Title: DjangoCon 2020 | How To Break Django: With Async - Andrew Godwin
Publication date: 2020-09-30
Playlist: DjangoCon Europe 2020 (Virtual)
Description: 
	DjangoCon Europe 2020 (Virtual)
September 19, 2020 - 17h10 (GMT+1)

"How To Break Django: With Async" by Andrew Godwin

Curious how to put your code into a deadlock? Want infinite loops, but in parallel? Or just want a new, exciting kind of data corruption? We'll look at these and other ways that asynchronous code can make you write some spectacularly nasty code, as well as the ways Django tries to save you from these terrible fates.


Note: Q&A not available due to technical problems.
Captions: 
	00:00:04,000 --> 00:00:06,080
hello everyone

00:00:05,200 --> 00:00:08,320
and i hope you're having a good

00:00:06,080 --> 00:00:09,920
djangocon so far i am

00:00:08,320 --> 00:00:12,080
very excited to be here to talk to you

00:00:09,920 --> 00:00:13,840
about the wonderful

00:00:12,080 --> 00:00:15,280
myriad number of ways you can break

00:00:13,840 --> 00:00:18,480
acing with django

00:00:15,280 --> 00:00:20,000
so let's get going first of all let's

00:00:18,480 --> 00:00:22,000
talk a bit about me

00:00:20,000 --> 00:00:24,160
i'm andrew if you've not met or seen me

00:00:22,000 --> 00:00:25,680
before i am a

00:00:24,160 --> 00:00:27,240
reasonably long time django developer

00:00:25,680 --> 00:00:28,800
i've been working on django since about

00:00:27,240 --> 00:00:30,400
2008-ish

00:00:28,800 --> 00:00:32,160
i've worked on things like south and

00:00:30,400 --> 00:00:33,040
django migrations and now the acing

00:00:32,160 --> 00:00:34,800
stuff

00:00:33,040 --> 00:00:36,880
i've been around a lot of places i've

00:00:34,800 --> 00:00:38,320
been doing django for quite a while

00:00:36,880 --> 00:00:39,920
and i still love this community

00:00:38,320 --> 00:00:41,200
everything it brings so thank you all

00:00:39,920 --> 00:00:43,200
for being who you are

00:00:41,200 --> 00:00:45,760
and crucially uh i'm unfortunately not

00:00:43,200 --> 00:00:48,079
in europe um i'm doing this remotely

00:00:45,760 --> 00:00:49,120
from the wonderful world of denver

00:00:48,079 --> 00:00:51,440
colorado

00:00:49,120 --> 00:00:54,079
um it is wonderfully beautiful here um

00:00:51,440 --> 00:00:56,399
we've been blessed with a pretty nice uh

00:00:54,079 --> 00:00:57,760
set of days here in autumn it snowed

00:00:56,399 --> 00:00:59,039
very recently which is an

00:00:57,760 --> 00:01:01,440
odd thing in september that's where

00:00:59,039 --> 00:01:02,879
things go but yeah i am sad not to be

00:01:01,440 --> 00:01:03,760
there with all of you in person but

00:01:02,879 --> 00:01:06,240
hopefully we will

00:01:03,760 --> 00:01:07,280
all meet again in person very soon if

00:01:06,240 --> 00:01:09,040
not next year

00:01:07,280 --> 00:01:10,960
but with that done let's talk about the

00:01:09,040 --> 00:01:13,439
good news the good news is

00:01:10,960 --> 00:01:14,799
async views are in django right now you

00:01:13,439 --> 00:01:16,479
can go use them

00:01:14,799 --> 00:01:18,240
you can just put async death with your

00:01:16,479 --> 00:01:19,040
views it will all intermingle and work

00:01:18,240 --> 00:01:20,560
perfectly

00:01:19,040 --> 00:01:22,720
i'm not going to go into too much detail

00:01:20,560 --> 00:01:24,799
here you can see more about this in my

00:01:22,720 --> 00:01:26,320
other talks i've given various places

00:01:24,799 --> 00:01:28,159
but the nice thing is you can just write

00:01:26,320 --> 00:01:29,759
views that are async def

00:01:28,159 --> 00:01:31,280
alongside normal defuse that are

00:01:29,759 --> 00:01:33,759
synchronous um

00:01:31,280 --> 00:01:35,840
thanks to some wonderful interior

00:01:33,759 --> 00:01:37,600
rewriting of django's request flow

00:01:35,840 --> 00:01:39,600
uh both of those are servers in both

00:01:37,600 --> 00:01:42,079
modes if you're running in wsgi

00:01:39,600 --> 00:01:43,680
mode then it will just work and serve

00:01:42,079 --> 00:01:44,320
synchronous views like normal with no

00:01:43,680 --> 00:01:46,560
performance

00:01:44,320 --> 00:01:48,640
impact and it will serve asynchronous

00:01:46,560 --> 00:01:49,119
views in their own like async mini event

00:01:48,640 --> 00:01:50,880
loop

00:01:49,119 --> 00:01:52,320
it's not as good for performance you

00:01:50,880 --> 00:01:53,360
can't do long polling and stuff

00:01:52,320 --> 00:01:55,119
and we still can still do

00:01:53,360 --> 00:01:55,759
parallelization and things like that and

00:01:55,119 --> 00:01:58,719
if you're in

00:01:55,759 --> 00:01:59,200
uh ws so if you're in asgi mode then of

00:01:58,719 --> 00:02:01,119
course

00:01:59,200 --> 00:02:03,119
you can run both synchronous analytics

00:02:01,119 --> 00:02:03,920
using that mode in the same way and the

00:02:03,119 --> 00:02:05,520
synchronous ones

00:02:03,920 --> 00:02:07,040
wrapped in their own thread so it's

00:02:05,520 --> 00:02:09,679
there it's good to use

00:02:07,040 --> 00:02:10,399
please go use it um i encourage you to

00:02:09,679 --> 00:02:12,239
have a go with it

00:02:10,399 --> 00:02:13,920
and then as you'll see in the rest of

00:02:12,239 --> 00:02:15,120
the talk i encourage you to go about it

00:02:13,920 --> 00:02:17,680
in a certain way

00:02:15,120 --> 00:02:18,959
so let's talk about that so first of all

00:02:17,680 --> 00:02:21,280
i want to be up front here

00:02:18,959 --> 00:02:22,879
synchronous programming is really quite

00:02:21,280 --> 00:02:25,920
safe as safe as programming

00:02:22,879 --> 00:02:27,599
can be anyway right um but like it's all

00:02:25,920 --> 00:02:29,599
in order you can understand how

00:02:27,599 --> 00:02:31,120
instructions execute one after the other

00:02:29,599 --> 00:02:32,560
it's a mental model we're all familiar

00:02:31,120 --> 00:02:33,920
with at least if you started out doing

00:02:32,560 --> 00:02:36,480
procedural programming

00:02:33,920 --> 00:02:37,920
if you did functional i mean a thank you

00:02:36,480 --> 00:02:39,360
and also i apologize

00:02:37,920 --> 00:02:41,440
and b i hope you still know how

00:02:39,360 --> 00:02:42,239
procedural stuff works i can't do monads

00:02:41,440 --> 00:02:43,440
very well

00:02:42,239 --> 00:02:45,280
but the point aside like we all

00:02:43,440 --> 00:02:46,319
understand how synchronous programming

00:02:45,280 --> 00:02:47,840
works

00:02:46,319 --> 00:02:49,519
asynchronous programming on the other

00:02:47,840 --> 00:02:51,599
hand is difficult

00:02:49,519 --> 00:02:53,200
now it's not impossible certainly but

00:02:51,599 --> 00:02:54,640
there's a lot more sort of subtleties to

00:02:53,200 --> 00:02:55,920
it and this is true not just of

00:02:54,640 --> 00:02:57,920
asynchronous programming but

00:02:55,920 --> 00:03:00,000
all concurrent programming in general be

00:02:57,920 --> 00:03:02,319
that asynchronous models like we have in

00:03:00,000 --> 00:03:04,319
python be that threading be it multiple

00:03:02,319 --> 00:03:05,680
processes be it across a network

00:03:04,319 --> 00:03:07,280
these are all concurrency problems

00:03:05,680 --> 00:03:08,159
you'll see versions of all the same

00:03:07,280 --> 00:03:09,360
problems

00:03:08,159 --> 00:03:11,760
in every single one of those kind of

00:03:09,360 --> 00:03:13,599
system designs but it is harder than

00:03:11,760 --> 00:03:14,959
writing code all by itself

00:03:13,599 --> 00:03:17,440
if you've ever worked on say like

00:03:14,959 --> 00:03:18,879
microservices or distributed systems you

00:03:17,440 --> 00:03:20,319
know this all too well

00:03:18,879 --> 00:03:21,920
and in many ways asynchronous

00:03:20,319 --> 00:03:22,480
programming is inviting those same

00:03:21,920 --> 00:03:24,879
problems

00:03:22,480 --> 00:03:26,080
into your code base where normally

00:03:24,879 --> 00:03:28,159
things were safer

00:03:26,080 --> 00:03:29,440
and so i want to kind of talk about the

00:03:28,159 --> 00:03:30,319
kind of things you can see when writing

00:03:29,440 --> 00:03:31,680
async code

00:03:30,319 --> 00:03:34,159
and certainly the things that i have run

00:03:31,680 --> 00:03:35,519
across personally now i learn best by

00:03:34,159 --> 00:03:36,640
example so these are all a set of

00:03:35,519 --> 00:03:38,400
examples of

00:03:36,640 --> 00:03:39,680
mistakes i have made at one point or

00:03:38,400 --> 00:03:41,760
another throughout the years

00:03:39,680 --> 00:03:43,599
i do encourage you to try these at home

00:03:41,760 --> 00:03:45,040
but do not try them in production

00:03:43,599 --> 00:03:46,560
you want to try them away from having

00:03:45,040 --> 00:03:47,760
actual users where you can experiment

00:03:46,560 --> 00:03:49,440
and learn from them that's my

00:03:47,760 --> 00:03:51,760
recommendation

00:03:49,440 --> 00:03:53,599
so with that done let's go and look at

00:03:51,760 --> 00:03:55,439
what we can do in django with async

00:03:53,599 --> 00:03:57,200
and i went you know i led off here with

00:03:55,439 --> 00:03:58,000
like great async views are in we can put

00:03:57,200 --> 00:04:00,560
async def in

00:03:58,000 --> 00:04:02,560
fantastic there we go there's an async

00:04:00,560 --> 00:04:04,400
view i've taken an existing view i had

00:04:02,560 --> 00:04:05,920
i put async in front of it let's go

00:04:04,400 --> 00:04:08,879
let's hit run

00:04:05,920 --> 00:04:10,480
this isn't going to work now there's a

00:04:08,879 --> 00:04:12,640
couple of reasons not going to work

00:04:10,480 --> 00:04:14,239
the first one is and the main problem is

00:04:12,640 --> 00:04:14,879
it actually would have worked in some

00:04:14,239 --> 00:04:16,880
ways

00:04:14,879 --> 00:04:19,199
if django hadn't stopped you doing this

00:04:16,880 --> 00:04:22,000
this is perfectly valid python code

00:04:19,199 --> 00:04:23,040
it will run and compile and execute and

00:04:22,000 --> 00:04:24,880
what it will do

00:04:23,040 --> 00:04:26,080
is it will start an asynchronous view in

00:04:24,880 --> 00:04:28,240
its own core routine

00:04:26,080 --> 00:04:29,280
it will then get to this dot get line

00:04:28,240 --> 00:04:30,320
here where the book they're trying to

00:04:29,280 --> 00:04:32,080
fetch the book

00:04:30,320 --> 00:04:33,680
and then it will synchronously go

00:04:32,080 --> 00:04:35,040
towards the database and block the whole

00:04:33,680 --> 00:04:37,360
apparently while it's doing so

00:04:35,040 --> 00:04:39,360
for maybe up to a couple of seconds and

00:04:37,360 --> 00:04:41,360
then come back and return

00:04:39,360 --> 00:04:42,720
now the way asynchronous programming

00:04:41,360 --> 00:04:43,040
works in python is it's called what's

00:04:42,720 --> 00:04:45,280
called

00:04:43,040 --> 00:04:47,680
cooperative multitasking you have to

00:04:45,280 --> 00:04:49,600
cooperate and tell python hey

00:04:47,680 --> 00:04:51,759
here is a point where you can pause my

00:04:49,600 --> 00:04:53,280
execution and go and run other things

00:04:51,759 --> 00:04:56,400
it's still single threaded on a single

00:04:53,280 --> 00:04:58,880
core the gil is still there so

00:04:56,400 --> 00:05:01,039
if you don't have an await that kind of

00:04:58,880 --> 00:05:02,720
like cooperative thing in your code

00:05:01,039 --> 00:05:04,960
it can't return so this would actually

00:05:02,720 --> 00:05:06,240
just run and it would run and block the

00:05:04,960 --> 00:05:09,520
event loop for

00:05:06,240 --> 00:05:11,759
50 100 200 maybe 500 milliseconds

00:05:09,520 --> 00:05:12,720
and that's really bad because you would

00:05:11,759 --> 00:05:14,720
take this code

00:05:12,720 --> 00:05:16,000
you'd run it it would pass unit tests it

00:05:14,720 --> 00:05:18,080
would work in your browser

00:05:16,000 --> 00:05:20,400
you push it to production and it would

00:05:18,080 --> 00:05:21,520
work but it wouldn't be very efficient

00:05:20,400 --> 00:05:23,520
it's probably less efficient than the

00:05:21,520 --> 00:05:24,720
old synchronous code because you're

00:05:23,520 --> 00:05:26,080
blocking the event loop it doesn't like

00:05:24,720 --> 00:05:27,440
that it's not designed for that

00:05:26,080 --> 00:05:29,280
and so your launch is like what that's

00:05:27,440 --> 00:05:30,960
weird why are we getting like weird slow

00:05:29,280 --> 00:05:32,960
down what's going on the code looks and

00:05:30,960 --> 00:05:34,960
runs fine it passes tests

00:05:32,960 --> 00:05:36,560
these are the worst kinds of failures

00:05:34,960 --> 00:05:38,400
they're called silent failures in my

00:05:36,560 --> 00:05:39,840
personal vocabulary i do

00:05:38,400 --> 00:05:42,160
everything i can to hunt them down and

00:05:39,840 --> 00:05:43,680
stop them this is no exception

00:05:42,160 --> 00:05:45,280
now first of all let's talk about how

00:05:43,680 --> 00:05:46,160
you're meant to do this which is like

00:05:45,280 --> 00:05:48,160
this

00:05:46,160 --> 00:05:49,280
um our friend the awake keyword is

00:05:48,160 --> 00:05:50,960
turned up right there

00:05:49,280 --> 00:05:53,360
very important it tells the function

00:05:50,960 --> 00:05:55,039
that you can for the co routine it can

00:05:53,360 --> 00:05:57,199
pause there and hand control back to

00:05:55,039 --> 00:05:58,880
python but crucially as well um we also

00:05:57,199 --> 00:06:00,080
have a different version of get here you

00:05:58,880 --> 00:06:03,759
see right there

00:06:00,080 --> 00:06:05,360
um the way pythons

00:06:03,759 --> 00:06:06,960
works and this is you can read more

00:06:05,360 --> 00:06:09,039
about this in my um

00:06:06,960 --> 00:06:10,560
djangocon au talk about the orm and

00:06:09,039 --> 00:06:11,680
trying to make it async like this isn't

00:06:10,560 --> 00:06:12,479
real code yet we haven't got an

00:06:11,680 --> 00:06:14,639
asynchronous

00:06:12,479 --> 00:06:15,520
example um but like we have to have

00:06:14,639 --> 00:06:17,360
different

00:06:15,520 --> 00:06:18,560
uh callables for synchronous

00:06:17,360 --> 00:06:20,240
asynchronous modes

00:06:18,560 --> 00:06:22,560
so we can't just have dot get work with

00:06:20,240 --> 00:06:23,520
async we have to have dot get async

00:06:22,560 --> 00:06:25,759
and so that's kind of the difference

00:06:23,520 --> 00:06:27,440
here the two things you can see there's

00:06:25,759 --> 00:06:29,520
also one more thing right so like

00:06:27,440 --> 00:06:31,280
this is fine this will work once there's

00:06:29,520 --> 00:06:32,080
an asynchronom again it's not in yet

00:06:31,280 --> 00:06:35,199
this is kind of a

00:06:32,080 --> 00:06:36,319
demonstration it would look like now

00:06:35,199 --> 00:06:38,720
what happens though if you do this

00:06:36,319 --> 00:06:41,840
previous one well thankfully

00:06:38,720 --> 00:06:43,360
i kept doing this and it kept basically

00:06:41,840 --> 00:06:44,960
screwing up all my tests

00:06:43,360 --> 00:06:47,280
and so what django has it has this

00:06:44,960 --> 00:06:49,280
exception if you try and do anything in

00:06:47,280 --> 00:06:50,639
django with database right now

00:06:49,280 --> 00:06:52,560
because all database access is still

00:06:50,639 --> 00:06:54,560
currently synchronous in django

00:06:52,560 --> 00:06:55,680
you will get this error this is a

00:06:54,560 --> 00:06:58,160
synchronous only

00:06:55,680 --> 00:06:59,759
operation exception it basically tells

00:06:58,160 --> 00:07:01,280
you you have tried to call a piece of

00:06:59,759 --> 00:07:03,599
chango that is synchronous

00:07:01,280 --> 00:07:05,759
probably the rm from an asynchronous

00:07:03,599 --> 00:07:07,280
context you shouldn't be doing this

00:07:05,759 --> 00:07:09,360
you should be wrapping that code in a

00:07:07,280 --> 00:07:10,720
sync to acing cool we'll see that later

00:07:09,360 --> 00:07:13,440
and that'll be much safer way of doing

00:07:10,720 --> 00:07:14,720
it now this is what i call a guard rail

00:07:13,440 --> 00:07:16,560
there's many of these as you'll see

00:07:14,720 --> 00:07:17,759
and that we can add and do have in

00:07:16,560 --> 00:07:20,800
django as we go along

00:07:17,759 --> 00:07:22,639
but this turns a silent failure or

00:07:20,800 --> 00:07:24,240
you know a silent performance slow down

00:07:22,639 --> 00:07:24,880
into an explicit failure and in my

00:07:24,240 --> 00:07:26,800
opinion

00:07:24,880 --> 00:07:28,319
that's the way to go about things this

00:07:26,800 --> 00:07:28,960
way there's no way you can write that

00:07:28,319 --> 00:07:30,319
first

00:07:28,960 --> 00:07:31,840
piece of code and have it past tests

00:07:30,319 --> 00:07:32,880
generally like no but you do it what are

00:07:31,840 --> 00:07:33,919
you doing this is a synchronous

00:07:32,880 --> 00:07:37,120
operation stop it

00:07:33,919 --> 00:07:38,479
that's kind of the idea now there's

00:07:37,120 --> 00:07:39,840
another kind of mistake you can make

00:07:38,479 --> 00:07:40,800
this is the same code we saw here on

00:07:39,840 --> 00:07:42,240
this previous slide

00:07:40,800 --> 00:07:44,400
but there's one thing missing and it's

00:07:42,240 --> 00:07:45,039
that of weight what happens if you miss

00:07:44,400 --> 00:07:47,759
awaits

00:07:45,039 --> 00:07:49,440
well there's two things first of all any

00:07:47,759 --> 00:07:51,120
side effects of it don't happen and this

00:07:49,440 --> 00:07:52,960
is a get it's not too problematic

00:07:51,120 --> 00:07:54,800
imagine it was a create though if that

00:07:52,960 --> 00:07:56,080
was a create it wouldn't actually run i

00:07:54,800 --> 00:07:58,960
wouldn't make anything

00:07:56,080 --> 00:07:59,680
so that's the first problem secondly um

00:07:58,960 --> 00:08:01,039
because

00:07:59,680 --> 00:08:02,879
asynchronous callables return a

00:08:01,039 --> 00:08:04,080
co-routine basically a weight is looking

00:08:02,879 --> 00:08:04,960
for a thing to consume which is a

00:08:04,080 --> 00:08:06,720
co-routine

00:08:04,960 --> 00:08:08,160
if you don't have an await there you

00:08:06,720 --> 00:08:08,639
just have a codeine object because in

00:08:08,160 --> 00:08:10,479
python

00:08:08,639 --> 00:08:12,240
everything's an object and that coding

00:08:10,479 --> 00:08:14,319
object in this example becomes book

00:08:12,240 --> 00:08:16,240
you pass as a template and you're like

00:08:14,319 --> 00:08:18,160
and then somebody's like i can't do

00:08:16,240 --> 00:08:20,080
dot name of a co routine what are you

00:08:18,160 --> 00:08:21,360
doing and then you get more exceptions

00:08:20,080 --> 00:08:23,440
so thankfully this is this isn't really

00:08:21,360 --> 00:08:24,720
a silent exception in this case

00:08:23,440 --> 00:08:26,800
it does become a problem as we'll see

00:08:24,720 --> 00:08:28,160
later when you have just a side effect

00:08:26,800 --> 00:08:28,879
and no variable assignment and you can't

00:08:28,160 --> 00:08:30,639
detect it

00:08:28,879 --> 00:08:33,200
but thankfully python's got a guardrail

00:08:30,639 --> 00:08:35,760
for you we'll look at that in a bit

00:08:33,200 --> 00:08:38,000
so in this particular case at least the

00:08:35,760 --> 00:08:38,560
most basic example that i made so many

00:08:38,000 --> 00:08:40,640
times

00:08:38,560 --> 00:08:42,080
django's got your back now this is a

00:08:40,640 --> 00:08:44,159
principle we'll try and return to

00:08:42,080 --> 00:08:45,200
like django's goal in my opinion is to

00:08:44,159 --> 00:08:47,120
be a safety net

00:08:45,200 --> 00:08:49,040
to give you guard rails that when you're

00:08:47,120 --> 00:08:51,279
comfortable you can remove one by one

00:08:49,040 --> 00:08:52,640
by by default they're there in place

00:08:51,279 --> 00:08:53,200
basically preventing you from doing bad

00:08:52,640 --> 00:08:54,640
stuff

00:08:53,200 --> 00:08:56,560
and that's just one of the examples i

00:08:54,640 --> 00:08:58,160
think the main example that many people

00:08:56,560 --> 00:08:59,120
run into they first try to do async code

00:08:58,160 --> 00:08:59,600
like oh yeah let's try it and they're

00:08:59,120 --> 00:09:01,440
like

00:08:59,600 --> 00:09:03,600
what is this exception that's what it is

00:09:01,440 --> 00:09:04,880
you need to do things a different way

00:09:03,600 --> 00:09:06,240
and the reason you do the different way

00:09:04,880 --> 00:09:07,279
is dangerous if you do it the first way

00:09:06,240 --> 00:09:08,959
and you wouldn't notice

00:09:07,279 --> 00:09:11,200
in the worst case so here's another

00:09:08,959 --> 00:09:14,399
example i have often said

00:09:11,200 --> 00:09:15,360
that the key thing about doing things in

00:09:14,399 --> 00:09:17,200
async world is

00:09:15,360 --> 00:09:18,800
parallelization running two things at

00:09:17,200 --> 00:09:19,680
once or three things or four things at

00:09:18,800 --> 00:09:21,600
once

00:09:19,680 --> 00:09:23,440
and here's a perfect example i have a

00:09:21,600 --> 00:09:24,320
situation where i have a view that makes

00:09:23,440 --> 00:09:26,320
a user account

00:09:24,320 --> 00:09:27,519
it has two things it writes a user row

00:09:26,320 --> 00:09:29,360
that takes a network called

00:09:27,519 --> 00:09:31,279
postgres that takes time and needs to be

00:09:29,360 --> 00:09:33,600
async it also sends an email

00:09:31,279 --> 00:09:35,200
that takes smtp and could be async as

00:09:33,600 --> 00:09:37,279
well both these things happen

00:09:35,200 --> 00:09:39,120
asynchronously great let's do them at

00:09:37,279 --> 00:09:42,320
once and have them run in parallel

00:09:39,120 --> 00:09:43,440
fantastic what could go wrong well again

00:09:42,320 --> 00:09:44,959
this is one of those subtle things where

00:09:43,440 --> 00:09:45,680
like it's not quite the same as you do

00:09:44,959 --> 00:09:48,240
it in

00:09:45,680 --> 00:09:49,760
sort of normal synchronous mode there is

00:09:48,240 --> 00:09:51,920
no ordering guarantee

00:09:49,760 --> 00:09:53,120
so if you're not familiar um this async

00:09:51,920 --> 00:09:54,800
io.weight here

00:09:53,120 --> 00:09:56,959
that's the primitive function in async

00:09:54,800 --> 00:09:57,760
that takes a set of things and runs them

00:09:56,959 --> 00:09:59,760
in parallel

00:09:57,760 --> 00:10:01,600
and then returns when they're all done

00:09:59,760 --> 00:10:02,640
and obviously you can pass it a whole

00:10:01,600 --> 00:10:04,240
number of things

00:10:02,640 --> 00:10:06,800
but there is literally no ordering

00:10:04,240 --> 00:10:08,640
guarantee you could run

00:10:06,800 --> 00:10:09,839
one thing first and then the other thing

00:10:08,640 --> 00:10:12,480
both in parallel

00:10:09,839 --> 00:10:13,360
or crucially you could run one thing and

00:10:12,480 --> 00:10:14,640
then the other thing

00:10:13,360 --> 00:10:17,360
might not happen with the process has

00:10:14,640 --> 00:10:19,600
crashed so imagine in this case

00:10:17,360 --> 00:10:21,600
um there are two different failure modes

00:10:19,600 --> 00:10:22,800
in this case i could have my create user

00:10:21,600 --> 00:10:25,120
account function run

00:10:22,800 --> 00:10:26,800
and write a row and then the process

00:10:25,120 --> 00:10:29,040
crashes before it sends an email

00:10:26,800 --> 00:10:30,399
or i could have the send email function

00:10:29,040 --> 00:10:31,839
run and send an email

00:10:30,399 --> 00:10:33,600
and then it crashes before it writes a

00:10:31,839 --> 00:10:35,920
user character database

00:10:33,600 --> 00:10:37,760
and that's two different failure modes

00:10:35,920 --> 00:10:39,279
now maybe you're okay with both of those

00:10:37,760 --> 00:10:40,320
but i prefer having less failure modes

00:10:39,279 --> 00:10:42,240
that i know

00:10:40,320 --> 00:10:44,160
and so in my opinion when you're doing

00:10:42,240 --> 00:10:46,160
things like this with side effects that

00:10:44,160 --> 00:10:47,519
kind of have an implicit dependency you

00:10:46,160 --> 00:10:48,880
want to do something more like this

00:10:47,519 --> 00:10:50,560
where like in my opinion it's much

00:10:48,880 --> 00:10:51,120
better to have like only one failure

00:10:50,560 --> 00:10:52,480
mode

00:10:51,120 --> 00:10:54,160
and that failure mode is we made the

00:10:52,480 --> 00:10:56,720
account that's didn't send you an email

00:10:54,160 --> 00:10:58,800
by explicitly ordering them we can do

00:10:56,720 --> 00:11:01,040
that we can have it okay account made

00:10:58,800 --> 00:11:02,399
then if it crashes it crashes that's bad

00:11:01,040 --> 00:11:04,240
hopefully it doesn't happen very often

00:11:02,399 --> 00:11:05,839
and then email's sent much better way

00:11:04,240 --> 00:11:06,880
around now of course this is only

00:11:05,839 --> 00:11:09,600
problem for things with

00:11:06,880 --> 00:11:11,120
side effects if you're in parallel just

00:11:09,600 --> 00:11:12,880
querying getting data and then

00:11:11,120 --> 00:11:14,160
returning a result from it that's very

00:11:12,880 --> 00:11:16,320
safe tapered in parallel

00:11:14,160 --> 00:11:17,519
but if you're not doing those things if

00:11:16,320 --> 00:11:19,040
you're doing side effects

00:11:17,519 --> 00:11:21,040
be very cautious doing things in

00:11:19,040 --> 00:11:22,480
parallel it's very tempting you can get

00:11:21,040 --> 00:11:23,600
amazing speed ups from doing your

00:11:22,480 --> 00:11:25,279
queries in parallel

00:11:23,600 --> 00:11:27,920
i think if you had like a view with 20

00:11:25,279 --> 00:11:29,120
queries and you did all 20 queries in

00:11:27,920 --> 00:11:30,800
parallel you could probably get it down

00:11:29,120 --> 00:11:32,880
like a tenth of the time

00:11:30,800 --> 00:11:34,399
but you've got to be aware of the extra

00:11:32,880 --> 00:11:35,760
layers of failure you're adding

00:11:34,399 --> 00:11:37,680
imagine there wasn't just two of these

00:11:35,760 --> 00:11:39,279
there was like five different things

00:11:37,680 --> 00:11:40,880
the number of combinations of how they

00:11:39,279 --> 00:11:42,959
can now go wrong and what can run on

00:11:40,880 --> 00:11:46,000
what can't if they're all paralyzed

00:11:42,959 --> 00:11:47,920
is enormous so be very careful of that

00:11:46,000 --> 00:11:49,760
and unfortunately in this case there's

00:11:47,920 --> 00:11:50,720
not a good way to prevent against it we

00:11:49,760 --> 00:11:52,320
can't detect it

00:11:50,720 --> 00:11:55,040
this is a thing called a race condition

00:11:52,320 --> 00:11:57,360
it's a classic thing in concurrency

00:11:55,040 --> 00:11:59,600
um you can read so much about it on the

00:11:57,360 --> 00:12:01,839
internet i couldn't do it justice here

00:11:59,600 --> 00:12:03,120
but essentially these are just a fact of

00:12:01,839 --> 00:12:04,959
life with concurrent

00:12:03,120 --> 00:12:07,040
programming asynchronous being part of

00:12:04,959 --> 00:12:08,560
that you can't really prevent them apart

00:12:07,040 --> 00:12:10,480
from structuring your code well

00:12:08,560 --> 00:12:12,160
it's kind of a path you have to tread

00:12:10,480 --> 00:12:12,959
yourself you can do things to help

00:12:12,160 --> 00:12:14,399
prevent them

00:12:12,959 --> 00:12:16,399
there are some things you can do to aid

00:12:14,399 --> 00:12:17,760
yourself but in the end it's kind of

00:12:16,399 --> 00:12:19,440
part of the territory

00:12:17,760 --> 00:12:21,040
in some ways the direct trade-off of

00:12:19,440 --> 00:12:23,120
when you ask for performance

00:12:21,040 --> 00:12:24,880
this is what you get this is what you

00:12:23,120 --> 00:12:26,240
know computers and processes and kernels

00:12:24,880 --> 00:12:28,560
handle as well like those things run

00:12:26,240 --> 00:12:30,160
asynchronously in some sense and they

00:12:28,560 --> 00:12:31,600
they have to handle plenty of race

00:12:30,160 --> 00:12:32,959
conditions

00:12:31,600 --> 00:12:34,639
so let's change tracks a bit though and

00:12:32,959 --> 00:12:37,519
talk about uh database access

00:12:34,639 --> 00:12:39,519
again now david texas as i said there is

00:12:37,519 --> 00:12:42,000
no async orb in january 3.1

00:12:39,519 --> 00:12:43,200
unfortunately i'm sorry it takes time so

00:12:42,000 --> 00:12:43,920
instead if you want to talk to the

00:12:43,200 --> 00:12:45,839
database

00:12:43,920 --> 00:12:47,200
you can't do it in an asynchronous

00:12:45,839 --> 00:12:48,240
thread so you need to do it in a

00:12:47,200 --> 00:12:49,760
synchronous thread

00:12:48,240 --> 00:12:51,279
what you do is this you can write your

00:12:49,760 --> 00:12:53,279
database code in a function

00:12:51,279 --> 00:12:55,440
a synchronous function and wrap it in

00:12:53,279 --> 00:12:57,040
the sync to async decorator

00:12:55,440 --> 00:12:58,880
and what that does is it takes any

00:12:57,040 --> 00:13:00,480
synchronous callable and turns it into

00:12:58,880 --> 00:13:02,880
an asynchronous awaitable

00:13:00,480 --> 00:13:03,600
so with this code is written here i can

00:13:02,880 --> 00:13:04,800
actually await

00:13:03,600 --> 00:13:07,120
create user account and it will

00:13:04,800 --> 00:13:08,320
correctly make a sub thread run the code

00:13:07,120 --> 00:13:08,800
there so it doesn't block the main

00:13:08,320 --> 00:13:10,320
thread

00:13:08,800 --> 00:13:11,760
and then when the results come back

00:13:10,320 --> 00:13:12,399
wakes up the code routine and it returns

00:13:11,760 --> 00:13:13,920
it the result

00:13:12,399 --> 00:13:15,760
and does exception propagation and stuff

00:13:13,920 --> 00:13:17,519
properly it's all done there for you

00:13:15,760 --> 00:13:19,040
we ship this as part of django these

00:13:17,519 --> 00:13:20,639
days there's a reason we recommend you

00:13:19,040 --> 00:13:21,680
use it it's much easier than anything

00:13:20,639 --> 00:13:24,399
else

00:13:21,680 --> 00:13:25,839
however it's not quite perfect so

00:13:24,399 --> 00:13:26,399
imagine i did this like i've written

00:13:25,839 --> 00:13:28,160
code

00:13:26,399 --> 00:13:29,839
i've got stuff that let's say again does

00:13:28,160 --> 00:13:30,720
two different things it does a classic

00:13:29,839 --> 00:13:32,959
example of

00:13:30,720 --> 00:13:34,399
validates a user account name and then

00:13:32,959 --> 00:13:35,680
writes a user account row

00:13:34,399 --> 00:13:37,839
and because i want to reuse my

00:13:35,680 --> 00:13:38,079
validation logic on say my signup form

00:13:37,839 --> 00:13:40,000
to

00:13:38,079 --> 00:13:42,079
have like a little ticker across i made

00:13:40,000 --> 00:13:45,279
the validation logic a separate function

00:13:42,079 --> 00:13:48,079
but of course obviously i am a

00:13:45,279 --> 00:13:48,639
moderately okay developer i know that

00:13:48,079 --> 00:13:51,760
hey

00:13:48,639 --> 00:13:52,399
if i don't do check username exists and

00:13:51,760 --> 00:13:54,639
then

00:13:52,399 --> 00:13:56,320
write user inside a transaction i can

00:13:54,639 --> 00:13:58,240
have another race condition where

00:13:56,320 --> 00:14:00,240
well two requests come in with the same

00:13:58,240 --> 00:14:00,959
username both check it doesn't exist

00:14:00,240 --> 00:14:02,800
both go

00:14:00,959 --> 00:14:04,160
yep not written database and then both

00:14:02,800 --> 00:14:05,600
write it in and they clash

00:14:04,160 --> 00:14:07,519
so that's why we have transactions right

00:14:05,600 --> 00:14:08,000
and so i'd be like okay great i know

00:14:07,519 --> 00:14:10,560
this

00:14:08,000 --> 00:14:11,839
i'm gonna write this code right here and

00:14:10,560 --> 00:14:14,399
again

00:14:11,839 --> 00:14:16,000
to the naive python runtime this code is

00:14:14,399 --> 00:14:18,639
perfectly fine

00:14:16,000 --> 00:14:19,920
because transaction will find the

00:14:18,639 --> 00:14:21,279
connection on its thread

00:14:19,920 --> 00:14:23,040
it will set transaction up on it and

00:14:21,279 --> 00:14:25,279
wait for stuff to run in it

00:14:23,040 --> 00:14:27,279
now here's the problem i just told you

00:14:25,279 --> 00:14:28,240
that sync to async runs things in

00:14:27,279 --> 00:14:30,639
different threads

00:14:28,240 --> 00:14:31,360
and it does and transactions connections

00:14:30,639 --> 00:14:33,440
in django

00:14:31,360 --> 00:14:35,120
are threadbound so what this code

00:14:33,440 --> 00:14:36,160
actually does if those asynchronous

00:14:35,120 --> 00:14:38,240
pieces of code

00:14:36,160 --> 00:14:39,279
is it sets up a transaction on the async

00:14:38,240 --> 00:14:42,320
thread

00:14:39,279 --> 00:14:44,079
doesn't use it at all makes a brand new

00:14:42,320 --> 00:14:46,000
synchronous thread and then in that

00:14:44,079 --> 00:14:46,560
synchronous thread it runs things

00:14:46,000 --> 00:14:49,199
outside of

00:14:46,560 --> 00:14:49,839
a transaction and again this is silent

00:14:49,199 --> 00:14:52,160
failure

00:14:49,839 --> 00:14:54,000
this won't actually fail it probably

00:14:52,160 --> 00:14:54,800
will pass all of your unit tests most

00:14:54,000 --> 00:14:57,519
likely

00:14:54,800 --> 00:14:59,040
until you get those two requests just

00:14:57,519 --> 00:15:00,560
perfectly timed to hit each other and go

00:14:59,040 --> 00:15:03,199
around with the transactions protecting

00:15:00,560 --> 00:15:05,040
and bam you've got data corruption and

00:15:03,199 --> 00:15:05,920
again this is silent failure it's really

00:15:05,040 --> 00:15:08,240
annoying

00:15:05,920 --> 00:15:09,680
now again django can detect that hey you

00:15:08,240 --> 00:15:11,839
shouldn't be using transactions

00:15:09,680 --> 00:15:12,880
in asynchronous in an asynchronous

00:15:11,839 --> 00:15:14,800
environment right

00:15:12,880 --> 00:15:17,360
that we can do but this is more a

00:15:14,800 --> 00:15:19,600
problem for when we do have an asynchron

00:15:17,360 --> 00:15:21,519
because what if you do genuinely write

00:15:19,600 --> 00:15:22,480
this code and we support async

00:15:21,519 --> 00:15:25,120
transactions

00:15:22,480 --> 00:15:26,480
what do we do do we error do we try and

00:15:25,120 --> 00:15:27,199
port the transaction over to the other

00:15:26,480 --> 00:15:28,959
thread

00:15:27,199 --> 00:15:30,399
like do we silently fail not do that

00:15:28,959 --> 00:15:31,519
obviously it's terrible but these are

00:15:30,399 --> 00:15:33,040
kind of the problems with asynchronous

00:15:31,519 --> 00:15:33,839
design and like especially context

00:15:33,040 --> 00:15:36,399
managers not

00:15:33,839 --> 00:15:39,600
kind of going and wrapping the code

00:15:36,399 --> 00:15:41,279
below them as you think they should do

00:15:39,600 --> 00:15:42,880
and in my opinion not having

00:15:41,279 --> 00:15:44,399
transactions is one of the scariest

00:15:42,880 --> 00:15:46,320
failure modes because

00:15:44,399 --> 00:15:48,240
it is really a thing that's very hard to

00:15:46,320 --> 00:15:49,600
test like honestly try writing tests for

00:15:48,240 --> 00:15:51,440
it's almost impossible to do that you

00:15:49,600 --> 00:15:53,199
perfectly write the code sequentially

00:15:51,440 --> 00:15:55,279
and certainly having code as a single

00:15:53,199 --> 00:15:57,920
opaque block is pretty difficult

00:15:55,279 --> 00:15:59,199
but at the same time it doesn't really

00:15:57,920 --> 00:16:00,079
happen a lot in production when it does

00:15:59,199 --> 00:16:01,519
it's really bad

00:16:00,079 --> 00:16:03,279
like your foreign keys stop pouring to

00:16:01,519 --> 00:16:04,160
the right place you get dependency

00:16:03,279 --> 00:16:06,079
errors or like

00:16:04,160 --> 00:16:07,759
things just get messed up so i want to

00:16:06,079 --> 00:16:09,120
avoid this at all costs

00:16:07,759 --> 00:16:11,519
we're going to look deeply into how to

00:16:09,120 --> 00:16:12,560
solve this in the proper asynchron

00:16:11,519 --> 00:16:14,160
and again if you want to learn more

00:16:12,560 --> 00:16:16,240
about that i opine a bit on this

00:16:14,160 --> 00:16:17,199
particular topic in my djangocon au talk

00:16:16,240 --> 00:16:18,880
this year

00:16:17,199 --> 00:16:20,959
but it's still kind of a hairy problem

00:16:18,880 --> 00:16:23,040
by itself

00:16:20,959 --> 00:16:24,240
so let's go away from databases now and

00:16:23,040 --> 00:16:27,040
talk about

00:16:24,240 --> 00:16:28,320
fetching fetching urls in parallel um

00:16:27,040 --> 00:16:29,040
classic example of thing you do with

00:16:28,320 --> 00:16:31,519
async

00:16:29,040 --> 00:16:32,800
let's say here i have 100 urls i want to

00:16:31,519 --> 00:16:33,920
fetch all of them and see which ones are

00:16:32,800 --> 00:16:35,759
still alive

00:16:33,920 --> 00:16:38,000
because you know good urls don't change

00:16:35,759 --> 00:16:39,839
but many urls die over time

00:16:38,000 --> 00:16:41,040
so code like this is what i might write

00:16:39,839 --> 00:16:43,040
and it basically you know

00:16:41,040 --> 00:16:44,320
has a nice uh async code.wait so you've

00:16:43,040 --> 00:16:46,320
seen this weight before

00:16:44,320 --> 00:16:47,920
we're feeding a list comprehension with

00:16:46,320 --> 00:16:48,320
all the urls it's going to take all

00:16:47,920 --> 00:16:50,399
those

00:16:48,320 --> 00:16:52,000
co routines it says 100 of them it's

00:16:50,399 --> 00:16:54,079
going to run them all in parallel

00:16:52,000 --> 00:16:55,759
efficiently at once and then collect all

00:16:54,079 --> 00:16:57,199
the results and then return it to us

00:16:55,759 --> 00:16:58,720
as you see at the top there we have a

00:16:57,199 --> 00:16:59,759
dictionary that's counting the number of

00:16:58,720 --> 00:17:02,880
things that are live

00:16:59,759 --> 00:17:05,839
and dead now if you look closely at the

00:17:02,880 --> 00:17:05,839
inside of our fetch

00:17:17,439 --> 00:17:20,559
and a weight though there crucially and

00:17:19,760 --> 00:17:22,559
then

00:17:20,559 --> 00:17:23,600
we write back the value of a live plus

00:17:22,559 --> 00:17:26,799
one

00:17:23,600 --> 00:17:27,919
now you can imagine that like if there

00:17:26,799 --> 00:17:29,760
are many things running at once which of

00:17:27,919 --> 00:17:31,120
course there are by design

00:17:29,760 --> 00:17:33,200
many of them can fetch you live and

00:17:31,120 --> 00:17:34,880
they'll all be zero and then all go and

00:17:33,200 --> 00:17:35,760
do their request and then it's like the

00:17:34,880 --> 00:17:37,679
first one

00:17:35,760 --> 00:17:39,200
fetches alive does its request then

00:17:37,679 --> 00:17:41,039
suspends second one

00:17:39,200 --> 00:17:43,039
then goes in fetches live suspends and

00:17:41,039 --> 00:17:44,720
so on when they all come back

00:17:43,039 --> 00:17:46,240
they've kept the value of a live in the

00:17:44,720 --> 00:17:47,840
local memory area

00:17:46,240 --> 00:17:50,160
but it's wrong they've all got the wrong

00:17:47,840 --> 00:17:50,880
number again this is a classic race

00:17:50,160 --> 00:17:52,559
condition

00:17:50,880 --> 00:17:54,080
what we've done here is we have a piece

00:17:52,559 --> 00:17:55,200
of code that isn't atomic where it

00:17:54,080 --> 00:17:58,000
should be

00:17:55,200 --> 00:17:59,360
now here's the fun thing in threading

00:17:58,000 --> 00:18:01,840
this is very hard to solve

00:17:59,360 --> 00:18:02,880
but in async we can just do this we can

00:18:01,840 --> 00:18:05,280
switch that away

00:18:02,880 --> 00:18:06,480
fetch um with the await and the fetch

00:18:05,280 --> 00:18:08,559
for alive

00:18:06,480 --> 00:18:10,960
um basically in place and what this

00:18:08,559 --> 00:18:11,520
means now is the alive is next to where

00:18:10,960 --> 00:18:13,600
it's written

00:18:11,520 --> 00:18:14,799
it's kind of a single block and with

00:18:13,600 --> 00:18:17,919
async io

00:18:14,799 --> 00:18:19,840
things are atomic between a weights

00:18:17,919 --> 00:18:21,840
so if there's a weight and a second

00:18:19,840 --> 00:18:23,440
await everything between those two

00:18:21,840 --> 00:18:25,200
is gonna run atomically nothing can

00:18:23,440 --> 00:18:26,720
barge in remember it's cooperative

00:18:25,200 --> 00:18:28,559
multitasking if you're not gonna await

00:18:26,720 --> 00:18:31,360
nothing can come in and stop you

00:18:28,559 --> 00:18:32,240
so in async this is perfectly valid code

00:18:31,360 --> 00:18:34,640
and we save

00:18:32,240 --> 00:18:36,720
in threading however this is not safe

00:18:34,640 --> 00:18:38,240
threads can interrupt wherever they want

00:18:36,720 --> 00:18:39,840
and they can just jump in and go hey

00:18:38,240 --> 00:18:42,160
nope this line we're going to stop

00:18:39,840 --> 00:18:43,600
so crucially they can interrupt between

00:18:42,160 --> 00:18:45,440
reading a weight and writing a weight

00:18:43,600 --> 00:18:47,600
and there's nothing you can do about it

00:18:45,440 --> 00:18:48,880
so in the threading world you need a

00:18:47,600 --> 00:18:51,280
lock or something here

00:18:48,880 --> 00:18:52,480
but in async oh thankfully we have a

00:18:51,280 --> 00:18:55,039
nice property that

00:18:52,480 --> 00:18:56,400
between awaits things are atomic and

00:18:55,039 --> 00:18:57,600
this is one of the nice things about the

00:18:56,400 --> 00:18:59,120
trade-offs of like you know

00:18:57,600 --> 00:19:01,360
there are good and bad things about all

00:18:59,120 --> 00:19:02,000
async mechanisms a weight-based ones are

00:19:01,360 --> 00:19:03,679
one of them

00:19:02,000 --> 00:19:05,280
but this is one of the good things with

00:19:03,679 --> 00:19:06,160
things like threading or even with like

00:19:05,280 --> 00:19:08,480
g event

00:19:06,160 --> 00:19:09,679
you don't know if a certain function is

00:19:08,480 --> 00:19:11,679
going to context switch

00:19:09,679 --> 00:19:13,679
in fact if threading anything can with g

00:19:11,679 --> 00:19:14,559
event who knows if somewhere in the

00:19:13,679 --> 00:19:15,919
function there's a

00:19:14,559 --> 00:19:18,000
request that's going to context switch

00:19:15,919 --> 00:19:19,200
you away and so

00:19:18,000 --> 00:19:21,280
in those two you had to be much more

00:19:19,200 --> 00:19:23,520
defensive about your atomic code whereas

00:19:21,280 --> 00:19:25,600
with an await based language like

00:19:23,520 --> 00:19:26,559
not only python but also node does this

00:19:25,600 --> 00:19:27,919
for example

00:19:26,559 --> 00:19:29,840
um you have that kind of built-in

00:19:27,919 --> 00:19:31,520
atomicity like hey like

00:19:29,840 --> 00:19:33,200
as long as i don't await i can do stuff

00:19:31,520 --> 00:19:35,120
and not and assume i'm not interrupted

00:19:33,200 --> 00:19:37,120
and it's really nice

00:19:35,120 --> 00:19:38,400
now here's another example of where that

00:19:37,120 --> 00:19:39,520
kind of comes into play and where it's

00:19:38,400 --> 00:19:41,520
really important

00:19:39,520 --> 00:19:43,360
now here is again it's a contrived

00:19:41,520 --> 00:19:45,280
example right but it's the idea of like

00:19:43,360 --> 00:19:46,640
i'm going to do a long fetch

00:19:45,280 --> 00:19:47,919
and i have a second coating that's going

00:19:46,640 --> 00:19:49,360
to wait for that to finish and then

00:19:47,919 --> 00:19:51,440
notify me

00:19:49,360 --> 00:19:52,559
now this is interesting because i mean

00:19:51,440 --> 00:19:55,440
obviously you probably wouldn't write

00:19:52,559 --> 00:19:59,039
like this but let's say we did right

00:19:55,440 --> 00:20:02,240
this code will either run perfectly

00:19:59,039 --> 00:20:04,000
or be stuck in an infinite loop forever

00:20:02,240 --> 00:20:04,880
and guess what you can't tell which one

00:20:04,000 --> 00:20:06,000
you run it because it's kind of

00:20:04,880 --> 00:20:07,520
non-deterministic

00:20:06,000 --> 00:20:09,520
but obviously even a chance infant

00:20:07,520 --> 00:20:12,080
looping is bad what happens here

00:20:09,520 --> 00:20:13,679
well crucially remember i said that you

00:20:12,080 --> 00:20:14,640
have to have an await to give out

00:20:13,679 --> 00:20:16,559
control

00:20:14,640 --> 00:20:18,559
there is no weight in this notify

00:20:16,559 --> 00:20:20,000
function what that means is it never

00:20:18,559 --> 00:20:22,320
gives up control

00:20:20,000 --> 00:20:23,600
so let's say we submit both functions uh

00:20:22,320 --> 00:20:26,000
right down here you can see

00:20:23,600 --> 00:20:27,919
um to run in parallel and the event loop

00:20:26,000 --> 00:20:28,720
chooses to run notify first it enters

00:20:27,919 --> 00:20:30,320
notify

00:20:28,720 --> 00:20:32,799
it sees that ready is false and it

00:20:30,320 --> 00:20:34,000
enters the loop now as all good loops in

00:20:32,799 --> 00:20:35,840
python that could be

00:20:34,000 --> 00:20:37,360
potentially long running we haven't just

00:20:35,840 --> 00:20:39,679
done a pass because that would make it

00:20:37,360 --> 00:20:40,720
loop busy loop very very badly we put a

00:20:39,679 --> 00:20:42,799
sleep in there

00:20:40,720 --> 00:20:44,559
so the temperature can sleep and there's

00:20:42,799 --> 00:20:46,240
time to do other things in a threading

00:20:44,559 --> 00:20:48,640
this works perfectly

00:20:46,240 --> 00:20:49,600
this does not work in asynco because

00:20:48,640 --> 00:20:51,200
you're not waiting

00:20:49,600 --> 00:20:53,600
and so what this does is it literally

00:20:51,200 --> 00:20:56,320
sits there and locks up the event loop

00:20:53,600 --> 00:20:57,280
and stays notified sits in that loop

00:20:56,320 --> 00:20:59,440
forever

00:20:57,280 --> 00:21:01,200
nothing else can run ready will never be

00:20:59,440 --> 00:21:02,640
turned on and such a deadlock there

00:21:01,200 --> 00:21:04,480
waiting for something to happen

00:21:02,640 --> 00:21:05,760
and bam you have an infinite loop even

00:21:04,480 --> 00:21:06,640
though it looks like you wrote a good

00:21:05,760 --> 00:21:09,039
loop

00:21:06,640 --> 00:21:10,000
so how do you fix it we might just do

00:21:09,039 --> 00:21:12,320
this

00:21:10,000 --> 00:21:15,039
and this is better but it's not fixed

00:21:12,320 --> 00:21:16,640
because uh remember a weight needs an

00:21:15,039 --> 00:21:18,240
asynchronous version there's

00:21:16,640 --> 00:21:20,400
asynchronous versions of everything

00:21:18,240 --> 00:21:21,280
it's true for the rm it's also true for

00:21:20,400 --> 00:21:23,520
sleep

00:21:21,280 --> 00:21:25,200
the default time dot sleep function when

00:21:23,520 --> 00:21:26,960
you call it does its sleep

00:21:25,200 --> 00:21:29,280
so it's not too much of a problem here

00:21:26,960 --> 00:21:30,960
imagine those are five seconds sleep

00:21:29,280 --> 00:21:33,039
and then what would happen is we'd start

00:21:30,960 --> 00:21:34,880
this function would enter the loop

00:21:33,039 --> 00:21:36,640
and then the way it evaluates is it

00:21:34,880 --> 00:21:37,760
right it evaluates to the right of the

00:21:36,640 --> 00:21:40,320
await first

00:21:37,760 --> 00:21:41,840
so it's gonna go okay i'm gonna sleep

00:21:40,320 --> 00:21:44,320
for five seconds and then return

00:21:41,840 --> 00:21:45,440
none and then it will await on none so

00:21:44,320 --> 00:21:47,120
you'll get an exception

00:21:45,440 --> 00:21:48,400
saying that you can't await none but

00:21:47,120 --> 00:21:49,520
only after you've blocked the event loop

00:21:48,400 --> 00:21:52,480
for five seconds

00:21:49,520 --> 00:21:54,000
so the real solution is this and this

00:21:52,480 --> 00:21:55,919
you see has an async i o

00:21:54,000 --> 00:21:57,679
compatible version of sleep when you

00:21:55,919 --> 00:21:59,600
call it doesn't do anything

00:21:57,679 --> 00:22:01,039
and it returns in a weightable and when

00:21:59,600 --> 00:22:03,280
you await that awaitable

00:22:01,039 --> 00:22:04,080
that's when it sleeps so you can see

00:22:03,280 --> 00:22:06,240
like this is

00:22:04,080 --> 00:22:07,679
kind of it's not super subtle but it's

00:22:06,240 --> 00:22:10,320
very easy to

00:22:07,679 --> 00:22:11,600
look at code like this and miss that you

00:22:10,320 --> 00:22:13,679
should take the two steps

00:22:11,600 --> 00:22:15,440
to get to code like this and this is

00:22:13,679 --> 00:22:17,039
kind of partially the way python's

00:22:15,440 --> 00:22:18,480
designed this is the kind of the bad

00:22:17,039 --> 00:22:20,799
side of the awaits

00:22:18,480 --> 00:22:21,840
mechanic the good side is the atomicity

00:22:20,799 --> 00:22:23,840
the bad side is

00:22:21,840 --> 00:22:26,080
a you have to remember to add a weight

00:22:23,840 --> 00:22:27,600
and b you kind of need a different

00:22:26,080 --> 00:22:29,679
version of stuff because a weight is a

00:22:27,600 --> 00:22:31,280
separate keyword that has an expression

00:22:29,679 --> 00:22:33,200
rather than being a way of calling a

00:22:31,280 --> 00:22:36,000
function there's no there's no like

00:22:33,200 --> 00:22:36,480
asynchronous call type in python it's

00:22:36,000 --> 00:22:38,640
merely

00:22:36,480 --> 00:22:40,640
you call and it returns a co routine

00:22:38,640 --> 00:22:43,840
that makes it an asynchronous function

00:22:40,640 --> 00:22:45,840
so that's kind of the subtlety there

00:22:43,840 --> 00:22:48,080
finally i want to talk about one other

00:22:45,840 --> 00:22:50,720
thing that i kind of screwed up on

00:22:48,080 --> 00:22:51,840
and that is sync to async as i said

00:22:50,720 --> 00:22:54,080
earlier in the talk

00:22:51,840 --> 00:22:55,840
this is a very useful thing that you can

00:22:54,080 --> 00:22:56,960
wrap around database code and it runs it

00:22:55,840 --> 00:22:58,559
in a thread

00:22:56,960 --> 00:23:00,080
and you saw earlier the transaction

00:22:58,559 --> 00:23:01,360
wasn't in the synchronous threads we

00:23:00,080 --> 00:23:03,840
didn't have any side effects

00:23:01,360 --> 00:23:05,520
great so obviously if i was doing stuff

00:23:03,840 --> 00:23:06,640
that ran on the same connection like

00:23:05,520 --> 00:23:08,080
this code here

00:23:06,640 --> 00:23:10,000
where the code is kind of like oh i'm

00:23:08,080 --> 00:23:11,679
going to set up some like transaction

00:23:10,000 --> 00:23:14,240
level stuff on the connection first

00:23:11,679 --> 00:23:15,840
and then run a query on it this might be

00:23:14,240 --> 00:23:19,120
how you'd write it

00:23:15,840 --> 00:23:21,440
this in current django will not work

00:23:19,120 --> 00:23:23,039
and there's a very subtle reason why so

00:23:21,440 --> 00:23:24,960
i said sync to async

00:23:23,039 --> 00:23:26,720
does run things in threads in a sub

00:23:24,960 --> 00:23:28,159
thread it does but it doesn't run them

00:23:26,720 --> 00:23:30,240
in the same sub thread

00:23:28,159 --> 00:23:32,640
it can run them in different threads and

00:23:30,240 --> 00:23:34,559
remember transactions connections are

00:23:32,640 --> 00:23:37,120
thread bound in django

00:23:34,559 --> 00:23:38,559
and so if these two functions here run

00:23:37,120 --> 00:23:40,400
in different threads

00:23:38,559 --> 00:23:41,760
they're not talking the same connection

00:23:40,400 --> 00:23:43,200
like the first one is going to set up

00:23:41,760 --> 00:23:44,400
stuff on a connection the second one's

00:23:43,200 --> 00:23:46,559
not even going to use

00:23:44,400 --> 00:23:48,400
and then even worse a third thing might

00:23:46,559 --> 00:23:49,760
come along get put on that first thread

00:23:48,400 --> 00:23:50,799
because there's a big pool of threads

00:23:49,760 --> 00:23:52,799
it's reusing

00:23:50,799 --> 00:23:54,159
and then it's like oh this connection's

00:23:52,799 --> 00:23:55,520
set up and it's the wrong setup and

00:23:54,159 --> 00:23:58,159
things fail

00:23:55,520 --> 00:23:59,039
now this was me having a bit of a

00:23:58,159 --> 00:24:02,799
mistake

00:23:59,039 --> 00:24:03,760
i kind of went for speed and flexibility

00:24:02,799 --> 00:24:06,240
over safety

00:24:03,760 --> 00:24:07,360
and so guess what it's fixed at least

00:24:06,240 --> 00:24:10,320
it's mostly fixed

00:24:07,360 --> 00:24:11,840
um in the most recent ascii ref commits

00:24:10,320 --> 00:24:13,919
we have changed this behavior

00:24:11,840 --> 00:24:15,840
so that things always run on the same

00:24:13,919 --> 00:24:16,960
thread if you want to you can turn it

00:24:15,840 --> 00:24:18,480
off for performance reasons

00:24:16,960 --> 00:24:20,559
but thread sensitive equals false they

00:24:18,480 --> 00:24:22,880
run different threads but by default now

00:24:20,559 --> 00:24:24,720
they will all run on the same thread

00:24:22,880 --> 00:24:26,640
they will all share the same connection

00:24:24,720 --> 00:24:28,799
middleware and the view code with the

00:24:26,640 --> 00:24:29,679
same thread all manner of weird bugs

00:24:28,799 --> 00:24:32,320
that i have seen

00:24:29,679 --> 00:24:33,919
and i have honestly been trying to fix

00:24:32,320 --> 00:24:35,520
are now fixed by that one small change

00:24:33,919 --> 00:24:36,799
and yeah it runs a little bit slower but

00:24:35,520 --> 00:24:38,480
it's not that much and it's worth it for

00:24:36,799 --> 00:24:39,360
the safety if you want to turn it off

00:24:38,480 --> 00:24:42,000
you know what you're doing

00:24:39,360 --> 00:24:43,760
go ahead you can just turn it off and

00:24:42,000 --> 00:24:46,080
that's just one example of like how do

00:24:43,760 --> 00:24:48,159
we defend against stuff like this you've

00:24:46,080 --> 00:24:50,240
seen just a small subset of the examples

00:24:48,159 --> 00:24:52,960
of how you can break asynchronous code

00:24:50,240 --> 00:24:54,080
there are so many more and how do you

00:24:52,960 --> 00:24:55,520
mount a defense against a thing that's

00:24:54,080 --> 00:24:57,760
like fundamentally just based

00:24:55,520 --> 00:24:59,440
on the language paradigm of doing right

00:24:57,760 --> 00:25:02,080
it's as you've seen like

00:24:59,440 --> 00:25:04,159
you can miss a single awake keyword and

00:25:02,080 --> 00:25:06,960
screw up your entire code base like

00:25:04,159 --> 00:25:08,559
if i have a function that makes users

00:25:06,960 --> 00:25:09,520
and i miss an await on the function that

00:25:08,559 --> 00:25:11,440
makes users

00:25:09,520 --> 00:25:13,360
the view will run and return yes user

00:25:11,440 --> 00:25:14,000
made but i never awaited it it's not

00:25:13,360 --> 00:25:15,840
actually going to run

00:25:14,000 --> 00:25:17,840
so silent failure is a really common

00:25:15,840 --> 00:25:18,720
thing it's really tricky to build around

00:25:17,840 --> 00:25:20,159
that

00:25:18,720 --> 00:25:22,159
the first thing i recommend is this

00:25:20,159 --> 00:25:24,400
thing called python async debug

00:25:22,159 --> 00:25:25,600
now if django has guard rails um this is

00:25:24,400 --> 00:25:27,760
python's guardrail

00:25:25,600 --> 00:25:29,760
basically if you turn this on a whole

00:25:27,760 --> 00:25:30,159
number of debugging features for async

00:25:29,760 --> 00:25:32,880
apps

00:25:30,159 --> 00:25:34,720
turn on in async io um there are quite a

00:25:32,880 --> 00:25:37,600
few things that these top two here the

00:25:34,720 --> 00:25:39,279
most crucial to me first of all any co

00:25:37,600 --> 00:25:41,039
routine that runs for too long

00:25:39,279 --> 00:25:42,880
will be flagged to you and be like hey

00:25:41,039 --> 00:25:44,559
there's protein around for too long

00:25:42,880 --> 00:25:46,960
why is that important it means it didn't

00:25:44,559 --> 00:25:48,799
give up control a good co-routine runs

00:25:46,960 --> 00:25:50,320
for maybe a few milliseconds and awaits

00:25:48,799 --> 00:25:52,720
what does a long thing

00:25:50,320 --> 00:25:54,159
if your coating runs for a long time and

00:25:52,720 --> 00:25:57,279
by default the long time is

00:25:54,159 --> 00:25:58,720
100 milliseconds then it probably means

00:25:57,279 --> 00:26:00,480
you're actually calling a synchronous

00:25:58,720 --> 00:26:02,320
thing by mistake maybe

00:26:00,480 --> 00:26:04,640
you're using a library and some id from

00:26:02,320 --> 00:26:05,520
the library is a http call you didn't

00:26:04,640 --> 00:26:07,440
notice

00:26:05,520 --> 00:26:09,039
this will detect that and go hey when

00:26:07,440 --> 00:26:10,640
your co-routine ran it took

00:26:09,039 --> 00:26:12,480
one and a half seconds for it yielded

00:26:10,640 --> 00:26:14,320
control back to us for the next to wait

00:26:12,480 --> 00:26:16,480
that's not that's too long something's

00:26:14,320 --> 00:26:18,080
going on so this lets you find the cases

00:26:16,480 --> 00:26:19,279
where you're actually using synchronous

00:26:18,080 --> 00:26:20,720
code where you shouldn't be that's

00:26:19,279 --> 00:26:22,320
blocking

00:26:20,720 --> 00:26:24,400
the other thing is the inverse it can

00:26:22,320 --> 00:26:25,919
detect unawaited co-routines

00:26:24,400 --> 00:26:27,760
this detects the case where let's say

00:26:25,919 --> 00:26:29,360
you have a side effect function

00:26:27,760 --> 00:26:31,360
written in an asynchronous style that

00:26:29,360 --> 00:26:33,440
you want to run but you forget to put

00:26:31,360 --> 00:26:35,360
the weight in front of it so if you just

00:26:33,440 --> 00:26:37,360
have like oh yeah create user

00:26:35,360 --> 00:26:39,360
i know a weight what happens is python

00:26:37,360 --> 00:26:40,960
will make the coding object ready to run

00:26:39,360 --> 00:26:42,720
and then it will just vanish into the

00:26:40,960 --> 00:26:44,720
local memory space and never get run

00:26:42,720 --> 00:26:46,559
and get garbage collected when this

00:26:44,720 --> 00:26:49,760
happens with this mode turned on

00:26:46,559 --> 00:26:51,440
python's like you made a coating there

00:26:49,760 --> 00:26:53,679
awaited it what are you doing

00:26:51,440 --> 00:26:54,880
this is bad and so both of these aren't

00:26:53,679 --> 00:26:56,480
perfect they're not going to like

00:26:54,880 --> 00:26:57,760
outline the area in your code that's

00:26:56,480 --> 00:26:58,720
wrong but they're going to give you

00:26:57,760 --> 00:27:01,520
hints that something's

00:26:58,720 --> 00:27:02,960
not right be like okay like i know that

00:27:01,520 --> 00:27:04,400
if a thing runs for too long

00:27:02,960 --> 00:27:06,400
there is a blocking synchronous call

00:27:04,400 --> 00:27:08,000
somewhere and i know that if a code

00:27:06,400 --> 00:27:09,520
is unawaited i'm missing another weight

00:27:08,000 --> 00:27:11,440
somewhere and with that information you

00:27:09,520 --> 00:27:13,440
can go do some of your own research and

00:27:11,440 --> 00:27:14,880
work out exactly what the problem is

00:27:13,440 --> 00:27:17,200
hopefully these will improve over time

00:27:14,880 --> 00:27:19,200
or get code analysis tools but it's a

00:27:17,200 --> 00:27:21,520
good start

00:27:19,200 --> 00:27:23,520
again other things like synchronous only

00:27:21,520 --> 00:27:25,279
operation i call these guard rails

00:27:23,520 --> 00:27:26,640
these are things where when we can

00:27:25,279 --> 00:27:28,720
definitely detect you're not doing a

00:27:26,640 --> 00:27:30,480
thing right we'll raise this exception

00:27:28,720 --> 00:27:32,640
there are a very few number of cases

00:27:30,480 --> 00:27:34,640
where you do want to try and call

00:27:32,640 --> 00:27:35,919
the rm from asynchronous code um

00:27:34,640 --> 00:27:36,799
especially when it's like a one-off

00:27:35,919 --> 00:27:38,240
function or something like that but

00:27:36,799 --> 00:27:40,159
generally you don't want to do it

00:27:38,240 --> 00:27:42,080
and that's where a guardrail makes sense

00:27:40,159 --> 00:27:42,960
now of course these all have options to

00:27:42,080 --> 00:27:45,360
turn them off

00:27:42,960 --> 00:27:46,880
that's very important to us is totally

00:27:45,360 --> 00:27:49,279
up to you what you want to do

00:27:46,880 --> 00:27:50,480
by default they all come turned on like

00:27:49,279 --> 00:27:52,159
all of chango's

00:27:50,480 --> 00:27:54,080
other safety features like the security

00:27:52,159 --> 00:27:57,600
middleware and so on and so forth

00:27:54,080 --> 00:27:59,360
that comes by default and remember this

00:27:57,600 --> 00:28:01,679
is all because asynchronous programming

00:27:59,360 --> 00:28:03,679
is by its nature hard it's not that like

00:28:01,679 --> 00:28:05,679
django or python has screwed up here

00:28:03,679 --> 00:28:07,600
like concurrent programming in general

00:28:05,679 --> 00:28:09,279
and async programming in particular

00:28:07,600 --> 00:28:11,679
are just difficult to think about you

00:28:09,279 --> 00:28:13,200
can basically screw up in so many more

00:28:11,679 --> 00:28:14,159
ways than you can in a synchronous

00:28:13,200 --> 00:28:15,840
context that

00:28:14,159 --> 00:28:17,919
we just have to defend against all of

00:28:15,840 --> 00:28:20,799
this my personal way of doing this

00:28:17,919 --> 00:28:22,640
is to write code synchronously first

00:28:20,799 --> 00:28:23,840
that lets me understand how it flows get

00:28:22,640 --> 00:28:26,080
a mental model of it

00:28:23,840 --> 00:28:27,440
then i can write a good test suite then

00:28:26,080 --> 00:28:29,039
only when i've done that

00:28:27,440 --> 00:28:30,880
and i would know that that code is a

00:28:29,039 --> 00:28:32,480
performance bottleneck then i will go

00:28:30,880 --> 00:28:34,320
and refactor it to make it async

00:28:32,480 --> 00:28:35,840
this is what i recommend to you um that

00:28:34,320 --> 00:28:37,360
you do as your mechanism

00:28:35,840 --> 00:28:39,039
because you may find the things you

00:28:37,360 --> 00:28:39,520
think will be performance bottlenecks

00:28:39,039 --> 00:28:41,440
aren't

00:28:39,520 --> 00:28:42,720
and vice versa because you don't want to

00:28:41,440 --> 00:28:43,279
write your whole thing an async from the

00:28:42,720 --> 00:28:44,480
beginning

00:28:43,279 --> 00:28:46,240
it's going to be a massive nightmare and

00:28:44,480 --> 00:28:48,080
more work than you want you want to have

00:28:46,240 --> 00:28:49,279
the ability to like lift up oh like this

00:28:48,080 --> 00:28:50,559
one view

00:28:49,279 --> 00:28:51,840
we're going to make it async and that's

00:28:50,559 --> 00:28:53,200
one of the reasons django supports a

00:28:51,840 --> 00:28:55,520
hybrid mode right like

00:28:53,200 --> 00:28:56,640
you can just make one or two views async

00:28:55,520 --> 00:28:58,320
and the rest synchronous

00:28:56,640 --> 00:28:59,760
django will just deal with it for you

00:28:58,320 --> 00:29:01,120
with all the right safety around it

00:28:59,760 --> 00:29:02,799
and there you go bob's your uncle you

00:29:01,120 --> 00:29:03,279
can have both worlds for the price of

00:29:02,799 --> 00:29:05,039
one

00:29:03,279 --> 00:29:06,559
that's kind of the point and that's kind

00:29:05,039 --> 00:29:08,559
of django's contract here

00:29:06,559 --> 00:29:10,320
we are here to do our part where we can

00:29:08,559 --> 00:29:12,399
django's job is to give you a safe

00:29:10,320 --> 00:29:13,919
framework that you can quickly and

00:29:12,399 --> 00:29:15,120
safely develop code in

00:29:13,919 --> 00:29:17,120
and then when it comes time to make it

00:29:15,120 --> 00:29:19,919
bigger you have the

00:29:17,120 --> 00:29:22,000
room to carve out like how this section

00:29:19,919 --> 00:29:23,360
i want to trade my safety for speed

00:29:22,000 --> 00:29:25,520
or this section i want to replace what

00:29:23,360 --> 00:29:28,480
django does that's what we're here for

00:29:25,520 --> 00:29:30,159
and that philosophy as it were continues

00:29:28,480 --> 00:29:30,799
into how we're trying to design django

00:29:30,159 --> 00:29:32,159
async

00:29:30,799 --> 00:29:34,000
and it's really important to me

00:29:32,159 --> 00:29:35,200
personally we continue this is what i

00:29:34,000 --> 00:29:37,279
come to django for

00:29:35,200 --> 00:29:38,880
is i can just hammer on a keyboard for

00:29:37,279 --> 00:29:40,559
20 minutes and make a site and not worry

00:29:38,880 --> 00:29:42,240
about having giant security holes in it

00:29:40,559 --> 00:29:43,679
or like giant performance holes that

00:29:42,240 --> 00:29:45,360
continues here but

00:29:43,679 --> 00:29:46,880
that's kind of our job and so i'm

00:29:45,360 --> 00:29:49,120
telling you we will try and continue

00:29:46,880 --> 00:29:50,880
that and make async the best it can be

00:29:49,120 --> 00:29:52,399
but of course that is in the framework

00:29:50,880 --> 00:29:54,080
of async as a whole

00:29:52,399 --> 00:29:55,840
it's not just a django problem it's not

00:29:54,080 --> 00:29:56,399
just a python problem it's an everything

00:29:55,840 --> 00:29:57,919
problem

00:29:56,399 --> 00:29:59,360
nobody's looking at this ras is looking

00:29:57,919 --> 00:30:00,480
at this both have a weight pattern as

00:29:59,360 --> 00:30:01,760
well for example

00:30:00,480 --> 00:30:04,000
many other languages have tried this

00:30:01,760 --> 00:30:05,840
over the years like there's so much more

00:30:04,000 --> 00:30:08,000
to be done in terms of making good

00:30:05,840 --> 00:30:09,840
safe concurrent programming we're just

00:30:08,000 --> 00:30:10,720
at the foot of the mountain of what we

00:30:09,840 --> 00:30:13,039
can achieve

00:30:10,720 --> 00:30:14,399
and so i hope in five to ten years i'll

00:30:13,039 --> 00:30:14,799
be standing in a similar position being

00:30:14,399 --> 00:30:16,320
like

00:30:14,799 --> 00:30:18,000
it's great you can just write async now

00:30:16,320 --> 00:30:19,360
and it's all perfectly safe and like

00:30:18,000 --> 00:30:21,360
you can't screw up and all the race

00:30:19,360 --> 00:30:22,960
conditions are detected by default but

00:30:21,360 --> 00:30:24,640
unfortunately it's going to be a little

00:30:22,960 --> 00:30:27,039
bit work to get anywhere near there

00:30:24,640 --> 00:30:29,200
and we may never get there but my hope

00:30:27,039 --> 00:30:31,360
is one day that async programming

00:30:29,200 --> 00:30:33,360
will be a lot harder to make mistakes in

00:30:31,360 --> 00:30:34,840
and really worth writing stuff in from

00:30:33,360 --> 00:30:36,480
the get-go rather than doing synchronous

00:30:34,840 --> 00:30:39,520
first but

00:30:36,480 --> 00:30:41,440
until then i uh hope you have fun trying

00:30:39,520 --> 00:30:43,520
django's new async stuff

00:30:41,440 --> 00:30:44,640
um i hope you have enjoyed learning some

00:30:43,520 --> 00:30:46,559
of the ways you can you can

00:30:44,640 --> 00:30:47,840
make things go wrong i do encourage you

00:30:46,559 --> 00:30:49,520
to try this at home like

00:30:47,840 --> 00:30:50,960
download jenga three one try and break

00:30:49,520 --> 00:30:51,600
it and just don't do it in production

00:30:50,960 --> 00:30:53,440
please

00:30:51,600 --> 00:30:54,799
and if you're interested in helping out

00:30:53,440 --> 00:30:55,760
with async stuff please come to the

00:30:54,799 --> 00:30:57,279
django forum

00:30:55,760 --> 00:30:59,519
we have an async sub forum where we

00:30:57,279 --> 00:31:00,960
discuss stuff and designs you can see me

00:30:59,519 --> 00:31:02,960
talking about transactions in middleware

00:31:00,960 --> 00:31:04,720
there for example but yeah

00:31:02,960 --> 00:31:06,480
until then i hope you have a lovely

00:31:04,720 --> 00:31:07,760
afternoon i hope you've enjoyed

00:31:06,480 --> 00:31:10,000
djangocon europe

00:31:07,760 --> 00:31:11,919
and i'll hopefully see you somewhere

00:31:10,000 --> 00:31:12,559
around the world in person at some point

00:31:11,919 --> 00:31:19,840
soon

00:31:12,559 --> 00:31:19,840
until then i'll see you next time

00:31:19,919 --> 00:31:22,000

YouTube URL: https://www.youtube.com/watch?v=19Uh_PA_8Rc


