Title: Cloud Foundry and IOT protocol support
Publication date: 2015-05-12
Playlist: Cloud Foundry Summit 2015
Description: 
	Cloud Foundry and IOT protocol support - 03 Atul Kshirsagar 720p
Captions: 
	00:00:01,669 --> 00:00:09,330
good afternoon my name is dr. Chris

00:00:05,970 --> 00:00:10,980
Adler I am engineer at GE software I've

00:00:09,330 --> 00:00:13,049
been working with cloud Fonda's Diego

00:00:10,980 --> 00:00:16,080
team as a full-time member for past five

00:00:13,049 --> 00:00:18,840
to six months and I'll be talking about

00:00:16,080 --> 00:00:22,140
how G software in collaboration with

00:00:18,840 --> 00:00:25,019
pivotal is trying to add non-http

00:00:22,140 --> 00:00:27,720
routing capability to Cloud Foundry now

00:00:25,019 --> 00:00:30,269
this is going to enable routing of our

00:00:27,720 --> 00:00:32,610
support for IOT protocols in Cloud

00:00:30,269 --> 00:00:36,120
Foundry as well as it is going to enable

00:00:32,610 --> 00:00:40,950
support for any layer 7 protocol that's

00:00:36,120 --> 00:00:44,610
going to work on TCP so why is G

00:00:40,950 --> 00:00:46,890
interested in IOT at all by show of

00:00:44,610 --> 00:00:50,539
hands how many of you have heard about

00:00:46,890 --> 00:00:53,449
industrial Internet Wow

00:00:50,539 --> 00:00:58,289
everyone has heard about it that's nice

00:00:53,449 --> 00:01:01,260
so now you all know that industry on

00:00:58,289 --> 00:01:04,920
internet is internet of really big

00:01:01,260 --> 00:01:08,130
things it's also internet of really

00:01:04,920 --> 00:01:10,470
important things now I'm going to walk

00:01:08,130 --> 00:01:13,140
you through an very typical use case

00:01:10,470 --> 00:01:16,320
that GE has and I'm going to show you

00:01:13,140 --> 00:01:19,770
why IOT protocols are important and I

00:01:16,320 --> 00:01:22,200
will also try to show you how Cloud

00:01:19,770 --> 00:01:26,070
Foundry fits into this entire scheme of

00:01:22,200 --> 00:01:30,540
things so now most of you would know

00:01:26,070 --> 00:01:32,909
that G is a big industrial company it

00:01:30,540 --> 00:01:35,610
has its presence in many industries it's

00:01:32,909 --> 00:01:39,060
there in aviation transportation health

00:01:35,610 --> 00:01:41,790
care oil and gas power generation many

00:01:39,060 --> 00:01:43,829
more so the example and the use case

00:01:41,790 --> 00:01:47,130
that I'm going to show you today is from

00:01:43,829 --> 00:01:50,369
our power generation business now this

00:01:47,130 --> 00:01:53,009
is our typical IT ot deployment and

00:01:50,369 --> 00:01:55,350
topology that you are seeing here on the

00:01:53,009 --> 00:01:57,119
bottom left what you are seeing is our

00:01:55,350 --> 00:01:59,329
remote stations where you have this big

00:01:57,119 --> 00:02:02,430
turbines that are generating electricity

00:01:59,329 --> 00:02:04,409
the top left you see the control centers

00:02:02,430 --> 00:02:07,560
which are going to manage this remote

00:02:04,409 --> 00:02:10,020
stations and on the bottom right is our

00:02:07,560 --> 00:02:12,420
data center which has our industrial

00:02:10,020 --> 00:02:14,210
apps that run on the cloud platform for

00:02:12,420 --> 00:02:17,580
industrial Internet

00:02:14,210 --> 00:02:19,590
now if you notice there in the remote

00:02:17,580 --> 00:02:22,110
stations you have this PLC's with a

00:02:19,590 --> 00:02:23,700
little P and that that is our predicts

00:02:22,110 --> 00:02:26,930
machine which is the embedded part of

00:02:23,700 --> 00:02:31,470
our software this predicts machine

00:02:26,930 --> 00:02:33,060
software talks to the turbines and

00:02:31,470 --> 00:02:36,360
controls the operations of the turbine

00:02:33,060 --> 00:02:40,170
using variety of OT protocols like OPC

00:02:36,360 --> 00:02:43,740
UA Modbus empty connect profinet there

00:02:40,170 --> 00:02:45,030
are many more if you look at diagram

00:02:43,740 --> 00:02:49,110
you'll also see that there are a bunch

00:02:45,030 --> 00:02:51,420
of sensors which are which are fitted on

00:02:49,110 --> 00:02:54,239
those turbines and they are going to

00:02:51,420 --> 00:02:58,080
measure various operational parameters

00:02:54,239 --> 00:03:00,239
like what is the level pressure flow and

00:02:58,080 --> 00:03:04,290
that data will be sent to predicts

00:03:00,239 --> 00:03:07,080
machine or IOT protocol like DDS this

00:03:04,290 --> 00:03:08,370
data in remote station is stored in a

00:03:07,080 --> 00:03:10,470
time series database which is a

00:03:08,370 --> 00:03:13,709
proprietary time series database of G

00:03:10,470 --> 00:03:16,020
called historian and that data is then

00:03:13,709 --> 00:03:18,690
sent over satellite uplink to our

00:03:16,020 --> 00:03:20,070
control centers this control center is

00:03:18,690 --> 00:03:22,680
your typical corporate enterprise

00:03:20,070 --> 00:03:25,590
network and you have bunch of apps that

00:03:22,680 --> 00:03:28,410
are running there these apps front edge

00:03:25,590 --> 00:03:31,080
analytics so that that data could be

00:03:28,410 --> 00:03:33,540
shown to the field engineers to the

00:03:31,080 --> 00:03:35,130
experts who are in control center who

00:03:33,540 --> 00:03:40,140
can actually manage and take real-time

00:03:35,130 --> 00:03:42,390
actions now you see there is a little

00:03:40,140 --> 00:03:44,700
peor there in the control center which

00:03:42,390 --> 00:03:46,200
is our predicts gateway this predicts

00:03:44,700 --> 00:03:49,230
Gateway is going to get the data

00:03:46,200 --> 00:03:51,630
compress it filter it and send it over

00:03:49,230 --> 00:03:54,090
van to the industrial apps that are

00:03:51,630 --> 00:03:55,530
running in our data center these

00:03:54,090 --> 00:03:58,200
industrial apps are going to run

00:03:55,530 --> 00:03:59,640
predictive analytics to advanced

00:03:58,200 --> 00:04:02,280
analytics and give you predictive

00:03:59,640 --> 00:04:05,840
insights and then all Big Data stuff

00:04:02,280 --> 00:04:08,970
that's going to happen there on so this

00:04:05,840 --> 00:04:10,500
predicts Gateway as well have a bunch of

00:04:08,970 --> 00:04:13,890
apps that are running in control center

00:04:10,500 --> 00:04:17,459
are going to send the data to the apps

00:04:13,890 --> 00:04:23,789
running in the data center or multiple

00:04:17,459 --> 00:04:26,699
i/o protocols HTTP obviously DDS s2s

00:04:23,789 --> 00:04:30,590
which is our proprietary binary protocol

00:04:26,699 --> 00:04:35,270
and MQTT mqv and went to further things

00:04:30,590 --> 00:04:37,590
now let's zoom in into our data center

00:04:35,270 --> 00:04:40,620
and this is where Cloud Foundry comes

00:04:37,590 --> 00:04:41,969
into picture our cloud platform for

00:04:40,620 --> 00:04:45,659
industry or Internet which is called

00:04:41,969 --> 00:04:47,789
products is based on Cloud Foundry now

00:04:45,659 --> 00:04:50,210
we have a bunch of apps and industrial

00:04:47,789 --> 00:04:53,759
micro services that run on Cloud Foundry

00:04:50,210 --> 00:04:56,279
now the key part here is we have to get

00:04:53,759 --> 00:05:00,150
the data either from our predicts

00:04:56,279 --> 00:05:03,029
gateways either from the apps sensors or

00:05:00,150 --> 00:05:07,500
devices or to the apps that are running

00:05:03,029 --> 00:05:10,050
on Cloud Foundry right now now you get a

00:05:07,500 --> 00:05:12,389
picture of what we have in terms of our

00:05:10,050 --> 00:05:16,199
protocol landscape from G's point of

00:05:12,389 --> 00:05:19,080
view let's take a quick look at how the

00:05:16,199 --> 00:05:21,599
protocol landscape plays out in regular

00:05:19,080 --> 00:05:25,139
IOT use case so Eclipse Foundation

00:05:21,599 --> 00:05:27,509
recently conducted and survey of IOT

00:05:25,139 --> 00:05:29,370
developers and they found out what are

00:05:27,509 --> 00:05:32,310
the messaging protocols that you use in

00:05:29,370 --> 00:05:34,199
your IOT solutions there are two things

00:05:32,310 --> 00:05:37,259
you should notice about this particular

00:05:34,199 --> 00:05:39,990
survey first obviously it's certainly

00:05:37,259 --> 00:05:45,360
not HTTP there are many more protocols

00:05:39,990 --> 00:05:49,229
like mqtt is their coop XMPP des and

00:05:45,360 --> 00:05:57,930
many more if you look real close it adds

00:05:49,229 --> 00:06:00,169
up to more than 100% why is that any

00:05:57,930 --> 00:06:00,169
guesses

00:06:00,609 --> 00:06:05,959
people use more than one protocol in

00:06:03,589 --> 00:06:07,279
their loyalty solutions it's just not

00:06:05,959 --> 00:06:09,499
one there more than one

00:06:07,279 --> 00:06:14,059
and that's the real point I'm trying to

00:06:09,499 --> 00:06:15,979
make here world is multi-dimensional we

00:06:14,059 --> 00:06:18,229
need multiple protocols it's not on a

00:06:15,979 --> 00:06:21,139
single protocol that you need and that

00:06:18,229 --> 00:06:24,679
isn't where we need support for multiple

00:06:21,139 --> 00:06:26,899
protocols in Cloud Foundry now in then

00:06:24,679 --> 00:06:29,839
IOT use-case HTTP has certain drawbacks

00:06:26,899 --> 00:06:33,019
that HTTP has overhead its large

00:06:29,839 --> 00:06:36,379
overheads does it offer QoS not very

00:06:33,019 --> 00:06:39,679
well suited for large payloads doesn't

00:06:36,379 --> 00:06:42,199
offer sticky sessions right so those are

00:06:39,679 --> 00:06:45,829
various disadvantages if you consider

00:06:42,199 --> 00:06:49,519
HTTP from an i/o to use this so now that

00:06:45,829 --> 00:06:52,179
we know for IOT you have multiple other

00:06:49,519 --> 00:06:55,609
protocols in play what happens today

00:06:52,179 --> 00:06:57,199
when you have Cloud Foundry now you have

00:06:55,609 --> 00:07:00,109
this bunch of apps we have deployed in

00:06:57,199 --> 00:07:02,949
Cloud Foundry and let us say these are

00:07:00,109 --> 00:07:07,009
12 factor apps web apps if you will and

00:07:02,949 --> 00:07:09,019
you are their clients or browsers will

00:07:07,009 --> 00:07:12,289
happily talk to your apps because go

00:07:09,019 --> 00:07:14,599
router understands HTTP very well if you

00:07:12,289 --> 00:07:18,379
want to talk to app 1 Google Auto can do

00:07:14,599 --> 00:07:21,349
it it knows how to forward the request

00:07:18,379 --> 00:07:23,689
to your app and everyone's happy now

00:07:21,349 --> 00:07:26,899
let's try to see what happens in the IOT

00:07:23,689 --> 00:07:30,619
use case in comes our sensor device

00:07:26,899 --> 00:07:33,009
gateway then wanna talk HTTP wants to

00:07:30,619 --> 00:07:36,529
talk maybe I'm to TD

00:07:33,009 --> 00:07:39,739
go router has no clue what do I do with

00:07:36,529 --> 00:07:43,879
this well I can't do anything the

00:07:39,739 --> 00:07:48,319
connection drops everyone is unhappy so

00:07:43,879 --> 00:07:51,559
now if you have to use Cloud Foundry you

00:07:48,319 --> 00:07:55,579
have to use it in an IOT use case what

00:07:51,559 --> 00:08:00,589
do you do doesn't even know answer to

00:07:55,579 --> 00:08:04,819
existing what is the workaround cf

00:08:00,589 --> 00:08:06,289
services that's what people do the you

00:08:04,819 --> 00:08:08,629
will host some part of the system or

00:08:06,289 --> 00:08:11,389
some part of your app outside of Cloud

00:08:08,629 --> 00:08:14,120
Foundry that is the part that's going to

00:08:11,389 --> 00:08:17,570
receive the data over non-http

00:08:14,120 --> 00:08:20,000
right and then you use CFCs so if it's

00:08:17,570 --> 00:08:23,090
broker api's to expose a service and

00:08:20,000 --> 00:08:24,979
point into cloud foundry now the apps

00:08:23,090 --> 00:08:29,540
will bind to that service endpoint get

00:08:24,979 --> 00:08:35,210
the data all works well but it turns out

00:08:29,540 --> 00:08:37,669
there are certain drawbacks first up you

00:08:35,210 --> 00:08:40,839
are adding an additional hop to get the

00:08:37,669 --> 00:08:44,660
data so there is an additional latency

00:08:40,839 --> 00:08:48,620
second you have to manage your that part

00:08:44,660 --> 00:08:50,150
of your service or app outside of CF so

00:08:48,620 --> 00:08:52,310
you don't get all those things that CF

00:08:50,150 --> 00:08:55,250
is offering you it's not going to manage

00:08:52,310 --> 00:08:57,070
the health of your apps it's not going

00:08:55,250 --> 00:08:59,839
to move your apps if your apps crash

00:08:57,070 --> 00:09:03,820
it's not able to scale so you have to do

00:08:59,839 --> 00:09:06,260
that by yourself but most importantly

00:09:03,820 --> 00:09:11,300
it's not going to work for all the

00:09:06,260 --> 00:09:13,310
protocols mqtt here what I have shown

00:09:11,300 --> 00:09:15,410
here it will work very well because it's

00:09:13,310 --> 00:09:18,140
a broker based protocol you can have

00:09:15,410 --> 00:09:19,760
your broker outside of CF and apps as

00:09:18,140 --> 00:09:21,830
client to that broke on and everything

00:09:19,760 --> 00:09:25,580
works fine but what about peer-to-peer

00:09:21,830 --> 00:09:27,050
protocols like DDS I want to put your

00:09:25,580 --> 00:09:32,330
apps out there then what slots boundary

00:09:27,050 --> 00:09:34,279
for not going to work so it will be

00:09:32,330 --> 00:09:37,760
great if Cloud Foundry is going to have

00:09:34,279 --> 00:09:40,040
this capability to route non HTTP

00:09:37,760 --> 00:09:42,650
traffic directly to the apps right if

00:09:40,040 --> 00:09:44,720
you have that you will take Cloud

00:09:42,650 --> 00:09:48,230
Foundry one step closer to make the

00:09:44,720 --> 00:09:54,290
platform of choice for IOT use case we

00:09:48,230 --> 00:09:56,870
want that so now that we know 4G

00:09:54,290 --> 00:09:59,900
definitely IOT is something that is

00:09:56,870 --> 00:10:02,420
required and this is a gap that needs to

00:09:59,900 --> 00:10:05,480
be filled let's see how we can add this

00:10:02,420 --> 00:10:07,810
capability and as any good engineering

00:10:05,480 --> 00:10:11,810
team we came up with couple of options

00:10:07,810 --> 00:10:14,600
let's let's have those options let's see

00:10:11,810 --> 00:10:17,150
what is involved in that and let's pick

00:10:14,600 --> 00:10:20,150
the right one that's right at the at

00:10:17,150 --> 00:10:22,430
this point in time so I'm going to walk

00:10:20,150 --> 00:10:24,260
you through those two options give you a

00:10:22,430 --> 00:10:27,620
brief overview and then we'll take a

00:10:24,260 --> 00:10:32,060
deep dive into the approach or option

00:10:27,620 --> 00:10:36,140
that we have decided to go with the

00:10:32,060 --> 00:10:40,459
first option that we consider is the

00:10:36,140 --> 00:10:43,700
seven router in visiting HTTP or go

00:10:40,459 --> 00:10:46,730
router that we have is layer seven

00:10:43,700 --> 00:10:48,950
router right so we thought that's nice

00:10:46,730 --> 00:10:51,620
we can just exchange that might as well

00:10:48,950 --> 00:10:53,959
put a routing framework around it so

00:10:51,620 --> 00:10:56,450
that you could have pluggable layer

00:10:53,959 --> 00:10:59,270
seven protocol specific proxies so you

00:10:56,450 --> 00:11:01,790
could have a proxy for MQTT you could

00:10:59,270 --> 00:11:05,209
have a proxy for DDS could have a proxy

00:11:01,790 --> 00:11:07,070
for XMPP and so on and so forth and this

00:11:05,209 --> 00:11:08,839
routing framework now will route the

00:11:07,070 --> 00:11:15,770
traffic that it receives on its external

00:11:08,839 --> 00:11:17,959
port to the particular proxy so let's

00:11:15,770 --> 00:11:20,060
say it receives traffic on port 1883 it

00:11:17,959 --> 00:11:23,180
routes it to MQTT so that routing could

00:11:20,060 --> 00:11:26,020
happen based on what is the well-known

00:11:23,180 --> 00:11:28,550
port for that particular protocol right

00:11:26,020 --> 00:11:31,010
now it's the responsibility of that

00:11:28,550 --> 00:11:33,020
proxy to actually route the traffic to

00:11:31,010 --> 00:11:35,450
the appropriate instance of the app and

00:11:33,020 --> 00:11:38,270
how it is going to do it I'm going to

00:11:35,450 --> 00:11:40,550
talk about it a little bit later and

00:11:38,270 --> 00:11:43,779
that's where the more challenges are and

00:11:40,550 --> 00:11:49,160
we'll see what those challenges are so

00:11:43,779 --> 00:11:50,570
now if you look at this approach the

00:11:49,160 --> 00:11:52,490
advantages of this approach are pretty

00:11:50,570 --> 00:11:54,950
clear oh you are going to use standard

00:11:52,490 --> 00:11:57,470
ports it's very natural to use like

00:11:54,950 --> 00:11:59,360
you're using HTTP 80 and 443 you'll be

00:11:57,470 --> 00:12:01,940
able to use MQTT on 1883

00:11:59,360 --> 00:12:05,480
you will you'll be able to use XMPP 150

00:12:01,940 --> 00:12:07,790
222 it's very scalable there is no limit

00:12:05,480 --> 00:12:09,550
on the number of apps that can receive

00:12:07,790 --> 00:12:13,010
this non HTTP traffic

00:12:09,550 --> 00:12:15,079
it's very extensible you can add support

00:12:13,010 --> 00:12:18,380
for whatever protocol you want by

00:12:15,079 --> 00:12:20,420
developing a proxy plugging it in right

00:12:18,380 --> 00:12:22,190
you can develop some routing services

00:12:20,420 --> 00:12:25,250
like we are going to develop for go

00:12:22,190 --> 00:12:26,540
router we have this router services that

00:12:25,250 --> 00:12:28,370
will be developed and you can implement

00:12:26,540 --> 00:12:34,850
any cross-cutting concerns at that layer

00:12:28,370 --> 00:12:37,220
7 protocol proxy on the flip side you'll

00:12:34,850 --> 00:12:39,560
see that you'll need to develop protocol

00:12:37,220 --> 00:12:42,130
proxies for each individual protocol

00:12:39,560 --> 00:12:44,510
that you need support for

00:12:42,130 --> 00:12:47,600
so that is obviously an additional

00:12:44,510 --> 00:12:49,430
overhead and more complexity and but

00:12:47,600 --> 00:12:51,800
more importantly and this is where we

00:12:49,430 --> 00:12:54,440
will dig a little deeper into how we can

00:12:51,800 --> 00:12:56,330
have this layer seven proxies route the

00:12:54,440 --> 00:12:59,120
traffic to app one particular app

00:12:56,330 --> 00:13:01,670
instances it's very difficult for this

00:12:59,120 --> 00:13:05,540
process to know where it should route

00:13:01,670 --> 00:13:07,850
that particular traffic to it will end

00:13:05,540 --> 00:13:10,550
up using some non-standard ways or some

00:13:07,850 --> 00:13:12,560
hacks in order to achieve that so let's

00:13:10,550 --> 00:13:14,660
let's spend some time on this to

00:13:12,560 --> 00:13:19,490
understand what's involved and why is it

00:13:14,660 --> 00:13:23,990
so complex in case of HTTP it's a little

00:13:19,490 --> 00:13:26,480
easier because HTTP specs mandate that

00:13:23,990 --> 00:13:27,380
you need to have the host header in your

00:13:26,480 --> 00:13:30,170
HTTP request

00:13:27,380 --> 00:13:33,620
what is this host header this host

00:13:30,170 --> 00:13:36,350
header is your route so your app one dot

00:13:33,620 --> 00:13:39,230
c FF com that's going to come in your

00:13:36,350 --> 00:13:41,900
HTTP headers so core outer can look at

00:13:39,230 --> 00:13:43,670
this host header look at its routing

00:13:41,900 --> 00:13:46,790
table and route the traffic to

00:13:43,670 --> 00:13:49,730
particular app instance let's take a

00:13:46,790 --> 00:13:51,800
look at the headers from one of the iot

00:13:49,730 --> 00:13:53,750
protocols I am clicking on MQTT here

00:13:51,800 --> 00:13:57,950
because that's more popular that's what

00:13:53,750 --> 00:14:02,540
we saw in Eclipse Foundation server MQTT

00:13:57,950 --> 00:14:06,170
has two byte fixed header first byte is

00:14:02,540 --> 00:14:08,510
message type and a bunch of flags second

00:14:06,170 --> 00:14:10,730
byte is remaining length it's followed

00:14:08,510 --> 00:14:13,010
by a bunch of variable headers which are

00:14:10,730 --> 00:14:17,660
different based on what message tribe it

00:14:13,010 --> 00:14:19,160
is the most relevant message type for

00:14:17,660 --> 00:14:21,380
this discussion is connect message type

00:14:19,160 --> 00:14:23,300
which is the first message that will be

00:14:21,380 --> 00:14:27,110
sent by the client to the broker in

00:14:23,300 --> 00:14:28,820
order to connect to the broker so here

00:14:27,110 --> 00:14:31,130
the variable headers would be protocol

00:14:28,820 --> 00:14:32,870
name version connect flags and keep a

00:14:31,130 --> 00:14:35,420
lifetime or after this is going to be

00:14:32,870 --> 00:14:38,960
the payload so if you look at these

00:14:35,420 --> 00:14:42,310
headers there is nothing similar to host

00:14:38,960 --> 00:14:45,410
header in HTTP so there is no way for

00:14:42,310 --> 00:14:47,510
impunity proxy to determine what is the

00:14:45,410 --> 00:14:50,810
logical target just based on the

00:14:47,510 --> 00:14:54,050
standard protocol headers so now though

00:14:50,810 --> 00:14:54,750
it has two options it can add its own

00:14:54,050 --> 00:14:58,530
custom header

00:14:54,750 --> 00:15:01,380
an expected client will have that custom

00:14:58,530 --> 00:15:04,080
headers in it if you do that you need

00:15:01,380 --> 00:15:07,830
client-side updates existing clients are

00:15:04,080 --> 00:15:12,900
not going to send that header can you do

00:15:07,830 --> 00:15:14,940
that in IOT maybe maybe not practice

00:15:12,900 --> 00:15:17,190
it's not probably practical to go and

00:15:14,940 --> 00:15:20,520
update hundreds and thousands of your

00:15:17,190 --> 00:15:23,040
devices with client-side updates so what

00:15:20,520 --> 00:15:25,560
do you do then you'll have to come up

00:15:23,040 --> 00:15:28,910
with some non-standard hacks and some

00:15:25,560 --> 00:15:33,300
tricks depending upon who you ask and

00:15:28,910 --> 00:15:35,940
the casing point here is SSH proxy the

00:15:33,300 --> 00:15:39,780
SSH support that we are adding to Diego

00:15:35,940 --> 00:15:41,660
how it is achieving the routing of Asus

00:15:39,780 --> 00:15:43,520
connections to appropriate app instance

00:15:41,660 --> 00:15:46,560
what it does today

00:15:43,520 --> 00:15:49,800
is that it expects the username to be

00:15:46,560 --> 00:15:51,570
the process good and index and then it

00:15:49,800 --> 00:15:53,790
knows yeah this is the process good this

00:15:51,570 --> 00:15:55,680
is the index I know I can look up in the

00:15:53,790 --> 00:15:57,930
routing table I know what host IP and

00:15:55,680 --> 00:16:01,140
port it is and then I can route it so

00:15:57,930 --> 00:16:05,210
now the clients need to provide the

00:16:01,140 --> 00:16:08,700
process grid and index as the username

00:16:05,210 --> 00:16:10,800
now it would be little bit better on the

00:16:08,700 --> 00:16:13,680
search side because we are going to

00:16:10,800 --> 00:16:15,720
provide SSH plug-in on the CLI so user

00:16:13,680 --> 00:16:17,610
is not going to worry about that they

00:16:15,720 --> 00:16:20,280
have to find out the process good and

00:16:17,610 --> 00:16:24,390
index and all that stuff IOT it's going

00:16:20,280 --> 00:16:26,130
to be difficult so but there now we have

00:16:24,390 --> 00:16:28,320
to see if there is any other easier way

00:16:26,130 --> 00:16:30,420
that we can achieve this kind of routing

00:16:28,320 --> 00:16:33,930
and if there is an easier way we should

00:16:30,420 --> 00:16:37,260
probably go with that and and see how

00:16:33,930 --> 00:16:39,810
that plays out and as it turns out the

00:16:37,260 --> 00:16:44,460
reason is your way we can do layer for

00:16:39,810 --> 00:16:46,680
routing so when we were looking at this

00:16:44,460 --> 00:16:49,080
various options Pia water was also

00:16:46,680 --> 00:16:51,740
looking at routing SMTP traffic to its

00:16:49,080 --> 00:16:55,380
app and it was considering the same

00:16:51,740 --> 00:16:58,920
particular option so we collaborated and

00:16:55,380 --> 00:17:01,560
we detailed this particular approach out

00:16:58,920 --> 00:17:03,780
and this approach is pretty simple and

00:17:01,560 --> 00:17:06,209
straightforward here what we are going

00:17:03,780 --> 00:17:08,070
to do is that we are going to map the

00:17:06,209 --> 00:17:11,480
external port of a router

00:17:08,070 --> 00:17:14,190
to a particular app what that means

00:17:11,480 --> 00:17:16,770
let's take an example let's say there

00:17:14,190 --> 00:17:19,500
was a tap to and it wants to listen on

00:17:16,770 --> 00:17:22,800
port 5222 it wants to listen for it's in

00:17:19,500 --> 00:17:27,540
people traffic so it Maps itself to port

00:17:22,800 --> 00:17:29,490
5222 of TCP route through one so and it

00:17:27,540 --> 00:17:33,960
gives out the front end IP of TCP router

00:17:29,490 --> 00:17:36,210
1 and port 5222 to its client and that's

00:17:33,960 --> 00:17:39,570
what it will use to connect and talk to

00:17:36,210 --> 00:17:41,850
app 2 over XMPP now let's say there was

00:17:39,570 --> 00:17:46,470
another app app for wants to listen on

00:17:41,850 --> 00:17:48,960
port 5222 now it has two options it can

00:17:46,470 --> 00:17:51,990
either map itself to some other port on

00:17:48,960 --> 00:17:54,540
TCP router 1 and give out the front end

00:17:51,990 --> 00:17:56,790
IP of TCP router 1 and that non-standard

00:17:54,540 --> 00:18:00,090
port to its client so that it can talk

00:17:56,790 --> 00:18:01,800
to at 4 or if it is not very tolerant or

00:18:00,090 --> 00:18:04,860
the clients are not very tolerant in

00:18:01,800 --> 00:18:06,720
terms of using non-standard ports then

00:18:04,860 --> 00:18:08,490
it can map itself to another TCP route

00:18:06,720 --> 00:18:16,230
for instance it has a different front

00:18:08,490 --> 00:18:17,850
end IP and map the same port 5222 so the

00:18:16,230 --> 00:18:19,770
idea here is you use port address

00:18:17,850 --> 00:18:22,710
mapping or port address translation and

00:18:19,770 --> 00:18:25,050
by virtue of receiving the traffic on

00:18:22,710 --> 00:18:27,180
that port you would be able to route you

00:18:25,050 --> 00:18:32,190
will be able to know which app this

00:18:27,180 --> 00:18:34,170
traffic is meant for and I promise we'll

00:18:32,190 --> 00:18:36,740
go more detailed and see what it

00:18:34,170 --> 00:18:40,320
actually takes in order to do all that

00:18:36,740 --> 00:18:41,820
but at this time I think it's good to

00:18:40,320 --> 00:18:44,400
take a look at what are its pros and

00:18:41,820 --> 00:18:47,070
cons you are going to get support for

00:18:44,400 --> 00:18:49,140
almost all layer 7 protocols from the

00:18:47,070 --> 00:18:51,120
word go you don't have to write any

00:18:49,140 --> 00:18:53,900
proxies you don't have to worry about

00:18:51,120 --> 00:18:57,060
coming up with some non-standard ways of

00:18:53,900 --> 00:18:59,850
developing routing mechanism for that

00:18:57,060 --> 00:19:02,790
proxies complexity is highly reduced of

00:18:59,850 --> 00:19:05,850
course on the flip side you might have

00:19:02,790 --> 00:19:10,290
to use non-standard ports for your iot

00:19:05,850 --> 00:19:13,230
protocols the major concern here though

00:19:10,290 --> 00:19:15,180
is about scalability now there are two

00:19:13,230 --> 00:19:16,860
type of scalability things to be

00:19:15,180 --> 00:19:21,299
considered here one is if you are

00:19:16,860 --> 00:19:24,299
tolerant towards non-standard ports

00:19:21,299 --> 00:19:26,879
then you are limited to 64k theoretical

00:19:24,299 --> 00:19:29,489
number of apps that can receive non HTTP

00:19:26,879 --> 00:19:31,049
traffic per router instance but

00:19:29,489 --> 00:19:32,940
workaround for that would be to have

00:19:31,049 --> 00:19:34,799
many more router instances in your

00:19:32,940 --> 00:19:38,580
deployment and you can overcome that

00:19:34,799 --> 00:19:42,539
scalability issue other is more more

00:19:38,580 --> 00:19:45,749
serious as in if you are not tolerant

00:19:42,539 --> 00:19:47,820
towards non-standard ports then you are

00:19:45,749 --> 00:19:52,169
limited by the number of front-end IPS

00:19:47,820 --> 00:19:54,330
your is can give you and there is really

00:19:52,169 --> 00:19:55,830
no good answer for that unless your

00:19:54,330 --> 00:20:00,359
clients are tolerant towards

00:19:55,830 --> 00:20:02,519
non-standard ports in which case I mean

00:20:00,359 --> 00:20:05,249
as things evolve we might go with a

00:20:02,519 --> 00:20:10,409
hybrid approach but as of now this is

00:20:05,249 --> 00:20:12,450
the one that is we are going with and as

00:20:10,409 --> 00:20:14,840
I promised I'm going to dig a little

00:20:12,450 --> 00:20:18,570
deeper and take a little closer look at

00:20:14,840 --> 00:20:23,249
how we are going to develop support for

00:20:18,570 --> 00:20:25,409
this TCP routing in Cloud Foundry if you

00:20:23,249 --> 00:20:28,739
guys have attended on sis talk in the

00:20:25,409 --> 00:20:31,559
morning he indicated that TCP routing is

00:20:28,739 --> 00:20:33,029
going to be part of Diego and what that

00:20:31,559 --> 00:20:34,559
means is that it's not going to be

00:20:33,029 --> 00:20:37,559
available for apps that are running on

00:20:34,559 --> 00:20:40,889
de a this will be developed based on

00:20:37,559 --> 00:20:44,359
Diego and will be part of Diego so one

00:20:40,889 --> 00:20:46,859
more reason for you guys to adopt Diego

00:20:44,359 --> 00:20:48,989
so this is a crystal block diagram of

00:20:46,859 --> 00:20:51,239
Diego I'm not going to go into details

00:20:48,989 --> 00:20:52,879
of this but I'm going to talk about the

00:20:51,239 --> 00:20:55,139
new components that we are going to add

00:20:52,879 --> 00:20:58,850
there are two new components that will

00:20:55,139 --> 00:21:02,759
be added first is the TCP route emitter

00:20:58,850 --> 00:21:04,559
now this could this is a logical

00:21:02,759 --> 00:21:05,909
component whether it becomes the part of

00:21:04,559 --> 00:21:08,249
existing route emitter or is the

00:21:05,909 --> 00:21:12,600
separate component is to be determined

00:21:08,249 --> 00:21:14,549
and will decide that as we execute but

00:21:12,600 --> 00:21:17,929
functionally what this TCP route emitter

00:21:14,549 --> 00:21:20,519
is going to do is that it's going to

00:21:17,929 --> 00:21:23,279
subscribe the server side event stream

00:21:20,519 --> 00:21:25,200
from receptor which is going to let it

00:21:23,279 --> 00:21:28,830
know about changes in actual and desired

00:21:25,200 --> 00:21:33,080
LR piece what that means is when app is

00:21:28,830 --> 00:21:34,890
placed or applets mood or applet scaled

00:21:33,080 --> 00:21:37,320
will note we

00:21:34,890 --> 00:21:40,200
be notified about it and then the router

00:21:37,320 --> 00:21:42,960
meter is going to get that information

00:21:40,200 --> 00:21:44,520
and give it to TCP router which is going

00:21:42,960 --> 00:21:47,730
to maintain the routing table which is

00:21:44,520 --> 00:21:50,880
the mapping of front-end IP and port to

00:21:47,730 --> 00:21:53,760
your back-end IPS and ports so as soon

00:21:50,880 --> 00:21:55,920
as the data is received its it will be

00:21:53,760 --> 00:21:59,280
able to route to the appropriate app

00:21:55,920 --> 00:22:01,440
instance now if you'll notice here I

00:21:59,280 --> 00:22:05,220
have added TCP router and disappeared

00:22:01,440 --> 00:22:06,990
out a meter as part of lattice because

00:22:05,220 --> 00:22:08,700
this will be packaged as part of lattice

00:22:06,990 --> 00:22:12,450
and that this is going to be our first

00:22:08,700 --> 00:22:14,490
deliverable will down of this components

00:22:12,450 --> 00:22:19,380
and we will ship it as part of lattice

00:22:14,490 --> 00:22:22,650
so your lattice apps can receive 90 non

00:22:19,380 --> 00:22:25,350
HTTP traffic so there are obviously a

00:22:22,650 --> 00:22:26,700
lot more things that are involved and

00:22:25,350 --> 00:22:29,040
that lot of things that we need to

00:22:26,700 --> 00:22:32,070
consider and I'm going to talk about all

00:22:29,040 --> 00:22:33,230
of them but by no means this is an

00:22:32,070 --> 00:22:36,360
exhaustive list

00:22:33,230 --> 00:22:39,480
I'm sure if Shannon is here he knows he

00:22:36,360 --> 00:22:42,360
is going to add a lot more he's our PM

00:22:39,480 --> 00:22:44,550
for this project obviously we are going

00:22:42,360 --> 00:22:46,800
to route TCP traffic and I'm calling out

00:22:44,550 --> 00:22:49,410
TCP here because we are not going to

00:22:46,800 --> 00:22:51,840
support UDP at this time if there is a

00:22:49,410 --> 00:22:54,090
need and there is a requirement we will

00:22:51,840 --> 00:22:57,330
add UDP support in future but that's not

00:22:54,090 --> 00:22:58,470
on course as of today one of the

00:22:57,330 --> 00:23:02,010
important things that we are going to

00:22:58,470 --> 00:23:03,630
consider is zero downtime whenever there

00:23:02,010 --> 00:23:05,790
are conflicting is that are happening

00:23:03,630 --> 00:23:09,180
when a new app gets placed AB gets

00:23:05,790 --> 00:23:11,460
scaled up or down we have to make sure

00:23:09,180 --> 00:23:13,770
that the existing connections do not go

00:23:11,460 --> 00:23:15,800
down now depending upon whether we are

00:23:13,770 --> 00:23:18,480
using H a proxy for TCP router

00:23:15,800 --> 00:23:20,520
switchboard which is our existing TCP

00:23:18,480 --> 00:23:22,500
router that's used in services or we

00:23:20,520 --> 00:23:24,870
write our own that's one of the main

00:23:22,500 --> 00:23:26,880
things that we will be doing we will

00:23:24,870 --> 00:23:30,180
make sure that there is zero downtime

00:23:26,880 --> 00:23:31,980
for existing connections if you have

00:23:30,180 --> 00:23:35,340
more than one app instance we will be

00:23:31,980 --> 00:23:37,770
providing you a way to do some load

00:23:35,340 --> 00:23:41,100
balancing either round-robin weighted

00:23:37,770 --> 00:23:44,760
round robin we will be providing a way

00:23:41,100 --> 00:23:47,790
for doing health checks so we don't want

00:23:44,760 --> 00:23:48,080
to route the you do not want to route

00:23:47,790 --> 00:23:49,940
the

00:23:48,080 --> 00:23:51,980
traffic to an app instance that's down

00:23:49,940 --> 00:23:53,600
or it's crashing we want to make sure

00:23:51,980 --> 00:23:56,780
that we route it to an app instance

00:23:53,600 --> 00:23:58,160
that's up and running purely providing

00:23:56,780 --> 00:24:00,380
some kind of traffic shaping and

00:23:58,160 --> 00:24:04,610
limiting number of connections that can

00:24:00,380 --> 00:24:06,410
be made simultaneously what is the

00:24:04,610 --> 00:24:08,840
connection rate so those things can be

00:24:06,410 --> 00:24:11,060
controlled we have to manage back-end

00:24:08,840 --> 00:24:13,220
ports so that we don't run out of the

00:24:11,060 --> 00:24:15,770
back inputs and that could happen

00:24:13,220 --> 00:24:17,990
because of buggy TCP clients they don't

00:24:15,770 --> 00:24:20,810
close the connection the ports going to

00:24:17,990 --> 00:24:23,510
film it to straight and then we run out

00:24:20,810 --> 00:24:26,090
of ports we have to manage rolling

00:24:23,510 --> 00:24:28,430
deploys so that we give enough grace

00:24:26,090 --> 00:24:30,230
time to the existing apps and clients to

00:24:28,430 --> 00:24:31,760
shut down their existing connections

00:24:30,230 --> 00:24:36,110
gracefully so that those could be

00:24:31,760 --> 00:24:38,810
upgraded obviously we have to provide a

00:24:36,110 --> 00:24:40,820
way to reserve the front end IPS and

00:24:38,810 --> 00:24:43,010
poor combination that's going to be

00:24:40,820 --> 00:24:44,720
achieved using changes to call Cloud

00:24:43,010 --> 00:24:46,340
Controller and now cloud controller is

00:24:44,720 --> 00:24:48,890
going to make sure that there is no

00:24:46,340 --> 00:24:51,200
conflicts if there are two apps trying

00:24:48,890 --> 00:24:53,450
to get front-end IP and port combination

00:24:51,200 --> 00:24:56,360
it will detect that it will prevent one

00:24:53,450 --> 00:24:58,610
of them will provide a way for you to

00:24:56,360 --> 00:25:01,370
add remove and show these mappings so

00:24:58,610 --> 00:25:05,410
that means CLI changes will be done and

00:25:01,370 --> 00:25:08,000
you would also be able to do this

00:25:05,410 --> 00:25:11,840
mapping for front-end IP and port using

00:25:08,000 --> 00:25:14,180
application manifest so now I would like

00:25:11,840 --> 00:25:17,360
to conclude here by just calling for

00:25:14,180 --> 00:25:19,250
your feedback and comments from the

00:25:17,360 --> 00:25:22,880
community and we would like to

00:25:19,250 --> 00:25:25,670
especially hear about your IOT use cases

00:25:22,880 --> 00:25:29,260
or any use cases that need non HTTP

00:25:25,670 --> 00:25:31,580
traffic and I put up my contact

00:25:29,260 --> 00:25:33,280
information and contact information of

00:25:31,580 --> 00:25:36,110
Shannon who is the PM for this project

00:25:33,280 --> 00:25:38,120
we would be glad to hear from you and we

00:25:36,110 --> 00:25:40,310
looking forward to add this

00:25:38,120 --> 00:25:44,960
functionality to Cloud Foundry to make

00:25:40,310 --> 00:25:46,080
it and platform of choice for IOT thank

00:25:44,960 --> 00:25:52,760
you

00:25:46,080 --> 00:25:54,990
[Applause]

00:25:52,760 --> 00:25:59,270
you have four more minutes for question

00:25:54,990 --> 00:25:59,270
or I have a demo whatever you choose

00:26:11,130 --> 00:26:13,190
you

00:26:29,290 --> 00:26:36,680
yes so the way we authenticate devices

00:26:33,650 --> 00:26:39,140
is using client certificates and since

00:26:36,680 --> 00:26:40,400
this is going to operate at layer 4 we

00:26:39,140 --> 00:26:42,020
would be able to flow the client

00:26:40,400 --> 00:26:44,960
certificates all the way to the apps and

00:26:42,020 --> 00:26:54,320
apps will be able to authenticate using

00:26:44,960 --> 00:26:59,990
the trust role that they would have been

00:26:54,320 --> 00:27:01,850
in so we should start off next week

00:26:59,990 --> 00:27:06,260
I don't know Shannon is here Shannon is

00:27:01,850 --> 00:27:10,040
here if you couldn't stand we would get

00:27:06,260 --> 00:27:12,980
started next week and as soon as we have

00:27:10,040 --> 00:27:14,780
certain stability will it would be part

00:27:12,980 --> 00:27:16,570
of Cloud Foundry incubator should be

00:27:14,780 --> 00:27:18,620
available for anyone and everyone to see

00:27:16,570 --> 00:27:20,929
first up which would be available as

00:27:18,620 --> 00:27:23,350
part of lattice for you to play and see

00:27:20,929 --> 00:27:23,350
how it goes

00:27:30,190 --> 00:27:35,650
we have time and this is against all

00:27:33,520 --> 00:27:40,480
their voice that I have got of not doing

00:27:35,650 --> 00:27:48,340
live demos but I'm going to do it

00:27:40,480 --> 00:27:51,610
anyways so what I'm doing is that I'm

00:27:48,340 --> 00:27:54,790
doing a Bosch SSH into one of the cells

00:27:51,610 --> 00:27:58,480
where I have already pushed an app which

00:27:54,790 --> 00:28:00,700
is actually nothing but an netcat server

00:27:58,480 --> 00:28:03,280
it just listens on port three four five

00:28:00,700 --> 00:28:04,750
six and is this listens for anything and

00:28:03,280 --> 00:28:16,290
everything that you are cool to send to

00:28:04,750 --> 00:28:16,290
it oh sure better

00:28:28,909 --> 00:28:36,409
what I'm doing now is that I am going to

00:28:31,190 --> 00:28:40,879
go into I'm going to go into the

00:28:36,409 --> 00:28:44,139
container and I'm going to show you the

00:28:40,879 --> 00:28:47,659
process that's running this is the app

00:28:44,139 --> 00:28:50,570
well it's a dead cat server listening on

00:28:47,659 --> 00:28:52,820
some port and it's whatever it is

00:28:50,570 --> 00:28:54,229
getting it's putting it into a file it's

00:28:52,820 --> 00:29:08,419
putting it into temp output I'm just

00:28:54,229 --> 00:29:10,309
gonna and I'm gonna hop up here and I'm

00:29:08,419 --> 00:29:13,099
going to open a connection so as I said

00:29:10,309 --> 00:29:17,379
here if you see this first is the front

00:29:13,099 --> 00:29:25,759
end IP and the port and I'm gonna say

00:29:17,379 --> 00:29:32,570
Cloud Foundry summit rocks we received

00:29:25,759 --> 00:29:34,340
that here so we will be able to yeah so

00:29:32,570 --> 00:29:36,739
we'll get this and obviously we will

00:29:34,340 --> 00:29:39,979
this is obviously a POC that I put up

00:29:36,739 --> 00:29:41,479
together for this talk but you should

00:29:39,979 --> 00:29:45,679
all come together in a nice way which

00:29:41,479 --> 00:29:47,330
you can use and be able to I hope you

00:29:45,679 --> 00:29:51,109
get to give it a try give you a feedback

00:29:47,330 --> 00:29:54,739
and glad to hear from you

00:29:51,109 --> 00:29:56,330
and I'm hoping we'll get be able to get

00:29:54,739 --> 00:29:59,950
this functionality out as soon as

00:29:56,330 --> 00:29:59,950
possible thank you

00:30:01,490 --> 00:30:03,550

YouTube URL: https://www.youtube.com/watch?v=RCZce-l9EsI


