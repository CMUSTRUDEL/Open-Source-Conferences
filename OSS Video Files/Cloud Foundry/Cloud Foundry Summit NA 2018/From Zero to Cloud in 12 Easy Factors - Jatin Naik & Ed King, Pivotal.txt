Title: From Zero to Cloud in 12 Easy Factors - Jatin Naik & Ed King, Pivotal
Publication date: 2018-04-21
Playlist: Cloud Foundry Summit NA 2018
Description: 
	From Zero to Cloud in 12 Easy Factors - Jatin Naik & Ed King, Pivotal

It’s no secret that Cloud Foundry provides an amazing platform to deploy and run your applications, and getting your applications deployed to the Cloud is as easy as `cf push`, right? Well, yes, assuming your .NET applications are ready for the cloud. There are a number of “rules” your apps need to abide by in order to get the maximum value from the platform. These rules are commonly referred to as the “12 Factors”.

I’m sure you’ve probably heard of the term “12 factor”, but what exactly does it mean, and more importantly, what needs to be done to take your existing apps and convert them to “12 factor” apps?

For this session, Ed and Jatin have prepared a “0 factor" ASP.NET/C# web app, one that is completely unsuitable for the Cloud. Join them as they transform the app, factor-by-factor, into one that is Cloud Native and ready for the Foundry. 

About Ed King
Ed is a Systems Engineer currently working on the Cloud Foundry Garden project. He has spoken at CFSummit Santa Clara 2016.

About Jatin Naik
Jatin is a software engineer for Pivotal Cloud Foundry, currently working on BOSH Backup & Restore. He has previously spoken at Cloud Foundry Summit Silicon Valley 2017, Cloud Foundry Summit Europe 2016 and is a regular at the London PaaS User Group.
Captions: 
	00:00:00,260 --> 00:00:09,179
all right hello cool I think we're I

00:00:04,770 --> 00:00:10,650
think we're gonna get started so hello

00:00:09,179 --> 00:00:13,799
everyone thank you very much for joining

00:00:10,650 --> 00:00:17,340
us today this talk is from zero to cloud

00:00:13,799 --> 00:00:19,830
in 12 easy factors before we get started

00:00:17,340 --> 00:00:22,560
here's the obligatory for our exit

00:00:19,830 --> 00:00:24,990
announcement it will be by far the most

00:00:22,560 --> 00:00:28,199
important slide you read today please

00:00:24,990 --> 00:00:30,660
take note so okay so my name is Ed King

00:00:28,199 --> 00:00:32,759
I'm an engineer working for pivotal out

00:00:30,660 --> 00:00:34,920
of the London office currently working

00:00:32,759 --> 00:00:36,690
on the Cloud Foundry garden team and

00:00:34,920 --> 00:00:38,640
this is my colleague Jatin who works

00:00:36,690 --> 00:00:44,640
with me at London as well as one of the

00:00:38,640 --> 00:00:45,690
engineering leads down there so someone

00:00:44,640 --> 00:00:48,870
once told me that every good

00:00:45,690 --> 00:00:51,199
presentation tells a good story and this

00:00:48,870 --> 00:00:54,510
is really a story of transformation

00:00:51,199 --> 00:00:56,969
transformation of a legacy old-school

00:00:54,510 --> 00:00:59,760
dotnet application into one that is much

00:00:56,969 --> 00:01:02,820
more modern and suitable for deployment

00:00:59,760 --> 00:01:06,210
to modern cloud platforms such as cloud

00:01:02,820 --> 00:01:08,189
foundry so specifically what we wanted

00:01:06,210 --> 00:01:11,400
to talk about today was the 12 factor

00:01:08,189 --> 00:01:12,960
application manifesto what it is where

00:01:11,400 --> 00:01:15,450
it came from why you should care about

00:01:12,960 --> 00:01:17,520
it and we thought that the best way to

00:01:15,450 --> 00:01:20,880
do this would be to go through each of

00:01:17,520 --> 00:01:23,610
the factors step by step and to take a

00:01:20,880 --> 00:01:26,880
look at exactly what each factor is and

00:01:23,610 --> 00:01:30,650
to then demonstrate that factor in

00:01:26,880 --> 00:01:34,079
practice against an actual application

00:01:30,650 --> 00:01:36,110
and so Jatin and I have developed what

00:01:34,079 --> 00:01:38,400
we're calling a zero factor application

00:01:36,110 --> 00:01:40,890
so this is one that is completely

00:01:38,400 --> 00:01:45,240
unsuitable for deployment to cloud

00:01:40,890 --> 00:01:46,950
platforms such as cloud foundry and so

00:01:45,240 --> 00:01:49,380
with that in mind let me hand over to

00:01:46,950 --> 00:01:53,549
Jatin to describe our example

00:01:49,380 --> 00:01:55,409
application all right so the example

00:01:53,549 --> 00:01:58,530
application that will be transforming

00:01:55,409 --> 00:02:01,710
today is called slow Graham so just like

00:01:58,530 --> 00:02:06,350
Instagram but it does it much slower so

00:02:01,710 --> 00:02:06,350
the application itself is

00:02:08,380 --> 00:02:15,880
right so the application itself is a

00:02:11,340 --> 00:02:18,430
very simple asp.net application it uses

00:02:15,880 --> 00:02:22,000
the dotnet core framework what the user

00:02:18,430 --> 00:02:25,540
can do is upload an image and that image

00:02:22,000 --> 00:02:27,760
will be a specific image filter will be

00:02:25,540 --> 00:02:30,070
applied on that image and then the image

00:02:27,760 --> 00:02:32,860
will be displayed back to the user so

00:02:30,070 --> 00:02:35,050
the user can see two queues like a queue

00:02:32,860 --> 00:02:39,820
of unprocessed images and a queue of

00:02:35,050 --> 00:02:42,310
processed images so in this uses the

00:02:39,820 --> 00:02:43,960
application itself is very simple it

00:02:42,310 --> 00:02:46,540
uses like a thread for background

00:02:43,960 --> 00:02:48,550
processing there are there's an

00:02:46,540 --> 00:02:50,590
interesting way in which it has deployed

00:02:48,550 --> 00:02:53,410
so it's currently deployed on a shared

00:02:50,590 --> 00:02:55,540
ISS instance it uses the file system to

00:02:53,410 --> 00:02:57,850
do everything so all the images that

00:02:55,540 --> 00:02:59,370
have been uploaded just go and stay on

00:02:57,850 --> 00:03:02,170
the file system that the server is the

00:02:59,370 --> 00:03:05,260
application is running on it uses a

00:03:02,170 --> 00:03:07,290
local data store like sequel light that

00:03:05,260 --> 00:03:11,740
it connects to for storing its

00:03:07,290 --> 00:03:15,580
relational data the the way that you

00:03:11,740 --> 00:03:18,790
update the app is you go to your

00:03:15,580 --> 00:03:22,150
daughter project click publish get a DLL

00:03:18,790 --> 00:03:23,380
ensure that the version of.net that you

00:03:22,150 --> 00:03:26,050
have installed on your local machine is

00:03:23,380 --> 00:03:28,180
the same as the server email the binary

00:03:26,050 --> 00:03:31,810
to the server through the operator and

00:03:28,180 --> 00:03:35,980
then they will put this DLL in in a

00:03:31,810 --> 00:03:38,770
specific folder in ISS and wait for no

00:03:35,980 --> 00:03:40,450
like wait for all the processing to get

00:03:38,770 --> 00:03:45,250
up get to a pause and then restart the

00:03:40,450 --> 00:03:46,990
server we have been there and if so one

00:03:45,250 --> 00:03:50,080
of the one of the problems with this

00:03:46,990 --> 00:03:52,390
application is it is very difficult to

00:03:50,080 --> 00:03:55,600
update and if it receive too much

00:03:52,390 --> 00:03:57,280
traffic the only the only amount of

00:03:55,600 --> 00:03:58,540
traffic that it can handle is the

00:03:57,280 --> 00:04:01,540
capacity of the server that it is

00:03:58,540 --> 00:04:03,160
deployed in so once it's if it starts to

00:04:01,540 --> 00:04:06,910
get a lot of traffic it will start to

00:04:03,160 --> 00:04:08,500
throw for tutus and and what's happening

00:04:06,910 --> 00:04:10,780
now is like this app is really going

00:04:08,500 --> 00:04:13,030
viral and like we really need to find an

00:04:10,780 --> 00:04:15,760
effective way to scale it and we know

00:04:13,030 --> 00:04:19,200
that CF is good for that sort of thing

00:04:15,760 --> 00:04:19,200
so can we just push it to CF

00:04:19,239 --> 00:04:23,120
yeah so I think that's really that's

00:04:21,620 --> 00:04:24,830
really going to be the crux for the rest

00:04:23,120 --> 00:04:26,360
of this talk is we're going to be trying

00:04:24,830 --> 00:04:28,940
to take this old-school legacy

00:04:26,360 --> 00:04:32,330
application and successfully pushing and

00:04:28,940 --> 00:04:34,130
scaling it on Cloud Foundry but before

00:04:32,330 --> 00:04:35,720
we get into that I think it's probably a

00:04:34,130 --> 00:04:38,600
good idea just to get like a high-level

00:04:35,720 --> 00:04:40,880
overview of off the 12 factors like what

00:04:38,600 --> 00:04:42,470
we're actually talking about here so I

00:04:40,880 --> 00:04:44,960
think maybe the best way to describe

00:04:42,470 --> 00:04:47,180
this is there really a set of best

00:04:44,960 --> 00:04:48,950
practices and learnings that developers

00:04:47,180 --> 00:04:51,169
can apply to their applications as

00:04:48,950 --> 00:04:53,660
they're developing them in order to

00:04:51,169 --> 00:04:56,510
output something that is suitable for

00:04:53,660 --> 00:05:00,770
deployment and development on cloud

00:04:56,510 --> 00:05:02,690
platforms such as cloud foundry so the

00:05:00,770 --> 00:05:04,750
idea kind of originated from engineers

00:05:02,690 --> 00:05:07,520
who were working at Haruki

00:05:04,750 --> 00:05:10,130
so Heroku is like another modern cloud

00:05:07,520 --> 00:05:13,010
platform it's obviously not quite as

00:05:10,130 --> 00:05:15,590
good as Cloud Foundry but that's kind of

00:05:13,010 --> 00:05:17,750
where this originated and so by the time

00:05:15,590 --> 00:05:19,729
the engine is there were witnessing and

00:05:17,750 --> 00:05:22,550
overseeing thousands and thousands and

00:05:19,729 --> 00:05:25,130
thousands of deployments like on a daily

00:05:22,550 --> 00:05:27,140
basis and over time they sort of started

00:05:25,130 --> 00:05:29,050
to notice some of the patterns and best

00:05:27,140 --> 00:05:31,970
practices that were emerging from those

00:05:29,050 --> 00:05:33,560
they had a good insight into the kinds

00:05:31,970 --> 00:05:35,090
of things that were working what wasn't

00:05:33,560 --> 00:05:37,370
working what was making life difficult

00:05:35,090 --> 00:05:39,620
and they essentially gathered all of

00:05:37,370 --> 00:05:43,220
that knowledge together into what we now

00:05:39,620 --> 00:05:44,660
call the twelve factors and I think at

00:05:43,220 --> 00:05:46,220
least for me I think like the key point

00:05:44,660 --> 00:05:48,860
about this is like the twelfth factor

00:05:46,220 --> 00:05:52,490
application it's but it's focused on

00:05:48,860 --> 00:05:53,900
statelessness so state is bad state is

00:05:52,490 --> 00:05:55,370
very difficult to manage and it

00:05:53,900 --> 00:05:57,650
generally makes your lie was very

00:05:55,370 --> 00:06:00,560
difficult and so by designing your

00:05:57,650 --> 00:06:02,510
applications in a way which minimize how

00:06:00,560 --> 00:06:03,830
much state that they're depending on or

00:06:02,510 --> 00:06:06,860
the way in which they depend on the

00:06:03,830 --> 00:06:11,090
state is going to lead us in a leave us

00:06:06,860 --> 00:06:12,889
in a better situation so just briefly

00:06:11,090 --> 00:06:14,419
that's what the twelve factors are and

00:06:12,889 --> 00:06:16,550
it might not mean too much to you right

00:06:14,419 --> 00:06:18,800
now but we're hoping to cover most of

00:06:16,550 --> 00:06:20,840
these probably won't get through all of

00:06:18,800 --> 00:06:22,430
them as we haven't got a lot of time

00:06:20,840 --> 00:06:26,720
here but we certainly covered the main

00:06:22,430 --> 00:06:28,370
ones so let's get started let's get

00:06:26,720 --> 00:06:31,039
started with an easy one and the first

00:06:28,370 --> 00:06:32,580
factor is code base and the code base

00:06:31,039 --> 00:06:35,789
factor states that

00:06:32,580 --> 00:06:37,800
every application must have a single

00:06:35,789 --> 00:06:39,889
corresponding codebase and that that

00:06:37,800 --> 00:06:41,729
codebase must store in version control I

00:06:39,889 --> 00:06:43,110
don't want to spend too much time on

00:06:41,729 --> 00:06:45,599
this because I hope everyone is already

00:06:43,110 --> 00:06:47,819
sort of doing this if you're not you you

00:06:45,599 --> 00:06:50,340
really should be why do we want to do

00:06:47,819 --> 00:06:52,800
this obviously to allow for proper

00:06:50,340 --> 00:06:55,020
versioning of our applications and to

00:06:52,800 --> 00:06:57,689
support collaboration between teams and

00:06:55,020 --> 00:07:02,849
developers how do you do this well just

00:06:57,689 --> 00:07:05,129
use git basically cool

00:07:02,849 --> 00:07:07,919
so okay so let's actually run through

00:07:05,129 --> 00:07:10,169
this and you know whenever you read any

00:07:07,919 --> 00:07:12,509
tutorials or look at any documentation

00:07:10,169 --> 00:07:15,180
online it all just says that all you

00:07:12,509 --> 00:07:17,659
need to do is run CF push right so we

00:07:15,180 --> 00:07:20,159
thought that we would actually try this

00:07:17,659 --> 00:07:22,050
but just before we do there's just

00:07:20,159 --> 00:07:25,560
enough time to mention this other factor

00:07:22,050 --> 00:07:26,940
here which is build release run so this

00:07:25,560 --> 00:07:29,250
factor states that there must be a

00:07:26,940 --> 00:07:32,370
strict separation between the build

00:07:29,250 --> 00:07:34,289
release and run stages so the build

00:07:32,370 --> 00:07:36,259
stage is where we take the application

00:07:34,289 --> 00:07:38,879
code and convert it into an executable

00:07:36,259 --> 00:07:41,310
the release stage is where we apply the

00:07:38,879 --> 00:07:43,919
deployment sorry apply the deployments

00:07:41,310 --> 00:07:45,750
configuration to that SQL and then the

00:07:43,919 --> 00:07:48,000
run stage is when we actually run it and

00:07:45,750 --> 00:07:49,379
the reason i mentioning this here is

00:07:48,000 --> 00:07:51,930
because this is basically what's

00:07:49,379 --> 00:07:54,779
happening when you run a CF push so

00:07:51,930 --> 00:08:01,080
Cloud Foundry just does this for you so

00:07:54,779 --> 00:08:03,509
let's take a look cool and so we're not

00:08:01,080 --> 00:08:05,940
actually doing this live because this

00:08:03,509 --> 00:08:06,960
takes quite a lot of time and we would

00:08:05,940 --> 00:08:11,089
just spend the whole time kind of

00:08:06,960 --> 00:08:14,610
watching this screen and but there we go

00:08:11,089 --> 00:08:18,210
alright so as you see like as I'd

00:08:14,610 --> 00:08:21,449
mentioned is running it's a build

00:08:18,210 --> 00:08:23,789
process which will create binary for you

00:08:21,449 --> 00:08:26,729
and attempt to run it so you don't

00:08:23,789 --> 00:08:28,979
really have to worry about the code map

00:08:26,729 --> 00:08:30,900
like the framework version mismatches

00:08:28,979 --> 00:08:35,099
between your servers you just have to

00:08:30,900 --> 00:08:39,089
give your code to the platform but we

00:08:35,099 --> 00:08:42,469
see that the the push process has failed

00:08:39,089 --> 00:08:46,110
it has failed in the compilation step so

00:08:42,469 --> 00:08:48,920
the the way the app was deployed before

00:08:46,110 --> 00:08:52,590
so it's saying that it cannot find the

00:08:48,920 --> 00:08:55,020
image image processing library so the

00:08:52,590 --> 00:08:57,030
way the app was deployed before this

00:08:55,020 --> 00:08:58,770
image processing library was essentially

00:08:57,030 --> 00:09:00,690
shared by a lot of other applications

00:08:58,770 --> 00:09:03,120
that were also deployed on our shared

00:09:00,690 --> 00:09:05,540
Isis instance so the operator used to go

00:09:03,120 --> 00:09:08,550
in and install this for us

00:09:05,540 --> 00:09:10,170
so we cannot really rely on such

00:09:08,550 --> 00:09:12,960
processes when we are pushing to the

00:09:10,170 --> 00:09:16,020
cloud so which brings us to the factor

00:09:12,960 --> 00:09:17,700
of dependencies so this is a key

00:09:16,020 --> 00:09:19,380
requirement what wow factor applications

00:09:17,700 --> 00:09:21,450
like all of your dependencies should be

00:09:19,380 --> 00:09:23,670
explicitly declared so that the build

00:09:21,450 --> 00:09:25,530
process and can go in and pick it up and

00:09:23,670 --> 00:09:28,140
install it for you

00:09:25,530 --> 00:09:31,170
dotnet applications are pretty good at

00:09:28,140 --> 00:09:33,870
this from the get-go because of the DLL

00:09:31,170 --> 00:09:37,350
hell experiences of the past but there

00:09:33,870 --> 00:09:39,960
are still there still some dependencies

00:09:37,350 --> 00:09:42,270
or some administrators which will allow

00:09:39,960 --> 00:09:44,160
our shared dependencies to be installed

00:09:42,270 --> 00:09:46,980
on the server just to save on artifact

00:09:44,160 --> 00:09:48,420
size or whatever we cannot rely on such

00:09:46,980 --> 00:09:51,000
optimizations anymore when we are

00:09:48,420 --> 00:09:54,540
pushing to a cloud cloud Allah 12

00:09:51,000 --> 00:09:57,630
platform so the way that to fix this is

00:09:54,540 --> 00:10:00,060
just to use dependency declaration too

00:09:57,630 --> 00:10:03,120
so there are a lot available for dotnet

00:10:00,060 --> 00:10:05,970
we are just we want to use nugget which

00:10:03,120 --> 00:10:08,760
which is the default now for dotnet core

00:10:05,970 --> 00:10:10,470
so in like this is our current

00:10:08,760 --> 00:10:12,870
dependency declaration we just

00:10:10,470 --> 00:10:16,290
explicitly add our image processing

00:10:12,870 --> 00:10:20,910
library there and let's try to CF push

00:10:16,290 --> 00:10:23,280
again so yes so as a as a side note

00:10:20,910 --> 00:10:26,670
while this is happening like if you have

00:10:23,280 --> 00:10:28,530
some specific OS OS level dependencies

00:10:26,670 --> 00:10:32,010
like binaries that have to be available

00:10:28,530 --> 00:10:33,990
on the server for processing you can

00:10:32,010 --> 00:10:36,510
create a special folder called LD

00:10:33,990 --> 00:10:39,120
library spot and then the belt pack will

00:10:36,510 --> 00:10:40,710
take care of making this those libraries

00:10:39,120 --> 00:10:46,770
available when the application is

00:10:40,710 --> 00:10:48,120
running so I think now we have pushed

00:10:46,770 --> 00:10:50,940
again and we've got a little bit further

00:10:48,120 --> 00:10:53,190
this time but now it appears as though

00:10:50,940 --> 00:10:55,110
the push is hanging and I think

00:10:53,190 --> 00:10:58,920
eventually we're going to see that it

00:10:55,110 --> 00:10:59,910
fails so what's happening here as we

00:10:58,920 --> 00:11:02,250
could see it asked

00:10:59,910 --> 00:11:03,870
us to run the CF logs slow Graham

00:11:02,250 --> 00:11:04,800
command in order to get some more help

00:11:03,870 --> 00:11:07,290
it

00:11:04,800 --> 00:11:09,570
incidentally like logging is actually

00:11:07,290 --> 00:11:11,790
another one of the factors I'm not going

00:11:09,570 --> 00:11:12,840
to talk too much about that now maybe if

00:11:11,790 --> 00:11:15,450
we got some time at the end I might

00:11:12,840 --> 00:11:17,520
might might come back to that but for

00:11:15,450 --> 00:11:25,770
the purposes of this let's just run that

00:11:17,520 --> 00:11:27,750
command and see what it's telling us all

00:11:25,770 --> 00:11:29,180
right so we can see the output there and

00:11:27,750 --> 00:11:31,770
there's a fairly obvious error message

00:11:29,180 --> 00:11:34,980
failed to make a TCP connection to port

00:11:31,770 --> 00:11:36,240
8080 connection refused so in order to

00:11:34,980 --> 00:11:37,920
understand this I think we're going to

00:11:36,240 --> 00:11:39,960
need to talk about two things

00:11:37,920 --> 00:11:42,480
firstly the Cloud Foundry health check

00:11:39,960 --> 00:11:46,440
process and then secondly it's our next

00:11:42,480 --> 00:11:47,550
factor which relates to config so the

00:11:46,440 --> 00:11:49,170
health check process this is something

00:11:47,550 --> 00:11:51,480
that's periodically running against

00:11:49,170 --> 00:11:54,030
applications that you deploy and the way

00:11:51,480 --> 00:11:56,490
it works is it attempts to connect to a

00:11:54,030 --> 00:11:58,500
port and if it can't connect to that

00:11:56,490 --> 00:12:01,080
port it assumes that your application is

00:11:58,500 --> 00:12:02,670
crashed at which point cloud Faudree

00:12:01,080 --> 00:12:06,360
will bring up another instance of that

00:12:02,670 --> 00:12:10,640
application and the way that this works

00:12:06,360 --> 00:12:13,380
is cloud Rodri needs to know the port or

00:12:10,640 --> 00:12:15,690
sorry let me let me start early on so

00:12:13,380 --> 00:12:17,250
the reason this is failing is because as

00:12:15,690 --> 00:12:19,380
jadon mentioned earlier like we had some

00:12:17,250 --> 00:12:22,740
fairly strict networking requirements in

00:12:19,380 --> 00:12:24,720
our current deployment so this is this

00:12:22,740 --> 00:12:26,790
is kind of maybe a fairly contrived

00:12:24,720 --> 00:12:27,930
example but but bear with us because I

00:12:26,790 --> 00:12:30,990
think it kind of demonstrates the point

00:12:27,930 --> 00:12:33,420
here we are hard-coding some

00:12:30,990 --> 00:12:34,950
configuration into our application right

00:12:33,420 --> 00:12:37,080
so right here it's saying that you must

00:12:34,950 --> 00:12:38,490
be using port 9000 and that's why the

00:12:37,080 --> 00:12:40,980
health checks failing because Cloud

00:12:38,490 --> 00:12:42,540
Foundry expects to provide a port for

00:12:40,980 --> 00:12:45,930
you that your application should be

00:12:42,540 --> 00:12:48,240
listening on and so that brings us on to

00:12:45,930 --> 00:12:50,400
the next factor which is config and the

00:12:48,240 --> 00:12:52,140
config factor states that you must

00:12:50,400 --> 00:12:54,410
insert or ensure strict separation

00:12:52,140 --> 00:12:58,440
between your code and your configuration

00:12:54,410 --> 00:13:00,570
and on top of that you must store the

00:12:58,440 --> 00:13:02,280
configuration usually in environment

00:13:00,570 --> 00:13:03,900
variables and the reason we want to do

00:13:02,280 --> 00:13:06,240
this is because it allows you to deploy

00:13:03,900 --> 00:13:09,570
your application and in many different

00:13:06,240 --> 00:13:12,420
places and make changes to the behavior

00:13:09,570 --> 00:13:14,830
without needed to make code changes

00:13:12,420 --> 00:13:16,840
so in this is since we need to remove

00:13:14,830 --> 00:13:19,360
the hard-coded port which is part of the

00:13:16,840 --> 00:13:22,270
configuration so that we can pass the

00:13:19,360 --> 00:13:24,490
health check so all we need to do is

00:13:22,270 --> 00:13:26,290
remove that line that had the use URLs

00:13:24,490 --> 00:13:27,940
and then as we're building up the

00:13:26,290 --> 00:13:30,220
configuration we can just add this line

00:13:27,940 --> 00:13:35,710
here which is the add environment

00:13:30,220 --> 00:13:37,470
variables line once we've done that we

00:13:35,710 --> 00:13:40,300
can try and push again

00:13:37,470 --> 00:13:44,110
so hopefully this this time we'll get a

00:13:40,300 --> 00:13:48,090
little bit further as we can see we're

00:13:44,110 --> 00:13:48,090
going through the staging process again

00:13:51,510 --> 00:13:59,920
looking good so far and there we go we

00:13:56,950 --> 00:14:01,090
now have actually a running instance so

00:13:59,920 --> 00:14:02,650
this is pretty cool right like we've

00:14:01,090 --> 00:14:04,920
covered like a few other factors and

00:14:02,650 --> 00:14:07,030
we've already managed to go through and

00:14:04,920 --> 00:14:10,060
get something that's working on Cloud

00:14:07,030 --> 00:14:11,830
Foundry so now that that's succeeded

00:14:10,060 --> 00:14:14,020
let's just give it a test run make sure

00:14:11,830 --> 00:14:16,450
that this is actually working as we

00:14:14,020 --> 00:14:19,120
intended and so all we're going to do

00:14:16,450 --> 00:14:21,510
here is upload a few example images make

00:14:19,120 --> 00:14:25,630
sure that the processing is working

00:14:21,510 --> 00:14:26,890
weezing pictures of giraffes here so we

00:14:25,630 --> 00:14:28,990
can see that they're eventually going

00:14:26,890 --> 00:14:31,120
from the the raw queue and they're

00:14:28,990 --> 00:14:36,000
getting processed and everything seems

00:14:31,120 --> 00:14:38,410
to be looking pretty good which is great

00:14:36,000 --> 00:14:41,830
so just to sort of like cover like we've

00:14:38,410 --> 00:14:43,570
covered like config dependencies code

00:14:41,830 --> 00:14:45,610
base and the build release run and

00:14:43,570 --> 00:14:47,230
that's been enough of the fact is to

00:14:45,610 --> 00:14:50,970
take our application and get it working

00:14:47,230 --> 00:14:53,920
on Cloud Foundry so what's next

00:14:50,970 --> 00:14:54,970
scaling this is the whole reason we

00:14:53,920 --> 00:14:57,550
wanted to do this in the first place

00:14:54,970 --> 00:14:58,980
right we are currently our apps going

00:14:57,550 --> 00:15:01,660
viral it's crushing under the pressure

00:14:58,980 --> 00:15:04,350
and we have been told that Cloud Foundry

00:15:01,660 --> 00:15:07,150
is amazing at scaling our applications

00:15:04,350 --> 00:15:09,640
and again like whenever you sort of read

00:15:07,150 --> 00:15:11,320
anything about this read any tutorials

00:15:09,640 --> 00:15:13,900
or whatever it says that's it all you

00:15:11,320 --> 00:15:16,570
need to do is just run the CF scale

00:15:13,900 --> 00:15:18,870
command so let's do that let's see how

00:15:16,570 --> 00:15:18,870
that goes

00:15:20,240 --> 00:15:26,930
so the actual command here is scale - I

00:15:23,120 --> 00:15:29,540
- which means take give me two instances

00:15:26,930 --> 00:15:34,070
rather than one so in theory twice as

00:15:29,540 --> 00:15:36,410
fast and that's been successful pretty

00:15:34,070 --> 00:15:38,029
easy pretty quick as well we can see

00:15:36,410 --> 00:15:40,850
that we now have two instances of the

00:15:38,029 --> 00:15:42,200
app so let's go and check let's make

00:15:40,850 --> 00:15:46,730
sure that this is still working as we

00:15:42,200 --> 00:15:49,610
expect and there's a problem we're now

00:15:46,730 --> 00:15:53,300
missing some images this is clearly not

00:15:49,610 --> 00:15:55,820
working as it should be so clearly we've

00:15:53,300 --> 00:15:59,720
done something wrong so over to you

00:15:55,820 --> 00:16:01,220
Jatin to help explain all right so

00:15:59,720 --> 00:16:03,770
what's going on over here

00:16:01,220 --> 00:16:06,170
so as we described before the

00:16:03,770 --> 00:16:09,200
application that we had the develop was

00:16:06,170 --> 00:16:11,209
extremely stateful so it used the local

00:16:09,200 --> 00:16:13,459
file system and a database which also

00:16:11,209 --> 00:16:17,360
lived on the local file system

00:16:13,459 --> 00:16:19,190
so essentially what you had is applique

00:16:17,360 --> 00:16:21,110
that the application was running before

00:16:19,190 --> 00:16:22,880
was there was a load balancer and there

00:16:21,110 --> 00:16:26,240
was a container which had the file

00:16:22,880 --> 00:16:28,700
system and the database both in it once

00:16:26,240 --> 00:16:30,820
we have scaled up we have two stateful

00:16:28,700 --> 00:16:34,310
applications and a load balancer which

00:16:30,820 --> 00:16:37,100
randomly directs requests to either of

00:16:34,310 --> 00:16:39,079
these applications so for making one web

00:16:37,100 --> 00:16:40,970
page there are multiple web requests

00:16:39,079 --> 00:16:43,490
that need to go through and those are

00:16:40,970 --> 00:16:45,709
going through randomly to any of these

00:16:43,490 --> 00:16:47,480
servers and one of them does not really

00:16:45,709 --> 00:16:50,180
know about the state that we injected it

00:16:47,480 --> 00:16:54,279
into it earlier so that's why we see

00:16:50,180 --> 00:16:56,390
this page which is incomplete which

00:16:54,279 --> 00:16:58,850
which really brings us to the next

00:16:56,390 --> 00:17:02,029
factor and this is probably one of the

00:16:58,850 --> 00:17:04,250
most important things about twelve

00:17:02,029 --> 00:17:07,990
factor applications is that they have to

00:17:04,250 --> 00:17:10,040
be stateless processes so the

00:17:07,990 --> 00:17:12,679
application should make no assumptions

00:17:10,040 --> 00:17:14,270
about resources or discs that will be

00:17:12,679 --> 00:17:16,819
present on the operating system where

00:17:14,270 --> 00:17:19,520
the process is running so this this

00:17:16,819 --> 00:17:21,920
alone has a lot of implications so which

00:17:19,520 --> 00:17:24,260
means that no sticky sessions no local

00:17:21,920 --> 00:17:25,579
databases no local storage if you

00:17:24,260 --> 00:17:28,429
compose an application this way it's

00:17:25,579 --> 00:17:31,130
very easy to scale out but like what do

00:17:28,429 --> 00:17:33,740
you do about the data like the app does

00:17:31,130 --> 00:17:36,169
need data to serve user requests

00:17:33,740 --> 00:17:40,000
so that that really brings us to the

00:17:36,169 --> 00:17:42,740
next factor which is backing services so

00:17:40,000 --> 00:17:45,850
this the idea of backing service is is

00:17:42,740 --> 00:17:49,429
very very much related to the idea of

00:17:45,850 --> 00:17:52,010
conflict so all all the reader services

00:17:49,429 --> 00:17:54,710
should be all of the data should be

00:17:52,010 --> 00:17:57,320
stared short in backing services which

00:17:54,710 --> 00:18:00,919
are injected through the as config this

00:17:57,320 --> 00:18:02,899
includes stuff like databases file

00:18:00,919 --> 00:18:04,760
systems not file systems but like

00:18:02,899 --> 00:18:07,460
external resources that you would use

00:18:04,760 --> 00:18:10,130
and all of these resources should be

00:18:07,460 --> 00:18:12,919
attachable to the application when

00:18:10,130 --> 00:18:15,140
during runtime the whole point of

00:18:12,919 --> 00:18:16,880
backing services is that you should be

00:18:15,140 --> 00:18:21,529
able to switch backing services without

00:18:16,880 --> 00:18:24,350
making any code changes so it this this

00:18:21,529 --> 00:18:26,240
mechanism really allows us this creates

00:18:24,350 --> 00:18:27,710
a mechanism for us to externalize all of

00:18:26,240 --> 00:18:32,590
our state to make our application

00:18:27,710 --> 00:18:34,850
stateless so so what are what are the

00:18:32,590 --> 00:18:37,789
scaling concerns in our application

00:18:34,850 --> 00:18:41,690
right now right so the first one is

00:18:37,789 --> 00:18:43,039
fairly obvious like a local database so

00:18:41,690 --> 00:18:44,870
we are using sequel Lite so it just

00:18:43,039 --> 00:18:46,179
connects to a file on local we should

00:18:44,870 --> 00:18:49,610
not do that

00:18:46,179 --> 00:18:51,470
we are using file system all over the

00:18:49,610 --> 00:18:53,809
place so then when you upload an image

00:18:51,470 --> 00:18:55,730
it just stored on the local machine so

00:18:53,809 --> 00:18:57,710
it just was filed or joined to reach

00:18:55,730 --> 00:18:59,210
those images we probably should not do

00:18:57,710 --> 00:19:02,649
that as well and we need to move that

00:18:59,210 --> 00:19:05,710
out the third one was is a bit

00:19:02,649 --> 00:19:08,600
non-obvious so ace we alternate

00:19:05,710 --> 00:19:12,559
implicitly uses the file storage as well

00:19:08,600 --> 00:19:14,659
for storing encryption keys so by

00:19:12,559 --> 00:19:17,870
default all forms are protected by a

00:19:14,659 --> 00:19:20,899
cross-site forgery protection protection

00:19:17,870 --> 00:19:23,899
so which means that each each form will

00:19:20,899 --> 00:19:25,820
be added a secret token will be added

00:19:23,899 --> 00:19:27,710
into each of those forms which should be

00:19:25,820 --> 00:19:31,220
validated when the requests comes back

00:19:27,710 --> 00:19:33,470
to a to execute a post request so if we

00:19:31,220 --> 00:19:35,270
don't move this these data protection

00:19:33,470 --> 00:19:38,360
keys to a place where both the

00:19:35,270 --> 00:19:40,190
containers can see that a request

00:19:38,360 --> 00:19:43,330
originating from a different container

00:19:40,190 --> 00:19:46,549
won't be possible by the other container

00:19:43,330 --> 00:19:47,000
so yeah so we'll have to switch to a

00:19:46,549 --> 00:19:52,250
deaf

00:19:47,000 --> 00:19:54,320
macadam for all of these use cases cool

00:19:52,250 --> 00:19:56,240
so we've identified that we basically

00:19:54,320 --> 00:19:58,850
need to extract away all of our state

00:19:56,240 --> 00:20:00,650
and fortunately this is this is a solved

00:19:58,850 --> 00:20:03,980
problem in Cloud Foundry and this is

00:20:00,650 --> 00:20:05,750
where CF services come into play so in

00:20:03,980 --> 00:20:09,500
order to update our application to make

00:20:05,750 --> 00:20:11,540
use of that we can first of all run the

00:20:09,500 --> 00:20:13,310
CF marketplace command this is going to

00:20:11,540 --> 00:20:16,700
list all of the services available and

00:20:13,310 --> 00:20:19,010
for us we're going to use my sequel next

00:20:16,700 --> 00:20:21,110
up we need to create an instance of that

00:20:19,010 --> 00:20:22,940
service so all this is going to do here

00:20:21,110 --> 00:20:25,160
is basically go and provision us a new

00:20:22,940 --> 00:20:28,100
database that we can use and then

00:20:25,160 --> 00:20:30,560
finally we need to bind that service to

00:20:28,100 --> 00:20:32,900
our application and all this really

00:20:30,560 --> 00:20:34,970
happening there is all of the connection

00:20:32,900 --> 00:20:37,580
information required to connect to that

00:20:34,970 --> 00:20:39,950
database is being injected into our

00:20:37,580 --> 00:20:45,020
application via a special environment

00:20:39,950 --> 00:20:46,670
variable called pcap services so that's

00:20:45,020 --> 00:20:47,960
this is great we've now sort of attached

00:20:46,670 --> 00:20:49,640
to that backing service to the

00:20:47,960 --> 00:20:53,090
application but obviously we need to

00:20:49,640 --> 00:20:54,410
update the app to to make use of that so

00:20:53,090 --> 00:20:56,240
first of all we need to make use of a

00:20:54,410 --> 00:20:58,700
couple new libraries we're going to

00:20:56,240 --> 00:21:01,070
specify them as explicit dependencies

00:20:58,700 --> 00:21:04,010
and for the purposes of this we're going

00:21:01,070 --> 00:21:05,090
to use the steel-toe connector along

00:21:04,010 --> 00:21:09,050
with the pomelo

00:21:05,090 --> 00:21:10,820
and my sequel adapter so just as an

00:21:09,050 --> 00:21:12,500
aside like the still steel-toed library

00:21:10,820 --> 00:21:14,480
or steel-toe project is really

00:21:12,500 --> 00:21:16,400
interesting especially about you're

00:21:14,480 --> 00:21:18,260
developing like Microsoft Microsoft

00:21:16,400 --> 00:21:19,250
style applications and certainly

00:21:18,260 --> 00:21:22,520
recommend you check it out

00:21:19,250 --> 00:21:24,800
but right now we are just using the T

00:21:22,520 --> 00:21:26,660
connector which basically allows us to

00:21:24,800 --> 00:21:28,880
pause that connection information from

00:21:26,660 --> 00:21:31,400
the the pcap services environment

00:21:28,880 --> 00:21:33,680
variable and then we're using the my

00:21:31,400 --> 00:21:37,850
sequel adapter so that we can use on my

00:21:33,680 --> 00:21:40,280
sequel rather than a sequel Lite so in

00:21:37,850 --> 00:21:41,360
terms of code all we need to do here is

00:21:40,280 --> 00:21:43,780
as we're building up the configuration

00:21:41,360 --> 00:21:45,710
we can just add in this ad Cloud Foundry

00:21:43,780 --> 00:21:47,600
which is going to go and grab that

00:21:45,710 --> 00:21:49,880
connection information and then we just

00:21:47,600 --> 00:21:53,300
need to pass it through to the my sequel

00:21:49,880 --> 00:21:54,560
to use my sequel function so that kind

00:21:53,300 --> 00:21:56,750
of solves one of the problems that

00:21:54,560 --> 00:21:58,220
solves the database problem but there's

00:21:56,750 --> 00:22:00,710
still the problem that we are using the

00:21:58,220 --> 00:22:02,600
local file system both to store

00:22:00,710 --> 00:22:06,590
the images as well as Jason mentioned

00:22:02,600 --> 00:22:08,480
those data protection keys so in this

00:22:06,590 --> 00:22:10,490
case all we've done it just created a

00:22:08,480 --> 00:22:12,200
little adapter class that basically

00:22:10,490 --> 00:22:15,320
provides us a connection into the azure

00:22:12,200 --> 00:22:17,779
blob store it's perfectly possible the

00:22:15,320 --> 00:22:19,190
this could have been built as a cloud

00:22:17,779 --> 00:22:21,470
foundry service that we could have just

00:22:19,190 --> 00:22:23,600
attached to the m2 the application as

00:22:21,470 --> 00:22:25,760
well unfortunately we couldn't find one

00:22:23,600 --> 00:22:29,419
and so this is why we've kind of done it

00:22:25,760 --> 00:22:32,029
ourselves and then all we need to do to

00:22:29,419 --> 00:22:34,490
make use of that is just cool this Azure

00:22:32,029 --> 00:22:35,630
blob and then rather than storing that

00:22:34,490 --> 00:22:43,190
information on the local file system

00:22:35,630 --> 00:22:46,429
it's now in a remote blob store so after

00:22:43,190 --> 00:22:47,929
we've done all that has it worked and it

00:22:46,429 --> 00:22:50,419
appears that yes it has so we're

00:22:47,929 --> 00:22:52,130
refreshing the page and the application

00:22:50,419 --> 00:22:54,440
sorry the pictures were staying there

00:22:52,130 --> 00:22:55,580
but there's actually one more problem or

00:22:54,440 --> 00:22:57,890
one more thing we need to think about

00:22:55,580 --> 00:23:00,470
and that's what happens when we scale

00:22:57,890 --> 00:23:02,899
down so as we just seen here we've

00:23:00,470 --> 00:23:05,029
uploaded another image and before it had

00:23:02,899 --> 00:23:06,860
a chance to process we scaled our

00:23:05,029 --> 00:23:09,890
application instances back down to one

00:23:06,860 --> 00:23:12,880
and now what's happening is the image is

00:23:09,890 --> 00:23:17,870
stuck it's not ever being processed

00:23:12,880 --> 00:23:21,380
so Justin what is happening there all

00:23:17,870 --> 00:23:24,830
right well the way the application is

00:23:21,380 --> 00:23:27,260
written today to do the background

00:23:24,830 --> 00:23:29,870
processing it just spawns up a thread in

00:23:27,260 --> 00:23:33,320
the SP context and it just processed

00:23:29,870 --> 00:23:35,299
inside the web server and when we scaled

00:23:33,320 --> 00:23:38,750
down the web server essentially goes

00:23:35,299 --> 00:23:40,909
away so one if if the web server that

00:23:38,750 --> 00:23:43,820
goes away happens to be processing the

00:23:40,909 --> 00:23:45,620
request that request will never be

00:23:43,820 --> 00:23:48,890
processed and this background this image

00:23:45,620 --> 00:23:50,740
will forever be in the raw stage which

00:23:48,890 --> 00:23:55,460
brings us to the next factor which is

00:23:50,740 --> 00:23:58,190
disposability so applications in

00:23:55,460 --> 00:24:00,590
clarifier applications should be

00:23:58,190 --> 00:24:03,039
designed in a way that they can be

00:24:00,590 --> 00:24:06,289
stopped and start at any point of time

00:24:03,039 --> 00:24:08,090
so if if we do that like we it gives us

00:24:06,289 --> 00:24:10,399
a lot of benefits around how we can

00:24:08,090 --> 00:24:11,899
update them and how frequently how

00:24:10,399 --> 00:24:14,809
frequently you can update them and like

00:24:11,899 --> 00:24:17,280
we we are not constrained by any

00:24:14,809 --> 00:24:19,200
application-specific state or we are not

00:24:17,280 --> 00:24:20,940
constrained by what the application is

00:24:19,200 --> 00:24:25,140
doing when we are updating the

00:24:20,940 --> 00:24:27,090
application one one factor which is

00:24:25,140 --> 00:24:31,049
closely related to this is concurrency

00:24:27,090 --> 00:24:34,200
so we are also treating that the 12

00:24:31,049 --> 00:24:36,870
factor the the concurrency aspect of the

00:24:34,200 --> 00:24:39,450
devil factor framework talks about

00:24:36,870 --> 00:24:42,660
treating all of the background all of

00:24:39,450 --> 00:24:46,530
the processes as first-class entities so

00:24:42,660 --> 00:24:48,840
currently our of our background

00:24:46,530 --> 00:24:55,169
processes essentially lives with the web

00:24:48,840 --> 00:24:57,780
server and this this really this allows

00:24:55,169 --> 00:25:00,660
us not to be horizontally scalable very

00:24:57,780 --> 00:25:04,770
efficiently so we want to get to a world

00:25:00,660 --> 00:25:07,740
in which we could we could scale our web

00:25:04,770 --> 00:25:09,990
service web web workers which serve

00:25:07,740 --> 00:25:13,590
websites independently of the servers

00:25:09,990 --> 00:25:15,299
which process images for example like in

00:25:13,590 --> 00:25:17,130
our application it's takes much longer

00:25:15,299 --> 00:25:19,049
to process an image than it takes to

00:25:17,130 --> 00:25:22,559
serve the web requests so we would like

00:25:19,049 --> 00:25:24,929
to make those two things independent so

00:25:22,559 --> 00:25:27,360
the way that we can do that is the the

00:25:24,929 --> 00:25:28,500
current offending line in our code is we

00:25:27,360 --> 00:25:31,020
just have a toss dot run which will

00:25:28,500 --> 00:25:33,270
start a thread what we would like to do

00:25:31,020 --> 00:25:36,270
is switch to any background processing

00:25:33,270 --> 00:25:37,919
library so there are a lot available for

00:25:36,270 --> 00:25:40,410
dotnet so there are squirts flow and

00:25:37,919 --> 00:25:43,040
sherry Euler we are using a library

00:25:40,410 --> 00:25:45,299
called time fire so hangfire gives us

00:25:43,040 --> 00:25:48,179
hang fire actually uses a backing store

00:25:45,299 --> 00:25:49,650
so once you say background job dot n

00:25:48,179 --> 00:25:52,380
queue it would sum add something in the

00:25:49,650 --> 00:25:54,900
hang fire database and hang fire library

00:25:52,380 --> 00:25:57,750
gives us like at at least one run

00:25:54,900 --> 00:26:01,049
guarantees so it would run this that

00:25:57,750 --> 00:26:05,610
task it at least once at some point of

00:26:01,049 --> 00:26:07,380
time and which which also allows us the

00:26:05,610 --> 00:26:09,990
disposability aspect which means that

00:26:07,380 --> 00:26:12,870
this process can be killed at any point

00:26:09,990 --> 00:26:14,549
of time and Hank when the server comes

00:26:12,870 --> 00:26:17,580
back up hang fire will ensure that that

00:26:14,549 --> 00:26:19,830
task is run the other thing that we want

00:26:17,580 --> 00:26:22,230
to do is we also want to move the

00:26:19,830 --> 00:26:25,200
processing to another thread so what we

00:26:22,230 --> 00:26:28,440
have done over here is created a new

00:26:25,200 --> 00:26:31,410
console application which is only for

00:26:28,440 --> 00:26:33,000
doing the processing of images so the

00:26:31,410 --> 00:26:34,980
the library again helps us a lot with

00:26:33,000 --> 00:26:37,830
this so all we need to do is connect to

00:26:34,980 --> 00:26:39,870
the same backing reader store and ask it

00:26:37,830 --> 00:26:45,180
to process the jobs that we put in there

00:26:39,870 --> 00:26:47,610
through our web server cool

00:26:45,180 --> 00:26:48,990
so I think just to sort of explicitly

00:26:47,610 --> 00:26:51,570
show that what we're gonna see here is

00:26:48,990 --> 00:26:53,490
if we run apps we now have two separate

00:26:51,570 --> 00:26:55,770
apps the slow Graham and the slow Graham

00:26:53,490 --> 00:26:59,100
worker and this means that we can scale

00:26:55,770 --> 00:27:03,390
both of those independently and this is

00:26:59,100 --> 00:27:04,830
really nice cool so we can see that wait

00:27:03,390 --> 00:27:08,660
yeah we're scaling the web server up to

00:27:04,830 --> 00:27:08,660
two and the background worker up to four

00:27:10,670 --> 00:27:15,630
cool so I think let's just take a quick

00:27:13,890 --> 00:27:18,270
step back and look at everything that

00:27:15,630 --> 00:27:21,570
we've covered so far there's a few there

00:27:18,270 --> 00:27:24,000
that we haven't mentioned these are

00:27:21,570 --> 00:27:25,920
perhaps not as important for getting

00:27:24,000 --> 00:27:30,930
your application at least up and running

00:27:25,920 --> 00:27:33,330
on Cloud Foundry to big it with and I

00:27:30,930 --> 00:27:34,740
think actually that it's all that we all

00:27:33,330 --> 00:27:37,950
that we have time for or all that we

00:27:34,740 --> 00:27:40,890
have covered so hopefully that's been of

00:27:37,950 --> 00:27:43,920
some help to you hopefully the examples

00:27:40,890 --> 00:27:46,010
weren't too contrived and thank you for

00:27:43,920 --> 00:27:46,010
listening

00:27:49,310 --> 00:28:00,710
I think we probably got a bit of time

00:27:53,000 --> 00:28:10,370
for questions if anyone has any yes yep

00:28:00,710 --> 00:28:12,560
I will post the slides after this rock

00:28:10,370 --> 00:28:18,800
concert dine across her first slash what

00:28:12,560 --> 00:28:21,790
is this thing called a slow Graham cool

00:28:18,800 --> 00:28:21,790

YouTube URL: https://www.youtube.com/watch?v=3ziP2wIbNXo


