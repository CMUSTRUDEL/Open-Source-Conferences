Title: Enabling .NET Applications with Performance Monitoring and Management on Cloud Foundry
Publication date: 2018-04-21
Playlist: Cloud Foundry Summit NA 2018
Description: 
	Enabling .NET Applications with Performance Monitoring and Management on Cloud Foundry - Dave Tillman, Pivotal

 Applications with complex distributed architectures typically have dozens of dependencies which at times fail or become unresponsive. Detecting these problems in a timely fashion and then troubleshooting them in a distributed environment can pose a significant challenge.
This developer level talk we will explore how you can use the Steeltoe Management frameworks to enable your .NET application with performance monitoring, management diagnostic endpoints, and distributed tracing all of which seamlessly integrate with Cloud Foundry. We will use a polyglot based micro-services sample application (i.e. Java and .NET) together with Pivotal Apps Manager and Pivotal Cloud Foundry Metrics to illustrate how all these tools integrate and can be used in detecting and diagnosing a failing application.

About Dave Tillman
Dave Tillman is the lead engineer on the Steeltoe open source project. He has many years of experience as both a Java and a .NET developer and currently works for Pivotal.
Captions: 
	00:00:01,280 --> 00:00:06,390
this is the session on enabling

00:00:04,470 --> 00:00:10,260
application performance and monitoring

00:00:06,390 --> 00:00:11,010
within dotnet applications my name is

00:00:10,260 --> 00:00:14,849
Dave Tillman

00:00:11,010 --> 00:00:17,609
I'm with pivotal I've been working on

00:00:14,849 --> 00:00:20,550
the steel-toe project for well since its

00:00:17,609 --> 00:00:25,519
inception from from from day one

00:00:20,550 --> 00:00:28,439
in fact my favorite colleague last night

00:00:25,519 --> 00:00:30,900
Tim here who also works on the steel-toe

00:00:28,439 --> 00:00:34,680
project decided to give me a nickname

00:00:30,900 --> 00:00:39,360
which was called Papa steel-toe don't

00:00:34,680 --> 00:00:40,800
know why but anyway I prefer Papa toe so

00:00:39,360 --> 00:00:43,440
we'll take the short version of that

00:00:40,800 --> 00:00:47,010
from now on but anyway I've been working

00:00:43,440 --> 00:00:48,239
on steel toe for quite a while and so

00:00:47,010 --> 00:00:51,270
I've got some good things to talk about

00:00:48,239 --> 00:00:53,610
today before I get there let's do this

00:00:51,270 --> 00:00:55,440
slide you've all seen this at least a

00:00:53,610 --> 00:00:56,820
dozen times today so I'm not going to

00:00:55,440 --> 00:00:59,579
read it to you I think you already know

00:00:56,820 --> 00:01:02,940
what it says and so I'll move right on

00:00:59,579 --> 00:01:05,400
to to the session itself so here's the

00:01:02,940 --> 00:01:07,229
outline today we're gonna start out and

00:01:05,400 --> 00:01:09,060
talk about some cloud native frameworks

00:01:07,229 --> 00:01:12,720
that you probably already are aware of

00:01:09,060 --> 00:01:14,850
today least in the Java and.net space

00:01:12,720 --> 00:01:18,390
we're gonna talk about spring cloud and

00:01:14,850 --> 00:01:20,340
and steel-toe two frameworks that we'll

00:01:18,390 --> 00:01:21,990
go into a little bit of depth on but

00:01:20,340 --> 00:01:24,860
what we're really gonna focus on in this

00:01:21,990 --> 00:01:27,990
session is of those frameworks

00:01:24,860 --> 00:01:30,210
monitoring and management the tools the

00:01:27,990 --> 00:01:32,220
technology that you can employ you can

00:01:30,210 --> 00:01:33,960
include in your Java apps or in your

00:01:32,220 --> 00:01:37,350
dotnet apps of course I'm going to focus

00:01:33,960 --> 00:01:39,150
primarily on dotnet in this session to

00:01:37,350 --> 00:01:41,610
enable monitoring and management of your

00:01:39,150 --> 00:01:43,890
app in a production environment runtime

00:01:41,610 --> 00:01:47,250
type environment and then throughout the

00:01:43,890 --> 00:01:49,740
session I'll be using a demo app to try

00:01:47,250 --> 00:01:51,899
to go illustrate all those features that

00:01:49,740 --> 00:01:54,119
that you can make use of I'll also bring

00:01:51,899 --> 00:01:56,130
up some code show you how within net and

00:01:54,119 --> 00:01:57,840
steel-toe using the steel-toe framework

00:01:56,130 --> 00:02:04,950
sure you enable this this stuff within

00:01:57,840 --> 00:02:08,039
your app okay so first of all in the

00:02:04,950 --> 00:02:10,080
Java world we've all probably heard of

00:02:08,039 --> 00:02:11,879
spring we've all heard of spring boot

00:02:10,080 --> 00:02:13,330
these days or at least many of you

00:02:11,879 --> 00:02:15,190
probably have

00:02:13,330 --> 00:02:17,530
and then of course spring cloud which is

00:02:15,190 --> 00:02:19,870
built on top of those things so you got

00:02:17,530 --> 00:02:22,660
spring cloud which is a cloud basically

00:02:19,870 --> 00:02:25,690
a Java framework that you can use to

00:02:22,660 --> 00:02:29,470
basically a cloud enable or make your

00:02:25,690 --> 00:02:33,070
applications cloud native in in your

00:02:29,470 --> 00:02:35,470
environment spring cloud is based off of

00:02:33,070 --> 00:02:37,780
or built on spring boot which has been

00:02:35,470 --> 00:02:39,880
become very very popular which in turn

00:02:37,780 --> 00:02:41,890
is built on the spring framework itself

00:02:39,880 --> 00:02:44,560
that's been around for many many years

00:02:41,890 --> 00:02:47,770
for building web apps in in other apps

00:02:44,560 --> 00:02:50,350
within the Java ecosystem then layered

00:02:47,770 --> 00:02:53,140
on top of that pivotal has taken spring

00:02:50,350 --> 00:02:55,840
cloud packaged up components of it and

00:02:53,140 --> 00:02:57,670
offered up something called spring cloud

00:02:55,840 --> 00:03:01,570
services which is an offering that will

00:02:57,670 --> 00:03:03,280
run on pivotal Cloud Foundry it's

00:03:01,570 --> 00:03:05,950
packaged it up as a tile as a Bosch

00:03:03,280 --> 00:03:10,180
deployable unit as part of that you get

00:03:05,950 --> 00:03:12,520
several pieces of technology things like

00:03:10,180 --> 00:03:15,520
a service registry centralized

00:03:12,520 --> 00:03:19,630
configuration you get histor --ax which

00:03:15,520 --> 00:03:21,400
is something created by netflix you get

00:03:19,630 --> 00:03:24,580
a bunch of components that are quite

00:03:21,400 --> 00:03:27,520
useful in building micro services in in

00:03:24,580 --> 00:03:29,770
the java java language and this has been

00:03:27,520 --> 00:03:34,630
around for actually for quite some time

00:03:29,770 --> 00:03:37,570
several actually several years then on

00:03:34,630 --> 00:03:39,370
the dotnet side what we did is we

00:03:37,570 --> 00:03:41,680
started a project pivotal sponsor to

00:03:39,370 --> 00:03:44,530
project I think it's been about two

00:03:41,680 --> 00:03:45,700
years now I think probably right Jason

00:03:44,530 --> 00:03:46,510
when you say we've been doing this for

00:03:45,700 --> 00:03:48,340
about two years

00:03:46,510 --> 00:03:51,640
so the steel-toe project started about

00:03:48,340 --> 00:03:54,340
roughly two years ago and the idea was

00:03:51,640 --> 00:03:56,650
is to enable dotnet applications to be

00:03:54,340 --> 00:03:59,709
able to use those services that I just

00:03:56,650 --> 00:04:01,480
described running on Cloud Foundry and

00:03:59,709 --> 00:04:03,790
and making basically dotnet a

00:04:01,480 --> 00:04:06,240
first-class citizen for app and micro

00:04:03,790 --> 00:04:08,770
services development on on Cloud Foundry

00:04:06,240 --> 00:04:10,150
this is a project if you've not heard of

00:04:08,770 --> 00:04:12,150
it it's a it's an open source project

00:04:10,150 --> 00:04:15,700
like I said it's about two years old

00:04:12,150 --> 00:04:18,280
there's the link to the code up on in

00:04:15,700 --> 00:04:20,049
github there's some documentation that

00:04:18,280 --> 00:04:21,880
goes along with it there that if you're

00:04:20,049 --> 00:04:24,460
interested in digging in more depth on

00:04:21,880 --> 00:04:26,620
it and there's a slack channel where you

00:04:24,460 --> 00:04:29,139
can find myself Tim and other

00:04:26,620 --> 00:04:30,940
that work on the project so if you need

00:04:29,139 --> 00:04:33,840
help you just come to that slack channel

00:04:30,940 --> 00:04:36,699
we're always there ready ready to help

00:04:33,840 --> 00:04:39,780
the Steel Toe framework works both on

00:04:36,699 --> 00:04:43,360
dotnet core in other words the core CLR

00:04:39,780 --> 00:04:46,180
dotnet core framework on a cross

00:04:43,360 --> 00:04:48,790
platform across operating systems it

00:04:46,180 --> 00:04:52,180
also supports the full framework the

00:04:48,790 --> 00:04:55,229
dotnet full framework you you've been

00:04:52,180 --> 00:04:58,270
using for probably many many years okay

00:04:55,229 --> 00:05:02,440
it also works with asp.net core and

00:04:58,270 --> 00:05:05,110
asp.net 4x so if you've got your moving

00:05:02,440 --> 00:05:07,240
on to asp.net core steel-toe will work

00:05:05,110 --> 00:05:09,580
seamlessly in there and we've also done

00:05:07,240 --> 00:05:12,639
some work here in the 2.0 release to try

00:05:09,580 --> 00:05:14,889
to make better support of asp.net 4x the

00:05:12,639 --> 00:05:18,430
I like like to refer to as the legacy

00:05:14,889 --> 00:05:20,500
web app technology on the right side of

00:05:18,430 --> 00:05:23,050
the screen or I guess yeah on the right

00:05:20,500 --> 00:05:25,930
side of the screen you'll see the the

00:05:23,050 --> 00:05:28,479
areas that Steel Toe covers there's

00:05:25,930 --> 00:05:31,900
really kind of two areas that it focuses

00:05:28,479 --> 00:05:33,370
on one is simplifying building apps and

00:05:31,900 --> 00:05:35,830
running them and deploying them and

00:05:33,370 --> 00:05:38,229
managing them on Cloud Foundry and then

00:05:35,830 --> 00:05:40,720
the other is tying into those spring

00:05:38,229 --> 00:05:42,760
cloud services that operate on on Cloud

00:05:40,720 --> 00:05:44,700
Foundry those are actually Java based

00:05:42,760 --> 00:05:47,530
you know they're built in Java

00:05:44,700 --> 00:05:49,750
technology but they all offer up rest

00:05:47,530 --> 00:05:52,450
services so it's Netflix service

00:05:49,750 --> 00:05:55,750
discovery history and all of that are

00:05:52,450 --> 00:06:00,010
easily accessible from application using

00:05:55,750 --> 00:06:02,229
steel-toe so what I want to do is I want

00:06:00,010 --> 00:06:04,300
to we literally could spend hours and

00:06:02,229 --> 00:06:06,310
hours and hours on all of the components

00:06:04,300 --> 00:06:07,900
that make up steel-toe so what I want to

00:06:06,310 --> 00:06:09,520
do in this session is I want to focus on

00:06:07,900 --> 00:06:13,990
the management and monitoring what I

00:06:09,520 --> 00:06:15,880
refer to as the MMS of steel-toe and so

00:06:13,990 --> 00:06:18,699
if you leave today with nothing else

00:06:15,880 --> 00:06:22,300
remember this to be the MM presentation

00:06:18,699 --> 00:06:23,650
given by the steel-toe team and you

00:06:22,300 --> 00:06:26,320
you're going to learn about monitoring

00:06:23,650 --> 00:06:28,270
and management as it relates to dotnet

00:06:26,320 --> 00:06:31,180
applications and I'm actually going to

00:06:28,270 --> 00:06:32,889
cover both areas both Java and.net so

00:06:31,180 --> 00:06:35,289
that you can relate if you if you're a

00:06:32,889 --> 00:06:37,150
mix shop and you've got dot both Java

00:06:35,289 --> 00:06:39,700
and.net here are some of the spring

00:06:37,150 --> 00:06:41,890
spring components that make

00:06:39,700 --> 00:06:43,690
I'm sorry the Java components that make

00:06:41,890 --> 00:06:46,090
up the safe the equivalent functionality

00:06:43,690 --> 00:06:47,590
in Java and then I've also listed the

00:06:46,090 --> 00:06:49,930
steel-toe components and you can break

00:06:47,590 --> 00:06:52,930
up monitoring and management into four

00:06:49,930 --> 00:06:54,610
major areas okay we've got at the very

00:06:52,930 --> 00:06:57,820
top we've got what we refer to as a

00:06:54,610 --> 00:06:59,140
management endpoints these are endpoints

00:06:57,820 --> 00:07:01,630
that I'll go into here in a minute that

00:06:59,140 --> 00:07:03,610
that allow you to gather or collect

00:07:01,630 --> 00:07:06,130
information out of your app at runtime

00:07:03,610 --> 00:07:07,660
and they basically arrest endpoints that

00:07:06,130 --> 00:07:11,040
you can hit and I'll describe them here

00:07:07,660 --> 00:07:14,020
in a second then in addition if you are

00:07:11,040 --> 00:07:17,080
interested in using history as a fault

00:07:14,020 --> 00:07:19,150
management a fault tolerant latency kind

00:07:17,080 --> 00:07:22,140
of framework for building your

00:07:19,150 --> 00:07:24,640
dependencies on remote remote instances

00:07:22,140 --> 00:07:26,440
you can use history and within the

00:07:24,640 --> 00:07:29,170
history extreme work there's a lot of

00:07:26,440 --> 00:07:31,200
status and monitoring and statistics

00:07:29,170 --> 00:07:33,430
that flow out of that history

00:07:31,200 --> 00:07:35,320
environment that you can make use of and

00:07:33,430 --> 00:07:38,080
we've got an implementation in dotnet

00:07:35,320 --> 00:07:39,910
now that we did as part of steel-toe

00:07:38,080 --> 00:07:41,590
that's completely compatible with the

00:07:39,910 --> 00:07:44,530
java version so you can gather hit

00:07:41,590 --> 00:07:46,420
metrics and and performance data out of

00:07:44,530 --> 00:07:48,820
both your java app and your history have

00:07:46,420 --> 00:07:51,430
them flow into one common dashboard and

00:07:48,820 --> 00:07:53,260
see the status of your circuits that

00:07:51,430 --> 00:07:54,970
you've got going and then two new things

00:07:53,260 --> 00:07:56,590
that we're kind of announcing I guess at

00:07:54,970 --> 00:07:58,840
this show that we've just recently added

00:07:56,590 --> 00:08:01,000
is we're adding distributed tracing

00:07:58,840 --> 00:08:05,170
functionality and we're adding metrics

00:08:01,000 --> 00:08:07,690
into into the dotnet world those things

00:08:05,170 --> 00:08:09,100
already existed in the Java world you

00:08:07,690 --> 00:08:11,700
had something called spring sleuth

00:08:09,100 --> 00:08:14,170
sleuth that was used for doing

00:08:11,700 --> 00:08:16,090
distributed tracing what we're

00:08:14,170 --> 00:08:18,520
announcing here is that we've done a

00:08:16,090 --> 00:08:21,190
steel-toe open census implementation

00:08:18,520 --> 00:08:25,330
open census is a project that has been

00:08:21,190 --> 00:08:27,820
championed by Google and is basically

00:08:25,330 --> 00:08:29,020
centers around implementing distributed

00:08:27,820 --> 00:08:31,030
tracing and we've done a dotnet

00:08:29,020 --> 00:08:35,050
implementation of that basically a port

00:08:31,030 --> 00:08:37,510
of the Java open census code over into

00:08:35,050 --> 00:08:39,160
dotnet a lot obviously with some some

00:08:37,510 --> 00:08:41,500
changes that made more sense for dotnet

00:08:39,160 --> 00:08:43,390
and then on top of that we ported of

00:08:41,500 --> 00:08:45,370
course all of the unit tests so there's

00:08:43,390 --> 00:08:47,860
some 450 unit tests that we had to port

00:08:45,370 --> 00:08:50,560
over as well to make all that work in

00:08:47,860 --> 00:08:52,640
addition then we've also added support

00:08:50,560 --> 00:08:54,470
for open census in steel-toe for

00:08:52,640 --> 00:08:56,120
Metrix gathering so what that's one of

00:08:54,470 --> 00:08:58,250
the really beautiful things about open

00:08:56,120 --> 00:09:00,220
census is it's not only all about

00:08:58,250 --> 00:09:03,050
distributed tracing but it also has

00:09:00,220 --> 00:09:05,630
stats gathering or metrics gathering and

00:09:03,050 --> 00:09:07,640
so we've gone ahead and ported that code

00:09:05,630 --> 00:09:10,280
over as well and then we're building on

00:09:07,640 --> 00:09:14,210
top of that as I'll show you here in in

00:09:10,280 --> 00:09:16,790
a little bit all right so let's focus

00:09:14,210 --> 00:09:21,290
first on the management endpoints these

00:09:16,790 --> 00:09:24,560
are essentially endpoints that give you

00:09:21,290 --> 00:09:26,300
access to information that just by

00:09:24,560 --> 00:09:28,100
incorporating this deal to a framework

00:09:26,300 --> 00:09:32,330
into your application you're able to

00:09:28,100 --> 00:09:34,070
provide these types of things inside of

00:09:32,330 --> 00:09:36,350
your application the endpoints

00:09:34,070 --> 00:09:39,500
themselves are not really tied to HTTP

00:09:36,350 --> 00:09:41,240
rest calls but if you want to but out of

00:09:39,500 --> 00:09:43,550
the box if you just drop it in the way

00:09:41,240 --> 00:09:46,070
you typically would it'll expose these

00:09:43,550 --> 00:09:47,690
endpoints this functionality as rest

00:09:46,070 --> 00:09:49,490
endpoints that can be called by any

00:09:47,690 --> 00:09:51,950
application today I'm going to show you

00:09:49,490 --> 00:09:54,350
the pivotal apps manager which will

00:09:51,950 --> 00:09:56,630
actually call those rest endpoints and

00:09:54,350 --> 00:09:58,760
surface the information within within an

00:09:56,630 --> 00:10:00,740
ICU I within pivotal apps manager and

00:09:58,760 --> 00:10:02,870
there's the list of the endpoints that

00:10:00,740 --> 00:10:07,880
you can you can make use of we just

00:10:02,870 --> 00:10:10,430
recently added two to the list for

00:10:07,880 --> 00:10:13,040
dotnet applications dump and heap dump

00:10:10,430 --> 00:10:15,770
dump allows you to capture a thread dump

00:10:13,040 --> 00:10:17,450
of the application at runtime and the

00:10:15,770 --> 00:10:19,280
heap dump actually allows you to capture

00:10:17,450 --> 00:10:21,170
a mini dump so if you're diagnosing a

00:10:19,280 --> 00:10:22,670
problem let's say you've got a maybe you

00:10:21,170 --> 00:10:24,500
have a memory leak or something in one

00:10:22,670 --> 00:10:26,150
of the instances you'd like to grab a

00:10:24,500 --> 00:10:30,410
memory dump or a heap dump so that you

00:10:26,150 --> 00:10:32,720
could do some off-site off-off analysis

00:10:30,410 --> 00:10:34,910
of it you're able to do that now online

00:10:32,720 --> 00:10:37,400
you know right right within right within

00:10:34,910 --> 00:10:39,170
the tool and all of these endpoints like

00:10:37,400 --> 00:10:42,200
I said they're offered up by both Java

00:10:39,170 --> 00:10:44,690
and they're offered up by both net so

00:10:42,200 --> 00:10:46,520
anything that is able to call those rest

00:10:44,690 --> 00:10:49,300
endpoints and display the information

00:10:46,520 --> 00:10:52,070
coming out of it can be used to access

00:10:49,300 --> 00:10:54,290
the the information out of it so I'm

00:10:52,070 --> 00:10:56,060
going to show how you can do this with

00:10:54,290 --> 00:10:57,440
the pivotal apps manager here in a

00:10:56,060 --> 00:10:59,690
minute but of course like I said it's

00:10:57,440 --> 00:11:01,940
just rest endpoints so here's the demo

00:10:59,690 --> 00:11:05,090
app that I'm going to use it's a real

00:11:01,940 --> 00:11:06,560
simple app we've got a shopping cart

00:11:05,090 --> 00:11:08,660
micro service on the

00:11:06,560 --> 00:11:10,730
frontend you hit it with the check at

00:11:08,660 --> 00:11:13,850
the checkout endpoint it calls the

00:11:10,730 --> 00:11:15,620
process order micro service which in

00:11:13,850 --> 00:11:18,380
turn calls the pay process and then the

00:11:15,620 --> 00:11:20,360
results all flow back back through very

00:11:18,380 --> 00:11:22,640
very simple and I've enabled it with

00:11:20,360 --> 00:11:26,690
both the Java and the steel-toe

00:11:22,640 --> 00:11:28,760
components to provide these rest

00:11:26,690 --> 00:11:30,830
endpoints within within the application

00:11:28,760 --> 00:11:32,839
and I'm gonna use the apps manager down

00:11:30,830 --> 00:11:34,430
there at the bottom to actually surface

00:11:32,839 --> 00:11:43,670
the information that comes out of out of

00:11:34,430 --> 00:11:47,870
out of those apps so if the demo gods

00:11:43,670 --> 00:11:50,690
are good to us today we will have so

00:11:47,870 --> 00:11:52,390
here's the here's the sample very simple

00:11:50,690 --> 00:11:56,240
I'm just going to hit the shopping cart

00:11:52,390 --> 00:11:57,980
process hit the checkout hit that a few

00:11:56,240 --> 00:12:00,320
times and basically just returns some

00:11:57,980 --> 00:12:01,970
JSON that says the orders been processed

00:12:00,320 --> 00:12:04,670
and the cards successfully been charged

00:12:01,970 --> 00:12:06,980
so so we'll get a get a couple things

00:12:04,670 --> 00:12:11,990
going there now we go back to the apps

00:12:06,980 --> 00:12:14,650
manager we see we see the 3 micro

00:12:11,990 --> 00:12:16,820
services that I talked about the

00:12:14,650 --> 00:12:20,930
payments and shopping cart are Java

00:12:16,820 --> 00:12:23,000
applications the order processor is the

00:12:20,930 --> 00:12:25,310
dotnet application ignore the Zipkin

00:12:23,000 --> 00:12:26,510
server I'll get to that in a in a bit

00:12:25,310 --> 00:12:29,030
here in a second when I start talking

00:12:26,510 --> 00:12:31,150
about distributed tracing so if we bring

00:12:29,030 --> 00:12:33,640
up for example the shopping cart service

00:12:31,150 --> 00:12:35,960
the first thing that happens is within

00:12:33,640 --> 00:12:38,930
within this particular product the

00:12:35,960 --> 00:12:40,580
pivotal apps manager is you see a logo

00:12:38,930 --> 00:12:42,290
up here in the in the top left corner

00:12:40,580 --> 00:12:44,150
which is the spring boot logo for those

00:12:42,290 --> 00:12:45,950
of you know a little bit about Java and

00:12:44,150 --> 00:12:50,020
that signifies that this app has been

00:12:45,950 --> 00:12:52,310
been augmented with the actuator

00:12:50,020 --> 00:12:54,230
management endpoints right the rest

00:12:52,310 --> 00:12:57,459
endpoints are have been enabled and what

00:12:54,230 --> 00:13:00,290
happens is there's some there are some

00:12:57,459 --> 00:13:02,930
additional menu items that are added to

00:13:00,290 --> 00:13:05,750
the application so for example we see

00:13:02,930 --> 00:13:07,970
this trace we see threads which is which

00:13:05,750 --> 00:13:09,170
we can use to do thread dumps if we go

00:13:07,970 --> 00:13:12,980
down here and look at one of the

00:13:09,170 --> 00:13:15,140
instances that's running we'll see that

00:13:12,980 --> 00:13:17,870
we can take a heap dump of this

00:13:15,140 --> 00:13:20,370
particular Java app etc etc so these are

00:13:17,870 --> 00:13:22,529
these are things that the apps manager

00:13:20,370 --> 00:13:24,450
has queried the application hit the

00:13:22,529 --> 00:13:26,700
endpoints determined what's actually

00:13:24,450 --> 00:13:29,040
implemented and available and now

00:13:26,700 --> 00:13:30,750
surfaces that within within this so for

00:13:29,040 --> 00:13:33,270
example we could take a look at threads

00:13:30,750 --> 00:13:36,839
in this particular java application if

00:13:33,270 --> 00:13:40,200
i'd here's a list of all the threads and

00:13:36,839 --> 00:13:41,310
you get a you get a stack trace for each

00:13:40,200 --> 00:13:43,170
one of those so if you're trying to

00:13:41,310 --> 00:13:45,150
diagnose a problem or you you're

00:13:43,170 --> 00:13:46,589
beginning to see an instant slowing down

00:13:45,150 --> 00:13:48,660
and you're trying to figure out what are

00:13:46,589 --> 00:13:51,000
all the threads doing why isn't its why

00:13:48,660 --> 00:13:52,230
isn't it responding to requests or why

00:13:51,000 --> 00:13:53,880
are they taking so long

00:13:52,230 --> 00:13:55,529
you could do a thread dump look at the

00:13:53,880 --> 00:13:57,600
threads see what they're all busy doing

00:13:55,529 --> 00:13:59,670
and maybe begin to get an idea of what's

00:13:57,600 --> 00:14:04,410
going on inside of that in that side of

00:13:59,670 --> 00:14:08,910
that app if we switch over to the dotnet

00:14:04,410 --> 00:14:10,800
application similar things start happens

00:14:08,910 --> 00:14:13,440
now because we've we've enabled these

00:14:10,800 --> 00:14:15,210
applicant to this application with the

00:14:13,440 --> 00:14:17,190
actuator endpoints in this case we get

00:14:15,210 --> 00:14:19,200
the steel-toe symbol up at the top that

00:14:17,190 --> 00:14:21,990
signifies that the actuator endpoints

00:14:19,200 --> 00:14:24,690
are now in the application itself we get

00:14:21,990 --> 00:14:29,130
a trace we get some things we get a we

00:14:24,690 --> 00:14:31,050
we get able to view traces this

00:14:29,130 --> 00:14:34,080
particular app that i've got is an

00:14:31,050 --> 00:14:36,480
asp.net core app that's running on linux

00:14:34,080 --> 00:14:38,250
and so since it's not running on Windows

00:14:36,480 --> 00:14:40,200
I don't have the thread dump and I don't

00:14:38,250 --> 00:14:41,400
have the heap dump available to me right

00:14:40,200 --> 00:14:44,100
now that's something we're going to add

00:14:41,400 --> 00:14:46,050
in the future but it's not there yet

00:14:44,100 --> 00:14:49,589
but one of the things for example that

00:14:46,050 --> 00:14:51,270
you get is notice the steel-toe symbol

00:14:49,589 --> 00:14:53,190
down here is you get some good

00:14:51,270 --> 00:14:55,080
information so one of the things that

00:14:53,190 --> 00:14:58,080
the endpoints provide is the info

00:14:55,080 --> 00:14:59,670
endpoint that allows you to capture some

00:14:58,080 --> 00:15:01,680
basically some configuration information

00:14:59,670 --> 00:15:04,020
about the application in this case it's

00:15:01,680 --> 00:15:06,570
get information it tells you what commit

00:15:04,020 --> 00:15:08,070
this was this app this was built from it

00:15:06,570 --> 00:15:09,630
gives you when it was built some things

00:15:08,070 --> 00:15:11,700
that you know typically when you're

00:15:09,630 --> 00:15:13,890
starting to diagnose a problem you kind

00:15:11,700 --> 00:15:15,870
of want to know what instance and what

00:15:13,890 --> 00:15:18,540
bit of code am I actually looking at so

00:15:15,870 --> 00:15:23,160
that you can begin to to to look at it

00:15:18,540 --> 00:15:26,490
so let me switch over to let me switch

00:15:23,160 --> 00:15:33,750
over to some looking at this this app

00:15:26,490 --> 00:15:34,649
itself the order the dotnet app so in

00:15:33,750 --> 00:15:37,649
order to get the

00:15:34,649 --> 00:15:39,509
things to those end points to become

00:15:37,649 --> 00:15:40,980
available those rest endpoints to become

00:15:39,509 --> 00:15:42,839
available it's pretty straightforward

00:15:40,980 --> 00:15:45,779
within your application to add that

00:15:42,839 --> 00:15:48,019
functionality so if I go to a program

00:15:45,779 --> 00:15:51,300
beam and take a look at the application

00:15:48,019 --> 00:15:53,100
can everybody see that a little bit

00:15:51,300 --> 00:15:59,749
bigger

00:15:53,100 --> 00:16:02,429
let's see control how's that good enough

00:15:59,749 --> 00:16:04,470
so there's a couple things a couple

00:16:02,429 --> 00:16:07,529
things that were added in here for for

00:16:04,470 --> 00:16:09,749
making this enabling this application

00:16:07,529 --> 00:16:11,339
with steel toe and and those end points

00:16:09,749 --> 00:16:13,709
the first thing as we do is we add this

00:16:11,339 --> 00:16:16,589
Cloud Foundry configuration provider

00:16:13,709 --> 00:16:19,019
this basically parses vcap services vcap

00:16:16,589 --> 00:16:21,059
application and pulls that information

00:16:19,019 --> 00:16:23,339
into your application and makes it part

00:16:21,059 --> 00:16:25,319
of your applications configuration data

00:16:23,339 --> 00:16:27,600
it also makes it available for all the

00:16:25,319 --> 00:16:30,329
other steel-toe components for for

00:16:27,600 --> 00:16:31,589
operation then as you're gonna see in a

00:16:30,329 --> 00:16:33,839
minute we're going to talk about logging

00:16:31,589 --> 00:16:35,610
one of the features that that's in the

00:16:33,839 --> 00:16:37,769
actuator endpoints is the ability to

00:16:35,610 --> 00:16:40,740
monitor and change the logging of your

00:16:37,769 --> 00:16:42,149
application on-the-fly to do that you

00:16:40,740 --> 00:16:44,309
have to add use something called the

00:16:42,149 --> 00:16:46,860
dynamic console logger basically a

00:16:44,309 --> 00:16:49,439
wrapper around the standard logging

00:16:46,860 --> 00:16:51,990
provider that Microsoft provides for

00:16:49,439 --> 00:16:54,540
console but it also been allows us to do

00:16:51,990 --> 00:16:57,689
this querying and and changing of the

00:16:54,540 --> 00:16:59,370
console of the log levels so those two

00:16:57,689 --> 00:17:03,269
things are needed in program main and

00:16:59,370 --> 00:17:05,640
then over in your startup class you need

00:17:03,269 --> 00:17:07,649
to add the Cloud Foundry actuators this

00:17:05,640 --> 00:17:11,159
will add all of those in all of those

00:17:07,649 --> 00:17:12,899
endpoints info logging heap dump if it's

00:17:11,159 --> 00:17:14,850
per if it's relevant all those things

00:17:12,899 --> 00:17:16,380
that I said just so with this one single

00:17:14,850 --> 00:17:20,789
command will add those endpoints as

00:17:16,380 --> 00:17:23,760
services within the container then if

00:17:20,789 --> 00:17:26,429
you go down here you then have to add

00:17:23,760 --> 00:17:28,350
those rest endpoints as into the into

00:17:26,429 --> 00:17:30,029
the pipeline into the as part of the

00:17:28,350 --> 00:17:32,340
middleware so then you just do this and

00:17:30,029 --> 00:17:34,409
now all of those rest endpoints have

00:17:32,340 --> 00:17:36,390
been actually enabled and made available

00:17:34,409 --> 00:17:38,100
now within your application that's all

00:17:36,390 --> 00:17:40,440
you need to do there is one small thing

00:17:38,100 --> 00:17:41,880
I forgot I just thought of you do have

00:17:40,440 --> 00:17:44,130
to add some a little bit of

00:17:41,880 --> 00:17:48,440
configuration so in app settings JSON

00:17:44,130 --> 00:17:50,750
you have to enable this endpoint or this

00:17:48,440 --> 00:17:54,230
for the management end points this is

00:17:50,750 --> 00:17:57,769
the this is the end point that the apse

00:17:54,230 --> 00:18:01,490
manager calls in order to access those

00:17:57,769 --> 00:18:05,649
rest endpoints this is the context okay

00:18:01,490 --> 00:18:10,190
that's pretty much it so just quickly

00:18:05,649 --> 00:18:12,019
trace what Trace does is when you enable

00:18:10,190 --> 00:18:14,450
when you have the trace actuator

00:18:12,019 --> 00:18:15,950
endpoint within within your app enabled

00:18:14,450 --> 00:18:18,440
you actually are able it keeps a

00:18:15,950 --> 00:18:20,360
circularbuffer of the last 100 requests

00:18:18,440 --> 00:18:22,700
that came into that application it

00:18:20,360 --> 00:18:26,720
captures request headers and the

00:18:22,700 --> 00:18:28,970
response data it also captures response

00:18:26,720 --> 00:18:31,639
time this particular requests are 37

00:18:28,970 --> 00:18:33,320
milliseconds and and basically it's it's

00:18:31,639 --> 00:18:35,240
actually configurable as to what

00:18:33,320 --> 00:18:38,539
information you collect as part of that

00:18:35,240 --> 00:18:42,830
trace as I said it's a circular buffer

00:18:38,539 --> 00:18:46,029
that runs a by default a hundred honored

00:18:42,830 --> 00:18:48,260
requests then when we look at logging

00:18:46,029 --> 00:18:50,480
one of the things that I mentioned is

00:18:48,260 --> 00:18:53,720
that that's enabled is you are able to

00:18:50,480 --> 00:18:55,730
configure logging levels so if I click

00:18:53,720 --> 00:18:57,380
on this logging level thing I'll notice

00:18:55,730 --> 00:19:01,399
first of all that I'm able to see now

00:18:57,380 --> 00:19:03,019
I've got I've got a 109 loggers that

00:19:01,399 --> 00:19:04,730
have been created within this

00:19:03,019 --> 00:19:09,350
application since it's been running and

00:19:04,730 --> 00:19:12,769
I can go in here and say web application

00:19:09,350 --> 00:19:14,450
- and I see all of the categories

00:19:12,769 --> 00:19:17,779
underneath that and I can just go over

00:19:14,450 --> 00:19:20,240
here and switch this to debug and now

00:19:17,779 --> 00:19:23,210
all of those loggers have been changed

00:19:20,240 --> 00:19:26,120
from whatever it was info or nothing to

00:19:23,210 --> 00:19:27,919
debug level logging now you can capture

00:19:26,120 --> 00:19:29,750
logs for example if you're trying to

00:19:27,919 --> 00:19:30,380
diagnose a problem you can capture some

00:19:29,750 --> 00:19:32,539
logs

00:19:30,380 --> 00:19:34,399
this has been changed on all instances

00:19:32,539 --> 00:19:36,830
of the of this particular application

00:19:34,399 --> 00:19:39,500
whatever it may be so you can capture

00:19:36,830 --> 00:19:40,669
the logs and do some offline analysis or

00:19:39,500 --> 00:19:42,860
if you're trying to diagnose a problem

00:19:40,669 --> 00:19:45,289
and when you're all done you can go back

00:19:42,860 --> 00:19:48,049
and you know set it to set it to info

00:19:45,289 --> 00:19:50,179
and you're ready to go so this is a nice

00:19:48,049 --> 00:19:56,210
little feature that we've that's enabled

00:19:50,179 --> 00:19:58,779
by the actuator endpoints also if I go

00:19:56,210 --> 00:20:02,409
in here there's a what's called a health

00:19:58,779 --> 00:20:04,730
endpoint the health endpoint

00:20:02,409 --> 00:20:06,440
is essentially captured in this

00:20:04,730 --> 00:20:10,129
particular case what it's capturing is

00:20:06,440 --> 00:20:11,450
is it's looking at the disk space that

00:20:10,129 --> 00:20:13,879
you have available for this particular

00:20:11,450 --> 00:20:15,739
instance of the app and making sure that

00:20:13,879 --> 00:20:17,659
the you're not eating up all the disk

00:20:15,739 --> 00:20:19,309
space if you can set thresholds such

00:20:17,659 --> 00:20:21,559
that if that app begins to write too

00:20:19,309 --> 00:20:24,470
much data to its local disk and begin

00:20:21,559 --> 00:20:27,049
begins to overflow it'll it'll flag this

00:20:24,470 --> 00:20:29,299
as being a application that is in bad

00:20:27,049 --> 00:20:31,220
health you can also add other health

00:20:29,299 --> 00:20:32,869
indicators into here like for example we

00:20:31,220 --> 00:20:35,059
have a my secret my sequel health

00:20:32,869 --> 00:20:36,619
indicator which actually test the my

00:20:35,059 --> 00:20:39,379
sequel connection if you actually have a

00:20:36,619 --> 00:20:41,149
my sequel database

00:20:39,379 --> 00:20:43,039
tied to your application on the back end

00:20:41,149 --> 00:20:44,629
there could be RabbitMQ and in fact you

00:20:43,039 --> 00:20:46,309
can write your own health indicators and

00:20:44,629 --> 00:20:48,409
plug it into this this infrastructure

00:20:46,309 --> 00:20:50,659
without too much trouble and you'll just

00:20:48,409 --> 00:20:53,600
see this information pop up within at

00:20:50,659 --> 00:20:59,809
least you know as rest json data that

00:20:53,600 --> 00:21:01,580
comes back and rest calls okay so those

00:20:59,809 --> 00:21:03,590
are the management endpoints i pretty

00:21:01,580 --> 00:21:05,659
much focused on the.net ones but all

00:21:03,590 --> 00:21:07,429
that same stuff is there for java as

00:21:05,659 --> 00:21:09,320
well so it's nice you have one common

00:21:07,429 --> 00:21:12,169
set of endpoints that you can use to

00:21:09,320 --> 00:21:14,299
look into and peer into both run running

00:21:12,169 --> 00:21:15,739
Java applications to dotnet apps this

00:21:14,299 --> 00:21:18,109
has been part of what what I just

00:21:15,739 --> 00:21:20,359
described has been part of steel-toe up

00:21:18,109 --> 00:21:24,859
through 2.0 we're currently working on

00:21:20,359 --> 00:21:29,419
2.1 of Steel Toe right now okay so let

00:21:24,859 --> 00:21:34,909
me move on to another area distributed

00:21:29,419 --> 00:21:37,489
tracing this is a new area for 2.1 for

00:21:34,909 --> 00:21:39,470
dotnet for steel-toe it's been around

00:21:37,489 --> 00:21:42,320
obviously in the java world for quite

00:21:39,470 --> 00:21:45,559
some time it's part of in the java world

00:21:42,320 --> 00:21:47,210
it's called spring cloud sleuth and it's

00:21:45,559 --> 00:21:49,100
pretty much tied to Zipkin although i

00:21:47,210 --> 00:21:51,980
think in the 2.0 release they're doing

00:21:49,100 --> 00:21:56,029
some things to add open tracing support

00:21:51,980 --> 00:21:58,429
as well and then if you want to add you

00:21:56,029 --> 00:22:00,619
know basically use distributed tracing

00:21:58,429 --> 00:22:03,249
within your app in the java world you

00:22:00,619 --> 00:22:05,629
add a dependency on spring on sleuth and

00:22:03,249 --> 00:22:07,609
in the steel-toe world you'll be adding

00:22:05,629 --> 00:22:10,240
a dependency this is not currently out

00:22:07,609 --> 00:22:12,470
there today it's it's still in process

00:22:10,240 --> 00:22:13,620
you'll add something called tracing core

00:22:12,470 --> 00:22:17,130
as an

00:22:13,620 --> 00:22:18,720
get dependency okay when you do that out

00:22:17,130 --> 00:22:22,010
of the box the first that one of the

00:22:18,720 --> 00:22:24,780
things that you get right away is all

00:22:22,010 --> 00:22:27,390
trace IDs and span what are called span

00:22:24,780 --> 00:22:29,160
IDs you think of a trace as as a

00:22:27,390 --> 00:22:32,100
distributed request that's going through

00:22:29,160 --> 00:22:34,290
many multi many micro services within

00:22:32,100 --> 00:22:36,540
each one of the micro service there is a

00:22:34,290 --> 00:22:39,450
typically at least one or more spans

00:22:36,540 --> 00:22:40,860
created which are capturing trace

00:22:39,450 --> 00:22:43,309
information about that particular

00:22:40,860 --> 00:22:46,380
request and you can add or annotate

00:22:43,309 --> 00:22:48,059
whatever you want to that span that's

00:22:46,380 --> 00:22:50,970
all collected together as part of a

00:22:48,059 --> 00:22:53,580
trace and then optionally as you'll see

00:22:50,970 --> 00:22:56,030
you're able to actually send each one of

00:22:53,580 --> 00:22:59,690
those micro services can send their

00:22:56,030 --> 00:23:04,140
spans up to a central server for

00:22:59,690 --> 00:23:07,050
analysis and logging out of the box what

00:23:04,140 --> 00:23:13,380
you get with the steel-toe distributed

00:23:07,050 --> 00:23:15,780
trace is we enable adding span IDs and

00:23:13,380 --> 00:23:17,700
trace IDs to all log outputs that come

00:23:15,780 --> 00:23:19,230
out of the application and what that

00:23:17,700 --> 00:23:21,720
allows you to do is do something called

00:23:19,230 --> 00:23:25,260
log correlation this is also done in the

00:23:21,720 --> 00:23:29,190
java application so what's what's added

00:23:25,260 --> 00:23:32,490
is is essentially this capability right

00:23:29,190 --> 00:23:35,730
here or that I'm going to fast that

00:23:32,490 --> 00:23:38,820
little bit of service ID service name

00:23:35,730 --> 00:23:40,590
trace ID span ID and exported is all

00:23:38,820 --> 00:23:42,750
added to every one of the log log

00:23:40,590 --> 00:23:44,460
entries and then what we've also done is

00:23:42,750 --> 00:23:46,740
part of steel-toe is we've then gone

00:23:44,460 --> 00:23:49,290
ahead and instrumented all the ingress

00:23:46,740 --> 00:23:51,660
and egress places within your

00:23:49,290 --> 00:23:54,210
application so when a request comes in

00:23:51,660 --> 00:23:57,990
to say an asp.net core application will

00:23:54,210 --> 00:24:00,500
automatically start a span a piece of

00:23:57,990 --> 00:24:03,720
the trace and then if you initiate a

00:24:00,500 --> 00:24:05,880
HTTP request call to another outside

00:24:03,720 --> 00:24:08,370
process will actually forward the

00:24:05,880 --> 00:24:10,830
context the trace context automatically

00:24:08,370 --> 00:24:13,440
for you out that egress point okay so

00:24:10,830 --> 00:24:15,870
that that trace will continue to flow

00:24:13,440 --> 00:24:17,940
throughout the microservices application

00:24:15,870 --> 00:24:20,480
and like I said this works for both Java

00:24:17,940 --> 00:24:22,920
and.net it's all interoperability all

00:24:20,480 --> 00:24:24,750
interoperable and I'll show you here an

00:24:22,920 --> 00:24:26,700
exhibit an example that's what you get

00:24:24,750 --> 00:24:27,480
automatically out-of-the-box then you

00:24:26,700 --> 00:24:29,310
can optionally

00:24:27,480 --> 00:24:32,580
if you'd like to instrument your app

00:24:29,310 --> 00:24:35,070
yourself so you can start your own spans

00:24:32,580 --> 00:24:37,770
or you can add context or more

00:24:35,070 --> 00:24:41,310
information to the spans like for

00:24:37,770 --> 00:24:42,750
example customer IDs or order IDs or

00:24:41,310 --> 00:24:45,270
what are any information you'd like to

00:24:42,750 --> 00:24:47,610
add to your application or add to your

00:24:45,270 --> 00:24:49,620
trace can be done and you do that in in

00:24:47,610 --> 00:24:52,500
the Java world using the brave API is

00:24:49,620 --> 00:24:55,350
the Zipkin brave api's that are part of

00:24:52,500 --> 00:24:57,510
the spring cloud sleuth in the Steel Toe

00:24:55,350 --> 00:24:59,580
world you'll be using the open census a

00:24:57,510 --> 00:25:01,710
BIA ap is the ones that I talked about

00:24:59,580 --> 00:25:05,010
that we've implemented as part of the

00:25:01,710 --> 00:25:06,630
Google activity that we've done and then

00:25:05,010 --> 00:25:08,790
optionally you can enable your

00:25:06,630 --> 00:25:11,490
application to send those spans and

00:25:08,790 --> 00:25:14,390
traces to the back-end server and you

00:25:11,490 --> 00:25:16,680
can export them to different backends

00:25:14,390 --> 00:25:20,850
Zipkin is one of the more popular ones

00:25:16,680 --> 00:25:23,450
that we have used in within pivitol

00:25:20,850 --> 00:25:25,980
quite a bit but there are others Jagr

00:25:23,450 --> 00:25:29,460
stack whatever it's called stack driver

00:25:25,980 --> 00:25:31,110
from Google and others there's there's

00:25:29,460 --> 00:25:33,540
quite a few we've already done one

00:25:31,110 --> 00:25:38,550
exporter for Zipkin as part of the

00:25:33,540 --> 00:25:41,220
steel-toe project okay so let me let me

00:25:38,550 --> 00:25:43,140
go into again the demo that illustrates

00:25:41,220 --> 00:25:45,510
that we'll drive this home so I'm gonna

00:25:43,140 --> 00:25:48,150
use something from pivitol called PCF

00:25:45,510 --> 00:25:51,410
metrics to show log correlation that's

00:25:48,150 --> 00:25:54,060
down there in the bottom bottom left and

00:25:51,410 --> 00:25:56,130
it's important to realize that the log

00:25:54,060 --> 00:25:59,160
messages are just getting annotated with

00:25:56,130 --> 00:26:01,350
that that information if you're using

00:25:59,160 --> 00:26:03,720
some other log analysis tool instead of

00:26:01,350 --> 00:26:05,640
PCF metrics the same demo that I'm about

00:26:03,720 --> 00:26:07,500
to show you would work as well because

00:26:05,640 --> 00:26:08,790
it's all just basically flowing in

00:26:07,500 --> 00:26:11,430
through the logger Gator and out the

00:26:08,790 --> 00:26:13,710
firehose into whatever whatever wants to

00:26:11,430 --> 00:26:15,900
collect it and then I'll also show you

00:26:13,710 --> 00:26:18,060
the Zipkin server so the traces will

00:26:15,900 --> 00:26:19,410
actually get sent back into a Zipkin

00:26:18,060 --> 00:26:28,800
server and we'll take a look at that as

00:26:19,410 --> 00:26:32,370
well okay so I'm going to start a

00:26:28,800 --> 00:26:34,020
a console app that will start hopefully

00:26:32,370 --> 00:26:36,510
hitting the end point and start

00:26:34,020 --> 00:26:41,850
generating some traces and so forth some

00:26:36,510 --> 00:26:48,870
some data on the app and then I'm gonna

00:26:41,850 --> 00:26:50,580
go to PCF metrics here and so this is

00:26:48,870 --> 00:26:52,110
PCF metrics if you've never seen it

00:26:50,580 --> 00:26:54,030
there are actually two parts to PCF

00:26:52,110 --> 00:26:57,270
metrics there's a log analysis part of

00:26:54,030 --> 00:26:59,340
it and then there's a metrics analysis

00:26:57,270 --> 00:27:02,910
component we're gonna first focus on the

00:26:59,340 --> 00:27:06,630
log analysis part right right here so

00:27:02,910 --> 00:27:10,680
this is essentially a raw log dump of

00:27:06,630 --> 00:27:12,480
this this set of applications and I'm

00:27:10,680 --> 00:27:16,050
gonna pick one of the I'm gonna pick

00:27:12,480 --> 00:27:17,700
this log message from check out first of

00:27:16,050 --> 00:27:19,920
all the thing that you want to want to

00:27:17,700 --> 00:27:22,080
take a look at is notice this here this

00:27:19,920 --> 00:27:23,640
is what I was talking about every one of

00:27:22,080 --> 00:27:26,400
the log messages coming out of these

00:27:23,640 --> 00:27:30,120
applications now contain the name of the

00:27:26,400 --> 00:27:32,370
component the trace ID and the span ID

00:27:30,120 --> 00:27:34,710
and that's what's used to do log

00:27:32,370 --> 00:27:36,750
correlation and that's what in this case

00:27:34,710 --> 00:27:39,480
PCF metrics or any other application

00:27:36,750 --> 00:27:41,670
could could use the way you way you make

00:27:39,480 --> 00:27:44,940
use of that within PCF metrics is you

00:27:41,670 --> 00:27:46,380
find like the get checkout request and

00:27:44,940 --> 00:27:48,570
you click on this button to view the

00:27:46,380 --> 00:27:51,200
trace to view the trace in the trace

00:27:48,570 --> 00:27:54,840
Explorer so I'm gonna go ahead and click

00:27:51,200 --> 00:27:57,120
click that and what I get here is now I

00:27:54,840 --> 00:28:00,060
get all of the log messages that are

00:27:57,120 --> 00:28:02,790
specific to this particular trace this

00:28:00,060 --> 00:28:05,340
particular trace ID okay so every one of

00:28:02,790 --> 00:28:07,140
the log messages from the payments

00:28:05,340 --> 00:28:08,730
processor the orders processor and the

00:28:07,140 --> 00:28:12,420
shopping cart are all shown here and

00:28:08,730 --> 00:28:16,710
they're all actually shown I think it's

00:28:12,420 --> 00:28:19,980
in a Sunday or newest to oldest is the

00:28:16,710 --> 00:28:22,320
way it's sorted right now and then up at

00:28:19,980 --> 00:28:25,020
the very top it actually shows you the

00:28:22,320 --> 00:28:27,540
timings for each one of those requests

00:28:25,020 --> 00:28:31,650
so you see the time that it took for the

00:28:27,540 --> 00:28:33,960
checkout endpoint to finish was 58

00:28:31,650 --> 00:28:36,630
milliseconds as part of that entire 58

00:28:33,960 --> 00:28:40,170
milliseconds 35.5 of it was used for the

00:28:36,630 --> 00:28:42,950
process order and the 11.8 was used by

00:28:40,170 --> 00:28:42,950
their charge card

00:28:44,670 --> 00:28:50,200
so log correlation all done and we can

00:28:48,460 --> 00:28:51,640
we can we can see that we could we can

00:28:50,200 --> 00:28:53,050
do this across both Java and.net

00:28:51,640 --> 00:28:54,940
applications because we're being

00:28:53,050 --> 00:28:57,990
consistent now the next thing that you

00:28:54,940 --> 00:29:01,170
can do is you can take this trace ID and

00:28:57,990 --> 00:29:04,000
you can go over to the Zipkin

00:29:01,170 --> 00:29:07,300
application which is now it's been

00:29:04,000 --> 00:29:09,580
collecting the traces right each one of

00:29:07,300 --> 00:29:13,030
the Java and.net components are sending

00:29:09,580 --> 00:29:15,580
their traces you can just enter this and

00:29:13,030 --> 00:29:17,680
it'll do a query and you get basically

00:29:15,580 --> 00:29:20,320
similar information but you get another

00:29:17,680 --> 00:29:23,530
level of detail and another level of

00:29:20,320 --> 00:29:25,150
accuracy so here we've got on the Left

00:29:23,530 --> 00:29:26,770
we've got the shopping cart service and

00:29:25,150 --> 00:29:29,320
in within the shopping cart service are

00:29:26,770 --> 00:29:31,420
actually two spans that were created it

00:29:29,320 --> 00:29:33,760
calls the order processor which in turn

00:29:31,420 --> 00:29:36,760
calls the payment processor I can look

00:29:33,760 --> 00:29:39,790
at each individual span just by clicking

00:29:36,760 --> 00:29:41,860
on this and now I get more details about

00:29:39,790 --> 00:29:44,740
that particular request how long it took

00:29:41,860 --> 00:29:47,170
and notice what I also get is I get this

00:29:44,740 --> 00:29:49,570
key value pair set of information these

00:29:47,170 --> 00:29:51,490
are attributes that can be applied or

00:29:49,570 --> 00:29:53,440
added to the span as it's going through

00:29:51,490 --> 00:29:57,190
the application it allows you to collect

00:29:53,440 --> 00:29:59,140
data and there's by default steel-toe

00:29:57,190 --> 00:30:01,750
and the spring cloud sleuth will add

00:29:59,140 --> 00:30:04,570
they're set default set of attributes

00:30:01,750 --> 00:30:06,760
but you as a developer can augment or

00:30:04,570 --> 00:30:08,680
add whatever information you'd like so

00:30:06,760 --> 00:30:11,020
you can capture application specific

00:30:08,680 --> 00:30:14,980
information as part of that as part of

00:30:11,020 --> 00:30:16,480
that as part of that trace and we've

00:30:14,980 --> 00:30:22,510
gotta just-in-time to bugger that just

00:30:16,480 --> 00:30:24,490
popped up okay so that is distributed

00:30:22,510 --> 00:30:26,440
tracing that's something new and 2.1 of

00:30:24,490 --> 00:30:28,870
steel-toe it already exists in the java

00:30:26,440 --> 00:30:32,700
world as part of spring cloud sleuth and

00:30:28,870 --> 00:30:32,700
we'll be releasing that as part of 2.1

00:30:33,000 --> 00:30:43,230
mmm did we pick a date yet Jason for 2.1

00:30:36,700 --> 00:30:43,230
steel-toe huh August

00:30:52,360 --> 00:30:57,130
okay let's go into metrics that's

00:30:54,700 --> 00:30:58,179
another new area as far as steel-toe is

00:30:57,130 --> 00:31:03,330
concerned something new that we're

00:30:58,179 --> 00:31:06,940
adding and as part of steel-toe so

00:31:03,330 --> 00:31:08,200
within if you go back to the actuator

00:31:06,940 --> 00:31:09,580
endpoint you'll note you will have

00:31:08,200 --> 00:31:14,440
noticed that the one of the endpoints is

00:31:09,580 --> 00:31:18,370
something called metrics and what this

00:31:14,440 --> 00:31:20,830
basically does is it allows you to query

00:31:18,370 --> 00:31:23,260
the application and pull application

00:31:20,830 --> 00:31:28,510
metrics out of it so response time by

00:31:23,260 --> 00:31:30,549
endpoint heap usage you know job garbage

00:31:28,510 --> 00:31:32,019
collection times and all that kind of

00:31:30,549 --> 00:31:32,669
information I'll show you that here in a

00:31:32,019 --> 00:31:35,710
second

00:31:32,669 --> 00:31:38,590
and this is available both in the Java

00:31:35,710 --> 00:31:41,080
applications as part of the spring

00:31:38,590 --> 00:31:42,929
actuators as spring actuator endpoints

00:31:41,080 --> 00:31:45,100
as well as now in the steel-toe

00:31:42,929 --> 00:31:48,789
inflammation implementation at two point

00:31:45,100 --> 00:31:50,500
one the endpoints are exposed via HTTP

00:31:48,789 --> 00:31:52,570
end points system metrics are

00:31:50,500 --> 00:31:54,340
automatically collected for you so

00:31:52,570 --> 00:31:55,929
things like I said he keep information

00:31:54,340 --> 00:31:59,429
that sort of stuff

00:31:55,929 --> 00:32:02,409
app metrics are also automatically

00:31:59,429 --> 00:32:04,659
collected and created for you on ingress

00:32:02,409 --> 00:32:07,179
and egress points within your

00:32:04,659 --> 00:32:08,919
application so as requests come in in

00:32:07,179 --> 00:32:12,010
your asp.net core application for

00:32:08,919 --> 00:32:14,409
example will increment counters well

00:32:12,010 --> 00:32:16,269
capture time stamps will you know all of

00:32:14,409 --> 00:32:19,779
that sort of stuff will aggregate that

00:32:16,269 --> 00:32:22,659
information all within the steel-toe

00:32:19,779 --> 00:32:24,399
metrics components and then optionally

00:32:22,659 --> 00:32:26,220
you can actually add your own metrics as

00:32:24,399 --> 00:32:28,539
well so if there are some specific

00:32:26,220 --> 00:32:30,760
application specific data that you want

00:32:28,539 --> 00:32:32,529
to capture over a period of time as your

00:32:30,760 --> 00:32:34,360
application is running you can add those

00:32:32,529 --> 00:32:37,570
as well and there's a nice tagging

00:32:34,360 --> 00:32:39,220
system as part of open census that you

00:32:37,570 --> 00:32:42,490
can make use of to actually tag your

00:32:39,220 --> 00:32:44,230
metrics then optionally if you would

00:32:42,490 --> 00:32:47,260
rather instead of having to hit the

00:32:44,230 --> 00:32:50,950
metrics HTTP endpoint and get the data

00:32:47,260 --> 00:32:53,200
you can optionally cause the components

00:32:50,950 --> 00:32:56,139
to export the metrics to a back-end

00:32:53,200 --> 00:32:58,059
system and we have already implemented

00:32:56,139 --> 00:33:00,250
I'll be demoing this in a second where

00:32:58,059 --> 00:33:02,889
we'll actually export the application

00:33:00,250 --> 00:33:04,840
metrics to the metrics forward or within

00:33:02,889 --> 00:33:06,429
PCF within the pivotal Cloud Foundry

00:33:04,840 --> 00:33:08,139
we're going to do other

00:33:06,429 --> 00:33:09,700
exporters as well so you don't have to

00:33:08,139 --> 00:33:12,100
necessarily and all that is by the way

00:33:09,700 --> 00:33:14,379
the metrics export all it does is it

00:33:12,100 --> 00:33:17,470
captures the metrics information and

00:33:14,379 --> 00:33:21,850
puts it into the logger Gator firehose

00:33:17,470 --> 00:33:23,710
so any any metrics applet ryx tool that

00:33:21,850 --> 00:33:25,659
you want to make use of can actually use

00:33:23,710 --> 00:33:31,389
that information if it's able to read

00:33:25,659 --> 00:33:40,440
out of it so let me go quickly do a show

00:33:31,389 --> 00:33:43,919
you that so I've been running that app

00:33:40,440 --> 00:33:48,879
that console app that's been generating

00:33:43,919 --> 00:33:59,019
hopefully requests and now I'm going to

00:33:48,879 --> 00:34:04,210
use the PCF metrics tool to surface some

00:33:59,019 --> 00:34:06,220
of the metrics so right now I'm looking

00:34:04,210 --> 00:34:11,889
at the shopping cart which is the java

00:34:06,220 --> 00:34:14,020
application and if i want to add two up

00:34:11,889 --> 00:34:15,460
here at the top is essentially all of

00:34:14,020 --> 00:34:20,079
the various metrics that are being

00:34:15,460 --> 00:34:22,629
they're being captured by the PCF

00:34:20,079 --> 00:34:24,309
metrics and i can add additional metrics

00:34:22,629 --> 00:34:27,329
by clicking up here and going to add

00:34:24,309 --> 00:34:31,839
chart and then for example i can say

00:34:27,329 --> 00:34:35,740
let's see heap used now this is a java

00:34:31,839 --> 00:34:37,899
application so I can add the heap usage

00:34:35,740 --> 00:34:40,030
and now I get a graph of the heap usage

00:34:37,899 --> 00:34:43,510
for the whatever the period of time I

00:34:40,030 --> 00:34:45,819
selected and I can take a look at that I

00:34:43,510 --> 00:34:48,639
can go on and do garbage collection all

00:34:45,819 --> 00:34:50,589
kinds of additional metrics that I can

00:34:48,639 --> 00:34:52,679
do but I what's more interesting is

00:34:50,589 --> 00:34:56,109
let's go over to the dotnet application

00:34:52,679 --> 00:34:58,710
so we'll switch over to the orders

00:34:56,109 --> 00:34:58,710
processor

00:35:05,040 --> 00:35:15,360
and as it's refreshing I've already been

00:35:11,700 --> 00:35:18,440
in here as you can see one of the things

00:35:15,360 --> 00:35:21,090
we we see here is we see heap usage

00:35:18,440 --> 00:35:24,030
coming out of the application we also

00:35:21,090 --> 00:35:27,870
see generation collections GC gen 1 GC

00:35:24,030 --> 00:35:29,520
gen gen 0 and we also see actually the

00:35:27,870 --> 00:35:32,280
response time for the process order

00:35:29,520 --> 00:35:34,230
endpoint plotted over time within and

00:35:32,280 --> 00:35:36,270
this is all application metrics that are

00:35:34,230 --> 00:35:39,870
being captured by steel-toe and being

00:35:36,270 --> 00:35:41,880
flown or being sent on to the firehose

00:35:39,870 --> 00:35:43,400
for collection and in this case the PCF

00:35:41,880 --> 00:35:46,650
metrics is what's being used to

00:35:43,400 --> 00:35:48,810
demonstrate that so you get this you get

00:35:46,650 --> 00:35:50,610
a basically you get the same set of kind

00:35:48,810 --> 00:35:52,740
of metrics that you get out of a Java

00:35:50,610 --> 00:35:55,700
app you begin to get out of a dotnet app

00:35:52,740 --> 00:35:59,250
they can be combined into one you know

00:35:55,700 --> 00:36:03,330
analysis tool for analysis and and

00:35:59,250 --> 00:36:11,640
exploration this is something that'll be

00:36:03,330 --> 00:36:14,250
like I said in 2.1 and we hope to have

00:36:11,640 --> 00:36:17,180
that soon and real quickly because i'm

00:36:14,250 --> 00:36:22,170
running out of time I'm going to show

00:36:17,180 --> 00:36:23,910
history as well so what we have here on

00:36:22,170 --> 00:36:27,780
the history in the hill in the case of

00:36:23,910 --> 00:36:29,340
history is if you're using history in

00:36:27,780 --> 00:36:31,830
order to make requests to back-end

00:36:29,340 --> 00:36:34,110
services you have to build a command

00:36:31,830 --> 00:36:37,040
pattern around the remote endpoint and

00:36:34,110 --> 00:36:39,720
you make use of the history X command

00:36:37,040 --> 00:36:42,480
class in order to implement that command

00:36:39,720 --> 00:36:45,300
as part of that you get metrics and

00:36:42,480 --> 00:36:47,310
monitoring that comes out of that out of

00:36:45,300 --> 00:36:49,470
that particular command and what I've

00:36:47,310 --> 00:36:52,470
done is is in the order process I'm

00:36:49,470 --> 00:36:55,380
using a history command to make calls to

00:36:52,470 --> 00:36:56,880
the payment process okay so we're going

00:36:55,380 --> 00:37:01,610
to take a look at the historic stash

00:36:56,880 --> 00:37:01,610
board that's part of PCF

00:37:04,510 --> 00:37:09,850
and I thought I had it up let me so the

00:37:08,500 --> 00:37:13,600
way you get that is you go over to

00:37:09,850 --> 00:37:20,220
services circuit break your dashboard

00:37:13,600 --> 00:37:20,220
click manage oops

00:37:30,930 --> 00:37:33,710
hang on

00:37:53,720 --> 00:38:01,069
and here is the circuit breaker

00:37:56,240 --> 00:38:04,760
dashboard and so looks like my app have

00:38:01,069 --> 00:38:10,099
my console app has crashed so it's not

00:38:04,760 --> 00:38:12,680
generating any so now we're starting to

00:38:10,099 --> 00:38:14,390
see real-time information coming in the

00:38:12,680 --> 00:38:15,859
payment service command is the command

00:38:14,390 --> 00:38:17,950
the history command that's making a

00:38:15,859 --> 00:38:21,460
requests of the payment service

00:38:17,950 --> 00:38:25,130
everything's doing doing well it's doing

00:38:21,460 --> 00:38:26,660
it's done 14 whatever 13 requests is set

00:38:25,130 --> 00:38:29,270
this side I think this window is 20

00:38:26,660 --> 00:38:31,309
seconds so it's doing about 13 that

00:38:29,270 --> 00:38:36,589
command is processing about 13 requests

00:38:31,309 --> 00:38:41,690
a second if I go back to the dashboard

00:38:36,589 --> 00:38:50,470
and do something crazy like shutdown the

00:38:41,690 --> 00:38:53,450
payments processor and if we go back to

00:38:50,470 --> 00:38:55,010
the history X monitor all of a sudden

00:38:53,450 --> 00:38:57,710
now we start to see failures right

00:38:55,010 --> 00:38:59,450
because that that history that requests

00:38:57,710 --> 00:39:02,720
to the payment service is failing we

00:38:59,450 --> 00:39:04,130
start to see that the circuit itself has

00:39:02,720 --> 00:39:06,020
opened we're using the circuit breaker

00:39:04,130 --> 00:39:10,789
pattern as part of this we're getting

00:39:06,020 --> 00:39:13,160
about 12 short circuits now a request so

00:39:10,789 --> 00:39:15,890
over time the circuit opens up or close

00:39:13,160 --> 00:39:17,660
opens up and the requests no longer

00:39:15,890 --> 00:39:19,190
start going to to the back-end service

00:39:17,660 --> 00:39:21,319
if I were to start up the payment

00:39:19,190 --> 00:39:24,079
service we'd see this now automatically

00:39:21,319 --> 00:39:26,750
turn back into all green everything's

00:39:24,079 --> 00:39:29,960
looking good what users are seeing of

00:39:26,750 --> 00:39:33,950
course on their side is they're just

00:39:29,960 --> 00:39:36,260
seeing order process successfully but

00:39:33,950 --> 00:39:37,910
payment processing is pending so you're

00:39:36,260 --> 00:39:41,890
able to basically fall back and take

00:39:37,910 --> 00:39:45,079
care of log the reorder and move on so

00:39:41,890 --> 00:39:48,279
okay I think I'm probably pretty much

00:39:45,079 --> 00:39:50,240
out of time there's so much to cover

00:39:48,279 --> 00:39:53,059
feel free to come up and ask questions

00:39:50,240 --> 00:39:55,460
afterwards if you'd like and I'll be

00:39:53,059 --> 00:39:58,090
around of course the rest of the day and

00:39:55,460 --> 00:40:03,289
tomorrow okay thank you

00:39:58,090 --> 00:40:03,289

YouTube URL: https://www.youtube.com/watch?v=bOuWshoviak


