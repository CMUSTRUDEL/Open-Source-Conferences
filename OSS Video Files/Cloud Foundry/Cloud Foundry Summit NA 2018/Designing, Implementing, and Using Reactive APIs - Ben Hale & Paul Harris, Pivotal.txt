Title: Designing, Implementing, and Using Reactive APIs - Ben Hale & Paul Harris, Pivotal
Publication date: 2018-04-21
Playlist: Cloud Foundry Summit NA 2018
Description: 
	Designing, Implementing, and Using Reactive APIs - Ben Hale & Paul Harris, Pivotal

The Java community is on the cusp of a major change in programming model. As the industry moves towards high-performance micro-service architectures, the need for a reactive programming model becomes clear. In this session, the lead developers of the Cloud Foundry Java Client will talk about what led them to choose a reactive API. Using that project as a lens, they'll explore how they designed and implemented this API using Project Reactor and what users will expect when using a reactive API. If you are a developer looking to provide reactive APIs, this is your chance to gain the experience of team building a large, production-ready reactive library. 

About Ben Hale
Ben Hale leads Pivotal's efforts to constantly improve the Java experience on Cloud Foundry. Recently he has been working on the Cloud Foundry Java Buildpack with an eye to making it the best place to run Java applications, in the Cloud or otherwise. In addition, he leads the team that is revamping the Cloud Foundry Java Client, a Java language binding on top of the Cloud Foundry REST APIs.

Prior to working on Cloud Foundry, Ben worked on large-scale middleware management tools, tc Server, dm Server (OSGi), and Spring. If you go back far enough, he even worked on a network management and monitoring application, but will deny it when asked. 

About Paul Harris
Paul Harris is the lead developer for the Cloud Foundry Java Client, working on bringing the power of Cloud Foundry’s API and CLI to Java. Prior to working on Cloud Foundry, Paul worked on large-scale middleware management tools, tc Server, and dm Server (OSGi). He’s worked in a range of industries from medical devices through manufacturing to banking, where he was one of the backroom heroes averting the Y2K disaster.
Captions: 
	00:00:00,030 --> 00:00:07,470
okay good afternoon everybody my name is

00:00:04,230 --> 00:00:10,080
Ben Hale I'm a pivotal employee and I am

00:00:07,470 --> 00:00:12,059
the lead of the Cloud Foundry Java

00:00:10,080 --> 00:00:14,160
experience which basically means that if

00:00:12,059 --> 00:00:17,970
you want to run Java applications on

00:00:14,160 --> 00:00:19,770
Cloud Foundry I sort of oversee all of

00:00:17,970 --> 00:00:24,960
the teams that are responsible for doing

00:00:19,770 --> 00:00:27,660
that my name is Paul Harris I'm the lead

00:00:24,960 --> 00:00:30,359
of the Cloud Foundry Java client and

00:00:27,660 --> 00:00:32,579
I've been working in tech for about 20

00:00:30,359 --> 00:00:35,040
years now and the last three of it as a

00:00:32,579 --> 00:00:37,370
developer so I'm relatively new to this

00:00:35,040 --> 00:00:40,770
and will be relatively gentle with your

00:00:37,370 --> 00:00:42,390
great so today we're going to be doing a

00:00:40,770 --> 00:00:45,930
talk called designing implementing and

00:00:42,390 --> 00:00:47,250
using reactive api's this talk was

00:00:45,930 --> 00:00:50,190
originally supposed to be an hour long

00:00:47,250 --> 00:00:53,070
so strap in this is gonna be pretty fast

00:00:50,190 --> 00:00:53,850
I am in protest so I will not read this

00:00:53,070 --> 00:00:58,230
next slide

00:00:53,850 --> 00:01:00,989
would you like to exits there's probably

00:00:58,230 --> 00:01:02,520
an exit here as well if you see me

00:01:00,989 --> 00:01:07,920
running just follow I think that's the

00:01:02,520 --> 00:01:10,950
basic message okay so we're gonna talk

00:01:07,920 --> 00:01:13,740
about reactive programming today but the

00:01:10,950 --> 00:01:15,689
term reactive has been just vastly

00:01:13,740 --> 00:01:18,030
overused it's been hijacked to mean a

00:01:15,689 --> 00:01:19,950
bunch of different things for the

00:01:18,030 --> 00:01:21,869
purposes of the discussion today though

00:01:19,950 --> 00:01:24,689
we want to define reactive programming

00:01:21,869 --> 00:01:28,829
as something that is a way to broadly

00:01:24,689 --> 00:01:30,600
define event-driven systems right so we

00:01:28,829 --> 00:01:32,490
effectively want to take code that

00:01:30,600 --> 00:01:34,049
you've already written or a code that

00:01:32,490 --> 00:01:36,060
you you know would know how to write

00:01:34,049 --> 00:01:38,420
imperative ly and we want to move it to

00:01:36,060 --> 00:01:40,320
a foundation that is asynchronous

00:01:38,420 --> 00:01:41,640
primarily and this is probably the

00:01:40,320 --> 00:01:42,420
biggest thing that you want to take away

00:01:41,640 --> 00:01:44,430
from it

00:01:42,420 --> 00:01:46,070
non-blocking and we'll talk a little bit

00:01:44,430 --> 00:01:48,240
about why this is really important a

00:01:46,070 --> 00:01:49,500
functional style code base so you're

00:01:48,240 --> 00:01:50,640
gonna see sort of different things

00:01:49,500 --> 00:01:52,439
you're gonna see a lot more use of

00:01:50,640 --> 00:01:55,439
closures and things like that that you

00:01:52,439 --> 00:01:58,020
may not have normally used but the whole

00:01:55,439 --> 00:02:02,549
goal behind doing reactive programming

00:01:58,020 --> 00:02:04,649
is to give us stable scalable access to

00:02:02,549 --> 00:02:07,290
external systems or inside of our own

00:02:04,649 --> 00:02:08,429
system the goal is to take what is an

00:02:07,290 --> 00:02:10,319
imperative programming that can

00:02:08,429 --> 00:02:12,180
potentially get you into trouble

00:02:10,319 --> 00:02:13,220
things like exploding thread pools

00:02:12,180 --> 00:02:14,690
things that block

00:02:13,220 --> 00:02:16,400
way too long blocking all incoming

00:02:14,690 --> 00:02:18,860
connections to sort of give you a

00:02:16,400 --> 00:02:21,290
programming model that removes that kind

00:02:18,860 --> 00:02:23,300
of behavior and so the way we're gonna

00:02:21,290 --> 00:02:25,100
do this is we're gonna talk about the

00:02:23,300 --> 00:02:27,170
Cloud Foundry Java client when we give

00:02:25,100 --> 00:02:30,080
this talk in a lot of places that are

00:02:27,170 --> 00:02:31,670
not Cloud Foundry summits which means

00:02:30,080 --> 00:02:33,320
that we have to explain what Cloud

00:02:31,670 --> 00:02:34,610
Foundry is the fact that it's composed

00:02:33,320 --> 00:02:36,710
of about five hundred and fifty

00:02:34,610 --> 00:02:39,320
different restful api secured by oath

00:02:36,710 --> 00:02:41,150
but you all know that there's even there

00:02:39,320 --> 00:02:42,500
uses is normally a slide in here that

00:02:41,150 --> 00:02:44,270
says don't worry that you don't

00:02:42,500 --> 00:02:45,920
understand these Cloud Foundry concepts

00:02:44,270 --> 00:02:47,090
the names will be self-explanatory I

00:02:45,920 --> 00:02:50,020
don't have to give that today because

00:02:47,090 --> 00:02:53,930
you won't know all of these gob boundary

00:02:50,020 --> 00:02:55,520
concepts and so what we take away when

00:02:53,930 --> 00:02:56,600
it comes to writing the Java client is

00:02:55,520 --> 00:02:58,760
that we have these really really

00:02:56,600 --> 00:03:00,709
low-level api they often need to be

00:02:58,760 --> 00:03:02,060
orchestrated so like I don't know if

00:03:00,709 --> 00:03:04,790
anybody's ever looked under the hood of

00:03:02,060 --> 00:03:07,070
what CF pushes Paul will be happy to

00:03:04,790 --> 00:03:08,600
tell you CF pushes at minimum thirteen

00:03:07,070 --> 00:03:11,810
different network requests trying to get

00:03:08,600 --> 00:03:14,060
all of this stuff coordinated so the

00:03:11,810 --> 00:03:15,440
Java client itself has become the

00:03:14,060 --> 00:03:18,400
preferred language for orchestrating

00:03:15,440 --> 00:03:20,720
Cloud Foundry more than any other

00:03:18,400 --> 00:03:25,000
orchestration tool we find that things

00:03:20,720 --> 00:03:27,290
as varied as spinnaker the tool from

00:03:25,000 --> 00:03:29,239
Netflix that's used to sort of

00:03:27,290 --> 00:03:32,420
orchestrate pushing applications to

00:03:29,239 --> 00:03:34,670
different cloud platforms to something

00:03:32,420 --> 00:03:36,950
like spring cloud dataflow uses this we

00:03:34,670 --> 00:03:38,930
see it in different customers as well we

00:03:36,950 --> 00:03:40,900
have everybody from like internally

00:03:38,930 --> 00:03:44,090
inside a pivotal we have an internal

00:03:40,900 --> 00:03:45,650
version of Cloud Foundry called Pez and

00:03:44,090 --> 00:03:47,720
they do a bunch of or castration there

00:03:45,650 --> 00:03:50,060
we see other clients outside doing

00:03:47,720 --> 00:03:52,459
orchestration and automating access to

00:03:50,060 --> 00:03:54,709
their Cloud Foundry footprint for their

00:03:52,459 --> 00:03:57,280
customers using the Cloud Foundry Java

00:03:54,709 --> 00:03:59,510
client the problem ends up being that

00:03:57,280 --> 00:04:02,090
when people first started trying to do

00:03:59,510 --> 00:04:04,100
this orchestration just making rest call

00:04:02,090 --> 00:04:05,690
response rest call response and knowing

00:04:04,100 --> 00:04:07,940
which of the five hundred and fifty

00:04:05,690 --> 00:04:09,680
different api's to call and what the

00:04:07,940 --> 00:04:11,540
payloads are supposed to be was really

00:04:09,680 --> 00:04:14,090
really problematic that kind of generic

00:04:11,540 --> 00:04:15,890
access something like this where you

00:04:14,090 --> 00:04:17,419
might have a map of string object and

00:04:15,890 --> 00:04:20,600
you need to pass a bunch of stuff and

00:04:17,419 --> 00:04:22,310
make this particular request really

00:04:20,600 --> 00:04:23,570
really problematic to know that you got

00:04:22,310 --> 00:04:26,060
a right to be able to test it

00:04:23,570 --> 00:04:27,710
extensively so what we wanted to do

00:04:26,060 --> 00:04:29,630
right a Java client on top of it

00:04:27,710 --> 00:04:31,580
effectively a language binding that

00:04:29,630 --> 00:04:33,440
makes things much more strongly typed

00:04:31,580 --> 00:04:35,990
much more obvious exactly what's going

00:04:33,440 --> 00:04:37,160
on so now you know what name should be

00:04:35,990 --> 00:04:38,540
you don't even need to know what the

00:04:37,160 --> 00:04:40,850
payload key is we'll take care of that

00:04:38,540 --> 00:04:43,340
for you but you write code that is much

00:04:40,850 --> 00:04:44,750
much more understandable and you can do

00:04:43,340 --> 00:04:46,280
things with it that's a little bit

00:04:44,750 --> 00:04:48,410
clearer to read I want to push this

00:04:46,280 --> 00:04:50,240
particular application located here name

00:04:48,410 --> 00:04:51,830
this thing using this build pack and I

00:04:50,240 --> 00:04:55,610
want to map that response back getting

00:04:51,830 --> 00:04:57,110
its ID so that I can do something so we

00:04:55,610 --> 00:04:58,940
knew that we wanted to write a language

00:04:57,110 --> 00:05:00,830
binding for this kind of thing but we

00:04:58,940 --> 00:05:02,780
were still toying around with what it

00:05:00,830 --> 00:05:04,310
meant like what that API needs to look

00:05:02,780 --> 00:05:07,280
like and it turned out that the high

00:05:04,310 --> 00:05:09,169
latency network interaction is a really

00:05:07,280 --> 00:05:10,340
really good fit for reactive design

00:05:09,169 --> 00:05:13,880
there are a number of places that

00:05:10,340 --> 00:05:16,610
reactive design works really well but as

00:05:13,880 --> 00:05:18,320
a sort of first rule of thumb if you go

00:05:16,610 --> 00:05:20,810
over Network you really really want to

00:05:18,320 --> 00:05:23,060
use reactive programming simply because

00:05:20,810 --> 00:05:25,370
it allows you to write asynchronous

00:05:23,060 --> 00:05:28,669
non-blocking kind of operations really

00:05:25,370 --> 00:05:30,289
really simple so we partnered with

00:05:28,669 --> 00:05:32,000
something that came out of the spring

00:05:30,289 --> 00:05:34,010
team called project reactor really early

00:05:32,000 --> 00:05:35,630
on we drove their design they drove our

00:05:34,010 --> 00:05:39,380
design and we came out with something

00:05:35,630 --> 00:05:42,080
that we think is really really good so

00:05:39,380 --> 00:05:45,440
what does it mean as I said when should

00:05:42,080 --> 00:05:47,360
we use reactive so networking is always

00:05:45,440 --> 00:05:49,729
a really really good example of a place

00:05:47,360 --> 00:05:52,070
to use reactive programming because it

00:05:49,729 --> 00:05:54,140
has certain features things like high

00:05:52,070 --> 00:05:56,660
latency if you take a look at sort of

00:05:54,140 --> 00:05:58,970
imperative programming whether it's the

00:05:56,660 --> 00:06:02,600
servlet model or even something like

00:05:58,970 --> 00:06:04,639
Springs HTTP client what you end up with

00:06:02,600 --> 00:06:06,440
is a network request goes out but it

00:06:04,639 --> 00:06:09,919
holds open a thread there is this

00:06:06,440 --> 00:06:12,500
binding from one thread to one one

00:06:09,919 --> 00:06:13,910
request and threads are really expensive

00:06:12,500 --> 00:06:16,370
I mean they're lighter weight than

00:06:13,910 --> 00:06:18,470
processes obviously but there is a very

00:06:16,370 --> 00:06:21,289
small finite number of threads that a

00:06:18,470 --> 00:06:22,910
JVM can feasibly keep maybe it's 200

00:06:21,289 --> 00:06:24,350
maybe it's 2,000 right it doesn't matter

00:06:22,910 --> 00:06:26,120
really what the number is but

00:06:24,350 --> 00:06:28,550
effectively if you hold one of these

00:06:26,120 --> 00:06:30,889
very scarce resources for an extended

00:06:28,550 --> 00:06:32,810
period of time just blocking waiting for

00:06:30,889 --> 00:06:35,960
something to come back you are wasting

00:06:32,810 --> 00:06:37,760
it in a very bad way we also see going

00:06:35,960 --> 00:06:39,950
across network things like failures

00:06:37,760 --> 00:06:42,410
intermittent Network failures and

00:06:39,950 --> 00:06:44,360
what it means when the server on the

00:06:42,410 --> 00:06:46,280
other side starts sending you a huge

00:06:44,360 --> 00:06:49,820
amount of data way more data that then

00:06:46,280 --> 00:06:52,100
you can actually process all of these

00:06:49,820 --> 00:06:54,200
things are really good indicators that

00:06:52,100 --> 00:06:56,660
reactive programming is good for going

00:06:54,200 --> 00:06:58,040
over the network we also have anything

00:06:56,660 --> 00:06:59,630
that requires highly concurrent

00:06:58,040 --> 00:07:01,760
operations so if you have something that

00:06:59,630 --> 00:07:03,350
can be sort of scattered gathered very

00:07:01,760 --> 00:07:05,900
broadly that's really good

00:07:03,350 --> 00:07:08,960
so a good example of this was someone

00:07:05,900 --> 00:07:12,350
asked and the Java client github issues

00:07:08,960 --> 00:07:15,170
the other day how would I enumerate the

00:07:12,350 --> 00:07:17,090
tuple or namespace name application name

00:07:15,170 --> 00:07:19,190
for everything on my entire platform

00:07:17,090 --> 00:07:21,290
right and you can imagine platforms

00:07:19,190 --> 00:07:22,640
having thousands of orgs and tens of

00:07:21,290 --> 00:07:24,200
thousands of applications and things

00:07:22,640 --> 00:07:25,130
like that if you tried to do something

00:07:24,200 --> 00:07:26,870
like this

00:07:25,130 --> 00:07:29,750
sequentially or even if you tried to

00:07:26,870 --> 00:07:31,220
coordinate it directly yourself using

00:07:29,750 --> 00:07:32,840
you know fork/join or something like

00:07:31,220 --> 00:07:35,900
that in Java and imperative programming

00:07:32,840 --> 00:07:37,460
those api's aren't great right and so

00:07:35,900 --> 00:07:39,410
reactive programming gives you a way to

00:07:37,460 --> 00:07:41,300
sort of declaratively say I want these

00:07:39,410 --> 00:07:43,460
things to happen sequentially and I want

00:07:41,300 --> 00:07:45,440
these things to happen parallel E and I

00:07:43,460 --> 00:07:47,780
can stack them together right so I want

00:07:45,440 --> 00:07:49,280
to I need to enumerate all of I need to

00:07:47,780 --> 00:07:50,630
enumerate an org before I can enumerate

00:07:49,280 --> 00:07:52,610
at spaces before I can do its

00:07:50,630 --> 00:07:53,990
applications but once I'm inside of an

00:07:52,610 --> 00:07:56,120
org I can enumerate all of its

00:07:53,990 --> 00:07:58,220
applicator spaces in parallel on each

00:07:56,120 --> 00:08:00,110
one of those spaces all of their

00:07:58,220 --> 00:08:01,660
applications in parallel as well and you

00:08:00,110 --> 00:08:03,950
never have to manage that

00:08:01,660 --> 00:08:05,840
multi-threading that concurrency the

00:08:03,950 --> 00:08:08,480
framework the reactive framework takes

00:08:05,840 --> 00:08:11,000
care of it for you and then finally we

00:08:08,480 --> 00:08:12,860
talked about scalability scalability

00:08:11,000 --> 00:08:14,420
anything that you need to handle a huge

00:08:12,860 --> 00:08:16,180
amount of data or a huge number of

00:08:14,420 --> 00:08:18,590
connections or a huge amount of load

00:08:16,180 --> 00:08:21,350
reactive programming by its very nature

00:08:18,590 --> 00:08:23,210
of not doing blocking and doing things

00:08:21,350 --> 00:08:27,890
asynchronously is another place that

00:08:23,210 --> 00:08:30,290
it's a really really good fit so we're

00:08:27,890 --> 00:08:32,060
gonna talk a little bit about the API

00:08:30,290 --> 00:08:34,580
that we designed is based on as I said

00:08:32,060 --> 00:08:36,380
project reactor and so the tights that

00:08:34,580 --> 00:08:37,820
you're going to see in here are going to

00:08:36,380 --> 00:08:40,040
be reactor types something called flux

00:08:37,820 --> 00:08:41,960
and mono but everything that we talked

00:08:40,040 --> 00:08:43,490
about here is effectively in all

00:08:41,960 --> 00:08:45,770
reactive framework so if you're using

00:08:43,490 --> 00:08:47,890
something like rx Java or vertex or

00:08:45,770 --> 00:08:50,030
something like that all of the concepts

00:08:47,890 --> 00:08:52,260
translate over we just happen to use

00:08:50,030 --> 00:08:56,640
this set of this set of names

00:08:52,260 --> 00:08:58,680
so reactive ap is the first fundamental

00:08:56,640 --> 00:09:00,900
difference of a reactive API from a

00:08:58,680 --> 00:09:04,080
normal imperative API is that a reactive

00:09:00,900 --> 00:09:06,180
API always returns something right it's

00:09:04,080 --> 00:09:08,820
basically a what we would call a flow of

00:09:06,180 --> 00:09:11,190
values of some kind and there are two

00:09:08,820 --> 00:09:12,930
major variants in truth there's really

00:09:11,190 --> 00:09:15,180
only one there's this concept of a flux

00:09:12,930 --> 00:09:17,550
0 to n values are going to be returned

00:09:15,180 --> 00:09:18,840
we also specialize it turns out it's

00:09:17,550 --> 00:09:21,330
really useful to know if it's going to

00:09:18,840 --> 00:09:24,090
be 0 or 1 versus 0 to N and so we have a

00:09:21,330 --> 00:09:26,210
specialization of flux called a mono so

00:09:24,090 --> 00:09:29,400
we're gonna see in examples like this

00:09:26,210 --> 00:09:31,740
something like this if I want to list a

00:09:29,400 --> 00:09:34,530
set of applications listing that set

00:09:31,740 --> 00:09:37,380
returns me a flux of those applications

00:09:34,530 --> 00:09:39,000
right so I can list and then I can take

00:09:37,380 --> 00:09:40,350
that list of all those applications and

00:09:39,000 --> 00:09:42,240
I can map something out of it so

00:09:40,350 --> 00:09:44,700
effectively what this says is for each

00:09:42,240 --> 00:09:46,740
application flowing through that flux I

00:09:44,700 --> 00:09:48,360
want to get its name and then at the

00:09:46,740 --> 00:09:50,400
bottom we see where we subscribe I want

00:09:48,360 --> 00:09:52,590
to print that particular name out so you

00:09:50,400 --> 00:09:55,380
start seeing this composability where at

00:09:52,590 --> 00:09:58,470
any given line any given operation

00:09:55,380 --> 00:10:00,390
behaves on one single element flowing

00:09:58,470 --> 00:10:01,800
through in the end

00:10:00,390 --> 00:10:03,360
all of the elements will flow through

00:10:01,800 --> 00:10:04,470
and each one of them will get its name

00:10:03,360 --> 00:10:06,630
and each one of them will we print it

00:10:04,470 --> 00:10:08,400
out but one of the key differences

00:10:06,630 --> 00:10:11,010
between sort of imperative programming

00:10:08,400 --> 00:10:12,720
and reactive programming is this idea

00:10:11,010 --> 00:10:14,670
that each one of these little atoms each

00:10:12,720 --> 00:10:19,500
one of these little operators behaves on

00:10:14,670 --> 00:10:22,140
a single element flowing through mono

00:10:19,500 --> 00:10:24,240
response works very similarly except it

00:10:22,140 --> 00:10:25,710
only does one and so we see listing

00:10:24,240 --> 00:10:27,270
applications again we get all the names

00:10:25,710 --> 00:10:28,800
but you'll notice the next thing we do

00:10:27,270 --> 00:10:30,750
is we collect all of those names as a

00:10:28,800 --> 00:10:33,060
list we wait until every single element

00:10:30,750 --> 00:10:35,940
has come through that flux put them all

00:10:33,060 --> 00:10:38,610
as a list and now I have a mono that

00:10:35,940 --> 00:10:40,620
just contains a list which I make check

00:10:38,610 --> 00:10:42,930
does an application name exist in that

00:10:40,620 --> 00:10:45,000
list itself right so it works very

00:10:42,930 --> 00:10:46,410
similarly and that data is flowing

00:10:45,000 --> 00:10:48,060
through but in the mono the big

00:10:46,410 --> 00:10:50,460
difference is only a single piece of

00:10:48,060 --> 00:10:53,640
data and what you'll see certainly

00:10:50,460 --> 00:10:55,500
inside the the java client api is it's

00:10:53,640 --> 00:10:57,630
very very common to sort of have a

00:10:55,500 --> 00:11:00,000
stream of stuff that gets collected into

00:10:57,630 --> 00:11:02,310
the list and then that list is then

00:11:00,000 --> 00:11:03,870
inside of a mono that is the one thing

00:11:02,310 --> 00:11:06,180
that flows through because something

00:11:03,870 --> 00:11:08,459
like testing whether or not

00:11:06,180 --> 00:11:10,410
a name exists an application name is

00:11:08,459 --> 00:11:12,240
very difficult to do if it's just sort

00:11:10,410 --> 00:11:13,649
of data going by it's much much more

00:11:12,240 --> 00:11:15,930
efficient to just collect all those

00:11:13,649 --> 00:11:17,759
names and use a standard invocation name

00:11:15,930 --> 00:11:19,740
contains or something like that there

00:11:17,759 --> 00:11:22,559
are ways to do this without converting

00:11:19,740 --> 00:11:24,600
it but in a lot of cases actually having

00:11:22,559 --> 00:11:26,399
an entire list is the most efficient way

00:11:24,600 --> 00:11:30,300
to understand everything that's going

00:11:26,399 --> 00:11:32,699
through so as we said every method must

00:11:30,300 --> 00:11:34,740
return something void is not a valid

00:11:32,699 --> 00:11:37,379
return value when you're talking about

00:11:34,740 --> 00:11:40,220
reactive programming and the reason is

00:11:37,379 --> 00:11:43,399
because we take a look at code a

00:11:40,220 --> 00:11:46,920
reactive flow is basically a map of

00:11:43,399 --> 00:11:49,379
execution but it is not executed yet

00:11:46,920 --> 00:11:51,959
right so if we take a look at this

00:11:49,379 --> 00:11:53,910
imperative operation when I call delete

00:11:51,959 --> 00:11:55,470
passing in a string ID it executes this

00:11:53,910 --> 00:11:57,480
thing the rest template goes off it goes

00:11:55,470 --> 00:12:00,839
in delete something and when it returns

00:11:57,480 --> 00:12:02,249
that deletion has completed right so

00:12:00,839 --> 00:12:04,290
before it can get out of that delete

00:12:02,249 --> 00:12:06,540
method and get back into cleanup you can

00:12:04,290 --> 00:12:09,149
be sure that something has happened that

00:12:06,540 --> 00:12:11,670
an operation has been completed but in

00:12:09,149 --> 00:12:13,680
reactive programming this is not true so

00:12:11,670 --> 00:12:15,600
in this particular case when you call

00:12:13,680 --> 00:12:19,350
delete it basically sets up a framework

00:12:15,600 --> 00:12:22,079
that says when someone when someone is

00:12:19,350 --> 00:12:23,699
finally ready to execute then I will go

00:12:22,079 --> 00:12:26,730
delete something so that method returns

00:12:23,699 --> 00:12:29,819
instantly back to cleanup only on this

00:12:26,730 --> 00:12:31,980
SUBSCRIBE call here does the delete

00:12:29,819 --> 00:12:34,230
actually begin so subscribe basically

00:12:31,980 --> 00:12:35,759
means start and I want you to hand me

00:12:34,230 --> 00:12:37,860
some information in this particular case

00:12:35,759 --> 00:12:39,569
the use of mono void that you see up

00:12:37,860 --> 00:12:41,220
there is basically a shorthand way of

00:12:39,569 --> 00:12:43,019
saying just tell me when you're done I

00:12:41,220 --> 00:12:45,360
don't expect you to return anything but

00:12:43,019 --> 00:12:49,490
you do need to signal me that you are

00:12:45,360 --> 00:12:49,490
complete or that you have an error you

00:12:50,509 --> 00:12:56,819
know me no okay thanks very much Ben so

00:12:54,920 --> 00:12:57,990
we've looked at the details of Ben's

00:12:56,819 --> 00:12:59,699
going over now we're going to look at a

00:12:57,990 --> 00:13:03,269
little bit the implementation how we've

00:12:59,699 --> 00:13:04,790
been implementing stuff reactively so

00:13:03,269 --> 00:13:07,740
the first thing sequential and parallel

00:13:04,790 --> 00:13:10,470
coordination so as Ben's been saying

00:13:07,740 --> 00:13:14,790
there's a lot of benefit here in being

00:13:10,470 --> 00:13:16,139
able to paralyze things the project

00:13:14,790 --> 00:13:17,819
reactive people will tell you most

00:13:16,139 --> 00:13:18,840
vehemently that it is not about

00:13:17,819 --> 00:13:20,550
performance it's

00:13:18,840 --> 00:13:23,300
up managing loads and things like that

00:13:20,550 --> 00:13:25,380
but the fact is if you can paralyze

00:13:23,300 --> 00:13:27,210
dozens of calls that you would normally

00:13:25,380 --> 00:13:28,730
do sequentially then clearly there's

00:13:27,210 --> 00:13:30,360
going to be a performance benefit there

00:13:28,730 --> 00:13:31,890
unfortunately

00:13:30,360 --> 00:13:33,270
doing things concurrently can be very

00:13:31,890 --> 00:13:34,590
hard to do you've got to manage thread

00:13:33,270 --> 00:13:36,750
pools and all the other problems that

00:13:34,590 --> 00:13:38,160
Ben's mentioned fortunately something

00:13:36,750 --> 00:13:40,380
like Project reactor and various other

00:13:38,160 --> 00:13:41,820
frameworks that are available will allow

00:13:40,380 --> 00:13:44,490
you to define sequential and parallel

00:13:41,820 --> 00:13:47,490
operations and the relationships between

00:13:44,490 --> 00:13:49,350
them in a pretty simplistic way so that

00:13:47,490 --> 00:13:50,610
you can concentrate on the code that you

00:13:49,350 --> 00:13:52,470
need and you can leave it to the

00:13:50,610 --> 00:13:56,910
framework to do the hard lifting of

00:13:52,470 --> 00:13:58,530
managing those thread pools etc so if we

00:13:56,910 --> 00:14:00,930
take a look at a little example here

00:13:58,530 --> 00:14:03,750
this is about retrieving some lists

00:14:00,930 --> 00:14:05,850
application information we have the

00:14:03,750 --> 00:14:07,650
first method is a gap page and it all it

00:14:05,850 --> 00:14:09,660
does is make a call and say give me a

00:14:07,650 --> 00:14:12,480
page defined by the page number that

00:14:09,660 --> 00:14:14,730
we've given it so internee that we have

00:14:12,480 --> 00:14:16,680
the main method that starts very simply

00:14:14,730 --> 00:14:18,240
it says give me the first page and when

00:14:16,680 --> 00:14:20,670
it gets that first page back there's a

00:14:18,240 --> 00:14:22,410
bunch of resources on there but there's

00:14:20,670 --> 00:14:24,360
also information about the payload that

00:14:22,410 --> 00:14:26,670
we're requesting one of the information

00:14:24,360 --> 00:14:28,830
items on that payload is the total

00:14:26,670 --> 00:14:31,440
number of pages so it could be 210

00:14:28,830 --> 00:14:32,550
whatever so what we're going to do is

00:14:31,440 --> 00:14:35,160
we're going to extract that information

00:14:32,550 --> 00:14:37,860
out and we're going to have this thing

00:14:35,160 --> 00:14:40,980
of flux range so flux a bit like a

00:14:37,860 --> 00:14:43,770
stream in Java 8 it's going to say give

00:14:40,980 --> 00:14:46,410
me a list of numbers from 2 to whatever

00:14:43,770 --> 00:14:48,150
the total number of pages and for each

00:14:46,410 --> 00:14:51,690
of those numbers I'm going to do a

00:14:48,150 --> 00:14:53,640
request to get page so that flat map

00:14:51,690 --> 00:14:56,760
says I want you to do all of those at

00:14:53,640 --> 00:15:00,720
the same time so we all do get page for

00:14:56,760 --> 00:15:02,280
page to get page for page 3 and so on it

00:15:00,720 --> 00:15:04,050
will make all of those requests it will

00:15:02,280 --> 00:15:05,370
put them together with the that start

00:15:04,050 --> 00:15:07,040
with there just says don't forget about

00:15:05,370 --> 00:15:09,450
the first page that we've already got

00:15:07,040 --> 00:15:12,180
and it will put all of that information

00:15:09,450 --> 00:15:14,190
together and well in this case this out

00:15:12,180 --> 00:15:15,110
obviously not terribly useful but a good

00:15:14,190 --> 00:15:17,760
example

00:15:15,110 --> 00:15:19,590
so the key thing there is we started

00:15:17,760 --> 00:15:21,240
with a single operation and then

00:15:19,590 --> 00:15:23,430
everything else every other request from

00:15:21,240 --> 00:15:27,600
there happened in parallel big

00:15:23,430 --> 00:15:29,130
performance gain potentially so as well

00:15:27,600 --> 00:15:31,470
as just defining simple flows like that

00:15:29,130 --> 00:15:32,400
we can do various sorts of conditional

00:15:31,470 --> 00:15:33,480
logic

00:15:32,400 --> 00:15:35,400
won't surprise you to hear that we can

00:15:33,480 --> 00:15:37,470
do the standard things and branching and

00:15:35,400 --> 00:15:39,600
so on but there are a couple of them

00:15:37,470 --> 00:15:42,330
slightly more unusual things that we can

00:15:39,600 --> 00:15:44,400
do as well one of those is to we first

00:15:42,330 --> 00:15:46,200
need to understand that in reactive

00:15:44,400 --> 00:15:47,760
programming an error is just a value

00:15:46,200 --> 00:15:51,240
that can be passed on the same as any

00:15:47,760 --> 00:15:53,370
other value that means that we can pass

00:15:51,240 --> 00:15:54,600
it on to the consumer if it's something

00:15:53,370 --> 00:15:57,510
that we don't particularly know about we

00:15:54,600 --> 00:15:59,400
can just say here this error happened we

00:15:57,510 --> 00:16:01,080
can change behavior we can generate new

00:15:59,400 --> 00:16:02,280
values based on that error as well

00:16:01,080 --> 00:16:06,210
potentially if it's something that we're

00:16:02,280 --> 00:16:08,070
expecting to see so if we look at this

00:16:06,210 --> 00:16:10,530
example we're going to do an application

00:16:08,070 --> 00:16:11,790
statistics request so we want to for a

00:16:10,530 --> 00:16:14,900
particular application we want to know

00:16:11,790 --> 00:16:17,250
its uptime memory usage things like that

00:16:14,900 --> 00:16:19,800
in the normal run of things we give it

00:16:17,250 --> 00:16:22,410
the application request and we say based

00:16:19,800 --> 00:16:24,120
on this ID retrieve this information for

00:16:22,410 --> 00:16:25,530
me it will go and take a look and say

00:16:24,120 --> 00:16:26,300
here you go here's the information

00:16:25,530 --> 00:16:30,360
you're after

00:16:26,300 --> 00:16:32,100
uptime etc but we may get an error back

00:16:30,360 --> 00:16:33,960
and one of the area's errors that we

00:16:32,100 --> 00:16:36,300
could get back is an application stopped

00:16:33,960 --> 00:16:37,830
error and what that says is there's

00:16:36,300 --> 00:16:39,660
nothing wrong everything's working fine

00:16:37,830 --> 00:16:41,310
is just that the application is stopped

00:16:39,660 --> 00:16:45,060
because it hasn't been started for some

00:16:41,310 --> 00:16:47,250
reason so in that case we do a non error

00:16:45,060 --> 00:16:48,750
resume so we've got an error but we

00:16:47,250 --> 00:16:51,690
don't want to stop we want to resume we

00:16:48,750 --> 00:16:53,010
want to continue processing and in this

00:16:51,690 --> 00:16:55,650
case we're going to return an empty

00:16:53,010 --> 00:16:57,300
object that says I checked there was no

00:16:55,650 --> 00:17:00,180
information but you can carry on

00:16:57,300 --> 00:17:02,310
normally and use that information what

00:17:00,180 --> 00:17:04,500
it doesn't do it's not a a catch-all for

00:17:02,310 --> 00:17:07,020
errors so we've specified that it's an

00:17:04,500 --> 00:17:08,459
application stopped error if anything

00:17:07,020 --> 00:17:09,570
else comes up then somebody else is

00:17:08,459 --> 00:17:10,070
going to have to handle that we'll pass

00:17:09,570 --> 00:17:15,720
it on

00:17:10,070 --> 00:17:17,940
however we decide to process it as been

00:17:15,720 --> 00:17:19,680
mentioned earlier not everything will

00:17:17,940 --> 00:17:21,810
return a particular value sometimes it

00:17:19,680 --> 00:17:23,280
will just return a complete to say I did

00:17:21,810 --> 00:17:27,240
the thing you asked me to do and now I'm

00:17:23,280 --> 00:17:28,320
done and we can use those indicators in

00:17:27,240 --> 00:17:31,320
the same way that we were using the

00:17:28,320 --> 00:17:34,620
errors we can again use logic from them

00:17:31,320 --> 00:17:38,310
we can pass them straight on as just

00:17:34,620 --> 00:17:40,080
here's the value that came out so if we

00:17:38,310 --> 00:17:42,060
take a look at an example of that with

00:17:40,080 --> 00:17:44,850
this empty logic something that may be

00:17:42,060 --> 00:17:46,399
familiar to you if we're trying to find

00:17:44,850 --> 00:17:48,509
a domain based on it

00:17:46,399 --> 00:17:50,669
we don't necessarily know if it's a

00:17:48,509 --> 00:17:53,759
private domain or shared domain so we

00:17:50,669 --> 00:17:55,289
have to check both both places so we

00:17:53,759 --> 00:17:58,889
start here by saying get the private

00:17:55,289 --> 00:18:00,419
donate domain ID based on a name and it

00:17:58,889 --> 00:18:02,779
may return the value and in which case

00:18:00,419 --> 00:18:05,700
we'll pass that on as a string is the ID

00:18:02,779 --> 00:18:07,830
if we don't get a result from that if we

00:18:05,700 --> 00:18:09,629
get an empty that says I checked and

00:18:07,830 --> 00:18:11,879
there was nothing there then we switch

00:18:09,629 --> 00:18:14,070
based on that empty and we go and check

00:18:11,879 --> 00:18:16,350
the shared domains and we do a query and

00:18:14,070 --> 00:18:17,820
we get back a result and again we may

00:18:16,350 --> 00:18:21,899
get a positive result we'll pass back

00:18:17,820 --> 00:18:23,519
the ID but it may come back again saying

00:18:21,899 --> 00:18:25,559
I checked I still don't have anything

00:18:23,519 --> 00:18:26,970
for you in which case we now have a

00:18:25,559 --> 00:18:28,590
problem because we've checked shared

00:18:26,970 --> 00:18:29,759
domains we check private domains we

00:18:28,590 --> 00:18:31,830
don't know this name that you've given

00:18:29,759 --> 00:18:34,049
us and in that scenario we've got an

00:18:31,830 --> 00:18:36,149
error and we will report that as an

00:18:34,049 --> 00:18:38,700
illegal state exception so you can see

00:18:36,149 --> 00:18:40,440
here we've changed logic based on

00:18:38,700 --> 00:18:41,669
whether we got to return back and then

00:18:40,440 --> 00:18:44,039
eventually we've actually changed the

00:18:41,669 --> 00:18:48,749
return type or the return value by

00:18:44,039 --> 00:18:51,269
generating an error okay that's a little

00:18:48,749 --> 00:18:52,799
bit about processing now we've got some

00:18:51,269 --> 00:18:55,980
testing which I'm sure you'll all be

00:18:52,799 --> 00:18:57,450
wanting to do and one of the problems we

00:18:55,980 --> 00:18:58,980
face when we're testing is that most

00:18:57,450 --> 00:19:00,090
useful flows will be asynchronous that's

00:18:58,980 --> 00:19:02,309
what we're about we're trying to use

00:19:00,090 --> 00:19:03,480
this asynchronicity to speed things up

00:19:02,309 --> 00:19:04,279
to make more efficient use of our

00:19:03,480 --> 00:19:07,049
resources

00:19:04,279 --> 00:19:08,700
unfortunately in this scenario most

00:19:07,049 --> 00:19:11,129
testing frameworks are aggressively

00:19:08,700 --> 00:19:14,429
synchronous so they run the test and

00:19:11,129 --> 00:19:17,159
shut down as soon as possible and that

00:19:14,429 --> 00:19:18,480
gives us a problem because we are

00:19:17,159 --> 00:19:20,850
waiting for something to happen

00:19:18,480 --> 00:19:23,489
asynchronously that the test will not

00:19:20,850 --> 00:19:25,080
wait for so what we need to do is to

00:19:23,489 --> 00:19:26,730
block the main thread and make test

00:19:25,080 --> 00:19:28,499
assertions in the asynchronous thread

00:19:26,730 --> 00:19:31,739
and we've got a little example of that

00:19:28,499 --> 00:19:34,769
here so I'm going to generate a single

00:19:31,739 --> 00:19:36,509
value alpha just one value I'm going to

00:19:34,769 --> 00:19:39,049
subscribe to it and then I'm going to

00:19:36,509 --> 00:19:42,179
assert that the value I get equals Bravo

00:19:39,049 --> 00:19:45,059
now fairly clearly that should fail and

00:19:42,179 --> 00:19:47,279
sure enough when I run it it's actually

00:19:45,059 --> 00:19:50,309
passed and the reason it's passed is

00:19:47,279 --> 00:19:52,619
because the processing that did the

00:19:50,309 --> 00:19:55,440
assert equals happened on a secondary

00:19:52,619 --> 00:19:58,129
thread but whilst that was off doing its

00:19:55,440 --> 00:20:00,120
thing the test looked for completion

00:19:58,129 --> 00:20:01,530
didn't see any failure because

00:20:00,120 --> 00:20:03,900
the assertequals didn't generate

00:20:01,530 --> 00:20:06,030
anything on the main thread completed

00:20:03,900 --> 00:20:08,270
and as far as its concerned everything's

00:20:06,030 --> 00:20:08,270
passed

00:20:08,480 --> 00:20:12,240
fortunately project reactor gives us a

00:20:10,470 --> 00:20:13,940
way of dealing with this and that's to

00:20:12,240 --> 00:20:16,260
use something called the step verifier

00:20:13,940 --> 00:20:17,850
the step verifier has a number of other

00:20:16,260 --> 00:20:20,370
benefits as well as just handling that

00:20:17,850 --> 00:20:21,780
blocking which would be enough it allows

00:20:20,370 --> 00:20:24,270
us to do things like multiple value

00:20:21,780 --> 00:20:25,980
assertions expected error assertions

00:20:24,270 --> 00:20:27,390
unexpected errors if there's something

00:20:25,980 --> 00:20:31,500
that we didn't actually know was coming

00:20:27,390 --> 00:20:32,910
back we can still handle it so if we

00:20:31,500 --> 00:20:35,790
look at an example of just one of those

00:20:32,910 --> 00:20:37,020
things the multiple values we're

00:20:35,790 --> 00:20:39,890
generating a flux here so we're gonna

00:20:37,020 --> 00:20:42,960
have two values emitted alpha and Bravo

00:20:39,890 --> 00:20:45,660
we subscribe to it using a step verifier

00:20:42,960 --> 00:20:48,270
and then we're going to say we're

00:20:45,660 --> 00:20:49,770
asserting in fact three things we expect

00:20:48,270 --> 00:20:52,650
that an alpha will come out and the

00:20:49,770 --> 00:20:54,240
Alpha will be first we expect that Bravo

00:20:52,650 --> 00:20:56,160
will come out and that will be second

00:20:54,240 --> 00:20:58,080
and then the third thing we're saying is

00:20:56,160 --> 00:21:00,030
that that's all that we will get back so

00:20:58,080 --> 00:21:02,730
the next signal that we get is an expect

00:21:00,030 --> 00:21:04,500
complete give it to duration of five

00:21:02,730 --> 00:21:06,780
seconds because this is asynchronous

00:21:04,500 --> 00:21:08,040
which means we don't know how long it's

00:21:06,780 --> 00:21:10,530
going to take but we know we don't want

00:21:08,040 --> 00:21:14,850
to wait forever and I don't have a slide

00:21:10,530 --> 00:21:17,190
to prove it but trust me that works okay

00:21:14,850 --> 00:21:18,660
so that's implementation now here's a

00:21:17,190 --> 00:21:20,520
little bit about how we've been using it

00:21:18,660 --> 00:21:23,850
and how we expect other people to use it

00:21:20,520 --> 00:21:27,330
as well one of the big problems that we

00:21:23,850 --> 00:21:29,400
see a lot of people facing is that the

00:21:27,330 --> 00:21:30,960
reactive framework can only coordinate

00:21:29,400 --> 00:21:33,180
its own operation it doesn't know about

00:21:30,960 --> 00:21:35,640
the environment around it so whilst it's

00:21:33,180 --> 00:21:37,230
managing its own threads etc what's

00:21:35,640 --> 00:21:39,180
happening underneath is not visible to

00:21:37,230 --> 00:21:40,680
it now a lot of the time that doesn't

00:21:39,180 --> 00:21:42,740
matter if you're running in a servlet

00:21:40,680 --> 00:21:45,540
container for example it's effectively

00:21:42,740 --> 00:21:46,740
long-lived and the reactive framework

00:21:45,540 --> 00:21:50,160
doesn't care what's going on

00:21:46,740 --> 00:21:52,980
but there are situations where it can

00:21:50,160 --> 00:21:54,420
cause problems an obvious one of that in

00:21:52,980 --> 00:21:56,130
addition to the testing we just looked

00:21:54,420 --> 00:21:57,720
at is if you're running in a main method

00:21:56,130 --> 00:22:01,920
which will try to complete as soon as

00:21:57,720 --> 00:22:04,590
possible so if we have a look at that

00:22:01,920 --> 00:22:06,780
happening and what goes wrong I'm going

00:22:04,590 --> 00:22:08,310
to omit a single value here alpha I'm

00:22:06,780 --> 00:22:09,780
going to delay the subscription so I'm

00:22:08,310 --> 00:22:11,419
gonna wait for a second so if there is a

00:22:09,780 --> 00:22:13,830
problem here with

00:22:11,419 --> 00:22:16,620
concurrency and a synchronicity then we

00:22:13,830 --> 00:22:18,990
will find out about it we subscribe and

00:22:16,620 --> 00:22:23,190
we're going to try and sit out the value

00:22:18,990 --> 00:22:24,660
that we get back and when we run that it

00:22:23,190 --> 00:22:26,789
will run to completion because there's

00:22:24,660 --> 00:22:28,169
no problem with running yet but when we

00:22:26,789 --> 00:22:30,090
look at the values that come out we see

00:22:28,169 --> 00:22:32,660
that there aren't any values because the

00:22:30,090 --> 00:22:35,010
main thread completed before the

00:22:32,660 --> 00:22:38,850
subscription which was delayed actually

00:22:35,010 --> 00:22:42,750
got to do anything the way we handle

00:22:38,850 --> 00:22:44,700
that is Yunus using a countdown latch so

00:22:42,750 --> 00:22:46,380
what we're going to say is I will set up

00:22:44,700 --> 00:22:48,000
this precondition that needs to be

00:22:46,380 --> 00:22:50,490
satisfied before the main method can

00:22:48,000 --> 00:22:52,470
complete and I do that by creating a new

00:22:50,490 --> 00:22:55,740
countdown latch with just a single flag

00:22:52,470 --> 00:22:56,970
on it again the code is pretty much the

00:22:55,740 --> 00:23:00,330
same I emit an alpha

00:22:56,970 --> 00:23:02,280
I am wait for a second I subscribe and

00:23:00,330 --> 00:23:03,900
you can see I've got some parameters

00:23:02,280 --> 00:23:05,190
inside that subscribe I'll explain what

00:23:03,900 --> 00:23:08,130
they are in a moment but the key thing

00:23:05,190 --> 00:23:10,850
here is that they count down the latch

00:23:08,130 --> 00:23:16,049
they release the latch in this case and

00:23:10,850 --> 00:23:17,940
when I run that I wait for the latch and

00:23:16,049 --> 00:23:19,440
what happens is it executes again

00:23:17,940 --> 00:23:20,850
because still nothing's gone wrong but

00:23:19,440 --> 00:23:26,400
this time it's actually waiting for the

00:23:20,850 --> 00:23:28,070
Alpha to be emitted so as I said we've

00:23:26,400 --> 00:23:30,630
got some additional parameters in there

00:23:28,070 --> 00:23:31,890
they are letters define the behavior

00:23:30,630 --> 00:23:33,900
that we're going to have in particular

00:23:31,890 --> 00:23:36,270
scenarios one of which is error handling

00:23:33,900 --> 00:23:38,370
as I've said before errors will just go

00:23:36,270 --> 00:23:40,020
through naturally until somebody catches

00:23:38,370 --> 00:23:44,580
them so we need to be able to handle

00:23:40,020 --> 00:23:46,169
those things so if we take a look again

00:23:44,580 --> 00:23:48,150
a very similar piece of code we're

00:23:46,169 --> 00:23:49,830
setting up a countdown latch again this

00:23:48,150 --> 00:23:51,659
time we're going to have a flux and it's

00:23:49,830 --> 00:23:53,039
going to have two items in it first one

00:23:51,659 --> 00:23:55,320
is just a simple string and that will

00:23:53,039 --> 00:23:57,210
work just fine but the second item is an

00:23:55,320 --> 00:23:59,700
illegal State exception so we know that

00:23:57,210 --> 00:24:01,470
this is going to throw an error we

00:23:59,700 --> 00:24:04,110
subscribe to it and then we have three

00:24:01,470 --> 00:24:06,630
parameters inside that subscribe the

00:24:04,110 --> 00:24:08,100
first one is on next which just says the

00:24:06,630 --> 00:24:10,409
next time I get something that comes in

00:24:08,100 --> 00:24:12,570
do this and that's the normal operation

00:24:10,409 --> 00:24:15,539
if you like and in this case we will sit

00:24:12,570 --> 00:24:18,270
out the second one is what happens in

00:24:15,539 --> 00:24:19,770
case of on error and in that scenario we

00:24:18,270 --> 00:24:21,870
want to do something we want to handle

00:24:19,770 --> 00:24:22,980
the error in some way here we just print

00:24:21,870 --> 00:24:25,330
out the stack trace pretty

00:24:22,980 --> 00:24:27,160
straightforward but we also want to make

00:24:25,330 --> 00:24:29,050
sure that because we've had an error and

00:24:27,160 --> 00:24:31,210
this is a terminal condition if you like

00:24:29,050 --> 00:24:34,080
that we need to count down the latch we

00:24:31,210 --> 00:24:38,050
need to say this processing is complete

00:24:34,080 --> 00:24:39,400
the final parameter there is uncomplete

00:24:38,050 --> 00:24:40,900
so if everything has completed

00:24:39,400 --> 00:24:43,600
successfully we've had however many

00:24:40,900 --> 00:24:46,900
things emitted and now the flux says I'm

00:24:43,600 --> 00:24:48,220
closed then we still need we could do

00:24:46,900 --> 00:24:50,140
some other processing as well but we

00:24:48,220 --> 00:24:53,620
still need to release that latch to say

00:24:50,140 --> 00:24:55,180
this process is now completed we do the

00:24:53,620 --> 00:25:01,330
latch wait and again that will execute

00:24:55,180 --> 00:25:04,360
correctly just going back to that

00:25:01,330 --> 00:25:06,100
actually this is one of the two biggest

00:25:04,360 --> 00:25:07,990
problems that we see people having when

00:25:06,100 --> 00:25:10,690
the using reactive not just to do with

00:25:07,990 --> 00:25:12,220
our code but anytime that you've written

00:25:10,690 --> 00:25:14,800
code that you think is great and it

00:25:12,220 --> 00:25:15,910
produces nothing because everything

00:25:14,800 --> 00:25:18,640
that's happening is off on a different

00:25:15,910 --> 00:25:20,740
thread and you don't see it so if you

00:25:18,640 --> 00:25:21,940
start using reactor and you don't get

00:25:20,740 --> 00:25:23,890
the results out that you're expecting

00:25:21,940 --> 00:25:25,660
yet first thing to think of is can down

00:25:23,890 --> 00:25:28,960
match it's not necessarily the solution

00:25:25,660 --> 00:25:30,730
but it's a good place to start one final

00:25:28,960 --> 00:25:32,560
thing is point freestyle so you may have

00:25:30,730 --> 00:25:33,790
noticed from the code samples that and

00:25:32,560 --> 00:25:35,920
they're using something that might look

00:25:33,790 --> 00:25:37,270
a little bit in unintuitive if you're

00:25:35,920 --> 00:25:39,370
looking at it from an imperative point

00:25:37,270 --> 00:25:42,880
of view there's a link there to a point

00:25:39,370 --> 00:25:46,600
free style guide and the reasoning

00:25:42,880 --> 00:25:48,910
behind it and what we found is that it's

00:25:46,600 --> 00:25:50,290
kind of an intuitive at first and been

00:25:48,910 --> 00:25:52,690
certainly didn't like it when we got

00:25:50,290 --> 00:25:55,120
started but after a while you get used

00:25:52,690 --> 00:25:57,070
to the style and how it works and and it

00:25:55,120 --> 00:25:58,390
becomes more readable becomes more

00:25:57,070 --> 00:26:01,150
compact which helps with them

00:25:58,390 --> 00:26:02,770
understanding the flow so if you look at

00:26:01,150 --> 00:26:04,840
this slightly more complicated example

00:26:02,770 --> 00:26:06,910
I'm going to delete an application so

00:26:04,840 --> 00:26:08,890
I'm supplying a name and I've got two

00:26:06,910 --> 00:26:11,020
steps that it needs to take first of all

00:26:08,890 --> 00:26:13,300
it needs to look up the ID based on that

00:26:11,020 --> 00:26:15,690
name and then it needs to actually do

00:26:13,300 --> 00:26:18,280
the delete based with based on that ID

00:26:15,690 --> 00:26:20,170
so you can see that the first builder

00:26:18,280 --> 00:26:21,730
that I've got there I could construct

00:26:20,170 --> 00:26:23,590
that in advance I could set up a

00:26:21,730 --> 00:26:26,140
variable and just insert the variable

00:26:23,590 --> 00:26:29,620
name inside that but you can see that in

00:26:26,140 --> 00:26:31,360
the second builder I can't really do

00:26:29,620 --> 00:26:32,770
that in advance very easily because I

00:26:31,360 --> 00:26:36,100
don't know what the application ID is

00:26:32,770 --> 00:26:38,080
there are ways around it you can create

00:26:36,100 --> 00:26:39,120
an unbuilt builder if you like and then

00:26:38,080 --> 00:26:40,800
just complete

00:26:39,120 --> 00:26:42,900
and there are various other cheats you

00:26:40,800 --> 00:26:44,570
can do but we found that ultimately when

00:26:42,900 --> 00:26:47,160
you get used to it this style of

00:26:44,570 --> 00:26:49,560
effectively in lining everything is much

00:26:47,160 --> 00:26:52,110
more useful than in trying to stick with

00:26:49,560 --> 00:26:53,400
the old style of imperative code okay

00:26:52,110 --> 00:26:55,830
without I'm gonna hand over to Ben to

00:26:53,400 --> 00:26:57,810
wrap up yeah just to sort of build on

00:26:55,830 --> 00:26:59,550
this a little bit you do end up with

00:26:57,810 --> 00:27:03,720
much denser code than you might

00:26:59,550 --> 00:27:05,040
otherwise there are ways around that so

00:27:03,720 --> 00:27:06,750
if you ever took a look at the Java

00:27:05,040 --> 00:27:08,670
client code itself you'd see that we've

00:27:06,750 --> 00:27:10,230
never actually write a flow that was

00:27:08,670 --> 00:27:12,810
quite this dense it had this many lines

00:27:10,230 --> 00:27:16,110
when you you get a lot of reward from

00:27:12,810 --> 00:27:18,450
really extracting out methods and using

00:27:16,110 --> 00:27:21,780
the java method reference syntax so

00:27:18,450 --> 00:27:23,220
instead of this whole second sort of

00:27:21,780 --> 00:27:26,400
flat map here with application ID

00:27:23,220 --> 00:27:28,440
there'd be a method called was a get

00:27:26,400 --> 00:27:29,820
application ID or delete application or

00:27:28,440 --> 00:27:32,430
something like that

00:27:29,820 --> 00:27:34,170
that would take in just the application

00:27:32,430 --> 00:27:35,670
ID and so this would sort of collapse to

00:27:34,170 --> 00:27:37,350
become a one-liner and the same thing

00:27:35,670 --> 00:27:39,180
with the pagination utils and that whole

00:27:37,350 --> 00:27:40,860
thing that would you know have a list

00:27:39,180 --> 00:27:43,280
applications map that's absolutely

00:27:40,860 --> 00:27:45,810
compresses and so this realistically

00:27:43,280 --> 00:27:47,130
even using point freestyle collapses

00:27:45,810 --> 00:27:49,230
down to like two or three different

00:27:47,130 --> 00:27:51,180
lines and the key is that it ends up

00:27:49,230 --> 00:27:54,300
being much more readable whether like if

00:27:51,180 --> 00:27:56,430
you're taking a look at it even expanded

00:27:54,300 --> 00:27:58,320
like this I don't think anybody really

00:27:56,430 --> 00:28:00,120
thinks of having a bunch of assignment

00:27:58,320 --> 00:28:01,830
and equal signs and curly braces and

00:28:00,120 --> 00:28:03,900
stuff like that makes this any more

00:28:01,830 --> 00:28:05,910
understandable than if you sort of

00:28:03,900 --> 00:28:07,710
collapse the whole thing down into very

00:28:05,910 --> 00:28:09,590
small methods that have very clear names

00:28:07,710 --> 00:28:13,050
on it

00:28:09,590 --> 00:28:14,910
so with just a couple minutes left let's

00:28:13,050 --> 00:28:16,740
go ahead and take a look at a summary of

00:28:14,910 --> 00:28:18,480
this so we talked a little bit in the

00:28:16,740 --> 00:28:20,430
very beginning about how to design so

00:28:18,480 --> 00:28:23,190
when is it appropriate to use reactive

00:28:20,430 --> 00:28:25,020
programming the key the easiest one and

00:28:23,190 --> 00:28:26,490
probably the first place every single

00:28:25,020 --> 00:28:28,110
person is going to get involved in

00:28:26,490 --> 00:28:29,850
reactive programming if you choose to is

00:28:28,110 --> 00:28:32,670
if you're doing anything over the

00:28:29,850 --> 00:28:34,620
network the the sort of ability to do

00:28:32,670 --> 00:28:37,440
asynchronous non-blocking style

00:28:34,620 --> 00:28:39,450
programming inside of java is the key

00:28:37,440 --> 00:28:42,720
reason to start taking a look at

00:28:39,450 --> 00:28:45,150
reactive programming reactive methods

00:28:42,720 --> 00:28:46,920
must all methods and reactive api's must

00:28:45,150 --> 00:28:49,140
always return something void is not

00:28:46,920 --> 00:28:51,060
reasonable you always want to return

00:28:49,140 --> 00:28:51,380
mono and flux and as I just said you

00:28:51,060 --> 00:28:53,570
want

00:28:51,380 --> 00:28:54,770
have these very small reusable methods

00:28:53,570 --> 00:28:57,410
and you take a look at our code you'll

00:28:54,770 --> 00:28:59,570
see that a lot on the implementation

00:28:57,410 --> 00:29:01,880
side remember back at the very beginning

00:28:59,570 --> 00:29:04,400
I mentioned that one of the key value

00:29:01,880 --> 00:29:06,680
propositions of something like project

00:29:04,400 --> 00:29:08,600
reactor rx Java is this idea that you

00:29:06,680 --> 00:29:10,100
can declaratively say here are the

00:29:08,600 --> 00:29:11,360
things that need to happen sequentially

00:29:10,100 --> 00:29:13,130
here are the things that are allowed to

00:29:11,360 --> 00:29:14,960
happen in parallel with one another and

00:29:13,130 --> 00:29:16,460
you can look at it and read it and

00:29:14,960 --> 00:29:18,890
understand how these things are related

00:29:16,460 --> 00:29:20,690
to one another but someone else some

00:29:18,890 --> 00:29:22,520
other framework is responsible for doing

00:29:20,690 --> 00:29:24,160
that coordination in the most efficient

00:29:22,520 --> 00:29:26,150
way and if you take a look at reactor

00:29:24,160 --> 00:29:28,520
things that you think might have been

00:29:26,150 --> 00:29:29,870
parallelized aren't necessarily because

00:29:28,520 --> 00:29:32,360
it turns out that doing things in

00:29:29,870 --> 00:29:34,550
batches but doing them sequentially can

00:29:32,360 --> 00:29:37,010
actually outperform doing everything in

00:29:34,550 --> 00:29:38,870
parallel or everything in parallel at

00:29:37,010 --> 00:29:40,640
the exact same time and so you want

00:29:38,870 --> 00:29:42,080
someone else working at a different

00:29:40,640 --> 00:29:44,420
layer of abstraction working that out

00:29:42,080 --> 00:29:45,740
for you and you are simply saying here's

00:29:44,420 --> 00:29:48,380
what needs to be sequential and here's

00:29:45,740 --> 00:29:50,690
what's allowed to be parallel finally in

00:29:48,380 --> 00:29:52,910
the implementation testing is a really

00:29:50,690 --> 00:29:55,310
key thing but has a lot of caveats or a

00:29:52,910 --> 00:29:56,540
lot of gotchas simply because so much of

00:29:55,310 --> 00:29:58,280
reactive programming happens

00:29:56,540 --> 00:29:59,870
asynchronously on different threads and

00:29:58,280 --> 00:30:03,560
test frameworks aren't necessarily

00:29:59,870 --> 00:30:06,980
designed to think about things in that

00:30:03,560 --> 00:30:09,830
way on the use side we said there are a

00:30:06,980 --> 00:30:11,300
couple things that go problematic you

00:30:09,830 --> 00:30:12,770
want to probably make sure you're using

00:30:11,300 --> 00:30:14,840
things like countdown latches to

00:30:12,770 --> 00:30:17,090
guarantee that you're holding processes

00:30:14,840 --> 00:30:18,320
open longer than they might otherwise

00:30:17,090 --> 00:30:20,420
simply because once your stuff is

00:30:18,320 --> 00:30:22,070
happening on other threads there are

00:30:20,420 --> 00:30:24,290
ways we didn't discuss them in here but

00:30:22,070 --> 00:30:26,210
there are ways to effectively say I

00:30:24,290 --> 00:30:27,890
don't want to use a countdown launch I

00:30:26,210 --> 00:30:29,720
just want you to turn this back into a

00:30:27,890 --> 00:30:32,600
synchronous non asynchronous thing by

00:30:29,720 --> 00:30:34,190
blocking it open we saw how to handle

00:30:32,600 --> 00:30:35,930
errors remember that errors are actually

00:30:34,190 --> 00:30:38,360
values that flow through a chain there

00:30:35,930 --> 00:30:39,680
are no exceptions you pass exception

00:30:38,360 --> 00:30:41,990
types around but nothing ever gets

00:30:39,680 --> 00:30:44,210
thrown and reactive you want to make

00:30:41,990 --> 00:30:46,190
sure you compose methods and obviously

00:30:44,210 --> 00:30:49,880
the point freestyle we discussed there

00:30:46,190 --> 00:30:52,910
at then so that's it for us thank you

00:30:49,880 --> 00:30:54,350
all I think we're right at time now so I

00:30:52,910 --> 00:30:56,000
will step off the stage and while the

00:30:54,350 --> 00:30:58,490
next speaker to come up and we'll answer

00:30:56,000 --> 00:31:02,559
questions thank you very much

00:30:58,490 --> 00:31:02,559

YouTube URL: https://www.youtube.com/watch?v=5rTIJKrvsKA


