Title: Test Driven Development for Microservices Using Spring Cloud Contracts & Cloud Foundry
Publication date: 2018-04-21
Playlist: Cloud Foundry Summit NA 2018
Description: 
	Test Driven Development for Microservices Using Spring Cloud Contracts & Cloud Foundry - Reshmi Krishna & Adib Saikali, Pivotal

TDD introduced many improvements into the development process, but in our opinion the biggest impact relates to code design. Looking at the code from the usage perspective (by first writing an acceptance test) allows us to focus on usability rather than concrete implementation. Unfortunately, we usually rest on our laurels not trying to uplift this practice to the architecture level.

Consumer driven contracts (CDC) are like TDD applied to the API. It’s especially important in the world of microservices. Since it’s driven by consumers, it’s much more user friendly. Of course microservices are really cool, but most people do not take into consideration plenty of potential obstacles that should be tackled. Then instead of frequent, fully automated deploys via a delivery pipeline, you might end up in an asylum due to frequent mental breakdowns caused by production disasters.

This presentation will show you how you can use the Spring Cloud Contracts to have a fully automated solution to a consumer driven testing disasters. We will then deploy all these applications to Cloud Foundry. At the end, you will see how easy is it to write applications that have a consumer driven API and that will allow a developer to speed up the time of writing his better quality software.

About Reshmi Krishna
Reshmi Krishna is a Senior Platform Architect with Pivotal. She works with Cloud Foundry and helps customers transform the way they build software. Prior to working at Pivotal, Reshmi was a software engineer with investment banks and start ups on Wall Street. She has extensive experience of building low latency trading systems.

Reshmi lives in New York. She likes supporting various conferences and causes for diversity. She's a part of Women in Tech, Society of Women Engineers and participates in Grace Hopper Conference for Women.

About Adib Saikali
Adib is passionate about technology and entreprenurship from assembly to JavaScript from cold calling to pitching venture capitalists.
Captions: 
	00:00:00,000 --> 00:00:05,490
all right good afternoon everyone so you

00:00:02,610 --> 00:00:08,059
all already have probably eventually in

00:00:05,490 --> 00:00:10,200
the last two sessions but it's mandatory

00:00:08,059 --> 00:00:13,410
so please read the fire exit

00:00:10,200 --> 00:00:14,820
announcements so for today's session

00:00:13,410 --> 00:00:17,279
we'll be talking about test-driven

00:00:14,820 --> 00:00:19,350
development for micro services my name

00:00:17,279 --> 00:00:23,670
is Rashmi Krishna and I'm a senior

00:00:19,350 --> 00:00:25,830
platform architect with pivotal my name

00:00:23,670 --> 00:00:29,130
is Adisa Kali and I'm an advisory

00:00:25,830 --> 00:00:30,359
platform architecture pivotal and want

00:00:29,130 --> 00:00:33,059
to set a little bit of context about

00:00:30,359 --> 00:00:35,100
what we're talking about today what

00:00:33,059 --> 00:00:38,550
we're concerned with is how do we

00:00:35,100 --> 00:00:40,079
actually test micro services with this

00:00:38,550 --> 00:00:41,760
thing called consumer driven contracts

00:00:40,079 --> 00:00:43,829
our goal isn't to give you an

00:00:41,760 --> 00:00:45,899
encyclopedic treatment of it to give you

00:00:43,829 --> 00:00:47,280
a sense of what the workflow is when you

00:00:45,899 --> 00:00:49,620
work with this type of technology and

00:00:47,280 --> 00:00:51,960
this is all because unfortunately as

00:00:49,620 --> 00:00:53,610
much as we all love micro services the

00:00:51,960 --> 00:00:56,070
challenge of micro services that they

00:00:53,610 --> 00:00:58,559
talk to each other so when things talk

00:00:56,070 --> 00:01:00,899
to each other that causes problems and

00:00:58,559 --> 00:01:03,390
there's two categories of problems that

00:01:00,899 --> 00:01:05,220
causes one is around testing and service

00:01:03,390 --> 00:01:07,260
evolution and one is around continuous

00:01:05,220 --> 00:01:10,710
delivery so we've broken up the talk

00:01:07,260 --> 00:01:12,540
into a section that focuses on service

00:01:10,710 --> 00:01:14,700
evolution first and how to solve that

00:01:12,540 --> 00:01:18,659
and a second part with it with another

00:01:14,700 --> 00:01:21,180
demo that talks about how to how to

00:01:18,659 --> 00:01:23,130
handle continuous delivery so the first

00:01:21,180 --> 00:01:25,530
thing is you know we have all these

00:01:23,130 --> 00:01:28,890
services and let's say I was in a

00:01:25,530 --> 00:01:31,200
situation where I have this green micro

00:01:28,890 --> 00:01:34,200
service that calls the rectangle micro

00:01:31,200 --> 00:01:36,420
service which calls the Pentagon micro

00:01:34,200 --> 00:01:37,740
service and what would happen if I was

00:01:36,420 --> 00:01:39,890
to add or remove something how many

00:01:37,740 --> 00:01:42,299
people here raise your hand if you

00:01:39,890 --> 00:01:43,950
modified an API and we're quite

00:01:42,299 --> 00:01:47,310
concerned that one of your clients would

00:01:43,950 --> 00:01:48,360
break and you left something in there

00:01:47,310 --> 00:01:50,460
just because you didn't want anybody

00:01:48,360 --> 00:01:52,829
screaming at you for breaking the code

00:01:50,460 --> 00:01:54,450
so this is the you know the service

00:01:52,829 --> 00:01:57,119
evolution problem can I add something

00:01:54,450 --> 00:01:58,770
can I remove something and if I did have

00:01:57,119 --> 00:02:01,079
I done it in a safe way we don't want to

00:01:58,770 --> 00:02:03,899
be with micro services going back to the

00:02:01,079 --> 00:02:05,490
old way of having to coordinate releases

00:02:03,899 --> 00:02:06,780
with a whole bunch of people we just

00:02:05,490 --> 00:02:07,590
want to release each micro service

00:02:06,780 --> 00:02:09,750
independently

00:02:07,590 --> 00:02:11,580
so there are a lot of patterns for how

00:02:09,750 --> 00:02:13,890
we can involve our service in order to

00:02:11,580 --> 00:02:16,590
make sure that it does not break the

00:02:13,890 --> 00:02:18,120
client's things like for example how

00:02:16,590 --> 00:02:19,770
many people have versioned their api's

00:02:18,120 --> 00:02:22,290
you have version one of the API version

00:02:19,770 --> 00:02:25,050
2 it's a common pattern or baby you

00:02:22,290 --> 00:02:26,970
build extension points into your API so

00:02:25,050 --> 00:02:28,769
that you can actually extend things in

00:02:26,970 --> 00:02:30,239
the future these are all good patterns

00:02:28,769 --> 00:02:31,319
but the one we want to focus on is

00:02:30,239 --> 00:02:33,420
something called consumer driven

00:02:31,319 --> 00:02:34,650
contracts just a quick show of hands how

00:02:33,420 --> 00:02:37,290
many of you are familiar with the

00:02:34,650 --> 00:02:39,540
consumer driven contracts pattern just a

00:02:37,290 --> 00:02:41,519
few people ok so for those of you who

00:02:39,540 --> 00:02:43,380
aren't familiar with it let's let's kind

00:02:41,519 --> 00:02:45,569
of get a couple of pieces of terminology

00:02:43,380 --> 00:02:47,370
down the first one is what is a provider

00:02:45,569 --> 00:02:49,620
contract if I'm the person who builds

00:02:47,370 --> 00:02:51,810
the service I can basically from my

00:02:49,620 --> 00:02:53,940
point of view all of my clients want

00:02:51,810 --> 00:02:56,489
everything I offer so I'm looking at

00:02:53,940 --> 00:02:58,500
this and saying ok my client a is gonna

00:02:56,489 --> 00:03:00,540
call me and they're gonna invoke every

00:02:58,500 --> 00:03:01,920
operation I have and I'm gonna return to

00:03:00,540 --> 00:03:04,049
them everything that they care about

00:03:01,920 --> 00:03:05,880
everything that I can offer but this

00:03:04,049 --> 00:03:08,819
isn't how the world looks like from the

00:03:05,880 --> 00:03:11,430
point of view of the consumer so we look

00:03:08,819 --> 00:03:12,180
at it from the point of view of the

00:03:11,430 --> 00:03:14,700
consumer

00:03:12,180 --> 00:03:16,650
maybe client a what it calls the service

00:03:14,700 --> 00:03:19,230
does not use every feature of my micro

00:03:16,650 --> 00:03:21,840
service it might be using a subset maybe

00:03:19,230 --> 00:03:24,959
I returned 50 fields and it only cares

00:03:21,840 --> 00:03:27,720
about 3 of those 50 fields as anybody

00:03:24,959 --> 00:03:29,370
ever called an API and didn't use every

00:03:27,720 --> 00:03:31,140
feature of the API they're called they

00:03:29,370 --> 00:03:34,170
call it raise your hand we've all done

00:03:31,140 --> 00:03:36,510
that so what we want to be doing is is

00:03:34,170 --> 00:03:39,600
understanding that the world from the

00:03:36,510 --> 00:03:42,480
point of view of the consumer is always

00:03:39,600 --> 00:03:45,690
very much a subset of what the provider

00:03:42,480 --> 00:03:47,700
offers every consumer is gonna be

00:03:45,690 --> 00:03:49,470
wanting some things potentially slightly

00:03:47,700 --> 00:03:51,780
different it's possible that some

00:03:49,470 --> 00:03:54,359
consumer will use every single feature

00:03:51,780 --> 00:03:56,670
of the provider that's okay that's a lot

00:03:54,359 --> 00:03:58,889
but let's make the assumption that they

00:03:56,670 --> 00:04:01,200
care about different things and so what

00:03:58,889 --> 00:04:04,139
we want to define is this concept of

00:04:01,200 --> 00:04:07,109
what is a consumer contract test imagine

00:04:04,139 --> 00:04:09,720
that if your consumers of your API gave

00:04:07,109 --> 00:04:11,760
you an executable test for writing your

00:04:09,720 --> 00:04:14,430
code in Java think they gave me in JUnit

00:04:11,760 --> 00:04:17,010
test and I can run this test as part of

00:04:14,430 --> 00:04:17,690
my CD pipeline and every time I make a

00:04:17,010 --> 00:04:20,030
change

00:04:17,690 --> 00:04:22,340
to the service that I felt I can run my

00:04:20,030 --> 00:04:24,080
consumers tests and if I break any of

00:04:22,340 --> 00:04:27,410
them I would know right away that I

00:04:24,080 --> 00:04:30,140
broke my consumer and but what the

00:04:27,410 --> 00:04:33,110
expectation is that my consumer is only

00:04:30,140 --> 00:04:36,110
going to test the things that they use

00:04:33,110 --> 00:04:38,150
so if I call one of five operations I

00:04:36,110 --> 00:04:40,700
that are available I'll test that

00:04:38,150 --> 00:04:42,800
operation I call if I care about four of

00:04:40,700 --> 00:04:44,330
that twenty fields I get return I'll

00:04:42,800 --> 00:04:47,600
check for the four of those twenty

00:04:44,330 --> 00:04:49,760
fields so I'm testing things from my

00:04:47,600 --> 00:04:53,420
point of view as an end user of the API

00:04:49,760 --> 00:04:56,510
and and that allows us to have a very

00:04:53,420 --> 00:04:58,180
interesting flow of collaboration which

00:04:56,510 --> 00:05:01,040
has referred to as the consumer driven

00:04:58,180 --> 00:05:04,220
workflow so I've got a short animation

00:05:01,040 --> 00:05:06,440
to explain this so let's say I have my

00:05:04,220 --> 00:05:08,870
code and I've got a git repo for my

00:05:06,440 --> 00:05:11,750
micro service and this get repo I'm

00:05:08,870 --> 00:05:16,030
gonna have my the code that implements

00:05:11,750 --> 00:05:18,320
my micro service I'm going to have my

00:05:16,030 --> 00:05:21,260
provider tasks which are the tests that

00:05:18,320 --> 00:05:23,020
I write to test my own code as I should

00:05:21,260 --> 00:05:26,110
be and then I'm gonna have another

00:05:23,020 --> 00:05:30,919
directory in my repo let's call this one

00:05:26,110 --> 00:05:34,490
the the consumer tests okay oh there's a

00:05:30,919 --> 00:05:36,169
typo on mine so imagine this third this

00:05:34,490 --> 00:05:38,030
column right here not saying code to

00:05:36,169 --> 00:05:41,030
implement the micro service but saying

00:05:38,030 --> 00:05:45,860
this is where my consumer tests go sorry

00:05:41,030 --> 00:05:47,360
I type on on the slide so what I do is

00:05:45,860 --> 00:05:49,190
let's say I've got the green team the

00:05:47,360 --> 00:05:50,840
Green team wants to use this so what the

00:05:49,190 --> 00:05:54,710
green team is going to do is they're

00:05:50,840 --> 00:05:57,290
going to create a test for the API and

00:05:54,710 --> 00:05:59,690
they're gonna test for my micro service

00:05:57,290 --> 00:06:02,120
just what they want to use then they're

00:05:59,690 --> 00:06:04,160
gonna send me a pull request and in that

00:06:02,120 --> 00:06:06,550
pull request I'm gonna take it and I'm

00:06:04,160 --> 00:06:09,740
gonna put the consumer a contract test

00:06:06,550 --> 00:06:11,390
inside of my git repository so that I

00:06:09,740 --> 00:06:13,880
can run it as part of my regular

00:06:11,390 --> 00:06:16,130
development flow and then the orange

00:06:13,880 --> 00:06:18,830
team comes along and they also want to

00:06:16,130 --> 00:06:20,360
use my API but they care about something

00:06:18,830 --> 00:06:22,280
slightly different they are not using

00:06:20,360 --> 00:06:24,220
all the fields so this is represented

00:06:22,280 --> 00:06:26,770
with they only care about the indepen

00:06:24,220 --> 00:06:29,110
teacher not the triangle in the circle

00:06:26,770 --> 00:06:31,540
and they will send me a pull request and

00:06:29,110 --> 00:06:35,740
I will put that in my good repo so now

00:06:31,540 --> 00:06:39,220
in my repository I actually have a

00:06:35,740 --> 00:06:41,740
collection of all of the consumer tests

00:06:39,220 --> 00:06:44,170
every one of my consumers has told me

00:06:41,740 --> 00:06:46,270
what they need for me not by having a

00:06:44,170 --> 00:06:49,410
conversation and sending me an email but

00:06:46,270 --> 00:06:51,760
by sending me a pull request with a test

00:06:49,410 --> 00:06:55,000
who thinks this is this would be useful

00:06:51,760 --> 00:06:57,340
when you're in your life and the

00:06:55,000 --> 00:06:59,950
contract is going to be is as the person

00:06:57,340 --> 00:07:02,260
who provides the API my goal in life is

00:06:59,950 --> 00:07:04,990
not to break my consumers but I want

00:07:02,260 --> 00:07:07,660
them to own telling me an executable

00:07:04,990 --> 00:07:10,150
format what I what they need for me so

00:07:07,660 --> 00:07:11,830
if we're gonna implement this pattern we

00:07:10,150 --> 00:07:14,080
probably want to use something like a

00:07:11,830 --> 00:07:16,150
contract testing framework of some kind

00:07:14,080 --> 00:07:18,430
and the job of the contract testing

00:07:16,150 --> 00:07:21,250
framework is to make it easy to write

00:07:18,430 --> 00:07:22,600
these contract tests and make it

00:07:21,250 --> 00:07:25,000
possible to implement the

00:07:22,600 --> 00:07:27,850
consumer-driven contracts workflow so in

00:07:25,000 --> 00:07:29,260
the java world you'll see technology is

00:07:27,850 --> 00:07:31,600
like spring cloud contract that's what

00:07:29,260 --> 00:07:34,030
we're going to demo today and other

00:07:31,600 --> 00:07:35,169
technologies like pact and other

00:07:34,030 --> 00:07:37,450
languages there are other

00:07:35,169 --> 00:07:39,160
consumer-driven contract frameworks so

00:07:37,450 --> 00:07:41,200
the key thing here is that we want to

00:07:39,160 --> 00:07:43,660
answer first as how do I actually

00:07:41,200 --> 00:07:45,880
represent a a contract and turn it over

00:07:43,660 --> 00:07:48,850
to Rashmi and she is going to walk you

00:07:45,880 --> 00:07:53,650
through a demo on how to do this Thank

00:07:48,850 --> 00:07:56,140
You Allie alright so for our first demo

00:07:53,650 --> 00:07:58,600
we'll be looking at a customer profile

00:07:56,140 --> 00:08:01,270
service with consumers as loyalty point

00:07:58,600 --> 00:08:02,800
and recommendation service and our

00:08:01,270 --> 00:08:05,320
problem that we are going to solve here

00:08:02,800 --> 00:08:07,720
is how can we evolve my producer which

00:08:05,320 --> 00:08:12,040
is my customer profile service without

00:08:07,720 --> 00:08:14,790
breaking any of its consumer right let's

00:08:12,040 --> 00:08:14,790
jump to the code

00:08:15,949 --> 00:08:23,520
so let's pretend can you guys see in the

00:08:18,780 --> 00:08:26,639
back everyone good all right so let's

00:08:23,520 --> 00:08:28,949
pretend I have a contract that has been

00:08:26,639 --> 00:08:34,380
sent to me by my consumer loyalty point

00:08:28,949 --> 00:08:36,810
service it's sitting in my repo and I

00:08:34,380 --> 00:08:39,659
need to do I need to accept their pull

00:08:36,810 --> 00:08:42,240
request so before I do that let's look

00:08:39,659 --> 00:08:44,640
at what the contract is saying and if I

00:08:42,240 --> 00:08:47,550
agree with it so the contract is saying

00:08:44,640 --> 00:08:50,519
here that hey producer customer profile

00:08:47,550 --> 00:08:52,829
service if I send you a request with

00:08:50,519 --> 00:08:54,870
username and password rush million one

00:08:52,829 --> 00:08:57,990
two three the response that I am

00:08:54,870 --> 00:09:02,040
expecting from you are these two fields

00:08:57,990 --> 00:09:05,790
user login check status and points with

00:09:02,040 --> 00:09:07,500
gold and 50000 as the value so this is

00:09:05,790 --> 00:09:11,070
what the loyalty point service is

00:09:07,500 --> 00:09:14,070
expecting from me I think this is okay I

00:09:11,070 --> 00:09:19,110
can do this so let me accept the pull

00:09:14,070 --> 00:09:24,959
request let's put it under the contract

00:09:19,110 --> 00:09:27,089
folder so as Adeeb was mentioning in the

00:09:24,959 --> 00:09:29,970
producer you have a common repository

00:09:27,089 --> 00:09:33,120
which is my resources contract folder

00:09:29,970 --> 00:09:34,620
where I as a producer can merge all the

00:09:33,120 --> 00:09:37,709
contracts that's coming from the

00:09:34,620 --> 00:09:39,870
consumer it also makes documentation

00:09:37,709 --> 00:09:42,480
really easy so this is in groovy dsl

00:09:39,870 --> 00:09:44,850
format you can write it in llamo and you

00:09:42,480 --> 00:09:48,750
can also generate Doc's from it isn't

00:09:44,850 --> 00:09:50,970
that cool all right so now let's see

00:09:48,750 --> 00:09:54,949
once I have accepted this contract let

00:09:50,970 --> 00:09:54,949
me run my project and see what happens

00:09:55,459 --> 00:09:59,449
let's bring up my console

00:10:03,870 --> 00:10:11,880
oops looks like and broke so let's see

00:10:07,950 --> 00:10:16,280
what happened here so because I accepted

00:10:11,880 --> 00:10:20,220
this contract what you see here is my

00:10:16,280 --> 00:10:23,820
consumer here is expecting a field

00:10:20,220 --> 00:10:26,670
called user login check status but what

00:10:23,820 --> 00:10:29,490
I have here is status so that's not

00:10:26,670 --> 00:10:31,620
matching right so since I don't have any

00:10:29,490 --> 00:10:33,300
other contracts I think that's a

00:10:31,620 --> 00:10:34,910
valuable change and I can make that

00:10:33,300 --> 00:10:40,110
change and of course this is the demo

00:10:34,910 --> 00:10:43,590
right let's make that change and then

00:10:40,110 --> 00:10:49,530
see how that works so I'm just gonna

00:10:43,590 --> 00:10:56,760
rename my field also rename the getters

00:10:49,530 --> 00:10:58,970
and setters okay all right now let's run

00:10:56,760 --> 00:10:58,970
this again

00:11:04,590 --> 00:11:10,560
and hopefully they should build this

00:11:06,450 --> 00:11:13,410
time all right bill success great so

00:11:10,560 --> 00:11:16,040
once the build has been successful let

00:11:13,410 --> 00:11:21,540
me show you something

00:11:16,040 --> 00:11:22,140
it is also generated a test for me isn't

00:11:21,540 --> 00:11:24,900
that cool

00:11:22,140 --> 00:11:26,910
so the very fired plug-in on the

00:11:24,900 --> 00:11:29,490
producer side that I have from the

00:11:26,910 --> 00:11:32,010
spring cloud contract project has not

00:11:29,490 --> 00:11:33,540
only abled me to you know put my

00:11:32,010 --> 00:11:36,740
contracts in the replay and make sure I

00:11:33,540 --> 00:11:39,750
conform to it but it has also generated

00:11:36,740 --> 00:11:43,290
auto-generated a test for me and this

00:11:39,750 --> 00:11:46,140
test makes sure because of this test my

00:11:43,290 --> 00:11:48,630
initial implementation broke because the

00:11:46,140 --> 00:11:55,680
field that I was using was incorrect

00:11:48,630 --> 00:11:59,970
does that make sense yeah all right so

00:11:55,680 --> 00:12:03,480
moving on in summary what you saw so far

00:11:59,970 --> 00:12:05,460
I was on the producer side and once I

00:12:03,480 --> 00:12:07,410
accepted the contract coming from the

00:12:05,460 --> 00:12:10,020
consumer because I was using the

00:12:07,410 --> 00:12:12,420
verifier plugin it was able to verify

00:12:10,020 --> 00:12:14,970
that my code is validating against the

00:12:12,420 --> 00:12:17,400
API that the consumers are expecting and

00:12:14,970 --> 00:12:27,839
it was also able to generate these tests

00:12:17,400 --> 00:12:29,460
for me back to a bit so so we saw how we

00:12:27,839 --> 00:12:31,230
can solve the problem with the

00:12:29,460 --> 00:12:34,490
consumer-driven contract workflow of

00:12:31,230 --> 00:12:38,540
being able to change the definition of

00:12:34,490 --> 00:12:41,940
an API for a micro service and then

00:12:38,540 --> 00:12:44,400
determine whether who we broke and what

00:12:41,940 --> 00:12:45,990
action we need to take to fix that the

00:12:44,400 --> 00:12:49,380
other problem that we have when we want

00:12:45,990 --> 00:12:51,750
to do micro services at scale is that if

00:12:49,380 --> 00:12:54,089
I'm going to make a change to the circle

00:12:51,750 --> 00:12:55,920
micro service and I want to deploy it as

00:12:54,089 --> 00:12:58,350
part of my pipeline how do I run an

00:12:55,920 --> 00:13:01,380
automated test against the circle micro

00:12:58,350 --> 00:13:04,050
service do I need to de frst deploy the

00:13:01,380 --> 00:13:06,300
triangle the square the Pentagon and the

00:13:04,050 --> 00:13:07,980
and the diamond if I have to do that

00:13:06,300 --> 00:13:10,529
then my pipelines are going to be like

00:13:07,980 --> 00:13:12,660
really complicated right we don't want

00:13:10,529 --> 00:13:14,220
to we won't be able to test a circle

00:13:12,660 --> 00:13:18,300
micro-service and know that it's working

00:13:14,220 --> 00:13:21,629
before we actually deploy it - with all

00:13:18,300 --> 00:13:24,239
this dependencies so this is the how do

00:13:21,629 --> 00:13:26,129
I test something in isolation and so

00:13:24,239 --> 00:13:28,110
there are actually two strategies for

00:13:26,129 --> 00:13:30,749
doing this one is to use mocks and the

00:13:28,110 --> 00:13:32,730
other one is to use stubs and mocks and

00:13:30,749 --> 00:13:34,350
stubs are kind of slight variations of

00:13:32,730 --> 00:13:36,720
the same idea and I kinda want to take a

00:13:34,350 --> 00:13:39,239
moment to distinguish the two so when

00:13:36,720 --> 00:13:41,309
you're building a mock typical actions

00:13:39,239 --> 00:13:43,470
are first you create the mock and then

00:13:41,309 --> 00:13:45,269
as the person writing the test you set

00:13:43,470 --> 00:13:47,879
the expectations on the mock so you say

00:13:45,269 --> 00:13:49,980
hey when I call you and I pass in the

00:13:47,879 --> 00:13:52,679
username deep you should come back with

00:13:49,980 --> 00:13:55,860
a response of 50,000 points status

00:13:52,679 --> 00:13:58,199
Platinum okay and then you use that in

00:13:55,860 --> 00:14:01,139
your test the key idea here is that

00:13:58,199 --> 00:14:04,230
every single test first sets up the mock

00:14:01,139 --> 00:14:06,420
for their needs and it tends to be the

00:14:04,230 --> 00:14:08,759
case that you don't make remote calls

00:14:06,420 --> 00:14:10,980
when marks are involved you're typically

00:14:08,759 --> 00:14:12,809
relying on the programming language and

00:14:10,980 --> 00:14:14,549
the runtime with a programming language

00:14:12,809 --> 00:14:16,829
to maybe do something in Java we

00:14:14,549 --> 00:14:19,230
typically do like bytecode generation in

00:14:16,829 --> 00:14:21,569
order to generate mock implementations

00:14:19,230 --> 00:14:23,160
you use tools like mojito and other

00:14:21,569 --> 00:14:26,610
frameworks like that to auto generate

00:14:23,160 --> 00:14:28,799
the marks stubs on the other hand tend

00:14:26,610 --> 00:14:31,589
to be things that are the same for all

00:14:28,799 --> 00:14:34,470
tests so when a stub I'll make one stub

00:14:31,589 --> 00:14:37,410
and multiple tests will utilize that so

00:14:34,470 --> 00:14:39,329
with a stub we also tend to be able to

00:14:37,410 --> 00:14:41,790
do remote calls so I might actually

00:14:39,329 --> 00:14:44,189
start start up a dummy server I might

00:14:41,790 --> 00:14:46,709
use something like wire mock or another

00:14:44,189 --> 00:14:49,379
technology service virtualization

00:14:46,709 --> 00:14:51,660
technology and and this way I can

00:14:49,379 --> 00:14:54,899
actually receive real messages real HTTP

00:14:51,660 --> 00:14:56,519
requests and return canned responses

00:14:54,899 --> 00:14:58,290
who's built a stopped by hand in the

00:14:56,519 --> 00:15:02,089
past raise your hand if you've done that

00:14:58,290 --> 00:15:05,100
okay so a few of you have that's great

00:15:02,089 --> 00:15:06,929
and so if we look at this scenario and

00:15:05,100 --> 00:15:08,189
we say okay I got my loyalty point

00:15:06,929 --> 00:15:10,589
service it calls a recommendation

00:15:08,189 --> 00:15:12,779
service which in turn calls customer

00:15:10,589 --> 00:15:15,620
profile which calls order history which

00:15:12,779 --> 00:15:17,600
uses a database it makes a call to me

00:15:15,620 --> 00:15:19,940
if I want to test the loyalty point

00:15:17,600 --> 00:15:22,880
service I don't want to have to you know

00:15:19,940 --> 00:15:25,279
how do I get an on-demand instance of

00:15:22,880 --> 00:15:27,230
the customer profile service and all its

00:15:25,279 --> 00:15:29,510
dependencies so what we'd like to do is

00:15:27,230 --> 00:15:32,390
instead say okay how about we do this

00:15:29,510 --> 00:15:35,270
what if we actually hand coded a

00:15:32,390 --> 00:15:37,160
customer profile service stop and then

00:15:35,270 --> 00:15:39,620
that customer profile service stop we

00:15:37,160 --> 00:15:41,390
can deploy that to Cloud Foundry and and

00:15:39,620 --> 00:15:43,820
then or we can just run it as part of

00:15:41,390 --> 00:15:46,370
our test but the problem with hand-coded

00:15:43,820 --> 00:15:49,190
stubs is that they are tedious to code

00:15:46,370 --> 00:15:51,680
right it's actually hard to make sure

00:15:49,190 --> 00:15:53,839
that your stub is staying in sync with

00:15:51,680 --> 00:15:55,850
the actual API that you're calling

00:15:53,839 --> 00:15:57,560
because your stub can veer off and

00:15:55,850 --> 00:15:59,360
you're like getting surprised that hey

00:15:57,560 --> 00:16:01,100
my test worked for the loyalty point

00:15:59,360 --> 00:16:02,839
service what do you mean when I deploy

00:16:01,100 --> 00:16:04,520
that it didn't work because you know the

00:16:02,839 --> 00:16:06,410
custom the order the the customer

00:16:04,520 --> 00:16:08,270
profile folks have changed their

00:16:06,410 --> 00:16:09,920
implementation and I didn't know that

00:16:08,270 --> 00:16:14,150
because I was testing against the hand

00:16:09,920 --> 00:16:16,460
coded stub that I wrote and the stop

00:16:14,150 --> 00:16:21,920
does not test the request over that like

00:16:16,460 --> 00:16:24,230
the stub is gonna give us we want to

00:16:21,920 --> 00:16:25,730
test it over the network okay so what we

00:16:24,230 --> 00:16:27,320
want to do is this we want to basically

00:16:25,730 --> 00:16:30,260
take the contract that we have written

00:16:27,320 --> 00:16:33,560
and then we want to generate from that

00:16:30,260 --> 00:16:35,930
contract a wire mark configuration which

00:16:33,560 --> 00:16:38,420
in which implements what's specified in

00:16:35,930 --> 00:16:41,839
the contract then we can launch wire

00:16:38,420 --> 00:16:44,350
mark as a server pick a port number and

00:16:41,839 --> 00:16:49,100
make our request to wire mach remotely

00:16:44,350 --> 00:16:51,560
right and that is also gives us the

00:16:49,100 --> 00:16:54,529
advantage of being able to publish this

00:16:51,560 --> 00:16:56,779
watermark configuration into our maven

00:16:54,529 --> 00:16:58,400
repository so that we can just depend on

00:16:56,779 --> 00:17:00,350
it so what I'm gonna what we'll do now

00:16:58,400 --> 00:17:03,440
is you can have end up in this situation

00:17:00,350 --> 00:17:05,689
where if I want to write my loyalty

00:17:03,440 --> 00:17:08,390
point service integration test for my

00:17:05,689 --> 00:17:10,970
loyalty point service I'm able to do

00:17:08,390 --> 00:17:13,610
that and I'm calling the auto-generated

00:17:10,970 --> 00:17:15,709
customer profile service stuff and this

00:17:13,610 --> 00:17:18,170
is going to resolve the problem of

00:17:15,709 --> 00:17:21,829
keeping it in sync because the contracts

00:17:18,170 --> 00:17:24,199
are being used to generate the tests

00:17:21,829 --> 00:17:27,079
that the service provider is used

00:17:24,199 --> 00:17:28,850
to test their code and the same

00:17:27,079 --> 00:17:31,639
contracts are being used to generate the

00:17:28,850 --> 00:17:33,320
stubs and since the contracts are part

00:17:31,639 --> 00:17:36,830
of the pipeline of the service provider

00:17:33,320 --> 00:17:38,600
I'm gonna resolve that problem of using

00:17:36,830 --> 00:17:44,480
a version of the stub that doesn't

00:17:38,600 --> 00:17:46,429
actually reflect reality so this is the

00:17:44,480 --> 00:17:48,470
combination of able to generate both is

00:17:46,429 --> 00:17:52,179
the kind of really key idea here that

00:17:48,470 --> 00:17:54,200
enables that development workflow so

00:17:52,179 --> 00:17:56,659
what should you expect from your

00:17:54,200 --> 00:17:58,190
contract testing framework your contract

00:17:56,659 --> 00:18:00,380
testing framework should be able to

00:17:58,190 --> 00:18:02,059
generate the stubs for you so what we're

00:18:00,380 --> 00:18:03,590
gonna do now is turn it back to Rashmi

00:18:02,059 --> 00:18:11,570
to show you how this works in the spring

00:18:03,590 --> 00:18:14,240
law contract thank you alright so before

00:18:11,570 --> 00:18:16,549
we go into see how the consumer is going

00:18:14,240 --> 00:18:19,669
to utilize the stub let's see something

00:18:16,549 --> 00:18:22,010
and to review what we saw so far in the

00:18:19,669 --> 00:18:24,350
demo was we have a provider customer

00:18:22,010 --> 00:18:26,570
profile service we have an

00:18:24,350 --> 00:18:27,200
auto-generated test from our verifier

00:18:26,570 --> 00:18:31,399
plugin

00:18:27,200 --> 00:18:34,039
and if you look at the jars that was

00:18:31,399 --> 00:18:37,789
developed in the target directory you

00:18:34,039 --> 00:18:38,960
can see here is the project jar and you

00:18:37,789 --> 00:18:41,990
see another thing which is very

00:18:38,960 --> 00:18:44,480
interesting which is the stubs jar so

00:18:41,990 --> 00:18:47,450
when I ran it my producer using the

00:18:44,480 --> 00:18:50,450
verifier plugin what it did was it

00:18:47,450 --> 00:18:53,570
created this wire mock configuration as

00:18:50,450 --> 00:18:58,490
dumpster jar which then was downloaded

00:18:53,570 --> 00:19:01,929
into my maven repository alright so now

00:18:58,490 --> 00:19:07,340
let's go back to my sorry about that

00:19:01,929 --> 00:19:10,159
consumer okay so this is my consumer

00:19:07,340 --> 00:19:13,580
this is one of my those greenboxes

00:19:10,159 --> 00:19:16,549
loyalty point service what it does is it

00:19:13,580 --> 00:19:18,350
tries to retrieve the points given the

00:19:16,549 --> 00:19:20,720
name in the password it riffed read

00:19:18,350 --> 00:19:23,929
retrieves the point in the status from

00:19:20,720 --> 00:19:26,419
the customer profile service you see

00:19:23,929 --> 00:19:30,370
here I already have a test let's run

00:19:26,419 --> 00:19:30,370
this test and then see what happens

00:19:31,600 --> 00:19:44,230
so I'm gonna run this okay all right

00:19:39,820 --> 00:19:47,040
great so it was successful now let's see

00:19:44,230 --> 00:19:47,040
what happened here

00:19:52,420 --> 00:19:58,390
okay so what you see here is telling me

00:19:56,170 --> 00:20:01,600
I've started a stop server for this

00:19:58,390 --> 00:20:03,610
project on four six six five and the

00:20:01,600 --> 00:20:05,860
stuff that I have here is the customer

00:20:03,610 --> 00:20:09,900
profile service job so it's the producer

00:20:05,860 --> 00:20:12,700
stub so as a background the stub runner

00:20:09,900 --> 00:20:16,180
plug-in that I have for my consumer it

00:20:12,700 --> 00:20:18,730
does two things it goes and it downloads

00:20:16,180 --> 00:20:20,890
the stubs from the producer and make

00:20:18,730 --> 00:20:23,800
sure it's available to me it's running

00:20:20,890 --> 00:20:28,120
on port six five six five on wiremock

00:20:23,800 --> 00:20:31,360
server then using wire mock you can also

00:20:28,120 --> 00:20:36,430
see here this is my request that I've

00:20:31,360 --> 00:20:38,770
generated and it's telling me looks like

00:20:36,430 --> 00:20:41,650
your request is matching and the

00:20:38,770 --> 00:20:44,470
response that you're expecting is golden

00:20:41,650 --> 00:20:47,440
fifty thousand is also matching so that

00:20:44,470 --> 00:20:49,090
means the test that I've written matches

00:20:47,440 --> 00:20:52,200
with the contract and the stubs that

00:20:49,090 --> 00:20:55,180
have been generated from the producer

00:20:52,200 --> 00:20:58,690
now let's see what makes this happen on

00:20:55,180 --> 00:21:00,640
the consumer side so I was tell as I was

00:20:58,690 --> 00:21:03,880
telling you before we use stub runners

00:21:00,640 --> 00:21:07,510
so if you see this annotation here at

00:21:03,880 --> 00:21:09,660
Auto configure stub runner so the moment

00:21:07,510 --> 00:21:13,120
you have this annotation in your code

00:21:09,660 --> 00:21:15,580
you're telling it that hey I want it to

00:21:13,120 --> 00:21:18,160
use my producer which is my customer

00:21:15,580 --> 00:21:20,590
profile service stubs it's gonna run on

00:21:18,160 --> 00:21:23,590
six five six five and I'm gonna make

00:21:20,590 --> 00:21:26,220
sure that my tests are conforming to

00:21:23,590 --> 00:21:26,220
these stubs

00:21:26,730 --> 00:21:34,920
alright so now let's go back any

00:21:32,920 --> 00:21:38,330
questions so far

00:21:34,920 --> 00:21:43,190
now everything is super clear

00:21:38,330 --> 00:21:46,280
all right great okay so what you saw on

00:21:43,190 --> 00:21:49,250
the consumer side was I wrote a test and

00:21:46,280 --> 00:21:52,640
I had the act Auto configure stub runner

00:21:49,250 --> 00:21:54,590
as annotations on my test class which

00:21:52,640 --> 00:21:57,050
allowed me to do two things so as part

00:21:54,590 --> 00:21:59,600
of the stub runner plug-in from the

00:21:57,050 --> 00:22:02,240
contracts winter contract project it

00:21:59,600 --> 00:22:04,130
downloaded the jars with the stubs and I

00:22:02,240 --> 00:22:07,010
used a class path to be able to verify

00:22:04,130 --> 00:22:09,620
that and it also ran these on my VAR

00:22:07,010 --> 00:22:16,400
mocks server that that then I was able

00:22:09,620 --> 00:22:19,100
to validate my test again right yeah so

00:22:16,400 --> 00:22:20,480
just going back to you know taking a

00:22:19,100 --> 00:22:23,060
step back and saying we showed you a

00:22:20,480 --> 00:22:25,580
couple of different things that together

00:22:23,060 --> 00:22:27,260
make it possible to implement this this

00:22:25,580 --> 00:22:29,330
advanced way of testing and that's the

00:22:27,260 --> 00:22:31,160
idea that we're going to write the

00:22:29,330 --> 00:22:33,470
contract once we're going to write the

00:22:31,160 --> 00:22:35,180
contract in groovy the reason why we

00:22:33,470 --> 00:22:37,040
want to write the contract in groovy is

00:22:35,180 --> 00:22:40,040
having groovy is very good for making

00:22:37,040 --> 00:22:41,900
DSL and it allows us to create contracts

00:22:40,040 --> 00:22:43,820
that aren't static they're not just like

00:22:41,900 --> 00:22:45,860
when you see the string return this

00:22:43,820 --> 00:22:48,830
result we could have put a lot of fancy

00:22:45,860 --> 00:22:51,710
things in there called Java code to help

00:22:48,830 --> 00:22:53,930
generate the incoming requests and the

00:22:51,710 --> 00:22:55,940
outgoing responses we don't have time to

00:22:53,930 --> 00:22:57,590
show all of that but the point is we're

00:22:55,940 --> 00:22:59,690
gonna write the contract once in groovy

00:22:57,590 --> 00:23:01,970
we are going to run it through the

00:22:59,690 --> 00:23:04,670
spring cloud contract plugins now spring

00:23:01,970 --> 00:23:06,860
cloud contract has plug-ins for maven it

00:23:04,670 --> 00:23:09,050
also has plug-ins for Gradle we're gonna

00:23:06,860 --> 00:23:09,800
expect spring cloud contract to do two

00:23:09,050 --> 00:23:12,890
things for us

00:23:09,800 --> 00:23:15,800
number one we wanted to generate j-unit

00:23:12,890 --> 00:23:17,600
tasks which just run as regular part of

00:23:15,800 --> 00:23:21,020
our implementation of the micro service

00:23:17,600 --> 00:23:23,290
to to automatically test that we are

00:23:21,020 --> 00:23:26,450
conforming to our consumers requirements

00:23:23,290 --> 00:23:28,550
we are then going to also generate stops

00:23:26,450 --> 00:23:30,770
it's going to generate stubs for us we

00:23:28,550 --> 00:23:33,680
will publish those stub jar files to our

00:23:30,770 --> 00:23:37,190
maven repository so our colleagues that

00:23:33,680 --> 00:23:40,310
are working on calling our services are

00:23:37,190 --> 00:23:43,100
able to use write their integration

00:23:40,310 --> 00:23:44,990
tests just as plain old j-unit tasks but

00:23:43,100 --> 00:23:47,690
just add the annotation that's table

00:23:44,990 --> 00:23:48,830
runner to it and by doing that it will

00:23:47,690 --> 00:23:51,799
download from

00:23:48,830 --> 00:23:54,140
even the actual wire mark configuration

00:23:51,799 --> 00:23:55,880
launched the wire mark configuration as

00:23:54,140 --> 00:23:58,130
part of the task they're just going to

00:23:55,880 --> 00:24:00,769
go on localhost to the port number that

00:23:58,130 --> 00:24:04,370
they specified in the stub runner and

00:24:00,769 --> 00:24:06,320
now you have the ability to actually do

00:24:04,370 --> 00:24:08,929
the two things that we wanted to do

00:24:06,320 --> 00:24:11,179
which is be able to evolve your api's

00:24:08,929 --> 00:24:13,460
interface without breaking your

00:24:11,179 --> 00:24:17,539
consumers and to be able to test things

00:24:13,460 --> 00:24:19,460
in isolation so if you think about it is

00:24:17,539 --> 00:24:22,730
this going to be a complete replacement

00:24:19,460 --> 00:24:24,320
for you know the end-to-end tests no you

00:24:22,730 --> 00:24:26,389
still want to do that but what we want

00:24:24,320 --> 00:24:27,769
to be able to do is on every commit we

00:24:26,389 --> 00:24:30,110
want to go through the testing pyramid

00:24:27,769 --> 00:24:31,519
we want to run our J unit tests are our

00:24:30,110 --> 00:24:33,169
regular unit tests we want to run our

00:24:31,519 --> 00:24:35,090
integration test and if all of these

00:24:33,169 --> 00:24:37,100
paths eventually we're gonna hit an

00:24:35,090 --> 00:24:38,600
environment where we are in fact doing

00:24:37,100 --> 00:24:41,090
an end-to-end test to validate that

00:24:38,600 --> 00:24:44,630
everything works but let's be let us be

00:24:41,090 --> 00:24:46,940
able to disqualify and catch errors

00:24:44,630 --> 00:24:49,490
earlier and have a shorter feedback loop

00:24:46,940 --> 00:24:54,200
because this is really what this is all

00:24:49,490 --> 00:24:56,750
about absolutely and just to summarize

00:24:54,200 --> 00:24:58,299
the whole flow that you saw so far and

00:24:56,750 --> 00:25:00,380
we tried to keep it really really simple

00:24:58,299 --> 00:25:02,690
so what we saw so far

00:25:00,380 --> 00:25:05,480
as a developer what I did was I

00:25:02,690 --> 00:25:08,360
generated a contract that then it was

00:25:05,480 --> 00:25:11,120
accepted by the producer and this what

00:25:08,360 --> 00:25:12,919
this contract did was it mentioned the

00:25:11,120 --> 00:25:15,889
interaction between a consumer and the

00:25:12,919 --> 00:25:19,610
API and we use groovy DSL for that you

00:25:15,889 --> 00:25:22,639
can use yamo config files and using the

00:25:19,610 --> 00:25:25,100
contract maven or Gradle plugin we then

00:25:22,639 --> 00:25:28,059
generated the stubs which were then

00:25:25,100 --> 00:25:30,740
downloaded and used by your consumer and

00:25:28,059 --> 00:25:33,500
the way your consumer used these stubs

00:25:30,740 --> 00:25:36,529
are using these at Auto configure stub

00:25:33,500 --> 00:25:40,429
runner annotation right so what this

00:25:36,529 --> 00:25:42,950
this did for me as a consumer it kind of

00:25:40,429 --> 00:25:45,139
took away those environmental issues and

00:25:42,950 --> 00:25:48,019
waiting on the producer to publish it

00:25:45,139 --> 00:25:50,809
thought I could very one run and test my

00:25:48,019 --> 00:25:53,809
code against the producer without having

00:25:50,809 --> 00:25:55,820
to call the real API now I'm guessing

00:25:53,809 --> 00:25:58,159
you all have a CI CD server that's

00:25:55,820 --> 00:26:00,889
running right and you can very well

00:25:58,159 --> 00:26:02,250
automate all of these things and sprint

00:26:00,889 --> 00:26:03,600
out contracts actually start

00:26:02,250 --> 00:26:06,900
to the wire mark during the test

00:26:03,600 --> 00:26:08,520
execution and also configures it with

00:26:06,900 --> 00:26:10,980
the scenario that's specified in the

00:26:08,520 --> 00:26:13,380
contract for you and then you can run

00:26:10,980 --> 00:26:17,580
your test from the consumer side against

00:26:13,380 --> 00:26:19,170
it so any questions so far we are ending

00:26:17,580 --> 00:26:26,700
I know we have like less than five

00:26:19,170 --> 00:26:28,680
minutes so any questions so far yes yes

00:26:26,700 --> 00:26:34,460
it's available and you'll see that in

00:26:28,680 --> 00:26:34,460
the resources slide yeah yes

00:26:38,390 --> 00:26:41,570
so the question is is there any tooling

00:26:40,309 --> 00:26:45,530
that allows you to generate the

00:26:41,570 --> 00:26:48,830
contracts from your code and not that I

00:26:45,530 --> 00:26:51,039
know on with this one we like the code

00:26:48,830 --> 00:26:53,809
that you're generating the contract from

00:26:51,039 --> 00:26:56,270
would have to be the consumer code yeah

00:26:53,809 --> 00:26:57,860
and that's a pretty hard problem to

00:26:56,270 --> 00:27:00,950
understand how one piece of code is

00:26:57,860 --> 00:27:04,850
using another one I think a big value of

00:27:00,950 --> 00:27:06,289
the of the of the contract workflow the

00:27:04,850 --> 00:27:07,760
consumer-driven contract work so it

00:27:06,289 --> 00:27:10,190
makes it more social you know it's

00:27:07,760 --> 00:27:12,470
leveraging the idea of pull requests

00:27:10,190 --> 00:27:15,409
coding as a social activity and it's

00:27:12,470 --> 00:27:17,870
asking the actual end user to say please

00:27:15,409 --> 00:27:20,289
take some responsibility and give me a

00:27:17,870 --> 00:27:22,549
test it's it's a way of spreading the

00:27:20,289 --> 00:27:24,590
testing culture inside of the

00:27:22,549 --> 00:27:27,380
organization and it's saying I will

00:27:24,590 --> 00:27:30,169
reward you in two ways by you taking the

00:27:27,380 --> 00:27:33,140
time to write the test number one is I

00:27:30,169 --> 00:27:35,000
will give you I'll make sure I don't

00:27:33,140 --> 00:27:36,559
break you as a provider and number two

00:27:35,000 --> 00:27:37,539
I'm going to make it easier for you to

00:27:36,559 --> 00:27:41,960
get stops

00:27:37,539 --> 00:27:47,609
great question yep

00:27:41,960 --> 00:27:47,609
[Music]

00:27:49,960 --> 00:27:56,089
yes absolutely

00:27:52,990 --> 00:27:56,089
[Music]

00:27:59,530 --> 00:28:11,720
yeah yes I mean let me summarize the

00:28:10,160 --> 00:28:14,990
question so the question is an

00:28:11,720 --> 00:28:17,270
observation that the can one can I have

00:28:14,990 --> 00:28:19,460
dynamic contracts where you know I have

00:28:17,270 --> 00:28:20,990
conditional things number two is what if

00:28:19,460 --> 00:28:23,090
the contracts get so complicated that

00:28:20,990 --> 00:28:25,280
nobody understands them anymore right so

00:28:23,090 --> 00:28:27,320
the answer is - this is yes because

00:28:25,280 --> 00:28:30,140
we're using groovy there's the concept

00:28:27,320 --> 00:28:31,880
that your base contract or actually have

00:28:30,140 --> 00:28:34,160
a base class that they that you can

00:28:31,880 --> 00:28:36,230
control and put helper methods in and

00:28:34,160 --> 00:28:39,440
like all technologies you can definitely

00:28:36,230 --> 00:28:41,660
make spaghetti code with us so part of

00:28:39,440 --> 00:28:43,660
the learning process so we encourage you

00:28:41,660 --> 00:28:45,980
to keep things simple and like say hey

00:28:43,660 --> 00:28:48,320
consumers can you please just test what

00:28:45,980 --> 00:28:50,690
you need it's easier to have a hundred

00:28:48,320 --> 00:28:53,150
simple contracts and to have one generic

00:28:50,690 --> 00:28:55,429
contract that does 100 cases right right

00:28:53,150 --> 00:28:58,250
so that would be the recommendation

00:28:55,429 --> 00:29:00,169
there right and another thing is as you

00:28:58,250 --> 00:29:02,179
saw the end point right so you can

00:29:00,169 --> 00:29:04,730
customize the contract to make sure

00:29:02,179 --> 00:29:06,799
you're only kind of integrating all the

00:29:04,730 --> 00:29:09,530
tests or all the use cases for spawn

00:29:06,799 --> 00:29:11,740
single API call in one contract right

00:29:09,530 --> 00:29:14,299
just to make sure it's not as convoluted

00:29:11,740 --> 00:29:17,150
all right so before we take any more

00:29:14,299 --> 00:29:19,130
questions actually let's finish up and I

00:29:17,150 --> 00:29:21,890
know we have a minute so did you want to

00:29:19,130 --> 00:29:23,600
talk about the nest feature so in say

00:29:21,890 --> 00:29:27,110
sprinkler contract is a very large

00:29:23,600 --> 00:29:28,790
project with a ton of features like I

00:29:27,110 --> 00:29:30,830
would we would have loved to have like

00:29:28,790 --> 00:29:33,380
five hours to tell you all about it but

00:29:30,830 --> 00:29:35,179
we didn't so we hope that what we've

00:29:33,380 --> 00:29:39,169
given you today is just a glimpse of

00:29:35,179 --> 00:29:41,440
what a workflow it enables and they you

00:29:39,169 --> 00:29:44,570
know motivation to look deeper into it

00:29:41,440 --> 00:29:46,460
you know a lot of the the more advanced

00:29:44,570 --> 00:29:49,160
scenarios we can do it so just we

00:29:46,460 --> 00:29:51,020
encourage you to go to the docs and this

00:29:49,160 --> 00:29:55,270
is a list of resources that you can head

00:29:51,020 --> 00:29:55,270
to find more information so question

00:30:03,590 --> 00:30:06,920
yeah so

00:30:08,860 --> 00:30:12,370
so there's no wonder there's a wonderful

00:30:11,140 --> 00:30:14,679
question so I'm gonna repeat it for

00:30:12,370 --> 00:30:17,289
further for the video which is can I

00:30:14,679 --> 00:30:19,000
write the stubs can I get the stops

00:30:17,289 --> 00:30:20,679
before the implementer of the micro

00:30:19,000 --> 00:30:23,409
service has added that feature and the

00:30:20,679 --> 00:30:26,260
answer is absolutely yes so if you think

00:30:23,409 --> 00:30:27,669
about the idea of TDD you're supposed to

00:30:26,260 --> 00:30:29,980
write the test before you write the code

00:30:27,669 --> 00:30:31,899
right and we tend to do that at the

00:30:29,980 --> 00:30:34,870
level of an individual class or

00:30:31,899 --> 00:30:36,700
individual small piece of code consumer

00:30:34,870 --> 00:30:37,570
driven contracts actually allow you to

00:30:36,700 --> 00:30:40,419
do that at the level of your

00:30:37,570 --> 00:30:43,630
architecture some you can describe to a

00:30:40,419 --> 00:30:46,090
consumer-driven contracts as TDD at the

00:30:43,630 --> 00:30:48,309
architecture level so if I'm a consumer

00:30:46,090 --> 00:30:49,630
and I know that the other team I'm

00:30:48,309 --> 00:30:51,100
calling the micro service that I'm

00:30:49,630 --> 00:30:53,440
calling they haven't had time to

00:30:51,100 --> 00:30:54,730
implement the feature that I want but

00:30:53,440 --> 00:30:57,399
we've had a meeting we've talked about

00:30:54,730 --> 00:31:00,100
it I can specify the contract get that

00:30:57,399 --> 00:31:01,899
in and start like writing my own

00:31:00,100 --> 00:31:05,500
application before they've implemented

00:31:01,899 --> 00:31:07,450
that feature and and like there is a way

00:31:05,500 --> 00:31:09,460
for example to store all the contracts

00:31:07,450 --> 00:31:12,549
in a separate repository there's a lot

00:31:09,460 --> 00:31:14,380
of variations of this workflow that are

00:31:12,549 --> 00:31:15,760
refinements which we didn't have time to

00:31:14,380 --> 00:31:19,630
talk about but wonderful question thank

00:31:15,760 --> 00:31:22,240
you yeah any other questions getting the

00:31:19,630 --> 00:31:23,590
signals all right we're happy to take

00:31:22,240 --> 00:31:27,859
your questions offline

00:31:23,590 --> 00:31:27,859

YouTube URL: https://www.youtube.com/watch?v=uankAcm1jxE


