Title: Concourse All of the Things at All Times - Jason Immerman, Zipcar & Derek Van Assche, HS2 Solutions
Publication date: 2018-04-21
Playlist: Cloud Foundry Summit NA 2018
Description: 
	Concourse All of the Things at All Times - Jason Immerman, Zipcar & Derek Van Assche, HS2 Solutions

How do large engineering organisations build reliable and well-defined processes to help dev teams get their work to production?

Zipcar answered this question by replacing a patchwork of semi-automated and manual testing, approval and deployment processes with a series of autonomous pipelines powered by the powerful and supremely flexible continuous integration/delivery system "Concourse".

Concourse allowed Zipcar to move from a tightly controlled weekly release cycle to a loose peer-reviewed process allowing 100+ applications to be tested, integrated and deployed on a continuous basis.

This presentation will focus on the real world experience of automating creation of well-tested deployable artifacts (in Zipcar's case, docker images, ready to be deployed into a diego-based infrastructure) and the tactics that can be employed in coordinating and expressing dependencies between applications that are managed according to their own autonomous schedules. It will discuss the limitations and constraints of pipelined integration testing and will suggest several approaches to overcoming them.

About Derek Van Assche
Derek is a software engineer working for HS2 Solutions in Detroit, Michigan. His primary expertise is in web development using a Java stack, but he also has experience in a variety of other tools and languages. He has particular interests in data analysis and simplifying complicated problems.

Most recently Derek has been working with Zipcar on managing Concourse infrastructure and streamlining the generation and maintenance of CI/CD pipelines. 

About Jason Immerman
As manager of quality engineering, Jason focuses on furthering Zipcar’s continuous delivery implementation within a microservice architecture. Jason holds a BA in physics from Bowdoin College, and conducted research in numerical relativity.

He then made the (quantum) leap to computing, working both as an independent contractor in web development, and in management roles for QA and QA automation at Eze Software Group. Jason is passionate about automating manual processes including testing, artifact management, and deployment.

During downtime, Jason enjoys hiking, woodworking, cooking, and “having deep conversations with his Google Home.”
Captions: 
	00:00:00,860 --> 00:00:06,060
cool hey everyone my name is Jason

00:00:04,020 --> 00:00:07,770
Timmerman I work for a sip car this is

00:00:06,060 --> 00:00:09,750
Derrick vanish works for hs2 solutions

00:00:07,770 --> 00:00:11,580
and we're gonna be talk about how Zipcar

00:00:09,750 --> 00:00:13,650
has recently been using concours in

00:00:11,580 --> 00:00:15,960
order to manage our increased product

00:00:13,650 --> 00:00:17,609
and process complexity or more

00:00:15,960 --> 00:00:20,520
specifically how we use concours for all

00:00:17,609 --> 00:00:21,300
of the things at all the times so before

00:00:20,520 --> 00:00:25,680
we get started

00:00:21,300 --> 00:00:27,689
quick fire exit announcement cool so as

00:00:25,680 --> 00:00:30,269
I said my name is Jason Merman I work

00:00:27,689 --> 00:00:31,949
for a sip car and zip car provides

00:00:30,269 --> 00:00:34,170
on-demand cars wheels when you want them

00:00:31,949 --> 00:00:36,300
and as a result we do a lot of things

00:00:34,170 --> 00:00:37,800
with scaling fleet management and

00:00:36,300 --> 00:00:40,800
Internet of Things as we pull data from

00:00:37,800 --> 00:00:44,280
our cars and i'm derek finish i work for

00:00:40,800 --> 00:00:46,559
a company called hs2 solutions hs2 is a

00:00:44,280 --> 00:00:49,399
digital brand experience agency we offer

00:00:46,559 --> 00:00:52,410
the full range of services including

00:00:49,399 --> 00:00:54,539
development management consulting q wave

00:00:52,410 --> 00:00:57,180
analytics pretty much everything in

00:00:54,539 --> 00:00:58,859
between as well HS Tunes up car up and

00:00:57,180 --> 00:01:00,899
partnering and different part projects

00:00:58,859 --> 00:01:03,570
for over seven years and currently I'm

00:01:00,899 --> 00:01:06,090
working with Jason and his team to build

00:01:03,570 --> 00:01:07,530
out their pipelines in concourse trying

00:01:06,090 --> 00:01:10,439
to optimize their development workflow

00:01:07,530 --> 00:01:11,280
cool so Before we jump into concourse

00:01:10,439 --> 00:01:12,869
I'm going to give a little bit of

00:01:11,280 --> 00:01:14,970
context of sort of car use with our tech

00:01:12,869 --> 00:01:17,820
stack and hopefully some of you saw this

00:01:14,970 --> 00:01:19,170
in the keynote with Andy and Holly but

00:01:17,820 --> 00:01:20,549
right now it's the cars replied forming

00:01:19,170 --> 00:01:22,640
so we're a major replied forming going

00:01:20,549 --> 00:01:26,070
from monolith to a set of micro services

00:01:22,640 --> 00:01:28,110
and we're using cloud foundry tools for

00:01:26,070 --> 00:01:30,000
our deployment our orchestration and a

00:01:28,110 --> 00:01:32,100
lot of our monitoring things like Bosch

00:01:30,000 --> 00:01:33,869
Diego and logger Gator and we built this

00:01:32,100 --> 00:01:36,240
abstraction layer that we call savanna

00:01:33,869 --> 00:01:38,130
that's really makes it easier for us to

00:01:36,240 --> 00:01:40,619
host and do all these things with a set

00:01:38,130 --> 00:01:42,060
of micro services and it's super cool

00:01:40,619 --> 00:01:43,259
that's not what this talk is about so

00:01:42,060 --> 00:01:45,090
I'm not going to talk about it too much

00:01:43,259 --> 00:01:46,680
other than to say to pertinent details

00:01:45,090 --> 00:01:48,149
one of which is throughout this talk I'm

00:01:46,680 --> 00:01:49,530
going to I'm going to reference an app

00:01:48,149 --> 00:01:50,850
or a micro service or a service

00:01:49,530 --> 00:01:52,280
I'm talking about the same thing but

00:01:50,850 --> 00:01:54,509
it's a car we have a very opinionated

00:01:52,280 --> 00:01:57,170
idea of what a service is or a micro

00:01:54,509 --> 00:01:59,219
service but Savannah can host them all

00:01:57,170 --> 00:02:00,659
the other piece there is I'm going to

00:01:59,219 --> 00:02:02,549
we're going to reference deployment

00:02:00,659 --> 00:02:04,020
manifests so deployment manifest is a

00:02:02,549 --> 00:02:05,880
file that contains the state of an

00:02:04,020 --> 00:02:07,740
environment it's effectively an array

00:02:05,880 --> 00:02:09,420
that's a set of services their names

00:02:07,740 --> 00:02:12,510
their versions the number of instances

00:02:09,420 --> 00:02:13,890
etc so that will come up a few times so

00:02:12,510 --> 00:02:15,480
this repot farming has been soo

00:02:13,890 --> 00:02:18,420
cool but it's also increased the

00:02:15,480 --> 00:02:20,400
complexity of our system a lot so a few

00:02:18,420 --> 00:02:21,750
numbers there we have now over 80

00:02:20,400 --> 00:02:23,790
services and that number is only going

00:02:21,750 --> 00:02:25,770
to keep growing we have over 25

00:02:23,790 --> 00:02:27,810
production environments that's because

00:02:25,770 --> 00:02:29,760
in addition to the Zipcar solution we

00:02:27,810 --> 00:02:31,860
also have a white labeled solution

00:02:29,760 --> 00:02:33,840
called local motion by Zipcar and we're

00:02:31,860 --> 00:02:37,130
using the same technology to work with

00:02:33,840 --> 00:02:41,670
our our parent company Avis Budget Group

00:02:37,130 --> 00:02:43,170
on some connected car stuff so we also

00:02:41,670 --> 00:02:44,970
have teams that can choose their own

00:02:43,170 --> 00:02:46,800
languages their own frameworks their own

00:02:44,970 --> 00:02:48,420
runtimes and as a result we have a lot

00:02:46,800 --> 00:02:49,980
of varied host configurations to what we

00:02:48,420 --> 00:02:52,290
need in the docker images and the parent

00:02:49,980 --> 00:02:53,550
docker images that they use and then

00:02:52,290 --> 00:02:55,709
finally our teams are widely distributed

00:02:53,550 --> 00:02:58,739
so geographically and as a result

00:02:55,709 --> 00:03:00,239
they're distributed in time zones so in

00:02:58,739 --> 00:03:02,280
pictures we're going from something that

00:03:00,239 --> 00:03:04,440
looks like this to something that looks

00:03:02,280 --> 00:03:06,180
more like this you don't need to read

00:03:04,440 --> 00:03:08,519
that diagram it's really just so there's

00:03:06,180 --> 00:03:10,140
more stuff and so that the problem

00:03:08,519 --> 00:03:11,580
statement really becomes how do we

00:03:10,140 --> 00:03:12,840
minimize the human error while still

00:03:11,580 --> 00:03:14,459
being able to fully understand our

00:03:12,840 --> 00:03:16,350
environments and safely delegate

00:03:14,459 --> 00:03:17,820
ownership to the individual teams that

00:03:16,350 --> 00:03:19,860
last part is really important to us we

00:03:17,820 --> 00:03:21,690
what the teams fail to own the code from

00:03:19,860 --> 00:03:22,829
development to production to support to

00:03:21,690 --> 00:03:24,660
interacting with users and getting

00:03:22,829 --> 00:03:26,010
technical feedback and if we want to

00:03:24,660 --> 00:03:27,120
take away a lot of the stuff that they

00:03:26,010 --> 00:03:31,500
need to deal with in order to do those

00:03:27,120 --> 00:03:34,049
things cool so in looking for a solution

00:03:31,500 --> 00:03:35,519
we came up with a few main tenets one is

00:03:34,049 --> 00:03:36,900
communication we want the communication

00:03:35,519 --> 00:03:39,660
to be transparent centralized and

00:03:36,900 --> 00:03:40,829
consistent as a individual engineer I

00:03:39,660 --> 00:03:42,000
want to know what's going on with my

00:03:40,829 --> 00:03:43,350
builds what's going up with my apps

00:03:42,000 --> 00:03:45,750
where they are in any particular

00:03:43,350 --> 00:03:47,310
environment as a stakeholder I want to

00:03:45,750 --> 00:03:49,350
know the same things but in a little bit

00:03:47,310 --> 00:03:50,910
of a different perspective change

00:03:49,350 --> 00:03:52,680
management needs to be lightweight and

00:03:50,910 --> 00:03:54,120
auditable specifically that lightweight

00:03:52,680 --> 00:03:56,700
piece we want to make sure that people

00:03:54,120 --> 00:03:58,980
can apply these solutions to really a

00:03:56,700 --> 00:04:00,570
general set of technology and so that a

00:03:58,980 --> 00:04:02,220
lot of our artifacts are publications

00:04:00,570 --> 00:04:04,980
things like that are built in a fairly

00:04:02,220 --> 00:04:06,360
consistent way cascading changes if I

00:04:04,980 --> 00:04:07,500
make a change over here to package that

00:04:06,360 --> 00:04:09,810
package gets to where it needs to be

00:04:07,500 --> 00:04:11,220
over here and ultimately that thing that

00:04:09,810 --> 00:04:12,299
this is using the package is deployed to

00:04:11,220 --> 00:04:13,680
all the right environments and then I

00:04:12,299 --> 00:04:16,079
can actually check that that happened

00:04:13,680 --> 00:04:17,789
and then finally managed configuration

00:04:16,079 --> 00:04:20,250
we don't snowflakes we want to be able

00:04:17,789 --> 00:04:22,590
to redeploy and rebuild and have it be

00:04:20,250 --> 00:04:24,240
the same thing in isolation let's say if

00:04:22,590 --> 00:04:25,910
I build a bad version an app I want to

00:04:24,240 --> 00:04:27,660
be able to build that same artifact

00:04:25,910 --> 00:04:28,950
without thinking

00:04:27,660 --> 00:04:32,280
the bad versions going to have somehow

00:04:28,950 --> 00:04:34,830
impacted the good version so we chose to

00:04:32,280 --> 00:04:36,390
concours all the things and so in the

00:04:34,830 --> 00:04:37,980
next slide I'm going to show a general

00:04:36,390 --> 00:04:39,300
solution and then I'm going to pass it

00:04:37,980 --> 00:04:41,820
off to Derrick to to break down how

00:04:39,300 --> 00:04:42,810
we're going to go through this talk the

00:04:41,820 --> 00:04:44,010
general solution to show does not

00:04:42,810 --> 00:04:45,990
contain all the ways in which you use

00:04:44,010 --> 00:04:47,490
Concours because we use it across our

00:04:45,990 --> 00:04:48,810
entire system our infrastructure

00:04:47,490 --> 00:04:50,940
everything it's going to show a

00:04:48,810 --> 00:04:53,130
high-level idea and then just kind of to

00:04:50,940 --> 00:04:54,510
give a flavor and then what we're going

00:04:53,130 --> 00:04:56,790
to do is try to give you some scenarios

00:04:54,510 --> 00:04:58,410
about how we actually use Concours to

00:04:56,790 --> 00:05:01,620
show how you might be able to use it in

00:04:58,410 --> 00:05:03,300
your organization so that solution looks

00:05:01,620 --> 00:05:04,530
a little like this we have pipelines for

00:05:03,300 --> 00:05:06,510
things like building our docker images

00:05:04,530 --> 00:05:08,010
are apparent actor images for building

00:05:06,510 --> 00:05:10,230
all of these individual micro services

00:05:08,010 --> 00:05:12,240
for deployments to all of our staging

00:05:10,230 --> 00:05:13,110
and production environments and then end

00:05:12,240 --> 00:05:15,600
that a bunch of other things on the

00:05:13,110 --> 00:05:17,670
right side but the the main important

00:05:15,600 --> 00:05:18,900
piece of this slide is the center so in

00:05:17,670 --> 00:05:20,250
the center all of our artifacts are

00:05:18,900 --> 00:05:21,960
built by concourse all of them are built

00:05:20,250 --> 00:05:23,700
in a consistent way they're rebuildable

00:05:21,960 --> 00:05:25,320
and no one is really manually going in

00:05:23,700 --> 00:05:27,360
and building and pushing to our artifact

00:05:25,320 --> 00:05:28,650
stores with slack all of the

00:05:27,360 --> 00:05:30,090
communication from concourse about our

00:05:28,650 --> 00:05:32,250
pipelines and everything else is going

00:05:30,090 --> 00:05:33,510
to the same set of channels and there's

00:05:32,250 --> 00:05:34,950
channels follow patterns so that is a

00:05:33,510 --> 00:05:36,840
stakeholder an individual engineer I

00:05:34,950 --> 00:05:38,370
know where to look and I know that I can

00:05:36,840 --> 00:05:39,780
look there and feel comfortable down

00:05:38,370 --> 00:05:42,210
getting the right information all the

00:05:39,780 --> 00:05:46,050
time cool now I'll hand it off to

00:05:42,210 --> 00:05:48,120
Derrick all right so forget started one

00:05:46,050 --> 00:05:51,150
thing I want to reiterate that Jason

00:05:48,120 --> 00:05:53,040
mentioned earlier Zipcar uses concourse

00:05:51,150 --> 00:05:55,350
in many different places in a lot of

00:05:53,040 --> 00:05:57,150
different ways so many different ways

00:05:55,350 --> 00:05:59,430
that we don't really have time to really

00:05:57,150 --> 00:06:01,530
dive into any meaningful detail and the

00:05:59,430 --> 00:06:03,630
time we have allowed so what we decided

00:06:01,530 --> 00:06:05,490
to do was just identify a few different

00:06:03,630 --> 00:06:07,110
scenarios that might be relatable to a

00:06:05,490 --> 00:06:08,970
lot of different types of organization

00:06:07,110 --> 00:06:10,830
and just kind of break down you know

00:06:08,970 --> 00:06:12,780
like discuss a little bit about the

00:06:10,830 --> 00:06:15,780
workflows involved in how kind of course

00:06:12,780 --> 00:06:18,060
enters the picture so as you can see

00:06:15,780 --> 00:06:20,070
here the this is what the scenarios are

00:06:18,060 --> 00:06:23,070
and without further ado let's go into

00:06:20,070 --> 00:06:24,660
the first one so let's say a developer

00:06:23,070 --> 00:06:27,150
wants to make a change to an existing

00:06:24,660 --> 00:06:29,880
application so what I'm showing here

00:06:27,150 --> 00:06:31,020
it's just a basic outline of a process

00:06:29,880 --> 00:06:33,180
that you know a lot different

00:06:31,020 --> 00:06:34,890
organizations might follow might vary

00:06:33,180 --> 00:06:37,760
slightly a little bit but especially

00:06:34,890 --> 00:06:39,470
three they use git as source control

00:06:37,760 --> 00:06:42,200
so first off the developer would create

00:06:39,470 --> 00:06:45,590
a branch then make some code changes on

00:06:42,200 --> 00:06:47,420
them and you know like they would make

00:06:45,590 --> 00:06:50,000
iterate on these changes as they further

00:06:47,420 --> 00:06:51,020
test once they're ready they would

00:06:50,000 --> 00:06:53,810
create a pull request

00:06:51,020 --> 00:06:56,300
maybe iterate some more on their code

00:06:53,810 --> 00:06:57,860
changes and once everyone was happy with

00:06:56,300 --> 00:07:00,800
that result they would merge it to a

00:06:57,860 --> 00:07:02,900
master branch then deployed a staging

00:07:00,800 --> 00:07:05,480
where some manual testing some automated

00:07:02,900 --> 00:07:06,950
testing would occur and once you know

00:07:05,480 --> 00:07:08,390
all stakeholders are happy with the

00:07:06,950 --> 00:07:10,550
result then we would deploy to

00:07:08,390 --> 00:07:13,850
production so what we're gonna do today

00:07:10,550 --> 00:07:16,630
is just focus on the items in the dotted

00:07:13,850 --> 00:07:19,280
rectangle here so the items in green

00:07:16,630 --> 00:07:21,110
actually the ones on the dotted before I

00:07:19,280 --> 00:07:23,390
go further through these have kind of

00:07:21,110 --> 00:07:25,280
course pipelines associated to them so

00:07:23,390 --> 00:07:27,980
the ones in green are basically

00:07:25,280 --> 00:07:29,630
automated triggers and anything in

00:07:27,980 --> 00:07:32,420
yellow which in this case the following

00:07:29,630 --> 00:07:36,590
that to production is manually trigger

00:07:32,420 --> 00:07:38,840
it so first off when it's time to create

00:07:36,590 --> 00:07:41,390
a pull request a pipeline that looks

00:07:38,840 --> 00:07:43,190
like this gets executed so for those

00:07:41,390 --> 00:07:45,440
that I are not familiar this is just an

00:07:43,190 --> 00:07:48,500
example of a pipeline screen within

00:07:45,440 --> 00:07:51,380
Concours and again for those not

00:07:48,500 --> 00:07:53,210
familiar with concourse within concourse

00:07:51,380 --> 00:07:57,950
you have pipelines and with pipelines

00:07:53,210 --> 00:08:00,740
you have resources and end jobs so like

00:07:57,950 --> 00:08:02,300
a resource could be you know any object

00:08:00,740 --> 00:08:04,460
that you might want to trigger action

00:08:02,300 --> 00:08:07,670
off of or any object you might want to

00:08:04,460 --> 00:08:10,130
update some examples might include you

00:08:07,670 --> 00:08:12,590
know like a dock repository or a get

00:08:10,130 --> 00:08:15,860
repository a database things in that

00:08:12,590 --> 00:08:19,370
nature and jobs are the action and you

00:08:15,860 --> 00:08:21,620
actually take so to start out the way of

00:08:19,370 --> 00:08:24,140
a dependencies test and it's a it's a

00:08:21,620 --> 00:08:26,600
check that essentially looks out any

00:08:24,140 --> 00:08:28,970
kind of internal service dependencies

00:08:26,600 --> 00:08:30,710
that particular application has just

00:08:28,970 --> 00:08:32,960
make sure that version exists there's no

00:08:30,710 --> 00:08:36,169
circular dependencies things of that

00:08:32,960 --> 00:08:38,180
nature and moving on we also run some

00:08:36,169 --> 00:08:40,970
integration tests so automated tests

00:08:38,180 --> 00:08:43,669
ensure that the code will work on upper

00:08:40,970 --> 00:08:46,340
environments and also we run an

00:08:43,669 --> 00:08:48,650
internationalization job so essentially

00:08:46,340 --> 00:08:50,240
we take a look and see what languages

00:08:48,650 --> 00:08:52,730
are configured for a pick

00:08:50,240 --> 00:08:55,399
application and generate the proper

00:08:52,730 --> 00:08:58,250
translations there and then finally we

00:08:55,399 --> 00:08:59,959
create a docker image and publish it to

00:08:58,250 --> 00:09:02,899
all the doctor repositories we need to

00:08:59,959 --> 00:09:04,760
and one thing to note with these docker

00:09:02,899 --> 00:09:06,560
versions that we tagged there you know

00:09:04,760 --> 00:09:08,450
we can overwrite them so it's not

00:09:06,560 --> 00:09:10,910
limited to just one so it's essentially

00:09:08,450 --> 00:09:14,270
a snapshot version of that particular

00:09:10,910 --> 00:09:16,970
application so once it's time to merge

00:09:14,270 --> 00:09:18,709
the code to master so we have a very

00:09:16,970 --> 00:09:21,649
similar looking pipeline here there's a

00:09:18,709 --> 00:09:24,020
couple of differences though so one is a

00:09:21,649 --> 00:09:26,089
master dependency analysis job and what

00:09:24,020 --> 00:09:28,180
that does is just conducts a security

00:09:26,089 --> 00:09:31,700
vulnerability check against the code and

00:09:28,180 --> 00:09:33,440
also make sure that all API dependencies

00:09:31,700 --> 00:09:35,209
external dependencies are up-to-date

00:09:33,440 --> 00:09:38,360
there's no newer versions of those out

00:09:35,209 --> 00:09:41,000
there again moving along we have a

00:09:38,360 --> 00:09:43,160
docker build step that again creates a

00:09:41,000 --> 00:09:46,100
docker images publishes it up to the

00:09:43,160 --> 00:09:48,110
docker repositories and but this time

00:09:46,100 --> 00:09:49,850
when we tag it it's a lasting version so

00:09:48,110 --> 00:09:52,040
you can have exactly one version of that

00:09:49,850 --> 00:09:54,020
if you want to something change then you

00:09:52,040 --> 00:09:57,440
have to actually bump up the version

00:09:54,020 --> 00:09:59,540
again and finishing off here we have a

00:09:57,440 --> 00:10:01,520
deployment manifest update and this is a

00:09:59,540 --> 00:10:03,860
very key part of the process that Jason

00:10:01,520 --> 00:10:05,990
alluded to earlier so essentially what

00:10:03,860 --> 00:10:07,850
that is it's it's a per environment

00:10:05,990 --> 00:10:10,250
configuration one of the things in there

00:10:07,850 --> 00:10:11,690
is is that it has all the current

00:10:10,250 --> 00:10:14,720
version of an application per

00:10:11,690 --> 00:10:16,690
environment so at this point we update

00:10:14,720 --> 00:10:19,550
that version

00:10:16,690 --> 00:10:21,440
what's its code whats its virtual master

00:10:19,550 --> 00:10:24,589
we have like the hot off the presses

00:10:21,440 --> 00:10:26,540
version in our manifests for a staging

00:10:24,589 --> 00:10:30,320
environment by default and that brings

00:10:26,540 --> 00:10:32,570
us to deployment time so once that

00:10:30,320 --> 00:10:34,839
happens we kick off a pipeline pretty

00:10:32,570 --> 00:10:38,300
simple one that looks a lot like this

00:10:34,839 --> 00:10:40,850
again we update that deployment manifest

00:10:38,300 --> 00:10:43,370
and by default it will actually kick off

00:10:40,850 --> 00:10:45,680
this pipeline Chuck's to see what if the

00:10:43,370 --> 00:10:47,329
deployment manifest was updated and then

00:10:45,680 --> 00:10:49,520
actually deploys it to our staging

00:10:47,329 --> 00:10:52,399
environment automatically which is nice

00:10:49,520 --> 00:10:53,600
and then once it's time to deploy to

00:10:52,399 --> 00:10:56,000
production we have a very similar

00:10:53,600 --> 00:10:58,670
looking pipeline but this time it's

00:10:56,000 --> 00:11:00,529
manually triggered but essentially it's

00:10:58,670 --> 00:11:02,480
like the same mechanism in order to

00:11:00,529 --> 00:11:03,620
deploy we update a deployment manifest

00:11:02,480 --> 00:11:05,570
for the

00:11:03,620 --> 00:11:07,130
version of that application as well as

00:11:05,570 --> 00:11:12,230
any other application we want to push

00:11:07,130 --> 00:11:14,690
out to prod so with that we'll move

00:11:12,230 --> 00:11:17,930
along to another scenario to create a

00:11:14,690 --> 00:11:19,610
new micro service let's say so again the

00:11:17,930 --> 00:11:21,380
workflow looks very similar to the one

00:11:19,610 --> 00:11:23,990
if you want to change an existing

00:11:21,380 --> 00:11:25,910
microcircuit before we can get to that

00:11:23,990 --> 00:11:28,970
point we need a little bit of setup so

00:11:25,910 --> 00:11:31,670
again the developer might create a

00:11:28,970 --> 00:11:33,920
repository first and then create a kind

00:11:31,670 --> 00:11:35,839
of course pipeline so for our sake again

00:11:33,920 --> 00:11:37,760
we're gonna focus on the item in the

00:11:35,839 --> 00:11:39,410
dotted rectangle that's creating our

00:11:37,760 --> 00:11:41,750
kind of course pipeline and we actually

00:11:39,410 --> 00:11:45,410
chosen to automate this process for a

00:11:41,750 --> 00:11:47,960
few different reasons so as do some as

00:11:45,410 --> 00:11:50,060
mentioned earlier Zipcar has over 80

00:11:47,960 --> 00:11:52,339
micro services that's counting every day

00:11:50,060 --> 00:11:53,900
not all developers at saqqara

00:11:52,339 --> 00:11:55,279
necessarily well-versed with Concours

00:11:53,900 --> 00:11:56,720
know how to create pipelines and things

00:11:55,279 --> 00:11:58,010
of that nature but they don't really

00:11:56,720 --> 00:12:00,560
have to be we've created a nice little

00:11:58,010 --> 00:12:02,990
process to seamlessly integrate with an

00:12:00,560 --> 00:12:04,790
agile development workflow so having a

00:12:02,990 --> 00:12:06,950
nice powerful tool like concourse

00:12:04,790 --> 00:12:09,050
pipeline is you know just a matter of

00:12:06,950 --> 00:12:11,600
seconds away definitely not a barrier to

00:12:09,050 --> 00:12:13,279
you know have something spun up to help

00:12:11,600 --> 00:12:16,459
with continuous integration great thing

00:12:13,279 --> 00:12:18,860
to have another reason why we chose to

00:12:16,459 --> 00:12:21,380
automate it is just issue support so

00:12:18,860 --> 00:12:24,290
Jason's team is charged with supporting

00:12:21,380 --> 00:12:26,600
these pipelines so a having so many

00:12:24,290 --> 00:12:28,670
pipelines running it makes it very easy

00:12:26,600 --> 00:12:31,459
to a identify issues but more

00:12:28,670 --> 00:12:33,680
importantly fix issues so when you're

00:12:31,459 --> 00:12:35,959
fixing one issue for one pipeline a lot

00:12:33,680 --> 00:12:37,339
of times it's you know it'll apply to

00:12:35,959 --> 00:12:39,529
many pipelines and sometimes all

00:12:37,339 --> 00:12:43,040
pipelines which is very powerful and and

00:12:39,529 --> 00:12:45,290
efficient which we all like another

00:12:43,040 --> 00:12:47,450
benefit is to you know aim towards

00:12:45,290 --> 00:12:49,310
stateless infrastructure so if we wanted

00:12:47,450 --> 00:12:52,339
to migrate a different kind of course

00:12:49,310 --> 00:12:53,810
folks for some reason we can easily spin

00:12:52,339 --> 00:12:58,070
up all the pipeline's that belong to

00:12:53,810 --> 00:13:00,790
that kind of course instance and you

00:12:58,070 --> 00:13:04,790
know have have it in a matter of minutes

00:13:00,790 --> 00:13:06,709
very nice layer - so going into the

00:13:04,790 --> 00:13:08,390
solution a little bit more detail so

00:13:06,709 --> 00:13:10,760
we've created a command-line application

00:13:08,390 --> 00:13:12,800
it essentially allows a developer to

00:13:10,760 --> 00:13:14,150
configure a few different aspects they

00:13:12,800 --> 00:13:16,490
would like to see in their pipeline so

00:13:14,150 --> 00:13:17,120
they can customize different types of

00:13:16,490 --> 00:13:19,910
testing that

00:13:17,120 --> 00:13:21,920
they went on it which concourse instance

00:13:19,910 --> 00:13:24,620
they would like to push their pipeline

00:13:21,920 --> 00:13:26,900
to what tech stack that their service

00:13:24,620 --> 00:13:29,150
belongs to that kind of customizes

00:13:26,900 --> 00:13:32,150
actually how the pipeline runs in a lot

00:13:29,150 --> 00:13:33,890
of cases and as well as if they want to

00:13:32,150 --> 00:13:35,300
update other deployment manifests for

00:13:33,890 --> 00:13:38,930
auto deployment so as I mentioned

00:13:35,300 --> 00:13:40,850
earlier by default we will deploy to our

00:13:38,930 --> 00:13:42,350
staging environment but if you wanted to

00:13:40,850 --> 00:13:44,420
deploy to other environments

00:13:42,350 --> 00:13:48,140
automatically as part of this pipeline

00:13:44,420 --> 00:13:49,910
you can easily do that here so to draw

00:13:48,140 --> 00:13:53,330
your attention to the diagram at the

00:13:49,910 --> 00:13:55,310
right a little bit so again we have an

00:13:53,330 --> 00:13:57,710
application it basically takes a smaller

00:13:55,310 --> 00:14:00,500
configuration and generates a larger

00:13:57,710 --> 00:14:03,110
configuration file that concourse can

00:14:00,500 --> 00:14:05,540
recognize we push it out there one

00:14:03,110 --> 00:14:07,640
notable thing we use vault for sensitive

00:14:05,540 --> 00:14:10,820
data that is within our pipelines so

00:14:07,640 --> 00:14:13,339
we'll push it out there another thing to

00:14:10,820 --> 00:14:16,760
note is that we also interact with our

00:14:13,339 --> 00:14:20,089
git repository in this pipeline process

00:14:16,760 --> 00:14:23,330
and this is kind of interesting so by

00:14:20,089 --> 00:14:25,790
default the the concourse get resource

00:14:23,330 --> 00:14:28,490
that we used will pull get powered get

00:14:25,790 --> 00:14:29,990
server and we found that it produced a

00:14:28,490 --> 00:14:31,850
lot of load on that server so in order

00:14:29,990 --> 00:14:33,200
to especially with all these micro

00:14:31,850 --> 00:14:35,600
services we have a lot of different

00:14:33,200 --> 00:14:37,930
repositories so what we chose to do

00:14:35,600 --> 00:14:40,430
instead is to trigger our pipelines

00:14:37,930 --> 00:14:42,410
based on a commit against a pull request

00:14:40,430 --> 00:14:45,770
that we showed earlier and a commit

00:14:42,410 --> 00:14:47,300
against a matched master branch and just

00:14:45,770 --> 00:14:50,750
by looking at this you may wonder well

00:14:47,300 --> 00:14:52,250
how does this magic occur so we have

00:14:50,750 --> 00:14:54,620
created this application called

00:14:52,250 --> 00:14:58,310
concourse API and what that essentially

00:14:54,620 --> 00:15:00,920
is it acts as a traffic cop so anytime

00:14:58,310 --> 00:15:02,930
like I said a commit is pushed against a

00:15:00,920 --> 00:15:05,560
pull request branch or a master branch

00:15:02,930 --> 00:15:08,330
it'll flow through this concourse API

00:15:05,560 --> 00:15:10,250
application and in turn the concourse

00:15:08,330 --> 00:15:12,050
API application is smart enough to know

00:15:10,250 --> 00:15:13,580
which pipeline to kick off which

00:15:12,050 --> 00:15:15,920
resource to kick off to get the whole

00:15:13,580 --> 00:15:20,600
pipeline going it's a very powerful

00:15:15,920 --> 00:15:22,730
thing so moving on to our next scenario

00:15:20,600 --> 00:15:27,000
you might wonder how the card is called

00:15:22,730 --> 00:15:30,210
the code vulnerability analysis so

00:15:27,000 --> 00:15:31,920
we have the going back to our first

00:15:30,210 --> 00:15:35,460
scenario one of the steps in our

00:15:31,920 --> 00:15:38,220
workflow was merging some co2 master we

00:15:35,460 --> 00:15:40,890
have a within that workflow step we have

00:15:38,220 --> 00:15:43,380
a job that'll actually you know conduct

00:15:40,890 --> 00:15:45,810
this vulnerability analysis that I sort

00:15:43,380 --> 00:15:48,450
of alluded to earlier so again that's it

00:15:45,810 --> 00:15:50,520
checks for old versions of API but more

00:15:48,450 --> 00:15:53,430
importantly any security vulnerabilities

00:15:50,520 --> 00:15:56,430
that might be you know within that

00:15:53,430 --> 00:15:57,930
application so what we actually do there

00:15:56,430 --> 00:16:00,270
going in a little more detail there's a

00:15:57,930 --> 00:16:03,000
national vulnerabilities database which

00:16:00,270 --> 00:16:07,560
is a US government hosted database of

00:16:03,000 --> 00:16:10,890
known vulnerabilities of api's and so we

00:16:07,560 --> 00:16:12,990
make that flow through this job and if

00:16:10,890 --> 00:16:15,480
there's any vulnerability or old API

00:16:12,990 --> 00:16:17,910
dependency we will post a notification

00:16:15,480 --> 00:16:20,910
to slack so the correct slack channel so

00:16:17,910 --> 00:16:22,920
any stakeholder or development team will

00:16:20,910 --> 00:16:25,260
be notified that hey there's a security

00:16:22,920 --> 00:16:27,720
vulnerability in your application and

00:16:25,260 --> 00:16:31,560
we'll also post it to this metrics

00:16:27,720 --> 00:16:33,090
database there I'll talk about that in

00:16:31,560 --> 00:16:35,850
more detail in a minute here but before

00:16:33,090 --> 00:16:37,770
I do one thing to note is that any

00:16:35,850 --> 00:16:40,290
failure here so if there is a cold

00:16:37,770 --> 00:16:42,420
vulnerability for example although the

00:16:40,290 --> 00:16:44,520
job will fail the pipeline will continue

00:16:42,420 --> 00:16:47,220
to flow so we'll will allow docker

00:16:44,520 --> 00:16:48,720
images to you know continue to be posted

00:16:47,220 --> 00:16:51,660
for that particular tag for that

00:16:48,720 --> 00:16:53,040
particular version just allowing the

00:16:51,660 --> 00:16:55,710
different development teams to kind of

00:16:53,040 --> 00:16:58,260
prioritize like how vital they see these

00:16:55,710 --> 00:17:00,000
vulnerabilities or you know how vital

00:16:58,260 --> 00:17:03,390
they should get up to the you know

00:17:00,000 --> 00:17:05,610
latest version of an API dependency so

00:17:03,390 --> 00:17:07,080
again we put the control right into the

00:17:05,610 --> 00:17:08,760
developers hands and the development

00:17:07,080 --> 00:17:10,890
teams hands so they can make an educated

00:17:08,760 --> 00:17:15,120
decision they're not have to block any

00:17:10,890 --> 00:17:17,640
kind of agile workflow so going into a

00:17:15,120 --> 00:17:19,740
little more detail on dev metrics so as

00:17:17,640 --> 00:17:21,930
you can see we have wrapped the dev

00:17:19,740 --> 00:17:24,840
metrics data based around a service and

00:17:21,930 --> 00:17:26,160
again we've have it not only embedded in

00:17:24,840 --> 00:17:28,020
our pipelines but we also have a

00:17:26,160 --> 00:17:30,360
scheduled of metrics run so for those

00:17:28,020 --> 00:17:32,700
cases where you know a an application

00:17:30,360 --> 00:17:34,350
isn't actually actively developed let's

00:17:32,700 --> 00:17:36,390
say it's pretty stable and there's no

00:17:34,350 --> 00:17:39,840
code changes against it well at least

00:17:36,390 --> 00:17:42,269
run this dev metrics run that we call

00:17:39,840 --> 00:17:44,190
every once a week and it'll essentially

00:17:42,269 --> 00:17:46,350
do the same thing it'll look for

00:17:44,190 --> 00:17:48,090
security vulnerabilities updated API to

00:17:46,350 --> 00:17:50,070
been seized post to the same slack

00:17:48,090 --> 00:17:52,249
channels and have the development teams

00:17:50,070 --> 00:17:54,240
you know kind of prioritize accordingly

00:17:52,249 --> 00:17:56,700
another interesting thing to note here

00:17:54,240 --> 00:17:58,350
is we have a humid application and what

00:17:56,700 --> 00:18:00,539
that is it just takes some slack

00:17:58,350 --> 00:18:02,700
commands it'll interpret them and go

00:18:00,539 --> 00:18:05,549
against our dev metrics service and

00:18:02,700 --> 00:18:07,590
basically post the same results so with

00:18:05,549 --> 00:18:09,360
that I'll turn it back over to Jason who

00:18:07,590 --> 00:18:11,159
will bring us home with a couple more

00:18:09,360 --> 00:18:13,409
scenarios cool thanks jack

00:18:11,159 --> 00:18:16,379
so a lot of what Derek has shown so far

00:18:13,409 --> 00:18:17,999
is our pipelines within the context of a

00:18:16,379 --> 00:18:20,100
single micro service a single

00:18:17,999 --> 00:18:21,450
application but that's not the only way

00:18:20,100 --> 00:18:23,249
that we use Concours it's it's certainly

00:18:21,450 --> 00:18:24,690
the primary way it's that it's the way

00:18:23,249 --> 00:18:26,909
that most developers or engineers

00:18:24,690 --> 00:18:28,169
interact with the Concours but there are

00:18:26,909 --> 00:18:30,090
a bunch of things that we do outside of

00:18:28,169 --> 00:18:31,619
that so I'm gonna demonstrate a few of

00:18:30,090 --> 00:18:35,009
those more cross cross-cutting

00:18:31,619 --> 00:18:36,600
applications so the first one if we need

00:18:35,009 --> 00:18:38,369
to upgrade a package that's shared

00:18:36,600 --> 00:18:39,960
across a lot of our services in this

00:18:38,369 --> 00:18:43,440
case let's say we're upgrading java more

00:18:39,960 --> 00:18:45,690
specifically the version of JDK so what

00:18:43,440 --> 00:18:47,999
we've done is we've wrapped the remote

00:18:45,690 --> 00:18:49,499
Oracle JDK repo in a Concours resource

00:18:47,999 --> 00:18:50,999
which means a concourse can natively

00:18:49,499 --> 00:18:52,499
interact with it when new versions are

00:18:50,999 --> 00:18:55,830
posted concourse will know about them

00:18:52,499 --> 00:18:57,509
and so for minor versions we can

00:18:55,830 --> 00:18:59,669
automatically trigger the pipeline and

00:18:57,509 --> 00:19:01,379
what's going to happen is if Oracle

00:18:59,669 --> 00:19:03,450
posts a new minor version of some JDK

00:19:01,379 --> 00:19:05,490
that we're using for the major version

00:19:03,450 --> 00:19:07,230
we are going to kick off this pipeline

00:19:05,490 --> 00:19:09,090
and automatically rebuild all the images

00:19:07,230 --> 00:19:11,129
so the base job image the image that has

00:19:09,090 --> 00:19:13,230
Java as well as all the magic sauce need

00:19:11,129 --> 00:19:14,490
to interact with savanah and the same

00:19:13,230 --> 00:19:17,759
images that are used to test within

00:19:14,490 --> 00:19:19,590
Concours and then what-what Derek showed

00:19:17,759 --> 00:19:21,450
earlier we have a developer coming along

00:19:19,590 --> 00:19:23,789
making some code changes unbeknownst to

00:19:21,450 --> 00:19:26,610
them JDK has been bumped they pushed

00:19:23,789 --> 00:19:28,499
something up to to get and their

00:19:26,610 --> 00:19:29,970
pipeline kicks off now the magic here is

00:19:28,499 --> 00:19:31,769
that the pipeline that runs both the

00:19:29,970 --> 00:19:33,389
tests and the artifact that's built and

00:19:31,769 --> 00:19:35,549
published are using new version of JDK

00:19:33,389 --> 00:19:37,470
of course the tests can fail and

00:19:35,549 --> 00:19:39,210
Concours in concourse logs you can

00:19:37,470 --> 00:19:41,129
easily see what happened why it failed

00:19:39,210 --> 00:19:42,509
and move from there but ideally it's

00:19:41,129 --> 00:19:44,210
published it works it automatically goes

00:19:42,509 --> 00:19:46,769
to staging and the workflow Derek showed

00:19:44,210 --> 00:19:48,720
the you know the developer chooses when

00:19:46,769 --> 00:19:51,960
to push it out to production and we have

00:19:48,720 --> 00:19:53,149
upgraded JDK there's there's a pretty

00:19:51,960 --> 00:19:54,679
big gap here though which is the

00:19:53,149 --> 00:19:56,269
we have over 80 micro-services that

00:19:54,679 --> 00:19:58,070
number is going to grow they don't all

00:19:56,269 --> 00:19:59,059
get developed very often right so some

00:19:58,070 --> 00:20:00,859
of them are constant being developed

00:19:59,059 --> 00:20:02,570
some won't get a commit for a little

00:20:00,859 --> 00:20:04,700
while but we still need to get the new

00:20:02,570 --> 00:20:06,859
versions of in this case JDK up to those

00:20:04,700 --> 00:20:09,320
apps so we have this thing that we're

00:20:06,859 --> 00:20:12,559
developing in process called maintenance

00:20:09,320 --> 00:20:15,169
mode and effectively we choose some time

00:20:12,559 --> 00:20:16,669
let's say in this case a month and we're

00:20:15,169 --> 00:20:18,019
gonna we're gonna trigger these

00:20:16,669 --> 00:20:19,549
pipelines in a schedule check what

00:20:18,019 --> 00:20:21,259
pipelines haven't been run in a certain

00:20:19,549 --> 00:20:22,279
amount of time and if they haven't been

00:20:21,259 --> 00:20:24,710
run we're gonna bump the patch version

00:20:22,279 --> 00:20:27,049
and then run the pipeline ideally the

00:20:24,710 --> 00:20:29,029
tests pass we publish a new artifact we

00:20:27,049 --> 00:20:30,200
push that to staging and then we have

00:20:29,029 --> 00:20:31,909
the new version on staging with the new

00:20:30,200 --> 00:20:34,789
JDK even though the developer didn't

00:20:31,909 --> 00:20:35,779
commit code changes well the developer

00:20:34,789 --> 00:20:37,580
team committee code changes so they're

00:20:35,779 --> 00:20:38,479
not expecting this new version so

00:20:37,580 --> 00:20:40,519
they're not going to know to deploy that

00:20:38,479 --> 00:20:42,379
in production so we use Concours again

00:20:40,519 --> 00:20:45,559
for a bunch of reports one of which is

00:20:42,379 --> 00:20:46,879
this environment differ part and we for

00:20:45,559 --> 00:20:48,859
any of our stationary production

00:20:46,879 --> 00:20:50,330
environments week and if production and

00:20:48,859 --> 00:20:51,849
week and if staging and we can see what

00:20:50,330 --> 00:20:54,409
versions are in both how old those are

00:20:51,849 --> 00:20:56,479
and so we publish that to a very public

00:20:54,409 --> 00:20:57,830
channel once a week and ideally the

00:20:56,479 --> 00:20:59,450
engineer notice this is a oh there's a

00:20:57,830 --> 00:21:02,029
new version of my app I need to go deal

00:20:59,450 --> 00:21:03,889
with that no test it pushed out the

00:21:02,029 --> 00:21:05,389
production however they might not notice

00:21:03,889 --> 00:21:06,769
and this is where peer pressure comes in

00:21:05,389 --> 00:21:08,089
we have this nudging mechanism where

00:21:06,769 --> 00:21:09,409
everyone's accountable people are

00:21:08,089 --> 00:21:12,200
talking to each other stakeholders my

00:21:09,409 --> 00:21:15,799
notice appears may notice and inform the

00:21:12,200 --> 00:21:17,599
engineer get it out to production and a

00:21:15,799 --> 00:21:18,830
quick shadow we also have that as a Hugh

00:21:17,599 --> 00:21:21,979
bot command a lot of these things for

00:21:18,830 --> 00:21:23,779
for slack integration so there's one

00:21:21,979 --> 00:21:25,099
more gap here I said that ideally the

00:21:23,779 --> 00:21:26,479
test pass the thing pushes out to

00:21:25,099 --> 00:21:28,489
staging in this environment different

00:21:26,479 --> 00:21:30,739
port picks it up what if the tests

00:21:28,489 --> 00:21:33,619
started failing for whatever reason time

00:21:30,739 --> 00:21:35,029
passed or the new JDK version caused the

00:21:33,619 --> 00:21:36,919
test to fail

00:21:35,029 --> 00:21:38,509
that's where another report comes from

00:21:36,919 --> 00:21:40,429
the persistent pipeline failure report

00:21:38,509 --> 00:21:42,259
which is effectively on some interval we

00:21:40,429 --> 00:21:44,089
checked to see has our pipe I admit a

00:21:42,259 --> 00:21:47,479
consistent failure state for X days

00:21:44,089 --> 00:21:48,649
weeks months whatever and if so we do

00:21:47,479 --> 00:21:50,570
the same thing we publish how to report

00:21:48,649 --> 00:21:52,820
to slack and through that same mechanism

00:21:50,570 --> 00:21:54,469
we hope the engineer will get it that

00:21:52,820 --> 00:21:57,219
information make some code changes and

00:21:54,469 --> 00:22:01,729
after that thing out to production so

00:21:57,219 --> 00:22:03,229
one less scenario here is continuous

00:22:01,729 --> 00:22:04,009
integrations or continuous integration

00:22:03,229 --> 00:22:06,229
testing

00:22:04,009 --> 00:22:06,880
so Holly reference this on the the

00:22:06,229 --> 00:22:08,230
keynote

00:22:06,880 --> 00:22:09,790
but we do this thing called journey

00:22:08,230 --> 00:22:11,080
testing or user journey testing and

00:22:09,790 --> 00:22:13,300
these are really the revenue critical

00:22:11,080 --> 00:22:14,440
paths that are required for our system

00:22:13,300 --> 00:22:15,490
to work on our users to interact with

00:22:14,440 --> 00:22:17,590
the system both internal and external

00:22:15,490 --> 00:22:20,770
users and so we have a set of very

00:22:17,590 --> 00:22:22,210
stable tests that that run constantly

00:22:20,770 --> 00:22:23,290
against all of our staging production

00:22:22,210 --> 00:22:25,090
environments to make sure that these

00:22:23,290 --> 00:22:26,710
revenue critical pads are passing

00:22:25,090 --> 00:22:28,210
because we have all these versions of

00:22:26,710 --> 00:22:29,710
all of these apps constantly flowing

00:22:28,210 --> 00:22:31,080
into these environments and we need to

00:22:29,710 --> 00:22:33,760
make sure that they don't break things

00:22:31,080 --> 00:22:36,000
if something fails post a slack and all

00:22:33,760 --> 00:22:38,200
hands on deck to get that thing fixed

00:22:36,000 --> 00:22:39,550
but one side effect here is that because

00:22:38,200 --> 00:22:41,080
we're running some concourse we're

00:22:39,550 --> 00:22:42,820
constantly telling the data from these

00:22:41,080 --> 00:22:44,080
tests into New Relic which is an

00:22:42,820 --> 00:22:46,170
application performance monitoring tool

00:22:44,080 --> 00:22:49,780
it's really cool if you haven't used it

00:22:46,170 --> 00:22:51,250
but one really nice side effect here is

00:22:49,780 --> 00:22:52,120
that we have constant uptime metrics on

00:22:51,250 --> 00:22:55,750
both our staging and production

00:22:52,120 --> 00:22:57,070
environments so we can see how quality

00:22:55,750 --> 00:22:58,900
is affected not only in production but

00:22:57,070 --> 00:23:00,370
staging because see ICD comes to the

00:22:58,900 --> 00:23:02,560
fact that we can't just constantly be

00:23:00,370 --> 00:23:03,940
bringing down our staging environment we

00:23:02,560 --> 00:23:06,910
need to be usable for people to actually

00:23:03,940 --> 00:23:08,350
test and things like that and so as a

00:23:06,910 --> 00:23:10,450
little bit of a side we take this data

00:23:08,350 --> 00:23:11,290
and then we have a new relic dashboard

00:23:10,450 --> 00:23:13,990
that we can make for any environment

00:23:11,290 --> 00:23:15,280
that gives us uptime metrics it gives us

00:23:13,990 --> 00:23:17,400
things like historical duration of the

00:23:15,280 --> 00:23:20,200
test we can see if we have load problems

00:23:17,400 --> 00:23:22,680
things like that so with that I will

00:23:20,200 --> 00:23:27,010
hand it back to Derek to wrap up all

00:23:22,680 --> 00:23:30,400
right so thanks Jason and as we talked

00:23:27,010 --> 00:23:32,710
about Zipcar uses Concours in a lot of

00:23:30,400 --> 00:23:34,600
different ways we covered some really

00:23:32,710 --> 00:23:36,880
fundamental basic building blocks just

00:23:34,600 --> 00:23:40,480
to kind of you know get your appetite

00:23:36,880 --> 00:23:42,130
whetted a little bit you know like we

00:23:40,480 --> 00:23:43,900
said earlier like it's used in a lot of

00:23:42,130 --> 00:23:46,210
different ways a lot of different you

00:23:43,900 --> 00:23:48,160
know things it's used you know for other

00:23:46,210 --> 00:23:50,380
development workflows there's nuances to

00:23:48,160 --> 00:23:52,510
the workflows we've discussed there's a

00:23:50,380 --> 00:23:55,360
lot of infrastructure related workflows

00:23:52,510 --> 00:23:57,970
that it's used as well so really neat

00:23:55,360 --> 00:23:59,920
powerful tool so really I just wanted an

00:23:57,970 --> 00:24:02,320
extend an invitation if you see either

00:23:59,920 --> 00:24:04,500
Jason or I walk it around feel free to

00:24:02,320 --> 00:24:06,550
stop us we'd love to talk more about

00:24:04,500 --> 00:24:08,920
concours and how does it power users

00:24:06,550 --> 00:24:10,390
concours or if you're a user of concours

00:24:08,920 --> 00:24:11,740
we'd love to chat as well there's a lot

00:24:10,390 --> 00:24:13,900
of different ways to solve you know

00:24:11,740 --> 00:24:15,220
different problems and it's interesting

00:24:13,900 --> 00:24:17,500
to kind of relate you know some

00:24:15,220 --> 00:24:19,060
different organizational challenges and

00:24:17,500 --> 00:24:20,710
try to come up with good common

00:24:19,060 --> 00:24:22,930
solutions

00:24:20,710 --> 00:24:24,700
and also before I close to I wanted to

00:24:22,930 --> 00:24:27,790
give a big shout out to Stark and Wayne

00:24:24,700 --> 00:24:30,550
they got so car started with concours

00:24:27,790 --> 00:24:33,670
got them initially implemented so thanks

00:24:30,550 --> 00:24:35,650
for that and with that I'll just close

00:24:33,670 --> 00:24:37,000
it out and if I think we have time for a

00:24:35,650 --> 00:24:39,030
few questions if anyone has any

00:24:37,000 --> 00:24:39,030
questions

00:25:05,969 --> 00:25:09,999
guess I don't fully understand your

00:25:08,440 --> 00:25:11,259
question when you when you say

00:25:09,999 --> 00:25:13,619
applications on the core versus the

00:25:11,259 --> 00:25:13,619
periphery

00:25:20,170 --> 00:25:23,170
sure

00:25:34,769 --> 00:25:41,110
sorry sorry sorry about that everybody

00:25:37,840 --> 00:25:43,690
so so your question is around pulling

00:25:41,110 --> 00:25:47,139
apart a tightly integrated system is

00:25:43,690 --> 00:25:51,429
really hard and so what what I think

00:25:47,139 --> 00:25:53,309
you're saying is that the things in the

00:25:51,429 --> 00:25:56,289
core that are really tightly integrated

00:25:53,309 --> 00:25:57,970
are you you can't get to those right

00:25:56,289 --> 00:25:59,950
away you have to have a you know real

00:25:57,970 --> 00:26:01,690
strategic approach to those and so to

00:25:59,950 --> 00:26:03,639
start out you pick things that aren't

00:26:01,690 --> 00:26:05,200
quite as tightly integrated and start

00:26:03,639 --> 00:26:08,019
migrating them into the environment is

00:26:05,200 --> 00:26:11,379
that what you're saying so when I ask

00:26:08,019 --> 00:26:14,230
the rest to your question so did we did

00:26:11,379 --> 00:26:16,869
we do it that way what we ended up doing

00:26:14,230 --> 00:26:18,999
is starting off with completely new

00:26:16,869 --> 00:26:22,600
functionality and we are in the process

00:26:18,999 --> 00:26:24,759
of migrating some of that deeper deeper

00:26:22,600 --> 00:26:26,289
integrated stuff and we do have a

00:26:24,759 --> 00:26:28,570
strategy in place for that but I'm not

00:26:26,289 --> 00:26:30,330
sure I can really talk about how we're

00:26:28,570 --> 00:26:38,350
going about that without divulging

00:26:30,330 --> 00:26:40,980
internal stuff so does that help cool

00:26:38,350 --> 00:26:40,980
anything else

00:26:53,500 --> 00:26:58,400
yeah so yeah exactly so instead of

00:26:56,360 --> 00:27:00,380
concourse polling get it all basically

00:26:58,400 --> 00:27:01,640
anytime you commit to get so like I said

00:27:00,380 --> 00:27:04,400
the master branch or a pull request

00:27:01,640 --> 00:27:05,630
branch only it'll flow through that kind

00:27:04,400 --> 00:27:07,630
of course API and then trigger the

00:27:05,630 --> 00:27:12,380
pipeline instead of a pulling mechanism

00:27:07,630 --> 00:27:15,620
yeah web hooks yeah when you use web

00:27:12,380 --> 00:27:18,680
hooks and there's also a PR NFB servlet

00:27:15,620 --> 00:27:20,660
that also handles the pull request so

00:27:18,680 --> 00:27:22,820
that's kind of a just something like a a

00:27:20,660 --> 00:27:25,330
plugin that you put right into in our

00:27:22,820 --> 00:27:25,330
case stash

00:27:32,620 --> 00:27:37,670
um I mean I think it's pretty salad like

00:27:35,450 --> 00:27:40,010
so far we're not you know we find some

00:27:37,670 --> 00:27:42,170
issues sometimes with you know having to

00:27:40,010 --> 00:27:44,150
configure workers and you know container

00:27:42,170 --> 00:27:46,580
counts you know getting maxed out but

00:27:44,150 --> 00:27:48,920
then it's you know it's pretty tweakable

00:27:46,580 --> 00:27:50,600
like you can easily just you know kind

00:27:48,920 --> 00:27:51,770
of scale that and a lot of different

00:27:50,600 --> 00:27:53,000
ways I think we're still kind of

00:27:51,770 --> 00:27:54,950
exploring the different ways that you

00:27:53,000 --> 00:27:56,840
can do that but so far it's not like a

00:27:54,950 --> 00:27:59,090
huge problem it's it's usually pretty

00:27:56,840 --> 00:28:00,650
attainable too to tell that we've done a

00:27:59,090 --> 00:28:01,880
few things to also mitigate that I don't

00:28:00,650 --> 00:28:03,740
know if you noticed an earlier slide we

00:28:01,880 --> 00:28:05,030
have multiple instances in concourse so

00:28:03,740 --> 00:28:06,410
there were having problems with one and

00:28:05,030 --> 00:28:08,330
that was more of an issue in a much

00:28:06,410 --> 00:28:10,190
older version of concourse we were able

00:28:08,330 --> 00:28:11,420
to dynamically go between them and

00:28:10,190 --> 00:28:13,390
because we automatically can generate

00:28:11,420 --> 00:28:16,430
the pipelines that was not too painful

00:28:13,390 --> 00:28:19,490
we also have a lot of monitoring set up

00:28:16,430 --> 00:28:20,960
on concourse itself so there's a lot of

00:28:19,490 --> 00:28:23,780
documentation about how you can do this

00:28:20,960 --> 00:28:27,470
but concourse is always emitting data

00:28:23,780 --> 00:28:28,820
that you can report upon and similar to

00:28:27,470 --> 00:28:30,920
that we built a lot of our own reporting

00:28:28,820 --> 00:28:33,200
mechanisms to hey if jobs are failing

00:28:30,920 --> 00:28:35,030
with a stalled worker exception we we

00:28:33,200 --> 00:28:42,250
get notified and then we can go take

00:28:35,030 --> 00:28:45,410
care of it anything else

00:28:42,250 --> 00:28:47,660
all right well again approach Jason RI

00:28:45,410 --> 00:28:54,999
and thanks for your attention

00:28:47,660 --> 00:28:54,999

YouTube URL: https://www.youtube.com/watch?v=2RfHv8HRJ0Q


