Title: Using Cloud Foundry on AWS to become Cloud Native - Mandus Momberg, AWS
Publication date: 2018-04-21
Playlist: Cloud Foundry Summit NA 2018
Description: 
	Using Cloud Foundry on AWS to become Cloud Native - Mandus Momberg, AWS

Struggling to integrate the benefits of Cloud Foundry with native services in your AWS deployment? Confused about how to use AWS native services like EMR, Kinesis, and Lex with Cloud Foundry? Join us in this session to discover how you can stay agile, iterate quickly and make use of AWS native services in your polyglot application environment without sacrificing the value of Cloud Foundry.

About Madus Momberg
When a problem seems impossible to solve, when teeth grind, tables get flipped and hair gets pulled out, it means only one thing for Mandus Momberg: that’s when you turn on an episode of Star Trek and pull up your sleeves. Mandus has a passion for solving difficult problems in a simple and elegant way. When at 11 years old he got frustrated with a bad telephone line and a continuously disconnecting dial-up modem, he wrote a custom dialing program using Cobol. At 21, when stared down by a fleet of unintelligent remote digital advertising devices, he engineered a self-healing, battery-powered VPN device. He’s in love with the Open Source community. Mandus joined AWS at the age of 27 where he became one of the First Big Data System Engineers, working with customers on building effective data storage and analytic strategies. In his natural habitat, you can find Mandus inciting arguments such as Tabs vs Spaces and mumbling about his excitement about the cloud, containers and big data. This also earned him the title of Application Platform Lead within the Amazon Web Services Partner Solution Architect team.
Captions: 
	00:00:00,079 --> 00:00:04,319
okay I think that's good with everybody

00:00:03,000 --> 00:00:07,440
that's not in the room now I didn't want

00:00:04,319 --> 00:00:08,760
to be in the room so good afternoon

00:00:07,440 --> 00:00:09,540
everybody thank you very much for

00:00:08,760 --> 00:00:12,420
joining us today

00:00:09,540 --> 00:00:13,980
or joining me today I know it's the last

00:00:12,420 --> 00:00:16,529
session of the day which is usually the

00:00:13,980 --> 00:00:18,180
most difficult session because you're

00:00:16,529 --> 00:00:20,490
tired of all the breakouts to churn

00:00:18,180 --> 00:00:22,289
about throughout the day it's also after

00:00:20,490 --> 00:00:25,080
lunch so the food is settled and you've

00:00:22,289 --> 00:00:26,930
begun in logic so I really appreciate

00:00:25,080 --> 00:00:30,029
you taking the time to be here and

00:00:26,930 --> 00:00:32,099
listen to what we have to say so I want

00:00:30,029 --> 00:00:35,219
to talk about Cloud Foundry on AWS and

00:00:32,099 --> 00:00:37,980
what really brought this on is we had a

00:00:35,219 --> 00:00:41,399
lot of customers that we're asking us

00:00:37,980 --> 00:00:44,600
about how do you customers become

00:00:41,399 --> 00:00:48,809
winners on AWS what makes a successful

00:00:44,600 --> 00:00:52,260
customer on AWS and one of the examples

00:00:48,809 --> 00:00:56,309
that always get brought up is someone

00:00:52,260 --> 00:01:00,149
like Airbnb so how does Airbnb become a

00:00:56,309 --> 00:01:02,850
first-class AWS citizen and be able to

00:01:00,149 --> 00:01:05,250
do and disrupt their industry in the way

00:01:02,850 --> 00:01:08,180
that they did and we kind of bring this

00:01:05,250 --> 00:01:10,740
down to three pillars that any customer

00:01:08,180 --> 00:01:13,140
really needs to adopt in order to become

00:01:10,740 --> 00:01:14,760
successful and become cloud native and

00:01:13,140 --> 00:01:16,740
I'll speak about cloud native in a

00:01:14,760 --> 00:01:20,930
second but these three pillars are

00:01:16,740 --> 00:01:23,549
elasticity agility and availability a

00:01:20,930 --> 00:01:25,979
customer needs that ability to

00:01:23,549 --> 00:01:28,530
elastically scale up and down when they

00:01:25,979 --> 00:01:31,259
need you the reason for that is firstly

00:01:28,530 --> 00:01:33,420
on demand how can you get the demand to

00:01:31,259 --> 00:01:36,420
your customers as the morning creases

00:01:33,420 --> 00:01:38,790
and match that demand but also not over

00:01:36,420 --> 00:01:41,430
provision and overspend when you don't

00:01:38,790 --> 00:01:44,729
need that capacity so how do you grow

00:01:41,430 --> 00:01:47,430
and shrink dynamically and effectively

00:01:44,729 --> 00:01:50,610
without needing a large Operations team

00:01:47,430 --> 00:01:53,189
to complete to consistently be there how

00:01:50,610 --> 00:01:55,549
do you how do you become agile where you

00:01:53,189 --> 00:01:58,460
can go from the inception of a new idea

00:01:55,549 --> 00:02:01,259
into the development of that idea and

00:01:58,460 --> 00:02:04,710
delivering that idea in production as a

00:02:01,259 --> 00:02:09,270
feature or a new product within a matter

00:02:04,710 --> 00:02:11,940
of days as opposed to months and how do

00:02:09,270 --> 00:02:13,600
you build all of this in a platform that

00:02:11,940 --> 00:02:18,420
allows you to be 100

00:02:13,600 --> 00:02:21,850
st. available or nearly 100% available

00:02:18,420 --> 00:02:23,530
so Airbnb is the best example that we

00:02:21,850 --> 00:02:25,720
always bring up when we talk about this

00:02:23,530 --> 00:02:28,060
and not only have they been able to

00:02:25,720 --> 00:02:30,580
build a platform that is so successful

00:02:28,060 --> 00:02:35,410
they do it with an Operations team of

00:02:30,580 --> 00:02:37,810
merely five people a five man operations

00:02:35,410 --> 00:02:42,310
team that gives them the ability to do

00:02:37,810 --> 00:02:44,470
millions of reservations per night they

00:02:42,310 --> 00:02:48,100
iterate and release new features on a

00:02:44,470 --> 00:02:50,560
bi-weekly cadence and they're able to

00:02:48,100 --> 00:02:52,990
create an environment and a user

00:02:50,560 --> 00:02:55,840
experience that keeps letting customers

00:02:52,990 --> 00:02:57,430
come back because they're able to focus

00:02:55,840 --> 00:02:59,830
on their business and their business

00:02:57,430 --> 00:03:02,220
model and what brings value to their

00:02:59,830 --> 00:03:05,080
customers without needing to worry about

00:03:02,220 --> 00:03:08,140
things like database management or

00:03:05,080 --> 00:03:12,490
scaling out their application they have

00:03:08,140 --> 00:03:17,350
achieved this by creating a cloud native

00:03:12,490 --> 00:03:20,110
pattern so we talked about cloud native

00:03:17,350 --> 00:03:22,300
very oftenly in the industry it's become

00:03:20,110 --> 00:03:23,680
one of those words that if you hear it

00:03:22,300 --> 00:03:25,360
you kind of get a shudder because you're

00:03:23,680 --> 00:03:27,550
excited but then you break out in a cold

00:03:25,360 --> 00:03:31,930
sweat because you don't know how to do

00:03:27,550 --> 00:03:34,630
it right but cloud native is nothing

00:03:31,930 --> 00:03:39,450
more than a collection of the right

00:03:34,630 --> 00:03:43,330
patterns an adoption of processes

00:03:39,450 --> 00:03:46,150
methodologies and tools combined in the

00:03:43,330 --> 00:03:48,970
right way to give you the three pillars

00:03:46,150 --> 00:03:51,850
I just mentioned to get the ls

00:03:48,970 --> 00:03:55,120
elasticity the agility and the high

00:03:51,850 --> 00:03:57,840
availability using these patterns

00:03:55,120 --> 00:04:01,300
correctly allows you to effortlessly

00:03:57,840 --> 00:04:05,440
scale and contribute to your business

00:04:01,300 --> 00:04:07,090
value companies like a B&B have achieved

00:04:05,440 --> 00:04:10,300
this by adopting some of our native

00:04:07,090 --> 00:04:13,050
service applications they've got a very

00:04:10,300 --> 00:04:15,640
unique containerized implementation

00:04:13,050 --> 00:04:17,350
adopting containers and using those to

00:04:15,640 --> 00:04:19,720
ship it across their environments in

00:04:17,350 --> 00:04:22,060
order for them to adhere to security

00:04:19,720 --> 00:04:24,810
measures uptime and processing plat

00:04:22,060 --> 00:04:24,810
patterns

00:04:25,420 --> 00:04:32,780
every pattern is unique to the business

00:04:28,850 --> 00:04:34,760
that runs that pattern cloud native or a

00:04:32,780 --> 00:04:37,370
cloud native pattern to one business

00:04:34,760 --> 00:04:40,280
does not necessarily mean that it's the

00:04:37,370 --> 00:04:42,950
same pattern for someone else the tools

00:04:40,280 --> 00:04:46,820
that you use do not need to be the same

00:04:42,950 --> 00:04:48,920
tools that someone else uses a very

00:04:46,820 --> 00:04:51,440
effective pattern is to use a

00:04:48,920 --> 00:04:53,060
combination of strong DevOps mechanisms

00:04:51,440 --> 00:04:54,740
that essentially takes you from

00:04:53,060 --> 00:04:57,650
developing or giving a developer

00:04:54,740 --> 00:05:00,470
experience that's unified from the from

00:04:57,650 --> 00:05:03,620
his laptop or his developing machine all

00:05:00,470 --> 00:05:07,340
the way through into production give the

00:05:03,620 --> 00:05:09,320
developer the power to control not only

00:05:07,340 --> 00:05:11,420
the code that is writing but also the

00:05:09,320 --> 00:05:14,600
environment and the dependencies that

00:05:11,420 --> 00:05:16,310
that code will operate in that allows

00:05:14,600 --> 00:05:18,710
the developer to have freedom and

00:05:16,310 --> 00:05:20,870
creativity into the work that he's doing

00:05:18,710 --> 00:05:23,300
it allows him to not worry about

00:05:20,870 --> 00:05:25,640
limitations that might be imposed on him

00:05:23,300 --> 00:05:29,150
later in the cycle buying operations or

00:05:25,640 --> 00:05:31,670
a security team take that code and that

00:05:29,150 --> 00:05:33,560
definition that he that he explains in

00:05:31,670 --> 00:05:36,080
inside of his code of requirements that

00:05:33,560 --> 00:05:39,590
he needs to do and automate that through

00:05:36,080 --> 00:05:41,450
a CI see the engine that regresses and

00:05:39,590 --> 00:05:44,720
make sure that it adheres to business

00:05:41,450 --> 00:05:46,970
policies that it does inspection on

00:05:44,720 --> 00:05:49,490
libraries to make sure that it conforms

00:05:46,970 --> 00:05:51,230
to the right libraries and security

00:05:49,490 --> 00:05:53,930
principles that gets enforced by the

00:05:51,230 --> 00:05:57,080
security team a lot of our customers

00:05:53,930 --> 00:05:59,360
come to us and say we know we want to go

00:05:57,080 --> 00:06:01,790
and have something a DevOps pipeline or

00:05:59,360 --> 00:06:04,610
we want to use something that allows us

00:06:01,790 --> 00:06:06,260
to iterate faster but if we get stuck at

00:06:04,610 --> 00:06:08,270
the security team the security team

00:06:06,260 --> 00:06:10,130
where our developers are now doing agile

00:06:08,270 --> 00:06:11,330
they're developing applications they're

00:06:10,130 --> 00:06:12,860
pushing it into the source code our

00:06:11,330 --> 00:06:15,770
pipelines are picking it up but our

00:06:12,860 --> 00:06:17,900
security teams are still using three

00:06:15,770 --> 00:06:20,150
weeks three months or even as much as a

00:06:17,900 --> 00:06:24,560
year to review that application before

00:06:20,150 --> 00:06:27,860
we can go to production using a strong

00:06:24,560 --> 00:06:31,400
set of integrations in your CI CD

00:06:27,860 --> 00:06:33,950
practice you can automate many of your

00:06:31,400 --> 00:06:36,260
security tasks and review tasks that

00:06:33,950 --> 00:06:38,420
already do does library scanning and

00:06:36,260 --> 00:06:40,580
gives that value in that power

00:06:38,420 --> 00:06:43,070
to the developer and doesn't allow them

00:06:40,580 --> 00:06:46,280
to be blocked by security review a

00:06:43,070 --> 00:06:49,880
simple practice where security team goes

00:06:46,280 --> 00:06:52,970
and investigates libraries that are

00:06:49,880 --> 00:06:55,550
available in repositories like NPM or

00:06:52,970 --> 00:06:56,990
compose or any of those package

00:06:55,550 --> 00:06:58,060
management solutions for development

00:06:56,990 --> 00:07:01,670
tools like Newgate

00:06:58,060 --> 00:07:03,350
so copying that source code and storing

00:07:01,670 --> 00:07:04,840
them in a local repository for

00:07:03,350 --> 00:07:06,800
consumption within their environment

00:07:04,840 --> 00:07:09,830
accelerates the development and the

00:07:06,800 --> 00:07:12,410
delivery for customers and amazon.com we

00:07:09,830 --> 00:07:14,480
have thousands of third-party open

00:07:12,410 --> 00:07:17,450
source libraries that we develop against

00:07:14,480 --> 00:07:19,940
that our security team has already white

00:07:17,450 --> 00:07:22,490
labeled reviewed and made available and

00:07:19,940 --> 00:07:25,580
we can consume that library in as many

00:07:22,490 --> 00:07:27,680
projects as we want without needing to

00:07:25,580 --> 00:07:30,230
go through a subsequent review every

00:07:27,680 --> 00:07:32,950
time we use it because we lock a version

00:07:30,230 --> 00:07:35,750
of that source code into our repository

00:07:32,950 --> 00:07:37,850
bold against it and then consume that

00:07:35,750 --> 00:07:40,610
version and that source code that has

00:07:37,850 --> 00:07:42,740
been built in our applications so you

00:07:40,610 --> 00:07:45,020
need to be able to build all of that and

00:07:42,740 --> 00:07:48,800
deliver that sell to your basic

00:07:45,020 --> 00:07:51,500
environment this baton doesn't change

00:07:48,800 --> 00:07:53,350
whether you go from or deploy to

00:07:51,500 --> 00:07:55,280
something like a physical environment

00:07:53,350 --> 00:07:58,640
on-premises or into the cloud

00:07:55,280 --> 00:08:04,820
environment so a cloud native approach

00:07:58,640 --> 00:08:06,590
is all about the pattern so how do we

00:08:04,820 --> 00:08:09,980
take this cloud native approach this

00:08:06,590 --> 00:08:12,590
pattern that I just spoke about and how

00:08:09,980 --> 00:08:15,800
does Cloud Foundry really benefit me in

00:08:12,590 --> 00:08:19,850
getting to that point of being a cloud

00:08:15,800 --> 00:08:23,510
native citizen well to begin off with

00:08:19,850 --> 00:08:25,520
Cloud Foundry provides you with many of

00:08:23,510 --> 00:08:28,760
the guardrails that I already spoke

00:08:25,520 --> 00:08:31,250
about out-of-the-box CloudFront foundry

00:08:28,760 --> 00:08:33,950
provides you with the basic tool sets to

00:08:31,250 --> 00:08:35,530
give this pattern a production and

00:08:33,950 --> 00:08:37,970
productive run with inside your company

00:08:35,530 --> 00:08:40,370
it provides you with the central

00:08:37,970 --> 00:08:43,130
platform for administration this means

00:08:40,370 --> 00:08:44,930
that every developer every ops engineer

00:08:43,130 --> 00:08:47,030
every administrator and business

00:08:44,930 --> 00:08:49,400
reviewer has a central place that they

00:08:47,030 --> 00:08:50,690
can have a top-down view of all the

00:08:49,400 --> 00:08:52,250
applications and the

00:08:50,690 --> 00:08:56,000
that your business brings linked to the

00:08:52,250 --> 00:08:58,010
environment it already sets up dynamic

00:08:56,000 --> 00:09:00,380
routing for you which allows that that

00:08:58,010 --> 00:09:03,410
atomic unit that cell that the developer

00:09:00,380 --> 00:09:07,010
bolt can be deployed to any section of

00:09:03,410 --> 00:09:09,260
your infrastructure and requests to that

00:09:07,010 --> 00:09:12,530
would be dynamically routed so in a

00:09:09,260 --> 00:09:14,540
micro services world if one team builds

00:09:12,530 --> 00:09:16,580
for example of an authentication module

00:09:14,540 --> 00:09:17,930
that can be rigged or consumed by a

00:09:16,580 --> 00:09:18,590
different product inside of your

00:09:17,930 --> 00:09:20,780
business

00:09:18,590 --> 00:09:22,280
routing between those operations will

00:09:20,780 --> 00:09:25,930
already be handled to you on the

00:09:22,280 --> 00:09:28,190
platform layer on the platform level

00:09:25,930 --> 00:09:31,460
role based access control for

00:09:28,190 --> 00:09:33,320
deployments is a key requirement for all

00:09:31,460 --> 00:09:37,190
of our customers that are employing

00:09:33,320 --> 00:09:39,920
applications into the cloud they need an

00:09:37,190 --> 00:09:42,290
extension of I am and be able to limit

00:09:39,920 --> 00:09:45,200
different teams from accessing different

00:09:42,290 --> 00:09:47,860
in enterprise data sets or different

00:09:45,200 --> 00:09:51,050
applications and also for an audit trail

00:09:47,860 --> 00:09:53,260
they need to know when a user deployed a

00:09:51,050 --> 00:09:57,410
specific application or made a specific

00:09:53,260 --> 00:09:59,510
push for example so Cloud Foundry

00:09:57,410 --> 00:10:02,000
already has that in the independently or

00:09:59,510 --> 00:10:04,520
ingrain inside of the platform itself it

00:10:02,000 --> 00:10:07,550
provides you with an audible auditable

00:10:04,520 --> 00:10:09,800
trail of the love of who did what and

00:10:07,550 --> 00:10:11,420
who would did win and also by limiting

00:10:09,800 --> 00:10:15,080
access to different parts and portions

00:10:11,420 --> 00:10:18,020
of the business in one layer you don't

00:10:15,080 --> 00:10:20,990
have to setup a complicated multi

00:10:18,020 --> 00:10:24,290
account strategy to control what

00:10:20,990 --> 00:10:25,640
applications run where and then obvious

00:10:24,290 --> 00:10:27,530
the application security

00:10:25,640 --> 00:10:28,940
that's the ICD practice with

00:10:27,530 --> 00:10:30,770
integrations through something like corn

00:10:28,940 --> 00:10:34,520
course and doing library scanning

00:10:30,770 --> 00:10:35,990
scanning with all of the the third-party

00:10:34,520 --> 00:10:38,120
software modules and parties in the

00:10:35,990 --> 00:10:40,070
ecosystem that's available makes it

00:10:38,120 --> 00:10:42,800
possible for you to unblock at that

00:10:40,070 --> 00:10:47,420
layer change requests can natively be

00:10:42,800 --> 00:10:50,150
incorporated into the platform right so

00:10:47,420 --> 00:10:52,190
we have this benefit of Cloud Foundry we

00:10:50,150 --> 00:10:55,280
can make it easy for you to get to that

00:10:52,190 --> 00:10:57,830
cloud native pattern but how can we even

00:10:55,280 --> 00:11:00,350
make your life a little bit better by

00:10:57,830 --> 00:11:04,760
running this Cloud Foundry platform on

00:11:00,350 --> 00:11:08,600
yes well we have something called the

00:11:04,760 --> 00:11:11,900
AWS service broker and reinvent in 2017

00:11:08,600 --> 00:11:14,660
we released the AWS service program the

00:11:11,900 --> 00:11:16,010
aw service broker is both or based on

00:11:14,660 --> 00:11:18,620
the open service broker API

00:11:16,010 --> 00:11:22,910
specification and it integrates

00:11:18,620 --> 00:11:26,000
seamlessly with all platforms that

00:11:22,910 --> 00:11:29,750
support that specification most notably

00:11:26,000 --> 00:11:31,760
cloud foundry so in 2017 at reinvent we

00:11:29,750 --> 00:11:34,870
launched the service worker with 10

00:11:31,760 --> 00:11:38,420
services the ones at the bottom right

00:11:34,870 --> 00:11:40,940
early this month in April 2018 we

00:11:38,420 --> 00:11:42,800
launched an additional six services and

00:11:40,940 --> 00:11:44,300
they actually have a seventh and an

00:11:42,800 --> 00:11:47,200
eighth service that's not listed on top

00:11:44,300 --> 00:11:50,660
of that we will be adding more services

00:11:47,200 --> 00:11:53,180
every four months and growing this list

00:11:50,660 --> 00:11:55,370
of service brokers as our customer

00:11:53,180 --> 00:11:59,240
demands come in and more customers

00:11:55,370 --> 00:12:01,760
require more of our services so what

00:11:59,240 --> 00:12:11,210
does this mean what does the service

00:12:01,760 --> 00:12:15,850
broker allow you to do in AWS right so

00:12:11,210 --> 00:12:21,230
Pinterest is an interesting case study

00:12:15,850 --> 00:12:25,160
Pinterest has an architecture they have

00:12:21,230 --> 00:12:28,370
a pattern where they use native AWS

00:12:25,160 --> 00:12:31,850
services to allow them to do millions of

00:12:28,370 --> 00:12:34,910
pins a day and how do they do this they

00:12:31,850 --> 00:12:39,620
provision resources that gets deployed

00:12:34,910 --> 00:12:42,020
and stored on s3 and then they use low

00:12:39,620 --> 00:12:44,870
latency meta text extraction using a

00:12:42,020 --> 00:12:46,790
service for that we use for example a

00:12:44,870 --> 00:12:49,520
new service that we launched lately

00:12:46,790 --> 00:12:52,970
called Amazon recognition so they have

00:12:49,520 --> 00:12:55,940
these static images opens that gets

00:12:52,970 --> 00:12:59,360
posted by a user millions of expens a

00:12:55,940 --> 00:13:01,850
day and then they extract meta text

00:12:59,360 --> 00:13:04,340
information from those pins using our

00:13:01,850 --> 00:13:06,440
amazon recognition service so the amazon

00:13:04,340 --> 00:13:08,810
recognition service is a machine

00:13:06,440 --> 00:13:11,330
learning based service that investigates

00:13:08,810 --> 00:13:13,520
and looks at a photo and then returns

00:13:11,330 --> 00:13:14,120
information like oh there's a car in

00:13:13,520 --> 00:13:15,559
this picture

00:13:14,120 --> 00:13:18,259
there's a woman in this picture there's

00:13:15,559 --> 00:13:20,509
a kid with a skateboard jumping over a

00:13:18,259 --> 00:13:23,209
bench in this picture this is probably a

00:13:20,509 --> 00:13:24,350
picture of a bunch of people at a park

00:13:23,209 --> 00:13:26,749
right

00:13:24,350 --> 00:13:30,019
it creates meets a context for that

00:13:26,749 --> 00:13:32,589
image interesting goes and they create a

00:13:30,019 --> 00:13:35,059
complete catalogue of this image and

00:13:32,589 --> 00:13:39,079
categorize it and then use that to

00:13:35,059 --> 00:13:40,149
better target images and suggestions to

00:13:39,079 --> 00:13:44,269
their users

00:13:40,149 --> 00:13:47,689
now their pattern uses native AWS

00:13:44,269 --> 00:13:50,569
services they consume native AWS

00:13:47,689 --> 00:13:52,999
services and if you've noticed Amazon

00:13:50,569 --> 00:13:55,850
recognition is one of the services that

00:13:52,999 --> 00:13:59,480
you can use and provision within the aw

00:13:55,850 --> 00:14:02,899
service broker so using the AWS service

00:13:59,480 --> 00:14:05,620
broker and running Cloud Foundry your

00:14:02,899 --> 00:14:08,720
developer can build an application and

00:14:05,620 --> 00:14:10,699
request the Amazon recognition service

00:14:08,720 --> 00:14:13,430
to be provisioned and set up on your

00:14:10,699 --> 00:14:15,800
behalf the developer never needs to

00:14:13,430 --> 00:14:19,670
login to the analyst console he never

00:14:15,800 --> 00:14:21,829
needs to look look at the API manually

00:14:19,670 --> 00:14:22,970
using the CLI or create a bash script to

00:14:21,829 --> 00:14:26,569
do it on his behalf

00:14:22,970 --> 00:14:28,879
he just exposes the service or request

00:14:26,569 --> 00:14:31,220
the service as an internal service in

00:14:28,879 --> 00:14:33,709
cart foundry the platform goes sets it

00:14:31,220 --> 00:14:36,439
up provision that creates the required

00:14:33,709 --> 00:14:38,029
roles and credentials that needs to what

00:14:36,439 --> 00:14:41,089
the developer needs to access it and

00:14:38,029 --> 00:14:43,040
binds that to the application the

00:14:41,089 --> 00:14:44,959
developer then pushes his information or

00:14:43,040 --> 00:14:47,929
uploads his file to something like s3

00:14:44,959 --> 00:14:51,050
and triggers that run against the image

00:14:47,929 --> 00:14:53,269
at no point does this developer ever

00:14:51,050 --> 00:14:54,110
leave that unified experience that we

00:14:53,269 --> 00:14:57,350
spoke about earlier

00:14:54,110 --> 00:15:00,199
he stole stays with inside cloud foundry

00:14:57,350 --> 00:15:02,120
yet he has the benefit of a managed

00:15:00,199 --> 00:15:05,149
machine learning process that can do

00:15:02,120 --> 00:15:08,689
millions of low latency image

00:15:05,149 --> 00:15:11,449
recognitions per second that value

00:15:08,689 --> 00:15:12,829
allows your developer to focus on the

00:15:11,449 --> 00:15:14,899
value of that application that is

00:15:12,829 --> 00:15:17,569
building without needing to go and

00:15:14,899 --> 00:15:20,089
deploy a convoluted MX net deployment

00:15:17,569 --> 00:15:22,519
inside of CF or an open CV image

00:15:20,089 --> 00:15:24,949
recognition algorithm into CF and focus

00:15:22,519 --> 00:15:25,950
on building that machine live machine

00:15:24,949 --> 00:15:29,170
learning

00:15:25,950 --> 00:15:31,420
his focus stays on how do I make that

00:15:29,170 --> 00:15:34,930
image recognition that was provided to

00:15:31,420 --> 00:15:37,120
me by AWS a better integral part of my

00:15:34,930 --> 00:15:39,760
cut of my application and how can I

00:15:37,120 --> 00:15:42,610
focus on giving my user a better user

00:15:39,760 --> 00:15:43,990
experience the developer doesn't want to

00:15:42,610 --> 00:15:46,090
worry about the machine learning

00:15:43,990 --> 00:15:49,960
algorithm that detecting all of the meta

00:15:46,090 --> 00:15:51,910
information they want to focus on the

00:15:49,960 --> 00:15:55,900
user experience and the value that his

00:15:51,910 --> 00:15:57,490
product is giving to the customer so now

00:15:55,900 --> 00:15:59,230
you have a platform that provides you

00:15:57,490 --> 00:16:01,330
with the controls and the mechanisms and

00:15:59,230 --> 00:16:03,250
the automation and Cloud Foundry but

00:16:01,330 --> 00:16:05,320
also the integration through the AWS

00:16:03,250 --> 00:16:08,650
service broker to allow you to use

00:16:05,320 --> 00:16:14,650
native services to focus on the value of

00:16:08,650 --> 00:16:16,630
your business so it always is about the

00:16:14,650 --> 00:16:20,680
patterns and you can have multiple

00:16:16,630 --> 00:16:22,420
different patterns a very basic example

00:16:20,680 --> 00:16:24,820
of a pattern is that you have a

00:16:22,420 --> 00:16:26,650
monolithic application that requires

00:16:24,820 --> 00:16:30,040
something simple like in my sequel

00:16:26,650 --> 00:16:31,420
database this database gets provisioned

00:16:30,040 --> 00:16:32,890
by the end of this service broker and

00:16:31,420 --> 00:16:34,810
injects the connection string the

00:16:32,890 --> 00:16:37,600
username and the password inside of

00:16:34,810 --> 00:16:39,790
Cloud Foundry that application can be

00:16:37,600 --> 00:16:41,740
shipped across multiple environments and

00:16:39,790 --> 00:16:43,900
used with it an on-premises my sequel

00:16:41,740 --> 00:16:46,450
database and RDS my sequel database or

00:16:43,900 --> 00:16:50,020
any version of a my sequel database

00:16:46,450 --> 00:16:51,790
that's the basic pattern but we have

00:16:50,020 --> 00:16:54,760
seen that our customers are truly

00:16:51,790 --> 00:16:57,310
getting value from using our native

00:16:54,760 --> 00:16:59,080
services so let's look at this patent

00:16:57,310 --> 00:17:02,940
for example right this is the pattern

00:16:59,080 --> 00:17:05,590
that I just spoke about you have AWS

00:17:02,940 --> 00:17:07,240
services providing the basic

00:17:05,590 --> 00:17:08,560
infrastructure so you're running your a

00:17:07,240 --> 00:17:12,010
device or your Cloud Foundry

00:17:08,560 --> 00:17:14,230
distribution within AWS across multiple

00:17:12,010 --> 00:17:16,180
availability zones and for you that

00:17:14,230 --> 00:17:18,700
flows that aren't familiar with what an

00:17:16,180 --> 00:17:21,580
Amazon availability zone is an Amazon

00:17:18,700 --> 00:17:24,960
availability zone cons one availability

00:17:21,580 --> 00:17:28,000
zone consists of multiple data centers

00:17:24,960 --> 00:17:30,880
multiple data centers spaced out in a

00:17:28,000 --> 00:17:34,000
geographic area for for redundancy and

00:17:30,880 --> 00:17:38,020
for for security and for uptime right so

00:17:34,000 --> 00:17:39,670
in that configuration your deployment is

00:17:38,020 --> 00:17:42,370
not only sitting in one or two data

00:17:39,670 --> 00:17:45,660
centers it is span across at least three

00:17:42,370 --> 00:17:48,310
or four data centers in front of that

00:17:45,660 --> 00:17:51,640
you set one of our application load

00:17:48,310 --> 00:17:53,950
balancers are highly available strongly

00:17:51,640 --> 00:17:55,840
consistent and persistent load balancer

00:17:53,950 --> 00:18:00,040
that can handle thousands of requests

00:17:55,840 --> 00:18:02,110
per second you deliver your applications

00:18:00,040 --> 00:18:03,940
through this platform your API and

00:18:02,110 --> 00:18:07,030
everything 4cf all of that goes through

00:18:03,940 --> 00:18:09,460
this load balancer how do you secure

00:18:07,030 --> 00:18:11,950
that load balancer do you have to buy

00:18:09,460 --> 00:18:14,110
something like an f5 instance do you

00:18:11,950 --> 00:18:17,590
have to go and set up your own IP table

00:18:14,110 --> 00:18:20,230
rules using AWS you can use and leverage

00:18:17,590 --> 00:18:24,000
services like AWS Web Application

00:18:20,230 --> 00:18:26,980
Firewall that allows you to protect

00:18:24,000 --> 00:18:29,740
transparently against things like sequel

00:18:26,980 --> 00:18:31,030
injection into your api's how do you

00:18:29,740 --> 00:18:35,050
protect against DDoS

00:18:31,030 --> 00:18:39,190
with a convoluted and complex setup of

00:18:35,050 --> 00:18:42,160
your DNS no you deploy a W shield in

00:18:39,190 --> 00:18:45,610
front of your applications aw shield

00:18:42,160 --> 00:18:49,810
will effectively protect you from DDoS

00:18:45,610 --> 00:18:53,980
app DDoS attacks your persistent data

00:18:49,810 --> 00:18:56,400
storage layers the actual infrastructure

00:18:53,980 --> 00:18:58,360
layer that you want to run against for

00:18:56,400 --> 00:19:00,730
Boston for all of those type of things

00:18:58,360 --> 00:19:03,580
and for the director do you launch that

00:19:00,730 --> 00:19:05,980
Y sequel database on an ec2 instance no

00:19:03,580 --> 00:19:07,990
you use an RDS instance with a read

00:19:05,980 --> 00:19:10,870
replica in a second region which allows

00:19:07,990 --> 00:19:13,590
you near hundred percent uptime and RPO

00:19:10,870 --> 00:19:16,810
of a couple of minutes right

00:19:13,590 --> 00:19:20,140
what about storage across multiple nodes

00:19:16,810 --> 00:19:24,370
and application nodes the AWS EFS system

00:19:20,140 --> 00:19:26,410
is a native NFS capable storage layer

00:19:24,370 --> 00:19:29,200
that you can connect to all of your

00:19:26,410 --> 00:19:31,870
application nodes and store data across

00:19:29,200 --> 00:19:34,540
these layers to share things like

00:19:31,870 --> 00:19:40,140
session State for example between those

00:19:34,540 --> 00:19:43,090
nodes so that's just to get CF really

00:19:40,140 --> 00:19:45,790
running well and very secured and and in

00:19:43,090 --> 00:19:48,640
a good practice on AWS now you can put

00:19:45,790 --> 00:19:49,389
something like AWS cloud front in front

00:19:48,640 --> 00:19:51,339
of that

00:19:49,389 --> 00:19:54,459
and ship all of your application

00:19:51,339 --> 00:19:59,229
endpoints to the closest age node to

00:19:54,459 --> 00:20:01,450
your user to one of any of our nodes

00:19:59,229 --> 00:20:05,200
that have been deployed in regions all

00:20:01,450 --> 00:20:08,259
around the world inside of your

00:20:05,200 --> 00:20:12,849
application nodes you have bulb packs

00:20:08,259 --> 00:20:15,609
that have integrated the AWS SDK so a

00:20:12,849 --> 00:20:17,529
developer requires only that bulb back

00:20:15,609 --> 00:20:19,450
it's already configured with the

00:20:17,529 --> 00:20:23,529
appropriate analyst hdk whether that's

00:20:19,450 --> 00:20:25,779
nodejs Go Python PHP or any of the

00:20:23,529 --> 00:20:27,549
available languages and he simply

00:20:25,779 --> 00:20:30,459
provisions the recognition service

00:20:27,549 --> 00:20:32,079
through the service program the SDK has

00:20:30,459 --> 00:20:34,959
all the information that he needs to

00:20:32,079 --> 00:20:38,679
make the API calls he makes those API

00:20:34,959 --> 00:20:40,659
calls to push data to s3 and therefore

00:20:38,679 --> 00:20:42,369
after that push that into recognition

00:20:40,659 --> 00:20:45,639
and get the meta information back and

00:20:42,369 --> 00:20:47,440
store that data in his application so

00:20:45,639 --> 00:20:50,889
this pattern is probably one of the most

00:20:47,440 --> 00:20:54,190
complete cloud native patterns that you

00:20:50,889 --> 00:20:56,229
can have without needing to build

00:20:54,190 --> 00:20:58,659
anything substantially different from

00:20:56,229 --> 00:21:00,459
what you ran on-premises none of the

00:20:58,659 --> 00:21:02,229
value of cloud from cloud formation

00:21:00,459 --> 00:21:04,659
Cloud Foundry has been lost in this

00:21:02,229 --> 00:21:08,079
pattern this pattern is still a cloud

00:21:04,659 --> 00:21:10,509
foundry workload you have only added

00:21:08,079 --> 00:21:12,849
value to it by transparently adding

00:21:10,509 --> 00:21:16,239
other layers of native alw service to it

00:21:12,849 --> 00:21:20,139
in this pattern you will have a higher

00:21:16,239 --> 00:21:23,229
performance higher uptime and more

00:21:20,139 --> 00:21:25,450
security then without the additional

00:21:23,229 --> 00:21:27,219
layers your iteration will be faster

00:21:25,450 --> 00:21:30,339
because your developers will be able to

00:21:27,219 --> 00:21:32,109
iterate and deploy quicker and focus on

00:21:30,339 --> 00:21:34,629
the application for your business value

00:21:32,109 --> 00:21:36,940
as opposed to building out their own

00:21:34,629 --> 00:21:43,329
services like an image recognition

00:21:36,940 --> 00:21:45,759
service but what if I also want to make

00:21:43,329 --> 00:21:47,979
sure that I don't just want to store or

00:21:45,759 --> 00:21:50,169
use the average Rick the Amazon

00:21:47,979 --> 00:21:52,809
recognition service maybe I do want to

00:21:50,169 --> 00:21:54,940
create a on-premises or deployment

00:21:52,809 --> 00:21:57,579
that's capable of deploying on-premises

00:21:54,940 --> 00:22:00,759
and this open CV application that

00:21:57,579 --> 00:22:03,140
processes images on Prem right what

00:22:00,759 --> 00:22:04,970
happens then what if I do want to invest

00:22:03,140 --> 00:22:06,800
that kind of architecture that my

00:22:04,970 --> 00:22:09,400
application can essentially switch out

00:22:06,800 --> 00:22:14,030
between recognition and my own open CV

00:22:09,400 --> 00:22:17,750
application this is a problem that has

00:22:14,030 --> 00:22:20,330
already been solved back in 2014 and

00:22:17,750 --> 00:22:23,960
that architecture is called the ports

00:22:20,330 --> 00:22:25,490
and adapters architecture the principle

00:22:23,960 --> 00:22:28,570
behind the ports and adapters

00:22:25,490 --> 00:22:32,600
architecture or the Hasmoneans

00:22:28,570 --> 00:22:34,070
architecture is that as a part of the

00:22:32,600 --> 00:22:36,560
MVC class-based

00:22:34,070 --> 00:22:38,690
and functional based execution each

00:22:36,560 --> 00:22:42,440
adapter that writes to a persistent

00:22:38,690 --> 00:22:46,010
function or feature works as an adapter

00:22:42,440 --> 00:22:48,620
works as a port and each port then slots

00:22:46,010 --> 00:22:52,250
into an adapter for consumption so your

00:22:48,620 --> 00:22:54,890
application has a unified model let's

00:22:52,250 --> 00:22:57,740
call that image or image processing

00:22:54,890 --> 00:22:59,780
model you then have a background

00:22:57,740 --> 00:23:02,090
function that's processed dot or image

00:22:59,780 --> 00:23:04,970
dot process and you can switch that

00:23:02,090 --> 00:23:07,550
adapter based on a config flag saying if

00:23:04,970 --> 00:23:11,180
I am detected that I'm running within a

00:23:07,550 --> 00:23:14,690
WS process this image using image

00:23:11,180 --> 00:23:18,140
recognition if I am running on premises

00:23:14,690 --> 00:23:21,320
process this using my on premises

00:23:18,140 --> 00:23:25,490
deployment I don't want to go too deep

00:23:21,320 --> 00:23:27,740
into water ports and adapters framework

00:23:25,490 --> 00:23:30,110
looks like but we will be processing or

00:23:27,740 --> 00:23:31,850
we will be posting a blog soon that goes

00:23:30,110 --> 00:23:35,090
into depths a little bit more on how you

00:23:31,850 --> 00:23:38,270
can actually use multiple services to

00:23:35,090 --> 00:23:43,220
achieve the same result in an abstracted

00:23:38,270 --> 00:23:45,530
way so keep an eye out for that blog and

00:23:43,220 --> 00:23:48,440
that's all I have to say today I have a

00:23:45,530 --> 00:23:49,940
couple of minutes for you to ask me any

00:23:48,440 --> 00:23:51,950
questions if you have any questions and

00:23:49,940 --> 00:23:53,900
I would just once again want to thank

00:23:51,950 --> 00:23:56,840
you for taking the time at the end of

00:23:53,900 --> 00:24:00,220
your day to come out and hear what I had

00:23:56,840 --> 00:24:00,220
to say thank you very much

00:24:00,280 --> 00:24:03,849
[Applause]

00:24:06,609 --> 00:24:11,029
the enemy's service program so the AWS

00:24:09,350 --> 00:24:14,359
service broker is an open source project

00:24:11,029 --> 00:24:17,320
you can access it in our AWS labs github

00:24:14,359 --> 00:24:20,419
repository so you can go to github.com

00:24:17,320 --> 00:24:22,399
/aw it's labs and if you inside that

00:24:20,419 --> 00:24:24,529
repository you do a search for service

00:24:22,399 --> 00:24:33,980
broker you will find the resources in

00:24:24,529 --> 00:24:46,519
their service - broker yeah is there any

00:24:33,980 --> 00:24:48,230
other questions yeah yeah we have V PC V

00:24:46,519 --> 00:24:51,139
PC endpoints for many of our services

00:24:48,230 --> 00:24:52,820
I'm going to lie to you if I have to

00:24:51,139 --> 00:24:54,769
tell you exactly which all the services

00:24:52,820 --> 00:24:57,350
are we also recently launched something

00:24:54,769 --> 00:24:59,090
called private link which also exposes a

00:24:57,350 --> 00:25:02,359
couple of other services and even allows

00:24:59,090 --> 00:25:04,820
you to create a V PC endpoint of your

00:25:02,359 --> 00:25:05,989
own for a service that you want to

00:25:04,820 --> 00:25:08,119
deliver so if you have multiple accounts

00:25:05,989 --> 00:25:09,919
you could create a private link that

00:25:08,119 --> 00:25:11,809
essentially that it gets exposed in

00:25:09,919 --> 00:25:14,330
another account or another V PC that can

00:25:11,809 --> 00:25:16,220
be consumed internally which is a pretty

00:25:14,330 --> 00:25:17,419
cool feature and we actually have some

00:25:16,220 --> 00:25:19,850
customers that are playing around with

00:25:17,419 --> 00:25:22,009
that to expose things like API is on a

00:25:19,850 --> 00:25:23,720
platform level and things like that but

00:25:22,009 --> 00:25:25,789
yes we have many of those services and

00:25:23,720 --> 00:25:29,119
it natively and frictionlessly works

00:25:25,789 --> 00:25:30,649
with with these integrations so if you

00:25:29,119 --> 00:25:32,690
want to store data on h3 and never

00:25:30,649 --> 00:25:36,320
actually have to egress out of the out

00:25:32,690 --> 00:25:38,149
of the the private network then a V PC

00:25:36,320 --> 00:25:41,809
endpoint works completely you can also

00:25:38,149 --> 00:25:45,230
manage access to the data inside of that

00:25:41,809 --> 00:25:49,269
that endpoint by applying an iamb policy

00:25:45,230 --> 00:25:49,269
to that actually be seen

00:25:51,680 --> 00:25:57,580
any other questions great thank you very

00:25:55,160 --> 00:25:57,580
much everyone

00:25:57,930 --> 00:26:00,559

YouTube URL: https://www.youtube.com/watch?v=nZ7p6HqBGE0


