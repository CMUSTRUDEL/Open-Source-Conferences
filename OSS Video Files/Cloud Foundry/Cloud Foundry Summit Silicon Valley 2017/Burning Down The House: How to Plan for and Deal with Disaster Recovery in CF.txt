Title: Burning Down The House: How to Plan for and Deal with Disaster Recovery in CF
Publication date: 2017-06-21
Playlist: Cloud Foundry Summit Silicon Valley 2017
Description: 
	Burning Down The House: How to Plan for and Deal with Disaster Recovery in CF - Jatin Naik & Therese Stowell, Pivotal    

People make mistakes. Hardware fails. Hurricanes, volcanoes, acts of God. You’ve installed Cloud Foundry and are running 1000 mission-critical apps. You’re the operator and the health of CF is on your head, how do you sleep at night? 
Backups? But.. is backup an outdated term in a cloud native world? What does it mean to back up Cloud Foundry? What components are involved? What about data services? 
In this talk Therese and Jatin will dig into CF internals to map out what’s required to make reliable backups of Cloud Foundry and app data. They will talk through the challenges of engineering a robust b+r solution that works across IaaSs. They will look at different tools and approaches in use now, and discuss issues like downtime and consistency across multiple components. Finally they will present their proposed BOSH-based framework for backup and recovery plus other potential solutions, from disk imaging to event streams, while considering potential modifications to CF to make it more backup-able.

Jatin Naik
Jatin Naik is an Engineer on the Cloud Foundry team at Pivotal, working on backup and restore. He is interested in BOSH and Cloud Foundry, and spoke at CF Summit Europe last year on an intro to writing an app for CF and a multi-cloud CPI.

Therese Stowell
Pivotal
Staff Product Manager
London
Websitepivotal.io
Therese Stowell is Product Manager at Pivotal. She has worked in the software industry for 20+ years as programmer, interface designer, and product manager. She worked on Windows, developing the command line environment, founded a successful social enterprise, and was part of a startup team to win a Nesta Open Data Institute £40,000 prize. She also has an MA in Fine Art. She has extensive speaking experience, most recently moderating a panel on implicit bias in technology and speaking about metrics in Cloud Foundry at the PaaS LOPUG.
Captions: 
	00:00:00,030 --> 00:00:05,190
hello and welcome to burning burning

00:00:03,600 --> 00:00:07,230
down the house this will be a quick

00:00:05,190 --> 00:00:10,630
tutorial on how you burn down your data

00:00:07,230 --> 00:00:11,780
center and hopefully can put it back

00:00:10,630 --> 00:00:15,330
[Music]

00:00:11,780 --> 00:00:17,400
this is Therese I'm Jatin we are from

00:00:15,330 --> 00:00:20,910
the backup and restore team at pivotal

00:00:17,400 --> 00:00:23,880
and we are here to talk about the backup

00:00:20,910 --> 00:00:27,269
and restore of cloud foundry in this

00:00:23,880 --> 00:00:28,769
talk we are gonna cover how can you back

00:00:27,269 --> 00:00:31,260
up and restore cloud foundry what are

00:00:28,769 --> 00:00:32,099
the current approaches of doing that the

00:00:31,260 --> 00:00:34,170
current issues

00:00:32,099 --> 00:00:36,570
what is our solution to the problem and

00:00:34,170 --> 00:00:37,610
the future of backup and restore for

00:00:36,570 --> 00:00:41,430
cloud foundry

00:00:37,610 --> 00:00:42,329
so why backup and restore cloud foundry

00:00:41,430 --> 00:00:44,610
in the first place

00:00:42,329 --> 00:00:47,280
so companies run mission critical

00:00:44,610 --> 00:00:48,660
workloads on cloud foundry and a part as

00:00:47,280 --> 00:00:50,610
a part of running mission critical

00:00:48,660 --> 00:00:53,940
workloads on cloud foundry involves

00:00:50,610 --> 00:00:55,530
planning for when things go wrong we

00:00:53,940 --> 00:00:57,270
have seen one of the first things

00:00:55,530 --> 00:00:58,730
operators do when they install cloud

00:00:57,270 --> 00:01:00,930
foundry in their organization is

00:00:58,730 --> 00:01:04,769
installed some kind of for backup and

00:01:00,930 --> 00:01:07,229
restore solution app downtime can is a

00:01:04,769 --> 00:01:10,729
pretty big deal for companies as it can

00:01:07,229 --> 00:01:13,740
lead to loss of revenue or customers and

00:01:10,729 --> 00:01:15,150
in a lot of organizations cloud foundry

00:01:13,740 --> 00:01:17,970
is actually embedded into the

00:01:15,150 --> 00:01:20,040
development lifecycle so if when cloud

00:01:17,970 --> 00:01:22,259
foundry goes down you actually are

00:01:20,040 --> 00:01:25,860
losing the ability to develop your

00:01:22,259 --> 00:01:27,689
applications so what can go wrong what

00:01:25,860 --> 00:01:32,450
what are people planning up planning out

00:01:27,689 --> 00:01:35,310
for so there can be things like

00:01:32,450 --> 00:01:38,280
recovering from a failed upgrade where

00:01:35,310 --> 00:01:40,020
you have your upgrade has left your

00:01:38,280 --> 00:01:42,600
foundry in a bad place and you want to

00:01:40,020 --> 00:01:44,070
go back to a point in time it can be

00:01:42,600 --> 00:01:47,430
things like user errors in which

00:01:44,070 --> 00:01:49,170
administrator accidentally deletes user

00:01:47,430 --> 00:01:51,299
critical information an example of that

00:01:49,170 --> 00:01:53,420
is the gait lab meltdown in which like

00:01:51,299 --> 00:01:56,070
requests could not be served because

00:01:53,420 --> 00:01:59,460
part of the needed data were

00:01:56,070 --> 00:02:03,060
accidentally deleted there can be issues

00:01:59,460 --> 00:02:04,979
like data corruptions and like nowadays

00:02:03,060 --> 00:02:08,000
there are security vectors like

00:02:04,979 --> 00:02:11,819
ransomware which can affect applications

00:02:08,000 --> 00:02:13,620
by the way the easiest fix for a

00:02:11,819 --> 00:02:18,120
ransomware situation is to

00:02:13,620 --> 00:02:20,099
repave and put your data back and we

00:02:18,120 --> 00:02:22,409
also have failures like ass and

00:02:20,099 --> 00:02:26,909
corruption and when your data center

00:02:22,409 --> 00:02:29,220
floods we we are gonna target the data

00:02:26,909 --> 00:02:32,129
center failure as our use case because

00:02:29,220 --> 00:02:35,579
it's like the superset of all the all

00:02:32,129 --> 00:02:37,019
the use cases that we see over here so

00:02:35,579 --> 00:02:39,930
what does it mean to backup cloud

00:02:37,019 --> 00:02:42,930
foundry so cloud foundry itself is a

00:02:39,930 --> 00:02:44,280
complicated distributed system and to

00:02:42,930 --> 00:02:47,640
back-up plan foundry we have to

00:02:44,280 --> 00:02:49,640
essentially need to extract the state

00:02:47,640 --> 00:02:52,739
that it has accumulated over it's

00:02:49,640 --> 00:02:54,299
running lifecycle so that when we put

00:02:52,739 --> 00:02:58,379
the state back and flip the switch back

00:02:54,299 --> 00:03:00,180
on the it should resume operations so

00:02:58,379 --> 00:03:01,470
what it really means is try to get

00:03:00,180 --> 00:03:03,989
enough information out of your

00:03:01,470 --> 00:03:05,940
installation so that when you put it

00:03:03,989 --> 00:03:09,569
back during restore times your app

00:03:05,940 --> 00:03:11,489
should come back up so that that begs

00:03:09,569 --> 00:03:14,340
the question where does the state in

00:03:11,489 --> 00:03:15,989
Cloud Foundry live and what state do we

00:03:14,340 --> 00:03:19,230
need to capture to create an effective

00:03:15,989 --> 00:03:21,419
backup of cloud foundry so to explore

00:03:19,230 --> 00:03:23,989
that let's look at how cloud foundry

00:03:21,419 --> 00:03:27,030
stores its state during its life cycle

00:03:23,989 --> 00:03:29,730
so imagine a cloud foundry with just two

00:03:27,030 --> 00:03:32,639
components a cloud controller and a few

00:03:29,730 --> 00:03:34,980
diogo cells when an app developer pushes

00:03:32,639 --> 00:03:37,859
their application to cloud foundry

00:03:34,980 --> 00:03:39,870
what they do is Cloud Foundry will

00:03:37,859 --> 00:03:43,169
insert metadata about the application in

00:03:39,870 --> 00:03:45,180
the database and it will it will save

00:03:43,169 --> 00:03:48,660
the source of the application itself in

00:03:45,180 --> 00:03:51,180
a blob store the as you can see there

00:03:48,660 --> 00:03:54,690
are clock this this subset of Cloud

00:03:51,180 --> 00:03:57,000
Foundry uses two data sources a database

00:03:54,690 --> 00:04:00,329
to store up its records and blob store

00:03:57,000 --> 00:04:02,790
to save files when when Cloud Foundry is

00:04:00,329 --> 00:04:05,609
deployed it is pre-populated with build

00:04:02,790 --> 00:04:11,180
backs built backs are programs which

00:04:05,609 --> 00:04:15,299
will convert source corpse to containers

00:04:11,180 --> 00:04:17,519
after that the cloud controller will ask

00:04:15,299 --> 00:04:19,709
the Diego one of the Diego's cells to

00:04:17,519 --> 00:04:22,349
stage the application what that would do

00:04:19,709 --> 00:04:26,539
is fetch the build PACs and the source

00:04:22,349 --> 00:04:27,690
from the blob store and create a droplet

00:04:26,539 --> 00:04:29,190
then

00:04:27,690 --> 00:04:30,930
we'll save the droplet inside the

00:04:29,190 --> 00:04:32,520
database save the droplet metadata

00:04:30,930 --> 00:04:35,010
inside a database and save the actual

00:04:32,520 --> 00:04:37,020
droplet in the blob store and in the

00:04:35,010 --> 00:04:39,450
last stage the cloud controller will ask

00:04:37,020 --> 00:04:40,920
the one of Diego cells to run the

00:04:39,450 --> 00:04:42,480
application which will pull the trap

00:04:40,920 --> 00:04:46,050
late' out of the blobstore

00:04:42,480 --> 00:04:47,670
and start to run it so what we can see

00:04:46,050 --> 00:04:49,650
here is there is some referential

00:04:47,670 --> 00:04:51,930
integrity between the blobstore

00:04:49,650 --> 00:04:55,020
and the database so there are there are

00:04:51,930 --> 00:04:59,490
references going out from the database

00:04:55,020 --> 00:05:01,710
to the blobs and if we do a restore and

00:04:59,490 --> 00:05:05,790
these records don't line up your apps

00:05:01,710 --> 00:05:07,230
might not come back so these are not the

00:05:05,790 --> 00:05:09,240
only two components in Cloud Foundry

00:05:07,230 --> 00:05:11,850
there are other components and they have

00:05:09,240 --> 00:05:14,600
their own data source and these data

00:05:11,850 --> 00:05:18,120
source might sources might have similar

00:05:14,600 --> 00:05:24,600
referential integrity concerns across

00:05:18,120 --> 00:05:27,480
data source so so if we put back all the

00:05:24,600 --> 00:05:29,810
state that we saw before will we do we

00:05:27,480 --> 00:05:32,220
have enough information to do a restore

00:05:29,810 --> 00:05:33,290
well the state that we saw before is

00:05:32,220 --> 00:05:36,720
just part of the puzzle

00:05:33,290 --> 00:05:38,010
there is also Cloud Foundry itself like

00:05:36,720 --> 00:05:41,250
the Cloud Foundry the software which

00:05:38,010 --> 00:05:44,640
runs and deploys your applications so

00:05:41,250 --> 00:05:49,940
where does that live so to find that out

00:05:44,640 --> 00:05:53,250
we need to go deeper so Cloud Foundry is

00:05:49,940 --> 00:05:56,640
deployed and managed on a control plane

00:05:53,250 --> 00:05:58,830
provided by Bosh Bosh is responsible for

00:05:56,640 --> 00:06:01,590
actually deploying Cloud Foundry all the

00:05:58,830 --> 00:06:02,669
information about the software will be

00:06:01,590 --> 00:06:05,460
stored in Bosh

00:06:02,669 --> 00:06:07,710
so let's take a look at how dataflow

00:06:05,460 --> 00:06:10,260
looks like in a Bosh director the Bosh

00:06:07,710 --> 00:06:13,530
director also has two data sources so it

00:06:10,260 --> 00:06:16,950
has a record store and a blob store when

00:06:13,530 --> 00:06:18,870
an operator uploads a release to the

00:06:16,950 --> 00:06:20,490
Bosh director the wash director will

00:06:18,870 --> 00:06:22,919
save some metadata about the release in

00:06:20,490 --> 00:06:25,560
a in a database and save the actual

00:06:22,919 --> 00:06:27,690
software in a blob store when the

00:06:25,560 --> 00:06:31,020
operator asks a wash to deploy that

00:06:27,690 --> 00:06:32,970
software it would save the some metadata

00:06:31,020 --> 00:06:35,070
about the deployment in its record store

00:06:32,970 --> 00:06:37,970
after that it will fetch information

00:06:35,070 --> 00:06:40,600
about the releases and and the

00:06:37,970 --> 00:06:42,100
deployment from the record store and

00:06:40,600 --> 00:06:44,110
get the actual software from the lobster

00:06:42,100 --> 00:06:47,020
and try to create a VM out of it

00:06:44,110 --> 00:06:50,980
so we see this pattern again where we

00:06:47,020 --> 00:06:53,050
have a software trying to get an

00:06:50,980 --> 00:06:55,540
information across which is stored

00:06:53,050 --> 00:06:57,550
across data stores and there is some

00:06:55,540 --> 00:07:02,950
referential integrity which grows across

00:06:57,550 --> 00:07:06,400
different components so Bosch is also

00:07:02,950 --> 00:07:10,240
used to deploy other things like data

00:07:06,400 --> 00:07:12,010
services apps actually connect to these

00:07:10,240 --> 00:07:15,850
data services which are deployed on

00:07:12,010 --> 00:07:18,220
Bosch - to save user data and them so

00:07:15,850 --> 00:07:20,530
like if you want to take an effective

00:07:18,220 --> 00:07:23,290
backup of the entire platform the data

00:07:20,530 --> 00:07:26,020
landscape kind of looks like this so

00:07:23,290 --> 00:07:27,010
what would what do we do when parts of

00:07:26,020 --> 00:07:30,340
this scatter on fire

00:07:27,010 --> 00:07:32,410
so currently like when we started with

00:07:30,340 --> 00:07:35,290
the backup and restore initiative we

00:07:32,410 --> 00:07:38,080
looked at what companies currently do

00:07:35,290 --> 00:07:40,720
for solving this problem and we realized

00:07:38,080 --> 00:07:43,630
there are a lot of localized solutions

00:07:40,720 --> 00:07:45,910
for solving this problem the first class

00:07:43,630 --> 00:07:48,820
of tools that we discovered worse like

00:07:45,910 --> 00:07:52,060
tools that know a lot about where state

00:07:48,820 --> 00:07:54,850
in cloud foundry exists so these are

00:07:52,060 --> 00:07:57,640
tools which we'll go in and we'll know

00:07:54,850 --> 00:07:59,530
how where which databases are used by

00:07:57,640 --> 00:08:01,450
which components in cloud foundry will

00:07:59,530 --> 00:08:03,970
do sequel dumps or likely just copy

00:08:01,450 --> 00:08:07,960
files which they think are required to

00:08:03,970 --> 00:08:10,240
create a good backup of Laura foundry so

00:08:07,960 --> 00:08:13,960
the the primary problem with tools like

00:08:10,240 --> 00:08:16,030
this is a fragility so cloud foundry for

00:08:13,960 --> 00:08:19,660
a software of its size moves critical

00:08:16,030 --> 00:08:22,240
frequently and whenever it changes how

00:08:19,660 --> 00:08:25,720
how it stores data internally these

00:08:22,240 --> 00:08:28,570
tools start to break and so which means

00:08:25,720 --> 00:08:30,970
that like to create a tool which will

00:08:28,570 --> 00:08:34,180
always back up a color foundry you need

00:08:30,970 --> 00:08:35,740
to change the tool to know about a lot

00:08:34,180 --> 00:08:37,599
of versions of cloud foundry and how

00:08:35,740 --> 00:08:41,860
data was represented across those

00:08:37,599 --> 00:08:44,530
versions the other thing is consistency

00:08:41,860 --> 00:08:47,620
so tools like this cannot just backup

00:08:44,530 --> 00:08:50,740
individual databases they need effective

00:08:47,620 --> 00:08:52,900
snapshot across those databases so which

00:08:50,740 --> 00:08:54,340
means that they somehow have to stop the

00:08:52,900 --> 00:08:57,100
the cloud controller

00:08:54,340 --> 00:08:59,350
to take a consistent backup across these

00:08:57,100 --> 00:09:03,000
data stores so that when they when the

00:08:59,350 --> 00:09:05,530
restore happens the the records match up

00:09:03,000 --> 00:09:10,750
which means that these tools are

00:09:05,530 --> 00:09:15,550
susceptible to down times the other

00:09:10,750 --> 00:09:17,200
class of solutions is running to cloud

00:09:15,550 --> 00:09:21,130
boundaries an active active or active

00:09:17,200 --> 00:09:23,190
passive mode in which like essentially

00:09:21,130 --> 00:09:25,510
build tooling around pushing

00:09:23,190 --> 00:09:28,050
applications to to foundations and

00:09:25,510 --> 00:09:30,100
maintaining trying to maintain then

00:09:28,050 --> 00:09:32,530
trying to maintain the state and them

00:09:30,100 --> 00:09:34,390
consistently so the issue with this is

00:09:32,530 --> 00:09:35,980
it's really difficult to get right

00:09:34,390 --> 00:09:40,450
because it's like you have a consistency

00:09:35,980 --> 00:09:41,860
problem now across boundaries and it it

00:09:40,450 --> 00:09:43,450
essentially doubles your cost because

00:09:41,860 --> 00:09:46,570
you are running to production like

00:09:43,450 --> 00:09:48,850
environments and it does not medicate

00:09:46,570 --> 00:09:52,000
against things like the malware vectors

00:09:48,850 --> 00:09:53,740
that we saw before the other class of

00:09:52,000 --> 00:09:56,590
solutions people are trying out is I a

00:09:53,740 --> 00:09:57,730
snapshot so some summarizes will give

00:09:56,590 --> 00:09:59,620
you your functionality which will

00:09:57,730 --> 00:10:04,090
snapshot persistent disks or have been

00:09:59,620 --> 00:10:05,680
attached to instances so this is the

00:10:04,090 --> 00:10:07,510
issue with this is it's like pulling

00:10:05,680 --> 00:10:08,560
data from underneath the application not

00:10:07,510 --> 00:10:10,420
everything might have been splashed

00:10:08,560 --> 00:10:12,730
flushed down to disk when the snapshot

00:10:10,420 --> 00:10:14,500
was taken and the other interesting bit

00:10:12,730 --> 00:10:17,830
is not all state is needed for a

00:10:14,500 --> 00:10:19,720
successful backup like only a subset of

00:10:17,830 --> 00:10:23,500
the information on disk might be

00:10:19,720 --> 00:10:26,320
required to do a successful restore the

00:10:23,500 --> 00:10:30,790
other strangely popular opinion is to do

00:10:26,320 --> 00:10:33,430
nothing so a lot of operators which

00:10:30,790 --> 00:10:35,680
script out things like platform

00:10:33,430 --> 00:10:38,440
configuration like creating augs users

00:10:35,680 --> 00:10:40,720
in spaces and in case of a disaster you

00:10:38,440 --> 00:10:42,490
would create this structure again and

00:10:40,720 --> 00:10:44,770
ask your app developers to repost your

00:10:42,490 --> 00:10:47,290
applications the problem with this

00:10:44,770 --> 00:10:49,330
essentially is the recovery time might

00:10:47,290 --> 00:10:52,060
be really long because not all teams

00:10:49,330 --> 00:10:57,340
have really good pipelines to push their

00:10:52,060 --> 00:10:59,700
apps in again and so the the other

00:10:57,340 --> 00:11:01,780
common themes that we see across

00:10:59,700 --> 00:11:03,400
organizations is people are worrying

00:11:01,780 --> 00:11:05,800
about things like how do they do

00:11:03,400 --> 00:11:08,200
artifact management how do they encrypt

00:11:05,800 --> 00:11:10,030
the backups that they get a

00:11:08,200 --> 00:11:11,680
when they should take the backups how

00:11:10,030 --> 00:11:13,810
long should they retain their artifacts

00:11:11,680 --> 00:11:15,970
should they do complete backups or

00:11:13,810 --> 00:11:17,320
partial backups which means that all the

00:11:15,970 --> 00:11:19,570
components that we saw before should

00:11:17,320 --> 00:11:21,550
date back up all of them all the time or

00:11:19,570 --> 00:11:24,700
can they get away with just backing up

00:11:21,550 --> 00:11:27,640
some of them some of the times should

00:11:24,700 --> 00:11:29,950
they do incremental backups so which

00:11:27,640 --> 00:11:32,190
leaves us with a problem state a problem

00:11:29,950 --> 00:11:35,320
space which looks kind of like this

00:11:32,190 --> 00:11:41,710
Therese is will take us through how we

00:11:35,320 --> 00:11:44,440
have been solving this problem so we

00:11:41,710 --> 00:11:46,810
took everything we learned and we did a

00:11:44,440 --> 00:11:48,940
lot of customer research and a lot of

00:11:46,810 --> 00:11:51,370
research into current solutions and we

00:11:48,940 --> 00:11:54,070
came up with a new model of backup and

00:11:51,370 --> 00:11:57,730
restore to try to address the the issues

00:11:54,070 --> 00:12:03,400
that we found so if we start with this

00:11:57,730 --> 00:12:04,870
problem space and we divided the issues

00:12:03,400 --> 00:12:06,430
into two categories

00:12:04,870 --> 00:12:09,340
on the one hand there's how to

00:12:06,430 --> 00:12:11,050
orchestrate the backup so that concern

00:12:09,340 --> 00:12:13,450
that that includes all the concerns

00:12:11,050 --> 00:12:16,600
around the backup consistency across

00:12:13,450 --> 00:12:18,640
backups encryption scheduling artifact

00:12:16,600 --> 00:12:20,860
management things like that and the

00:12:18,640 --> 00:12:22,300
other category is how to do the backup

00:12:20,860 --> 00:12:25,390
how to actually do the backup in the

00:12:22,300 --> 00:12:27,190
restore so things like database versions

00:12:25,390 --> 00:12:29,410
what is the data that needs to be backed

00:12:27,190 --> 00:12:35,200
up and what is the correct procedure for

00:12:29,410 --> 00:12:40,030
a backup or for for a restore we assign

00:12:35,200 --> 00:12:42,070
these two categories roles the one the

00:12:40,030 --> 00:12:44,350
first role is the orchestrator and the

00:12:42,070 --> 00:12:46,660
other role is the component and we've

00:12:44,350 --> 00:12:51,510
crafted a contract between these two

00:12:46,660 --> 00:12:54,850
roles so we have a backup and restore

00:12:51,510 --> 00:12:56,530
framework based on a contract that sets

00:12:54,850 --> 00:12:58,930
out the requirements for the

00:12:56,530 --> 00:13:00,880
orchestrator and the component and now

00:12:58,930 --> 00:13:05,710
I'm going to go into the details of that

00:13:00,880 --> 00:13:08,170
contract so the orchestrator expects the

00:13:05,710 --> 00:13:10,000
component to implement hooks to do the

00:13:08,170 --> 00:13:13,030
backup and restore the hooks are locked

00:13:10,000 --> 00:13:15,220
back up and unlock the first requirement

00:13:13,030 --> 00:13:16,960
for the orchestrator is that it has to

00:13:15,220 --> 00:13:23,430
trigger these hooks in this prescribed

00:13:16,960 --> 00:13:23,430
order and the only hook for restore is

00:13:24,120 --> 00:13:29,620
so the orchestrator is responsible for

00:13:27,040 --> 00:13:31,990
moving the backup artifacts after a

00:13:29,620 --> 00:13:33,940
backup is taken and putting the

00:13:31,990 --> 00:13:37,839
artifacts in the right place before a

00:13:33,940 --> 00:13:40,389
restore now the other side of the

00:13:37,839 --> 00:13:42,610
contract is the component so if a

00:13:40,389 --> 00:13:44,949
component wants to be backed up and

00:13:42,610 --> 00:13:47,170
restored it has to implement the backup

00:13:44,949 --> 00:13:50,829
and restore hooks which are locked back

00:13:47,170 --> 00:13:53,050
up unlock and restore and so the

00:13:50,829 --> 00:13:55,870
component each of those hooks is

00:13:53,050 --> 00:13:58,209
actually optional so the component will

00:13:55,870 --> 00:14:01,750
implement the hooks that are appropriate

00:13:58,209 --> 00:14:04,959
to it so if it's a database that needs

00:14:01,750 --> 00:14:07,750
to be locked I mean that needs to be has

00:14:04,959 --> 00:14:11,139
have rights topped it might implement

00:14:07,750 --> 00:14:13,089
lock and then backup would be like you

00:14:11,139 --> 00:14:15,420
know PG dump or something and then

00:14:13,089 --> 00:14:19,300
unlock would start up the database again

00:14:15,420 --> 00:14:20,709
and so you know and then if if nothing

00:14:19,300 --> 00:14:22,360
needed to be backed up it wouldn't

00:14:20,709 --> 00:14:27,220
implement any scripts at all and that

00:14:22,360 --> 00:14:29,260
would be fine nothing would happen so

00:14:27,220 --> 00:14:31,480
the component this is the other side of

00:14:29,260 --> 00:14:33,639
the contract has to put the backup

00:14:31,480 --> 00:14:36,779
artifact in a particular location so

00:14:33,639 --> 00:14:40,180
that the orchestrator can find it and

00:14:36,779 --> 00:14:42,730
take artifact the artifacts to be

00:14:40,180 --> 00:14:45,600
restored from a particular place so that

00:14:42,730 --> 00:14:48,910
it can be received from the orchestrator

00:14:45,600 --> 00:14:54,880
so here's all the things right thus it's

00:14:48,910 --> 00:14:57,730
a pretty simple contract so the contract

00:14:54,880 --> 00:15:00,850
separates backup orchestration from the

00:14:57,730 --> 00:15:03,279
actual backup and restore logic the

00:15:00,850 --> 00:15:05,949
backup hooks are written by component

00:15:03,279 --> 00:15:08,139
authors who are best placed to determine

00:15:05,949 --> 00:15:10,360
which parts of component state are

00:15:08,139 --> 00:15:12,220
relevant for a backup and what the

00:15:10,360 --> 00:15:14,800
correct behavior for a backup and

00:15:12,220 --> 00:15:17,019
restore is because the hooks are

00:15:14,800 --> 00:15:19,510
packaged with the component they can

00:15:17,019 --> 00:15:21,730
change as the component changes so they

00:15:19,510 --> 00:15:24,819
should never be out of sync with how the

00:15:21,730 --> 00:15:27,250
data is stored you'll see that the the

00:15:24,819 --> 00:15:29,170
contract addresses the fragility and the

00:15:27,250 --> 00:15:31,269
compatibility issues that we saw with

00:15:29,170 --> 00:15:33,310
tools that reach under the hood by

00:15:31,269 --> 00:15:34,850
encapsulating the backup and restore

00:15:33,310 --> 00:15:38,779
knowledge

00:15:34,850 --> 00:15:41,480
component so there are there are

00:15:38,779 --> 00:15:44,329
benefits to this contract firstly

00:15:41,480 --> 00:15:46,130
consistency so asking the component to

00:15:44,329 --> 00:15:48,319
do its own backup means that it can

00:15:46,130 --> 00:15:50,870
flush data to disk can stop database

00:15:48,319 --> 00:15:53,720
writes whatever it needs to do to take a

00:15:50,870 --> 00:15:56,120
consistent backup and locking across

00:15:53,720 --> 00:15:58,430
components prevent state mutations

00:15:56,120 --> 00:16:01,670
during backup enabling again consistent

00:15:58,430 --> 00:16:02,420
backups secondly backup and restore can

00:16:01,670 --> 00:16:05,089
be smart

00:16:02,420 --> 00:16:07,790
so processing and filtering data in any

00:16:05,089 --> 00:16:10,699
way that makes sense so the backup

00:16:07,790 --> 00:16:12,889
script might do encryption a restore

00:16:10,699 --> 00:16:15,440
script might regenerate credentials and

00:16:12,889 --> 00:16:17,839
the orchestrator actually doesn't care

00:16:15,440 --> 00:16:20,839
what the what the script does as long as

00:16:17,839 --> 00:16:23,050
it abides by the contract another

00:16:20,839 --> 00:16:26,660
benefit to the contract is that the

00:16:23,050 --> 00:16:29,569
artefact transfer happens after the

00:16:26,660 --> 00:16:32,180
unlock step and so it minimizes the

00:16:29,569 --> 00:16:38,930
amount of downtime that that a lock

00:16:32,180 --> 00:16:41,569
might incur so I've talked about this

00:16:38,930 --> 00:16:44,779
the contract in the abstract we have

00:16:41,569 --> 00:16:45,319
implemented the contract as bosh backup

00:16:44,779 --> 00:16:48,319
and restore

00:16:45,319 --> 00:16:51,529
so in our implementation the

00:16:48,319 --> 00:16:55,370
orchestrator is a binary called bbr a

00:16:51,529 --> 00:16:58,160
component is a boss job and the unit of

00:16:55,370 --> 00:17:00,170
backup is a Bosch deployment so you'll

00:16:58,160 --> 00:17:02,750
notice that we've tied to we're tied to

00:17:00,170 --> 00:17:05,720
and have leveraged Bosch concepts well

00:17:02,750 --> 00:17:08,209
why is that all come all components in

00:17:05,720 --> 00:17:09,980
cloud foundry or Bosch deployments the

00:17:08,209 --> 00:17:12,799
Bosch director is a Bosch release and

00:17:09,980 --> 00:17:18,500
for an operator a Bosch deployment is

00:17:12,799 --> 00:17:21,589
the logical unit of a backup so the

00:17:18,500 --> 00:17:24,890
orchestrator is the bbr binary it's a

00:17:21,589 --> 00:17:26,689
CLI that runs on a jump box it knows how

00:17:24,890 --> 00:17:29,330
to trigger the backup and restore hooks

00:17:26,689 --> 00:17:35,150
on both bosch deployments and Bosch

00:17:29,330 --> 00:17:38,240
directors so bbr can backup the state

00:17:35,150 --> 00:17:40,490
and the software in cloud foundry but a

00:17:38,240 --> 00:17:44,000
restore doesn't do a redeploy so it's

00:17:40,490 --> 00:17:46,280
kind of like my sequel restore and I'm

00:17:44,000 --> 00:17:48,120
really we are very excited to announce

00:17:46,280 --> 00:17:53,300
that we have some

00:17:48,120 --> 00:17:53,300
to the CF extensions to open-source bbr

00:17:53,360 --> 00:17:58,620
okay so earlier Jatin showed you where

00:17:56,160 --> 00:18:00,630
state is stored in cloud foundry so what

00:17:58,620 --> 00:18:07,050
I'm gonna do now is gonna walk through

00:18:00,630 --> 00:18:11,190
how BB our backs that stayed up so

00:18:07,050 --> 00:18:15,240
there's there's our operator calls back

00:18:11,190 --> 00:18:18,750
up and then BB our will first identify

00:18:15,240 --> 00:18:21,809
any loc scripts so the cloud controller

00:18:18,750 --> 00:18:24,750
implements lock the lock script and what

00:18:21,809 --> 00:18:26,690
it does is it stops the CF API so to

00:18:24,750 --> 00:18:29,790
avoid mutating state during the backup

00:18:26,690 --> 00:18:32,880
then bbr will call all of the backup

00:18:29,790 --> 00:18:35,520
scripts so the backup scripts will

00:18:32,880 --> 00:18:37,170
generate backup artifacts for each job

00:18:35,520 --> 00:18:40,020
in the deployment each job that

00:18:37,170 --> 00:18:43,920
implements backup for Cloud Foundry will

00:18:40,020 --> 00:18:48,480
end up with the UA a database CCD be the

00:18:43,920 --> 00:18:52,050
blobstore and some other things then bbr

00:18:48,480 --> 00:18:56,550
will call the unlock script and finally

00:18:52,050 --> 00:18:59,510
BB r will copy all the artifacts back to

00:18:56,550 --> 00:19:03,390
the jump box and the backup is finished

00:18:59,510 --> 00:19:07,380
okay so I'm gonna give you a demo me and

00:19:03,390 --> 00:19:11,030
live demos not so good so it's a video

00:19:07,380 --> 00:19:16,530
it's sped up but it is the real thing

00:19:11,030 --> 00:19:18,750
here we go now I hope that this is okay

00:19:16,530 --> 00:19:20,370
so I hope you can it's big enough to see

00:19:18,750 --> 00:19:23,340
it so we're backing up the Boche

00:19:20,370 --> 00:19:26,130
director here you can see that I'm gonna

00:19:23,340 --> 00:19:28,679
come over here so I can see and it

00:19:26,130 --> 00:19:32,550
identifies which scripts are there it's

00:19:28,679 --> 00:19:34,320
backing up cred hub the director the

00:19:32,550 --> 00:19:40,080
director database the blobstore

00:19:34,320 --> 00:19:42,150
and uaa and then it's done some it does

00:19:40,080 --> 00:19:45,630
check sums it does validity checks and

00:19:42,150 --> 00:19:47,490
then it creates a tar file and then if

00:19:45,630 --> 00:19:50,940
you look it also creates a metadata file

00:19:47,490 --> 00:19:53,250
which has each of the artifacts that it

00:19:50,940 --> 00:19:56,250
created and also the start and finish

00:19:53,250 --> 00:19:58,440
time of the backup and then you can see

00:19:56,250 --> 00:20:02,480
that we ran restore and we've put all

00:19:58,440 --> 00:20:02,480
that data back into Bosh

00:20:04,430 --> 00:20:11,220
so in order for bbr we'll only can only

00:20:08,910 --> 00:20:14,280
backup and restore things that implement

00:20:11,220 --> 00:20:15,810
the backup and restore scripts and here

00:20:14,280 --> 00:20:18,660
are the releases that we have at the

00:20:15,810 --> 00:20:21,780
moment we have we can backup and restore

00:20:18,660 --> 00:20:23,870
the boss director cred hub ua a elastic

00:20:21,780 --> 00:20:26,670
runtime which is pivotal Cloud Foundry

00:20:23,870 --> 00:20:28,470
and coming soon we'll have backup and

00:20:26,670 --> 00:20:34,490
restore scripts for open source cloud

00:20:28,470 --> 00:20:36,600
foundry and for data services so BB are

00:20:34,490 --> 00:20:39,930
the the problem that we're trying to

00:20:36,600 --> 00:20:42,990
solve is is this the kind of inner core

00:20:39,930 --> 00:20:44,730
of backup and restore it's creating the

00:20:42,990 --> 00:20:47,340
backup artifact and putting it back

00:20:44,730 --> 00:20:49,290
there you know as we talked about in our

00:20:47,340 --> 00:20:51,630
earlier slide about concerns around

00:20:49,290 --> 00:20:52,590
backup and restore there are a lot of

00:20:51,630 --> 00:20:54,420
other concerns

00:20:52,590 --> 00:20:56,760
so encryption scheduling artifact

00:20:54,420 --> 00:21:02,400
management the you know a lot of other

00:20:56,760 --> 00:21:05,700
things well we have partners and we're

00:21:02,400 --> 00:21:08,100
working with them to integrate bbr with

00:21:05,700 --> 00:21:09,470
external data stores and with automation

00:21:08,100 --> 00:21:12,180
that does things like scheduling

00:21:09,470 --> 00:21:14,160
encryption artifact management and we

00:21:12,180 --> 00:21:16,620
really do welcome collaboration so

00:21:14,160 --> 00:21:19,170
please get in touch if you're interested

00:21:16,620 --> 00:21:24,840
in integrating bbr with your backup and

00:21:19,170 --> 00:21:28,770
restore project we're looking very

00:21:24,840 --> 00:21:31,530
actively how we will need to extend the

00:21:28,770 --> 00:21:34,410
bbr contract to support different backup

00:21:31,530 --> 00:21:37,740
and restore scenarios and to improve

00:21:34,410 --> 00:21:39,960
operability so we're looking at being

00:21:37,740 --> 00:21:42,750
able to run bbr against multiple

00:21:39,960 --> 00:21:45,150
deployments in supporting incremental

00:21:42,750 --> 00:21:47,850
backups points in time recovery external

00:21:45,150 --> 00:21:50,640
data stores and then having a way to

00:21:47,850 --> 00:21:54,060
validate backup artifacts without

00:21:50,640 --> 00:21:58,140
running a restore because that's a very

00:21:54,060 --> 00:22:00,660
expensive thing to do and then as we

00:21:58,140 --> 00:22:04,200
extend the contract will build bbr out

00:22:00,660 --> 00:22:09,450
to match the contract extensions we're

00:22:04,200 --> 00:22:12,240
also looking so bbr uses ssh to run to

00:22:09,450 --> 00:22:15,150
tunnel into the jobs and run the scripts

00:22:12,240 --> 00:22:17,250
what we're looking at is

00:22:15,150 --> 00:22:19,590
triggering those with a Bosch agent in

00:22:17,250 --> 00:22:21,960
the future we're also looking at

00:22:19,590 --> 00:22:24,210
optimizations like calling all of the

00:22:21,960 --> 00:22:30,300
backup scripts in parallel instead of in

00:22:24,210 --> 00:22:32,390
serial when we think about the future of

00:22:30,300 --> 00:22:35,250
backup and restore for Cloud Foundry

00:22:32,390 --> 00:22:38,160
it's really about making Cloud Foundry

00:22:35,250 --> 00:22:42,240
more backup able so doing things like

00:22:38,160 --> 00:22:47,130
adding read-only modes to minimize the

00:22:42,240 --> 00:22:50,720
downtime and trying to minimize the

00:22:47,130 --> 00:22:53,550
amount of references across data stores

00:22:50,720 --> 00:22:56,730
and then in the in the future and this

00:22:53,550 --> 00:22:59,220
is a pretty exciting vision is to change

00:22:56,730 --> 00:23:01,710
the way that state is stored in cloud

00:22:59,220 --> 00:23:04,710
foundry so that it's in an event stream

00:23:01,710 --> 00:23:07,380
so it's basically you can replay all the

00:23:04,710 --> 00:23:13,290
events that have happened to regenerate

00:23:07,380 --> 00:23:14,790
the state so we've talked about Cloud

00:23:13,290 --> 00:23:17,330
Foundry what what it means to backup

00:23:14,790 --> 00:23:19,710
Cloud Foundry the state and the software

00:23:17,330 --> 00:23:21,390
we've talked about the current

00:23:19,710 --> 00:23:23,730
approaches that we've seen the issues

00:23:21,390 --> 00:23:26,540
with those approaches we've talked about

00:23:23,730 --> 00:23:28,580
the bbr contract that we've created

00:23:26,540 --> 00:23:32,220
we've talked about our implementation

00:23:28,580 --> 00:23:33,870
bbr and we've talked about what backup

00:23:32,220 --> 00:23:37,410
and restore might look like in the

00:23:33,870 --> 00:23:39,900
future so I want to say thank you I know

00:23:37,410 --> 00:23:44,460
it's the end of the day and you probably

00:23:39,900 --> 00:23:45,870
want some adult drinks soon we have I

00:23:44,460 --> 00:23:47,670
mean we'll we're going to answer

00:23:45,870 --> 00:23:50,100
questions now I will also say that we'll

00:23:47,670 --> 00:23:52,590
be taking part in the extensions office

00:23:50,100 --> 00:23:54,179
hours tomorrow morning or well tomorrow

00:23:52,590 --> 00:23:57,690
at 12:10

00:23:54,179 --> 00:23:59,700
and hot off the press we have bbr

00:23:57,690 --> 00:24:04,500
stickers so I think every fashionable

00:23:59,700 --> 00:24:07,520
laptop wants one okay so do we let's

00:24:04,500 --> 00:24:07,520
have let's have questions

00:24:13,140 --> 00:24:23,760
I have to say this is the best round of

00:24:20,550 --> 00:24:27,240
applause that we've had pretty good all

00:24:23,760 --> 00:24:28,770
right Matt Whittle

00:24:27,240 --> 00:24:31,740
yeah I'm curious what sort of duration

00:24:28,770 --> 00:24:33,480
you're seeing on the locks just for the

00:24:31,740 --> 00:24:58,980
Cloud Foundry as you backed up but how

00:24:33,480 --> 00:25:02,400
long do those last depends upon the data

00:24:58,980 --> 00:25:04,640
that is there in the MySQL and the

00:25:02,400 --> 00:25:04,640
blobstore

00:25:09,110 --> 00:25:14,790
you're not trying to read it up yet so

00:25:11,990 --> 00:25:17,010
it depends on how big the MySQL

00:25:14,790 --> 00:25:19,680
datastore is so for the block for the

00:25:17,010 --> 00:25:22,230
NFS blobstore we can do stuff like hard

00:25:19,680 --> 00:25:24,330
links where we just link the data link

00:25:22,230 --> 00:25:27,450
the blocks to another directory so that

00:25:24,330 --> 00:25:30,360
the backup utility can copy them off so

00:25:27,450 --> 00:25:34,260
the primary lock time driver for us

00:25:30,360 --> 00:25:37,080
right now is the MySQL dump so for we

00:25:34,260 --> 00:25:42,300
are seeing times like in minutes so it's

00:25:37,080 --> 00:25:49,500
like five to six minutes any other

00:25:42,300 --> 00:25:51,810
questions so kind of interesting is I

00:25:49,500 --> 00:25:53,340
know that down the line you're looking

00:25:51,810 --> 00:25:56,130
at doing the data services as well as

00:25:53,340 --> 00:25:58,230
components there and I we have a lot of

00:25:56,130 --> 00:26:00,300
experience where I work with the my

00:25:58,230 --> 00:26:01,830
sequel data service and I know that they

00:26:00,300 --> 00:26:03,840
actually changed the way that they're

00:26:01,830 --> 00:26:05,070
offering backups is in that front they

00:26:03,840 --> 00:26:07,020
used to do to my sequin up now they're

00:26:05,070 --> 00:26:08,880
actually backing up the actual data

00:26:07,020 --> 00:26:11,820
files themselves is there some sort of

00:26:08,880 --> 00:26:13,470
cross team collaboration there to see

00:26:11,820 --> 00:26:14,700
like maybe why did they go down that

00:26:13,470 --> 00:26:15,900
path because you guys are served in two

00:26:14,700 --> 00:26:17,850
my sequel ones on the cop hundred

00:26:15,900 --> 00:26:19,620
obviously those could be much smaller

00:26:17,850 --> 00:26:21,360
than what is potentially on the data

00:26:19,620 --> 00:26:23,550
services but I know that could speed up

00:26:21,360 --> 00:26:24,840
times so instead of using my sequel dump

00:26:23,550 --> 00:26:27,060
actually backing up the data files

00:26:24,840 --> 00:26:29,010
themselves right so the current

00:26:27,060 --> 00:26:31,530
implementation of the script for blob

00:26:29,010 --> 00:26:34,110
foundry the vertical foundry don't use

00:26:31,530 --> 00:26:37,860
MySQL dump they do use the MySQL

00:26:34,110 --> 00:26:43,020
database mechanism provided by the MySQL

00:26:37,860 --> 00:26:45,030
team and but the point so the whole

00:26:43,020 --> 00:26:47,880
point of the contract is that the teams

00:26:45,030 --> 00:26:49,890
it would be it will be the my sequel

00:26:47,880 --> 00:26:53,460
teams who write the backup and restore

00:26:49,890 --> 00:26:57,620
scripts so the decision about how to

00:26:53,460 --> 00:26:57,620
back it up will be their decision

00:26:57,750 --> 00:27:00,869
[Music]

00:27:04,980 --> 00:27:10,769
thank you so when you implement a lock

00:27:08,279 --> 00:27:13,139
for a specific component does that lock

00:27:10,769 --> 00:27:15,990
also propagate to things that may be

00:27:13,139 --> 00:27:19,279
posting data to those things so if you

00:27:15,990 --> 00:27:21,929
lock a database as part of a component

00:27:19,279 --> 00:27:23,460
well it also locked things that are

00:27:21,929 --> 00:27:28,100
trying to write to that component as

00:27:23,460 --> 00:27:28,100
well no no okay

00:27:28,250 --> 00:27:34,559
okay one more

00:27:30,029 --> 00:27:38,759
all right last question Frank you

00:27:34,559 --> 00:27:42,149
mentioned yeah two questions actually

00:27:38,759 --> 00:27:48,000
which version of PCF is it coming on and

00:27:42,149 --> 00:27:54,649
is it replacing CF ops 111 and over time

00:27:48,000 --> 00:27:54,649
yes thank you everybody thank you

00:28:01,630 --> 00:28:04,900

YouTube URL: https://www.youtube.com/watch?v=HlO9L9iE9T8


