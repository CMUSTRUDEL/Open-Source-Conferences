Title: Do More With Your Apps: Unleashing the Power of the V3 Cloud Controller API
Publication date: 2016-09-30
Playlist: Cloud Foundry Summit Europe 2016
Description: 
	Do More With Your Apps: Unleashing the Power of the V3 Cloud Controller API - Utako Ueda and Dan Wendorf, Pivotal

Some of the biggest problems developers have had with the Cloud Controller API have traditionally revolved around lifecycle management of their apps. The lack of features like version rollbacks, zero downtime deployment, running one-off tasks, simplified database migration, and running multiple processes per application have frustrated many developers.

The CAPI team is working on making all this and more possible with V3 of the cloud controller API. The new application modeling provides much more flexibility and control over the workflows available to you for application deployment, while maintaining backwards compatibility with the Cloud Foundry interface you use today.

Utako and Dan will explain how to take advantage of the V3 API, and get into the details of the strategies involved in ensuring both dependable backwards compatibility and exciting new resource modularity.

About Utako Ueda
Utako is a core contributor to the Cloud Controller API on the CF CAPI Team. She is a Pivotal CF software engineer with a background in physics. She is very excited about her escape from basement laboratories into the world of agile development and offices with windows.

About Dan Wendorf
Dan is a consultant at Pivotal Labs who has been working with and on Cloud Foundry in multiple capacities since 2013. He is a core contributor to the Cloud Controller API. | Utako and Dan previously presented on the Cloud Controller API at the 2016 North American CF Summit.
Captions: 
	00:00:00,920 --> 00:00:06,150
unfortunately some of the most frequent

00:00:03,899 --> 00:00:07,649
feature requests we get are hard or

00:00:06,150 --> 00:00:11,910
impossible to do by incrementally

00:00:07,649 --> 00:00:14,070
improving the API and because of that we

00:00:11,910 --> 00:00:15,750
needed a more drastic change to allow us

00:00:14,070 --> 00:00:20,180
to respond to the needs of app

00:00:15,750 --> 00:00:20,180
developers so what were our goals

00:00:21,140 --> 00:00:26,820
backwards-compatible we want that we

00:00:24,330 --> 00:00:29,400
want to maintain v2 behavior eventually

00:00:26,820 --> 00:00:31,730
we will be deprecating v2 and new

00:00:29,400 --> 00:00:33,600
features will be added exclusively to v3

00:00:31,730 --> 00:00:35,070
we know that there are a lot of tools

00:00:33,600 --> 00:00:38,579
out there so we want to make sure that

00:00:35,070 --> 00:00:40,920
we don't break that experience modular

00:00:38,579 --> 00:00:42,930
we have a few great ideas about how to

00:00:40,920 --> 00:00:45,480
improve the app deployment lifecycle but

00:00:42,930 --> 00:00:47,820
we're just 10 people as a team we want

00:00:45,480 --> 00:00:49,710
the API to be modular so that your ideas

00:00:47,820 --> 00:00:51,660
are possible and so you can customize

00:00:49,710 --> 00:00:56,399
the app your app development lifecycle

00:00:51,660 --> 00:00:57,719
to your needs flexible flexible code

00:00:56,399 --> 00:01:02,460
base for us means that we can deliver

00:00:57,719 --> 00:01:04,530
more features to you faster and we want

00:01:02,460 --> 00:01:06,180
users to spend less time repeating the

00:01:04,530 --> 00:01:08,750
same process over and over again and

00:01:06,180 --> 00:01:11,700
more time delivering

00:01:08,750 --> 00:01:13,439
easier to manage if you want to get rid

00:01:11,700 --> 00:01:14,790
of hidden complexity and they need to

00:01:13,439 --> 00:01:17,610
have a deep knowledge of the internals

00:01:14,790 --> 00:01:19,200
of cod boundary developers shouldn't

00:01:17,610 --> 00:01:21,180
have to know that an app needs to be

00:01:19,200 --> 00:01:23,729
restaged if a new billet buildpack

00:01:21,180 --> 00:01:25,380
doesn't work out and your app deployment

00:01:23,729 --> 00:01:28,890
process should be easy to understand and

00:01:25,380 --> 00:01:30,659
customize shall speak consistent class

00:01:28,890 --> 00:01:34,740
leaving want the API to be discoverable

00:01:30,659 --> 00:01:37,140
and unsurprising so how do we accomplish

00:01:34,740 --> 00:01:39,330
these goals we initially wanted to

00:01:37,140 --> 00:01:41,399
extend the existing API but we were

00:01:39,330 --> 00:01:45,000
blocked by the overall domain modeling

00:01:41,399 --> 00:01:47,490
and design there's a meta programming

00:01:45,000 --> 00:01:49,110
layer that's closely coupled with and

00:01:47,490 --> 00:01:52,020
shared between the database models

00:01:49,110 --> 00:01:55,860
this can make adding simple features for

00:01:52,020 --> 00:01:59,280
one resource a pretty complex task for

00:01:55,860 --> 00:02:01,049
instance if we're hitting d2 apps to

00:01:59,280 --> 00:02:03,030
create a new app for instance then it

00:02:01,049 --> 00:02:05,970
would be hitting the same the same card

00:02:03,030 --> 00:02:08,970
base as what you'd be hitting if you

00:02:05,970 --> 00:02:10,950
wanted to make a new space so we try to

00:02:08,970 --> 00:02:13,079
if we try to be changed the behavior for

00:02:10,950 --> 00:02:15,090
how apps behave then we could make an

00:02:13,079 --> 00:02:19,500
undesired change and how spaces didn't

00:02:15,090 --> 00:02:22,470
behave so this made feature work pretty

00:02:19,500 --> 00:02:24,269
slow and we needed to redefine some of

00:02:22,470 --> 00:02:28,829
the constructs to provide flexibility

00:02:24,269 --> 00:02:33,410
and future proofing so in addition to

00:02:28,829 --> 00:02:33,410
that v2 app is a monolith and

00:02:34,599 --> 00:02:40,760
the user defines configuration like a

00:02:38,000 --> 00:02:43,849
start command CPU a number of instances

00:02:40,760 --> 00:02:46,060
memory and they have a package which is

00:02:43,849 --> 00:02:51,170
the source code and the compiled bits

00:02:46,060 --> 00:02:53,060
which we call a droplet and when the

00:02:51,170 --> 00:02:55,400
user wants to start the app the package

00:02:53,060 --> 00:02:58,160
fits and the app metadata are downloaded

00:02:55,400 --> 00:03:00,530
into a container and run this is what we

00:02:58,160 --> 00:03:02,540
call v2 app it doesn't really allow for

00:03:00,530 --> 00:03:04,400
things we value like flexibility of

00:03:02,540 --> 00:03:08,840
implementation or client-side

00:03:04,400 --> 00:03:10,700
manipulation our solution was to extract

00:03:08,840 --> 00:03:13,129
things like the droplet and package from

00:03:10,700 --> 00:03:15,590
the v2 app into top level domain objects

00:03:13,129 --> 00:03:18,670
with their own API endpoints that all

00:03:15,590 --> 00:03:22,160
live under an umbrella at v3 up an

00:03:18,670 --> 00:03:26,150
umbrella v3 app can have many source

00:03:22,160 --> 00:03:28,489
code packages and these packages can be

00:03:26,150 --> 00:03:33,160
staged into droplets or tarballs of

00:03:28,489 --> 00:03:33,160
compiled source code or docker images

00:03:34,180 --> 00:03:39,349
and then when the user is ready to

00:03:37,129 --> 00:03:41,329
execute their code this desired

00:03:39,349 --> 00:03:44,540
combination of metadata and compiled

00:03:41,329 --> 00:03:47,690
bits can be downloaded and run and this

00:03:44,540 --> 00:03:49,609
is now what we call a v3 process and by

00:03:47,690 --> 00:03:51,799
splitting this monolith into more

00:03:49,609 --> 00:03:53,840
manageable and independent concepts we

00:03:51,799 --> 00:03:56,299
can provide an API that supports a more

00:03:53,840 --> 00:04:01,069
flexible and nuanced management of your

00:03:56,299 --> 00:04:03,260
apps and this v3 process is now

00:04:01,069 --> 00:04:05,090
available of all v2 apps that were

00:04:03,260 --> 00:04:09,109
previously pushed with v2 are now

00:04:05,090 --> 00:04:10,849
available as v3 processes as well and if

00:04:09,109 --> 00:04:18,669
you'd like to learn more about this then

00:04:10,849 --> 00:04:18,669
check out a talk from last year so

00:04:18,799 --> 00:04:29,010
I'm taller so that's the details of what

00:04:24,960 --> 00:04:30,780
v3 is conceptually but what we also want

00:04:29,010 --> 00:04:33,000
to make sure is that all the tooling

00:04:30,780 --> 00:04:35,330
people have made around v2 of the cloud

00:04:33,000 --> 00:04:39,270
controller API still works so

00:04:35,330 --> 00:04:41,580
fortunately we've ensured that all the

00:04:39,270 --> 00:04:46,170
endpoints on v2 still work

00:04:41,580 --> 00:04:48,930
v3 doesn't deprecated v2 also has itako

00:04:46,170 --> 00:04:52,290
had mentioned all existing applications

00:04:48,930 --> 00:04:55,890
that have been pushed in v2 are being

00:04:52,290 --> 00:04:59,430
migrated to the v3 API so you can

00:04:55,890 --> 00:05:03,750
actually use v3 for existing apps just

00:04:59,430 --> 00:05:06,390
consider it as processes now once you've

00:05:03,750 --> 00:05:08,580
got v3 on your Cloud Foundry it's

00:05:06,390 --> 00:05:10,860
interesting to think about what using v3

00:05:08,580 --> 00:05:13,110
looks like and I think the best way to

00:05:10,860 --> 00:05:15,660
understand that is to look at what it

00:05:13,110 --> 00:05:20,490
looks like to push an app in v2 right

00:05:15,660 --> 00:05:22,380
now so if you're pushing an app on cloud

00:05:20,490 --> 00:05:24,330
Cloud Foundry what you're probably gonna

00:05:22,380 --> 00:05:26,390
do is create a couple of spaces one for

00:05:24,330 --> 00:05:30,510
development and one for production and

00:05:26,390 --> 00:05:32,370
you will most likely create a service

00:05:30,510 --> 00:05:34,410
for this this could be a database could

00:05:32,370 --> 00:05:37,229
be anything so in this example we're

00:05:34,410 --> 00:05:40,200
going to make a couple of spaces for our

00:05:37,229 --> 00:05:44,010
boots app and create a user provided

00:05:40,200 --> 00:05:45,000
service the password is Dora don't tell

00:05:44,010 --> 00:05:48,200
anyone please

00:05:45,000 --> 00:05:49,820
it's my password

00:05:48,200 --> 00:05:52,280
all right so when you're pushing that

00:05:49,820 --> 00:05:54,410
application what you'll want to do let's

00:05:52,280 --> 00:05:56,330
say you've got a standard web

00:05:54,410 --> 00:05:58,730
application probably has three different

00:05:56,330 --> 00:06:01,250
processes that need to run what we

00:05:58,730 --> 00:06:04,640
oftentimes see is a web application a

00:06:01,250 --> 00:06:07,130
worker application to process jobs and a

00:06:04,640 --> 00:06:08,540
scheduler application to tell though

00:06:07,130 --> 00:06:12,700
that worker what to do

00:06:08,540 --> 00:06:15,320
so you'll push your app three times and

00:06:12,700 --> 00:06:17,120
it's going to be the same codebase you

00:06:15,320 --> 00:06:19,310
have to do three pushes interact with

00:06:17,120 --> 00:06:22,160
the the API three separate times and

00:06:19,310 --> 00:06:25,310
then bind your database service to that

00:06:22,160 --> 00:06:29,950
same application three separate times it

00:06:25,310 --> 00:06:33,050
seems like a lot of duplication and

00:06:29,950 --> 00:06:35,150
during this push process there's some

00:06:33,050 --> 00:06:36,680
interesting stuff that's happening even

00:06:35,150 --> 00:06:39,140
though it looks like one command in the

00:06:36,680 --> 00:06:41,900
CLI in reality what's happening is first

00:06:39,140 --> 00:06:43,940
creates an empty application then

00:06:41,900 --> 00:06:47,390
creates a default route for that

00:06:43,940 --> 00:06:50,650
application it will bind the route to

00:06:47,390 --> 00:06:53,600
the application upload all of the files

00:06:50,650 --> 00:06:55,490
stage those files into an executable

00:06:53,600 --> 00:06:57,470
droplet if you're not familiar with the

00:06:55,490 --> 00:06:59,480
staging process when you push that's the

00:06:57,470 --> 00:07:02,870
part that takes a long time has a lot of

00:06:59,480 --> 00:07:07,190
output and then finally we'll run the

00:07:02,870 --> 00:07:11,020
droplet so in v3 this looks a little bit

00:07:07,190 --> 00:07:14,990
different all you do is one single push

00:07:11,020 --> 00:07:16,760
it's got the exact same steps except

00:07:14,990 --> 00:07:18,590
because we can be smart about one

00:07:16,760 --> 00:07:22,990
application having three different

00:07:18,590 --> 00:07:26,000
processes we only need to do one staging

00:07:22,990 --> 00:07:28,220
so as you can see here we just create

00:07:26,000 --> 00:07:31,490
the empty app the route upload the files

00:07:28,220 --> 00:07:34,040
do the staging just once I think that

00:07:31,490 --> 00:07:37,090
feels a lot better it's a lot faster it

00:07:34,040 --> 00:07:37,090
just makes more sense

00:07:37,300 --> 00:07:39,569
now

00:07:42,630 --> 00:07:48,270
so the way that we're able to do this is

00:07:45,390 --> 00:07:49,590
we specify a proc file in the

00:07:48,270 --> 00:07:51,990
application so just at the root where

00:07:49,590 --> 00:07:54,540
you'd have your indexed at HTML your gem

00:07:51,990 --> 00:07:57,030
file whatever it is just create a simple

00:07:54,540 --> 00:08:00,000
proc file specifying I want my web my

00:07:57,030 --> 00:08:02,670
worker and my scheduler and the v3 API

00:08:00,000 --> 00:08:04,980
can look at this and say I'm going to

00:08:02,670 --> 00:08:09,110
push three apps for the same bits again

00:08:04,980 --> 00:08:11,040
only one staging process

00:08:09,110 --> 00:08:13,560
unfortunately we're able to do other

00:08:11,040 --> 00:08:15,930
things coordinating processes as one

00:08:13,560 --> 00:08:19,080
single app so those three different bind

00:08:15,930 --> 00:08:23,490
services that you do before and v3 it's

00:08:19,080 --> 00:08:25,560
just one single bind service this is not

00:08:23,490 --> 00:08:28,650
only faster easier for you to do but

00:08:25,560 --> 00:08:30,120
it's also safer the service binding has

00:08:28,650 --> 00:08:31,530
credentials so let's say you've leaked

00:08:30,120 --> 00:08:33,780
your credentials maybe you've announced

00:08:31,530 --> 00:08:35,340
your password at a conference and now

00:08:33,780 --> 00:08:38,099
you only have to change your password

00:08:35,340 --> 00:08:40,140
once all of your app all of your

00:08:38,099 --> 00:08:42,150
processes for your application get the

00:08:40,140 --> 00:08:44,850
new password

00:08:42,150 --> 00:08:47,010
so that's how developments little bit

00:08:44,850 --> 00:08:51,120
easier makes even pushing to production

00:08:47,010 --> 00:08:52,950
better so in production you would

00:08:51,120 --> 00:08:55,230
normally target your production space

00:08:52,950 --> 00:08:56,880
you'd push those same three apps again

00:08:55,230 --> 00:08:58,800
you'd bind those same three services

00:08:56,880 --> 00:09:03,390
again and you'd map your production

00:08:58,800 --> 00:09:06,120
route to the new application which seems

00:09:03,390 --> 00:09:08,070
again kind of like extra behavior

00:09:06,120 --> 00:09:09,570
because we've already pushed our bits

00:09:08,070 --> 00:09:12,380
we've already staged our pits we have

00:09:09,570 --> 00:09:16,290
our droplet so in v3 we can do better in

00:09:12,380 --> 00:09:18,060
v3 we could just copy a droplet over to

00:09:16,290 --> 00:09:20,070
the production space the exact same

00:09:18,060 --> 00:09:21,930
droplet exact same bits that you've

00:09:20,070 --> 00:09:23,820
tested that you've written through CI

00:09:21,930 --> 00:09:25,650
you don't even need the code on your

00:09:23,820 --> 00:09:27,690
development machine you just need access

00:09:25,650 --> 00:09:30,210
to the cloud foundry and you can move

00:09:27,690 --> 00:09:32,400
the application from your development

00:09:30,210 --> 00:09:34,560
environment to your staging environment

00:09:32,400 --> 00:09:38,870
to your production environment no

00:09:34,560 --> 00:09:38,870
staging much much nicer

00:09:42,470 --> 00:09:48,889
so eul's so what happens when you copy

00:09:45,800 --> 00:09:51,649
it creates a new application it copies

00:09:48,889 --> 00:09:54,440
the configuration for the app it will

00:09:51,649 --> 00:09:57,500
then copy that same droplet for the

00:09:54,440 --> 00:09:59,920
application allowing you to later on

00:09:57,500 --> 00:10:03,259
change it separately if you'd like to

00:09:59,920 --> 00:10:05,870
it'll bind all the services that were

00:10:03,259 --> 00:10:07,339
the same service bindings but to your

00:10:05,870 --> 00:10:09,680
production services that will have the

00:10:07,339 --> 00:10:12,709
same names as in your development space

00:10:09,680 --> 00:10:16,290
and then it will just run the droplet

00:10:12,709 --> 00:10:18,350
nice and simple nice and fast

00:10:16,290 --> 00:10:18,350
you

00:10:19,990 --> 00:10:24,040
so what if you want to update your up

00:10:28,320 --> 00:10:35,149
all right and VT this is what we do we

00:10:31,649 --> 00:10:38,430
stop the app we push the updated code

00:10:35,149 --> 00:10:40,589
create a package upload the files stage

00:10:38,430 --> 00:10:44,130
and create the droplet and we start the

00:10:40,589 --> 00:10:46,279
new instances with that droplet in v3 we

00:10:44,130 --> 00:10:49,139
push the updated code create a package

00:10:46,279 --> 00:10:51,680
upload files state and create the

00:10:49,139 --> 00:10:55,500
droplet stop instance of an old droplet

00:10:51,680 --> 00:10:59,430
assign the droplet to that app and we

00:10:55,500 --> 00:11:03,329
start instances with the new droplet in

00:10:59,430 --> 00:11:09,060
v2 your app is down for almost all of

00:11:03,329 --> 00:11:10,290
this process and in v3 your app is it's

00:11:09,060 --> 00:11:13,560
only done when we're swapping the hold

00:11:10,290 --> 00:11:14,540
within you so what if the update didn't

00:11:13,560 --> 00:11:18,029
go well

00:11:14,540 --> 00:11:20,639
well in a normal process you would freak

00:11:18,029 --> 00:11:23,490
out look through the logs to see if it

00:11:20,639 --> 00:11:26,880
was previously deployed check out that

00:11:23,490 --> 00:11:29,279
shop and then maybe deploy from your

00:11:26,880 --> 00:11:32,370
development machine outside of CI where

00:11:29,279 --> 00:11:33,899
anything could go wrong and then you

00:11:32,370 --> 00:11:36,440
hope that you deployed the right thing

00:11:33,899 --> 00:11:39,360
and wait for your app to come back up in

00:11:36,440 --> 00:11:42,329
v3 could be as simple as one simple

00:11:39,360 --> 00:11:44,130
rollback command and because v3 keeps

00:11:42,329 --> 00:11:47,480
track of your apps last five droplets

00:11:44,130 --> 00:11:47,480
you can roll back to any one of them

00:11:48,090 --> 00:11:53,520
and so everything we've said so far is a

00:11:51,330 --> 00:11:55,200
hypothetical world these CLI commands

00:11:53,520 --> 00:11:57,510
are not implemented yet and they could

00:11:55,200 --> 00:11:59,130
change and they aren't currently

00:11:57,510 --> 00:12:03,510
available it's just what the world could

00:11:59,130 --> 00:12:05,790
be so we've talked about how existing

00:12:03,510 --> 00:12:07,290
workflows can be improved with v3 and

00:12:05,790 --> 00:12:09,780
now we'd like to talk about something

00:12:07,290 --> 00:12:11,580
new we're really excited about this

00:12:09,780 --> 00:12:14,400
feature users have been requesting this

00:12:11,580 --> 00:12:16,500
for a really long time Diego had it

00:12:14,400 --> 00:12:18,360
available for a while but we just didn't

00:12:16,500 --> 00:12:21,090
have the structure in place to expose

00:12:18,360 --> 00:12:25,890
this implementing v3 has made it

00:12:21,090 --> 00:12:29,400
possible so you can now run arbitrary

00:12:25,890 --> 00:12:31,200
commands on your app your tasks and app

00:12:29,400 --> 00:12:34,470
share the same code the same environment

00:12:31,200 --> 00:12:37,660
variables and the same service findings

00:12:34,470 --> 00:12:40,690
so let's say you push an app called Dora

00:12:37,660 --> 00:12:46,120
with v2 or v3 so what could you do with

00:12:40,690 --> 00:12:48,970
it you can run a migration you can send

00:12:46,120 --> 00:12:52,090
email blasts to your users you can make

00:12:48,970 --> 00:12:54,910
a query against your database pretty

00:12:52,090 --> 00:12:56,800
much anything you want and also you'll

00:12:54,910 --> 00:12:59,740
have access to an outfit of every task

00:12:56,800 --> 00:13:04,060
you run and a history of the tests that

00:12:59,740 --> 00:13:05,050
you run against your app so maybe you'd

00:13:04,060 --> 00:13:08,560
like to know when this will be made

00:13:05,050 --> 00:13:10,590
generally available in the next few

00:13:08,560 --> 00:13:10,590
weeks

00:13:14,600 --> 00:13:20,600
all right so what we've talked about is

00:13:18,319 --> 00:13:23,329
what is available in the cloud

00:13:20,600 --> 00:13:26,899
controller API like we said some of the

00:13:23,329 --> 00:13:28,370
new CLI features are coming soon some

00:13:26,899 --> 00:13:30,350
more works v3 is going to be coming soon

00:13:28,370 --> 00:13:32,949
so so what are what are those things

00:13:30,350 --> 00:13:36,410
obviously the CLI does need to support

00:13:32,949 --> 00:13:39,529
support this and task support is coming

00:13:36,410 --> 00:13:42,560
quite soon everything is going to be in

00:13:39,529 --> 00:13:44,720
the CF CLI so if you want to take a look

00:13:42,560 --> 00:13:47,839
now you'll have to hit endpoints you'll

00:13:44,720 --> 00:13:49,040
have to create post bodies CLI is going

00:13:47,839 --> 00:13:52,430
to make this very easy it's going to be

00:13:49,040 --> 00:13:56,000
great we talked a little bit about how

00:13:52,430 --> 00:13:58,279
downtime is shorter in v3 but because we

00:13:56,000 --> 00:13:59,990
can do more complex application life

00:13:58,279 --> 00:14:02,329
cycles we think we'll be able to get

00:13:59,990 --> 00:14:04,160
zero downtime deployments and there are

00:14:02,329 --> 00:14:06,560
a lot of blue/green deployment processes

00:14:04,160 --> 00:14:08,990
other sorts of zero downtime deployments

00:14:06,560 --> 00:14:10,519
that are kind of outside of Cloud

00:14:08,990 --> 00:14:13,519
Foundry we think we can make that a

00:14:10,519 --> 00:14:16,009
native part of the platform we also

00:14:13,519 --> 00:14:18,110
think it'll be possible to move droplets

00:14:16,009 --> 00:14:19,790
from one existing Cloud Foundry to

00:14:18,110 --> 00:14:21,319
another Cloud Foundry so you've got a

00:14:19,790 --> 00:14:24,350
development Cloud Foundry on your

00:14:21,319 --> 00:14:26,689
machine on your laptop or you've got it

00:14:24,350 --> 00:14:28,910
on a different part of the world and you

00:14:26,689 --> 00:14:30,470
need to balance between foundation

00:14:28,910 --> 00:14:32,240
installations should be able to move

00:14:30,470 --> 00:14:36,589
droplets between those cloud foundries

00:14:32,240 --> 00:14:37,910
and finally if you've if you've got a

00:14:36,589 --> 00:14:39,829
situation where you don't want to rely

00:14:37,910 --> 00:14:41,930
on a proc file you want to make

00:14:39,829 --> 00:14:44,990
processes dynamically they'll be able to

00:14:41,930 --> 00:14:48,680
make processes for existing apps using

00:14:44,990 --> 00:14:51,139
that same droplet again it's it's

00:14:48,680 --> 00:14:53,660
enabling workflows for different types

00:14:51,139 --> 00:14:57,380
of application deployment processes

00:14:53,660 --> 00:15:00,960
you'll want to do so fortunately all

00:14:57,380 --> 00:15:03,150
this stuff is free

00:15:00,960 --> 00:15:05,420
you can try it right now and we'd love

00:15:03,150 --> 00:15:08,220
to have everyone try the v3 of the API

00:15:05,420 --> 00:15:10,200
we think it enables some pretty cool

00:15:08,220 --> 00:15:13,830
things it's fun to work with a lot

00:15:10,200 --> 00:15:16,680
faster a lot easier so the ways that you

00:15:13,830 --> 00:15:20,940
can get involved with it right now we've

00:15:16,680 --> 00:15:23,840
got documentation for v3 these slides

00:15:20,940 --> 00:15:26,580
will be published that's correct okay so

00:15:23,840 --> 00:15:27,810
if you don't know or if you don't want

00:15:26,580 --> 00:15:30,060
to copy down this link you'll be able to

00:15:27,810 --> 00:15:33,330
get this link later the documentation

00:15:30,060 --> 00:15:35,430
will show you how to use it you also you

00:15:33,330 --> 00:15:37,080
can also write a custom CLI plugin to

00:15:35,430 --> 00:15:39,330
play with these different workflows see

00:15:37,080 --> 00:15:41,760
what a workflow feels like there are a

00:15:39,330 --> 00:15:43,560
couple of alpha plugins using v3 right

00:15:41,760 --> 00:15:43,980
now that maybe you want to do something

00:15:43,560 --> 00:15:47,240
else

00:15:43,980 --> 00:15:47,240
that's what v3 is good for

00:15:50,649 --> 00:15:57,730
and so please take a look right now we'd

00:15:54,939 --> 00:15:59,259
love again to get feedback the alpha

00:15:57,730 --> 00:16:02,170
release is coming up pretty soon and

00:15:59,259 --> 00:16:05,800
general availability is I guess

00:16:02,170 --> 00:16:10,360
soon after soon please provide us any

00:16:05,800 --> 00:16:12,639
feedback you can we'd love to hear it we

00:16:10,360 --> 00:16:13,720
also have slack channel Cloud Foundry

00:16:12,639 --> 00:16:15,699
that's like calm

00:16:13,720 --> 00:16:17,199
hopefully you're in that already we're

00:16:15,699 --> 00:16:19,209
in a kappa channel so if you've got

00:16:17,199 --> 00:16:21,550
questions if you need advice if you've

00:16:19,209 --> 00:16:22,959
got suggestions that's where you can get

00:16:21,550 --> 00:16:26,459
in contact with people from the capi

00:16:22,959 --> 00:16:26,459
team talk about v3

00:16:28,630 --> 00:16:31,860
experimental would you like to

00:16:32,500 --> 00:16:38,180
so v3 is currently experimental which

00:16:35,449 --> 00:16:42,579
means that your data may be truncated on

00:16:38,180 --> 00:16:42,579
a migration so just keep that in mind

00:16:44,240 --> 00:16:51,290
feature though we don't want that

00:16:45,470 --> 00:16:57,459
forever all right so at this point does

00:16:51,290 --> 00:16:57,459
anyone have any questions about v3 yes

00:17:06,689 --> 00:17:10,569
yes that's correct

00:17:08,350 --> 00:17:12,639
so that's that's using the the proc file

00:17:10,569 --> 00:17:14,999
that you put in your in your code

00:17:12,639 --> 00:17:14,999
directory

00:17:21,799 --> 00:17:25,649
so the binding the services will be

00:17:24,270 --> 00:17:28,110
separate but you'll bind it to the

00:17:25,649 --> 00:17:29,700
application and all the processes get

00:17:28,110 --> 00:17:32,870
the binding so you won't have to bind

00:17:29,700 --> 00:17:32,870
per process anymore

00:17:33,880 --> 00:17:35,940
you

00:17:36,270 --> 00:17:38,330
you

00:17:42,450 --> 00:17:47,380
I don't think that manaphy

00:17:45,280 --> 00:17:49,390
part of that has been figured out I

00:17:47,380 --> 00:17:51,280
think there's still some design work

00:17:49,390 --> 00:17:53,290
about what exactly it feels like to use

00:17:51,280 --> 00:17:57,220
the CLI what it feels like to use the

00:17:53,290 --> 00:18:00,460
manifest seems like something that is

00:17:57,220 --> 00:18:02,170
pretty reasonable if you would like that

00:18:00,460 --> 00:18:04,330
feature absolutely I'd encourage you to

00:18:02,170 --> 00:18:06,370
go into the channel talk about it the

00:18:04,330 --> 00:18:07,480
more we hear about what people want the

00:18:06,370 --> 00:18:09,630
more we're probably going to go in that

00:18:07,480 --> 00:18:09,630
direction

00:18:19,070 --> 00:18:21,130
you

00:18:22,070 --> 00:18:25,030
can you speak to that

00:18:26,559 --> 00:18:28,620
you

00:18:39,290 --> 00:18:43,740
question is between different

00:18:41,430 --> 00:18:45,660
installations of Cloud Foundry when will

00:18:43,740 --> 00:18:48,920
we will be able to copy droplets between

00:18:45,660 --> 00:18:51,180
the two that's also still in development

00:18:48,920 --> 00:18:52,620
we're getting to the I think we have

00:18:51,180 --> 00:18:54,840
like something in our backlog right now

00:18:52,620 --> 00:18:56,280
about uploading a droplet that's already

00:18:54,840 --> 00:19:00,230
been staged

00:18:56,280 --> 00:19:00,230
so it's already in the works

00:19:00,490 --> 00:19:06,250
short but I make no promises

00:19:03,560 --> 00:19:06,250
I'm not allowed to

00:19:14,310 --> 00:19:22,920
referre

00:19:15,890 --> 00:19:24,870
just say and we'll be rolling and this

00:19:22,920 --> 00:19:26,400
has also not been implemented yet you

00:19:24,870 --> 00:19:28,530
could technically assign your current

00:19:26,400 --> 00:19:30,690
droplet to an older version so you could

00:19:28,530 --> 00:19:32,130
look through your apps droplets find the

00:19:30,690 --> 00:19:33,960
goo it or something and then when you

00:19:32,130 --> 00:19:35,430
assign the droplet you can actually this

00:19:33,960 --> 00:19:38,400
has already been done

00:19:35,430 --> 00:19:43,730
you can assign that droplet to that drop

00:19:38,400 --> 00:19:43,730
look good and start that up

00:19:43,870 --> 00:19:47,340
any other questions

00:19:48,800 --> 00:20:06,820
I don't believe so but that's a good

00:20:04,670 --> 00:20:06,820
idea

00:20:09,190 --> 00:20:15,980
as far as scheduling of tasks I think

00:20:13,040 --> 00:20:17,960
that's something for now would probably

00:20:15,980 --> 00:20:22,760
best still live in your application

00:20:17,960 --> 00:20:25,660
logic C might be I would guess a little

00:20:22,760 --> 00:20:28,790
complex for what what task is meant for

00:20:25,660 --> 00:20:32,290
but from your own app you could actually

00:20:28,790 --> 00:20:32,290
trigger tasks on itself

00:20:34,130 --> 00:20:39,620
I think there's one more question to the

00:20:35,900 --> 00:20:43,400
left is this correctly of the

00:20:39,620 --> 00:20:47,210
environment is also copied over if you

00:20:43,400 --> 00:20:49,990
help me over you droplet from your

00:20:47,210 --> 00:20:52,370
development for your production space

00:20:49,990 --> 00:20:54,440
but most likely on exploiting

00:20:52,370 --> 00:20:58,010
applications that I know the environment

00:20:54,440 --> 00:21:02,900
will be good for example I don't you

00:20:58,010 --> 00:21:04,669
tell you that my profile pencil all

00:21:02,900 --> 00:21:06,580
these kind of things so how how would I

00:21:04,669 --> 00:21:09,380
do that

00:21:06,580 --> 00:21:11,539
most likely you'd pass in a different

00:21:09,380 --> 00:21:14,360
set of environment variables maybe we

00:21:11,539 --> 00:21:16,370
would have a different flag this is a

00:21:14,360 --> 00:21:18,230
really good point I think we'll take it

00:21:16,370 --> 00:21:21,520
into consideration when we implement it

00:21:18,230 --> 00:21:21,520
very soon

00:21:25,050 --> 00:21:28,160
any final questions

00:21:28,380 --> 00:21:33,470
all right well thank you all very much

00:21:31,480 --> 00:21:39,950
appreciate you coming

00:21:33,470 --> 00:21:39,950

YouTube URL: https://www.youtube.com/watch?v=rSDoU3NDbsU


