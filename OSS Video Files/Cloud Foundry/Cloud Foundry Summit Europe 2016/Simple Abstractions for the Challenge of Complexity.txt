Title: Simple Abstractions for the Challenge of Complexity
Publication date: 2016-09-30
Playlist: Cloud Foundry Summit Europe 2016
Description: 
	Simple Abstractions for the Challenge of Complexity - How Cloud Foundry's Layered Approach Allows for Isolated Components and a Pattern for Reuse - Duncan Winn, Pivotal

Simple abstractions for the challenge of complexity - how Cloud Foundry's layered approach allows for isolated components and a pattern for reuse.”

With all the hype around trends such as microservices, DevOps, and continuous delivery, what does it look like in reality? Cloud Foundry, including both the way it is architected, and developed, expertly demonstrate how these trends are established and why they make sense for distributed architectures such as Cloud Foundry.

This talk comes from spending three years writing a technical book on Cloud Foundry that explores the core components, the beauty of Diego’s abstraction , the value and progression of BOSH and the essential steps required for debugging CF.

This talk is intended for anyone getting started with CF or anyone who wants to see real world examples of the aforementioned trends in practice.

About Duncan Winn
Duncan has been working on Cloud Foundry since 2012. Currently Duncan works in Pivotal's Services Team to help companies install and configure hardened Cloud Foundry environments and related services so they get the most out of Cloud Foundry in an enterprise setting. Prior to moving to the US he was the EMEA developer advocate for Pivotal and ran Pivotal's Platform team in London.
Captions: 
	00:00:00,030 --> 00:00:04,230
cool so uh let's kick off so thank you

00:00:02,850 --> 00:00:07,290
very much for coming my name is Duncan

00:00:04,230 --> 00:00:08,639
Wynn so this talk is titled simple

00:00:07,290 --> 00:00:10,230
abstractions for the challenge of

00:00:08,639 --> 00:00:13,019
complexity or how Cloud Foundry is

00:00:10,230 --> 00:00:16,350
layered approach allows for isolated

00:00:13,019 --> 00:00:18,029
components and a pattern of reuse so

00:00:16,350 --> 00:00:19,770
that's the huge mouthful and if you come

00:00:18,029 --> 00:00:22,050
to this talk just on that title thank

00:00:19,770 --> 00:00:23,970
you very much you've made it this far so

00:00:22,050 --> 00:00:26,990
to unpack that I'm going to take you on

00:00:23,970 --> 00:00:29,310
my personal journey with Cloud Foundry

00:00:26,990 --> 00:00:31,650
so I've been involved with Cloud Foundry

00:00:29,310 --> 00:00:34,050
for a number of years and I help

00:00:31,650 --> 00:00:35,610
companies install and configure and help

00:00:34,050 --> 00:00:38,070
companies get started with Cloud Foundry

00:00:35,610 --> 00:00:39,239
I'm a consultant for pivotal have worked

00:00:38,070 --> 00:00:41,550
both here in a mirror and I currently

00:00:39,239 --> 00:00:43,739
work in the US and throughout these

00:00:41,550 --> 00:00:44,850
engagements especially with this getting

00:00:43,739 --> 00:00:46,739
started experience

00:00:44,850 --> 00:00:48,960
a typically founder come across the same

00:00:46,739 --> 00:00:52,079
set of problems and challenges again and

00:00:48,960 --> 00:00:54,090
again so I sat down I started to write a

00:00:52,079 --> 00:00:55,829
book for a Riley just to capture the

00:00:54,090 --> 00:00:58,199
technical concerns and the technical

00:00:55,829 --> 00:00:59,370
considerations around installing and

00:00:58,199 --> 00:01:00,780
configuring Cloud Foundry and I've got

00:00:59,370 --> 00:01:02,820
some early releases here at the end if

00:01:00,780 --> 00:01:05,630
anyone's interested this is kind of half

00:01:02,820 --> 00:01:08,549
the book although it's almost finished

00:01:05,630 --> 00:01:10,920
some way into that journey of writing

00:01:08,549 --> 00:01:14,820
about California about to our foundry at

00:01:10,920 --> 00:01:17,610
the 2014 CF summit I was introduced to

00:01:14,820 --> 00:01:19,530
this guy on Z and on Z took the Cloud

00:01:17,610 --> 00:01:21,960
Foundry community through some of the

00:01:19,530 --> 00:01:23,220
changes with the elastic runtime and

00:01:21,960 --> 00:01:25,979
some of the challenges with the old

00:01:23,220 --> 00:01:27,990
elastic runtime and how Diego fixed a

00:01:25,979 --> 00:01:29,759
number of these problems now this

00:01:27,990 --> 00:01:31,500
presentation is still on YouTube it's a

00:01:29,759 --> 00:01:33,659
really really good presentation so if

00:01:31,500 --> 00:01:35,329
anyone hasn't seen it I'd strongly

00:01:33,659 --> 00:01:37,979
recommend that you go and have a look

00:01:35,329 --> 00:01:41,400
but just to summarize what aandhi talked

00:01:37,979 --> 00:01:43,619
about he talked about the tight coupling

00:01:41,400 --> 00:01:45,720
of the components and some of the

00:01:43,619 --> 00:01:47,670
orchestration challenges that the cloud

00:01:45,720 --> 00:01:49,200
controller had because the cloud

00:01:47,670 --> 00:01:52,170
controller had too much responsibility

00:01:49,200 --> 00:01:55,049
and had too much control over what was

00:01:52,170 --> 00:01:56,969
going on he also talked about these

00:01:55,049 --> 00:01:59,729
triangular dependencies and this poor

00:01:56,969 --> 00:02:02,070
separation of concerns between some of

00:01:59,729 --> 00:02:03,600
the components and this led to a real

00:02:02,070 --> 00:02:07,860
challenge I'm just kind of switch does

00:02:03,600 --> 00:02:09,959
this work still well cool so he talked

00:02:07,860 --> 00:02:11,640
about this poor separation or concerns

00:02:09,959 --> 00:02:13,800
and this led to a challenge there cloud

00:02:11,640 --> 00:02:16,680
foundry was hard to reason over

00:02:13,800 --> 00:02:18,750
and hard to test and also hard to manage

00:02:16,680 --> 00:02:21,150
the existing features but more

00:02:18,750 --> 00:02:22,860
importantly at the time it was hard to

00:02:21,150 --> 00:02:25,290
add new features and this was a real

00:02:22,860 --> 00:02:27,660
problem because back in 2014

00:02:25,290 --> 00:02:29,840
Cloud Foundry was just about the app

00:02:27,660 --> 00:02:32,880
only supported one type of workload and

00:02:29,840 --> 00:02:35,370
it was very platform specific meaning I

00:02:32,880 --> 00:02:38,400
had Linux specific code hardwired

00:02:35,370 --> 00:02:40,410
throughout and so diego has pitched as

00:02:38,400 --> 00:02:42,930
this ground-up rewrite of the elastic

00:02:40,410 --> 00:02:46,350
runtime and go and September fit on

00:02:42,930 --> 00:02:48,570
September last year in 2015 the first GA

00:02:46,350 --> 00:02:51,060
version of Diego is released this was

00:02:48,570 --> 00:02:54,330
the first version that supported zero

00:02:51,060 --> 00:02:56,220
downtime deploys now Diego is fantastic

00:02:54,330 --> 00:02:58,860
for the Cloud Foundry food community but

00:02:56,220 --> 00:03:01,500
as an author trying to write about Cloud

00:02:58,860 --> 00:03:03,450
Foundry this was really problematic it

00:03:01,500 --> 00:03:05,550
meant I had to go away and refactor 50

00:03:03,450 --> 00:03:08,250
pages very quickly and then if that

00:03:05,550 --> 00:03:10,110
wasn't bad enough dimitri came out with

00:03:08,250 --> 00:03:11,970
both 2.0 earlier this year and it men

00:03:10,110 --> 00:03:14,640
that had to refactor another three

00:03:11,970 --> 00:03:17,010
chapters so writing about stuff is hard

00:03:14,640 --> 00:03:18,900
but when the technology is changing as

00:03:17,010 --> 00:03:21,360
fast as Cloud Foundry it becomes even

00:03:18,900 --> 00:03:22,920
more problematic and as I was delving

00:03:21,360 --> 00:03:25,320
into the weeds of Cloud Foundry and

00:03:22,920 --> 00:03:27,510
really understanding the detail I step

00:03:25,320 --> 00:03:29,100
back and ask myself this question you

00:03:27,510 --> 00:03:30,510
know why should I care not about Cloud

00:03:29,100 --> 00:03:31,350
Foundry I think Cloud Foundry is

00:03:30,510 --> 00:03:34,020
fantastic

00:03:31,350 --> 00:03:36,810
but the detail of Cloud Foundry the

00:03:34,020 --> 00:03:38,910
detail of how Diego works why should I

00:03:36,810 --> 00:03:41,520
care and at the back of my mind I had to

00:03:38,910 --> 00:03:43,080
developer and thinking as a developer

00:03:41,520 --> 00:03:44,280
why should you care about this stuff why

00:03:43,080 --> 00:03:46,530
should you care about Cloud Foundry

00:03:44,280 --> 00:03:49,410
internals and it's abstractions and how

00:03:46,530 --> 00:03:51,360
it works again borrowing from Anzhi we

00:03:49,410 --> 00:03:54,390
have this fantastic developer mantra

00:03:51,360 --> 00:03:57,180
here is my app run it on the cloud for

00:03:54,390 --> 00:03:58,770
me I don't care how and by the developer

00:03:57,180 --> 00:04:00,930
I'm not just talking about the person

00:03:58,770 --> 00:04:03,690
who cuts code I'm talking about the

00:04:00,930 --> 00:04:05,880
entire team responsible for developing

00:04:03,690 --> 00:04:07,620
and running that application they by and

00:04:05,880 --> 00:04:10,080
large think of Cloud Foundry is this

00:04:07,620 --> 00:04:11,850
black box they pushed their application

00:04:10,080 --> 00:04:14,040
Cloud Foundry does its thing and returns

00:04:11,850 --> 00:04:15,570
an endpoint a router will endpoint so

00:04:14,040 --> 00:04:17,010
they don't really need to peel back the

00:04:15,570 --> 00:04:19,200
covers and understand what's going on

00:04:17,010 --> 00:04:21,690
and for anyone who's been working with

00:04:19,200 --> 00:04:23,400
Cloud Foundry for some time this is the

00:04:21,690 --> 00:04:26,430
highest level of abstraction that we're

00:04:23,400 --> 00:04:27,420
used to that developers think about

00:04:26,430 --> 00:04:29,250
their work they think

00:04:27,420 --> 00:04:31,440
about their apps their tasks their

00:04:29,250 --> 00:04:33,630
services they don't really need to be

00:04:31,440 --> 00:04:34,770
mindful of what container orchestration

00:04:33,630 --> 00:04:36,900
you're using or what version of Linux

00:04:34,770 --> 00:04:38,250
you're running on all of those are the

00:04:36,900 --> 00:04:41,160
platform concerns and that

00:04:38,250 --> 00:04:42,450
undifferentiated heavy lifting is really

00:04:41,160 --> 00:04:46,110
what the platform is there to take care

00:04:42,450 --> 00:04:48,390
of for you so it got me thinking back to

00:04:46,110 --> 00:04:50,250
this book the book isn't really for

00:04:48,390 --> 00:04:52,380
developers Cloud Foundry is so easy to

00:04:50,250 --> 00:04:53,730
use as a developer that if you were

00:04:52,380 --> 00:04:55,080
going to capture those developer

00:04:53,730 --> 00:04:57,720
concerns a book like that would be

00:04:55,080 --> 00:05:00,180
really small and so in true agile

00:04:57,720 --> 00:05:01,920
fashion I decided to actually start

00:05:00,180 --> 00:05:03,300
small and I wrote with such a book so

00:05:01,920 --> 00:05:05,160
I've got some of these around as well if

00:05:03,300 --> 00:05:06,870
anyone's interested this isn't really

00:05:05,160 --> 00:05:09,900
targeting the developer but this is the

00:05:06,870 --> 00:05:12,930
developer experience of delivering agile

00:05:09,900 --> 00:05:14,520
software with velocity so in my own

00:05:12,930 --> 00:05:16,470
naivety I thought that small book would

00:05:14,520 --> 00:05:18,570
be about a week but six months later I

00:05:16,470 --> 00:05:20,670
was back to the original book and I was

00:05:18,570 --> 00:05:23,190
able to frame my question much better as

00:05:20,670 --> 00:05:25,860
an operator why should I care about

00:05:23,190 --> 00:05:27,840
Cloud Foundry abstractions and this is a

00:05:25,860 --> 00:05:29,310
really important question to ask not

00:05:27,840 --> 00:05:31,380
just for an author trying to understand

00:05:29,310 --> 00:05:32,700
his audience but for the Cloud Foundry

00:05:31,380 --> 00:05:34,320
community as a whole

00:05:32,700 --> 00:05:37,320
why should you care about Diego and the

00:05:34,320 --> 00:05:39,630
internals and to answer this you need to

00:05:37,320 --> 00:05:42,030
understand the concert the context of

00:05:39,630 --> 00:05:43,890
another question and that's why

00:05:42,030 --> 00:05:46,710
distributed systems so hard in the first

00:05:43,890 --> 00:05:48,330
place so two level set in case anyone's

00:05:46,710 --> 00:05:51,240
completely new to this stuff

00:05:48,330 --> 00:05:52,770
descriptive systems involve a number of

00:05:51,240 --> 00:05:54,660
components and their networks well

00:05:52,770 --> 00:05:56,280
they're connected together and because

00:05:54,660 --> 00:05:57,990
there's many moving parts they've become

00:05:56,280 --> 00:06:00,420
inherently complex because you need to

00:05:57,990 --> 00:06:01,650
orchestrate them halfway through one of

00:06:00,420 --> 00:06:03,150
these original talk

00:06:01,650 --> 00:06:04,710
he had this comment it was almost like

00:06:03,150 --> 00:06:07,020
an off-the-cuff throwaway comment but it

00:06:04,710 --> 00:06:09,660
really resonated with me that within a

00:06:07,020 --> 00:06:11,070
distributed system it's hard to have an

00:06:09,660 --> 00:06:13,800
accurate picture of the world at all

00:06:11,070 --> 00:06:16,530
times and when you look at cloud foundry

00:06:13,800 --> 00:06:18,720
it's a multi-user multi component

00:06:16,530 --> 00:06:21,570
environment it has a number of micro

00:06:18,720 --> 00:06:23,520
services things can fail usage paths

00:06:21,570 --> 00:06:25,740
change auto scaling can kick in

00:06:23,520 --> 00:06:27,750
self-healing can kick in all of these

00:06:25,740 --> 00:06:30,950
things can change state and they need to

00:06:27,750 --> 00:06:33,000
be tracked and potentially responded to

00:06:30,950 --> 00:06:35,340
moreover there are just inherent

00:06:33,000 --> 00:06:39,180
challenges with any distributed system

00:06:35,340 --> 00:06:41,190
so for example heterogeneity the ability

00:06:39,180 --> 00:06:43,860
to support multiple diff

00:06:41,190 --> 00:06:46,530
environments cloud found you manages

00:06:43,860 --> 00:06:48,630
this really well it has the Bosch CPI

00:06:46,530 --> 00:06:52,650
for supporting different is layers like

00:06:48,630 --> 00:06:54,270
AWS or vSphere or Azure we have bill

00:06:52,650 --> 00:06:56,220
packs to support that polyglot

00:06:54,270 --> 00:06:58,470
programming environment so you can

00:06:56,220 --> 00:07:00,210
support Ruby you can support Java or all

00:06:58,470 --> 00:07:02,550
the languages that run on the JVM and

00:07:00,210 --> 00:07:04,740
you can support node and so on and it

00:07:02,550 --> 00:07:06,420
also has this marketplace for the

00:07:04,740 --> 00:07:09,570
middleware services like Redis and

00:07:06,420 --> 00:07:11,550
RabbitMQ and my sequel but all those

00:07:09,570 --> 00:07:12,960
components need to be extensible you

00:07:11,550 --> 00:07:16,620
need to be able to extend the platform

00:07:12,960 --> 00:07:19,050
and again a great example of this is the

00:07:16,620 --> 00:07:21,390
route service or route service instead

00:07:19,050 --> 00:07:22,860
of the marketplace just being about the

00:07:21,390 --> 00:07:24,300
middleware components you now have

00:07:22,860 --> 00:07:27,360
services for the route to your

00:07:24,300 --> 00:07:29,760
application and again UCP is are coming

00:07:27,360 --> 00:07:32,460
out all the time with photon and GCP and

00:07:29,760 --> 00:07:33,810
also you can extend the bill packs and

00:07:32,460 --> 00:07:37,170
you have other bill packs like the tommy

00:07:33,810 --> 00:07:40,140
bill pack coming out so extensibility is

00:07:37,170 --> 00:07:42,510
really key you also need transparency

00:07:40,140 --> 00:07:44,070
now a lot of people look at transparency

00:07:42,510 --> 00:07:46,290
is everything being open and available

00:07:44,070 --> 00:07:48,390
but actually in a distributed system I

00:07:46,290 --> 00:07:50,340
feel actually really means the opposite

00:07:48,390 --> 00:07:51,710
instead of seeing all the complexity and

00:07:50,340 --> 00:07:54,390
all the gory details

00:07:51,710 --> 00:07:56,520
what distributed systems need to do is

00:07:54,390 --> 00:07:58,020
they hide that level of complexity and

00:07:56,520 --> 00:08:00,510
make them transparent to the end-user

00:07:58,020 --> 00:08:02,310
make it clear to the end-user so the end

00:08:00,510 --> 00:08:05,210
user has a really simple way of

00:08:02,310 --> 00:08:07,740
interacting with that system

00:08:05,210 --> 00:08:10,350
distributed systems also need stable

00:08:07,740 --> 00:08:13,320
api's they need well-defined api's that

00:08:10,350 --> 00:08:16,530
are stable an example of a good stable

00:08:13,320 --> 00:08:19,560
API is or effectively like a USB it's

00:08:16,530 --> 00:08:23,070
been around for ages a bad API would be

00:08:19,560 --> 00:08:24,780
like the new iPhone headphone jack and I

00:08:23,070 --> 00:08:26,940
mean it means you have to update your

00:08:24,780 --> 00:08:29,760
earphones and everything else so you

00:08:26,940 --> 00:08:32,430
need those api's to be stable as much as

00:08:29,760 --> 00:08:34,650
possible this gives each component the

00:08:32,430 --> 00:08:37,110
ability to be independent and decoupled

00:08:34,650 --> 00:08:38,789
and that's really valuable because then

00:08:37,110 --> 00:08:40,890
you can plug and play those components

00:08:38,789 --> 00:08:42,120
you can swap them out to replace them

00:08:40,890 --> 00:08:46,110
and the system as a whole

00:08:42,120 --> 00:08:47,820
carries on working so just to delve into

00:08:46,110 --> 00:08:50,010
the details for Cloud Foundry for a

00:08:47,820 --> 00:08:53,190
second a great example of stable api's

00:08:50,010 --> 00:08:56,790
is the cell so if you look at a Linux

00:08:53,190 --> 00:08:58,880
cell applications run on cells in Linux

00:08:56,790 --> 00:09:01,830
they run on Runcie backed containers

00:08:58,880 --> 00:09:04,320
containers are managed by garden and the

00:09:01,830 --> 00:09:07,650
cell itself is managed by the rep in the

00:09:04,320 --> 00:09:10,950
rep talks to Diego now there's a

00:09:07,650 --> 00:09:13,650
decoupled interaction between garden and

00:09:10,950 --> 00:09:15,990
the rep but there's a strong contract

00:09:13,650 --> 00:09:17,910
between them because garden isn't

00:09:15,990 --> 00:09:19,860
participating as part of that wider

00:09:17,910 --> 00:09:23,010
distributive system you can make

00:09:19,860 --> 00:09:24,870
breaking changes to the API but because

00:09:23,010 --> 00:09:27,720
it's coupled to the rep you'll also have

00:09:24,870 --> 00:09:30,270
to change the rep by keeping the garden

00:09:27,720 --> 00:09:32,550
API stable it's got really strong

00:09:30,270 --> 00:09:34,200
advantages so for example you can swap

00:09:32,550 --> 00:09:36,570
out the back end it was Guardian now

00:09:34,200 --> 00:09:39,240
it's run see if there's a CVE

00:09:36,570 --> 00:09:41,430
all you have to do is upgrade garden and

00:09:39,240 --> 00:09:43,350
we make a promise to the community that

00:09:41,430 --> 00:09:45,900
if you're on Diego version X and above

00:09:43,350 --> 00:09:47,550
all you need to do is redeploy garden

00:09:45,900 --> 00:09:49,589
and you get all the latest security

00:09:47,550 --> 00:09:51,930
fixes you don't have to do any changes

00:09:49,589 --> 00:09:55,300
to the rep or any other components so

00:09:51,930 --> 00:09:57,940
stable a PRS are really valuable

00:09:55,300 --> 00:10:00,370
descriptive systems also need to support

00:09:57,940 --> 00:10:02,230
concurrency when you have many different

00:10:00,370 --> 00:10:03,880
users whether they're users of your

00:10:02,230 --> 00:10:06,310
application or whether they're different

00:10:03,880 --> 00:10:08,709
developers or competing to view and

00:10:06,310 --> 00:10:10,630
update the same piece of data the system

00:10:08,709 --> 00:10:11,829
needs to handle that in a robust way and

00:10:10,630 --> 00:10:13,300
things like dynamic routing and

00:10:11,829 --> 00:10:15,600
distributed locks really help with

00:10:13,300 --> 00:10:18,430
dealing with the concurrency challenges

00:10:15,600 --> 00:10:20,500
so the list of lists of complexity just

00:10:18,430 --> 00:10:23,320
keeps on growing there's things like

00:10:20,500 --> 00:10:25,510
security and self-healing and monitoring

00:10:23,320 --> 00:10:26,800
and logging and user management when

00:10:25,510 --> 00:10:28,060
you're running a distributed system

00:10:26,800 --> 00:10:30,700
especially in a cloud environment

00:10:28,060 --> 00:10:33,480
there's many components that go into

00:10:30,700 --> 00:10:35,920
making that system stable and reliable

00:10:33,480 --> 00:10:38,470
so in essence they're hard to build and

00:10:35,920 --> 00:10:40,269
complex in nature and it's because

00:10:38,470 --> 00:10:42,279
distributive systems like Diego are

00:10:40,269 --> 00:10:44,769
complex there's a lot of value in really

00:10:42,279 --> 00:10:46,899
understanding them for example the Cloud

00:10:44,769 --> 00:10:48,550
Foundry operator there's at least two

00:10:46,899 --> 00:10:51,730
reasons why they should be concerned

00:10:48,550 --> 00:10:53,170
about the internals the first reason you

00:10:51,730 --> 00:10:56,110
need to care is because you want to

00:10:53,170 --> 00:10:57,850
debug your app if the users accessing an

00:10:56,110 --> 00:10:59,500
endpoint or routing Cloud Foundry from

00:10:57,850 --> 00:11:01,839
an application and for some reason that

00:10:59,500 --> 00:11:03,579
route goes away there could be any

00:11:01,839 --> 00:11:05,529
number of failures to coerce out to

00:11:03,579 --> 00:11:07,899
happen and without understanding the

00:11:05,529 --> 00:11:10,410
system we've done a way to debug so for

00:11:07,899 --> 00:11:10,410
example

00:11:11,060 --> 00:11:14,959
your container could have died or your

00:11:13,529 --> 00:11:18,329
app may have crashed in the container

00:11:14,959 --> 00:11:20,339
the rep on the cell may have died and it

00:11:18,329 --> 00:11:22,620
looks like your cell is offline or the

00:11:20,339 --> 00:11:24,540
router meter may have died causing the

00:11:22,620 --> 00:11:26,850
dynamic routing table not to get updated

00:11:24,540 --> 00:11:29,100
so any one of these failures could of

00:11:26,850 --> 00:11:30,300
course out effect and it's important to

00:11:29,100 --> 00:11:32,670
understand the flow of communication

00:11:30,300 --> 00:11:35,610
between the components in the system to

00:11:32,670 --> 00:11:37,560
really understand what's going on the

00:11:35,610 --> 00:11:39,480
second reason why you need to care about

00:11:37,560 --> 00:11:42,449
the internals is because you need to

00:11:39,480 --> 00:11:44,670
establish resiliency components like

00:11:42,449 --> 00:11:46,230
console and XE D and my sequel use a

00:11:44,670 --> 00:11:48,720
raft protocol which means they need a

00:11:46,230 --> 00:11:50,220
quorum and to have a quorum you need an

00:11:48,720 --> 00:11:52,680
odd number if you just have a single

00:11:50,220 --> 00:11:55,320
node and that node dies you've lost your

00:11:52,680 --> 00:11:57,480
service if you have two nodes and a

00:11:55,320 --> 00:11:59,970
single node dies you still don't have

00:11:57,480 --> 00:12:01,500
more than 50% remaining and therefore

00:11:59,970 --> 00:12:03,389
the system as a whole will shut down or

00:12:01,500 --> 00:12:05,550
may need manual intervention to restart

00:12:03,389 --> 00:12:08,279
so ideally you need three nodes

00:12:05,550 --> 00:12:11,160
preferably in three different AZ's so if

00:12:08,279 --> 00:12:12,779
you lose a node or you lose an AZ your

00:12:11,160 --> 00:12:15,660
system still has quorum and it still

00:12:12,779 --> 00:12:17,670
remains operational other components

00:12:15,660 --> 00:12:20,220
like the brain you have multiple

00:12:17,670 --> 00:12:21,930
versions for resiliency but they can

00:12:20,220 --> 00:12:23,610
only work in isolation so they need to

00:12:21,930 --> 00:12:25,050
establish things like distributed locks

00:12:23,610 --> 00:12:26,940
to ensure that they're not trampling

00:12:25,050 --> 00:12:28,470
over each other so again by

00:12:26,940 --> 00:12:32,240
understanding the system it helps you

00:12:28,470 --> 00:12:32,240
build in the right level of resiliency

00:12:35,920 --> 00:12:41,930
so how does Diego deal with some of

00:12:39,050 --> 00:12:43,340
these distributed system challenges the

00:12:41,930 --> 00:12:45,350
more I looked at Diego the more I

00:12:43,340 --> 00:12:48,050
realized actually has a very elegant

00:12:45,350 --> 00:12:50,150
approach and I've loosely termed these

00:12:48,050 --> 00:12:51,410
as Diego abstractions and I'm going to

00:12:50,150 --> 00:12:55,700
take you through some of the high-level

00:12:51,410 --> 00:12:58,280
ones Diego itself is a subsystem to

00:12:55,700 --> 00:12:59,900
Cloud Foundry so things like cloud

00:12:58,280 --> 00:13:02,180
foundries cloud controller on cloud

00:12:59,900 --> 00:13:02,870
foundry slogra Gator access Diego as a

00:13:02,180 --> 00:13:05,510
client

00:13:02,870 --> 00:13:07,280
Diego is comprised of a number of

00:13:05,510 --> 00:13:09,950
independent components and each

00:13:07,280 --> 00:13:12,230
component hosts a set of micro services

00:13:09,950 --> 00:13:14,420
which are scoped to the boundary of that

00:13:12,230 --> 00:13:15,950
component and as I mentioned the

00:13:14,420 --> 00:13:18,620
important thing to understand is how

00:13:15,950 --> 00:13:19,730
work flows through the system actually

00:13:18,620 --> 00:13:21,440
understanding the technical

00:13:19,730 --> 00:13:23,510
implementation of things like the BBS

00:13:21,440 --> 00:13:26,870
and what backs of BBS is less important

00:13:23,510 --> 00:13:29,210
the engineers can swap out XE D for my

00:13:26,870 --> 00:13:32,890
sequel for example and by and large the

00:13:29,210 --> 00:13:32,890
system should operate in the same way

00:13:33,579 --> 00:13:38,690
so Diego is a decoupled infrastructure a

00:13:37,040 --> 00:13:41,209
number of different components are

00:13:38,690 --> 00:13:42,980
responsible for the orchestration and it

00:13:41,209 --> 00:13:45,319
handles this through a separation of

00:13:42,980 --> 00:13:47,360
concerns between these components and it

00:13:45,319 --> 00:13:49,639
uses abstraction layers as work flow

00:13:47,360 --> 00:13:51,980
throughout the system and this gives the

00:13:49,639 --> 00:13:53,930
benefit that work can be agnostic so

00:13:51,980 --> 00:13:56,449
Diego can now support a rich a set of

00:13:53,930 --> 00:13:58,490
workloads and is also contained an

00:13:56,449 --> 00:14:00,920
agnostic both in the image format you

00:13:58,490 --> 00:14:02,720
deploy to Cloud Foundry and also on the

00:14:00,920 --> 00:14:06,740
backend as well in terms of how you run

00:14:02,720 --> 00:14:09,110
your applications the first abstraction

00:14:06,740 --> 00:14:10,370
I want to cover is subsystems and again

00:14:09,110 --> 00:14:12,290
this may seem like I'm going off at

00:14:10,370 --> 00:14:15,230
tangible actually subsystems are really

00:14:12,290 --> 00:14:17,420
important to cloud foundry Diego has

00:14:15,230 --> 00:14:20,209
been encapsulated in his own Bosch

00:14:17,420 --> 00:14:21,709
release so its own codebase and this is

00:14:20,209 --> 00:14:24,649
really valuable because it's become

00:14:21,709 --> 00:14:27,230
independently deployable as a standalone

00:14:24,649 --> 00:14:29,209
system standalone systems typically

00:14:27,230 --> 00:14:31,100
offer a pattern of reuse I don't know

00:14:29,209 --> 00:14:33,500
anyone outside the Cloud Foundry system

00:14:31,100 --> 00:14:35,750
using Diego so why is this so important

00:14:33,500 --> 00:14:37,100
to have an independent code base it

00:14:35,750 --> 00:14:39,259
gives a couple of things when you start

00:14:37,100 --> 00:14:42,829
to decompose conceptually at least a

00:14:39,259 --> 00:14:45,680
monolith into subsystems it allows each

00:14:42,829 --> 00:14:46,519
individual subsystem to grow and evolve

00:14:45,680 --> 00:14:49,220
as it needs to

00:14:46,519 --> 00:14:51,649
this increases the developer velocity

00:14:49,220 --> 00:14:54,860
but it also has a really rich side

00:14:51,649 --> 00:14:57,230
benefit of testability so the release

00:14:54,860 --> 00:14:59,360
engineer or the platform operator can

00:14:57,230 --> 00:15:00,560
take a more granular approach to testing

00:14:59,360 --> 00:15:03,170
because they have a number of different

00:15:00,560 --> 00:15:05,779
subsystems so for example if you deploy

00:15:03,170 --> 00:15:07,880
the latest version of Diego but you back

00:15:05,779 --> 00:15:09,380
it with an old version of Postgres if

00:15:07,880 --> 00:15:11,180
you then migrate that version of

00:15:09,380 --> 00:15:14,000
Postgres to your new version will Diego

00:15:11,180 --> 00:15:15,889
still be able to interact with it so in

00:15:14,000 --> 00:15:18,709
addition to just having backwards

00:15:15,889 --> 00:15:20,360
compatible api's you can also now to

00:15:18,709 --> 00:15:22,310
have a more granular approach to

00:15:20,360 --> 00:15:25,160
actually migrating disparate components

00:15:22,310 --> 00:15:27,079
so it gives a richer testing cycle but

00:15:25,160 --> 00:15:29,720
in addition for the individual teams

00:15:27,079 --> 00:15:32,329
that allows for isolated testing so now

00:15:29,720 --> 00:15:35,060
just the owner of that subsystem can

00:15:32,329 --> 00:15:36,649
focus on their subsystem they can have

00:15:35,060 --> 00:15:38,569
assurance that the teams which they

00:15:36,649 --> 00:15:40,189
depend on have done their due diligence

00:15:38,569 --> 00:15:41,870
and they can also not worry too much

00:15:40,189 --> 00:15:43,760
about the downstream teams it means that

00:15:41,870 --> 00:15:45,100
their view of the distributed system is

00:15:43,760 --> 00:15:46,690
way smaller we

00:15:45,100 --> 00:15:51,790
ultimately allows them to move a lot

00:15:46,690 --> 00:15:54,700
faster the second abstraction is work

00:15:51,790 --> 00:15:56,530
later abstraction so most people know

00:15:54,700 --> 00:15:58,210
that Cloud Foundry is moved beyond two

00:15:56,530 --> 00:16:01,360
supporting applications to this more

00:15:58,210 --> 00:16:04,990
generic term of long-running processes

00:16:01,360 --> 00:16:06,970
and tasks so a long-running process is

00:16:04,990 --> 00:16:09,640
diego's view of your application its

00:16:06,970 --> 00:16:12,430
desired to just keep on running Diego

00:16:09,640 --> 00:16:14,800
has a view conceptually of a desired lrp

00:16:12,430 --> 00:16:16,540
a long-running process and an actual

00:16:14,800 --> 00:16:19,120
process running in a container known as

00:16:16,540 --> 00:16:20,800
your actual lrp if you scale that

00:16:19,120 --> 00:16:24,880
process you can then have multiple

00:16:20,800 --> 00:16:25,660
actual n RPS for your lrp now LR PS have

00:16:24,880 --> 00:16:27,550
a life cycle

00:16:25,660 --> 00:16:30,280
I'm not going to dig too much into Diego

00:16:27,550 --> 00:16:32,050
state machine but these life cycles

00:16:30,280 --> 00:16:33,850
pretty much map to the behavior you'd

00:16:32,050 --> 00:16:35,740
expect so if you see your application

00:16:33,850 --> 00:16:37,240
running it's likely to be in a running

00:16:35,740 --> 00:16:39,250
State if you see a crashed it's likely

00:16:37,240 --> 00:16:41,860
to be in the crash phase of the life

00:16:39,250 --> 00:16:43,270
cycle but the reason why life cycles

00:16:41,860 --> 00:16:46,420
were important to understand is if you

00:16:43,270 --> 00:16:48,700
go in and query Diego's database of BBS

00:16:46,420 --> 00:16:50,830
and you see your applications in

00:16:48,700 --> 00:16:52,270
unclaimed State it could well be you

00:16:50,830 --> 00:16:54,460
haven't provisioned enough resource for

00:16:52,270 --> 00:16:56,470
yourselves so by understanding something

00:16:54,460 --> 00:16:59,370
about the lifecycle stayed you can help

00:16:56,470 --> 00:16:59,370
you troubleshoot as well

00:17:00,209 --> 00:17:05,470
so onto tasks tasks are guaranteed to be

00:17:03,850 --> 00:17:07,839
run at once they're effectively a

00:17:05,470 --> 00:17:09,309
singleton they should always terminate

00:17:07,839 --> 00:17:11,829
and they should have a finite running

00:17:09,309 --> 00:17:13,870
time so tasks could be anything from a

00:17:11,829 --> 00:17:15,250
wanna script like a batch job or a con

00:17:13,870 --> 00:17:17,980
job or maybe you're doing stream

00:17:15,250 --> 00:17:19,990
processing using ELT applications

00:17:17,980 --> 00:17:22,150
themselves can call out and run one-off

00:17:19,990 --> 00:17:24,910
tasks so applications can now use this

00:17:22,150 --> 00:17:26,650
task abstraction but the other important

00:17:24,910 --> 00:17:30,429
feature of the task abstraction is the

00:17:26,650 --> 00:17:32,320
Cloud Foundry itself uses tasks as a end

00:17:30,429 --> 00:17:33,790
user you ask Larr foundry to run your

00:17:32,320 --> 00:17:35,920
application your application goes

00:17:33,790 --> 00:17:37,630
through the staging process and the

00:17:35,920 --> 00:17:39,580
staging requests from Diego gets

00:17:37,630 --> 00:17:41,420
encapsulated as an internal task from

00:17:39,580 --> 00:17:44,620
Diego

00:17:41,420 --> 00:17:47,360
so in addition to tasks and L RPS

00:17:44,620 --> 00:17:50,210
applications or actual LR T's also have

00:17:47,360 --> 00:17:52,130
this app lifecycle the app lifecycle is

00:17:50,210 --> 00:17:54,080
responsible for building and running and

00:17:52,130 --> 00:17:56,120
keeping your app running so there's

00:17:54,080 --> 00:17:58,490
three distinct phases there's a builder

00:17:56,120 --> 00:17:59,900
which actually runs your application or

00:17:58,490 --> 00:18:00,950
sorry with the builds your droplet and

00:17:59,900 --> 00:18:02,420
build your application there's a

00:18:00,950 --> 00:18:04,340
launcher which runs your application

00:18:02,420 --> 00:18:05,810
there's also a health check that runs

00:18:04,340 --> 00:18:08,540
alongside the application in the

00:18:05,810 --> 00:18:09,890
container application life cycles aren't

00:18:08,540 --> 00:18:11,450
anything new they've been around for

00:18:09,890 --> 00:18:14,360
some time so in the old world

00:18:11,450 --> 00:18:16,460
they were packaged as bill packs on the

00:18:14,360 --> 00:18:18,830
runner the DEA the VM that used to be

00:18:16,460 --> 00:18:20,840
responsible for running the component of

00:18:18,830 --> 00:18:22,070
the applications and you can start to

00:18:20,840 --> 00:18:25,040
get a sense of this tight coupling

00:18:22,070 --> 00:18:27,700
between what actually ran I'm sorry I

00:18:25,040 --> 00:18:27,700
just go back one

00:18:29,570 --> 00:18:34,740
between what ran how it worked and also

00:18:32,879 --> 00:18:37,399
where it ran so this tight coupling was

00:18:34,740 --> 00:18:39,779
on one of the core challenges originally

00:18:37,399 --> 00:18:42,509
bill pack still exists but they're part

00:18:39,779 --> 00:18:43,950
of this more generic execution so now

00:18:42,509 --> 00:18:45,629
they're not coupled with the cell

00:18:43,950 --> 00:18:47,549
meaning the cells significantly lighter

00:18:45,629 --> 00:18:50,249
weight and also because they're

00:18:47,549 --> 00:18:52,230
decoupled you have this plug ability you

00:18:50,249 --> 00:18:53,970
can have Bill pack life cycles doctor

00:18:52,230 --> 00:18:55,289
life cycles window life cycles if you

00:18:53,970 --> 00:18:57,990
have a different type of workload in the

00:18:55,289 --> 00:19:00,149
future you can just add that in the mix

00:18:57,990 --> 00:19:01,769
so the way it works is when you need to

00:19:00,149 --> 00:19:04,129
use something like a Bill pack it gets

00:19:01,769 --> 00:19:06,600
injected into the cell

00:19:04,129 --> 00:19:08,040
so it's decoupled ins deep lot anas

00:19:06,600 --> 00:19:10,450
pluggable

00:19:08,040 --> 00:19:11,380
so looking at containers and I've

00:19:10,450 --> 00:19:13,690
touched on this before in a previous

00:19:11,380 --> 00:19:15,070
talk but I still see a lot of confusion

00:19:13,690 --> 00:19:17,140
out there in terms of what Ashley can

00:19:15,070 --> 00:19:18,970
Cloud Foundry support in terms of the

00:19:17,140 --> 00:19:21,760
file system Cloud Foundry supports

00:19:18,970 --> 00:19:23,530
docker images and it also supports the

00:19:21,760 --> 00:19:25,840
ability for you to push your application

00:19:23,530 --> 00:19:28,300
and allow Cloud Foundry to build it into

00:19:25,840 --> 00:19:30,340
a droplet plus a stack so the file

00:19:28,300 --> 00:19:32,140
system is what you actually run the

00:19:30,340 --> 00:19:33,850
thing responsible for building and

00:19:32,140 --> 00:19:36,070
running that isolated process that

00:19:33,850 --> 00:19:37,930
container management is garden and

00:19:36,070 --> 00:19:40,060
garden can be backed by Linux or it can

00:19:37,930 --> 00:19:42,550
be about currently by Windows but really

00:19:40,060 --> 00:19:44,620
we talk about containers anything which

00:19:42,550 --> 00:19:46,690
adheres to the garden API can be plugged

00:19:44,620 --> 00:19:48,730
in so if you want to run on run V or you

00:19:46,690 --> 00:19:50,080
want thrown on bare metal conceptually

00:19:48,730 --> 00:19:52,650
all of that can be plugged into that

00:19:50,080 --> 00:19:52,650
garden API

00:19:52,980 --> 00:19:59,230
so Diego itself has what we loosely comb

00:19:56,470 --> 00:20:01,120
Action abstraction and this is fairly

00:19:59,230 --> 00:20:04,450
complicated but all the pieces within

00:20:01,120 --> 00:20:06,580
Diego but totally independent decoupled

00:20:04,450 --> 00:20:08,650
concerns and that means that they can

00:20:06,580 --> 00:20:10,030
solve their task at hand in isolation

00:20:08,650 --> 00:20:12,430
they can choose to have unique

00:20:10,030 --> 00:20:14,890
expressions of the problem as it flows

00:20:12,430 --> 00:20:16,990
through the Diego system and it can

00:20:14,890 --> 00:20:18,940
choose the right expression depending on

00:20:16,990 --> 00:20:20,260
the problem being solved now there's a

00:20:18,940 --> 00:20:23,560
lot of information there so let's

00:20:20,260 --> 00:20:25,300
visualize that as you see f.push as an

00:20:23,560 --> 00:20:27,460
end user your app to the cloud

00:20:25,300 --> 00:20:29,290
controller the cloud controller of them

00:20:27,460 --> 00:20:32,020
passes it into this bridge layer called

00:20:29,290 --> 00:20:34,360
the CC bridge that then goes to Diego's

00:20:32,020 --> 00:20:37,180
database it goes onto an auction and

00:20:34,360 --> 00:20:39,570
ultimately that request ends up as a

00:20:37,180 --> 00:20:42,400
scheduled process running on a container

00:20:39,570 --> 00:20:44,230
as work flows through the system it

00:20:42,400 --> 00:20:46,930
starts really coarse-grained as this big

00:20:44,230 --> 00:20:49,240
kind of Boulder like analogy and it gets

00:20:46,930 --> 00:20:52,540
broken down into finally something very

00:20:49,240 --> 00:20:54,640
granular as a scheduled process now if

00:20:52,540 --> 00:20:56,380
everything within Diego was concerned

00:20:54,640 --> 00:20:58,840
with this scheduled process it would be

00:20:56,380 --> 00:21:00,700
incredibly brittle and it would be very

00:20:58,840 --> 00:21:03,700
complicated for the end user to interact

00:21:00,700 --> 00:21:06,310
with it so by adopting the ability for

00:21:03,700 --> 00:21:08,110
each component to have its own view of

00:21:06,310 --> 00:21:10,780
the work in its own expressions of that

00:21:08,110 --> 00:21:12,250
work and abstractions it allows for this

00:21:10,780 --> 00:21:14,230
plug-and-play model where you can take

00:21:12,250 --> 00:21:16,300
things out and replace them but it also

00:21:14,230 --> 00:21:20,440
allows for this really easy transparent

00:21:16,300 --> 00:21:22,270
client client interaction and so as this

00:21:20,440 --> 00:21:24,610
workload gets kicked off as the cloud

00:21:22,270 --> 00:21:27,010
controller interacts with Diego it's

00:21:24,610 --> 00:21:28,710
imperative it can say run this and then

00:21:27,010 --> 00:21:31,390
it can leave Diego to do its thing

00:21:28,710 --> 00:21:33,310
Diego knows about the desired state and

00:21:31,390 --> 00:21:34,690
it tries to rectify the desired state

00:21:33,310 --> 00:21:36,970
with the actual state and run that

00:21:34,690 --> 00:21:38,380
workload so the cloud controller beyond

00:21:36,970 --> 00:21:42,370
that point doesn't need to be overly

00:21:38,380 --> 00:21:44,020
concerned with how Diego does its job so

00:21:42,370 --> 00:21:46,180
the cloud controller which is Cloud

00:21:44,020 --> 00:21:47,710
Foundry and Diego have to effectively

00:21:46,180 --> 00:21:49,330
different views of the world Diego's

00:21:47,710 --> 00:21:51,250
view is very generic and clouds

00:21:49,330 --> 00:21:53,860
Foundries view is very specific for

00:21:51,250 --> 00:21:55,510
Cloud Foundry and this bridge component

00:21:53,860 --> 00:21:56,860
in the middle allows the translation

00:21:55,510 --> 00:21:59,440
between the two

00:21:56,860 --> 00:22:02,019
so for example when you stage your

00:21:59,440 --> 00:22:04,510
application Cloud Foundry knows of the

00:22:02,019 --> 00:22:06,880
app needs to be staged but Diego turns

00:22:04,510 --> 00:22:10,480
the engine generic set of stating tasks

00:22:06,880 --> 00:22:12,880
or LR P's and so on and the uploader as

00:22:10,480 --> 00:22:14,500
well Cloud Foundry knows that you should

00:22:12,880 --> 00:22:15,909
upload droplets to his blob store and

00:22:14,500 --> 00:22:18,370
download droplets from his blob store

00:22:15,909 --> 00:22:20,019
but the upload action in Diego is only

00:22:18,370 --> 00:22:22,870
concerned about upload a file to this

00:22:20,019 --> 00:22:24,340
URL it doesn't have to specify the URL

00:22:22,870 --> 00:22:28,289
as the blob store that's Cloud Foundry

00:22:24,340 --> 00:22:28,289
is concerned to tell Diego about it

00:22:28,620 --> 00:22:34,950
so the BBS diego's BBS which is

00:22:31,890 --> 00:22:36,660
effectively Diego's API uses something

00:22:34,950 --> 00:22:38,550
called composable actions and this is

00:22:36,660 --> 00:22:43,530
the next layer down from tasks and LR

00:22:38,550 --> 00:22:47,370
peas so we talked about tasks and LR

00:22:43,530 --> 00:22:49,050
peas they get translated into diego's

00:22:47,370 --> 00:22:51,270
composable actions things like download

00:22:49,050 --> 00:22:52,860
a droplet download action run action and

00:22:51,270 --> 00:22:55,200
again these are imperative actions

00:22:52,860 --> 00:22:57,240
they're an instruction set and you get

00:22:55,200 --> 00:22:58,800
this tree and these instructions end up

00:22:57,240 --> 00:23:00,809
being the components that actually run

00:22:58,800 --> 00:23:04,590
on the cell and negatory in the

00:23:00,809 --> 00:23:08,640
container so how do L RPS

00:23:04,590 --> 00:23:11,370
and tasks translate to these composable

00:23:08,640 --> 00:23:13,110
actions so let's take a take them the

00:23:11,370 --> 00:23:15,840
scenario way of staging an app or you're

00:23:13,110 --> 00:23:18,330
running a staged out you will have three

00:23:15,840 --> 00:23:20,490
composable actions you have a download

00:23:18,330 --> 00:23:22,950
action to download the droplet from the

00:23:20,490 --> 00:23:24,630
CC blob store there's another download

00:23:22,950 --> 00:23:27,240
action to download the app lifecycle

00:23:24,630 --> 00:23:29,809
binaries and then there's a run action

00:23:27,240 --> 00:23:32,250
to run all this stuff on to a container

00:23:29,809 --> 00:23:34,170
the important thing is this is another

00:23:32,250 --> 00:23:36,300
level of granularity beyond the LR PS

00:23:34,170 --> 00:23:39,270
but this is still describing the desired

00:23:36,300 --> 00:23:40,770
activity not the implementation so as I

00:23:39,270 --> 00:23:41,910
mentioned things like the implementation

00:23:40,770 --> 00:23:43,230
that you're downloading from the blob

00:23:41,910 --> 00:23:46,679
store all of that still comes from the

00:23:43,230 --> 00:23:48,750
Cloud Controller so the last abstraction

00:23:46,679 --> 00:23:51,929
I'm going to talk about is closed

00:23:48,750 --> 00:23:55,880
feedback loops and again this is key to

00:23:51,929 --> 00:23:55,880
keeping that distributed system in place

00:23:56,620 --> 00:24:02,260
so the CC bridge has two core components

00:23:59,980 --> 00:24:04,330
to offer this close feedback loop it's

00:24:02,260 --> 00:24:06,940
the ability to handle domain freshness

00:24:04,330 --> 00:24:10,360
and this is done by N Sync and it's also

00:24:06,940 --> 00:24:13,090
done by the TPS so the cloud controller

00:24:10,360 --> 00:24:14,710
tells the CC bridge doesn't speak to

00:24:13,090 --> 00:24:17,230
Diego directly it tells the CC bridge

00:24:14,710 --> 00:24:20,320
about the desired app and then NSYNC

00:24:17,230 --> 00:24:22,840
tells Diego to go and make that so so

00:24:20,320 --> 00:24:24,700
Diego has this view of the world that it

00:24:22,840 --> 00:24:27,070
knows what the cloud controller wants in

00:24:24,700 --> 00:24:28,570
those the desired state and it goes

00:24:27,070 --> 00:24:30,789
through this auction process to make

00:24:28,570 --> 00:24:33,370
that a reality so at that point

00:24:30,789 --> 00:24:34,899
everything's good and Diego is running

00:24:33,370 --> 00:24:37,600
the required level of apps if now

00:24:34,899 --> 00:24:39,460
crashes because Diego knows the desired

00:24:37,600 --> 00:24:42,429
state it can bring another instance of

00:24:39,460 --> 00:24:43,840
that app back but just stopping there

00:24:42,429 --> 00:24:45,340
isn't enough because this is a

00:24:43,840 --> 00:24:48,159
distributive system it's eventually

00:24:45,340 --> 00:24:50,320
consistent in cloud controllers view of

00:24:48,159 --> 00:24:52,120
the world may change maybe you want

00:24:50,320 --> 00:24:53,980
something different or maybe it sent so

00:24:52,120 --> 00:24:56,950
many messages to Diego that one of those

00:24:53,980 --> 00:24:59,020
messages has been lost so there's this N

00:24:56,950 --> 00:25:01,690
Sync polka that periodically checks

00:24:59,020 --> 00:25:03,130
cloud controllers required state it

00:25:01,690 --> 00:25:05,890
desired state and what's actually

00:25:03,130 --> 00:25:08,169
running over in Diego and then using

00:25:05,890 --> 00:25:10,179
cloud controller is the authority the

00:25:08,169 --> 00:25:12,279
anything bokeh the bulker can then give

00:25:10,179 --> 00:25:15,669
Diego a new view of the world a new

00:25:12,279 --> 00:25:17,380
desired state there's also this TPS

00:25:15,669 --> 00:25:19,270
listener and watcher as well and this

00:25:17,380 --> 00:25:21,850
gives the cloud controller the ability

00:25:19,270 --> 00:25:24,130
to query Diego and find out what's going

00:25:21,850 --> 00:25:26,020
on and it also listens for any crash

00:25:24,130 --> 00:25:27,240
events and it feeds us back into the

00:25:26,020 --> 00:25:29,860
cloud controller as well

00:25:27,240 --> 00:25:32,679
so this closed feedback loop is

00:25:29,860 --> 00:25:34,390
essential for getting that domain

00:25:32,679 --> 00:25:37,240
freshness in place and we see this model

00:25:34,390 --> 00:25:39,520
again and again so the brain to the rep

00:25:37,240 --> 00:25:41,649
interaction works in a similar way where

00:25:39,520 --> 00:25:44,140
the auction passes information over and

00:25:41,649 --> 00:25:45,820
then the converger is looking for that

00:25:44,140 --> 00:25:48,490
state as rectifiers and the things

00:25:45,820 --> 00:25:50,049
missing so again that's a whistle-stop

00:25:48,490 --> 00:25:52,179
tour through the abstractions we've

00:25:50,049 --> 00:25:53,710
talked about subsystems we've talked

00:25:52,179 --> 00:25:55,510
about workloads and the life cycles

00:25:53,710 --> 00:25:58,330
container abstractions composable

00:25:55,510 --> 00:26:00,429
actions and feedback loops so these are

00:25:58,330 --> 00:26:03,399
Diego's abstractions for dealing with

00:26:00,429 --> 00:26:05,380
that challenge of complexity and Diego

00:26:03,399 --> 00:26:07,330
has a layered approach and the layered

00:26:05,380 --> 00:26:10,060
approach allows for each component to

00:26:07,330 --> 00:26:12,700
work in isolation and it also a force

00:26:10,060 --> 00:26:15,190
pattern of reuse ultimately that gives

00:26:12,700 --> 00:26:17,020
you better user transparency and with

00:26:15,190 --> 00:26:18,850
each subsystem whether it's the Diego

00:26:17,020 --> 00:26:21,790
subsystem with respect to Cloud Foundry

00:26:18,850 --> 00:26:23,440
or as the subsystems within Diego you

00:26:21,790 --> 00:26:24,760
get this iterative development this

00:26:23,440 --> 00:26:26,950
development velocity and better

00:26:24,760 --> 00:26:29,410
testability and you also get this

00:26:26,950 --> 00:26:32,290
plug-and-play capability as well so

00:26:29,410 --> 00:26:37,579
that's it thank you very much

00:26:32,290 --> 00:26:37,579

YouTube URL: https://www.youtube.com/watch?v=8rzxE_rn0Wc


