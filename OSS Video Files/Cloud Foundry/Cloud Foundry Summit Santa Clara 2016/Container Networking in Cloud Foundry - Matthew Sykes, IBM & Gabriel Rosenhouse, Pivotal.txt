Title: Container Networking in Cloud Foundry - Matthew Sykes, IBM & Gabriel Rosenhouse, Pivotal
Publication date: 2016-05-29
Playlist: Cloud Foundry Summit Santa Clara 2016
Description: 
	Modern applications consist of small, highly interconnected, independently scalable units of deployment that are often referred to as “microservices.” When you deploy these services on Cloud Foundry today, they are forced to communicate via routes that are advertised to the external routing tier. Not only does this force all services to be exposed to external clients, it adds significant latency to the interactions between services. 

What if instead of exposing routes to all of your services, you could define the network topology that’s right for your application? How about defining an isolation policy to prevent unauthorized access? What about enabling secure access to existing networks? 

The Cloud Foundry Container Networking project hopes to make these things a reality. Come learn about where we are today, where we’re going, and how you can help us get there. 

Gabriel Rosenhouse
Software Engineer, Pivotal
Gabe is a software engineer at the Pivotal office in Santa Monica, California. He is currently working on the Cloud Foundry Container Networking team.

Matthew Sykes
STSM, IBM
Matthew is an senior technical staff member in IBM's open cloud technology group. He has been involved with Cloud Foundry since 2013 as part of the elastic runtime and Diego teams. He is currently working on the Cloud Foundry container networking project to enable flexible, efficient, and secure communications between containers and legacy networks. Prior to his work on Cloud Foundry, he worked on IBM application servers and middleware.
Captions: 
	00:00:01,970 --> 00:00:04,970
hello

00:00:08,700 --> 00:00:15,459
my name is Gabe Rosenhaus and I'm Matt

00:00:12,879 --> 00:00:22,500
Sykes welcome and we're part of the

00:00:15,459 --> 00:00:24,699
container networking engineering team so

00:00:22,500 --> 00:00:26,050
most of you probably already know the

00:00:24,699 --> 00:00:27,609
pitch you know why why are people

00:00:26,050 --> 00:00:28,810
looking to net worth of containers what

00:00:27,609 --> 00:00:30,070
do they get out of it one of the

00:00:28,810 --> 00:00:31,330
shortcomings of what we have today with

00:00:30,070 --> 00:00:33,760
cloud foundry in terms of conductivity

00:00:31,330 --> 00:00:36,629
between containers and we kind of tried

00:00:33,760 --> 00:00:38,469
to summarize that here in one little bit

00:00:36,629 --> 00:00:40,600
essentially what we've got today is

00:00:38,469 --> 00:00:42,219
we've got a model where users come in

00:00:40,600 --> 00:00:44,230
workloads come in through a front-end

00:00:42,219 --> 00:00:46,300
router the router then finds the

00:00:44,230 --> 00:00:49,149
container instance that's hosting your

00:00:46,300 --> 00:00:51,340
application it dispatches it inside the

00:00:49,149 --> 00:00:53,350
container but if that container then

00:00:51,340 --> 00:00:54,730
needs to talk to some other deployed

00:00:53,350 --> 00:00:56,440
application some other container in the

00:00:54,730 --> 00:00:58,449
Cloud Foundry network the only real way

00:00:56,440 --> 00:01:00,280
you have today to do that make that work

00:00:58,449 --> 00:01:01,780
is to come back around through the front

00:01:00,280 --> 00:01:03,879
door so you basically hit your load

00:01:01,780 --> 00:01:05,170
balancer you hit your proxies you have

00:01:03,879 --> 00:01:06,250
to go router and get back to the

00:01:05,170 --> 00:01:09,790
container that you actually wanted to

00:01:06,250 --> 00:01:14,290
hit and it's kind of obtuse it adds a

00:01:09,790 --> 00:01:17,860
huge expense for the round-trip it also

00:01:14,290 --> 00:01:19,360
forces you to expose routes to your

00:01:17,860 --> 00:01:21,670
application on the back end that you may

00:01:19,360 --> 00:01:22,900
not otherwise want to expose so what we

00:01:21,670 --> 00:01:24,970
really want so you want to have a model

00:01:22,900 --> 00:01:26,590
where you come in through the router you

00:01:24,970 --> 00:01:29,170
can access your front-end apps but those

00:01:26,590 --> 00:01:30,250
applications can then come directly to

00:01:29,170 --> 00:01:32,079
the back-end that you're trying to keep

00:01:30,250 --> 00:01:34,299
secret or private or secure or whatever

00:01:32,079 --> 00:01:35,619
you want something that you want to just

00:01:34,299 --> 00:01:37,600
manage so that you don't expose it to

00:01:35,619 --> 00:01:38,890
the whole wide world and that's kind of

00:01:37,600 --> 00:01:43,659
what we're trying to do with container

00:01:38,890 --> 00:01:45,430
networking more explicitly we have a set

00:01:43,659 --> 00:01:47,590
of goals that we're looking to the liver

00:01:45,430 --> 00:01:50,380
in this project for users and for

00:01:47,590 --> 00:01:51,820
operators all right we're gonna try to

00:01:50,380 --> 00:01:54,340
talk through some of these things and

00:01:51,820 --> 00:01:55,899
give examples of how we're doing it and

00:01:54,340 --> 00:01:58,240
we're kind of hoping that throughout

00:01:55,899 --> 00:02:00,189
this discussion if there's questions

00:01:58,240 --> 00:02:01,390
comments concerns you kind of let us

00:02:00,189 --> 00:02:03,820
know so we can have that conversation

00:02:01,390 --> 00:02:06,430
either after the pitch or during Q&A or

00:02:03,820 --> 00:02:07,329
out in the halls whatever might be so in

00:02:06,430 --> 00:02:09,280
terms of the container networking

00:02:07,329 --> 00:02:11,350
project in general we have a set of

00:02:09,280 --> 00:02:14,410
small we have a very small set of goals

00:02:11,350 --> 00:02:17,020
we're looking to get to so for users we

00:02:14,410 --> 00:02:18,010
want to deliver a solution that allows

00:02:17,020 --> 00:02:19,599
direct layer

00:02:18,010 --> 00:02:21,549
three addressability without a nap

00:02:19,599 --> 00:02:25,120
between all connected peers so what that

00:02:21,549 --> 00:02:27,459
means explicitly is that if you have two

00:02:25,120 --> 00:02:29,049
instances two containers right of the

00:02:27,459 --> 00:02:31,599
same application or other applications

00:02:29,049 --> 00:02:33,760
you can uniquely address them and send

00:02:31,599 --> 00:02:36,430
requests to them without having to go

00:02:33,760 --> 00:02:38,409
through the entire routing tier right so

00:02:36,430 --> 00:02:40,030
when you receive a request now you know

00:02:38,409 --> 00:02:42,940
explicitly who is from in terms of the

00:02:40,030 --> 00:02:45,370
address and you have some notion of the

00:02:42,940 --> 00:02:48,010
source you have some notion of you know

00:02:45,370 --> 00:02:49,629
who you're talking to within the

00:02:48,010 --> 00:02:52,599
container we're looking to have a single

00:02:49,629 --> 00:02:54,640
network interface so today what you have

00:02:52,599 --> 00:02:55,930
in the garden containers that exists is

00:02:54,640 --> 00:02:56,519
you have a single network interface that

00:02:55,930 --> 00:02:59,500
you can receive your application

00:02:56,519 --> 00:03:01,629
requests on that's great what most

00:02:59,500 --> 00:03:03,430
container networking models end up doing

00:03:01,629 --> 00:03:06,129
today is you look at docker for instance

00:03:03,430 --> 00:03:09,909
if you have a plugin or you add another

00:03:06,129 --> 00:03:11,170
network or even on some VM machines if

00:03:09,909 --> 00:03:12,940
you add another network what you end up

00:03:11,170 --> 00:03:14,409
finding is you have another network

00:03:12,940 --> 00:03:18,010
interface sitting inside your container

00:03:14,409 --> 00:03:19,359
inside of your container your host that

00:03:18,010 --> 00:03:21,040
adds a fair bit of complexity and

00:03:19,359 --> 00:03:23,949
complications around determining you

00:03:21,040 --> 00:03:25,299
know what addresses you should listen on

00:03:23,949 --> 00:03:26,739
for instance does everybody do an ad or

00:03:25,299 --> 00:03:28,480
any or do you listen to one side which

00:03:26,739 --> 00:03:30,310
one's private which one's public most

00:03:28,480 --> 00:03:31,900
people don't want to care so by

00:03:30,310 --> 00:03:34,150
surfacing a single interface with a

00:03:31,900 --> 00:03:36,519
single address it's very easy for people

00:03:34,150 --> 00:03:39,519
to basically come up listen listen on

00:03:36,519 --> 00:03:41,199
one address and just get going in terms

00:03:39,519 --> 00:03:42,910
of connectivity tween applications we

00:03:41,199 --> 00:03:46,299
want to be able to allow you to specify

00:03:42,910 --> 00:03:49,419
a policy a way of describing who can

00:03:46,299 --> 00:03:50,739
talk to whom right and how so those are

00:03:49,419 --> 00:03:52,870
the goals that we have for users so you

00:03:50,739 --> 00:03:55,060
have basic connectivity with direct

00:03:52,870 --> 00:03:58,359
access single network interface and

00:03:55,060 --> 00:04:00,879
policy based cognitive aterial now for

00:03:58,359 --> 00:04:02,319
operators we want to make sure that when

00:04:00,879 --> 00:04:04,900
you're running Cloud Foundry since we

00:04:02,319 --> 00:04:06,519
are multi cloud and we support many

00:04:04,900 --> 00:04:07,389
different cloud providers right you

00:04:06,519 --> 00:04:09,370
could bring your own you can go

00:04:07,389 --> 00:04:10,900
someplace else we want to give you the

00:04:09,370 --> 00:04:12,669
opportunity to actually choose the

00:04:10,900 --> 00:04:15,879
networking technology that's going to be

00:04:12,669 --> 00:04:16,900
in place for your network all right so

00:04:15,879 --> 00:04:19,239
we need some level of extensibility

00:04:16,900 --> 00:04:20,889
there we want to ensure that when you

00:04:19,239 --> 00:04:22,810
deploy these network technology that

00:04:20,889 --> 00:04:24,820
within your infrastructure within your

00:04:22,810 --> 00:04:28,240
deployment you have the ability to lock

00:04:24,820 --> 00:04:29,919
things down to explicitly control where

00:04:28,240 --> 00:04:31,230
packets are allowed to go all right so

00:04:29,919 --> 00:04:34,290
we want to make sure that that's there

00:04:31,230 --> 00:04:35,610
and a stretch goal or something that we

00:04:34,290 --> 00:04:36,870
hear a lot all right something we really

00:04:35,610 --> 00:04:39,180
want to have happen is we want to be

00:04:36,870 --> 00:04:41,370
able to say that as packets traverse the

00:04:39,180 --> 00:04:42,900
network right the packets that are

00:04:41,370 --> 00:04:46,140
coming from containers we want to be

00:04:42,900 --> 00:04:48,000
able to say you know with certainty the

00:04:46,140 --> 00:04:50,130
source of that packet so we can tie it

00:04:48,000 --> 00:04:51,270
back in a multi-tenant world exactly to

00:04:50,130 --> 00:04:53,760
the application that generated that

00:04:51,270 --> 00:04:55,680
packet so if you end up getting you know

00:04:53,760 --> 00:04:57,330
a huge flood of traffic from an

00:04:55,680 --> 00:04:58,890
application you can track it back or if

00:04:57,330 --> 00:05:00,870
you find out that there's an attack on a

00:04:58,890 --> 00:05:02,040
foreign web service right and you want

00:05:00,870 --> 00:05:04,050
to find out who's actually causing that

00:05:02,040 --> 00:05:05,550
in a multi-tenant public cloud you have

00:05:04,050 --> 00:05:10,640
the ability to do that so those are some

00:05:05,550 --> 00:05:13,200
of the goals so how do we get there

00:05:10,640 --> 00:05:14,730
so we have five basic topics that we're

00:05:13,200 --> 00:05:15,930
going to try to cover today we're going

00:05:14,730 --> 00:05:18,030
to talk about the technology

00:05:15,930 --> 00:05:21,540
extensibility or and talk a little bit

00:05:18,030 --> 00:05:23,610
about address management right policy

00:05:21,540 --> 00:05:25,140
expression for Cloud Foundry and some

00:05:23,610 --> 00:05:26,550
ideas that we have there and we're

00:05:25,140 --> 00:05:29,190
looking for lots of feedback on this

00:05:26,550 --> 00:05:33,210
because this is a probably the most

00:05:29,190 --> 00:05:35,040
intensive portion of this presentation

00:05:33,210 --> 00:05:36,960
is to get some feedback on the policy

00:05:35,040 --> 00:05:39,750
pieces well you want to control who to

00:05:36,960 --> 00:05:42,720
talk to whom it can become very detailed

00:05:39,750 --> 00:05:44,550
and very X you know basically it's kind

00:05:42,720 --> 00:05:47,370
of obtuse right so we're looking to have

00:05:44,550 --> 00:05:49,170
a simple solution for that that still

00:05:47,370 --> 00:05:51,300
meets requirements people have so we're

00:05:49,170 --> 00:05:52,530
looking to cover that today we're gonna

00:05:51,300 --> 00:05:54,870
talk a little bit about what we have for

00:05:52,530 --> 00:05:56,880
batteries included solution in the

00:05:54,870 --> 00:05:58,110
Batman release so what's going to happen

00:05:56,880 --> 00:06:00,120
with open source Cloud Foundry just for

00:05:58,110 --> 00:06:01,470
connectivity and how policy enforcement

00:06:00,120 --> 00:06:03,480
will work with that built-in provider

00:06:01,470 --> 00:06:09,270
and the last little bit we're going to

00:06:03,480 --> 00:06:12,180
talk about is some some ideas around how

00:06:09,270 --> 00:06:13,500
we could discover endpoints things like

00:06:12,180 --> 00:06:16,020
naming so that if you have connectivity

00:06:13,500 --> 00:06:18,000
from A to B how do you actually find out

00:06:16,020 --> 00:06:21,000
where B is in terms of addresses and how

00:06:18,000 --> 00:06:23,990
you access those things right so that's

00:06:21,000 --> 00:06:23,990
kind of what were going to cover today

00:06:28,929 --> 00:06:33,229
so you just if you're in this room a few

00:06:32,179 --> 00:06:36,199
minutes ago you heard a talk about

00:06:33,229 --> 00:06:38,689
garden and you heard about garden Runcie

00:06:36,199 --> 00:06:42,829
which is the next version of the back

00:06:38,689 --> 00:06:45,559
end for the garden API what our team has

00:06:42,829 --> 00:06:49,549
been working on the last few months has

00:06:45,559 --> 00:06:51,649
been a adapter between garden Runcie and

00:06:49,549 --> 00:06:55,339
the container and networking initiative

00:06:51,649 --> 00:06:58,699
specification for wiring up containers

00:06:55,339 --> 00:07:00,289
to networks and what that does what

00:06:58,699 --> 00:07:02,929
we've got is this this adapter layer

00:07:00,289 --> 00:07:05,539
that lets us drive via the cni plug-in

00:07:02,929 --> 00:07:08,479
interface any number of different CNI

00:07:05,539 --> 00:07:10,219
plugins which are available if you if

00:07:08,479 --> 00:07:12,589
you look this up on github you can see

00:07:10,219 --> 00:07:14,719
that there are a number of existing

00:07:12,589 --> 00:07:17,479
reference specification implement like

00:07:14,719 --> 00:07:21,799
reference implementations of CNI plugins

00:07:17,479 --> 00:07:23,989
and we have this thing called net man

00:07:21,799 --> 00:07:26,359
release it's a boss release that you can

00:07:23,989 --> 00:07:28,549
go look up today and it uses the final

00:07:26,359 --> 00:07:30,619
C&I plug-in and provides layer 3

00:07:28,549 --> 00:07:32,360
connectivity between containers it

00:07:30,619 --> 00:07:34,399
doesn't meet all of the goals that we've

00:07:32,360 --> 00:07:35,449
that Matthew went over but that's what

00:07:34,399 --> 00:07:43,219
our team is going to be working off of

00:07:35,449 --> 00:07:44,209
going forward all right so they get a

00:07:43,219 --> 00:07:46,969
little bit to the address management

00:07:44,209 --> 00:07:48,739
piece what we have here is we want to

00:07:46,969 --> 00:07:51,469
demonstrate you know really in picture

00:07:48,739 --> 00:07:53,449
form the ultimate goal which is given a

00:07:51,469 --> 00:07:55,639
graph of containers we want to be able

00:07:53,449 --> 00:07:57,679
to allow full connectivity between those

00:07:55,639 --> 00:07:58,639
graphs and unique address ability so

00:07:57,679 --> 00:08:00,979
what you notice here is that we actually

00:07:58,639 --> 00:08:02,629
have four boxes they look like servers

00:08:00,979 --> 00:08:05,149
but they're they could be anything you

00:08:02,629 --> 00:08:07,249
want it could be containers and we have

00:08:05,149 --> 00:08:09,169
four unique IP addresses between those

00:08:07,249 --> 00:08:10,399
things now going back to what I said

00:08:09,169 --> 00:08:13,039
earlier part of the reason why we're

00:08:10,399 --> 00:08:16,909
looking for this unique IP is it makes a

00:08:13,039 --> 00:08:19,009
lot of things simpler in terms of what

00:08:16,909 --> 00:08:21,889
your application has to understand right

00:08:19,009 --> 00:08:23,599
again with one one address one eye you

00:08:21,889 --> 00:08:25,549
know one interface we have one place to

00:08:23,599 --> 00:08:27,289
listen what's also interesting about

00:08:25,549 --> 00:08:28,669
that is if you end up having to roll

00:08:27,289 --> 00:08:31,039
your own for things like service

00:08:28,669 --> 00:08:34,639
discovery you know very easily which IP

00:08:31,039 --> 00:08:36,469
address to expose right so long the

00:08:34,639 --> 00:08:38,539
short of it is across the container

00:08:36,469 --> 00:08:38,960
network we're looking for a flat address

00:08:38,539 --> 00:08:41,390
space

00:08:38,960 --> 00:08:43,940
fully interconnected with unique

00:08:41,390 --> 00:08:47,930
addresses and that's the ultimate goal

00:08:43,940 --> 00:08:50,840
there and this is related to C an I in

00:08:47,930 --> 00:08:53,810
that the CNI plugins the way they

00:08:50,840 --> 00:08:56,450
actually work today is when garden comes

00:08:53,810 --> 00:08:59,450
down through the CNI adapter to actually

00:08:56,450 --> 00:09:01,190
bring up a network interface on the

00:08:59,450 --> 00:09:03,560
container where point it's the network

00:09:01,190 --> 00:09:05,660
namespace of that container and we're

00:09:03,560 --> 00:09:07,790
allowed to essentially create all the

00:09:05,660 --> 00:09:09,320
artifacts that are required to bring

00:09:07,790 --> 00:09:12,260
that network or bring that container

00:09:09,320 --> 00:09:14,150
onto a network so the address management

00:09:12,260 --> 00:09:16,190
pieces of it and the technology that are

00:09:14,150 --> 00:09:17,600
used are both baked into scene eyes this

00:09:16,190 --> 00:09:18,920
is the first primary extension point

00:09:17,600 --> 00:09:25,490
that we have for a cloud foundry

00:09:18,920 --> 00:09:27,230
networking okay let's talk about policy

00:09:25,490 --> 00:09:29,270
it's gonna be a few slides so there's

00:09:27,230 --> 00:09:31,460
two basic roles that we think about

00:09:29,270 --> 00:09:33,530
types of people that are sort of users

00:09:31,460 --> 00:09:35,180
of the policy work there's the developer

00:09:33,530 --> 00:09:37,070
who just wants to push their app and

00:09:35,180 --> 00:09:39,080
have it be run for them on the cloud I

00:09:37,070 --> 00:09:40,900
want this to be connected to the other

00:09:39,080 --> 00:09:42,020
apps that it needs to talk to maybe

00:09:40,900 --> 00:09:45,290
microservices

00:09:42,020 --> 00:09:47,450
applications directly without going

00:09:45,290 --> 00:09:49,790
through the router they want that to be

00:09:47,450 --> 00:09:51,650
easy to use and then there are operators

00:09:49,790 --> 00:09:54,080
they're administering the Cloud Foundry

00:09:51,650 --> 00:09:55,340
and the network and they probably have

00:09:54,080 --> 00:09:58,550
concerns about security and compliance

00:09:55,340 --> 00:10:00,350
and so what the goal of this effort is

00:09:58,550 --> 00:10:02,660
to figure out how to make this easy for

00:10:00,350 --> 00:10:04,340
developers to just get a simple CF push

00:10:02,660 --> 00:10:06,920
experience the self-service thing that's

00:10:04,340 --> 00:10:10,130
making CF really easy to use for a

00:10:06,920 --> 00:10:12,190
developer but also not scare away the

00:10:10,130 --> 00:10:15,260
people who are concerned about security

00:10:12,190 --> 00:10:17,540
so you can think about you can think

00:10:15,260 --> 00:10:19,760
about policy this user experience issue

00:10:17,540 --> 00:10:21,650
on a couple different axes one of them

00:10:19,760 --> 00:10:25,090
is the sort of implicit versus explicit

00:10:21,650 --> 00:10:27,140
axis do you want to default allow

00:10:25,090 --> 00:10:28,870
connectivity between applications or do

00:10:27,140 --> 00:10:32,390
you want there to be a default deny and

00:10:28,870 --> 00:10:35,390
the user or operator has to explicitly

00:10:32,390 --> 00:10:37,880
say which application can talk to which

00:10:35,390 --> 00:10:39,380
other application or which Cloud Foundry

00:10:37,880 --> 00:10:41,900
space could talk to some other Cloud

00:10:39,380 --> 00:10:44,600
Foundry space there's also the axis of

00:10:41,900 --> 00:10:47,090
granularity are you talking about apps

00:10:44,600 --> 00:10:49,040
are you talking about spaces are you

00:10:47,090 --> 00:10:52,279
talking about orgs in terms of the the

00:10:49,040 --> 00:10:56,360
units that when you discuss policy so we

00:10:52,279 --> 00:10:57,709
can imagine some simple implicit default

00:10:56,360 --> 00:10:59,990
policy which is that every single

00:10:57,709 --> 00:11:01,430
application within an organization Cloud

00:10:59,990 --> 00:11:03,199
Foundry org can talk to its to

00:11:01,430 --> 00:11:05,870
everything else in that org there's no

00:11:03,199 --> 00:11:07,160
restrictions at all except that you can

00:11:05,870 --> 00:11:09,259
only talk to things within the same org

00:11:07,160 --> 00:11:11,269
and then sort of going down the

00:11:09,259 --> 00:11:12,589
granularity scale you could imagine the

00:11:11,269 --> 00:11:14,779
same kind of thing but only within a

00:11:12,589 --> 00:11:16,129
space and that spaces themselves you

00:11:14,779 --> 00:11:18,860
couldn't talk to things outside of this

00:11:16,129 --> 00:11:20,809
space except via of course going out

00:11:18,860 --> 00:11:22,670
through the the router and coming back

00:11:20,809 --> 00:11:24,379
in the the way it currently works and

00:11:22,670 --> 00:11:26,240
then going down again in terms of

00:11:24,379 --> 00:11:27,949
granularity you can imagine that

00:11:26,240 --> 00:11:29,680
instances of a single application could

00:11:27,949 --> 00:11:32,540
talk to each other but there's no

00:11:29,680 --> 00:11:35,240
Interop communication and that's all

00:11:32,540 --> 00:11:38,089
sort of implicit there's no additional

00:11:35,240 --> 00:11:41,569
user experience because these rules are

00:11:38,089 --> 00:11:42,980
just applied automatically and then in

00:11:41,569 --> 00:11:45,649
terms of going on the more explicit side

00:11:42,980 --> 00:11:47,180
of things you can imagine that a user

00:11:45,649 --> 00:11:50,389
might be able to write a rule that says

00:11:47,180 --> 00:11:52,040
org a can talk to org B or all the

00:11:50,389 --> 00:11:54,410
applications in org a can talk to all

00:11:52,040 --> 00:11:56,809
the applications in order B and again

00:11:54,410 --> 00:11:59,149
going down the granularity scale may be

00:11:56,809 --> 00:12:00,290
a space can talk to an org or all the

00:11:59,149 --> 00:12:02,750
apps within the space can talk to all

00:12:00,290 --> 00:12:04,610
the other apps in another space and then

00:12:02,750 --> 00:12:09,529
you can just imagine an app to app

00:12:04,610 --> 00:12:10,939
granularity where the default is don't

00:12:09,529 --> 00:12:13,220
allow any communication unless I

00:12:10,939 --> 00:12:15,379
explicitly say app a can talk to a B and

00:12:13,220 --> 00:12:16,970
then finally in terms of the version 3

00:12:15,379 --> 00:12:18,889
cloud controller API there's this

00:12:16,970 --> 00:12:20,930
smaller unit than an application which

00:12:18,889 --> 00:12:22,670
is a process or process type and so you

00:12:20,930 --> 00:12:24,170
can imagine maybe writing rules like a

00:12:22,670 --> 00:12:26,480
process type can talk to another process

00:12:24,170 --> 00:12:28,370
type and finally we can add on top of

00:12:26,480 --> 00:12:32,360
this the ID concept of ports and

00:12:28,370 --> 00:12:34,850
protocols so there's this question of

00:12:32,360 --> 00:12:36,860
what should Cloud Foundry support like

00:12:34,850 --> 00:12:38,240
what should the user experience be what

00:12:36,860 --> 00:12:42,009
should you be able to do as a user

00:12:38,240 --> 00:12:44,870
operator and so it's going to be some

00:12:42,009 --> 00:12:46,639
area of this graph we don't really know

00:12:44,870 --> 00:12:49,100
some collection of these things covering

00:12:46,639 --> 00:12:51,259
some region will be the thing the Cloud

00:12:49,100 --> 00:12:53,149
Foundry supports at least out-of-the-box

00:12:51,259 --> 00:12:54,829
and we don't know what that is yet and

00:12:53,149 --> 00:12:56,839
we really want to hear from people if

00:12:54,829 --> 00:12:59,089
they have opinions about this sort of

00:12:56,839 --> 00:13:00,470
thing well you'll see a slide at the

00:12:59,089 --> 00:13:01,370
very end about office hours but we're

00:13:00,470 --> 00:13:03,709
gonna have office hours tomorrow

00:13:01,370 --> 00:13:04,879
afternoon be great if you came and told

00:13:03,709 --> 00:13:07,000
us what you thought about this kind of

00:13:04,879 --> 00:13:07,000
stuff

00:13:07,300 --> 00:13:10,850
the one thing I did wanna bring about

00:13:09,140 --> 00:13:12,860
this is one of the initial proposals

00:13:10,850 --> 00:13:16,490
that we had which was kind of a middle

00:13:12,860 --> 00:13:17,600
ground was that by default applications

00:13:16,490 --> 00:13:19,550
within the same space would have

00:13:17,600 --> 00:13:22,190
connectivity and then policy controls

00:13:19,550 --> 00:13:23,779
would be on top of that it's it's kind

00:13:22,190 --> 00:13:27,110
of a middle of a ground like approach

00:13:23,779 --> 00:13:29,089
it's not agreed to it's not kind of

00:13:27,110 --> 00:13:30,920
where everybody wants to be but that's

00:13:29,089 --> 00:13:32,570
just kind of an idea of before you could

00:13:30,920 --> 00:13:34,010
start with something which is I push two

00:13:32,570 --> 00:13:35,060
applications they can talk as long as

00:13:34,010 --> 00:13:37,550
they're in the same space as soon as you

00:13:35,060 --> 00:13:39,170
cross spaces they're gone so just that's

00:13:37,550 --> 00:13:44,720
an idea of like an illicit control point

00:13:39,170 --> 00:13:46,339
just a concrete way so in addition to

00:13:44,720 --> 00:13:47,870
those sort of high-level concepts

00:13:46,339 --> 00:13:49,790
there's this question of like where does

00:13:47,870 --> 00:13:51,709
this stuff actually stored does a user

00:13:49,790 --> 00:13:53,570
put this into the cloud controller API

00:13:51,709 --> 00:13:55,399
is there gonna be some separate

00:13:53,570 --> 00:13:57,589
networking API that controls this stuff

00:13:55,399 --> 00:13:59,209
maybe they express it via the service

00:13:57,589 --> 00:14:01,160
model for Cloud Foundry with service

00:13:59,209 --> 00:14:02,930
bindings we've talked about and thought

00:14:01,160 --> 00:14:04,790
about these approaches we haven't made

00:14:02,930 --> 00:14:07,220
any firm decisions yet but again we're

00:14:04,790 --> 00:14:09,020
looking for feedback on this so here's

00:14:07,220 --> 00:14:13,190
an option or an example of how you might

00:14:09,020 --> 00:14:14,990
do explicit rules that the top line kind

00:14:13,190 --> 00:14:17,290
of is the most generic case where I

00:14:14,990 --> 00:14:20,300
could write some CF command line thing

00:14:17,290 --> 00:14:22,399
that's allows traffic from some source

00:14:20,300 --> 00:14:24,829
application in this space in order to

00:14:22,399 --> 00:14:26,360
another destination application over a

00:14:24,829 --> 00:14:27,980
space in org using a particular protocol

00:14:26,360 --> 00:14:30,050
in particular boards so just to make

00:14:27,980 --> 00:14:31,760
this a little more concrete I push a web

00:14:30,050 --> 00:14:33,709
UI app and an inventory app and a

00:14:31,760 --> 00:14:35,959
checkout app that makes some kind of

00:14:33,709 --> 00:14:38,720
shopping cart experience and I allow

00:14:35,959 --> 00:14:41,149
explicitly traffic from the web UI to

00:14:38,720 --> 00:14:42,709
the inventory app and I allow traffic

00:14:41,149 --> 00:14:45,290
from the web UI to the checkout and then

00:14:42,709 --> 00:14:47,300
I allow traffic from the checkout - some

00:14:45,290 --> 00:14:50,029
credit-card sensitive PCI thing that's

00:14:47,300 --> 00:14:52,310
maybe in a different space and those

00:14:50,029 --> 00:14:55,490
three allow rules together allow me to

00:14:52,310 --> 00:14:57,800
run my complete web ecommerce

00:14:55,490 --> 00:15:00,320
application there's a question as far as

00:14:57,800 --> 00:15:03,410
who should be allowed to write these

00:15:00,320 --> 00:15:05,630
allow rules if you're maybe if you're a

00:15:03,410 --> 00:15:07,160
space developer in both the space that

00:15:05,630 --> 00:15:08,480
contains this the source and the

00:15:07,160 --> 00:15:10,399
destination that that's enough of a

00:15:08,480 --> 00:15:13,610
permission maybe you need some kind of a

00:15:10,399 --> 00:15:15,589
particular network admin scope those are

00:15:13,610 --> 00:15:17,820
open questions as far as the the

00:15:15,589 --> 00:15:21,250
permissions to do this

00:15:17,820 --> 00:15:22,210
another iteration on this might be

00:15:21,250 --> 00:15:24,730
something that's a little more

00:15:22,210 --> 00:15:27,820
self-service when I push an app perhaps

00:15:24,730 --> 00:15:30,190
I can expose a named endpoint and I can

00:15:27,820 --> 00:15:34,720
say this inventory app is available on

00:15:30,190 --> 00:15:37,270
port 443 over TCP and I'm giving it this

00:15:34,720 --> 00:15:39,070
name and then when I push the web UI app

00:15:37,270 --> 00:15:39,910
the thing that consumes that inventory

00:15:39,070 --> 00:15:42,040
back-end

00:15:39,910 --> 00:15:46,420
I say bind it to that bind it to the

00:15:42,040 --> 00:15:47,800
inventory and that would be a perhaps an

00:15:46,420 --> 00:15:49,630
eyesore user experience would make it a

00:15:47,800 --> 00:15:52,450
little simpler to do micro services with

00:15:49,630 --> 00:15:54,459
CF push so again we're kind of like

00:15:52,450 --> 00:15:56,350
kicking these ideas around and we're

00:15:54,459 --> 00:15:59,260
interested in people's feedback about

00:15:56,350 --> 00:16:01,029
what they might want to use and we're

00:15:59,260 --> 00:16:03,330
certainly not seeing these as the only

00:16:01,029 --> 00:16:03,330
two options

00:16:03,490 --> 00:16:06,910
finally this gets a little more

00:16:05,230 --> 00:16:09,490
complicated with cloud controller

00:16:06,910 --> 00:16:10,930
version 3 as I mentioned earlier maybe

00:16:09,490 --> 00:16:13,149
you specify process types as opposed

00:16:10,930 --> 00:16:15,220
applications and there's a question

00:16:13,149 --> 00:16:16,930
again in terms of like implicit versus

00:16:15,220 --> 00:16:18,790
explicit whether there should be some

00:16:16,930 --> 00:16:20,320
kind of default allow roll all the

00:16:18,790 --> 00:16:25,630
processes within an application should

00:16:20,320 --> 00:16:27,220
be a little able to talk or not so to

00:16:25,630 --> 00:16:29,110
sort of summarize all this stuff in

00:16:27,220 --> 00:16:32,110
terms of just kind of like commentary on

00:16:29,110 --> 00:16:34,060
this with a default deny role you're

00:16:32,110 --> 00:16:35,890
gonna have to write a lot of explicit

00:16:34,060 --> 00:16:37,540
allow rules in order to set up your

00:16:35,890 --> 00:16:39,070
application and doing stuff

00:16:37,540 --> 00:16:41,470
bidirectionally if you have a callback

00:16:39,070 --> 00:16:43,480
between some front-end and you've got a

00:16:41,470 --> 00:16:46,660
if this and that application that calls

00:16:43,480 --> 00:16:49,060
you back it's a little messy both at

00:16:46,660 --> 00:16:50,560
fault allow rule if everything's allowed

00:16:49,060 --> 00:16:51,670
to talk to each other then maybe the

00:16:50,560 --> 00:16:53,410
security guys are gonna get a little

00:16:51,670 --> 00:16:55,300
concerned and they're gonna say what why

00:16:53,410 --> 00:16:58,000
do these things why can't I talk by

00:16:55,300 --> 00:16:59,950
default I want to know explicitly where

00:16:58,000 --> 00:17:01,300
traffic is going so this question of

00:16:59,950 --> 00:17:03,790
usability versus security would like

00:17:01,300 --> 00:17:09,160
we'd like some some input from people to

00:17:03,790 --> 00:17:11,699
hear what you think ok I'm gonna keep

00:17:09,160 --> 00:17:14,530
talking about policy enforcement so

00:17:11,699 --> 00:17:15,819
there's this overall goal with Cloud

00:17:14,530 --> 00:17:18,040
Foundry is we want to be able to provide

00:17:15,819 --> 00:17:19,449
some included batteries that enforces

00:17:18,040 --> 00:17:21,490
policy for you but you should build

00:17:19,449 --> 00:17:22,959
replace them so the open source things

00:17:21,490 --> 00:17:25,750
should just work but if you have some

00:17:22,959 --> 00:17:29,620
proprietary network fabric that you want

00:17:25,750 --> 00:17:30,970
to use that's ok too so the open source

00:17:29,620 --> 00:17:31,780
solution that we're going to we think

00:17:30,970 --> 00:17:34,179
we're going to begin working

00:17:31,780 --> 00:17:36,159
we've done some work on already and the

00:17:34,179 --> 00:17:38,640
flannel release is the foundation of

00:17:36,159 --> 00:17:40,720
this is it the excellent overlay Network

00:17:38,640 --> 00:17:42,309
so what this does is it takes the

00:17:40,720 --> 00:17:46,270
traffic from an application and

00:17:42,309 --> 00:17:47,470
encapsulate sit and adds a tag to the

00:17:46,270 --> 00:17:50,260
front of that packet before it goes out

00:17:47,470 --> 00:17:51,490
on the wire and that tag has something

00:17:50,260 --> 00:17:54,610
that represents the identity of the

00:17:51,490 --> 00:17:56,860
application and what this lets us do is

00:17:54,610 --> 00:17:58,150
it separates the identity of an

00:17:56,860 --> 00:18:00,940
application from its address on the

00:17:58,150 --> 00:18:02,770
network this pays dividends with policy

00:18:00,940 --> 00:18:03,970
enforcement so to make this a little

00:18:02,770 --> 00:18:06,970
more concrete for those of you who are

00:18:03,970 --> 00:18:09,250
not already networking experts it kind

00:18:06,970 --> 00:18:11,679
of looks like this you've got your

00:18:09,250 --> 00:18:13,090
application data is got its own IP

00:18:11,679 --> 00:18:15,840
header its own UDP header but it's

00:18:13,090 --> 00:18:18,250
encapsulated within the body of an outer

00:18:15,840 --> 00:18:20,260
packet that has a tag on it

00:18:18,250 --> 00:18:24,250
and so each CF application would be

00:18:20,260 --> 00:18:26,409
assigned some unique tag and then before

00:18:24,250 --> 00:18:28,270
the traffic leaves the container house

00:18:26,409 --> 00:18:31,059
before it leaves the Diego cell it would

00:18:28,270 --> 00:18:33,700
be tagged with its identity and then

00:18:31,059 --> 00:18:35,049
when traffic arrives at a container it

00:18:33,700 --> 00:18:40,030
can be filtered based on the identity of

00:18:35,049 --> 00:18:42,400
the source of the packet getting a bit

00:18:40,030 --> 00:18:43,570
more into the details the excellent has

00:18:42,400 --> 00:18:46,809
a few different places where we might

00:18:43,570 --> 00:18:49,270
put this tag and it has a 24-bit thing

00:18:46,809 --> 00:18:50,950
called a vni it has a 16-bit group

00:18:49,270 --> 00:18:53,890
policy identifier which is a very new

00:18:50,950 --> 00:18:55,840
extension to the specification depending

00:18:53,890 --> 00:18:58,150
on how many bits you allow for the tag

00:18:55,840 --> 00:18:59,440
that puts an upper limit on how many

00:18:58,150 --> 00:19:01,200
different applications you can deploy to

00:18:59,440 --> 00:19:04,030
your Cloud Foundry using this approach

00:19:01,200 --> 00:19:06,669
and you we can imagine a few different

00:19:04,030 --> 00:19:08,799
ways of encoding the identity of the

00:19:06,669 --> 00:19:12,280
application into that the tag on the

00:19:08,799 --> 00:19:14,080
packet and perhaps splitting it based on

00:19:12,280 --> 00:19:15,460
some concept of a tenant versus an

00:19:14,080 --> 00:19:20,559
application that's owned by that time to

00:19:15,460 --> 00:19:22,360
support multi tenant cases we're not set

00:19:20,559 --> 00:19:23,230
in stone on this stuff again we kind of

00:19:22,360 --> 00:19:26,380
want to hear from people if they have

00:19:23,230 --> 00:19:27,850
opinions just a couple of side effects

00:19:26,380 --> 00:19:29,409
that like people may need to be aware of

00:19:27,850 --> 00:19:30,909
for this kind of thing is that if you

00:19:29,409 --> 00:19:32,890
start to actually and cap everything

00:19:30,909 --> 00:19:33,820
it's a non-standard end cap all right

00:19:32,890 --> 00:19:35,500
then you have some interoperability

00:19:33,820 --> 00:19:36,789
issues if you want to cap everything

00:19:35,500 --> 00:19:38,260
leaving the container then you have to

00:19:36,789 --> 00:19:39,820
basically D cap on the way out which we

00:19:38,260 --> 00:19:40,720
do have another filter before you

00:19:39,820 --> 00:19:41,680
actually leave your Cloud Foundry

00:19:40,720 --> 00:19:44,260
environment

00:19:41,680 --> 00:19:45,340
if you have existing VXLAN overlays and

00:19:44,260 --> 00:19:47,440
vien eyes are actually reserved

00:19:45,340 --> 00:19:48,940
depending on how you do routing etc you

00:19:47,440 --> 00:19:50,320
may have to you know segregate some of

00:19:48,940 --> 00:19:52,060
those things and actually isolate those

00:19:50,320 --> 00:19:54,040
there's a lot of little things about

00:19:52,060 --> 00:19:56,950
this proposal that people need to be

00:19:54,040 --> 00:19:59,440
aware of and but it's something that

00:19:56,950 --> 00:20:05,710
would be there on the box so it's it's a

00:19:59,440 --> 00:20:08,410
starting point so to give a little bit

00:20:05,710 --> 00:20:10,270
of a overview of how this might work

00:20:08,410 --> 00:20:12,580
with cloud foundry you can imagine the

00:20:10,270 --> 00:20:15,520
user or perhaps cloud controller itself

00:20:12,580 --> 00:20:17,050
driving some policy brain some central

00:20:15,520 --> 00:20:18,520
controller that that stores the rules

00:20:17,050 --> 00:20:20,830
the intended rules that the user has

00:20:18,520 --> 00:20:22,480
about which apps can talk to other apps

00:20:20,830 --> 00:20:26,110
or spaces conductive apps or whatever

00:20:22,480 --> 00:20:27,310
you want and that there's there's a

00:20:26,110 --> 00:20:29,980
component which we're starting to call a

00:20:27,310 --> 00:20:33,130
net man that stays in sync with that

00:20:29,980 --> 00:20:34,360
with that brain and has the the local

00:20:33,130 --> 00:20:36,610
copy of those rules that are relevant to

00:20:34,360 --> 00:20:38,830
the cell that it's running on and and

00:20:36,610 --> 00:20:39,970
that net man program is going to be

00:20:38,830 --> 00:20:41,970
actually responsible for doing two

00:20:39,970 --> 00:20:44,350
different things one of them is driving

00:20:41,970 --> 00:20:45,880
cni plug-ins to set up network

00:20:44,350 --> 00:20:48,610
connectivity in the first place and it's

00:20:45,880 --> 00:20:51,970
also going to be responsible for driving

00:20:48,610 --> 00:20:54,220
policy controls on the local cell but

00:20:51,970 --> 00:20:56,190
because we're we've got these three

00:20:54,220 --> 00:20:58,720
different API boundaries this allows for

00:20:56,190 --> 00:21:02,800
extensibility if you want to replace

00:20:58,720 --> 00:21:06,100
these batteries with something else you

00:21:02,800 --> 00:21:08,590
can do that by making use of the cni api

00:21:06,100 --> 00:21:11,650
of the policy api that we specify that

00:21:08,590 --> 00:21:14,530
net man drives and by the the brain

00:21:11,650 --> 00:21:18,280
itself and this type of solution should

00:21:14,530 --> 00:21:20,050
we hope allow for extensible different

00:21:18,280 --> 00:21:22,930
types of custom Network setups for

00:21:20,050 --> 00:21:25,620
people who are not content with the

00:21:22,930 --> 00:21:25,620
batteries that we're building

00:21:30,480 --> 00:21:37,740
okay last major thing was a discussion

00:21:34,080 --> 00:21:39,050
about discovery so one of the things

00:21:37,740 --> 00:21:40,980
that's interesting about when you build

00:21:39,050 --> 00:21:43,200
container networks and you have the

00:21:40,980 --> 00:21:45,150
ability to identify sources and targets

00:21:43,200 --> 00:21:47,580
when you declaratively when you actually

00:21:45,150 --> 00:21:49,110
push your applications is you still have

00:21:47,580 --> 00:21:52,320
the problem actually finding them at

00:21:49,110 --> 00:21:55,200
runtime and discovery is a it's kind of

00:21:52,320 --> 00:21:57,600
a big deal and most of the solutions

00:21:55,200 --> 00:21:59,430
that exist today provides some level of

00:21:57,600 --> 00:22:01,770
support to help application developers

00:21:59,430 --> 00:22:06,180
find that stuff out either through the

00:22:01,770 --> 00:22:07,860
environment or through DNS so we've

00:22:06,180 --> 00:22:09,270
kicked around for a little while the

00:22:07,860 --> 00:22:10,950
notion of trying to use DNS for some of

00:22:09,270 --> 00:22:12,720
these things it hasn't gone anywhere

00:22:10,950 --> 00:22:14,250
it's not currently on the roadmap but

00:22:12,720 --> 00:22:16,740
we're looking for lots of opinions from

00:22:14,250 --> 00:22:18,390
people right on where we should go one

00:22:16,740 --> 00:22:19,290
of the options was take those names that

00:22:18,390 --> 00:22:21,450
we were talking about for explicit

00:22:19,290 --> 00:22:23,940
policy before where you labeled it back

00:22:21,450 --> 00:22:26,310
in and you gave it the the the port

00:22:23,940 --> 00:22:28,550
cetera may take that bind name and use

00:22:26,310 --> 00:22:30,870
that something you can reference in DNS

00:22:28,550 --> 00:22:32,940
another approach is we do nothing for

00:22:30,870 --> 00:22:34,530
you so you have a single interface you

00:22:32,940 --> 00:22:35,970
can get the IP yourself and if you want

00:22:34,530 --> 00:22:39,300
to roll your own service discovery you

00:22:35,970 --> 00:22:40,860
certainly can or if you're using a

00:22:39,300 --> 00:22:43,350
library in your application that allows

00:22:40,860 --> 00:22:43,770
you to essentially register you can do

00:22:43,350 --> 00:22:49,620
that

00:22:43,770 --> 00:22:51,690
those are options but yeah we're looking

00:22:49,620 --> 00:22:54,480
for some input here I personally feel

00:22:51,690 --> 00:22:56,220
like discovery something that is is kind

00:22:54,480 --> 00:22:58,200
of important having a network without

00:22:56,220 --> 00:23:00,660
being able to find your target is really

00:22:58,200 --> 00:23:04,020
only part of the solution so if you have

00:23:00,660 --> 00:23:07,320
feedback come on in or we were open to

00:23:04,020 --> 00:23:09,870
it and then yeah we're at the end I mean

00:23:07,320 --> 00:23:12,030
this is really the call for action right

00:23:09,870 --> 00:23:14,700
please come out and get involved we've

00:23:12,030 --> 00:23:16,890
been around now since the beginning of

00:23:14,700 --> 00:23:19,230
the year we have a slack channel we get

00:23:16,890 --> 00:23:21,390
a little bit of action in there but we

00:23:19,230 --> 00:23:23,940
would really really welcome some people

00:23:21,390 --> 00:23:26,130
kind of expressing your use cases and

00:23:23,940 --> 00:23:28,320
what you need out of this we have some

00:23:26,130 --> 00:23:30,390
code that's already out there today we

00:23:28,320 --> 00:23:31,980
have two releases an old one and a new

00:23:30,390 --> 00:23:33,330
net man release that allows connectivity

00:23:31,980 --> 00:23:35,610
so you can play with it deploy it and

00:23:33,330 --> 00:23:38,910
explore what

00:23:35,610 --> 00:23:39,809
you know finally you know we went

00:23:38,910 --> 00:23:41,490
through the five things that we're

00:23:39,809 --> 00:23:44,549
thinking about right now that's not an

00:23:41,490 --> 00:23:46,920
exhaustive list but we're looking at

00:23:44,549 --> 00:23:48,750
that being enough to get started so if

00:23:46,920 --> 00:23:51,240
that's not enough to get started for

00:23:48,750 --> 00:23:57,059
people what are we missing right that's

00:23:51,240 --> 00:23:58,500
kind of where we are yeah and then more

00:23:57,059 --> 00:23:59,670
stuff if you're interested in container

00:23:58,500 --> 00:24:02,460
networking we're having office hours

00:23:59,670 --> 00:24:04,950
tomorrow and there's also this recently

00:24:02,460 --> 00:24:08,400
added thing about CNI and OCI not really

00:24:04,950 --> 00:24:10,490
sure what it is but I'm an attend thank

00:24:08,400 --> 00:24:10,490
you

00:24:10,670 --> 00:24:14,009
[Applause]

00:24:16,270 --> 00:24:19,510
question front

00:24:49,049 --> 00:24:55,000
right so yeah so the the two points were

00:24:52,539 --> 00:24:56,139
the things that this yeah that's one

00:24:55,000 --> 00:24:57,669
trying to do the two points that we made

00:24:56,139 --> 00:24:58,960
from the question where one of the

00:24:57,669 --> 00:25:01,389
things that's really missing is ipv6

00:24:58,960 --> 00:25:02,559
support noted I think that's a larger

00:25:01,389 --> 00:25:04,480
effort within Cloud Foundry

00:25:02,559 --> 00:25:06,460
I think the overlay than you know within

00:25:04,480 --> 00:25:08,230
the container container I don't see why

00:25:06,460 --> 00:25:10,809
a network provider the plug-in could not

00:25:08,230 --> 00:25:12,820
support ipv6 if they chose to but

00:25:10,809 --> 00:25:14,470
outside of Cloud Foundry like within the

00:25:12,820 --> 00:25:16,629
fabric Cloud Foundry right now it's ipv4

00:25:14,470 --> 00:25:19,330
so I think it's a larger work effort the

00:25:16,629 --> 00:25:21,399
the other piece was around multi data

00:25:19,330 --> 00:25:23,259
center and extending the network and

00:25:21,399 --> 00:25:25,299
again I think that's where the

00:25:23,259 --> 00:25:26,559
extensibility comes into play where the

00:25:25,299 --> 00:25:27,850
network that you have between the two

00:25:26,559 --> 00:25:29,769
depending on the technology that you use

00:25:27,850 --> 00:25:31,570
you could federated bridge you add your

00:25:29,769 --> 00:25:32,980
own routing rules to do that so with

00:25:31,570 --> 00:25:34,090
what's battery you know batteries

00:25:32,980 --> 00:25:35,799
included I don't think we're ever going

00:25:34,090 --> 00:25:37,480
to try to support all the enterprise use

00:25:35,799 --> 00:25:38,950
cases you have multi data center dr and

00:25:37,480 --> 00:25:41,350
everything else and that's really why

00:25:38,950 --> 00:25:43,059
those plug points are there right we

00:25:41,350 --> 00:25:44,740
really want to get to that now Multi

00:25:43,059 --> 00:25:46,659
Cloud Foundry is kind of an interesting

00:25:44,740 --> 00:25:48,309
one right multi Cloud Foundry is where

00:25:46,659 --> 00:25:50,259
you have you manned up at the point

00:25:48,309 --> 00:25:52,059
where you have two policy engines and I

00:25:50,259 --> 00:25:53,289
don't know really how to solve that

00:25:52,059 --> 00:25:54,759
problem so that'd be an interesting

00:25:53,289 --> 00:25:56,320
conversation to have during office hours

00:25:54,759 --> 00:25:57,460
or if you have any ideas that would be I

00:25:56,320 --> 00:26:03,000
think that'd be really welcome we'd hear

00:25:57,460 --> 00:26:03,000
those any other questions

00:26:11,600 --> 00:26:15,809
yeah this this is completely separate

00:26:14,370 --> 00:26:16,740
from router this is that's actually one

00:26:15,809 --> 00:26:18,480
of the things that we should have

00:26:16,740 --> 00:26:20,100
probably talked about the way the router

00:26:18,480 --> 00:26:21,899
works today is the component something

00:26:20,100 --> 00:26:23,789
Cloud Foundry actually advertised routes

00:26:21,899 --> 00:26:26,010
what that means is the constantly

00:26:23,789 --> 00:26:27,929
broadcast they say this name is that

00:26:26,010 --> 00:26:29,309
this address at this port and the

00:26:27,929 --> 00:26:31,080
routers watch for those advertisements

00:26:29,309 --> 00:26:32,519
and when a request comes in

00:26:31,080 --> 00:26:34,440
they will forward it to that host

00:26:32,519 --> 00:26:36,450
important that's true for TCP and for

00:26:34,440 --> 00:26:37,919
HTTP right with with a couple of

00:26:36,450 --> 00:26:39,659
differences in the flows but that's

00:26:37,919 --> 00:26:42,240
largely what happens the container

00:26:39,659 --> 00:26:43,289
networking it will will allow you to get

00:26:42,240 --> 00:26:45,360
into the container through the router

00:26:43,289 --> 00:26:46,769
still buy advertising routes but what's

00:26:45,360 --> 00:26:47,880
more important is now the containers can

00:26:46,769 --> 00:26:49,169
talk to each other without going through

00:26:47,880 --> 00:26:51,389
the router it's completely separate from

00:26:49,169 --> 00:26:53,070
the router so for route services the

00:26:51,389 --> 00:26:54,750
stuff that comings from the router still

00:26:53,070 --> 00:26:56,370
applies you have the ability to receive

00:26:54,750 --> 00:26:59,159
the request modify the request stage

00:26:56,370 --> 00:27:00,690
request but you don't have access to

00:26:59,159 --> 00:27:02,039
what's happening for container to

00:27:00,690 --> 00:27:04,610
container communication only was coming

00:27:02,039 --> 00:27:04,610
from the frontier

00:27:13,170 --> 00:27:17,620
right the limits on the router on the

00:27:16,030 --> 00:27:19,330
routing tier from the front end only

00:27:17,620 --> 00:27:21,610
apply to what the router receives and

00:27:19,330 --> 00:27:23,260
sends out right but again if you don't

00:27:21,610 --> 00:27:25,330
want to use container networking right

00:27:23,260 --> 00:27:27,100
so for the back end you expose a route

00:27:25,330 --> 00:27:28,740
and you go through the front door but

00:27:27,100 --> 00:27:30,820
then what you end up doing is you have

00:27:28,740 --> 00:27:32,410
you pay the price of coming through that

00:27:30,820 --> 00:27:33,880
round-trip so you now get to choose

00:27:32,410 --> 00:27:35,800
right you have flexibility that you

00:27:33,880 --> 00:27:36,970
didn't have before which is a win and if

00:27:35,800 --> 00:27:38,290
you choose to be your own rate limiting

00:27:36,970 --> 00:27:40,800
inside of your application or your

00:27:38,290 --> 00:27:43,800
container you have that ability as well

00:27:40,800 --> 00:27:43,800
yeah

00:27:52,059 --> 00:27:55,269
yeah so one of the things in the battery

00:27:53,830 --> 00:27:57,489
so the question is exposing a container

00:27:55,269 --> 00:27:59,289
not just other containers that was

00:27:57,489 --> 00:28:00,279
basically a question right yeah so one

00:27:59,289 --> 00:28:02,139
of the things in the batteries included

00:28:00,279 --> 00:28:04,149
model that's being proposed right now is

00:28:02,139 --> 00:28:05,559
the IP addresses for the container are

00:28:04,149 --> 00:28:07,059
actually accessible from outside the

00:28:05,559 --> 00:28:09,219
container I don't think that's something

00:28:07,059 --> 00:28:10,539
that necessarily you can rely on in all

00:28:09,219 --> 00:28:11,349
environments because as soon as you get

00:28:10,539 --> 00:28:14,320
to plug it in there

00:28:11,349 --> 00:28:16,299
those IPS may not be accessible but

00:28:14,320 --> 00:28:17,679
again it's going to depend on the on the

00:28:16,299 --> 00:28:21,359
conductivity the batteries in the

00:28:17,679 --> 00:28:21,359
batteries included version would do that

00:28:23,159 --> 00:28:36,849
anything else thank you

00:28:28,230 --> 00:28:36,849

YouTube URL: https://www.youtube.com/watch?v=wcbKzdLDBk8


