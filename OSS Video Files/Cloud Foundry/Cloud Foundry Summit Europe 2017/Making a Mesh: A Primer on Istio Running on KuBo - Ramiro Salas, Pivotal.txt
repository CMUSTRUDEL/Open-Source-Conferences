Title: Making a Mesh: A Primer on Istio Running on KuBo - Ramiro Salas, Pivotal
Publication date: 2017-10-18
Playlist: Cloud Foundry Summit Europe 2017
Description: 
	Making a Mesh: A Primer on Istio Running on KuBo - Ramiro Salas, Pivotal

The concept of a service mesh represents a paradigm shift on application connectivity for distributed systems, with wide implications for analytics, policy and extensibility. In this talk, we will explain what a service mesh is, the power it brings to microservices, and its impact on Cloud Foundry and K8s, both separately and together. We will also discuss the implications for the traditional network infrastructure, and the shifting of responsibilities from L3/4 to L7.

About Ramiro Salas
Ramiro Salas is Product Lead for Networking at Pivotal R&D. He has 30 years in the industry, with 9 of them in the Telecom space. Ramiro was CTO of the first privately owned ISP in Chile, and has worked at renowned telecom equipment vendors like Ascend, Lucent and CoSine Communications having done business in 31 countries and lived in 4. He was NetSec & NFV Specialist at VMware, where he worked for 10 years. He also serves in the board of advisors at startups in related fields, and heâ€™s a regular presenter at conferences and meetups.
Captions: 
	00:00:00,030 --> 00:00:07,170
hello hello good afternoon thank you for

00:00:04,049 --> 00:00:10,019
coming to the talk my name is Ramiro

00:00:07,170 --> 00:00:13,650
worth of pivitol San Francisco and I

00:00:10,019 --> 00:00:15,089
focus primarily on networking the reason

00:00:13,650 --> 00:00:16,800
why we wanted to have this talk in

00:00:15,089 --> 00:00:19,289
particular is because the pattern of

00:00:16,800 --> 00:00:21,449
service meshes is a pattern that has

00:00:19,289 --> 00:00:23,130
been starting to percolate in the

00:00:21,449 --> 00:00:27,539
industry for the last 2 years

00:00:23,130 --> 00:00:29,760
approximately and some communities are

00:00:27,539 --> 00:00:31,800
probably more aware of that pattern than

00:00:29,760 --> 00:00:32,579
others and we have noticed in different

00:00:31,800 --> 00:00:35,820
conversations with customers

00:00:32,579 --> 00:00:37,800
specifically in pivotal that the CF

00:00:35,820 --> 00:00:39,989
community in general is still not very

00:00:37,800 --> 00:00:41,579
aware of the pattern of a service mesh

00:00:39,989 --> 00:00:44,640
so we wanted to do like a very very

00:00:41,579 --> 00:00:45,899
basic with no assumptions whatsoever and

00:00:44,640 --> 00:00:46,950
there are many service message types

00:00:45,899 --> 00:00:48,329
right and we're going to focus primarily

00:00:46,950 --> 00:00:50,039
on East Year which is the one that we're

00:00:48,329 --> 00:00:51,449
interested in and I want to cover why

00:00:50,039 --> 00:00:54,600
we're interested in that particular one

00:00:51,449 --> 00:00:55,860
and the idea obviously is to keep it

00:00:54,600 --> 00:00:57,120
hopefully interacting when I try to

00:00:55,860 --> 00:00:59,670
leave a few minutes at the end this is a

00:00:57,120 --> 00:01:01,680
conceptual talk it's a basic talk with

00:00:59,670 --> 00:01:03,270
the whole purpose that you guys walk out

00:01:01,680 --> 00:01:05,250
of here understanding the pattern

00:01:03,270 --> 00:01:06,840
understanding why this pattern matters

00:01:05,250 --> 00:01:08,820
and what's gonna look like for the

00:01:06,840 --> 00:01:12,080
future in the industry and this is as

00:01:08,820 --> 00:01:14,610
big as that the future of the industry

00:01:12,080 --> 00:01:16,500
it's all about micro services and this

00:01:14,610 --> 00:01:19,280
is not an understatement micro services

00:01:16,500 --> 00:01:21,390
in general they have changed the way

00:01:19,280 --> 00:01:23,400
networking should work on networking

00:01:21,390 --> 00:01:25,920
should react it's not just a matter of

00:01:23,400 --> 00:01:27,590
speed as you know micro services can be

00:01:25,920 --> 00:01:29,640
created and destroyed in a matter of

00:01:27,590 --> 00:01:30,479
microseconds or milliseconds in many

00:01:29,640 --> 00:01:32,220
cases right

00:01:30,479 --> 00:01:34,680
not all workloads are like that of

00:01:32,220 --> 00:01:36,000
course but it potentially can happen and

00:01:34,680 --> 00:01:38,070
when that happens what's gonna be the

00:01:36,000 --> 00:01:39,780
impact on the network right primarily

00:01:38,070 --> 00:01:42,090
what's gonna be what's gonna be the

00:01:39,780 --> 00:01:43,740
impact when you have instead of hundreds

00:01:42,090 --> 00:01:45,689
of the ends which is you used to have

00:01:43,740 --> 00:01:48,060
before now you have hundreds of

00:01:45,689 --> 00:01:49,829
thousands of micro services right that

00:01:48,060 --> 00:01:55,049
all need to have their own networking

00:01:49,829 --> 00:01:57,119
characteristics so the micro service

00:01:55,049 --> 00:01:59,520
expectations of the networks are pretty

00:01:57,119 --> 00:02:01,320
high micro services have requirements

00:01:59,520 --> 00:02:02,520
like every other type of obligation in

00:02:01,320 --> 00:02:05,430
history has had requirements

00:02:02,520 --> 00:02:08,340
specifically it requires the network to

00:02:05,430 --> 00:02:09,629
exist to be available it relies on the

00:02:08,340 --> 00:02:11,550
network this is what we do in computer

00:02:09,629 --> 00:02:13,170
science we layer things will be layering

00:02:11,550 --> 00:02:15,989
things since the beginning of computer

00:02:13,170 --> 00:02:18,030
so a micro service as an entity as a

00:02:15,989 --> 00:02:20,099
software entity requires a network to be

00:02:18,030 --> 00:02:22,349
there to be available it requires to be

00:02:20,099 --> 00:02:24,510
fast micro service doesn't have to

00:02:22,349 --> 00:02:25,680
concern itself about the speed of the

00:02:24,510 --> 00:02:28,800
network it has to make an assumption

00:02:25,680 --> 00:02:30,030
that the network is essentially fast it

00:02:28,800 --> 00:02:31,680
has to make the assumptions that the

00:02:30,030 --> 00:02:33,840
network provides some degree of security

00:02:31,680 --> 00:02:35,970
let's say firewalling and functions like

00:02:33,840 --> 00:02:37,650
that typically happens outside the

00:02:35,970 --> 00:02:40,890
purview of the micro service there is

00:02:37,650 --> 00:02:42,330
obviously some security that happens

00:02:40,890 --> 00:02:44,880
within the micro service right typically

00:02:42,330 --> 00:02:46,680
single sign-on capabilities and so on

00:02:44,880 --> 00:02:48,810
are managed at the micro service level

00:02:46,680 --> 00:02:50,100
but there is an expectation a basic

00:02:48,810 --> 00:02:52,319
expectation and the network will provide

00:02:50,100 --> 00:02:55,260
some degree of security at least

00:02:52,319 --> 00:02:56,730
perimeter security and there's also an

00:02:55,260 --> 00:02:58,140
expectation in these days that the

00:02:56,730 --> 00:03:00,560
network is gonna provide a relatively

00:02:58,140 --> 00:03:02,519
low latency and this is important

00:03:00,560 --> 00:03:05,220
specifically as we move on to

00:03:02,519 --> 00:03:06,959
applications that use heavily other

00:03:05,220 --> 00:03:09,750
micro service to provide a single output

00:03:06,959 --> 00:03:12,269
so you have the expectations that we all

00:03:09,750 --> 00:03:14,610
behave like a consistent system across

00:03:12,269 --> 00:03:16,380
the board you may have new applications

00:03:14,610 --> 00:03:18,090
that are going to be consuming hundreds

00:03:16,380 --> 00:03:19,650
or thousands of micro services and you

00:03:18,090 --> 00:03:21,810
want to make sure there is consistency

00:03:19,650 --> 00:03:23,579
among them so not one single micro

00:03:21,810 --> 00:03:24,989
service is becoming the bottleneck for

00:03:23,579 --> 00:03:28,890
others so there's a lot of those

00:03:24,989 --> 00:03:31,049
patterns to start to matter and there's

00:03:28,890 --> 00:03:33,480
also the expectation that the network is

00:03:31,049 --> 00:03:35,430
gonna be transparent you don't care in

00:03:33,480 --> 00:03:37,700
this modern world if your network is

00:03:35,430 --> 00:03:40,890
based on AWS or it's based on whatever

00:03:37,700 --> 00:03:42,569
underlying Sdn is provided either by you

00:03:40,890 --> 00:03:43,799
or your data center or anybody else for

00:03:42,569 --> 00:03:45,180
that matter you just care that it's

00:03:43,799 --> 00:03:49,260
available it's there it's somehow

00:03:45,180 --> 00:03:50,579
available to you and of course we would

00:03:49,260 --> 00:03:53,370
love to believe that network should

00:03:50,579 --> 00:03:55,769
never fail right which we all probably

00:03:53,370 --> 00:03:59,069
know better right so there is some

00:03:55,769 --> 00:04:02,130
degree of certainty that that things

00:03:59,069 --> 00:04:03,389
will fail how does the micro service

00:04:02,130 --> 00:04:05,250
needs to react in terms of a failure

00:04:03,389 --> 00:04:06,750
that's another aspect that needs to be

00:04:05,250 --> 00:04:08,639
considered within the development and

00:04:06,750 --> 00:04:10,109
deployment of these micro services the

00:04:08,639 --> 00:04:12,780
network on the other hand the network

00:04:10,109 --> 00:04:15,090
also has some expectations for the micro

00:04:12,780 --> 00:04:17,160
service right it's not like the network

00:04:15,090 --> 00:04:18,810
knew ahead of time of the micro service

00:04:17,160 --> 00:04:20,340
right this is networks predates

00:04:18,810 --> 00:04:23,159
typically the generation of micro

00:04:20,340 --> 00:04:25,470
services however networks somehow expect

00:04:23,159 --> 00:04:26,720
that the micro service will implement

00:04:25,470 --> 00:04:29,120
its own service discovery

00:04:26,720 --> 00:04:30,770
the network function as it is does not

00:04:29,120 --> 00:04:32,480
provide you generally with any sort of

00:04:30,770 --> 00:04:34,100
service discovery there are other

00:04:32,480 --> 00:04:36,860
mechanisms for self-discovery that are

00:04:34,100 --> 00:04:38,240
implemented as a network function but

00:04:36,860 --> 00:04:40,250
typically is something that needs to be

00:04:38,240 --> 00:04:42,050
managed at the application level their

00:04:40,250 --> 00:04:44,630
platforms typically are very good in

00:04:42,050 --> 00:04:46,580
that right software systems like console

00:04:44,630 --> 00:04:49,010
for example or Eureka are very good

00:04:46,580 --> 00:04:50,840
doing that functionality but it's not

00:04:49,010 --> 00:04:54,740
necessarily a functionality that comes

00:04:50,840 --> 00:04:55,910
from the network so take a look at what

00:04:54,740 --> 00:04:57,140
I'm trying to today say here I'm trying

00:04:55,910 --> 00:04:59,480
to say that all this is from the

00:04:57,140 --> 00:05:01,040
perspective of the network right so the

00:04:59,480 --> 00:05:03,110
network really doesn't necessary

00:05:01,040 --> 00:05:04,940
implement its own service discovery it

00:05:03,110 --> 00:05:06,800
expects the application or the micro

00:05:04,940 --> 00:05:08,390
service to implement its own app level

00:05:06,800 --> 00:05:10,160
flow control and network provides you

00:05:08,390 --> 00:05:12,110
with some degree of flow control right

00:05:10,160 --> 00:05:14,660
which is typically based on the TCP

00:05:12,110 --> 00:05:16,190
layer right TCP has its own mechanism

00:05:14,660 --> 00:05:18,500
for the window size and so on

00:05:16,190 --> 00:05:20,270
adjustments for the flow control but

00:05:18,500 --> 00:05:23,630
that's a very low level facility you

00:05:20,270 --> 00:05:26,030
don't expect or you wouldn't want that

00:05:23,630 --> 00:05:28,100
modern developers have to concern

00:05:26,030 --> 00:05:29,840
themselves with that in the ideal world

00:05:28,100 --> 00:05:31,760
that should be abstracted from them they

00:05:29,840 --> 00:05:34,010
shouldn't have to think about that at

00:05:31,760 --> 00:05:35,900
the same time you need to implement your

00:05:34,010 --> 00:05:37,700
own network security obviously the

00:05:35,900 --> 00:05:39,290
network security externally to the micro

00:05:37,700 --> 00:05:41,780
services provided obviously by the

00:05:39,290 --> 00:05:43,580
network like firewalls or IDs and IPS

00:05:41,780 --> 00:05:45,200
systems and may be outside the purview

00:05:43,580 --> 00:05:46,940
of the micro service but there is an

00:05:45,200 --> 00:05:48,740
expectation of the micro service itself

00:05:46,940 --> 00:05:52,730
is gonna have to provide some degree of

00:05:48,740 --> 00:05:54,380
security implement its own protection in

00:05:52,730 --> 00:05:56,990
case of a network partitioning this is a

00:05:54,380 --> 00:06:00,560
very important element in distributed

00:05:56,990 --> 00:06:01,970
systems network partitioning happen that

00:06:00,560 --> 00:06:04,580
that means that if you have multiple

00:06:01,970 --> 00:06:05,810
instance of a service let's say HCD is a

00:06:04,580 --> 00:06:07,820
good example right let's say you have

00:06:05,810 --> 00:06:11,030
three instances of @cd and then as a

00:06:07,820 --> 00:06:12,740
partition occurs yet CD has intelligence

00:06:11,030 --> 00:06:14,270
within the system to understand what

00:06:12,740 --> 00:06:15,980
happens during that partition if the

00:06:14,270 --> 00:06:18,140
partition is over a certain amount of

00:06:15,980 --> 00:06:20,240
milliseconds or seconds then suddenly

00:06:18,140 --> 00:06:22,730
you now have two clusters one cluster of

00:06:20,240 --> 00:06:25,070
to one plus r1 so but there is obviously

00:06:22,730 --> 00:06:27,230
that's an undesirable effect but it is

00:06:25,070 --> 00:06:28,910
something that the application had to

00:06:27,230 --> 00:06:30,500
learn to deal with because the network

00:06:28,910 --> 00:06:35,330
partition is something that will occur

00:06:30,500 --> 00:06:37,070
eventually in any network whatsoever so

00:06:35,330 --> 00:06:38,780
protocols now have started to emerge

00:06:37,070 --> 00:06:40,340
once you start mixing these two worlds

00:06:38,780 --> 00:06:42,270
these two paradigms you starts

00:06:40,340 --> 00:06:43,710
micro-services and networks they start

00:06:42,270 --> 00:06:47,670
creating this new patterns these new

00:06:43,710 --> 00:06:49,620
protocols like HTTP 2 or like G RPC

00:06:47,670 --> 00:06:51,990
fantastic protocol that is based on HTTP

00:06:49,620 --> 00:06:53,400
2 for IOT or Internet of Things you

00:06:51,990 --> 00:06:56,610
start seeing the emergence of things

00:06:53,400 --> 00:06:58,430
like mqtt or co-op for example newer

00:06:56,610 --> 00:07:02,730
protocols that didn't exist years ago

00:06:58,430 --> 00:07:05,220
however this is still not sufficient or

00:07:02,730 --> 00:07:06,840
still need for things like HTTP 1.1

00:07:05,220 --> 00:07:08,340
there is still need for encryption

00:07:06,840 --> 00:07:10,560
everywhere there's still needs for

00:07:08,340 --> 00:07:13,020
sockets like raw TCP sockets or even raw

00:07:10,560 --> 00:07:14,730
UDP sockets right there's the need for

00:07:13,020 --> 00:07:16,500
multi ports applications that have

00:07:14,730 --> 00:07:18,660
specific needs for multi ports

00:07:16,500 --> 00:07:19,950
some other ones are dynamic port which

00:07:18,660 --> 00:07:21,510
makes it even more difficult specially

00:07:19,950 --> 00:07:24,720
the box over IP and media applications

00:07:21,510 --> 00:07:27,450
right so unfortunately nothing of this

00:07:24,720 --> 00:07:30,900
is really enough so new patterns need to

00:07:27,450 --> 00:07:34,640
emerge to satisfy the demanding needs of

00:07:30,900 --> 00:07:37,530
this micro services now at the same time

00:07:34,640 --> 00:07:40,290
micro services have also complex needs

00:07:37,530 --> 00:07:42,420
that are not easily fulfilled service

00:07:40,290 --> 00:07:44,670
health checks for example the network

00:07:42,420 --> 00:07:46,560
doesn't provide any mechanism natively

00:07:44,670 --> 00:07:48,900
to provide you with those health checks

00:07:46,560 --> 00:07:50,310
right extensive metrics well the micro

00:07:48,900 --> 00:07:51,390
service will generate those metrics and

00:07:50,310 --> 00:07:52,890
they need to go somewhere but the

00:07:51,390 --> 00:07:55,110
network is technically not responsible

00:07:52,890 --> 00:07:57,390
for any other stuff you need to send

00:07:55,110 --> 00:07:59,100
them somewhere right you need efficient

00:07:57,390 --> 00:08:00,960
patterns like circuit breakers that have

00:07:59,100 --> 00:08:03,600
become very popular in Springwood world

00:08:00,960 --> 00:08:06,120
and so on you need higher-level flow

00:08:03,600 --> 00:08:07,470
controls like manage QoS that you want

00:08:06,120 --> 00:08:09,720
to make sure that some micro services

00:08:07,470 --> 00:08:12,450
are not overwhelmed by the pressure of

00:08:09,720 --> 00:08:14,370
others and you need especially advanced

00:08:12,450 --> 00:08:16,050
policy controls you make you want to

00:08:14,370 --> 00:08:17,730
make sure that not only the developer

00:08:16,050 --> 00:08:20,280
setting the policy so who can talk to

00:08:17,730 --> 00:08:22,800
whom but also external entities say the

00:08:20,280 --> 00:08:25,560
InfoSec teams the info 16 may want to

00:08:22,800 --> 00:08:27,720
have horizontal adjacent policies that

00:08:25,560 --> 00:08:29,760
are superseding the policies that

00:08:27,720 --> 00:08:32,729
developers are creating for their own

00:08:29,760 --> 00:08:34,890
applications right and of course the

00:08:32,729 --> 00:08:37,740
networks can't really provide all that

00:08:34,890 --> 00:08:39,599
themselves now 30 years ago when I

00:08:37,740 --> 00:08:41,940
started doing networking we would have

00:08:39,599 --> 00:08:43,229
created a protocol for this right back

00:08:41,940 --> 00:08:44,700
in the day we used to do it by okay

00:08:43,229 --> 00:08:46,590
let's there's no protocol that could do

00:08:44,700 --> 00:08:49,020
that we'll just do another one IP x

00:08:46,590 --> 00:08:50,070
banyan vines we did all sort of

00:08:49,020 --> 00:08:52,380
different protocols for different

00:08:50,070 --> 00:08:53,420
purposes because he was ok right you can

00:08:52,380 --> 00:08:54,440
create a new protocol

00:08:53,420 --> 00:08:56,690
we would have done that today if we

00:08:54,440 --> 00:08:59,120
could but unfortunately we can't IP won

00:08:56,690 --> 00:09:00,589
the battle eyepiece everywhere the fact

00:08:59,120 --> 00:09:02,510
they said now we need to start

00:09:00,589 --> 00:09:03,889
augmenting the network we need to assume

00:09:02,510 --> 00:09:05,089
that the network is what it is there are

00:09:03,889 --> 00:09:06,769
some intelligent protocols there

00:09:05,089 --> 00:09:09,589
interesting things that are coming out

00:09:06,769 --> 00:09:11,449
of the pipe like quick for example which

00:09:09,589 --> 00:09:13,820
is a protocol that Google is actually

00:09:11,449 --> 00:09:15,980
experimenting quite a bit of there's bbr

00:09:13,820 --> 00:09:18,260
for congestion control but these are

00:09:15,980 --> 00:09:21,320
essentially efficiency models over the

00:09:18,260 --> 00:09:25,100
same IP paradigm unfortunately you still

00:09:21,320 --> 00:09:27,860
need to have a more complex layer on top

00:09:25,100 --> 00:09:30,680
of that network so we have done is that

00:09:27,860 --> 00:09:32,209
we have decided to replace instead of

00:09:30,680 --> 00:09:34,160
having this direct communication layer

00:09:32,209 --> 00:09:37,670
we have all these micro services talking

00:09:34,160 --> 00:09:39,589
to each other directly natively right we

00:09:37,670 --> 00:09:43,399
decided to change the model and overlay

00:09:39,589 --> 00:09:45,230
a new system in between in this in this

00:09:43,399 --> 00:09:48,260
case the system we call it sidecars

00:09:45,230 --> 00:09:51,500
right this site cards are essentially

00:09:48,260 --> 00:09:54,649
very small and very efficient highly

00:09:51,500 --> 00:09:56,630
sophisticated proxy systems that sits in

00:09:54,649 --> 00:09:58,760
between the micro service itself and the

00:09:56,630 --> 00:10:01,220
network so the micro service does not

00:09:58,760 --> 00:10:02,360
really talk to the network however the

00:10:01,220 --> 00:10:04,430
micro service doesn't have any awareness

00:10:02,360 --> 00:10:06,019
of them the micro Service believes is

00:10:04,430 --> 00:10:08,000
talking directly to a network but in

00:10:06,019 --> 00:10:09,649
reality is talking to a proxy this

00:10:08,000 --> 00:10:11,360
behaves very similar to the way you

00:10:09,649 --> 00:10:13,160
won't normally work with the proxy today

00:10:11,360 --> 00:10:15,079
this is almost no difference they say

00:10:13,160 --> 00:10:17,570
except that this proxies as you will see

00:10:15,079 --> 00:10:19,220
in a moment they do a lot more than the

00:10:17,570 --> 00:10:21,829
process that you're probably used to but

00:10:19,220 --> 00:10:23,839
but essentially conceptually the beauty

00:10:21,829 --> 00:10:25,070
of this is that now the communication

00:10:23,839 --> 00:10:26,779
all the aspect of the communication

00:10:25,070 --> 00:10:29,390
without having to create a new protocol

00:10:26,779 --> 00:10:32,300
we now are creating a new layer on top

00:10:29,390 --> 00:10:34,190
of the pre-existing protocols the

00:10:32,300 --> 00:10:36,649
advantage of this model is that now you

00:10:34,190 --> 00:10:38,390
have an entirely new data plane and this

00:10:36,649 --> 00:10:41,060
data plane is leveraging things like

00:10:38,390 --> 00:10:42,319
mutual TLS so every little blue line

00:10:41,060 --> 00:10:44,720
that you see here for example is a

00:10:42,319 --> 00:10:48,680
mutually authenticated TLS communication

00:10:44,720 --> 00:10:51,800
line don't directly in layer 7 so all

00:10:48,680 --> 00:10:54,110
the intelligences we move upwards in the

00:10:51,800 --> 00:10:55,660
stream no longer you need to rely on

00:10:54,110 --> 00:10:57,980
things like for example IPSec encryption

00:10:55,660 --> 00:10:59,480
which is fantastic I love IPSec I've

00:10:57,980 --> 00:11:02,000
done tons of projects with them and I'm

00:10:59,480 --> 00:11:04,370
a big fan however not everybody allows

00:11:02,000 --> 00:11:06,960
that and that's that's the job for my

00:11:04,370 --> 00:11:09,750
for my friends at Microsoft there that

00:11:06,960 --> 00:11:11,520
that do not allow native protocols 50

00:11:09,750 --> 00:11:14,910
and 51 in their network which is a

00:11:11,520 --> 00:11:16,230
standard IPSec things and there's many

00:11:14,910 --> 00:11:18,450
other networks where you simply are not

00:11:16,230 --> 00:11:20,360
gonna allow things like TCP or UDP or I

00:11:18,450 --> 00:11:24,840
or even ICMP for that matter

00:11:20,360 --> 00:11:26,940
however mutual TLS works everywhere now

00:11:24,840 --> 00:11:29,430
obviously this side cars are a data

00:11:26,940 --> 00:11:32,550
plane they still need a control plane

00:11:29,430 --> 00:11:34,530
right this control plane is the one that

00:11:32,550 --> 00:11:36,390
basically asks the intelligence layer

00:11:34,530 --> 00:11:39,930
how you gonna tell all this little spike

00:11:36,390 --> 00:11:41,400
has to do collective magic right that's

00:11:39,930 --> 00:11:43,740
the whole point of this and that is

00:11:41,400 --> 00:11:47,510
essentially a service mesh and I'm done

00:11:43,740 --> 00:11:49,230
why not not really but no one says

00:11:47,510 --> 00:11:50,790
essentially a service mission is as

00:11:49,230 --> 00:11:53,430
simple as that and as complex as that

00:11:50,790 --> 00:11:57,360
right there's a lot of intelligence that

00:11:53,430 --> 00:11:58,680
goes behind scene now the market today

00:11:57,360 --> 00:12:00,960
if you just look at the market as it is

00:11:58,680 --> 00:12:03,840
you have in the data plane world you

00:12:00,960 --> 00:12:06,300
have things like linker D envoy H a

00:12:03,840 --> 00:12:08,340
proxy traffic and there's other ones

00:12:06,300 --> 00:12:10,170
that keep coming up they manage those

00:12:08,340 --> 00:12:11,610
connections really well they have a lot

00:12:10,170 --> 00:12:13,830
of features in those connections they're

00:12:11,610 --> 00:12:15,810
all very rich in terms of capability

00:12:13,830 --> 00:12:18,480
these are tiny little proxies they're

00:12:15,810 --> 00:12:19,920
all efficient and they do one thing only

00:12:18,480 --> 00:12:21,480
and they do it really well some of them

00:12:19,920 --> 00:12:22,770
have more functionality than others some

00:12:21,480 --> 00:12:25,350
of them have more contributors than

00:12:22,770 --> 00:12:27,360
other but all of them are really good

00:12:25,350 --> 00:12:28,980
solutions and in terms of control planes

00:12:27,360 --> 00:12:30,480
you have other ones that are starting to

00:12:28,980 --> 00:12:33,300
pop up in the market you have each tier

00:12:30,480 --> 00:12:35,670
you have synapse from Airbnb you have

00:12:33,300 --> 00:12:36,930
Nelson and you have other ones also

00:12:35,670 --> 00:12:39,480
popping up in the open source community

00:12:36,930 --> 00:12:42,090
Nelson it's more get centric for example

00:12:39,480 --> 00:12:43,290
so you have different sort of systems

00:12:42,090 --> 00:12:46,170
out there that are trying to position

00:12:43,290 --> 00:12:47,880
themselves within this now sto in

00:12:46,170 --> 00:12:51,900
particular it's a project that was

00:12:47,880 --> 00:12:54,180
originally sponsored out of IBM Google

00:12:51,900 --> 00:12:55,350
and lyft right and we say lyft in

00:12:54,180 --> 00:12:57,900
particular because they're the ones

00:12:55,350 --> 00:12:59,970
behind the unvoiced which is the one

00:12:57,900 --> 00:13:01,500
that is two uses at pivotal were

00:12:59,970 --> 00:13:03,840
particularly interested in this do

00:13:01,500 --> 00:13:07,140
primarily because it is first and

00:13:03,840 --> 00:13:09,600
foremost platform agnostic so it doesn't

00:13:07,140 --> 00:13:11,790
have a requirement to be unique for

00:13:09,600 --> 00:13:13,350
kubernetes or unique for Cloud Foundry

00:13:11,790 --> 00:13:16,230
or for any other system it can be

00:13:13,350 --> 00:13:18,210
adapted to any sort of platform it's

00:13:16,230 --> 00:13:19,410
already been progressively added into

00:13:18,210 --> 00:13:20,819
Cloud Foundry there was a talk this

00:13:19,410 --> 00:13:22,350
morning about that there's more talk

00:13:20,819 --> 00:13:24,649
coming I have a schedule of the talks

00:13:22,350 --> 00:13:27,600
we're gonna be talking more about how

00:13:24,649 --> 00:13:30,509
East EO is getting slowly but surely

00:13:27,600 --> 00:13:32,189
inside the foundry the very station

00:13:30,509 --> 00:13:35,939
you're gonna see about this is the

00:13:32,189 --> 00:13:38,069
inclusion of envoy proxies being

00:13:35,939 --> 00:13:39,779
deployed with every app typically in a

00:13:38,069 --> 00:13:41,879
cloud foundry world when you save CF

00:13:39,779 --> 00:13:43,649
push you push an app an app is a single

00:13:41,879 --> 00:13:44,789
type of container entity right it

00:13:43,649 --> 00:13:46,139
doesn't matter how many you have you can

00:13:44,789 --> 00:13:47,489
have any number of instances but

00:13:46,139 --> 00:13:49,319
essentially it's one single type of

00:13:47,489 --> 00:13:51,269
binary well that's about to change with

00:13:49,319 --> 00:13:52,529
this now in addition to adding that

00:13:51,269 --> 00:13:54,809
single type of binary now you're gonna

00:13:52,529 --> 00:13:56,669
have a sidecar alongside with it right

00:13:54,809 --> 00:13:57,869
and that cycle is gonna be an envoy and

00:13:56,669 --> 00:13:59,999
that's the one that is gonna be

00:13:57,869 --> 00:14:01,529
controlling their communication the the

00:13:59,999 --> 00:14:04,410
beauty of the implementation of own

00:14:01,529 --> 00:14:06,089
Cloud Foundry is that we don't lose any

00:14:04,410 --> 00:14:08,910
of the simplicity that you're used to

00:14:06,089 --> 00:14:10,169
right claw foundry became popular with

00:14:08,910 --> 00:14:12,359
the developer community because it's

00:14:10,169 --> 00:14:14,069
simple you do a CF push and magic

00:14:12,359 --> 00:14:15,720
happens nothing of that is going to

00:14:14,069 --> 00:14:18,689
change you what you're gonna do you're

00:14:15,720 --> 00:14:21,539
gonna inherit this advantages that you

00:14:18,689 --> 00:14:24,179
get with a service mesh now obviously in

00:14:21,539 --> 00:14:25,619
in other clouds or other orchestrators

00:14:24,179 --> 00:14:27,389
like kubernetes for example you don't

00:14:25,619 --> 00:14:29,699
have those constructs so they're much

00:14:27,389 --> 00:14:32,129
more manual right you need to manually

00:14:29,699 --> 00:14:35,579
do things manually enable the service

00:14:32,129 --> 00:14:36,720
mesh manually set it up right that's

00:14:35,579 --> 00:14:38,970
some of the things that we're gonna be

00:14:36,720 --> 00:14:41,609
working with the community to over over

00:14:38,970 --> 00:14:44,009
time improving this process as I was

00:14:41,609 --> 00:14:46,379
mentioning is backed by lyft by IBM and

00:14:44,009 --> 00:14:48,659
Google all partner companies we partner

00:14:46,379 --> 00:14:51,600
in different areas of the business it's

00:14:48,659 --> 00:14:55,499
very very very lightweight specifically

00:14:51,600 --> 00:14:57,449
the Envoy system is it's written in C++

00:14:55,499 --> 00:14:59,609
it's extremely powerful extremely

00:14:57,449 --> 00:15:03,149
sophisticated it has a lot of different

00:14:59,609 --> 00:15:03,749
features very robust API and it's so

00:15:03,149 --> 00:15:05,729
small

00:15:03,749 --> 00:15:07,229
with so much functionality that is

00:15:05,729 --> 00:15:08,850
literally a no-brainer for us to just

00:15:07,229 --> 00:15:10,229
use it as a standard base of the system

00:15:08,850 --> 00:15:12,839
and implement it alongside pretty much

00:15:10,229 --> 00:15:14,909
anything else that we do it has a very

00:15:12,839 --> 00:15:16,919
dynamic environment community it's a

00:15:14,909 --> 00:15:18,979
young community is willing to do changes

00:15:16,919 --> 00:15:22,350
dynamically depending on what's needed

00:15:18,979 --> 00:15:24,059
and they are heavily Center in terms of

00:15:22,350 --> 00:15:27,209
plug ability and extensibility of their

00:15:24,059 --> 00:15:28,919
product they have capabilities as

00:15:27,209 --> 00:15:31,589
distributive tracing for example Zipkin

00:15:28,919 --> 00:15:33,569
is a natural element of the stimulate

00:15:31,589 --> 00:15:34,190
racing and it is standard with Easter

00:15:33,569 --> 00:15:37,640
stay

00:15:34,190 --> 00:15:40,130
with envoy in particular envoy also

00:15:37,640 --> 00:15:41,720
generates a ridiculous amount of metrics

00:15:40,130 --> 00:15:44,360
it has so many metrics that can

00:15:41,720 --> 00:15:45,920
overwhelm a normal system so that is

00:15:44,360 --> 00:15:47,270
very very powerful in some cases we have

00:15:45,920 --> 00:15:48,650
to decrease the amount of metrics that

00:15:47,270 --> 00:15:52,510
were generated out of envoy because it

00:15:48,650 --> 00:15:55,670
has so many right which is fantastic and

00:15:52,510 --> 00:15:57,410
finally has distributed security East

00:15:55,670 --> 00:16:00,800
goe Hall has the capability of

00:15:57,410 --> 00:16:02,540
maintaining this end-to-end TLS

00:16:00,800 --> 00:16:04,970
communication among all the endpoints

00:16:02,540 --> 00:16:07,490
and and also have the capability of

00:16:04,970 --> 00:16:10,310
creating and recreating and managing the

00:16:07,490 --> 00:16:13,520
TLS keys that are typical in this

00:16:10,310 --> 00:16:14,690
available type of environments ongoing

00:16:13,520 --> 00:16:17,630
in particular I was mentioning before

00:16:14,690 --> 00:16:20,180
C++ based system layer four layer seven

00:16:17,630 --> 00:16:21,680
proxy very low memory is being

00:16:20,180 --> 00:16:24,200
battle-tested already in places like

00:16:21,680 --> 00:16:26,270
lift this is not news been out there for

00:16:24,200 --> 00:16:28,940
a while it has over 100 plus services

00:16:26,270 --> 00:16:31,040
being deployed over 10,000 VMs and to

00:16:28,940 --> 00:16:32,720
millions of requests per second this is

00:16:31,040 --> 00:16:35,120
a system that actually works it works

00:16:32,720 --> 00:16:37,190
very well there is of course there was

00:16:35,120 --> 00:16:39,020
an version one API now there's a new

00:16:37,190 --> 00:16:40,910
version two API that keeps growing and

00:16:39,020 --> 00:16:45,050
it's more thought-out for distributed

00:16:40,910 --> 00:16:47,540
systems as a whole it has native HTTP

00:16:45,050 --> 00:16:49,370
two capabilities and G RPC capabilities

00:16:47,540 --> 00:16:51,020
out-of-the-box this is nothing that you

00:16:49,370 --> 00:16:54,380
have to add or a plug-in or anything

00:16:51,020 --> 00:16:56,060
like that right is is zone aware load

00:16:54,380 --> 00:16:58,250
balancing with failover has the

00:16:56,060 --> 00:17:00,560
capability of understanding AZ's as well

00:16:58,250 --> 00:17:02,330
right and has the capability of doing

00:17:00,560 --> 00:17:05,689
health checks circuit breakers timeouts

00:17:02,330 --> 00:17:07,790
and retries it's extremely sophisticated

00:17:05,689 --> 00:17:09,790
as a piece of software and it's also

00:17:07,790 --> 00:17:13,069
completely transparent to the network

00:17:09,790 --> 00:17:14,270
overall it has so many features that i

00:17:13,069 --> 00:17:16,339
would highly recommend that you guys

00:17:14,270 --> 00:17:17,689
look at their their webpage and look at

00:17:16,339 --> 00:17:20,329
this the entire list of features that

00:17:17,689 --> 00:17:22,750
they provide all of those features are

00:17:20,329 --> 00:17:24,829
somehow exposed in the east EO

00:17:22,750 --> 00:17:26,180
environment so whenever you have a nice

00:17:24,829 --> 00:17:28,490
new environment you're going to be able

00:17:26,180 --> 00:17:30,140
to use those features directly of Envoy

00:17:28,490 --> 00:17:32,420
I'm go is basically producing the data

00:17:30,140 --> 00:17:34,790
plane that you need being controlled by

00:17:32,420 --> 00:17:37,580
these two control plane the other

00:17:34,790 --> 00:17:39,920
interesting corollary of this is that

00:17:37,580 --> 00:17:41,690
there is now a big change in the

00:17:39,920 --> 00:17:43,760
discussion around what is east-west

00:17:41,690 --> 00:17:47,090
traffic versus what is north-south

00:17:43,760 --> 00:17:47,990
traffic in in Cal foundry that's a very

00:17:47,090 --> 00:17:49,730
common conversation

00:17:47,990 --> 00:17:52,400
in fact sometimes it's a heated

00:17:49,730 --> 00:17:53,720
discussion right north-south traffic is

00:17:52,400 --> 00:17:55,309
pretty much one of the things that you

00:17:53,720 --> 00:17:56,630
do in order to access applications in

00:17:55,309 --> 00:17:58,910
Cloud Foundry you come via the load

00:17:56,630 --> 00:18:00,679
balancer through the go router and then

00:17:58,910 --> 00:18:01,970
you go into the application and when the

00:18:00,679 --> 00:18:03,590
micro-service needs to talk to another

00:18:01,970 --> 00:18:05,420
micro servers if you're not using CF

00:18:03,590 --> 00:18:07,130
then working which is rather new you

00:18:05,420 --> 00:18:08,390
have to go all the way around the load

00:18:07,130 --> 00:18:11,780
balancer so you generate a lot of

00:18:08,390 --> 00:18:14,210
north-south traffic as opposed to the

00:18:11,780 --> 00:18:16,940
modern data center designs that are

00:18:14,210 --> 00:18:19,010
based on spine leaf architectures where

00:18:16,940 --> 00:18:21,830
typically you optimize for east-west

00:18:19,010 --> 00:18:24,050
traffic well in this model now that you

00:18:21,830 --> 00:18:26,150
have site cars everywhere north-south

00:18:24,050 --> 00:18:28,970
east-west become literally irrelevant

00:18:26,150 --> 00:18:31,490
everything is part of the same mesh the

00:18:28,970 --> 00:18:33,140
traffic will flow directly from the

00:18:31,490 --> 00:18:35,360
north there's a single entry point

00:18:33,140 --> 00:18:37,760
but now when microservices needs to talk

00:18:35,360 --> 00:18:38,720
to other micro services the mesh is

00:18:37,760 --> 00:18:41,179
literally it's going to make the

00:18:38,720 --> 00:18:42,800
decision how to reach the next micro

00:18:41,179 --> 00:18:44,450
service that you need to talk to or how

00:18:42,800 --> 00:18:46,640
to reach an external service that you

00:18:44,450 --> 00:18:49,970
need to talk to they're all part of the

00:18:46,640 --> 00:18:53,179
same mesh now optimized for that purpose

00:18:49,970 --> 00:18:54,350
so this is this is pretty game-changing

00:18:53,179 --> 00:18:56,090
if you guys think about especially if

00:18:54,350 --> 00:18:57,530
you've been involved in the in the cloud

00:18:56,090 --> 00:18:58,670
foundry community for a while this not

00:18:57,530 --> 00:19:00,320
only has the potential to completely

00:18:58,670 --> 00:19:02,870
replace the rack will replace the

00:19:00,320 --> 00:19:05,179
routing tier in cloud foundry but it

00:19:02,870 --> 00:19:06,800
also has severe implications also for

00:19:05,179 --> 00:19:08,960
kubernetes how kubernetes is going to

00:19:06,800 --> 00:19:11,090
evolve and transform itself as a product

00:19:08,960 --> 00:19:12,679
in a more usable fashion as this is

00:19:11,090 --> 00:19:16,070
going to give it get kubernetes new

00:19:12,679 --> 00:19:18,530
usability levels if you want to dig down

00:19:16,070 --> 00:19:20,690
deeper into how is to itself is built is

00:19:18,530 --> 00:19:22,040
to has different components as part of

00:19:20,690 --> 00:19:23,679
the control plane has three major

00:19:22,040 --> 00:19:26,870
components that we're going to talk to

00:19:23,679 --> 00:19:28,970
primarily pilot mixer and is to us these

00:19:26,870 --> 00:19:30,380
are the three different pieces one of

00:19:28,970 --> 00:19:33,590
the things that this team did very very

00:19:30,380 --> 00:19:35,780
well is plug ability at every layer each

00:19:33,590 --> 00:19:37,400
one of those layers is highly pluggable

00:19:35,780 --> 00:19:39,350
they all have good api's they all have

00:19:37,400 --> 00:19:41,480
capabilities to being inserted into

00:19:39,350 --> 00:19:43,730
pre-existing models and there are no

00:19:41,480 --> 00:19:45,110
dependencies at the moment with any

00:19:43,730 --> 00:19:47,920
other Orchestrator system out there

00:19:45,110 --> 00:19:52,250
which is an absolutely fantastic concept

00:19:47,920 --> 00:19:54,170
mixer mixer is the center point for the

00:19:52,250 --> 00:19:56,990
policy evaluation and telemetry of the

00:19:54,170 --> 00:19:59,660
entire system the policy system is

00:19:56,990 --> 00:20:00,960
pluggable here this think about this

00:19:59,660 --> 00:20:02,760
that the big concept

00:20:00,960 --> 00:20:04,710
here behind this if you create your own

00:20:02,760 --> 00:20:06,870
policy language because you want to

00:20:04,710 --> 00:20:08,700
create a domain-specific type situation

00:20:06,870 --> 00:20:11,100
you can create your own police language

00:20:08,700 --> 00:20:12,539
and you can plug it into mixer as long

00:20:11,100 --> 00:20:14,610
as you make sure that all the constructs

00:20:12,539 --> 00:20:17,340
match and you use the mixer API and you

00:20:14,610 --> 00:20:18,630
plug into that system one example for

00:20:17,340 --> 00:20:21,000
example we're looking seriously at the

00:20:18,630 --> 00:20:23,460
guise of opa for example open policy

00:20:21,000 --> 00:20:24,990
agents org open policy agent for example

00:20:23,460 --> 00:20:26,789
they have a multi-layered

00:20:24,990 --> 00:20:29,190
domain-specific language very

00:20:26,789 --> 00:20:31,080
sophisticated language right they apply

00:20:29,190 --> 00:20:32,750
different sort of policy mechanisms at

00:20:31,080 --> 00:20:35,880
different layers of the infrastructure

00:20:32,750 --> 00:20:38,100
well that system is now pluggable with

00:20:35,880 --> 00:20:40,380
mixer that means that if I choose to use

00:20:38,100 --> 00:20:42,299
that system I can just grab it plug it

00:20:40,380 --> 00:20:44,520
into mixer and now I can use my OPA

00:20:42,299 --> 00:20:46,080
language in order to define and

00:20:44,520 --> 00:20:49,289
describes the police east of my entire

00:20:46,080 --> 00:20:50,720
mesh right the potential for this is

00:20:49,289 --> 00:20:53,220
fantastic it's literally infinite

00:20:50,720 --> 00:20:54,750
potential possibilities of slicing and

00:20:53,220 --> 00:20:57,270
dicing any sort of platform that you

00:20:54,750 --> 00:20:59,580
want and again this is irrelevant if

00:20:57,270 --> 00:21:01,200
you're in class foundry you're in missus

00:20:59,580 --> 00:21:03,770
you're in kubernetes during any other

00:21:01,200 --> 00:21:06,840
thing that comes down in the future it

00:21:03,770 --> 00:21:09,450
supports mixer supports precondition

00:21:06,840 --> 00:21:11,250
checking quotas and rate limiting it has

00:21:09,450 --> 00:21:13,950
a primary point for extensibility as we

00:21:11,250 --> 00:21:16,559
mentioned before and it has specifically

00:21:13,950 --> 00:21:18,720
operator configuration model right so

00:21:16,559 --> 00:21:21,630
you can focus on the operator set of

00:21:18,720 --> 00:21:23,970
things obviously in a DevOps environment

00:21:21,630 --> 00:21:25,559
where say a developer can actually own

00:21:23,970 --> 00:21:28,529
an entire company's environment like

00:21:25,559 --> 00:21:30,029
what we'll see what PKS and Kubo in that

00:21:28,529 --> 00:21:31,890
sense it makes a lot more sense for them

00:21:30,029 --> 00:21:33,960
to control their own destiny they can

00:21:31,890 --> 00:21:36,179
plug the zipper every kubernetes custom

00:21:33,960 --> 00:21:38,250
they can plug their own components

00:21:36,179 --> 00:21:40,230
within mixer it doesn't have to be to

00:21:38,250 --> 00:21:42,360
have any sort of relationship with other

00:21:40,230 --> 00:21:46,409
clusters that are being provisioned in

00:21:42,360 --> 00:21:48,779
parallel more about that later pilot

00:21:46,409 --> 00:21:52,140
pilot is the system that actually plugs

00:21:48,779 --> 00:21:54,270
into the entire control plane to

00:21:52,140 --> 00:21:56,669
maintain the life cycle of the anvil

00:21:54,270 --> 00:21:59,850
instances and it has a very good API for

00:21:56,669 --> 00:22:02,010
service discovery now you need to have a

00:21:59,850 --> 00:22:04,380
service discovery system that can plug

00:22:02,010 --> 00:22:05,580
into this right that's one of the things

00:22:04,380 --> 00:22:07,020
that we're doing for example in Cloud

00:22:05,580 --> 00:22:10,649
Foundry right now in clock foundry the

00:22:07,020 --> 00:22:12,389
new service discovery system that is

00:22:10,649 --> 00:22:14,550
being created as being program as we

00:22:12,389 --> 00:22:16,200
speak that system one of the

00:22:14,550 --> 00:22:18,690
requirements that it has is to be

00:22:16,200 --> 00:22:20,940
pluggable with pilot so in the future

00:22:18,690 --> 00:22:22,380
when when pilot is fully integrated into

00:22:20,940 --> 00:22:23,820
Cloud Foundry you're gonna have the

00:22:22,380 --> 00:22:25,290
capability of using the service

00:22:23,820 --> 00:22:27,960
discovery that we produce in Cloud

00:22:25,290 --> 00:22:30,420
Foundry which is actually based on DNS

00:22:27,960 --> 00:22:32,610
internal names as well as boss DNS which

00:22:30,420 --> 00:22:36,900
is being used as well as underneath the

00:22:32,610 --> 00:22:38,700
system there is obviously load balancing

00:22:36,900 --> 00:22:40,260
pools and routing tables when I say

00:22:38,700 --> 00:22:41,430
routing here we're talking layer seven

00:22:40,260 --> 00:22:42,930
routing we're not talking about the

00:22:41,430 --> 00:22:45,570
typical layer 3 routing that were used

00:22:42,930 --> 00:22:47,820
to this is layer 7 routing this is

00:22:45,570 --> 00:22:49,350
application a tox to application B and

00:22:47,820 --> 00:22:51,570
this is the way to reach application B

00:22:49,350 --> 00:22:53,100
and this instance of an application B if

00:22:51,570 --> 00:22:55,260
I want to have Bluegreen deployments I

00:22:53,100 --> 00:22:57,180
can also do that that is a routing

00:22:55,260 --> 00:22:59,130
function for the mesh that will

00:22:57,180 --> 00:23:00,840
determine when an application is going

00:22:59,130 --> 00:23:02,640
to start fading from point A to point B

00:23:00,840 --> 00:23:05,970
you know as part of a standard

00:23:02,640 --> 00:23:08,160
mechanisms or the service mesh is to off

00:23:05,970 --> 00:23:11,190
at the same time another very powerful

00:23:08,160 --> 00:23:13,680
construct it gives you strong service to

00:23:11,190 --> 00:23:15,900
end to end to end service for a end user

00:23:13,680 --> 00:23:17,700
authentication mutual TLS it has

00:23:15,900 --> 00:23:19,650
built-in identity and credential

00:23:17,700 --> 00:23:21,630
management and in the future it will

00:23:19,650 --> 00:23:23,610
have role based access control and

00:23:21,630 --> 00:23:29,010
authorization hooks they're actually in

00:23:23,610 --> 00:23:30,510
the roadmap ok so this is very fast

00:23:29,010 --> 00:23:32,970
I know because with a short talk we have

00:23:30,510 --> 00:23:35,000
half an hour only so well so what about

00:23:32,970 --> 00:23:38,450
Kubo

00:23:35,000 --> 00:23:40,830
well Kubas you know and using the the

00:23:38,450 --> 00:23:43,530
expression that my friend Colin loves to

00:23:40,830 --> 00:23:45,810
to talk about is invented to delight as

00:23:43,530 --> 00:23:49,620
he likes to say a person who creates

00:23:45,810 --> 00:23:51,270
coronaries clusters right so Kubo per se

00:23:49,620 --> 00:23:52,670
or whatever snow we call now I can't

00:23:51,270 --> 00:23:57,120
keep up anymore

00:23:52,670 --> 00:23:58,890
Kubo is essentially a product that is

00:23:57,120 --> 00:24:00,750
not a kubernetes distribution by itself

00:23:58,890 --> 00:24:03,450
it's a software tool to create

00:24:00,750 --> 00:24:05,970
kubernetes clusters right so other

00:24:03,450 --> 00:24:07,860
people or yourself can consume those

00:24:05,970 --> 00:24:10,140
clusters right if you're a developer

00:24:07,860 --> 00:24:11,550
that want to consume a cluster you can

00:24:10,140 --> 00:24:13,020
just go to your service broker say hey

00:24:11,550 --> 00:24:14,100
create me a kubernetes cluster clear

00:24:13,020 --> 00:24:16,380
make we're not this environment and I

00:24:14,100 --> 00:24:17,460
can use that right it's as vanilla

00:24:16,380 --> 00:24:20,400
kubernetes

00:24:17,460 --> 00:24:21,750
as is possibly capable of doing this is

00:24:20,400 --> 00:24:23,100
one of the goals is to keep it as

00:24:21,750 --> 00:24:24,900
up-to-date as possible

00:24:23,100 --> 00:24:26,280
and of course it's all controlled by

00:24:24,900 --> 00:24:28,070
managed by Bosch which is one of the

00:24:26,280 --> 00:24:29,570
advantages of this right you can upgrade

00:24:28,070 --> 00:24:31,310
the entire control plane of the system

00:24:29,570 --> 00:24:33,830
without necessary touching the workers

00:24:31,310 --> 00:24:34,790
you can upgrade the workers later if you

00:24:33,830 --> 00:24:36,260
choose to do so

00:24:34,790 --> 00:24:39,860
but the control plane can also be

00:24:36,260 --> 00:24:41,750
upgraded I directly via via Bosch right

00:24:39,860 --> 00:24:43,880
it has strong isolation and

00:24:41,750 --> 00:24:45,230
multi-tenancy which is achieved by Bosch

00:24:43,880 --> 00:24:46,250
primarily you don't have to worry about

00:24:45,230 --> 00:24:48,230
the OS anymore

00:24:46,250 --> 00:24:49,940
or the cake compatibility the old order

00:24:48,230 --> 00:24:52,700
is all that is done by the stem cells

00:24:49,940 --> 00:24:55,640
and the other very important aspect of

00:24:52,700 --> 00:24:58,280
this is that each do like kubernetes it

00:24:55,640 --> 00:24:59,810
does not do multi-tenancy very well in

00:24:58,280 --> 00:25:00,710
fact at the moment is to doesn't do any

00:24:59,810 --> 00:25:04,190
sort multi-tenancy

00:25:00,710 --> 00:25:06,740
so that is a perfect fit for us this is

00:25:04,190 --> 00:25:09,140
really what we're telling like stom

00:25:06,740 --> 00:25:12,650
kubernetes + Kubo is the goodness here

00:25:09,140 --> 00:25:14,990
because now Kubo primarily provides you

00:25:12,650 --> 00:25:16,610
this isolated clusters and the isolation

00:25:14,990 --> 00:25:18,650
is guaranteed by Bosch this is hard

00:25:16,610 --> 00:25:20,780
isolation guaranteed by Bosch now you

00:25:18,650 --> 00:25:23,450
can have your Easter environments

00:25:20,780 --> 00:25:26,390
directly on top of that right each

00:25:23,450 --> 00:25:27,920
developer that produces a cluster can

00:25:26,390 --> 00:25:30,440
choose to install their own each to

00:25:27,920 --> 00:25:32,450
environment automatically right or

00:25:30,440 --> 00:25:34,580
manually if you want to do that - and

00:25:32,450 --> 00:25:36,710
now consume is - within your service

00:25:34,580 --> 00:25:38,420
mesh with in your internal cluster this

00:25:36,710 --> 00:25:38,990
is the present this can be done today

00:25:38,420 --> 00:25:41,320
right

00:25:38,990 --> 00:25:43,190
in order to set it up super simple just

00:25:41,320 --> 00:25:44,750
literally all these steps and you're

00:25:43,190 --> 00:25:46,790
gonna document later you can see them

00:25:44,750 --> 00:25:48,350
later in the recording or or just go to

00:25:46,790 --> 00:25:50,720
the website the installation is

00:25:48,350 --> 00:25:52,130
extremely simple just need to be blow

00:25:50,720 --> 00:25:53,510
your kubernetes environment assuming

00:25:52,130 --> 00:25:56,960
that you have the prep done for your own

00:25:53,510 --> 00:25:58,970
cloud right then set your clock your

00:25:56,960 --> 00:26:00,860
queue config directly to point of your

00:25:58,970 --> 00:26:03,590
cluster that you're trying to do then

00:26:00,860 --> 00:26:05,000
get the Easter release and as part of

00:26:03,590 --> 00:26:06,800
the process of getting these to release

00:26:05,000 --> 00:26:09,350
it will get automatically deployed and

00:26:06,800 --> 00:26:10,580
if you choose to do the empty LS for all

00:26:09,350 --> 00:26:12,800
the side cars with automatic injection

00:26:10,580 --> 00:26:15,920
it all automatically gets deployed with

00:26:12,800 --> 00:26:17,780
this is - initializer when you install

00:26:15,920 --> 00:26:19,850
is - initializer that means that every

00:26:17,780 --> 00:26:22,370
new app that you push into the

00:26:19,850 --> 00:26:25,010
kubernetes cluster that you created it's

00:26:22,370 --> 00:26:27,980
gonna automatically get the side cars

00:26:25,010 --> 00:26:29,990
inserted and you can then control the

00:26:27,980 --> 00:26:32,870
mesh in any way that you choose to do so

00:26:29,990 --> 00:26:34,250
so then you have verifies - its

00:26:32,870 --> 00:26:36,110
installed on running this will do it

00:26:34,250 --> 00:26:37,790
this with these commands right and then

00:26:36,110 --> 00:26:39,080
finally deploy your app and this is the

00:26:37,790 --> 00:26:40,580
way you do you deploy your app you have

00:26:39,080 --> 00:26:41,149
two mechanisms to deploy it I'm not

00:26:40,580 --> 00:26:42,619
going to

00:26:41,149 --> 00:26:45,950
spend time on backhoe sites just don't

00:26:42,619 --> 00:26:49,519
have much time now feature is great

00:26:45,950 --> 00:26:51,379
right features great so one possible

00:26:49,519 --> 00:26:53,629
future you know from your point of view

00:26:51,379 --> 00:26:56,529
I don't know tech stuff right that's the

00:26:53,629 --> 00:27:00,679
line from terminator for you Alzheimer's

00:26:56,529 --> 00:27:03,679
so I want you to think about these

00:27:00,679 --> 00:27:05,269
possibilities right this is an existing

00:27:03,679 --> 00:27:07,039
not very but I just want to make sure

00:27:05,269 --> 00:27:10,159
that you guys get a sense of what is

00:27:07,039 --> 00:27:11,719
possible here say it's Kubo create me a

00:27:10,159 --> 00:27:13,580
coordinators cluster with east EO

00:27:11,719 --> 00:27:15,409
pre-install in my local vSphere

00:27:13,580 --> 00:27:17,839
environment today we cannot do that

00:27:15,409 --> 00:27:19,999
right google create vanilla clusters but

00:27:17,839 --> 00:27:23,210
nothing will stop us to evolve

00:27:19,999 --> 00:27:25,639
cubot you do this as well to create pre

00:27:23,210 --> 00:27:28,460
ready is to environments

00:27:25,639 --> 00:27:31,339
right with kubernetes there furthermore

00:27:28,460 --> 00:27:32,659
say now use the open service broker on

00:27:31,339 --> 00:27:36,080
the main service broker to create my

00:27:32,659 --> 00:27:38,989
boss Manish Postgres clustered fronted

00:27:36,080 --> 00:27:42,289
by an unvoiced of my up for my own use

00:27:38,989 --> 00:27:44,299
and make it part of my mesh that can

00:27:42,289 --> 00:27:45,289
also be done as subversion zero point

00:27:44,299 --> 00:27:48,320
two of Sto

00:27:45,289 --> 00:27:52,570
you can now support VMs as members of

00:27:48,320 --> 00:27:55,330
the bash not only containers right

00:27:52,570 --> 00:27:59,149
furthermore and while you're at it

00:27:55,330 --> 00:28:01,070
extend my mesh to org foo and spaces bar

00:27:59,149 --> 00:28:03,099
and bass in my development cloud foundry

00:28:01,070 --> 00:28:05,570
on my google cloud using my credentials

00:28:03,099 --> 00:28:07,249
so imagine what we're talking about here

00:28:05,570 --> 00:28:09,859
merging all the system creating a

00:28:07,249 --> 00:28:12,320
service mesh that will go from Cloud

00:28:09,859 --> 00:28:15,019
Foundry all the way to multiple

00:28:12,320 --> 00:28:18,499
kubernetes clusters for the developers

00:28:15,019 --> 00:28:23,119
enjoyment and delight again following my

00:28:18,499 --> 00:28:25,690
my friend Colin's terminology here and

00:28:23,119 --> 00:28:27,950
now even create create me a new

00:28:25,690 --> 00:28:30,469
communities cluster on my AWS

00:28:27,950 --> 00:28:33,859
environment and furthermore extend they

00:28:30,469 --> 00:28:37,009
is to mesh they're all those things are

00:28:33,859 --> 00:28:38,779
actually feasible to do how many of

00:28:37,009 --> 00:28:39,169
these are we gonna do when are we gonna

00:28:38,779 --> 00:28:41,509
do that

00:28:39,169 --> 00:28:43,729
it's always going to be dependent on you

00:28:41,509 --> 00:28:45,739
especially if you are a customer right

00:28:43,729 --> 00:28:47,389
you already want to need to tell us yeah

00:28:45,739 --> 00:28:49,399
this resonates with me this sounds like

00:28:47,389 --> 00:28:51,379
something I want to do right and if

00:28:49,399 --> 00:28:52,999
that's the case I want to hear from you

00:28:51,379 --> 00:28:54,830
literally because we actually we're in

00:28:52,999 --> 00:28:56,060
the process right now building roadmap

00:28:54,830 --> 00:28:57,470
for this kind of thing we're going to

00:28:56,060 --> 00:29:00,260
work in conjunction with the community

00:28:57,470 --> 00:29:01,760
this is not an insular thing this is all

00:29:00,260 --> 00:29:03,410
community based this is all open source

00:29:01,760 --> 00:29:08,540
code right we're going to be working

00:29:03,410 --> 00:29:12,230
with everybody on on this area but need

00:29:08,540 --> 00:29:13,520
to adapt need to adapt SDM inners Sdn

00:29:12,230 --> 00:29:16,280
vendors will have to up their game

00:29:13,520 --> 00:29:19,160
because now all the intelligence moving

00:29:16,280 --> 00:29:20,930
up to layer seven all this beautiful

00:29:19,160 --> 00:29:23,210
micro segmentation and all those goodies

00:29:20,930 --> 00:29:26,330
that they used to sell us so hardly now

00:29:23,210 --> 00:29:28,100
suddenly I wouldn't say they don't

00:29:26,330 --> 00:29:29,810
matter they do matter for one purpose

00:29:28,100 --> 00:29:32,300
because they need to protect the mesh

00:29:29,810 --> 00:29:34,340
right they need to protect this from

00:29:32,300 --> 00:29:36,710
denial of service attacks and so on but

00:29:34,340 --> 00:29:37,970
essentially that's the role now so

00:29:36,710 --> 00:29:41,300
they're gonna have to figure out a way

00:29:37,970 --> 00:29:44,740
to insert themselves into a world where

00:29:41,300 --> 00:29:47,690
the intelligence is moving upwards

00:29:44,740 --> 00:29:50,030
orchestrators and this is also valid for

00:29:47,690 --> 00:29:51,950
the Cloud Foundry community and for the

00:29:50,030 --> 00:29:54,140
communities community we also have gonna

00:29:51,950 --> 00:29:55,820
have to up their game because

00:29:54,140 --> 00:29:58,060
essentially once you have a mesh that

00:29:55,820 --> 00:29:59,990
can expand in different directions where

00:29:58,060 --> 00:30:01,180
essentially all the components are going

00:29:59,990 --> 00:30:03,710
to look pretty much alike

00:30:01,180 --> 00:30:05,330
then you better up your game you've got

00:30:03,710 --> 00:30:06,830
to figure out a way how to keep adding

00:30:05,330 --> 00:30:09,050
that secret sauce up people who want to

00:30:06,830 --> 00:30:12,080
buy your product or use your product for

00:30:09,050 --> 00:30:13,370
using only open-source envoy is great

00:30:12,080 --> 00:30:14,840
but for example it doesn't have the

00:30:13,370 --> 00:30:17,570
capability for more specialized things

00:30:14,840 --> 00:30:19,070
like in India NFV world or network

00:30:17,570 --> 00:30:22,100
function virtualization for telecom for

00:30:19,070 --> 00:30:24,320
example we love to use HTTP protocol

00:30:22,100 --> 00:30:26,210
which is not there in the list and boy

00:30:24,320 --> 00:30:27,500
doesn't support that so should we create

00:30:26,210 --> 00:30:29,180
an alternative to envoy

00:30:27,500 --> 00:30:32,570
shouldn't we grow in that direction to

00:30:29,180 --> 00:30:35,150
also super sctv acid SCTP what about

00:30:32,570 --> 00:30:37,250
native imputed tea or coop right for IOT

00:30:35,150 --> 00:30:39,170
protocols right so all those things

00:30:37,250 --> 00:30:40,490
actually matter right which one of them

00:30:39,170 --> 00:30:42,290
are we going to be able to support or

00:30:40,490 --> 00:30:43,790
not it's going to be over time we're

00:30:42,290 --> 00:30:45,950
gonna have to figure out sense of

00:30:43,790 --> 00:30:47,900
realism is to as young it's new it's a

00:30:45,950 --> 00:30:50,150
very new protocol there's not a lot of

00:30:47,900 --> 00:30:52,220
best practices for h8 right now there is

00:30:50,150 --> 00:30:53,480
no Federation capability a lot of the

00:30:52,220 --> 00:30:55,100
things we're talking about depending on

00:30:53,480 --> 00:30:57,140
they give ability of Federation it

00:30:55,100 --> 00:31:00,140
doesn't support that yet right they're

00:30:57,140 --> 00:31:01,430
obviously thinking about that there

00:31:00,140 --> 00:31:03,380
needs to be integration and cooperation

00:31:01,430 --> 00:31:05,630
with the Sdn layers there's none of that

00:31:03,380 --> 00:31:06,980
yet right all that needs to happen the

00:31:05,630 --> 00:31:08,120
tiger guys are probably the only ones

00:31:06,980 --> 00:31:08,770
that are more advanced thinking about

00:31:08,120 --> 00:31:13,490
that area

00:31:08,770 --> 00:31:15,830
with calico no options about the

00:31:13,490 --> 00:31:19,580
end-to-end policy to provide flexibility

00:31:15,830 --> 00:31:22,970
can be create can be complex etc down

00:31:19,580 --> 00:31:25,010
the road so essentially there's a lot of

00:31:22,970 --> 00:31:26,120
still unknowns in this area there's a

00:31:25,010 --> 00:31:28,760
lot of things that are being developed

00:31:26,120 --> 00:31:30,830
the big message for you guys is get

00:31:28,760 --> 00:31:32,870
educated on this and if you have ideas

00:31:30,830 --> 00:31:34,070
let us know if you have some things that

00:31:32,870 --> 00:31:36,020
we haven't thought about let us know

00:31:34,070 --> 00:31:37,670
many of these things are going to be

00:31:36,020 --> 00:31:38,690
incorporated in future future roadmaps

00:31:37,670 --> 00:31:41,180
and it will be up to you to determine

00:31:38,690 --> 00:31:43,100
which ones and unfortunately I'm out of

00:31:41,180 --> 00:31:49,359
time so thank you

00:31:43,100 --> 00:31:49,359

YouTube URL: https://www.youtube.com/watch?v=erA7Icm__W4


