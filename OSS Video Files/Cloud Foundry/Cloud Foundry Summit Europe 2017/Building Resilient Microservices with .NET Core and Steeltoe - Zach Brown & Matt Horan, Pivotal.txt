Title: Building Resilient Microservices with .NET Core and Steeltoe - Zach Brown & Matt Horan, Pivotal
Publication date: 2017-10-18
Playlist: Cloud Foundry Summit Europe 2017
Description: 
	Building Resilient Microservices with .NET Core and Steeltoe - Zach Brown & Matt Horan, Pivotal

The cloud encourages a set of design principles that, at first, may seem a little foreign to .NET developers. There are 12-factor apps, microservices, and patterns like service discovery, shared config management, and circuit breakers.

To make their apps run and scale well on Cloud Foundry, developers need to explicitly declare all dependencies, externalize configuration, store session state out of process, and avoid accessing the registry, the GAC, or the local file system.

This session is for developers and architects who want to leverage cloud-native architectures with their .NET apps on Cloud Foundry. The speakers will demonstrate cloud-native development patterns using .NET Core and Steeltoe (https://steeltoe.io), a new project aimed at cloud-native .NET.

About Zach Brown
Zach Brown starting building web sites in the 90s using Netscape-optimized HTML, cgi, and lots of Photoshop lens flares. He spent many years as an enterprise software developer in the Microsoft ecosystem, and now works at Pivotal in San Francisco as a customer-facing Product Owner for Pivotal Cloud Foundry and Steeltoe.

About Matthew Horan
Matthew Horan has spent over a decade developing Web applications. Before becoming a developer, he worked as a systems administrator at various startups and hosting providers. Having worked with just about every configuration management tool, and being a developer by trade, he was naturally drawn to Cloud Foundry. He has focused on .NET due to a desire to bring the best practices of Pivotal's Cloud Foundry platform to a wider audience.
Captions: 
	00:00:00,110 --> 00:00:05,279
all right thanks everyone for coming to

00:00:02,340 --> 00:00:07,259
building microservices with.net core and

00:00:05,279 --> 00:00:14,250
Steel Toe hopefully you're in the right

00:00:07,259 --> 00:00:16,260
place a quick introduction

00:00:14,250 --> 00:00:19,170
I'm Matt Horan a software engineer at

00:00:16,260 --> 00:00:22,529
pivotal I'm Zac Brown I also work at

00:00:19,170 --> 00:00:25,619
pivotal and we're going to talk about

00:00:22,529 --> 00:00:29,640
today a quick introduction introduction

00:00:25,619 --> 00:00:31,520
to the dotnet Renaissance we'll talk a

00:00:29,640 --> 00:00:34,770
little bit about what is steel-toe and

00:00:31,520 --> 00:00:38,520
why did we build it we have a quick demo

00:00:34,770 --> 00:00:42,809
and then a roadmap and resources at the

00:00:38,520 --> 00:00:45,989
end please be engaged we'd love for you

00:00:42,809 --> 00:00:48,480
to talk with us after this talk today

00:00:45,989 --> 00:00:51,539
and reach out to us on Twitter follow

00:00:48,480 --> 00:00:54,899
Zack or the steel-toe project and please

00:00:51,539 --> 00:00:56,640
engage with us so Zack why don't you

00:00:54,899 --> 00:01:00,719
tell us about this so-called done that

00:00:56,640 --> 00:01:02,780
Renaissance I don't mind if I do all

00:01:00,719 --> 00:01:02,780
right

00:01:04,010 --> 00:01:09,600
some people in the open source world

00:01:06,240 --> 00:01:11,130
when you hear the words dotnet you don't

00:01:09,600 --> 00:01:14,909
automatically think cool

00:01:11,130 --> 00:01:17,159
maybe you think old-school I suppose

00:01:14,909 --> 00:01:21,240
they think that all the all the cool

00:01:17,159 --> 00:01:24,450
kids are writing golang and an ode apps

00:01:21,240 --> 00:01:26,759
nowadays well there's a lot of stuff

00:01:24,450 --> 00:01:28,979
that's been happening up in Redmond a

00:01:26,759 --> 00:01:31,409
lot of changes are underfoot and

00:01:28,979 --> 00:01:34,049
ultimately they make right now this very

00:01:31,409 --> 00:01:36,390
moment a very exciting time to be a

00:01:34,049 --> 00:01:37,770
dotnet developer in case you're not

00:01:36,390 --> 00:01:39,860
clear what I'm talking about let me

00:01:37,770 --> 00:01:44,369
refresh your memory

00:01:39,860 --> 00:01:47,490
Microsoft loves Linux you can now run

00:01:44,369 --> 00:01:50,399
bash on Windows you can run Linux

00:01:47,490 --> 00:01:52,470
containers on Windows I mean who could

00:01:50,399 --> 00:01:53,939
have seen this coming it was just a few

00:01:52,470 --> 00:01:57,420
years ago this would have been

00:01:53,939 --> 00:01:59,700
unthinkable I really personally I hope

00:01:57,420 --> 00:02:01,829
somewhere deep down inside of me that

00:01:59,700 --> 00:02:04,170
someone at Microsoft has printed up one

00:02:01,829 --> 00:02:06,570
of those Linux heart Microsoft loves

00:02:04,170 --> 00:02:08,910
Linux t-shirts and sent it to Steve

00:02:06,570 --> 00:02:11,149
Ballmer because I'd love to see him rock

00:02:08,910 --> 00:02:11,149
that

00:02:11,150 --> 00:02:16,650
Microsoft loves open-source to me this

00:02:14,730 --> 00:02:18,390
is obviously another massive pivot but

00:02:16,650 --> 00:02:20,280
to me this is even bigger more

00:02:18,390 --> 00:02:23,700
significant than the Linux thing a

00:02:20,280 --> 00:02:27,030
previous incarnation of Microsoft viewed

00:02:23,700 --> 00:02:28,560
open-source as competition in fact there

00:02:27,030 --> 00:02:31,380
were probably times that they

00:02:28,560 --> 00:02:34,650
deliberately tried to put open-source

00:02:31,380 --> 00:02:37,350
out of business so the fact that they're

00:02:34,650 --> 00:02:39,150
moving towards this model of embracing

00:02:37,350 --> 00:02:42,390
the open-source community is something

00:02:39,150 --> 00:02:45,360
very significant and as an example of

00:02:42,390 --> 00:02:47,760
that dotnet itself is now open-source

00:02:45,360 --> 00:02:49,920
it's managed by the dotnet foundation

00:02:47,760 --> 00:02:52,320
which aims to cultivate and foster a

00:02:49,920 --> 00:02:55,560
community around net it includes the

00:02:52,320 --> 00:02:58,200
dotnet framework rosalind xamarin mono

00:02:55,560 --> 00:03:00,930
plus all sorts of community projects and

00:02:58,200 --> 00:03:04,410
then more recently it includes dotnet

00:03:00,930 --> 00:03:06,540
core which is a new cross-platform set

00:03:04,410 --> 00:03:09,720
of runtimes and frameworks that runs on

00:03:06,540 --> 00:03:14,880
Windows it runs on Linux it runs on Mac

00:03:09,720 --> 00:03:17,190
OS and of course Visual Studio had to

00:03:14,880 --> 00:03:20,100
get in on the lovefest there's a

00:03:17,190 --> 00:03:22,800
full-blown Visual Studio IDE now for Mac

00:03:20,100 --> 00:03:24,630
OS and they've come out with a new

00:03:22,800 --> 00:03:30,450
lightweight editor called Visual Studio

00:03:24,630 --> 00:03:33,840
code it runs on Mac Linux Windows but

00:03:30,450 --> 00:03:36,750
wait that's not all sequel server now

00:03:33,840 --> 00:03:40,130
runs on Linux Wow

00:03:36,750 --> 00:03:42,890
look at that look at all those hearts

00:03:40,130 --> 00:03:45,180
what are we meant to take away from this

00:03:42,890 --> 00:03:47,550
does anybody remember when you were in

00:03:45,180 --> 00:03:50,310
school and you wrote your name and maybe

00:03:47,550 --> 00:03:52,440
somebody else's name on a piece of paper

00:03:50,310 --> 00:03:54,000
with a heart in between or maybe you

00:03:52,440 --> 00:03:56,489
were you're really serious and you

00:03:54,000 --> 00:03:59,310
carved it into the a tree trunk or wrote

00:03:56,489 --> 00:04:03,290
it in wet cement so what are we supposed

00:03:59,310 --> 00:04:06,180
to take away from all these hearts

00:04:03,290 --> 00:04:10,860
Microsoft must be getting really serious

00:04:06,180 --> 00:04:13,590
about this stuff all right so what's all

00:04:10,860 --> 00:04:15,870
this about a dotnet Renaissance at the

00:04:13,590 --> 00:04:18,770
NDC conference in Oslo this summer

00:04:15,870 --> 00:04:21,299
Ian Cooper called out the Java

00:04:18,770 --> 00:04:23,699
rejuvenation Renaissance

00:04:21,299 --> 00:04:26,490
five or six years ago and drew some

00:04:23,699 --> 00:04:28,800
parallels and said that we can we can

00:04:26,490 --> 00:04:30,960
draw some conclusions from that that

00:04:28,800 --> 00:04:32,669
dotnet is in the same place so basically

00:04:30,960 --> 00:04:35,759
he said we're at one point you were

00:04:32,669 --> 00:04:38,250
seeing the JVM lose ground to Ruby and

00:04:35,759 --> 00:04:40,110
rails as more developers started turning

00:04:38,250 --> 00:04:43,139
towards that low-friction

00:04:40,110 --> 00:04:46,069
web development experience and away from

00:04:43,139 --> 00:04:48,900
the heavy-duty enterprise app servers

00:04:46,069 --> 00:04:51,270
suddenly there was this you know

00:04:48,900 --> 00:04:53,460
Renaissance of projects like Neddie and

00:04:51,270 --> 00:04:56,250
like the Spring Framework and and even

00:04:53,460 --> 00:04:59,310
Netflix OSS where there was a rich

00:04:56,250 --> 00:05:02,069
community of projects around cloud

00:04:59,310 --> 00:05:04,740
native and 12 factor and micro services

00:05:02,069 --> 00:05:08,210
and and right now we're on the verge of

00:05:04,740 --> 00:05:12,210
such a renaissance in the dotnet world

00:05:08,210 --> 00:05:15,030
so the dotnet by comparison dotnet had

00:05:12,210 --> 00:05:17,639
its 15th birthday this year whereas Java

00:05:15,030 --> 00:05:19,319
is closer to 20 years old so maybe you

00:05:17,639 --> 00:05:23,250
know in the terms of the timeframe were

00:05:19,319 --> 00:05:25,949
around the same timing you know with the

00:05:23,250 --> 00:05:28,770
introduction of dotnet core given

00:05:25,949 --> 00:05:30,810
Microsoft's pivot towards open source we

00:05:28,770 --> 00:05:32,789
are really turning to a point where

00:05:30,810 --> 00:05:35,099
dotnet is on the verge of this massive

00:05:32,789 --> 00:05:36,779
renaissance so what's missing well

00:05:35,099 --> 00:05:40,500
what's been missing at least until very

00:05:36,779 --> 00:05:43,169
recently is that rich community of cloud

00:05:40,500 --> 00:05:45,779
native 12 factor micro services projects

00:05:43,169 --> 00:05:46,770
and that's where Steel Toe comes in and

00:05:45,779 --> 00:05:49,289
that's what we're going to talk to you

00:05:46,770 --> 00:05:52,620
about today you want to tell us what

00:05:49,289 --> 00:05:54,719
Steel Toe is met perfect so Steel Toe is

00:05:52,620 --> 00:05:57,090
an open source project sponsored by

00:05:54,719 --> 00:06:00,590
pivotal that brings client libraries for

00:05:57,090 --> 00:06:02,849
spring cloud and Netflix OSS to dotnet

00:06:00,590 --> 00:06:04,740
it also provides tooling that makes it

00:06:02,849 --> 00:06:06,690
easy to deploy and run dotnet

00:06:04,740 --> 00:06:10,919
applications on cloud foundry and

00:06:06,690 --> 00:06:13,319
leverage cloud foundry services so

00:06:10,919 --> 00:06:16,139
before we talk about what's in Steel Toe

00:06:13,319 --> 00:06:21,990
let's talk about why we built it so why

00:06:16,139 --> 00:06:24,479
is Steel Toe if you're building cloud

00:06:21,990 --> 00:06:27,060
native dotnet applications specifically

00:06:24,479 --> 00:06:30,120
to run on Cloud Foundry you're going to

00:06:27,060 --> 00:06:32,009
be embracing 12 factor principles so you

00:06:30,120 --> 00:06:34,050
want to move away from just having

00:06:32,009 --> 00:06:34,689
random application dependencies in your

00:06:34,050 --> 00:06:37,059
codebase

00:06:34,689 --> 00:06:39,069
and like just checking binary blobs into

00:06:37,059 --> 00:06:42,129
your code move to something like nougat

00:06:39,069 --> 00:06:45,339
for storing those dependency references

00:06:42,129 --> 00:06:47,369
right story and configuration in the

00:06:45,339 --> 00:06:50,860
environment so instead of hard-coding

00:06:47,369 --> 00:06:52,269
database strings and other settings into

00:06:50,860 --> 00:06:53,529
your code base and then checking that in

00:06:52,269 --> 00:06:55,959
and shipping around a password to

00:06:53,529 --> 00:06:58,289
everyone you want to move that into

00:06:55,959 --> 00:07:01,360
something like a configuration server

00:06:58,289 --> 00:07:03,879
you don't want to be storing session

00:07:01,360 --> 00:07:05,769
state in your process how do you scale

00:07:03,879 --> 00:07:07,959
horizontally an application that just

00:07:05,769 --> 00:07:10,360
stores that session state and memory

00:07:07,959 --> 00:07:12,219
then you do things like J session ID and

00:07:10,360 --> 00:07:15,369
session pinning right that's not a great

00:07:12,219 --> 00:07:17,259
way to scale out your application you

00:07:15,369 --> 00:07:19,179
need to break down tight coupling

00:07:17,259 --> 00:07:21,159
between your application and the server

00:07:19,179 --> 00:07:22,749
it's running on guess what for dotnet

00:07:21,159 --> 00:07:24,849
that means you can't use the Windows

00:07:22,749 --> 00:07:27,969
registry you don't want to use the

00:07:24,849 --> 00:07:28,959
global assembly cache the GAC you don't

00:07:27,969 --> 00:07:30,759
want to write things to the local

00:07:28,959 --> 00:07:32,919
filesystem and rely on them being there

00:07:30,759 --> 00:07:35,499
they won't be there when you scale up or

00:07:32,919 --> 00:07:37,809
down your instance right and when you're

00:07:35,499 --> 00:07:39,639
using a datastore like maybe a

00:07:37,809 --> 00:07:42,189
relational database you need to loosely

00:07:39,639 --> 00:07:44,079
couple your application to that again

00:07:42,189 --> 00:07:45,849
just like configuration you've got to

00:07:44,079 --> 00:07:47,949
find a way to inject that into the

00:07:45,849 --> 00:07:50,709
application and then swap it out based

00:07:47,949 --> 00:07:52,360
on while are you in dev test or prod and

00:07:50,709 --> 00:07:53,729
your locally are you working on Cloud

00:07:52,360 --> 00:07:56,319
Foundry

00:07:53,729 --> 00:07:58,419
Sam Scott is saying today's best

00:07:56,319 --> 00:08:01,149
practices are tomorrow's anti-patterns

00:07:58,419 --> 00:08:04,179
of course that means yesterday's best

00:08:01,149 --> 00:08:09,129
practices are today is anti-patterns

00:08:04,179 --> 00:08:10,899
right so you know what this means right

00:08:09,129 --> 00:08:13,209
is there may have been things that you

00:08:10,899 --> 00:08:15,489
did five years ago and dotnet that made

00:08:13,209 --> 00:08:19,209
a lot of sense and it worked really well

00:08:15,489 --> 00:08:20,619
and that was fantastic but today as

00:08:19,209 --> 00:08:22,300
you're embracing something like quad

00:08:20,619 --> 00:08:25,289
foundry and you're trying to scale out

00:08:22,300 --> 00:08:27,459
your application and it and modernize it

00:08:25,289 --> 00:08:29,499
maybe some of those decisions are

00:08:27,459 --> 00:08:34,289
interfering with application resiliency

00:08:29,499 --> 00:08:34,289
or scalability and so you need to reset

00:08:35,760 --> 00:08:40,560
second well you can't you can't go to a

00:08:38,690 --> 00:08:43,290
technology conference and not hear about

00:08:40,560 --> 00:08:44,820
microservices right so I promise you

00:08:43,290 --> 00:08:46,860
we'll talk about micro services

00:08:44,820 --> 00:08:49,350
micro services allow developers to

00:08:46,860 --> 00:08:52,260
quickly iterate on small components and

00:08:49,350 --> 00:08:54,150
divide up responsibilities what you get

00:08:52,260 --> 00:08:56,400
out of this is being able to onboard

00:08:54,150 --> 00:08:59,310
developers to a project more quickly

00:08:56,400 --> 00:09:01,740
when you've broken down gigantic

00:08:59,310 --> 00:09:04,290
application into component pieces you

00:09:01,740 --> 00:09:06,330
can onboard a developer to one part of

00:09:04,290 --> 00:09:07,920
the system will show you a demo

00:09:06,330 --> 00:09:10,050
application where it's broken up into

00:09:07,920 --> 00:09:11,820
four components and you have somebody

00:09:10,050 --> 00:09:13,260
working on the front end and somebody

00:09:11,820 --> 00:09:17,550
working on one of three back-end

00:09:13,260 --> 00:09:19,620
services you can quickly iterate on your

00:09:17,550 --> 00:09:21,840
on your test cycle so instead of waiting

00:09:19,620 --> 00:09:24,390
for the entire integration test suite to

00:09:21,840 --> 00:09:26,460
pass and then wasting a lot of cycles

00:09:24,390 --> 00:09:28,590
there you could just run unit tests

00:09:26,460 --> 00:09:30,540
they're concentrated on the piece of

00:09:28,590 --> 00:09:31,860
code that you're iterating on and then

00:09:30,540 --> 00:09:34,620
you can come together at the end to just

00:09:31,860 --> 00:09:39,480
run a full suite of happy path tests

00:09:34,620 --> 00:09:41,610
right you can also choose the right

00:09:39,480 --> 00:09:44,520
language to solve a problem you can do

00:09:41,610 --> 00:09:46,590
this polyglot architecture and so say

00:09:44,520 --> 00:09:50,040
you have an application that needs to

00:09:46,590 --> 00:09:52,830
run on the desktop done at CLR right

00:09:50,040 --> 00:09:54,270
requires Windows for some reason but

00:09:52,830 --> 00:09:56,120
then you you're trying to save your

00:09:54,270 --> 00:09:59,640
company money and you also want to use

00:09:56,120 --> 00:10:01,440
Linux to run some of that application so

00:09:59,640 --> 00:10:03,240
why don't you split up your micro

00:10:01,440 --> 00:10:05,970
service so that that back end that needs

00:10:03,240 --> 00:10:08,340
access to Windows well that runs just

00:10:05,970 --> 00:10:10,800
fine on the desk desktop CLR with

00:10:08,340 --> 00:10:12,690
Windows support even Claude foundry and

00:10:10,800 --> 00:10:14,100
then everything else runs on Linux maybe

00:10:12,690 --> 00:10:15,930
you write an ode app maybe you write a

00:10:14,100 --> 00:10:19,950
dot in that core app you can mix and

00:10:15,930 --> 00:10:22,050
match as as you see fit you can also

00:10:19,950 --> 00:10:22,380
scale components independently of each

00:10:22,050 --> 00:10:24,510
other

00:10:22,380 --> 00:10:25,560
so if you need to scale up your front

00:10:24,510 --> 00:10:28,110
end because you're getting a lot of

00:10:25,560 --> 00:10:29,610
traffic you scale that up you can scale

00:10:28,110 --> 00:10:31,800
it down you can scale up your back-end

00:10:29,610 --> 00:10:34,320
all independently of each other right so

00:10:31,800 --> 00:10:36,840
maker services bring some great benefits

00:10:34,320 --> 00:10:41,160
to the table they also have some

00:10:36,840 --> 00:10:43,620
challenges so micro services by

00:10:41,160 --> 00:10:45,750
definition our distributed system right

00:10:43,620 --> 00:10:48,200
so there's a ton of complexity

00:10:45,750 --> 00:10:50,330
underneath there

00:10:48,200 --> 00:10:52,100
what if you're trying to find a bug in

00:10:50,330 --> 00:10:54,020
your application well if it's a monolith

00:10:52,100 --> 00:10:55,910
right the bug is probably in that

00:10:54,020 --> 00:10:58,100
gigantic codebase so you know where it

00:10:55,910 --> 00:11:01,070
is go and find it no problem

00:10:58,100 --> 00:11:03,770
but troubleshooting a micro service or

00:11:01,070 --> 00:11:06,380
set of micro services is kind of like

00:11:03,770 --> 00:11:10,760
solving a murder mystery so if you're

00:11:06,380 --> 00:11:12,980
into that it's great it's also really

00:11:10,760 --> 00:11:14,720
easy to set global configuration and

00:11:12,980 --> 00:11:16,640
read it from anywhere in a monolith

00:11:14,720 --> 00:11:18,740
right you have one giant code base you

00:11:16,640 --> 00:11:20,540
throw it in some I don't know what about

00:11:18,740 --> 00:11:22,520
a kid's like these days XML JSON

00:11:20,540 --> 00:11:26,060
something like that and it's everywhere

00:11:22,520 --> 00:11:26,870
right so in a monolith that's easy how

00:11:26,060 --> 00:11:30,770
do you do that

00:11:26,870 --> 00:11:32,570
in all these tiny microservices how do

00:11:30,770 --> 00:11:34,280
you get all that configuration out to to

00:11:32,570 --> 00:11:36,080
every single one of those right copying

00:11:34,280 --> 00:11:38,270
an XML file and checking it into a bunch

00:11:36,080 --> 00:11:39,170
of code bases is not really a good way

00:11:38,270 --> 00:11:40,970
to solve that problem

00:11:39,170 --> 00:11:42,290
what if those microservices are in a

00:11:40,970 --> 00:11:44,030
bunch of different languages written in

00:11:42,290 --> 00:11:46,250
different languages right maybe one of

00:11:44,030 --> 00:11:49,490
them doesn't have a JSON parser I don't

00:11:46,250 --> 00:11:51,380
know if a microservice you depend on is

00:11:49,490 --> 00:11:54,560
running at this horizontal scale right

00:11:51,380 --> 00:11:56,840
and dynamically scaling up and down how

00:11:54,560 --> 00:12:00,230
do you find healthy instances and only

00:11:56,840 --> 00:12:02,210
route traffic to those right and if you

00:12:00,230 --> 00:12:03,560
have all these instances that are

00:12:02,210 --> 00:12:06,200
scaling up and down and one of them

00:12:03,560 --> 00:12:08,480
becomes unhealthy how do you handle that

00:12:06,200 --> 00:12:12,740
what do you do we're gonna know instance

00:12:08,480 --> 00:12:14,690
goes offline well the good news is our

00:12:12,740 --> 00:12:15,590
friends at Netflix already solved a lot

00:12:14,690 --> 00:12:17,180
of these problems

00:12:15,590 --> 00:12:19,610
however they solved a lot of these

00:12:17,180 --> 00:12:22,580
problems specifically for their

00:12:19,610 --> 00:12:25,220
deployment on AWS but the spring team

00:12:22,580 --> 00:12:27,920
which pivotal contributes a number of

00:12:25,220 --> 00:12:30,560
developers towards has been working on

00:12:27,920 --> 00:12:32,650
making generic implementations for a lot

00:12:30,560 --> 00:12:35,060
of this frame cloud open source

00:12:32,650 --> 00:12:37,820
libraries for the java programming

00:12:35,060 --> 00:12:41,060
language but wait a minute how does that

00:12:37,820 --> 00:12:42,520
help dotnet developers well that's why

00:12:41,060 --> 00:12:46,040
we're here

00:12:42,520 --> 00:12:48,170
steel-toe was built to help you build

00:12:46,040 --> 00:12:49,790
cloud native dotnet applications and

00:12:48,170 --> 00:12:52,520
leverage spring cloud tooling for

00:12:49,790 --> 00:12:56,730
resilient microservices check out all

00:12:52,520 --> 00:12:59,670
those buzzwords cool

00:12:56,730 --> 00:13:04,530
all right so let's talk about what's

00:12:59,670 --> 00:13:06,030
inside the box first a look at the

00:13:04,530 --> 00:13:08,070
components in Steel Toe that are geared

00:13:06,030 --> 00:13:09,990
towards a building cloud native done net

00:13:08,070 --> 00:13:13,140
micro-services building applications

00:13:09,990 --> 00:13:15,450
that run on Cloud Foundry so steel toe

00:13:13,140 --> 00:13:18,210
connectors they simplify the process of

00:13:15,450 --> 00:13:21,080
connecting to and using backing data

00:13:18,210 --> 00:13:26,430
services on Cloud Foundry things like

00:13:21,080 --> 00:13:27,960
MySQL Postgres RabbitMQ ooofff - they

00:13:26,430 --> 00:13:30,030
provide out of the sort out-of-the-box

00:13:27,960 --> 00:13:31,830
support for discovering many of those

00:13:30,030 --> 00:13:34,470
services as long as they're bound to

00:13:31,830 --> 00:13:35,970
your application and they also include

00:13:34,470 --> 00:13:38,610
the ability to do settings based

00:13:35,970 --> 00:13:41,100
configuration so that developers can

00:13:38,610 --> 00:13:43,320
supply configuration settings at

00:13:41,100 --> 00:13:45,360
development time you know for they're on

00:13:43,320 --> 00:13:46,500
their local system and then have them

00:13:45,360 --> 00:13:50,790
overridden when you push your

00:13:46,500 --> 00:13:52,680
application to Cloud Foundry steel-toe

00:13:50,790 --> 00:13:54,630
also includes a number of security

00:13:52,680 --> 00:13:57,060
related services so that you can

00:13:54,630 --> 00:14:01,020
simplify things like using oauth2

00:13:57,060 --> 00:14:04,320
based UA a or pivotal SSO on your

00:14:01,020 --> 00:14:07,190
application accessing JWT protected

00:14:04,320 --> 00:14:09,540
resources like the cloud controller API

00:14:07,190 --> 00:14:12,330
additionally steel-toe makes available

00:14:09,540 --> 00:14:16,500
an additional security provider the

00:14:12,330 --> 00:14:19,440
asp.net core data protection library

00:14:16,500 --> 00:14:20,880
includes a keyring store but the way

00:14:19,440 --> 00:14:23,190
that they've implemented it by default

00:14:20,880 --> 00:14:25,500
it writes the keyring to the local disk

00:14:23,190 --> 00:14:28,350
since that not that's not a very cloud

00:14:25,500 --> 00:14:31,410
native pattern what the steel-toe

00:14:28,350 --> 00:14:33,360
project does is it makes available way

00:14:31,410 --> 00:14:36,600
for you to override that configuration

00:14:33,360 --> 00:14:42,270
and write those key rings to a Cloud

00:14:36,600 --> 00:14:43,560
Foundry hosted Redis instance steel-toe

00:14:42,270 --> 00:14:45,900
also helps you manage and troubleshoot

00:14:43,560 --> 00:14:47,730
your micro service by ornamenting it

00:14:45,900 --> 00:14:50,040
with a set of standard management

00:14:47,730 --> 00:14:52,740
endpoints these were inspired by the

00:14:50,040 --> 00:14:54,990
actuator library and spring boot they're

00:14:52,740 --> 00:14:56,040
non-invasive so you can get visibility

00:14:54,990 --> 00:14:57,960
to the problems where they're actually

00:14:56,040 --> 00:15:00,570
occurring even if that's in production

00:14:57,960 --> 00:15:03,390
and you can access them on an instance

00:15:00,570 --> 00:15:04,890
by instance basis for your micro service

00:15:03,390 --> 00:15:07,440
if you're if your micro service is

00:15:04,890 --> 00:15:09,950
running at horizontal scale so they

00:15:07,440 --> 00:15:11,660
include info so this is a

00:15:09,950 --> 00:15:13,550
information endpoint it includes agate

00:15:11,660 --> 00:15:16,130
hash so if you're trying to solve that

00:15:13,550 --> 00:15:17,930
problem of figuring out the running

00:15:16,130 --> 00:15:19,790
instance of your application which

00:15:17,930 --> 00:15:22,700
commit does it actually correspond to

00:15:19,790 --> 00:15:24,980
and in in your git repo then it makes

00:15:22,700 --> 00:15:27,320
that a lot easier there's a health

00:15:24,980 --> 00:15:29,840
endpoint to see health information about

00:15:27,320 --> 00:15:34,100
your application a trace endpoint that

00:15:29,840 --> 00:15:37,610
returns the last 100 HTTP requests and

00:15:34,100 --> 00:15:40,370
responses and then the most powerful is

00:15:37,610 --> 00:15:43,280
the loggers endpoint so this allows you

00:15:40,370 --> 00:15:46,240
to both see and configure in real time

00:15:43,280 --> 00:15:48,620
the logging levels of your application

00:15:46,240 --> 00:15:50,600
as I said on an instance by instance

00:15:48,620 --> 00:15:52,730
basis all the way down to the class

00:15:50,600 --> 00:15:55,330
level in your application so it's

00:15:52,730 --> 00:15:55,330
extremely powerful

00:15:55,850 --> 00:16:01,670
all right so steel-toe also includes

00:15:58,880 --> 00:16:04,850
configuration providers there's this

00:16:01,670 --> 00:16:06,320
dotnet configuration API it enables you

00:16:04,850 --> 00:16:08,720
to pull configuration data from a

00:16:06,320 --> 00:16:10,670
variety of sources it loads it into a

00:16:08,720 --> 00:16:12,950
hierarchical dictionary of key value

00:16:10,670 --> 00:16:15,170
pairs that you can then access inside of

00:16:12,950 --> 00:16:16,790
your application out-of-the-box dotnet

00:16:15,170 --> 00:16:20,000
gives you things like command line

00:16:16,790 --> 00:16:23,270
arguments and file sources like JSON

00:16:20,000 --> 00:16:25,850
files or even XML or dot ini files

00:16:23,270 --> 00:16:28,580
heaven forbid and environment variables

00:16:25,850 --> 00:16:30,470
but steel-toe adds to custom providers

00:16:28,580 --> 00:16:33,470
to that list so the first is a Cloud

00:16:30,470 --> 00:16:34,820
Foundry provider it it parses the

00:16:33,470 --> 00:16:36,170
standard Cloud Foundry environment

00:16:34,820 --> 00:16:39,050
variables and then makes them available

00:16:36,170 --> 00:16:41,120
to you as configuration data from inside

00:16:39,050 --> 00:16:44,000
your application and then the config

00:16:41,120 --> 00:16:46,220
server provider it enables the spring

00:16:44,000 --> 00:16:49,100
cloud config server to be used as a

00:16:46,220 --> 00:16:50,630
config data source so what does that

00:16:49,100 --> 00:16:53,420
mean what does spring cloud config

00:16:50,630 --> 00:16:55,010
server according to the 12 facto

00:16:53,420 --> 00:16:56,630
principles you're supposed to separate

00:16:55,010 --> 00:16:59,240
your configuration from your application

00:16:56,630 --> 00:17:01,190
code definitely whatever you do don't

00:16:59,240 --> 00:17:03,080
check your connection strings or other

00:17:01,190 --> 00:17:05,720
app secrets into your source control

00:17:03,080 --> 00:17:08,000
repo but that begs the question well

00:17:05,720 --> 00:17:09,800
where do you put them in spring cloud

00:17:08,000 --> 00:17:11,720
config server is a service that gives

00:17:09,800 --> 00:17:13,270
you a central place to manage your

00:17:11,720 --> 00:17:16,250
applications configuration values

00:17:13,270 --> 00:17:18,920
externally and then read read them in at

00:17:16,250 --> 00:17:20,930
runtime so the way it works is you push

00:17:18,920 --> 00:17:23,600
your configuration could be stored in Y

00:17:20,930 --> 00:17:25,789
amyl files for example into a git repo

00:17:23,600 --> 00:17:26,959
it also supports hashey Corp vaults as a

00:17:25,789 --> 00:17:29,510
back-end if you want to store

00:17:26,959 --> 00:17:31,010
application secrets in there and then

00:17:29,510 --> 00:17:33,590
all of the changes to config are

00:17:31,010 --> 00:17:35,419
versioned there auditable then when your

00:17:33,590 --> 00:17:37,250
app comes online it pulls the latest

00:17:35,419 --> 00:17:40,250
convicted config values from the server

00:17:37,250 --> 00:17:42,410
it's also possible to call an endpoint

00:17:40,250 --> 00:17:44,750
on your application that tells it to

00:17:42,410 --> 00:17:46,429
refresh configuration without having to

00:17:44,750 --> 00:17:48,740
stop and restart your application so

00:17:46,429 --> 00:17:54,710
there you can refresh config without any

00:17:48,740 --> 00:17:57,260
application downtime all right service

00:17:54,710 --> 00:17:59,360
discovery service discovery is a pattern

00:17:57,260 --> 00:18:02,270
that allows you to dynamically bind at

00:17:59,360 --> 00:18:04,789
runtime to micro services that your app

00:18:02,270 --> 00:18:07,000
depends on this is valuable when those

00:18:04,789 --> 00:18:09,679
services are running a horizontal scale

00:18:07,000 --> 00:18:12,470
adding and subtracting instances and

00:18:09,679 --> 00:18:14,929
constantly changing addresses especially

00:18:12,470 --> 00:18:16,880
if those services are they that you're

00:18:14,929 --> 00:18:18,950
calling they live before hind a firewall

00:18:16,880 --> 00:18:21,500
and they aren't publicly addressable so

00:18:18,950 --> 00:18:23,900
you can't rely on dns steel-toe

00:18:21,500 --> 00:18:26,659
implements Netflix Eureka for service

00:18:23,900 --> 00:18:29,960
discovery and the pattern works like

00:18:26,659 --> 00:18:33,740
this micro service register themselves

00:18:29,960 --> 00:18:35,570
when they come online and whether that's

00:18:33,740 --> 00:18:37,460
because they're just been deployed or

00:18:35,570 --> 00:18:39,830
they're scaling out and in and then the

00:18:37,460 --> 00:18:41,390
Eureka server periodically checks in to

00:18:39,830 --> 00:18:43,010
make sure they're still alive and keeps

00:18:41,390 --> 00:18:46,130
its server list up-to-date with healthy

00:18:43,010 --> 00:18:47,809
instances when a consumer comes online

00:18:46,130 --> 00:18:49,789
wants to consume one of those micro

00:18:47,809 --> 00:18:51,500
services it first pulls the server list

00:18:49,789 --> 00:18:54,080
from the Eureka server and then gets

00:18:51,500 --> 00:18:56,630
periodic updates confirming the the

00:18:54,080 --> 00:18:58,220
current state then your application can

00:18:56,630 --> 00:19:00,710
make calls to the micro services it

00:18:58,220 --> 00:19:02,630
depends on even when their ephemeral

00:19:00,710 --> 00:19:05,720
dynamically addressed scaling in and out

00:19:02,630 --> 00:19:08,240
etc it's built to BHA so that if the

00:19:05,720 --> 00:19:10,400
Eureka server goes offline you the

00:19:08,240 --> 00:19:12,409
client keeps a your application keeps a

00:19:10,400 --> 00:19:14,000
cached copy of that list it's able to

00:19:12,409 --> 00:19:19,480
continue to use it until eureka server

00:19:14,000 --> 00:19:22,390
is self healed and comes back up and now

00:19:19,480 --> 00:19:24,860
histor --ax circuit breakers so

00:19:22,390 --> 00:19:26,929
steel-toe includes a full dotnet

00:19:24,860 --> 00:19:29,059
implementation of netflix historic

00:19:26,929 --> 00:19:31,700
circuit breaker it allows your

00:19:29,059 --> 00:19:33,140
application to fail gracefully even when

00:19:31,700 --> 00:19:35,780
a dependent micro service becomes

00:19:33,140 --> 00:19:36,490
unavailable so your users never ever

00:19:35,780 --> 00:19:39,160
have to see

00:19:36,490 --> 00:19:41,470
nasty error message history also

00:19:39,160 --> 00:19:43,870
includes rich metrics as well as a

00:19:41,470 --> 00:19:46,990
dashboard to visualize the status across

00:19:43,870 --> 00:19:48,580
all your micro services so a little bit

00:19:46,990 --> 00:19:50,620
more about how it works this is a quick

00:19:48,580 --> 00:19:52,420
high-level overview as long as the

00:19:50,620 --> 00:19:54,340
dependent service that you're you're

00:19:52,420 --> 00:19:56,350
calling remains healthy the circuit

00:19:54,340 --> 00:19:58,720
breaker remains closed and all calls are

00:19:56,350 --> 00:20:00,520
passed through when a failure threshold

00:19:58,720 --> 00:20:03,400
is reached however the circuit breaker

00:20:00,520 --> 00:20:07,000
opens up and falls back to a default

00:20:03,400 --> 00:20:09,730
response or data set a default fallback

00:20:07,000 --> 00:20:11,590
behavior so and that gives the service

00:20:09,730 --> 00:20:13,720
time to recover so it stops sending

00:20:11,590 --> 00:20:16,210
requests to that service so that it can

00:20:13,720 --> 00:20:18,490
self heal and come back online every so

00:20:16,210 --> 00:20:20,440
often the circuit breaker will switch to

00:20:18,490 --> 00:20:21,940
a half-open state where it allows a

00:20:20,440 --> 00:20:23,860
request to go through to check the

00:20:21,940 --> 00:20:25,540
status of that service if the call

00:20:23,860 --> 00:20:33,220
succeeds then the circuit breaker goes

00:20:25,540 --> 00:20:35,350
back to closed ok so just generally

00:20:33,220 --> 00:20:38,830
speaking steel-toe works both with done

00:20:35,350 --> 00:20:40,330
at core this new Linux or cross-platform

00:20:38,830 --> 00:20:42,670
runtime as well as dotnet framework

00:20:40,330 --> 00:20:44,770
works both on Windows and Linux that

00:20:42,670 --> 00:20:49,240
works standalone and it works running on

00:20:44,770 --> 00:20:51,100
Cloud Foundry of course all right well

00:20:49,240 --> 00:20:56,350
having said that let's let's take a look

00:20:51,100 --> 00:20:57,760
at a demo Matt you want to show us so

00:20:56,350 --> 00:20:59,380
just walk through a quick set of

00:20:57,760 --> 00:21:01,030
architecture slides to talk about what

00:20:59,380 --> 00:21:06,340
the demo is doing and then we'll show

00:21:01,030 --> 00:21:08,140
you how this works so we took the music

00:21:06,340 --> 00:21:11,230
store reference application from the

00:21:08,140 --> 00:21:14,260
dotnet community this application is

00:21:11,230 --> 00:21:17,530
known for exercising the entity

00:21:14,260 --> 00:21:19,630
framework and asp.net core it's a

00:21:17,530 --> 00:21:22,420
monolithic application so everything's

00:21:19,630 --> 00:21:24,429
just in one giant codebase and there's

00:21:22,420 --> 00:21:26,020
it's just a sample app you can go to it

00:21:24,429 --> 00:21:28,630
you put some stuff in a shopping cart

00:21:26,020 --> 00:21:33,160
and you can check out there's a library

00:21:28,630 --> 00:21:36,400
of available albums and then that's

00:21:33,160 --> 00:21:38,320
pretty much the gist we broke that down

00:21:36,400 --> 00:21:40,210
into multiple micro services that

00:21:38,320 --> 00:21:42,100
correspond to different business

00:21:40,210 --> 00:21:44,050
functions and so there's a music UI

00:21:42,100 --> 00:21:46,660
which is just the front-end the music

00:21:44,050 --> 00:21:48,460
store which is that library of albums

00:21:46,660 --> 00:21:49,710
that are available the shopping cart

00:21:48,460 --> 00:21:51,480
service which can

00:21:49,710 --> 00:21:53,760
hold the things that you're looking at

00:21:51,480 --> 00:21:56,330
purchasing and an order processing

00:21:53,760 --> 00:21:58,860
service where you can actually check out

00:21:56,330 --> 00:22:01,380
this is all implemented using the proxy

00:21:58,860 --> 00:22:03,809
micro service design pattern and a

00:22:01,380 --> 00:22:06,179
single application that music UI calls

00:22:03,809 --> 00:22:08,700
out to each of these different back-end

00:22:06,179 --> 00:22:12,000
services to perform the related business

00:22:08,700 --> 00:22:14,370
functions there's also a Redis cash for

00:22:12,000 --> 00:22:16,380
application session state to allow that

00:22:14,370 --> 00:22:21,630
music UI to scale out to multiple

00:22:16,380 --> 00:22:23,610
instances the application config is

00:22:21,630 --> 00:22:26,429
stored in the spring cloud config server

00:22:23,610 --> 00:22:28,529
so this allows all those micro services

00:22:26,429 --> 00:22:30,690
to know what they need to do and how to

00:22:28,529 --> 00:22:33,510
do it without having that hard-coded in

00:22:30,690 --> 00:22:34,350
the configuration the configuration

00:22:33,510 --> 00:22:37,559
provider

00:22:34,350 --> 00:22:39,960
automatically injects the connection for

00:22:37,559 --> 00:22:44,820
the spring cloud config server into

00:22:39,960 --> 00:22:46,649
those micro services then we utilize

00:22:44,820 --> 00:22:48,720
steel-toe connectors connectors

00:22:46,649 --> 00:22:50,399
automatically detect the back-end

00:22:48,720 --> 00:22:52,830
services that each of these instances

00:22:50,399 --> 00:22:55,320
have been deployed with and configures

00:22:52,830 --> 00:22:57,390
the connections to them and so instead

00:22:55,320 --> 00:22:59,250
of having to hard-code your my sequel or

00:22:57,390 --> 00:23:01,559
Redis connection string into your

00:22:59,250 --> 00:23:03,419
application the connectors connectors

00:23:01,559 --> 00:23:05,490
automatically instantiate the libraries

00:23:03,419 --> 00:23:10,169
and connect your application to those

00:23:05,490 --> 00:23:12,510
data stores service discovery is

00:23:10,169 --> 00:23:14,490
implemented using eureka so when each of

00:23:12,510 --> 00:23:16,559
the backend stores the music store of

00:23:14,490 --> 00:23:18,510
the shopping cart and the order

00:23:16,559 --> 00:23:19,980
processing service come online they

00:23:18,510 --> 00:23:22,799
register themselves with the eureka

00:23:19,980 --> 00:23:24,539
server then the music ula service

00:23:22,799 --> 00:23:27,240
reaches out to the eureka server and

00:23:24,539 --> 00:23:31,169
says hey where's the music store ok and

00:23:27,240 --> 00:23:33,270
that gets back the URI for that and you

00:23:31,169 --> 00:23:35,190
could use a standard dotnet HTTP library

00:23:33,270 --> 00:23:40,169
to call out to them so it's all

00:23:35,190 --> 00:23:42,179
relatively seamless finally we decorated

00:23:40,169 --> 00:23:45,059
the micro services with some management

00:23:42,179 --> 00:23:47,070
endpoints to make them easier to

00:23:45,059 --> 00:23:49,500
troubleshoot so you could turn up or

00:23:47,070 --> 00:23:52,080
down that logging you can get the health

00:23:49,500 --> 00:23:53,789
check you could see the get sha that was

00:23:52,080 --> 00:23:55,169
actually deployed and where my home

00:23:53,789 --> 00:24:00,200
directory is when I deployed the

00:23:55,169 --> 00:24:10,070
application so let's pull this up

00:24:00,200 --> 00:24:11,330
I need you to login Zack you're gonna

00:24:10,070 --> 00:24:21,159
have to drag it over to the other screen

00:24:11,330 --> 00:24:21,159
cool all right that's visible

00:24:29,030 --> 00:24:33,320
all right so this is the sample app if

00:24:31,610 --> 00:24:34,760
you had just deployed that reference app

00:24:33,320 --> 00:24:36,530
it would look exactly like this we

00:24:34,760 --> 00:24:39,110
changed nothing with the UI except for

00:24:36,530 --> 00:24:41,270
breaking up the back-end services so

00:24:39,110 --> 00:24:44,270
here all the album's that are available

00:24:41,270 --> 00:24:49,280
for purchase and we can even drill in

00:24:44,270 --> 00:24:51,440
further to a specific type of music so I

00:24:49,280 --> 00:24:55,070
can go ahead and and add this to the

00:24:51,440 --> 00:24:58,690
cart so looking back at the architecture

00:24:55,070 --> 00:24:58,690
diagram maybe

00:25:05,010 --> 00:25:07,820
maybe not

00:25:10,070 --> 00:25:14,669
there's the front end which we were just

00:25:12,929 --> 00:25:20,760
looking at reaching out to this music

00:25:14,669 --> 00:25:23,510
store back end you can swipe back to it

00:25:20,760 --> 00:25:27,419
there you go

00:25:23,510 --> 00:25:30,270
so then when I add this to my cart that

00:25:27,419 --> 00:25:31,980
front end service inserted a reference

00:25:30,270 --> 00:25:35,149
into the shopping cart now that actually

00:25:31,980 --> 00:25:39,870
got stored in this my sequel database

00:25:35,149 --> 00:25:42,450
and if I were go to checkout I'm

00:25:39,870 --> 00:25:48,029
actually asked to log in so this is in

00:25:42,450 --> 00:25:53,909
the Music Store UI I will enter my

00:25:48,029 --> 00:25:55,380
secure password and I brought to this

00:25:53,909 --> 00:25:56,730
checkout page now I'm not gonna bore you

00:25:55,380 --> 00:25:58,289
with filling this out we all know how

00:25:56,730 --> 00:26:01,110
forms work but if I were to fill this

00:25:58,289 --> 00:26:03,120
out and submit it that would go to the

00:26:01,110 --> 00:26:05,370
back end order processing have you

00:26:03,120 --> 00:26:07,950
mentioned this Redis store here and why

00:26:05,370 --> 00:26:09,990
that's meant to help you be able to

00:26:07,950 --> 00:26:12,630
scale out that front end application so

00:26:09,990 --> 00:26:14,460
you can see here I'm logged in as me if

00:26:12,630 --> 00:26:18,289
I keep reloading the page I'm still

00:26:14,460 --> 00:26:21,149
logged in as me and when I go over to

00:26:18,289 --> 00:26:24,299
the application dashboard here I see

00:26:21,149 --> 00:26:26,580
that my using music UI actually has two

00:26:24,299 --> 00:26:28,590
instances right and so because we have

00:26:26,580 --> 00:26:31,529
that Redis back in store for the session

00:26:28,590 --> 00:26:34,620
state I can scale this up to you know 10

00:26:31,529 --> 00:26:38,789
1 5 whatever right so Redis is being

00:26:34,620 --> 00:26:41,549
used as that backing store if I go back

00:26:38,789 --> 00:26:45,779
to my applications here and look at the

00:26:41,549 --> 00:26:50,010
Music Store app you see this icon up

00:26:45,779 --> 00:26:52,230
here is actually notifying us that this

00:26:50,010 --> 00:26:57,000
application has been extended with that

00:26:52,230 --> 00:26:58,590
info health and lager API and so there's

00:26:57,000 --> 00:27:00,870
some additional functionality unlocked

00:26:58,590 --> 00:27:04,679
in the application manager console here

00:27:00,870 --> 00:27:06,899
I can click on this instance and get a

00:27:04,679 --> 00:27:09,539
health check of the disk space that's

00:27:06,899 --> 00:27:13,380
available in my container and the status

00:27:09,539 --> 00:27:16,710
of my service that I'm attached to I can

00:27:13,380 --> 00:27:17,970
also get the trace of the last hundred

00:27:16,710 --> 00:27:19,799
requests that were made to the

00:27:17,970 --> 00:27:22,350
application including all the headers

00:27:19,799 --> 00:27:26,220
that were in the response and request

00:27:22,350 --> 00:27:28,080
and under settings here I can see the

00:27:26,220 --> 00:27:29,519
Shaw and the directory that this was

00:27:28,080 --> 00:27:33,860
pushed from so if I'm trying to trace a

00:27:29,519 --> 00:27:36,360
bug down that makes it easy finally I

00:27:33,860 --> 00:27:37,830
can configure that logging level here

00:27:36,360 --> 00:27:39,809
and this is affecting the production

00:27:37,830 --> 00:27:42,809
instance of this application so as soon

00:27:39,809 --> 00:27:44,700
as I change this that's actually changed

00:27:42,809 --> 00:27:46,919
the logging level of the app and so

00:27:44,700 --> 00:27:49,440
maybe under normal circumstances I I

00:27:46,919 --> 00:27:51,529
really don't want any logging right I

00:27:49,440 --> 00:27:53,460
can turn this all the way down to none

00:27:51,529 --> 00:27:55,049
and the reason there's a little bit of

00:27:53,460 --> 00:27:56,549
lag when I push that is that that's

00:27:55,049 --> 00:27:59,970
actually sending a request out to the

00:27:56,549 --> 00:28:03,080
application and flipping that bit now

00:27:59,970 --> 00:28:05,970
this is all configured and secured using

00:28:03,080 --> 00:28:07,830
the built-in UA a and quad foundry and

00:28:05,970 --> 00:28:10,019
so random people can't just hit this

00:28:07,830 --> 00:28:11,909
right it's checking that I have access

00:28:10,019 --> 00:28:14,639
to this application it's sending along

00:28:11,909 --> 00:28:18,529
an OAuth token to the application to

00:28:14,639 --> 00:28:18,529
these endpoints to make these changes

00:28:19,970 --> 00:28:27,539
cool cool stuff so Zack why don't you

00:28:25,919 --> 00:28:30,779
tell us a little bit about the roadmap

00:28:27,539 --> 00:28:33,389
and many maybe some resources so I think

00:28:30,779 --> 00:28:34,980
we're we're running out of time so I'll

00:28:33,389 --> 00:28:37,679
be very quick but just to give you an

00:28:34,980 --> 00:28:38,700
idea of what's coming we're adding a

00:28:37,679 --> 00:28:40,529
couple of additional management

00:28:38,700 --> 00:28:42,960
endpoints including the ability to pull

00:28:40,529 --> 00:28:45,509
down a thread dump or a heap dump from

00:28:42,960 --> 00:28:48,000
your running application very useful in

00:28:45,509 --> 00:28:51,029
in troubleshooting we're looking to

00:28:48,000 --> 00:28:53,970
implement a dotnet version of Netflix

00:28:51,029 --> 00:28:57,090
ribbon to give you more flexibility in

00:28:53,970 --> 00:28:59,759
load balancing algorithms from your

00:28:57,090 --> 00:29:02,639
Eureka server from your Eureka client

00:28:59,759 --> 00:29:07,080
rather and then distribute it tracing as

00:29:02,639 --> 00:29:10,649
well the these slides are available on

00:29:07,080 --> 00:29:12,690
the sched schedule app you can pull them

00:29:10,649 --> 00:29:14,940
down there are links in here that help

00:29:12,690 --> 00:29:18,360
you get started as well as some

00:29:14,940 --> 00:29:21,000
additional resources if you'd like to

00:29:18,360 --> 00:29:22,649
dig in and read some blogs and if you

00:29:21,000 --> 00:29:24,419
happen to be attending the spring one

00:29:22,649 --> 00:29:27,000
platform conference in San Francisco

00:29:24,419 --> 00:29:30,419
later this year this December there is a

00:29:27,000 --> 00:29:32,970
two-day hands-on steel-toe course we

00:29:30,419 --> 00:29:35,020
invite you to attend all right and on

00:29:32,970 --> 00:29:42,550
that note I think we are done

00:29:35,020 --> 00:29:47,650
well thank you very much are there any

00:29:42,550 --> 00:29:55,270
questions we can answer this one right

00:29:47,650 --> 00:29:58,150
there thank you

00:29:55,270 --> 00:30:02,320
does the health endpoints do they

00:29:58,150 --> 00:30:04,420
integrate with lager cater so the health

00:30:02,320 --> 00:30:07,360
endpoint is slightly different from

00:30:04,420 --> 00:30:08,650
lager gator it's just it's integrated

00:30:07,360 --> 00:30:10,330
directly into the application and

00:30:08,650 --> 00:30:13,320
there's some specific monitoring that

00:30:10,330 --> 00:30:15,850
it's doing there right but we showed you

00:30:13,320 --> 00:30:18,940
we showed you how those actuators show

00:30:15,850 --> 00:30:21,330
up in the ABS manager console right and

00:30:18,940 --> 00:30:24,070
so law grader does integrate into that

00:30:21,330 --> 00:30:30,720
but the the health endpoint is separate

00:30:24,070 --> 00:30:33,070
from logger gator one more in the back

00:30:30,720 --> 00:30:35,679
is there any work being done on the

00:30:33,070 --> 00:30:38,200
datastore abstractions right like your

00:30:35,679 --> 00:30:40,120
crud interface right could I just you

00:30:38,200 --> 00:30:42,760
know change a current configuration

00:30:40,120 --> 00:30:44,380
parameter and move from a like an MS

00:30:42,760 --> 00:30:51,580
sequel database to may an Oracle

00:30:44,380 --> 00:30:54,010
database something like that in theory

00:30:51,580 --> 00:30:56,800
it's possible it's not not anything that

00:30:54,010 --> 00:30:58,590
we're actively working on but okay are

00:30:56,800 --> 00:31:01,540
either one of you use like spring data

00:30:58,590 --> 00:31:03,520
stores know if like that so that that's

00:31:01,540 --> 00:31:06,010
a really key feature for me okay when

00:31:03,520 --> 00:31:09,270
using spring I'd love to see you steel

00:31:06,010 --> 00:31:09,270
toe also

00:31:17,790 --> 00:31:24,760
we'll the distributed tracing be using

00:31:21,100 --> 00:31:29,620
Zipkin it will most likely be using zip

00:31:24,760 --> 00:31:33,280
confer net there's a question Ryan

00:31:29,620 --> 00:31:35,950
Fournier just shortly every car versus

00:31:33,280 --> 00:31:39,520
console will both be supported in

00:31:35,950 --> 00:31:43,240
the.net darshan I don't I don't know

00:31:39,520 --> 00:31:45,790
about console right so I mean console is

00:31:43,240 --> 00:31:47,680
a very heated topic and I'm happy to

00:31:45,790 --> 00:31:49,270
talk with you about that after I think

00:31:47,680 --> 00:31:51,730
there's a there's a question of like how

00:31:49,270 --> 00:31:53,260
to best run console inside a container

00:31:51,730 --> 00:31:54,490
on the platform right so that's a

00:31:53,260 --> 00:31:58,180
challenge

00:31:54,490 --> 00:32:00,610
so initially just based on Cloud Foundry

00:31:58,180 --> 00:32:03,130
when the spring team was looking for how

00:32:00,610 --> 00:32:04,870
do we solve this discovery problem Oh

00:32:03,130 --> 00:32:07,030
Eureka looks great right because it

00:32:04,870 --> 00:32:10,810
doesn't interfere with DNS doesn't use

00:32:07,030 --> 00:32:13,090
anything like console right now there's

00:32:10,810 --> 00:32:14,650
some really cool roadmap stuff that you

00:32:13,090 --> 00:32:16,180
might have seen talks about today where

00:32:14,650 --> 00:32:19,240
we have the opportunity for sidecar

00:32:16,180 --> 00:32:21,970
containers we're doing things with sto

00:32:19,240 --> 00:32:23,530
and and all that right so there's a lot

00:32:21,970 --> 00:32:25,690
of exciting stuff that's gonna happen in

00:32:23,530 --> 00:32:27,010
the next year so we're I think we're

00:32:25,690 --> 00:32:31,210
gonna have a much better story here on

00:32:27,010 --> 00:32:33,790
the service discovery but for today

00:32:31,210 --> 00:32:38,230
console in the container not not so

00:32:33,790 --> 00:32:39,190
great all right well I think we're out

00:32:38,230 --> 00:32:40,660
of time but if you have any other

00:32:39,190 --> 00:32:43,270
questions please feel free to come up to

00:32:40,660 --> 00:32:43,890
us afterwards and and ask all right

00:32:43,270 --> 00:32:46,979
thanks again

00:32:43,890 --> 00:32:46,979

YouTube URL: https://www.youtube.com/watch?v=2HF6HFhGH60


