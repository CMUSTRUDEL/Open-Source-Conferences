Title: Observability with Prometheus and Beyond - Richard Hartmann, Grafana Labs
Publication date: 2020-10-26
Playlist: Cloud Foundry Summit Europe 2020
Description: 
	Observability with Prometheus and Beyond - Richard Hartmann, Grafana Labs
Captions: 
	00:00:00,080 --> 00:00:03,840
hi and welcome to observability with

00:00:01,920 --> 00:00:05,440
prometheus and beyond

00:00:03,840 --> 00:00:07,040
i've been asked to talk a little bit

00:00:05,440 --> 00:00:08,160
about my background course there's a new

00:00:07,040 --> 00:00:10,160
audience

00:00:08,160 --> 00:00:11,920
i'm the director of community at grafana

00:00:10,160 --> 00:00:14,240
labs i'm a prometheus team member

00:00:11,920 --> 00:00:16,400
i organized a conference for prometheus

00:00:14,240 --> 00:00:18,160
i chair the dev summits for prometheus i

00:00:16,400 --> 00:00:20,400
founded openmetrics

00:00:18,160 --> 00:00:21,520
i'm the chair of the sick observability

00:00:20,400 --> 00:00:23,519
within cncf

00:00:21,520 --> 00:00:25,760
i did a few other things built a data

00:00:23,519 --> 00:00:28,240
center had some consulting

00:00:25,760 --> 00:00:30,320
my initial background is in mainframes

00:00:28,240 --> 00:00:32,880
and especially networking

00:00:30,320 --> 00:00:33,840
and i organized quite a few conferences

00:00:32,880 --> 00:00:36,399
on the site which

00:00:33,840 --> 00:00:36,960
have quite a few users and as such quite

00:00:36,399 --> 00:00:39,120
a few

00:00:36,960 --> 00:00:40,879
requirements when it comes to actually

00:00:39,120 --> 00:00:43,280
making those work

00:00:40,879 --> 00:00:44,000
this is all a long-winded form of saying

00:00:43,280 --> 00:00:45,680
that yes

00:00:44,000 --> 00:00:48,000
i actually come from the trenches of

00:00:45,680 --> 00:00:50,320
tech and i know the pains of

00:00:48,000 --> 00:00:51,280
of operations and of trying to make

00:00:50,320 --> 00:00:54,800
sense of a

00:00:51,280 --> 00:00:57,199
system and that's where i'm coming from

00:00:54,800 --> 00:00:59,039
so let's look at today today you have

00:00:57,199 --> 00:01:00,079
disparate systems you have this spirit

00:00:59,039 --> 00:01:02,640
data

00:01:00,079 --> 00:01:04,400
they might be with the same indexing

00:01:02,640 --> 00:01:06,240
data but usually there aren't so

00:01:04,400 --> 00:01:08,960
jumping in between those different

00:01:06,240 --> 00:01:10,720
systems usually means a break

00:01:08,960 --> 00:01:12,080
they're kind of air gap they're kind of

00:01:10,720 --> 00:01:15,119
different so you have to

00:01:12,080 --> 00:01:16,960
mentally switch model to the other to

00:01:15,119 --> 00:01:18,560
the other system to actually follow up

00:01:16,960 --> 00:01:19,280
what that thing is which is currently

00:01:18,560 --> 00:01:21,200
broken

00:01:19,280 --> 00:01:23,280
which just costs you time it's mental

00:01:21,200 --> 00:01:24,799
overhead and it's just not very

00:01:23,280 --> 00:01:26,240
efficient also it makes it harder to

00:01:24,799 --> 00:01:27,920
automate some things

00:01:26,240 --> 00:01:29,840
but usually i care a lot more about the

00:01:27,920 --> 00:01:32,079
humans not having too much

00:01:29,840 --> 00:01:33,040
mental overhead of course computers can

00:01:32,079 --> 00:01:36,159
be bought more

00:01:33,040 --> 00:01:37,840
humans actually like they need to

00:01:36,159 --> 00:01:40,000
they need to be able to grok what they

00:01:37,840 --> 00:01:42,240
need to know

00:01:40,000 --> 00:01:44,159
so let's rethink how we could be doing

00:01:42,240 --> 00:01:45,600
this instead let's get a little bit back

00:01:44,159 --> 00:01:47,759
to the basics

00:01:45,600 --> 00:01:49,360
and before we do this let's look at some

00:01:47,759 --> 00:01:52,320
buzzwords

00:01:49,360 --> 00:01:53,119
what do these buzzwords actually mean so

00:01:52,320 --> 00:01:55,759
buzzwords

00:01:53,119 --> 00:01:57,920
usually have some some real meaning some

00:01:55,759 --> 00:01:59,920
core of truth some kerning of truth

00:01:57,920 --> 00:02:01,439
um but by the time they're buzzword

00:01:59,920 --> 00:02:03,840
they're more or less useless

00:02:01,439 --> 00:02:05,520
they might become useful after once

00:02:03,840 --> 00:02:07,360
they're not a buzzword anymore

00:02:05,520 --> 00:02:09,440
but usually during that phase everyone

00:02:07,360 --> 00:02:09,840
is just piling on and trying to to get

00:02:09,440 --> 00:02:13,120
their

00:02:09,840 --> 00:02:16,879
specific thing named after that thing

00:02:13,120 --> 00:02:19,360
so pitfalls of this cargo collecting

00:02:16,879 --> 00:02:20,080
which is a term for you observe how

00:02:19,360 --> 00:02:22,000
something or

00:02:20,080 --> 00:02:23,599
you observe the effects of something and

00:02:22,000 --> 00:02:24,879
you want to have the same effects and

00:02:23,599 --> 00:02:27,520
you just

00:02:24,879 --> 00:02:29,040
do whatever you perceive as being what

00:02:27,520 --> 00:02:30,480
the other people are doing instead of

00:02:29,040 --> 00:02:33,760
really understanding

00:02:30,480 --> 00:02:36,160
why something is happening and

00:02:33,760 --> 00:02:37,040
to me it's a lot more observability it's

00:02:36,160 --> 00:02:40,080
a lot more about

00:02:37,040 --> 00:02:41,040
changing the actual behavior within the

00:02:40,080 --> 00:02:42,879
org

00:02:41,040 --> 00:02:44,560
than about just changing the name and

00:02:42,879 --> 00:02:46,319
calling whatever you've done before by a

00:02:44,560 --> 00:02:48,319
new name and then basically pretend

00:02:46,319 --> 00:02:50,720
you're done

00:02:48,319 --> 00:02:51,599
these days monitoring has taken on a

00:02:50,720 --> 00:02:53,360
meaning of

00:02:51,599 --> 00:02:55,280
more or less collecting data but not

00:02:53,360 --> 00:02:57,760
really using this data

00:02:55,280 --> 00:02:59,040
um there are some euphemisms for this um

00:02:57,760 --> 00:03:02,400
data lake would be one

00:02:59,040 --> 00:03:04,080
where you basically give up on indexing

00:03:02,400 --> 00:03:05,920
or making any sense at all

00:03:04,080 --> 00:03:07,120
out of your data and you just store it

00:03:05,920 --> 00:03:09,360
because

00:03:07,120 --> 00:03:11,200
it might be useful and you can run super

00:03:09,360 --> 00:03:11,840
complex queries on it but you don't

00:03:11,200 --> 00:03:14,480
actually

00:03:11,840 --> 00:03:15,920
you can can actually work with it or you

00:03:14,480 --> 00:03:18,080
have the other extreme where you just do

00:03:15,920 --> 00:03:21,040
full text and it's a full text indexing

00:03:18,080 --> 00:03:22,800
and everything is indexed and this is

00:03:21,040 --> 00:03:24,720
obviously super expensive

00:03:22,800 --> 00:03:27,360
but at least you have some way into your

00:03:24,720 --> 00:03:29,040
data none of those trade-offs are super

00:03:27,360 --> 00:03:32,400
nice to me

00:03:29,040 --> 00:03:33,280
observability these days it has a

00:03:32,400 --> 00:03:35,840
meaning of

00:03:33,280 --> 00:03:38,000
trying to enable humans to actually

00:03:35,840 --> 00:03:39,120
understand those complex systems to be

00:03:38,000 --> 00:03:42,319
able to understand

00:03:39,120 --> 00:03:46,159
why something is not working instead of

00:03:42,319 --> 00:03:49,599
just saying that yes it is not working

00:03:46,159 --> 00:03:51,440
this is my all-time favorite meme

00:03:49,599 --> 00:03:53,040
but it has a deeper meaning because yes

00:03:51,440 --> 00:03:55,439
at the face of it yes

00:03:53,040 --> 00:03:56,159
things are broken but that book is

00:03:55,439 --> 00:03:58,720
actually about

00:03:56,159 --> 00:03:59,280
how to with the information you have

00:03:58,720 --> 00:04:01,840
extract

00:03:59,280 --> 00:04:02,319
more meaning so humans can understand

00:04:01,840 --> 00:04:04,799
what

00:04:02,319 --> 00:04:05,439
what they're actually dealing with and

00:04:04,799 --> 00:04:08,319
same as

00:04:05,439 --> 00:04:09,920
observability is about taking what you

00:04:08,319 --> 00:04:12,000
have and improving what you have

00:04:09,920 --> 00:04:13,680
and actually understanding it and making

00:04:12,000 --> 00:04:16,160
deductions from this

00:04:13,680 --> 00:04:17,919
let's let's show you the same thing just

00:04:16,160 --> 00:04:21,280
in a more funny way

00:04:17,919 --> 00:04:23,360
let's talk about complexity complexity

00:04:21,280 --> 00:04:25,759
can be in my opinion split into two

00:04:23,360 --> 00:04:28,000
parts you have the fake complexity and

00:04:25,759 --> 00:04:30,400
you have the real complexity fake

00:04:28,000 --> 00:04:32,479
complexity can just be bad design or

00:04:30,400 --> 00:04:33,919
operational whatever or some

00:04:32,479 --> 00:04:36,560
organizational

00:04:33,919 --> 00:04:38,720
constraints which you have but usually

00:04:36,560 --> 00:04:39,360
this can be reduced and if at all

00:04:38,720 --> 00:04:41,280
possible

00:04:39,360 --> 00:04:42,560
should be reduced that's not always

00:04:41,280 --> 00:04:46,160
possible in the real world

00:04:42,560 --> 00:04:48,800
agreed but it should still be attempted

00:04:46,160 --> 00:04:49,360
real system inherent complexity just

00:04:48,800 --> 00:04:52,880
can't

00:04:49,360 --> 00:04:55,360
be be taken away you can move it like

00:04:52,880 --> 00:04:56,880
you can say where you want to to have

00:04:55,360 --> 00:04:59,040
your state

00:04:56,880 --> 00:05:01,199
should this be in a distinct database

00:04:59,040 --> 00:05:03,759
should it be part of your own code

00:05:01,199 --> 00:05:05,360
and one of the old sayings is make

00:05:03,759 --> 00:05:07,280
states someone else's problem and this

00:05:05,360 --> 00:05:09,680
is very much about this

00:05:07,280 --> 00:05:12,000
it must be comparisonalized service

00:05:09,680 --> 00:05:15,039
boundaries you don't have your cpu

00:05:12,000 --> 00:05:16,080
and and look at all up codes within that

00:05:15,039 --> 00:05:18,400
cpu

00:05:16,080 --> 00:05:20,160
you compartialize this as a service and

00:05:18,400 --> 00:05:21,600
then you build on top of that comparison

00:05:20,160 --> 00:05:23,039
of services

00:05:21,600 --> 00:05:25,360
and it should be distilled in a

00:05:23,039 --> 00:05:27,280
meaningful way so humans can actually

00:05:25,360 --> 00:05:28,720
understand what is happening within that

00:05:27,280 --> 00:05:30,639
one compartment

00:05:28,720 --> 00:05:32,320
and then make deductions based on this

00:05:30,639 --> 00:05:34,880
without having to understand the full

00:05:32,320 --> 00:05:38,160
extent of the whole system

00:05:34,880 --> 00:05:41,120
another buzzword is sre

00:05:38,160 --> 00:05:43,520
its core to me as there is about

00:05:41,120 --> 00:05:47,199
aligning incentives across your

00:05:43,520 --> 00:05:50,240
across the org which obviously is easier

00:05:47,199 --> 00:05:53,440
than them there are some

00:05:50,240 --> 00:05:54,800
very very few things which everyone

00:05:53,440 --> 00:05:57,680
should be looking at sli

00:05:54,800 --> 00:05:58,479
as low as la sli are service level

00:05:57,680 --> 00:06:00,080
indicators

00:05:58,479 --> 00:06:02,160
as in the things which you actually

00:06:00,080 --> 00:06:04,240
measure objectives

00:06:02,160 --> 00:06:06,160
are the things which you or are the

00:06:04,240 --> 00:06:09,919
thresholds which you don't want to go

00:06:06,160 --> 00:06:12,160
over under whatever your your way of

00:06:09,919 --> 00:06:13,680
measuring this is and agreements is what

00:06:12,160 --> 00:06:15,360
you actually have with customers

00:06:13,680 --> 00:06:17,120
internal or external where you

00:06:15,360 --> 00:06:18,479
actually break a contract where you

00:06:17,120 --> 00:06:21,840
actually have to pay money

00:06:18,479 --> 00:06:26,080
or whatever

00:06:21,840 --> 00:06:29,199
if you have your your operations in this

00:06:26,080 --> 00:06:29,600
manner one thing which you can do is you

00:06:29,199 --> 00:06:32,160
can

00:06:29,600 --> 00:06:34,000
introduce error budgets because if you

00:06:32,160 --> 00:06:37,039
have this sli slo sla

00:06:34,000 --> 00:06:40,240
system you can actually talk about

00:06:37,039 --> 00:06:42,800
what is the state of that system you can

00:06:40,240 --> 00:06:44,800
have an sli for your errors

00:06:42,800 --> 00:06:47,600
and then you have an slo for your error

00:06:44,800 --> 00:06:51,039
and this is your error budget

00:06:47,600 --> 00:06:52,560
so if the debts ship broken code and ops

00:06:51,039 --> 00:06:55,280
have to fix it all the time

00:06:52,560 --> 00:06:56,160
that counts against the error budget if

00:06:55,280 --> 00:06:58,639
ops

00:06:56,160 --> 00:07:01,199
make some mistake and break something

00:06:58,639 --> 00:07:03,199
and that eats into your uptime

00:07:01,199 --> 00:07:04,720
that's also something which goes against

00:07:03,199 --> 00:07:07,360
the error budget

00:07:04,720 --> 00:07:08,960
and if you have good operations and if

00:07:07,360 --> 00:07:10,479
you have clean code which is shipping

00:07:08,960 --> 00:07:12,479
nicely then you have

00:07:10,479 --> 00:07:14,720
error budget over so you can you can use

00:07:12,479 --> 00:07:17,039
this for a b testing you can do it for

00:07:14,720 --> 00:07:18,240
you can use it for faster iterations on

00:07:17,039 --> 00:07:20,720
your code shipments

00:07:18,240 --> 00:07:21,680
you can do whatever but by taking what

00:07:20,720 --> 00:07:23,039
actually matters

00:07:21,680 --> 00:07:25,759
and measuring this and making

00:07:23,039 --> 00:07:28,720
quantifiable and having a shared budget

00:07:25,759 --> 00:07:31,120
across everyone who is touching this

00:07:28,720 --> 00:07:32,960
everyone is all of a sudden working

00:07:31,120 --> 00:07:36,080
towards the same goals

00:07:32,960 --> 00:07:37,440
which might sound somewhat almost almost

00:07:36,080 --> 00:07:40,400
tautologic

00:07:37,440 --> 00:07:43,840
but it's super powerful to just align

00:07:40,400 --> 00:07:46,000
incentives between different

00:07:43,840 --> 00:07:47,680
and you have other things because once

00:07:46,000 --> 00:07:49,599
everyone is using the same tools and

00:07:47,680 --> 00:07:52,160
dashboards

00:07:49,599 --> 00:07:53,680
every investment into this shared

00:07:52,160 --> 00:07:55,840
tooling

00:07:53,680 --> 00:07:58,000
is an investment into the whole org

00:07:55,840 --> 00:08:00,960
because everyone else is benefiting

00:07:58,000 --> 00:08:02,800
from the same thing all of a sudden you

00:08:00,960 --> 00:08:04,160
start pulling institutional knowledge

00:08:02,800 --> 00:08:06,479
about your systems

00:08:04,160 --> 00:08:08,400
within or across the org instead of

00:08:06,479 --> 00:08:09,599
having your islands of people your

00:08:08,400 --> 00:08:11,280
islands of data

00:08:09,599 --> 00:08:13,440
now everyone is working on literally the

00:08:11,280 --> 00:08:15,039
same thing as they're using the same

00:08:13,440 --> 00:08:16,240
tools and dashboards they also have the

00:08:15,039 --> 00:08:18,879
same shared language

00:08:16,240 --> 00:08:20,160
so and language is a vehicle for human

00:08:18,879 --> 00:08:22,720
understanding

00:08:20,160 --> 00:08:26,240
so they also gain similar or even the

00:08:22,720 --> 00:08:27,840
same understanding of the services again

00:08:26,240 --> 00:08:30,080
what's the service it's comparison as

00:08:27,840 --> 00:08:31,440
complexity it has an interface or many

00:08:30,080 --> 00:08:34,719
interfaces

00:08:31,440 --> 00:08:37,120
usually a service has one set of owners

00:08:34,719 --> 00:08:37,839
and contracts define those interfaces

00:08:37,120 --> 00:08:40,399
which again

00:08:37,839 --> 00:08:41,039
with service agreements if you break

00:08:40,399 --> 00:08:43,200
them

00:08:41,039 --> 00:08:45,600
you have to pay or whatever but still

00:08:43,200 --> 00:08:46,560
there is a defined mechanism about what

00:08:45,600 --> 00:08:49,600
happens

00:08:46,560 --> 00:08:51,600
if you break a contract and that's why i

00:08:49,600 --> 00:08:54,000
like the term contract

00:08:51,600 --> 00:08:54,959
of course it is a shared agreement which

00:08:54,000 --> 00:08:58,080
must not

00:08:54,959 --> 00:09:00,000
be broken because both internal and

00:08:58,080 --> 00:09:01,920
external customers rely on what you

00:09:00,000 --> 00:09:03,680
build and maintain and same

00:09:01,920 --> 00:09:05,440
you are relying on stuff which other

00:09:03,680 --> 00:09:07,200
people build and maintain

00:09:05,440 --> 00:09:08,800
and your customers are building and

00:09:07,200 --> 00:09:10,800
maintaining other stuff which

00:09:08,800 --> 00:09:12,160
yet again other people are relying on

00:09:10,800 --> 00:09:14,959
without this

00:09:12,160 --> 00:09:17,120
society wouldn't work and without this

00:09:14,959 --> 00:09:19,040
orcs don't work

00:09:17,120 --> 00:09:20,880
there is another super common term for

00:09:19,040 --> 00:09:23,120
this which is layer

00:09:20,880 --> 00:09:25,839
and quite frankly without proper

00:09:23,120 --> 00:09:26,800
layering the internet would not exist as

00:09:25,839 --> 00:09:29,839
of today

00:09:26,800 --> 00:09:33,120
it couldn't because it is ever changing

00:09:29,839 --> 00:09:34,560
and by being able to rely on huge parts

00:09:33,120 --> 00:09:37,760
of the stack

00:09:34,560 --> 00:09:40,399
and just not having them change is

00:09:37,760 --> 00:09:42,480
incredibly powerful for having faster

00:09:40,399 --> 00:09:45,040
iterations and innovations in

00:09:42,480 --> 00:09:47,040
different parts of the stick which also

00:09:45,040 --> 00:09:48,399
goes a little bit against newer http

00:09:47,040 --> 00:09:50,000
forms and such of course those

00:09:48,399 --> 00:09:52,959
mingle a lot of layers but that's the

00:09:50,000 --> 00:09:55,040
topic for for another day

00:09:52,959 --> 00:09:56,959
layering enables innovation of course it

00:09:55,040 --> 00:09:59,040
paralyzes human engineering and it

00:09:56,959 --> 00:10:01,040
paralyzes taking care of different parts

00:09:59,040 --> 00:10:03,200
of the stick of this one hole which

00:10:01,040 --> 00:10:04,880
everyone wants to use

00:10:03,200 --> 00:10:06,480
one of the examples i already used

00:10:04,880 --> 00:10:08,640
earlier cpus

00:10:06,480 --> 00:10:11,200
heartless compute knows your lunch

00:10:08,640 --> 00:10:14,959
you're not growing your own weed or

00:10:11,200 --> 00:10:16,959
or like growing your own cucumbers

00:10:14,959 --> 00:10:18,959
you're buying those or you're buying the

00:10:16,959 --> 00:10:20,959
already pre-processed food or what

00:10:18,959 --> 00:10:22,240
wherever your your break point is what

00:10:20,959 --> 00:10:24,399
type of service you buy in what

00:10:22,240 --> 00:10:27,680
situation yet

00:10:24,399 --> 00:10:29,760
that this concept of having things as a

00:10:27,680 --> 00:10:32,959
service or as a product

00:10:29,760 --> 00:10:35,519
is super common but it needs to be

00:10:32,959 --> 00:10:38,240
done more and more also within orgs and

00:10:35,519 --> 00:10:38,240
done properly

00:10:38,399 --> 00:10:42,720
one thing about services customers care

00:10:41,040 --> 00:10:44,480
about both services being up

00:10:42,720 --> 00:10:46,560
and available they don't care about

00:10:44,480 --> 00:10:47,360
individual you care about those

00:10:46,560 --> 00:10:50,079
components

00:10:47,360 --> 00:10:51,760
they don't same as you don't really care

00:10:50,079 --> 00:10:52,880
about the individual components of

00:10:51,760 --> 00:10:55,040
whatever you're using

00:10:52,880 --> 00:10:56,160
tap water needs to come out of the wall

00:10:55,040 --> 00:10:58,000
that's it

00:10:56,160 --> 00:11:00,160
like it's it's interesting to see how

00:10:58,000 --> 00:11:02,000
that works and it's a fascinating topic

00:11:00,160 --> 00:11:04,160
but at the end of the day i just want to

00:11:02,000 --> 00:11:05,600
turn on my tab and i want to have water

00:11:04,160 --> 00:11:07,680
and it's the same for you and it's the

00:11:05,600 --> 00:11:09,200
same for everyone else

00:11:07,680 --> 00:11:11,920
at least those people happy enough to

00:11:09,200 --> 00:11:11,920
have tap water

00:11:12,320 --> 00:11:18,000
there is something which is not in

00:11:15,440 --> 00:11:18,480
core sre but something which i like

00:11:18,000 --> 00:11:20,880
doing

00:11:18,480 --> 00:11:22,640
uh to discern between different levels

00:11:20,880 --> 00:11:25,519
of slis

00:11:22,640 --> 00:11:26,720
primary slis are service relevant and

00:11:25,519 --> 00:11:29,120
for alerting

00:11:26,720 --> 00:11:31,600
and secondary slis are basically

00:11:29,120 --> 00:11:34,880
informational for debugging and such

00:11:31,600 --> 00:11:35,200
but quite likely those things which to

00:11:34,880 --> 00:11:37,600
you

00:11:35,200 --> 00:11:39,600
are secondary slis which just give you

00:11:37,600 --> 00:11:41,519
information about this

00:11:39,600 --> 00:11:42,720
what what environment you're operating

00:11:41,519 --> 00:11:46,000
in

00:11:42,720 --> 00:11:48,079
is um actually your primary

00:11:46,000 --> 00:11:49,680
sli is for the underlying service not

00:11:48,079 --> 00:11:51,200
always but it's super likely

00:11:49,680 --> 00:11:52,560
and again this gives you a shared

00:11:51,200 --> 00:11:54,320
knowledge because you can already

00:11:52,560 --> 00:11:56,560
approach the other team with hey this

00:11:54,320 --> 00:11:58,720
and that thing is degrading

00:11:56,560 --> 00:12:00,079
and my other thing is breaking because

00:11:58,720 --> 00:12:01,760
you have that same

00:12:00,079 --> 00:12:03,680
terminology you have literally the same

00:12:01,760 --> 00:12:06,399
dashboards you look at the dashboards

00:12:03,680 --> 00:12:08,320
of your supplying team so you know

00:12:06,399 --> 00:12:10,240
precisely what's up with them and you

00:12:08,320 --> 00:12:11,120
know precisely what terms to use when

00:12:10,240 --> 00:12:12,800
talking to them

00:12:11,120 --> 00:12:14,800
it's super nice and it just makes

00:12:12,800 --> 00:12:16,959
everything quicker

00:12:14,800 --> 00:12:18,399
one thing important which is often done

00:12:16,959 --> 00:12:21,920
right and just to prevent

00:12:18,399 --> 00:12:24,079
pager fatty fatty anything

00:12:21,920 --> 00:12:25,680
which is currently or imminently

00:12:24,079 --> 00:12:27,519
impacting customers whatever your

00:12:25,680 --> 00:12:31,839
definition of customer is

00:12:27,519 --> 00:12:33,760
must be alerted upon but nothing else

00:12:31,839 --> 00:12:35,680
if it's important but not urgent great

00:12:33,760 --> 00:12:37,839
make a ticket someone can deal with this

00:12:35,680 --> 00:12:39,440
during business hours or even during

00:12:37,839 --> 00:12:42,160
whatever time

00:12:39,440 --> 00:12:42,639
maybe the on-call people even take care

00:12:42,160 --> 00:12:45,760
of this

00:12:42,639 --> 00:12:48,320
but not as part of an escalation just as

00:12:45,760 --> 00:12:51,360
part of normal systems maintenance

00:12:48,320 --> 00:12:54,399
only both important and urgent things

00:12:51,360 --> 00:12:57,360
make it to your pager that's it

00:12:54,399 --> 00:12:58,800
so let's look at specific software

00:12:57,360 --> 00:13:01,600
prometheus

00:12:58,800 --> 00:13:02,160
for me sys101 it is inspired by google's

00:13:01,600 --> 00:13:06,000
pork one

00:13:02,160 --> 00:13:08,880
it's a time series database it has unc

00:13:06,000 --> 00:13:10,480
64 millisecond timestamps and float64

00:13:08,880 --> 00:13:12,000
values

00:13:10,480 --> 00:13:15,279
it relies on instrumentation and

00:13:12,000 --> 00:13:17,279
exporters it is not for event logging

00:13:15,279 --> 00:13:18,720
and dashboarding is usually done via

00:13:17,279 --> 00:13:21,600
grafana

00:13:18,720 --> 00:13:22,240
its main selling points it has a highly

00:13:21,600 --> 00:13:23,839
dynamic

00:13:22,240 --> 00:13:25,839
and built-in service discovery which

00:13:23,839 --> 00:13:28,720
enables you to to

00:13:25,839 --> 00:13:29,920
grab services to monitor from a hugely

00:13:28,720 --> 00:13:33,040
diverse

00:13:29,920 --> 00:13:34,000
set of mechanisms it doesn't have a

00:13:33,040 --> 00:13:36,000
hierarchical

00:13:34,000 --> 00:13:38,079
data model so usually when you have a

00:13:36,000 --> 00:13:39,839
tree like structure

00:13:38,079 --> 00:13:41,600
whatever you're doing once you're done

00:13:39,839 --> 00:13:43,199
defining this it's already wrong

00:13:41,600 --> 00:13:44,720
this doesn't have that problem you have

00:13:43,199 --> 00:13:46,800
your n-dimensional label setting

00:13:44,720 --> 00:13:48,000
slice and dice your n-dimensional matrix

00:13:46,800 --> 00:13:50,240
however you want

00:13:48,000 --> 00:13:51,760
with these label sets you have one

00:13:50,240 --> 00:13:54,320
single language

00:13:51,760 --> 00:13:57,680
placing your data but that's the same

00:13:54,320 --> 00:13:57,680
for processing for graphing for

00:13:57,760 --> 00:14:03,600
for doing everything all operations

00:14:01,040 --> 00:14:05,199
on your data are always done through one

00:14:03,600 --> 00:14:06,399
single language because it's just super

00:14:05,199 --> 00:14:08,560
powerful

00:14:06,399 --> 00:14:11,279
it's really simple to operate and it's

00:14:08,560 --> 00:14:13,120
highly highly efficient

00:14:11,279 --> 00:14:14,880
it's a pull based system which gives you

00:14:13,120 --> 00:14:17,519
some nice properties around

00:14:14,880 --> 00:14:19,920
around a system state or determining the

00:14:17,519 --> 00:14:22,079
state of your monetary systems but

00:14:19,920 --> 00:14:23,360
push versus pull is largely a religious

00:14:22,079 --> 00:14:25,519
question

00:14:23,360 --> 00:14:27,839
black box monitoring is a concept of

00:14:25,519 --> 00:14:30,240
looking at services from the outside

00:14:27,839 --> 00:14:33,120
for example does my server answer to

00:14:30,240 --> 00:14:35,279
http requests or do i get http 200 or

00:14:33,120 --> 00:14:38,880
404 or whatever do i get

00:14:35,279 --> 00:14:41,920
um that is built into into prometheus

00:14:38,880 --> 00:14:43,519
same or the different side of the coin

00:14:41,920 --> 00:14:44,560
the other side of the coin is white box

00:14:43,519 --> 00:14:47,760
monitoring

00:14:44,560 --> 00:14:50,560
they actually go into your code

00:14:47,760 --> 00:14:52,880
and actually look at at your code from

00:14:50,560 --> 00:14:54,880
within what is my call doing

00:14:52,880 --> 00:14:57,040
where you look through the box more or

00:14:54,880 --> 00:14:58,000
less and somewhere in the middle you

00:14:57,040 --> 00:15:00,959
have exporters which

00:14:58,000 --> 00:15:02,160
basically take some form of data and

00:15:00,959 --> 00:15:03,920
translate it into

00:15:02,160 --> 00:15:06,720
into whatever prometheus can read which

00:15:03,920 --> 00:15:08,000
is the prometheus exposition from it

00:15:06,720 --> 00:15:09,760
every service should have its own

00:15:08,000 --> 00:15:12,079
metrics endpoint you can hide them

00:15:09,760 --> 00:15:14,480
behind a reverse proxy a common one for

00:15:12,079 --> 00:15:16,560
easier have for easier fireballing and

00:15:14,480 --> 00:15:20,240
such that's not an issue but

00:15:16,560 --> 00:15:22,959
you shouldn't have super split up

00:15:20,240 --> 00:15:23,920
things and so you shouldn't have one

00:15:22,959 --> 00:15:26,320
humongous thing

00:15:23,920 --> 00:15:27,440
ideally you have one matrix endpoint per

00:15:26,320 --> 00:15:31,120
service

00:15:27,440 --> 00:15:34,880
there are hard api commits within

00:15:31,120 --> 00:15:38,079
every major version of prometheus and

00:15:34,880 --> 00:15:38,560
oh actually we do have tls by now that

00:15:38,079 --> 00:15:40,560
is

00:15:38,560 --> 00:15:42,000
i need to i need to edit that slide

00:15:40,560 --> 00:15:44,160
sorry

00:15:42,000 --> 00:15:45,120
but that's relatively recent and we just

00:15:44,160 --> 00:15:47,839
got done with

00:15:45,120 --> 00:15:49,120
uh with our security audit for this so

00:15:47,839 --> 00:15:51,440
it's it's somewhere in the middle but

00:15:49,120 --> 00:15:54,720
still i need to change that part

00:15:51,440 --> 00:15:59,279
so working assumptions and concept no

00:15:54,720 --> 00:16:01,519
that's a duplication time series

00:15:59,279 --> 00:16:02,480
time series are recorded values which

00:16:01,519 --> 00:16:04,240
change over time

00:16:02,480 --> 00:16:05,920
you could for example say you have a

00:16:04,240 --> 00:16:09,680
temperature and that temperature

00:16:05,920 --> 00:16:10,480
changes obviously and you just write

00:16:09,680 --> 00:16:12,880
down what

00:16:10,480 --> 00:16:13,759
what the current value is and by over

00:16:12,880 --> 00:16:16,639
time that becomes

00:16:13,759 --> 00:16:18,399
time series individual events are

00:16:16,639 --> 00:16:19,199
usually merged into counters and or

00:16:18,399 --> 00:16:22,160
histograms

00:16:19,199 --> 00:16:23,680
like total amount of user requests you

00:16:22,160 --> 00:16:26,240
wouldn't count or you wouldn't

00:16:23,680 --> 00:16:27,360
persist every single user request that

00:16:26,240 --> 00:16:28,720
is event logging

00:16:27,360 --> 00:16:32,320
you would just have a counter for

00:16:28,720 --> 00:16:32,320
counting how many of those you have

00:16:32,720 --> 00:16:36,399
changing values are recorded as gorgeous

00:16:35,440 --> 00:16:38,880
of course they

00:16:36,399 --> 00:16:39,839
go up and down various counters only go

00:16:38,880 --> 00:16:43,839
up

00:16:39,839 --> 00:16:44,240
monotonically and service latency and

00:16:43,839 --> 00:16:45,839
such

00:16:44,240 --> 00:16:47,920
would be would be histograms where you

00:16:45,839 --> 00:16:52,000
have your percentiles or whatever

00:16:47,920 --> 00:16:54,560
for for for how long it takes to

00:16:52,000 --> 00:16:56,720
to access a service or how long it takes

00:16:54,560 --> 00:17:00,250
until it replies

00:16:56,720 --> 00:17:02,639
it's a super easy to emit and parse

00:17:00,250 --> 00:17:05,679
[Music]

00:17:02,639 --> 00:17:06,400
format wire format which basically looks

00:17:05,679 --> 00:17:08,480
as such

00:17:06,400 --> 00:17:09,600
you have your metric name you have your

00:17:08,480 --> 00:17:11,199
label set

00:17:09,600 --> 00:17:13,039
and then you have the current value and

00:17:11,199 --> 00:17:15,039
you just have tons and tons of these and

00:17:13,039 --> 00:17:17,039
that is how you expose your data which

00:17:15,039 --> 00:17:19,600
is super easy to emit

00:17:17,039 --> 00:17:21,039
i even know people who literally print f

00:17:19,600 --> 00:17:22,959
from c code because

00:17:21,039 --> 00:17:24,720
that's how how it works for them and

00:17:22,959 --> 00:17:27,199
that's totally fine

00:17:24,720 --> 00:17:29,679
it's really really easy to to create

00:17:27,199 --> 00:17:32,880
compliant

00:17:29,679 --> 00:17:34,480
data sets talking about scaling of

00:17:32,880 --> 00:17:37,520
prometheus

00:17:34,480 --> 00:17:38,559
kubernetes is google spork prometheus is

00:17:37,520 --> 00:17:40,000
google sport one

00:17:38,559 --> 00:17:41,760
just in open source three

00:17:40,000 --> 00:17:44,400
implementations with a few

00:17:41,760 --> 00:17:47,200
rough edges send it down so it's it's

00:17:44,400 --> 00:17:50,480
easier to handle

00:17:47,200 --> 00:17:52,559
quite honestly and quite bluntly

00:17:50,480 --> 00:17:54,799
google couldn't have run borg which is

00:17:52,559 --> 00:17:57,679
their container thing

00:17:54,799 --> 00:17:58,480
which basically powers everything which

00:17:57,679 --> 00:18:01,760
they have

00:17:58,480 --> 00:18:03,440
and this was already in the late 90s so

00:18:01,760 --> 00:18:04,799
this is literally where their success is

00:18:03,440 --> 00:18:06,160
coming from and they couldn't have run

00:18:04,799 --> 00:18:08,400
borg without boardman

00:18:06,160 --> 00:18:10,400
or again more like these days as well

00:18:08,400 --> 00:18:11,840
yet without borgman they couldn't have

00:18:10,400 --> 00:18:14,960
run it

00:18:11,840 --> 00:18:18,480
so scaling wise this design goes

00:18:14,960 --> 00:18:20,240
beyond whatever kubernetes and

00:18:18,480 --> 00:18:20,720
prometheus are designed and written

00:18:20,240 --> 00:18:23,760
which

00:18:20,720 --> 00:18:26,640
are in mind the only thing

00:18:23,760 --> 00:18:27,919
where kubernetes really goes to to talk

00:18:26,640 --> 00:18:30,400
about changes uh

00:18:27,919 --> 00:18:32,000
the only observability tool um the

00:18:30,400 --> 00:18:34,799
kubernetes people talk with

00:18:32,000 --> 00:18:35,760
is prometheus for the simple reason that

00:18:34,799 --> 00:18:37,760
the people doing it

00:18:35,760 --> 00:18:39,600
on both kubernetes side and prometheus

00:18:37,760 --> 00:18:42,000
side are literally the same people

00:18:39,600 --> 00:18:42,799
so this overlap both from the initial

00:18:42,000 --> 00:18:44,640
routes

00:18:42,799 --> 00:18:46,400
and from design goals and just

00:18:44,640 --> 00:18:49,200
operational sense

00:18:46,400 --> 00:18:51,039
and from personal overlap they are made

00:18:49,200 --> 00:18:54,080
for each other

00:18:51,039 --> 00:18:55,840
some more scaling data

00:18:54,080 --> 00:18:58,000
having more than a million samples per

00:18:55,840 --> 00:19:01,520
second is absolutely no problem on

00:18:58,000 --> 00:19:04,480
any current hardware or cloud nodes

00:19:01,520 --> 00:19:05,440
um roughly speaking 200k samples per

00:19:04,480 --> 00:19:09,760
second in core

00:19:05,440 --> 00:19:12,799
that's a good indication of of how much

00:19:09,760 --> 00:19:15,360
you can ingest and if you

00:19:12,799 --> 00:19:15,919
remember that we have two times 64 bit

00:19:15,360 --> 00:19:18,880
values

00:19:15,919 --> 00:19:19,360
for for the actual data and 16 bytes per

00:19:18,880 --> 00:19:21,919
sample

00:19:19,360 --> 00:19:24,640
and this compresses with our mechanisms

00:19:21,919 --> 00:19:27,760
down to 1.3 px bytes

00:19:24,640 --> 00:19:30,240
on average in huge data sets so that's

00:19:27,760 --> 00:19:31,919
pretty good i would say the highest

00:19:30,240 --> 00:19:34,799
which we saw in production on a

00:19:31,919 --> 00:19:35,360
single prometheus instance were 15

00:19:34,799 --> 00:19:38,559
million

00:19:35,360 --> 00:19:40,960
active series at once as in 15 million

00:19:38,559 --> 00:19:42,400
serious time series which are currently

00:19:40,960 --> 00:19:44,000
being ingested by

00:19:42,400 --> 00:19:46,640
that prometheus server and can be

00:19:44,000 --> 00:19:49,520
cleared and everything

00:19:46,640 --> 00:19:50,880
which is quite a lot for one single node

00:19:49,520 --> 00:19:52,400
especially

00:19:50,880 --> 00:19:54,240
there are also solutions for long-term

00:19:52,400 --> 00:19:55,840
storage um

00:19:54,240 --> 00:19:57,520
the two ones which have actual

00:19:55,840 --> 00:19:59,520
prometheus team members working on them

00:19:57,520 --> 00:20:02,240
are thanos and cortex

00:19:59,520 --> 00:20:03,200
historically thanos is easier to run and

00:20:02,240 --> 00:20:05,280
it

00:20:03,200 --> 00:20:06,720
its main approach is to scale storage

00:20:05,280 --> 00:20:09,039
horizontally

00:20:06,720 --> 00:20:11,760
cortex used to be pretty hard to run and

00:20:09,039 --> 00:20:13,840
is pretty simple to run these days

00:20:11,760 --> 00:20:15,120
initially it started by scaling the

00:20:13,840 --> 00:20:19,280
query front end

00:20:15,120 --> 00:20:22,320
to make queries paralyzable now it also

00:20:19,280 --> 00:20:24,880
scales the storage with exactly the same

00:20:22,320 --> 00:20:28,159
mechanisms which thanos is using

00:20:24,880 --> 00:20:30,320
and both thanos and cortex are

00:20:28,159 --> 00:20:32,080
trying to to stay close when it comes to

00:20:30,320 --> 00:20:33,120
tech like initially they diverge because

00:20:32,080 --> 00:20:34,880
the

00:20:33,120 --> 00:20:36,559
the scaling point the horizontal scaling

00:20:34,880 --> 00:20:39,039
point was chosen differently

00:20:36,559 --> 00:20:40,640
but they are trying to converge back and

00:20:39,039 --> 00:20:42,960
i keep annoying people

00:20:40,640 --> 00:20:43,760
for years now about core thanos and this

00:20:42,960 --> 00:20:45,919
is actually

00:20:43,760 --> 00:20:47,440
something which which at the back of

00:20:45,919 --> 00:20:49,600
people's heads

00:20:47,440 --> 00:20:51,760
at least exists as a content because it

00:20:49,600 --> 00:20:53,679
would be nice to actually merge those

00:20:51,760 --> 00:20:56,799
two long-term storages

00:20:53,679 --> 00:21:00,840
back together into one so

00:20:56,799 --> 00:21:02,320
how can we leverage this outside of just

00:21:00,840 --> 00:21:05,760
prometheus

00:21:02,320 --> 00:21:07,679
let's talk about metrics prometheus is

00:21:05,760 --> 00:21:09,520
the defective standard in cloud native

00:21:07,679 --> 00:21:12,799
metric monitoring

00:21:09,520 --> 00:21:15,600
but it has been for years and

00:21:12,799 --> 00:21:16,000
it's starting to take hold or it has

00:21:15,600 --> 00:21:18,159
already

00:21:16,000 --> 00:21:19,039
started to take hold way beyond just

00:21:18,159 --> 00:21:23,120
cloud native

00:21:19,039 --> 00:21:25,760
uh environments in particular networking

00:21:23,120 --> 00:21:27,679
is is a field where i see lots and lots

00:21:25,760 --> 00:21:29,440
and lots of prometheus

00:21:27,679 --> 00:21:30,880
and by extension the same is true for

00:21:29,440 --> 00:21:32,080
the promethean exposition format of

00:21:30,880 --> 00:21:33,360
course everywhere where you have

00:21:32,080 --> 00:21:34,880
prometheus

00:21:33,360 --> 00:21:36,400
you also have the exposition formula of

00:21:34,880 --> 00:21:37,919
prometheus because that's the only thing

00:21:36,400 --> 00:21:40,400
which prometheus can ingest and

00:21:37,919 --> 00:21:43,280
understand

00:21:40,400 --> 00:21:45,600
this ease of exposing data which you saw

00:21:43,280 --> 00:21:47,840
earlier has led to an absolute explosion

00:21:45,600 --> 00:21:50,080
in competitive matrix endpoints

00:21:47,840 --> 00:21:51,760
and there is thousands and thousands of

00:21:50,080 --> 00:21:53,919
exporters and integrations which were

00:21:51,760 --> 00:21:56,840
not created by us but by other people

00:21:53,919 --> 00:21:58,240
who wanted to use this power for

00:21:56,840 --> 00:22:01,200
themselves

00:21:58,240 --> 00:22:03,520
we have standard exporters for for much

00:22:01,200 --> 00:22:05,360
use thing which we maintain ourselves

00:22:03,520 --> 00:22:07,440
and we also have standard libraries

00:22:05,360 --> 00:22:09,919
which you can take and then put

00:22:07,440 --> 00:22:11,360
into your own code to integrate with

00:22:09,919 --> 00:22:15,600
whatever and start emitting

00:22:11,360 --> 00:22:17,440
your data some other project and vendors

00:22:15,600 --> 00:22:18,080
were torn about adopting something which

00:22:17,440 --> 00:22:20,880
was named

00:22:18,080 --> 00:22:22,559
after prometheus for obvious reasons and

00:22:20,880 --> 00:22:24,320
especially more traditional vendors

00:22:22,559 --> 00:22:26,480
especially in the networking

00:22:24,320 --> 00:22:28,720
world prefer to support official

00:22:26,480 --> 00:22:30,799
standards

00:22:28,720 --> 00:22:32,640
so that's where openmetrics is coming

00:22:30,799 --> 00:22:34,720
from to reuse the space

00:22:32,640 --> 00:22:35,760
of or to reuse this installed base of

00:22:34,720 --> 00:22:38,400
prometheus and

00:22:35,760 --> 00:22:38,799
to reuse this ease of adoption and to

00:22:38,400 --> 00:22:41,919
have

00:22:38,799 --> 00:22:42,880
a very focused and concise and

00:22:41,919 --> 00:22:45,520
opinionate

00:22:42,880 --> 00:22:47,039
opinionated standard about how to do

00:22:45,520 --> 00:22:50,080
metrics monitoring

00:22:47,039 --> 00:22:51,840
or how to transmit data how to transmit

00:22:50,080 --> 00:22:54,000
metrics data

00:22:51,840 --> 00:22:54,880
rejecting this kitchen sink approach

00:22:54,000 --> 00:22:58,159
where you try to

00:22:54,880 --> 00:22:58,720
to do all things poorly do one thing do

00:22:58,159 --> 00:23:01,760
it well

00:22:58,720 --> 00:23:03,520
the old unix dodge

00:23:01,760 --> 00:23:06,080
many many different companies

00:23:03,520 --> 00:23:08,159
collaborated on the the open metrics

00:23:06,080 --> 00:23:10,240
umbrella which is again nice course with

00:23:08,159 --> 00:23:13,280
the prometheus name that wasn't really

00:23:10,240 --> 00:23:16,080
uh possible cause politics

00:23:13,280 --> 00:23:16,720
and the result is an actual neutral

00:23:16,080 --> 00:23:20,400
standard

00:23:16,720 --> 00:23:23,520
um we are weeks before submitting this

00:23:20,400 --> 00:23:25,440
as an actual rfc or an internet draft to

00:23:23,520 --> 00:23:28,960
the itf to then make an ifc

00:23:25,440 --> 00:23:29,760
out of this but there's more than just

00:23:28,960 --> 00:23:31,520
metrics

00:23:29,760 --> 00:23:34,640
if you've heard of the three pillars of

00:23:31,520 --> 00:23:36,240
observability metrics logs and traces

00:23:34,640 --> 00:23:38,000
metrics are super nice for alerting

00:23:36,240 --> 00:23:39,520
obviously and for dashboarding and also

00:23:38,000 --> 00:23:42,799
for

00:23:39,520 --> 00:23:46,240
enabling machines to understand the data

00:23:42,799 --> 00:23:47,919
a i and l are the current buzzwords logs

00:23:46,240 --> 00:23:49,840
are super nice for due diligence for

00:23:47,919 --> 00:23:51,200
debugging incident response basically

00:23:49,840 --> 00:23:52,880
where you need to understand what

00:23:51,200 --> 00:23:54,480
specific thing happened at what

00:23:52,880 --> 00:23:56,240
particular point

00:23:54,480 --> 00:23:57,520
and traces are obviously super nice for

00:23:56,240 --> 00:23:59,520
the both e-body

00:23:57,520 --> 00:24:01,360
debugging and also performance tuning to

00:23:59,520 --> 00:24:03,039
understand why that one thing was on the

00:24:01,360 --> 00:24:04,320
long tail of latency why that one

00:24:03,039 --> 00:24:06,320
request took two seconds

00:24:04,320 --> 00:24:09,760
like really looking into what the code

00:24:06,320 --> 00:24:12,799
did what what the problem was

00:24:09,760 --> 00:24:15,919
when i started openmetrics in 2015

00:24:12,799 --> 00:24:18,159
my plan was from that day to have also

00:24:15,919 --> 00:24:20,880
label based login format

00:24:18,159 --> 00:24:22,720
to basically take that power of how

00:24:20,880 --> 00:24:24,960
prometheus does it and also apply this

00:24:22,720 --> 00:24:27,600
to to logging

00:24:24,960 --> 00:24:29,039
and in 2016 google shared that what they

00:24:27,600 --> 00:24:33,360
use internally for traces

00:24:29,039 --> 00:24:35,200
were not were not label sets but example

00:24:33,360 --> 00:24:38,880
switches just an id

00:24:35,200 --> 00:24:42,720
which you can use to jump from um

00:24:38,880 --> 00:24:43,840
from your metrics and now logs to xm uh

00:24:42,720 --> 00:24:45,360
two traces

00:24:43,840 --> 00:24:47,919
and when google tells you that searching

00:24:45,360 --> 00:24:50,559
doesn't scale you better listen so i did

00:24:47,919 --> 00:24:52,720
and that's why uh openmetrics has

00:24:50,559 --> 00:24:54,960
has excellers as a first class supported

00:24:52,720 --> 00:24:54,960
thing

00:24:55,120 --> 00:25:01,760
and this is not a joke

00:24:58,960 --> 00:25:02,400
i actually did start openmetrics to

00:25:01,760 --> 00:25:06,400
change

00:25:02,400 --> 00:25:06,960
the world which might sound like a large

00:25:06,400 --> 00:25:10,240
claim and

00:25:06,960 --> 00:25:13,520
it kind of is or it really is but i

00:25:10,240 --> 00:25:16,559
really do mean it because

00:25:13,520 --> 00:25:18,400
how prometheus changed the metrics based

00:25:16,559 --> 00:25:19,840
monitoring world where you have your

00:25:18,400 --> 00:25:21,440
label sets and where you have your

00:25:19,840 --> 00:25:24,480
basically vector math

00:25:21,440 --> 00:25:25,840
on on your data i wanted to take the

00:25:24,480 --> 00:25:28,320
power and to apply to

00:25:25,840 --> 00:25:30,559
more things around the world for metrics

00:25:28,320 --> 00:25:33,679
based and also take it further with

00:25:30,559 --> 00:25:36,080
logs and with traces

00:25:33,679 --> 00:25:37,200
so for logs i'm super happy that grafana

00:25:36,080 --> 00:25:40,880
lab started loki

00:25:37,200 --> 00:25:42,799
some time ago loki 101 it has the same

00:25:40,880 --> 00:25:45,279
label based system like prometheus

00:25:42,799 --> 00:25:46,799
it does not need a full text index

00:25:45,279 --> 00:25:48,960
because it only indexes

00:25:46,799 --> 00:25:50,240
the labels which gives it incredible

00:25:48,960 --> 00:25:51,679
speed

00:25:50,240 --> 00:25:53,520
obviously it works at scale of course

00:25:51,679 --> 00:25:55,600
you don't have this huge overhead of

00:25:53,520 --> 00:25:57,440
full text index

00:25:55,600 --> 00:25:59,039
you can access your logs with exactly

00:25:57,440 --> 00:25:59,840
the same label set so you can jump

00:25:59,039 --> 00:26:02,240
seamlessly

00:25:59,840 --> 00:26:03,600
in between your logs and your metrics

00:26:02,240 --> 00:26:07,120
and back and forth

00:26:03,600 --> 00:26:07,600
super nice you can obviously take your

00:26:07,120 --> 00:26:10,400
logs

00:26:07,600 --> 00:26:11,840
turn them into a matrix and apply the

00:26:10,400 --> 00:26:13,360
same label sets and everything and then

00:26:11,840 --> 00:26:15,200
they're just living in prometheus or

00:26:13,360 --> 00:26:17,919
cortex or thanos or what have you

00:26:15,200 --> 00:26:19,919
and you can use the same queries to to

00:26:17,919 --> 00:26:21,520
access data which was generated from

00:26:19,919 --> 00:26:24,080
your logs

00:26:21,520 --> 00:26:25,919
and you can take syslog data and you can

00:26:24,080 --> 00:26:27,279
take all kinds of other log data and

00:26:25,919 --> 00:26:31,360
just put it

00:26:27,279 --> 00:26:33,679
into into loki the format is

00:26:31,360 --> 00:26:35,679
pretty similar to prometheus um you have

00:26:33,679 --> 00:26:38,240
the timestamp course obviously with with

00:26:35,679 --> 00:26:39,679
events you always have a timestamp

00:26:38,240 --> 00:26:41,039
you have your label set same as

00:26:39,679 --> 00:26:41,840
prometheus and then you have your

00:26:41,039 --> 00:26:44,480
contents

00:26:41,840 --> 00:26:45,120
context content which from loki's

00:26:44,480 --> 00:26:48,720
perspective

00:26:45,120 --> 00:26:50,840
is just an opaque string i talked a lot

00:26:48,720 --> 00:26:53,840
so i let those numbers just talk for

00:26:50,840 --> 00:26:53,840
themselves

00:27:11,440 --> 00:27:15,200
that's the first time i tried this trick

00:27:13,039 --> 00:27:17,279
so please in the q a or in feedback let

00:27:15,200 --> 00:27:19,440
me know if if that was actually good or

00:27:17,279 --> 00:27:22,480
not

00:27:19,440 --> 00:27:25,600
and let's look at tracing for a second

00:27:22,480 --> 00:27:28,960
pareto pareto pareto 80 20.

00:27:25,600 --> 00:27:32,000
matrix logs and traces are in this order

00:27:28,960 --> 00:27:34,080
simply because you get the most benefit

00:27:32,000 --> 00:27:35,200
when you when you start doing something

00:27:34,080 --> 00:27:37,760
different when you

00:27:35,200 --> 00:27:38,720
start with the metrics then come logs

00:27:37,760 --> 00:27:41,039
then come traces

00:27:38,720 --> 00:27:42,000
in this order that's just relative

00:27:41,039 --> 00:27:45,360
effort

00:27:42,000 --> 00:27:47,520
and how much you need as a as a

00:27:45,360 --> 00:27:50,240
as work done before before you can start

00:27:47,520 --> 00:27:52,080
leveraging the other like for real

00:27:50,240 --> 00:27:53,279
tracing as of today still has a needle

00:27:52,080 --> 00:27:55,520
and hates that problem

00:27:53,279 --> 00:27:56,880
of course you usually have your index

00:27:55,520 --> 00:27:59,120
data attached

00:27:56,880 --> 00:27:59,919
to those two those traces and then you

00:27:59,120 --> 00:28:03,120
need to start

00:27:59,919 --> 00:28:05,360
searching for stuff examples are

00:28:03,120 --> 00:28:06,960
more efficient of course they allow you

00:28:05,360 --> 00:28:09,200
to jump directly

00:28:06,960 --> 00:28:10,000
from this interesting from this

00:28:09,200 --> 00:28:11,919
interesting

00:28:10,000 --> 00:28:13,679
metric from this interesting log from

00:28:11,919 --> 00:28:16,480
this long tail latency

00:28:13,679 --> 00:28:18,000
directly to the one trace which is

00:28:16,480 --> 00:28:20,240
interesting

00:28:18,000 --> 00:28:22,799
and obviously this also works at google

00:28:20,240 --> 00:28:24,559
scale of course that's what google uses

00:28:22,799 --> 00:28:26,240
and why i'm not one of those people who

00:28:24,559 --> 00:28:27,840
say well a large company did it so

00:28:26,240 --> 00:28:31,760
everyone else has to emulate this

00:28:27,840 --> 00:28:33,679
far from the if something works at

00:28:31,760 --> 00:28:35,600
scale and you can also make it work

00:28:33,679 --> 00:28:38,320
again smaller scales

00:28:35,600 --> 00:28:40,159
it's obviously nicer than if it wouldn't

00:28:38,320 --> 00:28:43,039
work large scales that's

00:28:40,159 --> 00:28:45,039
again almost total logic in my opinion

00:28:43,039 --> 00:28:47,600
the tracing space has room for future

00:28:45,039 --> 00:28:47,600
improvements

00:28:48,240 --> 00:28:52,080
if you bring all of this together what

00:28:49,760 --> 00:28:55,200
you get is you have your thing

00:28:52,080 --> 00:28:57,679
and you have your workflow of

00:28:55,200 --> 00:28:58,720
something breaks they can actually jump

00:28:57,679 --> 00:29:01,919
through everything

00:28:58,720 --> 00:29:04,000
with exactly the same

00:29:01,919 --> 00:29:05,120
labor sets or exactly the same indexing

00:29:04,000 --> 00:29:07,520
data

00:29:05,120 --> 00:29:08,320
walk through everything get an

00:29:07,520 --> 00:29:13,200
understanding

00:29:08,320 --> 00:29:16,799
by humans and then to actual engineering

00:29:13,200 --> 00:29:16,799

YouTube URL: https://www.youtube.com/watch?v=9sQvVfgBykU


