Title: KNative 101: Overview & Roadmap - Matt Moore, VMware
Publication date: 2020-10-26
Playlist: Cloud Foundry Summit Europe 2020
Description: 
	KNative 101: Overview & Roadmap - Matt Moore, VMware

Overview and roadmap of the KNative project.
Captions: 
	00:00:00,080 --> 00:00:03,600
hello everyone and welcome to k-native

00:00:01,680 --> 00:00:05,600
101 i'm matt moore i'm one of the

00:00:03,600 --> 00:00:07,120
founders of k-native i lead the serving

00:00:05,600 --> 00:00:09,840
area of the project and i sit on the

00:00:07,120 --> 00:00:10,800
technical oversight committee before we

00:00:09,840 --> 00:00:13,280
get started i want to

00:00:10,800 --> 00:00:14,160
thank evan anderson for giving a really

00:00:13,280 --> 00:00:16,880
fantastic

00:00:14,160 --> 00:00:17,199
similar longer presentation on this that

00:00:16,880 --> 00:00:20,960
i

00:00:17,199 --> 00:00:20,960
borrowed a lot of slides from

00:00:22,560 --> 00:00:26,720
before we get started let's talk a

00:00:24,080 --> 00:00:29,439
little bit about the goals of k-native

00:00:26,720 --> 00:00:30,720
we wanted to achieve a serverless style

00:00:29,439 --> 00:00:34,079
user experience

00:00:30,720 --> 00:00:35,520
that lived on top of kubernetes and

00:00:34,079 --> 00:00:36,960
when we were starting to think about

00:00:35,520 --> 00:00:38,399
what we needed in order to do this we

00:00:36,960 --> 00:00:39,520
identified three main areas where there

00:00:38,399 --> 00:00:41,200
were gaps

00:00:39,520 --> 00:00:42,559
that we needed to fill in order to

00:00:41,200 --> 00:00:44,079
devise a solution

00:00:42,559 --> 00:00:45,360
one of those areas was taking your

00:00:44,079 --> 00:00:46,079
source code and turning it into a

00:00:45,360 --> 00:00:48,800
container

00:00:46,079 --> 00:00:49,440
which we called build one of those areas

00:00:48,800 --> 00:00:51,760
was

00:00:49,440 --> 00:00:53,280
um being able to scale your

00:00:51,760 --> 00:00:54,000
container-based workload based on

00:00:53,280 --> 00:00:56,239
requests

00:00:54,000 --> 00:00:58,160
we called this serving and the final

00:00:56,239 --> 00:01:00,079
area was how we brought events into the

00:00:58,160 --> 00:01:03,440
system and how we reasoned about events

00:01:00,079 --> 00:01:05,119
and we called this area event we wanted

00:01:03,440 --> 00:01:06,960
these to stand on their own

00:01:05,119 --> 00:01:08,240
but also to be highly complementary so

00:01:06,960 --> 00:01:09,840
that folks could build survival

00:01:08,240 --> 00:01:12,960
solutions on top of

00:01:09,840 --> 00:01:14,479
these components and kubernetes

00:01:12,960 --> 00:01:16,000
and as a sort of testament to our

00:01:14,479 --> 00:01:18,479
success here um

00:01:16,000 --> 00:01:19,360
we eventually spun build out as the seed

00:01:18,479 --> 00:01:21,119
for

00:01:19,360 --> 00:01:23,520
uh what would become the tecton project

00:01:21,119 --> 00:01:25,680
a very successful open source community

00:01:23,520 --> 00:01:27,520
in its own right

00:01:25,680 --> 00:01:29,280
so when folks talk about key native

00:01:27,520 --> 00:01:31,840
today they're typically talking about

00:01:29,280 --> 00:01:33,920
these serving and eventing pieces

00:01:31,840 --> 00:01:36,079
surveying has two main areas of

00:01:33,920 --> 00:01:37,759
investment within that umbrella

00:01:36,079 --> 00:01:39,920
auto scaling which handles the request

00:01:37,759 --> 00:01:42,159
based scaling and networking where we

00:01:39,920 --> 00:01:45,200
handle integration with various

00:01:42,159 --> 00:01:48,399
ingress layers like those listed here

00:01:45,200 --> 00:01:50,000
at a half a dozen or so these days

00:01:48,399 --> 00:01:52,159
on the eventing side there are sort of

00:01:50,000 --> 00:01:54,399
two areas of focus as well

00:01:52,159 --> 00:01:55,520
there's bringing events into the system

00:01:54,399 --> 00:01:57,520
from

00:01:55,520 --> 00:01:58,560
literally anything that could emit of an

00:01:57,520 --> 00:02:01,200
event could have

00:01:58,560 --> 00:02:02,719
a source associated with it and then

00:02:01,200 --> 00:02:03,840
there's how we model and deliver those

00:02:02,719 --> 00:02:06,960
events within our

00:02:03,840 --> 00:02:08,720
eventing model and we have integrations

00:02:06,960 --> 00:02:10,560
uh and implementations of those

00:02:08,720 --> 00:02:12,080
abstractions that sit on top of

00:02:10,560 --> 00:02:14,160
you know a whole bunch of different

00:02:12,080 --> 00:02:15,200
messaging systems like maths and kafka

00:02:14,160 --> 00:02:17,440
and rabbit

00:02:15,200 --> 00:02:18,959
as well as cloud vendor ones like gcp

00:02:17,440 --> 00:02:22,000
pub sub

00:02:18,959 --> 00:02:24,959
so today we are going to focus

00:02:22,000 --> 00:02:26,720
in on serving because that really is i

00:02:24,959 --> 00:02:28,160
think one of the areas of the project

00:02:26,720 --> 00:02:31,920
that aligns most with

00:02:28,160 --> 00:02:36,000
cloud foundry and this is cf summit

00:02:31,920 --> 00:02:38,160
so to drive to drill in here

00:02:36,000 --> 00:02:39,840
let's talk about the anatomy of a

00:02:38,160 --> 00:02:41,519
service the service resource is sort of

00:02:39,840 --> 00:02:42,480
the one resource to rule them all in

00:02:41,519 --> 00:02:43,760
cumulative survey

00:02:42,480 --> 00:02:45,360
and so let's talk about the resource

00:02:43,760 --> 00:02:46,400
model a little bit sort of broken down

00:02:45,360 --> 00:02:48,879
from there

00:02:46,400 --> 00:02:50,640
so the service is a simplified api over

00:02:48,879 --> 00:02:52,319
two other resources within our model

00:02:50,640 --> 00:02:54,319
that you can use directly but hopefully

00:02:52,319 --> 00:02:56,160
you don't need to

00:02:54,319 --> 00:02:57,680
the route and the configuration so the

00:02:56,160 --> 00:02:59,840
configuration

00:02:57,680 --> 00:03:01,599
is effectively a description of how to

00:02:59,840 --> 00:03:05,200
run what

00:03:01,599 --> 00:03:06,959
and the route is effectively what

00:03:05,200 --> 00:03:09,680
makes different versions of that

00:03:06,959 --> 00:03:12,319
accessible and so you can see this

00:03:09,680 --> 00:03:14,480
a simple example of a service on the

00:03:12,319 --> 00:03:16,959
bottom left here in yaml because

00:03:14,480 --> 00:03:18,720
that's you know what folks do with

00:03:16,959 --> 00:03:19,599
kubernetes right they throw the ammo on

00:03:18,720 --> 00:03:21,440
it

00:03:19,599 --> 00:03:22,959
so if you were to apply this you would

00:03:21,440 --> 00:03:26,080
get typically

00:03:22,959 --> 00:03:28,640
two urls one that's available external

00:03:26,080 --> 00:03:30,400
to the cluster and one that's available

00:03:28,640 --> 00:03:32,080
within the cluster and so

00:03:30,400 --> 00:03:33,760
we followed the kubernetes style here

00:03:32,080 --> 00:03:35,120
and constructing these urls and the

00:03:33,760 --> 00:03:36,720
first part of the hostname

00:03:35,120 --> 00:03:38,480
is based on the name of the resource and

00:03:36,720 --> 00:03:40,959
the second part of the hostname is based

00:03:38,480 --> 00:03:44,480
on the namespace

00:03:40,959 --> 00:03:46,319
so since it's cf summit i was encouraged

00:03:44,480 --> 00:03:47,680
and you all love your cli i was

00:03:46,319 --> 00:03:49,360
encouraged to also show

00:03:47,680 --> 00:03:51,519
that you can do the same thing without

00:03:49,360 --> 00:03:52,640
the yaml right through the cl iso can

00:03:51,519 --> 00:03:55,120
service create

00:03:52,640 --> 00:03:55,920
you specify the name space and the name

00:03:55,120 --> 00:04:00,319
and the image

00:03:55,920 --> 00:04:03,040
and you can create the same service

00:04:00,319 --> 00:04:03,760
so let's drill in a little bit deeper

00:04:03,040 --> 00:04:06,400
into

00:04:03,760 --> 00:04:08,480
uh first configuration right i described

00:04:06,400 --> 00:04:11,920
this as how to run one

00:04:08,480 --> 00:04:14,720
and so the configuration effectively uh

00:04:11,920 --> 00:04:16,239
tracks the the uh how you want to run

00:04:14,720 --> 00:04:19,600
your software and

00:04:16,239 --> 00:04:20,479
as you update it it stamps out revisions

00:04:19,600 --> 00:04:23,520
which are

00:04:20,479 --> 00:04:28,160
uh basically you know point in time

00:04:23,520 --> 00:04:30,639
snapshots of that description and so

00:04:28,160 --> 00:04:32,000
uh you can think of it a lot like the

00:04:30,639 --> 00:04:33,520
head of a branch in your favorite

00:04:32,000 --> 00:04:35,680
version control system

00:04:33,520 --> 00:04:36,560
whereas the revisions are like you know

00:04:35,680 --> 00:04:39,199
commits if

00:04:36,560 --> 00:04:41,120
we're talking gig they're immutable they

00:04:39,199 --> 00:04:42,000
represent sort of how to run what at a

00:04:41,120 --> 00:04:44,000
particular point

00:04:42,000 --> 00:04:45,919
in time and configuration is really the

00:04:44,000 --> 00:04:49,520
the collection of those

00:04:45,919 --> 00:04:53,759
um you know tracking the latest one

00:04:49,520 --> 00:04:55,040
now the route i describe the route as

00:04:53,759 --> 00:04:56,639
controlling which versions are

00:04:55,040 --> 00:04:58,400
accessible so now that we have these

00:04:56,639 --> 00:05:00,479
revisions in this configuration

00:04:58,400 --> 00:05:02,000
the route can point at particular

00:05:00,479 --> 00:05:04,720
revisions to

00:05:02,000 --> 00:05:05,840
give you very fine control over which

00:05:04,720 --> 00:05:08,400
versions of that

00:05:05,840 --> 00:05:10,240
application are accessible to your users

00:05:08,400 --> 00:05:12,240
now you can point to a

00:05:10,240 --> 00:05:13,360
single specific revision if you wanted

00:05:12,240 --> 00:05:15,440
to um

00:05:13,360 --> 00:05:16,800
you know be very controlled about which

00:05:15,440 --> 00:05:19,199
versions get rolled out

00:05:16,800 --> 00:05:19,840
or you can point to a specific word to

00:05:19,199 --> 00:05:22,960
roll

00:05:19,840 --> 00:05:24,960
back to a previous last known good if

00:05:22,960 --> 00:05:27,120
you have some sort of issue

00:05:24,960 --> 00:05:28,880
you can traffic split across these or

00:05:27,120 --> 00:05:30,560
you can just point the revision at the

00:05:28,880 --> 00:05:32,400
configuration if you just wanted to

00:05:30,560 --> 00:05:36,240
constantly roll out the latest

00:05:32,400 --> 00:05:37,680
ready revision as the configuration gets

00:05:36,240 --> 00:05:39,120
updated and this is the default mode

00:05:37,680 --> 00:05:42,720
that we

00:05:39,120 --> 00:05:44,160
use with our service so now that we've

00:05:42,720 --> 00:05:45,919
talked about the resource model a little

00:05:44,160 --> 00:05:48,880
bit let's talk about

00:05:45,919 --> 00:05:51,280
the data path and what happens there so

00:05:48,880 --> 00:05:52,960
one of the goals with k-native was

00:05:51,280 --> 00:05:55,360
when you have the system and you're

00:05:52,960 --> 00:05:58,560
putting it under near constant load

00:05:55,360 --> 00:06:01,199
uh the the overhead of k-native is

00:05:58,560 --> 00:06:02,639
as little as possible and so we've put a

00:06:01,199 --> 00:06:04,960
lot of elements on the slide

00:06:02,639 --> 00:06:06,080
that you typically have the one thing

00:06:04,960 --> 00:06:08,400
you wouldn't have

00:06:06,080 --> 00:06:10,080
uh if you weren't using k native is our

00:06:08,400 --> 00:06:11,680
q proxy sign here and hopefully you'll

00:06:10,080 --> 00:06:14,720
see in the coming slides

00:06:11,680 --> 00:06:16,880
why that's interesting and important so

00:06:14,720 --> 00:06:19,680
one of the use cases of this

00:06:16,880 --> 00:06:21,840
q proxy is to support the idea of

00:06:19,680 --> 00:06:22,479
bounded concurrency so in typical fast

00:06:21,840 --> 00:06:25,280
systems

00:06:22,479 --> 00:06:27,039
like you know lambdas your google cloud

00:06:25,280 --> 00:06:29,680
functions and whatnot

00:06:27,039 --> 00:06:31,919
there's this idea that only a single

00:06:29,680 --> 00:06:34,720
request is let through to your function

00:06:31,919 --> 00:06:35,199
to each instance of your function at a

00:06:34,720 --> 00:06:36,800
time

00:06:35,199 --> 00:06:39,039
and so this this has some really nice

00:06:36,800 --> 00:06:39,360
properties uh you don't have to worry as

00:06:39,039 --> 00:06:41,199
much

00:06:39,360 --> 00:06:42,639
about you know locking global state

00:06:41,199 --> 00:06:45,600
within your process

00:06:42,639 --> 00:06:46,240
and it allows you to reason about the

00:06:45,600 --> 00:06:49,120
amount of

00:06:46,240 --> 00:06:49,759
resources that each instance of your

00:06:49,120 --> 00:06:51,520
function

00:06:49,759 --> 00:06:52,800
has available to it to process each

00:06:51,520 --> 00:06:55,520
request

00:06:52,800 --> 00:06:57,599
now the q proxy sits on the data path to

00:06:55,520 --> 00:06:58,240
effectively make sure that only a single

00:06:57,599 --> 00:07:02,080
request

00:06:58,240 --> 00:07:03,520
or if you make a concurrency three it

00:07:02,080 --> 00:07:04,720
makes sure that you know the appropriate

00:07:03,520 --> 00:07:05,840
number of requests are being allowed

00:07:04,720 --> 00:07:08,080
through to the user container

00:07:05,840 --> 00:07:08,960
at a given time so this is allows folks

00:07:08,080 --> 00:07:11,199
to build

00:07:08,960 --> 00:07:12,960
um your typical fast models on top of

00:07:11,199 --> 00:07:15,360
community

00:07:12,960 --> 00:07:16,000
so with that q proxy in there it also

00:07:15,360 --> 00:07:18,080
enables us

00:07:16,000 --> 00:07:20,400
to scale the number of container

00:07:18,080 --> 00:07:22,000
replicas based on the request rate so

00:07:20,400 --> 00:07:23,680
without needing to have

00:07:22,000 --> 00:07:26,080
you know deeper visibility into what the

00:07:23,680 --> 00:07:28,720
http layer is doing in front of us

00:07:26,080 --> 00:07:30,000
or requiring the user to do crazy things

00:07:28,720 --> 00:07:33,039
in the user container to expose

00:07:30,000 --> 00:07:33,840
metrics we by having that q proxy there

00:07:33,039 --> 00:07:35,919
it gives us a

00:07:33,840 --> 00:07:37,360
um consistent place that's available on

00:07:35,919 --> 00:07:38,080
the data path all the time to service

00:07:37,360 --> 00:07:39,680
metrics

00:07:38,080 --> 00:07:41,759
and we can make scaling decisions based

00:07:39,680 --> 00:07:43,919
on it so for instance if a

00:07:41,759 --> 00:07:45,919
traffic we see a traffic increase right

00:07:43,919 --> 00:07:48,160
we can spin up additional capacity

00:07:45,919 --> 00:07:49,520
to respond to that one of the

00:07:48,160 --> 00:07:52,080
interesting things when you're

00:07:49,520 --> 00:07:53,759
scaling based on requests though is the

00:07:52,080 --> 00:07:56,080
idea of scaling to zero

00:07:53,759 --> 00:07:57,120
right when we see that the request rate

00:07:56,080 --> 00:08:00,160
has dropped

00:07:57,120 --> 00:08:02,720
to you know not receiving a new request

00:08:00,160 --> 00:08:03,360
we are able to wire in our activator

00:08:02,720 --> 00:08:05,840
component

00:08:03,360 --> 00:08:07,199
and tear down the final remaining pods

00:08:05,840 --> 00:08:09,440
so that at rest

00:08:07,199 --> 00:08:12,400
when you're not receiving any traffic

00:08:09,440 --> 00:08:13,680
there's effectively no cost

00:08:12,400 --> 00:08:15,120
one of the most important things when

00:08:13,680 --> 00:08:15,520
you're scaling two zeros being able to

00:08:15,120 --> 00:08:18,400
scale

00:08:15,520 --> 00:08:20,160
from zero so if that activator receives

00:08:18,400 --> 00:08:23,039
a request

00:08:20,160 --> 00:08:24,800
it is able to bring a pot online just in

00:08:23,039 --> 00:08:27,360
time and forward the request

00:08:24,800 --> 00:08:28,400
to that pot once it's come up and it's

00:08:27,360 --> 00:08:29,680
ready

00:08:28,400 --> 00:08:31,360
so let's pivot a little bit and talk

00:08:29,680 --> 00:08:32,640
about some of the features of the http

00:08:31,360 --> 00:08:34,800
routing layer

00:08:32,640 --> 00:08:36,399
so we mentioned the ability to do

00:08:34,800 --> 00:08:37,839
percentage based splits

00:08:36,399 --> 00:08:40,080
this is actually something that you

00:08:37,839 --> 00:08:43,599
can't do in terms of

00:08:40,080 --> 00:08:45,600
just raw kubernetes resources uh without

00:08:43,599 --> 00:08:47,279
you know targeting a specific ingress

00:08:45,600 --> 00:08:48,880
layer because

00:08:47,279 --> 00:08:51,279
the kubernetes ingress doesn't support

00:08:48,880 --> 00:08:53,440
percentage-based splits and so

00:08:51,279 --> 00:08:55,279
you can do this directly with istio or

00:08:53,440 --> 00:08:57,440
contour one of the ingress layers

00:08:55,279 --> 00:08:58,640
but there isn't a standard way of doing

00:08:57,440 --> 00:09:00,320
this we thought that this was

00:08:58,640 --> 00:09:02,320
fundamentally important to rolling out

00:09:00,320 --> 00:09:03,680
software because you know reasoning in

00:09:02,320 --> 00:09:06,720
terms of percentages

00:09:03,680 --> 00:09:08,399
is just what we want to do

00:09:06,720 --> 00:09:11,279
whereas with kubernetes with raw

00:09:08,399 --> 00:09:13,680
kubernetes you know it's very coarse and

00:09:11,279 --> 00:09:16,000
you know you can get 90 10 but only if

00:09:13,680 --> 00:09:19,600
you have 100 pods basically

00:09:16,000 --> 00:09:23,760
um kicking around and then yeah

00:09:19,600 --> 00:09:25,839
so um so we want to support the idea of

00:09:23,760 --> 00:09:29,040
percentage-based flips now

00:09:25,839 --> 00:09:31,920
uh one of the other things that we do

00:09:29,040 --> 00:09:32,399
in our http layer is we program it so

00:09:31,920 --> 00:09:34,880
that

00:09:32,399 --> 00:09:35,519
as you're doing these rollouts you can

00:09:34,880 --> 00:09:38,720
also

00:09:35,519 --> 00:09:40,160
directly target one of those splits so

00:09:38,720 --> 00:09:42,560
if for instance you're starting to do a

00:09:40,160 --> 00:09:44,480
canary rollout where 99 of your traffic

00:09:42,560 --> 00:09:46,800
is still going to your previous version

00:09:44,480 --> 00:09:47,680
but you want to start to qualify your

00:09:46,800 --> 00:09:49,920
new 1

00:09:47,680 --> 00:09:50,880
canary with very focused testing that

00:09:49,920 --> 00:09:53,360
hits that

00:09:50,880 --> 00:09:54,480
um all the time we have this idea of

00:09:53,360 --> 00:09:57,839
tags where

00:09:54,480 --> 00:10:01,360
you can tag a particular split and

00:09:57,839 --> 00:10:03,360
target that directly with some of your

00:10:01,360 --> 00:10:05,360
loads so if you wanted to probe it

00:10:03,360 --> 00:10:06,079
directly or run tests against it or

00:10:05,360 --> 00:10:07,600
whatnot

00:10:06,079 --> 00:10:10,079
as you're rolling it out and starting to

00:10:07,600 --> 00:10:12,640
qualify it you can do that

00:10:10,079 --> 00:10:12,640
with tax

00:10:13,279 --> 00:10:19,519
okay so let's let's shift away from

00:10:16,560 --> 00:10:21,040
uh the you know features of the control

00:10:19,519 --> 00:10:22,640
plane and the data plane and serving and

00:10:21,040 --> 00:10:23,120
talk a little bit about what's coming

00:10:22,640 --> 00:10:26,800
for

00:10:23,120 --> 00:10:30,320
both game serving but canada in general

00:10:26,800 --> 00:10:32,640
so feature number one uh is all around

00:10:30,320 --> 00:10:34,160
reliability stability scalability

00:10:32,640 --> 00:10:35,519
performance this is our feature number

00:10:34,160 --> 00:10:37,839
one we want to make sure

00:10:35,519 --> 00:10:39,440
that we are not regressing on any of

00:10:37,839 --> 00:10:41,279
these dimensions and frankly improving

00:10:39,440 --> 00:10:43,200
these is pretty fundamental to moving

00:10:41,279 --> 00:10:45,200
a project forward this means bigger

00:10:43,200 --> 00:10:46,240
clusters running more instances serving

00:10:45,200 --> 00:10:49,120
higher traffic

00:10:46,240 --> 00:10:50,240
and more and more testing of these

00:10:49,120 --> 00:10:53,120
different scenarios

00:10:50,240 --> 00:10:53,920
this means smaller clusters think edge

00:10:53,120 --> 00:10:55,360
right

00:10:53,920 --> 00:10:57,760
which means running in a smaller

00:10:55,360 --> 00:11:00,240
footprint and we won't

00:10:57,760 --> 00:11:02,320
we want to constantly drive latency down

00:11:00,240 --> 00:11:04,320
and reduce our release toil

00:11:02,320 --> 00:11:05,360
in addition to you know our feature

00:11:04,320 --> 00:11:07,360
number one

00:11:05,360 --> 00:11:10,160
we also have a whole bunch of additional

00:11:07,360 --> 00:11:12,160
functionality that's coming

00:11:10,160 --> 00:11:14,920
uh one of these is vanity domain so

00:11:12,160 --> 00:11:16,160
instead of being restricted to just

00:11:14,920 --> 00:11:18,800
name.namespace.suffix

00:11:16,160 --> 00:11:19,920
right uh being able to put a very

00:11:18,800 --> 00:11:23,200
specific domain

00:11:19,920 --> 00:11:25,640
on you know your your services so

00:11:23,200 --> 00:11:28,160
you know you serve your blog off of

00:11:25,640 --> 00:11:29,920
www.mapmoore.io o

00:11:28,160 --> 00:11:31,760
it's a much nicer thing for folks to

00:11:29,920 --> 00:11:33,360
remember and type

00:11:31,760 --> 00:11:35,040
uh more sophisticated requests

00:11:33,360 --> 00:11:37,360
dispatching so you know

00:11:35,040 --> 00:11:39,120
being able to dispatch do more than you

00:11:37,360 --> 00:11:42,399
know percentage-based splits and stuff

00:11:39,120 --> 00:11:44,240
like that um request affinity

00:11:42,399 --> 00:11:45,680
being able to dispatch on things like

00:11:44,240 --> 00:11:48,160
method or path

00:11:45,680 --> 00:11:50,959
um these are all things that we've seen

00:11:48,160 --> 00:11:52,800
requests for

00:11:50,959 --> 00:11:54,160
we have a group of folks that are

00:11:52,800 --> 00:11:56,160
investigating whether

00:11:54,160 --> 00:11:58,079
we can find common ground for a

00:11:56,160 --> 00:11:58,560
functions experience on top of k native

00:11:58,079 --> 00:12:00,560
which

00:11:58,560 --> 00:12:02,079
ties together a whole bunch of different

00:12:00,560 --> 00:12:04,320
things um

00:12:02,079 --> 00:12:05,120
and i think we're all sort of hoping to

00:12:04,320 --> 00:12:07,040
find some

00:12:05,120 --> 00:12:08,320
nice common ground there so that we can

00:12:07,040 --> 00:12:11,200
have a common uh

00:12:08,320 --> 00:12:12,480
multi-cloud multi-vendor uh function

00:12:11,200 --> 00:12:15,680
experience that we can

00:12:12,480 --> 00:12:17,680
get behind uh discovery discovery is

00:12:15,680 --> 00:12:20,880
basically a mechanism that we're

00:12:17,680 --> 00:12:22,560
looking into for finding out what event

00:12:20,880 --> 00:12:23,040
types and event schemas are within the

00:12:22,560 --> 00:12:24,800
system

00:12:23,040 --> 00:12:26,560
this pairs really nicely with things

00:12:24,800 --> 00:12:29,519
like the functions experience

00:12:26,560 --> 00:12:30,240
um because if i wanted to scaffold a new

00:12:29,519 --> 00:12:31,680
function

00:12:30,240 --> 00:12:33,839
i could look at what event types are

00:12:31,680 --> 00:12:36,000
available within the system

00:12:33,839 --> 00:12:37,519
uh get their schemas and sort of

00:12:36,000 --> 00:12:41,600
bootstrap a new

00:12:37,519 --> 00:12:43,600
function signature from that um and

00:12:41,600 --> 00:12:45,519
you know it's sort of like i you like

00:12:43,600 --> 00:12:48,800
functionality which is super cool

00:12:45,519 --> 00:12:50,399
and then the last area is another um

00:12:48,800 --> 00:12:52,480
interesting thing we're looking at in

00:12:50,399 --> 00:12:53,279
eventing which is the dual of sources

00:12:52,480 --> 00:12:56,000
which is

00:12:53,279 --> 00:12:58,240
sinks right so where sources are sort of

00:12:56,000 --> 00:13:00,720
events coming into the system

00:12:58,240 --> 00:13:03,440
sinks are about sort of emitting events

00:13:00,720 --> 00:13:05,279
from our eventing model

00:13:03,440 --> 00:13:07,760
and sending them out to external

00:13:05,279 --> 00:13:11,440
messaging systems

00:13:07,760 --> 00:13:11,440
so the last area

00:13:11,680 --> 00:13:16,000
is about sort of aligning with the

00:13:13,760 --> 00:13:16,800
broader ecosystem and sustainability of

00:13:16,000 --> 00:13:19,040
how we

00:13:16,800 --> 00:13:20,800
invest in the project so one of the key

00:13:19,040 --> 00:13:22,000
areas here where we have been investing

00:13:20,800 --> 00:13:24,000
and we'll continue to

00:13:22,000 --> 00:13:25,360
invest is around open governance so a

00:13:24,000 --> 00:13:28,079
couple months ago we had

00:13:25,360 --> 00:13:29,440
our first doc elections and we now have

00:13:28,079 --> 00:13:33,519
a nice multi-vendor

00:13:29,440 --> 00:13:36,880
diverse um technical oversight committee

00:13:33,519 --> 00:13:39,440
we just merged a pr describing

00:13:36,880 --> 00:13:41,519
how we will do a similar style thing for

00:13:39,440 --> 00:13:43,279
our steering committee

00:13:41,519 --> 00:13:44,560
and those elections are going to be

00:13:43,279 --> 00:13:47,839
coming up

00:13:44,560 --> 00:13:49,360
very soon with alignment so there are a

00:13:47,839 --> 00:13:51,120
whole bunch of efforts that we

00:13:49,360 --> 00:13:52,959
as a broader project are aligning with

00:13:51,120 --> 00:13:55,440
cloud events is a really big one

00:13:52,959 --> 00:13:57,120
um that a lot of the folks from our the

00:13:55,440 --> 00:14:00,399
eventing side of our community are

00:13:57,120 --> 00:14:01,440
deeply involved in uh ingress v2 is one

00:14:00,399 --> 00:14:02,800
of those things where

00:14:01,440 --> 00:14:04,480
bringing some of those more

00:14:02,800 --> 00:14:05,440
sophisticated capabilities that weren't

00:14:04,480 --> 00:14:08,959
in anger speed

00:14:05,440 --> 00:14:10,320
one that we wanted into the ingress v2

00:14:08,959 --> 00:14:11,839
definition that's one of the things that

00:14:10,320 --> 00:14:14,079
we're collaborating on

00:14:11,839 --> 00:14:16,320
and then things like endpoint slices

00:14:14,079 --> 00:14:18,560
which kubernetes is uh

00:14:16,320 --> 00:14:20,079
built up as a way of achieving higher

00:14:18,560 --> 00:14:21,680
scale right this this is one of those

00:14:20,079 --> 00:14:22,240
efforts we want to align with in order

00:14:21,680 --> 00:14:24,079
to

00:14:22,240 --> 00:14:26,160
support you know running on bigger

00:14:24,079 --> 00:14:27,839
clusters you know more traffic more

00:14:26,160 --> 00:14:28,959
resources

00:14:27,839 --> 00:14:31,279
we want to get some of the best

00:14:28,959 --> 00:14:34,240
practices we've developed out there

00:14:31,279 --> 00:14:35,680
so things like our duct typing of

00:14:34,240 --> 00:14:38,480
kubernetes resources

00:14:35,680 --> 00:14:39,680
and the way we handle conditions duct

00:14:38,480 --> 00:14:40,959
typing is actually a great example

00:14:39,680 --> 00:14:42,959
because it

00:14:40,959 --> 00:14:44,480
is one of the things that the service

00:14:42,959 --> 00:14:46,399
binding folks the kubernetes service

00:14:44,480 --> 00:14:49,519
binding folks are starting to

00:14:46,399 --> 00:14:50,720
uh look at as a mechanism for binding

00:14:49,519 --> 00:14:52,480
information into

00:14:50,720 --> 00:14:54,240
kubernetes based workloads including

00:14:52,480 --> 00:14:56,240
k-native services and i wanted to

00:14:54,240 --> 00:14:57,600
you know make a point to highlight that

00:14:56,240 --> 00:15:00,720
because

00:14:57,600 --> 00:15:02,639
you know cf summit right one of the

00:15:00,720 --> 00:15:04,320
really cool things in my opinion about

00:15:02,639 --> 00:15:04,959
cloud foundry is this idea of service

00:15:04,320 --> 00:15:07,360
findings

00:15:04,959 --> 00:15:08,480
um and bringing that to kubernetes and

00:15:07,360 --> 00:15:09,760
being able to do that through some of

00:15:08,480 --> 00:15:11,199
the best practices that we've been

00:15:09,760 --> 00:15:13,920
working on in q native

00:15:11,199 --> 00:15:14,560
um you know is really cool to me and

00:15:13,920 --> 00:15:16,480
especially

00:15:14,560 --> 00:15:18,639
you know bringing that to folks making

00:15:16,480 --> 00:15:20,560
sure that we are well aligned with that

00:15:18,639 --> 00:15:21,760
and so that folks can access that

00:15:20,560 --> 00:15:23,519
service binding effort

00:15:21,760 --> 00:15:25,600
within the context of canadian serving

00:15:23,519 --> 00:15:28,079
is also really interesting

00:15:25,600 --> 00:15:29,519
so with that i'm going to put up the

00:15:28,079 --> 00:15:32,240
list of resources

00:15:29,519 --> 00:15:32,959
and i think we're going to switch over

00:15:32,240 --> 00:15:36,160
to

00:15:32,959 --> 00:15:36,160
um questions

00:15:36,639 --> 00:15:41,120
aren't what are your thoughts on using

00:15:39,360 --> 00:15:43,120
k-native components as part of cloud

00:15:41,120 --> 00:15:46,160
foundry on kubernetes

00:15:43,120 --> 00:15:49,199
um so uh

00:15:46,160 --> 00:15:51,600
good question i mean uh i

00:15:49,199 --> 00:15:52,480
i will admit that i am not deeply

00:15:51,600 --> 00:15:54,240
familiar with

00:15:52,480 --> 00:15:55,600
sort of the inner workings of claude

00:15:54,240 --> 00:15:58,399
foundry um

00:15:55,600 --> 00:15:59,759
but you know i know there's uh

00:15:58,399 --> 00:16:02,959
interesting overlaps

00:15:59,759 --> 00:16:04,959
and i think i'm supportive of sort of

00:16:02,959 --> 00:16:06,880
exploring that direction and supporting

00:16:04,959 --> 00:16:11,199
it um

00:16:06,880 --> 00:16:14,560
but uh i honestly i think um

00:16:11,199 --> 00:16:15,839
uh you know i defer to

00:16:14,560 --> 00:16:17,360
it you know there's there's a lot of

00:16:15,839 --> 00:16:18,320
folks actually within the k-native

00:16:17,360 --> 00:16:22,639
community that

00:16:18,320 --> 00:16:27,040
um have a lot more sort of

00:16:22,639 --> 00:16:27,600
background in cf than i do like dr jules

00:16:27,040 --> 00:16:30,320
and

00:16:27,600 --> 00:16:30,720
frankly a lot of the folks um from ibm i

00:16:30,320 --> 00:16:33,360
think

00:16:30,720 --> 00:16:35,440
uh come from uh sort of a cloud foundry

00:16:33,360 --> 00:16:39,440
background so

00:16:35,440 --> 00:16:42,480
um i think you know uh

00:16:39,440 --> 00:16:44,240
i'm it's

00:16:42,480 --> 00:16:46,160
it's an interesting direction to talk

00:16:44,240 --> 00:16:48,480
about but um i think i'd

00:16:46,160 --> 00:16:48,480
you know

00:16:49,279 --> 00:16:56,320
defer to those uh experts on sort of

00:16:52,800 --> 00:16:57,519
some of the um things we need to do in

00:16:56,320 --> 00:16:59,920
terms of

00:16:57,519 --> 00:17:01,680
you know mechanics and whatnot but

00:16:59,920 --> 00:17:03,759
generally i'm supportive and

00:17:01,680 --> 00:17:05,760
i think i'd be interested in knowing

00:17:03,759 --> 00:17:10,240
sort of how

00:17:05,760 --> 00:17:10,240
we'd have to change k-native to be

00:17:10,319 --> 00:17:13,839
to support that right um i mean

00:17:12,559 --> 00:17:18,000
ultimately we want

00:17:13,839 --> 00:17:21,199
um we want the pieces of k-native

00:17:18,000 --> 00:17:24,160
to support use cases like you know

00:17:21,199 --> 00:17:26,880
that um you know not just sort of your

00:17:24,160 --> 00:17:29,120
fast things but we we see folks building

00:17:26,880 --> 00:17:32,240
uh all kinds of sort of higher level

00:17:29,120 --> 00:17:35,280
developer facing experiences on top of

00:17:32,240 --> 00:17:38,240
kubernetes using native fast is

00:17:35,280 --> 00:17:39,520
probably one of the most uh common but

00:17:38,240 --> 00:17:42,240
um

00:17:39,520 --> 00:17:42,240
you know uh

00:17:42,960 --> 00:17:50,559
i don't know i does that uh

00:17:47,520 --> 00:17:52,240
sort of answer your question i i don't

00:17:50,559 --> 00:17:55,200
know that i can speak

00:17:52,240 --> 00:17:56,640
to the specifics uh of how what that

00:17:55,200 --> 00:18:01,840
might look like given

00:17:56,640 --> 00:18:01,840
you know um yeah

00:18:06,240 --> 00:18:15,840
i feel like i'm talking to myself

00:18:21,039 --> 00:18:24,400
does anyone else have any other

00:18:22,720 --> 00:18:26,720
questions

00:18:24,400 --> 00:18:28,160
burnt do you have does that answer your

00:18:26,720 --> 00:18:30,480
question or

00:18:28,160 --> 00:18:34,080
you have a more specific question i can

00:18:30,480 --> 00:18:34,080
dance around or try and answer

00:18:41,280 --> 00:18:47,440
okay cool i was looking for your answer

00:18:44,559 --> 00:18:47,440
in the q a panel

00:18:47,840 --> 00:18:57,840
still learning this uh ui

00:19:01,440 --> 00:19:05,120
you can see the sun rising out my window

00:19:04,160 --> 00:19:11,840
if

00:19:05,120 --> 00:19:11,840
there are no questions it's pretty early

00:19:31,679 --> 00:19:37,360
any plans ideas on how rules for request

00:19:34,799 --> 00:19:40,640
dispatching would look like

00:19:37,360 --> 00:19:43,760
um i assume that's talking about um the

00:19:40,640 --> 00:19:46,799
sort of path method based dispatching um

00:19:43,760 --> 00:19:50,000
that i mentioned in the

00:19:46,799 --> 00:19:53,919
discussion uh or in the presentation

00:19:50,000 --> 00:19:56,160
um i would say it's pretty early um

00:19:53,919 --> 00:19:58,160
i can i can give my opinions on it but

00:19:56,160 --> 00:20:00,000
um we don't have anything that's

00:19:58,160 --> 00:20:01,200
you know an approved design for it or

00:20:00,000 --> 00:20:05,919
anything like that

00:20:01,200 --> 00:20:06,960
um i've prototyped a little bit here um

00:20:05,919 --> 00:20:10,880
uh

00:20:06,960 --> 00:20:12,720
let's see um so

00:20:10,880 --> 00:20:14,240
generally i think what we what we want

00:20:12,720 --> 00:20:16,799
to do with um

00:20:14,240 --> 00:20:18,159
for instance domain mapping um and i

00:20:16,799 --> 00:20:19,760
bring that up because there's

00:20:18,159 --> 00:20:21,520
that's further along and i think there's

00:20:19,760 --> 00:20:22,799
elements of it that are interesting

00:20:21,520 --> 00:20:24,240
i think we want to achieve those kinds

00:20:22,799 --> 00:20:25,760
of things through composition so that

00:20:24,240 --> 00:20:27,840
they work with k native services but

00:20:25,760 --> 00:20:30,400
they also work with other things that

00:20:27,840 --> 00:20:32,799
we might build like something that does

00:20:30,400 --> 00:20:36,480
more sophisticated request dispatching

00:20:32,799 --> 00:20:39,600
and so um i think the way i'm looking at

00:20:36,480 --> 00:20:40,480
the sort of idea around request

00:20:39,600 --> 00:20:44,320
dispatching

00:20:40,480 --> 00:20:46,960
um is um

00:20:44,320 --> 00:20:49,120
as something you know where you would

00:20:46,960 --> 00:20:51,600
sort of specify matching rules

00:20:49,120 --> 00:20:53,120
uh you know that would program your the

00:20:51,600 --> 00:20:56,159
l7 layer to do

00:20:53,120 --> 00:20:58,320
various matching and dispatching uh

00:20:56,159 --> 00:20:59,360
that could compose with k-native

00:20:58,320 --> 00:21:03,360
services or

00:20:59,360 --> 00:21:04,559
native routes in addition to potentially

00:21:03,360 --> 00:21:08,559
other things

00:21:04,559 --> 00:21:10,799
like um you know the k native channel

00:21:08,559 --> 00:21:13,039
and broker on the eventing side so if

00:21:10,799 --> 00:21:15,120
if you wanted certain routes to like go

00:21:13,039 --> 00:21:17,840
over there

00:21:15,120 --> 00:21:19,840
you could do that um and then ultimately

00:21:17,840 --> 00:21:22,240
you know part of the goal is to be able

00:21:19,840 --> 00:21:25,120
to sort of stitch together a bunch of

00:21:22,240 --> 00:21:26,720
you know functions and other things into

00:21:25,120 --> 00:21:28,000
something like an api surface or

00:21:26,720 --> 00:21:32,000
something like that

00:21:28,000 --> 00:21:34,240
that's sort of the rough sketch um but

00:21:32,000 --> 00:21:35,280
the my preference would be to achieve

00:21:34,240 --> 00:21:37,200
some of these things through

00:21:35,280 --> 00:21:38,400
composition so that they can compose

00:21:37,200 --> 00:21:40,159
with uh

00:21:38,400 --> 00:21:41,919
other things we haven't thought of yet

00:21:40,159 --> 00:21:44,320
or other things that may exist

00:21:41,919 --> 00:21:46,640
sort of outside of the sort of main

00:21:44,320 --> 00:21:51,520
upstream of k-native if that

00:21:46,640 --> 00:21:51,520
makes sense does that answer your

00:21:56,840 --> 00:21:59,840
question

00:22:08,000 --> 00:22:13,840
all right

00:22:22,159 --> 00:22:28,480
so i don't know okay cool

00:22:25,360 --> 00:22:31,760
yeah i mean it's it's a lot of fun

00:22:28,480 --> 00:22:34,880
i've played with a similar um

00:22:31,760 --> 00:22:38,000
concept for a while um and

00:22:34,880 --> 00:22:38,880
wanted to um it's something i've wanted

00:22:38,000 --> 00:22:41,919
to do for

00:22:38,880 --> 00:22:43,760
a while but um there's some

00:22:41,919 --> 00:22:45,679
some aspects of our networking layer

00:22:43,760 --> 00:22:46,480
that have taken some time to reach the

00:22:45,679 --> 00:22:48,000
point where

00:22:46,480 --> 00:22:49,600
i think we've sort of figured out

00:22:48,000 --> 00:22:52,840
composition and i think we did that as

00:22:49,600 --> 00:22:55,919
part of the domain mapping stuff so

00:22:52,840 --> 00:22:58,799
um so yeah so i'm i'm hoping that

00:22:55,919 --> 00:23:01,679
um we'll make some progress on that um

00:22:58,799 --> 00:23:01,679
in a couple months

00:23:03,440 --> 00:23:06,640
so i'm happy to keep chatting i don't

00:23:05,280 --> 00:23:09,840
know how time

00:23:06,640 --> 00:23:11,840
works for this but uh

00:23:09,840 --> 00:23:13,360
you know i i don't think i have anything

00:23:11,840 --> 00:23:16,000
for another

00:23:13,360 --> 00:23:18,640
20 25 minutes or so so if folks have

00:23:16,000 --> 00:23:23,280
other questions i'm happy to

00:23:18,640 --> 00:23:26,000
hang out and answer them um

00:23:23,280 --> 00:23:26,960
and i'm basically always reachable on k

00:23:26,000 --> 00:23:28,720
native slack

00:23:26,960 --> 00:23:30,159
and while i sit on a lot of slack

00:23:28,720 --> 00:23:34,840
workspaces these days

00:23:30,159 --> 00:23:37,760
um usually matt moore

00:23:34,840 --> 00:23:39,919
um uh no e uh on

00:23:37,760 --> 00:23:40,960
whatever slack workspace you can see if

00:23:39,919 --> 00:23:42,799
i'm there

00:23:40,960 --> 00:23:51,840
uh if folks have questions after the

00:23:42,799 --> 00:23:51,840
session um

00:24:15,279 --> 00:24:19,840
all right

00:24:30,400 --> 00:24:34,799
all right nobody else has any more

00:24:33,120 --> 00:24:35,200
questions i think i'm going to hit the

00:24:34,799 --> 00:24:39,520
big

00:24:35,200 --> 00:24:39,520
red stop broadcast button

00:24:40,159 --> 00:24:47,840
we'll give it another minute

00:24:54,760 --> 00:24:58,029
[Music]

00:24:59,840 --> 00:25:03,730
you

00:25:00,530 --> 00:25:03,730
[Music]

00:25:06,640 --> 00:25:11,069
[Music]

00:25:17,190 --> 00:25:27,670
[Music]

00:25:33,200 --> 00:25:38,159
all right i don't see any more questions

00:25:36,640 --> 00:25:41,440
popping up

00:25:38,159 --> 00:25:44,159
um so thanks everyone for coming and uh

00:25:41,440 --> 00:25:44,720
asking questions uh hopefully it was

00:25:44,159 --> 00:25:48,480
useful

00:25:44,720 --> 00:25:51,600
and again uh feel free to hit me up on

00:25:48,480 --> 00:25:54,320
slack my email's the same matt moore

00:25:51,600 --> 00:25:56,159
at vmware if folks need an invite to a

00:25:54,320 --> 00:25:56,799
slack workspace where we can chat or

00:25:56,159 --> 00:26:00,039
want to

00:25:56,799 --> 00:26:03,039
reach out over email but thanks for

00:26:00,039 --> 00:26:03,039

YouTube URL: https://www.youtube.com/watch?v=m2wIYuX3D3o


