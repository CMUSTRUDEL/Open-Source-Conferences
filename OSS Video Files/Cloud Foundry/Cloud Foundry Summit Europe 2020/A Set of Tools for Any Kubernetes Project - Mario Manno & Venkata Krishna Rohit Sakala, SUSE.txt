Title: A Set of Tools for Any Kubernetes Project - Mario Manno & Venkata Krishna Rohit Sakala, SUSE
Publication date: 2020-10-26
Playlist: Cloud Foundry Summit Europe 2020
Description: 
	A Set of Tools for Any Kubernetes Project - Mario Manno & Venkata Krishna Rohit Sakala, SUSE

In our effort to build an operator that can deploy Cloud Foundry on Kubernetes, we've discovered several opportunities for features. We'd like to demo these capabilities to the Cloud Foundry community. These can be useful for core contributors to Cloud Foundry, but also users of Kubernetes that have encountered the same limitations as we did. Secret generation, canary deployments, server-side templates, config change detection, feature-rich jobs and more.
Captions: 
	00:00:00,160 --> 00:00:03,600
uh i'm mario mano i work at souza for a

00:00:02,879 --> 00:00:06,480
few years

00:00:03,600 --> 00:00:07,919
i'm working upstream uh at the cloud

00:00:06,480 --> 00:00:10,719
foundry foundation

00:00:07,919 --> 00:00:12,160
for about four years now and um this is

00:00:10,719 --> 00:00:15,839
my colleague

00:00:12,160 --> 00:00:17,039
hi hi i'm rohit zakala and i also work

00:00:15,839 --> 00:00:18,640
for suze

00:00:17,039 --> 00:00:20,320
and i'm a contributor to the quarks

00:00:18,640 --> 00:00:22,720
project under the cloud foundry

00:00:20,320 --> 00:00:25,119
community

00:00:22,720 --> 00:00:27,039
and we are going to talk today about the

00:00:25,119 --> 00:00:29,119
work we did in quarks where we built

00:00:27,039 --> 00:00:32,719
from operators for kubernetes

00:00:29,119 --> 00:00:35,760
to make cube cf run on kubernetes

00:00:32,719 --> 00:00:37,200
and um qcf of course is a cloud foundry

00:00:35,760 --> 00:00:39,600
application runtime

00:00:37,200 --> 00:00:41,120
and so first the few basics about

00:00:39,600 --> 00:00:43,200
kubernetes then we are going to talk

00:00:41,120 --> 00:00:46,239
about the work we did on secrets

00:00:43,200 --> 00:00:49,600
jobs and stateful sets among

00:00:46,239 --> 00:00:52,719
some of the smaller concepts and

00:00:49,600 --> 00:00:55,360
ideas we had so kubernetes is

00:00:52,719 --> 00:00:56,079
very much the operating system of the

00:00:55,360 --> 00:00:57,360
cloud

00:00:56,079 --> 00:01:00,320
in the sense that it gives you

00:00:57,360 --> 00:01:03,520
primitives to build your cloud with

00:01:00,320 --> 00:01:08,320
are like services ports and ingress

00:01:03,520 --> 00:01:10,080
ingresses but what we use

00:01:08,320 --> 00:01:12,560
are custom resource definitions where

00:01:10,080 --> 00:01:15,920
you can define your own kind of resource

00:01:12,560 --> 00:01:17,680
and i wanted to show a few basics here

00:01:15,920 --> 00:01:19,280
like to get the custom resource you can

00:01:17,680 --> 00:01:20,880
do cube ctl get

00:01:19,280 --> 00:01:22,320
for example quark secret in all

00:01:20,880 --> 00:01:24,880
namespaces

00:01:22,320 --> 00:01:27,280
and you have to register it with a

00:01:24,880 --> 00:01:30,400
cluster first

00:01:27,280 --> 00:01:32,560
customer resources are cluster-wide so

00:01:30,400 --> 00:01:33,920
they have an array here of versions and

00:01:32,560 --> 00:01:36,479
each

00:01:33,920 --> 00:01:37,040
version in that array contains a json

00:01:36,479 --> 00:01:40,079
schema

00:01:37,040 --> 00:01:42,960
to validate the custom resource

00:01:40,079 --> 00:01:45,840
you create and then there's also the

00:01:42,960 --> 00:01:48,799
name under which it lives and

00:01:45,840 --> 00:01:49,520
the short names and so on in your

00:01:48,799 --> 00:01:50,960
application

00:01:49,520 --> 00:01:52,640
when the customer resource is

00:01:50,960 --> 00:01:54,960
deserialized you get the

00:01:52,640 --> 00:01:56,479
struct like this and then you can work

00:01:54,960 --> 00:01:59,600
with it

00:01:56,479 --> 00:02:01,040
so all our controllers follow the common

00:01:59,600 --> 00:02:03,439
controller pattern

00:02:01,040 --> 00:02:05,439
where we watch for changes to either

00:02:03,439 --> 00:02:08,239
core or customers

00:02:05,439 --> 00:02:10,879
we then analyze cluster state without

00:02:08,239 --> 00:02:12,800
looking at historical events

00:02:10,879 --> 00:02:14,720
so we don't have any race conditions and

00:02:12,800 --> 00:02:18,239
we act on the current state

00:02:14,720 --> 00:02:22,239
and then we try to

00:02:18,239 --> 00:02:23,920
create the desired outcome are the

00:02:22,239 --> 00:02:27,040
components we are going to show

00:02:23,920 --> 00:02:28,720
they work without bosch um they are

00:02:27,040 --> 00:02:29,920
currently at different levels of

00:02:28,720 --> 00:02:31,680
standalone

00:02:29,920 --> 00:02:36,000
in the sense that someone in the helm

00:02:31,680 --> 00:02:38,879
chart and others have a docker image um

00:02:36,000 --> 00:02:42,080
and those components i actually induced

00:02:38,879 --> 00:02:43,200
now by qcf and we hope that cf4ks can

00:02:42,080 --> 00:02:46,959
find use for

00:02:43,200 --> 00:02:48,080
some of them so the first component i

00:02:46,959 --> 00:02:51,280
want to talk about is

00:02:48,080 --> 00:02:53,360
quark quark secret um

00:02:51,280 --> 00:02:54,640
tries to improve on kubernetes secrets

00:02:53,360 --> 00:02:56,800
by generating

00:02:54,640 --> 00:02:58,159
the actual credentials inside the

00:02:56,800 --> 00:03:00,959
cluster

00:02:58,159 --> 00:03:02,000
um but let's talk about kubernetes

00:03:00,959 --> 00:03:04,159
secrets first

00:03:02,000 --> 00:03:05,920
they are basically key value stores um

00:03:04,159 --> 00:03:07,599
they only store strings like you can see

00:03:05,920 --> 00:03:10,959
here you have a username

00:03:07,599 --> 00:03:16,480
key or type key and the

00:03:10,959 --> 00:03:18,480
actual value is protected here by base64

00:03:16,480 --> 00:03:20,159
and you could easily decode that but

00:03:18,480 --> 00:03:21,200
what you would get back is still a

00:03:20,159 --> 00:03:23,680
string it's not a

00:03:21,200 --> 00:03:26,239
nested structure and these secrets are

00:03:23,680 --> 00:03:28,000
normally used in ports

00:03:26,239 --> 00:03:31,519
for example as an environment variable

00:03:28,000 --> 00:03:33,200
by referencing the secret and the key

00:03:31,519 --> 00:03:35,040
of the string to put in that environment

00:03:33,200 --> 00:03:35,920
variable or you can mount them as a

00:03:35,040 --> 00:03:38,080
volume

00:03:35,920 --> 00:03:41,440
and then you get the directory full of

00:03:38,080 --> 00:03:44,640
files each file would be

00:03:41,440 --> 00:03:44,640
a key from the secret

00:03:45,440 --> 00:03:48,560
there is also an update mechanism in

00:03:47,440 --> 00:03:50,560
that case um

00:03:48,560 --> 00:03:51,599
if the secret changes the file will

00:03:50,560 --> 00:03:53,519
eventually change

00:03:51,599 --> 00:03:55,439
but on the documentation doesn't really

00:03:53,519 --> 00:03:57,599
say when

00:03:55,439 --> 00:03:57,599
the

00:03:59,280 --> 00:04:03,680
thing here is that this is very much

00:04:01,519 --> 00:04:04,640
fine if your application has a 12 vector

00:04:03,680 --> 00:04:06,879
application

00:04:04,640 --> 00:04:08,480
if it takes all its configuration from

00:04:06,879 --> 00:04:12,080
environment variables

00:04:08,480 --> 00:04:13,840
but if it doesn't then

00:04:12,080 --> 00:04:17,600
you still need to somehow generate an

00:04:13,840 --> 00:04:20,880
application config from those secrets

00:04:17,600 --> 00:04:23,520
uh here's how it works so

00:04:20,880 --> 00:04:25,360
in the quark secret you give a generated

00:04:23,520 --> 00:04:27,520
password here this is the name of the

00:04:25,360 --> 00:04:30,720
secret that will be created

00:04:27,520 --> 00:04:32,639
from the quark secret and the type here

00:04:30,720 --> 00:04:34,880
is password but it could also be

00:04:32,639 --> 00:04:36,960
certificate templated config or docker

00:04:34,880 --> 00:04:41,840
authentication

00:04:36,960 --> 00:04:44,800
we don't generate if the secret already

00:04:41,840 --> 00:04:47,520
so you can create your own secret like

00:04:44,800 --> 00:04:47,520
as a default

00:04:48,479 --> 00:04:53,680
this is templated config one mechanism

00:04:51,840 --> 00:04:56,000
we came up with recently which we

00:04:53,680 --> 00:04:58,240
hope can help when creating these

00:04:56,000 --> 00:05:00,720
proprietary application configs

00:04:58,240 --> 00:05:01,919
and we basically take secrets as an

00:05:00,720 --> 00:05:05,680
input here

00:05:01,919 --> 00:05:08,320
and fill them into

00:05:05,680 --> 00:05:10,000
templates and this will create a secret

00:05:08,320 --> 00:05:13,120
where each value is here

00:05:10,000 --> 00:05:17,520
in this case actually a

00:05:13,120 --> 00:05:24,400
helm template and

00:05:17,520 --> 00:05:27,600
can demo this okay

00:05:24,400 --> 00:05:29,680
okay so the demo for temperature config

00:05:27,600 --> 00:05:31,600
we have already installed the operator

00:05:29,680 --> 00:05:34,000
uh we have the operator the quarks job

00:05:31,600 --> 00:05:38,320
and the quark secret

00:05:34,000 --> 00:05:42,720
now let's apply the templated config but

00:05:38,320 --> 00:05:42,720
let's just check check it once

00:05:43,840 --> 00:05:49,280
so we are applying we are creating a

00:05:47,919 --> 00:05:52,080
quark secret

00:05:49,280 --> 00:05:53,120
custom resource that is templated config

00:05:52,080 --> 00:05:55,919
and

00:05:53,120 --> 00:05:56,720
we want to have a secret name templated

00:05:55,919 --> 00:05:59,840
secret

00:05:56,720 --> 00:06:00,800
which has two keys cert and password and

00:05:59,840 --> 00:06:03,840
the values

00:06:00,800 --> 00:06:06,319
for those keys should come from other

00:06:03,840 --> 00:06:08,319
two secrets

00:06:06,319 --> 00:06:10,160
one of the gen the certificate value

00:06:08,319 --> 00:06:11,199
should come from generated certificate

00:06:10,160 --> 00:06:13,440
secret

00:06:11,199 --> 00:06:17,039
and the password value should come from

00:06:13,440 --> 00:06:20,240
the secret name generated password

00:06:17,039 --> 00:06:24,319
okay now let's apply these

00:06:20,240 --> 00:06:24,319
first let's watch over the secrets

00:06:28,240 --> 00:06:30,639
so there

00:06:32,479 --> 00:06:35,680
the generated certificate has been

00:06:34,080 --> 00:06:36,960
created the generator password is being

00:06:35,680 --> 00:06:39,199
created

00:06:36,960 --> 00:06:40,639
and then at last we have the templated

00:06:39,199 --> 00:06:44,080
secret

00:06:40,639 --> 00:06:45,520
so here we have as we wanted the cert

00:06:44,080 --> 00:06:48,639
and the password

00:06:45,520 --> 00:06:51,840
from the values taken from these two

00:06:48,639 --> 00:06:55,919
secrets so that's it

00:06:51,840 --> 00:06:58,000
back to mario forex job and

00:06:55,919 --> 00:06:59,360
quarkshop tries to improve on kubernetes

00:06:58,000 --> 00:07:02,479
jobs which are really

00:06:59,360 --> 00:07:04,560
um simple they have a job

00:07:02,479 --> 00:07:07,120
um you create the job and that creates a

00:07:04,560 --> 00:07:08,000
port and that executes your command and

00:07:07,120 --> 00:07:10,319
the cluster

00:07:08,000 --> 00:07:12,400
so quarkshop is like a template for jobs

00:07:10,319 --> 00:07:13,840
where you can now decide if you want to

00:07:12,400 --> 00:07:15,599
run the job right

00:07:13,840 --> 00:07:16,880
in the moment you create the workshop or

00:07:15,599 --> 00:07:19,039
you want to run it

00:07:16,880 --> 00:07:20,720
at some point in time like an errand and

00:07:19,039 --> 00:07:22,080
you can do this by patching the trigger

00:07:20,720 --> 00:07:23,840
strategy to now

00:07:22,080 --> 00:07:25,840
and when the job is done this will be

00:07:23,840 --> 00:07:28,080
set to done

00:07:25,840 --> 00:07:29,680
workshop can also clean up by deleting

00:07:28,080 --> 00:07:32,160
the job and optionally

00:07:29,680 --> 00:07:33,680
also deleting the part it created

00:07:32,160 --> 00:07:34,560
another feature we have is update on

00:07:33,680 --> 00:07:37,919
config change

00:07:34,560 --> 00:07:39,840
um you can use this um to run the job

00:07:37,919 --> 00:07:40,960
again if one of the conflicts changes

00:07:39,840 --> 00:07:43,520
and by that we mean

00:07:40,960 --> 00:07:45,120
secrets you reference from the quarkshop

00:07:43,520 --> 00:07:47,360
from the pod template right

00:07:45,120 --> 00:07:49,120
so every time one of these changes a new

00:07:47,360 --> 00:07:50,400
job will be created and the new part

00:07:49,120 --> 00:07:52,000
will run

00:07:50,400 --> 00:07:53,919
another feature we have is persist

00:07:52,000 --> 00:07:56,160
output where each

00:07:53,919 --> 00:07:57,120
part and each part has several

00:07:56,160 --> 00:07:59,440
containers

00:07:57,120 --> 00:08:01,039
so where each container and that part

00:07:59,440 --> 00:08:05,360
can write

00:08:01,039 --> 00:08:05,360
its output as json to a secret

00:08:05,919 --> 00:08:12,800
um let's do a quark through demo

00:08:09,360 --> 00:08:14,700
we already have a workshop on running

00:08:12,800 --> 00:08:18,070
let's see the example

00:08:14,700 --> 00:08:18,070
[Music]

00:08:18,080 --> 00:08:21,360
what do we have here we have a kind

00:08:20,080 --> 00:08:23,199
workshop

00:08:21,360 --> 00:08:24,400
and we have one container which is

00:08:23,199 --> 00:08:27,440
outputting

00:08:24,400 --> 00:08:29,120
json into a file

00:08:27,440 --> 00:08:30,800
and our requirement is to create a

00:08:29,120 --> 00:08:34,159
secret out of this

00:08:30,800 --> 00:08:35,120
json file and so uh here we have output

00:08:34,159 --> 00:08:38,240
map

00:08:35,120 --> 00:08:40,880
and the file name and the secret name

00:08:38,240 --> 00:08:41,760
is for json in which we want the

00:08:40,880 --> 00:08:45,920
contents of

00:08:41,760 --> 00:08:47,360
output.json and we also have update on

00:08:45,920 --> 00:08:51,279
config changes true

00:08:47,360 --> 00:08:52,640
that means if the contents of

00:08:51,279 --> 00:08:54,560
this particular secret that is

00:08:52,640 --> 00:08:57,600
referenced in this quarks

00:08:54,560 --> 00:09:01,200
job changes then this should this job

00:08:57,600 --> 00:09:04,240
runs once again and will have an

00:09:01,200 --> 00:09:09,839
updated for json secret

00:09:04,240 --> 00:09:09,839
okay let's apply this

00:09:16,240 --> 00:09:23,839
see a job board here now

00:09:24,640 --> 00:09:29,580
yep you see a pod it's running

00:09:26,350 --> 00:09:29,580
[Music]

00:09:34,160 --> 00:09:38,640
it has completed and we have the four

00:09:36,959 --> 00:09:41,440
json secret

00:09:38,640 --> 00:09:42,320
yeah and we have the json in it now

00:09:41,440 --> 00:09:51,839
let's

00:09:42,320 --> 00:09:51,839
edit this particular secret

00:09:54,560 --> 00:09:57,600
and we should see

00:09:58,000 --> 00:10:05,839
uh and job board here since

00:10:01,040 --> 00:10:05,839
the reference secret has updated

00:10:06,079 --> 00:10:13,839
yep we have here

00:10:09,680 --> 00:10:18,880
one more uh job job board created and

00:10:13,839 --> 00:10:22,320
the for json secret will get updated

00:10:18,880 --> 00:10:22,320
that's it back to mario

00:10:26,880 --> 00:10:30,640
the next feature is quark stateful set

00:10:29,200 --> 00:10:33,839
and quark stateful set

00:10:30,640 --> 00:10:35,279
is another wrapper around kubernetes

00:10:33,839 --> 00:10:39,040
stateful sets

00:10:35,279 --> 00:10:42,000
stateful sets are important because they

00:10:39,040 --> 00:10:42,480
have a sticky identifier which can be

00:10:42,000 --> 00:10:46,720
used

00:10:42,480 --> 00:10:48,720
to match the volumes of the parts

00:10:46,720 --> 00:10:50,399
to the same ports later on that's why

00:10:48,720 --> 00:10:52,640
they have state each port

00:10:50,399 --> 00:10:53,760
gets a volume and these allow for

00:10:52,640 --> 00:10:58,240
rolling updates

00:10:53,760 --> 00:11:00,240
and order deployments right and

00:10:58,240 --> 00:11:02,240
there's one drawback however if you get

00:11:00,240 --> 00:11:03,600
into a failed state with your deployment

00:11:02,240 --> 00:11:06,480
you have to manually

00:11:03,600 --> 00:11:08,399
enter then intervene uh and delete

00:11:06,480 --> 00:11:10,000
support delete parts and so on so the

00:11:08,399 --> 00:11:12,880
rollout can continue

00:11:10,000 --> 00:11:13,760
um quark statefulset can do recovery

00:11:12,880 --> 00:11:16,720
from filter

00:11:13,760 --> 00:11:18,240
deployments automatically we also added

00:11:16,720 --> 00:11:21,279
zero downtime deployments

00:11:18,240 --> 00:11:23,120
and um like workshop before it can also

00:11:21,279 --> 00:11:26,079
restart if the config of

00:11:23,120 --> 00:11:28,399
one of the pots that's used in the

00:11:26,079 --> 00:11:31,839
stateful set of a quark stateful set

00:11:28,399 --> 00:11:34,800
changes um we added

00:11:31,839 --> 00:11:36,720
more features here for example we have

00:11:34,800 --> 00:11:38,560
cannery support so

00:11:36,720 --> 00:11:41,040
you know the canary and the coal mine

00:11:38,560 --> 00:11:43,200
when the deployment fails this

00:11:41,040 --> 00:11:44,880
little bird here tilts over and you have

00:11:43,200 --> 00:11:48,399
to use the oxygen

00:11:44,880 --> 00:11:50,720
tank at the top to revive it

00:11:48,399 --> 00:11:53,519
we also have ac support where on the

00:11:50,720 --> 00:11:56,079
stateful set is spawned in each ac

00:11:53,519 --> 00:11:57,200
so ac's are built by attaching node

00:11:56,079 --> 00:12:00,560
labels

00:11:57,200 --> 00:12:02,079
to nodes on kubernetes and we also have

00:12:00,560 --> 00:12:04,880
support for active passive

00:12:02,079 --> 00:12:05,760
probes where we have a service that's

00:12:04,880 --> 00:12:07,519
pointing to

00:12:05,760 --> 00:12:08,959
the stateful set and if the active

00:12:07,519 --> 00:12:11,600
passive probe is

00:12:08,959 --> 00:12:12,160
working there's a label that will be

00:12:11,600 --> 00:12:15,200
attached

00:12:12,160 --> 00:12:17,279
to the port so traffic gets routed there

00:12:15,200 --> 00:12:19,040
here are some more concepts and code we

00:12:17,279 --> 00:12:21,360
have which might be useful

00:12:19,040 --> 00:12:22,079
for example we have a binary that can

00:12:21,360 --> 00:12:24,480
wait

00:12:22,079 --> 00:12:26,560
for any pot to appear on the cluster and

00:12:24,480 --> 00:12:29,040
we use that in an init container

00:12:26,560 --> 00:12:30,320
to stop the pot from starting until

00:12:29,040 --> 00:12:32,880
another part

00:12:30,320 --> 00:12:34,720
is there then we have monitored

00:12:32,880 --> 00:12:38,240
namespaces which we use for

00:12:34,720 --> 00:12:39,519
like multi-tenancy we put a label on the

00:12:38,240 --> 00:12:41,200
namespace and

00:12:39,519 --> 00:12:43,040
only if the label is on the namespace

00:12:41,200 --> 00:12:46,000
our operator will

00:12:43,040 --> 00:12:47,360
react to events in that namespace that

00:12:46,000 --> 00:12:49,600
means we can have

00:12:47,360 --> 00:12:50,800
our operator work on multiple namespaces

00:12:49,600 --> 00:12:52,800
but we can also

00:12:50,800 --> 00:12:54,880
have multiple operators in the same

00:12:52,800 --> 00:12:57,360
cluster each with their own set of

00:12:54,880 --> 00:13:01,680
namespaces

00:12:57,360 --> 00:13:05,519
version secrets is another thing we have

00:13:01,680 --> 00:13:08,880
to add a version

00:13:05,519 --> 00:13:12,399
suffix to a secret and so we

00:13:08,880 --> 00:13:14,240
can kind of make it immutable i

00:13:12,399 --> 00:13:16,560
hope that maybe we can get rid of this

00:13:14,240 --> 00:13:20,800
when the new kubernetes version

00:13:16,560 --> 00:13:22,880
introduces immutable secrets

00:13:20,800 --> 00:13:25,040
or maybe we still need it and can

00:13:22,880 --> 00:13:28,079
improve on it

00:13:25,040 --> 00:13:33,360
and then we have meltdown on resources

00:13:28,079 --> 00:13:35,440
so if events occur very fast we can

00:13:33,360 --> 00:13:36,720
ignore the first one and postpone it a

00:13:35,440 --> 00:13:39,279
little bit

00:13:36,720 --> 00:13:40,800
so this protects you against the

00:13:39,279 --> 00:13:44,240
equivalent of

00:13:40,800 --> 00:13:45,760
a user double clicking on your html html

00:13:44,240 --> 00:13:47,680
form buttons

00:13:45,760 --> 00:13:50,000
and then we have the gora test release

00:13:47,680 --> 00:13:52,560
which we are using testing and

00:13:50,000 --> 00:13:54,959
it's a small web server that can do ssl

00:13:52,560 --> 00:13:54,959
and

00:13:55,040 --> 00:13:58,399
agent and debugging

00:13:58,720 --> 00:14:05,040
yeah that's um that's it for

00:14:02,000 --> 00:14:05,440
tools you can use um we are the quarks

00:14:05,040 --> 00:14:09,920
team

00:14:05,440 --> 00:14:09,920
on slack so feel free to reach out

00:14:11,680 --> 00:14:14,800
oh there is a question in the q a oh

00:14:13,920 --> 00:14:18,800
cool

00:14:14,800 --> 00:14:18,800
i was trying to come up with my own one

00:14:28,839 --> 00:14:31,839
but

00:14:42,000 --> 00:14:48,160
so the service account

00:14:45,839 --> 00:14:48,160
is

00:14:48,959 --> 00:15:01,760
bound to a cluster role

00:14:59,600 --> 00:15:03,040
so it has a cluster role binding to a

00:15:01,760 --> 00:15:06,320
cluster role which

00:15:03,040 --> 00:15:09,839
lost read access to all secrets um

00:15:06,320 --> 00:15:11,680
that services i don't think it can be

00:15:09,839 --> 00:15:14,880
restricted in that case right

00:15:11,680 --> 00:15:17,120
normally service accounts they

00:15:14,880 --> 00:15:17,120
um

00:15:18,560 --> 00:15:22,800
i mean if they if they have a namespace

00:15:20,639 --> 00:15:23,600
role binding they could only do stuff in

00:15:22,800 --> 00:15:27,279
their

00:15:23,600 --> 00:15:29,920
in their namespace but

00:15:27,279 --> 00:15:31,759
if it has a cluster role binding i think

00:15:29,920 --> 00:15:35,519
you can use the the token

00:15:31,759 --> 00:15:41,839
for for cluster white stuff

00:15:35,519 --> 00:15:41,839
if if that answers the question like

00:15:42,560 --> 00:15:48,720
role-based access i think is um

00:15:46,079 --> 00:15:51,199
it's a nice feature right it's uh but

00:15:48,720 --> 00:15:51,199
it's still

00:15:52,839 --> 00:15:56,959
um

00:15:54,000 --> 00:15:57,440
uh the the fun is over soon right like

00:15:56,959 --> 00:15:59,839
it's

00:15:57,440 --> 00:16:02,160
uh there's so many permissions you can

00:15:59,839 --> 00:16:05,040
run which basically gives cluster access

00:16:02,160 --> 00:16:06,399
it's really it's really hard like uh if

00:16:05,040 --> 00:16:07,759
you have a service account that's able

00:16:06,399 --> 00:16:10,480
to

00:16:07,759 --> 00:16:12,399
execute something in a pot then it can

00:16:10,480 --> 00:16:13,600
still all the tokens in that part right

00:16:12,399 --> 00:16:16,480
so

00:16:13,600 --> 00:16:17,839
there's so many conditions where uh raw

00:16:16,480 --> 00:16:23,839
based access controls

00:16:17,839 --> 00:16:23,839
seem like not enough um

00:16:26,720 --> 00:16:31,600
yeah and we um i think

00:16:31,839 --> 00:16:35,360
uh that was one of the problems we had

00:16:34,000 --> 00:16:38,320
with quarkshop

00:16:35,360 --> 00:16:39,040
and the persist output feature that we

00:16:38,320 --> 00:16:42,240
basically

00:16:39,040 --> 00:16:44,079
um need the service account for every

00:16:42,240 --> 00:16:46,560
namespace this feature runs and

00:16:44,079 --> 00:16:46,560
otherwise

00:16:47,199 --> 00:16:50,240
the security would not be given right

00:16:49,279 --> 00:16:53,040
then

00:16:50,240 --> 00:16:55,040
um we can't set this up and from the

00:16:53,040 --> 00:16:56,480
hand chart right we we like to set up

00:16:55,040 --> 00:16:59,040
things in the hem chart

00:16:56,480 --> 00:17:00,800
because then you can audit the hem chart

00:16:59,040 --> 00:17:02,880
and you know

00:17:00,800 --> 00:17:04,640
what kind of roles are in the cluster

00:17:02,880 --> 00:17:06,400
but since namespaces are not dynamic and

00:17:04,640 --> 00:17:08,319
you can have multiple namespaces

00:17:06,400 --> 00:17:10,079
are the user is kind of responsible for

00:17:08,319 --> 00:17:11,520
creating those service accounts manually

00:17:10,079 --> 00:17:13,720
for namespaces

00:17:11,520 --> 00:17:16,079
that should be monitored so

00:17:13,720 --> 00:17:19,839
[Music]

00:17:16,079 --> 00:17:19,839
yeah lots of problems here

00:17:52,160 --> 00:17:59,360
i i don't know of any way

00:17:56,160 --> 00:18:00,160
to to do this here like the question is

00:17:59,360 --> 00:18:03,440
like when

00:18:00,160 --> 00:18:04,240
when we have this uh row bindings and

00:18:03,440 --> 00:18:06,160
service account

00:18:04,240 --> 00:18:07,600
can i can i make it so that the cluster

00:18:06,160 --> 00:18:10,400
white one can't access

00:18:07,600 --> 00:18:12,840
the secret i don't i don't think it's

00:18:10,400 --> 00:18:15,840
possible

00:18:12,840 --> 00:18:15,840
um

00:18:24,000 --> 00:18:27,440
maybe it's like more like a kubernetes

00:18:25,919 --> 00:18:29,440
feature

00:18:27,440 --> 00:18:31,440
yeah definitely kubernetes right we um

00:18:29,440 --> 00:18:32,320
we just create secrets in in quark

00:18:31,440 --> 00:18:35,840
secret we just

00:18:32,320 --> 00:18:37,840
create them and um

00:18:35,840 --> 00:18:39,039
i remember we were afraid that our

00:18:37,840 --> 00:18:41,760
controllers

00:18:39,039 --> 00:18:42,880
had too much too many permissions right

00:18:41,760 --> 00:18:45,280
when moving to

00:18:42,880 --> 00:18:47,600
the multi-name space feature where we um

00:18:45,280 --> 00:18:49,760
we have this monitored namespace

00:18:47,600 --> 00:18:50,960
and it turns out we already had so many

00:18:49,760 --> 00:18:53,520
permissions that it

00:18:50,960 --> 00:18:54,559
didn't really create so much of a

00:18:53,520 --> 00:18:56,400
difference to

00:18:54,559 --> 00:18:57,760
change all the road lines to cluster

00:18:56,400 --> 00:18:59,919
world bindings

00:18:57,760 --> 00:19:02,640
because um basically what what we're

00:18:59,919 --> 00:19:06,080
working on is more like

00:19:02,640 --> 00:19:09,760
cluster management so it's

00:19:06,080 --> 00:19:12,240
you really go fast to needing a lot of

00:19:09,760 --> 00:19:12,240
access

00:19:12,320 --> 00:19:15,919
uh while normal apps i think you're fine

00:19:14,559 --> 00:19:19,039
with the namespace

00:19:15,919 --> 00:19:19,039
resources and

00:19:20,240 --> 00:19:24,799
that that's much more secure of course i

00:19:23,440 --> 00:19:28,880
think there are also a lot of

00:19:24,799 --> 00:19:32,080
projects in kubernetes which um try to

00:19:28,880 --> 00:19:34,640
simplify service accounts and automate

00:19:32,080 --> 00:19:38,000
them or even sync them to your

00:19:34,640 --> 00:19:39,440
active directory or whatever so maybe

00:19:38,000 --> 00:19:41,120
that would have solution would be a

00:19:39,440 --> 00:19:42,799
solution for that problem right

00:19:41,120 --> 00:19:45,039
don't use a cluster world binding

00:19:42,799 --> 00:19:46,160
instead um create role bindings

00:19:45,039 --> 00:19:49,840
dynamically

00:19:46,160 --> 00:19:53,679
so you can just exclude that one secret

00:19:49,840 --> 00:19:58,160
from that one service account

00:19:53,679 --> 00:20:00,400
i can't suggest the solution here

00:19:58,160 --> 00:20:00,400
though

00:20:04,840 --> 00:20:07,840
maybe

00:20:23,520 --> 00:20:28,880
yeah i am we didn't talk about this but

00:20:27,280 --> 00:20:33,280
most of our controllers were

00:20:28,880 --> 00:20:36,320
created with the operator sdk first

00:20:33,280 --> 00:20:36,320
and some

00:20:37,039 --> 00:20:42,480
we felt that we didn't need the

00:20:40,480 --> 00:20:43,840
functionality of the operator sdk

00:20:42,480 --> 00:20:46,400
anymore so it was really easy

00:20:43,840 --> 00:20:49,120
to remove it but we still use the

00:20:46,400 --> 00:20:52,720
controller runtime sdk

00:20:49,120 --> 00:20:57,840
from operator sdk

00:20:52,720 --> 00:20:57,840
that's basically our main

00:21:00,840 --> 00:21:03,840
library

00:21:11,679 --> 00:21:15,600
and it's really easy to use on the

00:21:13,760 --> 00:21:16,559
controller runtime to build your own

00:21:15,600 --> 00:21:20,799
controllers

00:21:16,559 --> 00:21:24,320
and some act on

00:21:20,799 --> 00:21:26,960
uh resources

00:21:24,320 --> 00:21:29,280
what's not so easy is testing especially

00:21:26,960 --> 00:21:31,440
against live clusters

00:21:29,280 --> 00:21:32,480
that's a huge problem because this is

00:21:31,440 --> 00:21:36,159
basically

00:21:32,480 --> 00:21:38,000
waiting for events to occur and

00:21:36,159 --> 00:21:39,760
sometimes they don't sometimes do you

00:21:38,000 --> 00:21:42,320
have race conditions

00:21:39,760 --> 00:21:43,280
it's much better um with testing and

00:21:42,320 --> 00:21:46,000
kind

00:21:43,280 --> 00:21:47,360
which is kubernetes in docker that helps

00:21:46,000 --> 00:21:51,919
a lot because it

00:21:47,360 --> 00:21:53,919
somehow behaves more uh

00:21:51,919 --> 00:21:55,760
you can depend on its behavior much more

00:21:53,919 --> 00:21:56,400
than on on the behavior of a real

00:21:55,760 --> 00:22:00,080
cluster

00:21:56,400 --> 00:22:00,080
on on from some provider

00:22:00,799 --> 00:22:04,880
timings are faster

00:22:05,760 --> 00:22:10,720
okay um i think if there are no more

00:22:08,720 --> 00:22:14,720
questions

00:22:10,720 --> 00:22:16,960
i mean we can wrap it up i guess

00:22:14,720 --> 00:22:16,960
yep

00:22:19,120 --> 00:22:26,039
so um yeah if you're interested in on

00:22:22,559 --> 00:22:29,360
controllers or quarks um

00:22:26,039 --> 00:22:33,200
comebackworkstaff on slack

00:22:29,360 --> 00:22:38,000
or open an issue on github

00:22:33,200 --> 00:22:38,000

YouTube URL: https://www.youtube.com/watch?v=hv1c45wibSc


