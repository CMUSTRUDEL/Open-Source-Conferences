Title: Angular Vienna, Authistry: The Art of Web Authentication with Angular, December 2019
Publication date: 2019-12-12
Playlist: Angular Vienna
Description: 
	Talk by Kim Maida,


Authentication and authorization can be daunting topics for many developers, including those of us working in the landscape of web apps. Jargon and acronyms (OAuth, OIDC, JWT, IETF)? What's the difference between authorization and authentication, and what are the pitfalls of confusing the two? How does cookie-based authentication work? How does token-based authentication work? New SPA authorization best practices?!

Let's demystify the terminology and concepts of authentication and authorization and talk about the features the Angular platform provides out of the box to make adding authentication and protecting routes easier for the developer.
Captions: 
	00:00:00,000 --> 00:00:05,910
hello thanks for having me by the way

00:00:02,220 --> 00:00:08,580
this is a beautiful city so I am going

00:00:05,910 --> 00:00:11,730
to talk to you about the art of web

00:00:08,580 --> 00:00:13,230
authentication with angular a little bit

00:00:11,730 --> 00:00:16,139
about me my name is Kim Maite

00:00:13,230 --> 00:00:19,050
I am a Google developer expert in web

00:00:16,139 --> 00:00:22,320
technologies and angular I organized an

00:00:19,050 --> 00:00:23,640
angular meetup in Ann Arbor Michigan and

00:00:22,320 --> 00:00:27,150
I'm also the head of developer relations

00:00:23,640 --> 00:00:29,880
at a company called auth0 and so austero

00:00:27,150 --> 00:00:31,859
is sponsoring this austere provides what

00:00:29,880 --> 00:00:33,719
we call identity as a service so

00:00:31,859 --> 00:00:35,430
essentially we're a thank you

00:00:33,719 --> 00:00:37,920
cloud platform that helps you to

00:00:35,430 --> 00:00:39,690
authenticate users in your applications

00:00:37,920 --> 00:00:41,940
as well as protect your data and your

00:00:39,690 --> 00:00:44,280
API so we deal with a lot of the

00:00:41,940 --> 00:00:45,690
complexity of identity so that you don't

00:00:44,280 --> 00:00:47,489
have to so that you can give that over

00:00:45,690 --> 00:00:49,890
to us and you can get work on building

00:00:47,489 --> 00:00:53,190
your products we're also hiring quite a

00:00:49,890 --> 00:00:55,379
bit for JavaScript folks who are good at

00:00:53,190 --> 00:00:57,899
JavaScript so if you're interested and

00:00:55,379 --> 00:01:02,039
we're fully remote so you can work from

00:00:57,899 --> 00:01:03,690
basic almost everywhere in the world so

00:01:02,039 --> 00:01:07,260
definitely check out our careers page if

00:01:03,690 --> 00:01:09,990
you're looking for something remote so I

00:01:07,260 --> 00:01:11,549
work an identity and when I've seen this

00:01:09,990 --> 00:01:13,979
type of thing a lot so when people take

00:01:11,549 --> 00:01:15,420
on an authentication project or are

00:01:13,979 --> 00:01:18,270
adding it as a feature to their

00:01:15,420 --> 00:01:19,920
applications they're usually aware that

00:01:18,270 --> 00:01:23,130
this is a pretty big thing to attempt

00:01:19,920 --> 00:01:24,420
and are rightfully quite concerned about

00:01:23,130 --> 00:01:26,880
what could potentially go wrong with

00:01:24,420 --> 00:01:29,040
this now authentication and

00:01:26,880 --> 00:01:31,020
authorization standards are very clearly

00:01:29,040 --> 00:01:34,049
defined but they're also challenging to

00:01:31,020 --> 00:01:35,909
get right so here's the thing you can

00:01:34,049 --> 00:01:39,210
take something like how do I add up in

00:01:35,909 --> 00:01:41,970
it it's hard to see I'm sorry how do I

00:01:39,210 --> 00:01:44,220
add authentication and you can sort of

00:01:41,970 --> 00:01:49,049
go to Google's put it in the search box

00:01:44,220 --> 00:01:50,640
and you can actually get to here doing

00:01:49,049 --> 00:01:52,500
the rest off stuff essentially by doing

00:01:50,640 --> 00:01:55,079
something like using it identity as a

00:01:52,500 --> 00:01:56,689
service solution like oz0 and it really

00:01:55,079 --> 00:01:59,520
can be that easy

00:01:56,689 --> 00:02:01,079
however I'm going to show you a lot more

00:01:59,520 --> 00:02:02,700
of the steps that go into this today

00:02:01,079 --> 00:02:04,259
because since you're here listening to

00:02:02,700 --> 00:02:06,110
this talk I'm going to assume that

00:02:04,259 --> 00:02:09,530
you're at least somewhat interested in

00:02:06,110 --> 00:02:11,879
sort of more of the things in between

00:02:09,530 --> 00:02:13,349
now I also want to make it really clear

00:02:11,879 --> 00:02:13,890
that you don't need to know all of these

00:02:13,349 --> 00:02:16,770
steps

00:02:13,890 --> 00:02:18,420
in order to get to the end result so you

00:02:16,770 --> 00:02:20,640
don't need to know that after you draw

00:02:18,420 --> 00:02:22,740
the circles and you're gonna sort of add

00:02:20,640 --> 00:02:24,000
a little tail and then you here's like

00:02:22,740 --> 00:02:25,500
you say the eyes you don't need to know

00:02:24,000 --> 00:02:28,560
all of that to get to a beautiful

00:02:25,500 --> 00:02:29,700
picture but it does really help so I'm

00:02:28,560 --> 00:02:32,790
going to fill you in on a lot of it

00:02:29,700 --> 00:02:34,890
today and I'm going to start with an

00:02:32,790 --> 00:02:36,780
introduction to commonly used open

00:02:34,890 --> 00:02:38,640
standards I'm gonna go through this in

00:02:36,780 --> 00:02:40,530
what I hope is an approachable way and

00:02:38,640 --> 00:02:43,170
provide foundational knowledge on

00:02:40,530 --> 00:02:44,550
standards based off I'm gonna give a

00:02:43,170 --> 00:02:45,990
little bit of a background err and then

00:02:44,550 --> 00:02:48,570
I'm going to talk about how this applies

00:02:45,990 --> 00:02:51,360
to JavaScript apps and talk about ways

00:02:48,570 --> 00:02:54,080
that angular as a platform can help you

00:02:51,360 --> 00:02:58,650
manage authentication and authorization

00:02:54,080 --> 00:03:00,090
so I work in identity and when I say I

00:02:58,650 --> 00:03:01,650
work in identity or someone asked me

00:03:00,090 --> 00:03:03,660
what do you do and I say I work an

00:03:01,650 --> 00:03:05,220
identity a lot of times they're going to

00:03:03,660 --> 00:03:07,500
assume that maybe I work for the

00:03:05,220 --> 00:03:09,870
government issuing government IDs or I

00:03:07,500 --> 00:03:11,490
help people recover from identity theft

00:03:09,870 --> 00:03:13,920
or credit card fraud or something like

00:03:11,490 --> 00:03:17,100
that that's not the case I work in

00:03:13,920 --> 00:03:19,140
digital identity and this actually

00:03:17,100 --> 00:03:20,940
refers specifically to a set of

00:03:19,140 --> 00:03:23,340
attributes that define an individual

00:03:20,940 --> 00:03:24,890
user in the context of a function that's

00:03:23,340 --> 00:03:28,560
delivered by a particular application

00:03:24,890 --> 00:03:31,400
that's a lot of words but really as an

00:03:28,560 --> 00:03:34,290
example so let's say that you have a

00:03:31,400 --> 00:03:37,050
shoot online shoe retailer app you sell

00:03:34,290 --> 00:03:39,000
shoes online the digital identity of

00:03:37,050 --> 00:03:40,620
your users would probably be something

00:03:39,000 --> 00:03:42,209
like their credit card number their

00:03:40,620 --> 00:03:44,070
shipping address and maybe their

00:03:42,209 --> 00:03:46,920
purchase history the lists of the last

00:03:44,070 --> 00:03:48,630
10 pairs of shoes they've bought now

00:03:46,920 --> 00:03:51,209
another term that comes up really often

00:03:48,630 --> 00:03:53,489
in identity is authentication and when

00:03:51,209 --> 00:03:56,250
we say authentication what exactly do we

00:03:53,489 --> 00:03:58,230
mean by this in a broad sense

00:03:56,250 --> 00:04:00,330
authentication refers to the process of

00:03:58,230 --> 00:04:02,130
verifying that the user is who they say

00:04:00,330 --> 00:04:04,680
they are can we make sure that they're

00:04:02,130 --> 00:04:06,239
the person they claim to be and then

00:04:04,680 --> 00:04:08,040
once we have established that we know

00:04:06,239 --> 00:04:09,989
the person is who they are we come to

00:04:08,040 --> 00:04:11,940
this topic of authorization which has to

00:04:09,989 --> 00:04:15,720
do with granting or denying rights to

00:04:11,940 --> 00:04:17,820
access resources now when we start

00:04:15,720 --> 00:04:19,739
talking about authorization the standard

00:04:17,820 --> 00:04:23,970
that comes up really frequently is a

00:04:19,739 --> 00:04:26,940
auth 2.0 and the document for OAuth is

00:04:23,970 --> 00:04:27,420
really dense I'm curious if anybody's

00:04:26,940 --> 00:04:29,010
looked at

00:04:27,420 --> 00:04:33,570
has anybody ever looked at the standards

00:04:29,010 --> 00:04:34,980
for costume so few people so I mentioned

00:04:33,570 --> 00:04:37,170
earlier the standards are very clearly

00:04:34,980 --> 00:04:39,000
defined but who writes them like where

00:04:37,170 --> 00:04:40,560
do they come from in the first place and

00:04:39,000 --> 00:04:41,940
there's a lot of different standards and

00:04:40,560 --> 00:04:45,090
organizations that deal with the

00:04:41,940 --> 00:04:48,000
internet the one that specifically deals

00:04:45,090 --> 00:04:50,520
with OAuth is the IETF or the internet

00:04:48,000 --> 00:04:52,860
Engineering Task Force this is really a

00:04:50,520 --> 00:04:55,710
large open international community of

00:04:52,860 --> 00:04:59,250
Network designers operators vendors and

00:04:55,710 --> 00:05:00,930
researchers and their concern is the

00:04:59,250 --> 00:05:03,390
evolution of Internet architecture and

00:05:00,930 --> 00:05:05,160
the smooth operation of the Internet now

00:05:03,390 --> 00:05:07,560
the technical work that's done by the

00:05:05,160 --> 00:05:08,850
IETF is done by working groups that are

00:05:07,560 --> 00:05:10,890
organized by topic

00:05:08,850 --> 00:05:12,360
so you could have there's a security

00:05:10,890 --> 00:05:15,210
working group there's a transport

00:05:12,360 --> 00:05:17,460
working group so on and so forth but to

00:05:15,210 --> 00:05:20,400
understand the actual purpose of the

00:05:17,460 --> 00:05:23,160
IETF so off standards we kind of have to

00:05:20,400 --> 00:05:24,330
go back before auth existed and find out

00:05:23,160 --> 00:05:27,390
like why were these standards written in

00:05:24,330 --> 00:05:30,390
the first place so before o 1.0 was

00:05:27,390 --> 00:05:33,900
established in December of 2007 let's

00:05:30,390 --> 00:05:35,400
say that we have our app and we want to

00:05:33,900 --> 00:05:39,090
access third-party resources the

00:05:35,400 --> 00:05:41,040
resources of a different service so

00:05:39,090 --> 00:05:44,250
maybe it might look something like this

00:05:41,040 --> 00:05:47,700
let's say that you as a user you use a

00:05:44,250 --> 00:05:49,860
web app called hire me and you also have

00:05:47,700 --> 00:05:52,080
an account with another app called Mike

00:05:49,860 --> 00:05:54,420
hell and you use my Kyle to manage your

00:05:52,080 --> 00:05:56,640
calendar events and now let's say that

00:05:54,420 --> 00:06:00,630
hire me actually wants to add an event

00:05:56,640 --> 00:06:01,710
to your Mike he'll account so before

00:06:00,630 --> 00:06:03,600
oo-ahh existed

00:06:01,710 --> 00:06:05,700
what hire me would do is it would ask

00:06:03,600 --> 00:06:08,370
you the user for your Mike how

00:06:05,700 --> 00:06:11,690
credentials and you would provide your

00:06:08,370 --> 00:06:13,980
credentials for Mike how to hire me and

00:06:11,690 --> 00:06:16,800
then hire me would take your credentials

00:06:13,980 --> 00:06:19,260
and it would use your access in order to

00:06:16,800 --> 00:06:21,510
access the Mike hel API on your behalf

00:06:19,260 --> 00:06:23,820
and then it would be able to do things

00:06:21,510 --> 00:06:25,590
like call the API and create calendar

00:06:23,820 --> 00:06:29,280
events using the access that you gave it

00:06:25,590 --> 00:06:31,830
by providing your credentials now this

00:06:29,280 --> 00:06:33,570
approach this is a good thing right

00:06:31,830 --> 00:06:37,050
sharing credentials is bad this approach

00:06:33,570 --> 00:06:38,910
relied on one application sharing your

00:06:37,050 --> 00:06:40,889
personal credentials for a different

00:06:38,910 --> 00:06:42,780
application and

00:06:40,889 --> 00:06:44,699
doing this is just in general not a good

00:06:42,780 --> 00:06:47,879
idea and there's a there's a couple of

00:06:44,699 --> 00:06:50,310
specific reasons why it should be really

00:06:47,879 --> 00:06:52,229
concerning for one thing hire me if hire

00:06:50,310 --> 00:06:54,270
me doesn't do their due diligence to

00:06:52,229 --> 00:06:56,639
protect the credentials that you gave it

00:06:54,270 --> 00:06:59,490
for my cow then they really have a lot

00:06:56,639 --> 00:07:01,560
less at stake than my cow so if they

00:06:59,490 --> 00:07:04,379
don't protect your my cow credentials

00:07:01,560 --> 00:07:05,939
very well and they get leaked then hire

00:07:04,379 --> 00:07:08,219
me 'he's not gonna suffer that much

00:07:05,939 --> 00:07:09,719
they're gonna maybe get some bad press

00:07:08,219 --> 00:07:10,860
somebody gonna write a nasty blog

00:07:09,719 --> 00:07:12,360
article and they're gonna say oh they

00:07:10,860 --> 00:07:13,590
didn't you know work very hard to

00:07:12,360 --> 00:07:18,120
protect it but it's not gonna be a

00:07:13,590 --> 00:07:19,889
catastrophe right also so it would be a

00:07:18,120 --> 00:07:21,750
catastrophe for my cow though because

00:07:19,889 --> 00:07:23,550
your credentials for their system had

00:07:21,750 --> 00:07:25,979
been leaked by a different system now

00:07:23,550 --> 00:07:28,650
hire me also has way too much access to

00:07:25,979 --> 00:07:31,650
the mike hell api hire me can do

00:07:28,650 --> 00:07:34,139
everything you can do because it's got

00:07:31,650 --> 00:07:35,339
your credentials so it can read all of

00:07:34,139 --> 00:07:36,960
your calendar events it could change

00:07:35,339 --> 00:07:39,029
your settings that could delete events

00:07:36,960 --> 00:07:40,499
it could do whatever it wanted in

00:07:39,029 --> 00:07:44,069
addition to adding events to your

00:07:40,499 --> 00:07:46,560
calendar so because of this scenario

00:07:44,069 --> 00:07:49,080
this is why ofk mabh out this is where

00:07:46,560 --> 00:07:51,419
the birthplace of the standard now I'm

00:07:49,080 --> 00:07:54,659
gonna specifically talk about OAuth 2.0

00:07:51,419 --> 00:07:56,189
in this talk and both 2.0 is an open

00:07:54,659 --> 00:08:00,000
standard for performing what we call

00:07:56,189 --> 00:08:01,680
delegated authorization now using OAuth

00:08:00,000 --> 00:08:03,870
MyCal can actually delegate

00:08:01,680 --> 00:08:06,210
authorization to hire me to give it

00:08:03,870 --> 00:08:07,770
limited access to its api's without

00:08:06,210 --> 00:08:10,020
incurring the risks of doing things like

00:08:07,770 --> 00:08:12,750
asking you for your mic how credentials

00:08:10,020 --> 00:08:14,399
and having to hire me store those

00:08:12,750 --> 00:08:16,469
credentials and use them in some way and

00:08:14,399 --> 00:08:19,439
it does this using something that we

00:08:16,469 --> 00:08:21,389
call an authorization server now this is

00:08:19,439 --> 00:08:23,460
kind of just a fancy word for a set of

00:08:21,389 --> 00:08:27,120
end points whose intent is to interact

00:08:23,460 --> 00:08:28,649
with the user and to issue tokens so if

00:08:27,120 --> 00:08:30,599
we come back to our scenario with hire

00:08:28,649 --> 00:08:33,659
me and Mike he'll only now we're using

00:08:30,599 --> 00:08:35,699
OAuth 2.0 then let's say that Mike Howe

00:08:33,659 --> 00:08:38,130
has one of these authorization servers

00:08:35,699 --> 00:08:40,169
and we're going to assume that hire me

00:08:38,130 --> 00:08:41,820
has already registered as a known client

00:08:40,169 --> 00:08:43,979
with my cow so this means that Michael

00:08:41,820 --> 00:08:46,410
is aware that hire me is another service

00:08:43,979 --> 00:08:49,470
that may be asking it for access to its

00:08:46,410 --> 00:08:51,620
api's and let's say you as a user are

00:08:49,470 --> 00:08:53,270
logged in with hire me already and this

00:08:51,620 --> 00:08:54,920
is however higher army happens to do

00:08:53,270 --> 00:08:56,420
authentication it's kind of outside of

00:08:54,920 --> 00:08:58,670
the scope of OAuth and I'll talk more

00:08:56,420 --> 00:08:59,779
about that later but hire me now wants

00:08:58,670 --> 00:09:03,110
to do the same thing it wants to set a

00:08:59,779 --> 00:09:05,240
calendar event on your Mike Hell so

00:09:03,110 --> 00:09:07,790
what's gonna happen now is the browser's

00:09:05,240 --> 00:09:09,710
gonna perform a get request to send an

00:09:07,790 --> 00:09:12,470
authorization request to the Mike how

00:09:09,710 --> 00:09:14,360
authorizations server and then the Mike

00:09:12,470 --> 00:09:16,790
how authorization server is going to

00:09:14,360 --> 00:09:19,160
prompt you the user to log in with Mike

00:09:16,790 --> 00:09:20,540
how using your Mike how credentials so

00:09:19,160 --> 00:09:22,250
you're logging in with the entity that

00:09:20,540 --> 00:09:25,660
is asking if you're dependent Riddle's

00:09:22,250 --> 00:09:28,130
not like a different service and then

00:09:25,660 --> 00:09:31,190
once the users authenticated with

00:09:28,130 --> 00:09:33,650
Michael then the Mike how authorization

00:09:31,190 --> 00:09:36,260
server is going to prompt you the user

00:09:33,650 --> 00:09:39,800
in the browser for your consent to allow

00:09:36,260 --> 00:09:41,960
hire me to access the Mike hell ap is to

00:09:39,800 --> 00:09:44,060
do one specific thing to add the event

00:09:41,960 --> 00:09:46,940
right because that's what you hire me

00:09:44,060 --> 00:09:49,339
wants to do for you and it's that's all

00:09:46,940 --> 00:09:51,200
its gonna say it's gonna say can will

00:09:49,339 --> 00:09:53,960
you allow hire me to add an event and

00:09:51,200 --> 00:09:56,630
not do anything more than that so if you

00:09:53,960 --> 00:09:58,100
say that's okay I will allow this then

00:09:56,630 --> 00:09:59,240
the Mike how authorization server is

00:09:58,100 --> 00:10:01,490
going to send what's called an

00:09:59,240 --> 00:10:03,140
authorization code to hire me and it's

00:10:01,490 --> 00:10:05,300
going to use the browser to do this

00:10:03,140 --> 00:10:07,730
and then hire me is going to take that

00:10:05,300 --> 00:10:09,950
code and it's app credentials and it's

00:10:07,730 --> 00:10:13,730
going to send those things back to my

00:10:09,950 --> 00:10:16,070
kal server side Michael at this point

00:10:13,730 --> 00:10:17,810
checks out that those credentials and

00:10:16,070 --> 00:10:19,490
the code says okay that everything is in

00:10:17,810 --> 00:10:22,160
order and then it's going to issue an

00:10:19,490 --> 00:10:24,680
access token to hire me which hire me

00:10:22,160 --> 00:10:26,390
can use to call the Mike hell API but

00:10:24,680 --> 00:10:28,760
only within the scope of the permissions

00:10:26,390 --> 00:10:31,070
that you as the user have said to it's

00:10:28,760 --> 00:10:33,860
okay to grant to hire me so at this

00:10:31,070 --> 00:10:36,290
point hire me can use that access token

00:10:33,860 --> 00:10:37,760
to call the Mike hell API to do the

00:10:36,290 --> 00:10:41,690
thing you said it could do which was to

00:10:37,760 --> 00:10:43,279
set calendar events now nothing

00:10:41,690 --> 00:10:43,880
insidious is happening anymore at this

00:10:43,279 --> 00:10:45,920
point

00:10:43,880 --> 00:10:48,250
Michael is asking the user to login with

00:10:45,920 --> 00:10:51,800
Mike he'll hire me is not asking for

00:10:48,250 --> 00:10:54,500
your Mike he'll credentials and hire me

00:10:51,800 --> 00:10:56,330
can only create events it can't do crazy

00:10:54,500 --> 00:10:58,490
things like change your settings or read

00:10:56,330 --> 00:11:00,650
all of your events so we have the issues

00:10:58,490 --> 00:11:02,860
with sharing credentials and the

00:11:00,650 --> 00:11:05,000
problems with giving too much access are

00:11:02,860 --> 00:11:06,880
basically gone they've been solved by

00:11:05,000 --> 00:11:09,230
the city

00:11:06,880 --> 00:11:11,630
but then the thing that happened after

00:11:09,230 --> 00:11:13,610
Oh wasps came on the scene was it

00:11:11,630 --> 00:11:17,060
applications wanted to do more than just

00:11:13,610 --> 00:11:18,980
call api's they wanted to be able to

00:11:17,060 --> 00:11:21,710
sign users in with accounts that we're

00:11:18,980 --> 00:11:24,680
living in other systems so maybe let's

00:11:21,710 --> 00:11:25,880
say hire me has discovered Oh aah

00:11:24,680 --> 00:11:29,030
they're like oh this is great

00:11:25,880 --> 00:11:30,770
and they want a mic he'll user to be

00:11:29,030 --> 00:11:32,480
able to log in to hire me using their

00:11:30,770 --> 00:11:36,080
mic he'll account even if they don't

00:11:32,480 --> 00:11:39,020
have a hire me account the thing is Oh

00:11:36,080 --> 00:11:40,970
auth 2 is for what we call delegated

00:11:39,020 --> 00:11:44,270
authorization or delegated access it's

00:11:40,970 --> 00:11:46,070
not an authentication protocol so

00:11:44,270 --> 00:11:47,990
there's a few problems with using OAuth

00:11:46,070 --> 00:11:50,570
2 for authentication

00:11:47,990 --> 00:11:52,670
if hire me does something like take this

00:11:50,570 --> 00:11:55,910
access token and because it has this

00:11:52,670 --> 00:11:58,190
Mike Hell API access token it just

00:11:55,910 --> 00:12:01,040
assumes that that means that the user is

00:11:58,190 --> 00:12:02,390
authenticated then what it's doing is

00:12:01,040 --> 00:12:04,700
it's assuming that the presence of the

00:12:02,390 --> 00:12:07,370
access token means that the users

00:12:04,700 --> 00:12:09,950
authenticated with hire me and this

00:12:07,370 --> 00:12:11,630
causes problems first of all someone

00:12:09,950 --> 00:12:13,970
could have stolen this access token we

00:12:11,630 --> 00:12:16,400
don't actually really know who it was

00:12:13,970 --> 00:12:17,840
issued for or where it came from the job

00:12:16,400 --> 00:12:19,460
token could be from a completely

00:12:17,840 --> 00:12:20,750
different user it could have been

00:12:19,460 --> 00:12:22,610
obtained from another client

00:12:20,750 --> 00:12:24,800
that's not hire me and then injected

00:12:22,610 --> 00:12:27,170
into hire me and we call this the

00:12:24,800 --> 00:12:28,640
confused deputy problem so hire me

00:12:27,170 --> 00:12:31,520
doesn't know where this token came for

00:12:28,640 --> 00:12:33,320
or who it was issued for and if we think

00:12:31,520 --> 00:12:35,060
back to what I said about what is

00:12:33,320 --> 00:12:36,800
authentication authentication is about

00:12:35,060 --> 00:12:39,410
verifying the user is who they say they

00:12:36,800 --> 00:12:41,600
are and hire me just can't know this

00:12:39,410 --> 00:12:45,620
from the fact that it has this access

00:12:41,600 --> 00:12:48,080
token so this didn't stop people from

00:12:45,620 --> 00:12:50,600
doing this anyway though so in order to

00:12:48,080 --> 00:12:53,000
address this we really needed to form

00:12:50,600 --> 00:12:55,340
eyes authentication on top of OAuth and

00:12:53,000 --> 00:12:59,720
this is how the open ID connect

00:12:55,340 --> 00:13:03,280
specification was born so the open ID

00:12:59,720 --> 00:13:05,890
foundation like ITF for OAuth is a

00:13:03,280 --> 00:13:08,740
organization that's responsible for

00:13:05,890 --> 00:13:10,760
essentially open ID connect it

00:13:08,740 --> 00:13:13,940
responsible for promoting it it's

00:13:10,760 --> 00:13:16,880
responsible for its committed to

00:13:13,940 --> 00:13:18,209
enabling and protecting the technologies

00:13:16,880 --> 00:13:20,369
and for writing the specs

00:13:18,209 --> 00:13:24,689
and it's a non-profit international

00:13:20,369 --> 00:13:27,119
standardization organization now again o

00:13:24,689 --> 00:13:30,329
auth 2 is for delegated authorization

00:13:27,119 --> 00:13:32,939
open ID Connect is for authentication so

00:13:30,329 --> 00:13:35,160
if you hear somebody say use OAuth 2 for

00:13:32,939 --> 00:13:36,929
authentication it's that's actually not

00:13:35,160 --> 00:13:39,209
accurate what you'd be using for

00:13:36,929 --> 00:13:43,499
authentication is open ID Connect which

00:13:39,209 --> 00:13:45,779
is a layer on top of OAuth 2 so open ID

00:13:43,499 --> 00:13:47,790
connect or OID C as it's commonly called

00:13:45,779 --> 00:13:51,089
is an identity layer on top of OAuth 2

00:13:47,790 --> 00:13:52,649
for authenticating users still using the

00:13:51,089 --> 00:13:55,439
thing that we call the authorization

00:13:52,649 --> 00:13:57,329
server and if we think back to the

00:13:55,439 --> 00:14:02,100
definition of the authorization server

00:13:57,329 --> 00:14:04,319
we know that it issues tokens so for

00:14:02,100 --> 00:14:06,540
authentication with OID C we do this

00:14:04,319 --> 00:14:09,720
with a type of token called an ID token

00:14:06,540 --> 00:14:12,089
and the authorization server can issue

00:14:09,720 --> 00:14:14,970
ID tokens similarly to the ways that it

00:14:12,089 --> 00:14:17,399
issues access tokens accept ID tokens

00:14:14,970 --> 00:14:19,519
are not meant for the resource server

00:14:17,399 --> 00:14:22,559
the API they're meant for the client

00:14:19,519 --> 00:14:26,490
they're also a fixed format that clients

00:14:22,559 --> 00:14:27,929
can parse and validate and they do the

00:14:26,490 --> 00:14:29,970
parse invalidate in order to extract

00:14:27,929 --> 00:14:33,689
identity information from the token and

00:14:29,970 --> 00:14:35,129
therefore be able to establish that the

00:14:33,689 --> 00:14:36,629
user is who they say they are because

00:14:35,129 --> 00:14:40,019
they've got this token that identifies

00:14:36,629 --> 00:14:42,899
them now open ID Connect as a

00:14:40,019 --> 00:14:46,529
specification extends to to show how to

00:14:42,899 --> 00:14:48,899
specifically issue ID tokens now like I

00:14:46,529 --> 00:14:52,949
mentioned there a fixed format ID tokens

00:14:48,899 --> 00:14:55,019
are the JSON web token format and a JSON

00:14:52,949 --> 00:14:59,339
web token looks like this it's

00:14:55,019 --> 00:15:01,379
essentially sorry it's three string

00:14:59,339 --> 00:15:03,689
segments concatenated with periods so

00:15:01,379 --> 00:15:08,549
it's a lot of sort of characters with

00:15:03,689 --> 00:15:11,549
dots in between the first segment oh my

00:15:08,549 --> 00:15:13,699
gosh well the first segment is a JSON

00:15:11,549 --> 00:15:16,589
object it's an object that contains an

00:15:13,699 --> 00:15:18,929
algorithm and a token type and it's then

00:15:16,589 --> 00:15:21,899
as base64 you're all encoded so that its

00:15:18,929 --> 00:15:25,259
URL and file name safe the second

00:15:21,899 --> 00:15:27,720
segment is another JSON object that is

00:15:25,259 --> 00:15:30,059
base64 you're all encoded and this

00:15:27,720 --> 00:15:31,769
object has statements about the user and

00:15:30,059 --> 00:15:36,300
information about the authentication

00:15:31,769 --> 00:15:38,790
than itself the last segment is a crypto

00:15:36,300 --> 00:15:40,619
segment and this is a signature so jason

00:15:38,790 --> 00:15:43,079
web tokens are signed so that they can't

00:15:40,619 --> 00:15:44,850
be modified in transit so when an

00:15:43,079 --> 00:15:47,129
authorization server issues an ID token

00:15:44,850 --> 00:15:49,199
it's gonna assign it using a key and

00:15:47,129 --> 00:15:51,089
then when the client receives that ID

00:15:49,199 --> 00:15:53,939
token is going to validate the signature

00:15:51,089 --> 00:15:55,829
using a key also now if we're using an

00:15:53,939 --> 00:15:57,420
asymmetric signing algorithm then

00:15:55,829 --> 00:15:59,399
different keys are used to sign and

00:15:57,420 --> 00:16:01,379
validate the tokens and in this case

00:15:59,399 --> 00:16:03,029
only the authorization server holds the

00:16:01,379 --> 00:16:04,589
signing key and so they're the only one

00:16:03,029 --> 00:16:06,449
that holds the ability to sign tokens

00:16:04,589 --> 00:16:10,199
and then various clients will have the

00:16:06,449 --> 00:16:12,239
public key and they'll be able to decode

00:16:10,199 --> 00:16:14,480
and validate them but they can't create

00:16:12,239 --> 00:16:18,509
their own they can't MIT new tokens

00:16:14,480 --> 00:16:21,119
now ID tokens as per their name provide

00:16:18,509 --> 00:16:23,850
identity information so if we come back

00:16:21,119 --> 00:16:24,959
to that second segment which is called

00:16:23,850 --> 00:16:26,910
the payload segment

00:16:24,959 --> 00:16:28,259
this was the JSON object with statements

00:16:26,910 --> 00:16:32,189
about the user and the authentication

00:16:28,259 --> 00:16:34,649
event and these are data claims so

00:16:32,189 --> 00:16:36,329
claims like I just said our statements

00:16:34,649 --> 00:16:38,639
about the user and the authentication

00:16:36,329 --> 00:16:42,420
event and if we take a look at some

00:16:38,639 --> 00:16:45,329
authentication claims you kind of see

00:16:42,420 --> 00:16:47,639
that these are some of them and I'll go

00:16:45,329 --> 00:16:49,230
through them kind of one by one so I

00:16:47,639 --> 00:16:51,559
guess listen to what I say rather than

00:16:49,230 --> 00:16:54,179
look at this but the first one is

00:16:51,559 --> 00:16:56,309
something called an issuer so this is

00:16:54,179 --> 00:16:59,879
going to be the identity of your

00:16:56,309 --> 00:17:01,860
authorization server there's also

00:16:59,879 --> 00:17:04,049
something called an audience and this is

00:17:01,860 --> 00:17:05,730
the ID of the app that the token has

00:17:04,049 --> 00:17:08,339
been issued for so it's the intended

00:17:05,730 --> 00:17:10,679
recipient of the token we also have

00:17:08,339 --> 00:17:12,539
timestamps for things like expiration

00:17:10,679 --> 00:17:14,309
and the time that it was issued at so

00:17:12,539 --> 00:17:17,069
that we can make sure that this tokens

00:17:14,309 --> 00:17:19,169
within a valid window and then finally

00:17:17,069 --> 00:17:21,000
we have something called a nonce and

00:17:19,169 --> 00:17:24,209
this is a cryptographically random

00:17:21,000 --> 00:17:25,799
string that binds the client to the ID

00:17:24,209 --> 00:17:28,049
token that it received from the

00:17:25,799 --> 00:17:30,120
authorization server so essentially what

00:17:28,049 --> 00:17:32,159
happens is the client creates this

00:17:30,120 --> 00:17:33,510
random string and when it makes an

00:17:32,159 --> 00:17:35,700
authorization request to the

00:17:33,510 --> 00:17:37,830
authorization server includes this nonce

00:17:35,700 --> 00:17:39,360
the string with the request the

00:17:37,830 --> 00:17:41,340
authorization server then takes the

00:17:39,360 --> 00:17:43,889
nonce and it puts it inside the token in

00:17:41,340 --> 00:17:45,630
this JSON object and then it sends it

00:17:43,889 --> 00:17:48,270
back so that the

00:17:45,630 --> 00:17:49,500
recipient of the token the client that

00:17:48,270 --> 00:17:52,140
issued the request in the first place

00:17:49,500 --> 00:17:53,610
can check that the knots in the token is

00:17:52,140 --> 00:17:55,440
the same nonce that made when it

00:17:53,610 --> 00:17:57,750
requested the token in the first place

00:17:55,440 --> 00:17:58,980
and it this is to prevent something

00:17:57,750 --> 00:18:01,110
called token injection

00:17:58,980 --> 00:18:02,550
so if we have tokus coming from

00:18:01,110 --> 00:18:04,170
somewhere other than the authorization

00:18:02,550 --> 00:18:06,720
server then they won't have a nonce that

00:18:04,170 --> 00:18:09,300
matches the authorization request so we

00:18:06,720 --> 00:18:11,190
can throw those tokens out so in

00:18:09,300 --> 00:18:14,430
addition to validating the signature

00:18:11,190 --> 00:18:16,590
using the keys we also want about verify

00:18:14,430 --> 00:18:18,840
authentication claims like the issuer is

00:18:16,590 --> 00:18:21,420
the token coming from the authorization

00:18:18,840 --> 00:18:23,880
server that we asked for it from the

00:18:21,420 --> 00:18:25,500
audience is this token intended for my

00:18:23,880 --> 00:18:27,480
application does it match my application

00:18:25,500 --> 00:18:29,370
ID the timestamps to make sure it's

00:18:27,480 --> 00:18:34,200
valid and then the nonce which I just

00:18:29,370 --> 00:18:36,540
described so the claims contains

00:18:34,200 --> 00:18:38,760
statements about the end user and the

00:18:36,540 --> 00:18:41,340
Ithaca authentication event so we talked

00:18:38,760 --> 00:18:43,050
about the authentication event there are

00:18:41,340 --> 00:18:44,970
some standard claims that we can ask the

00:18:43,050 --> 00:18:47,100
authorization server to include that

00:18:44,970 --> 00:18:50,010
tell us some information about the user

00:18:47,100 --> 00:18:53,070
so sort of the identity of the user part

00:18:50,010 --> 00:18:55,530
of the ID token some of them look a

00:18:53,070 --> 00:18:57,750
little bit like this one of the most

00:18:55,530 --> 00:18:59,670
important ones is the subject and this

00:18:57,750 --> 00:19:02,520
is a unique user identifier so you can

00:18:59,670 --> 00:19:04,620
think of it as the users ID and then we

00:19:02,520 --> 00:19:06,510
can also ask for other information about

00:19:04,620 --> 00:19:08,810
the user profile claims they could be

00:19:06,510 --> 00:19:12,180
things like the name address nickname

00:19:08,810 --> 00:19:15,900
email is the email verified things like

00:19:12,180 --> 00:19:17,790
that and these are all actually listed

00:19:15,900 --> 00:19:22,020
in the specification so you can take a

00:19:17,790 --> 00:19:24,210
look at what they are so what have we

00:19:22,020 --> 00:19:26,550
learned so far if we go back to sort of

00:19:24,210 --> 00:19:28,760
the idea about we're sort of making this

00:19:26,550 --> 00:19:31,880
bigger picture drawing the whole owl

00:19:28,760 --> 00:19:34,890
we've provided some background on ooofff

00:19:31,880 --> 00:19:37,190
we talked about how Open ID Connect is a

00:19:34,890 --> 00:19:39,630
layer on top of OAuth for authentication

00:19:37,190 --> 00:19:43,140
we talked about authorization servers

00:19:39,630 --> 00:19:45,840
what they are and how we issue do ID

00:19:43,140 --> 00:19:49,140
tokens for if we want to deal with

00:19:45,840 --> 00:19:51,000
authentication we talked about how the

00:19:49,140 --> 00:19:52,710
ID tokens of the JSON web token format

00:19:51,000 --> 00:19:54,570
and then we talked about the different

00:19:52,710 --> 00:19:57,150
claims that are contained in the ID

00:19:54,570 --> 00:19:59,250
token so if we pull all of this together

00:19:57,150 --> 00:20:00,480
then we can talk about

00:19:59,250 --> 00:20:02,640
the concepts of authentication

00:20:00,480 --> 00:20:05,010
specifically for JavaScript applications

00:20:02,640 --> 00:20:08,190
because we're JavaScript application

00:20:05,010 --> 00:20:11,220
developers here and in order to do that

00:20:08,190 --> 00:20:13,260
I want to take a little bit of a detour

00:20:11,220 --> 00:20:16,950
to talk about cookies and server-side

00:20:13,260 --> 00:20:19,860
web applications and I want to share how

00:20:16,950 --> 00:20:22,080
this works so if we think about an

00:20:19,860 --> 00:20:24,840
application that is built in a

00:20:22,080 --> 00:20:27,690
server-side language such as like PHP or

00:20:24,840 --> 00:20:29,370
dotnet or something like that then the

00:20:27,690 --> 00:20:30,929
scenario for authentication might look

00:20:29,370 --> 00:20:33,840
something more like this so you have

00:20:30,929 --> 00:20:35,700
your browser and then on the server you

00:20:33,840 --> 00:20:39,059
have your back-end web application and

00:20:35,700 --> 00:20:40,919
it might have a database and the users

00:20:39,059 --> 00:20:44,010
going to submit their credentials to log

00:20:40,919 --> 00:20:45,630
in and then if the login event is

00:20:44,010 --> 00:20:47,159
successful the server is going to set a

00:20:45,630 --> 00:20:49,830
cookie and the cookie represents a

00:20:47,159 --> 00:20:52,350
session at this point the server can or

00:20:49,830 --> 00:20:55,140
the app running on the server considers

00:20:52,350 --> 00:20:57,330
the user to be authenticated now on

00:20:55,140 --> 00:20:58,770
subsequent requests for pages whenever

00:20:57,330 --> 00:21:00,750
there's traffic to this domain the

00:20:58,770 --> 00:21:02,730
cookie is attached by the browser and

00:21:00,750 --> 00:21:04,020
sent to the server and we don't have to

00:21:02,730 --> 00:21:05,760
take any special action to make this

00:21:04,020 --> 00:21:08,659
happen it's a browser thing the browser

00:21:05,760 --> 00:21:11,909
will send the cookie for the storming

00:21:08,659 --> 00:21:13,590
the server can then send down the

00:21:11,909 --> 00:21:15,539
requested page HTML and sensitive data

00:21:13,590 --> 00:21:17,789
and deliver that to the browser and the

00:21:15,539 --> 00:21:19,950
user can look at it now if the cookie

00:21:17,789 --> 00:21:22,710
expires or there is no cookie and a

00:21:19,950 --> 00:21:24,809
request is made for protected data then

00:21:22,710 --> 00:21:27,539
the server is going to give us a 302

00:21:24,809 --> 00:21:29,580
redirect status and basically this is

00:21:27,539 --> 00:21:31,320
going to tell the browser hey do a full

00:21:29,580 --> 00:21:34,679
page redirect so that this user can

00:21:31,320 --> 00:21:38,520
authenticate once that's done then

00:21:34,679 --> 00:21:40,679
secure data can be sent again now for

00:21:38,520 --> 00:21:43,110
JavaScript applications and angular we

00:21:40,679 --> 00:21:45,210
often use token-based authentication and

00:21:43,110 --> 00:21:47,610
this looks a little bit different from

00:21:45,210 --> 00:21:49,470
cookie based authentication so if we

00:21:47,610 --> 00:21:51,659
want to take a look at tokens in a

00:21:49,470 --> 00:21:53,340
single page perhaps then we have our

00:21:51,659 --> 00:21:55,950
browser and then when the user navigates

00:21:53,340 --> 00:21:59,190
to an app the app is actually compiled

00:21:55,950 --> 00:22:02,250
downloaded and it runs in the browser we

00:21:59,190 --> 00:22:03,419
often get our data from api's and then

00:22:02,250 --> 00:22:06,360
we have let's say we have our

00:22:03,419 --> 00:22:07,740
authorization server now when the user

00:22:06,360 --> 00:22:09,330
wants to login they're going to make

00:22:07,740 --> 00:22:11,700
that authorization request to the

00:22:09,330 --> 00:22:13,170
authorization server the credentials are

00:22:11,700 --> 00:22:15,840
going to be verified and then

00:22:13,170 --> 00:22:17,970
station service gonna issue tokens the

00:22:15,840 --> 00:22:19,950
tokens are then sent to the application

00:22:17,970 --> 00:22:21,510
and the authorization server is going to

00:22:19,950 --> 00:22:23,850
set a cookie in the browser for the

00:22:21,510 --> 00:22:26,070
authorization servers domain and what

00:22:23,850 --> 00:22:28,500
this does is it represents the users off

00:22:26,070 --> 00:22:32,580
session with the authorization server

00:22:28,500 --> 00:22:34,860
itself the client on in JavaScript is

00:22:32,580 --> 00:22:37,680
going to parse the ID token and validate

00:22:34,860 --> 00:22:40,020
it and at this point the browser-based

00:22:37,680 --> 00:22:43,500
application can consider the user to be

00:22:40,020 --> 00:22:46,140
authenticated now when we make HTTP

00:22:43,500 --> 00:22:48,150
requests to our API we're gonna put the

00:22:46,140 --> 00:22:50,580
access token in the authorization header

00:22:48,150 --> 00:22:52,890
and then the API is going to verify this

00:22:50,580 --> 00:22:55,170
token using middleware and if everything

00:22:52,890 --> 00:22:57,210
checks out it's going to send data back

00:22:55,170 --> 00:23:01,020
to the browser in the form of JSON which

00:22:57,210 --> 00:23:02,970
the application can consume now in a

00:23:01,020 --> 00:23:06,990
single page app though if the page is

00:23:02,970 --> 00:23:09,180
refresh then the app reloads right so if

00:23:06,990 --> 00:23:11,970
we were putting our tokens in our user

00:23:09,180 --> 00:23:14,730
info in app memory then it's gone we

00:23:11,970 --> 00:23:17,190
don't have it but what we can do is we

00:23:14,730 --> 00:23:19,320
can actually use that cookie that the

00:23:17,190 --> 00:23:21,570
authorization server set to do something

00:23:19,320 --> 00:23:24,690
called checking session so if that

00:23:21,570 --> 00:23:27,120
concession is still valid then we're

00:23:24,690 --> 00:23:29,670
going to be able to use a essentially a

00:23:27,120 --> 00:23:31,530
hidden iframe and send the authorization

00:23:29,670 --> 00:23:33,600
server cookie to the authorization

00:23:31,530 --> 00:23:34,950
server to request new tokens without

00:23:33,600 --> 00:23:38,300
ever asking the user for their

00:23:34,950 --> 00:23:41,010
credentials and this is silent

00:23:38,300 --> 00:23:43,440
authentication so we can do this without

00:23:41,010 --> 00:23:45,240
the user ever needing to be prompted as

00:23:43,440 --> 00:23:46,740
long as they've got a valid cookie for

00:23:45,240 --> 00:23:49,590
the authorization server so essentially

00:23:46,740 --> 00:23:51,240
we can restore access and tokens even if

00:23:49,590 --> 00:23:53,340
the single page app reloads and we don't

00:23:51,240 --> 00:23:57,180
have to put tokens and sensitive data in

00:23:53,340 --> 00:23:59,130
something like local storage so why

00:23:57,180 --> 00:24:02,490
don't we use cookies for single page

00:23:59,130 --> 00:24:04,230
apps though well for one thing cookies

00:24:02,490 --> 00:24:07,560
only work on the domain of the

00:24:04,230 --> 00:24:10,350
application so if everything is on the

00:24:07,560 --> 00:24:13,920
same domain like your domain has your

00:24:10,350 --> 00:24:16,800
API on it then cookies are actually

00:24:13,920 --> 00:24:18,840
going to work in this scenario but many

00:24:16,800 --> 00:24:20,400
single page applications call api's that

00:24:18,840 --> 00:24:22,290
live on other domains or if they don't

00:24:20,400 --> 00:24:25,170
now they might need to scale and do so

00:24:22,290 --> 00:24:26,190
in the future and your domain session

00:24:25,170 --> 00:24:29,070
cookie isn't going

00:24:26,190 --> 00:24:31,740
to work for the API is domain so we

00:24:29,070 --> 00:24:34,080
could use the authorization servers

00:24:31,740 --> 00:24:35,700
cookie to check session because we were

00:24:34,080 --> 00:24:38,610
using doing traffic between the

00:24:35,700 --> 00:24:40,830
authorization server but between your

00:24:38,610 --> 00:24:43,409
application and the API is domain then

00:24:40,830 --> 00:24:47,220
you're the same session cookie is going

00:24:43,409 --> 00:24:48,720
to work because it's cross-origin so

00:24:47,220 --> 00:24:51,029
maybe you don't have this problem though

00:24:48,720 --> 00:24:53,279
maybe everything is on one domain if you

00:24:51,029 --> 00:24:55,379
have for example an angular app running

00:24:53,279 --> 00:24:58,230
on something like a dotnet back-end or

00:24:55,379 --> 00:25:00,000
react up with a node back-end and your

00:24:58,230 --> 00:25:03,389
back-end serves your API and they all

00:25:00,000 --> 00:25:05,039
live under the same domain then you can

00:25:03,389 --> 00:25:07,830
actually use cookies for this scenario

00:25:05,039 --> 00:25:10,710
and as long as you're not exposing your

00:25:07,830 --> 00:25:12,720
API for other people to use as like a

00:25:10,710 --> 00:25:14,730
third party API and the API is for

00:25:12,720 --> 00:25:16,399
exclusive use of your single page app

00:25:14,730 --> 00:25:19,159
that's running as a presentation layer

00:25:16,399 --> 00:25:22,110
then cookies are going to work and

00:25:19,159 --> 00:25:23,700
according to best practices you may

00:25:22,110 --> 00:25:25,080
actually want to consider using cookies

00:25:23,700 --> 00:25:28,710
if that's your architecture and you're

00:25:25,080 --> 00:25:31,559
sure that it's not going to change so if

00:25:28,710 --> 00:25:34,500
this is your case then authentication

00:25:31,559 --> 00:25:36,450
with a back-end that serves an API and a

00:25:34,500 --> 00:25:38,070
single page app as a presentation layer

00:25:36,450 --> 00:25:40,259
might look something like this

00:25:38,070 --> 00:25:43,139
you have your back-end that's capable of

00:25:40,259 --> 00:25:45,360
executing code and it's also providing

00:25:43,139 --> 00:25:47,370
API endpoints and then the backend

00:25:45,360 --> 00:25:49,259
serves the single page app which is

00:25:47,370 --> 00:25:51,029
going to run in the browser right and

00:25:49,259 --> 00:25:54,299
then you have your authorization server

00:25:51,029 --> 00:25:57,509
and we can use back-end routes to login

00:25:54,299 --> 00:25:58,679
and the backend app will can interact

00:25:57,509 --> 00:26:00,899
with the authorization server to

00:25:58,679 --> 00:26:02,370
authenticate users and then the data

00:26:00,899 --> 00:26:03,990
that's moving between the backend and

00:26:02,370 --> 00:26:07,820
the single page application can be

00:26:03,990 --> 00:26:11,220
secured with an HTTP only session cookie

00:26:07,820 --> 00:26:13,169
however maybe you don't have a back-end

00:26:11,220 --> 00:26:16,169
maybe you're going for something

00:26:13,169 --> 00:26:18,240
serverless maybe you're api's are on

00:26:16,169 --> 00:26:19,590
other domains maybe you know that you're

00:26:18,240 --> 00:26:21,480
going to need to scale and call other

00:26:19,590 --> 00:26:25,350
API is in the future or that you're

00:26:21,480 --> 00:26:28,080
going to provide your API to other

00:26:25,350 --> 00:26:33,080
people as a third party then in that

00:26:28,080 --> 00:26:36,179
case then you do want to use tokens now

00:26:33,080 --> 00:26:38,490
there's some guidance around the use of

00:26:36,179 --> 00:26:40,480
tokens in single page applications and

00:26:38,490 --> 00:26:42,880
in order to talk about the

00:26:40,480 --> 00:26:46,840
we're going to talk about what's been

00:26:42,880 --> 00:26:50,049
happening for the the sort of recent

00:26:46,840 --> 00:26:51,820
past that we know about so in 2012 this

00:26:50,049 --> 00:26:54,100
was the year that the oauth2 spec was

00:26:51,820 --> 00:26:55,929
adopted and single page applications

00:26:54,100 --> 00:26:59,020
weren't mainstream yet at this point in

00:26:55,929 --> 00:27:00,970
time so for example angularjs didn't

00:26:59,020 --> 00:27:05,500
actually become popular and gained a lot

00:27:00,970 --> 00:27:07,299
of traction and use until about 2014 so

00:27:05,500 --> 00:27:11,200
that doesn't mean that a loss didn't

00:27:07,299 --> 00:27:13,630
address the idea of this though so if

00:27:11,200 --> 00:27:16,690
you were going to make a request to

00:27:13,630 --> 00:27:18,490
authorization server then the same

00:27:16,690 --> 00:27:21,070
endpoint that receives the authorization

00:27:18,490 --> 00:27:23,919
request used to return tokens to the

00:27:21,070 --> 00:27:25,990
browser in a URL hash fragment and this

00:27:23,919 --> 00:27:27,970
is how we would get tokens if we were

00:27:25,990 --> 00:27:30,970
using a single page app and an

00:27:27,970 --> 00:27:32,590
authorization server now there's some

00:27:30,970 --> 00:27:35,590
security risks with doing this though

00:27:32,590 --> 00:27:38,530
especially for access tokens because

00:27:35,590 --> 00:27:40,030
access tokens grant API access if we

00:27:38,530 --> 00:27:41,530
were to think back to the problem with

00:27:40,030 --> 00:27:42,760
the confuse deputy the application

00:27:41,530 --> 00:27:44,679
doesn't actually know where these access

00:27:42,760 --> 00:27:47,320
tokens really came from it just assumed

00:27:44,679 --> 00:27:49,030
that if it gets an access token in this

00:27:47,320 --> 00:27:51,520
hash fragment that it should use it and

00:27:49,030 --> 00:27:53,409
it was okay to use so the tokens are

00:27:51,520 --> 00:27:55,240
vulnerable in a number of ways they're

00:27:53,409 --> 00:27:58,630
vulnerable in what we call the redirect

00:27:55,240 --> 00:28:02,980
URI which means that we could receive

00:27:58,630 --> 00:28:04,750
the token to a URL that is not supposed

00:28:02,980 --> 00:28:06,610
to go to a malicious actor could say hey

00:28:04,750 --> 00:28:08,460
this token should be sent to me instead

00:28:06,610 --> 00:28:10,840
of you know where it's supposed to go

00:28:08,460 --> 00:28:13,510
it's also accessible in the browser

00:28:10,840 --> 00:28:14,890
history the browser history API is

00:28:13,510 --> 00:28:17,950
accessible to any JavaScript running on

00:28:14,890 --> 00:28:21,730
the page right it's accessible in the

00:28:17,950 --> 00:28:23,799
referer header so if malicious page was

00:28:21,730 --> 00:28:25,780
requested right after a login event then

00:28:23,799 --> 00:28:27,340
we could the malicious actor could grab

00:28:25,780 --> 00:28:29,500
that token out of the referer header as

00:28:27,340 --> 00:28:31,360
well and then finally we have this

00:28:29,500 --> 00:28:33,340
problem of the application doesn't know

00:28:31,360 --> 00:28:36,610
if the token was injected maliciously

00:28:33,340 --> 00:28:38,380
from somewhere else now authorization

00:28:36,610 --> 00:28:40,900
servers and application developers

00:28:38,380 --> 00:28:42,460
mitigate these security risks we work

00:28:40,900 --> 00:28:45,039
pretty hard we'd put in a lot of effort

00:28:42,460 --> 00:28:46,900
to do this and I talked about strategies

00:28:45,039 --> 00:28:48,909
like for the ID token for example

00:28:46,900 --> 00:28:51,790
validating the signatures and verifying

00:28:48,909 --> 00:28:53,040
the claims and I want to be really clear

00:28:51,790 --> 00:28:55,380
that there's no new threats

00:28:53,040 --> 00:28:56,910
this approach it's not like all of a

00:28:55,380 --> 00:28:58,110
sudden there's some new attack and

00:28:56,910 --> 00:29:00,420
everything that we've been doing for the

00:28:58,110 --> 00:29:02,280
last seven years is a terrible idea and

00:29:00,420 --> 00:29:05,160
all of a sudden all those apps are

00:29:02,280 --> 00:29:08,610
falling because they're not and in fact

00:29:05,160 --> 00:29:11,850
this approach is still viable if you're

00:29:08,610 --> 00:29:15,300
only requesting ID tokens because we

00:29:11,850 --> 00:29:18,060
validate ID tokens in the client and we

00:29:15,300 --> 00:29:22,320
would never use ID tokens to access

00:29:18,060 --> 00:29:24,180
other resources and also if you have

00:29:22,320 --> 00:29:26,730
mitigated if you have a lot of good

00:29:24,180 --> 00:29:29,100
cross-site scripting protections and

00:29:26,730 --> 00:29:31,140
you're sort of making sure that you're

00:29:29,100 --> 00:29:32,370
validating and your tokens properly then

00:29:31,140 --> 00:29:33,420
the same mitigations you've been using

00:29:32,370 --> 00:29:36,510
for the last seven years they're gonna

00:29:33,420 --> 00:29:38,160
continue to work but because modern

00:29:36,510 --> 00:29:39,750
JavaScript is really just sort of eating

00:29:38,160 --> 00:29:42,570
the world of web apps at this stage in

00:29:39,750 --> 00:29:44,490
time it was just the right time for the

00:29:42,570 --> 00:29:47,940
IETF to start recommending new best

00:29:44,490 --> 00:29:50,490
practices so in early 2019 they worked

00:29:47,940 --> 00:29:51,660
on this and did this and so I'm going to

00:29:50,490 --> 00:29:54,510
tell you about what the new best

00:29:51,660 --> 00:29:56,250
practice is now it's actually the same

00:29:54,510 --> 00:29:57,690
approach that's used in mobile apps

00:29:56,250 --> 00:30:00,930
because mobile applications are also

00:29:57,690 --> 00:30:03,120
public clients and essentially it

00:30:00,930 --> 00:30:06,120
involves exchanging a code for a token

00:30:03,120 --> 00:30:09,600
so it's a few more steps than the old

00:30:06,120 --> 00:30:12,480
process but how this works is basically

00:30:09,600 --> 00:30:14,850
on the client we create a random string

00:30:12,480 --> 00:30:16,500
call the code verifier and then we use a

00:30:14,850 --> 00:30:19,020
hashing method called the code challege

00:30:16,500 --> 00:30:21,750
method to compute another string from

00:30:19,020 --> 00:30:23,970
this code verifier then when the user

00:30:21,750 --> 00:30:26,100
comes along and we make an authorization

00:30:23,970 --> 00:30:28,500
request to the authorization server we

00:30:26,100 --> 00:30:30,180
take the requests the code challenge and

00:30:28,500 --> 00:30:32,250
the code challenge method that hashing

00:30:30,180 --> 00:30:33,990
method and we send these things to the

00:30:32,250 --> 00:30:36,750
authorization servers authorization

00:30:33,990 --> 00:30:38,100
endpoint and the authorization server is

00:30:36,750 --> 00:30:39,630
going to take these things and keep

00:30:38,100 --> 00:30:41,940
track of them that's going to generate a

00:30:39,630 --> 00:30:43,710
code and it's gonna send the code to the

00:30:41,940 --> 00:30:45,960
browser and the browser's going to

00:30:43,710 --> 00:30:48,660
receive this code in a URL query string

00:30:45,960 --> 00:30:50,640
and this is actually fine to do unlike

00:30:48,660 --> 00:30:52,530
putting the tokens in the URL because

00:30:50,640 --> 00:30:54,600
interception of the code by itself isn't

00:30:52,530 --> 00:30:56,130
dangerous because it doesn't grant

00:30:54,600 --> 00:30:57,420
access to anything someone could steal

00:30:56,130 --> 00:30:59,010
this code and then they wouldn't be able

00:30:57,420 --> 00:31:01,200
to do anything with it they wouldn't be

00:30:59,010 --> 00:31:04,020
able to get anywhere because once we

00:31:01,200 --> 00:31:06,060
have that code then we're going to make

00:31:04,020 --> 00:31:06,960
another request to the authorization

00:31:06,060 --> 00:31:08,399
server we're going to

00:31:06,960 --> 00:31:10,350
take the code and the code verifier

00:31:08,399 --> 00:31:11,460
we're going to send those to a different

00:31:10,350 --> 00:31:13,679
end point on the authorization server

00:31:11,460 --> 00:31:15,510
called the token end point the

00:31:13,679 --> 00:31:18,029
authorization server is then going to

00:31:15,510 --> 00:31:20,899
calculate the code challenge from the

00:31:18,029 --> 00:31:23,309
verifier using the code challenge method

00:31:20,899 --> 00:31:25,679
it's going to compare that calculated

00:31:23,309 --> 00:31:27,120
challenge that it just calculated itself

00:31:25,679 --> 00:31:28,799
it's going to compare it to the

00:31:27,120 --> 00:31:32,460
challenge that the applications sent on

00:31:28,799 --> 00:31:34,409
the first pass the initial pass and if

00:31:32,460 --> 00:31:36,809
those challenges match then it's going

00:31:34,409 --> 00:31:40,559
to issue tokens and deliver them to the

00:31:36,809 --> 00:31:42,630
application as a JSON object now all the

00:31:40,559 --> 00:31:44,610
mitigations for the security risks that

00:31:42,630 --> 00:31:47,850
we were facing with putting the tokens

00:31:44,610 --> 00:31:50,549
in the URL are not needed anymore so

00:31:47,850 --> 00:31:52,799
they're sort of taken care of but this

00:31:50,549 --> 00:31:54,600
is a lot of work right it looks like

00:31:52,799 --> 00:31:56,760
more a lot it's a lot more things to

00:31:54,600 --> 00:31:59,659
deal with you have to deal with hashing

00:31:56,760 --> 00:32:01,679
and you have to deal with multiple

00:31:59,659 --> 00:32:04,080
endpoints on the authorization server

00:32:01,679 --> 00:32:06,840
and all of these things but the great

00:32:04,080 --> 00:32:09,049
thing is that SDKs can basically take

00:32:06,840 --> 00:32:14,159
all of this and do it for you

00:32:09,049 --> 00:32:15,840
so these new best practices what from a

00:32:14,159 --> 00:32:19,620
pragmatic sense what do they mean for

00:32:15,840 --> 00:32:21,390
you as an application developer well if

00:32:19,620 --> 00:32:23,429
you are building a brand-new application

00:32:21,390 --> 00:32:25,500
and you've got a green field then I

00:32:23,429 --> 00:32:28,169
strongly recommend that you use the new

00:32:25,500 --> 00:32:30,330
approach like I said SDKs can really

00:32:28,169 --> 00:32:32,279
sort of alleviate the stress of needing

00:32:30,330 --> 00:32:34,110
to sort of generate the code verify

00:32:32,279 --> 00:32:37,320
yourself and dealing with the hashing

00:32:34,110 --> 00:32:39,120
and almost that type of thing but if you

00:32:37,320 --> 00:32:41,580
have existing applications that are

00:32:39,120 --> 00:32:43,049
already running in production again I

00:32:41,580 --> 00:32:45,299
want to emphasize there's no new threats

00:32:43,049 --> 00:32:47,220
to how we did it for the last seven

00:32:45,299 --> 00:32:49,770
years there's innumerable single page

00:32:47,220 --> 00:32:51,960
apps out there using the old approach

00:32:49,770 --> 00:32:53,549
everything that's been doing this for

00:32:51,960 --> 00:32:55,500
the last seven years is using the old

00:32:53,549 --> 00:32:57,809
approach so I would really encourage you

00:32:55,500 --> 00:32:59,399
to assess your needs and then make the

00:32:57,809 --> 00:33:02,100
choice that works best for your team

00:32:59,399 --> 00:33:05,220
your application your company your

00:33:02,100 --> 00:33:08,070
client see if what makes the most sense

00:33:05,220 --> 00:33:11,159
if you have time and resources to

00:33:08,070 --> 00:33:13,080
re-implement and switch over to the new

00:33:11,159 --> 00:33:14,340
approach then that's awesome you can

00:33:13,080 --> 00:33:16,799
sort of do away with all of the

00:33:14,340 --> 00:33:17,580
mitigations but as long as you are using

00:33:16,799 --> 00:33:20,130
those mitigations

00:33:17,580 --> 00:33:21,930
and you have

00:33:20,130 --> 00:33:23,940
something in place if you don't have

00:33:21,930 --> 00:33:27,840
time and resources it's not really the

00:33:23,940 --> 00:33:30,600
end of the world so if we come back to

00:33:27,840 --> 00:33:32,760
kind of drawing this owl we've now

00:33:30,600 --> 00:33:35,280
covered traditional web application with

00:33:32,760 --> 00:33:37,650
cookies web application authentication

00:33:35,280 --> 00:33:41,280
with cookies and we've also covered

00:33:37,650 --> 00:33:43,170
single page app off with tokens on api's

00:33:41,280 --> 00:33:45,810
that are on the same domain as well as

00:33:43,170 --> 00:33:47,970
cross-origin but i want you to remember

00:33:45,810 --> 00:33:49,800
this is still only really a two-step

00:33:47,970 --> 00:33:52,440
process it only has to be a two-step

00:33:49,800 --> 00:33:55,110
process only now you know a lot more

00:33:52,440 --> 00:33:57,540
about what's going on in the interim

00:33:55,110 --> 00:34:00,390
steps so essentially you've leveled up

00:33:57,540 --> 00:34:02,820
and you can get started right away by

00:34:00,390 --> 00:34:03,570
using an identity as a service like

00:34:02,820 --> 00:34:05,940
auth0

00:34:03,570 --> 00:34:08,730
and osteo for example provides

00:34:05,940 --> 00:34:10,320
JavaScript SDK that implements the new

00:34:08,730 --> 00:34:11,879
best practices for you and all you

00:34:10,320 --> 00:34:14,250
really have to do is configure it and

00:34:11,879 --> 00:34:16,020
throw it into your application and then

00:34:14,250 --> 00:34:18,330
we also provide QuickStart tutorials

00:34:16,020 --> 00:34:20,310
with sample code so that you can quickly

00:34:18,330 --> 00:34:23,310
and easily implement this in your

00:34:20,310 --> 00:34:30,679
angular applications and you probably

00:34:23,310 --> 00:34:30,679
can't tell but I disasters are happening

00:34:31,310 --> 00:34:36,960
and I so I wrote the QuickStart so if

00:34:35,129 --> 00:34:39,419
you have any feedback about it or

00:34:36,960 --> 00:34:54,179
complaints about it you can you can come

00:34:39,419 --> 00:34:56,730
to me with that stuff - thanks so how

00:34:54,179 --> 00:35:00,240
does angular as a platform help us deal

00:34:56,730 --> 00:35:02,790
with a lot of these things and I want to

00:35:00,240 --> 00:35:04,290
cover this by using sort of a to-do list

00:35:02,790 --> 00:35:05,910
and I don't mean we're gonna like build

00:35:04,290 --> 00:35:07,950
to do this application or something like

00:35:05,910 --> 00:35:10,890
that it's just these are things that we

00:35:07,950 --> 00:35:12,630
want to make sure that we cover when

00:35:10,890 --> 00:35:15,690
we're dealing with authentication in

00:35:12,630 --> 00:35:17,400
angular the first thing that we want to

00:35:15,690 --> 00:35:19,620
be able to do is elegantly manage

00:35:17,400 --> 00:35:22,290
authentication events so this might be

00:35:19,620 --> 00:35:24,210
stuff like when is the token available

00:35:22,290 --> 00:35:26,910
what's the login status of the user

00:35:24,210 --> 00:35:29,090
things like that we also need to be able

00:35:26,910 --> 00:35:32,880
to send the token with API requests and

00:35:29,090 --> 00:35:33,920
then on the UI we do want to probably be

00:35:32,880 --> 00:35:37,100
able to restrict

00:35:33,920 --> 00:35:39,140
to certain routes now we have let's say

00:35:37,100 --> 00:35:41,390
we should always have our API protected

00:35:39,140 --> 00:35:43,910
but we don't we can't solely rely on

00:35:41,390 --> 00:35:45,950
that because we can't just make API

00:35:43,910 --> 00:35:47,930
calls and then get an error back and be

00:35:45,950 --> 00:35:49,760
like hey user sorry like you actually

00:35:47,930 --> 00:35:50,690
can't access that endpoint we want to be

00:35:49,760 --> 00:35:54,440
able to stop them before they get to

00:35:50,690 --> 00:35:57,170
that point in the UI so if we talk about

00:35:54,440 --> 00:35:59,840
managing authentication events angular

00:35:57,170 --> 00:36:03,350
has this awesome library that comes with

00:35:59,840 --> 00:36:06,650
it which is rxjs of course an RCS helps

00:36:03,350 --> 00:36:08,960
us to do things like interact with SDKs

00:36:06,650 --> 00:36:10,640
in a reactive way so we can do things

00:36:08,960 --> 00:36:12,830
like binding callbacks or converting

00:36:10,640 --> 00:36:14,750
promises this is especially useful if

00:36:12,830 --> 00:36:16,430
we're using external libraries like an

00:36:14,750 --> 00:36:18,110
external javascript sdk from an

00:36:16,430 --> 00:36:20,090
authorization server then maybe was

00:36:18,110 --> 00:36:22,850
built for all javascript in general but

00:36:20,090 --> 00:36:24,530
not specifically with angular in mind so

00:36:22,850 --> 00:36:26,810
maybe it's not reactive out-of-the-box

00:36:24,530 --> 00:36:28,850
and we can take methods from the

00:36:26,810 --> 00:36:32,330
libraries and turn them into observable

00:36:28,850 --> 00:36:34,670
streams so for example maybe our

00:36:32,330 --> 00:36:37,190
authentication SDK provides some kind of

00:36:34,670 --> 00:36:38,960
a callback method to return token data

00:36:37,190 --> 00:36:41,630
from the authorization server after the

00:36:38,960 --> 00:36:43,550
user logs in what we can do is use

00:36:41,630 --> 00:36:46,430
something like buying call back or by

00:36:43,550 --> 00:36:49,190
node call back depending on how the SDK

00:36:46,430 --> 00:36:50,840
is constructed from rxjs to do something

00:36:49,190 --> 00:36:54,320
like create an observable that's going

00:36:50,840 --> 00:36:56,090
to emit when the callback completes then

00:36:54,320 --> 00:36:58,220
we can subscribe to this observable and

00:36:56,090 --> 00:37:01,610
pass options to the bound SDK method if

00:36:58,220 --> 00:37:03,680
necessary and if the library returns

00:37:01,610 --> 00:37:05,330
promises then we can use the from

00:37:03,680 --> 00:37:09,080
observable creation method to convert

00:37:05,330 --> 00:37:11,090
promises to observables as well the

00:37:09,080 --> 00:37:14,240
other thing that rxjs can really help us

00:37:11,090 --> 00:37:16,580
do is manage streams of authentication

00:37:14,240 --> 00:37:18,230
data this could be like I mentioned

00:37:16,580 --> 00:37:20,870
before token availability user

00:37:18,230 --> 00:37:23,000
availability of user information login

00:37:20,870 --> 00:37:24,950
status as user logged in or out when

00:37:23,000 --> 00:37:27,860
does this happen and do I need to react

00:37:24,950 --> 00:37:29,900
to it in some way in my application so

00:37:27,860 --> 00:37:32,510
for example if we wanted to create a

00:37:29,900 --> 00:37:33,920
stream for user data then we could do

00:37:32,510 --> 00:37:36,530
something like create a private behavior

00:37:33,920 --> 00:37:39,470
subject in an authentication service and

00:37:36,530 --> 00:37:41,270
then when data becomes available that or

00:37:39,470 --> 00:37:42,920
changes as a result of some kind of

00:37:41,270 --> 00:37:45,440
authentication event then we can tell

00:37:42,920 --> 00:37:47,300
the stream to emit values and then we

00:37:45,440 --> 00:37:47,830
can expose the user observable publicly

00:37:47,300 --> 00:37:50,290
to our

00:37:47,830 --> 00:37:53,260
location and then subscribe to it and

00:37:50,290 --> 00:37:55,260
take some action as a result of new

00:37:53,260 --> 00:37:57,670
values being emitted from this stream

00:37:55,260 --> 00:38:00,460
now these are really just a couple of

00:37:57,670 --> 00:38:02,080
surface level examples of how rxjs can

00:38:00,460 --> 00:38:04,210
help us to do things like manage

00:38:02,080 --> 00:38:06,010
authentication data and callbacks and

00:38:04,210 --> 00:38:08,620
I'm sure that you can find a lot more

00:38:06,010 --> 00:38:10,150
ways to use rxjs to help with

00:38:08,620 --> 00:38:12,940
authentication in your apps and if you

00:38:10,150 --> 00:38:16,420
do I would love to hear about it so

00:38:12,940 --> 00:38:19,090
please let me know on Twitter or however

00:38:16,420 --> 00:38:20,860
I would love to take some of those

00:38:19,090 --> 00:38:24,160
examples and maybe highlight them and in

00:38:20,860 --> 00:38:25,690
future talks or something like that so

00:38:24,160 --> 00:38:27,760
if we come back to our authentication

00:38:25,690 --> 00:38:29,710
to-do list we learned that we can

00:38:27,760 --> 00:38:32,920
elegantly manage authentication events

00:38:29,710 --> 00:38:35,140
with rxjs so that brings us to the topic

00:38:32,920 --> 00:38:38,110
of sending the token with API requests

00:38:35,140 --> 00:38:41,110
and we can do this which with HTTP

00:38:38,110 --> 00:38:44,050
interceptors now interceptors transform

00:38:41,110 --> 00:38:46,450
requests or responses so when we call

00:38:44,050 --> 00:38:49,300
the API then we can intercept requests

00:38:46,450 --> 00:38:51,520
using an interceptor service and then we

00:38:49,300 --> 00:38:54,010
can attach the authorization header with

00:38:51,520 --> 00:38:56,770
a token and then we can send the whole

00:38:54,010 --> 00:38:58,780
request on its way and we use

00:38:56,770 --> 00:39:01,960
interceptors by setting off in our app

00:38:58,780 --> 00:39:04,360
routing module so in the providers array

00:39:01,960 --> 00:39:08,320
of our ng module in our app routing

00:39:04,360 --> 00:39:10,450
module we are going to provide the HTTP

00:39:08,320 --> 00:39:12,640
interceptors token from angular common

00:39:10,450 --> 00:39:14,620
and then we're going to tell it to use

00:39:12,640 --> 00:39:16,270
an interceptor service class and I'll

00:39:14,620 --> 00:39:16,780
talk about what the class looks like in

00:39:16,270 --> 00:39:19,180
a moment

00:39:16,780 --> 00:39:20,710
and we can set multi to true because we

00:39:19,180 --> 00:39:22,210
can potentially define multiple

00:39:20,710 --> 00:39:23,230
interceptors they're just going to be

00:39:22,210 --> 00:39:26,470
called in the order that they're

00:39:23,230 --> 00:39:29,110
provided now that interceptor service

00:39:26,470 --> 00:39:30,130
class might look something like this it

00:39:29,110 --> 00:39:32,080
might contain something like this

00:39:30,130 --> 00:39:35,920
there's some necessary set up and then

00:39:32,080 --> 00:39:38,350
inside the intercept function we can

00:39:35,920 --> 00:39:40,780
take that HTTP request that's coming

00:39:38,350 --> 00:39:43,060
through and we can clone it and then we

00:39:40,780 --> 00:39:45,430
can set an authorization header on that

00:39:43,060 --> 00:39:47,430
outgoing request with the value of

00:39:45,430 --> 00:39:49,630
bearer and then the access token and

00:39:47,430 --> 00:39:53,380
then we can send the cloned request on

00:39:49,630 --> 00:39:55,870
its way with the new header attached now

00:39:53,380 --> 00:39:57,850
there's not out-of-the-box a way to only

00:39:55,870 --> 00:40:00,520
run interceptors on specific requests

00:39:57,850 --> 00:40:01,589
but we can very easily use conditional

00:40:00,520 --> 00:40:04,150
logic to do this

00:40:01,589 --> 00:40:09,069
so we can cone and modify requests based

00:40:04,150 --> 00:40:10,329
on some condition so if our for example

00:40:09,069 --> 00:40:13,059
you may want to do this for security

00:40:10,329 --> 00:40:16,270
right because if you're you want to see

00:40:13,059 --> 00:40:18,130
if you're requested endpoint matches the

00:40:16,270 --> 00:40:19,059
API that we want to send the token to

00:40:18,130 --> 00:40:21,130
because you don't want to necessarily

00:40:19,059 --> 00:40:23,859
attach tokens to every single request

00:40:21,130 --> 00:40:25,660
that's going out especially if you are

00:40:23,859 --> 00:40:27,970
you sort of victim to some kind of

00:40:25,660 --> 00:40:29,890
attack where your app can call something

00:40:27,970 --> 00:40:31,540
that it shouldn't be calling then we

00:40:29,890 --> 00:40:34,240
don't want to just freely give our token

00:40:31,540 --> 00:40:36,579
to every outgoing request so we can do

00:40:34,240 --> 00:40:39,579
something like take the original HTTP

00:40:36,579 --> 00:40:44,619
request and see what its URL was and

00:40:39,579 --> 00:40:47,260
then check for some condition updated

00:40:44,619 --> 00:40:51,130
some code here which may not be accurate

00:40:47,260 --> 00:40:52,690
anymore but we can also check for if we

00:40:51,130 --> 00:40:54,220
only want certain endpoints on our API

00:40:52,690 --> 00:40:56,410
to be secured then we might check for a

00:40:54,220 --> 00:41:00,400
certain segment that's going to exist in

00:40:56,410 --> 00:41:03,280
the URL and then only clone if necessary

00:41:00,400 --> 00:41:05,109
and then if it doesn't meet the

00:41:03,280 --> 00:41:07,210
conditions that we set up set for it

00:41:05,109 --> 00:41:09,130
then we can send the original HTTP

00:41:07,210 --> 00:41:13,150
request on its way without attaching any

00:41:09,130 --> 00:41:16,200
headers to it now another thing we can

00:41:13,150 --> 00:41:18,430
do is create asynchronous interceptors

00:41:16,200 --> 00:41:21,670
so we can wait for something to happen

00:41:18,430 --> 00:41:24,099
and this is specifically useful in the

00:41:21,670 --> 00:41:26,950
scenario where you load a page and then

00:41:24,099 --> 00:41:29,020
you make API requests in the background

00:41:26,950 --> 00:41:31,119
while the page loads but if you want

00:41:29,020 --> 00:41:32,890
them some of them to be authorized then

00:41:31,119 --> 00:41:34,660
you're going to want to wait until the

00:41:32,890 --> 00:41:36,790
token is available so you're not trying

00:41:34,660 --> 00:41:38,170
to send requests with something like an

00:41:36,790 --> 00:41:41,170
authorization header that says bearer

00:41:38,170 --> 00:41:42,819
undefined in it so we can use our XJS to

00:41:41,170 --> 00:41:44,290
wait until data is available before we

00:41:42,819 --> 00:41:47,650
do something like coding the request and

00:41:44,290 --> 00:41:50,170
attaching the header so we could do

00:41:47,650 --> 00:41:52,119
something like with rxjs we can set up a

00:41:50,170 --> 00:41:54,309
token stream in our authentication

00:41:52,119 --> 00:41:56,230
service for example and then we can

00:41:54,309 --> 00:41:58,750
ensure that the token is present in the

00:41:56,230 --> 00:42:00,849
application and set the token once it's

00:41:58,750 --> 00:42:02,559
available so we can use something like

00:42:00,849 --> 00:42:04,329
merge map to ensure that if there are

00:42:02,559 --> 00:42:07,329
multiple requests then not are cancelled

00:42:04,329 --> 00:42:09,940
by a new request so if we come back to

00:42:07,329 --> 00:42:11,829
our to-do list we know we can use

00:42:09,940 --> 00:42:15,130
interceptors to send the token with API

00:42:11,829 --> 00:42:17,020
requests and this brings us to the

00:42:15,130 --> 00:42:19,930
topic of restricting access to certain

00:42:17,020 --> 00:42:22,270
routes and people are probably fairly

00:42:19,930 --> 00:42:24,190
familiar with route guards at this time

00:42:22,270 --> 00:42:27,100
route cars implement three different

00:42:24,190 --> 00:42:29,710
interfaces the can activate interface is

00:42:27,100 --> 00:42:32,680
the probably just by default the most

00:42:29,710 --> 00:42:34,840
commonly used example and it prevents

00:42:32,680 --> 00:42:37,690
unauthorized users from navigating to a

00:42:34,840 --> 00:42:39,220
particular UI route but the thing is the

00:42:37,690 --> 00:42:41,500
code for this route is still in your

00:42:39,220 --> 00:42:43,480
bundle it's still going to be loaded now

00:42:41,500 --> 00:42:46,090
it holds true that you wouldn't put

00:42:43,480 --> 00:42:48,370
sensitive data into your front-end

00:42:46,090 --> 00:42:52,270
hopefully you're not doing that it

00:42:48,370 --> 00:42:55,870
belongs on the API but if you do do that

00:42:52,270 --> 00:42:58,390
the code for your can't activate route

00:42:55,870 --> 00:43:00,190
is still in your application bundle so

00:42:58,390 --> 00:43:03,580
it's actually still available to people

00:43:00,190 --> 00:43:05,080
once your app is downloaded now can

00:43:03,580 --> 00:43:06,730
activate child is similar to can

00:43:05,080 --> 00:43:08,800
activate it prevents unauthorized users

00:43:06,730 --> 00:43:11,980
from navigating to all children of a

00:43:08,800 --> 00:43:13,300
specific parent and then can load is a

00:43:11,980 --> 00:43:15,640
little bit different from the other two

00:43:13,300 --> 00:43:17,620
because it prevents lazy loaded modules

00:43:15,640 --> 00:43:20,200
from downloading in the first place if

00:43:17,620 --> 00:43:23,710
the users aren't authorized to look at

00:43:20,200 --> 00:43:26,380
it and the way a lot of this works is in

00:43:23,710 --> 00:43:29,380
our app routing module when we set up

00:43:26,380 --> 00:43:33,100
our routes we can use the interface name

00:43:29,380 --> 00:43:34,510
as the property for the guard that we

00:43:33,100 --> 00:43:36,640
want to add and then we can give it an

00:43:34,510 --> 00:43:38,260
array so we can pass it multiple guards

00:43:36,640 --> 00:43:40,660
they're going to run in the order that

00:43:38,260 --> 00:43:42,390
they're listed so if we just have

00:43:40,660 --> 00:43:45,970
something like an authentication guard

00:43:42,390 --> 00:43:49,200
that's going to check if the users just

00:43:45,970 --> 00:43:51,760
logged in or not as another note off

00:43:49,200 --> 00:43:53,740
guard files can implement multiple

00:43:51,760 --> 00:43:55,900
interfaces so you can have an off guard

00:43:53,740 --> 00:43:58,720
file that actually has a can't activate

00:43:55,900 --> 00:44:01,420
and I can load in it also so you can use

00:43:58,720 --> 00:44:05,830
that sort of same file with the

00:44:01,420 --> 00:44:08,500
different interface types but the can

00:44:05,830 --> 00:44:10,630
activate guard in particular is going to

00:44:08,500 --> 00:44:12,250
have a can activate function in it and

00:44:10,630 --> 00:44:16,540
this function returns an observable a

00:44:12,250 --> 00:44:18,160
promise or a boolean so inside the guard

00:44:16,540 --> 00:44:20,140
our can activate function might contain

00:44:18,160 --> 00:44:22,060
something that looks like this we can

00:44:20,140 --> 00:44:23,950
basically just say access going to be

00:44:22,060 --> 00:44:26,200
denied based on some condition that we

00:44:23,950 --> 00:44:27,730
define so maybe our authentication

00:44:26,200 --> 00:44:28,839
service has a method called is

00:44:27,730 --> 00:44:30,430
authenticated

00:44:28,839 --> 00:44:31,989
returns true or false depending on

00:44:30,430 --> 00:44:34,960
whether users logged in or not

00:44:31,989 --> 00:44:37,119
and if they are not authenticated we're

00:44:34,960 --> 00:44:40,599
then we're gonna return false and say

00:44:37,119 --> 00:44:42,549
this user don't load this route now we

00:44:40,599 --> 00:44:44,229
could also take some action like we

00:44:42,549 --> 00:44:46,719
could redirect the user to a login page

00:44:44,229 --> 00:44:48,640
for example and then we're going to

00:44:46,719 --> 00:44:49,960
return true if access to the route

00:44:48,640 --> 00:44:54,880
should be granted and navigation should

00:44:49,960 --> 00:44:57,729
be allowed to proceed now we can also do

00:44:54,880 --> 00:44:59,799
guarded lazy loading and with this we

00:44:57,729 --> 00:45:01,719
would use the can load route guard and

00:44:59,799 --> 00:45:03,519
asynchronously load sections of our

00:45:01,719 --> 00:45:06,519
application only for users that are

00:45:03,519 --> 00:45:08,319
authorized now it's still true that you

00:45:06,519 --> 00:45:10,749
would never put sensitive data directly

00:45:08,319 --> 00:45:13,289
in your app bundles regardless it

00:45:10,749 --> 00:45:16,599
sensitive data just doesn't belong in

00:45:13,289 --> 00:45:19,299
application bundles that end up being

00:45:16,599 --> 00:45:21,130
downloaded in a single page app but with

00:45:19,299 --> 00:45:22,690
guarded lazy loading we do get a few

00:45:21,130 --> 00:45:26,380
other advantages like smaller bundle

00:45:22,690 --> 00:45:28,420
sizes and some added protection so if we

00:45:26,380 --> 00:45:30,369
come back to our app routing module when

00:45:28,420 --> 00:45:32,349
we're setting up our routes we are going

00:45:30,369 --> 00:45:34,569
to lazy load a routed module in this

00:45:32,349 --> 00:45:36,910
example I'm using like an admin module

00:45:34,569 --> 00:45:38,799
so this might be several pages that are

00:45:36,910 --> 00:45:41,430
should only be used and accessed by

00:45:38,799 --> 00:45:44,650
users with an admin level privilege and

00:45:41,430 --> 00:45:46,660
then we can add a can load route guard

00:45:44,650 --> 00:45:48,789
and in the in this case I'm using a roll

00:45:46,660 --> 00:45:50,979
guard so this is a guard that could

00:45:48,789 --> 00:45:53,979
potentially be used for different roles

00:45:50,979 --> 00:45:55,630
so I would be looking at the for the

00:45:53,979 --> 00:45:57,099
role to be looking for admins

00:45:55,630 --> 00:45:58,509
specifically in this case but I could

00:45:57,099 --> 00:46:00,940
have like an editor one I can have a

00:45:58,509 --> 00:46:03,039
user one so on and so forth and we can

00:46:00,940 --> 00:46:05,289
also add route data that informs the

00:46:03,039 --> 00:46:07,509
guard what's expected for example we say

00:46:05,289 --> 00:46:08,979
in order to access this page we're going

00:46:07,509 --> 00:46:12,069
to use this roll guard and we want this

00:46:08,979 --> 00:46:14,229
person to have a roll of admin in order

00:46:12,069 --> 00:46:16,150
to be allowed to proceed here and we can

00:46:14,229 --> 00:46:18,640
do this with other guard types or any

00:46:16,150 --> 00:46:20,680
route specific data it's just nice if we

00:46:18,640 --> 00:46:25,479
want to do something that repurposes a

00:46:20,680 --> 00:46:27,819
little bit so our author ole guard has a

00:46:25,479 --> 00:46:29,880
can load function in it and this returns

00:46:27,819 --> 00:46:32,829
an observable a promise or a boolean

00:46:29,880 --> 00:46:34,119
similar to the other case and our can

00:46:32,829 --> 00:46:37,390
load function might contain something

00:46:34,119 --> 00:46:39,249
that looks like this so let's say that

00:46:37,390 --> 00:46:41,109
we're going to want to return an is

00:46:39,249 --> 00:46:41,980
authenticated observable this observable

00:46:41,109 --> 00:46:43,450
is going to emit true

00:46:41,980 --> 00:46:46,119
if users logged in and it's going to

00:46:43,450 --> 00:46:49,150
emit false if they're not and then we

00:46:46,119 --> 00:46:52,930
can use the tap operator to execute a

00:46:49,150 --> 00:46:55,570
side effect so we can say if the user is

00:46:52,930 --> 00:46:58,390
not logged in then the can log function

00:46:55,570 --> 00:47:01,180
can is able to access segments which is

00:46:58,390 --> 00:47:03,430
a URL tree so this allows us to get the

00:47:01,180 --> 00:47:06,640
path of the guarded route even though

00:47:03,430 --> 00:47:08,410
it's not actually in the bundle and we

00:47:06,640 --> 00:47:10,750
can prompt the user to log in and then

00:47:08,410 --> 00:47:14,619
redirect back to the guarded lazy loaded

00:47:10,750 --> 00:47:17,560
route after they're logged in now if the

00:47:14,619 --> 00:47:19,540
user is logged in but they don't have

00:47:17,560 --> 00:47:21,849
the expected role they're not the admin

00:47:19,540 --> 00:47:26,530
then we can do something like send them

00:47:21,849 --> 00:47:29,170
to an unauthorized page so coming back

00:47:26,530 --> 00:47:31,359
to our list we learned about route

00:47:29,170 --> 00:47:33,010
guards and how we can use them and lazy

00:47:31,359 --> 00:47:35,290
loading to restrict access to certain

00:47:33,010 --> 00:47:37,510
routes and essentially at this point our

00:47:35,290 --> 00:47:41,619
angular authentication to-do list

00:47:37,510 --> 00:47:44,349
is completed so I hope that sort of in

00:47:41,619 --> 00:47:46,510
the last 47 minutes or so I was able to

00:47:44,349 --> 00:47:49,270
demystify a lot of the complications

00:47:46,510 --> 00:47:52,060
around the standards and share with you

00:47:49,270 --> 00:47:55,270
some basics of authentication on the web

00:47:52,060 --> 00:47:57,579
and there's a lot more to it than this

00:47:55,270 --> 00:47:59,470
this was sort of what you would call the

00:47:57,579 --> 00:48:01,540
the crash course version of it and I

00:47:59,470 --> 00:48:03,430
also talked about how angular provides

00:48:01,540 --> 00:48:06,700
things that let us work with

00:48:03,430 --> 00:48:09,250
authentication a little more easily now

00:48:06,700 --> 00:48:11,859
the slides from the talk are available

00:48:09,250 --> 00:48:13,990
at the bitly link and then also if you

00:48:11,859 --> 00:48:16,900
are interested in learning quite a bit

00:48:13,990 --> 00:48:19,390
more in depth about identity in general

00:48:16,900 --> 00:48:22,119
not just for browser-based applications

00:48:19,390 --> 00:48:26,470
but also for different for mobile apps

00:48:22,119 --> 00:48:28,060
for traditional web apps as well as just

00:48:26,470 --> 00:48:30,190
a lot more history about the standards

00:48:28,060 --> 00:48:32,650
and how they came about then you can

00:48:30,190 --> 00:48:35,530
check out this course it's a learn

00:48:32,650 --> 00:48:37,119
identity series of videos from principal

00:48:35,530 --> 00:48:38,290
architect at austero and it's

00:48:37,119 --> 00:48:40,060
essentially the same training that

00:48:38,290 --> 00:48:42,160
austero employees are given it's

00:48:40,060 --> 00:48:43,450
publicly available you don't even have

00:48:42,160 --> 00:48:45,160
to like give up your email address or

00:48:43,450 --> 00:48:46,060
anything it's just in the docs so if

00:48:45,160 --> 00:48:48,520
you're interested in learning more I

00:48:46,060 --> 00:48:53,410
highly recommend checking that out it's

00:48:48,520 --> 00:48:54,880
pretty easy to digest I am on Twitter so

00:48:53,410 --> 00:48:55,690
if you have any questions think of any

00:48:54,880 --> 00:48:57,310
questions later

00:48:55,690 --> 00:48:59,950
have feedback about that quick start or

00:48:57,310 --> 00:49:02,200
anything like that please chat with me

00:48:59,950 --> 00:49:05,170
on Twitter and I really appreciate your

00:49:02,200 --> 00:49:08,579
time today so thank you very much

00:49:05,170 --> 00:49:08,579

YouTube URL: https://www.youtube.com/watch?v=TXI6K5lQgok


