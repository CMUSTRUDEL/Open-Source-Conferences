Title: Angular Vienna, Reactive state of mind, February 2018
Publication date: 2018-02-09
Playlist: Angular Vienna
Description: 
	Talk by Miroslav Jonas: Miroslav gives background info on RX and helps you switch to reactive thinking. We will see later in the live coding session how complex things can be made simple using RX.

More about Angular Vienna: https://www.meetup.com/Angular-Vienna/
Captions: 
	00:00:00,030 --> 00:00:06,509
my name is Miroslav janosh I'm going to

00:00:02,520 --> 00:00:10,440
talk about reactive state of mind so I'm

00:00:06,509 --> 00:00:13,349
gonna try to help you go completely into

00:00:10,440 --> 00:00:16,440
the reactive world and understand all

00:00:13,349 --> 00:00:18,869
the aspects so first of all how many of

00:00:16,440 --> 00:00:20,670
you heard about reactive axe how many of

00:00:18,869 --> 00:00:25,260
you know wood okay that's pretty much

00:00:20,670 --> 00:00:27,060
everyone how many of you are using rx on

00:00:25,260 --> 00:00:31,050
daily basis during your working time

00:00:27,060 --> 00:00:33,480
okay again quite a lot of people okay

00:00:31,050 --> 00:00:36,030
let's try something harder how many of

00:00:33,480 --> 00:00:40,710
you are using more than five different

00:00:36,030 --> 00:00:44,910
operators on daily basis okay three four

00:00:40,710 --> 00:00:46,980
five hands okay let's go even harder how

00:00:44,910 --> 00:00:49,050
many of you can tell the difference

00:00:46,980 --> 00:00:51,719
between these operators I don't know if

00:00:49,050 --> 00:00:54,300
you can see it but it says fork/join

00:00:51,719 --> 00:00:58,680
compile a tests merge and with latest

00:00:54,300 --> 00:01:02,699
from without looking at animation okay

00:00:58,680 --> 00:01:04,500
and finally how many of you think they

00:01:02,699 --> 00:01:07,200
would be able to explain the whole

00:01:04,500 --> 00:01:12,119
reactive axe to someone non-technical or

00:01:07,200 --> 00:01:15,810
let's say eight-year-old kid difficult

00:01:12,119 --> 00:01:18,720
right okay so let's try to understand

00:01:15,810 --> 00:01:22,140
why is this difficult when I started

00:01:18,720 --> 00:01:24,689
working with angular 2 it was packed an

00:01:22,140 --> 00:01:26,939
alpha version it was driven completely

00:01:24,689 --> 00:01:28,650
on Eric's chest this was a completely

00:01:26,939 --> 00:01:31,710
new concept although I knew what

00:01:28,650 --> 00:01:36,600
reactive programming was Eric says the

00:01:31,710 --> 00:01:38,549
library was quite new to me and I did

00:01:36,600 --> 00:01:40,439
understand standard even driven

00:01:38,549 --> 00:01:43,530
development so we have something that

00:01:40,439 --> 00:01:47,820
some event producer and then you

00:01:43,530 --> 00:01:51,299
subscribe right but if you go deeper and

00:01:47,820 --> 00:01:53,509
you go to our X J's site you see the

00:01:51,299 --> 00:01:56,100
definition first of all definition was

00:01:53,509 --> 00:01:58,469
something like this it's an API for

00:01:56,100 --> 00:02:00,270
asynchronous programming with observable

00:01:58,469 --> 00:02:04,170
streams for most people this is like

00:02:00,270 --> 00:02:06,060
what so then if you go further you see

00:02:04,170 --> 00:02:08,220
something like this reactive axis

00:02:06,060 --> 00:02:10,410
library for composing a synchronous and

00:02:08,220 --> 00:02:12,700
even based programs by using observable

00:02:10,410 --> 00:02:14,830
sequences again

00:02:12,700 --> 00:02:19,180
of phrases that most people don't

00:02:14,830 --> 00:02:20,770
understand and finally our dear

00:02:19,180 --> 00:02:22,599
wikipedia says something like this

00:02:20,770 --> 00:02:24,700
reactive programming is a declarative

00:02:22,599 --> 00:02:26,790
programming paradigm concerned with data

00:02:24,700 --> 00:02:29,590
streams and the propagation of change

00:02:26,790 --> 00:02:32,470
although all of this definition say

00:02:29,590 --> 00:02:34,480
Qalat they don't really explain what the

00:02:32,470 --> 00:02:37,540
reactive is and and how the operators

00:02:34,480 --> 00:02:40,959
work and if you were unlucky enough to

00:02:37,540 --> 00:02:43,750
go to our xj site in the early days you

00:02:40,959 --> 00:02:47,500
would see some quite weird definitions

00:02:43,750 --> 00:02:49,060
of operators that I'm pretty sure even

00:02:47,500 --> 00:02:52,420
they don't understand what they wanted

00:02:49,060 --> 00:02:56,290
to say it was quite quite hard to

00:02:52,420 --> 00:02:58,390
comprehend what they are doing and there

00:02:56,290 --> 00:03:01,900
was this thing called marbles marbles

00:02:58,390 --> 00:03:04,750
were brilliant for easy operators like

00:03:01,900 --> 00:03:07,720
mat filter but when you try to apply

00:03:04,750 --> 00:03:09,190
marbles to something complex you

00:03:07,720 --> 00:03:10,870
suddenly get lost you don't know where

00:03:09,190 --> 00:03:14,950
these marbles are coming from how they

00:03:10,870 --> 00:03:18,430
are being combined so one of the things

00:03:14,950 --> 00:03:20,769
that's now written on the reactive ax

00:03:18,430 --> 00:03:22,750
website is this it's a combination of

00:03:20,769 --> 00:03:25,060
best ideas from observer pattern

00:03:22,750 --> 00:03:28,890
iterator pattern and functional

00:03:25,060 --> 00:03:33,190
programming now although this is not

00:03:28,890 --> 00:03:35,280
clearer than the previous definitions it

00:03:33,190 --> 00:03:38,140
gives us something to work with

00:03:35,280 --> 00:03:39,940
so since I'm a backward man I'm gonna

00:03:38,140 --> 00:03:43,989
start backwards with functional

00:03:39,940 --> 00:03:46,359
programming this doesn't mean that the

00:03:43,989 --> 00:03:48,730
library or the stuff you are using is

00:03:46,359 --> 00:03:49,600
functioning so functional is something

00:03:48,730 --> 00:03:52,510
completely different

00:03:49,600 --> 00:03:55,600
me as you are aware functional

00:03:52,510 --> 00:03:58,569
programming is core parts of the

00:03:55,600 --> 00:04:01,319
JavaScript and there are different

00:03:58,569 --> 00:04:03,519
definitions some of them say that

00:04:01,319 --> 00:04:05,739
functional programming is the

00:04:03,519 --> 00:04:10,239
programming where you can use function

00:04:05,739 --> 00:04:11,970
as a first-class member in plain English

00:04:10,239 --> 00:04:14,769
that means that function can be

00:04:11,970 --> 00:04:17,320
parameter of another function you can

00:04:14,769 --> 00:04:21,410
also combine functions to get some some

00:04:17,320 --> 00:04:23,420
new function or some new object the more

00:04:21,410 --> 00:04:26,090
important part for the functional

00:04:23,420 --> 00:04:28,520
programming is that functional

00:04:26,090 --> 00:04:30,760
programming tells you that each function

00:04:28,520 --> 00:04:34,220
has to be pure function again in the

00:04:30,760 --> 00:04:36,440
plain English that means that function

00:04:34,220 --> 00:04:40,010
should not have side-effects there

00:04:36,440 --> 00:04:42,800
should be one or zero or multiple inputs

00:04:40,010 --> 00:04:45,080
and there should be there can be zero or

00:04:42,800 --> 00:04:47,930
multiple outputs but the important thing

00:04:45,080 --> 00:04:51,680
is that whatever comes in should not be

00:04:47,930 --> 00:04:54,110
changed inside a function so the the

00:04:51,680 --> 00:04:56,090
data you pass in the function have to

00:04:54,110 --> 00:04:58,670
remain the same as they are and you can

00:04:56,090 --> 00:05:00,230
pass something new as a result of

00:04:58,670 --> 00:05:02,390
calculation in your function but

00:05:00,230 --> 00:05:05,380
function should not do some side effect

00:05:02,390 --> 00:05:09,980
like if you think about our standard

00:05:05,380 --> 00:05:12,170
login function the way we used to do it

00:05:09,980 --> 00:05:15,500
is that we pass in user name and

00:05:12,170 --> 00:05:16,910
password then we do some magic called

00:05:15,500 --> 00:05:19,370
backend check if the user is

00:05:16,910 --> 00:05:21,710
authenticated or not and then we

00:05:19,370 --> 00:05:24,260
redirect this V Direction is actually

00:05:21,710 --> 00:05:26,780
side-effect because your function is

00:05:24,260 --> 00:05:28,640
checking for your credentials it should

00:05:26,780 --> 00:05:32,300
not redirect you should use different

00:05:28,640 --> 00:05:35,180
flow and it's part of the way we are

00:05:32,300 --> 00:05:37,700
used to program and how we are taught to

00:05:35,180 --> 00:05:39,740
program so since this was allowed for us

00:05:37,700 --> 00:05:42,530
of course we were misusing this in

00:05:39,740 --> 00:05:44,900
different ways but once you switch to

00:05:42,530 --> 00:05:46,760
fully functional programming it's quite

00:05:44,900 --> 00:05:48,860
easier to comprehend because then these

00:05:46,760 --> 00:05:52,220
side-effects don't exist anymore and

00:05:48,860 --> 00:05:55,130
it's easy to follow the whole workflow

00:05:52,220 --> 00:05:57,410
of your data with side-effects you never

00:05:55,130 --> 00:05:58,880
know what happens there can be a bunch

00:05:57,410 --> 00:06:00,800
of different situations you cannot

00:05:58,880 --> 00:06:02,750
follow but with functional you have a

00:06:00,800 --> 00:06:07,370
clear path so something comes in

00:06:02,750 --> 00:06:10,550
something comes out it's simple so the

00:06:07,370 --> 00:06:13,700
second two patterns are iterator and

00:06:10,550 --> 00:06:18,020
observable most of you I guess heard

00:06:13,700 --> 00:06:20,630
about Gang of Four this is referring to

00:06:18,020 --> 00:06:23,120
for altars that created the original 23

00:06:20,630 --> 00:06:25,540
design patterns and iterator and

00:06:23,120 --> 00:06:28,220
observable were two of these patterns

00:06:25,540 --> 00:06:30,979
they weren't as used in the beginning

00:06:28,220 --> 00:06:32,680
but now with reactive programming they

00:06:30,979 --> 00:06:36,039
are becoming more and more popular

00:06:32,680 --> 00:06:39,639
more and more important so first

00:06:36,039 --> 00:06:41,650
iterator pattern now this would maybe

00:06:39,639 --> 00:06:45,280
have more sense if there was actually

00:06:41,650 --> 00:06:47,139
pizza today but unfortunately you would

00:06:45,280 --> 00:06:50,710
just have to assume that there is pizza

00:06:47,139 --> 00:06:53,590
today and I'm gonna try to explain you

00:06:50,710 --> 00:06:57,940
iterator pattern with a simple pizza

00:06:53,590 --> 00:07:01,210
example so you can think of an iterator

00:06:57,940 --> 00:07:04,570
pattern as a pull mechanism so let's say

00:07:01,210 --> 00:07:07,389
our we have a pizza and this pizza is

00:07:04,570 --> 00:07:10,990
our iterator the iterator pattern

00:07:07,389 --> 00:07:13,330
explains that you have a collection of

00:07:10,990 --> 00:07:17,410
some information let's call it slices

00:07:13,330 --> 00:07:20,949
for pizza and you can take or you can

00:07:17,410 --> 00:07:23,380
enumerate through these items until we

00:07:20,949 --> 00:07:25,470
reach the end so in pizza world this

00:07:23,380 --> 00:07:29,050
would mean you can take slices of pizza

00:07:25,470 --> 00:07:31,720
until there are no more slices left so

00:07:29,050 --> 00:07:33,610
pizza provides two things it can give

00:07:31,720 --> 00:07:36,370
you a slice and it could tell you hey I

00:07:33,610 --> 00:07:38,169
don't have any slices anymore so you can

00:07:36,370 --> 00:07:40,539
come and take one slice and then take

00:07:38,169 --> 00:07:43,150
next slice and tank next slice and at

00:07:40,539 --> 00:07:48,039
some point the pizza will say well

00:07:43,150 --> 00:07:50,560
that's it from me clearly enough okay

00:07:48,039 --> 00:07:52,210
let's go to observer pattern observer

00:07:50,560 --> 00:07:55,810
pattern is your gramma

00:07:52,210 --> 00:07:59,139
so let's see how we can explain observer

00:07:55,810 --> 00:08:03,330
with a grammar so in contrast to pizza

00:07:59,139 --> 00:08:08,979
and the pool gramma is working more on a

00:08:03,330 --> 00:08:11,590
push mechanism so what happens you go to

00:08:08,979 --> 00:08:14,590
your grandma and you say hey grandma I'm

00:08:11,590 --> 00:08:17,409
hungry and grandma starts creating

00:08:14,590 --> 00:08:19,840
pancakes and you sit in the table and

00:08:17,409 --> 00:08:21,759
the first pancake arrives and then the

00:08:19,840 --> 00:08:24,190
second you don't have to ask for

00:08:21,759 --> 00:08:26,370
pancakes they just keep arriving and

00:08:24,190 --> 00:08:30,690
also

00:08:26,370 --> 00:08:33,220
on on top of it you can do some

00:08:30,690 --> 00:08:35,080
operators on top of the pancakes so

00:08:33,220 --> 00:08:38,470
let's assume the substance from which

00:08:35,080 --> 00:08:42,400
the pickings are done is one type of

00:08:38,470 --> 00:08:45,850
observable and then you have the heat as

00:08:42,400 --> 00:08:47,830
a second observable and then you can

00:08:45,850 --> 00:08:51,460
combine the pen with the substance in a

00:08:47,830 --> 00:08:54,070
heat to get a pancake and then normally

00:08:51,460 --> 00:08:56,530
grandma doesn't make one pancake at a

00:08:54,070 --> 00:08:58,060
time and deliver it one at a time she

00:08:56,530 --> 00:08:59,830
creates some sort of buffer of Pam

00:08:58,060 --> 00:09:02,440
pancakes and then when she has ten

00:08:59,830 --> 00:09:06,720
pickings she brings it to you and then

00:09:02,440 --> 00:09:10,390
you can use your map function to to or

00:09:06,720 --> 00:09:12,970
scan to enhance the pancake with jam and

00:09:10,390 --> 00:09:17,440
then map to wrap it in the bank cake

00:09:12,970 --> 00:09:19,480
underneath it so you can explain pretty

00:09:17,440 --> 00:09:21,910
much the whole process of making and

00:09:19,480 --> 00:09:24,670
eating pancakes through the observable

00:09:21,910 --> 00:09:27,040
the important thing is that it works

00:09:24,670 --> 00:09:28,810
with a push so you just have to initiate

00:09:27,040 --> 00:09:30,610
the stream or tell grandma that you are

00:09:28,810 --> 00:09:35,200
hungry and she starts making the

00:09:30,610 --> 00:09:37,330
pancakes now there are two types of

00:09:35,200 --> 00:09:39,910
observables which you might have heard

00:09:37,330 --> 00:09:42,940
one of them are cold and the other one

00:09:39,910 --> 00:09:44,680
are called hot observables since I like

00:09:42,940 --> 00:09:49,720
sushi what I'm going to try to explain

00:09:44,680 --> 00:09:51,730
this on a sushi principle so let's say

00:09:49,720 --> 00:09:53,620
you want to eat sushi so in Vienna

00:09:51,730 --> 00:09:55,360
pretty much there are two ways how you

00:09:53,620 --> 00:09:57,160
can do it you can go to a standard

00:09:55,360 --> 00:10:00,400
restaurant you can sit there

00:09:57,160 --> 00:10:02,590
you order a sushi then there's some a

00:10:00,400 --> 00:10:06,190
sink weight time and after some time

00:10:02,590 --> 00:10:08,860
your sushi arrives now the difference

00:10:06,190 --> 00:10:11,460
between observables and promises which

00:10:08,860 --> 00:10:14,620
is one of the core differences is that

00:10:11,460 --> 00:10:16,840
observables are cancelable so with

00:10:14,620 --> 00:10:18,940
promise if your sushi was a promise that

00:10:16,840 --> 00:10:20,500
would mean that once you order you are

00:10:18,940 --> 00:10:22,240
chained to the table and you cannot

00:10:20,500 --> 00:10:25,330
leave before you eat it and you pay for

00:10:22,240 --> 00:10:28,000
it but with observable you can order

00:10:25,330 --> 00:10:29,320
sushi and you can change your mind and

00:10:28,000 --> 00:10:31,840
say to it or hey actually I want

00:10:29,320 --> 00:10:34,810
something else or you can just bail just

00:10:31,840 --> 00:10:39,460
leave and who cares

00:10:34,810 --> 00:10:41,800
the second kind of way how you can

00:10:39,460 --> 00:10:44,350
or your sushi is go to running sushi

00:10:41,800 --> 00:10:47,980
does is anyone familiar with running

00:10:44,350 --> 00:10:51,310
sushi okay most of you so for those that

00:10:47,980 --> 00:10:53,800
are not it's the place where you have

00:10:51,310 --> 00:10:56,649
sushi as all-you-can-eat so you just sit

00:10:53,800 --> 00:10:59,649
and then sushi is circulating around you

00:10:56,649 --> 00:11:01,630
and you just take whatever you want

00:10:59,649 --> 00:11:03,399
so you can sit there as long as you want

00:11:01,630 --> 00:11:07,360
then you can take as much as you want

00:11:03,399 --> 00:11:09,850
sushi so for this sushi you don't

00:11:07,360 --> 00:11:11,800
trigger the event stream it just keeps

00:11:09,850 --> 00:11:13,540
going whether you are in the restaurant

00:11:11,800 --> 00:11:15,580
or not the sushi is there and it's going

00:11:13,540 --> 00:11:17,950
in the round whether you take it or not

00:11:15,580 --> 00:11:20,649
it's up to you but so she keeps running

00:11:17,950 --> 00:11:25,029
around this is how the hot observables

00:11:20,649 --> 00:11:27,520
work so in IT world this would be for

00:11:25,029 --> 00:11:29,709
example mouse clicks or mouse moves or

00:11:27,520 --> 00:11:32,649
keyboard clicks or whatever type of

00:11:29,709 --> 00:11:34,839
stream that keeps going or like

00:11:32,649 --> 00:11:37,330
listening to the radio so you can switch

00:11:34,839 --> 00:11:39,700
on your your set and listen to the radio

00:11:37,330 --> 00:11:41,649
but if you don't the radio will still be

00:11:39,700 --> 00:11:45,000
there the broadcast is still there it's

00:11:41,649 --> 00:11:49,660
not just for you it's there for everyone

00:11:45,000 --> 00:11:55,510
so now I'm going to show you how to

00:11:49,660 --> 00:11:58,779
build a relatively complex game in a

00:11:55,510 --> 00:12:05,800
iterative world but in a relative simple

00:11:58,779 --> 00:12:09,490
way with RX so as you can see is the

00:12:05,800 --> 00:12:13,180
game of tetris I guess most of you are

00:12:09,490 --> 00:12:15,370
familiar with this game so it's an old

00:12:13,180 --> 00:12:18,040
Russian game that used to be quite

00:12:15,370 --> 00:12:19,720
popular in 90s because everyone had

00:12:18,040 --> 00:12:22,510
these small gadgets where they were

00:12:19,720 --> 00:12:27,579
playing Tetris sweet but it was one of

00:12:22,510 --> 00:12:33,610
the first oral popular games created on

00:12:27,579 --> 00:12:35,980
computers so I did some work up front I

00:12:33,610 --> 00:12:41,079
was cheating I have to promise

00:12:35,980 --> 00:12:43,720
so I created something like shapes which

00:12:41,079 --> 00:12:46,540
is the definition now if you can see it

00:12:43,720 --> 00:12:48,500
maybe I can reduce it as well still

00:12:46,540 --> 00:12:50,910
visible

00:12:48,500 --> 00:12:53,880
so we have like definition for a point

00:12:50,910 --> 00:12:55,860
definition for shapes of shape has two

00:12:53,880 --> 00:12:59,580
dimension it's some sort of matrix it

00:12:55,860 --> 00:13:03,029
has a block we have a random index

00:12:59,580 --> 00:13:07,589
generator we have our predefined shapes

00:13:03,029 --> 00:13:10,589
etc also there are some constants which

00:13:07,589 --> 00:13:13,320
we're going to use make the colors the

00:13:10,589 --> 00:13:15,600
keys we want to deal with so we are

00:13:13,320 --> 00:13:18,540
interested only with arrow left arrow

00:13:15,600 --> 00:13:21,690
right down key and space which will be

00:13:18,540 --> 00:13:25,920
our rotation we have some definitions

00:13:21,690 --> 00:13:30,000
here our game speed and that's pretty

00:13:25,920 --> 00:13:34,320
much it also they are of course the core

00:13:30,000 --> 00:13:37,440
part which is the different methods that

00:13:34,320 --> 00:13:39,510
are modifying the scene or checking if

00:13:37,440 --> 00:13:43,290
the game is over generating the blocks

00:13:39,510 --> 00:13:49,560
moving rotating etc but we're going to

00:13:43,290 --> 00:13:51,089
go back to our game so at the moment as

00:13:49,560 --> 00:13:53,640
you can see there is pretty much not

00:13:51,089 --> 00:13:57,750
even in the game we have just reference

00:13:53,640 --> 00:14:00,120
to canvas it runs this method which

00:13:57,750 --> 00:14:04,709
again doesn't have anything so let's try

00:14:00,120 --> 00:14:07,620
to analyze what one tetris might need so

00:14:04,709 --> 00:14:10,890
first of all I said that we defined some

00:14:07,620 --> 00:14:15,810
keys so let's see what we can do with

00:14:10,890 --> 00:14:18,240
those keys so we're going to define one

00:14:15,810 --> 00:14:27,180
observable and we're going to call it

00:14:18,240 --> 00:14:32,510
from event now let's take it here so we

00:14:27,180 --> 00:14:40,740
say document and then we're going to say

00:14:32,510 --> 00:14:43,010
key down and let's just call subscribe

00:14:40,740 --> 00:14:43,010
on it

00:14:51,870 --> 00:15:03,600
okay and now when we run this let's just

00:14:57,990 --> 00:15:05,610
bring this console walk and now let's

00:15:03,600 --> 00:15:11,370
try to click okay so we have our

00:15:05,610 --> 00:15:14,010
keyboard events okay but we are not

00:15:11,370 --> 00:15:16,770
interested in this whole object of

00:15:14,010 --> 00:15:20,250
keyboard you and right we are probably

00:15:16,770 --> 00:15:25,320
interested just in a code so what we can

00:15:20,250 --> 00:15:27,750
say you say that pipe now for those who

00:15:25,320 --> 00:15:32,310
are unfamiliar with pipe I'm going to

00:15:27,750 --> 00:15:35,820
come back to that later but for the time

00:15:32,310 --> 00:15:38,760
being let's just say that the all the

00:15:35,820 --> 00:15:41,100
operators with a pipe bubble or a letter

00:15:38,760 --> 00:15:43,890
ball operators are now organized under

00:15:41,100 --> 00:15:45,720
pipe so it's easier to kind of

00:15:43,890 --> 00:15:48,270
comprehend what's going on so you have

00:15:45,720 --> 00:15:51,930
clear observable you have a subscription

00:15:48,270 --> 00:15:55,820
and you have your methods in between so

00:15:51,930 --> 00:16:00,810
let's say we want to take event and

00:15:55,820 --> 00:16:03,920
we're interested in event that code now

00:16:00,810 --> 00:16:03,920
let's see what happens now

00:16:07,970 --> 00:16:18,510
okay there now as I mentioned we have

00:16:15,180 --> 00:16:20,190
four keys that we are interested in so

00:16:18,510 --> 00:16:27,380
we don't really want to listen to all of

00:16:20,190 --> 00:16:27,380
them and we map them to this object

00:16:38,300 --> 00:16:44,990
now if I start clicking you see that

00:16:41,660 --> 00:16:47,270
sometimes it comes as undefined that

00:16:44,990 --> 00:16:49,720
means that some of the events that we

00:16:47,270 --> 00:16:52,820
are triggering are not being mapped so

00:16:49,720 --> 00:16:57,890
we want to get rid of this right so

00:16:52,820 --> 00:17:00,500
we're going to go filter and again

00:16:57,890 --> 00:17:06,050
filter we want from operators and we're

00:17:00,500 --> 00:17:14,240
gonna say he returned me just the keys

00:17:06,050 --> 00:17:16,310
that have value okay now you can't

00:17:14,240 --> 00:17:18,320
really see but I'm like randomly typing

00:17:16,310 --> 00:17:21,610
on a keyboard and nothing happens unless

00:17:18,320 --> 00:17:26,450
I hit one of the keys very interested in

00:17:21,610 --> 00:17:32,030
so what do we have next

00:17:26,450 --> 00:17:34,130
as a game we want game to have some sort

00:17:32,030 --> 00:17:37,280
of natural progression like even if you

00:17:34,130 --> 00:17:42,230
don't type on your keyboard these blocks

00:17:37,280 --> 00:17:45,170
will still be moving and we have to make

00:17:42,230 --> 00:17:53,540
them somehow move right so first we want

00:17:45,170 --> 00:17:56,300
to create interval so this will be our

00:17:53,540 --> 00:18:00,050
main mechanism and we want to say that

00:17:56,300 --> 00:18:05,210
it will run on game speed which was 500

00:18:00,050 --> 00:18:09,080
millisecond and again we want to treat

00:18:05,210 --> 00:18:13,000
subscribe so we have some number and we

00:18:09,080 --> 00:18:13,000
want to console.log it

00:18:19,340 --> 00:18:24,870
okay now you can see it's generating

00:18:22,019 --> 00:18:27,630
something but it's not the numbers we

00:18:24,870 --> 00:18:30,059
want right we want key down event

00:18:27,630 --> 00:18:33,659
because what game should eventually do

00:18:30,059 --> 00:18:44,269
it should move this block one one line

00:18:33,659 --> 00:18:48,659
at a time so we can again use pipe first

00:18:44,269 --> 00:18:54,120
and then we're gonna map we don't care

00:18:48,659 --> 00:18:59,940
about the number so we return just keys

00:18:54,120 --> 00:19:02,159
dot arrow down so now if I run this you

00:18:59,940 --> 00:19:06,480
can see that the arrow down function has

00:19:02,159 --> 00:19:09,600
been triggered now if you look at these

00:19:06,480 --> 00:19:13,259
two subscribes there are pretty much the

00:19:09,600 --> 00:19:16,710
same right so let's create something

00:19:13,259 --> 00:19:23,929
that would combine them together so

00:19:16,710 --> 00:19:26,340
we're going to create one action subject

00:19:23,929 --> 00:19:30,629
now for those of you that don't know

00:19:26,340 --> 00:19:33,720
what subject is subject is a object in

00:19:30,629 --> 00:19:36,480
observable Road that's both observer and

00:19:33,720 --> 00:19:38,490
observable so you can subscribe to it as

00:19:36,480 --> 00:19:42,929
to any observable but it can also

00:19:38,490 --> 00:19:50,250
subscribe to something so let's pass

00:19:42,929 --> 00:19:52,620
these two actions so now instead of go

00:19:50,250 --> 00:19:58,289
sending it to console.log we're gonna

00:19:52,620 --> 00:20:00,919
send it to actions and then we can do

00:19:58,289 --> 00:20:00,919
something like this

00:20:05,759 --> 00:20:08,969
random L

00:20:13,720 --> 00:20:22,520
okay so when you look at the cons of

00:20:17,540 --> 00:20:27,560
luck it's still the same right so it's

00:20:22,520 --> 00:20:32,090
still reacting okay now what we need to

00:20:27,560 --> 00:20:35,390
do next is on every key we need to

00:20:32,090 --> 00:20:39,950
generate our scene our scene will

00:20:35,390 --> 00:20:43,090
consist of the board and also the object

00:20:39,950 --> 00:20:46,960
I can hide this now

00:20:43,090 --> 00:20:53,230
so let's write something like this

00:20:46,960 --> 00:20:56,470
actions and then we're gonna write pipe

00:20:53,230 --> 00:21:00,710
now what we want to do is we want to

00:20:56,470 --> 00:21:03,890
bring the scan function now scan

00:21:00,710 --> 00:21:07,520
function is similar to the reducer to

00:21:03,890 --> 00:21:10,670
reduce in array with the difference that

00:21:07,520 --> 00:21:14,300
standard reduce only creates a response

00:21:10,670 --> 00:21:16,850
at the end so let's say you have a array

00:21:14,300 --> 00:21:19,670
of numbers so if you create a function

00:21:16,850 --> 00:21:22,040
that sums it up the reduce on this array

00:21:19,670 --> 00:21:24,800
will just give you the final number the

00:21:22,040 --> 00:21:28,100
final result now scan does this but it

00:21:24,800 --> 00:21:31,520
also sends the current sum in every step

00:21:28,100 --> 00:21:35,930
so if you have numbers from 1 to 5 it

00:21:31,520 --> 00:21:42,320
will send 5 10 3 then 6 etc until it

00:21:35,930 --> 00:21:44,870
reaches the end so on every action we're

00:21:42,320 --> 00:21:47,690
gonna call the method called modify

00:21:44,870 --> 00:21:51,400
scene which I'm going to show in a

00:21:47,690 --> 00:21:54,260
second and as our first step or as our

00:21:51,400 --> 00:22:00,140
initial step we're gonna call generate

00:21:54,260 --> 00:22:02,390
scene now if I go here you can see the

00:22:00,140 --> 00:22:04,820
generate scene doesn't do much it just

00:22:02,390 --> 00:22:08,660
takes port shape and generates the block

00:22:04,820 --> 00:22:11,690
and generate block is just taking a

00:22:08,660 --> 00:22:16,210
random shape setting a random color and

00:22:11,690 --> 00:22:16,210
setting the initial starting point so

00:22:17,530 --> 00:22:23,930
yeah one more thing so this is the

00:22:20,990 --> 00:22:27,350
modify scene it reacts on arrow down for

00:22:23,930 --> 00:22:30,860
example and it tries to move it if there

00:22:27,350 --> 00:22:32,690
was a mood and it if the move cannot be

00:22:30,860 --> 00:22:36,080
done any more than it adds the block to

00:22:32,690 --> 00:22:38,510
the board the detects if there are some

00:22:36,080 --> 00:22:41,150
row that is completely full that you can

00:22:38,510 --> 00:22:43,910
remove it again on arrow left it just

00:22:41,150 --> 00:22:50,120
moving left or moving right and on space

00:22:43,910 --> 00:22:59,230
it's rotating so not much to it now this

00:22:50,120 --> 00:23:06,140
is this action will will now return the

00:22:59,230 --> 00:23:10,540
following type will return the following

00:23:06,140 --> 00:23:10,540
result so let's see what we have here

00:23:19,660 --> 00:23:24,040
okay so we're getting some object and

00:23:22,180 --> 00:23:28,450
you see there's a board and there's a

00:23:24,040 --> 00:23:31,620
block inside so instead of returning

00:23:28,450 --> 00:23:37,060
just this object let's try to render it

00:23:31,620 --> 00:23:46,200
so we can call something like this you

00:23:37,060 --> 00:23:46,200
can say that next sorry

00:23:46,260 --> 00:24:02,010
next we have our scene and we're gonna

00:23:53,020 --> 00:24:07,590
do render scene bypassing the context

00:24:02,010 --> 00:24:16,090
and scene let's see what this brings us

00:24:07,590 --> 00:24:24,340
okay nice right now bear with me this we

00:24:16,090 --> 00:24:31,810
are not done yet so okay now if I would

00:24:24,340 --> 00:24:34,780
just pull this down quickly it's not as

00:24:31,810 --> 00:24:37,480
fast as this could see nothing happens

00:24:34,780 --> 00:24:43,620
they just keep falling so we have to

00:24:37,480 --> 00:24:43,620
solve this right okay let's call this

00:24:43,950 --> 00:24:52,740
our scene and get rid of this

00:24:58,690 --> 00:25:06,650
okay so we don't want to run this

00:25:02,540 --> 00:25:10,880
endlessly right ideally we would like

00:25:06,650 --> 00:25:18,740
this to stop at some point so we're

00:25:10,880 --> 00:25:35,210
going to again use our pipe and let's

00:25:18,740 --> 00:25:41,600
say take while seen so this method just

00:25:35,210 --> 00:25:50,030
checks if our game is over now if we

00:25:41,600 --> 00:25:52,490
just bring them down quickly again this

00:25:50,030 --> 00:25:54,620
this is not showing anything so we're

00:25:52,490 --> 00:25:59,060
doing something wrong right so let's see

00:25:54,620 --> 00:26:01,670
what we might be doing wrong when we are

00:25:59,060 --> 00:26:03,220
running the SUBSCRIBE we are rendering

00:26:01,670 --> 00:26:07,460
the scene on next

00:26:03,220 --> 00:26:09,380
but although our observable has ended

00:26:07,460 --> 00:26:11,150
because the take while happened

00:26:09,380 --> 00:26:16,480
we don't really see it right so let's

00:26:11,150 --> 00:26:25,280
check if we can render it so on complete

00:26:16,480 --> 00:26:29,240
we're gonna say render game over and

00:26:25,280 --> 00:26:32,540
we're passing just context let's see if

00:26:29,240 --> 00:26:35,320
this change is something so again

00:26:32,540 --> 00:26:35,320
quickly down

00:26:36,990 --> 00:26:47,970
oh there it is now I don't know if you

00:26:44,940 --> 00:26:49,710
can see it but there's some jumping

00:26:47,970 --> 00:26:53,159
animations happening there whenever I'm

00:26:49,710 --> 00:26:55,830
or things so it's not as fluent as we

00:26:53,159 --> 00:26:57,280
would like to be so let's see what we

00:26:55,830 --> 00:27:00,549
can do

00:26:57,280 --> 00:27:00,549
[Music]

00:27:03,440 --> 00:27:18,110
now so sorry so you're gonna just leave

00:27:14,990 --> 00:27:20,510
it as it is one thing that we want to do

00:27:18,110 --> 00:27:24,320
we don't want to render the scene every

00:27:20,510 --> 00:27:26,150
time we want to render a scene say 60

00:27:24,320 --> 00:27:31,910
frames per second so we're going to

00:27:26,150 --> 00:27:39,800
create one interval and we're gonna pass

00:27:31,910 --> 00:27:41,660
it FPS that's my constant 60 frames per

00:27:39,800 --> 00:27:42,800
second so that's just thousand divided

00:27:41,660 --> 00:27:45,940
by fps

00:27:42,800 --> 00:27:49,690
and on top of it what we want to do is

00:27:45,940 --> 00:27:52,190
we want to reserve our animation frame

00:27:49,690 --> 00:27:55,300
so we're going to use animation frame

00:27:52,190 --> 00:27:58,160
for our X what this does is pretty much

00:27:55,300 --> 00:28:00,680
make sure that you have your animation

00:27:58,160 --> 00:28:05,630
frame request it whenever you want to

00:28:00,680 --> 00:28:06,800
render your CPU is free to do it so

00:28:05,630 --> 00:28:07,250
there's nothing else running in the

00:28:06,800 --> 00:28:10,910
background

00:28:07,250 --> 00:28:15,920
now the interval as we know returns just

00:28:10,910 --> 00:28:19,460
a number so we need to map this to our

00:28:15,920 --> 00:28:29,570
scene so we can use something like with

00:28:19,460 --> 00:28:33,290
latest from and now we have our scene

00:28:29,570 --> 00:28:35,330
observable and we have our method so the

00:28:33,290 --> 00:28:36,950
first parameter is a number from

00:28:35,330 --> 00:28:43,250
interval we don't really care about it

00:28:36,950 --> 00:28:46,940
and the second is scene and we're going

00:28:43,250 --> 00:28:49,490
to return just seen so what this does

00:28:46,940 --> 00:28:52,210
this every time when the interval fires

00:28:49,490 --> 00:28:57,440
which is hopefully 60 times per second

00:28:52,210 --> 00:29:05,690
it will take the latest value from our

00:28:57,440 --> 00:29:08,440
scene and it will send this instead and

00:29:05,690 --> 00:29:08,440
again then

00:29:09,490 --> 00:29:14,440
okay it's better and then we can

00:29:12,700 --> 00:29:17,409
continue working with scenes so that's

00:29:14,440 --> 00:29:20,230
pretty much we switched from our our

00:29:17,409 --> 00:29:23,320
integer or our number to the current

00:29:20,230 --> 00:29:30,429
scene we're checking if scene is not

00:29:23,320 --> 00:29:37,360
game over we subscribe and render so see

00:29:30,429 --> 00:29:43,779
now by the way you can rotate them of

00:29:37,360 --> 00:29:50,500
course let's see if we can get rid of

00:29:43,779 --> 00:29:54,149
this line okay there is one more thing

00:29:50,500 --> 00:29:56,830
which we shouldn't forget and that's

00:29:54,149 --> 00:29:59,860
getting rid of the observables once we

00:29:56,830 --> 00:30:01,929
are done so as you know observables are

00:29:59,860 --> 00:30:03,929
just the event streams and once you

00:30:01,929 --> 00:30:06,700
start listening to these event streams

00:30:03,929 --> 00:30:09,340
your listeners remainder so what we want

00:30:06,700 --> 00:30:11,049
to do we want to make sure that we get

00:30:09,340 --> 00:30:13,539
rid of this even streams when the

00:30:11,049 --> 00:30:17,830
application is done so some of them like

00:30:13,539 --> 00:30:20,830
this scene they don't really happen on

00:30:17,830 --> 00:30:23,110
their own but stuff like interval it's

00:30:20,830 --> 00:30:27,549
pretty much generating on its own

00:30:23,110 --> 00:30:29,529
keydown event as well interval so what

00:30:27,549 --> 00:30:36,340
are we going to do here is we're going

00:30:29,529 --> 00:30:39,720
to create one subject which we're going

00:30:36,340 --> 00:30:39,720
to call this Troy

00:30:45,330 --> 00:30:52,480
and we're gonna make sure that on

00:30:50,440 --> 00:30:55,570
destroy maybe you've seen this so this

00:30:52,480 --> 00:31:00,580
is pretty good practice we're gonna call

00:30:55,570 --> 00:31:05,019
next which will fire value and then we

00:31:00,580 --> 00:31:07,179
can call this destroy dot complete

00:31:05,019 --> 00:31:09,880
because we don't need it anymore now

00:31:07,179 --> 00:31:14,440
what do we want to do is we want to make

00:31:09,880 --> 00:31:18,600
sure that all of these are done so what

00:31:14,440 --> 00:31:27,820
we can do is we can say take until and

00:31:18,600 --> 00:31:31,600
then pass our destroy and we can do this

00:31:27,820 --> 00:31:35,559
for intro as well this is really good

00:31:31,600 --> 00:31:39,940
practice because then you have it in one

00:31:35,559 --> 00:31:41,710
central place and you know that ng

00:31:39,940 --> 00:31:43,210
ondestroy will be called every time you

00:31:41,710 --> 00:31:46,450
close your component or destroy

00:31:43,210 --> 00:31:48,639
component and on the other hand this

00:31:46,450 --> 00:31:50,909
destroy will make sure that everything

00:31:48,639 --> 00:32:00,330
gets destroyed

00:31:50,909 --> 00:32:00,330
so here again take until this dot

00:32:04,030 --> 00:32:12,070
so now when you look at this couple of

00:32:09,340 --> 00:32:16,090
lines of code this is pretty much the

00:32:12,070 --> 00:32:17,950
whole game the whole application there

00:32:16,090 --> 00:32:20,920
are of course these helper methods that

00:32:17,950 --> 00:32:24,520
calculate everything but the domain flow

00:32:20,920 --> 00:32:26,680
is explained in these few lines now just

00:32:24,520 --> 00:32:29,740
try to imagine how you would solve this

00:32:26,680 --> 00:32:33,400
without observables so for key event you

00:32:29,740 --> 00:32:35,890
will have some add that add

00:32:33,400 --> 00:32:37,690
eventlistener then you will have to make

00:32:35,890 --> 00:32:40,380
sure that you know at which point you

00:32:37,690 --> 00:32:43,870
have to detach from this event listener

00:32:40,380 --> 00:32:46,380
with intervals again you would have to

00:32:43,870 --> 00:32:48,820
make sure that the interval is not

00:32:46,380 --> 00:32:51,100
running and you have to combine in

00:32:48,820 --> 00:32:54,070
combination of this would be horrible

00:32:51,100 --> 00:32:56,830
you will have to keep some state and yet

00:32:54,070 --> 00:33:00,280
this creating this hole in iterative

00:32:56,830 --> 00:33:02,320
world would be just huge madness and

00:33:00,280 --> 00:33:04,960
most likely you would miss something you

00:33:02,320 --> 00:33:07,930
would get some memory leaks with Oryx

00:33:04,960 --> 00:33:10,710
the taken till make sure that there are

00:33:07,930 --> 00:33:13,390
no memory leaks so once you're done

00:33:10,710 --> 00:33:17,610
everything gets cleaned up also the

00:33:13,390 --> 00:33:21,460
important part is that Rx is by default

00:33:17,610 --> 00:33:23,920
pure function so it doesn't mutate your

00:33:21,460 --> 00:33:26,230
object whatever whatever observable

00:33:23,920 --> 00:33:29,470
comes in something completely different

00:33:26,230 --> 00:33:31,150
comes out so it makes sure that you it

00:33:29,470 --> 00:33:33,610
doesn't change the original observable

00:33:31,150 --> 00:33:35,950
if you create observable and then you

00:33:33,610 --> 00:33:37,960
map it to something else you can still

00:33:35,950 --> 00:33:39,190
subscribe to the first observable and

00:33:37,960 --> 00:33:41,740
you would still get the original data

00:33:39,190 --> 00:33:44,980
although it was mapped to something else

00:33:41,740 --> 00:33:47,920
you can have two separate instances and

00:33:44,980 --> 00:33:50,500
this is really powerful because by using

00:33:47,920 --> 00:33:52,260
the event streams you can organize your

00:33:50,500 --> 00:33:55,330
entire applications you just have to

00:33:52,260 --> 00:33:57,460
think from user perspective what do I

00:33:55,330 --> 00:33:59,440
want to do what is the user fool does

00:33:57,460 --> 00:34:01,630
the user clicks here or does he does

00:33:59,440 --> 00:34:04,090
this and then what happens on this click

00:34:01,630 --> 00:34:07,570
or what happens on this input field so

00:34:04,090 --> 00:34:09,429
once you are able to visualize these

00:34:07,570 --> 00:34:12,250
streams then everything else is simple

00:34:09,429 --> 00:34:14,409
then it's just a matter of picking the

00:34:12,250 --> 00:34:15,750
right operators picking the right

00:34:14,409 --> 00:34:18,120
observables and link

00:34:15,750 --> 00:34:20,220
them together and the important thing is

00:34:18,120 --> 00:34:22,379
that when you have some error or

00:34:20,220 --> 00:34:23,760
something is wrong in the application

00:34:22,379 --> 00:34:25,889
you can simply just follow the

00:34:23,760 --> 00:34:28,950
observable stream and figure out what

00:34:25,889 --> 00:34:30,870
happened with iterate boss it's quite

00:34:28,950 --> 00:34:33,179
difficult because something somewhere it

00:34:30,870 --> 00:34:35,520
might go wrong if you're using promises

00:34:33,179 --> 00:34:36,899
at some point something breaks and if

00:34:35,520 --> 00:34:38,370
everything is changed you really don't

00:34:36,899 --> 00:34:42,060
know what happened with observables you

00:34:38,370 --> 00:34:46,649
can easily follow so let's get back to

00:34:42,060 --> 00:34:49,470
the presentation I promise that I will

00:34:46,649 --> 00:34:51,360
talk about piper ball or lateral

00:34:49,470 --> 00:34:54,899
operators so in the beginning they were

00:34:51,360 --> 00:34:58,890
called lateral because they were similar

00:34:54,899 --> 00:35:00,540
to existing light operator in Rx but

00:34:58,890 --> 00:35:02,670
they decided to call it Piper ball

00:35:00,540 --> 00:35:05,610
because it makes more sense and as you

00:35:02,670 --> 00:35:08,220
can see it uses pipe to link the

00:35:05,610 --> 00:35:11,670
operators together so why were they

00:35:08,220 --> 00:35:15,150
introduced at all it came with a version

00:35:11,670 --> 00:35:20,940
5 it's pretty much standard in a version

00:35:15,150 --> 00:35:23,250
5.5 and this is how we started and at

00:35:20,940 --> 00:35:24,410
least I started this way so there was

00:35:23,250 --> 00:35:26,760
this rx

00:35:24,410 --> 00:35:28,770
library I just took care it again

00:35:26,760 --> 00:35:30,240
because why would I import piece by

00:35:28,770 --> 00:35:33,270
piece let's just take everything right

00:35:30,240 --> 00:35:36,090
and then you bundle your application and

00:35:33,270 --> 00:35:38,610
suddenly it has seven mega bytes because

00:35:36,090 --> 00:35:42,090
Rx is huge there are like hundreds of

00:35:38,610 --> 00:35:44,580
operators and some of them depend on

00:35:42,090 --> 00:35:46,980
stuff that's not even rx with bundles

00:35:44,580 --> 00:35:50,190
again with bunch of node modules which

00:35:46,980 --> 00:35:53,070
you don't really need so there came the

00:35:50,190 --> 00:35:55,140
prototype patching that was a nice way

00:35:53,070 --> 00:35:57,170
to separate the functionality so you

00:35:55,140 --> 00:36:03,150
would take just the core observable and

00:35:57,170 --> 00:36:05,490
then you would import operators so by

00:36:03,150 --> 00:36:07,650
doing this you are actually patching the

00:36:05,490 --> 00:36:10,830
observable so observable itself didn't

00:36:07,650 --> 00:36:13,590
have anything in the new import is line

00:36:10,830 --> 00:36:15,780
and under the hood it adds to Ajax meta

00:36:13,590 --> 00:36:19,680
to the observable then this one acts

00:36:15,780 --> 00:36:22,770
catch and this one adds map this was

00:36:19,680 --> 00:36:24,510
nice because the size was reduced but

00:36:22,770 --> 00:36:26,550
the bad thing was that it's quite easy

00:36:24,510 --> 00:36:26,940
to forget this and we still have it this

00:36:26,550 --> 00:36:30,210
way

00:36:26,940 --> 00:36:32,819
in our application and we just had the

00:36:30,210 --> 00:36:33,920
issue today with this did we just forgot

00:36:32,819 --> 00:36:36,180
one Operator

00:36:33,920 --> 00:36:39,030
and it's quite easy to do this because

00:36:36,180 --> 00:36:41,099
there's no intelligence there's no UI

00:36:39,030 --> 00:36:46,050
helping you telling you hey you're

00:36:41,099 --> 00:36:48,450
missing this so there was then another

00:36:46,050 --> 00:36:51,000
way this is pretty much supported by

00:36:48,450 --> 00:36:53,069
angular team and if you look at their

00:36:51,000 --> 00:36:56,730
code especially the router which is

00:36:53,069 --> 00:36:58,800
completely built on top of our X you can

00:36:56,730 --> 00:37:01,589
see that this is how they're calling it

00:36:58,800 --> 00:37:03,300
so by importing it directly our

00:37:01,589 --> 00:37:06,000
operators they make sure that every

00:37:03,300 --> 00:37:09,300
operator is there and that nothing is

00:37:06,000 --> 00:37:12,450
missing the bad thing is that JavaScript

00:37:09,300 --> 00:37:15,859
call function by default doesn't have

00:37:12,450 --> 00:37:18,119
type so response is any so all these

00:37:15,859 --> 00:37:21,810
intelligence and night nice things that

00:37:18,119 --> 00:37:25,260
type had just that type screen brings is

00:37:21,810 --> 00:37:27,089
completely gone and this is especially

00:37:25,260 --> 00:37:29,520
hard if you are trying to figure out

00:37:27,089 --> 00:37:33,020
what's going on in rx if you ever try to

00:37:29,520 --> 00:37:35,520
debug router you will just end up in

00:37:33,020 --> 00:37:37,859
hundreds of observables going each other

00:37:35,520 --> 00:37:40,140
and your original code is completely

00:37:37,859 --> 00:37:41,790
gone you can't even see from where you

00:37:40,140 --> 00:37:44,579
call this you just get lost in the

00:37:41,790 --> 00:37:47,550
observables and this was of course pain

00:37:44,579 --> 00:37:51,089
for debugging so that's pretty much the

00:37:47,550 --> 00:37:54,140
main reason why reactive X team decided

00:37:51,089 --> 00:37:57,480
to bring pipes with pipes you have the

00:37:54,140 --> 00:38:00,089
same benefit of the call where you can

00:37:57,480 --> 00:38:03,480
pretty much target directly the parts

00:38:00,089 --> 00:38:05,670
that you need and instead of bringing

00:38:03,480 --> 00:38:08,540
observables and then patching it you're

00:38:05,670 --> 00:38:11,790
actually bringing the upper of the

00:38:08,540 --> 00:38:13,859
different types of observables so if I

00:38:11,790 --> 00:38:17,010
would like interval I just bring

00:38:13,859 --> 00:38:19,020
interval which is completely isolated

00:38:17,010 --> 00:38:21,450
part it's built on top of operate of

00:38:19,020 --> 00:38:25,290
observable but it's completely separate

00:38:21,450 --> 00:38:29,130
and then I can use pipes to nicely

00:38:25,290 --> 00:38:31,770
organize my my operators and the best

00:38:29,130 --> 00:38:33,750
thing is that if you try to debug you

00:38:31,770 --> 00:38:36,270
can actually see the whole flow you can

00:38:33,750 --> 00:38:37,090
track it so it's no longer mass of

00:38:36,270 --> 00:38:41,950
different observe

00:38:37,090 --> 00:38:44,740
you can nicely follow what's going on so

00:38:41,950 --> 00:38:50,050
that's it and hopefully you can see this

00:38:44,740 --> 00:38:53,640
nice video so once you learn the secrets

00:38:50,050 --> 00:38:56,500
of rx and learn how the operators work

00:38:53,640 --> 00:38:59,410
then doing synchronizations like this

00:38:56,500 --> 00:39:02,020
won't be a big deal for you if you're

00:38:59,410 --> 00:39:04,540
interested in the game itself

00:39:02,020 --> 00:39:06,790
it's hosted on the github these slides

00:39:04,540 --> 00:39:10,030
will be available probably tomorrow

00:39:06,790 --> 00:39:11,830
already on the meetup page that's my

00:39:10,030 --> 00:39:14,580
handle for Twitter if you want to follow

00:39:11,830 --> 00:39:18,340
me or just want to see what's going on

00:39:14,580 --> 00:39:19,730
thank you for your listening and hope it

00:39:18,340 --> 00:39:23,340
was worth it

00:39:19,730 --> 00:39:23,340

YouTube URL: https://www.youtube.com/watch?v=Doyn3oZPrY4


