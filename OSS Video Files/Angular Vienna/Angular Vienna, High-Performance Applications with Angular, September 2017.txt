Title: Angular Vienna, High-Performance Applications with Angular, September 2017
Publication date: 2018-01-24
Playlist: Angular Vienna
Description: 
	There is not a sole adjusting screw for performance tuning in single page applications but even several influencing factors that need to be considered. This talk shows how to deal with them.
You'll learn how to leverage Ahead of Time Compilation (AOT), Tree Shaking and Lazy Loading to improve the startup performance of your application dramatically. For this, we'll look at the Angular Build Optimizer as well as at Googleâ€™s Closure compiler that allows aggressive optimizations. In addition to that you'll see how to use the optimization strategy OnPush to speed up data binding performance in your solutions. Furthermore, Service Worker for caching and instant loading will be covered as well as Server Side Rendering to improve the perceived loading time.

Find Manfred on Twitter: https://twitter.com/ManfredSteyer

Talk recorded at Angular Vienna: https://www.meetup.com/Angular-Vienna/
Captions: 
	00:00:00,030 --> 00:00:06,420
the topic of my presentation is about

00:00:02,429 --> 00:00:08,970
performance tuning with angular and let

00:00:06,420 --> 00:00:12,030
me introduce myself I'm an forget I'm a

00:00:08,970 --> 00:00:15,450
train and consultant and I'm focusing on

00:00:12,030 --> 00:00:18,359
the topic angular I'm doing nothing but

00:00:15,450 --> 00:00:21,750
angular since it bans PETA in December

00:00:18,359 --> 00:00:24,210
2015 and I'm also a Google developer

00:00:21,750 --> 00:00:27,810
expert which means that I am connected

00:00:24,210 --> 00:00:28,560
to Google and the angular team and from

00:00:27,810 --> 00:00:31,740
time to time

00:00:28,560 --> 00:00:34,500
I'm writing my last book was also about

00:00:31,740 --> 00:00:39,030
Angola by the way it's the book with the

00:00:34,500 --> 00:00:44,910
most ugly cover animal but anyway I like

00:00:39,030 --> 00:00:50,879
it so let's start with a little picture

00:00:44,910 --> 00:00:55,370
who knows this most not most some of you

00:00:50,879 --> 00:01:00,149
it's a free 86 who knows the Intel 386

00:00:55,370 --> 00:01:03,750
ok about the half the hero of my

00:01:00,149 --> 00:01:06,299
childhood it is a home computer and a

00:01:03,750 --> 00:01:09,180
nice thing of this Intel computer is

00:01:06,299 --> 00:01:11,700
there was this - about button perhaps

00:01:09,180 --> 00:01:14,130
you remember it and when you push this

00:01:11,700 --> 00:01:17,790
button then the computer is twice as

00:01:14,130 --> 00:01:21,330
fast of course the real use case of its

00:01:17,790 --> 00:01:24,119
- was to make the computer slower to be

00:01:21,330 --> 00:01:28,680
more compatible with the formal version

00:01:24,119 --> 00:01:31,700
of it with the 80 to 86 and now the

00:01:28,680 --> 00:01:35,189
question arises if there is such a

00:01:31,700 --> 00:01:37,409
turnkey solution for angular and as it

00:01:35,189 --> 00:01:39,479
turns out yes there is such a turnkey

00:01:37,409 --> 00:01:42,390
solution for angular there are some

00:01:39,479 --> 00:01:44,490
quick wins you can use to get a better

00:01:42,390 --> 00:01:47,820
performance for instance you can do

00:01:44,490 --> 00:01:51,119
bundling you can also - minification and

00:01:47,820 --> 00:01:53,970
you can enable the production mode in

00:01:51,119 --> 00:01:56,570
this cases you get a much better

00:01:53,970 --> 00:02:00,329
performance when you run your code and

00:01:56,570 --> 00:02:02,820
the good things about this is that you

00:02:00,329 --> 00:02:05,820
don't need to do anything when you are

00:02:02,820 --> 00:02:08,009
using things like the CLI you just can

00:02:05,820 --> 00:02:11,580
create a production build and those

00:02:08,009 --> 00:02:13,780
things get baked into it but there are

00:02:11,580 --> 00:02:15,700
some other things you can do too

00:02:13,780 --> 00:02:19,030
to improve the performance of your

00:02:15,700 --> 00:02:21,610
application and that's what I'm talking

00:02:19,030 --> 00:02:24,040
about here that's what the contents of

00:02:21,610 --> 00:02:27,069
this talk is about I will start with

00:02:24,040 --> 00:02:29,740
fleas loading and reloading we'll also

00:02:27,069 --> 00:02:32,770
talk about performance for data binding

00:02:29,740 --> 00:02:36,310
with ambush I will talk about ahead of

00:02:32,770 --> 00:02:38,560
time compilation as well as about tree

00:02:36,310 --> 00:02:41,770
shaking and I will also talk about

00:02:38,560 --> 00:02:44,760
caching with service workers in addition

00:02:41,770 --> 00:02:47,620
to that I will talk about suicide

00:02:44,760 --> 00:02:50,019
rendering but first things first let's

00:02:47,620 --> 00:02:53,230
start with the first topic let's start

00:02:50,019 --> 00:02:55,959
with lazy loading so a good friend of

00:02:53,230 --> 00:02:58,300
mine told me that I'm very authentic

00:02:55,959 --> 00:03:02,140
when I'm talking about lazy things I

00:02:58,300 --> 00:03:04,060
have no idea what he meant but I think

00:03:02,140 --> 00:03:05,650
it was some kind of compliments don't

00:03:04,060 --> 00:03:07,870
know anyway

00:03:05,650 --> 00:03:10,420
what you see here is the typically

00:03:07,870 --> 00:03:12,640
structure of an angular application you

00:03:10,420 --> 00:03:15,130
have something like a root module that

00:03:12,640 --> 00:03:18,340
is bootstrapped you have several feature

00:03:15,130 --> 00:03:21,250
models perhaps one for each use case and

00:03:18,340 --> 00:03:24,790
you have one or several shared models

00:03:21,250 --> 00:03:28,090
and normally everything is loaded on

00:03:24,790 --> 00:03:30,850
startup of course that influences the

00:03:28,090 --> 00:03:34,150
startup time in a bad way and this is

00:03:30,850 --> 00:03:37,420
exactly where lazy loading comes in then

00:03:34,150 --> 00:03:40,120
you are leveraging lazy loading you just

00:03:37,420 --> 00:03:43,660
start with one or with several modules

00:03:40,120 --> 00:03:46,060
and then one by one you are loading the

00:03:43,660 --> 00:03:47,950
other models your needs when you need

00:03:46,060 --> 00:03:50,500
the first module you load the first

00:03:47,950 --> 00:03:53,079
model when you need the second one you

00:03:50,500 --> 00:03:56,980
load the second one and so on and so

00:03:53,079 --> 00:04:00,700
forth so what does it take to make use

00:03:56,980 --> 00:04:02,340
of lazy loading you just need a routing

00:04:00,700 --> 00:04:05,260
configuration for it

00:04:02,340 --> 00:04:07,660
normally when it comes to routing you

00:04:05,260 --> 00:04:10,690
have a mapping between paths and

00:04:07,660 --> 00:04:13,630
components when it comes to lazy loading

00:04:10,690 --> 00:04:16,780
you map your path to a module that

00:04:13,630 --> 00:04:19,780
should be lazy loaded then you activate

00:04:16,780 --> 00:04:22,900
the route in this case when we are

00:04:19,780 --> 00:04:25,539
switching to the route flights Angola or

00:04:22,900 --> 00:04:27,460
the angular router boots loads this

00:04:25,539 --> 00:04:30,069
flight booking model here

00:04:27,460 --> 00:04:32,560
for this you're losing load children and

00:04:30,069 --> 00:04:36,550
load children gets a string with the

00:04:32,560 --> 00:04:38,919
name of the model file and you a pants

00:04:36,550 --> 00:04:41,770
the name of the motor class to this

00:04:38,919 --> 00:04:44,199
model file name the name of the motor

00:04:41,770 --> 00:04:47,470
class would be here flight booking model

00:04:44,199 --> 00:04:50,410
so that's everything you need to do to

00:04:47,470 --> 00:04:53,340
get lazy loading to improve your startup

00:04:50,410 --> 00:04:56,949
performance now of course the question

00:04:53,340 --> 00:05:01,060
arises which route is activated when we

00:04:56,949 --> 00:05:04,570
are loading this model and the answer is

00:05:01,060 --> 00:05:07,030
you're lazy loaded model has a routing

00:05:04,570 --> 00:05:09,789
configuration of its own and they are

00:05:07,030 --> 00:05:13,030
you could you could insert a default

00:05:09,789 --> 00:05:16,060
route a route without a path or a route

00:05:13,030 --> 00:05:19,630
with an empty path and then this route

00:05:16,060 --> 00:05:22,960
would be activated after the lazy loaded

00:05:19,630 --> 00:05:29,110
model is loaded into the memory of your

00:05:22,960 --> 00:05:32,110
browser I think it's a good time to do

00:05:29,110 --> 00:05:35,889
some live demonstration I have prepared

00:05:32,110 --> 00:05:39,699
a simple example a simple example that

00:05:35,889 --> 00:05:43,180
is about booking flights and there is

00:05:39,699 --> 00:05:46,750
this menu item flight booking and this

00:05:43,180 --> 00:05:52,150
menu item triggers lazy loading for this

00:05:46,750 --> 00:05:54,340
I have just included this route you this

00:05:52,150 --> 00:05:56,320
route into my application with the name

00:05:54,340 --> 00:05:59,530
flight booking and as mentioned on the

00:05:56,320 --> 00:06:02,860
slides it points to the model as well as

00:05:59,530 --> 00:06:04,840
to the model class and in addition to

00:06:02,860 --> 00:06:08,229
that there is another important thing

00:06:04,840 --> 00:06:11,280
you have to get rid of every reference

00:06:08,229 --> 00:06:13,990
to this model within your main model

00:06:11,280 --> 00:06:19,539
let's have a look to this here we have

00:06:13,990 --> 00:06:22,449
my main model my routes model and here I

00:06:19,539 --> 00:06:25,330
have commanded out there reference to

00:06:22,449 --> 00:06:27,909
the flight booking model that is vital

00:06:25,330 --> 00:06:30,909
because as mentioned this would prevent

00:06:27,909 --> 00:06:33,430
lazy loading the reason for it is is a

00:06:30,909 --> 00:06:35,919
typically bundling solution would follow

00:06:33,430 --> 00:06:38,020
this reference and would put this

00:06:35,919 --> 00:06:40,719
reference and everything that could be

00:06:38,020 --> 00:06:41,319
reached from this reference into the

00:06:40,719 --> 00:06:44,919
main bar

00:06:41,319 --> 00:06:47,770
and of course when everything ends up in

00:06:44,919 --> 00:06:50,800
the main bundle lazy loading doesn't

00:06:47,770 --> 00:06:53,860
make any sense so for this reason just

00:06:50,800 --> 00:06:59,339
comment out any reference to the lazy

00:06:53,860 --> 00:07:07,599
loaded models okay let's do some

00:06:59,339 --> 00:07:10,839
Diagnostics you have a question deep

00:07:07,599 --> 00:07:13,360
linking absolutely works so you can jump

00:07:10,839 --> 00:07:16,539
to a supper out of your lazy loaded

00:07:13,360 --> 00:07:19,089
model let's have a look to the network

00:07:16,539 --> 00:07:20,740
tap let's trace the files that are

00:07:19,089 --> 00:07:26,409
downloaded into the browser

00:07:20,740 --> 00:07:30,249
I am reloading Hume my application a lot

00:07:26,409 --> 00:07:33,699
of bundles are loaded bundles and other

00:07:30,249 --> 00:07:36,520
files then let's clear this and let's

00:07:33,699 --> 00:07:39,159
switch over to flight booking and now we

00:07:36,520 --> 00:07:41,439
see that our own bundle for flight

00:07:39,159 --> 00:07:44,139
booking is loaded this own bundle is

00:07:41,439 --> 00:07:47,680
called after my model it is called

00:07:44,139 --> 00:07:50,469
flight booking model chunk so I think

00:07:47,680 --> 00:07:55,379
this shows that lazy loading really

00:07:50,469 --> 00:07:59,289
takes happen here at raw back of this is

00:07:55,379 --> 00:08:02,860
that the lazy loading procedure takes

00:07:59,289 --> 00:08:04,930
some seconds during runtime when I'm

00:08:02,860 --> 00:08:07,839
clicking here the first time at flight

00:08:04,930 --> 00:08:10,240
booking we see this nifty loading

00:08:07,839 --> 00:08:14,110
indicator ok I've stolen it from some

00:08:10,240 --> 00:08:16,869
website but this also shows that the

00:08:14,110 --> 00:08:19,089
user has to wait when he or she triggers

00:08:16,869 --> 00:08:24,369
lazy loading this is the drawback of

00:08:19,089 --> 00:08:33,010
this procedure and this is exactly where

00:08:24,369 --> 00:08:36,579
pre loading comes into play pre loading

00:08:33,010 --> 00:08:39,370
means that models that might be needed

00:08:36,579 --> 00:08:42,639
later are loaded after the start of the

00:08:39,370 --> 00:08:45,819
application and this in turns means that

00:08:42,639 --> 00:08:49,480
when the model is needed actually it is

00:08:45,819 --> 00:08:51,850
available immediately what does it take

00:08:49,480 --> 00:08:54,490
to go be pre loading you just have to

00:08:51,850 --> 00:08:56,610
define a pre loading strategy when

00:08:54,490 --> 00:08:59,410
you set up your routing configuration

00:08:56,610 --> 00:09:01,240
here I'm calling route 2 motor four

00:08:59,410 --> 00:09:03,730
routes to set up the routing

00:09:01,240 --> 00:09:07,029
configuration for the routes module and

00:09:03,730 --> 00:09:11,220
as you might know this method takes a

00:09:07,029 --> 00:09:14,950
second parameter object with further

00:09:11,220 --> 00:09:16,899
parameters for their routing and sterte

00:09:14,950 --> 00:09:19,930
parameter we have to go brief is the

00:09:16,899 --> 00:09:22,330
parameter pre loading strategy here I'm

00:09:19,930 --> 00:09:25,330
using the preload all moto strategy

00:09:22,330 --> 00:09:28,480
which means that every model that could

00:09:25,330 --> 00:09:31,570
be lazily loaded is loaded when the

00:09:28,480 --> 00:09:34,570
application starts up so as a matter of

00:09:31,570 --> 00:09:37,510
fact when we are using this first of all

00:09:34,570 --> 00:09:40,149
the application stats they use a C step

00:09:37,510 --> 00:09:42,399
location and after this after the

00:09:40,149 --> 00:09:45,010
application can be seen by the user

00:09:42,399 --> 00:09:48,490
after the application is interactive

00:09:45,010 --> 00:09:52,029
angular starts to preload all the other

00:09:48,490 --> 00:09:56,010
lazy models and because of this those

00:09:52,029 --> 00:09:59,610
latency models get available quite soon

00:09:56,010 --> 00:10:02,410
ok so much for lazy loading and

00:09:59,610 --> 00:10:04,839
pre-loading let's talk about another

00:10:02,410 --> 00:10:07,600
thing to speed up the performance of

00:10:04,839 --> 00:10:10,329
your angular application let's talk

00:10:07,600 --> 00:10:14,110
about the on Bush optimization technique

00:10:10,329 --> 00:10:22,089
and for this I just want to start with a

00:10:14,110 --> 00:10:24,459
little demonstration as mentioned my

00:10:22,089 --> 00:10:27,250
application allows to book flights and

00:10:24,459 --> 00:10:29,200
here I can search for flights for

00:10:27,250 --> 00:10:31,980
instance for flights that go from

00:10:29,200 --> 00:10:36,100
Hamburg to Graz which is the city I am

00:10:31,980 --> 00:10:38,740
living in and then here we have a delay

00:10:36,100 --> 00:10:41,560
button and we push this when we push

00:10:38,740 --> 00:10:43,570
this delay button just the first flight

00:10:41,560 --> 00:10:48,220
here is delayed so when you look at the

00:10:43,570 --> 00:10:51,940
first flight we have something like 0 43

00:10:48,220 --> 00:10:55,120
and when we push it again we have 0 58

00:10:51,940 --> 00:10:57,910
and when we push it again we have 114

00:10:55,120 --> 00:11:01,180
and so on and so forth perhaps you've

00:10:57,910 --> 00:11:04,360
notified the animation I have put into

00:11:01,180 --> 00:11:07,120
this application this isn't because I

00:11:04,360 --> 00:11:08,380
want to show you how animations work but

00:11:07,120 --> 00:11:11,140
this is because

00:11:08,380 --> 00:11:14,110
I've tried to visualize that change

00:11:11,140 --> 00:11:17,290
detection mechanism of angular every

00:11:14,110 --> 00:11:20,220
time such a cart blinks Angola is

00:11:17,290 --> 00:11:23,860
checking this cart for an change and

00:11:20,220 --> 00:11:26,860
here we see even though just the first

00:11:23,860 --> 00:11:31,060
flight is delayed Angola checks every

00:11:26,860 --> 00:11:33,910
flights for an change and this can leads

00:11:31,060 --> 00:11:35,640
to a bad performance when everything is

00:11:33,910 --> 00:11:38,470
checked all the time

00:11:35,640 --> 00:11:41,860
normally that isn't a matter at all

00:11:38,470 --> 00:11:44,200
coz Angola is generating source code for

00:11:41,860 --> 00:11:47,410
these checks and the source code can

00:11:44,200 --> 00:11:50,080
handle some hundreds thousands of data

00:11:47,410 --> 00:11:53,440
bindings but in some situation this is

00:11:50,080 --> 00:11:55,630
just too slow especially in situation

00:11:53,440 --> 00:11:58,390
where you are triggering change

00:11:55,630 --> 00:12:01,600
detection on a regular basis for

00:11:58,390 --> 00:12:04,000
instance when your mouse move event is

00:12:01,600 --> 00:12:06,940
triggering a change detection event on

00:12:04,000 --> 00:12:09,520
the regular basis then you are need then

00:12:06,940 --> 00:12:14,190
you need something else something like

00:12:09,520 --> 00:12:14,190
this on push change detection strategy

00:12:17,460 --> 00:12:24,010
then it comes to on Bush you can lock

00:12:21,190 --> 00:12:26,620
down specific components for instance

00:12:24,010 --> 00:12:29,380
here I've locked down my card components

00:12:26,620 --> 00:12:32,320
which means that Angola is keeping then

00:12:29,380 --> 00:12:35,950
for change detection Angola will only

00:12:32,320 --> 00:12:39,280
check them for changes then Angola is

00:12:35,950 --> 00:12:43,870
not defied that there might be a change

00:12:39,280 --> 00:12:47,410
and what's not the fight means I will

00:12:43,870 --> 00:12:50,080
tell you in some slides first of all

00:12:47,410 --> 00:12:52,510
let's talk about how to activate this

00:12:50,080 --> 00:12:55,150
optimization technique for components

00:12:52,510 --> 00:12:58,210
this is the most easiest part of this

00:12:55,150 --> 00:13:01,000
you just have to set change detection do

00:12:58,210 --> 00:13:03,370
the strategy on Bush when you're using

00:13:01,000 --> 00:13:05,740
this then angular locks down the

00:13:03,370 --> 00:13:08,110
component and then Angola is just

00:13:05,740 --> 00:13:10,410
skipping this component for change

00:13:08,110 --> 00:13:14,050
detection now of course the question

00:13:10,410 --> 00:13:16,750
arises what do we need to do to notify

00:13:14,050 --> 00:13:20,740
Angola about a change within this

00:13:16,750 --> 00:13:21,850
lockdown components and there are two

00:13:20,740 --> 00:13:24,910
answers for this

00:13:21,850 --> 00:13:28,900
the first answer sounds easy at first

00:13:24,910 --> 00:13:31,840
but it isn't the first answer says just

00:13:28,900 --> 00:13:35,200
changed it bounced data just changed

00:13:31,840 --> 00:13:38,590
data that is bounced to a property via

00:13:35,200 --> 00:13:42,610
an input binding and the second answer

00:13:38,590 --> 00:13:45,700
is notify a bound observable so let's

00:13:42,610 --> 00:13:48,400
have a look at the first answer here in

00:13:45,700 --> 00:13:51,580
this example I have in my parent

00:13:48,400 --> 00:13:53,650
component an array of lights and of

00:13:51,580 --> 00:13:55,810
course this array consists of several

00:13:53,650 --> 00:13:58,480
flights and those flights are passed

00:13:55,810 --> 00:14:02,590
down to their flight card components and

00:13:58,480 --> 00:14:06,790
now to notify angola about the change we

00:14:02,590 --> 00:14:10,030
have to change those flights but to gain

00:14:06,790 --> 00:14:12,280
a good performance angola isn't checking

00:14:10,030 --> 00:14:14,650
whether the first property of the flight

00:14:12,280 --> 00:14:17,050
change the second property of the flight

00:14:14,650 --> 00:14:19,060
changed the first property property of

00:14:17,050 --> 00:14:21,670
the flight changed or the fiftieth

00:14:19,060 --> 00:14:23,590
property of the flight changed angola is

00:14:21,670 --> 00:14:26,650
just checking whether the whole flight

00:14:23,590 --> 00:14:30,280
changed angola is checking the object

00:14:26,650 --> 00:14:34,120
references here because of this angola

00:14:30,280 --> 00:14:36,880
can quite easily find out where a change

00:14:34,120 --> 00:14:40,510
occurred it just checks whether the

00:14:36,880 --> 00:14:43,420
object references changed and this means

00:14:40,510 --> 00:14:46,630
we aren't allowed just to modify a

00:14:43,420 --> 00:14:50,260
property we have to exchange one object

00:14:46,630 --> 00:14:52,900
for another one some people are calling

00:14:50,260 --> 00:14:56,200
this immutable data structures when the

00:14:52,900 --> 00:14:58,870
object itself can't change but the

00:14:56,200 --> 00:15:02,980
object itself has to be exchanged by

00:14:58,870 --> 00:15:05,470
another object here we have a

00:15:02,980 --> 00:15:06,130
demonstration for the second answer F

00:15:05,470 --> 00:15:09,970
gave you

00:15:06,130 --> 00:15:12,910
we could also bind an observable within

00:15:09,970 --> 00:15:15,310
the component in question with the async

00:15:12,910 --> 00:15:18,520
pipe in this case the async pipe

00:15:15,310 --> 00:15:21,040
subscribes for this observable and the

00:15:18,520 --> 00:15:23,770
async pipes just triggers change

00:15:21,040 --> 00:15:27,940
detection every time the observable is

00:15:23,770 --> 00:15:31,500
coming up with a new value so let's look

00:15:27,940 --> 00:15:31,500
at a demonstration for this

00:15:33,440 --> 00:15:41,600
I have a tiny secret for you

00:15:36,860 --> 00:15:44,060
I am not changing the objects here the

00:15:41,600 --> 00:15:45,920
flight objects I am exchanging the whole

00:15:44,060 --> 00:15:48,500
flight references

00:15:45,920 --> 00:15:50,930
every time I'm pressing delay a new

00:15:48,500 --> 00:15:53,300
flight is generated and you fly it with

00:15:50,930 --> 00:15:56,209
the new date because of this I can

00:15:53,300 --> 00:16:00,949
easily activate on Buechele let's do

00:15:56,209 --> 00:16:07,459
this I'm switching to my flight card

00:16:00,949 --> 00:16:11,810
component flight - card dots component

00:16:07,459 --> 00:16:16,209
and here I'm activating that change

00:16:11,810 --> 00:16:20,389
detection strategy on bush let's save it

00:16:16,209 --> 00:16:25,490
let's wait for their compiler and for

00:16:20,389 --> 00:16:30,439
the bundling okay and let's go back into

00:16:25,490 --> 00:16:33,230
our application I am searching for

00:16:30,439 --> 00:16:36,170
flights and then I'm delaying the first

00:16:33,230 --> 00:16:39,350
flight and as we are seeing here just

00:16:36,170 --> 00:16:43,339
the first card is checked for and change

00:16:39,350 --> 00:16:45,410
because just the object reference of the

00:16:43,339 --> 00:16:51,889
first flight has been changed by my

00:16:45,410 --> 00:16:59,930
application of course we can have a look

00:16:51,889 --> 00:17:04,209
their flight service flight dot service

00:16:59,930 --> 00:17:04,209
would be the name of this

00:17:06,730 --> 00:17:15,790
okay this is my delay function let's go

00:17:10,390 --> 00:17:19,209
to sin mode and I'm doing this procedure

00:17:15,790 --> 00:17:21,699
step by step it's a bit too long I think

00:17:19,209 --> 00:17:24,069
you could save some lines of code here

00:17:21,699 --> 00:17:24,370
but I really wanted to do this step by

00:17:24,069 --> 00:17:28,240
step

00:17:24,370 --> 00:17:30,820
to emphasize on what their idea is

00:17:28,240 --> 00:17:33,610
behind exchanging the object reference

00:17:30,820 --> 00:17:35,590
first of all I'm grabbing the current

00:17:33,610 --> 00:17:38,080
flight's array I'm calling it all

00:17:35,590 --> 00:17:40,690
flights then I'm grabbing the first

00:17:38,080 --> 00:17:43,240
flight of this flight array I'm calling

00:17:40,690 --> 00:17:45,970
it all flight and then I'm taking the

00:17:43,240 --> 00:17:48,700
date of the old flight which is just the

00:17:45,970 --> 00:17:50,230
ISO string and I'm passing this date

00:17:48,700 --> 00:17:53,190
with the date constructor

00:17:50,230 --> 00:17:56,919
I'm calling the result of this all state

00:17:53,190 --> 00:17:59,549
then I am calculating the new date the

00:17:56,919 --> 00:18:03,190
new date is the old date plus their

00:17:59,549 --> 00:18:08,110
milliseconds for 15 minutes and then

00:18:03,190 --> 00:18:11,350
then I would use default angular when I

00:18:08,110 --> 00:18:14,020
would go with modifying properties I

00:18:11,350 --> 00:18:16,809
would do something like this I would

00:18:14,020 --> 00:18:19,870
just modify the date property of the old

00:18:16,809 --> 00:18:22,929
flight but as mentioned before we aren't

00:18:19,870 --> 00:18:25,690
allowed to do this because we have to

00:18:22,929 --> 00:18:28,990
exchange the whole object reference

00:18:25,690 --> 00:18:32,740
because of this M news I'm using this

00:18:28,990 --> 00:18:37,120
nifty syntax Ian this nifty syndics that

00:18:32,740 --> 00:18:40,540
comes with typescript I think 2.1 or 2.2

00:18:37,120 --> 00:18:43,900
this is called a spread operator for

00:18:40,540 --> 00:18:47,650
objects here I'm just creating a new

00:18:43,900 --> 00:18:51,580
flight and this new flight gets all the

00:18:47,650 --> 00:18:53,950
properties of the old flights all the

00:18:51,580 --> 00:18:56,350
properties no not all the properties

00:18:53,950 --> 00:18:58,750
because a little property in the north

00:18:56,350 --> 00:19:03,669
of runs now because a little property

00:18:58,750 --> 00:19:08,020
here is reluctant and has been exchanged

00:19:03,669 --> 00:19:12,570
and this is the date so as you see using

00:19:08,020 --> 00:19:15,760
immutables is a bit harder is a bit more

00:19:12,570 --> 00:19:19,210
verbose than just modifying properties

00:19:15,760 --> 00:19:19,990
but it isn't that difficult as you might

00:19:19,210 --> 00:19:23,140
have

00:19:19,990 --> 00:19:25,900
imagined of course I want to stick with

00:19:23,140 --> 00:19:28,960
immutables because of this I'm not

00:19:25,900 --> 00:19:31,780
modifying the existing array I'm just

00:19:28,960 --> 00:19:33,990
exchanging the existing array and again

00:19:31,780 --> 00:19:37,720
for this I'm using the spread of Parata

00:19:33,990 --> 00:19:40,840
operator for arrays the new array

00:19:37,720 --> 00:19:43,809
consists of the new flight as well as of

00:19:40,840 --> 00:19:46,450
all the other unmodified flights of the

00:19:43,809 --> 00:19:47,500
old array again I'm using the spread

00:19:46,450 --> 00:19:50,100
operator here

00:19:47,500 --> 00:19:53,020
it's the spread operator cause I'm

00:19:50,100 --> 00:19:56,800
spreading all the items from the old

00:19:53,020 --> 00:19:59,890
array into the new array not all the

00:19:56,800 --> 00:20:02,679
items all the items beginning with the

00:19:59,890 --> 00:20:05,290
index position one yeah and then I'm

00:20:02,679 --> 00:20:08,350
writing new flights back to my flights

00:20:05,290 --> 00:20:10,570
property because of this Angola just

00:20:08,350 --> 00:20:13,270
needs to check whether the object

00:20:10,570 --> 00:20:16,809
reference for the flight array has been

00:20:13,270 --> 00:20:20,200
exchanged as well as whether the object

00:20:16,809 --> 00:20:22,710
reference for the old flight for the

00:20:20,200 --> 00:20:27,790
first flight this year has been

00:20:22,710 --> 00:20:30,220
exchanged so this idea isn't that new to

00:20:27,790 --> 00:20:33,610
be honest perhaps there are some rekt

00:20:30,220 --> 00:20:36,160
guys beyond view to be honest we have

00:20:33,610 --> 00:20:41,250
borrowed this idea from the area of

00:20:36,160 --> 00:20:41,250
react there are quite similar concepts

00:20:44,850 --> 00:20:50,460
that would be possible in this very case

00:20:53,820 --> 00:20:59,559
that's a good point in this very case it

00:20:57,220 --> 00:21:02,910
would be enough just to exchange the

00:20:59,559 --> 00:21:06,880
object reference for this one flight but

00:21:02,910 --> 00:21:08,350
when I'm doing immutables I like hits 2

00:21:06,880 --> 00:21:10,630
to immutables

00:21:08,350 --> 00:21:13,360
at least for the whole use case I don't

00:21:10,630 --> 00:21:16,059
want to mix immutables with mutable

00:21:13,360 --> 00:21:18,730
scuzz in this case I have to think too

00:21:16,059 --> 00:21:24,640
much what Angola is doing during change

00:21:18,730 --> 00:21:29,140
tracking and so on ok and as we've seen

00:21:24,640 --> 00:21:32,790
here just a first cut here brings really

00:21:29,140 --> 00:21:32,790
like this could do this all the day

00:21:33,650 --> 00:21:49,440
okay yeah yeah for the next Tocqueville

00:21:43,710 --> 00:21:52,890
consider this okay one important thing

00:21:49,440 --> 00:21:55,650
is when you go with on Bush this isn't

00:21:52,890 --> 00:21:59,100
an all-or-nothing strategy you can use

00:21:55,650 --> 00:22:00,810
on Bush just for selected components you

00:21:59,100 --> 00:22:03,900
don't have to use it for everything

00:22:00,810 --> 00:22:06,810
as mentioned I don't mix it with in the

00:22:03,900 --> 00:22:09,180
use case but as a matter of fact you can

00:22:06,810 --> 00:22:12,570
just use it for a use case that needs

00:22:09,180 --> 00:22:15,660
additional performance some people are

00:22:12,570 --> 00:22:18,420
saying hey I want to use on Bush and

00:22:15,660 --> 00:22:21,240
immutables and observables all the time

00:22:18,420 --> 00:22:24,650
and in this case you should have a look

00:22:21,240 --> 00:22:27,240
at a Redux pattern and at some Redux

00:22:24,650 --> 00:22:30,420
implementation for instance on the

00:22:27,240 --> 00:22:33,240
implementation and she rx store which is

00:22:30,420 --> 00:22:36,660
a Redux implementation with angular in

00:22:33,240 --> 00:22:41,280
minds it has been created of according

00:22:36,660 --> 00:22:44,160
member of the angular team okay so much

00:22:41,280 --> 00:22:46,860
for this let's go on with the next topic

00:22:44,160 --> 00:22:50,550
the next topic is about ahead of time

00:22:46,860 --> 00:22:54,570
compilation perhaps you know Angola is

00:22:50,550 --> 00:22:57,390
compiling HTML templates in any way to

00:22:54,570 --> 00:23:01,800
JavaScript the idea behind this is that

00:22:57,390 --> 00:23:06,060
Java scripts can be faster evaluated

00:23:01,800 --> 00:23:08,310
compared to HTML and for compiling this

00:23:06,060 --> 00:23:11,130
stuff to JavaScript there are two

00:23:08,310 --> 00:23:13,470
approaches the first approach is called

00:23:11,130 --> 00:23:17,190
just-in-time in this case you are

00:23:13,470 --> 00:23:19,830
compiling at runtime when the

00:23:17,190 --> 00:23:23,310
application starts up of course this is

00:23:19,830 --> 00:23:25,980
delaying your startup procedure and then

00:23:23,310 --> 00:23:29,070
there is ahead of time compilation which

00:23:25,980 --> 00:23:31,560
means that the HTML templates are

00:23:29,070 --> 00:23:35,100
compiled to JavaScript during an

00:23:31,560 --> 00:23:37,380
additional build step and there are some

00:23:35,100 --> 00:23:40,170
advantages of course when it came to

00:23:37,380 --> 00:23:42,390
when it comes to a OD the obvious

00:23:40,170 --> 00:23:45,200
advantage of this is you get a better

00:23:42,390 --> 00:23:47,779
start up performance of course you

00:23:45,200 --> 00:23:49,340
needs to compile within the browser so

00:23:47,779 --> 00:23:51,649
you'll get a better performance at

00:23:49,340 --> 00:23:55,580
runtime but there are also two

00:23:51,649 --> 00:23:58,820
additional none that obvious advantages

00:23:55,580 --> 00:24:01,700
of ahead of time one of those is you get

00:23:58,820 --> 00:24:04,610
smaller bundles co-ceo tones needs to

00:24:01,700 --> 00:24:07,549
include the compiler into your bundles

00:24:04,610 --> 00:24:08,690
in this case you don't need the compiler

00:24:07,549 --> 00:24:11,330
within the browser

00:24:08,690 --> 00:24:14,659
cause you are compiling without the

00:24:11,330 --> 00:24:18,919
browser touring their other compilation

00:24:14,659 --> 00:24:21,919
steps and the compiler is quite a big

00:24:18,919 --> 00:24:23,690
thing the compiler has about the half of

00:24:21,919 --> 00:24:27,740
the rest of the core framework

00:24:23,690 --> 00:24:32,299
it has about 300k so you can just save

00:24:27,740 --> 00:24:36,110
this 300k by doing a ot and there is

00:24:32,299 --> 00:24:39,889
another advantage that isn't obvious at

00:24:36,110 --> 00:24:42,440
first side tools can easier analyze the

00:24:39,889 --> 00:24:45,350
whole code of course when the whole code

00:24:42,440 --> 00:24:48,860
just consists of typescript or

00:24:45,350 --> 00:24:52,850
JavaScript it can be analyzed in a

00:24:48,860 --> 00:24:56,210
static way more easy and because of this

00:24:52,850 --> 00:24:59,029
you can detect unnecessary code within

00:24:56,210 --> 00:25:01,789
your bundles within your frameworks

00:24:59,029 --> 00:25:04,429
within your packages and then you can

00:25:01,789 --> 00:25:09,049
just remove this unneeded code from the

00:25:04,429 --> 00:25:12,710
bundles I think every framework has some

00:25:09,049 --> 00:25:15,320
lines of code some classes that aren't

00:25:12,710 --> 00:25:18,679
used by your application and of course

00:25:15,320 --> 00:25:21,529
those classes can then be removed you

00:25:18,679 --> 00:25:25,330
also call this tree shaking you are

00:25:21,529 --> 00:25:29,350
shaking a tree so that the unconnected

00:25:25,330 --> 00:25:34,100
branches of this tree are falling down

00:25:29,350 --> 00:25:37,730
when I talked about a OTE about a year

00:25:34,100 --> 00:25:40,880
ago I had to talk about how to configure

00:25:37,730 --> 00:25:45,110
your build tasks to do a OD that was a

00:25:40,880 --> 00:25:48,080
tricky and ever today we can just use

00:25:45,110 --> 00:25:51,860
the angular CLI the angular CLI comes

00:25:48,080 --> 00:25:55,039
with a pre defined compilation step as

00:25:51,860 --> 00:25:59,090
well as with a predefined compile and

00:25:55,039 --> 00:26:01,399
build task and this task contains a OD

00:25:59,090 --> 00:26:06,490
all you need to do is to create a

00:26:01,399 --> 00:26:10,220
production build and beneath the covers

00:26:06,490 --> 00:26:14,120
angular is using the AOD plugin nowadays

00:26:10,220 --> 00:26:17,059
this will change they have not a plug-in

00:26:14,120 --> 00:26:20,210
core but currently we are using the Ã¤Ã´t

00:26:17,059 --> 00:26:23,600
plug-in and this IOT plug-in is part of

00:26:20,210 --> 00:26:26,690
the NBN package ng Jewell's backpack and

00:26:23,600 --> 00:26:30,080
as the name implies and she tools web

00:26:26,690 --> 00:26:32,960
pack is just add on for backpack and

00:26:30,080 --> 00:26:36,409
that's why you can use it with outs the

00:26:32,960 --> 00:26:38,869
CLI do when you just have an vanilla

00:26:36,409 --> 00:26:42,830
backpack built you can use it with your

00:26:38,869 --> 00:26:46,340
backpack backpack build - so let's have

00:26:42,830 --> 00:26:49,940
a demonstration for this I've compiled

00:26:46,340 --> 00:26:52,610
my application twice when I've prepared

00:26:49,940 --> 00:26:56,869
for this talk I've compiled it once

00:26:52,610 --> 00:27:03,610
without a OD and once with a OD let's

00:26:56,869 --> 00:27:03,610
start with not a OD built 50-buck built

00:27:03,909 --> 00:27:12,610
life server entry file index.html and

00:27:12,999 --> 00:27:25,610
here we go and now let's go into the

00:27:22,999 --> 00:27:28,909
developer tools there is this nifty

00:27:25,610 --> 00:27:32,869
performance stack and let's measure the

00:27:28,909 --> 00:27:43,940
start performance of this application so

00:27:32,869 --> 00:27:48,440
as you see this takes a moment no it's

00:27:43,940 --> 00:27:52,490
it's just an ordinary application which

00:27:48,440 --> 00:27:55,399
is built for debug purposes so it's

00:27:52,490 --> 00:28:01,570
really a typical build and as we see

00:27:55,399 --> 00:28:01,570
here this took about seven milliseconds

00:28:02,409 --> 00:28:06,180
seven seconds seven thousand

00:28:04,549 --> 00:28:09,750
milliseconds yeah

00:28:06,180 --> 00:28:13,560
and when we look at this diagram we see

00:28:09,750 --> 00:28:16,410
the browser is executing most of the

00:28:13,560 --> 00:28:20,460
time this yellow task so what is this

00:28:16,410 --> 00:28:23,970
yellow task about this yellow task is

00:28:20,460 --> 00:28:26,580
about scripting we see here and when you

00:28:23,970 --> 00:28:30,780
guess what this scripting is about what

00:28:26,580 --> 00:28:33,450
would you say yeah it's about cheat its

00:28:30,780 --> 00:28:35,760
about compiling here we see the compiler

00:28:33,450 --> 00:28:39,030
in action here we see that the compiler

00:28:35,760 --> 00:28:41,940
is just compiling down the HTML

00:28:39,030 --> 00:28:46,400
templates to chava script on startup so

00:28:41,940 --> 00:28:53,820
it is always a good idea to repeat such

00:28:46,400 --> 00:28:57,660
measurement perhaps we get a slightly

00:28:53,820 --> 00:29:00,600
better performance it won't beat that

00:28:57,660 --> 00:29:04,770
further but it could be slightly better

00:29:00,600 --> 00:29:07,710
the second time it's about seven seconds

00:29:04,770 --> 00:29:11,340
seventh and something 7.5 or something

00:29:07,710 --> 00:29:16,460
okay so much for the debug build let's

00:29:11,340 --> 00:29:16,460
start with the brought action built

00:29:22,400 --> 00:29:30,510
tough goes down let me double check here

00:29:26,250 --> 00:29:39,650
this is the production build and here we

00:29:30,510 --> 00:29:39,650
have the bird let's reload this

00:29:44,560 --> 00:29:55,010
No and let's have a look at this and we

00:29:51,110 --> 00:29:58,420
see we are ending up with four seconds

00:29:55,010 --> 00:29:58,420
so let's repeat this

00:30:08,170 --> 00:30:16,890
yeah now we are ending up with three 3.5

00:30:11,440 --> 00:30:21,850
seconds so as you see we managed to to

00:30:16,890 --> 00:30:24,790
save 50% of our startup time so I think

00:30:21,850 --> 00:30:27,010
my application is fetching some metadata

00:30:24,790 --> 00:30:29,470
from the web and as my internet

00:30:27,010 --> 00:30:32,020
connection isn't the best here this also

00:30:29,470 --> 00:30:34,900
takes some seconds when we look at the

00:30:32,020 --> 00:30:37,570
network tab there should be a call to a

00:30:34,900 --> 00:30:43,240
discovery document somewhere yeah here

00:30:37,570 --> 00:30:45,190
they open ID configuration okay so much

00:30:43,240 --> 00:30:48,400
for this so I think that shows that

00:30:45,190 --> 00:30:51,460
everything of us should use ahead of

00:30:48,400 --> 00:30:55,360
time compilation in production and that

00:30:51,460 --> 00:30:57,670
also shows why cheats compilation is not

00:30:55,360 --> 00:31:00,100
allowed at Google they have to go with a

00:30:57,670 --> 00:31:10,390
OT there there was some Corrections on

00:31:00,100 --> 00:31:12,880
there you don't have to do it on your

00:31:10,390 --> 00:31:17,200
own they are using that back currently

00:31:12,880 --> 00:31:21,070
and that works since that back since

00:31:17,200 --> 00:31:26,620
version 2 is doing tree shaking and it

00:31:21,070 --> 00:31:29,170
gets better and better if it but the

00:31:26,620 --> 00:31:32,410
question is a good one because I have a

00:31:29,170 --> 00:31:36,010
nice information for you when you are

00:31:32,410 --> 00:31:37,900
interested into tree shaking when it

00:31:36,010 --> 00:31:41,110
comes to tree shaking there are some

00:31:37,900 --> 00:31:43,780
challenges and the biggest challenge is

00:31:41,110 --> 00:31:46,420
that most reshaping tools are quite

00:31:43,780 --> 00:31:48,820
conservative that means that they are

00:31:46,420 --> 00:31:53,290
just removing codes when they are sure

00:31:48,820 --> 00:31:59,460
for 100% cos they don't want to break

00:31:53,290 --> 00:32:03,010
your application of course and the not

00:31:59,460 --> 00:32:06,610
nice part is that very often they aren't

00:32:03,010 --> 00:32:09,880
sure so that means that tree shaking is

00:32:06,610 --> 00:32:12,460
nowadays not as good as it could be the

00:32:09,880 --> 00:32:15,310
tree shaking tools have a hard time to

00:32:12,460 --> 00:32:17,530
find out what really can be thrown out

00:32:15,310 --> 00:32:20,200
of the bundle but there is a good

00:32:17,530 --> 00:32:22,029
message for this the angular team worked

00:32:20,200 --> 00:32:24,489
on something that is called too

00:32:22,029 --> 00:32:27,249
Angola built optimism and this angle

00:32:24,489 --> 00:32:30,460
appealed optimizer rewrites the compiled

00:32:27,249 --> 00:32:33,519
code it turns out that it just needs

00:32:30,460 --> 00:32:37,269
some tiny modifications with the

00:32:33,519 --> 00:32:39,729
compiled code to make the code more tree

00:32:37,269 --> 00:32:42,940
shakable to help those tree shaking

00:32:39,729 --> 00:32:46,090
tools to find out which code is needed

00:32:42,940 --> 00:32:50,409
and which code isn't and this is

00:32:46,090 --> 00:32:54,039
currently in beta and experimental but I

00:32:50,409 --> 00:32:56,289
hope that it will land in the CLI soon

00:32:54,039 --> 00:32:59,229
when you look at the current beta

00:32:56,289 --> 00:33:03,159
version of the CLI you can try it out

00:32:59,229 --> 00:33:07,749
nowadays and I have played around with

00:33:03,159 --> 00:33:10,419
this I did some experiments and I found

00:33:07,749 --> 00:33:13,029
out that these results are possible when

00:33:10,419 --> 00:33:15,309
you look at this slide I think you see

00:33:13,029 --> 00:33:20,200
what's there potential of this build

00:33:15,309 --> 00:33:22,330
optimizer of course the gains differ

00:33:20,200 --> 00:33:24,399
from brought check to brought checked

00:33:22,330 --> 00:33:26,830
from libraries to libraries from

00:33:24,399 --> 00:33:30,039
packages you have downloaded to packages

00:33:26,830 --> 00:33:34,960
but as a rule of thumb pukin can say

00:33:30,039 --> 00:33:39,519
about a optimization of 50% is possible

00:33:34,960 --> 00:33:43,149
I have found this number out with

00:33:39,519 --> 00:33:44,830
several scenarios so as we see tree

00:33:43,149 --> 00:33:47,710
shaking is a huge deal

00:33:44,830 --> 00:33:50,559
we just needs to help the tree shaking

00:33:47,710 --> 00:33:53,859
tools to find out what can be removed

00:33:50,559 --> 00:33:56,769
more easy when you want to read more

00:33:53,859 --> 00:33:59,379
about this when you want to find out why

00:33:56,769 --> 00:34:02,109
those modifications help the tree

00:33:59,379 --> 00:34:04,479
shaking tools just check out my blog I

00:34:02,109 --> 00:34:06,909
have written two blog posts about this

00:34:04,479 --> 00:34:09,609
the first one is how to use it and the

00:34:06,909 --> 00:34:12,029
second one is about what it does beyond

00:34:09,609 --> 00:34:12,029
stickers

00:34:12,210 --> 00:34:20,260
okay so let's go to the next topic the

00:34:17,770 --> 00:34:24,339
next topic is about caching with service

00:34:20,260 --> 00:34:27,760
workers and first of all we have to talk

00:34:24,339 --> 00:34:30,190
about what service workers are and the

00:34:27,760 --> 00:34:33,490
answer is service workers are just

00:34:30,190 --> 00:34:35,020
background tasks within your browser you

00:34:33,490 --> 00:34:38,679
can compare them

00:34:35,020 --> 00:34:41,230
to a linux demon or to a Windows service

00:34:38,679 --> 00:34:44,350
but as mentioned it runs within your

00:34:41,230 --> 00:34:48,159
browser and it is installed by an web

00:34:44,350 --> 00:34:51,010
application and the browser can activate

00:34:48,159 --> 00:34:53,710
and deactivate those background tasks

00:34:51,010 --> 00:34:58,510
on-demand what has this to do with

00:34:53,710 --> 00:35:02,230
performance well one exercise one task

00:34:58,510 --> 00:35:04,180
they can do is caching and for this they

00:35:02,230 --> 00:35:05,170
can do something that sounds quite

00:35:04,180 --> 00:35:08,290
interesting

00:35:05,170 --> 00:35:11,260
they can intercept every request of your

00:35:08,290 --> 00:35:13,810
website and then after intercepting

00:35:11,260 --> 00:35:17,440
those requests they can decide how to

00:35:13,810 --> 00:35:19,990
respond to this request for instance

00:35:17,440 --> 00:35:23,320
they can respond with the cache which

00:35:19,990 --> 00:35:27,010
can be quite fast or they can respond by

00:35:23,320 --> 00:35:31,050
using the network by going out to the

00:35:27,010 --> 00:35:34,150
network and by fetching fresh data an

00:35:31,050 --> 00:35:36,910
important thing about this is that there

00:35:34,150 --> 00:35:40,330
is the same origin policy in place that

00:35:36,910 --> 00:35:44,020
means that a service worker installs by

00:35:40,330 --> 00:35:47,020
the domain a cannot intercept requests

00:35:44,020 --> 00:35:49,750
for the domain B otherwise that would be

00:35:47,020 --> 00:35:54,040
quite dangerous that would allow for

00:35:49,750 --> 00:35:56,370
security attacks and because we can

00:35:54,040 --> 00:35:59,770
write the service worker as a JavaScript

00:35:56,370 --> 00:36:02,040
we can implement some interesting

00:35:59,770 --> 00:36:05,440
caching patterns that haven't been

00:36:02,040 --> 00:36:08,890
possible in the past caching patterns

00:36:05,440 --> 00:36:12,220
like cash only which means the script

00:36:08,890 --> 00:36:15,490
just takes the cache or network only

00:36:12,220 --> 00:36:18,070
which means this grip just takes fresh

00:36:15,490 --> 00:36:20,800
data from the network we can also

00:36:18,070 --> 00:36:23,080
implement something like dry cache first

00:36:20,800 --> 00:36:26,110
and when nothing is there used the

00:36:23,080 --> 00:36:28,510
network as well as try Network first and

00:36:26,110 --> 00:36:33,310
when the network isn't available or is

00:36:28,510 --> 00:36:36,340
quite slow then take the cash and as

00:36:33,310 --> 00:36:39,400
mentioned you can control this caching

00:36:36,340 --> 00:36:45,210
balance cause the source code of this

00:36:39,400 --> 00:36:45,210
service worker is up to you using

00:36:47,910 --> 00:36:53,460
it's partly true

00:36:50,770 --> 00:36:56,220
currently there are free browsers and

00:36:53,460 --> 00:36:59,800
since some weeks we know that

00:36:56,220 --> 00:37:02,920
serviceworker will land in h quite soon

00:36:59,800 --> 00:37:05,530
and also so far results that they will

00:37:02,920 --> 00:37:08,260
have serviceworkers they announced it

00:37:05,530 --> 00:37:11,730
some weeks ago that was a really good

00:37:08,260 --> 00:37:13,720
announcement for everyone who is using

00:37:11,730 --> 00:37:15,790
serviceworkers or progressive web

00:37:13,720 --> 00:37:18,570
applications progressive web

00:37:15,790 --> 00:37:22,030
applications is this umbrella term and

00:37:18,570 --> 00:37:36,010
serviceworker is the central point of

00:37:22,030 --> 00:37:38,080
this progressive web apps that can be a

00:37:36,010 --> 00:37:42,280
good idea and it could be another

00:37:38,080 --> 00:37:45,910
caching padania you can also try to

00:37:42,280 --> 00:37:49,000
raise conditions and take the results

00:37:45,910 --> 00:37:50,950
that is the faster one and anyway when

00:37:49,000 --> 00:37:57,490
it comes back from the network you can

00:37:50,950 --> 00:38:00,760
cache it using service workers directly

00:37:57,490 --> 00:38:05,080
is a bit difficult because there is this

00:38:00,760 --> 00:38:09,940
low-level api for them that isn't much

00:38:05,080 --> 00:38:13,060
of fun but fortunately there are some

00:38:09,940 --> 00:38:15,910
high level api's abstracting service

00:38:13,060 --> 00:38:19,720
workers and one of those high level API

00:38:15,910 --> 00:38:22,720
is work box it's quite new it's directly

00:38:19,720 --> 00:38:26,500
from Google or at least from some guys

00:38:22,720 --> 00:38:29,940
who work at Google and it allows you to

00:38:26,500 --> 00:38:33,130
write service work in a very easy way

00:38:29,940 --> 00:38:35,310
here I have the source code for a simple

00:38:33,130 --> 00:38:38,080
service worker that is doing caching the

00:38:35,310 --> 00:38:41,320
service worker is importing work box

00:38:38,080 --> 00:38:44,020
then I'm instantiating my Rock box

00:38:41,320 --> 00:38:46,360
Service Worker and then I'm crapping do

00:38:44,020 --> 00:38:48,970
caching strategies the network for

00:38:46,360 --> 00:38:52,060
threats strategy and the cache first

00:38:48,970 --> 00:38:55,000
strategy and then I'm setting up two

00:38:52,060 --> 00:38:58,750
routes the first route is for angular at

00:38:55,000 --> 00:39:01,869
E where my Web API runs

00:38:58,750 --> 00:39:04,060
here I'm using Network first because I

00:39:01,869 --> 00:39:08,109
want to have fresh data and I'm

00:39:04,060 --> 00:39:10,780
accessing my Web API and the second

00:39:08,109 --> 00:39:13,180
route is for their rest here I'm just

00:39:10,780 --> 00:39:16,510
using the regular expression points

00:39:13,180 --> 00:39:19,630
which means everything and here I'm

00:39:16,510 --> 00:39:24,790
using the cache first strategy so that

00:39:19,630 --> 00:39:28,800
means everything but my butt calls to my

00:39:24,790 --> 00:39:31,540
Web API are processed with cash first

00:39:28,800 --> 00:39:33,940
after this I just have to load this

00:39:31,540 --> 00:39:37,570
serviceworker into my application and

00:39:33,940 --> 00:39:40,900
then I get their performance their

00:39:37,570 --> 00:39:45,310
performance gains of caching let's have

00:39:40,900 --> 00:39:48,670
a demonstration for this first of all

00:39:45,310 --> 00:39:53,760
let's have a look at this example here

00:39:48,670 --> 00:39:57,369
that is not using service workers and

00:39:53,760 --> 00:40:04,920
here I'm just simulating a slow Network

00:39:57,369 --> 00:40:11,280
slow for eg and here I'm reloading this

00:40:04,920 --> 00:40:14,470
and as we see free Qi or slow Fritsche

00:40:11,280 --> 00:40:17,740
isn't a fast thing you need a bit of

00:40:14,470 --> 00:40:23,170
patience when you are using a slow for

00:40:17,740 --> 00:40:26,410
Ichi connection it took about three dot

00:40:23,170 --> 00:40:30,070
sixty five seconds until that ohm

00:40:26,410 --> 00:40:35,310
content loaded and overall time it took

00:40:30,070 --> 00:40:35,310
was seven seconds so let's retry this

00:40:38,099 --> 00:40:46,010
now it took a bit longer

00:40:41,930 --> 00:40:57,800
so perhaps you can remember these

00:40:46,010 --> 00:41:00,910
numbers or let's just do a screenshot so

00:40:57,800 --> 00:41:06,580
this is screenshot for poor-man's and

00:41:00,910 --> 00:41:06,580
let's switch to our serviceworker build

00:41:11,080 --> 00:41:15,250
the application you started

00:41:21,670 --> 00:41:33,549
let's reload the application and let's

00:41:28,660 --> 00:41:36,760
have a look to our application tap here

00:41:33,549 --> 00:41:39,549
and here we see that a service work is

00:41:36,760 --> 00:41:41,140
running the service worker with the IDE

00:41:39,549 --> 00:41:45,670
for for free free

00:41:41,140 --> 00:41:53,799
okay so let's simulate a slow network

00:41:45,670 --> 00:41:55,950
connection it's low for eg and let's

00:41:53,799 --> 00:42:03,910
reload this

00:41:55,950 --> 00:42:07,990
no it wasn't much fastest a true so that

00:42:03,910 --> 00:42:12,099
somehow a pity because it should be

00:42:07,990 --> 00:42:12,700
faster now as we are using service

00:42:12,099 --> 00:42:17,740
workers

00:42:12,700 --> 00:42:22,329
let's go offline it should also work

00:42:17,740 --> 00:42:25,599
when we aren't connected to the web for

00:42:22,329 --> 00:42:27,519
some reason it really takes also free

00:42:25,599 --> 00:42:30,730
second as mentioned it it should be

00:42:27,519 --> 00:42:33,640
faster now but I am offline now you are

00:42:30,730 --> 00:42:37,089
seeing that I am indeed cashing that I'm

00:42:33,640 --> 00:42:40,049
indeed using my cash let's try it again

00:42:37,089 --> 00:42:40,049
with Cleo cash

00:42:45,500 --> 00:42:48,570
[Music]

00:42:49,240 --> 00:42:54,880
okay for some reason it isn't becoming

00:42:52,660 --> 00:42:58,420
faster but it should but a very nice

00:42:54,880 --> 00:43:04,360
aspect of this is let's just quit our

00:42:58,420 --> 00:43:08,470
server and when we reload our

00:43:04,360 --> 00:43:11,080
application we see that everything still

00:43:08,470 --> 00:43:13,450
works cause as mentioned we are using

00:43:11,080 --> 00:43:17,950
our cache that is controlled by the

00:43:13,450 --> 00:43:25,900
application okay interesting

00:43:17,950 --> 00:43:27,820
so much for service workers so when I've

00:43:25,900 --> 00:43:31,660
prepared for this there was really a

00:43:27,820 --> 00:43:34,480
performance gain no idea by

00:43:31,660 --> 00:43:36,850
there isn't a game now okay let's come

00:43:34,480 --> 00:43:40,840
to a last topic let's talk about

00:43:36,850 --> 00:43:43,270
server-side rendering perhaps you are

00:43:40,840 --> 00:43:45,990
wondering why we need server-side

00:43:43,270 --> 00:43:48,790
rendering because now we have

00:43:45,990 --> 00:43:51,940
client-side frameworks we have angular

00:43:48,790 --> 00:43:55,420
that runs within the browser so by 2 we

00:43:51,940 --> 00:43:57,520
have to go back to the HS of PHP and so

00:43:55,420 --> 00:44:00,430
on and to two server-side rendering well

00:43:57,520 --> 00:44:04,290
it's all about pre-rendering the first

00:44:00,430 --> 00:44:08,820
page of your application you want to

00:44:04,290 --> 00:44:13,480
deliver it more fast to the user and

00:44:08,820 --> 00:44:16,450
this is about startup performance the

00:44:13,480 --> 00:44:19,270
use of things he sees it's all about

00:44:16,450 --> 00:44:22,420
displaying the first page in a faster

00:44:19,270 --> 00:44:25,660
way and this is especially important for

00:44:22,420 --> 00:44:28,180
consumer apps course consumers and

00:44:25,660 --> 00:44:30,580
patients when they have to wait a bit

00:44:28,180 --> 00:44:33,070
longer they are moving to the next

00:44:30,580 --> 00:44:36,220
competitor there are some nice

00:44:33,070 --> 00:44:41,950
statistics for instance when you have a

00:44:36,220 --> 00:44:44,650
delay at Amazon for just one I think one

00:44:41,950 --> 00:44:48,100
or 100 milliseconds I think it was 100

00:44:44,650 --> 00:44:52,240
milliseconds then the cross amount goes

00:44:48,100 --> 00:44:54,369
down about 1 percent and 1 percent of

00:44:52,240 --> 00:44:58,359
the gross amount of Amazon is a huge

00:44:54,369 --> 00:45:01,660
thing I think so you see the first

00:44:58,359 --> 00:45:02,740
impression startup performance or at

00:45:01,660 --> 00:45:05,590
least their Percy

00:45:02,740 --> 00:45:08,830
startup performance is important when it

00:45:05,590 --> 00:45:12,310
comes to customer applications angola in

00:45:08,830 --> 00:45:16,810
version 4 comes with a baked in support

00:45:12,310 --> 00:45:19,060
for server-side rendering and for this

00:45:16,810 --> 00:45:22,690
it comes up with this method here it is

00:45:19,060 --> 00:45:25,450
called random module factory and random

00:45:22,690 --> 00:45:28,480
module factory just gets the model

00:45:25,450 --> 00:45:31,390
factory of your routes model the model

00:45:28,480 --> 00:45:34,900
factory is what the AOD compiler

00:45:31,390 --> 00:45:37,390
compiles out of your model file you are

00:45:34,900 --> 00:45:40,600
writing and you have to pass the

00:45:37,390 --> 00:45:44,500
contents of your index file the contents

00:45:40,600 --> 00:45:47,080
of your index DB of your index.html not

00:45:44,500 --> 00:45:50,710
index DB and of course you have to pass

00:45:47,080 --> 00:45:53,320
in your URL and after this this method

00:45:50,710 --> 00:45:56,740
is just starting up angular it is

00:45:53,320 --> 00:45:59,080
rendering the page in question the

00:45:56,740 --> 00:46:02,140
routing question and then you get back

00:45:59,080 --> 00:46:04,540
the whole source codes the HTML code for

00:46:02,140 --> 00:46:07,900
this pre-rendered page within this 10

00:46:04,540 --> 00:46:10,810
function so this is leveraging promises

00:46:07,900 --> 00:46:13,420
as you might have seen and now it's up

00:46:10,810 --> 00:46:17,170
to you what to do with this string you

00:46:13,420 --> 00:46:20,109
could save it into an HTML file or you

00:46:17,170 --> 00:46:23,500
can just wrap a server process around it

00:46:20,109 --> 00:46:26,980
and deliver it out to the user and when

00:46:23,500 --> 00:46:30,070
you do the later one then you can of

00:46:26,980 --> 00:46:32,619
course implement server-side rendering

00:46:30,070 --> 00:46:34,960
with this strategy to speed up their

00:46:32,619 --> 00:46:38,890
perceived startup performance of the

00:46:34,960 --> 00:46:49,330
first page also for this I have prepared

00:46:38,890 --> 00:46:56,520
and sample so let's switch to my sample

00:46:49,330 --> 00:46:56,520
that is using server-side rendering

00:46:58,860 --> 00:47:07,360
let's shorten the prompt let's go to the

00:47:03,580 --> 00:47:13,300
distribution directory and here I have

00:47:07,360 --> 00:47:15,520
just prepared a main server bundle which

00:47:13,300 --> 00:47:16,150
has been compiled for server-side

00:47:15,520 --> 00:47:18,940
rendering

00:47:16,150 --> 00:47:21,790
I've also wrapped a server-side node

00:47:18,940 --> 00:47:26,740
process around this which is calling the

00:47:21,790 --> 00:47:33,550
method we've seen and now let's have a

00:47:26,740 --> 00:47:36,340
look to localhost 80,000 oh 8,000 yeah

00:47:33,550 --> 00:47:41,290
and perhaps you have seen for some

00:47:36,340 --> 00:47:45,270
seconds we saw their bird server let's

00:47:41,290 --> 00:47:50,130
test this with a slow network connection

00:47:45,270 --> 00:47:50,130
for instance with slow for eg

00:47:55,660 --> 00:48:04,670
it takes some time sometimes sometimes

00:48:02,720 --> 00:48:07,280
some time we see the word server on the

00:48:04,670 --> 00:48:09,980
left this is the result of the

00:48:07,280 --> 00:48:13,069
server-side pre-rendering and after some

00:48:09,980 --> 00:48:15,829
seconds after the Chava script code has

00:48:13,069 --> 00:48:19,190
been downloaded executed and so on

00:48:15,829 --> 00:48:20,960
Angola kicks in on the client-side so

00:48:19,190 --> 00:48:23,359
what you've seen here is what

00:48:20,960 --> 00:48:27,740
server-side rendering is about it is

00:48:23,359 --> 00:48:30,170
just about bridging this gap between the

00:48:27,740 --> 00:48:32,869
time when the page arrives in the

00:48:30,170 --> 00:48:35,329
browser and the time when Angola kicks

00:48:32,869 --> 00:48:39,920
in when the application gets interactive

00:48:35,329 --> 00:48:42,349
and of course this is a positive thing

00:48:39,920 --> 00:48:45,710
for the perceived performance of the

00:48:42,349 --> 00:48:49,010
user I'm really emphasizing the word

00:48:45,710 --> 00:48:52,940
perceived cuz the application isn't

00:48:49,010 --> 00:48:55,400
getting interactive more quick it is

00:48:52,940 --> 00:49:01,819
just there it is just displayed in a

00:48:55,400 --> 00:49:06,910
more fast way is it's also important

00:49:01,819 --> 00:49:11,150
with IOT both addresses different things

00:49:06,910 --> 00:49:13,490
cause in both case when using a ot or

00:49:11,150 --> 00:49:16,190
not you have to download of course the

00:49:13,490 --> 00:49:18,680
JavaScript bundles you have to execute

00:49:16,190 --> 00:49:20,270
the JavaScript bundles perhaps the

00:49:18,680 --> 00:49:23,270
JavaScript bundles are fetching

00:49:20,270 --> 00:49:25,309
additional data from the server angola

00:49:23,270 --> 00:49:28,780
has to kick in angola has to do

00:49:25,309 --> 00:49:32,390
client-side rendering so this is also

00:49:28,780 --> 00:49:34,250
important when it comes to IOT for a

00:49:32,390 --> 00:49:36,430
consumer application you would combine

00:49:34,250 --> 00:49:48,880
of course both it would combine

00:49:36,430 --> 00:49:53,150
server-side rendering with iot yeah with

00:49:48,880 --> 00:49:55,510
lazy loading yeah it absolutely works

00:49:53,150 --> 00:49:55,510
together

00:49:55,640 --> 00:50:15,680
loaded nested paths in that way that's

00:50:01,190 --> 00:50:18,290
true is it possible to do everything on

00:50:15,680 --> 00:50:23,750
server said no this isn't a goal of this

00:50:18,290 --> 00:50:27,080
implementation the the goal is just to

00:50:23,750 --> 00:50:29,990
bridge the gap of course you can do some

00:50:27,080 --> 00:50:33,290
things without JavaScript here for

00:50:29,990 --> 00:50:35,660
instance navigating from menu item to

00:50:33,290 --> 00:50:37,850
menu item would work without JavaScript

00:50:35,660 --> 00:50:40,820
as everything is also server-side

00:50:37,850 --> 00:50:43,340
rendered but things like working with

00:50:40,820 --> 00:50:45,770
forms or other things working with

00:50:43,340 --> 00:50:47,770
drop-down fields and so on isn't

00:50:45,770 --> 00:50:50,960
supported when you don't have JavaScript

00:50:47,770 --> 00:50:54,290
so the main goal of this is just

00:50:50,960 --> 00:50:58,880
performance for consumer apps saying

00:50:54,290 --> 00:51:03,650
this I wouldn't use server-side

00:50:58,880 --> 00:51:06,680
rendering for business apps because it

00:51:03,650 --> 00:51:09,410
is also bringing some additional

00:51:06,680 --> 00:51:11,870
complexity into plate and because of

00:51:09,410 --> 00:51:25,690
this I just would use server side

00:51:11,870 --> 00:51:32,150
rendering when I really need it yeah

00:51:25,690 --> 00:51:35,750
yeah yeah that's a good point when you

00:51:32,150 --> 00:51:38,660
have a business application that is

00:51:35,750 --> 00:51:40,280
publicly available and where you have

00:51:38,660 --> 00:51:42,890
all these things like see Odin

00:51:40,280 --> 00:51:45,620
server-side rendering is an important

00:51:42,890 --> 00:51:47,780
thing when it comes to internet

00:51:45,620 --> 00:51:50,510
applications behind the firewall stuff

00:51:47,780 --> 00:51:51,980
then it just increases the complexity

00:51:50,510 --> 00:51:54,250
yeah good point

00:51:51,980 --> 00:51:54,250
thank you

00:51:58,579 --> 00:52:05,890
you need some JavaScript back-end

00:52:02,029 --> 00:52:10,009
process which calls note chess in DubLi

00:52:05,890 --> 00:52:12,410
but there are also wrappers for instance

00:52:10,009 --> 00:52:23,720
currently there is a wrapper for net who

00:52:12,410 --> 00:52:27,650
is doing dotnet okay yeah yeah it is

00:52:23,720 --> 00:52:29,390
using asp.net core and they are they are

00:52:27,650 --> 00:52:32,480
using something that's called angular

00:52:29,390 --> 00:52:36,009
services and what does angular services

00:52:32,480 --> 00:52:40,539
- it is starting a JavaScript process

00:52:36,009 --> 00:52:44,089
nodes process within asp.net to just

00:52:40,539 --> 00:52:46,759
start angular yeah

00:52:44,089 --> 00:52:50,779
it's that's a solution you can also go

00:52:46,759 --> 00:52:55,069
with both with an asp.net back and/or a

00:52:50,779 --> 00:52:58,250
topic and or a PHP backends and you can

00:52:55,069 --> 00:53:02,269
use in addition to this and nodes back

00:52:58,250 --> 00:53:04,789
and just for pre-rendering so no one

00:53:02,269 --> 00:53:10,900
prevents you from just using two

00:53:04,789 --> 00:53:10,900
backends okay so much for this

00:53:16,930 --> 00:53:22,520
so there are also some challenges when

00:53:20,000 --> 00:53:24,200
it comes to server-side rendering one

00:53:22,520 --> 00:53:26,660
challenge is that you have other

00:53:24,200 --> 00:53:28,790
conditions on server side where have you

00:53:26,660 --> 00:53:32,210
seen it on server side there isn't a

00:53:28,790 --> 00:53:36,260
document object model of course and for

00:53:32,210 --> 00:53:38,270
this you have to take care a good but

00:53:36,260 --> 00:53:40,820
good workaround for this is to use

00:53:38,270 --> 00:53:44,120
separate services one for the server

00:53:40,820 --> 00:53:46,490
side and one for the client side you can

00:53:44,120 --> 00:53:49,700
also use the renderer which is a dome

00:53:46,490 --> 00:53:52,610
abstraction with in Angola the renderer

00:53:49,700 --> 00:53:56,210
does the right thing on both sides on

00:53:52,610 --> 00:53:58,460
cayenne side and on server side on guy

00:53:56,210 --> 00:54:00,710
inside it is leveraging the document

00:53:58,460 --> 00:54:02,960
object model that home and on server

00:54:00,710 --> 00:54:06,970
side it is just writing into a string

00:54:02,960 --> 00:54:10,520
and you have to take care of effort but

00:54:06,970 --> 00:54:14,120
vendor libraries cause those firt but

00:54:10,520 --> 00:54:17,720
vendor libraries very often use the dome

00:54:14,120 --> 00:54:20,810
directly or they are using jQuery which

00:54:17,720 --> 00:54:23,510
in turn is using the dome directly that

00:54:20,810 --> 00:54:27,950
won't necessarily work on server side

00:54:23,510 --> 00:54:30,680
but I have a good message for you with

00:54:27,950 --> 00:54:34,310
Angola 5 they are introducing a

00:54:30,680 --> 00:54:37,730
server-side dome simulation and this is

00:54:34,310 --> 00:54:41,180
simulating the dome at least badly on

00:54:37,730 --> 00:54:44,170
server side so the hope here is to make

00:54:41,180 --> 00:54:47,120
more firt butty

00:54:44,170 --> 00:54:50,450
libraries available with server-side

00:54:47,120 --> 00:54:53,360
rendering they can't of course simulate

00:54:50,450 --> 00:54:58,730
everything but the hope is to make just

00:54:53,360 --> 00:55:02,710
more possible on the server side ok so

00:54:58,730 --> 00:55:02,710
much for this but was there a question

00:55:08,130 --> 00:55:24,369
yeah template bindings works out of the

00:55:15,760 --> 00:55:27,940
box yeah Dom manipulation Orban services

00:55:24,369 --> 00:55:30,580
are accessing like say local storage or

00:55:27,940 --> 00:55:33,400
the window object or the location object

00:55:30,580 --> 00:55:35,980
and so on in this case it would be a

00:55:33,400 --> 00:55:38,020
good idea to have two implementations of

00:55:35,980 --> 00:55:41,710
your service one for the server side and

00:55:38,020 --> 00:55:44,670
one for the giant set are there other

00:55:41,710 --> 00:55:44,670
questions so far

00:55:46,859 --> 00:55:55,300
okay when you are interested in to the

00:55:51,910 --> 00:56:00,220
topic performance tuning then I have a

00:55:55,300 --> 00:56:04,359
nice link for you I have made a block a

00:56:00,220 --> 00:56:08,200
DP at medium a column at medium and this

00:56:04,359 --> 00:56:18,300
column is pointing to several of my real

00:56:08,200 --> 00:56:24,910
blog posts about performance tuning yeah

00:56:18,300 --> 00:56:27,730
let's try this out don't here we have

00:56:24,910 --> 00:56:32,290
some hyperlinks and perhaps when I say

00:56:27,730 --> 00:56:35,020
hey I want to see how pre-rendering

00:56:32,290 --> 00:56:37,390
works what I have to do what I have to

00:56:35,020 --> 00:56:40,359
configure when I want to do server-side

00:56:37,390 --> 00:56:43,570
rendering you'll find an article here as

00:56:40,359 --> 00:56:45,940
a matter of fact most of these things

00:56:43,570 --> 00:56:50,290
are quite easy but you have to configure

00:56:45,940 --> 00:56:53,020
a whole bunch of aspects and you can

00:56:50,290 --> 00:56:55,859
read about those things here within

00:56:53,020 --> 00:56:55,859
those articles

00:57:00,680 --> 00:57:06,750
so let's come to the conclusion as we've

00:57:04,440 --> 00:57:09,900
seen there are some quick wins there are

00:57:06,750 --> 00:57:12,660
some turnkey solutions for performance

00:57:09,900 --> 00:57:15,030
tuning like bundling like minification

00:57:12,660 --> 00:57:17,730
like the angle of production mode and

00:57:15,030 --> 00:57:21,390
the good message is the angle of SIL is

00:57:17,730 --> 00:57:23,730
doing for this then there is something

00:57:21,390 --> 00:57:25,950
like lazy loading and pre loading which

00:57:23,730 --> 00:57:29,340
allows you to improve the staudte

00:57:25,950 --> 00:57:32,220
performance there is something like a ot

00:57:29,340 --> 00:57:35,340
and tree-shaking which also allows you

00:57:32,220 --> 00:57:37,880
to increase the starter performance and

00:57:35,340 --> 00:57:40,380
in turn it is shrinking your bundles

00:57:37,880 --> 00:57:44,060
there is something like caching the

00:57:40,380 --> 00:57:48,950
service workers which should in theory

00:57:44,060 --> 00:57:51,870
also haha in boost your data performance

00:57:48,950 --> 00:57:55,050
there is something like on bush with

00:57:51,870 --> 00:57:58,110
immutables and observables which boosts

00:57:55,050 --> 00:58:01,140
your data binding performance it is just

00:57:58,110 --> 00:58:03,750
necessary when you have to do change

00:58:01,140 --> 00:58:05,880
tracking on a regular basis for instance

00:58:03,750 --> 00:58:08,580
when you are triggering the change

00:58:05,880 --> 00:58:12,000
detection procedure within a mousemove

00:58:08,580 --> 00:58:15,390
event and for consumer apps I would

00:58:12,000 --> 00:58:17,910
recommend server-side rendering so

00:58:15,390 --> 00:58:20,370
that's all here you have my contact data

00:58:17,910 --> 00:58:22,710
when you have further questions just

00:58:20,370 --> 00:58:26,160
write me an email or just send via

00:58:22,710 --> 00:58:29,490
message on Twitter and of course you

00:58:26,160 --> 00:58:32,820
will find all my material between my

00:58:29,490 --> 00:58:37,260
block in some minutes and then you can

00:58:32,820 --> 00:58:40,230
try out the examples for instance also

00:58:37,260 --> 00:58:43,140
the example with the serviceworker

00:58:40,230 --> 00:58:43,800
it should as mentioned bring a better

00:58:43,140 --> 00:58:45,630
performance

00:58:43,800 --> 00:58:48,120
perhaps you try it out and you tell me

00:58:45,630 --> 00:58:48,470
so thank you for this and have a nice

00:58:48,120 --> 00:58:52,820
evening

00:58:48,470 --> 00:58:52,820

YouTube URL: https://www.youtube.com/watch?v=_MNDoDO4lv4


