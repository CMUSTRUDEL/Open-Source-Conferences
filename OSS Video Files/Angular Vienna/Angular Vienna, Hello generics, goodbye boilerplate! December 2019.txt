Title: Angular Vienna, Hello generics, goodbye boilerplate! December 2019
Publication date: 2019-12-13
Playlist: Angular Vienna
Description: 
	Talk by Miroslav Jonas, 



Having state management in your application helps to organize your code more efficiently and reason about it more easily. But it comes with a high price - the repetitive annoying boilerplate. Not cool!

But there is a solution! By using typescript generics in a smart way we can get rid of the most of this boilerplate. And why stop at state management? Let's remove the clutter once and for all.
Captions: 
	00:00:00,030 --> 00:00:05,130
now this is a topic I was very

00:00:02,040 --> 00:00:06,899
passionate about and it happened in the

00:00:05,130 --> 00:00:09,929
past that I was passionate about some

00:00:06,899 --> 00:00:12,179
topics and then I shared it with people

00:00:09,929 --> 00:00:15,900
and realized actually not too many

00:00:12,179 --> 00:00:19,949
people share the same passion so if it's

00:00:15,900 --> 00:00:22,650
okay with you I'm gonna run by you some

00:00:19,949 --> 00:00:25,650
statements and if you agree with this

00:00:22,650 --> 00:00:30,300
statement just raise your hand or give

00:00:25,650 --> 00:00:32,130
me any other visual or audio cue so the

00:00:30,300 --> 00:00:36,090
first statement is that every developer

00:00:32,130 --> 00:00:38,190
loves the code so all of you who agree

00:00:36,090 --> 00:00:40,430
with this just raise your hand okay nice

00:00:38,190 --> 00:00:43,590
that's pretty much everyone

00:00:40,430 --> 00:00:45,899
now let's refine this statement a bit so

00:00:43,590 --> 00:00:48,989
let's say every developer likes to copy

00:00:45,899 --> 00:00:50,820
paste code right I mean why would you

00:00:48,989 --> 00:00:52,469
spend your mental energy trying to

00:00:50,820 --> 00:00:54,030
figure out some solution where you can

00:00:52,469 --> 00:00:59,129
just copy paste it from Stack Overflow

00:00:54,030 --> 00:01:02,160
or maybe just your old project right now

00:00:59,129 --> 00:01:03,619
let's refine this even more every

00:01:02,160 --> 00:01:07,049
developer loves to copy paste

00:01:03,619 --> 00:01:10,470
boilerplate code right

00:01:07,049 --> 00:01:15,060
no hands I guess we are on the same page

00:01:10,470 --> 00:01:18,119
then so boilerplate can be quite

00:01:15,060 --> 00:01:20,790
annoying now if you google for

00:01:18,119 --> 00:01:22,560
boilerplate you might find on google

00:01:20,790 --> 00:01:25,470
picture like this so there's some

00:01:22,560 --> 00:01:27,960
guerrilla going on and among these

00:01:25,470 --> 00:01:29,850
warriors you can see one specifically

00:01:27,960 --> 00:01:32,340
proud attending color by the name of

00:01:29,850 --> 00:01:35,310
boilerplate and here you can see him

00:01:32,340 --> 00:01:38,610
again in case you haven't realized the

00:01:35,310 --> 00:01:40,409
boilerplate is the guy with a helmet now

00:01:38,610 --> 00:01:42,360
if you consult Wikipedia and pipe

00:01:40,409 --> 00:01:45,299
boilerplate code you get something like

00:01:42,360 --> 00:01:47,820
this boilerplate is section of code that

00:01:45,299 --> 00:01:50,939
have to be included in many places with

00:01:47,820 --> 00:01:53,310
little or no alteration and this is

00:01:50,939 --> 00:01:56,009
where the whole copy pasting comes into

00:01:53,310 --> 00:01:59,579
hand now recently I saw an article that

00:01:56,009 --> 00:02:02,310
claims that 90% of good code is

00:01:59,579 --> 00:02:05,759
boilerplate this sounds slightly

00:02:02,310 --> 00:02:08,399
controversial right how can code be good

00:02:05,759 --> 00:02:11,330
and at the same time Borla place kind of

00:02:08,399 --> 00:02:11,330
doesn't make sense right

00:02:11,900 --> 00:02:18,590
but if you think about it what makes a

00:02:15,170 --> 00:02:20,950
good code good that means you're

00:02:18,590 --> 00:02:24,440
probably sharing the common architecture

00:02:20,950 --> 00:02:27,620
within your application you're probably

00:02:24,440 --> 00:02:29,930
using the same style you're using the

00:02:27,620 --> 00:02:32,750
same constructs for the components for

00:02:29,930 --> 00:02:35,390
your services for our models and this

00:02:32,750 --> 00:02:37,430
inevitably means that you are doing a

00:02:35,390 --> 00:02:39,680
lot of stuff over and over again in your

00:02:37,430 --> 00:02:41,930
application which is actually

00:02:39,680 --> 00:02:45,230
boilerplate right copy pasting the same

00:02:41,930 --> 00:02:47,239
things so even if you don't agree with

00:02:45,230 --> 00:02:49,489
this number I definitely don't agree

00:02:47,239 --> 00:02:51,019
with it I think it's more fitting to

00:02:49,489 --> 00:02:55,160
maybe Java back-end and front-end

00:02:51,019 --> 00:02:57,980
development it's still a big number and

00:02:55,160 --> 00:03:02,569
it's still something that pressures us

00:02:57,980 --> 00:03:05,959
on daily basis so before I move on to

00:03:02,569 --> 00:03:08,090
the actual topic of the talk let me

00:03:05,959 --> 00:03:10,040
briefly introduce myself for those of

00:03:08,090 --> 00:03:13,129
you that don't know me my name is mera

00:03:10,040 --> 00:03:15,889
saaya nosh or mera shorter I'm working

00:03:13,129 --> 00:03:18,650
at 5g systems building some gaming

00:03:15,889 --> 00:03:20,660
solutions of the future I'm also one of

00:03:18,650 --> 00:03:23,889
the organizers of this meetup as you can

00:03:20,660 --> 00:03:27,169
see with the t-shirt I'm also organizer

00:03:23,889 --> 00:03:30,379
organizer of the energy is meetup

00:03:27,169 --> 00:03:32,660
together with David here and I'm also

00:03:30,379 --> 00:03:35,720
one of the cofounders of angular austria

00:03:32,660 --> 00:03:39,530
association if you want to say hi or

00:03:35,720 --> 00:03:41,329
just follow my tweets you can find me on

00:03:39,530 --> 00:03:46,579
most of the social networks using this

00:03:41,329 --> 00:03:49,190
handle Miroslav and it's exactly 5g

00:03:46,579 --> 00:03:52,879
systems where we have a lot of web

00:03:49,190 --> 00:03:54,859
applications and some of these web

00:03:52,879 --> 00:03:56,989
applications are big enterprise

00:03:54,859 --> 00:03:59,389
applications in some of these big

00:03:56,989 --> 00:04:02,540
enterprise applications shared the same

00:03:59,389 --> 00:04:05,209
technology in same framework and this of

00:04:02,540 --> 00:04:08,150
course means that a lot of the code gets

00:04:05,209 --> 00:04:12,019
duplicated between these solutions so

00:04:08,150 --> 00:04:14,690
what happens often is we come up with

00:04:12,019 --> 00:04:16,910
some cool thing how to do or how to

00:04:14,690 --> 00:04:19,820
solve certain challenge and then we

00:04:16,910 --> 00:04:21,320
simply copy the same approach to all

00:04:19,820 --> 00:04:23,670
other projects sharing the same

00:04:21,320 --> 00:04:27,330
technology all

00:04:23,670 --> 00:04:29,730
so we have a lot of features and lot of

00:04:27,330 --> 00:04:31,980
modules in the project and this also

00:04:29,730 --> 00:04:33,980
mean that a lot of these concepts is

00:04:31,980 --> 00:04:39,960
copy pasting from one place to another

00:04:33,980 --> 00:04:42,810
this can be quite painful now in order

00:04:39,960 --> 00:04:46,410
to handle our logic in the application

00:04:42,810 --> 00:04:49,530
bit nicer we of course as many other

00:04:46,410 --> 00:04:51,180
companies introduce state management and

00:04:49,530 --> 00:04:53,340
once we introduce state management we

00:04:51,180 --> 00:04:55,470
realized that boilerplate of yesterday

00:04:53,340 --> 00:04:57,540
was child fights today and state

00:04:55,470 --> 00:05:00,960
management brings the boilerplate to

00:04:57,540 --> 00:05:02,820
completely different level but state

00:05:00,960 --> 00:05:06,180
management is not that bad it of course

00:05:02,820 --> 00:05:09,150
gave us chance to reason more easily

00:05:06,180 --> 00:05:12,210
about our application state to debug

00:05:09,150 --> 00:05:14,700
more easily to know exactly at every

00:05:12,210 --> 00:05:21,450
point what our application does because

00:05:14,700 --> 00:05:23,850
every state or or every every view of

00:05:21,450 --> 00:05:26,610
the application is a result of the

00:05:23,850 --> 00:05:29,310
initial state and some steps that led to

00:05:26,610 --> 00:05:31,080
the current state now as some of you

00:05:29,310 --> 00:05:33,630
might not know how the state

00:05:31,080 --> 00:05:36,630
management's work I'm going to do just a

00:05:33,630 --> 00:05:39,210
quick 101 of what state management's

00:05:36,630 --> 00:05:42,390
look like so in a nutshell you have a

00:05:39,210 --> 00:05:45,030
store which has a state state is nothing

00:05:42,390 --> 00:05:46,860
but an object representing some

00:05:45,030 --> 00:05:50,400
properties of your application for

00:05:46,860 --> 00:05:53,370
example it can say whether the menu is

00:05:50,400 --> 00:05:56,610
open or not it can say what is the

00:05:53,370 --> 00:05:59,100
logged in user it can hold the

00:05:56,610 --> 00:06:02,700
information about some products that you

00:05:59,100 --> 00:06:04,620
want to show so just imagine what makes

00:06:02,700 --> 00:06:06,120
your application dynamic what are the

00:06:04,620 --> 00:06:09,150
things that change and this is usually

00:06:06,120 --> 00:06:12,450
the stuff that you keep in the state now

00:06:09,150 --> 00:06:15,630
state is then fed to the view we can

00:06:12,450 --> 00:06:19,830
feed it directly or we can use selectors

00:06:15,630 --> 00:06:21,780
as Michelle mentioned or with other with

00:06:19,830 --> 00:06:23,970
some some other libraries it can might

00:06:21,780 --> 00:06:26,790
have different name like getters but

00:06:23,970 --> 00:06:31,020
generally it means taking parts of the

00:06:26,790 --> 00:06:35,460
state and reacting in a view upon this

00:06:31,020 --> 00:06:37,070
these state parts now we need to be able

00:06:35,460 --> 00:06:39,530
somehow to change the state

00:06:37,070 --> 00:06:42,430
to leave it turn to different states so

00:06:39,530 --> 00:06:45,970
for this we use concept collections an

00:06:42,430 --> 00:06:49,550
action is nothing else but a vessel that

00:06:45,970 --> 00:06:52,550
carries the information to the state so

00:06:49,550 --> 00:06:55,160
what we usually do is we have this

00:06:52,550 --> 00:06:57,230
pipeline that carries all the actions to

00:06:55,160 --> 00:07:00,290
the state and we simply create a new

00:06:57,230 --> 00:07:02,360
action each action has a type and can

00:07:00,290 --> 00:07:05,240
have some payload for example if we want

00:07:02,360 --> 00:07:08,210
to load the products we can have we can

00:07:05,240 --> 00:07:13,490
say that my action type is load products

00:07:08,210 --> 00:07:14,930
and maybe my payload is some specific

00:07:13,490 --> 00:07:16,430
filter I want to apply so I don't want

00:07:14,930 --> 00:07:18,590
to fetch all the products I want to

00:07:16,430 --> 00:07:21,650
write just the products that have been

00:07:18,590 --> 00:07:25,730
added yesterday or that have serial code

00:07:21,650 --> 00:07:27,950
that matches some some pattern now these

00:07:25,730 --> 00:07:30,260
actions then trigger something called

00:07:27,950 --> 00:07:33,020
reducers or mutations in some other

00:07:30,260 --> 00:07:34,660
libraries when reducer is nothing but a

00:07:33,020 --> 00:07:37,820
function that takes two arguments

00:07:34,660 --> 00:07:41,600
current state and an action and produces

00:07:37,820 --> 00:07:44,240
a new state so it simply calculates the

00:07:41,600 --> 00:07:47,330
new state based on information and then

00:07:44,240 --> 00:07:49,060
reducer as a result sense this date back

00:07:47,330 --> 00:07:52,550
to the store and you have the full cycle

00:07:49,060 --> 00:07:54,800
you know store showing view view

00:07:52,550 --> 00:07:56,810
triggering the action action carrying

00:07:54,800 --> 00:07:59,270
the information to the reducer reducer

00:07:56,810 --> 00:08:02,060
calculating a new state and sending it

00:07:59,270 --> 00:08:05,060
back to the store now this whole flow is

00:08:02,060 --> 00:08:08,170
synchronous so what happens if we need

00:08:05,060 --> 00:08:11,000
to do something asynchronous such as

00:08:08,170 --> 00:08:14,060
fetching information from our back-end

00:08:11,000 --> 00:08:17,720
API so for this we use something called

00:08:14,060 --> 00:08:21,200
effects or in some other libraries you

00:08:17,720 --> 00:08:25,040
can call it sagas or thunks or even

00:08:21,200 --> 00:08:29,030
acing actions and what they do is they

00:08:25,040 --> 00:08:32,180
also in similar way like reducers react

00:08:29,030 --> 00:08:34,820
to the action and then they can do some

00:08:32,180 --> 00:08:37,220
asynchronous activities such as calling

00:08:34,820 --> 00:08:39,740
our back-end API ice getting the

00:08:37,220 --> 00:08:43,760
response and feeding it to another

00:08:39,740 --> 00:08:46,670
action and this action would then fall

00:08:43,760 --> 00:08:49,970
into the existing pipeline and might

00:08:46,670 --> 00:08:54,189
trigger reducer or might trigger a next

00:08:49,970 --> 00:08:57,110
effect now this is how the actions

00:08:54,189 --> 00:09:01,430
normally look like in the most popular

00:08:57,110 --> 00:09:03,740
library called MGR X you usually have a

00:09:01,430 --> 00:09:07,699
class that has a name for example

00:09:03,740 --> 00:09:11,120
product it implements action it has a

00:09:07,699 --> 00:09:13,670
read only type which is a string and

00:09:11,120 --> 00:09:17,899
then it might have a constructor with a

00:09:13,670 --> 00:09:19,850
public payload now since these strings

00:09:17,899 --> 00:09:23,360
have to be used all over the application

00:09:19,850 --> 00:09:25,970
the reducer distinguishes between

00:09:23,360 --> 00:09:29,029
actions based on the type also effect

00:09:25,970 --> 00:09:30,829
distinguishes between actions based on

00:09:29,029 --> 00:09:32,540
the type so this is some piece of

00:09:30,829 --> 00:09:35,870
information we carry along the

00:09:32,540 --> 00:09:38,060
application so it's advisable not to

00:09:35,870 --> 00:09:41,449
type it over and over because of course

00:09:38,060 --> 00:09:44,480
syntax errors are quite possible means

00:09:41,449 --> 00:09:46,819
that there are two common approaches we

00:09:44,480 --> 00:09:50,389
either keep it in a constant or in

00:09:46,819 --> 00:09:53,269
animal like you see on the screen so

00:09:50,389 --> 00:09:57,769
this is how our typical action look

00:09:53,269 --> 00:09:59,930
likes looks like now we might have a lot

00:09:57,769 --> 00:10:01,639
of actions on the screen you can see

00:09:59,930 --> 00:10:03,470
three different actions one is a lot

00:10:01,639 --> 00:10:06,920
product one is product loaded and the

00:10:03,470 --> 00:10:10,069
third one is product load field now it

00:10:06,920 --> 00:10:11,809
might not be clear initially by looking

00:10:10,069 --> 00:10:14,959
at this screen that there's a lot of

00:10:11,809 --> 00:10:16,730
boilerplate but let's highlight the

00:10:14,959 --> 00:10:20,360
things that are different between these

00:10:16,730 --> 00:10:22,610
three actions so I highlighted the stuff

00:10:20,360 --> 00:10:24,079
that same so as you can see the only

00:10:22,610 --> 00:10:28,579
thing that's different between these

00:10:24,079 --> 00:10:30,500
actions is the name the type the the

00:10:28,579 --> 00:10:33,490
type that represents the the string and

00:10:30,500 --> 00:10:35,930
the type of payload if you have any and

00:10:33,490 --> 00:10:39,259
this is of course causing a lot of

00:10:35,930 --> 00:10:41,290
boilerplate the team that's behind ng Rx

00:10:39,259 --> 00:10:44,089
realized this and they came up with

00:10:41,290 --> 00:10:46,009
construct code create action and then

00:10:44,089 --> 00:10:48,649
create reducer and create effect to

00:10:46,009 --> 00:10:52,430
simplify the code but at the same time

00:10:48,649 --> 00:10:54,230
while this was being developed us at 5g

00:10:52,430 --> 00:10:57,949
worked on our own solution using

00:10:54,230 --> 00:11:00,880
generics and this is what I'm going to

00:10:57,949 --> 00:11:05,050
be talking about how we solve this issue

00:11:00,880 --> 00:11:07,120
now generics is perhaps not that popular

00:11:05,050 --> 00:11:08,709
in front-end development because it came

00:11:07,120 --> 00:11:11,769
with typescript it doesn't exist in

00:11:08,709 --> 00:11:14,230
JavaScript but it's quite popular for

00:11:11,769 --> 00:11:18,519
the backend languages such as Java and

00:11:14,230 --> 00:11:21,160
c-sharp generics in general help you to

00:11:18,519 --> 00:11:24,190
create reusable constructs that can

00:11:21,160 --> 00:11:27,130
replace parts of your logic by simply

00:11:24,190 --> 00:11:28,899
having on the undefined or loosely

00:11:27,130 --> 00:11:30,970
defined types so what it means in

00:11:28,899 --> 00:11:33,730
general it means that you can create a

00:11:30,970 --> 00:11:35,769
construct that can do the same logic for

00:11:33,730 --> 00:11:38,130
different types so for example let's say

00:11:35,769 --> 00:11:41,829
we want to create a function that

00:11:38,130 --> 00:11:45,279
compares different items based on their

00:11:41,829 --> 00:11:48,370
serial code now this could be some

00:11:45,279 --> 00:11:53,079
laptops this could be some clothing

00:11:48,370 --> 00:11:55,029
items it could be even some abstract

00:11:53,079 --> 00:11:56,920
stuff the only thing that needs to be

00:11:55,029 --> 00:11:58,990
coming between these two you the same

00:11:56,920 --> 00:12:01,300
functionality is the existing of the

00:11:58,990 --> 00:12:03,399
serial code so you can simply create

00:12:01,300 --> 00:12:06,519
generic type and say that the only thing

00:12:03,399 --> 00:12:08,649
this type has to satisfy is to have a

00:12:06,519 --> 00:12:12,569
serial code and everything else is

00:12:08,649 --> 00:12:15,819
optional now let's see how we used

00:12:12,569 --> 00:12:19,149
generics to solve to simplify the

00:12:15,819 --> 00:12:21,970
actions so here you see how the action

00:12:19,149 --> 00:12:23,889
looked before below that you can see our

00:12:21,970 --> 00:12:27,939
generic abstract class called base

00:12:23,889 --> 00:12:29,949
action which since it implements action

00:12:27,939 --> 00:12:32,920
it has to set type to something so we

00:12:29,949 --> 00:12:34,389
simply set it to now because we won't be

00:12:32,920 --> 00:12:36,939
using it at this moment we're going to

00:12:34,389 --> 00:12:39,490
define it later and then we say that

00:12:36,939 --> 00:12:43,269
this base action has one generic type T

00:12:39,490 --> 00:12:47,110
and then we say that our constructor has

00:12:43,269 --> 00:12:49,750
one simple payload public argument type

00:12:47,110 --> 00:12:52,300
of T so the order you can see that load

00:12:49,750 --> 00:12:56,050
product now implements instead of action

00:12:52,300 --> 00:12:59,579
implements base action and it instead of

00:12:56,050 --> 00:13:03,339
this T send string this would mean that

00:12:59,579 --> 00:13:06,579
whenever we call this instead of the

00:13:03,339 --> 00:13:09,189
constructor public payload T it would

00:13:06,579 --> 00:13:12,610
under the hood create constructor which

00:13:09,189 --> 00:13:14,380
with public payload string now this

00:13:12,610 --> 00:13:18,220
original idea didn't

00:13:14,380 --> 00:13:19,780
came from me it it came from my solid

00:13:18,220 --> 00:13:25,290
Christian sitting in the first row you

00:13:19,780 --> 00:13:27,640
might know him from the me table and

00:13:25,290 --> 00:13:29,740
since we are building a lot of

00:13:27,640 --> 00:13:31,630
enterprise applications we have a lot of

00:13:29,740 --> 00:13:34,960
code applications and boilerplate is

00:13:31,630 --> 00:13:37,960
something we battle with every day so I

00:13:34,960 --> 00:13:41,470
thought okay if we did this for actions

00:13:37,960 --> 00:13:44,080
what else can we solve and we decided to

00:13:41,470 --> 00:13:47,110
take next thing directly into the

00:13:44,080 --> 00:13:47,710
hornet's nest the effects this is how

00:13:47,110 --> 00:13:51,130
typically

00:13:47,710 --> 00:13:53,650
effects look like in ng rx they have the

00:13:51,130 --> 00:13:57,370
create effect which listens to the

00:13:53,650 --> 00:13:59,740
pipeline of actions you filter out some

00:13:57,370 --> 00:14:02,290
specific action in this case we filter

00:13:59,740 --> 00:14:05,170
out load product action you can see we

00:14:02,290 --> 00:14:09,100
are passing this constant I put that we

00:14:05,170 --> 00:14:12,340
have defined then we are simply using

00:14:09,100 --> 00:14:15,910
map to pluck out the payload from the

00:14:12,340 --> 00:14:19,150
action and then we use the switch map to

00:14:15,910 --> 00:14:21,610
call our service to get products which

00:14:19,150 --> 00:14:24,010
is a synchronous call it will make a

00:14:21,610 --> 00:14:26,320
call to the backend it will fetch

00:14:24,010 --> 00:14:28,990
products for us based on based on a

00:14:26,320 --> 00:14:31,930
product ID it will return the response

00:14:28,990 --> 00:14:33,670
and then if the call was successful

00:14:31,930 --> 00:14:37,090
we're going to map this response to the

00:14:33,670 --> 00:14:39,100
product loaded otherwise if it fails

00:14:37,090 --> 00:14:42,940
we're gonna map it to product load field

00:14:39,100 --> 00:14:46,590
and pretty much all the effects that

00:14:42,940 --> 00:14:50,740
make some back-end code look like this

00:14:46,590 --> 00:14:53,590
also this effect has two parameters one

00:14:50,740 --> 00:14:55,420
is the actions the whole pipeline and

00:14:53,590 --> 00:14:57,340
the other one is usually the service

00:14:55,420 --> 00:14:59,520
that you want to use so usually per

00:14:57,340 --> 00:15:02,230
module you have a single service that

00:14:59,520 --> 00:15:07,030
handles all the API calls and this is

00:15:02,230 --> 00:15:09,100
how you write it now these are the only

00:15:07,030 --> 00:15:11,830
things that are different between

00:15:09,100 --> 00:15:16,180
actions what type of action we're

00:15:11,830 --> 00:15:19,090
listening to what is the actual action

00:15:16,180 --> 00:15:21,820
that we want to take what is the method

00:15:19,090 --> 00:15:23,710
from our service that we want to take if

00:15:21,820 --> 00:15:26,620
it's successful which action should I

00:15:23,710 --> 00:15:27,999
take if it fails which favored action

00:15:26,620 --> 00:15:31,499
should I fire

00:15:27,999 --> 00:15:37,599
and at the end the whole effect class

00:15:31,499 --> 00:15:40,239
points to one service now this is how we

00:15:37,599 --> 00:15:41,949
solve it right if you come back here so

00:15:40,239 --> 00:15:45,609
that these are the only things that are

00:15:41,949 --> 00:15:49,119
different so what if we could write it

00:15:45,609 --> 00:15:51,989
like this just put the stuff that's

00:15:49,119 --> 00:15:55,689
different and have everything else

00:15:51,989 --> 00:15:58,919
automatically generic for us so we came

00:15:55,689 --> 00:16:02,309
up with these constructs of helper

00:15:58,919 --> 00:16:05,259
effects or or effect helpers rather

00:16:02,309 --> 00:16:09,039
where we can now say we have a switch

00:16:05,259 --> 00:16:13,389
map effect so what it does it will take

00:16:09,039 --> 00:16:15,729
the load product type it will switch map

00:16:13,389 --> 00:16:17,769
it which would I take the payload it

00:16:15,729 --> 00:16:20,829
would switch map to get product method

00:16:17,769 --> 00:16:23,349
if it's successful it would code product

00:16:20,829 --> 00:16:27,459
loaded if it fails it will call product

00:16:23,349 --> 00:16:30,459
load failed and as you can see that our

00:16:27,459 --> 00:16:33,939
it extends the base effect base effect

00:16:30,459 --> 00:16:36,849
takes one generic parameter which is our

00:16:33,939 --> 00:16:40,569
service and we pass this service in the

00:16:36,849 --> 00:16:42,549
constructor now this is how this whole

00:16:40,569 --> 00:16:45,220
looks under the hood so you can see the

00:16:42,549 --> 00:16:49,389
base effect it has one generic parameter

00:16:45,220 --> 00:16:52,809
s and the same parameter or same type is

00:16:49,389 --> 00:16:55,599
then used within the constructor for the

00:16:52,809 --> 00:16:58,839
service we can then see the switch map

00:16:55,599 --> 00:17:01,029
effect that takes one parameter T it

00:16:58,839 --> 00:17:04,029
extends our base section that we defined

00:17:01,029 --> 00:17:07,209
earlier and it has action type which is

00:17:04,029 --> 00:17:10,000
string it has method which is key of s

00:17:07,209 --> 00:17:12,129
now this is quite important if you

00:17:10,000 --> 00:17:14,889
looked at this slide you probably

00:17:12,129 --> 00:17:17,799
realize ok there's a string so you could

00:17:14,889 --> 00:17:20,769
just easily make a typo well you cannot

00:17:17,799 --> 00:17:23,620
because by using key of s you're

00:17:20,769 --> 00:17:26,709
actually telling your transpiler

00:17:23,620 --> 00:17:28,870
that whatever is passed as a method has

00:17:26,709 --> 00:17:31,509
to actually be method on my service

00:17:28,870 --> 00:17:34,539
otherwise the transpiler will complain

00:17:31,509 --> 00:17:36,009
that this is not correct code and then

00:17:34,539 --> 00:17:38,590
you have to action success

00:17:36,009 --> 00:17:40,490
action infection and then the body of

00:17:38,590 --> 00:17:43,580
this method is

00:17:40,490 --> 00:17:46,670
actually just copied body from our

00:17:43,580 --> 00:17:49,850
original effect and this is how we

00:17:46,670 --> 00:17:52,610
solved some other issues as well so when

00:17:49,850 --> 00:17:54,770
you want to make some go to the back end

00:17:52,610 --> 00:17:56,300
that is post or puts or something that

00:17:54,770 --> 00:17:59,570
changes and that should be treated

00:17:56,300 --> 00:18:02,120
sequentially switch map probably

00:17:59,570 --> 00:18:04,429
wouldn't be the best case so you can use

00:18:02,120 --> 00:18:08,330
conquered map and for this we have also

00:18:04,429 --> 00:18:10,460
conquered map effect but this isn't the

00:18:08,330 --> 00:18:12,470
only thing for example whenever things

00:18:10,460 --> 00:18:14,179
fail we would like to inform the user

00:18:12,470 --> 00:18:16,150
about it and this is how we do it so we

00:18:14,179 --> 00:18:19,820
usually listen to the failed action

00:18:16,150 --> 00:18:24,380
again we take out a payload and then we

00:18:19,820 --> 00:18:27,110
fire at failure message and the way our

00:18:24,380 --> 00:18:29,559
applications usually operate is that we

00:18:27,110 --> 00:18:33,590
have one component that listens to this

00:18:29,559 --> 00:18:35,360
at failure messages and then shows this

00:18:33,590 --> 00:18:37,460
toaster messages every time error

00:18:35,360 --> 00:18:41,300
happens the same thing we have also for

00:18:37,460 --> 00:18:43,370
successful messages so with this effects

00:18:41,300 --> 00:18:46,250
we simply fire the messages whenever

00:18:43,370 --> 00:18:49,670
needed and again the only thing that's

00:18:46,250 --> 00:18:51,440
here different is which type of action

00:18:49,670 --> 00:18:54,320
we're listening to and what is the

00:18:51,440 --> 00:18:56,870
actual message we want to show so we

00:18:54,320 --> 00:19:02,600
could simply write it like this yeah

00:18:56,870 --> 00:19:06,140
amazing right so with this thing you can

00:19:02,600 --> 00:19:08,420
create generic methods that will serve

00:19:06,140 --> 00:19:10,040
your specific application this is how we

00:19:08,420 --> 00:19:12,770
use it in our application it doesn't

00:19:10,040 --> 00:19:14,929
have to map your architecture you could

00:19:12,770 --> 00:19:17,090
be using effects in a different way but

00:19:14,929 --> 00:19:19,040
by using generics I'm pretty sure you

00:19:17,090 --> 00:19:21,350
have a lot of duplication between your

00:19:19,040 --> 00:19:23,990
effects so you can just figure out

00:19:21,350 --> 00:19:27,740
what's common between your effects and

00:19:23,990 --> 00:19:30,280
create a generic wrapper around it now

00:19:27,740 --> 00:19:33,410
the next thing to solve was the reducer

00:19:30,280 --> 00:19:35,600
so this is how a typical reducer looked

00:19:33,410 --> 00:19:37,610
like you have some switch case as I

00:19:35,600 --> 00:19:40,300
mentioned it has two parameters current

00:19:37,610 --> 00:19:43,309
state action and produces new state

00:19:40,300 --> 00:19:45,860
usually had some switch case and then

00:19:43,309 --> 00:19:48,710
based on a type it will return different

00:19:45,860 --> 00:19:52,809
states now one thing we realized quite

00:19:48,710 --> 00:19:54,160
early is that there's also some sort of

00:19:52,809 --> 00:19:56,860
algorithm

00:19:54,160 --> 00:20:00,070
behind all of this so you could say that

00:19:56,860 --> 00:20:03,220
all our actions fell into three

00:20:00,070 --> 00:20:05,710
different groups first one was loading

00:20:03,220 --> 00:20:10,120
action that's when you fire an action to

00:20:05,710 --> 00:20:11,980
load certain data and we need fire an

00:20:10,120 --> 00:20:14,320
action to load certain data you usually

00:20:11,980 --> 00:20:17,140
want to set the flag loading to true

00:20:14,320 --> 00:20:20,860
this will probably show some spinner on

00:20:17,140 --> 00:20:25,750
the page and you want to reset all the

00:20:20,860 --> 00:20:27,550
previous errors now if action fails you

00:20:25,750 --> 00:20:29,590
want to stop the loading spinner and you

00:20:27,550 --> 00:20:35,530
want to hit this error message to your

00:20:29,590 --> 00:20:38,650
error message field and then if the data

00:20:35,530 --> 00:20:41,020
came back if data was loaded you again

00:20:38,650 --> 00:20:43,450
set the loading to false clothing has

00:20:41,020 --> 00:20:45,790
been finished and then you do some

00:20:43,450 --> 00:20:48,730
meaningful change so you store your data

00:20:45,790 --> 00:20:51,730
into the state so as you can see those

00:20:48,730 --> 00:20:54,130
are kind of three types of effects three

00:20:51,730 --> 00:20:56,710
types of actions so instead of having

00:20:54,130 --> 00:20:59,770
one based action we actually came up

00:20:56,710 --> 00:21:02,050
with three base actions one is paid base

00:20:59,770 --> 00:21:04,030
load action the second one was based

00:21:02,050 --> 00:21:05,320
loaded action and the third one was bait

00:21:04,030 --> 00:21:10,200
this failed action

00:21:05,320 --> 00:21:14,230
now all these base actions had some

00:21:10,200 --> 00:21:16,810
hidden baked in field that told us which

00:21:14,230 --> 00:21:20,410
type they belong to so this helped us

00:21:16,810 --> 00:21:23,800
then later on to handle different cases

00:21:20,410 --> 00:21:27,180
for example whenever we used reducer we

00:21:23,800 --> 00:21:31,060
realized that pretty much all our load

00:21:27,180 --> 00:21:33,070
reducers were the same we just set the

00:21:31,060 --> 00:21:35,740
field to loading and that's it there's

00:21:33,070 --> 00:21:36,940
not much going on there the same was

00:21:35,740 --> 00:21:38,410
with failure

00:21:36,940 --> 00:21:40,540
so we said loading to false we said

00:21:38,410 --> 00:21:45,030
error message nothing else nothing

00:21:40,540 --> 00:21:49,500
specific so is that we could replace our

00:21:45,030 --> 00:21:52,810
huge reducers with a lot of switch cases

00:21:49,500 --> 00:21:55,150
with our simple base reducer which

00:21:52,810 --> 00:21:57,370
handles all the load actions the same

00:21:55,150 --> 00:21:59,920
way and those all the failure actions

00:21:57,370 --> 00:22:01,870
the same way and then the only thing we

00:21:59,920 --> 00:22:03,490
want to handle if we want to handle

00:22:01,870 --> 00:22:06,130
differently is handle

00:22:03,490 --> 00:22:08,380
so this is where the meaningful changes

00:22:06,130 --> 00:22:10,899
are happening I mean then you can write

00:22:08,380 --> 00:22:13,299
it simply like this and if you look at

00:22:10,899 --> 00:22:16,000
the signature of the handle loaded it

00:22:13,299 --> 00:22:19,210
takes state action and it returns state

00:22:16,000 --> 00:22:23,559
so if you're one of those that switch to

00:22:19,210 --> 00:22:25,899
the new NJ rx and use create reducer you

00:22:23,559 --> 00:22:29,110
can use the same create reducer instead

00:22:25,899 --> 00:22:32,200
of handle loaded so you can even more

00:22:29,110 --> 00:22:34,210
simplify this code now as I said we were

00:22:32,200 --> 00:22:37,480
working on this solution in parallel so

00:22:34,210 --> 00:22:40,649
this talk doesn't include a creator

00:22:37,480 --> 00:22:46,149
reducer but I will mention it later

00:22:40,649 --> 00:22:48,070
now there's one slide or actually three

00:22:46,149 --> 00:22:51,010
slide issues with action-type that we

00:22:48,070 --> 00:22:54,850
define fresh each action now as I

00:22:51,010 --> 00:22:57,640
mentioned that using string might

00:22:54,850 --> 00:23:00,399
produce some syntax errors so you have

00:22:57,640 --> 00:23:03,669
to use this Const or some minims to

00:23:00,399 --> 00:23:06,820
represent it and this enabled inevitably

00:23:03,669 --> 00:23:10,630
leads to these long sausages of variable

00:23:06,820 --> 00:23:12,850
names which one presents the feature or

00:23:10,630 --> 00:23:16,870
module where this action belongs to and

00:23:12,850 --> 00:23:19,659
then second is the actual class name now

00:23:16,870 --> 00:23:22,659
once you have some effects or some code

00:23:19,659 --> 00:23:26,020
that has bunch of these action your code

00:23:22,659 --> 00:23:28,000
looks voted for no reason the second

00:23:26,020 --> 00:23:31,270
thing is that your action type is

00:23:28,000 --> 00:23:33,909
nothing but a string you can use a good

00:23:31,270 --> 00:23:35,679
action hygiene to make sure or hope that

00:23:33,909 --> 00:23:37,510
it's really unique but no one can

00:23:35,679 --> 00:23:39,940
guarantees that this string is really

00:23:37,510 --> 00:23:41,500
unique it's just a string you can

00:23:39,940 --> 00:23:43,840
prepend it with the module where it

00:23:41,500 --> 00:23:46,630
belongs you can have a really specific

00:23:43,840 --> 00:23:48,279
name to make sure that it's unique but

00:23:46,630 --> 00:23:51,480
as I said it's just a string

00:23:48,279 --> 00:23:54,070
no one guarantees this is unique and

00:23:51,480 --> 00:23:56,140
well this is COBOL debugging because

00:23:54,070 --> 00:23:57,880
whenever something happens you can see

00:23:56,140 --> 00:24:01,570
what actions were fired and you can

00:23:57,880 --> 00:24:03,190
follow the whole flow in production you

00:24:01,570 --> 00:24:05,770
don't have this switched on so you don't

00:24:03,190 --> 00:24:08,110
have the bugging switched on and then

00:24:05,770 --> 00:24:10,600
you have a bunch of waste in production

00:24:08,110 --> 00:24:14,279
because you have all these long string

00:24:10,600 --> 00:24:15,490
names that are used just to figure out

00:24:14,279 --> 00:24:17,679
what is

00:24:15,490 --> 00:24:20,740
difference between actions but they

00:24:17,679 --> 00:24:26,080
don't really bring any benefit one thing

00:24:20,740 --> 00:24:28,929
that actions had was constructor so if

00:24:26,080 --> 00:24:31,090
we look at the constructor it's shorter

00:24:28,929 --> 00:24:33,100
than this first line right because it's

00:24:31,090 --> 00:24:37,120
just load product that's the name of the

00:24:33,100 --> 00:24:40,420
class that we use it's a unique because

00:24:37,120 --> 00:24:43,450
each class keeps a specific place in the

00:24:40,420 --> 00:24:45,520
memory so there is no chance that you

00:24:43,450 --> 00:24:48,700
will have two classes pointing to the

00:24:45,520 --> 00:24:50,800
same memory right and it doesn't produce

00:24:48,700 --> 00:24:54,070
waste in the production because the

00:24:50,800 --> 00:24:56,110
names get compiled to a single character

00:24:54,070 --> 00:25:00,130
most likely so it's taking a really

00:24:56,110 --> 00:25:02,290
small amount of space and this is what

00:25:00,130 --> 00:25:04,270
we did we decided to go type less to

00:25:02,290 --> 00:25:07,500
drop the type completely from the action

00:25:04,270 --> 00:25:10,120
and instead use the constructor so now

00:25:07,500 --> 00:25:12,790
instead of those three lines where you

00:25:10,120 --> 00:25:15,429
had to define also type we would have

00:25:12,790 --> 00:25:17,830
just base action that specifies the

00:25:15,429 --> 00:25:20,740
payload we don't care about type right

00:25:17,830 --> 00:25:24,340
because we now handle the classes

00:25:20,740 --> 00:25:26,350
directly this also helps us then tried

00:25:24,340 --> 00:25:30,400
reducers be differently so instead of

00:25:26,350 --> 00:25:32,830
comparing action type to this to some

00:25:30,400 --> 00:25:35,970
string we simply take constructor from

00:25:32,830 --> 00:25:40,059
the action and compare it with a class

00:25:35,970 --> 00:25:42,820
and finally in effect instead of using

00:25:40,059 --> 00:25:44,770
off type we were using a faction now

00:25:42,820 --> 00:25:47,260
some of you might look at this of action

00:25:44,770 --> 00:25:51,100
and think hey wait this doesn't really

00:25:47,260 --> 00:25:54,400
exist does it well it is it exists now

00:25:51,100 --> 00:25:57,850
so meat off action this is the operator

00:25:54,400 --> 00:26:01,120
which we do it for rxjs I specifically

00:25:57,850 --> 00:26:03,700
built for entry Rx and it's nothing

00:26:01,120 --> 00:26:08,080
other than a simple wrapper around

00:26:03,700 --> 00:26:10,960
filter so we simply say which actions we

00:26:08,080 --> 00:26:12,460
want to allow and then for each action

00:26:10,960 --> 00:26:15,730
coming through the pipeline we check

00:26:12,460 --> 00:26:17,590
does this action map matches our

00:26:15,730 --> 00:26:20,470
constructors to one of the actions

00:26:17,590 --> 00:26:23,260
defined yes or no and this is exactly

00:26:20,470 --> 00:26:25,750
the same way how the off type has been

00:26:23,260 --> 00:26:29,470
built but instead of constructor they

00:26:25,750 --> 00:26:32,060
are comparing type to the string

00:26:29,470 --> 00:26:33,740
now in case you wondered it's also

00:26:32,060 --> 00:26:35,780
faster than string which only makes

00:26:33,740 --> 00:26:37,130
sense right because you're simply

00:26:35,780 --> 00:26:38,680
comparing by reference you're not

00:26:37,130 --> 00:26:41,510
comparing each character of the string

00:26:38,680 --> 00:26:45,710
so based on some of the benchmarks it's

00:26:41,510 --> 00:26:50,300
15% faster and not much because already

00:26:45,710 --> 00:26:52,190
this type has been quite optimized and

00:26:50,300 --> 00:26:54,230
if you want to run the benchmark

00:26:52,190 --> 00:26:56,720
yourself if you don't believe me you can

00:26:54,230 --> 00:27:00,530
follow this link there you can see the

00:26:56,720 --> 00:27:03,590
benchmark now the bad thing is that it's

00:27:00,530 --> 00:27:05,120
not compatible with create action the

00:27:03,590 --> 00:27:07,940
reason why it's not compatible is

00:27:05,120 --> 00:27:11,690
because when they introduced create

00:27:07,940 --> 00:27:14,330
action in ngrick steam they drop the

00:27:11,690 --> 00:27:16,540
class completely and instead they use a

00:27:14,330 --> 00:27:19,940
function that generates a simple object

00:27:16,540 --> 00:27:22,220
now this simple object doesn't have a

00:27:19,940 --> 00:27:25,600
sense of class which it belongs to it's

00:27:22,220 --> 00:27:28,910
simply an object that has a read-only

00:27:25,600 --> 00:27:34,070
field called type which is the string

00:27:28,910 --> 00:27:36,950
that we saw so you can still use a lot

00:27:34,070 --> 00:27:40,370
of stuff from this talk not necessarily

00:27:36,950 --> 00:27:44,300
the of action but you can still use it

00:27:40,370 --> 00:27:46,240
to simplify or reduces and to simplify

00:27:44,300 --> 00:27:49,010
your effects even if you are using

00:27:46,240 --> 00:27:53,120
create action create reducer create

00:27:49,010 --> 00:27:54,770
effect now MGR X is not or State

00:27:53,120 --> 00:27:57,440
management is not the only thing you can

00:27:54,770 --> 00:28:00,380
optimize in your code this is for

00:27:57,440 --> 00:28:02,240
example how we are building page table

00:28:00,380 --> 00:28:07,130
lists in our application we realize that

00:28:02,240 --> 00:28:10,430
a lot of our code whatever musn't some a

00:28:07,130 --> 00:28:13,160
list of items that are payable right and

00:28:10,430 --> 00:28:15,740
each of these lists then have to have

00:28:13,160 --> 00:28:18,340
some sort of information which page are

00:28:15,740 --> 00:28:22,100
they on we would also like to know

00:28:18,340 --> 00:28:23,750
whether there is next page and we

00:28:22,100 --> 00:28:29,420
realize there's a lot of stuff being

00:28:23,750 --> 00:28:31,490
duplicated so instead we created this

00:28:29,420 --> 00:28:35,990
page ball structure and its generic he

00:28:31,490 --> 00:28:38,270
takes simple type and if you can see

00:28:35,990 --> 00:28:41,900
here it takes just two parameters one is

00:28:38,270 --> 00:28:42,850
items which is again a list of generic

00:28:41,900 --> 00:28:46,389
types

00:28:42,850 --> 00:28:48,789
and page which is a number ready folded

00:28:46,389 --> 00:28:51,970
set to zero and then we said in the

00:28:48,789 --> 00:28:56,740
structure array of these items and we

00:28:51,970 --> 00:28:59,320
said our page and we have this nice

00:28:56,740 --> 00:29:02,639
function or nice get our code has more

00:28:59,320 --> 00:29:05,590
items which simply checks if our list

00:29:02,639 --> 00:29:07,509
has the same length of the page size if

00:29:05,590 --> 00:29:10,090
it does then probably there's a next

00:29:07,509 --> 00:29:12,190
page if it doesn't for sure there's no

00:29:10,090 --> 00:29:14,710
next page now in reality our

00:29:12,190 --> 00:29:18,250
implementation is a bit more complex

00:29:14,710 --> 00:29:20,769
than this there's bit more checks but in

00:29:18,250 --> 00:29:24,279
a nutshell this is what we do so we

00:29:20,769 --> 00:29:27,279
simply use generics to hide a lot of

00:29:24,279 --> 00:29:29,049
common functionality behind and then we

00:29:27,279 --> 00:29:31,870
can use the same thing to make generic

00:29:29,049 --> 00:29:34,360
component so so in microstock some

00:29:31,870 --> 00:29:37,629
generic some generics with services and

00:29:34,360 --> 00:29:40,870
with components so for example we can

00:29:37,629 --> 00:29:46,120
now create a component that again uses

00:29:40,870 --> 00:29:49,210
this generic page ball list and we have

00:29:46,120 --> 00:29:54,070
a simple observable of this page ablest

00:29:49,210 --> 00:29:58,720
and one thing we realized that for most

00:29:54,070 --> 00:30:01,659
of the pages we are taking the ID or

00:29:58,720 --> 00:30:04,419
some property from the activated route

00:30:01,659 --> 00:30:06,629
and then we use this to fetch our first

00:30:04,419 --> 00:30:09,419
set of items and we always have some

00:30:06,629 --> 00:30:13,450
selector that fetches the items for us

00:30:09,419 --> 00:30:15,639
so we could simply hide this common

00:30:13,450 --> 00:30:18,159
functionality behind this vegetable

00:30:15,639 --> 00:30:21,159
component and then we would simply say

00:30:18,159 --> 00:30:23,590
that our class extends the page table

00:30:21,159 --> 00:30:25,389
component and we would specify the type

00:30:23,590 --> 00:30:29,789
which is the main type of our items we

00:30:25,389 --> 00:30:32,710
want to show now this hopefully wasn't

00:30:29,789 --> 00:30:35,799
too technical for you hopefully you were

00:30:32,710 --> 00:30:39,970
able to follow generics are really

00:30:35,799 --> 00:30:41,950
powerful to set and if you haven't used

00:30:39,970 --> 00:30:42,610
it so far if you don't know how it works

00:30:41,950 --> 00:30:46,590
exactly

00:30:42,610 --> 00:30:49,059
I suggest you go to the typescript

00:30:46,590 --> 00:30:50,710
documentation and see how it works and

00:30:49,059 --> 00:30:53,830
start using it in your application if

00:30:50,710 --> 00:30:55,960
you did already use it I urge you next

00:30:53,830 --> 00:30:57,700
time when you copy/paste some code

00:30:55,960 --> 00:30:59,290
when you come into a situation where

00:30:57,700 --> 00:31:02,980
something is just too boring because

00:30:59,290 --> 00:31:04,780
it's too repetitive try to find common

00:31:02,980 --> 00:31:06,930
patterns and try to replace this

00:31:04,780 --> 00:31:10,120
functionality with generics generics

00:31:06,930 --> 00:31:14,310
gives you a different set of glasses

00:31:10,120 --> 00:31:19,270
with which you can look to your code and

00:31:14,310 --> 00:31:21,100
every time you apply some generics you

00:31:19,270 --> 00:31:23,020
never tableau redo remove a bunch of

00:31:21,100 --> 00:31:24,760
code and the best thing to do when you

00:31:23,020 --> 00:31:27,580
remove a bunch of code is to play your

00:31:24,760 --> 00:31:29,800
favorite goodbye list so this is my

00:31:27,580 --> 00:31:33,070
goodbye playlist you can find it under

00:31:29,800 --> 00:31:35,920
this Spotify link so there's some

00:31:33,070 --> 00:31:38,740
classic songs like Bocelli's time to say

00:31:35,920 --> 00:31:42,160
goodbye or placebo zone to say goodbye

00:31:38,740 --> 00:31:46,090
for those of you who saw a German series

00:31:42,160 --> 00:31:48,750
dark you can probably recognize that but

00:31:46,090 --> 00:31:51,670
at some goodbye and there's even one

00:31:48,750 --> 00:31:54,580
song from a Serbian band

00:31:51,670 --> 00:31:56,950
auf wiedersehen which means both the

00:31:54,580 --> 00:32:00,730
name of the song and the band means

00:31:56,950 --> 00:32:04,270
goodbye so with that thank you for

00:32:00,730 --> 00:32:07,030
listening you can follow me using handle

00:32:04,270 --> 00:32:11,020
Miroslav again here's a link to my

00:32:07,030 --> 00:32:14,110
Spotify playlist some of the code early

00:32:11,020 --> 00:32:16,420
version of this has been developed under

00:32:14,110 --> 00:32:19,420
my github account here you can find it

00:32:16,420 --> 00:32:22,350
under NJ helper it's bit outdated our

00:32:19,420 --> 00:32:24,910
project moved on since then but I

00:32:22,350 --> 00:32:27,160
promise you in the upcoming weeks it

00:32:24,910 --> 00:32:30,520
will come up to the up to date and it

00:32:27,160 --> 00:32:33,310
will also cover cases where I use create

00:32:30,520 --> 00:32:36,580
actions and create reducers there's also

00:32:33,310 --> 00:32:38,950
it's called mg helper not ng rx helper

00:32:36,580 --> 00:32:41,470
because there's bunch of other things in

00:32:38,950 --> 00:32:44,890
this ocean that you might find helpful

00:32:41,470 --> 00:32:47,050
for your project and using generics

00:32:44,890 --> 00:32:48,910
might not make you super hero but it

00:32:47,050 --> 00:32:50,590
pleased you will look like a local

00:32:48,910 --> 00:32:52,250
superhero in the eyes of your colleagues

00:32:50,590 --> 00:32:55,940
thank you

00:32:52,250 --> 00:32:55,940

YouTube URL: https://www.youtube.com/watch?v=LesJdh4uRmk


