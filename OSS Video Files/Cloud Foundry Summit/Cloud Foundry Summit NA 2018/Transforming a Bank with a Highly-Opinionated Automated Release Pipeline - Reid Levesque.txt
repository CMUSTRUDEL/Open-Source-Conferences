Title: Transforming a Bank with a Highly-Opinionated Automated Release Pipeline - Reid Levesque
Publication date: 2018-04-21
Playlist: Cloud Foundry Summit NA 2018
Description: 
	Transforming a Bank with a Highly-Opinionated Automated Release Pipeline - Reid Levesque, Royal Bank of Canada

Can development teams focus on developing business logic while avoiding the bureaucratic jungle to get to production? Microservices are great at speeding up development time and shortening the feedback loop -- unless every team has to build a pipeline from scratch. In an organization used to monthly or quarterly releases, moving to daily or hourly deployments requires more than a change in application architecture.

This session will cover how weâ€™ve automated all the things while still giving developers the freedom to be successful. 

About Reid Levesque
Reid is a Principal Software Developer in the Cloud Platform Engineering team at RBC. He has created several microservice applications using Spring Cloud and Cloud Foundry. Reid is actively accelerating applications to production with an opinionated release pipeline. Reid has a strong development background and received his Bachelor of Mathematics in Computer Science from the University of Waterloo. He is based in Toronto, Ontario.
Captions: 
	00:00:00,260 --> 00:00:08,519
hi everyone we're gonna get started but

00:00:06,480 --> 00:00:10,559
before we do I need to read the fires

00:00:08,519 --> 00:00:12,120
announcement so please note the

00:00:10,559 --> 00:00:14,849
locations of the surrounding emergency

00:00:12,120 --> 00:00:17,460
exits locate the nearest exit nearest

00:00:14,849 --> 00:00:20,010
lit exit sign to you in the event of a

00:00:17,460 --> 00:00:22,519
fire alarm or other emergency please

00:00:20,010 --> 00:00:24,779
calmly exit to the public concourse

00:00:22,519 --> 00:00:26,670
emergency exits stairwells leading to

00:00:24,779 --> 00:00:29,070
the outside of this facility are located

00:00:26,670 --> 00:00:31,109
along the public concourse for your

00:00:29,070 --> 00:00:33,410
safety in an emergency please follow the

00:00:31,109 --> 00:00:37,290
direction of the public safety staff

00:00:33,410 --> 00:00:39,660
great so hopefully you're all here for

00:00:37,290 --> 00:00:41,070
for this talk we're gonna be talking

00:00:39,660 --> 00:00:43,590
about transforming a bank with a highly

00:00:41,070 --> 00:00:45,360
opinionated automated release pipeline I

00:00:43,590 --> 00:00:47,610
was trying to win the prize for the

00:00:45,360 --> 00:00:51,809
longest title at the conference so we'll

00:00:47,610 --> 00:00:55,500
see it's Jerry slope so Who am I I'm

00:00:51,809 --> 00:00:58,350
Reed Reed Lebec I work at RBC which is a

00:00:55,500 --> 00:01:00,449
bank in Canada I've been there for eight

00:00:58,350 --> 00:01:03,449
and a half years and I've been on the

00:01:00,449 --> 00:01:05,760
cloud team for the last three two and a

00:01:03,449 --> 00:01:07,350
half three years they're boats and in

00:01:05,760 --> 00:01:10,909
that time I've written several micro

00:01:07,350 --> 00:01:13,409
service based applications and we have

00:01:10,909 --> 00:01:15,000
we've started to try to roll that out to

00:01:13,409 --> 00:01:19,020
the rest organization and try to write

00:01:15,000 --> 00:01:20,009
some tools to help them do it so what

00:01:19,020 --> 00:01:22,049
are we going to talk about today so I

00:01:20,009 --> 00:01:23,250
want to kind of take you through for

00:01:22,049 --> 00:01:26,549
those of you who haven't worked at a big

00:01:23,250 --> 00:01:27,540
organization government or bank that

00:01:26,549 --> 00:01:28,890
sort of stuff I want to talk to you

00:01:27,540 --> 00:01:32,750
through kind of how we've done it in the

00:01:28,890 --> 00:01:36,060
past some ways we tried to fix that and

00:01:32,750 --> 00:01:40,500
then how the problems that led to and

00:01:36,060 --> 00:01:44,369
how we solved those so hopefully

00:01:40,500 --> 00:01:48,090
everyone knows a monolith is a big giant

00:01:44,369 --> 00:01:50,549
thing that's unruly so that's not really

00:01:48,090 --> 00:01:52,710
the interesting bit but more what comes

00:01:50,549 --> 00:01:54,329
out of having monoliths so we end up

00:01:52,710 --> 00:01:56,909
having these long development cycles so

00:01:54,329 --> 00:01:58,560
typically waterfall three months if

00:01:56,909 --> 00:02:01,590
you're lucky you'll get a deployment out

00:01:58,560 --> 00:02:04,110
and each application deployment is a

00:02:01,590 --> 00:02:06,750
special snowflake so we need to work

00:02:04,110 --> 00:02:07,829
with every other team you know you need

00:02:06,750 --> 00:02:10,379
to work with the network team the

00:02:07,829 --> 00:02:13,410
database team the five op teams that

00:02:10,379 --> 00:02:14,100
also use your database etc etc so that's

00:02:13,410 --> 00:02:16,090
a mess

00:02:14,100 --> 00:02:19,090
so we don't really want to be doing that

00:02:16,090 --> 00:02:22,270
anymore and the other thing to note is

00:02:19,090 --> 00:02:24,040
that we do a lot of retail so a lot of

00:02:22,270 --> 00:02:25,750
the banks applications revolve around

00:02:24,040 --> 00:02:28,030
these three steps get data from

00:02:25,750 --> 00:02:30,150
somewhere transform it into the right

00:02:28,030 --> 00:02:32,800
format and then put it somewhere else

00:02:30,150 --> 00:02:35,590
and so traditionally that's been done

00:02:32,800 --> 00:02:39,610
you know with some database and then

00:02:35,590 --> 00:02:42,010
some process and then no database so our

00:02:39,610 --> 00:02:44,380
idea at the bank was to stop doing that

00:02:42,010 --> 00:02:45,970
which I thought was a good one and we're

00:02:44,380 --> 00:02:49,570
gonna do some venture of an architecture

00:02:45,970 --> 00:02:51,730
so vent ribbon is a new hotness the idea

00:02:49,570 --> 00:02:52,900
is that you take your data and turn it

00:02:51,730 --> 00:02:55,120
into events and then you can write them

00:02:52,900 --> 00:02:58,510
in processors instead of having batch

00:02:55,120 --> 00:02:59,890
jobs so streaming is ultimately better

00:02:58,510 --> 00:03:01,860
than batch because you can always

00:02:59,890 --> 00:03:04,510
Express a batch process as a stream

00:03:01,860 --> 00:03:08,910
reading a file in is just streaming the

00:03:04,510 --> 00:03:12,940
file right so we chose Kafka as our bus

00:03:08,910 --> 00:03:14,650
event stream and we want to put the data

00:03:12,940 --> 00:03:17,350
into a lastik search so we have a lot of

00:03:14,650 --> 00:03:19,420
use cases where there's search use cases

00:03:17,350 --> 00:03:21,880
so if someone calls up the help desk or

00:03:19,420 --> 00:03:24,130
hey can you help me here and we need to

00:03:21,880 --> 00:03:25,930
look up the users information so

00:03:24,130 --> 00:03:27,610
elasticsearch is perfect for that and

00:03:25,930 --> 00:03:29,590
then we didn't want to do micro services

00:03:27,610 --> 00:03:31,930
sorry we didn't wanna do monoliths

00:03:29,590 --> 00:03:33,580
so he decided to do micro services put a

00:03:31,930 --> 00:03:35,560
REST API in the front and then the data

00:03:33,580 --> 00:03:36,820
is exposed to the rest of the bank so we

00:03:35,560 --> 00:03:39,520
don't need to go through this mess all

00:03:36,820 --> 00:03:42,100
over again so just briefly through the

00:03:39,520 --> 00:03:43,810
application architecture so the reason I

00:03:42,100 --> 00:03:46,060
want to focus on this is what we've done

00:03:43,810 --> 00:03:48,130
is we've written an opinion framework

00:03:46,060 --> 00:03:49,930
for this type of architecture so we

00:03:48,130 --> 00:03:51,160
didn't write a framework for every

00:03:49,930 --> 00:03:53,620
application at the bank we wrote a

00:03:51,160 --> 00:03:55,780
framework for event-driven applications

00:03:53,620 --> 00:03:58,000
using Kafka and some sort of datastore

00:03:55,780 --> 00:03:59,950
in this case it's elasticsearch so the

00:03:58,000 --> 00:04:02,650
data comes from somewhere goes into

00:03:59,950 --> 00:04:05,440
Kafka we have some consumer which will

00:04:02,650 --> 00:04:08,620
do some sort of transformation put it in

00:04:05,440 --> 00:04:10,870
the bespoke format that we need for

00:04:08,620 --> 00:04:12,700
answering the question and that question

00:04:10,870 --> 00:04:14,500
will be answered by the REST API which

00:04:12,700 --> 00:04:16,150
ultimately just asked elasticsearch and

00:04:14,500 --> 00:04:18,670
then the client will connect to the REST

00:04:16,150 --> 00:04:21,430
API so fairly a fairly simple

00:04:18,670 --> 00:04:23,020
architecture so we should be able to do

00:04:21,430 --> 00:04:25,169
something to make that pretty easy for

00:04:23,020 --> 00:04:27,220
everyone

00:04:25,169 --> 00:04:30,700
so we went from monoliths to

00:04:27,220 --> 00:04:34,060
microservices and now we have a whole

00:04:30,700 --> 00:04:36,250
new set of problems so all the processes

00:04:34,060 --> 00:04:38,440
at the bank are set up to deploy very

00:04:36,250 --> 00:04:40,900
infrequently so when you do a deployment

00:04:38,440 --> 00:04:43,419
every three months it's really hard so

00:04:40,900 --> 00:04:45,370
you want to be really careful and you

00:04:43,419 --> 00:04:46,389
want to be super diligent you got to

00:04:45,370 --> 00:04:48,820
coordinate every one so there's all

00:04:46,389 --> 00:04:50,770
kinds of processes of the change records

00:04:48,820 --> 00:04:51,910
getting everyone coordinated but if you

00:04:50,770 --> 00:04:54,190
want to release you know once an hour

00:04:51,910 --> 00:04:55,930
once a day once a week that becomes

00:04:54,190 --> 00:04:58,810
quite onerous and you spend more time

00:04:55,930 --> 00:05:01,570
doing the process than you do doing the

00:04:58,810 --> 00:05:03,030
doing the actual deployment and so the

00:05:01,570 --> 00:05:05,020
things that they want to make sure that

00:05:03,030 --> 00:05:06,760
are done in the process aren't

00:05:05,020 --> 00:05:08,979
necessarily bad things like you know

00:05:06,760 --> 00:05:10,330
making sure testings done making sure

00:05:08,979 --> 00:05:12,820
that you're not going to break stuff you

00:05:10,330 --> 00:05:14,080
know regression testing etc etc but the

00:05:12,820 --> 00:05:16,090
idea is we want to automate those checks

00:05:14,080 --> 00:05:19,060
we don't want them to be some some

00:05:16,090 --> 00:05:20,830
manual process the other thing is as we

00:05:19,060 --> 00:05:24,520
get more micro services things get hairy

00:05:20,830 --> 00:05:26,500
in a hurry so if all our operations is

00:05:24,520 --> 00:05:28,360
set up around my monitoring one

00:05:26,500 --> 00:05:32,380
application then we're gonna be in for a

00:05:28,360 --> 00:05:34,000
world of hurt when messages are in Kafka

00:05:32,380 --> 00:05:36,669
and we have some eventual consistency in

00:05:34,000 --> 00:05:39,039
our API so things get a lot harder and

00:05:36,669 --> 00:05:40,780
the other bit is that every team has to

00:05:39,039 --> 00:05:42,520
do this themselves so every team I

00:05:40,780 --> 00:05:45,160
served monitoring every team has to set

00:05:42,520 --> 00:05:47,050
up a pipeline to go to production

00:05:45,160 --> 00:05:50,080
everything has to test to figure out how

00:05:47,050 --> 00:05:52,539
to solve all these problems and and that

00:05:50,080 --> 00:05:54,479
sucks so we need a pipeline we need

00:05:52,539 --> 00:05:58,419
something that everyone can just use and

00:05:54,479 --> 00:06:00,160
and benefit from so the too many pieces

00:05:58,419 --> 00:06:02,260
to do it ad hoc you can't you know

00:06:00,160 --> 00:06:04,330
before you could get away with some some

00:06:02,260 --> 00:06:06,310
person typing on a keyboard and it'd be

00:06:04,330 --> 00:06:07,990
alright but now if you have you know

00:06:06,310 --> 00:06:09,100
even five microservices you're just

00:06:07,990 --> 00:06:11,530
going to be typing forever

00:06:09,100 --> 00:06:12,940
we want something repeatable and we want

00:06:11,530 --> 00:06:15,580
some way to automate all those processes

00:06:12,940 --> 00:06:19,350
away so what do we want to automate

00:06:15,580 --> 00:06:22,800
automate testing deployments roll backs

00:06:19,350 --> 00:06:26,200
ideally we do some zero downtime deploys

00:06:22,800 --> 00:06:27,310
and those are not necessarily trivial so

00:06:26,200 --> 00:06:28,530
it'd be nice if everyone didn't have to

00:06:27,310 --> 00:06:30,990
do it all themselves

00:06:28,530 --> 00:06:33,699
all right so

00:06:30,990 --> 00:06:35,830
the first time we tackled this was for

00:06:33,699 --> 00:06:37,300
an application so we were on the cloud

00:06:35,830 --> 00:06:39,460
team and put a cloud team and we were

00:06:37,300 --> 00:06:41,319
doing the first of these event-driven

00:06:39,460 --> 00:06:44,800
architectures and so we had a very tight

00:06:41,319 --> 00:06:46,779
deadline is about two months to three

00:06:44,800 --> 00:06:47,800
months which is fairly tight when you

00:06:46,779 --> 00:06:49,840
have nothing going on and it's

00:06:47,800 --> 00:06:52,870
incredibly tight when you work at a bank

00:06:49,840 --> 00:06:54,879
and everything has a three-day SLA to

00:06:52,870 --> 00:06:56,560
get access timing so what do we have we

00:06:54,879 --> 00:06:57,849
have Cloud Foundry so we had Cloud

00:06:56,560 --> 00:06:59,949
Foundry and we had our code in github

00:06:57,849 --> 00:07:02,650
and somehow we needed to get it from one

00:06:59,949 --> 00:07:04,060
to the other so there was nothing

00:07:02,650 --> 00:07:06,699
we had nothing there before there's no

00:07:04,060 --> 00:07:09,969
pipeline we could leverage we had a few

00:07:06,699 --> 00:07:12,279
tools though so we have jenkins we have

00:07:09,969 --> 00:07:16,449
essential jenkins so we we opted for

00:07:12,279 --> 00:07:19,029
maven because we knew maven no other

00:07:16,449 --> 00:07:20,529
reason than that and and the jenkins was

00:07:19,029 --> 00:07:22,509
already up and running so we didn't

00:07:20,529 --> 00:07:24,879
really need to setup our own so that was

00:07:22,509 --> 00:07:26,439
a small win we had to sell the tool

00:07:24,879 --> 00:07:28,499
called urbancode deploy so a quick show

00:07:26,439 --> 00:07:31,479
of hands who's ever heard of that before

00:07:28,499 --> 00:07:33,490
Wow that's way more than I thought okay

00:07:31,479 --> 00:07:38,020
so for those of you who haven't herman

00:07:33,490 --> 00:07:40,060
code deploy is a IBM tool that lets you

00:07:38,020 --> 00:07:42,729
draw pretty pictures and then those

00:07:40,060 --> 00:07:46,270
pretty pictures will somehow deploy your

00:07:42,729 --> 00:07:47,680
application so it had a few nice

00:07:46,270 --> 00:07:49,599
features to it so one it was Bank

00:07:47,680 --> 00:07:51,279
approved so we'd enough go through the

00:07:49,599 --> 00:07:52,449
process of figuring out you know how do

00:07:51,279 --> 00:07:54,159
we get whatever tool we're gonna use

00:07:52,449 --> 00:07:56,830
approved we can just go ahead and use

00:07:54,159 --> 00:07:58,300
this one and for for those who worked at

00:07:56,830 --> 00:08:01,000
bigger organizations they'll know that

00:07:58,300 --> 00:08:02,800
that's a non-trivial task the other

00:08:01,000 --> 00:08:04,539
thing is it let us store secrets so it

00:08:02,800 --> 00:08:07,000
was a place that was approved to store

00:08:04,539 --> 00:08:11,139
usernames passwords etc so if we need to

00:08:07,000 --> 00:08:12,449
connect to databases or kafka then then

00:08:11,139 --> 00:08:15,759
that's good

00:08:12,449 --> 00:08:17,949
the bad part is that we couldn't store

00:08:15,759 --> 00:08:20,860
config in source control so in our case

00:08:17,949 --> 00:08:22,389
kit which is bad because any time you

00:08:20,860 --> 00:08:23,710
make a change you make a change to the

00:08:22,389 --> 00:08:26,080
code and then if you need to update the

00:08:23,710 --> 00:08:27,729
pipeline because we're still fairly new

00:08:26,080 --> 00:08:29,379
then you have to go into this UI and

00:08:27,729 --> 00:08:32,079
make the change and that's bad because

00:08:29,379 --> 00:08:34,000
as your code changes this doesn't really

00:08:32,079 --> 00:08:35,860
change with it so you end up with a

00:08:34,000 --> 00:08:37,779
situation where one branch needs to

00:08:35,860 --> 00:08:39,130
change to the pipeline and then master

00:08:37,779 --> 00:08:41,979
doesn't and you can only deploy one of

00:08:39,130 --> 00:08:43,180
the two so that was no good and and only

00:08:41,979 --> 00:08:45,160
had a UI and I

00:08:43,180 --> 00:08:48,990
don't really like using you eyes for

00:08:45,160 --> 00:08:52,360
development it's just not my thing

00:08:48,990 --> 00:08:57,220
so we decide to use ansible so who here

00:08:52,360 --> 00:08:59,250
has ever used ansible before who here

00:08:57,220 --> 00:09:03,670
has used ansible to deploy in the cloud

00:08:59,250 --> 00:09:05,020
yeah so okay we'll get to that as well

00:09:03,670 --> 00:09:06,730
was it was good we knew and we knew as

00:09:05,020 --> 00:09:07,959
well so that was kind of want to

00:09:06,730 --> 00:09:09,520
leverage some of the things that we knew

00:09:07,959 --> 00:09:12,790
we had to tight deadlines we want to go

00:09:09,520 --> 00:09:14,290
ahead and not reinvent everything we

00:09:12,790 --> 00:09:15,580
could store that config and get it's

00:09:14,290 --> 00:09:18,279
good we can move along with the branches

00:09:15,580 --> 00:09:20,140
and we could have different config so

00:09:18,279 --> 00:09:22,089
ansible has a concept of group bars and

00:09:20,140 --> 00:09:23,560
you can have you know a dev config and a

00:09:22,089 --> 00:09:24,730
prod config which is good because you're

00:09:23,560 --> 00:09:28,180
going to have different servers for

00:09:24,730 --> 00:09:32,800
Kafka elasticsearch et cetera bad

00:09:28,180 --> 00:09:34,360
ansible is really good at deploying say

00:09:32,800 --> 00:09:35,770
you want to install Tomcat on 10 servers

00:09:34,360 --> 00:09:38,020
and you just kind of list the servers

00:09:35,770 --> 00:09:39,820
nobody goes it's great deploying to

00:09:38,020 --> 00:09:42,220
Cloud Foundry it's not so great so

00:09:39,820 --> 00:09:44,080
there's no plugins for it so we had to

00:09:42,220 --> 00:09:46,209
write a bunch of that ourselves which

00:09:44,080 --> 00:09:49,720
was in scripts like Python scripts I

00:09:46,209 --> 00:09:50,920
think it was so it was a bit bit too

00:09:49,720 --> 00:09:53,170
awkward we also want to achieve

00:09:50,920 --> 00:09:55,270
idempotency so the idea behind ansible

00:09:53,170 --> 00:09:57,339
is if say Tomcats already installed on

00:09:55,270 --> 00:09:58,450
on server a then it doesn't do anything

00:09:57,339 --> 00:10:02,170
right so we want to get the same idea

00:09:58,450 --> 00:10:03,339
from from that for Cloud Foundry it's a

00:10:02,170 --> 00:10:07,510
part of that was driven by the reason

00:10:03,339 --> 00:10:09,190
that we used mono repos or a mono repo I

00:10:07,510 --> 00:10:11,709
should say so all our all our micro

00:10:09,190 --> 00:10:13,529
services were in one one repo and we can

00:10:11,709 --> 00:10:15,790
talk about whether that's good or bad

00:10:13,529 --> 00:10:18,370
but it was both good and bad good and

00:10:15,790 --> 00:10:19,750
bad in this case so because we every

00:10:18,370 --> 00:10:21,160
time something changed it was going to

00:10:19,750 --> 00:10:22,540
rebuild and redeploy everything we

00:10:21,160 --> 00:10:25,480
wanted to make sure that only redeployed

00:10:22,540 --> 00:10:28,089
what actually changed and so we did some

00:10:25,480 --> 00:10:30,250
fun and by fun I mean terrible ideas

00:10:28,089 --> 00:10:33,610
that you should never do at home we just

00:10:30,250 --> 00:10:35,890
had to use md5 sums to compare whether

00:10:33,610 --> 00:10:37,510
things had changed so we we took the md5

00:10:35,890 --> 00:10:38,860
sum of the jar we're deploying so it's

00:10:37,510 --> 00:10:40,510
great so we've got that and was stored

00:10:38,860 --> 00:10:42,100
in in an environment variable in Cloud

00:10:40,510 --> 00:10:44,440
Foundry we can just compare the next

00:10:42,100 --> 00:10:47,410
time right so the problem is how

00:10:44,440 --> 00:10:49,839
everyone knows is the jars in their

00:10:47,410 --> 00:10:51,040
headers have a timestamp or something

00:10:49,839 --> 00:10:53,140
that changes every time you build it so

00:10:51,040 --> 00:10:56,079
if you build the same you zip up the

00:10:53,140 --> 00:10:56,620
same files twice you'll get a different

00:10:56,079 --> 00:10:58,810
MD

00:10:56,620 --> 00:11:00,430
by some so it's like okay well we can

00:10:58,810 --> 00:11:03,160
work around that so we expanded the jar

00:11:00,430 --> 00:11:05,080
into files and then we did an md5 sum of

00:11:03,160 --> 00:11:06,820
each of the files and put that in a text

00:11:05,080 --> 00:11:09,510
file and we didn't md5 sum of that text

00:11:06,820 --> 00:11:11,800
file so it got complicated real quickly

00:11:09,510 --> 00:11:14,350
but it did serve the purpose of we only

00:11:11,800 --> 00:11:16,300
redeployed what actually changed the

00:11:14,350 --> 00:11:18,520
other tricky bit was services so we have

00:11:16,300 --> 00:11:20,770
a few years to provide services 2.2

00:11:18,520 --> 00:11:23,830
caf-co elasticsearch any other services

00:11:20,770 --> 00:11:25,360
we need and it's very easy to update a

00:11:23,830 --> 00:11:27,250
user provide service I mean it doesn't

00:11:25,360 --> 00:11:28,390
really need to be idempotent the only

00:11:27,250 --> 00:11:30,550
problem is that if you're not deploying

00:11:28,390 --> 00:11:33,010
the application that the service is

00:11:30,550 --> 00:11:34,930
bound to then you need to restage that

00:11:33,010 --> 00:11:37,120
application so we had to do some

00:11:34,930 --> 00:11:39,640
finagling to figure out which

00:11:37,120 --> 00:11:43,000
applications were bound to the service

00:11:39,640 --> 00:11:47,230
have changed so it got it got way too

00:11:43,000 --> 00:11:48,940
complicated way too quickly so we then

00:11:47,230 --> 00:11:51,580
had a second application and it was very

00:11:48,940 --> 00:11:54,160
similar to the first very similar

00:11:51,580 --> 00:11:57,400
event-driven architecture we also type

00:11:54,160 --> 00:11:58,750
tight deadlines because we did such a

00:11:57,400 --> 00:12:00,790
good job on the first one that they

00:11:58,750 --> 00:12:02,230
figured we could do an even better job

00:12:00,790 --> 00:12:04,690
in the second one seeing as we solved

00:12:02,230 --> 00:12:06,450
all the hard problems so there are still

00:12:04,690 --> 00:12:08,380
a few problems that we want to solve

00:12:06,450 --> 00:12:09,850
we're gonna we're going to use the

00:12:08,380 --> 00:12:12,370
existing pipeline because we don't have

00:12:09,850 --> 00:12:14,470
time to rewrite it but we wanted things

00:12:12,370 --> 00:12:15,940
to go a bit faster so I think I think

00:12:14,470 --> 00:12:17,560
for the first application we had five or

00:12:15,940 --> 00:12:19,570
ten and we're somewhere not ranged

00:12:17,560 --> 00:12:22,630
microservices so deploying not every

00:12:19,570 --> 00:12:24,610
time gets its real slow so what we

00:12:22,630 --> 00:12:25,570
wanted to do is deploy all of those at

00:12:24,610 --> 00:12:26,530
the same time because there's nothing

00:12:25,570 --> 00:12:28,420
really dependent between the

00:12:26,530 --> 00:12:30,490
applications they could we could do five

00:12:28,420 --> 00:12:32,050
CF pushes at the same time and all of

00:12:30,490 --> 00:12:35,110
this again is driven by the fact that we

00:12:32,050 --> 00:12:37,810
had a mono repo so we had some

00:12:35,110 --> 00:12:40,810
parallelism so our first attempt was to

00:12:37,810 --> 00:12:42,520
have urbancode deploy call ansible say

00:12:40,810 --> 00:12:44,260
five times with different parameters say

00:12:42,520 --> 00:12:46,450
deploy application a application be

00:12:44,260 --> 00:12:49,210
efficacy so then we broke the cardinal

00:12:46,450 --> 00:12:51,820
rule of of put nothing in urbancode

00:12:49,210 --> 00:12:53,620
deploy because then anytime something

00:12:51,820 --> 00:12:55,420
changed we had to go back to to this UI

00:12:53,620 --> 00:12:58,570
based system which wasn't in get so that

00:12:55,420 --> 00:13:00,940
was no good so what we did then as we

00:12:58,570 --> 00:13:02,680
added bash in front so you know you're

00:13:00,940 --> 00:13:07,540
in trouble when you're doing parallelism

00:13:02,680 --> 00:13:10,000
in bash so so we had a bunch of execs

00:13:07,540 --> 00:13:12,700
and weights in bash and event

00:13:10,000 --> 00:13:16,300
we achieved some parallelism so it's

00:13:12,700 --> 00:13:17,830
great the other thing we really wanted

00:13:16,300 --> 00:13:19,960
to do was to do that automated testing

00:13:17,830 --> 00:13:24,430
bit so the first one was a UI the first

00:13:19,960 --> 00:13:26,230
application was a UI and it just didn't

00:13:24,430 --> 00:13:29,470
have time to automate automating UI

00:13:26,230 --> 00:13:31,060
testing is difficult so this one was all

00:13:29,470 --> 00:13:33,070
kind of his back-end stuff so we could

00:13:31,060 --> 00:13:34,450
easily send some data in the front and

00:13:33,070 --> 00:13:37,000
check the time a it at the end in the

00:13:34,450 --> 00:13:39,160
right way so the problem we had though

00:13:37,000 --> 00:13:41,740
with automated testing was that we ended

00:13:39,160 --> 00:13:43,360
up running on a live instance so we

00:13:41,740 --> 00:13:45,370
would deploy the application and because

00:13:43,360 --> 00:13:47,620
everything was so entangled we had to

00:13:45,370 --> 00:13:49,780
have all the services up and then we ran

00:13:47,620 --> 00:13:52,330
testing on that and so that's okay but

00:13:49,780 --> 00:13:53,740
if you find a problem it's kind of too

00:13:52,330 --> 00:13:57,550
late you have to roll everything back

00:13:53,740 --> 00:13:58,840
and it takes time so this this was

00:13:57,550 --> 00:14:02,590
definitely a lot better but we needed to

00:13:58,840 --> 00:14:05,800
work on a few things so what were our

00:14:02,590 --> 00:14:07,090
shortcomings well it took too long the

00:14:05,800 --> 00:14:08,800
whole thing took about 20 minutes even

00:14:07,090 --> 00:14:10,030
if you didn't change anything but more

00:14:08,800 --> 00:14:11,740
often not you changed some central

00:14:10,030 --> 00:14:13,960
library and you'd have to redeploy the

00:14:11,740 --> 00:14:17,710
whole thing and so then we had a team I

00:14:13,960 --> 00:14:20,050
think five or seven developers and if we

00:14:17,710 --> 00:14:21,430
all want to do something kind of we all

00:14:20,050 --> 00:14:23,890
want to do work right and so every time

00:14:21,430 --> 00:14:26,020
we go to deploy we'd have to wait 20

00:14:23,890 --> 00:14:27,700
minutes on top of that our automated

00:14:26,020 --> 00:14:29,230
testing was a bit flaky so it's like we

00:14:27,700 --> 00:14:30,610
weren't sure if it had just timed out or

00:14:29,230 --> 00:14:32,470
if we if it was an actual fare so we'd

00:14:30,610 --> 00:14:34,570
end up rewriting it so we were lucky if

00:14:32,470 --> 00:14:37,510
we got kind of four or five pull

00:14:34,570 --> 00:14:41,080
requests done in a day so it was really

00:14:37,510 --> 00:14:42,910
slowing us down the other bit is we if

00:14:41,080 --> 00:14:45,370
you haven't figured out yet we picked a

00:14:42,910 --> 00:14:46,660
few the wrong tools so ansible wasn't

00:14:45,370 --> 00:14:48,430
necessarily the right tool for deploying

00:14:46,660 --> 00:14:51,640
to the cloud

00:14:48,430 --> 00:14:54,100
bash is fine but not necessarily that

00:14:51,640 --> 00:14:56,890
robust and urbancode deploy wasn't

00:14:54,100 --> 00:14:58,089
really getting us to much and they were

00:14:56,890 --> 00:15:01,150
on top of that there was still a ton of

00:14:58,089 --> 00:15:03,339
manual steps so if we want a new Kafka

00:15:01,150 --> 00:15:05,500
topic we want a new elasticsearch index

00:15:03,339 --> 00:15:06,940
or we want a new boundary space it was

00:15:05,500 --> 00:15:09,490
all manual stuff we'd have to do that

00:15:06,940 --> 00:15:11,650
manually so if I wanted to deploy to my

00:15:09,490 --> 00:15:14,020
own particular space I would have to set

00:15:11,650 --> 00:15:16,470
up the whole pipeline set up all the

00:15:14,020 --> 00:15:16,470
pieces myself

00:15:18,970 --> 00:15:24,740
so welcome to the third and ultimate

00:15:21,770 --> 00:15:26,000
pipeline so this time we had a bit we

00:15:24,740 --> 00:15:28,670
had a bit more time so we decided to

00:15:26,000 --> 00:15:30,770
rewrite from scratch so we threw away

00:15:28,670 --> 00:15:33,710
the code but we kept all the lessons we

00:15:30,770 --> 00:15:35,750
learned and we still had a few things so

00:15:33,710 --> 00:15:37,040
we had github still that worked well and

00:15:35,750 --> 00:15:39,770
we had cloud foundry I want to keep that

00:15:37,040 --> 00:15:44,080
and we wanted to keep me even so we like

00:15:39,770 --> 00:15:46,340
maven we know maven so we kept that one

00:15:44,080 --> 00:15:47,780
now one of the things we want to do and

00:15:46,340 --> 00:15:49,580
you'll hear a lot of it other people

00:15:47,780 --> 00:15:52,730
talk about pipelines and they'll focus a

00:15:49,580 --> 00:15:54,590
lot just on the deployment side and

00:15:52,730 --> 00:15:56,000
that's great that's great that you can

00:15:54,590 --> 00:15:57,770
you know certainly solves one problem

00:15:56,000 --> 00:16:00,440
but we want to go a bit further we want

00:15:57,770 --> 00:16:02,660
to provide not necessarily lock people

00:16:00,440 --> 00:16:06,200
in but but give them a head start on

00:16:02,660 --> 00:16:07,460
building their code as well so when

00:16:06,200 --> 00:16:09,320
we're doing when we're doing these

00:16:07,460 --> 00:16:10,700
applications are fairly standard so

00:16:09,320 --> 00:16:12,140
everyone's gonna have more or less the

00:16:10,700 --> 00:16:16,220
same spring dependencies you know you'll

00:16:12,140 --> 00:16:18,050
depend on elasticsearch web Kafka etc so

00:16:16,220 --> 00:16:20,600
we can at least fix the versions so we

00:16:18,050 --> 00:16:22,520
have a bunch of bunch of defaults that

00:16:20,600 --> 00:16:24,530
we have in the CI space so we have a

00:16:22,520 --> 00:16:27,080
default parent palm so you can just

00:16:24,530 --> 00:16:28,520
inherit from that which is great and we

00:16:27,080 --> 00:16:30,890
have some Aven jobs or sorry some

00:16:28,520 --> 00:16:33,080
Jenkins jobs which will scan your repo

00:16:30,890 --> 00:16:34,430
and just grab your Jenkins file I'm

00:16:33,080 --> 00:16:35,660
sorry ok well that's kind of pretty

00:16:34,430 --> 00:16:37,820
standard right but then what we did is

00:16:35,660 --> 00:16:40,730
we wrote some functions which we added

00:16:37,820 --> 00:16:42,110
into our Jenkins so you could just call

00:16:40,730 --> 00:16:45,010
those from your Jenkins files you just

00:16:42,110 --> 00:16:46,820
say you know do the CI or do the CD and

00:16:45,010 --> 00:16:48,560
and then you wouldn't have to worry

00:16:46,820 --> 00:16:50,390
about all the steps so like stuff and

00:16:48,560 --> 00:16:53,260
we'll get to what they are but stuff

00:16:50,390 --> 00:16:56,840
that are not necessarily straightforward

00:16:53,260 --> 00:16:59,450
so we had Jenkins we decided to do our

00:16:56,840 --> 00:17:02,930
scripting in Python we we have some

00:16:59,450 --> 00:17:05,420
experience in Python it has a fairly

00:17:02,930 --> 00:17:07,610
good REST API fairly good to call REST

00:17:05,420 --> 00:17:10,250
API which we're gonna use for Cloud

00:17:07,610 --> 00:17:12,140
Foundry hit run stuff on the shell as

00:17:10,250 --> 00:17:16,850
well so it's good and the other thing we

00:17:12,140 --> 00:17:18,709
used this docker and this is so key so

00:17:16,850 --> 00:17:21,230
we ended up running Jenkins on docker

00:17:18,709 --> 00:17:23,810
and then the jobs would run inside

00:17:21,230 --> 00:17:24,800
docker containers on Jenkins and so

00:17:23,810 --> 00:17:27,949
that's super important because now we

00:17:24,800 --> 00:17:29,480
don't need to worry about like is CF CLI

00:17:27,949 --> 00:17:31,880
installed do we have the right version

00:17:29,480 --> 00:17:34,430
of Python or we need to scale out to an

00:17:31,880 --> 00:17:36,980
note are we gonna what's our procedure

00:17:34,430 --> 00:17:38,390
to set everything up and and I know it

00:17:36,980 --> 00:17:41,390
sounds like you know we could give this

00:17:38,390 --> 00:17:44,720
talk five years ago but but it's pretty

00:17:41,390 --> 00:17:46,280
revolutionary for for RBC to to run the

00:17:44,720 --> 00:17:48,080
stuff on docker and it really helped us

00:17:46,280 --> 00:17:49,940
tremendously because once we had those

00:17:48,080 --> 00:17:52,880
those base docker images with those

00:17:49,940 --> 00:17:54,410
those prereqs in we could just reuse

00:17:52,880 --> 00:17:56,630
those over over and over again which is

00:17:54,410 --> 00:17:58,760
great and the other thing we decided to

00:17:56,630 --> 00:18:00,260
do was go multi repo so we didn't like

00:17:58,760 --> 00:18:02,900
the way that mono repo was working out

00:18:00,260 --> 00:18:05,030
for us and I know some companies have

00:18:02,900 --> 00:18:07,220
made that work tremendously well like

00:18:05,030 --> 00:18:08,630
Google and Facebook but if you look at

00:18:07,220 --> 00:18:10,940
how they've done it they end up using a

00:18:08,630 --> 00:18:13,930
lot of custom tools and I know that

00:18:10,940 --> 00:18:15,530
Concours which we're at a club boundary

00:18:13,930 --> 00:18:17,990
summit so we might as well mention

00:18:15,530 --> 00:18:20,180
concourse concourse does very well where

00:18:17,990 --> 00:18:22,550
you'll you'll you can grab the subfolder

00:18:20,180 --> 00:18:24,110
inside inside your git repo and say

00:18:22,550 --> 00:18:26,240
we'll just just build if this sub

00:18:24,110 --> 00:18:27,740
folders changed but we didn't really

00:18:26,240 --> 00:18:29,600
want to go learn concourse we have

00:18:27,740 --> 00:18:32,990
enough to do so we stuck with Jenkins

00:18:29,600 --> 00:18:34,430
Jenkins works best when you make your

00:18:32,990 --> 00:18:36,260
changes at the top so the top level

00:18:34,430 --> 00:18:37,790
changed and there you go so we went

00:18:36,260 --> 00:18:42,020
multi repo so every micro service has

00:18:37,790 --> 00:18:44,270
its own repo and github so the other

00:18:42,020 --> 00:18:46,310
thing we did is we wanted to

00:18:44,270 --> 00:18:50,270
automatically provision elasticsearch in

00:18:46,310 --> 00:18:53,060
Kafka and Cloud Foundry stuff and so we

00:18:50,270 --> 00:18:54,980
created a DSL so it's in the ammo so

00:18:53,060 --> 00:18:57,550
it's how you got to talk here you know

00:18:54,980 --> 00:18:59,960
if it was JSON they'd kick me out

00:18:57,550 --> 00:19:01,700
so so we have it in Yama and it's just

00:18:59,960 --> 00:19:03,770
simple stuff like you know what's your

00:19:01,700 --> 00:19:05,630
app called how much memory do you need

00:19:03,770 --> 00:19:07,850
you know what's your topic called it's

00:19:05,630 --> 00:19:08,930
not all the options so it wouldn't be it

00:19:07,850 --> 00:19:11,450
wouldn't be everything you put in the

00:19:08,930 --> 00:19:13,070
manifest for instance it would just be a

00:19:11,450 --> 00:19:14,330
subset because there's a lot of stuff

00:19:13,070 --> 00:19:17,330
that you don't really need to worry

00:19:14,330 --> 00:19:18,980
about like where the Kafka server is or

00:19:17,330 --> 00:19:20,930
where elasticsearch will take care of

00:19:18,980 --> 00:19:22,130
that as the pipeline you just need to

00:19:20,930 --> 00:19:23,420
know you're going to use elasticsearch

00:19:22,130 --> 00:19:25,070
and you want your index to be called

00:19:23,420 --> 00:19:28,910
this and here's the JSON and such and

00:19:25,070 --> 00:19:29,960
such and so what we would do is part of

00:19:28,910 --> 00:19:31,100
the pipeline is we were checked to make

00:19:29,960 --> 00:19:32,600
sure that's okay so you want to know

00:19:31,100 --> 00:19:34,220
sooner you don't want to go all the way

00:19:32,600 --> 00:19:35,420
to deploy it's like oh hey the thing

00:19:34,220 --> 00:19:37,370
failed because you're the syntax error

00:19:35,420 --> 00:19:40,010
so I know that as soon as possible so we

00:19:37,370 --> 00:19:43,430
check that here and then what we do is

00:19:40,010 --> 00:19:45,110
we put the artifacts in s3 now we can

00:19:43,430 --> 00:19:46,350
argue all day as to the best artifact

00:19:45,110 --> 00:19:48,090
repository

00:19:46,350 --> 00:19:51,269
some people like Nexus other people like

00:19:48,090 --> 00:19:52,529
artifactory we chose s3 partly for the

00:19:51,269 --> 00:19:55,049
reason that we had more control over

00:19:52,529 --> 00:19:56,669
that and we didn't have to rely on other

00:19:55,049 --> 00:19:58,110
teams so it's always good when you're

00:19:56,669 --> 00:20:00,179
trying to get stuff done the hurry is to

00:19:58,110 --> 00:20:03,690
do stuff you have control over the other

00:20:00,179 --> 00:20:05,730
bit we did was so part of our goal was

00:20:03,690 --> 00:20:09,330
that each deploy each branch would get

00:20:05,730 --> 00:20:11,940
its own pipeline all the way through so

00:20:09,330 --> 00:20:13,370
if I'm working on my branch Reed and my

00:20:11,940 --> 00:20:15,960
colleagues working on his branch John

00:20:13,370 --> 00:20:17,750
then you know we'll have well but we'll

00:20:15,960 --> 00:20:20,100
have a reed space and we'll have a read

00:20:17,750 --> 00:20:22,110
Kafka topic and we'll have a read

00:20:20,100 --> 00:20:23,789
elasticsearch index and so on so I'll be

00:20:22,110 --> 00:20:25,350
able to deploy everything all the way

00:20:23,789 --> 00:20:26,580
out and and John will be able to do that

00:20:25,350 --> 00:20:29,519
as well and we don't conflict with each

00:20:26,580 --> 00:20:31,529
other so the nice thing of using s3 is

00:20:29,519 --> 00:20:33,510
we can put the buckets named after the

00:20:31,529 --> 00:20:35,309
branches or named after whatever we're

00:20:33,510 --> 00:20:36,929
deploying so we have a prod prod bucket

00:20:35,309 --> 00:20:38,909
or whatnot which makes it really easy to

00:20:36,929 --> 00:20:41,220
pour cleanup so whenever we delete the

00:20:38,909 --> 00:20:44,929
branch then we just delete the s3 bucket

00:20:41,220 --> 00:20:47,460
and and it makes life a lot simpler and

00:20:44,929 --> 00:20:48,990
then and then grand plans which haven't

00:20:47,460 --> 00:20:50,850
quite been realized yet I'll be honest

00:20:48,990 --> 00:20:54,120
but the idea is to have a chat bot in

00:20:50,850 --> 00:20:56,039
between the CI and the CD so when you're

00:20:54,120 --> 00:20:57,299
deploying to dev or maybe staging is

00:20:56,039 --> 00:20:59,880
it's great you just kick it off

00:20:57,299 --> 00:21:02,130
automatically but especially at a bank

00:20:59,880 --> 00:21:03,450
you'll want to hold off your Prada

00:21:02,130 --> 00:21:05,700
ployment to have some sort of manual

00:21:03,450 --> 00:21:09,600
step and that manual step will be

00:21:05,700 --> 00:21:11,789
someone saying slash slash pipeline bot

00:21:09,600 --> 00:21:16,080
and deploy right so that that's kind of

00:21:11,789 --> 00:21:17,880
how that will work all right so that was

00:21:16,080 --> 00:21:19,320
the CI so let's have a look at the CD so

00:21:17,880 --> 00:21:21,360
what we did now is we created the

00:21:19,320 --> 00:21:25,639
environment parameters so these are

00:21:21,360 --> 00:21:28,980
things like server locations API URLs

00:21:25,639 --> 00:21:30,480
etc and then we combine those with the

00:21:28,980 --> 00:21:32,639
application parameters to get our full

00:21:30,480 --> 00:21:34,970
full picture so you know we know it's

00:21:32,639 --> 00:21:37,620
gonna be called reads awesome app and

00:21:34,970 --> 00:21:39,659
and we know it needs a large amount of

00:21:37,620 --> 00:21:41,370
memory so we give it four gigs and so on

00:21:39,659 --> 00:21:43,860
so forth so we get something that we can

00:21:41,370 --> 00:21:46,139
actually go off in deploy and then we'll

00:21:43,860 --> 00:21:48,779
go and provision our Kafka topics if

00:21:46,139 --> 00:21:50,610
they're not there again idempotency will

00:21:48,779 --> 00:21:56,490
create any elastic search indexes if

00:21:50,610 --> 00:21:57,860
needed and yeah and then we'll do the

00:21:56,490 --> 00:21:59,929
actual deployment

00:21:57,860 --> 00:22:02,080
so the idea is we're gonna do a

00:21:59,929 --> 00:22:04,940
Bluegreen deployment so we want to have

00:22:02,080 --> 00:22:06,470
zero downtime as much as possible so I

00:22:04,940 --> 00:22:09,080
can never remember which is which but

00:22:06,470 --> 00:22:11,120
but so we'll do the green first deploy

00:22:09,080 --> 00:22:13,640
that and then know what we did this time

00:22:11,120 --> 00:22:15,860
as we did automated testing on the on

00:22:13,640 --> 00:22:17,720
the non live route so we have our

00:22:15,860 --> 00:22:19,250
temporary pointing to our new app so

00:22:17,720 --> 00:22:20,750
we'll do the testing there which is

00:22:19,250 --> 00:22:22,519
great because now if it if the testing

00:22:20,750 --> 00:22:25,190
fails we can just not switch the red

00:22:22,519 --> 00:22:28,130
over and then if the testing does pass

00:22:25,190 --> 00:22:29,600
then we will switch the road over so the

00:22:28,130 --> 00:22:31,190
idea is that this automated testing is

00:22:29,600 --> 00:22:34,460
something that the user will the

00:22:31,190 --> 00:22:36,500
developers will provide so they their

00:22:34,460 --> 00:22:38,960
development team will plug something in

00:22:36,500 --> 00:22:41,659
there and then it will call whatever

00:22:38,960 --> 00:22:43,250
testing it needs to happen and then

00:22:41,659 --> 00:22:45,799
we'll just check the return code so

00:22:43,250 --> 00:22:47,059
either a success or failure and then and

00:22:45,799 --> 00:22:52,460
then we'll finalize the deployments will

00:22:47,059 --> 00:22:55,639
make will make the rang it up live so

00:22:52,460 --> 00:22:57,289
what so then this is a picture of what

00:22:55,639 --> 00:22:59,539
the developer experience looks like now

00:22:57,289 --> 00:23:00,710
that they have this pipeline so all they

00:22:59,539 --> 00:23:03,320
have to do really is inherit from the

00:23:00,710 --> 00:23:05,720
parent palm add a few parameters to say

00:23:03,320 --> 00:23:08,779
here's my app name here's the memory if

00:23:05,720 --> 00:23:10,909
my kafka topic and that's it and and

00:23:08,779 --> 00:23:12,110
they commit and away they go so I mean

00:23:10,909 --> 00:23:13,909
this was so good that when we were

00:23:12,110 --> 00:23:15,230
developing it we hadn't kind of finished

00:23:13,909 --> 00:23:17,269
everything so we got like little bits

00:23:15,230 --> 00:23:20,330
done and so we're working on the bits

00:23:17,269 --> 00:23:22,370
that weren't in the pipeline yet and it

00:23:20,330 --> 00:23:24,440
was it was so painful so we're gonna in

00:23:22,370 --> 00:23:25,700
little rooms like four of us and we were

00:23:24,440 --> 00:23:28,880
still payable we all turn around like oh

00:23:25,700 --> 00:23:31,820
I want to use the pipeline is it so good

00:23:28,880 --> 00:23:34,820
so and that at that point I knew that we

00:23:31,820 --> 00:23:39,500
have something special so thank you very

00:23:34,820 --> 00:23:42,159
much that's so that's it let's just talk

00:23:39,500 --> 00:23:42,159
thank you

00:23:45,770 --> 00:23:57,480
so we have time for a few questions I

00:23:48,210 --> 00:23:59,309
wants to grill me they're good sure so

00:23:57,480 --> 00:24:01,260
the question is what is Cloud Foundry do

00:23:59,309 --> 00:24:04,200
for us in the pipeline so Cloud Foundry

00:24:01,260 --> 00:24:06,210
is just our deployment target so we use

00:24:04,200 --> 00:24:12,270
that as a platform as a service where we

00:24:06,210 --> 00:24:14,610
run stuff to answer your question like

00:24:12,270 --> 00:24:21,570
it's the target where we deploy where we

00:24:14,610 --> 00:24:24,059
deploy to that's that's a good question

00:24:21,570 --> 00:24:26,490
so where we run docker is still in flux

00:24:24,059 --> 00:24:29,600
so there's talk of writing it there

00:24:26,490 --> 00:24:29,600
there's talk of bringing it elsewhere

00:24:40,520 --> 00:24:52,460
so did we have to do what for artifacts

00:24:42,930 --> 00:24:54,540
nests yeah sure sure so the question is

00:24:52,460 --> 00:24:56,880
the question is did we have to get

00:24:54,540 --> 00:24:58,260
approvals to store data in s3 so the bit

00:24:56,880 --> 00:25:01,320
that's hidden in this wonderful green

00:24:58,260 --> 00:25:03,540
box is that it's an internal s3 so it's

00:25:01,320 --> 00:25:05,370
an s3 API on top of internal storage so

00:25:03,540 --> 00:25:07,440
in that case we didn't have to get

00:25:05,370 --> 00:25:09,150
approvals to put stuff outside onto

00:25:07,440 --> 00:25:12,080
public cloud so that this whole thing

00:25:09,150 --> 00:25:12,080
runs internally

00:25:30,210 --> 00:25:34,210
yeah so the question is how much work

00:25:32,290 --> 00:25:35,980
was this and was it frustrating I felt

00:25:34,210 --> 00:25:38,050
like I should it should be available

00:25:35,980 --> 00:25:41,040
somewhere else so the answer is probably

00:25:38,050 --> 00:25:43,300
too much work or not enough I don't know

00:25:41,040 --> 00:25:45,970
it felt like a lot of work at the time

00:25:43,300 --> 00:25:47,770
the benefits are certainly there I wish

00:25:45,970 --> 00:25:49,630
there was something that we could use

00:25:47,770 --> 00:25:51,610
straight out of the box and there are

00:25:49,630 --> 00:25:53,230
some efforts showed it to supreme Cloud

00:25:51,610 --> 00:25:55,480
pipelines

00:25:53,230 --> 00:25:57,190
I know Marcin is doing a great job with

00:25:55,480 --> 00:25:58,930
that stuff it didn't quite fit our use

00:25:57,190 --> 00:26:00,370
case we'd kind of gone far enough down

00:25:58,930 --> 00:26:04,450
the road that we hadn't weren't able to

00:26:00,370 --> 00:26:06,670
use it but it really depends on like how

00:26:04,450 --> 00:26:08,380
much control you want to give up so so

00:26:06,670 --> 00:26:09,790
if you want to do everything for your

00:26:08,380 --> 00:26:11,650
developers or as much as possible they

00:26:09,790 --> 00:26:13,990
may end up writing stuff yourself so

00:26:11,650 --> 00:26:15,820
nothing is going to end up creating you

00:26:13,990 --> 00:26:17,440
know Kafka an elastic search as well so

00:26:15,820 --> 00:26:19,570
if you want to do just deploy to PCF

00:26:17,440 --> 00:26:21,580
then that's okay and so the idea that

00:26:19,570 --> 00:26:23,920
that we want to do is on top of this is

00:26:21,580 --> 00:26:26,440
well add the security checks we'll add

00:26:23,920 --> 00:26:28,240
whatever bits they're currently manual

00:26:26,440 --> 00:26:30,760
processes in here as automated checks

00:26:28,240 --> 00:26:33,070
but if if we use something out of the

00:26:30,760 --> 00:26:34,870
box and is that availability is that is

00:26:33,070 --> 00:26:42,420
that feature available so it's kind of

00:26:34,870 --> 00:26:42,420
the trade-off anyone else yeah

00:26:46,030 --> 00:26:51,160
yeah it's we just end up calling

00:26:48,880 --> 00:26:54,370
different API is at different points but

00:26:51,160 --> 00:26:56,770
the the idea is we do a CF push with a

00:26:54,370 --> 00:26:59,590
lot of the no option so - - nil pretty

00:26:56,770 --> 00:27:02,950
much everything and then then we'll

00:26:59,590 --> 00:27:04,630
assign a temp route to it which is

00:27:02,950 --> 00:27:07,960
really all we need and then eventually

00:27:04,630 --> 00:27:09,910
we'll we'll assign the real route to it

00:27:07,960 --> 00:27:11,980
delete the temper out and delete what

00:27:09,910 --> 00:27:13,870
the railroad used to be playing - and

00:27:11,980 --> 00:27:16,030
then we'll clean up any applications

00:27:13,870 --> 00:27:21,130
that that were there from failed deploys

00:27:16,030 --> 00:27:23,560
in the past so it is it is sadly a a set

00:27:21,130 --> 00:27:24,910
of just like making a bunch of steps and

00:27:23,560 --> 00:27:28,350
the same way to pipe together a bunch of

00:27:24,910 --> 00:27:33,850
Unix commands it's really the way we did

00:27:28,350 --> 00:27:41,710
yeah so the question is how long did it

00:27:33,850 --> 00:27:44,560
take us to get there yes so probably

00:27:41,710 --> 00:27:47,320
about three months from from the time

00:27:44,560 --> 00:27:49,360
we'd finish the second pipeline to here

00:27:47,320 --> 00:27:51,220
and a lot of that quite frankly was

00:27:49,360 --> 00:27:53,110
spent deciding which direction we want

00:27:51,220 --> 00:27:54,280
to go like making decisions I stand up

00:27:53,110 --> 00:27:56,800
here and say we're using multi repo

00:27:54,280 --> 00:27:58,060
analysis so easy but but again to the

00:27:56,800 --> 00:27:59,740
point where we decide that that's the

00:27:58,060 --> 00:28:02,020
right thing we wanna do and like oh we

00:27:59,740 --> 00:28:03,550
want to do we want to do Jenkins and all

00:28:02,020 --> 00:28:05,620
we want to use the github org plug-in in

00:28:03,550 --> 00:28:07,540
in in Jenkins and all we want to use

00:28:05,620 --> 00:28:08,710
docker like these sort of questions and

00:28:07,540 --> 00:28:10,030
like how much control do we give to

00:28:08,710 --> 00:28:12,180
developers was really where we spent a

00:28:10,030 --> 00:28:14,350
lot of our time decoding it up wasn't

00:28:12,180 --> 00:28:15,910
terribly important it's terribly

00:28:14,350 --> 00:28:17,440
difficult I mean it still took time but

00:28:15,910 --> 00:28:23,350
the hardest bit was kind of figuring out

00:28:17,440 --> 00:28:25,360
what we wanted to do there good yeah so

00:28:23,350 --> 00:28:27,460
the question do we look at Concours yeah

00:28:25,360 --> 00:28:28,720
so they're kind of two parts of the

00:28:27,460 --> 00:28:31,360
cloud team and I receive so there's the

00:28:28,720 --> 00:28:33,790
platform team which runs cloud foundry

00:28:31,360 --> 00:28:36,400
and Kafka and elasticsearch and they use

00:28:33,790 --> 00:28:39,220
concourse for that for the development

00:28:36,400 --> 00:28:41,410
side we didn't have enough experience

00:28:39,220 --> 00:28:42,550
and I played around with concourse a bit

00:28:41,410 --> 00:28:45,130
and one of the problems I found was that

00:28:42,550 --> 00:28:48,040
you have to build an office better yet

00:28:45,130 --> 00:28:49,270
so so if anyone but but you have to

00:28:48,040 --> 00:28:51,370
build a lot of the things you get for

00:28:49,270 --> 00:28:52,930
free out of the box with Jenkins stuff

00:28:51,370 --> 00:28:54,790
like having a workspace that carries

00:28:52,930 --> 00:28:56,440
through all the way like on all your

00:28:54,790 --> 00:28:58,690
docker images I'm sorry all your docker

00:28:56,440 --> 00:28:59,299
containers stuff like that you kind of

00:28:58,690 --> 00:29:00,320
get for free

00:28:59,299 --> 00:29:03,470
with Jenkins and we had a ton of

00:29:00,320 --> 00:29:05,779
experience I think between us there was

00:29:03,470 --> 00:29:08,239
something like 30 years of administering

00:29:05,779 --> 00:29:10,489
Jenkins so we had a ton of familiarity

00:29:08,239 --> 00:29:13,360
so it felt silly to throw that away when

00:29:10,489 --> 00:29:16,720
we had so many other questions to answer

00:29:13,360 --> 00:29:16,720
and about good

00:29:19,929 --> 00:29:23,779
so the chat yeah the chaplet so the chat

00:29:22,220 --> 00:29:26,210
pod isn't implemented so this is all

00:29:23,779 --> 00:29:28,190
kind of theoretical but I will talk

00:29:26,210 --> 00:29:29,629
about how the chat pod works so the idea

00:29:28,190 --> 00:29:31,549
is it is a PCF service

00:29:29,629 --> 00:29:34,789
yeah that would talk to in this case

00:29:31,549 --> 00:29:37,940
slack and and the ideas that would say

00:29:34,789 --> 00:29:40,700
hey your builds done and then and then

00:29:37,940 --> 00:29:43,309
halyard deploys done etc and then for

00:29:40,700 --> 00:29:44,960
higher level environments you would ask

00:29:43,309 --> 00:29:46,940
it to deploy that application that would

00:29:44,960 --> 00:29:48,529
be your interface so instead of going to

00:29:46,940 --> 00:29:49,759
the UI and Jenkins and say you know

00:29:48,529 --> 00:29:52,899
click to the floor you would go do

00:29:49,759 --> 00:29:52,899
through a chat bot so that's the idea

00:29:54,070 --> 00:29:59,299
anyone else

00:29:57,159 --> 00:30:01,249
awesome all right thanks so much for

00:29:59,299 --> 00:30:03,340
thanks so much for listening appreciate

00:30:01,249 --> 00:30:03,340

YouTube URL: https://www.youtube.com/watch?v=-OoOqtGhTSU


