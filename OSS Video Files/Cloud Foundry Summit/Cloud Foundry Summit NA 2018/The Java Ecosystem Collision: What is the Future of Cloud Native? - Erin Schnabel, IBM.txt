Title: The Java Ecosystem Collision: What is the Future of Cloud Native? - Erin Schnabel, IBM
Publication date: 2018-04-21
Playlist: Cloud Foundry Summit NA 2018
Description: 
	The Java Ecosystem Collision: What is the Future of Cloud Native? - Erin Schnabel, IBM

 Changes in cloud orchestration technologies have started to push the boundaries between Cloud Native applications and their environment.

The notion of smart endpoints gave rise to shared libraries, like Ribbon from Netflix, to encapsulate outbound service discovery, load balancing, and fault tolerance. Now new technologies, like Istio, call that paradigm into question, suggesting those concerns should move out of the app and back into the infrastructure. What does that mean for Java applications using Netflix integrations in Spring Cloud?

The emergence of reactive programming is also pressing against the dominance of REST. Should everything be reactive now?

From shared libraries to sidecars, buildpacks to containers, Erin will demonstrate how different Java application frameworks are adapting to the changing Cloud Native landscape. 

About Erin Schnabel
Erin Schnabel is a Senior Technical Staff Member at IBM working with microservice architectures, cloud native applications, composable runtimes and Java. Erin has more years of experience than she cares to admit, and was the former Development Lead for WebSphere Liberty. Erin is passionate about the Java developer's experience, particularly with respect to the role of community-driven, open source or standards-compliant software in the cloud environment, and strongly prefers being up to her elbows in code.
Captions: 
	00:00:00,000 --> 00:00:04,589
so what I want to talk about today there

00:00:03,060 --> 00:00:07,080
is all kinds of really cool stuff

00:00:04,589 --> 00:00:08,639
happening both with Java and with cloud

00:00:07,080 --> 00:00:10,019
native and all of it is smashing

00:00:08,639 --> 00:00:11,429
together and it's raising some very

00:00:10,019 --> 00:00:12,900
interesting questions about what on

00:00:11,429 --> 00:00:14,940
earth we are going to do next

00:00:12,900 --> 00:00:18,350
as Heather pointed out and I mentioned a

00:00:14,940 --> 00:00:22,109
little bit earlier I do not in this deck

00:00:18,350 --> 00:00:24,150
have information about Scala or Kotlin

00:00:22,109 --> 00:00:26,609
or other innovations happening on top of

00:00:24,150 --> 00:00:30,269
the JVM although to some to some extent

00:00:26,609 --> 00:00:32,070
they definitely fit in this space I want

00:00:30,269 --> 00:00:33,540
to take a second we're gonna everybody

00:00:32,070 --> 00:00:35,309
should know what cloud native is but I

00:00:33,540 --> 00:00:36,809
still get hilarious comments from people

00:00:35,309 --> 00:00:38,940
that I wanted to actually talk about I

00:00:36,809 --> 00:00:40,680
had someone say that in order to be a

00:00:38,940 --> 00:00:43,170
cloud native application you actually

00:00:40,680 --> 00:00:45,539
have to use cloud only backing services

00:00:43,170 --> 00:00:47,010
like object storage if you not if you

00:00:45,539 --> 00:00:50,039
use object storage you're doing it wrong

00:00:47,010 --> 00:00:51,809
I can't even really and I had somebody

00:00:50,039 --> 00:00:53,850
else say it's not a cloud native

00:00:51,809 --> 00:00:55,920
application unless your team is using

00:00:53,850 --> 00:00:58,410
agile practices is using DevOps

00:00:55,920 --> 00:01:00,989
is totally your little team is involved

00:00:58,410 --> 00:01:03,030
is is on the hook for 24/7 operations

00:01:00,989 --> 00:01:04,710
using pager duty if all of those things

00:01:03,030 --> 00:01:08,070
are not true you also do not have a true

00:01:04,710 --> 00:01:09,900
cloud native application I'm sorry also

00:01:08,070 --> 00:01:13,320
wrong there is very much a culture

00:01:09,900 --> 00:01:15,479
portion to being you know to be active

00:01:13,320 --> 00:01:17,970
in a cloud native environment DevOps is

00:01:15,479 --> 00:01:20,729
definitely a thing there are many

00:01:17,970 --> 00:01:22,920
different ways to approach managing

00:01:20,729 --> 00:01:24,420
uptime not everybody does page or duty

00:01:22,920 --> 00:01:28,409
for the actual team there's plenty of

00:01:24,420 --> 00:01:31,290
other ways to take care of that so I

00:01:28,409 --> 00:01:33,600
just find that hilarious if we want to

00:01:31,290 --> 00:01:36,619
go back to a definition the cloud native

00:01:33,600 --> 00:01:38,729
computing foundation has a definition

00:01:36,619 --> 00:01:40,200
interestingly to me they talk about

00:01:38,729 --> 00:01:41,180
their applications cloud native

00:01:40,200 --> 00:01:43,530
applications being micro

00:01:41,180 --> 00:01:45,810
service-oriented which certainly leaves

00:01:43,530 --> 00:01:47,070
room for the micro lift the thing you

00:01:45,810 --> 00:01:48,030
only have one of because that's what

00:01:47,070 --> 00:01:49,950
you're starting with and you're not

00:01:48,030 --> 00:01:51,390
starting with an insane everything right

00:01:49,950 --> 00:01:54,600
you got room for the micro lifts there

00:01:51,390 --> 00:01:57,750
which is good the big part is you're

00:01:54,600 --> 00:02:00,810
loosely coupled write all of your

00:01:57,750 --> 00:02:03,750
dependencies are explicitly declared

00:02:00,810 --> 00:02:05,040
your container packaged various kinds of

00:02:03,750 --> 00:02:07,409
containers right this is where Bill

00:02:05,040 --> 00:02:10,830
pecks come in docker comes in the big

00:02:07,409 --> 00:02:12,239
point here is that last the last couple

00:02:10,830 --> 00:02:14,609
things where

00:02:12,239 --> 00:02:16,500
the single biggest characteristic of a

00:02:14,609 --> 00:02:20,099
cloud native application is that it can

00:02:16,500 --> 00:02:22,260
be managed it can be orchestrated right

00:02:20,099 --> 00:02:25,140
it is stateless it lives in a box it

00:02:22,260 --> 00:02:26,819
fits well so that all of this automation

00:02:25,140 --> 00:02:29,189
stuff can happen that has ramifications

00:02:26,819 --> 00:02:31,680
into how you write your application but

00:02:29,189 --> 00:02:32,939
that is the key thing if you're writing

00:02:31,680 --> 00:02:34,280
a cloud native application you're

00:02:32,939 --> 00:02:36,540
writing something that can be

00:02:34,280 --> 00:02:39,090
dynamically managed by some

00:02:36,540 --> 00:02:42,480
orchestration mechanism 12 factor fits

00:02:39,090 --> 00:02:44,040
right in here all of those points write

00:02:42,480 --> 00:02:45,930
all of those factors are all about how

00:02:44,040 --> 00:02:49,769
you write an app that is orchestrate a

00:02:45,930 --> 00:02:51,299
bowl will say now I'm going to show a

00:02:49,769 --> 00:02:53,790
couple things about micro services

00:02:51,299 --> 00:02:56,159
because this is our shared pain this is

00:02:53,790 --> 00:02:58,739
why we're doing this right I like to say

00:02:56,159 --> 00:03:01,560
well we all like to bad-mouth the

00:02:58,739 --> 00:03:03,030
monoliths right now the big dinosaurs we

00:03:01,560 --> 00:03:04,680
should remember that the big dinosaurs

00:03:03,030 --> 00:03:05,790
are incredibly capable and they are

00:03:04,680 --> 00:03:07,530
powering those through the world's

00:03:05,790 --> 00:03:09,629
internet right now they are not

00:03:07,530 --> 00:03:12,329
inherently evil but they cause us pain

00:03:09,629 --> 00:03:14,069
right they causes problems they make it

00:03:12,329 --> 00:03:16,109
hard to innovate they make it hard to

00:03:14,069 --> 00:03:19,470
iterate they make it hard to experiment

00:03:16,109 --> 00:03:22,129
and that pain is why we're starting to

00:03:19,470 --> 00:03:24,959
move from monoliths to micro services

00:03:22,129 --> 00:03:25,349
and we're trading off pain it to some

00:03:24,959 --> 00:03:31,109
extent

00:03:25,349 --> 00:03:33,000
right we also came we took pain and we

00:03:31,109 --> 00:03:34,530
kind of made pain worse right we decided

00:03:33,000 --> 00:03:35,790
we really wanted an under price service

00:03:34,530 --> 00:03:37,319
bus because we wanted to have

00:03:35,790 --> 00:03:38,970
service-oriented architecture and have

00:03:37,319 --> 00:03:41,430
all of these pieces being able to talk

00:03:38,970 --> 00:03:44,069
to each other and so we took our

00:03:41,430 --> 00:03:47,669
monoliths and we wrapped them in soap

00:03:44,069 --> 00:03:50,250
and jax-ws and exposed all of our

00:03:47,669 --> 00:03:51,959
internal details to everything else now

00:03:50,250 --> 00:03:55,259
I should also be clear like I want us to

00:03:51,959 --> 00:03:57,509
understand systems that use Enterprise

00:03:55,259 --> 00:03:59,549
Service bus are also incredibly capable

00:03:57,509 --> 00:04:03,389
they are in places you would not believe

00:03:59,549 --> 00:04:04,949
doing amazing things and they're like

00:04:03,389 --> 00:04:07,199
people who are trying to replace them or

00:04:04,949 --> 00:04:08,970
like I have no idea how to replace this

00:04:07,199 --> 00:04:10,319
capability it is fundamental to our

00:04:08,970 --> 00:04:13,500
business it is awesome

00:04:10,319 --> 00:04:15,030
but they can't make any changes because

00:04:13,500 --> 00:04:17,909
to change one thing they have to change

00:04:15,030 --> 00:04:19,739
everything and that's the pain right

00:04:17,909 --> 00:04:21,450
that's so I just want to make sure we're

00:04:19,739 --> 00:04:23,610
all remembering our shared agony here

00:04:21,450 --> 00:04:25,440
because everything that we're doing next

00:04:23,610 --> 00:04:30,720
right is trying to walk away

00:04:25,440 --> 00:04:32,550
from this shared history the ideal when

00:04:30,720 --> 00:04:34,290
Netflix and Twitter started coming out

00:04:32,550 --> 00:04:36,240
this is this was a tweet that's probably

00:04:34,290 --> 00:04:38,130
four years old now I love it because

00:04:36,240 --> 00:04:40,560
it's Adrian Cockroft sitting in the

00:04:38,130 --> 00:04:43,140
audience taking a picture of Twitter's

00:04:40,560 --> 00:04:44,730
interaction diagram and saying hey ours

00:04:43,140 --> 00:04:46,680
looks kind of the same and we call it

00:04:44,730 --> 00:04:47,940
the Deathstar diagram you guys can't see

00:04:46,680 --> 00:04:49,860
it I totally have a star wars t-shirt

00:04:47,940 --> 00:04:51,660
underneath the sweatshirt I'm a big star

00:04:49,860 --> 00:04:54,930
Wars fan so I thought that was just

00:04:51,660 --> 00:04:56,750
generally hilarious we know that in

00:04:54,930 --> 00:04:59,310
order to get to those big environments

00:04:56,750 --> 00:05:00,810
that automation is huge this again gets

00:04:59,310 --> 00:05:02,760
back to the fundamental concept these

00:05:00,810 --> 00:05:04,590
things have to be orchestrated well you

00:05:02,760 --> 00:05:09,480
have to have automation or you will lose

00:05:04,590 --> 00:05:11,900
your mind zero downtime upgrades right

00:05:09,480 --> 00:05:14,820
all this stuff it goes back to our pain

00:05:11,900 --> 00:05:18,960
we have to do weekend outages because we

00:05:14,820 --> 00:05:20,850
have to upgrade the entire system we

00:05:18,960 --> 00:05:22,860
have to be able to do automatic scaling

00:05:20,850 --> 00:05:24,480
we're not going to bother making all

00:05:22,860 --> 00:05:26,700
these little stateless services if we

00:05:24,480 --> 00:05:29,580
can't scale them automatically real-time

00:05:26,700 --> 00:05:30,720
monitoring is important as is I'm sure

00:05:29,580 --> 00:05:32,580
most of you know with Cloud Foundry

00:05:30,720 --> 00:05:34,350
getting all of your logging and tracing

00:05:32,580 --> 00:05:36,540
data out of the process because the

00:05:34,350 --> 00:05:40,470
process will disappear and if you don't

00:05:36,540 --> 00:05:41,880
have the data out it all is gone so some

00:05:40,470 --> 00:05:43,760
of this I'm hoping all of this is like

00:05:41,880 --> 00:05:48,690
yes yes yes we know we know we know

00:05:43,760 --> 00:05:50,190
should be good so this puts oh I'm

00:05:48,690 --> 00:05:52,140
calling this out explicitly for a couple

00:05:50,190 --> 00:05:55,440
of reasons but this puts burden on the

00:05:52,140 --> 00:05:58,140
developer at least at first we'll talk

00:05:55,440 --> 00:05:59,669
about that so we are talking about these

00:05:58,140 --> 00:06:01,020
ephemeral processes that are stateless

00:05:59,669 --> 00:06:03,780
again we're going to be elastically

00:06:01,020 --> 00:06:06,380
scaled when we say stateless we mean you

00:06:03,780 --> 00:06:09,360
cannot count on the application that

00:06:06,380 --> 00:06:11,730
in-memory process process that has

00:06:09,360 --> 00:06:13,530
session data for example in memory you

00:06:11,730 --> 00:06:14,520
can't count on that process still being

00:06:13,530 --> 00:06:17,100
there you're gonna go through the

00:06:14,520 --> 00:06:19,110
round-trip and in the meanwhile the the

00:06:17,100 --> 00:06:21,360
process got tossed maybe it was sick

00:06:19,110 --> 00:06:22,980
maybe wasn't needed anymore and there's

00:06:21,360 --> 00:06:25,980
nobody for you to bring that staple

00:06:22,980 --> 00:06:27,570
session back to it's gone and so that

00:06:25,980 --> 00:06:29,220
changes when you start looking at people

00:06:27,570 --> 00:06:30,780
writing applications that come from the

00:06:29,220 --> 00:06:33,450
old environment they're like but I have

00:06:30,780 --> 00:06:34,890
stateful sessions so it's like you have

00:06:33,450 --> 00:06:37,080
to change your thinking about how you're

00:06:34,890 --> 00:06:38,939
going to deal with session

00:06:37,080 --> 00:06:40,979
that sticky session as' because that

00:06:38,939 --> 00:06:44,639
doesn't necessarily apply here anymore

00:06:40,979 --> 00:06:46,020
you have to expect rubbish part of why

00:06:44,639 --> 00:06:47,520
we're doing this right with all the

00:06:46,020 --> 00:06:49,560
pieces everywhere so people can

00:06:47,520 --> 00:06:50,639
experiment they can evolve and all of

00:06:49,560 --> 00:06:53,580
these pieces can evolve independently

00:06:50,639 --> 00:06:56,060
and this is a point for everybody that's

00:06:53,580 --> 00:07:00,090
writing Java because it's especially

00:06:56,060 --> 00:07:04,050
this can happen to us by accident so we

00:07:00,090 --> 00:07:07,319
love Jackson right we love Jackson now

00:07:04,050 --> 00:07:09,060
the problem is if you use Jackson you're

00:07:07,319 --> 00:07:12,389
automatically serializing a JSON object

00:07:09,060 --> 00:07:13,979
to and from your data stream how many

00:07:12,389 --> 00:07:15,539
people are reflexively at this point

00:07:13,979 --> 00:07:17,819
saying ignore unknown fields because you

00:07:15,539 --> 00:07:19,620
had better be right like or you are

00:07:17,819 --> 00:07:21,990
implicitly fragile you are not robust

00:07:19,620 --> 00:07:24,090
there's another piece to this which also

00:07:21,990 --> 00:07:25,560
people who has tried Jackson views the

00:07:24,090 --> 00:07:28,830
JSON views that Jackson has have you

00:07:25,560 --> 00:07:30,330
tried them oh then that means you are

00:07:28,830 --> 00:07:32,069
very likely exposing all of your

00:07:30,330 --> 00:07:33,360
internal details to everybody else

00:07:32,069 --> 00:07:35,310
because you're taking your model and

00:07:33,360 --> 00:07:38,580
just dumping it you're giving yourself

00:07:35,310 --> 00:07:41,520
no room how many people use D TOS that

00:07:38,580 --> 00:07:43,650
are separate from their models that's

00:07:41,520 --> 00:07:45,690
safer right you're giving yourself some

00:07:43,650 --> 00:07:47,490
pattern it's a padding if you look at

00:07:45,690 --> 00:07:49,169
domain-driven design from Eric Evans

00:07:47,490 --> 00:07:52,589
they call that an anti-corruption layer

00:07:49,169 --> 00:07:54,330
which i think is hilarious but it's that

00:07:52,589 --> 00:07:56,339
kind of thing for Java developers that

00:07:54,330 --> 00:07:59,000
robustness stuff is really easy to miss

00:07:56,339 --> 00:08:01,680
because we love ourselves some Jackson

00:07:59,000 --> 00:08:03,330
fault-tolerance we know we have to be

00:08:01,680 --> 00:08:04,860
fault-tolerant there's stuff we have to

00:08:03,330 --> 00:08:07,909
do in our application to make sure that

00:08:04,860 --> 00:08:10,800
errors don't cascade through the system

00:08:07,909 --> 00:08:13,949
we have to fail fast we want to be able

00:08:10,800 --> 00:08:16,409
to define our callbacks or our yeah

00:08:13,949 --> 00:08:18,300
callbacks and fall backs and retries and

00:08:16,409 --> 00:08:20,039
all that stuff that's we'll get to why

00:08:18,300 --> 00:08:21,599
this is important anyway but here we

00:08:20,039 --> 00:08:23,099
have we just have more moving moving

00:08:21,599 --> 00:08:25,889
pieces the application developer has

00:08:23,099 --> 00:08:27,000
responsible for more things so far so

00:08:25,889 --> 00:08:29,129
good

00:08:27,000 --> 00:08:30,719
all this stuff right it's not easy it's

00:08:29,129 --> 00:08:33,779
not easy to do it's not easy to get

00:08:30,719 --> 00:08:35,550
right so some of this is provided by the

00:08:33,779 --> 00:08:37,349
orchestration layer that could be Cloud

00:08:35,550 --> 00:08:39,990
Foundry that could be kubernetes in both

00:08:37,349 --> 00:08:41,339
cases consistent with 12 factors they're

00:08:39,990 --> 00:08:43,469
saying the infrastructure should handle

00:08:41,339 --> 00:08:45,120
some of this but there's a lot of it

00:08:43,469 --> 00:08:47,399
that the developer still has to do and

00:08:45,120 --> 00:08:50,490
that was the beginning of Netflix right

00:08:47,399 --> 00:08:50,970
in the Netflix engineers I think it was

00:08:50,490 --> 00:08:52,920
it was a

00:08:50,970 --> 00:08:54,870
drinking craft who quoted it at one time

00:08:52,920 --> 00:08:56,370
he's like not everybody is going to be

00:08:54,870 --> 00:08:58,620
really good at all of this stuff so

00:08:56,370 --> 00:08:59,610
we're gonna make a set of libraries so

00:08:58,620 --> 00:09:01,050
that you have the really smart people

00:08:59,610 --> 00:09:02,519
who could do this stuff and they can do

00:09:01,050 --> 00:09:07,850
it once and then everybody can use what

00:09:02,519 --> 00:09:10,529
they did Eureka for service discovery

00:09:07,850 --> 00:09:13,889
Zul which is your health aware API

00:09:10,529 --> 00:09:15,120
gateway ribbon for client-side load

00:09:13,889 --> 00:09:16,410
balancing I'll come back to that

00:09:15,120 --> 00:09:21,120
everybody should have heard of those

00:09:16,410 --> 00:09:22,769
right hystrix and turbine are huge the

00:09:21,120 --> 00:09:24,660
good thing about historic sand turbine

00:09:22,769 --> 00:09:26,459
is the amount of data that they collect

00:09:24,660 --> 00:09:28,199
from the point of view of the client

00:09:26,459 --> 00:09:31,230
there's all kinds of other things you

00:09:28,199 --> 00:09:32,819
can measure at the network layer but

00:09:31,230 --> 00:09:34,620
hysteresis is the one that says I

00:09:32,819 --> 00:09:36,899
actually tried to make the call and this

00:09:34,620 --> 00:09:38,699
is how well it behaved right so that

00:09:36,899 --> 00:09:41,579
kind of feedback is incredibly important

00:09:38,699 --> 00:09:43,470
history is really really popular and

00:09:41,579 --> 00:09:51,120
they also have a metrics library and

00:09:43,470 --> 00:09:53,550
Arceus configuration so spring everybody

00:09:51,120 --> 00:09:56,670
who's used spring just just a few people

00:09:53,550 --> 00:10:00,540
have used spring so so spring cloud

00:09:56,670 --> 00:10:02,519
netflix combines the Netflix libraries

00:10:00,540 --> 00:10:05,779
right with with what spring cloud

00:10:02,519 --> 00:10:08,129
provides and in some cases there's

00:10:05,779 --> 00:10:11,129
spring as doing things that Netflix

00:10:08,129 --> 00:10:14,160
didn't do right so spring cloud has

00:10:11,129 --> 00:10:16,170
sleuth who's you sleuth for distributed

00:10:14,160 --> 00:10:18,779
tracing right Netflix didn't have a

00:10:16,170 --> 00:10:24,809
library for that so spring is filling a

00:10:18,779 --> 00:10:26,519
gap there Spring has has some security

00:10:24,809 --> 00:10:30,949
aspects and stuff again Netflix didn't

00:10:26,519 --> 00:10:33,329
do that what is interesting here is

00:10:30,949 --> 00:10:35,009
Spring has made using Netflix really

00:10:33,329 --> 00:10:37,559
really easy I think at this point based

00:10:35,009 --> 00:10:40,230
on on cursory googles of the interweb

00:10:37,559 --> 00:10:41,970
lately there's absolutely no real useful

00:10:40,230 --> 00:10:44,910
way to start a eureka server if you

00:10:41,970 --> 00:10:48,029
don't use spring for example they have

00:10:44,910 --> 00:10:51,689
officially like you know they've made it

00:10:48,029 --> 00:10:55,339
so easy there's no other way I found

00:10:51,689 --> 00:10:58,670
that really hilarious by the way but

00:10:55,339 --> 00:11:00,170
we know also that kubernetes is coming

00:10:58,670 --> 00:11:02,120
on pretty strong right now as an

00:11:00,170 --> 00:11:05,089
orchestration layer and there's a whole

00:11:02,120 --> 00:11:06,769
bunch that kubernetes already knows you

00:11:05,089 --> 00:11:08,060
don't need a service discovery mechanism

00:11:06,769 --> 00:11:12,259
if kubernetes already knows all the

00:11:08,060 --> 00:11:14,629
services that are involved for just the

00:11:12,259 --> 00:11:15,740
biggest example right so Spring has it

00:11:14,629 --> 00:11:18,319
has anybody looked at spring cloud

00:11:15,740 --> 00:11:20,360
kubernetes so spring cloud kubernetes is

00:11:18,319 --> 00:11:22,249
taking some of the spring cloud concepts

00:11:20,360 --> 00:11:24,589
including the discovery client for

00:11:22,249 --> 00:11:27,620
example or the ribbon client and as

00:11:24,589 --> 00:11:30,740
making those run on top of native

00:11:27,620 --> 00:11:31,939
capabilities of kubernetes so you don't

00:11:30,740 --> 00:11:34,309
have to deal with a eureka server

00:11:31,939 --> 00:11:35,959
anymore right you're relying on the

00:11:34,309 --> 00:11:37,999
infrastructure that kubernetes provides

00:11:35,959 --> 00:11:40,129
and the information that kubernetes has

00:11:37,999 --> 00:11:44,269
to be able to do your service discovery

00:11:40,129 --> 00:11:49,040
your your routing etc and they also have

00:11:44,269 --> 00:11:50,779
some adaptations for taking spring cloud

00:11:49,040 --> 00:11:52,790
or spring actually just spring

00:11:50,779 --> 00:11:53,839
configuration mechanisms and mapping

00:11:52,790 --> 00:11:56,180
those down into the configuration

00:11:53,839 --> 00:11:58,220
capabilities that kubernetes has that's

00:11:56,180 --> 00:12:01,009
pushing more responsibilities down into

00:11:58,220 --> 00:12:03,139
the infrastructure in all seriousness

00:12:01,009 --> 00:12:05,750
and it's taking some of it out of the

00:12:03,139 --> 00:12:07,910
application space I have to be careful

00:12:05,750 --> 00:12:11,569
I'm going to go too fast I do that all

00:12:07,910 --> 00:12:14,029
the time what I like about the side and

00:12:11,569 --> 00:12:18,050
that to be fair some of this applies

00:12:14,029 --> 00:12:19,430
also to Cloud Foundry I think one of the

00:12:18,050 --> 00:12:20,540
interesting things between kubernetes

00:12:19,430 --> 00:12:23,240
and Cloud Foundry is how they treat

00:12:20,540 --> 00:12:25,370
proxies and Cloud Foundry you have the

00:12:23,240 --> 00:12:27,110
go router go router sitting in front of

00:12:25,370 --> 00:12:29,930
your elastically scaled services in

00:12:27,110 --> 00:12:32,110
kubernetes you have the the kubernetes

00:12:29,930 --> 00:12:36,079
proxy that's ingress egress to the pod

00:12:32,110 --> 00:12:37,730
so how they are used and and happen you

00:12:36,079 --> 00:12:40,160
know what linkage you use to get there

00:12:37,730 --> 00:12:46,279
is different conceptually they're the

00:12:40,160 --> 00:12:48,170
same because of where because of where

00:12:46,279 --> 00:12:53,980
and how these things live like there's

00:12:48,170 --> 00:12:56,509
ways to configure Zul and possibly I

00:12:53,980 --> 00:12:59,920
haven't done this in a while there's

00:12:56,509 --> 00:13:02,300
ways to configure Zul I believe and also

00:12:59,920 --> 00:13:04,939
ribbon or Eureka or somebody to go

00:13:02,300 --> 00:13:06,649
through still the go router so you can

00:13:04,939 --> 00:13:08,170
still bring the go router back into that

00:13:06,649 --> 00:13:10,240
because the go router does in

00:13:08,170 --> 00:13:12,550
know who's behind it and what state

00:13:10,240 --> 00:13:14,529
they're in and so it's again you kind of

00:13:12,550 --> 00:13:16,450
have a redundant system if you have a

00:13:14,529 --> 00:13:18,730
Eureka up here you have to register and

00:13:16,450 --> 00:13:20,410
D register with with Eureka maintain

00:13:18,730 --> 00:13:23,050
your state there when in theory the

00:13:20,410 --> 00:13:25,329
infrastructure already knows you're

00:13:23,050 --> 00:13:27,699
doing a bit of redundant activity and

00:13:25,329 --> 00:13:29,290
part of that is because of zone

00:13:27,699 --> 00:13:30,670
awareness for example so one of the

00:13:29,290 --> 00:13:32,560
things that you can do when you're

00:13:30,670 --> 00:13:34,510
working with with spring cloud and

00:13:32,560 --> 00:13:36,160
ribbon and stuff as you can be zone

00:13:34,510 --> 00:13:38,110
aware now the problem that I have with

00:13:36,160 --> 00:13:40,959
this is every application developer is

00:13:38,110 --> 00:13:42,760
putting that config in their app every

00:13:40,959 --> 00:13:45,610
application developer is defining their

00:13:42,760 --> 00:13:48,160
load balancing policy that is way too

00:13:45,610 --> 00:13:50,529
detailed for what you usually need at an

00:13:48,160 --> 00:13:51,639
app level there's no reason to put it

00:13:50,529 --> 00:13:56,760
there

00:13:51,639 --> 00:14:00,250
in addition retry policies are actually

00:13:56,760 --> 00:14:02,410
harder to get right than might appear on

00:14:00,250 --> 00:14:04,389
the surface right who does the correct

00:14:02,410 --> 00:14:06,070
exponential back-off and do you actually

00:14:04,389 --> 00:14:08,800
know when to stop the exponential

00:14:06,070 --> 00:14:10,540
back-off and just stop did you do it

00:14:08,800 --> 00:14:12,360
right right are you still flogging the

00:14:10,540 --> 00:14:15,070
dead horse yes a circuit breaker helps

00:14:12,360 --> 00:14:17,740
but you can have serious echo problems

00:14:15,070 --> 00:14:18,670
with everybody trying to retry because

00:14:17,740 --> 00:14:20,470
there's no way to short-circuit

00:14:18,670 --> 00:14:22,180
everybody doing their exponential

00:14:20,470 --> 00:14:26,019
back-off retry you still have a lot of

00:14:22,180 --> 00:14:28,089
noise and so this is where envoy comes

00:14:26,019 --> 00:14:30,730
in the envoy sidecar which is now part

00:14:28,089 --> 00:14:33,070
of ISTE oh and the Envoy sidecar is

00:14:30,730 --> 00:14:37,630
language agnostic it's out of process to

00:14:33,070 --> 00:14:39,430
be fair Netflix has piranha Spring has a

00:14:37,630 --> 00:14:42,930
wrapper around piranhas so you could do

00:14:39,430 --> 00:14:45,339
a JVM based sidecar JVMs are not cheap

00:14:42,930 --> 00:14:48,130
right they're pretty big so to have a

00:14:45,339 --> 00:14:50,380
JVM as a sidecar as a bit inefficient so

00:14:48,130 --> 00:14:53,470
part of what is good about envoy is it

00:14:50,380 --> 00:14:55,720
is I think it's C and C++ I don't think

00:14:53,470 --> 00:14:59,050
it's go but it's it's much more compact

00:14:55,720 --> 00:15:01,959
and small but it still gives you content

00:14:59,050 --> 00:15:04,660
aware smart routing capabilities that do

00:15:01,959 --> 00:15:06,579
a lot more at the network level so they

00:15:04,660 --> 00:15:10,389
can be it's a lot more intelligent and

00:15:06,579 --> 00:15:11,889
because it is aware and if you think

00:15:10,389 --> 00:15:13,449
about the way kubernetes knows how

00:15:11,889 --> 00:15:15,010
things work and knows where the cluster

00:15:13,449 --> 00:15:16,839
is it can short-circuit and cut out all

00:15:15,010 --> 00:15:19,269
retries when I know somebody's down like

00:15:16,839 --> 00:15:20,070
you actually have the ability to really

00:15:19,269 --> 00:15:22,140
cut down on your

00:15:20,070 --> 00:15:24,750
try to effing traffic because you know

00:15:22,140 --> 00:15:28,440
way more down at that level than you do

00:15:24,750 --> 00:15:30,750
inside the app there's also the

00:15:28,440 --> 00:15:32,460
interesting thing about envoy is and

00:15:30,750 --> 00:15:34,860
there's some other talks about that

00:15:32,460 --> 00:15:37,710
later the motivation behind envoy right

00:15:34,860 --> 00:15:40,890
is you have lots of people in the

00:15:37,710 --> 00:15:42,660
company all producing applications in

00:15:40,890 --> 00:15:44,700
the case of where lyft was they're not

00:15:42,660 --> 00:15:46,890
all in Java right there's multiple

00:15:44,700 --> 00:15:48,630
languages going on and you have

00:15:46,890 --> 00:15:50,340
different skill levels of developers

00:15:48,630 --> 00:15:52,620
push you know putting out these apps

00:15:50,340 --> 00:15:53,760
which means there's different levels of

00:15:52,620 --> 00:15:56,610
awareness of whether or not they should

00:15:53,760 --> 00:15:58,170
add certain kinds of trace or or whether

00:15:56,610 --> 00:16:00,930
or not they should be adding those retry

00:15:58,170 --> 00:16:03,720
capabilities in a smart way or people

00:16:00,930 --> 00:16:05,940
forget stuff so part of why the Envoy

00:16:03,720 --> 00:16:08,250
sidecar came to be is it gives a common

00:16:05,940 --> 00:16:09,600
base set of capabilities regardless of

00:16:08,250 --> 00:16:10,290
whether or not the developer remembered

00:16:09,600 --> 00:16:13,170
to do it

00:16:10,290 --> 00:16:14,970
so envoy always collects distributed

00:16:13,170 --> 00:16:17,010
trace data for every outbound requests

00:16:14,970 --> 00:16:19,170
it's always there if the developer

00:16:17,010 --> 00:16:21,210
remembers to add additional context to

00:16:19,170 --> 00:16:22,830
say ok this is a follows from kind of

00:16:21,210 --> 00:16:24,450
transaction or like you know this

00:16:22,830 --> 00:16:26,490
request is gonna follow from this other

00:16:24,450 --> 00:16:28,800
request so you get your nice nested span

00:16:26,490 --> 00:16:30,810
diagrams great but if they don't who

00:16:28,800 --> 00:16:32,250
cares we could still see something about

00:16:30,810 --> 00:16:33,180
what's going on in our system because we

00:16:32,250 --> 00:16:37,770
have that base

00:16:33,180 --> 00:16:39,810
capability the other nice thing as a

00:16:37,770 --> 00:16:43,230
Java developer who really hates trust

00:16:39,810 --> 00:16:47,040
stores and key stores like nobody wants

00:16:43,230 --> 00:16:49,620
to deal with that nobody but envoy as

00:16:47,040 --> 00:16:51,510
the proxy that sits in the case of

00:16:49,620 --> 00:16:53,370
kubernetes it sits right with the the

00:16:51,510 --> 00:16:55,920
egress ingress from the pod in the case

00:16:53,370 --> 00:16:57,480
of Cloud Foundry it will sit with the go

00:16:55,920 --> 00:17:00,510
router there's a project actively

00:16:57,480 --> 00:17:03,180
working on that it will manage secure

00:17:00,510 --> 00:17:05,459
TLS transport between services for you

00:17:03,180 --> 00:17:07,410
which means we do not have to do stupid

00:17:05,459 --> 00:17:08,790
trust stores in our code we do not have

00:17:07,410 --> 00:17:10,980
to worry about keep rotation in our code

00:17:08,790 --> 00:17:13,050
we do not like you just don't you just

00:17:10,980 --> 00:17:14,339
don't I am so excited when you do not

00:17:13,050 --> 00:17:16,079
have to do something and is the best

00:17:14,339 --> 00:17:19,050
thing ever because if you don't write it

00:17:16,079 --> 00:17:20,640
it doesn't break so it's just goodness

00:17:19,050 --> 00:17:22,589
right you have a much more secure

00:17:20,640 --> 00:17:26,550
ecosystem and all you did was a sidecar

00:17:22,589 --> 00:17:28,020
it's good stuff now this is where things

00:17:26,550 --> 00:17:29,059
are going to get really interesting or

00:17:28,020 --> 00:17:31,399
the next

00:17:29,059 --> 00:17:33,379
as envoy grows up and if you have an

00:17:31,399 --> 00:17:35,389
opinion about this by the way now is a

00:17:33,379 --> 00:17:38,149
great time to go get involved right

00:17:35,389 --> 00:17:39,409
envoy and SEO are not baked yet so if

00:17:38,149 --> 00:17:40,730
you have an opinion about how this

00:17:39,409 --> 00:17:42,409
should work it's a great time to go and

00:17:40,730 --> 00:17:44,389
get involved because where I think

00:17:42,409 --> 00:17:46,370
things are interesting is in the

00:17:44,389 --> 00:17:49,490
intersection of circuit breakers

00:17:46,370 --> 00:17:52,730
bulkheads fault you know callbacks fall

00:17:49,490 --> 00:17:56,870
backs and retries so if I have history

00:17:52,730 --> 00:17:58,700
in my app I can define certain behaviors

00:17:56,870 --> 00:18:00,440
like this but we know some of it is

00:17:58,700 --> 00:18:04,070
better done at the transport layer

00:18:00,440 --> 00:18:07,070
because it's just more efficient there

00:18:04,070 --> 00:18:08,509
is no way that the sidecar at the

00:18:07,070 --> 00:18:10,580
infrastructure level is going to know

00:18:08,509 --> 00:18:12,889
the appropriate fallback to execute if

00:18:10,580 --> 00:18:14,389
the request fails remember where fall

00:18:12,889 --> 00:18:16,429
backs came from from the point of view

00:18:14,389 --> 00:18:18,590
of Netflix they had some catastrophic

00:18:16,429 --> 00:18:20,450
outages a long time ago and they

00:18:18,590 --> 00:18:22,249
realized firstly like their user service

00:18:20,450 --> 00:18:24,409
was down and they couldn't give you any

00:18:22,249 --> 00:18:26,899
movies okay that was bad so they figured

00:18:24,409 --> 00:18:28,639
out how in their cookie processing for

00:18:26,899 --> 00:18:30,289
example they have enough in there that

00:18:28,639 --> 00:18:32,179
they can remember who you are even if

00:18:30,289 --> 00:18:33,860
their user services down so that's not

00:18:32,179 --> 00:18:36,710
in their app you know that's like cookie

00:18:33,860 --> 00:18:39,320
stuff the next thing they did and this

00:18:36,710 --> 00:18:42,110
is stuff they did with hystrix fall

00:18:39,320 --> 00:18:43,460
backs in their code as they said okay

00:18:42,110 --> 00:18:45,919
I'm gonna try to get the movies for this

00:18:43,460 --> 00:18:47,720
person okay that didn't work I'm gonna

00:18:45,919 --> 00:18:49,429
try to get movies for people like this

00:18:47,720 --> 00:18:50,960
person well that didn't work either okay

00:18:49,429 --> 00:18:52,549
I'm gonna get movies for people in the

00:18:50,960 --> 00:18:55,070
area of this person okay that didn't

00:18:52,549 --> 00:18:57,740
work here's the movies right but that

00:18:55,070 --> 00:19:00,980
that was application specific fallback

00:18:57,740 --> 00:19:02,899
behavior right that they defined so that

00:19:00,980 --> 00:19:07,070
they can satisfy their requirement which

00:19:02,899 --> 00:19:10,220
is you will get movies and right you

00:19:07,070 --> 00:19:11,869
can't put that kind of logic at the

00:19:10,220 --> 00:19:13,669
network infrastructure layer without

00:19:11,869 --> 00:19:16,039
heading right down the Silbury slope

00:19:13,669 --> 00:19:17,509
back to e SBS which we know we don't see

00:19:16,039 --> 00:19:18,950
there's a reason I mentioned that we

00:19:17,509 --> 00:19:23,119
don't want to go there we know it hurts

00:19:18,950 --> 00:19:25,549
so how that dynamic is gonna play out is

00:19:23,119 --> 00:19:27,590
very interesting to me

00:19:25,549 --> 00:19:29,990
another one is circuit breakers and

00:19:27,590 --> 00:19:32,169
bulkheads as we see those who is in

00:19:29,990 --> 00:19:34,519
charge of maintaining the sliding window

00:19:32,169 --> 00:19:35,840
circuit breakers are easier right you

00:19:34,519 --> 00:19:39,980
want to see that traffic shut off

00:19:35,840 --> 00:19:42,289
bulkheads for me java loves threads we

00:19:39,980 --> 00:19:42,919
love to manage our thread pools we love

00:19:42,289 --> 00:19:44,690
to be able to

00:19:42,919 --> 00:19:47,179
say this guy's gonna be expensive I only

00:19:44,690 --> 00:19:49,549
want this to go but I don't actually

00:19:47,179 --> 00:19:52,429
care if the data like I can skip a

00:19:49,549 --> 00:19:53,899
couple so I'm gonna use a semaphore here

00:19:52,429 --> 00:19:55,700
because I either get the lock in its

00:19:53,899 --> 00:19:57,679
ends or I don't I don't life it's good

00:19:55,700 --> 00:19:59,629
or I'm gonna have a constrained thread

00:19:57,679 --> 00:20:02,629
pool and I'm gonna queue because these

00:19:59,629 --> 00:20:06,739
are what you batch yeah envoy cannot do

00:20:02,629 --> 00:20:08,539
that so how for me how this relationship

00:20:06,739 --> 00:20:11,389
involves that we can get the application

00:20:08,539 --> 00:20:14,659
behavior we want and yet interact and

00:20:11,389 --> 00:20:16,940
make best use of envoy that relationship

00:20:14,659 --> 00:20:18,409
I think is going to be fascinating so if

00:20:16,940 --> 00:20:19,609
you have opinions go get involved with

00:20:18,409 --> 00:20:21,619
the community so that you can get what

00:20:19,609 --> 00:20:23,889
you want if you don't say what you want

00:20:21,619 --> 00:20:27,590
it's your fault if you don't get it

00:20:23,889 --> 00:20:29,239
do you have to use spring everybody here

00:20:27,590 --> 00:20:32,919
and I noticed just about everybody here

00:20:29,239 --> 00:20:35,899
use a spring micro profile is a new

00:20:32,919 --> 00:20:39,289
standard coming out based on like a

00:20:35,899 --> 00:20:41,600
minimum set I would say of existing Java

00:20:39,289 --> 00:20:44,299
EE specifications specifically the

00:20:41,600 --> 00:20:48,200
lightweight ones like jax-rs CDI right

00:20:44,299 --> 00:20:50,980
it's a very small subset it has all the

00:20:48,200 --> 00:20:53,840
capabilities that you would expect from

00:20:50,980 --> 00:20:56,330
spraying cloud Plus Netflix but it is

00:20:53,840 --> 00:20:58,700
tiny because it does not drag in an

00:20:56,330 --> 00:21:02,269
entire stack or the Maven dependency

00:20:58,700 --> 00:21:04,369
download the universe problem so as an

00:21:02,269 --> 00:21:06,080
alternative to spring or for people who

00:21:04,369 --> 00:21:07,340
have a lot of code and traditional Java

00:21:06,080 --> 00:21:09,619
environments this is definitely

00:21:07,340 --> 00:21:12,379
something to check out it has fault

00:21:09,619 --> 00:21:14,179
tolerance behavior it supports CDI it

00:21:12,379 --> 00:21:15,889
supports it has a metrics API it

00:21:14,179 --> 00:21:17,299
supports open tracing like all the

00:21:15,889 --> 00:21:19,220
capabilities are there and they're

00:21:17,299 --> 00:21:20,480
adding all the time that again as a

00:21:19,220 --> 00:21:23,600
community that you could get involved

00:21:20,480 --> 00:21:25,850
with also and then we have certain we

00:21:23,600 --> 00:21:28,639
have server lists the fun thing about

00:21:25,850 --> 00:21:31,070
server list is do we need any of it the

00:21:28,639 --> 00:21:35,960
example from Amazon for lambda

00:21:31,070 --> 00:21:37,639
that's the stack like um yeah there's a

00:21:35,960 --> 00:21:38,480
lot of stuff we might expect that's just

00:21:37,639 --> 00:21:40,999
not there

00:21:38,480 --> 00:21:42,200
at all and that's gonna be kind of

00:21:40,999 --> 00:21:44,840
fascinating right when you were trying

00:21:42,200 --> 00:21:46,159
to minimize the size of your JVM or you

00:21:44,840 --> 00:21:47,989
know to get it starting fast in that

00:21:46,159 --> 00:21:50,269
kind of environment do we need any of

00:21:47,989 --> 00:21:53,899
this stuff that we think of like no

00:21:50,269 --> 00:21:55,700
maybe not so that's I think that's gonna

00:21:53,899 --> 00:21:58,680
really change how we do stuff

00:21:55,700 --> 00:22:01,080
rest we no rest

00:21:58,680 --> 00:22:02,820
we love rest we document rest we bring

00:22:01,080 --> 00:22:06,540
it up in swagger api's we push buttons

00:22:02,820 --> 00:22:08,670
to do it and now we have GR PC which is

00:22:06,540 --> 00:22:10,200
binary which by the way I find hilarious

00:22:08,670 --> 00:22:13,950
as someone who has been around long

00:22:10,200 --> 00:22:16,380
enough to work with CORBA we're back to

00:22:13,950 --> 00:22:19,080
fixed fixed payload didn't think first

00:22:16,380 --> 00:22:20,490
it's great so but there's some

00:22:19,080 --> 00:22:22,620
interesting work going on I have one

00:22:20,490 --> 00:22:24,300
blog post here on voice doing it core OS

00:22:22,620 --> 00:22:25,980
is doing it and they've established some

00:22:24,300 --> 00:22:30,240
end-to-end practices so that they can

00:22:25,980 --> 00:22:32,429
have G RPC for HTTP 2 with the proto 2

00:22:30,240 --> 00:22:34,460
protobuf definitions you know that nice

00:22:32,429 --> 00:22:36,929
thing and then they can grow up to rest

00:22:34,460 --> 00:22:38,400
HTTP one one with all the swagger stuff

00:22:36,929 --> 00:22:40,950
that you know so they're keeping those

00:22:38,400 --> 00:22:43,440
as a continuum of things that they

00:22:40,950 --> 00:22:45,320
support which kind of bridges the two

00:22:43,440 --> 00:22:51,150
universes and I think a rather nice way

00:22:45,320 --> 00:22:52,830
so that's when do I finish yeah that's

00:22:51,150 --> 00:22:54,240
why I thought good all right I will

00:22:52,830 --> 00:22:57,960
probably blow through this because again

00:22:54,240 --> 00:23:00,300
I brush um oh yeah and I had somebody

00:22:57,960 --> 00:23:02,490
recently say they hate G RPC because

00:23:00,300 --> 00:23:04,230
it's back to binary and I'm like yeah go

00:23:02,490 --> 00:23:05,880
talk to the guys I used to work with

00:23:04,230 --> 00:23:08,030
that did WebSphere on z/os we know

00:23:05,880 --> 00:23:10,980
everything about dumping binary payloads

00:23:08,030 --> 00:23:14,910
complete with eye catchers because for Z

00:23:10,980 --> 00:23:18,540
it's also in episodic reactive is coming

00:23:14,910 --> 00:23:20,160
and reactive changes everything I did

00:23:18,540 --> 00:23:21,480
not try to go through marble diagrams

00:23:20,160 --> 00:23:23,010
here I've had people tell me that the

00:23:21,480 --> 00:23:25,920
marble diagrams make their head explode

00:23:23,010 --> 00:23:28,770
I will tell you in all seriousness if

00:23:25,920 --> 00:23:30,090
you figure out observables and how to do

00:23:28,770 --> 00:23:32,370
subscriptions you know - how did your

00:23:30,090 --> 00:23:35,070
subscribes and then how to do like map

00:23:32,370 --> 00:23:37,350
and switch map and now everything like I

00:23:35,070 --> 00:23:38,790
have a hammer everything everything is a

00:23:37,350 --> 00:23:41,220
nail because you can do synchronous

00:23:38,790 --> 00:23:43,970
stuff with observables - and it's it's

00:23:41,220 --> 00:23:47,130
quite addictive once you figure that out

00:23:43,970 --> 00:23:48,870
but I find this interesting because when

00:23:47,130 --> 00:23:51,330
micro services and cloud native became a

00:23:48,870 --> 00:23:53,130
thing there's this AAB everything if

00:23:51,330 --> 00:23:55,140
it's going to be really truly decoupled

00:23:53,130 --> 00:23:57,330
everything should be an event like we

00:23:55,140 --> 00:23:58,440
should be going back to messaging but of

00:23:57,330 --> 00:24:01,559
course we all went to rest because

00:23:58,440 --> 00:24:04,080
that's easier to understand so how this

00:24:01,559 --> 00:24:06,060
emerges so that we can understand these

00:24:04,080 --> 00:24:07,250
systems and reason about them and debug

00:24:06,060 --> 00:24:10,310
them and let them grow

00:24:07,250 --> 00:24:13,510
is a big deal has anybody have a has

00:24:10,310 --> 00:24:17,720
anybody ever seen a good way to describe

00:24:13,510 --> 00:24:20,690
version test out be aware of the

00:24:17,720 --> 00:24:24,890
contents of events it is the biggest

00:24:20,690 --> 00:24:26,810
super secret handshake everybody is soda

00:24:24,890 --> 00:24:28,610
coupled with events except the contents

00:24:26,810 --> 00:24:30,770
are a super secret handshake I have yet

00:24:28,610 --> 00:24:36,290
to find a good answer for documenting

00:24:30,770 --> 00:24:39,920
the contents of these events fascinating

00:24:36,290 --> 00:24:41,450
stuff oh it's the end - see I told you I

00:24:39,920 --> 00:24:42,020
would rush but we can do questions

00:24:41,450 --> 00:24:45,950
that's fun

00:24:42,020 --> 00:24:47,930
so just for this track so to get back to

00:24:45,950 --> 00:24:51,230
the intro track that I didn't really do

00:24:47,930 --> 00:24:53,600
very well at - we do have lunch by the

00:24:51,230 --> 00:24:56,030
way there is a lunch break right after

00:24:53,600 --> 00:24:58,490
the lunch break Ozzy he's he's the other

00:24:56,030 --> 00:25:00,320
half of my brain which is scary but he's

00:24:58,490 --> 00:25:02,390
gonna talk about ISTE oh and spring and

00:25:00,320 --> 00:25:05,060
micro profile so if you want to know

00:25:02,390 --> 00:25:06,200
more you know a little more in detail

00:25:05,060 --> 00:25:08,720
about what I talked about with this do

00:25:06,200 --> 00:25:10,850
you can come to all these talk Rix

00:25:08,720 --> 00:25:13,550
rotors here and he's going to talk about

00:25:10,850 --> 00:25:16,340
building responsive systems with survey

00:25:13,550 --> 00:25:18,170
lists and event-driven Java which is a

00:25:16,340 --> 00:25:20,240
whole nother pile right right out of

00:25:18,170 --> 00:25:21,470
what I talked about and that should be a

00:25:20,240 --> 00:25:23,000
really good session if you're curious

00:25:21,470 --> 00:25:27,770
about about what's going on with that

00:25:23,000 --> 00:25:29,020
and then at just after them Ben Hale and

00:25:27,770 --> 00:25:33,830
Paul Harris are going to talk about

00:25:29,020 --> 00:25:35,990
reactive api's which is also just out of

00:25:33,830 --> 00:25:39,140
what I talked about tomorrow we also

00:25:35,990 --> 00:25:40,760
have from Surya at IBM my colleague we

00:25:39,140 --> 00:25:42,710
have a talk about how Cloud Foundry

00:25:40,760 --> 00:25:45,230
compares with kubernetes for deployment

00:25:42,710 --> 00:25:47,570
of cloud native applications so that is

00:25:45,230 --> 00:25:49,580
my rundown of all the crazy stuff that's

00:25:47,570 --> 00:25:54,170
happening in the Java ecosystem I do

00:25:49,580 --> 00:25:56,930
hope now you have questions wait wait no

00:25:54,170 --> 00:25:58,880
I'm gonna put her on the spot I don't

00:25:56,930 --> 00:26:02,060
where's the microphone

00:25:58,880 --> 00:26:04,630
I forget where like look it's here since

00:26:02,060 --> 00:26:10,580
we have time can I put you on the spot

00:26:04,630 --> 00:26:13,910
be like no I want Heather to talk

00:26:10,580 --> 00:26:15,980
briefly about Kotlin because she told me

00:26:13,910 --> 00:26:18,620
she knows it so Dana yeah I didn't know

00:26:15,980 --> 00:26:21,860
well enough to talk about it has anybody

00:26:18,620 --> 00:26:26,060
played with Colin a couple yeah

00:26:21,860 --> 00:26:37,820
what do you better feel for what are

00:26:26,060 --> 00:26:40,010
your feelings yeah exactly that's what I

00:26:37,820 --> 00:26:41,930
found in tribute it's so much more so

00:26:40,010 --> 00:26:44,990
the comment was that it's very succinct

00:26:41,930 --> 00:26:49,040
and readable which has exactly been my

00:26:44,990 --> 00:26:50,360
experience so cuz obviously I had

00:26:49,040 --> 00:26:52,820
nothing prepared because I just grabbed

00:26:50,360 --> 00:26:54,590
and pulled up here but I would recommend

00:26:52,820 --> 00:26:56,930
checking it out and checking out some of

00:26:54,590 --> 00:26:59,510
the language idioms and once you get

00:26:56,930 --> 00:27:01,970
used to writing out things some of the

00:26:59,510 --> 00:27:05,030
ways it does I think one of my favorite

00:27:01,970 --> 00:27:07,880
is the where the when Klaus instead of

00:27:05,030 --> 00:27:10,280
an if/else once you start writing those

00:27:07,880 --> 00:27:12,260
and then you have to go back to

00:27:10,280 --> 00:27:15,080
something written in Java it becomes

00:27:12,260 --> 00:27:17,930
painful which is my best test for when a

00:27:15,080 --> 00:27:20,420
new language is worth learning cool

00:27:17,930 --> 00:27:23,120
thank you does anybody else have a

00:27:20,420 --> 00:27:24,410
question or a comment I invite comments

00:27:23,120 --> 00:27:30,010
because this was a very opinionated

00:27:24,410 --> 00:27:30,010
I love opinions you can tell

00:27:32,280 --> 00:27:35,370
I don't know if this is something you

00:27:33,960 --> 00:27:37,200
can answer it's just a general question

00:27:35,370 --> 00:27:40,560
does anyone know where Netflix went

00:27:37,200 --> 00:27:42,360
because all of these all the spring

00:27:40,560 --> 00:27:46,140
cloud stuff is is core to everything

00:27:42,360 --> 00:27:48,080
that I know that we do and Netflix kind

00:27:46,140 --> 00:27:50,730
of just stepped back from the

00:27:48,080 --> 00:27:56,970
conferences and you know general support

00:27:50,730 --> 00:27:59,490
so what I know from my reading is they

00:27:56,970 --> 00:28:02,460
did go quiet ribbon is in maintenance

00:27:59,490 --> 00:28:04,080
mode a lot of I think Eureka is mostly

00:28:02,460 --> 00:28:05,940
in maintenance mode aside from the

00:28:04,080 --> 00:28:09,890
contributions that spring is still

00:28:05,940 --> 00:28:11,760
making to it I think they went I

00:28:09,890 --> 00:28:14,220
actually should probably not put that

00:28:11,760 --> 00:28:16,800
down they went very much into the G RPC

00:28:14,220 --> 00:28:18,960
space right so they're they're looking

00:28:16,800 --> 00:28:21,270
at this point into how you're optimizing

00:28:18,960 --> 00:28:24,210
binary transports right to really

00:28:21,270 --> 00:28:26,310
streamline how how how you're

00:28:24,210 --> 00:28:29,220
communicating between services I also

00:28:26,310 --> 00:28:32,250
think I believe the last time I looked

00:28:29,220 --> 00:28:33,720
there and on mesos so again you're

00:28:32,250 --> 00:28:35,280
starting getting you're starting to get

00:28:33,720 --> 00:28:36,870
into these platforms where the service

00:28:35,280 --> 00:28:38,670
discovery is happening in the

00:28:36,870 --> 00:28:42,450
infrastructure which means you don't

00:28:38,670 --> 00:28:44,670
need the extra services like Eureka

00:28:42,450 --> 00:28:46,170
especially because you're relying on

00:28:44,670 --> 00:28:49,860
that infrastructure which already knows

00:28:46,170 --> 00:28:52,920
the information does that answer your

00:28:49,860 --> 00:28:54,330
question if no I mean it is a good

00:28:52,920 --> 00:28:56,070
question they went really really quiet

00:28:54,330 --> 00:28:58,710
if you look at some of what they're

00:28:56,070 --> 00:29:00,870
talking about like where they're still

00:28:58,710 --> 00:29:05,280
investing where I can see is on some of

00:29:00,870 --> 00:29:06,780
their operational visualization side

00:29:05,280 --> 00:29:09,150
right because that's something you need

00:29:06,780 --> 00:29:11,070
either way right even if you're even if

00:29:09,150 --> 00:29:12,900
you're looking or using a meso Soraa

00:29:11,070 --> 00:29:14,580
kubernetes you need to be able to

00:29:12,900 --> 00:29:16,230
visualize what's going on on your system

00:29:14,580 --> 00:29:17,970
and so you still see a lot of

00:29:16,230 --> 00:29:27,890
contributions in that area specifically

00:29:17,970 --> 00:29:27,890
I think I might one more minute yeah

00:29:35,059 --> 00:29:40,529
so it's do versus spring cloud gateway

00:29:38,010 --> 00:29:43,639
in by spring cloud gateway you mean

00:29:40,529 --> 00:29:43,639
spring cloud gateway on Zuul

00:29:53,090 --> 00:30:00,929
so I think that from what I know not

00:29:57,360 --> 00:30:03,539
being a pivot in fairness is is an

00:30:00,929 --> 00:30:05,279
interesting space to watch there's a few

00:30:03,539 --> 00:30:06,929
places that have gateways and then it's

00:30:05,279 --> 00:30:08,970
whether or not the Gateway is going to

00:30:06,929 --> 00:30:10,799
know everything that envoy or sto is

00:30:08,970 --> 00:30:12,509
going to know and I think part of the

00:30:10,799 --> 00:30:15,539
question when you look at how envoy and

00:30:12,509 --> 00:30:17,159
sto are going to fit into an interest

00:30:15,539 --> 00:30:19,740
like an organization that's managing

00:30:17,159 --> 00:30:21,960
things is where that data like where the

00:30:19,740 --> 00:30:23,730
configuration and how the traffic will

00:30:21,960 --> 00:30:25,919
flow or traffic shaping is going to

00:30:23,730 --> 00:30:27,749
happen and and who is going to have that

00:30:25,919 --> 00:30:30,869
information and who is going to be right

00:30:27,749 --> 00:30:33,139
in control of of doing that when you

00:30:30,869 --> 00:30:35,730
start looking at how a kubernetes

00:30:33,139 --> 00:30:37,619
kubernetes plus helm charts plus role

00:30:35,730 --> 00:30:40,070
based access controls and how that is

00:30:37,619 --> 00:30:43,440
shaping you start to understand where

00:30:40,070 --> 00:30:46,379
envoy is sitting with each pot so it's

00:30:43,440 --> 00:30:48,720
like it's like distributed behavior

00:30:46,379 --> 00:30:51,179
distributed execution of centrally

00:30:48,720 --> 00:30:53,490
managed information which is amazingly

00:30:51,179 --> 00:30:55,200
powerful when you start looking at

00:30:53,490 --> 00:30:57,149
spring cloud gateway or other things

00:30:55,200 --> 00:30:58,799
it's who you still don't necessarily

00:30:57,149 --> 00:31:01,110
know who's in charge of configuring any

00:30:58,799 --> 00:31:02,820
one of those pieces and I think that's

00:31:01,110 --> 00:31:05,009
where some of the tension is going to

00:31:02,820 --> 00:31:07,440
come from I think interestingly is as

00:31:05,009 --> 00:31:09,570
envoy stabilizes because it's still

00:31:07,440 --> 00:31:12,210
envoy itself is stable but it's do is

00:31:09,570 --> 00:31:15,330
very much under development it will be

00:31:12,210 --> 00:31:17,070
interesting to see if they adapt to use

00:31:15,330 --> 00:31:23,279
more capabilities from that which is

00:31:17,070 --> 00:31:26,429
possible on SDO itself envoy I think can

00:31:23,279 --> 00:31:29,279
work already like it can I think it can

00:31:26,429 --> 00:31:31,889
satisfy Eureka api's like it already has

00:31:29,279 --> 00:31:34,409
capabilities to fit to fit into existing

00:31:31,889 --> 00:31:36,149
spaces and so I would imagine that if

00:31:34,409 --> 00:31:39,019
you are if you really like spring cloud

00:31:36,149 --> 00:31:41,759
gateway there's going to be ways to

00:31:39,019 --> 00:31:43,440
piece those together right I do know

00:31:41,759 --> 00:31:45,240
that from the go router like there's

00:31:43,440 --> 00:31:47,909
active work to get envoy and the go

00:31:45,240 --> 00:31:49,409
router working better together and again

00:31:47,909 --> 00:31:51,240
once you start getting that do you still

00:31:49,409 --> 00:31:52,559
need that gateway you know at what point

00:31:51,240 --> 00:31:54,450
does it become redundant we don't know

00:31:52,559 --> 00:31:55,830
it's one of those things we don't we

00:31:54,450 --> 00:32:00,149
actually don't know all right you guys

00:31:55,830 --> 00:32:00,429
get a break I think briefly right 10

00:32:00,149 --> 00:32:04,720
minute

00:32:00,429 --> 00:32:06,250
ten minutes I hope that was helpful

00:32:04,720 --> 00:32:09,950
yay come back

00:32:06,250 --> 00:32:09,950

YouTube URL: https://www.youtube.com/watch?v=NkBNLkmldnI


