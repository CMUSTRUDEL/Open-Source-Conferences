Title: Istio Platform vs Spring and MicroProfile Frameworks - Ozzy Osborne, IBM UK
Publication date: 2018-04-21
Playlist: Cloud Foundry Summit NA 2018
Description: 
	Istio Platform vs Spring and MicroProfile Frameworks - Ozzy Osborne, IBM UK

Istio is an open platform which aims to provide a uniform way to connect, manage and secure microservices. However, these are capabilities that are already provided by a variety of programming frameworks, such as Netflix OSS and MicroProfile fault tolerance. Can a platform really know everything about an application, or does the application sometimes know better?

In this session Ozzy will start with an introduction to the Istio architecture, including the sidecar model and what it means to deploy your application in this way. He will cover the technologies that overlap with existing framework capabilities such as security and fault tolerance. The differences between the approaches will be highlighted, including when to use which and how you can make them work in harmony together.

Istio also provides capabilities that compliment existing microservice and cloud native architectures. He will cover some of these functions, such as smart routing to enable A/B testing and canary deployments, together with how to make use of them within this new platform. 

About avatar for Ozzy Osborne
Ozzy has over two decades of experience in Enterprise Software Development for IBM, mainly working with Java based technologies and enterprise middleware. An enthusiastic developer, who loves to "make things work", and isn't scared to take things apart to figure out how, he has most recently been focused on Cloud Native architectures centered around Kubernetes, and what the arrival of Istio means for the accepted definition of Cloud Native applications.
Captions: 
	00:00:00,030 --> 00:00:07,740
okay hi everyone welcome I'm going to be

00:00:04,380 --> 00:00:10,679
talking about sto and spring and micro

00:00:07,740 --> 00:00:13,740
profile and Erin's waving our arms at me

00:00:10,679 --> 00:00:16,160
from the back higher and my name is Ozzy

00:00:13,740 --> 00:00:18,570
Osbourne yes that's actually my name

00:00:16,160 --> 00:00:23,730
just for anybody else who wants to ask

00:00:18,570 --> 00:00:27,240
me today we're getting on quite well so

00:00:23,730 --> 00:00:28,619
let's go back to that one apparently

00:00:27,240 --> 00:00:30,599
we've all been asked to add this one to

00:00:28,619 --> 00:00:33,149
our foils so I have to read this one out

00:00:30,599 --> 00:00:34,980
so please note the locations of the

00:00:33,149 --> 00:00:37,800
surrounding emergency exits and located

00:00:34,980 --> 00:00:39,329
the nearest exit sign to you in the

00:00:37,800 --> 00:00:41,040
event of a fire alarm or other emergency

00:00:39,329 --> 00:00:43,710
please calmly exit to the public

00:00:41,040 --> 00:00:44,879
concourse area emergency exit stairwells

00:00:43,710 --> 00:00:47,750
leading to the outside of this facility

00:00:44,879 --> 00:00:50,219
are located along the public concourse

00:00:47,750 --> 00:00:51,420
for your safety in an emergency please

00:00:50,219 --> 00:00:54,270
follow the directions of the public

00:00:51,420 --> 00:00:58,320
safety staff okay now we can get back to

00:00:54,270 --> 00:01:01,559
the real stuff so show of hands how many

00:00:58,320 --> 00:01:03,120
people have heard of this tear okay keep

00:01:01,559 --> 00:01:07,680
your hand up or put your hand up again

00:01:03,120 --> 00:01:10,409
if you've used it okay how many people

00:01:07,680 --> 00:01:13,590
have heard of spring same deal how many

00:01:10,409 --> 00:01:16,409
people have used spring thought so how

00:01:13,590 --> 00:01:20,939
people heard a micro profile and how

00:01:16,409 --> 00:01:23,000
people have used it okay that gives me a

00:01:20,939 --> 00:01:25,110
rough idea of where we're headed

00:01:23,000 --> 00:01:28,380
so I should explain a little bit about

00:01:25,110 --> 00:01:29,189
my motivation behind giving this we've

00:01:28,380 --> 00:01:30,720
been looking at the way that

00:01:29,189 --> 00:01:32,189
applications have been evolving over

00:01:30,720 --> 00:01:34,110
time and you've been looking at the way

00:01:32,189 --> 00:01:36,090
that basically the business logic has

00:01:34,110 --> 00:01:37,259
been becoming clearer and clearer to be

00:01:36,090 --> 00:01:39,180
just about what the business is about

00:01:37,259 --> 00:01:40,590
and if you think about the wave of

00:01:39,180 --> 00:01:42,210
applications used to be put together we

00:01:40,590 --> 00:01:43,860
used to have like you know vast watches

00:01:42,210 --> 00:01:46,079
our code all of it would be custom and

00:01:43,860 --> 00:01:47,579
your application would run if you were

00:01:46,079 --> 00:01:49,110
lucky but when you went on to your next

00:01:47,579 --> 00:01:50,520
application pass a bit of work possibly

00:01:49,110 --> 00:01:52,710
wouldn't work and yeah you'd have to

00:01:50,520 --> 00:01:54,030
figure out how it came together and then

00:01:52,710 --> 00:01:55,259
libraries came along we decide to pull

00:01:54,030 --> 00:01:56,820
the common stuff in there and then you

00:01:55,259 --> 00:01:57,719
end up with basically you know little

00:01:56,820 --> 00:01:59,670
libraries you can transfer between

00:01:57,719 --> 00:02:00,719
stuffs and we realized that enough of

00:01:59,670 --> 00:02:01,619
these libraries were common that we're

00:02:00,719 --> 00:02:03,210
going to stick them all together and

00:02:01,619 --> 00:02:04,619
call them a server so you have je

00:02:03,210 --> 00:02:05,820
servers and then suddenly you had

00:02:04,619 --> 00:02:06,930
applications that you could run on all

00:02:05,820 --> 00:02:08,310
these different servers and they didn't

00:02:06,930 --> 00:02:10,830
matter where you transferred your app to

00:02:08,310 --> 00:02:12,480
it would still work and then people

00:02:10,830 --> 00:02:12,880
started looking at je and saying well

00:02:12,480 --> 00:02:15,730
that's not

00:02:12,880 --> 00:02:17,020
enough I need to add more to this so we

00:02:15,730 --> 00:02:18,490
have things like spring come along as a

00:02:17,020 --> 00:02:20,410
framework and start providing additional

00:02:18,490 --> 00:02:21,850
api's over the top of those as well and

00:02:20,410 --> 00:02:23,500
then people start writing their

00:02:21,850 --> 00:02:25,750
applications to those api's because they

00:02:23,500 --> 00:02:26,770
look good and then lastly we've got

00:02:25,750 --> 00:02:29,020
these things there's a concept of a

00:02:26,770 --> 00:02:30,550
platform and a platform seems very

00:02:29,020 --> 00:02:32,500
similar to a framework but it's

00:02:30,550 --> 00:02:33,910
essentially providing capabilities to

00:02:32,500 --> 00:02:35,920
your application that you no longer need

00:02:33,910 --> 00:02:36,610
to take care of all of these have in

00:02:35,920 --> 00:02:37,930
common that they're moving

00:02:36,610 --> 00:02:39,490
responsibilities that you would

00:02:37,930 --> 00:02:41,080
previously have taken care of out of

00:02:39,490 --> 00:02:42,700
your application and placing them

00:02:41,080 --> 00:02:44,620
somewhere else this leads to your

00:02:42,700 --> 00:02:46,240
business logic becoming clearer but

00:02:44,620 --> 00:02:48,430
importantly it has impacts on how you

00:02:46,240 --> 00:02:49,690
design your application and it's that

00:02:48,430 --> 00:02:51,340
kind of stuff that I wanted to look at

00:02:49,690 --> 00:02:54,010
and be able to show you through

00:02:51,340 --> 00:02:56,290
comparing sto against spring and against

00:02:54,010 --> 00:02:57,460
Michael profile but to be able to do

00:02:56,290 --> 00:03:00,580
that we've got to understand the

00:02:57,460 --> 00:03:01,900
capabilities of these platforms so as a

00:03:00,580 --> 00:03:03,520
suggestion that none of us have got

00:03:01,900 --> 00:03:04,780
through iste iÃ³ yet that's why the first

00:03:03,520 --> 00:03:06,430
half of this presentation is going to be

00:03:04,780 --> 00:03:07,960
showing people a little bit about how it

00:03:06,430 --> 00:03:11,980
works and how the architecture hangs

00:03:07,960 --> 00:03:14,200
together so sto describes itself as an

00:03:11,980 --> 00:03:15,640
open platform to connect manage and

00:03:14,200 --> 00:03:17,080
secure micro services which is great

00:03:15,640 --> 00:03:18,640
it's got a web page you can go read the

00:03:17,080 --> 00:03:20,410
same statement there and it will mean

00:03:18,640 --> 00:03:22,990
just the same as if I say it 20 times

00:03:20,410 --> 00:03:24,070
it's not gonna help much it's a service

00:03:22,990 --> 00:03:26,170
measure so you've got a bunch loader

00:03:24,070 --> 00:03:27,610
services they all talk together and it

00:03:26,170 --> 00:03:29,110
provides some magic that helps glue this

00:03:27,610 --> 00:03:30,940
together and helps provide some

00:03:29,110 --> 00:03:32,650
facilities that you can use to make it

00:03:30,940 --> 00:03:34,090
easier to do this stuff some of that

00:03:32,650 --> 00:03:36,160
stuff includes intelligent routing and

00:03:34,090 --> 00:03:38,050
low brunson so you can have things in

00:03:36,160 --> 00:03:39,430
sto where your request comes in and you

00:03:38,050 --> 00:03:41,290
decide where it's gonna go based on the

00:03:39,430 --> 00:03:42,940
content of the request or you decide

00:03:41,290 --> 00:03:44,410
where it's going to go based on pretty

00:03:42,940 --> 00:03:45,490
much any attribute you can imagine you

00:03:44,410 --> 00:03:46,840
if you want to route it to somewhere

00:03:45,490 --> 00:03:48,670
that's lightly loaded you can go that

00:03:46,840 --> 00:03:50,050
way you want to route it based on which

00:03:48,670 --> 00:03:51,840
IP address it came from you can do that

00:03:50,050 --> 00:03:54,459
kind of thing

00:03:51,840 --> 00:03:56,530
load balancing so sto can could be

00:03:54,459 --> 00:03:58,120
something that can decide which one

00:03:56,530 --> 00:04:00,970
you're gonna route 2 which instance the

00:03:58,120 --> 00:04:02,440
service you'll route to based on more

00:04:00,970 --> 00:04:03,700
algorithms and just round-robin yeah

00:04:02,440 --> 00:04:05,890
because it's got knowledge of how long

00:04:03,700 --> 00:04:08,290
the last wanted to respond and fault

00:04:05,890 --> 00:04:09,520
tolerance so SEO is capable of sitting

00:04:08,290 --> 00:04:10,510
there and say well actually the service

00:04:09,520 --> 00:04:11,890
you're trying to talk to hasn't

00:04:10,510 --> 00:04:12,850
responded for a while I don't think we

00:04:11,890 --> 00:04:16,090
should probably be trying to talk to

00:04:12,850 --> 00:04:17,500
that one anymore you get into things

00:04:16,090 --> 00:04:19,180
like policy enforcement which he should

00:04:17,500 --> 00:04:21,549
this service even be allowed to talk to

00:04:19,180 --> 00:04:23,030
that other service and all of this is

00:04:21,549 --> 00:04:24,950
comes via the platform

00:04:23,030 --> 00:04:26,270
and then we get on to stuff like metrics

00:04:24,950 --> 00:04:27,830
and logging observability and

00:04:26,270 --> 00:04:29,389
visualization which are all coming for

00:04:27,830 --> 00:04:31,970
free by the fact that by this point SEO

00:04:29,389 --> 00:04:33,350
is deeply embedded in your mesh and it

00:04:31,970 --> 00:04:35,120
can see all the other stuff happening so

00:04:33,350 --> 00:04:37,130
why not pull this stuff out and make use

00:04:35,120 --> 00:04:38,180
of it and lastly I'm going to go into

00:04:37,130 --> 00:04:40,430
some of the stuff about service identity

00:04:38,180 --> 00:04:42,740
and security which is because se owes

00:04:40,430 --> 00:04:44,360
that far down in your stack it's got a

00:04:42,740 --> 00:04:46,639
concept of the identity of your services

00:04:44,360 --> 00:04:48,110
and it can provide security based around

00:04:46,639 --> 00:04:50,510
the identity of those services so

00:04:48,110 --> 00:04:51,919
instead of having a security that says

00:04:50,510 --> 00:04:53,540
that this user's allowed to do this

00:04:51,919 --> 00:04:55,070
thing you can have a concept that this

00:04:53,540 --> 00:04:58,730
service is allowed to do this with this

00:04:55,070 --> 00:05:00,410
other service so now we start getting a

00:04:58,730 --> 00:05:02,840
little bit deeper this is the SEO

00:05:00,410 --> 00:05:04,669
architecture diagram it's present on

00:05:02,840 --> 00:05:06,169
their website it explains pretty much

00:05:04,669 --> 00:05:09,169
everything you need to know about SEO in

00:05:06,169 --> 00:05:10,970
one little vibrant but because it's not

00:05:09,169 --> 00:05:12,500
that much useful without some more words

00:05:10,970 --> 00:05:15,290
we should probably start looking at that

00:05:12,500 --> 00:05:17,570
so they divide their stuff loosely into

00:05:15,290 --> 00:05:18,680
a control plane and a data plane the

00:05:17,570 --> 00:05:20,540
data plane you're probably all familiar

00:05:18,680 --> 00:05:22,040
with the data plane is basically a way

00:05:20,540 --> 00:05:23,810
of saying here's a bunch of services

00:05:22,040 --> 00:05:25,760
which you can see a service a and

00:05:23,810 --> 00:05:27,080
service B at the bottom and these

00:05:25,760 --> 00:05:28,880
services talk to each other they are

00:05:27,080 --> 00:05:30,229
exchanging data they're you know getting

00:05:28,880 --> 00:05:33,050
on with the usual business in the life

00:05:30,229 --> 00:05:34,100
of the service but the control plane

00:05:33,050 --> 00:05:35,720
something you might not have heard of

00:05:34,100 --> 00:05:38,300
and the control planes one of these

00:05:35,720 --> 00:05:40,640
things are best read recently described

00:05:38,300 --> 00:05:43,550
in a blog as the control plane in most

00:05:40,640 --> 00:05:44,960
cases today is you the human you're the

00:05:43,550 --> 00:05:46,280
person who's responsible for defining

00:05:44,960 --> 00:05:47,810
the configuration that you're going to

00:05:46,280 --> 00:05:50,330
push out to all of these services so

00:05:47,810 --> 00:05:52,820
these services know how to talk to other

00:05:50,330 --> 00:05:54,410
services what to do if a service doesn't

00:05:52,820 --> 00:05:55,880
answer how long you're supposed to wait

00:05:54,410 --> 00:05:57,979
for a service to answer before you give

00:05:55,880 --> 00:06:00,169
out all that configuration information

00:05:57,979 --> 00:06:02,360
today is what you the human being enters

00:06:00,169 --> 00:06:03,650
into various config files and scatters

00:06:02,360 --> 00:06:05,360
to the four winds when you deploy your

00:06:03,650 --> 00:06:06,979
services in the vague hope that you

00:06:05,360 --> 00:06:07,760
maintain synchronization between all of

00:06:06,979 --> 00:06:10,610
these when they're actually in

00:06:07,760 --> 00:06:13,100
production STO decided that basically

00:06:10,610 --> 00:06:14,539
this was not a good plan and we wanted

00:06:13,100 --> 00:06:16,190
to try and come up with a way that this

00:06:14,539 --> 00:06:18,650
stuff could actually be controlled from

00:06:16,190 --> 00:06:20,720
a central location and managed by a

00:06:18,650 --> 00:06:22,310
strongly typed configuration so you

00:06:20,720 --> 00:06:23,600
can't accidentally put an integer where

00:06:22,310 --> 00:06:26,650
you're supposed to have a URL for the

00:06:23,600 --> 00:06:26,650
service you talk to next

00:06:27,660 --> 00:06:33,180
so we get on to the next blob which is

00:06:30,810 --> 00:06:34,950
this M voice icon you've heard a little

00:06:33,180 --> 00:06:38,010
bit about my from Aaron earlier today if

00:06:34,950 --> 00:06:39,750
you're in one of her talks misty Oh

00:06:38,010 --> 00:06:41,250
works because it's capable of

00:06:39,750 --> 00:06:43,140
intercepting all the traffic in and out

00:06:41,250 --> 00:06:44,430
of all the services so each service

00:06:43,140 --> 00:06:46,470
individually has its own little own

00:06:44,430 --> 00:06:48,240
voice stuck next to it and it's

00:06:46,470 --> 00:06:50,280
delivered to this service mesh by

00:06:48,240 --> 00:06:52,290
natural nature of a service a sidecar

00:06:50,280 --> 00:06:53,400
mechanism and the sidecar basically

00:06:52,290 --> 00:06:55,050
means that the container that you're

00:06:53,400 --> 00:06:57,300
pushing out with your app gains another

00:06:55,050 --> 00:06:59,010
one and that invoice sits next to it

00:06:57,300 --> 00:07:00,660
takes over all the traffic from your

00:06:59,010 --> 00:07:02,310
service and then listens for

00:07:00,660 --> 00:07:04,680
configuration information that comes in

00:07:02,310 --> 00:07:06,540
from mixer and that's what tells it yeah

00:07:04,680 --> 00:07:08,400
what it's allowed to do and there's a

00:07:06,540 --> 00:07:11,070
pile of communication stuff which says

00:07:08,400 --> 00:07:12,870
how it does service discovery and how it

00:07:11,070 --> 00:07:14,880
should talk to other services and these

00:07:12,870 --> 00:07:17,430
are extensible pluggable mechanisms so

00:07:14,880 --> 00:07:20,130
it's toz intended originally but it was

00:07:17,430 --> 00:07:21,360
designed to be neutral but the first

00:07:20,130 --> 00:07:22,500
implementation of it everybody's

00:07:21,360 --> 00:07:23,940
familiar with is the one that runs on

00:07:22,500 --> 00:07:25,800
kubernetes that's the one I'll be

00:07:23,940 --> 00:07:27,450
showing some more details through but I

00:07:25,800 --> 00:07:29,040
know that CF is looking at integrating

00:07:27,450 --> 00:07:31,920
this stuff into their stack and I

00:07:29,040 --> 00:07:33,900
believe that the CF they've not just got

00:07:31,920 --> 00:07:35,370
one version of some of these they've had

00:07:33,900 --> 00:07:37,950
to create a few more different pieces

00:07:35,370 --> 00:07:39,210
along the way but envoi is important and

00:07:37,950 --> 00:07:40,560
voice very important because it in

00:07:39,210 --> 00:07:41,910
sitting in front of all of the traffic

00:07:40,560 --> 00:07:43,740
that comes in and out of your service

00:07:41,910 --> 00:07:45,150
it's capable of implementing a lot of

00:07:43,740 --> 00:07:47,670
the stuff that you may previously have

00:07:45,150 --> 00:07:48,690
done inside the application itself so

00:07:47,670 --> 00:07:50,070
back to the first part where I was

00:07:48,690 --> 00:07:51,510
explaining about how this leads to

00:07:50,070 --> 00:07:52,620
cleaner business logic means your

00:07:51,510 --> 00:07:54,330
application no longer needs to

00:07:52,620 --> 00:07:55,950
explicitly take care of things like load

00:07:54,330 --> 00:07:58,470
balancing or circuit braking or health

00:07:55,950 --> 00:08:00,480
checks or fault injections which is a

00:07:58,470 --> 00:08:01,800
fun one because bolt injections one

00:08:00,480 --> 00:08:04,500
that's kind of unique twist yet will

00:08:01,800 --> 00:08:06,270
cover it a little bit more but the idea

00:08:04,500 --> 00:08:08,370
basically that you can deliberately fail

00:08:06,270 --> 00:08:09,780
something between some services to test

00:08:08,370 --> 00:08:11,940
how the rest of your application copes

00:08:09,780 --> 00:08:15,900
when a failure likely will occur at some

00:08:11,940 --> 00:08:17,940
point in production so talking about

00:08:15,900 --> 00:08:19,850
site costs when we're over in kubernetes

00:08:17,940 --> 00:08:21,930
if you're not familiar with this stuff's

00:08:19,850 --> 00:08:23,820
the our concept of a service in

00:08:21,930 --> 00:08:25,350
kubernetes is associated very strongly

00:08:23,820 --> 00:08:28,920
with the concept of a thing called a pod

00:08:25,350 --> 00:08:30,600
a pod is basically your unit of function

00:08:28,920 --> 00:08:32,280
that you've deployed and if you were to

00:08:30,600 --> 00:08:33,570
horizontally scale that service so you

00:08:32,280 --> 00:08:35,070
have multiple instance if ik present

00:08:33,570 --> 00:08:36,570
you'll end up with multiple pods present

00:08:35,070 --> 00:08:37,440
which is why in the little diagram that

00:08:36,570 --> 00:08:39,870
I've got here there are these little

00:08:37,440 --> 00:08:42,819
squares that are stacked going back

00:08:39,870 --> 00:08:44,410
now when you played with the stuff in

00:08:42,819 --> 00:08:46,029
the past you would have a container that

00:08:44,410 --> 00:08:47,889
would sit in your pot and that container

00:08:46,029 --> 00:08:49,120
would be your application and if you

00:08:47,889 --> 00:08:50,470
played with kubernetes a little bit

00:08:49,120 --> 00:08:52,180
you'll know that usually you have this

00:08:50,470 --> 00:08:53,769
one-to-one relationship between your pod

00:08:52,180 --> 00:08:56,170
and your application container running

00:08:53,769 --> 00:08:57,759
in the pot that changes quite quickly

00:08:56,170 --> 00:09:00,279
when you start looking at using this ta

00:08:57,759 --> 00:09:01,629
exist EO is using kubernetes ability to

00:09:00,279 --> 00:09:03,639
run more than one container in the same

00:09:01,629 --> 00:09:06,459
pod so that when you deploy your

00:09:03,639 --> 00:09:07,779
application container into a pod you end

00:09:06,459 --> 00:09:09,790
up with an invoice container deployed

00:09:07,779 --> 00:09:11,459
alongside it they're still part of the

00:09:09,790 --> 00:09:14,529
same pod they share the same lifecycle

00:09:11,459 --> 00:09:16,420
but in deploying the endpoint container

00:09:14,529 --> 00:09:17,889
into the same pot it has taken over all

00:09:16,420 --> 00:09:20,259
of the network traffic for the whole pot

00:09:17,889 --> 00:09:21,370
now rooting through envoi say oneboys

00:09:20,259 --> 00:09:23,199
now I've got full visibility over

00:09:21,370 --> 00:09:27,819
everything and manages to achieve

00:09:23,199 --> 00:09:28,959
interesting things violent so we get on

00:09:27,819 --> 00:09:33,250
talking a little bit about mixer and

00:09:28,959 --> 00:09:34,689
pilot mixes the part that has the

00:09:33,250 --> 00:09:36,100
interesting role of basically pulling

00:09:34,689 --> 00:09:37,990
all the different fragments of conflict

00:09:36,100 --> 00:09:40,600
together and blending them out and then

00:09:37,990 --> 00:09:42,459
sending them down to the end voice so

00:09:40,600 --> 00:09:45,250
mixers role is pretty much to interpret

00:09:42,459 --> 00:09:47,259
what you've asked for your services to

00:09:45,250 --> 00:09:49,480
be allowed to do or not allowed to do so

00:09:47,259 --> 00:09:51,100
you want the service to only be allowed

00:09:49,480 --> 00:09:52,660
to invoke other services on a whitelist

00:09:51,100 --> 00:09:54,910
that would be an example of a policy

00:09:52,660 --> 00:09:56,230
that you would give to mixer mixer takes

00:09:54,910 --> 00:09:57,329
all of these different policies that you

00:09:56,230 --> 00:10:00,009
snap together from various places

00:09:57,329 --> 00:10:01,870
aggregates them into what's required for

00:10:00,009 --> 00:10:03,189
each instance of envoi and propagates

00:10:01,870 --> 00:10:06,610
them out to the envoy's and keeps water

00:10:03,189 --> 00:10:07,959
their voice up-to-date pilot on the

00:10:06,610 --> 00:10:10,029
other hand pulp that should cover tumor

00:10:07,959 --> 00:10:11,199
telemetry is where n voice because it's

00:10:10,029 --> 00:10:12,370
sitting there it's also aware all the

00:10:11,199 --> 00:10:14,319
traffic flowing in and out all the time

00:10:12,370 --> 00:10:15,759
so it can collect up that across your

00:10:14,319 --> 00:10:17,709
entire service mesh and stream that out

00:10:15,759 --> 00:10:18,880
to a Prometheus endpoint so you can

00:10:17,709 --> 00:10:20,529
collect and aggregate that data and

00:10:18,880 --> 00:10:23,500
visualize it and do useful things with

00:10:20,529 --> 00:10:24,730
it but pilot on the other hand is a

00:10:23,500 --> 00:10:28,149
similar role in that it's another

00:10:24,730 --> 00:10:29,769
extension point and pilots job is to

00:10:28,149 --> 00:10:34,240
interpret the stuff that's coming

00:10:29,769 --> 00:10:35,860
through from mixer to slightly and be

00:10:34,240 --> 00:10:36,670
able to implement service discovery in

00:10:35,860 --> 00:10:39,129
an abstract way

00:10:36,670 --> 00:10:41,410
it's basically there to try and hide the

00:10:39,129 --> 00:10:43,839
fact that sto will run across multiple

00:10:41,410 --> 00:10:45,220
platforms so for me it's very easy to me

00:10:43,839 --> 00:10:47,319
imagine that is do is basically just a

00:10:45,220 --> 00:10:49,360
chunk of kubernetes but when you start

00:10:47,319 --> 00:10:50,949
looking at how it's gonna implement over

00:10:49,360 --> 00:10:52,480
the top of CF they're talking about

00:10:50,949 --> 00:10:54,370
having CF version of pilot

00:10:52,480 --> 00:10:56,290
and I think at the moment they talk

00:10:54,370 --> 00:10:57,820
about having a co-pilot as well because

00:10:56,290 --> 00:10:59,889
they've decided that pilots life cycle

00:10:57,820 --> 00:11:02,139
wasn't quite what they were after in

00:10:59,889 --> 00:11:04,750
every case so pilot takes care of

00:11:02,139 --> 00:11:06,399
service discovery traffic management AV

00:11:04,750 --> 00:11:07,990
tests where you can basically route a

00:11:06,399 --> 00:11:10,029
certain percentage of your traffic to

00:11:07,990 --> 00:11:11,350
one service and another percentage out

00:11:10,029 --> 00:11:12,459
to another you can keep an eye on it and

00:11:11,350 --> 00:11:14,529
see whether you think it's any good or

00:11:12,459 --> 00:11:15,490
not into canary deployments we can throw

00:11:14,529 --> 00:11:17,199
out things and see whether they're

00:11:15,490 --> 00:11:18,970
actually any good or keep an eye on them

00:11:17,199 --> 00:11:21,610
to see if they're still alive

00:11:18,970 --> 00:11:22,959
it handles resiliency so automatically

00:11:21,610 --> 00:11:25,389
pilot can configure our own voice so

00:11:22,959 --> 00:11:27,490
that you know you can have services that

00:11:25,389 --> 00:11:28,870
if they don't respond within say 15

00:11:27,490 --> 00:11:30,699
seconds they will timeout then rather

00:11:28,870 --> 00:11:33,699
than waiting for the full two-minute TCP

00:11:30,699 --> 00:11:35,529
socket timeout retries if it doesn't

00:11:33,699 --> 00:11:36,910
answer it can retry under the covers for

00:11:35,529 --> 00:11:38,139
you and again all of this is your

00:11:36,910 --> 00:11:40,329
applications not aware of what's going

00:11:38,139 --> 00:11:42,160
on it placed a request the request will

00:11:40,329 --> 00:11:43,589
either come back with a valid result or

00:11:42,160 --> 00:11:46,329
will come back with an error eventually

00:11:43,589 --> 00:11:48,310
but pilots job could be summarized quite

00:11:46,329 --> 00:11:50,139
loosely as it's there to look after all

00:11:48,310 --> 00:11:51,699
of those get Limbaugh instances its job

00:11:50,139 --> 00:11:53,550
to collect the configs push them out

00:11:51,699 --> 00:11:55,510
there and keep them all in sync that

00:11:53,550 --> 00:11:58,420
leaves the last part of our architecture

00:11:55,510 --> 00:12:00,459
diagram which is SDI OAuth and that part

00:11:58,420 --> 00:12:03,190
is basically responsible for being able

00:12:00,459 --> 00:12:05,050
to secure the services it's capable of

00:12:03,190 --> 00:12:07,540
creating neutral TLS connections between

00:12:05,050 --> 00:12:09,100
all of the services transparently this

00:12:07,540 --> 00:12:11,470
is because all the data is flowing out

00:12:09,100 --> 00:12:13,000
through envoi so of course my can now

00:12:11,470 --> 00:12:16,000
set up these connections between places

00:12:13,000 --> 00:12:18,519
but if you've tried configuring just

00:12:16,000 --> 00:12:20,350
even HTTPS between a nest of micro

00:12:18,519 --> 00:12:21,910
services at any point you'll quickly

00:12:20,350 --> 00:12:23,920
have found that certificates become your

00:12:21,910 --> 00:12:25,420
enemy you've got to set up probably your

00:12:23,920 --> 00:12:27,399
own custom CA or you've got a bi

00:12:25,420 --> 00:12:28,209
certificate for every service and then

00:12:27,399 --> 00:12:29,230
you've got to make sure that you've got

00:12:28,209 --> 00:12:31,120
the right certificates in the right

00:12:29,230 --> 00:12:32,470
places and then what happens when you

00:12:31,120 --> 00:12:34,269
need to do certificate rotation what

00:12:32,470 --> 00:12:35,589
happens when a key expires what happens

00:12:34,269 --> 00:12:36,550
if you need to revoke a certificate

00:12:35,589 --> 00:12:39,279
because it ended up somewhere it

00:12:36,550 --> 00:12:40,720
shouldn't like github then you have to

00:12:39,279 --> 00:12:43,089
think through you know how do you handle

00:12:40,720 --> 00:12:45,459
this and sto makes all this quite simple

00:12:43,089 --> 00:12:47,319
you just send HTTP from your service it

00:12:45,459 --> 00:12:49,779
wraps it up into a TLS connection it

00:12:47,319 --> 00:12:51,670
manages with its own CA all of the

00:12:49,779 --> 00:12:53,170
certificates for you and all of the

00:12:51,670 --> 00:12:54,940
connections are very secure not just

00:12:53,170 --> 00:12:56,680
with you know one way to LS but with

00:12:54,940 --> 00:12:58,779
mutual TLS client certificate based

00:12:56,680 --> 00:13:00,100
HTTPS and if you've ever tried setting

00:12:58,779 --> 00:13:01,899
that one up is a world of pain even

00:13:00,100 --> 00:13:04,269
greater than just going for normal HTTP

00:13:01,899 --> 00:13:05,230
but this way is free happens for you

00:13:04,269 --> 00:13:07,330
your application doesn't

00:13:05,230 --> 00:13:08,770
here you can revoke certificates you can

00:13:07,330 --> 00:13:11,140
even shut down which routes you want by

00:13:08,770 --> 00:13:14,590
using the mix of policies so a lot of

00:13:11,140 --> 00:13:16,120
power so hopefully at this point when

00:13:14,590 --> 00:13:17,170
this diagram comes up and when you see

00:13:16,120 --> 00:13:18,910
this kind of thing floating around on

00:13:17,170 --> 00:13:20,080
their website you'll have an idea of

00:13:18,910 --> 00:13:21,310
roughly now what each of these different

00:13:20,080 --> 00:13:25,210
parts were there for and what they were

00:13:21,310 --> 00:13:26,650
doing so that's pretty much it for where

00:13:25,210 --> 00:13:29,110
I wanted to get to with the technology

00:13:26,650 --> 00:13:31,030
with the overview of this year and now

00:13:29,110 --> 00:13:32,920
we start looking at for each of the

00:13:31,030 --> 00:13:35,380
different capabilities that's there how

00:13:32,920 --> 00:13:38,710
this stuff compares between sto and

00:13:35,380 --> 00:13:40,510
spring and micro profile so we're gonna

00:13:38,710 --> 00:13:41,710
look at a couple of different things the

00:13:40,510 --> 00:13:43,480
first ones are please sir gonna be

00:13:41,710 --> 00:13:45,010
service discovery we can look a little

00:13:43,480 --> 00:13:46,480
bit how will you can blend different

00:13:45,010 --> 00:13:48,730
approaches so you could make bricks

00:13:46,480 --> 00:13:51,730
mixed together spring and kubernetes

00:13:48,730 --> 00:13:53,050
and what that means and what happens if

00:13:51,730 --> 00:13:54,790
you try to throw this do into that mix

00:13:53,050 --> 00:13:56,290
as well now we can look at fault

00:13:54,790 --> 00:13:59,710
tolerance and then security and then

00:13:56,290 --> 00:14:02,110
traced all the metrics so starting off

00:13:59,710 --> 00:14:04,120
with service discovery service discovery

00:14:02,110 --> 00:14:06,850
within spring it centers around Eureka

00:14:04,120 --> 00:14:08,890
usually Eureka's borrowed from the

00:14:06,850 --> 00:14:10,900
Netflix pack and it's a service registry

00:14:08,890 --> 00:14:13,000
it requires that each of your services

00:14:10,900 --> 00:14:14,830
as they boot up basically contact the

00:14:13,000 --> 00:14:17,740
server Treasury say hi I'm service fred

00:14:14,830 --> 00:14:20,890
I'm over here so via Treasury remembers

00:14:17,740 --> 00:14:22,840
that and then via ribbon and via other

00:14:20,890 --> 00:14:24,910
client plugins or via lookups using

00:14:22,840 --> 00:14:26,200
discovery client your app code turns

00:14:24,910 --> 00:14:28,120
around says I need to talk to service

00:14:26,200 --> 00:14:29,830
fred and Eureka turns around says yeah I

00:14:28,120 --> 00:14:31,780
know three versions of Fred which one do

00:14:29,830 --> 00:14:33,010
you want and the client picks which one

00:14:31,780 --> 00:14:34,180
wants and the client goes out and makes

00:14:33,010 --> 00:14:35,530
the connection and then everything's

00:14:34,180 --> 00:14:39,760
finished and you've completed your

00:14:35,530 --> 00:14:41,830
passage SDIO is the other way around

00:14:39,760 --> 00:14:43,570
because sto is using envoi so it's

00:14:41,830 --> 00:14:45,880
actually more common to the way that

00:14:43,570 --> 00:14:47,440
kubernetes passes stuff in kubernetes

00:14:45,880 --> 00:14:48,850
when you want to connect to a service

00:14:47,440 --> 00:14:51,310
you turn around say hey i want to talk

00:14:48,850 --> 00:14:52,690
to service Fred and kubernetes knows

00:14:51,310 --> 00:14:54,160
where the service Fred's are because

00:14:52,690 --> 00:14:55,630
when you deployed them to kubernetes you

00:14:54,160 --> 00:14:57,700
said kubernetes here's a service it's

00:14:55,630 --> 00:14:59,200
called Fred if you horizontally scale it

00:14:57,700 --> 00:15:00,850
so you've got 20 copies of fret then

00:14:59,200 --> 00:15:02,680
Kubb knows there's 20 copies but

00:15:00,850 --> 00:15:04,450
critically the client doesn't care the

00:15:02,680 --> 00:15:06,610
client is never told about all 20 copies

00:15:04,450 --> 00:15:09,190
of red in Kubb you turn when I say I

00:15:06,610 --> 00:15:10,630
need to talk to Fred and coop sales

00:15:09,190 --> 00:15:12,130
rather said okay I'll connect you to a

00:15:10,630 --> 00:15:13,660
Fred I'll find one for you I'll find you

00:15:12,130 --> 00:15:15,520
something that matching match is the

00:15:13,660 --> 00:15:17,110
definition of what you are asking for

00:15:15,520 --> 00:15:18,889
and that's critical include because it

00:15:17,110 --> 00:15:21,230
isn't just down to a single thing it's

00:15:18,889 --> 00:15:22,249
it matches it based on the claims that

00:15:21,230 --> 00:15:23,629
you've made when you deployed your

00:15:22,249 --> 00:15:25,309
service so you could deploy a service

00:15:23,629 --> 00:15:27,319
and claim that it's satisfied Fred and a

00:15:25,309 --> 00:15:29,899
bunch light of others and then you you

00:15:27,319 --> 00:15:31,279
would be talking one of those so because

00:15:29,899 --> 00:15:32,809
of that you end up with a situation

00:15:31,279 --> 00:15:34,160
where the application no longer cares

00:15:32,809 --> 00:15:36,049
about this stuff the application doesn't

00:15:34,160 --> 00:15:38,379
care about where it's connecting to so

00:15:36,049 --> 00:15:40,369
I'm aware of where it's connecting to

00:15:38,379 --> 00:15:42,769
registrations automatic and a framework

00:15:40,369 --> 00:15:44,299
takes where it's where it's going to sto

00:15:42,769 --> 00:15:45,980
is playing into that because it's

00:15:44,299 --> 00:15:48,169
sitting in kind of taking over from

00:15:45,980 --> 00:15:49,609
kubernetes default service discovery so

00:15:48,169 --> 00:15:51,829
that when you turn around from an sto

00:15:49,609 --> 00:15:53,660
enabled kubernetes stack and say I want

00:15:51,829 --> 00:15:55,009
to talk to service fred will list Yoko

00:15:53,660 --> 00:15:57,290
Turner I'll say well are you allowed to

00:15:55,009 --> 00:15:58,369
talk to service fred and if the answer's

00:15:57,290 --> 00:16:00,009
no it does turn around say well there

00:15:58,369 --> 00:16:02,389
isn't a service fred for you to talk to

00:16:00,009 --> 00:16:03,649
or it could actually be that there were

00:16:02,389 --> 00:16:04,999
three different versions of Fred you

00:16:03,649 --> 00:16:07,579
might Fred one Fred two and Fred's

00:16:04,999 --> 00:16:09,259
redeployed concurrently and then sto

00:16:07,579 --> 00:16:10,519
will make the choice as to which Fred

00:16:09,259 --> 00:16:12,739
you're gonna connect to based on the

00:16:10,519 --> 00:16:13,910
policies that you've told it to use so

00:16:12,739 --> 00:16:15,919
you could have it so that if your user

00:16:13,910 --> 00:16:18,679
ID is Grahame you'll be connected to

00:16:15,919 --> 00:16:20,359
Fred two if your user ID is Erin you'll

00:16:18,679 --> 00:16:21,889
be connected to Fred three and everybody

00:16:20,359 --> 00:16:23,209
else get stuck with Fred one because

00:16:21,889 --> 00:16:26,779
that's the one that's in production and

00:16:23,209 --> 00:16:28,129
the other two are beta so it's it's an

00:16:26,779 --> 00:16:29,600
interesting way of looking at it but no

00:16:28,129 --> 00:16:32,059
longer does the application have to care

00:16:29,600 --> 00:16:33,470
is pushing out the configuration of how

00:16:32,059 --> 00:16:35,089
the service discovery is functioning to

00:16:33,470 --> 00:16:36,529
an ops level and all that's done by the

00:16:35,089 --> 00:16:38,449
control plane so it's all done using

00:16:36,529 --> 00:16:40,009
proper config files instead of little

00:16:38,449 --> 00:16:41,299
mishmash bits of Yama land properties

00:16:40,009 --> 00:16:43,100
that you've scattered to the four winds

00:16:41,299 --> 00:16:44,600
and deployed to containers that you

00:16:43,100 --> 00:16:46,369
can't remember what you set them to or

00:16:44,600 --> 00:16:47,839
you've put in environment variables that

00:16:46,369 --> 00:16:49,600
you have to go to various web console to

00:16:47,839 --> 00:16:53,299
edit to keep everything in sync by hand

00:16:49,600 --> 00:16:54,169
this one makes sense the other way it's

00:16:53,299 --> 00:16:56,779
it's tricky

00:16:54,169 --> 00:16:58,639
a quick note for micro profile for the

00:16:56,779 --> 00:17:00,439
one person I know who deeply cares about

00:16:58,639 --> 00:17:01,639
it in the room at the moment that Mykel

00:17:00,439 --> 00:17:03,829
profile doesn't have anything to say

00:17:01,639 --> 00:17:05,240
about services go it's not saying that

00:17:03,829 --> 00:17:07,069
it's lacking a feature here it's not

00:17:05,240 --> 00:17:08,600
saying that it's not doing anything it's

00:17:07,069 --> 00:17:09,709
basically saying that micro profile just

00:17:08,600 --> 00:17:11,029
doesn't need to worry about service

00:17:09,709 --> 00:17:13,130
discovery because it's somebody else's

00:17:11,029 --> 00:17:14,750
job if you're using a microphone file

00:17:13,130 --> 00:17:16,309
app somewhere or a deployment

00:17:14,750 --> 00:17:18,319
you're gonna have service discovery but

00:17:16,309 --> 00:17:21,649
it's just not down to my profile to make

00:17:18,319 --> 00:17:24,559
that choice so talking about service

00:17:21,649 --> 00:17:26,929
discovery if we've got Netflix apps that

00:17:24,559 --> 00:17:28,179
are using Eureka and you need to bring

00:17:26,929 --> 00:17:30,230
them over and put them on kubernetes

00:17:28,179 --> 00:17:32,600
what do you do

00:17:30,230 --> 00:17:34,639
do you rewrite the entire app because as

00:17:32,600 --> 00:17:37,519
Aaron was showing earlier the code that

00:17:34,639 --> 00:17:39,049
Netflix uses in the code that spring

00:17:37,519 --> 00:17:41,750
uses to say that you're gonna use a

00:17:39,049 --> 00:17:43,639
eureka server he's actually very very

00:17:41,750 --> 00:17:45,679
specific he turns around says at enable

00:17:43,639 --> 00:17:47,419
Eureka server or at enable Eureka client

00:17:45,679 --> 00:17:49,130
that's not just a statement saying I

00:17:47,419 --> 00:17:50,570
want to use service discovery that's a

00:17:49,130 --> 00:17:52,870
statement saying I want to use service

00:17:50,570 --> 00:17:55,010
discovery on a particular technology and

00:17:52,870 --> 00:17:56,750
quite often you can end up not just

00:17:55,010 --> 00:17:59,330
injecting a discovery client which is

00:17:56,750 --> 00:18:01,340
the nice standardized abstract way of

00:17:59,330 --> 00:18:03,200
talking discovery you can see spring

00:18:01,340 --> 00:18:05,299
code that has injected eureka clients

00:18:03,200 --> 00:18:07,630
that means that code could be making

00:18:05,299 --> 00:18:10,549
client-side load balancing decisions

00:18:07,630 --> 00:18:12,350
which is interesting because if it

00:18:10,549 --> 00:18:13,820
relies on that if it was the code that

00:18:12,350 --> 00:18:14,899
was there was critical that it had to

00:18:13,820 --> 00:18:16,490
make the choice of which one it was

00:18:14,899 --> 00:18:18,649
connected to so it was manually

00:18:16,490 --> 00:18:20,120
implementing sticky sessions then you

00:18:18,649 --> 00:18:21,529
have to maintain that behavior as you

00:18:20,120 --> 00:18:24,980
roll out to another architecture like

00:18:21,529 --> 00:18:26,779
kubernetes so just for kind of

00:18:24,980 --> 00:18:28,820
entertainment value like rolled out to

00:18:26,779 --> 00:18:31,010
kubernetes cluster and then deployed

00:18:28,820 --> 00:18:32,480
Eureka to it because Eureka's our

00:18:31,010 --> 00:18:34,250
container like any other so I pushed it

00:18:32,480 --> 00:18:36,320
out set up a cluster of Eureka servers

00:18:34,250 --> 00:18:38,510
inside my new kubernetes cluster and

00:18:36,320 --> 00:18:39,740
then I started setting up applications

00:18:38,510 --> 00:18:42,200
on spring and I told them to start

00:18:39,740 --> 00:18:43,779
talking to Eureka and you get into this

00:18:42,200 --> 00:18:45,830
wonderful world of pain

00:18:43,779 --> 00:18:46,940
because you've got your applications on

00:18:45,830 --> 00:18:49,669
the one hand saying hey where's the

00:18:46,940 --> 00:18:51,500
Eureka server but at this point Eureka

00:18:49,669 --> 00:18:52,639
is not in play right because they don't

00:18:51,500 --> 00:18:53,870
know whether you're eco server is so

00:18:52,639 --> 00:18:56,029
there's no way it can get in the way of

00:18:53,870 --> 00:18:57,620
it so what happens is kubernetes turns

00:18:56,029 --> 00:18:59,630
around and says Eureka servers over

00:18:57,620 --> 00:19:01,159
there performing service discovery for

00:18:59,630 --> 00:19:03,169
your spring app that wants to use Eureka

00:19:01,159 --> 00:19:05,210
based service discovery so you

00:19:03,169 --> 00:19:07,639
bootstrapped your spring app now so that

00:19:05,210 --> 00:19:09,019
it's found its Eureka server the request

00:19:07,639 --> 00:19:10,460
compacts from you ago oh I'm here

00:19:09,019 --> 00:19:12,019
anytime I say I need to talk we service

00:19:10,460 --> 00:19:14,000
fred tell me where all the service

00:19:12,019 --> 00:19:16,549
friends are and here's where things get

00:19:14,000 --> 00:19:18,080
really really twisted because your

00:19:16,549 --> 00:19:20,090
Eureka server turned I said I know of

00:19:18,080 --> 00:19:21,230
three friends there's that one that was

00:19:20,090 --> 00:19:22,220
sitting there that one that's sitting

00:19:21,230 --> 00:19:25,070
there and there's that one scene over

00:19:22,220 --> 00:19:26,809
there but you know I'm gonna give you

00:19:25,070 --> 00:19:28,820
the exact seat address of where each of

00:19:26,809 --> 00:19:30,019
these friends are and then you're gonna

00:19:28,820 --> 00:19:32,419
decide which one you want to talk to

00:19:30,019 --> 00:19:34,820
seek oh great I'll talk to Freight too

00:19:32,419 --> 00:19:37,309
and you don't have to start talking with

00:19:34,820 --> 00:19:39,049
fred - and your kubernetes cluster says

00:19:37,309 --> 00:19:40,250
wait you're trying to talk to our fred I

00:19:39,049 --> 00:19:41,570
know what you're doing here and it

00:19:40,250 --> 00:19:43,399
randomly connects you to any fred that

00:19:41,570 --> 00:19:43,850
you want to talk to because all of the

00:19:43,399 --> 00:19:45,289
threads

00:19:43,850 --> 00:19:46,850
two and three were actually declared as

00:19:45,289 --> 00:19:49,039
a service type threat when you were

00:19:46,850 --> 00:19:51,200
given your URL from this Eureka service

00:19:49,039 --> 00:19:54,410
registry you were given a URL to this

00:19:51,200 --> 00:19:56,210
kubernetes service fred which is itself

00:19:54,410 --> 00:19:57,590
an abstract service discovery proxy that

00:19:56,210 --> 00:19:59,570
goes off and finds an actual threat to

00:19:57,590 --> 00:20:00,740
connect you to so your attempt to talk

00:19:59,570 --> 00:20:01,970
to a particular friends and helping

00:20:00,740 --> 00:20:04,309
completely thwarted and you're now

00:20:01,970 --> 00:20:05,690
talking to a random fred again so you

00:20:04,309 --> 00:20:07,669
think I know I'll get roundness I'll

00:20:05,690 --> 00:20:08,030
change the way my clients register to

00:20:07,669 --> 00:20:09,590
Eureka

00:20:08,030 --> 00:20:11,270
I'll have them instead of registering

00:20:09,590 --> 00:20:12,710
using the kubernetes service URL I'll

00:20:11,270 --> 00:20:16,400
have them register using their pot IP

00:20:12,710 --> 00:20:18,409
that's awesome I tried this it's it's

00:20:16,400 --> 00:20:19,789
rather entertaining you end up with a

00:20:18,409 --> 00:20:21,710
Eureka service rectory that now knows

00:20:19,789 --> 00:20:23,750
exactly where each of the threads are to

00:20:21,710 --> 00:20:25,460
the T and you turn around say I want to

00:20:23,750 --> 00:20:26,960
talk to service Fred Eureka gives you

00:20:25,460 --> 00:20:29,330
the IP address and you connect to that

00:20:26,960 --> 00:20:31,429
pod IP and you think excellent I've

00:20:29,330 --> 00:20:33,679
solved it everything's working and then

00:20:31,429 --> 00:20:35,929
you deploy sto to the cluster and you

00:20:33,679 --> 00:20:37,130
say sto up to say that when user Graham

00:20:35,929 --> 00:20:39,140
is coming through they're only allowed

00:20:37,130 --> 00:20:41,299
to basically be routed to Fred - and

00:20:39,140 --> 00:20:43,549
your client code comes along and says I

00:20:41,299 --> 00:20:46,159
need to talk to Fred my user ID is

00:20:43,549 --> 00:20:46,669
Graham and Eureka turned round said oh

00:20:46,159 --> 00:20:49,070
well

00:20:46,669 --> 00:20:50,059
fred is basically over there that's the

00:20:49,070 --> 00:20:52,370
Fred you want I'll connect to you

00:20:50,059 --> 00:20:54,320
exactly - that one an sto turned round

00:20:52,370 --> 00:20:55,970
at that point should turn around and say

00:20:54,320 --> 00:20:58,490
but you're supposed to talk to Fred -

00:20:55,970 --> 00:20:59,809
I'm gonna make you talk to Fred - except

00:20:58,490 --> 00:21:01,220
it can't because you're not asking for

00:20:59,809 --> 00:21:03,320
Fred anymore you're now asking for an

00:21:01,220 --> 00:21:05,360
exact IP address of a service within

00:21:03,320 --> 00:21:08,870
your cluster so you bypass the whole of

00:21:05,360 --> 00:21:13,669
iste iÃ³ in one step so is it possible to

00:21:08,870 --> 00:21:15,500
deploy this yes is it practical no you

00:21:13,669 --> 00:21:17,480
can make this stuff work it has great

00:21:15,500 --> 00:21:19,070
caveats you can pull it together but

00:21:17,480 --> 00:21:21,500
actually administering a system that

00:21:19,070 --> 00:21:23,870
sitting like that is very tricky

00:21:21,500 --> 00:21:25,309
if you allow people who are expecting to

00:21:23,870 --> 00:21:27,260
administer a kubernetes system to look

00:21:25,309 --> 00:21:28,580
at that then you're in for even even

00:21:27,260 --> 00:21:29,900
worse pain because they're gonna come

00:21:28,580 --> 00:21:31,730
along assuming that certain things are

00:21:29,900 --> 00:21:32,929
still true if you deploy it to a cluster

00:21:31,730 --> 00:21:34,640
where your ops team are they rely on

00:21:32,929 --> 00:21:36,289
this teo to do that they're gonna hate

00:21:34,640 --> 00:21:37,610
you because you're just gonna sidestep

00:21:36,289 --> 00:21:39,789
all of their nice policies they start

00:21:37,610 --> 00:21:39,789
creating

00:21:40,340 --> 00:21:44,909
that said it's not all doom and gloom

00:21:42,690 --> 00:21:46,679
there are ways to integrate these kind

00:21:44,909 --> 00:21:48,539
of frameworks together and although a

00:21:46,679 --> 00:21:49,710
lot of spring does have things like that

00:21:48,539 --> 00:21:51,419
enable Eureka server

00:21:49,710 --> 00:21:53,760
it also has things like map discovery

00:21:51,419 --> 00:21:55,919
client and ribbon and zip King and

00:21:53,760 --> 00:21:59,519
config map and business pieces that you

00:21:55,919 --> 00:22:01,620
know spring extensions which are aspects

00:21:59,519 --> 00:22:03,390
of spring config that would map really

00:22:01,620 --> 00:22:04,799
really well to existing functionality

00:22:03,390 --> 00:22:06,630
that exists within kubernetes and

00:22:04,799 --> 00:22:08,669
there's the project called spring cloud

00:22:06,630 --> 00:22:11,250
kubernetes that offers kubernetes

00:22:08,669 --> 00:22:13,740
specific implementations of spring api's

00:22:11,250 --> 00:22:15,029
and so that you can get hold of and

00:22:13,740 --> 00:22:17,010
inject yourself with the spring auto

00:22:15,029 --> 00:22:18,899
wire stuff you can inject yourself a

00:22:17,010 --> 00:22:20,700
version of a spring discovery client and

00:22:18,899 --> 00:22:22,679
if you ask that hey I need to talk to

00:22:20,700 --> 00:22:24,330
service friend then it's then a delegate

00:22:22,679 --> 00:22:26,399
down to the kubernetes service discovery

00:22:24,330 --> 00:22:28,350
which in the case of a cluster that's

00:22:26,399 --> 00:22:30,360
got SDIO present will delegate to sto

00:22:28,350 --> 00:22:32,549
and which point your spring app is now

00:22:30,360 --> 00:22:33,950
talking natively through ISTE own and

00:22:32,549 --> 00:22:36,029
the whole mesh comes back together again

00:22:33,950 --> 00:22:38,070
the trick here is of course that you're

00:22:36,029 --> 00:22:40,940
talking to the generic discovery client

00:22:38,070 --> 00:22:44,669
and not to and Eureka client specific

00:22:40,940 --> 00:22:46,320
it's a lot of fun the bits like ribbon

00:22:44,669 --> 00:22:47,639
is client-side load balancing if you

00:22:46,320 --> 00:22:49,049
plug that in there's a plug in there

00:22:47,639 --> 00:22:51,360
that wall so route that out through ku

00:22:49,049 --> 00:22:52,919
Zipkin spur distributed trace and

00:22:51,360 --> 00:22:54,299
there's plugins again from spring

00:22:52,919 --> 00:22:55,649
calculate is the plug that in and so

00:22:54,299 --> 00:22:58,380
that it will connect across the

00:22:55,649 --> 00:23:00,510
kubernetes trace api and config map is a

00:22:58,380 --> 00:23:02,909
kubernetes concept for a key value store

00:23:00,510 --> 00:23:05,070
and there's a spring crowd kubernetes

00:23:02,909 --> 00:23:08,039
plugin that allows you to dynamically

00:23:05,070 --> 00:23:10,019
access the the configuration elements

00:23:08,039 --> 00:23:11,580
from your spring cloud stuff by just

00:23:10,019 --> 00:23:13,980
injecting it like you would with normal

00:23:11,580 --> 00:23:15,630
spring properties so that gives you a

00:23:13,980 --> 00:23:17,070
way to configure your spring application

00:23:15,630 --> 00:23:18,450
without needing to have too much data

00:23:17,070 --> 00:23:19,980
inside an application yeah more

00:23:18,450 --> 00:23:22,080
somewhere you can store it in a Cuban

00:23:19,980 --> 00:23:24,000
et's config map and transparently inject

00:23:22,080 --> 00:23:25,590
it directly into your app as if yeah it

00:23:24,000 --> 00:23:28,490
was just any other spring configuration

00:23:25,590 --> 00:23:30,960
I wouldn't recommend trying this with a

00:23:28,490 --> 00:23:33,960
mutual author turned on mutual TLS for

00:23:30,960 --> 00:23:36,419
SEO at the moment there's issues to do

00:23:33,960 --> 00:23:38,580
with which ports are allowed and how the

00:23:36,419 --> 00:23:40,230
data communicates that will get you into

00:23:38,580 --> 00:23:41,399
trouble so it's best to avoid I know

00:23:40,230 --> 00:23:42,330
that people who are working on it at the

00:23:41,399 --> 00:23:45,090
moment and they're trying to put it back

00:23:42,330 --> 00:23:47,250
together honest so we should look

00:23:45,090 --> 00:23:48,539
quickly at spring fault tolerance if

00:23:47,250 --> 00:23:50,909
you're looking at spring

00:23:48,539 --> 00:23:52,060
Springs got history how many people know

00:23:50,909 --> 00:23:55,990
of hystrix

00:23:52,060 --> 00:23:58,000
a few quite a lot cool hysterics handles

00:23:55,990 --> 00:23:59,620
all the wonderful things there so you

00:23:58,000 --> 00:24:00,970
know time out you want to make sure that

00:23:59,620 --> 00:24:02,320
if you try to talk to a service if it

00:24:00,970 --> 00:24:05,290
doesn't answer within X that you

00:24:02,320 --> 00:24:07,570
Benchley timeout before your time before

00:24:05,290 --> 00:24:09,490
your sock it ends up timing out retry is

00:24:07,570 --> 00:24:10,810
easy enough if you're trying to talk to

00:24:09,490 --> 00:24:12,130
a service it doesn't answer the first

00:24:10,810 --> 00:24:13,900
time maybe it'll answer again if you

00:24:12,130 --> 00:24:16,630
keep ringing it's just like bringing the

00:24:13,900 --> 00:24:17,860
doorbell right either somebody I'll

00:24:16,630 --> 00:24:19,000
answer or they'll give up and decide

00:24:17,860 --> 00:24:19,570
you're horrific and learn I'll see you

00:24:19,000 --> 00:24:21,970
ever again

00:24:19,570 --> 00:24:23,260
fall back is Erin covered this one if

00:24:21,970 --> 00:24:24,250
you want to talk to a service and it

00:24:23,260 --> 00:24:25,390
doesn't answer maybe there's another

00:24:24,250 --> 00:24:26,710
service you can talk to they will give

00:24:25,390 --> 00:24:28,060
you another answer works well for

00:24:26,710 --> 00:24:29,550
Netflix if they want to list a movies

00:24:28,060 --> 00:24:32,170
not so great if you want to stock price

00:24:29,550 --> 00:24:33,490
yeah trying to find another fallback

00:24:32,170 --> 00:24:36,430
service for the stock price of your

00:24:33,490 --> 00:24:38,260
company isn't such a great plan circuit

00:24:36,430 --> 00:24:39,490
breaking is you know you haven't you've

00:24:38,260 --> 00:24:41,050
talked to this service for a bit and

00:24:39,490 --> 00:24:42,790
other people are talking to this service

00:24:41,050 --> 00:24:44,920
for a bit and it's not responding and

00:24:42,790 --> 00:24:46,660
what are you gonna do well it's best at

00:24:44,920 --> 00:24:48,490
this point if the service is struggling

00:24:46,660 --> 00:24:49,930
if the service has got like all of the

00:24:48,490 --> 00:24:51,610
threads it's got available to it working

00:24:49,930 --> 00:24:52,690
on trying to give answers the worst

00:24:51,610 --> 00:24:53,950
thing you can do is let any more

00:24:52,690 --> 00:24:54,750
requests to land on it because it will

00:24:53,950 --> 00:24:57,640
never finish it

00:24:54,750 --> 00:24:59,140
so yeah that would've basically let you

00:24:57,640 --> 00:25:00,250
turn those off give the service a chance

00:24:59,140 --> 00:25:02,410
to recover and then maybe everything

00:25:00,250 --> 00:25:03,730
will come back together bulk heading is

00:25:02,410 --> 00:25:05,110
one way you basically say I'm only going

00:25:03,730 --> 00:25:07,570
to allow so many people to talk to the

00:25:05,110 --> 00:25:08,980
service at one point and the thing about

00:25:07,570 --> 00:25:10,570
these capabilities is they're not just

00:25:08,980 --> 00:25:11,860
common for history they're present

00:25:10,570 --> 00:25:13,150
within micro profile they've got their

00:25:11,860 --> 00:25:15,040
own spec they're called fall torrents

00:25:13,150 --> 00:25:17,080
one point no and that basically provides

00:25:15,040 --> 00:25:18,970
all those capabilities again and then

00:25:17,080 --> 00:25:20,680
when you go over to sto the same Lots

00:25:18,970 --> 00:25:21,880
all there again as well the key

00:25:20,680 --> 00:25:23,320
difference is of course that when you're

00:25:21,880 --> 00:25:24,730
doing this for a micro profile when

00:25:23,320 --> 00:25:25,900
you're doing this from History X you're

00:25:24,730 --> 00:25:28,180
doing it with code inside your

00:25:25,900 --> 00:25:29,680
application in historic space you create

00:25:28,180 --> 00:25:31,300
a thing called a history command that

00:25:29,680 --> 00:25:32,890
wraps the invocation to the service that

00:25:31,300 --> 00:25:34,540
you're trying to do to and the history

00:25:32,890 --> 00:25:36,460
command specifies the behavior of

00:25:34,540 --> 00:25:37,750
whether you want to do a retrial whether

00:25:36,460 --> 00:25:39,640
you want to fall back and so on and so

00:25:37,750 --> 00:25:41,050
on but the point is that if you needed

00:25:39,640 --> 00:25:41,650
to move your code off of history to

00:25:41,050 --> 00:25:44,050
somewhere else

00:25:41,650 --> 00:25:45,850
you've got to rewrite all that code it's

00:25:44,050 --> 00:25:48,190
Joan doesn't have any code in the app

00:25:45,850 --> 00:25:49,750
the behaviors at the network level you

00:25:48,190 --> 00:25:51,520
try talking to a service the network

00:25:49,750 --> 00:25:53,380
decided according to the policies that

00:25:51,520 --> 00:25:54,850
you defined by the control plane decides

00:25:53,380 --> 00:25:56,230
that you should be retrying that or it

00:25:54,850 --> 00:25:57,970
will retry the request for you it

00:25:56,230 --> 00:26:00,280
decides if you want to go off and have

00:25:57,970 --> 00:26:02,860
other behaviors later on to it so your

00:26:00,280 --> 00:26:04,870
application has no code and I say almost

00:26:02,860 --> 00:26:05,600
because of course if the request

00:26:04,870 --> 00:26:07,130
actually fail

00:26:05,600 --> 00:26:08,690
you still need to handle the failure at

00:26:07,130 --> 00:26:10,730
the end of the day it's not sufficient

00:26:08,690 --> 00:26:12,560
to just magically have your platform

00:26:10,730 --> 00:26:13,790
find out but the service isn't there

00:26:12,560 --> 00:26:14,930
you're going to have to still deal with

00:26:13,790 --> 00:26:16,630
the factor of the end of a if he's not

00:26:14,930 --> 00:26:19,430
there that's your good job to deal with

00:26:16,630 --> 00:26:20,900
and the fault injection fault injection

00:26:19,430 --> 00:26:22,040
is the great one that comes free from

00:26:20,900 --> 00:26:24,890
hemorrhoids you can actually have the

00:26:22,040 --> 00:26:26,660
things lie ever wondered how well your

00:26:24,890 --> 00:26:27,830
microservice mesh would survive if one

00:26:26,660 --> 00:26:30,440
of your services started randomly

00:26:27,830 --> 00:26:31,970
returning a 404 perhaps one of your mic

00:26:30,440 --> 00:26:33,470
reserves has already returns a 404

00:26:31,970 --> 00:26:36,110
occation you've seen what happens yes

00:26:33,470 --> 00:26:37,490
right so the key thing here is you can

00:26:36,110 --> 00:26:38,750
do this in a safe test environment

00:26:37,490 --> 00:26:40,190
before it gets to the point where you

00:26:38,750 --> 00:26:41,840
need to do it in production and debug

00:26:40,190 --> 00:26:44,060
what what happens if a service falls

00:26:41,840 --> 00:26:46,820
over takes too long to reply or isn't

00:26:44,060 --> 00:26:49,760
answering so it's Jonas you do that kind

00:26:46,820 --> 00:26:52,730
of fault injection and simulate failures

00:26:49,760 --> 00:26:54,800
within your graph Security's our next

00:26:52,730 --> 00:26:56,960
one security spring security is great

00:26:54,800 --> 00:26:59,090
fun I've had the joy of digging into

00:26:56,960 --> 00:27:02,360
incredibly deeply over the last sort of

00:26:59,090 --> 00:27:03,440
six to eight weeks it's a combination of

00:27:02,360 --> 00:27:04,970
a bunch of building blocks they're

00:27:03,440 --> 00:27:07,370
incredibly flexible you can make them do

00:27:04,970 --> 00:27:09,920
anything you want and the cost that

00:27:07,370 --> 00:27:11,300
comes with that is that basically you've

00:27:09,920 --> 00:27:12,890
got a huge cognitive load you have to

00:27:11,300 --> 00:27:14,090
understand how the framework works you

00:27:12,890 --> 00:27:15,560
have to understand what it is you're

00:27:14,090 --> 00:27:16,940
trying to achieve with it you have to

00:27:15,560 --> 00:27:18,170
understand the implications of what

00:27:16,940 --> 00:27:19,520
you're doing and whether you end up with

00:27:18,170 --> 00:27:22,010
something that's ultimately secure is

00:27:19,520 --> 00:27:23,240
your problem it's very easy to end up

00:27:22,010 --> 00:27:24,830
with ones that just bypass the whole

00:27:23,240 --> 00:27:27,860
stack just by sending the wrong response

00:27:24,830 --> 00:27:29,720
at the wrong layer but at the end of the

00:27:27,860 --> 00:27:31,010
day it does work is flexible it will do

00:27:29,720 --> 00:27:33,230
whatever you need and the code is part

00:27:31,010 --> 00:27:35,470
of your app micro profile offers another

00:27:33,230 --> 00:27:37,910
approach micro profile has JWT

00:27:35,470 --> 00:27:39,680
propagation that allows you to basically

00:27:37,910 --> 00:27:41,990
mark methods on your services and say

00:27:39,680 --> 00:27:43,910
that this one requires authentication by

00:27:41,990 --> 00:27:45,770
a user that has a given role and the

00:27:43,910 --> 00:27:48,080
role is retrieved from the JWT that it's

00:27:45,770 --> 00:27:49,820
used to authenticate the request but

00:27:48,080 --> 00:27:51,940
again you're annotating code in your

00:27:49,820 --> 00:27:55,730
application with your security concerns

00:27:51,940 --> 00:27:57,020
SEO comes along and says well knowing if

00:27:55,730 --> 00:27:58,340
a service should talk to another service

00:27:57,020 --> 00:28:00,440
isn't really something I want in the

00:27:58,340 --> 00:28:02,540
code that's kind of an OPS level concern

00:28:00,440 --> 00:28:04,220
I want to be able to configure that and

00:28:02,540 --> 00:28:05,360
say that you know all of the services

00:28:04,220 --> 00:28:06,860
will talk to each other they're all

00:28:05,360 --> 00:28:09,500
going to be secured on a traffic level

00:28:06,860 --> 00:28:11,120
using mutual TLS and what I need to know

00:28:09,500 --> 00:28:13,010
now is should this service be allowed to

00:28:11,120 --> 00:28:16,640
talk to that service and as a policy

00:28:13,010 --> 00:28:17,960
decision that's fed in by mixer so

00:28:16,640 --> 00:28:19,140
lastly we come up to trace a lot of

00:28:17,960 --> 00:28:21,300
metrics

00:28:19,140 --> 00:28:22,980
ring has a price little handy project

00:28:21,300 --> 00:28:24,270
called actuators you turn that on you

00:28:22,980 --> 00:28:25,470
get a bunch load of metrics and you get

00:28:24,270 --> 00:28:27,600
a bunch of little health endpoints and

00:28:25,470 --> 00:28:28,680
it's quite easy to play with you can

00:28:27,600 --> 00:28:30,570
customize them make them do it you're

00:28:28,680 --> 00:28:32,700
one sleuth is handling end to end

00:28:30,570 --> 00:28:33,780
tracing within spring so if you want to

00:28:32,700 --> 00:28:35,100
see a request flowing all the way

00:28:33,780 --> 00:28:37,680
through the different services end to

00:28:35,100 --> 00:28:38,910
end will handle that micro profile on

00:28:37,680 --> 00:28:40,590
the other hands is very similar

00:28:38,910 --> 00:28:43,290
capabilities within metrics one I want

00:28:40,590 --> 00:28:44,730
an open tracing but again SDO is the odd

00:28:43,290 --> 00:28:46,500
one out here because it's not inside

00:28:44,730 --> 00:28:48,120
your application it's sitting outside

00:28:46,500 --> 00:28:49,380
but because it's seeing all the traffic

00:28:48,120 --> 00:28:51,780
you can achieve much of the same goals

00:28:49,380 --> 00:28:53,730
you can still see a request flowing into

00:28:51,780 --> 00:28:55,920
end so you can collect all of that stuff

00:28:53,730 --> 00:28:58,410
you can still collect metrics from all

00:28:55,920 --> 00:28:59,790
of those nboyer endpoints and have those

00:28:58,410 --> 00:29:02,310
routed through to Prometheus where you

00:28:59,790 --> 00:29:04,440
can render them in dashboards and you

00:29:02,310 --> 00:29:05,850
can do things like this because Emily

00:29:04,440 --> 00:29:08,040
knows everything about where your

00:29:05,850 --> 00:29:09,750
traffic's flying so it can generate you

00:29:08,040 --> 00:29:11,160
a real-time graph of where your services

00:29:09,750 --> 00:29:12,420
are on how they've connected and start

00:29:11,160 --> 00:29:14,670
showing you where the data is within

00:29:12,420 --> 00:29:16,350
that now showing you which services are

00:29:14,670 --> 00:29:17,640
retrieving like thousands of requests a

00:29:16,350 --> 00:29:19,980
second versus the one that's sitting

00:29:17,640 --> 00:29:20,670
there not doing much I like that I think

00:29:19,980 --> 00:29:22,140
it's kind of cool

00:29:20,670 --> 00:29:23,460
not just because I've built something

00:29:22,140 --> 00:29:26,520
that looked rather similar a few years

00:29:23,460 --> 00:29:29,310
back but that's that comes to the end of

00:29:26,520 --> 00:29:31,650
where I wanted to get to of this so if

00:29:29,310 --> 00:29:35,390
you've got like need the need to go and

00:29:31,650 --> 00:29:38,550
find more you can go to sto sto die of

00:29:35,390 --> 00:29:40,590
spring a spring buyer or micro profile

00:29:38,550 --> 00:29:42,360
at micro profile tile or you can come to

00:29:40,590 --> 00:29:43,920
Ozzy but not at i/o because I'm not Ozzy

00:29:42,360 --> 00:29:52,050
aiyyo aiyyo aiyyo because that's gets

00:29:43,920 --> 00:29:54,680
very confusing so any questions no one

00:29:52,050 --> 00:29:54,680
question yes

00:30:04,260 --> 00:30:07,860
yes this deer comes with an ingress

00:30:06,000 --> 00:30:10,410
module on kubernetes at least

00:30:07,860 --> 00:30:12,090
so there's sto ingress and if you deploy

00:30:10,410 --> 00:30:13,860
and you configure rules on this Jo

00:30:12,090 --> 00:30:16,049
ingress then you can apply the same

00:30:13,860 --> 00:30:17,490
policies that you have between service

00:30:16,049 --> 00:30:19,860
to service to the traffic that's

00:30:17,490 --> 00:30:20,940
entering your service measure so you can

00:30:19,860 --> 00:30:22,410
say like things that come in with a

00:30:20,940 --> 00:30:24,390
particular header must be routed to the

00:30:22,410 --> 00:30:26,220
following service at this version and so

00:30:24,390 --> 00:30:30,450
on and so on so you can control all the

00:30:26,220 --> 00:30:32,309
flows across the entire graph now

00:30:30,450 --> 00:30:34,200
foundries integration with SDIO isn't

00:30:32,309 --> 00:30:37,980
complete at this stage so I can't speak

00:30:34,200 --> 00:30:42,960
to the capabilities you can Google as

00:30:37,980 --> 00:30:45,350
well cool I think well thank you very

00:30:42,960 --> 00:30:45,350
much you're wrong

00:30:45,780 --> 00:30:48,680

YouTube URL: https://www.youtube.com/watch?v=bUi_8v99jrc


