Title: Managing Session State with REDIS and Spring Data Redis - Ram Gopinathan, T-Mobile
Publication date: 2018-04-21
Playlist: Cloud Foundry Summit NA 2018
Description: 
	Managing Session State with REDIS and Spring Data Redis - Ram Gopinathan, T-Mobile

A cloud-native web application that is used by millions of users, managing session state in a clustered environment can bring numerous challenges. This session will focus on leveraging REDIS along with Spring Data Redis for managing session state. We will discuss benefits of using REDIS, various tips and tricks, things to watch out for, etc. learned from large-scale implementations in the real world 

About Ram Gopinathan
Ram is a Principal Architect with T-Mobile with 22+ years of experience in the industry with a focus on AWS Cloud, DevOps, Docker and microservices, API first design and Internet of things solutions.
Captions: 
	00:00:00,030 --> 00:00:05,339
basically my team at t-mobile is called

00:00:02,629 --> 00:00:09,809
digital technology development what we

00:00:05,339 --> 00:00:12,240
do we basically build run and operate

00:00:09,809 --> 00:00:21,000
infrastructure and applications that are

00:00:12,240 --> 00:00:23,519
used by our customers so before I talk

00:00:21,000 --> 00:00:27,060
about a little bit about the company I

00:00:23,519 --> 00:00:30,890
just want to show of hands how many

00:00:27,060 --> 00:00:34,260
people are actually developers here

00:00:30,890 --> 00:00:39,649
developers ok how many of you work on

00:00:34,260 --> 00:00:43,710
web applications ok so a lot of people

00:00:39,649 --> 00:00:45,719
do you guys think state this evil

00:00:43,710 --> 00:00:48,300
Accession state is evil I'm just curious

00:00:45,719 --> 00:00:50,340
how many how many think session state is

00:00:48,300 --> 00:00:54,180
evil do you think we can like not have

00:00:50,340 --> 00:00:57,390
such a session state okay so yeah it's

00:00:54,180 --> 00:00:59,789
it's a necessary evil right so hopefully

00:00:57,390 --> 00:01:04,110
you know what I am hoping to achieve

00:00:59,789 --> 00:01:06,450
from this talk is to kind of talk about

00:01:04,110 --> 00:01:08,100
hey maybe session state is not so evil

00:01:06,450 --> 00:01:10,890
there are there are use cases especially

00:01:08,100 --> 00:01:13,260
if you think about our applications that

00:01:10,890 --> 00:01:14,909
we work on our typical websites where

00:01:13,260 --> 00:01:17,970
there's some commerce type of things you

00:01:14,909 --> 00:01:20,130
you log in to the website and then

00:01:17,970 --> 00:01:22,140
there's a session established and there

00:01:20,130 --> 00:01:26,549
are things that you do as a part of that

00:01:22,140 --> 00:01:28,229
session for example I might add some

00:01:26,549 --> 00:01:30,329
products into my shopping cart the

00:01:28,229 --> 00:01:33,479
shopping cart might be the data might be

00:01:30,329 --> 00:01:37,829
in the session State and then when when

00:01:33,479 --> 00:01:39,960
I leave that data is gone right for us

00:01:37,829 --> 00:01:43,649
like what some of the some of the use

00:01:39,960 --> 00:01:46,140
cases are you know I might want to

00:01:43,649 --> 00:01:49,200
upgrade my phone as a customer I might

00:01:46,140 --> 00:01:52,110
want to buy a new accessories so you

00:01:49,200 --> 00:01:55,049
know there's experiences that takes the

00:01:52,110 --> 00:01:56,790
user to kind of looking for something

00:01:55,049 --> 00:01:58,680
they want to buy and then add it to the

00:01:56,790 --> 00:02:03,000
cart so there's a lot of like state data

00:01:58,680 --> 00:02:04,590
that we deal with so so sessions like

00:02:03,000 --> 00:02:07,170
even though we're kind of moving into a

00:02:04,590 --> 00:02:10,140
modern application architectures where

00:02:07,170 --> 00:02:12,629
you have web experiences and then

00:02:10,140 --> 00:02:12,840
they're powered by AP is right and we

00:02:12,629 --> 00:02:14,760
all

00:02:12,840 --> 00:02:17,459
no like we want to try to as much as

00:02:14,760 --> 00:02:20,400
possible build our API is in a stateless

00:02:17,459 --> 00:02:23,580
manner but you know session management

00:02:20,400 --> 00:02:25,890
is still relevant and so hopefully in

00:02:23,580 --> 00:02:28,200
this talk you'll be able to see like how

00:02:25,890 --> 00:02:31,500
you can architect your modern

00:02:28,200 --> 00:02:34,230
applications in such a way that there

00:02:31,500 --> 00:02:39,510
can be a stateful component to your tier

00:02:34,230 --> 00:02:42,230
architecture okay so I have to talk a

00:02:39,510 --> 00:02:45,569
little bit about the company I work for

00:02:42,230 --> 00:02:49,110
so I promise you but just two slides and

00:02:45,569 --> 00:02:54,569
so basically we like to call ourselves

00:02:49,110 --> 00:02:57,870
on carrier we were based out of Bellevue

00:02:54,569 --> 00:03:01,140
and they've been changing the industry

00:02:57,870 --> 00:03:05,250
since 2013 with innovative products and

00:03:01,140 --> 00:03:07,190
services plus how the way we the way you

00:03:05,250 --> 00:03:10,709
know consumers and businesses by

00:03:07,190 --> 00:03:13,260
wireless products and services we've

00:03:10,709 --> 00:03:15,629
been changing that you know for a while

00:03:13,260 --> 00:03:17,370
now using using innovative products and

00:03:15,629 --> 00:03:19,440
solutions we're a publicly traded

00:03:17,370 --> 00:03:22,470
company with two flagship brands

00:03:19,440 --> 00:03:25,769
t-mobile and metro pcs and we're based

00:03:22,470 --> 00:03:28,019
out of Bellevue Washington where it's

00:03:25,769 --> 00:03:29,420
pretty much sunny all the time I think

00:03:28,019 --> 00:03:34,049
we all know that right

00:03:29,420 --> 00:03:36,510
no I'm just kidding so it's not bad

00:03:34,049 --> 00:03:38,970
summer it's awesome I love I mean it's

00:03:36,510 --> 00:03:42,780
Seattle's just like any other place in

00:03:38,970 --> 00:03:45,389
terms of weather okay I get super

00:03:42,780 --> 00:03:48,989
excited about this slide and I'll tell

00:03:45,389 --> 00:03:52,319
you why so we have our genius marketing

00:03:48,989 --> 00:03:54,720
team I think I think so they what they

00:03:52,319 --> 00:03:57,989
do is they they listen to customers

00:03:54,720 --> 00:03:59,639
problems and they understand the pain

00:03:57,989 --> 00:04:02,549
points and then they come up with these

00:03:59,639 --> 00:04:06,419
really innovative programs what we like

00:04:02,549 --> 00:04:10,530
to call uncarrier moves and we've been

00:04:06,419 --> 00:04:13,319
doing this since 2013 and our job our

00:04:10,530 --> 00:04:16,530
primary job as a on the technology side

00:04:13,319 --> 00:04:19,139
is to make these uncarrier moves come to

00:04:16,530 --> 00:04:25,349
life using innovative products and

00:04:19,139 --> 00:04:26,070
technology right so the way we like to

00:04:25,349 --> 00:04:27,270
connect with

00:04:26,070 --> 00:04:30,360
customers there are multiple ways

00:04:27,270 --> 00:04:32,190
customers connect with us they use the

00:04:30,360 --> 00:04:36,260
first two are called the what we call

00:04:32,190 --> 00:04:39,510
assisted channels customers can go to a

00:04:36,260 --> 00:04:42,870
store and they can you know for things

00:04:39,510 --> 00:04:45,510
like buying a product or accessory they

00:04:42,870 --> 00:04:48,590
can call our our awesome customer care

00:04:45,510 --> 00:04:52,050
team so and get answers to questions

00:04:48,590 --> 00:04:54,810
related to their account bill or any new

00:04:52,050 --> 00:04:59,790
products that they want to buy they can

00:04:54,810 --> 00:05:01,290
also use a website if you like to do

00:04:59,790 --> 00:05:02,910
self-service kind of thing where you

00:05:01,290 --> 00:05:05,640
don't really need somebody helping you

00:05:02,910 --> 00:05:07,440
out you can use the website and then as

00:05:05,640 --> 00:05:10,850
well as the the mobile app that you can

00:05:07,440 --> 00:05:13,650
install on any device of your choice

00:05:10,850 --> 00:05:16,710
we're also pretty active in the in the

00:05:13,650 --> 00:05:18,960
social media I don't know some of you

00:05:16,710 --> 00:05:20,730
might already follow John Ledyard who's

00:05:18,960 --> 00:05:22,860
our CEO he's pretty active he tweets a

00:05:20,730 --> 00:05:24,960
lot and you can ask questions and so we

00:05:22,860 --> 00:05:26,610
we stayed real connected with our

00:05:24,960 --> 00:05:29,700
customers through you know various

00:05:26,610 --> 00:05:36,900
channels we've won numerous awards for

00:05:29,700 --> 00:05:39,930
customer satisfaction okay moving on so

00:05:36,900 --> 00:05:44,130
real quick you know even though we live

00:05:39,930 --> 00:05:47,190
in a cloud first mobile first world web

00:05:44,130 --> 00:05:51,060
applications are still relevant meaning

00:05:47,190 --> 00:05:54,450
enterprises have not really jumped on to

00:05:51,060 --> 00:05:56,460
that mobile bandwagon right so there's

00:05:54,450 --> 00:05:59,220
still a lot of legacy applications that

00:05:56,460 --> 00:06:02,670
are web-based but you want to kind of

00:05:59,220 --> 00:06:04,530
transform them the second thing that I

00:06:02,670 --> 00:06:06,270
want to kind of mention here is so

00:06:04,530 --> 00:06:09,330
considering that you have the web

00:06:06,270 --> 00:06:12,300
applications sometimes it just makes no

00:06:09,330 --> 00:06:14,130
sense to invest in kind of transform you

00:06:12,300 --> 00:06:17,250
know rewriting them in mobile

00:06:14,130 --> 00:06:19,260
applications so you still have those so

00:06:17,250 --> 00:06:21,210
with web applications you have as we

00:06:19,260 --> 00:06:23,640
talked earlier you have this problem of

00:06:21,210 --> 00:06:25,350
you know state right so web is

00:06:23,640 --> 00:06:28,460
essentially stateless we all know that

00:06:25,350 --> 00:06:31,430
and typically what the way it works is

00:06:28,460 --> 00:06:34,980
you when you first log in to a website

00:06:31,430 --> 00:06:37,919
you a session is established on the

00:06:34,980 --> 00:06:39,340
server and then server then sends an ID

00:06:37,919 --> 00:06:42,250
you know session I

00:06:39,340 --> 00:06:45,130
the down to the client using a cookie

00:06:42,250 --> 00:06:47,080
and that browser will then subsequent

00:06:45,130 --> 00:06:49,900
requests for various pages browser will

00:06:47,080 --> 00:06:51,610
then pass that section ID on to the

00:06:49,900 --> 00:06:54,220
server and server is able to kind of

00:06:51,610 --> 00:06:56,380
bind to that to that user session right

00:06:54,220 --> 00:06:58,930
that's typically how it works this is

00:06:56,380 --> 00:07:01,650
all good when you think about

00:06:58,930 --> 00:07:04,900
traditional web applications right where

00:07:01,650 --> 00:07:07,360
the number of instances that are serving

00:07:04,900 --> 00:07:09,250
your web site is pretty static right in

00:07:07,360 --> 00:07:15,280
the past you know they don't really

00:07:09,250 --> 00:07:17,320
change a lot now when it's not okay is

00:07:15,280 --> 00:07:20,380
in the cloud native architecture right

00:07:17,320 --> 00:07:23,800
where you have you and your instances

00:07:20,380 --> 00:07:26,260
can go up and down if you know during a

00:07:23,800 --> 00:07:30,150
busy time you might scale it so you can

00:07:26,260 --> 00:07:34,060
you know meet the demands of your need

00:07:30,150 --> 00:07:35,890
so so the problem with that is with that

00:07:34,060 --> 00:07:39,250
you have this problem of how do you make

00:07:35,890 --> 00:07:41,590
sure the the session state data is

00:07:39,250 --> 00:07:45,280
actually it consistent across all your

00:07:41,590 --> 00:07:46,870
instances right in the traditional world

00:07:45,280 --> 00:07:48,880
if you think about how we've achieved

00:07:46,870 --> 00:07:52,090
this in a production like architecture

00:07:48,880 --> 00:07:54,360
is you use a line load balancer sticky

00:07:52,090 --> 00:07:56,830
session so if I hit one server

00:07:54,360 --> 00:07:59,920
subsequent requests go back to the same

00:07:56,830 --> 00:08:01,360
server right so that was okay back then

00:07:59,920 --> 00:08:03,460
but in the in the cloud native world

00:08:01,360 --> 00:08:06,640
your request could go to any instances

00:08:03,460 --> 00:08:08,320
especially if your experiences you know

00:08:06,640 --> 00:08:10,690
web experience is running in a container

00:08:08,320 --> 00:08:14,350
you could have multiple instances and

00:08:10,690 --> 00:08:16,660
you so you can't afford to you know have

00:08:14,350 --> 00:08:18,580
all that like use sticky sessions or

00:08:16,660 --> 00:08:21,130
have all the all the session data cannot

00:08:18,580 --> 00:08:24,070
be persisted in that in that instance

00:08:21,130 --> 00:08:27,400
where you're always hitting the second

00:08:24,070 --> 00:08:30,330
point here is it also doesn't confirm

00:08:27,400 --> 00:08:33,760
the the tool factor app methodology

00:08:30,330 --> 00:08:35,830
specifically number six which states no

00:08:33,760 --> 00:08:37,600
process you know your tow factor

00:08:35,830 --> 00:08:40,930
processes are stateless and they share

00:08:37,600 --> 00:08:43,570
nothing if they need to share the data

00:08:40,930 --> 00:08:47,740
you have to persist it into an external

00:08:43,570 --> 00:08:50,820
backing store it can be any any database

00:08:47,740 --> 00:08:50,820
or it typically a database

00:08:51,850 --> 00:08:57,079
so in what this slide is showing you is

00:08:54,980 --> 00:08:59,839
potentially what what are some of the

00:08:57,079 --> 00:09:02,629
solutions right so you have so we chose

00:08:59,839 --> 00:09:05,989
for one of the applications we worked on

00:09:02,629 --> 00:09:08,779
we chose to use Redis as that backing

00:09:05,989 --> 00:09:12,739
store so let me kind of walk you through

00:09:08,779 --> 00:09:14,230
the architecture here from the top so we

00:09:12,739 --> 00:09:17,749
have on the top of the layer we have

00:09:14,230 --> 00:09:20,029
users hitting the load balancer and from

00:09:17,749 --> 00:09:23,420
load balancer you your request comes to

00:09:20,029 --> 00:09:27,049
a gateway layer and a gateway routes the

00:09:23,420 --> 00:09:30,319
requests based on if it's you know you

00:09:27,049 --> 00:09:34,339
request going to your web experience it

00:09:30,319 --> 00:09:36,949
routes to what we call micro apps and we

00:09:34,339 --> 00:09:39,860
have you can deploy these things in a

00:09:36,949 --> 00:09:41,869
container if you choose to you can also

00:09:39,860 --> 00:09:45,019
you know if you're using building your

00:09:41,869 --> 00:09:47,629
web experience using angular you can put

00:09:45,019 --> 00:09:51,889
your angular assets in s3 buckets three

00:09:47,629 --> 00:09:53,929
bucket assuming you're using AWS and

00:09:51,889 --> 00:09:56,269
then you can have CloudFront that

00:09:53,929 --> 00:09:58,489
actually sir serves those static assets

00:09:56,269 --> 00:10:01,610
right so they're simply in this case if

00:09:58,489 --> 00:10:04,519
it's a call to like a request going to a

00:10:01,610 --> 00:10:07,819
UI asset it will just simply you know

00:10:04,519 --> 00:10:11,600
route your CloudFront URL and if it's

00:10:07,819 --> 00:10:13,459
called going to what we call BFF so no

00:10:11,600 --> 00:10:15,889
that's not best friends forever although

00:10:13,459 --> 00:10:17,600
i like to think it's really best friends

00:10:15,889 --> 00:10:20,959
forever with the UI right because

00:10:17,600 --> 00:10:23,209
essentially that's what we call back-end

00:10:20,959 --> 00:10:25,249
for front-end it's the law you know your

00:10:23,209 --> 00:10:27,379
your so you have a set of services

00:10:25,249 --> 00:10:30,230
underneath micro services underneath

00:10:27,379 --> 00:10:32,899
that provides various capabilities but

00:10:30,230 --> 00:10:35,959
at the same time what we what we want is

00:10:32,899 --> 00:10:38,389
something to orchestrate because

00:10:35,959 --> 00:10:40,369
typically you know if you look at any X

00:10:38,389 --> 00:10:43,639
you know action transactions that the

00:10:40,369 --> 00:10:46,549
user typical user would do it involves

00:10:43,639 --> 00:10:50,809
orchestrating multiple services right so

00:10:46,549 --> 00:10:53,269
and and the other scenario is you may

00:10:50,809 --> 00:10:56,919
you may need to kind of format the data

00:10:53,269 --> 00:11:00,380
in a specific manner for your experience

00:10:56,919 --> 00:11:02,750
so in those cases you can use

00:11:00,380 --> 00:11:04,850
a back-end for front-end kind of model

00:11:02,750 --> 00:11:07,700
where you have it is like an eight a

00:11:04,850 --> 00:11:09,590
REST API sorry so you your request go

00:11:07,700 --> 00:11:12,170
through the Gateway you hit the backend

00:11:09,590 --> 00:11:14,720
back in for front-end layer and that

00:11:12,170 --> 00:11:16,520
because that's also stateful now that's

00:11:14,720 --> 00:11:20,960
the other key point here is it's using

00:11:16,520 --> 00:11:24,560
brightest to to get to the session state

00:11:20,960 --> 00:11:26,690
that you know for that particular user

00:11:24,560 --> 00:11:29,390
session the other thing I should point

00:11:26,690 --> 00:11:31,580
out here is we move the the security and

00:11:29,390 --> 00:11:34,040
authentication pieces down into the

00:11:31,580 --> 00:11:35,600
Gateway layer so if you when your

00:11:34,040 --> 00:11:38,350
request comes to Gateway if it's

00:11:35,600 --> 00:11:41,060
accessing an authenticated resource

00:11:38,350 --> 00:11:43,570
you're going to Gateway is going to you

00:11:41,060 --> 00:11:46,250
know force you to go do the log in and

00:11:43,570 --> 00:11:49,640
then you once you log in your session is

00:11:46,250 --> 00:11:52,850
established and and then the requests

00:11:49,640 --> 00:11:55,010
flows into you know potentially if it's

00:11:52,850 --> 00:11:57,080
an API call happening to your back-end

00:11:55,010 --> 00:11:58,610
for front-end layer it will hit the

00:11:57,080 --> 00:12:01,190
backend for friend and layer and in that

00:11:58,610 --> 00:12:05,210
case also it will bind to that same

00:12:01,190 --> 00:12:07,970
session and so it can then in that layer

00:12:05,210 --> 00:12:10,160
you can then get access to all of all of

00:12:07,970 --> 00:12:13,190
those you know state information that's

00:12:10,160 --> 00:12:15,440
already a part of that that that session

00:12:13,190 --> 00:12:18,470
a couple of other things I should point

00:12:15,440 --> 00:12:20,630
out you know we do sometimes we do

00:12:18,470 --> 00:12:22,400
things like we have a lot of you know

00:12:20,630 --> 00:12:24,770
obviously you know big enterprise there

00:12:22,400 --> 00:12:27,230
are legacy components that you can't

00:12:24,770 --> 00:12:29,510
just you know one day swap it out right

00:12:27,230 --> 00:12:33,770
it takes some time to actually transform

00:12:29,510 --> 00:12:36,470
the entire architecture so we still have

00:12:33,770 --> 00:12:40,280
like an you know need to call legacy

00:12:36,470 --> 00:12:42,410
components so we do things like what as

00:12:40,280 --> 00:12:43,550
soon as the the session like login

00:12:42,410 --> 00:12:45,890
process is over

00:12:43,550 --> 00:12:47,840
we kind of call some acing

00:12:45,890 --> 00:12:51,170
asynchronously make some calls to

00:12:47,840 --> 00:12:53,930
actually load pre-warm the the data I

00:12:51,170 --> 00:12:56,120
mean the cache with some additional

00:12:53,930 --> 00:12:59,260
information that that is using that

00:12:56,120 --> 00:13:01,130
users might need right because based on

00:12:59,260 --> 00:13:03,710
typically you know when you think about

00:13:01,130 --> 00:13:06,110
our use cases users will you know you

00:13:03,710 --> 00:13:08,270
login you might you'll go to your usage

00:13:06,110 --> 00:13:11,300
you know information you view that

00:13:08,270 --> 00:13:13,660
information so we can do things like

00:13:11,300 --> 00:13:16,570
this architecture we can do things like

00:13:13,660 --> 00:13:21,450
warming the the session with data that's

00:13:16,570 --> 00:13:24,660
needed for that particular session right

00:13:21,450 --> 00:13:27,880
and then down in the bottom you can see

00:13:24,660 --> 00:13:30,640
you can see all the microservices layer

00:13:27,880 --> 00:13:33,220
so it's really behind gateway and then

00:13:30,640 --> 00:13:36,760
back in for front-end which is for that

00:13:33,220 --> 00:13:38,710
experience and then down below is the

00:13:36,760 --> 00:13:40,920
backend for front-end and discovers all

00:13:38,710 --> 00:13:48,880
the services it needs to orchestrate

00:13:40,920 --> 00:13:50,800
using a service discovery moving on so

00:13:48,880 --> 00:13:52,720
the other the other thing I should talk

00:13:50,800 --> 00:13:54,880
about you know so I mentioned the way we

00:13:52,720 --> 00:13:57,010
solve the the session problem is using

00:13:54,880 --> 00:13:58,810
you know one was we needed to

00:13:57,010 --> 00:14:00,970
externalize the session data so we use

00:13:58,810 --> 00:14:02,830
Redis for that the other thing I want to

00:14:00,970 --> 00:14:06,790
mention here is a project called spring

00:14:02,830 --> 00:14:09,820
session how many of you heard of are you

00:14:06,790 --> 00:14:13,470
guys using using this today just curious

00:14:09,820 --> 00:14:16,780
so what do you what do you do today to

00:14:13,470 --> 00:14:20,440
you know for for externalizing session

00:14:16,780 --> 00:14:22,090
state do you store and like in a product

00:14:20,440 --> 00:14:27,070
are you using like a load balancer

00:14:22,090 --> 00:14:29,080
sticky session kind of thing okay I

00:14:27,070 --> 00:14:31,810
think that's mostly most of the folks

00:14:29,080 --> 00:14:34,270
that's what that's what we've seen you

00:14:31,810 --> 00:14:36,340
know you you you you know traditionally

00:14:34,270 --> 00:14:38,020
you use you know load balancer and

00:14:36,340 --> 00:14:40,950
sticky sessions so that it all the

00:14:38,020 --> 00:14:43,750
requests go to the same same instance

00:14:40,950 --> 00:14:45,700
but anyway so spring session is

00:14:43,750 --> 00:14:50,520
basically again spring does a great job

00:14:45,700 --> 00:14:52,840
of abstracting and keeping things very

00:14:50,520 --> 00:14:56,800
simple for developers to actually

00:14:52,840 --> 00:14:58,750
implement so sprin spring session is one

00:14:56,800 --> 00:15:02,050
of those projects which allows us to

00:14:58,750 --> 00:15:04,870
kind of externalize the session date you

00:15:02,050 --> 00:15:06,580
know session data into a some kind of

00:15:04,870 --> 00:15:09,820
backing data store and we don't have to

00:15:06,580 --> 00:15:11,890
worry about where that data is going

00:15:09,820 --> 00:15:14,170
because meaning you know it's it's

00:15:11,890 --> 00:15:16,840
decoupled in the sense that I can swap

00:15:14,170 --> 00:15:18,370
out today I could go with Redis and

00:15:16,840 --> 00:15:22,240
tomorrow I can go with some other other

00:15:18,370 --> 00:15:23,800
solutions like or gem fire or

00:15:22,240 --> 00:15:26,470
hazel Cass

00:15:23,800 --> 00:15:27,400
so with with the spring session you by

00:15:26,470 --> 00:15:30,940
default you get

00:15:27,400 --> 00:15:35,110
implementations for Redis JDBC gem

00:15:30,940 --> 00:15:36,820
fire and hazel caste GBC is where if you

00:15:35,110 --> 00:15:39,430
if you want to use some relational

00:15:36,820 --> 00:15:42,700
database to persist your session

00:15:39,430 --> 00:15:45,880
information it allows us to use that so

00:15:42,700 --> 00:15:47,530
if any of these out-of-the-box solutions

00:15:45,880 --> 00:15:49,900
doesn't work for you for whatever reason

00:15:47,530 --> 00:15:52,420
you have a need to integrate with some

00:15:49,900 --> 00:15:54,610
other backing store you can roll your

00:15:52,420 --> 00:15:56,200
own implementation so the architecture

00:15:54,610 --> 00:15:59,170
is extensible in such a way that it's

00:15:56,200 --> 00:16:04,330
really easy to build something custom of

00:15:59,170 --> 00:16:06,640
your own also it supports clustered

00:16:04,330 --> 00:16:09,300
sessions without being tied to a

00:16:06,640 --> 00:16:12,670
application container specific solution

00:16:09,300 --> 00:16:15,150
again we know like in the Java world you

00:16:12,670 --> 00:16:18,400
know you got servlet with that you get

00:16:15,150 --> 00:16:20,500
basically a you know we talked about

00:16:18,400 --> 00:16:23,140
this earlier where you know your session

00:16:20,500 --> 00:16:25,450
is established and then the bra you know

00:16:23,140 --> 00:16:27,760
the session ID send we our cookie right

00:16:25,450 --> 00:16:29,950
so with with the spring session you can

00:16:27,760 --> 00:16:32,380
you know again the problem with that is

00:16:29,950 --> 00:16:34,900
you know you have to kind of stick to

00:16:32,380 --> 00:16:36,850
the load balancer sticky sessions this

00:16:34,900 --> 00:16:39,550
allows us to have clustered sessions

00:16:36,850 --> 00:16:41,500
without actually being using anything

00:16:39,550 --> 00:16:44,140
like load balancer sticky sessions or

00:16:41,500 --> 00:16:48,790
even you know being tied to a container

00:16:44,140 --> 00:16:50,740
specific solution such as Tomcat the

00:16:48,790 --> 00:16:54,670
other the other thing to you know kind

00:16:50,740 --> 00:16:57,190
of call out here is you can also use

00:16:54,670 --> 00:17:00,610
session IDs can be exchanged via HTTP

00:16:57,190 --> 00:17:02,410
headers you know you saw in that are the

00:17:00,610 --> 00:17:05,080
the architecture slide that we looked

00:17:02,410 --> 00:17:07,320
earlier right we have API calls going to

00:17:05,080 --> 00:17:10,240
the backend back-end for front-end layer

00:17:07,320 --> 00:17:11,980
so we can actually now that you can

00:17:10,240 --> 00:17:15,280
actually pass when they when it's

00:17:11,980 --> 00:17:17,830
calling the the BFF layer it can it can

00:17:15,280 --> 00:17:21,130
pass the session ID as a you know we are

00:17:17,830 --> 00:17:22,870
the header and then the last thing here

00:17:21,130 --> 00:17:25,510
is the WebSocket support so if you're

00:17:22,870 --> 00:17:27,310
using WebSockets for like you know

00:17:25,510 --> 00:17:28,990
real-time communication from server to

00:17:27,310 --> 00:17:30,880
client

00:17:28,990 --> 00:17:34,950
spring session actually works really

00:17:30,880 --> 00:17:34,950
nicely with WebSocket

00:17:36,620 --> 00:17:42,679
so quick who's using register dated

00:17:39,950 --> 00:17:46,580
anyone using Redis so mostly for cash

00:17:42,679 --> 00:17:51,230
I'm guessing like caching things okay so

00:17:46,580 --> 00:17:53,990
just a quick overview of Redis basically

00:17:51,230 --> 00:17:55,159
Redis is a as we as we may already know

00:17:53,990 --> 00:17:58,460
it's an in-memory

00:17:55,159 --> 00:18:00,260
key value database because it's memory

00:17:58,460 --> 00:18:03,620
it provides us fast access to the data

00:18:00,260 --> 00:18:05,330
which is really nice you can also I

00:18:03,620 --> 00:18:07,520
don't know how many people know Redis

00:18:05,330 --> 00:18:09,350
can actually be used to persist data

00:18:07,520 --> 00:18:12,919
into the disk so it's almost like a

00:18:09,350 --> 00:18:14,750
database it does the persistence in an

00:18:12,919 --> 00:18:16,669
asynchronous manner so there's always a

00:18:14,750 --> 00:18:19,820
chance of some data being lost in

00:18:16,669 --> 00:18:23,840
failures and disaster recovery type of

00:18:19,820 --> 00:18:26,480
scenarios it's written in C and it's

00:18:23,840 --> 00:18:30,230
recommended to deploy brightest and on

00:18:26,480 --> 00:18:33,380
Linux there are from a from a developer

00:18:30,230 --> 00:18:34,520
standpoint you know we the reality is we

00:18:33,380 --> 00:18:36,890
build applications in different

00:18:34,520 --> 00:18:40,250
platforms right Java some people build

00:18:36,890 --> 00:18:41,480
applications in Java some dotnet so

00:18:40,250 --> 00:18:43,220
there are a variety of client

00:18:41,480 --> 00:18:46,250
implementations for various programming

00:18:43,220 --> 00:18:48,080
languages that's available so it's

00:18:46,250 --> 00:18:50,419
really easy to the point is it's really

00:18:48,080 --> 00:18:53,510
easy to integrate in Redis in you know

00:18:50,419 --> 00:18:55,880
into your application and then last bit

00:18:53,510 --> 00:18:58,730
here is you can there are two ways you

00:18:55,880 --> 00:19:01,130
can deploy Redis one is in a

00:18:58,730 --> 00:19:03,320
master/slave mode where you have a

00:19:01,130 --> 00:19:06,320
single master that's taking all the the

00:19:03,320 --> 00:19:09,500
requests for you know query for data and

00:19:06,320 --> 00:19:11,750
then and then you have maybe one or more

00:19:09,500 --> 00:19:13,370
slaves that so in case master goes down

00:19:11,750 --> 00:19:15,380
you know one of you know one of the

00:19:13,370 --> 00:19:18,200
slave can be promoted to a master from a

00:19:15,380 --> 00:19:20,870
a che standpoint and then you have the

00:19:18,200 --> 00:19:23,990
the cluster mode which which is

00:19:20,870 --> 00:19:25,460
primarily used to scale where you do you

00:19:23,990 --> 00:19:28,399
know basically shard the data across

00:19:25,460 --> 00:19:32,120
multiple master nodes for to achieve

00:19:28,399 --> 00:19:34,669
scalability and high availability so the

00:19:32,120 --> 00:19:36,200
charts down what they're what that's

00:19:34,669 --> 00:19:39,620
showing I'm not sure if it's really

00:19:36,200 --> 00:19:42,890
clear or not don't think so so the the

00:19:39,620 --> 00:19:46,520
key thing to call out here is this is

00:19:42,890 --> 00:19:49,020
again from one of the one of the

00:19:46,520 --> 00:19:52,350
articles published by Redis labs

00:19:49,020 --> 00:19:55,350
they did a survey the the first one the

00:19:52,350 --> 00:19:57,660
one on the my right which is showing the

00:19:55,350 --> 00:20:00,000
use cases of using Redis and specific

00:19:57,660 --> 00:20:01,890
one to kind of call out is that the

00:20:00,000 --> 00:20:04,110
second one from the from the from the

00:20:01,890 --> 00:20:06,690
other end that's basically session

00:20:04,110 --> 00:20:08,130
management so people you can see from

00:20:06,690 --> 00:20:10,860
the chart that people are really using

00:20:08,130 --> 00:20:14,130
it for session management and then the

00:20:10,860 --> 00:20:15,740
the one on on my left is is basically

00:20:14,130 --> 00:20:18,900
you know kind of the use cases

00:20:15,740 --> 00:20:20,820
industries and in and that are using

00:20:18,900 --> 00:20:22,380
Redis sir so there's a variety of

00:20:20,820 --> 00:20:24,690
industries that are already using it so

00:20:22,380 --> 00:20:27,930
look again the key point is it's a

00:20:24,690 --> 00:20:30,540
proven solution used for very there are

00:20:27,930 --> 00:20:37,230
various use cases it supports and then a

00:20:30,540 --> 00:20:39,660
lot of people are using it so okay next

00:20:37,230 --> 00:20:42,330
i want to talk about some of the

00:20:39,660 --> 00:20:46,650
deployment options so there are

00:20:42,330 --> 00:20:47,910
basically obviously there are more but i

00:20:46,650 --> 00:20:51,120
want to kind of focus on the three

00:20:47,910 --> 00:20:52,320
things so you can deploy right ass on

00:20:51,120 --> 00:20:55,530
your own i mean use the open source

00:20:52,320 --> 00:20:57,680
version and spin up of you know the

00:20:55,530 --> 00:21:00,810
infrastructure that's required and

00:20:57,680 --> 00:21:05,520
install Redis and then you can run and

00:21:00,810 --> 00:21:09,240
operate and manage yourself and then the

00:21:05,520 --> 00:21:12,300
other option is you can amazon has a

00:21:09,240 --> 00:21:15,930
service called ElastiCache it lets you

00:21:12,300 --> 00:21:19,260
run Redis or memcache D depending on

00:21:15,930 --> 00:21:21,600
your choice and and it's a fully managed

00:21:19,260 --> 00:21:23,940
service that you don't now you don't

00:21:21,600 --> 00:21:27,120
have to be responsible for installing

00:21:23,940 --> 00:21:28,710
configuring and even supporting it right

00:21:27,120 --> 00:21:31,290
so you get you know management

00:21:28,710 --> 00:21:33,510
monitoring aspects of it but one thing

00:21:31,290 --> 00:21:35,930
I'm not gonna go to detail into it there

00:21:33,510 --> 00:21:38,430
are various options to for deployment

00:21:35,930 --> 00:21:43,830
but one thing I want to kind of call out

00:21:38,430 --> 00:21:45,030
is I did some cost analysis and there

00:21:43,830 --> 00:21:48,240
isn't but you know if you look at the

00:21:45,030 --> 00:21:50,390
the cost for a cash node in in AWS

00:21:48,240 --> 00:21:54,810
there's about thirty five percent

00:21:50,390 --> 00:21:56,700
increase compared to an ec2 instance so

00:21:54,810 --> 00:21:59,460
if you were to buy you know get a spin

00:21:56,700 --> 00:22:01,410
up an ec2 instance and then do install

00:21:59,460 --> 00:22:02,340
Redis on your own you know the cost that

00:22:01,410 --> 00:22:04,799
you would pay for that

00:22:02,340 --> 00:22:08,059
versus cost for a cash no there's like a

00:22:04,799 --> 00:22:10,169
35% increase sometimes that may be a

00:22:08,059 --> 00:22:13,980
blocker for you right because depending

00:22:10,169 --> 00:22:16,440
on the costs constraints but again the

00:22:13,980 --> 00:22:18,690
caught that cost you're paying for you

00:22:16,440 --> 00:22:20,250
know being able to not have to worry

00:22:18,690 --> 00:22:23,100
about the management and monitoring

00:22:20,250 --> 00:22:26,760
aspects of it again

00:22:23,100 --> 00:22:28,679
a juror also has the service that allows

00:22:26,760 --> 00:22:31,260
you to it's basically a fully managed

00:22:28,679 --> 00:22:34,080
service that allows you to spin up Redis

00:22:31,260 --> 00:22:36,870
clusters and there are basically three

00:22:34,080 --> 00:22:41,640
different types of deployment options in

00:22:36,870 --> 00:22:45,779
Azure one is a basic which which is

00:22:41,640 --> 00:22:48,059
basically a single node and you don't

00:22:45,779 --> 00:22:50,130
you don't really have any H a or you

00:22:48,059 --> 00:22:53,940
know SLA is around that so if that node

00:22:50,130 --> 00:22:56,460
goes down you know you you're basically

00:22:53,940 --> 00:22:59,640
down your applications down typically

00:22:56,460 --> 00:23:02,490
not recommended to you know use it in

00:22:59,640 --> 00:23:05,549
production like you know synthesis

00:23:02,490 --> 00:23:10,020
situations there's also the standard and

00:23:05,549 --> 00:23:13,320
premier tier that gives you you know H a

00:23:10,020 --> 00:23:16,470
and n SLA is around when when you know

00:23:13,320 --> 00:23:21,000
the masters down or you need to failover

00:23:16,470 --> 00:23:21,779
to a secondary cluster you also have

00:23:21,000 --> 00:23:24,029
read Aloud's

00:23:21,779 --> 00:23:28,020
again I I don't have a much of

00:23:24,029 --> 00:23:30,330
experience but it essentially brightest

00:23:28,020 --> 00:23:32,610
can actually you can have ready slabs

00:23:30,330 --> 00:23:35,760
kind of spin up your Redis cluster in

00:23:32,610 --> 00:23:37,890
the cloud provider of your choice I

00:23:35,760 --> 00:23:40,080
think one of the key things to kind of

00:23:37,890 --> 00:23:42,899
keep in mind is because red is kind of

00:23:40,080 --> 00:23:45,899
created you know they created the the

00:23:42,899 --> 00:23:47,340
Redis so it might be a good thing for

00:23:45,899 --> 00:23:49,529
people that they know better than

00:23:47,340 --> 00:23:52,289
probably any way any one of us right in

00:23:49,529 --> 00:23:55,799
terms of you know the best way to to

00:23:52,289 --> 00:23:57,630
knit provision to tune and manage it

00:23:55,799 --> 00:24:01,679
right so there may be an option that

00:23:57,630 --> 00:24:05,370
that it's worth considering we chose to

00:24:01,679 --> 00:24:08,640
run on on our own we have some teams

00:24:05,370 --> 00:24:11,039
that that in some some use cases we have

00:24:08,640 --> 00:24:13,830
we use our own Redis cluster and then

00:24:11,039 --> 00:24:15,480
there are certain other teams that use a

00:24:13,830 --> 00:24:15,960
managed service because again they're

00:24:15,480 --> 00:24:20,009
the mature

00:24:15,960 --> 00:24:21,779
level of that beam is not as high where

00:24:20,009 --> 00:24:24,539
you where you need it to be to be able

00:24:21,779 --> 00:24:28,320
to kind of manage the infrastructure and

00:24:24,539 --> 00:24:30,059
monitor and all aspects of that so so

00:24:28,320 --> 00:24:31,830
again you know depending on you know

00:24:30,059 --> 00:24:34,019
where you are with the maturity level

00:24:31,830 --> 00:24:40,679
you might choose to run on your own

00:24:34,019 --> 00:24:42,809
versus use a fully managed service okay

00:24:40,679 --> 00:24:46,139
next up I want to kind of talk about a

00:24:42,809 --> 00:24:49,379
couple of so you know how do you monitor

00:24:46,139 --> 00:24:52,200
monitor Redis so let me just kind of

00:24:49,379 --> 00:24:54,840
quickly go through it so basically this

00:24:52,200 --> 00:24:57,389
is what's shown here is a you know

00:24:54,840 --> 00:25:01,499
system basic system metrics that you

00:24:57,389 --> 00:25:03,600
should be monitoring you know the one of

00:25:01,499 --> 00:25:06,659
the key thing is the over here is the

00:25:03,600 --> 00:25:08,490
memory usage again it depends on how

00:25:06,659 --> 00:25:10,860
many keys you have in the database and

00:25:08,490 --> 00:25:14,249
and you also need to factor in the the

00:25:10,860 --> 00:25:17,309
memory that your OS needs also you

00:25:14,249 --> 00:25:20,639
should monitor the disk usage you know

00:25:17,309 --> 00:25:24,480
because if you're using persistence it's

00:25:20,639 --> 00:25:26,909
a good thing to have and then I'm gonna

00:25:24,480 --> 00:25:28,889
I'm you can use this as a reference so

00:25:26,909 --> 00:25:32,009
there are like you know guidelines on

00:25:28,889 --> 00:25:34,549
what what that does and then Wendy when

00:25:32,009 --> 00:25:37,369
you know when when should you use

00:25:34,549 --> 00:25:40,559
alerting you know things of that nature

00:25:37,369 --> 00:25:42,299
and then neck the next one what this

00:25:40,559 --> 00:25:44,659
table what it's showing is the some

00:25:42,299 --> 00:25:47,039
availability related metrics

00:25:44,659 --> 00:25:48,659
specifically the one to call out here is

00:25:47,039 --> 00:25:50,429
the connected client so this is the

00:25:48,659 --> 00:25:53,399
number of you know if you want to see

00:25:50,429 --> 00:25:55,679
the active sessions the connected

00:25:53,399 --> 00:25:57,960
clients is something that that you can

00:25:55,679 --> 00:26:00,269
you can look to see how many users are

00:25:57,960 --> 00:26:03,269
logged into the database I'm into your

00:26:00,269 --> 00:26:06,330
application the some of the other things

00:26:03,269 --> 00:26:08,850
to kind of call out is the this you know

00:26:06,330 --> 00:26:11,549
our DB changes last save that's

00:26:08,850 --> 00:26:13,350
basically you know the amount the number

00:26:11,549 --> 00:26:16,080
of changes that are pending since the

00:26:13,350 --> 00:26:18,450
the server persisted last time you know

00:26:16,080 --> 00:26:20,149
again if that timeline is pretty high

00:26:18,450 --> 00:26:22,950
it's a good indication that something's

00:26:20,149 --> 00:26:28,100
failing in terms of being persisting to

00:26:22,950 --> 00:26:28,100
the to the database to the storage

00:26:28,600 --> 00:26:32,170
I'm going to quickly skip through this

00:26:30,310 --> 00:26:35,200
again you guys can look at this for

00:26:32,170 --> 00:26:38,020
reference let's quickly talk about some

00:26:35,200 --> 00:26:41,400
of the monitoring tools so you have

00:26:38,020 --> 00:26:45,120
ready CLI CLI has two commands info and

00:26:41,400 --> 00:26:47,890
monitor info kind of you can get a

00:26:45,120 --> 00:26:51,370
general information about the server and

00:26:47,890 --> 00:26:54,670
then client connections it also gives

00:26:51,370 --> 00:26:57,430
you memory usage information you can

00:26:54,670 --> 00:27:01,090
also you know view things related to

00:26:57,430 --> 00:27:04,840
persistence and then CPU usage

00:27:01,090 --> 00:27:07,570
statistics and then the one other thing

00:27:04,840 --> 00:27:10,840
to call out is info command doesn't have

00:27:07,570 --> 00:27:12,940
much of an impact on the performance

00:27:10,840 --> 00:27:15,070
overall performance the monitor on the

00:27:12,940 --> 00:27:17,260
other hand has has impact on the

00:27:15,070 --> 00:27:18,730
performance in some cases typically

00:27:17,260 --> 00:27:23,200
you'll use monitor if you want to

00:27:18,730 --> 00:27:24,820
troubleshoot an issue so but so just be

00:27:23,200 --> 00:27:28,840
aware that when you're using that you

00:27:24,820 --> 00:27:32,260
you there is an overhead so the other

00:27:28,840 --> 00:27:33,730
thing too shown here is ready stat so

00:27:32,260 --> 00:27:35,350
ready stat is actually a ruby

00:27:33,730 --> 00:27:37,360
application there's there's kind of

00:27:35,350 --> 00:27:39,430
web-based dashboard and then you can

00:27:37,360 --> 00:27:43,540
also view performance information in

00:27:39,430 --> 00:27:46,210
terminal using a vmstat like format what

00:27:43,540 --> 00:27:48,480
we again a lot I'm gonna have to quick

00:27:46,210 --> 00:27:50,680
you know I'm running out of time so the

00:27:48,480 --> 00:27:53,410
one thing that the call-out is we use

00:27:50,680 --> 00:27:55,270
Telegraph's so we're we use influx as a

00:27:53,410 --> 00:27:58,390
time series database to store all the

00:27:55,270 --> 00:27:59,920
metrics and drop honor to kind of you

00:27:58,390 --> 00:28:02,190
know visualize that metrics so we use

00:27:59,920 --> 00:28:05,230
Telegraph in our you know in our world

00:28:02,190 --> 00:28:08,140
but there are you know different options

00:28:05,230 --> 00:28:10,030
depending on you know how your what what

00:28:08,140 --> 00:28:12,070
tools and technologies are using for

00:28:10,030 --> 00:28:17,500
your monitoring stack you might choose

00:28:12,070 --> 00:28:20,730
one of these options limiting this I'm

00:28:17,500 --> 00:28:26,290
gonna quickly just jump into this slide

00:28:20,730 --> 00:28:27,580
so why use Redis for session store so

00:28:26,290 --> 00:28:29,640
number one here is you want to

00:28:27,580 --> 00:28:32,620
externalize data hopefully you've seen

00:28:29,640 --> 00:28:34,750
you know being it you know having

00:28:32,620 --> 00:28:36,970
the the Gateway set you know we move

00:28:34,750 --> 00:28:39,010
gateway all the authentication

00:28:36,970 --> 00:28:41,980
authorization aspects into the gateway

00:28:39,010 --> 00:28:43,779
and then you have multiple components in

00:28:41,980 --> 00:28:46,570
your application stack that actually

00:28:43,779 --> 00:28:47,919
depends on that session state right so

00:28:46,570 --> 00:28:50,620
it's kind of good from that perspective

00:28:47,919 --> 00:28:53,740
and then also you know in terms of being

00:28:50,620 --> 00:28:56,650
able to share session across multiple

00:28:53,740 --> 00:28:58,570
instances a couple of things to note is

00:28:56,650 --> 00:29:01,029
you can expire kill sessions if you see

00:28:58,570 --> 00:29:03,340
a robe you know the user session you can

00:29:01,029 --> 00:29:07,690
you can easily go into Redis and expire

00:29:03,340 --> 00:29:09,700
that key you can act you know identify

00:29:07,690 --> 00:29:11,649
active users in the system it works very

00:29:09,700 --> 00:29:13,390
well in a clustered environment and the

00:29:11,649 --> 00:29:16,240
last two things it scales well and

00:29:13,390 --> 00:29:17,850
performs really well again with

00:29:16,240 --> 00:29:20,950
clustering option you can scale

00:29:17,850 --> 00:29:23,770
partition your database across multiple

00:29:20,950 --> 00:29:25,899
nodes and achieve maximum scale and then

00:29:23,770 --> 00:29:29,919
because it's in memory you have a lot of

00:29:25,899 --> 00:29:33,730
performance gains just some real-world

00:29:29,919 --> 00:29:37,110
use cases you know we have an

00:29:33,730 --> 00:29:40,990
application called used in the metro pcs

00:29:37,110 --> 00:29:42,760
it's a retail retail channel what we

00:29:40,990 --> 00:29:46,750
call retail channel it's a web-based

00:29:42,760 --> 00:29:49,570
application used by stores and dealers

00:29:46,750 --> 00:29:51,760
and all the call centers some of the

00:29:49,570 --> 00:29:56,049
patterns that we use we built it for

00:29:51,760 --> 00:29:58,809
maximum reuse and then basically it uses

00:29:56,049 --> 00:30:02,230
leverages technics OSS stack as you've

00:29:58,809 --> 00:30:05,620
seen in earlier in the in the slides and

00:30:02,230 --> 00:30:10,539
then we also use the same strategy for a

00:30:05,620 --> 00:30:14,169
a.m. based application again to you know

00:30:10,539 --> 00:30:17,140
in terms of externalizing the the

00:30:14,169 --> 00:30:20,350
session slave data I think I'm about

00:30:17,140 --> 00:30:25,149
time if there's if there's any question

00:30:20,350 --> 00:30:29,320
my contact information is all the way in

00:30:25,149 --> 00:30:32,649
the end it's a lot to cover and one when

00:30:29,320 --> 00:30:35,380
you know 30 minute talk but oh just

00:30:32,649 --> 00:30:38,279
reach out to me in terms of if you have

00:30:35,380 --> 00:30:41,140
any questions also I I did have a demo

00:30:38,279 --> 00:30:43,100
but unfortunately as you see I couldn't

00:30:41,140 --> 00:30:47,090
even go through all the slides but

00:30:43,100 --> 00:30:51,289
I will point out the link to the github

00:30:47,090 --> 00:30:54,470
repo that has a sample application which

00:30:51,289 --> 00:30:56,059
basically can think the the the high

00:30:54,470 --> 00:30:58,070
level the architecture diagram that I

00:30:56,059 --> 00:30:59,660
showed right basically there's a sample

00:30:58,070 --> 00:31:02,419
application that actually models that

00:30:59,660 --> 00:31:04,429
entire architecture so you could I'll

00:31:02,419 --> 00:31:08,169
point you guys to that repo and then you

00:31:04,429 --> 00:31:08,169
guys can look at that as a reference

00:31:09,340 --> 00:31:12,340

YouTube URL: https://www.youtube.com/watch?v=jcrZllhKank


