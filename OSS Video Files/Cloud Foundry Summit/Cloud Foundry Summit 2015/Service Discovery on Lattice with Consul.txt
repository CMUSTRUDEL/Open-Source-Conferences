Title: Service Discovery on Lattice with Consul
Publication date: 2015-05-12
Playlist: Cloud Foundry Summit 2015
Description: 
	Service Discovery on Lattice with Consul - 06 Juan Pablo Genovese 720p
Captions: 
	00:00:01,100 --> 00:00:08,179
hello everybody how are you doing

00:00:04,049 --> 00:00:10,740
thank you for being here first of all

00:00:08,179 --> 00:00:13,889
this is obviously not the guy who's

00:00:10,740 --> 00:00:18,390
given the talk I did mutated because of

00:00:13,889 --> 00:00:21,539
extrange virus actually this guy should

00:00:18,390 --> 00:00:25,470
be here instead of me because he's the

00:00:21,539 --> 00:00:28,820
father of the creature that do it due to

00:00:25,470 --> 00:00:33,180
a small problem with a counselor that

00:00:28,820 --> 00:00:38,030
didn't granted the visa in time he

00:00:33,180 --> 00:00:41,550
couldn't be here so I am here talking so

00:00:38,030 --> 00:00:45,270
first of all keep in mind that Alexei

00:00:41,550 --> 00:00:49,140
who's a great guy an amazing developer

00:00:45,270 --> 00:00:53,190
and and also very smart guy should be

00:00:49,140 --> 00:00:57,390
here and not me and all credits to this

00:00:53,190 --> 00:01:00,030
guy so Who I am I am my name is Juan

00:00:57,390 --> 00:01:05,010
Pablo I have been working in the IT

00:01:00,030 --> 00:01:07,979
industry for 18 years I'm 36 years old I

00:01:05,010 --> 00:01:11,250
am a software engineer and currently I

00:01:07,979 --> 00:01:15,720
work as a field call foundry engineer at

00:01:11,250 --> 00:01:18,090
all todos I do love to dance tango and

00:01:15,720 --> 00:01:21,869
to play those guitars so if anyone wants

00:01:18,090 --> 00:01:26,250
to invite me to jam I'm happy to do it

00:01:21,869 --> 00:01:29,759
I work Adam Torres we offer a variety of

00:01:26,250 --> 00:01:31,710
software services mostly related right

00:01:29,759 --> 00:01:34,950
now to co-found really we are investing

00:01:31,710 --> 00:01:36,890
a lot in co-founder e we provide very

00:01:34,950 --> 00:01:41,189
much benchmarking for different

00:01:36,890 --> 00:01:43,979
companies we do software development we

00:01:41,189 --> 00:01:47,189
have a lot of big and not so big

00:01:43,979 --> 00:01:51,420
customers which we don't care everything

00:01:47,189 --> 00:01:54,630
everyone is speak for us we have offices

00:01:51,420 --> 00:01:56,549
all around the world and we are really

00:01:54,630 --> 00:02:00,689
really happy of being a Gold Sponsor

00:01:56,549 --> 00:02:06,240
here at CF summit this year

00:02:00,689 --> 00:02:11,149
so let's get to the important topics the

00:02:06,240 --> 00:02:11,149
real picture of this talk is about

00:02:11,150 --> 00:02:15,470
lattice and council have you

00:02:13,580 --> 00:02:20,780
how many of you have you been indeed

00:02:15,470 --> 00:02:23,900
talk in the a2 room were the guys

00:02:20,780 --> 00:02:27,110
talking about lattice were awesome nice

00:02:23,900 --> 00:02:29,900
so you are familiar with lattice for

00:02:27,110 --> 00:02:32,810
those who are not I'm going to make a

00:02:29,900 --> 00:02:35,960
very brief introduction to to lattice

00:02:32,810 --> 00:02:39,890
and then console which is the main topic

00:02:35,960 --> 00:02:43,490
of this talk we're going to be talking

00:02:39,890 --> 00:02:47,240
about service discovery issues and how

00:02:43,490 --> 00:02:51,830
to overcome them and how council works

00:02:47,240 --> 00:02:56,330
to overcome those problems and we also

00:02:51,830 --> 00:02:58,370
are going to see a very brief example on

00:02:56,330 --> 00:03:04,270
registering and my sequel service with

00:02:58,370 --> 00:03:10,030
council and how council reacts one when

00:03:04,270 --> 00:03:10,030
one of these my sequel servers goes down

00:03:10,930 --> 00:03:18,230
first of all lattice lattice is a very

00:03:14,360 --> 00:03:24,080
sweet open-source tool that allows you

00:03:18,230 --> 00:03:28,040
to run containers in a cluster lattice

00:03:24,080 --> 00:03:32,360
containers he uses docker images which

00:03:28,040 --> 00:03:36,470
is really cool they can be long-running

00:03:32,360 --> 00:03:40,430
or temporary tasks and they get

00:03:36,470 --> 00:03:46,820
dynamically scale and balanced across

00:03:40,430 --> 00:03:48,920
the cluster lattice has much a lot of

00:03:46,820 --> 00:03:51,500
similarities with cloud foundry without

00:03:48,920 --> 00:03:55,010
being a full golf and redeployment which

00:03:51,500 --> 00:03:56,959
you know it's big it's heavy its costly

00:03:55,010 --> 00:04:01,100
lattice is very lightweight and it's

00:03:56,959 --> 00:04:06,020
extremely fun to use it's it's really

00:04:01,100 --> 00:04:11,269
amazing I just I really love it four

00:04:06,020 --> 00:04:14,420
main features for lattice you have a

00:04:11,269 --> 00:04:17,239
scheduling lattice uses Diego Diego is a

00:04:14,420 --> 00:04:21,620
stone development this dealer is next

00:04:17,239 --> 00:04:23,600
generation of cloud foundry scheduler so

00:04:21,620 --> 00:04:26,300
everything that you have in called

00:04:23,600 --> 00:04:26,820
foundry the ghost with Diego you have it

00:04:26,300 --> 00:04:30,570
in last

00:04:26,820 --> 00:04:32,100
oh geez what this killer does is

00:04:30,570 --> 00:04:37,770
basically to balance the location of

00:04:32,100 --> 00:04:40,380
resources across a cluster of off

00:04:37,770 --> 00:04:44,990
servers that you have running in the

00:04:40,380 --> 00:04:49,080
lattice cluster right the algorithm is

00:04:44,990 --> 00:04:51,480
distributed the ocean model I encourage

00:04:49,080 --> 00:04:56,520
you know a little bit more about it it's

00:04:51,480 --> 00:04:59,520
very cool to learn so the the most

00:04:56,520 --> 00:05:07,850
important feature here is that since it

00:04:59,520 --> 00:05:12,510
uses scheduling and also it uses Diego

00:05:07,850 --> 00:05:14,520
what it does is to provide a very good

00:05:12,510 --> 00:05:16,410
compatibility with coal foundry the same

00:05:14,520 --> 00:05:18,090
image that you using lattice you can

00:05:16,410 --> 00:05:20,790
then deploy to production using coal

00:05:18,090 --> 00:05:23,970
foundry but you can stage it you can

00:05:20,790 --> 00:05:26,910
test it you can develop it using just

00:05:23,970 --> 00:05:30,050
lattice in one node week without having

00:05:26,910 --> 00:05:35,760
to deploy it you for example AWS or a

00:05:30,050 --> 00:05:37,710
server farm right a second very very

00:05:35,760 --> 00:05:42,120
cool feature is dynamic routing the

00:05:37,710 --> 00:05:46,980
dynamic routing allows you to start as

00:05:42,120 --> 00:05:49,920
many as containers as you want as you

00:05:46,980 --> 00:05:52,560
want and they will be automatically

00:05:49,920 --> 00:05:57,420
added to the load balancer as they

00:05:52,560 --> 00:05:59,820
become available right this is very this

00:05:57,420 --> 00:06:02,850
is very good because you don't have to

00:05:59,820 --> 00:06:05,160
manually configured of course you have

00:06:02,850 --> 00:06:07,080
the chance to configure that manually

00:06:05,160 --> 00:06:10,770
you have the chance to do some custom

00:06:07,080 --> 00:06:14,280
routing and provide for example a

00:06:10,770 --> 00:06:19,170
customer HTTP traffic shaping for a be

00:06:14,280 --> 00:06:22,410
test or Bluegreen deployments that is

00:06:19,170 --> 00:06:24,750
also self-healing another characteristic

00:06:22,410 --> 00:06:28,860
that shares with some of the cloud

00:06:24,750 --> 00:06:32,940
foundry topics which allows to compare a

00:06:28,860 --> 00:06:36,090
desired state of the system against the

00:06:32,940 --> 00:06:38,400
current state of the system right if

00:06:36,090 --> 00:06:40,780
flat is found that the desired state is

00:06:38,400 --> 00:06:42,640
not equal at

00:06:40,780 --> 00:06:46,240
the current state it will fix it

00:06:42,640 --> 00:06:49,150
automatically for you it also provides a

00:06:46,240 --> 00:06:52,890
very cool status stream via logger Gator

00:06:49,150 --> 00:06:55,720
that you can actually see all the

00:06:52,890 --> 00:06:59,620
activity that the logs are providing for

00:06:55,720 --> 00:07:02,340
each one of the containers running you

00:06:59,620 --> 00:07:05,920
just can actually tool at this via the

00:07:02,340 --> 00:07:09,910
CLI tool and you can see all the

00:07:05,920 --> 00:07:14,680
activity that's happening the CLI is

00:07:09,910 --> 00:07:19,120
very simple it's very easy to use you

00:07:14,680 --> 00:07:22,390
can target one of the latest is running

00:07:19,120 --> 00:07:26,500
in your computer or in a cloud

00:07:22,390 --> 00:07:28,750
deployment you can create the

00:07:26,500 --> 00:07:31,270
applications very simple with the chest

00:07:28,750 --> 00:07:34,840
I create just like you can see there for

00:07:31,270 --> 00:07:38,080
example we're creating a Loftus app

00:07:34,840 --> 00:07:40,060
that's on the docker repository and

00:07:38,080 --> 00:07:43,270
co-founder ease let's have a very simple

00:07:40,060 --> 00:07:45,880
application but you just need that you

00:07:43,270 --> 00:07:49,720
don't need any complicated procedure or

00:07:45,880 --> 00:07:51,300
whatever you can see logs this is how

00:07:49,720 --> 00:07:55,240
you can actually can start looking

00:07:51,300 --> 00:07:57,940
through the only logger gate or stream

00:07:55,240 --> 00:07:59,860
the firehose you can list the

00:07:57,940 --> 00:08:02,890
applications that you have you can scale

00:07:59,860 --> 00:08:05,290
applications that easy you can see the

00:08:02,890 --> 00:08:07,770
status of each one it's a single one of

00:08:05,290 --> 00:08:12,970
the containers that you're running and

00:08:07,770 --> 00:08:15,990
you can visualize the distribution of

00:08:12,970 --> 00:08:20,410
the workload between those containers

00:08:15,990 --> 00:08:22,240
it's just a very simple demonstration of

00:08:20,410 --> 00:08:25,930
the CLI it's not even administration's

00:08:22,240 --> 00:08:28,900
just showing you guys so why it's just

00:08:25,930 --> 00:08:31,300
lettuce it's extremely easy to use it's

00:08:28,900 --> 00:08:36,460
extremely simple to setup

00:08:31,300 --> 00:08:41,950
it's fast it's really fast it has a very

00:08:36,460 --> 00:08:44,080
small footprint and idle deployment and

00:08:41,950 --> 00:08:46,000
I don't lattice deployment weights as

00:08:44,080 --> 00:08:48,970
much as two hundred and fifty megabytes

00:08:46,000 --> 00:08:52,390
in memory so you can use it in your

00:08:48,970 --> 00:08:55,779
laptop try to use bosch light in your

00:08:52,390 --> 00:08:59,199
laptop they need we can

00:08:55,779 --> 00:09:03,430
it fits it's perfect fit for developers

00:08:59,199 --> 00:09:07,120
that work standalone or a small team for

00:09:03,430 --> 00:09:07,870
testing for staging I do use it I use it

00:09:07,120 --> 00:09:13,690
for

00:09:07,870 --> 00:09:19,540
UCD my company and as and for personal

00:09:13,690 --> 00:09:22,230
projects it's really good now let's get

00:09:19,540 --> 00:09:29,069
to the to the very important important

00:09:22,230 --> 00:09:33,940
part of the job right now console is

00:09:29,069 --> 00:09:37,170
also another really cool product that

00:09:33,940 --> 00:09:39,670
works that is for discovering and

00:09:37,170 --> 00:09:41,800
configuring services in your

00:09:39,670 --> 00:09:44,259
infrastructure right

00:09:41,800 --> 00:09:47,920
it's very distributed it's highly

00:09:44,259 --> 00:09:50,980
available so it will work in many

00:09:47,920 --> 00:09:53,769
situations it's perfect for production

00:09:50,980 --> 00:10:00,100
even though it didn't reach the 1.0

00:09:53,769 --> 00:10:05,620
virtually every every node provides

00:10:00,100 --> 00:10:09,339
services that are mapped with console it

00:10:05,620 --> 00:10:12,670
runs a console agent this agent is going

00:10:09,339 --> 00:10:15,189
to health check the services that are

00:10:12,670 --> 00:10:17,980
running in the node and it's going to be

00:10:15,189 --> 00:10:20,829
responsible to check the health of node

00:10:17,980 --> 00:10:28,230
itself and reported to the console

00:10:20,829 --> 00:10:32,889
servers the most important part is that

00:10:28,230 --> 00:10:35,889
you can use this you can use console to

00:10:32,889 --> 00:10:39,610
discover services with your applications

00:10:35,889 --> 00:10:41,889
clients whatever and they don't have to

00:10:39,610 --> 00:10:45,040
know exactly where the service is

00:10:41,889 --> 00:10:47,860
located which for to communicate which

00:10:45,040 --> 00:10:50,050
IP console will take care of it will

00:10:47,860 --> 00:10:54,540
return hey if you want to use my signal

00:10:50,050 --> 00:11:00,100
units to connect to this IP this port

00:10:54,540 --> 00:11:02,949
the for many features of console are all

00:11:00,100 --> 00:11:08,360
the tasks maybe it's not features its

00:11:02,949 --> 00:11:13,910
tasks console is service discovery is

00:11:08,360 --> 00:11:17,930
main purpose the cause of clients can

00:11:13,910 --> 00:11:19,519
provide services maybe an API maybe my

00:11:17,930 --> 00:11:23,269
sequel maybe Cassandra maybe Reddy's

00:11:19,519 --> 00:11:26,060
whatever and other clients can connect

00:11:23,269 --> 00:11:30,980
to counsel to find out how to connect to

00:11:26,060 --> 00:11:34,430
those services the way that you can

00:11:30,980 --> 00:11:37,820
connect to counsel is via a simple DNS

00:11:34,430 --> 00:11:46,180
query or an HTTP API which is really

00:11:37,820 --> 00:11:49,700
cool check it out also a very important

00:11:46,180 --> 00:11:54,709
characteristic of council is the health

00:11:49,700 --> 00:11:57,529
checking for failure detection those

00:11:54,709 --> 00:12:00,740
agents that lives that are running in

00:11:57,529 --> 00:12:05,329
the servers that are running our

00:12:00,740 --> 00:12:09,490
services can provide any number of

00:12:05,329 --> 00:12:14,269
health checks you can report for example

00:12:09,490 --> 00:12:17,540
how much memory is left how if the

00:12:14,269 --> 00:12:19,940
processor is running high whatever you

00:12:17,540 --> 00:12:22,070
want to report with scripts do you have

00:12:19,940 --> 00:12:26,930
the facility of doing that with simple

00:12:22,070 --> 00:12:30,260
scripts the health checks can be for

00:12:26,930 --> 00:12:33,680
example associated also to HTTP queries

00:12:30,260 --> 00:12:38,690
you can query a service via HTTP and if

00:12:33,680 --> 00:12:41,870
it returns 200 then you are okay this

00:12:38,690 --> 00:12:47,120
operation this this information can be

00:12:41,870 --> 00:12:50,750
used by any operator to take action in

00:12:47,120 --> 00:12:54,949
case that some catastrophic thing is

00:12:50,750 --> 00:12:59,630
happening it also has a very flexible

00:12:54,949 --> 00:13:03,199
key value store it's a hierarchical key

00:12:59,630 --> 00:13:06,079
value store you can do that you can use

00:13:03,199 --> 00:13:09,649
it for dynamic configurations you can

00:13:06,079 --> 00:13:13,900
use it for feature flying you can use it

00:13:09,649 --> 00:13:17,350
for leader election

00:13:13,900 --> 00:13:23,410
you have an HTTP API that you can use to

00:13:17,350 --> 00:13:25,450
query that key value store and for me

00:13:23,410 --> 00:13:29,500
the most cool feature about Council is

00:13:25,450 --> 00:13:34,360
that it's multi data center ready you

00:13:29,500 --> 00:13:37,450
don't have to add any layer to be able

00:13:34,360 --> 00:13:39,490
to query for different services in

00:13:37,450 --> 00:13:48,010
different data centers more than that

00:13:39,490 --> 00:13:52,330
later so many of you may be wondering

00:13:48,010 --> 00:13:58,510
lattice is in Diego Diego has council

00:13:52,330 --> 00:14:01,320
actually use console for discovering the

00:13:58,510 --> 00:14:04,450
cells that he's working with so why

00:14:01,320 --> 00:14:10,210
don't we use the same console that the

00:14:04,450 --> 00:14:13,120
air has for me the problem is symbol

00:14:10,210 --> 00:14:17,230
gets to the point of how much do you

00:14:13,120 --> 00:14:21,660
want to tamper inside of your deployment

00:14:17,230 --> 00:14:27,690
right even if you're using Cloud Foundry

00:14:21,660 --> 00:14:31,270
can be it can be very risky to start

00:14:27,690 --> 00:14:36,820
tampering with the council inside of

00:14:31,270 --> 00:14:39,160
Diego I can confirm that because I never

00:14:36,820 --> 00:14:45,660
tried it but for me it has to be a

00:14:39,160 --> 00:14:51,600
separate completely separate layer so

00:14:45,660 --> 00:14:54,370
there is one proposal in the in lattice

00:14:51,600 --> 00:14:57,670
repository in the lettuce bug tracker

00:14:54,370 --> 00:15:01,750
that says that it's probably good to use

00:14:57,670 --> 00:15:05,460
the sky DNS to solve the services the

00:15:01,750 --> 00:15:08,730
external service discoveries in lattice

00:15:05,460 --> 00:15:14,380
the second chance is to speed up us to

00:15:08,730 --> 00:15:18,070
start another console cluster just like

00:15:14,380 --> 00:15:22,620
we think that is it's a better choice

00:15:18,070 --> 00:15:26,030
and maybe there is a third option that

00:15:22,620 --> 00:15:27,950
we didn't explore or maybe another

00:15:26,030 --> 00:15:34,550
another one of you hasn't a better idea

00:15:27,950 --> 00:15:38,540
but so far starting a third eye starting

00:15:34,550 --> 00:15:43,610
a separate console cluster is for us is

00:15:38,540 --> 00:15:45,860
better let's talk about the problems

00:15:43,610 --> 00:15:54,920
there the inner problems with service

00:15:45,860 --> 00:15:57,920
discovery so let's say that we have one

00:15:54,920 --> 00:16:02,030
service running a multiple host right

00:15:57,920 --> 00:16:05,180
it's today's very common to have three

00:16:02,030 --> 00:16:08,270
or four for example my sequel database

00:16:05,180 --> 00:16:12,110
is running during master master

00:16:08,270 --> 00:16:15,920
replication or maybe you have Redis

00:16:12,110 --> 00:16:20,530
cluster or cassandra or whatever service

00:16:15,920 --> 00:16:26,420
you might want to have even your own API

00:16:20,530 --> 00:16:28,310
service right so if a client wants to

00:16:26,420 --> 00:16:32,020
connect to one of these services how to

00:16:28,310 --> 00:16:41,780
provide the right IP and the right port

00:16:32,020 --> 00:16:43,760
for this client this is one of the one

00:16:41,780 --> 00:16:46,130
of the problems that council solves

00:16:43,760 --> 00:16:48,740
right it's the problem that council

00:16:46,130 --> 00:16:51,290
solves and it's actually really hard

00:16:48,740 --> 00:16:56,500
because you have to have in mind a lot

00:16:51,290 --> 00:16:58,370
of constraints and and a lot of

00:16:56,500 --> 00:17:00,950
different problems that you may

00:16:58,370 --> 00:17:06,640
encounter the first of all of course is

00:17:00,950 --> 00:17:09,200
no fault what happens when one of this

00:17:06,640 --> 00:17:16,630
hosts one of these hosts

00:17:09,200 --> 00:17:16,630
has problems and can answer to request

00:17:17,500 --> 00:17:23,840
just for having this in mind every

00:17:21,980 --> 00:17:26,570
software and hardware piece will

00:17:23,840 --> 00:17:28,910
eventually fail at some time will

00:17:26,570 --> 00:17:32,000
eventually be shut down at some time

00:17:28,910 --> 00:17:35,930
this is Murphy's Law you can't avoid it

00:17:32,000 --> 00:17:40,640
it's impossible so

00:17:35,930 --> 00:17:45,350
let's say that no whole node not just a

00:17:40,640 --> 00:17:51,559
service a home node gets shut down due

00:17:45,350 --> 00:17:56,030
to power outage or whatever the service

00:17:51,559 --> 00:17:59,660
discovery tool will have to detect that

00:17:56,030 --> 00:18:05,260
this node has been shut down and will

00:17:59,660 --> 00:18:05,260
have to route all the other requests for

00:18:06,130 --> 00:18:15,800
my sequel service to the other available

00:18:09,620 --> 00:18:18,880
house right so in the text that the now

00:18:15,800 --> 00:18:23,120
due to the health checks that is

00:18:18,880 --> 00:18:26,860
constantly doing right it not only

00:18:23,120 --> 00:18:30,320
received health checks but it should

00:18:26,860 --> 00:18:35,929
constantly be checking for the null

00:18:30,320 --> 00:18:39,260
health once it detects that note when

00:18:35,929 --> 00:18:44,590
down just switches the traffic to the

00:18:39,260 --> 00:18:48,679
healthy node another problem that is

00:18:44,590 --> 00:18:55,640
quite difficult to solve is the is that

00:18:48,679 --> 00:18:59,600
today pretty much all the applications

00:18:55,640 --> 00:19:03,050
that we have can be scaled to hundreds

00:18:59,600 --> 00:19:04,790
of nodes very easily let's say that you

00:19:03,050 --> 00:19:07,250
are working for a start-up that's a

00:19:04,790 --> 00:19:11,750
start-up gaining is gaining momentum and

00:19:07,250 --> 00:19:14,000
some very famous person tweets that your

00:19:11,750 --> 00:19:17,900
startup is really cool you're going to

00:19:14,000 --> 00:19:21,920
start having to scale up your

00:19:17,900 --> 00:19:28,630
application horizontally like tenfold

00:19:21,920 --> 00:19:33,830
twenty fold the workload required for

00:19:28,630 --> 00:19:37,660
controlling that simply can be daunting

00:19:33,830 --> 00:19:40,309
if you are applying to the yourself so

00:19:37,660 --> 00:19:45,380
your service discovery solutions should

00:19:40,309 --> 00:19:48,670
be able to scale with you right and then

00:19:45,380 --> 00:19:51,910
there's net more efficiency

00:19:48,670 --> 00:19:57,640
all of this network traffic going from

00:19:51,910 --> 00:20:01,870
node to node can be can take a hit to

00:19:57,640 --> 00:20:04,840
the network so you have to be aware of

00:20:01,870 --> 00:20:07,920
bandwidth limits and your communication

00:20:04,840 --> 00:20:11,620
protocols really need to minimize

00:20:07,920 --> 00:20:17,530
network traffic to be as efficient as

00:20:11,620 --> 00:20:22,120
possible then there is what happened

00:20:17,530 --> 00:20:25,420
when your servers fail your application

00:20:22,120 --> 00:20:28,800
should be able to survive one failure

00:20:25,420 --> 00:20:32,290
and then another failure

00:20:28,800 --> 00:20:36,580
that's when self-healing algorithms

00:20:32,290 --> 00:20:40,290
comes in right and then you have data

00:20:36,580 --> 00:20:42,690
consistency which is very important in

00:20:40,290 --> 00:20:49,810
pretty much everything that we are doing

00:20:42,690 --> 00:20:53,710
let's say that you want you recover one

00:20:49,810 --> 00:20:57,420
address to connect to Cassandra right so

00:20:53,710 --> 00:21:00,790
I guess under cluster so you ask for

00:20:57,420 --> 00:21:05,740
that address to one console server and

00:21:00,790 --> 00:21:08,830
you ask and then another client as the

00:21:05,740 --> 00:21:10,870
same thing to another console server you

00:21:08,830 --> 00:21:13,480
have to be able to have the same

00:21:10,870 --> 00:21:16,810
response from all of your service

00:21:13,480 --> 00:21:19,980
discovery servers to the same query this

00:21:16,810 --> 00:21:25,120
is very important this is actually where

00:21:19,980 --> 00:21:30,190
console comes in console allows you to

00:21:25,120 --> 00:21:37,870
do all of that it has a very cool health

00:21:30,190 --> 00:21:40,060
check system so the first thing that you

00:21:37,870 --> 00:21:44,800
have to have in mind is that you can run

00:21:40,060 --> 00:21:49,330
any arbitrary common in your node using

00:21:44,800 --> 00:21:51,910
a script this script will return an exit

00:21:49,330 --> 00:21:56,920
status if successful everything is cool

00:21:51,910 --> 00:22:00,780
if not this the health check asian will

00:21:56,920 --> 00:22:00,780
report that to the console cluster

00:22:00,790 --> 00:22:06,860
second part if you want to use HTTP to

00:22:04,640 --> 00:22:09,260
poke a services that service that you

00:22:06,860 --> 00:22:16,450
have running in that's alright that's

00:22:09,260 --> 00:22:20,510
perfect too and and that's one it your

00:22:16,450 --> 00:22:24,830
service can proactively report to

00:22:20,510 --> 00:22:26,930
Council with a status over a time to

00:22:24,830 --> 00:22:31,610
leave

00:22:26,930 --> 00:22:36,650
and sort in the key value storage that

00:22:31,610 --> 00:22:40,220
council has so council can have can

00:22:36,650 --> 00:22:44,000
check this value and if it doesn't live

00:22:40,220 --> 00:22:46,160
up to the time to live then basically it

00:22:44,000 --> 00:22:50,240
will say hey this node is having

00:22:46,160 --> 00:22:55,880
problems council has two interfaces to

00:22:50,240 --> 00:23:00,290
work with one is via HTTP and the other

00:22:55,880 --> 00:23:04,100
one is just wearing DNS of course dienes

00:23:00,290 --> 00:23:11,270
is much lighter than HTTP but it's not

00:23:04,100 --> 00:23:15,770
as flexible as the API consensus is very

00:23:11,270 --> 00:23:18,350
important due to the infamous cap

00:23:15,770 --> 00:23:22,580
theorem the consistency availability and

00:23:18,350 --> 00:23:25,310
partitioning issue you can you can have

00:23:22,580 --> 00:23:26,690
the three of them at the same time you

00:23:25,310 --> 00:23:33,920
can only choose two

00:23:26,690 --> 00:23:36,590
so since council needs to be consistent

00:23:33,920 --> 00:23:40,030
really consistent and since it is very

00:23:36,590 --> 00:23:46,000
distributed so it is very partitioning

00:23:40,030 --> 00:23:46,000
it uses consensus algorithm to

00:23:46,450 --> 00:23:52,460
understand which node has failed which

00:23:50,300 --> 00:23:55,700
service has failed and then reroute the

00:23:52,460 --> 00:24:01,010
traffic the consensus protocol is based

00:23:55,700 --> 00:24:04,390
on raft is not exactly raft roughest of

00:24:01,010 --> 00:24:08,270
course it's completely outside of this

00:24:04,390 --> 00:24:10,080
talk but you can check it out it's it's

00:24:08,270 --> 00:24:14,280
very interesting

00:24:10,080 --> 00:24:19,680
and a very quick overview on how this

00:24:14,280 --> 00:24:26,150
works the quorum for taking a decision

00:24:19,680 --> 00:24:29,460
on which if fan-out is down or not is

00:24:26,150 --> 00:24:33,960
done by this simple formula which is n

00:24:29,460 --> 00:24:36,990
over 2 plus 1 this means that the latest

00:24:33,960 --> 00:24:42,210
that the minimum counsel cluster that

00:24:36,990 --> 00:24:44,430
you can have is 3 council nodes if one

00:24:42,210 --> 00:24:48,510
fails the other two can say hey there's

00:24:44,430 --> 00:24:51,060
a quorum to agree that the third the

00:24:48,510 --> 00:24:56,340
third server that the third cluster

00:24:51,060 --> 00:25:00,660
server has failed so we need to alert

00:24:56,340 --> 00:25:04,200
the operator right and having three or

00:25:00,660 --> 00:25:07,680
five it's the best way why simply

00:25:04,200 --> 00:25:09,690
because if you have three if one fails

00:25:07,680 --> 00:25:12,600
the other you can the other two can talk

00:25:09,690 --> 00:25:16,080
to each other if you have five and two

00:25:12,600 --> 00:25:17,730
fail then the other three can talk to

00:25:16,080 --> 00:25:21,450
each other and you will still be alive

00:25:17,730 --> 00:25:23,490
into the rule that of n over 2 plus one

00:25:21,450 --> 00:25:26,450
this is actually what console creators

00:25:23,490 --> 00:25:31,380
recommends you have three or five

00:25:26,450 --> 00:25:34,110
counsel cluster deployment then you have

00:25:31,380 --> 00:25:37,830
the problem of membership of actually

00:25:34,110 --> 00:25:43,740
how counsel will detect services to to

00:25:37,830 --> 00:25:45,360
provider and manage memberships in in

00:25:43,740 --> 00:25:51,450
order to provide the information of

00:25:45,360 --> 00:25:56,610
appliance service discovery uses this

00:25:51,450 --> 00:26:00,140
membership and and has two different

00:25:56,610 --> 00:26:04,050
polls which is the lam pool and one poll

00:26:00,140 --> 00:26:09,630
the land pool look at the local area

00:26:04,050 --> 00:26:13,830
network is council helps you by

00:26:09,630 --> 00:26:15,930
discovering services which allows you to

00:26:13,830 --> 00:26:18,360
reduce a lot of configuration that you

00:26:15,930 --> 00:26:23,090
have to use it uses a gossip protocol

00:26:18,360 --> 00:26:26,300
right the PO contains

00:26:23,090 --> 00:26:28,330
members of the data center clients and

00:26:26,300 --> 00:26:37,820
servers oh sorry

00:26:28,330 --> 00:26:40,700
when in the one pool is unique why

00:26:37,820 --> 00:26:43,940
because since you can use council to

00:26:40,700 --> 00:26:47,210
deploy that you do service discovery

00:26:43,940 --> 00:26:54,730
across multi data centers the one pool

00:26:47,210 --> 00:26:57,350
is provides information of the services

00:26:54,730 --> 00:27:00,290
regardless of the data center you know

00:26:57,350 --> 00:27:05,510
that service a is service a and service

00:27:00,290 --> 00:27:08,620
B is a recipe and just that another very

00:27:05,510 --> 00:27:13,460
cool feature is that failure detection

00:27:08,620 --> 00:27:19,520
allows Council to handle losses cut off

00:27:13,460 --> 00:27:23,690
connectivity so you can be sure that you

00:27:19,520 --> 00:27:29,420
will not have crazy packages being lost

00:27:23,690 --> 00:27:32,390
in the network I'm having little time

00:27:29,420 --> 00:27:34,370
right how much time do you have three

00:27:32,390 --> 00:27:36,590
minutes Wow

00:27:34,370 --> 00:27:38,000
I have a very brief example to show you

00:27:36,590 --> 00:27:41,600
guys let's see if I can do it real quick

00:27:38,000 --> 00:27:43,280
let's say that we have a raddest

00:27:41,600 --> 00:27:46,970
employment and a console deployment and

00:27:43,280 --> 00:27:54,590
we have a my sequel stack with to master

00:27:46,970 --> 00:27:57,740
masters right then counsel patients tops

00:27:54,590 --> 00:28:01,940
to counsel servers to provide health

00:27:57,740 --> 00:28:03,530
check information let's say that from

00:28:01,940 --> 00:28:05,090
your lattice deployment for your

00:28:03,530 --> 00:28:05,780
application requests to connect to my

00:28:05,090 --> 00:28:09,970
sequel

00:28:05,780 --> 00:28:14,870
I will query console via HTTP or DNS

00:28:09,970 --> 00:28:17,300
then console we return the address that

00:28:14,870 --> 00:28:23,630
I need to connect in order to use my

00:28:17,300 --> 00:28:29,210
sequel and what happens when this one of

00:28:23,630 --> 00:28:32,180
the server fails I simply what console

00:28:29,210 --> 00:28:34,700
will do is to understand that the server

00:28:32,180 --> 00:28:36,080
is failing and start rerouting the

00:28:34,700 --> 00:28:40,520
traffic firm

00:28:36,080 --> 00:28:44,570
the that my sequel server to the good my

00:28:40,520 --> 00:28:48,560
sequel server wow that was quick

00:28:44,570 --> 00:28:52,280
so coming up real soon we will have a

00:28:48,560 --> 00:28:54,380
post a blog post on Alturas blog with

00:28:52,280 --> 00:28:59,950
all of this and we will provide the demo

00:28:54,380 --> 00:29:04,910
how to do this a video during this so

00:28:59,950 --> 00:29:07,010
just stay tuned check it out and I guess

00:29:04,910 --> 00:29:09,200
that we didn't we don't have an even

00:29:07,010 --> 00:29:11,710
time for questions but if you have one

00:29:09,200 --> 00:29:15,020
and real quick I maybe I can take it

00:29:11,710 --> 00:29:17,510
no questions that was real that's really

00:29:15,020 --> 00:29:21,230
bad or really good depends on your look

00:29:17,510 --> 00:29:23,470
ok alright so I think this is it thank

00:29:21,230 --> 00:29:25,440
you so much for being here

00:29:23,470 --> 00:29:29,420
see you later see you next year

00:29:25,440 --> 00:29:29,420

YouTube URL: https://www.youtube.com/watch?v=thNlwp3MxkQ


