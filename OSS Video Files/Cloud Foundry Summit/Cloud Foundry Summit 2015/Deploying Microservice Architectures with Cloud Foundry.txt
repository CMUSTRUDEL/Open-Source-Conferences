Title: Deploying Microservice Architectures with Cloud Foundry
Publication date: 2015-05-13
Playlist: Cloud Foundry Summit 2015
Description: 
	Deploying Microservice Architectures with Cloud Foundry - 04 Matt Stine 720p
Captions: 
	00:00:00,140 --> 00:00:07,890
hi everybody hi lunch wake up good I

00:00:06,359 --> 00:00:09,450
know you're all going to be in a food

00:00:07,890 --> 00:00:11,550
coma in a few minutes so we have to go

00:00:09,450 --> 00:00:13,230
and we have to go fast there's no way we

00:00:11,550 --> 00:00:16,580
can possibly complete this talk in 30

00:00:13,230 --> 00:00:21,390
minutes but we're gonna try anyway

00:00:16,580 --> 00:00:22,769
very quickly me Matt Stein they called

00:00:21,390 --> 00:00:24,060
me a principal software engineer or

00:00:22,769 --> 00:00:25,650
whatever that means I do a lot of stuff

00:00:24,060 --> 00:00:28,050
at pivotal around Cloud Foundry in

00:00:25,650 --> 00:00:31,170
spring and I spend a lot of time on

00:00:28,050 --> 00:00:34,050
airplanes as it turns out managed to get

00:00:31,170 --> 00:00:36,239
here on time which is good I wrote a

00:00:34,050 --> 00:00:37,920
little book that you might have seen

00:00:36,239 --> 00:00:40,649
floating around if you don't have a

00:00:37,920 --> 00:00:42,660
print copy of this yet and you want one

00:00:40,649 --> 00:00:44,340
just attack the fine people at the

00:00:42,660 --> 00:00:46,260
pivotal booth and they should have some

00:00:44,340 --> 00:00:48,539
I think they have a few hundred of those

00:00:46,260 --> 00:00:51,059
so if you want to get ahold of that this

00:00:48,539 --> 00:00:53,460
is sort of my cloud native application

00:00:51,059 --> 00:00:57,120
architecture propaganda that you should

00:00:53,460 --> 00:01:02,520
all consume and believe and and and go

00:00:57,120 --> 00:01:06,090
do so so Andrew Schaeffer gave a talk

00:01:02,520 --> 00:01:09,659
yesterday who went to Andrews talk okay

00:01:06,090 --> 00:01:11,220
so Andrews talk was without doing this

00:01:09,659 --> 00:01:13,049
on purpose a great set up for my

00:01:11,220 --> 00:01:15,330
presentation he actually helped me craft

00:01:13,049 --> 00:01:17,310
the abstract for this presentation and

00:01:15,330 --> 00:01:19,170
this is hit these are his words so he

00:01:17,310 --> 00:01:21,810
said now that you have Cloud Foundry

00:01:19,170 --> 00:01:23,520
what are you going to do with it it's

00:01:21,810 --> 00:01:26,280
kind of an important question right we

00:01:23,520 --> 00:01:28,590
have this platform how can we use a

00:01:26,280 --> 00:01:32,400
platform in a way that's actually going

00:01:28,590 --> 00:01:34,170
to give us give us what we want and so

00:01:32,400 --> 00:01:37,259
the first thing that I would say is that

00:01:34,170 --> 00:01:40,650
if you're smart don't try to to

00:01:37,259 --> 00:01:45,240
microservices on day one you should

00:01:40,650 --> 00:01:47,159
actually start with a monolith actually

00:01:45,240 --> 00:01:49,710
if I could build everything I wanted to

00:01:47,159 --> 00:01:52,380
build as a monolith and do continuous

00:01:49,710 --> 00:01:54,360
delivery and and and be agile and

00:01:52,380 --> 00:01:55,710
innovate and get all that right I would

00:01:54,360 --> 00:01:58,409
because it would be a whole heck of a

00:01:55,710 --> 00:02:01,020
lot easier than doing micro services my

00:01:58,409 --> 00:02:02,759
services are hard stuff so start with a

00:02:01,020 --> 00:02:04,110
monolith while you're small while you

00:02:02,759 --> 00:02:05,969
can you're gonna build something new

00:02:04,110 --> 00:02:08,550
this is where you want to begin small

00:02:05,969 --> 00:02:12,599
teams small monolith make it twelve

00:02:08,550 --> 00:02:13,980
factor if you have something small it

00:02:12,599 --> 00:02:15,659
doesn't matter if it's a

00:02:13,980 --> 00:02:18,390
service or a monolith or anything else

00:02:15,659 --> 00:02:19,860
making something 12 factor and having

00:02:18,390 --> 00:02:22,500
that contract between your application

00:02:19,860 --> 00:02:25,080
and the platform set that such that they

00:02:22,500 --> 00:02:27,209
get along well with one another is is

00:02:25,080 --> 00:02:28,860
relatively easy to do it's a lot harder

00:02:27,209 --> 00:02:31,349
to take something that's big and been

00:02:28,860 --> 00:02:32,849
around for a long time and and turn that

00:02:31,349 --> 00:02:34,769
into a twelve factor app and I'm sure

00:02:32,849 --> 00:02:38,730
many folks in the room have felt that

00:02:34,769 --> 00:02:44,760
pain but we all know that eventually

00:02:38,730 --> 00:02:48,090
things get bigger and we don't really

00:02:44,760 --> 00:02:51,959
have a good answer to at which at what

00:02:48,090 --> 00:02:53,459
point is it too big in fact micro

00:02:51,959 --> 00:02:56,760
services are a terrible it's a terrible

00:02:53,459 --> 00:02:58,650
word when we talk about micro services

00:02:56,760 --> 00:03:00,750
we see this micro thing and we start to

00:02:58,650 --> 00:03:02,190
think who something that I can count I

00:03:00,750 --> 00:03:03,989
can tell you how big it is and I can

00:03:02,190 --> 00:03:07,109
measure it and I can put a number on it

00:03:03,989 --> 00:03:11,190
like lines of code or a number of

00:03:07,109 --> 00:03:12,900
operations or things like that don't do

00:03:11,190 --> 00:03:19,040
that that's all wrong don't do that at

00:03:12,900 --> 00:03:22,739
all it's not quantitative micro it's

00:03:19,040 --> 00:03:26,069
qualitative Micro roll responsibility

00:03:22,739 --> 00:03:28,049
capability focus scope those things are

00:03:26,069 --> 00:03:29,910
really hard to measure because every

00:03:28,049 --> 00:03:31,260
person in the room in every context that

00:03:29,910 --> 00:03:32,549
you come from you're gonna have a

00:03:31,260 --> 00:03:35,430
slightly different answer to the

00:03:32,549 --> 00:03:38,160
question of how big is too big that it's

00:03:35,430 --> 00:03:40,049
time to start decomposing this thing

00:03:38,160 --> 00:03:47,989
into something that we're calling micro

00:03:40,049 --> 00:03:47,989
services so what are micro services

00:03:48,530 --> 00:03:55,470
micro services has a lot of definitions

00:03:52,760 --> 00:03:59,329
that are floating around lots of hype I

00:03:55,470 --> 00:03:59,329
like Adrian's definition best

00:04:00,319 --> 00:04:05,790
he says the dreaded word

00:04:02,430 --> 00:04:08,099
service-oriented architecture in his

00:04:05,790 --> 00:04:09,690
definition okay I thought the micro

00:04:08,099 --> 00:04:12,150
services were different than SOA we're

00:04:09,690 --> 00:04:13,680
not doing s so any more SOA is bad micro

00:04:12,150 --> 00:04:17,810
services are good now don't don't that's

00:04:13,680 --> 00:04:21,780
that's wrong actually if you go read

00:04:17,810 --> 00:04:23,310
Wikipedia first five paragraphs or so of

00:04:21,780 --> 00:04:25,229
the service-oriented architecture

00:04:23,310 --> 00:04:27,160
article there's really great stuff in

00:04:25,229 --> 00:04:28,900
there and you read about what the

00:04:27,160 --> 00:04:31,390
focus of what we were trying to achieve

00:04:28,900 --> 00:04:34,210
would that was it's actually all very

00:04:31,390 --> 00:04:37,630
good stuff and then we went and

00:04:34,210 --> 00:04:40,660
implemented it and we got it kind of

00:04:37,630 --> 00:04:43,690
wrong because we missed the two things

00:04:40,660 --> 00:04:46,120
on either side of it that Adrienne adds

00:04:43,690 --> 00:04:48,670
in his definition one the idea of loose

00:04:46,120 --> 00:04:50,980
coupling because what do we do when we

00:04:48,670 --> 00:04:53,110
did SOA well we wouldn't found something

00:04:50,980 --> 00:04:55,480
really big to couple ourselves to which

00:04:53,110 --> 00:04:59,140
was that ESB and we put all the

00:04:55,480 --> 00:05:00,700
important stuff inside the ESB and then

00:04:59,140 --> 00:05:03,790
anytime we needed to change something we

00:05:00,700 --> 00:05:05,740
had to go through the ESB and all the

00:05:03,790 --> 00:05:08,890
enterprise architects clinging to the

00:05:05,740 --> 00:05:12,700
ESB like barnacles and start to put up

00:05:08,890 --> 00:05:14,410
this barriers to change doesn't matter

00:05:12,700 --> 00:05:17,230
where your monolith is if it's an

00:05:14,410 --> 00:05:19,630
application or if it's a bus or we were

00:05:17,230 --> 00:05:22,420
talking about this morning about how how

00:05:19,630 --> 00:05:25,390
an f5 can load a load balancer can

00:05:22,420 --> 00:05:27,160
become a monolith as well any time you

00:05:25,390 --> 00:05:29,890
start putting all of your stuff in one

00:05:27,160 --> 00:05:31,840
place you can get into this situation so

00:05:29,890 --> 00:05:33,880
loose coupling means what it means that

00:05:31,840 --> 00:05:36,310
I can deploy my service anytime I want

00:05:33,880 --> 00:05:40,560
to and I don't have to ask you if it's

00:05:36,310 --> 00:05:44,140
okay now that sounds hard and it is hard

00:05:40,560 --> 00:05:45,070
but if I can get there I think we would

00:05:44,140 --> 00:05:47,080
all agree that that would be very

00:05:45,070 --> 00:05:48,430
powerful now one of the ways that we can

00:05:47,080 --> 00:05:53,740
get there is this idea of a bounded

00:05:48,430 --> 00:05:55,870
context what's a bounded context Eric

00:05:53,740 --> 00:06:00,630
Evans started writing about this in

00:05:55,870 --> 00:06:03,780
domain driven design twelve years ago

00:06:00,630 --> 00:06:08,200
who's read the domain driven design book

00:06:03,780 --> 00:06:12,070
okay you don't have to read the whole

00:06:08,200 --> 00:06:13,090
thing start about I think chapter 13 he

00:06:12,070 --> 00:06:16,120
starts talking about this thing called

00:06:13,090 --> 00:06:17,530
strategic design and you read about

00:06:16,120 --> 00:06:19,810
three chapters of that and you realize

00:06:17,530 --> 00:06:22,030
this is a textbook on how to do micro

00:06:19,810 --> 00:06:24,550
services except he never uses the word

00:06:22,030 --> 00:06:26,400
microservices because honestly what

00:06:24,550 --> 00:06:29,580
we're trying to do is just take

00:06:26,400 --> 00:06:34,450
principles and concepts that actually

00:06:29,580 --> 00:06:35,979
worked very well and arguably are a set

00:06:34,450 --> 00:06:38,169
of the small part of the set of small

00:06:35,979 --> 00:06:40,750
things that we can say is true about

00:06:38,169 --> 00:06:41,110
software engineering very few things

00:06:40,750 --> 00:06:43,780
that we can

00:06:41,110 --> 00:06:45,070
they are true versus false if there are

00:06:43,780 --> 00:06:47,050
a handful of principles out there and

00:06:45,070 --> 00:06:50,800
these things start to feel like they're

00:06:47,050 --> 00:06:53,230
in that category but you look at a

00:06:50,800 --> 00:06:55,330
domain you know that if a domain gets

00:06:53,230 --> 00:06:57,790
too big you go from one side of it to

00:06:55,330 --> 00:06:59,950
the other and you take the same term and

00:06:57,790 --> 00:07:01,960
you try to understand what does that

00:06:59,950 --> 00:07:03,820
term mean and all of the different

00:07:01,960 --> 00:07:06,880
context along the way from one side of

00:07:03,820 --> 00:07:08,290
the business to the other how many

00:07:06,880 --> 00:07:10,710
different definitions do you come up

00:07:08,290 --> 00:07:13,270
with if you come up with more than one

00:07:10,710 --> 00:07:14,680
you don't have a bounded context because

00:07:13,270 --> 00:07:18,970
the domains not actually internally

00:07:14,680 --> 00:07:22,780
consistent across itself so pick

00:07:18,970 --> 00:07:24,220
whatever your central concept is I was

00:07:22,780 --> 00:07:26,650
working with an airline customer we're

00:07:24,220 --> 00:07:27,820
talking about a reservation said how

00:07:26,650 --> 00:07:31,090
many different definitions of

00:07:27,820 --> 00:07:32,290
reservation do you have probably 17 okay

00:07:31,090 --> 00:07:34,420
well if you've got 17 different

00:07:32,290 --> 00:07:37,330
definitions can we all agree on one

00:07:34,420 --> 00:07:39,400
course not we can't we all have slightly

00:07:37,330 --> 00:07:41,860
different connotation you go different

00:07:39,400 --> 00:07:43,900
context whether it's an order or a movie

00:07:41,860 --> 00:07:45,520
or something else you have these central

00:07:43,900 --> 00:07:47,680
concepts that everyone treats a little

00:07:45,520 --> 00:07:50,440
bit differently and so what you do is

00:07:47,680 --> 00:07:52,630
you find context where if I keep the

00:07:50,440 --> 00:07:55,650
boundary here all the words mean the

00:07:52,630 --> 00:07:59,410
same thing from one side to the other

00:07:55,650 --> 00:08:01,660
that is the thing that either is big or

00:07:59,410 --> 00:08:02,730
small or somewhere in between and you're

00:08:01,660 --> 00:08:05,410
going to come up with a different answer

00:08:02,730 --> 00:08:06,190
for every context in your business and

00:08:05,410 --> 00:08:08,530
you're going to come up with different

00:08:06,190 --> 00:08:10,900
answers across every business but if you

00:08:08,530 --> 00:08:13,690
can get that right and then you can

00:08:10,900 --> 00:08:15,760
bound that thing with an API and you can

00:08:13,690 --> 00:08:17,860
say nobody gets to know what's going on

00:08:15,760 --> 00:08:19,900
inside the box you only get to know

00:08:17,860 --> 00:08:21,700
what's going on at the API level then

00:08:19,900 --> 00:08:23,620
you can create these bounded context

00:08:21,700 --> 00:08:25,030
that are loosely coupled you don't know

00:08:23,620 --> 00:08:27,310
what's going on you can't couple to

00:08:25,030 --> 00:08:28,960
details you've got this wall this

00:08:27,310 --> 00:08:31,030
barrier kind of keeping you from

00:08:28,960 --> 00:08:33,550
becoming too bound to the things that

00:08:31,030 --> 00:08:35,170
you're dependent upon and maybe you can

00:08:33,550 --> 00:08:38,560
start to deploy services whenever you

00:08:35,170 --> 00:08:42,430
want to now if that all sounded very

00:08:38,560 --> 00:08:46,330
complicated it's because it is and

00:08:42,430 --> 00:08:48,820
there's a sense in which you can't just

00:08:46,330 --> 00:08:52,720
start doing this

00:08:48,820 --> 00:08:54,700
I think the way Martin described this

00:08:52,720 --> 00:08:55,360
this idea of you must be this tall to

00:08:54,700 --> 00:08:57,640
ride

00:08:55,360 --> 00:08:58,750
the micro-services ride is probably one

00:08:57,640 --> 00:09:02,260
of the best ways that I've heard this

00:08:58,750 --> 00:09:03,490
explained so if you can't do these four

00:09:02,260 --> 00:09:06,370
basic things

00:09:03,490 --> 00:09:08,950
if you can't provision new environments

00:09:06,370 --> 00:09:11,770
in seconds or minutes if you can't

00:09:08,950 --> 00:09:13,630
monitor things reasonably well if you

00:09:11,770 --> 00:09:18,040
can't deploy a new line of code very

00:09:13,630 --> 00:09:22,030
quickly and if you don't have something

00:09:18,040 --> 00:09:24,070
that feels like a devops culture and and

00:09:22,030 --> 00:09:25,930
andrew talked at length about that so

00:09:24,070 --> 00:09:29,140
refer to his talk if you want to know

00:09:25,930 --> 00:09:32,500
what I mean by that then you probably

00:09:29,140 --> 00:09:34,090
need to come back next year fix these

00:09:32,500 --> 00:09:36,700
things first and then maybe you can go

00:09:34,090 --> 00:09:38,170
do that now as it turns out you start to

00:09:36,700 --> 00:09:40,990
look at Cloud Foundry and I talked about

00:09:38,170 --> 00:09:43,180
this last year there is a nice

00:09:40,990 --> 00:09:45,790
relationship between micro services and

00:09:43,180 --> 00:09:48,370
Cloud Foundry in that not just anything

00:09:45,790 --> 00:09:51,610
will run on Cloud Foundry well as it

00:09:48,370 --> 00:09:53,530
turns out the things that we build that

00:09:51,610 --> 00:09:57,520
feel like micro services tend to run

00:09:53,530 --> 00:09:58,990
kind of well on Cloud Foundry and you

00:09:57,520 --> 00:10:00,339
have these issues that you have to deal

00:09:58,990 --> 00:10:02,589
with when you start deploying micro

00:10:00,339 --> 00:10:04,150
services provisioning new environments

00:10:02,589 --> 00:10:06,339
provisioning new code that's something

00:10:04,150 --> 00:10:08,320
we sort of know how to do in this world

00:10:06,339 --> 00:10:09,940
so there's a sense in which you bring

00:10:08,320 --> 00:10:12,130
these two things together one doesn't

00:10:09,940 --> 00:10:15,520
require the other but one can definitely

00:10:12,130 --> 00:10:18,250
help the other and so we have all these

00:10:15,520 --> 00:10:20,530
great features in Cloud Foundry that

00:10:18,250 --> 00:10:22,900
help us to deal with a lot of the

00:10:20,530 --> 00:10:25,740
concerns that we run into with micro

00:10:22,900 --> 00:10:31,450
services I can provision code quickly

00:10:25,740 --> 00:10:33,910
repeatably reliably I can scale I can

00:10:31,450 --> 00:10:36,850
let the health manager or Diego

00:10:33,910 --> 00:10:39,100
whichever flavor we're on right now take

00:10:36,850 --> 00:10:41,200
care of making sure that when things die

00:10:39,100 --> 00:10:42,730
that they come back I can deal with a

00:10:41,200 --> 00:10:44,560
lot of my routing and load balancing

00:10:42,730 --> 00:10:46,089
concerns and I can run all the data

00:10:44,560 --> 00:10:48,220
services that I want to run all the

00:10:46,089 --> 00:10:49,950
services you know Bosch all of the

00:10:48,220 --> 00:10:52,180
things and things are going to be

00:10:49,950 --> 00:10:56,130
working pretty well in this micro

00:10:52,180 --> 00:10:58,660
services world but that's not enough so

00:10:56,130 --> 00:11:01,510
so Dave sire who works on spring cloud

00:10:58,660 --> 00:11:03,370
project that that I work on he made this

00:11:01,510 --> 00:11:06,790
statement at spring one last year that

00:11:03,370 --> 00:11:08,350
no micro service is an island doesn't

00:11:06,790 --> 00:11:12,190
matter if we can

00:11:08,350 --> 00:11:14,260
small services it's good but it's not

00:11:12,190 --> 00:11:16,750
enough being able to build small

00:11:14,260 --> 00:11:18,340
services and deploy them is good but

00:11:16,750 --> 00:11:20,170
it's not enough being able to build them

00:11:18,340 --> 00:11:22,500
deploy them and run them and keep them

00:11:20,170 --> 00:11:24,760
running is good but it's not enough

00:11:22,500 --> 00:11:26,500
because as soon as we start to decompose

00:11:24,760 --> 00:11:28,570
a monolith and as soon as we start to

00:11:26,500 --> 00:11:30,670
put Network boundaries between the

00:11:28,570 --> 00:11:32,110
things that we're building we start to

00:11:30,670 --> 00:11:36,100
create these nasty things called

00:11:32,110 --> 00:11:41,350
distributed systems and distributed

00:11:36,100 --> 00:11:44,020
systems are hard as well and so we start

00:11:41,350 --> 00:11:47,200
to run in to a lot of new challenges

00:11:44,020 --> 00:11:51,640
that maybe we didn't have when we were

00:11:47,200 --> 00:11:54,370
writing code inside of a monolith how do

00:11:51,640 --> 00:11:56,470
I get configuration information out to

00:11:54,370 --> 00:11:58,930
all of my micro services and then all of

00:11:56,470 --> 00:12:01,690
my scaled out instances of my micro

00:11:58,930 --> 00:12:04,900
services consistently and reliably how

00:12:01,690 --> 00:12:07,060
do I discover where things are how do I

00:12:04,900 --> 00:12:09,550
once I know where things are actually

00:12:07,060 --> 00:12:12,190
route traffic to them and do load

00:12:09,550 --> 00:12:15,040
balancing and Cloud Foundry does some of

00:12:12,190 --> 00:12:16,390
this but maybe we want to do things even

00:12:15,040 --> 00:12:19,810
more sophisticated with what Cloud

00:12:16,390 --> 00:12:21,430
Foundry can do today and obviously I

00:12:19,810 --> 00:12:23,380
deploy more things I have more things

00:12:21,430 --> 00:12:24,760
that can break so more things you're

00:12:23,380 --> 00:12:26,890
running the more likely something in

00:12:24,760 --> 00:12:28,560
your system is going to fail if you

00:12:26,890 --> 00:12:30,850
don't actually think about that and

00:12:28,560 --> 00:12:34,330
something does fail and failure doesn't

00:12:30,850 --> 00:12:37,000
mean it died failure might mean that the

00:12:34,330 --> 00:12:39,070
latency got to a point where I have

00:12:37,000 --> 00:12:41,710
enough load on an upstream service that

00:12:39,070 --> 00:12:43,570
I fill up all of my thread pools waiting

00:12:41,710 --> 00:12:45,970
on this thing to respond and then that

00:12:43,570 --> 00:12:47,560
thing does die and then something

00:12:45,970 --> 00:12:50,020
dependent upon it dies and we have this

00:12:47,560 --> 00:12:52,030
cascade effect you don't run into that

00:12:50,020 --> 00:12:53,140
when you call a method that's running in

00:12:52,030 --> 00:12:55,660
process with you and you get an

00:12:53,140 --> 00:12:56,860
exception you do have failures but

00:12:55,660 --> 00:12:58,060
they're very different types of failures

00:12:56,860 --> 00:13:01,390
a little bit easier to figure out what's

00:12:58,060 --> 00:13:04,270
going on and there's a sense in which

00:13:01,390 --> 00:13:07,240
monitoring becomes even more of a

00:13:04,270 --> 00:13:09,820
concern if you have one app I can plug a

00:13:07,240 --> 00:13:12,460
monitoring tool into it and I can I can

00:13:09,820 --> 00:13:14,140
pretty well tell you what's going on if

00:13:12,460 --> 00:13:15,370
I have ten apps I can plug a monitoring

00:13:14,140 --> 00:13:16,840
tool into ten app so I can pretty much

00:13:15,370 --> 00:13:18,730
say what's going on I have a hundred

00:13:16,840 --> 00:13:20,830
micro services deployed that are

00:13:18,730 --> 00:13:22,000
composing a distributed system and it's

00:13:20,830 --> 00:13:23,440
only the composition of

00:13:22,000 --> 00:13:25,630
those things that gives me the behavior

00:13:23,440 --> 00:13:28,870
that I'm looking for where do I put the

00:13:25,630 --> 00:13:31,630
plug into that system to find out what

00:13:28,870 --> 00:13:33,220
it's doing so that I can know how the

00:13:31,630 --> 00:13:35,620
system is behaving there's no physical

00:13:33,220 --> 00:13:36,880
thing that represents the system we have

00:13:35,620 --> 00:13:38,860
a bunch of little things that are

00:13:36,880 --> 00:13:40,960
running around and the behavior that

00:13:38,860 --> 00:13:43,990
emerges from that composition is the

00:13:40,960 --> 00:13:45,220
system how do you monitor that these are

00:13:43,990 --> 00:13:46,570
the types of questions that we have to

00:13:45,220 --> 00:13:49,120
answer so we need some sort of a

00:13:46,570 --> 00:13:52,930
representation of the composite system

00:13:49,120 --> 00:13:55,360
and I started being involved in

00:13:52,930 --> 00:13:57,430
conversations about this several months

00:13:55,360 --> 00:14:00,280
ago and the first thing that we started

00:13:57,430 --> 00:14:04,360
working from was this idea of the big a

00:14:00,280 --> 00:14:05,440
app as opposed to the little a app you

00:14:04,360 --> 00:14:07,000
know what's the little layette those are

00:14:05,440 --> 00:14:10,540
the apps that we deploy to Cloud Foundry

00:14:07,000 --> 00:14:13,540
but everybody's got some set of apps

00:14:10,540 --> 00:14:15,460
that they deploy to Cloud Foundry that

00:14:13,540 --> 00:14:18,070
we put a user interface in front of and

00:14:15,460 --> 00:14:19,360
the customer knows that as an app but

00:14:18,070 --> 00:14:23,680
there's actually lots of little Cloud

00:14:19,360 --> 00:14:26,170
Foundry apps that are that thing and we

00:14:23,680 --> 00:14:29,320
say okay I need a representation of that

00:14:26,170 --> 00:14:31,810
that I can manage and work with and so

00:14:29,320 --> 00:14:33,960
the first tool that we had to kind of

00:14:31,810 --> 00:14:40,360
deal with that was this was a manifest

00:14:33,960 --> 00:14:42,339
and a manifest can tell me a lot to

00:14:40,360 --> 00:14:44,770
solve this problem I can name several

00:14:42,339 --> 00:14:47,140
applications and the code that produces

00:14:44,770 --> 00:14:50,260
those applications and I can say deploy

00:14:47,140 --> 00:14:54,070
this thing and buying this thing to

00:14:50,260 --> 00:14:57,100
these services and I can get something

00:14:54,070 --> 00:15:01,000
that looks like what I want the problem

00:14:57,100 --> 00:15:03,850
with this is that it's very static this

00:15:01,000 --> 00:15:06,030
is a point and time description of what

00:15:03,850 --> 00:15:10,210
the system should look like right now

00:15:06,030 --> 00:15:14,350
but if I need to change that I need to

00:15:10,210 --> 00:15:16,030
go back to go and start again and I

00:15:14,350 --> 00:15:20,140
probably end up having to deploy this

00:15:16,030 --> 00:15:21,430
whole unit again and that's fine but

00:15:20,140 --> 00:15:23,680
when I get into the world of micro

00:15:21,430 --> 00:15:25,030
services I want the ability to be a

00:15:23,680 --> 00:15:27,130
little bit more dynamic and I'll and

00:15:25,030 --> 00:15:28,480
I'll tell you why so then I start

00:15:27,130 --> 00:15:32,440
thinking well what I really want is

00:15:28,480 --> 00:15:34,750
something like Bosch but for apps for

00:15:32,440 --> 00:15:35,980
Microsoft so Bosch is very good at

00:15:34,750 --> 00:15:39,190
taking one I've got a

00:15:35,980 --> 00:15:42,820
cluster of things that happen to live on

00:15:39,190 --> 00:15:46,000
VMs and I can describe that thing as a

00:15:42,820 --> 00:15:48,490
system until Bosh go make this so and it

00:15:46,000 --> 00:15:50,530
will go make it so and as things change

00:15:48,490 --> 00:15:52,660
in that environment it will keep it the

00:15:50,530 --> 00:15:55,540
way it ought to the way I described it

00:15:52,660 --> 00:15:58,180
it will converge to some desired state

00:15:55,540 --> 00:15:59,680
eventually and then I go into my

00:15:58,180 --> 00:16:01,930
manifest and I say make me a little bit

00:15:59,680 --> 00:16:03,820
more of this thing and apply it and it

00:16:01,930 --> 00:16:05,170
will do that and see it and Cloud

00:16:03,820 --> 00:16:10,450
Foundry manifest will do that to an

00:16:05,170 --> 00:16:13,900
extent but even then Bosh wants to own

00:16:10,450 --> 00:16:17,710
the whole thing right here's a cluster

00:16:13,900 --> 00:16:21,130
make this thing exist but there's no

00:16:17,710 --> 00:16:22,840
concept of okay now I want to without

00:16:21,130 --> 00:16:26,440
redeploying anything split it into two

00:16:22,840 --> 00:16:29,650
things and have this manage the left

00:16:26,440 --> 00:16:30,490
half and this managed the right half but

00:16:29,650 --> 00:16:34,300
when you start to talk about

00:16:30,490 --> 00:16:35,770
microservices you have this this topic

00:16:34,300 --> 00:16:37,750
out there of it's not just about

00:16:35,770 --> 00:16:40,870
technology it's about organization in

00:16:37,750 --> 00:16:44,800
people and you have this very strong

00:16:40,870 --> 00:16:48,550
idea of decentralized so you think about

00:16:44,800 --> 00:16:51,310
Bosh Bosh is centralizing management of

00:16:48,550 --> 00:16:54,010
a cluster I want now decentralized

00:16:51,310 --> 00:16:56,200
management of a cluster and I want all

00:16:54,010 --> 00:16:58,440
the pieces that form my composite system

00:16:56,200 --> 00:17:00,940
to actually be able to act autonomously

00:16:58,440 --> 00:17:02,620
meaning I want all the teams to do be

00:17:00,940 --> 00:17:05,140
able to do what I want to be able to

00:17:02,620 --> 00:17:06,580
deploy my service whenever I want so if

00:17:05,140 --> 00:17:08,350
I have a change I can deploy it now I

00:17:06,580 --> 00:17:13,630
don't have to wait on you I can't really

00:17:08,350 --> 00:17:15,190
do that in that world so so Andrew you

00:17:13,630 --> 00:17:18,130
know brought this up yesterday this idea

00:17:15,190 --> 00:17:19,510
that if you write it you run it if I

00:17:18,130 --> 00:17:21,580
write it and I run it

00:17:19,510 --> 00:17:25,510
that means I'm responsible for deploying

00:17:21,580 --> 00:17:30,400
it so again I'm back to the square one

00:17:25,510 --> 00:17:33,190
of I have tens or hundreds of services

00:17:30,400 --> 00:17:34,960
and I have tens or hundreds of teams

00:17:33,190 --> 00:17:37,180
that are managing those services and

00:17:34,960 --> 00:17:39,670
deploying them and somehow I need to get

00:17:37,180 --> 00:17:41,770
a system out of that but all the tools

00:17:39,670 --> 00:17:44,320
that I've worked with to this point in

00:17:41,770 --> 00:17:48,220
the Cloud Foundry ecosystem aren't

00:17:44,320 --> 00:17:50,940
geared toward that so how do we create a

00:17:48,220 --> 00:17:50,940
composite system

00:17:51,100 --> 00:17:59,450
so Netflix did this and Netflix started

00:17:57,200 --> 00:18:03,100
from exactly the principle that I just

00:17:59,450 --> 00:18:04,940
described will have multiple teams

00:18:03,100 --> 00:18:09,260
multiple teams will own their own

00:18:04,940 --> 00:18:12,110
services owning them from build to

00:18:09,260 --> 00:18:15,470
deploy to run to wear the pager and

00:18:12,110 --> 00:18:17,510
everything in between but they still

00:18:15,470 --> 00:18:19,340
needed a way to compose that into a

00:18:17,510 --> 00:18:21,530
system and they wanted to compose it

00:18:19,340 --> 00:18:23,480
into a system in such a way that any of

00:18:21,530 --> 00:18:27,380
the components can fail at any time and

00:18:23,480 --> 00:18:29,750
the system should keep working and then

00:18:27,380 --> 00:18:31,370
they did us the service of taking these

00:18:29,750 --> 00:18:33,800
components that they use to build a

00:18:31,370 --> 00:18:38,060
composite system battle testing them in

00:18:33,800 --> 00:18:39,890
production you know running you know

00:18:38,060 --> 00:18:41,630
what is it two thirds of the of the

00:18:39,890 --> 00:18:44,870
traffic and the evening on the internet

00:18:41,630 --> 00:18:47,480
through them and then open sourcing that

00:18:44,870 --> 00:18:49,160
stuff so now not only do we to hear

00:18:47,480 --> 00:18:50,720
about how they do things well here's a

00:18:49,160 --> 00:18:55,160
lot of the code that we use to do it to

00:18:50,720 --> 00:18:57,950
so go go use that and and you can go

00:18:55,160 --> 00:18:59,120
grab that and start using the Netflix

00:18:57,950 --> 00:19:00,320
code today but you have to figure out

00:18:59,120 --> 00:19:02,540
how it works you have to figure out how

00:19:00,320 --> 00:19:03,700
to run it and and deploy it and manage

00:19:02,540 --> 00:19:07,340
it sort of on your own

00:19:03,700 --> 00:19:10,150
so in the spring team several months ago

00:19:07,340 --> 00:19:13,670
the idea was had well what if we take

00:19:10,150 --> 00:19:17,060
these components and we take the spring

00:19:13,670 --> 00:19:18,740
programming model that already a huge

00:19:17,060 --> 00:19:20,330
number of Java developers know and

00:19:18,740 --> 00:19:23,000
understand and enjoy and are productive

00:19:20,330 --> 00:19:27,520
with and we apply that programming model

00:19:23,000 --> 00:19:30,380
to the Netflix components such that I

00:19:27,520 --> 00:19:32,840
don't have to relearn how to write my

00:19:30,380 --> 00:19:34,970
app I can just say oh now I need these

00:19:32,840 --> 00:19:37,940
new distributed systems patterns that

00:19:34,970 --> 00:19:40,070
I've learned in my app if I just

00:19:37,940 --> 00:19:42,530
annotate things appropriately and

00:19:40,070 --> 00:19:44,240
configure things appropriately then now

00:19:42,530 --> 00:19:46,670
I can go back to focusing on business

00:19:44,240 --> 00:19:48,680
code again and not worrying about that

00:19:46,670 --> 00:19:52,820
all the distributed system goodness is

00:19:48,680 --> 00:19:55,390
going to work the way that it should so

00:19:52,820 --> 00:19:57,950
we have all of these now not just

00:19:55,390 --> 00:20:00,080
deployment level patterns but

00:19:57,950 --> 00:20:03,320
application and service composition

00:20:00,080 --> 00:20:03,740
patterns it's this idea of deploying and

00:20:03,320 --> 00:20:07,159
running

00:20:03,740 --> 00:20:09,140
code that's kind of what Cloud Foundry

00:20:07,159 --> 00:20:11,539
does but it doesn't really have an

00:20:09,140 --> 00:20:12,140
opinion about what is the code that I'm

00:20:11,539 --> 00:20:14,840
building

00:20:12,140 --> 00:20:17,270
now Cloud Foundry is very capable of why

00:20:14,840 --> 00:20:19,250
it's we could run a composed fault

00:20:17,270 --> 00:20:20,750
tolerant distributed system on top of it

00:20:19,250 --> 00:20:23,179
but Cloud Foundry doesn't really have an

00:20:20,750 --> 00:20:25,159
opinion about what that thing is and so

00:20:23,179 --> 00:20:26,809
what these patterns when we take spring

00:20:25,159 --> 00:20:28,970
cloud and we layer it on top of Cloud

00:20:26,809 --> 00:20:29,950
Foundry do is allow us to do exactly

00:20:28,970 --> 00:20:32,360
that

00:20:29,950 --> 00:20:33,919
so we have several components I'm going

00:20:32,360 --> 00:20:36,020
to run through these quickly I know that

00:20:33,919 --> 00:20:38,270
I'm running out of time already but

00:20:36,020 --> 00:20:40,399
we'll see what happens

00:20:38,270 --> 00:20:42,110
all of this also happens to work on

00:20:40,399 --> 00:20:44,179
lattice and all of my demos are going to

00:20:42,110 --> 00:20:45,830
be on lattice and by the way if I change

00:20:44,179 --> 00:20:47,000
slides really quickly they're already on

00:20:45,830 --> 00:20:48,470
the Internet and I'll tell you where

00:20:47,000 --> 00:20:53,059
they are so if you don't get your

00:20:48,470 --> 00:20:56,740
picture I'm sorry I've seen a couple oh

00:20:53,059 --> 00:21:01,340
he changed you know it's it'll be fine

00:20:56,740 --> 00:21:02,659
so the config server is a way for us to

00:21:01,340 --> 00:21:05,299
put all of our configuration information

00:21:02,659 --> 00:21:07,960
in a central place in this case we chose

00:21:05,299 --> 00:21:10,669
get gets really good at doing what

00:21:07,960 --> 00:21:12,289
versioning things and making an audit

00:21:10,669 --> 00:21:13,490
trail of things and that's something

00:21:12,289 --> 00:21:14,840
that you really like to have for your

00:21:13,490 --> 00:21:16,850
configuration I want to know what

00:21:14,840 --> 00:21:18,730
changed I want to know who changed it

00:21:16,850 --> 00:21:20,779
when did it change and I want to know

00:21:18,730 --> 00:21:22,399
maybe a reason for that

00:21:20,779 --> 00:21:24,110
and gets very good at that so why

00:21:22,399 --> 00:21:25,940
duplicate it let's just put a service in

00:21:24,110 --> 00:21:28,940
front of it that can distribute that to

00:21:25,940 --> 00:21:30,590
applications so we have a REST API and

00:21:28,940 --> 00:21:32,750
the config server and then we have a

00:21:30,590 --> 00:21:34,370
client binding inside of a spring

00:21:32,750 --> 00:21:36,500
application that knows how to take that

00:21:34,370 --> 00:21:40,279
information reconcile it with any

00:21:36,500 --> 00:21:43,520
configuration that's local and create

00:21:40,279 --> 00:21:46,700
something that's consistently configured

00:21:43,520 --> 00:21:49,520
across all of the system so now in my

00:21:46,700 --> 00:21:50,840
git repository I have some description

00:21:49,520 --> 00:21:53,090
of what the configuration for the

00:21:50,840 --> 00:21:55,159
composite should be and then I can

00:21:53,090 --> 00:21:57,740
distribute that appropriately to all the

00:21:55,159 --> 00:22:00,740
individual pieces but then I want to

00:21:57,740 --> 00:22:02,299
update that in real time I don't want to

00:22:00,740 --> 00:22:04,179
go through a deployment what I'd really

00:22:02,299 --> 00:22:06,440
like to do is say this piece of

00:22:04,179 --> 00:22:08,390
configuration should change and that's

00:22:06,440 --> 00:22:10,669
going to affect these small components

00:22:08,390 --> 00:22:11,390
in these apps I'd like that to happen

00:22:10,669 --> 00:22:14,840
right now

00:22:11,390 --> 00:22:17,120
and so we add a component called the

00:22:14,840 --> 00:22:18,440
cloud bus to make that happen

00:22:17,120 --> 00:22:19,820
the cloud bus is just a management

00:22:18,440 --> 00:22:24,350
backplane that happens to be backed

00:22:19,820 --> 00:22:25,730
right now by RabbitMQ and when I send a

00:22:24,350 --> 00:22:28,159
refresh event to something that

00:22:25,730 --> 00:22:30,350
participates in that bus what it will do

00:22:28,159 --> 00:22:32,480
is send a message to the bus so that all

00:22:30,350 --> 00:22:35,149
the other participating applications

00:22:32,480 --> 00:22:39,289
receive it so let's see if we can make

00:22:35,149 --> 00:22:43,490
this work very quickly so you'll notice

00:22:39,289 --> 00:22:47,210
that I have a bunch of stuff oops I just

00:22:43,490 --> 00:22:49,879
turned off mirroring again there we go a

00:22:47,210 --> 00:22:54,999
bunch of stuff running on my lattice

00:22:49,879 --> 00:22:58,519
cluster here let's make that big and

00:22:54,999 --> 00:22:59,570
here's my config server and the

00:22:58,519 --> 00:23:01,309
important thing that I want you to

00:22:59,570 --> 00:23:03,139
notice is that there is a greeting

00:23:01,309 --> 00:23:04,539
property in here that happens to say

00:23:03,139 --> 00:23:06,700
right now let's make sure that that's

00:23:04,539 --> 00:23:09,230
up-to-date okay right now it says howdy

00:23:06,700 --> 00:23:12,619
because I'm from the south and I need to

00:23:09,230 --> 00:23:15,740
do that and I have another application

00:23:12,619 --> 00:23:19,879
here that says howdy world right now so

00:23:15,740 --> 00:23:26,259
I want to do a couple of things first of

00:23:19,879 --> 00:23:26,259
all let's make this big as well

00:23:29,130 --> 00:23:34,720
you will see that I have only one

00:23:32,140 --> 00:23:36,760
instance of this app that we're going to

00:23:34,720 --> 00:23:43,210
show off let's go ahead and scale that

00:23:36,760 --> 00:23:47,049
up to five instances and then let's grab

00:23:43,210 --> 00:23:50,320
the logs for that once it's done while

00:23:47,049 --> 00:23:52,210
that scale is happening wrong file let's

00:23:50,320 --> 00:23:56,520
go into demo dot Yamma let's change that

00:23:52,210 --> 00:24:00,030
greeting well what do we want to say

00:23:56,520 --> 00:24:02,190
hola okay we'll make it speak Spanish

00:24:00,030 --> 00:24:08,429
sounds good

00:24:02,190 --> 00:24:08,429
let's commit that to our repository

00:24:12,500 --> 00:24:18,320
so that's out there if we go back to our

00:24:16,130 --> 00:24:22,400
configuration server we will see that

00:24:18,320 --> 00:24:25,880
the greeting has in fact updated to say

00:24:22,400 --> 00:24:28,039
hola but when we go to our application

00:24:25,880 --> 00:24:30,200
it still says howdy so we've got another

00:24:28,039 --> 00:24:40,280
step and that is that we need to send a

00:24:30,200 --> 00:24:44,059
refresh event so if we say LTC logs dist

00:24:40,280 --> 00:24:53,620
config and what I'm going to do is send

00:24:44,059 --> 00:24:53,620
a post event to this route bus refresh

00:24:55,450 --> 00:25:01,270
not bush I make that mistake every time

00:25:01,659 --> 00:25:10,490
there we go so what you just saw and all

00:25:07,520 --> 00:25:14,360
those log events was each app received

00:25:10,490 --> 00:25:18,380
and here's app number four says received

00:25:14,360 --> 00:25:21,200
remote refresh request the result is

00:25:18,380 --> 00:25:23,510
that it now doesn't matter which of

00:25:21,200 --> 00:25:25,490
these apps I get routed to I now have

00:25:23,510 --> 00:25:30,890
that change distributed across the

00:25:25,490 --> 00:25:33,740
cluster okay let's keep moving so now we

00:25:30,890 --> 00:25:35,659
want to find out where things are Eureka

00:25:33,740 --> 00:25:38,570
is a service registry that allows us to

00:25:35,659 --> 00:25:41,450
do that and very simple application

00:25:38,570 --> 00:25:43,220
registers consumer looks up what it

00:25:41,450 --> 00:25:47,659
wants to find and is able to connect to

00:25:43,220 --> 00:25:49,820
it directly we have Eureka here and

00:25:47,659 --> 00:25:51,289
you'll see that I have a bunch of stuff

00:25:49,820 --> 00:25:53,150
registered right now and if i refresh

00:25:51,289 --> 00:25:56,750
that you'll see that I have the five

00:25:53,150 --> 00:26:00,710
instances of the producer going now we

00:25:56,750 --> 00:26:02,210
had a problem here in that you can argue

00:26:00,710 --> 00:26:03,679
whether it's a problem or not but we

00:26:02,210 --> 00:26:07,010
have this thing called the router and

00:26:03,679 --> 00:26:08,929
the router wants all the traffic to go

00:26:07,010 --> 00:26:10,640
through that we don't have these things

00:26:08,929 --> 00:26:12,980
talking to each other so this idea of

00:26:10,640 --> 00:26:15,080
consumer talking straight to producer

00:26:12,980 --> 00:26:17,419
doesn't really happen and what we end up

00:26:15,080 --> 00:26:19,850
doing is registering the route for the

00:26:17,419 --> 00:26:21,919
producer in Eureka and then we can do

00:26:19,850 --> 00:26:24,289
this trip from ribbon that's capable

00:26:21,919 --> 00:26:26,300
fully of load balancing what's going to

00:26:24,289 --> 00:26:27,650
load balance me to H a proxy or whatever

00:26:26,300 --> 00:26:29,540
load balancer we have in front of this

00:26:27,650 --> 00:26:30,580
then through the go router and then down

00:26:29,540 --> 00:26:34,310
to the producer

00:26:30,580 --> 00:26:35,450
well we added in CF release 195 some

00:26:34,310 --> 00:26:37,130
environment variables that you

00:26:35,450 --> 00:26:39,260
automatically get in your app

00:26:37,130 --> 00:26:41,960
environment that tell you what your DEA

00:26:39,260 --> 00:26:45,320
IP and port are there's an equivalent

00:26:41,960 --> 00:26:47,660
for Diego for cell IP and port and then

00:26:45,320 --> 00:26:50,090
also in 204 the ability to allow host

00:26:47,660 --> 00:26:52,100
access on the DEA so if I'm in a

00:26:50,090 --> 00:26:54,530
container I can actually talk to another

00:26:52,100 --> 00:26:58,790
container on the same DEA or cell that

00:26:54,530 --> 00:27:00,980
I'm living on so after 204 were able to

00:26:58,790 --> 00:27:03,440
do this and lattis has an equivalent

00:27:00,980 --> 00:27:05,960
setup that allows consumers to talk

00:27:03,440 --> 00:27:07,610
straight to producers and this may end

00:27:05,960 --> 00:27:13,250
up being the last demo that we're able

00:27:07,610 --> 00:27:16,390
to get to but we will see so let's do an

00:27:13,250 --> 00:27:19,370
LTC list again and let's take our

00:27:16,390 --> 00:27:21,530
producer and one thing I want you to

00:27:19,370 --> 00:27:23,540
note about the producer you see there's

00:27:21,530 --> 00:27:26,840
no route of sign so I can't even talk to

00:27:23,540 --> 00:27:29,450
this producer outside of the VPC in

00:27:26,840 --> 00:27:31,160
which this lattice cluster is living but

00:27:29,450 --> 00:27:33,440
I do have a consumer service and the

00:27:31,160 --> 00:27:36,980
consumer is basically just going to tell

00:27:33,440 --> 00:27:39,110
me exactly what that what that producer

00:27:36,980 --> 00:27:41,330
is doing which in this case is producing

00:27:39,110 --> 00:27:43,670
an increasing counter sequence so I only

00:27:41,330 --> 00:27:47,570
have one we keep going up a number every

00:27:43,670 --> 00:27:57,100
time let's scale the producer out to say

00:27:47,570 --> 00:27:57,100
10 instances and watch so start up

00:28:04,960 --> 00:28:09,580
so we're filling up our cluster nicely

00:28:16,669 --> 00:28:20,369
so once all these start up I want you to

00:28:19,019 --> 00:28:21,869
pay attention to the logs right now

00:28:20,369 --> 00:28:27,029
they're not that interesting just a

00:28:21,869 --> 00:28:29,450
bunch of startup stuff very close to

00:28:27,029 --> 00:28:29,450
done here

00:28:38,040 --> 00:28:51,130
maybe I should have done five I'm

00:28:43,840 --> 00:28:53,080
flirting with the clock well we should

00:28:51,130 --> 00:28:54,550
start to see some of what we want so

00:28:53,080 --> 00:28:57,190
some of these are up and registers so

00:28:54,550 --> 00:29:02,170
you see I've got right now four four

00:28:57,190 --> 00:29:04,180
instances of the producer up so as

00:29:02,170 --> 00:29:09,070
that's happening now what I should see

00:29:04,180 --> 00:29:12,310
is as I'm hitting this you'll see that

00:29:09,070 --> 00:29:14,620
I'm actually load balancing across the

00:29:12,310 --> 00:29:17,320
instances of the producer but if you

00:29:14,620 --> 00:29:19,960
were to look in the logs and actually

00:29:17,320 --> 00:29:23,020
now we're in a good spot you look at the

00:29:19,960 --> 00:29:24,880
logs you see that we are in fact hitting

00:29:23,020 --> 00:29:26,230
the producer app but you don't see any

00:29:24,880 --> 00:29:28,360
router logs we're not going through the

00:29:26,230 --> 00:29:30,760
router at all so now we're able to do

00:29:28,360 --> 00:29:34,300
client-side load balancing inside the

00:29:30,760 --> 00:29:38,020
app so I'm gonna have to get out of the

00:29:34,300 --> 00:29:40,600
way of the next presenter but very

00:29:38,020 --> 00:29:42,610
quickly there are some other patterns I

00:29:40,600 --> 00:29:45,070
wasn't able to show you circuit breakers

00:29:42,610 --> 00:29:46,780
but circuit breaker is a state machine

00:29:45,070 --> 00:29:49,420
that protects you from those cascading

00:29:46,780 --> 00:29:51,480
failures and then Zul is a component

00:29:49,420 --> 00:29:53,860
that allows me to do intelligent routing

00:29:51,480 --> 00:29:56,020
you can learn more about those on the

00:29:53,860 --> 00:29:57,490
Netflix website we have a lot of other

00:29:56,020 --> 00:29:59,110
things that are coming we want to be

00:29:57,490 --> 00:30:02,860
able to support alternative stacks like

00:29:59,110 --> 00:30:04,720
console zookeeper Etsy d.j rugged is an

00:30:02,860 --> 00:30:06,660
interesting circuit breaker library that

00:30:04,720 --> 00:30:08,920
comcast is produced we want to do

00:30:06,660 --> 00:30:11,550
distributed request tracing in the vein

00:30:08,920 --> 00:30:14,590
of what dapper ins if can are able to do

00:30:11,550 --> 00:30:16,990
leader election locks state machine

00:30:14,590 --> 00:30:18,880
stateful patterns we really want to

00:30:16,990 --> 00:30:20,920
improve the developer workflow for micro

00:30:18,880 --> 00:30:21,820
services it's not great today and then

00:30:20,920 --> 00:30:24,010
we also want to do a lot around

00:30:21,820 --> 00:30:26,770
switching patterns if you want to learn

00:30:24,010 --> 00:30:28,570
more I put a bunch of links the most

00:30:26,770 --> 00:30:31,660
important link is you can get to this

00:30:28,570 --> 00:30:34,480
talk on github and download a PDF it's

00:30:31,660 --> 00:30:36,400
also on SlideShare and then all of the

00:30:34,480 --> 00:30:39,100
demos that I was able to show are in

00:30:36,400 --> 00:30:40,870
that second repository so like I said

00:30:39,100 --> 00:30:42,820
right after the talk I will tweet the

00:30:40,870 --> 00:30:45,820
links to all these things so that you

00:30:42,820 --> 00:30:46,960
can go get the slides and thank you very

00:30:45,820 --> 00:30:53,459
much

00:30:46,960 --> 00:30:53,459

YouTube URL: https://www.youtube.com/watch?v=DBIm6gDpSNg


