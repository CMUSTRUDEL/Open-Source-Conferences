Title: The Route To Rootless Containers - Claudia Beresford & Ed King, Pivotal
Publication date: 2018-10-10
Playlist: Cloud Foundry Summit Europe 2018
Description: 
	The Route To Rootless Containers - Claudia Beresford & Ed King, Pivotal

Rootless containers are a new and exciting development in the container community, offering the ability to create and manage containers as a completely unprivileged, non-root user. This is appealing both in terms of security, as well as in making container-based workloads accessible to a much wider audience.

During this presentation, Claudia and Ed will share their team's learnings from the journey to adopting rootless containers in production for a large multi-tenant PaaS (Cloud Foundry). The talk contains a technical overview of rootless containers - what they are, how they work and how to enable them in runC as well as a discussion of the limitations of rootless containers and how we overcame those limitations. If youâ€™re interested in using rootless containers in production, this talk is for you!

https://cfseu18.sched.com/event/FRyv/the-route-to-rootless-containers-claudia-beresford-ed-king-pivotal
Captions: 
	00:00:00,030 --> 00:00:04,770
all right hi welcome to this talk about

00:00:03,000 --> 00:00:07,740
our team's journey to realize containers

00:00:04,770 --> 00:00:09,389
my name is Claudia this is ed and we

00:00:07,740 --> 00:00:10,950
work at pivotal on the team which

00:00:09,389 --> 00:00:14,490
provides the containers for cloud

00:00:10,950 --> 00:00:17,070
foundry before we get started I do want

00:00:14,490 --> 00:00:19,470
to mention one thing so I gave this talk

00:00:17,070 --> 00:00:20,279
a month ago in the UK and people

00:00:19,470 --> 00:00:22,380
understood what I'm about to say

00:00:20,279 --> 00:00:23,580
completely but when Ed and other

00:00:22,380 --> 00:00:26,279
colleagues of virgin does talk in the

00:00:23,580 --> 00:00:27,630
States and elsewhere there's a lot of

00:00:26,279 --> 00:00:31,320
problem with the pronunciation of this

00:00:27,630 --> 00:00:33,680
talk so we get going I want to lay the

00:00:31,320 --> 00:00:37,620
rest we are assuming the correct

00:00:33,680 --> 00:00:41,989
pronunciation of the word route so it is

00:00:37,620 --> 00:00:41,989
the route to route lists not the route

00:00:42,290 --> 00:00:50,789
nothing else all right

00:00:47,520 --> 00:00:52,079
so now we can get going all right so

00:00:50,789 --> 00:00:53,520
you'll hear because you'll know more

00:00:52,079 --> 00:00:56,760
about containers that's cool we love

00:00:53,520 --> 00:00:58,050
containers they are awesome and you're

00:00:56,760 --> 00:00:59,340
in luck because today you're not just

00:00:58,050 --> 00:01:00,989
gonna hear about containers in general

00:00:59,340 --> 00:01:04,229
you're also gonna hear about rootless

00:01:00,989 --> 00:01:05,549
containers which is very cool some of

00:01:04,229 --> 00:01:06,990
you less familiar with how containers

00:01:05,549 --> 00:01:08,729
are built may be wondering why we

00:01:06,990 --> 00:01:10,590
actually won't use containers those of

00:01:08,729 --> 00:01:12,540
you who run docker with the- PFLAG that

00:01:10,590 --> 00:01:13,950
privilege will probably be whirring oh I

00:01:12,540 --> 00:01:15,659
don't lose that privilege it's so

00:01:13,950 --> 00:01:17,220
powerful lets me do so much but you've

00:01:15,659 --> 00:01:18,720
answer your own question there it's very

00:01:17,220 --> 00:01:20,430
powerful which is exactly why on a

00:01:18,720 --> 00:01:29,009
multi-talented system like I've and you

00:01:20,430 --> 00:01:31,049
we do not want root full containers so

00:01:29,009 --> 00:01:32,880
yeah but just just before we start

00:01:31,049 --> 00:01:34,079
talking about rootless containers we

00:01:32,880 --> 00:01:36,540
first need to talk a little bit about

00:01:34,079 --> 00:01:38,100
containers and then before we talk about

00:01:36,540 --> 00:01:41,460
containers we first need to talk a

00:01:38,100 --> 00:01:42,899
little bit about cloud foundry and it's

00:01:41,460 --> 00:01:45,240
probably worth mentioning that for this

00:01:42,899 --> 00:01:47,340
talk we're mainly focusing on the cloud

00:01:45,240 --> 00:01:49,649
foundry application runtime as opposed

00:01:47,340 --> 00:01:51,360
to the container runtime but actually

00:01:49,649 --> 00:01:53,280
like a lot of the topics they stick this

00:01:51,360 --> 00:01:54,390
all relevant across both it's just that

00:01:53,280 --> 00:01:56,250
if we're referring to cloud foundry

00:01:54,390 --> 00:02:00,540
we're kind of specifically talking about

00:01:56,250 --> 00:02:02,939
the application runtime here so what is

00:02:00,540 --> 00:02:04,799
cloud foundry I'm going to assume that

00:02:02,939 --> 00:02:07,110
we're at least partially familiar with

00:02:04,799 --> 00:02:09,209
what this is given where we are but just

00:02:07,110 --> 00:02:11,790
to sort of set the scene foundry is an

00:02:09,209 --> 00:02:13,620
open source platform as a service so it

00:02:11,790 --> 00:02:15,599
allows developers to take their code

00:02:13,620 --> 00:02:18,870
and push it into the cloud and Cloud

00:02:15,599 --> 00:02:20,190
Foundry does everything else for you and

00:02:18,870 --> 00:02:21,840
because that's so nice and that's so

00:02:20,190 --> 00:02:24,230
amazing Cloud Foundry has become pretty

00:02:21,840 --> 00:02:27,629
popular particularly in the enterprise

00:02:24,230 --> 00:02:29,910
and especially with a lot of banks banks

00:02:27,629 --> 00:02:31,080
are pretty big on Cloud Foundry and so

00:02:29,910 --> 00:02:34,730
with this in mind we have to make sure

00:02:31,080 --> 00:02:36,629
that we are really focused on security

00:02:34,730 --> 00:02:39,000
so what does that look like what does

00:02:36,629 --> 00:02:40,080
that mean for Cloud Foundry I don't

00:02:39,000 --> 00:02:42,090
think there's really three things here

00:02:40,080 --> 00:02:44,430
so the first one is that Cloud Foundry

00:02:42,090 --> 00:02:47,040
is a public platform which means that

00:02:44,430 --> 00:02:48,780
anyone can push anything the second one

00:02:47,040 --> 00:02:52,079
is that Cloud Foundry has a multi-tenant

00:02:48,780 --> 00:02:54,299
platform which means that user s well

00:02:52,079 --> 00:02:57,049
behaved nice code may be running on the

00:02:54,299 --> 00:02:59,400
same VM as user B's malicious nasty code

00:02:57,049 --> 00:03:01,890
and then third one is that Cloud Foundry

00:02:59,400 --> 00:03:03,150
allows us to push docker images and this

00:03:01,890 --> 00:03:04,739
is kind of this is like really scary

00:03:03,150 --> 00:03:06,930
because these days it's so easy just to

00:03:04,739 --> 00:03:08,910
package up anything any sort of hack or

00:03:06,930 --> 00:03:11,519
vulnerability into a nice pretty docker

00:03:08,910 --> 00:03:12,209
image push that into the cloud and and

00:03:11,519 --> 00:03:14,750
away you go

00:03:12,209 --> 00:03:17,250
and so we look at this and we think like

00:03:14,750 --> 00:03:20,250
mmm that's that's pretty concerning

00:03:17,250 --> 00:03:21,810
actually it's actually like a worst case

00:03:20,250 --> 00:03:23,700
scenario if you think about it

00:03:21,810 --> 00:03:25,410
completely public completely

00:03:23,700 --> 00:03:26,459
multi-tenant and we allow you to push

00:03:25,410 --> 00:03:30,209
whatever you want

00:03:26,459 --> 00:03:32,099
that's pretty terrifying and so it means

00:03:30,209 --> 00:03:33,810
that we have to make sure we are on the

00:03:32,099 --> 00:03:36,389
absolute forefront and the bleeding edge

00:03:33,810 --> 00:03:40,799
of container security we have to be

00:03:36,389 --> 00:03:43,470
prepared for the worst so how do

00:03:40,799 --> 00:03:45,109
containers fit into this what even is a

00:03:43,470 --> 00:03:46,799
container let's let's start with that

00:03:45,109 --> 00:03:49,049
and the first thing to know about

00:03:46,799 --> 00:03:53,549
containers is that there's no such thing

00:03:49,049 --> 00:03:54,120
as containers containers are rely what I

00:03:53,549 --> 00:03:55,980
mean by this

00:03:54,120 --> 00:03:57,680
of course containers are real all of our

00:03:55,980 --> 00:04:00,599
applications are running in containers

00:03:57,680 --> 00:04:03,060
so what I really mean is that containers

00:04:00,599 --> 00:04:04,889
are just Linux processes there's nothing

00:04:03,060 --> 00:04:07,590
magic about them they're just processes

00:04:04,889 --> 00:04:09,239
running on a VM somewhere and the only

00:04:07,590 --> 00:04:11,849
thing that differentiates them from any

00:04:09,239 --> 00:04:14,880
normal process is the fact that these

00:04:11,849 --> 00:04:16,650
containers are isolated they have layers

00:04:14,880 --> 00:04:19,769
of isolation around them so that they

00:04:16,650 --> 00:04:21,299
are isolated from each other as well as

00:04:19,769 --> 00:04:24,330
any other processes running on the VM

00:04:21,299 --> 00:04:27,979
and it's that isolation that helps us

00:04:24,330 --> 00:04:27,979
here with the security aspect of

00:04:28,240 --> 00:04:33,650
so how does this work well we use some

00:04:31,160 --> 00:04:36,229
kernel technologies namely the Linux

00:04:33,650 --> 00:04:38,449
namespaces which provide isolation of

00:04:36,229 --> 00:04:41,720
global system resources so things like

00:04:38,449 --> 00:04:45,830
pits mount points etc etc as well as C

00:04:41,720 --> 00:04:48,139
groups which provide like limitation of

00:04:45,830 --> 00:04:51,830
physical resources so things like CPU

00:04:48,139 --> 00:04:54,229
and memory and there is a third one that

00:04:51,830 --> 00:04:56,270
we have to especially think about given

00:04:54,229 --> 00:04:58,460
cloud foundries multi-tenant nature

00:04:56,270 --> 00:04:59,960
which the disk waiters so we need to

00:04:58,460 --> 00:05:02,210
make sure their applications aren't able

00:04:59,960 --> 00:05:03,979
to just write to disk and fill that up

00:05:02,210 --> 00:05:05,840
and sort of provide an attack surface

00:05:03,979 --> 00:05:10,669
like that but we're going to come back

00:05:05,840 --> 00:05:12,229
to that a bit later on so that's kind of

00:05:10,669 --> 00:05:13,460
the intro that's that's why we care

00:05:12,229 --> 00:05:16,820
about this this is why we think it's

00:05:13,460 --> 00:05:18,110
important what's coming up so to begin

00:05:16,820 --> 00:05:19,910
with we're going to take a bit of a

00:05:18,110 --> 00:05:21,590
deeper dive into exactly what makes a

00:05:19,910 --> 00:05:23,660
container a container so we're going to

00:05:21,590 --> 00:05:25,970
look at namespaces see groups as well as

00:05:23,660 --> 00:05:27,740
dependencies then we're going to talk a

00:05:25,970 --> 00:05:29,750
little bit about some extra security

00:05:27,740 --> 00:05:31,639
layers that we apply on top of that to

00:05:29,750 --> 00:05:33,949
make sure our containers are as secure

00:05:31,639 --> 00:05:35,389
as they possibly can be and then finally

00:05:33,949 --> 00:05:36,979
we'll get to rootless containers what

00:05:35,389 --> 00:05:42,740
they are and how they fit into all of

00:05:36,979 --> 00:05:46,669
this so Claudia what makes a container a

00:05:42,740 --> 00:05:49,610
container thank you a question let's

00:05:46,669 --> 00:05:51,620
start with namespaces so new faces are a

00:05:49,610 --> 00:05:54,080
Linux kernel feature which allow you to

00:05:51,620 --> 00:05:56,300
isolate global system resources for a

00:05:54,080 --> 00:05:58,639
process so these are things like mount

00:05:56,300 --> 00:05:59,479
mount points network devices and process

00:05:58,639 --> 00:06:01,669
ideas such as

00:05:59,479 --> 00:06:04,190
as I said it's basically about creating

00:06:01,669 --> 00:06:05,690
illusion when you put a process inside a

00:06:04,190 --> 00:06:08,000
new space you can make it think it has

00:06:05,690 --> 00:06:10,909
exclusive access and sole control of

00:06:08,000 --> 00:06:13,009
those resources so there are seven new

00:06:10,909 --> 00:06:16,070
spaces in linux right now these are

00:06:13,009 --> 00:06:17,960
mount IPC pit net UTSC group and user

00:06:16,070 --> 00:06:19,490
and this last one the user name space is

00:06:17,960 --> 00:06:21,680
particularly relevant when it comes to

00:06:19,490 --> 00:06:23,180
rootless containers so we're going to

00:06:21,680 --> 00:06:25,490
come back to that in much more detail

00:06:23,180 --> 00:06:27,590
later but for now let's just pick a

00:06:25,490 --> 00:06:29,389
couple which are used to create just

00:06:27,590 --> 00:06:31,310
containers in general and those are the

00:06:29,389 --> 00:06:34,430
pit and mountainy spaces so let's have a

00:06:31,310 --> 00:06:36,800
look at how they work let me move my

00:06:34,430 --> 00:06:38,650
mouse yeah

00:06:36,800 --> 00:06:41,260
so it's up with the pin database

00:06:38,650 --> 00:06:44,020
so with the pit namespace to processes

00:06:41,260 --> 00:06:49,060
running on the same VM can have the same

00:06:44,020 --> 00:06:50,860
process ID in different namespaces it's

00:06:49,060 --> 00:06:52,150
what it appears to be for the process

00:06:50,860 --> 00:06:54,280
inside the namespace when in reality

00:06:52,150 --> 00:06:56,470
that processes the map to a different

00:06:54,280 --> 00:06:59,050
pit outside these namespace so if you

00:06:56,470 --> 00:06:59,800
take this awesome diagram here which I

00:06:59,050 --> 00:07:01,510
drew myself

00:06:59,800 --> 00:07:03,220
you got to child in these places they're

00:07:01,510 --> 00:07:04,510
shown namespace one namespace to and

00:07:03,220 --> 00:07:05,710
they both think they are running pit one

00:07:04,510 --> 00:07:07,360
says you know when you boot up your

00:07:05,710 --> 00:07:09,010
machine pit one is the first process

00:07:07,360 --> 00:07:10,180
that rather runs and does everything and

00:07:09,010 --> 00:07:11,740
all the other processes are there

00:07:10,180 --> 00:07:13,720
children grandchildren etc of that

00:07:11,740 --> 00:07:16,270
process so it's the big dog is God it's

00:07:13,720 --> 00:07:17,919
the God process but the parenting space

00:07:16,270 --> 00:07:21,310
knows that these are maps to other

00:07:17,919 --> 00:07:22,600
processes inside the host the child's

00:07:21,310 --> 00:07:23,979
these places have no idea they have a

00:07:22,600 --> 00:07:25,930
parent none at all because pit main

00:07:23,979 --> 00:07:27,160
space is a top-down the parent has clear

00:07:25,930 --> 00:07:29,050
view down into its children its

00:07:27,160 --> 00:07:30,580
grandchildren everything the child main

00:07:29,050 --> 00:07:31,690
spaces can see its children yes but

00:07:30,580 --> 00:07:32,380
doesn't know how the parent doesn't know

00:07:31,690 --> 00:07:34,479
it has siblings

00:07:32,380 --> 00:07:39,130
it just has only visible control over

00:07:34,479 --> 00:07:40,030
its own given world now all right so the

00:07:39,130 --> 00:07:42,220
next we're gonna have look at is the

00:07:40,030 --> 00:07:43,210
Mountaineers base so processes which

00:07:42,220 --> 00:07:45,010
have been put in the amount of space

00:07:43,210 --> 00:07:47,440
have a different view of the mountable

00:07:45,010 --> 00:07:48,850
when we use pivot routes at the same

00:07:47,440 --> 00:07:51,550
time which I'm I'm going to come back to

00:07:48,850 --> 00:07:52,419
in a minute or two that process will see

00:07:51,550 --> 00:07:54,580
something different

00:07:52,419 --> 00:08:00,250
mounted as slash so mountain its route

00:07:54,580 --> 00:08:02,830
FS you'll notice here that I've done DF

00:08:00,250 --> 00:08:04,030
- and print type to see the file system

00:08:02,830 --> 00:08:05,440
mounts I just did that because it gives

00:08:04,030 --> 00:08:07,060
you a pretty outfit for slides in

00:08:05,440 --> 00:08:09,460
reality you probably do like cat prog

00:08:07,060 --> 00:08:12,430
kids mount info or mount or anything

00:08:09,460 --> 00:08:14,590
like that see the mountain table if you

00:08:12,430 --> 00:08:16,060
want to see more about what name space

00:08:14,590 --> 00:08:18,850
your kid is running in you would do your

00:08:16,060 --> 00:08:20,919
LS - L proc Pitt NS and those links

00:08:18,850 --> 00:08:22,419
would give you the names base IDs for

00:08:20,919 --> 00:08:27,610
the namespaces that your process is

00:08:22,419 --> 00:08:29,680
running in alright so if namespaces

00:08:27,610 --> 00:08:31,630
alter a processes view of the system and

00:08:29,680 --> 00:08:33,640
its resources then see groups can

00:08:31,630 --> 00:08:36,279
actually be used to enforce certain

00:08:33,640 --> 00:08:37,510
power over physical resources as already

00:08:36,279 --> 00:08:40,870
mentioned there's are things like memory

00:08:37,510 --> 00:08:43,839
and CPU control groups are again the

00:08:40,870 --> 00:08:44,920
next kernel feature and so every time we

00:08:43,839 --> 00:08:47,680
create a container we will put that

00:08:44,920 --> 00:08:49,180
container process inside a c group and

00:08:47,680 --> 00:08:51,950
then apply limits to that c group so

00:08:49,180 --> 00:08:53,630
that it can't access more cpu than it

00:08:51,950 --> 00:08:58,910
should ruin the experience for the

00:08:53,630 --> 00:09:00,139
people as I've said the other thing we

00:08:58,910 --> 00:09:02,000
care about limiting is disk quota and

00:09:00,139 --> 00:09:03,290
this caused us a lot of problem so we're

00:09:02,000 --> 00:09:08,449
going to come back to the again in more

00:09:03,290 --> 00:09:10,040
detail in a minute so the last thing

00:09:08,449 --> 00:09:11,779
which makes a container the thing we all

00:09:10,040 --> 00:09:13,699
very familiar with them we love and

00:09:11,779 --> 00:09:15,110
different from a standard learners

00:09:13,699 --> 00:09:17,240
container is the encapsulation of

00:09:15,110 --> 00:09:18,769
dependencies so if years ago docker

00:09:17,240 --> 00:09:20,870
figured out a way to encapsulate

00:09:18,769 --> 00:09:22,970
dependencies into shippable units within

00:09:20,870 --> 00:09:24,709
things called images and they figured

00:09:22,970 --> 00:09:25,820
out how to do this efficiently these

00:09:24,709 --> 00:09:27,920
images could then be moved around

00:09:25,820 --> 00:09:29,269
between machines and this meant that we

00:09:27,920 --> 00:09:31,100
could run many different containers

00:09:29,269 --> 00:09:32,720
based on these identical blueprints

00:09:31,100 --> 00:09:34,430
which underneath we using the same Linux

00:09:32,720 --> 00:09:36,860
primitives and mostly we're sharing

00:09:34,430 --> 00:09:38,420
dependencies and this is the key

00:09:36,860 --> 00:09:40,730
difference between Linux containers

00:09:38,420 --> 00:09:42,730
which have existed for a while and the

00:09:40,730 --> 00:09:45,500
containers which we talk about today

00:09:42,730 --> 00:09:47,329
isolation by itself gives you a Linux

00:09:45,500 --> 00:09:49,220
container but isolation along with the

00:09:47,329 --> 00:09:54,260
encapsulation of dependencies gives you

00:09:49,220 --> 00:09:55,639
a container container so let's look at

00:09:54,260 --> 00:09:59,930
how the dependencies and encapsulation

00:09:55,639 --> 00:10:01,160
works do this we use a layered file

00:09:59,930 --> 00:10:02,149
system and pivot root which is what I

00:10:01,160 --> 00:10:04,519
mentioned earlier when we were talking

00:10:02,149 --> 00:10:07,220
about the mounting space let's start

00:10:04,519 --> 00:10:08,899
with pivot root so peer roots is system

00:10:07,220 --> 00:10:12,230
cool which changes what a process sees

00:10:08,899 --> 00:10:13,279
when it looks at its root directory so

00:10:12,230 --> 00:10:15,380
we're servicing the hosts file hierarchy

00:10:13,279 --> 00:10:18,800
we can tell the container process to see

00:10:15,380 --> 00:10:20,600
somewhere else as its root filesystem so

00:10:18,800 --> 00:10:23,120
say for example you had a program called

00:10:20,600 --> 00:10:24,920
rondo it wrote it asks a question what's

00:10:23,120 --> 00:10:27,470
in slash what's in my root of s and what

00:10:24,920 --> 00:10:29,480
comes back is whatever is on the host

00:10:27,470 --> 00:10:31,880
something boring because it's not a

00:10:29,480 --> 00:10:34,310
contain it contains a cool but then the

00:10:31,880 --> 00:10:36,740
next time it runs what's in slurp slurp

00:10:34,310 --> 00:10:38,240
/ sorry defconn has talked / we can do

00:10:36,740 --> 00:10:39,410
pivot root with a path to somewhere else

00:10:38,240 --> 00:10:41,720
and this time what come back is

00:10:39,410 --> 00:10:43,490
something much more exciting busybox

00:10:41,720 --> 00:10:46,279
its container root filesystem much more

00:10:43,490 --> 00:10:49,010
exciting but we can't just point to any

00:10:46,279 --> 00:10:49,910
old path what we actually could but it

00:10:49,010 --> 00:10:51,380
wouldn't be very useful and this

00:10:49,910 --> 00:10:52,610
actually does what a root filesystem is

00:10:51,380 --> 00:10:55,010
supposed to do so we have to give it an

00:10:52,610 --> 00:10:58,130
actual root filesystem and we do that

00:10:55,010 --> 00:11:00,430
where that layered file systems so in

00:10:58,130 --> 00:11:02,930
the past

00:11:00,430 --> 00:11:04,910
yes of course very so this is your job

00:11:02,930 --> 00:11:10,850
team members this is your job

00:11:04,910 --> 00:11:20,510
shout you know this I'm very sorry I do

00:11:10,850 --> 00:11:22,779
sorry alright alright so it's like I try

00:11:20,510 --> 00:11:25,640
not to count seconds in my head

00:11:22,779 --> 00:11:29,120
so this is where layered file systems

00:11:25,640 --> 00:11:30,860
come in so in the past the way that we

00:11:29,120 --> 00:11:31,370
and by we I mean the community as a

00:11:30,860 --> 00:11:33,709
whole

00:11:31,370 --> 00:11:35,990
used to handled dependencies was we

00:11:33,709 --> 00:11:38,899
would package everything up into an ami

00:11:35,990 --> 00:11:40,820
or a VMDK or whatever and that was fine

00:11:38,899 --> 00:11:43,160
if you didn't care about things like

00:11:40,820 --> 00:11:46,070
boot speed and filling up your disk with

00:11:43,160 --> 00:11:48,830
junk so imagine you had a container

00:11:46,070 --> 00:11:50,990
which needed Ubuntu as part of its

00:11:48,830 --> 00:11:51,860
dependency package so that container

00:11:50,990 --> 00:11:54,709
would come along you would download

00:11:51,860 --> 00:11:56,240
Ubuntu cool another container comes

00:11:54,709 --> 00:11:58,279
along and they're like oh hi I also

00:11:56,240 --> 00:12:00,350
won't even - so you download that Ubuntu

00:11:58,279 --> 00:12:02,120
again and then a third container comes

00:12:00,350 --> 00:12:03,649
along and you kind of see how this files

00:12:02,120 --> 00:12:05,690
out of control because Ubuntu is not

00:12:03,649 --> 00:12:08,870
small a lot of times dependencies are

00:12:05,690 --> 00:12:10,760
quite large and this is where doctor

00:12:08,870 --> 00:12:12,140
really saved us a lot of pain they

00:12:10,760 --> 00:12:14,270
realized this thing called layered file

00:12:12,140 --> 00:12:15,920
systems which is not a new concept could

00:12:14,270 --> 00:12:19,550
be used to get containers their

00:12:15,920 --> 00:12:22,459
dependencies so how does this work

00:12:19,550 --> 00:12:24,529
another awesome diagram if you picture

00:12:22,459 --> 00:12:25,970
standard docker files doctor file the

00:12:24,529 --> 00:12:29,630
first line begins with from some key

00:12:25,970 --> 00:12:31,130
something we've taken Ubuntu when it

00:12:29,630 --> 00:12:34,040
containers Orchestrator reads that line

00:12:31,130 --> 00:12:36,310
it will go ahead and download the

00:12:34,040 --> 00:12:38,420
contents Ubuntu into a read-only

00:12:36,310 --> 00:12:41,810
directory somewhere on the host file

00:12:38,420 --> 00:12:43,940
system the next container comes along

00:12:41,810 --> 00:12:45,829
and it also wants Ubuntu but this time

00:12:43,940 --> 00:12:47,240
because the orchestrator already knows

00:12:45,829 --> 00:12:48,740
that we have one of those it doesn't do

00:12:47,240 --> 00:12:51,260
it it doesn't need to download it again

00:12:48,740 --> 00:12:53,180
it can just point to it and say use this

00:12:51,260 --> 00:12:56,000
one too so now they're sharing we've

00:12:53,180 --> 00:12:59,630
already saved time and space Doctor Who

00:12:56,000 --> 00:13:01,880
reference and the next line they run at

00:12:59,630 --> 00:13:03,350
update again only one of the needs to do

00:13:01,880 --> 00:13:05,540
this whichever one gets there first will

00:13:03,350 --> 00:13:07,850
run will downloads the things that are

00:13:05,540 --> 00:13:09,170
required in that run app date and that

00:13:07,850 --> 00:13:11,720
whoever gets their second we'll just use

00:13:09,170 --> 00:13:14,000
the one that's already been downloaded

00:13:11,720 --> 00:13:14,990
this third line now they're doing

00:13:14,000 --> 00:13:16,850
something different but this is still

00:13:14,990 --> 00:13:18,139
the first time that that second continue

00:13:16,850 --> 00:13:19,850
create cooled has actually had to

00:13:18,139 --> 00:13:21,920
download anything until then we have

00:13:19,850 --> 00:13:24,819
been sharing we've been saving space on

00:13:21,920 --> 00:13:27,199
our disk finally these are all then

00:13:24,819 --> 00:13:28,759
mounted into a read/write layer which

00:13:27,199 --> 00:13:32,720
becomes the containers root filesystem

00:13:28,759 --> 00:13:34,069
visible thanks to pivot root so here we

00:13:32,720 --> 00:13:35,660
can see how layered file systems and

00:13:34,069 --> 00:13:38,149
pivot root allow us to share

00:13:35,660 --> 00:13:39,740
dependencies and stop container

00:13:38,149 --> 00:13:41,120
processes from interfering with each

00:13:39,740 --> 00:13:47,839
other's route file systems while they

00:13:41,120 --> 00:13:50,720
are running all right

00:13:47,839 --> 00:13:52,399
so at this point we might be thinking

00:13:50,720 --> 00:13:54,050
okay we've got some pretty awesome

00:13:52,399 --> 00:13:55,250
isolation in places we've got our C

00:13:54,050 --> 00:13:57,560
groups in place we've got our

00:13:55,250 --> 00:13:57,800
dependencies sorted we should be pretty

00:13:57,560 --> 00:14:00,399
good

00:13:57,800 --> 00:14:02,600
right like what else do we need to do

00:14:00,399 --> 00:14:05,329
and of course like nothing's ever that

00:14:02,600 --> 00:14:06,560
easy and and so now we kind of need to

00:14:05,329 --> 00:14:09,259
think about okay well we've got our

00:14:06,560 --> 00:14:11,779
isolation but what happens like if or

00:14:09,259 --> 00:14:13,220
more like more likely when somebody

00:14:11,779 --> 00:14:15,170
breaks out of that isolation what

00:14:13,220 --> 00:14:18,259
happens then and what can we do to

00:14:15,170 --> 00:14:21,559
protect ourselves in that instance and

00:14:18,259 --> 00:14:24,139
so to that I say security onion so of

00:14:21,559 --> 00:14:25,490
course this is about applying layers so

00:14:24,139 --> 00:14:26,899
there's some additional layers of

00:14:25,490 --> 00:14:29,689
security that we can apply to these

00:14:26,899 --> 00:14:30,680
containerized processes in order to

00:14:29,689 --> 00:14:33,050
protect ourselves here

00:14:30,680 --> 00:14:36,740
so namely I'm talking about capability

00:14:33,050 --> 00:14:38,180
dropping set comp and gamma let's just

00:14:36,740 --> 00:14:41,779
quickly run through those now

00:14:38,180 --> 00:14:44,120
so capabilities so historically on Linux

00:14:41,779 --> 00:14:46,730
systems privileges tend to be divided

00:14:44,120 --> 00:14:49,910
into two you had the all-powerful root

00:14:46,730 --> 00:14:52,399
user a UID 0 who had the privileges to

00:14:49,910 --> 00:14:54,019
do absolutely everything and then there

00:14:52,399 --> 00:14:55,970
was every other user on the system so

00:14:54,019 --> 00:14:57,370
all of the unprivileged users and they

00:14:55,970 --> 00:15:00,589
weren't allowed to do anything at all

00:14:57,370 --> 00:15:02,930
and if an unprivileged user wanted to do

00:15:00,589 --> 00:15:05,600
some privileged operation like due

00:15:02,930 --> 00:15:06,800
amount do a pivot root they had to sudo

00:15:05,600 --> 00:15:08,899
su up to the root user

00:15:06,800 --> 00:15:11,059
at which point then they've gained every

00:15:08,899 --> 00:15:14,569
single privilege available so it's not

00:15:11,059 --> 00:15:16,639
great these days those privileges have

00:15:14,569 --> 00:15:21,130
been split up into little chunks known

00:15:16,639 --> 00:15:24,949
as capabilities here are some examples

00:15:21,130 --> 00:15:25,740
so we've got for example cap shown so

00:15:24,949 --> 00:15:27,210
historically

00:15:25,740 --> 00:15:30,930
if you wanted to turn a file to another

00:15:27,210 --> 00:15:32,430
user you had to be the root user but now

00:15:30,930 --> 00:15:35,100
that these capabilities have been split

00:15:32,430 --> 00:15:37,500
up it means that actually any process is

00:15:35,100 --> 00:15:40,520
now has the privileges to do this as

00:15:37,500 --> 00:15:43,560
long as it has that cap shown capability

00:15:40,520 --> 00:15:46,890
similarly for cap set you it and there's

00:15:43,560 --> 00:15:48,150
there's about 40 of these in total and

00:15:46,890 --> 00:15:52,860
you can see that that gives us a much

00:15:48,150 --> 00:15:54,180
nicer separation of concerns there but

00:15:52,860 --> 00:15:56,850
there is one that we need to talk about

00:15:54,180 --> 00:15:58,770
which is cap sysadmin and this has kind

00:15:56,850 --> 00:16:01,410
of become like a catch-all for any of

00:15:58,770 --> 00:16:04,230
the privileges that don't fit into any

00:16:01,410 --> 00:16:07,050
of the other capabilities that we have

00:16:04,230 --> 00:16:09,240
today and so as a result it's really

00:16:07,050 --> 00:16:11,160
overpowered and really to the point

00:16:09,240 --> 00:16:14,060
where if you have caps this admin you

00:16:11,160 --> 00:16:16,380
are still essentially the root user and

00:16:14,060 --> 00:16:18,270
this is going to be really important

00:16:16,380 --> 00:16:20,340
later on when we start to talk about the

00:16:18,270 --> 00:16:22,050
rootless containers so keep that in mind

00:16:20,340 --> 00:16:23,880
but the reason we're mentioning this now

00:16:22,050 --> 00:16:27,230
is because it's actually possible to

00:16:23,880 --> 00:16:29,640
remove capabilities from our processes

00:16:27,230 --> 00:16:31,350
so what this means is that when we've

00:16:29,640 --> 00:16:33,690
got our containerized processes that are

00:16:31,350 --> 00:16:34,980
running we can actually remove caps this

00:16:33,690 --> 00:16:37,320
admin as well as all the other

00:16:34,980 --> 00:16:39,780
capabilities that we want to and it

00:16:37,320 --> 00:16:42,080
means that if that containerized process

00:16:39,780 --> 00:16:44,250
is able to break out of the isolation

00:16:42,080 --> 00:16:46,050
we've actually limited the amount of

00:16:44,250 --> 00:16:51,810
damage it can do because it doesn't have

00:16:46,050 --> 00:16:55,230
the capability to do anything so next up

00:16:51,810 --> 00:16:58,650
we have set comp set comm stands for

00:16:55,230 --> 00:17:01,920
secure computing mode and this is pretty

00:16:58,650 --> 00:17:03,660
awesome set basically allows us to limit

00:17:01,920 --> 00:17:07,320
the number of sis calls that our

00:17:03,660 --> 00:17:08,820
processes can make so this is great so

00:17:07,320 --> 00:17:10,500
if you think about it like all of this

00:17:08,820 --> 00:17:13,440
security here it's kind of relying on

00:17:10,500 --> 00:17:15,920
the surface area of the kernel and the

00:17:13,440 --> 00:17:19,380
kernel is a pretty big thing and so by

00:17:15,920 --> 00:17:20,790
giving well the fact that we are able to

00:17:19,380 --> 00:17:22,890
remove some of the Siskel's

00:17:20,790 --> 00:17:24,900
from our containers or the containerized

00:17:22,890 --> 00:17:26,370
processes that's awesome because it

00:17:24,900 --> 00:17:30,150
means that we are dramatically reducing

00:17:26,370 --> 00:17:32,160
the surface area for an attack there and

00:17:30,150 --> 00:17:35,070
it means that yeah any vulnerabilities

00:17:32,160 --> 00:17:37,050
in any of those two schools that's no

00:17:35,070 --> 00:17:38,490
longer a concern for us because the

00:17:37,050 --> 00:17:39,200
containers don't have the permission to

00:17:38,490 --> 00:17:46,039
run this

00:17:39,200 --> 00:17:47,629
anyway finally then we have a Parma so a

00:17:46,039 --> 00:17:51,049
Parma allows us to restrict these

00:17:47,629 --> 00:17:52,730
containerized processes even further so

00:17:51,049 --> 00:17:55,519
a Palmer is a form of mandatory access

00:17:52,730 --> 00:17:57,619
control kind of like SELinux and the way

00:17:55,519 --> 00:18:00,529
this works is you create yourself an

00:17:57,619 --> 00:18:02,659
ARMA profile which contains a bunch of

00:18:00,529 --> 00:18:06,109
rules so there's an example rule there

00:18:02,659 --> 00:18:08,840
deny at proc slash start W which means

00:18:06,109 --> 00:18:11,330
that when applied this process is not

00:18:08,840 --> 00:18:14,450
allowed to write to any file inside the

00:18:11,330 --> 00:18:16,070
prog referral system for example and so

00:18:14,450 --> 00:18:17,690
we build up these these profiles and we

00:18:16,070 --> 00:18:20,299
apply it to the containerized processes

00:18:17,690 --> 00:18:23,359
and again even then if they're able to

00:18:20,299 --> 00:18:25,039
break out of the isolation we're

00:18:23,359 --> 00:18:28,480
limiting the damage that can actually be

00:18:25,039 --> 00:18:31,970
actually be done in in that situation

00:18:28,480 --> 00:18:34,340
and so we have the security onion

00:18:31,970 --> 00:18:36,350
capability dropping set calm and a palma

00:18:34,340 --> 00:18:38,119
it's probably worth mentioning that in

00:18:36,350 --> 00:18:40,009
order to apply all this lot you do

00:18:38,119 --> 00:18:42,649
typically need to have like caps s admin

00:18:40,009 --> 00:18:47,840
and those root level privileges which is

00:18:42,649 --> 00:18:49,549
going to be important later on but the

00:18:47,840 --> 00:18:52,519
other thing just want to quickly mention

00:18:49,549 --> 00:18:55,100
is we've actually covered loads of stuff

00:18:52,519 --> 00:18:58,460
right we've seen like namespaces C

00:18:55,100 --> 00:19:00,649
groups set comp dependencies like all

00:18:58,460 --> 00:19:03,080
this stuff and it's actually really

00:19:00,649 --> 00:19:04,960
really tricky stuff it's quite low level

00:19:03,080 --> 00:19:07,460
sort of working around the kernel and

00:19:04,960 --> 00:19:09,919
historically that fell to the garden

00:19:07,460 --> 00:19:11,450
team to program around that and to be

00:19:09,919 --> 00:19:13,369
responsible for that

00:19:11,450 --> 00:19:15,200
but fortunately with the introduction of

00:19:13,369 --> 00:19:17,840
standards a couple of years ago so

00:19:15,200 --> 00:19:19,989
particularly the OCI standard this has

00:19:17,840 --> 00:19:22,989
now no no longer such an issue for us

00:19:19,989 --> 00:19:25,970
and in particular a tool called run C

00:19:22,989 --> 00:19:28,489
which is just a very small binary tool

00:19:25,970 --> 00:19:30,139
that's published by by the OCI it

00:19:28,489 --> 00:19:32,749
basically abstracts away all of that

00:19:30,139 --> 00:19:34,369
hard work for us and it means that we as

00:19:32,749 --> 00:19:37,039
garden can just cool down to the binary

00:19:34,369 --> 00:19:39,440
and it does all of that complexity for

00:19:37,039 --> 00:19:39,889
us so it's it's been absolutely

00:19:39,440 --> 00:19:41,840
invaluable

00:19:39,889 --> 00:19:45,139
and I think it's it would be hard to

00:19:41,840 --> 00:19:48,830
overstate how good this has been for

00:19:45,139 --> 00:19:51,519
security in general so thank you to NC

00:19:48,830 --> 00:19:51,519
Cheers

00:19:51,889 --> 00:19:57,600
okay so at this point as I said we

00:19:56,129 --> 00:19:59,879
covered the namespaces the cgroups

00:19:57,600 --> 00:20:02,159
isolation set comp all this stuff like

00:19:59,879 --> 00:20:09,090
Shirley Shirley Shirley now we must be

00:20:02,159 --> 00:20:12,239
secure enough right so yeah sure so far

00:20:09,090 --> 00:20:13,529
we have suffered no major exploits there

00:20:12,239 --> 00:20:17,549
is no word here I can't touch word I'm

00:20:13,529 --> 00:20:19,320
really sorry sorry Molly but it doesn't

00:20:17,549 --> 00:20:21,450
mean that we're invulnerable not yet if

00:20:19,320 --> 00:20:22,859
you picture the various exit points from

00:20:21,450 --> 00:20:25,799
a container as a door then yes we've

00:20:22,859 --> 00:20:29,009
made a really solid door but how likely

00:20:25,799 --> 00:20:29,460
are the attackers to stop there pretty

00:20:29,009 --> 00:20:30,600
unlikely

00:20:29,460 --> 00:20:32,009
once you've sealed off the door they're

00:20:30,600 --> 00:20:33,840
gonna step back they're gonna look for

00:20:32,009 --> 00:20:36,179
the windows which means that while we

00:20:33,840 --> 00:20:41,129
think we've done this if we step back

00:20:36,179 --> 00:20:42,779
what we've actually got is that so

00:20:41,129 --> 00:20:44,279
we've secured the containers but now II

00:20:42,779 --> 00:20:45,539
to make sure that we secure everything

00:20:44,279 --> 00:20:46,590
else we need to secure the things that

00:20:45,539 --> 00:20:48,029
are managing and running those

00:20:46,590 --> 00:20:50,279
containers we need to secure garden

00:20:48,029 --> 00:20:52,889
itself we've garden to not run as route

00:20:50,279 --> 00:20:53,850
right now garden and all the other

00:20:52,889 --> 00:20:55,139
components will running with Mayor

00:20:53,850 --> 00:20:56,999
privilege right now because we've had to

00:20:55,139 --> 00:20:58,590
be in the past but things have changed

00:20:56,999 --> 00:21:00,149
and now there's all sorts of primitives

00:20:58,590 --> 00:21:06,330
and tricks that we can use to get to

00:21:00,149 --> 00:21:08,129
this yeah so that so this is where

00:21:06,330 --> 00:21:12,749
rootless containers finally come into

00:21:08,129 --> 00:21:14,309
play so the nice thing about realist

00:21:12,749 --> 00:21:16,619
containers is it means we can actually

00:21:14,309 --> 00:21:18,450
create all of that that all of those

00:21:16,619 --> 00:21:22,139
containers without needing to be roots

00:21:18,450 --> 00:21:24,450
ourselves and the key trick here is user

00:21:22,139 --> 00:21:27,629
namespaces so we kind of touched on

00:21:24,450 --> 00:21:29,039
these earlier so so in the same way as

00:21:27,629 --> 00:21:32,309
we saw with the pip namespace which

00:21:29,039 --> 00:21:35,909
allowed the peared of a process inside a

00:21:32,309 --> 00:21:37,859
container to be different - to be

00:21:35,909 --> 00:21:40,049
different from the perspective inside

00:21:37,859 --> 00:21:42,989
the container as compared to outside the

00:21:40,049 --> 00:21:45,179
container such as the case also with the

00:21:42,989 --> 00:21:47,369
username space but with the username

00:21:45,179 --> 00:21:50,340
space we're talking about you IDs rather

00:21:47,369 --> 00:21:51,779
than P IDs and this is really great

00:21:50,340 --> 00:21:53,580
because it means that inside the

00:21:51,779 --> 00:21:56,759
container a process can appear to be

00:21:53,580 --> 00:21:58,230
running with a UID of zero or root but

00:21:56,759 --> 00:22:00,239
actually from the perspective of the

00:21:58,230 --> 00:22:02,369
host and all of the other containers

00:22:00,239 --> 00:22:05,999
it's just running as some completely

00:22:02,369 --> 00:22:07,799
random unprivileged to you

00:22:05,999 --> 00:22:10,279
and what's even more awesome about this

00:22:07,799 --> 00:22:14,009
is that actually any unprivileged user

00:22:10,279 --> 00:22:16,679
has the privileges to create a new user

00:22:14,009 --> 00:22:18,779
name space and so I'm going to put this

00:22:16,679 --> 00:22:20,429
up here in sort of giant letters because

00:22:18,779 --> 00:22:23,309
this is kind of the key the key point of

00:22:20,429 --> 00:22:25,409
the whole talk here any non real user

00:22:23,309 --> 00:22:29,100
can create a new user name space in

00:22:25,409 --> 00:22:30,749
which they are the root user and once

00:22:29,100 --> 00:22:33,179
you are then the root user within that

00:22:30,749 --> 00:22:35,220
user name space you have caps this admin

00:22:33,179 --> 00:22:38,330
you have the privileges that you need to

00:22:35,220 --> 00:22:41,700
go and setup the rest of the container

00:22:38,330 --> 00:22:43,109
so that's pretty awesome but but user

00:22:41,700 --> 00:22:43,590
name spaces can be they can be a bit

00:22:43,109 --> 00:22:46,019
confusing

00:22:43,590 --> 00:22:48,269
so I've got an analogy here hopefully

00:22:46,019 --> 00:22:52,169
this will help you so let's imagine that

00:22:48,269 --> 00:22:55,230
in the host we are an average frustrated

00:22:52,169 --> 00:23:00,259
user we have no privileges our UID does

00:22:55,230 --> 00:23:00,259
not equal to zero but in the container a

00:23:00,499 --> 00:23:05,249
web Brad Pitt

00:23:02,539 --> 00:23:08,940
we are the root user we have all

00:23:05,249 --> 00:23:09,989
privileges our UID is zero and yeah so

00:23:08,940 --> 00:23:11,789
this means that we've got that cap

00:23:09,989 --> 00:23:13,049
sysadmin it means we can go and set up

00:23:11,789 --> 00:23:14,940
and create the rest of the container

00:23:13,049 --> 00:23:16,759
with all of those layers of security

00:23:14,940 --> 00:23:20,999
that I that we've just been through

00:23:16,759 --> 00:23:22,980
exactly the same as before which is

00:23:20,999 --> 00:23:25,559
great but the key thing here is that

00:23:22,980 --> 00:23:27,869
it's only though those root level

00:23:25,559 --> 00:23:31,019
privileges are only applicable with

00:23:27,869 --> 00:23:33,690
inside that user namespace so outside

00:23:31,019 --> 00:23:35,279
the user namespace I in the host and in

00:23:33,690 --> 00:23:37,859
the other containers you're just an

00:23:35,279 --> 00:23:40,950
unprivileged user which is pretty

00:23:37,859 --> 00:23:43,710
awesome so how does this work well

00:23:40,950 --> 00:23:45,570
there's a map a UID map so as we can see

00:23:43,710 --> 00:23:49,639
there we are basically mapping UID 0

00:23:45,570 --> 00:23:53,460
inside the container to UID 49 blah blah

00:23:49,639 --> 00:23:55,049
inside the host with the length of 1 and

00:23:53,460 --> 00:23:56,879
that you idea there that's that's

00:23:55,049 --> 00:23:59,159
basically the maximum UID that's

00:23:56,879 --> 00:24:00,450
available on the linux systems and we

00:23:59,159 --> 00:24:02,340
chose this because it's the one least

00:24:00,450 --> 00:24:05,419
likely to have any privileges or to

00:24:02,340 --> 00:24:06,929
clash with any other sub with you IDs

00:24:05,419 --> 00:24:08,909
but there's a problem

00:24:06,929 --> 00:24:11,489
and the problem is that by default

00:24:08,909 --> 00:24:15,629
you're only allowed to map one single

00:24:11,489 --> 00:24:17,429
UID so let's take a look at what this

00:24:15,629 --> 00:24:17,760
might look like so let's assume that in

00:24:17,429 --> 00:24:19,920
the

00:24:17,760 --> 00:24:23,910
host let's say we are unprivileged user

00:24:19,920 --> 00:24:25,770
UID a thousand Alice and we say okay I'm

00:24:23,910 --> 00:24:28,080
gonna create a new username space and

00:24:25,770 --> 00:24:31,140
I'm going to map myself to UID 0 the

00:24:28,080 --> 00:24:32,940
real user that's great but what about

00:24:31,140 --> 00:24:33,540
all of the other UID is inside the

00:24:32,940 --> 00:24:35,640
container

00:24:33,540 --> 00:24:37,500
we haven't applied a mapping for those

00:24:35,640 --> 00:24:40,590
and so it means that if you were to look

00:24:37,500 --> 00:24:41,700
in it look inside it they would just be

00:24:40,590 --> 00:24:44,790
unknown and they wouldn't be allowed to

00:24:41,700 --> 00:24:49,410
do anything and obviously you know users

00:24:44,790 --> 00:24:52,740
expect UID used to work so how do we get

00:24:49,410 --> 00:24:56,790
around this well fortunately there is a

00:24:52,740 --> 00:25:00,450
solution new UI new UI D map and this is

00:24:56,790 --> 00:25:03,480
basically a small set UID binary and to

00:25:00,450 --> 00:25:05,550
set you ideas basically it allows you to

00:25:03,480 --> 00:25:08,250
run a binary with the privileges of the

00:25:05,550 --> 00:25:11,040
owner of the binary rather than the

00:25:08,250 --> 00:25:13,500
currently running user and so if that

00:25:11,040 --> 00:25:15,360
binary has turned as the root user it

00:25:13,500 --> 00:25:18,990
gives us a way to temporarily elevate

00:25:15,360 --> 00:25:22,560
our privileges write the entire UID map

00:25:18,990 --> 00:25:25,410
and then drop that down so it's kind of

00:25:22,560 --> 00:25:26,730
cheating it's not like 100% rulers but

00:25:25,410 --> 00:25:29,820
but we kind of think it's okay

00:25:26,730 --> 00:25:33,200
new UID map is a very standard binary

00:25:29,820 --> 00:25:33,200
either you'll find on most distributions

00:25:34,280 --> 00:25:40,890
what about reader vestments so earlier I

00:25:39,120 --> 00:25:42,390
talked about how encapsulation is the

00:25:40,890 --> 00:25:44,130
thing which makes containers nice and

00:25:42,390 --> 00:25:45,960
portable and stops their dependencies

00:25:44,130 --> 00:25:47,640
from flooding your disk and this is done

00:25:45,960 --> 00:25:49,230
through filesystem layering well

00:25:47,640 --> 00:25:52,110
unfortunately doing a reach first mount

00:25:49,230 --> 00:25:53,520
often requires root so that was our next

00:25:52,110 --> 00:25:57,360
target when we want to become completely

00:25:53,520 --> 00:25:58,500
ruthless just quickly clarify by what we

00:25:57,360 --> 00:26:00,690
mean when I talk about a filesystem

00:25:58,500 --> 00:26:02,670
there are two meanings associated with

00:26:00,690 --> 00:26:04,470
this word one is the structure just the

00:26:02,670 --> 00:26:07,320
files and directories what you see when

00:26:04,470 --> 00:26:10,020
you go on and do LS and move around the

00:26:07,320 --> 00:26:11,430
second meaning is the way that data is

00:26:10,020 --> 00:26:14,430
managed within that structure and that

00:26:11,430 --> 00:26:15,540
is done by filesystem type so today I'm

00:26:14,430 --> 00:26:19,320
going to be talking about the second one

00:26:15,540 --> 00:26:21,300
how that data is managed so let's start

00:26:19,320 --> 00:26:22,560
in the beginning back in the day when

00:26:21,300 --> 00:26:25,380
Garden was young and we weren't even

00:26:22,560 --> 00:26:27,360
call garden we used a ufs to create

00:26:25,380 --> 00:26:28,559
those root filesystem mounts for our

00:26:27,360 --> 00:26:30,690
containers

00:26:28,559 --> 00:26:32,159
and we use a OFS for ages and it was a

00:26:30,690 --> 00:26:34,230
headache but we stuck with it because

00:26:32,159 --> 00:26:34,769
nothing else was mature enough for our

00:26:34,230 --> 00:26:36,419
needs

00:26:34,769 --> 00:26:37,740
well either that or it was under

00:26:36,419 --> 00:26:41,429
proprietary license and we couldn't use

00:26:37,740 --> 00:26:43,200
it our main problems with AFS we're that

00:26:41,429 --> 00:26:44,880
it would not in the mainline kernel and

00:26:43,200 --> 00:26:46,559
compiling that module went wrong more

00:26:44,880 --> 00:26:48,509
often than it went right it was

00:26:46,559 --> 00:26:50,669
maintained mid maintained by precisely

00:26:48,509 --> 00:26:53,880
one person which meant asking for

00:26:50,669 --> 00:26:56,220
patches it's not quick and you have to

00:26:53,880 --> 00:26:58,200
be root to do an area first mount but we

00:26:56,220 --> 00:27:00,059
were stuck with it until two years ago

00:26:58,200 --> 00:27:02,220
another option became very attractive

00:27:00,059 --> 00:27:04,200
and because there was this huge push for

00:27:02,220 --> 00:27:06,840
us to get all of our components rootless

00:27:04,200 --> 00:27:08,940
we created an entire team around our new

00:27:06,840 --> 00:27:10,860
root filesystem creator and we called it

00:27:08,940 --> 00:27:12,990
root of s which is a terrible name

00:27:10,860 --> 00:27:15,690
because implies we create a new type of

00:27:12,990 --> 00:27:16,799
file system which we did not we created

00:27:15,690 --> 00:27:18,029
something which download the stuff and

00:27:16,799 --> 00:27:19,830
then give you a directory at the end of

00:27:18,029 --> 00:27:20,789
it which is still cool a lot of cool

00:27:19,830 --> 00:27:22,769
stuff going on but we did not make a

00:27:20,789 --> 00:27:24,779
file system anyway we chose better of s

00:27:22,769 --> 00:27:27,330
to actually be our new file system type

00:27:24,779 --> 00:27:29,129
and it looked good to us because it had

00:27:27,330 --> 00:27:30,629
disk quota tooling built-in which as we

00:27:29,129 --> 00:27:33,509
know for Cloud Foundry is really

00:27:30,629 --> 00:27:35,250
essential with multi-talented and aside

00:27:33,509 --> 00:27:36,539
from needing a bit of privilege for

00:27:35,250 --> 00:27:37,710
setup which can be done before we start

00:27:36,539 --> 00:27:39,960
our container server

00:27:37,710 --> 00:27:41,700
it could snapshot our root file systems

00:27:39,960 --> 00:27:44,490
as an unprivileged user and so we were

00:27:41,700 --> 00:27:45,990
very excited about this but it turned

00:27:44,490 --> 00:27:47,730
out that that disk quota tooling we were

00:27:45,990 --> 00:27:49,080
so excited about ended up not really

00:27:47,730 --> 00:27:50,519
being very good in production it cannot

00:27:49,080 --> 00:27:53,009
stand up under load and the whole system

00:27:50,519 --> 00:27:54,539
ground to a very unpleasant halt so we

00:27:53,009 --> 00:27:56,399
had to quickly turn it around and we

00:27:54,539 --> 00:27:58,740
chose our next favorites file system

00:27:56,399 --> 00:28:00,450
which was overlay FS which is very

00:27:58,740 --> 00:28:01,889
similar to a o FS and that it performs a

00:28:00,450 --> 00:28:03,059
union mount which basically means it

00:28:01,889 --> 00:28:04,559
takes the contents of several

00:28:03,059 --> 00:28:07,080
directories and make it a pairs of it's

00:28:04,559 --> 00:28:09,809
under just one directory the only permit

00:28:07,080 --> 00:28:11,549
the big difference is between a o FS and

00:28:09,809 --> 00:28:14,639
overlay is that you can do mounts as an

00:28:11,549 --> 00:28:16,799
unprivileged user or new bunting so

00:28:14,639 --> 00:28:19,049
currently you bun two had a chat with

00:28:16,799 --> 00:28:21,090
the overlay FS maintainer and decided it

00:28:19,049 --> 00:28:22,500
was not a security risk to perform

00:28:21,090 --> 00:28:24,600
mounts as and privileged users because

00:28:22,500 --> 00:28:28,679
not many I don't think any apartment is

00:28:24,600 --> 00:28:31,529
it shipped FS does or soon does mounts

00:28:28,679 --> 00:28:34,139
as and privileged user but a Bunty now

00:28:31,529 --> 00:28:36,690
compiles a patch version of its kernel

00:28:34,139 --> 00:28:38,610
with the overlay filesystem whitelisted

00:28:36,690 --> 00:28:39,590
for that action so it's very cool it

00:28:38,610 --> 00:28:42,289
does highest on

00:28:39,590 --> 00:28:44,960
but it does get us by on our quest for

00:28:42,289 --> 00:28:47,419
rootless containers we still use gruta

00:28:44,960 --> 00:28:49,340
vests to download all those layers and

00:28:47,419 --> 00:28:53,029
to turn them to turn all the directories

00:28:49,340 --> 00:28:54,710
to be owned by our Maximus user but rid

00:28:53,029 --> 00:28:56,270
of us sorry gruta fest will not do that

00:28:54,710 --> 00:28:59,690
month instead it will return all the

00:28:56,270 --> 00:29:03,230
information needed to do that amount to

00:28:59,690 --> 00:29:06,049
run C in the form of the is at the OCIO

00:29:03,230 --> 00:29:07,850
spec then run C you will perform those

00:29:06,049 --> 00:29:09,049
mounts in order so just we just need to

00:29:07,850 --> 00:29:10,970
make sure that the route of first mount

00:29:09,049 --> 00:29:12,890
is at the top of that lists that array

00:29:10,970 --> 00:29:15,080
and run C we will get that to those

00:29:12,890 --> 00:29:16,640
details and inside the user names base

00:29:15,080 --> 00:29:17,899
where it has all the correct powers to

00:29:16,640 --> 00:29:19,520
do everything it needs to do it will

00:29:17,899 --> 00:29:23,600
mount our root filesystem for us as an

00:29:19,520 --> 00:29:25,370
unprivileged user so it's very cool so

00:29:23,600 --> 00:29:26,929
to sum up we are running garden rootless

00:29:25,370 --> 00:29:28,460
we've got user and acid mappings we have

00:29:26,929 --> 00:29:30,260
got grew turf s running rootless which

00:29:28,460 --> 00:29:38,299
is creating a rootless lyon of route FS

00:29:30,260 --> 00:29:40,309
are we now good not entirely so there's

00:29:38,299 --> 00:29:41,600
still a couple of a road blocks left I'm

00:29:40,309 --> 00:29:44,990
going to quickly run through these just

00:29:41,600 --> 00:29:48,200
aware of the time so the first one is

00:29:44,990 --> 00:29:49,850
disc waders so we mentioned this earlier

00:29:48,200 --> 00:29:52,070
we need to apply disc waders to our

00:29:49,850 --> 00:29:54,169
applications to stop them from filling

00:29:52,070 --> 00:29:57,320
out the disc and the way that we do this

00:29:54,169 --> 00:29:58,580
is with xf s fundamentally x the first

00:29:57,320 --> 00:30:01,070
disc quitters require root level

00:29:58,580 --> 00:30:02,990
privileges to apply so the way that we

00:30:01,070 --> 00:30:04,909
worked around this was to just extract

00:30:02,990 --> 00:30:06,730
the tiny piece of code that was actually

00:30:04,909 --> 00:30:09,679
responsible for applying these quotas

00:30:06,730 --> 00:30:11,929
into a tiny binary and then again we

00:30:09,679 --> 00:30:14,649
applied that set UID bit to it so very

00:30:11,929 --> 00:30:17,029
similar to how new UI team app works

00:30:14,649 --> 00:30:18,529
next up was networking this is kind of

00:30:17,029 --> 00:30:20,480
like elephant in the room we haven't

00:30:18,529 --> 00:30:22,340
talked at all about this and that's

00:30:20,480 --> 00:30:26,570
because again requires root level

00:30:22,340 --> 00:30:27,830
privileges so what do we do well we

00:30:26,570 --> 00:30:29,390
extracted the piece of code that does

00:30:27,830 --> 00:30:30,529
the networking and we apply it to set

00:30:29,390 --> 00:30:32,840
UID binary to it

00:30:30,529 --> 00:30:36,080
so you ID bit sorry you may be noticing

00:30:32,840 --> 00:30:38,240
the theme just quickly mention there is

00:30:36,080 --> 00:30:39,950
some work ongoing here that slurp for

00:30:38,240 --> 00:30:42,470
net NS tool which has got a great name

00:30:39,950 --> 00:30:44,809
this is like user space networking you

00:30:42,470 --> 00:30:46,580
can do that entirely unprivileged but

00:30:44,809 --> 00:30:49,280
it's really slow so we couldn't use it

00:30:46,580 --> 00:30:52,700
for production and then finally there's

00:30:49,280 --> 00:30:53,389
C group joining so by default C groups

00:30:52,700 --> 00:30:55,940
are Expo

00:30:53,389 --> 00:30:58,789
as a virtual file system and if you want

00:30:55,940 --> 00:31:01,009
to apply a limit you have to echo some

00:30:58,789 --> 00:31:02,779
values into the secret pass and the

00:31:01,009 --> 00:31:05,419
problem is that those files are owned by

00:31:02,779 --> 00:31:06,709
the host root so our container root

00:31:05,419 --> 00:31:08,659
doesn't have permission to do that I

00:31:06,709 --> 00:31:10,579
said to get around this we actually have

00:31:08,659 --> 00:31:13,070
like a very small privilege to setup

00:31:10,579 --> 00:31:15,109
phase that goes in tones the cgroups to

00:31:13,070 --> 00:31:17,089
our container at root user and this is

00:31:15,109 --> 00:31:19,700
sort of okay because that happens before

00:31:17,089 --> 00:31:21,619
any container is ever created so then

00:31:19,700 --> 00:31:23,589
there's no risk of a user interfering

00:31:21,619 --> 00:31:28,190
with that process at all

00:31:23,589 --> 00:31:30,109
are we production ready well gotten has

00:31:28,190 --> 00:31:31,459
been some production ready for a while

00:31:30,109 --> 00:31:33,379
now but of course Cloud Foundry is a big

00:31:31,459 --> 00:31:34,789
thing there are lots of other teams that

00:31:33,379 --> 00:31:36,739
need to line before we can get out there

00:31:34,789 --> 00:31:38,269
so no we're not reproduction yet we

00:31:36,739 --> 00:31:39,649
really hoped that by the time we got up

00:31:38,269 --> 00:31:42,049
here we'd be able see that we are so

00:31:39,649 --> 00:31:43,249
close we can see it it's painful to

00:31:42,049 --> 00:31:45,349
think how close we were being able to

00:31:43,249 --> 00:31:46,969
say that we were in production but we're

00:31:45,349 --> 00:31:48,499
not yet but hopefully this time next

00:31:46,969 --> 00:31:49,940
year we'll be back or someone on the

00:31:48,499 --> 00:31:51,499
team will be back to give you the latest

00:31:49,940 --> 00:31:52,579
updates on all their fun new bugs that

00:31:51,499 --> 00:31:54,519
would come out from running rootless in

00:31:52,579 --> 00:31:57,769
production it's gonna happen

00:31:54,519 --> 00:31:59,570
so we're times gonna do this all at once

00:31:57,769 --> 00:32:01,249
here a bunch of links if you want to try

00:31:59,570 --> 00:32:03,289
rootless yourself if you're deploying by

00:32:01,249 --> 00:32:06,320
SCF just turn on the experimental route

00:32:03,289 --> 00:32:08,389
some experimental routes mode on your

00:32:06,320 --> 00:32:10,070
garden job and then all your application

00:32:08,389 --> 00:32:13,009
containers will be running rootless if

00:32:10,070 --> 00:32:16,459
you run want to run the binary just on

00:32:13,009 --> 00:32:18,079
ubuntu stem cell just to play around you

00:32:16,459 --> 00:32:19,969
can create some routes containers there

00:32:18,079 --> 00:32:21,679
and the last one there is a link to the

00:32:19,969 --> 00:32:23,629
rootless containers roadmap which is

00:32:21,679 --> 00:32:25,609
maintained by alexis RI who is a

00:32:23,629 --> 00:32:27,789
contributor to run see that component we

00:32:25,609 --> 00:32:29,899
you know talk very highly of earlier and

00:32:27,789 --> 00:32:30,889
so that's just how route is going

00:32:29,899 --> 00:32:31,849
generally in the community which is very

00:32:30,889 --> 00:32:34,579
important for us because we work

00:32:31,849 --> 00:32:35,690
alongside the community and I just

00:32:34,579 --> 00:32:37,759
actually do want to shout out to people

00:32:35,690 --> 00:32:39,259
in the community who have done so much

00:32:37,759 --> 00:32:40,820
work with recent anus without them we

00:32:39,259 --> 00:32:43,579
would probably have nothing to even talk

00:32:40,820 --> 00:32:46,820
about here today so just result xsr i

00:32:43,579 --> 00:32:50,329
Akihiro sudha and many many others thank

00:32:46,820 --> 00:32:52,099
you so much for your work and that's

00:32:50,329 --> 00:32:55,029
that's done just under the wire any

00:32:52,099 --> 00:32:55,029
questions thank you

00:33:00,060 --> 00:33:05,350
you have a 30 minute break after this

00:33:03,580 --> 00:33:06,580
talk I believe so we can take some

00:33:05,350 --> 00:33:10,050
questions that people want to stick

00:33:06,580 --> 00:33:12,250
around not 30 minutes questions clicking

00:33:10,050 --> 00:33:18,910
but I'll pass you the mic if you have

00:33:12,250 --> 00:33:21,090
any questions going once okay so you got

00:33:18,910 --> 00:33:21,090
one

00:33:23,690 --> 00:33:30,990
thank you for the presentation and did

00:33:26,100 --> 00:33:33,600
you consider it CFS and said yes we did

00:33:30,990 --> 00:33:35,730
my understanding is that the licensing

00:33:33,600 --> 00:33:38,190
around ZFS is a little complicated and

00:33:35,730 --> 00:33:39,240
so we kind of got scared off from it but

00:33:38,190 --> 00:33:41,070
you're right I think I think you're

00:33:39,240 --> 00:33:43,230
right actually I think ZFS you are able

00:33:41,070 --> 00:33:46,440
to do the disk Wittering unprivileged as

00:33:43,230 --> 00:33:48,270
well but yeah we can really consider it

00:33:46,440 --> 00:33:51,530
for production the Cloud Foundry case

00:33:48,270 --> 00:33:51,530
because of that that licensing

00:34:02,870 --> 00:34:09,600
this will be a quick one I'm curious

00:34:05,429 --> 00:34:12,750
about how how to test these kinds of

00:34:09,600 --> 00:34:14,760
changes so it sounds like a lot of these

00:34:12,750 --> 00:34:17,609
implementations come from like a

00:34:14,760 --> 00:34:18,960
theoretical kind of observation of what

00:34:17,609 --> 00:34:22,169
it would mean to be ruthless

00:34:18,960 --> 00:34:24,240
but are there any tests or automation

00:34:22,169 --> 00:34:27,000
suites to like try to break out or try

00:34:24,240 --> 00:34:30,510
to really exercise and be really

00:34:27,000 --> 00:34:32,580
mischievous to your yeah so I think

00:34:30,510 --> 00:34:35,310
there's a couple of parts to that so

00:34:32,580 --> 00:34:36,780
first of all like the vast majority of

00:34:35,310 --> 00:34:39,990
the work here is actually contained

00:34:36,780 --> 00:34:41,129
inside run C itself so again like we get

00:34:39,990 --> 00:34:43,109
a lot of this for free

00:34:41,129 --> 00:34:45,210
we've actually been helping out with

00:34:43,109 --> 00:34:48,030
some of the realist off so a year or so

00:34:45,210 --> 00:34:49,290
ago we were the ones well you know we

00:34:48,030 --> 00:34:50,940
were helping out to get the features in

00:34:49,290 --> 00:34:53,280
that we needed to make it work for Cloud

00:34:50,940 --> 00:34:54,869
Foundry and as part of that there was

00:34:53,280 --> 00:34:56,700
some testing stuff that we had it into

00:34:54,869 --> 00:35:00,510
there so I think run C has a set of

00:34:56,700 --> 00:35:03,510
tests garden also has a pretty awesome

00:35:00,510 --> 00:35:08,160
set of security tests integration tests

00:35:03,510 --> 00:35:10,980
as well and yeah we we spent a lot of

00:35:08,160 --> 00:35:13,170
time talking about this and just you

00:35:10,980 --> 00:35:15,000
know any idea on the wall like how are

00:35:13,170 --> 00:35:17,060
we what we wanted to make sure was that

00:35:15,000 --> 00:35:19,980
we weren't making the security worse

00:35:17,060 --> 00:35:23,160
accidentally which was a possibility

00:35:19,980 --> 00:35:24,990
right but and yeah I think I think we

00:35:23,160 --> 00:35:27,510
got the run C test the Garmin tests and

00:35:24,990 --> 00:35:31,470
we're pretty sure it's it's pretty

00:35:27,510 --> 00:35:33,270
secure if anyone could spot anything

00:35:31,470 --> 00:35:35,100
that we haven't noticed please come and

00:35:33,270 --> 00:35:38,180
talk to us but yeah I think we've I

00:35:35,100 --> 00:35:38,180
think we've pretty much got it covered

00:35:50,420 --> 00:35:57,320
the user name spacing seems to provide a

00:35:54,410 --> 00:36:00,550
way to inside containers of different

00:35:57,320 --> 00:36:03,080
users and maybe add some restrictions

00:36:00,550 --> 00:36:05,870
can you clarify whether it's already

00:36:03,080 --> 00:36:07,790
possible for platform developers to set

00:36:05,870 --> 00:36:10,220
those restrictions to create new users

00:36:07,790 --> 00:36:12,140
and to set those and if not is it

00:36:10,220 --> 00:36:17,020
something that could be envisioned in

00:36:12,140 --> 00:36:19,070
the future so I think in Cloud Foundry I

00:36:17,020 --> 00:36:21,470
didn't quite hear the question I think

00:36:19,070 --> 00:36:22,760
I'm gonna answer it let me know it's not

00:36:21,470 --> 00:36:24,140
so I think like and when you're pushing

00:36:22,760 --> 00:36:26,770
apps to Cloud Foundry like we are

00:36:24,140 --> 00:36:29,780
running them as a very specific user

00:36:26,770 --> 00:36:31,820
inside that container cap and so we have

00:36:29,780 --> 00:36:36,590
ensured that that the UID mapping for

00:36:31,820 --> 00:36:40,190
that user exists we also with regards to

00:36:36,590 --> 00:36:42,860
the UID range we so we've got the the

00:36:40,190 --> 00:36:44,540
first mapping which is you know the root

00:36:42,860 --> 00:36:47,750
user back to Maximus

00:36:44,540 --> 00:36:49,550
but then for every other UID we actually

00:36:47,750 --> 00:36:52,670
start the range at like sixty-five

00:36:49,550 --> 00:36:56,780
thousand or something in the host yeah

00:36:52,670 --> 00:36:59,060
above nobody basically so the idea there

00:36:56,780 --> 00:37:00,800
is that hopefully it's not going to

00:36:59,060 --> 00:37:02,600
clash within it with any of the more

00:37:00,800 --> 00:37:05,570
common users new ideas that you might be

00:37:02,600 --> 00:37:08,990
running on a system so a common use

00:37:05,570 --> 00:37:11,270
cases for example in the in PHP to run

00:37:08,990 --> 00:37:14,600
the PHP interpreter with low low

00:37:11,270 --> 00:37:17,510
privilege so that if ever the app gets

00:37:14,600 --> 00:37:19,100
compromised it has limited capability

00:37:17,510 --> 00:37:24,020
for example it will not be able to make

00:37:19,100 --> 00:37:28,820
Network calls restricted system course

00:37:24,020 --> 00:37:32,450
it would be making and so currently I

00:37:28,820 --> 00:37:37,190
understand the Diego is creating vcap

00:37:32,450 --> 00:37:39,230
user so you're saying I could have some

00:37:37,190 --> 00:37:41,180
user provided scripts such as a provide

00:37:39,230 --> 00:37:44,090
a script to create new users and to

00:37:41,180 --> 00:37:49,490
restrict the way my app is running would

00:37:44,090 --> 00:37:51,260
that seem possible so I think like it

00:37:49,490 --> 00:37:53,240
depends like if you're running if you're

00:37:51,260 --> 00:37:56,400
just running like a bill park space

00:37:53,240 --> 00:37:58,230
application like you don't get any

00:37:56,400 --> 00:37:59,550
and there's no chance to customizing

00:37:58,230 --> 00:38:02,580
that like you are running as the user

00:37:59,550 --> 00:38:04,050
that Diego runs us but like with docker

00:38:02,580 --> 00:38:09,330
images and stuff you can kind of run as

00:38:04,050 --> 00:38:10,590
any any UID that you want to I'm not

00:38:09,330 --> 00:38:11,880
sure I'm totally hearing the question

00:38:10,590 --> 00:38:13,440
maybe maybe we could chat afterwards so

00:38:11,880 --> 00:38:23,690
now I think you trying to clarify but

00:38:13,440 --> 00:38:23,690
okay anyone else

00:38:26,270 --> 00:38:29,960

YouTube URL: https://www.youtube.com/watch?v=iFo1KrxdOts


