Title: Deploy my Application Across Multiple CF with Persistent Data - Vick Kelkar, Redis Labs
Publication date: 2018-10-10
Playlist: Cloud Foundry Summit Europe 2018
Description: 
	Deploy my Application Across Multiple CF with Persistent Data - Vick Kelkar, Redis Labs

We have geo-distributed teams; each using a local [P]CF
We have an internal application that needs to sync persistent data between CFs.
Two ways to solve this problem
We could have setup a GeoDNS based solution for CF, sync blobs, VPN etc
We chose to go with an active-active redis replication solution for our needs
We used a bosh-release of redis-enterprise in each CF
 Setup a geo-distributed redis cluster that takes care of replication and consistency using CRDB

So app-developers do a blue-green deploy of their app to both cloud-foundries and the redis-active-active cluster takes care of application persistent data with CRDB.

https://cfseu18.sched.com/event/FRyg/deploy-my-application-across-multiple-cf-with-persistent-data-vick-kelkar-redis-labs
Captions: 
	00:00:00,060 --> 00:00:07,400
welcome to my talk folks I am Vic Cocker

00:00:03,230 --> 00:00:09,929
today I'll be talking about how to do

00:00:07,400 --> 00:00:13,590
application development across cloud

00:00:09,929 --> 00:00:16,139
foundries so just quick poll here how

00:00:13,590 --> 00:00:19,890
many are you using cloud foundry today

00:00:16,139 --> 00:00:20,689
in dev staging prod just so I have an

00:00:19,890 --> 00:00:23,400
idea

00:00:20,689 --> 00:00:25,970
okay that's great half of you so I think

00:00:23,400 --> 00:00:30,480
hopefully you'll find this talk useful

00:00:25,970 --> 00:00:32,009
so what I plan on covering today is you

00:00:30,480 --> 00:00:34,380
know what are the challenges you are

00:00:32,009 --> 00:00:37,110
facing when you're using cloud foundry

00:00:34,380 --> 00:00:40,559
and you have multiple instances of your

00:00:37,110 --> 00:00:43,200
foundations and you know what is the

00:00:40,559 --> 00:00:46,289
potential solution around solving your

00:00:43,200 --> 00:00:48,899
data needs because you can push your

00:00:46,289 --> 00:00:51,239
applications very easily to your local

00:00:48,899 --> 00:00:54,270
cloud foundries but then how do you

00:00:51,239 --> 00:00:56,730
synchronize the data across various

00:00:54,270 --> 00:00:59,340
cloud foundries that you may have across

00:00:56,730 --> 00:01:02,100
the geographies then I'll quickly

00:00:59,340 --> 00:01:04,650
introduce Redis as a potential solution

00:01:02,100 --> 00:01:07,200
and give you a quick overview of what

00:01:04,650 --> 00:01:09,869
Redis is and how it can address your

00:01:07,200 --> 00:01:12,930
data needs and then finally I will

00:01:09,869 --> 00:01:16,320
present a walkthrough of the solution

00:01:12,930 --> 00:01:17,909
using cloud foundry and specifically I

00:01:16,320 --> 00:01:20,909
will use the pivotal cloud foundry

00:01:17,909 --> 00:01:23,520
distribution to show you what that

00:01:20,909 --> 00:01:25,979
solution looks like from Redis and Redis

00:01:23,520 --> 00:01:27,900
Enterprise perspective finally I'll

00:01:25,979 --> 00:01:31,439
leave about a couple minutes or last

00:01:27,900 --> 00:01:33,390
five minutes to open it up for questions

00:01:31,439 --> 00:01:36,840
and that will give us a good opportunity

00:01:33,390 --> 00:01:42,329
to ask any follow-on questions you may

00:01:36,840 --> 00:01:45,780
have so let me just set the stage for

00:01:42,329 --> 00:01:49,140
you on what is required or what is the

00:01:45,780 --> 00:01:52,259
challenge with doing multiple cloud

00:01:49,140 --> 00:01:54,630
foundries on a planet scale with

00:01:52,259 --> 00:01:57,930
multiple data centers involved right so

00:01:54,630 --> 00:01:59,969
in your development environments or in

00:01:57,930 --> 00:02:02,130
your staging environments production

00:01:59,969 --> 00:02:05,610
environments you may have multiple cloud

00:02:02,130 --> 00:02:08,910
foundries all of them may be within the

00:02:05,610 --> 00:02:11,750
same region or they may be spanning

00:02:08,910 --> 00:02:14,930
regions on public clouds

00:02:11,750 --> 00:02:17,830
so one of the big challenges if you're a

00:02:14,930 --> 00:02:21,380
cloud foundry user is how do you

00:02:17,830 --> 00:02:24,550
synchronize data across multiple data

00:02:21,380 --> 00:02:28,910
centers which might be running in

00:02:24,550 --> 00:02:31,610
different regions of public cloud so one

00:02:28,910 --> 00:02:34,940
of the big challenges of doing that is

00:02:31,610 --> 00:02:38,360
around data synchronization and how do

00:02:34,940 --> 00:02:42,520
you make sure that your CF applications

00:02:38,360 --> 00:02:45,560
are able to leverage the same data set

00:02:42,520 --> 00:02:48,440
but you're able to push your Cloud

00:02:45,560 --> 00:02:52,730
Foundry applications across multiple CF

00:02:48,440 --> 00:02:53,690
targets or multiple CF foundries so I

00:02:52,730 --> 00:02:55,700
think that's one of the bigger

00:02:53,690 --> 00:02:58,910
challenges when you're talking about

00:02:55,700 --> 00:03:01,910
data services in Cloud Foundry and how

00:02:58,910 --> 00:03:06,170
do you do data synchronization across

00:03:01,910 --> 00:03:08,930
regions across cloud foundries today so

00:03:06,170 --> 00:03:11,480
some of the reasons why you might want

00:03:08,930 --> 00:03:15,320
to synchronize your data across multiple

00:03:11,480 --> 00:03:18,110
cloud foundries are some of the use

00:03:15,320 --> 00:03:20,900
cases I'm highlighting here some of

00:03:18,110 --> 00:03:24,050
those are around scorecards and shopping

00:03:20,900 --> 00:03:27,080
carts that you may be using you may be

00:03:24,050 --> 00:03:29,709
using this multiple Cloud Foundry is to

00:03:27,080 --> 00:03:33,230
solve your leaderboard issues or

00:03:29,709 --> 00:03:35,810
leaderboard solution it could be related

00:03:33,230 --> 00:03:40,430
to fraud detection as well as event

00:03:35,810 --> 00:03:44,660
tracking or you might be using the likes

00:03:40,430 --> 00:03:47,450
or a recommendation system so for

00:03:44,660 --> 00:03:50,360
addressing all these use cases you want

00:03:47,450 --> 00:03:53,230
to figure out a way to synchronize your

00:03:50,360 --> 00:03:57,980
data have it be globally available

00:03:53,230 --> 00:04:00,430
across multiple cloud foundries so there

00:03:57,980 --> 00:04:03,290
are a couple challenges in the solution

00:04:00,430 --> 00:04:07,670
to the potential in a problem statement

00:04:03,290 --> 00:04:09,890
here so one of the key things when you

00:04:07,670 --> 00:04:12,500
are developing CF applications is you

00:04:09,890 --> 00:04:16,070
want to focus on the same data set

00:04:12,500 --> 00:04:18,109
across multiple cloud foundries you want

00:04:16,070 --> 00:04:20,120
to ensure that you have a very good

00:04:18,109 --> 00:04:22,789
developer experience and a user

00:04:20,120 --> 00:04:25,400
experience so you want to give the

00:04:22,789 --> 00:04:27,940
freedom for your developers to port

00:04:25,400 --> 00:04:31,550
they're Cloud Foundry applications

00:04:27,940 --> 00:04:34,729
locally quickly without having to worry

00:04:31,550 --> 00:04:38,449
about synchronization of Geo distributed

00:04:34,729 --> 00:04:41,180
teams so one of the ways you want to do

00:04:38,449 --> 00:04:44,840
that is you want to keep very low

00:04:41,180 --> 00:04:46,759
latencies for your applications by

00:04:44,840 --> 00:04:50,060
having your applications pushed out to

00:04:46,759 --> 00:04:54,830
cloud foundries that are very close to

00:04:50,060 --> 00:04:57,380
your user base and then one final thing

00:04:54,830 --> 00:05:00,050
as a big organization who has multiple

00:04:57,380 --> 00:05:02,479
cloud foundries across the planet

00:05:00,050 --> 00:05:06,590
one thing you want to do is you want to

00:05:02,479 --> 00:05:09,410
keep the delta of your application in

00:05:06,590 --> 00:05:12,169
various regions and various continents

00:05:09,410 --> 00:05:15,289
to be very small right you want to use

00:05:12,169 --> 00:05:18,380
the same code base and maybe literally

00:05:15,289 --> 00:05:19,880
change the CF target before you push the

00:05:18,380 --> 00:05:22,729
application right so you don't want to

00:05:19,880 --> 00:05:24,979
introduce any additional logic as you

00:05:22,729 --> 00:05:27,440
are trying to push your geo distributed

00:05:24,979 --> 00:05:30,860
applications across multiple cloud

00:05:27,440 --> 00:05:33,050
foundries now there are two potential

00:05:30,860 --> 00:05:37,580
possible solutions that you can leverage

00:05:33,050 --> 00:05:39,770
today in public clouds or on Prem kind

00:05:37,580 --> 00:05:42,740
of highlighting couple of them one of

00:05:39,770 --> 00:05:46,099
them is around spanner Google spanner

00:05:42,740 --> 00:05:49,010
which has a two-phase commit approach so

00:05:46,099 --> 00:05:52,849
with this approach what you are gaining

00:05:49,010 --> 00:05:55,400
is consistency but what the trade-off

00:05:52,849 --> 00:05:57,680
there is in order to achieve that you're

00:05:55,400 --> 00:05:59,990
looking at at least 200 milliseconds or

00:05:57,680 --> 00:06:02,630
higher before your data gets

00:05:59,990 --> 00:06:06,169
synchronized another approach is a

00:06:02,630 --> 00:06:09,050
quorum based approach Cassandra is one

00:06:06,169 --> 00:06:11,710
of the good examples of how you would do

00:06:09,050 --> 00:06:13,970
that at a global scale

00:06:11,710 --> 00:06:17,840
Cassandra again it's a quorum based

00:06:13,970 --> 00:06:21,080
system so it has to have majority of the

00:06:17,840 --> 00:06:24,380
participating nodes to agree before the

00:06:21,080 --> 00:06:27,020
commit is written to all the Cassandra

00:06:24,380 --> 00:06:28,940
nodes so again with this approach the

00:06:27,020 --> 00:06:30,949
quorum based approach you are looking at

00:06:28,940 --> 00:06:35,659
at least over 100 milliseconds of

00:06:30,949 --> 00:06:38,360
latency so in a typical web app you know

00:06:35,659 --> 00:06:39,320
you want very quick response times you

00:06:38,360 --> 00:06:43,010
want to have

00:06:39,320 --> 00:06:46,490
very fast data response rates so that

00:06:43,010 --> 00:06:48,050
there is no lag for your end users so if

00:06:46,490 --> 00:06:50,290
you're already looking at 200

00:06:48,050 --> 00:06:53,450
millisecond latency at your data layer

00:06:50,290 --> 00:06:55,580
it's definitely going to trickle down to

00:06:53,450 --> 00:06:58,970
your user application and it will affect

00:06:55,580 --> 00:07:02,090
your user experience so one of the

00:06:58,970 --> 00:07:04,370
things I want to focus on is I don't

00:07:02,090 --> 00:07:05,750
want the developers the Cloud Foundry

00:07:04,370 --> 00:07:10,130
developers who are writing the

00:07:05,750 --> 00:07:13,190
applications to focus on implementing

00:07:10,130 --> 00:07:15,800
the solution themselves in the code what

00:07:13,190 --> 00:07:19,010
I mean here is we don't want the

00:07:15,800 --> 00:07:21,230
developers to look at how to do the

00:07:19,010 --> 00:07:24,860
retries how to do the circuit breaker

00:07:21,230 --> 00:07:28,220
pattern and write all that in to your

00:07:24,860 --> 00:07:32,330
application logic right so we want them

00:07:28,220 --> 00:07:35,630
to focus on delivering value writing the

00:07:32,330 --> 00:07:39,830
business use case and sort of developing

00:07:35,630 --> 00:07:43,340
the app around that while we let someone

00:07:39,830 --> 00:07:48,980
else address these concerns about data

00:07:43,340 --> 00:07:51,680
replication and data synchronization so

00:07:48,980 --> 00:07:54,440
let me let me propose and tell you about

00:07:51,680 --> 00:07:59,090
a solution that is being used at Redis

00:07:54,440 --> 00:08:02,180
labs and what we are doing at Redis labs

00:07:59,090 --> 00:08:04,610
we have a Bosch based release which is

00:08:02,180 --> 00:08:09,500
implementing this solution this solution

00:08:04,610 --> 00:08:13,840
is based on CR DTS CR DTS are

00:08:09,500 --> 00:08:16,750
conflict-free replicated data types this

00:08:13,840 --> 00:08:20,150
implementation of data synchronization

00:08:16,750 --> 00:08:24,800
is based on a paper that was written by

00:08:20,150 --> 00:08:28,070
dr. Carlos in 2011 so dr. Carlos is

00:08:24,800 --> 00:08:30,410
actually on our technology board so he's

00:08:28,070 --> 00:08:32,570
advising us on how to do this data

00:08:30,410 --> 00:08:36,650
replication and conflict resolution

00:08:32,570 --> 00:08:39,219
which is purely based on Redis to solve

00:08:36,650 --> 00:08:42,440
the data needs of multiple Cloud Foundry

00:08:39,219 --> 00:08:44,570
applications one of the key things to

00:08:42,440 --> 00:08:48,280
highlight in this solution is we are

00:08:44,570 --> 00:08:51,380
achieving data replication through

00:08:48,280 --> 00:08:52,290
continuous synchronization and the data

00:08:51,380 --> 00:08:55,829
become

00:08:52,290 --> 00:08:59,399
strongly eventual consistency it reaches

00:08:55,829 --> 00:09:03,000
strong eventual consistency through the

00:08:59,399 --> 00:09:05,160
replication process now what is the

00:09:03,000 --> 00:09:07,949
advantage of this solution over the

00:09:05,160 --> 00:09:09,480
previously mentioned options you know a

00:09:07,949 --> 00:09:12,540
couple of the things to highlight here

00:09:09,480 --> 00:09:14,970
is again the data service or the

00:09:12,540 --> 00:09:18,480
database itself is doing all the heavy

00:09:14,970 --> 00:09:21,509
lifting of synchronization retry logics

00:09:18,480 --> 00:09:23,850
so that the developer the Cloud Foundry

00:09:21,509 --> 00:09:27,980
application owner doesn't have to worry

00:09:23,850 --> 00:09:32,399
about those retry logics and then the

00:09:27,980 --> 00:09:36,089
Redis is known to be very simple and

00:09:32,399 --> 00:09:38,310
fast so it is able to take care of those

00:09:36,089 --> 00:09:41,699
conflicts that you may have during data

00:09:38,310 --> 00:09:44,040
replication using the conflict

00:09:41,699 --> 00:09:48,120
resolution that's built into the CR DT

00:09:44,040 --> 00:09:52,579
approach so let me dive a little bit

00:09:48,120 --> 00:09:55,259
deeper into why active active CRD TS and

00:09:52,579 --> 00:10:00,149
active active like the name suggests is

00:09:55,259 --> 00:10:02,699
around doing the ability to write data

00:10:00,149 --> 00:10:05,750
to multiple cloud foundries at the same

00:10:02,699 --> 00:10:09,120
time so it's multi master approach

00:10:05,750 --> 00:10:12,690
active active running on multiple cloud

00:10:09,120 --> 00:10:15,449
foundries what this does for you as an

00:10:12,690 --> 00:10:19,079
app developer or app owner is it gives

00:10:15,449 --> 00:10:20,579
you local latency guarantees for your

00:10:19,079 --> 00:10:24,709
Cloud Foundry applications

00:10:20,579 --> 00:10:28,410
so each Cloud Foundry is essentially

00:10:24,709 --> 00:10:32,069
doing service binding to your own local

00:10:28,410 --> 00:10:35,010
Cloud Foundry instance thus guaranteeing

00:10:32,069 --> 00:10:37,019
you very low latencies for your

00:10:35,010 --> 00:10:40,769
applications to reach your data service

00:10:37,019 --> 00:10:43,560
and then as part of the solution what

00:10:40,769 --> 00:10:46,050
the Redis CR DT based technology is

00:10:43,560 --> 00:10:49,680
doing is it's giving you conflict

00:10:46,050 --> 00:10:52,860
resolution now built in and providing

00:10:49,680 --> 00:10:55,199
you with strong eventual consistency as

00:10:52,860 --> 00:10:59,899
you are sort of focusing more on

00:10:55,199 --> 00:11:03,209
developing your application itself so

00:10:59,899 --> 00:11:05,160
one other sort of aspects of the CR DD

00:11:03,209 --> 00:11:07,440
solution is around

00:11:05,160 --> 00:11:11,120
you know how you're gonna leverage this

00:11:07,440 --> 00:11:14,640
solution for your cloud foundries so

00:11:11,120 --> 00:11:18,630
ready Center prize is based on C R DT

00:11:14,640 --> 00:11:22,040
approach so our CR DVS are delivering

00:11:18,630 --> 00:11:24,740
you know lower local latencies for

00:11:22,040 --> 00:11:28,410
geographically distributed applications

00:11:24,740 --> 00:11:32,250
so as the diagram depicts you are able

00:11:28,410 --> 00:11:36,690
to do high throughput ingest using Redis

00:11:32,250 --> 00:11:42,510
Enterprise to your local cloud foundries

00:11:36,690 --> 00:11:44,130
while the global synchronization service

00:11:42,510 --> 00:11:47,480
in the background will take care of

00:11:44,130 --> 00:11:51,270
conflict resolution for you as well as

00:11:47,480 --> 00:11:53,970
you know take care of all the retry

00:11:51,270 --> 00:11:56,370
logic so that as a developer you don't

00:11:53,970 --> 00:12:01,860
have to worry about that particular

00:11:56,370 --> 00:12:05,460
instance another sort of quick use case

00:12:01,860 --> 00:12:07,140
and benefit of Redis enterprise with

00:12:05,460 --> 00:12:10,680
cloud foundry is it allows you to

00:12:07,140 --> 00:12:12,840
develop your Cloud Foundry micro service

00:12:10,680 --> 00:12:14,220
applications a lot quicker and a lot

00:12:12,840 --> 00:12:16,890
faster

00:12:14,220 --> 00:12:19,080
like I mentioned it makes it possible

00:12:16,890 --> 00:12:22,260
for the developer to focus on the

00:12:19,080 --> 00:12:24,870
business logic and not necessarily worry

00:12:22,260 --> 00:12:27,330
about how to go about doing the data

00:12:24,870 --> 00:12:29,730
synchronization you know all these

00:12:27,330 --> 00:12:32,070
normal patterns that you use in micro

00:12:29,730 --> 00:12:35,190
service developments like retry logic

00:12:32,070 --> 00:12:37,860
and circuit breakers patterns are

00:12:35,190 --> 00:12:40,110
something that is now offloaded to the

00:12:37,860 --> 00:12:42,170
data service and the data service will

00:12:40,110 --> 00:12:44,070
take care of the replication the

00:12:42,170 --> 00:12:46,130
synchronization and the conflict

00:12:44,070 --> 00:12:46,130
resolution

00:12:46,220 --> 00:12:53,160
so why see our DTS and what's so unique

00:12:49,980 --> 00:12:55,680
about them so see our DTS

00:12:53,160 --> 00:12:58,110
offer you active active and I think I

00:12:55,680 --> 00:13:00,720
want to emphasize this point again it is

00:12:58,110 --> 00:13:02,540
a multi master approach we call it

00:13:00,720 --> 00:13:06,300
active active so it's bi-directional

00:13:02,540 --> 00:13:08,460
it's not active passive it is master

00:13:06,300 --> 00:13:11,430
master replication so you are able to

00:13:08,460 --> 00:13:13,800
write data to both the cloud foundries

00:13:11,430 --> 00:13:15,870
at the same time and the conflict

00:13:13,800 --> 00:13:18,060
resolution and replication happens in

00:13:15,870 --> 00:13:20,370
the background

00:13:18,060 --> 00:13:23,160
another advantage of this approach is

00:13:20,370 --> 00:13:25,290
the ability to create a full mesh

00:13:23,160 --> 00:13:29,870
network of all your Cloud Foundry

00:13:25,290 --> 00:13:32,400
instances that may be spanning regions

00:13:29,870 --> 00:13:34,790
then the couple other advantages to

00:13:32,400 --> 00:13:37,050
highlight here is the Redis

00:13:34,790 --> 00:13:40,080
implementation automatically takes care

00:13:37,050 --> 00:13:43,440
of the counter deletion for you

00:13:40,080 --> 00:13:46,260
it takes care of expiry as well and then

00:13:43,440 --> 00:13:50,280
the Redis CR DT offers up conflict

00:13:46,260 --> 00:13:53,250
resolution for these five complex data

00:13:50,280 --> 00:13:55,850
types some of the easier ones may be

00:13:53,250 --> 00:13:58,620
easy to explain is the last right wins

00:13:55,850 --> 00:14:01,320
but as the data structures get complex

00:13:58,620 --> 00:14:04,380
the conflict resolution algorithm also

00:14:01,320 --> 00:14:07,980
gets complex but the Redis enterprise

00:14:04,380 --> 00:14:11,010
solution is already solving that concern

00:14:07,980 --> 00:14:15,810
for you by implementing various conflict

00:14:11,010 --> 00:14:17,820
resolution strategies before I go any

00:14:15,810 --> 00:14:21,060
further let me just briefly tell you

00:14:17,820 --> 00:14:24,420
guys about Redis how many of you here

00:14:21,060 --> 00:14:27,480
are active users of Redis today show of

00:14:24,420 --> 00:14:30,450
hands alright we got a few so this would

00:14:27,480 --> 00:14:33,330
be good to go over with the whole group

00:14:30,450 --> 00:14:35,460
here so let me tell you a little bit

00:14:33,330 --> 00:14:39,990
about Redis so Redis is an open source

00:14:35,460 --> 00:14:44,030
in memory no sequel database Redis labs

00:14:39,990 --> 00:14:46,530
is home to the Redis open source project

00:14:44,030 --> 00:14:50,430
Salvatori who's the core contributor or

00:14:46,530 --> 00:14:53,100
Redis works at Redis labs and let me

00:14:50,430 --> 00:14:55,770
tell you what are the key advantages and

00:14:53,100 --> 00:14:59,520
differentiators for Redis as a

00:14:55,770 --> 00:15:02,310
technology so we are known for three big

00:14:59,520 --> 00:15:05,580
differentiators one of them is around

00:15:02,310 --> 00:15:08,400
performance the second one is around

00:15:05,580 --> 00:15:10,740
simplicity and the third one is around

00:15:08,400 --> 00:15:14,100
extensibility and I'll kind of step into

00:15:10,740 --> 00:15:16,380
these three pillars of our product and

00:15:14,100 --> 00:15:19,080
product offering in detail in the next

00:15:16,380 --> 00:15:22,550
few slides so when we talk about

00:15:19,080 --> 00:15:26,000
performance for Redis we are looking at

00:15:22,550 --> 00:15:29,490
how do we get you the highest throughput

00:15:26,000 --> 00:15:31,060
with the lowest latency possible for

00:15:29,490 --> 00:15:34,480
your applications

00:15:31,060 --> 00:15:36,490
so the graph on the left is essentially

00:15:34,480 --> 00:15:39,040
showing you that we are able to achieve

00:15:36,490 --> 00:15:41,710
very high throughput it's very low

00:15:39,040 --> 00:15:45,880
latencies and this was a survey done by

00:15:41,710 --> 00:15:48,660
an independent benchmarking firm to kind

00:15:45,880 --> 00:15:53,830
of highlight that feature the second

00:15:48,660 --> 00:15:57,160
advantage of Redis is around how the

00:15:53,830 --> 00:15:59,860
footprint looks like for Redis so the

00:15:57,160 --> 00:16:01,630
second graph on the right is essentially

00:15:59,860 --> 00:16:03,910
highlighting the fact that in order to

00:16:01,630 --> 00:16:07,900
reach a million operations per second

00:16:03,910 --> 00:16:10,360
how many Redis instances and boss jobs

00:16:07,900 --> 00:16:13,770
will it take for you to achieve this

00:16:10,360 --> 00:16:17,440
outcome so as you can see from the graph

00:16:13,770 --> 00:16:19,630
Redis has a very small footprint and is

00:16:17,440 --> 00:16:22,090
able to deliver that performance and

00:16:19,630 --> 00:16:25,570
that you may be looking for as an app

00:16:22,090 --> 00:16:28,800
developer on Cloud Foundry the second

00:16:25,570 --> 00:16:33,310
aspect is around simplicity and Redis is

00:16:28,800 --> 00:16:36,490
no sequel database running in memory and

00:16:33,310 --> 00:16:40,750
it essentially supports data structures

00:16:36,490 --> 00:16:43,060
like the diagrams on this slide we have

00:16:40,750 --> 00:16:46,510
kind of highlighted them as Lego blocks

00:16:43,060 --> 00:16:48,910
so what these allows you to do is using

00:16:46,510 --> 00:16:51,400
these data structures or Lego blocks you

00:16:48,910 --> 00:16:54,280
are able to compose your solution and

00:16:51,400 --> 00:16:56,890
address your use case using these ten

00:16:54,280 --> 00:17:02,860
basic data structures that are available

00:16:56,890 --> 00:17:06,460
in Redis the third aspect of Redis is

00:17:02,860 --> 00:17:09,670
around extensibility what I mean here is

00:17:06,460 --> 00:17:11,920
Redis gives you those ten basic data

00:17:09,670 --> 00:17:14,230
structures but if you are trying to

00:17:11,920 --> 00:17:16,410
solve a business need and you have a

00:17:14,230 --> 00:17:19,690
case where you may need additional

00:17:16,410 --> 00:17:22,660
capability Redis allows you to extend

00:17:19,690 --> 00:17:26,800
the basic functionality of Redis through

00:17:22,660 --> 00:17:29,530
the concept of modules so modules allows

00:17:26,800 --> 00:17:32,590
you to extend the Redis capability and

00:17:29,530 --> 00:17:35,230
introduce new capabilities that can help

00:17:32,590 --> 00:17:38,200
you solve your use case I'm just

00:17:35,230 --> 00:17:41,140
highlighting couple of them here so we

00:17:38,200 --> 00:17:44,140
have four modules that we want to

00:17:41,140 --> 00:17:45,490
maintain and highlight and publish from

00:17:44,140 --> 00:17:48,309
Redis labs

00:17:45,490 --> 00:17:51,730
so ready search is a capability that you

00:17:48,309 --> 00:17:53,559
can introduce in your solution to do

00:17:51,730 --> 00:17:57,279
basic recommendation system and

00:17:53,559 --> 00:18:00,640
full-text searching graph module is

00:17:57,279 --> 00:18:03,279
about to hit GA in in the near future so

00:18:00,640 --> 00:18:06,520
that's also a capability that you can

00:18:03,279 --> 00:18:09,370
introduce in your Redis deployment on a

00:18:06,520 --> 00:18:11,200
Cloud Foundry a couple other modules -

00:18:09,370 --> 00:18:15,429
worth mentioning is around machine

00:18:11,200 --> 00:18:20,620
learning and JSON objects so lettis can

00:18:15,429 --> 00:18:26,289
also do JSON object store on your Cloud

00:18:20,620 --> 00:18:28,630
Foundry service instances so let me just

00:18:26,289 --> 00:18:31,929
quickly tell you what it looks like on a

00:18:28,630 --> 00:18:34,059
cloud foundry I was going to do a live

00:18:31,929 --> 00:18:37,029
demo but I think after I saw what

00:18:34,059 --> 00:18:40,059
happened at the keynote this morning not

00:18:37,029 --> 00:18:41,799
a lot of the demos were working so I'm

00:18:40,059 --> 00:18:44,950
going to go with the static screenshots

00:18:41,799 --> 00:18:47,980
but I will do my best to explain what's

00:18:44,950 --> 00:18:53,159
happening here so I think what you see

00:18:47,980 --> 00:18:57,399
here is Redis Enterprise deployed on a

00:18:53,159 --> 00:19:00,070
Cloud Foundry foundation that is

00:18:57,399 --> 00:19:05,230
essentially running in the u.s.

00:19:00,070 --> 00:19:08,350
continent so if you look at the red box

00:19:05,230 --> 00:19:11,559
what you will see here is I have a US

00:19:08,350 --> 00:19:14,649
Cloud Foundry foundation I have enabled

00:19:11,559 --> 00:19:18,039
the Redis slabs offering of Redis

00:19:14,649 --> 00:19:20,529
Enterprise in this Cloud Foundry I have

00:19:18,039 --> 00:19:24,580
pushed out a web application and bound

00:19:20,529 --> 00:19:29,620
my web application to the Redis service

00:19:24,580 --> 00:19:32,409
instance so I have done so the second

00:19:29,620 --> 00:19:35,860
output here is around when you push that

00:19:32,409 --> 00:19:38,169
it's a Python flask app that one of our

00:19:35,860 --> 00:19:40,539
architects have written so I've

00:19:38,169 --> 00:19:43,899
essentially pushed it out to that US

00:19:40,539 --> 00:19:47,020
Cloud Foundry did the service binding so

00:19:43,899 --> 00:19:50,770
that now you can see that my Redis web

00:19:47,020 --> 00:19:54,610
CLI is connected to the US Foundation in

00:19:50,770 --> 00:19:59,040
u.s. now I have gone through and done

00:19:54,610 --> 00:20:01,900
the similar exercise with CF

00:19:59,040 --> 00:20:05,920
foundation running in the European

00:20:01,900 --> 00:20:10,470
subcontinent so now I have to cloud

00:20:05,920 --> 00:20:15,480
foundries one in the u.s. one in Europe

00:20:10,470 --> 00:20:18,310
both have deployed this Python flask app

00:20:15,480 --> 00:20:21,370
they are bound to their local service

00:20:18,310 --> 00:20:25,140
instances and the data is getting

00:20:21,370 --> 00:20:27,850
synchronized for you in the background

00:20:25,140 --> 00:20:29,890
so I'm going to quickly walk you guys

00:20:27,850 --> 00:20:34,870
through a couple examples of what that

00:20:29,890 --> 00:20:39,490
looks like so let's start with the data

00:20:34,870 --> 00:20:41,020
structure lists in Redis so what I've

00:20:39,490 --> 00:20:44,410
done here is kind of taken screenshots

00:20:41,020 --> 00:20:47,320
of my Python flask app and I'm

00:20:44,410 --> 00:20:50,440
essentially walking you guys through the

00:20:47,320 --> 00:20:53,260
four steps to confirm that the data is

00:20:50,440 --> 00:20:57,390
getting synchronized so if you look at

00:20:53,260 --> 00:21:00,820
Box one this is in the US data center I

00:20:57,390 --> 00:21:03,370
input something into my list I do the

00:21:00,820 --> 00:21:07,090
same thing on the European cloud foundry

00:21:03,370 --> 00:21:10,990
in step two then in step three and step

00:21:07,090 --> 00:21:15,310
four I am essentially pulling up that

00:21:10,990 --> 00:21:18,010
same list and showcasing the fact that

00:21:15,310 --> 00:21:20,740
the data has been synchronized for you

00:21:18,010 --> 00:21:22,390
and by the Redis Enterprise Service in

00:21:20,740 --> 00:21:25,060
the background without you as a

00:21:22,390 --> 00:21:28,420
developer having to do any additional

00:21:25,060 --> 00:21:32,050
steps so that's a quick example of how

00:21:28,420 --> 00:21:35,830
we do it in less register data structure

00:21:32,050 --> 00:21:38,830
we have a similar concept of doing that

00:21:35,830 --> 00:21:42,450
data synchronization using another data

00:21:38,830 --> 00:21:45,550
structure called sets same concept here

00:21:42,450 --> 00:21:48,610
you know I have a four step process in

00:21:45,550 --> 00:21:52,060
the first one I'm in entering a set in

00:21:48,610 --> 00:21:55,720
the US Cloud Foundry I do the same on

00:21:52,060 --> 00:21:58,660
the second step in the European Cloud

00:21:55,720 --> 00:22:00,610
Foundry installation and step three and

00:21:58,660 --> 00:22:03,040
four are essentially showing you the

00:22:00,610 --> 00:22:06,040
fact that the sets have been

00:22:03,040 --> 00:22:09,520
synchronized across both the cloud

00:22:06,040 --> 00:22:12,250
foundries and the developer doesn't have

00:22:09,520 --> 00:22:12,640
to worry about the retry logic or any of

00:22:12,250 --> 00:22:15,340
the circuit

00:22:12,640 --> 00:22:19,000
breaker that you may have to do on a

00:22:15,340 --> 00:22:21,580
traditional development platform the

00:22:19,000 --> 00:22:23,770
third one I want to highlight is sorted

00:22:21,580 --> 00:22:28,600
sets again it's a complex data structure

00:22:23,770 --> 00:22:32,860
but same sort of steps this is a sorted

00:22:28,600 --> 00:22:36,430
set so you're seeing the step one I'm

00:22:32,860 --> 00:22:40,270
adding some data in Redis on the US side

00:22:36,430 --> 00:22:43,240
in step two I'm adding more data but on

00:22:40,270 --> 00:22:45,100
the European Cloud Foundry and step

00:22:43,240 --> 00:22:47,770
three and step four are essentially

00:22:45,100 --> 00:22:50,470
showing you the fact that without any

00:22:47,770 --> 00:22:53,500
develop developer interaction the Redis

00:22:50,470 --> 00:22:55,570
enterprise service instances are staying

00:22:53,500 --> 00:22:57,280
in synchronous you know are being

00:22:55,570 --> 00:23:00,520
synchronized in the background and

00:22:57,280 --> 00:23:04,620
you're able to use the same data set for

00:23:00,520 --> 00:23:08,200
your application needs one quick

00:23:04,620 --> 00:23:11,260
screenshot of our Redis Enterprise

00:23:08,200 --> 00:23:14,800
console so in this image what I'm trying

00:23:11,260 --> 00:23:17,400
to highlight here is the fact that you

00:23:14,800 --> 00:23:21,610
are able to see the synchronization of

00:23:17,400 --> 00:23:25,330
the Redis service instances across these

00:23:21,610 --> 00:23:28,420
two cloud foundries so where do you see

00:23:25,330 --> 00:23:31,300
the small green circular icon towards

00:23:28,420 --> 00:23:33,880
the bottom of the image what you are

00:23:31,300 --> 00:23:36,520
seeing there are the two cloud foundries

00:23:33,880 --> 00:23:40,390
that I have connected to each other so

00:23:36,520 --> 00:23:42,430
this allows you to essentially see the

00:23:40,390 --> 00:23:45,310
synchronization happening and you can

00:23:42,430 --> 00:23:48,810
collect the status of that so that you

00:23:45,310 --> 00:23:52,930
can focus on developing your application

00:23:48,810 --> 00:23:55,570
now the web interface gives you the

00:23:52,930 --> 00:23:58,960
clear indication that these two cloud

00:23:55,570 --> 00:24:01,060
foundries are in sync but we also have a

00:23:58,960 --> 00:24:04,330
REST API so if you are trying to

00:24:01,060 --> 00:24:07,390
automate the Status collection of the

00:24:04,330 --> 00:24:10,750
synchronization of data you can hit the

00:24:07,390 --> 00:24:15,040
REST API endpoint and you can automate

00:24:10,750 --> 00:24:17,530
the status update of your data and you

00:24:15,040 --> 00:24:19,810
know set up any triggers or alerts for

00:24:17,530 --> 00:24:24,730
your follow-on sequence of Cloud Foundry

00:24:19,810 --> 00:24:26,820
applications so in quick summary I just

00:24:24,730 --> 00:24:31,780
wanted to highlight the fact

00:24:26,820 --> 00:24:35,050
using CR DTS we are able to take care of

00:24:31,780 --> 00:24:38,380
the data synchronization based on these

00:24:35,050 --> 00:24:42,100
five data structures and you're able to

00:24:38,380 --> 00:24:45,070
achieve the outcome here of achieving

00:24:42,100 --> 00:24:48,580
strong eventual consistency for your

00:24:45,070 --> 00:24:51,610
data for your Cloud Foundry applications

00:24:48,580 --> 00:24:54,580
running on different continents or

00:24:51,610 --> 00:24:58,780
across different regions in Cloud

00:24:54,580 --> 00:25:00,930
Foundry ecosystem this slide is

00:24:58,780 --> 00:25:04,120
essentially giving you links to our

00:25:00,930 --> 00:25:07,390
paper on which the technology is based

00:25:04,120 --> 00:25:10,330
and you're welcome to download it from

00:25:07,390 --> 00:25:14,200
the pivotal Network and give it a try

00:25:10,330 --> 00:25:18,580
and try out our CR DB based solution for

00:25:14,200 --> 00:25:21,250
Cloud Foundry so that's pretty much it

00:25:18,580 --> 00:25:25,000
I do want to open it up to questions at

00:25:21,250 --> 00:25:27,430
this point so I will have my wonderful

00:25:25,000 --> 00:25:29,230
assistant here running around with a mic

00:25:27,430 --> 00:25:31,000
so if you guys have any questions I'll

00:25:29,230 --> 00:25:33,090
be happy to take a few questions at this

00:25:31,000 --> 00:25:33,090
point

00:25:38,800 --> 00:25:44,200
hi hi

00:25:41,920 --> 00:25:47,110
so you mentioned at the beginning of a

00:25:44,200 --> 00:25:48,900
presentation that other solutions ensure

00:25:47,110 --> 00:25:51,700
consistency by

00:25:48,900 --> 00:25:54,070
two-phase comments or some quorum

00:25:51,700 --> 00:25:56,730
approaches how do you ensure consistency

00:25:54,070 --> 00:25:59,680
because this some probably somehow

00:25:56,730 --> 00:26:02,770
included in this sea oddity concept but

00:25:59,680 --> 00:26:04,630
for me it wasn't clear how you doing

00:26:02,770 --> 00:26:06,630
sure the consistency because it seems

00:26:04,630 --> 00:26:09,520
like it's a more replication based

00:26:06,630 --> 00:26:11,590
approach to sync the data right yeah no

00:26:09,520 --> 00:26:15,250
that's a good question so actually the

00:26:11,590 --> 00:26:17,350
answer lies on the fact that you know

00:26:15,250 --> 00:26:21,010
you're talking about geographically

00:26:17,350 --> 00:26:24,430
distributed systems so the data has to

00:26:21,010 --> 00:26:26,110
traverse across the continent so it's an

00:26:24,430 --> 00:26:30,400
event-based system so it's continuously

00:26:26,110 --> 00:26:32,260
synchronizing but the the rate of which

00:26:30,400 --> 00:26:34,570
it synchronizes depends on your

00:26:32,260 --> 00:26:36,670
architecture itself so if they are

00:26:34,570 --> 00:26:38,850
within the same continent the

00:26:36,670 --> 00:26:41,860
synchronization will happen a lot faster

00:26:38,850 --> 00:26:45,160
in my example it had to go all the way

00:26:41,860 --> 00:26:48,400
from u.s. west coast to you know Ireland

00:26:45,160 --> 00:26:50,500
so it took a little bit longer so the

00:26:48,400 --> 00:26:52,210
answer to your question is it is an

00:26:50,500 --> 00:26:55,720
event-based it is a continuous

00:26:52,210 --> 00:27:00,160
replication and synchronization but the

00:26:55,720 --> 00:27:03,160
actual consistency is achieved based on

00:27:00,160 --> 00:27:06,760
the geographical distances so it's a

00:27:03,160 --> 00:27:08,940
variable number it is based on vector

00:27:06,760 --> 00:27:12,090
clocks and we are able to achieve that

00:27:08,940 --> 00:27:12,090
using that

00:27:15,990 --> 00:27:24,330
all right one more two more all right

00:27:21,510 --> 00:27:27,870
just now I'm in a dangerous but in

00:27:24,330 --> 00:27:30,590
between lunch and my question so let's

00:27:27,870 --> 00:27:33,510
see if we can wrap it up very short one

00:27:30,590 --> 00:27:34,790
yet question with respect with

00:27:33,510 --> 00:27:39,300
developers

00:27:34,790 --> 00:27:41,550
I've able to align multiple insert of

00:27:39,300 --> 00:27:43,830
modification inside the transaction or

00:27:41,550 --> 00:27:46,710
is it's only single transaction which

00:27:43,830 --> 00:27:48,180
can benefit from see oddity yeah I mean

00:27:46,710 --> 00:27:50,420
right now we're starting off with a

00:27:48,180 --> 00:27:53,850
single transaction but Redis itself

00:27:50,420 --> 00:27:55,530
supports multi exact blocks but right

00:27:53,850 --> 00:27:58,140
now we are focusing on getting these

00:27:55,530 --> 00:28:01,560
basic data structures down for the CR

00:27:58,140 --> 00:28:03,840
DTS and the eventual goal is to continue

00:28:01,560 --> 00:28:14,360
that effort that is traditionally

00:28:03,840 --> 00:28:17,250
supported by Redis all right going once

00:28:14,360 --> 00:28:18,180
twice all right thanks everyone have a

00:28:17,250 --> 00:28:22,479
good lunch

00:28:18,180 --> 00:28:22,479

YouTube URL: https://www.youtube.com/watch?v=6LgjS41rh_M


