Title: Buildpacks Can Be Better - Stephen Levine & Tyler Phelan, Pivotal
Publication date: 2018-10-10
Playlist: Cloud Foundry Summit Europe 2018
Description: 
	Buildpacks Can Be Better - Stephen Levine & Tyler Phelan, Pivotal

Wouldn't it be great if buildpacks were faster, more flexible, and more transparent -- but just as easy to use? This talk will detail the next generation buildpack API and the future of the buildpack model. Pivotal and Heroku are collaborating on a new buildpack API to serve as the model for buildpack-based platforms. Exciting new features include layer caching, surgical droplet updates, stack management, dependency management, and other improvements to speed up build times and offer a better experience to app developers.

https://cfseu18.sched.com/event/FRyB/buildpacks-can-be-better-stephen-levine-tyler-phelan-pivotal
Captions: 
	00:00:00,030 --> 00:00:06,629
my name is Tyler and this is Steven and

00:00:02,429 --> 00:00:09,630
today we are talking about Bill packs so

00:00:06,629 --> 00:00:11,420
what our bill packs I think some of us

00:00:09,630 --> 00:00:14,460
are familiar with this scenario

00:00:11,420 --> 00:00:17,940
developer creates an application runs a

00:00:14,460 --> 00:00:21,600
CF push maybe this is a ruby app our

00:00:17,940 --> 00:00:23,789
build pack is going to run install Ruby

00:00:21,600 --> 00:00:25,140
install a version of Ruby and we're

00:00:23,789 --> 00:00:26,970
going to get a running application on

00:00:25,140 --> 00:00:30,900
Cloud Foundry pretty simple

00:00:26,970 --> 00:00:33,149
well we on the build packs team we love

00:00:30,900 --> 00:00:34,860
build packs we love this model there are

00:00:33,149 --> 00:00:37,040
a lot of reasons that we really love

00:00:34,860 --> 00:00:37,040
this

00:00:37,950 --> 00:00:41,969
first of all build packs are an

00:00:39,510 --> 00:00:44,280
opinionated build this means we get this

00:00:41,969 --> 00:00:45,510
really nice consistent application

00:00:44,280 --> 00:00:48,140
environment structure across the

00:00:45,510 --> 00:00:50,129
organization our apps look the same

00:00:48,140 --> 00:00:53,820
because of this nice consistency

00:00:50,129 --> 00:00:57,750
security is a really primary concern as

00:00:53,820 --> 00:01:01,350
a part of the bill pack model this model

00:00:57,750 --> 00:01:05,280
allows us to easily roll and update our

00:01:01,350 --> 00:01:06,780
applications quickly and we also don't

00:01:05,280 --> 00:01:08,880
feel limited by this model we still have

00:01:06,780 --> 00:01:12,770
flexibility we can still use all of our

00:01:08,880 --> 00:01:16,409
favorite languages tools frameworks and

00:01:12,770 --> 00:01:18,030
of course we're always trying to help

00:01:16,409 --> 00:01:21,869
the operators and power operators and

00:01:18,030 --> 00:01:23,100
allow developers to develop so thinking

00:01:21,869 --> 00:01:26,880
about this let's take a look at an

00:01:23,100 --> 00:01:29,040
alternative to build packs a really

00:01:26,880 --> 00:01:31,979
popular alternative in the application

00:01:29,040 --> 00:01:33,170
build is the docker file model there are

00:01:31,979 --> 00:01:38,040
a lot of good things about docker files

00:01:33,170 --> 00:01:40,710
docker files are really flexible it's

00:01:38,040 --> 00:01:43,890
really easy to add dependencies change

00:01:40,710 --> 00:01:46,170
up your application image these docker

00:01:43,890 --> 00:01:47,850
files create container images there's a

00:01:46,170 --> 00:01:50,430
lot of great things about those they

00:01:47,850 --> 00:01:53,909
container images come with immutable

00:01:50,430 --> 00:01:56,009
container layers so we know that the

00:01:53,909 --> 00:01:58,890
code that we are testing against is the

00:01:56,009 --> 00:02:01,380
same code that we are deploying it's

00:01:58,890 --> 00:02:03,390
also a straightforward model pretty easy

00:02:01,380 --> 00:02:04,770
to pick up and we also can easily tell

00:02:03,390 --> 00:02:06,750
what's going inside these docker files

00:02:04,770 --> 00:02:10,500
we're writing it out line by line but

00:02:06,750 --> 00:02:13,110
it's not all good some of the issues

00:02:10,500 --> 00:02:14,490
with this model comes up

00:02:13,110 --> 00:02:17,460
when specifically when we're creating

00:02:14,490 --> 00:02:22,650
amp images and also a lot in the

00:02:17,460 --> 00:02:24,270
enterprise world because we're creating

00:02:22,650 --> 00:02:26,580
app images the dependencies in our

00:02:24,270 --> 00:02:29,310
environments are locked behind other

00:02:26,580 --> 00:02:31,170
docker files because we are using docker

00:02:29,310 --> 00:02:33,510
files on top of docker files and layers

00:02:31,170 --> 00:02:35,340
on top of layers so if we want to patch

00:02:33,510 --> 00:02:39,510
a dependency at the bottom layer we need

00:02:35,340 --> 00:02:41,550
to rebuild layers on top of those doctor

00:02:39,510 --> 00:02:44,490
files are so flexible that it's pretty

00:02:41,550 --> 00:02:46,490
hard to create a consistent structure

00:02:44,490 --> 00:02:51,450
across the organization for these apps

00:02:46,490 --> 00:02:53,550
and because the in consistency it is

00:02:51,450 --> 00:02:58,170
harder to keep those secure and update

00:02:53,550 --> 00:02:59,790
all those dependencies again because of

00:02:58,170 --> 00:03:02,310
that consistency it's harder for

00:02:59,790 --> 00:03:03,900
operators to control the contents of all

00:03:02,310 --> 00:03:05,910
the apps across the organization and

00:03:03,900 --> 00:03:08,850
therefore harder for them to audit those

00:03:05,910 --> 00:03:11,430
apps so let's take a look at what this

00:03:08,850 --> 00:03:13,770
might look like here is a pretty typical

00:03:11,430 --> 00:03:16,050
docker file application based

00:03:13,770 --> 00:03:19,200
application we're going to be starting

00:03:16,050 --> 00:03:21,660
at the OS level OS layer at the at the

00:03:19,200 --> 00:03:24,780
bottom where we are installing any OS

00:03:21,660 --> 00:03:26,490
level packages maybe open SSL maybe like

00:03:24,780 --> 00:03:28,920
a my sequel connector if we want to use

00:03:26,490 --> 00:03:31,610
that and then our next level our next

00:03:28,920 --> 00:03:34,310
layer is gonna install nodejs

00:03:31,610 --> 00:03:36,270
let's say we're using a node app here

00:03:34,310 --> 00:03:39,030
we're gonna stall nodejs

00:03:36,270 --> 00:03:40,800
we're gonna pull from that previous

00:03:39,030 --> 00:03:41,340
stocker file and finally on the top

00:03:40,800 --> 00:03:43,320
layer

00:03:41,340 --> 00:03:45,600
we're gonna install our app run npm

00:03:43,320 --> 00:03:50,250
install we have a running application a

00:03:45,600 --> 00:03:52,590
nice note app well what happens when we

00:03:50,250 --> 00:03:55,290
give the developers a little bit of

00:03:52,590 --> 00:03:56,790
flexibility here let's say the developer

00:03:55,290 --> 00:03:58,860
developers are all managing their own

00:03:56,790 --> 00:04:02,730
application images so everyone is going

00:03:58,860 --> 00:04:03,900
to choose their own base image for their

00:04:02,730 --> 00:04:05,670
app they're gonna choose their favorite

00:04:03,900 --> 00:04:07,830
operating system they're gonna pick the

00:04:05,670 --> 00:04:10,290
packages that they want and then maybe

00:04:07,830 --> 00:04:12,330
everyone is installing their their node

00:04:10,290 --> 00:04:13,410
layer as well differently as well maybe

00:04:12,330 --> 00:04:14,850
they're solving different versions of

00:04:13,410 --> 00:04:16,980
node and finally they're installing

00:04:14,850 --> 00:04:19,560
their apps on top of that so we've got

00:04:16,980 --> 00:04:22,260
alleged a lot of divergence here already

00:04:19,560 --> 00:04:24,660
what happens when we look or Douai

00:04:22,260 --> 00:04:25,690
org-wide we've got lots of applications

00:04:24,660 --> 00:04:28,240
running

00:04:25,690 --> 00:04:31,510
well now we have chaos and we have lots

00:04:28,240 --> 00:04:34,780
of different applications on top of node

00:04:31,510 --> 00:04:37,510
layers on top of OS packages well what

00:04:34,780 --> 00:04:39,940
happens when that OS level cv comes in

00:04:37,510 --> 00:04:42,880
open SSL has a critical cv we need to

00:04:39,940 --> 00:04:45,880
patch this right away well in this

00:04:42,880 --> 00:04:48,280
scenario an operator could rebuild that

00:04:45,880 --> 00:04:50,470
OS image image layer but it's more

00:04:48,280 --> 00:04:54,160
likely that that operator is going to

00:04:50,470 --> 00:04:58,210
wait for the downstream package to get

00:04:54,160 --> 00:05:00,340
updated and it'll pull that one in so

00:04:58,210 --> 00:05:02,350
after it updates the OS layer it's gonna

00:05:00,340 --> 00:05:04,780
have to update each individual nodejs

00:05:02,350 --> 00:05:06,010
layer and finally the developer can

00:05:04,780 --> 00:05:08,700
rebuild their apps on top of those

00:05:06,010 --> 00:05:14,890
layers test all of those redeploy them

00:05:08,700 --> 00:05:17,320
and this scenario may take something it

00:05:14,890 --> 00:05:20,920
may be like months but in reality it may

00:05:17,320 --> 00:05:23,790
never get patched across the org maybe

00:05:20,920 --> 00:05:25,900
we're not doing it exactly this

00:05:23,790 --> 00:05:27,730
inconsistently maybe we're doing doclet

00:05:25,900 --> 00:05:31,120
files a little bit more the right way

00:05:27,730 --> 00:05:33,430
where we have a consistent organization

00:05:31,120 --> 00:05:35,560
image for the OS layer and the nodejs

00:05:33,430 --> 00:05:38,230
layer we are using good practice and

00:05:35,560 --> 00:05:41,200
making sure all teams are using the same

00:05:38,230 --> 00:05:42,400
OS same version of node and they're

00:05:41,200 --> 00:05:47,080
building their apps on top of that

00:05:42,400 --> 00:05:50,050
well CVA comes in operators are going to

00:05:47,080 --> 00:05:52,990
wait for downstream to build that one OS

00:05:50,050 --> 00:05:55,060
level image rebuild the nodejs image and

00:05:52,990 --> 00:05:58,570
then all the apps on top of that this

00:05:55,060 --> 00:06:00,550
scenario is better but still not great

00:05:58,570 --> 00:06:02,380
maybe this gets rolled depending on how

00:06:00,550 --> 00:06:04,330
long these builds take and the testing

00:06:02,380 --> 00:06:08,020
and the redeploying maybe this takes a

00:06:04,330 --> 00:06:10,390
few days maybe longer so let's take a

00:06:08,020 --> 00:06:12,430
look at the build pack model Cloud

00:06:10,390 --> 00:06:14,669
Foundry we start with our staging

00:06:12,430 --> 00:06:17,380
container which contains the build pack

00:06:14,669 --> 00:06:19,180
we are going to stream in our

00:06:17,380 --> 00:06:21,180
application our developer application

00:06:19,180 --> 00:06:23,760
the build pack is can inspect the app

00:06:21,180 --> 00:06:26,320
figure out what dependencies it needs

00:06:23,760 --> 00:06:26,770
using this nodejs example or an install

00:06:26,320 --> 00:06:28,930
node

00:06:26,770 --> 00:06:32,230
we're gonna run npm install get the NPM

00:06:28,930 --> 00:06:34,650
packages we're gonna tar up that those

00:06:32,230 --> 00:06:37,360
layers into what's called a droplet

00:06:34,650 --> 00:06:41,650
export that out of the staging container

00:06:37,360 --> 00:06:43,450
and next we are going to provision the

00:06:41,650 --> 00:06:45,729
Missis at the desired number of running

00:06:43,450 --> 00:06:47,880
containers and those running those

00:06:45,729 --> 00:06:50,740
launch containers are going to contain

00:06:47,880 --> 00:06:55,030
packages supplied by the platform root

00:06:50,740 --> 00:06:57,729
FS the droplet is going to get streamed

00:06:55,030 --> 00:06:59,229
into the launch containers the platform

00:06:57,729 --> 00:07:02,110
will invoke the start command and we

00:06:59,229 --> 00:07:05,050
have our running apps so we can easily

00:07:02,110 --> 00:07:08,500
tell that with this build pack we are

00:07:05,050 --> 00:07:10,300
able to take care of the inconsistencies

00:07:08,500 --> 00:07:12,550
that arise from the docker file model

00:07:10,300 --> 00:07:18,729
take care of the node.js level take care

00:07:12,550 --> 00:07:20,950
of the operating system level so sorry

00:07:18,729 --> 00:07:23,130
so Cloud Foundry has a really

00:07:20,950 --> 00:07:24,910
interesting way of dealing with

00:07:23,130 --> 00:07:27,340
vulnerabilities when they occur in

00:07:24,910 --> 00:07:29,229
operating system packages and it sort of

00:07:27,340 --> 00:07:31,750
ties into the infrastructure for how

00:07:29,229 --> 00:07:34,720
Cloud Foundry is you know runs on top of

00:07:31,750 --> 00:07:37,210
VMs so this is a Diego cell and you can

00:07:34,720 --> 00:07:38,350
see it has multiple apps on it they

00:07:37,210 --> 00:07:41,320
could be different droplets they can be

00:07:38,350 --> 00:07:43,900
the same and has operating system

00:07:41,320 --> 00:07:45,610
packages for the containers for the

00:07:43,900 --> 00:07:47,919
stack which is like the container root

00:07:45,610 --> 00:07:50,500
FS and it has operating system packages

00:07:47,919 --> 00:07:52,210
for the VM to run the Diego tow sort of

00:07:50,500 --> 00:07:54,550
support the Diego components themselves

00:07:52,210 --> 00:07:56,710
as they run so when a vulnerability hits

00:07:54,550 --> 00:07:58,870
you have a whole bunch of digo cells and

00:07:56,710 --> 00:08:01,150
they have some vulnerability in them in

00:07:58,870 --> 00:08:02,979
the operating system layers and to patch

00:08:01,150 --> 00:08:05,640
this the platform sort of one by one

00:08:02,979 --> 00:08:08,320
starts a new Diego cell with the

00:08:05,640 --> 00:08:11,500
duplicate apps from one of the old

00:08:08,320 --> 00:08:13,510
outdated Diego cells that has new where

00:08:11,500 --> 00:08:15,400
the new cell has new operating system

00:08:13,510 --> 00:08:17,229
packages both for the stack the

00:08:15,400 --> 00:08:19,990
container root FS and the stem cell the

00:08:17,229 --> 00:08:22,360
VM and then it takes the old cell down

00:08:19,990 --> 00:08:24,370
and so it kind of runs through each cell

00:08:22,360 --> 00:08:26,169
and brings us new cells up and takes old

00:08:24,370 --> 00:08:28,360
cells down until the whole platform is

00:08:26,169 --> 00:08:30,220
patched this is kind of really nice and

00:08:28,360 --> 00:08:31,270
Cloud Foundry because it lets us kind of

00:08:30,220 --> 00:08:33,190
take advantage of the way the

00:08:31,270 --> 00:08:34,959
infrastructure looks in order to patch

00:08:33,190 --> 00:08:36,820
security vulnerabilities and an

00:08:34,959 --> 00:08:38,709
operating system packages sort of live

00:08:36,820 --> 00:08:40,479
in production for a very large platform

00:08:38,709 --> 00:08:42,250
and a couple of hours it's sort of very

00:08:40,479 --> 00:08:44,320
consistent and of course we only do this

00:08:42,250 --> 00:08:45,970
for the operating system packages that

00:08:44,320 --> 00:08:47,709
have that sort of ABI compatibility

00:08:45,970 --> 00:08:49,070
contract and only with operating system

00:08:47,709 --> 00:08:51,710
packages that are

00:08:49,070 --> 00:08:54,050
patched by upstream vendors in sort of

00:08:51,710 --> 00:08:56,120
safe ways so it's we've never had a

00:08:54,050 --> 00:08:57,940
report of this causing problems or app

00:08:56,120 --> 00:09:00,110
behavior changes in an undesirable way

00:08:57,940 --> 00:09:01,670
so that's a so we're pretty exciting

00:09:00,110 --> 00:09:04,970
advantage of build packs that people

00:09:01,670 --> 00:09:06,260
don't think about too much so again you

00:09:04,970 --> 00:09:07,370
know as Tyler said we like build packs

00:09:06,260 --> 00:09:08,120
because they're opinionated they're

00:09:07,370 --> 00:09:10,430
secure

00:09:08,120 --> 00:09:11,660
you have nice security benefits they

00:09:10,430 --> 00:09:13,640
provide a little different languages

00:09:11,660 --> 00:09:14,900
they provide a lot of operator control

00:09:13,640 --> 00:09:16,940
which is really important and make

00:09:14,900 --> 00:09:19,730
developers lives easier but there are

00:09:16,940 --> 00:09:21,710
problems too so this sort of droplet

00:09:19,730 --> 00:09:23,180
model involves a lot of data transfer

00:09:21,710 --> 00:09:25,040
that's probably not necessary we build

00:09:23,180 --> 00:09:27,650
droplets and then we transfer the same

00:09:25,040 --> 00:09:29,030
droplets to the you know Diego vm's you

00:09:27,650 --> 00:09:31,700
know many times but when we don't really

00:09:29,030 --> 00:09:33,290
need to necessarily we rebuild a lot of

00:09:31,700 --> 00:09:35,540
stuff every time even if we don't need

00:09:33,290 --> 00:09:37,460
to and that's a simple build pack model

00:09:35,540 --> 00:09:38,840
where we're building a brand new droplet

00:09:37,460 --> 00:09:41,060
on each rebuild and there's there's some

00:09:38,840 --> 00:09:42,740
caching but it's pretty inefficient it's

00:09:41,060 --> 00:09:45,650
sort of a simple form of caching we have

00:09:42,740 --> 00:09:49,130
right now so we've been working on a new

00:09:45,650 --> 00:09:50,830
build pack contract along with Heroku

00:09:49,130 --> 00:09:52,790
it's sort of this is like a

00:09:50,830 --> 00:09:54,080
collaborative engineering effort where

00:09:52,790 --> 00:09:57,140
we have contributions from pivotal in

00:09:54,080 --> 00:09:59,180
Heroku it's called cloud native build

00:09:57,140 --> 00:10:01,600
packs it actually just entered the CNC F

00:09:59,180 --> 00:10:06,140
last week that's really exciting thing

00:10:01,600 --> 00:10:08,030
the this new contract has some really

00:10:06,140 --> 00:10:09,710
key changes over the previous one it's

00:10:08,030 --> 00:10:10,300
sort of a complete break away from what

00:10:09,710 --> 00:10:14,180
we had before

00:10:10,300 --> 00:10:16,760
it creates portable OCI images uses

00:10:14,180 --> 00:10:18,740
separate build and run images so you can

00:10:16,760 --> 00:10:20,270
have you know compilers and stuff on one

00:10:18,740 --> 00:10:22,970
image but not have that in your final

00:10:20,270 --> 00:10:25,300
container the detection process gets a

00:10:22,970 --> 00:10:27,500
lot more advanced so detection involves

00:10:25,300 --> 00:10:29,690
you know looking through the application

00:10:27,500 --> 00:10:31,310
and figuring out what dependencies need

00:10:29,690 --> 00:10:33,200
to get supplied and creating a plan for

00:10:31,310 --> 00:10:35,630
the build ahead of time which has a lot

00:10:33,200 --> 00:10:37,250
of benefits it also kind of serves as a

00:10:35,630 --> 00:10:41,150
bill of materials for the container

00:10:37,250 --> 00:10:42,950
afterwards the it has Bill peg groups

00:10:41,150 --> 00:10:44,240
that allow for multi detection so we can

00:10:42,950 --> 00:10:45,380
pick a bunch of different build packs

00:10:44,240 --> 00:10:46,550
that apply to your app without you

00:10:45,380 --> 00:10:47,990
having to think about that ahead of time

00:10:46,550 --> 00:10:49,760
and we can break the build packs down

00:10:47,990 --> 00:10:51,170
into really small pieces that just do

00:10:49,760 --> 00:10:53,180
you know instead of a node build pack

00:10:51,170 --> 00:10:54,890
we're gonna have a NPM build pack and a

00:10:53,180 --> 00:10:56,600
yarn build pack and a node build pack

00:10:54,890 --> 00:10:58,850
and then individual build packs for

00:10:56,600 --> 00:11:00,470
different you know partners or

00:10:58,850 --> 00:11:01,690
extensions that you might want to your

00:11:00,470 --> 00:11:03,850
app

00:11:01,690 --> 00:11:06,160
and I think most importantly this lits

00:11:03,850 --> 00:11:09,610
leverages some really kind of new

00:11:06,160 --> 00:11:11,710
features of the OCI image format and new

00:11:09,610 --> 00:11:13,540
features of docker registries to really

00:11:11,710 --> 00:11:14,890
efficiently update just individual

00:11:13,540 --> 00:11:17,530
layers on a registry they need to get

00:11:14,890 --> 00:11:19,840
updated we don't we don't have to you

00:11:17,530 --> 00:11:22,270
know rebuild lower layers in order to

00:11:19,840 --> 00:11:23,770
rebuild higher layers with it with OCI

00:11:22,270 --> 00:11:25,930
which is something how many people know

00:11:23,770 --> 00:11:29,530
about I'll talk more about those a

00:11:25,930 --> 00:11:31,120
little bit later in the presentation so

00:11:29,530 --> 00:11:33,460
let's take a look at some of these

00:11:31,120 --> 00:11:35,350
changes a little bit more in depth so if

00:11:33,460 --> 00:11:37,810
you remember the droplet that we were

00:11:35,350 --> 00:11:39,400
creating during staging before we've

00:11:37,810 --> 00:11:42,100
gotten rid of that we're using OCI

00:11:39,400 --> 00:11:44,530
images there's a lot of really nice

00:11:42,100 --> 00:11:49,480
benefits to this right off the bat we

00:11:44,530 --> 00:11:51,730
get a layered digest for each of the

00:11:49,480 --> 00:11:53,170
different layers and this is you know

00:11:51,730 --> 00:11:55,660
contractually associated with the

00:11:53,170 --> 00:11:57,400
contents of each layer so we can easily

00:11:55,660 --> 00:12:01,600
audit our applications make sure things

00:11:57,400 --> 00:12:04,510
haven't changed not only that those eye

00:12:01,600 --> 00:12:06,880
images are very portable we can run

00:12:04,510 --> 00:12:09,370
these images on all over the place a lot

00:12:06,880 --> 00:12:13,570
of different places really makes it nice

00:12:09,370 --> 00:12:15,880
to abstract that so let's take a look at

00:12:13,570 --> 00:12:18,970
the actual change of the implementation

00:12:15,880 --> 00:12:21,160
of Bill pecks so on the left you'll see

00:12:18,970 --> 00:12:22,750
the old build pack of an interface this

00:12:21,160 --> 00:12:25,360
is how we used to develop both packs we

00:12:22,750 --> 00:12:28,420
would have four separate executables

00:12:25,360 --> 00:12:31,090
these would all run in order and we've

00:12:28,420 --> 00:12:32,800
reduced that down to two we think that

00:12:31,090 --> 00:12:34,540
we don't need this extra complication

00:12:32,800 --> 00:12:36,910
and we hope that this simplification

00:12:34,540 --> 00:12:40,030
makes it easier for people to write

00:12:36,910 --> 00:12:42,370
their own custom build packs not only

00:12:40,030 --> 00:12:45,250
that but another another interesting

00:12:42,370 --> 00:12:48,070
part is that previously the detection

00:12:45,250 --> 00:12:51,640
script was usually generally a pretty

00:12:48,070 --> 00:12:55,060
minimal step that would return 0 or 1

00:12:51,640 --> 00:12:56,470
depending on whether the build pack

00:12:55,060 --> 00:12:58,870
should be used for the application well

00:12:56,470 --> 00:13:00,760
now the detection is going to do have a

00:12:58,870 --> 00:13:02,290
little bit more responsibility it's

00:13:00,760 --> 00:13:05,140
going to reach into that app and figure

00:13:02,290 --> 00:13:08,950
out a build plan for the subsequent

00:13:05,140 --> 00:13:10,870
steps to run based on those contents of

00:13:08,950 --> 00:13:13,400
the app and we'll see that come up more

00:13:10,870 --> 00:13:17,330
so because of this

00:13:13,400 --> 00:13:22,640
change we are able to create a new way

00:13:17,330 --> 00:13:24,260
of doing multiple build packs so we have

00:13:22,640 --> 00:13:26,690
this new concept for multiple build

00:13:24,260 --> 00:13:28,190
packs called a build pack group and this

00:13:26,690 --> 00:13:32,000
is going to be how a lot of build packs

00:13:28,190 --> 00:13:34,400
are kind of thought of in the new API so

00:13:32,000 --> 00:13:38,270
let's take an example of a ruby and

00:13:34,400 --> 00:13:40,370
node.js app pretty common scenario so

00:13:38,270 --> 00:13:42,080
we've got our build pack group which we

00:13:40,370 --> 00:13:44,630
have defined as a ruby build pack and a

00:13:42,080 --> 00:13:47,630
node build pack we have our application

00:13:44,630 --> 00:13:51,290
code first thing that's going to happen

00:13:47,630 --> 00:13:53,170
during staging is the detection script

00:13:51,290 --> 00:13:56,420
is going to inspect the application code

00:13:53,170 --> 00:13:58,400
it's gonna say okay great this is a ruby

00:13:56,420 --> 00:14:00,470
app you should use this build pack I'm

00:13:58,400 --> 00:14:02,570
going to return 0 I'm also going to

00:14:00,470 --> 00:14:05,600
contribute a build plan I think we need

00:14:02,570 --> 00:14:07,250
to contribute a ruby version and maybe I

00:14:05,600 --> 00:14:10,010
might provide metadata along with that

00:14:07,250 --> 00:14:12,080
for the build steps as well we're gonna

00:14:10,010 --> 00:14:14,660
move on now to the next build pack in

00:14:12,080 --> 00:14:17,120
the group this build pack says yes this

00:14:14,660 --> 00:14:20,120
is also a node.js build pack our

00:14:17,120 --> 00:14:22,490
application so we are going to return 0

00:14:20,120 --> 00:14:24,890
and I'm also going to contribute to the

00:14:22,490 --> 00:14:28,190
same build plan and let you know what

00:14:24,890 --> 00:14:31,550
versions of node what I also want to

00:14:28,190 --> 00:14:34,400
contribute to this app environment so

00:14:31,550 --> 00:14:35,630
after that the build different we're

00:14:34,400 --> 00:14:37,730
gonna go back to the Ruby build pack

00:14:35,630 --> 00:14:39,410
which is going to run its build step

00:14:37,730 --> 00:14:42,589
it's gonna read from this build plan

00:14:39,410 --> 00:14:44,630
it's gonna create every B layer because

00:14:42,589 --> 00:14:47,300
it knows it needs a version of Ruby it's

00:14:44,630 --> 00:14:49,700
gonna run bundle install Datchet extra

00:14:47,300 --> 00:14:51,350
probably told it to do that and then

00:14:49,700 --> 00:14:53,060
we're gonna move over to the node.js

00:14:51,350 --> 00:14:55,880
build pack it's gonna read from the

00:14:53,060 --> 00:14:59,150
build plan during build create the

00:14:55,880 --> 00:15:03,350
node.js layer run npm install get some

00:14:59,150 --> 00:15:05,360
node modules so one of the things that's

00:15:03,350 --> 00:15:07,700
really nice about this change is that

00:15:05,360 --> 00:15:09,800
we're finding that making these bill

00:15:07,700 --> 00:15:12,850
packs really modular it's a really

00:15:09,800 --> 00:15:15,650
powerful thing because we are able to

00:15:12,850 --> 00:15:17,990
reduce the depends the dependencies that

00:15:15,650 --> 00:15:20,300
we need only to the applications that

00:15:17,990 --> 00:15:23,930
really need them we're able to reduce a

00:15:20,300 --> 00:15:26,089
bit of resource usage there so in this

00:15:23,930 --> 00:15:27,740
example we thought initially that the

00:15:26,089 --> 00:15:29,810
node.js Bob Packwood

00:15:27,740 --> 00:15:32,870
just a single build pack but really

00:15:29,810 --> 00:15:34,880
we're finding it's better implemented as

00:15:32,870 --> 00:15:37,340
separate bill packs where the nodejs

00:15:34,880 --> 00:15:41,240
build pack provides just node and the

00:15:37,340 --> 00:15:44,240
NPM build pack its detects scrip tells

00:15:41,240 --> 00:15:46,400
the build process whether it should

00:15:44,240 --> 00:15:47,510
actually install NPM not modules so you

00:15:46,400 --> 00:15:49,910
could imagine that there is an

00:15:47,510 --> 00:15:51,500
application that only needed node didn't

00:15:49,910 --> 00:15:53,510
need modules and we were able to module

00:15:51,500 --> 00:15:56,090
eyes like this a really good example of

00:15:53,510 --> 00:15:58,040
this is the Java build pack and the Java

00:15:56,090 --> 00:16:00,080
build pack team is working on splitting

00:15:58,040 --> 00:16:06,800
the Java build pack into a lot of

00:16:00,080 --> 00:16:08,720
separate build packs so I want to go

00:16:06,800 --> 00:16:11,930
into a little more detail about how this

00:16:08,720 --> 00:16:14,000
works and specifically how how we make

00:16:11,930 --> 00:16:18,530
rebuilds really efficient using the new

00:16:14,000 --> 00:16:20,360
model so I think the key idea behind it

00:16:18,530 --> 00:16:21,920
is that we only rebuild and upload

00:16:20,360 --> 00:16:23,420
layers when it's necessary and then

00:16:21,920 --> 00:16:26,240
includes uploading layers all the way to

00:16:23,420 --> 00:16:27,650
the edge so we just update you know

00:16:26,240 --> 00:16:30,290
rebuild a few layers that we need to

00:16:27,650 --> 00:16:32,660
locally or you know in your CI system or

00:16:30,290 --> 00:16:34,220
on a platform and then those individual

00:16:32,660 --> 00:16:35,900
layers get transferred through docker

00:16:34,220 --> 00:16:39,170
registries and dr. daemons all the way

00:16:35,900 --> 00:16:40,730
out to the you know cell or or whatever

00:16:39,170 --> 00:16:44,090
could run on a kubernetes recupera

00:16:40,730 --> 00:16:48,560
Netta's deployment out at the very end

00:16:44,090 --> 00:16:50,390
so to do this we use some interesting

00:16:48,560 --> 00:16:52,310
features of the OCI image specification

00:16:50,390 --> 00:16:55,370
so the OCI image specification breaks

00:16:52,310 --> 00:16:58,280
layers it's sort of a departure from the

00:16:55,370 --> 00:17:00,080
docker v1 image specification where now

00:16:58,280 --> 00:17:00,590
instead of linked layers that point to

00:17:00,080 --> 00:17:02,030
each other

00:17:00,590 --> 00:17:03,620
do you have individual content

00:17:02,030 --> 00:17:05,840
addressable layers for the file system

00:17:03,620 --> 00:17:06,980
and you can apply those in an order but

00:17:05,840 --> 00:17:08,150
they're not they're not it's not like

00:17:06,980 --> 00:17:10,280
get anymore they're not linked together

00:17:08,150 --> 00:17:12,230
so we can we can rebuild those layers

00:17:10,280 --> 00:17:13,940
whatever layers we want to replace and

00:17:12,230 --> 00:17:16,160
just update the individual ones in the

00:17:13,940 --> 00:17:18,770
image and just send those up to the

00:17:16,160 --> 00:17:21,380
registry so another feature we take

00:17:18,770 --> 00:17:22,910
advantage of is a new feature in modern

00:17:21,380 --> 00:17:25,160
docker registries and this sort of

00:17:22,910 --> 00:17:27,530
docker v2 registry where it's a feature

00:17:25,160 --> 00:17:31,070
called cross repository blob mounting so

00:17:27,530 --> 00:17:33,440
we can have one image repo that's a

00:17:31,070 --> 00:17:35,930
source of a route FS for lots of other

00:17:33,440 --> 00:17:37,940
image repos and then without any data

00:17:35,930 --> 00:17:39,470
transfer really or without it's sort of

00:17:37,940 --> 00:17:41,059
the negligible amount of data transfer

00:17:39,470 --> 00:17:43,100
we can point you know

00:17:41,059 --> 00:17:45,440
thousand imagery posed at a new base

00:17:43,100 --> 00:17:47,210
image just by going across each image

00:17:45,440 --> 00:17:49,100
and making a small metadata change as

00:17:47,210 --> 00:17:50,659
this would let you update so it kind of

00:17:49,100 --> 00:17:52,100
take the Cloud Foundry model where we

00:17:50,659 --> 00:17:53,539
have the cells and enrolling them and

00:17:52,100 --> 00:17:55,100
replay that on top of the docker

00:17:53,539 --> 00:17:57,440
registry to get sort of the same

00:17:55,100 --> 00:17:59,149
benefits that's that's one of the sort

00:17:57,440 --> 00:18:00,620
of coolest things about this I think so

00:17:59,149 --> 00:18:02,059
there was the result of sort of using

00:18:00,620 --> 00:18:04,490
these two strategies together is that we

00:18:02,059 --> 00:18:07,700
get really fast builds a really minimal

00:18:04,490 --> 00:18:09,200
data transfer and can do the sort of

00:18:07,700 --> 00:18:14,360
layer rebasing thing directly on the

00:18:09,200 --> 00:18:16,309
registry and so so you can I go through

00:18:14,360 --> 00:18:17,509
and compare these these two ways of

00:18:16,309 --> 00:18:21,470
doing things a little more technically

00:18:17,509 --> 00:18:23,419
so before we had you know just this

00:18:21,470 --> 00:18:25,730
supply and finalize build step and so

00:18:23,419 --> 00:18:27,080
you have your you know application and

00:18:25,730 --> 00:18:28,759
it runs supply finalized does everything

00:18:27,080 --> 00:18:30,590
and generates the droplet and when you

00:18:28,759 --> 00:18:32,389
want to rebuild again you know yes

00:18:30,590 --> 00:18:34,580
there's a small cache it has access to

00:18:32,389 --> 00:18:35,779
that where it can recover some of the

00:18:34,580 --> 00:18:36,950
things that downloaded last time but

00:18:35,779 --> 00:18:38,419
it's basically gonna do all the same

00:18:36,950 --> 00:18:40,070
things and generated new droplet and

00:18:38,419 --> 00:18:43,070
transfer all those same droplet bits out

00:18:40,070 --> 00:18:44,899
to the edge we're in the new model we

00:18:43,070 --> 00:18:46,639
take those two steps that sort of detect

00:18:44,899 --> 00:18:47,840
step and that's supply and finalized

00:18:46,639 --> 00:18:49,820
stuff but we combine that supply and

00:18:47,840 --> 00:18:52,190
finally step into one and let me

00:18:49,820 --> 00:18:53,960
introduce two more steps that the

00:18:52,190 --> 00:18:57,590
platform is responsible for called

00:18:53,960 --> 00:18:59,450
analysis and export and so detect

00:18:57,590 --> 00:19:00,889
selects the build packs that run and

00:18:59,450 --> 00:19:04,070
figures out what dependencies the

00:19:00,889 --> 00:19:07,879
application needs analysis sort of grabs

00:19:04,070 --> 00:19:09,889
information about the previous image

00:19:07,879 --> 00:19:12,470
build uses that information to determine

00:19:09,889 --> 00:19:14,029
what there's to rebuild an export sends

00:19:12,470 --> 00:19:16,039
those layers up to the registry and I'll

00:19:14,029 --> 00:19:17,600
talk about that more in a little bit so

00:19:16,039 --> 00:19:18,230
to kind of break this down really

00:19:17,600 --> 00:19:20,690
granularly

00:19:18,230 --> 00:19:22,639
and the analyse step we pull information

00:19:20,690 --> 00:19:24,799
from the image configuration which is a

00:19:22,639 --> 00:19:26,649
special sort of easy to access section I

00:19:24,799 --> 00:19:29,299
write in a docker image in a registry

00:19:26,649 --> 00:19:31,249
and we write that into Tamil files that

00:19:29,299 --> 00:19:33,230
each build pack can read and so you'll

00:19:31,249 --> 00:19:34,789
see in the build step they can modify

00:19:33,230 --> 00:19:36,710
those Tamil files and those Tamil files

00:19:34,789 --> 00:19:39,080
represent the contents of the image

00:19:36,710 --> 00:19:41,960
layers so in the first step here we pull

00:19:39,080 --> 00:19:44,450
them from the the remote image in the

00:19:41,960 --> 00:19:46,730
build step the build packs read the

00:19:44,450 --> 00:19:48,230
those Tamil files to determine the

00:19:46,730 --> 00:19:49,879
contents of the existing layers and

00:19:48,230 --> 00:19:51,200
decide which layers to regenerate and

00:19:49,879 --> 00:19:52,460
they just regenerate them by creating a

00:19:51,200 --> 00:19:54,380
directory with the new contents of the

00:19:52,460 --> 00:19:56,300
file system it's very simple

00:19:54,380 --> 00:19:59,030
and I also still have access to a small

00:19:56,300 --> 00:20:00,890
transparent cache it's a has a little

00:19:59,030 --> 00:20:03,440
bit fewer guarantees than the caching

00:20:00,890 --> 00:20:06,050
Cloud Foundry right now you know it may

00:20:03,440 --> 00:20:07,280
go away but it can also be used to you

00:20:06,050 --> 00:20:11,270
know cache things that you need to

00:20:07,280 --> 00:20:12,620
download for build for instance and then

00:20:11,270 --> 00:20:14,900
so you end up with your new layers and

00:20:12,620 --> 00:20:18,740
your compiled app and then in the export

00:20:14,900 --> 00:20:20,390
step weary upload the new newly created

00:20:18,740 --> 00:20:22,100
directories as layers to replace the

00:20:20,390 --> 00:20:24,680
previous ones we leave other layers

00:20:22,100 --> 00:20:26,210
alone and then we combine all those

00:20:24,680 --> 00:20:28,400
tamil files together into a big JSON

00:20:26,210 --> 00:20:30,050
blob and put that back on an image label

00:20:28,400 --> 00:20:31,790
to live in the image configuration so

00:20:30,050 --> 00:20:33,110
that in the next analysis step it can be

00:20:31,790 --> 00:20:35,720
recovered and I know it sort of works

00:20:33,110 --> 00:20:37,370
like that so to kind of give you an

00:20:35,720 --> 00:20:39,500
example this to break it down until what

00:20:37,370 --> 00:20:41,570
this looks like first build and second

00:20:39,500 --> 00:20:43,790
build if you have your app and your

00:20:41,570 --> 00:20:45,920
first build analysis doesn't do anything

00:20:43,790 --> 00:20:48,530
yet because there's no image there build

00:20:45,920 --> 00:20:50,450
generates these you know Ruby and

00:20:48,530 --> 00:20:52,310
downloads Ruby note and installs them

00:20:50,450 --> 00:20:55,220
installs node modules installs Ruby gems

00:20:52,310 --> 00:20:59,180
export uploads all those layers and then

00:20:55,220 --> 00:21:00,680
in the second build if you know just

00:20:59,180 --> 00:21:03,050
parts of that are updated just say

00:21:00,680 --> 00:21:05,510
package JSON changes and your gem file

00:21:03,050 --> 00:21:08,360
changes we read information about the

00:21:05,510 --> 00:21:13,910
previous layers we decide oh we're gonna

00:21:08,360 --> 00:21:15,710
rebuild the node modules and and gems we

00:21:13,910 --> 00:21:17,660
just up to update those individual

00:21:15,710 --> 00:21:18,740
layers and the app layer on the registry

00:21:17,660 --> 00:21:20,510
and everything else stays where it is

00:21:18,740 --> 00:21:23,000
and we don't have to to regenerate it

00:21:20,510 --> 00:21:25,760
and that's sort of the process so the

00:21:23,000 --> 00:21:27,350
the goals here are increased portability

00:21:25,760 --> 00:21:28,790
from what Cloud Foundry is we don't have

00:21:27,350 --> 00:21:31,010
droplets anymore which are kind of a

00:21:28,790 --> 00:21:34,250
Cloud Foundry specific thing we have OCI

00:21:31,010 --> 00:21:35,750
images will run anywhere we could have

00:21:34,250 --> 00:21:38,930
decoupled that build process from Cloud

00:21:35,750 --> 00:21:40,840
Foundry so you can run it anywhere it's

00:21:38,930 --> 00:21:43,010
sort of a more flexible model you have

00:21:40,840 --> 00:21:44,540
lots of smaller build packs that are

00:21:43,010 --> 00:21:47,330
simpler and easier to understand and

00:21:44,540 --> 00:21:48,590
more transparent and we can really

00:21:47,330 --> 00:21:50,330
reduce the build time and the data

00:21:48,590 --> 00:21:52,430
transfer where some builds are now

00:21:50,330 --> 00:21:54,530
milliseconds where before they were 30

00:21:52,430 --> 00:21:56,690
seconds that's really it's been a kind

00:21:54,530 --> 00:21:59,330
of impressive thing to see so if you

00:21:56,690 --> 00:22:02,900
want more information the CN CF project

00:21:59,330 --> 00:22:04,850
is at build pack style just to clarify a

00:22:02,900 --> 00:22:06,620
little bit the CN CF project has the

00:22:04,850 --> 00:22:08,160
infrastructure and tools and

00:22:06,620 --> 00:22:10,440
specification for build pack

00:22:08,160 --> 00:22:12,570
now but the Cloud Foundry bill PACs are

00:22:10,440 --> 00:22:14,790
still part of Cloud Foundry and they'll

00:22:12,570 --> 00:22:18,180
be that way you know for the foreseeable

00:22:14,790 --> 00:22:30,260
future and that's all we got

00:22:18,180 --> 00:22:30,260
Thanks anybody have questions

00:22:42,910 --> 00:22:48,309
so the interest so we worked on this

00:22:46,660 --> 00:22:52,110
effort along with Heroku it's sort of a

00:22:48,309 --> 00:22:54,730
collaborative engineering effort the

00:22:52,110 --> 00:22:56,200
infrastructure and tools the like we

00:22:54,730 --> 00:22:59,169
have a CLI now that will build build

00:22:56,200 --> 00:23:01,360
packs in Toto CI images we have a formal

00:22:59,169 --> 00:23:03,520
specification for it all that's part of

00:23:01,360 --> 00:23:05,500
the CN CF project but the Cloud Foundry

00:23:03,520 --> 00:23:06,669
build packs are you know gonna continue

00:23:05,500 --> 00:23:08,260
to be part of Cloud Foundry and the

00:23:06,669 --> 00:23:09,850
Cloud Foundry foundation the Heroku bill

00:23:08,260 --> 00:23:11,950
packs are gonna continue to be part of

00:23:09,850 --> 00:23:15,120
you know owned by Heroku and in their

00:23:11,950 --> 00:23:15,120
you know respective places

00:23:23,700 --> 00:23:27,210
absolutely you're asking about

00:23:25,230 --> 00:23:29,880
compatibility so if you build new the

00:23:27,210 --> 00:23:31,980
three build packs on the CNC aspect will

00:23:29,880 --> 00:23:33,990
they run in Cloud Foundry so they won't

00:23:31,980 --> 00:23:35,640
run on Cloud Foundry right now we have a

00:23:33,990 --> 00:23:37,020
bunch of different options for enabling

00:23:35,640 --> 00:23:38,880
that I think the simplest thing that we

00:23:37,020 --> 00:23:41,280
plan to do really soon is make a wrapper

00:23:38,880 --> 00:23:43,260
that you can just run on a v3 build pack

00:23:41,280 --> 00:23:44,970
and make it run and actually run on a

00:23:43,260 --> 00:23:47,010
group of v3 build packs and would create

00:23:44,970 --> 00:23:49,050
a cloud foundry style build pack for you

00:23:47,010 --> 00:23:54,120
that's until Cloud Foundry has you know

00:23:49,050 --> 00:23:55,470
native v3 support and there there's

00:23:54,120 --> 00:23:57,810
compatibility in other directions to

00:23:55,470 --> 00:23:59,550
that we've been thinking about for you

00:23:57,810 --> 00:24:01,980
know making V to build packs run on v3

00:23:59,550 --> 00:24:09,230
things and this kind of complicated

00:24:01,980 --> 00:24:09,230
thing any other questions

00:24:27,320 --> 00:24:32,369
yeah that's a great question so it's not

00:24:30,840 --> 00:24:33,899
quite like a git rebase and it get

00:24:32,369 --> 00:24:35,849
rebase it's really regenerating the top

00:24:33,899 --> 00:24:37,649
layers just gets handling that

00:24:35,849 --> 00:24:39,599
underneath and this we're just swapping

00:24:37,649 --> 00:24:41,070
out one layer in the registry so the top

00:24:39,599 --> 00:24:43,700
layers don't get touched their IDs don't

00:24:41,070 --> 00:24:44,969
change they're all content address

00:24:43,700 --> 00:24:48,269
excuse me

00:24:44,969 --> 00:24:49,979
so how do you handle merge conflicts as

00:24:48,269 --> 00:24:53,070
an interesting question and the idea is

00:24:49,979 --> 00:24:55,979
if you sort of construct your layers so

00:24:53,070 --> 00:24:57,989
they don't conflict then they just apply

00:24:55,979 --> 00:24:59,580
naturally on top of each other so part

00:24:57,989 --> 00:25:01,229
of the difference between the dockerfile

00:24:59,580 --> 00:25:03,330
model and the build pack model this new

00:25:01,229 --> 00:25:04,469
v3 build pack model is that in docker

00:25:03,330 --> 00:25:05,700
files you can kind of do whatever you

00:25:04,469 --> 00:25:07,289
want in each layer and this they're

00:25:05,700 --> 00:25:12,739
restricted to directories so that they

00:25:07,289 --> 00:25:15,889
all apply cleanly essentially cool

00:25:12,739 --> 00:25:15,889
anybody else

00:25:28,850 --> 00:25:35,249
yeah that's interesting so in general we

00:25:33,299 --> 00:25:37,049
make the bill PACs provide the

00:25:35,249 --> 00:25:40,409
dependencies in a way so that they don't

00:25:37,049 --> 00:25:42,659
need the same directory right we there's

00:25:40,409 --> 00:25:44,369
a little like each bill Peck it's a

00:25:42,659 --> 00:25:46,499
sandbox directory that has like a POSIX

00:25:44,369 --> 00:25:47,580
tile root in it with a pin and a Lib and

00:25:46,499 --> 00:25:48,720
all of that so they're all kind of

00:25:47,580 --> 00:25:50,869
isolated and then we set up the

00:25:48,720 --> 00:25:53,489
environment to string all those together

00:25:50,869 --> 00:25:54,479
what's that make sense we've been

00:25:53,489 --> 00:25:55,739
thinking about some interesting things

00:25:54,479 --> 00:25:57,269
we could do with operating system

00:25:55,739 --> 00:25:58,859
packages to let us kind of take

00:25:57,269 --> 00:26:01,940
advantage of the same layer rebasing but

00:25:58,859 --> 00:26:01,940
that gets pretty complicated

00:26:04,669 --> 00:26:17,669
any other questions you're asking about

00:26:14,609 --> 00:26:20,609
k native and bill packs yeah so

00:26:17,669 --> 00:26:22,559
currently we have a build template in

00:26:20,609 --> 00:26:24,389
the cave official build templates repo

00:26:22,559 --> 00:26:26,129
for the Cloud Foundry build packs and

00:26:24,389 --> 00:26:28,559
that works right now it's the same v2

00:26:26,129 --> 00:26:30,239
stuff just kind of we have a shim layer

00:26:28,559 --> 00:26:31,710
that makes me to kind of behave like

00:26:30,239 --> 00:26:34,499
like me through you get some of those

00:26:31,710 --> 00:26:36,960
features to work on top of registries

00:26:34,499 --> 00:26:39,090
and with those CI images there's a PR in

00:26:36,960 --> 00:26:40,529
there right now for full v3 support and

00:26:39,090 --> 00:26:42,059
that should hopefully get merged soon

00:26:40,529 --> 00:26:44,369
you can check out that PR I think it

00:26:42,059 --> 00:26:48,539
works we're just some wording details I

00:26:44,369 --> 00:26:50,789
need to get worked out and that that

00:26:48,539 --> 00:26:53,190
uses candidates build CRD which is like

00:26:50,789 --> 00:26:54,509
a part of Canada that does builds so

00:26:53,190 --> 00:26:55,710
that if you use those templates with it

00:26:54,509 --> 00:27:03,869
you can use that to build apps on that

00:26:55,710 --> 00:27:07,399
platform cool cool

00:27:03,869 --> 00:27:07,399
any more questions last one

00:27:20,049 --> 00:27:27,110
so Heroku started a bill pack registry

00:27:23,330 --> 00:27:29,090
that they've kind of talked about making

00:27:27,110 --> 00:27:30,889
a more open community related thing I

00:27:29,090 --> 00:27:33,169
don't think they've they're ready to

00:27:30,889 --> 00:27:35,690
announce anything quite yet but yes we

00:27:33,169 --> 00:27:37,880
are looking to create a big community

00:27:35,690 --> 00:27:39,200
repository build packs and with nice

00:27:37,880 --> 00:27:40,960
integrations that would let you easily

00:27:39,200 --> 00:27:43,130
pull down the build tax you want to use

00:27:40,960 --> 00:27:44,360
instead of kind of confining them to a

00:27:43,130 --> 00:27:47,210
list of bill packs on each particular

00:27:44,360 --> 00:27:49,510
platform that's that's definitely part

00:27:47,210 --> 00:27:49,510
of the plan

00:27:56,499 --> 00:28:00,820
sorry can you say again when doing it

00:28:01,090 --> 00:28:06,259
yeah so we're currently converting the

00:28:04,309 --> 00:28:07,519
node J house build pack 2 B 3 and we're

00:28:06,259 --> 00:28:11,539
gonna provide a wrapper to make that

00:28:07,519 --> 00:28:12,559
work on Cloud Foundry to the you know I

00:28:11,539 --> 00:28:15,559
think say that'll be done in a couple

00:28:12,559 --> 00:28:17,480
weeks probably the Java team has been

00:28:15,559 --> 00:28:19,759
working on splitting the Java build pack

00:28:17,480 --> 00:28:21,590
into a bunch of different v3 build text

00:28:19,759 --> 00:28:22,970
- they've made a lot of progress on

00:28:21,590 --> 00:28:26,360
there they have some parts that you know

00:28:22,970 --> 00:28:27,860
work really well now the so that's

00:28:26,360 --> 00:28:29,269
that's when the build packs will be you

00:28:27,860 --> 00:28:30,740
know the Cloud Foundry build packs will

00:28:29,269 --> 00:28:32,179
work on v3 the other part of that

00:28:30,740 --> 00:28:34,970
question is one will quiet foundry run

00:28:32,179 --> 00:28:36,080
the v3 build packs right we we think we

00:28:34,970 --> 00:28:37,970
can get that wrapper done pretty soon

00:28:36,080 --> 00:28:39,169
but we don't have a timeline for what

00:28:37,970 --> 00:28:41,470
you know native support might look like

00:28:39,169 --> 00:28:41,470
that

00:29:15,290 --> 00:29:21,520
ah so I didn't hear all that you're

00:29:19,970 --> 00:29:27,410
asking about build tech versioning and

00:29:21,520 --> 00:29:28,910
how that plays into detection can you it

00:29:27,410 --> 00:29:30,740
was a question about you have an

00:29:28,910 --> 00:29:32,660
application and you have multiple build

00:29:30,740 --> 00:29:34,460
packs of different versions in the same

00:29:32,660 --> 00:29:35,090
list and you know which one gets

00:29:34,460 --> 00:29:39,380
selected

00:29:35,090 --> 00:29:42,500
okay so the v3 API the new C and C F API

00:29:39,380 --> 00:29:45,410
supports versioning and so you can have

00:29:42,500 --> 00:29:47,540
you can sort of construct your it's now

00:29:45,410 --> 00:29:48,800
a two by two list of build packs because

00:29:47,540 --> 00:29:53,210
you have build pack groups and then you

00:29:48,800 --> 00:29:54,800
have candidate groups it it supports

00:29:53,210 --> 00:29:56,090
versioning so the inside of one of those

00:29:54,800 --> 00:29:57,530
groups you can say always pull the

00:29:56,090 --> 00:29:59,690
latest version or pull a particular

00:29:57,530 --> 00:30:01,310
version and you don't have to list the

00:29:59,690 --> 00:30:02,390
same you wouldn't like it wouldn't

00:30:01,310 --> 00:30:04,430
really you wouldn't really have the

00:30:02,390 --> 00:30:05,930
option of listing the same build pack at

00:30:04,430 --> 00:30:07,520
a different version multiple times or if

00:30:05,930 --> 00:30:08,720
you could but it would be would be

00:30:07,520 --> 00:30:10,610
obvious that you're doing something you

00:30:08,720 --> 00:30:12,200
shouldn't do if that makes sense

00:30:10,610 --> 00:30:14,090
you could have different candidate

00:30:12,200 --> 00:30:16,070
groups that have different versions of

00:30:14,090 --> 00:30:19,370
the build pack in it if you wanted to

00:30:16,070 --> 00:30:21,880
though that sort of make sense design

00:30:19,370 --> 00:30:21,880
answer question

00:30:26,190 --> 00:30:30,370
all right anything else I think we just

00:30:29,590 --> 00:30:34,750
out of time here

00:30:30,370 --> 00:30:38,010
so uh thanks everybody and feel free to

00:30:34,750 --> 00:30:38,010

YouTube URL: https://www.youtube.com/watch?v=J6zn3WRqJko


