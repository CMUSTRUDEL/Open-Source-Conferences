Title: Running Smart Apps on the Cloud Foundry Platform - Amith Nambiar, Pivotal
Publication date: 2018-10-10
Playlist: Cloud Foundry Summit Europe 2018
Description: 
	Running Smart Apps on the Cloud Foundry Platform - Amith Nambiar, Pivotal

"A quick look at companies disrupting well-established industries reveals a number of common characteristics. Among the most important, they're all expert at delivering insights in context to their customers and usersâ€”and they do it by surfacing data-driven, actionable information via features in smart applications."

This talk will delve into the details of delivering an end to end smart app on the Cloud Foundry platform. I will start with an example app which uses Machine learning and describe the problems involved in making the insights from the predictions available to the end users. Then, I will go into the details of how to use Cloud Foundry's Platform as a service (PaaS) abstraction to run and scale the API's, use Container as a service (CaaS) abstraction to run Machine Learning workloads using Apache Spark and Serverless computing abstraction (FaaS - Project riff) to run event driven functions. Finally, I will talk about how these different abstractions connect and enable, a whole new set of apps with varied requirements, onto the platform.

https://cfseu18.sched.com/event/FRyG/running-smart-apps-on-the-cloud-foundry-platform-amith-nambiar-pivotal
Captions: 
	00:00:00,060 --> 00:00:09,240
welcome everyone let's get started here

00:00:04,859 --> 00:00:11,509
let me just connect this one yep this is

00:00:09,240 --> 00:00:13,620
an infographic I got from the

00:00:11,509 --> 00:00:16,920
multi-platform trend report from the

00:00:13,620 --> 00:00:19,140
Cloud Foundry website what's really

00:00:16,920 --> 00:00:22,130
interesting here for me is if you look

00:00:19,140 --> 00:00:25,320
at the adoption of paths

00:00:22,130 --> 00:00:30,150
amongst the enterprises you can see 77%

00:00:25,320 --> 00:00:32,309
of pass usage and 70 to 72 percent of

00:00:30,150 --> 00:00:34,739
containers which is really interesting

00:00:32,309 --> 00:00:35,579
for me because if you compare where

00:00:34,739 --> 00:00:37,920
paths

00:00:35,579 --> 00:00:40,350
how many years ago pass was there and

00:00:37,920 --> 00:00:44,640
where containers came from right I mean

00:00:40,350 --> 00:00:47,430
72 percent is a big leap and 46% of

00:00:44,640 --> 00:00:49,469
serverless usage among enterprises right

00:00:47,430 --> 00:00:52,710
I mean the people who have responded to

00:00:49,469 --> 00:00:58,199
this survey our IT decision makers who

00:00:52,710 --> 00:01:00,359
are saying that 39 percent of of the

00:00:58,199 --> 00:01:03,329
respondents are using all these three

00:01:00,359 --> 00:01:07,310
types of abstractions so what I want to

00:01:03,329 --> 00:01:09,990
talk to you today is about Cloud Foundry

00:01:07,310 --> 00:01:14,070
originally started out as a pass right

00:01:09,990 --> 00:01:15,689
and now has abstractions which can run

00:01:14,070 --> 00:01:19,770
containers as well as serverless

00:01:15,689 --> 00:01:22,439
right so my question today to all of you

00:01:19,770 --> 00:01:24,659
is is it possible to architect an app

00:01:22,439 --> 00:01:27,330
spanning across the abstractions in

00:01:24,659 --> 00:01:30,840
Cloud Foundry so when I say abstractions

00:01:27,330 --> 00:01:34,490
here I mean as gas and fast so platform

00:01:30,840 --> 00:01:38,070
as a service container as a service and

00:01:34,490 --> 00:01:40,770
function as a service so I'd like to

00:01:38,070 --> 00:01:43,259
start off with a little bit of my

00:01:40,770 --> 00:01:46,829
experience right when I started in the

00:01:43,259 --> 00:01:51,030
IT industry there was only one way to

00:01:46,829 --> 00:01:53,009
develop an app and it is a monolith

00:01:51,030 --> 00:01:56,280
right every every team member

00:01:53,009 --> 00:01:58,079
contributes to the same codebase and we

00:01:56,280 --> 00:02:01,020
never used to call it the monolith in

00:01:58,079 --> 00:02:04,200
those days right I mean there was there

00:02:01,020 --> 00:02:06,200
were lots of them happening and I just

00:02:04,200 --> 00:02:08,640
wanted to make an observation there that

00:02:06,200 --> 00:02:12,150
when we started building these

00:02:08,640 --> 00:02:13,800
applications the focus amongst

00:02:12,150 --> 00:02:14,360
developers I mean if you get into a

00:02:13,800 --> 00:02:17,060
developing

00:02:14,360 --> 00:02:19,910
you can hear them talking about design

00:02:17,060 --> 00:02:21,920
patterns and code complexity basically

00:02:19,910 --> 00:02:24,440
because everyone is contributing to the

00:02:21,920 --> 00:02:26,420
same codebase so design patterns I still

00:02:24,440 --> 00:02:29,510
have this book from the Gang of Four I'm

00:02:26,420 --> 00:02:32,360
sure some of you would have read that as

00:02:29,510 --> 00:02:34,450
well a 20 plus design pattern and some

00:02:32,360 --> 00:02:37,880
really cool object-oriented techniques

00:02:34,450 --> 00:02:39,620
to use to may have your code manageable

00:02:37,880 --> 00:02:42,230
to get a shared understanding of the

00:02:39,620 --> 00:02:44,600
code base across the team right I mean

00:02:42,230 --> 00:02:46,750
that's where the focus was and that's

00:02:44,600 --> 00:02:49,580
where the discussions were around but

00:02:46,750 --> 00:02:52,570
soon there were some new architectural

00:02:49,580 --> 00:02:55,220
patterns that came out like

00:02:52,570 --> 00:02:59,290
service-oriented architectures and then

00:02:55,220 --> 00:03:02,480
micro services where we started

00:02:59,290 --> 00:03:04,490
basically taking that app and

00:03:02,480 --> 00:03:06,590
identifying the services right which

00:03:04,490 --> 00:03:09,580
make up that app and splitting them into

00:03:06,590 --> 00:03:14,000
different independently deployable

00:03:09,580 --> 00:03:17,300
artifacts right that's where the micro

00:03:14,000 --> 00:03:19,459
services world is heading and then the

00:03:17,300 --> 00:03:21,890
focus changed from domain driven into

00:03:19,459 --> 00:03:23,840
domain driven design DevOps platforms

00:03:21,890 --> 00:03:25,850
distributed computing right I mean

00:03:23,840 --> 00:03:28,670
what's what's really interesting for me

00:03:25,850 --> 00:03:31,340
is coming from developing more elites

00:03:28,670 --> 00:03:33,650
during those years and now nobody is

00:03:31,340 --> 00:03:35,930
talking about design patterns having a

00:03:33,650 --> 00:03:37,959
shared understanding because everyone is

00:03:35,930 --> 00:03:40,670
working on a really small codebase and

00:03:37,959 --> 00:03:42,650
all they are carried all they all they

00:03:40,670 --> 00:03:44,660
are really interested about is what

00:03:42,650 --> 00:03:46,340
interfaces do these services exposed

00:03:44,660 --> 00:03:47,780
they don't care about what the internal

00:03:46,340 --> 00:03:49,459
implementation of those services well

00:03:47,780 --> 00:03:53,989
these are just observations I would like

00:03:49,459 --> 00:03:57,220
to make then another observation I had

00:03:53,989 --> 00:03:59,660
was innovations in cloud computing

00:03:57,220 --> 00:04:02,660
basically driven by the cloud vendors

00:03:59,660 --> 00:04:06,920
like Amazon Google cloud and Microsoft

00:04:02,660 --> 00:04:08,600
Azure and also changes to the Linux

00:04:06,920 --> 00:04:10,060
kernel I mean innovations in the Linux

00:04:08,600 --> 00:04:12,830
kernel my introduction of cgroups

00:04:10,060 --> 00:04:16,390
namespaces and container technology in

00:04:12,830 --> 00:04:19,190
general has actually given rise to

00:04:16,390 --> 00:04:23,240
different abstractions called pass gas

00:04:19,190 --> 00:04:26,560
and fast so pass is platform as a

00:04:23,240 --> 00:04:28,250
service as you all know it's it's really

00:04:26,560 --> 00:04:30,700
built for

00:04:28,250 --> 00:04:32,990
running stateless apps so when I say

00:04:30,700 --> 00:04:36,800
stateless apps what I really mean is

00:04:32,990 --> 00:04:39,950
apps which have externalized your state

00:04:36,800 --> 00:04:43,550
they don't do any kind of persisting to

00:04:39,950 --> 00:04:45,380
disk or any of those activities and also

00:04:43,550 --> 00:04:48,050
twelve actor apps it's its set of

00:04:45,380 --> 00:04:50,800
guidelines how to make your app you know

00:04:48,050 --> 00:04:53,420
deployable on such platform as-a-service

00:04:50,800 --> 00:04:56,210
then you have container as a service

00:04:53,420 --> 00:04:59,890
where it's it's ideal for running your

00:04:56,210 --> 00:05:03,260
commercial off-the-shelf products

00:04:59,890 --> 00:05:05,090
stateful apps for example a stateful app

00:05:03,260 --> 00:05:08,930
would be if you're running some machine

00:05:05,090 --> 00:05:11,090
learning workloads and if it is a pata

00:05:08,930 --> 00:05:14,330
spark for example it does most of its

00:05:11,090 --> 00:05:16,640
compute in memory but when there is no

00:05:14,330 --> 00:05:18,140
know much memory left it has to spill to

00:05:16,640 --> 00:05:20,120
disk and write to disk

00:05:18,140 --> 00:05:21,919
such kinds of applications can run and

00:05:20,120 --> 00:05:24,650
it's well suited for container as a

00:05:21,919 --> 00:05:26,180
service right even databases you can see

00:05:24,650 --> 00:05:28,220
many of the database vendors now

00:05:26,180 --> 00:05:33,800
continuing their applications and giving

00:05:28,220 --> 00:05:35,990
it out free use then you have function

00:05:33,800 --> 00:05:38,479
as a service right these are basically

00:05:35,990 --> 00:05:40,700
you just push your function to the

00:05:38,479 --> 00:05:43,010
platform and the platform takes care of

00:05:40,700 --> 00:05:46,310
running the function for you I mean

00:05:43,010 --> 00:05:48,680
basically give it a URL maybe get URL

00:05:46,310 --> 00:05:51,229
and it will take that URL build the

00:05:48,680 --> 00:05:53,450
image for you and when and even comes

00:05:51,229 --> 00:05:55,370
into the platform it spins up the

00:05:53,450 --> 00:05:59,570
container or whatever technology is

00:05:55,370 --> 00:06:01,880
using and to service that event so what

00:05:59,570 --> 00:06:06,050
why I wanted to set this up here is

00:06:01,880 --> 00:06:09,430
because I wanted to just show that we

00:06:06,050 --> 00:06:11,600
have got the choice of now moving these

00:06:09,430 --> 00:06:15,169
services into these different

00:06:11,600 --> 00:06:17,390
abstractions right so my question today

00:06:15,169 --> 00:06:21,860
is I mean how does Cloud Foundry really

00:06:17,390 --> 00:06:24,470
help you basically strangle a monolith

00:06:21,860 --> 00:06:27,890
into micro services and then there are

00:06:24,470 --> 00:06:30,020
services within these those boxes which

00:06:27,890 --> 00:06:32,210
are a good fit some of them are a good

00:06:30,020 --> 00:06:34,400
fit for a platform is a service some of

00:06:32,210 --> 00:06:36,470
them are a good fit for a container

00:06:34,400 --> 00:06:38,780
service and some for even driven

00:06:36,470 --> 00:06:42,810
functions so

00:06:38,780 --> 00:06:44,280
the next question I have is so what does

00:06:42,810 --> 00:06:46,680
Cloud Foundry offered for a

00:06:44,280 --> 00:06:49,560
multi-platform world right I mean how

00:06:46,680 --> 00:06:51,000
can you use Cloud Foundry to run such

00:06:49,560 --> 00:06:55,590
workloads and with different

00:06:51,000 --> 00:06:57,150
abstractions so this is what I was

00:06:55,590 --> 00:06:59,639
showing you earlier

00:06:57,150 --> 00:07:02,729
so Cloud Foundry has something called as

00:06:59,639 --> 00:07:05,969
an application runtime the CF air which

00:07:02,729 --> 00:07:08,129
is which is basically a mission

00:07:05,969 --> 00:07:10,560
statement you can call it like beyond

00:07:08,129 --> 00:07:12,419
seas haiku which says here's my source

00:07:10,560 --> 00:07:15,000
code run it on the cloud for me I don't

00:07:12,419 --> 00:07:18,449
care how right you just do a CF push and

00:07:15,000 --> 00:07:21,469
the application the runtime takes care

00:07:18,449 --> 00:07:23,639
of building the container for you

00:07:21,469 --> 00:07:26,599
storing the container in a registry

00:07:23,639 --> 00:07:29,520
within the platform doing a DNS

00:07:26,599 --> 00:07:31,439
networking security and all that surface

00:07:29,520 --> 00:07:34,560
even the load balancing is taken care

00:07:31,439 --> 00:07:36,659
for you so you as a developer don't have

00:07:34,560 --> 00:07:38,610
to do anything about it then you have

00:07:36,659 --> 00:07:42,810
the Cloud Foundry container runtime

00:07:38,610 --> 00:07:46,440
which was previously called a Kubo which

00:07:42,810 --> 00:07:48,990
means kubernetes on Bosh so it gives you

00:07:46,440 --> 00:07:51,060
an interface for you to create highly

00:07:48,990 --> 00:07:54,300
available kubernetes clusters managed by

00:07:51,060 --> 00:07:56,580
Bosh right so on these two building

00:07:54,300 --> 00:07:58,110
blocks you can actually have all your

00:07:56,580 --> 00:08:00,800
abstractions running so that's the

00:07:58,110 --> 00:08:03,960
that's the focus of my talk today of

00:08:00,800 --> 00:08:05,909
taking a demo app and showing how you

00:08:03,960 --> 00:08:07,860
can place the services which are

00:08:05,909 --> 00:08:10,680
well-suited for running on a pass gas on

00:08:07,860 --> 00:08:14,849
the press right so that makes it

00:08:10,680 --> 00:08:16,919
multi-platform in Bosh if you're not

00:08:14,849 --> 00:08:19,620
aware Bosh is a release engineering

00:08:16,919 --> 00:08:22,500
deployment management and lifecycle

00:08:19,620 --> 00:08:25,289
management tool which has a has a

00:08:22,500 --> 00:08:28,439
component called CPI which stands for

00:08:25,289 --> 00:08:32,099
cloud provider interface right and that

00:08:28,439 --> 00:08:35,760
makes it cloud agnostic so you could be

00:08:32,099 --> 00:08:38,370
running your path on the application

00:08:35,760 --> 00:08:41,310
runtime on Bosh and Bosh might be

00:08:38,370 --> 00:08:43,709
deploying it onto AWS for example or it

00:08:41,310 --> 00:08:46,920
could be a vmware vsphere right Bosh

00:08:43,709 --> 00:08:48,569
abstracts out the what you call the

00:08:46,920 --> 00:08:50,670
complexity of dealing with each cloud

00:08:48,569 --> 00:08:51,300
provider so that the operator doesn't

00:08:50,670 --> 00:08:53,399
have to deal with

00:08:51,300 --> 00:08:55,380
himself so it provides a good control

00:08:53,399 --> 00:08:59,910
plane for the operator to work with the

00:08:55,380 --> 00:09:02,730
platform and that makes it multi-cloud

00:08:59,910 --> 00:09:07,380
right so you get a multi cloud plus or

00:09:02,730 --> 00:09:10,410
multi platform with Cloud Foundry so

00:09:07,380 --> 00:09:15,120
this is the app we are going to have a

00:09:10,410 --> 00:09:18,480
look at today right what the what the

00:09:15,120 --> 00:09:21,269
app does is it has a few api's and a UI

00:09:18,480 --> 00:09:24,560
as you can see which is deployed into a

00:09:21,269 --> 00:09:28,980
platform as a service so given website

00:09:24,560 --> 00:09:32,550
URL the app is going to go fetch all the

00:09:28,980 --> 00:09:34,500
links from this website and then make a

00:09:32,550 --> 00:09:36,930
prediction as to what kind of our

00:09:34,500 --> 00:09:41,420
website this is from a predefined list

00:09:36,930 --> 00:09:45,450
of categories so I'll do a quick record

00:09:41,420 --> 00:09:47,399
demo of this so since we are in Basel I

00:09:45,450 --> 00:09:50,190
thought I'll do Basel calm which is

00:09:47,399 --> 00:09:55,370
jerusem website and let's see how it

00:09:50,190 --> 00:09:57,660
goes so this is a recorded video for you

00:09:55,370 --> 00:09:59,610
we'll get into the details of what

00:09:57,660 --> 00:10:04,380
exactly is happening behind the scenes

00:09:59,610 --> 00:10:10,410
and how this app has been deployed onto

00:10:04,380 --> 00:10:12,029
different abstractions so so the link

00:10:10,410 --> 00:10:13,440
has been submitted what it's doing in

00:10:12,029 --> 00:10:18,740
the background it's going and fetching

00:10:13,440 --> 00:10:18,740
all the links to the site Basel calm

00:10:23,250 --> 00:10:31,839
so you can see the words I mean it does

00:10:26,500 --> 00:10:33,870
a little bit of stemming and before it

00:10:31,839 --> 00:10:42,130
submits it to the machine learning

00:10:33,870 --> 00:10:45,070
module so the fetching of links is

00:10:42,130 --> 00:10:47,260
happening on function as a service we

00:10:45,070 --> 00:10:49,390
look into that soon the machine learning

00:10:47,260 --> 00:10:51,790
the prediction is done on container as a

00:10:49,390 --> 00:10:53,940
service and the API and the UI is

00:10:51,790 --> 00:10:57,490
fostered on the platform as a service

00:10:53,940 --> 00:10:59,820
all right let me just what this little

00:10:57,490 --> 00:10:59,820
bit

00:11:12,080 --> 00:11:18,800
so just predicted it as a travel website

00:11:14,570 --> 00:11:21,649
which is pretty much right so let's move

00:11:18,800 --> 00:11:24,470
on I'd like to introduce you to this

00:11:21,649 --> 00:11:28,160
team right which is called the web cat

00:11:24,470 --> 00:11:31,459
team so there are UX and API designers

00:11:28,160 --> 00:11:34,760
here the UI designers are building their

00:11:31,459 --> 00:11:37,940
front ends the API developers are using

00:11:34,760 --> 00:11:41,300
spring mode nodejs they need a post-race

00:11:37,940 --> 00:11:44,149
already sketch to use platform as a

00:11:41,300 --> 00:11:46,630
service which is which so that they can

00:11:44,149 --> 00:11:49,459
go in and do a self-service kind of

00:11:46,630 --> 00:11:52,760
provisioning of their of their

00:11:49,459 --> 00:11:55,010
applications and their backends then we

00:11:52,760 --> 00:11:57,140
have the data science team right with

00:11:55,010 --> 00:11:58,910
data scientists doing the machine

00:11:57,140 --> 00:12:02,149
learning work they are doing their

00:11:58,910 --> 00:12:04,610
designs models for these prediction of

00:12:02,149 --> 00:12:06,500
the category of the website then you

00:12:04,610 --> 00:12:09,410
have the data engineering guys on this

00:12:06,500 --> 00:12:11,720
side who are responsible for ingesting

00:12:09,410 --> 00:12:13,459
data into the into the air environment

00:12:11,720 --> 00:12:19,220
right and also building the data

00:12:13,459 --> 00:12:23,480
pipelines here so this is how the stack

00:12:19,220 --> 00:12:26,540
looks up looks the UI and API is using

00:12:23,480 --> 00:12:29,450
spring boat and node.js they're using

00:12:26,540 --> 00:12:31,490
their own Postgres and Redis and that's

00:12:29,450 --> 00:12:33,829
showing on the Cloud Foundry application

00:12:31,490 --> 00:12:36,470
runtime right and the machine learning

00:12:33,829 --> 00:12:38,240
team is using spark which is running on

00:12:36,470 --> 00:12:40,430
the cloud foundry container runtime and

00:12:38,240 --> 00:12:42,290
we'll talk about the server lists in the

00:12:40,430 --> 00:12:45,940
even driven functions it's using R if

00:12:42,290 --> 00:12:50,860
it's a + k native and all this is

00:12:45,940 --> 00:12:53,570
running on Bosh as I mentioned earlier

00:12:50,860 --> 00:12:56,620
just so that I can set the context here

00:12:53,570 --> 00:13:00,320
I'm using a vSphere environment with

00:12:56,620 --> 00:13:03,350
pivotal Cloud Foundry installed as you

00:13:00,320 --> 00:13:05,839
can see I have a boss director there and

00:13:03,350 --> 00:13:08,000
pivotal application service and the

00:13:05,839 --> 00:13:11,839
pivotal container service so the

00:13:08,000 --> 00:13:14,990
application service is running on top of

00:13:11,839 --> 00:13:17,660
it's basically Cloud Foundry application

00:13:14,990 --> 00:13:19,820
runtime and the container service

00:13:17,660 --> 00:13:26,300
pivotal container service is using the

00:13:19,820 --> 00:13:30,830
Cloud Foundry container on time so let's

00:13:26,300 --> 00:13:33,920
do the deployment of the front and API

00:13:30,830 --> 00:13:37,220
is on to the application runtime so I'll

00:13:33,920 --> 00:13:40,150
have to log into my VPN to do that so

00:13:37,220 --> 00:13:40,150
just bear with me

00:14:03,350 --> 00:14:12,210
so once that's connected we should be

00:14:06,300 --> 00:14:18,900
able to wrap yep looks like it is gonna

00:14:12,210 --> 00:14:22,770
come out okay yep so the first step is I

00:14:18,900 --> 00:14:24,270
have this app here which is just a

00:14:22,770 --> 00:14:25,860
springboard app which I'll be pushing it

00:14:24,270 --> 00:14:27,750
onto the platform onto the pivotal

00:14:25,860 --> 00:14:30,180
application service which is running on

00:14:27,750 --> 00:14:33,990
the cloud foundry application runtime

00:14:30,180 --> 00:14:37,710
right so I'll just show you where it's

00:14:33,990 --> 00:14:40,410
running CF target will show me that I'm

00:14:37,710 --> 00:14:42,600
targeting the API dot system with PCF

00:14:40,410 --> 00:14:44,700
platform comm that's where the

00:14:42,600 --> 00:14:50,520
platform's running so I'm going to do a

00:14:44,700 --> 00:14:52,740
CF push so this is the here's my source

00:14:50,520 --> 00:14:57,420
code run it on the cloud for me I don't

00:14:52,740 --> 00:14:59,940
care how happening life I've just pushed

00:14:57,420 --> 00:15:02,820
an app which has a manifest which is

00:14:59,940 --> 00:15:07,040
just describing that the name is web cat

00:15:02,820 --> 00:15:15,180
that's the jar you need to deploy and

00:15:07,040 --> 00:15:18,090
the name of the app as well once as you

00:15:15,180 --> 00:15:21,120
can see I've just pushed an app and it's

00:15:18,090 --> 00:15:23,730
the build pack detection and creating a

00:15:21,120 --> 00:15:26,160
container or a droplet is taken care by

00:15:23,730 --> 00:15:28,650
the platform and even storing that into

00:15:26,160 --> 00:15:32,070
a registry is it's done by the platform

00:15:28,650 --> 00:15:35,780
itself now this is the route for that

00:15:32,070 --> 00:15:35,780
app I'm going to hit that

00:15:38,970 --> 00:15:47,170
this is the apps manager which would be

00:15:43,870 --> 00:15:50,350
showing me the app here so this is just

00:15:47,170 --> 00:15:52,330
deployed I can click on it and if

00:15:50,350 --> 00:15:57,340
everything works I should be able to see

00:15:52,330 --> 00:15:59,680
the UI so that's the first part of

00:15:57,340 --> 00:16:01,410
deploying the application now let's look

00:15:59,680 --> 00:16:10,900
at the second part of deploying the

00:16:01,410 --> 00:16:14,650
machine learning workloads right so this

00:16:10,900 --> 00:16:18,300
is done it's more into the next one

00:16:14,650 --> 00:16:18,300
deploying the machine learning workloads

00:16:18,690 --> 00:16:23,170
so the first step is to create a

00:16:21,070 --> 00:16:25,870
kubernetes cluster right

00:16:23,170 --> 00:16:33,180
using PKS the command-line tool so I'll

00:16:25,870 --> 00:16:33,180
speak briefly about the PKS too so

00:16:40,240 --> 00:16:52,839
so I'm logging into the environment yep

00:16:47,819 --> 00:16:56,199
okay so when so PKS is a command-line

00:16:52,839 --> 00:16:57,939
tool for you to spin up kubernetes

00:16:56,199 --> 00:17:00,550
clusters highly available kubernetes

00:16:57,939 --> 00:17:02,170
clusters so what I've done here is it

00:17:00,550 --> 00:17:06,279
takes 10 to 15 minutes to spin up

00:17:02,170 --> 00:17:08,020
cluster so I've done it in advance what

00:17:06,279 --> 00:17:11,319
it's doing is as an operator you can go

00:17:08,020 --> 00:17:14,350
in and say apk is create cluster and the

00:17:11,319 --> 00:17:17,799
PKS API will talk to boss and then use

00:17:14,350 --> 00:17:19,329
the CF container and time to create an

00:17:17,799 --> 00:17:24,429
highly available proven it is cluster

00:17:19,329 --> 00:17:27,069
for you so once this command finishes

00:17:24,429 --> 00:17:29,169
you have highly available kubernetes

00:17:27,069 --> 00:17:32,110
cluster right so that's what I have done

00:17:29,169 --> 00:17:34,480
already the next step is for me to get

00:17:32,110 --> 00:17:37,659
the credentials for the cluster into my

00:17:34,480 --> 00:17:39,490
cube conflict then finally I deploy the

00:17:37,659 --> 00:17:41,010
machine learning workloads right I've

00:17:39,490 --> 00:17:52,779
done all this

00:17:41,010 --> 00:17:55,990
here you can cube CDL so you can see

00:17:52,779 --> 00:17:57,130
there are a few namespaces here you can

00:17:55,990 --> 00:18:02,580
see there's one called machine learning

00:17:57,130 --> 00:18:02,580
workloads where I have deployed my pod

00:18:05,039 --> 00:18:12,130
right that's where the SPARC application

00:18:09,100 --> 00:18:13,870
is running right now and if I look at my

00:18:12,130 --> 00:18:17,380
default namespace there is nothing

00:18:13,870 --> 00:18:19,270
running at the moment oh there is a link

00:18:17,380 --> 00:18:24,880
collector probably it'll die in some

00:18:19,270 --> 00:18:27,850
time okay so deploying machine learning

00:18:24,880 --> 00:18:29,080
workloads with SPARC 2.3 there has been

00:18:27,850 --> 00:18:32,620
native support for running

00:18:29,080 --> 00:18:35,860
kubernetes so you can now actually run

00:18:32,620 --> 00:18:41,710
kubernetes on the solid run spark and

00:18:35,860 --> 00:18:43,360
coupon it is final part is to run the

00:18:41,710 --> 00:18:45,490
function as a service before we get into

00:18:43,360 --> 00:18:48,789
that I just wanted to talk a little bit

00:18:45,490 --> 00:18:50,950
about the landscape right you have AWS

00:18:48,789 --> 00:18:52,750
lambda as your functions and Google

00:18:50,950 --> 00:18:53,890
Cloud functions which are function as a

00:18:52,750 --> 00:18:56,710
service provided by these

00:18:53,890 --> 00:18:59,190
vendors you also have the open-source

00:18:56,710 --> 00:19:02,410
function is a service

00:18:59,190 --> 00:19:03,790
now all these open-source implementation

00:19:02,410 --> 00:19:07,120
have a build scale and the eventing

00:19:03,790 --> 00:19:08,650
module but the thing is they have a

00:19:07,120 --> 00:19:10,930
little slightly bit different

00:19:08,650 --> 00:19:12,580
implementation of this we just created a

00:19:10,930 --> 00:19:16,450
lot of fragmentation and lock-in

00:19:12,580 --> 00:19:18,280
so what a new initiative called Kennedy

00:19:16,450 --> 00:19:21,010
which was started by Google with

00:19:18,280 --> 00:19:22,720
industry leaders what it has done is

00:19:21,010 --> 00:19:24,370
it's equipment it is based platform to

00:19:22,720 --> 00:19:26,290
build deploy and manage your modern

00:19:24,370 --> 00:19:28,270
service workloads so it has the same

00:19:26,290 --> 00:19:31,570
serving build and eventing serving is

00:19:28,270 --> 00:19:34,450
basically scaled to zero build is given

00:19:31,570 --> 00:19:37,270
your source code it it does source to

00:19:34,450 --> 00:19:39,400
image events is how do you manage

00:19:37,270 --> 00:19:42,370
subscriptions and delivery of events to

00:19:39,400 --> 00:19:43,930
these functions right so we'll be using

00:19:42,370 --> 00:19:46,000
riff it's an open source project in

00:19:43,930 --> 00:19:48,700
pivotal it stands for reference of

00:19:46,000 --> 00:19:51,400
functions that's the URL if you're

00:19:48,700 --> 00:19:53,320
interested go have a look please it

00:19:51,400 --> 00:19:54,910
builds upon Kennedy and is going to be

00:19:53,320 --> 00:19:57,310
the foundation for our future product

00:19:54,910 --> 00:19:59,890
called pivotal function service right

00:19:57,310 --> 00:20:02,050
now let's get into deploying these even

00:19:59,890 --> 00:20:05,560
driven functions so riff as I mentioned

00:20:02,050 --> 00:20:07,630
users can ativ under the under the hood

00:20:05,560 --> 00:20:10,810
so when you do a riff system install

00:20:07,630 --> 00:20:13,510
manifest stable it goes and installs key

00:20:10,810 --> 00:20:16,200
native for you under the hood so the

00:20:13,510 --> 00:20:18,760
first step for me is to create a channel

00:20:16,200 --> 00:20:20,680
right I create a channel here with the

00:20:18,760 --> 00:20:23,350
link collector so what it's basically

00:20:20,680 --> 00:20:27,010
doing is I'm creating two channel these

00:20:23,350 --> 00:20:29,380
are K native concepts but since I'm

00:20:27,010 --> 00:20:32,320
using a Kafka bus here it's going and

00:20:29,380 --> 00:20:34,720
creating a actual Kafka topic under the

00:20:32,320 --> 00:20:36,670
hood right so once I create these two

00:20:34,720 --> 00:20:39,790
channels I'm going to have my function

00:20:36,670 --> 00:20:43,270
code deployed so I'm saying riff service

00:20:39,790 --> 00:20:45,220
create a link collector and I'm saying

00:20:43,270 --> 00:20:49,180
that's the image you need to use when

00:20:45,220 --> 00:20:50,710
you start building the when there's an

00:20:49,180 --> 00:20:53,560
event you need to start up this

00:20:50,710 --> 00:20:55,720
container now the last step is

00:20:53,560 --> 00:20:58,300
connecting the dots right I mean how you

00:20:55,720 --> 00:21:01,020
do a subscribe please subscribe and say

00:20:58,300 --> 00:21:03,510
that ok link collector is my in

00:21:01,020 --> 00:21:05,430
and whatever the cat sling collector

00:21:03,510 --> 00:21:08,910
service returns has to go into a

00:21:05,430 --> 00:21:10,680
different channel now riff writes all

00:21:08,910 --> 00:21:12,030
the complexity of the a miles and all

00:21:10,680 --> 00:21:14,630
those things which you need to create

00:21:12,030 --> 00:21:23,580
and makes it really simple for you to

00:21:14,630 --> 00:21:28,550
build this pipeline now so this is the

00:21:23,580 --> 00:21:34,610
riff command line so if I do a riff

00:21:28,550 --> 00:21:41,310
channel list you can see some of the

00:21:34,610 --> 00:21:46,920
channels which I have created okay so

00:21:41,310 --> 00:21:49,950
what I'm going to do now is I'll show

00:21:46,920 --> 00:21:52,350
you the pipeline I have built so I'll

00:21:49,950 --> 00:21:55,560
just explain what exactly this is doing

00:21:52,350 --> 00:21:57,960
initially when I go and submit a link a

00:21:55,560 --> 00:22:00,240
link goes into the link collector which

00:21:57,960 --> 00:22:03,930
is picked up by the cats link collector

00:22:00,240 --> 00:22:07,200
service and it goes and says okay basil

00:22:03,930 --> 00:22:10,230
calm has 138 links the the link fan-out

00:22:07,200 --> 00:22:11,790
channel and it puts those 138 individual

00:22:10,230 --> 00:22:13,170
links into the link from our channel the

00:22:11,790 --> 00:22:15,180
link fan our channel picks it up and

00:22:13,170 --> 00:22:16,920
puts it into the link roller channel

00:22:15,180 --> 00:22:19,710
which mean which starts going and

00:22:16,920 --> 00:22:21,930
crawling these sites individually the

00:22:19,710 --> 00:22:23,970
URLs individually and finally the cats

00:22:21,930 --> 00:22:26,100
link roller is putting that data into

00:22:23,970 --> 00:22:28,700
the link crawled channel basically these

00:22:26,100 --> 00:22:31,410
are all going into a craft topic right

00:22:28,700 --> 00:22:33,000
the machine learning module will then

00:22:31,410 --> 00:22:35,640
there's another function which gets info

00:22:33,000 --> 00:22:36,750
which picks up all this data and sends

00:22:35,640 --> 00:22:38,370
it to the machine learning module and

00:22:36,750 --> 00:22:41,280
says based on this data we have

00:22:38,370 --> 00:22:43,560
collected about this website what do you

00:22:41,280 --> 00:22:48,510
think is the category which it belongs

00:22:43,560 --> 00:22:51,450
to so so this is the high-level

00:22:48,510 --> 00:22:53,850
architecture of the app right

00:22:51,450 --> 00:22:55,950
you as a user you come in and submit a

00:22:53,850 --> 00:22:57,840
link to the web app which posts it into

00:22:55,950 --> 00:23:00,300
a queue now the queue can be managed

00:22:57,840 --> 00:23:01,830
either as part of a platform as a

00:23:00,300 --> 00:23:03,330
service because we have integrations

00:23:01,830 --> 00:23:05,550
with service broker and the open service

00:23:03,330 --> 00:23:08,059
broker API it could be managed there or

00:23:05,550 --> 00:23:14,710
it could be something running in your

00:23:08,059 --> 00:23:17,420
kubernetes system as well whatever it is

00:23:14,710 --> 00:23:19,100
those messages are picked up by the

00:23:17,420 --> 00:23:22,220
function as a service so each of them

00:23:19,100 --> 00:23:24,230
starts executing it and finally the data

00:23:22,220 --> 00:23:27,290
goes into the machine learning app on

00:23:24,230 --> 00:23:29,299
this side and finally a prediction is

00:23:27,290 --> 00:23:31,370
made and that response comes into queue

00:23:29,299 --> 00:23:34,190
picked up by the web app and shown to

00:23:31,370 --> 00:23:36,980
the end-user so basically you can see

00:23:34,190 --> 00:23:40,220
how you can place components which makes

00:23:36,980 --> 00:23:45,790
sense for a particular app section in

00:23:40,220 --> 00:23:48,140
their own in their own space right so

00:23:45,790 --> 00:23:52,730
normally you shouldn't see anything

00:23:48,140 --> 00:23:54,850
running here when you post a link that's

00:23:52,730 --> 00:23:57,200
when something should appear here so

00:23:54,850 --> 00:24:00,620
maybe I have kicked off something just

00:23:57,200 --> 00:24:04,490
before the presentation that's why it's

00:24:00,620 --> 00:24:07,669
running so with K native what happens is

00:24:04,490 --> 00:24:10,840
when when there is no activity for a

00:24:07,669 --> 00:24:14,690
particular queue the container is

00:24:10,840 --> 00:24:21,559
terminated right so if I just watch

00:24:14,690 --> 00:24:23,540
these parts now normally you wouldn't

00:24:21,559 --> 00:24:25,760
see this cats link collector here but

00:24:23,540 --> 00:24:32,230
anyway let's do just let's go and kick

00:24:25,760 --> 00:24:32,230
off a new web page I mean a new URL -

00:24:33,580 --> 00:24:41,390
and then I'll switch to the console view

00:24:38,600 --> 00:24:44,000
so that you can see the even different

00:24:41,390 --> 00:24:46,299
functions starting up in response to the

00:24:44,000 --> 00:24:46,299
event

00:24:50,620 --> 00:24:56,390
so you can see that the link collector

00:24:53,690 --> 00:24:57,620
is already there so it has started up

00:24:56,390 --> 00:24:59,510
and you can see the link fan-out

00:24:57,620 --> 00:25:02,180
starting and then the link roller

00:24:59,510 --> 00:25:03,980
initializing and then starting up right

00:25:02,180 --> 00:25:05,660
so these are the even different

00:25:03,980 --> 00:25:09,040
functions which are happening in the

00:25:05,660 --> 00:25:12,890
background they are going to crawl and

00:25:09,040 --> 00:25:18,470
you can see those responses coming in in

00:25:12,890 --> 00:25:21,020
some time for all these links right so

00:25:18,470 --> 00:25:23,180
you can see that there are 3-3

00:25:21,020 --> 00:25:25,460
containers in each part so there is an

00:25:23,180 --> 00:25:27,230
sto proxy there is also a queue proxy

00:25:25,460 --> 00:25:29,150
and your actual user container that's

00:25:27,230 --> 00:25:34,120
the business logic for your container

00:25:29,150 --> 00:25:34,120
there right so

00:25:45,639 --> 00:25:49,720
fortunately this is not a recording so I

00:25:47,590 --> 00:25:51,929
can't fast-forward this it takes some

00:25:49,720 --> 00:25:51,929
time

00:26:13,950 --> 00:26:19,370
so it's predicted it as a computer's an

00:26:16,020 --> 00:26:27,690
Internet related site based on the

00:26:19,370 --> 00:26:29,880
crawled content okay so this is the

00:26:27,690 --> 00:26:32,370
high-level architecture as I mentioned

00:26:29,880 --> 00:26:35,520
and finally I'd like to just summarize

00:26:32,370 --> 00:26:36,840
what I was just talking about

00:26:35,520 --> 00:26:39,120
so the initial question is it possible

00:26:36,840 --> 00:26:42,840
to architect an app across these

00:26:39,120 --> 00:26:47,040
abstractions Cloud Foundry I think it is

00:26:42,840 --> 00:26:48,240
I just showed you a demo of that and the

00:26:47,040 --> 00:26:50,490
other thing I want to mention is choose

00:26:48,240 --> 00:26:52,740
the right abstractions for the job most

00:26:50,490 --> 00:26:56,160
of the time I when we may you know go to

00:26:52,740 --> 00:27:00,150
customers we see there are there are

00:26:56,160 --> 00:27:02,850
apps like api's which need a DBMS or a

00:27:00,150 --> 00:27:04,350
cache just use platform as a service

00:27:02,850 --> 00:27:07,980
that's the right abstraction for running

00:27:04,350 --> 00:27:09,930
such workloads run workloads which need

00:27:07,980 --> 00:27:12,330
persistence and lot of networking

00:27:09,930 --> 00:27:16,830
requirements on continual service and

00:27:12,330 --> 00:27:20,280
even driven apps which need which have

00:27:16,830 --> 00:27:22,830
these even driven kind of patterns run

00:27:20,280 --> 00:27:26,490
it on a function as a service with that

00:27:22,830 --> 00:27:28,490
I'd like to go and distort thank you for

00:27:26,490 --> 00:27:34,819
your time

00:27:28,490 --> 00:27:34,819

YouTube URL: https://www.youtube.com/watch?v=PWz6X4tObh8


