Title: Matt Stine - Cloud Foundry and Microservices: A Mutualistic Symbiotic Relationship (CF Summit 2014)
Publication date: 2014-07-18
Playlist: Cloud Foundry Summit 2014
Description: 
	Technical track breakout session presented by Matt Stine, Platform Engineer, Cloud Foundry, Pivotal.

With businesses built around software now disrupting multiple industries that appeared to have stable leaders, the need has emerged for enterprises to create "software factories" built around the following principles:

-Streaming customer feedback directly into rapid, iterative cycles of application development
-Horizontally scaling applications to meet user demand
-Compatibility with an enormous diversity of clients, with mobility (smartphones, tablets, etc.) taking the lead
-Continuous delivery of value, shrinking the cycle time from concept to cash

Infrastructure has taken the lead in adapting to meet these needs with the move to the cloud, and Platform as a Service (PaaS) has raised the level of abstraction to a focus on an ecosystem of applications and services. However, most applications are still developed as if we're living in the previous generation of both business and infrastructure: the monolithic application. Microservices - small, loosely coupled applications that follow the Unix philosophy of "doing one thing well" - represent the application development side of enabling rapid, iterative development, horizontal scale, polyglot clients, and continuous delivery. They also enable us to scale application development and eliminate long term commitments to a single technology stack.

While microservices are simple, they are certainly not easy. It's recently been said that "microservices are not a free lunch". Interestingly enough, if you look at the concerns expressed here about microservices, you'll find that they are exactly the challenges that a PaaS is intended to address. So while microservices do not necessarily imply cloud (and vice versa), there is in fact a symbiotic relationship between the two, with each approach somehow compensating for the limitations of the other, much like the practices of eXtreme Programming.
Captions: 
	00:00:00,930 --> 00:00:04,220
[Music]

00:00:08,000 --> 00:00:13,920
hi I'm that's 9 on a platform engineer

00:00:11,160 --> 00:00:17,730
with a foundry team and today we want to

00:00:13,920 --> 00:00:20,130
talk about is what I see is a symbiotic

00:00:17,730 --> 00:00:24,180
relationship between cloud foundry and

00:00:20,130 --> 00:00:28,800
this new hotness that is microservices

00:00:24,180 --> 00:00:30,960
so I've got a few goals one is I want to

00:00:28,800 --> 00:00:32,820
kind of revisit the change in business

00:00:30,960 --> 00:00:34,860
models that's driving this not only

00:00:32,820 --> 00:00:36,989
towards path but they're also micro

00:00:34,860 --> 00:00:39,239
services and then go into micro services

00:00:36,989 --> 00:00:42,329
at a high level but then I also want to

00:00:39,239 --> 00:00:44,329
look at the pattern engine as the whole

00:00:42,329 --> 00:00:46,950
factor allocation what happens to be the

00:00:44,329 --> 00:00:50,010
active model of the cloud foundry stood

00:00:46,950 --> 00:00:51,930
for and then shows that micro services

00:00:50,010 --> 00:00:53,579
are in fact an ideal fit for that model

00:00:51,930 --> 00:00:54,809
and then finally look at some of the

00:00:53,579 --> 00:00:57,270
challenges that come along with

00:00:54,809 --> 00:00:59,520
developing apps this way and how cloud

00:00:57,270 --> 00:01:00,989
foundry actually helps to mitigate many

00:00:59,520 --> 00:01:02,609
of those concerns so actually change

00:01:00,989 --> 00:01:05,939
this slide this morning when is James

00:01:02,609 --> 00:01:07,619
changed it finally so we've we've all

00:01:05,939 --> 00:01:10,409
seen this drive it just revisited for

00:01:07,619 --> 00:01:12,270
one sentence to frame the micro services

00:01:10,409 --> 00:01:13,860
story has a very similar beginning to

00:01:12,270 --> 00:01:15,810
the Cloud Foundry story and that's that

00:01:13,860 --> 00:01:17,759
we have stable industries they've had

00:01:15,810 --> 00:01:19,590
insurance leaders and they're rapidly

00:01:17,759 --> 00:01:21,840
being disrupted they're being disrupted

00:01:19,590 --> 00:01:23,520
by businesses that have software in

00:01:21,840 --> 00:01:26,570
their core and so we throw this slide up

00:01:23,520 --> 00:01:30,299
a lot of actually fixed evaluation to

00:01:26,570 --> 00:01:32,400
write off the back you see Netflix which

00:01:30,299 --> 00:01:34,140
is one of the early champions of this

00:01:32,400 --> 00:01:36,930
micro services approach and they have a

00:01:34,140 --> 00:01:38,880
very routine presence on technical blogs

00:01:36,930 --> 00:01:42,780
and conferences where they talk about

00:01:38,880 --> 00:01:44,850
building applications this way now one

00:01:42,780 --> 00:01:46,770
of the driving factors behind both paths

00:01:44,850 --> 00:01:49,740
and micro services is this need to

00:01:46,770 --> 00:01:51,659
produce business services faster because

00:01:49,740 --> 00:01:54,870
the markets moving faster in customer

00:01:51,659 --> 00:01:56,820
behavior is driving the need for change

00:01:54,870 --> 00:01:58,680
as an example we've heard a lot about

00:01:56,820 --> 00:02:00,900
Warner Music Group and how they develop

00:01:58,680 --> 00:02:03,090
their software factory platform around

00:02:00,900 --> 00:02:04,440
Cloud Foundry to meet that challenge and

00:02:03,090 --> 00:02:06,450
the goal of all these efforts is

00:02:04,440 --> 00:02:08,910
basically do one thing shrink the

00:02:06,450 --> 00:02:11,130
distance between concept and catch and

00:02:08,910 --> 00:02:13,470
create this steady stream of value from

00:02:11,130 --> 00:02:15,240
IT to the business and so when you build

00:02:13,470 --> 00:02:16,830
a factory like this they usually built

00:02:15,240 --> 00:02:19,200
around a few common principles one

00:02:16,830 --> 00:02:23,100
obviously iterative or agile development

00:02:19,200 --> 00:02:25,230
we tighten feedback loops and poor

00:02:23,100 --> 00:02:27,270
feedback directly into the process we

00:02:25,230 --> 00:02:28,710
get feedback from the customer

00:02:27,270 --> 00:02:30,530
relationship during the development

00:02:28,710 --> 00:02:32,850
process but we also want to get feedback

00:02:30,530 --> 00:02:34,800
through deep user analytics they're

00:02:32,850 --> 00:02:37,820
attached to our production applications

00:02:34,800 --> 00:02:40,140
that are being used by real customers

00:02:37,820 --> 00:02:42,720
scaling obviously used to be

00:02:40,140 --> 00:02:45,570
accomplished vertically but that was too

00:02:42,720 --> 00:02:48,090
slow the middlee we had to reconfigure

00:02:45,570 --> 00:02:51,090
or reboot machines physically

00:02:48,090 --> 00:02:54,090
reconfigure act hardware very expensive

00:02:51,090 --> 00:02:55,770
obviously can't do this in this economy

00:02:54,090 --> 00:02:58,020
so the big players were accomplishing

00:02:55,770 --> 00:02:59,670
scale by horizontally scaling on

00:02:58,020 --> 00:03:05,580
commodity hardware and usually this is

00:02:59,670 --> 00:03:07,290
through containers lightweight VMS we

00:03:05,580 --> 00:03:10,590
also have to deal with this diversity of

00:03:07,290 --> 00:03:12,959
clients so this is the beginning of this

00:03:10,590 --> 00:03:14,850
year was the first time we measured that

00:03:12,959 --> 00:03:17,850
Internet traffic was predominantly

00:03:14,850 --> 00:03:20,220
coming from mobile devices fifty five

00:03:17,850 --> 00:03:22,709
percent forty seven percent actually

00:03:20,220 --> 00:03:25,709
coming from native apps and so the era

00:03:22,709 --> 00:03:27,320
have the the fat client has began again

00:03:25,709 --> 00:03:30,510
just how being on a much smaller

00:03:27,320 --> 00:03:32,160
platform so what we've been doing for

00:03:30,510 --> 00:03:33,989
quite some time now has flipped around

00:03:32,160 --> 00:03:35,820
then finally this idea of continuous

00:03:33,989 --> 00:03:37,530
delivery that when we develop

00:03:35,820 --> 00:03:39,390
applications we're continuously

00:03:37,530 --> 00:03:41,160
integrating but not only that we're

00:03:39,390 --> 00:03:42,860
building a package we're taking it

00:03:41,160 --> 00:03:45,209
through an automated testing pipeline

00:03:42,860 --> 00:03:47,640
deploying smaller batches more

00:03:45,209 --> 00:03:49,349
frequently and automating all testing

00:03:47,640 --> 00:03:50,670
where if a test failed

00:03:49,349 --> 00:03:52,590
we're not going to go to production but

00:03:50,670 --> 00:03:54,269
if all of these tests actually pass then

00:03:52,590 --> 00:03:56,069
the business gets to make the decision

00:03:54,269 --> 00:03:58,019
to pull that trigger and push an app

00:03:56,069 --> 00:04:00,090
into production so you take all those

00:03:58,019 --> 00:04:01,230
factors together and then driven a sea

00:04:00,090 --> 00:04:03,359
change and how we approach

00:04:01,230 --> 00:04:05,420
infrastructure infrastructure has

00:04:03,359 --> 00:04:07,500
actually been out ahead of the game and

00:04:05,420 --> 00:04:09,569
adapting to meet these needs first

00:04:07,500 --> 00:04:12,810
moving to the cloud then Cloud Foundry

00:04:09,569 --> 00:04:15,680
raising the abstraction to a focus on an

00:04:12,810 --> 00:04:18,269
ecosystem of apps and services

00:04:15,680 --> 00:04:20,280
unfortunately most applications are

00:04:18,269 --> 00:04:22,320
still being developed as if we're living

00:04:20,280 --> 00:04:23,820
in the previous generation of both

00:04:22,320 --> 00:04:27,300
business and infrastructure and that's

00:04:23,820 --> 00:04:29,039
the monolith so Mike reservist is our

00:04:27,300 --> 00:04:31,800
what these small loosely Cup of

00:04:29,039 --> 00:04:33,780
applications that follow the UNIX model

00:04:31,800 --> 00:04:36,449
of building software be one thing and

00:04:33,780 --> 00:04:40,380
one thing well and they represent the

00:04:36,449 --> 00:04:42,930
active side of enabling us to meet all

00:04:40,380 --> 00:04:45,150
these software factory concerns and they

00:04:42,930 --> 00:04:47,780
also enable us to scale application

00:04:45,150 --> 00:04:50,400
development from small teams to

00:04:47,780 --> 00:04:52,710
ecosystems of larger teams working

00:04:50,400 --> 00:04:54,930
together and one very important thing

00:04:52,710 --> 00:04:57,210
they make it cheap for us to try new

00:04:54,930 --> 00:04:58,979
ideas new architectures new technologies

00:04:57,210 --> 00:05:02,970
we no longer have these long term

00:04:58,979 --> 00:05:05,039
commitments to a single tech the problem

00:05:02,970 --> 00:05:07,620
is your enterprise dev shop you want to

00:05:05,039 --> 00:05:09,479
move this direction move towards Paul

00:05:07,620 --> 00:05:11,370
foundry moved towards micro services

00:05:09,479 --> 00:05:13,919
they have to embrace a new set of

00:05:11,370 --> 00:05:17,130
architectural constraints now cloud

00:05:13,919 --> 00:05:19,800
foundry optimizes around this 12 factor

00:05:17,130 --> 00:05:22,289
application 12 factor applications tins

00:05:19,800 --> 00:05:24,750
were small footprints stateless shared

00:05:22,289 --> 00:05:26,849
nothing architecture and they discover

00:05:24,750 --> 00:05:29,310
their configuration through lay binding

00:05:26,849 --> 00:05:31,259
to their runtime environments now my

00:05:29,310 --> 00:05:33,900
cursor versus take the 12 factors file

00:05:31,259 --> 00:05:36,210
step further by organizing services

00:05:33,900 --> 00:05:38,280
around business capabilities decoupling

00:05:36,210 --> 00:05:41,419
component change cycles and introducing

00:05:38,280 --> 00:05:43,919
techniques like poly lock persistence

00:05:41,419 --> 00:05:46,230
both of these styles and techniques

00:05:43,919 --> 00:05:48,930
represent a pre crackled apart

00:05:46,230 --> 00:05:50,790
from large footprint monolithic layered

00:05:48,930 --> 00:05:52,860
architecture applications that

00:05:50,790 --> 00:05:55,410
enterprises a traditionally employed and

00:05:52,860 --> 00:05:57,450
socia and micro services each bring

00:05:55,410 --> 00:05:59,100
their own set of unique challenges to

00:05:57,450 --> 00:06:02,490
the enterprise that's looking to move

00:05:59,100 --> 00:06:04,440
forward now what was thinking about this

00:06:02,490 --> 00:06:07,050
problem of migrating a siesta

00:06:04,440 --> 00:06:08,760
micro-services I was reminded of the

00:06:07,050 --> 00:06:11,160
challenges associated with shops

00:06:08,760 --> 00:06:13,350
adopting extreme programming in the

00:06:11,160 --> 00:06:15,780
early 2000s customers would look at this

00:06:13,350 --> 00:06:18,150
set of 13 practices and they would

00:06:15,780 --> 00:06:20,070
naturally gravitate toward a few but

00:06:18,150 --> 00:06:22,170
they would shun the others and what was

00:06:20,070 --> 00:06:24,780
incredibly difficult to communicate and

00:06:22,170 --> 00:06:27,000
I tried and failed several times was

00:06:24,780 --> 00:06:29,970
this idea that many of these practices

00:06:27,000 --> 00:06:32,640
are actually have crippling weaknesses

00:06:29,970 --> 00:06:35,880
when they're used in isolation from

00:06:32,640 --> 00:06:38,940
their siblings in the XP family and so

00:06:35,880 --> 00:06:42,480
as an example practices like say

00:06:38,940 --> 00:06:44,670
refactoring or simple design tend to be

00:06:42,480 --> 00:06:46,950
extremely difficult to use well when

00:06:44,670 --> 00:06:50,010
they're used apart from obviously this

00:06:46,950 --> 00:06:52,230
polarizing duo of pair programming and

00:06:50,010 --> 00:06:56,550
test-driven development in what testing

00:06:52,230 --> 00:06:58,890
an XP actually really means so I came to

00:06:56,550 --> 00:07:01,650
this conclusion that there is actually a

00:06:58,890 --> 00:07:05,280
symbiotic relationship between Cloud

00:07:01,650 --> 00:07:07,770
Foundry and micro services now I went to

00:07:05,280 --> 00:07:09,450
Wikipedia Wikipedia to find symbiosis is

00:07:07,770 --> 00:07:11,250
this close and often long-term

00:07:09,450 --> 00:07:14,100
interaction between two biological

00:07:11,250 --> 00:07:16,760
species if you add in mutualism it means

00:07:14,100 --> 00:07:18,900
that both of these individuals benefit

00:07:16,760 --> 00:07:20,730
so an article was published very

00:07:18,900 --> 00:07:22,740
recently it's that micro services are

00:07:20,730 --> 00:07:24,600
not a free lunch and that's absolutely

00:07:22,740 --> 00:07:27,510
true there is a significant cost

00:07:24,600 --> 00:07:30,060
associated with moving towards this

00:07:27,510 --> 00:07:32,340
style just like there is a significant

00:07:30,060 --> 00:07:34,650
cost associated with taking monolithic

00:07:32,340 --> 00:07:35,849
enterprise apps and moving a 12 factor

00:07:34,650 --> 00:07:38,550
but if you look at the

00:07:35,849 --> 00:07:40,169
Ernest many of those that are expressed

00:07:38,550 --> 00:07:42,719
off micro-services they're exactly the

00:07:40,169 --> 00:07:44,909
same challenges that CF is actually

00:07:42,719 --> 00:07:48,569
intended to address so one doesn't

00:07:44,909 --> 00:07:50,520
necessarily imply the other but there is

00:07:48,569 --> 00:07:53,580
this symbiotic relationship between the

00:07:50,520 --> 00:07:55,619
two where each somehow compensates for

00:07:53,580 --> 00:07:58,679
the weaknesses of the other much like

00:07:55,619 --> 00:08:01,379
the extreme programming practices did so

00:07:58,679 --> 00:08:03,270
let's do a brief overview of what micro

00:08:01,379 --> 00:08:06,240
services are about but first I wanted to

00:08:03,270 --> 00:08:08,369
find some terms I used to not have this

00:08:06,240 --> 00:08:10,769
slide and I added it because I got tired

00:08:08,369 --> 00:08:13,679
of waving my hands about it when I talk

00:08:10,769 --> 00:08:15,569
about simple and easy or simple versus

00:08:13,679 --> 00:08:18,360
complex easy versus hard I'm actually

00:08:15,569 --> 00:08:21,059
talking about very specific things rich

00:08:18,360 --> 00:08:23,459
nici define these terms this way in a

00:08:21,059 --> 00:08:23,789
talk he gave a strange loop back in 2011

00:08:23,459 --> 00:08:26,759
called

00:08:23,789 --> 00:08:28,469
simple made easy the idea that we like

00:08:26,759 --> 00:08:29,729
to interchange these two words but

00:08:28,469 --> 00:08:32,940
they're actually very different things

00:08:29,729 --> 00:08:34,919
simple as an objective concept you trace

00:08:32,940 --> 00:08:37,589
it back to its root word it's simple

00:08:34,919 --> 00:08:40,319
goes all the way back to sim and flexsim

00:08:37,589 --> 00:08:41,550
means one flex means fold or break so

00:08:40,319 --> 00:08:43,259
I've got a bunch of folds or braids

00:08:41,550 --> 00:08:45,810
floating around up here when I take them

00:08:43,259 --> 00:08:51,420
and I make a complex bring those things

00:08:45,810 --> 00:08:53,389
together that's many things coupled we

00:08:51,420 --> 00:08:57,089
should be able to look at a system and

00:08:53,389 --> 00:08:59,790
tell whether it's a simplex or a complex

00:08:57,089 --> 00:09:01,649
and come up with the same answer now

00:08:59,790 --> 00:09:03,089
easy is very different you trace these

00:09:01,649 --> 00:09:04,829
back to where it came from

00:09:03,089 --> 00:09:08,189
adjacent that means something that lies

00:09:04,829 --> 00:09:10,319
near to me so my clicker here lies near

00:09:08,189 --> 00:09:12,509
to me the camera in the back of the room

00:09:10,319 --> 00:09:16,980
is far away now far away doesn't be hard

00:09:12,509 --> 00:09:20,639
so the analogy breaks down but ease is a

00:09:16,980 --> 00:09:23,339
relative concept and so we can talk

00:09:20,639 --> 00:09:27,079
about a system that is simple but hard

00:09:23,339 --> 00:09:29,189
or a system that is complex but easy

00:09:27,079 --> 00:09:32,189
which happens to be with them on what

00:09:29,189 --> 00:09:34,560
the kharka texture is so we have what a

00:09:32,189 --> 00:09:36,930
large monolithic enterprise usually

00:09:34,560 --> 00:09:38,790
relational DB often pre-existing to the

00:09:36,930 --> 00:09:40,769
app we have a layered monolithic

00:09:38,790 --> 00:09:43,139
architecture we've got data access

00:09:40,769 --> 00:09:43,769
victus we've got service beings if we're

00:09:43,139 --> 00:09:45,720
in Java

00:09:43,769 --> 00:09:48,509
we've got server-side NBC we have to

00:09:45,720 --> 00:09:51,540
play D perhaps we have a smattering of

00:09:48,509 --> 00:09:54,360
JavaScript and Ajax and it's delivered

00:09:51,540 --> 00:10:01,439
to the browser now what can we say about

00:09:54,360 --> 00:10:03,480
these they're complex we have a bunch of

00:10:01,439 --> 00:10:05,879
business concerns that are brought

00:10:03,480 --> 00:10:09,029
together in a single unit but they're

00:10:05,879 --> 00:10:11,309
incredibly easy to build meaning I start

00:10:09,029 --> 00:10:13,079
a code base I open it up in the IDE and

00:10:11,309 --> 00:10:14,879
I start coding if I want to call into

00:10:13,079 --> 00:10:17,790
another business concern I just make a

00:10:14,879 --> 00:10:19,860
method call they're very easy to start

00:10:17,790 --> 00:10:24,119
with but the longer we build them the

00:10:19,860 --> 00:10:25,980
harder they get to work with why because

00:10:24,119 --> 00:10:27,509
modularity is dependent upon the tools

00:10:25,980 --> 00:10:30,809
that the language of the framework gives

00:10:27,509 --> 00:10:32,489
us I'm usually talking about Java Java

00:10:30,809 --> 00:10:35,189
doesn't give us very good tools to do

00:10:32,489 --> 00:10:38,459
modularity we have classes we have

00:10:35,189 --> 00:10:41,790
packages but they don't really prevent

00:10:38,459 --> 00:10:44,309
us from making bad decisions we try osg

00:10:41,790 --> 00:10:46,470
I didn't take us very far from an

00:10:44,309 --> 00:10:47,999
enterprise app perspective now we're

00:10:46,470 --> 00:10:49,829
talking about services maybe that gets

00:10:47,999 --> 00:10:51,389
us better but we don't have to depend on

00:10:49,829 --> 00:10:53,249
the language of eating brain in that

00:10:51,389 --> 00:10:56,069
particular situation whereas for the

00:10:53,249 --> 00:10:58,350
monolith we do because of this change

00:10:56,069 --> 00:11:00,449
cycles get tightly coupled together why

00:10:58,350 --> 00:11:03,809
our enterprise is afraid of language

00:11:00,449 --> 00:11:06,059
like continuous deployment because

00:11:03,809 --> 00:11:07,889
they're afraid of we're never usually at

00:11:06,059 --> 00:11:10,259
a point where everything all works at

00:11:07,889 --> 00:11:11,999
the same time so this idea of deploying

00:11:10,259 --> 00:11:14,459
multiple times a day or even multiple

00:11:11,999 --> 00:11:16,110
times a week is very scary because all

00:11:14,459 --> 00:11:17,879
of these different business concerns are

00:11:16,110 --> 00:11:20,189
tightly coupled together so we can

00:11:17,879 --> 00:11:22,049
deploy his frequent engine one wiki its

00:11:20,189 --> 00:11:23,929
scale efficiently because again the part

00:11:22,049 --> 00:11:26,069
of the system that's getting hit hard is

00:11:23,929 --> 00:11:28,199
inseparable from the parts of the system

00:11:26,069 --> 00:11:30,199
that aren't we have to scale up

00:11:28,199 --> 00:11:32,910
everything or scale down everything

00:11:30,199 --> 00:11:35,069
obviously very intimidating to a new

00:11:32,910 --> 00:11:36,339
developer to walk into a codebase that's

00:11:35,069 --> 00:11:37,749
half a million lines

00:11:36,339 --> 00:11:39,730
covered across multiple business

00:11:37,749 --> 00:11:41,319
concerns and no one on the team actually

00:11:39,730 --> 00:11:43,509
knows what's going on and all the

00:11:41,319 --> 00:11:45,480
application so who's going to teach me

00:11:43,509 --> 00:11:48,129
this part when nobody actually knows

00:11:45,480 --> 00:11:49,569
also an obstacle to scaling development

00:11:48,129 --> 00:11:50,980
you take five people put them in a

00:11:49,569 --> 00:11:52,870
single codebase they might have a

00:11:50,980 --> 00:11:54,610
fighting chance of working together you

00:11:52,870 --> 00:11:56,230
take 50 people and put them in the

00:11:54,610 --> 00:11:58,209
single codebase and all of a sudden

00:11:56,230 --> 00:12:00,579
everything falls apart from the overhead

00:11:58,209 --> 00:12:02,709
associated with communicating amongst

00:12:00,579 --> 00:12:04,600
all those people and obviously we have

00:12:02,709 --> 00:12:06,399
this long-term commitment to technical

00:12:04,600 --> 00:12:09,519
stack this is why we have frameworks

00:12:06,399 --> 00:12:10,990
that if you're on the bleeding edge it

00:12:09,519 --> 00:12:12,399
outlived their usefulness but there are

00:12:10,990 --> 00:12:14,470
still companies that have huge app

00:12:12,399 --> 00:12:16,509
invites and things like struts one which

00:12:14,470 --> 00:12:19,870
at the time it was pretty cool but we've

00:12:16,509 --> 00:12:21,129
moved on so what's the difference

00:12:19,870 --> 00:12:25,240
between that and micro service

00:12:21,129 --> 00:12:28,809
architecture few things primarily rest

00:12:25,240 --> 00:12:31,449
and message driven services primarily

00:12:28,809 --> 00:12:33,999
this idea of polyglot persistence where

00:12:31,449 --> 00:12:36,370
we picked the right datastore for the

00:12:33,999 --> 00:12:39,040
job and we encapsulate the data storage

00:12:36,370 --> 00:12:41,470
semantics behind that service front-end

00:12:39,040 --> 00:12:42,999
at the API level we acknowledge the fact

00:12:41,470 --> 00:12:46,089
that we do have this diversity of

00:12:42,999 --> 00:12:48,790
clients so we see tablets we see phones

00:12:46,089 --> 00:12:50,740
we see laptops we see other apps that

00:12:48,790 --> 00:12:52,990
are talking to us and then we have this

00:12:50,740 --> 00:12:55,660
API gateway layer that we use for things

00:12:52,990 --> 00:12:57,339
like aggregating services to reduce the

00:12:55,660 --> 00:12:59,980
chattiness on the network protocol

00:12:57,339 --> 00:13:03,459
translation where a particular API

00:12:59,980 --> 00:13:05,620
people work well with say a DQ P we

00:13:03,459 --> 00:13:07,959
reduce latency and round trips we deal

00:13:05,620 --> 00:13:10,569
with mobile device fragmentation and we

00:13:07,959 --> 00:13:13,720
build these use case and device specific

00:13:10,569 --> 00:13:15,639
ap eyes that hide this cloud of services

00:13:13,720 --> 00:13:16,990
that are behind so that each of these

00:13:15,639 --> 00:13:19,029
clients doesn't have to know about

00:13:16,990 --> 00:13:22,600
everything that's going on so we get

00:13:19,029 --> 00:13:26,709
benefits on both sides of the wall micro

00:13:22,600 --> 00:13:30,370
service architectures are what they're

00:13:26,709 --> 00:13:32,220
simple because each of the one things is

00:13:30,370 --> 00:13:34,660
no longer brought together in a complex

00:13:32,220 --> 00:13:36,980
they do one thing and they do one thing

00:13:34,660 --> 00:13:40,399
well but we could argue that microts

00:13:36,980 --> 00:13:42,199
services are hard they're hard to get

00:13:40,399 --> 00:13:44,959
started we have multiple code bases we

00:13:42,199 --> 00:13:46,430
have to start to really think about what

00:13:44,959 --> 00:13:48,230
our API is look like what are the

00:13:46,430 --> 00:13:52,610
contracts between these services how we

00:13:48,230 --> 00:13:55,220
orchestrate data flows modularity is

00:13:52,610 --> 00:13:58,820
based on component services so no longer

00:13:55,220 --> 00:14:01,220
do we have to think about the Java class

00:13:58,820 --> 00:14:03,889
or the jar file or the packages being

00:14:01,220 --> 00:14:06,649
the unit of modularity we now have fixed

00:14:03,889 --> 00:14:09,199
walls code base walls API walls between

00:14:06,649 --> 00:14:11,300
services that make it a lot harder to do

00:14:09,199 --> 00:14:16,220
things like create circular dependencies

00:14:11,300 --> 00:14:18,320
and reduce encapsulation change cycles

00:14:16,220 --> 00:14:20,660
become decoupled which means I can

00:14:18,320 --> 00:14:23,060
deploy smaller batches of things faster

00:14:20,660 --> 00:14:24,980
that sounds happy to use delivery I can

00:14:23,060 --> 00:14:26,630
scale efficiently because the components

00:14:24,980 --> 00:14:28,240
that need to get it the components that

00:14:26,630 --> 00:14:30,949
don't know left alone

00:14:28,240 --> 00:14:33,350
you walk into a micro service that might

00:14:30,949 --> 00:14:36,680
be hundreds of lines of code at biggest

00:14:33,350 --> 00:14:40,730
but probably not that big that's not

00:14:36,680 --> 00:14:42,560
intimidating to a new developer I can

00:14:40,730 --> 00:14:44,990
take the 50 developers and divide them

00:14:42,560 --> 00:14:47,899
up amongst 10 or 12 services opposed to

00:14:44,990 --> 00:14:50,350
one codebase and so no longer they

00:14:47,899 --> 00:14:53,029
stepping on each other's toes and then

00:14:50,350 --> 00:14:55,970
probably one of the most important ideas

00:14:53,029 --> 00:14:59,569
is that now it no longer cost me a lot

00:14:55,970 --> 00:15:01,670
to try new technologies it no longer is

00:14:59,569 --> 00:15:03,889
a big risk to try new technologies

00:15:01,670 --> 00:15:06,560
because I'm working on very small

00:15:03,889 --> 00:15:09,139
capabilities I'm nice isolating those

00:15:06,560 --> 00:15:11,449
behind an API so if I make a bad

00:15:09,139 --> 00:15:13,040
decision I throw it away

00:15:11,449 --> 00:15:15,230
I replace it with something else the

00:15:13,040 --> 00:15:18,250
rest of the system is nonetheless there

00:15:15,230 --> 00:15:20,800
because all its aware of the API there

00:15:18,250 --> 00:15:23,089
so how do you build something like this

00:15:20,800 --> 00:15:25,370
so Martin Fowler and James Lewis

00:15:23,089 --> 00:15:28,100
recently posted an awesome article on

00:15:25,370 --> 00:15:29,600
micro services and they actually gave

00:15:28,100 --> 00:15:31,310
one of the better overviews of what the

00:15:29,600 --> 00:15:33,920
organizational restructuring to build

00:15:31,310 --> 00:15:34,970
micro services looks like so typically

00:15:33,920 --> 00:15:38,029
management is

00:15:34,970 --> 00:15:40,759
on the technology layer so they built UI

00:15:38,029 --> 00:15:43,790
team server-side logic teams database

00:15:40,759 --> 00:15:46,310
teams and when you separate teams like

00:15:43,790 --> 00:15:49,009
that simple changes almost always

00:15:46,310 --> 00:15:51,410
involve cross team projects and cross

00:15:49,009 --> 00:15:53,750
team projects are big and they take time

00:15:51,410 --> 00:15:56,000
and they take budget approval and so

00:15:53,750 --> 00:15:57,949
when a smart team does is try to stay

00:15:56,000 --> 00:16:00,050
away from the approval process as much

00:15:57,949 --> 00:16:01,399
as they can and just force the logic

00:16:00,050 --> 00:16:04,430
into whatever app they actually do have

00:16:01,399 --> 00:16:06,379
access to and so now you have logic all

00:16:04,430 --> 00:16:08,300
over the place think concerns are

00:16:06,379 --> 00:16:10,660
coupled together and this is actually an

00:16:08,300 --> 00:16:14,149
example of Conway's law in action

00:16:10,660 --> 00:16:17,180
Melvin Conway was a smart guy we weren't

00:16:14,149 --> 00:16:20,629
building on a software in 1967 in the

00:16:17,180 --> 00:16:22,610
enterprise but he came up with a law

00:16:20,629 --> 00:16:24,079
that actually makes sense today it

00:16:22,610 --> 00:16:26,240
probably makes more sense today than

00:16:24,079 --> 00:16:27,889
ever did an organization that designs

00:16:26,240 --> 00:16:33,110
the system is going to produce a design

00:16:27,889 --> 00:16:35,689
that's a copy of itself so Fowler talks

00:16:33,110 --> 00:16:38,209
about organizing not around technology

00:16:35,689 --> 00:16:39,949
but around business capabilities and so

00:16:38,209 --> 00:16:42,470
you build these cross-functional teams

00:16:39,949 --> 00:16:44,209
that include all of the roles necessary

00:16:42,470 --> 00:16:46,519
to build that particular capability

00:16:44,209 --> 00:16:49,339
whether it's user experience database

00:16:46,519 --> 00:16:51,019
product management QA development and

00:16:49,339 --> 00:16:52,819
these cross-functional teams are not

00:16:51,019 --> 00:16:55,339
only responsible for building but also

00:16:52,819 --> 00:16:57,740
operating their products and each

00:16:55,339 --> 00:16:59,449
product is split out into a number of

00:16:57,740 --> 00:17:02,360
individual services that communicate

00:16:59,449 --> 00:17:04,819
over say breast or a message bus so with

00:17:02,360 --> 00:17:07,130
a monolith on the on the Left you end up

00:17:04,819 --> 00:17:08,659
spanning too many context and so any

00:17:07,130 --> 00:17:09,860
given team member has this mental

00:17:08,659 --> 00:17:11,630
overload that they have to go through

00:17:09,860 --> 00:17:15,500
because they have to know all of the

00:17:11,630 --> 00:17:17,150
business at one time enforcing modular

00:17:15,500 --> 00:17:20,120
lines in that situation makes a great

00:17:17,150 --> 00:17:22,220
deal of discipline but we actually

00:17:20,120 --> 00:17:23,959
reduce that when we move to micro

00:17:22,220 --> 00:17:26,449
services we end up as we talked about

00:17:23,959 --> 00:17:29,690
several times already today this idea of

00:17:26,449 --> 00:17:35,690
two Pizza teams so six to around six

00:17:29,690 --> 00:17:36,920
people supporting services so how do we

00:17:35,690 --> 00:17:38,630
partition

00:17:36,920 --> 00:17:40,400
many different ways I can think about

00:17:38,630 --> 00:17:42,890
partitioning by nouns so maybe I have a

00:17:40,400 --> 00:17:44,660
product info service reverbs maybe I

00:17:42,890 --> 00:17:46,280
ship things so I have a shipping service

00:17:44,660 --> 00:17:47,660
it doesn't really matter which part of

00:17:46,280 --> 00:17:50,360
speech you pick it's all about the

00:17:47,660 --> 00:17:52,910
single responsibility principle find one

00:17:50,360 --> 00:17:54,260
capability do one thing one thing well

00:17:52,910 --> 00:17:56,630
as soon as you start to have more than

00:17:54,260 --> 00:17:58,580
one reason to change that you have too

00:17:56,630 --> 00:18:00,340
many things built into that service and

00:17:58,580 --> 00:18:02,780
you need to start to decompose again

00:18:00,340 --> 00:18:06,050
another way you can think of it is UNIX

00:18:02,780 --> 00:18:08,300
pipes and filters you're aiming to be

00:18:06,050 --> 00:18:10,610
decoupled and cohesive that's how UNIX

00:18:08,300 --> 00:18:13,550
tools work things like cut and sort

00:18:10,610 --> 00:18:15,200
unique ins and less they do one thing

00:18:13,550 --> 00:18:16,580
and one thing well and they don't really

00:18:15,200 --> 00:18:19,190
know about what the others are doing

00:18:16,580 --> 00:18:22,160
they're linked together with these dumb

00:18:19,190 --> 00:18:24,620
pipes I'm linking standard into standard

00:18:22,160 --> 00:18:27,050
out so the smarts isn't so much in the

00:18:24,620 --> 00:18:30,200
communication mechanism as it is in the

00:18:27,050 --> 00:18:32,720
services themselves colleague of mine

00:18:30,200 --> 00:18:35,630
Dale Ford calls this choreography /

00:18:32,720 --> 00:18:38,960
orchestration so we're using restitched

00:18:35,630 --> 00:18:40,760
protocols we're using messaging you know

00:18:38,960 --> 00:18:42,710
think about going to a performance when

00:18:40,760 --> 00:18:44,000
you go to the orchestra there's a person

00:18:42,710 --> 00:18:45,980
standing in front of all the musicians

00:18:44,000 --> 00:18:49,040
and he's directing movies telling them

00:18:45,980 --> 00:18:51,800
what to do it's centralized control the

00:18:49,040 --> 00:18:54,830
musician does what the conductor tells

00:18:51,800 --> 00:18:55,750
them to do at runtime you go to the

00:18:54,830 --> 00:18:59,090
ballet

00:18:55,750 --> 00:19:01,250
there's no conductor the individual

00:18:59,090 --> 00:19:04,100
dancers do what they've agreed upon at

00:19:01,250 --> 00:19:07,010
design time and at runtime the

00:19:04,100 --> 00:19:10,130
individual dancers or components they

00:19:07,010 --> 00:19:11,780
simply perform their roles interactions

00:19:10,130 --> 00:19:13,040
are decentralized the two dancers get

00:19:11,780 --> 00:19:15,740
too close to another something goes

00:19:13,040 --> 00:19:20,690
wrong they adjust they react no one's

00:19:15,740 --> 00:19:22,220
telling them what to do so now I want to

00:19:20,690 --> 00:19:24,230
switch gears and give a little overview

00:19:22,220 --> 00:19:28,490
of 12 factor out and how Cloud Foundry

00:19:24,230 --> 00:19:30,500
is tuned to support it so each of the

00:19:28,490 --> 00:19:32,150
main bullets is a point straight out

00:19:30,500 --> 00:19:36,320
that's both factored out so one code

00:19:32,150 --> 00:19:37,790
base many deploys obviously multiple

00:19:36,320 --> 00:19:39,220
code bases turning to a distributed

00:19:37,790 --> 00:19:40,840
system and

00:19:39,220 --> 00:19:43,630
since the consistent I'm sorry with the

00:19:40,840 --> 00:19:46,809
CF application Union we explicitly

00:19:43,630 --> 00:19:50,409
declare an isolate dependency so a 12

00:19:46,809 --> 00:19:52,179
factor app never relies on the existence

00:19:50,409 --> 00:19:54,520
of system wide packet in some cloud

00:19:52,179 --> 00:19:56,080
foundry they would be there unless you

00:19:54,520 --> 00:19:57,549
were to create a custom built pack that

00:19:56,080 --> 00:19:59,650
provides them you so you have to be

00:19:57,549 --> 00:20:02,200
explicit about what you're doing

00:19:59,650 --> 00:20:05,140
store config in the environment this is

00:20:02,200 --> 00:20:08,590
nicely facilitated by CF so we have a

00:20:05,140 --> 00:20:10,120
strict separation of config from code we

00:20:08,590 --> 00:20:12,730
use environment variables it's a

00:20:10,120 --> 00:20:15,190
language enter last agnostic standard we

00:20:12,730 --> 00:20:17,650
have CF set E and V we have application

00:20:15,190 --> 00:20:19,450
manifest so this is easy to work with we

00:20:17,650 --> 00:20:22,299
treat backing services as attached

00:20:19,450 --> 00:20:25,030
resources we have very nice concepts

00:20:22,299 --> 00:20:27,370
like CF create services CF find service

00:20:25,030 --> 00:20:29,260
to expose this to the developer there's

00:20:27,370 --> 00:20:30,970
no distinction in your app whether

00:20:29,260 --> 00:20:33,580
you're connected to a local service or a

00:20:30,970 --> 00:20:35,230
third-party service everything's in vcap

00:20:33,580 --> 00:20:37,750
services whether it's broker your user

00:20:35,230 --> 00:20:41,409
provided it's one way of consuming other

00:20:37,750 --> 00:20:43,240
resources strictly separate the build

00:20:41,409 --> 00:20:45,130
and run stages so if you think about the

00:20:43,240 --> 00:20:47,110
process of pushing an app an app on

00:20:45,130 --> 00:20:48,659
Cloud Foundry we build a deployable

00:20:47,110 --> 00:20:51,250
package we combine that with

00:20:48,659 --> 00:20:54,490
configuration in the environment bound

00:20:51,250 --> 00:20:56,440
services this is staging on CF and then

00:20:54,490 --> 00:20:58,900
at one time we take the droplet we

00:20:56,440 --> 00:21:00,220
deploy it to a DDA inside of a working

00:20:58,900 --> 00:21:03,330
container we have a very strict

00:21:00,220 --> 00:21:05,830
separation between all of those stages

00:21:03,330 --> 00:21:09,100
we execute the app is one or more

00:21:05,830 --> 00:21:11,110
stateless processes so Warden containers

00:21:09,100 --> 00:21:13,000
again there's no app server clustering

00:21:11,110 --> 00:21:14,650
going on there's no shared file system

00:21:13,000 --> 00:21:21,130
at least not yet

00:21:14,650 --> 00:21:22,539
and CF optimizes for this we have sticky

00:21:21,130 --> 00:21:24,730
sessions but they're not to be relied

00:21:22,539 --> 00:21:26,799
upon this is a challenge for a

00:21:24,730 --> 00:21:29,289
monolithic application monolithic

00:21:26,799 --> 00:21:31,120
applications tend to expect the ability

00:21:29,289 --> 00:21:33,910
to do things like clustering a right to

00:21:31,120 --> 00:21:36,450
a shared file system so one move

00:21:33,910 --> 00:21:40,960
price has to make export services by

00:21:36,450 --> 00:21:43,060
port binding so we have the at port

00:21:40,960 --> 00:21:46,180
environment variable that tells the app

00:21:43,060 --> 00:21:47,710
or to bind to expose HTTP or HTTPS we

00:21:46,180 --> 00:21:51,730
might have more in the future we might

00:21:47,710 --> 00:21:53,770
have raw TCP if a container is required

00:21:51,730 --> 00:21:57,280
to run the app that's injected by the

00:21:53,770 --> 00:21:59,830
build pack and then you scale out by the

00:21:57,280 --> 00:22:05,890
same process model so obviously we have

00:21:59,830 --> 00:22:08,740
CF scale app - I whatever here's another

00:22:05,890 --> 00:22:10,360
challenge for the enterprise maximize

00:22:08,740 --> 00:22:12,940
robustness with fast startup and

00:22:10,360 --> 00:22:14,590
graceful shutdown so CF can scale very

00:22:12,940 --> 00:22:16,930
quickly but it can only move as fast as

00:22:14,590 --> 00:22:19,330
your app can bootstrap itself so if you

00:22:16,930 --> 00:22:21,580
have a very large monolithic application

00:22:19,330 --> 00:22:23,740
lots of bees that need to be initialized

00:22:21,580 --> 00:22:26,470
you can run out of time now we make you

00:22:23,740 --> 00:22:28,180
able to increase that time out so that

00:22:26,470 --> 00:22:29,800
you can get your monolith up and running

00:22:28,180 --> 00:22:33,550
but you're not going to get the full

00:22:29,800 --> 00:22:37,690
benefit of a fast scaling until you can

00:22:33,550 --> 00:22:39,640
actually break that thing down obviously

00:22:37,690 --> 00:22:41,830
keep dev staging and production is some

00:22:39,640 --> 00:22:45,130
more possibilities while foundry is

00:22:41,830 --> 00:22:46,600
cloud foundry spaces provide separation

00:22:45,130 --> 00:22:48,580
and concern that there are no technical

00:22:46,600 --> 00:22:50,200
differences so you know that if your

00:22:48,580 --> 00:22:52,540
apps running in this space or this space

00:22:50,200 --> 00:22:55,090
it gets the same capabilities it gets

00:22:52,540 --> 00:22:58,390
the same services logs the bid streams

00:22:55,090 --> 00:22:59,980
we have blogger Gator waka standard out

00:22:58,390 --> 00:23:01,510
there pick it up with handle routing my

00:22:59,980 --> 00:23:04,870
handle storage concerns for the drain

00:23:01,510 --> 00:23:06,640
api the one thing we're still trying to

00:23:04,870 --> 00:23:08,440
I guess addressing the challenges this

00:23:06,640 --> 00:23:11,560
idea of roaming adamant or management

00:23:08,440 --> 00:23:13,540
tasks as one-off processes we've got

00:23:11,560 --> 00:23:15,880
some experiments like the teammate Bill

00:23:13,540 --> 00:23:18,160
pack and WebSocket D to do some of this

00:23:15,880 --> 00:23:22,570
but it's still not quite where maybe we

00:23:18,160 --> 00:23:25,690
needed to be so 12 factor +

00:23:22,570 --> 00:23:27,580
microservices I'd say fully compatible

00:23:25,690 --> 00:23:29,830
protector style was nothing we talked

00:23:27,580 --> 00:23:31,930
about in the micro services space that

00:23:29,830 --> 00:23:34,330
we would say is in opposition at 12

00:23:31,930 --> 00:23:36,290
factor advice person but I think that

00:23:34,330 --> 00:23:39,350
the ideals ball Factory

00:23:36,290 --> 00:23:41,360
is a micro service and so now we also

00:23:39,350 --> 00:23:44,120
have frameworks that tend to optimize

00:23:41,360 --> 00:23:45,620
around those same ideas so spring boots

00:23:44,120 --> 00:23:47,570
if you're not familiar with it

00:23:45,620 --> 00:23:50,510
represents the next generation of how to

00:23:47,570 --> 00:23:52,400
build server-side applications well it

00:23:50,510 --> 00:23:55,370
makes the bootstrapping cost of a new

00:23:52,400 --> 00:23:57,530
spring project approach zero it has Auto

00:23:55,370 --> 00:23:59,360
config mechanisms that give you sensible

00:23:57,530 --> 00:24:01,790
not only that but production great

00:23:59,360 --> 00:24:03,590
defaults for most of the common choices

00:24:01,790 --> 00:24:05,330
that you can want to make and then you

00:24:03,590 --> 00:24:07,550
get this extensive set of additional

00:24:05,330 --> 00:24:09,680
production rating features like metrics

00:24:07,550 --> 00:24:12,830
and health checks and externalize

00:24:09,680 --> 00:24:15,320
configuration exactly in the 12 factor

00:24:12,830 --> 00:24:16,940
style and then spring cloud takes that

00:24:15,320 --> 00:24:19,550
to the next level by giving you these

00:24:16,940 --> 00:24:21,440
very easy mechanisms for connecting to

00:24:19,550 --> 00:24:23,480
those services they're exposed to you

00:24:21,440 --> 00:24:26,180
through the environment giving you an

00:24:23,480 --> 00:24:29,480
awareness of your other environment

00:24:26,180 --> 00:24:31,340
variables so 12 factor apps that are 2d

00:24:29,480 --> 00:24:33,470
for past platforms like Cloud Foundry

00:24:31,340 --> 00:24:35,570
Perot you can run very well or as much

00:24:33,470 --> 00:24:37,450
of this was inspired by the drop Wizard

00:24:35,570 --> 00:24:39,770
framework which was one of the first JVM

00:24:37,450 --> 00:24:43,430
frameworks targeted to building apps in

00:24:39,770 --> 00:24:44,750
style so to finish up I want to take a

00:24:43,430 --> 00:24:47,090
look at the challenges that are

00:24:44,750 --> 00:24:50,180
associated with developing into this

00:24:47,090 --> 00:24:51,950
architectural style so Benjamin wound

00:24:50,180 --> 00:24:54,020
published this excellent article a

00:24:51,950 --> 00:24:56,840
couple of months ago at high scalability

00:24:54,020 --> 00:24:59,000
called microcircuit is not a free lunch

00:24:56,840 --> 00:25:01,790
and he does a very excellent job I think

00:24:59,000 --> 00:25:04,520
of summarizing the challenges that you

00:25:01,790 --> 00:25:06,980
run into when you travel down this road

00:25:04,520 --> 00:25:08,900
of micro services so we have all these

00:25:06,980 --> 00:25:11,570
different areas in which we actually do

00:25:08,900 --> 00:25:14,660
have to pay for our lunch and so what I

00:25:11,570 --> 00:25:17,540
want to do is focus in on four of these

00:25:14,660 --> 00:25:20,390
bullets that I think pop boundary has a

00:25:17,540 --> 00:25:23,090
lot to say about so first he goes

00:25:20,390 --> 00:25:24,410
through the operations overhead that we

00:25:23,090 --> 00:25:26,810
run into and I want to walk through

00:25:24,410 --> 00:25:29,240
these bullet by bullet and basically

00:25:26,810 --> 00:25:33,350
show how boundary addresses absolutely

00:25:29,240 --> 00:25:34,860
all of them so I have all these micro

00:25:33,350 --> 00:25:37,559
services to build tests

00:25:34,860 --> 00:25:39,120
ploy and run and I have polyglot

00:25:37,559 --> 00:25:42,210
languages and I have in all these

00:25:39,120 --> 00:25:44,280
different environments this is exactly a

00:25:42,210 --> 00:25:49,140
set of concerns that cloud foundry built

00:25:44,280 --> 00:25:51,030
acts are intended to address of course

00:25:49,140 --> 00:25:52,980
all those services are going to be

00:25:51,030 --> 00:25:55,470
clustering for fails or they're going to

00:25:52,980 --> 00:25:58,679
need resilience and so your single

00:25:55,470 --> 00:26:01,200
monolithic system becomes 20 services

00:25:58,679 --> 00:26:04,440
and maybe those are 40 or 60 processes

00:26:01,200 --> 00:26:07,260
after we've scaled for H a and obviously

00:26:04,440 --> 00:26:10,559
this is what Cloud Foundry CF scale the

00:26:07,260 --> 00:26:13,830
health monitor FH a placement pools all

00:26:10,559 --> 00:26:15,450
this was intended to address he then

00:26:13,830 --> 00:26:19,049
goes on to say we'll throw in load

00:26:15,450 --> 00:26:21,059
balancing boundary router messaging

00:26:19,049 --> 00:26:23,640
layers for plumbing between the services

00:26:21,059 --> 00:26:29,840
Cloud Foundry services like RabbitMQ

00:26:23,640 --> 00:26:33,990
iron and Q Redis you need high quality

00:26:29,840 --> 00:26:35,490
monitoring to productionize your apps so

00:26:33,990 --> 00:26:36,840
we have agent based monitoring and

00:26:35,490 --> 00:26:39,809
things like New Relic and have dynamic

00:26:36,840 --> 00:26:43,700
spring insight integrated ap I'm coming

00:26:39,809 --> 00:26:46,080
at pivotal CF we need a very strong

00:26:43,700 --> 00:26:49,919
Operations infrastructure we have a

00:26:46,080 --> 00:26:52,380
boundary box and then we also need a

00:26:49,919 --> 00:26:54,809
very sophisticated release deployment

00:26:52,380 --> 00:26:57,870
automation infrastructure so the Cloud

00:26:54,809 --> 00:27:00,480
Foundry API is obviously available we

00:26:57,870 --> 00:27:02,700
have a scriptable CLI now we have made

00:27:00,480 --> 00:27:04,410
any Gradle plugins and we have strong

00:27:02,700 --> 00:27:08,940
partnerships with companies like cloud

00:27:04,410 --> 00:27:13,020
beans around Jenkins so I pulled this

00:27:08,940 --> 00:27:14,640
one paragraph so there's not much in

00:27:13,020 --> 00:27:16,500
terms of frameworks than open source

00:27:14,640 --> 00:27:20,100
tools to support this from operational

00:27:16,500 --> 00:27:21,480
perspective and it's likely that if you

00:27:20,100 --> 00:27:22,919
want to roll this out as an enterprise

00:27:21,480 --> 00:27:26,010
you got to make a significant investment

00:27:22,919 --> 00:27:27,900
in customer christian or development to

00:27:26,010 --> 00:27:29,309
manage these processes before they write

00:27:27,900 --> 00:27:30,390
a line of code that delivers any

00:27:29,309 --> 00:27:34,559
business value

00:27:30,390 --> 00:27:36,660
now I greatly respect the analysis in

00:27:34,559 --> 00:27:39,950
this article but this portion for me was

00:27:36,660 --> 00:27:39,950
just wow

00:27:41,399 --> 00:27:50,370
what no open-source tooling are we

00:27:43,929 --> 00:27:54,460
talking about substantial DevOps skills

00:27:50,370 --> 00:27:57,610
this is a problem I think DevOps skills

00:27:54,460 --> 00:28:00,070
are a good thing in any architecture you

00:27:57,610 --> 00:28:02,710
definitely need high-quality DevOps and

00:28:00,070 --> 00:28:04,929
automation release skills embedded in

00:28:02,710 --> 00:28:08,590
your development team it's just a good

00:28:04,929 --> 00:28:11,019
idea dev teams he goes only talk about

00:28:08,590 --> 00:28:13,090
dev teams running Tomcat clusters and

00:28:11,019 --> 00:28:15,130
keeping them available and because we're

00:28:13,090 --> 00:28:16,480
going to micro services now they have a

00:28:15,130 --> 00:28:18,610
whole bunch of other things that need to

00:28:16,480 --> 00:28:20,260
be aware of and keep running you don't

00:28:18,610 --> 00:28:23,500
keep stuff running on Cloud Foundry

00:28:20,260 --> 00:28:25,179
Cloud Foundry does that for you you have

00:28:23,500 --> 00:28:27,010
build packs to set up your runtime

00:28:25,179 --> 00:28:29,169
environments you have the health monitor

00:28:27,010 --> 00:28:31,480
to keep things running he talks about

00:28:29,169 --> 00:28:33,639
not throwing apps built in the SAP style

00:28:31,480 --> 00:28:35,110
over the wall to an ops team well with

00:28:33,639 --> 00:28:38,529
cloud foundry you don't you shouldn't be

00:28:35,110 --> 00:28:40,330
doing that anyway you need an

00:28:38,529 --> 00:28:42,760
operationally focused dev team that's

00:28:40,330 --> 00:28:45,070
production aware well CF you have such

00:28:42,760 --> 00:28:47,019
dev and prosperity I know what my code

00:28:45,070 --> 00:28:50,080
is going to look like when it's running

00:28:47,019 --> 00:28:51,909
in production services need their own

00:28:50,080 --> 00:28:54,010
data stores we're trying to do valve

00:28:51,909 --> 00:28:55,419
polyglot persistence so now that they

00:28:54,010 --> 00:28:57,309
know the team also needs to know how to

00:28:55,419 --> 00:29:01,659
deploy and run and optimize and support

00:28:57,309 --> 00:29:04,120
all the new sequel products Zia Bosh CF

00:29:01,659 --> 00:29:08,679
service brokers I think we've got a lot

00:29:04,120 --> 00:29:12,880
of this covered distributed systems are

00:29:08,679 --> 00:29:14,320
complex I agree once we have a

00:29:12,880 --> 00:29:15,340
distributed system we have a lot of

00:29:14,320 --> 00:29:16,990
other things that we

00:29:15,340 --> 00:29:18,820
think about we don't solve all these in

00:29:16,990 --> 00:29:22,600
Cloud Foundry yet we start to solve some

00:29:18,820 --> 00:29:25,110
of them we help you deal with your

00:29:22,600 --> 00:29:26,919
networks we hate you help you deal with

00:29:25,110 --> 00:29:29,440
fault-tolerance we help you deal with

00:29:26,919 --> 00:29:31,539
load variability your scaling auto

00:29:29,440 --> 00:29:36,999
scaling that's coming in the typical CF

00:29:31,539 --> 00:29:38,289
product APM that's coming testability it

00:29:36,999 --> 00:29:40,120
can be difficult to recreate

00:29:38,289 --> 00:29:42,879
environments the consistent way from an

00:29:40,120 --> 00:29:48,249
your automated testing no it's just CF

00:29:42,879 --> 00:29:50,230
push bill packs do the rest you add a

00:29:48,249 --> 00:29:52,389
synchronicity you add dynamic message

00:29:50,230 --> 00:29:54,009
loads it becomes harder to test systems

00:29:52,389 --> 00:29:56,590
because you can't set up the

00:29:54,009 --> 00:29:58,539
environments to test the full Cloud

00:29:56,590 --> 00:30:00,220
Foundry deployment service binding makes

00:29:58,539 --> 00:30:02,889
getting this type of system provision

00:30:00,220 --> 00:30:04,899
easy and so it helps to mitigate that it

00:30:02,889 --> 00:30:07,570
obviously doesn't get rid of knowing how

00:30:04,899 --> 00:30:09,730
to do asynchronous programming well but

00:30:07,570 --> 00:30:12,999
it does in able us to get the test

00:30:09,730 --> 00:30:15,519
environments up he goes on to say

00:30:12,999 --> 00:30:18,279
idiomatic micro services involves less

00:30:15,519 --> 00:30:21,970
emphasis on testing and more on

00:30:18,279 --> 00:30:23,740
monitoring fine if that were true Cloud

00:30:21,970 --> 00:30:25,899
Foundry is enabling the monitoring

00:30:23,740 --> 00:30:28,809
approach we have very cool stuff coming

00:30:25,899 --> 00:30:30,490
on that front so we can start to spot

00:30:28,809 --> 00:30:32,769
anomalies in production we can roll back

00:30:30,490 --> 00:30:35,519
we can take appropriate action but this

00:30:32,769 --> 00:30:37,929
idea that we don't do much testing and

00:30:35,519 --> 00:30:40,119
micro services think about Cloud Foundry

00:30:37,929 --> 00:30:42,549
what is co-founder it's a micro services

00:30:40,119 --> 00:30:44,649
architecture Alice Cloud Foundry

00:30:42,549 --> 00:30:48,789
developed obsessive test-driven

00:30:44,649 --> 00:30:52,419
development so it's not a set of

00:30:48,789 --> 00:30:55,960
concerns that you can't have together so

00:30:52,419 --> 00:30:57,909
I think it's safe to say that micro

00:30:55,960 --> 00:31:00,730
services are an ideal style for

00:30:57,909 --> 00:31:02,559
developing apps for Cloud Foundry and I

00:31:00,730 --> 00:31:04,419
think Cloud Foundry is an ideal hosting

00:31:02,559 --> 00:31:06,929
platform for micro services because I

00:31:04,419 --> 00:31:11,910
think where one is weak the other

00:31:06,929 --> 00:31:14,900
happens to make it strong Thanks

00:31:11,910 --> 00:31:18,189
[Applause]

00:31:14,900 --> 00:31:18,189

YouTube URL: https://www.youtube.com/watch?v=RGZefc92tZs


