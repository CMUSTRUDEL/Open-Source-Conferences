Title: Vinícius Carvalho - Cloud Foundry Cookbook (Cloud Foundry Summit 2014)
Publication date: 2014-07-28
Playlist: Cloud Foundry Summit 2014
Description: 
	Technical track breakout session presented by Vinícius Carvalho, Senior Field Engineer, Pivotal.

Cloud Foundry Cookbook: Recipes for a Successful Cloud Foundry Deployment in Production

Cloud Foundry provides the foundation for your PaaS infrastructure. It streamlines deployment and turns your developers and your ops into super heroes when it comes to time to market. But what about your architecture? How should you build your services (or microservices)? How can you guarantee security is being enforced on every layer of your architecture? How can you solve cross-service dependencies? How can services discover each other? How could developers leverage an API explorer to test your services and build apps on top of it? How could you leverage a data pipeline to solve polyglot persistence and cascading operations on diverse persistence technologies? How can you monetize on top of your public services? How could you use a service registry to boost your models with extended metadata?

This session presents a few recipes to demonstrate how to solve some of the problems found when applying cloud patterns to real business scenarios.
Captions: 
	00:00:00,930 --> 00:00:04,220
[Music]

00:00:08,269 --> 00:00:15,360
my name is vinicius I'm a fuel engineer

00:00:12,030 --> 00:00:16,859
for pivotal but before joining pivotal I

00:00:15,360 --> 00:00:20,910
was actually working at Warner Music

00:00:16,859 --> 00:00:24,930
Group and there I was the lead architect

00:00:20,910 --> 00:00:26,699
for the engineering team I work with

00:00:24,930 --> 00:00:30,720
Brian MacLean and if you guys saw his

00:00:26,699 --> 00:00:33,120
presentation prior to this I was the his

00:00:30,720 --> 00:00:37,200
counterpart on the development team so

00:00:33,120 --> 00:00:40,410
this presentation is about some things

00:00:37,200 --> 00:00:44,100
that I've learned when I was there and

00:00:40,410 --> 00:00:46,950
trying to get our applications into

00:00:44,100 --> 00:00:49,559
production right and what does it really

00:00:46,950 --> 00:00:52,860
means for you to develop into cloud

00:00:49,559 --> 00:00:55,530
foundry to give you a little bit more

00:00:52,860 --> 00:00:59,969
about my background I've been working

00:00:55,530 --> 00:01:01,320
with Java for the past 12 years and I

00:00:59,969 --> 00:01:04,589
worked from startups to large

00:01:01,320 --> 00:01:09,090
corporations like Ericsson I've been an

00:01:04,589 --> 00:01:12,570
architect a engineer product owner and

00:01:09,090 --> 00:01:15,530
scrum master but at the essence I like

00:01:12,570 --> 00:01:18,930
to think myself as I'm a developer and

00:01:15,530 --> 00:01:22,979
that's that's the reason I love Cloud

00:01:18,930 --> 00:01:27,299
Foundry I first heard about Cloud

00:01:22,979 --> 00:01:29,400
Foundry back in 2011 and since then I

00:01:27,299 --> 00:01:31,500
when I look into profits hey this thing

00:01:29,400 --> 00:01:33,600
is awesome right this thing can actually

00:01:31,500 --> 00:01:35,549
make my life easier and I was blessed

00:01:33,600 --> 00:01:38,540
that I was part of Warner music when

00:01:35,549 --> 00:01:41,430
they they started their journey into

00:01:38,540 --> 00:01:44,040
actually getting Cloud Foundry as the

00:01:41,430 --> 00:01:47,820
platform of choice and to me when I look

00:01:44,040 --> 00:01:49,860
into called foundry I see this right you

00:01:47,820 --> 00:01:55,829
if you're a developer you get called the

00:01:49,860 --> 00:02:00,030
foundry it's your super power up but in

00:01:55,829 --> 00:02:03,420
reality and someone already made this

00:02:00,030 --> 00:02:05,790
joke before myself with great power

00:02:03,420 --> 00:02:08,489
comes great responsibility but it's it's

00:02:05,790 --> 00:02:10,319
true right what cloud fun will do with

00:02:08,489 --> 00:02:12,780
your team if your enterprise are tight

00:02:10,319 --> 00:02:13,590
and you want to start using cloud

00:02:12,780 --> 00:02:17,670
fundraiser player

00:02:13,590 --> 00:02:19,890
form it raises the bar right because you

00:02:17,670 --> 00:02:22,290
get how this neat cool things that you

00:02:19,890 --> 00:02:27,150
guys been hearing you know hearing about

00:02:22,290 --> 00:02:30,030
which is self-healing right H a push of

00:02:27,150 --> 00:02:33,360
an application in in a you know one line

00:02:30,030 --> 00:02:35,819
of code so for you developer out there

00:02:33,360 --> 00:02:38,400
in Arctic it means that you have to

00:02:35,819 --> 00:02:40,500
raise your bar now you don't have that

00:02:38,400 --> 00:02:42,629
excuse when your boss calls you and say

00:02:40,500 --> 00:02:44,099
hey why we have so many problems in your

00:02:42,629 --> 00:02:45,299
code and say well I don't have time to

00:02:44,099 --> 00:02:47,730
do that because I'm worrying about

00:02:45,299 --> 00:02:51,150
infrastructure right you really need to

00:02:47,730 --> 00:02:54,890
start pushing yourself harder and the

00:02:51,150 --> 00:02:58,170
challenges that we faced when going to

00:02:54,890 --> 00:03:00,480
cloud foundry one of the first of them

00:02:58,170 --> 00:03:02,819
was that in large distributed systems

00:03:00,480 --> 00:03:04,860
the failure actually is a norm it's not

00:03:02,819 --> 00:03:06,959
an exception now the Hadoop guys know

00:03:04,860 --> 00:03:09,420
this quite well data great guys know

00:03:06,959 --> 00:03:10,940
that quite well but if you're trying to

00:03:09,420 --> 00:03:13,709
embrace the micro service architecture

00:03:10,940 --> 00:03:17,910
that's going to become you know your

00:03:13,709 --> 00:03:21,180
norm as well and again cloud foundry is

00:03:17,910 --> 00:03:23,549
a reliable platform it has a chain

00:03:21,180 --> 00:03:26,190
self-healing but the question is does

00:03:23,549 --> 00:03:30,000
your code is support that are you ready

00:03:26,190 --> 00:03:32,220
for for that type of things right the

00:03:30,000 --> 00:03:35,340
next thing is you give the developer a

00:03:32,220 --> 00:03:38,579
great experience to push applications

00:03:35,340 --> 00:03:40,829
you have a nice console to check your

00:03:38,579 --> 00:03:42,690
services and binding services they will

00:03:40,829 --> 00:03:45,480
come back to you and say I also want a

00:03:42,690 --> 00:03:50,099
better experience of my API or the api's

00:03:45,480 --> 00:03:51,480
you're providing to me right and how how

00:03:50,099 --> 00:03:54,180
can you even for security an access

00:03:51,480 --> 00:03:57,299
control of your endpoints the service

00:03:54,180 --> 00:04:00,930
discovery right and of how can you avoid

00:03:57,299 --> 00:04:02,730
duplication and guys I know a lot of

00:04:00,930 --> 00:04:05,340
those things here they are recurring

00:04:02,730 --> 00:04:09,389
topics in our industry but one thing I

00:04:05,340 --> 00:04:11,069
can tell you is everyone has duplication

00:04:09,389 --> 00:04:13,889
of code in their companies that's that's

00:04:11,069 --> 00:04:15,630
the norm now if you have that with your

00:04:13,889 --> 00:04:18,209
developers taking weeks or months to

00:04:15,630 --> 00:04:20,190
push applications how far how much

00:04:18,209 --> 00:04:21,510
duplication you think you can have when

00:04:20,190 --> 00:04:23,610
they can push applications in a matter

00:04:21,510 --> 00:04:25,140
of hours right so if you don't start

00:04:23,610 --> 00:04:26,169
tackling this problem at the very

00:04:25,140 --> 00:04:28,150
beginning

00:04:26,169 --> 00:04:30,340
it's gonna come back and haunt you right

00:04:28,150 --> 00:04:33,520
so I'm going to start talking first at

00:04:30,340 --> 00:04:35,229
about the experience right and I'm

00:04:33,520 --> 00:04:37,300
assuming here we're building rest

00:04:35,229 --> 00:04:39,460
services just just for the sake of this

00:04:37,300 --> 00:04:41,080
presentation right so if you're really

00:04:39,460 --> 00:04:42,969
building rest services right it means

00:04:41,080 --> 00:04:45,129
that you're using curl a lot to consume

00:04:42,969 --> 00:04:46,090
your applications your developers are

00:04:45,129 --> 00:04:49,300
going to come back to you and say hey

00:04:46,090 --> 00:04:52,659
why can't you give me this right which

00:04:49,300 --> 00:04:53,830
is an API Explorer like Foursquare has

00:04:52,659 --> 00:04:57,219
it twitter has it

00:04:53,830 --> 00:04:59,830
I mean you your platform has that I can

00:04:57,219 --> 00:05:01,029
have a nice console why can't I consume

00:04:59,830 --> 00:05:02,650
my services like this

00:05:01,029 --> 00:05:06,400
so he actually it turns out that you can

00:05:02,650 --> 00:05:09,150
and you can use something called swagger

00:05:06,400 --> 00:05:12,099
so embracing swagger was one of our

00:05:09,150 --> 00:05:15,069
initial thoughts you can have a nice UI

00:05:12,099 --> 00:05:18,310
to consume your endpoints swagger is an

00:05:15,069 --> 00:05:20,680
API description for rest services but

00:05:18,310 --> 00:05:23,050
also has jQuery plugins right so that

00:05:20,680 --> 00:05:26,289
was the first step it's okay I give you

00:05:23,050 --> 00:05:29,020
an endpoint I give an API to consume you

00:05:26,289 --> 00:05:31,240
go to a browser and you can actually use

00:05:29,020 --> 00:05:33,189
it it makes much nicer experience for

00:05:31,240 --> 00:05:34,240
developers to start consuming the

00:05:33,189 --> 00:05:37,330
services you're building in your

00:05:34,240 --> 00:05:39,279
infrastructure and other talking about

00:05:37,330 --> 00:05:41,949
services right if I could take a

00:05:39,279 --> 00:05:44,740
constellation and mimic services this is

00:05:41,949 --> 00:05:47,830
what I pretty much can say that any

00:05:44,740 --> 00:05:50,229
corporation has those days you have this

00:05:47,830 --> 00:05:52,210
clusters right where they're probably

00:05:50,229 --> 00:05:53,919
the core business services and you know

00:05:52,210 --> 00:05:55,539
about them and you you're there

00:05:53,919 --> 00:05:58,449
documented people know what they're

00:05:55,539 --> 00:06:00,580
doing but what about this guy's here who

00:05:58,449 --> 00:06:03,759
the hell are them right and every

00:06:00,580 --> 00:06:05,529
company has that and and yesterday I was

00:06:03,759 --> 00:06:07,180
talking to two friends of mine and they

00:06:05,529 --> 00:06:08,949
were discussing about the legacy and say

00:06:07,180 --> 00:06:11,620
hey we have so much legacy in our

00:06:08,949 --> 00:06:13,839
company that I don't know who is using

00:06:11,620 --> 00:06:15,430
those services I might as well you know

00:06:13,839 --> 00:06:17,800
turn off the switch of those some

00:06:15,430 --> 00:06:22,449
machines wait a couple of weeks and see

00:06:17,800 --> 00:06:24,250
what happens right and guys you're

00:06:22,449 --> 00:06:26,199
starting a new landscape right you're

00:06:24,250 --> 00:06:28,000
starting with a pass you don't want to

00:06:26,199 --> 00:06:29,349
repeat the same errors in the past you

00:06:28,000 --> 00:06:31,300
want to make sure that you have all

00:06:29,349 --> 00:06:32,620
those things you know documented and

00:06:31,300 --> 00:06:35,490
where they stored now Cloud Foundry

00:06:32,620 --> 00:06:37,479
gives you part of that when you're doing

00:06:35,490 --> 00:06:38,620
the application deployment and the

00:06:37,479 --> 00:06:41,680
console but

00:06:38,620 --> 00:06:43,870
really with each service is you need a

00:06:41,680 --> 00:06:48,100
service registry right and then that was

00:06:43,870 --> 00:06:50,490
the next thing that we had to build so I

00:06:48,100 --> 00:06:52,660
understand that Cloud Foundry supports

00:06:50,490 --> 00:06:54,700
has a service registry actually the

00:06:52,660 --> 00:06:56,590
service broker is a service registry but

00:06:54,700 --> 00:06:58,510
here I'm talking more about service

00:06:56,590 --> 00:07:02,410
registering in the sense of a rest

00:06:58,510 --> 00:07:05,260
service registry ok so we start with

00:07:02,410 --> 00:07:07,780
something you know at entry architecture

00:07:05,260 --> 00:07:10,450
you have services instances and API

00:07:07,780 --> 00:07:12,720
endpoints and for each endpoint you add

00:07:10,450 --> 00:07:15,460
some metadata

00:07:12,720 --> 00:07:17,230
I got inspired actually by Apache

00:07:15,460 --> 00:07:18,990
creator they have a nice service

00:07:17,230 --> 00:07:23,860
discovery for zookeeper

00:07:18,990 --> 00:07:25,570
so if talk about the API swagger has a

00:07:23,860 --> 00:07:28,450
convention that there's an endpoint

00:07:25,570 --> 00:07:31,480
forward slash API for slash API dogs

00:07:28,450 --> 00:07:33,430
that describes your endpoints the next

00:07:31,480 --> 00:07:36,660
thing is you do have some endpoints

00:07:33,430 --> 00:07:39,310
there I get users or put a user by ID

00:07:36,660 --> 00:07:41,410
now that's where things gets started

00:07:39,310 --> 00:07:43,660
getting interesting if you can start

00:07:41,410 --> 00:07:45,760
putting security metadata for your

00:07:43,660 --> 00:07:49,210
services there when I say ok for to get

00:07:45,760 --> 00:07:52,030
users for a given client ID I want to

00:07:49,210 --> 00:07:54,520
allow a group of set of rules to access

00:07:52,030 --> 00:07:56,380
that endpoint and note when I talk about

00:07:54,520 --> 00:07:58,840
client ID I'm really talking about OAuth

00:07:56,380 --> 00:08:03,130
client ID right I'm gonna touch the UAE

00:07:58,840 --> 00:08:04,600
partners shut in the short term but if

00:08:03,130 --> 00:08:06,640
you're really thinking about building

00:08:04,600 --> 00:08:08,620
services that are gonna be consumed by

00:08:06,640 --> 00:08:11,290
multiple applications they might have

00:08:08,620 --> 00:08:13,740
different roles per application you want

00:08:11,290 --> 00:08:16,810
to start this here and not in your code

00:08:13,740 --> 00:08:20,010
you might add some UI metadata right I

00:08:16,810 --> 00:08:22,770
mean if you're really building widgets

00:08:20,010 --> 00:08:25,630
reusable widgets you might need some

00:08:22,770 --> 00:08:28,900
hints on how you want to present that

00:08:25,630 --> 00:08:30,460
even they're consuming a service quality

00:08:28,900 --> 00:08:34,210
of services right you might want to be

00:08:30,460 --> 00:08:37,060
limiting your API calls and billing as

00:08:34,210 --> 00:08:38,620
well so all these information and you

00:08:37,060 --> 00:08:40,870
can do whatever you want here it depends

00:08:38,620 --> 00:08:43,450
on your corporation but you do have a

00:08:40,870 --> 00:08:46,420
nice your structure service registry

00:08:43,450 --> 00:08:48,040
where you can count on having all the

00:08:46,420 --> 00:08:48,700
services no matter data associated in

00:08:48,040 --> 00:08:51,399
one place

00:08:48,700 --> 00:08:54,279
now during this should be pretty simple

00:08:51,399 --> 00:08:56,320
pick a database of your choice and you

00:08:54,279 --> 00:08:57,910
write it you have it the next part is

00:08:56,320 --> 00:09:00,760
how do you discover how you make

00:08:57,910 --> 00:09:02,820
discovery you know possible so you guys

00:09:00,760 --> 00:09:05,829
might haven't seen this slide before

00:09:02,820 --> 00:09:08,410
it's a short version so let's say that I

00:09:05,829 --> 00:09:12,010
push an app it's on my da now it's it's

00:09:08,410 --> 00:09:13,750
it's ready for action one approach would

00:09:12,010 --> 00:09:15,700
be make your application go to the

00:09:13,750 --> 00:09:21,640
service registry and say hey I'm here

00:09:15,700 --> 00:09:23,620
you can grab my metadata right but this

00:09:21,640 --> 00:09:25,720
actually leads to a problem what if a

00:09:23,620 --> 00:09:27,490
developer forgets you call the registry

00:09:25,720 --> 00:09:29,589
right I mean binding the registry should

00:09:27,490 --> 00:09:31,930
be easy it can be just a custom user

00:09:29,589 --> 00:09:33,880
provided service in Cloud Foundry so

00:09:31,930 --> 00:09:36,279
another approach could be make your

00:09:33,880 --> 00:09:38,950
registry calls the Club controller

00:09:36,279 --> 00:09:42,010
there's a experimental API for events

00:09:38,950 --> 00:09:43,990
and one of the events is app create so

00:09:42,010 --> 00:09:46,240
once an application gets created your

00:09:43,990 --> 00:09:48,790
registry go back to your application say

00:09:46,240 --> 00:09:50,440
ok now give me back the metadata now a

00:09:48,790 --> 00:09:54,940
reg is populated with all information

00:09:50,440 --> 00:09:57,399
and you have the registry part so we

00:09:54,940 --> 00:09:59,890
have the registry we have a nice API

00:09:57,399 --> 00:10:02,440
description how can you actually enforce

00:09:59,890 --> 00:10:05,640
that those things work ok

00:10:02,440 --> 00:10:08,560
there's tons of way of doing that right

00:10:05,640 --> 00:10:12,300
if you're just doing Java code you could

00:10:08,560 --> 00:10:14,800
just bundle a jar with your service and

00:10:12,300 --> 00:10:17,320
use that information so for example you

00:10:14,800 --> 00:10:20,260
spring security for the security part

00:10:17,320 --> 00:10:23,100
but if your services are built in

00:10:20,260 --> 00:10:26,110
multiple languages not only Java right

00:10:23,100 --> 00:10:27,880
one idea is to have a service proxy

00:10:26,110 --> 00:10:30,579
right and the service proxy is just an

00:10:27,880 --> 00:10:35,110
HTTP proxy and turns out to be a nati

00:10:30,579 --> 00:10:37,000
pipeline so that is just is for you for

00:10:35,110 --> 00:10:39,670
those who doesn't know who natty is that

00:10:37,000 --> 00:10:41,550
is this fantastic niño project that a

00:10:39,670 --> 00:10:44,860
lot of cool things are built on top of

00:10:41,550 --> 00:10:46,930
reactor TCP elasticsearch they all rely

00:10:44,860 --> 00:10:49,930
on it and on addy it's pretty simple

00:10:46,930 --> 00:10:53,529
architecture right so user send a

00:10:49,930 --> 00:10:56,079
request right the proxy will intercept

00:10:53,529 --> 00:10:58,149
that get the metadata for that endpoint

00:10:56,079 --> 00:11:00,579
it will validate the credentials it goes

00:10:58,149 --> 00:11:01,840
to a say ok check is talking what what

00:11:00,579 --> 00:11:05,110
does this token has can you

00:11:01,840 --> 00:11:07,480
and the token that comes back from you a

00:11:05,110 --> 00:11:10,180
who have credentials for that specific

00:11:07,480 --> 00:11:12,940
user it then applies from other

00:11:10,180 --> 00:11:15,190
filtering sand on the chain and finally

00:11:12,940 --> 00:11:17,230
calls the user service right users will

00:11:15,190 --> 00:11:20,260
say okay here's the payload back it

00:11:17,230 --> 00:11:24,430
sends back the payload and what could do

00:11:20,260 --> 00:11:26,860
as well the first you know handler is a

00:11:24,430 --> 00:11:30,370
data filter right and the data filter

00:11:26,860 --> 00:11:34,089
all it does is I know who you are I know

00:11:30,370 --> 00:11:35,830
what roles you have you cannot see one

00:11:34,089 --> 00:11:37,450
of the fields so I'm gonna filter that

00:11:35,830 --> 00:11:41,830
out and I'm gonna send the data back to

00:11:37,450 --> 00:11:45,640
you so now you also have a data security

00:11:41,830 --> 00:11:47,980
in your platform there's many ways of

00:11:45,640 --> 00:11:49,750
doing that this is one of them you could

00:11:47,980 --> 00:11:52,480
also you know try to change the query on

00:11:49,750 --> 00:11:54,460
the fly I'm not particularly fan of that

00:11:52,480 --> 00:11:57,250
because you have to understand a lot of

00:11:54,460 --> 00:11:58,900
you know parsers and bear in mind if you

00:11:57,250 --> 00:12:00,610
have multiple data stores you have to

00:11:58,900 --> 00:12:05,520
rewrite your query among different data

00:12:00,610 --> 00:12:08,620
data store providers the next lesson was

00:12:05,520 --> 00:12:09,850
security and I don't want to dive too

00:12:08,620 --> 00:12:15,070
much insecurity because it's a huge

00:12:09,850 --> 00:12:17,380
topic but do not do not use LDAP for

00:12:15,070 --> 00:12:20,370
authorization and the last one is

00:12:17,380 --> 00:12:24,490
corporate LD apps can be very polluted

00:12:20,370 --> 00:12:26,560
so do education on LDAP or any SSO

00:12:24,490 --> 00:12:28,950
appliance you might have and I'm talking

00:12:26,560 --> 00:12:34,000
about you a here being your SS Sol

00:12:28,950 --> 00:12:36,670
platform but move the authorization part

00:12:34,000 --> 00:12:39,880
back maybe to UA maybe to a separate

00:12:36,670 --> 00:12:41,920
database because now we have this

00:12:39,880 --> 00:12:43,930
fantastic platform you can push code in

00:12:41,920 --> 00:12:46,150
a matter of seconds you should rely on

00:12:43,930 --> 00:12:48,940
LDAP it means that you have to open a

00:12:46,150 --> 00:12:50,920
ticket again request a group take some

00:12:48,940 --> 00:12:52,510
vacations come back and then you might

00:12:50,920 --> 00:12:54,520
have your group so you push your app

00:12:52,510 --> 00:12:59,410
fast you don't have the group and LDAP

00:12:54,520 --> 00:13:01,720
in the same speed to enforce security to

00:12:59,410 --> 00:13:03,100
go no all the way through all the

00:13:01,720 --> 00:13:04,390
services we're talking about micro

00:13:03,100 --> 00:13:06,430
services you're gonna have a lot of

00:13:04,390 --> 00:13:08,920
services all over the place make sure

00:13:06,430 --> 00:13:11,920
that you pass the token along right so

00:13:08,920 --> 00:13:13,990
each service that you have must get the

00:13:11,920 --> 00:13:15,670
token and propagate you the next one so

00:13:13,990 --> 00:13:18,250
there is a pseudo code here that

00:13:15,670 --> 00:13:20,440
really work but a simple example if you

00:13:18,250 --> 00:13:22,450
use spring security is if you go to the

00:13:20,440 --> 00:13:25,090
security context holder you get the

00:13:22,450 --> 00:13:27,790
context you get token from the the call

00:13:25,090 --> 00:13:29,770
and then just pass it along as a header

00:13:27,790 --> 00:13:32,620
to the next client that makes a rest

00:13:29,770 --> 00:13:34,060
call right and that is pretty much what

00:13:32,620 --> 00:13:36,220
I have to talk about security because

00:13:34,060 --> 00:13:38,170
that's a huge topic and I don't want to

00:13:36,220 --> 00:13:44,020
dive in this I don't have time in in the

00:13:38,170 --> 00:13:46,830
expertise just to talk into that but you

00:13:44,020 --> 00:13:49,240
guys probably wearing the Madden Stein

00:13:46,830 --> 00:13:51,160
micro-services everyone was there

00:13:49,240 --> 00:13:53,860
actually write a talk and that was

00:13:51,160 --> 00:13:55,840
fantastic but there is the dark side of

00:13:53,860 --> 00:13:59,490
micro service right and then there's no

00:13:55,840 --> 00:14:02,860
if you play Portal there's no cake and

00:13:59,490 --> 00:14:04,390
we found out is multiple remote calls

00:14:02,860 --> 00:14:07,060
that you're gonna start having on your

00:14:04,390 --> 00:14:09,790
server in your architecture and eight

00:14:07,060 --> 00:14:15,190
entity relationships that one hurts and

00:14:09,790 --> 00:14:17,320
we it hurt really bad actually so two

00:14:15,190 --> 00:14:19,120
weeks ago I was reading an article by

00:14:17,320 --> 00:14:20,320
this guy here I don't know Chris with

00:14:19,120 --> 00:14:22,180
sharks and if you've ever heard about

00:14:20,320 --> 00:14:24,000
him if you know the Cloud Foundry

00:14:22,180 --> 00:14:27,340
history you've probably heard about him

00:14:24,000 --> 00:14:29,680
so he wrote an article about micro

00:14:27,340 --> 00:14:32,020
services and he was talking of

00:14:29,680 --> 00:14:34,480
a solution on solving of some of those

00:14:32,020 --> 00:14:36,850
problems and I was in joy when I when I

00:14:34,480 --> 00:14:38,350
when I read that cuz hey that's what

00:14:36,850 --> 00:14:40,540
this exact exactly what are we heading

00:14:38,350 --> 00:14:42,220
to right I mean so I wasn't you know

00:14:40,540 --> 00:14:44,260
going crazy or something

00:14:42,220 --> 00:14:47,230
and when you're looking in the

00:14:44,260 --> 00:14:49,270
architecture for micro services you can

00:14:47,230 --> 00:14:51,190
see something like this it might look

00:14:49,270 --> 00:14:53,620
like this at the bottom layer you have

00:14:51,190 --> 00:14:55,920
data services and data services are as

00:14:53,620 --> 00:14:58,720
close as you can get to crud operations

00:14:55,920 --> 00:15:00,370
core services are services that are

00:14:58,720 --> 00:15:02,830
complete agnostic of your business it

00:15:00,370 --> 00:15:05,350
could be a push notification service it

00:15:02,830 --> 00:15:07,750
can be audit service or a profile

00:15:05,350 --> 00:15:10,630
service you move up you have business

00:15:07,750 --> 00:15:12,760
services those are tighter your your

00:15:10,630 --> 00:15:14,440
business units and then final an

00:15:12,760 --> 00:15:17,470
application orchestrating out there and

00:15:14,440 --> 00:15:19,810
if you can notice the number of calls

00:15:17,470 --> 00:15:22,180
are just increasing as you go down right

00:15:19,810 --> 00:15:24,820
so it means that the response time will

00:15:22,180 --> 00:15:26,740
go up right so you have to be prepared

00:15:24,820 --> 00:15:29,200
for that and how do you deal with that

00:15:26,740 --> 00:15:33,010
so how I've dealt with that

00:15:29,200 --> 00:15:34,570
we launched an application and the

00:15:33,010 --> 00:15:36,070
application is built on nodejs as a

00:15:34,570 --> 00:15:38,800
front end and the back end is complete

00:15:36,070 --> 00:15:41,020
Java and you're just sitting waiting for

00:15:38,800 --> 00:15:43,060
the page to render and you're wondering

00:15:41,020 --> 00:15:45,820
what went wrong I mean I'm using node

00:15:43,060 --> 00:15:48,190
right it was supposed to be fast

00:15:45,820 --> 00:15:51,880
you've opened the code and you see

00:15:48,190 --> 00:15:55,540
something like this right every single

00:15:51,880 --> 00:15:59,170
invocation of the services they've they

00:15:55,540 --> 00:16:01,620
are just in sequential so you're paying

00:15:59,170 --> 00:16:04,150
a penalty of the remote a vocation call

00:16:01,620 --> 00:16:08,650
but you shouldn't be writing code like

00:16:04,150 --> 00:16:12,160
this right now just a message to myself

00:16:08,650 --> 00:16:14,380
here I'm not on scala days i'm CF summit

00:16:12,160 --> 00:16:18,190
but you should be writing code like this

00:16:14,380 --> 00:16:21,670
right if you really want to embrace no

00:16:18,190 --> 00:16:25,900
reactive and making parallel execution

00:16:21,670 --> 00:16:27,730
calls we made it choice for hey what if

00:16:25,900 --> 00:16:28,930
we write code in Scala I mean it doesn't

00:16:27,730 --> 00:16:31,300
have to be a scholar you can actually

00:16:28,930 --> 00:16:34,960
write code and in compose futures in

00:16:31,300 --> 00:16:39,850
Java and just leave by the callback

00:16:34,960 --> 00:16:43,780
nightmare it's up to you but evaluating

00:16:39,850 --> 00:16:45,610
from some choices right that what we

00:16:43,780 --> 00:16:47,350
have out there there's a bunch of

00:16:45,610 --> 00:16:49,990
frameworks you can think about it right

00:16:47,350 --> 00:16:52,210
it's there's akka rx reactor and vertex

00:16:49,990 --> 00:16:56,190
and they all kind of hold the same

00:16:52,210 --> 00:16:58,810
problem right the idea is I want to have

00:16:56,190 --> 00:17:01,210
parallel execution and I don't want to

00:16:58,810 --> 00:17:03,940
pay the penalty for you know the

00:17:01,210 --> 00:17:08,290
distributed calls it just turns out that

00:17:03,940 --> 00:17:10,209
akka had a nice feature butene that you

00:17:08,290 --> 00:17:13,180
guys probably heard about it and it's a

00:17:10,209 --> 00:17:16,300
circuit breaker right so not only it saw

00:17:13,180 --> 00:17:20,589
the actor model solve the the parylene

00:17:16,300 --> 00:17:23,530
problem we had in composing remote calls

00:17:20,589 --> 00:17:26,410
it came with a nice circuit breaker as

00:17:23,530 --> 00:17:28,510
well and it worked with Java being a

00:17:26,410 --> 00:17:31,720
huge Java shop there's no need for each

00:17:28,510 --> 00:17:33,910
of switches caller actually so that was

00:17:31,720 --> 00:17:36,660
one of you know our thoughts when moving

00:17:33,910 --> 00:17:36,660
to Scala

00:17:36,700 --> 00:17:41,350
if you look into the that the next

00:17:38,980 --> 00:17:45,520
problem right it's the traditional web

00:17:41,350 --> 00:17:49,090
application and it doesn't matter if if

00:17:45,520 --> 00:17:51,790
you're talking about ers or Wars as a

00:17:49,090 --> 00:17:53,530
developers we are used to this this has

00:17:51,790 --> 00:17:56,130
been built in our DNA s for almost a

00:17:53,530 --> 00:17:58,480
decade now this is how we do things and

00:17:56,130 --> 00:17:59,350
what I want to highlight is how

00:17:58,480 --> 00:18:04,060
hibernate

00:17:59,350 --> 00:18:06,790
you know handles entity relationships so

00:18:04,060 --> 00:18:08,560
you're used for to have hibernate to

00:18:06,790 --> 00:18:11,230
propagate cascading operations for you

00:18:08,560 --> 00:18:15,220
and they happen at the same JVM you move

00:18:11,230 --> 00:18:16,780
into a micro service architecture how

00:18:15,220 --> 00:18:19,990
can you make those things work and then

00:18:16,780 --> 00:18:23,820
to me that it's what I'm calling the

00:18:19,990 --> 00:18:26,380
ripple effect of entity relationships

00:18:23,820 --> 00:18:28,810
your data services when you change one

00:18:26,380 --> 00:18:31,750
service and it's starting propagating

00:18:28,810 --> 00:18:34,110
all the changes to different related

00:18:31,750 --> 00:18:37,240
entities and here I'm talking about

00:18:34,110 --> 00:18:39,820
resources okay those are the bat the

00:18:37,240 --> 00:18:42,310
bottom layer the data services layer and

00:18:39,820 --> 00:18:46,600
the top layer you solve by using vertex

00:18:42,310 --> 00:18:49,170
or a core reactor you choose one of

00:18:46,600 --> 00:18:52,360
those frameworks but at the bottom layer

00:18:49,170 --> 00:18:54,430
what we decide to do is hey why don't we

00:18:52,360 --> 00:18:58,690
go even three them right there is

00:18:54,430 --> 00:18:59,980
there's a nice architecture for that and

00:18:58,690 --> 00:19:02,980
there's a awesome product called

00:18:59,980 --> 00:19:05,980
RabbitMQ so we just embrace the message

00:19:02,980 --> 00:19:08,860
oriented pattern I say instead of having

00:19:05,980 --> 00:19:10,870
to tell the others why don't I just

00:19:08,860 --> 00:19:12,730
propagate an event and who else is

00:19:10,870 --> 00:19:14,410
interested in that they can take care of

00:19:12,730 --> 00:19:16,660
themselves you know you stop blocking

00:19:14,410 --> 00:19:19,630
the caller so the color color is never

00:19:16,660 --> 00:19:24,220
blocked anymore right so we got a lot of

00:19:19,630 --> 00:19:25,900
you know agility there but if you're

00:19:24,220 --> 00:19:27,670
really serious about exposing your

00:19:25,900 --> 00:19:30,400
services to the external world it might

00:19:27,670 --> 00:19:33,730
happens that you don't want exposed AMQP

00:19:30,400 --> 00:19:37,120
protocol few things that could be done

00:19:33,730 --> 00:19:39,100
is you can have server sent events so if

00:19:37,120 --> 00:19:41,500
you have a nice server that behaves nice

00:19:39,100 --> 00:19:44,680
with an i/o doesn't block by tribes and

00:19:41,500 --> 00:19:46,930
it's okay with long polling you can

00:19:44,680 --> 00:19:48,430
publish your events on the web for

00:19:46,930 --> 00:19:49,850
external entities you might have

00:19:48,430 --> 00:19:51,559
partners that want to be

00:19:49,850 --> 00:19:54,530
listen for events or for entities as

00:19:51,559 --> 00:19:57,320
well or you can embrace the webhooks

00:19:54,530 --> 00:20:01,390
idea right just like github and there's

00:19:57,320 --> 00:20:04,299
a very nice project called pubsubhubbub

00:20:01,390 --> 00:20:06,950
yeah I always want to say that in public

00:20:04,299 --> 00:20:09,679
it's projects by Google it's a webhooks

00:20:06,950 --> 00:20:11,660
implementation it tells you how to build

00:20:09,679 --> 00:20:17,059
you know brokers for for web hooks and

00:20:11,660 --> 00:20:19,730
and so and and finally but but but last

00:20:17,059 --> 00:20:22,520
but not least was the whole problem of

00:20:19,730 --> 00:20:23,960
polygon persistence right so everyone is

00:20:22,520 --> 00:20:28,100
polyglot when it comes to persist in

00:20:23,960 --> 00:20:31,220
these days so traditionally what you do

00:20:28,100 --> 00:20:33,740
is you have your service and and it has

00:20:31,220 --> 00:20:36,919
a bunch of repositories you know spring

00:20:33,740 --> 00:20:39,799
data repos and don't take me wrong I

00:20:36,919 --> 00:20:42,260
love spring I love spring data but

00:20:39,799 --> 00:20:46,549
what's what's happening here is if it

00:20:42,260 --> 00:20:49,130
turns out that you need an extra type of

00:20:46,549 --> 00:20:51,320
repository and believe me when you're

00:20:49,130 --> 00:20:54,770
going to the no sequel word that again

00:20:51,320 --> 00:20:57,380
becomes a more right you start adding

00:20:54,770 --> 00:20:59,840
everything on Cassandra and then one day

00:20:57,380 --> 00:21:01,909
you realize that hey my developers are

00:20:59,840 --> 00:21:04,450
doing relationships and Cassandra and

00:21:01,909 --> 00:21:08,690
all the queries are taking too long so

00:21:04,450 --> 00:21:11,690
why don't I put my relationships on a a

00:21:08,690 --> 00:21:13,010
graph database and there's a nice

00:21:11,690 --> 00:21:15,890
pattern out there that people uses

00:21:13,010 --> 00:21:18,590
cylindra right they combined solar with

00:21:15,890 --> 00:21:20,929
Cassandra but you might be doing

00:21:18,590 --> 00:21:22,429
elasticsearch so those things will pop

00:21:20,929 --> 00:21:26,240
up you don't want to be in the business

00:21:22,429 --> 00:21:28,730
of every time a new storage engine pops

00:21:26,240 --> 00:21:32,480
up you have to open your services and

00:21:28,730 --> 00:21:36,140
add the repositories there so again same

00:21:32,480 --> 00:21:39,740
concept of event-driven architectures

00:21:36,140 --> 00:21:42,640
right persistence is no longer done by

00:21:39,740 --> 00:21:45,919
the data service right and I think that

00:21:42,640 --> 00:21:48,289
we've just created that the Nano service

00:21:45,919 --> 00:21:53,630
where we got a micro service and we

00:21:48,289 --> 00:21:57,980
split it over smaller sets services just

00:21:53,630 --> 00:22:00,400
put into the data pipeline a JSON

00:21:57,980 --> 00:22:03,260
request and Kazon is as good as it gets

00:22:00,400 --> 00:22:05,000
yesterday Dave McCrory gave

00:22:03,260 --> 00:22:07,760
nice presentation on the future of path

00:22:05,000 --> 00:22:11,230
and data and he was talking about how

00:22:07,760 --> 00:22:17,330
Jason might be the good solution for a

00:22:11,230 --> 00:22:20,750
universal format for storage each one of

00:22:17,330 --> 00:22:23,440
those implementations red is new for J

00:22:20,750 --> 00:22:27,530
or elasticsearch or your dupe data Lake

00:22:23,440 --> 00:22:30,950
they'll know how to that data make it

00:22:27,530 --> 00:22:35,780
fit right it knows how to you know fit

00:22:30,950 --> 00:22:39,530
the square in the Octagon but you might

00:22:35,780 --> 00:22:42,620
need a few more information and this

00:22:39,530 --> 00:22:49,310
approach it also actually turns to be

00:22:42,620 --> 00:22:51,710
nice on another another face facet so

00:22:49,310 --> 00:22:53,450
different different providers that you

00:22:51,710 --> 00:22:55,850
offer different SLA is right

00:22:53,450 --> 00:23:00,290
so Redis llamó readies is blazing fast

00:22:55,850 --> 00:23:01,820
right but new for J might not be there

00:23:00,290 --> 00:23:04,160
as fast as they advertised I'm not

00:23:01,820 --> 00:23:08,090
saying that but you might have you might

00:23:04,160 --> 00:23:11,960
not you may not have a fast engine air

00:23:08,090 --> 00:23:15,200
and with this you can have a different

00:23:11,960 --> 00:23:17,210
number of instances of those services to

00:23:15,200 --> 00:23:19,340
to keep up with the throughput of your

00:23:17,210 --> 00:23:20,840
messages right so I can have only one

00:23:19,340 --> 00:23:22,640
instance for Eddie's because it's too

00:23:20,840 --> 00:23:24,170
fast but I might need three or for

00:23:22,640 --> 00:23:27,230
instance for new for J to handle the

00:23:24,170 --> 00:23:30,250
traffic that is coming right so I think

00:23:27,230 --> 00:23:34,460
that there was one of the the last

00:23:30,250 --> 00:23:37,750
lessons learned when there was a lot of

00:23:34,460 --> 00:23:41,440
things one thing I can tell you guys is

00:23:37,750 --> 00:23:44,750
if you if you're embracing Cloud Foundry

00:23:41,440 --> 00:23:46,340
if you're looking for a pass you you

00:23:44,750 --> 00:23:48,290
have a lot of things to do to raise your

00:23:46,340 --> 00:23:50,300
game you know start thinking a little

00:23:48,290 --> 00:23:53,660
bit different on how you deploy your

00:23:50,300 --> 00:23:54,880
architecture I really think that this is

00:23:53,660 --> 00:23:56,690
the first time we're gonna get

00:23:54,880 --> 00:23:58,820
service-oriented architecture right

00:23:56,690 --> 00:24:04,000
without having to spend half a billion

00:23:58,820 --> 00:24:08,120
dollars in tooling and I think that's it

00:24:04,000 --> 00:24:09,680
I'm gonna thank you guys and we just

00:24:08,120 --> 00:24:12,470
welcome to the next level that's pretty

00:24:09,680 --> 00:24:15,850
much what it is all about

00:24:12,470 --> 00:24:19,140
[Applause]

00:24:15,850 --> 00:24:19,140

YouTube URL: https://www.youtube.com/watch?v=TS02UwPX3IY


