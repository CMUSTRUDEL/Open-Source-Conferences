Title: Basho - Future Data Platforms and PaaS Services (Cloud Foundry Summit 2014)
Publication date: 2014-07-04
Playlist: Cloud Foundry Summit 2014
Description: 
	Presentation by CTO of Basho, Dave McCrory.
Captions: 
	00:00:00,930 --> 00:00:04,220
[Music]

00:00:08,240 --> 00:00:17,279
so this talk is about future data

00:00:11,670 --> 00:00:19,619
platforms and past services the I guess

00:00:17,279 --> 00:00:23,189
a little bit of detail I've been dealing

00:00:19,619 --> 00:00:26,609
with with platform-as-a-service since my

00:00:23,189 --> 00:00:28,920
time at Cloud Foundry which was pre the

00:00:26,609 --> 00:00:34,950
original launch when it was part of

00:00:28,920 --> 00:00:38,129
VMware I then went and spent roughly

00:00:34,950 --> 00:00:40,980
just shy of two years at at Warner Music

00:00:38,129 --> 00:00:44,600
Group implementing a customized version

00:00:40,980 --> 00:00:46,590
of Cloud Foundry in in the enterprise

00:00:44,600 --> 00:00:49,530
dealing with all sorts of interesting

00:00:46,590 --> 00:00:53,760
challenges including quite a bit around

00:00:49,530 --> 00:00:57,870
data and I left just a few months ago

00:00:53,760 --> 00:01:01,199
and and joined bass show as the CTO bass

00:00:57,870 --> 00:01:03,600
show is a is one of the no sequel

00:01:01,199 --> 00:01:05,820
storage companies they make a product

00:01:03,600 --> 00:01:08,610
called react which is key value storage

00:01:05,820 --> 00:01:11,520
and another product called react CS

00:01:08,610 --> 00:01:13,950
which is object storage built on top of

00:01:11,520 --> 00:01:16,130
that that's probably the last you'll

00:01:13,950 --> 00:01:19,229
hear me talk about bash o or react

00:01:16,130 --> 00:01:20,430
except maybe a bullet or something so

00:01:19,229 --> 00:01:23,520
you don't have to worry about this being

00:01:20,430 --> 00:01:25,890
a long boring advertisement hopefully it

00:01:23,520 --> 00:01:26,970
won't be long and boring at all but at

00:01:25,890 --> 00:01:29,369
least you won't have to hear more about

00:01:26,970 --> 00:01:32,729
bash oh right now

00:01:29,369 --> 00:01:35,100
so what is the data platform this is

00:01:32,729 --> 00:01:36,960
kind of my definition I didn't take this

00:01:35,100 --> 00:01:40,049
definition from anywhere I just sat down

00:01:36,960 --> 00:01:41,490
and wrote it you can see a technology or

00:01:40,049 --> 00:01:43,290
collection of technologies that can

00:01:41,490 --> 00:01:45,000
provide the majority of data services

00:01:43,290 --> 00:01:47,189
required by developers in needed by

00:01:45,000 --> 00:01:50,040
enterprises for data and especially pass

00:01:47,189 --> 00:01:52,530
if you've dealt with platform as a

00:01:50,040 --> 00:01:56,520
service in any type of enterprise

00:01:52,530 --> 00:01:58,939
environment you'll find that data ends

00:01:56,520 --> 00:02:02,130
up becoming a very interesting challenge

00:01:58,939 --> 00:02:05,130
you're reliant on a set of abstractions

00:02:02,130 --> 00:02:07,799
that are giving you access to data you

00:02:05,130 --> 00:02:09,629
may be dealing with with handoffs

00:02:07,799 --> 00:02:12,510
you may be dealing with relational

00:02:09,629 --> 00:02:15,019
databases non-relational

00:02:12,510 --> 00:02:17,670
but what you will find is there is

00:02:15,019 --> 00:02:19,860
there's a lot of complexity around data

00:02:17,670 --> 00:02:23,189
especially as your needs grow and as

00:02:19,860 --> 00:02:25,970
your applications grow you will want to

00:02:23,189 --> 00:02:28,650
do all sorts of things with the data and

00:02:25,970 --> 00:02:31,739
that's really a large portion of what

00:02:28,650 --> 00:02:33,209
this talk will be about the other side

00:02:31,739 --> 00:02:37,049
are what our past services these are

00:02:33,209 --> 00:02:38,940
some examples these apply to all the

00:02:37,049 --> 00:02:41,459
passes I'm aware of that that are out

00:02:38,940 --> 00:02:43,739
there in one form or fashion or another

00:02:41,459 --> 00:02:46,079
some of them may not have one capability

00:02:43,739 --> 00:02:49,829
or something on them others may have all

00:02:46,079 --> 00:02:51,690
of these I think the the point is that

00:02:49,829 --> 00:02:53,700
these are examples you'll see that I've

00:02:51,690 --> 00:02:56,099
highlighted storage because that's what

00:02:53,700 --> 00:02:58,170
we're gonna focus on arguably messaging

00:02:56,099 --> 00:03:00,090
can be a form of storage and you can

00:02:58,170 --> 00:03:03,359
have extensions to search that are

00:03:00,090 --> 00:03:05,549
storage you can have processing that

00:03:03,359 --> 00:03:08,040
occurs that both feeds out of storage

00:03:05,549 --> 00:03:09,810
and then feeds back into it and logging

00:03:08,040 --> 00:03:14,879
and audit actually have to rely on

00:03:09,810 --> 00:03:17,519
storage in one way or another a bit of a

00:03:14,879 --> 00:03:19,739
disclaimer as I get later on into the

00:03:17,519 --> 00:03:22,560
talk I'll be doing a little bit of

00:03:19,739 --> 00:03:24,959
fortune-telling telling a future this is

00:03:22,560 --> 00:03:27,900
based purely on my experience and things

00:03:24,959 --> 00:03:30,239
that I've seen and obviously no one can

00:03:27,900 --> 00:03:32,129
truly predict the future certainly if I

00:03:30,239 --> 00:03:34,739
could I wouldn't be here right now I

00:03:32,129 --> 00:03:38,060
would be wealthy probably on an island

00:03:34,739 --> 00:03:38,060
or something else at this point

00:03:38,449 --> 00:03:41,849
hope you're hungry

00:03:40,139 --> 00:03:43,739
many of my slides in fact the majority

00:03:41,849 --> 00:03:46,290
of them will have pictures of food on

00:03:43,739 --> 00:03:47,639
them so be prepared for that I wanted to

00:03:46,290 --> 00:03:50,940
make this talk at least visually

00:03:47,639 --> 00:03:56,340
interesting as well so I choose I chose

00:03:50,940 --> 00:03:59,310
food as my comparison so storage comes

00:03:56,340 --> 00:04:02,569
in many forms depends on how you like

00:03:59,310 --> 00:04:05,519
your storage there's both raw and cooked

00:04:02,569 --> 00:04:07,799
raw might be block storage or file

00:04:05,519 --> 00:04:11,699
systems or some other very low-level

00:04:07,799 --> 00:04:14,310
thing and there are different platforms

00:04:11,699 --> 00:04:16,349
that can expose different levels of raw

00:04:14,310 --> 00:04:17,820
storage to you and depending on your

00:04:16,349 --> 00:04:21,659
purposes it may be perfectly acceptable

00:04:17,820 --> 00:04:24,360
to leverage these types of constructs at

00:04:21,659 --> 00:04:26,699
the same time at least in

00:04:24,360 --> 00:04:29,419
many enterprises and especially in pass

00:04:26,699 --> 00:04:31,650
people are looking more it cooked things

00:04:29,419 --> 00:04:34,909
arguably some of these might be more

00:04:31,650 --> 00:04:38,189
rare or medium-rare than others

00:04:34,909 --> 00:04:41,490
depending on which project or solution

00:04:38,189 --> 00:04:43,580
we talked about many of these in my

00:04:41,490 --> 00:04:45,090
experience are being used today in

00:04:43,580 --> 00:04:47,250
platform-as-a-service

00:04:45,090 --> 00:04:49,800
to one degree or another some of them

00:04:47,250 --> 00:04:53,060
are more popular than others and these

00:04:49,800 --> 00:04:56,610
offer different capabilities the

00:04:53,060 --> 00:04:58,680
interesting thing is there are at least

00:04:56,610 --> 00:05:01,439
the majority of PA's implementations

00:04:58,680 --> 00:05:04,610
that I've seen are using many of these

00:05:01,439 --> 00:05:06,960
in some cases you'll run across

00:05:04,610 --> 00:05:09,180
enterprise platforms that are using all

00:05:06,960 --> 00:05:12,919
of these in one place or another as well

00:05:09,180 --> 00:05:15,539
as many more this has advantages in that

00:05:12,919 --> 00:05:18,199
each of these is designed to have a set

00:05:15,539 --> 00:05:22,590
of strengths and weaknesses in platforms

00:05:18,199 --> 00:05:25,439
as do all of these you know an example

00:05:22,590 --> 00:05:27,419
elasticsearch is fantastic with with

00:05:25,439 --> 00:05:29,129
being able to ingest data and do all

00:05:27,419 --> 00:05:30,990
sorts of really interesting things it

00:05:29,129 --> 00:05:32,930
was the first F clustering in the search

00:05:30,990 --> 00:05:36,089
category

00:05:32,930 --> 00:05:38,879
Kassandra has has a good scalability

00:05:36,089 --> 00:05:41,580
story these days it has lots of

00:05:38,879 --> 00:05:44,219
capabilities around being able to do

00:05:41,580 --> 00:05:47,370
materialized views and it's evolved over

00:05:44,219 --> 00:05:50,069
time is super easy to get started

00:05:47,370 --> 00:05:52,740
on arguably you can have it up and

00:05:50,069 --> 00:05:54,960
running in in minutes and at least from

00:05:52,740 --> 00:05:56,849
the developer side very easy to store

00:05:54,960 --> 00:05:59,039
data and pull data and it uses a

00:05:56,849 --> 00:06:03,150
document oriented paradigm so everything

00:05:59,039 --> 00:06:05,490
looks like a document in reacts a

00:06:03,150 --> 00:06:08,370
key value store so pretty simple concept

00:06:05,490 --> 00:06:10,259
you store keys and values you request a

00:06:08,370 --> 00:06:12,360
key and you can get a value or you can

00:06:10,259 --> 00:06:14,610
say I want to store data in this key and

00:06:12,360 --> 00:06:18,300
the data you store is a value pretty

00:06:14,610 --> 00:06:21,060
easy concept to get solar is is another

00:06:18,300 --> 00:06:23,039
search technology it's the oldest of the

00:06:21,060 --> 00:06:25,409
search technologies that are open source

00:06:23,039 --> 00:06:26,729
and in use between elastic search and

00:06:25,409 --> 00:06:29,759
Cassandra

00:06:26,729 --> 00:06:31,319
there's people using solar an elastic

00:06:29,759 --> 00:06:35,159
search at the same time or some people

00:06:31,319 --> 00:06:37,639
will favor one over the other solar

00:06:35,159 --> 00:06:40,069
strength is in its maturity it now has

00:06:37,639 --> 00:06:42,050
clustering it got it after elasticsearch

00:06:40,069 --> 00:06:44,659
so it has lots of capabilities there

00:06:42,050 --> 00:06:46,370
and finally Redis is an in-memory key

00:06:44,659 --> 00:06:48,590
value store lots and lots of people

00:06:46,370 --> 00:06:51,710
using Redis in the enterprise very

00:06:48,590 --> 00:06:54,949
high-performance incredible response

00:06:51,710 --> 00:06:57,800
times the downside is it doesn't have a

00:06:54,949 --> 00:07:00,520
good availability story right now you

00:06:57,800 --> 00:07:04,099
can't cluster Redis at least very easily

00:07:00,520 --> 00:07:05,539
so again people are picking combinations

00:07:04,099 --> 00:07:07,580
of these things because there is no

00:07:05,539 --> 00:07:09,830
magic bullet that can solve all of their

00:07:07,580 --> 00:07:12,349
data needs problems at least in this no

00:07:09,830 --> 00:07:14,599
sequel space there are classic

00:07:12,349 --> 00:07:16,400
relational stores that that have lots of

00:07:14,599 --> 00:07:18,830
maturity in them they have other

00:07:16,400 --> 00:07:20,689
limitations so none of these things are

00:07:18,830 --> 00:07:23,289
just oh you can put all everything in

00:07:20,689 --> 00:07:26,779
there in here it's a one size fits all

00:07:23,289 --> 00:07:30,889
there is no one size fits all at least

00:07:26,779 --> 00:07:33,500
not today and so talking a little bit

00:07:30,889 --> 00:07:35,509
about the different types these are all

00:07:33,500 --> 00:07:38,029
different types of ways you can store

00:07:35,509 --> 00:07:40,310
your data outside of classic relational

00:07:38,029 --> 00:07:43,490
databases so you've got key value that's

00:07:40,310 --> 00:07:47,210
the kV object document graph time series

00:07:43,490 --> 00:07:49,819
queue columnar table cache and they're a

00:07:47,210 --> 00:07:51,919
whole host of more exotics and other

00:07:49,819 --> 00:07:54,409
Popular's that are on this list of ways

00:07:51,919 --> 00:07:57,919
that you can actually store your data

00:07:54,409 --> 00:07:59,599
all of these constructs are here for a

00:07:57,919 --> 00:08:01,460
reason they're not just because

00:07:59,599 --> 00:08:03,139
developers like more and more constructs

00:08:01,460 --> 00:08:04,789
there to solve different types of

00:08:03,139 --> 00:08:08,599
problems in to handle data in different

00:08:04,789 --> 00:08:11,000
ways data that you might store in a

00:08:08,599 --> 00:08:13,689
graph might be very rapidly changing and

00:08:11,000 --> 00:08:15,979
very difficult to put into a schema

00:08:13,689 --> 00:08:20,710
specifically graphs are really good at

00:08:15,979 --> 00:08:22,849
handling some very complex problems they

00:08:20,710 --> 00:08:24,589
there's a lot of difficulty if you

00:08:22,849 --> 00:08:26,689
wanted to use a graph for time series

00:08:24,589 --> 00:08:28,189
it's possible I've actually seen someone

00:08:26,689 --> 00:08:30,879
give an example of how they were able to

00:08:28,189 --> 00:08:34,099
store time series in a graph but overall

00:08:30,879 --> 00:08:35,959
you would be better off storing that in

00:08:34,099 --> 00:08:38,209
something that's designed to store time

00:08:35,959 --> 00:08:40,669
series data time series data could be

00:08:38,209 --> 00:08:43,010
log data it could be event data it could

00:08:40,669 --> 00:08:44,990
be Internet of Things data so you could

00:08:43,010 --> 00:08:47,600
have sensors distributed all over and

00:08:44,990 --> 00:08:49,620
they're each reporting every 30 seconds

00:08:47,600 --> 00:08:51,240
an aggregate amount of in

00:08:49,620 --> 00:08:54,060
information maybe it's temperature and

00:08:51,240 --> 00:08:56,370
humidity and pressure and several other

00:08:54,060 --> 00:08:59,040
things reporting them all of that is

00:08:56,370 --> 00:09:00,810
time series based data so it would be

00:08:59,040 --> 00:09:03,540
better if you had a storage solution

00:09:00,810 --> 00:09:05,700
designed to handle that specific use

00:09:03,540 --> 00:09:08,520
case so we have time series as a

00:09:05,700 --> 00:09:11,370
construct queues are a different form of

00:09:08,520 --> 00:09:14,520
storage so all of these are types of

00:09:11,370 --> 00:09:15,270
storage they they all are here to solve

00:09:14,520 --> 00:09:17,460
problems

00:09:15,270 --> 00:09:19,980
it's just what level of problem how

00:09:17,460 --> 00:09:22,050
mature is a solution providing this to

00:09:19,980 --> 00:09:26,550
you what are the capabilities versus

00:09:22,050 --> 00:09:29,370
your needs in the world of paths you

00:09:26,550 --> 00:09:32,279
have ready to mate ready-made services

00:09:29,370 --> 00:09:33,960
and made-to-order services and I'll

00:09:32,279 --> 00:09:35,300
explain a little bit about at least in

00:09:33,960 --> 00:09:37,940
my mind what the differences are

00:09:35,300 --> 00:09:41,490
ready-made is kind of like a TV dinner

00:09:37,940 --> 00:09:43,589
you just get it out you you cook it and

00:09:41,490 --> 00:09:47,760
you eat it and there's really not a lot

00:09:43,589 --> 00:09:49,500
of other work involved and baked into

00:09:47,760 --> 00:09:52,680
passes you'll see all sorts of different

00:09:49,500 --> 00:09:54,120
services out there these services have

00:09:52,680 --> 00:09:55,950
already been set up they've already been

00:09:54,120 --> 00:09:58,200
tuned and configured in a generic way

00:09:55,950 --> 00:10:02,880
and you can just begin to consume them

00:09:58,200 --> 00:10:05,670
so very very low barrier to entry to

00:10:02,880 --> 00:10:09,180
begin consuming these services which is

00:10:05,670 --> 00:10:11,190
great again they're still going to be

00:10:09,180 --> 00:10:13,020
general-purpose so the more outside of

00:10:11,190 --> 00:10:15,990
that general-purpose use case you have

00:10:13,020 --> 00:10:18,270
the more specific or the more specifics

00:10:15,990 --> 00:10:20,459
a latency or performance demands you

00:10:18,270 --> 00:10:22,020
have the less likely these are going to

00:10:20,459 --> 00:10:23,910
be to be able to meet your needs at

00:10:22,020 --> 00:10:27,690
least today with the maturity state of

00:10:23,910 --> 00:10:29,670
services in the past market what's

00:10:27,690 --> 00:10:32,430
interesting is when you move more

00:10:29,670 --> 00:10:34,529
towards say made-to-order where you spin

00:10:32,430 --> 00:10:36,270
up services on demand these could be

00:10:34,529 --> 00:10:38,010
more customised towards what you're

00:10:36,270 --> 00:10:42,750
looking for to solve your specific use

00:10:38,010 --> 00:10:46,200
case they they do incur some more

00:10:42,750 --> 00:10:48,029
specific operations and you will have to

00:10:46,200 --> 00:10:50,160
manage those likely yourself and

00:10:48,029 --> 00:10:52,350
maintain them you may have to build your

00:10:50,160 --> 00:10:54,130
own gateway depending on how exotic you

00:10:52,350 --> 00:10:58,920
decide to go

00:10:54,130 --> 00:10:58,920
at least this is from what I've seen

00:10:59,340 --> 00:11:06,910
Mille to be able to do this effectively

00:11:04,110 --> 00:11:10,090
I'm seeing more and more companies that

00:11:06,910 --> 00:11:11,800
are trying to trying to automate this as

00:11:10,090 --> 00:11:14,950
much as possible and they're having some

00:11:11,800 --> 00:11:17,200
success but there's no no easy way to

00:11:14,950 --> 00:11:22,390
address all of these scenarios yet

00:11:17,200 --> 00:11:24,550
impasse at least not that I've seen in a

00:11:22,390 --> 00:11:28,300
perfect world you'd have a gourmet

00:11:24,550 --> 00:11:31,260
kitchen with personal chef I I don't

00:11:28,300 --> 00:11:34,030
have this but I would certainly like to

00:11:31,260 --> 00:11:35,830
it's a team of people that can create

00:11:34,030 --> 00:11:38,590
the services you need customize them

00:11:35,830 --> 00:11:39,970
automate them the operations and

00:11:38,590 --> 00:11:43,150
maintenance is still based on these

00:11:39,970 --> 00:11:46,060
individual services so each service is

00:11:43,150 --> 00:11:49,090
different and something that few people

00:11:46,060 --> 00:11:53,740
are yet talking about are the different

00:11:49,090 --> 00:11:57,280
SLA services may need so you may have

00:11:53,740 --> 00:12:00,540
multiple services that appear the same

00:11:57,280 --> 00:12:04,090
let's let's use Cassandra as an example

00:12:00,540 --> 00:12:06,250
Cassandra allows you to have replication

00:12:04,090 --> 00:12:08,740
and you can store multiple copies of

00:12:06,250 --> 00:12:11,830
your data with Cassandra which is

00:12:08,740 --> 00:12:14,110
fantastic the question is how many

00:12:11,830 --> 00:12:16,360
copies of your data do you need well you

00:12:14,110 --> 00:12:18,190
might have one use case where it says no

00:12:16,360 --> 00:12:20,110
matter what you can't lose my data my

00:12:18,190 --> 00:12:22,930
data always needs to be available to me

00:12:20,110 --> 00:12:24,910
and so the decisions made to keep six

00:12:22,930 --> 00:12:26,410
copies of the data and oh by the way

00:12:24,910 --> 00:12:28,690
it's so important I also want you to

00:12:26,410 --> 00:12:30,970
take backups of that data so if you

00:12:28,690 --> 00:12:33,820
think about it that means that for all

00:12:30,970 --> 00:12:35,770
the data you're storing you need six

00:12:33,820 --> 00:12:38,170
times the amount of storage so it's a

00:12:35,770 --> 00:12:40,150
six times multiplier for each bit of

00:12:38,170 --> 00:12:41,770
information you're saving along with

00:12:40,150 --> 00:12:44,530
however much space your backup takes

00:12:41,770 --> 00:12:46,600
that can get expensive but there might

00:12:44,530 --> 00:12:49,240
be legitimate business need to have that

00:12:46,600 --> 00:12:51,480
so that would be a requirement of

00:12:49,240 --> 00:12:54,190
providing a much higher service level

00:12:51,480 --> 00:12:57,190
than what might be needed under ordinary

00:12:54,190 --> 00:13:00,340
circumstances you might have another

00:12:57,190 --> 00:13:02,440
copy of Cassandra running and that

00:13:00,340 --> 00:13:04,000
version you know what it might not be so

00:13:02,440 --> 00:13:06,040
important that the data be available

00:13:04,000 --> 00:13:07,100
under any and all circumstances no

00:13:06,040 --> 00:13:09,440
matter what

00:13:07,100 --> 00:13:11,450
it might be acceptable to have two or

00:13:09,440 --> 00:13:13,340
three copies of your data and maybe you

00:13:11,450 --> 00:13:15,560
don't even need backups maybe it's safe

00:13:13,340 --> 00:13:17,660
enough that you're keeping two copies

00:13:15,560 --> 00:13:19,940
locally and one copy at a remote site

00:13:17,660 --> 00:13:23,150
that might be perfectly acceptable well

00:13:19,940 --> 00:13:24,710
now your cost is for three times the

00:13:23,150 --> 00:13:27,380
amount of storage you are originally

00:13:24,710 --> 00:13:28,910
consuming so your costs are lower your

00:13:27,380 --> 00:13:31,250
service level is different though and

00:13:28,910 --> 00:13:34,070
really all I'm providing to the business

00:13:31,250 --> 00:13:35,450
and to the developer is Cassandra but

00:13:34,070 --> 00:13:36,950
they have different ways you configure

00:13:35,450 --> 00:13:38,990
them they have different ways that you

00:13:36,950 --> 00:13:40,370
might choose to operate them they might

00:13:38,990 --> 00:13:42,830
have different numbers of machines

00:13:40,370 --> 00:13:44,780
involved and they have different amounts

00:13:42,830 --> 00:13:48,200
of storage but I'm still just talking

00:13:44,780 --> 00:13:49,940
about Cassandra we don't hear a lot

00:13:48,200 --> 00:13:51,590
about that today but that's something

00:13:49,940 --> 00:13:54,040
that's going to be occurring more and

00:13:51,590 --> 00:13:59,300
more and more as enterprises adopt

00:13:54,040 --> 00:14:04,640
platform-as-a-service so the kitchen of

00:13:59,300 --> 00:14:06,980
today is individual storage services so

00:14:04,640 --> 00:14:10,460
these are examples like the Cassandra

00:14:06,980 --> 00:14:11,900
the Redis the mangos and and such they

00:14:10,460 --> 00:14:13,660
have separate maintenance so each of

00:14:11,900 --> 00:14:16,040
these things has to be maintained

00:14:13,660 --> 00:14:17,870
independently you're providing

00:14:16,040 --> 00:14:20,330
maintenance different to how you treat

00:14:17,870 --> 00:14:22,430
Redis than you do Cassandra or then you

00:14:20,330 --> 00:14:25,430
do or then you do any of the

00:14:22,430 --> 00:14:28,610
others elasticsearch it's because of

00:14:25,430 --> 00:14:30,470
this that that then you have two

00:14:28,610 --> 00:14:33,560
separate management so you have separate

00:14:30,470 --> 00:14:34,370
management and that management has to be

00:14:33,560 --> 00:14:36,050
treated differently

00:14:34,370 --> 00:14:37,370
you can't treat all these things the

00:14:36,050 --> 00:14:38,960
same because they were built by

00:14:37,370 --> 00:14:40,450
different people they operate different

00:14:38,960 --> 00:14:44,750
ways they're configured different ways

00:14:40,450 --> 00:14:46,820
it gets it gets difficult you're also

00:14:44,750 --> 00:14:48,320
trying to transfer data between these

00:14:46,820 --> 00:14:50,060
stores which is something else that a

00:14:48,320 --> 00:14:53,300
lot of people aren't yet really talking

00:14:50,060 --> 00:14:57,410
much about and that is I've stored my

00:14:53,300 --> 00:14:59,210
data in in but I need I need my

00:14:57,410 --> 00:15:00,950
cup I need my data indexed in

00:14:59,210 --> 00:15:04,250
elasticsearch and I also want to keep a

00:15:00,950 --> 00:15:06,020
copy in Redis for in-memory operation so

00:15:04,250 --> 00:15:07,460
how do you put the data into all of

00:15:06,020 --> 00:15:09,380
those and how do you keep the data

00:15:07,460 --> 00:15:11,810
coordinated and synchronized and what do

00:15:09,380 --> 00:15:13,760
you do with this that's a difficult

00:15:11,810 --> 00:15:15,410
problem but it's a problem that really

00:15:13,760 --> 00:15:18,650
hasn't been addressed all that well

00:15:15,410 --> 00:15:20,120
today the the way I've seen people

00:15:18,650 --> 00:15:22,279
address it so far is for the

00:15:20,120 --> 00:15:26,120
to engineer their own solution inside of

00:15:22,279 --> 00:15:30,260
their their platform so again much more

00:15:26,120 --> 00:15:32,470
complicated as well as by doing this you

00:15:30,260 --> 00:15:37,400
end up with separate silos of expertise

00:15:32,470 --> 00:15:40,010
generally you don't have say one guy or

00:15:37,400 --> 00:15:43,130
even a few guys that are operating this

00:15:40,010 --> 00:15:44,570
this data inside of the platform by

00:15:43,130 --> 00:15:47,060
themselves so you don't have one guy

00:15:44,570 --> 00:15:50,360
that's your expert on Cassandra

00:15:47,060 --> 00:15:53,420
Redis elasticsearch if you do then he's

00:15:50,360 --> 00:15:56,960
he's one heck of a guy to be an expert

00:15:53,420 --> 00:15:59,089
with all of these and and so your

00:15:56,960 --> 00:16:01,400
expenses go up because now you're trying

00:15:59,089 --> 00:16:02,450
to hire these all of these different

00:16:01,400 --> 00:16:04,940
people with all of these different

00:16:02,450 --> 00:16:06,440
specialties and by the way what happens

00:16:04,940 --> 00:16:09,260
when one of the guys gets sick or

00:16:06,440 --> 00:16:10,940
something else and now your your your

00:16:09,260 --> 00:16:12,620
Cassandra guy got sick and he was your

00:16:10,940 --> 00:16:15,380
only Cassandra expert and you're having

00:16:12,620 --> 00:16:18,800
a problem now you're either trying to go

00:16:15,380 --> 00:16:20,420
to the vendor or you're stuck or you

00:16:18,800 --> 00:16:21,890
have somebody that maybe knows a little

00:16:20,420 --> 00:16:23,750
bit about Cassandra that's going and

00:16:21,890 --> 00:16:27,050
trying to futz with it trying to figure

00:16:23,750 --> 00:16:27,830
out what exactly the problem is so it

00:16:27,050 --> 00:16:30,080
gets difficult

00:16:27,830 --> 00:16:32,060
and finally orchestrating all of this

00:16:30,080 --> 00:16:33,529
gets really really complex because

00:16:32,060 --> 00:16:36,529
you're trying to deal with all of these

00:16:33,529 --> 00:16:40,490
issues they're not they're not simple

00:16:36,529 --> 00:16:43,610
issues they can be managed but it it

00:16:40,490 --> 00:16:44,930
requires a team of people and it becomes

00:16:43,610 --> 00:16:47,390
really difficult when you have knowledge

00:16:44,930 --> 00:16:48,950
walkout and you're kind of sitting there

00:16:47,390 --> 00:16:51,200
going all right now how are we going to

00:16:48,950 --> 00:16:54,020
coordinate all of this it also becomes

00:16:51,200 --> 00:16:56,390
complex in trying to deal with the

00:16:54,020 --> 00:16:59,150
processes to wrap around this so that

00:16:56,390 --> 00:17:01,459
you don't have people building what I'll

00:16:59,150 --> 00:17:04,699
call errant services an errant service

00:17:01,459 --> 00:17:06,319
would be Bob decides that he doesn't

00:17:04,699 --> 00:17:09,220
like the services that are provided

00:17:06,319 --> 00:17:12,410
today and he happens to have access to

00:17:09,220 --> 00:17:15,319
to the infrastructure and decides to

00:17:12,410 --> 00:17:19,030
spend up MongoDB and he starts writing

00:17:15,319 --> 00:17:22,459
an application to leverage MongoDB and

00:17:19,030 --> 00:17:24,199
you have no expertise in MongoDB and you

00:17:22,459 --> 00:17:27,350
don't know how to operationalize it and

00:17:24,199 --> 00:17:30,110
you don't know how to manage it and what

00:17:27,350 --> 00:17:32,300
do you do now that he's written an

00:17:30,110 --> 00:17:34,480
application that uses and you find

00:17:32,300 --> 00:17:37,110
out that you have now have do

00:17:34,480 --> 00:17:39,730
in your enterprise how do you either

00:17:37,110 --> 00:17:41,860
operationalize it or how do you get the

00:17:39,730 --> 00:17:43,480
data out of and move it to one of

00:17:41,860 --> 00:17:46,059
the things that you have operationalized

00:17:43,480 --> 00:17:48,399
these are these are really complicated

00:17:46,059 --> 00:17:51,429
problems and they get very expensive and

00:17:48,399 --> 00:17:53,649
time-consuming and this has already

00:17:51,429 --> 00:17:57,159
happened and I think it will get worse

00:17:53,649 --> 00:18:00,909
before it gets better so what does the

00:17:57,159 --> 00:18:03,399
kitchen of tomorrow look like I see it

00:18:00,909 --> 00:18:05,980
as having a unified storage or something

00:18:03,399 --> 00:18:07,990
close to it where you're able to treat

00:18:05,980 --> 00:18:10,419
the majority of your store it's the same

00:18:07,990 --> 00:18:13,779
you might have special cases of storage

00:18:10,419 --> 00:18:15,460
you might have split out say some

00:18:13,779 --> 00:18:18,399
storage that you specifically for

00:18:15,460 --> 00:18:22,000
relational I think relational storage

00:18:18,399 --> 00:18:24,880
for related relational database I think

00:18:22,000 --> 00:18:26,529
that's probably a 15% of all your

00:18:24,880 --> 00:18:28,929
applications who really really need a

00:18:26,529 --> 00:18:30,580
relational database the rest could use

00:18:28,929 --> 00:18:33,100
other specialized things that would

00:18:30,580 --> 00:18:36,309
better serve them but you're still gonna

00:18:33,100 --> 00:18:38,710
need that relational database for a

00:18:36,309 --> 00:18:40,419
specific set of problems it wasn't just

00:18:38,710 --> 00:18:42,429
created out of the blue there there are

00:18:40,419 --> 00:18:44,440
legitimate reasons I would apply the

00:18:42,429 --> 00:18:46,059
same thing for Hadoop which is something

00:18:44,440 --> 00:18:50,320
I haven't really talked about which is

00:18:46,059 --> 00:18:52,240
also in in this so there's a set of use

00:18:50,320 --> 00:18:55,210
cases that Hadoop is really good for in

00:18:52,240 --> 00:18:57,880
HDFS and and so I see that is kind of a

00:18:55,210 --> 00:19:01,029
separate area and then there's this mix

00:18:57,880 --> 00:19:02,830
of other no sequel solutions and I see

00:19:01,029 --> 00:19:04,990
all of the no sequel solutions being

00:19:02,830 --> 00:19:06,250
able to be stored in a place so even if

00:19:04,990 --> 00:19:07,980
we broke it down in that way you

00:19:06,250 --> 00:19:11,019
probably have three different things

00:19:07,980 --> 00:19:12,820
that you're storing data in three still

00:19:11,019 --> 00:19:15,010
a manageable number it's not insanity

00:19:12,820 --> 00:19:17,799
like it is today where you could have an

00:19:15,010 --> 00:19:21,250
enterprise it has 17 different or more

00:19:17,799 --> 00:19:24,279
different storage places sure I'll take

00:19:21,250 --> 00:19:25,899
a question now so the question was is

00:19:24,279 --> 00:19:28,539
there a tree or a flow chart or

00:19:25,899 --> 00:19:32,830
something that will effectively guide

00:19:28,539 --> 00:19:35,590
developers to a specific answer or a

00:19:32,830 --> 00:19:38,320
specific set of selections based on what

00:19:35,590 --> 00:19:40,000
they're trying to do I haven't seen that

00:19:38,320 --> 00:19:43,750
but I think that's really one of the

00:19:40,000 --> 00:19:45,760
points of paths is to is to begin

00:19:43,750 --> 00:19:47,580
becoming more prescriptive for

00:19:45,760 --> 00:19:51,149
developers so that you don't end up

00:19:47,580 --> 00:19:53,820
the problems we're seeing and for you to

00:19:51,149 --> 00:19:55,470
be able to consolidate inside of your

00:19:53,820 --> 00:19:57,029
infrastructure all of these different

00:19:55,470 --> 00:20:00,899
things I think we're still just really

00:19:57,029 --> 00:20:01,769
early right now in this and and that's

00:20:00,899 --> 00:20:03,389
why there's a little bit of

00:20:01,769 --> 00:20:05,999
fortune-telling involved in this I

00:20:03,389 --> 00:20:08,039
really don't know how it all ends it's

00:20:05,999 --> 00:20:10,590
this is where we get into me making

00:20:08,039 --> 00:20:13,529
predictions that probably will be mostly

00:20:10,590 --> 00:20:17,639
wrong I hope not but they certainly

00:20:13,529 --> 00:20:21,239
could be the the idea is that you want

00:20:17,639 --> 00:20:22,889
you want a few vendors in a perfect

00:20:21,239 --> 00:20:24,690
world that would be one and you just buy

00:20:22,889 --> 00:20:26,070
this thing or you get this thing an open

00:20:24,690 --> 00:20:27,929
source and you deploy it and you can

00:20:26,070 --> 00:20:29,609
just store everything in it

00:20:27,929 --> 00:20:32,340
we tried that with relational databases

00:20:29,609 --> 00:20:34,190
by the way and it didn't quite work out

00:20:32,340 --> 00:20:37,350
the way I think we all hoped it would

00:20:34,190 --> 00:20:40,499
they're they're just too many edge cases

00:20:37,350 --> 00:20:43,739
that that don't work or don't work well

00:20:40,499 --> 00:20:47,220
enough to satisfy the business needs so

00:20:43,739 --> 00:20:47,700
so what we end up with is is what we

00:20:47,220 --> 00:20:50,549
have today

00:20:47,700 --> 00:20:54,029
I see tight integration so I see tight

00:20:50,549 --> 00:20:56,820
integration in in the different storage

00:20:54,029 --> 00:20:58,889
solutions over time so people are going

00:20:56,820 --> 00:21:02,100
to demand that you're able to have a

00:20:58,889 --> 00:21:06,239
better integration between elasticsearch

00:21:02,100 --> 00:21:08,190
and and Cassandra and Redis and

00:21:06,239 --> 00:21:09,470
all of these things people need this and

00:21:08,190 --> 00:21:13,169
they're going to continue to need this

00:21:09,470 --> 00:21:16,230
this is simply this is simply something

00:21:13,169 --> 00:21:18,149
that doesn't take a lot of a lot of

00:21:16,230 --> 00:21:20,129
forethought because it's becoming a

00:21:18,149 --> 00:21:24,059
requirement rapidly in anyone that's

00:21:20,129 --> 00:21:26,789
trying to adopt these technologies so

00:21:24,059 --> 00:21:30,029
data works together between types

00:21:26,789 --> 00:21:32,659
this means that key value becomes

00:21:30,029 --> 00:21:34,919
something that can be consumed by

00:21:32,659 --> 00:21:38,279
document that becomes something that can

00:21:34,919 --> 00:21:39,809
be consumed by by search that becomes

00:21:38,279 --> 00:21:42,299
something that can be consumed by graph

00:21:39,809 --> 00:21:44,879
all of these things should be consumable

00:21:42,299 --> 00:21:46,889
across one another this is something

00:21:44,879 --> 00:21:48,239
that doesn't exist today you could try

00:21:46,889 --> 00:21:52,169
and do something where you create a

00:21:48,239 --> 00:21:53,609
common format Jason is certainly the the

00:21:52,169 --> 00:21:56,429
closest thing we have but

00:21:53,609 --> 00:21:58,649
interoperability schema requirements and

00:21:56,429 --> 00:22:00,240
such destroy this today

00:21:58,649 --> 00:22:00,780
there's just no viable way to do it so

00:22:00,240 --> 00:22:03,240
you'd have to

00:22:00,780 --> 00:22:04,500
some type of services or bridging tools

00:22:03,240 --> 00:22:06,450
or something else that would kind of

00:22:04,500 --> 00:22:09,750
copy the data or synchronize it across

00:22:06,450 --> 00:22:14,280
or something it's just not quite the the

00:22:09,750 --> 00:22:16,380
ideal way for things to work kitchen of

00:22:14,280 --> 00:22:20,040
tomorrow would be highly automated so

00:22:16,380 --> 00:22:21,840
being able to add nodes for for storing

00:22:20,040 --> 00:22:23,700
all of this cool stuff in doing things

00:22:21,840 --> 00:22:25,710
you should be able to just add nodes as

00:22:23,700 --> 00:22:28,530
required without a lot of work it should

00:22:25,710 --> 00:22:30,960
have that elastic capability and you

00:22:28,530 --> 00:22:34,950
should be able to remove nodes to today

00:22:30,960 --> 00:22:36,750
that that doesn't really work as well as

00:22:34,950 --> 00:22:38,100
I think anybody would like it to things

00:22:36,750 --> 00:22:41,280
will break especially if you try to

00:22:38,100 --> 00:22:43,170
remove nodes but even adding nodes is

00:22:41,280 --> 00:22:45,570
not something that you can just drop

00:22:43,170 --> 00:22:47,400
down turn on and hey look I have another

00:22:45,570 --> 00:22:50,070
node I have this additional storage made

00:22:47,400 --> 00:22:52,020
available to me it just doesn't work

00:22:50,070 --> 00:22:53,940
that way I think we're marching towards

00:22:52,020 --> 00:22:58,710
that I think we will get there we're not

00:22:53,940 --> 00:23:00,870
there yet and ideally you'd have a

00:22:58,710 --> 00:23:02,790
single expertise needed you wouldn't

00:23:00,870 --> 00:23:04,290
have this siloing of all of these

00:23:02,790 --> 00:23:06,600
different capabilities you wouldn't need

00:23:04,290 --> 00:23:09,090
an expert in each of these we'd be kind

00:23:06,600 --> 00:23:11,520
of back to that I have a DBA and he

00:23:09,090 --> 00:23:14,220
manages my my relational database and he

00:23:11,520 --> 00:23:16,020
gets it and I don't need eight other

00:23:14,220 --> 00:23:18,930
DBAs unless I'm running eight other

00:23:16,020 --> 00:23:23,850
types of databases if I'm running Oracle

00:23:18,930 --> 00:23:25,620
MySQL Postgres db2 sequel server then I

00:23:23,850 --> 00:23:27,450
needed potentially several people that

00:23:25,620 --> 00:23:29,490
were experts and I might even have a

00:23:27,450 --> 00:23:31,770
couple that were capable of being an

00:23:29,490 --> 00:23:37,530
expert across those but you're number of

00:23:31,770 --> 00:23:42,570
an amount of expertise is lowered so if

00:23:37,530 --> 00:23:47,190
we go to a bit more speculation I think

00:23:42,570 --> 00:23:49,800
I think really where this goes is you

00:23:47,190 --> 00:23:52,880
have some vendors that that attempt to

00:23:49,800 --> 00:23:55,020
provide more of a unified solution

00:23:52,880 --> 00:23:56,550
potentially building on what they have

00:23:55,020 --> 00:23:58,920
to offer a lot of the different

00:23:56,550 --> 00:24:01,500
constructs that are available so that

00:23:58,920 --> 00:24:05,610
means I have one solution and it's able

00:24:01,500 --> 00:24:09,179
to provide to me graph document key

00:24:05,610 --> 00:24:11,130
value object search it gives me all of

00:24:09,179 --> 00:24:13,920
those things and it's one solution

00:24:11,130 --> 00:24:14,550
open-source or not most of the solutions

00:24:13,920 --> 00:24:16,290
that I

00:24:14,550 --> 00:24:18,690
stood there in fact I believe all of

00:24:16,290 --> 00:24:21,930
them are open-source projects as well so

00:24:18,690 --> 00:24:23,760
I'll point that out but that's where it

00:24:21,930 --> 00:24:25,470
needs to head it needs to head to where

00:24:23,760 --> 00:24:27,330
I get all of these things from one thing

00:24:25,470 --> 00:24:29,940
and I just pick whatever is best for me

00:24:27,330 --> 00:24:34,860
and this flexibility these capabilities

00:24:29,940 --> 00:24:37,350
that I get give me much easier control

00:24:34,860 --> 00:24:39,120
it gives me a degree of homogeneity and

00:24:37,350 --> 00:24:42,390
the fact that I'm getting it all from

00:24:39,120 --> 00:24:44,130
one thing whatever that thing is if I'm

00:24:42,390 --> 00:24:47,340
able to get all of that from that one

00:24:44,130 --> 00:24:50,220
thing probably solves 80% of my storage

00:24:47,340 --> 00:24:52,500
needs as far as in the in the no sequel

00:24:50,220 --> 00:24:54,240
space it's not again a magic bullet it's

00:24:52,500 --> 00:24:56,430
not gonna solve every single problem and

00:24:54,240 --> 00:24:58,710
if I find a specific deep enough use

00:24:56,430 --> 00:25:01,380
case I may not be able to use it for

00:24:58,710 --> 00:25:01,830
that but if I could even get 80% of the

00:25:01,380 --> 00:25:03,960
way there

00:25:01,830 --> 00:25:06,720
that would be huge compared to where we

00:25:03,960 --> 00:25:09,390
are today where each solution I see

00:25:06,720 --> 00:25:11,640
people trying to shoehorn in oh we've

00:25:09,390 --> 00:25:13,710
done all these customizations so that we

00:25:11,640 --> 00:25:17,130
could do these three extra things with

00:25:13,710 --> 00:25:20,580
whatever elasticsearch solar you name it

00:25:17,130 --> 00:25:22,620
and now they have something that's even

00:25:20,580 --> 00:25:24,270
more specialized it's custom to them

00:25:22,620 --> 00:25:26,100
they have to manage it and maintain it

00:25:24,270 --> 00:25:28,410
because they've now customized it and

00:25:26,100 --> 00:25:30,810
they've customized it because they were

00:25:28,410 --> 00:25:33,030
trying to use the screwdriver as a

00:25:30,810 --> 00:25:35,250
hammer and if they would have just

00:25:33,030 --> 00:25:37,350
gotten a hammer they wouldn't have had

00:25:35,250 --> 00:25:40,350
to change anything so right now there's

00:25:37,350 --> 00:25:44,070
no viable way to deal with either side I

00:25:40,350 --> 00:25:46,260
see I see this as something that's the

00:25:44,070 --> 00:25:47,820
markets gonna demand and it's going to

00:25:46,260 --> 00:25:49,500
be how do we get there and how quickly

00:25:47,820 --> 00:25:53,510
we get there that's really more of the

00:25:49,500 --> 00:25:57,690
question again this is my speculation

00:25:53,510 --> 00:25:59,760
with that I'm gonna take questions for I

00:25:57,690 --> 00:26:03,060
guess about three minutes that's all I

00:25:59,760 --> 00:26:04,980
have left and then and then we'll end so

00:26:03,060 --> 00:26:08,310
does anyone have questions I believe

00:26:04,980 --> 00:26:10,380
that that there are viable paths that

00:26:08,310 --> 00:26:12,810
many of the players could take to

00:26:10,380 --> 00:26:15,420
provide things like this I think that

00:26:12,810 --> 00:26:17,100
all of them Batchelor included will take

00:26:15,420 --> 00:26:20,370
different routes and the question will

00:26:17,100 --> 00:26:22,350
be what are the viable right routes that

00:26:20,370 --> 00:26:23,910
come out of that that people can use I

00:26:22,350 --> 00:26:26,220
think a few of them will become viable

00:26:23,910 --> 00:26:28,980
and I think you'll find some that just

00:26:26,220 --> 00:26:31,260
fundamentally end up being broken and

00:26:28,980 --> 00:26:35,130
trying to address that type of a

00:26:31,260 --> 00:26:37,890
solution but I wouldn't say bash o is or

00:26:35,130 --> 00:26:40,860
could be the only one sure so the

00:26:37,890 --> 00:26:43,770
question is around api's being layered

00:26:40,860 --> 00:26:46,830
over heterogeneity or heterogeneous

00:26:43,770 --> 00:26:48,870
based data storage specifically

00:26:46,830 --> 00:26:52,860
databases and such so what that means is

00:26:48,870 --> 00:26:55,650
I have three or four different solutions

00:26:52,860 --> 00:26:58,260
or maybe even two and I write this API

00:26:55,650 --> 00:27:00,510
to try and abstract away or hide what

00:26:58,260 --> 00:27:03,840
those really are beneath it so for a

00:27:00,510 --> 00:27:05,549
developer I'm exposing this API and they

00:27:03,840 --> 00:27:07,380
just worry about talking to that and

00:27:05,549 --> 00:27:09,720
they don't know what's happening under

00:27:07,380 --> 00:27:12,150
the covers with how I'm storing the data

00:27:09,720 --> 00:27:16,650
or messing with it or or moving things

00:27:12,150 --> 00:27:18,240
around it's a good way of of buying time

00:27:16,650 --> 00:27:20,610
if you think that you're going to switch

00:27:18,240 --> 00:27:22,590
things out from underneath it does give

00:27:20,610 --> 00:27:25,679
you more flexibility you're right that

00:27:22,590 --> 00:27:27,299
you pay a penalty and that now you you

00:27:25,679 --> 00:27:29,400
will break things if you need to change

00:27:27,299 --> 00:27:32,730
that API and developers have written

00:27:29,400 --> 00:27:36,090
things against it I think it's

00:27:32,730 --> 00:27:38,220
interesting because if you're providing

00:27:36,090 --> 00:27:41,610
an API that's supposed to be a

00:27:38,220 --> 00:27:45,090
compatible API with somebody else an

00:27:41,610 --> 00:27:48,570
example might be s3 so s3 is Amazon's

00:27:45,090 --> 00:27:49,070
object storage so a lot of people are

00:27:48,570 --> 00:27:51,750
writing

00:27:49,070 --> 00:27:53,280
api's that provide compatibility so if

00:27:51,750 --> 00:27:57,720
you had written an application to talk

00:27:53,280 --> 00:27:59,850
to Amazon's s3 now you could instead

00:27:57,720 --> 00:28:02,309
point the point the application to

00:27:59,850 --> 00:28:04,320
something else and it still talks s3 so

00:28:02,309 --> 00:28:06,299
the application doesn't think anything

00:28:04,320 --> 00:28:09,630
has changed but you've really changed

00:28:06,299 --> 00:28:12,240
the storage from underneath it this is a

00:28:09,630 --> 00:28:15,720
powerful thing but if the developer

00:28:12,240 --> 00:28:17,880
keeps keeps marching to s3 and s3 keeps

00:28:15,720 --> 00:28:19,860
changing then you now have another

00:28:17,880 --> 00:28:23,159
maintenance point in that you now need

00:28:19,860 --> 00:28:25,409
to manage the API keep it updated and

00:28:23,159 --> 00:28:27,990
keep it up-to-date to mirror whatever it

00:28:25,409 --> 00:28:29,880
is that's that's being written it does

00:28:27,990 --> 00:28:32,010
have benefits and that you do get this

00:28:29,880 --> 00:28:34,080
flexibility you can add new features and

00:28:32,010 --> 00:28:35,669
capabilities you can swap things from

00:28:34,080 --> 00:28:37,230
underneath because of that abstraction

00:28:35,669 --> 00:28:38,669
but the penalty is you now have

00:28:37,230 --> 00:28:39,030
something else that you need to manage

00:28:38,669 --> 00:28:40,620
and

00:28:39,030 --> 00:28:44,220
maintain because you've you've

00:28:40,620 --> 00:28:45,930
introduced this layer of indirection so

00:28:44,220 --> 00:28:48,720
the questions around the trend of

00:28:45,930 --> 00:28:51,240
hardware that processing and memory is

00:28:48,720 --> 00:28:54,090
becoming less expensive and that you

00:28:51,240 --> 00:28:57,180
simply store the data and then pick it

00:28:54,090 --> 00:28:59,190
up and change it as necessary and then

00:28:57,180 --> 00:29:03,210
either story back or present it to the

00:28:59,190 --> 00:29:05,430
application based on its needs I think

00:29:03,210 --> 00:29:10,170
that it is possible but you're also

00:29:05,430 --> 00:29:11,700
adding complexity at least up front and

00:29:10,170 --> 00:29:14,340
you then have to make up for that by

00:29:11,700 --> 00:29:16,170
creating logic to unwind the complexity

00:29:14,340 --> 00:29:17,490
I think it's appropriate depending on

00:29:16,170 --> 00:29:20,130
what you're trying to do if we're

00:29:17,490 --> 00:29:21,660
talking about sensor data so massive

00:29:20,130 --> 00:29:24,630
amounts of data that's constantly

00:29:21,660 --> 00:29:26,100
flowing in from from points it might

00:29:24,630 --> 00:29:29,070
make sense to store the data like that

00:29:26,100 --> 00:29:31,830
if I'm trying to write an application to

00:29:29,070 --> 00:29:34,260
solve a specific business problem where

00:29:31,830 --> 00:29:37,340
I place the logic really depends on what

00:29:34,260 --> 00:29:41,970
problem I'm trying to solve I think I

00:29:37,340 --> 00:29:43,830
think it gets back to what data format

00:29:41,970 --> 00:29:46,320
is the data coming in and what problem

00:29:43,830 --> 00:29:48,180
am I trying to solve with it that would

00:29:46,320 --> 00:29:51,210
determine what the best way to handle

00:29:48,180 --> 00:29:53,460
the data is I think there's a class of

00:29:51,210 --> 00:29:55,470
problems in data that would fall under

00:29:53,460 --> 00:29:57,210
exactly what you're saying would be

00:29:55,470 --> 00:29:59,040
fantastic if we had an automated

00:29:57,210 --> 00:30:01,380
platform that could just ingest

00:29:59,040 --> 00:30:03,420
everything and you could get the ideal

00:30:01,380 --> 00:30:07,440
format you want out simply by requesting

00:30:03,420 --> 00:30:09,660
it we may get there I don't know how far

00:30:07,440 --> 00:30:11,430
out that is though I mean that that

00:30:09,660 --> 00:30:13,530
might be quite a ways out before we get

00:30:11,430 --> 00:30:16,980
there or maybe I'm wrong it might be

00:30:13,530 --> 00:30:19,920
around the corner so I don't really know

00:30:16,980 --> 00:30:22,500
I know that for developers to be able to

00:30:19,920 --> 00:30:24,300
easily write code to it they need to be

00:30:22,500 --> 00:30:26,370
able to wrap their heads around how the

00:30:24,300 --> 00:30:28,470
data is and how they need to deal with

00:30:26,370 --> 00:30:30,990
the data and that's probably the biggest

00:30:28,470 --> 00:30:33,050
barrier to to any of these things and

00:30:30,990 --> 00:30:35,760
that's why they make different choices I

00:30:33,050 --> 00:30:37,640
think it could I think there's lots of

00:30:35,760 --> 00:30:41,250
storage technologies and people

00:30:37,640 --> 00:30:44,010
researching things around doing this

00:30:41,250 --> 00:30:46,500
idea if you look at SSDs replacing

00:30:44,010 --> 00:30:48,780
spinning disks and you get a 10 to 100 X

00:30:46,500 --> 00:30:50,010
in performance improvement if we come

00:30:48,780 --> 00:30:52,440
out with a way of making memory

00:30:50,010 --> 00:30:55,080
persistent like the violin memory

00:30:52,440 --> 00:30:57,920
stuff that I've seen or mem resistors or

00:30:55,080 --> 00:31:00,990
something like that could probably

00:30:57,920 --> 00:31:02,400
probably another ten years away but I

00:31:00,990 --> 00:31:04,320
think we could see something like that

00:31:02,400 --> 00:31:05,850
and it would change the game it

00:31:04,320 --> 00:31:08,250
definitely would which is probably what

00:31:05,850 --> 00:31:11,870
the next generation past no sequel will

00:31:08,250 --> 00:31:13,400
be with that I think everyone very much

00:31:11,870 --> 00:31:17,040
thank you

00:31:13,400 --> 00:31:20,319
[Applause]

00:31:17,040 --> 00:31:20,319

YouTube URL: https://www.youtube.com/watch?v=fR2Z_bBi5Qw


