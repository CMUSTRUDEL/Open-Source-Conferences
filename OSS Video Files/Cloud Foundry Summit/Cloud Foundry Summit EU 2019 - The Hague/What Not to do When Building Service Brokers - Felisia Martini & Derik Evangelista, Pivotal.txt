Title: What Not to do When Building Service Brokers - Felisia Martini & Derik Evangelista, Pivotal
Publication date: 2019-09-13
Playlist: Cloud Foundry Summit EU 2019 - The Hague
Description: 
	What Not to do When Building Service Brokers - Felisia Martini & Derik Evangelista, Pivotal 

The Open Service Broker API is the specification that adds service capabilities to platforms like Cloud Foundry and Kubernetes. Central to the spec are the Service Brokers: components that live between the platform and the actual service.   But building brokers is hard. The spec is extensive and there are many details one can easily miss when implementing a service broker.  In this talk, we will show how to avoid common mistakes we learned from building service brokers at Pivotal, highlighting points like security, scalability, resilience and reliability. For that, we will leverage open source libraries that help with broker development and maintenance.

For more info: https://www.cloudfoundry.org/
Captions: 
	00:00:00,060 --> 00:00:05,009
hello I'm Derek that's Felicia and a

00:00:03,210 --> 00:00:08,040
huge day to talk about what not to do

00:00:05,009 --> 00:00:09,840
when building service brokers so we both

00:00:08,040 --> 00:00:11,880
work at Butte Oh out of the London

00:00:09,840 --> 00:00:13,740
office and it serves any human team and

00:00:11,880 --> 00:00:16,500
we build their own demand service broker

00:00:13,740 --> 00:00:18,000
that people to let powers the dates and

00:00:16,500 --> 00:00:21,180
service offerings such as Mexico and

00:00:18,000 --> 00:00:24,269
RabbitMQ that people provides we've been

00:00:21,180 --> 00:00:26,039
building brokers for a while I've been

00:00:24,269 --> 00:00:28,650
building Brooks for almost two years now

00:00:26,039 --> 00:00:30,570
and Feliz it for almost a year so

00:00:28,650 --> 00:00:31,700
hopefully we learn a thing or two that

00:00:30,570 --> 00:00:35,309
will save you a little bit of headache

00:00:31,700 --> 00:00:36,899
when you try to build your own that's

00:00:35,309 --> 00:00:38,969
briefly the agenda that we're gonna go

00:00:36,899 --> 00:00:41,910
today we're going to talk about the open

00:00:38,969 --> 00:00:44,160
service broker API spec and what what it

00:00:41,910 --> 00:00:45,960
is and then we're gonna go to the broker

00:00:44,160 --> 00:00:46,920
operations so what are the minimum what

00:00:45,960 --> 00:00:49,590
are the things that you need to

00:00:46,920 --> 00:00:51,420
implement when you are respecting expect

00:00:49,590 --> 00:00:53,039
when I'm ready for it to the spec then

00:00:51,420 --> 00:00:54,300
you're gonna go to the to the point so

00:00:53,039 --> 00:00:55,710
to the main points of the talks they're

00:00:54,300 --> 00:00:57,870
like what do you want to avoid and what

00:00:55,710 --> 00:00:59,129
you want to keep an eye on and then

00:00:57,870 --> 00:01:02,820
hopefully you have some times for

00:00:59,129 --> 00:01:05,070
questions so the service broker API spec

00:01:02,820 --> 00:01:06,900
in general like if you are building

00:01:05,070 --> 00:01:08,250
applications your application will

00:01:06,900 --> 00:01:10,110
probably need some data rights and

00:01:08,250 --> 00:01:14,369
something to do anything interesting you

00:01:10,110 --> 00:01:16,080
probably some data there is a need like

00:01:14,369 --> 00:01:17,970
called foundry when old foundry was

00:01:16,080 --> 00:01:20,520
emerging as a platform there was a need

00:01:17,970 --> 00:01:23,009
to bring first-class experience to the

00:01:20,520 --> 00:01:26,909
platform for services as well not only

00:01:23,009 --> 00:01:28,979
for apps and platforms like toddfamily

00:01:26,909 --> 00:01:31,369
kubernetes both converged on those

00:01:28,979 --> 00:01:35,820
bodies back which is an specification

00:01:31,369 --> 00:01:37,829
that allows you to give the same service

00:01:35,820 --> 00:01:39,119
to both platforms yet to provide the

00:01:37,829 --> 00:01:41,520
same service experience in both

00:01:39,119 --> 00:01:44,159
platforms like the same life that

00:01:41,520 --> 00:01:45,990
lifecycle management experience giving

00:01:44,159 --> 00:01:47,340
the your develops an unified a

00:01:45,990 --> 00:01:50,369
structured way of consuming those

00:01:47,340 --> 00:01:53,670
services so a little bit of history on

00:01:50,369 --> 00:01:56,820
those buckets back around like a squat

00:01:53,670 --> 00:01:59,280
foundry rose to prominence as popular

00:01:56,820 --> 00:02:01,229
enterprise cloud platform their

00:01:59,280 --> 00:02:03,810
foundation saw that they needed like

00:02:01,229 --> 00:02:05,310
software vendors wanted to bring their

00:02:03,810 --> 00:02:06,689
own services to the platform and once

00:02:05,310 --> 00:02:08,550
you provide their service again as a

00:02:06,689 --> 00:02:11,129
first-class experience to that platform

00:02:08,550 --> 00:02:12,750
users so the foundation sought an

00:02:11,129 --> 00:02:13,790
opportunity there and together with the

00:02:12,750 --> 00:02:16,159
community they decide

00:02:13,790 --> 00:02:20,719
how the services like could interact

00:02:16,159 --> 00:02:22,129
with the platform and in 2014 the output

00:02:20,719 --> 00:02:24,230
of that of that cooperation was the

00:02:22,129 --> 00:02:26,780
Cloud Foundry service broker API which

00:02:24,230 --> 00:02:29,329
was around 2014 and defined at the

00:02:26,780 --> 00:02:32,090
broker pattern for cloud foundry between

00:02:29,329 --> 00:02:34,129
2014 and 2016 other platforms like

00:02:32,090 --> 00:02:35,840
minetti's emerged as like new

00:02:34,129 --> 00:02:38,810
abstractions that you'd want to run your

00:02:35,840 --> 00:02:40,609
apps and services on their foundation

00:02:38,810 --> 00:02:43,219
saw the potential and an opportunity

00:02:40,609 --> 00:02:45,950
there to extend the old foundry service

00:02:43,219 --> 00:02:48,230
brocade guys specification to more

00:02:45,950 --> 00:02:50,840
services and that's when the project

00:02:48,230 --> 00:02:52,819
opens the service broker API project was

00:02:50,840 --> 00:02:54,379
launched to ensure that that

00:02:52,819 --> 00:02:56,739
specification continued to be like

00:02:54,379 --> 00:02:59,720
relevant and used by different services

00:02:56,739 --> 00:03:01,819
both platforms and service vendors the

00:02:59,720 --> 00:03:03,950
foundation created a dedicated project

00:03:01,819 --> 00:03:05,989
committee to manage the do swap it's

00:03:03,950 --> 00:03:10,069
back today it has members from pivotal

00:03:05,989 --> 00:03:12,590
IBM Google Microsoft and others so today

00:03:10,069 --> 00:03:14,239
they called the open service broker guys

00:03:12,590 --> 00:03:16,760
back is truly supported by both

00:03:14,239 --> 00:03:19,959
kubernetes and cloud foundry and you can

00:03:16,760 --> 00:03:22,579
find many services that many brokers

00:03:19,959 --> 00:03:25,310
four-forty services so but what is

00:03:22,579 --> 00:03:26,629
exactly like a service broker the

00:03:25,310 --> 00:03:28,190
service broker is this component that

00:03:26,629 --> 00:03:31,190
lives between the platform and the

00:03:28,190 --> 00:03:33,019
services so it's and what was what

00:03:31,190 --> 00:03:34,669
expect define this is a contract it's

00:03:33,019 --> 00:03:37,220
what this component that we call the

00:03:34,669 --> 00:03:38,900
service broker or just a broker needs to

00:03:37,220 --> 00:03:43,129
implement in order to give to the

00:03:38,900 --> 00:03:44,449
platform and experience on services and

00:03:43,129 --> 00:03:46,579
that gives like independent software

00:03:44,449 --> 00:03:48,650
vendors a simple and elegant way to

00:03:46,579 --> 00:03:49,849
deliver their services to them deliver

00:03:48,650 --> 00:03:52,250
service to applications

00:03:49,849 --> 00:03:54,169
it also abstracts the like all the

00:03:52,250 --> 00:03:55,220
lifecycle concerns from the developer so

00:03:54,169 --> 00:03:57,319
they don't need to worry about how do

00:03:55,220 --> 00:03:59,840
they manage how how where do they going

00:03:57,319 --> 00:04:05,959
to deploy them I see go and let them

00:03:59,840 --> 00:04:07,849
focus on their own applications so to

00:04:05,959 --> 00:04:10,939
the actual developer broker you

00:04:07,849 --> 00:04:12,590
basically need to do three main type of

00:04:10,939 --> 00:04:14,209
operations the first one is the Service

00:04:12,590 --> 00:04:17,269
Catalog operation so that's defining a

00:04:14,209 --> 00:04:19,519
lost puppy spec and a catalog is what's

00:04:17,269 --> 00:04:22,639
described all the services that that

00:04:19,519 --> 00:04:24,919
particular broker can provide so and

00:04:22,639 --> 00:04:26,300
also defines the plants plans if you're

00:04:24,919 --> 00:04:27,889
not familiar of the plants plant is what

00:04:26,300 --> 00:04:29,569
determines what type of

00:04:27,889 --> 00:04:31,039
that particular service you want so for

00:04:29,569 --> 00:04:34,969
example if you're deploying on my Seco

00:04:31,039 --> 00:04:36,409
broker small plan might be a small disc

00:04:34,969 --> 00:04:39,469
size and a big plan might be like a

00:04:36,409 --> 00:04:42,469
large disc size and the only operation

00:04:39,469 --> 00:04:45,379
that it's like related to the catalog is

00:04:42,469 --> 00:04:47,509
the actual fetching of the catalog one

00:04:45,379 --> 00:04:50,330
broker can also provide many services so

00:04:47,509 --> 00:04:51,499
this is an array of services the second

00:04:50,330 --> 00:04:53,990
type of operation is the instance

00:04:51,499 --> 00:04:55,639
management itself which controls the

00:04:53,990 --> 00:04:57,409
life cycle of the service instance and

00:04:55,639 --> 00:04:58,550
the operations there is like how do you

00:04:57,409 --> 00:05:00,889
provision and deprovision

00:04:58,550 --> 00:05:03,430
or create and destroy a service instance

00:05:00,889 --> 00:05:05,659
and how you update one an existing one

00:05:03,430 --> 00:05:08,150
finally the third type is the actual

00:05:05,659 --> 00:05:09,620
access management which is which

00:05:08,150 --> 00:05:11,960
controls who can communicate with the

00:05:09,620 --> 00:05:13,669
service instance for the service broker

00:05:11,960 --> 00:05:16,520
perspective this operation is called a

00:05:13,669 --> 00:05:18,529
binding so a binding is giving an app or

00:05:16,520 --> 00:05:21,110
a user access to that particular service

00:05:18,529 --> 00:05:28,550
and when you unbind you revoke that that

00:05:21,110 --> 00:05:30,620
access so with that go to falesha so as

00:05:28,550 --> 00:05:33,050
Derek said we've been building brokers

00:05:30,620 --> 00:05:34,759
for a while now so and although they

00:05:33,050 --> 00:05:38,389
implement the specification is quite

00:05:34,759 --> 00:05:41,719
straightforward you can still fall into

00:05:38,389 --> 00:05:44,719
some pitfalls and we'll show some of

00:05:41,719 --> 00:05:47,169
them today so first of all let's start

00:05:44,719 --> 00:05:49,909
talking about how your broker is running

00:05:47,169 --> 00:05:52,610
by default many times a broker can be

00:05:49,909 --> 00:05:54,889
running but over HTTP and the main

00:05:52,610 --> 00:05:57,259
problem here is the way CF communicates

00:05:54,889 --> 00:05:59,419
with a broker so let's take the example

00:05:57,259 --> 00:06:03,409
of create service broker command which

00:05:59,419 --> 00:06:05,300
will require the broker URL and the

00:06:03,409 --> 00:06:09,500
credentials and those credentials are

00:06:05,300 --> 00:06:12,020
taken by CF and stored and encrypted in

00:06:09,500 --> 00:06:15,740
the database however the broker is still

00:06:12,020 --> 00:06:17,419
running over HTTP and if there is

00:06:15,740 --> 00:06:23,389
something spoofing your broker that

00:06:17,419 --> 00:06:26,300
connection might be not secured so the

00:06:23,389 --> 00:06:29,810
simple solution for this it's just to

00:06:26,300 --> 00:06:32,120
run your broker over HTTPS and this

00:06:29,810 --> 00:06:35,990
means that CF will need to be provided

00:06:32,120 --> 00:06:37,610
with a certificate which is trusted and

00:06:35,990 --> 00:06:39,709
the broker will need to be configured

00:06:37,610 --> 00:06:40,430
with that certificate however there is a

00:06:39,709 --> 00:06:42,530
little

00:06:40,430 --> 00:06:45,770
caveat that you need to be careful to

00:06:42,530 --> 00:06:49,430
understand where your connection from

00:06:45,770 --> 00:06:54,800
the where the connection to the broker

00:06:49,430 --> 00:06:57,199
will be coming from so if there is a

00:06:54,800 --> 00:07:00,410
girl Rooter in between your connection

00:06:57,199 --> 00:07:02,330
the tls communication will be terminated

00:07:00,410 --> 00:07:03,740
there and then the rest of the

00:07:02,330 --> 00:07:07,280
communication from the co reader to the

00:07:03,740 --> 00:07:11,530
broker itself will need to be configured

00:07:07,280 --> 00:07:14,840
separately from your other certificate

00:07:11,530 --> 00:07:16,729
so another issue with running the way

00:07:14,840 --> 00:07:19,880
you're running the broker it has to do

00:07:16,729 --> 00:07:22,490
with the availability of the broker so

00:07:19,880 --> 00:07:26,600
by default you can make the broker

00:07:22,490 --> 00:07:28,910
publicly available and many examples of

00:07:26,600 --> 00:07:31,070
this are when you put the probe when you

00:07:28,910 --> 00:07:33,020
push the broker using the CF push

00:07:31,070 --> 00:07:37,550
command and that's pretty valid because

00:07:33,020 --> 00:07:40,849
it's just an API server it will just

00:07:37,550 --> 00:07:43,669
have some end points however the things

00:07:40,849 --> 00:07:45,139
to consider in this case is that you

00:07:43,669 --> 00:07:49,820
might want to restrict the network

00:07:45,139 --> 00:07:52,310
access for your broker and you will

00:07:49,820 --> 00:07:54,380
probably know pretty much who are the

00:07:52,310 --> 00:07:57,979
users of that broker and it's pretty

00:07:54,380 --> 00:08:00,080
easy to restrict the access and to

00:07:57,979 --> 00:08:02,870
restrict where the broker can be

00:08:00,080 --> 00:08:06,889
communicated from and if you're running

00:08:02,870 --> 00:08:10,550
it in CF you can just use implement the

00:08:06,889 --> 00:08:12,740
CF security groups and you just put some

00:08:10,550 --> 00:08:16,699
rules around the protocols the IPS that

00:08:12,740 --> 00:08:19,400
can connect to that broker and with that

00:08:16,699 --> 00:08:21,560
we can move on to the next issue which

00:08:19,400 --> 00:08:23,360
has to do with the other APIs back so

00:08:21,560 --> 00:08:26,030
it's really good that there is a spec

00:08:23,360 --> 00:08:28,010
and everyone can confirm to it but

00:08:26,030 --> 00:08:30,590
sometimes when you especially want you

00:08:28,010 --> 00:08:33,490
to just start implementing it you might

00:08:30,590 --> 00:08:35,839
partially implement the spec and that's

00:08:33,490 --> 00:08:37,729
either because you don't need all the

00:08:35,839 --> 00:08:40,130
properties in each of the end points or

00:08:37,729 --> 00:08:42,800
it's also because the spec even though

00:08:40,130 --> 00:08:44,450
it's only six or seven and points it's

00:08:42,800 --> 00:08:46,970
quite long it has a lot of little

00:08:44,450 --> 00:08:51,170
specifications it extends seconds to

00:08:46,970 --> 00:08:53,029
scroll through all this so first of all

00:08:51,170 --> 00:08:53,640
why would you really need to implement

00:08:53,029 --> 00:08:57,060
this

00:08:53,640 --> 00:08:59,820
cool and the first reason is for for

00:08:57,060 --> 00:09:02,280
consistency so you want any platform

00:08:59,820 --> 00:09:04,200
that being CF or kubernetes to be able

00:09:02,280 --> 00:09:07,080
to communicate to your broker and not

00:09:04,200 --> 00:09:08,880
have any surprises and on the other hand

00:09:07,080 --> 00:09:11,960
you want to also future-proof your

00:09:08,880 --> 00:09:14,520
broker so the clients are always

00:09:11,960 --> 00:09:16,500
confirming clients that are calling your

00:09:14,520 --> 00:09:18,150
broker will be confirming to the spec so

00:09:16,500 --> 00:09:21,270
you will need to be confirming to the

00:09:18,150 --> 00:09:23,730
same spec as well for example the v3 of

00:09:21,270 --> 00:09:26,850
the CF API will only have asynchronous

00:09:23,730 --> 00:09:31,710
calls to the broker so if your broker is

00:09:26,850 --> 00:09:34,200
not serving async it will have some

00:09:31,710 --> 00:09:39,270
surprises when you connect to the latest

00:09:34,200 --> 00:09:43,080
CF ABI so with that we have established

00:09:39,270 --> 00:09:45,630
that we want to keep implementing the

00:09:43,080 --> 00:09:47,820
entire spec but that is also quite a

00:09:45,630 --> 00:09:50,490
difficult thing to do if you don't have

00:09:47,820 --> 00:09:56,490
all the infrastructure in place

00:09:50,490 --> 00:09:58,890
and by that what we mean is being able

00:09:56,490 --> 00:10:01,770
to check that you are always compliant

00:09:58,890 --> 00:10:05,610
to the spec and the reason for that

00:10:01,770 --> 00:10:06,840
would be because you want to keep up to

00:10:05,610 --> 00:10:08,660
date with all the new features and

00:10:06,840 --> 00:10:10,730
provide the features that some other

00:10:08,660 --> 00:10:13,830
members of the community have already

00:10:10,730 --> 00:10:16,110
decided that our part of the next

00:10:13,830 --> 00:10:21,480
version of the spec so for example the

00:10:16,110 --> 00:10:25,860
version 215 of the spec will include the

00:10:21,480 --> 00:10:28,770
broker having ability to decide how how

00:10:25,860 --> 00:10:31,230
long the max fuelling duration is also

00:10:28,770 --> 00:10:33,510
the broker can publish version for each

00:10:31,230 --> 00:10:36,180
of the services and the services plants

00:10:33,510 --> 00:10:39,270
can now specify whether their updatable

00:10:36,180 --> 00:10:45,000
or not and the way to keep up to date

00:10:39,270 --> 00:10:47,520
would be either implementing one of the

00:10:45,000 --> 00:10:49,350
spec spec checkers that the community

00:10:47,520 --> 00:10:52,920
has already created and you can just add

00:10:49,350 --> 00:10:55,620
them to your pipeline and another easy

00:10:52,920 --> 00:10:59,759
way to just keep on top of the spec is

00:10:55,620 --> 00:11:03,119
by using some AHS boppy frameworks like

00:10:59,759 --> 00:11:05,819
broker API or the open service broker

00:11:03,119 --> 00:11:10,109
client which are already there easy to

00:11:05,819 --> 00:11:13,439
use and conform to the spec another

00:11:10,109 --> 00:11:16,109
issue with those Bubba spec is sometimes

00:11:13,439 --> 00:11:18,179
you go off spec and that can be either

00:11:16,109 --> 00:11:20,790
by mistake because you didn't have the

00:11:18,179 --> 00:11:23,899
checkers on place or store it can be on

00:11:20,790 --> 00:11:27,299
purpose because there are features that

00:11:23,899 --> 00:11:29,429
for your purpose for your broker would

00:11:27,299 --> 00:11:32,639
be beneficial but they're not part of

00:11:29,429 --> 00:11:35,489
the spec and in our case for Berkley

00:11:32,639 --> 00:11:39,449
that we create we had to you to add

00:11:35,489 --> 00:11:42,239
force delete flag when some service

00:11:39,449 --> 00:11:44,609
instance become completely unresponsive

00:11:42,239 --> 00:11:48,959
and this is not part of the spec it

00:11:44,609 --> 00:11:50,999
wouldn't really break our come our

00:11:48,959 --> 00:11:56,660
implementation of the earth map but

00:11:50,999 --> 00:11:59,639
still it's not documented anywhere so

00:11:56,660 --> 00:12:03,149
things to consider one going off spec is

00:11:59,639 --> 00:12:04,619
do you actually really need to do it you

00:12:03,149 --> 00:12:07,289
have to consider that there are already

00:12:04,619 --> 00:12:09,089
a lot of stuff on the specification and

00:12:07,289 --> 00:12:11,970
you can go back there and talk to the

00:12:09,089 --> 00:12:13,559
community and see if there is a way to

00:12:11,970 --> 00:12:15,660
implement the feature that you need with

00:12:13,559 --> 00:12:18,089
what is already in the spec and the

00:12:15,660 --> 00:12:20,369
second option is just join the

00:12:18,089 --> 00:12:23,209
conversation on those papi expect and I

00:12:20,369 --> 00:12:25,799
was backing a call or open an issue and

00:12:23,209 --> 00:12:28,109
try to see if there is a ways that the

00:12:25,799 --> 00:12:30,289
thing that you're implementing might be

00:12:28,109 --> 00:12:33,029
beneficial to other people as well

00:12:30,289 --> 00:12:35,759
however there are a couple of issues

00:12:33,029 --> 00:12:38,730
with going after the spec and one of

00:12:35,759 --> 00:12:41,399
them is the support from the platform

00:12:38,730 --> 00:12:45,089
it's not guaranteed so if you go up spec

00:12:41,399 --> 00:12:48,799
and you rely on a behavior that CF for

00:12:45,089 --> 00:12:50,939
example is providing today there is no

00:12:48,799 --> 00:12:54,169
consistency and there is no assurance

00:12:50,939 --> 00:12:56,669
that it will actually work later on and

00:12:54,169 --> 00:12:59,429
while doing this you still have to make

00:12:56,669 --> 00:13:01,559
sure that your remaining about be

00:12:59,429 --> 00:13:04,279
compliant and you're not breaking what

00:13:01,559 --> 00:13:04,279
is already there

00:13:05,740 --> 00:13:12,920
we're talking now about service bindings

00:13:08,240 --> 00:13:14,360
and how that can be a problem so service

00:13:12,920 --> 00:13:17,480
binding again is that operation that

00:13:14,360 --> 00:13:19,940
gives access from an application we've

00:13:17,480 --> 00:13:22,640
access you to your service so you might

00:13:19,940 --> 00:13:24,200
be familiar with this diagram but that

00:13:22,640 --> 00:13:25,910
basically explains how the cloud

00:13:24,200 --> 00:13:27,440
controller talks to the broker to

00:13:25,910 --> 00:13:30,500
actually create a service binding so the

00:13:27,440 --> 00:13:32,660
user initiates the request with CF bind

00:13:30,500 --> 00:13:35,089
service command that calls a broker

00:13:32,660 --> 00:13:37,100
which you then communicate to the

00:13:35,089 --> 00:13:38,779
service you create a service binding so

00:13:37,100 --> 00:13:41,420
for example that might be creating an

00:13:38,779 --> 00:13:44,450
user on my sequel cluster or something

00:13:41,420 --> 00:13:46,730
like that the service will then return

00:13:44,450 --> 00:13:47,990
those credentials the broker will get

00:13:46,730 --> 00:13:49,400
those credentials and return those

00:13:47,990 --> 00:13:51,710
credentials to the cloud controller on

00:13:49,400 --> 00:13:54,740
the pickup services objects which should

00:13:51,710 --> 00:13:57,260
then be forward to Diego which you then

00:13:54,740 --> 00:13:59,630
add that pickup services to the

00:13:57,260 --> 00:14:02,660
application so if you ever done anything

00:13:59,630 --> 00:14:04,550
like this you know that if you run CFM

00:14:02,660 --> 00:14:06,170
poor or similar commands you'll be able

00:14:04,550 --> 00:14:10,250
to see the plain text or nature's there

00:14:06,170 --> 00:14:11,480
so yes and that's the problem right in

00:14:10,250 --> 00:14:14,060
general you don't want plain text

00:14:11,480 --> 00:14:16,820
relations over the Internet

00:14:14,060 --> 00:14:18,920
it's not a good thing especially when

00:14:16,820 --> 00:14:22,010
people can do things like that and you

00:14:18,920 --> 00:14:24,680
know just copy and paste send to their

00:14:22,010 --> 00:14:26,390
friends jump in and try to debug

00:14:24,680 --> 00:14:29,750
themselves maybe it's something is going

00:14:26,390 --> 00:14:31,580
wrong the main problems that comes with

00:14:29,750 --> 00:14:33,890
train two Exponential's or plain text

00:14:31,580 --> 00:14:36,470
bindings first is the leaking

00:14:33,890 --> 00:14:38,720
environment variables to logs it's not

00:14:36,470 --> 00:14:40,370
unheard of that people log things like

00:14:38,720 --> 00:14:42,290
environment variables and like what is

00:14:40,370 --> 00:14:44,570
the configuration of there's particular

00:14:42,290 --> 00:14:47,000
app or service when the application is

00:14:44,570 --> 00:14:49,220
starting by having that's those

00:14:47,000 --> 00:14:51,320
credentials in plain text as environment

00:14:49,220 --> 00:14:52,850
variables because that in the end of the

00:14:51,320 --> 00:14:54,680
day that's what the pickup services ends

00:14:52,850 --> 00:14:58,520
up being on your application right it's

00:14:54,680 --> 00:15:00,500
just an environment variable you may

00:14:58,520 --> 00:15:02,870
increase the chances of people logging

00:15:00,500 --> 00:15:04,940
that and then people don't treat logs in

00:15:02,870 --> 00:15:06,320
general with the same level of scrutiny

00:15:04,940 --> 00:15:08,029
and security that they treat their

00:15:06,320 --> 00:15:10,250
applications so they might you know send

00:15:08,029 --> 00:15:13,370
that to a paper trail or download it and

00:15:10,250 --> 00:15:15,290
email it to someone so you run the risk

00:15:13,370 --> 00:15:17,680
of like you increase the risk of rate of

00:15:15,290 --> 00:15:17,680
disclosure

00:15:17,709 --> 00:15:23,660
also although the credentials are not

00:15:21,379 --> 00:15:25,160
traveling on the open Internet when you

00:15:23,660 --> 00:15:26,750
create a service mining they should be

00:15:25,160 --> 00:15:28,730
inside the internal cloud founder

00:15:26,750 --> 00:15:31,100
network they still transiting between

00:15:28,730 --> 00:15:32,689
components and that they also increase

00:15:31,100 --> 00:15:38,689
the risk of disclosure right you don't

00:15:32,689 --> 00:15:41,209
want that for similar reasons and also

00:15:38,689 --> 00:15:43,670
it makes retaining creations slightly

00:15:41,209 --> 00:15:45,079
harder because if those environment if

00:15:43,670 --> 00:15:47,810
you cannot easily rotate their

00:15:45,079 --> 00:15:50,810
credentials you might you know stick

00:15:47,810 --> 00:15:52,490
with it for a little bit longer and if

00:15:50,810 --> 00:15:54,529
you if you need to rotate you need to

00:15:52,490 --> 00:15:57,439
either create a new binding or restate

00:15:54,529 --> 00:15:58,759
your app and that can cause this net can

00:15:57,439 --> 00:16:00,529
cause downtime and stuff like that then

00:15:58,759 --> 00:16:03,050
people might avoid doing it in the first

00:16:00,529 --> 00:16:05,269
place which again if you have the same

00:16:03,050 --> 00:16:08,509
set of credentials for a long time you

00:16:05,269 --> 00:16:09,920
increase the risk of disclosure so one

00:16:08,509 --> 00:16:12,470
of the possible solutions for this

00:16:09,920 --> 00:16:13,490
problem is to use credible for those

00:16:12,470 --> 00:16:16,819
that are not familiar with credit

00:16:13,490 --> 00:16:19,610
upgrade hub is a open source credit they

00:16:16,819 --> 00:16:23,149
chose management system it's a key value

00:16:19,610 --> 00:16:25,579
store you store a value you get a key

00:16:23,149 --> 00:16:26,839
and then you can consume it so it's made

00:16:25,579 --> 00:16:32,689
for credentials so encrypts your

00:16:26,839 --> 00:16:34,819
credentials and all that yeah and it has

00:16:32,689 --> 00:16:37,879
a it is supported on both CF and bush

00:16:34,819 --> 00:16:39,800
so 14 if you have a credit hog and

00:16:37,879 --> 00:16:41,839
you're in CF can talk to your cred hub

00:16:39,800 --> 00:16:44,269
the new you create binding diagram might

00:16:41,839 --> 00:16:45,709
look something like this so they've

00:16:44,269 --> 00:16:47,660
created by nice you've initiated by the

00:16:45,709 --> 00:16:49,519
user it goes through the service broker

00:16:47,660 --> 00:16:51,769
the same way it goes through the service

00:16:49,519 --> 00:16:53,540
the same way and create a credential but

00:16:51,769 --> 00:16:54,559
then when the service broker gets the

00:16:53,540 --> 00:16:57,050
credentials back he does something

00:16:54,559 --> 00:16:58,670
different instead of just sending it

00:16:57,050 --> 00:17:00,110
through under the cap services back to

00:16:58,670 --> 00:17:01,129
the Cloud Controller it to actually

00:17:00,110 --> 00:17:04,250
store on cred hub

00:17:01,129 --> 00:17:06,799
so this broker need access to credit and

00:17:04,250 --> 00:17:08,780
I need to restore that there and then it

00:17:06,799 --> 00:17:10,309
will give the application that the buy

00:17:08,780 --> 00:17:10,819
needs me created access to that

00:17:10,309 --> 00:17:14,750
particular

00:17:10,819 --> 00:17:16,789
granita on cran hub so it will get back

00:17:14,750 --> 00:17:19,429
from credible reference and then you use

00:17:16,789 --> 00:17:21,589
that reference I owned the cup clubs on

00:17:19,429 --> 00:17:22,909
the cup services actually called

00:17:21,589 --> 00:17:24,770
controller

00:17:22,909 --> 00:17:26,750
call controller would then forward that

00:17:24,770 --> 00:17:27,860
recap service to Diego and then the

00:17:26,750 --> 00:17:29,720
magic happens when you

00:17:27,860 --> 00:17:32,420
if CF can't talk should have same credit

00:17:29,720 --> 00:17:35,330
up when Diego is about you rights that

00:17:32,420 --> 00:17:38,990
they don't up it will resolve that for

00:17:35,330 --> 00:17:41,900
you so you you have access to them to

00:17:38,990 --> 00:17:45,500
their credentials in your app without

00:17:41,900 --> 00:17:48,590
having to do anything special on dealing

00:17:45,500 --> 00:17:50,240
with credible so your credential your

00:17:48,590 --> 00:17:51,980
binding will look something like this

00:17:50,240 --> 00:17:54,799
instead of being a plain text retention

00:17:51,980 --> 00:17:56,390
so slightly more secure you cannot find

00:17:54,799 --> 00:17:58,670
where that service is running or

00:17:56,390 --> 00:18:03,380
anything like that and if you send that

00:17:58,670 --> 00:18:04,790
in an email it's not a problem and you

00:18:03,380 --> 00:18:08,570
can find more about how to integrate

00:18:04,790 --> 00:18:14,030
cred hub on your on your Cloud Foundry

00:18:08,570 --> 00:18:16,130
deployment on that link the next thing

00:18:14,030 --> 00:18:19,370
we want to talk about is multi-tenancy

00:18:16,130 --> 00:18:23,150
on service instances and that's kind of

00:18:19,370 --> 00:18:24,950
our shameless plug so let's think about

00:18:23,150 --> 00:18:26,450
how the broker actually process commands

00:18:24,950 --> 00:18:28,280
right so if you have a rap team queue

00:18:26,450 --> 00:18:31,490
cluster for example what will create

00:18:28,280 --> 00:18:34,010
service do simple thing that you can do

00:18:31,490 --> 00:18:36,679
it's just create a queue so the cluster

00:18:34,010 --> 00:18:39,140
is running you run CF create service

00:18:36,679 --> 00:18:41,360
that creates a queue when you do then

00:18:39,140 --> 00:18:43,010
run CF create binding what that might do

00:18:41,360 --> 00:18:45,049
is create a user not created by white

00:18:43,010 --> 00:18:46,760
service that might create an user and

00:18:45,049 --> 00:18:48,350
give that user access to that particular

00:18:46,760 --> 00:18:50,929
queue and that's it

00:18:48,350 --> 00:18:53,150
it's simple it's great it's best when

00:18:50,929 --> 00:18:55,250
you delete the only leader binding what

00:18:53,150 --> 00:18:57,650
that will do justly the user when you

00:18:55,250 --> 00:18:59,240
delete the queue that on delete service

00:18:57,650 --> 00:19:00,830
that you just delete the queue so your

00:18:59,240 --> 00:19:02,540
cluster will not change it will be

00:19:00,830 --> 00:19:05,179
running you'll be there and you are just

00:19:02,540 --> 00:19:07,340
like changing how it interact and that

00:19:05,179 --> 00:19:10,220
definitely has some adventure advantages

00:19:07,340 --> 00:19:13,280
like it's quick it's simple easy to

00:19:10,220 --> 00:19:14,510
understand but for some critical

00:19:13,280 --> 00:19:16,660
services and for simple critical

00:19:14,510 --> 00:19:20,030
applications that might come with some

00:19:16,660 --> 00:19:21,679
problems that you might not expect one

00:19:20,030 --> 00:19:24,940
of the main problems the noisy neighbor

00:19:21,679 --> 00:19:27,470
problem so in a rabbitmq specific case

00:19:24,940 --> 00:19:29,960
the default behavior that it has it's

00:19:27,470 --> 00:19:31,640
like after getting 50 KB of data in a

00:19:29,960 --> 00:19:34,010
queue it will flush to the disk if no

00:19:31,640 --> 00:19:36,800
one is consuming one other thought that

00:19:34,010 --> 00:19:40,280
happened was someone created a service

00:19:36,800 --> 00:19:41,840
on a shared cluster pushed an app that

00:19:40,280 --> 00:19:43,880
was producing things so

00:19:41,840 --> 00:19:45,950
was going to Twitter and getting twits

00:19:43,880 --> 00:19:49,010
and putting the queue and then they

00:19:45,950 --> 00:19:50,870
forgot to push the consumer so that Q

00:19:49,010 --> 00:19:52,370
was getting full flush to disk can you

00:19:50,870 --> 00:19:54,380
feel flush the disk and if you flush to

00:19:52,370 --> 00:19:56,150
the disk until eventually that it's got

00:19:54,380 --> 00:19:58,070
full and any when that happened all of

00:19:56,150 --> 00:19:59,419
their cues all of their services that

00:19:58,070 --> 00:20:03,549
were not attached that particular

00:19:59,419 --> 00:20:05,990
krauser died that was not cool

00:20:03,549 --> 00:20:08,390
but that's not the only problem right so

00:20:05,990 --> 00:20:10,610
we also have some security problems now

00:20:08,390 --> 00:20:13,789
you have to think is are your bindings

00:20:10,610 --> 00:20:15,799
really unique because if you're creating

00:20:13,789 --> 00:20:17,120
user can you ensure and guarantee you

00:20:15,799 --> 00:20:18,500
have to think about it can you guarantee

00:20:17,120 --> 00:20:21,409
that that user will not have access to a

00:20:18,500 --> 00:20:22,610
different Q or a different database do

00:20:21,409 --> 00:20:25,190
you need do you need to think about

00:20:22,610 --> 00:20:27,649
excavation of privileges is that

00:20:25,190 --> 00:20:30,080
something that a user might do like if

00:20:27,649 --> 00:20:31,700
they get access to the cluster can they

00:20:30,080 --> 00:20:33,830
just get access to the entire cluster

00:20:31,700 --> 00:20:36,559
jor database they can get extra entire

00:20:33,830 --> 00:20:37,880
cluster there's compliance as well some

00:20:36,559 --> 00:20:39,950
services depending on the app that

00:20:37,880 --> 00:20:42,980
you're running they just cannot to share

00:20:39,950 --> 00:20:44,779
services so it's really not a choice and

00:20:42,980 --> 00:20:48,740
it's also cost so you have to plan on

00:20:44,779 --> 00:20:50,809
how many service instances you want and

00:20:48,740 --> 00:20:55,130
you need to plan that up from so if you

00:20:50,809 --> 00:20:56,809
are running a my sequel offering and you

00:20:55,130 --> 00:20:59,299
want you know you might deploy tree

00:20:56,809 --> 00:21:00,919
Mexico clusters and never use them like

00:20:59,299 --> 00:21:02,960
for three databases so that that is

00:21:00,919 --> 00:21:05,299
costing you money and no one is actually

00:21:02,960 --> 00:21:06,830
using it and you also need to manage and

00:21:05,299 --> 00:21:08,390
keep an eye on it so if it's getting

00:21:06,830 --> 00:21:12,710
close to like the limit you need to

00:21:08,390 --> 00:21:14,679
deploy more and all of that some

00:21:12,710 --> 00:21:17,779
alternatives of that particular problem

00:21:14,679 --> 00:21:20,770
first you can explore if you can limit

00:21:17,779 --> 00:21:24,860
the idealization of the resources so

00:21:20,770 --> 00:21:27,620
things like my sequel and probably other

00:21:24,860 --> 00:21:29,330
services you can implement quarters and

00:21:27,620 --> 00:21:31,490
it's kind of stuff that will at least

00:21:29,330 --> 00:21:33,470
for some of those problems like the

00:21:31,490 --> 00:21:35,990
noisy neighbor will stop them off

00:21:33,470 --> 00:21:37,789
actually throwing everything offline it

00:21:35,990 --> 00:21:39,320
still can happen if like all the

00:21:37,789 --> 00:21:40,760
services are reaching the closer then

00:21:39,320 --> 00:21:43,190
you might still be in a funny place but

00:21:40,760 --> 00:21:45,260
you you at least reduce the chances of

00:21:43,190 --> 00:21:46,970
that occurring you can also consider

00:21:45,260 --> 00:21:50,169
service plans and how they impact the

00:21:46,970 --> 00:21:52,549
service instances so though you need a

00:21:50,169 --> 00:21:54,380
way of implementing quotas and still

00:21:52,549 --> 00:21:55,640
giving users some freedoms is to think

00:21:54,380 --> 00:21:57,740
about the plans and to thing about

00:21:55,640 --> 00:22:00,559
what do you mean are your plants too big

00:21:57,740 --> 00:22:02,179
maybe if you have like these plants that

00:22:00,559 --> 00:22:06,260
I consume you all the memories can you

00:22:02,179 --> 00:22:09,080
tweak a little bit so use more users can

00:22:06,260 --> 00:22:11,420
share that same resources and finally

00:22:09,080 --> 00:22:13,610
the best solution is to deploy your

00:22:11,420 --> 00:22:17,740
service on demand what that means is

00:22:13,610 --> 00:22:20,809
instead of using an existing cluster or

00:22:17,740 --> 00:22:23,210
existing deployment every time that a

00:22:20,809 --> 00:22:26,059
user creates a service that actually

00:22:23,210 --> 00:22:28,460
creates a new instance on your own your

00:22:26,059 --> 00:22:33,679
infrastructure of course that comes with

00:22:28,460 --> 00:22:35,570
drawbacks it's slightly slower slightly

00:22:33,679 --> 00:22:38,600
harder to implement it might be a little

00:22:35,570 --> 00:22:41,780
bit more difficult to she to start but

00:22:38,600 --> 00:22:48,650
it can help you to like increase

00:22:41,780 --> 00:22:50,419
adoption of your services so in summary

00:22:48,650 --> 00:22:53,540
some of the things that we have learned

00:22:50,419 --> 00:22:55,790
and we want you to think about are

00:22:53,540 --> 00:22:58,250
consider if the way that you're running

00:22:55,790 --> 00:23:01,240
your broker if you need to make it more

00:22:58,250 --> 00:23:04,520
secure if you need to make it or HTTPS

00:23:01,240 --> 00:23:07,429
and also try to conform as much as

00:23:04,520 --> 00:23:09,740
possible to the auspice spec and find

00:23:07,429 --> 00:23:11,660
ways how to keep on top of that and

00:23:09,740 --> 00:23:16,250
implement even the new features that

00:23:11,660 --> 00:23:18,620
come up secure bindings severe service

00:23:16,250 --> 00:23:21,200
bindings make sure that you don't use

00:23:18,620 --> 00:23:25,100
plain text credentials to return the

00:23:21,200 --> 00:23:28,400
bindings to the apps and the fourth one

00:23:25,100 --> 00:23:31,030
is think about do you need the

00:23:28,400 --> 00:23:34,790
multi-tenancy or an on-demand service

00:23:31,030 --> 00:23:37,910
instances and actually the last one is

00:23:34,790 --> 00:23:40,100
think if your use case actually requires

00:23:37,910 --> 00:23:42,440
you to write an on-demand broker because

00:23:40,100 --> 00:23:44,950
there are other ways easier ways for you

00:23:42,440 --> 00:23:48,440
to just provide the user provided

00:23:44,950 --> 00:23:50,750
services and you just add the

00:23:48,440 --> 00:23:56,179
credentials from another pre provisioned

00:23:50,750 --> 00:23:58,130
service in case that you want to use to

00:23:56,179 --> 00:24:01,820
start building a broker you can start up

00:23:58,130 --> 00:24:05,390
with a broker API which is available and

00:24:01,820 --> 00:24:07,460
open source to use and if you want it on

00:24:05,390 --> 00:24:09,760
demand you can start using the on-demand

00:24:07,460 --> 00:24:14,950
service broker

00:24:09,760 --> 00:24:14,950
and with that we can take any questions

00:24:24,440 --> 00:24:29,500
okay thank you thank you and thanks for

00:24:27,170 --> 00:24:29,500

YouTube URL: https://www.youtube.com/watch?v=qML4Z_9m0Us


