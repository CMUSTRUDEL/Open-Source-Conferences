Title: Carvel in Action with CF for K8s - Dr. Dave Walter, Vmware
Publication date: 2020-10-26
Playlist: Cloud Foundry Summit Europe 2020
Description: 
	Carvel in Action with CF for K8s - Dr. Dave Walter, Vmware

Integrating the myriad of YAML documents that make up the CF for K8s platform is no small task. Fortunately, we have the Carvel suite of tools (formerly known as K14s) in our toolbox. This talk explores the ways in which the CF Release Integration team have made use of vendir, ytt and kapp to pull together a variety of components. Attend this talk and learn how Carvel tools are used to:

* incorporate and extract subdirectories containing K8s templates from other repositories with vendir
* limit the blast radius of ytt overlays by using dynamic library loading
* define custom kapp change and wait rules to provide a better operator deployment experience
Captions: 
	00:00:00,080 --> 00:00:03,520
hello everyone and welcome to carville

00:00:02,080 --> 00:00:04,640
in action with cloud foundry for

00:00:03,520 --> 00:00:06,720
kubernetes

00:00:04,640 --> 00:00:08,639
my name is dave walter and i've been an

00:00:06,720 --> 00:00:11,040
engineer on the cf release integration

00:00:08,639 --> 00:00:12,880
team since march 2019

00:00:11,040 --> 00:00:14,880
we're responsible for releasing both

00:00:12,880 --> 00:00:17,440
cloud transfer kubernetes

00:00:14,880 --> 00:00:19,439
and cf deployment sometimes referred to

00:00:17,440 --> 00:00:22,240
as client translation vms or cloud

00:00:19,439 --> 00:00:22,240
foundry for bosch

00:00:22,320 --> 00:00:26,480
i feel i should start with a small

00:00:23,840 --> 00:00:28,240
disclaimer i have tried to severely

00:00:26,480 --> 00:00:30,720
limit the amount of on-screen examples

00:00:28,240 --> 00:00:32,480
of yammer configuration in this talk

00:00:30,720 --> 00:00:34,480
where it cannot be avoided i have

00:00:32,480 --> 00:00:36,480
included links to actual examples from

00:00:34,480 --> 00:00:38,160
cf for kate's in the slides

00:00:36,480 --> 00:00:40,559
so that you can review them later at

00:00:38,160 --> 00:00:41,920
your leisure

00:00:40,559 --> 00:00:43,440
pulling together all of the separate

00:00:41,920 --> 00:00:44,559
components that make up cloud foundry

00:00:43,440 --> 00:00:46,559
has never been a particularly

00:00:44,559 --> 00:00:48,640
straightforward task

00:00:46,559 --> 00:00:51,039
in the world of cf deployment we have

00:00:48,640 --> 00:00:52,559
bosch with the strict api boundaries

00:00:51,039 --> 00:00:54,559
and it's directed to orchestrate

00:00:52,559 --> 00:00:56,719
deployments

00:00:54,559 --> 00:00:58,320
now i know what you're going to say

00:00:56,719 --> 00:01:00,480
bosch is hard

00:00:58,320 --> 00:01:02,559
well as complicated as bosch is for many

00:01:00,480 --> 00:01:04,080
users it has clearly defined boundaries

00:01:02,559 --> 00:01:04,720
between component releases on the one

00:01:04,080 --> 00:01:06,960
hand

00:01:04,720 --> 00:01:08,560
and deployment manifests on the other

00:01:06,960 --> 00:01:10,080
the component releases are responsible

00:01:08,560 --> 00:01:11,680
for exposing a set of jobs

00:01:10,080 --> 00:01:12,960
that include specifications with

00:01:11,680 --> 00:01:14,080
well-defined lists and available

00:01:12,960 --> 00:01:16,000
properties

00:01:14,080 --> 00:01:17,200
the deployment manifests take care of

00:01:16,000 --> 00:01:18,960
among other things

00:01:17,200 --> 00:01:21,200
the user-defined configurations for

00:01:18,960 --> 00:01:22,720
those jobs

00:01:21,200 --> 00:01:24,560
turns out that bosch is hard for a

00:01:22,720 --> 00:01:26,320
reason issues like

00:01:24,560 --> 00:01:28,320
simple yet flexible configuration

00:01:26,320 --> 00:01:30,880
options and reliable one-step

00:01:28,320 --> 00:01:32,320
deployments are not easy to achieve

00:01:30,880 --> 00:01:33,920
so how do we solve these problems in

00:01:32,320 --> 00:01:35,439
this new world of kubernetes as an

00:01:33,920 --> 00:01:38,720
alternative to bosch

00:01:35,439 --> 00:01:40,079
fortunately we have cargo some of you

00:01:38,720 --> 00:01:41,680
might not have heard of carville and are

00:01:40,079 --> 00:01:43,600
wondering what it is

00:01:41,680 --> 00:01:44,799
carvel is a suite of tools designed to

00:01:43,600 --> 00:01:46,960
help users manage

00:01:44,799 --> 00:01:48,880
manipulate and deploy applications to

00:01:46,960 --> 00:01:50,479
kubernetes

00:01:48,880 --> 00:01:53,920
you may know them by their previous name

00:01:50,479 --> 00:01:55,680
of kubernetes tools or k-14s for short

00:01:53,920 --> 00:01:57,280
the tools in the carville suite

00:01:55,680 --> 00:01:59,040
have been designed to solve many of the

00:01:57,280 --> 00:02:02,479
same problems on kubernetes

00:01:59,040 --> 00:02:03,920
that bosch sorcerers on vms

00:02:02,479 --> 00:02:05,600
some of you might also be unaware of

00:02:03,920 --> 00:02:08,160
client trendy for kubernetes

00:02:05,600 --> 00:02:09,920
or cf for case for short this is a new

00:02:08,160 --> 00:02:11,680
version of cloud foundry designed to run

00:02:09,920 --> 00:02:13,920
application workloads natively

00:02:11,680 --> 00:02:15,520
on a kubernetes cluster whilst also

00:02:13,920 --> 00:02:16,720
running its control plane on the same

00:02:15,520 --> 00:02:18,640
cluster

00:02:16,720 --> 00:02:20,239
if you weren't able to catch it live

00:02:18,640 --> 00:02:21,120
make sure to watch the recording of paul

00:02:20,239 --> 00:02:23,440
warren's talk

00:02:21,120 --> 00:02:26,720
titled cf push comes to kubernetes

00:02:23,440 --> 00:02:28,239
introducing cfo case 1.0

00:02:26,720 --> 00:02:30,400
the three cardville tools i'm going to

00:02:28,239 --> 00:02:33,680
focus on today are vendor

00:02:30,400 --> 00:02:35,519
ytt and cap this talk will explore some

00:02:33,680 --> 00:02:36,879
of the more interesting and complicated

00:02:35,519 --> 00:02:39,599
features of these tools

00:02:36,879 --> 00:02:41,519
and how the cf release integration team

00:02:39,599 --> 00:02:45,040
has used them to create a holistic cloud

00:02:41,519 --> 00:02:46,959
foundry experience on kubernetes

00:02:45,040 --> 00:02:48,560
the first challenge is to package all of

00:02:46,959 --> 00:02:51,599
the cloud foundry components

00:02:48,560 --> 00:02:53,440
into a single cohesive project

00:02:51,599 --> 00:02:55,040
with bosch there is a well-defined set

00:02:53,440 --> 00:02:56,160
of abstractions in the form of job

00:02:55,040 --> 00:02:59,599
templates

00:02:56,160 --> 00:03:01,599
job specs releases to group related jobs

00:02:59,599 --> 00:03:02,720
and a central manifest to co-locate jobs

00:03:01,599 --> 00:03:06,159
into instance groups

00:03:02,720 --> 00:03:07,120
and provide configuration however

00:03:06,159 --> 00:03:09,680
things are very different with

00:03:07,120 --> 00:03:11,440
kubernetes there are several templating

00:03:09,680 --> 00:03:13,680
and packaging options available

00:03:11,440 --> 00:03:14,959
including helm customize and of course

00:03:13,680 --> 00:03:16,480
cover

00:03:14,959 --> 00:03:18,480
there are also options as to where to

00:03:16,480 --> 00:03:20,239
store the templates for a component

00:03:18,480 --> 00:03:21,920
some teams choose to keep them with the

00:03:20,239 --> 00:03:23,760
source code for the component

00:03:21,920 --> 00:03:25,680
whilst others prefer to use separate

00:03:23,760 --> 00:03:27,280
repositories

00:03:25,680 --> 00:03:29,440
while choice is generally a good thing

00:03:27,280 --> 00:03:33,920
it does lead to a variety of solutions

00:03:29,440 --> 00:03:35,840
which adds complexity enter vendor

00:03:33,920 --> 00:03:37,840
at its core vendor allows users to

00:03:35,840 --> 00:03:39,280
declaratively state how to extract

00:03:37,840 --> 00:03:41,200
directories or files

00:03:39,280 --> 00:03:42,319
from a given version of one or more

00:03:41,200 --> 00:03:44,319
repositories

00:03:42,319 --> 00:03:45,760
and where to store them in another you

00:03:44,319 --> 00:03:48,959
could think of it as a dependency

00:03:45,760 --> 00:03:50,480
management tool for configuration files

00:03:48,959 --> 00:03:52,720
in this example you can see how we

00:03:50,480 --> 00:03:54,879
extract a specific set of templates

00:03:52,720 --> 00:03:56,720
from the cf case repository network on

00:03:54,879 --> 00:03:58,480
lines 13 through 15

00:03:56,720 --> 00:04:00,000
and co-locate them all in the config

00:03:58,480 --> 00:04:04,000
directory in the cfo case

00:04:00,000 --> 00:04:05,760
repository specified on line 6.

00:04:04,000 --> 00:04:08,239
we see it for case this is only part of

00:04:05,760 --> 00:04:09,519
the story some components have chosen to

00:04:08,239 --> 00:04:13,280
provide helm charts

00:04:09,519 --> 00:04:16,000
whereas others went with ytt templates

00:04:13,280 --> 00:04:16,880
fortunately ytt supports plain yammer

00:04:16,000 --> 00:04:18,720
files

00:04:16,880 --> 00:04:20,560
and since users will be using ytt to

00:04:18,720 --> 00:04:22,240
configure safer case

00:04:20,560 --> 00:04:24,160
this means that all we need to do is

00:04:22,240 --> 00:04:26,479
pre-process each of the helm charts

00:04:24,160 --> 00:04:28,080
with a defined set of values and then we

00:04:26,479 --> 00:04:29,759
can combine the resulting yaml

00:04:28,080 --> 00:04:31,840
with the ytt templates for the rest of

00:04:29,759 --> 00:04:33,919
the components

00:04:31,840 --> 00:04:36,000
for example this is the script we use to

00:04:33,919 --> 00:04:37,440
process a miniature home chart

00:04:36,000 --> 00:04:40,479
in addition to applying the desired

00:04:37,440 --> 00:04:42,639
configuration we apply a ytt overlay

00:04:40,479 --> 00:04:44,240
to scrub a default set of credentials

00:04:42,639 --> 00:04:46,639
from the templated chart

00:04:44,240 --> 00:04:48,639
i'll talk more on what on ytt overlays

00:04:46,639 --> 00:04:49,840
later

00:04:48,639 --> 00:04:51,840
now that we've assembled all of the

00:04:49,840 --> 00:04:53,520
components that make up c for case

00:04:51,840 --> 00:04:56,479
the next step is to apply the user

00:04:53,520 --> 00:04:57,840
provided configuration

00:04:56,479 --> 00:05:00,160
this would normally be the job of the

00:04:57,840 --> 00:05:01,919
bosch manifest it allows users to

00:05:00,160 --> 00:05:02,880
control most basic aspects of their

00:05:01,919 --> 00:05:05,280
deployment

00:05:02,880 --> 00:05:06,320
including job-specific configuration and

00:05:05,280 --> 00:05:09,120
co-location

00:05:06,320 --> 00:05:11,039
into interest groups it also gives users

00:05:09,120 --> 00:05:12,240
the ability to modify manifest

00:05:11,039 --> 00:05:15,840
maintained by others

00:05:12,240 --> 00:05:17,440
by using ops files with kubernetes

00:05:15,840 --> 00:05:19,280
things are quite different

00:05:17,440 --> 00:05:20,639
vms and jobs have been replaced by parts

00:05:19,280 --> 00:05:21,840
and containers

00:05:20,639 --> 00:05:23,199
while this means that we don't have to

00:05:21,840 --> 00:05:25,280
concern ourselves as things like

00:05:23,199 --> 00:05:27,039
problems with job collocation

00:05:25,280 --> 00:05:28,400
we do still have to focus on how the

00:05:27,039 --> 00:05:30,400
components are combined

00:05:28,400 --> 00:05:32,240
into a cohesive set of deployment

00:05:30,400 --> 00:05:33,680
instructions

00:05:32,240 --> 00:05:36,400
sounds like a job for a templating

00:05:33,680 --> 00:05:37,280
engine ytt is a templating engine in

00:05:36,400 --> 00:05:39,280
carville

00:05:37,280 --> 00:05:41,680
and defines the configuration interface

00:05:39,280 --> 00:05:43,680
of cfocates

00:05:41,680 --> 00:05:46,160
users specify one or more yaml

00:05:43,680 --> 00:05:48,000
configuration files called data values

00:05:46,160 --> 00:05:50,479
and the combined set of component

00:05:48,000 --> 00:05:52,720
templates via command line options

00:05:50,479 --> 00:05:54,240
ytt uses the data values to evaluate

00:05:52,720 --> 00:05:56,720
variables in the templates

00:05:54,240 --> 00:05:59,199
and renders the resulting documents the

00:05:56,720 --> 00:06:00,720
entire set of data values properties

00:05:59,199 --> 00:06:02,319
that make up the configuration

00:06:00,720 --> 00:06:04,240
configuration interface

00:06:02,319 --> 00:06:06,800
is defined in a set of files in the

00:06:04,240 --> 00:06:08,400
cf4case repository

00:06:06,800 --> 00:06:09,840
ideally all components would use the

00:06:08,400 --> 00:06:11,840
same templating language

00:06:09,840 --> 00:06:13,680
allowing us to easily present a unified

00:06:11,840 --> 00:06:15,919
interface to the user

00:06:13,680 --> 00:06:17,360
however the choices i mentioned earlier

00:06:15,919 --> 00:06:19,199
lead to a variety of

00:06:17,360 --> 00:06:20,639
implementations which in turn leads to

00:06:19,199 --> 00:06:21,600
complexity in hiding those

00:06:20,639 --> 00:06:24,800
implementations

00:06:21,600 --> 00:06:26,720
behind the desired user interface

00:06:24,800 --> 00:06:28,479
for the plane yaml documents generated

00:06:26,720 --> 00:06:31,120
from the pre-processed hem charts

00:06:28,479 --> 00:06:31,600
and for configuration not exposed by ytt

00:06:31,120 --> 00:06:34,000
templates

00:06:31,600 --> 00:06:35,600
via their data values interface we have

00:06:34,000 --> 00:06:37,759
to use ytt overlays

00:06:35,600 --> 00:06:39,199
to apply changes as specified by the

00:06:37,759 --> 00:06:42,639
configuration choices

00:06:39,199 --> 00:06:43,759
made by the user ytt overlays are like

00:06:42,639 --> 00:06:46,080
bar shops files

00:06:43,759 --> 00:06:46,960
with similar actions to add new settings

00:06:46,080 --> 00:06:49,759
update

00:06:46,960 --> 00:06:52,800
existing ones and remove them if desired

00:06:49,759 --> 00:06:54,800
you can also append to arrays and so on

00:06:52,800 --> 00:06:56,319
however the inside entire set of

00:06:54,800 --> 00:06:58,160
kubernetes documents

00:06:56,319 --> 00:07:00,840
is available for modification by the

00:06:58,160 --> 00:07:02,720
user and this can make them much more

00:07:00,840 --> 00:07:05,599
dangerous

00:07:02,720 --> 00:07:07,120
by default ytt recursively traverses all

00:07:05,599 --> 00:07:09,680
configuration directories

00:07:07,120 --> 00:07:11,440
specified on the command line first it

00:07:09,680 --> 00:07:13,520
separates the documents in the provided

00:07:11,440 --> 00:07:17,199
input parameters based on that type

00:07:13,520 --> 00:07:19,280
data values overlays and templates

00:07:17,199 --> 00:07:21,280
it then merges all the data values

00:07:19,280 --> 00:07:23,360
together to form a single master set of

00:07:21,280 --> 00:07:25,440
values

00:07:23,360 --> 00:07:27,440
next it evaluates all the overlays and

00:07:25,440 --> 00:07:29,360
templates using that master set of

00:07:27,440 --> 00:07:31,280
values

00:07:29,360 --> 00:07:32,479
finally it applies the overlays to all

00:07:31,280 --> 00:07:34,240
of the templates

00:07:32,479 --> 00:07:36,560
and renders the results to produce the

00:07:34,240 --> 00:07:38,319
final set of documents

00:07:36,560 --> 00:07:40,400
this can lead to problems if overlays

00:07:38,319 --> 00:07:42,880
are not carefully written to only target

00:07:40,400 --> 00:07:44,479
the desired kubernetes resources as

00:07:42,880 --> 00:07:47,120
overlays from one directory

00:07:44,479 --> 00:07:50,160
can modify resources defined in a file

00:07:47,120 --> 00:07:50,160
in another directory

00:07:50,240 --> 00:07:53,919
to help with this ytt provides a

00:07:52,240 --> 00:07:55,599
mechanism for loading templates from

00:07:53,919 --> 00:07:58,639
specific specially named

00:07:55,599 --> 00:08:01,360
ytt lib directories these label these

00:07:58,639 --> 00:08:03,280
libraries are ignored by ytt by default

00:08:01,360 --> 00:08:06,080
and are instead available to be loaded

00:08:03,280 --> 00:08:07,759
on demand via its library module

00:08:06,080 --> 00:08:09,680
this allows projects such as save for

00:08:07,759 --> 00:08:11,199
case to isolate the process of loading a

00:08:09,680 --> 00:08:13,520
component's templates

00:08:11,199 --> 00:08:14,960
rendering them with targeted data values

00:08:13,520 --> 00:08:16,800
apply overlays to them

00:08:14,960 --> 00:08:18,720
and convert them back into a set of yaml

00:08:16,800 --> 00:08:20,400
documents that are not only ready for

00:08:18,720 --> 00:08:22,240
inclusion in the parent project

00:08:20,400 --> 00:08:24,800
but are also still available for further

00:08:22,240 --> 00:08:26,560
manipulation by more overlays

00:08:24,800 --> 00:08:28,319
component teams can concentrate on

00:08:26,560 --> 00:08:30,000
writing templates for their needs

00:08:28,319 --> 00:08:31,759
without having to be concerned about the

00:08:30,000 --> 00:08:32,719
effect that overlays might have on other

00:08:31,759 --> 00:08:34,399
components

00:08:32,719 --> 00:08:36,399
being combined with theirs in downstream

00:08:34,399 --> 00:08:37,839
projects

00:08:36,399 --> 00:08:39,599
here are two examples of this pattern

00:08:37,839 --> 00:08:41,440
from cfocates

00:08:39,599 --> 00:08:42,880
the first example shows how the capy

00:08:41,440 --> 00:08:45,519
templates are loaded

00:08:42,880 --> 00:08:47,200
with a specified set of data values that

00:08:45,519 --> 00:08:49,360
allows us to pass some values

00:08:47,200 --> 00:08:51,040
from the user through we could also

00:08:49,360 --> 00:08:52,320
choose to hard code other values that we

00:08:51,040 --> 00:08:55,760
decided not experts

00:08:52,320 --> 00:08:56,399
exposed to the user the key steps here

00:08:55,760 --> 00:08:58,480
are

00:08:56,399 --> 00:09:00,640
the library get call on line 9 which

00:08:58,480 --> 00:09:01,680
loads the copy case release library into

00:09:00,640 --> 00:09:04,080
memory

00:09:01,680 --> 00:09:05,920
the with data values call on line 10

00:09:04,080 --> 00:09:07,120
which takes the output from the copy

00:09:05,920 --> 00:09:08,959
values function

00:09:07,120 --> 00:09:10,160
and uses it to evaluate the loaded

00:09:08,959 --> 00:09:13,200
templates

00:09:10,160 --> 00:09:13,680
the eval call also on line 10 that turns

00:09:13,200 --> 00:09:16,560
the

00:09:13,680 --> 00:09:18,640
evaluated templates back into yaml and

00:09:16,560 --> 00:09:19,839
finally the template replace called the

00:09:18,640 --> 00:09:21,440
beginning of the line

00:09:19,839 --> 00:09:26,080
which replace the placeholder yaml

00:09:21,440 --> 00:09:27,839
document with the entire set of yaml

00:09:26,080 --> 00:09:29,680
the second slightly different example

00:09:27,839 --> 00:09:30,720
shows how the rendered mineo helm chart

00:09:29,680 --> 00:09:32,959
is modified

00:09:30,720 --> 00:09:34,640
with an overlay before being combined

00:09:32,959 --> 00:09:36,240
with the rest of the templates

00:09:34,640 --> 00:09:38,560
the key difference here compared to the

00:09:36,240 --> 00:09:40,480
first example is the use of the overlay

00:09:38,560 --> 00:09:42,880
apply call on line 12

00:09:40,480 --> 00:09:45,200
to apply the overlay defined by the add

00:09:42,880 --> 00:09:48,000
cf blobstore namespace function

00:09:45,200 --> 00:09:48,480
to the menu templates note that overlay

00:09:48,000 --> 00:09:50,959
apply

00:09:48,480 --> 00:09:52,560
acts on the set of yaml documents not

00:09:50,959 --> 00:09:55,920
the in-memory representation of them

00:09:52,560 --> 00:09:59,200
that library.getreturns

00:09:55,920 --> 00:10:00,240
as a side note ytt is an extremely

00:09:59,200 --> 00:10:02,640
useful tool

00:10:00,240 --> 00:10:03,519
that can be used for manipulating yaml

00:10:02,640 --> 00:10:07,040
outside

00:10:03,519 --> 00:10:08,800
of manipulating kubernetes documents

00:10:07,040 --> 00:10:10,399
for example we also use it to render

00:10:08,800 --> 00:10:11,279
some of our more repetitive concourse

00:10:10,399 --> 00:10:12,880
pipelines

00:10:11,279 --> 00:10:16,880
that help manage component bumps for

00:10:12,880 --> 00:10:16,880
both cf deployment and cfo gates

00:10:17,120 --> 00:10:20,720
now that we've applied the user provided

00:10:18,720 --> 00:10:22,640
configuration to our templates

00:10:20,720 --> 00:10:24,880
and generated a set of kubernetes

00:10:22,640 --> 00:10:26,560
documents the last step is to deploy

00:10:24,880 --> 00:10:28,079
everything and get cloud foundry up and

00:10:26,560 --> 00:10:29,360
running

00:10:28,079 --> 00:10:31,279
historically that has meant running

00:10:29,360 --> 00:10:32,959
bosch deploy and taking a table tennis

00:10:31,279 --> 00:10:34,240
break safe in the knowledge

00:10:32,959 --> 00:10:36,399
that bosch would take care of the

00:10:34,240 --> 00:10:38,240
complexities of creating the vms

00:10:36,399 --> 00:10:39,839
rendering the job templates onto them

00:10:38,240 --> 00:10:41,360
and ensuring that

00:10:39,839 --> 00:10:42,880
ensuring that everything has started

00:10:41,360 --> 00:10:44,720
correctly

00:10:42,880 --> 00:10:47,600
while things are faster with kubernetes

00:10:44,720 --> 00:10:49,120
they're not necessarily easier

00:10:47,600 --> 00:10:50,480
when deploying an application such as

00:10:49,120 --> 00:10:51,839
cloud friendly to a cluster using

00:10:50,480 --> 00:10:54,720
kubectl

00:10:51,839 --> 00:10:55,680
some resources crds namespaces webhooks

00:10:54,720 --> 00:10:57,519
and so on

00:10:55,680 --> 00:10:59,760
need to be created and ready before

00:10:57,519 --> 00:11:01,519
other resources can be applied

00:10:59,760 --> 00:11:02,800
even then sending everything to the

00:11:01,519 --> 00:11:04,240
cluster and waiting for

00:11:02,800 --> 00:11:06,320
for it all to eventually become

00:11:04,240 --> 00:11:08,079
consistent can be confusing

00:11:06,320 --> 00:11:09,920
as you watch resources fail until their

00:11:08,079 --> 00:11:12,959
dependencies are ready and wonder if

00:11:09,920 --> 00:11:15,519
everything is deploying successfully

00:11:12,959 --> 00:11:17,120
once again carhartt comes to the rescue

00:11:15,519 --> 00:11:18,800
this time we have cap to handle the

00:11:17,120 --> 00:11:20,320
orchestration for us

00:11:18,800 --> 00:11:21,760
this means that it will automatically

00:11:20,320 --> 00:11:22,959
apply the resources that need to be

00:11:21,760 --> 00:11:24,720
created first

00:11:22,959 --> 00:11:26,959
wait for them to be ready and then

00:11:24,720 --> 00:11:29,040
proceed to apply other resources

00:11:26,959 --> 00:11:30,000
this cycle can be repeated as many times

00:11:29,040 --> 00:11:31,920
as is required

00:11:30,000 --> 00:11:33,519
to successfully deploy everything

00:11:31,920 --> 00:11:35,440
without requiring the user to issue

00:11:33,519 --> 00:11:37,040
multiple commands

00:11:35,440 --> 00:11:39,519
while the common use cases are taken

00:11:37,040 --> 00:11:41,200
care of by caps built-in rules

00:11:39,519 --> 00:11:42,480
we sometimes need to teach it how to

00:11:41,200 --> 00:11:45,040
manage the deployment of custom

00:11:42,480 --> 00:11:47,519
resources correctly

00:11:45,040 --> 00:11:48,880
most cap configuration is applied via

00:11:47,519 --> 00:11:51,040
metadata annotations

00:11:48,880 --> 00:11:52,240
which are defined as pairs of key value

00:11:51,040 --> 00:11:53,839
data

00:11:52,240 --> 00:11:57,320
the key consists of three separate

00:11:53,839 --> 00:11:59,839
sections the prefix which is always

00:11:57,320 --> 00:12:02,160
cap.k14s.io the rule name

00:11:59,839 --> 00:12:03,680
and a unique identifier while the

00:12:02,160 --> 00:12:04,480
identifier is not required it is

00:12:03,680 --> 00:12:06,320
recommended

00:12:04,480 --> 00:12:08,480
to avoid issues with colliding

00:12:06,320 --> 00:12:10,320
annotations

00:12:08,480 --> 00:12:11,920
the first adjustment we can make

00:12:10,320 --> 00:12:13,600
involves using change groups

00:12:11,920 --> 00:12:15,600
and change rules to control the

00:12:13,600 --> 00:12:17,440
deployment of dependent resources

00:12:15,600 --> 00:12:18,720
where one will not start before another

00:12:17,440 --> 00:12:20,480
is ready

00:12:18,720 --> 00:12:22,480
kubernetes does handle this natively

00:12:20,480 --> 00:12:23,839
with its eventual consistency approach

00:12:22,480 --> 00:12:25,519
but this can lead to potentially

00:12:23,839 --> 00:12:27,200
confusing error messages

00:12:25,519 --> 00:12:28,800
and crash-loop back-offs that cause the

00:12:27,200 --> 00:12:29,920
deployment to take longer than it really

00:12:28,800 --> 00:12:32,160
needs to

00:12:29,920 --> 00:12:34,160
to avoid these issues we can put a set

00:12:32,160 --> 00:12:35,839
of resources into a change group

00:12:34,160 --> 00:12:38,560
and apply change rules to dependent

00:12:35,839 --> 00:12:40,240
resources to cap to wait until the first

00:12:38,560 --> 00:12:43,279
set of resources are ready

00:12:40,240 --> 00:12:44,639
before applying the dependent resources

00:12:43,279 --> 00:12:46,880
waiting to apply a given set of

00:12:44,639 --> 00:12:49,120
resources helps eliminate error messages

00:12:46,880 --> 00:12:50,880
since they can start first time and also

00:12:49,120 --> 00:12:52,720
can result in a faster overall

00:12:50,880 --> 00:12:55,279
deployment

00:12:52,720 --> 00:12:57,040
as this example from the cap docks show

00:12:55,279 --> 00:13:00,880
these rules can be combined on the same

00:12:57,040 --> 00:13:00,880
resource for more fine grained control

00:13:01,040 --> 00:13:04,320
the second adjustment involves versioned

00:13:03,040 --> 00:13:06,160
resources

00:13:04,320 --> 00:13:08,160
this technique is most commonly applied

00:13:06,160 --> 00:13:09,760
to kubernetes configuration resources

00:13:08,160 --> 00:13:12,560
consisting of config max

00:13:09,760 --> 00:13:14,480
and secrets it is intended to solve the

00:13:12,560 --> 00:13:15,279
problem of resources not updating their

00:13:14,480 --> 00:13:17,279
internal

00:13:15,279 --> 00:13:19,680
configuration when a value in a

00:13:17,279 --> 00:13:21,760
configuration resource is modified

00:13:19,680 --> 00:13:23,920
it works by appending a numeric version

00:13:21,760 --> 00:13:26,880
to the configuration resource name

00:13:23,920 --> 00:13:28,720
which is incremented on every deployment

00:13:26,880 --> 00:13:31,279
references to the configuration resource

00:13:28,720 --> 00:13:32,880
name in other resources are also updated

00:13:31,279 --> 00:13:34,720
which forces those resources to be

00:13:32,880 --> 00:13:36,639
recreated with the new configuration

00:13:34,720 --> 00:13:38,399
resource mounted

00:13:36,639 --> 00:13:40,399
you can use custom template roles to

00:13:38,399 --> 00:13:41,360
teach cap about configuration resource

00:13:40,399 --> 00:13:43,680
name references

00:13:41,360 --> 00:13:45,360
that it does not know about by default

00:13:43,680 --> 00:13:46,000
to ensure that they're kept in sync with

00:13:45,360 --> 00:13:49,600
the name

00:13:46,000 --> 00:13:51,279
of the configuration resource itself

00:13:49,600 --> 00:13:53,680
the last adjustment involves using

00:13:51,279 --> 00:13:56,880
custom weight rules to tell cap

00:13:53,680 --> 00:13:58,560
how to tell if a component is ready

00:13:56,880 --> 00:14:00,480
making cap wait until the resource is

00:13:58,560 --> 00:14:03,440
actually ready is actually

00:14:00,480 --> 00:14:04,560
helpful for two reasons if the resource

00:14:03,440 --> 00:14:06,560
has dependencies

00:14:04,560 --> 00:14:07,839
we do not want cap to attempt to create

00:14:06,560 --> 00:14:10,160
them too early

00:14:07,839 --> 00:14:11,360
and even if it doesn't waiting until all

00:14:10,160 --> 00:14:12,639
resources are ready

00:14:11,360 --> 00:14:14,839
gives users confidence that the

00:14:12,639 --> 00:14:16,079
deployment is complete when capp says it

00:14:14,839 --> 00:14:17,600
is

00:14:16,079 --> 00:14:20,000
it's worth noting that you do need to

00:14:17,600 --> 00:14:22,399
set up appropriate readiness probes

00:14:20,000 --> 00:14:23,760
for your resources in addition to this

00:14:22,399 --> 00:14:24,959
being a best practice when working with

00:14:23,760 --> 00:14:26,959
kubernetes

00:14:24,959 --> 00:14:28,399
cap relies on the ready condition to

00:14:26,959 --> 00:14:29,680
tell it when each resource has finished

00:14:28,399 --> 00:14:31,600
deploying

00:14:29,680 --> 00:14:33,279
for example you probably want the

00:14:31,600 --> 00:14:35,199
readiness probe for a web server

00:14:33,279 --> 00:14:37,519
to actually send a request and confirm

00:14:35,199 --> 00:14:38,800
that it receives a successful response

00:14:37,519 --> 00:14:40,240
rather than simply checking that the

00:14:38,800 --> 00:14:42,800
server is listening on the appropriate

00:14:40,240 --> 00:14:44,880
tcp port

00:14:42,800 --> 00:14:46,240
weight rules also offer the benefit of a

00:14:44,880 --> 00:14:48,480
faster deployment feedback

00:14:46,240 --> 00:14:49,680
cycle as long as the resource is only

00:14:48,480 --> 00:14:52,720
marked as

00:14:49,680 --> 00:14:54,959
ready false when it hits a non-retriable

00:14:52,720 --> 00:14:58,000
error

00:14:54,959 --> 00:14:59,760
all of these custom configuration

00:14:58,000 --> 00:15:01,040
allow us to keep the user experience as

00:14:59,760 --> 00:15:03,519
simple as possible

00:15:01,040 --> 00:15:04,800
to deploy all they need is a single cap

00:15:03,519 --> 00:15:06,959
command

00:15:04,800 --> 00:15:08,320
after after just a few short minutes

00:15:06,959 --> 00:15:09,519
they have a fully functional cloud

00:15:08,320 --> 00:15:10,480
foundry installation running on

00:15:09,519 --> 00:15:12,320
kubernetes

00:15:10,480 --> 00:15:14,560
ready to accept applications pushed to

00:15:12,320 --> 00:15:16,240
the platform

00:15:14,560 --> 00:15:18,320
that wraps up my look at three extremely

00:15:16,240 --> 00:15:21,600
useful tools from the carville suite

00:15:18,320 --> 00:15:23,440
vendor ytt and cap for those of you who

00:15:21,600 --> 00:15:24,959
are new to the carvel suite of tools

00:15:23,440 --> 00:15:27,040
i hope you have found this introduction

00:15:24,959 --> 00:15:29,040
informative for those of you who have

00:15:27,040 --> 00:15:30,959
started using some of the tools already

00:15:29,040 --> 00:15:32,639
i hope this has been helpful to show you

00:15:30,959 --> 00:15:34,160
new ways to make them even more

00:15:32,639 --> 00:15:35,040
effective in allowing you to bridge the

00:15:34,160 --> 00:15:37,920
gap between the

00:15:35,040 --> 00:15:39,279
worlds of bosch and kubernetes my thanks

00:15:37,920 --> 00:15:40,720
go to the carville team for creating

00:15:39,279 --> 00:15:41,600
such a powerful and useful suite of

00:15:40,720 --> 00:15:43,680
tools

00:15:41,600 --> 00:15:45,279
and the current and former members of

00:15:43,680 --> 00:15:46,720
the cf release integration team that i

00:15:45,279 --> 00:15:51,440
had the pleasure of working with

00:15:46,720 --> 00:15:53,680
over the past couple of years thank you

00:15:51,440 --> 00:15:56,720
hi everyone hopefully you can hear me

00:15:53,680 --> 00:15:59,920
okay um hopefully that talk was

00:15:56,720 --> 00:16:02,959
informative uh gave you

00:15:59,920 --> 00:16:05,759
some an introduction into

00:16:02,959 --> 00:16:07,040
uh deploying cloud foundry on kubernetes

00:16:05,759 --> 00:16:11,120
and the tooling we're using

00:16:07,040 --> 00:16:12,320
for the configuration and deployment

00:16:11,120 --> 00:16:14,880
if you have any questions i'd be happy

00:16:12,320 --> 00:16:15,199
to take them now or you can always reach

00:16:14,880 --> 00:16:17,199
out

00:16:15,199 --> 00:16:18,720
in slack in the cf for kate's channel

00:16:17,199 --> 00:16:20,000
the team's always happy to answer

00:16:18,720 --> 00:16:21,440
questions or help with any problems

00:16:20,000 --> 00:16:24,800
people may have

00:16:21,440 --> 00:16:28,079
um definitely excited now we've gone

00:16:24,800 --> 00:16:30,720
1.0 we released that yesterday

00:16:28,079 --> 00:16:33,120
um very excited for people to start

00:16:30,720 --> 00:16:36,000
trying out the platform on kubernetes

00:16:33,120 --> 00:16:38,800
giving us their feedback and keep

00:16:36,000 --> 00:16:42,079
working towards a great

00:16:38,800 --> 00:16:42,079
cloud foundry experience on top of

00:16:48,839 --> 00:16:51,839
kubernetes

00:17:17,839 --> 00:17:19,919
you

00:18:41,600 --> 00:18:45,039
we have a question

00:18:46,720 --> 00:18:50,640
okay uh andrew trucks asking what is the

00:18:49,120 --> 00:18:51,600
best way to start using the carville

00:18:50,640 --> 00:18:55,919
tools

00:18:51,600 --> 00:18:59,440
um so you can go to

00:18:55,919 --> 00:19:02,000
carvel.dev to get started and download

00:18:59,440 --> 00:19:02,000
the tools

00:19:02,240 --> 00:19:09,360
each of them is targeted at a different

00:19:05,600 --> 00:19:11,919
use case they've taken the unix tool

00:19:09,360 --> 00:19:15,280
approach of small sharp tools that

00:19:11,919 --> 00:19:15,280
solve a particular problem

00:19:16,080 --> 00:19:19,760
depending on on your needs

00:19:19,919 --> 00:19:25,840
different tools will will fit in

00:19:23,360 --> 00:19:26,799
so for example if you are manipulating

00:19:25,840 --> 00:19:30,320
yaml

00:19:26,799 --> 00:19:33,440
whether it be a concourse pipeline um

00:19:30,320 --> 00:19:36,960
case uh deployment document even

00:19:33,440 --> 00:19:40,480
a bosch manifest you can use ytt to

00:19:36,960 --> 00:19:43,120
help manage that it's very powerful

00:19:40,480 --> 00:19:44,720
at pulling fragments together to form

00:19:43,120 --> 00:19:48,880
larger documents

00:19:44,720 --> 00:19:50,480
or as i showed with the example with

00:19:48,880 --> 00:19:53,679
conquest pipelines

00:19:50,480 --> 00:19:56,000
if you have a very repetitive pipeline

00:19:53,679 --> 00:19:57,840
you can use an input file and iterate

00:19:56,000 --> 00:20:02,240
over the contents there to

00:19:57,840 --> 00:20:05,360
kind of stamp out jobs that are

00:20:02,240 --> 00:20:08,640
very similar in nature white

00:20:05,360 --> 00:20:09,280
uh vendor is an extremely useful tool

00:20:08,640 --> 00:20:12,799
for

00:20:09,280 --> 00:20:15,280
aggregating um repository code from

00:20:12,799 --> 00:20:19,039
repositories together into a larger

00:20:15,280 --> 00:20:22,400
uh cohesive bundle um

00:20:19,039 --> 00:20:24,159
so for example you can you uh it's a

00:20:22,400 --> 00:20:26,400
kind of like a get some module you can

00:20:24,159 --> 00:20:30,640
pull in pieces as needed

00:20:26,400 --> 00:20:30,640
um and

00:20:31,200 --> 00:20:36,400
then obviously if um

00:20:34,880 --> 00:20:38,559
if you're deploying on kubernetes and

00:20:36,400 --> 00:20:41,280
cap i think is a

00:20:38,559 --> 00:20:43,840
a great replacement for the bosch

00:20:41,280 --> 00:20:47,200
deployment process where

00:20:43,840 --> 00:20:49,679
it gives you that real-time status of

00:20:47,200 --> 00:20:50,320
how everything is being applied to the

00:20:49,679 --> 00:20:53,360
cluster

00:20:50,320 --> 00:20:56,240
and the health of of the deployment

00:20:53,360 --> 00:20:56,640
as it's progressing that you don't get

00:20:56,240 --> 00:21:03,840
with

00:20:56,640 --> 00:21:03,840
coupe ctl

00:21:13,520 --> 00:21:16,720
does anyone have any other questions i

00:21:15,200 --> 00:21:19,600
know we are

00:21:16,720 --> 00:21:21,360
we started a little late but we are um

00:21:19,600 --> 00:21:24,080
over time so i don't want to

00:21:21,360 --> 00:21:25,440
stop you from going to other talks if

00:21:24,080 --> 00:21:29,200
there are any

00:21:25,440 --> 00:21:33,120
um as i said earlier happy to

00:21:29,200 --> 00:21:35,360
keep answering questions in slack

00:21:33,120 --> 00:21:37,760
if people have anything they can jump in

00:21:35,360 --> 00:21:39,360
there and

00:21:37,760 --> 00:21:41,840
will be available for the rest of the

00:21:39,360 --> 00:21:44,880
day obviously being

00:21:41,840 --> 00:21:46,400
on the west coast of the us

00:21:44,880 --> 00:21:49,280
you'll be available through into the

00:21:46,400 --> 00:21:51,280
evening in in europe so

00:21:49,280 --> 00:21:59,840
any questions that you may have please

00:21:51,280 --> 00:21:59,840
jump in and ask them there

00:22:04,960 --> 00:22:09,280
okay there's nothing else i'm good to

00:22:07,679 --> 00:22:11,600
stop broadcasting now but

00:22:09,280 --> 00:22:13,039
thank you all for attending hopefully it

00:22:11,600 --> 00:22:15,760
was

00:22:13,039 --> 00:22:16,159
uh you all got something out of the talk

00:22:15,760 --> 00:22:21,360
and

00:22:16,159 --> 00:22:21,360

YouTube URL: https://www.youtube.com/watch?v=pQOnEEoFPXM


