Title: Service Broker Integration with Kubernetes Operators - Julian Fischer, anynines GmbH
Publication date: 2020-10-26
Playlist: Cloud Foundry Summit Europe 2020
Description: 
	Service Broker Integration with Kubernetes Operators - Julian Fischer, anynines GmbH

Cloud Foundry can be run on top of or alongside Kubernetes. Simultaneously, Kubernetes becomes more popular for automating data services and in particular the operator pattern is applied frequently. In this talk you will get a brief introduction into the operator pattern and how it works. Furthermore, it will be discussed how operators can be integrated with Cloud Foundry using Service Brokers. After this talk you will have a conceptual understanding of operators and how they might fit into your Cloud Foundry marketplace.
Captions: 
	00:00:00,080 --> 00:00:04,880
hello and welcome to this talk about

00:00:02,879 --> 00:00:08,720
service broker integration

00:00:04,880 --> 00:00:11,200
with kubernetes operators a few words

00:00:08,720 --> 00:00:14,719
about myself i'm julian fisher

00:00:11,200 --> 00:00:17,279
ceo of a company called any nines and

00:00:14,719 --> 00:00:19,199
our mission is to create application

00:00:17,279 --> 00:00:21,600
developer platforms so whether this is

00:00:19,199 --> 00:00:24,800
with kubernetes or cloud foundry

00:00:21,600 --> 00:00:27,920
uh whether it's about planning design

00:00:24,800 --> 00:00:31,199
or operating it uh that's what we do

00:00:27,920 --> 00:00:34,559
we want to think about how

00:00:31,199 --> 00:00:37,520
service brokers can integrate

00:00:34,559 --> 00:00:38,879
kubernetes operators so first of all a

00:00:37,520 --> 00:00:42,239
little bit of context

00:00:38,879 --> 00:00:44,160
we've been researching and developing

00:00:42,239 --> 00:00:45,760
and implementing automation for data

00:00:44,160 --> 00:00:48,960
services

00:00:45,760 --> 00:00:51,840
for more than six years now and

00:00:48,960 --> 00:00:53,120
the major paradigm in data service

00:00:51,840 --> 00:00:56,399
automation these days

00:00:53,120 --> 00:00:59,440
is the on-demand provisioning of

00:00:56,399 --> 00:00:59,920
dedicated data services the main point

00:00:59,440 --> 00:01:01,760
is

00:00:59,920 --> 00:01:03,280
that the on-demand provisioning of

00:01:01,760 --> 00:01:06,720
dedicated instances

00:01:03,280 --> 00:01:09,200
is the leading paradigm here this is in

00:01:06,720 --> 00:01:11,280
contrast to for example shared databases

00:01:09,200 --> 00:01:13,439
where you have a postgres

00:01:11,280 --> 00:01:14,640
server for example and carve it up into

00:01:13,439 --> 00:01:17,759
particular

00:01:14,640 --> 00:01:19,520
or into separate data service instances

00:01:17,759 --> 00:01:20,960
using databases

00:01:19,520 --> 00:01:23,520
in the case of the on demand

00:01:20,960 --> 00:01:26,159
provisioning you would be using

00:01:23,520 --> 00:01:27,360
dedicated pods or dedicated virtual

00:01:26,159 --> 00:01:30,240
machines to represent

00:01:27,360 --> 00:01:30,960
your service instances or even clusters

00:01:30,240 --> 00:01:33,759
of

00:01:30,960 --> 00:01:34,560
vms or parts so you have a service

00:01:33,759 --> 00:01:36,479
broker

00:01:34,560 --> 00:01:38,880
you trigger automation you create a

00:01:36,479 --> 00:01:41,360
dedicated vm dedicated port

00:01:38,880 --> 00:01:42,479
or a group of dedicated vms group of

00:01:41,360 --> 00:01:45,200
dedicated parts

00:01:42,479 --> 00:01:47,280
comprising a clustered instance in the

00:01:45,200 --> 00:01:49,840
second case

00:01:47,280 --> 00:01:51,280
so the first idea you may have is is

00:01:49,840 --> 00:01:54,240
there a way

00:01:51,280 --> 00:01:54,960
to have or implement a generic service

00:01:54,240 --> 00:01:58,240
broker

00:01:54,960 --> 00:02:00,159
that implements arbitrary um

00:01:58,240 --> 00:02:02,719
operators or integrates arbitrary

00:02:00,159 --> 00:02:05,680
operators to be more precise

00:02:02,719 --> 00:02:06,960
and i personally think that this is

00:02:05,680 --> 00:02:10,160
possible

00:02:06,960 --> 00:02:11,120
um but it may be challenging and we are

00:02:10,160 --> 00:02:13,920
going into

00:02:11,120 --> 00:02:15,440
the question how generic can or should

00:02:13,920 --> 00:02:19,760
the service broker be

00:02:15,440 --> 00:02:22,800
into before we do that i'm not sure

00:02:19,760 --> 00:02:25,920
who of you have been

00:02:22,800 --> 00:02:28,080
familiar with the components such

00:02:25,920 --> 00:02:29,840
a service broker will have to

00:02:28,080 --> 00:02:31,440
orchestrate and check out and therefore

00:02:29,840 --> 00:02:34,319
we'll spend a few minutes on the

00:02:31,440 --> 00:02:37,840
building blocks and presenting them

00:02:34,319 --> 00:02:40,720
so obviously if you use cloud foundry

00:02:37,840 --> 00:02:42,480
you're very likely to be familiar with

00:02:40,720 --> 00:02:45,599
the service marketplace where you do

00:02:42,480 --> 00:02:48,080
cf marketplace and you get a list of

00:02:45,599 --> 00:02:49,120
all the services offered on your cloud

00:02:48,080 --> 00:02:52,400
foundry

00:02:49,120 --> 00:02:55,440
platform now this marketplace basically

00:02:52,400 --> 00:02:58,400
is um generated by

00:02:55,440 --> 00:02:59,920
the cloud controller of cloud foundry

00:02:58,400 --> 00:03:02,560
where the service brokers

00:02:59,920 --> 00:03:03,440
are registered and by retrieving

00:03:02,560 --> 00:03:06,640
information

00:03:03,440 --> 00:03:07,519
from the service brokers via the catalog

00:03:06,640 --> 00:03:09,760
function

00:03:07,519 --> 00:03:12,239
the cloud controller knows which service

00:03:09,760 --> 00:03:17,360
endpoints these service brokers offer

00:03:12,239 --> 00:03:20,959
and enable the cloud phone marketplace

00:03:17,360 --> 00:03:23,120
listing so the main point here is that

00:03:20,959 --> 00:03:23,519
each service broker needs to implement

00:03:23,120 --> 00:03:27,040
the

00:03:23,519 --> 00:03:29,440
open service broker api the

00:03:27,040 --> 00:03:30,879
main terminology introduced by the

00:03:29,440 --> 00:03:34,720
service broker api

00:03:30,879 --> 00:03:37,920
is a service plan a service instance

00:03:34,720 --> 00:03:40,080
and a service binding

00:03:37,920 --> 00:03:42,080
the open service broker api is fairly

00:03:40,080 --> 00:03:46,319
simple it has some methods

00:03:42,080 --> 00:03:48,799
rest endpoints to retrieve the metadata

00:03:46,319 --> 00:03:49,840
as the service catalog create service

00:03:48,799 --> 00:03:52,480
instance

00:03:49,840 --> 00:03:54,720
and create delete bindings as well as

00:03:52,480 --> 00:03:58,319
delete them

00:03:54,720 --> 00:04:00,480
so so much about the service broker

00:03:58,319 --> 00:04:02,560
so it's worth having a look into

00:04:00,480 --> 00:04:05,040
kubernetes operators

00:04:02,560 --> 00:04:06,480
the operator sdk has been around for a

00:04:05,040 --> 00:04:08,640
while for those who are

00:04:06,480 --> 00:04:09,760
not familiar with it it's basically a

00:04:08,640 --> 00:04:13,040
set of tools

00:04:09,760 --> 00:04:16,479
that makes it easier to create um

00:04:13,040 --> 00:04:19,040
other constructs that are

00:04:16,479 --> 00:04:20,320
kubernetes abilities to extend

00:04:19,040 --> 00:04:22,400
kubernetes

00:04:20,320 --> 00:04:23,600
and one of these constructs the operator

00:04:22,400 --> 00:04:26,840
sdk sdk

00:04:23,600 --> 00:04:28,080
facilitates is custom resource

00:04:26,840 --> 00:04:31,360
definitions

00:04:28,080 --> 00:04:35,199
custom resource definitions is

00:04:31,360 --> 00:04:38,639
about describing a new data type

00:04:35,199 --> 00:04:40,960
and tell the kubernetes cluster

00:04:38,639 --> 00:04:42,320
how to create an endpoint for this new

00:04:40,960 --> 00:04:45,360
resource and also

00:04:42,320 --> 00:04:47,759
store it in its etcd store so

00:04:45,360 --> 00:04:48,960
if you look at this example where

00:04:47,759 --> 00:04:52,639
there's a

00:04:48,960 --> 00:04:55,840
description for a new postgres type

00:04:52,639 --> 00:04:58,160
that has the attributes replicas and

00:04:55,840 --> 00:05:00,960
postgres version

00:04:58,160 --> 00:05:02,800
once you have this custom resource

00:05:00,960 --> 00:05:03,600
definition applied to your kubernetes

00:05:02,800 --> 00:05:06,639
cluster

00:05:03,600 --> 00:05:10,240
it will be able to store objects of

00:05:06,639 --> 00:05:14,240
this new data type called postgres here

00:05:10,240 --> 00:05:16,479
the kind is postgres sql

00:05:14,240 --> 00:05:18,240
and objects will look like that of

00:05:16,479 --> 00:05:21,039
course they can be more complex more

00:05:18,240 --> 00:05:24,000
attributes but you get the idea

00:05:21,039 --> 00:05:25,919
so custom resource definitions tell the

00:05:24,000 --> 00:05:29,039
kubernetes api

00:05:25,919 --> 00:05:32,400
to store new data types custom resources

00:05:29,039 --> 00:05:34,240
and introduce end points

00:05:32,400 --> 00:05:35,840
so that you can use the cube cuddle

00:05:34,240 --> 00:05:38,320
command to create postgres

00:05:35,840 --> 00:05:40,320
objects that have not been known to

00:05:38,320 --> 00:05:43,600
kubernetes before

00:05:40,320 --> 00:05:47,280
and along with offering endpoints

00:05:43,600 --> 00:05:48,960
kubernetes will also storm the

00:05:47,280 --> 00:05:51,680
objects you create persistent

00:05:48,960 --> 00:05:54,400
persistently in its etcd

00:05:51,680 --> 00:05:56,080
but what it's not going to do is

00:05:54,400 --> 00:05:59,759
implement any behavior

00:05:56,080 --> 00:06:02,960
on what such a postgres object is about

00:05:59,759 --> 00:06:07,039
this is where controllers come into play

00:06:02,960 --> 00:06:10,319
and you write them down in go code

00:06:07,039 --> 00:06:12,720
when using the operator sdk and these

00:06:10,319 --> 00:06:15,759
operators are basically about

00:06:12,720 --> 00:06:17,759
monitoring the primary as well as

00:06:15,759 --> 00:06:20,479
secondary resources

00:06:17,759 --> 00:06:22,639
so in the example of our postgres the

00:06:20,479 --> 00:06:25,360
primary resource would be the postgres

00:06:22,639 --> 00:06:27,280
object that a user may want to create

00:06:25,360 --> 00:06:29,520
and you may want to translate it into a

00:06:27,280 --> 00:06:30,000
service and a stateful set which would

00:06:29,520 --> 00:06:32,840
then

00:06:30,000 --> 00:06:34,400
be the secondary resources in this

00:06:32,840 --> 00:06:36,639
example

00:06:34,400 --> 00:06:38,880
the code example there's a memcache

00:06:36,639 --> 00:06:39,840
object where the primary resource is

00:06:38,880 --> 00:06:41,919
memcache

00:06:39,840 --> 00:06:44,160
and the secondary resource is a single

00:06:41,919 --> 00:06:45,919
pod

00:06:44,160 --> 00:06:48,080
then these controllers they do have a

00:06:45,919 --> 00:06:50,720
reconcile or

00:06:48,080 --> 00:06:51,120
loop a function that is called where you

00:06:50,720 --> 00:06:53,919
check

00:06:51,120 --> 00:06:54,800
the desired state versus the actual

00:06:53,919 --> 00:06:57,919
state

00:06:54,800 --> 00:07:01,199
and what this function basically does

00:06:57,919 --> 00:07:03,039
is twofold first of all it or what the

00:07:01,199 --> 00:07:03,680
operator in this case does is twofold

00:07:03,039 --> 00:07:06,400
first of all

00:07:03,680 --> 00:07:07,520
it watches the primary object

00:07:06,400 --> 00:07:10,560
specification

00:07:07,520 --> 00:07:13,039
and translates it into secondary objects

00:07:10,560 --> 00:07:13,919
in this example it's um looking up

00:07:13,039 --> 00:07:17,199
whether

00:07:13,919 --> 00:07:20,240
a memcached object exists and if not

00:07:17,199 --> 00:07:21,759
it creates the corresponding part in our

00:07:20,240 --> 00:07:23,599
postgres example this would

00:07:21,759 --> 00:07:26,800
be about creating a service and a

00:07:23,599 --> 00:07:30,160
stateful set for example

00:07:26,800 --> 00:07:32,319
so a controller is basically

00:07:30,160 --> 00:07:33,360
reading those custom resource objects

00:07:32,319 --> 00:07:35,840
specifications

00:07:33,360 --> 00:07:37,039
and translate this primary resource

00:07:35,840 --> 00:07:39,919
description

00:07:37,039 --> 00:07:41,120
into a set of secondary resources by

00:07:39,919 --> 00:07:44,000
using

00:07:41,120 --> 00:07:44,800
other kubernetes resources well most of

00:07:44,000 --> 00:07:46,720
the time

00:07:44,800 --> 00:07:49,280
you'd be translating let's say the

00:07:46,720 --> 00:07:51,680
postgres object into kubernetes

00:07:49,280 --> 00:07:52,720
native resources such as services and

00:07:51,680 --> 00:07:55,199
stateful sets

00:07:52,720 --> 00:07:56,319
but you could also have an hierarchy of

00:07:55,199 --> 00:07:58,400
self

00:07:56,319 --> 00:08:01,360
of customer resources along with their

00:07:58,400 --> 00:08:05,280
controllers until you eventually hit

00:08:01,360 --> 00:08:07,360
the kubernetes native resources

00:08:05,280 --> 00:08:09,440
yes they will also watch the primary

00:08:07,360 --> 00:08:12,080
resources for changes and it ensures

00:08:09,440 --> 00:08:14,720
that the secondary resources comply to

00:08:12,080 --> 00:08:15,360
the specification as well so for example

00:08:14,720 --> 00:08:18,160
if you

00:08:15,360 --> 00:08:18,879
delete a stateful set of a postgres

00:08:18,160 --> 00:08:20,560
instance

00:08:18,879 --> 00:08:22,879
the controller could recognize that and

00:08:20,560 --> 00:08:24,800
recreate it such as the stateful set

00:08:22,879 --> 00:08:28,800
would recognize if you

00:08:24,800 --> 00:08:28,800
delete a pod and would recreate it

00:08:28,879 --> 00:08:34,080
yeah few thoughts about designing the

00:08:31,440 --> 00:08:36,240
service broker

00:08:34,080 --> 00:08:37,839
the service broker integration with

00:08:36,240 --> 00:08:40,320
operators

00:08:37,839 --> 00:08:41,200
first thing you have to do is figure out

00:08:40,320 --> 00:08:44,959
how would you map

00:08:41,200 --> 00:08:48,640
a service broker method to um

00:08:44,959 --> 00:08:52,160
the behavior in your operator

00:08:48,640 --> 00:08:55,440
now the first gotcha is here where

00:08:52,160 --> 00:08:58,080
where like enumerating the

00:08:55,440 --> 00:08:58,800
catalog meta information isn't a problem

00:08:58,080 --> 00:09:00,880
and

00:08:58,800 --> 00:09:02,480
creating service instance is what most

00:09:00,880 --> 00:09:06,320
operators support

00:09:02,480 --> 00:09:09,920
not every operator has a corresponding

00:09:06,320 --> 00:09:13,600
or a meaningful replacement for

00:09:09,920 --> 00:09:15,440
creating service bindings in fact many

00:09:13,600 --> 00:09:16,640
operators don't have anything to create

00:09:15,440 --> 00:09:19,360
a service binding

00:09:16,640 --> 00:09:20,800
once the service instance is is created

00:09:19,360 --> 00:09:23,519
they don't care

00:09:20,800 --> 00:09:26,080
how you create a database user there are

00:09:23,519 --> 00:09:29,120
operators who have that functionality

00:09:26,080 --> 00:09:30,320
and that's where an integration would be

00:09:29,120 --> 00:09:34,000
more easy

00:09:30,320 --> 00:09:35,839
but still one is one big problem

00:09:34,000 --> 00:09:37,279
seems to be apparent when integrating

00:09:35,839 --> 00:09:40,080
operators is

00:09:37,279 --> 00:09:40,080
if there's no

00:09:41,279 --> 00:09:46,320
functionality api or custom resource

00:09:44,399 --> 00:09:48,839
that represents the service binding the

00:09:46,320 --> 00:09:50,560
integration will require additional

00:09:48,839 --> 00:09:53,279
effort

00:09:50,560 --> 00:09:55,279
so now let's focus on the more the

00:09:53,279 --> 00:09:57,040
important use case of creating service

00:09:55,279 --> 00:10:00,560
instances for a second

00:09:57,040 --> 00:10:01,200
and the basic idea is that a cfcf create

00:10:00,560 --> 00:10:02,720
service

00:10:01,200 --> 00:10:04,959
triggers a controller triggers the

00:10:02,720 --> 00:10:05,760
service broker in this service broker

00:10:04,959 --> 00:10:09,120
what it does

00:10:05,760 --> 00:10:12,079
is it combines all custom parameters

00:10:09,120 --> 00:10:13,839
for example if you create a postgres you

00:10:12,079 --> 00:10:15,680
could add

00:10:13,839 --> 00:10:17,760
custom parameters about where to store

00:10:15,680 --> 00:10:21,279
logs or whether to

00:10:17,760 --> 00:10:24,640
use point in time recovery wall shipping

00:10:21,279 --> 00:10:26,560
or not these parameters are enriched

00:10:24,640 --> 00:10:29,279
with parameters

00:10:26,560 --> 00:10:29,680
gathered from the specified service plan

00:10:29,279 --> 00:10:32,079
so

00:10:29,680 --> 00:10:33,200
the service plan may for example contain

00:10:32,079 --> 00:10:36,560
the information

00:10:33,200 --> 00:10:38,640
whether one or three

00:10:36,560 --> 00:10:39,920
replicas should be used in the stateful

00:10:38,640 --> 00:10:41,600
set and also

00:10:39,920 --> 00:10:45,279
information about their vertical scale

00:10:41,600 --> 00:10:46,800
for example memory and cpu shares

00:10:45,279 --> 00:10:48,560
in a bosch based environment you would

00:10:46,800 --> 00:10:50,399
also resolve cloud properties which

00:10:48,560 --> 00:10:52,720
won't be necessary in a

00:10:50,399 --> 00:10:54,240
in a kubernetes environment but at some

00:10:52,720 --> 00:10:57,360
point you will have to generate

00:10:54,240 --> 00:11:00,240
a specification that will then be uh

00:10:57,360 --> 00:11:01,360
handed over to the kubernetes api where

00:11:00,240 --> 00:11:03,200
the operators

00:11:01,360 --> 00:11:05,279
take those specifications and translate

00:11:03,200 --> 00:11:07,200
them into secondary resources

00:11:05,279 --> 00:11:09,120
as i mentioned earlier earlier this

00:11:07,200 --> 00:11:12,480
could be a recursive

00:11:09,120 --> 00:11:14,640
chain of responsibility until you hit

00:11:12,480 --> 00:11:16,079
kubernetes native resources and

00:11:14,640 --> 00:11:19,839
kubernetes will actually do

00:11:16,079 --> 00:11:21,920
the rest for you so such a create

00:11:19,839 --> 00:11:24,959
statement may look like this

00:11:21,920 --> 00:11:28,240
it will on the server server

00:11:24,959 --> 00:11:32,320
service broker side generate

00:11:28,240 --> 00:11:33,839
a a request like this

00:11:32,320 --> 00:11:35,760
containing the information about the

00:11:33,839 --> 00:11:36,720
service plan which can then be resolved

00:11:35,760 --> 00:11:39,600
into

00:11:36,720 --> 00:11:41,120
the service plan attributes which then

00:11:39,600 --> 00:11:42,880
can be

00:11:41,120 --> 00:11:44,160
followed up until you have all the

00:11:42,880 --> 00:11:46,399
information about the

00:11:44,160 --> 00:11:47,680
the vertical and the horizontal scale of

00:11:46,399 --> 00:11:49,760
the service instance

00:11:47,680 --> 00:11:51,519
so that basically what you're doing is

00:11:49,760 --> 00:11:52,800
building the data structure containing

00:11:51,519 --> 00:11:55,279
all information

00:11:52,800 --> 00:11:56,880
necessary to create that service

00:11:55,279 --> 00:11:59,360
instance

00:11:56,880 --> 00:12:01,519
so it's basically in the end what you do

00:11:59,360 --> 00:12:02,399
is transform the incoming data of the

00:12:01,519 --> 00:12:04,560
service broker

00:12:02,399 --> 00:12:05,680
into the object specification of your

00:12:04,560 --> 00:12:07,519
custom resource

00:12:05,680 --> 00:12:08,880
for example the postgres object you've

00:12:07,519 --> 00:12:10,880
seen earlier

00:12:08,880 --> 00:12:12,720
and then hand it over to the kubernetes

00:12:10,880 --> 00:12:14,079
api which will then trigger the

00:12:12,720 --> 00:12:16,399
reconcile loop

00:12:14,079 --> 00:12:19,440
within the controller which will then

00:12:16,399 --> 00:12:21,839
translate it into secondary resources

00:12:19,440 --> 00:12:22,959
so that on the right side would for

00:12:21,839 --> 00:12:26,079
example be

00:12:22,959 --> 00:12:29,200
such a more complicated um

00:12:26,079 --> 00:12:30,000
real world so to say version of such an

00:12:29,200 --> 00:12:34,000
object

00:12:30,000 --> 00:12:36,000
where you specify a kubernetes resource

00:12:34,000 --> 00:12:37,600
a few words about the server about

00:12:36,000 --> 00:12:39,760
service bindings

00:12:37,600 --> 00:12:42,079
as i said they are unknown to kubernetes

00:12:39,760 --> 00:12:45,279
and unknown to many operators

00:12:42,079 --> 00:12:47,360
so if you want to look into or if you

00:12:45,279 --> 00:12:49,120
want to integrate an operator

00:12:47,360 --> 00:12:50,800
with kubernetes you may have to deal

00:12:49,120 --> 00:12:52,959
with that problem

00:12:50,800 --> 00:12:54,560
so one architectural draft to deal with

00:12:52,959 --> 00:12:57,360
this could be

00:12:54,560 --> 00:12:58,800
um as we've did it in the na9's data

00:12:57,360 --> 00:13:01,120
service framework

00:12:58,800 --> 00:13:03,519
well there's a concert called the spi

00:13:01,120 --> 00:13:05,600
which is a little bit comparable to

00:13:03,519 --> 00:13:06,800
bosch cpi we call it the service

00:13:05,600 --> 00:13:09,519
provider interface

00:13:06,800 --> 00:13:11,600
spi and this is where the service

00:13:09,519 --> 00:13:14,000
bindings are being created for a

00:13:11,600 --> 00:13:18,240
particular data service

00:13:14,000 --> 00:13:21,279
now in my opinion the creation of

00:13:18,240 --> 00:13:24,480
service bindings shouldn't be in

00:13:21,279 --> 00:13:26,240
a service broker plug-in because if you

00:13:24,480 --> 00:13:29,920
want to make

00:13:26,240 --> 00:13:32,320
kubernetes developers access your data

00:13:29,920 --> 00:13:32,320
service

00:13:32,720 --> 00:13:37,440
from kubernetes and using the kubernetes

00:13:34,880 --> 00:13:38,720
api alone

00:13:37,440 --> 00:13:41,360
the service bindings should be

00:13:38,720 --> 00:13:42,959
represented by customer resources with

00:13:41,360 --> 00:13:45,600
an appropriate controller

00:13:42,959 --> 00:13:50,240
which is where the logic should reside

00:13:45,600 --> 00:13:50,240
so in this case the spi wouldn't

00:13:51,040 --> 00:13:54,160
create the database user for your

00:13:52,560 --> 00:13:56,399
postgres for example

00:13:54,160 --> 00:13:58,320
but instead create a custom resource

00:13:56,399 --> 00:13:59,120
definition triggering a controller to do

00:13:58,320 --> 00:14:01,120
that for you

00:13:59,120 --> 00:14:02,800
with using kubernetes means for example

00:14:01,120 --> 00:14:04,240
like executing a job that will connect

00:14:02,800 --> 00:14:06,000
to the service instance

00:14:04,240 --> 00:14:08,079
and you know do the heavy lifting of

00:14:06,000 --> 00:14:12,560
creating that user

00:14:08,079 --> 00:14:15,440
um if your operator doesn't support

00:14:12,560 --> 00:14:16,000
creating a service binding well then an

00:14:15,440 --> 00:14:18,399
spi

00:14:16,000 --> 00:14:21,600
plug-in would be necessary so that the

00:14:18,399 --> 00:14:25,920
service broker knows how to do it

00:14:21,600 --> 00:14:25,920
so it may be interesting to restrict the

00:14:26,079 --> 00:14:29,519
the application developer using the

00:14:28,320 --> 00:14:32,480
kubernetes api

00:14:29,519 --> 00:14:33,760
to modify a service instance that's used

00:14:32,480 --> 00:14:35,360
by cloud foundry

00:14:33,760 --> 00:14:36,800
that has been created by a cloud from

00:14:35,360 --> 00:14:40,959
the application user

00:14:36,800 --> 00:14:43,360
to make things easier so in particular

00:14:40,959 --> 00:14:45,279
the question is should a cloud foundry

00:14:43,360 --> 00:14:46,880
and cooper should cloud foundry and

00:14:45,279 --> 00:14:48,959
kubernetes users

00:14:46,880 --> 00:14:50,000
be able to modify a certain service

00:14:48,959 --> 00:14:51,760
instance

00:14:50,000 --> 00:14:54,000
and i would say it is technically

00:14:51,760 --> 00:14:56,480
possible but it requires

00:14:54,000 --> 00:14:57,040
a back-and-forth communication between

00:14:56,480 --> 00:15:00,320
both

00:14:57,040 --> 00:15:02,800
the kubernetes controllers as well as

00:15:00,320 --> 00:15:04,240
or the kubernetes api as well as the

00:15:02,800 --> 00:15:07,360
service broker api

00:15:04,240 --> 00:15:08,079
or or even the cloud controller to keep

00:15:07,360 --> 00:15:10,720
those

00:15:08,079 --> 00:15:12,320
two entities in sync especially because

00:15:10,720 --> 00:15:14,560
the cloud controller tends to store

00:15:12,320 --> 00:15:16,160
information about service instances

00:15:14,560 --> 00:15:18,480
if you would delete for example a

00:15:16,160 --> 00:15:20,480
service binding or service instance

00:15:18,480 --> 00:15:22,399
that has been created and has still

00:15:20,480 --> 00:15:25,040
metadata in the cloud controller

00:15:22,399 --> 00:15:25,680
this would lead to data inconsistencies

00:15:25,040 --> 00:15:28,160
so

00:15:25,680 --> 00:15:29,279
to keep things simple it will definitely

00:15:28,160 --> 00:15:32,320
help if you'd

00:15:29,279 --> 00:15:32,959
declare each service instance to be

00:15:32,320 --> 00:15:35,519
either

00:15:32,959 --> 00:15:36,000
in the responsibility of a cloud foundry

00:15:35,519 --> 00:15:39,279
or

00:15:36,000 --> 00:15:41,680
a kubernetes application developer so

00:15:39,279 --> 00:15:43,680
let's sum it up a service broker

00:15:41,680 --> 00:15:46,000
integrating arbitrary operators

00:15:43,680 --> 00:15:46,959
may not be worth the effort it is

00:15:46,000 --> 00:15:49,440
possible but

00:15:46,959 --> 00:15:51,759
it may be too complicated to do so

00:15:49,440 --> 00:15:54,000
assumptions about the operation to be

00:15:51,759 --> 00:15:54,959
integrated are necess of the operator to

00:15:54,000 --> 00:15:58,880
be integrated

00:15:54,959 --> 00:16:00,720
are necessary to be made

00:15:58,880 --> 00:16:02,959
to make the service broker economically

00:16:00,720 --> 00:16:03,839
viable so in our case for example the

00:16:02,959 --> 00:16:06,079
assumption is

00:16:03,839 --> 00:16:07,440
the operator will have a custom resource

00:16:06,079 --> 00:16:09,839
for the service binding

00:16:07,440 --> 00:16:11,199
which makes the creation of service

00:16:09,839 --> 00:16:14,000
bindings much easier

00:16:11,199 --> 00:16:16,000
and generic if you don't want to do that

00:16:14,000 --> 00:16:19,040
you will lose the generic part

00:16:16,000 --> 00:16:20,800
because then you have to create a plugin

00:16:19,040 --> 00:16:22,560
for each data service

00:16:20,800 --> 00:16:24,320
describing how to create a service

00:16:22,560 --> 00:16:26,320
binding

00:16:24,320 --> 00:16:28,000
so you can say the more homogenous the

00:16:26,320 --> 00:16:30,079
functionality of your operators

00:16:28,000 --> 00:16:33,279
the more generic and the easier a

00:16:30,079 --> 00:16:35,519
generic source broker can emerge

00:16:33,279 --> 00:16:36,959
the operator must provide a specific

00:16:35,519 --> 00:16:39,040
functionality because

00:16:36,959 --> 00:16:40,800
as i said there's no service binding

00:16:39,040 --> 00:16:42,079
functionality well and you have to take

00:16:40,800 --> 00:16:44,480
care of it

00:16:42,079 --> 00:16:45,920
yourself and you know certain lifecycle

00:16:44,480 --> 00:16:47,920
operations for example

00:16:45,920 --> 00:16:50,399
creates and updates well obviously they

00:16:47,920 --> 00:16:52,240
have to exist as well

00:16:50,399 --> 00:16:53,519
the service broker will be much simpler

00:16:52,240 --> 00:16:55,759
if you have

00:16:53,519 --> 00:16:57,600
that restriction where a cloud founder

00:16:55,759 --> 00:16:58,720
user creates service instances used by

00:16:57,600 --> 00:17:02,000
cloud foundry

00:16:58,720 --> 00:17:03,759
and kubernetes users create instances

00:17:02,000 --> 00:17:06,079
used by kubernetes users

00:17:03,759 --> 00:17:07,520
read-only access should be possible from

00:17:06,079 --> 00:17:10,400
both worlds even

00:17:07,520 --> 00:17:11,199
if they are mixed but creating and

00:17:10,400 --> 00:17:13,439
modifying

00:17:11,199 --> 00:17:14,400
a deleting and modifying they should be

00:17:13,439 --> 00:17:17,120
exclusive

00:17:14,400 --> 00:17:18,400
to either cloud foundry or kubernetes

00:17:17,120 --> 00:17:21,439
users

00:17:18,400 --> 00:17:24,160
well thank you very much so far

00:17:21,439 --> 00:17:24,720
i hope you have learned something in

00:17:24,160 --> 00:17:28,240
this

00:17:24,720 --> 00:17:29,039
very very quick tour about how service

00:17:28,240 --> 00:17:30,840
brokers

00:17:29,039 --> 00:17:32,640
can be used to integrate kubernetes

00:17:30,840 --> 00:17:36,400
operators

00:17:32,640 --> 00:17:40,640
we'll have a 30 minute deep dive session

00:17:36,400 --> 00:17:43,039
in our youtube channel um at youtube.com

00:17:40,640 --> 00:17:44,400
any nines so if you want to go through

00:17:43,039 --> 00:17:48,160
that material

00:17:44,400 --> 00:17:51,039
in um at a little slower pace please

00:17:48,160 --> 00:17:52,000
feel free to visit on that channel so if

00:17:51,039 --> 00:17:54,559
you have questions

00:17:52,000 --> 00:17:57,039
um just feel free to ask and already

00:17:54,559 --> 00:18:00,720
thank you very much

00:17:57,039 --> 00:18:05,520
hello everyone

00:18:00,720 --> 00:18:09,360
well sales brokers there any questions

00:18:05,520 --> 00:18:12,720
no questions have been asked so far

00:18:09,360 --> 00:18:29,840
so feel free to ask whatever is

00:18:12,720 --> 00:18:29,840
concerning you after the talk

00:18:31,039 --> 00:18:33,600
thank you

00:18:36,240 --> 00:18:42,080
are there any questions um concerning

00:18:39,840 --> 00:18:45,120
the service broker api

00:18:42,080 --> 00:18:48,480
concerning kubernetes operators

00:18:45,120 --> 00:18:48,480
or their integration

00:18:53,840 --> 00:18:57,039
you mean kubernetes itself or the

00:18:56,160 --> 00:19:00,000
kubernetes

00:18:57,039 --> 00:19:00,000
implementation that we have done

00:19:00,559 --> 00:19:11,840
the question was how mature is the

00:19:02,000 --> 00:19:11,840
kubernetes side

00:19:16,080 --> 00:19:22,480
well um the service catalog plugin

00:19:20,480 --> 00:19:24,240
it assumes that there is a service

00:19:22,480 --> 00:19:25,840
broker that actually does the automation

00:19:24,240 --> 00:19:26,799
and implements all the implementation

00:19:25,840 --> 00:19:30,720
logic

00:19:26,799 --> 00:19:33,200
which is basically the the primary

00:19:30,720 --> 00:19:34,600
automation and the service catalog then

00:19:33,200 --> 00:19:36,320
provides the option to

00:19:34,600 --> 00:19:38,400
[Music]

00:19:36,320 --> 00:19:39,840
create custom resource definitions and

00:19:38,400 --> 00:19:41,280
it will create custom resource

00:19:39,840 --> 00:19:43,440
definitions for you

00:19:41,280 --> 00:19:44,720
so that you'll be able to consume a

00:19:43,440 --> 00:19:49,600
service broker

00:19:44,720 --> 00:19:52,160
within kubernetes um

00:19:49,600 --> 00:19:54,240
so the service catalog is always useful

00:19:52,160 --> 00:19:55,280
if you have a cloud-founded data service

00:19:54,240 --> 00:19:57,280
implementation

00:19:55,280 --> 00:19:59,039
such as the nines data service that will

00:19:57,280 --> 00:20:01,280
come with the service broker

00:19:59,039 --> 00:20:02,720
and then talk to bosch to actually do

00:20:01,280 --> 00:20:04,080
the on-demand provisioning

00:20:02,720 --> 00:20:05,919
and if you want to integrate that with

00:20:04,080 --> 00:20:06,559
kubernetes you'd be using the service

00:20:05,919 --> 00:20:08,640
catalog

00:20:06,559 --> 00:20:09,760
and i think that's um or at least from

00:20:08,640 --> 00:20:13,360
our experience

00:20:09,760 --> 00:20:15,280
it's okay to use now the approach

00:20:13,360 --> 00:20:16,400
that i explained in the talk would be

00:20:15,280 --> 00:20:19,919
the other way around

00:20:16,400 --> 00:20:20,400
that you create a kubernetes operator

00:20:19,919 --> 00:20:23,360
where

00:20:20,400 --> 00:20:24,880
the actual automation takes place within

00:20:23,360 --> 00:20:26,960
kubernetes

00:20:24,880 --> 00:20:28,320
and where you provide custom resource

00:20:26,960 --> 00:20:30,960
definitions

00:20:28,320 --> 00:20:33,039
and controllers and controllers will

00:20:30,960 --> 00:20:35,200
then take care of the actual automation

00:20:33,039 --> 00:20:37,200
by scheduling a stateful set which will

00:20:35,200 --> 00:20:37,679
then you know use container images that

00:20:37,200 --> 00:20:40,320
do

00:20:37,679 --> 00:20:40,880
contain all your scripts so the service

00:20:40,320 --> 00:20:44,720
broker

00:20:40,880 --> 00:20:49,039
in the example i've shown is basically

00:20:44,720 --> 00:20:52,480
a secondary or a means to an end and

00:20:49,039 --> 00:20:55,120
so it's just an adapter to integrate

00:20:52,480 --> 00:20:57,120
um the kubernetes api by using those

00:20:55,120 --> 00:21:00,640
custom resource definitions

00:20:57,120 --> 00:21:01,600
so um both this is valid and especially

00:21:00,640 --> 00:21:05,120
if you have

00:21:01,600 --> 00:21:07,039
operators already and you want to

00:21:05,120 --> 00:21:08,880
integrate them with the cloud foundry

00:21:07,039 --> 00:21:11,440
and the way that i just earlier

00:21:08,880 --> 00:21:13,440
explained in the talk would be suitable

00:21:11,440 --> 00:21:15,039
if you have a service broker that for

00:21:13,440 --> 00:21:16,240
example comes from the cloud foundry

00:21:15,039 --> 00:21:17,840
ecosystem

00:21:16,240 --> 00:21:18,799
and it does the automation already and

00:21:17,840 --> 00:21:20,559
you want to integrate that with

00:21:18,799 --> 00:21:30,000
kubernetes then you'd be using the

00:21:20,559 --> 00:21:31,919
service catalog plugin

00:21:30,000 --> 00:21:33,520
well if you have native support with

00:21:31,919 --> 00:21:34,880
custom resource definitions then you

00:21:33,520 --> 00:21:37,360
don't need the service catalog

00:21:34,880 --> 00:21:38,480
because the service catalog actually

00:21:37,360 --> 00:21:40,240
does create

00:21:38,480 --> 00:21:43,280
those custom resource definitions for

00:21:40,240 --> 00:21:45,919
you and it also introduces the concept

00:21:43,280 --> 00:21:48,080
of the service binding just to reflect

00:21:45,919 --> 00:21:50,159
the circumstance that the service broker

00:21:48,080 --> 00:21:59,840
to be integrated will have support for

00:21:50,159 --> 00:21:59,840
service bindings and service instances

00:22:01,360 --> 00:22:05,679
are there any other questions or

00:22:02,720 --> 00:22:05,679
comments um

00:22:06,559 --> 00:22:13,840
i think we have a few minutes left

00:22:18,080 --> 00:22:21,520
all right then thank you very much for

00:22:20,880 --> 00:22:24,720
your time

00:22:21,520 --> 00:22:27,039
uh pleasure talking to you guys um

00:22:24,720 --> 00:22:29,280
if you have questions that pop up into

00:22:27,039 --> 00:22:30,240
your mind later feel free to reach out

00:22:29,280 --> 00:22:33,120
it's um

00:22:30,240 --> 00:22:34,640
at julianfisher or at any lines and we

00:22:33,120 --> 00:22:37,039
can then use uh

00:22:34,640 --> 00:22:38,400
you know some slack channel or have a

00:22:37,039 --> 00:22:40,960
zoom one to one to

00:22:38,400 --> 00:22:41,760
you know go through your questions so

00:22:40,960 --> 00:22:45,360
thank you very much

00:22:41,760 --> 00:22:49,760
and and see you in the next talk or next

00:22:45,360 --> 00:22:49,760

YouTube URL: https://www.youtube.com/watch?v=5M_4Z-kzYrk


