Title: Go Within Cloud Foundry - Platform: The Cloud Foundry Conference
Publication date: 2013-11-22
Playlist: Platform: The Cloud Foundry Conference
Description: 
	Go Within Cloud Foundry
Mike Gehard, Senior Software Engineer, Pivotal Labs
Platform: The Cloud Foundry Conference (http://www.platformcf.com) September 8-9, 2013
Captions: 
	00:00:00,870 --> 00:00:03,979
[Music]

00:00:06,109 --> 00:00:12,090
so a little bit about me I've been

00:00:10,410 --> 00:00:15,420
developing software for probably 15

00:00:12,090 --> 00:00:17,070
years now going on I've developed in

00:00:15,420 --> 00:00:19,580
most major languages that are used on

00:00:17,070 --> 00:00:21,779
the web I have two engineering degrees

00:00:19,580 --> 00:00:23,010
one of which is in chemical engineering

00:00:21,779 --> 00:00:27,810
and one of which is in software

00:00:23,010 --> 00:00:29,189
engineering and it's really not about my

00:00:27,810 --> 00:00:30,510
back I just wanted you to understand

00:00:29,189 --> 00:00:33,270
like where I'm coming from so when I

00:00:30,510 --> 00:00:37,200
evaluate a language I bring a certain

00:00:33,270 --> 00:00:38,550
engineering mindset to it so as we go

00:00:37,200 --> 00:00:40,379
through this talk kind of keep that in

00:00:38,550 --> 00:00:41,790
the back of your head like when he talks

00:00:40,379 --> 00:00:44,460
about this he's coming from an

00:00:41,790 --> 00:00:46,140
engineering standpoint I like creativity

00:00:44,460 --> 00:00:47,700
as much as the next person but when I'm

00:00:46,140 --> 00:00:50,489
writing code I really want to be

00:00:47,700 --> 00:00:54,149
engineering code so that may show up

00:00:50,489 --> 00:00:57,989
here I also am crusty and old so I'm

00:00:54,149 --> 00:01:01,440
using note cards and I have very baggy

00:00:57,989 --> 00:01:04,110
pants on so I'm not like a new hipster

00:01:01,440 --> 00:01:06,030
which is cool but I typically don't look

00:01:04,110 --> 00:01:08,400
at languages from a new hotness

00:01:06,030 --> 00:01:09,570
standpoint it's very much an engineering

00:01:08,400 --> 00:01:15,090
like what can I get done with these

00:01:09,570 --> 00:01:16,470
things so go has anybody seen logo but

00:01:15,090 --> 00:01:19,049
one of the best parts ago is all the

00:01:16,470 --> 00:01:20,939
cool Gopher logos that they have I tried

00:01:19,049 --> 00:01:22,590
to get a gopher t-shirt they do not have

00:01:20,939 --> 00:01:24,840
them they're out of stock I also try to

00:01:22,590 --> 00:01:26,700
get a little gopher stuffed animal that

00:01:24,840 --> 00:01:28,950
Rob Pike always has during his talks but

00:01:26,700 --> 00:01:31,409
they were out of those too so not only

00:01:28,950 --> 00:01:32,790
is the language hot but so where's all

00:01:31,409 --> 00:01:34,020
the swag that surrounds the language

00:01:32,790 --> 00:01:37,820
maybe someone from Google we're hear

00:01:34,020 --> 00:01:41,159
this and send me a shirt and a gopher

00:01:37,820 --> 00:01:43,829
and I said as my goal is to help you

00:01:41,159 --> 00:01:45,390
understand why we've chosen go so I'm

00:01:43,829 --> 00:01:47,369
gonna start out with a little history so

00:01:45,390 --> 00:01:49,200
as many people know those that do not

00:01:47,369 --> 00:01:51,090
understand the past are doomed to repeat

00:01:49,200 --> 00:01:52,860
it so I'm gonna give you a little bit

00:01:51,090 --> 00:01:56,490
history of where go came from how it

00:01:52,860 --> 00:02:00,990
came to be who was involved I mean

00:01:56,490 --> 00:02:02,670
explain to you at a high level some of

00:02:00,990 --> 00:02:04,320
the aspects of go that I really like

00:02:02,670 --> 00:02:06,000
there are many aspects of go that are

00:02:04,320 --> 00:02:08,550
really cool and I'm more than happy to

00:02:06,000 --> 00:02:10,500
talk to people as we go about them

00:02:08,550 --> 00:02:12,629
either after the conference today or in

00:02:10,500 --> 00:02:14,550
the low tomorrow during the open talk

00:02:12,629 --> 00:02:18,840
sessions show people Coe

00:02:14,550 --> 00:02:20,129
we can do that and show you a short kind

00:02:18,840 --> 00:02:21,870
of a short introduction

00:02:20,129 --> 00:02:23,819
one of which Matthew stole my thunder on

00:02:21,870 --> 00:02:26,269
which is the ghost CLI that I helped

00:02:23,819 --> 00:02:28,890
start to rewrite three weeks ago and

00:02:26,269 --> 00:02:30,450
another one is the logger Gator project

00:02:28,890 --> 00:02:32,940
which is our log aggregation product

00:02:30,450 --> 00:02:35,610
which I helped start right - so two big

00:02:32,940 --> 00:02:37,319
projects both started and go I'd never

00:02:35,610 --> 00:02:40,560
written go before I start a blog on

00:02:37,319 --> 00:02:41,580
Gator Rob joked with me one day is like

00:02:40,560 --> 00:02:43,319
hey you might want to start learning

00:02:41,580 --> 00:02:44,819
goes it actually a Scala conference owes

00:02:43,319 --> 00:02:46,349
it Scala days and I'm tweeting how cool

00:02:44,819 --> 00:02:48,150
Scala is and sending out all these

00:02:46,349 --> 00:02:50,280
things and I got an email from Rob

00:02:48,150 --> 00:02:52,739
saying you might want to start looking

00:02:50,280 --> 00:02:54,540
at go and I was like all right cool

00:02:52,739 --> 00:02:55,620
and then like four weeks later is like

00:02:54,540 --> 00:02:59,730
hey now you're gonna start writing good

00:02:55,620 --> 00:03:02,069
you start looking at it I'm like no but

00:02:59,730 --> 00:03:03,720
we'll talk about that later too

00:03:02,069 --> 00:03:05,310
and then yeah if you've got any

00:03:03,720 --> 00:03:09,450
questions as we go let's have a

00:03:05,310 --> 00:03:11,340
discussion around that so it's like the

00:03:09,450 --> 00:03:13,049
admit understand we're all starting at

00:03:11,340 --> 00:03:15,660
the same point we are talking about

00:03:13,049 --> 00:03:17,970
writing software that runs on gigantic

00:03:15,660 --> 00:03:20,519
arrays of computers we are not talking

00:03:17,970 --> 00:03:21,690
about brochure websites which some

00:03:20,519 --> 00:03:23,730
people are trying to write and go

00:03:21,690 --> 00:03:26,850
there's actually rails clone and go

00:03:23,730 --> 00:03:28,290
called rebel I am NOT talking about that

00:03:26,850 --> 00:03:30,870
I'm talking about writing high

00:03:28,290 --> 00:03:33,569
performance highly scalable software the

00:03:30,870 --> 00:03:35,639
CLI being kind of a counterpoint to that

00:03:33,569 --> 00:03:40,889
but I'll explain how that goes down

00:03:35,639 --> 00:03:45,959
later yeah so a little bit of the

00:03:40,889 --> 00:03:47,790
history of go it was started in 2007 by

00:03:45,959 --> 00:03:49,889
some pretty heavy hitters in the

00:03:47,790 --> 00:03:52,620
industry so how many people recognize

00:03:49,889 --> 00:03:55,560
those names yeah

00:03:52,620 --> 00:03:58,650
so you got a guy that wrote the v8

00:03:55,560 --> 00:04:01,530
engine and the hot spot compiler for

00:03:58,650 --> 00:04:04,590
Java and you have two guys that worked

00:04:01,530 --> 00:04:07,290
at Bell Labs that wrote most of Linux or

00:04:04,590 --> 00:04:08,760
lot parts of Linux and planned the plan

00:04:07,290 --> 00:04:12,000
9 operating system which never saw the

00:04:08,760 --> 00:04:13,950
light of day so 2007 so there's that six

00:04:12,000 --> 00:04:16,859
years ago Oh actually six years ago

00:04:13,950 --> 00:04:18,389
almost to the day that work began inside

00:04:16,859 --> 00:04:20,910
of Google on this project

00:04:18,389 --> 00:04:22,950
a year later Russ Cox I mean and Russ

00:04:20,910 --> 00:04:24,900
Cox worked with a bunch of those guys at

00:04:22,950 --> 00:04:26,340
Bell Labs another systems programmer

00:04:24,900 --> 00:04:27,840
joins the team so you know I have four

00:04:26,340 --> 00:04:29,580
heavy hitters in the

00:04:27,840 --> 00:04:32,370
community working on a language inside

00:04:29,580 --> 00:04:36,389
of Google there must be some there's

00:04:32,370 --> 00:04:39,120
something going on there November 10th

00:04:36,389 --> 00:04:41,130
2009 they open source the project so

00:04:39,120 --> 00:04:44,130
this is the big turning point for go in

00:04:41,130 --> 00:04:46,199
my mind is that many people bash Google

00:04:44,130 --> 00:04:49,470
for starting projects and never really

00:04:46,199 --> 00:04:51,540
supporting them all the way through this

00:04:49,470 --> 00:04:53,190
one went open-source fully public it is

00:04:51,540 --> 00:04:54,630
not a Google project any longer is an

00:04:53,190 --> 00:04:56,340
open source project given to the

00:04:54,630 --> 00:04:59,120
community so there are many people

00:04:56,340 --> 00:05:03,500
outside of Google that are working on

00:04:59,120 --> 00:05:07,620
writing go the next big turning point

00:05:03,500 --> 00:05:10,169
2012 goes go goes 1.0 so the reason this

00:05:07,620 --> 00:05:12,389
was a big turning point was that they

00:05:10,169 --> 00:05:14,040
said now you can start beginning begin

00:05:12,389 --> 00:05:17,490
building production apps we will make it

00:05:14,040 --> 00:05:19,169
we will make a pledge to you that we are

00:05:17,490 --> 00:05:21,780
not gonna go rewrite a bunch of the

00:05:19,169 --> 00:05:23,340
api's so much that Rob Pike on the

00:05:21,780 --> 00:05:25,979
mailing list is always pushing back on

00:05:23,340 --> 00:05:27,410
people that one IP API changes they're

00:05:25,979 --> 00:05:28,710
like no no back we're gonna do

00:05:27,410 --> 00:05:29,580
backwards-compatible here

00:05:28,710 --> 00:05:30,960
we're not you're not gonna have to worry

00:05:29,580 --> 00:05:33,270
about writing a bunch of production code

00:05:30,960 --> 00:05:34,500
and go and then you know 1.1 comes out

00:05:33,270 --> 00:05:37,020
and we're gonna release a bunch of new

00:05:34,500 --> 00:05:38,250
things or 2.0 is gonna come out in six

00:05:37,020 --> 00:05:39,360
months and now you have to rewrite your

00:05:38,250 --> 00:05:41,940
whole stack they actually have not

00:05:39,360 --> 00:05:45,660
announced the timeline for go 2.0 so

00:05:41,940 --> 00:05:48,240
they're really focusing on using the

00:05:45,660 --> 00:05:48,660
language inside of Google and making it

00:05:48,240 --> 00:05:51,630
better

00:05:48,660 --> 00:05:55,770
in early 2013 we wrote the rewrote the

00:05:51,630 --> 00:05:57,360
router and go so a year after Google

00:05:55,770 --> 00:06:02,460
releases were like ah let's try this out

00:05:57,360 --> 00:06:05,010
so why go can't reread that they were

00:06:02,460 --> 00:06:07,020
gonna read that for me no okay cool just

00:06:05,010 --> 00:06:08,760
remember that URL so there's a you are

00:06:07,020 --> 00:06:10,470
at the bottom it comes from the go FAQ I

00:06:08,760 --> 00:06:12,900
literally copied that verbatim don't you

00:06:10,470 --> 00:06:14,430
don't need to read it I'm gonna

00:06:12,900 --> 00:06:17,580
highlight some big pieces of that for

00:06:14,430 --> 00:06:19,860
you so one big piece frustration with

00:06:17,580 --> 00:06:22,349
existing languages somebody will do

00:06:19,860 --> 00:06:28,360
systems programming yeah do you all

00:06:22,349 --> 00:06:33,030
enjoy C and C++ you do okay sweet

00:06:28,360 --> 00:06:33,030
I haven't written C++ since college so

00:06:35,039 --> 00:06:39,129
there was a frustration within Google

00:06:37,419 --> 00:06:40,509
they're doing I mean think about the

00:06:39,129 --> 00:06:43,180
sauce software that these guys write

00:06:40,509 --> 00:06:45,699
gigantic single codebase you know you

00:06:43,180 --> 00:06:47,740
tell stories about the build system it's

00:06:45,699 --> 00:06:50,650
like dear God that stuff I could put

00:06:47,740 --> 00:06:51,849
this man on the moon so they were

00:06:50,650 --> 00:06:54,909
frustrated with that they were being

00:06:51,849 --> 00:06:56,139
forced to choose choose between

00:06:54,909 --> 00:06:59,259
efficient compilation efficient

00:06:56,139 --> 00:07:00,909
execution or ease of programming they

00:06:59,259 --> 00:07:06,069
couldn't get all three in the existing

00:07:00,909 --> 00:07:08,590
tools and heaven forbid you go to a

00:07:06,069 --> 00:07:11,439
dynamically typed language ooh

00:07:08,590 --> 00:07:12,669
Ruby Python so they're right we start

00:07:11,439 --> 00:07:14,409
writing a lot of things in Ruby and

00:07:12,669 --> 00:07:19,629
Python Matthew talked about how we have

00:07:14,409 --> 00:07:21,669
a lot of code in Python so they were

00:07:19,629 --> 00:07:24,430
being forced to choose and the only

00:07:21,669 --> 00:07:25,930
choice they could go to was a

00:07:24,430 --> 00:07:27,909
dynamically typed language how many

00:07:25,930 --> 00:07:29,560
people write Ruby in here how many

00:07:27,909 --> 00:07:32,550
people want to write large gigantic

00:07:29,560 --> 00:07:37,120
systems in a ruby that's what I thought

00:07:32,550 --> 00:07:38,789
I've done it it's painful what did they

00:07:37,120 --> 00:07:40,870
want they wanted ease of programming

00:07:38,789 --> 00:07:42,310
they wanted something that was easy

00:07:40,870 --> 00:07:43,569
that's why we go to dynamically type

00:07:42,310 --> 00:07:47,289
language is how many people went to Roo

00:07:43,569 --> 00:07:49,150
because it was easy yeah I love Ruby I

00:07:47,289 --> 00:07:51,550
used to write Ruby full time until I

00:07:49,150 --> 00:07:53,949
started writing go they also wanted

00:07:51,550 --> 00:07:55,960
efficiency and safety so what don't we

00:07:53,949 --> 00:07:58,629
get in Ruby we don't get efficiency we

00:07:55,960 --> 00:08:02,289
don't get safety a dynamically typed

00:07:58,629 --> 00:08:04,479
language that is interpreted at runtime

00:08:02,289 --> 00:08:08,020
Network and multi-core computing how

00:08:04,479 --> 00:08:10,180
many people like threads in Java yeah

00:08:08,020 --> 00:08:12,189
that's what I thought

00:08:10,180 --> 00:08:14,289
and it's network I mean think of the

00:08:12,189 --> 00:08:15,879
Google infrastructure and you know Rob

00:08:14,289 --> 00:08:17,289
Pike tells stories and all of this talks

00:08:15,879 --> 00:08:19,120
if you haven't watched the talks on go I

00:08:17,289 --> 00:08:21,460
highly recommend it not only is Rob Pike

00:08:19,120 --> 00:08:23,560
very entertaining but they're really and

00:08:21,460 --> 00:08:25,779
they're really good you know all these

00:08:23,560 --> 00:08:27,699
computers talking to one another we know

00:08:25,779 --> 00:08:29,740
of multi-core computing so this is a new

00:08:27,699 --> 00:08:31,180
thing my native languages didn't Werner

00:08:29,740 --> 00:08:34,719
out where we didn't have this in many

00:08:31,180 --> 00:08:36,550
languages are written and they want to

00:08:34,719 --> 00:08:38,230
build a large execute on a single

00:08:36,550 --> 00:08:40,180
computer

00:08:38,230 --> 00:08:43,680
so what did they do they were at a new

00:08:40,180 --> 00:08:45,940
language so let's talk about frustration

00:08:43,680 --> 00:08:50,260
how many people are frustrated with the

00:08:45,940 --> 00:08:51,610
languages they're writing in so there's

00:08:50,260 --> 00:08:53,050
some frustration we have one gentleman

00:08:51,610 --> 00:08:55,420
down here who loves C++ and that's

00:08:53,050 --> 00:08:58,090
awesome you can still actually write C++

00:08:55,420 --> 00:08:59,800
in go which is kind of nice but remember

00:08:58,090 --> 00:09:01,630
who wrote this language these guys ever

00:08:59,800 --> 00:09:03,580
writing swimming these are system

00:09:01,630 --> 00:09:04,720
programming experts these guys are

00:09:03,580 --> 00:09:06,610
writing Unix

00:09:04,720 --> 00:09:12,060
and they were frustrated with what they

00:09:06,610 --> 00:09:16,690
have you know you look at C++ C Java

00:09:12,060 --> 00:09:19,050
rust and Bay written rust what do you

00:09:16,690 --> 00:09:23,020
think yeah

00:09:19,050 --> 00:09:25,600
but how do you like rust yeah it's still

00:09:23,020 --> 00:09:27,160
new though it's still a relatively new

00:09:25,600 --> 00:09:32,200
language I'm is they be using rust in

00:09:27,160 --> 00:09:36,700
production no so they all have trade

00:09:32,200 --> 00:09:41,170
offs again we're being able to being

00:09:36,700 --> 00:09:42,910
forced to choose so why do I need to

00:09:41,170 --> 00:09:47,170
choose its 2013

00:09:42,910 --> 00:09:48,310
I want jetpacks I was promised jetpacks

00:09:47,170 --> 00:09:50,470
sometimes I feel like I'm programming

00:09:48,310 --> 00:09:52,210
like this like I had this little copier

00:09:50,470 --> 00:09:54,370
that I can like I can get around on it

00:09:52,210 --> 00:09:56,980
but I like it's 2013 like where my

00:09:54,370 --> 00:10:01,540
jetpacks so they didn't want to choose

00:09:56,980 --> 00:10:03,160
anymore and as I said we're all going to

00:10:01,540 --> 00:10:06,010
dynamic languages so Ruby's great

00:10:03,160 --> 00:10:08,380
I love Ruby but writing large systems

00:10:06,010 --> 00:10:11,110
Ruby's really hard and we have a really

00:10:08,380 --> 00:10:12,880
long running test suite and Ruby yeah

00:10:11,110 --> 00:10:14,530
the reason we have long running test

00:10:12,880 --> 00:10:18,600
Suites is because we have to build up

00:10:14,530 --> 00:10:22,060
all of this structure around our code

00:10:18,600 --> 00:10:23,820
I'll be writing node in production I'm

00:10:22,060 --> 00:10:25,960
sorry

00:10:23,820 --> 00:10:27,960
every time someone says they put in note

00:10:25,960 --> 00:10:30,190
service and oppression I was like oh man

00:10:27,960 --> 00:10:35,440
javascript is written to script the

00:10:30,190 --> 00:10:41,080
browser it was it was written to script

00:10:35,440 --> 00:10:43,330
the browser so what do we want we want

00:10:41,080 --> 00:10:44,800
ease and safety how do you want to eat

00:10:43,330 --> 00:10:46,150
how many people want to be easy to

00:10:44,800 --> 00:10:48,760
program and a type system

00:10:46,150 --> 00:10:54,680
hey Scala developers in here

00:10:48,760 --> 00:10:55,940
yeah that type systems a little heavy go

00:10:54,680 --> 00:10:58,490
is actually got a really nice

00:10:55,940 --> 00:11:04,250
lightweight type system so maybe right

00:10:58,490 --> 00:11:05,450
go in here one wow cool i all the rest

00:11:04,250 --> 00:11:07,190
you guys that your developers have your

00:11:05,450 --> 00:11:12,560
hands up I highly recommend like tonight

00:11:07,190 --> 00:11:14,840
tour golang.org so we want something

00:11:12,560 --> 00:11:18,290
that's easy to use so go as a garbage

00:11:14,840 --> 00:11:21,290
collector which is really awesome it's a

00:11:18,290 --> 00:11:22,970
kind of old-school it's a mark and sweep

00:11:21,290 --> 00:11:23,960
garbage collector but they're actually

00:11:22,970 --> 00:11:27,130
improving it as we go

00:11:23,960 --> 00:11:31,250
so you have garbage collection you have

00:11:27,130 --> 00:11:33,320
a small speck so the ghost speck I think

00:11:31,250 --> 00:11:35,900
printed out is fifty pages I think it

00:11:33,320 --> 00:11:37,970
took me like four hours to read so

00:11:35,900 --> 00:11:40,340
there's just not a lot going on in the

00:11:37,970 --> 00:11:43,280
language it is not a language that

00:11:40,340 --> 00:11:46,310
someone has created as part of their PhD

00:11:43,280 --> 00:11:49,220
thesis no disrespect to mr. order ski

00:11:46,310 --> 00:11:50,990
and Scala and your Scala like lots of

00:11:49,220 --> 00:11:53,540
dark corners there are no dark corners

00:11:50,990 --> 00:11:58,280
and go there's no magic and go so one of

00:11:53,540 --> 00:12:00,820
you metaprogramming and Ruby Wow come on

00:11:58,280 --> 00:12:00,820
liars

00:12:01,370 --> 00:12:04,400
everybody does metaprogramming there's

00:12:03,170 --> 00:12:06,230
none of that it's just really

00:12:04,400 --> 00:12:09,770
straightforward which is one of the

00:12:06,230 --> 00:12:11,870
reasons I love the language so much you

00:12:09,770 --> 00:12:14,900
get pointers but no pointer arithmetic

00:12:11,870 --> 00:12:17,810
so I get some sort of safety I get this

00:12:14,900 --> 00:12:19,430
mechanism this lower level paradigm but

00:12:17,810 --> 00:12:24,650
I'm not worried about like stepping into

00:12:19,430 --> 00:12:27,950
somebody else's memory space and it's

00:12:24,650 --> 00:12:30,320
fast so I don't know Rob Pike gives a

00:12:27,950 --> 00:12:32,780
you know mention of whatever compiling

00:12:30,320 --> 00:12:37,090
the Google you know code base but it's

00:12:32,780 --> 00:12:39,320
really fast so anybody do TDD and Java

00:12:37,090 --> 00:12:43,010
what's the one thing that makes it a

00:12:39,320 --> 00:12:44,810
little weird to do TDD in Java the JVM

00:12:43,010 --> 00:12:46,040
startup time like you won't go to run

00:12:44,810 --> 00:12:48,260
your tests and you're like alright sweet

00:12:46,040 --> 00:12:49,820
and we've seen that xkcd the compiling

00:12:48,260 --> 00:12:53,690
one where they're on chairs like sword

00:12:49,820 --> 00:12:55,610
fighting yeah go doesn't have that we

00:12:53,690 --> 00:12:57,860
actually can get into a really nice TDD

00:12:55,610 --> 00:13:00,330
cycle with go because it compiles so

00:12:57,860 --> 00:13:02,680
fast and it starts up and runs so fast

00:13:00,330 --> 00:13:03,280
I talked about the lightweight type

00:13:02,680 --> 00:13:05,680
system

00:13:03,280 --> 00:13:13,210
I love Scala but the type system is just

00:13:05,680 --> 00:13:15,700
kind of mind-bending sometimes go has go

00:13:13,210 --> 00:13:20,650
as support for a network and multi-core

00:13:15,700 --> 00:13:22,360
computing built-in so we've got in three

00:13:20,650 --> 00:13:25,990
lines of code I can stand up an HTTP

00:13:22,360 --> 00:13:28,090
server and go and with one keyword I can

00:13:25,990 --> 00:13:29,530
may set make something asynchronous it's

00:13:28,090 --> 00:13:31,150
called a go routine you literally put

00:13:29,530 --> 00:13:34,270
the keyword go in front of a function

00:13:31,150 --> 00:13:36,370
call and I now have concurrency I have a

00:13:34,270 --> 00:13:37,180
thing called channels and go which allow

00:13:36,370 --> 00:13:39,100
me to do

00:13:37,180 --> 00:13:45,040
concurrency so every right read the CSP

00:13:39,100 --> 00:13:45,550
paper from horror really Wow cool that's

00:13:45,040 --> 00:13:49,510
awesome

00:13:45,550 --> 00:13:51,970
I had this notion of channels which it's

00:13:49,510 --> 00:13:54,250
like a telephone I have two ends to it I

00:13:51,970 --> 00:13:56,080
hand one end to my go routine which I

00:13:54,250 --> 00:13:58,660
think of it like a server running in my

00:13:56,080 --> 00:13:59,980
process I keep the other end and when I

00:13:58,660 --> 00:14:01,120
need something from the server

00:13:59,980 --> 00:14:03,070
I call it up and say hey you got

00:14:01,120 --> 00:14:04,750
anything for me and if it doesn't answer

00:14:03,070 --> 00:14:07,120
because it doesn't have anything for me

00:14:04,750 --> 00:14:08,890
I just sit and wait and then when it

00:14:07,120 --> 00:14:10,470
does it puts something on the channel I

00:14:08,890 --> 00:14:12,670
can go about my business because

00:14:10,470 --> 00:14:15,460
concurrency is so cheap and go

00:14:12,670 --> 00:14:17,350
I can I can spin up thousands of go

00:14:15,460 --> 00:14:20,050
routines I think the logger Gator server

00:14:17,350 --> 00:14:22,030
that I'll talk about a little bit has 20

00:14:20,050 --> 00:14:24,190
go routines out of the box just kind of

00:14:22,030 --> 00:14:26,350
idling so I'm just spinning these things

00:14:24,190 --> 00:14:27,820
up waiting for things to happen it's

00:14:26,350 --> 00:14:29,110
very much like a vent driven programming

00:14:27,820 --> 00:14:31,510
and that's where I get my concurrency

00:14:29,110 --> 00:14:32,980
safety is I only have one go routine

00:14:31,510 --> 00:14:34,840
running at a time and if I'm waiting on

00:14:32,980 --> 00:14:36,910
something from another go routine I'm

00:14:34,840 --> 00:14:39,460
blocked waiting on that other thing to

00:14:36,910 --> 00:14:40,180
rock so built into the language is not a

00:14:39,460 --> 00:14:41,530
library

00:14:40,180 --> 00:14:43,330
that is not a bolt-on it is not

00:14:41,530 --> 00:14:45,190
third-party is built into the library

00:14:43,330 --> 00:14:48,010
and that was the way they could assure

00:14:45,190 --> 00:14:50,430
that it actually worked well yes

00:14:48,010 --> 00:14:50,430
question

00:14:52,490 --> 00:14:56,810
I have no idea how it's implemented has

00:14:55,070 --> 00:14:58,399
not deferred nor promises it's built

00:14:56,810 --> 00:15:02,450
into the language it is this this whole

00:14:58,399 --> 00:15:04,490
paradigm of I have these freely running

00:15:02,450 --> 00:15:05,990
processes I think of them as like the

00:15:04,490 --> 00:15:08,600
way they describe them is I have servers

00:15:05,990 --> 00:15:10,220
running inside of my memory space and I

00:15:08,600 --> 00:15:12,020
have clients also running inside of my

00:15:10,220 --> 00:15:14,540
memory space and they are simply

00:15:12,020 --> 00:15:16,220
mechanisms that when I ask for something

00:15:14,540 --> 00:15:18,500
off of a channel if that channel does

00:15:16,220 --> 00:15:19,970
not have anything for me I block I just

00:15:18,500 --> 00:15:21,800
stop running and the go routines

00:15:19,970 --> 00:15:23,959
scheduler schedules other people around

00:15:21,800 --> 00:15:26,240
me and then when something comes onto

00:15:23,959 --> 00:15:27,800
that channel when it comes back and says

00:15:26,240 --> 00:15:30,080
hey are you ready to run I can say yep I

00:15:27,800 --> 00:15:33,260
got an answer I'm ready to go and they

00:15:30,080 --> 00:15:35,060
eliminate this mechanism of multiple

00:15:33,260 --> 00:15:37,700
things operating on the same thing you

00:15:35,060 --> 00:15:39,170
can still do that you can still kind of

00:15:37,700 --> 00:15:41,570
shoot yourself in the foot with sharing

00:15:39,170 --> 00:15:42,890
memory but the cool thing about go is

00:15:41,570 --> 00:15:45,050
they actually have a tool built-in

00:15:42,890 --> 00:15:46,580
called the race detector which will tell

00:15:45,050 --> 00:15:48,980
me as my tests are running whether or

00:15:46,580 --> 00:15:50,779
not I have a possible race condition so

00:15:48,980 --> 00:15:52,190
they haven't prevented me from shooting

00:15:50,779 --> 00:15:53,899
myself in the foot they've kind of just

00:15:52,190 --> 00:15:56,089
put the safety on and told me like hey

00:15:53,899 --> 00:15:58,310
don't take the safety off other

00:15:56,089 --> 00:15:59,899
languages kind of hands you a gun the

00:15:58,310 --> 00:16:01,070
safety might be on or off they don't

00:15:59,899 --> 00:16:03,529
tell you how to put me I'll put the

00:16:01,070 --> 00:16:04,880
safety back on so they've done a lot of

00:16:03,529 --> 00:16:06,380
things to make it a lot simpler for me

00:16:04,880 --> 00:16:07,850
to do concurrency which is a huge thing

00:16:06,380 --> 00:16:10,520
right now like I said the logger Gator

00:16:07,850 --> 00:16:14,480
is 2020 go routines just idling waiting

00:16:10,520 --> 00:16:16,630
for requests it also allows me to think

00:16:14,480 --> 00:16:19,279
yes sir

00:16:16,630 --> 00:16:19,640
sure am I not being serious enough for

00:16:19,279 --> 00:16:24,500
you

00:16:19,640 --> 00:16:26,720
I believe you can so there is a thing

00:16:24,500 --> 00:16:29,180
called C go I don't know a ton about it

00:16:26,720 --> 00:16:31,760
but it is the mechanism that they use to

00:16:29,180 --> 00:16:35,000
communicate with C I said I believe you

00:16:31,760 --> 00:16:36,560
can do C++ and go but I'm sure they've

00:16:35,000 --> 00:16:40,550
got some documentation on annotation on

00:16:36,560 --> 00:16:42,410
that yeah so you've got this whole this

00:16:40,550 --> 00:16:46,750
whole idea of concurrency the networking

00:16:42,410 --> 00:16:49,880
built in like UNIX sockets all built in

00:16:46,750 --> 00:16:51,230
again jet packs like this is what I want

00:16:49,880 --> 00:16:53,209
as a developer I don't want to have to

00:16:51,230 --> 00:16:55,910
think about all of this stuff this whole

00:16:53,209 --> 00:16:58,640
blocking mentality allows me to think

00:16:55,910 --> 00:17:00,410
more linearly about my programs so I can

00:16:58,640 --> 00:17:02,300
reason about them and that's why we get

00:17:00,410 --> 00:17:04,309
concurrency problems if I can't reason

00:17:02,300 --> 00:17:05,870
about my software in my head and I'm

00:17:04,309 --> 00:17:07,130
getting older and I can't reason as well

00:17:05,870 --> 00:17:08,809
and my

00:17:07,130 --> 00:17:11,030
that's where we get into problems this

00:17:08,809 --> 00:17:12,919
concurrency model allows me to reason a

00:17:11,030 --> 00:17:18,470
lot more clearly of what's going on in

00:17:12,919 --> 00:17:20,569
my system and the build a large

00:17:18,470 --> 00:17:23,689
executable like we don't have gigantic

00:17:20,569 --> 00:17:27,500
executables I think the CLI executable

00:17:23,689 --> 00:17:30,350
when gzipped is 1.5 Meg which includes

00:17:27,500 --> 00:17:34,400
the full go runtime blogger gator what's

00:17:30,350 --> 00:17:38,120
logger gator alex 1.9 Meg for a logger

00:17:34,400 --> 00:17:39,710
Gator server so relatively small but

00:17:38,120 --> 00:17:41,690
they're fast like I said I can get into

00:17:39,710 --> 00:17:43,220
a TDD cycle like literally have my tests

00:17:41,690 --> 00:17:45,559
running in a window and just watch them

00:17:43,220 --> 00:17:47,750
go as soon as as soon as I save an

00:17:45,559 --> 00:17:50,179
intelligence a of the files tests are

00:17:47,750 --> 00:17:52,190
running and tests are green again most

00:17:50,179 --> 00:18:00,220
of the tests run in less than like two

00:17:52,190 --> 00:18:03,290
milliseconds three milliseconds kind of

00:18:00,220 --> 00:18:07,250
this go oh sorry discover a bus testing

00:18:03,290 --> 00:18:09,410
framework around it so they have taken

00:18:07,250 --> 00:18:11,419
the very bare-bones approach there's a

00:18:09,410 --> 00:18:12,919
testing framework built in how many

00:18:11,419 --> 00:18:15,350
people are familiar with X unit type

00:18:12,919 --> 00:18:17,270
style testing it's even lower level than

00:18:15,350 --> 00:18:20,270
that like I don't even have assertions

00:18:17,270 --> 00:18:21,860
and go what I do is have this testing

00:18:20,270 --> 00:18:24,410
object that I can either say yes or no

00:18:21,860 --> 00:18:26,510
it passed or failed there are political

00:18:24,410 --> 00:18:27,950
reasons for that many of which are found

00:18:26,510 --> 00:18:30,169
on the mailing list we've actually

00:18:27,950 --> 00:18:32,390
chosen to go with an assertion library

00:18:30,169 --> 00:18:34,669
so very much our tests look very X unit

00:18:32,390 --> 00:18:36,770
like and we've been super happy with

00:18:34,669 --> 00:18:38,000
them super happy with the testing but

00:18:36,770 --> 00:18:39,410
it's built into the language so it is

00:18:38,000 --> 00:18:42,950
like a first-class citizen it's not this

00:18:39,410 --> 00:18:45,230
bolt on so what do they do they rewrote

00:18:42,950 --> 00:18:49,250
they wrote a new language so I mean you

00:18:45,230 --> 00:18:53,570
think about it C 1970s C++ 1980s Java

00:18:49,250 --> 00:18:56,570
1995 we haven't seen any way even Ruby I

00:18:53,570 --> 00:18:58,160
mean Ruby was like 94 93 94 we haven't

00:18:56,570 --> 00:19:01,210
seen a new language come out that

00:18:58,160 --> 00:19:01,210
addresses this stuff

00:19:04,759 --> 00:19:10,799
that's we get we get go but we don't get

00:19:08,519 --> 00:19:12,960
as a box of Lego's so this is the other

00:19:10,799 --> 00:19:14,970
thing I love about go is it's not a just

00:19:12,960 --> 00:19:17,309
gigantic box of Lego's anybody had this

00:19:14,970 --> 00:19:21,330
as a kid get this gigantic box leaves I

00:19:17,309 --> 00:19:25,350
can build anything I want like six

00:19:21,330 --> 00:19:28,490
months later what I get is I get a kit

00:19:25,350 --> 00:19:32,039
for assembling stuff system software

00:19:28,490 --> 00:19:34,230
very much like the x-wing I have these

00:19:32,039 --> 00:19:35,850
pieces it shocks me every day I write

00:19:34,230 --> 00:19:37,169
code I go to reach for something I'm

00:19:35,850 --> 00:19:39,360
like I need a socket library or any

00:19:37,169 --> 00:19:41,610
crypto and you're like oh there's a

00:19:39,360 --> 00:19:43,379
standard library for that they really

00:19:41,610 --> 00:19:45,659
sat down and said what is the things I

00:19:43,379 --> 00:19:48,210
need to write software systems level

00:19:45,659 --> 00:19:49,980
software and they put it in go and it's

00:19:48,210 --> 00:19:56,009
it's been really really impressive to

00:19:49,980 --> 00:19:57,240
see how well that's worked out this is

00:19:56,009 --> 00:19:59,129
one of my favorite codes from a friend

00:19:57,240 --> 00:20:00,450
of mine writing boring code that does

00:19:59,129 --> 00:20:03,649
exciting things is greater than writing

00:20:00,450 --> 00:20:05,999
exciting code that does boring things I

00:20:03,649 --> 00:20:08,519
feel very much this way when I'm writing

00:20:05,999 --> 00:20:11,369
go the code is not exciting it is not

00:20:08,519 --> 00:20:17,070
sexy metaprogramming it is not a lot of

00:20:11,369 --> 00:20:19,889
hotness a lot of air handling and go a

00:20:17,070 --> 00:20:23,369
lot of if air not equal to nail curly

00:20:19,889 --> 00:20:25,669
braces but it is it lets me do really

00:20:23,369 --> 00:20:25,669
cool things

00:20:27,500 --> 00:20:33,710
so a little bit of a background on what

00:20:29,809 --> 00:20:36,080
we're using it for as I said the first

00:20:33,710 --> 00:20:40,130
one is the logging agent so how many

00:20:36,080 --> 00:20:43,570
people abused Heroku Heroku logs - -

00:20:40,130 --> 00:20:46,100
tail this is our baby

00:20:43,570 --> 00:20:48,380
relatively new didn't exist in Cloud

00:20:46,100 --> 00:20:51,049
Foundry up until recently we've gone

00:20:48,380 --> 00:20:52,820
into private beta within the company on

00:20:51,049 --> 00:20:54,230
Friday so congratulations as a logger

00:20:52,820 --> 00:20:58,250
Gator team for getting that on running

00:20:54,230 --> 00:21:00,530
it's pretty exciting written didn't go

00:20:58,250 --> 00:21:02,840
so a couple of pieces to this this is

00:21:00,530 --> 00:21:06,320
the business end of the logger Gator so

00:21:02,840 --> 00:21:09,320
what we have here as Matthew explained

00:21:06,320 --> 00:21:11,020
you have the DEA inside of the DEA are

00:21:09,320 --> 00:21:13,100
these things called warden containers

00:21:11,020 --> 00:21:16,490
it's called warden because it's like a

00:21:13,100 --> 00:21:18,260
jail and the user apps run inside of the

00:21:16,490 --> 00:21:19,880
warden containers and what we're doing

00:21:18,260 --> 00:21:22,549
with logger Gators were we want to

00:21:19,880 --> 00:21:24,080
aggregate your user logs you know active

00:21:22,549 --> 00:21:26,090
record logs and things like that so what

00:21:24,080 --> 00:21:28,070
warden does is warden writes standard

00:21:26,090 --> 00:21:31,370
air and standard out onto UNIX sockets

00:21:28,070 --> 00:21:34,220
and that is kind of the door in the jail

00:21:31,370 --> 00:21:35,809
cell like the little door that they push

00:21:34,220 --> 00:21:39,260
the food through to the prisoners that's

00:21:35,809 --> 00:21:40,970
how we get our log messages we're also

00:21:39,260 --> 00:21:42,530
doing the same thing with the router the

00:21:40,970 --> 00:21:44,179
cloud controller the service gateway so

00:21:42,530 --> 00:21:46,909
we want to eventually at some point with

00:21:44,179 --> 00:21:49,130
logger Gator be able to take all of the

00:21:46,909 --> 00:21:52,130
logs about your apps and not only user

00:21:49,130 --> 00:21:54,320
logs but router logs like hey I routed

00:21:52,130 --> 00:21:58,010
this request to this instance on this

00:21:54,320 --> 00:21:59,840
DEA all that stuff from the UAA and then

00:21:58,010 --> 00:22:00,289
what we did is we ended up using go for

00:21:59,840 --> 00:22:02,840
this

00:22:00,289 --> 00:22:05,030
we made it super simple we use the UNIX

00:22:02,840 --> 00:22:07,280
socket as a layer of abstraction between

00:22:05,030 --> 00:22:09,140
the outside and the inside we were

00:22:07,280 --> 00:22:10,340
forced to do that with warden but we

00:22:09,140 --> 00:22:12,490
were not forced to do that with the rest

00:22:10,340 --> 00:22:15,830
of them so we've done is we've written

00:22:12,490 --> 00:22:18,350
like Ruby and go things that run inside

00:22:15,830 --> 00:22:20,210
of our processes and then this single

00:22:18,350 --> 00:22:22,100
generic agent that sits on the outside

00:22:20,210 --> 00:22:25,580
of the UNIX socket and simply listens

00:22:22,100 --> 00:22:29,480
for messages and ships that off to the

00:22:25,580 --> 00:22:30,770
logger Gator so really nice we have one

00:22:29,480 --> 00:22:32,900
generic piece and then a bunch of

00:22:30,770 --> 00:22:35,230
customized pieces on the inside of these

00:22:32,900 --> 00:22:35,230
things

00:22:35,730 --> 00:22:43,560
I would get to that in a second so the

00:22:42,390 --> 00:22:44,850
question was what are we using to get

00:22:43,560 --> 00:22:46,940
back to the aggregator I'll get to that

00:22:44,850 --> 00:22:51,360
in a second

00:22:46,940 --> 00:22:53,700
the biggest concern we have here

00:22:51,360 --> 00:22:57,630
especially on a DEA which is where

00:22:53,700 --> 00:22:59,700
client code runs is CPU usage so we

00:22:57,630 --> 00:23:01,650
don't want these agents sucking up a ton

00:22:59,700 --> 00:23:03,330
of cycles because the more cycles the

00:23:01,650 --> 00:23:05,790
agent sucks up the less cycles we can

00:23:03,330 --> 00:23:07,410
sell to our clients on run pivotal IO or

00:23:05,790 --> 00:23:08,880
if you're running behind your firewall

00:23:07,410 --> 00:23:11,930
you just have to buy that much more

00:23:08,880 --> 00:23:16,530
hardware to keep the apps up and running

00:23:11,930 --> 00:23:18,810
so we chose go we did some load testing

00:23:16,530 --> 00:23:20,670
I was actually not involved in the load

00:23:18,810 --> 00:23:23,630
testing but I heard kind of secondhand

00:23:20,670 --> 00:23:25,950
from a bunch of folks at full capacity

00:23:23,630 --> 00:23:27,720
we're literally sending enough log

00:23:25,950 --> 00:23:29,520
messages where warden shuts the

00:23:27,720 --> 00:23:33,090
application down because the application

00:23:29,520 --> 00:23:36,570
is using too much memory the DEA agent

00:23:33,090 --> 00:23:38,340
runs at half a percent CPU usage like

00:23:36,570 --> 00:23:40,980
almost nothing as this thing is getting

00:23:38,340 --> 00:23:42,120
crushed with log messages and it's not

00:23:40,980 --> 00:23:43,470
doing a whole lot it's literally just

00:23:42,120 --> 00:23:44,700
taking a message from here and like

00:23:43,470 --> 00:23:51,750
shipping it off to the thing but

00:23:44,700 --> 00:23:52,740
literally half of CPI 4% CPU usage and

00:23:51,750 --> 00:23:56,040
that was like wow

00:23:52,740 --> 00:23:58,680
that's pretty amazing so that's the next

00:23:56,040 --> 00:24:00,540
piece came up here of how we were

00:23:58,680 --> 00:24:02,790
getting things so this is the kind of

00:24:00,540 --> 00:24:04,800
the meat and potatoes of it so as those

00:24:02,790 --> 00:24:06,960
messages come out of the applications

00:24:04,800 --> 00:24:09,210
and out of the pieces they end up in

00:24:06,960 --> 00:24:12,720
this big lager Gator server and it is

00:24:09,210 --> 00:24:15,420
simple I think are you guys still at UDP

00:24:12,720 --> 00:24:17,640
sockets Alex still using UDP sockets

00:24:15,420 --> 00:24:21,750
again just like okay we drop a couple

00:24:17,640 --> 00:24:24,150
you know so be it and we've actually now

00:24:21,750 --> 00:24:25,770
just begun the scaling of this thing so

00:24:24,150 --> 00:24:27,120
we originally wrote it we wrote for one

00:24:25,770 --> 00:24:29,130
instance of logger Gator we're just

00:24:27,120 --> 00:24:31,620
gonna hammer this thing we've now begun

00:24:29,130 --> 00:24:34,080
to scale it horizontally and that work

00:24:31,620 --> 00:24:36,570
has begun so what we've done now is we

00:24:34,080 --> 00:24:38,850
have a little router the router hashing

00:24:36,570 --> 00:24:40,980
proxy thing that sits around the storage

00:24:38,850 --> 00:24:43,380
servers is now just a layer that is

00:24:40,980 --> 00:24:45,570
hashing so when a message comes in that

00:24:43,380 --> 00:24:47,370
thing gets hit it figures out what

00:24:45,570 --> 00:24:48,970
instance of law grater server it needs

00:24:47,370 --> 00:24:51,220
to go to and it ships it off

00:24:48,970 --> 00:24:53,440
so we're doing the hashing in another

00:24:51,220 --> 00:24:54,970
little go program so we got all these

00:24:53,440 --> 00:24:57,190
little pieces that we can slot together

00:24:54,970 --> 00:24:58,930
all again using network communications

00:24:57,190 --> 00:25:02,710
all these really low-level things all

00:24:58,930 --> 00:25:05,170
built in to go and then the piece you're

00:25:02,710 --> 00:25:07,720
not seeing which is the far left side of

00:25:05,170 --> 00:25:09,580
that is where when you connect a tail so

00:25:07,720 --> 00:25:11,320
we'd use WebSockets for that there's

00:25:09,580 --> 00:25:13,840
another piece that's written in ruby in

00:25:11,320 --> 00:25:16,120
the CLI right now that uses the same

00:25:13,840 --> 00:25:19,180
thing on the other end to say hey I'm

00:25:16,120 --> 00:25:21,100
looking for log messages from app XYZ

00:25:19,180 --> 00:25:22,750
which logger gator server do I talk to

00:25:21,100 --> 00:25:24,550
so that's how we've decided to do

00:25:22,750 --> 00:25:25,810
horizontal scaling is we're gonna pin

00:25:24,550 --> 00:25:27,100
you to one of these servers and we're

00:25:25,810 --> 00:25:28,870
gonna write these little agents that

00:25:27,100 --> 00:25:30,160
tell me where you're where you end up in

00:25:28,870 --> 00:25:32,700
what logger Gator server you're going to

00:25:30,160 --> 00:25:36,430
do the other piece of logger Gator so

00:25:32,700 --> 00:25:40,630
outside of the streaming is short-term

00:25:36,430 --> 00:25:43,210
storage of your log messages so if you

00:25:40,630 --> 00:25:44,680
don't connect anything to logger Gator

00:25:43,210 --> 00:25:47,080
you're we're going to drop your messages

00:25:44,680 --> 00:25:48,850
on the floor we do have a short-term

00:25:47,080 --> 00:25:50,710
window I don't know what we're at right

00:25:48,850 --> 00:25:53,200
now as far as how long we'll hold onto

00:25:50,710 --> 00:25:54,610
them but you can dump your logs so I

00:25:53,200 --> 00:25:55,810
want to dump my logs and we'll give you

00:25:54,610 --> 00:25:57,430
whatever we have I think we're

00:25:55,810 --> 00:25:58,750
guaranteeing like the let in the last

00:25:57,430 --> 00:26:00,490
hour

00:25:58,750 --> 00:26:02,680
the third piece being that if you want

00:26:00,490 --> 00:26:04,330
persistent storage of your logs you're

00:26:02,680 --> 00:26:06,160
gonna connect something like Splunk to

00:26:04,330 --> 00:26:08,380
this thing so implementing the Heroku

00:26:06,160 --> 00:26:09,460
drain API you could connect a service

00:26:08,380 --> 00:26:10,930
and we'll just dump them out there

00:26:09,460 --> 00:26:12,670
forever and you can do your log r again

00:26:10,930 --> 00:26:15,940
over there what logger gator is not as a

00:26:12,670 --> 00:26:20,710
log aggregation analysis service it is

00:26:15,940 --> 00:26:22,720
simply a broker for you know collating

00:26:20,710 --> 00:26:24,670
all the messages holding onto them for a

00:26:22,720 --> 00:26:29,500
short period of time and then sending

00:26:24,670 --> 00:26:32,380
them out the really interesting thing

00:26:29,500 --> 00:26:34,870
about this is that this project for

00:26:32,380 --> 00:26:37,540
everybody on the team is our first shot

00:26:34,870 --> 00:26:40,090
at writing go none of us had written go

00:26:37,540 --> 00:26:42,220
professionally before this the code

00:26:40,090 --> 00:26:44,380
started out kind of messy we started to

00:26:42,220 --> 00:26:46,300
think really object-oriented like we

00:26:44,380 --> 00:26:47,940
were writing Ruby and Go which caused us

00:26:46,300 --> 00:26:50,170
a little bit of pain for a little while

00:26:47,940 --> 00:26:51,880
the one big thing I learned with go is

00:26:50,170 --> 00:26:53,050
that if you're writing go check your

00:26:51,880 --> 00:26:54,670
object-oriented brain at the door

00:26:53,050 --> 00:26:55,300
because it go is not an object-oriented

00:26:54,670 --> 00:26:57,310
language

00:26:55,300 --> 00:26:58,570
it has concepts about pin to orientation

00:26:57,310 --> 00:26:59,910
but it is not an object-oriented

00:26:58,570 --> 00:27:05,700
language you'll only cause you

00:26:59,910 --> 00:27:07,470
if you do that but in I think how many

00:27:05,700 --> 00:27:14,730
weeks are we at now on longer Gator

00:27:07,470 --> 00:27:16,620
tammer three months we have a fully

00:27:14,730 --> 00:27:18,450
functioning server already in production

00:27:16,620 --> 00:27:20,670
from a bunch of engineers I'd never

00:27:18,450 --> 00:27:23,250
written go before our lives so a pretty

00:27:20,670 --> 00:27:24,930
quick ramp up time like I said it was a

00:27:23,250 --> 00:27:27,270
little painful at the beginning we wrote

00:27:24,930 --> 00:27:29,610
code it was working we refactored a

00:27:27,270 --> 00:27:31,530
bunch so that type system came in really

00:27:29,610 --> 00:27:33,420
handy as we were tearing the pieces

00:27:31,530 --> 00:27:36,270
apart to try and make them more

00:27:33,420 --> 00:27:37,800
idiomatic which is awesome you're like

00:27:36,270 --> 00:27:39,780
sweet the compiler is telling me that a

00:27:37,800 --> 00:27:42,110
is not plugged in to be awesome I plug

00:27:39,780 --> 00:27:45,210
it into B and everybody everything works

00:27:42,110 --> 00:27:46,290
so that was really cool I think that you

00:27:45,210 --> 00:27:48,060
know that's the biggest concern that

00:27:46,290 --> 00:27:49,500
people have when you start talking go is

00:27:48,060 --> 00:27:50,910
like oh it's a brand new language and

00:27:49,500 --> 00:27:52,770
who's gonna write it for you and this

00:27:50,910 --> 00:27:54,870
that and the other thing I mean you're

00:27:52,770 --> 00:27:56,100
talking seasoned ended engineers so most

00:27:54,870 --> 00:27:58,530
of those in writing software for a long

00:27:56,100 --> 00:28:00,480
time but we'd never seen go before so

00:27:58,530 --> 00:28:03,270
really easy to translate the mental

00:28:00,480 --> 00:28:08,900
model in our heads onto paper and onto

00:28:03,270 --> 00:28:08,900
paper into code yes sir

00:28:19,620 --> 00:28:23,220
so the question was what is the plan to

00:28:21,690 --> 00:28:26,340
go full go

00:28:23,220 --> 00:28:28,070
I don't think personally I don't know

00:28:26,340 --> 00:28:30,000
I'm not in charge of those decisions

00:28:28,070 --> 00:28:33,390
personally I would like I would like to

00:28:30,000 --> 00:28:37,140
say no go is a very specific language

00:28:33,390 --> 00:28:38,429
for systems level programming so yes

00:28:37,140 --> 00:28:40,110
things that need to be high throughput

00:28:38,429 --> 00:28:42,029
high scalability I don't see why we

00:28:40,110 --> 00:28:43,620
wouldn't at least try to move them

00:28:42,029 --> 00:28:47,789
towards but like Matthew said the Health

00:28:43,620 --> 00:28:49,500
Manager is going to go the CLI is still

00:28:47,789 --> 00:28:51,210
is really not systems programming I'll

00:28:49,500 --> 00:28:53,909
touch on that like I'll touch on that

00:28:51,210 --> 00:28:55,140
why we did that made that decision but I

00:28:53,909 --> 00:28:57,390
would like to see us write as much go as

00:28:55,140 --> 00:28:59,279
possible I love the language I love Ruby

00:28:57,390 --> 00:29:02,100
too but for stuff like this

00:28:59,279 --> 00:29:05,100
I don't want Java just too heavy like to

00:29:02,100 --> 00:29:06,960
blow tea I do not want to rewriting C++

00:29:05,100 --> 00:29:09,990
like it just I don't want that I would I

00:29:06,960 --> 00:29:12,179
really want to write go I get that I get

00:29:09,990 --> 00:29:13,470
the kind of the syntax of Ruby and I'm

00:29:12,179 --> 00:29:14,850
more than happy if like somebody wants

00:29:13,470 --> 00:29:15,779
to see the go code I'm more than happy

00:29:14,850 --> 00:29:17,760
to step through that with people

00:29:15,779 --> 00:29:20,330
the syntax of Ruby kind of the ease of

00:29:17,760 --> 00:29:28,380
use without all of the sharp edges of

00:29:20,330 --> 00:29:30,179
obscene C++ so here open source you can

00:29:28,380 --> 00:29:31,440
go take a look at it as I said I'm more

00:29:30,179 --> 00:29:32,909
than happy to step through code with

00:29:31,440 --> 00:29:34,440
people if they want to talk about it we

00:29:32,909 --> 00:29:36,270
have two members from the logger current

00:29:34,440 --> 00:29:37,440
lager Gator team here as well so if you

00:29:36,270 --> 00:29:39,929
want to take a look at you want to talk

00:29:37,440 --> 00:29:42,630
to us about it please come find us and

00:29:39,929 --> 00:29:46,230
we will chat through that with you the

00:29:42,630 --> 00:29:48,899
second piece as Matthew said is the CLI

00:29:46,230 --> 00:29:51,390
so that's a lot of words pretty much

00:29:48,899 --> 00:29:54,299
Matthew so stole my thunder our pig pain

00:29:51,390 --> 00:29:57,840
point was distribution so as a Java

00:29:54,299 --> 00:29:59,789
developer as a Python developer as a

00:29:57,840 --> 00:30:01,350
developer there was not anything doesn't

00:29:59,789 --> 00:30:04,409
right Ruby why do I need a ruby

00:30:01,350 --> 00:30:06,929
installation on my machine Ruby gems is

00:30:04,409 --> 00:30:11,640
hard if I'm running Windows like that's

00:30:06,929 --> 00:30:14,010
crazy town just to begin with it is I

00:30:11,640 --> 00:30:16,080
mean trust me we had a large client

00:30:14,010 --> 00:30:18,990
whose name will remain nameless we

00:30:16,080 --> 00:30:20,820
showed up with ruby gems and was not an

00:30:18,990 --> 00:30:23,039
option we literally had to go back and

00:30:20,820 --> 00:30:25,230
like figure out how to compile we

00:30:23,039 --> 00:30:27,990
actually had went to J Ruby compiled a

00:30:25,230 --> 00:30:30,730
war file and use Java to run our Ruby

00:30:27,990 --> 00:30:33,420
process on Windows

00:30:30,730 --> 00:30:36,010
it was a kind of a big black eye for us

00:30:33,420 --> 00:30:37,510
yeah it was bad news and window I mean

00:30:36,010 --> 00:30:40,660
it's just windows is not well supported

00:30:37,510 --> 00:30:42,790
in the Ruby community it just isn't so

00:30:40,660 --> 00:30:44,740
we decided to go to go there it is up

00:30:42,790 --> 00:30:47,560
and running so right now we're calling

00:30:44,740 --> 00:30:50,740
it go - cf that is running code we've

00:30:47,560 --> 00:30:53,620
been going for three weeks on this and

00:30:50,740 --> 00:30:55,630
James how are we doing yeah

00:30:53,620 --> 00:30:58,540
so James says we're doing awesome we

00:30:55,630 --> 00:31:01,180
have most of the functionality for

00:30:58,540 --> 00:31:03,760
managing Application Lifecycle so we can

00:31:01,180 --> 00:31:05,500
push an app we can we can log in we can

00:31:03,760 --> 00:31:10,030
target we can push an app we can now set

00:31:05,500 --> 00:31:13,930
services Friday we finished up listing

00:31:10,030 --> 00:31:15,970
stacks yeah so it's good it's coming

00:31:13,930 --> 00:31:21,970
along real Oh again three weeks we're

00:31:15,970 --> 00:31:24,430
just flying through this stuff we were

00:31:21,970 --> 00:31:28,780
not the first ones to do this so anybody

00:31:24,430 --> 00:31:31,750
know Packer IO we they were actually the

00:31:28,780 --> 00:31:35,560
first one Mitchell has been very adamant

00:31:31,750 --> 00:31:36,820
about never writing a ruby gem again he

00:31:35,560 --> 00:31:38,050
just lays it's not worth it if you're

00:31:36,820 --> 00:31:38,530
just ribbing software so it's not worth

00:31:38,050 --> 00:31:41,500
it anymore

00:31:38,530 --> 00:31:43,450
again I don't want Legos I want the Star

00:31:41,500 --> 00:31:44,860
Destroyer this is what I want to hand

00:31:43,450 --> 00:31:47,560
our clients I want to hand them one

00:31:44,860 --> 00:31:49,240
statically compiled binary that they can

00:31:47,560 --> 00:31:51,220
simply upload so another for systems

00:31:49,240 --> 00:31:53,290
programming all you sis admins how much

00:31:51,220 --> 00:31:56,170
easier it is to upload one static binary

00:31:53,290 --> 00:31:57,640
and then just bounce the process versus

00:31:56,170 --> 00:32:00,780
trying to like get this like crazy

00:31:57,640 --> 00:32:00,780
bundler thing to work

00:32:03,300 --> 00:32:08,380
so there's been some great talk in the

00:32:06,580 --> 00:32:11,230
community about this Jarrod's in the

00:32:08,380 --> 00:32:13,560
room somewhere yeah I think I saw I only

00:32:11,230 --> 00:32:15,850
recognized him from Twitter pictures

00:32:13,560 --> 00:32:17,650
doctor Nick had a great write-up he

00:32:15,850 --> 00:32:19,510
thanked us for doing this

00:32:17,650 --> 00:32:21,520
it's just great it's like here's a

00:32:19,510 --> 00:32:23,260
binary the other great thing about goes

00:32:21,520 --> 00:32:26,620
I can cross compiled to three operating

00:32:23,260 --> 00:32:28,030
systems on my Mac I can compile OS 10 I

00:32:26,620 --> 00:32:30,340
can compile Linux and I can call it

00:32:28,030 --> 00:32:31,660
Windows all with one script if you go

00:32:30,340 --> 00:32:33,280
into the repo and you go into bin slash

00:32:31,660 --> 00:32:36,100
build all that's how we build all three

00:32:33,280 --> 00:32:40,060
did PI Nerys right under Mac so it's

00:32:36,100 --> 00:32:42,430
kind of nice it's kind of good we also

00:32:40,060 --> 00:32:44,580
have another success story we have a new

00:32:42,430 --> 00:32:46,740
developer started with us this week he

00:32:44,580 --> 00:32:51,460
has never written go before in his life

00:32:46,740 --> 00:32:53,620
he and I worked on a feature he's here

00:32:51,460 --> 00:32:55,510
in San Francisco and we we miss a

00:32:53,620 --> 00:32:57,700
two-hour overlap at the end of the day I

00:32:55,510 --> 00:32:59,650
left him with a half-finished story on

00:32:57,700 --> 00:33:01,810
Friday when I left at 5:00 Boulder time

00:32:59,650 --> 00:33:03,640
by six o'clock San Francisco time he had

00:33:01,810 --> 00:33:07,510
finished this feature and pushed it up

00:33:03,640 --> 00:33:09,760
to github without my help so he was able

00:33:07,510 --> 00:33:10,810
to pick up enough in three days of go

00:33:09,760 --> 00:33:12,160
program three and a half days ago

00:33:10,810 --> 00:33:12,820
program it to finish up the feature

00:33:12,160 --> 00:33:15,070
without me

00:33:12,820 --> 00:33:20,950
so another testament to the ease of use

00:33:15,070 --> 00:33:22,960
of go there's the repo there are my

00:33:20,950 --> 00:33:27,460
credits from my lego pictures and my

00:33:22,960 --> 00:33:30,730
jetpack pictures zoom any questions I'm

00:33:27,460 --> 00:33:32,530
just I'm do I have okay cool I don't

00:33:30,730 --> 00:33:34,180
have any more time but please come find

00:33:32,530 --> 00:33:36,820
me if you have any questions we can chat

00:33:34,180 --> 00:33:37,690
we can look at code yeah thank you very

00:33:36,820 --> 00:33:40,799
much

00:33:37,690 --> 00:33:40,799
[Music]

00:33:44,330 --> 00:33:50,619

YouTube URL: https://www.youtube.com/watch?v=d5aHr8VGU-8


