Title: UAA Project Updates and Roadmap - Sree Tummidi, Pivotal
Publication date: 2017-10-18
Playlist: Cloud Foundry Summit Europe 2017
Description: 
	UAA Project Updates and Roadmap - Sree Tummidi, Pivotal

Cloud Foundry UAA has been continually expanding its horizons to secure not just the core CF platform but also Apps and APIs running on and off the platform. In this talk we will start off with a brief overview of UAA in the CF ecosystem followed by feature highlights including:

OpenID Connect Enhancements: 
Multiple enhancements around OpenID Connect have been introduced for UAA as an Identity Provider and Relying Party including support for discovery profile, custom user claims in id_token and /userinfo , account chooser, authentication method reference and much more.

Keys and Secrets Rotation: 
At last year’s CF Summit Justin Smith introduced his vision for Cloud Native Security with three R’s(https://www.youtube.com/watch?v=NUXpz0Dni50). Now UAA supports canary style rotation of signing keys and OAuth clients secrets and will soon add support for rotation of SAML Keys. 

Opaque Tokens: 
UAA since its inception has supported JSON Web Tokens which has the advantage of offline validation. However with the the addition of stateful opaque tokens UAA now supports on-demand token revocation.

In addition to this we will also provide a sneak peek of the UAA roadmap with features like Multi-Factor Authentication, additional token exchange flows and fine grained authorization support.

About Sree Tummidi
Sree Tummidi is the Product Manager for UAA (User Account and Authentication Service) on Open Source Cloud Foundry since the past 3 Years and drives the Identity and Access Management products for Pivotal. She brings in more than 12 years of experience in the security domain. Prior to joining Pivotal she held multiple Product Management & Engineering positions at CA Technologies. She holds a Masters of Business Administration from Boston University & Bachelors of Engineering in Computer Science from Jawaharlal Nehru Technological University. She has spoken at multiple sales & customer conferences about Identity & Access Management related topics and products. Most recently she spoke at Cloud Foundry Summit Silicon Valley 2017 (http://bit.ly/2sWjlst) and Spring One Platform 2016 about UAA and Cloud Identity (http://bit.ly/2kD1WNB)
Captions: 
	00:00:00,110 --> 00:00:05,700
I'm sorry to me D and I'm the product

00:00:02,939 --> 00:00:07,470
manager for you a a I've been with

00:00:05,700 --> 00:00:09,179
pivotal for three years basically

00:00:07,470 --> 00:00:11,910
responsible for product management of

00:00:09,179 --> 00:00:13,799
UAA and other identity initiatives at

00:00:11,910 --> 00:00:18,990
pivotal including the single sign-on

00:00:13,799 --> 00:00:21,840
service so as part of the talk today

00:00:18,990 --> 00:00:24,210
I'll be providing an overview of UAA in

00:00:21,840 --> 00:00:26,099
terms of its role in cloud foundry and

00:00:24,210 --> 00:00:28,529
how it is securing cloud foundry

00:00:26,099 --> 00:00:31,590
followed by a some recent feature

00:00:28,529 --> 00:00:33,809
updates roadmap and then finally some

00:00:31,590 --> 00:00:41,850
housekeeping and I'll try to leave time

00:00:33,809 --> 00:00:44,250
for Q&A okay so in order to explain what

00:00:41,850 --> 00:00:47,039
is the role of UAA in terms of securing

00:00:44,250 --> 00:00:49,559
the platform let's start off with the

00:00:47,039 --> 00:00:51,600
most known interface which is the cloud

00:00:49,559 --> 00:00:53,730
foundry command-line interface so

00:00:51,600 --> 00:00:56,760
everyone over here has used the CF CLI

00:00:53,730 --> 00:00:58,859
so as an app developer when you specify

00:00:56,760 --> 00:01:01,920
your username and password through the

00:00:58,859 --> 00:01:05,400
CF login process let's try to figure out

00:01:01,920 --> 00:01:08,040
what happens behind the scenes so CF CLI

00:01:05,400 --> 00:01:10,890
as a client is actually going to first

00:01:08,040 --> 00:01:13,020
invoke UA a and in this case it's going

00:01:10,890 --> 00:01:16,200
to be the token endpoint and it's going

00:01:13,020 --> 00:01:19,200
to pass the username the password in the

00:01:16,200 --> 00:01:21,810
client ID and the client secret with CF

00:01:19,200 --> 00:01:24,840
client it's a public line so the secret

00:01:21,810 --> 00:01:27,299
is essentially MP so when you a a

00:01:24,840 --> 00:01:31,670
receives that information what it does

00:01:27,299 --> 00:01:34,049
is it authenticates the user and then it

00:01:31,670 --> 00:01:36,780
basically generates a token which

00:01:34,049 --> 00:01:40,020
represents the identity of the user in

00:01:36,780 --> 00:01:42,329
the context of that client and it

00:01:40,020 --> 00:01:43,530
generates that token and sends it over

00:01:42,329 --> 00:01:46,710
to the CF CLI

00:01:43,530 --> 00:01:49,439
so so far so good now then as an app

00:01:46,710 --> 00:01:52,740
developer you perform an action or a

00:01:49,439 --> 00:01:53,820
command like CF apps so that is

00:01:52,740 --> 00:01:57,659
essentially to get a list of

00:01:53,820 --> 00:02:00,479
applications what the CF CLI does is it

00:01:57,659 --> 00:02:03,090
actually takes the token makes a request

00:02:00,479 --> 00:02:06,509
to the cloud controller API and it

00:02:03,090 --> 00:02:08,129
passes that token in a header so it's

00:02:06,509 --> 00:02:11,340
referred to as an authorization header

00:02:08,129 --> 00:02:13,230
and basically when the cloud controller

00:02:11,340 --> 00:02:16,650
API receives this particular

00:02:13,230 --> 00:02:18,269
Qwest it validates the token now the

00:02:16,650 --> 00:02:21,989
kind of things that propagate in the

00:02:18,269 --> 00:02:24,180
token are the users identity and some

00:02:21,989 --> 00:02:26,459
coarse-grained permissions like are they

00:02:24,180 --> 00:02:27,959
an admin or not right so in in the

00:02:26,459 --> 00:02:30,390
previous presentation there was talk

00:02:27,959 --> 00:02:33,900
about some new permissions like global

00:02:30,390 --> 00:02:36,030
auditor and read-only access so those

00:02:33,900 --> 00:02:38,670
kind of things flow in the token but

00:02:36,030 --> 00:02:40,530
then beyond that if cloud controller has

00:02:38,670 --> 00:02:43,319
to perform some fine-grained decisions

00:02:40,530 --> 00:02:45,239
like is this user a space developer

00:02:43,319 --> 00:02:45,930
that's within the purview of cloud

00:02:45,239 --> 00:02:48,209
controller

00:02:45,930 --> 00:02:50,790
now when cloud controller performs the

00:02:48,209 --> 00:02:54,209
validation of the token it basically

00:02:50,790 --> 00:02:57,930
responds to the CLI with in this case

00:02:54,209 --> 00:02:59,879
the app listing so the previous example

00:02:57,930 --> 00:03:01,349
was Varon there was a user involved

00:02:59,879 --> 00:03:03,450
there was a client and there was the

00:03:01,349 --> 00:03:07,220
cloud controller API there is another

00:03:03,450 --> 00:03:09,959
kind of interaction that UAS occurs is

00:03:07,220 --> 00:03:14,609
essentially component to component so

00:03:09,959 --> 00:03:16,230
something like the CF router which which

00:03:14,609 --> 00:03:18,569
is there in two flavors right you have

00:03:16,230 --> 00:03:22,590
the gore outer and you have the PCP

00:03:18,569 --> 00:03:24,930
router there is a routing API which is

00:03:22,590 --> 00:03:27,510
available for the router to perform

00:03:24,930 --> 00:03:30,180
actions like registration and D

00:03:27,510 --> 00:03:34,109
registration of routes so in that

00:03:30,180 --> 00:03:38,130
particular scenario also UAA is securing

00:03:34,109 --> 00:03:40,230
that interaction so CF router as a

00:03:38,130 --> 00:03:43,650
client is actually going to interact

00:03:40,230 --> 00:03:46,079
with UAA and present its client

00:03:43,650 --> 00:03:48,810
credentials it's a client ID and a

00:03:46,079 --> 00:03:51,030
client secret and when you AAA receives

00:03:48,810 --> 00:03:53,849
it it validates that client ID and

00:03:51,030 --> 00:03:56,010
secret and then generates a token which

00:03:53,849 --> 00:03:57,030
is then passed to the CF router but

00:03:56,010 --> 00:04:00,329
things don't end there

00:03:57,030 --> 00:04:03,329
because now the CF router takes that

00:04:00,329 --> 00:04:05,819
token and makes a request to the routing

00:04:03,329 --> 00:04:07,919
API to perform like a register or

00:04:05,819 --> 00:04:10,949
unregistered of route and then the

00:04:07,919 --> 00:04:14,669
routing API validates the token and once

00:04:10,949 --> 00:04:16,979
it's good then the action is completed

00:04:14,669 --> 00:04:21,930
in this case a registration or an

00:04:16,979 --> 00:04:25,110
registration of a router so we looked at

00:04:21,930 --> 00:04:26,730
how you a is used within CF but what

00:04:25,110 --> 00:04:31,890
makes up UA

00:04:26,730 --> 00:04:35,400
so when you deploy a see a CF right as a

00:04:31,890 --> 00:04:37,110
CF release or a CF deployment there are

00:04:35,400 --> 00:04:41,340
various components that get deployed and

00:04:37,110 --> 00:04:43,830
UAA is one of them UAA is packaged as a

00:04:41,340 --> 00:04:47,190
Bosch release and there are multiple

00:04:43,830 --> 00:04:49,500
jobs within UAE obviously the main one

00:04:47,190 --> 00:04:52,650
is the UAS server which is running

00:04:49,500 --> 00:04:55,410
within our Tomcat and it's essentially a

00:04:52,650 --> 00:04:58,620
JVM process but along with UAA

00:04:55,410 --> 00:05:00,810
or alongside UAA within the same Tomcat

00:04:58,620 --> 00:05:03,950
process there is something called a

00:05:00,810 --> 00:05:07,080
stats D and it is responsible for

00:05:03,950 --> 00:05:10,680
metrics so the metrics that you AAA

00:05:07,080 --> 00:05:14,220
emits are actually encapsulated and

00:05:10,680 --> 00:05:17,520
routed via the stats D component so an

00:05:14,220 --> 00:05:19,830
extension to this metrics in general is

00:05:17,520 --> 00:05:22,740
the collection why's there are two other

00:05:19,830 --> 00:05:25,440
jobs there is the stats D injector and

00:05:22,740 --> 00:05:28,230
the Metron agent which collectively are

00:05:25,440 --> 00:05:30,780
pushing the metrics out of UAA into a

00:05:28,230 --> 00:05:32,670
collection point which is governed by

00:05:30,780 --> 00:05:36,540
the logger Gator architecture so things

00:05:32,670 --> 00:05:40,920
could be streamed over a secured Suslov

00:05:36,540 --> 00:05:42,470
channel or you could have you know like

00:05:40,920 --> 00:05:47,340
things being collected via different

00:05:42,470 --> 00:05:50,730
nozzles so beyond that there are other

00:05:47,340 --> 00:05:54,240
jobs within this VM there is something

00:05:50,730 --> 00:05:58,220
called as route registrar so as the name

00:05:54,240 --> 00:06:01,340
suggests it is for registering UAS route

00:05:58,220 --> 00:06:04,770
with the router so that it is

00:06:01,340 --> 00:06:07,650
discoverable right but then that's for

00:06:04,770 --> 00:06:09,540
external routing now in the previous

00:06:07,650 --> 00:06:12,030
example I explained that a component

00:06:09,540 --> 00:06:14,850
like a router is also interacting with

00:06:12,030 --> 00:06:16,650
UAE but from a latency and a performance

00:06:14,850 --> 00:06:18,720
point of view you don't want those

00:06:16,650 --> 00:06:21,870
things to go out and come back in

00:06:18,720 --> 00:06:24,240
through the router so we have counsel

00:06:21,870 --> 00:06:26,220
for internal service discovery which

00:06:24,240 --> 00:06:28,890
seems like it's going to get replaced by

00:06:26,220 --> 00:06:30,870
bascially and as soon so that will be

00:06:28,890 --> 00:06:33,870
replaced but right as of now when you

00:06:30,870 --> 00:06:36,510
install UA a there is a consul job now

00:06:33,870 --> 00:06:39,600
let's take a look at the things outside

00:06:36,510 --> 00:06:43,160
of this you AVM that ua is interact

00:06:39,600 --> 00:06:46,230
with you a a has a database dependency

00:06:43,160 --> 00:06:48,000
we support Postgres my sequel and we

00:06:46,230 --> 00:06:51,840
recently added support for sequel server

00:06:48,000 --> 00:06:54,330
and so that's the UA a database you a

00:06:51,840 --> 00:06:57,840
database obviously comes with its own a

00:06:54,330 --> 00:07:00,180
set of tables which allow an internal

00:06:57,840 --> 00:07:03,180
user store so you can register user

00:07:00,180 --> 00:07:05,670
accounts in UAE but that's not a typical

00:07:03,180 --> 00:07:07,680
deployment and an enterprise because in

00:07:05,670 --> 00:07:09,930
an enterprise you already have a source

00:07:07,680 --> 00:07:13,440
of truth which could be Active Directory

00:07:09,930 --> 00:07:15,270
or if it has a federated setup you could

00:07:13,440 --> 00:07:18,390
be dealing with a sam'l identity

00:07:15,270 --> 00:07:20,580
provider or a open ID connect identity

00:07:18,390 --> 00:07:23,070
provider which is essentially the new

00:07:20,580 --> 00:07:26,610
buzz so like things like Google's

00:07:23,070 --> 00:07:30,170
identity provider is oh I DC so you AAA

00:07:26,610 --> 00:07:32,580
has the ability to connect out to these

00:07:30,170 --> 00:07:36,690
essentially user stores or federated

00:07:32,580 --> 00:07:40,620
identity stores to get the identity on

00:07:36,690 --> 00:07:44,250
the other side is how does UA a

00:07:40,620 --> 00:07:46,230
interface that the applications so you

00:07:44,250 --> 00:07:48,120
need to have familiarity with OAuth and

00:07:46,230 --> 00:07:51,210
open ID connect to understand this but

00:07:48,120 --> 00:07:54,210
the interface between the application or

00:07:51,210 --> 00:07:57,330
the API and UA a is worth open ID

00:07:54,210 --> 00:07:59,940
Connect typically but UAE is also or

00:07:57,330 --> 00:08:03,060
sam'l identity provider what that means

00:07:59,940 --> 00:08:08,390
is in addition to securing applications

00:08:03,060 --> 00:08:11,550
which are basically you know like

00:08:08,390 --> 00:08:14,520
relying on UA a to get a token they can

00:08:11,550 --> 00:08:16,710
also rely on UA to get an assertion so

00:08:14,520 --> 00:08:19,320
you AAA supports a sam'l identity

00:08:16,710 --> 00:08:24,240
provider profile as well which means

00:08:19,320 --> 00:08:26,310
that applications can rely on you AAA to

00:08:24,240 --> 00:08:29,970
get a sam'l assertion which encapsulate

00:08:26,310 --> 00:08:32,430
the identity beyond that we have an

00:08:29,970 --> 00:08:34,770
admin interface for user and group

00:08:32,430 --> 00:08:37,440
management so we follow a standard

00:08:34,770 --> 00:08:39,360
called scheme which is called system for

00:08:37,440 --> 00:08:42,120
cross domain identity management and

00:08:39,360 --> 00:08:44,730
then we have REST API is for all of our

00:08:42,120 --> 00:08:49,050
management in general so if you're

00:08:44,730 --> 00:08:53,270
managing identity providers zones groups

00:08:49,050 --> 00:08:53,270
users there is a REST API for that

00:08:54,660 --> 00:09:00,060
uan multi-tenancy i don't have to

00:08:57,390 --> 00:09:03,300
explain multi-tenancy here but basically

00:09:00,060 --> 00:09:05,820
you a a is multi-tenant but it's logical

00:09:03,300 --> 00:09:08,730
multi-tenancy as in its logical

00:09:05,820 --> 00:09:12,330
separation so let me explain this with

00:09:08,730 --> 00:09:15,360
use case suppose you want to use you a a

00:09:12,330 --> 00:09:17,640
to secure your applications but you want

00:09:15,360 --> 00:09:19,980
to maintain this boundary which could be

00:09:17,640 --> 00:09:22,020
basically based on your environments so

00:09:19,980 --> 00:09:24,420
you have your dev pre prod and prod

00:09:22,020 --> 00:09:26,220
environment and you want to use separate

00:09:24,420 --> 00:09:27,990
authentication domains for that that

00:09:26,220 --> 00:09:30,750
could be one reason why you want

00:09:27,990 --> 00:09:33,330
separate tenants which are referred to

00:09:30,750 --> 00:09:35,580
as identity zones or as an enterprise

00:09:33,330 --> 00:09:37,290
you could have internal facing

00:09:35,580 --> 00:09:39,150
applications and external facing

00:09:37,290 --> 00:09:41,310
applications so your internal

00:09:39,150 --> 00:09:43,230
applications you may want to keep on one

00:09:41,310 --> 00:09:44,670
authentication domain and your external

00:09:43,230 --> 00:09:46,560
applications you want to apply a

00:09:44,670 --> 00:09:49,680
separate security policy and keep it

00:09:46,560 --> 00:09:51,780
completely separate so you a a supports

00:09:49,680 --> 00:09:55,200
for that model wherein you can create

00:09:51,780 --> 00:09:59,160
multiple identities zones now each zone

00:09:55,200 --> 00:10:01,710
is a UA a in itself so what each zone

00:09:59,160 --> 00:10:04,470
represents is pretty much everything

00:10:01,710 --> 00:10:07,230
that you a a relies on it relies on for

00:10:04,470 --> 00:10:09,750
its functioning so users groups clients

00:10:07,230 --> 00:10:14,880
identity providers group memberships

00:10:09,750 --> 00:10:19,350
mappings it's all pers own now what you

00:10:14,880 --> 00:10:21,480
need to understand is as part of CF

00:10:19,350 --> 00:10:24,060
deployment a UA a is already getting

00:10:21,480 --> 00:10:26,700
pushed so the default zone which is

00:10:24,060 --> 00:10:29,340
accessible typically at login dot or UA

00:10:26,700 --> 00:10:32,280
a dot system domain that is used for

00:10:29,340 --> 00:10:35,190
securing CF itself so when I say CF

00:10:32,280 --> 00:10:38,670
itself it's used for securing the router

00:10:35,190 --> 00:10:41,520
the Cloud Controller API but then beyond

00:10:38,670 --> 00:10:44,970
that you can create more zones so you

00:10:41,520 --> 00:10:46,980
can actually as an operator expose the

00:10:44,970 --> 00:10:49,680
same UA a that is being used for

00:10:46,980 --> 00:10:52,230
securing the platform to actually secure

00:10:49,680 --> 00:10:57,210
apps as well by creating one or more

00:10:52,230 --> 00:10:59,040
identity zones quick look at the token

00:10:57,210 --> 00:11:00,290
format because we'll be going into the

00:10:59,040 --> 00:11:04,339
detail of that later on

00:11:00,290 --> 00:11:07,309
ua a out-of-the-box supports dot which

00:11:04,339 --> 00:11:10,610
Jason web token it mainly has three

00:11:07,309 --> 00:11:12,559
parts as driven by the standard so there

00:11:10,610 --> 00:11:16,910
is the header the body and the footer

00:11:12,559 --> 00:11:19,850
and if you decode this the header is

00:11:16,910 --> 00:11:22,430
carrying meta information about how was

00:11:19,850 --> 00:11:25,519
the token signed so it will carry

00:11:22,430 --> 00:11:28,100
information like the algorithm and the

00:11:25,519 --> 00:11:31,430
key ID so the ID of the key with which

00:11:28,100 --> 00:11:33,709
the jot was signed or the token was

00:11:31,430 --> 00:11:36,980
signed the type is jot in this case

00:11:33,709 --> 00:11:39,019
obviously the main information which is

00:11:36,980 --> 00:11:42,589
the the claims about the user or a

00:11:39,019 --> 00:11:45,860
client will flow within the body some

00:11:42,589 --> 00:11:48,319
important aspects here are subject which

00:11:45,860 --> 00:11:50,660
refers to the identity in this case it's

00:11:48,319 --> 00:11:54,889
a user so it's the user identity and

00:11:50,660 --> 00:11:57,709
then you have something called as origin

00:11:54,889 --> 00:12:00,139
in this case you see that it says UA a

00:11:57,709 --> 00:12:01,970
that means that the user authenticated

00:12:00,139 --> 00:12:03,889
with the internal user store

00:12:01,970 --> 00:12:05,959
so anytime the user authenticates with

00:12:03,889 --> 00:12:08,870
the internal user store then it will say

00:12:05,959 --> 00:12:12,920
UA a but if it were LDAP authentication

00:12:08,870 --> 00:12:14,870
or some other provider like sam'l or

00:12:12,920 --> 00:12:18,199
open ID connect it will be that provider

00:12:14,870 --> 00:12:20,600
alias now why do you need this kind of

00:12:18,199 --> 00:12:22,910
information in the token well if you are

00:12:20,600 --> 00:12:25,189
making downstream authorization

00:12:22,910 --> 00:12:26,839
decisions wherein you want to trigger a

00:12:25,189 --> 00:12:28,759
piece of functionality within the app

00:12:26,839 --> 00:12:31,249
only if the user came in through a

00:12:28,759 --> 00:12:33,949
certain provider you can do such things

00:12:31,249 --> 00:12:37,600
by basically looking at the token

00:12:33,949 --> 00:12:40,579
because it came from a trusted party

00:12:37,600 --> 00:12:42,949
client-side integrations for you AAA you

00:12:40,579 --> 00:12:46,759
all are aware of this we have you AAC

00:12:42,949 --> 00:12:51,079
which is a u ruby gem and it is backed

00:12:46,759 --> 00:12:53,749
by library or the UCF UA a lip we do

00:12:51,079 --> 00:12:55,279
have plans to rewrite this and go so

00:12:53,749 --> 00:12:57,949
we've started a project in incubation

00:12:55,279 --> 00:13:00,259
it's called the UA a CLI it's a

00:12:57,949 --> 00:13:03,589
command-line interface basically return

00:13:00,259 --> 00:13:05,209
and go and we have plans to have the MVP

00:13:03,589 --> 00:13:07,990
basically cover at least all the

00:13:05,209 --> 00:13:11,540
functionality that you AAC provides

00:13:07,990 --> 00:13:13,610
beyond that spring security is something

00:13:11,540 --> 00:13:16,270
that a lot of our customers are using

00:13:13,610 --> 00:13:19,480
for integrating with UAE

00:13:16,270 --> 00:13:22,780
spring security worth provides basic

00:13:19,480 --> 00:13:24,240
worth client functionality so what that

00:13:22,780 --> 00:13:27,370
means is if you have an application

00:13:24,240 --> 00:13:30,100
which needs to communicate with you a a

00:13:27,370 --> 00:13:31,810
to get tokens you can use spring

00:13:30,100 --> 00:13:33,460
security and not have to worry about

00:13:31,810 --> 00:13:35,920
anything worth related

00:13:33,460 --> 00:13:38,110
it is however undergoing a major rewrite

00:13:35,920 --> 00:13:40,810
so please refer to the link that I've

00:13:38,110 --> 00:13:43,810
put in the presentation here so if you

00:13:40,810 --> 00:13:49,240
follow spring i/o they are doing a major

00:13:43,810 --> 00:13:51,730
rewrite as part of their M 500 series so

00:13:49,240 --> 00:13:53,650
they are adding support for core open ID

00:13:51,730 --> 00:13:57,120
connect but they are rewriting a lot of

00:13:53,650 --> 00:14:00,460
things so something you need to plan for

00:13:57,120 --> 00:14:03,790
see if Java client is essentially an

00:14:00,460 --> 00:14:08,290
admin interface so it implements all of

00:14:03,790 --> 00:14:10,240
the UAAP is and you would want to use it

00:14:08,290 --> 00:14:12,640
if you want to do user management

00:14:10,240 --> 00:14:16,660
identity zone management or provider

00:14:12,640 --> 00:14:19,800
management within your own tool and this

00:14:16,660 --> 00:14:23,050
Java client allows you to do that

00:14:19,800 --> 00:14:27,310
finally we recently added support for

00:14:23,050 --> 00:14:30,340
you a a JavaScript SDK so this would be

00:14:27,310 --> 00:14:32,380
of interest if you are writing a single

00:14:30,340 --> 00:14:34,990
page application which is JavaScript

00:14:32,380 --> 00:14:38,230
only runs within the browser no back end

00:14:34,990 --> 00:14:40,390
and as a developer if you don't want to

00:14:38,230 --> 00:14:43,060
you know like really understand the

00:14:40,390 --> 00:14:45,790
intricacies of earth this is the SDK to

00:14:43,060 --> 00:14:47,590
use because you just call a method you

00:14:45,790 --> 00:14:47,860
register a set of things and you're good

00:14:47,590 --> 00:14:51,940
to go

00:14:47,860 --> 00:14:53,560
now there is a spec out there which is

00:14:51,940 --> 00:14:56,290
referred to as the open ID connect

00:14:53,560 --> 00:14:58,840
session management so for folks over

00:14:56,290 --> 00:15:00,700
here who are familiar with sam'l there

00:14:58,840 --> 00:15:04,450
is something called as the single logout

00:15:00,700 --> 00:15:06,370
profile so what that means is with

00:15:04,450 --> 00:15:09,160
respect to single sign-on you have

00:15:06,370 --> 00:15:11,860
multiple applications that a user is

00:15:09,160 --> 00:15:14,110
accessing right but if the user logs out

00:15:11,860 --> 00:15:15,910
of one application if your compliance

00:15:14,110 --> 00:15:18,220
policy is to log them out of all

00:15:15,910 --> 00:15:21,340
applications at that time then you need

00:15:18,220 --> 00:15:23,890
to have a single log out in place so

00:15:21,340 --> 00:15:26,080
sam'l supports that and open ID connect

00:15:23,890 --> 00:15:28,860
through this RFC supports that so we

00:15:26,080 --> 00:15:31,310
have plans to add that support with

00:15:28,860 --> 00:15:31,310
Nastia

00:15:32,460 --> 00:15:37,920
moving on to feature updates so I have

00:15:36,150 --> 00:15:39,510
not covered everything so I've tried to

00:15:37,920 --> 00:15:41,990
stick to like the major updates that

00:15:39,510 --> 00:15:44,910
we've done in like the past few months

00:15:41,990 --> 00:15:47,880
major ones being client and secret

00:15:44,910 --> 00:15:52,080
rotation sorry keys and client secret

00:15:47,880 --> 00:15:53,970
rotation so you a relies for its

00:15:52,080 --> 00:15:57,060
functioning right it relies on different

00:15:53,970 --> 00:16:00,840
key material right so for example tokens

00:15:57,060 --> 00:16:03,000
are signed with key with a key and if

00:16:00,840 --> 00:16:05,880
you AAA is acting as a sam'l identity

00:16:03,000 --> 00:16:08,070
provider or as a relying party it needs

00:16:05,880 --> 00:16:12,990
to sign outgoing authentication requests

00:16:08,070 --> 00:16:16,440
or sign assertions so these keys

00:16:12,990 --> 00:16:19,410
prior to this functionality were not

00:16:16,440 --> 00:16:22,500
rotatable or even if they were rotated

00:16:19,410 --> 00:16:25,830
out you would face downtime so the way

00:16:22,500 --> 00:16:29,310
we implemented this feature is you add

00:16:25,830 --> 00:16:32,310
your new key and this can be added via

00:16:29,310 --> 00:16:35,070
the API so there is an identity zone API

00:16:32,310 --> 00:16:38,040
for management of all identity zone

00:16:35,070 --> 00:16:41,910
configuration so you specify the new key

00:16:38,040 --> 00:16:44,040
there and then you switch the key ID for

00:16:41,910 --> 00:16:46,440
active key so the moment you do that

00:16:44,040 --> 00:16:49,020
what happens is you AAA starts using

00:16:46,440 --> 00:16:51,180
that key for all of its operations but

00:16:49,020 --> 00:16:53,370
the old key is still there and the

00:16:51,180 --> 00:16:56,190
reason it is still there is because all

00:16:53,370 --> 00:16:59,070
the outstanding tokens that have been

00:16:56,190 --> 00:17:01,290
signed they should still function

00:16:59,070 --> 00:17:04,800
because otherwise your apps will start

00:17:01,290 --> 00:17:06,360
facing downtime so there will however be

00:17:04,800 --> 00:17:08,310
situations where and like a key

00:17:06,360 --> 00:17:10,200
compromise has happened and you don't

00:17:08,310 --> 00:17:11,550
want the old key to function at all in

00:17:10,200 --> 00:17:14,430
those situations you should immediately

00:17:11,550 --> 00:17:17,270
get rid of the old key but if you want

00:17:14,430 --> 00:17:19,590
that graceful sort of you know a

00:17:17,270 --> 00:17:21,510
rotation then you should you should

00:17:19,590 --> 00:17:24,450
follow this process of introducing the

00:17:21,510 --> 00:17:28,110
new key make it active and then get rid

00:17:24,450 --> 00:17:30,570
of the old key after some time we follow

00:17:28,110 --> 00:17:33,710
a similar model for Roth client secrets

00:17:30,570 --> 00:17:37,980
also so today right what we support is

00:17:33,710 --> 00:17:40,430
each client has not one but you can have

00:17:37,980 --> 00:17:42,710
two secrets

00:17:40,430 --> 00:17:45,500
so if you were to rotate out a secret

00:17:42,710 --> 00:17:47,240
you will add the new secret and client

00:17:45,500 --> 00:17:49,070
authentication will work with both the

00:17:47,240 --> 00:17:51,050
secrets and then eventually you can

00:17:49,070 --> 00:17:53,120
remove the old secret and all these

00:17:51,050 --> 00:17:55,790
activities can be performed through the

00:17:53,120 --> 00:17:59,150
API so they are fully automated one

00:17:55,790 --> 00:18:01,250
important thing to note is default zone

00:17:59,150 --> 00:18:03,800
all of the key management is via the

00:18:01,250 --> 00:18:09,410
manifest not via the API but for all

00:18:03,800 --> 00:18:11,660
other zones you can use use the API open

00:18:09,410 --> 00:18:13,400
ID connect enhancements we recently done

00:18:11,660 --> 00:18:17,090
a lot of enhancements around open ID

00:18:13,400 --> 00:18:20,030
connect support so UAE is both an

00:18:17,090 --> 00:18:21,980
identity provider and a relying party so

00:18:20,030 --> 00:18:24,200
as an identity provider we've added a

00:18:21,980 --> 00:18:26,480
discovery support what that basically

00:18:24,200 --> 00:18:29,660
means is all relying parties can

00:18:26,480 --> 00:18:32,060
discover configuration open ID Connect

00:18:29,660 --> 00:18:34,190
IDP configuration for UA a without

00:18:32,060 --> 00:18:37,940
having to startingly statically support

00:18:34,190 --> 00:18:43,550
or hook that up into a relying party so

00:18:37,940 --> 00:18:45,730
that configuration is available at

00:18:43,550 --> 00:18:48,920
well-known configuration open ID

00:18:45,730 --> 00:18:53,630
configuration under the base domain of

00:18:48,920 --> 00:18:56,660
the UAE as a relying party we have added

00:18:53,630 --> 00:19:00,290
support for onboarding external

00:18:56,660 --> 00:19:02,630
providers like Google Asha so a sure for

00:19:00,290 --> 00:19:05,720
example a supports oh can I reconnect

00:19:02,630 --> 00:19:08,240
and sam'l so we can connect with both so

00:19:05,720 --> 00:19:11,120
I sure can expose Active Directory via

00:19:08,240 --> 00:19:14,030
open ID connect connection also and a

00:19:11,120 --> 00:19:16,880
ping identity is one more heavily used

00:19:14,030 --> 00:19:18,620
Enterprise product for Federation and it

00:19:16,880 --> 00:19:21,440
also supports open I reconnect so we've

00:19:18,620 --> 00:19:24,710
tested with all three of them for our

00:19:21,440 --> 00:19:27,230
open early connect relying party anytime

00:19:24,710 --> 00:19:30,560
we are connecting to an external

00:19:27,230 --> 00:19:32,270
provider we have to basically map

00:19:30,560 --> 00:19:35,840
attributes like how will we read

00:19:32,270 --> 00:19:37,820
information from that provider so we do

00:19:35,840 --> 00:19:40,100
this in a standards-based manner we've

00:19:37,820 --> 00:19:43,070
done this with LDAP and fit sam'l you

00:19:40,100 --> 00:19:46,250
specify attribute mappings in order to

00:19:43,070 --> 00:19:49,460
read information from the external IDP

00:19:46,250 --> 00:19:51,710
and we also support mapping external

00:19:49,460 --> 00:19:53,870
groups to UA a scopes so this is a

00:19:51,710 --> 00:19:55,610
pattern that we've supported for all

00:19:53,870 --> 00:19:58,760
kinds of providers and we support this

00:19:55,610 --> 00:20:03,230
with open ID connect to future work-wise

00:19:58,760 --> 00:20:05,420
we have plans to get oh I DC certified

00:20:03,230 --> 00:20:06,559
so there are a lot of things in there in

00:20:05,420 --> 00:20:08,840
that certification

00:20:06,559 --> 00:20:10,850
you need to have identity provider

00:20:08,840 --> 00:20:12,770
support relying party support and then

00:20:10,850 --> 00:20:14,780
open early connect session management if

00:20:12,770 --> 00:20:21,110
you have plans to apply for that and get

00:20:14,780 --> 00:20:23,690
listed backup and recovery so backup and

00:20:21,110 --> 00:20:28,730
recovery is basically a process through

00:20:23,690 --> 00:20:31,070
which you can backup the state of CF so

00:20:28,730 --> 00:20:33,770
and part of that state is the UA a

00:20:31,070 --> 00:20:37,040
database right and you can restore it in

00:20:33,770 --> 00:20:41,750
a disaster site disaster recovery site

00:20:37,040 --> 00:20:43,190
so if as an operator the way we have

00:20:41,750 --> 00:20:44,900
simplified the backup and recovery

00:20:43,190 --> 00:20:47,990
procedure or backup and restore

00:20:44,900 --> 00:20:51,080
procedure for CF is there is something

00:20:47,990 --> 00:20:55,120
called as the Bosch DVR so you AAA

00:20:51,080 --> 00:20:58,610
implements this framework through which

00:20:55,120 --> 00:21:01,370
basically there are different series of

00:20:58,610 --> 00:21:06,050
things that have to happen of starting

00:21:01,370 --> 00:21:09,110
with a pre backup lock take then you do

00:21:06,050 --> 00:21:13,460
the backup then you unlock and then on

00:21:09,110 --> 00:21:15,980
the on the recovery site you perform a

00:21:13,460 --> 00:21:18,679
pre restore lock then you restore and

00:21:15,980 --> 00:21:20,420
then you unlock so these things are

00:21:18,679 --> 00:21:24,200
actually triggered by the operator

00:21:20,420 --> 00:21:27,710
through a jump box and that jump box

00:21:24,200 --> 00:21:30,710
relies on a separate virtual machine

00:21:27,710 --> 00:21:32,960
which is called the BB RVM to maintain

00:21:30,710 --> 00:21:36,350
the state and that is where all the

00:21:32,960 --> 00:21:38,150
backups are taken so what what happens

00:21:36,350 --> 00:21:42,890
is when the operator kicks off this

00:21:38,150 --> 00:21:46,250
process the the Boche BB our VM is going

00:21:42,890 --> 00:21:49,190
to invoke the lock functionality on you

00:21:46,250 --> 00:21:52,550
AAA now what that will do is put you AAA

00:21:49,190 --> 00:21:55,070
in a limited functionality mode other

00:21:52,550 --> 00:21:57,710
components like cloud controller they

00:21:55,070 --> 00:21:59,210
are container networking they do it a

00:21:57,710 --> 00:22:01,670
different way they don't go into a

00:21:59,210 --> 00:22:04,010
limited functionality mode but with you

00:22:01,670 --> 00:22:06,620
AAA what we do is we keep some

00:22:04,010 --> 00:22:09,470
functionality available because we don't

00:22:06,620 --> 00:22:11,120
to take a downtime for apps that rely on

00:22:09,470 --> 00:22:13,880
you AAA for authentication and

00:22:11,120 --> 00:22:16,010
authorization so we when you go into a

00:22:13,880 --> 00:22:18,020
limited functionality mode login and

00:22:16,010 --> 00:22:20,600
token acquisition flows are still

00:22:18,020 --> 00:22:22,640
available all gates are available

00:22:20,600 --> 00:22:26,360
because it's it's a read-only mode so

00:22:22,640 --> 00:22:28,400
that doesn't really hurt and this set of

00:22:26,360 --> 00:22:31,220
endpoints and the methods that you want

00:22:28,400 --> 00:22:33,290
to allow are actually configurable so as

00:22:31,220 --> 00:22:35,660
an operator if you decide that no I do

00:22:33,290 --> 00:22:37,130
not want even login functionality to be

00:22:35,660 --> 00:22:39,320
there that's your decision

00:22:37,130 --> 00:22:42,020
but something that I would advise

00:22:39,320 --> 00:22:45,050
against because yes especially if you

00:22:42,020 --> 00:22:46,670
are using UA a not just to secure CF but

00:22:45,050 --> 00:22:53,450
for apps you don't want to take a

00:22:46,670 --> 00:22:56,030
downtime for applications one important

00:22:53,450 --> 00:23:00,320
thing so the backup and recovery is

00:22:56,030 --> 00:23:02,809
supported for my sequel and Postgres we

00:23:00,320 --> 00:23:05,630
will add support for sequel server as

00:23:02,809 --> 00:23:10,460
well but as of the MVP my sequel and

00:23:05,630 --> 00:23:13,130
post phase are supported so earlier I

00:23:10,460 --> 00:23:17,059
was explaining UA is support for jar

00:23:13,130 --> 00:23:20,270
tokens we have added support for opaque

00:23:17,059 --> 00:23:25,340
tokens also so as the name suggests it's

00:23:20,270 --> 00:23:28,100
an opaque string now the the good thing

00:23:25,340 --> 00:23:30,740
about jar is that it can be validated

00:23:28,100 --> 00:23:32,570
offline or this is this is really

00:23:30,740 --> 00:23:34,280
important especially you know like yet

00:23:32,570 --> 00:23:37,040
we are dealing with distributed systems

00:23:34,280 --> 00:23:38,990
you don't want this latency you know

00:23:37,040 --> 00:23:41,660
like overhead of always having to call

00:23:38,990 --> 00:23:45,820
back into UA a to validate tokens right

00:23:41,660 --> 00:23:48,800
so the chart you get offline validation

00:23:45,820 --> 00:23:51,140
with opaque tokens you don't but then

00:23:48,800 --> 00:23:53,330
there is a there is a place where opaque

00:23:51,140 --> 00:23:56,510
tokens do make sense is when you want

00:23:53,330 --> 00:24:00,230
immediate revoke ability because you you

00:23:56,510 --> 00:24:03,440
want that you know like anytime token

00:24:00,230 --> 00:24:06,620
has been generated by you AAA and it's

00:24:03,440 --> 00:24:08,900
being used by a resource server like an

00:24:06,620 --> 00:24:12,650
API for access checks you want to make

00:24:08,900 --> 00:24:15,010
sure that that access is still good so

00:24:12,650 --> 00:24:17,510
and you want to get that latest date

00:24:15,010 --> 00:24:19,450
centrally from the server so in those

00:24:17,510 --> 00:24:21,330
situations it does make sense

00:24:19,450 --> 00:24:24,160
with opaque tokens you get claims

00:24:21,330 --> 00:24:26,260
confidentiality because with chart it's

00:24:24,160 --> 00:24:28,240
a base64 encoded string but not

00:24:26,260 --> 00:24:30,940
necessarily encrypted you AAA doesn't

00:24:28,240 --> 00:24:32,770
encrypt chart but with opaque tokens a

00:24:30,940 --> 00:24:36,280
client will never be able to figure out

00:24:32,770 --> 00:24:39,580
what is within the token because it's an

00:24:36,280 --> 00:24:41,770
opaque string only client clients as in

00:24:39,580 --> 00:24:44,530
like resource servers or API s-- will be

00:24:41,770 --> 00:24:47,650
able to exchange that opaque token for

00:24:44,530 --> 00:24:50,170
actual claims persistence wise opaque

00:24:47,650 --> 00:24:52,360
tokens are always persisted if you do

00:24:50,170 --> 00:24:55,380
want to be revocable we have added that

00:24:52,360 --> 00:24:58,270
support wherein dot can also be

00:24:55,380 --> 00:24:59,980
optionally persisted so this is a flag

00:24:58,270 --> 00:25:03,430
that you need to turn on at AU AAA

00:24:59,980 --> 00:25:05,920
identity zone level revocable revoke

00:25:03,430 --> 00:25:07,690
ability of tokens so dot tokens are

00:25:05,920 --> 00:25:10,590
revocable if they are persisted and

00:25:07,690 --> 00:25:14,200
opaque tokens are always revocable

00:25:10,590 --> 00:25:16,300
future work wise today we do not put any

00:25:14,200 --> 00:25:18,580
limits on the number of opaque tokens

00:25:16,300 --> 00:25:22,270
that are generated per user and client

00:25:18,580 --> 00:25:24,300
combination so this is something that we

00:25:22,270 --> 00:25:26,470
understand is is limiting because

00:25:24,300 --> 00:25:28,300
especially you know like as your usage

00:25:26,470 --> 00:25:30,910
of you AAA grows and the footprint grows

00:25:28,300 --> 00:25:34,600
so will the number of opaque tokens in

00:25:30,910 --> 00:25:36,850
your storage so we we plan on adding

00:25:34,600 --> 00:25:38,740
like policy around how many opaque

00:25:36,850 --> 00:25:44,530
tokens can be generated per user and

00:25:38,740 --> 00:25:46,390
client combination token exchange is one

00:25:44,530 --> 00:25:50,500
more important feature that we recently

00:25:46,390 --> 00:25:53,200
added so as the name suggests token

00:25:50,500 --> 00:25:58,150
exchange is basically exchanging one

00:25:53,200 --> 00:25:59,500
kind of token for another kind so but

00:25:58,150 --> 00:26:03,790
what are what are these different kinds

00:25:59,500 --> 00:26:05,980
of tokens so one is sam'l so if you have

00:26:03,790 --> 00:26:08,950
a sam'l assertion and you want it

00:26:05,980 --> 00:26:10,660
exchanged for Earth access token that's

00:26:08,950 --> 00:26:13,810
something that token exchange allows you

00:26:10,660 --> 00:26:18,010
to do but token exchange also allows you

00:26:13,810 --> 00:26:18,850
to exchange a shot for another shot from

00:26:18,010 --> 00:26:21,580
UAA

00:26:18,850 --> 00:26:23,830
so all well and good you can do token

00:26:21,580 --> 00:26:26,980
exchange but what is the use case that

00:26:23,830 --> 00:26:29,700
is being solved so there are two

00:26:26,980 --> 00:26:32,380
important aspects to it as an enterprise

00:26:29,700 --> 00:26:33,880
right you are going to deal with the

00:26:32,380 --> 00:26:36,040
which is you will have legacy

00:26:33,880 --> 00:26:38,530
applications which are still dealing

00:26:36,040 --> 00:26:40,060
with sam'l and you will have greenfield

00:26:38,530 --> 00:26:43,420
applications that you may have written

00:26:40,060 --> 00:26:45,100
to understand Oh auth but how do they

00:26:43,420 --> 00:26:46,990
all interoperate with each other because

00:26:45,100 --> 00:26:48,490
again just because you wrote a

00:26:46,990 --> 00:26:50,560
greenfield apps doesn't mean that you'll

00:26:48,490 --> 00:26:53,160
drop support for legacy apps right so

00:26:50,560 --> 00:26:56,710
what token exchange allows you to do is

00:26:53,160 --> 00:26:59,770
you can actually from a legacy app if it

00:26:56,710 --> 00:27:02,530
is in possession of a sam'l assertion

00:26:59,770 --> 00:27:06,280
and that legacy app needs to make a call

00:27:02,530 --> 00:27:08,710
to a Greenfield API then that sam'l

00:27:06,280 --> 00:27:10,390
assertion can be exchanged for a auth

00:27:08,710 --> 00:27:14,190
token so that you can make that

00:27:10,390 --> 00:27:18,130
downstream API call now from a

00:27:14,190 --> 00:27:19,840
configuration perspective if you want to

00:27:18,130 --> 00:27:22,540
do this exchange you have to register a

00:27:19,840 --> 00:27:24,790
client and the grant type should be

00:27:22,540 --> 00:27:27,100
sam'l bearer or jot bearer depending on

00:27:24,790 --> 00:27:29,620
what you are trying to exchange scopes

00:27:27,100 --> 00:27:32,080
is an important aspect because whatever

00:27:29,620 --> 00:27:35,050
you set in the scope says is what will

00:27:32,080 --> 00:27:38,200
end up in the token so like any other

00:27:35,050 --> 00:27:40,450
thing in UA a token wise what ends up in

00:27:38,200 --> 00:27:42,880
the scope sorry what ends up in the

00:27:40,450 --> 00:27:45,400
token is an intersection of users

00:27:42,880 --> 00:27:48,220
permissions and clients permissions so

00:27:45,400 --> 00:27:50,530
with respect to token exchanges so the

00:27:48,220 --> 00:27:53,050
final token that is generated is an

00:27:50,530 --> 00:27:55,180
intersection of what was the original

00:27:53,050 --> 00:27:57,460
sam'l assertion what were the

00:27:55,180 --> 00:28:01,570
permissions in there and then what is

00:27:57,460 --> 00:28:04,210
the client allowed to do so

00:28:01,570 --> 00:28:05,830
as part of the actual request right you

00:28:04,210 --> 00:28:09,160
would be passing the client ID the

00:28:05,830 --> 00:28:11,590
secret and the assertion dot or sam'l

00:28:09,160 --> 00:28:14,590
and the response will be a UAE access

00:28:11,590 --> 00:28:16,150
token now we just don't take the token

00:28:14,590 --> 00:28:17,620
and you know generate your new access

00:28:16,150 --> 00:28:23,140
token we perform like all the

00:28:17,620 --> 00:28:24,760
validations before we do that we have

00:28:23,140 --> 00:28:27,700
taken it a step further

00:28:24,760 --> 00:28:31,360
token exchange and we allow exchanging

00:28:27,700 --> 00:28:34,540
tokens within you a a boundary also now

00:28:31,360 --> 00:28:37,930
this can get a bit confusing so again

00:28:34,540 --> 00:28:41,230
let me explain with an example think of

00:28:37,930 --> 00:28:44,230
an edge application which is making a

00:28:41,230 --> 00:28:45,630
bunch of micro service calls wherein one

00:28:44,230 --> 00:28:47,490
micro service could be

00:28:45,630 --> 00:28:49,680
invoking another microservice and then

00:28:47,490 --> 00:28:52,230
another microservice now there are

00:28:49,680 --> 00:28:55,770
multiple ways to secure that kind of

00:28:52,230 --> 00:28:58,740
communication but the best way is to

00:28:55,770 --> 00:29:01,680
always maintain the state of the user

00:28:58,740 --> 00:29:03,930
right but when you are doing that you

00:29:01,680 --> 00:29:06,570
don't want to pass the original token

00:29:03,930 --> 00:29:08,190
all the way downstream because you want

00:29:06,570 --> 00:29:11,730
to follow the principle of least

00:29:08,190 --> 00:29:13,650
privilege wherein when the when an API

00:29:11,730 --> 00:29:15,180
makes another API request or a micro

00:29:13,650 --> 00:29:17,880
service makes another micro service

00:29:15,180 --> 00:29:21,120
request you want to pass only what is

00:29:17,880 --> 00:29:23,730
required for that call so token exchange

00:29:21,120 --> 00:29:27,510
can help you here because what it can do

00:29:23,730 --> 00:29:31,260
is you pass that token with more scopes

00:29:27,510 --> 00:29:33,840
to UAA and it will exchange it for a

00:29:31,260 --> 00:29:37,410
token with limited scopes that you can

00:29:33,840 --> 00:29:40,160
then pass downstream so this way you are

00:29:37,410 --> 00:29:43,710
decreasing the footprint of you know

00:29:40,160 --> 00:29:45,990
having the token misused for other

00:29:43,710 --> 00:29:50,910
things because the Scopes are limited in

00:29:45,990 --> 00:29:52,500
their token roadmap price there has been

00:29:50,910 --> 00:29:56,520
a lot of talk about scaling and metrics

00:29:52,500 --> 00:29:59,580
for other components of CF we have plans

00:29:56,520 --> 00:30:02,910
to invest in the performance and scaling

00:29:59,580 --> 00:30:04,950
aspects of UAA as well we have started

00:30:02,910 --> 00:30:07,020
off this work where and we are

00:30:04,950 --> 00:30:08,850
essentially as part of UAA

00:30:07,020 --> 00:30:11,700
there are three kinds of metrics that

00:30:08,850 --> 00:30:16,850
are being generated request metrics data

00:30:11,700 --> 00:30:21,570
base metrics and VM and JVM metrics so

00:30:16,850 --> 00:30:23,400
we have two goals here and one number

00:30:21,570 --> 00:30:26,280
one goal is that we want to benchmark

00:30:23,400 --> 00:30:29,160
performance of UAA wherein we can

00:30:26,280 --> 00:30:30,810
baseline and say that okay say two VMs

00:30:29,160 --> 00:30:33,440
can give you this kind of performance

00:30:30,810 --> 00:30:36,840
this this level of concurrency and

00:30:33,440 --> 00:30:38,940
indicator for when to scale out so this

00:30:36,840 --> 00:30:41,670
is something which will be beneficial to

00:30:38,940 --> 00:30:44,820
operators in terms of scaling out UAS

00:30:41,670 --> 00:30:46,920
horizontally and another aspect is the

00:30:44,820 --> 00:30:48,780
stability aspect we don't want to put

00:30:46,920 --> 00:30:50,400
out UAE releases which regress on

00:30:48,780 --> 00:30:52,860
performance and this has happened in the

00:30:50,400 --> 00:30:54,720
past where and we we did some

00:30:52,860 --> 00:30:59,280
refactoring and turned out that you know

00:30:54,720 --> 00:31:02,420
like the users API is dead slow so

00:30:59,280 --> 00:31:05,190
our goal is that we want to see I

00:31:02,420 --> 00:31:06,990
performance-wise we're in every new

00:31:05,190 --> 00:31:08,580
release that we put out to the community

00:31:06,990 --> 00:31:10,590
we want to make sure that we don't

00:31:08,580 --> 00:31:13,590
regress on performance so that's

00:31:10,590 --> 00:31:16,260
something that we want to achieve in

00:31:13,590 --> 00:31:19,290
terms of performance goals what you see

00:31:16,260 --> 00:31:21,180
here is actually a data dashboard which

00:31:19,290 --> 00:31:23,700
shows you the metrics that we are

00:31:21,180 --> 00:31:25,370
collecting so you don't have to use data

00:31:23,700 --> 00:31:29,820
dog but this is one way to visualize

00:31:25,370 --> 00:31:31,800
these metrics multi-factor

00:31:29,820 --> 00:31:35,310
authentication is something that we are

00:31:31,800 --> 00:31:37,110
already working on initially the plan is

00:31:35,310 --> 00:31:41,450
to add support for google authenticator

00:31:37,110 --> 00:31:44,700
followed by other factors like Yubikey

00:31:41,450 --> 00:31:46,230
the way this is going to function is we

00:31:44,700 --> 00:31:49,620
can enable multi-factor authentication

00:31:46,230 --> 00:31:52,290
at our identities own level what that

00:31:49,620 --> 00:31:54,120
means is every user who is trying to

00:31:52,290 --> 00:31:55,680
authenticate has to go through

00:31:54,120 --> 00:31:58,560
multi-factor authentication period

00:31:55,680 --> 00:32:02,310
because the policy is applied at a zone

00:31:58,560 --> 00:32:05,090
level the token that will be generated

00:32:02,310 --> 00:32:07,530
will actually have a claim which says

00:32:05,090 --> 00:32:10,350
AMR which is authentication method

00:32:07,530 --> 00:32:13,170
reference is MFA what that means is this

00:32:10,350 --> 00:32:14,970
user authenticated using MFA credential

00:32:13,170 --> 00:32:19,260
it's an important piece of information

00:32:14,970 --> 00:32:22,020
because again you want to apply policy

00:32:19,260 --> 00:32:23,820
around did the user perform a

00:32:22,020 --> 00:32:27,120
multi-factor authentication before

00:32:23,820 --> 00:32:30,360
accessing a certain app or API so you

00:32:27,120 --> 00:32:33,210
can feed this into your per for a fine

00:32:30,360 --> 00:32:36,420
grained a permission system to leverage

00:32:33,210 --> 00:32:39,720
it for policy related decisions we do

00:32:36,420 --> 00:32:42,600
have plans to enable MFA at app level to

00:32:39,720 --> 00:32:45,660
wear in not every user has to register

00:32:42,600 --> 00:32:48,870
for MFA only for certain apps you will

00:32:45,660 --> 00:32:52,040
have MFA enabled and only if the user is

00:32:48,870 --> 00:32:54,420
accessing that application will the

00:32:52,040 --> 00:32:56,370
villa step-up authentication happen

00:32:54,420 --> 00:32:59,040
wherein the user will be challenged for

00:32:56,370 --> 00:33:01,260
a MFA credential as part of accessing

00:32:59,040 --> 00:33:03,300
the app so this will not happen as part

00:33:01,260 --> 00:33:08,240
of the MVP but we have plans to add

00:33:03,300 --> 00:33:10,070
support later on so this

00:33:08,240 --> 00:33:13,660
I put the slide in it's not directly

00:33:10,070 --> 00:33:16,400
connected to UAA but something that is

00:33:13,660 --> 00:33:18,740
close in terms of identity related

00:33:16,400 --> 00:33:20,030
decision-making so we are kicking off a

00:33:18,740 --> 00:33:22,280
new project which has already been

00:33:20,030 --> 00:33:24,400
kicked off it's an incubation it's

00:33:22,280 --> 00:33:27,559
called the permissions project perm and

00:33:24,400 --> 00:33:29,510
it's an incubation it's for solving the

00:33:27,559 --> 00:33:32,900
fine-grained authorization needs for

00:33:29,510 --> 00:33:36,530
Cloud Foundry and they have two charters

00:33:32,900 --> 00:33:41,780
one is that the ability to map existing

00:33:36,530 --> 00:33:43,850
CF roles or to external groups so I mean

00:33:41,780 --> 00:33:46,490
you all are aware that in enterprises

00:33:43,850 --> 00:33:48,559
typically access management is done via

00:33:46,490 --> 00:33:50,750
group memberships you don't grant access

00:33:48,559 --> 00:33:53,450
to an individual user you always do it

00:33:50,750 --> 00:33:56,090
on a group basis so we want to leverage

00:33:53,450 --> 00:33:59,450
that standard for Cloud Foundry roles as

00:33:56,090 --> 00:34:01,610
well so you AAA has the ability to read

00:33:59,450 --> 00:34:04,070
group memberships for a user from LDAP

00:34:01,610 --> 00:34:06,050
sam'l or oh I D see the idea is that we

00:34:04,070 --> 00:34:09,710
can feed this into this form system and

00:34:06,050 --> 00:34:13,240
have it evaluate policy and grant the

00:34:09,710 --> 00:34:15,440
right kind of access there is also a

00:34:13,240 --> 00:34:17,090
subsequent work that is going to happen

00:34:15,440 --> 00:34:19,790
around creating custom roles

00:34:17,090 --> 00:34:22,010
so today roles are limiting there is

00:34:19,790 --> 00:34:24,379
only space developer and probably five

00:34:22,010 --> 00:34:26,690
other roles but again from a security

00:34:24,379 --> 00:34:30,169
perspective least privilege you want to

00:34:26,690 --> 00:34:32,780
give only the access that should be

00:34:30,169 --> 00:34:34,820
given right like you do not have to grip

00:34:32,780 --> 00:34:36,859
the entire space developer access just

00:34:34,820 --> 00:34:38,840
because they have to view logs why do

00:34:36,859 --> 00:34:41,210
you want to give them the access to push

00:34:38,840 --> 00:34:45,700
applications for example so custom roles

00:34:41,210 --> 00:34:48,710
will solve that problem for you MVP for

00:34:45,700 --> 00:34:50,710
palm is to migrate off the cloud

00:34:48,710 --> 00:34:53,840
controller roles to this new model and

00:34:50,710 --> 00:34:56,090
behind the scenes it will be UAE which

00:34:53,840 --> 00:34:58,820
will be providing all the identity

00:34:56,090 --> 00:35:01,609
related information to the to poem as a

00:34:58,820 --> 00:35:03,470
policy engine so definitely we like your

00:35:01,609 --> 00:35:07,070
feedback so please feel free to reach

00:35:03,470 --> 00:35:10,700
out I'm not I'm not sure if the group

00:35:07,070 --> 00:35:13,640
there is a group of formed already but I

00:35:10,700 --> 00:35:15,530
this will be part of the runtime PMC so

00:35:13,640 --> 00:35:17,830
you can use that handle to provide

00:35:15,530 --> 00:35:17,830
feedback

00:35:18,900 --> 00:35:26,400
housekeeping so we are at the end and

00:35:22,970 --> 00:35:28,950
you a project updates they are available

00:35:26,400 --> 00:35:31,500
as part of elastic runtime PMC the

00:35:28,950 --> 00:35:33,780
meetings happen bi-weekly so notes are

00:35:31,500 --> 00:35:35,670
shared it's part of the github repo so

00:35:33,780 --> 00:35:39,030
if you want to follow you know like you

00:35:35,670 --> 00:35:43,250
a project updates please subscribe to

00:35:39,030 --> 00:35:47,640
that repository and security issues

00:35:43,250 --> 00:35:49,980
everyone's focused on security so if you

00:35:47,640 --> 00:35:52,260
find any security issues with you AAA

00:35:49,980 --> 00:35:54,420
please report them to security at cloud

00:35:52,260 --> 00:35:56,370
foundry dot org and all Seavey's

00:35:54,420 --> 00:35:59,100
like things which are deemed CVS and

00:35:56,370 --> 00:36:02,580
that get patched will be published at

00:35:59,100 --> 00:36:05,100
that URL and we do give credit so it's

00:36:02,580 --> 00:36:07,110
not like we just say that or something

00:36:05,100 --> 00:36:10,290
was fixed we actually say the name of

00:36:07,110 --> 00:36:12,480
the person who reported it so I'm not

00:36:10,290 --> 00:36:14,250
sure what I'm saying like you need to

00:36:12,480 --> 00:36:17,270
find all the security issues but I'm

00:36:14,250 --> 00:36:20,730
just saying you get the credit for it

00:36:17,270 --> 00:36:23,070
finally a shout-out to the team I have I

00:36:20,730 --> 00:36:26,190
think one member from the team's ashes

00:36:23,070 --> 00:36:29,280
here so none of this would be possible

00:36:26,190 --> 00:36:33,300
without an amazing team and it's not

00:36:29,280 --> 00:36:36,660
just pivotal employees so we have people

00:36:33,300 --> 00:36:39,290
from dojo contributing to UAA we have

00:36:36,660 --> 00:36:41,940
two people from GE Parata and Henry and

00:36:39,290 --> 00:36:45,240
we also have Michael who is from VMware

00:36:41,940 --> 00:36:50,280
and we have I think people from s AP out

00:36:45,240 --> 00:36:54,750
here so so they've contributed a lot in

00:36:50,280 --> 00:36:56,400
terms of especially a sam'l support the

00:36:54,750 --> 00:36:59,250
token exchange actually came from sa P

00:36:56,400 --> 00:37:00,630
and we are hoping to have them as part

00:36:59,250 --> 00:37:03,990
of the dojo program as well

00:37:00,630 --> 00:37:06,270
but overall it's purely a community

00:37:03,990 --> 00:37:08,970
driven thing it's not pivotal it's

00:37:06,270 --> 00:37:11,690
pivotal GES ap doing a lot of

00:37:08,970 --> 00:37:15,810
contributions to this project

00:37:11,690 --> 00:37:18,630
yeah it's Q&A and there will be an open

00:37:15,810 --> 00:37:21,180
house tomorrow and it'll be at Creation

00:37:18,630 --> 00:37:23,930
Station on the third floor it's at 3:20

00:37:21,180 --> 00:37:26,790
there is also another talk on UAA and

00:37:23,930 --> 00:37:32,360
microservices that's also tomorrow at

00:37:26,790 --> 00:37:32,360
2:40 so thank you all for coming

00:37:32,840 --> 00:37:42,339
[Applause]

00:37:36,119 --> 00:37:45,549
any questions I try to cover a lot I do

00:37:42,339 --> 00:37:48,759
understand that I will be sharing the

00:37:45,549 --> 00:37:49,960
slide deck feel free to reach out at the

00:37:48,759 --> 00:37:51,309
open house if you have any other

00:37:49,960 --> 00:37:59,890
questions but happy to take any

00:37:51,309 --> 00:38:02,890
questions right now hi hi

00:37:59,890 --> 00:38:06,130
so one thing you you didn't mention was

00:38:02,890 --> 00:38:08,289
this user token flow you know we you

00:38:06,130 --> 00:38:10,809
talked about okay there antara the

00:38:08,289 --> 00:38:14,410
directly browser flows the token

00:38:10,809 --> 00:38:18,460
exchange flows for what scenarios would

00:38:14,410 --> 00:38:20,109
you see the user token flow your are you

00:38:18,460 --> 00:38:24,369
referring to the user token grant type

00:38:20,109 --> 00:38:26,680
yeah yeah okay yeah so yeah so the

00:38:24,369 --> 00:38:28,150
question was about a new grant type that

00:38:26,680 --> 00:38:31,000
has been introduced in UAE

00:38:28,150 --> 00:38:35,859
it's called the user token grant type

00:38:31,000 --> 00:38:40,509
and it's an interesting question I think

00:38:35,859 --> 00:38:42,039
it's it's not it's not either our it it

00:38:40,509 --> 00:38:44,079
could be depending on the situation but

00:38:42,039 --> 00:38:47,559
what the user token grant flow allows

00:38:44,079 --> 00:38:50,319
you to do is as a user you can pre

00:38:47,559 --> 00:38:55,390
authorize access for a given application

00:38:50,319 --> 00:38:59,230
and that pre-authorization actually is a

00:38:55,390 --> 00:39:04,240
refresh token so let me try to explain

00:38:59,230 --> 00:39:05,799
it in some more details so if I'm pretty

00:39:04,240 --> 00:39:07,539
sure you've used like github access

00:39:05,799 --> 00:39:09,700
tokens where and you go into you know

00:39:07,539 --> 00:39:12,369
like it helps you I and you say that

00:39:09,700 --> 00:39:15,130
okay I want to you have leverage github

00:39:12,369 --> 00:39:18,670
access in a script that I wrote and I

00:39:15,130 --> 00:39:20,230
want to plug in the token so what you

00:39:18,670 --> 00:39:22,710
would do is like you would go into the

00:39:20,230 --> 00:39:25,150
UI and say that okay I want these scopes

00:39:22,710 --> 00:39:26,650
generate me a token and in order to do

00:39:25,150 --> 00:39:29,109
that you will actually authenticate and

00:39:26,650 --> 00:39:31,539
authorize that access and the end result

00:39:29,109 --> 00:39:34,390
will be a token that you will go and you

00:39:31,539 --> 00:39:36,730
will take and plug into your CI system

00:39:34,390 --> 00:39:39,069
and then your CI system will be able to

00:39:36,730 --> 00:39:41,970
leverage that token for its access needs

00:39:39,069 --> 00:39:44,730
so that user token grant type does

00:39:41,970 --> 00:39:47,490
so with the user token grant type you

00:39:44,730 --> 00:39:49,650
can code a UI or some kind of a

00:39:47,490 --> 00:39:53,460
management system through which a user

00:39:49,650 --> 00:39:56,730
can go in and pre-approve applications

00:39:53,460 --> 00:39:59,460
for access and that pre-approval results

00:39:56,730 --> 00:40:02,610
in a token that can then be plugged into

00:39:59,460 --> 00:40:06,630
your CI systems or scripts or CL eyes

00:40:02,610 --> 00:40:08,850
now with UAS implementation that token

00:40:06,630 --> 00:40:09,300
is a refresh token it's not an access

00:40:08,850 --> 00:40:11,520
token

00:40:09,300 --> 00:40:14,340
because refresh tokens are longer-lived

00:40:11,520 --> 00:40:17,070
the whole idea is for automated access

00:40:14,340 --> 00:40:19,980
so we generate a refresh token at the

00:40:17,070 --> 00:40:22,800
end of that flow and that token can then

00:40:19,980 --> 00:40:24,810
be in turn plugged in so that's that's

00:40:22,800 --> 00:40:27,780
how you would use that flow token

00:40:24,810 --> 00:40:29,730
exchanges more in flow I want to

00:40:27,780 --> 00:40:38,250
exchange one kind of token for another

00:40:29,730 --> 00:40:40,640
token I hope that UPS any other

00:40:38,250 --> 00:40:40,640
questions

00:40:41,780 --> 00:40:50,010
another one so yeah for the you also

00:40:46,500 --> 00:40:53,840
show this JSON web token exchange so

00:40:50,010 --> 00:40:57,180
this token exchange then did I get it

00:40:53,840 --> 00:41:00,780
correctly so that means concerning the

00:40:57,180 --> 00:41:03,600
Scopes that are in in a token mm-hmm

00:41:00,780 --> 00:41:05,820
they always get reduced or is there also

00:41:03,600 --> 00:41:08,730
an option where you can say okay I want

00:41:05,820 --> 00:41:10,860
to reimburse innate the user and metric

00:41:08,730 --> 00:41:13,740
and the Scopes that are assigned to a

00:41:10,860 --> 00:41:15,480
certain client mm-hmm you want to do it

00:41:13,740 --> 00:41:19,980
at the request time rather than that

00:41:15,480 --> 00:41:22,350
registration time well the point is if

00:41:19,980 --> 00:41:25,020
we're looking at at microservices

00:41:22,350 --> 00:41:27,690
and I have communication between one

00:41:25,020 --> 00:41:31,770
micro service to is to another micro

00:41:27,690 --> 00:41:33,630
service I mean with micro services I'm

00:41:31,770 --> 00:41:35,370
trying to decouple them you know I give

00:41:33,630 --> 00:41:39,090
them an old persistence I give them a

00:41:35,370 --> 00:41:41,100
non web container etc and that means I

00:41:39,090 --> 00:41:43,740
would also like to do that security wise

00:41:41,100 --> 00:41:47,250
that I say okay the authorizations that

00:41:43,740 --> 00:41:51,750
are you required by that webs micro

00:41:47,250 --> 00:41:53,790
service they're also decoupled and that

00:41:51,750 --> 00:41:57,120
would that would mean I need to have

00:41:53,790 --> 00:41:59,670
mechanism to increase the number of

00:41:57,120 --> 00:42:03,660
scopes or have a different set of scopes

00:41:59,670 --> 00:42:07,800
I said then so this is one of the things

00:42:03,660 --> 00:42:10,530
where we are using the user token grant

00:42:07,800 --> 00:42:14,010
okay yeah because then if you have to

00:42:10,530 --> 00:42:16,830
use a user scope then this exactly

00:42:14,010 --> 00:42:20,190
allows you to do that but that requires

00:42:16,830 --> 00:42:23,160
two HTTP messages to the UAA sure

00:42:20,190 --> 00:42:28,080
therefore the question is if we would

00:42:23,160 --> 00:42:31,020
now go for the JWT token flow would it

00:42:28,080 --> 00:42:33,300
allow us to do it with one message would

00:42:31,020 --> 00:42:36,600
it allow you to do what to do it one

00:42:33,300 --> 00:42:39,380
with one HTTP call instead of having to

00:42:36,600 --> 00:42:42,060
as we have it with the user token ground

00:42:39,380 --> 00:42:45,780
but the token exchange is one called

00:42:42,060 --> 00:42:48,660
though wherein you make a call to the

00:42:45,780 --> 00:42:52,890
token endpoint with a client ID a secret

00:42:48,660 --> 00:42:55,890
and the token button yeah I mean when

00:42:52,890 --> 00:42:58,710
I'm comparing the the user token grant

00:42:55,890 --> 00:43:00,990
with the Jason web token ground yeah

00:42:58,710 --> 00:43:03,780
then the user token grant that request

00:43:00,990 --> 00:43:05,850
to HTTP message says the first one to

00:43:03,780 --> 00:43:10,830
get a refresh token the second one to

00:43:05,850 --> 00:43:14,760
get an access token and the JWT token

00:43:10,830 --> 00:43:16,770
flow that allows it to do oh okay okay I

00:43:14,760 --> 00:43:20,160
get I get the question so the question

00:43:16,770 --> 00:43:22,230
is basically can I just request a subset

00:43:20,160 --> 00:43:23,910
of the Scopes right because the probably

00:43:22,230 --> 00:43:26,310
the grant the user token grant type does

00:43:23,910 --> 00:43:28,800
allow you to do that yeah so in the

00:43:26,310 --> 00:43:31,170
token exchange flow also even though the

00:43:28,800 --> 00:43:34,550
client may be authorized for ten Scopes

00:43:31,170 --> 00:43:37,320
as part of that exchange you can specify

00:43:34,550 --> 00:43:40,440
only the three scopes that you need

00:43:37,320 --> 00:43:42,990
further downstream interaction so it's

00:43:40,440 --> 00:43:46,710
it's possible we could probably take

00:43:42,990 --> 00:43:53,630
that offline I mean yeah yeah sure thank

00:43:46,710 --> 00:43:53,630

YouTube URL: https://www.youtube.com/watch?v=cerANFN9ufk


