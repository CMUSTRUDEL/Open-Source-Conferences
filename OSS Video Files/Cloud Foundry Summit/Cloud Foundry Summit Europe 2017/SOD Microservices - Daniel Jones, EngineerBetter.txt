Title: SOD Microservices - Daniel Jones, EngineerBetter
Publication date: 2017-10-18
Playlist: Cloud Foundry Summit Europe 2017
Description: 
	SOD Microservices - Daniel Jones, EngineerBetter

In the clamour to deploy all the things as microservices, the development community seems to have forgotten about Service-Oriented Design - an architectural code style that allows systems to start as monoliths, and be easily broken into microservices only when required. We’ll look at what exactly Service-Oriented Design is, how to apply Service-Oriented Design in Java Spring apps, and discuss how a forward-looking monolith-first approach can save engineering time and effort.

About Daniel Jones
Daniel Jones is CTO of UK Cloud Foundry consultancy EngineerBetter, who have been improving value-delivery at the world’s largest banks, global wealth management firms, FTSE 100 retailers, governments and non-profit organizations. Previously Daniel was a member of the Pivotal CF London Services team, and also worked with Europe's leading CF consultancy CloudCredo. Daniel has delivered keynotes and talks at three Cloud Foundry Summits, the London PaaS User Group, as well as numerous video games industry conferences. He once even stormed the stage at a music festival to interrupt the performing act and challenge their alleged bribe-taking!
Captions: 
	00:00:00,230 --> 00:00:06,750
good afternoon everybody thank you for

00:00:04,140 --> 00:00:09,000
joining me my name is Daniel Jones and

00:00:06,750 --> 00:00:11,550
I'm CTO of a consultancy called engineer

00:00:09,000 --> 00:00:13,740
better we help people with Cloud Foundry

00:00:11,550 --> 00:00:16,920
we also help people use Cloud Foundry

00:00:13,740 --> 00:00:20,609
and get the most out of it this talk is

00:00:16,920 --> 00:00:25,109
about service-oriented design when

00:00:20,609 --> 00:00:26,640
applied to micro services and how we've

00:00:25,109 --> 00:00:28,349
worked with customers in the past who

00:00:26,640 --> 00:00:31,109
have been trying to move from monoliths

00:00:28,349 --> 00:00:32,880
to micro services sometimes that's gone

00:00:31,109 --> 00:00:34,670
really well because they had a well

00:00:32,880 --> 00:00:36,630
structured monoliths in the first place

00:00:34,670 --> 00:00:38,879
sometimes they've really struggled

00:00:36,630 --> 00:00:41,309
because they had too many blended

00:00:38,879 --> 00:00:43,649
concerns in their monoliths and this

00:00:41,309 --> 00:00:46,200
made me think that you know before micro

00:00:43,649 --> 00:00:47,789
services with the new hotness 15 years

00:00:46,200 --> 00:00:50,070
ago when I first entered the IT industry

00:00:47,789 --> 00:00:52,289
I worked for a financial company that

00:00:50,070 --> 00:00:54,059
whose trading system was built using

00:00:52,289 --> 00:00:56,879
service-oriented architecture so you

00:00:54,059 --> 00:00:58,559
know message oriented middleware and all

00:00:56,879 --> 00:01:03,930
of the design patterns that I learnt

00:00:58,559 --> 00:01:05,700
then apply now to micro services so this

00:01:03,930 --> 00:01:07,500
session is about trying to share some of

00:01:05,700 --> 00:01:09,780
those ideas and act as a bit of a

00:01:07,500 --> 00:01:12,510
reminder that a lot of the hard problems

00:01:09,780 --> 00:01:15,509
about micro services are not about using

00:01:12,510 --> 00:01:16,590
the latest spring cloud implementation

00:01:15,509 --> 00:01:18,570
of a Netflix pattern

00:01:16,590 --> 00:01:21,450
it's just old-fashioned distributed

00:01:18,570 --> 00:01:23,869
computing so we'll be going through some

00:01:21,450 --> 00:01:26,790
ideas some patterns a very high level

00:01:23,869 --> 00:01:28,770
that you can apply when starting a new

00:01:26,790 --> 00:01:30,630
project when building a monolith that

00:01:28,770 --> 00:01:32,030
then will make running it in a

00:01:30,630 --> 00:01:37,799
distribution Micra service architecture

00:01:32,030 --> 00:01:39,180
easier so the executive summary mic

00:01:37,799 --> 00:01:42,119
reserves they're a deployment concern

00:01:39,180 --> 00:01:43,890
yeah how you do things with circuit

00:01:42,119 --> 00:01:45,720
breakers and service discovery that

00:01:43,890 --> 00:01:48,210
doesn't impact your business logic it

00:01:45,720 --> 00:01:50,189
shouldn't do their deployment concern

00:01:48,210 --> 00:01:51,840
and you're probably deploying that way

00:01:50,189 --> 00:01:54,840
because you either want resiliency or

00:01:51,840 --> 00:01:56,600
you want scalability and that means that

00:01:54,840 --> 00:01:59,460
you end up with a distributed system

00:01:56,600 --> 00:02:01,680
distribution systems are hard they're

00:01:59,460 --> 00:02:03,630
hard to reason about all the things that

00:02:01,680 --> 00:02:06,810
worked when you were working with one

00:02:03,630 --> 00:02:08,280
process with a lot of certainty you and

00:02:06,810 --> 00:02:08,849
you took for granted you can't do

00:02:08,280 --> 00:02:11,580
anymore

00:02:08,849 --> 00:02:13,250
but luckily distributed systems have

00:02:11,580 --> 00:02:17,120
been around for a while

00:02:13,250 --> 00:02:19,460
in fact I listen to dr. Jules who PM's

00:02:17,120 --> 00:02:21,290
the garden project about this the other

00:02:19,460 --> 00:02:23,090
night in the bar and he went it out the

00:02:21,290 --> 00:02:25,280
Lamport clocks you know where the paper

00:02:23,090 --> 00:02:27,550
on those was written in the 1970s so

00:02:25,280 --> 00:02:30,500
this stuff has been around for a while

00:02:27,550 --> 00:02:33,920
so if you practice service-oriented

00:02:30,500 --> 00:02:35,510
design from the start you'll end up with

00:02:33,920 --> 00:02:38,270
an app that's easier to split into

00:02:35,510 --> 00:02:40,730
distributable chunks and your code will

00:02:38,270 --> 00:02:42,860
be easier to reason about which I'll

00:02:40,730 --> 00:02:44,330
have immediate benefits even if you

00:02:42,860 --> 00:02:48,470
choose not to split it out and

00:02:44,330 --> 00:02:50,510
distribute it into micro services one of

00:02:48,470 --> 00:02:52,880
the things about this and the original

00:02:50,510 --> 00:02:55,460
abstract Allah still talked about taking

00:02:52,880 --> 00:02:58,280
through an example using a spring Java

00:02:55,460 --> 00:03:01,160
app a lot of frameworks for the sake of

00:02:58,280 --> 00:03:04,700
productivity and make it very easy to

00:03:01,160 --> 00:03:06,440
get things done quickly but by munging

00:03:04,700 --> 00:03:08,750
together concerns and putting too many

00:03:06,440 --> 00:03:10,460
things in one place the Cloud Controller

00:03:08,750 --> 00:03:12,290
is a good example of this it's a ruby on

00:03:10,460 --> 00:03:14,240
rails app that could be written really

00:03:12,290 --> 00:03:15,860
really quickly but it also means that

00:03:14,240 --> 00:03:18,800
it's hard to evolve because some of the

00:03:15,860 --> 00:03:20,060
Jason representations of objects are

00:03:18,800 --> 00:03:21,230
exactly the same as the database

00:03:20,060 --> 00:03:22,790
representation because there's a

00:03:21,230 --> 00:03:26,630
one-to-one mapping and lots of meta

00:03:22,790 --> 00:03:29,150
programming magic going on so the kind

00:03:26,630 --> 00:03:30,830
of the thrust of this talk is think

00:03:29,150 --> 00:03:33,710
about some architectural concerns to

00:03:30,830 --> 00:03:35,090
start off with don't necessarily do the

00:03:33,710 --> 00:03:36,410
easiest thing the framework puts in

00:03:35,090 --> 00:03:41,720
front of you and you will have an easier

00:03:36,410 --> 00:03:44,240
life in the future so the world before

00:03:41,720 --> 00:03:46,640
microservices was fashionable and trendy

00:03:44,240 --> 00:03:48,230
looked a lot like this if you had things

00:03:46,640 --> 00:03:50,360
that needed to talk to each other they

00:03:48,230 --> 00:03:52,910
did so via the enterprise service bus

00:03:50,360 --> 00:03:55,340
which was normally manifested with

00:03:52,910 --> 00:03:56,870
messaging or into middleware you would

00:03:55,340 --> 00:03:58,820
send a message you didn't know who was

00:03:56,870 --> 00:03:59,990
going to receive it the message broker

00:03:58,820 --> 00:04:03,500
would make sure it got to the right

00:03:59,990 --> 00:04:06,380
place why did this fall out of fashion a

00:04:03,500 --> 00:04:07,910
number of reasons but one is that as you

00:04:06,380 --> 00:04:09,770
can see in this diagram the service bus

00:04:07,910 --> 00:04:12,430
becomes a lynchpin becomes a logical

00:04:09,770 --> 00:04:16,220
lynchpin it becomes a scaling linchpin

00:04:12,430 --> 00:04:19,430
when you get to the scale of Netflix or

00:04:16,220 --> 00:04:21,229
Google or Amazon this isn't going to

00:04:19,430 --> 00:04:23,090
work having one central thing that knows

00:04:21,229 --> 00:04:25,250
where all of the services are so it can

00:04:23,090 --> 00:04:26,340
route messages to them the only way to

00:04:25,250 --> 00:04:29,199
get around that

00:04:26,340 --> 00:04:31,629
is something that looks like this which

00:04:29,199 --> 00:04:34,689
I'm not sure is necessarily more simple

00:04:31,629 --> 00:04:36,789
or more elegant we take the logic from

00:04:34,689 --> 00:04:39,789
that service bus and we distribute it

00:04:36,789 --> 00:04:42,069
and we push it down into each app so all

00:04:39,789 --> 00:04:44,279
of that functionality about retries and

00:04:42,069 --> 00:04:46,539
temporal decoupling and routing and

00:04:44,279 --> 00:04:50,740
finding out where things should go that

00:04:46,539 --> 00:04:52,779
goes into every single app if you're

00:04:50,740 --> 00:04:55,090
going to operate in this way and you

00:04:52,779 --> 00:04:56,740
want micro-services and you want to have

00:04:55,090 --> 00:05:00,129
more than one instance of a thing you

00:04:56,740 --> 00:05:03,189
are going to need to prepare to optimize

00:05:00,129 --> 00:05:05,650
her availability over consistency we do

00:05:03,189 --> 00:05:08,680
get people that say I want to do micro

00:05:05,650 --> 00:05:11,110
services I hear their call can we put

00:05:08,680 --> 00:05:13,029
some distribution transactions in the

00:05:11,110 --> 00:05:16,870
answer is you really don't want to do

00:05:13,029 --> 00:05:19,719
that okay fortuitously last night in the

00:05:16,870 --> 00:05:22,029
bar probably about half midnight a

00:05:19,719 --> 00:05:24,210
friend of mine who works for a software

00:05:22,029 --> 00:05:26,800
vendor came out with this classic quote

00:05:24,210 --> 00:05:30,490
which was quite lucky the transactions

00:05:26,800 --> 00:05:32,289
of lazy architects okay transactions we

00:05:30,490 --> 00:05:34,360
put in systems to stop bad things

00:05:32,289 --> 00:05:37,659
happening with our data it's a

00:05:34,360 --> 00:05:39,520
preventative measure when we have to

00:05:37,659 --> 00:05:41,710
deal with eventual consistency which we

00:05:39,520 --> 00:05:44,529
do have to do as soon as we have two

00:05:41,710 --> 00:05:47,110
instances of a thing running then we

00:05:44,529 --> 00:05:50,409
instead move to a world where we have to

00:05:47,110 --> 00:05:51,819
remediate bad things that happened we

00:05:50,409 --> 00:05:53,319
don't try and prevent data getting

00:05:51,819 --> 00:05:55,360
inconsistent we allow it to become

00:05:53,319 --> 00:05:57,550
inconsistent but we make sure we deal

00:05:55,360 --> 00:06:00,909
with it at a later date we'll do

00:05:57,550 --> 00:06:03,659
something to detect and then act on that

00:06:00,909 --> 00:06:07,210
divergence of history

00:06:03,659 --> 00:06:09,279
so in this Whistlestop the guide to

00:06:07,210 --> 00:06:11,589
future proofing monoliths there's kind

00:06:09,279 --> 00:06:13,839
of three broad strokes of things that we

00:06:11,589 --> 00:06:15,879
can do going from the quite easy and the

00:06:13,839 --> 00:06:17,560
quite straightforward to the this is

00:06:15,879 --> 00:06:18,990
getting a bit more complex now this is

00:06:17,560 --> 00:06:22,839
adding a bit of overhead to our code

00:06:18,990 --> 00:06:24,969
first up separation of concerns I mean

00:06:22,839 --> 00:06:26,919
really when we get involved in moving

00:06:24,969 --> 00:06:28,240
apps and breaking them apart that's

00:06:26,919 --> 00:06:29,979
normally the number one thing that

00:06:28,240 --> 00:06:32,319
causes a problem like fairly

00:06:29,979 --> 00:06:34,029
straightforward stuff well that class is

00:06:32,319 --> 00:06:37,509
doing too many things this knows about

00:06:34,029 --> 00:06:38,860
the database and it shouldn't do then we

00:06:37,509 --> 00:06:39,790
start talking about communicating via

00:06:38,860 --> 00:06:43,230
events rather than

00:06:39,790 --> 00:06:46,450
direct RPC direct method invocation that

00:06:43,230 --> 00:06:48,730
in itself isn't necessarily going to

00:06:46,450 --> 00:06:50,560
help with moving to microservices and

00:06:48,730 --> 00:06:52,450
dealing with ventral consistency but it

00:06:50,560 --> 00:06:54,760
gives us some benefits that we see in a

00:06:52,450 --> 00:06:59,770
moment and it also allows us to handle

00:06:54,760 --> 00:07:03,910
eventual consistency so what do I mean

00:06:59,770 --> 00:07:07,240
when I say services the opposite of a

00:07:03,910 --> 00:07:08,680
rich domain fat object you read an

00:07:07,240 --> 00:07:10,030
object-oriented programming book from

00:07:08,680 --> 00:07:11,620
the nineties and they probably should

00:07:10,030 --> 00:07:13,330
have said you've got a user objects

00:07:11,620 --> 00:07:15,700
which has a save method and it has the

00:07:13,330 --> 00:07:16,750
update method and it contains all of its

00:07:15,700 --> 00:07:18,190
state and it knows about all the

00:07:16,750 --> 00:07:20,260
behavior of things that can be done with

00:07:18,190 --> 00:07:22,060
it I think we've all moved away from

00:07:20,260 --> 00:07:23,920
that now because that ends up with these

00:07:22,060 --> 00:07:28,210
objects that know about all the things

00:07:23,920 --> 00:07:30,430
that can happen to them so my definition

00:07:28,210 --> 00:07:31,660
of a service is a thing that does a

00:07:30,430 --> 00:07:35,800
thing with a thing

00:07:31,660 --> 00:07:37,990
it's really quite succinct that and they

00:07:35,800 --> 00:07:39,640
should be stateless so they receive some

00:07:37,990 --> 00:07:41,290
kind of communication in they do

00:07:39,640 --> 00:07:43,330
something with it they chuck something

00:07:41,290 --> 00:07:44,440
out the other end or they have side

00:07:43,330 --> 00:07:47,010
effects and change the state of the

00:07:44,440 --> 00:07:49,180
world they don't hold state themselves

00:07:47,010 --> 00:07:50,770
until maybe when you start event

00:07:49,180 --> 00:07:56,020
sourcing but we'll get to that in a

00:07:50,770 --> 00:07:59,650
minute now somewhat embarrassingly this

00:07:56,020 --> 00:08:01,870
is still in my slide deck so if you can

00:07:59,650 --> 00:08:03,850
imagine they're like a large object

00:08:01,870 --> 00:08:06,700
record user or something with a save

00:08:03,850 --> 00:08:07,360
method and get name and a set name and

00:08:06,700 --> 00:08:09,460
all that kind of stuff

00:08:07,360 --> 00:08:12,340
that's what I'm talking about when I'm

00:08:09,460 --> 00:08:14,260
talking about rich domain objects this

00:08:12,340 --> 00:08:17,940
is the sort of thing that I'm talking

00:08:14,260 --> 00:08:20,620
about when talking about services so I

00:08:17,940 --> 00:08:22,570
was trying to come up with some really

00:08:20,620 --> 00:08:24,850
trivial examples to demonstrate

00:08:22,570 --> 00:08:26,890
principles in this but this is the kind

00:08:24,850 --> 00:08:28,570
of thing we've got a domain service that

00:08:26,890 --> 00:08:32,410
knows about accounts that can have

00:08:28,570 --> 00:08:35,950
transactions acted on them it gets set

00:08:32,410 --> 00:08:38,940
up it doesn't hold any state when

00:08:35,950 --> 00:08:41,620
something needs to change it gets told

00:08:38,940 --> 00:08:44,550
arguments it does the business logic and

00:08:41,620 --> 00:08:47,470
then it asks someone else to do the

00:08:44,550 --> 00:08:49,090
persistence for it so that's the kind of

00:08:47,470 --> 00:08:52,480
thing that I'm talking about when I'm

00:08:49,090 --> 00:08:54,639
referring services now the

00:08:52,480 --> 00:08:57,190
thing that I really hope if this is new

00:08:54,639 --> 00:08:59,889
to you that you take away from this talk

00:08:57,190 --> 00:09:01,240
is this if all the rest of it gets

00:08:59,889 --> 00:09:05,910
confusing later and quite complicated

00:09:01,240 --> 00:09:09,310
this is the main bit this pattern of

00:09:05,910 --> 00:09:10,480
these four layers I think applies to

00:09:09,310 --> 00:09:13,449
pretty much every system I've ever

00:09:10,480 --> 00:09:17,440
worked with at the top we've got gateway

00:09:13,449 --> 00:09:19,149
services so these are the gateways job

00:09:17,440 --> 00:09:24,639
is to translate from the outside world

00:09:19,149 --> 00:09:27,579
into our domain B HTTP AMQP even if you

00:09:24,639 --> 00:09:29,589
write CLI tool the entry point into your

00:09:27,579 --> 00:09:31,000
application that then parses

00:09:29,589 --> 00:09:32,920
command-line arguments that's your

00:09:31,000 --> 00:09:35,079
gateway layer it doesn't want to have

00:09:32,920 --> 00:09:36,850
any logic in it it just wants to be able

00:09:35,079 --> 00:09:39,220
to translate from the outside world into

00:09:36,850 --> 00:09:41,260
something meaningful that we then

00:09:39,220 --> 00:09:44,680
understand as oh right somebody's trying

00:09:41,260 --> 00:09:46,839
to achieve a thing the orchestration

00:09:44,680 --> 00:09:48,490
layer is below that so the Gateway

00:09:46,839 --> 00:09:51,190
doesn't do any thinking whatsoever it's

00:09:48,490 --> 00:09:54,579
just translation orchestration knows

00:09:51,190 --> 00:09:57,370
about workflow so maybe in a a

00:09:54,579 --> 00:09:59,920
software-as-a-service when we register a

00:09:57,370 --> 00:10:02,319
new user the orchestration gets one

00:09:59,920 --> 00:10:05,230
request from the Gateway layer saying

00:10:02,319 --> 00:10:07,510
register at user plays the orchestration

00:10:05,230 --> 00:10:08,709
tier is the bit that knows right first

00:10:07,510 --> 00:10:10,870
I've gotta go and write some records

00:10:08,709 --> 00:10:12,279
into the author system then I've got to

00:10:10,870 --> 00:10:15,130
go and put something into the users

00:10:12,279 --> 00:10:17,529
database and then maybe invoke some

00:10:15,130 --> 00:10:18,639
email sending service to let them know

00:10:17,529 --> 00:10:23,170
they've got to confirm their email

00:10:18,639 --> 00:10:24,130
address hands up if you are familiar

00:10:23,170 --> 00:10:29,850
with the difference between

00:10:24,130 --> 00:10:31,360
orchestration and choreography okay so

00:10:29,850 --> 00:10:33,819
orchestration is a particularly

00:10:31,360 --> 00:10:35,949
meaningful term here because it means

00:10:33,819 --> 00:10:38,470
that someone knows what's going to

00:10:35,949 --> 00:10:39,940
happen and it knows the workflow there's

00:10:38,470 --> 00:10:42,399
one thing that's responsible for that

00:10:39,940 --> 00:10:45,190
the alternative to orchestration is

00:10:42,399 --> 00:10:47,019
choreography and in a distributed system

00:10:45,190 --> 00:10:50,459
where we have lots of micro services

00:10:47,019 --> 00:10:52,750
that means that the services are

00:10:50,459 --> 00:10:54,459
responsible for emitting events and then

00:10:52,750 --> 00:10:55,930
another thing will pick that up and then

00:10:54,459 --> 00:10:58,300
maybe another thing will pick that up

00:10:55,930 --> 00:11:00,130
they're all decoupled but there's no one

00:10:58,300 --> 00:11:01,750
central place where you can look at and

00:11:00,130 --> 00:11:02,870
go alright the system is going to do

00:11:01,750 --> 00:11:05,210
that that and that

00:11:02,870 --> 00:11:07,820
in that order because the behavior

00:11:05,210 --> 00:11:09,920
becomes emerging now emergent behavior

00:11:07,820 --> 00:11:12,920
is awesome in people we like emergent

00:11:09,920 --> 00:11:14,480
behavior diversity leads to complexity

00:11:12,920 --> 00:11:16,550
which leads to emergence that's where

00:11:14,480 --> 00:11:18,560
innovation and creativity come from but

00:11:16,550 --> 00:11:20,900
it's also unpredictable so therefore not

00:11:18,560 --> 00:11:24,279
a desirable feature in one of our

00:11:20,900 --> 00:11:26,720
systems so orchestration knows workflow

00:11:24,279 --> 00:11:28,220
domain services hopefully this should

00:11:26,720 --> 00:11:30,080
make sense to everyone you know business

00:11:28,220 --> 00:11:33,800
logic the the boring stuff that we

00:11:30,080 --> 00:11:36,140
normally do and below that data services

00:11:33,800 --> 00:11:39,410
that whose sole job it is is to closely

00:11:36,140 --> 00:11:41,600
guard a data store all they do is i/o no

00:11:39,410 --> 00:11:42,800
business logic no validation that should

00:11:41,600 --> 00:11:44,870
have been done by someone higher up the

00:11:42,800 --> 00:11:46,630
stack these are responsible for

00:11:44,870 --> 00:11:47,750
abstracting away whether using MongoDB

00:11:46,630 --> 00:11:51,740
Cassandra

00:11:47,750 --> 00:11:54,710
MySQL or whatever every app you write

00:11:51,740 --> 00:11:57,110
I'm willing to bet you a drink will fit

00:11:54,710 --> 00:11:58,490
into that pattern yeah maybe it won't

00:11:57,110 --> 00:11:59,990
have the data layer depending on what

00:11:58,490 --> 00:12:03,770
it's doing but pretty much everything

00:11:59,990 --> 00:12:05,990
you write or ends up fitting into those

00:12:03,770 --> 00:12:08,000
four categories just knowing that and

00:12:05,990 --> 00:12:10,100
just separating your code into these

00:12:08,000 --> 00:12:13,610
four tiers will make your life easier in

00:12:10,100 --> 00:12:14,480
future so here's an example I don't know

00:12:13,610 --> 00:12:15,890
whether you can see that at the back

00:12:14,480 --> 00:12:18,260
hopefully not actually cuz it's a

00:12:15,890 --> 00:12:20,540
rubbish example of the kind of thing

00:12:18,260 --> 00:12:25,400
that frameworks like spring lead you

00:12:20,540 --> 00:12:27,620
into doing this is a controller and it's

00:12:25,400 --> 00:12:30,140
doing some business logic and it knows

00:12:27,620 --> 00:12:30,680
about repository so it knows how to save

00:12:30,140 --> 00:12:33,740
things

00:12:30,680 --> 00:12:35,180
it's got far too many concerns but if

00:12:33,740 --> 00:12:37,600
you had to get something up and running

00:12:35,180 --> 00:12:40,040
quickly this is probably what you'd do

00:12:37,600 --> 00:12:41,720
but it's not a good idea for the long

00:12:40,040 --> 00:12:43,850
run okay because you have all those

00:12:41,720 --> 00:12:45,830
concerns munch together as it evolves

00:12:43,850 --> 00:12:47,870
you'll end up with more and more in this

00:12:45,830 --> 00:12:50,150
one class it will be hard to migrate

00:12:47,870 --> 00:12:54,650
away from resist the temptation to do

00:12:50,150 --> 00:12:56,000
this so we've now written our

00:12:54,650 --> 00:12:59,209
application and we've got it into those

00:12:56,000 --> 00:13:00,260
four different strata of services what's

00:12:59,209 --> 00:13:04,480
the next thing we need to do to make

00:13:00,260 --> 00:13:07,070
this portable make it migrate able

00:13:04,480 --> 00:13:10,910
secure a slight hands off of you know

00:13:07,070 --> 00:13:12,829
what see qrs's call quite a few people

00:13:10,910 --> 00:13:15,380
for those that don't a command query

00:13:12,829 --> 00:13:16,639
responsibility segregation there are

00:13:15,380 --> 00:13:19,970
various connotation

00:13:16,639 --> 00:13:22,610
of what CQRS means the simple bit is

00:13:19,970 --> 00:13:24,319
separate you reads from your rights you

00:13:22,610 --> 00:13:26,389
have a separate right path through your

00:13:24,319 --> 00:13:29,089
application that can have side effects

00:13:26,389 --> 00:13:32,420
and changes States reads must not do

00:13:29,089 --> 00:13:36,170
that this makes your system very easily

00:13:32,420 --> 00:13:37,730
easy to reason about you know that when

00:13:36,170 --> 00:13:39,230
you call something called get account

00:13:37,730 --> 00:13:41,059
you're not going to change the state of

00:13:39,230 --> 00:13:44,299
the world you're just going to get some

00:13:41,059 --> 00:13:46,850
data back and that allows us to add in

00:13:44,299 --> 00:13:49,699
quick reads to this architecture so

00:13:46,850 --> 00:13:51,679
because the reads are always side-effect

00:13:49,699 --> 00:13:53,480
free we can do them anywhere and it

00:13:51,679 --> 00:13:56,749
doesn't matter they're safe it doesn't

00:13:53,480 --> 00:14:01,459
matter if any layer talks down to the

00:13:56,749 --> 00:14:05,779
data layer so we've got an application

00:14:01,459 --> 00:14:08,269
in these four tiers and we've got our

00:14:05,779 --> 00:14:09,739
right path separate to our read path if

00:14:08,269 --> 00:14:10,879
you want to go really hardcore with this

00:14:09,739 --> 00:14:15,499
you could spirit them in two different

00:14:10,879 --> 00:14:16,879
interfaces now what we need to do is not

00:14:15,499 --> 00:14:17,779
preparing for an event-driven

00:14:16,879 --> 00:14:20,929
architecture

00:14:17,779 --> 00:14:23,179
now the event-driven stuff is going to

00:14:20,929 --> 00:14:26,419
lead to our ability to handle eventual

00:14:23,179 --> 00:14:29,929
consistency it's a means to an end for

00:14:26,419 --> 00:14:32,779
us here and now so to prepare for this

00:14:29,929 --> 00:14:35,989
we can take some steps that you can do

00:14:32,779 --> 00:14:37,519
in any older app right now and it won't

00:14:35,989 --> 00:14:39,709
hurt you you have to write some more

00:14:37,519 --> 00:14:42,499
code but you'll have a code that's

00:14:39,709 --> 00:14:44,269
easier to reason about the first thing

00:14:42,499 --> 00:14:48,350
is to communicate with a mutable value

00:14:44,269 --> 00:14:50,749
objects what do I mean by that click

00:14:48,350 --> 00:14:55,459
there we go something that looks a bit

00:14:50,749 --> 00:14:57,819
like this so that's basically a

00:14:55,459 --> 00:15:01,369
parameter object we take into parameters

00:14:57,819 --> 00:15:03,769
on our do a transaction on a bank

00:15:01,369 --> 00:15:06,230
account please service and we've wrapped

00:15:03,769 --> 00:15:08,600
it up into one object it's got public

00:15:06,230 --> 00:15:10,160
finals I love this and I love it when

00:15:08,600 --> 00:15:12,529
people get upset that I'm making things

00:15:10,160 --> 00:15:14,989
member variables public and Java they're

00:15:12,529 --> 00:15:17,679
immutable why not be public we don't

00:15:14,989 --> 00:15:19,819
need all that getter and setter nonsense

00:15:17,679 --> 00:15:21,470
so if we communicate with these

00:15:19,819 --> 00:15:23,869
parameter objects that are immutable

00:15:21,470 --> 00:15:26,389
we have easier to reason about code I

00:15:23,869 --> 00:15:27,980
know that the thing downstream of me is

00:15:26,389 --> 00:15:29,960
not gonna fiddle with the data I've

00:15:27,980 --> 00:15:31,280
given it I've asked it to do a thing I

00:15:29,960 --> 00:15:33,290
expect it to do exactly what I've said

00:15:31,280 --> 00:15:35,990
not start changing the state of stuff if

00:15:33,290 --> 00:15:37,760
your code would it works on assumptions

00:15:35,990 --> 00:15:39,500
that you're going to have shared memory

00:15:37,760 --> 00:15:40,820
and you'll be able to change the state

00:15:39,500 --> 00:15:42,410
of an object after it's been sent to

00:15:40,820 --> 00:15:44,570
somebody else you can have a really bad

00:15:42,410 --> 00:15:45,800
time when it's distributed and you don't

00:15:44,570 --> 00:15:51,650
have shared memory because you're going

00:15:45,800 --> 00:15:55,970
over serialization hop and then after

00:15:51,650 --> 00:15:58,370
that we get into the really quite the

00:15:55,970 --> 00:16:04,250
first quite tricky issue which is

00:15:58,370 --> 00:16:05,990
dealing with idempotency when you've got

00:16:04,250 --> 00:16:07,820
a distributed system when you've got any

00:16:05,990 --> 00:16:11,780
degree of uncertainty you can either

00:16:07,820 --> 00:16:14,740
have at most once messaging or at least

00:16:11,780 --> 00:16:17,330
once messaging no matter what a

00:16:14,740 --> 00:16:19,880
salesperson from a very large vendor

00:16:17,330 --> 00:16:26,510
might tell you you cannot have exactly

00:16:19,880 --> 00:16:29,590
once messaging if I send a message and I

00:16:26,510 --> 00:16:31,760
don't hear anything back what do I do

00:16:29,590 --> 00:16:34,490
all right well I can't send it twice

00:16:31,760 --> 00:16:35,990
because something bad would happen so

00:16:34,490 --> 00:16:39,530
I'm just not gonna try again hopefully

00:16:35,990 --> 00:16:44,810
it got there that's at most once if I

00:16:39,530 --> 00:16:47,960
send a message nope no response I'll try

00:16:44,810 --> 00:16:51,260
again that's at least once we can't have

00:16:47,960 --> 00:16:52,850
exactly once messaging when there's some

00:16:51,260 --> 00:16:56,450
uncertainty as to whether that's going

00:16:52,850 --> 00:17:00,010
to be received or not so we have to deal

00:16:56,450 --> 00:17:03,530
with idempotency we have to know that

00:17:00,010 --> 00:17:05,270
when an operation is invoked it could be

00:17:03,530 --> 00:17:07,190
done in several times because the

00:17:05,270 --> 00:17:09,200
network might fail on the acknowledgment

00:17:07,190 --> 00:17:13,490
so we have to start thinking about that

00:17:09,200 --> 00:17:15,530
and tied into that issue is also the

00:17:13,490 --> 00:17:17,330
idea of being deterministic so

00:17:15,530 --> 00:17:19,910
idempotency I can do the same thing

00:17:17,330 --> 00:17:22,940
twice I get the same result determinism

00:17:19,910 --> 00:17:26,930
is that there are no random processes in

00:17:22,940 --> 00:17:30,230
this now where's ash and mr. shan't here

00:17:26,930 --> 00:17:31,670
ah boo was working with a customer last

00:17:30,230 --> 00:17:33,590
week and we were working through an

00:17:31,670 --> 00:17:35,930
example if we were basically emulating a

00:17:33,590 --> 00:17:38,960
multi DC approach to eventual

00:17:35,930 --> 00:17:42,920
consistency there it is did you hear me

00:17:38,960 --> 00:17:43,800
from outside cool so we were working

00:17:42,920 --> 00:17:45,030
with this and

00:17:43,800 --> 00:17:49,110
we realized that when we had multiple

00:17:45,030 --> 00:17:51,900
databases multiple DC's we couldn't do

00:17:49,110 --> 00:17:52,890
things like have auto incrementing IDs

00:17:51,900 --> 00:17:55,080
because you've got two different

00:17:52,890 --> 00:17:56,400
databases that's one bit of state that

00:17:55,080 --> 00:18:01,770
you would need to be consistent between

00:17:56,400 --> 00:18:03,720
the two and we need availability so one

00:18:01,770 --> 00:18:07,080
of the ways we can deal with idempotency

00:18:03,720 --> 00:18:09,360
and with deterministic behavior is to

00:18:07,080 --> 00:18:12,210
identify a transaction as close to the

00:18:09,360 --> 00:18:14,400
clients as possible if when a client

00:18:12,210 --> 00:18:17,280
asks you to create an account as a

00:18:14,400 --> 00:18:20,190
trivial example if the client decides

00:18:17,280 --> 00:18:22,020
the ID or if they tag that request with

00:18:20,190 --> 00:18:24,270
some kind of unique identifier a UUID

00:18:22,020 --> 00:18:26,520
then you can tell if you've received it

00:18:24,270 --> 00:18:29,520
twice have I seen this message before

00:18:26,520 --> 00:18:32,010
yes yes I have I won't do it again if

00:18:29,520 --> 00:18:33,030
you don't have any way of doing that how

00:18:32,010 --> 00:18:35,640
do you know they don't want to create

00:18:33,030 --> 00:18:38,250
two accounts we need to tag things as

00:18:35,640 --> 00:18:40,520
close as possible to the client that

00:18:38,250 --> 00:18:42,750
will make it much easier to deduplicate

00:18:40,520 --> 00:18:44,730
these messages going through the system

00:18:42,750 --> 00:18:48,630
so in this example which is very

00:18:44,730 --> 00:18:51,500
colorful we've changed from our original

00:18:48,630 --> 00:18:56,430
controller which were as where are we

00:18:51,500 --> 00:18:58,790
creating and creating an account I can't

00:18:56,430 --> 00:19:02,510
point there and look there

00:18:58,790 --> 00:19:05,940
here the client is specifying the ID

00:19:02,510 --> 00:19:07,950
also you can see that we're now using a

00:19:05,940 --> 00:19:10,110
parameter object so rather than passing

00:19:07,950 --> 00:19:12,420
through just the ID we've wrapped it up

00:19:10,110 --> 00:19:14,340
in a parameter object that's going to

00:19:12,420 --> 00:19:17,780
make it easier to turn into an

00:19:14,340 --> 00:19:17,780
event-driven system later on

00:19:19,100 --> 00:19:28,550
so speaking of events in an event-driven

00:19:25,950 --> 00:19:30,660
system we communicate with events

00:19:28,550 --> 00:19:32,150
immutable things that have happened in

00:19:30,660 --> 00:19:36,360
the past and are therefore

00:19:32,150 --> 00:19:38,970
incontrovertible our parameter objects

00:19:36,360 --> 00:19:41,460
were immutable this is one of the

00:19:38,970 --> 00:19:42,870
reasons why so we can say that a thing

00:19:41,460 --> 00:19:45,510
happened and that no one's going to

00:19:42,870 --> 00:19:51,380
fiddle with it later you'll notice in

00:19:45,510 --> 00:19:53,760
the previous example that that way

00:19:51,380 --> 00:19:57,260
this parameter object was called account

00:19:53,760 --> 00:19:59,179
created account create requested that's

00:19:57,260 --> 00:20:00,980
it's a thing that happens we've given it

00:19:59,179 --> 00:20:03,919
a name so it makes more sense when we

00:20:00,980 --> 00:20:05,840
replay these in history so we

00:20:03,919 --> 00:20:08,799
communicate with events but that also

00:20:05,840 --> 00:20:11,240
means that we're not directly invoke a

00:20:08,799 --> 00:20:13,549
downstream system when our domain

00:20:11,240 --> 00:20:15,770
service wants to save something instead

00:20:13,549 --> 00:20:18,590
of calling the data service and saying

00:20:15,770 --> 00:20:21,559
data service please save this record we

00:20:18,590 --> 00:20:25,429
instead admit an event to whoever might

00:20:21,559 --> 00:20:27,850
be listening saying that somebody asked

00:20:25,429 --> 00:20:31,549
for an account to be saved now

00:20:27,850 --> 00:20:35,090
so we deke up all our systems in that

00:20:31,549 --> 00:20:36,500
way one of the downsides this and the

00:20:35,090 --> 00:20:38,419
thing that will you'll end up having to

00:20:36,500 --> 00:20:41,240
change loads of code because of is that

00:20:38,419 --> 00:20:43,610
you can't have return values event

00:20:41,240 --> 00:20:45,890
submission is fire-and-forget if we're

00:20:43,610 --> 00:20:48,740
in a distributed system and I'm sending

00:20:45,890 --> 00:20:51,799
an event saying somebody wanted saver an

00:20:48,740 --> 00:20:53,960
account and then the data service sends

00:20:51,799 --> 00:20:56,030
back an event saying some I created the

00:20:53,960 --> 00:20:57,799
account I don't know if I'm going to be

00:20:56,030 --> 00:21:00,190
the one receiving that it could be

00:20:57,799 --> 00:21:04,669
another instance of the domain service

00:21:00,190 --> 00:21:05,929
so we can't expect return values and we

00:21:04,669 --> 00:21:09,320
have to block and all sorts of other

00:21:05,929 --> 00:21:12,140
things so our code ends up looking more

00:21:09,320 --> 00:21:15,440
like this we've got an example here

00:21:12,140 --> 00:21:17,840
where we're just doing a post to some

00:21:15,440 --> 00:21:19,820
event bus we don't know whether it's

00:21:17,840 --> 00:21:21,500
going to work that's for somebody else

00:21:19,820 --> 00:21:27,830
to figure out they will it emit an event

00:21:21,500 --> 00:21:32,090
when that has happened when we do this

00:21:27,830 --> 00:21:33,770
and we can't get a return value

00:21:32,090 --> 00:21:34,760
immediately because we're asynchronous

00:21:33,770 --> 00:21:37,010
and we don't know if we're going to be

00:21:34,760 --> 00:21:39,860
the person to receive the system to

00:21:37,010 --> 00:21:42,440
receive the request what if I need

00:21:39,860 --> 00:21:46,309
something what if when somebody asks me

00:21:42,440 --> 00:21:48,440
can you domain service please create an

00:21:46,309 --> 00:21:50,540
account or update an account what if I

00:21:48,440 --> 00:21:55,370
need to emit another event saying yeah

00:21:50,540 --> 00:21:57,980
it was done and I debited 30 pounds and

00:21:55,370 --> 00:21:59,210
the resulting balance was 100 pounds and

00:21:57,980 --> 00:22:02,030
this is the account number what if I

00:21:59,210 --> 00:22:03,860
need to then emit something out to the

00:22:02,030 --> 00:22:07,220
rest of the world saying that I did my

00:22:03,860 --> 00:22:08,690
job what if I'm not the person's receive

00:22:07,220 --> 00:22:09,450
it how's another domain service gonna

00:22:08,690 --> 00:22:12,289
know how to

00:22:09,450 --> 00:22:16,559
that we then get into the realms of

00:22:12,289 --> 00:22:19,260
event carried state transfer the idea

00:22:16,559 --> 00:22:21,570
here being for anything that somebody

00:22:19,260 --> 00:22:26,610
might need to know in the causal chain

00:22:21,570 --> 00:22:28,769
of events that we want to trigger has to

00:22:26,610 --> 00:22:32,039
be carried through with these events we

00:22:28,769 --> 00:22:34,590
can't rely on me holding some state

00:22:32,039 --> 00:22:36,299
right I fired off an event to save this

00:22:34,590 --> 00:22:37,769
record in the database when I hear back

00:22:36,299 --> 00:22:40,710
I'll tell everyone else that that

00:22:37,769 --> 00:22:43,429
particular event was completed I can't

00:22:40,710 --> 00:22:48,600
do that because I might not receive it

00:22:43,429 --> 00:22:52,860
so an example of this would be where

00:22:48,600 --> 00:22:55,409
we're doing a debit on an account so the

00:22:52,860 --> 00:22:58,860
domain service receives a request saying

00:22:55,409 --> 00:23:02,070
can we take 30 pounds or euros or Swiss

00:22:58,860 --> 00:23:05,340
francs or dollars or bitcoins out of

00:23:02,070 --> 00:23:07,019
account one the main service checks the

00:23:05,340 --> 00:23:09,480
balance goes yep they've got enough

00:23:07,019 --> 00:23:11,130
money I'm happy for that to happen it

00:23:09,480 --> 00:23:13,830
does the business logic the validation

00:23:11,130 --> 00:23:17,779
and then tells the date service set the

00:23:13,830 --> 00:23:21,899
balance of account 1 to be 70 pounds now

00:23:17,779 --> 00:23:23,659
the days service responds back going yep

00:23:21,899 --> 00:23:27,210
I've updated the balance of account 1

00:23:23,659 --> 00:23:30,059
the receiving domain service that's

00:23:27,210 --> 00:23:32,639
listening to those the data has been

00:23:30,059 --> 00:23:34,529
written events it doesn't know how to

00:23:32,639 --> 00:23:37,190
respond it hasn't got the information it

00:23:34,529 --> 00:23:41,519
needs because in that flow of events

00:23:37,190 --> 00:23:43,769
data was lost so instead we need to pass

00:23:41,519 --> 00:23:48,690
through more state we need to pass

00:23:43,769 --> 00:23:51,120
through the whole chain of stuff so here

00:23:48,690 --> 00:23:54,630
even though the data service doesn't

00:23:51,120 --> 00:23:56,940
need to know the amount by which the

00:23:54,630 --> 00:23:59,130
balance changed all it needs to know is

00:23:56,940 --> 00:24:01,649
the final result which is 70 pounds but

00:23:59,130 --> 00:24:04,230
we pass through the amount it was

00:24:01,649 --> 00:24:06,779
changed by so then it can communicate it

00:24:04,230 --> 00:24:09,409
back up the stack so then whichever

00:24:06,779 --> 00:24:13,289
domain service receives that event can

00:24:09,409 --> 00:24:15,750
then report correctly an event of yes an

00:24:13,289 --> 00:24:20,279
account was debited and here's all the

00:24:15,750 --> 00:24:23,420
information you need that's event

00:24:20,279 --> 00:24:25,650
carried State transfer that allows

00:24:23,420 --> 00:24:26,250
different actors in the system to

00:24:25,650 --> 00:24:27,900
respond

00:24:26,250 --> 00:24:32,420
whichever messages they receive without

00:24:27,900 --> 00:24:32,420
having to hold or share state directly

00:24:32,450 --> 00:24:40,200
so we kind of now prepared ourselves for

00:24:38,070 --> 00:24:42,780
distribution and these things aren't

00:24:40,200 --> 00:24:44,700
necessarily massive changes like the

00:24:42,780 --> 00:24:46,020
separation in those four tiers not a big

00:24:44,700 --> 00:24:46,770
deal I would recommend you should be

00:24:46,020 --> 00:24:49,830
doing that anyway

00:24:46,770 --> 00:24:50,340
immutable parameter objects definitely

00:24:49,830 --> 00:24:52,530
do that

00:24:50,340 --> 00:24:56,669
more mutability always more reasonable

00:24:52,530 --> 00:24:57,870
code event-driven hmm okay maybe this is

00:24:56,669 --> 00:24:59,340
getting a little bit inconvenient now

00:24:57,870 --> 00:25:01,860
this isn't how I would like to write

00:24:59,340 --> 00:25:03,480
systems quickly but it will future-proof

00:25:01,860 --> 00:25:08,580
us we're now going to get into the

00:25:03,480 --> 00:25:10,230
realms of things that are necessary for

00:25:08,580 --> 00:25:14,000
dealing with eventual consistency in the

00:25:10,230 --> 00:25:17,250
distributed system and our more work I

00:25:14,000 --> 00:25:18,900
said that using events and an

00:25:17,250 --> 00:25:21,750
event-driven architecture for this

00:25:18,900 --> 00:25:24,360
discussion was a means to an end it's a

00:25:21,750 --> 00:25:27,540
means to an end of being able to replay

00:25:24,360 --> 00:25:29,850
events so event sourcing is the idea

00:25:27,540 --> 00:25:31,740
that we keep a track of every single one

00:25:29,850 --> 00:25:34,730
of those events that was omitted by any

00:25:31,740 --> 00:25:37,200
actor in the system we store those and

00:25:34,730 --> 00:25:39,450
then when we want to build our view of

00:25:37,200 --> 00:25:43,980
the world we replay them from beginning

00:25:39,450 --> 00:25:45,929
to end this is cool because it gives us

00:25:43,980 --> 00:25:47,580
a means to deal with eventual

00:25:45,929 --> 00:25:49,200
consistency we'll get to that in a bit

00:25:47,580 --> 00:25:56,220
but it also gives you some other

00:25:49,200 --> 00:25:58,290
benefits as well so event list might

00:25:56,220 --> 00:26:01,890
look something like this we've created

00:25:58,290 --> 00:26:03,570
an account somebody asked to save it the

00:26:01,890 --> 00:26:05,429
date service said yep I've saved that

00:26:03,570 --> 00:26:07,500
and then the domain service above it

00:26:05,429 --> 00:26:09,299
says yes an account was created so on

00:26:07,500 --> 00:26:12,960
and so forth so we get this log of all

00:26:09,299 --> 00:26:14,700
the events that have changed this gives

00:26:12,960 --> 00:26:16,950
us benefits without worrying about

00:26:14,700 --> 00:26:20,429
distribution and about eventual

00:26:16,950 --> 00:26:22,890
consistency because if there's a bug we

00:26:20,429 --> 00:26:25,169
can replay everything that happened

00:26:22,890 --> 00:26:26,730
during that day the financial company

00:26:25,169 --> 00:26:28,350
that I was talking to you about at the

00:26:26,730 --> 00:26:30,570
beginning of the talk we used to do this

00:26:28,350 --> 00:26:32,940
if there was weird behavior in one of

00:26:30,570 --> 00:26:35,160
the systems because every single message

00:26:32,940 --> 00:26:36,060
have been recorded we could replay a

00:26:35,160 --> 00:26:37,950
whole day's

00:26:36,060 --> 00:26:40,860
reading activity and see where the

00:26:37,950 --> 00:26:44,040
problem lied it's also useful for

00:26:40,860 --> 00:26:46,170
modeling and for testing if we want to

00:26:44,040 --> 00:26:48,480
change our business logic and see I

00:26:46,170 --> 00:26:51,870
don't know if we're a bank and we charge

00:26:48,480 --> 00:26:55,080
someone 10% when they go overdrawn what

00:26:51,870 --> 00:26:57,780
would happen if we charge them 20% we

00:26:55,080 --> 00:27:00,360
can change our implementation run the

00:26:57,780 --> 00:27:02,100
event lock through it and see how things

00:27:00,360 --> 00:27:04,920
would have changed so it gives you

00:27:02,100 --> 00:27:09,030
modeling capability as well as the

00:27:04,920 --> 00:27:12,480
ability to debug into what would

00:27:09,030 --> 00:27:15,150
apparently be one-off issues once we've

00:27:12,480 --> 00:27:18,210
got that list of events we can start

00:27:15,150 --> 00:27:19,710
thinking about how we might merge those

00:27:18,210 --> 00:27:23,250
histories of events together from

00:27:19,710 --> 00:27:25,620
different databases so here's an example

00:27:23,250 --> 00:27:28,710
without always working with working

00:27:25,620 --> 00:27:29,580
through with Hashem last week so he

00:27:28,710 --> 00:27:34,020
definitely deserves some of the credit

00:27:29,580 --> 00:27:36,270
for this we've got two datacenters with

00:27:34,020 --> 00:27:38,610
two copies of our app stack whether it's

00:27:36,270 --> 00:27:40,110
a monolith or you know though those apps

00:27:38,610 --> 00:27:41,970
actually app a whole bunch of micro

00:27:40,110 --> 00:27:45,330
services for this example it doesn't

00:27:41,970 --> 00:27:48,030
matter we get a request in on the

00:27:45,330 --> 00:27:52,230
left-hand date Center saying let's add

00:27:48,030 --> 00:27:55,440
100 pounds to account number one that

00:27:52,230 --> 00:27:58,350
gets stored in to the left database and

00:27:55,440 --> 00:28:01,050
by some means those two can talk to each

00:27:58,350 --> 00:28:02,280
other that information gets shared like

00:28:01,050 --> 00:28:04,170
the actual implementation of that

00:28:02,280 --> 00:28:05,940
pretend it's Cassandra I don't know it

00:28:04,170 --> 00:28:07,920
doesn't really matter but conceptually

00:28:05,940 --> 00:28:11,160
that's what's happening when there is no

00:28:07,920 --> 00:28:15,570
network partition but if we introduced a

00:28:11,160 --> 00:28:17,730
network partition so we've added a

00:28:15,570 --> 00:28:19,890
hundred pounds into our account now now

00:28:17,730 --> 00:28:21,360
the user wants to take some out but

00:28:19,890 --> 00:28:22,710
there's a network partition and our apps

00:28:21,360 --> 00:28:25,290
in our databases can't talk to each

00:28:22,710 --> 00:28:27,570
other so on the left side we think we've

00:28:25,290 --> 00:28:30,780
got hundred pounds on the right side we

00:28:27,570 --> 00:28:35,310
think we've got a hundred pounds on the

00:28:30,780 --> 00:28:38,280
left side the user asks to take out 70

00:28:35,310 --> 00:28:39,540
pounds we go to the left database yep

00:28:38,280 --> 00:28:42,360
you've got enough money for that great

00:28:39,540 --> 00:28:46,110
I'm going to take out 70 pounds and set

00:28:42,360 --> 00:28:49,250
your balance to be 30 pounds great same

00:28:46,110 --> 00:28:52,370
user then runs a second request going

00:28:49,250 --> 00:28:54,560
ah ah and it can't be shared because

00:28:52,370 --> 00:28:58,760
we've got a network partition so that

00:28:54,560 --> 00:29:01,010
state is isolated in one DC the user may

00:28:58,760 --> 00:29:02,810
be a naughty hacker realizes that

00:29:01,010 --> 00:29:04,640
there's a network partition runs a

00:29:02,810 --> 00:29:07,010
second request routing through to the

00:29:04,640 --> 00:29:10,520
second datacenter and I'd like to take

00:29:07,010 --> 00:29:11,810
out 60 pounds now please the right-hand

00:29:10,520 --> 00:29:13,580
database still thinks we have a hundred

00:29:11,810 --> 00:29:16,310
pounds because it hasn't heard any

00:29:13,580 --> 00:29:19,130
different so it sets the balance to 40

00:29:16,310 --> 00:29:24,020
after doing its validation checks and it

00:29:19,130 --> 00:29:25,790
can't share that information yet network

00:29:24,020 --> 00:29:27,260
partition gets resolved these two

00:29:25,790 --> 00:29:32,210
databases start talking to each other

00:29:27,260 --> 00:29:34,100
again what happens what we've got a

00:29:32,210 --> 00:29:37,550
situation like this where we've got some

00:29:34,100 --> 00:29:39,440
common history up at the top and then

00:29:37,550 --> 00:29:41,660
we've got these events down here and

00:29:39,440 --> 00:29:43,790
these events over there how are we going

00:29:41,660 --> 00:29:46,490
to merge those together how do we even

00:29:43,790 --> 00:29:48,320
know what order they happened in how do

00:29:46,490 --> 00:29:52,040
when we're putting these in we could use

00:29:48,320 --> 00:29:54,590
timestamps but time is entirely relative

00:29:52,040 --> 00:29:55,820
you know time does not flow the same for

00:29:54,590 --> 00:29:56,990
two observers in different parts of the

00:29:55,820 --> 00:29:58,910
universe depending what speed they're

00:29:56,990 --> 00:30:00,830
going on all those kind of things let

00:29:58,910 --> 00:30:03,530
alone when you introduce NTP and clock

00:30:00,830 --> 00:30:07,280
drift and leap seconds so how are we

00:30:03,530 --> 00:30:10,460
gonna order those the answer is vector

00:30:07,280 --> 00:30:15,290
clocks hands up if you understand vector

00:30:10,460 --> 00:30:17,050
clocks so chances put his hand up after

00:30:15,290 --> 00:30:20,810
we modelled away through this last week

00:30:17,050 --> 00:30:23,780
so there are quite there were two

00:30:20,810 --> 00:30:26,120
possible answers this right one solution

00:30:23,780 --> 00:30:28,280
is vector clocks the other is that we

00:30:26,120 --> 00:30:30,830
could tag like the last event that we

00:30:28,280 --> 00:30:32,810
saw if every event gets a unique

00:30:30,830 --> 00:30:35,570
identifier then we could always chain

00:30:32,810 --> 00:30:37,310
our events and say well this one was

00:30:35,570 --> 00:30:40,100
caused by that one which was caused by

00:30:37,310 --> 00:30:44,330
that one vector clocks are basically a

00:30:40,100 --> 00:30:49,090
more efficient way of doing that so each

00:30:44,330 --> 00:30:52,460
actor in our system every time it sees

00:30:49,090 --> 00:30:56,150
an event relay or act on an event

00:30:52,460 --> 00:30:59,240
relating to a particular account it tags

00:30:56,150 --> 00:31:01,490
that event with its identifier so this

00:30:59,240 --> 00:31:02,210
is the left data center and it's saying

00:31:01,490 --> 00:31:04,100
this is the

00:31:02,210 --> 00:31:08,890
first time I've got had an event that's

00:31:04,100 --> 00:31:11,660
acted on this the next event happens

00:31:08,890 --> 00:31:13,610
this is also the left datacenter hour

00:31:11,660 --> 00:31:17,210
right days Center hasn't got involved

00:31:13,610 --> 00:31:19,280
hasn't seen any of this yet and then our

00:31:17,210 --> 00:31:21,650
third event happens so we've ticked up

00:31:19,280 --> 00:31:24,140
three times that we've acted on this

00:31:21,650 --> 00:31:26,990
account in the left eighth Center then

00:31:24,140 --> 00:31:29,060
we get on Network partition and we get

00:31:26,990 --> 00:31:31,280
one branch of history over here on one

00:31:29,060 --> 00:31:33,470
branch history over here and we can see

00:31:31,280 --> 00:31:36,290
the the numbers tick up for the left

00:31:33,470 --> 00:31:41,750
dates ends over here but over here it

00:31:36,290 --> 00:31:44,570
will get stuck on 3r increments vector

00:31:41,750 --> 00:31:49,190
clocks can determine whether things are

00:31:44,570 --> 00:31:51,530
causally related some an event is

00:31:49,190 --> 00:31:55,640
descendant of another event it is caused

00:31:51,530 --> 00:32:02,990
by another event if all elements in its

00:31:55,640 --> 00:32:05,690
ancestor have the same if all elements

00:32:02,990 --> 00:32:08,090
in the descendant are greater than or

00:32:05,690 --> 00:32:12,080
equal to ones in the ancestor so for

00:32:08,090 --> 00:32:15,320
example we can tell that this is not a

00:32:12,080 --> 00:32:18,560
descendant of this because three is not

00:32:15,320 --> 00:32:22,070
greater than four 1 is greater than zero

00:32:18,560 --> 00:32:24,800
but we can tell here that we've got a

00:32:22,070 --> 00:32:27,080
conflict we can tell that this is

00:32:24,800 --> 00:32:31,130
greater than is a descendant of that

00:32:27,080 --> 00:32:34,070
because 4 is greater than 3 0 is equal

00:32:31,130 --> 00:32:36,500
to 0 and we tell that this is a

00:32:34,070 --> 00:32:41,750
descendant of that because 3 the same as

00:32:36,500 --> 00:32:44,900
3 1 is greater than 0 this allows us to

00:32:41,750 --> 00:32:47,090
build a causal history we can track

00:32:44,900 --> 00:32:50,420
through all of the events in our system

00:32:47,090 --> 00:32:52,070
what happened why and in which logical

00:32:50,420 --> 00:32:54,140
order we don't know what time they

00:32:52,070 --> 00:32:56,870
happened in and we can't tell that this

00:32:54,140 --> 00:32:59,420
happened before or after that but we can

00:32:56,870 --> 00:33:01,820
tell that history has diverged and we've

00:32:59,420 --> 00:33:06,050
got two parallel dimensions of

00:33:01,820 --> 00:33:08,300
transactions so if we can track those

00:33:06,050 --> 00:33:12,260
histories than we can detect when they

00:33:08,300 --> 00:33:14,780
diverge that means that when we're doing

00:33:12,260 --> 00:33:16,370
event sourcing and we're replaying state

00:33:14,780 --> 00:33:18,200
remember that we build our view of the

00:33:16,370 --> 00:33:20,360
world with event sourcing by replaying

00:33:18,200 --> 00:33:22,430
each one of those events to build our

00:33:20,360 --> 00:33:25,460
view of the world when we detect a

00:33:22,430 --> 00:33:28,100
branch we can do something about it if

00:33:25,460 --> 00:33:29,690
you've got two databases that say well

00:33:28,100 --> 00:33:32,150
the account balance is 30 and the

00:33:29,690 --> 00:33:33,920
account balance is 40 you've got no way

00:33:32,150 --> 00:33:35,480
of intelligently merging those together

00:33:33,920 --> 00:33:37,850
those are just conflicting bits of

00:33:35,480 --> 00:33:40,190
information when you've got conflicting

00:33:37,850 --> 00:33:42,590
event histories then you can do

00:33:40,190 --> 00:33:44,690
something about it you can see why they

00:33:42,590 --> 00:33:47,810
diverge and you can see when they first

00:33:44,690 --> 00:33:50,360
started diverging that means that you

00:33:47,810 --> 00:33:52,280
can do something particular to that type

00:33:50,360 --> 00:33:54,860
of event you know what events it was

00:33:52,280 --> 00:33:57,770
that caused the branching and then you

00:33:54,860 --> 00:33:59,960
could implement your own logic there you

00:33:57,770 --> 00:34:02,180
can have an event specific divergence

00:33:59,960 --> 00:34:04,190
handler that will take remediate of

00:34:02,180 --> 00:34:05,420
action so remember at the beginning I

00:34:04,190 --> 00:34:07,660
was saying that transactions are

00:34:05,420 --> 00:34:10,670
preventing bad things happening in

00:34:07,660 --> 00:34:12,950
eventual consistent land you have to

00:34:10,670 --> 00:34:15,440
take action to correct the bad things

00:34:12,950 --> 00:34:19,190
that will have happened maybe in this

00:34:15,440 --> 00:34:21,020
instance we attempt to do both branches

00:34:19,190 --> 00:34:22,310
of history maybe they did have enough

00:34:21,020 --> 00:34:25,850
money you know if they were two

00:34:22,310 --> 00:34:26,900
conflicting withdrawals and they did

00:34:25,850 --> 00:34:29,930
have enough money that would be fine

00:34:26,900 --> 00:34:31,460
maybe we cancel both maybe we do one and

00:34:29,930 --> 00:34:34,850
not the other maybe we do something

00:34:31,460 --> 00:34:36,770
completely different if we in processing

00:34:34,850 --> 00:34:40,250
that event a talk to an external system

00:34:36,770 --> 00:34:44,260
we could send a opposite message we

00:34:40,250 --> 00:34:44,260
could do the equivalent of a git revert

00:34:45,460 --> 00:34:50,510
only if we have that causal history and

00:34:48,740 --> 00:34:53,390
a list of all the events can we do

00:34:50,510 --> 00:34:55,820
something sensible when we detect a

00:34:53,390 --> 00:34:57,560
conflict if you're going to have a

00:34:55,820 --> 00:34:59,210
distributed system and you're going to

00:34:57,560 --> 00:35:02,390
have more Xserve is's in different

00:34:59,210 --> 00:35:07,280
places for resiliency or scaling you're

00:35:02,390 --> 00:35:13,400
gonna have to deal with this so that was

00:35:07,280 --> 00:35:16,220
a lot of information for half an hour so

00:35:13,400 --> 00:35:18,410
the engineer better guide to future

00:35:16,220 --> 00:35:19,700
proofing your monoliths I would have

00:35:18,410 --> 00:35:21,950
loved it if there have been fewer things

00:35:19,700 --> 00:35:23,360
on this slide unfortunately it's not

00:35:21,950 --> 00:35:26,960
necessarily that simple

00:35:23,360 --> 00:35:27,970
but you can do that separation of into

00:35:26,960 --> 00:35:30,760
those four tiers

00:35:27,970 --> 00:35:32,710
of Gateway orchestration domain and data

00:35:30,760 --> 00:35:33,869
start doing that now if you're not

00:35:32,710 --> 00:35:36,250
already doing it

00:35:33,869 --> 00:35:38,230
separate your rights from your reeds

00:35:36,250 --> 00:35:40,420
make sure that read operations don't

00:35:38,230 --> 00:35:42,130
have any side effects so you can reason

00:35:40,420 --> 00:35:46,930
about them so you can do performance

00:35:42,130 --> 00:35:48,790
optimization do caching if you then move

00:35:46,930 --> 00:35:50,770
towards using a mutable parameter

00:35:48,790 --> 00:35:53,740
objects you're a step closer towards

00:35:50,770 --> 00:35:55,000
being able to event source you also have

00:35:53,740 --> 00:35:57,760
code that's easier to reason about

00:35:55,000 --> 00:35:59,950
because your classes are immutable you

00:35:57,760 --> 00:36:03,250
can then move to doing asynchronous

00:35:59,950 --> 00:36:04,510
event-driven architecture and once

00:36:03,250 --> 00:36:05,859
you've got those events flowing through

00:36:04,510 --> 00:36:08,560
the system you can start recording them

00:36:05,859 --> 00:36:10,869
if you tag them with vector clocks then

00:36:08,560 --> 00:36:13,450
you can assert a causal history and then

00:36:10,869 --> 00:36:16,570
you can detect window histories diverge

00:36:13,450 --> 00:36:17,859
and then you can take remediate of steps

00:36:16,570 --> 00:36:24,280
when you realize that there is a

00:36:17,859 --> 00:36:31,200
conflict and that's it so hopefully that

00:36:24,280 --> 00:36:31,200
wasn't completely baffling any questions

00:36:33,420 --> 00:36:36,420
yes

00:36:39,789 --> 00:36:44,390
you lost me somewhere when you started

00:36:41,990 --> 00:36:46,609
to talk about that the micro sir or that

00:36:44,390 --> 00:36:48,740
the services should communicate so he

00:36:46,609 --> 00:36:52,279
wins and I wasn't totally clear why that

00:36:48,740 --> 00:36:55,250
is and if I have micro services they can

00:36:52,279 --> 00:36:57,410
talk over HTTP and that request respond

00:36:55,250 --> 00:37:01,400
so they get a response or why should I

00:36:57,410 --> 00:37:04,150
use events so the events allow you to do

00:37:01,400 --> 00:37:06,769
that event sourcing and to build up a

00:37:04,150 --> 00:37:09,289
meaningful semantic history of what's

00:37:06,769 --> 00:37:12,920
change in your system they can do that

00:37:09,289 --> 00:37:15,529
still over HTTP rest I pay TV rest is a

00:37:12,920 --> 00:37:18,289
transport mechanism but something in

00:37:15,529 --> 00:37:21,619
your app needs to be able to tell that I

00:37:18,289 --> 00:37:23,690
a thing has happened we're going to

00:37:21,619 --> 00:37:26,660
record that thing and now in order to

00:37:23,690 --> 00:37:28,130
tell the rest of the world you might in

00:37:26,660 --> 00:37:30,230
the old world you might do that with a

00:37:28,130 --> 00:37:32,900
message broke up of you am it an event

00:37:30,230 --> 00:37:37,519
and you do some TCP which is like acts

00:37:32,900 --> 00:37:39,019
Inc the message broker receives that you

00:37:37,519 --> 00:37:41,420
know it's received it and then it works

00:37:39,019 --> 00:37:43,309
out where to go in a micro services

00:37:41,420 --> 00:37:44,960
world it's similar but the thing that's

00:37:43,309 --> 00:37:47,269
working out where your message needs to

00:37:44,960 --> 00:37:48,230
go to is probably inside your app

00:37:47,269 --> 00:37:49,849
because you're doing some service

00:37:48,230 --> 00:37:52,910
discovery or something like that so a

00:37:49,849 --> 00:37:56,029
layer between your application and

00:37:52,910 --> 00:37:58,849
knowing where to call can perform that

00:37:56,029 --> 00:38:02,509
same job the important part about the

00:37:58,849 --> 00:38:05,450
events is being able to record that

00:38:02,509 --> 00:38:07,759
history of what has changed and why that

00:38:05,450 --> 00:38:09,980
makes sense so it goes in in the

00:38:07,759 --> 00:38:12,890
direction of prepare for resilience for

00:38:09,980 --> 00:38:14,599
a really widely distributed system so if

00:38:12,890 --> 00:38:16,549
I have a user sitting there in front of

00:38:14,599 --> 00:38:19,279
the screen and the user presses a button

00:38:16,549 --> 00:38:21,349
once a safe I would apply with well it

00:38:19,279 --> 00:38:24,890
didn't work the safe that is probably

00:38:21,349 --> 00:38:26,660
the very native easy case so the

00:38:24,890 --> 00:38:28,880
question was what would you do if

00:38:26,660 --> 00:38:31,279
somebody is trying to save something a

00:38:28,880 --> 00:38:34,430
users click Save button and it's failed

00:38:31,279 --> 00:38:36,440
in which way yeah it's like failing

00:38:34,430 --> 00:38:37,670
because can't talk to the database or

00:38:36,440 --> 00:38:40,220
two of the micro services can't

00:38:37,670 --> 00:38:42,319
communicate in this very moment and just

00:38:40,220 --> 00:38:44,299
propagate the arrow up and bubble it up

00:38:42,319 --> 00:38:46,730
and show the user well that didn't work

00:38:44,299 --> 00:38:49,430
yes so the client could timeout or you

00:38:46,730 --> 00:38:50,660
can omit failure event so if a handler

00:38:49,430 --> 00:38:53,060
has failed if the receive

00:38:50,660 --> 00:38:55,100
of a message has failed to process it

00:38:53,060 --> 00:38:57,110
correctly you would then emit an event

00:38:55,100 --> 00:38:59,960
that said this thing failed and it would

00:38:57,110 --> 00:39:02,390
probably include the original events

00:38:59,960 --> 00:39:04,190
like the causing event in there so then

00:39:02,390 --> 00:39:08,540
somebody can listen to that and report

00:39:04,190 --> 00:39:16,070
it back anymore or are we I think we're

00:39:08,540 --> 00:39:19,990
over time on me what anyone know when

00:39:16,070 --> 00:39:22,430
the next talk starts is it now sorry

00:39:19,990 --> 00:39:24,050
okay yes we are out of time it's four

00:39:22,430 --> 00:39:25,700
minutes past 4:00 right thank you very

00:39:24,050 --> 00:39:27,770
much for that I hope it wasn't

00:39:25,700 --> 00:39:28,770
completely confusing and happy to answer

00:39:27,770 --> 00:39:32,079
questions later

00:39:28,770 --> 00:39:32,079

YouTube URL: https://www.youtube.com/watch?v=hYVh8PbbeJw


