Title: Windows Server Containers for Cloud Foundry - Matthew Horan & Sunjay Bhatia, Pivotal
Publication date: 2017-10-18
Playlist: Cloud Foundry Summit Europe 2017
Description: 
	Windows Server Containers for Cloud Foundry - Matthew Horan & Sunjay Bhatia, Pivotal

The Garden Windows team has been working hard to bring Windows Server Containers to Cloud Foundry. We'll be providing an update on our progress in implementing Windows Server Containers support, and discuss the architecture of this implementation. We'll assess the new file-system and network isolation provided by Windows Server Containers, and cover some of the differences between Windows Server 2012R2 "containers" and the Windows Server Containers offered in Windows Server 2016. We'll also touch on the concept of HyperV isolation, which is new in Windows Server 2016.

About Sunjay Bhatia
Software Engineer, Pivotal Software, Inc.

About Matthew Horan
Matthew Horan has spent over a decade developing Web applications. Before becoming a developer, he worked as a systems administrator at various startups and hosting providers. Having worked with just about every configuration management tool, and being a developer by trade, he was naturally drawn to Cloud Foundry. He has focused on .NET due to a desire to bring the best practices of Pivotal's Cloud Foundry platform to a wider audience.
Captions: 
	00:00:00,000 --> 00:00:05,220
all right good afternoon everyone thanks

00:00:02,669 --> 00:00:06,480
for coming to our talk this is Windows

00:00:05,220 --> 00:00:08,400
Server containers for Cloud Foundry

00:00:06,480 --> 00:00:13,380
hopefully this is where you want to be

00:00:08,400 --> 00:00:15,389
promised will be interesting so my name

00:00:13,380 --> 00:00:16,859
is Sanjay Bhatia I'm a engineer at

00:00:15,389 --> 00:00:19,710
pivotal working on the garden windows

00:00:16,859 --> 00:00:21,840
team and I'm Matt horn software engineer

00:00:19,710 --> 00:00:26,609
at pivotal also working on the garden

00:00:21,840 --> 00:00:30,840
windows team so what have we been

00:00:26,609 --> 00:00:32,160
working on part of our mission here as

00:00:30,840 --> 00:00:36,120
that's the garden windows team is

00:00:32,160 --> 00:00:38,670
maintaining the windows 2012 r2 stack so

00:00:36,120 --> 00:00:41,730
if you want to push your dotnet

00:00:38,670 --> 00:00:44,430
applications to a Windows 2012 VM we

00:00:41,730 --> 00:00:48,570
maintain the garden implementation for

00:00:44,430 --> 00:00:51,930
that stack what we've implemented in the

00:00:48,570 --> 00:00:54,350
last year since our last appearance at

00:00:51,930 --> 00:00:56,789
the summit bill PEX thanks to our

00:00:54,350 --> 00:01:00,840
friends at HP for the initial work on

00:00:56,789 --> 00:01:02,699
that we added a configurable HTTP TCP

00:01:00,840 --> 00:01:05,360
health check to match Linux instead of

00:01:02,699 --> 00:01:07,950
the default mode that was just HTTP

00:01:05,360 --> 00:01:11,040
we've improved on the bind mount

00:01:07,950 --> 00:01:13,049
implementation you enable the use of

00:01:11,040 --> 00:01:15,990
instance identity credentials on Windows

00:01:13,049 --> 00:01:18,509
2012 some various security enhancements

00:01:15,990 --> 00:01:21,080
and we now have a CF deployment ops file

00:01:18,509 --> 00:01:21,080
that you can use

00:01:29,210 --> 00:01:34,640
in addition we've been we've implanted

00:01:32,060 --> 00:01:37,930
the Windows 2016 snack as you can see a

00:01:34,640 --> 00:01:40,790
screenshot of our lovely CF stacks there

00:01:37,930 --> 00:01:41,680
now we have two times more windows decks

00:01:40,790 --> 00:01:47,450
than Linux

00:01:41,680 --> 00:01:49,640
not that for years right yeah so why

00:01:47,450 --> 00:01:51,620
have we been doing this we've envisioned

00:01:49,640 --> 00:01:54,110
a first-class dotnet developer

00:01:51,620 --> 00:01:56,240
experience on CF we want to enable

00:01:54,110 --> 00:01:58,670
dotnet developers just as in the same

00:01:56,240 --> 00:02:01,160
way that Java developers are enabled

00:01:58,670 --> 00:02:03,490
with the Linux stack we want to reduce

00:02:01,160 --> 00:02:07,130
the burden of leveraging windows on CF

00:02:03,490 --> 00:02:09,080
part of that was helped by er the Bosh

00:02:07,130 --> 00:02:11,270
windows team we can Bosh deploy windows

00:02:09,080 --> 00:02:13,880
cells but containers on windows is a

00:02:11,270 --> 00:02:17,080
really important part of that so Windows

00:02:13,880 --> 00:02:19,070
2012 is gets us part of the way we

00:02:17,080 --> 00:02:20,600
implemented that stack that enables a

00:02:19,070 --> 00:02:23,060
lot of legacy applications a lot of

00:02:20,600 --> 00:02:26,260
dotnet developers but one of the things

00:02:23,060 --> 00:02:28,640
some of the things that the platform

00:02:26,260 --> 00:02:30,860
enables for Linux like container

00:02:28,640 --> 00:02:33,680
container networking pushing OCI images

00:02:30,860 --> 00:02:34,820
OCI build packs volume services those

00:02:33,680 --> 00:02:36,530
things are not really feasible on

00:02:34,820 --> 00:02:42,680
Windows 2012 and we want to enable those

00:02:36,530 --> 00:02:44,660
for done in developers cool so there are

00:02:42,680 --> 00:02:47,150
some shortcomings with that 2012 stack

00:02:44,660 --> 00:02:49,580
that we had out there for a number of

00:02:47,150 --> 00:02:52,400
years now basically those those

00:02:49,580 --> 00:02:55,550
containers or containers are pieced

00:02:52,400 --> 00:02:57,739
together using Java objects the Windows

00:02:55,550 --> 00:03:00,220
Firewall filesystem ackles

00:02:57,739 --> 00:03:02,690
all these things are relatively limited

00:03:00,220 --> 00:03:04,640
Java objects weren't really intended to

00:03:02,690 --> 00:03:06,980
be used for containers Java objects were

00:03:04,640 --> 00:03:08,510
were meant to be similar to Linux

00:03:06,980 --> 00:03:10,400
process groups so you could say these

00:03:08,510 --> 00:03:12,020
processes are related to each other in

00:03:10,400 --> 00:03:12,530
some way and then you can kill them all

00:03:12,020 --> 00:03:15,370
at once

00:03:12,530 --> 00:03:18,020
right so Java objects were a nice way to

00:03:15,370 --> 00:03:20,900
approximate containers and we could

00:03:18,020 --> 00:03:23,750
apply resource limits to some degree

00:03:20,900 --> 00:03:25,870
with them but they really didn't deliver

00:03:23,750 --> 00:03:27,800
everything that you'd expect from

00:03:25,870 --> 00:03:30,220
containerization especially compared

00:03:27,800 --> 00:03:33,709
with Linux the Windows Firewall is

00:03:30,220 --> 00:03:35,810
relatively limited well it's actually

00:03:33,709 --> 00:03:37,310
quite extensive what you can program it

00:03:35,810 --> 00:03:39,350
to do but there are some serious

00:03:37,310 --> 00:03:40,970
limitations like not being able to

00:03:39,350 --> 00:03:43,310
firewall local

00:03:40,970 --> 00:03:46,070
and so a process running a container on

00:03:43,310 --> 00:03:48,890
Linux can talk two processes running on

00:03:46,070 --> 00:03:52,580
the host over localhost and so if you're

00:03:48,890 --> 00:03:55,370
trying to protect your server from

00:03:52,580 --> 00:03:56,810
unauthorized use maybe you're deploying

00:03:55,370 --> 00:03:59,900
Cloud Foundry and you have components

00:03:56,810 --> 00:04:01,100
like the wrapper Metron or console you

00:03:59,900 --> 00:04:03,080
don't want containers to be able to talk

00:04:01,100 --> 00:04:07,280
to those processes you can't stop that

00:04:03,080 --> 00:04:10,910
from happening by a TCP on on Windows

00:04:07,280 --> 00:04:12,920
and then filesystem Ackles while they're

00:04:10,910 --> 00:04:14,690
great you still have a global filesystem

00:04:12,920 --> 00:04:17,510
and so if I also some a closed work

00:04:14,690 --> 00:04:19,370
pretty well but they're they're not as

00:04:17,510 --> 00:04:25,100
good as a container isolated final

00:04:19,370 --> 00:04:27,110
system there's a real lack of true

00:04:25,100 --> 00:04:29,330
isolation and resource limiting there's

00:04:27,110 --> 00:04:31,730
a shared system registry and so if you

00:04:29,330 --> 00:04:33,590
have a legacy application that's writing

00:04:31,730 --> 00:04:36,940
for something like H key local machine

00:04:33,590 --> 00:04:38,930
or you're writing to user registry you

00:04:36,940 --> 00:04:42,140
it's really you're gonna have a bad time

00:04:38,930 --> 00:04:43,910
it's just not it's not good that shared

00:04:42,140 --> 00:04:46,190
file system if you accidentally write

00:04:43,910 --> 00:04:49,100
some files to like a temp directory its

00:04:46,190 --> 00:04:51,919
global and so unless you've set the temp

00:04:49,100 --> 00:04:53,479
environment variable correctly that you

00:04:51,919 --> 00:04:55,100
might end up writing files to the same

00:04:53,479 --> 00:04:57,860
place with some other container and that

00:04:55,100 --> 00:04:59,840
can really lead to some problems in fact

00:04:57,860 --> 00:05:03,080
we saw issues with that in in early

00:04:59,840 --> 00:05:05,450
iterations of the project their shared

00:05:03,080 --> 00:05:08,030
network interfaces and so you can you

00:05:05,450 --> 00:05:11,030
can't firewall localhost and you can't

00:05:08,030 --> 00:05:12,919
set network bandwidth limits so if you

00:05:11,030 --> 00:05:14,660
have a really bad actor and maybe you're

00:05:12,919 --> 00:05:17,300
running a multi-tenant public cloud

00:05:14,660 --> 00:05:21,140
Windows is really not a good fit for

00:05:17,300 --> 00:05:25,190
that deployment we also didn't implement

00:05:21,140 --> 00:05:28,419
CPU limits in the 2012 r2 stack job

00:05:25,190 --> 00:05:31,490
objects do have the concept of applying

00:05:28,419 --> 00:05:34,370
CPU limit however it's percentage based

00:05:31,490 --> 00:05:36,440
and when you're trying to deploy you

00:05:34,370 --> 00:05:40,729
know n containers trying to divide up

00:05:36,440 --> 00:05:43,070
that shared based load via percentages

00:05:40,729 --> 00:05:45,130
becomes really hard we also start

00:05:43,070 --> 00:05:48,080
problems when turning on CPU limits

00:05:45,130 --> 00:05:48,830
where they just weren't sufficient in

00:05:48,080 --> 00:05:50,420
that

00:05:48,830 --> 00:05:52,940
containers couldn't even get themselves

00:05:50,420 --> 00:05:55,610
started if we applied CPU limits you

00:05:52,940 --> 00:05:58,280
just have so little CPU allocated to you

00:05:55,610 --> 00:06:00,110
via that percentage that we ended up

00:05:58,280 --> 00:06:04,580
shutting off CPU limits in the 2012

00:06:00,110 --> 00:06:08,090
offering and the isolation primitives

00:06:04,580 --> 00:06:13,730
are well primitive so there's a known

00:06:08,090 --> 00:06:17,360
exploit in the Java object kernel kernel

00:06:13,730 --> 00:06:19,730
call known as inconsolable this was

00:06:17,360 --> 00:06:22,160
documented by the Google project zero

00:06:19,730 --> 00:06:24,590
team in some work they were doing for

00:06:22,160 --> 00:06:28,580
the Chrome browser chrome actually uses

00:06:24,590 --> 00:06:29,810
Java objects to do do all the limits

00:06:28,580 --> 00:06:33,320
that are applied to Chrome on Windows

00:06:29,810 --> 00:06:35,540
right and so this con host exploit

00:06:33,320 --> 00:06:37,790
allows you to start processes outside of

00:06:35,540 --> 00:06:39,860
the job object that you started in and

00:06:37,790 --> 00:06:42,260
so when we're using Java objects to fly

00:06:39,860 --> 00:06:43,820
memory and other limits to your

00:06:42,260 --> 00:06:46,220
container if you can just start a

00:06:43,820 --> 00:06:48,860
process outside of that that kind of

00:06:46,220 --> 00:06:51,230
defeats the whole purpose now what you

00:06:48,860 --> 00:06:52,880
can do is monitor the process tree and

00:06:51,230 --> 00:06:55,280
look for processes that start up outside

00:06:52,880 --> 00:06:56,840
of a job and then put them back in the

00:06:55,280 --> 00:06:58,460
job that's exactly what we do we have a

00:06:56,840 --> 00:07:00,500
process called the guard but that's

00:06:58,460 --> 00:07:03,169
reactive right and so when you're

00:07:00,500 --> 00:07:04,780
building a system that's meant to scale

00:07:03,169 --> 00:07:07,340
you don't really want to have a bunch of

00:07:04,780 --> 00:07:13,070
reactive processes putting things back

00:07:07,340 --> 00:07:14,930
in Java objects so how do we improve the

00:07:13,070 --> 00:07:16,490
experience we want to improve the

00:07:14,930 --> 00:07:19,520
experience for app developers give them

00:07:16,490 --> 00:07:20,750
more isolation run it also a major point

00:07:19,520 --> 00:07:22,690
here is we want to improve the

00:07:20,750 --> 00:07:25,970
experience for a CF component T's

00:07:22,690 --> 00:07:27,530
Windows 2012 the implementation is built

00:07:25,970 --> 00:07:30,740
on top of iron frame which is a dotnet

00:07:27,530 --> 00:07:32,740
library requires Visual Studio Imus

00:07:30,740 --> 00:07:35,270
build lots of workstations set up and

00:07:32,740 --> 00:07:36,890
onboarding becomes hard for new members

00:07:35,270 --> 00:07:39,229
for the garden windows and other teams

00:07:36,890 --> 00:07:41,030
that want to interact with the garden

00:07:39,229 --> 00:07:43,190
windows implementation so we want to

00:07:41,030 --> 00:07:45,080
improve that experience as we go forward

00:07:43,190 --> 00:07:46,790
as well I think we went like three

00:07:45,080 --> 00:07:48,530
months without a workstation that even

00:07:46,790 --> 00:07:50,750
had Visual Studio installed on it and

00:07:48,530 --> 00:07:56,660
when we had to do a thing to iron frame

00:07:50,750 --> 00:07:58,550
it's like really painful and so how how

00:07:56,660 --> 00:08:00,169
do we improve the experience so we want

00:07:58,550 --> 00:08:02,420
to leverage the Windows Server 2016

00:08:00,169 --> 00:08:04,670
stack microscope

00:08:02,420 --> 00:08:07,220
working with when odd to implement

00:08:04,670 --> 00:08:08,900
Windows Server containers containers are

00:08:07,220 --> 00:08:12,200
now a native concept to windows in

00:08:08,900 --> 00:08:13,700
Windows 10 and Windows Server 2016 in

00:08:12,200 --> 00:08:16,250
concept there are similar to Linux

00:08:13,700 --> 00:08:18,260
containers there's a version with the

00:08:16,250 --> 00:08:21,280
shade kernel which is what we use and

00:08:18,260 --> 00:08:24,460
there's also the quote hyper-v

00:08:21,280 --> 00:08:26,360
containers that are used suitable for

00:08:24,460 --> 00:08:28,880
multi-tenant workloads according to

00:08:26,360 --> 00:08:31,970
Microsoft and we want to bring these to

00:08:28,880 --> 00:08:33,740
Cloud Foundry in addition we want to

00:08:31,970 --> 00:08:35,479
adopt existing Cloud Foundry development

00:08:33,740 --> 00:08:37,700
patterns I want to have all our

00:08:35,479 --> 00:08:40,790
components in golang want to integrate

00:08:37,700 --> 00:08:42,680
with the garden team more deeply and use

00:08:40,790 --> 00:08:44,510
garden Runcie release and Guardian so

00:08:42,680 --> 00:08:46,880
there's no longer a separate garden

00:08:44,510 --> 00:08:48,470
windows bas-reliefs and we want to try

00:08:46,880 --> 00:08:50,480
to adopt industry standards with

00:08:48,470 --> 00:08:53,540
containers try to take advantage of the

00:08:50,480 --> 00:08:55,910
open container initiative the runtimes

00:08:53,540 --> 00:08:58,160
back the image spec and emulate the

00:08:55,910 --> 00:09:00,950
linux version of the runtime plugin

00:08:58,160 --> 00:09:07,910
which is called run C and we implemented

00:09:00,950 --> 00:09:10,100
our own called win C so what were our

00:09:07,910 --> 00:09:12,620
design goals when building the 2016

00:09:10,100 --> 00:09:15,620
stack so we focused initially on Windows

00:09:12,620 --> 00:09:17,390
Server 2012 parody and so we weren't

00:09:15,620 --> 00:09:18,650
trying to bring new features to the

00:09:17,390 --> 00:09:20,810
platform we just wanted to deliver

00:09:18,650 --> 00:09:22,730
everything that we had before so

00:09:20,810 --> 00:09:23,900
initially we're only supporting the bill

00:09:22,730 --> 00:09:27,920
pack app lifecycle

00:09:23,900 --> 00:09:30,200
there's no docker app lifecycle yet we

00:09:27,920 --> 00:09:32,630
support application security groups just

00:09:30,200 --> 00:09:34,790
like we do in 2012 these are currently

00:09:32,630 --> 00:09:38,630
implemented via Windows Firewall rules

00:09:34,790 --> 00:09:41,150
but more on that later we have resource

00:09:38,630 --> 00:09:44,810
limits just like you had in 2012 for

00:09:41,150 --> 00:09:46,190
memory and this and we're really

00:09:44,810 --> 00:09:49,250
targeting that same class of

00:09:46,190 --> 00:09:51,620
applications to be deployed so we're not

00:09:49,250 --> 00:09:54,170
initially supporting the Nano server

00:09:51,620 --> 00:09:56,300
image Microsoft has to route file

00:09:54,170 --> 00:09:58,550
systems for 2016 there's a nano server

00:09:56,300 --> 00:10:01,640
and there's Windows server core nano

00:09:58,550 --> 00:10:03,050
server is great but it's more like maybe

00:10:01,640 --> 00:10:05,420
alpine linux right you can have this

00:10:03,050 --> 00:10:09,650
tiny base image now tiny to Microsoft is

00:10:05,420 --> 00:10:12,650
200 megabytes so tiny a tiny base image

00:10:09,650 --> 00:10:14,680
versus Windows server core which is a

00:10:12,650 --> 00:10:17,630
much larger image

00:10:14,680 --> 00:10:19,940
but we didn't want to require app

00:10:17,630 --> 00:10:22,910
developers to rewrite their apps take

00:10:19,940 --> 00:10:24,320
advantage of this new stat and so most

00:10:22,910 --> 00:10:28,430
applications that are currently

00:10:24,320 --> 00:10:31,310
targeting the windows net desktop CLR

00:10:28,430 --> 00:10:33,170
runtime you need things that are in that

00:10:31,310 --> 00:10:34,610
server core image and so our initial

00:10:33,170 --> 00:10:37,580
support will just be that server core

00:10:34,610 --> 00:10:42,200
and maybe we'll have a nano server some

00:10:37,580 --> 00:10:45,080
other day we wanted an improved

00:10:42,200 --> 00:10:46,880
experience for dotnet developers so that

00:10:45,080 --> 00:10:48,860
that isolation right the isolation

00:10:46,880 --> 00:10:52,550
primitives in 2012 are really primitive

00:10:48,860 --> 00:10:54,920
and so we wanted better isolation we

00:10:52,550 --> 00:10:57,920
also wanted to bring CF SSH

00:10:54,920 --> 00:11:00,920
to the windows the windows stat right

00:10:57,920 --> 00:11:02,390
now it's really difficult to debug

00:11:00,920 --> 00:11:05,270
Windows applications when they're

00:11:02,390 --> 00:11:08,150
running on the 2012 step and we know

00:11:05,270 --> 00:11:09,980
from our experience with Java and Linux

00:11:08,150 --> 00:11:12,770
that developers really like being all

00:11:09,980 --> 00:11:14,150
the SSH into their container and do

00:11:12,770 --> 00:11:15,710
whatever they need to in there to figure

00:11:14,150 --> 00:11:17,800
out what's going on with their apps so

00:11:15,710 --> 00:11:21,380
we wanted to bring that to the platform

00:11:17,800 --> 00:11:23,780
we also wanted to enable more of the

00:11:21,380 --> 00:11:25,490
existing platform features like

00:11:23,780 --> 00:11:28,420
container networking and Diego

00:11:25,490 --> 00:11:31,400
persistence with 2012 it's been

00:11:28,420 --> 00:11:33,050
basically impossible to support either

00:11:31,400 --> 00:11:35,270
of these because we didn't have isolated

00:11:33,050 --> 00:11:40,850
container networks and we didn't have

00:11:35,270 --> 00:11:42,589
isolated discs right and so with 2016 we

00:11:40,850 --> 00:11:44,650
can bring these features to the platform

00:11:42,589 --> 00:11:48,320
we also wanted to set ourselves up for

00:11:44,650 --> 00:11:50,330
future platform opportunities things

00:11:48,320 --> 00:11:51,920
like sidecar containers which you might

00:11:50,330 --> 00:11:53,000
have might have heard about some of the

00:11:51,920 --> 00:11:58,970
initiatives that are being talked about

00:11:53,000 --> 00:12:01,880
this week and oh see I don't packs so

00:11:58,970 --> 00:12:04,550
what is the 2016 server implementation

00:12:01,880 --> 00:12:07,720
give us we have complete filesystem

00:12:04,550 --> 00:12:11,870
isolation so each container runs in a

00:12:07,720 --> 00:12:15,470
virtual disk volume that is booted as a

00:12:11,870 --> 00:12:18,589
sandbox from the container image the

00:12:15,470 --> 00:12:20,270
root of the containers file system is

00:12:18,589 --> 00:12:22,370
the root of this volume it does not get

00:12:20,270 --> 00:12:23,990
to see anything outside of the container

00:12:22,370 --> 00:12:28,009
volume unless it's by and mounted in and

00:12:23,990 --> 00:12:30,949
by amounts are read-only by default

00:12:28,009 --> 00:12:33,410
and with this we are we have a container

00:12:30,949 --> 00:12:36,079
root of s unlike on windows 20 2012

00:12:33,410 --> 00:12:38,509
where we were just on the host as

00:12:36,079 --> 00:12:40,879
follows the Linux patterns for security

00:12:38,509 --> 00:12:42,879
updates and deployments we have a root

00:12:40,879 --> 00:12:45,619
of s that's packaged in a Bosch release

00:12:42,879 --> 00:12:47,629
if there's a security vulnerability and

00:12:45,619 --> 00:12:49,970
net or some other component of the root

00:12:47,629 --> 00:12:53,899
of s we can roll a new build a new Bosch

00:12:49,970 --> 00:12:55,879
release ship it and you can redeploy and

00:12:53,899 --> 00:12:59,059
have your patch and as long as it takes

00:12:55,879 --> 00:13:01,609
you to Bosch deploy yourself

00:12:59,059 --> 00:13:03,470
it seems sniffle simplifies the bar stem

00:13:01,609 --> 00:13:05,569
cell as well so no longer do we have to

00:13:03,470 --> 00:13:07,549
have the application dependencies like

00:13:05,569 --> 00:13:10,069
put on that framework installed in the

00:13:07,549 --> 00:13:13,519
host stem cell we can now have them in

00:13:10,069 --> 00:13:18,049
the container root of s and there's more

00:13:13,519 --> 00:13:20,329
about this on the next slide so here we

00:13:18,049 --> 00:13:23,149
have a lovely diagram from our PM

00:13:20,329 --> 00:13:25,910
William Martin you can see the bottom

00:13:23,149 --> 00:13:27,410
layer of this root of s is the Windows

00:13:25,910 --> 00:13:31,489
Server container image that Microsoft

00:13:27,410 --> 00:13:34,519
provides the we install some net

00:13:31,489 --> 00:13:38,480
features some windows specific stuff

00:13:34,519 --> 00:13:41,299
dotnet modules the URL rewriting for

00:13:38,480 --> 00:13:43,489
example some utilities and you can see

00:13:41,299 --> 00:13:46,129
in the orange there the an example of

00:13:43,489 --> 00:13:48,649
where your the application droplet will

00:13:46,129 --> 00:13:50,540
live with the bill pack application all

00:13:48,649 --> 00:13:52,879
compiling together to become your

00:13:50,540 --> 00:13:55,549
droplet yeah so one of the things that

00:13:52,879 --> 00:13:57,889
we kind of heard from a lot of users of

00:13:55,549 --> 00:14:00,769
the 2012 stack was like where do I put

00:13:57,889 --> 00:14:03,169
my db2 module right and like this was

00:14:00,769 --> 00:14:04,759
never a fun thing to say well you built

00:14:03,169 --> 00:14:05,959
a special stem cell and you put it in

00:14:04,759 --> 00:14:07,399
there and they need to play that right

00:14:05,959 --> 00:14:11,480
it's not a great experience especially

00:14:07,399 --> 00:14:13,129
compared to to Linux so now we can say

00:14:11,480 --> 00:14:17,199
hey well you put it in your root in this

00:14:13,129 --> 00:14:17,199
right or you put it in your build pack

00:14:17,319 --> 00:14:21,679
so some more improvements we have with

00:14:19,699 --> 00:14:24,529
the Windows 2016 stack we have now have

00:14:21,679 --> 00:14:27,289
CPU limits and Microsoft has implement

00:14:24,529 --> 00:14:31,399
in plan look implemented them directly

00:14:27,289 --> 00:14:33,949
in the host computer service with shares

00:14:31,399 --> 00:14:35,839
so you're able to do the sort of CPU

00:14:33,949 --> 00:14:37,520
limiting you would require for

00:14:35,839 --> 00:14:42,140
applications to start up and for

00:14:37,520 --> 00:14:45,200
application CPU sharing to continue as

00:14:42,140 --> 00:14:47,840
on Linux users are unique to each

00:14:45,200 --> 00:14:50,300
container so before containers were

00:14:47,840 --> 00:14:52,790
implemented with a user on the host and

00:14:50,300 --> 00:14:54,680
Windows 2012 now container users are

00:14:52,790 --> 00:14:57,350
unique to each application container and

00:14:54,680 --> 00:14:58,910
now you also have registry isolation

00:14:57,350 --> 00:15:00,520
which is very important for these legacy

00:14:58,910 --> 00:15:05,180
apps that people will be pushing to the

00:15:00,520 --> 00:15:07,670
platform each container has a copy of

00:15:05,180 --> 00:15:09,800
its own copy of a registry and each

00:15:07,670 --> 00:15:12,350
layer of a container file system

00:15:09,800 --> 00:15:15,920
actually has a diff between the itself

00:15:12,350 --> 00:15:17,600
and the previous layer registry we also

00:15:15,920 --> 00:15:20,060
have network compartments which are

00:15:17,600 --> 00:15:21,860
pretty much akin to Linux namespaces the

00:15:20,060 --> 00:15:25,160
process is no longer listed on the hosts

00:15:21,860 --> 00:15:27,640
IP they have their own loopback

00:15:25,160 --> 00:15:29,750
interface for the container and

00:15:27,640 --> 00:15:31,850
container processes cannot communicate

00:15:29,750 --> 00:15:34,160
with the host unless we explicitly allow

00:15:31,850 --> 00:15:39,380
them over the network with a firewall

00:15:34,160 --> 00:15:40,820
rule cool so we have a couple

00:15:39,380 --> 00:15:43,880
architecture diagrams to talk through

00:15:40,820 --> 00:15:47,360
they were drawn by our pm and literal

00:15:43,880 --> 00:15:49,310
architect William Martin so here's a

00:15:47,360 --> 00:15:51,260
high-level diagram of what actually runs

00:15:49,310 --> 00:15:53,900
on a Windows cell right so ultimately

00:15:51,260 --> 00:15:57,080
everything that's on a cell is deployed

00:15:53,900 --> 00:16:00,560
via bosh and that gets there via the

00:15:57,080 --> 00:16:02,390
wash agent we have these components on

00:16:00,560 --> 00:16:04,550
the left of the diagram the wrap the

00:16:02,390 --> 00:16:06,440
Metron agent console client and the

00:16:04,550 --> 00:16:09,950
route emitter all these components are

00:16:06,440 --> 00:16:12,380
written in go we are currently using all

00:16:09,950 --> 00:16:15,110
of those components in the 2012 stack as

00:16:12,380 --> 00:16:17,060
well as the 2016 step so for the most

00:16:15,110 --> 00:16:19,820
part all the components that make up the

00:16:17,060 --> 00:16:21,920
2016 stack are tried-and-true we already

00:16:19,820 --> 00:16:24,320
know these things work well on Windows

00:16:21,920 --> 00:16:26,600
we have a deployment mechanism for them

00:16:24,320 --> 00:16:28,850
and we've seen them working in

00:16:26,600 --> 00:16:31,640
production very well over the last two

00:16:28,850 --> 00:16:35,990
to two-and-a-half years on the right is

00:16:31,640 --> 00:16:38,900
the new bit of Windows 2016 stack which

00:16:35,990 --> 00:16:43,220
is Guardian or comes from the garden run

00:16:38,900 --> 00:16:44,960
see release and Guardian is the

00:16:43,220 --> 00:16:47,450
the vid of the platform that actually

00:16:44,960 --> 00:16:49,700
runs the windows containers so you can

00:16:47,450 --> 00:16:52,040
see it consists of a garden server a

00:16:49,700 --> 00:16:53,930
container plugin and ever clog it andrew

00:16:52,040 --> 00:16:58,070
defense plugin they'll dive in a little

00:16:53,930 --> 00:16:59,900
bit to what those mean you have the the

00:16:58,070 --> 00:17:03,680
gardener's server which is implementing

00:16:59,900 --> 00:17:05,750
the garden api the diego component talks

00:17:03,680 --> 00:17:07,850
to the garden api and says hey i needed

00:17:05,750 --> 00:17:09,650
to run these containers right so that's

00:17:07,850 --> 00:17:12,520
our standard api that's exactly what

00:17:09,650 --> 00:17:16,160
we're using in 2012 and in 2016

00:17:12,520 --> 00:17:18,230
instead of writing yet another garden

00:17:16,160 --> 00:17:20,360
release let's see we had garden Linux

00:17:18,230 --> 00:17:22,250
release garden run sea release garden

00:17:20,360 --> 00:17:25,040
windows release we didn't want garden

00:17:22,250 --> 00:17:26,630
windows 2016 release so we went back to

00:17:25,040 --> 00:17:28,130
the garden team and we said hey is there

00:17:26,630 --> 00:17:30,440
a better abstraction we can build here

00:17:28,130 --> 00:17:32,900
and then we found a place to push that

00:17:30,440 --> 00:17:35,350
down to lower level and Sunday I

00:17:32,900 --> 00:17:39,320
mentioned this around OCI in adopting

00:17:35,350 --> 00:17:41,300
standards and so with the garden run C

00:17:39,320 --> 00:17:44,720
release we have this server the gardener

00:17:41,300 --> 00:17:46,880
that implements the garden API and that

00:17:44,720 --> 00:17:48,860
server has three sub components the

00:17:46,880 --> 00:17:51,290
container Iser the external network ur

00:17:48,860 --> 00:17:53,330
in the image plug in the container Iser

00:17:51,290 --> 00:17:55,700
is where we saw an opportunity to

00:17:53,330 --> 00:17:58,730
leverage a lower level abstraction to

00:17:55,700 --> 00:18:00,290
implement Windows Server containers so

00:17:58,730 --> 00:18:03,140
it saw an opportunity to implement the

00:18:00,290 --> 00:18:05,810
OCI specification on Windows this is the

00:18:03,140 --> 00:18:07,550
open container initiative it's standard

00:18:05,810 --> 00:18:10,220
that defines how containers should be

00:18:07,550 --> 00:18:13,940
created maintain their lifecycle

00:18:10,220 --> 00:18:16,070
destruction etc so we wrote a CLI

00:18:13,940 --> 00:18:19,280
implementing the OCI spec for Windows

00:18:16,070 --> 00:18:23,030
called win C win C talks directly to

00:18:19,280 --> 00:18:25,700
Windows host compute service and this

00:18:23,030 --> 00:18:27,590
allows spinning up spinning down of

00:18:25,700 --> 00:18:31,430
containers putting stuff in containers

00:18:27,590 --> 00:18:34,100
that whole lifecycle for networking we

00:18:31,430 --> 00:18:36,140
wrote a networking plug-in link network

00:18:34,100 --> 00:18:38,210
which talks to the host network service

00:18:36,140 --> 00:18:42,020
this sits alongside and windows land the

00:18:38,210 --> 00:18:44,030
host computer and for images this is

00:18:42,020 --> 00:18:47,120
that route FS right now we just have a

00:18:44,030 --> 00:18:49,130
dummy link image plug-in which gives you

00:18:47,120 --> 00:18:51,850
access to a root filesystem that's

00:18:49,130 --> 00:18:51,850
installed on the host

00:18:52,380 --> 00:19:01,230
all right now time for a demo so for

00:18:59,640 --> 00:19:03,270
example so here we can see this is our

00:19:01,230 --> 00:19:05,940
ops file we have deployed a cloud

00:19:03,270 --> 00:19:08,309
foundry and some windows cells Windows

00:19:05,940 --> 00:19:10,470
2016 sales or using this ops file this

00:19:08,309 --> 00:19:12,270
is in master of CF deployment on the

00:19:10,470 --> 00:19:16,910
latest releases so you can take a look

00:19:12,270 --> 00:19:24,710
at this and use it if you want to and

00:19:16,910 --> 00:19:28,140
here so if we look at our stacks see our

00:19:24,710 --> 00:19:33,539
Windows 2016 stack right there and we've

00:19:28,140 --> 00:19:36,900
pre pushed couple applications we have a

00:19:33,539 --> 00:19:39,539
2012 app nor of 2012 Norah's are

00:19:36,900 --> 00:19:43,770
equivalent to the linux test app Dora

00:19:39,539 --> 00:19:54,860
for Windows we have a Dora and a Windows

00:19:43,770 --> 00:19:54,860
2016 at you're missing had be Oh Hernan

00:20:01,850 --> 00:20:06,950
all right we can see it's running on the

00:20:04,010 --> 00:20:10,820
windows 2016 stack with the HWC bill

00:20:06,950 --> 00:20:14,950
pack and let's do the most interesting

00:20:10,820 --> 00:20:14,950
thing and ssh to this app

00:20:21,110 --> 00:20:27,880
so this is before it yeah this should

00:20:24,110 --> 00:20:31,310
put you in a command shell session up in

00:20:27,880 --> 00:20:34,880
GCP this is actually running on a server

00:20:31,310 --> 00:20:38,300
ng CP and so what do we want to do here

00:20:34,880 --> 00:20:50,450
we can look around our directory oh look

00:20:38,300 --> 00:20:53,180
there's our application directory users

00:20:50,450 --> 00:20:55,690
we capture no subfolders exist let's go

00:20:53,180 --> 00:20:55,690
to parish Oh

00:20:59,929 --> 00:21:09,230
takes a little while but it takes a

00:21:03,500 --> 00:21:13,130
little while on Windows normally oh so

00:21:09,230 --> 00:21:16,909
there's our application files and let's

00:21:13,130 --> 00:21:20,360
try to install a Windows feature let's

00:21:16,909 --> 00:21:21,799
see if we can run containers in

00:21:20,360 --> 00:21:28,520
containers this alone

00:21:21,799 --> 00:21:29,570
hopefully autocomplete for us a nice

00:21:28,520 --> 00:21:33,289
little progress bar

00:21:29,570 --> 00:21:35,659
oh we're not admin so we cannot install

00:21:33,289 --> 00:21:39,500
windows features here which is pretty

00:21:35,659 --> 00:21:41,710
good let's see let's try to open a

00:21:39,500 --> 00:21:41,710
notepad

00:21:49,370 --> 00:21:54,320
No doesn't open Notepad we can't see

00:21:51,470 --> 00:21:56,660
that but if you look at the process list

00:21:54,320 --> 00:21:58,280
you can see a notepad up there which

00:21:56,660 --> 00:22:01,490
it's running somewhere we can't see it

00:21:58,280 --> 00:22:05,559
but it's running we can see our

00:22:01,490 --> 00:22:07,850
PowerShell sessions and so if you notice

00:22:05,559 --> 00:22:13,670
let's see if we can scroll a little bit

00:22:07,850 --> 00:22:16,309
how do we scroll here so we can't see

00:22:13,670 --> 00:22:18,530
any of the the Bosch service processes

00:22:16,309 --> 00:22:19,850
which is good we're pretty showing that

00:22:18,530 --> 00:22:24,730
we're just running inside of a container

00:22:19,850 --> 00:22:29,500
we can't see the system host processes

00:22:24,730 --> 00:22:29,500
what else we can see our

00:22:39,620 --> 00:22:48,830
no subfolders exist let's got a look at

00:22:41,900 --> 00:22:51,640
the files can see our well I think you

00:22:48,830 --> 00:22:59,390
did not the dot slash not the dot slash

00:22:51,640 --> 00:23:00,980
PowerShell no well I don't know well you

00:22:59,390 --> 00:23:05,030
can look around your you can look around

00:23:00,980 --> 00:23:07,160
your container file system you can get

00:23:05,030 --> 00:23:08,840
instance identity credentials you can

00:23:07,160 --> 00:23:11,210
look at all the processes inside of your

00:23:08,840 --> 00:23:14,770
container and we're not admin which is

00:23:11,210 --> 00:23:14,770
pretty good cool

00:23:24,100 --> 00:23:28,419
awesome so I want to talk a little bit

00:23:26,620 --> 00:23:29,890
about the Windows Server semiannual

00:23:28,419 --> 00:23:32,470
release Channel

00:23:29,890 --> 00:23:35,710
there the Microsoft team is actually

00:23:32,470 --> 00:23:38,590
moving to instead of these gigantic

00:23:35,710 --> 00:23:40,660
monolithic releases like once every four

00:23:38,590 --> 00:23:42,580
years they're moving towards this

00:23:40,660 --> 00:23:45,000
semi-annual or these channel every six

00:23:42,580 --> 00:23:48,010
months so you've seen this in Windows 10

00:23:45,000 --> 00:23:49,750
with the anniversary update and the

00:23:48,010 --> 00:23:51,460
creators update so they're targeting

00:23:49,750 --> 00:23:54,760
basically every six months to do these

00:23:51,460 --> 00:23:57,490
major releases 1709 you might think oh

00:23:54,760 --> 00:23:59,860
that's 2017 September it's October

00:23:57,490 --> 00:24:02,080
where's that release any day now promise

00:23:59,860 --> 00:24:03,760
we've been actively working with the

00:24:02,080 --> 00:24:06,390
windows server containers team to

00:24:03,760 --> 00:24:08,710
deliver new functionality in Windows

00:24:06,390 --> 00:24:11,350
we've seen major networking and

00:24:08,710 --> 00:24:13,480
performance enhancements in Windows

00:24:11,350 --> 00:24:16,299
Server containers in this semi-annual

00:24:13,480 --> 00:24:18,880
release channel there's improved process

00:24:16,299 --> 00:24:21,909
isolation that con hosts breakout that

00:24:18,880 --> 00:24:25,240
we mentioned is is mostly mitigated now

00:24:21,909 --> 00:24:28,059
it's still sort of possible but you

00:24:25,240 --> 00:24:31,090
can't really contain it there's also

00:24:28,059 --> 00:24:34,840
approved CPU sharing we see a smaller

00:24:31,090 --> 00:24:36,580
route FS just two point two gigabytes to

00:24:34,840 --> 00:24:39,820
give you an idea that's currently five

00:24:36,580 --> 00:24:42,820
gigabytes and sidecar containers so you

00:24:39,820 --> 00:24:44,260
can have two containers that are stood

00:24:42,820 --> 00:24:45,940
up next to each other that have the same

00:24:44,260 --> 00:24:48,010
network and can can communicate with

00:24:45,940 --> 00:24:52,690
each other but are still separate

00:24:48,010 --> 00:24:54,250
containers so some areas that still need

00:24:52,690 --> 00:24:57,580
improvement in our Windows 2016

00:24:54,250 --> 00:24:59,530
implementation memory limits as in 2012

00:24:57,580 --> 00:25:01,470
still do not constrain memory map files

00:24:59,530 --> 00:25:04,480
so you could potentially take up a host

00:25:01,470 --> 00:25:07,419
whole memory with a large memory map

00:25:04,480 --> 00:25:10,000
file this is something we're working on

00:25:07,419 --> 00:25:12,340
with Microsoft but there are no process

00:25:10,000 --> 00:25:14,500
limits so you can run as many processes

00:25:12,340 --> 00:25:15,700
as you want in the container that's on

00:25:14,500 --> 00:25:19,299
the roadmap for the Windows Server

00:25:15,700 --> 00:25:23,350
containers team and containers are semi

00:25:19,299 --> 00:25:25,900
privileged so if you elevate from the

00:25:23,350 --> 00:25:27,909
default vcap user that is a non admin

00:25:25,900 --> 00:25:29,980
user inside of your container if you

00:25:27,909 --> 00:25:32,080
elevate to administrator you can get

00:25:29,980 --> 00:25:35,900
around disk limits which are implemented

00:25:32,080 --> 00:25:37,850
currently as a quota on your disk volume

00:25:35,900 --> 00:25:40,130
and you can also get around the network

00:25:37,850 --> 00:25:42,230
access restrictions this networking

00:25:40,130 --> 00:25:45,530
stuff will be fixed in the part of the

00:25:42,230 --> 00:25:48,950
1709 release as the networking team has

00:25:45,530 --> 00:25:51,080
done a lot of work and now have network

00:25:48,950 --> 00:25:58,040
access control lists for network

00:25:51,080 --> 00:26:00,160
endpoints future roadmap items we're

00:25:58,040 --> 00:26:04,130
working with the Garuda fest team for

00:26:00,160 --> 00:26:07,460
OCI or docker image push support we're

00:26:04,130 --> 00:26:10,550
also thinking about a true upstream

00:26:07,460 --> 00:26:12,170
support in Concours for Windows workers

00:26:10,550 --> 00:26:14,090
right now there's a separate Vash

00:26:12,170 --> 00:26:16,910
release that stands up houdini based

00:26:14,090 --> 00:26:19,550
worker but we want to have real windows

00:26:16,910 --> 00:26:21,280
server container workers and we're also

00:26:19,550 --> 00:26:24,890
thinking about nano server image support

00:26:21,280 --> 00:26:26,300
but first we need multi route FS so see

00:26:24,890 --> 00:26:30,650
the point about working with career

00:26:26,300 --> 00:26:32,330
defense in terms of isolation that

00:26:30,650 --> 00:26:34,640
Sanjay mentioned earlier right now we

00:26:32,330 --> 00:26:36,470
just have shared kernel isolation

00:26:34,640 --> 00:26:40,160
implemented and this is similar in

00:26:36,470 --> 00:26:41,810
principle the 2012 r2 and Linux in the

00:26:40,160 --> 00:26:44,720
future we might think about adding

00:26:41,810 --> 00:26:47,990
hyper-v isolation it's not implemented

00:26:44,720 --> 00:26:50,510
today microsoft says hyper-v isolation

00:26:47,990 --> 00:26:52,070
is intended for hostile multi-tenant

00:26:50,510 --> 00:26:54,050
workloads what they're actually using

00:26:52,070 --> 00:26:58,160
this for is the azure container service

00:26:54,050 --> 00:27:00,530
and isolating processes however hyper-v

00:26:58,160 --> 00:27:02,240
isolation requires nested virtualization

00:27:00,530 --> 00:27:04,580
support which is not supported by all I

00:27:02,240 --> 00:27:06,500
Aza's although I think was GCP that just

00:27:04,580 --> 00:27:08,960
announced last week they have this

00:27:06,500 --> 00:27:12,140
option now for Windows you not for

00:27:08,960 --> 00:27:14,930
Windows ok but they're these containers

00:27:12,140 --> 00:27:17,750
are very heavyweight so standing up one

00:27:14,930 --> 00:27:20,360
container took 3 gigabytes of memory and

00:27:17,750 --> 00:27:21,500
so in talking with our operators and

00:27:20,360 --> 00:27:24,500
seeing what they're used to from the

00:27:21,500 --> 00:27:27,890
linux experience in 2012 r2 hyper-v

00:27:24,500 --> 00:27:29,750
isolation is kind of crazy but as I

00:27:27,890 --> 00:27:31,940
mentioned Microsoft is working on making

00:27:29,750 --> 00:27:34,610
these things better and so I expect this

00:27:31,940 --> 00:27:36,110
will improve over time we actually have

00:27:34,610 --> 00:27:38,900
seen improvements in the semi-annual

00:27:36,110 --> 00:27:42,920
release already it's down to two

00:27:38,900 --> 00:27:45,110
gigabytes so call to action what can you

00:27:42,920 --> 00:27:47,600
guys do we're hiring at

00:27:45,110 --> 00:27:49,070
pivotal and confound you so give us a

00:27:47,600 --> 00:27:51,530
call if you want to work on Windows work

00:27:49,070 --> 00:27:55,820
on Windows containers we love pull

00:27:51,530 --> 00:27:57,320
requests all of our Wincy Guardian code

00:27:55,820 --> 00:28:00,050
of course is open-source

00:27:57,320 --> 00:28:03,050
if you take a look see some bugs give us

00:28:00,050 --> 00:28:05,420
a call and definitely start using win

00:28:03,050 --> 00:28:08,720
sea Guardian garden rinse release on

00:28:05,420 --> 00:28:11,090
Windows and take a look at our CF

00:28:08,720 --> 00:28:13,340
deployment ops file give it a whirl see

00:28:11,090 --> 00:28:19,160
see if it works for you more pull

00:28:13,340 --> 00:28:31,130
requests there open as well cool any

00:28:19,160 --> 00:28:34,970
questions thanks would like to ask how

00:28:31,130 --> 00:28:37,880
the licensing topic is covered what if I

00:28:34,970 --> 00:28:40,760
have want to have a window stem-cell do

00:28:37,880 --> 00:28:42,860
I have to bring my own license in now ya

00:28:40,760 --> 00:28:45,230
be great great question

00:28:42,860 --> 00:28:47,330
so licensing is is one of the tough

00:28:45,230 --> 00:28:50,930
points here of course with Windows

00:28:47,330 --> 00:28:54,470
Server and so for you know the boss

00:28:50,930 --> 00:28:55,940
deployment right of Cloud Foundry you

00:28:54,470 --> 00:28:57,440
need to figure out your own licensing

00:28:55,940 --> 00:29:00,800
you need to bring that along now if

00:28:57,440 --> 00:29:03,800
you're using something like as your GCP

00:29:00,800 --> 00:29:05,660
or AWS that licensing is included in the

00:29:03,800 --> 00:29:11,420
cost of the VM if you stand up a Windows

00:29:05,660 --> 00:29:12,650
VM now for your own I as like vSphere or

00:29:11,420 --> 00:29:16,610
OpenStack you've got to figure that out

00:29:12,650 --> 00:29:18,170
on your own now for the containers it's

00:29:16,610 --> 00:29:20,480
my understanding that you can you can

00:29:18,170 --> 00:29:22,130
create as many of these Windows Server

00:29:20,480 --> 00:29:22,850
containers the lightweight containers as

00:29:22,130 --> 00:29:24,290
you'd like

00:29:22,850 --> 00:29:26,240
great so if you have a Windows Server

00:29:24,290 --> 00:29:29,450
license you just bring it up those

00:29:26,240 --> 00:29:34,400
aren't charged at that you know per CPU

00:29:29,450 --> 00:29:35,990
or fir first socket licensing basis

00:29:34,400 --> 00:29:38,090
right and so you just start up as many

00:29:35,990 --> 00:29:39,770
containers as you want on a server once

00:29:38,090 --> 00:29:42,290
you have it running which is basically

00:29:39,770 --> 00:29:45,620
the same concept in licensing that

00:29:42,290 --> 00:29:47,420
Microsoft has or if you have say ESX

00:29:45,620 --> 00:29:49,370
host and you're running Windows VMs on

00:29:47,420 --> 00:29:51,290
there you license the physical host and

00:29:49,370 --> 00:29:54,650
then you run all the VMS on there that

00:29:51,290 --> 00:29:56,510
you want and public is stem cells

00:29:54,650 --> 00:29:57,299
they're all available on bacio so you

00:29:56,510 --> 00:29:59,039
don't have to build them

00:29:57,299 --> 00:30:01,889
so you can just get the download link

00:29:59,039 --> 00:30:05,039
and those will be a valid stem cell that

00:30:01,889 --> 00:30:07,739
you can use and coming soon to CF

00:30:05,039 --> 00:30:09,869
deployment will be the opportunity to

00:30:07,739 --> 00:30:12,210
use an offline and an online Bosch

00:30:09,869 --> 00:30:14,249
release to get the rid of s so by

00:30:12,210 --> 00:30:15,989
default there will be a online release

00:30:14,249 --> 00:30:18,320
which will download the root of s from

00:30:15,989 --> 00:30:21,059
the internet for you and if you have

00:30:18,320 --> 00:30:23,220
constraints on having internet in your

00:30:21,059 --> 00:30:25,230
environment then you can use the offline

00:30:23,220 --> 00:30:27,149
ops file which requires a couple of

00:30:25,230 --> 00:30:30,059
manual steps to build the release for

00:30:27,149 --> 00:30:31,889
you we already have scripts and code in

00:30:30,059 --> 00:30:34,080
the release source for n instructions

00:30:31,889 --> 00:30:35,879
for you to build the Bosch release and

00:30:34,080 --> 00:30:37,440
you upload it yourself and then after

00:30:35,879 --> 00:30:41,970
that it's just a usable Bosch release

00:30:37,440 --> 00:30:44,009
and it deploys as normal go I think

00:30:41,970 --> 00:30:45,690
we're at lunchtime now so I don't want

00:30:44,009 --> 00:30:47,190
to keep you from that but go ahead and

00:30:45,690 --> 00:30:50,140
find us after this if you have any more

00:30:47,190 --> 00:30:50,920
questions we'll be around

00:30:50,140 --> 00:30:53,390
[Music]

00:30:50,920 --> 00:30:53,390

YouTube URL: https://www.youtube.com/watch?v=Q4k3lf1zVak


