Title: Managing the Complexity of Microservices Deployments - Prithpal Bhogill, Google & Kenny Bastini
Publication date: 2017-10-18
Playlist: Cloud Foundry Summit Europe 2017
Description: 
	Managing the Complexity of Microservices Deployments - Prithpal Bhogill, Google & Kenny Bastini, Pivotal

The transition to microservices can be an exciting change of pace for many developers. But for organizations, the path to success with microservices is not without embracing a major cultural shift in the process of how companies build and deliver software.

To rapidly deliver microservices to production, organizations are turning to infrastructure automation provided by a cloud-native platform, like Cloud Foundry. With a platform in place, every microservice team will have what they need to create a CI/CD pipeline that safely delivers applications to a production environment. The final ingredient for success is knowing the right patterns for connecting microservices together over HTTP using REST APIs.

In this session, Kenny Bastani from Pivotal and Prithpal Bhogill from Apigee will dive into a reference architecture that demonstrates the patterns and practices for securely connecting microservices together.

This session will cover:

- The basics for building cloud-native applications as microservices on Pivotal Cloud Foundry using Spring Boot and Spring Cloud Services
- The patterns and practices that are enabling small autonomous microservice teams to provision backing services for their applications
- How to securely expose microservices over HTTP using Apigee Edge for PCF
- How to ensure that APIs are readily and securely consumable by application developers
- How to get instant, end-to-end visibility into the performance and adoption of your API program
- How to thrive in the API economy by leveraging microservices and cloud-native application architectures

About Kenny Bastani
Kenny Bastani works at Pivotal as a Spring Developer Advocate. As an open source contributor and blogger, Kenny engages a community of passionate developers on topics ranging from graph databases to microservices. He is also a co-author of O’Reilly’s Cloud Native Java: Designing Resilient Systems with Spring Boot, Spring Cloud, and Cloud Foundry.

About Prithpal Bhogill
Prithpal is responsible for Edge API Management platform as a Product Manager in the Google Cloud Platform team. Prior to Google, Prithpal held various roles in Product Management, Pre-Sales, Architecture for companies including Apigee, Salesforce, Oracle and BEA. Prithpal earned a bachelor's degree in computer science from University of Pune and a graduate diploma in Business Systems from Monash University. Prithpal is a frequent speaker at tech forums, industry/tech conferences has presented various webcasts and contributes technology blogs.
Captions: 
	00:00:00,030 --> 00:00:04,830
hey everyone I'm Kenny Bustani it's a

00:00:03,060 --> 00:00:06,569
sprit ball bow Gil and we're gonna be

00:00:04,830 --> 00:00:09,179
talking today about managing the

00:00:06,569 --> 00:00:13,410
complexity of micro service deployments

00:00:09,179 --> 00:00:14,849
using Cloud Foundry and Apogee so I'll

00:00:13,410 --> 00:00:16,650
go ahead and introduce myself first

00:00:14,849 --> 00:00:19,830
again i'm kenny Bustani I'm a spring

00:00:16,650 --> 00:00:21,750
developer advocate at pivotal I also

00:00:19,830 --> 00:00:23,519
wrote a book called cloud native Java so

00:00:21,750 --> 00:00:26,099
I thought I'd plug that now I'll be

00:00:23,519 --> 00:00:29,279
signing these I guess reduced free

00:00:26,099 --> 00:00:30,720
chapter versions after this session so

00:00:29,279 --> 00:00:34,170
if you're interested come by the pivotal

00:00:30,720 --> 00:00:35,820
booth and yeah hey guys Bruce bot will

00:00:34,170 --> 00:00:37,770
get on part of the Apogee product team

00:00:35,820 --> 00:00:39,629
part of Google now so super excited to

00:00:37,770 --> 00:00:41,700
be here today we're gonna be talking

00:00:39,629 --> 00:00:43,620
about micro services and then we'll get

00:00:41,700 --> 00:00:45,510
into how API management plays into that

00:00:43,620 --> 00:00:47,100
space and hopefully it should be

00:00:45,510 --> 00:00:48,300
exciting session small things so we're

00:00:47,100 --> 00:00:50,700
looking forward to it

00:00:48,300 --> 00:00:53,520
awesome Kenny thanks so I'm gonna start

00:00:50,700 --> 00:00:55,710
out talking about the history of why

00:00:53,520 --> 00:00:57,989
really we're doing Micra services today

00:00:55,710 --> 00:01:00,090
and hopefully that leads into this

00:00:57,989 --> 00:01:02,640
discussion of why an API gateway is so

00:01:00,090 --> 00:01:04,530
important all right so here's the agenda

00:01:02,640 --> 00:01:06,330
we're gonna talk about monolith to micro

00:01:04,530 --> 00:01:08,189
services first and I think it's

00:01:06,330 --> 00:01:10,380
important to note that not all

00:01:08,189 --> 00:01:12,540
architectures that aren't micro services

00:01:10,380 --> 00:01:15,000
are monoliths right we also have things

00:01:12,540 --> 00:01:17,070
like SOA we have services architectures

00:01:15,000 --> 00:01:19,890
so not just monoliths and there are some

00:01:17,070 --> 00:01:21,659
companies who are trying to move from

00:01:19,890 --> 00:01:24,060
this services architecture that's not

00:01:21,659 --> 00:01:26,250
micro services to micro services so I'll

00:01:24,060 --> 00:01:28,590
be talking about that a little bit and

00:01:26,250 --> 00:01:31,439
then why API management Paul is gonna

00:01:28,590 --> 00:01:34,020
dive into the solution with Apogee API

00:01:31,439 --> 00:01:35,640
gateway and Cloud Foundry and then we'll

00:01:34,020 --> 00:01:37,500
wrap it up with some key takeaways we

00:01:35,640 --> 00:01:40,350
have 30 minutes and a lot of content so

00:01:37,500 --> 00:01:42,570
I'm gonna go a little bit fast all right

00:01:40,350 --> 00:01:44,579
so we started with this we started with

00:01:42,570 --> 00:01:47,880
the monolithic application right and

00:01:44,579 --> 00:01:49,049
you're all familiar with this today now

00:01:47,880 --> 00:01:50,790
if you're working with a model of today

00:01:49,049 --> 00:01:53,070
you'll notice a lot of the pains that

00:01:50,790 --> 00:01:55,470
come with this I mean it has to do with

00:01:53,070 --> 00:01:57,570
shared ownership right sharing ownership

00:01:55,470 --> 00:02:00,149
over infrastructure sharing ownership

00:01:57,570 --> 00:02:02,009
oprah's this source code and that really

00:02:00,149 --> 00:02:04,200
causes an issue it causes us to go slow

00:02:02,009 --> 00:02:06,270
so here in this example I have a patchy

00:02:04,200 --> 00:02:07,570
tomcat server in the center of that I

00:02:06,270 --> 00:02:09,220
have a ward of

00:02:07,570 --> 00:02:11,140
now inside that board appointment I have

00:02:09,220 --> 00:02:12,849
separate components the modules of the

00:02:11,140 --> 00:02:16,000
application and let's say this is a

00:02:12,849 --> 00:02:18,280
single source code codebase and maybe

00:02:16,000 --> 00:02:20,170
it's a million lines of code now the

00:02:18,280 --> 00:02:21,489
solution is very large in terms of code

00:02:20,170 --> 00:02:24,340
and so that's going to be very difficult

00:02:21,489 --> 00:02:26,080
for developers to work on together but

00:02:24,340 --> 00:02:27,700
more than that is that we're sharing a

00:02:26,080 --> 00:02:29,410
release schedule right so I call this

00:02:27,700 --> 00:02:31,480
taking public transportation to

00:02:29,410 --> 00:02:33,670
production but the bus comes four times

00:02:31,480 --> 00:02:37,209
a year and that's the primary issue with

00:02:33,670 --> 00:02:38,739
a monolithic application and so first of

00:02:37,209 --> 00:02:40,180
all it's going to slow our velocity and

00:02:38,739 --> 00:02:41,860
getting into production right so if we

00:02:40,180 --> 00:02:43,989
have to share that release schedule

00:02:41,860 --> 00:02:46,090
share that source code share that

00:02:43,989 --> 00:02:47,739
infrastructure it's really going to slow

00:02:46,090 --> 00:02:49,959
us down because we have to coordinate

00:02:47,739 --> 00:02:51,879
more if something goes wrong if let's

00:02:49,959 --> 00:02:53,950
say one developer changes a line of code

00:02:51,879 --> 00:02:56,049
and that brings the entire application

00:02:53,950 --> 00:02:59,170
down in production that's a big deal and

00:02:56,049 --> 00:03:01,540
it's gonna slow us down because of it it

00:02:59,170 --> 00:03:04,660
also takes way too long to ramp up new

00:03:01,540 --> 00:03:07,540
engineers right so with microcircuits

00:03:04,660 --> 00:03:09,790
ideal to be able to add an engineer to a

00:03:07,540 --> 00:03:12,160
project have them reason about that

00:03:09,790 --> 00:03:13,840
source code within a day and be able to

00:03:12,160 --> 00:03:16,269
work with it as opposed to a million

00:03:13,840 --> 00:03:17,769
lines of code where it's gonna take much

00:03:16,269 --> 00:03:20,799
longer for a developer to really

00:03:17,769 --> 00:03:22,450
understand what that code does before

00:03:20,799 --> 00:03:26,079
they feel safe to be able to make

00:03:22,450 --> 00:03:27,790
changes but I want to hit on this all

00:03:26,079 --> 00:03:29,709
teams share the same infrastructure

00:03:27,790 --> 00:03:31,329
right so we have one production

00:03:29,709 --> 00:03:34,239
environment where our monolithic

00:03:31,329 --> 00:03:36,910
application is being run by a single

00:03:34,239 --> 00:03:38,560
application server or multiple but the

00:03:36,910 --> 00:03:40,269
idea is we have one way to get to

00:03:38,560 --> 00:03:42,700
production so if I change one single

00:03:40,269 --> 00:03:44,940
line of code I have to deploy everything

00:03:42,700 --> 00:03:47,319
or nothing at all

00:03:44,940 --> 00:03:48,730
so that's the next point so this is the

00:03:47,319 --> 00:03:50,650
main issue with monoliths right you

00:03:48,730 --> 00:03:55,690
deploy everything at once or nothing at

00:03:50,650 --> 00:03:58,419
all and that's the primary issue and so

00:03:55,690 --> 00:04:00,579
on the way to micro services we move to

00:03:58,419 --> 00:04:03,160
the SOA and we got a little bit better

00:04:00,579 --> 00:04:04,930
in terms of infrastructure so I have

00:04:03,160 --> 00:04:07,540
three applications here an accounting

00:04:04,930 --> 00:04:09,669
service inventory service and a shipping

00:04:07,540 --> 00:04:11,109
service and so we've split up that

00:04:09,669 --> 00:04:14,860
infrastructure that single monolithic

00:04:11,109 --> 00:04:16,900
application into three separate

00:04:14,860 --> 00:04:18,730
but the problem over time with the SOA

00:04:16,900 --> 00:04:22,390
is that they're at the bottom we're

00:04:18,730 --> 00:04:25,210
still sharing on libraries we're sharing

00:04:22,390 --> 00:04:27,070
the objects in our domain and these

00:04:25,210 --> 00:04:29,500
different teams working on these three

00:04:27,070 --> 00:04:32,320
separate applications may need to change

00:04:29,500 --> 00:04:34,600
one of those domain objects to support

00:04:32,320 --> 00:04:36,640
their functionality and so if I change

00:04:34,600 --> 00:04:38,860
the customer record or the accounts

00:04:36,640 --> 00:04:40,750
record then I just deploy the accounting

00:04:38,860 --> 00:04:43,300
service and so I get that benefit of

00:04:40,750 --> 00:04:44,950
being able to deploy independently but

00:04:43,300 --> 00:04:47,110
what happens if I make a change to the

00:04:44,950 --> 00:04:48,669
address record now I have to deploy all

00:04:47,110 --> 00:04:51,070
three of these applications at the same

00:04:48,669 --> 00:04:54,130
time in a coordinated release and so

00:04:51,070 --> 00:04:57,040
over time the SOA makes it harder than

00:04:54,130 --> 00:04:59,860
the monolith and so now we've arrived at

00:04:57,040 --> 00:05:01,570
microservices and the idea is that small

00:04:59,860 --> 00:05:03,400
teams are organized around business

00:05:01,570 --> 00:05:06,430
capabilities right so most of you know

00:05:03,400 --> 00:05:08,680
what micro services are today but the

00:05:06,430 --> 00:05:10,750
idea really is velocity and not sharing

00:05:08,680 --> 00:05:12,070
anything right so we're gonna move to

00:05:10,750 --> 00:05:14,140
something called a share nothing

00:05:12,070 --> 00:05:16,450
architecture that is we're not going to

00:05:14,140 --> 00:05:18,100
share our libraries either what we're

00:05:16,450 --> 00:05:19,870
gonna do is we're gonna create an

00:05:18,100 --> 00:05:23,110
economy of applications that produce

00:05:19,870 --> 00:05:25,479
api's and consume api stand so we'll

00:05:23,110 --> 00:05:27,520
have many small services organized

00:05:25,479 --> 00:05:29,710
around business capabilities and they'll

00:05:27,520 --> 00:05:34,750
expose their functionality to the rest

00:05:29,710 --> 00:05:36,970
of the applications via REST API and the

00:05:34,750 --> 00:05:38,620
key thing here is that these teams need

00:05:36,970 --> 00:05:40,090
to be able to build and run their

00:05:38,620 --> 00:05:42,460
applications right there's all these

00:05:40,090 --> 00:05:44,500
things that you need to really support a

00:05:42,460 --> 00:05:46,870
practice of building micro services and

00:05:44,500 --> 00:05:48,910
this is the most important one with

00:05:46,870 --> 00:05:50,650
implications to cloud boundaries and

00:05:48,910 --> 00:05:53,020
cloud platforms is that you have

00:05:50,650 --> 00:05:55,360
self-service on-demand infrastructure

00:05:53,020 --> 00:05:57,460
you give everything to your developers

00:05:55,360 --> 00:06:01,240
that they need to be able to build and

00:05:57,460 --> 00:06:03,760
run that application and so here's an

00:06:01,240 --> 00:06:05,260
example of micro services a micro

00:06:03,760 --> 00:06:07,330
service architecture that's cloud native

00:06:05,260 --> 00:06:09,729
I put this together for the cloud native

00:06:07,330 --> 00:06:12,640
Java book this is an online store

00:06:09,729 --> 00:06:15,070
it has 10 micro services and that middle

00:06:12,640 --> 00:06:16,960
layer I have my platform services and so

00:06:15,070 --> 00:06:19,600
when I talk about giving developers

00:06:16,960 --> 00:06:21,760
everything that they need to build their

00:06:19,600 --> 00:06:23,140
application that middle layer is that

00:06:21,760 --> 00:06:24,129
marketplace right these are the

00:06:23,140 --> 00:06:26,319
platforms service

00:06:24,129 --> 00:06:28,749
is that these developers can't provision

00:06:26,319 --> 00:06:31,330
on demand and be able to plug into their

00:06:28,749 --> 00:06:33,189
application without having to implement

00:06:31,330 --> 00:06:35,589
it over and over and over again in each

00:06:33,189 --> 00:06:37,569
application and the one that we're going

00:06:35,589 --> 00:06:39,729
to be talking about today is the API

00:06:37,569 --> 00:06:41,529
gateway in the center and what this is

00:06:39,729 --> 00:06:44,469
going to do is it's going to hide all

00:06:41,529 --> 00:06:46,629
the complexity down below with my domain

00:06:44,469 --> 00:06:48,009
services so that the front-end

00:06:46,629 --> 00:06:50,139
developers don't have to worry about

00:06:48,009 --> 00:06:52,839
that right so if you have 500 micro

00:06:50,139 --> 00:06:54,729
services and they all have AP is we

00:06:52,839 --> 00:06:57,189
don't want the front-end developers to

00:06:54,729 --> 00:07:00,219
have to see that complexity we want them

00:06:57,189 --> 00:07:02,889
to see a single contract an API contract

00:07:00,219 --> 00:07:06,039
of that domain and so we can use this

00:07:02,889 --> 00:07:08,139
API gateway to reverse proxy into these

00:07:06,039 --> 00:07:09,999
back-end services and so from the

00:07:08,139 --> 00:07:12,069
front-end application if I want to use

00:07:09,999 --> 00:07:14,499
the catalog service I go to ford slash

00:07:12,069 --> 00:07:17,199
catalog at the API gateway or the

00:07:14,499 --> 00:07:19,809
account service and so I have a way to

00:07:17,199 --> 00:07:22,059
combine together all of these api's from

00:07:19,809 --> 00:07:27,039
the separate services into one API

00:07:22,059 --> 00:07:29,829
contract now there are two popular ways

00:07:27,039 --> 00:07:32,529
of going from a monolith to micro

00:07:29,829 --> 00:07:34,209
services one of the ways is splitting

00:07:32,529 --> 00:07:36,849
the monolith and that becomes very

00:07:34,209 --> 00:07:39,129
painful over time because you have more

00:07:36,849 --> 00:07:41,139
than just the application right so most

00:07:39,129 --> 00:07:43,899
monoliths are on a large shared database

00:07:41,139 --> 00:07:45,639
actually almost all of them are and the

00:07:43,899 --> 00:07:47,409
idea is that not only do you need to

00:07:45,639 --> 00:07:49,869
split off functionality from the

00:07:47,409 --> 00:07:52,300
application but you have to extract out

00:07:49,869 --> 00:07:54,729
these tables from that database and

00:07:52,300 --> 00:07:56,889
migrate them to new databases and so

00:07:54,729 --> 00:07:59,259
over time it becomes very difficult to

00:07:56,889 --> 00:08:00,969
split up a complex domain because you

00:07:59,259 --> 00:08:03,399
have all these foreign key relationships

00:08:00,969 --> 00:08:05,649
that are running across tables and not

00:08:03,399 --> 00:08:07,689
only that in the backend you also have a

00:08:05,649 --> 00:08:10,419
data warehouse right so you have ETLs

00:08:07,689 --> 00:08:12,159
running from third party systems into

00:08:10,419 --> 00:08:14,649
this large shared database and so over

00:08:12,159 --> 00:08:16,539
time it becomes very very painful to go

00:08:14,649 --> 00:08:18,339
to microcircuits by splitting the

00:08:16,539 --> 00:08:20,679
monolith and so there is another

00:08:18,339 --> 00:08:23,409
strategy called strangling the monolith

00:08:20,679 --> 00:08:26,439
and this was first proposed by martin

00:08:23,409 --> 00:08:29,110
fowler back in around 2002 he went to

00:08:26,439 --> 00:08:31,419
australia on vacation and he saw this

00:08:29,110 --> 00:08:33,250
plant here this is called a strangler

00:08:31,419 --> 00:08:35,880
vine and what the strangler vine does is

00:08:33,250 --> 00:08:38,250
it seeds itself in the upper branches

00:08:35,880 --> 00:08:40,620
of a fig tree and it works its way down

00:08:38,250 --> 00:08:43,260
the trunk of the tree all the way to the

00:08:40,620 --> 00:08:45,240
root system extracting the resources

00:08:43,260 --> 00:08:47,010
that the tree is producing and the

00:08:45,240 --> 00:08:49,260
benefit that it gets is it doesn't have

00:08:47,010 --> 00:08:51,270
to grow up from the forest floor it

00:08:49,260 --> 00:08:53,670
works its way down from the top of the

00:08:51,270 --> 00:08:56,060
tree and so what Martin said is that

00:08:53,670 --> 00:08:58,860
what you can do is take this philosophy

00:08:56,060 --> 00:09:00,900
gradually create a new system around the

00:08:58,860 --> 00:09:03,870
edges of the old letting it grow slowly

00:09:00,900 --> 00:09:07,200
over several years until the old system

00:09:03,870 --> 00:09:09,080
is strangled and what you really need to

00:09:07,200 --> 00:09:12,150
do this is called an indirection layer

00:09:09,080 --> 00:09:14,220
now not all architectures are monoliths

00:09:12,150 --> 00:09:17,220
and so here's an example of an SOA

00:09:14,220 --> 00:09:19,740
that's migrating to microservices and

00:09:17,220 --> 00:09:21,960
here we have an ESB which is usually

00:09:19,740 --> 00:09:23,880
evil but in this case it's going to help

00:09:21,960 --> 00:09:26,460
us because it gives us that indirection

00:09:23,880 --> 00:09:28,590
layer that place where we concede that

00:09:26,460 --> 00:09:31,980
Strangler vine and start to gain control

00:09:28,590 --> 00:09:35,520
of extracting out data from this large

00:09:31,980 --> 00:09:37,230
shared database and so with this pattern

00:09:35,520 --> 00:09:39,810
what you can do is create an edge

00:09:37,230 --> 00:09:42,480
between your legacy system and your new

00:09:39,810 --> 00:09:44,790
microcircuits and that legacy edge can

00:09:42,480 --> 00:09:47,520
do useful things like adapt formats

00:09:44,790 --> 00:09:49,050
right so if you have legacy formats with

00:09:47,520 --> 00:09:51,390
your micro services you'll be using

00:09:49,050 --> 00:09:54,420
modern formats and so this legacy edge

00:09:51,390 --> 00:09:58,590
adaptor can be an api gateway that

00:09:54,420 --> 00:10:00,840
translates between these formats but the

00:09:58,590 --> 00:10:03,000
goal here is to migrate data away from

00:10:00,840 --> 00:10:04,830
the large shared database using

00:10:03,000 --> 00:10:07,050
something called a cache pattern or

00:10:04,830 --> 00:10:10,260
gateway cache pattern and what you do is

00:10:07,050 --> 00:10:12,120
just like a cache you'll reach into that

00:10:10,260 --> 00:10:14,340
back-end if you don't have a record in

00:10:12,120 --> 00:10:16,050
your micro services database so let's

00:10:14,340 --> 00:10:18,120
say I'm trying to get a customer record

00:10:16,050 --> 00:10:20,190
and it's not in my micro service

00:10:18,120 --> 00:10:22,680
database what I'll do is I'll look at

00:10:20,190 --> 00:10:24,360
that legacy system I'll take control

00:10:22,680 --> 00:10:26,340
over a single service maybe it's the

00:10:24,360 --> 00:10:28,500
customer service I'll request that

00:10:26,340 --> 00:10:30,690
object from there and I'll save it to my

00:10:28,500 --> 00:10:33,030
micro services database and then on the

00:10:30,690 --> 00:10:35,250
subsequent request I'll go there instead

00:10:33,030 --> 00:10:38,510
of going until legacy back-end and so

00:10:35,250 --> 00:10:40,920
you can use an API gateway to do this

00:10:38,510 --> 00:10:42,750
but what this allows you to do is you

00:10:40,920 --> 00:10:44,880
move all your new feature development to

00:10:42,750 --> 00:10:47,220
your micro services you don't have to

00:10:44,880 --> 00:10:47,620
worry about splitting that monolith over

00:10:47,220 --> 00:10:49,570
time

00:10:47,620 --> 00:10:51,850
because that's a lot of undifferentiated

00:10:49,570 --> 00:10:53,740
heavy lifting and so what you can do

00:10:51,850 --> 00:10:56,290
instead is to start to build your new

00:10:53,740 --> 00:10:58,540
microservices and use this legacy edge

00:10:56,290 --> 00:11:01,600
to reach into that legacy back-end and

00:10:58,540 --> 00:11:03,430
begin to migrate your data away into

00:11:01,600 --> 00:11:05,650
your micro service layer and eventually

00:11:03,430 --> 00:11:08,110
you'll be able to reason about what's

00:11:05,650 --> 00:11:12,850
the costs of shutting out shutting down

00:11:08,110 --> 00:11:14,080
that legacy system and so you can use

00:11:12,850 --> 00:11:16,660
something like that little Cloud Foundry

00:11:14,080 --> 00:11:19,990
to do this so here's an example of PCF

00:11:16,660 --> 00:11:22,360
now everything in Cloud Foundry really

00:11:19,990 --> 00:11:24,070
exists to reduce the level of

00:11:22,360 --> 00:11:25,240
undifferentiated heavy lifting that

00:11:24,070 --> 00:11:26,980
you're doing your application

00:11:25,240 --> 00:11:28,960
development and so you can use tools

00:11:26,980 --> 00:11:31,720
from Cloud Foundry to do that with that

00:11:28,960 --> 00:11:36,210
marketplace such as Apogee edge which

00:11:31,720 --> 00:11:36,210
Britt ball's going to talk about now

00:11:40,980 --> 00:11:45,760
awesome so so can you spend some time

00:11:43,960 --> 00:11:47,770
taking a look at different strategies

00:11:45,760 --> 00:11:50,530
for moving from you know your monoliths

00:11:47,770 --> 00:11:53,140
to micro services so we feel API

00:11:50,530 --> 00:11:56,070
management has a pretty important role

00:11:53,140 --> 00:11:58,330
let's examine how that actually works so

00:11:56,070 --> 00:12:00,580
one of the first things you do as part

00:11:58,330 --> 00:12:02,410
of app modernization is start to build

00:12:00,580 --> 00:12:04,300
out micro services and that's great

00:12:02,410 --> 00:12:07,090
but if you focus more on the micro

00:12:04,300 --> 00:12:10,150
services it is an architecture style

00:12:07,090 --> 00:12:11,830
it's an approach and you start composing

00:12:10,150 --> 00:12:14,560
and building out business logic within

00:12:11,830 --> 00:12:16,800
the micro service it's well contained so

00:12:14,560 --> 00:12:21,340
where does an API really come in well

00:12:16,800 --> 00:12:25,240
API becomes what Kenny had alluded to as

00:12:21,340 --> 00:12:27,220
the contract that becomes the way your

00:12:25,240 --> 00:12:28,930
consumers whether the consumers happen

00:12:27,220 --> 00:12:31,810
to be across different teams within your

00:12:28,930 --> 00:12:34,210
enterprise or if the micro service now

00:12:31,810 --> 00:12:36,430
starts to enable a capability outside of

00:12:34,210 --> 00:12:38,740
the enterprise boundary that becomes the

00:12:36,430 --> 00:12:41,590
contract that becomes a mechanism that

00:12:38,740 --> 00:12:44,620
app developers which are building apps

00:12:41,590 --> 00:12:46,540
against those micro sources use that API

00:12:44,620 --> 00:12:50,830
as a contract communicate with our micro

00:12:46,540 --> 00:12:52,230
service in some ways we feel API than

00:12:50,830 --> 00:12:55,450
micro sources are very complementary

00:12:52,230 --> 00:12:58,570
what do we really mean by that well API

00:12:55,450 --> 00:12:59,490
existed even before app modernization of

00:12:58,570 --> 00:13:02,070
the strategy became

00:12:59,490 --> 00:13:03,510
commonplace which means yes you may have

00:13:02,070 --> 00:13:06,000
services which are either legacy

00:13:03,510 --> 00:13:09,149
oriented or you may use something like

00:13:06,000 --> 00:13:11,250
SLA or a layer similar to that you are

00:13:09,149 --> 00:13:13,350
still accessing death returned api's as

00:13:11,250 --> 00:13:15,149
you now start to move into the micro

00:13:13,350 --> 00:13:17,070
services world without modernization

00:13:15,149 --> 00:13:20,070
especially leveraging platform like

00:13:17,070 --> 00:13:22,350
Cloud Foundry APs and micro services

00:13:20,070 --> 00:13:23,399
become complementary in a way that you

00:13:22,350 --> 00:13:25,890
still access them through

00:13:23,399 --> 00:13:28,410
standards-based HTTP rest endpoints

00:13:25,890 --> 00:13:31,950
right so from that perspective that

00:13:28,410 --> 00:13:34,470
becomes your outside of view in into you

00:13:31,950 --> 00:13:37,050
know how to access them what are the

00:13:34,470 --> 00:13:41,040
other benefits of leveraging API is is

00:13:37,050 --> 00:13:42,540
they shield complexity from the they

00:13:41,040 --> 00:13:44,580
shield the consumers from any kind of

00:13:42,540 --> 00:13:47,190
micro sources complexity what do I

00:13:44,580 --> 00:13:49,230
really mean by that well the reality is

00:13:47,190 --> 00:13:51,720
for some period of time you're going to

00:13:49,230 --> 00:13:54,209
have the existing Enterprise legacy

00:13:51,720 --> 00:13:55,529
systems may be some middleware but

00:13:54,209 --> 00:13:58,470
you're slowly moving over to micro

00:13:55,529 --> 00:14:00,300
services right during that transition it

00:13:58,470 --> 00:14:03,060
becomes important to continue business

00:14:00,300 --> 00:14:06,000
as usual which means if you're exposing

00:14:03,060 --> 00:14:08,610
those capabilities using api's as we

00:14:06,000 --> 00:14:10,770
transition into micro services you are

00:14:08,610 --> 00:14:12,360
still able to offer the same exact kind

00:14:10,770 --> 00:14:13,500
of level of service yet you're

00:14:12,360 --> 00:14:16,079
refactoring into a more modern

00:14:13,500 --> 00:14:18,870
architecture right over time you may

00:14:16,079 --> 00:14:21,329
either change stacks or different themes

00:14:18,870 --> 00:14:24,089
as they come in so ap has kind of become

00:14:21,329 --> 00:14:26,220
this layer of installation where as you

00:14:24,089 --> 00:14:29,160
and you know on your app modernization

00:14:26,220 --> 00:14:32,339
journey you're able to kind of pace

00:14:29,160 --> 00:14:34,740
yourself then you move into micro

00:14:32,339 --> 00:14:37,829
services API start to shield that kind

00:14:34,740 --> 00:14:40,290
of complexity the other part is as an

00:14:37,829 --> 00:14:43,230
API contract you specify a specific

00:14:40,290 --> 00:14:46,740
version that customers or consumers of

00:14:43,230 --> 00:14:49,110
the api's are accessing for hearing some

00:14:46,740 --> 00:14:51,510
capability at the same time you are able

00:14:49,110 --> 00:14:53,160
to move forward in your newer versions

00:14:51,510 --> 00:14:55,980
of micro services and when the time is

00:14:53,160 --> 00:14:57,990
right make that switch for new consumers

00:14:55,980 --> 00:15:00,149
to start using newer versions so what

00:14:57,990 --> 00:15:03,520
that means is you're able to move faster

00:15:00,149 --> 00:15:07,180
at your pace and still be able to hide

00:15:03,520 --> 00:15:08,560
complexity just like micro sources you

00:15:07,180 --> 00:15:10,870
go through different phases in their

00:15:08,560 --> 00:15:14,230
lifecycle the moment to expose there is

00:15:10,870 --> 00:15:17,200
an API every API has a lifecycle this is

00:15:14,230 --> 00:15:20,530
important why because you want to be

00:15:17,200 --> 00:15:22,810
able to ensure that you have core set of

00:15:20,530 --> 00:15:24,910
capabilities to tackle all the phases of

00:15:22,810 --> 00:15:28,120
the API lifecycle it obviously starts

00:15:24,910 --> 00:15:30,790
from a design in which case the swagger

00:15:28,120 --> 00:15:33,310
or open API as it's called now is a very

00:15:30,790 --> 00:15:35,560
common standard which many API

00:15:33,310 --> 00:15:38,380
developers are using to expose their API

00:15:35,560 --> 00:15:40,780
but as soon as you start to compose

00:15:38,380 --> 00:15:42,220
these micro services at api's you need

00:15:40,780 --> 00:15:45,250
to ensure they have the right level of

00:15:42,220 --> 00:15:46,960
security right which means it could be

00:15:45,250 --> 00:15:50,080
making sure that everything is protected

00:15:46,960 --> 00:15:51,670
using OAuth as an example or it could be

00:15:50,080 --> 00:15:53,680
ensuring that we have the right set of

00:15:51,670 --> 00:15:55,390
traffic management policies as an

00:15:53,680 --> 00:15:57,790
example you know your cloud native

00:15:55,390 --> 00:15:59,710
platform can scale infinitely at some

00:15:57,790 --> 00:16:02,050
level but you still want to be able to

00:15:59,710 --> 00:16:05,050
perhaps provide for some common-sense

00:16:02,050 --> 00:16:07,630
quotas on how much NEPA can be used

00:16:05,050 --> 00:16:09,010
maybe they're tied into the consumer and

00:16:07,630 --> 00:16:11,350
the kind of contract we have with that

00:16:09,010 --> 00:16:13,390
consumer maybe it's a gold tier partner

00:16:11,350 --> 00:16:15,370
versus a platinum tier partner right we

00:16:13,390 --> 00:16:16,990
have some traffic lament needs which are

00:16:15,370 --> 00:16:20,170
beyond just technical traffic management

00:16:16,990 --> 00:16:22,510
as you start to get into securing your

00:16:20,170 --> 00:16:25,330
API then you want to ensure that the

00:16:22,510 --> 00:16:27,580
api's are published that's usually done

00:16:25,330 --> 00:16:29,980
through developer portal okay so as you

00:16:27,580 --> 00:16:32,500
start to look to the API lifecycle there

00:16:29,980 --> 00:16:34,600
are very important aspects of each and

00:16:32,500 --> 00:16:38,890
every element of the lifecycle which

00:16:34,600 --> 00:16:41,530
need to be solved for and the Apogee API

00:16:38,890 --> 00:16:43,900
platform is the full API lifecycle

00:16:41,530 --> 00:16:45,550
platform which gives you the ability for

00:16:43,900 --> 00:16:49,540
you to be able to securely expose the

00:16:45,550 --> 00:16:51,760
api's and be able to offer api packages

00:16:49,540 --> 00:16:54,090
which can be consumed by the app

00:16:51,760 --> 00:16:56,230
developers on the developer portal

00:16:54,090 --> 00:16:58,870
analytics gives you the end-to-end

00:16:56,230 --> 00:17:01,570
visibility what that really means is as

00:16:58,870 --> 00:17:03,400
soon as you start having an Apogee API

00:17:01,570 --> 00:17:05,770
platform and the API gateway the core

00:17:03,400 --> 00:17:09,100
component of the platform in front of

00:17:05,770 --> 00:17:11,200
your micro services you now have instant

00:17:09,100 --> 00:17:14,320
visibility into micro services and API

00:17:11,200 --> 00:17:15,779
usage so instead of now going to a third

00:17:14,320 --> 00:17:18,119
party system to figure out

00:17:15,779 --> 00:17:20,969
how many AAP are being used by what

00:17:18,119 --> 00:17:23,129
partners and what kind of apps are being

00:17:20,969 --> 00:17:24,929
powered by the api's you get instant

00:17:23,129 --> 00:17:27,839
visibility into not only the operational

00:17:24,929 --> 00:17:30,779
aspects of though the api's but even the

00:17:27,839 --> 00:17:33,179
business metrics customers can you use

00:17:30,779 --> 00:17:35,609
some of the self-service tools which are

00:17:33,179 --> 00:17:38,609
built into the analytics capability to

00:17:35,609 --> 00:17:41,129
build reports for businesses let's say

00:17:38,609 --> 00:17:44,129
you are working with an order API as an

00:17:41,129 --> 00:17:46,200
example and you want to be able to very

00:17:44,129 --> 00:17:49,109
quickly surface a report give me a

00:17:46,200 --> 00:17:51,419
breakdown of all orders in this region

00:17:49,109 --> 00:17:54,599
over the last month and a half with an

00:17:51,419 --> 00:17:56,759
order amount greater than $1,000 that's

00:17:54,599 --> 00:17:59,369
something that someone can go into the

00:17:56,759 --> 00:18:00,929
tool use the custom report a bill to

00:17:59,369 --> 00:18:02,700
report from the order a peer very very

00:18:00,929 --> 00:18:04,799
quickly right that's the power of the

00:18:02,700 --> 00:18:08,159
energies platform as you start getting

00:18:04,799 --> 00:18:10,200
into more levels of maturity with your

00:18:08,159 --> 00:18:12,359
API program you run into situations

00:18:10,200 --> 00:18:14,009
where you may want to monetize the api's

00:18:12,359 --> 00:18:15,989
we have many different examples of

00:18:14,009 --> 00:18:19,139
customers who are leveraging the API

00:18:15,989 --> 00:18:22,379
platform to monetize the api's Walgreens

00:18:19,139 --> 00:18:24,089
sauce Tara MapQuest many others who are

00:18:22,379 --> 00:18:26,399
leveraging those capabilities so the

00:18:24,089 --> 00:18:28,619
apogee API platform is delivered in

00:18:26,399 --> 00:18:31,139
three different flavors you can use that

00:18:28,619 --> 00:18:33,690
as a software service completely in the

00:18:31,139 --> 00:18:36,149
cloud or you can use it completely

00:18:33,690 --> 00:18:39,719
on-premises or use pieces of it which

00:18:36,149 --> 00:18:42,299
are in the cloud and some on-premises so

00:18:39,719 --> 00:18:44,249
Apogee provides the layer API layer for

00:18:42,299 --> 00:18:46,409
micro services and we essentially have

00:18:44,249 --> 00:18:48,269
two different form factors one is the

00:18:46,409 --> 00:18:50,279
Enterprise API gateway which is

00:18:48,269 --> 00:18:53,249
traditionally used in a DMZ layer in

00:18:50,279 --> 00:18:55,409
front of Cloud Foundry or your legacy

00:18:53,249 --> 00:18:57,389
stack and then you also have a smaller

00:18:55,409 --> 00:18:59,839
runtime what we call as the Apogee micro

00:18:57,389 --> 00:19:03,539
gateway this is something which can be

00:18:59,839 --> 00:19:04,769
deployed close to your target machine

00:19:03,539 --> 00:19:06,839
which is very oh my crow service is

00:19:04,769 --> 00:19:08,759
running and it gives you all the LEDs of

00:19:06,839 --> 00:19:13,320
security traffic management and

00:19:08,759 --> 00:19:16,019
analytics to those micro services so

00:19:13,320 --> 00:19:17,279
from a relationship perspective Apogee

00:19:16,019 --> 00:19:19,499
and pivotal have been working for the

00:19:17,279 --> 00:19:23,039
last couple years we've been partners in

00:19:19,499 --> 00:19:25,170
a few different areas we've had

00:19:23,039 --> 00:19:29,340
prototypes integrations that we

00:19:25,170 --> 00:19:32,400
rolled out for the last 18 months one

00:19:29,340 --> 00:19:34,560
such example of that offering is the EPI

00:19:32,400 --> 00:19:36,540
gh service broker for terminal Cloud

00:19:34,560 --> 00:19:38,940
Foundry so it's available in pip net I

00:19:36,540 --> 00:19:41,630
think we are in version 2 1-1 today this

00:19:38,940 --> 00:19:43,170
offers two different styles of

00:19:41,630 --> 00:19:45,180
integration patterns

00:19:43,170 --> 00:19:47,970
the first one is through route services

00:19:45,180 --> 00:19:50,820
so using route services once you deploy

00:19:47,970 --> 00:19:53,310
the you configure the tile and you

00:19:50,820 --> 00:19:54,930
create a service instance we have two

00:19:53,310 --> 00:19:57,000
different plans supported one for the

00:19:54,930 --> 00:20:00,120
enterprise and one for the micro gateway

00:19:57,000 --> 00:20:03,930
as a Cloud Foundry app developer you

00:20:00,120 --> 00:20:06,120
build your app you do a CF push once the

00:20:03,930 --> 00:20:07,980
app is up and running you can use these

00:20:06,120 --> 00:20:09,780
server out sources this integration if

00:20:07,980 --> 00:20:11,820
you have wrought services turned on you

00:20:09,780 --> 00:20:14,310
can just issue a bind dot service

00:20:11,820 --> 00:20:17,100
command passing in some key information

00:20:14,310 --> 00:20:19,650
about the Appaji org and when you do

00:20:17,100 --> 00:20:22,560
that we automatically generate an API

00:20:19,650 --> 00:20:24,180
proxy within a PG edge write and the

00:20:22,560 --> 00:20:26,790
routing table within Cloud Foundry gets

00:20:24,180 --> 00:20:28,620
updated what that really means is the

00:20:26,790 --> 00:20:31,080
moment you push the app and you run bind

00:20:28,620 --> 00:20:33,180
route services you actually have an API

00:20:31,080 --> 00:20:36,200
proxy which is deployed for you an app

00:20:33,180 --> 00:20:38,640
ugh any time you start now hitting that

00:20:36,200 --> 00:20:41,460
API endpoint which is nothing but your

00:20:38,640 --> 00:20:43,770
micro service endpoint the call gets

00:20:41,460 --> 00:20:46,530
intercepted where out sources it pushes

00:20:43,770 --> 00:20:48,180
that to a PG edge where you can use all

00:20:46,530 --> 00:20:50,520
the different out-of-the-box policies we

00:20:48,180 --> 00:20:52,400
have so we have over 30 different out of

00:20:50,520 --> 00:20:54,960
the box policies you do security

00:20:52,400 --> 00:20:58,260
transformation traffic mam and mediation

00:20:54,960 --> 00:21:00,660
etc it hits that layer you do all the

00:20:58,260 --> 00:21:02,310
a/b mmm and concerns out there then the

00:21:00,660 --> 00:21:04,920
request gets routed back to the app

00:21:02,310 --> 00:21:06,840
right so by leveraging a route services

00:21:04,920 --> 00:21:08,850
their integration you're slowly wheeling

00:21:06,840 --> 00:21:12,750
in API management automatically for all

00:21:08,850 --> 00:21:15,000
your laundry apps then the next one the

00:21:12,750 --> 00:21:18,300
Cloud Foundry decorative bill pack this

00:21:15,000 --> 00:21:19,050
is a deployment style we are planning on

00:21:18,300 --> 00:21:20,880
releasing

00:21:19,050 --> 00:21:23,130
generally available edition is very very

00:21:20,880 --> 00:21:24,900
soon but this leverages the Maribelle

00:21:23,130 --> 00:21:27,090
pack capability within cloud foundry and

00:21:24,900 --> 00:21:29,490
by this pattern what you really can do

00:21:27,090 --> 00:21:31,260
is you can take a PGH micro gateway

00:21:29,490 --> 00:21:35,250
which is a very very small footprint and

00:21:31,260 --> 00:21:38,430
it can reside or be co-resident inside

00:21:35,250 --> 00:21:40,590
çf app container right this is a great

00:21:38,430 --> 00:21:43,410
way for you to distribute the API

00:21:40,590 --> 00:21:45,420
runtime and as you scale your Cloud

00:21:43,410 --> 00:21:46,920
Foundry apps this scales with it right

00:21:45,420 --> 00:21:49,050
so this is a great way of separation of

00:21:46,920 --> 00:21:51,090
concerns you're building a micro sources

00:21:49,050 --> 00:21:53,340
you push it out there you configure

00:21:51,090 --> 00:21:56,070
certain policies and the ap8 macro

00:21:53,340 --> 00:21:57,930
gateway can protect secure and do

00:21:56,070 --> 00:21:59,970
everything that you need to for that

00:21:57,930 --> 00:22:02,310
micro service at the same time pushing

00:21:59,970 --> 00:22:03,810
analytics into a common plane which can

00:22:02,310 --> 00:22:07,740
be accessed by by everyone in the

00:22:03,810 --> 00:22:09,960
organization the second offering that we

00:22:07,740 --> 00:22:11,760
have a little bit related to more around

00:22:09,960 --> 00:22:14,820
Bosch so we have an Apogee edge

00:22:11,760 --> 00:22:18,680
installer for several Cloud Foundry you

00:22:14,820 --> 00:22:21,120
you can leverage this and install a PGH

00:22:18,680 --> 00:22:23,520
right next to your pivotal Cloud Foundry

00:22:21,120 --> 00:22:26,130
foundation in the same way that bosch

00:22:23,520 --> 00:22:28,830
manages pivotal Cloud Foundry you can

00:22:26,130 --> 00:22:30,840
use Bosch to manage Apogee edge so you

00:22:28,830 --> 00:22:33,270
know all the benefits of managed

00:22:30,840 --> 00:22:35,670
maintenance self-healing etc now get

00:22:33,270 --> 00:22:36,900
passionate with that this is a pattern

00:22:35,670 --> 00:22:39,570
which is used by a lot of our

00:22:36,900 --> 00:22:41,480
on-premises customers and you know this

00:22:39,570 --> 00:22:44,670
continues to get more and more traction

00:22:41,480 --> 00:22:46,530
so use the API management as the

00:22:44,670 --> 00:22:48,960
transition to micro services I think

00:22:46,530 --> 00:22:52,200
this is a very very important bring home

00:22:48,960 --> 00:22:55,410
slide and as you saw Kenny walk you

00:22:52,200 --> 00:22:58,440
through the different pieces of strategy

00:22:55,410 --> 00:23:00,480
and patterns that you used to now deal

00:22:58,440 --> 00:23:03,840
with micro services and enable certain

00:23:00,480 --> 00:23:06,000
key capabilities reality is business as

00:23:03,840 --> 00:23:08,610
usual needs to continue on and for many

00:23:06,000 --> 00:23:11,520
enterprises this seems to be a very very

00:23:08,610 --> 00:23:13,980
common pattern they leverage a PGH in

00:23:11,520 --> 00:23:16,710
the front out there for any horizontal

00:23:13,980 --> 00:23:18,840
API memory concerns which means if I

00:23:16,710 --> 00:23:20,850
wanted a general threat protection the

00:23:18,840 --> 00:23:23,220
general kind of security and traffic

00:23:20,850 --> 00:23:25,260
management whether the request is going

00:23:23,220 --> 00:23:28,200
to pivotal foundry or to my legacy app

00:23:25,260 --> 00:23:29,790
you can use a pH in the front this

00:23:28,200 --> 00:23:31,680
becomes your later enforcement right

00:23:29,790 --> 00:23:34,230
this also becomes the layer which will

00:23:31,680 --> 00:23:35,490
cater to all the contract one of the

00:23:34,230 --> 00:23:38,340
other things which can you point it out

00:23:35,490 --> 00:23:39,990
was the the Gateway cache pattern this

00:23:38,340 --> 00:23:42,240
is another classical news cable you can

00:23:39,990 --> 00:23:43,549
just configure caching out here so data

00:23:42,240 --> 00:23:44,629
from a legacy back-end

00:23:43,549 --> 00:23:47,059
and the one which you needed where my

00:23:44,629 --> 00:23:50,600
resources could very quickly be cashed

00:23:47,059 --> 00:23:52,340
on the gate where there another big

00:23:50,600 --> 00:23:54,440
advantage of this approach is many

00:23:52,340 --> 00:23:57,470
customers are using this to be able to

00:23:54,440 --> 00:23:59,330
justify decisions on how much stuff they

00:23:57,470 --> 00:24:01,580
want to move over the Cloud Foundry so

00:23:59,330 --> 00:24:03,049
let me give an example of that by using

00:24:01,580 --> 00:24:05,029
the analytics provided by the platform

00:24:03,049 --> 00:24:07,519
they're actually able to see in real

00:24:05,029 --> 00:24:09,529
time what kind of API traffic is served

00:24:07,519 --> 00:24:11,090
from the legacy platform versus what

00:24:09,529 --> 00:24:12,739
kind of API traffic is being served from

00:24:11,090 --> 00:24:14,720
the new pivotal Cloud Foundry

00:24:12,739 --> 00:24:16,999
deployments right so they're using some

00:24:14,720 --> 00:24:19,639
of those data points to be able to make

00:24:16,999 --> 00:24:22,190
decisions on how much traffic needs to

00:24:19,639 --> 00:24:24,830
move over to the to the new platform and

00:24:22,190 --> 00:24:27,730
thereby leveraging you know some of the

00:24:24,830 --> 00:24:30,200
capabilities provided by the platform so

00:24:27,730 --> 00:24:32,600
these kind of integrations that we have

00:24:30,200 --> 00:24:35,239
jointly built and continue to iterate on

00:24:32,600 --> 00:24:37,970
have benefits for both sides of the

00:24:35,239 --> 00:24:40,549
house if you look at the developers they

00:24:37,970 --> 00:24:42,679
are able to use some pre-built traffic

00:24:40,549 --> 00:24:44,899
management security policies and

00:24:42,679 --> 00:24:47,119
analytics and apply them to their micro

00:24:44,899 --> 00:24:50,539
services irrespective of how many of

00:24:47,119 --> 00:24:52,100
them they deploy right once you get into

00:24:50,539 --> 00:24:54,619
a level of maturity with your API

00:24:52,100 --> 00:24:56,509
program you are able to then leverage

00:24:54,619 --> 00:24:58,549
some of the monetization capabilities of

00:24:56,509 --> 00:25:01,820
the platform to now start charging for

00:24:58,549 --> 00:25:04,129
api's and monitor them and even if you

00:25:01,820 --> 00:25:06,379
don't have a public API program many

00:25:04,129 --> 00:25:08,629
cases we have enterprises who have a

00:25:06,379 --> 00:25:10,249
shared services team which are offering

00:25:08,629 --> 00:25:12,440
the platform for the individual lines of

00:25:10,249 --> 00:25:14,090
businesses you can use the monetization

00:25:12,440 --> 00:25:15,340
capabilities to provide metering

00:25:14,090 --> 00:25:18,409
chargebacks and all those capabilities

00:25:15,340 --> 00:25:21,049
becomes super easy and then last but not

00:25:18,409 --> 00:25:23,269
the least provide a catalog of API so

00:25:21,049 --> 00:25:25,039
developers can test those services make

00:25:23,269 --> 00:25:27,230
sure the EPA are working the way they

00:25:25,039 --> 00:25:29,269
should for the operators especially

00:25:27,230 --> 00:25:31,639
leveraging the Boston store pieces

00:25:29,269 --> 00:25:33,529
they're able to apply a common set of

00:25:31,639 --> 00:25:35,869
security practices in a horizontal

00:25:33,529 --> 00:25:39,379
concern they're able to scale these kind

00:25:35,869 --> 00:25:41,629
of features out and more importantly get

00:25:39,379 --> 00:25:44,149
the same kind of administration look and

00:25:41,629 --> 00:25:47,980
feel of how they are managing Cloud

00:25:44,149 --> 00:25:50,179
Foundry for the same for Apogee edge in

00:25:47,980 --> 00:25:52,399
closing can you

00:25:50,179 --> 00:25:56,179
come up that's just wrap up the key

00:25:52,399 --> 00:25:58,669
takeaways so just to wrap up the first

00:25:56,179 --> 00:26:01,309
point I made about architecture going

00:25:58,669 --> 00:26:03,320
from monolith to microservice not all

00:26:01,309 --> 00:26:05,299
architectures or monoliths if you do

00:26:03,320 --> 00:26:06,919
have a monolith with a simplistic domain

00:26:05,299 --> 00:26:09,259
it makes a lot of sense to split it up

00:26:06,919 --> 00:26:11,629
but if you're a large company and you

00:26:09,259 --> 00:26:13,820
have services all over the place maybe

00:26:11,629 --> 00:26:14,929
300 plus services some of which you

00:26:13,820 --> 00:26:17,389
don't even know what they do anymore

00:26:14,929 --> 00:26:20,059
this is a very valuable pattern to use

00:26:17,389 --> 00:26:22,070
it the Strangler pattern to over time

00:26:20,059 --> 00:26:24,320
move that data away from that legacy

00:26:22,070 --> 00:26:26,360
system and using an api gateway cache

00:26:24,320 --> 00:26:28,429
pattern you can move that out of that

00:26:26,360 --> 00:26:30,289
system and put it into your micro

00:26:28,429 --> 00:26:32,119
services yeah for the last couple of

00:26:30,289 --> 00:26:34,519
ones real quick right APA and micro

00:26:32,119 --> 00:26:36,970
service is a super complementary and you

00:26:34,519 --> 00:26:39,440
know as you start to modernize your apps

00:26:36,970 --> 00:26:40,879
remember the way to access your micro

00:26:39,440 --> 00:26:44,169
sources is through a very established

00:26:40,879 --> 00:26:46,639
contract which is nothing but an API and

00:26:44,169 --> 00:26:48,409
as you have seen in some of the examples

00:26:46,639 --> 00:26:50,029
we have covered many customers are doing

00:26:48,409 --> 00:26:52,220
that today's for you the API amendment

00:26:50,029 --> 00:26:54,080
or the strategy as we modernize the apps

00:26:52,220 --> 00:26:56,119
as the transition to micro sources is

00:26:54,080 --> 00:26:58,220
going to make it easy to kinda realize

00:26:56,119 --> 00:27:00,350
the benefits of app modernization so

00:26:58,220 --> 00:27:02,450
thanks for attending this session and

00:27:00,350 --> 00:27:06,289
we'll be around for a few questions I

00:27:02,450 --> 00:27:08,090
think we have about about 5 or 5 min if

00:27:06,289 --> 00:27:09,919
you do want to ask a question now in

00:27:08,090 --> 00:27:11,720
front of everyone there's the microphone

00:27:09,919 --> 00:27:13,759
up here I was told that they're not

00:27:11,720 --> 00:27:17,350
running it anymore so we'll be kind and

00:27:13,759 --> 00:27:18,830
maybe you run it is there any questions

00:27:17,350 --> 00:27:21,350
ok wonderful

00:27:18,830 --> 00:27:22,789
so we'll be taking questions up here if

00:27:21,350 --> 00:27:24,919
you are interested in any of that

00:27:22,789 --> 00:27:26,600
content we just talked about so thank

00:27:24,919 --> 00:27:27,040
you very much have a great rest of your

00:27:26,600 --> 00:27:30,109
conference

00:27:27,040 --> 00:27:30,109

YouTube URL: https://www.youtube.com/watch?v=P8tPxw4UDAM


