Title: On-Demand Data Services with Cloud Foundry - Maria Ntalla & Simon Jones, Pivotal
Publication date: 2017-10-18
Playlist: Cloud Foundry Summit Europe 2017
Description: 
	On-Demand Data Services with Cloud Foundry - Maria Ntalla & Simon Jones, Pivotal

Cloud Foundry services are a big part of what makes the platform so incredibly powerful; they allow developers to perform self-service provisioning of databases, message queues and anything else that can provide data to their applications. 

The ability to create services entirely on demand was one of Cloud Foundry’s most anticipated features. When the feature was added to Cloud Foundry, an exciting new era began for service authors and users alike. 

In this talk Maria and Simon will show how BOSH and the on-demand-broker are used to enable application developers to do self-service provision of services with configuration tailored to the application’s use case. They will also give an overview of how to develop an on-demand service, best practices and challenges they have seen during their experience with developing on demand service offerings.

About Simon Jones
Simon works as technical lead for the team that develops Pivotal's On Demand Service Broker. He has previously been a service author for Redis, Cassandra and RabbitMQ, and has a wealth of experience in deploying platforms and services with Cloud Foundry operators from a number of large companies. Simon has previously spoken at local PaaS user group meetups, and provided training to new Cloud Foundry users.

About Maria Ntalla
Maria is a software engineer at Pivotal. She was on the team that developed the on-demand service broker and SDK and is now developing the Redis service broker for Cloud Foundry. She has previously spoken at Cloud Foundry Summit Europe 2016, London PaaS Users Group and Women Who Go sessions.
Captions: 
	00:00:00,000 --> 00:00:05,040
I'm hi hi everybody good afternoon and

00:00:02,520 --> 00:00:08,910
welcome to on demand data services with

00:00:05,040 --> 00:00:11,099
Cloud Foundry quick introductions my

00:00:08,910 --> 00:00:12,929
name is Maria and I am a developer for

00:00:11,099 --> 00:00:17,699
the cloud foundry ride his team in

00:00:12,929 --> 00:00:20,430
pivotal London a good evening I'm Simon

00:00:17,699 --> 00:00:22,710
Jones I'm a developer inhibitor London

00:00:20,430 --> 00:00:28,439
and I work on the on demand service

00:00:22,710 --> 00:00:44,040
broker team alright so over the course

00:00:28,439 --> 00:00:46,170
of the next over the next 30 minutes we

00:00:44,040 --> 00:00:48,329
are going to have a quick refresher on

00:00:46,170 --> 00:00:51,420
what cloud foundry services do for us

00:00:48,329 --> 00:00:53,160
and how Bosh fits into the equation will

00:00:51,420 --> 00:00:55,350
then look at the traditional approach

00:00:53,160 --> 00:00:58,770
that we've generally followed so far to

00:00:55,350 --> 00:01:00,510
deploy cloud foundry services move on to

00:00:58,770 --> 00:01:02,100
the path for on-demand provisioning and

00:01:00,510 --> 00:01:03,899
finally we're going to look at how we

00:01:02,100 --> 00:01:08,159
would go about developing an on-demand

00:01:03,899 --> 00:01:10,890
service broker cloud foundry services

00:01:08,159 --> 00:01:12,720
are a very important part of what the

00:01:10,890 --> 00:01:15,390
platform offers to application

00:01:12,720 --> 00:01:17,549
developers just by pushing an

00:01:15,390 --> 00:01:19,860
application with CF push I have really

00:01:17,549 --> 00:01:21,630
no way of storing state or even sharing

00:01:19,860 --> 00:01:22,439
data and sharing state with other

00:01:21,630 --> 00:01:26,479
applications

00:01:22,439 --> 00:01:29,939
that's where services come in so we can

00:01:26,479 --> 00:01:32,579
discover available services using the

00:01:29,939 --> 00:01:34,530
Cloud Foundry marketplace and there's a

00:01:32,579 --> 00:01:37,009
wide range range of services available

00:01:34,530 --> 00:01:39,240
so for example data stores databases

00:01:37,009 --> 00:01:43,740
caches message queues or even user

00:01:39,240 --> 00:01:45,270
accounts for external services once

00:01:43,740 --> 00:01:46,740
we've picked our favorite service we can

00:01:45,270 --> 00:01:50,369
go ahead and create an instance of it

00:01:46,740 --> 00:01:51,810
with CF create service we can then bind

00:01:50,369 --> 00:01:56,579
our application so that the application

00:01:51,810 --> 00:01:59,040
can start using it with CF mind if we

00:01:56,579 --> 00:02:00,659
ever want to change properties or move

00:01:59,040 --> 00:02:02,460
our service instance to use a new plan

00:02:00,659 --> 00:02:05,909
with new configuration we can do so with

00:02:02,460 --> 00:02:07,469
CF update service and finally we when

00:02:05,909 --> 00:02:07,880
the application no longer needs a

00:02:07,469 --> 00:02:10,429
service

00:02:07,880 --> 00:02:11,900
it can see if unbind itself and then we

00:02:10,429 --> 00:02:17,780
can go ahead and see after leave the

00:02:11,900 --> 00:02:21,200
service an approach that service authors

00:02:17,780 --> 00:02:23,540
have followed so far to implement the

00:02:21,200 --> 00:02:26,239
workflow that we just saw has been that

00:02:23,540 --> 00:02:27,680
of pre provisioned instances and in that

00:02:26,239 --> 00:02:30,140
world Bosch would come in it would

00:02:27,680 --> 00:02:32,720
deploy deploy Cloud Foundry but it would

00:02:30,140 --> 00:02:35,360
also deploy the service program and pre

00:02:32,720 --> 00:02:37,489
decided and pre declared by the operator

00:02:35,360 --> 00:02:40,340
number of service instances and they

00:02:37,489 --> 00:02:42,049
would form a sort of pool if you want of

00:02:40,340 --> 00:02:44,780
available instances that would just hung

00:02:42,049 --> 00:02:48,769
around there until they see a fuser

00:02:44,780 --> 00:02:50,630
needs one so then when an application

00:02:48,769 --> 00:02:52,730
developer would need a my sequel

00:02:50,630 --> 00:02:55,280
instance for example they would type CF

00:02:52,730 --> 00:02:57,049
create service then the cloud controller

00:02:55,280 --> 00:02:58,970
would forward that request to the

00:02:57,049 --> 00:03:00,620
service broker the service broker would

00:02:58,970 --> 00:03:02,690
go away figure out if it has an

00:03:00,620 --> 00:03:05,540
available instance in its pol reserve it

00:03:02,690 --> 00:03:08,269
and return success or failure to Cloud

00:03:05,540 --> 00:03:11,810
Foundry there are some advantages to

00:03:08,269 --> 00:03:13,940
that approach mainly the the cost is

00:03:11,810 --> 00:03:15,650
fixed so we know in advance how many VMs

00:03:13,940 --> 00:03:18,170
were provisioning what sort of sizes so

00:03:15,650 --> 00:03:19,940
we know kind of what Bill will be paying

00:03:18,170 --> 00:03:21,319
and also the provisioning times that

00:03:19,940 --> 00:03:23,329
aren't quite quick because there is no

00:03:21,319 --> 00:03:26,389
VMs to spin up at that point and no

00:03:23,329 --> 00:03:28,700
software to deploy however pre provision

00:03:26,389 --> 00:03:31,180
instances cost money really doing

00:03:28,700 --> 00:03:33,530
nothing until they're actually claimed

00:03:31,180 --> 00:03:35,780
they're not configurable so they're all

00:03:33,530 --> 00:03:37,400
exactly the same it's hard to scale them

00:03:35,780 --> 00:03:38,989
up because it means that you have to

00:03:37,400 --> 00:03:42,260
redeploy the whole ecosystem of the

00:03:38,989 --> 00:03:46,420
broker and the pool and finally it's

00:03:42,260 --> 00:03:46,420
near impossible to scale down safely

00:03:48,420 --> 00:03:53,850
so we think there might be a better way

00:03:50,130 --> 00:03:55,430
to achieve these goals and we think this

00:03:53,850 --> 00:03:58,440
contact we've called on-demand

00:03:55,430 --> 00:04:00,020
provisioning could help with that so

00:03:58,440 --> 00:04:04,170
this means that the application

00:04:00,020 --> 00:04:07,230
developer through the CFC Li create and

00:04:04,170 --> 00:04:10,950
delete service actions would actually

00:04:07,230 --> 00:04:13,650
cause a deployment a provision to happen

00:04:10,950 --> 00:04:15,300
and then that service gets deleted so

00:04:13,650 --> 00:04:17,880
this really helps with our resource

00:04:15,300 --> 00:04:19,859
consumption because we know that until

00:04:17,880 --> 00:04:21,090
the application developer needs to make

00:04:19,859 --> 00:04:23,790
use of that service

00:04:21,090 --> 00:04:25,500
there is nothing are being consumed and

00:04:23,790 --> 00:04:27,660
as soon as the application developer is

00:04:25,500 --> 00:04:29,370
finished with the service again there is

00:04:27,660 --> 00:04:31,730
nothing being consumed so we don't have

00:04:29,370 --> 00:04:34,850
anything lying around waiting to be used

00:04:31,730 --> 00:04:38,240
we can also provide operator freedom

00:04:34,850 --> 00:04:41,790
using on-demand provisioning the

00:04:38,240 --> 00:04:44,520
operators can define plans and quotas so

00:04:41,790 --> 00:04:46,860
that different types of your service can

00:04:44,520 --> 00:04:48,870
be can be created and used by your

00:04:46,860 --> 00:04:50,790
application developer depending on their

00:04:48,870 --> 00:04:53,400
needs we've also got the application

00:04:50,790 --> 00:04:56,210
developer freedom as they can consume

00:04:53,400 --> 00:04:58,680
those different plans they can also

00:04:56,210 --> 00:05:01,830
depending on what's being permitted by

00:04:58,680 --> 00:05:04,290
the service or through an operator take

00:05:01,830 --> 00:05:06,630
further configuration steps and these

00:05:04,290 --> 00:05:08,580
all have to be pre-approved so the

00:05:06,630 --> 00:05:11,580
operator can be safe in the knowledge of

00:05:08,580 --> 00:05:15,450
what's happening so so what does this

00:05:11,580 --> 00:05:17,400
look like well the service broker has to

00:05:15,450 --> 00:05:21,120
ultimately take responsibility for

00:05:17,400 --> 00:05:23,729
deploying and managing the life cycle of

00:05:21,120 --> 00:05:26,130
service instances so your broker now

00:05:23,729 --> 00:05:28,410
needs to deploy update and delete

00:05:26,130 --> 00:05:33,360
services as a request from Cloud Foundry

00:05:28,410 --> 00:05:35,940
come in and you probably want to use a

00:05:33,360 --> 00:05:37,830
deployment manager and integrate a

00:05:35,940 --> 00:05:41,520
deployment manager with your service

00:05:37,830 --> 00:05:44,970
broker so what a Cloud Foundry have to

00:05:41,520 --> 00:05:46,650
do to enable this new workflow where

00:05:44,970 --> 00:05:49,470
we're actually going out on provisioning

00:05:46,650 --> 00:05:53,669
well Cloud Foundry implements the open

00:05:49,470 --> 00:05:55,610
service broker API already and not a lot

00:05:53,669 --> 00:05:59,240
really needed to change with this the

00:05:55,610 --> 00:06:01,130
the endpoints already existed to

00:05:59,240 --> 00:06:03,860
lifecycle of a service of course as we

00:06:01,130 --> 00:06:06,319
saw but what was it was missing was

00:06:03,860 --> 00:06:09,349
asynchronous operations so he previously

00:06:06,319 --> 00:06:13,160
had a default timeout of 30 seconds for

00:06:09,349 --> 00:06:16,400
calling the create service command and

00:06:13,160 --> 00:06:18,410
that's a little bit too short for a lot

00:06:16,400 --> 00:06:20,289
of services to go off and actually

00:06:18,410 --> 00:06:24,770
deploy it takes a little bit longer so

00:06:20,289 --> 00:06:27,050
the the state changing operations like

00:06:24,770 --> 00:06:28,460
provision updates and D provision can

00:06:27,050 --> 00:06:30,590
now be called asynchronously

00:06:28,460 --> 00:06:33,409
and we have a last operation endpoint to

00:06:30,590 --> 00:06:35,419
go and ask about the state of that so

00:06:33,409 --> 00:06:37,909
you might see services in the state of

00:06:35,419 --> 00:06:41,120
creating progress or delete in progress

00:06:37,909 --> 00:06:42,860
rather than created or delete or not

00:06:41,120 --> 00:06:45,440
there ahem

00:06:42,860 --> 00:06:48,440
so that's actually everything that you

00:06:45,440 --> 00:06:51,620
would need to create an on-demand

00:06:48,440 --> 00:06:56,479
service broker or an on-demand service

00:06:51,620 --> 00:06:58,190
so are we done well we think we can

00:06:56,479 --> 00:07:01,159
probably provide something a little bit

00:06:58,190 --> 00:07:03,259
better in the way of tooling everyone

00:07:01,159 --> 00:07:07,099
going out and implementing their own

00:07:03,259 --> 00:07:11,000
version of deploying software would lead

00:07:07,099 --> 00:07:13,280
to a lot of duplicated effort so in

00:07:11,000 --> 00:07:15,380
steps the on demand service broker this

00:07:13,280 --> 00:07:18,229
is an open source release that pivitol

00:07:15,380 --> 00:07:20,979
have developed this is a web server that

00:07:18,229 --> 00:07:24,349
implements the open service broker API

00:07:20,979 --> 00:07:27,380
so Cloud Foundry can can communicate

00:07:24,349 --> 00:07:30,169
with it it receives a request from Cloud

00:07:27,380 --> 00:07:32,630
Foundry and it makes requests to bosh

00:07:30,169 --> 00:07:35,389
which is our deployment manager of

00:07:32,630 --> 00:07:37,969
choice and we'll take a closer look at

00:07:35,389 --> 00:07:41,780
boshy in a second and the on-demand

00:07:37,969 --> 00:07:43,940
broker takes all of the generic steps

00:07:41,780 --> 00:07:46,039
that are involved in making a bosh

00:07:43,940 --> 00:07:50,090
deployment updating that bosh deployment

00:07:46,039 --> 00:07:51,860
binding on binding to that but it

00:07:50,090 --> 00:07:54,139
doesn't it can't know everything so we

00:07:51,860 --> 00:07:55,909
want to be able to use this broker to

00:07:54,139 --> 00:07:59,479
deploy as many different types of

00:07:55,909 --> 00:08:01,490
services as possible so we need

00:07:59,479 --> 00:08:04,190
something with that service specific

00:08:01,490 --> 00:08:05,930
knowledge so what we would want service

00:08:04,190 --> 00:08:07,820
authors to create is

00:08:05,930 --> 00:08:10,910
this thing called a service adapter and

00:08:07,820 --> 00:08:13,250
that ultimately can create manifests for

00:08:10,910 --> 00:08:16,460
ourselves for our on-demand broker to

00:08:13,250 --> 00:08:19,880
deploy the service instances and it will

00:08:16,460 --> 00:08:22,759
manage the bind and unbinding as each

00:08:19,880 --> 00:08:26,240
service has a different concept of what

00:08:22,759 --> 00:08:28,250
an account might look like so this is

00:08:26,240 --> 00:08:30,199
available as a Bosch release and as I

00:08:28,250 --> 00:08:31,970
mentioned it's open source the URL is

00:08:30,199 --> 00:08:35,330
here and we'll include that in the

00:08:31,970 --> 00:08:36,800
resources at the end so just to take a

00:08:35,330 --> 00:08:38,810
step back we've mentioned that we're

00:08:36,800 --> 00:08:39,979
going to use Bosch as our deployment

00:08:38,810 --> 00:08:42,169
manager of choice

00:08:39,979 --> 00:08:45,770
Bosh's currently used to deploy Cloud

00:08:42,169 --> 00:08:48,170
Foundry and a lot of the free pre

00:08:45,770 --> 00:08:51,140
provisioned instance services so this

00:08:48,170 --> 00:08:53,330
may turn such a pivotal so there should

00:08:51,140 --> 00:08:57,140
be familiarity hopefully within within

00:08:53,330 --> 00:09:00,470
the community but just to redefine that

00:08:57,140 --> 00:09:02,930
so it manages a distributed software

00:09:00,470 --> 00:09:05,300
lifecycle and it covers the packaging

00:09:02,930 --> 00:09:08,570
and deploying running and upgrading of

00:09:05,300 --> 00:09:11,779
software and it actually manages the

00:09:08,570 --> 00:09:14,089
deployments using a declarative manifest

00:09:11,779 --> 00:09:15,529
so you define what the desired state

00:09:14,089 --> 00:09:18,709
that you want your deployment to look

00:09:15,529 --> 00:09:21,070
like is for example how many VMs and

00:09:18,709 --> 00:09:23,779
what type of VM you want to deploy to

00:09:21,070 --> 00:09:28,520
and Bosch will go and converge to that

00:09:23,779 --> 00:09:30,800
state so we did have to make a few

00:09:28,520 --> 00:09:33,050
changes or we all we had some some Bosch

00:09:30,800 --> 00:09:37,870
features added which were very useful

00:09:33,050 --> 00:09:40,190
for the on-demand service life cycle and

00:09:37,870 --> 00:09:43,220
a lot of this was to do with how

00:09:40,190 --> 00:09:45,650
deployment manifests used to look so we

00:09:43,220 --> 00:09:47,810
would include networking subnets and

00:09:45,650 --> 00:09:50,120
Static ip's directly in the deployment

00:09:47,810 --> 00:09:54,170
manifests we'd include a lot of

00:09:50,120 --> 00:09:56,329
infrastructure detail in in every single

00:09:54,170 --> 00:09:58,730
deployment manifest and this became

00:09:56,329 --> 00:10:02,839
quite complicated in order for humans to

00:09:58,730 --> 00:10:05,060
start to be deploying Bosch deployments

00:10:02,839 --> 00:10:08,420
we came up with tools like spiff and

00:10:05,060 --> 00:10:11,060
spruce to try and help sell and it

00:10:08,420 --> 00:10:13,010
becomes even more automated it comes

00:10:11,060 --> 00:10:15,290
even more complicated with automation

00:10:13,010 --> 00:10:17,680
where we're trying to figure out which

00:10:15,290 --> 00:10:20,890
IP ranges are going to be available from

00:10:17,680 --> 00:10:24,120
service instance becomes very difficult

00:10:20,890 --> 00:10:26,860
so this logic has been moved to the

00:10:24,120 --> 00:10:29,920
centralized in the Bosch director so we

00:10:26,860 --> 00:10:32,890
now provide a cloud config and we have a

00:10:29,920 --> 00:10:36,540
dynamic IP allocation so the cloud

00:10:32,890 --> 00:10:41,770
config contains the knowledge of what

00:10:36,540 --> 00:10:43,589
VMs and networks look like and each of

00:10:41,770 --> 00:10:45,730
the deployments can make use of

00:10:43,589 --> 00:10:47,279
references in the cloud config but they

00:10:45,730 --> 00:10:52,959
don't need to know about those things

00:10:47,279 --> 00:10:55,779
themselves we also added Bosch teams to

00:10:52,959 --> 00:10:57,760
- Bosch and the reason for this is that

00:10:55,779 --> 00:11:00,220
a broker needs to use something with

00:10:57,760 --> 00:11:02,890
admin like permissions in order to

00:11:00,220 --> 00:11:06,250
create and delete service instance

00:11:02,890 --> 00:11:08,790
deployments but we only want them to be

00:11:06,250 --> 00:11:11,770
able to do that for their own

00:11:08,790 --> 00:11:14,170
deployments so we don't want rogue

00:11:11,770 --> 00:11:15,670
service brokers to go deleting your

00:11:14,170 --> 00:11:19,450
Cloud Foundry or anything like this

00:11:15,670 --> 00:11:26,740
it also allows multiple service brokers

00:11:19,450 --> 00:11:29,050
to exist harmoniously all right so the

00:11:26,740 --> 00:11:31,390
another way the an on-demand broker is

00:11:29,050 --> 00:11:33,580
operated is important to service authors

00:11:31,390 --> 00:11:36,520
because the input that an operator might

00:11:33,580 --> 00:11:38,680
give needs to be considered when we go

00:11:36,520 --> 00:11:41,920
ahead and offer our service adapter so

00:11:38,680 --> 00:11:43,420
we're gonna have a quick look at that so

00:11:41,920 --> 00:11:45,670
when an operator deploys an on-demand

00:11:43,420 --> 00:11:48,670
broker they will write a Bosch manifest

00:11:45,670 --> 00:11:50,080
just as they used to nothing you hear in

00:11:48,670 --> 00:11:52,420
that manifest they will specify things

00:11:50,080 --> 00:11:54,040
like for example where the body directly

00:11:52,420 --> 00:11:55,540
lives that they want to talk to where

00:11:54,040 --> 00:11:57,640
does the cloud internal live that they

00:11:55,540 --> 00:12:00,040
want to talk to and so on but they will

00:11:57,640 --> 00:12:01,990
also define the catalog for the broker

00:12:00,040 --> 00:12:03,790
which includes how the service offering

00:12:01,990 --> 00:12:05,320
will show up in the marketplace and also

00:12:03,790 --> 00:12:08,079
what plants will configured and what

00:12:05,320 --> 00:12:10,300
quarters are applied okay let's have a

00:12:08,079 --> 00:12:11,440
closer look at plants so these are

00:12:10,300 --> 00:12:14,589
operator defined

00:12:11,440 --> 00:12:17,980
they include size so V M size disc size

00:12:14,589 --> 00:12:20,110
and configuration options and they will

00:12:17,980 --> 00:12:22,360
be provided as input to the service

00:12:20,110 --> 00:12:26,010
adapter for the manifest generation

00:12:22,360 --> 00:12:26,010
which we will look at shortly

00:12:26,020 --> 00:12:31,360
quarters are also operator defined they

00:12:28,660 --> 00:12:33,070
can be applied per plan and they can

00:12:31,360 --> 00:12:35,470
also be applied on the service offering

00:12:33,070 --> 00:12:37,480
globally they're there to help the

00:12:35,470 --> 00:12:39,430
operator manage service usage so they

00:12:37,480 --> 00:12:42,670
don't end up with way more instances

00:12:39,430 --> 00:12:44,140
that they were anticipating our service

00:12:42,670 --> 00:12:45,700
offers we don't really need to worry

00:12:44,140 --> 00:12:48,040
about them they are enforced by the

00:12:45,700 --> 00:12:49,930
broker very be on-demand broker and the

00:12:48,040 --> 00:12:53,710
service adapter doesn't really need to

00:12:49,930 --> 00:12:56,770
do anything about them okay so let's

00:12:53,710 --> 00:12:58,320
move to how we would go about developing

00:12:56,770 --> 00:13:01,480
an on-demand broker

00:12:58,320 --> 00:13:03,790
there are basically two components that

00:13:01,480 --> 00:13:06,280
record Larry require to make a service

00:13:03,790 --> 00:13:08,140
use the only month broker first of all

00:13:06,280 --> 00:13:10,210
you need your service packaged as a

00:13:08,140 --> 00:13:12,640
bas-reliefs or a set of bas releases and

00:13:10,210 --> 00:13:14,380
secondly you need an adapter so that's

00:13:12,640 --> 00:13:16,690
an executable which is also packaged as

00:13:14,380 --> 00:13:21,370
a bas-reliefs and we'll look at both of

00:13:16,690 --> 00:13:23,290
them just now the service release first

00:13:21,370 --> 00:13:25,210
of all so we saw just before that the

00:13:23,290 --> 00:13:28,270
broker must be able to instruct the boss

00:13:25,210 --> 00:13:30,520
on what it is that it wants deployed in

00:13:28,270 --> 00:13:32,620
the format of the bosch manifest that

00:13:30,520 --> 00:13:35,650
manifest will describe the topology and

00:13:32,620 --> 00:13:37,420
also the software or release in bas

00:13:35,650 --> 00:13:40,000
terms that we want deployed on each

00:13:37,420 --> 00:13:43,120
component of that topology so the first

00:13:40,000 --> 00:13:44,830
step of authoring an on-demand service

00:13:43,120 --> 00:13:46,620
broker is creating that service release

00:13:44,830 --> 00:13:50,339
that release will encapsulate your

00:13:46,620 --> 00:13:54,460
service it is deployable by Bosch and

00:13:50,339 --> 00:13:56,470
the main consideration here is what are

00:13:54,460 --> 00:13:58,510
the configuration options that we want

00:13:56,470 --> 00:14:00,040
to open up to either the operators or

00:13:58,510 --> 00:14:01,720
the application developers and then to

00:14:00,040 --> 00:14:04,660
ensure that these options that we want

00:14:01,720 --> 00:14:09,400
to expose make it into the spec file or

00:14:04,660 --> 00:14:11,080
the spec files of that release okay so

00:14:09,400 --> 00:14:15,160
moving on to developing the service

00:14:11,080 --> 00:14:16,810
adapter we saw previously but this is an

00:14:15,160 --> 00:14:19,390
executable that lives right next to the

00:14:16,810 --> 00:14:22,450
on-demand broker and adds service

00:14:19,390 --> 00:14:24,220
specific knowledge to the mix let's have

00:14:22,450 --> 00:14:26,440
a look at how it fits into the larger

00:14:24,220 --> 00:14:28,390
image of a service a cloud foundry

00:14:26,440 --> 00:14:31,000
service instances lifecycle so when an

00:14:28,390 --> 00:14:33,100
application developer goes ahead and

00:14:31,000 --> 00:14:35,170
type co-create service the cloud

00:14:33,100 --> 00:14:36,259
controller wear it without request and

00:14:35,170 --> 00:14:38,169
we'll send it over

00:14:36,259 --> 00:14:41,329
to this on-demand service broker that

00:14:38,169 --> 00:14:43,309
request includes two pieces of

00:14:41,329 --> 00:14:45,350
interesting information the first one is

00:14:43,309 --> 00:14:46,579
the plan that application developer

00:14:45,350 --> 00:14:48,709
chose and remember the plans are

00:14:46,579 --> 00:14:50,540
configured by operators so they contain

00:14:48,709 --> 00:14:53,149
some configuration there

00:14:50,540 --> 00:14:54,709
secondly the request will pass on any

00:14:53,149 --> 00:14:56,389
arbitrary parameters that the

00:14:54,709 --> 00:14:59,389
application developer may have passed

00:14:56,389 --> 00:15:02,059
with attached see flag the adapter

00:14:59,389 --> 00:15:03,529
executable is then expected to use the

00:15:02,059 --> 00:15:05,359
plan configuration and the arbitrary

00:15:03,529 --> 00:15:08,059
parameters and combine them to generate

00:15:05,359 --> 00:15:09,439
a Bosch manifest the undermount broker

00:15:08,059 --> 00:15:10,970
then we'll give that manifest to poach

00:15:09,439 --> 00:15:12,949
and both will go ahead and deploy the

00:15:10,970 --> 00:15:16,189
service instance we have a very similar

00:15:12,949 --> 00:15:18,139
workflow with CF update again the

00:15:16,189 --> 00:15:19,339
undermount broker we get well first of

00:15:18,139 --> 00:15:22,009
all the unbound worker will get the

00:15:19,339 --> 00:15:23,449
current manifest from boss and then

00:15:22,009 --> 00:15:25,399
we'll give it to the adapter together

00:15:23,449 --> 00:15:29,269
with the new plant configuration and the

00:15:25,399 --> 00:15:31,129
new arbitrary parameters the adapter

00:15:29,269 --> 00:15:33,199
will then do what it needs to do to

00:15:31,129 --> 00:15:34,789
combine those into an updated manifest

00:15:33,199 --> 00:15:38,059
that gets given to boss and gets

00:15:34,789 --> 00:15:39,889
deployed as an updated instance it's in

00:15:38,059 --> 00:15:42,169
the adapters logic in it's in the

00:15:39,889 --> 00:15:44,419
doctors hand to decide the priority of

00:15:42,169 --> 00:15:46,129
existing versus new configuration so a

00:15:44,419 --> 00:15:48,139
lot of the time you might want to apply

00:15:46,129 --> 00:15:50,389
the new configuration other times you

00:15:48,139 --> 00:15:57,109
want to ignore it and just keep what you

00:15:50,389 --> 00:15:59,089
had in the original instance and so

00:15:57,109 --> 00:16:01,100
we're gonna actually have a quick

00:15:59,089 --> 00:16:03,799
overview of how we think some of that

00:16:01,100 --> 00:16:05,569
might logic might look within in our

00:16:03,799 --> 00:16:08,269
service adapters when we are generating

00:16:05,569 --> 00:16:09,949
the manifests so first of all we'll take

00:16:08,269 --> 00:16:11,509
a look at the arguments that we're going

00:16:09,949 --> 00:16:13,639
to provide and these should hopefully

00:16:11,509 --> 00:16:15,169
contain all of the details that an

00:16:13,639 --> 00:16:18,230
adapter is going to need to create a

00:16:15,169 --> 00:16:21,679
manifest in any given situation so the

00:16:18,230 --> 00:16:23,509
command is generate manifest we're

00:16:21,679 --> 00:16:26,179
passing in the the service deployment

00:16:23,509 --> 00:16:28,549
block which includes a list of the

00:16:26,179 --> 00:16:30,619
releases and stem cells along with the

00:16:28,549 --> 00:16:34,339
versions of those that we're expecting

00:16:30,619 --> 00:16:37,639
to use in in our deployment we're going

00:16:34,339 --> 00:16:40,669
to pass in the plan so this is defined

00:16:37,639 --> 00:16:43,459
by the operator but a schema would be

00:16:40,669 --> 00:16:45,199
defined by the service author so you

00:16:43,459 --> 00:16:47,029
know what sort of things you're going to

00:16:45,199 --> 00:16:47,430
expect to receive in this JSON but you

00:16:47,029 --> 00:16:49,920
don't know

00:16:47,430 --> 00:16:51,870
exactly what the details are and this

00:16:49,920 --> 00:16:54,000
will be things like the service plan and

00:16:51,870 --> 00:16:56,370
might describe what instance types are

00:16:54,000 --> 00:16:59,160
going to be used in your manifest how

00:16:56,370 --> 00:17:01,620
many of them and also what properties

00:16:59,160 --> 00:17:03,949
you want to include in your manifest for

00:17:01,620 --> 00:17:06,420
this particular plan and what values

00:17:03,949 --> 00:17:08,220
we're also going to receive the request

00:17:06,420 --> 00:17:10,980
parameters these are arbitrary

00:17:08,220 --> 00:17:13,709
parameters that are defined on the CFC

00:17:10,980 --> 00:17:17,160
Li by the application developer now

00:17:13,709 --> 00:17:18,929
again the the schema for this should be

00:17:17,160 --> 00:17:21,809
defined by the service author so you

00:17:18,929 --> 00:17:24,150
should know what sort of parameters you

00:17:21,809 --> 00:17:26,160
want to expect and what are sensible

00:17:24,150 --> 00:17:28,530
values for those and you can of course

00:17:26,160 --> 00:17:32,910
ignore arbitrary parameters that you

00:17:28,530 --> 00:17:35,280
weren't expecting to receive we've also

00:17:32,910 --> 00:17:37,950
got the previous manifest so the last

00:17:35,280 --> 00:17:40,910
two arguments are only provided in the

00:17:37,950 --> 00:17:44,340
case that you are performing an update

00:17:40,910 --> 00:17:46,080
so we get the existing configuration in

00:17:44,340 --> 00:17:49,410
the form of the currently deployed

00:17:46,080 --> 00:17:51,840
manifest and that allows us to work out

00:17:49,410 --> 00:17:54,360
what the deployment currently looks like

00:17:51,840 --> 00:17:56,460
and more specifically if someone has

00:17:54,360 --> 00:17:59,370
previously configured arbitrary

00:17:56,460 --> 00:18:02,510
parameters you may want to keep those in

00:17:59,370 --> 00:18:05,760
your in your current deployment and

00:18:02,510 --> 00:18:09,480
similarly with the plan this all plays

00:18:05,760 --> 00:18:11,610
into this slightly complicated bit of

00:18:09,480 --> 00:18:14,820
logic you might need to determine

00:18:11,610 --> 00:18:18,540
whether a parameter was set using an

00:18:14,820 --> 00:18:20,880
arbitrary parameter command or using the

00:18:18,540 --> 00:18:23,670
previous plan and whether that needs to

00:18:20,880 --> 00:18:27,900
be updated to the new plan and the

00:18:23,670 --> 00:18:30,630
adapter chooses the priority of that so

00:18:27,900 --> 00:18:33,360
it's important for the generate manifest

00:18:30,630 --> 00:18:36,210
command to always return a consistent

00:18:33,360 --> 00:18:37,890
response when given the same inputs it's

00:18:36,210 --> 00:18:39,840
not quite a pure function because

00:18:37,890 --> 00:18:42,270
depending how you implement it it might

00:18:39,840 --> 00:18:44,460
have some side effects but the output

00:18:42,270 --> 00:18:48,840
does have to be identical and that's

00:18:44,460 --> 00:18:52,750
used in comparison when we try to block

00:18:48,840 --> 00:18:55,300
incidental changes being made when

00:18:52,750 --> 00:18:57,520
application developer has asked for an

00:18:55,300 --> 00:19:00,910
update to be made and that might happen

00:18:57,520 --> 00:19:04,300
if the operator has updated the broker

00:19:00,910 --> 00:19:06,220
and included newer releases and we

00:19:04,300 --> 00:19:08,290
basically don't want too many things to

00:19:06,220 --> 00:19:12,100
be happening at the same time so we

00:19:08,290 --> 00:19:14,830
block the the developer triggered

00:19:12,100 --> 00:19:17,050
updates and it's up to the operator to

00:19:14,830 --> 00:19:21,400
trigger a platform upgrade to make sure

00:19:17,050 --> 00:19:24,040
everyone gets the new changes at once so

00:19:21,400 --> 00:19:27,370
this is a sort of not quite example a

00:19:24,040 --> 00:19:29,590
bit of pseudocode for what some logic

00:19:27,370 --> 00:19:31,270
might look for generating a manifest

00:19:29,590 --> 00:19:32,980
so first up you're going to create the

00:19:31,270 --> 00:19:35,650
skeleton you're then going to

00:19:32,980 --> 00:19:37,960
interpolate any previous manifest

00:19:35,650 --> 00:19:40,690
properties previous planned properties

00:19:37,960 --> 00:19:42,790
come after that and then finally you add

00:19:40,690 --> 00:19:45,610
you have the new planned properties any

00:19:42,790 --> 00:19:49,450
arbitrary parameters before you print

00:19:45,610 --> 00:19:52,660
the manifest in plain text to stand it

00:19:49,450 --> 00:19:54,940
out and hopefully you'll exit zero and

00:19:52,660 --> 00:20:00,630
the on tomorr broker will know that it's

00:19:54,940 --> 00:20:03,100
been a successful manifest generation so

00:20:00,630 --> 00:20:04,870
looking now at the CF bind service

00:20:03,100 --> 00:20:07,570
requests about how that translates into

00:20:04,870 --> 00:20:09,910
call star service adapter again pretty

00:20:07,570 --> 00:20:12,370
similarly the on demand broker will

00:20:09,910 --> 00:20:14,520
receive that request and forwarded on to

00:20:12,370 --> 00:20:17,230
the service adapter having also

00:20:14,520 --> 00:20:22,030
originally first of all requested the

00:20:17,230 --> 00:20:25,090
existing manifest from both the adapter

00:20:22,030 --> 00:20:27,370
method that is called is on the adapter

00:20:25,090 --> 00:20:29,550
is called create binding and a typical

00:20:27,370 --> 00:20:31,600
request to create binding will involve

00:20:29,550 --> 00:20:33,540
connecting for example to the

00:20:31,600 --> 00:20:35,650
provisioned instance and creating a user

00:20:33,540 --> 00:20:37,510
other services simply look at the

00:20:35,650 --> 00:20:43,300
manifest to get admin credentials and

00:20:37,510 --> 00:20:45,370
return those the binding ID is provided

00:20:43,300 --> 00:20:47,170
by the cloud controller and can be used

00:20:45,370 --> 00:20:50,020
as unique identifier for the binding

00:20:47,170 --> 00:20:53,620
being created this is quite handy also

00:20:50,020 --> 00:20:55,480
for the unbind service lifecycle because

00:20:53,620 --> 00:20:57,100
the adapter might have to go ahead and

00:20:55,480 --> 00:21:00,130
delete that user later so it's important

00:20:57,100 --> 00:21:01,990
to keep it as a mapping we required bas

00:21:00,130 --> 00:21:03,610
VMs is again a list of the VMS that make

00:21:01,990 --> 00:21:04,870
up the service instance they are

00:21:03,610 --> 00:21:07,090
important in the

00:21:04,870 --> 00:21:09,370
binding creation context in case the

00:21:07,090 --> 00:21:11,320
adapter needs to go and reach out to

00:21:09,370 --> 00:21:14,440
them and create users or create topics

00:21:11,320 --> 00:21:17,710
for example in the Kafka on-demand

00:21:14,440 --> 00:21:20,980
service the manifest camel is the

00:21:17,710 --> 00:21:22,690
existing deployed Bosch manifest some

00:21:20,980 --> 00:21:24,639
adapters use it to extract the admin

00:21:22,690 --> 00:21:25,990
credentials or other information that's

00:21:24,639 --> 00:21:30,159
unique to the already provisioned

00:21:25,990 --> 00:21:32,399
incidents and finally request parameters

00:21:30,159 --> 00:21:34,899
or arbitrary parameters passed by the

00:21:32,399 --> 00:21:40,240
application developer using the CF CLI

00:21:34,899 --> 00:21:42,249
and again they could be they're used for

00:21:40,240 --> 00:21:45,369
example in the Kafka service instance to

00:21:42,249 --> 00:21:48,639
create custom topics instead of having a

00:21:45,369 --> 00:21:52,629
topic named after the binding sorry yeah

00:21:48,639 --> 00:21:54,879
the binding ID many services will behave

00:21:52,629 --> 00:21:58,360
differently and it really depends on

00:21:54,879 --> 00:21:59,470
your specific adapter what exactly

00:21:58,360 --> 00:22:05,200
you're going to what subsets of these

00:21:59,470 --> 00:22:08,980
arguments you're going to use and then

00:22:05,200 --> 00:22:10,929
we come to unbind so when the developer

00:22:08,980 --> 00:22:13,440
has or the application has finished

00:22:10,929 --> 00:22:18,100
using a service they're gonna call

00:22:13,440 --> 00:22:21,850
unbind and it's a pretty similar order

00:22:18,100 --> 00:22:24,070
of events to bind and really it should

00:22:21,850 --> 00:22:26,649
be a mirror image so whatever you're

00:22:24,070 --> 00:22:29,259
going to do in bind you're you're likely

00:22:26,649 --> 00:22:32,259
to want to do in unbind but the reverse

00:22:29,259 --> 00:22:34,539
of it so you receive the same arguments

00:22:32,259 --> 00:22:37,269
that's that's obviously crucial because

00:22:34,539 --> 00:22:39,070
whatever you needed to connect to during

00:22:37,269 --> 00:22:42,100
your buying process you may also need to

00:22:39,070 --> 00:22:45,279
connect to joy and unbinding the binding

00:22:42,100 --> 00:22:47,799
ID is very useful as mentioned in

00:22:45,279 --> 00:22:49,600
uniquely identifying accounts so you

00:22:47,799 --> 00:22:52,360
should probably if you are creating a

00:22:49,600 --> 00:22:54,820
user account named it after the binding

00:22:52,360 --> 00:22:58,629
ID so that you can then delete it during

00:22:54,820 --> 00:23:01,119
and unbind so that's really it for

00:22:58,629 --> 00:23:04,029
deleting binding there is a fourth

00:23:01,119 --> 00:23:06,909
method that's expected of a service

00:23:04,029 --> 00:23:08,740
adapter it's called dashboard URL it

00:23:06,909 --> 00:23:10,480
uses a lot of the same themes but we're

00:23:08,740 --> 00:23:14,409
not going to cover that so that's

00:23:10,480 --> 00:23:16,210
available in the documentation so again

00:23:14,409 --> 00:23:16,600
this is this is sort of everything you

00:23:16,210 --> 00:23:18,730
need

00:23:16,600 --> 00:23:19,870
if you implement these four methods and

00:23:18,730 --> 00:23:24,130
then collocates

00:23:19,870 --> 00:23:26,970
on a release with the with the on-demand

00:23:24,130 --> 00:23:31,390
service broker you're gonna get a

00:23:26,970 --> 00:23:33,280
working on demand service hopefully but

00:23:31,390 --> 00:23:36,490
we again we think we can do a little bit

00:23:33,280 --> 00:23:38,980
better than this so your service authors

00:23:36,490 --> 00:23:41,200
as service authors you can choose any

00:23:38,980 --> 00:23:43,480
language which can respond as an

00:23:41,200 --> 00:23:46,360
executable to write your service adapter

00:23:43,480 --> 00:23:49,540
in but the favored language of the

00:23:46,360 --> 00:23:52,930
development team is golang and as such

00:23:49,540 --> 00:23:56,800
we've made an SDK available as available

00:23:52,930 --> 00:23:58,720
at this URL and that helps out with

00:23:56,800 --> 00:24:01,090
things like command line parsing which

00:23:58,720 --> 00:24:03,220
again is quite repetitive the response

00:24:01,090 --> 00:24:06,640
serialization a bit of error handling

00:24:03,220 --> 00:24:09,160
where and provides a really simple

00:24:06,640 --> 00:24:12,370
interface for service authors adapter

00:24:09,160 --> 00:24:15,790
authors just to fulfill that interface

00:24:12,370 --> 00:24:17,350
and that allows you to excuse me that

00:24:15,790 --> 00:24:19,890
allows you to concentrate on that

00:24:17,350 --> 00:24:23,430
service specific knowledge and really

00:24:19,890 --> 00:24:27,580
not care too much about how to manage

00:24:23,430 --> 00:24:29,620
command line parameters and this does

00:24:27,580 --> 00:24:33,280
leave us with one missing part of the

00:24:29,620 --> 00:24:35,410
lifecycle and that is a deletion of an

00:24:33,280 --> 00:24:37,540
on demand instance and we didn't mention

00:24:35,410 --> 00:24:39,250
that because the on demand broker

00:24:37,540 --> 00:24:42,040
actually has all of the information

00:24:39,250 --> 00:24:44,980
required to delete a service instance so

00:24:42,040 --> 00:24:47,290
you don't need to implement anything in

00:24:44,980 --> 00:24:53,470
your service adapter to fulfill this

00:24:47,290 --> 00:24:55,420
part of the lifecycle ok so to ensure

00:24:53,470 --> 00:24:57,310
that you get the first best feedback

00:24:55,420 --> 00:24:58,750
when developing and also to help improve

00:24:57,310 --> 00:25:01,210
the reliability of your on demand

00:24:58,750 --> 00:25:02,980
service that you've just developed we do

00:25:01,210 --> 00:25:04,690
very highly recommend that you test your

00:25:02,980 --> 00:25:06,760
components now there is really no right

00:25:04,690 --> 00:25:08,500
or wrong way of doing that also because

00:25:06,760 --> 00:25:11,530
it depends so much on the specific

00:25:08,500 --> 00:25:13,150
service that you're building but we've

00:25:11,530 --> 00:25:15,430
put together a couple of ideas to

00:25:13,150 --> 00:25:17,860
consider so as a minimum it would be a

00:25:15,430 --> 00:25:20,230
good idea to cover manifest generation

00:25:17,860 --> 00:25:24,800
binding unbinding and dashboard URL with

00:25:20,230 --> 00:25:27,050
tests against the service adapter

00:25:24,800 --> 00:25:29,180
they should generally test the

00:25:27,050 --> 00:25:31,190
executable call the various sub commands

00:25:29,180 --> 00:25:33,080
and make assertions on the exit code and

00:25:31,190 --> 00:25:35,510
also the contents of standard out and

00:25:33,080 --> 00:25:37,580
standard error so the any errors that

00:25:35,510 --> 00:25:40,460
come out and any produced manifests and

00:25:37,580 --> 00:25:43,880
bindings it's a good idea to cover

00:25:40,460 --> 00:25:47,450
updates as well as original manifest

00:25:43,880 --> 00:25:48,860
generation after that tests in the

00:25:47,450 --> 00:25:50,810
service release are really helpful

00:25:48,860 --> 00:25:52,910
because they validate the effect that

00:25:50,810 --> 00:25:54,290
configuration options have on the

00:25:52,910 --> 00:25:56,000
runtime configuration of the instance

00:25:54,290 --> 00:25:58,550
and once you've generated that manifest

00:25:56,000 --> 00:26:01,700
with your adapter how are you sure that

00:25:58,550 --> 00:26:03,080
the impact and the effect that they had

00:26:01,700 --> 00:26:06,500
in provisioning that instance is what

00:26:03,080 --> 00:26:10,760
you expected moving a level out on the

00:26:06,500 --> 00:26:13,040
dotted blue line that patel so you like

00:26:10,760 --> 00:26:18,050
a bunch of integration tests to test

00:26:13,040 --> 00:26:20,390
that your adapter communicates well with

00:26:18,050 --> 00:26:24,140
any external components so some examples

00:26:20,390 --> 00:26:26,270
are in on-demand service instances where

00:26:24,140 --> 00:26:28,280
bindings need to happen in collaboration

00:26:26,270 --> 00:26:32,210
with the service instance that's a very

00:26:28,280 --> 00:26:35,390
good place to test that finally it's

00:26:32,210 --> 00:26:37,850
good to test your deployed system with a

00:26:35,390 --> 00:26:42,950
set of lifecycle tests which is the sort

00:26:37,850 --> 00:26:45,500
of outer border here what we usually

00:26:42,950 --> 00:26:47,360
look at our end-to-end tests to validate

00:26:45,500 --> 00:26:49,370
the hobby path of an instance lifecycle

00:26:47,360 --> 00:26:51,800
so I create service of mind great some

00:26:49,370 --> 00:26:53,330
data so I write some data I read some

00:26:51,800 --> 00:26:56,060
data and bind and delete the service

00:26:53,330 --> 00:26:58,010
instance and ideally you'd like the

00:26:56,060 --> 00:26:59,720
customer to be able to run those smoke

00:26:58,010 --> 00:27:01,280
tests on their own installation to

00:26:59,720 --> 00:27:04,060
confirm that they have a successful

00:27:01,280 --> 00:27:04,060
configuration

00:27:06,730 --> 00:27:12,410
fantastic so now you really do have an

00:27:09,590 --> 00:27:15,320
on-demand service available so just to

00:27:12,410 --> 00:27:17,690
cover what we've looked at today we've

00:27:15,320 --> 00:27:20,150
got the concept of on-demand services as

00:27:17,690 --> 00:27:25,550
something that is application developer

00:27:20,150 --> 00:27:28,730
triggered from the CFC Li but controlled

00:27:25,550 --> 00:27:32,050
through plans and quotas by the by the

00:27:28,730 --> 00:27:34,520
operator and the service author we've

00:27:32,050 --> 00:27:36,950
introduced the on-demand service broker

00:27:34,520 --> 00:27:39,260
which is a tool packaged as a Bosch

00:27:36,950 --> 00:27:42,440
release which will manage the lifecycle

00:27:39,260 --> 00:27:45,230
of an on-demand service using Bosch as a

00:27:42,440 --> 00:27:47,330
deployment tool and then we've

00:27:45,230 --> 00:27:49,070
identified that your on-demand service

00:27:47,330 --> 00:27:52,400
whatever that may be whatever that may

00:27:49,070 --> 00:27:54,740
look like would consist of your service

00:27:52,400 --> 00:27:59,240
release combined with a service adapter

00:27:54,740 --> 00:28:01,310
that knows about your service release so

00:27:59,240 --> 00:28:05,150
we've got some resources up here some

00:28:01,310 --> 00:28:11,330
documentation some example adapter

00:28:05,150 --> 00:28:12,800
releases so I'll leave that up there so

00:28:11,330 --> 00:28:14,810
we can take some pictures but the next

00:28:12,800 --> 00:28:16,960
slide I assure you it does ask for

00:28:14,810 --> 00:28:16,960
questions

00:28:18,560 --> 00:28:24,419
[Music]

00:28:18,740 --> 00:28:27,629
[Applause]

00:28:24,419 --> 00:28:27,629
so do

00:28:34,820 --> 00:28:37,899
the CFC life

00:28:39,460 --> 00:28:47,090
yeah is it uses a command runner to run

00:28:43,790 --> 00:28:49,460
that as as though it would use as though

00:28:47,090 --> 00:28:56,830
you were Donner on a terminal or

00:28:49,460 --> 00:28:56,830
something yeah yes

00:29:03,260 --> 00:29:09,440
it's definitely being considered so in

00:29:07,250 --> 00:29:12,790
terms of the actual lifecycle we like we

00:29:09,440 --> 00:29:16,540
we like to sort of it is tested by the

00:29:12,790 --> 00:29:20,690
on Tamar broker team in pivotal so

00:29:16,540 --> 00:29:23,570
that's that whoa that would be good to

00:29:20,690 --> 00:29:26,059
add I think but how much we could

00:29:23,570 --> 00:29:29,600
abstract might be interesting

00:29:26,059 --> 00:29:32,000
I think we'd also like to do kind of

00:29:29,600 --> 00:29:35,030
configuration confirmation so that

00:29:32,000 --> 00:29:36,530
rather than testing by results so you

00:29:35,030 --> 00:29:37,970
know if you wanted to test the quotas

00:29:36,530 --> 00:29:39,920
were working you might have to go out

00:29:37,970 --> 00:29:43,280
and actually deploy too many service

00:29:39,920 --> 00:29:45,230
instances it might be nicer to for us to

00:29:43,280 --> 00:29:54,080
say this is what we think your

00:29:45,230 --> 00:29:55,850
configuration looks like anymore okay

00:29:54,080 --> 00:29:57,770
well thank you for joining us so late in

00:29:55,850 --> 00:30:03,150
the day

00:29:57,770 --> 00:30:03,150

YouTube URL: https://www.youtube.com/watch?v=j-65h9DzCHw


