Title: Distributed Tracing of Microservices - Neil Stevenson, Hazelcast
Publication date: 2017-10-18
Playlist: Cloud Foundry Summit Europe 2017
Description: 
	Distributed Tracing of Microservices - Neil Stevenson, Hazelcast

Microservices are generally perceived as a better application style than monolithic code, and
certainly this is a style that sits nicely within Cloud Foundry.

However, itâ€™s not all good news. One of the drawbacks to such decomposition is it can be
very difficult to identify bottlenecks.

In this presentation, Neil will show how itâ€™s easy this can solved for Spring Boot users. A few
beans and dependencies can activate tracing, and with Hazelcast as a service, trace information
can be centrally captured from to a fault-tolerant scalable in-memory repository.

Trace analysis can then be distributed across multiple service instances, without the performance bottleneck of a unclustered disk based resource.
Captions: 
	00:00:01,159 --> 00:00:10,230
good afternoon everyone let's see

00:00:05,220 --> 00:00:13,830
can you meet yep hi my name is Neal

00:00:10,230 --> 00:00:16,699
Stephenson I work at hazel cast and I

00:00:13,830 --> 00:00:19,800
have half an hour to tell you about

00:00:16,699 --> 00:00:23,609
distributed tracing of micro services I

00:00:19,800 --> 00:00:26,400
have about 20 slides and the demo which

00:00:23,609 --> 00:00:27,930
you can download after and I'll be

00:00:26,400 --> 00:00:30,960
around for questions if you don't want

00:00:27,930 --> 00:00:34,559
to go straight for lunch hopefully

00:00:30,960 --> 00:00:38,460
you've seen the talk outline on sheds so

00:00:34,559 --> 00:00:41,010
I'll skip past that what I want to talk

00:00:38,460 --> 00:00:45,090
about very briefly is what I mean by

00:00:41,010 --> 00:00:47,550
micro service then we'll go into a tool

00:00:45,090 --> 00:00:51,329
called Zipkin which is going to do the

00:00:47,550 --> 00:00:53,699
actual tracing for us I mention about

00:00:51,329 --> 00:01:00,059
what hazel cast as to this piece and

00:00:53,699 --> 00:01:03,539
then finally a demo so we all kind of

00:01:00,059 --> 00:01:05,339
have an idea of what micro services I've

00:01:03,539 --> 00:01:08,549
never met two people with the same idea

00:01:05,339 --> 00:01:12,210
so as far as I'm concerned our micro

00:01:08,549 --> 00:01:16,140
services just a a bit it might do a

00:01:12,210 --> 00:01:20,790
little it might do a lot mainly seems to

00:01:16,140 --> 00:01:24,439
be rest based from what I see rest and

00:01:20,790 --> 00:01:27,270
Jason has won the battle in terms of

00:01:24,439 --> 00:01:33,119
communication between services easy for

00:01:27,270 --> 00:01:35,729
humans to to test so my micro service

00:01:33,119 --> 00:01:38,189
today is based around the idea of credit

00:01:35,729 --> 00:01:41,130
cards we've all done things with credit

00:01:38,189 --> 00:01:42,479
cards where we've we have a balance we

00:01:41,130 --> 00:01:45,290
have a credit limit

00:01:42,479 --> 00:01:49,200
we've done some transactions and we do

00:01:45,290 --> 00:01:51,509
authorizations authorizations are the

00:01:49,200 --> 00:01:53,579
the clever one that's when you you

00:01:51,509 --> 00:01:55,259
checked into the hotel we kind of put

00:01:53,579 --> 00:01:57,240
hold on some money on your card it

00:01:55,259 --> 00:02:00,930
doesn't cost you anything but it stops

00:01:57,240 --> 00:02:02,700
you spending that money so what that

00:02:00,930 --> 00:02:04,920
means is that changes your available

00:02:02,700 --> 00:02:08,429
credit you've acts we spent 100 euros

00:02:04,920 --> 00:02:08,670
you've had 50 on hold so 150 euros of

00:02:08,429 --> 00:02:14,970
you

00:02:08,670 --> 00:02:18,959
credit is you mind so the web front-end

00:02:14,970 --> 00:02:21,959
I've got here is not very good I'm a

00:02:18,959 --> 00:02:23,670
back-end developer but the micro

00:02:21,959 --> 00:02:26,520
services are just rest based they're

00:02:23,670 --> 00:02:28,920
just doing five simple things look up

00:02:26,520 --> 00:02:31,380
the users in the system look up

00:02:28,920 --> 00:02:34,080
somebody's transactions the important

00:02:31,380 --> 00:02:36,030
one is number three because number three

00:02:34,080 --> 00:02:38,720
calls four and five and this is where

00:02:36,030 --> 00:02:42,180
the tracing starts to become relevant

00:02:38,720 --> 00:02:44,190
because one of those is misbehaving is

00:02:42,180 --> 00:02:46,950
running slowly and I need to find out

00:02:44,190 --> 00:02:51,299
which one so I'm getting a per user

00:02:46,950 --> 00:02:52,890
experience on the front end and how do I

00:02:51,299 --> 00:02:55,410
trace that down at the back end when

00:02:52,890 --> 00:02:58,049
it's running different processes on

00:02:55,410 --> 00:03:01,319
different hosts what's the bottleneck

00:02:58,049 --> 00:03:06,180
where is it going wrong so that's what

00:03:01,319 --> 00:03:08,760
the tracing is about the tracing

00:03:06,180 --> 00:03:12,959
solution itself is a product called

00:03:08,760 --> 00:03:15,060
Zipkin which is free open-source you can

00:03:12,959 --> 00:03:19,100
download it from Zipkin io it's on

00:03:15,060 --> 00:03:23,489
github it grew out of a Google project

00:03:19,100 --> 00:03:27,540
the thing called dapper so the idea is

00:03:23,489 --> 00:03:31,530
around tracing and what they mean by

00:03:27,540 --> 00:03:35,579
tracing is two concepts spans and

00:03:31,530 --> 00:03:37,920
tracy's traces just the start and stop

00:03:35,579 --> 00:03:41,130
of an operation in and out of a method

00:03:37,920 --> 00:03:45,120
the usual kind of stuff the span is

00:03:41,130 --> 00:03:47,280
where that is like an umbrella where

00:03:45,120 --> 00:03:50,790
operation one calls operation two

00:03:47,280 --> 00:03:52,950
operation three and so on and how it

00:03:50,790 --> 00:03:55,799
works it is just it sneaks some extra

00:03:52,950 --> 00:03:59,130
data into the HTTP headers so you get in

00:03:55,799 --> 00:04:01,230
an incoming header which is blank so

00:03:59,130 --> 00:04:03,150
you're the top-level operation you get

00:04:01,230 --> 00:04:07,500
an incoming header which is non blank

00:04:03,150 --> 00:04:10,280
you're a child operation and hopefully

00:04:07,500 --> 00:04:13,500
how will we'll see it on screen is

00:04:10,280 --> 00:04:16,530
across the the top we have one long

00:04:13,500 --> 00:04:19,260
operation that took 30 seconds to

00:04:16,530 --> 00:04:21,579
execute we can look down that's been

00:04:19,260 --> 00:04:24,159
broken down this middle call that too

00:04:21,579 --> 00:04:25,990
or a large amount of time called some

00:04:24,159 --> 00:04:28,150
other operations that were very quick so

00:04:25,990 --> 00:04:30,879
that tells us all the time is being

00:04:28,150 --> 00:04:33,159
spent in this middle layer it's not

00:04:30,879 --> 00:04:36,250
spending a lot of time retrieving data

00:04:33,159 --> 00:04:39,069
from elsewhere it's spending all the

00:04:36,250 --> 00:04:42,300
time on its own processing so maybe it's

00:04:39,069 --> 00:04:45,460
got an inefficient algorithm who knows

00:04:42,300 --> 00:04:49,479
so the original architecture of Zipkin

00:04:45,460 --> 00:04:52,060
is that you have a monolith a process

00:04:49,479 --> 00:04:55,990
that does everything so we have the user

00:04:52,060 --> 00:04:57,729
interface in there we have the tracey's

00:04:55,990 --> 00:05:02,590
being stored in there and we have a

00:04:57,729 --> 00:05:05,080
storage mechanism for the Tracie's and

00:05:02,590 --> 00:05:07,300
that's okay but that's kind of not what

00:05:05,080 --> 00:05:11,469
we want so we want to get rid of that

00:05:07,300 --> 00:05:13,900
storage from the Zipkin server that

00:05:11,469 --> 00:05:17,650
provides a few options in terms of

00:05:13,900 --> 00:05:20,139
service so Zipkin can storing Cassandra

00:05:17,650 --> 00:05:24,639
that was what it was originally intended

00:05:20,139 --> 00:05:29,259
for Zipkin can store in MySQL Zipkin can

00:05:24,639 --> 00:05:31,180
store in memory which is fast but not

00:05:29,259 --> 00:05:32,590
really as far as they're concerned for

00:05:31,180 --> 00:05:35,139
production it's just a dev and test

00:05:32,590 --> 00:05:39,789
option because they're just running a

00:05:35,139 --> 00:05:42,130
JVM and memories gonna run out so what

00:05:39,789 --> 00:05:46,419
we're looking at is is there another way

00:05:42,130 --> 00:05:49,930
with Zipkin and in terms of adding it to

00:05:46,419 --> 00:05:52,870
the project super super easy if you're

00:05:49,930 --> 00:05:55,719
in spring boom and you just need spring

00:05:52,870 --> 00:05:58,180
application name and add one dependency

00:05:55,719 --> 00:06:00,969
and then spring boot does everything

00:05:58,180 --> 00:06:04,120
else for you so perhaps that's the

00:06:00,969 --> 00:06:06,789
takeaway from today spring cloud startup

00:06:04,120 --> 00:06:10,349
Zipkin pools in all the pieces you need

00:06:06,789 --> 00:06:10,349
does all the things you want

00:06:11,210 --> 00:06:18,740
so Zipkin is the monitoring framework

00:06:14,900 --> 00:06:21,289
the tracing framework it can store

00:06:18,740 --> 00:06:22,639
somewhere and this is where hazel caste

00:06:21,289 --> 00:06:25,789
comes in

00:06:22,639 --> 00:06:29,270
hazel caste is my employer I'm not

00:06:25,789 --> 00:06:31,009
entirely impartial here you've probably

00:06:29,270 --> 00:06:32,449
heard of hazel caste in a kind of

00:06:31,009 --> 00:06:35,600
interchangeable way with the software

00:06:32,449 --> 00:06:39,050
product we actually have two we have IMD

00:06:35,600 --> 00:06:41,360
G at the top in memory data grid which

00:06:39,050 --> 00:06:42,949
is what we'll talk about next and we

00:06:41,360 --> 00:06:45,440
have another thing called jet which is

00:06:42,949 --> 00:06:50,150
streaming analytics which is not

00:06:45,440 --> 00:06:53,090
relevant for today's talk so the idea of

00:06:50,150 --> 00:06:55,550
an in-memory data grid is some Java

00:06:53,090 --> 00:07:00,949
processes that hosts some data is in

00:06:55,550 --> 00:07:02,870
memory no great surprise the the drizzle

00:07:00,949 --> 00:07:04,550
it's like a toolbox there's lots of

00:07:02,870 --> 00:07:06,320
features in there but the one that

00:07:04,550 --> 00:07:09,770
matters is we have an implementation of

00:07:06,320 --> 00:07:12,380
map which is spread across multiple JVMs

00:07:09,770 --> 00:07:14,800
with the ability to query data to have

00:07:12,380 --> 00:07:17,479
indexes to run processing and data

00:07:14,800 --> 00:07:20,650
expiry search all sorts of things that

00:07:17,479 --> 00:07:23,930
you don't generally get with java maps

00:07:20,650 --> 00:07:26,030
so if we look at what a hazel caste

00:07:23,930 --> 00:07:29,210
cluster looks like it's a collection of

00:07:26,030 --> 00:07:31,909
processes and the key part which I've

00:07:29,210 --> 00:07:34,250
tried to get in this diagram is that the

00:07:31,909 --> 00:07:37,159
data is striped across the processes

00:07:34,250 --> 00:07:39,680
that's what the light green boxes are my

00:07:37,159 --> 00:07:41,740
Java util map is cut up into bits and

00:07:39,680 --> 00:07:44,479
shared out amongst the verbal service

00:07:41,740 --> 00:07:47,090
and the darker green boxes are in mirror

00:07:44,479 --> 00:07:49,159
copies so I can cook with servers going

00:07:47,090 --> 00:07:51,949
off the air I can scale up and down my

00:07:49,159 --> 00:07:57,009
capacity using the on-demand broker for

00:07:51,949 --> 00:07:59,870
example so that's what gives me the

00:07:57,009 --> 00:08:02,720
storage I want for Zipkin because it's

00:07:59,870 --> 00:08:05,060
in memory so it's fast but it's

00:08:02,720 --> 00:08:07,070
resilient and out of the process for the

00:08:05,060 --> 00:08:08,990
Zipkin server so I'm not worried about

00:08:07,070 --> 00:08:11,810
running out space I can manage that

00:08:08,990 --> 00:08:13,400
capacity independently think of it well

00:08:11,810 --> 00:08:15,650
it's not really a database but think of

00:08:13,400 --> 00:08:17,539
it like a database of got the best of

00:08:15,650 --> 00:08:19,190
both worlds I don't have this the

00:08:17,539 --> 00:08:20,690
slowness that you get from the desk but

00:08:19,190 --> 00:08:21,610
I don't have to worry about the Zipkin

00:08:20,690 --> 00:08:24,639
server itself

00:08:21,610 --> 00:08:27,550
running out capacity of off Lord eat to

00:08:24,639 --> 00:08:29,680
another server and this is Java

00:08:27,550 --> 00:08:34,329
processes they're very easy for spring

00:08:29,680 --> 00:08:37,089
boot but we have lots of ways to connect

00:08:34,329 --> 00:08:40,060
to them that took a long time on

00:08:37,089 --> 00:08:42,360
PowerPoint just that one animation we

00:08:40,060 --> 00:08:45,190
have got a range of clients that connect

00:08:42,360 --> 00:08:46,810
as far as we're concerned today it's a

00:08:45,190 --> 00:08:49,570
Java client for the Zipkin server

00:08:46,810 --> 00:08:51,130
connecting to a Java process you can

00:08:49,570 --> 00:08:53,589
access that map as if it's in your

00:08:51,130 --> 00:08:58,269
memory it's actually spread across the

00:08:53,589 --> 00:09:02,890
memory of other processes so it's time

00:08:58,269 --> 00:09:05,560
for my demo it's got a couple of bits

00:09:02,890 --> 00:09:08,019
where I'm half in and half out of Cloud

00:09:05,560 --> 00:09:10,630
Foundry I've decided to run my top-level

00:09:08,019 --> 00:09:14,740
application in Cloud Foundry I've

00:09:10,630 --> 00:09:16,990
decided to run my micro services out for

00:09:14,740 --> 00:09:18,399
no particular reason other than this is

00:09:16,990 --> 00:09:20,380
the kind of jumble that you normally

00:09:18,399 --> 00:09:22,149
have to deal with it's nice if you've

00:09:20,380 --> 00:09:24,089
got a green field where you do

00:09:22,149 --> 00:09:26,890
everything right to begin with but in

00:09:24,089 --> 00:09:32,399
big businesses have already got apps and

00:09:26,890 --> 00:09:35,079
there might be a transition process so

00:09:32,399 --> 00:09:37,449
how my application looks and the user on

00:09:35,079 --> 00:09:39,640
the Left I talked to the web application

00:09:37,449 --> 00:09:43,180
which is in blue and in Cloud Foundry

00:09:39,640 --> 00:09:45,279
which makes calls to my five micro

00:09:43,180 --> 00:09:47,199
services I'm only running one instance

00:09:45,279 --> 00:09:49,720
of each I don't have this on the laptops

00:09:47,199 --> 00:09:53,190
not off the clustering and those are

00:09:49,720 --> 00:09:56,529
retrieving data from hazel cast and then

00:09:53,190 --> 00:09:59,250
what the monitoring does is adds an

00:09:56,529 --> 00:10:02,230
extra process for the Zipkin server and

00:09:59,250 --> 00:10:04,329
the micro services are sending rest

00:10:02,230 --> 00:10:07,540
calls to the Zipkin servicing this is a

00:10:04,329 --> 00:10:11,079
trace that conservers saving that in

00:10:07,540 --> 00:10:16,839
hazel caste as well and the UI lets us

00:10:11,079 --> 00:10:21,700
browse them so time for demo let's hope

00:10:16,839 --> 00:10:29,450
this works on the network here

00:10:21,700 --> 00:10:33,800
so I'm in STS you'll see that okay yep

00:10:29,450 --> 00:10:38,589
so what I'm going to do is I have the

00:10:33,800 --> 00:10:38,589
Zipkin server all these objects I will

00:10:38,800 --> 00:10:41,800
start

00:10:44,690 --> 00:10:54,639
and while I'm doing that I will deploy

00:10:47,389 --> 00:10:54,639
my app to Cloud Foundry

00:10:58,540 --> 00:11:03,640
the only bar I had to change today is

00:11:00,760 --> 00:11:06,850
just my IP address for my atlas in Cloud

00:11:03,640 --> 00:11:08,200
Foundry reach outside there's better

00:11:06,850 --> 00:11:11,440
ways to do that but this is just a

00:11:08,200 --> 00:11:13,300
demonstration you know really you would

00:11:11,440 --> 00:11:15,870
want to use a config server and have all

00:11:13,300 --> 00:11:15,870
that kind of stuff

00:11:16,170 --> 00:11:22,600
derived rather than hard-coded so let's

00:11:20,980 --> 00:11:28,770
just wait for everything to start up on

00:11:22,600 --> 00:11:28,770
my laptop how are we doing

00:11:29,160 --> 00:11:32,700
everything's chugging a week

00:11:34,130 --> 00:11:38,770
so while that's going i'll stop some

00:11:39,920 --> 00:11:47,240
Sassy's as my out there yep my office -

00:11:44,910 --> 00:11:47,240
so

00:11:52,490 --> 00:12:00,130
so everything is up and running all my

00:11:54,710 --> 00:12:03,550
microservices are running and my app is

00:12:00,130 --> 00:12:03,550
still deploying

00:12:08,290 --> 00:12:13,779
you know the goat was still going so

00:12:11,860 --> 00:12:17,079
while I'm waiting on that what I'll do

00:12:13,779 --> 00:12:19,870
is I'll go to my I did briefly mentioned

00:12:17,079 --> 00:12:22,930
that hazel cast as a commercial site I

00:12:19,870 --> 00:12:27,990
can monitor my maps on my hazel cast a

00:12:22,930 --> 00:12:30,730
plication so I can have a look at my

00:12:27,990 --> 00:12:33,639
credit card authorizations I have two on

00:12:30,730 --> 00:12:37,360
this JVM I can look at my transactions

00:12:33,639 --> 00:12:42,040
I'm really just able to browse map

00:12:37,360 --> 00:12:45,910
content so what I want to do here here's

00:12:42,040 --> 00:12:48,630
my app is actually starting Jack let's

00:12:45,910 --> 00:12:48,630
try and see

00:12:53,130 --> 00:12:59,520
right so my app is up and running like I

00:12:57,510 --> 00:13:01,200
say it's not the best web developing an

00:12:59,520 --> 00:13:06,210
application in the world um that's not

00:13:01,200 --> 00:13:11,130
my thing and when I look at my users in

00:13:06,210 --> 00:13:14,940
my system I've got seven users I select

00:13:11,130 --> 00:13:17,220
one let's pick me and then what we see

00:13:14,940 --> 00:13:21,110
is of some operations in the background

00:13:17,220 --> 00:13:23,340
you might seen on the console but my

00:13:21,110 --> 00:13:27,900
balancers show me I've got credit limit

00:13:23,340 --> 00:13:29,880
400 and available credit of zero I can

00:13:27,900 --> 00:13:32,070
click down and see your well I took an

00:13:29,880 --> 00:13:33,390
uber Nevada pizza and this is the one

00:13:32,070 --> 00:13:36,150
that's pooped me out balance I have an

00:13:33,390 --> 00:13:38,430
authorizations we're not interested in

00:13:36,150 --> 00:13:44,400
the app what we are interested in though

00:13:38,430 --> 00:13:47,100
is zip code so I can go to my zip

00:13:44,400 --> 00:13:49,710
conserver it's picked up that it has

00:13:47,100 --> 00:13:51,510
treaties for app from my spring

00:13:49,710 --> 00:13:55,740
application name that's my top level I

00:13:51,510 --> 00:13:59,550
can see what Tracie's are available if I

00:13:55,740 --> 00:14:02,760
click on that trace I can see that that

00:13:59,550 --> 00:14:04,560
top-level called to find users made a

00:14:02,760 --> 00:14:07,410
call to this switch made a call to this

00:14:04,560 --> 00:14:09,780
this goal and this call and this call

00:14:07,410 --> 00:14:13,050
and if we look at that that operation

00:14:09,780 --> 00:14:15,210
took a set amount of time it's that

00:14:13,050 --> 00:14:18,780
there's the incoming call there's the

00:14:15,210 --> 00:14:21,290
response so I can trace all of what's

00:14:18,780 --> 00:14:21,290
going on

00:14:24,250 --> 00:14:28,660
the part that matters more is official

00:14:26,590 --> 00:14:31,780
you can see that the end to end of that

00:14:28,660 --> 00:14:33,520
operation was 1.7 seconds and that that

00:14:31,780 --> 00:14:35,740
bit didn t predict we long but there's

00:14:33,520 --> 00:14:38,650
took a large map time that's the span

00:14:35,740 --> 00:14:41,620
with the Tracy's underneath so that's

00:14:38,650 --> 00:14:44,770
the part that show me what's going on

00:14:41,620 --> 00:14:48,100
and I can run these operations directly

00:14:44,770 --> 00:14:52,360
I can look at my balance from a rest

00:14:48,100 --> 00:14:54,370
call not particularly exciting I can

00:14:52,360 --> 00:14:57,040
look at my transactions from a rest call

00:14:54,370 --> 00:15:01,150
so these are all the the micro services

00:14:57,040 --> 00:15:03,760
so that's that the demonstration app the

00:15:01,150 --> 00:15:07,780
app isn't important the part that

00:15:03,760 --> 00:15:12,880
matters is that to instrument it you

00:15:07,780 --> 00:15:14,650
just turn on sampling so the core thing

00:15:12,880 --> 00:15:18,460
is a tool called sleuth

00:15:14,650 --> 00:15:20,050
so it's springing clouds length is the

00:15:18,460 --> 00:15:24,190
thing that's wrapping up the Zipkin

00:15:20,050 --> 00:15:27,850
calls and this is where it's sending the

00:15:24,190 --> 00:15:31,720
Tracy's so this is just a URL and that's

00:15:27,850 --> 00:15:34,630
the URL that I call to browse the traces

00:15:31,720 --> 00:15:36,700
so I can see drill down into individual

00:15:34,630 --> 00:15:40,000
operations I can look at micro service 3

00:15:36,700 --> 00:15:41,620
and see what micro service 3 is doing

00:15:40,000 --> 00:15:44,650
and this is where we get back into the

00:15:41,620 --> 00:15:47,020
the same diagram so if you have a

00:15:44,650 --> 00:15:51,310
hierarchy of micro services you can add

00:15:47,020 --> 00:15:55,480
Tracy's if you've got rest calls and

00:15:51,310 --> 00:15:57,880
then the last piece of this is these

00:15:55,480 --> 00:16:02,080
rest calls Zipkin spans are stored in

00:15:57,880 --> 00:16:05,280
hazel caste we can see that the servers

00:16:02,080 --> 00:16:08,710
are there there are two JVM running

00:16:05,280 --> 00:16:14,410
storing data and mirrored data so if I

00:16:08,710 --> 00:16:16,890
really wanted to I can shut down my

00:16:14,410 --> 00:16:16,890
service

00:16:19,180 --> 00:16:25,030
go back to my application and it's still

00:16:22,960 --> 00:16:27,850
working because I've been cheating I'm

00:16:25,030 --> 00:16:30,280
running another copy in that window so

00:16:27,850 --> 00:16:33,120
I'm running a cluster of 2g VMs and I've

00:16:30,280 --> 00:16:33,120
only killed off one

00:16:39,220 --> 00:16:41,819
so

00:16:42,120 --> 00:16:47,190
that was a little bit fast through the

00:16:43,860 --> 00:16:50,550
slides but the key part really is that

00:16:47,190 --> 00:16:54,000
this is just a dependency to add you

00:16:50,550 --> 00:16:56,820
just add spring cloud start - Zipkin to

00:16:54,000 --> 00:17:00,510
your palm or Gradle and whatever you use

00:16:56,820 --> 00:17:08,640
them if you've got a spring application

00:17:00,510 --> 00:17:14,640
name that gets tagged in if you look in

00:17:08,640 --> 00:17:17,459
the console which one am i finding if I

00:17:14,640 --> 00:17:19,020
find one of my America services then now

00:17:17,459 --> 00:17:22,740
you can see the trace information going

00:17:19,020 --> 00:17:25,199
out there is the microservice name there

00:17:22,740 --> 00:17:26,610
is the trace ID was just at UUID so

00:17:25,199 --> 00:17:30,000
that's how it ties everything together

00:17:26,610 --> 00:17:31,650
you're passing in the parent and your

00:17:30,000 --> 00:17:33,420
faso parent and child minh says that

00:17:31,650 --> 00:17:35,670
this is a child of that operation it can

00:17:33,420 --> 00:17:38,580
build up the hierarchy on the Zipkin

00:17:35,670 --> 00:17:48,920
server so what matters is your

00:17:38,580 --> 00:17:48,920
application name in your llamo and your

00:17:50,090 --> 00:17:53,080
here's my bomber

00:17:54,630 --> 00:18:05,419
so I'm pulling in hazel cast timely from

00:17:59,100 --> 00:18:07,590
my web Zipkin for monitoring that's it

00:18:05,419 --> 00:18:08,820
couldn't get much simpler than that

00:18:07,590 --> 00:18:10,289
could get a little simpler but we're

00:18:08,820 --> 00:18:13,400
down to four dependencies so it's really

00:18:10,289 --> 00:18:13,400
not that many to manage

00:18:16,360 --> 00:18:20,919
and the part that I'm personally working

00:18:19,000 --> 00:18:24,730
on at the moment is this Zipkin storage

00:18:20,919 --> 00:18:27,580
hazel caste so adding hazel cast as a

00:18:24,730 --> 00:18:31,929
storage type to Zipkin it's still a work

00:18:27,580 --> 00:18:35,500
in progress looking is it self evolving

00:18:31,929 --> 00:18:37,360
so this works on version 128 the current

00:18:35,500 --> 00:18:40,029
version zip can - I'm still working on

00:18:37,360 --> 00:18:46,240
so that get pushed and because - or

00:18:40,029 --> 00:18:49,450
whatever long it takes me so that's the

00:18:46,240 --> 00:18:53,559
end for today this was just a kind of

00:18:49,450 --> 00:18:57,880
lightning cover of how you are zipped

00:18:53,559 --> 00:18:59,649
into applications very very easy there's

00:18:57,880 --> 00:19:02,740
lots of resources you can go and look at

00:18:59,649 --> 00:19:05,200
the one that matters really is the open

00:19:02,740 --> 00:19:08,500
tracing organization that tells you all

00:19:05,200 --> 00:19:11,350
about these slides are on uploaded them

00:19:08,500 --> 00:19:13,120
to shed so you can download them but

00:19:11,350 --> 00:19:17,380
obviously about then you gotta log in

00:19:13,120 --> 00:19:20,620
chat didn't so that's all there the cord

00:19:17,380 --> 00:19:24,789
itself is on github github calm / Neal

00:19:20,620 --> 00:19:27,039
Stephenson that's me if I'll stop in a

00:19:24,789 --> 00:19:28,929
second and we'll run into some questions

00:19:27,039 --> 00:19:32,620
but if there's any question you think

00:19:28,929 --> 00:19:37,260
off afterwards then Neal hazel cast comm

00:19:32,620 --> 00:19:40,260
keeps it nice and easy so that's me

00:19:37,260 --> 00:19:40,260
questions

00:19:46,540 --> 00:19:52,900
so the question was how do you set up

00:19:49,460 --> 00:19:52,900
Zipkin to use hazel caste

00:19:58,400 --> 00:20:06,800
so on my Zipkin server if i look at the

00:20:02,410 --> 00:20:10,760
configuration then all i do is add an

00:20:06,800 --> 00:20:14,660
argument Zipkin storage type equals

00:20:10,760 --> 00:20:18,260
hazel cast and if you're working on my

00:20:14,660 --> 00:20:21,800
bill then that creates some spring beans

00:20:18,260 --> 00:20:24,380
that do create a Zipkin eternally has an

00:20:21,800 --> 00:20:27,980
interface for storing the spans and for

00:20:24,380 --> 00:20:29,840
searching the spans so ordinarily that

00:20:27,980 --> 00:20:31,460
goes on to something like a rows and

00:20:29,840 --> 00:20:33,920
columns database and you have to index

00:20:31,460 --> 00:20:37,220
it for faster retrieval all that I'm

00:20:33,920 --> 00:20:39,710
doing is providing Zipkin as a client to

00:20:37,220 --> 00:20:42,230
call off the hazel cast and I'm storing

00:20:39,710 --> 00:20:46,070
that data in hazel cast memory across

00:20:42,230 --> 00:20:48,290
multiple processes in a map and I can

00:20:46,070 --> 00:20:50,570
retrieve that quickly because the maps

00:20:48,290 --> 00:20:51,920
are indexed on hazel cast so there's a

00:20:50,570 --> 00:20:56,390
couple of things that hazel cast adds

00:20:51,920 --> 00:20:58,580
that are kind of useful one is you can

00:20:56,390 --> 00:21:01,280
expire data you can say to hazel cast

00:20:58,580 --> 00:21:03,770
this data that written in a delete it

00:21:01,280 --> 00:21:05,630
after they and it'll delete it for you

00:21:03,770 --> 00:21:07,700
because otherwise your collection of

00:21:05,630 --> 00:21:09,950
Tracy's will be enormous that we run out

00:21:07,700 --> 00:21:13,160
forever and you'd have to do some sort

00:21:09,950 --> 00:21:14,320
of archiving which wouldn't be the

00:21:13,160 --> 00:21:16,760
hardest thing in the world and and

00:21:14,320 --> 00:21:18,650
archiving really would mean take it out

00:21:16,760 --> 00:21:21,679
and throw it away you're not usually

00:21:18,650 --> 00:21:24,440
interested in old trace information this

00:21:21,679 --> 00:21:26,720
is just a thing that you can add and say

00:21:24,440 --> 00:21:30,530
what's tricks what's going on in Devon

00:21:26,720 --> 00:21:32,480
test and because it's HTTP protocol it's

00:21:30,530 --> 00:21:34,520
easy to go in and out Cloud Foundry or

00:21:32,480 --> 00:21:37,600
you don't have to mess about the routes

00:21:34,520 --> 00:21:40,370
and things so that makes life simpler

00:21:37,600 --> 00:21:43,490
particularly if you've got legacy

00:21:40,370 --> 00:21:47,980
applications and new applications you're

00:21:43,490 --> 00:21:47,980
gonna have that mixed deployment model

00:21:49,620 --> 00:21:52,800
more questions

00:22:03,669 --> 00:22:09,710
yeah okay your question is can you have

00:22:07,669 --> 00:22:11,600
it yes you could do that but you would

00:22:09,710 --> 00:22:15,409
have to you I'd do it a different way

00:22:11,600 --> 00:22:18,379
zip kin can only send its traces to one

00:22:15,409 --> 00:22:20,869
place so it could send it to Cassandra

00:22:18,379 --> 00:22:23,210
or to Hazel caste which wouldn't solve

00:22:20,869 --> 00:22:25,249
your problem but you can send data to

00:22:23,210 --> 00:22:31,249
hazel caste and get hazel Cass to send

00:22:25,249 --> 00:22:37,129
it on which is what I'm doing on my

00:22:31,249 --> 00:22:40,820
database is right through or right

00:22:37,129 --> 00:22:48,350
behind on a hazel caste map you can

00:22:40,820 --> 00:22:51,169
attach you can attach a storage class

00:22:48,350 --> 00:22:53,360
which is responsible for every time you

00:22:51,169 --> 00:22:55,220
write into hazel caste write it

00:22:53,360 --> 00:22:56,509
somewhere else such as Cassandra so you

00:22:55,220 --> 00:22:59,330
would have the benefit of in-memory

00:22:56,509 --> 00:23:01,789
speed you might expire things out of

00:22:59,330 --> 00:23:04,190
memory but hold them for longer on

00:23:01,789 --> 00:23:06,169
Cassandra and House keep them after

00:23:04,190 --> 00:23:07,879
aren't for you I have today's Tracey's

00:23:06,169 --> 00:23:10,309
in memory they were blazing fast access

00:23:07,879 --> 00:23:13,249
to thaws and historical traces for a

00:23:10,309 --> 00:23:15,919
month on disk and then discard them from

00:23:13,249 --> 00:23:19,240
there and that's how you configure the

00:23:15,919 --> 00:23:21,649
expiry in this case it was your

00:23:19,240 --> 00:23:23,210
authorizations anybody that's ever done

00:23:21,649 --> 00:23:25,070
anything with credit card you swipe the

00:23:23,210 --> 00:23:26,929
card and it just holds an amount for a

00:23:25,070 --> 00:23:31,429
couple of days until the corresponding

00:23:26,929 --> 00:23:33,019
transaction comes through so so this is

00:23:31,429 --> 00:23:37,100
how we configure a map in hazel caste

00:23:33,019 --> 00:23:40,700
we're adding expiry easy-peasy throw it

00:23:37,100 --> 00:23:43,730
away afterwards at 3,600 what's that one

00:23:40,700 --> 00:23:44,409
day patty can't remember now it doesn't

00:23:43,730 --> 00:23:49,179
really matter

00:23:44,409 --> 00:23:49,179
no it's an hour in fact if its seconds

00:23:55,530 --> 00:24:02,280
so just as a last part one thing around

00:23:58,080 --> 00:24:04,710
connectivity is how do processes find

00:24:02,280 --> 00:24:07,200
each other you know it's we don't really

00:24:04,710 --> 00:24:08,700
want hard core IP addresses in one to

00:24:07,200 --> 00:24:11,700
seven zero zero one isn't a particularly

00:24:08,700 --> 00:24:13,650
scalable solution so you can have

00:24:11,700 --> 00:24:16,230
discovery plugins you can hard code your

00:24:13,650 --> 00:24:19,260
your IP address ejek I came up from

00:24:16,230 --> 00:24:20,910
zookeeper all sorts of ways one of the

00:24:19,260 --> 00:24:23,550
biggest challenges of Cloud Foundry is

00:24:20,910 --> 00:24:25,320
just finding where all the machines are

00:24:23,550 --> 00:24:29,730
you know something spins it up and

00:24:25,320 --> 00:24:33,090
that's why in my example on the front

00:24:29,730 --> 00:24:36,540
page you can get at the v kappa v cap

00:24:33,090 --> 00:24:38,670
server season when you create hazel

00:24:36,540 --> 00:24:40,680
caste client normally that would be

00:24:38,670 --> 00:24:42,120
inside Cloud Foundry and then you look

00:24:40,680 --> 00:24:44,580
up to find out where the service

00:24:42,120 --> 00:24:46,760
actually it was bound to and use that IP

00:24:44,580 --> 00:24:46,760
address

00:24:51,460 --> 00:24:56,820
more questions we've got five minutes to

00:24:54,609 --> 00:24:56,820
lunch

00:24:59,770 --> 00:25:02,370
No

00:25:03,600 --> 00:25:06,890
yeah can opener

00:25:14,100 --> 00:25:22,299
yeah if you want to run hazel custom

00:25:19,059 --> 00:25:28,779
Cloud Foundry you can run let's see if

00:25:22,299 --> 00:25:31,840
the Wi-Fi is up you can run it as an

00:25:28,779 --> 00:25:35,740
on-demand broker if you've got effort or

00:25:31,840 --> 00:25:37,840
Cloud Foundry so you can get ODB to spin

00:25:35,740 --> 00:25:40,299
up however many instances you care about

00:25:37,840 --> 00:25:42,279
and it'll do that by interacting with

00:25:40,299 --> 00:25:45,130
Bosch so that'll create a clustered

00:25:42,279 --> 00:25:47,740
service of whatever size you've

00:25:45,130 --> 00:25:49,210
configured for and it'll do rolling

00:25:47,740 --> 00:25:52,240
bounces and all the kind of nice stuff

00:25:49,210 --> 00:25:54,340
that you want so if you seen make some

00:25:52,240 --> 00:25:57,220
change then you take one note off the

00:25:54,340 --> 00:26:00,639
ear and bring it back and then do the

00:25:57,220 --> 00:26:02,830
next one and you can do a rolling change

00:26:00,639 --> 00:26:05,230
to your cluster without ever it going

00:26:02,830 --> 00:26:06,970
off the air and Bosch is bright enough

00:26:05,230 --> 00:26:09,309
to talk to Hazel Kass and say are you

00:26:06,970 --> 00:26:11,559
actually happy because it's not enough

00:26:09,309 --> 00:26:13,360
to say the JVM is started it's and it's

00:26:11,559 --> 00:26:16,029
you have to then say well make sure all

00:26:13,360 --> 00:26:17,559
their everything's heated itself up and

00:26:16,029 --> 00:26:20,880
it's all ready to go before you do the

00:26:17,559 --> 00:26:23,860
next one so it's fine for controlled

00:26:20,880 --> 00:26:25,330
rollout and if obviously ever machine

00:26:23,860 --> 00:26:28,570
failure will start up another one for

00:26:25,330 --> 00:26:30,220
you it's no different a procedure but

00:26:28,570 --> 00:26:33,159
that's only from version one point a

00:26:30,220 --> 00:26:40,870
onwards which shouldn't really be a

00:26:33,159 --> 00:26:44,320
problem are we on now 110 111 and then

00:26:40,870 --> 00:26:46,480
you can define it as a user mean use

00:26:44,320 --> 00:26:49,000
cups and you can make your own Hazel

00:26:46,480 --> 00:26:50,889
class service and then you need to be

00:26:49,000 --> 00:26:53,169
able to create instances off that

00:26:50,889 --> 00:26:54,789
service and then it's just a binding

00:26:53,169 --> 00:26:57,610
between the client and the server so

00:26:54,789 --> 00:27:00,429
that's that part's easy user provider

00:26:57,610 --> 00:27:01,990
services a bit fiddly but once you've

00:27:00,429 --> 00:27:05,350
done it once you just copy it and paste

00:27:01,990 --> 00:27:09,549
it for the next one so it's really not

00:27:05,350 --> 00:27:13,029
difficult to use the PCF tile thing is

00:27:09,549 --> 00:27:15,039
just an enhancement makes it very very

00:27:13,029 --> 00:27:16,779
simple but if you according it by hand

00:27:15,039 --> 00:27:17,590
it's not not the hardest thing in the

00:27:16,779 --> 00:27:20,020
world

00:27:17,590 --> 00:27:22,270
because it's you know Cloud Foundry

00:27:20,020 --> 00:27:26,050
Foundation silver members is like we're

00:27:22,270 --> 00:27:28,210
not horned in on pivotal it's like Cloud

00:27:26,050 --> 00:27:30,730
Foundry runs and Cloud Foundry you've

00:27:28,210 --> 00:27:32,970
got bluemix or any other then we're fine

00:27:30,730 --> 00:27:32,970
with that

00:27:37,770 --> 00:27:42,750
the end of the day hazel caste is just a

00:27:40,110 --> 00:27:49,970
Java process you run it inside a spring

00:27:42,750 --> 00:27:57,010
booth deployable jar file trivial okay

00:27:49,970 --> 00:28:00,220
one more question yes

00:27:57,010 --> 00:28:00,220
[Music]

00:28:07,149 --> 00:28:11,559
I didn't quite hear your question you're

00:28:09,190 --> 00:28:14,090
asking can when hazel gasps connects to

00:28:11,559 --> 00:28:21,039
an external store

00:28:14,090 --> 00:28:21,039
[Music]

00:28:22,649 --> 00:28:25,649
yeah

00:28:31,869 --> 00:28:37,519
I'm still not 100% sure involved in your

00:28:34,820 --> 00:28:39,950
question but basically if an external

00:28:37,519 --> 00:28:42,409
store is only external to hazel cast if

00:28:39,950 --> 00:28:44,749
its internal Cloud Foundry all the

00:28:42,409 --> 00:28:47,179
really matters is the connection string

00:28:44,749 --> 00:28:49,460
information so you know what's the IP

00:28:47,179 --> 00:28:51,529
address what's the logon password if

00:28:49,460 --> 00:28:53,719
it's like you know if that was like an

00:28:51,529 --> 00:28:55,879
up MySQL instance running in South Cloud

00:28:53,719 --> 00:29:00,080
Foundry you should be able to connect to

00:28:55,879 --> 00:29:01,669
that as long as there's no kind of the

00:29:00,080 --> 00:29:03,289
problem really is the network roots if

00:29:01,669 --> 00:29:08,089
you're outside trying to connect inside

00:29:03,289 --> 00:29:10,129
and TCP gets blocked or that's their the

00:29:08,089 --> 00:29:12,529
the difficulty it's not insurmountable

00:29:10,129 --> 00:29:14,839
it's just a bit fuss if it everything's

00:29:12,529 --> 00:29:17,149
inside then it's a lot simpler because

00:29:14,839 --> 00:29:24,889
Cloud Foundry is just looking after the

00:29:17,149 --> 00:29:27,909
boundary ok I'm done thank you everybody

00:29:24,889 --> 00:29:27,909

YouTube URL: https://www.youtube.com/watch?v=M5jZnE2gkJw


