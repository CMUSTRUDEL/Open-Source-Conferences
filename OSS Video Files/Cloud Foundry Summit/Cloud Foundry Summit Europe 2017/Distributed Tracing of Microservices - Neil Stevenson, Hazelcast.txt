Title: Distributed Tracing of Microservices - Neil Stevenson, Hazelcast
Publication date: 2017-10-18
Playlist: Cloud Foundry Summit Europe 2017
Description: 
	Distributed Tracing of Microservices - Neil Stevenson, Hazelcast

Microservices are generally perceived as a better application style than monolithic code, and
certainly this is a style that sits nicely within Cloud Foundry.

However, it’s not all good news. One of the drawbacks to such decomposition is it can be
very difficult to identify bottlenecks.

In this presentation, Neil will show how it’s easy this can solved for Spring Boot users. A few
beans and dependencies can activate tracing, and with Hazelcast as a service, trace information
can be centrally captured from to a fault-tolerant scalable in-memory repository.

Trace analysis can then be distributed across multiple service instances, without the performance bottleneck of a unclustered disk based resource.
Captions: 
	00:00:01,159 --> 00:00:10,230
good afternoon everyone let's see

00:00:05,220 --> 00:00:13,830
can you meet yep hi my name is Neal

00:00:10,230 --> 00:00:16,699
Stephenson I work at hazel cast and I

00:00:13,830 --> 00:00:19,800
have half an hour to tell you about

00:00:16,699 --> 00:00:23,609
distributed tracing of micro services I

00:00:19,800 --> 00:00:26,400
have about 20 slides and the demo which

00:00:23,609 --> 00:00:27,930
you can download after and I'll be

00:00:26,400 --> 00:00:30,960
around for questions if you don't want

00:00:27,930 --> 00:00:34,559
to go straight for lunch hopefully

00:00:30,960 --> 00:00:38,460
you've seen the talk outline on sheds so

00:00:34,559 --> 00:00:41,010
I'll skip past that what I want to talk

00:00:38,460 --> 00:00:45,090
about very briefly is what I mean by

00:00:41,010 --> 00:00:47,550
micro service then we'll go into a tool

00:00:45,090 --> 00:00:51,329
called Zipkin which is going to do the

00:00:47,550 --> 00:00:53,699
actual tracing for us I mention about

00:00:51,329 --> 00:01:00,059
what hazel cast as to this piece and

00:00:53,699 --> 00:01:03,539
then finally a demo so we all kind of

00:01:00,059 --> 00:01:05,339
have an idea of what micro services I've

00:01:03,539 --> 00:01:08,549
never met two people with the same idea

00:01:05,339 --> 00:01:12,210
so as far as I'm concerned our micro

00:01:08,549 --> 00:01:16,140
services just a a bit it might do a

00:01:12,210 --> 00:01:20,790
little it might do a lot mainly seems to

00:01:16,140 --> 00:01:24,439
be rest based from what I see rest and

00:01:20,790 --> 00:01:27,270
Jason has won the battle in terms of

00:01:24,439 --> 00:01:33,119
communication between services easy for

00:01:27,270 --> 00:01:35,729
humans to to test so my micro service

00:01:33,119 --> 00:01:38,189
today is based around the idea of credit

00:01:35,729 --> 00:01:41,130
cards we've all done things with credit

00:01:38,189 --> 00:01:42,479
cards where we've we have a balance we

00:01:41,130 --> 00:01:45,290
have a credit limit

00:01:42,479 --> 00:01:49,200
we've done some transactions and we do

00:01:45,290 --> 00:01:51,509
authorizations authorizations are the

00:01:49,200 --> 00:01:53,579
the clever one that's when you you

00:01:51,509 --> 00:01:55,259
checked into the hotel we kind of put

00:01:53,579 --> 00:01:57,240
hold on some money on your card it

00:01:55,259 --> 00:02:00,930
doesn't cost you anything but it stops

00:01:57,240 --> 00:02:02,700
you spending that money so what that

00:02:00,930 --> 00:02:04,920
means is that changes your available

00:02:02,700 --> 00:02:08,429
credit you've acts we spent 100 euros

00:02:04,920 --> 00:02:08,670
you've had 50 on hold so 150 euros of

00:02:08,429 --> 00:02:14,970
you

00:02:08,670 --> 00:02:18,959
credit is you mind so the web front-end

00:02:14,970 --> 00:02:21,959
I've got here is not very good I'm a

00:02:18,959 --> 00:02:23,670
back-end developer but the micro

00:02:21,959 --> 00:02:26,520
services are just rest based they're

00:02:23,670 --> 00:02:28,920
just doing five simple things look up

00:02:26,520 --> 00:02:31,380
the users in the system look up

00:02:28,920 --> 00:02:34,080
somebody's transactions the important

00:02:31,380 --> 00:02:36,030
one is number three because number three

00:02:34,080 --> 00:02:38,720
calls four and five and this is where

00:02:36,030 --> 00:02:42,180
the tracing starts to become relevant

00:02:38,720 --> 00:02:44,190
because one of those is misbehaving is

00:02:42,180 --> 00:02:46,950
running slowly and I need to find out

00:02:44,190 --> 00:02:51,299
which one so I'm getting a per user

00:02:46,950 --> 00:02:52,890
experience on the front end and how do I

00:02:51,299 --> 00:02:55,410
trace that down at the back end when

00:02:52,890 --> 00:02:58,049
it's running different processes on

00:02:55,410 --> 00:03:01,319
different hosts what's the bottleneck

00:02:58,049 --> 00:03:06,180
where is it going wrong so that's what

00:03:01,319 --> 00:03:08,760
the tracing is about the tracing

00:03:06,180 --> 00:03:12,959
solution itself is a product called

00:03:08,760 --> 00:03:15,060
Zipkin which is free open-source you can

00:03:12,959 --> 00:03:19,100
download it from Zipkin io it's on

00:03:15,060 --> 00:03:23,489
github it grew out of a Google project

00:03:19,100 --> 00:03:27,540
the thing called dapper so the idea is

00:03:23,489 --> 00:03:31,530
around tracing and what they mean by

00:03:27,540 --> 00:03:35,579
tracing is two concepts spans and

00:03:31,530 --> 00:03:37,920
tracy's traces just the start and stop

00:03:35,579 --> 00:03:41,130
of an operation in and out of a method

00:03:37,920 --> 00:03:45,120
the usual kind of stuff the span is

00:03:41,130 --> 00:03:47,280
where that is like an umbrella where

00:03:45,120 --> 00:03:50,790
operation one calls operation two

00:03:47,280 --> 00:03:52,950
operation three and so on and how it

00:03:50,790 --> 00:03:55,799
works it is just it sneaks some extra

00:03:52,950 --> 00:03:59,130
data into the HTTP headers so you get in

00:03:55,799 --> 00:04:01,230
an incoming header which is blank so

00:03:59,130 --> 00:04:03,150
you're the top-level operation you get

00:04:01,230 --> 00:04:07,500
an incoming header which is non blank

00:04:03,150 --> 00:04:10,280
you're a child operation and hopefully

00:04:07,500 --> 00:04:13,500
how will we'll see it on screen is

00:04:10,280 --> 00:04:16,530
across the the top we have one long

00:04:13,500 --> 00:04:19,260
operation that took 30 seconds to

00:04:16,530 --> 00:04:21,579
execute we can look down that's been

00:04:19,260 --> 00:04:24,159
broken down this middle call that too

00:04:21,579 --> 00:04:25,990
or a large amount of time called some

00:04:24,159 --> 00:04:28,150
other operations that were very quick so

00:04:25,990 --> 00:04:30,879
that tells us all the time is being

00:04:28,150 --> 00:04:33,159
spent in this middle layer it's not

00:04:30,879 --> 00:04:36,250
spending a lot of time retrieving data

00:04:33,159 --> 00:04:39,069
from elsewhere it's spending all the

00:04:36,250 --> 00:04:42,300
time on its own processing so maybe it's

00:04:39,069 --> 00:04:45,460
got an inefficient algorithm who knows

00:04:42,300 --> 00:04:49,479
so the original architecture of Zipkin

00:04:45,460 --> 00:04:52,060
is that you have a monolith a process

00:04:49,479 --> 00:04:55,990
that does everything so we have the user

00:04:52,060 --> 00:04:57,729
interface in there we have the tracey's

00:04:55,990 --> 00:05:02,590
being stored in there and we have a

00:04:57,729 --> 00:05:05,080
storage mechanism for the Tracie's and

00:05:02,590 --> 00:05:07,300
that's okay but that's kind of not what

00:05:05,080 --> 00:05:11,469
we want so we want to get rid of that

00:05:07,300 --> 00:05:13,900
storage from the Zipkin server that

00:05:11,469 --> 00:05:17,650
provides a few options in terms of

00:05:13,900 --> 00:05:20,139
service so Zipkin can storing Cassandra

00:05:17,650 --> 00:05:24,639
that was what it was originally intended

00:05:20,139 --> 00:05:29,259
for Zipkin can store in MySQL Zipkin can

00:05:24,639 --> 00:05:31,180
store in memory which is fast but not

00:05:29,259 --> 00:05:32,590
really as far as they're concerned for

00:05:31,180 --> 00:05:35,139
production it's just a dev and test

00:05:32,590 --> 00:05:39,789
option because they're just running a

00:05:35,139 --> 00:05:42,130
JVM and memories gonna run out so what

00:05:39,789 --> 00:05:46,419
we're looking at is is there another way

00:05:42,130 --> 00:05:49,930
with Zipkin and in terms of adding it to

00:05:46,419 --> 00:05:52,870
the project super super easy if you're

00:05:49,930 --> 00:05:55,719
in spring boom and you just need spring

00:05:52,870 --> 00:05:58,180
application name and add one dependency

00:05:55,719 --> 00:06:00,969
and then spring boot does everything

00:05:58,180 --> 00:06:04,120
else for you so perhaps that's the

00:06:00,969 --> 00:06:06,789
takeaway from today spring cloud startup

00:06:04,120 --> 00:06:10,349
Zipkin pools in all the pieces you need

00:06:06,789 --> 00:06:10,349
does all the things you want

00:06:11,210 --> 00:06:18,740
so Zipkin is the monitoring framework

00:06:14,900 --> 00:06:21,289
the tracing framework it can store

00:06:18,740 --> 00:06:22,639
somewhere and this is where hazel caste

00:06:21,289 --> 00:06:25,789
comes in

00:06:22,639 --> 00:06:29,270
hazel caste is my employer I'm not

00:06:25,789 --> 00:06:31,009
entirely impartial here you've probably

00:06:29,270 --> 00:06:32,449
heard of hazel caste in a kind of

00:06:31,009 --> 00:06:35,600
interchangeable way with the software

00:06:32,449 --> 00:06:39,050
product we actually have two we have IMD

00:06:35,600 --> 00:06:41,360
G at the top in memory data grid which

00:06:39,050 --> 00:06:42,949
is what we'll talk about next and we

00:06:41,360 --> 00:06:45,440
have another thing called jet which is

00:06:42,949 --> 00:06:50,150
streaming analytics which is not

00:06:45,440 --> 00:06:53,090
relevant for today's talk so the idea of

00:06:50,150 --> 00:06:55,550
an in-memory data grid is some Java

00:06:53,090 --> 00:07:00,949
processes that hosts some data is in

00:06:55,550 --> 00:07:02,870
memory no great surprise the the drizzle

00:07:00,949 --> 00:07:04,550
it's like a toolbox there's lots of

00:07:02,870 --> 00:07:06,320
features in there but the one that

00:07:04,550 --> 00:07:09,770
matters is we have an implementation of

00:07:06,320 --> 00:07:12,380
map which is spread across multiple JVMs

00:07:09,770 --> 00:07:14,800
with the ability to query data to have

00:07:12,380 --> 00:07:17,479
indexes to run processing and data

00:07:14,800 --> 00:07:20,650
expiry search all sorts of things that

00:07:17,479 --> 00:07:23,930
you don't generally get with java maps

00:07:20,650 --> 00:07:26,030
so if we look at what a hazel caste

00:07:23,930 --> 00:07:29,210
cluster looks like it's a collection of

00:07:26,030 --> 00:07:31,909
processes and the key part which I've

00:07:29,210 --> 00:07:34,250
tried to get in this diagram is that the

00:07:31,909 --> 00:07:37,159
data is striped across the processes

00:07:34,250 --> 00:07:39,680
that's what the light green boxes are my

00:07:37,159 --> 00:07:41,740
Java util map is cut up into bits and

00:07:39,680 --> 00:07:44,479
shared out amongst the verbal service

00:07:41,740 --> 00:07:47,090
and the darker green boxes are in mirror

00:07:44,479 --> 00:07:49,159
copies so I can cook with servers going

00:07:47,090 --> 00:07:51,949
off the air I can scale up and down my

00:07:49,159 --> 00:07:57,009
capacity using the on-demand broker for

00:07:51,949 --> 00:07:59,870
example so that's what gives me the

00:07:57,009 --> 00:08:02,720
storage I want for Zipkin because it's

00:07:59,870 --> 00:08:05,060
in memory so it's fast but it's

00:08:02,720 --> 00:08:07,070
resilient and out of the process for the

00:08:05,060 --> 00:08:08,990
Zipkin server so I'm not worried about

00:08:07,070 --> 00:08:11,810
running out space I can manage that

00:08:08,990 --> 00:08:13,400
capacity independently think of it well

00:08:11,810 --> 00:08:15,650
it's not really a database but think of

00:08:13,400 --> 00:08:17,539
it like a database of got the best of

00:08:15,650 --> 00:08:19,190
both worlds I don't have this the

00:08:17,539 --> 00:08:20,690
slowness that you get from the desk but

00:08:19,190 --> 00:08:21,610
I don't have to worry about the Zipkin

00:08:20,690 --> 00:08:24,639
server itself

00:08:21,610 --> 00:08:27,550
running out capacity of off Lord eat to

00:08:24,639 --> 00:08:29,680
another server and this is Java

00:08:27,550 --> 00:08:34,329
processes they're very easy for spring

00:08:29,680 --> 00:08:37,089
boot but we have lots of ways to connect

00:08:34,329 --> 00:08:40,060
to them that took a long time on

00:08:37,089 --> 00:08:42,360
PowerPoint just that one animation we

00:08:40,060 --> 00:08:45,190
have got a range of clients that connect

00:08:42,360 --> 00:08:46,810
as far as we're concerned today it's a

00:08:45,190 --> 00:08:49,570
Java client for the Zipkin server

00:08:46,810 --> 00:08:51,130
connecting to a Java process you can

00:08:49,570 --> 00:08:53,589
access that map as if it's in your

00:08:51,130 --> 00:08:58,269
memory it's actually spread across the

00:08:53,589 --> 00:09:02,890
memory of other processes so it's time

00:08:58,269 --> 00:09:05,560
for my demo it's got a couple of bits

00:09:02,890 --> 00:09:08,019
where I'm half in and half out of Cloud

00:09:05,560 --> 00:09:10,630
Foundry I've decided to run my top-level

00:09:08,019 --> 00:09:14,740
application in Cloud Foundry I've

00:09:10,630 --> 00:09:16,990
decided to run my micro services out for

00:09:14,740 --> 00:09:18,399
no particular reason other than this is

00:09:16,990 --> 00:09:20,380
the kind of jumble that you normally

00:09:18,399 --> 00:09:22,149
have to deal with it's nice if you've

00:09:20,380 --> 00:09:24,089
got a green field where you do

00:09:22,149 --> 00:09:26,890
everything right to begin with but in

00:09:24,089 --> 00:09:32,399
big businesses have already got apps and

00:09:26,890 --> 00:09:35,079
there might be a transition process so

00:09:32,399 --> 00:09:37,449
how my application looks and the user on

00:09:35,079 --> 00:09:39,640
the Left I talked to the web application

00:09:37,449 --> 00:09:43,180
which is in blue and in Cloud Foundry

00:09:39,640 --> 00:09:45,279
which makes calls to my five micro

00:09:43,180 --> 00:09:47,199
services I'm only running one instance

00:09:45,279 --> 00:09:49,720
of each I don't have this on the laptops

00:09:47,199 --> 00:09:53,190
not off the clustering and those are

00:09:49,720 --> 00:09:56,529
retrieving data from hazel cast and then

00:09:53,190 --> 00:09:59,250
what the monitoring does is adds an

00:09:56,529 --> 00:10:02,230
extra process for the Zipkin server and

00:09:59,250 --> 00:10:04,329
the micro services are sending rest

00:10:02,230 --> 00:10:07,540
calls to the Zipkin servicing this is a

00:10:04,329 --> 00:10:11,079
trace that conservers saving that in

00:10:07,540 --> 00:10:16,839
hazel caste as well and the UI lets us

00:10:11,079 --> 00:10:21,700
browse them so time for demo let's hope

00:10:16,839 --> 00:10:29,450
this works on the network here

00:10:21,700 --> 00:10:33,800
so I'm in STS you'll see that okay yep

00:10:29,450 --> 00:10:38,589
so what I'm going to do is I have the

00:10:33,800 --> 00:10:38,589
Zipkin server all these objects I will

00:10:38,800 --> 00:10:41,800
start

00:10:44,690 --> 00:10:54,639
and while I'm doing that I will deploy

00:10:47,389 --> 00:10:54,639
my app to Cloud Foundry

00:10:58,540 --> 00:11:03,640
the only bar I had to change today is

00:11:00,760 --> 00:11:06,850
just my IP address for my atlas in Cloud

00:11:03,640 --> 00:11:08,200
Foundry reach outside there's better

00:11:06,850 --> 00:11:11,440
ways to do that but this is just a

00:11:08,200 --> 00:11:13,300
demonstration you know really you would

00:11:11,440 --> 00:11:15,870
want to use a config server and have all

00:11:13,300 --> 00:11:15,870
that kind of stuff

00:11:16,170 --> 00:11:22,600
derived rather than hard-coded so let's

00:11:20,980 --> 00:11:28,770
just wait for everything to start up on

00:11:22,600 --> 00:11:28,770
my laptop how are we doing

00:11:29,160 --> 00:11:32,700
everything's chugging a week

00:11:34,130 --> 00:11:38,770
so while that's going i'll stop some

00:11:39,920 --> 00:11:47,240
Sassy's as my out there yep my office -

00:11:44,910 --> 00:11:47,240
so

00:11:52,490 --> 00:12:00,130
so everything is up and running all my

00:11:54,710 --> 00:12:03,550
microservices are running and my app is

00:12:00,130 --> 00:12:03,550
still deploying

00:12:08,290 --> 00:12:13,779
you know the goat was still going so

00:12:11,860 --> 00:12:17,079
while I'm waiting on that what I'll do

00:12:13,779 --> 00:12:19,870
is I'll go to my I did briefly mentioned

00:12:17,079 --> 00:12:22,930
that hazel cast as a commercial site I

00:12:19,870 --> 00:12:27,990
can monitor my maps on my hazel cast a

00:12:22,930 --> 00:12:30,730
plication so I can have a look at my

00:12:27,990 --> 00:12:33,639
credit card authorizations I have two on

00:12:30,730 --> 00:12:37,360
this JVM I can look at my transactions

00:12:33,639 --> 00:12:42,040
I'm really just able to browse map

00:12:37,360 --> 00:12:45,910
content so what I want to do here here's

00:12:42,040 --> 00:12:48,630
my app is actually starting Jack let's

00:12:45,910 --> 00:12:48,630
try and see

00:12:53,130 --> 00:12:59,520
right so my app is up and running like I

00:12:57,510 --> 00:13:01,200
say it's not the best web developing an

00:12:59,520 --> 00:13:06,210
application in the world um that's not

00:13:01,200 --> 00:13:11,130
my thing and when I look at my users in

00:13:06,210 --> 00:13:14,940
my system I've got seven users I select

00:13:11,130 --> 00:13:17,220
one let's pick me and then what we see

00:13:14,940 --> 00:13:21,110
is of some operations in the background

00:13:17,220 --> 00:13:23,340
you might seen on the console but my

00:13:21,110 --> 00:13:27,900
balancers show me I've got credit limit

00:13:23,340 --> 00:13:29,880
400 and available credit of zero I can

00:13:27,900 --> 00:13:32,070
click down and see your well I took an

00:13:29,880 --> 00:13:33,390
uber Nevada pizza and this is the one

00:13:32,070 --> 00:13:36,150
that's pooped me out balance I have an

00:13:33,390 --> 00:13:38,430
authorizations we're not interested in

00:13:36,150 --> 00:13:44,400
the app what we are interested in though

00:13:38,430 --> 00:13:47,100
is zip code so I can go to my zip

00:13:44,400 --> 00:13:49,710
conserver it's picked up that it has

00:13:47,100 --> 00:13:51,510
treaties for app from my spring

00:13:49,710 --> 00:13:55,740
application name that's my top level I

00:13:51,510 --> 00:13:59,550
can see what Tracie's are available if I

00:13:55,740 --> 00:14:02,760
click on that trace I can see that that

00:13:59,550 --> 00:14:04,560
top-level called to find users made a

00:14:02,760 --> 00:14:07,410
call to this switch made a call to this

00:14:04,560 --> 00:14:09,780
this goal and this call and this call

00:14:07,410 --> 00:14:13,050
and if we look at that that operation

00:14:09,780 --> 00:14:15,210
took a set amount of time it's that

00:14:13,050 --> 00:14:18,780
there's the incoming call there's the

00:14:15,210 --> 00:14:21,290
response so I can trace all of what's

00:14:18,780 --> 00:14:21,290
going on

00:14:24,250 --> 00:14:28,660
the part that matters more is official

00:14:26,590 --> 00:14:31,780
you can see that the end to end of that

00:14:28,660 --> 00:14:33,520
operation was 1.7 seconds and that that

00:14:31,780 --> 00:14:35,740
bit didn t predict we long but there's

00:14:33,520 --> 00:14:38,650
took a large map time that's the span

00:14:35,740 --> 00:14:41,620
with the Tracy's underneath so that's

00:14:38,650 --> 00:14:44,770
the part that show me what's going on

00:14:41,620 --> 00:14:48,100
and I can run these operations directly

00:14:44,770 --> 00:14:52,360
I can look at my balance from a rest

00:14:48,100 --> 00:14:54,370
call not particularly exciting I can

00:14:52,360 --> 00:14:57,040
look at my transactions from a rest call

00:14:54,370 --> 00:15:01,150
so these are all the the micro services

00:14:57,040 --> 00:15:03,760
so that's that the demonstration app the

00:15:01,150 --> 00:15:07,780
app isn't important the part that

00:15:03,760 --> 00:15:12,880
matters is that to instrument it you

00:15:07,780 --> 00:15:14,650
just turn on sampling so the core thing

00:15:12,880 --> 00:15:18,460
is a tool called sleuth

00:15:14,650 --> 00:15:20,050
so it's springing clouds length is the

00:15:18,460 --> 00:15:24,190
thing that's wrapping up the Zipkin

00:15:20,050 --> 00:15:27,850
calls and this is where it's sending the

00:15:24,190 --> 00:15:31,720
Tracy's so this is just a URL and that's

00:15:27,850 --> 00:15:34,630
the URL that I call to browse the traces

00:15:31,720 --> 00:15:36,700
so I can see drill down into individual

00:15:34,630 --> 00:15:40,000
operations I can look at micro service 3

00:15:36,700 --> 00:15:41,620
and see what micro service 3 is doing

00:15:40,000 --> 00:15:44,650
and this is where we get back into the

00:15:41,620 --> 00:15:47,020
the same diagram so if you have a

00:15:44,650 --> 00:15:51,310
hierarchy of micro services you can add

00:15:47,020 --> 00:15:55,480
Tracy's if you've got rest calls and

00:15:51,310 --> 00:15:57,880
then the last piece of this is these

00:15:55,480 --> 00:16:02,080
rest calls Zipkin spans are stored in

00:15:57,880 --> 00:16:05,280
hazel caste we can see that the servers

00:16:02,080 --> 00:16:08,710
are there there are two JVM running

00:16:05,280 --> 00:16:14,410
storing data and mirrored data so if I

00:16:08,710 --> 00:16:16,890
really wanted to I can shut down my

00:16:14,410 --> 00:16:16,890
service

00:16:19,180 --> 00:16:25,030
go back to my application and it's still

00:16:22,960 --> 00:16:27,850
working because I've been cheating I'm

00:16:25,030 --> 00:16:30,280
running another copy in that window so

00:16:27,850 --> 00:16:33,120
I'm running a cluster of 2g VMs and I've

00:16:30,280 --> 00:16:33,120
only killed off one

00:16:39,220 --> 00:16:41,819
so

00:16:42,120 --> 00:16:47,190
that was a little bit fast through the

00:16:43,860 --> 00:16:50,550
slides but the key part really is that

00:16:47,190 --> 00:16:54,000
this is just a dependency to add you

00:16:50,550 --> 00:16:56,820
just add spring cloud start - Zipkin to

00:16:54,000 --> 00:17:00,510
your palm or Gradle and whatever you use

00:16:56,820 --> 00:17:08,640
them if you've got a spring application

00:17:00,510 --> 00:17:14,640
name that gets tagged in if you look in

00:17:08,640 --> 00:17:17,459
the console which one am i finding if I

00:17:14,640 --> 00:17:19,020
find one of my America services then now

00:17:17,459 --> 00:17:22,740
you can see the trace information going

00:17:19,020 --> 00:17:25,199
out there is the microservice name there

00:17:22,740 --> 00:17:26,610
is the trace ID was just at UUID so

00:17:25,199 --> 00:17:30,000
that's how it ties everything together

00:17:26,610 --> 00:17:31,650
you're passing in the parent and your

00:17:30,000 --> 00:17:33,420
faso parent and child minh says that

00:17:31,650 --> 00:17:35,670
this is a child of that operation it can

00:17:33,420 --> 00:17:38,580
build up the hierarchy on the Zipkin

00:17:35,670 --> 00:17:48,920
server so what matters is your

00:17:38,580 --> 00:17:48,920
application name in your llamo and your

00:17:50,090 --> 00:17:53,080
here's my bomber

00:17:54,630 --> 00:18:05,419
so I'm pulling in hazel cast timely from

00:17:59,100 --> 00:18:07,590
my web Zipkin for monitoring that's it

00:18:05,419 --> 00:18:08,820
couldn't get much simpler than that

00:18:07,590 --> 00:18:10,289
could get a little simpler but we're

00:18:08,820 --> 00:18:13,400
down to four dependencies so it's really

00:18:10,289 --> 00:18:13,400
not that many to manage

00:18:16,360 --> 00:18:20,919
and the part that I'm personally working

00:18:19,000 --> 00:18:24,730
on at the moment is this Zipkin storage

00:18:20,919 --> 00:18:27,580
hazel caste so adding hazel cast as a

00:18:24,730 --> 00:18:31,929
storage type to Zipkin it's still a work

00:18:27,580 --> 00:18:35,500
in progress looking is it self evolving

00:18:31,929 --> 00:18:37,360
so this works on version 128 the current

00:18:35,500 --> 00:18:40,029
version zip can - I'm still working on

00:18:37,360 --> 00:18:46,240
so that get pushed and because - or

00:18:40,029 --> 00:18:49,450
whatever long it takes me so that's the

00:18:46,240 --> 00:18:53,559
end for today this was just a kind of

00:18:49,450 --> 00:18:57,880
lightning cover of how you are zipped

00:18:53,559 --> 00:18:59,649
into applications very very easy there's

00:18:57,880 --> 00:19:02,740
lots of resources you can go and look at

00:18:59,649 --> 00:19:05,200
the one that matters really is the open

00:19:02,740 --> 00:19:08,500
tracing organization that tells you all

00:19:05,200 --> 00:19:11,350
about these slides are on uploaded them

00:19:08,500 --> 00:19:13,120
to shed so you can download them but

00:19:11,350 --> 00:19:17,380
obviously about then you gotta log in

00:19:13,120 --> 00:19:20,620
chat didn't so that's all there the cord

00:19:17,380 --> 00:19:24,789
itself is on github github calm / Neal

00:19:20,620 --> 00:19:27,039
Stephenson that's me if I'll stop in a

00:19:24,789 --> 00:19:28,929
second and we'll run into some questions

00:19:27,039 --> 00:19:32,620
but if there's any question you think

00:19:28,929 --> 00:19:37,260
off afterwards then Neal hazel cast comm

00:19:32,620 --> 00:19:40,260
keeps it nice and easy so that's me

00:19:37,260 --> 00:19:40,260
questions

00:19:46,540 --> 00:19:52,900
so the question was how do you set up

00:19:49,460 --> 00:19:52,900
Zipkin to use hazel caste

00:19:58,400 --> 00:20:06,800
so on my Zipkin server if i look at the

00:20:02,410 --> 00:20:10,760
configuration then all i do is add an

00:20:06,800 --> 00:20:14,660
argument Zipkin storage type equals

00:20:10,760 --> 00:20:18,260
hazel cast and if you're working on my

00:20:14,660 --> 00:20:21,800
bill then that creates some spring beans

00:20:18,260 --> 00:20:24,380
that do create a Zipkin eternally has an

00:20:21,800 --> 00:20:27,980
interface for storing the spans and for

00:20:24,380 --> 00:20:29,840
searching the spans so ordinarily that

00:20:27,980 --> 00:20:31,460
goes on to something like a rows and

00:20:29,840 --> 00:20:33,920
columns database and you have to index

00:20:31,460 --> 00:20:37,220
it for faster retrieval all that I'm

00:20:33,920 --> 00:20:39,710
doing is providing Zipkin as a client to

00:20:37,220 --> 00:20:42,230
call off the hazel cast and I'm storing

00:20:39,710 --> 00:20:46,070
that data in hazel cast memory across

00:20:42,230 --> 00:20:48,290
multiple processes in a map and I can

00:20:46,070 --> 00:20:50,570
retrieve that quickly because the maps

00:20:48,290 --> 00:20:51,920
are indexed on hazel cast so there's a

00:20:50,570 --> 00:20:56,390
couple of things that hazel cast adds

00:20:51,920 --> 00:20:58,580
that are kind of useful one is you can

00:20:56,390 --> 00:21:01,280
expire data you can say to hazel cast

00:20:58,580 --> 00:21:03,770
this data that written in a delete it

00:21:01,280 --> 00:21:05,630
after they and it'll delete it for you

00:21:03,770 --> 00:21:07,700
because otherwise your collection of

00:21:05,630 --> 00:21:09,950
Tracy's will be enormous that we run out

00:21:07,700 --> 00:21:13,160
forever and you'd have to do some sort

00:21:09,950 --> 00:21:14,320
of archiving which wouldn't be the

00:21:13,160 --> 00:21:16,760
hardest thing in the world and and

00:21:14,320 --> 00:21:18,650
archiving really would mean take it out

00:21:16,760 --> 00:21:21,679
and throw it away you're not usually

00:21:18,650 --> 00:21:24,440
interested in old trace information this

00:21:21,679 --> 00:21:26,720
is just a thing that you can add and say

00:21:24,440 --> 00:21:30,530
what's tricks what's going on in Devon

00:21:26,720 --> 00:21:32,480
test and because it's HTTP protocol it's

00:21:30,530 --> 00:21:34,520
easy to go in and out Cloud Foundry or

00:21:32,480 --> 00:21:37,600
you don't have to mess about the routes

00:21:34,520 --> 00:21:40,370
and things so that makes life simpler

00:21:37,600 --> 00:21:43,490
particularly if you've got legacy

00:21:40,370 --> 00:21:47,980
applications and new applications you're

00:21:43,490 --> 00:21:47,980
gonna have that mixed deployment model

00:21:49,620 --> 00:21:52,800
more questions

00:22:03,669 --> 00:22:09,710
yeah okay your question is can you have

00:22:07,669 --> 00:22:11,600
it yes you could do that but you would

00:22:09,710 --> 00:22:15,409
have to you I'd do it a different way

00:22:11,600 --> 00:22:18,379
zip kin can only send its traces to one

00:22:15,409 --> 00:22:20,869
place so it could send it to Cassandra

00:22:18,379 --> 00:22:23,210
or to Hazel caste which wouldn't solve

00:22:20,869 --> 00:22:25,249
your problem but you can send data to

00:22:23,210 --> 00:22:31,249
hazel caste and get hazel Cass to send

00:22:25,249 --> 00:22:37,129
it on which is what I'm doing on my

00:22:31,249 --> 00:22:40,820
database is right through or right

00:22:37,129 --> 00:22:48,350
behind on a hazel caste map you can

00:22:40,820 --> 00:22:51,169
attach you can attach a storage class

00:22:48,350 --> 00:22:53,360
which is responsible for every time you

00:22:51,169 --> 00:22:55,220
write into hazel caste write it

00:22:53,360 --> 00:22:56,509
somewhere else such as Cassandra so you

00:22:55,220 --> 00:22:59,330
would have the benefit of in-memory

00:22:56,509 --> 00:23:01,789
speed you might expire things out of

00:22:59,330 --> 00:23:04,190
memory but hold them for longer on

00:23:01,789 --> 00:23:06,169
Cassandra and House keep them after

00:23:04,190 --> 00:23:07,879
aren't for you I have today's Tracey's

00:23:06,169 --> 00:23:10,309
in memory they were blazing fast access

00:23:07,879 --> 00:23:13,249
to thaws and historical traces for a

00:23:10,309 --> 00:23:15,919
month on disk and then discard them from

00:23:13,249 --> 00:23:19,240
there and that's how you configure the

00:23:15,919 --> 00:23:21,649
expiry in this case it was your

00:23:19,240 --> 00:23:23,210
authorizations anybody that's ever done

00:23:21,649 --> 00:23:25,070
anything with credit card you swipe the

00:23:23,210 --> 00:23:26,929
card and it just holds an amount for a

00:23:25,070 --> 00:23:31,429
couple of days until the corresponding

00:23:26,929 --> 00:23:33,019
transaction comes through so so this is

00:23:31,429 --> 00:23:37,100
how we configure a map in hazel caste

00:23:33,019 --> 00:23:40,700
we're adding expiry easy-peasy throw it

00:23:37,100 --> 00:23:43,730
away afterwards at 3,600 what's that one

00:23:40,700 --> 00:23:44,409
day patty can't remember now it doesn't

00:23:43,730 --> 00:23:49,179
really matter

00:23:44,409 --> 00:23:49,179
no it's an hour in fact if its seconds

00:23:55,530 --> 00:24:02,280
so just as a last part one thing around

00:23:58,080 --> 00:24:04,710
connectivity is how do processes find

00:24:02,280 --> 00:24:07,200
each other you know it's we don't really

00:24:04,710 --> 00:24:08,700
want hard core IP addresses in one to

00:24:07,200 --> 00:24:11,700
seven zero zero one isn't a particularly

00:24:08,700 --> 00:24:13,650
scalable solution so you can have

00:24:11,700 --> 00:24:16,230
discovery plugins you can hard code your

00:24:13,650 --> 00:24:19,260
your IP address ejek I came up from

00:24:16,230 --> 00:24:20,910
zookeeper all sorts of ways one of the

00:24:19,260 --> 00:24:23,550
biggest challenges of Cloud Foundry is

00:24:20,910 --> 00:24:25,320
just finding where all the machines are

00:24:23,550 --> 00:24:29,730
you know something spins it up and

00:24:25,320 --> 00:24:33,090
that's why in my example on the front

00:24:29,730 --> 00:24:36,540
page you can get at the v kappa v cap

00:24:33,090 --> 00:24:38,670
server season when you create hazel

00:24:36,540 --> 00:24:40,680
caste client normally that would be

00:24:38,670 --> 00:24:42,120
inside Cloud Foundry and then you look

00:24:40,680 --> 00:24:44,580
up to find out where the service

00:24:42,120 --> 00:24:46,760
actually it was bound to and use that IP

00:24:44,580 --> 00:24:46,760
address

00:24:51,460 --> 00:24:56,820
more questions we've got five minutes to

00:24:54,609 --> 00:24:56,820
lunch

00:24:59,770 --> 00:25:02,370
No

00:25:03,600 --> 00:25:06,890
yeah can opener

00:25:14,100 --> 00:25:22,299
yeah if you want to run hazel custom

00:25:19,059 --> 00:25:28,779
Cloud Foundry you can run let's see if

00:25:22,299 --> 00:25:31,840
the Wi-Fi is up you can run it as an

00:25:28,779 --> 00:25:35,740
on-demand broker if you've got effort or

00:25:31,840 --> 00:25:37,840
Cloud Foundry so you can get ODB to spin

00:25:35,740 --> 00:25:40,299
up however many instances you care about

00:25:37,840 --> 00:25:42,279
and it'll do that by interacting with

00:25:40,299 --> 00:25:45,130
Bosch so that'll create a clustered

00:25:42,279 --> 00:25:47,740
service of whatever size you've

00:25:45,130 --> 00:25:49,210
configured for and it'll do rolling

00:25:47,740 --> 00:25:52,240
bounces and all the kind of nice stuff

00:25:49,210 --> 00:25:54,340
that you want so if you seen make some

00:25:52,240 --> 00:25:57,220
change then you take one note off the

00:25:54,340 --> 00:26:00,639
ear and bring it back and then do the

00:25:57,220 --> 00:26:02,830
next one and you can do a rolling change

00:26:00,639 --> 00:26:05,230
to your cluster without ever it going

00:26:02,830 --> 00:26:06,970
off the air and Bosch is bright enough

00:26:05,230 --> 00:26:09,309
to talk to Hazel Kass and say are you

00:26:06,970 --> 00:26:11,559
actually happy because it's not enough

00:26:09,309 --> 00:26:13,360
to say the JVM is started it's and it's

00:26:11,559 --> 00:26:16,029
you have to then say well make sure all

00:26:13,360 --> 00:26:17,559
their everything's heated itself up and

00:26:16,029 --> 00:26:20,880
it's all ready to go before you do the

00:26:17,559 --> 00:26:23,860
next one so it's fine for controlled

00:26:20,880 --> 00:26:25,330
rollout and if obviously ever machine

00:26:23,860 --> 00:26:28,570
failure will start up another one for

00:26:25,330 --> 00:26:30,220
you it's no different a procedure but

00:26:28,570 --> 00:26:33,159
that's only from version one point a

00:26:30,220 --> 00:26:40,870
onwards which shouldn't really be a

00:26:33,159 --> 00:26:44,320
problem are we on now 110 111 and then

00:26:40,870 --> 00:26:46,480
you can define it as a user mean use

00:26:44,320 --> 00:26:49,000
cups and you can make your own Hazel

00:26:46,480 --> 00:26:50,889
class service and then you need to be

00:26:49,000 --> 00:26:53,169
able to create instances off that

00:26:50,889 --> 00:26:54,789
service and then it's just a binding

00:26:53,169 --> 00:26:57,610
between the client and the server so

00:26:54,789 --> 00:27:00,429
that's that part's easy user provider

00:26:57,610 --> 00:27:01,990
services a bit fiddly but once you've

00:27:00,429 --> 00:27:05,350
done it once you just copy it and paste

00:27:01,990 --> 00:27:09,549
it for the next one so it's really not

00:27:05,350 --> 00:27:13,029
difficult to use the PCF tile thing is

00:27:09,549 --> 00:27:15,039
just an enhancement makes it very very

00:27:13,029 --> 00:27:16,779
simple but if you according it by hand

00:27:15,039 --> 00:27:17,590
it's not not the hardest thing in the

00:27:16,779 --> 00:27:20,020
world

00:27:17,590 --> 00:27:22,270
because it's you know Cloud Foundry

00:27:20,020 --> 00:27:26,050
Foundation silver members is like we're

00:27:22,270 --> 00:27:28,210
not horned in on pivotal it's like Cloud

00:27:26,050 --> 00:27:30,730
Foundry runs and Cloud Foundry you've

00:27:28,210 --> 00:27:32,970
got bluemix or any other then we're fine

00:27:30,730 --> 00:27:32,970
with that

00:27:37,770 --> 00:27:42,750
the end of the day hazel caste is just a

00:27:40,110 --> 00:27:49,970
Java process you run it inside a spring

00:27:42,750 --> 00:27:57,010
booth deployable jar file trivial okay

00:27:49,970 --> 00:28:00,220
one more question yes

00:27:57,010 --> 00:28:00,220
[Music]

00:28:07,149 --> 00:28:11,559
I didn't quite hear your question you're

00:28:09,190 --> 00:28:14,090
asking can when hazel gasps connects to

00:28:11,559 --> 00:28:21,039
an external store

00:28:14,090 --> 00:28:21,039
[Music]

00:28:22,649 --> 00:28:25,649
yeah

00:28:31,869 --> 00:28:37,519
I'm still not 100% sure involved in your

00:28:34,820 --> 00:28:39,950
question but basically if an external

00:28:37,519 --> 00:28:42,409
store is only external to hazel cast if

00:28:39,950 --> 00:28:44,749
its internal Cloud Foundry all the

00:28:42,409 --> 00:28:47,179
really matters is the connection string

00:28:44,749 --> 00:28:49,460
information so you know what's the IP

00:28:47,179 --> 00:28:51,529
address what's the logon password if

00:28:49,460 --> 00:28:53,719
it's like you know if that was like an

00:28:51,529 --> 00:28:55,879
up MySQL instance running in South Cloud

00:28:53,719 --> 00:29:00,080
Foundry you should be able to connect to

00:28:55,879 --> 00:29:01,669
that as long as there's no kind of the

00:29:00,080 --> 00:29:03,289
problem really is the network roots if

00:29:01,669 --> 00:29:08,089
you're outside trying to connect inside

00:29:03,289 --> 00:29:10,129
and TCP gets blocked or that's their the

00:29:08,089 --> 00:29:12,529
the difficulty it's not insurmountable

00:29:10,129 --> 00:29:14,839
it's just a bit fuss if it everything's

00:29:12,529 --> 00:29:17,149
inside then it's a lot simpler because

00:29:14,839 --> 00:29:24,889
Cloud Foundry is just looking after the

00:29:17,149 --> 00:29:27,909
boundary ok I'm done thank you everybody

00:29:24,889 --> 00:29:27,909

YouTube URL: https://www.youtube.com/watch?v=M5jZnE2gkJw


