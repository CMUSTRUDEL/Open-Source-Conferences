Title: Docker & Buildpacks: One App, Two Options for Deploying to Cloud Foundry
Publication date: 2016-09-30
Playlist: Cloud Foundry Summit Europe 2016
Description: 
	Docker & Buildpacks: One App, Two Options for Deploying to Cloud Foundry - Jen Spinney, HPE & James Myers, Pivotal

Now that Cloud Foundry natively supports pushing Docker containers in addition to the traditional approach of constructing an app from a buildpack, end-users have a choice about which strategy to use. In this talk, we’ll walk through pushing the same sample app to Cloud Foundry using both the buildpack and Docker container techniques. 

We’ll discuss the pros and cons of both approaches, and at the end of the talk, attendees will have a better sense of the ‘hows’ and the ‘whys’ of the buildpack and Docker application lifecycles in Cloud Foundry.

About James Myers
James Myers is a software engineer for Pivotal Software and a core contributor to the Cloud Foundry project. James is currently the anchor of the Diego team and has worked on Cloud Foundry for two years. He has presented previously at the 2015 and 2016 North American CF Summits.

About Jen Spinney
Jen Spinney is a software engineer at HP Enterprise, where she works as a core contributor on the CF Diego team. Prior to HPE, she worked at Microsoft on the OData team where she developed a passion for open source and cross-company software development. She pairs remotely from the HPE office in Seattle, WA.
Captions: 
	00:00:00,000 --> 00:00:05,130
thanks for coming welcome to docker and

00:00:02,340 --> 00:00:07,950
build packs one app two options for

00:00:05,130 --> 00:00:09,510
deploying for tequila foundry so first

00:00:07,950 --> 00:00:11,550
let's introduce ourselves I'm James

00:00:09,510 --> 00:00:14,009
Myers I'm a software engineer at pivotal

00:00:11,550 --> 00:00:16,440
I've been on the Diego team for about

00:00:14,009 --> 00:00:18,000
two years I work out of San Francisco

00:00:16,440 --> 00:00:21,570
and I've been on cloud foundry for about

00:00:18,000 --> 00:00:23,670
three years in total and I'm Jen Spinney

00:00:21,570 --> 00:00:25,199
I work for Hewlett Packard Enterprise as

00:00:23,670 --> 00:00:27,269
a software engineer I'm also on the

00:00:25,199 --> 00:00:28,830
Diego team I work out of Seattle

00:00:27,269 --> 00:00:34,170
Washington I've been on the Diego team

00:00:28,830 --> 00:00:35,640
for about a year and a half cool so

00:00:34,170 --> 00:00:37,559
let's talk about what this talk is about

00:00:35,640 --> 00:00:39,360
and what we're trying to get out of it

00:00:37,559 --> 00:00:41,430
so what we're gonna do here is we're

00:00:39,360 --> 00:00:43,950
gonna give you a side-by-side look at

00:00:41,430 --> 00:00:46,050
deploying one application with a build

00:00:43,950 --> 00:00:48,059
pack and with a docker file what that

00:00:46,050 --> 00:00:49,770
means is we're gonna look at the user

00:00:48,059 --> 00:00:51,750
experience like CF push and all that

00:00:49,770 --> 00:00:53,219
stuff as well as what happens in the

00:00:51,750 --> 00:00:54,960
system under the hood and the

00:00:53,219 --> 00:00:57,660
consequences that happen because of it

00:00:54,960 --> 00:00:59,370
we're gonna examine some of the pros and

00:00:57,660 --> 00:01:00,899
cons between each deployment strategy

00:00:59,370 --> 00:01:02,670
and we're hopefully going to give you

00:01:00,899 --> 00:01:07,110
some insight into when you should use

00:01:02,670 --> 00:01:08,570
each of these deployment strategies so

00:01:07,110 --> 00:01:09,930
first we're gonna look at build packs

00:01:08,570 --> 00:01:11,880
both packs

00:01:09,930 --> 00:01:13,860
are the traditional way of deploying

00:01:11,880 --> 00:01:17,700
applications to Cloud Foundry they were

00:01:13,860 --> 00:01:19,470
popular popularized by Heroku and what

00:01:17,700 --> 00:01:22,530
they really are is just a zip file with

00:01:19,470 --> 00:01:24,930
three scripts detect the compile and a

00:01:22,530 --> 00:01:27,210
release and so what what it really does

00:01:24,930 --> 00:01:29,009
is it takes some language runtime and

00:01:27,210 --> 00:01:30,930
some dependencies and your source code

00:01:29,009 --> 00:01:32,930
and then produces an executable thing

00:01:30,930 --> 00:01:34,950
that we like to call a droplet

00:01:32,930 --> 00:01:37,110
essentially build pack apps are your

00:01:34,950 --> 00:01:40,439
source code and the build pack and then

00:01:37,110 --> 00:01:41,400
they just run on a cloud foundry next

00:01:40,439 --> 00:01:43,680
we're going to examine like what is

00:01:41,400 --> 00:01:45,299
darker so docker is the popular

00:01:43,680 --> 00:01:49,229
implementation of containers right now

00:01:45,299 --> 00:01:52,170
so basically a user will or a developer

00:01:49,229 --> 00:01:54,000
will create a container specification in

00:01:52,170 --> 00:01:56,219
a file using directives known as a

00:01:54,000 --> 00:01:58,590
docker file and then they can build and

00:01:56,219 --> 00:02:01,409
run that container locally or on some

00:01:58,590 --> 00:02:02,790
distributed system deploying docker apps

00:02:01,409 --> 00:02:04,409
to cloud foundry is actually a

00:02:02,790 --> 00:02:06,180
relatively new feature that came out

00:02:04,409 --> 00:02:07,350
with the new Diego back-end and we're

00:02:06,180 --> 00:02:10,440
starting to see some users take

00:02:07,350 --> 00:02:12,730
advantage of its functionality

00:02:10,440 --> 00:02:14,740
so throughout this talk we're going to

00:02:12,730 --> 00:02:16,240
be taking one sample application and

00:02:14,740 --> 00:02:19,330
seeing how it works on both the build

00:02:16,240 --> 00:02:21,250
pack way and the docker lifecycle of

00:02:19,330 --> 00:02:23,740
deployment the sample application we

00:02:21,250 --> 00:02:25,990
have here is a super simple golang app

00:02:23,740 --> 00:02:27,540
all it does is it listens on the port

00:02:25,990 --> 00:02:31,300
that it's been instructed to listen on

00:02:27,540 --> 00:02:33,250
for any incoming requests HTTP requests

00:02:31,300 --> 00:02:35,650
as soon as it gets a request it echoes

00:02:33,250 --> 00:02:37,930
back hello CF summit so it's very very

00:02:35,650 --> 00:02:39,730
simple we're using this simple example

00:02:37,930 --> 00:02:41,709
but everything we talk about right now

00:02:39,730 --> 00:02:46,090
applies to you know more complicated

00:02:41,709 --> 00:02:47,590
apps as well so let's say we wanted to

00:02:46,090 --> 00:02:49,989
play this as a build pack application

00:02:47,590 --> 00:02:52,300
our first step is actually to do to just

00:02:49,989 --> 00:02:56,290
open up our editor make that file we

00:02:52,300 --> 00:02:59,440
just saw just a single go file code that

00:02:56,290 --> 00:03:00,880
up and then we're gonna do a CF push you

00:02:59,440 --> 00:03:02,560
can accomplish these next two steps with

00:03:00,880 --> 00:03:04,840
just CF push but we're breaking them

00:03:02,560 --> 00:03:06,940
down into a CF push no start and then a

00:03:04,840 --> 00:03:08,950
CF start in order to explain the

00:03:06,940 --> 00:03:12,070
difference that differences that happen

00:03:08,950 --> 00:03:15,250
between those two steps so when we start

00:03:12,070 --> 00:03:17,320
with a CF push no Start two things

00:03:15,250 --> 00:03:19,420
happen first thing that happens is the

00:03:17,320 --> 00:03:21,700
application bits in this case just that

00:03:19,420 --> 00:03:24,250
main dot go file gets uploaded to the

00:03:21,700 --> 00:03:26,290
cloud controller so this is whatever

00:03:24,250 --> 00:03:27,760
your source code is this is not like

00:03:26,290 --> 00:03:29,290
your language runtime and your

00:03:27,760 --> 00:03:30,430
frameworks and stuff like that that's

00:03:29,290 --> 00:03:32,830
just the code that you wrote

00:03:30,430 --> 00:03:34,420
specifically so now that's upload to the

00:03:32,830 --> 00:03:36,910
cloud controller and an application

00:03:34,420 --> 00:03:38,350
record is also created for this app so

00:03:36,910 --> 00:03:40,030
this application record contains

00:03:38,350 --> 00:03:42,310
information about what the environment

00:03:40,030 --> 00:03:43,989
variables are what the desired number of

00:03:42,310 --> 00:03:47,350
running instances are things like that

00:03:43,989 --> 00:03:49,570
the metadata about the app so one reason

00:03:47,350 --> 00:03:51,610
so here we're splitting out the CF push

00:03:49,570 --> 00:03:53,470
know start and the CF start just for

00:03:51,610 --> 00:03:54,760
illustration purposes but in the real

00:03:53,470 --> 00:03:56,650
world you might really want to do this

00:03:54,760 --> 00:03:58,959
as well in case you want to bind a

00:03:56,650 --> 00:04:00,370
service after you do the CF push you

00:03:58,959 --> 00:04:02,080
want to make sure your app exists in the

00:04:00,370 --> 00:04:03,730
system and then you want to bind the

00:04:02,080 --> 00:04:07,090
service before you actually start the

00:04:03,730 --> 00:04:09,820
app so the next step is actually

00:04:07,090 --> 00:04:11,380
composed of two phases when you do a CF

00:04:09,820 --> 00:04:13,329
start you're actually doing what's

00:04:11,380 --> 00:04:16,810
called staging and then really starting

00:04:13,329 --> 00:04:18,970
the app up so as part of staging we have

00:04:16,810 --> 00:04:21,250
this component called the stager this

00:04:18,970 --> 00:04:23,500
component is a translation layer between

00:04:21,250 --> 00:04:24,370
the cloud controller and Diego it's

00:04:23,500 --> 00:04:26,949
responsible for

00:04:24,370 --> 00:04:29,350
creating a task to tell to diego to

00:04:26,949 --> 00:04:32,139
describe hey i want you to take these

00:04:29,350 --> 00:04:33,940
bits and I want you to combine them with

00:04:32,139 --> 00:04:34,590
a build pack and create a droplet out of

00:04:33,940 --> 00:04:38,229
it

00:04:34,590 --> 00:04:41,440
so Diego gets this request it says hey I

00:04:38,229 --> 00:04:43,690
want you to go make a droplet in this

00:04:41,440 --> 00:04:45,580
case we haven't explicitly specified the

00:04:43,690 --> 00:04:47,350
go build pack so the first thing that's

00:04:45,580 --> 00:04:49,330
going to happen is when this task is

00:04:47,350 --> 00:04:50,979
executed all the build packs are going

00:04:49,330 --> 00:04:52,750
to be brought down that the system knows

00:04:50,979 --> 00:04:54,310
about and each of those build packs is

00:04:52,750 --> 00:04:56,830
going to run its detect script and say

00:04:54,310 --> 00:04:59,050
do I apply to this application in our

00:04:56,830 --> 00:05:00,880
example we have a dot go file so the go

00:04:59,050 --> 00:05:01,690
build pack is going to say hey I can

00:05:00,880 --> 00:05:04,330
handle this one

00:05:01,690 --> 00:05:06,490
and then the go build pack then is

00:05:04,330 --> 00:05:08,530
combined with your with your outfits and

00:05:06,490 --> 00:05:11,020
it will combine together to create an

00:05:08,530 --> 00:05:14,500
executable that can just be run anywhere

00:05:11,020 --> 00:05:17,080
in the CF system so the result then is

00:05:14,500 --> 00:05:19,960
this droplet it gets uploaded to the

00:05:17,080 --> 00:05:21,580
cloud controller database from there the

00:05:19,960 --> 00:05:23,139
next step is the cloud controller wants

00:05:21,580 --> 00:05:25,240
to actually start this out so it's going

00:05:23,139 --> 00:05:27,039
to talk to another translation layer we

00:05:25,240 --> 00:05:28,450
call in sync this is the communication

00:05:27,039 --> 00:05:30,639
between the cloud controller and then

00:05:28,450 --> 00:05:33,270
Diego for actually starting up apps and

00:05:30,639 --> 00:05:37,120
stuff like that so the cloud controller

00:05:33,270 --> 00:05:38,979
says - in sync hey please go tell Diego

00:05:37,120 --> 00:05:41,229
to start running this Diego being the

00:05:38,979 --> 00:05:43,389
backend knows about tasks and

00:05:41,229 --> 00:05:44,710
long-running processes so this is a

00:05:43,389 --> 00:05:46,750
long-running process we want to create

00:05:44,710 --> 00:05:49,270
here in sync is going to look at the

00:05:46,750 --> 00:05:50,770
metadata on this app and put together a

00:05:49,270 --> 00:05:54,370
description of the long-running process

00:05:50,770 --> 00:05:56,830
that Diego needs to go run Diego is then

00:05:54,370 --> 00:05:58,570
going to take that app that lrp

00:05:56,830 --> 00:06:00,699
long-running process and it's going to

00:05:58,570 --> 00:06:02,229
put it on whatever number of containers

00:06:00,699 --> 00:06:03,789
it's gonna find containers on various

00:06:02,229 --> 00:06:07,690
cells where it's going to actually run

00:06:03,789 --> 00:06:09,099
this up and then once it starts running

00:06:07,690 --> 00:06:11,889
Diego is going to make sure it stays

00:06:09,099 --> 00:06:13,900
running and if it gets if it crashes

00:06:11,889 --> 00:06:20,500
it'll restart it on another cell for

00:06:13,900 --> 00:06:21,669
example and stuff like that cool so we

00:06:20,500 --> 00:06:22,990
just talked about deployment with the

00:06:21,669 --> 00:06:25,210
built pack but what about deployment

00:06:22,990 --> 00:06:27,190
with the docker application so once

00:06:25,210 --> 00:06:28,210
again the first step for deploying with

00:06:27,190 --> 00:06:29,979
the dock application is actually

00:06:28,210 --> 00:06:32,560
creating the app itself in your favorite

00:06:29,979 --> 00:06:34,300
editor then after that you actually need

00:06:32,560 --> 00:06:36,660
to make what's called a docker file or

00:06:34,300 --> 00:06:39,180
the container specification

00:06:36,660 --> 00:06:41,100
an example docker file is is this one

00:06:39,180 --> 00:06:43,380
here so there's various directives that

00:06:41,100 --> 00:06:46,530
means some stuff the first one is the

00:06:43,380 --> 00:06:48,330
from directive so this directive I like

00:06:46,530 --> 00:06:50,400
to think of as the root of s or the root

00:06:48,330 --> 00:06:52,770
filesystem and every example previously

00:06:50,400 --> 00:06:54,270
when we talked about containers the

00:06:52,770 --> 00:06:57,120
containers are made with a base image

00:06:54,270 --> 00:06:58,470
that is specified in the deployment here

00:06:57,120 --> 00:07:00,120
in your docker file you actually get to

00:06:58,470 --> 00:07:02,670
change that so you can specify what you

00:07:00,120 --> 00:07:04,410
want boon to trustee or you know in this

00:07:02,670 --> 00:07:07,440
case it's a going image that already has

00:07:04,410 --> 00:07:09,390
going install the next couple of blocks

00:07:07,440 --> 00:07:11,610
are what I like to think of as the

00:07:09,390 --> 00:07:13,380
staging process for docker so here you

00:07:11,610 --> 00:07:14,610
have run directives and add directives

00:07:13,380 --> 00:07:16,830
and a bunch of other ones that they

00:07:14,610 --> 00:07:17,790
expose and what this is does is it's

00:07:16,830 --> 00:07:20,370
going to basically set up the

00:07:17,790 --> 00:07:23,460
dependencies as well as compile your

00:07:20,370 --> 00:07:25,110
application into like a running app we

00:07:23,460 --> 00:07:28,050
also have metadata directives like

00:07:25,110 --> 00:07:29,850
expose and user so you can use these to

00:07:28,050 --> 00:07:31,590
tell the container system or the

00:07:29,850 --> 00:07:33,270
container engine like what you're going

00:07:31,590 --> 00:07:35,490
to do with your application for example

00:07:33,270 --> 00:07:37,080
I'm going to expose port 8080 I might

00:07:35,490 --> 00:07:40,100
say that I want to run with user vcap

00:07:37,080 --> 00:07:42,240
there's a couple things you can do there

00:07:40,100 --> 00:07:43,710
then lastly there's the command

00:07:42,240 --> 00:07:45,360
directive this is basically going to

00:07:43,710 --> 00:07:46,980
specify the process that you're going to

00:07:45,360 --> 00:07:48,720
run inside your container so this is

00:07:46,980 --> 00:07:50,430
where the built pack would figure this

00:07:48,720 --> 00:07:54,120
out for you you're seeing it yourself

00:07:50,430 --> 00:07:55,890
like I want to run my sample app so now

00:07:54,120 --> 00:07:57,930
that we have this docker file and we're

00:07:55,890 --> 00:08:00,360
ready to create it we're going to

00:07:57,930 --> 00:08:01,650
actually build the docker image so the

00:08:00,360 --> 00:08:03,810
two steps that I'm sure most of you are

00:08:01,650 --> 00:08:06,660
familiar with are first of all docker

00:08:03,810 --> 00:08:08,490
build so what this step does is it takes

00:08:06,660 --> 00:08:10,800
that docker file and then for each

00:08:08,490 --> 00:08:12,810
directive it will try and create a layer

00:08:10,800 --> 00:08:14,460
and then basically once you finish

00:08:12,810 --> 00:08:15,960
running this you'll have a local

00:08:14,460 --> 00:08:19,080
container image that you can run and

00:08:15,960 --> 00:08:21,060
experiment with and test out for the

00:08:19,080 --> 00:08:22,920
purposes of Cloud Foundry you're going

00:08:21,060 --> 00:08:25,050
to want to actually run a docker push so

00:08:22,920 --> 00:08:27,270
docker push you need to upload your

00:08:25,050 --> 00:08:29,490
container image to a docker registry

00:08:27,270 --> 00:08:33,510
that's publicly accessible by the cloud

00:08:29,490 --> 00:08:35,760
foundry deployment so now that we have

00:08:33,510 --> 00:08:37,680
our docker image actually uploaded to a

00:08:35,760 --> 00:08:38,940
registry we can start using Cloud

00:08:37,680 --> 00:08:40,650
Foundry to run it

00:08:38,940 --> 00:08:42,150
the first thing once again that we're

00:08:40,650 --> 00:08:44,310
going to do is we're going to split CF

00:08:42,150 --> 00:08:45,690
push which is normally one command into

00:08:44,310 --> 00:08:48,660
two commands to illustrate some of the

00:08:45,690 --> 00:08:50,400
differences so in this case I'm going to

00:08:48,660 --> 00:08:52,620
start with a CF push with the dad

00:08:50,400 --> 00:08:54,420
like so the - Oh flag is what you use to

00:08:52,620 --> 00:08:56,820
specify the dock the location of the

00:08:54,420 --> 00:08:58,500
docker image so all this does in this

00:08:56,820 --> 00:09:00,000
case is it will only create the record

00:08:58,500 --> 00:09:01,680
in the clock controller there's actually

00:09:00,000 --> 00:09:03,300
no reason to upload the application bits

00:09:01,680 --> 00:09:07,589
as they're in they're stored in the

00:09:03,300 --> 00:09:09,330
docker registry already so then you're

00:09:07,589 --> 00:09:11,940
gonna run CF start on your application

00:09:09,330 --> 00:09:13,260
so it's actually surprising but there is

00:09:11,940 --> 00:09:14,970
a staging process for docker

00:09:13,260 --> 00:09:16,589
applications so the first thing that's

00:09:14,970 --> 00:09:18,150
going to happen is going to take that

00:09:16,589 --> 00:09:20,190
metadata that was uploaded to the cloud

00:09:18,150 --> 00:09:21,600
controller and once again it's going to

00:09:20,190 --> 00:09:23,370
talk to the translation layer which is

00:09:21,600 --> 00:09:26,760
the stager so that it can create a task

00:09:23,370 --> 00:09:28,440
on Diego once this task begins running

00:09:26,760 --> 00:09:30,839
on Diego what's going to happen is the

00:09:28,440 --> 00:09:33,060
Diego cell is going to communicate with

00:09:30,839 --> 00:09:35,160
the docker registry and it does this to

00:09:33,060 --> 00:09:36,870
pull down that metadata that you exposed

00:09:35,160 --> 00:09:38,850
in your docker container so that we know

00:09:36,870 --> 00:09:40,380
how to like run your application so the

00:09:38,850 --> 00:09:43,890
port and the start command all that

00:09:40,380 --> 00:09:45,960
stuff once you've done that we actually

00:09:43,890 --> 00:09:49,050
compile this into what we call a docker

00:09:45,960 --> 00:09:50,970
droplet a docker droplet is not actually

00:09:49,050 --> 00:09:52,380
an executable thing it's more of just a

00:09:50,970 --> 00:09:55,800
bag of metadata that we can use to

00:09:52,380 --> 00:09:57,180
execute your docker image so once we do

00:09:55,800 --> 00:09:58,560
that we flow that back to the cloud

00:09:57,180 --> 00:10:02,459
controller and save that into the

00:09:58,560 --> 00:10:04,410
database the next step in the start is

00:10:02,459 --> 00:10:05,459
actually running the application so once

00:10:04,410 --> 00:10:06,779
again we're going to talk to the

00:10:05,459 --> 00:10:09,480
translation layer which is called in

00:10:06,779 --> 00:10:10,800
sync and this is going to create what's

00:10:09,480 --> 00:10:12,959
got what's known as a long-running

00:10:10,800 --> 00:10:15,779
process this long-running process

00:10:12,959 --> 00:10:17,550
instead of specifying the root of s as

00:10:15,779 --> 00:10:20,400
its base image it's going to specify the

00:10:17,550 --> 00:10:22,020
docker image itself when this starts

00:10:20,400 --> 00:10:24,180
running on Diego what's going to happen

00:10:22,020 --> 00:10:26,790
is is Diego's going to communicate with

00:10:24,180 --> 00:10:28,470
the docker registry and it's going to

00:10:26,790 --> 00:10:30,660
actually fetch that docker image and

00:10:28,470 --> 00:10:33,930
pull it down and then run the start

00:10:30,660 --> 00:10:35,580
command inside it once that's happened

00:10:33,930 --> 00:10:37,050
we're going to do the same stuff that we

00:10:35,580 --> 00:10:37,920
do with the build pack app and we're

00:10:37,050 --> 00:10:42,630
going to make sure that your app is

00:10:37,920 --> 00:10:44,459
running and that's pretty much it some

00:10:42,630 --> 00:10:46,589
special things to note for docker and

00:10:44,459 --> 00:10:48,390
garden so garden is actually Claude

00:10:46,589 --> 00:10:51,000
foundries container engine system that

00:10:48,390 --> 00:10:52,589
we use to run containers basically but

00:10:51,000 --> 00:10:55,890
Guardian can also run docker containers

00:10:52,589 --> 00:10:57,720
and what this means is that garden Linux

00:10:55,890 --> 00:11:00,990
and garden run C basically can download

00:10:57,720 --> 00:11:03,279
and fetch the docker image and then they

00:11:00,990 --> 00:11:04,720
just replaced the root filesystem and

00:11:03,279 --> 00:11:07,329
then create a container using this as

00:11:04,720 --> 00:11:08,980
the new root filesystem they also then

00:11:07,329 --> 00:11:12,069
can just launch processes inside this

00:11:08,980 --> 00:11:13,720
container as well as expose ports one

00:11:12,069 --> 00:11:15,189
important thing that's cool and then I'm

00:11:13,720 --> 00:11:17,290
sure if you went to you know will or

00:11:15,189 --> 00:11:19,569
jewel sock this garden run see is now

00:11:17,290 --> 00:11:22,569
running opening container initiative

00:11:19,569 --> 00:11:27,220
compatible images so this process is

00:11:22,569 --> 00:11:29,290
becoming much more standard cool so now

00:11:27,220 --> 00:11:31,029
that we've talked about like how the

00:11:29,290 --> 00:11:32,829
point how the apps get deployed with

00:11:31,029 --> 00:11:35,079
both build packs and docker let's go

00:11:32,829 --> 00:11:36,790
over some scenarios that developers and

00:11:35,079 --> 00:11:40,029
operators are going to run into on a

00:11:36,790 --> 00:11:42,309
daily basis one of the first ones is a

00:11:40,029 --> 00:11:47,350
security vulnerability so let's say you

00:11:42,309 --> 00:11:48,639
get a CVE and open SSL or yeah so if a

00:11:47,350 --> 00:11:49,899
build pack app gets the security

00:11:48,639 --> 00:11:51,670
vulnerability there's two things that

00:11:49,899 --> 00:11:53,800
are important here one is whether or not

00:11:51,670 --> 00:11:57,430
it affects the build pack or the root of

00:11:53,800 --> 00:11:59,290
s so if it affects the root of s the

00:11:57,430 --> 00:12:02,559
developer does not really have to do

00:11:59,290 --> 00:12:03,100
anything they just sit around but the

00:12:02,559 --> 00:12:04,990
operator

00:12:03,100 --> 00:12:06,579
it'll notice that a new root efest

00:12:04,990 --> 00:12:08,319
release has been made which patches this

00:12:06,579 --> 00:12:11,319
and then all they have to do is upload

00:12:08,319 --> 00:12:12,939
this read FS release and redeploy on the

00:12:11,319 --> 00:12:14,709
deploy we're actually going to redeploy

00:12:12,939 --> 00:12:16,809
the cells and they'll get this new rid

00:12:14,709 --> 00:12:18,399
of s so any container that's created

00:12:16,809 --> 00:12:20,529
with this new root of s will be secure

00:12:18,399 --> 00:12:22,569
and ready to go so after a finished

00:12:20,529 --> 00:12:23,769
deploy all build pack apps will actually

00:12:22,569 --> 00:12:27,040
be secure if it's a root of s

00:12:23,769 --> 00:12:28,930
vulnerability the other case is when a

00:12:27,040 --> 00:12:30,910
build pack is vulnerable so it's very

00:12:28,930 --> 00:12:32,110
similar here we're gonna have to the

00:12:30,910 --> 00:12:33,670
operator will notice that the

00:12:32,110 --> 00:12:34,329
application or the build pack is

00:12:33,670 --> 00:12:36,250
insecure

00:12:34,329 --> 00:12:39,389
they'll have to upload a new release and

00:12:36,250 --> 00:12:41,529
deploy or just CF upload the build pack

00:12:39,389 --> 00:12:43,240
once they do this you'll probably have

00:12:41,529 --> 00:12:45,480
to restage your application just to get

00:12:43,240 --> 00:12:48,579
the compiled bits to be changed but then

00:12:45,480 --> 00:12:50,559
we'll be ready to go as if you went to

00:12:48,579 --> 00:12:52,240
the v3 talk pretty soon this might be a

00:12:50,559 --> 00:12:54,399
zero downtime deploy so you know

00:12:52,240 --> 00:12:56,259
downtime for your application this is

00:12:54,399 --> 00:12:58,029
really important to point out that for

00:12:56,259 --> 00:13:00,100
security wise bill packs are great for

00:12:58,029 --> 00:13:02,470
operators and it really defines these

00:13:00,100 --> 00:13:05,470
user roles well so like the operator can

00:13:02,470 --> 00:13:06,910
actually patch a CVE without actually

00:13:05,470 --> 00:13:08,319
knowing anything about the container or

00:13:06,910 --> 00:13:10,509
the application running inside of it and

00:13:08,319 --> 00:13:12,089
it's pretty much the developer does not

00:13:10,509 --> 00:13:14,649
need to be involved

00:13:12,089 --> 00:13:16,629
the second scenario sorry the same

00:13:14,649 --> 00:13:16,970
scenario for docker the developer would

00:13:16,629 --> 00:13:18,620
need

00:13:16,970 --> 00:13:20,149
notice that the CV happened so that's

00:13:18,620 --> 00:13:21,290
one thing that's different the other

00:13:20,149 --> 00:13:23,269
thing is they're gonna actually have to

00:13:21,290 --> 00:13:24,319
rebuild their docker container so what's

00:13:23,269 --> 00:13:27,110
gonna happen is they're gonna need to

00:13:24,319 --> 00:13:29,120
either rerun docker build so that it

00:13:27,110 --> 00:13:30,769
pulls from an updated base image or

00:13:29,120 --> 00:13:33,350
they're gonna need to actually change

00:13:30,769 --> 00:13:36,350
their docker file file itself so that it

00:13:33,350 --> 00:13:38,389
can like no longer be vulnerable once

00:13:36,350 --> 00:13:40,670
they do this they need to repo it to the

00:13:38,389 --> 00:13:42,050
docker registry and then just to be safe

00:13:40,670 --> 00:13:43,459
there you have to restage their

00:13:42,050 --> 00:13:44,899
application so that it pulls any

00:13:43,459 --> 00:13:47,000
metadata that might have changed with

00:13:44,899 --> 00:13:50,180
this document back down and saves it in

00:13:47,000 --> 00:13:51,410
the clock control sometimes CF restart

00:13:50,180 --> 00:13:56,149
might work but it's always a good thing

00:13:51,410 --> 00:13:57,740
to just see if restage another scenario

00:13:56,149 --> 00:13:59,720
we want to talk about in order to

00:13:57,740 --> 00:14:00,949
compare build packs and docker is when

00:13:59,720 --> 00:14:04,069
you're doing local development on your

00:14:00,949 --> 00:14:06,230
apps so in this case we had a go HTTP

00:14:04,069 --> 00:14:08,959
server if I want to do some just quick

00:14:06,230 --> 00:14:10,550
iteration locally and see if I do this

00:14:08,959 --> 00:14:13,040
little change does it bring down my app

00:14:10,550 --> 00:14:14,509
stuff like that we want to look at how

00:14:13,040 --> 00:14:15,009
that works with build packs forces

00:14:14,509 --> 00:14:17,959
docker

00:14:15,009 --> 00:14:19,670
so with build packs your local

00:14:17,959 --> 00:14:22,459
environment if I'm developing this on a

00:14:19,670 --> 00:14:24,350
macbook for example my local environment

00:14:22,459 --> 00:14:25,790
isn't gonna look exactly the same as the

00:14:24,350 --> 00:14:27,230
environment where the app is eventually

00:14:25,790 --> 00:14:29,149
going to be running in it'll probably be

00:14:27,230 --> 00:14:33,350
running in a Linux container up in some

00:14:29,149 --> 00:14:36,230
public cloud or private cloud so as I'm

00:14:33,350 --> 00:14:38,000
doing my local development small things

00:14:36,230 --> 00:14:40,160
might be different I might make certain

00:14:38,000 --> 00:14:41,750
assumptions about certain like library

00:14:40,160 --> 00:14:45,079
that libraries that are available that

00:14:41,750 --> 00:14:46,490
aren't in the other environment or for

00:14:45,079 --> 00:14:48,680
example I might have a different version

00:14:46,490 --> 00:14:51,259
of go on my system I you know might have

00:14:48,680 --> 00:14:52,730
a really outdated version of go and when

00:14:51,259 --> 00:14:54,980
I actually combine it with a build pack

00:14:52,730 --> 00:14:57,139
it's going to use a more recent version

00:14:54,980 --> 00:14:58,790
of go and I don't realize that and I

00:14:57,139 --> 00:15:01,040
have some things in my code that are

00:14:58,790 --> 00:15:02,300
taking it you know they're only working

00:15:01,040 --> 00:15:04,040
because I'm relying on some older

00:15:02,300 --> 00:15:05,540
features of go stuff like that so I'm

00:15:04,040 --> 00:15:07,610
gonna be developing an environment that

00:15:05,540 --> 00:15:09,589
isn't exactly the same as how the and

00:15:07,610 --> 00:15:12,350
how the app is gonna be running up in

00:15:09,589 --> 00:15:15,139
the cloud there are a couple ways to

00:15:12,350 --> 00:15:17,120
deal with this some of you might be

00:15:15,139 --> 00:15:18,889
familiar with bashed light this is like

00:15:17,120 --> 00:15:22,040
a full bosch deployment except it sits

00:15:18,889 --> 00:15:24,259
in one VM on your local machine so you

00:15:22,040 --> 00:15:26,689
could deploy a full Cloud Foundry and

00:15:24,259 --> 00:15:29,660
Diego to a VM on your machine and then

00:15:26,689 --> 00:15:30,829
push to that Cloud Foundry this gives

00:15:29,660 --> 00:15:32,660
you a lot of control you can see the

00:15:30,829 --> 00:15:35,540
logs for the entire Cloud Foundry system

00:15:32,660 --> 00:15:37,009
but it's quite heavy-handed and when

00:15:35,540 --> 00:15:38,959
you're just trying to see does my app

00:15:37,009 --> 00:15:40,819
work or not this is a lot of effort to

00:15:38,959 --> 00:15:43,100
set up and you're probably not actually

00:15:40,819 --> 00:15:44,779
saving any time by doing it this way so

00:15:43,100 --> 00:15:45,769
we really only recommend Bosch late for

00:15:44,779 --> 00:15:48,529
when you're developing Cloud Foundry

00:15:45,769 --> 00:15:52,579
itself or you really want to see the

00:15:48,529 --> 00:15:55,639
detail blogs more common we suggest a

00:15:52,579 --> 00:15:57,290
blue-green style of deployment the idea

00:15:55,639 --> 00:15:59,149
being that you make a small change you

00:15:57,290 --> 00:16:01,069
push your app but you push it to a

00:15:59,149 --> 00:16:03,170
special space that's like a testing

00:16:01,069 --> 00:16:05,720
space or a staging space and your

00:16:03,170 --> 00:16:06,949
real-world traffic isn't being routed to

00:16:05,720 --> 00:16:08,209
this version of the app but you know

00:16:06,949 --> 00:16:10,209
where it is and you can play around with

00:16:08,209 --> 00:16:12,829
it and test out whether it works or not

00:16:10,209 --> 00:16:15,620
the nice thing about this is as soon as

00:16:12,829 --> 00:16:16,879
you validate that your experimental bits

00:16:15,620 --> 00:16:19,429
work the way you want to

00:16:16,879 --> 00:16:21,170
it's very trivial to then go and update

00:16:19,429 --> 00:16:23,420
the route and have all the real world

00:16:21,170 --> 00:16:25,910
traffic routed to your new version of

00:16:23,420 --> 00:16:28,009
the app the downside with this is that

00:16:25,910 --> 00:16:30,199
every time you are doing a small update

00:16:28,009 --> 00:16:31,490
it takes some minutes to do the push so

00:16:30,199 --> 00:16:33,829
it you know might take several minutes

00:16:31,490 --> 00:16:35,720
to actually upload your app fits and

00:16:33,829 --> 00:16:37,519
stuff like that so it is a little bit

00:16:35,720 --> 00:16:39,589
slow if you want to be doing small

00:16:37,519 --> 00:16:40,910
tweaks and see oh if I just change this

00:16:39,589 --> 00:16:42,319
one thing does it bring down the app or

00:16:40,910 --> 00:16:43,519
if you're like debugging if you see that

00:16:42,319 --> 00:16:45,740
your app is crashing and you're trying

00:16:43,519 --> 00:16:47,329
to figure out how it can take a while if

00:16:45,740 --> 00:16:50,929
you have to do a lot of iterations of

00:16:47,329 --> 00:16:52,459
this on the other hand with docker it's

00:16:50,929 --> 00:16:55,100
a bit easier to do some of the local

00:16:52,459 --> 00:16:57,230
development so with docker if you're

00:16:55,100 --> 00:16:58,819
running on Linux you can use docker

00:16:57,230 --> 00:17:00,949
directly if you're using one of the

00:16:58,819 --> 00:17:02,389
other OSS there's probably some system

00:17:00,949 --> 00:17:04,669
out there where you can run docker on a

00:17:02,389 --> 00:17:07,299
virtual machine this allows you to

00:17:04,669 --> 00:17:10,220
really quickly test out your app locally

00:17:07,299 --> 00:17:11,449
make sure that it's running exactly the

00:17:10,220 --> 00:17:13,370
way you want and then when you go and

00:17:11,449 --> 00:17:14,630
actually do the push you know it's going

00:17:13,370 --> 00:17:16,880
to be running in the exact same

00:17:14,630 --> 00:17:19,780
environment as how you tested it locally

00:17:16,880 --> 00:17:24,319
so it just means you can do much quicker

00:17:19,780 --> 00:17:26,059
local iteration based development so

00:17:24,319 --> 00:17:27,919
this is nice especially when you're

00:17:26,059 --> 00:17:30,049
doing more edge KC kind of things or

00:17:27,919 --> 00:17:32,510
when you're doing troubleshooting things

00:17:30,049 --> 00:17:34,100
don't go super well the first time or

00:17:32,510 --> 00:17:37,419
you're using more advanced features that

00:17:34,100 --> 00:17:39,530
the build packs don't provide for you

00:17:37,419 --> 00:17:41,540
another scenario we want to talk about

00:17:39,530 --> 00:17:43,590
is when you want to port the app between

00:17:41,540 --> 00:17:45,900
different providers for example

00:17:43,590 --> 00:17:47,460
so the great thing about open source is

00:17:45,900 --> 00:17:49,710
it you know if you're unhappy with

00:17:47,460 --> 00:17:51,450
whatever vendor your youth using you can

00:17:49,710 --> 00:17:54,990
take your app and go to another vendor

00:17:51,450 --> 00:17:57,150
and it'll just work so for build packs

00:17:54,990 --> 00:18:00,150
for both build packs and docker and this

00:17:57,150 --> 00:18:02,160
is pretty easy to do for the build pack

00:18:00,150 --> 00:18:04,110
scenario build packs originally came

00:18:02,160 --> 00:18:06,900
from Heroku so you can run things on

00:18:04,110 --> 00:18:09,590
Heroku you if you want you can also run

00:18:06,900 --> 00:18:12,690
on one of the many CF vendors out there

00:18:09,590 --> 00:18:14,250
we have this CF certified program and we

00:18:12,690 --> 00:18:16,890
have a number of different vendors that

00:18:14,250 --> 00:18:19,800
are all running that all have their own

00:18:16,890 --> 00:18:21,930
cloud foundry and so you can just move

00:18:19,800 --> 00:18:24,120
it to one of those vendors you can also

00:18:21,930 --> 00:18:26,640
you know the there's nothing about your

00:18:24,120 --> 00:18:29,520
app that's specific to build packs the

00:18:26,640 --> 00:18:30,780
way the build pack style works is you

00:18:29,520 --> 00:18:32,670
don't have to know that you're running

00:18:30,780 --> 00:18:33,960
inside Cloud Foundry in general you

00:18:32,670 --> 00:18:35,250
might be looking for specific

00:18:33,960 --> 00:18:36,900
environment variables but other than

00:18:35,250 --> 00:18:38,220
that it's not that different from how

00:18:36,900 --> 00:18:39,930
you would just write an app that would

00:18:38,220 --> 00:18:42,840
run on a bare metal machine so you could

00:18:39,930 --> 00:18:45,810
also do that if you wanted to with

00:18:42,840 --> 00:18:48,360
docker there are also numerous providers

00:18:45,810 --> 00:18:50,940
out there that can run docker images so

00:18:48,360 --> 00:18:53,280
it's pretty similar in both cases you

00:18:50,940 --> 00:18:55,560
have like a big ecosystem of different

00:18:53,280 --> 00:18:59,880
platforms that can you can port your app

00:18:55,560 --> 00:19:01,830
to so in summary we want to just go

00:18:59,880 --> 00:19:04,680
through the pros and cons of build packs

00:19:01,830 --> 00:19:06,450
and docker in general with build packs

00:19:04,680 --> 00:19:08,850
the idea is it just works and it's

00:19:06,450 --> 00:19:12,330
supposed to work for the like 90% use

00:19:08,850 --> 00:19:15,810
case not for the weird edge cases when

00:19:12,330 --> 00:19:19,440
you want to use a super beta version of

00:19:15,810 --> 00:19:21,540
go for example but for the majority of

00:19:19,440 --> 00:19:23,460
uses we expect build packs to be a lot

00:19:21,540 --> 00:19:24,960
faster and easier to develop with you

00:19:23,460 --> 00:19:27,840
just worry about your source you just

00:19:24,960 --> 00:19:29,460
push your source and it just works you

00:19:27,840 --> 00:19:31,950
get automatic and constant security

00:19:29,460 --> 00:19:34,830
updates so you as a developer don't have

00:19:31,950 --> 00:19:36,480
to be worried about this and all you

00:19:34,830 --> 00:19:40,020
need to do is focus on writing your own

00:19:36,480 --> 00:19:41,130
code cons is it's difficult when

00:19:40,020 --> 00:19:42,660
something goes wrong doing

00:19:41,130 --> 00:19:44,780
troubleshooting locally and that local

00:19:42,660 --> 00:19:46,980
development takes up a little bit longer

00:19:44,780 --> 00:19:48,930
and there's a little bit of a black box

00:19:46,980 --> 00:19:50,790
with the build pack you don't get the

00:19:48,930 --> 00:19:52,830
output you don't actually get to play

00:19:50,790 --> 00:19:55,290
around with that droplet so that result

00:19:52,830 --> 00:19:56,280
of the staging you don't get to see what

00:19:55,290 --> 00:19:59,370
that really is

00:19:56,280 --> 00:20:01,410
so there's a little bit of you know

00:19:59,370 --> 00:20:02,940
we'll handle this for you going on there

00:20:01,410 --> 00:20:04,140
so you have a little bit less control

00:20:02,940 --> 00:20:06,300
and a little bit less insight into

00:20:04,140 --> 00:20:09,030
what's actually happening on the other

00:20:06,300 --> 00:20:11,480
hand with docker the basic idea is you

00:20:09,030 --> 00:20:14,040
have more control which means more work

00:20:11,480 --> 00:20:17,430
but you can tweak whatever you need to

00:20:14,040 --> 00:20:19,380
tweak so you can run that like super new

00:20:17,430 --> 00:20:22,080
version of you know go that's

00:20:19,380 --> 00:20:23,790
experimental and not released yet you

00:20:22,080 --> 00:20:27,060
can also do your local development much

00:20:23,790 --> 00:20:29,250
quicker but on the flip side it means

00:20:27,060 --> 00:20:30,690
more work for you if for example there's

00:20:29,250 --> 00:20:32,370
a security update or something like that

00:20:30,690 --> 00:20:34,740
and generally you're just more in

00:20:32,370 --> 00:20:37,320
control so it's the typical software

00:20:34,740 --> 00:20:41,910
engineering trade-off of more control

00:20:37,320 --> 00:20:43,650
means more work for you the sample app

00:20:41,910 --> 00:20:45,090
that we displayed here and we talked

00:20:43,650 --> 00:20:49,140
about through this talk is available in

00:20:45,090 --> 00:20:51,000
github we also have our all of our Cloud

00:20:49,140 --> 00:20:54,330
Foundry repositories on github as well

00:20:51,000 --> 00:20:56,280
under github.com slash Cloud Foundry you

00:20:54,330 --> 00:20:57,300
can talk to us on the Diego team on our

00:20:56,280 --> 00:20:59,700
slack Channel

00:20:57,300 --> 00:21:03,870
it's Cloud Foundry slack comm and the

00:20:59,700 --> 00:21:06,140
channel is Diego with that are there any

00:21:03,870 --> 00:21:06,140
questions

00:21:06,730 --> 00:21:09,900
[Music]

00:21:15,409 --> 00:21:18,989
so for the purposes of this talk we're

00:21:17,759 --> 00:21:27,599
trying to keep it mainly open source

00:21:18,989 --> 00:21:29,219
related so yeah okay I actually haven't

00:21:27,599 --> 00:21:30,929
had any personal experience with PCF dev

00:21:29,219 --> 00:21:32,219
but I imagine since it's similar to a

00:21:30,929 --> 00:21:41,519
Bosch light environment it would

00:21:32,219 --> 00:21:43,200
probably work as well I would not

00:21:41,519 --> 00:21:44,849
imagine so they're still running on the

00:21:43,200 --> 00:22:14,969
same execution agents which are the

00:21:44,849 --> 00:22:17,309
cells yes so you could do that but if

00:22:14,969 --> 00:22:18,899
you like for example develop it first

00:22:17,309 --> 00:22:21,179
with docker and then want to make it run

00:22:18,899 --> 00:22:23,070
as a build pack there's really no point

00:22:21,179 --> 00:22:24,809
in doing at that point once you've got

00:22:23,070 --> 00:22:27,690
it working as docker I would just use it

00:22:24,809 --> 00:22:29,580
as docker because when you run as docker

00:22:27,690 --> 00:22:31,049
you're going to be using your own custom

00:22:29,580 --> 00:22:33,109
route efest that you're bringing and

00:22:31,049 --> 00:22:35,339
you're saying I want this to be my base

00:22:33,109 --> 00:22:37,589
filesystem and that's gonna have slight

00:22:35,339 --> 00:22:39,179
differences with how the build pack

00:22:37,589 --> 00:22:42,389
style apps are run and stuff like that

00:22:39,179 --> 00:22:43,710
but in like a given organization you

00:22:42,389 --> 00:22:45,509
might find there are certain apps that

00:22:43,710 --> 00:22:46,799
are more tailored towards build packs

00:22:45,509 --> 00:22:49,469
and certain apps that are more tailored

00:22:46,799 --> 00:22:51,839
towards docker so the apps that are more

00:22:49,469 --> 00:22:53,969
basic not touching a bunch of edge cases

00:22:51,839 --> 00:22:55,799
don't really require a ton of

00:22:53,969 --> 00:22:58,619
customization those would generally be

00:22:55,799 --> 00:22:59,849
better with build packs and docker is

00:22:58,619 --> 00:23:00,960
when you need a little bit more finer

00:22:59,849 --> 00:23:04,379
grained control but for a given

00:23:00,960 --> 00:23:05,879
application it I don't think it makes

00:23:04,379 --> 00:23:08,330
that much sense to mix the two

00:23:05,879 --> 00:23:11,009
strategies for the same application I

00:23:08,330 --> 00:23:13,229
think some of the trade-offs you get you

00:23:11,009 --> 00:23:14,909
might maybe you want to do it is if you

00:23:13,229 --> 00:23:16,109
get security updates automatically so

00:23:14,909 --> 00:23:18,179
that's like the one case so if you

00:23:16,109 --> 00:23:19,440
prefer docker for development and then

00:23:18,179 --> 00:23:22,499
you want the security updates for free

00:23:19,440 --> 00:23:23,700
using build pack might work the other

00:23:22,499 --> 00:23:25,590
thing is I think that

00:23:23,700 --> 00:23:27,450
if and some previous talks this summit

00:23:25,590 --> 00:23:29,490
we might there are some ideas about

00:23:27,450 --> 00:23:31,500
combining the flows into a more stable

00:23:29,490 --> 00:23:32,790
thing so there might be something along

00:23:31,500 --> 00:23:58,140
that lines in the future but I haven't

00:23:32,790 --> 00:23:59,760
heard much you would be responsible for

00:23:58,140 --> 00:24:01,500
doing that inside your docker image so

00:23:59,760 --> 00:24:07,050
you specify in your docker file most

00:24:01,500 --> 00:24:09,230
likely so the question was about agents

00:24:07,050 --> 00:24:11,880
like for logging and stuff like that and

00:24:09,230 --> 00:24:14,070
agents that come along for free when you

00:24:11,880 --> 00:24:16,080
use the build pack style does that

00:24:14,070 --> 00:24:19,620
happen also with docker and the answer

00:24:16,080 --> 00:24:21,420
is no when you have a docker when you

00:24:19,620 --> 00:24:22,560
have a docker app you have to you have

00:24:21,420 --> 00:24:24,360
to take care of all that stuff yourself

00:24:22,560 --> 00:24:26,370
like if you want to have specific agents

00:24:24,360 --> 00:24:28,890
that deal with metrics and logging or or

00:24:26,370 --> 00:24:30,420
whatever specific thing you need you

00:24:28,890 --> 00:24:31,740
have to include those yourself because

00:24:30,420 --> 00:24:33,950
those those are properties of the build

00:24:31,740 --> 00:24:33,950
packs

00:24:35,150 --> 00:24:38,339
[Music]

00:24:39,480 --> 00:24:42,470
see that one more time

00:24:45,130 --> 00:24:48,370
that's a good question for the Container

00:24:47,110 --> 00:24:50,110
networking team but no I don't think

00:24:48,370 --> 00:24:52,929
they support that quite yet but it's in

00:24:50,110 --> 00:24:54,760
the horizon sorry the question was

00:24:52,929 --> 00:24:56,650
whether or not garden supports container

00:24:54,760 --> 00:24:57,790
linking over the network there's a

00:24:56,650 --> 00:25:00,160
container networking team that's

00:24:57,790 --> 00:25:01,450
responsible for that right now so it's

00:25:00,160 --> 00:25:03,150
not finished but I think it's coming

00:25:01,450 --> 00:25:06,390
soon

00:25:03,150 --> 00:25:06,390
[Music]

00:25:24,470 --> 00:25:27,860
yeah so that's one of the cool things

00:25:26,120 --> 00:25:30,680
with that from Directive is you can

00:25:27,860 --> 00:25:32,240
actually specify a base image so if

00:25:30,680 --> 00:25:33,650
you're worried about skew across docker

00:25:32,240 --> 00:25:35,240
images you can always have your

00:25:33,650 --> 00:25:37,280
organization create a base image that

00:25:35,240 --> 00:25:40,990
you'd like people to build off on off of

00:25:37,280 --> 00:25:40,990
that's always a way to do that

00:25:41,440 --> 00:25:44,640
[Music]

00:25:47,620 --> 00:25:53,559
thank you sounds good

00:25:49,920 --> 00:25:53,559

YouTube URL: https://www.youtube.com/watch?v=1AwN9Nqc688


