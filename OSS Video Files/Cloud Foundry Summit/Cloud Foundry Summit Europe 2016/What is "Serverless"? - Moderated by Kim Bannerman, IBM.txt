Title: What is "Serverless"? - Moderated by Kim Bannerman, IBM
Publication date: 2016-09-30
Playlist: Cloud Foundry Summit Europe 2016
Description: 
	What is "Serverless"? - Moderated by Kim Bannerman, IBM; Kenny Bastani, Ruben Orduz, Jason Kennedy, & Tyler Britten, IBM, Casey West & Kenny Bastani, Pivotal

We all have heard these "Serverless" or "NoOps" buzzwords lately. So, why do these matter? How does it affect Cloud Foundry? Are they affronts or sources of impulse for the platform and community and CF technology? Should CF take a stance or just let the buzz fizz? 

The thrust and motivation of this panel is the increased (mis)use of buzzwords like "serverless" and "NoOps" floating around and how those tend to be conflated with other technologies like PaaS, CF, and other fast-deployment technologies. 

Please note it's not supposed to be a critique or the merits of the technologies discussed. It's a constructive and educational panel on the nomenclature and messaging and how that impacts Cloud Foundry and the tech community at large.

About Kim Bannerman
Kim Bannerman leads the Technical Advocacy & Community team inside the Office of the CTO at IBM Blue Box. Kim has over a decade of experience in the tech industry working with enterprise customers. Prior to joining Blue Box, she was the Director of Evangelism Programs inside the ISV Partner Ecosystem at CenturyLink Cloud.

Kim is passionate about open source and the open source community. She co-founded the Atlanta Hadoop Users Group in 2011, and co-founded the Seattle & Atlanta Cloud Foundry meet-up groups in 2014. You can follow her on twitter at @kmbannerman

About Ruben Orduz
Enterprise software developer for over a decade. Cloud architect and advocate for five years. FOSS enthusiast and advocate. Obsessed with improving user and developer experiences.

About Casey West
Working in Internet infrastructure, web app security, and design taught Casey to be a paranoid, UX-oriented, problem solving Internet plumber; his earliest contributions to Perl live to this day on your Mac. Casey’s speaking and writing ranges from open source communities and culture to technical architecture and automation tips and tricks. Casey West wears the mantle of Principal Technologist focused on Pivotal’s Cloud Foundry Platform and lives in Pittsburgh raising three sarcastic children.
Captions: 
	00:00:00,060 --> 00:00:04,440
welcome to our panel on what is

00:00:01,979 --> 00:00:05,850
serverless so I'm sure some of you set

00:00:04,440 --> 00:00:07,620
it on a couple sessions today on the

00:00:05,850 --> 00:00:10,349
deep dive in different ways to do

00:00:07,620 --> 00:00:11,969
survivalists different projects this

00:00:10,349 --> 00:00:13,920
panel started out by I was having a

00:00:11,969 --> 00:00:15,509
conversation and a couple different

00:00:13,920 --> 00:00:17,039
cities at the same time ever slack and

00:00:15,509 --> 00:00:18,270
just said hey it's a buzzword we should

00:00:17,039 --> 00:00:21,869
do a panel on it and really talk about

00:00:18,270 --> 00:00:22,560
what it is so that's how it started so

00:00:21,869 --> 00:00:26,400
I'm gonna let everyone introduce

00:00:22,560 --> 00:00:28,920
themselves just hey my name is Reuben or

00:00:26,400 --> 00:00:33,530
dues I work as a developer advocate for

00:00:28,920 --> 00:00:35,940
the office of the CTO and IBM blue box

00:00:33,530 --> 00:00:38,160
thank you for being here and you know we

00:00:35,940 --> 00:00:40,920
really hope that you guys at least get

00:00:38,160 --> 00:00:42,780
something out of this hi everyone i'm

00:00:40,920 --> 00:00:46,289
kenny Bustani I'm a spring developer

00:00:42,780 --> 00:00:48,239
advocate at pivotal I'm KC West

00:00:46,289 --> 00:00:50,039
principal technologist for cloud foundry

00:00:48,239 --> 00:00:51,500
at pivotal and frankly I hope I get

00:00:50,039 --> 00:00:53,969
something out of this

00:00:51,500 --> 00:00:57,329
I'm Tyler Britton a developer advocate

00:00:53,969 --> 00:00:59,059
for IBM for blue box as well and I'm Kim

00:00:57,329 --> 00:01:03,440
Bannerman I'm office of the CTO but

00:00:59,059 --> 00:01:05,159
technical advocate team at blue box IBM

00:01:03,440 --> 00:01:08,049
Oh

00:01:05,159 --> 00:01:10,830
so beyond the technology buzzword folks

00:01:08,049 --> 00:01:14,820
what is service

00:01:10,830 --> 00:01:23,460
alright I have the mic so I'm taking

00:01:14,820 --> 00:01:24,870
control Trump style yeah so to me you

00:01:23,460 --> 00:01:26,130
know it's same I think a lot of people

00:01:24,870 --> 00:01:27,630
with similar reactions serverless like

00:01:26,130 --> 00:01:30,060
well there's definitely servers so

00:01:27,630 --> 00:01:31,440
what's the server list thing and I think

00:01:30,060 --> 00:01:35,190
it's just the the move up to that next

00:01:31,440 --> 00:01:36,450
level of abstraction so term I've heard

00:01:35,190 --> 00:01:39,090
recently that I like a little more

00:01:36,450 --> 00:01:40,740
function as a service so the idea of a

00:01:39,090 --> 00:01:43,520
subset of code that does a specific

00:01:40,740 --> 00:01:46,710
thing that runs when it's called

00:01:43,520 --> 00:01:47,970
event-driven computing is decent - I

00:01:46,710 --> 00:01:51,290
think that's fair

00:01:47,970 --> 00:01:54,390
so who else is old and remembers CGI's

00:01:51,290 --> 00:01:56,490
yeah so I feel like it's it's everything

00:01:54,390 --> 00:01:58,320
up until the request and event loop

00:01:56,490 --> 00:02:00,980
being handled by something else which is

00:01:58,320 --> 00:02:03,330
kind of like how CGI is used to roll

00:02:00,980 --> 00:02:05,970
except there are some better some more

00:02:03,330 --> 00:02:07,950
enhancements for performance but that's

00:02:05,970 --> 00:02:10,350
that's how I see it - it's it's a

00:02:07,950 --> 00:02:14,310
function and it's about what you can

00:02:10,350 --> 00:02:16,800
abstract and then allow a provider to

00:02:14,310 --> 00:02:18,360
give you that you can trust and it used

00:02:16,800 --> 00:02:20,580
to be that that we couldn't do that with

00:02:18,360 --> 00:02:22,800
things like the the actual server that

00:02:20,580 --> 00:02:25,080
manages the request the request

00:02:22,800 --> 00:02:27,310
management and the i/o loops but but now

00:02:25,080 --> 00:02:30,340
we seem seems we can

00:02:27,310 --> 00:02:32,140
so I like to think that serverless is

00:02:30,340 --> 00:02:34,750
again functions I agree with both of you

00:02:32,140 --> 00:02:36,670
but I I think too it kind of fills a gap

00:02:34,750 --> 00:02:40,000
a switch when it comes to integration

00:02:36,670 --> 00:02:43,480
where you want to deploy just this one

00:02:40,000 --> 00:02:44,560
piece of code and you typically like in

00:02:43,480 --> 00:02:46,360
the past when it comes to integration

00:02:44,560 --> 00:02:48,640
you might have like a sequel server

00:02:46,360 --> 00:02:51,400
agent job and it's just very easy to

00:02:48,640 --> 00:02:52,720
change it's easy to deploy I think that

00:02:51,400 --> 00:02:54,069
we have other questions later that I'm

00:02:52,720 --> 00:02:55,660
going to talk about why you shouldn't

00:02:54,069 --> 00:02:59,290
actually use it for a full application

00:02:55,660 --> 00:03:02,320
but that's pretty much it pretty much in

00:02:59,290 --> 00:03:05,440
agreement with them just to me them a

00:03:02,320 --> 00:03:08,019
motivator is you know debunk that

00:03:05,440 --> 00:03:10,330
buzzword you see it although the social

00:03:08,019 --> 00:03:11,950
media people are abusing it you know

00:03:10,330 --> 00:03:13,269
several Isaiah serverless asked what

00:03:11,950 --> 00:03:14,920
does that even mean right so this is

00:03:13,269 --> 00:03:16,239
that it's a question that I want you all

00:03:14,920 --> 00:03:17,980
to ask yourselves when you see something

00:03:16,239 --> 00:03:19,239
server less what exactly do you mean by

00:03:17,980 --> 00:03:21,010
that because there are servers back

00:03:19,239 --> 00:03:23,400
there and there's a lot of things that

00:03:21,010 --> 00:03:23,400
go into that

00:03:23,760 --> 00:03:32,040
speaking of Kinney what are the good use

00:03:25,950 --> 00:03:35,099
cases you want to go okay I'm called

00:03:32,040 --> 00:03:37,590
that alright so as far as use cases from

00:03:35,099 --> 00:03:39,360
from what I looked at doing some

00:03:37,590 --> 00:03:40,799
research because I haven't actually

00:03:39,360 --> 00:03:43,920
built a full application with it I don't

00:03:40,799 --> 00:03:46,140
know if many people have but it really

00:03:43,920 --> 00:03:47,940
kind of feels for me a big use case it

00:03:46,140 --> 00:03:49,709
fills this gap where you might want to

00:03:47,940 --> 00:03:51,420
have an API gateway on top of a legacy

00:03:49,709 --> 00:03:52,799
system so you need a way to integrate

00:03:51,420 --> 00:03:56,670
with a legacy system you want to do

00:03:52,799 --> 00:03:57,930
translation from soap XML to JSON maybe

00:03:56,670 --> 00:03:59,370
you have some other business logic in

00:03:57,930 --> 00:04:01,859
there I think it should be lightweight I

00:03:59,370 --> 00:04:03,780
think that it should be dumb in a way

00:04:01,859 --> 00:04:05,790
not smart and try to do too many things

00:04:03,780 --> 00:04:07,980
with routing but a simple translation

00:04:05,790 --> 00:04:09,870
layer that you can put on top of your

00:04:07,980 --> 00:04:12,859
legacy system and maybe then integrate

00:04:09,870 --> 00:04:12,859
with a micro service architecture

00:04:14,720 --> 00:04:19,199
okay I suppose that some depth of stale

00:04:17,160 --> 00:04:21,720
dovetails with some of the things that

00:04:19,199 --> 00:04:24,330
I've seen background jobs data

00:04:21,720 --> 00:04:26,190
processing anything with discrete inputs

00:04:24,330 --> 00:04:27,979
and outputs with relatively low side

00:04:26,190 --> 00:04:30,449
effects this kind of comes back to

00:04:27,979 --> 00:04:32,880
functional functions as a service

00:04:30,449 --> 00:04:35,699
functional programming models where you

00:04:32,880 --> 00:04:38,190
can you can rely on a function today of

00:04:35,699 --> 00:04:40,620
the same way to have relatively low side

00:04:38,190 --> 00:04:43,290
effects and and then you can get a lot

00:04:40,620 --> 00:04:45,210
of benefit out of maybe fanning out a

00:04:43,290 --> 00:04:47,460
large number of instances of these

00:04:45,210 --> 00:04:48,720
things and the other thing that that I

00:04:47,460 --> 00:04:50,190
see sort of from an operational

00:04:48,720 --> 00:04:53,010
perspective is the opportunity for more

00:04:50,190 --> 00:04:54,840
efficiency and resource utilization if

00:04:53,010 --> 00:04:56,490
your process only runs when it's called

00:04:54,840 --> 00:04:59,220
even if it's run you know millions of

00:04:56,490 --> 00:05:02,729
times a minute or something then you're

00:04:59,220 --> 00:05:05,070
still able to reuse hardware and

00:05:02,729 --> 00:05:06,750
physical resources more efficiently than

00:05:05,070 --> 00:05:08,580
if you have long running processes stuck

00:05:06,750 --> 00:05:12,060
in memory all the time maybe being idle

00:05:08,580 --> 00:05:14,760
more often than they're not yeah I think

00:05:12,060 --> 00:05:16,580
to me anytime you know if you're looking

00:05:14,760 --> 00:05:19,020
at a whole block of code for a

00:05:16,580 --> 00:05:21,090
application and there's a piece that you

00:05:19,020 --> 00:05:23,010
you know described it as it waits for

00:05:21,090 --> 00:05:25,289
this to happen and then it does this

00:05:23,010 --> 00:05:27,150
thing are really good fits for this type

00:05:25,289 --> 00:05:28,740
of methodology because you can say it's

00:05:27,150 --> 00:05:31,139
not running when it's waiting it only

00:05:28,740 --> 00:05:32,340
gets it gets woken up and run and I

00:05:31,139 --> 00:05:33,630
think the other piece you hit on is

00:05:32,340 --> 00:05:36,440
really important is the scalability of

00:05:33,630 --> 00:05:40,200
it so those types of jobs generally are

00:05:36,440 --> 00:05:41,970
single threaded that are doing one

00:05:40,200 --> 00:05:43,830
specific thing say working on one file

00:05:41,970 --> 00:05:45,630
or one piece of data it's crunching so

00:05:43,830 --> 00:05:47,729
they're easy you can make them parallel

00:05:45,630 --> 00:05:49,860
really easily and that's where the

00:05:47,729 --> 00:05:53,130
scalability comes in so let's say you're

00:05:49,860 --> 00:05:56,039
your function is whether it's an API

00:05:53,130 --> 00:05:57,389
call or it's a it's processing in an

00:05:56,039 --> 00:05:59,490
image file or something like that

00:05:57,389 --> 00:06:01,620
you're basically spinning up an instance

00:05:59,490 --> 00:06:03,810
for each event so if you get 10 million

00:06:01,620 --> 00:06:05,130
API calls one day you're spinning up ten

00:06:03,810 --> 00:06:06,570
million instances to do that job and

00:06:05,130 --> 00:06:08,340
finish it and the next day you could may

00:06:06,570 --> 00:06:10,740
spin up five hundred so it gives you

00:06:08,340 --> 00:06:12,960
that that flexibility for something

00:06:10,740 --> 00:06:15,389
that's relatively stateless just what

00:06:12,960 --> 00:06:17,070
that individual job has to do and then

00:06:15,389 --> 00:06:19,260
it gives you that that scalability

00:06:17,070 --> 00:06:21,479
versus you know a model like whether

00:06:19,260 --> 00:06:23,430
using physical servers even as where you

00:06:21,479 --> 00:06:25,140
have workers if you will so if it gets

00:06:23,430 --> 00:06:26,040
busy I need to spin up more workers or I

00:06:25,140 --> 00:06:27,930
spin down work

00:06:26,040 --> 00:06:29,700
in this case it's happening at the

00:06:27,930 --> 00:06:31,970
individual job level and it's much more

00:06:29,700 --> 00:06:31,970
granular

00:06:37,680 --> 00:06:42,460
and what nodejs has been doing for like

00:06:40,389 --> 00:06:44,110
by that you would say that for the

00:06:42,460 --> 00:06:46,300
questions what's the difference between

00:06:44,110 --> 00:06:57,430
what nodejs has been doing for however

00:06:46,300 --> 00:07:02,129
many years and Cerberus what sorry no I

00:06:57,430 --> 00:07:04,810
was gonna finish the thought you guys so

00:07:02,129 --> 00:07:06,370
one actual application that assigned a

00:07:04,810 --> 00:07:09,129
well was what if some former colleagues

00:07:06,370 --> 00:07:10,930
they're trying to with server list these

00:07:09,129 --> 00:07:14,080
small functions that get called every

00:07:10,930 --> 00:07:16,419
time that and they have no problem with

00:07:14,080 --> 00:07:18,879
in here probably concurrency they have

00:07:16,419 --> 00:07:22,150
no problem accessing the database etc so

00:07:18,879 --> 00:07:23,229
like well any use case that you can that

00:07:22,150 --> 00:07:25,180
you don't have to worry so much about

00:07:23,229 --> 00:07:26,620
again like it writes through the

00:07:25,180 --> 00:07:28,300
database will reach the other ways that

00:07:26,620 --> 00:07:30,309
is not that type of thing they lend

00:07:28,300 --> 00:07:33,990
themselves really well for these

00:07:30,309 --> 00:07:33,990
services architectures so to speak

00:07:36,259 --> 00:07:45,740
do we want to sound good

00:07:47,099 --> 00:07:55,229
so um note has a the event loop that's

00:07:52,370 --> 00:07:56,639
that's pretty well handled and

00:07:55,229 --> 00:07:58,919
abstracted and I think that this is

00:07:56,639 --> 00:08:01,139
actually just the model again where this

00:07:58,919 --> 00:08:03,120
is what I keep going back to where the

00:08:01,139 --> 00:08:04,860
event loop is externalized and handled

00:08:03,120 --> 00:08:07,169
by a third-party provider that you can

00:08:04,860 --> 00:08:09,440
rely on I'll use I'll use the term

00:08:07,169 --> 00:08:12,389
vendor to very loosely mean someone else

00:08:09,440 --> 00:08:14,130
to provide you a reliable event loop so

00:08:12,389 --> 00:08:16,800
that you can execute small bits of code

00:08:14,130 --> 00:08:19,020
in memory efficiently and then and then

00:08:16,800 --> 00:08:21,240
get those resources back when it's done

00:08:19,020 --> 00:08:22,199
to you know be used for other things so

00:08:21,240 --> 00:08:24,500
I don't think there's a lot of

00:08:22,199 --> 00:08:24,500
difference

00:08:25,710 --> 00:08:30,050
so what aren't good bets what's a bad

00:08:27,750 --> 00:08:30,050
fit

00:08:32,870 --> 00:08:37,050
so I think a bad fit would probably be

00:08:35,459 --> 00:08:39,450
building your entire application let's

00:08:37,050 --> 00:08:41,610
say you're primarily programming in Java

00:08:39,450 --> 00:08:44,159
and you want to build your entire

00:08:41,610 --> 00:08:46,290
application architecture as serverless

00:08:44,159 --> 00:08:47,850
with functions essentially and we're

00:08:46,290 --> 00:08:49,649
already doing that it becomes it comes

00:08:47,850 --> 00:08:52,440
down to the unit of deployment you know

00:08:49,649 --> 00:08:54,810
how much business logic do you want to

00:08:52,440 --> 00:08:57,000
be able to deploy independently of one

00:08:54,810 --> 00:08:59,760
another so I think that a bad fit

00:08:57,000 --> 00:09:02,070
probably would be going serverless first

00:08:59,760 --> 00:09:04,110
and building an entire server server

00:09:02,070 --> 00:09:05,459
list architecture because we're already

00:09:04,110 --> 00:09:06,720
doing kind of that with micro services

00:09:05,459 --> 00:09:08,699
but we're building around business

00:09:06,720 --> 00:09:11,370
capabilities with micro services it's

00:09:08,699 --> 00:09:13,880
well-defined there's really not a lot of

00:09:11,370 --> 00:09:16,110
I guess stories out there with success

00:09:13,880 --> 00:09:18,290
with service I think it's early days

00:09:16,110 --> 00:09:18,290
still

00:09:19,509 --> 00:09:25,490
as I mentioned previously if bad use

00:09:23,240 --> 00:09:28,279
cases would be a code that you need to

00:09:25,490 --> 00:09:29,750
put there for events that require some

00:09:28,279 --> 00:09:32,570
sort of synchronicity or some sort of

00:09:29,750 --> 00:09:35,750
order again you know we're going to be

00:09:32,570 --> 00:09:38,839
firing off an independent execution of

00:09:35,750 --> 00:09:40,819
these events so if you're going to have

00:09:38,839 --> 00:09:43,009
if you require a strict order or if you

00:09:40,819 --> 00:09:45,139
require anything that requires a little

00:09:43,009 --> 00:09:47,899
marshaling of data or any sort of like

00:09:45,139 --> 00:09:50,000
strict reads extry rights etc I would

00:09:47,899 --> 00:09:55,040
say those are pretty about fits for a

00:09:50,000 --> 00:09:58,130
serverless architecture that in addition

00:09:55,040 --> 00:10:00,319
to that anything with with side effects

00:09:58,130 --> 00:10:01,610
that you're relying on if you can't if

00:10:00,319 --> 00:10:03,949
you can't handle in your architecture

00:10:01,610 --> 00:10:05,959
eventual consistency now then then don't

00:10:03,949 --> 00:10:08,149
bother with a serverless architecture

00:10:05,959 --> 00:10:13,430
because it's gonna get worse to your

00:10:08,149 --> 00:10:15,110
point I think I atomic expectations of

00:10:13,430 --> 00:10:17,089
awe Tom Optima City is that array word

00:10:15,110 --> 00:10:19,370
yeah thank you that one was hard

00:10:17,089 --> 00:10:21,380
yeah are kind of thrown out the window

00:10:19,370 --> 00:10:23,209
in this model to use it effectively as

00:10:21,380 --> 00:10:27,050
soon as you start blocking then you've

00:10:23,209 --> 00:10:30,019
kind of broken the the model yeah yeah

00:10:27,050 --> 00:10:31,339
anything that with your code would call

00:10:30,019 --> 00:10:34,010
this function normally say it was in a

00:10:31,339 --> 00:10:35,420
monolith and it just didn't return that

00:10:34,010 --> 00:10:37,579
you would hit your app would have a bad

00:10:35,420 --> 00:10:39,170
time is not a good fit because I said

00:10:37,579 --> 00:10:40,730
you're handing off this instead of being

00:10:39,170 --> 00:10:43,550
part of your code it's this external

00:10:40,730 --> 00:10:45,230
service and as highly available as any

00:10:43,550 --> 00:10:47,720
of the vendors or users try and build

00:10:45,230 --> 00:10:49,339
these architectures sometimes functions

00:10:47,720 --> 00:10:52,040
just won't run for some reason it's

00:10:49,339 --> 00:10:53,540
technology right it breaks so if you

00:10:52,040 --> 00:10:55,130
don't have that type of logic to handle

00:10:53,540 --> 00:10:56,660
that neither resubmitted or however

00:10:55,130 --> 00:10:59,240
you're doing that it's it's gonna be

00:10:56,660 --> 00:11:00,860
it's gonna be a really hard time we're

00:10:59,240 --> 00:11:02,540
talking at sort of a technical level but

00:11:00,860 --> 00:11:04,189
I'm curious I'd like to pull the

00:11:02,540 --> 00:11:06,319
audience how many folks here are

00:11:04,189 --> 00:11:08,899
currently involved in some way with a

00:11:06,319 --> 00:11:10,760
micro services strategy he was into that

00:11:08,899 --> 00:11:12,680
okay now keep your hand up if you think

00:11:10,760 --> 00:11:15,380
that your organization is able to

00:11:12,680 --> 00:11:19,699
effectively manage and deliver micro

00:11:15,380 --> 00:11:21,680
services right now okay yeah so now now

00:11:19,699 --> 00:11:23,870
maybe you have this could be anywhere

00:11:21,680 --> 00:11:26,089
from say you know to micro services -

00:11:23,870 --> 00:11:28,069
you know maybe hundreds maybe you're at

00:11:26,089 --> 00:11:29,870
that level now but at the serverless

00:11:28,069 --> 00:11:32,180
architecture - it's a Kenny's point when

00:11:29,870 --> 00:11:33,760
he talks about the ability to deliver

00:11:32,180 --> 00:11:35,780
on smaller and smaller increments

00:11:33,760 --> 00:11:38,930
independently this takes it to sort of

00:11:35,780 --> 00:11:40,460
an extreme level and I'm honestly I

00:11:38,930 --> 00:11:42,650
don't know the the answer I don't know

00:11:40,460 --> 00:11:44,720
anyone who's effectively cataloging and

00:11:42,650 --> 00:11:46,940
managing you know a collection of

00:11:44,720 --> 00:11:49,400
functions across a distributed graph

00:11:46,940 --> 00:11:51,250
like architecture right now so I would

00:11:49,400 --> 00:11:53,780
say I don't just jump into it without

00:11:51,250 --> 00:11:55,370
thinking ahead a little bit about how

00:11:53,780 --> 00:11:59,660
you're going to manage this once it gets

00:11:55,370 --> 00:12:01,190
proliferated one thing I would add to

00:11:59,660 --> 00:12:02,900
that is definitely is the whole you know

00:12:01,190 --> 00:12:04,670
if you think about your whole CI CD type

00:12:02,900 --> 00:12:05,870
of pipe line with regular coding it gets

00:12:04,670 --> 00:12:08,540
even more important with serverless

00:12:05,870 --> 00:12:09,740
because it's not this block of code we

00:12:08,540 --> 00:12:10,850
can run all your tests against it

00:12:09,740 --> 00:12:12,470
because you chunked it off in these

00:12:10,850 --> 00:12:13,580
little pieces so that's when the

00:12:12,470 --> 00:12:16,130
individual unit tests and integration

00:12:13,580 --> 00:12:17,480
tests become even more important and

00:12:16,130 --> 00:12:19,490
then how you handle the failures of

00:12:17,480 --> 00:12:21,200
those as well so what I mean what I've

00:12:19,490 --> 00:12:22,910
seen with one application that that I

00:12:21,200 --> 00:12:25,940
was messing with it that I'm using a

00:12:22,910 --> 00:12:28,220
server list for it started out in the

00:12:25,940 --> 00:12:29,660
micro services type approach and the one

00:12:28,220 --> 00:12:33,140
of the micro services were basically

00:12:29,660 --> 00:12:35,150
workers that waited for an API call did

00:12:33,140 --> 00:12:36,560
some stuff so then I said well hey this

00:12:35,150 --> 00:12:37,760
would be a perfect fit to pull these out

00:12:36,560 --> 00:12:39,290
so then there's pieces of the

00:12:37,760 --> 00:12:40,640
application that are still you know

00:12:39,290 --> 00:12:42,530
stateful that are running all the time

00:12:40,640 --> 00:12:44,450
connecting databases but those worker

00:12:42,530 --> 00:12:44,930
micro services are now replaced with

00:12:44,450 --> 00:12:48,260
serverless

00:12:44,930 --> 00:12:50,270
but a big piece of that was moving to a

00:12:48,260 --> 00:12:51,740
full you know I mean the fact that I set

00:12:50,270 --> 00:12:53,780
my own Jenkins server just to make sure

00:12:51,740 --> 00:12:55,120
but made a change to it that didn't

00:12:53,780 --> 00:12:56,930
break the whole thing because of the

00:12:55,120 --> 00:12:59,800
independent nature of each of the end of

00:12:56,930 --> 00:12:59,800
individual function

00:13:01,940 --> 00:13:14,220
so what does the impact serverless has

00:13:05,340 --> 00:13:15,900
in organizations is that what yeah so

00:13:14,220 --> 00:13:19,200
kind of along what Casey was saying and

00:13:15,900 --> 00:13:21,120
it's you know now that it's it's

00:13:19,200 --> 00:13:23,490
fashionable to for people like team

00:13:21,120 --> 00:13:25,560
managers etc CTO so you know let's go

00:13:23,490 --> 00:13:29,970
with server list let's try a POC or

00:13:25,560 --> 00:13:32,580
whatever so it's easier said that done

00:13:29,970 --> 00:13:34,590
right like now oh yeah if server sis

00:13:32,580 --> 00:13:35,790
easy you just do this do that you know

00:13:34,590 --> 00:13:37,500
that you just have and you just have to

00:13:35,790 --> 00:13:42,240
rewrite your application that's all

00:13:37,500 --> 00:13:44,400
and then so but beyond that it's just

00:13:42,240 --> 00:13:46,080
even operational perspective like let's

00:13:44,400 --> 00:13:47,790
say that you have certain parts of your

00:13:46,080 --> 00:13:51,300
application that you have a you know

00:13:47,790 --> 00:13:53,970
offloaded to event-driven or serverless

00:13:51,300 --> 00:13:56,250
architectures and all of a sudden your

00:13:53,970 --> 00:13:59,010
ops personal reliability engineer gets

00:13:56,250 --> 00:14:02,070
page at 2 a.m. and then are they trained

00:13:59,010 --> 00:14:03,750
to know how to debug a function or are

00:14:02,070 --> 00:14:05,310
they gonna require a developer to

00:14:03,750 --> 00:14:07,680
actually go and look into that into the

00:14:05,310 --> 00:14:10,650
logs and figure out what's going on so

00:14:07,680 --> 00:14:12,510
like there are certain aspect of

00:14:10,650 --> 00:14:15,150
serverless that need like cultural

00:14:12,510 --> 00:14:17,460
information formation and organizational

00:14:15,150 --> 00:14:19,020
transformation so it's not just beyond

00:14:17,460 --> 00:14:21,780
it is it goes beyond the technology

00:14:19,020 --> 00:14:23,910
itself technologies come and go but

00:14:21,780 --> 00:14:25,620
however what drives are successful in my

00:14:23,910 --> 00:14:28,530
opinion a successful deployment of any

00:14:25,620 --> 00:14:31,380
technology is you know the correct

00:14:28,530 --> 00:14:34,860
organizational you know embrace that

00:14:31,380 --> 00:14:36,360
they to give so it's easy to say oh we

00:14:34,860 --> 00:14:37,830
have this service let's just again for

00:14:36,360 --> 00:14:40,620
the buzz word you get free marketing

00:14:37,830 --> 00:14:42,540
blah blah blah but you know push comes

00:14:40,620 --> 00:14:46,240
to show what is the organization is your

00:14:42,540 --> 00:14:48,639
organization ready to be actual services

00:14:46,240 --> 00:14:52,029
so I think that the organization really

00:14:48,639 --> 00:14:54,550
has to look at these functions and

00:14:52,029 --> 00:14:56,199
determine who owns them right so what

00:14:54,550 --> 00:14:58,420
we're learning today with microcircuits

00:14:56,199 --> 00:14:59,949
at we have these teams to organize from

00:14:58,420 --> 00:15:02,290
our business capabilities and they're

00:14:59,949 --> 00:15:04,149
responsible for building and operating

00:15:02,290 --> 00:15:06,279
an application but with functions over

00:15:04,149 --> 00:15:08,350
time like who inherits a function once

00:15:06,279 --> 00:15:10,089
it becomes legacy right who what's the

00:15:08,350 --> 00:15:11,769
life cycle of that is it easy to

00:15:10,089 --> 00:15:14,290
decompose what's the size of these

00:15:11,769 --> 00:15:16,449
things I think that we are lacking a lot

00:15:14,290 --> 00:15:18,069
of things in clarity around what we

00:15:16,449 --> 00:15:19,929
should do with serverless I think that

00:15:18,069 --> 00:15:23,079
there's definitely a few use cases there

00:15:19,929 --> 00:15:25,420
that are very helpful with billion gaps

00:15:23,079 --> 00:15:27,730
especially but I think there's a hybrid

00:15:25,420 --> 00:15:31,990
approach that is yet to emerge between

00:15:27,730 --> 00:15:33,399
micro services and servers so I like to

00:15:31,990 --> 00:15:35,920
I like to try and be optimistic about

00:15:33,399 --> 00:15:38,170
what the impact will be

00:15:35,920 --> 00:15:40,420
but then the pessimist in me I'll start

00:15:38,170 --> 00:15:41,949
with that says that nobody knows how to

00:15:40,420 --> 00:15:43,600
actually implement this effectively you

00:15:41,949 --> 00:15:46,389
know we're here it we're here at the

00:15:43,600 --> 00:15:48,610
Cloud Foundry you know summit a CF

00:15:46,389 --> 00:15:50,980
summit and and we're talking about this

00:15:48,610 --> 00:15:52,889
where there are a couple of early early

00:15:50,980 --> 00:15:55,240
attempts at serverless architecture

00:15:52,889 --> 00:15:56,980
built on the Cloud Foundry stack I think

00:15:55,240 --> 00:16:00,879
they they look fairly promising and

00:15:56,980 --> 00:16:02,980
they're interesting but none of us have

00:16:00,879 --> 00:16:04,540
the technology in our production

00:16:02,980 --> 00:16:07,019
environments to make this happen right

00:16:04,540 --> 00:16:09,879
now at scale unless we're running on

00:16:07,019 --> 00:16:11,019
Amazon and we have lambda available and

00:16:09,879 --> 00:16:13,420
we can actually take advantage of that

00:16:11,019 --> 00:16:16,079
so so part of me says you know nobody's

00:16:13,420 --> 00:16:18,939
quite ready yet there's another

00:16:16,079 --> 00:16:21,549
pessimistic side of me that says a huge

00:16:18,939 --> 00:16:23,230
part of this is about either being being

00:16:21,549 --> 00:16:25,540
able to have this code sort of

00:16:23,230 --> 00:16:28,149
pre-loaded or ready to execute without

00:16:25,540 --> 00:16:29,199
having to do the to incur the startup

00:16:28,149 --> 00:16:31,809
cost every time you want to run a

00:16:29,199 --> 00:16:34,839
function and if you don't have a model

00:16:31,809 --> 00:16:36,879
where where it's already ready to go to

00:16:34,839 --> 00:16:39,309
start executing on business processes

00:16:36,879 --> 00:16:41,980
without having to you know boot up a JVM

00:16:39,309 --> 00:16:43,389
or even you know Ruby or node or

00:16:41,980 --> 00:16:44,529
anything else then then you're gonna

00:16:43,389 --> 00:16:46,689
give be kind of screwed from a

00:16:44,529 --> 00:16:48,730
performance perspective so we we still

00:16:46,689 --> 00:16:51,309
have some work to do I think on the

00:16:48,730 --> 00:16:53,860
operational side to make environments

00:16:51,309 --> 00:16:55,540
capable of providing these to us but but

00:16:53,860 --> 00:16:57,370
from an optimistic perspective once that

00:16:55,540 --> 00:16:58,809
work has done and we'll just hand wave

00:16:57,370 --> 00:16:59,860
and say that it's going to be magically

00:16:58,809 --> 00:17:03,970
sorted out

00:16:59,860 --> 00:17:08,160
by the Cloud Foundry community then then

00:17:03,970 --> 00:17:10,480
I see a great opportunity for increased

00:17:08,160 --> 00:17:11,800
resource utilization efficiency the

00:17:10,480 --> 00:17:14,080
ability to cut down on the amount of

00:17:11,800 --> 00:17:16,720
electricity we need to use in order to

00:17:14,080 --> 00:17:19,200
power our applications at larger and

00:17:16,720 --> 00:17:21,610
larger scales I think if we combine

00:17:19,200 --> 00:17:23,680
serverless as an architectural paradigm

00:17:21,610 --> 00:17:25,540
with things that are happening with you

00:17:23,680 --> 00:17:27,280
know kernels and the emerging technology

00:17:25,540 --> 00:17:29,170
there then we have the opportunity to

00:17:27,280 --> 00:17:31,690
really cut down on the footprint for our

00:17:29,170 --> 00:17:34,360
applications and continue to scale up

00:17:31,690 --> 00:17:36,430
and up and and so as an optimist I see

00:17:34,360 --> 00:17:38,320
that as a future that's you know

00:17:36,430 --> 00:17:41,650
probably frankly four to five years out

00:17:38,320 --> 00:17:45,790
but to be you know mainstream but is on

00:17:41,650 --> 00:17:47,800
the horizon yeah I think I would take a

00:17:45,790 --> 00:17:50,230
little bit more aggressive approach from

00:17:47,800 --> 00:17:51,760
the standpoint of these are one of the

00:17:50,230 --> 00:17:53,860
you know like if we think about the days

00:17:51,760 --> 00:17:55,660
when ec2 was first announced the idea

00:17:53,860 --> 00:17:57,460
was like well I mean it's nothing really

00:17:55,660 --> 00:17:59,410
new technology wise is we can just rent

00:17:57,460 --> 00:18:01,330
servers by the hour instead of buying

00:17:59,410 --> 00:18:03,100
them for three years and I think this is

00:18:01,330 --> 00:18:04,690
that natural evolution of now we're

00:18:03,100 --> 00:18:06,970
renting servers by the microsecond

00:18:04,690 --> 00:18:09,340
instead of by the minute or our day or

00:18:06,970 --> 00:18:11,470
year so I think those efficiencies drive

00:18:09,340 --> 00:18:13,630
not just you know power and cooling but

00:18:11,470 --> 00:18:14,800
then also drive cost efficiencies so I

00:18:13,630 --> 00:18:16,690
think that's gonna be the main push

00:18:14,800 --> 00:18:19,180
behind it which may speed up the

00:18:16,690 --> 00:18:21,520
adoption but I definitely think from an

00:18:19,180 --> 00:18:22,780
operational perspective where that's

00:18:21,520 --> 00:18:24,130
where companies ain't fair this is

00:18:22,780 --> 00:18:25,660
different than what they used to so then

00:18:24,130 --> 00:18:27,370
like for example to your point let's say

00:18:25,660 --> 00:18:28,630
we have a function we've built it does

00:18:27,370 --> 00:18:30,850
this one thing really well

00:18:28,630 --> 00:18:32,470
well if other people's code start start

00:18:30,850 --> 00:18:33,580
calling this function and then we want

00:18:32,470 --> 00:18:35,470
to swap out this function we don't

00:18:33,580 --> 00:18:37,030
realize like what's the upstream impact

00:18:35,470 --> 00:18:39,010
so I think that's where the tooling is

00:18:37,030 --> 00:18:40,840
kind of lacking besides you know from a

00:18:39,010 --> 00:18:43,300
code pipeline perspective for server

00:18:40,840 --> 00:18:45,160
lists but then also dependency mapping

00:18:43,300 --> 00:18:47,520
and tracking of that because right now

00:18:45,160 --> 00:18:50,380
if you know if you give me a Java

00:18:47,520 --> 00:18:52,300
project or a Python project pretty much

00:18:50,380 --> 00:18:53,650
all the codes there except for any

00:18:52,300 --> 00:18:54,880
external libraries and that's generally

00:18:53,650 --> 00:18:56,860
well documented with requirements like

00:18:54,880 --> 00:18:58,600
txt or whatever so I know what's

00:18:56,860 --> 00:19:00,370
happening and I can see you know in any

00:18:58,600 --> 00:19:02,260
ID I can see where that's happening but

00:19:00,370 --> 00:19:03,210
once I pull that out and it's a totally

00:19:02,260 --> 00:19:06,340
separate thing

00:19:03,210 --> 00:19:07,660
someone's random other app could be

00:19:06,340 --> 00:19:09,010
using that function I don't even realize

00:19:07,660 --> 00:19:10,660
it so I think that's where the

00:19:09,010 --> 00:19:13,620
operational aspects get tough is making

00:19:10,660 --> 00:19:16,500
sure those things are handled in an

00:19:13,620 --> 00:19:18,270
in a clean way and I think that's the

00:19:16,500 --> 00:19:19,620
whole move even to microservice and

00:19:18,270 --> 00:19:21,390
stuff it's more about you know

00:19:19,620 --> 00:19:22,800
automation and orchestration and code

00:19:21,390 --> 00:19:25,680
pipeline those type of things I think

00:19:22,800 --> 00:19:28,170
it's a basic prerequisite but and in my

00:19:25,680 --> 00:19:30,240
estimation I think the adoption and the

00:19:28,170 --> 00:19:31,650
use cases will quickly pick up I think

00:19:30,240 --> 00:19:33,450
faster than we're expecting as people

00:19:31,650 --> 00:19:34,770
just like what ec2 are like oh this is

00:19:33,450 --> 00:19:36,350
this cloud thing maybe Netflix can do

00:19:34,770 --> 00:19:38,580
some stuff with it and then how quickly

00:19:36,350 --> 00:19:40,850
other companies got on board with it and

00:19:38,580 --> 00:19:43,230
found new interesting use cases for it

00:19:40,850 --> 00:19:44,940
you know yeah I think I think the cool

00:19:43,230 --> 00:19:46,410
kids are gonna pick it up fast and and

00:19:44,940 --> 00:19:47,370
the companies that have only existed for

00:19:46,410 --> 00:19:53,310
one or two years that don't actually

00:19:47,370 --> 00:19:54,900
have anything real to manage yet but but

00:19:53,310 --> 00:19:56,880
I do think that it takes a little longer

00:19:54,900 --> 00:20:00,390
to get into some of the organizations

00:19:56,880 --> 00:20:03,660
that that we are in for obvious reasons

00:20:00,390 --> 00:20:05,370
but um but you know the the thing that

00:20:03,660 --> 00:20:07,230
you mentioned about the proliferation

00:20:05,370 --> 00:20:10,320
and the ownership can you mention this

00:20:07,230 --> 00:20:13,020
too I think that that's important but if

00:20:10,320 --> 00:20:15,840
you've ever been in in an architectural

00:20:13,020 --> 00:20:16,980
meeting with a legacy application that's

00:20:15,840 --> 00:20:18,000
sort of on the table where we're trying

00:20:16,980 --> 00:20:19,560
to figure out what to do with it and

00:20:18,000 --> 00:20:21,690
you've just tried to propose something

00:20:19,560 --> 00:20:23,130
like let's have background jobs when

00:20:21,690 --> 00:20:24,180
we've never had them before rather than

00:20:23,130 --> 00:20:26,700
in line

00:20:24,180 --> 00:20:28,320
synchronous processing of things like

00:20:26,700 --> 00:20:30,330
you know things as simple as sending

00:20:28,320 --> 00:20:32,550
emails if anyone's ever had that fight

00:20:30,330 --> 00:20:34,650
and and seeing people push back against

00:20:32,550 --> 00:20:36,660
that and then to go from something like

00:20:34,650 --> 00:20:38,160
that to well let's not just do

00:20:36,660 --> 00:20:39,300
background job so maybe let's start to

00:20:38,160 --> 00:20:40,740
decompose this into a collection of

00:20:39,300 --> 00:20:43,140
services maybe we'll just have one or

00:20:40,740 --> 00:20:44,940
two or three to start then and you've

00:20:43,140 --> 00:20:46,170
seen the fight against that going to

00:20:44,940 --> 00:20:48,690
something like serverless for you like

00:20:46,170 --> 00:20:50,070
let's just take this function out of

00:20:48,690 --> 00:20:51,300
this class and let's forget for a moment

00:20:50,070 --> 00:20:52,560
that it's an object and we don't know

00:20:51,300 --> 00:20:54,390
how to do functions because everything

00:20:52,560 --> 00:20:55,940
is object oriented but let's just call

00:20:54,390 --> 00:20:58,230
it that and then like shove it in to

00:20:55,940 --> 00:21:01,050
shove it into lambda or shove it into a

00:20:58,230 --> 00:21:02,460
task oriented you know scheduler then I

00:21:01,050 --> 00:21:04,760
think I think it's gonna take some time

00:21:02,460 --> 00:21:07,050
to get people on board with that because

00:21:04,760 --> 00:21:09,000
having having more things to manage

00:21:07,050 --> 00:21:11,720
doesn't doesn't make your system easier

00:21:09,000 --> 00:21:11,720
to manage

00:21:14,310 --> 00:21:20,490
that's it that's all the questions we

00:21:16,240 --> 00:21:20,490
have have any further for the audience

00:21:23,090 --> 00:21:29,550
cool okay

00:21:26,730 --> 00:21:31,560
yeah is anyone doing anything that

00:21:29,550 --> 00:21:33,660
they're calling serverless right now

00:21:31,560 --> 00:21:35,190
either trying to get something like this

00:21:33,660 --> 00:21:39,690
like a functional orient function

00:21:35,190 --> 00:21:41,940
oriented delivery out into production

00:21:39,690 --> 00:21:43,890
we've got someone over there can you

00:21:41,940 --> 00:21:49,560
talk about it at all

00:21:43,890 --> 00:21:56,160
how's it how's it going what who's the

00:21:49,560 --> 00:22:02,270
provider okay

00:21:56,160 --> 00:22:02,270
are you using lambda cool

00:22:08,029 --> 00:22:24,409
dynamodb yeah right so you like the

00:22:21,649 --> 00:22:28,129
nodejs model of a WS lambda yeah yeah

00:22:24,409 --> 00:22:47,629
with dynamodb got it okay any questions

00:22:28,129 --> 00:22:49,879
from you yeah I think it's early days

00:22:47,629 --> 00:22:52,129
this is this is my own fascination and I

00:22:49,879 --> 00:22:55,460
haven't I haven't tried it myself yet so

00:22:52,129 --> 00:22:57,620
I see the small footprint of a you know

00:22:55,460 --> 00:22:59,269
Colonel the ability to strip away

00:22:57,620 --> 00:23:02,120
anything that you would need to load

00:22:59,269 --> 00:23:03,889
into memory and then and and also a page

00:23:02,120 --> 00:23:05,210
through the CPU in order to get your

00:23:03,889 --> 00:23:06,620
application to run I see that as a

00:23:05,210 --> 00:23:08,240
benefit of you know kernel you know

00:23:06,620 --> 00:23:11,110
kernels generally and you can cut down

00:23:08,240 --> 00:23:14,360
on on your footprints quite dramatically

00:23:11,110 --> 00:23:16,279
for many applications so that's a

00:23:14,360 --> 00:23:18,590
benefit and then that only helps you

00:23:16,279 --> 00:23:22,330
spin up processes even more quickly and

00:23:18,590 --> 00:23:26,029
so I just see that along with an evented

00:23:22,330 --> 00:23:27,769
model for for i/o or request response

00:23:26,029 --> 00:23:30,769
that that could be a pretty interesting

00:23:27,769 --> 00:23:32,870
thing to throw together but I don't

00:23:30,769 --> 00:23:35,840
think anyone's trying that specifically

00:23:32,870 --> 00:23:38,029
I expect that in about five minute eat

00:23:35,840 --> 00:23:40,279
at Levine of EMC code will come out with

00:23:38,029 --> 00:23:43,639
a demo and have something on github that

00:23:40,279 --> 00:23:44,929
shows this but yeah well I I mean I get

00:23:43,639 --> 00:23:46,370
I think we have to if you can't have a

00:23:44,929 --> 00:23:49,039
panel of without at least one

00:23:46,370 --> 00:23:50,570
contentious issue so so my take on

00:23:49,039 --> 00:23:54,440
specifically you know kernels are

00:23:50,570 --> 00:23:56,509
they're fantastic use case in like the

00:23:54,440 --> 00:23:58,279
IOT world like the idea of hey I'm

00:23:56,509 --> 00:24:00,590
putting some you know like the the fact

00:23:58,279 --> 00:24:02,480
that today we have things like smoke

00:24:00,590 --> 00:24:03,590
detectors that have Wi-Fi and everything

00:24:02,480 --> 00:24:05,899
and they're running like a full Linux

00:24:03,590 --> 00:24:08,899
kernel is bonkers you know that that

00:24:05,899 --> 00:24:09,980
that attack surface that ability to

00:24:08,899 --> 00:24:12,139
update firmware and all those things

00:24:09,980 --> 00:24:13,639
seems like it's a perfect fit for you

00:24:12,139 --> 00:24:15,409
know if you're making a million of these

00:24:13,639 --> 00:24:16,700
devices why won't you cut the kernel

00:24:15,409 --> 00:24:18,889
back to the minimum so to me that's a

00:24:16,700 --> 00:24:21,200
fantastic you know kernel use case where

00:24:18,889 --> 00:24:21,680
I think it doesn't fit is more than

00:24:21,200 --> 00:24:23,270
likes

00:24:21,680 --> 00:24:25,820
Cloud Foundry type model or even

00:24:23,270 --> 00:24:27,050
serverless type model where you're going

00:24:25,820 --> 00:24:28,910
up that next layer to the container

00:24:27,050 --> 00:24:30,980
anyway so I don't need a whole video

00:24:28,910 --> 00:24:32,630
we're done with VMs right we don't need

00:24:30,980 --> 00:24:35,180
VMs anymore games are nobody uses

00:24:32,630 --> 00:24:37,280
anymore right that's everything's

00:24:35,180 --> 00:24:38,780
containers already right so no but as it

00:24:37,280 --> 00:24:42,290
moves forward you know kernels fit with

00:24:38,780 --> 00:24:43,700
with VMs but as we move to whether it's

00:24:42,290 --> 00:24:46,040
you know say Diego under Cloud Foundry

00:24:43,700 --> 00:24:48,710
or even docker kubernetes or any of

00:24:46,040 --> 00:24:50,810
those other things I don't I I want to I

00:24:48,710 --> 00:24:52,430
want to lower profile OS like a core OS

00:24:50,810 --> 00:24:54,920
but I don't really need a unit kernel

00:24:52,430 --> 00:24:58,130
per piece of function because I'm just

00:24:54,920 --> 00:24:59,960
doing in a container anyway except those

00:24:58,130 --> 00:25:01,400
those containers get big and their

00:24:59,960 --> 00:25:03,140
memory footprint with an OS in them

00:25:01,400 --> 00:25:04,640
anyway it gets big and if you want to

00:25:03,140 --> 00:25:07,250
get more efficient resource utilization

00:25:04,640 --> 00:25:09,050
if you want to use the cool another cool

00:25:07,250 --> 00:25:11,420
term and bin pack everything as tightly

00:25:09,050 --> 00:25:12,800
as possible I think I think there's

00:25:11,420 --> 00:25:13,850
still benefit there I do agree with you

00:25:12,800 --> 00:25:15,290
that that if you have to do

00:25:13,850 --> 00:25:17,810
virtualization anyway then you already

00:25:15,290 --> 00:25:19,760
reduced some of the benefits of the

00:25:17,810 --> 00:25:21,620
small unit kernel footprint but but I

00:25:19,760 --> 00:25:24,190
see other other benefits that I find

00:25:21,620 --> 00:25:24,190
interesting

00:25:44,890 --> 00:25:48,429
yeah so so this sounds like a question

00:25:47,110 --> 00:25:50,710
like you know how many lines of code is

00:25:48,429 --> 00:25:53,790
a microservice and I'm not I don't have

00:25:50,710 --> 00:25:53,790
it I don't have a good answer for it

00:25:53,970 --> 00:26:04,500
oughta be enough for anybody

00:25:56,580 --> 00:26:04,500
640k do you have an idea yourself

00:26:24,170 --> 00:26:28,310
that's tough you know so so I think um

00:26:26,360 --> 00:26:31,790
you know Kenny and I were talking about

00:26:28,310 --> 00:26:33,500
size of JVM and memory and proliferation

00:26:31,790 --> 00:26:35,900
of application instances kind of being a

00:26:33,500 --> 00:26:42,820
problem occasionally and I could see

00:26:35,900 --> 00:26:42,820
that playing a factor here for instance

00:26:47,920 --> 00:26:53,210
yeah so so there's memory footprint and

00:26:50,540 --> 00:26:55,670
and I think also time to first business

00:26:53,210 --> 00:26:57,200
process execution point right like we

00:26:55,670 --> 00:26:58,640
maybe not time to first byte because

00:26:57,200 --> 00:27:00,080
you're not always doing that but like

00:26:58,640 --> 00:27:02,570
what time they're getting to business

00:27:00,080 --> 00:27:03,590
process from from whatever startup is

00:27:02,570 --> 00:27:05,090
those are the two things that you're

00:27:03,590 --> 00:27:07,190
gonna need to try and profile and have

00:27:05,090 --> 00:27:09,170
an understanding about but I'm not about

00:27:07,190 --> 00:27:14,030
to to make a guess at what what's

00:27:09,170 --> 00:27:15,560
perfect or right thing I would add there

00:27:14,030 --> 00:27:17,690
is it's it's similar to when we see

00:27:15,560 --> 00:27:20,690
people do TCO models of public cloud

00:27:17,690 --> 00:27:22,340
like oh well you see to cost this and

00:27:20,690 --> 00:27:24,170
you know software cost this let me do

00:27:22,340 --> 00:27:26,270
the math if I buy the servers if I

00:27:24,170 --> 00:27:28,280
install you know an OS on and I do

00:27:26,270 --> 00:27:30,950
itself oh I could do it cheaper it's

00:27:28,280 --> 00:27:32,210
like well yeah if it's fully you know if

00:27:30,950 --> 00:27:34,160
you you're assuming that you're getting

00:27:32,210 --> 00:27:35,780
full utilization and what do we know

00:27:34,160 --> 00:27:37,760
most of our data centers are if they're

00:27:35,780 --> 00:27:39,020
half utilized we're doing awesome so

00:27:37,760 --> 00:27:40,490
that's why I think fits into that -

00:27:39,020 --> 00:27:42,740
where's hey we can build this big server

00:27:40,490 --> 00:27:44,810
list farm well it may make sense if

00:27:42,740 --> 00:27:47,570
we're getting a decent amount of

00:27:44,810 --> 00:27:49,090
transactions event triggering but if

00:27:47,570 --> 00:27:51,380
you're you know either trickling through

00:27:49,090 --> 00:27:52,910
you've built this big environment and

00:27:51,380 --> 00:27:54,050
then you don't have any transactions to

00:27:52,910 --> 00:27:55,430
run through them so you're the whole

00:27:54,050 --> 00:27:57,200
like hey I'm only using it for

00:27:55,430 --> 00:27:58,520
milliseconds doesn't make any sense cuz

00:27:57,200 --> 00:28:00,110
you already bought the server's you know

00:27:58,520 --> 00:28:01,370
that's a good point yeah if you're on if

00:28:00,110 --> 00:28:03,290
you're on Prem and you already have that

00:28:01,370 --> 00:28:04,760
capacity and you have to amortize it and

00:28:03,290 --> 00:28:07,330
use it anyway yeah then you're then

00:28:04,760 --> 00:28:09,680
you're there but you know I think

00:28:07,330 --> 00:28:11,750
there's there's a the execution process

00:28:09,680 --> 00:28:13,400
and then there's just keeping these idle

00:28:11,750 --> 00:28:15,410
long-running long live processes and

00:28:13,400 --> 00:28:17,390
memories is kind of a waste anyway so

00:28:15,410 --> 00:28:19,670
even when we talk about utilization if

00:28:17,390 --> 00:28:21,320
you have a bunch of idle you know micro

00:28:19,670 --> 00:28:24,080
services all just sitting around eating

00:28:21,320 --> 00:28:25,370
a memory and and not doing anything then

00:28:24,080 --> 00:28:29,120
what's the what's the point in that -

00:28:25,370 --> 00:28:33,010
that's really still idle capacity yeah

00:28:29,120 --> 00:28:33,010
there's one more question

00:28:40,840 --> 00:28:57,530
you see them along so that was so can

00:28:55,670 --> 00:29:01,240
you say it again or just summarize

00:28:57,530 --> 00:29:01,240
summarize what I'm trying to say is

00:29:05,140 --> 00:29:13,130
along with so I'm going to summarize

00:29:11,210 --> 00:29:15,320
that question is what's spring roll in

00:29:13,130 --> 00:29:19,730
Surrealists and I would say so if you're

00:29:15,320 --> 00:29:21,380
at a spring cloud dataflow yeah so it's

00:29:19,730 --> 00:29:23,330
like spring batch and then spring XD and

00:29:21,380 --> 00:29:24,890
the spring cloud dataflow so right now

00:29:23,330 --> 00:29:27,920
the description of spring cloud dataflow

00:29:24,890 --> 00:29:30,200
really is that it's data processing for

00:29:27,920 --> 00:29:33,500
micro services but it resembles quite a

00:29:30,200 --> 00:29:35,360
bit a service deployment model so

00:29:33,500 --> 00:29:37,880
they're recompose Abul so you can create

00:29:35,360 --> 00:29:40,490
these spring cloud stream modules and

00:29:37,880 --> 00:29:42,170
they're very small and then memory

00:29:40,490 --> 00:29:43,850
footprints gonna play a role so how do

00:29:42,170 --> 00:29:47,180
you kind of batch together these

00:29:43,850 --> 00:29:48,440
functions in a single JVM process so I

00:29:47,180 --> 00:29:52,760
mean it's early days but there are

00:29:48,440 --> 00:29:54,410
definitely plans to go that route in the

00:29:52,760 --> 00:29:56,480
abstract to when it comes to data

00:29:54,410 --> 00:29:59,270
processing and serverless if you can if

00:29:56,480 --> 00:30:00,980
you can work around a streaming model

00:29:59,270 --> 00:30:02,750
you're gonna get more efficient resource

00:30:00,980 --> 00:30:05,600
utilization over time with fewer bursts

00:30:02,750 --> 00:30:08,450
then if you just go with batches every

00:30:05,600 --> 00:30:10,310
hour minute you know day whatever you

00:30:08,450 --> 00:30:11,540
can't always do that but generally

00:30:10,310 --> 00:30:13,820
speaking if you can go with a more

00:30:11,540 --> 00:30:15,320
streaming approach to your data

00:30:13,820 --> 00:30:16,850
processing pipelines and you're probably

00:30:15,320 --> 00:30:20,050
going to get more value out of that

00:30:16,850 --> 00:30:20,050
model as well

00:30:20,160 --> 00:30:30,100
we're out of time so any more questions

00:30:23,170 --> 00:30:38,890
we'll be around later you have a hashtag

00:30:30,100 --> 00:30:40,630
monitoring back so yeah you say you know

00:30:38,890 --> 00:30:42,280
tweet at us and then with that hashtag

00:30:40,630 --> 00:30:46,110
and then you know we can keep the

00:30:42,280 --> 00:30:50,160
conversation going guys cool thanks all

00:30:46,110 --> 00:30:50,160

YouTube URL: https://www.youtube.com/watch?v=TEFXG31LnM8


