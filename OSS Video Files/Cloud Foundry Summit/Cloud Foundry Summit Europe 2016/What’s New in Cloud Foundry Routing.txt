Title: What’s New in Cloud Foundry Routing
Publication date: 2016-09-30
Playlist: Cloud Foundry Summit Europe 2016
Description: 
	What’s New in Cloud Foundry Routing - Shannon Coen, Prashanth Subrahmanyam and Chris Piraino, Pivotal

Route Services: Until recently, developers were on their own to implement rate-limiting, authentication, and many request transformation functions offered by API gateway services. Route Services expand the use cases that can be fulfilled by Marketplace services, enabling developers managing apps on CF to inject a service into the request path, or dynamically configure a component already in the request path. User-provided services are also supported! 

TCP Routing: Some developers would like to run workloads on Cloud Foundry that receive requests over TCP protocols other than http. Some developers would prefer to terminate TLS connections at the application. With support for TCP routing and multiple app ports, we enable these use case and more. 

This session will provide an update from the Routing team, including demonstrations of some of these new features in CF Routing.

About Shannon Coen
Shannon Coen has been guiding core functionality in Cloud Foundry since joining VMWare in 2012. He stayed with the project when it moved to Pivotal, and served for three years as Product Manager with the Services team, launching the v2 broker API in 2013, the MySQL BOSH release as a reference implementation, and most of the subsequent enhancements including support for asynchronous operations in 2015. Since 2015 he has served as Product Manager for the Cloud Foundry Routing team. Shannon is a member of the CF Foundation PMC Council.

About Christopher Piraino
Chris Piraino has been a core contributor to Cloud Foundry for over 2 years. As a software engineer for Pivotal, Chris has previously working on the CLI and Cloud Controller API. For the past year, he has been working on the CF Routing team where he has been working on shipping new routing features, such as Route Services and TCP Routing.

About Prashanth Subrahmanyam
Prashanth is a technology addict who loves to solve real world problems using technology and code. Professionally he has played the roles of a Developer, Architect, Scrum Master, and Agile Coach.

As an Architect, he has progressed from designing large, enterprise software to building Highly Scalable and API-coupled, Microservices-based systems.

At Apigee, Prashanth builds solutions to help customers accelerate their Digital Transformation journey.
Captions: 
	00:00:00,060 --> 00:00:03,899
well we have a lot of content to get

00:00:02,220 --> 00:00:07,440
through in 30 minutes so we're gonna get

00:00:03,899 --> 00:00:10,440
started thank you all for joining us

00:00:07,440 --> 00:00:12,870
we're going to talk about some fairly

00:00:10,440 --> 00:00:17,010
recent enhancements in the Cloud Foundry

00:00:12,870 --> 00:00:19,279
routing tier that has core platform

00:00:17,010 --> 00:00:23,039
features provide new points of extension

00:00:19,279 --> 00:00:26,130
enhance what Cloud Foundry services can

00:00:23,039 --> 00:00:29,730
be what kind of workloads can be run on

00:00:26,130 --> 00:00:32,040
Cloud Foundry my name is shannon cohen

00:00:29,730 --> 00:00:33,059
i'm a product manager at pivotal i've

00:00:32,040 --> 00:00:34,559
been working on the cloud foundry

00:00:33,059 --> 00:00:38,730
project for about four years

00:00:34,559 --> 00:00:40,500
came from vmware and this is the cloud

00:00:38,730 --> 00:00:42,780
foundry routing engineering team I have

00:00:40,500 --> 00:00:44,480
the honor of working with we're an open

00:00:42,780 --> 00:00:49,649
source team you can see we have

00:00:44,480 --> 00:00:52,770
contributors from pivotal IBM and GE

00:00:49,649 --> 00:01:02,430
we've also had members of the team from

00:00:52,770 --> 00:01:03,989
EMC and other member companies what does

00:01:02,430 --> 00:01:05,309
the routing tier do as an introduction

00:01:03,989 --> 00:01:09,479
before we get into the features I'll

00:01:05,309 --> 00:01:12,540
give a brief summary basically we're

00:01:09,479 --> 00:01:14,340
responsible for the components at the

00:01:12,540 --> 00:01:17,009
network edge of cloud foundry making

00:01:14,340 --> 00:01:18,590
sure that requests for system components

00:01:17,009 --> 00:01:21,689
and applications running on the platform

00:01:18,590 --> 00:01:23,490
get to where they're meant to go this is

00:01:21,689 --> 00:01:26,220
particular tricky for applications

00:01:23,490 --> 00:01:28,020
running on Cloud Foundry since among

00:01:26,220 --> 00:01:30,420
other things as a container scheduler

00:01:28,020 --> 00:01:32,900
those location of those application

00:01:30,420 --> 00:01:34,860
instances is subject to change

00:01:32,900 --> 00:01:38,310
historically we've been responsible for

00:01:34,860 --> 00:01:40,950
a layer 7 HTTP router and which is

00:01:38,310 --> 00:01:43,259
dynamically updated it also features

00:01:40,950 --> 00:01:45,720
round-robin load balancing though we've

00:01:43,259 --> 00:01:48,470
received a PR recently from IBM for a

00:01:45,720 --> 00:01:51,329
additional load balancing algorithm

00:01:48,470 --> 00:01:54,060
supports SSL termination WebSockets

00:01:51,329 --> 00:01:58,920
icky-sticky sessions and transparent

00:01:54,060 --> 00:02:01,439
retries okay first topic we'll talk

00:01:58,920 --> 00:02:02,939
about is Route services as an

00:02:01,439 --> 00:02:06,450
introduction I'll tell you a bit about

00:02:02,939 --> 00:02:09,509
the opportunity we saw as you know Cloud

00:02:06,450 --> 00:02:13,890
Foundry marketplace provides a way for

00:02:09,509 --> 00:02:15,660
developers to reuse or consume serve

00:02:13,890 --> 00:02:18,540
which are maintained by others so they

00:02:15,660 --> 00:02:20,940
don't have to reinvent the wheel and

00:02:18,540 --> 00:02:24,060
don't have to be responsible for all the

00:02:20,940 --> 00:02:26,640
technology in their stack but we

00:02:24,060 --> 00:02:29,730
identified a category of services which

00:02:26,640 --> 00:02:31,620
wasn't available to developers and those

00:02:29,730 --> 00:02:35,130
are things which intermediate

00:02:31,620 --> 00:02:37,410
application requests common use cases

00:02:35,130 --> 00:02:41,430
include rate limiting authentication and

00:02:37,410 --> 00:02:42,989
API traffic a P I management and we

00:02:41,430 --> 00:02:45,239
found that for operators delivering

00:02:42,989 --> 00:02:48,890
these services in a one-off way was a

00:02:45,239 --> 00:02:51,450
burden so our solution was to offer

00:02:48,890 --> 00:02:52,920
these services or enable service

00:02:51,450 --> 00:02:54,060
providers to offer these kinds of

00:02:52,920 --> 00:02:57,510
services through the Cloud Foundry

00:02:54,060 --> 00:03:00,390
marketplace rustle route services are a

00:02:57,510 --> 00:03:04,250
new kind of marketplace service that

00:03:00,390 --> 00:03:07,080
enables developers to insert these

00:03:04,250 --> 00:03:10,160
intermediaries intermediating services

00:03:07,080 --> 00:03:13,320
into their application request path and

00:03:10,160 --> 00:03:13,769
by not having to reinvent the wheel each

00:03:13,320 --> 00:03:16,410
time

00:03:13,769 --> 00:03:21,060
this increases developer velocity and

00:03:16,410 --> 00:03:23,519
minimizes time to market this is a look

00:03:21,060 --> 00:03:27,209
at the developer user experience the CLI

00:03:23,519 --> 00:03:30,930
it leverages many familiar and existing

00:03:27,209 --> 00:03:33,360
workflows and introduces one new one so

00:03:30,930 --> 00:03:34,650
discover to discover a route services in

00:03:33,360 --> 00:03:36,680
the cloud foundry marketplace you would

00:03:34,650 --> 00:03:38,970
use the same command CF marketplace and

00:03:36,680 --> 00:03:42,230
to create a service instance you would

00:03:38,970 --> 00:03:46,230
use the same command CF create service

00:03:42,230 --> 00:03:47,970
the the new command that's been

00:03:46,230 --> 00:03:51,079
introduced to support this class of

00:03:47,970 --> 00:03:55,709
services is the F bind route service

00:03:51,079 --> 00:03:59,010
because rather than interacting with

00:03:55,709 --> 00:04:00,630
these services with having an

00:03:59,010 --> 00:04:04,739
application interact with these services

00:04:00,630 --> 00:04:07,560
where interim where dynamically updating

00:04:04,739 --> 00:04:11,579
the Cloud Foundry routing tier to proxy

00:04:07,560 --> 00:04:13,530
requests to these services and the API

00:04:11,579 --> 00:04:15,930
object in cloud foundry that was most

00:04:13,530 --> 00:04:17,789
appropriate to associate with these

00:04:15,930 --> 00:04:21,720
services was the route this is the

00:04:17,789 --> 00:04:24,419
address for one or more applications so

00:04:21,720 --> 00:04:27,540
the workflow is to associate the service

00:04:24,419 --> 00:04:29,940
instance with the route we also support

00:04:27,540 --> 00:04:32,310
user provided service instances so that

00:04:29,940 --> 00:04:34,380
developers can leverage these kinds of

00:04:32,310 --> 00:04:39,150
services if they aren't in the

00:04:34,380 --> 00:04:42,060
marketplace a look at the management

00:04:39,150 --> 00:04:44,010
plain hasn't changed request to Cloud

00:04:42,060 --> 00:04:46,260
Foundry are still sent to the service

00:04:44,010 --> 00:04:49,260
broker which takes care of translating

00:04:46,260 --> 00:04:51,330
requests but for provisioning to a

00:04:49,260 --> 00:04:54,060
service instance of provisioning of a

00:04:51,330 --> 00:04:56,970
service instance the one change here is

00:04:54,060 --> 00:05:01,580
that the service broker can optionally

00:04:56,970 --> 00:05:04,680
return the URL of the service instance

00:05:01,580 --> 00:05:06,720
if the broker does return the URL of the

00:05:04,680 --> 00:05:08,820
service instance the Cloud Foundry

00:05:06,720 --> 00:05:11,760
routing tier is dynamically updated as I

00:05:08,820 --> 00:05:14,400
mentioned when it does a lookup of the

00:05:11,760 --> 00:05:16,710
backends for a particular route and

00:05:14,400 --> 00:05:18,990
iodine if it identifies that there is a

00:05:16,710 --> 00:05:22,020
URL associated with the service instance

00:05:18,990 --> 00:05:23,840
excuse me with the route and proxies

00:05:22,020 --> 00:05:27,360
those requests to the service instance

00:05:23,840 --> 00:05:29,160
after some transformation occurs the

00:05:27,360 --> 00:05:30,450
service instance sends the request back

00:05:29,160 --> 00:05:33,000
to the router and we forward the request

00:05:30,450 --> 00:05:35,040
on to the application responses from the

00:05:33,000 --> 00:05:37,530
application travel back through the

00:05:35,040 --> 00:05:39,330
route service also so services have the

00:05:37,530 --> 00:05:42,270
opportunity of doing transformation both

00:05:39,330 --> 00:05:44,550
on the request and the response I will

00:05:42,270 --> 00:05:46,080
say that requests between the route

00:05:44,550 --> 00:05:49,560
service and Cloud Foundry routing tier

00:05:46,080 --> 00:05:53,820
are encrypted if the broker does not

00:05:49,560 --> 00:05:57,810
return route service URL there's a use

00:05:53,820 --> 00:05:59,700
case for services which may be

00:05:57,810 --> 00:06:01,290
pre-existing or before cliff did in

00:05:59,700 --> 00:06:03,240
front of Cloud Foundry these are

00:06:01,290 --> 00:06:07,290
services through which all requests for

00:06:03,240 --> 00:06:09,870
the platform applications may travel it

00:06:07,290 --> 00:06:12,090
might be a transparent pass-through but

00:06:09,870 --> 00:06:13,740
through the broker integration and

00:06:12,090 --> 00:06:15,960
exposing the service in the marketplace

00:06:13,740 --> 00:06:18,600
there's still value in enabling

00:06:15,960 --> 00:06:20,970
developers to configure that service for

00:06:18,600 --> 00:06:24,300
their specific needs with familiar Cloud

00:06:20,970 --> 00:06:26,730
Foundry workflows with that I'd like to

00:06:24,300 --> 00:06:29,700
invite prashanta to give a demonstration

00:06:26,730 --> 00:06:31,380
of route services Prashant is from

00:06:29,700 --> 00:06:34,940
Apogee and Apogee has been an early

00:06:31,380 --> 00:06:34,940
adopter of this integration

00:06:39,229 --> 00:06:51,270
Thank You Shannon okay hi everyone as

00:06:47,580 --> 00:06:53,009
Shannon said I work with Apogee I'm a

00:06:51,270 --> 00:06:55,139
principal architect with Apogee and I

00:06:53,009 --> 00:07:03,419
had customers accelerate the digital

00:06:55,139 --> 00:07:05,009
transformation journey okay so let me

00:07:03,419 --> 00:07:07,560
take a step back and talk about

00:07:05,009 --> 00:07:10,680
developers right so as developers all

00:07:07,560 --> 00:07:12,330
that we so as developers all that we

00:07:10,680 --> 00:07:13,979
would like to do is we write a piece of

00:07:12,330 --> 00:07:16,650
source code and we want this to run on

00:07:13,979 --> 00:07:19,409
the cloud we do not worry too much about

00:07:16,650 --> 00:07:21,569
how it actually runs on the cloud but

00:07:19,409 --> 00:07:23,729
there are certain aspects that we do

00:07:21,569 --> 00:07:25,860
worry about and that is we want what we

00:07:23,729 --> 00:07:29,310
are running on the cloud to be easily

00:07:25,860 --> 00:07:31,259
consumable by other people and one of

00:07:29,310 --> 00:07:34,849
the best ways to make this easily

00:07:31,259 --> 00:07:37,530
consumable is to expose them as api's

00:07:34,849 --> 00:07:39,840
the very fact that these are exposed

00:07:37,530 --> 00:07:41,699
outside means that you do need to take

00:07:39,840 --> 00:07:46,590
that little bit of extra care and

00:07:41,699 --> 00:07:49,020
precaution of these api's Apogee has a

00:07:46,590 --> 00:07:51,870
API management platform called a PG edge

00:07:49,020 --> 00:07:53,759
and we provide you with out-of-the-box

00:07:51,870 --> 00:07:56,070
features like analytics traffic

00:07:53,759 --> 00:07:57,889
management security mediation and you

00:07:56,070 --> 00:08:00,719
can even write your custom extensions

00:07:57,889 --> 00:08:02,400
what we focus on is that we want the

00:08:00,719 --> 00:08:06,120
developer experience to be great not

00:08:02,400 --> 00:08:09,710
just for the developers of the api's but

00:08:06,120 --> 00:08:12,000
also the consumers of these api's right

00:08:09,710 --> 00:08:13,710
so in partnership with cloud foundry we

00:08:12,000 --> 00:08:15,630
have built the apogee ed service broker

00:08:13,710 --> 00:08:17,460
the apogee ed service broker is

00:08:15,630 --> 00:08:19,880
available as a route service on the

00:08:17,460 --> 00:08:22,259
cloud point for Cloud Foundry platform

00:08:19,880 --> 00:08:24,840
this can be used by developers and

00:08:22,259 --> 00:08:26,490
operators to easily plug in API

00:08:24,840 --> 00:08:28,199
management features on top of your

00:08:26,490 --> 00:08:30,240
existing applications that are running

00:08:28,199 --> 00:08:31,740
on Cloud Foundry Shannon spoke to you

00:08:30,240 --> 00:08:33,180
about the developer experience I'm just

00:08:31,740 --> 00:08:38,310
going to go and show this to you in a

00:08:33,180 --> 00:08:40,409
live demo Shannon spoke about how they

00:08:38,310 --> 00:08:42,479
request flow quickly in the context of

00:08:40,409 --> 00:08:45,060
Apogee what happens is the request comes

00:08:42,479 --> 00:08:47,400
in to Cloud Foundry you still make the

00:08:45,060 --> 00:08:49,260
request to plot foundry the go router is

00:08:47,400 --> 00:08:51,570
able to determine that there

00:08:49,260 --> 00:08:54,090
service instance associated with this

00:08:51,570 --> 00:08:55,710
route the service is proxy to the Apogee

00:08:54,090 --> 00:08:58,010
layer where you can perform your API

00:08:55,710 --> 00:08:59,490
management tasks once the API management

00:08:58,010 --> 00:09:03,210
tasks are done

00:08:59,490 --> 00:09:04,920
RPG sends this back to the go router the

00:09:03,210 --> 00:09:06,000
second time around go out and knows that

00:09:04,920 --> 00:09:08,130
it has to be forwarded to the

00:09:06,000 --> 00:09:10,110
application that's running on Cloud

00:09:08,130 --> 00:09:11,910
Foundry application returns a response

00:09:10,110 --> 00:09:17,220
and the response follows a path a

00:09:11,910 --> 00:09:20,900
similar path back out ok so let's get

00:09:17,220 --> 00:09:20,900
into the demo

00:09:29,680 --> 00:09:42,699
yeah all right so I will use the command

00:09:35,420 --> 00:09:42,699
line interface of Cloud Foundry sorry

00:09:44,800 --> 00:09:53,690
that helps yeah okay I already have an

00:09:51,290 --> 00:09:55,579
application running on Cloud Foundry let

00:09:53,690 --> 00:10:02,060
me show you what this does it returns a

00:09:55,579 --> 00:10:03,829
simple JSON response okay what I can do

00:10:02,060 --> 00:10:07,759
now is I can look at the marketplace for

00:10:03,829 --> 00:10:10,759
available services that I can use so I

00:10:07,759 --> 00:10:13,009
am looking at the marketplace I see that

00:10:10,759 --> 00:10:16,880
there is a service available called a PG

00:10:13,009 --> 00:10:18,889
edge I can look specifically at the

00:10:16,880 --> 00:10:20,660
servers I see that there is a service

00:10:18,889 --> 00:10:23,269
plan associated with it and it is

00:10:20,660 --> 00:10:25,490
currently available for free what I can

00:10:23,269 --> 00:10:27,560
do now is I can go and create an

00:10:25,490 --> 00:10:29,600
instance of the service on my

00:10:27,560 --> 00:10:38,449
environment before that let me quickly

00:10:29,600 --> 00:10:40,670
jump to the RPG platform okay so this is

00:10:38,449 --> 00:10:42,380
the RPG API management platform or right

00:10:40,670 --> 00:10:46,699
now there aren't any API proxies

00:10:42,380 --> 00:10:48,889
available here and this is where you

00:10:46,699 --> 00:10:51,620
will do all your API management tasks

00:10:48,889 --> 00:10:53,540
jumping back to the CLI I am going to

00:10:51,620 --> 00:10:55,670
create an instance of the service I

00:10:53,540 --> 00:10:58,459
specify the name of the service a PG

00:10:55,670 --> 00:10:59,720
edge the service plan I give the name of

00:10:58,459 --> 00:11:01,760
the service instance that I want to

00:10:59,720 --> 00:11:05,870
create and I'm also passing in some

00:11:01,760 --> 00:11:07,790
parameters via a configuration file this

00:11:05,870 --> 00:11:10,190
validates the right credentials are

00:11:07,790 --> 00:11:13,519
present so that we can start using a PG

00:11:10,190 --> 00:11:14,899
API management the next thing that I

00:11:13,519 --> 00:11:16,880
will do is now that I have a service

00:11:14,899 --> 00:11:20,540
instance created I need to bind this to

00:11:16,880 --> 00:11:23,810
my route so I will do this by the bind

00:11:20,540 --> 00:11:27,230
route service parameter I specify the

00:11:23,810 --> 00:11:31,399
domain and the route to which I want to

00:11:27,230 --> 00:11:33,889
bind as well as the service instance

00:11:31,399 --> 00:11:35,959
that I just created what this will do is

00:11:33,889 --> 00:11:39,620
this is going to now create a proxy on a

00:11:35,959 --> 00:11:45,590
PG so when i refresh the screen you will

00:11:39,620 --> 00:11:47,810
see that a new proxy is created

00:11:45,590 --> 00:11:49,520
which he has easy-to-use trace tool by

00:11:47,810 --> 00:11:51,380
which I can see the requests flowing

00:11:49,520 --> 00:11:55,760
into the system and the response back

00:11:51,380 --> 00:11:57,650
out let me make a curl again to this URL

00:11:55,760 --> 00:12:00,230
you see that I'm still hitting Cloud

00:11:57,650 --> 00:12:02,290
Foundry I don't need to connect to a PG

00:12:00,230 --> 00:12:06,080
because I've done this a PG sits as a

00:12:02,290 --> 00:12:08,660
service on the route the response has

00:12:06,080 --> 00:12:12,860
gone through a PG this time right

00:12:08,660 --> 00:12:16,160
currently the API proxy is it's empty

00:12:12,860 --> 00:12:17,570
there isn't much happening in here so to

00:12:16,160 --> 00:12:19,880
show you what you can do with API

00:12:17,570 --> 00:12:21,680
management I'm going to add a policy now

00:12:19,880 --> 00:12:23,870
a PG supports a lot of policies like

00:12:21,680 --> 00:12:25,250
traffic management security mediation

00:12:23,870 --> 00:12:28,310
and as I said even your custom

00:12:25,250 --> 00:12:31,640
extensions I am going to add a Spikers

00:12:28,310 --> 00:12:33,800
policy to the route I'm going to keep

00:12:31,640 --> 00:12:39,950
threshold low enough which is about 10

00:12:33,800 --> 00:12:43,400
requests per minute save this and start

00:12:39,950 --> 00:12:46,460
a trace again let's make a few more

00:12:43,400 --> 00:12:48,980
calls to this application we get a

00:12:46,460 --> 00:12:52,640
response we get a response and we start

00:12:48,980 --> 00:12:55,250
hitting these oh this biker is policy so

00:12:52,640 --> 00:12:58,430
you see here that API management is in

00:12:55,250 --> 00:13:00,710
effect and when I go back into the trace

00:12:58,430 --> 00:13:03,670
you see in the first case the request

00:13:00,710 --> 00:13:06,980
has come into a PG from the goal outer

00:13:03,670 --> 00:13:08,890
as what Shallon explained API management

00:13:06,980 --> 00:13:11,240
activities are done on the a PG layer

00:13:08,890 --> 00:13:13,010
the request is sent back to the go

00:13:11,240 --> 00:13:14,570
router in which case this time it's sent

00:13:13,010 --> 00:13:17,089
to the application that's running on

00:13:14,570 --> 00:13:21,350
Cloud Foundry response comes back out in

00:13:17,089 --> 00:13:24,830
case of a spike arrest violation you

00:13:21,350 --> 00:13:27,740
must excuse the UI here there are some

00:13:24,830 --> 00:13:29,150
things that are not being loaded what

00:13:27,740 --> 00:13:31,250
you will see here is that the response

00:13:29,150 --> 00:13:33,110
is not sent back to the application this

00:13:31,250 --> 00:13:34,880
time because it is a violation that

00:13:33,110 --> 00:13:36,410
happens on the API management layer the

00:13:34,880 --> 00:13:38,180
response is immediately sent back to the

00:13:36,410 --> 00:13:42,080
client of course through the go router

00:13:38,180 --> 00:13:43,850
okay so this is how easy it is to use to

00:13:42,080 --> 00:13:45,350
add API management features using the

00:13:43,850 --> 00:13:51,470
route services to your existing

00:13:45,350 --> 00:13:55,100
applications jumping back into the

00:13:51,470 --> 00:13:57,980
presentation in summary what you saw is

00:13:55,100 --> 00:13:59,230
that we create a service instance using

00:13:57,980 --> 00:14:01,210
the CLI you

00:13:59,230 --> 00:14:03,400
the service instance to your existing

00:14:01,210 --> 00:14:04,990
route and hopefully I also got you

00:14:03,400 --> 00:14:10,860
interested a little bit into how easy it

00:14:04,990 --> 00:14:13,990
is to do API management using a PG ok

00:14:10,860 --> 00:14:15,850
yeah so how has been the developer

00:14:13,990 --> 00:14:17,320
experience developing these the service

00:14:15,850 --> 00:14:19,840
broker itself right so Cloud Foundry

00:14:17,320 --> 00:14:22,090
exposes a set of api's that you would

00:14:19,840 --> 00:14:25,120
need to implement in order to create

00:14:22,090 --> 00:14:27,010
your own services and service broker aps

00:14:25,120 --> 00:14:28,510
are meant to be easy to use however it's

00:14:27,010 --> 00:14:29,890
very easy to make them hard as well if

00:14:28,510 --> 00:14:31,780
you do not have the right documentation

00:14:29,890 --> 00:14:33,700
the right security and do not use the

00:14:31,780 --> 00:14:35,410
right STP methods and in this regard

00:14:33,700 --> 00:14:39,790
Cloud Foundry has done a great job at

00:14:35,410 --> 00:14:41,170
exposing really easy-to-use api's it

00:14:39,790 --> 00:14:42,750
also helps that there is a good amount

00:14:41,170 --> 00:14:45,160
of testing and mock frameworks available

00:14:42,750 --> 00:14:46,750
also there is a local development

00:14:45,160 --> 00:14:48,790
environment available where you can do

00:14:46,750 --> 00:14:50,170
your development and testing locally

00:14:48,790 --> 00:14:59,350
without having to push the cloud each

00:14:50,170 --> 00:15:02,680
time yeah we can share the slides but

00:14:59,350 --> 00:15:04,120
this is a great way don't refer to this

00:15:02,680 --> 00:15:05,860
documentation but then this is a nice

00:15:04,120 --> 00:15:09,190
blog on how to make your ap as hard to

00:15:05,860 --> 00:15:10,300
use all right it's an anti-pattern don't

00:15:09,190 --> 00:15:11,740
do that

00:15:10,300 --> 00:15:14,050
of course we're going to talk a lot more

00:15:11,740 --> 00:15:16,480
about API management a lot more features

00:15:14,050 --> 00:15:18,790
that you can do with a PG in the session

00:15:16,480 --> 00:15:20,440
tomorrow at 2:30 p.m. of course all this

00:15:18,790 --> 00:15:22,900
is using the route services provided by

00:15:20,440 --> 00:15:24,700
cloud foundry for more information to

00:15:22,900 --> 00:15:26,620
build your own services or to read about

00:15:24,700 --> 00:15:30,580
this you can refer to the documentation

00:15:26,620 --> 00:15:32,320
Doc's at Cloud Foundry slash services ok

00:15:30,580 --> 00:15:37,230
that brings me to the end of my part I

00:15:32,320 --> 00:15:37,230
don't know about you guys thank you

00:15:40,430 --> 00:15:50,900
Thank You Prashant okay we're gonna

00:15:46,860 --> 00:15:50,900
switch gears and talk about TCP routing

00:15:56,270 --> 00:16:01,860
so first what was the opportunity

00:15:59,970 --> 00:16:05,910
traditionally Cloud Foundry has been a

00:16:01,860 --> 00:16:08,310
great place to operate and develop HTTP

00:16:05,910 --> 00:16:09,960
applications but there's a world of

00:16:08,310 --> 00:16:14,070
applications out there that depend on

00:16:09,960 --> 00:16:16,050
non HTTP protocols and it wouldn't it be

00:16:14,070 --> 00:16:17,850
great if developers of those

00:16:16,050 --> 00:16:20,030
applications could run their

00:16:17,850 --> 00:16:23,190
applications on Cloud Foundry also

00:16:20,030 --> 00:16:27,030
getting the same high developer velocity

00:16:23,190 --> 00:16:28,880
and minimizing time for market so our

00:16:27,030 --> 00:16:32,370
solution is support for TCP routing

00:16:28,880 --> 00:16:35,180
these are support for applications

00:16:32,370 --> 00:16:40,200
running on Cloud Foundry that require

00:16:35,180 --> 00:16:43,230
non-http TCP protocols and supports many

00:16:40,200 --> 00:16:45,210
use cases including the Internet of

00:16:43,230 --> 00:16:48,600
Things category of applications we're

00:16:45,210 --> 00:16:53,240
hearing so much about we also believe

00:16:48,600 --> 00:16:55,260
that to satisfy a use case wherein

00:16:53,240 --> 00:16:56,850
requests to applications need to be

00:16:55,260 --> 00:17:00,870
terminated as close to the application

00:16:56,850 --> 00:17:06,329
as possible here's a look at the user

00:17:00,870 --> 00:17:09,780
experience management of TCP routing is

00:17:06,329 --> 00:17:11,550
much the same as for HTTP routing with

00:17:09,780 --> 00:17:13,680
the exception that now there's a

00:17:11,550 --> 00:17:15,150
different kind of domain when you're

00:17:13,680 --> 00:17:17,370
looking at the list of domains you can

00:17:15,150 --> 00:17:21,360
create a route for you'll see that

00:17:17,370 --> 00:17:24,060
there's a domain of type TCP and when

00:17:21,360 --> 00:17:29,490
you push your application or create a

00:17:24,060 --> 00:17:32,910
route you would use this domain TCP

00:17:29,490 --> 00:17:35,460
routes are associated with ports whereas

00:17:32,910 --> 00:17:38,820
HTTP routes are defined by hosts and

00:17:35,460 --> 00:17:42,210
paths and for each TCP route a port is

00:17:38,820 --> 00:17:44,910
reserved so you can either request a

00:17:42,210 --> 00:17:47,910
port or ask the platform to allocate one

00:17:44,910 --> 00:17:50,240
for you in the bottom command you can

00:17:47,910 --> 00:17:53,270
see that I'm pushing an application

00:17:50,240 --> 00:17:56,420
and have specified a tcp domain and said

00:17:53,270 --> 00:17:58,160
that I've asked the platform to give me

00:17:56,420 --> 00:18:01,250
a random route and the platform

00:17:58,160 --> 00:18:05,600
generated a port for me and created a

00:18:01,250 --> 00:18:07,190
route from it a little look at the the

00:18:05,600 --> 00:18:08,870
architecture of this we've introduced

00:18:07,190 --> 00:18:12,740
some new components that we expect we'll

00:18:08,870 --> 00:18:17,180
provide in the eventually a point of

00:18:12,740 --> 00:18:20,330
extension there is already a emitter

00:18:17,180 --> 00:18:22,490
which supports HTTP routing the function

00:18:20,330 --> 00:18:25,880
of the emitter is to watch for events on

00:18:22,490 --> 00:18:28,550
Diego this is how we update the routing

00:18:25,880 --> 00:18:31,760
table when instances of applications are

00:18:28,550 --> 00:18:34,400
moved and the emitter ascends those

00:18:31,760 --> 00:18:36,770
events to the routing API the routing

00:18:34,400 --> 00:18:42,320
API is intended to eventually replace

00:18:36,770 --> 00:18:44,570
Nats as the the source of persistence of

00:18:42,320 --> 00:18:47,840
the routing table and the routers are

00:18:44,570 --> 00:18:50,420
watching for changes in the routing

00:18:47,840 --> 00:18:54,070
table from the routing API much as the

00:18:50,420 --> 00:18:54,070
go router currently does and nets

00:19:10,180 --> 00:19:16,460
so the emitter is a purpose film

00:19:13,490 --> 00:19:19,100
purpose-built for Diego but you could

00:19:16,460 --> 00:19:20,720
use a client of your own and send your

00:19:19,100 --> 00:19:24,910
route registrations directly to the

00:19:20,720 --> 00:19:24,910
routing API and register TCP routes

00:19:25,990 --> 00:19:33,770
that's right it works at the same heart

00:19:28,370 --> 00:19:36,080
beating heart beating mechanism so I

00:19:33,770 --> 00:19:39,700
mentioned how TCP routes were based on

00:19:36,080 --> 00:19:42,500
ports there's a couple of layers of

00:19:39,700 --> 00:19:44,180
portree addressing that goes on you can

00:19:42,500 --> 00:19:45,920
see in this example the client is

00:19:44,180 --> 00:19:48,290
sending a request to a domain and port

00:19:45,920 --> 00:19:50,750
the domain is resolved to the load

00:19:48,290 --> 00:19:55,160
balancer and the load balancer force a

00:19:50,750 --> 00:19:58,030
request to the routers at the routing in

00:19:55,160 --> 00:20:01,660
the routing table the router Maps the

00:19:58,030 --> 00:20:05,840
route port to a back-end port and that

00:20:01,660 --> 00:20:10,490
back in port here is an internal port

00:20:05,840 --> 00:20:16,120
signed by Diego and the application is

00:20:10,490 --> 00:20:16,120
listening on another port currently 8080

00:20:16,360 --> 00:20:33,620
okay with that I'd like to invite oh go

00:20:20,390 --> 00:20:35,540
ahead please Nick yes unfortunately

00:20:33,620 --> 00:20:38,770
Amazon does have a limited range of

00:20:35,540 --> 00:20:38,770
ports you can open per you be

00:20:52,169 --> 00:20:57,159
so we do expect that if there's a great

00:20:55,480 --> 00:20:58,870
demand for ports that port capacity

00:20:57,159 --> 00:21:00,820
could be an issue and we're looking for

00:20:58,870 --> 00:21:05,289
that feedback we have some ideas about

00:21:00,820 --> 00:21:08,580
how to scale port capacity including

00:21:05,289 --> 00:21:11,559
support for what we call router groups

00:21:08,580 --> 00:21:13,120
which would be a cluster of identically

00:21:11,559 --> 00:21:14,559
configured routers and you could

00:21:13,120 --> 00:21:16,419
potentially deploy multiple router

00:21:14,559 --> 00:21:19,230
groups and multiple load balancers

00:21:16,419 --> 00:21:23,259
currently the routing API supports one

00:21:19,230 --> 00:21:25,539
but based on feedback we can we have

00:21:23,259 --> 00:21:27,909
good ideas about how this could scale

00:21:25,539 --> 00:21:38,200
another way would be to support shared

00:21:27,909 --> 00:21:39,309
ports using S&I you could but we have a

00:21:38,200 --> 00:21:44,620
little bit of work to do in the routing

00:21:39,309 --> 00:21:49,179
API to enable you to support different

00:21:44,620 --> 00:21:54,990
port ranges for those load balancers for

00:21:49,179 --> 00:21:54,990
the same router group I'd be happy to

00:21:57,840 --> 00:22:01,570
yeah you I would expect that you'd map

00:22:00,250 --> 00:22:04,600
the same port from the load balancer

00:22:01,570 --> 00:22:07,870
through the router in the potato for the

00:22:04,600 --> 00:22:10,450
particulars of router groups and scaling

00:22:07,870 --> 00:22:12,190
ports we should follow up after just so

00:22:10,450 --> 00:22:16,389
I we have a chance to give that TCP

00:22:12,190 --> 00:22:18,669
router depth at the demo okay

00:22:16,389 --> 00:22:20,049
chris is our lead engineer on the

00:22:18,669 --> 00:22:22,740
routing team he's going to give a demo

00:22:20,049 --> 00:22:22,740
TCP routing

00:22:26,110 --> 00:22:31,580
all right Thank You Shannon Shannon said

00:22:29,540 --> 00:22:35,270
I was on the been on the Ryan team for

00:22:31,580 --> 00:22:37,300
about a year now helps develop and

00:22:35,270 --> 00:22:41,000
implement the route TCP routing and

00:22:37,300 --> 00:22:43,160
happy to show it off here to you all so

00:22:41,000 --> 00:22:46,810
quick overview of the demo before we

00:22:43,160 --> 00:22:49,820
actually get into it we will be doing a

00:22:46,810 --> 00:22:54,380
using mqtt protocol which is a pretty

00:22:49,820 --> 00:22:58,070
common non HTTP protocol for IOT use

00:22:54,380 --> 00:23:01,280
cases in this particular demo we'll use

00:22:58,070 --> 00:23:04,030
my handy-dandy smartphone to publish on

00:23:01,280 --> 00:23:06,710
a topic to the

00:23:04,030 --> 00:23:09,080
mqtt broker on running on Cloud Foundry

00:23:06,710 --> 00:23:10,990
and then we have another web app that is

00:23:09,080 --> 00:23:12,530
subscribed to that topic and we'll

00:23:10,990 --> 00:23:20,990
visualize the data

00:23:12,530 --> 00:23:23,410
I'm sending so if we go over here make

00:23:20,990 --> 00:23:23,410
it big

00:23:26,770 --> 00:23:30,010
how's that

00:23:34,200 --> 00:23:48,750
looks good alright so the first thing we

00:23:37,410 --> 00:23:50,700
want to do is log in so this workflow

00:23:48,750 --> 00:23:54,000
that I'm showing is the basic develop a

00:23:50,700 --> 00:23:56,610
use case of creating an app creating a

00:23:54,000 --> 00:23:58,860
TCP route and kind of doing that whole

00:23:56,610 --> 00:24:02,970
workflow that so first thing we need to

00:23:58,860 --> 00:24:07,320
do find the domains we see we have two

00:24:02,970 --> 00:24:09,390
domains shared domains one TCP there's a

00:24:07,320 --> 00:24:12,930
type TCP so we can create TCP routes

00:24:09,390 --> 00:24:16,710
from that an important thing to note

00:24:12,930 --> 00:24:21,810
with TCP routes is that as we have

00:24:16,710 --> 00:24:27,030
limited ports we have to divide them up

00:24:21,810 --> 00:24:30,540
and interesting so you have a quota that

00:24:27,030 --> 00:24:32,790
is you cannot create TCP rats if you

00:24:30,540 --> 00:24:39,000
don't have certain quota set so be aware

00:24:32,790 --> 00:24:41,220
of that so let's push our MQTT broker we

00:24:39,000 --> 00:24:49,020
are using a docker image which is pretty

00:24:41,220 --> 00:24:55,250
cool forgive my mistyping here we

00:24:49,020 --> 00:24:58,050
specify our tcp domain Superman and

00:24:55,250 --> 00:24:59,430
since we don't care what point we get

00:24:58,050 --> 00:25:01,890
we're just going to request a random

00:24:59,430 --> 00:25:07,050
route and the flight controller will

00:25:01,890 --> 00:25:07,980
basically give us one that's free and so

00:25:07,050 --> 00:25:11,310
this is just going through the normal

00:25:07,980 --> 00:25:14,400
staging pushing starting life cycle we

00:25:11,310 --> 00:25:17,840
see here that we're binding port 60,000

00:25:14,400 --> 00:25:17,840
28 to our app

00:25:22,960 --> 00:25:29,810
and it started we'll see we get a URL

00:25:26,690 --> 00:25:33,350
with the port there if we take a look at

00:25:29,810 --> 00:25:36,470
see if routes we also have that output

00:25:33,350 --> 00:25:40,220
there in this field port field six two

00:25:36,470 --> 00:25:44,600
thousand twenty eight look at amps I

00:25:40,220 --> 00:25:50,330
have pre pushed our web app mqtt web so

00:25:44,600 --> 00:25:52,280
if we go over there have it loaded so

00:25:50,330 --> 00:25:58,250
basically what we're going to do in here

00:25:52,280 --> 00:26:01,660
we put our tcp domain this is our port

00:25:58,250 --> 00:26:01,660
now what do you forget what port it is

00:26:03,220 --> 00:26:09,790
there let me get my web app ready

00:26:10,090 --> 00:26:24,740
connect no I do the same thing on my

00:26:15,410 --> 00:26:25,730
phone I wish I could show it to you you

00:26:24,740 --> 00:26:28,310
know if you want to download it real

00:26:25,730 --> 00:26:32,950
quick and believe it's on Google Play

00:26:28,310 --> 00:26:32,950
so I'm connected new interesting

00:26:38,550 --> 00:26:41,550
Superman

00:26:53,580 --> 00:26:58,140
interesting now that is unfortunate live

00:26:55,750 --> 00:27:01,480
demos are going wrong

00:26:58,140 --> 00:27:02,560
I'm actually not on the Wi-Fi because I

00:27:01,480 --> 00:27:09,640
tested it through the Wi-Fi and you

00:27:02,560 --> 00:27:22,180
didn't work all right we'll try one more

00:27:09,640 --> 00:27:27,460
time I don't know if it's the Wi-Fi

00:27:22,180 --> 00:27:29,050
that's the problem here no so this is to

00:27:27,460 --> 00:27:32,560
be clear this is not a service this is

00:27:29,050 --> 00:27:35,380
just a route it's a same way as HTTP

00:27:32,560 --> 00:27:37,600
routing this is as you pick your

00:27:35,380 --> 00:27:39,220
hostname instead of a hostname you have

00:27:37,600 --> 00:27:41,910
a port so that's how we distinguish

00:27:39,220 --> 00:27:41,910
between the two

00:27:50,440 --> 00:27:59,770
hmm I do have a video I don't know if

00:27:56,260 --> 00:28:04,080
where I have time to pull it up but huh

00:27:59,770 --> 00:28:04,080
all right let's see

00:28:17,170 --> 00:28:23,700
I was no great sorry I thought he was

00:28:20,890 --> 00:28:23,700
gonna put his laptop huh

00:28:33,420 --> 00:28:36,660
find out

00:28:41,890 --> 00:28:51,940
hey so we skipped through that part Oh

00:28:46,059 --> 00:28:54,179
whoops okay I mean how I get this going

00:28:51,940 --> 00:28:54,179
here

00:29:04,970 --> 00:29:08,000
Yeah right

00:29:17,560 --> 00:29:29,880
mm-hmm all right well it's my cousin oh

00:29:23,860 --> 00:29:33,700
there we go so let's take a look at this

00:29:29,880 --> 00:29:36,790
mmm we'll skip back faster that was a

00:29:33,700 --> 00:29:40,750
payoff right there so we're doing the

00:29:36,790 --> 00:29:43,450
same thing here and now we are going I'm

00:29:40,750 --> 00:29:47,860
connecting on my phone and suddenly we

00:29:43,450 --> 00:29:52,660
all see no got a look at the port never

00:29:47,860 --> 00:29:54,790
remember the port so there we go now

00:29:52,660 --> 00:29:56,920
this is me kind of frantically waving my

00:29:54,790 --> 00:29:58,690
arm around to generate graphs this

00:29:56,920 --> 00:30:02,170
particular thing is looking at the Y

00:29:58,690 --> 00:30:04,120
acceleration of the smartphone so those

00:30:02,170 --> 00:30:15,520
big spikes I'm meeting waiting really

00:30:04,120 --> 00:30:17,440
hard and so again this is all yes so

00:30:15,520 --> 00:30:21,130
that was all very quick and easy but

00:30:17,440 --> 00:30:24,760
this isn't now using a TCP protocol on

00:30:21,130 --> 00:30:28,270
Cloud Foundry specifically MQTT but

00:30:24,760 --> 00:30:30,040
doesn't have to be MPT you can have

00:30:28,270 --> 00:30:34,830
pretty much anything if it runs on top

00:30:30,040 --> 00:30:42,520
of TCP XMPP DVS all that good stuff all

00:30:34,830 --> 00:30:45,490
right we play this thing you could

00:30:42,520 --> 00:30:47,170
indeed I have actually talked to someone

00:30:45,490 --> 00:30:49,960
who had that idea and wanted to try it

00:30:47,170 --> 00:30:53,110
out but if you want more information

00:30:49,960 --> 00:30:55,510
about TCP routing or new routing

00:30:53,110 --> 00:30:57,730
features in general we have our routing

00:30:55,510 --> 00:31:03,150
release here at github.com on the

00:30:57,730 --> 00:31:09,040
incubator site yeah there's a demo

00:31:03,150 --> 00:31:11,960
[Applause]

00:31:09,040 --> 00:31:13,790
so we're at out of time but I think I

00:31:11,960 --> 00:31:15,380
have one more slide just to give you an

00:31:13,790 --> 00:31:18,410
idea of what the routing team is working

00:31:15,380 --> 00:31:20,140
on we've recently added support for a

00:31:18,410 --> 00:31:23,030
Zipkin tracing the router will now

00:31:20,140 --> 00:31:26,360
optionally initiate Zipkin traces it

00:31:23,030 --> 00:31:29,510
supports the b3 headers standard if your

00:31:26,360 --> 00:31:32,600
applications use a Zipkin library you

00:31:29,510 --> 00:31:34,250
can propagate that those tracing IDs we

00:31:32,600 --> 00:31:37,040
also added a little feature enabling you

00:31:34,250 --> 00:31:40,420
to send a request to a specific app

00:31:37,040 --> 00:31:43,250
instance using a particular HTTP header

00:31:40,420 --> 00:31:46,460
that takes as a value data that's

00:31:43,250 --> 00:31:48,020
available from the CF CLI we're also

00:31:46,460 --> 00:31:50,450
currently working on performance

00:31:48,020 --> 00:31:52,190
benchmarking and improving performance

00:31:50,450 --> 00:31:54,320
we've had some great talks from folks in

00:31:52,190 --> 00:31:56,420
the community or doing some of the same

00:31:54,320 --> 00:31:59,060
analysis and really appreciate the help

00:31:56,420 --> 00:32:00,740
and the next big rock that we're going

00:31:59,060 --> 00:32:02,420
to be working on is support for multiple

00:32:00,740 --> 00:32:04,310
app ports this will enable an

00:32:02,420 --> 00:32:06,620
application to listen on more than one

00:32:04,310 --> 00:32:08,660
port and fulfils use cases like

00:32:06,620 --> 00:32:12,320
applications serving web traffic on one

00:32:08,660 --> 00:32:17,210
port and app instance specific data on

00:32:12,320 --> 00:32:19,520
another we're also looking into support

00:32:17,210 --> 00:32:21,080
for certain management we hear that as a

00:32:19,520 --> 00:32:24,140
major point pain point and looking for

00:32:21,080 --> 00:32:26,810
your feedback we're also interested in

00:32:24,140 --> 00:32:28,190
getting feedback about weighted routing

00:32:26,810 --> 00:32:30,650
which would potentially enable a

00:32:28,190 --> 00:32:32,420
developer to specify that they want 10%

00:32:30,650 --> 00:32:36,800
of their traffic for a route going to a

00:32:32,420 --> 00:32:38,600
bay 90 percent going to app B and we've

00:32:36,800 --> 00:32:40,040
also believed that the routing API could

00:32:38,600 --> 00:32:42,520
eventually support a bring your own

00:32:40,040 --> 00:32:46,310
router workflow if you would like to

00:32:42,520 --> 00:32:48,320
even in the way-out future choose from a

00:32:46,310 --> 00:32:51,170
selection of routers in the marketplace

00:32:48,320 --> 00:32:53,690
I would like an f5 virtual appliance or

00:32:51,170 --> 00:32:56,780
Zul and have that used for your

00:32:53,690 --> 00:32:58,160
application only we see a path towards

00:32:56,780 --> 00:33:02,420
that we're looking for your feedback on

00:32:58,160 --> 00:33:03,560
that if you have a feedback for us come

00:33:02,420 --> 00:33:05,170
see us after the talk

00:33:03,560 --> 00:33:08,000
we're get in touch with us with slack

00:33:05,170 --> 00:33:10,640
here's my email address feel free to get

00:33:08,000 --> 00:33:12,110
in touch with me and here's our links

00:33:10,640 --> 00:33:13,870
for documentation on the presentations

00:33:12,110 --> 00:33:20,790
you saw today thank you

00:33:13,870 --> 00:33:20,790

YouTube URL: https://www.youtube.com/watch?v=40y8dMwaYyE


