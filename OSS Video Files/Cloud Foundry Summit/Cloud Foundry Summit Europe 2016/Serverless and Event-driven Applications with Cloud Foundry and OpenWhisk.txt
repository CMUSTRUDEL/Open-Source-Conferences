Title: Serverless and Event-driven Applications with Cloud Foundry and OpenWhisk
Publication date: 2016-09-30
Playlist: Cloud Foundry Summit Europe 2016
Description: 
	Serverless and Event-driven Applications with Cloud Foundry and OpenWhisk - Andrei Yurkevich, Altoros & Andreas Nauerz, IBM

Cloud Foundry represents a great platform for developing cloud-native apps. OpenWhisk is an open source serverless platform that instantly launches and scales out lightweight microservices and terminates them when they are no longer needed. It can power event-driven apps that can react to user- or machine-generated triggers to address spikes in traffic or requirements, like HA, reliability, and scalability, without the need to keep overcapacities.

In their presentation, Andreas and Andrei will talk about the sweetspots of traditional Cloud Foundry and serverless models, as well as cases where both models complement each other to create highly efficient cloud-native architectures. OpenWhisk’s core concepts, programming model, and general value proposition will be presented. Andreas and Andrei will conclude their session with a demonstration of practical examples of OpenWhisk-based end-to-end applications.

About Andreas Nauerz
Technical Product Manager, IBM

About Andrei Yurkevich
Andrei has grown Altoros’s engineering team from zero to 250 specialists across seven development centers around the world. Currently, he is building a portfolio of experts who bring "software assembly lines" into organizations through training, deployment, and integration of solutions offered by the Cloud Foundry ecosystem. The team is standing behind some of the world's largest CF deployments.
Captions: 
	00:00:00,079 --> 00:00:03,210
my name is andreas um I'm working for

00:00:02,669 --> 00:00:05,640
IBM

00:00:03,210 --> 00:00:09,599
I am technical product managers

00:00:05,640 --> 00:00:11,880
responsible for open risk and first of

00:00:09,599 --> 00:00:13,889
all thanks for being here thanks for

00:00:11,880 --> 00:00:15,330
having me here and thanks for listening

00:00:13,889 --> 00:00:17,940
to this talk that I will do together

00:00:15,330 --> 00:00:19,320
with my colleague entre so at the

00:00:17,940 --> 00:00:21,990
beginning and Trey will motivate a

00:00:19,320 --> 00:00:23,970
little a little bit and talk about what

00:00:21,990 --> 00:00:27,090
he calls the industrial Internet and

00:00:23,970 --> 00:00:29,970
then afterwards I will try to explain

00:00:27,090 --> 00:00:32,579
you the main concepts of service

00:00:29,970 --> 00:00:35,760
computing in general and open risk in

00:00:32,579 --> 00:00:38,070
particular to show you all the problems

00:00:35,760 --> 00:00:40,710
that andreas motivated before can be

00:00:38,070 --> 00:00:42,329
solved with these technologies so with

00:00:40,710 --> 00:00:45,149
this short introduction of myself I

00:00:42,329 --> 00:00:49,500
directly hand over to entry

00:00:45,149 --> 00:00:53,210
it's always your greetings everybody I'm

00:00:49,500 --> 00:00:53,210
excited to be here hope you're as well

00:00:53,390 --> 00:00:57,570
it's my pleasure to to open this

00:00:55,980 --> 00:01:02,640
breakout session in the breakout

00:00:57,570 --> 00:01:04,259
sessions at the design it and you will

00:01:02,640 --> 00:01:06,240
probably see a lot of those slides about

00:01:04,259 --> 00:01:10,619
altars where professional services

00:01:06,240 --> 00:01:12,770
company around Port Henry and the reason

00:01:10,619 --> 00:01:15,750
why we decided with interest to present

00:01:12,770 --> 00:01:18,410
assignment is that often called foundry

00:01:15,750 --> 00:01:22,289
functionality is not enough and you

00:01:18,410 --> 00:01:24,600
really can take most of advantage from

00:01:22,289 --> 00:01:26,670
the cloud native platform now when it

00:01:24,600 --> 00:01:28,770
has not only run time but also has

00:01:26,670 --> 00:01:31,590
services have different infrastructures

00:01:28,770 --> 00:01:38,009
and has possibilities to and run

00:01:31,590 --> 00:01:40,830
different kinds of applications and we

00:01:38,009 --> 00:01:45,300
will all tell you why we need web needs

00:01:40,830 --> 00:01:47,670
event-driven infrastructure I will give

00:01:45,300 --> 00:01:52,709
you some retrieval cases which will

00:01:47,670 --> 00:01:57,149
demonstrate now when we can take the

00:01:52,709 --> 00:02:01,200
most benefit out of it and we will speak

00:01:57,149 --> 00:02:04,069
about the requirement what we expect

00:02:01,200 --> 00:02:07,110
from event-driven infrastructure and

00:02:04,069 --> 00:02:09,899
unrest then we'll introduce open risk

00:02:07,110 --> 00:02:12,840
and they will explain at what extent it

00:02:09,899 --> 00:02:15,959
addresses those requirements we will

00:02:12,840 --> 00:02:19,680
tell about how open wisk can work with

00:02:15,959 --> 00:02:26,520
cold foundry and we will run a short a

00:02:19,680 --> 00:02:33,720
very simple demo open with connection so

00:02:26,520 --> 00:02:35,599
to start with we often now speak about

00:02:33,720 --> 00:02:39,300
industrial Internet Internet of Things

00:02:35,599 --> 00:02:41,190
industry 4.0 what is it about it's about

00:02:39,300 --> 00:02:45,120
the different devices that are connected

00:02:41,190 --> 00:02:47,400
to the cloud and devices could be it

00:02:45,120 --> 00:02:49,019
could be different there could be some

00:02:47,400 --> 00:02:51,030
devices ascend to their information to

00:02:49,019 --> 00:02:52,590
cloud some information get information

00:02:51,030 --> 00:02:54,530
from the cloud

00:02:52,590 --> 00:02:56,939
there could be bi-directional devices

00:02:54,530 --> 00:02:58,530
but what they hear what they all have in

00:02:56,939 --> 00:03:01,770
common is that

00:02:58,530 --> 00:03:04,350
they don't have to be connected to and

00:03:01,770 --> 00:03:07,500
to the server all the time the most

00:03:04,350 --> 00:03:10,170
cases they just send a signal you get a

00:03:07,500 --> 00:03:12,360
signal send a signal get a signal it

00:03:10,170 --> 00:03:15,840
might happen or once a minute when once

00:03:12,360 --> 00:03:21,800
an hour or maybe once a year but quite

00:03:15,840 --> 00:03:26,100
often quite often these signals both

00:03:21,800 --> 00:03:28,620
incoming and receiving are important for

00:03:26,100 --> 00:03:31,830
business for security of people for life

00:03:28,620 --> 00:03:37,500
of people so we need to have reliable

00:03:31,830 --> 00:03:39,090
connection however we don't need to have

00:03:37,500 --> 00:03:43,200
those devices connected to the cloud all

00:03:39,090 --> 00:03:45,390
the time and in general now what is the

00:03:43,200 --> 00:03:48,080
way how we have implement industrial

00:03:45,390 --> 00:03:53,310
Internet connected devices we have

00:03:48,080 --> 00:03:57,600
devices and they connect to some compute

00:03:53,310 --> 00:04:01,830
infrastructure in a very simple universe

00:03:57,600 --> 00:04:09,360
simple case we have one device one

00:04:01,830 --> 00:04:15,269
device what do you think what it is and

00:04:09,360 --> 00:04:20,820
it is yeah physical it's a physical

00:04:15,269 --> 00:04:22,740
Bitcoin just amazing imagine physical

00:04:20,820 --> 00:04:27,120
physical implementation of Bitcoin

00:04:22,740 --> 00:04:29,910
connected to a cloud so now we'll have a

00:04:27,120 --> 00:04:35,940
device connected to virtual machine or a

00:04:29,910 --> 00:04:42,690
container and in some cases we need to

00:04:35,940 --> 00:04:46,650
have to have high bill t44 for this

00:04:42,690 --> 00:04:50,160
device and how we will implement it in

00:04:46,650 --> 00:04:53,940
in AWS or in called foundry now we will

00:04:50,160 --> 00:04:56,250
have an application present and we will

00:04:53,940 --> 00:04:58,440
have a daemon running in in this

00:04:56,250 --> 00:05:04,830
application and it will listening for

00:04:58,440 --> 00:05:07,979
incoming connection all the time again I

00:05:04,830 --> 00:05:10,710
was not telling about devices that don't

00:05:07,979 --> 00:05:13,000
have to be don't have to be in

00:05:10,710 --> 00:05:16,090
don't know they don't send information

00:05:13,000 --> 00:05:18,310
all the time but in order to implement

00:05:16,090 --> 00:05:23,070
this functionality and I will do a AWS

00:05:18,310 --> 00:05:23,070
and or in called foundry we're using

00:05:23,130 --> 00:05:28,030
different traditional passes or

00:05:25,330 --> 00:05:30,670
infrastructure services you have to not

00:05:28,030 --> 00:05:32,980
have a process that is listening all the

00:05:30,670 --> 00:05:37,570
time because again sometimes our lives

00:05:32,980 --> 00:05:39,430
is dependent on this signal and in some

00:05:37,570 --> 00:05:41,760
cases it should be highly available so

00:05:39,430 --> 00:05:45,660
we have two instances of applications

00:05:41,760 --> 00:05:49,150
sitting there waiting for first signal

00:05:45,660 --> 00:05:51,010
which may come today maybe it's more

00:05:49,150 --> 00:05:51,820
room it may be may be once they may be

00:05:51,010 --> 00:05:56,830
maybe never

00:05:51,820 --> 00:05:59,110
and what's imagine that we have two

00:05:56,830 --> 00:06:02,380
devices so the question the question is

00:05:59,110 --> 00:06:07,060
do we have to propagate our

00:06:02,380 --> 00:06:08,890
infrastructure to multiple containers to

00:06:07,060 --> 00:06:12,480
connect to to the devices do do do or

00:06:08,890 --> 00:06:14,770
any head we really need to have an

00:06:12,480 --> 00:06:18,130
instance of a container of virtual

00:06:14,770 --> 00:06:20,710
machine per for each device and also

00:06:18,130 --> 00:06:22,870
have it highly available so we have this

00:06:20,710 --> 00:06:24,700
this big infrastructure just for two

00:06:22,870 --> 00:06:29,260
devices let's assume that we are smart

00:06:24,700 --> 00:06:34,360
and that we don't have to connect one

00:06:29,260 --> 00:06:36,370
device for one machine and we can have

00:06:34,360 --> 00:06:39,070
multiple demons sitting in one virtual

00:06:36,370 --> 00:06:41,200
machine and not listening for incoming

00:06:39,070 --> 00:06:43,600
incoming devices and this way we will be

00:06:41,200 --> 00:06:49,630
able to optimize utilization of our

00:06:43,600 --> 00:06:52,060
infrastructure so we cut down the number

00:06:49,630 --> 00:06:55,290
of our infrastructure we have two

00:06:52,060 --> 00:06:59,490
virtual machines or two containers

00:06:55,290 --> 00:07:05,290
having multiple demons running on them

00:06:59,490 --> 00:07:06,580
waiting for for connection and what

00:07:05,290 --> 00:07:08,830
summation that we have an unexpected

00:07:06,580 --> 00:07:10,990
spike in traffic and we have many many

00:07:08,830 --> 00:07:16,060
many many devices and

00:07:10,990 --> 00:07:19,930
we may have to scale out lotto or not

00:07:16,060 --> 00:07:23,229
the took over this with this load so we

00:07:19,930 --> 00:07:28,810
was killed out and at some point the

00:07:23,229 --> 00:07:30,310
time traffic goes down and we have we

00:07:28,810 --> 00:07:32,530
have this number of devices then we have

00:07:30,310 --> 00:07:34,180
this number of devices and right now

00:07:32,530 --> 00:07:37,690
it's a really mess and we don't

00:07:34,180 --> 00:07:40,090
understand which which service shall we

00:07:37,690 --> 00:07:42,069
sit down maybe these two servers maybe

00:07:40,090 --> 00:07:45,099
these two servers the position of

00:07:42,069 --> 00:07:47,259
cluster goes down but we don't now don't

00:07:45,099 --> 00:07:50,650
know which exact device is connected to

00:07:47,259 --> 00:07:51,940
which server and there will be several

00:07:50,650 --> 00:07:53,380
connections on this servers or

00:07:51,940 --> 00:07:55,870
connection on this servers or connection

00:07:53,380 --> 00:07:58,900
on this server so if we in just shut

00:07:55,870 --> 00:08:04,180
down underutilized server then we lose

00:07:58,900 --> 00:08:07,389
some some connections so we have to keep

00:08:04,180 --> 00:08:10,990
this infrastructure in place and traffic

00:08:07,389 --> 00:08:15,190
goes down and down the Spears so now we

00:08:10,990 --> 00:08:17,620
can destroy anything so we're coming to

00:08:15,190 --> 00:08:20,919
two situation that in ideal case we need

00:08:17,620 --> 00:08:23,470
to have one container or one device so

00:08:20,919 --> 00:08:26,139
that if we have many devices will have

00:08:23,470 --> 00:08:28,180
many containers if we have a few advices

00:08:26,139 --> 00:08:33,729
connected to tune to the cloud we have

00:08:28,180 --> 00:08:36,849
your containers and if we don't address

00:08:33,729 --> 00:08:38,770
the issue of vascular built-in now then

00:08:36,849 --> 00:08:41,140
we need to have this called

00:08:38,770 --> 00:08:44,110
infrastructure provisioned all the time

00:08:41,140 --> 00:08:47,560
and waiting for incoming connections and

00:08:44,110 --> 00:08:50,860
we need to adopt Mize for the maximum

00:08:47,560 --> 00:08:52,660
load of over the cloud for the maximum

00:08:50,860 --> 00:08:56,380
number of devices could be connected and

00:08:52,660 --> 00:08:59,829
it could be quite quite costly what cost

00:08:56,380 --> 00:09:02,279
endeavor in ideal case we need to have

00:08:59,829 --> 00:09:04,810
zero infrastructure for zero connections

00:09:02,279 --> 00:09:13,209
and to have compute following the

00:09:04,810 --> 00:09:15,040
traffic so now we are coming to to a

00:09:13,209 --> 00:09:16,660
point when we need to specify what

00:09:15,040 --> 00:09:18,510
requirements to event-driven

00:09:16,660 --> 00:09:20,760
infrastructure we in

00:09:18,510 --> 00:09:22,889
we'll want to address as we're speaking

00:09:20,760 --> 00:09:26,550
in this case we need to invoke invoke

00:09:22,889 --> 00:09:29,010
and scale as fast as possible ideally in

00:09:26,550 --> 00:09:31,380
a fraction of a second so and so that's

00:09:29,010 --> 00:09:34,620
when when we don't have an

00:09:31,380 --> 00:09:36,630
infrastructure at all then we get a

00:09:34,620 --> 00:09:39,690
signal and we have this infrastructure

00:09:36,630 --> 00:09:43,589
provisioned to process the signal and it

00:09:39,690 --> 00:09:45,089
should it should have a fast then we

00:09:43,589 --> 00:09:49,350
want to terminate this infrastructure

00:09:45,089 --> 00:09:50,820
after the job is completed ideally we

00:09:49,350 --> 00:09:52,829
want to get charged for a commute used

00:09:50,820 --> 00:09:57,449
we don't want to get charged for a

00:09:52,829 --> 00:10:00,260
demon's waiting for the connection we

00:09:57,449 --> 00:10:04,500
need to have reliability of a service

00:10:00,260 --> 00:10:08,459
now we need to we need to be very

00:10:04,500 --> 00:10:10,709
available and self-healing ideally we

00:10:08,459 --> 00:10:12,750
need to and to be able to use different

00:10:10,709 --> 00:10:16,970
technologies to develop for this

00:10:12,750 --> 00:10:19,620
infrastructure so launch micro services

00:10:16,970 --> 00:10:23,490
get it connected to different data

00:10:19,620 --> 00:10:26,639
sources and also would be would be good

00:10:23,490 --> 00:10:28,860
to have developers abstracted from from

00:10:26,639 --> 00:10:31,860
the infrastructure so they don't have to

00:10:28,860 --> 00:10:34,709
manage all this all the system now

00:10:31,860 --> 00:10:36,779
provisioning of containers taking them

00:10:34,709 --> 00:10:40,560
down all the scaling load balancing

00:10:36,779 --> 00:10:44,760
routing and abstract them from from that

00:10:40,560 --> 00:10:47,130
complexity so now Andres will tell you

00:10:44,760 --> 00:10:48,750
about open risk and how does it how does

00:10:47,130 --> 00:10:53,160
it help to address all this all these

00:10:48,750 --> 00:10:55,620
questions before diving into technology

00:10:53,160 --> 00:10:57,839
I would like to show you how we started

00:10:55,620 --> 00:11:02,190
as an IBM because I think that conveys a

00:10:57,839 --> 00:11:04,079
very important message as well so the

00:11:02,190 --> 00:11:07,790
dive tenders their field or service

00:11:04,079 --> 00:11:10,649
computing in the early years of 2015 and

00:11:07,790 --> 00:11:12,750
it hasn't really been born as a resource

00:11:10,649 --> 00:11:15,209
project that we started off at a TJ

00:11:12,750 --> 00:11:17,100
Watson Research Center and your Tom but

00:11:15,209 --> 00:11:18,839
meanwhile we have development teams that

00:11:17,100 --> 00:11:21,569
are working on the technology of open

00:11:18,839 --> 00:11:23,760
risk in development locations around the

00:11:21,569 --> 00:11:26,040
globe so we are developing on open risk

00:11:23,760 --> 00:11:29,140
in building Germany in Raleigh North

00:11:26,040 --> 00:11:31,240
Carolina in Austin Texas and many more

00:11:29,140 --> 00:11:33,370
and I think that conveys an important

00:11:31,240 --> 00:11:36,010
message because it demonstrates that

00:11:33,370 --> 00:11:39,730
this is for us a very important effort

00:11:36,010 --> 00:11:41,709
it also demonstrates that we regard this

00:11:39,730 --> 00:11:44,140
technology to have the potential to

00:11:41,709 --> 00:11:46,690
become a game-changer for future the

00:11:44,140 --> 00:11:50,140
future Rea of developing cloud native

00:11:46,690 --> 00:11:53,800
applications nothing is important to

00:11:50,140 --> 00:11:56,110
make that to point that out but what the

00:11:53,800 --> 00:11:58,120
hell is open risk so very crisp and to

00:11:56,110 --> 00:12:00,970
the point already short one sentence

00:11:58,120 --> 00:12:03,390
definition open risk is an event action

00:12:00,970 --> 00:12:07,300
platform that allows you as a developer

00:12:03,390 --> 00:12:10,209
to execute code interest in response to

00:12:07,300 --> 00:12:11,260
an event so is respect to what country

00:12:10,209 --> 00:12:13,769
said for instance

00:12:11,260 --> 00:12:17,250
that could mean that you can execute

00:12:13,769 --> 00:12:21,100
custom logic in response

00:12:17,250 --> 00:12:23,620
just because an IOT device has emitted

00:12:21,100 --> 00:12:26,019
an event and this event is then a kind

00:12:23,620 --> 00:12:28,269
of a trigger that a stand supposed to

00:12:26,019 --> 00:12:30,700
pick off application logic that you of

00:12:28,269 --> 00:12:34,449
the developer has written okay that's

00:12:30,700 --> 00:12:35,920
actually what it does open risk is being

00:12:34,449 --> 00:12:38,410
offered in two ways

00:12:35,920 --> 00:12:40,149
so you can get access to open risk if

00:12:38,410 --> 00:12:42,070
you go to the plumies platform that's

00:12:40,149 --> 00:12:44,470
where our commercial offering is running

00:12:42,070 --> 00:12:47,050
so as of today you can just access to

00:12:44,470 --> 00:12:48,760
bluemix offer the bluemix platform can

00:12:47,050 --> 00:12:51,579
go to open risk and can play around with

00:12:48,760 --> 00:12:53,550
it directly you have the CLIA field you

00:12:51,579 --> 00:12:56,620
are with you I just play around with it

00:12:53,550 --> 00:12:59,589
but we also made it available as an open

00:12:56,620 --> 00:13:01,779
source project it's being hosted on

00:12:59,589 --> 00:13:03,820
github and of course I would here like

00:13:01,779 --> 00:13:05,890
to take the opportunity and to encourage

00:13:03,820 --> 00:13:09,010
you to really do that so please go to

00:13:05,890 --> 00:13:11,290
our github our site have a look at what

00:13:09,010 --> 00:13:14,019
we are doing there provide feedback and

00:13:11,290 --> 00:13:17,230
feel invited to and that would be even

00:13:14,019 --> 00:13:19,630
better to participate and contribute to

00:13:17,230 --> 00:13:21,860
accelerate a development of that open of

00:13:19,630 --> 00:13:24,170
this open technology

00:13:21,860 --> 00:13:27,529
so what is open risk a little bit more

00:13:24,170 --> 00:13:30,080
details so open risks propagates a

00:13:27,529 --> 00:13:33,160
service deployment and operation model

00:13:30,080 --> 00:13:35,089
which means it hides any kind of

00:13:33,160 --> 00:13:37,850
infrastructural and operational

00:13:35,089 --> 00:13:40,459
complexity allowing you as a developer

00:13:37,850 --> 00:13:42,560
to focus on what you really want to do

00:13:40,459 --> 00:13:44,810
namely developing quickly

00:13:42,560 --> 00:13:46,490
well you're a team coach that's your

00:13:44,810 --> 00:13:48,470
main focus so it's a little bit like if

00:13:46,490 --> 00:13:50,720
I would have to say it was Logan it

00:13:48,470 --> 00:13:53,720
would be a little bit like you provide

00:13:50,720 --> 00:13:55,880
us code and be executed for you and you

00:13:53,720 --> 00:13:58,550
do not have to worry anymore about all

00:13:55,880 --> 00:14:00,790
these low-level details we also

00:13:58,550 --> 00:14:04,399
guarantee you an optimal utilization

00:14:00,790 --> 00:14:07,790
we're do not have to pay for resources

00:14:04,399 --> 00:14:10,100
just idling around what would have been

00:14:07,790 --> 00:14:14,120
the case in the old world if you rent

00:14:10,100 --> 00:14:17,690
this VM sensor force and it inherently

00:14:14,120 --> 00:14:21,230
scales honor her request basis because

00:14:17,690 --> 00:14:24,470
at any point in time we provide us the

00:14:21,230 --> 00:14:28,160
exact amount of resources on compute

00:14:24,470 --> 00:14:30,940
power storage memory that you need to

00:14:28,160 --> 00:14:34,880
operate your application efficiently

00:14:30,940 --> 00:14:37,220
open which also provides you with a

00:14:34,880 --> 00:14:39,260
flexible programming model where

00:14:37,220 --> 00:14:42,529
developers can develop in totally

00:14:39,260 --> 00:14:47,420
different languages like Swift like Java

00:14:42,529 --> 00:14:50,959
like peyten like JavaScript and they

00:14:47,420 --> 00:14:53,360
even can execute custom logic by being

00:14:50,959 --> 00:14:56,329
able to run docker containers in

00:14:53,360 --> 00:14:58,910
response to these events we even support

00:14:56,329 --> 00:15:00,829
things like interweaving or

00:14:58,910 --> 00:15:02,990
interconnecting the little puzzle pieces

00:15:00,829 --> 00:15:06,440
that you have developed in a decorative

00:15:02,990 --> 00:15:08,630
fashion by doing things like chaining

00:15:06,440 --> 00:15:11,540
all these things that are part of this

00:15:08,630 --> 00:15:15,020
flexible programming model allow your

00:15:11,540 --> 00:15:16,640
developers to reuse existing skills so

00:15:15,020 --> 00:15:19,970
they do not have to learn new languages

00:15:16,640 --> 00:15:21,920
for example and to fit in a and develop

00:15:19,970 --> 00:15:24,050
in a fit for purpose fashion because

00:15:21,920 --> 00:15:26,540
they can tackle each problem that have

00:15:24,050 --> 00:15:29,720
been assigned to using the best suite of

00:15:26,540 --> 00:15:31,850
technology by the bestest the entire

00:15:29,720 --> 00:15:32,460
technology is open so the engine itself

00:15:31,850 --> 00:15:35,790
is so

00:15:32,460 --> 00:15:37,680
and it's being built on open

00:15:35,790 --> 00:15:40,200
technologies as well as we leverage

00:15:37,680 --> 00:15:43,140
things like doctor or Kafka console and

00:15:40,200 --> 00:15:46,020
so forth but even the entire ecosystem

00:15:43,140 --> 00:15:49,080
around us open and this entire ecosystem

00:15:46,020 --> 00:15:50,970
stem comprised of event emitters so

00:15:49,080 --> 00:15:53,340
services emitting the event than

00:15:50,970 --> 00:15:57,570
supposed to kick off an action and event

00:15:53,340 --> 00:16:00,060
consumers and all these different event

00:15:57,570 --> 00:16:01,680
consumers and the event emitters it can

00:16:00,060 --> 00:16:04,170
even be provided by different vendors

00:16:01,680 --> 00:16:07,410
which is what makes the opening tester

00:16:04,170 --> 00:16:09,930
at the ecosystem open um we also provide

00:16:07,410 --> 00:16:12,270
us an open interface for event providers

00:16:09,930 --> 00:16:16,530
which makes it even better because that

00:16:12,270 --> 00:16:18,780
means that everyone including you can

00:16:16,530 --> 00:16:21,750
enable any servers that has not been

00:16:18,780 --> 00:16:23,250
enabled before VARs so it's not only the

00:16:21,750 --> 00:16:25,440
engine that is open it's also the

00:16:23,250 --> 00:16:28,160
ecosystem that is open so that we can

00:16:25,440 --> 00:16:30,690
end up with a lot of event emitters and

00:16:28,160 --> 00:16:35,280
open risk has been implemented just for

00:16:30,690 --> 00:16:37,260
performance reasons in SCADA so the

00:16:35,280 --> 00:16:39,210
question that remains of course is how

00:16:37,260 --> 00:16:42,120
can this be better than a traditional

00:16:39,210 --> 00:16:45,420
model and I would I'd like to explained

00:16:42,120 --> 00:16:49,440
it along a simple example so assume you

00:16:45,420 --> 00:16:51,840
have you want to execute logic just

00:16:49,440 --> 00:16:54,840
because something has changed in a

00:16:51,840 --> 00:16:57,210
database service like Cloudant so how

00:16:54,840 --> 00:16:58,860
would you have done that in the past so

00:16:57,210 --> 00:17:01,020
what you probably would do is you would

00:16:58,860 --> 00:17:03,330
write a little application that little

00:17:01,020 --> 00:17:05,190
application would contain code that can

00:17:03,330 --> 00:17:07,350
then connect to your database and can

00:17:05,190 --> 00:17:09,990
check if there was a change this little

00:17:07,350 --> 00:17:11,490
application will then run on a VM or as

00:17:09,990 --> 00:17:12,690
part of a container maybe you're

00:17:11,490 --> 00:17:15,750
implemented as a Cloud Foundry

00:17:12,690 --> 00:17:18,450
application something like that okay but

00:17:15,750 --> 00:17:19,980
then due to the absence of real event

00:17:18,450 --> 00:17:22,050
programming model where the service

00:17:19,980 --> 00:17:24,510
itself can tell you that something has

00:17:22,050 --> 00:17:26,640
changed you would to do you would have

00:17:24,510 --> 00:17:28,830
to do something like polling so you

00:17:26,640 --> 00:17:29,910
would have to ask the application over

00:17:28,830 --> 00:17:33,420
and over again

00:17:29,910 --> 00:17:35,280
hey has something changed and of course

00:17:33,420 --> 00:17:37,470
this is from a utilization trusted

00:17:35,280 --> 00:17:39,780
perspective very poor because that means

00:17:37,470 --> 00:17:42,960
the application is very often waiting

00:17:39,780 --> 00:17:44,970
for the next request to come in but at

00:17:42,960 --> 00:17:45,510
the same point in time the underlying VM

00:17:44,970 --> 00:17:47,460
for

00:17:45,510 --> 00:17:50,730
Zomba is still up and running so you

00:17:47,460 --> 00:17:52,800
have to pay for all that even worse from

00:17:50,730 --> 00:17:56,160
a scalability perspective so if you went

00:17:52,800 --> 00:17:59,130
for REM for example at the point in time

00:17:56,160 --> 00:18:01,440
you order to VM you are bound to the

00:17:59,130 --> 00:18:04,170
capacity you have ordered but what if

00:18:01,440 --> 00:18:08,370
load increases then you need to answer

00:18:04,170 --> 00:18:10,110
the question how when and how fast do I

00:18:08,370 --> 00:18:12,360
have to scale out so what you probably

00:18:10,110 --> 00:18:14,760
have to do which is again not a business

00:18:12,360 --> 00:18:16,980
developers being interested in he would

00:18:14,760 --> 00:18:19,140
probably have to do things like setting

00:18:16,980 --> 00:18:21,780
up very complex auto scaling which they

00:18:19,140 --> 00:18:23,610
define when to scale out for example

00:18:21,780 --> 00:18:25,890
maybe because the memory is running low

00:18:23,610 --> 00:18:27,660
the response time goes down all that

00:18:25,890 --> 00:18:30,060
stuff you as a developer actually not

00:18:27,660 --> 00:18:31,770
being interested in so it's really hear

00:18:30,060 --> 00:18:34,140
about radically simplifying the

00:18:31,770 --> 00:18:36,900
development process by making it not

00:18:34,140 --> 00:18:39,030
necessary anymore to take to to worry

00:18:36,900 --> 00:18:42,030
about these low-level things even worse

00:18:39,030 --> 00:18:44,820
you have even to think about resiliency

00:18:42,030 --> 00:18:47,070
so if you want to achieve high

00:18:44,820 --> 00:18:49,620
availability you need at least two

00:18:47,070 --> 00:18:53,700
processes mmm which is a kind of

00:18:49,620 --> 00:18:54,510
redundancy so of cost is forced money in

00:18:53,700 --> 00:18:56,730
sorry

00:18:54,510 --> 00:18:59,250
and probably you also want to have

00:18:56,730 --> 00:19:01,080
mildly rich deployments that costs money

00:18:59,250 --> 00:19:04,500
as well and of course keeping everything

00:19:01,080 --> 00:19:08,460
of that are running and healthy costs

00:19:04,500 --> 00:19:11,130
money again so open risk helps helps you

00:19:08,460 --> 00:19:13,170
to overcome these drawbacks so what we

00:19:11,130 --> 00:19:15,330
have is we have this little trigger here

00:19:13,170 --> 00:19:17,610
which might be the event that is being

00:19:15,330 --> 00:19:19,920
emitted by a service like 'loudened and

00:19:17,610 --> 00:19:22,590
this little event and arrives at the

00:19:19,920 --> 00:19:24,690
open risk engine and then we determine

00:19:22,590 --> 00:19:26,400
in the open risk engine what a right

00:19:24,690 --> 00:19:28,560
action is that is supposed to be

00:19:26,400 --> 00:19:30,630
executed at the action by DeRay is the

00:19:28,560 --> 00:19:32,700
little piece that encapsulates the

00:19:30,630 --> 00:19:34,530
application logic here as the developer

00:19:32,700 --> 00:19:36,870
of written in any of the languages that

00:19:34,530 --> 00:19:39,300
we support and then the magic the magic

00:19:36,870 --> 00:19:41,610
happens because what we do is we are

00:19:39,300 --> 00:19:46,620
able to deploy these little actions very

00:19:41,610 --> 00:19:48,810
quickly in milliseconds we run it and we

00:19:46,620 --> 00:19:51,330
take the response and and send it back

00:19:48,810 --> 00:19:53,760
and then we free up resources again and

00:19:51,330 --> 00:19:55,890
that means there is nothing idling

00:19:53,760 --> 00:19:59,190
around anymore we have a 100%

00:19:55,890 --> 00:20:01,380
utilization and we have real event

00:19:59,190 --> 00:20:03,060
model because that trigger is telling

00:20:01,380 --> 00:20:06,420
that something has changed right

00:20:03,060 --> 00:20:08,820
we are not polling anymore even better

00:20:06,420 --> 00:20:11,850
is that we can scale inherently because

00:20:08,820 --> 00:20:13,530
we can paralyze the deployment of these

00:20:11,850 --> 00:20:15,480
little actions so if the load is

00:20:13,530 --> 00:20:17,490
increasing we just deploy more of these

00:20:15,480 --> 00:20:19,200
actions if the load is decreasing we

00:20:17,490 --> 00:20:21,570
just try to get rid of some of these

00:20:19,200 --> 00:20:23,640
actions so we always have exactly this

00:20:21,570 --> 00:20:26,160
amount of actions that we really need

00:20:23,640 --> 00:20:27,840
and of course you don't have to worry

00:20:26,160 --> 00:20:31,830
about resiliency anymore because this

00:20:27,840 --> 00:20:34,620
entirely becomes our business so how

00:20:31,830 --> 00:20:38,580
does open risk work be it behind the

00:20:34,620 --> 00:20:40,620
scenes so the events that are that cause

00:20:38,580 --> 00:20:42,780
the actions to be kicked off they are

00:20:40,620 --> 00:20:44,490
emitted by what we call event providers

00:20:42,780 --> 00:20:46,110
typically event providers can be

00:20:44,490 --> 00:20:47,700
Cloudant I've just talked about it

00:20:46,110 --> 00:20:50,460
already it can be a push notification

00:20:47,700 --> 00:20:53,100
service something like that and once

00:20:50,460 --> 00:20:55,320
this and all these services that can be

00:20:53,100 --> 00:20:56,910
services run on clinics but of course it

00:20:55,320 --> 00:20:58,770
can be also services running outside of

00:20:56,910 --> 00:21:00,780
bluemix and as I've already told you if

00:20:58,770 --> 00:21:03,000
you have a service that has not yet been

00:21:00,780 --> 00:21:05,460
enabled so it's not yet admitting events

00:21:03,000 --> 00:21:07,410
that open risk understands you can do

00:21:05,460 --> 00:21:09,690
that on your own because we have that

00:21:07,410 --> 00:21:11,580
open service provider interface if you

00:21:09,690 --> 00:21:13,080
are a service provider please do that

00:21:11,580 --> 00:21:15,630
that's exactly what I would like to

00:21:13,080 --> 00:21:17,430
encourage you here today right um anyway

00:21:15,630 --> 00:21:18,870
if the event then arrives at the open

00:21:17,430 --> 00:21:20,970
risk engine we have something that we

00:21:18,870 --> 00:21:24,180
call the rule and the rule tells the

00:21:20,970 --> 00:21:26,790
system if this event is coming in then

00:21:24,180 --> 00:21:29,120
please execute this little action being

00:21:26,790 --> 00:21:32,130
implemented in this particular language

00:21:29,120 --> 00:21:33,720
of course what yours can do is you can

00:21:32,130 --> 00:21:36,120
invoke little action in a more direct

00:21:33,720 --> 00:21:38,820
fashion so you can invoke it by doing

00:21:36,120 --> 00:21:40,830
just an API call namely a REST API call

00:21:38,820 --> 00:21:42,750
so imagine you have a little bit a

00:21:40,830 --> 00:21:46,020
patient or a little mobile application

00:21:42,750 --> 00:21:47,640
supposed to to list the set of customers

00:21:46,020 --> 00:21:48,990
so what you probably would do is you

00:21:47,640 --> 00:21:50,400
would have a little button in the web

00:21:48,990 --> 00:21:52,830
application a mobile application and

00:21:50,400 --> 00:21:55,380
once that is being clicked on API calls

00:21:52,830 --> 00:21:57,000
being made and then it ends up at the

00:21:55,380 --> 00:21:58,950
open risk and can be determined once

00:21:57,000 --> 00:22:00,720
again the right action to be executed

00:21:58,950 --> 00:22:03,630
and the action would contain the code

00:22:00,720 --> 00:22:05,790
that can then connect to the data place

00:22:03,630 --> 00:22:07,130
fetch the right subset of customers to

00:22:05,790 --> 00:22:08,630
be displayed and handed back

00:22:07,130 --> 00:22:12,890
to the web application or the mobile

00:22:08,630 --> 00:22:14,900
application so coming to the programming

00:22:12,890 --> 00:22:16,520
model before handover back to to aintry

00:22:14,900 --> 00:22:18,770
houston demonstrating this along an

00:22:16,520 --> 00:22:20,540
example it's very very simple the

00:22:18,770 --> 00:22:23,510
programming model we want to have a very

00:22:20,540 --> 00:22:25,460
lower entry barrier so on the one hand

00:22:23,510 --> 00:22:27,590
side we have the services that emit the

00:22:25,460 --> 00:22:29,240
events as triggers but the only thing

00:22:27,590 --> 00:22:31,160
the developer has to take care of for

00:22:29,240 --> 00:22:32,810
severely implementing these little

00:22:31,160 --> 00:22:34,970
actions in the languages that we support

00:22:32,810 --> 00:22:36,770
it's all he has to do and then there's

00:22:34,970 --> 00:22:39,260
an additional one liner that he can do

00:22:36,770 --> 00:22:42,740
and using our CLI he has to associate

00:22:39,260 --> 00:22:44,510
these little triggers with these actions

00:22:42,740 --> 00:22:46,990
so that the system knows if this trigger

00:22:44,510 --> 00:22:49,460
is coming and please execute this action

00:22:46,990 --> 00:22:51,560
so triggers are actually nothing else

00:22:49,460 --> 00:22:53,780
than classes of events that can happen

00:22:51,560 --> 00:22:55,430
before already had a look at this one so

00:22:53,780 --> 00:22:57,410
events can be emitted by database

00:22:55,430 --> 00:23:00,560
centric services just because something

00:22:57,410 --> 00:23:02,330
has changed ended in the database may be

00:23:00,560 --> 00:23:04,610
data has been updated to lead it or

00:23:02,330 --> 00:23:06,410
something like that it can also be with

00:23:04,610 --> 00:23:08,630
respect to what Aundre explained it can

00:23:06,410 --> 00:23:10,700
also be an IOT service which might emit

00:23:08,630 --> 00:23:13,670
in the event just because an IOT device

00:23:10,700 --> 00:23:15,290
has sent some particular data it can be

00:23:13,670 --> 00:23:16,880
an analytic service for example maybe

00:23:15,290 --> 00:23:19,040
there is a service that is continuously

00:23:16,880 --> 00:23:20,960
scanning to a Twitter stream and has

00:23:19,040 --> 00:23:23,030
just detected a trend and just because

00:23:20,960 --> 00:23:24,890
it has detected a trend it emits an

00:23:23,030 --> 00:23:27,080
event and that fires of an action that

00:23:24,890 --> 00:23:29,390
contains some some logic it is supposed

00:23:27,080 --> 00:23:31,160
to be kicked off or it can be that a

00:23:29,390 --> 00:23:32,900
simple service like it is a meeting

00:23:31,160 --> 00:23:35,960
event just because there was a change in

00:23:32,900 --> 00:23:37,820
the git repository um actions are just

00:23:35,960 --> 00:23:40,280
event handlers contain area code that's

00:23:37,820 --> 00:23:42,950
what I already mentioned um just to

00:23:40,280 --> 00:23:45,710
foster reuse and making it able to

00:23:42,950 --> 00:23:47,720
change behavior quickly we also support

00:23:45,710 --> 00:23:50,060
higher programming constructs like for

00:23:47,720 --> 00:23:53,600
example sequencing so for example what

00:23:50,060 --> 00:23:56,360
you can do is you can define 1hg that if

00:23:53,600 --> 00:23:58,550
being invoked invokes the concatenation

00:23:56,360 --> 00:24:00,830
of other actions already existing so for

00:23:58,550 --> 00:24:03,470
example a kind of action a a and if

00:24:00,830 --> 00:24:06,470
being invoked it invokes a1 a2 and a3

00:24:03,470 --> 00:24:08,180
you can have two similar 18 AP that

00:24:06,470 --> 00:24:09,560
invokes the same actions but in a

00:24:08,180 --> 00:24:11,360
different order and of course you can

00:24:09,560 --> 00:24:13,070
have many many more actions by using

00:24:11,360 --> 00:24:14,960
that sequencing concept that

00:24:13,070 --> 00:24:16,430
interconnects this little puzzle pieces

00:24:14,960 --> 00:24:18,380
in different order or there's an

00:24:16,430 --> 00:24:19,350
additional step or you remove a step or

00:24:18,380 --> 00:24:21,760
step like that

00:24:19,350 --> 00:24:23,440
and then UF as I've already said you

00:24:21,760 --> 00:24:26,290
have two rules they're just associate

00:24:23,440 --> 00:24:28,120
riggers and actions um one last comment

00:24:26,290 --> 00:24:30,490
before I hand over back to to aintry

00:24:28,120 --> 00:24:32,200
Oseland demonstrating this technology he

00:24:30,490 --> 00:24:34,570
also provides you with what we call

00:24:32,200 --> 00:24:36,760
Pegasus with is a shared collection of

00:24:34,570 --> 00:24:40,150
triggers and actions just to give you

00:24:36,760 --> 00:24:41,380
two zombies one of the packages for

00:24:40,150 --> 00:24:42,760
example you have this de cloud and

00:24:41,380 --> 00:24:45,610
package which we have already talked

00:24:42,760 --> 00:24:47,260
about and there for example we have the

00:24:45,610 --> 00:24:49,480
trigger called changes and you can

00:24:47,260 --> 00:24:51,550
configure that package against your

00:24:49,480 --> 00:24:53,350
Cloudant database so that you get

00:24:51,550 --> 00:24:55,030
informed while your dead trigger if

00:24:53,350 --> 00:24:57,100
something has changed in your database

00:24:55,030 --> 00:24:59,890
and then you can say okay if this

00:24:57,100 --> 00:25:01,900
trigger fires please execute this

00:24:59,890 --> 00:25:03,850
particular action and then this actually

00:25:01,900 --> 00:25:05,110
contains the application logic that you

00:25:03,850 --> 00:25:07,420
have written and that's whatever you

00:25:05,110 --> 00:25:09,220
want to do or guess the IBM Watson

00:25:07,420 --> 00:25:11,950
package where you see there are no

00:25:09,220 --> 00:25:14,920
triggers body actions and what you can

00:25:11,950 --> 00:25:17,110
do here is you can for example invoke

00:25:14,920 --> 00:25:18,940
the translate a king hand over some text

00:25:17,110 --> 00:25:20,770
and you can translate a text without

00:25:18,940 --> 00:25:22,680
writing any code you don't understand

00:25:20,770 --> 00:25:25,240
anything about Watson you just hand over

00:25:22,680 --> 00:25:27,760
some text and you can strength translate

00:25:25,240 --> 00:25:30,340
it from English to French for example of

00:25:27,760 --> 00:25:32,050
course we once again would like to

00:25:30,340 --> 00:25:33,670
encourage you to write these kind of

00:25:32,050 --> 00:25:36,220
package as well for different services

00:25:33,670 --> 00:25:40,390
to make integrating this other service

00:25:36,220 --> 00:25:42,100
easier so I hope I could motivate you a

00:25:40,390 --> 00:25:44,770
little bit to at least have a look at

00:25:42,100 --> 00:25:46,630
this technology so if you want to try it

00:25:44,770 --> 00:25:48,250
out on your own and I would be very very

00:25:46,630 --> 00:25:50,530
interested in your feedback so don't

00:25:48,250 --> 00:25:53,280
hesitate to contact me via Twitter or Y

00:25:50,530 --> 00:25:57,280
a mail don't call me please

00:25:53,280 --> 00:25:59,620
then please try it out go to bluemix um

00:25:57,280 --> 00:26:02,290
you will find it very easily open risk

00:25:59,620 --> 00:26:04,750
and go is to UI first because that's the

00:26:02,290 --> 00:26:09,370
simple way to simplest way to to end it

00:26:04,750 --> 00:26:11,020
and in this area and also go to our the

00:26:09,370 --> 00:26:12,700
developer center where you'll find our

00:26:11,020 --> 00:26:15,130
open-source offering and a lot of

00:26:12,700 --> 00:26:16,870
resources so there will find all the

00:26:15,130 --> 00:26:18,820
events that we have attended in the past

00:26:16,870 --> 00:26:20,860
you will find the events that we will

00:26:18,820 --> 00:26:22,960
attend in the future you will have

00:26:20,860 --> 00:26:25,120
access to recorded sessions that we did

00:26:22,960 --> 00:26:26,680
before you will find access to our

00:26:25,120 --> 00:26:28,930
YouTube channel where we have a lot of

00:26:26,680 --> 00:26:30,610
samples all these things so there's a

00:26:28,930 --> 00:26:32,050
lot of information there there's also my

00:26:30,610 --> 00:26:34,570
contact data if

00:26:32,050 --> 00:26:35,920
go Dara just get in touch with me if you

00:26:34,570 --> 00:26:37,330
have additional questions we are really

00:26:35,920 --> 00:26:39,220
really interested because there's a

00:26:37,330 --> 00:26:41,110
still a beta program we are still

00:26:39,220 --> 00:26:42,700
running from you guys you're still

00:26:41,110 --> 00:26:45,460
running from our customers from our

00:26:42,700 --> 00:26:47,200
partners so do not hesitate to reach out

00:26:45,460 --> 00:26:50,680
I will be around for the rest of the day

00:26:47,200 --> 00:26:52,960
if you see me out there just yeah just

00:26:50,680 --> 00:26:54,910
get in touch is that being said and

00:26:52,960 --> 00:26:59,640
after having stoned too much time from

00:26:54,910 --> 00:26:59,640
entrer already Oh back to you

00:27:04,030 --> 00:27:11,380
I need two volunteers now those who have

00:27:07,630 --> 00:27:13,780
Android devices Android phones so what I

00:27:11,380 --> 00:27:16,690
would request you to do is to download

00:27:13,780 --> 00:27:20,020
an application from here nothing too

00:27:16,690 --> 00:27:22,180
scary it will just steal your Facebook

00:27:20,020 --> 00:27:26,670
password maybe Twitter I'm not sure but

00:27:22,180 --> 00:27:31,720
but yeah not nothing dramatic please

00:27:26,670 --> 00:27:44,290
please download an app install I will

00:27:31,720 --> 00:27:49,870
put here for now ten seconds yeah yeah I

00:27:44,290 --> 00:28:00,630
and them the demo is actually boring

00:27:49,870 --> 00:28:03,130
because what was that yeah it spoiler

00:28:00,630 --> 00:28:06,490
somebody just just starting to do

00:28:03,130 --> 00:28:10,600
something before before officially

00:28:06,490 --> 00:28:13,270
announced so so in Internet of Things is

00:28:10,600 --> 00:28:16,420
boring because you have one device you

00:28:13,270 --> 00:28:18,040
have another device and something

00:28:16,420 --> 00:28:20,860
happens between between those two

00:28:18,040 --> 00:28:23,140
devices so what I will do I will shake

00:28:20,860 --> 00:28:25,320
my phone and you already know what will

00:28:23,140 --> 00:28:25,320
happen

00:28:32,360 --> 00:29:37,980
yeah so look how somebody is somebody

00:28:34,379 --> 00:29:41,399
else or somebody else phone device and

00:29:37,980 --> 00:29:44,240
an open whisk now open whisk you know to

00:29:41,399 --> 00:29:51,990
use open whisk we used bluemix service

00:29:44,240 --> 00:29:56,429
and I will tell you that how long does

00:29:51,990 --> 00:30:03,360
it take to invoke go to searching I have

00:29:56,429 --> 00:30:11,820
to switch and you can you can find the

00:30:03,360 --> 00:30:16,710
open whisk and refresh the results so

00:30:11,820 --> 00:30:20,399
you see that some actions to 700

00:30:16,710 --> 00:30:27,809
milliseconds some actions took 6

00:30:20,399 --> 00:30:32,279
milliseconds so at maximum we have 700

00:30:27,809 --> 00:30:35,779
milliseconds and it's the time that

00:30:32,279 --> 00:30:39,409
really takes to to invoke an action

00:30:35,779 --> 00:30:43,940
and to process it and to terminate so

00:30:39,409 --> 00:30:46,580
actually when IBM boots open whisk into

00:30:43,940 --> 00:30:50,809
into production they will charge you

00:30:46,580 --> 00:30:55,070
just for 600 milliseconds at most four

00:30:50,809 --> 00:30:58,479
and this application and the rest of the

00:30:55,070 --> 00:31:00,529
time there is no payment is required and

00:30:58,479 --> 00:31:04,070
as I said in the beginning of the

00:31:00,529 --> 00:31:06,139
conversation the signal may may come in

00:31:04,070 --> 00:31:08,119
once a day maybe once a minute

00:31:06,139 --> 00:31:10,909
but still it's much more efficient than

00:31:08,119 --> 00:31:12,379
paying for the infrastructure sitting

00:31:10,909 --> 00:31:14,859
there and waiting for a signal signal

00:31:12,379 --> 00:31:14,859
all the time

00:31:18,440 --> 00:31:21,899
okay coming back to back to our

00:31:21,299 --> 00:31:30,090
presentation

00:31:21,899 --> 00:31:31,619
I was playing next 20 minutes to explain

00:31:30,090 --> 00:31:34,289
you what what is displayed on this

00:31:31,619 --> 00:31:39,720
diagram actually what what would suggest

00:31:34,289 --> 00:31:42,600
is to an to read this article there is a

00:31:39,720 --> 00:31:45,509
detailed explanation about what was

00:31:42,600 --> 00:31:50,999
happening how how open which works under

00:31:45,509 --> 00:31:54,330
the hood please take picture where the

00:31:50,999 --> 00:31:56,279
presentation will be will be available I

00:31:54,330 --> 00:31:59,580
will be available in some time at

00:31:56,279 --> 00:32:03,720
SlideShare and at thunder summit the

00:31:59,580 --> 00:32:06,239
website this is another diagram that you

00:32:03,720 --> 00:32:08,669
will find this article and now you will

00:32:06,239 --> 00:32:10,320
ask me okay so it's it's called founder

00:32:08,669 --> 00:32:15,690
Sam if it's not open we sign it where's

00:32:10,320 --> 00:32:18,389
called foundry and here is here is how

00:32:15,690 --> 00:32:21,119
open whisk can work with quad foundry I

00:32:18,389 --> 00:32:23,909
really think that open whisk can be a

00:32:21,119 --> 00:32:27,629
valuable component in a cloud native

00:32:23,909 --> 00:32:32,279
platform because it addresses a very

00:32:27,629 --> 00:32:38,100
important use case and addresses it's

00:32:32,279 --> 00:32:41,509
quite efficiently and so I mean in this

00:32:38,100 --> 00:32:44,220
diagram you will see that here is

00:32:41,509 --> 00:32:46,470
application sitting in open wisk

00:32:44,220 --> 00:32:49,019
infrastructure and here are the

00:32:46,470 --> 00:32:52,230
applications that I'd want in coal

00:32:49,019 --> 00:32:54,539
foundry so in called foundry we will

00:32:52,230 --> 00:32:56,460
have it absolutely it's perfect for

00:32:54,539 --> 00:32:59,129
deploy an application for making the dam

00:32:56,460 --> 00:33:04,649
scalable highly available authentication

00:32:59,129 --> 00:33:06,989
authorization policies but open wisk can

00:33:04,649 --> 00:33:10,559
be deployed with a Cloud Foundry with

00:33:06,989 --> 00:33:13,639
both it can get external connections

00:33:10,559 --> 00:33:16,320
from from external devices like from

00:33:13,639 --> 00:33:20,009
from the phone or from Raspberry Pi and

00:33:16,320 --> 00:33:22,350
it can also get get signals get triggers

00:33:20,009 --> 00:33:25,660
from applications that are running in

00:33:22,350 --> 00:33:28,870
code foundry something

00:33:25,660 --> 00:33:35,169
and something like address I gave an

00:33:28,870 --> 00:33:39,220
example Twitter handles were github

00:33:35,169 --> 00:33:41,860
notifications so those those

00:33:39,220 --> 00:33:44,890
applications can NACA can send figures

00:33:41,860 --> 00:33:48,460
to to open whisk and open whisk and its

00:33:44,890 --> 00:33:55,090
turn will take advantage of the service

00:33:48,460 --> 00:33:57,900
farm of Cloud Foundry and may work in in

00:33:55,090 --> 00:34:00,340
this example it might work with

00:33:57,900 --> 00:34:03,400
non-relational database that doesn't

00:34:00,340 --> 00:34:08,169
support AC transactions through message

00:34:03,400 --> 00:34:12,580
queue I like rabbit to Kafka and it also

00:34:08,169 --> 00:34:15,429
may have adapters for relation to the

00:34:12,580 --> 00:34:18,310
waste like like Marietta me and it also

00:34:15,429 --> 00:34:20,290
can be integrated with you a component

00:34:18,310 --> 00:34:24,450
of Connery so that there is a

00:34:20,290 --> 00:34:29,070
transparent authentication process for

00:34:24,450 --> 00:34:29,070
for all the components of a platform

00:34:31,740 --> 00:34:36,850
however now if you if you think that you

00:34:34,780 --> 00:34:42,280
don't know you want to avoid vendor

00:34:36,850 --> 00:34:47,649
lock-in were you don't have you have

00:34:42,280 --> 00:34:51,700
your data in a local data center or you

00:34:47,649 --> 00:34:54,940
implement a hybrid strategy and you

00:34:51,700 --> 00:34:59,740
don't have information Cloudant and you

00:34:54,940 --> 00:35:00,880
don't use blue mixed all you need to to

00:34:59,740 --> 00:35:05,920
have your compute device on your network

00:35:00,880 --> 00:35:08,320
eh again not not in not in Cloudant and

00:35:05,920 --> 00:35:11,020
you're concerned with what security you

00:35:08,320 --> 00:35:14,500
think that you may implement you

00:35:11,020 --> 00:35:17,800
infrastructure better than IBM then you

00:35:14,500 --> 00:35:20,890
don't have to use IBM service of bluemix

00:35:17,800 --> 00:35:24,369
the good news is that IBM open sourced

00:35:20,890 --> 00:35:26,950
the source code or open risk and it's

00:35:24,369 --> 00:35:29,080
freely available it HAP please join

00:35:26,950 --> 00:35:30,820
collaborate than would and you can

00:35:29,080 --> 00:35:34,410
deploy it on your own infrastructure one

00:35:30,820 --> 00:35:34,410
on OpenStack or VMware and

00:35:34,900 --> 00:35:44,920
you don't have to be dyed to to bluemix

00:35:37,690 --> 00:35:47,740
to IBM we're done would you pay

00:35:44,920 --> 00:35:50,150
particular person

00:35:47,740 --> 00:35:50,150

YouTube URL: https://www.youtube.com/watch?v=kydt6JgW6_8


