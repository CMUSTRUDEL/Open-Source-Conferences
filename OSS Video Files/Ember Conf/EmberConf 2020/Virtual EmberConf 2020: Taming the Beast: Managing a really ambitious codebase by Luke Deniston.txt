Title: Virtual EmberConf 2020: Taming the Beast: Managing a really ambitious codebase by Luke Deniston
Publication date: 2020-03-26
Playlist: EmberConf 2020
Description: 
	Taming the Beast: Managing a really ambitious codebase by Luke Deniston

What do you do when your codebase gets too big?

Ember is perfect for “ambitious applications”. But what about really ambitious applications? Apps with hundreds of thousands of lines of code, teams that span countries, and users all over the world? Or apps in high liability environments where regressions from upgrades could cost millions of dollars or even put people in danger?

Recent advances in two tools present an opportunity to structure a project that is easy to work in and upgrade, but without the pain points of past solutions. Those tools are Ember Engines, and Yarn workspaces.
Captions: 
	                              [Music]                               hello amber I'm Luke denistoun I'm                               really happy to be here                               I'm gonna talk to you a little bit about                               taming the Beast so these are gonna be                               strategies for managing a really                               ambitious codebase just a little bit                               about myself I've got four children                               I love playing rock and roll it doesn't                                matter what style this is a picture when                                I used to play in a rockabilly band with                                my wife and just in case I'm giving you                                a false impression that I'm a cool guy                                or something I really love magically                                gathering and for the past nine years                                I've been working for a company called                                Agron and I'll explain what we do at a                                green a little bit later but first I                                want to introduce you to our topic so I                                named this taming the Beast what do I                                mean by taming the Beast I think we all                                can relate to this we know this feeling                                where we have the opportunity to do some                                greenfield development and we tell                                ourselves that this time it's gonna be                                different we're not going to make the                                mistakes that we used to make and                                inevitably things happen and it's hard                                to say why that happens but we all know                                what this is so the beast that needs                                taming is complexity complexity creeps                                into every successful software project                                where growth happens complexity creeps                                in so most successful progress most                                successful software projects grow and as                                systems grow by definition the number of                                entities in those systems increase in                                the interactions between those entities                                increase almost exponentially and                                eventually you get to the point where it                                becomes impossible to understand all of                                these interactions so what you're                                looking at right now is a video of all                                of the dependencies of NPM itself                                if you've ever peeked inside your node                                modules folder you know what I'm talking                                about and this is not a new topic right                                this is a quote back from the                                         deep stress he basically pointed out                                that no one's skull can contain a whole                                program at once so we need to try to                                organize our programs in such a way that                                we can safely focus on one part at a                                time when software projects fail it's                                not usually for technical                                it's usually because of poor                                requirements or poor planning poor                                management but when projects do fail for                                reasons that are technical the reason                                given is usually uncontrolled complexity                                the work that we do is just inherently                                complex right when we write code we're                                telling a story but that story has two                                different audiences your code needs to                                be understood by developers who                                sometimes look like this and sometimes                                look like this but it also needs to be                                understood by the computer and computers                                and developers hopefully think very                                differently about things we can also                                become blind to the complexity in our                                projects right the first time that we                                tackle a complex part of our software we                                kind of do the work of untangling it and                                following the threads and then we we                                kind of mentally memorize that right we                                cache the result of the work we weave we                                cashed that understanding so over the                                past years so I've had the opportunity                                to mentor a junior engineer he's a                                really really smart guy I try to be nice                                to him because I'm pretty sure he's                                gonna be my boss in a couple of years                                and in this process I've learned just                                about as much as he has he was the one                                who actually convinced me to give up my                                beloved Adam IDE and switch to BS code                                but it's been great looking at our                                projects through the lens of his                                experiences those things that are simple                                to me because I've been doing it for                                maybe five or ten years he might really                                struggle with so if you're wondering                                where complexity is my advice to you is                                just ask the new guy and complexity is                                inevitable right it creeps into every                                successful software project where growth                                happens complexity creeps in strategies                                for dealing with complexity mostly fall                                 into two different groups avoiding                                 specifics about discussions about global                                 state or syntax inheritance languages                                 there's there's basically two ways of                                 doing it one is you can                                 strapped it away where you provide a                                 simpler API for engineers to work with                                 ember itself can almost be thought of as                                 an abstraction because we don't worry                                 about data binding or dawn-marie                                 rendering and bruh takes care of that                                 for us the other strategy is subdividing                                 so subdividing a system into subsystems                                 so your brain can just focus on a                                 smaller section of the system at a time                                 and those systems those sections can be                                 tested and deployed in isolation this                                 doesn't reduce the complexity of the                                 system but it does reduce the complexity                                 of the piece that has been divided out                                 so today I'm going to talk about one                                 specific approach to subdividing so like                                 I said I've been an Agron for nine years                                 the bulk of that time I've been leaving                                 our sort of front-end web team and I'm                                 gonna give you a little sneak peek about                                 who we are and what we do so that you                                 have an understanding of the Sun some of                                 the challenges that we face so these are                                 some slides I got from our marketing                                 department we've got more than                                        growers in our system more than                                        and rodimus use our system so an                                 agronomist would be you get to give them                                 as a crop doctor they conduct                                 experiments like analyzing tissue                                 samples or soil samples and then based                                 on those experiments they work with the                                 actual farmers to get a plan for growing                                 the best possible crops these are                                 something that AG retailers that we work                                 with may be not household names here at                                 ember calm but Simplot is one of the                                 largest privately owned companies in the                                 world nutrient is a thirty four billion                                 dollar company CHS is a fortune                                     company there's some of the food                                 companies who work but hopefully you                                 recognize some of these names in fact if                                 you ate any produce today if you had a                                 salad or anything like that there's a                                 really good chance that some or all of                                 that food was trapped in our systems                                 Agron and we have a whole suite of tools                                 I'm not going to talk about all of them                                 but I'm going to talk about two specific                                 features that we have just to kind of                                 give you an idea of what we do so we                                 have this zone creation tool that's                                 where we take a source so in this                                 it's a satellite image what you're                                 looking at is the vegetation density                                 that we figure out by taking                                 measurements in the red and                                 near-infrared zones it's something                                 called that NDVI in this example this is                                 a harvest event so those big combine                                 harvesters to drive over the field they                                 have multiple sensors on them taking                                 samples sometimes more than                                            second this example I think is we're                                 looking at the yield so it's the actual                                 rate at which crops came out of the                                 ground then you take that source you                                 plug it into our zone creation tool and                                 we we split it up into zones based on                                 where you want the break points to be                                 how many zones you want and then you can                                 take that and then you can attach                                 arbitrary data to it so in this example                                 we're attaching a spray rate to the                                 generated zones then you take those                                 zones you can upload it to your GPS                                 enabled sprayer and then as that sprayer                                 drives over the field and knows what                                 zone it's over and adjusts the spray                                 rate accordingly this is great for our                                 growers bottom line because they're only                                 using what they need but it's also great                                 for the environment because we're                                 eliminating waste I'm going to talk a                                 little bit about our compliance or                                 prescription creation tool I'm gonna try                                 to simplify a really complex subject so                                 I'm sorry if you're knowledgeable on and                                 I'm gonna leave out a lot of important                                 details but basically the legality of                                 pesticides or herbicides can change                                 based on what state you're in what crop                                 you're growing what pests you're                                 treating the history of applications at                                 that field and other factors and the                                 rate at which you can use that pesticide                                 herbicide changes based on the same kind                                 of factors this is all of that                                 information is in what's called the                                 product label this is when I pulled off                                 the EPA's website and this might be for                                 roundup if you look closely this is page                                                                                                information there in addition to                                 legality and rate information there's                                 also associated safety information so                                 what's called the re-entry interval                                 which is how soon after applying this                                 product is it safe to reenter field so                                 we have a tool that lets you specify                                 some of the details like the location a                                 reason for treatment and will tell you                                 what pesticides you can use and what                                 rate you can apply the map and then we                                 we file the paperwork for you so all                                 different counties have different                                 methods that in different forms that                                 need to be filled out so we'll email                                 them or get a file via API or we even do                                 faxing so as you can imagine it's                                 vitally important that the software be                                 correct right mistakes could mean                                 millions of dollars in lost project                                 product or even injury or death so I'm                                 not here to talk about a greener                                 agriculture I'm here to talk about                                 managing a really ambitious codebase so                                 I think it'd be helpful to show where we                                 came from in terms of our architecture                                 so version one is sort of our current                                 generation tech stack it started out                                 with sort of a micro service                                 architecture backends mostly written in                                 rails and a single monolithic front-end                                 ember app it was served by the rails                                 asset pipeline stitched together                                         lines at mostly CoffeeScript there's                                 over                                                                 while I got us started it was great but                                 over time we just were experiencing                                 epically slow builds even slower deploys                                 we had endless regressions with every                                 upgrade so we we've upgrade something in                                 one part of a system and then                                 another part of the system would end up                                 breaking we actually were never able to                                 upgrade it past ember                                                  issues with teams across time zones                                 re-implementing the same thing in                                 different ways because it wasn't always                                 clear what code was features specific                                 what was meant for reuse and while I was                                 working on this app every day this is                                 one of the few times where I really                                 thought you know maybe I don't want to                                 be a web developer maybe I want to go                                 back to iOS development or go like paint                                 houses or something but luckily we moved                                 on from there so this is version                                         we had these sort of micro service front                                 ends that mirrored the Microsoft's                                 backends we had an add-on that had the                                 shared code for styles and business                                 logic and this fixed a lot of problems                                 we had really quick builds really quick                                 deploys I was easy to see what was meant                                 for reuse because anything in that                                 shared add-on you know was what we                                 should be reusing across all of our                                 applications those kind of bad for our                                 customers it was a little bit of a                                 jarring experience where you go from one                                 feature to another and there'd be a                                 whole page refresh as a new ember app                                 that is downloaded and booted so we                                 briefly experimented with using in repo                                 engines to break things up but that was                                 sort of a bad developer ergonomics where                                 it wasn't always clear where the lines                                 were between the host application and                                 the engine especially with things like                                 dependencies and where your tests were                                 located but then we hit upon                                 so we then we moved to this so Version                                 three where those applications they                                 became engines this was a lot better for                                 customers the experience quick                                 transitions between features it was a                                 quick time to first paint because those                                 engines were worth lazily loaded it was                                 kind of bad for developers because                                 fixing a bug and the shared add-on meant                                 you know four or five six pull requests                                 where you first you fix the bug in the                                 add-on you bump the version add-on                                 to the engines then you bumped the                                 engine version in the host app so that                                 was kind of a pain then we hit upon the                                 current architecture that's just an                                 awesome experience it's great for                                 customers it's a great experience for                                 developers it's sort of the best of both                                 worlds and that is using yarn workspaces                                 with ember engines so let me just                                 introduce some of these concepts you've                                 probably heard of yarn already I'm not                                 gonna spend a lot of time explaining it                                 but if you haven't it was developed by                                 Facebook to overcome some of the                                 shortcomings of NPM specifically                                 problems with deterministic builds and                                 performance but importantly it's                                 independent from Facebook it's governed                                 by an RFC policy similar to ember and                                 rust if you are you know dead so using                                 NPM NPM has really covered a lot of                                 ground and in the time since yarn was                                 introduced I'm not going to talk about                                 it but there are approaches using NPM                                 leveraging tools like lerna where you                                 can get some of the benefits of what I'm                                 talking about and it's also worth noting                                 that yarn too is a complete rewrite it                                 seemed to make a lot of people angry I                                 couldn't really determine if that was                                 real anger or just internet anger                                 because there's a lot of internet anger                                 that doesn't really equate to like real                                 actual anger but most of the issues seem                                 to be that yarn two is not compatible                                 with some of the more popular packages                                 out there you're on to you also right                                 constraints in prologue which is either                                 great or terrible depending on who you                                 ask and what time of day it is                                 workspaces a really simple concept it's                                 you can have one repository and many                                 packages inside that that repository                                 those packages can import each other and                                 so if you've ever used NPM link it's                                 kind of a similar concept but in this                                 case it you know it actually works                                 emperor engines so engines are a                                 specific type of ember add-on that                                 they're almost like a mini application                                 where they contain their own container                                 and registry and namespace but they're                                 built and booted by the host application                                 they come in two flavors routable or                                 route lists they can                                 optionally be lazy loaded and they offer                                 great code isolation so we're never                                 worried about working on when engine is                                 going to break something in a different                                 engine so this is what our architecture                                 looks like now we have mono repo it's                                 set up as a workspace and in the side of                                 that workspace we have multiple packages                                 we have our host application we have our                                 engines we still have our shared add-on                                 for those styles and and business rules                                 that need to go across apps and it's                                 great we can boot the host app and work                                 on the whole system or we can work on                                 just an engine in isolation and I love                                 what this layout communicates about this                                 code where the physical layout of the                                 files kind of tells a story to both                                 developers and to the browser so if I                                 tell a developer and I need you to work                                 on this feature he knows that the code                                 for that feature is inside the specific                                 engine and the engine add-on kind of                                 tells the browser that when we navigate                                 to that feature here's the code that you                                 need to download include communication                                 is really important I was hanging out                                 with my aunt over the holidays and she                                 told me a story about communication that                                 I think I'll never forget she's a really                                 sweet lady but she's not particularly                                 tech savvy and she was under the                                 impression that the acronym lol meant                                 lots of love so when one of her friends                                 sent her a message saying that one of                                 her they had a family member passed away                                 she responded lol and didn't know why                                 her friends didn't get back to her for a                                 few days so it has a happy ending they                                 the misunderstanding was sorted out but                                 just clear communication is incredibly                                 important so how do you get started with                                 workspaces it's really simple you add a                                 package.json in your route you need to                                 add this private is true that's kind of                                 a safety measure to make sure that                                 you're not accidentally publishing                                 things that you didn't mean to you and                                 then you have this workspaces feel                                 that's an array containing the                                 to each package usually you see it set                                 up like this where you just have a glob                                 everything in the packages folders is                                 all your different little workspaces but                                 if you wanted to you could iterate                                 through each package that you wanted to                                 include so what that gets you is if you                                 have a setup like this so you've got                                 package a it's listed as version                                         and then in package beef we list that as                                 the dependency if we reference package a                                 that's gonna pull in your local code                                 regardless of what's on publish to NPM                                 it's also important to know that what's                                 listed in the name field of your package                                 JSON that's what the workspace uses to                                 resolve your package so it's kind of                                 important to have your folders be the                                 same as the name of the name field so                                 you don't you avoid unnecessary                                 confusion so what happens when we start                                 bringing in additional dependencies so                                 in this scenario since the versions of                                 left pad are both                                                   installs one instance of left pad and                                 that's installed in the root node                                 modules but that's available to both                                 packages but what happens if we change                                 the requirements where package a now                                 needs left pad                                                     gotcha Covered it installs left Pat                                     point one in the local node modules to                                 package a and leaves one point                                      package B in the root node modules so                                 what does our workspace look like now at                                 Aggron we've got a few packages so we                                 have our host app that serves up all our                                 engines we have our engines we have a                                 little shared files package that has                                 shared es lint configs and TS configs                                 and some keys and stuff like that we                                 also have a published add-on that we                                 published our private NPM registry and                                 that serves as sort of a bridge to our                                 apps that haven't been brought into                                 workspaces yet we have the shared add-on                                 that has the                                 styles and business rules and I'll talk                                 about models in just a little bit                                 because there's a few gotchas there and                                 then we have some add-ons that offer                                 specific functionality so mapping is                                 obviously really important to Agron in                                 the agricultural field                                 we mostly leverage open layers but we                                 don't necessarily want open liners is a                                 big library we don't want to include                                 that in every engine we don't                                 necessarily want to include it in the                                 host app we only want to include it                                 where it's needed so we have a little                                 mapping tools add-on so those engines                                 that are interested in mapping can                                 include our mapping tools add-on and                                 then open layers gets bundled with them                                 member engines so if you're looking to                                 get started Umbra engines the guide is                                 is really excellent it's concise but it                                 covers all the major points it's really                                 easy to understand if you're looking to                                 get started I recommend reading it from                                 start to finish but I'll go ahead and                                 explain how to get set up so it's about                                 six steps to get an engine going you                                 generate an add-on just like normal you                                 install the ember engines add-on also                                 kind of straightforward if you're                                 providing templates you need to make                                 sure that ember CLI HTML bars is                                 included as the dependency so those get                                 compiled and then there's three files                                 that you need to edit so your index J                                 ass is really similar to the index                                 status for an add-on but we're making                                 sure sure to extend ember engine the                                 environment also similar to just a                                 normal add-on but we have to make sure                                 that we're providing the module prefix                                 and then we have this engine dot J s                                 file if you've ever looked at your app                                 dot J's file that should look really                                 familiar                                 but we're extending engine instead of                                 ember application and that's it that's                                 all it takes to get started then you can                                 go into your host application and you                                 can mount the engine most often you see                                 it just like this so this is an example                                 for a routable engine now in our host                                 app if we go to slash my engine we're                                 now serving up that engine it works just                                 like a normal route so if you want to                                 over                                 ride the path so in this example if we                                 go to slash blargh                                 now we're serving up my engine be if you                                 need multiple instances of the same                                 engine you you can pass it this as                                 argument so in this if you go to slash                                 motor we're now serving up a different                                 instance of my engine be for a route                                 less engine you mount it in the template                                 using the mount helper it takes exactly                                 one argument which is the model if you                                 need to pass more things to your engine                                 the recommended way of doing so is to                                 passion a hash so some tips for working                                 with engines getting lazy loading                                 working is incredibly straightforward                                 that's all you have to do you just lazy                                 loading enable this true and now you're                                 you're asynchronously loading your                                 engine there are some gotchas about                                 tests so there's similar code on the                                 amber engines website i'm gonna post                                 these slides they don't expect you to                                 remember all of it                                 but in tests you have to make sure that                                 you're using the correct resolver so                                 engine ships with this utilities engine                                 resolver for what we've done is we've                                 made our own setup test and set up                                 rendering tests that we call instead of                                 the built in a setup test that makes                                 sure that we're using the correct                                 resolver sharing services is really                                 straightforward just in our host                                 application we declare what the service                                 is working to share and to what engines                                 and in our engine we just let it know                                 what what services to look for that are                                 going to be shared so if you're using                                 something like amber simple off you're                                 probably going to be reshoring your                                 session service I also recommend sharing                                 the store because there's a few little                                 gotchas about working with amber data so                                 if you this is a real bug that we came                                 across so if you've got a shared session                                 session that might return a user model                                 and then in your end                                 you might have like a created by belongs                                 to this code will throw an error amber                                 will will tell you that you try and use                                 models across different stores and you                                 can't do that so also your store in your                                 engine won't be accessible in amber                                 inspector so if you've ever use the data                                 tab in the amber inspector it's                                 incredibly helpful and not having that                                 can be kind of difficult so the                                 recommended way of doing things is                                 layout your your your workspace kind of                                 like this where you have your host you                                 have your engine and any models that are                                 relevant to that engine just kind of                                 name it the same make a new package and                                 append models to it that can be consumed                                 by your host app so that way it can be                                 set up in the store it can also be                                 consumed by your engine because if                                 you're using tech script you're going to                                 want those type definitions and and this                                 is this is really helpful i don't                                 recommend taking all of your models and                                 dumping into the host app because then                                 you're losing that clear communication                                 about what files for what feature go                                 where so that's it it's really                                 straightforward working with workspaces                                 and engines i wanted to leave you with                                 just a few little tips about working                                 with really ambitious large code bases                                 so i've ranked these in order of                                 controversy so least controversial two                                 most controversial least controversial                                 meaning that they're generally kind of                                 well accepted good practices most                                 controversial meaning that you can find                                 people that are a lot smarter than me                                 that will give you a lot of reasons why                                 not to do that but there's also other                                 people who are smarter mean i tell you                                 why to do it so replace this with your                                 real tests if i searched for this string                                 I would find it an embarrassing amount                                 of times in our repositories you need to                                 treat that as a commandment don't treat                                 it as a suggestion if you see that code                                 if it's committed treat that like a bug                                 similarly most of the arguments to the                                 the queue unit assert functions like                                 assert equals they take a final argument                                 the message there's so many times where                                 I've been doing a big refactor or                                 upgrading a library and a test breaks                                 and I look at it and the test is assert                                 equals foo is two point seven five nine                                 and now it's two point seven five eight                                 and I don't know if I fixed it or if I                                 broke it and if you just include a                                 little description about what exactly                                 you're testing it's incredibly helpful                                 you don't think about it when you're                                 just working on your feature because                                 it's obvious to you but once you're                                 doing those big reef actors where                                 there's a thousand tests and you're                                 looking at the failed ones on the with                                 the little cue unit reporter page having                                 that message is incredibly helpful so                                 starting to get into the controversial                                 side so yes Len is not very                                 controversial prettier maybe a little                                 bit more so but what's controversial is                                 when I first started running a web                                 development team I pretty much let                                 developers use whatever IDE they felt                                 comfortable with so we didn't get into                                 some holy war of them or Emacs or code                                 or Adam but more and more I'm leaning                                 towards recommending everyone on the                                 team used the same tools and the same                                 add-ons so we started using prettier                                 about a year ago at Agron and it's it's                                 really cleaned up some of the noise and                                 pull requests so in pull requests a lot                                 of times you'll have comments about oh                                 you need a line break here or clean up                                 this white space or follow this you know                                 best practices about code formatting if                                 you're all in the same page about having                                 your code always being automatically                                 formatted by the same thing you've never                                 run into that and you'll never run into                                 changes that are outside of the scope of                                 the actual work that you're dealing and                                 if you didn't know this there's actually                                 a glamor parser for prettier so you can                                 format your typescript or JavaScript                                 just the same as you form                                 or handlebars be careful with addons the                                 addon ecosystem in ember is just                                 incredible there's there's so much                                 functionality that's just an ember                                 install away but sometimes that can be a                                 deterrent it can slow down upgrades if                                 using an addon that uses old syntax and                                 it hasn't been updated so before you                                 install an add-on just take a look at is                                 it actively maintained is it using                                 modern best practices look at what does                                 it do to the actual size of your                                 compiled assets is it bringing on a                                 bunch of stuff and bloating your asset                                 size and slowing down the download of                                 your application if you do find an                                 add-on that you want to use but is maybe                                 not as actively maintained as you like                                 my recommendation is install it with the                                 knowledge that you might end up adopting                                 it the beauty of open source is that if                                 you have a problem with one of the tools                                 you're using you can just fix it                                 yourself                                 lastly and we're firmly in controversial                                 side of things use typescript in about                                 six months I went from you know                                 typescript might be a little bit helpful                                 I'm gonna maybe poke around using this                                 to oh my god how did I ever live without                                 typescript and now whenever I work in a                                 in an app that's not in typescript it's                                 like kind of scary like I feel like I                                 don't have a safety net it's made big                                 reef actors really simple it's made it                                 easy to find when you know if I change                                 something in a class and I think that no                                 place else is using a particular member                                 of the class getting those typescript                                 errors is helps us find those bugs                                 before we ship them to production and                                 then lastly boolean controversial mode                                 even kind of scared to put this on the                                 screen use tailwind                                 we went from thousands of lines of CSS                                 where every component we made felt like                                 it needed a few lines the CSS we just                                 needed to maybe nudge something one way                                 or the other or or reset the the font                                 size for                                 reason and we switched to using tailwind                                 we spent some time up front making sure                                 that we had a really good tailing                                 configuration and the amount of CSS that                                 we wrote dropped by                                                  there's a quote from Adam the guy that                                 made tail wind                                 he said if you haven't worked with a                                 library like this before I promise your                                 gut reaction will be                                 holy hell this is the worst thing I've                                 ever seen it was my reaction to you                                 really do have to try it to shake that                                 impression so if you looked at it and                                 you freaked out and you thought it was                                 gross I really recommend using it and                                 you might be persuaded so that's it for                                 me I you can find me at Luke denistoun                                 quite a few different places I'd love to                                 know if you thought this talk was                                 helpful or if you have any feedback                                 thank you
YouTube URL: https://www.youtube.com/watch?v=K7rNqE5nsgk


