Title: Virtual EmberConf 2020: Why JS is Coming to Ember Templates by Matthew Beale
Publication date: 2020-03-26
Playlist: EmberConf 2020
Description: 
	Why JS is Coming to Ember Templates by Matthew Beale

In March 2018 the Ember project announced the abandonment of a long-running effort to improve Ember's dynamic resolution system (aka "Module Unification"). We didn't do it, and now we're going to talk about why. Soon, Ember developers are going to be seeing JavaScript in the same files as Ember templates, which opens the door to a new way to organize component implementations.
Captions: 
	                              [Music]                               good afternoon I'm Matthew Beale and I'm                               excited to be speaking with you here                               again at ember conf before I start my                               talk here I just want to say I've been                               incredibly inspired by the work that                               tilde the conference organizers my                               fellow speakers and many others have                               done to make this conference virtually                                feel like a success my heart and thanks                                go out to each one of you for the work                                that you've done to make this feel like                                a real moment for our community so last                                year I started a new role in engineering                                at a company called a depart we're                                mostly based in New York City we work on                                one of the longest maintained ember code                                bases that's out there and additionally                                on a couple new code bases using ember                                octane in a big part project like ours                                you quickly learn to prioritize writing                                code that's easy to read and that's one                                of the reasons that this topic today is                                important to me okay                                so to dive in here there's a joke on the                                core teams it goes                                no more unification RFC's and yeah                                that's the punchline maybe some of you                                have an idea why                                just before ember comp last year we                                decided to withdraw this RFC the module                                unification RFC from consideration                                it might seem late to be talking about                                this topic and I'm not going to talk                                about multi unification in detail but                                what you should understand if you don't                                already is that multi notification was a                                last attempt at cleaning up some loose                                ends and how we organize and reference                                of files and ever so let's say that                                we're reading this template in an                                application most of our developers would                                Intuit that when they looked for the                                definition of welcome on disk they would                                look at this location in app components                                and that's often the correct answer but                                if you want to make an implementation of                                jump to definition say so that when you                                hover on welcome you can jump to the                                file where it's defined you would                                actually need to consider a much larger                                range of possible places that that thing                                can be and the same thing we go for                                typescript if you wanted to let                                typescript find the definition that file                                ember uses a resolver system that                                permits components to be defined in a                                number of different locations in your                                app or in an add-on and the logic for                                deciding which to use is implemented as                                part of your applications runtime now                                that makes it challenging to support                                common static analysis tools and things                                in IDs and type systems and bundler is                                that people use across other parts of                                the JavaScript community you might                                already be familiar with the concept of                                a local maximum                                when you're looking for a solution to a                                problem there are probably many like                                viable solutions to that particular                                thing however the path from one solution                                to another solution might not always be                                linear and and so it can get easy to                                over focus on the thing that you have in                                front of you instead of looking at                                though the whole range of design                                possibilities and solutions that might                                be out there you'll often read about                                this idea when you dig into something                                like neural network systems for example                                this neural network that generates                                horses on this this this horse does not                                exist calm a match to generate this                                really realistic image of a horse on the                                right-hand side as a global maximum but                                in other cases such as long left here it                                was equally confident that had found the                                right answer but had completely missed                                the mark so I think that modification                                was probably a local maximum we had                                identified places like real problems                                where mbers resolution system wasn't                                always clear about what file you are                                looking at what component you were                                trying to invoke in the module and                                modification introduced more formal                                rules and requirements in an attempt to                                unifying that system in hindsight though                                 it was a local maximum in the rest of                                 the JavaScript community was climbing                                 the hill to a better solution this talk                                 is about how we're going to align ember                                 with that better solution so to                                 illustrate the problem with embers                                 resolver system let's build a little                                 fork of Ember I'll call Matt's resolving                                 ember micro lib here's a component in my                                 framework and you can see it's just a                                 function that returns a string done and                                 we're gonna presume that it's in a file                                 here called components Jas and here's my                                 framework know this looks like a lot of                                 code the most important bit to look at                                 here is on the bottom we're calling a                                 render function passing it a template                                 and then further up we've got a template                                 itself now there's two different things                                 that we call op codes in there that say                                 how I want to render this template the                                 first one is the number zero which says                                 I want to append text and the second one                                 is the number one which says I want to                                 invoke this component and if you look at                                 the render function above you can see                                 how those things are done and further up                                 there's a setup where we create a map of                                 all of our components and then we render                                 them so let's see how the the ambiguity                                 of using this system because we're using                                 a string for welcome here let's see how                                 that ambiguity is presents problems                                 where a lot of tooling can't penetrate                                 the meeting so first I've run this                                 program                                 through some popular build tools roll up                                 and tercer roll up takes advantage of                                 the fact that es modules are static that                                 is the imports and exports from a module                                 can be understood without running the                                 code relic your multiple modules and                                 safely combine them into a single                                 JavaScript program you can think of as a                                 simple compiler which takes our                                 dependency the component and links it to                                 the main program tercer is a                                 minification tool which uses static                                 analysis to make your JavaScript payload                                 smaller for this version of the program                                 the output looks like what we would                                 expect the component here is present and                                 the rendering logic is present you can                                 see our template in there with the                                 opcode                                                                  go ahead and change our template so                                 instead of calling opcode                                                component here to invoke our component                                 let's just render more text with an                                 append opcode instead so now I have two                                 text op codes of                                                       farewell and this would be akin to you                                 opening up a template in your ember app                                 and deleting the invocation of a                                 component to replace it with some text                                 so in this output again rolling it                                 through roll up running it through roll                                 up and tercer you would expect the                                 component logic doesn't need to be                                 present since we stopped a reference                                 referencing in the templates but because                                 their relationship was something                                 resolved at runtime and because roll-up                                 interser don't know what the program                                 will actually do they aren't able to                                 strip that component out in the Ember                                 ecosystem we're working on tools like                                 embroider embroider tries to close this                                 gap by teaching the build tools to                                 assume things about the run time during                                 build time analysis but I can give you                                 another example of how the resolvers                                 dynamic implementation in implementation                                 will frustrate other tooling so finding                                 a second example of how this ambiguity                                 and all in our resolver based library                                 has practical impacts is as easy as                                 looking at the most popular IDE for                                 ember users vs code here I've opened                                 opened up the micro Lib and I'm                                 attempting to jump to the definition of                                 a component just like it was referenced                                 inside of our template so it isn't                                 surprising that this doesn't work right                                 you can actually read it with your eyes                                 here we have a string for welcome and                                 just like we don't without understanding                                 the program have any context for what                                 that string means our compilation tools                                 don't have that in our analysis tools in                                 this case don't have that understanding                                 themselves we could again teach the tool                                 about this                                 we could build a custom language server                                 and encode assumptions about where to                                 look for these definitions so the first                                 draft of my micro lid used dynamic                                 resolution to look up components the                                 application boots the available                                 components are put in a map and then                                 templates reference them by strings in                                 order for our eyes to know where to find                                 a definition and for our tooling to know                                 we need to teach the systems what those                                 rules for resolution are I and I think                                 that that teaching also comes across for                                 us as individual developers when I asked                                 you to look at this template and tell me                                 where the Welcome component is defined                                 you could probably give me a pretty                                 reasonable answer but that's because                                 you've internalized the rules of the                                 resolution system in contrast to that in                                 a static system one based on echo script                                 modules we're always going to be able to                                 be explicit about where a definition                                 comes from you don't need to teach any                                 tooling or people those rules so let's                                 build a second draft of the micro Lib                                 this time a static version so in this                                 version of the template I've referenced                                 the welcome component directly down in                                 our template we have our opcode                                        our string to append we have our opcode                                                                                                       which is the thing that's imported from                                 the top there's no setup there's no list                                 of components there's no resolver here                                 furthermore if you want to see where the                                 Welcome component comes from you can you                                 can read this really easily right you                                 just look at where it's imported from I                                 so now that the template contains a                                 direct reference to the component we                                 don't need to teach the tooling about                                 any ambiguous cases so jump to                                 definition just works in the template                                 the way that it would work in most                                 JavaScript code we've got that running                                 and when the bundlers processes again                                 through roll-up interser the                                 implementation the component is actually                                 lifted directly into the template itself                                 so we can see our opcode                                                and there are opcode                                                   component itself inlined into the                                 template we've made the link between the                                 program and the component static the                                 tooling can not only understand where                                 the component is being used but it can                                 also understand if it's not used at all                                 for example if I change the second                                 render step back to a fond farewell as                                 an append instead of a component                                 invocation the bundler understands that                                 the variable welcome was not referenced                                 in the entire component implementation                                 itself can be dropped ok                                 so Everest templates are of course a lot                                 more feature fool than my micro lid so                                 how can we bring the benefits of a                                 statically linked system back into ember                                 itself so Godfrey trend has been                                 exploring this in RFC                                                  RFC he proposes stricted templates and                                 ember a strict template mode we call it                                 mode because just like strict mode in                                 JavaScript it opts the user into a                                 version of language we're messy edge                                 cases are going to be disabled so what's                                 going to make a strict mode template a                                 strict mode template so really it's                                 going to be a list of things that we                                 apply as constraints again to remove                                 ambiguities from the system so the first                                 of these is that there's going to be no                                 more implicit this fall back so if you                                 invoke something like like or if you                                 access something like curly curly foo                                 here we're not going to look to this dot                                 foo if you want to access the component                                 instance you must use this dot this is                                 something that's an octane is already                                 lint it for it so that's pretty straight                                 ahead there's going to be no resolution                                 of any invocations so for example curly                                 curly foo dash bar is a component                                 invocation our angle bracket welcome was                                 a different kind of component invocation                                 in a strict mode template those things                                 won't be those things won't lookup                                 components in the app folder of your                                 program so this is obviously something                                 that we're going to have to come back to                                 there's no dynamic resolution so you                                 can't use the component helper to pass a                                 dynamic string here because this is not                                 analyzable at all you could pass any                                 string at runtime and there's no way for                                 us to know what you might pass in and                                 then partials have a similar facility                                 where they can also take a dynamic                                 argument partials are already deprecated                                 so again this is pretty much already on                                 the on the happy path okay here's an                                 example of what a handlebars strict mode                                 template could look like it shouldn't                                 look very different than ember template                                 you might work in today it's going to                                 contain a couple template keywords so in                                 this case we have each being used in                                 here arguments so at greeting this is an                                 argument to this component that I'm                                 using it has a block per my greeting                                 that we're then using inside of the                                 block and we're accessing properties off                                 the component State and that works just                                 like it would in any regular template                                 however there's no actual way to invoke                                 the component from app so for example if                                 I had put bracket like angle                                 get quote in here it wouldn't actually                                 render a component at all it would just                                 be an error and so this brings us to the                                 crux in order for these static templates                                 actually be useful we're going to need a                                 static solution for getting other                                 components into the scope of the                                 template since we want to bundle our                                 application as JavaScript we want to do                                 something that's going to work with es                                 modules of course and to work with es                                 modules we need to consider what a                                 strictmode template looks like when it's                                 compiled into JavaScript so here's that                                 same strictmode template compiled into                                 JavaScript only I've changed it this                                 time to invoke the quote component                                 around my greeting to bring that                                 component into scope I've imported it                                 from a file that's in the same directory                                 as our component here just quote you can                                 imagine that it exports in ember                                 component glimmer component just like                                 with my static microwave earlier the                                 definition of the component itself is                                 now passed directly into the compile                                 template you can see that down where we                                 have a property of scope and then we're                                 passing a function with quote being                                 closed over common built-in would work                                 well with this output and given some                                 work on source maps we can make jump to                                 definition work as well through the                                 template itself of course this API this                                 API is basically as far as the                                 handlebars strictmode                                 RFC itself goes in this API is only a                                 primitive right we don't write compiled                                 templates by hand in order to make this                                 readable and usable we need to find a                                 way to lift the import statement that                                 we're writing in JavaScript here into                                 the temple itself which is going to take                                 us into a design for template imports so                                 if we want the ability to bring other                                 components into a strict mode template                                 scope there are a couple different                                 plausible designs that we could go into                                 and to keep the design kind of                                 unsurprising to both new developers and                                 advanced ember developers we think that                                 two constraints are important to keep in                                 mind the first is that you want to be                                 able to import a default or a named                                 export so you want to be able to say                                 that my component from elsewhere or my                                 helper or my modifier is the thing which                                 I have named arbitrarily in my exports                                 and I can pull it into my template and                                 the second thing is that on the right                                 side of an import the path we want to                                 work just like it wouldn't in any know                                 jazz resolution nothing nothing special                                 to go on there so given that we accept                                 these constraints it's going to be                                 question if we're going to constrain                                 ourselves to so closely re-implementing                                 the constraints already provided by es                                 modules why not simply adopt the es                                 module syntax into templates themselves                                 in fact any design that doesn't do that                                 it seems to bend common-sense a little                                 bit too far so let's see what that's                                 going to look like to bring the echo                                 script module syntax into templates so a                                 strict mode template itself doesn't have                                 imports but if we bring in a design for                                 template imports we can bring them into                                 scope here so we have - - - import quote                                 and then another - - - the - - -                                 introduces a preamble where we're going                                 to be able to write our import                                 statements and at the bottom we have our                                 template in between the preamble section                                 we want to constrain what's available in                                 there to only be atma script module                                 syntax so you can't use variables you                                 can't define functions or anything like                                 that and that's really as a first pass                                 imports can of course come from any path                                 because we want the thing on the right                                 side of an import statement to work just                                 like it does in normal JavaScript so                                 here we're importing quote which would                                 be a file that's in our local                                 application we're also importing title                                 eyes which is a helper that the ember'                                 framework itself is providing and then                                 we're importing animated each from an                                 add-on imports are going to open up new                                 organization options for your app if you                                 have a naturally group two set of                                 components you can group them on disk                                 wherever it's going to seem appropriate                                 additionally related helpers and                                 modifiers could easily share a single                                 file but be exposed as named imports for                                 example as we're doing for the add ember                                 slash template helpers module here so                                 how do these imports compile back into                                 JavaScript because this is just our                                 syntax in the template so just as with                                 the handwritten compilation from earlier                                 these three components are passed in                                 inside of the compiled template closed                                 over from their imports the imports from                                 our sample that are lifted into the                                 JavaScript here then we close over the                                 values that are imported and passed them                                 into the create template factory itself                                 and this is great it means that when we                                 look at the Kepala javascript here it's                                 easy for our eyes to understand where                                 quote is coming from which means it's                                 also easy for our tooling to understand                                 okay so what are the next steps in the                                 process of delivering template imports                                 so I                                 before glimmer components has landed in                                 an ember staple release we actually                                 landed a primitive into a stable version                                 of ember component manager this allowed                                 us to implement glimmer components                                 inside of an add-on and circulate them                                 amongst like the most passionate users                                 who are eager to try and experiment with                                 that solution and to get their feedback                                 on that feedback kind of helped us shape                                 the glimmer components feature until the                                 point where we thought it was really                                 ready for a stable release we want to do                                 the same thing in this case the                                 handlebars strictmode is a an RFC that                                 we have to get into a final comment                                 period and land that primitive that will                                 then allow us to build an add-on on top                                 of it which provides the template import                                 a syntax and then early adopters can                                 experiment with that and let us know                                 what needs to be shaken out in order to                                 make it a success kind of in parallel                                 we're also going to need to do a little                                 bit design around what the es module API                                 would be like for things like linked                                 linked to or input it's probably a                                 little bit of extra design work to do                                 there so I've talked a lot about the                                 technical nature of static templates in                                 this talk but despite the fact that                                 static templates will have performance                                 in payload size impacts I wanna remind                                 you that performance isn't the headline                                 motivation here static templates with es                                 imports make it a template simple to                                 understand for our eyes as well so in                                 this first example we have welcome where                                 you as an ember developer need to                                 understand how the resolver rules work                                 but in the second one even if I've never                                 used number before it's really clear to                                 me where this thing is coming from and                                 where I need to go to find the                                 definition                                 additionally module notification it had                                 some interesting features you might have                                 heard of like local lookup of explicit                                 imports make those features pretty much                                 unnecessary and import syntax will just                                 allow you to group components naturally                                 in your project without losing the                                 common conventions as suggested by                                 linting and generators so that's why a                                 JavaScript or at least JavaScript                                 imports syntax is coming to ember                                 templates so the Ember project was one                                 of the earliest adopters of es modules                                 and embracing the opportunities that es                                 modules present in making our templates                                 more readable and better analyzed as                                 something that I'm pretty excited about                                 but more than that it's going to take                                 give us the opportunity to take                                 challenges that ember has in                                 common with other JavaScript projects                                 allow and allow us to better share                                 common solutions between them if you                                 want to do further reading on this topic                                 I encourage you to take a look at the                                 links that I put on the page here hi and                                 I've also included a bid lease that you                                 can open up these slides yourself this                                 afternoon thanks for joining us here at                                 ember kampf virtually and I look forward                                 to talking about this topic more with                                 you on chat Thanks
YouTube URL: https://www.youtube.com/watch?v=p32zUgp4-_4


