Title: Virtual EmberConf 2020: Programmer's Bookshelf: Cliff Notes Edition by Lisa Backer
Publication date: 2020-03-26
Playlist: EmberConf 2020
Description: 
	EmberConf 2020: Programmer's Bookshelf: Cliff Notes Edition by Lisa Backer

"The Pragmatic Programmer", "Clean Code", "Refactoring" - these are among the classic works that we are told should be on every programmer's bookshelf. Often, they make it to the shelf, but remain unread. Have you ever wondered why these books are considered such beacons to our community? Have you maybe even felt guilty for not reading them all?

We'll go through the "cliff notes" edition of these classics, and maybe even find a few future classics to inspire you to check out whatâ€™s on your own bookshelf.
Captions: 
	                              [Music]                               [Applause]                               [Music]                               so hi there welcome to this remote                               edition of the programmers bookshelf I                               am Lisa Becker and I am coming to you                               from Arlington Virginia and this would                               be a picture of the family that I would                               be missing so much from Portland but I'm                                not missing them at all because they're                                downstairs so I am a senior software                                engineer but that didn't always used to                                be the case so I thought I'd introduced                                this topic by giving you a little bit of                                a background on how books came to play                                an important role in my life so I like                                many of you to not graduate with a                                computer science degree I had more of an                                organic career path I wanted to do dance                                programming which is not the same as                                computer programming so I got an                                internship at this place the Kennedy                                Center for the Performing Arts in                                Washington DC I worked there and then to                                stay and staff I took a position in the                                office of the CIO and the web folks that                                worked with him needed a little help                                so I started helping out on the web now                                some of you may know that working in the                                arts doesn't pay a lot so I also waited                                tables on the side and I worked in a                                crab house this is important because                                crabs Maryland crabs specifically are                                seasonal and they're only available in                                the summertime so that means in the                                winter I was really bored and so I read                                manuals because back then software came                                with manuals so I'm these were good for                                getting familiar with how to do basic                                tasks and what was available in a                                language or a trademark and it helped me                                get better helping with the web folks                                and so I started getting promoted and                                that meant I could stop waiting tables                                and I also started working on more                                complicated projects now Beth and I                                didn't have any mentor I could turn to I                                didn't have any senior developers I                                could talk problems went through so it                                became kind of difficult to figure out                                how to deal with all this so in the                                early                                                                  just come out and they became my mentors                                they encouraged me by validating my                                approaches they supported me with how to                                communicate with programmers and                                non-programmers they helped me structure                                my thinking and be able to approach                                these more difficult problems so                                fast-forward to today I am a senior                                software engineer at Dockyard we are a                                digital product consulting agency and as                                you can see here I get to work with some                                pretty awesome clients I also work with                                some amazingly smart people some of                                which you're hearing from at this                                conference                                some of these people that I work with                                they have really fancy computer science                                degrees and some of them don't they all                                bring an interesting perspective and                                they all treat their work as refining a                                craft this reminded me of my old books                                so I decided to go back and take a look                                this time there was a new level of                                inspiration not only were they                                validating my approach but they reminded                                me why I stick to that approach in the                                first place and that it's worth fighting                                for that even when I'm faced with a                                challenging project or a challenging                                person perhaps these books invite                                inspire me to stay motivated and to keep                                reinventing myself in tech which as we                                know is a requirement in this career so                                here we are programmers bookshelf so                                we're gonna go through two classics that                                I chose today based on their relevance                                currently and also based on the impact                                they had on my own career the first is                                the pragmatic programmer this approaches                                software development as a craft and it's                                my favorite                                and then refactoring which gives more                                focused technical advice and                                specifically around scene refactoring                                principles so a little bit of a history                                here back in                                                          was really large and really complicated                                 and really expensive                                 everyone had Gantt shards and like                                 Microsoft Project and these horrible                                 waterfall approaches but there was this                                 subversive culture of open-source that                                 was starting to appear and this work on                                 the cathedral and the bazaar brought                                 that to the masses and really made                                 people understand how this could be                                 viable it kind of contrasted the idea of                                 this pristine waterfall approach with a                                 few people in a room as building a                                 cathedral versus like the raucous                                 diverse methods of a distributed open                                 source as the bazaar even though the                                 authors no longer relevant                                 this work is freely available and I                                 strongly suggest reading it partially to                                 know your history but also because it                                 guy is really good                                 device about working in teams and open                                 source so anyway our books refactoring                                 in                                                                       and then in                                                    programmer finally in                                                manifesto so let's pause for a second on                                 that the agile manifesto this is the                                 entire thing here up in the screen don't                                 try to read it all but focus a little                                 bit on the middle there the point is                                 this we were in a time of transition and                                 the emphasis in the industry was moving                                 from super hardcore planned out long                                 processes with heavily documented and                                 and a lot of risk to collaboration and                                 faster delivery and responding to change                                 as the priority so that's where were two                                 recent last year the refactoring was                                 revised and so there's the pragmatic                                 programmer and then here we are today at                                 a remote conference in                                             pragmatic programmer it was considered                                 by many to be one of the most                                 influential programming books it was                                 written by Dave Thomas and Andy Hunt who                                 were also contributing authors to the                                 agile manifesto it consists of a hundred                                 different tips within sections that are                                 organized into like broad topics each                                 sections really short and digestible and                                 cross-reference to the other sections                                 and each section gives you challenge                                 questions at the end kind of thought                                 questions that you can work through so                                 what does it mean to be pragmatic a                                 pragmatic approach is to keep a larger                                 perspective and it's to see and solve an                                 immediate problem while still thinking                                 about it in the larger context so I mean                                 when I think about the pragmatic                                 programmers as a work it's kind of like                                 this mentor in my office that guides me                                 to haven't really elegant and                                 maintainable code but being pragmatic                                 about having delivering code so we're                                 gonna go through a couple sections today                                 highlights from a pragmatic philosophy                                 and a pragmatic approach one of the                                 overarching principles of this book is                                 personal responsibility you are                                 responsible for your career you're                                 responsible for your code and your                                 deadlines this also means you're                                 responsible for dealing with problems                                 when they come up you have to raise your                                 hand when something is no longer                                 possible and you're responsible for                                 suggesting and alternative not                                 giving up and being defeatist excuses                                 like the cat ate my source code they're                                 just not gonna fly stated another way                                 tip number three says you have agency so                                 the scenario fear is a frustrated                                 developer who's kind of stagnating in                                 their job um maybe they feel                                 technology's passing them by maybe                                 they're underappreciated underpaid part                                 of a toxic team like you all know the                                 scenario um the tip here is to remember                                 that you are in control Martin Fowler                                 who we'll get to soon said you can                                 change your organization or you can                                 change your organization                                 speaking of responsibilities the                                 industry puts a lot of pressure on us to                                 continue learning and changing and it's                                 our responsibility to keep up knowledge                                 and experience are the most valuable                                 assets for software developers but they                                 are expiring assets oh so pragmatic                                 programmer tells us to think about this                                 as an investment portfolio and they have                                 an investment advice of course so invest                                 in yourself regularly as a habit these                                 are like the small things listening to                                 podcasts reading blog posts going to                                 meetups speaking at meetups diversify so                                 this book sets a goal of learning a new                                 language every year totally wish I would                                 have kept up with that but it's not too                                 late um balance keep it balancing your                                 portfolio don't put all your technical                                 eggs in one basket like it's fun to play                                 around with the new shiny things                                 sometimes but make sure you keep up with                                 the core to high risk and low risk but                                 maximize your return so sometimes                                 keeping your eye on those new shiny                                 things that can provide a huge reward                                 when one of them proves out to be a                                 useful technology and then rebalance                                 don't sit on your laurels                                 reevaluate in terms of where you want                                 your career to go and what types of                                 things you enjoy you're working with so                                 moving on to software entropy um this is                                 one of my favorite sections and sharpey                                 refers to the amount of disorder in a                                 system it's another word software rot or                                 tech debt so the idea here is that one                                 broken window over time in a building                                 can lead to a sense of abandonment and                                 as a result you start seeing more broken                                 windows or litter or a fede                                 eventually maintaining that building                                 becomes too much of a hassle and the                                 owner gives up and it's officially                                 abandon kind of a self-fulfilling                                 prophecy the idea with this in software                                 the lesson is to fix these what broken                                 windows as you find them so fix problems                                 as you find them and even if you can't                                 due to the stress of time at least make                                 an issue in your backlog with a comment                                 and come back to it a poor decision even                                 if it wasn't about a decision at the                                 time if you leave it unaddressed in your                                 code it can lead to more and more                                 ill-fitting solutions the flip side of                                 this is code that is so pristine that it                                 inspires you to be a better programmer a                                 story in the book is about a friend of                                 the authors who had a really fancy house                                 and super expensive art and one day                                 there was a tapestry that was hanging                                 too close to the fireplace so a little                                 spider started and the fire department                                 came but they looked around and before                                 they went straight to the fire they                                 pulled out a map because they didn't                                 want the hoses to get the carpet dirty I                                 mean it's kind of extreme but it makes                                 sense in software like in one hand                                 you've got code that's lots of broken                                 windows and it's pretty easy to start                                 thinking well I mean it's all a Z anyway                                 I just need my code to fit in like who                                 cares it can make you unhappy and                                 unmotivated and we took worse software                                 obviously on the other Antioch code                                 that's so beautiful                                 and so well tested that you don't want                                 to mess anything up so even if there's                                 the fire of a raging deadline you don't                                 want to be the one to make a mess so                                 moving into the pragmatic approach                                 section I'm dry don't repeat yourself                                 this phrase was coined by Dave Thomas                                 and the concept seems really obvious and                                 easy but it's often overused and                                 misunderstood I still see people arguing                                 today about whether DRI is a good thing                                 or a bad thing                                 um the key point here is a driver refers                                 to a single piece of knowledge not                                 individual lines of code and it's also                                 worth noting and this is addressed as                                 well in pragmatic programmer that some                                 people see comments as duplication of                                 the code but your comments are the Y of                                 your code whereas the code explains the                                 how so pragmatic programmer goes into a                                 couple different types of duplication                                 and give strategies for each but I'll                                 just go through the types here so                                 imposed this is when it's forced on us                                 by like standards or letting                                 is having to define a model in multiple                                 places or something then we have                                 inadvertent duplication so this is when                                 yeah you just made a mistake early on                                 and you ended up with some stuff                                 duplicated and you need to go back and                                 fix it                                 inpatient duplication this gets the best                                 of us right like you have time pressures                                 you copy a function and you change you                                 just change a couple lines that you need                                 to change and then you like commit it                                 and run away those shortcuts they make                                 for some long delays and it's it's hard                                 to have that discipline upfront                                 sometimes then there's thinner developer                                 duplication so this is you know one                                 person doesn't know what the other                                 person is doing                                 we need frequent communication between                                 developers and code reviews is a good                                 way to keep an eye on everything that's                                 going on in your in the application                                 you're working with so the reversibility                                 section reminds us that there's always                                 more than one way to implement something                                 and because of that we have to kind of                                 guard ourselves for changing our minds                                 in the future the challenge question in                                 this section asks us to consider short                                 answers cat the idea is you're probably                                 now um is that there's a cat in a closed                                 box and there's a                                                      killed                                 so before you open up the box there's                                 two outcomes and they each exist in your                                 own universe in one the cat is dead and                                 one the cap is alive you don't know                                 until you open the box which universe                                 you're in so no wonder coding for the                                 future can be so difficult like how many                                 alternative universes have you created                                 with the decisions in your code and in                                 your architecture like how hard will it                                 be to support them when you open that                                 box so I got most of you have heard of                                 rubber duckie                                 um the approach of solving a problem by                                 talking through it in simple terms to                                 anyone even a duck originates from a                                 story in the pragmatic programmer like                                 there's so many great topics in this                                 it's like I said my favorite but we just                                 have time for a sampling so let's move                                 on to read that during written in                                      like I said revised in                                                Fowler and Kent Beck there are two                                 programming legends they're also                                 original signers of the agile manifesto                                 I'll point out that in the original                                 version of this book all the examples                                 were in Java but now in the revision                                 they're all in JavaScript so totally                                 accessible to all of us                                 so refactoring is the process of                                 changing a software system in a way that                                 doesn't alter the external behavior of                                 the system but just changes the                                 internals when you refactor you're kind                                 of improving the design of the code                                 after you've written it it's this fun                                 process here for getting soap that has                                 slipped out of the bathtub has possibly                                 gone through a few refactorings but it                                 hasn't changed the external goal of                                 getting the sit back so excuse me this                                 book starts with a whole chapter as an                                 example it's a small application that                                 handles billing for a Shakespearean                                 theatrical troupe the author is kind of                                 walk through different steps they need                                 to do to improve the code in order to                                 add some new features it's a bit more in                                 depth than err to do example below a                                 lesson the railroad and then they heard                                 some chapters on the principles of                                 factoring on bad smells and building                                 tests and then a catalog of refactoring                                 patterns which is the bulk of the book                                 so under factoring you start with a                                 solid test week that's always step                                 number one and then you make a small                                 change                                 make sure those tests don't pass and                                 commit repeat the point here is to keep                                 a very short feedback loop and always                                 keep your coat in a workable state                                 unfortunately with numbers emphasis on                                 tests that part should already be in                                 your practice so going through a tricky                                 portion of code involves reading that                                 code gaining some insight and then using                                 refactoring to get that insight from                                 your head back into the code this is                                 this this readability is like called                                 code archaeology this is what you spend                                 a lot of time on a stick earlier if                                 you're looking at something that was                                 complicated and written a while back by                                 you or someone else some can say that                                 like spending a lot of time focusing on                                 the readability the code can make it                                 less it makes it harder                                 performance-tuned but in refactoring the                                 book they say it's easier to                                 performance-tuned well-written code so                                 why would be reflector um to fix broken                                 windows right and eliminate the                                 duplicated code that we talked about                                 readability is a big one that I just                                 mentioned taking the time to give a                                 little re-evaluation                                 of the software before you commit it                                 with your code and making sure it's easy                                 to read can save that pourcel in the                                 future it was usually you Fowler says                                 that he likes to take everything in the                                 code he likes to put everything into the                                 code so they doesn't have to remember                                 anything we refactor to find books um                                 when you clarify the intent of the code                                 it makes it a lot easier to see when                                 something is wrong it doesn't line up                                 and then the primary thing is speed                                 right so this code archaeology burden                                 really slows us down and refactoring                                 makes it so that it's much easier to add                                 new features it's especially easier than                                 working around older patterns that don't                                 apply anymore so as we kind of alluded                                 to software is never done right so we                                 need to remember no decisions final in                                 order to add capabilities we're gonna                                 need to tweak the existing code so that                                 it can accept the changes more refactor                                 is making that hard change so that you                                 can make the original requested change                                 easier so some people think that                                 refactoring is just cleaning up bad code                                 and a technically savvy manager would                                 encourage refactoring as a constant                                 improvement to the source code but what                                 if that's not your boss                                 Martin Fowler's advice is to just go                                 ahead and do it anyway and don't tell                                 them his thinking is that this is a                                 schedule driven manager right who wants                                 the feature completed quickly and if you                                 know that the fastest way to do this is                                 to make a small improvement first then                                 do it because putting that knowledge                                 back into the code makes everyone around                                 you faster - so it's your responsibility                                 to your fellow programmers and to your                                 future self just beat them up that's                                 similar that are times when you                                 shouldn't write vector for example if                                 you have code that you only really use                                 instead of actually modify it kind of                                 becomes almost like an internal API and                                 that's kind of how they suggest treating                                 it is as an API so just making sure you                                 fully understand all the connection                                 points rather than going down the rabbit                                 hole it's not always worth your time to                                 refactor code that you hardly ever touch                                 you're just not that you're not gaining                                 a whole lot from the arc                                 process there um this happens a lot you                                 have a small thing that you're going to                                 change but you realize that you kind of                                 like to refactor something in the                                 process to make it easier and that                                 refactoring it becomes huge you know                                 sometimes for the team trajectory it's                                 better not to make that huge refactor                                 although caveat if you keep seeing that                                 same thing over and over and over and                                 then it's worth the time finally on the                                 decision to throw it out and rewrite                                 it's very subjective so subjective that                                 in the book they mention it and that's                                 it saying completely outside the scope                                 so finally um the book offers to avoid                                 refactoring in the name of clean code or                                 good engineering practices anything that                                 sounds like a moral explanation because                                 the point isn't to make your cookies                                 like sparkly clean and show off how                                 elegant you can be but it's to make                                 adding features and fixing bugs faster                                 so a tech lead has the responsibility to                                 use refactoring to improve the code base                                 and to guide the team on wind refactor                                 given the number of judgment calls it's                                 actually a really good opportunity for                                 mentoring so next we go into the concept                                 of code smells um a coke smell like the                                 smell from a diaper is a surface                                 indication that usually corresponds to a                                 deeper problem it's quick to spot you                                 can smell it and it doesn't always mean                                 there's a problem but generally it means                                 you should take a deeper look um the                                 book goes on to elaborate on                                             code smells from duplicated code two                                 large classes or long parameter lists                                 each section includes an explanation of                                 the smell as well as some suggested                                 refactoring pattern solutions because                                 most can be pretty easy to spot if you                                 know what you're looking for so on his                                 website Martin Fowler suggests having                                 lead developers pick a smell of the week                                 and then having junior developers find                                 them and pear on the solutions so the                                 next part in the book is devoted to                                 tests and as I mentioned before that                                 solid test suite is a prerequisite for                                 refactoring it's a short section but                                 it's kind of useful with regards to like                                 the philosophy of testing and                                 there's some good tips about the                                 frequency about writing tests at the                                 beginning of a bug report to expose the                                 bug prior to fixing it rating incomplete                                 tests as placeholders and boundary                                 conditions but my favorite piece of                                 advice out of there is not to let the                                 fear that testing can't catch all the                                 bugs stop you from writing tests that                                 will catch most of the bugs so don't                                 give up because it's not perfect just                                 keep improving things that's what                                 refactoring is doing so the bulk of book                                 like I said as a pattern catalog kind of                                 like a design pattern catalog and rather                                 than coming through what these patterns                                 are and that's that's for you I'll just                                 give you a sense of how they're                                 structured so they'll start with the                                 name and that's to give a common                                 vocabulary and then they have a summary                                 and rather than being a written summary                                 it's usually pictorial a little bit of                                 code just give you a quick idea of what                                 we're dealing with and then there's the                                 motivation section so this describes why                                 the refactoring should be done and some                                 circumstances where maybe it shouldn't                                 be done then we have the mechanics these                                 are step by step instructions and what                                 you may or may not be able to see on the                                 slide is that it's kind of like do                                 something do something test do something                                 do something test so it really                                 emphasizes that short testing committing                                 cycle and that by there's an example and                                 these are those silly textbook kind of                                 examples but you know they give you an                                 idea so I would suggest kind of going                                 through familiarizing yourself with the                                 motivations of each thing so that you                                 know what's in there and you can come                                 back to the details when you actually                                 want to do it in your actual application                                 so finally there's a little pragmatic                                 advice at the end of this book that I                                 really like um let's say you're going                                 along your refactoring you're making                                 things better everything's great and                                 then like you start to feel wrong like                                 you just lose your confidence it could                                 be at the end of the day and you're                                 tired it could be that you're realizing                                 that maybe it wasn't the right way to go                                 after all and you're feeling kind of                                 like you wasted time whatever the reason                                 and Fowler says that you just stop and                                 take a break                                 um if what you have still make sense                                 then go ahead and commit it                                 you kept everything in a workable state                                 but if it doesn't that's fine like move                                 on you've learned a lesson and you                                 probably know the code better than you                                 did before so he says it's kind of like                                 walking on a really narrow trail above a                                 really steep drop and as long as you                                 have enough light and confidence then                                 you can keep going but once that Sun                                 Goes Down you better stop and wait for                                 the Sun and your confidence to come back                                 so is there a place for a book still I                                 mean how many people still read books                                 are they just this vintage quaint                                 handcrafted artisanal learning                                 experience Martin Fowler tried to                                 address this a little bit in the preface                                 to the revised edition and concluded                                 that it's still kind of the best way to                                 present long-form content um                                 not everything works in a medium article                                 right but I do see some people slicing                                 up their books and putting them into                                 medium articles anyway and it can work I                                 actually had um the interesting                                 experience recently I was at a                                 conference a few weeks ago and Dave                                 Thomas one of the authors of pragmatic                                 programmer was giving the closing                                 keynote so I got it my nerve and I went                                 and I sat down with him at lunch and                                 this fuzzy picture is the only proof I                                 have but I asked him about like the                                 place for books and how to make this                                 kind of longer form next level learning                                 accessible to people now we talked about                                 video series boot camps even sock                                 puppets but you know how do you teach                                 experience like stories help but I you                                 know I still see these books as my                                 mentors and they didn't teach me how to                                 program they taught me how to be better                                 um but then lo and behold I got to                                 skeino and this was there how I'm                                 becoming a program of becoming a                                 programmer becoming a better programmer                                 and I was so he kind of laid out a                                 three-step plan so you know homage to                                 the pragmatic programmer we're just                                 gonna run through this real quick he                                 said on be happy keep learning and do                                 good in the world so step number one get                                 happy remember back at the beginning                                 this talk tip number three you have                                 agency so don't be so resistant to                                 change that you make yourself miserable                                 like find a place where you enjoy your                                 work and find work that you enjoy doing                                 and where you're appreciated a happy                                 programmer is a more efficient                                 programmer as well you know joy is an                                 asset and most of us really have fun                                 coding so humans can't tend to get the                                 most pleasure of tena tasks in some sort                                 of like optimal challenge zone so this                                 is where it's like a stretch for us but                                 not impossible a task where we feel a                                 sense of achievement the problem is that                                 if we stay in the zone too long we start                                 getting comfortable                                 remember your knowledge portfolio is                                 full of expiring assets so this leads us                                 to Dave Thomas is step number two keep                                 learning what separates a junior                                 developer from the mid and senior level                                 developers I mean it's experience but                                 what does that really mean um this is                                 something we talked about if it's at the                                 lunch table and experience means that                                 you've failed right it means you made                                 mistakes it means you are uncomfortable                                 you were a newbie you made a mistake                                 and you learned from it was it really                                 that bad that's what we call experience                                 what we need to do is to make failure                                 fun right keep learning keep expanding                                 being a diversifying your portfolio                                 means being a newbie and being                                 uncomfortable in his talk Dave Thomas                                 said that if you don't know what's going                                 on you're on the right path so I feel                                 like I'm on the right path um finally I                                 think open source is a great place to                                 deal with this also as as a mentor um                                 there's such a large ecosystem that                                 there's always something that for people                                 to work on it could be you need a more                                 newbie challenge if you are looking to                                 expand into something a little different                                 and a whole community of people to guide                                 you now the third point was do good in                                 the post face to the pragmatic                                 programmer they talk about another                                 seminal work which is the mythical                                 man-month um again you should also be                                 that like Fred Brooks and he says that                                 programmers were only slightly removed                                 from pure thought we build castles in                                 the air from air creating by exertion of                                 the imagination so we can make anything                                 really but this comes with the                                 responsibility of doing what's best                                 our users so it's our responsibility to                                 protect confuse errs by thinking about                                 security it's our responsibility to                                 prevent a valid experience to all of our                                 users by making accessibility and a                                 priority um we should build our software                                 the way we want to see the world so the                                 final tip of the pragmatic programmer                                 it's you're like share so share it                                 celebrate it build it have fun so it's                                 pretty much all the time I have um and                                 while there are sometimes some dated                                 material in these books like especially                                 with regards to stereotypes of early                                 hacker culture um these principles                                 really translate across time and                                 languages and it's not just software                                 design principles but also principles of                                 people career development and motivation                                 and even ethics so if you already have                                 all these books and they're just sitting                                 on your shelf collecting dust and you've                                 never read them or you read them many                                 years ago or on your Kindle um maybe you                                 never heard of them before today but I                                 hope that you will go out and find one                                 or two to start your reading yourself                                 some of them are really long but like                                 the agile manifesto as you saw just a                                 couple paragraphs and it made such a                                 huge difference so see what inspired                                 everyone so that I am Lisa backers sign                                 enough and I hope you enjoy the rest of                                 your remote experience you can find me                                 anywhere especially DC and I'm happy to                                 chat about any of these and discord or                                 Twitter thanks
YouTube URL: https://www.youtube.com/watch?v=rhu2q4-CkX8


