Title: Virtual EmberConf 2020: Autotracking: Reactivity and State in Modern Ember by Chris Garrett
Publication date: 2020-03-26
Playlist: EmberConf 2020
Description: 
	Autotracking: Reactivity and State in Modern Ember by Chris Garrett

Tracked properties are one of the most exciting features introduced in Ember Octane, and they represent a shift in the model for state management in modern Ember apps. But what makes a property "tracked"? Why do we have to decorate our properties? And how does this all differ from how other web frameworks think about state?

In this deep dive talk, I'll discuss the problems of state management and reactivity, and a number of solutions that have evolved over the years. I'll also show the internals of autotracking, and demonstrate some the unique benefits it gives to developers!
Captions: 
	                              [Music]                               good morning ember Kampf or good                               afternoon or good evening depending on                               where you're joining us from I honestly                               didn't think I'd be giving this talk                               virtually but it has amazed me how the                               Ember community and especially the Ember                               comp team have come together to make                               this all happen and it really is truly                                incredible to me we may be stuck but at                                least we're stuck together anyways my                                name is Chris and I'm a software                                engineer at LinkedIn and I'm also an                                ember core team member you might know me                                better by my internet handle bizarre ik                                this is me on Twitter github discord                                basically everywhere else and today I'm                                here to talk about reactivity first off                                what is it and why do we care                                well in a nutshell reactivity is how                                apps update when things change and this                                is why we care because we're developing                                ambitious application so we want to show                                changes to the user as things occur we                                as users click on buttons or as we                                return API responses from the server or                                what have you                                so we care a lot about this question and                                modern frameworks solve this with                                reactivity auto tracking is a form of                                reactivity but there are many forms of                                reactivity and today we'll take a look                                at a few of them and see how they                                compare and contrast but before we do                                that it's important to understand that                                reactivity is really a subset of                                updating there are many ways you can                                update that we wouldn't call reactive so                                you might be wondering ok why does it                                get a cool buzzword then what makes it                                special what sets it apart and why do I                                want reactivity in my app why do I care                                about this and why not just use any old                                way to update well I think that's best                                described with an example best shown so                                let's build an application this is to do                                MVC and it's a commonly used example app                                for frameworks to demonstrate                                how to build with them and today we're                                going to imagine that we're building a                                framework from scratch and we're using                                that to build to do MVC we're not                                actually going to build it from scratch                                but let's just imagine that we are and                                that we are now trying to figure out how                                users update things in our framework and                                so we're gonna iterate through a few                                solutions and see how they work and                                compare and contrast them but to keep                                things simple we've already decided that                                we want this to be a template oriented                                framework and we like templates and                                handlebars is great templating language                                so we're gonna use handlebars templates                                for our framework so here's the template                                for this application and let's take a                                look at it so first up we can see that                                there's an input at the top which is                                where users can add new to dues and then                                we have the currently displaying to-do                                lists so whatever is currently                                displaying we have their checkboxes and                                their titles and then we have the footer                                where we can see the items left and the                                filter buttons where we can select all -                                dues or active - dues or completed -                                dues and here's the JavaScript that is                                backing that template it's a lot to take                                in so let's take a moment to read it                                so starting from the top we have the                                list of two dues all to dues so                                completed not completed they all go in                                here and we have the displaying property                                which controls which to-do list is                                currently displaying we are then we have                                these getters which is how we define                                things like active to do is completed to                                dues and which to-do list is currently                                displaying and to do is left finally we                                have our actions which is where we                                actually perform the updates this is                                what will happen when a user actually                                wants to add it to do or toggle it and                                we can see here that we're just using                                plain JavaScript as is we're just                                pushing into an array or setting a                                property nothing special here this                                presents a problem though because the                                framework doesn't know that we've made                                 these changes it doesn't know that it                                 needs to update the template and to show                                 the user these changes so the question                                 is how do we let it know well we could                                 do it directly we could call something                                 like this stop rerender whenever                                 something changed but that would be                                 pretty difficult to remember for us it                                 would be it would be hard to remember in                                 a lot of complicated code paths that                                 every time you update some state you                                 have to call this method and it would                                 also be not very performant because our                                 application doesn't know exactly what                                 changed it just knows that it needs to                                 rerender because something changed so we                                 could try to get a bit more specific to                                 fix that problem but this only gets more                                 complicated now we need to tell it ok                                 rerender this list or rerender the items                                 left the remember ender this particular                                 to do and that's that's a lot to                                 remember that's a lot to think through                                 every time you want to update some state                                 which parts of the view it's gonna                                 affect and which parts need to remember                                 every render that's a lot to put on the                                 developer we can call this burden                                 annotation overhead it's the extra code                                 or thought that has to go into code in                                 order to do it in the way that the                                 framework wants you to do                                 as opposed to how you would do it                                 without the framework and that                                 annotation overhead here is is not only                                 constant whenever we want to update                                 state it's also combinatorial as our                                 application grows there will be more and                                 more parts of it that could be updated                                 at any given time and more and more ways                                 to update it so it grows combinatorially                                 with the size of our application which                                 is not a good place to be this is really                                 the state of the art in the era of                                 backbone and jQuery everything was                                 pretty ad-hoc on the front end at that                                 point so you would have you know one-off                                 plugins and and this was fine there were                                 small applications it was fine for these                                 because things weren't complicated                                 enough for this to really become an                                 issue but as application size and scale                                 began to grow it started to become more                                 of an issue and eventually became too                                 much so this is where reactivity comes                                 in reactivity was a way to solve this to                                 make sure that your application                                 complexity that your updates and                                 complexity grows linearly instead of                                 exponentially with the size of your                                 application and that way it doesn't get                                 out of hand so let's define reactivity                                 let's see what sets it apart from plain                                 updates but before we do that I do want                                 to say real quick this isn't the only                                 definition of reactivity you might hear                                 it's one of those words that's kind of                                 fuzzy and it's a buzzword that it's used                                 a lot in context right now but and                                 people understand what it means but it                                 doesn't really have an agreed-upon a                                 super agreed-upon definition so this                                 definition attempts to look at the goals                                 of reactivity the end result that it                                 seeks to achieve and I think it actually                                 ends up being a very useful definition                                 because of that we it shows us the                                 similarities between a lot of different                                 frameworks such as view and ember and                                 react and angular and Speltz                                 and it shows us how different those                                 frameworks actually are from ones like                                 backbone and libraries like jQuery and                                 really shows us that that core                                 difference so reactivity is a                                 declarative programming model for                                 updating based on changes to state ok                                 seems simple enough but what does that                                 what does that mean let's let's dig in a                                 little bit deeper there to understand                                 exactly what we mean so first off what                                 is declarative well declarative is about                                 describing what you want to happen                                 without describing how you want it to                                 happen exactly so for instance hTML is a                                                                                                       because you aren't telling the browser                                 exactly how to render this HTML you're                                 not telling it ok make a header add some                                 text to it apply some styles to it and                                 paint it in the DOM and then make the                                 form know you are handing it the                                 structure that you want to see and the                                 browser handles the details of that so                                 that's really what declarative means                                 it's a way to describe our intent and                                 allow the system to figure out how to                                 handle that on its own without us                                 needing to figure out the details and                                 then what about the second part of our                                 definition what is state well state is                                 effectively anything that can change in                                 your application things like variables                                 properties user inputs and really                                 there's two kinds of state there's root                                 state and drive state so root state is                                 state that has an actual value that that                                 act is the actual data that underlies                                 your system so in this example the first                                 name and last name properties are the                                 root state because they are real                                 properties with real string values by                                 contrast derive state derives its value                                 thus the name from other values either                                 other root state or other derive state                                 so in this example the full name getter                                 is to Rive state because its values                                 based on first name and last name and                                 when we step back we can really see that                                 most modern web frameworks are just a                                 way to turn read state some API some                                 data into HTML which makes that HTML                                 derived State so putting it all together                                 reactivity is a declarative programming                                 model meaning one that we declare our                                 intent in and it figures out the details                                 for us with for updating derived state                                 based on changes to read state and other                                 derived state cool okay so now we                                 understand what it means but what does                                 it actually look like well let's take a                                 look at a few reactive solutions and see                                 first up we have observables now the                                 observables were made popular by rxjs                                 and they're used in angularjs and the                                 idea behind them is that they are a                                 primitive that is an event emitter they                                 emit events which then travel through                                 what are called streams streams of                                 events and these streams can have                                 transformations applied to them which                                 change them into different types of                                 events or collects them or what have you                                 they can also do things like debounce                                 them they can split streams into                                 multiple streams or join them back into                                 a single stream and so you end up with                                 this network of events and transforms                                 and streams and on the other end of the                                 network you have subscribers who are                                 listening for events and reacting to                                 them as they come through the system                                 this is known as push based reactivity                                 because we're pushing changes through                                 the system as they occur so let's see                                 what this does to our code answers a lot                                 so stepping through it here's our root                                 state the list of to do's and the                                 displaying property but it's changed                                 from being a plain array                                 and property to being a observable                                 because now we need everything to be in                                 terms of this new reactive system                                 everything needs to be made in terms of                                 events so we create our observables with                                 their initial event which is the state                                 of the system next up we have our derive                                 state the getters originally but now                                 they are transforms on those observables                                 because again they have to be defined in                                 terms of the system so they transform                                 the events our state coming through the                                 system and split it off into multiple                                 streams finally we have our updates and                                 our updates once again need to be rear                                 ashen alized in terms of this system                                 we're no longer just updating objects we                                 are pushing new events representing the                                 new state through the system and I do                                 this with an immutable approach here                                 where I clone the previous state and add                                 a new state to it so I'm never actually                                 mutating anything because you don't want                                 necessarily one references to objects                                 that are being mutated floating around                                 the system but there are many ways you                                 could possibly do this in rxjs and this                                 is just one method for it the key point                                 is that our annotation overhead has                                 grown significantly here in some ways we                                 we now have to wrap every part of our                                 application the rids state that arrives                                 state and the actions so that is                                 definitely a lot and it may seem like                                 wow that's that's not ideal right but                                 this is actually not that different from                                 what we had an ember classic as it turns                                 out in ember classic you had to wrap                                 root state things like ember array and                                 proxies and what not would be used to                                 wrap route stay quite frequently and you                                 wouldn't have to do four properties but                                 you still had to do it for derive state                                 we had to tell the system about every                                 computed property in all of its                                 dependencies so that was quite a lot of                                 annotation that was required                                 and then for adding our actions we had                                 to tell the system with ember set or                                 push object so those were other forms of                                 annotations that were required                                 so overall ember classic was the same                                 amount of an anotation overhead as                                 observables and that actually does isn't                                 too surprising because amber classic was                                 push based we were pushing events                                 through the system and it was very                                 similar to how observables work under                                 the hood so overall this solution is a                                 massive win for performance by default                                 we are only updating the parts of the                                 system that need to be updated                                 for ergonomics it arguably is a win                                 because it's no longer growing                                 exponentially with the size of our                                 application in terms of complexity but                                 we have lost a lot in the process as                                 well                                 now you need to know about the system                                 and think in terms of it from the very                                 GetGo so to become even a little bit                                 productive you need to learn a whole new                                 layer on top of normal JavaScript so                                 that's a lot that's a lot to take in is                                 there a way that we could have a system                                 where the annotation overhead is lower                                 and we can still be reactive well let's                                 look at a solution on the other side of                                 the aisle virtual Dom so virtual Dom was                                 made popular by react and the idea with                                 virtual Dom is that rather than trying                                 to understand how state flows to the                                 system in specific detail it just asks                                 one question where did the state change                                 occur what component which part of the                                 program changed and then it reruns that                                 entire component and all of its children                                 andrey renders them but it does so                                 virtually with a virtual representation                                 and then in order to actually update the                                 UI it dips that virtual representation                                 only applies the parts that have changed                                 this is much cheaper than actually fully                                 rerender at a massive win                                 and this is a form of what is known as                                 pull based reactivity because we are                                 pulling on the state changes as they                                 occur naturally we're not immediately                                 propagating them when they occur but we                                 are using them in the next render and                                 that allows them to naturally update as                                 they are used so let's see how this                                 affects our code looking first at our                                 red state we can see things are kind of                                 back to normal we have a plain                                 JavaScript array we have this displaying                                 property it's all on this state field                                 now that's actually not very necessary                                 for virtual Dom though it's more of a                                 react ism than something that is                                 actually required for this strategy so                                 back to pure uh Nana Tate 'add root                                 state and then we have our derive state                                 and our derive state is also back to                                 normal so that's pretty great it's when                                 we get to our updates where things are a                                 little bit different and part of this is                                 I'm still using the immutable pattern                                 here because that's what react prefers                                 itself but really the key difference                                 between this and our original solution                                 is we now need to call set state in                                 order to update state and if we don't                                 call this it won't actually update                                 because this is what tells the framework                                 that this part of the program this                                 component needs to re-render this is a                                 very small amount of annotation overhead                                 have and it's naturally tied to updating                                 states so that really helps this is                                 something that is honestly one of the                                 main reasons why react was so successful                                 in all probability it made the developer                                 ergonomics so much better because it                                 gave developers a huge amount of                                 flexibility in how they solve their                                 problem and allowed to write that them                                 to write code in a way that made sense                                 to them you may have noticed I'm                                 actually not using the latest and                                 greatest for me                                 not using hooks that actually was an                                 intentional choice because hooks kind of                                 make it seem like they're adding more                                 annotation overhead you have to learn                                 about these used state things and the                                 various other types of hooks and how                                 they have to be run in a particular                                 order every time in order to write code                                 in the system and that's true there is                                 more annotation overhead in general but                                 that annotation overhead doesn't have                                 anything to do with reactivity as a                                 whole because from the reactivity model                                 standpoint all it needs is something to                                 tell it what has changed at what points                                 and that's what happens when we call set                                 to do from a hook it tells the                                 reactivity model hey this part of the                                 program has changed rerun everything                                 below it so yeah all the extra                                 annotation overhead is on the                                 programming model side of things and                                 this really demonstrates how flexible                                 react is our virtual Dom is as a                                 strategy it can handle both of these                                 very different models hooks and                                 class-based components without needing                                 to know the details of them at all so                                 that's that's pretty great the downside                                 is performance because this model                                 unfortunately doesn't scale at a certain                                 point we running the program entirely                                 even sub sections of it and even only                                 doing virtual Dom is still very                                 expensive and this is why things like                                 use memo and should component update and                                 reacts concurrent mode exist because                                 they are allowing users to manually try                                 to optimize and make react faster and                                 make this virtual Dom strategy faster                                 and this is where a lot of complexity                                 can begin to enter react apps because                                 now we're doing the math in our head                                 again now we're trying to manually                                 figure out what are our patterns and how                                 do we how do we have two things and                                 prevent updating                                 so we're doing some more work of the                                 reactive system so let's step back so                                 far we've looked at two different                                 reactivity models observables were very                                 performant but they required a lot of                                 annotation and they had us constantly                                 thinking about the reactivity model                                 everywhere we wrote code we had to think                                 about it on the other side we had                                 virtual Dom and virtual Dom was much                                 more minimal in terms of the annotation                                 that was required you only had to put it                                 on updates and it was very flexible                                 because of this but it wasn't very                                 performant by default it required some                                 manual optimization at a certain point                                 at a certain scale and so yeah that                                 there seems to be this trade-off between                                 the amount of annotation that the system                                 requires and how much information it                                 knows about what's going on and the                                 amount of annotation overhead so the                                 question is can we bend the curve can we                                 have a reactivity solution that is both                                 performant                                 by default and that require has minimal                                 annotation overhead and our auto                                 tracking so auto tracking approaches                                 this from a different angle it tries to                                 focus entirely on rich State in                                 JavaScript we already have a state model                                 we have a way for updating state and                                 that's through things like pushing into                                 an array and setting properties on an                                 object and auto tracking tries to                                 capture that and so that it can                                 interpret those in a way that allows it                                 to tell us when things have changed when                                 needed so let's see how that effects our                                 application                                 the first thing we'll notice is that                                 there's this new to do class because in                                 Auto tracking we need to wrap all of our                                 annotate all of our routes state so that                                 the system knows about it so we have the                                 tracked decorator to track our various                                 properties title completed the                                 displaying property on our to-do list                                 component and we also have this tracked                                 array which is just a reactive array                                 it's not provided by Amber it's provided                                 by the tracked built-ins add-on that I                                 maintain but you can just think of it as                                 an array that you can treat like a                                 normal array but when you mutate it it                                 will let the system know that changes                                 have occurred and once we wrap our route                                 state this way we can see that                                 everything else kind of falls into place                                 we are derived state is just like normal                                 and so are our updates they are just                                 like the original example without any                                 details needed to be changed so this is                                 a massive win for ergonomics overall                                 because it requires minimal annotation                                 overhead only on one part of the system                                 just like virtual dumb but it's also a                                 massive win for performance because it                                 is just as performant as observables if                                 not more performant the secret here is                                 that auto tracking associates read state                                 without put and it does so without                                 caring about the details of how that                                 output is generated to it all of those                                 details are just a black box how does it                                 do this with a technique known as                                 memoization normalization is a technique                                 where we return a previously computed                                 value if nothing has changed so for                                 instance in this example we have a                                 memorized render function which has a                                 call to a real render function within it                                 it stores the last value of that render                                 function and it stores the last                                 arguments so the next time it's called                                 if the arguments it's called with are                                 this                                 same as it was last time it will return                                 the last result and skip calling render                                 altogether memorization is a way that we                                 can really speed up applications because                                 we can skip unnecessary work this way                                 but in Auto tracking apps we want to do                                 something slightly different we don't                                 want to memorize based on the arguments                                 that are passed to us we want to                                 memorize based on the values we access                                 while running the function so for                                 instance if this was our track state and                                 this was the function that we wanted to                                 memorize we would want to memorize based                                 on these values that are accessed on the                                 track state during the call of the                                 function such that if any one of them                                 changes the next time we call this                                 function we rerun it and if none of them                                 change we just return the previous value                                 and that's it so how do we do this well                                 it all starts with a single number the                                 global revision counter and whenever any                                 state changes in the application we                                 increment this number I like to think of                                 this as a clock only instead of tracking                                 time it tracks changes to state as we                                 change state we are creating new                                 versions of state in the app and the                                 clock always keeps track of the most                                 recent version so you can see how this                                 would be a good rudimentary way to                                 understand if something has changed in                                 the app we look at the clock we memorize                                 the time we go back to whatever we were                                 doing and the next time we want to check                                 if something has changed we look back at                                 the clock is it later than it was is it                                 a higher value than it was yes cool                                 something has changed now we know at                                 that but really we also want to tell if                                 like a specific piece of state has                                 changed usually not just like any state                                 so for that we need tags every piece of                                 state in the application has a                                 and every tag has a value and that value                                 is a version of the clock whenever we                                 want to change this piece of state we                                 first increment the clock because                                 something has changed and then we assign                                 that value to the tag so in this way                                 tags always contain the most recent                                 version of state that they were updated                                 in okay so now going back to our                                 original memorized function as we run                                 through and execute this function we as                                 we encounter track state we store the                                 tags and save them for later we store                                 them and we also save the value that is                                 highest out of all of them the maximum                                 value and the next time we come back to                                 this function we check that maximum                                 value again we iterate through the tags                                 again and find the maximum value again                                 if that maximum value is the same then                                 we know for sure that nothing has                                 changed within this function and we can                                 return the previous value and if it's                                 higher than it was previously then we                                 know something must have changed and we                                 need to rerun the function how can we                                 know that for sure well let's step                                 through it let's say we change something                                 within the function we increment the                                 clock we update the tag to match the new                                 value of the clock and the next time we                                 come back to this function we check the                                 maximum value and it's higher than it                                 was previously so we know for sure that                                 something has changed we rewound the                                 function and let's look at the opposite                                 let's say we changed some state                                 somewhere else in the app we increment                                 the clock again we match the value like                                 before but because that tag was not used                                 in our function it's not part of the set                                 we check so it doesn't affect the                                 maximum value of the tags of our state                                 and so the maximum value stays the same                                 so we know for sure nothing                                 changed and it's safe to use the                                 previous value our memorization strategy                                 works okay let's take a look at what                                 operations that required the dirty State                                 all we had to do was increment a number                                 to validate it to check whether or not                                 it was still valid all we have to do is                                 map through an array of tags and take                                 the maximum value out of all of them                                 this is all done lazily so you can                                 update a thousand pieces of State and                                 all that's doing is incrementing a                                 thousand numbers and then the next time                                 you go to render you are checking                                 validation only if needed if you skip an                                 entire section of the app if you deleted                                 it or got rid of it                                 you don't ever need to do that                                 validation you get all of this and all                                 you need to do is annotate read state                                 every other part of the system handles                                 itself read state and the portions that                                 you want to memorize this is what                                 bending the curve looks like incredible                                 developer ergonomics performant by                                 default this is hands-down the most                                 exciting feature to me in modern ember                                 and one of the most amazing things about                                 the framework as a whole to me so what's                                 next now that we have this amazing new                                 reactivity model what are we going to                                 build on top of it                                 well first up I would like to see more                                 libraries and patterns and common                                 abstractions built on top of auto                                 tracking we had a lot of these for                                 computed properties one of my favorites                                 was ember macro helpers which was a way                                 to define various macros for computers                                 stuff like that is going to be very very                                 helpful for auto tracking and I've                                 already started with the tracked                                 built-ins add-on which creates tracked                                 versions of Java scripts arrays and maps                                 and sets allowing people to create use                                 them as route state using their standard                                 api's                                 and I think we could see more of this we                                 can see tracked localstorage and tracked                                 indexeddb II tracked versions of Apollo                                 and redux I think that making more                                 libraries like this will be very helpful                                 and I'm very excited to see what the                                 community does with that beyond that I                                 think that tooling is very important and                                 I would like to see us invest a lot more                                 in that space I think that actually auto                                 tracking kind of gives us an                                 unprecedented ability and a chance to                                 really make some amazing tooling                                 improvements we can do things like when                                 you're pausing and debugger tell you                                 what you've Auto tracked so far how many                                 things are memorized above you what                                 changed - cause this code to rerun again                                 questions that would be very difficult                                 to answer otherwise and I even can see                                 some potential improvements to the Ember                                 inspector I imagine a state timeline                                 that shows the exact order of operations                                 the the exact state changes that have                                 happened in your application - bringing                                 it to where you're at in that moment and                                 because of the way Auto tracking works                                 we can show you exactly which components                                 those state changes are related to we                                 can show you which components dirtied                                 and updated and were created and we're                                 destroyed and we can we can show that                                 all to you and show your entanglements                                 and everything finally I I want to say                                 Auto tracking in a lot of ways is to me                                 larger than ever and what I mean by that                                 is that it is it's really a general                                 reactivity model it's something that can                                 be used outside of the context of a                                 rendering engine and a view layer it can                                 be used anywhere and so and it also is a                                 reactivity model that doesn't really                                 exist in the wider JavaScript ecosystem                                 yet there's nothing really quite like it                                 yet mob X and views reactivity are                                 similar but there are some pretty                                 fundamental difference                                 so I'd really like to see us extract it                                 and make it usable not only a number                                 apps but everywhere so that we can share                                 all of the utilities built on top of it                                 that we we can share all of the value                                 generated by it in general and yeah I I                                 think it would be incredibly valuable to                                 do that I've even thought as time has                                 gone on that it really would make a good                                 system a good solution for adding                                 reactivity on the language level itself                                 either to JavaScript or to another                                 language                                 unlike previous attempts to do this it's                                 not something that requires synchronous                                 code to run and it's not super invasive                                 so it could be kind of ideal and beyond                                 that it's paradigm las' you don't need                                 to write object-oriented code for it to                                 work you don't need to write functional                                 code for it to work you don't need to                                 write imperative code for it to work you                                 don't you can write any kind of code and                                 it works with it because all it cares                                 about is that you have properly                                 annotated your read state and for a                                 language level feature a language that                                 is you're able to do all three of those                                 in quite a lot that would be ideal                                 I think so anyways that's all I've got                                 if you're interested in this topic I've                                 been logging in more depth on auto                                 tracking so check that out and thank you
YouTube URL: https://www.youtube.com/watch?v=HDBSU2HCLbU


