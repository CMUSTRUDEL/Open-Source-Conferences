Title: Ember London - Delivering WebApps with HAProxy - January 2018
Publication date: 2018-01-31
Playlist: Ember London
Description: 
	Together we will explore Trouva's infrastructure, how we historically served Frontend apps and APIs and how we currently use HAProxy and AWS to serve all our frontend apps, and APIs through a single routing layer.

Ember London: https://www.meetup.com/London-Emberjs-User-Group/
Captions: 
	00:00:00,000 --> 00:00:05,339
so I'm going to talk a bit about HR

00:00:02,280 --> 00:00:07,140
proxy the history behind our

00:00:05,339 --> 00:00:10,170
infrastructure changes of true var and

00:00:07,140 --> 00:00:13,650
why we decided to use a cheap proxy what

00:00:10,170 --> 00:00:16,289
are the pros of using a cheap proxy and

00:00:13,650 --> 00:00:19,859
where are the cons of like using other

00:00:16,289 --> 00:00:23,420
choices so a little bit about the

00:00:19,859 --> 00:00:25,529
history of Java and what true VII is

00:00:23,420 --> 00:00:27,660
truly is an ecommerce platform for

00:00:25,529 --> 00:00:29,820
independent retailers our goal since we

00:00:27,660 --> 00:00:31,410
started in 2013 was to always bring

00:00:29,820 --> 00:00:33,600
truly unique products to the hands of

00:00:31,410 --> 00:00:35,579
everyone across the world and and

00:00:33,600 --> 00:00:38,730
Trouville was originally named Street

00:00:35,579 --> 00:00:40,530
hub when we launched in 2013 our goal

00:00:38,730 --> 00:00:43,500
was to prove that we can take the local

00:00:40,530 --> 00:00:45,750
supply and fulfill local demand so

00:00:43,500 --> 00:00:47,670
initially our tech stock was basically

00:00:45,750 --> 00:00:49,620
an absolute minimum viable product it

00:00:47,670 --> 00:00:52,350
was just gotta be hosting with static

00:00:49,620 --> 00:00:54,149
HTML files so to kind of help you

00:00:52,350 --> 00:00:55,829
visualize that this is how it all

00:00:54,149 --> 00:00:57,870
started how it all looked in the

00:00:55,829 --> 00:01:01,800
beginning so users would basically

00:00:57,870 --> 00:01:04,769
request HTML static HTML files with

00:01:01,800 --> 00:01:06,150
boutiques in their area so if I was

00:01:04,769 --> 00:01:08,340
looking for a boutique in Shoreditch I

00:01:06,150 --> 00:01:11,580
would go online I would find shortage

00:01:08,340 --> 00:01:15,110
that HTML downloaded and I would find on

00:01:11,580 --> 00:01:18,390
any boutique that I wanted to go to but

00:01:15,110 --> 00:01:20,939
essentially after that in 2014 we

00:01:18,390 --> 00:01:23,250
decided that we still want to meet the

00:01:20,939 --> 00:01:25,290
the local demand with the local supply

00:01:23,250 --> 00:01:28,710
but we wanted to enable customers to

00:01:25,290 --> 00:01:30,960
place orders online and this is where we

00:01:28,710 --> 00:01:33,090
kind of decided ok obviously you need

00:01:30,960 --> 00:01:34,650
you need something are we going to go

00:01:33,090 --> 00:01:36,570
down the path of server-side rendering

00:01:34,650 --> 00:01:38,310
for like everything with just I don't

00:01:36,570 --> 00:01:42,659
know PHP or whatever was popular at the

00:01:38,310 --> 00:01:45,299
time we decided to use basically build

00:01:42,659 --> 00:01:48,420
her own nodejs up which was going to be

00:01:45,299 --> 00:01:53,250
hosted on no jitsu which closed down

00:01:48,420 --> 00:01:55,170
hence the rest in progress with rip and

00:01:53,250 --> 00:01:57,689
then we also decided that we're going to

00:01:55,170 --> 00:02:00,360
host well store all of our products and

00:01:57,689 --> 00:02:02,280
boutiques on elasticsearch and our

00:02:00,360 --> 00:02:06,060
single page up was at the time hosted on

00:02:02,280 --> 00:02:07,590
s3 and this is basically again just to

00:02:06,060 --> 00:02:11,250
help you visualize it we just had our

00:02:07,590 --> 00:02:13,180
single page up elasticsearch note no

00:02:11,250 --> 00:02:16,420
jitsu api

00:02:13,180 --> 00:02:18,400
so this is where kind of like small

00:02:16,420 --> 00:02:20,890
problems started coming to play because

00:02:18,400 --> 00:02:24,489
our front end was being served through

00:02:20,890 --> 00:02:28,569
domain a and our elasticsearch and no

00:02:24,489 --> 00:02:31,810
Jitsu were on domain B so what comes

00:02:28,569 --> 00:02:33,400
with that course comes into play so with

00:02:31,810 --> 00:02:35,109
I'm not sure if how many of you are

00:02:33,400 --> 00:02:37,780
familiar with course but I imagine most

00:02:35,109 --> 00:02:40,000
of you are but basically what course is

00:02:37,780 --> 00:02:42,159
is basically a request mechanism in

00:02:40,000 --> 00:02:45,069
which every time that you want to make

00:02:42,159 --> 00:02:47,889
an API call from domain a to domain B or

00:02:45,069 --> 00:02:50,560
even a subdomain a to subdomain be you

00:02:47,889 --> 00:02:54,060
essentially have to say ok my server

00:02:50,560 --> 00:02:57,970
only responds back to these client ups

00:02:54,060 --> 00:03:00,970
so you first do your your pre-flight API

00:02:57,970 --> 00:03:03,250
call which is an options request and the

00:03:00,970 --> 00:03:05,950
server says yep you've got access and

00:03:03,250 --> 00:03:07,569
then responds back with yes you have

00:03:05,950 --> 00:03:10,180
access on the options request and then

00:03:07,569 --> 00:03:12,099
you have to do another API call well the

00:03:10,180 --> 00:03:13,750
client handles automatically but the

00:03:12,099 --> 00:03:16,030
client does another API call which is

00:03:13,750 --> 00:03:18,250
your actual API call so if you wanted to

00:03:16,030 --> 00:03:20,199
get a boutique it would have to do the

00:03:18,250 --> 00:03:23,049
options first and then the get boutique

00:03:20,199 --> 00:03:24,489
to find the boutique and then finally

00:03:23,049 --> 00:03:29,019
the server responds back with the actual

00:03:24,489 --> 00:03:31,090
data so this was fine because if you

00:03:29,019 --> 00:03:33,819
think about it we only had two back-end

00:03:31,090 --> 00:03:35,799
services so configuring that configuring

00:03:33,819 --> 00:03:40,000
that was like very easy it was also easy

00:03:35,799 --> 00:03:43,989
on the client side as well so in in

00:03:40,000 --> 00:03:46,209
early in early 2015 we decided that we

00:03:43,989 --> 00:03:49,479
really want to focus on delivering great

00:03:46,209 --> 00:03:51,699
products and the only way that we wanted

00:03:49,479 --> 00:03:54,190
to do that and expand it globally not

00:03:51,699 --> 00:03:57,250
just locally within the UK was to focus

00:03:54,190 --> 00:04:00,159
on the quality of the curation and start

00:03:57,250 --> 00:04:01,209
shipping internationally where rather

00:04:00,159 --> 00:04:05,109
than just focusing on the local

00:04:01,209 --> 00:04:07,979
liquidity so we what we decided to do is

00:04:05,109 --> 00:04:10,780
we decided okay we're going to rebrand

00:04:07,979 --> 00:04:14,109
Street hub and create this new brand

00:04:10,780 --> 00:04:15,909
called Trueba and in order to meet all

00:04:14,109 --> 00:04:17,739
of the all of the criteria that we

00:04:15,909 --> 00:04:19,570
wanted to meet we basically decided

00:04:17,739 --> 00:04:21,729
we're going to create four single page

00:04:19,570 --> 00:04:24,310
apps one of them is true Vodacom which

00:04:21,729 --> 00:04:26,380
is where you can buy products where you

00:04:24,310 --> 00:04:27,040
cannot products your basket the other

00:04:26,380 --> 00:04:29,410
one is

00:04:27,040 --> 00:04:31,240
the checkout process which is we decided

00:04:29,410 --> 00:04:33,370
to split out from the main app so we can

00:04:31,240 --> 00:04:36,730
help the customers focus on the user

00:04:33,370 --> 00:04:38,380
journey of checking checking out and

00:04:36,730 --> 00:04:41,080
just remove any of the distractions of

00:04:38,380 --> 00:04:42,910
the main site and then we also created

00:04:41,080 --> 00:04:45,850
two other single page apps which is our

00:04:42,910 --> 00:04:48,550
own internal CMS and the retailer CMS

00:04:45,850 --> 00:04:50,590
which is what the retailer's use to

00:04:48,550 --> 00:04:52,450
manage their inventory accepting new

00:04:50,590 --> 00:04:56,200
orders or reject them if they don't have

00:04:52,450 --> 00:04:59,290
them in stock we still kept our core API

00:04:56,200 --> 00:05:01,360
which was built in in node.js but we

00:04:59,290 --> 00:05:04,540
moved it over to Heroku since no jitsu

00:05:01,360 --> 00:05:06,910
closed down and again similar to before

00:05:04,540 --> 00:05:10,360
we still kept elasticsearch and for the

00:05:06,910 --> 00:05:13,210
products and boutiques so this is this

00:05:10,360 --> 00:05:15,940
is what it looked like at the time we

00:05:13,210 --> 00:05:17,980
had our four single page apps we had one

00:05:15,940 --> 00:05:21,970
JavaScript API and our elasticsearch

00:05:17,980 --> 00:05:24,490
instance so that meant that adding four

00:05:21,970 --> 00:05:26,700
new well adding three new single page

00:05:24,490 --> 00:05:30,520
apps meant that we had to go back on our

00:05:26,700 --> 00:05:32,920
on our back-end services and update the

00:05:30,520 --> 00:05:36,250
course configuration to support all four

00:05:32,920 --> 00:05:38,170
single page apps easy to do but then as

00:05:36,250 --> 00:05:40,030
you start to think about it more and

00:05:38,170 --> 00:05:41,740
more the more back-end services you add

00:05:40,030 --> 00:05:44,740
the more front and services you add

00:05:41,740 --> 00:05:47,080
there is more configuration piled on top

00:05:44,740 --> 00:05:53,020
and on top on top so it just gets a bit

00:05:47,080 --> 00:05:55,420
tedious to update in 2016 basically this

00:05:53,020 --> 00:05:59,500
is our current state now since 2016 we

00:05:55,420 --> 00:06:02,020
have built five new services which work

00:05:59,500 --> 00:06:05,110
alongside the core API to deliver the

00:06:02,020 --> 00:06:08,140
all of the content that the single page

00:06:05,110 --> 00:06:10,360
apps need we kept all four single single

00:06:08,140 --> 00:06:13,690
page apps and we also introduced algo

00:06:10,360 --> 00:06:16,660
Leon to the mix for doing the searching

00:06:13,690 --> 00:06:19,510
of products and boutiques so to

00:06:16,660 --> 00:06:21,970
visualize that again we essentially have

00:06:19,510 --> 00:06:26,110
I couldn't fit all of these services so

00:06:21,970 --> 00:06:28,870
there's more services there but this

00:06:26,110 --> 00:06:30,670
essentially meant that we had to again

00:06:28,870 --> 00:06:32,680
for every see for every buckin service

00:06:30,670 --> 00:06:35,950
we had to go back out the lovely course

00:06:32,680 --> 00:06:37,480
configuration again and it became so

00:06:35,950 --> 00:06:38,919
common for us to think about this thing

00:06:37,480 --> 00:06:39,610
that we were actually thinking at a

00:06:38,919 --> 00:06:42,189
point

00:06:39,610 --> 00:06:43,629
to create an NPM library which has all

00:06:42,189 --> 00:06:44,860
of the course configurations that we can

00:06:43,629 --> 00:06:49,180
share it across all of the single page

00:06:44,860 --> 00:06:51,280
jobs which sound to be something funny

00:06:49,180 --> 00:06:55,330
but actually it was a common problem for

00:06:51,280 --> 00:06:57,189
us and if you think about it also course

00:06:55,330 --> 00:07:00,159
doesn't make sense in this in the sense

00:06:57,189 --> 00:07:03,969
of basically you take almost twice the

00:07:00,159 --> 00:07:05,590
time to actually execute an API call so

00:07:03,969 --> 00:07:07,449
that's where we kind of sat down and

00:07:05,590 --> 00:07:10,479
thought about things and we decided to

00:07:07,449 --> 00:07:12,219
you start routing all of the all of the

00:07:10,479 --> 00:07:14,620
API calls through one single routing

00:07:12,219 --> 00:07:17,440
layer so we started using a cheap proxy

00:07:14,620 --> 00:07:19,719
unless your proxy sits between the user

00:07:17,440 --> 00:07:23,259
every single user basically that's using

00:07:19,719 --> 00:07:25,180
our apps and then between and the other

00:07:23,259 --> 00:07:28,810
side of the things are basically single

00:07:25,180 --> 00:07:31,509
page apps and are all of our API is so

00:07:28,810 --> 00:07:33,099
what is a cheap proxy and why we use it

00:07:31,509 --> 00:07:34,960
a cheap proxies are fast and very

00:07:33,099 --> 00:07:40,090
efficient load balancer and routing

00:07:34,960 --> 00:07:43,719
layer so why we use a cheap proxy proxy

00:07:40,090 --> 00:07:45,250
avoid helps us avoid course because we

00:07:43,719 --> 00:07:47,469
can route everything through a single

00:07:45,250 --> 00:07:49,270
domain so if you're on checkout you can

00:07:47,469 --> 00:07:52,930
do the request on checkout and you can

00:07:49,270 --> 00:07:56,050
still route to the same API service if

00:07:52,930 --> 00:08:00,330
we're on our no Trouville come then we

00:07:56,050 --> 00:08:03,190
use that domain to access our API calls

00:08:00,330 --> 00:08:05,250
at the time we're also thinking like the

00:08:03,190 --> 00:08:12,339
other way of doing things would be to

00:08:05,250 --> 00:08:14,440
use sorry that's all these annoying so

00:08:12,339 --> 00:08:18,099
the other way of we're thinking of doing

00:08:14,440 --> 00:08:19,810
things is basically use a CDN like cloud

00:08:18,099 --> 00:08:22,509
front so you can serve all of your

00:08:19,810 --> 00:08:24,759
single page apps and also define rules

00:08:22,509 --> 00:08:28,089
in cloud front where you can basically

00:08:24,759 --> 00:08:29,680
route all of the all of the api's but we

00:08:28,089 --> 00:08:31,210
decided we didn't want to go down the

00:08:29,680 --> 00:08:33,370
path because that meant that we had to

00:08:31,210 --> 00:08:37,240
do cache invalidation on index on the

00:08:33,370 --> 00:08:39,459
index dot HTML and although that's very

00:08:37,240 --> 00:08:41,589
reliable thing to do it also takes time

00:08:39,459 --> 00:08:43,360
and sometimes you're not entirely sure

00:08:41,589 --> 00:08:45,930
how much time is going to take on each

00:08:43,360 --> 00:08:48,430
different edge note across the world so

00:08:45,930 --> 00:08:51,610
I'll show you in a bit how a user ship

00:08:48,430 --> 00:08:53,530
proxy to get around that problem but for

00:08:51,610 --> 00:08:56,530
now keep that in mind

00:08:53,530 --> 00:08:57,880
and the other reason why you decided why

00:08:56,530 --> 00:08:59,940
we decided to use a cheap rocks is

00:08:57,880 --> 00:09:03,490
because we have one single routing layer

00:08:59,940 --> 00:09:05,020
so all of our requests go through one

00:09:03,490 --> 00:09:07,180
single routing layer so it's easier for

00:09:05,020 --> 00:09:08,770
us to debug things it's easier to go

00:09:07,180 --> 00:09:11,950
back and look at the history because you

00:09:08,770 --> 00:09:14,590
have one log and it's just everything's

00:09:11,950 --> 00:09:16,870
a lot easier and also a chip rocks it

00:09:14,590 --> 00:09:19,300
comes with a very interesting and

00:09:16,870 --> 00:09:21,040
excellent statistics dashboard so there

00:09:19,300 --> 00:09:23,200
is one statistics but dashboard that you

00:09:21,040 --> 00:09:24,790
can go to and you can see how many

00:09:23,200 --> 00:09:27,190
requests are failing per second how many

00:09:24,790 --> 00:09:28,810
requests have passed how many requests

00:09:27,190 --> 00:09:31,270
are going to every different service or

00:09:28,810 --> 00:09:36,520
how many times you have served your your

00:09:31,270 --> 00:09:38,110
single page up so just to talk a little

00:09:36,520 --> 00:09:41,800
bit about how we actually do the

00:09:38,110 --> 00:09:43,570
redirection you cannot before you

00:09:41,800 --> 00:09:46,330
actually start implementing things you

00:09:43,570 --> 00:09:49,060
need to start think about how you're

00:09:46,330 --> 00:09:51,430
gonna basically this is where it

00:09:49,060 --> 00:09:53,620
namespacing comes into play so if you

00:09:51,430 --> 00:09:57,880
start namespacing things so if I want to

00:09:53,620 --> 00:09:59,260
start accessing the list service I what

00:09:57,880 --> 00:10:01,270
we decided to do is we can namespace

00:09:59,260 --> 00:10:03,880
everything under slash API slash lists

00:10:01,270 --> 00:10:05,890
and then for the inventory service it

00:10:03,880 --> 00:10:08,110
slash API slash inventory is similar

00:10:05,890 --> 00:10:10,060
with a cart and then for anything else

00:10:08,110 --> 00:10:11,560
that doesn't match those rules we're

00:10:10,060 --> 00:10:17,530
basically going to route everything to

00:10:11,560 --> 00:10:19,840
the to our core API service so how does

00:10:17,530 --> 00:10:24,520
how does the configuration actually look

00:10:19,840 --> 00:10:26,470
like a chip proxy has three concepts

00:10:24,520 --> 00:10:28,180
which are quite important they have the

00:10:26,470 --> 00:10:31,210
concept of a front-end which is

00:10:28,180 --> 00:10:33,940
essentially I mean it's it's essentially

00:10:31,210 --> 00:10:35,830
one input so I think of the thing of the

00:10:33,940 --> 00:10:38,050
front owners basically where the request

00:10:35,830 --> 00:10:40,450
is coming from and then think of the

00:10:38,050 --> 00:10:42,460
backend as where the request is going to

00:10:40,450 --> 00:10:46,830
lead to so if you think of a routing

00:10:42,460 --> 00:10:50,230
layer or just like any standard like

00:10:46,830 --> 00:10:51,760
routing think of the input as being the

00:10:50,230 --> 00:10:54,550
front-end and the output as being the

00:10:51,760 --> 00:10:55,810
backend and you can actually name things

00:10:54,550 --> 00:10:57,520
and you can have multiple different

00:10:55,810 --> 00:11:00,880
front ends multiple different backends

00:10:57,520 --> 00:11:03,700
so here for example we decided to name

00:11:00,880 --> 00:11:06,100
our our this specific front-end we

00:11:03,700 --> 00:11:06,780
decided to call it HTTP and it listens

00:11:06,100 --> 00:11:09,300
on the port

00:11:06,780 --> 00:11:10,950
forty forty and with then we can set up

00:11:09,300 --> 00:11:12,540
a load balancer in front of it so it so

00:11:10,950 --> 00:11:14,550
that we can have everything on port 80

00:11:12,540 --> 00:11:17,340
and that allows us to have multiple

00:11:14,550 --> 00:11:21,510
agent proxy instances behind one one

00:11:17,340 --> 00:11:24,780
load balancer the third concert the

00:11:21,510 --> 00:11:27,480
Daisy proxy has is the concept of a cos

00:11:24,780 --> 00:11:30,450
a cos are access control lists and

00:11:27,480 --> 00:11:34,050
basically the that is very similar to

00:11:30,450 --> 00:11:36,600
saying Const something equals something

00:11:34,050 --> 00:11:39,180
so it's just a variable and what you

00:11:36,600 --> 00:11:42,000
actually basically how this works is you

00:11:39,180 --> 00:11:44,820
say access control list is HTTP that's

00:11:42,000 --> 00:11:48,150
the name of the variable this is my

00:11:44,820 --> 00:11:49,950
condition so I want to say I want I want

00:11:48,150 --> 00:11:50,370
you to look at the header X forwarded

00:11:49,950 --> 00:11:52,080
proto

00:11:50,370 --> 00:11:55,260
and I want you to check if it matches

00:11:52,080 --> 00:11:57,840
that value so here we're checking if the

00:11:55,260 --> 00:12:01,830
request that's coming in is on HTTP

00:11:57,840 --> 00:12:04,410
request then we've got two more access

00:12:01,830 --> 00:12:07,860
control lists one checks if the path

00:12:04,410 --> 00:12:10,500
begins with slash API so if that if that

00:12:07,860 --> 00:12:13,100
matches then basically is API will be

00:12:10,500 --> 00:12:17,100
true so we want to route to the core API

00:12:13,100 --> 00:12:19,110
if the path starts with slash API slash

00:12:17,100 --> 00:12:23,310
carts then we need to route to the card

00:12:19,110 --> 00:12:25,560
service and then then we use the use

00:12:23,310 --> 00:12:28,980
backend directive which essentially

00:12:25,560 --> 00:12:31,650
takes the first thing is the backend

00:12:28,980 --> 00:12:34,410
that we want to redirect to and then our

00:12:31,650 --> 00:12:37,140
condition so if this is not HTTP request

00:12:34,410 --> 00:12:39,150
then I want you to use that back-end and

00:12:37,140 --> 00:12:40,890
anything after that is not going to be

00:12:39,150 --> 00:12:42,510
cold because we're we're going to be

00:12:40,890 --> 00:12:45,750
used that we're going to be using up I

00:12:42,510 --> 00:12:48,840
can't so for the HTTP redirect back-end

00:12:45,750 --> 00:12:51,420
that's quite simple we basically do use

00:12:48,840 --> 00:12:55,050
the redirect directive and we say

00:12:51,420 --> 00:12:56,970
redirect scheme HTTP code 301 basically

00:12:55,050 --> 00:13:00,900
means that I want you to change the

00:12:56,970 --> 00:13:02,760
scheme of this request to HTTPS and I

00:13:00,900 --> 00:13:06,870
want you to do a 301 redirect because we

00:13:02,760 --> 00:13:10,110
always want to be using HTTPS if we want

00:13:06,870 --> 00:13:14,430
to redirect to if one proxy the request

00:13:10,110 --> 00:13:16,080
to to our core API a cheap proxy allows

00:13:14,430 --> 00:13:19,530
you to have multiple different servers

00:13:16,080 --> 00:13:20,640
so it will check that because it's a

00:13:19,530 --> 00:13:23,070
load balancer you can

00:13:20,640 --> 00:13:25,530
have like three different instances of

00:13:23,070 --> 00:13:27,570
our core API and then it will know how

00:13:25,530 --> 00:13:32,580
to distribute that load

00:13:27,570 --> 00:13:35,130
equivalently so basically you say my

00:13:32,580 --> 00:13:36,390
first server is has that name and that

00:13:35,130 --> 00:13:39,540
name is going to be used in the

00:13:36,390 --> 00:13:43,500
statistics dashboard I want you to route

00:13:39,540 --> 00:13:47,130
to that IP on that port so 443 is are as

00:13:43,500 --> 00:13:48,570
a support our HTTP port and I want you

00:13:47,130 --> 00:13:50,040
to verify that this request has a

00:13:48,570 --> 00:13:51,810
necessarily cuz we always want to make

00:13:50,040 --> 00:13:54,630
sure that there is an SSL associate

00:13:51,810 --> 00:13:57,210
associated to that request and I want

00:13:54,630 --> 00:13:58,800
you to the check directive basically all

00:13:57,210 --> 00:14:00,930
it does is it checks that these servers

00:13:58,800 --> 00:14:04,800
up and running before doing the before

00:14:00,930 --> 00:14:06,450
doing the routing so there we have two

00:14:04,800 --> 00:14:08,490
servers and then they ship proxy

00:14:06,450 --> 00:14:10,890
automatically knows hey I should load

00:14:08,490 --> 00:14:15,900
balance this and then I should do 50/50

00:14:10,890 --> 00:14:17,820
traffic so that's quite handy so I

00:14:15,900 --> 00:14:20,490
talked a little bit about the about the

00:14:17,820 --> 00:14:21,930
API proxying but what about like the

00:14:20,490 --> 00:14:24,870
client routing because I mentioned

00:14:21,930 --> 00:14:28,320
earlier that we also route basically all

00:14:24,870 --> 00:14:30,000
of the index or HTML files so the way

00:14:28,320 --> 00:14:33,300
that we do that is instead of looking at

00:14:30,000 --> 00:14:36,800
the actual path we also look at the at

00:14:33,300 --> 00:14:40,410
the domain domain or subdomain whatever

00:14:36,800 --> 00:14:42,600
so if this is a www Sotomayor or just to

00:14:40,410 --> 00:14:45,840
make a domain then I want you to route

00:14:42,600 --> 00:14:48,660
to the travel.com website if this is a

00:14:45,840 --> 00:14:49,970
check out retail or our internal CMS

00:14:48,660 --> 00:14:53,610
then I want you to route to the

00:14:49,970 --> 00:14:56,130
appropriate location and to show you an

00:14:53,610 --> 00:14:59,100
example of that of how we how we serve

00:14:56,130 --> 00:15:00,930
our Ember UPS is basically this is this

00:14:59,100 --> 00:15:03,390
is the example again we've got a

00:15:00,930 --> 00:15:07,290
front-end which is named HTTP n it's

00:15:03,390 --> 00:15:10,890
listening on port 4040 and we first want

00:15:07,290 --> 00:15:14,040
to check which not API which client is

00:15:10,890 --> 00:15:16,680
this that should have said so we're

00:15:14,040 --> 00:15:19,020
checking if that's the this is our

00:15:16,680 --> 00:15:22,470
checkout so if the requests coming in

00:15:19,020 --> 00:15:24,420
much is the secured approval comp so if

00:15:22,470 --> 00:15:28,680
the host is if the beginning of the host

00:15:24,420 --> 00:15:30,690
is secure the tribunal comb then assign

00:15:28,680 --> 00:15:33,540
basically the result of that into the is

00:15:30,690 --> 00:15:36,029
check out and then

00:15:33,540 --> 00:15:38,850
use back and check out if it's check out

00:15:36,029 --> 00:15:41,730
now obviously you wouldn't do this for

00:15:38,850 --> 00:15:43,800
like for just one one single domain you

00:15:41,730 --> 00:15:45,690
would do this for like multiple so like

00:15:43,800 --> 00:15:50,100
we've got like our force equal pay jobs

00:15:45,690 --> 00:15:51,690
so we we have more of these just to fit

00:15:50,100 --> 00:15:56,490
everything on the slide I trimmed it

00:15:51,690 --> 00:15:59,850
down so then our back end here is called

00:15:56,490 --> 00:16:02,190
checkout and we want to we want to do

00:15:59,850 --> 00:16:04,320
two things and we either want to serve

00:16:02,190 --> 00:16:06,899
the robots or txt if there are trying to

00:16:04,320 --> 00:16:09,959
access the robot so txt or we just want

00:16:06,899 --> 00:16:15,360
to serve our our main main check-out up

00:16:09,959 --> 00:16:18,120
so you can have multiple a ACLs inside

00:16:15,360 --> 00:16:20,250
back-end so we're creating here on SEO

00:16:18,120 --> 00:16:23,850
which checks if the path of the request

00:16:20,250 --> 00:16:25,620
is going into the for the robots.txt if

00:16:23,850 --> 00:16:28,940
that is true then what is going to do

00:16:25,620 --> 00:16:33,480
here it's going to set the path of the

00:16:28,940 --> 00:16:35,940
resulting request to our s3 buckets or

00:16:33,480 --> 00:16:39,690
and then the specific path to access the

00:16:35,940 --> 00:16:43,529
robots.txt and only do this if robots is

00:16:39,690 --> 00:16:46,680
true and then the other way around is

00:16:43,529 --> 00:16:48,930
basically if it's not any of those then

00:16:46,680 --> 00:16:53,339
we need to serve our index dot HTML file

00:16:48,930 --> 00:16:55,500
so similar to that we say set path to

00:16:53,339 --> 00:16:58,560
the s3 buckets the path of the

00:16:55,500 --> 00:17:01,160
index.html file unless robots so the

00:16:58,560 --> 00:17:05,730
other way around off of if robots and

00:17:01,160 --> 00:17:08,130
then s3 actually expects that the

00:17:05,730 --> 00:17:12,419
requests coming in will have the header

00:17:08,130 --> 00:17:13,949
off of host to be the s3 bucket so we

00:17:12,419 --> 00:17:17,780
actually get around the problem by

00:17:13,949 --> 00:17:20,569
setting the the ending request as as

00:17:17,780 --> 00:17:25,709
basically we're marking the host to be

00:17:20,569 --> 00:17:28,290
to be what what s3 is expecting so then

00:17:25,709 --> 00:17:31,730
finally we say server the name of the

00:17:28,290 --> 00:17:37,950
server is called checkout and we say the

00:17:31,730 --> 00:17:39,510
the public s3 sub domain of faith WS so

00:17:37,950 --> 00:17:41,580
basically what a chip rocks is going to

00:17:39,510 --> 00:17:44,790
do is going to take the domain that

00:17:41,580 --> 00:17:46,900
you've given there it's gonna update the

00:17:44,790 --> 00:17:49,780
the host header to

00:17:46,900 --> 00:17:51,970
to the Amazon AWS one and then it's also

00:17:49,780 --> 00:17:53,170
going to set the path 20 of these two

00:17:51,970 --> 00:17:58,870
depending on what you're trying to

00:17:53,170 --> 00:18:01,750
access so basically as a summary why we

00:17:58,870 --> 00:18:05,080
decided to use a cheap proxy is mainly

00:18:01,750 --> 00:18:06,940
to shorten the request lifecycle because

00:18:05,080 --> 00:18:11,320
it's very important as an e-commerce

00:18:06,940 --> 00:18:12,720
business to have things really quick we

00:18:11,320 --> 00:18:16,660
also wanted to avoid cache invalidation

00:18:12,720 --> 00:18:19,720
by getting around basically cloud front

00:18:16,660 --> 00:18:23,020
and just using just using a cheap proxy

00:18:19,720 --> 00:18:24,910
to serve the index.html I mean

00:18:23,020 --> 00:18:27,040
everything else all of the assets go

00:18:24,910 --> 00:18:31,150
through cloud front so all of that is

00:18:27,040 --> 00:18:33,280
all of that is cached and it's also

00:18:31,150 --> 00:18:35,080
easier for us again to have one single

00:18:33,280 --> 00:18:36,670
routing layer to go back to if something

00:18:35,080 --> 00:18:40,570
goes wrong we can check one check one

00:18:36,670 --> 00:18:42,610
log we can see once that once that's

00:18:40,570 --> 00:18:44,610
dashboard which has everything in all of

00:18:42,610 --> 00:18:48,520
our back ends all of our front ends and

00:18:44,610 --> 00:18:54,099
yeah so that's

00:18:48,520 --> 00:18:54,099

YouTube URL: https://www.youtube.com/watch?v=gYUEo1hRl_c


