Title: Domain Driven Design (DDD) with Algebraic Data Types (ADT) - RamÃ³n Soto Mathiesen
Publication date: 2020-11-02
Playlist: foss-north 2020ii
Description: 
	Talk details: https://foss-north.se/2020ii/speakers-and-talks.html#rmathiesen
Conference details: https://foss-north.se/2020ii/
Captions: 
	00:00:12,480 --> 00:00:16,960
welcome to another

00:00:13,759 --> 00:00:30,880
virtual frost north event big thanks to

00:00:16,960 --> 00:00:33,840
our sponsors and partners

00:00:30,880 --> 00:00:35,760
so welcome back everyone uh now we have

00:00:33,840 --> 00:00:39,760
the last speaker of the morning session

00:00:35,760 --> 00:00:42,840
um so welcome ramon the stage is yours

00:00:39,760 --> 00:00:45,440
thank you very much johan hello

00:00:42,840 --> 00:00:48,079
everybody

00:00:45,440 --> 00:00:49,840
in this talk i will actually talk about

00:00:48,079 --> 00:00:53,199
a domain driven design

00:00:49,840 --> 00:00:54,800
in combination with algebraic data types

00:00:53,199 --> 00:00:56,960
so a little overview about what we're

00:00:54,800 --> 00:00:58,640
going to see today is

00:00:56,960 --> 00:01:00,079
i'm going to go into a bit of a of the

00:00:58,640 --> 00:01:02,960
background why i

00:01:00,079 --> 00:01:03,359
mentioned this is really relevant or how

00:01:02,960 --> 00:01:06,159
how

00:01:03,359 --> 00:01:07,920
how does this actually give us some

00:01:06,159 --> 00:01:08,479
better possibilities that that other

00:01:07,920 --> 00:01:10,799
kind of

00:01:08,479 --> 00:01:12,560
approaches that we use i'm going to

00:01:10,799 --> 00:01:12,960
compare with some programming paradigms

00:01:12,560 --> 00:01:15,680
that

00:01:12,960 --> 00:01:16,560
most of us that develop mostly have

00:01:15,680 --> 00:01:20,240
heard about

00:01:16,560 --> 00:01:22,000
if not work with and normally i don't

00:01:20,240 --> 00:01:22,560
like to live code but i would like to do

00:01:22,000 --> 00:01:24,799
a demo

00:01:22,560 --> 00:01:27,920
live coding so bear with me if it

00:01:24,799 --> 00:01:30,640
doesn't go as expected

00:01:27,920 --> 00:01:32,400
the slides will be provided to johann

00:01:30,640 --> 00:01:34,560
and the force north conference and

00:01:32,400 --> 00:01:36,159
everybody can take copy paste to do

00:01:34,560 --> 00:01:37,600
whatever they want with them as it would

00:01:36,159 --> 00:01:41,040
be distributed under

00:01:37,600 --> 00:01:45,040
a couple of license

00:01:41,040 --> 00:01:47,600
shortly about myself i'm a mixture of a

00:01:45,040 --> 00:01:48,720
spaniard and a dane marriage so you can

00:01:47,600 --> 00:01:51,280
see me there on the right

00:01:48,720 --> 00:01:53,520
because with jitsi i would rather have a

00:01:51,280 --> 00:01:55,439
good quality on the slides and the code

00:01:53,520 --> 00:01:56,640
instead of having this combination with

00:01:55,439 --> 00:01:59,759
my picture and

00:01:56,640 --> 00:02:03,840
the slides so this is me when i do

00:01:59,759 --> 00:02:06,399
the november thing with a stash i have a

00:02:03,840 --> 00:02:09,039
degree in computer science and i work on

00:02:06,399 --> 00:02:12,080
a daily basis with a

00:02:09,039 --> 00:02:16,080
eu gdpr software in a bit

00:02:12,080 --> 00:02:18,560
strange way that anybody else is doing

00:02:16,080 --> 00:02:20,840
i also have a blog where i mostly put in

00:02:18,560 --> 00:02:24,160
snippets of code but i will put here the

00:02:20,840 --> 00:02:25,840
the slides for the talk afterwards but

00:02:24,160 --> 00:02:28,080
of course your hand will also distribute

00:02:25,840 --> 00:02:29,040
it i'm a believer in open sourceness so

00:02:28,080 --> 00:02:30,800
therefore i've been

00:02:29,040 --> 00:02:32,959
a member of the free software foundation

00:02:30,800 --> 00:02:35,920
for more like 13 years

00:02:32,959 --> 00:02:37,519
and i also very much like a functional

00:02:35,920 --> 00:02:39,040
programming so i have this meetup group

00:02:37,519 --> 00:02:40,480
in copenhagen

00:02:39,040 --> 00:02:42,640
and as you can see in the bottom i've

00:02:40,480 --> 00:02:45,280
tried a lot of programming language

00:02:42,640 --> 00:02:46,400
and all these are i have used in a

00:02:45,280 --> 00:02:50,560
professional

00:02:46,400 --> 00:02:52,560
environment so just to

00:02:50,560 --> 00:02:54,800
ensure that everybody that's actually

00:02:52,560 --> 00:02:56,959
listened to me

00:02:54,800 --> 00:02:58,720
is actually at the right talk so what i

00:02:56,959 --> 00:03:00,800
will try to do is i will show how we can

00:02:58,720 --> 00:03:02,319
put in some kind of constraints

00:03:00,800 --> 00:03:04,480
and we can check these constraints at

00:03:02,319 --> 00:03:06,159
compile time so so this

00:03:04,480 --> 00:03:08,239
constraint will actually ensure that the

00:03:06,159 --> 00:03:08,560
implementation will actually comply with

00:03:08,239 --> 00:03:11,280
a

00:03:08,560 --> 00:03:12,480
specific domain that we add for a given

00:03:11,280 --> 00:03:15,200
application

00:03:12,480 --> 00:03:16,480
we will be showing code and of course i

00:03:15,200 --> 00:03:19,120
will live code at the end

00:03:16,480 --> 00:03:20,080
but i don't think you need to know how

00:03:19,120 --> 00:03:21,440
to code

00:03:20,080 --> 00:03:23,200
in order to understand what i'm doing

00:03:21,440 --> 00:03:24,879
because we're going to use these adt's

00:03:23,200 --> 00:03:28,000
algebraic data types

00:03:24,879 --> 00:03:30,720
which reminds very much of english

00:03:28,000 --> 00:03:32,400
and i normally always put at the end of

00:03:30,720 --> 00:03:35,280
this slides that i

00:03:32,400 --> 00:03:37,519
like to get questions but sometimes in

00:03:35,280 --> 00:03:39,280
order to not overlap with other speakers

00:03:37,519 --> 00:03:41,599
i try to keep them at the end so if we

00:03:39,280 --> 00:03:44,799
can i can see from the other talk that

00:03:41,599 --> 00:03:44,799
we're already going to do this

00:03:45,599 --> 00:03:50,080
so the reason is why uh i mentioned this

00:03:48,959 --> 00:03:52,640
uh

00:03:50,080 --> 00:03:53,760
in in that of this talk uh with regard

00:03:52,640 --> 00:03:55,920
of the the product type

00:03:53,760 --> 00:03:57,760
recently got added to shisha in its

00:03:55,920 --> 00:04:01,599
version and 9.0

00:03:57,760 --> 00:04:03,519
is that i try to generate this

00:04:01,599 --> 00:04:05,040
kind of software that will comply with

00:04:03,519 --> 00:04:07,920
eu gdpr

00:04:05,040 --> 00:04:09,040
but until that catches on i work and

00:04:07,920 --> 00:04:12,560
doing some

00:04:09,040 --> 00:04:14,640
freelance contracts so most of this

00:04:12,560 --> 00:04:15,760
freelance contract it's not allowed to

00:04:14,640 --> 00:04:17,519
use for example the

00:04:15,760 --> 00:04:19,919
the functional programming language.com

00:04:17,519 --> 00:04:22,960
part of.net which is f-sharp so

00:04:19,919 --> 00:04:25,759
you need to stay with a c-sharp which is

00:04:22,960 --> 00:04:27,280
what most people are used to use so one

00:04:25,759 --> 00:04:28,240
of the things that like the most if you

00:04:27,280 --> 00:04:30,960
have this

00:04:28,240 --> 00:04:31,759
functional brain is that you try to

00:04:30,960 --> 00:04:34,240
domain

00:04:31,759 --> 00:04:36,240
or to model your logic into these

00:04:34,240 --> 00:04:38,720
algebraic data types

00:04:36,240 --> 00:04:41,280
so i gave a talk at the beginning of

00:04:38,720 --> 00:04:41,280
this year's

00:04:41,440 --> 00:04:46,160
based on this tooling that i was

00:04:43,280 --> 00:04:48,080
creating for a customer

00:04:46,160 --> 00:04:50,080
and as we can see in this slide is that

00:04:48,080 --> 00:04:51,199
sometimes in c-sharp you will actually

00:04:50,080 --> 00:04:54,479
get

00:04:51,199 --> 00:04:56,240
an attribute or a representation of a

00:04:54,479 --> 00:04:58,000
value where it can be

00:04:56,240 --> 00:04:59,919
in this case a system user which is

00:04:58,000 --> 00:05:01,039
represented as a reference type as an

00:04:59,919 --> 00:05:02,720
object

00:05:01,039 --> 00:05:04,720
and in other cases when you call this

00:05:02,720 --> 00:05:07,919
api you will get it as a

00:05:04,720 --> 00:05:10,800
primitive value type like a grill in the

00:05:07,919 --> 00:05:11,440
net language so how do you actually

00:05:10,800 --> 00:05:14,720
implement

00:05:11,440 --> 00:05:15,919
the logic in c sharp in order to comply

00:05:14,720 --> 00:05:19,120
with both this

00:05:15,919 --> 00:05:21,199
possibilities in the language so

00:05:19,120 --> 00:05:23,199
this will easily be done in for example

00:05:21,199 --> 00:05:24,800
fjap because it has support for these

00:05:23,199 --> 00:05:28,240
adts

00:05:24,800 --> 00:05:30,240
so so so so this is why i say that

00:05:28,240 --> 00:05:32,000
it's really really good that the net

00:05:30,240 --> 00:05:33,360
design team and this is what i said

00:05:32,000 --> 00:05:35,039
the abstract it's really really good

00:05:33,360 --> 00:05:35,680
that they added the product type sushi

00:05:35,039 --> 00:05:37,520
shot

00:05:35,680 --> 00:05:39,759
but i'm what i'm really really missing

00:05:37,520 --> 00:05:41,039
still is this some types

00:05:39,759 --> 00:05:43,199
and as you can see there on the bottom

00:05:41,039 --> 00:05:43,759
is a i will later on show you how we can

00:05:43,199 --> 00:05:46,320
mimic

00:05:43,759 --> 00:05:48,320
the product types with some types so if

00:05:46,320 --> 00:05:50,160
the net design team actually added

00:05:48,320 --> 00:05:52,960
some types that would be even better

00:05:50,160 --> 00:05:57,039
than adding the product types but hey

00:05:52,960 --> 00:06:00,319
it is what it is right so in order to

00:05:57,039 --> 00:06:03,199
hope that you can follow my

00:06:00,319 --> 00:06:04,080
arguments i'm going to use a 2 and i can

00:06:03,199 --> 00:06:06,400
already

00:06:04,080 --> 00:06:07,280
mention it now it's f sharp and it's

00:06:06,400 --> 00:06:10,479
because it has

00:06:07,280 --> 00:06:13,199
support for this uh three main

00:06:10,479 --> 00:06:15,120
paradigms that we mostly coding right

00:06:13,199 --> 00:06:17,120
and

00:06:15,120 --> 00:06:18,639
i might be biased on my opinions but

00:06:17,120 --> 00:06:20,400
it's because i'm very into

00:06:18,639 --> 00:06:23,680
functional programming but i will try to

00:06:20,400 --> 00:06:26,800
be as called objective as possible

00:06:23,680 --> 00:06:30,560
so just to ensure that we all

00:06:26,800 --> 00:06:31,039
know what the different definitions are

00:06:30,560 --> 00:06:33,680
so

00:06:31,039 --> 00:06:34,080
we all know that imperative code is more

00:06:33,680 --> 00:06:36,560
or less

00:06:34,080 --> 00:06:37,440
what we do when we code in c object

00:06:36,560 --> 00:06:38,800
oriented

00:06:37,440 --> 00:06:41,120
programming is more or less what we do

00:06:38,800 --> 00:06:44,160
when we code in java c plus or c

00:06:41,120 --> 00:06:45,919
sharp functional programming is

00:06:44,160 --> 00:06:47,360
what we mostly do when we code in o

00:06:45,919 --> 00:06:50,639
camera or haskell and

00:06:47,360 --> 00:06:53,680
it's sharp as we will see in a bit

00:06:50,639 --> 00:06:55,680
so the reason i

00:06:53,680 --> 00:06:56,960
choose to show this and if sharp and not

00:06:55,680 --> 00:06:58,800
in haskell is that

00:06:56,960 --> 00:07:00,560
we can actually showcase the three

00:06:58,800 --> 00:07:01,840
paradigms in the shot

00:07:00,560 --> 00:07:03,840
we will not be able to do that in

00:07:01,840 --> 00:07:05,360
haskell because haskell is a pure

00:07:03,840 --> 00:07:07,039
functional programming language so this

00:07:05,360 --> 00:07:10,080
is why i

00:07:07,039 --> 00:07:10,639
choose to use and if sharp and if sharp

00:07:10,080 --> 00:07:14,000
is

00:07:10,639 --> 00:07:15,360
very it's very more it's very related to

00:07:14,000 --> 00:07:17,440
c-sharp

00:07:15,360 --> 00:07:19,280
so the definition which i just

00:07:17,440 --> 00:07:20,720
copy-pasted from wikipedia it says it's

00:07:19,280 --> 00:07:21,919
a functional first but it's still a

00:07:20,720 --> 00:07:24,800
general purpose

00:07:21,919 --> 00:07:25,759
strongly typed i'm a believer in types

00:07:24,800 --> 00:07:27,840
and programming

00:07:25,759 --> 00:07:29,360
but it's also multi-paradigm which is

00:07:27,840 --> 00:07:31,840
what allows us to do functional

00:07:29,360 --> 00:07:34,560
imperative and object oriented

00:07:31,840 --> 00:07:35,440
programming in this in this tool besides

00:07:34,560 --> 00:07:38,800
this

00:07:35,440 --> 00:07:41,680
i think it sharp has

00:07:38,800 --> 00:07:42,560
maybe compared to its ancestor or camel

00:07:41,680 --> 00:07:44,879
some

00:07:42,560 --> 00:07:47,599
really nice features which i will try to

00:07:44,879 --> 00:07:50,800
summarize in the next slides

00:07:47,599 --> 00:07:52,879
so this concept of

00:07:50,800 --> 00:07:54,639
force indentation that you will see also

00:07:52,879 --> 00:07:57,440
in languages like python

00:07:54,639 --> 00:07:58,319
in combination with this pipe operator

00:07:57,440 --> 00:08:00,720
it makes it like

00:07:58,319 --> 00:08:02,240
really easy to read because if you take

00:08:00,720 --> 00:08:02,800
it from the ancestor or camel you can

00:08:02,240 --> 00:08:04,560
just

00:08:02,800 --> 00:08:06,800
put in a lot of code and the compiler

00:08:04,560 --> 00:08:08,879
will actually more or less

00:08:06,800 --> 00:08:11,199
produce the binaries based on the code

00:08:08,879 --> 00:08:13,039
but in a sharp it is a bit more like

00:08:11,199 --> 00:08:15,199
a strict that you need to make the code

00:08:13,039 --> 00:08:16,479
readable by using indentation like as

00:08:15,199 --> 00:08:20,000
you do in python

00:08:16,479 --> 00:08:20,639
but also like by using this uh pipeline

00:08:20,000 --> 00:08:22,960
we can actually

00:08:20,639 --> 00:08:24,400
read the code from left to right and

00:08:22,960 --> 00:08:26,319
then from top to bottom

00:08:24,400 --> 00:08:29,280
this is normally what we do when we read

00:08:26,319 --> 00:08:31,759
like a a normal document right

00:08:29,280 --> 00:08:34,560
if we take like the other paradigm we as

00:08:31,759 --> 00:08:36,240
we normally read code white we go from

00:08:34,560 --> 00:08:38,320
right to left or left to right sorry and

00:08:36,240 --> 00:08:41,279
then we go from bottom to top

00:08:38,320 --> 00:08:42,880
so this is small is like how we tend to

00:08:41,279 --> 00:08:43,680
read code but this is more or less how

00:08:42,880 --> 00:08:46,880
we do it in

00:08:43,680 --> 00:08:49,760
job which i think it's easiest

00:08:46,880 --> 00:08:52,240
the understanding for people who don't

00:08:49,760 --> 00:08:55,519
normally code

00:08:52,240 --> 00:08:55,839
also like in python it has the concept

00:08:55,519 --> 00:08:57,839
of

00:08:55,839 --> 00:08:59,120
a high order function so you can pass in

00:08:57,839 --> 00:09:04,320
your functions

00:08:59,120 --> 00:09:04,320
and that way you can reuse a lot of code

00:09:05,279 --> 00:09:09,760
like i say i'm a big believer of type

00:09:07,680 --> 00:09:12,000
safe code because this helps me whenever

00:09:09,760 --> 00:09:13,680
i do some mistakes i'm not going to ship

00:09:12,000 --> 00:09:15,680
the software to a customer and they get

00:09:13,680 --> 00:09:18,880
mad it's actually on my own table

00:09:15,680 --> 00:09:20,399
i can fix it before shipping and then

00:09:18,880 --> 00:09:22,080
one of the key components which is

00:09:20,399 --> 00:09:23,920
really ideal to

00:09:22,080 --> 00:09:25,600
to use is when you work with all these

00:09:23,920 --> 00:09:28,560
components

00:09:25,600 --> 00:09:29,760
you're able to make small evaluation of

00:09:28,560 --> 00:09:31,519
functionality

00:09:29,760 --> 00:09:33,040
so you can make small snippets you can

00:09:31,519 --> 00:09:35,760
test them and it's just like

00:09:33,040 --> 00:09:36,640
working with legos that you have this

00:09:35,760 --> 00:09:38,800
small blocks

00:09:36,640 --> 00:09:38,800
and

00:09:40,800 --> 00:09:44,720
yes you have this small blocks that you

00:09:42,560 --> 00:09:48,080
just composed to

00:09:44,720 --> 00:09:49,120
bigger blocks so let's see some code and

00:09:48,080 --> 00:09:52,800
i hope

00:09:49,120 --> 00:09:56,080
it's visible otherwise um

00:09:52,800 --> 00:09:57,839
i will show it in emacs

00:09:56,080 --> 00:09:59,680
so here we will see like how we will do

00:09:57,839 --> 00:10:00,399
an imperative code and the domain for

00:09:59,680 --> 00:10:02,640
this is very

00:10:00,399 --> 00:10:05,600
simple we have points and we can have 2d

00:10:02,640 --> 00:10:07,680
points and 3d points

00:10:05,600 --> 00:10:09,920
points in the 2d plane we just have an x

00:10:07,680 --> 00:10:11,519
and y and then a 3d plane we have x y

00:10:09,920 --> 00:10:14,720
and c

00:10:11,519 --> 00:10:17,519
so in order to instantiate structs

00:10:14,720 --> 00:10:18,480
and imperative languages we will need to

00:10:17,519 --> 00:10:21,519
have some kind of

00:10:18,480 --> 00:10:23,279
a function or yeah

00:10:21,519 --> 00:10:24,880
some kind of function so what what this

00:10:23,279 --> 00:10:28,160
function does it actually

00:10:24,880 --> 00:10:31,040
instantiates the struct and based on

00:10:28,160 --> 00:10:32,640
this information and we actually set

00:10:31,040 --> 00:10:34,959
each of the

00:10:32,640 --> 00:10:37,279
accessible fields or attributes to the

00:10:34,959 --> 00:10:39,680
value that we specify this function

00:10:37,279 --> 00:10:40,320
the same will happen with a 3d print or

00:10:39,680 --> 00:10:43,279
the

00:10:40,320 --> 00:10:44,959
3d point and i just implemented like

00:10:43,279 --> 00:10:46,320
some logic where we want to scale it

00:10:44,959 --> 00:10:48,399
with a factor

00:10:46,320 --> 00:10:50,800
so we still need to send in a point

00:10:48,399 --> 00:10:52,640
which in this case is a 2d point

00:10:50,800 --> 00:10:54,160
and we will take the point and we will

00:10:52,640 --> 00:10:56,880
make it

00:10:54,160 --> 00:10:57,760
increase the factors then we will just

00:10:56,880 --> 00:11:01,360
return again

00:10:57,760 --> 00:11:04,959
the point itself so as we can see here

00:11:01,360 --> 00:11:08,000
it's very much we need to define a

00:11:04,959 --> 00:11:09,600
2d point a 3d point and then add

00:11:08,000 --> 00:11:11,200
the functions to instantiate them and

00:11:09,600 --> 00:11:12,480
then just like the logic to do this

00:11:11,200 --> 00:11:15,040
scale

00:11:12,480 --> 00:11:16,560
this is why we tend to use

00:11:15,040 --> 00:11:18,399
object-oriented

00:11:16,560 --> 00:11:19,680
programming because we can see that

00:11:18,399 --> 00:11:21,839
there's some

00:11:19,680 --> 00:11:23,120
similar similarities between these

00:11:21,839 --> 00:11:24,959
points right

00:11:23,120 --> 00:11:27,040
so this is why we can make this thing

00:11:24,959 --> 00:11:31,680
called an abstract class where we

00:11:27,040 --> 00:11:33,920
encapsulate all the global uh

00:11:31,680 --> 00:11:35,680
well all the global or common

00:11:33,920 --> 00:11:37,120
information between the two types that

00:11:35,680 --> 00:11:38,880
we want to work with

00:11:37,120 --> 00:11:41,680
and we can even provide some kind of

00:11:38,880 --> 00:11:43,200
default logic so we say that

00:11:41,680 --> 00:11:44,800
the whole point of object oriented is

00:11:43,200 --> 00:11:45,360
that we cannot instantiate an abstract

00:11:44,800 --> 00:11:49,839
class

00:11:45,360 --> 00:11:52,880
but we can provide a functionality that

00:11:49,839 --> 00:11:56,399
that that's a default

00:11:52,880 --> 00:11:58,959
for the default case so as we can see

00:11:56,399 --> 00:12:00,800
in order to implement our 2d point we

00:11:58,959 --> 00:12:02,959
just need to innervate our abstract

00:12:00,800 --> 00:12:03,760
class so now we can instantiate our 2d

00:12:02,959 --> 00:12:07,279
point

00:12:03,760 --> 00:12:10,000
and we can just call the underlying

00:12:07,279 --> 00:12:11,440
point right but in order to expand it

00:12:10,000 --> 00:12:14,720
with a 3d point

00:12:11,440 --> 00:12:18,079
we need actually to add the c

00:12:14,720 --> 00:12:19,920
x so axis so which are more or less to

00:12:18,079 --> 00:12:22,880
the same so now we have a

00:12:19,920 --> 00:12:24,079
new uh internal valuable which is

00:12:22,880 --> 00:12:25,920
internal c

00:12:24,079 --> 00:12:27,279
and we add the get a set methods that we

00:12:25,920 --> 00:12:28,800
used to do up here

00:12:27,279 --> 00:12:30,639
and then we need to overwrite the

00:12:28,800 --> 00:12:32,399
default uh

00:12:30,639 --> 00:12:35,600
implementation of scale because now we

00:12:32,399 --> 00:12:37,760
have another axis that we need to

00:12:35,600 --> 00:12:39,120
take into consideration when we work

00:12:37,760 --> 00:12:42,480
with

00:12:39,120 --> 00:12:45,279
3d points so

00:12:42,480 --> 00:12:47,120
in order to ensure that the scale

00:12:45,279 --> 00:12:48,720
functionality has this

00:12:47,120 --> 00:12:50,160
the same return type you can see we give

00:12:48,720 --> 00:12:52,800
it an integer

00:12:50,160 --> 00:12:55,360
and then it will return us a point in

00:12:52,800 --> 00:12:57,519
object oriented programming we need to

00:12:55,360 --> 00:12:58,959
this is called downcasting or sorry

00:12:57,519 --> 00:13:00,560
opcasting

00:12:58,959 --> 00:13:04,000
the good thing about opcasting is that

00:13:00,560 --> 00:13:04,000
we can always do it

00:13:04,720 --> 00:13:08,560
what can you say in compile time and

00:13:06,240 --> 00:13:11,680
it's safe because

00:13:08,560 --> 00:13:13,519
going from an innovative class to

00:13:11,680 --> 00:13:15,279
the abstract class it's it's it's off

00:13:13,519 --> 00:13:18,720
casting and that's always a

00:13:15,279 --> 00:13:18,720
compile safe

00:13:19,200 --> 00:13:22,639
so now into this functional programming

00:13:21,519 --> 00:13:24,720
a paradigm

00:13:22,639 --> 00:13:27,200
so this is where algebraic data types

00:13:24,720 --> 00:13:29,279
come in right so for us a point

00:13:27,200 --> 00:13:30,800
in this case we just specified it as

00:13:29,279 --> 00:13:32,959
either a point

00:13:30,800 --> 00:13:34,959
the two-dimensional plane or a point in

00:13:32,959 --> 00:13:37,519
the three-dimensional plane

00:13:34,959 --> 00:13:38,880
i added these two functions because

00:13:37,519 --> 00:13:40,399
normally when you work with functional

00:13:38,880 --> 00:13:42,000
programming you like to work with this

00:13:40,399 --> 00:13:45,199
content called courier

00:13:42,000 --> 00:13:48,399
where you instead of providing all

00:13:45,199 --> 00:13:49,120
the arguments at the same time as we see

00:13:48,399 --> 00:13:51,600
here in

00:13:49,120 --> 00:13:51,600
scale

00:13:52,720 --> 00:13:55,839
oh it's smaller here so we can see here

00:13:54,639 --> 00:13:58,160
that we need to add

00:13:55,839 --> 00:14:00,079
all the arguments at the same time what

00:13:58,160 --> 00:14:01,760
we like to do is we we just like to add

00:14:00,079 --> 00:14:02,000
them partially because sometimes you

00:14:01,760 --> 00:14:05,120
don't

00:14:02,000 --> 00:14:06,000
have all the arguments in that part of

00:14:05,120 --> 00:14:08,240
the code

00:14:06,000 --> 00:14:09,360
but go and fill it into other code

00:14:08,240 --> 00:14:11,839
branches you might

00:14:09,360 --> 00:14:13,360
get the the second or the third

00:14:11,839 --> 00:14:14,959
parameter so that's why you can just

00:14:13,360 --> 00:14:17,839
send a partially applied

00:14:14,959 --> 00:14:19,440
function through your code base but you

00:14:17,839 --> 00:14:22,720
can see here that we just

00:14:19,440 --> 00:14:25,600
specified which kind of

00:14:22,720 --> 00:14:26,800
different subtyping we have for points

00:14:25,600 --> 00:14:30,480
and now when we do this

00:14:26,800 --> 00:14:33,199
scaling function we are able to actually

00:14:30,480 --> 00:14:34,000
parameter on each of those points so

00:14:33,199 --> 00:14:37,920
it's very

00:14:34,000 --> 00:14:42,079
simple and concise to to understand

00:14:37,920 --> 00:14:42,639
so and again i'm very biased with regard

00:14:42,079 --> 00:14:44,560
of

00:14:42,639 --> 00:14:45,760
these comments so again i will try to

00:14:44,560 --> 00:14:49,120
stay as a

00:14:45,760 --> 00:14:50,320
objective as possible so all programming

00:14:49,120 --> 00:14:52,720
paradigms they have the

00:14:50,320 --> 00:14:54,560
pros and cons right so so what we can

00:14:52,720 --> 00:14:57,760
get when we use imperative

00:14:54,560 --> 00:14:59,680
style of code is that these data structs

00:14:57,760 --> 00:15:01,199
are actually represented as value types

00:14:59,680 --> 00:15:03,920
and not reference types or

00:15:01,199 --> 00:15:05,040
pointers to object so if you have an

00:15:03,920 --> 00:15:08,959
array you can actually

00:15:05,040 --> 00:15:12,320
make your code go really really fast

00:15:08,959 --> 00:15:13,600
some cons i tend to see when i work with

00:15:12,320 --> 00:15:15,360
imperative code is that

00:15:13,600 --> 00:15:17,920
all the values are instantiated by

00:15:15,360 --> 00:15:20,639
default so i don't really know

00:15:17,920 --> 00:15:22,800
if i have set the value to zero or it

00:15:20,639 --> 00:15:26,480
was instantiated to zero

00:15:22,800 --> 00:15:30,399
which can be a bit problematic in some

00:15:26,480 --> 00:15:33,839
programs another thing that is a bit

00:15:30,399 --> 00:15:35,040
not ideal is because all fields are

00:15:33,839 --> 00:15:36,959
accessible everything is

00:15:35,040 --> 00:15:38,800
public so you can change it as you want

00:15:36,959 --> 00:15:40,639
but since this is a

00:15:38,800 --> 00:15:42,720
beautiful data structure you can

00:15:40,639 --> 00:15:44,560
actually

00:15:42,720 --> 00:15:46,240
mutate it as you please write but this

00:15:44,560 --> 00:15:47,440
is not ideal if you work with concurrent

00:15:46,240 --> 00:15:49,920
software where you have

00:15:47,440 --> 00:15:51,360
several threads actually trying to

00:15:49,920 --> 00:15:52,720
update

00:15:51,360 --> 00:15:54,800
these values so this is where you need

00:15:52,720 --> 00:15:56,959
to put in lock mechanisms

00:15:54,800 --> 00:15:58,720
and that can actually make a code go

00:15:56,959 --> 00:16:00,880
slower if you don't

00:15:58,720 --> 00:16:02,639
know what you're doing also like the

00:16:00,880 --> 00:16:04,320
lack of polymorphism so you can see that

00:16:02,639 --> 00:16:05,040
we have to do more or less the same code

00:16:04,320 --> 00:16:08,079
all the time

00:16:05,040 --> 00:16:09,759
so we have to repeat and more

00:16:08,079 --> 00:16:12,320
mollies do a lot of copy pasting and

00:16:09,759 --> 00:16:12,320
does add

00:16:12,880 --> 00:16:17,440
the element that's missing for example

00:16:14,720 --> 00:16:20,160
the 3d pointer

00:16:17,440 --> 00:16:21,680
and one of the good things in fsharp

00:16:20,160 --> 00:16:25,680
when i mentioned this with a

00:16:21,680 --> 00:16:29,360
mutability is that even though um

00:16:25,680 --> 00:16:30,480
struts and c are immutable by default in

00:16:29,360 --> 00:16:31,440
in fiat they actually made them

00:16:30,480 --> 00:16:33,839
immutable

00:16:31,440 --> 00:16:36,240
so you have to specify as i do here you

00:16:33,839 --> 00:16:39,440
have to say oh it is actually mutable

00:16:36,240 --> 00:16:42,160
which is yes here

00:16:39,440 --> 00:16:43,440
so you can say it is mutable and point

00:16:42,160 --> 00:16:45,920
3d so you have to

00:16:43,440 --> 00:16:46,560
point at it and make the point immutable

00:16:45,920 --> 00:16:48,959
and then

00:16:46,560 --> 00:16:50,000
change the afterwards so this is more or

00:16:48,959 --> 00:16:53,120
less my in

00:16:50,000 --> 00:16:54,880
impressions of imperative code and now

00:16:53,120 --> 00:16:58,079
we go to object oriented there's like

00:16:54,880 --> 00:16:59,680
this reusability of code by inheritance

00:16:58,079 --> 00:17:01,920
as you can see right so

00:16:59,680 --> 00:17:03,519
we specify an actual class and for the

00:17:01,920 --> 00:17:05,199
2d pointer we can just inherit the

00:17:03,519 --> 00:17:06,480
abstract class and then we're good to go

00:17:05,199 --> 00:17:08,640
but

00:17:06,480 --> 00:17:10,640
of course we need an extra axis for the

00:17:08,640 --> 00:17:13,199
3d so we're just going to add that

00:17:10,640 --> 00:17:14,480
so that's really good one of the also

00:17:13,199 --> 00:17:16,559
very good things about oh

00:17:14,480 --> 00:17:19,039
is that we have encapsulation of

00:17:16,559 --> 00:17:22,480
internal state so

00:17:19,039 --> 00:17:23,520
updates of the x and c and y it has to

00:17:22,480 --> 00:17:26,959
go through

00:17:23,520 --> 00:17:26,959
the get and set methods right

00:17:28,720 --> 00:17:32,480
which will allow you actually to hide

00:17:30,840 --> 00:17:34,080
and

00:17:32,480 --> 00:17:35,760
data so let's say that you don't want

00:17:34,080 --> 00:17:38,960
anybody to change

00:17:35,760 --> 00:17:40,880
the x value once an instantiated right

00:17:38,960 --> 00:17:43,679
so you can just hide the set

00:17:40,880 --> 00:17:46,000
statement so this is something that's

00:17:43,679 --> 00:17:47,840
really really good about

00:17:46,000 --> 00:17:50,240
object oriented programming is that you

00:17:47,840 --> 00:17:51,919
can hide the internal state

00:17:50,240 --> 00:17:53,840
you can also enforce the logic as you

00:17:51,919 --> 00:17:55,039
can see here that we specified that it

00:17:53,840 --> 00:17:57,919
must have

00:17:55,039 --> 00:18:00,160
the member called scale that takes a

00:17:57,919 --> 00:18:02,720
number and then returns a point and you

00:18:00,160 --> 00:18:02,720
can also

00:18:03,600 --> 00:18:09,280
provide some default uh logic

00:18:07,039 --> 00:18:10,880
for this method but you can also allow

00:18:09,280 --> 00:18:12,559
it to be all written here as we see in

00:18:10,880 --> 00:18:14,240
the three-dimensional point

00:18:12,559 --> 00:18:15,679
so this is really really good and object

00:18:14,240 --> 00:18:18,400
oriented

00:18:15,679 --> 00:18:20,080
the problem is of course like i say

00:18:18,400 --> 00:18:22,000
everything has good and bad things is

00:18:20,080 --> 00:18:25,200
that we have this internal state

00:18:22,000 --> 00:18:28,880
which is mutable so if you export

00:18:25,200 --> 00:18:30,400
expose your fields or attributes with a

00:18:28,880 --> 00:18:32,240
get and set methods

00:18:30,400 --> 00:18:34,240
if we work with concurrent software we

00:18:32,240 --> 00:18:34,640
have exactly the same problem as we have

00:18:34,240 --> 00:18:38,880
with

00:18:34,640 --> 00:18:41,520
uh imperative programming also like uh

00:18:38,880 --> 00:18:42,000
one of the things that it might be fear

00:18:41,520 --> 00:18:45,600
from

00:18:42,000 --> 00:18:46,080
both imperative and function programming

00:18:45,600 --> 00:18:48,799
language

00:18:46,080 --> 00:18:51,280
is that our paradigm is that logic is

00:18:48,799 --> 00:18:54,080
actually bound to the class itself

00:18:51,280 --> 00:18:54,799
so in order for this to work we need to

00:18:54,080 --> 00:18:58,000
add

00:18:54,799 --> 00:19:00,240
a member on the class itself

00:18:58,000 --> 00:19:01,520
which is called scale and this is the

00:19:00,240 --> 00:19:02,960
logic

00:19:01,520 --> 00:19:05,360
this is the kind of logic that we need

00:19:02,960 --> 00:19:06,160
to add on on the object itself in order

00:19:05,360 --> 00:19:09,200
to get it

00:19:06,160 --> 00:19:11,919
to to get modified by by the behavior

00:19:09,200 --> 00:19:13,600
so so this is like the more logic that

00:19:11,919 --> 00:19:14,640
you add to some kind of data type the

00:19:13,600 --> 00:19:18,559
bigger this object

00:19:14,640 --> 00:19:19,520
will become we have some kind of pattern

00:19:18,559 --> 00:19:22,640
matching

00:19:19,520 --> 00:19:23,840
but but it's for up to c sharp and

00:19:22,640 --> 00:19:26,240
earlier we have like this kind of

00:19:23,840 --> 00:19:28,400
limitation that we can only use very

00:19:26,240 --> 00:19:30,400
specifically primitive types so we have

00:19:28,400 --> 00:19:32,720
char strings pools and

00:19:30,400 --> 00:19:34,080
integers longs and so on so forth and

00:19:32,720 --> 00:19:37,520
enums right

00:19:34,080 --> 00:19:40,480
but from c sharp c

00:19:37,520 --> 00:19:41,280
zero we actually have the possibility to

00:19:40,480 --> 00:19:44,799
pair a match

00:19:41,280 --> 00:19:46,240
on non-nullable types and the problem

00:19:44,799 --> 00:19:49,760
with this kind of approach

00:19:46,240 --> 00:19:51,600
is based on casting and it's not always

00:19:49,760 --> 00:19:52,080
ideal because you can actually test if

00:19:51,600 --> 00:19:55,280
something

00:19:52,080 --> 00:19:58,640
is an int or a char or a string

00:19:55,280 --> 00:19:59,760
which is not what we want to do in most

00:19:58,640 --> 00:20:01,600
cases because

00:19:59,760 --> 00:20:03,760
that will actually make our unit test

00:20:01,600 --> 00:20:06,080
cases become huge

00:20:03,760 --> 00:20:06,880
whenever we have to taste right so as i

00:20:06,080 --> 00:20:08,880
mentioned before

00:20:06,880 --> 00:20:10,480
up casting we can always do that

00:20:08,880 --> 00:20:11,039
statically typed which is really really

00:20:10,480 --> 00:20:12,960
good

00:20:11,039 --> 00:20:14,240
but down casting this is where it gets

00:20:12,960 --> 00:20:17,200
problematic

00:20:14,240 --> 00:20:18,799
so whenever we downcast incorrectly we

00:20:17,200 --> 00:20:21,200
can actually

00:20:18,799 --> 00:20:23,760
get the error and run time and this is

00:20:21,200 --> 00:20:26,960
what we try to avoid with

00:20:23,760 --> 00:20:31,120
type save programming languages

00:20:26,960 --> 00:20:34,159
at least paradigms is so now to the

00:20:31,120 --> 00:20:37,679
fp code and again

00:20:34,159 --> 00:20:40,080
might be biased but bear with me so i

00:20:37,679 --> 00:20:41,280
i tend to see this as a very and simple

00:20:40,080 --> 00:20:45,600
concise

00:20:41,280 --> 00:20:48,640
way of representing logic into into code

00:20:45,600 --> 00:20:51,280
and this is mostly possible with a

00:20:48,640 --> 00:20:51,840
algebraic data tapes as as we can see

00:20:51,280 --> 00:20:55,600
that

00:20:51,840 --> 00:20:57,840
we can specify uh whatever we want to do

00:20:55,600 --> 00:21:00,159
both when we're constructing our data

00:20:57,840 --> 00:21:01,520
elements but also when we deconstruct

00:21:00,159 --> 00:21:04,880
them

00:21:01,520 --> 00:21:08,000
so given this type of uh

00:21:04,880 --> 00:21:09,840
given this logic of these components

00:21:08,000 --> 00:21:11,520
we don't need to cast at all we will

00:21:09,840 --> 00:21:13,280
never have like a upcast or downcast

00:21:11,520 --> 00:21:16,799
that actually goes wrong

00:21:13,280 --> 00:21:18,960
so adt's also have built-in

00:21:16,799 --> 00:21:21,360
constructors as we can see here so i

00:21:18,960 --> 00:21:23,120
just wrapped them to make it more like a

00:21:21,360 --> 00:21:24,799
functionality in this way but in

00:21:23,120 --> 00:21:26,720
programming languages like haskell that

00:21:24,799 --> 00:21:27,840
we can see that this a constructor could

00:21:26,720 --> 00:21:30,130
be

00:21:27,840 --> 00:21:31,280
instead of being a

00:21:30,130 --> 00:21:33,039
[Music]

00:21:31,280 --> 00:21:37,039
all the parameters at the same time we

00:21:33,039 --> 00:21:38,559
can actually apply them partially

00:21:37,039 --> 00:21:40,000
the thing that i like the most about

00:21:38,559 --> 00:21:41,520
this is that we have exhaustive

00:21:40,000 --> 00:21:44,080
parameters so

00:21:41,520 --> 00:21:45,360
we can put in some flags on the compiler

00:21:44,080 --> 00:21:48,320
that will ensure

00:21:45,360 --> 00:21:48,960
well this function doesn't handle point

00:21:48,320 --> 00:21:51,200
3d

00:21:48,960 --> 00:21:53,280
so i don't really want to build a binary

00:21:51,200 --> 00:21:55,200
until the person developing this

00:21:53,280 --> 00:21:56,799
actually adds that clause because

00:21:55,200 --> 00:21:59,919
otherwise we know that our code can

00:21:56,799 --> 00:22:02,880
actually explode at the end

00:21:59,919 --> 00:22:04,159
and of course one of the things that

00:22:02,880 --> 00:22:06,320
function programming is

00:22:04,159 --> 00:22:08,240
has as a key component is this

00:22:06,320 --> 00:22:11,039
immutability would makes it ideal to

00:22:08,240 --> 00:22:13,919
work with concurrent software

00:22:11,039 --> 00:22:14,480
and not everything is is good in fp so

00:22:13,919 --> 00:22:16,400
we have

00:22:14,480 --> 00:22:17,600
exactly the same problem as we have with

00:22:16,400 --> 00:22:19,360
imperative

00:22:17,600 --> 00:22:21,280
data struct is that all fields are

00:22:19,360 --> 00:22:25,520
actually accessible

00:22:21,280 --> 00:22:27,840
so if you want to limit the domain so

00:22:25,520 --> 00:22:29,039
you want to use a subset of integers not

00:22:27,840 --> 00:22:30,400
all the integers

00:22:29,039 --> 00:22:32,320
you're going to have a problem so let's

00:22:30,400 --> 00:22:35,679
say you only want to use from

00:22:32,320 --> 00:22:39,200
100 to 200 i can at any given point

00:22:35,679 --> 00:22:41,200
deconstruct the the the type object

00:22:39,200 --> 00:22:42,880
put zero and then construct it again

00:22:41,200 --> 00:22:46,960
because this is what's

00:22:42,880 --> 00:22:46,960
happening with this piece of code

00:22:47,200 --> 00:22:52,840
and again immutability is good at some

00:22:50,320 --> 00:22:55,840
point because it ensures that you cannot

00:22:52,840 --> 00:22:58,960
update code update

00:22:55,840 --> 00:23:01,760
data elements in memory concurrently but

00:22:58,960 --> 00:23:03,200
it can also allocate a lot of memory so

00:23:01,760 --> 00:23:03,600
and therefore make your application slow

00:23:03,200 --> 00:23:06,720
so

00:23:03,600 --> 00:23:10,480
you still need to have some kind of a

00:23:06,720 --> 00:23:13,440
notion of what a functional program

00:23:10,480 --> 00:23:13,440
works under the hood

00:23:13,520 --> 00:23:19,200
so now to the point of adts and i will

00:23:16,720 --> 00:23:20,480
go a bit more into detail what rdts

00:23:19,200 --> 00:23:23,679
actually are and also

00:23:20,480 --> 00:23:26,960
how we can use it with a domain

00:23:23,679 --> 00:23:29,200
driven design so

00:23:26,960 --> 00:23:30,720
as i mentioned product types that was

00:23:29,200 --> 00:23:36,080
recently added to

00:23:30,720 --> 00:23:37,679
c-sharp 9.0

00:23:36,080 --> 00:23:39,919
if you just have the concept of thinking

00:23:37,679 --> 00:23:42,000
about it as tuples and

00:23:39,919 --> 00:23:43,600
tuple is just like all the kind of

00:23:42,000 --> 00:23:46,559
different pairs triples

00:23:43,600 --> 00:23:49,120
quadruples and so on and so forth so

00:23:46,559 --> 00:23:52,080
it's just like

00:23:49,120 --> 00:23:52,640
you could say like it's like a list of a

00:23:52,080 --> 00:23:55,840
a

00:23:52,640 --> 00:23:58,320
finite list of elements that can be of

00:23:55,840 --> 00:23:59,760
any types so here we have

00:23:58,320 --> 00:24:02,799
[Music]

00:23:59,760 --> 00:24:02,799
42 and i

00:24:02,880 --> 00:24:08,159
i you use this two letters and if sharp

00:24:06,320 --> 00:24:09,440
in order to specify is a byte because

00:24:08,159 --> 00:24:12,640
for me

00:24:09,440 --> 00:24:13,279
uh i wouldn't use an integer to specify

00:24:12,640 --> 00:24:16,320
eight

00:24:13,279 --> 00:24:20,240
because nobody has minus

00:24:16,320 --> 00:24:21,600
four eight right so uh this is why i i

00:24:20,240 --> 00:24:23,039
use um

00:24:21,600 --> 00:24:24,799
bytes to represent this and this might

00:24:23,039 --> 00:24:26,640
make it a bit like more difficult to

00:24:24,799 --> 00:24:28,159
read but here i'm just using a char for

00:24:26,640 --> 00:24:31,600
the initial for the name it could

00:24:28,159 --> 00:24:32,080
be charles so if we look into what a

00:24:31,600 --> 00:24:34,240
record

00:24:32,080 --> 00:24:35,360
type is compared to a product type so a

00:24:34,240 --> 00:24:37,279
record type is just

00:24:35,360 --> 00:24:39,600
exactly the same as a product type but

00:24:37,279 --> 00:24:43,200
we just add labels to make it more

00:24:39,600 --> 00:24:44,720
understandable so uh

00:24:43,200 --> 00:24:47,120
you could more only say that this is

00:24:44,720 --> 00:24:49,039
like a json object

00:24:47,120 --> 00:24:50,320
because we have like a label and then we

00:24:49,039 --> 00:24:52,159
have like the type

00:24:50,320 --> 00:24:53,520
the label and then we have just like the

00:24:52,159 --> 00:24:55,760
type

00:24:53,520 --> 00:24:57,440
so what are sometimes this is the thing

00:24:55,760 --> 00:25:00,640
that i'm really looking forward to

00:24:57,440 --> 00:25:01,360
to get into c-sharp so it's just like

00:25:00,640 --> 00:25:03,600
this kind of

00:25:01,360 --> 00:25:05,520
disjoint sets so these sets don't have

00:25:03,600 --> 00:25:07,360
elements in common

00:25:05,520 --> 00:25:10,400
but the elements that you're actually

00:25:07,360 --> 00:25:12,640
using it must be in one of these

00:25:10,400 --> 00:25:14,960
disjoint sets so an example could be

00:25:12,640 --> 00:25:17,679
like a person could either be a child

00:25:14,960 --> 00:25:19,200
and after they are 18 they actually

00:25:17,679 --> 00:25:22,799
become adults

00:25:19,200 --> 00:25:24,960
or when we want to measure temperature

00:25:22,799 --> 00:25:27,760
we can use celsius or fahrenheit

00:25:24,960 --> 00:25:30,320
so when we use when we measure celsius

00:25:27,760 --> 00:25:32,559
we use flow because we can have decimals

00:25:30,320 --> 00:25:33,919
but when we measure fahrenheit we only

00:25:32,559 --> 00:25:38,320
have

00:25:33,919 --> 00:25:41,520
integers so

00:25:38,320 --> 00:25:44,400
just to go back to the mention i did

00:25:41,520 --> 00:25:45,840
i mentioned before where we could mimic

00:25:44,400 --> 00:25:48,240
record types

00:25:45,840 --> 00:25:49,200
with some types and this is why i think

00:25:48,240 --> 00:25:51,120
it's

00:25:49,200 --> 00:25:52,640
more important to get some types into a

00:25:51,120 --> 00:25:54,559
programming language that

00:25:52,640 --> 00:25:57,360
may be going for product types or record

00:25:54,559 --> 00:26:00,159
types is because we can actually mimic

00:25:57,360 --> 00:26:00,799
the record type here we can mimic it

00:26:00,159 --> 00:26:04,559
with

00:26:00,799 --> 00:26:05,919
a single case some type so a single case

00:26:04,559 --> 00:26:08,080
is just

00:26:05,919 --> 00:26:09,360
if we forget about fahrenheit of int we

00:26:08,080 --> 00:26:13,039
just take the first

00:26:09,360 --> 00:26:14,320
case here and this off on the right side

00:26:13,039 --> 00:26:16,240
we just

00:26:14,320 --> 00:26:17,600
provide exactly the same information

00:26:16,240 --> 00:26:20,640
with labels

00:26:17,600 --> 00:26:24,480
and the types as we did in the record

00:26:20,640 --> 00:26:26,720
so it's a an

00:26:24,480 --> 00:26:28,159
equivalent way of doing things but it's

00:26:26,720 --> 00:26:31,120
uh

00:26:28,159 --> 00:26:33,120
yeah normally i will use record types in

00:26:31,120 --> 00:26:35,120
the shop because it has a better uh

00:26:33,120 --> 00:26:36,159
interaction with the the ecosystem of

00:26:35,120 --> 00:26:38,799
the chart but

00:26:36,159 --> 00:26:40,960
some games in some cases i actually use

00:26:38,799 --> 00:26:44,240
some types of single constructors

00:26:40,960 --> 00:26:51,919
which we will see later on

00:26:44,240 --> 00:26:54,320
so just a bit more complex scenario

00:26:51,919 --> 00:26:56,559
where we can

00:26:54,320 --> 00:26:57,520
see how we can use this pattern matching

00:26:56,559 --> 00:27:01,600
so

00:26:57,520 --> 00:27:03,520
we have this notion of and

00:27:01,600 --> 00:27:05,120
just a small domain i just going to use

00:27:03,520 --> 00:27:07,600
a suite for

00:27:05,120 --> 00:27:08,640
the different cards and then just a card

00:27:07,600 --> 00:27:11,919
is a rank

00:27:08,640 --> 00:27:15,919
which can go from one to uh

00:27:11,919 --> 00:27:15,919
i don't know 10 and then you have like

00:27:16,000 --> 00:27:20,320
what's called jack king and queen and

00:27:18,640 --> 00:27:22,799
then you have like the suit right

00:27:20,320 --> 00:27:23,440
so in my functionality i just say is it

00:27:22,799 --> 00:27:25,279
an ace

00:27:23,440 --> 00:27:26,799
and i will just take a card as an input

00:27:25,279 --> 00:27:30,080
argument and i will give a

00:27:26,799 --> 00:27:30,799
boolean as output or return value so now

00:27:30,080 --> 00:27:33,120
a pattern match

00:27:30,799 --> 00:27:34,799
i just can deconstruct the record and

00:27:33,120 --> 00:27:37,120
say well is there rank

00:27:34,799 --> 00:27:38,159
one if it's one i know it says and then

00:27:37,120 --> 00:27:40,240
i will say true

00:27:38,159 --> 00:27:42,000
and then i have this wildcard notion and

00:27:40,240 --> 00:27:44,080
if sharper i can just say well all the

00:27:42,000 --> 00:27:47,760
other cases are actually false

00:27:44,080 --> 00:27:51,440
but i can also do it exhaustive

00:27:47,760 --> 00:27:54,320
so if i only say is this card

00:27:51,440 --> 00:27:55,120
true and if i don't add this flag and f

00:27:54,320 --> 00:27:58,399
sharp

00:27:55,120 --> 00:28:00,640
i can actually avoid using this uh

00:27:58,399 --> 00:28:02,159
other case in the pattern matching but

00:28:00,640 --> 00:28:03,360
that will actually make runtime errors

00:28:02,159 --> 00:28:04,960
so this is something that we really

00:28:03,360 --> 00:28:07,840
don't want to do

00:28:04,960 --> 00:28:08,799
another example is we could do an assert

00:28:07,840 --> 00:28:11,919
of an age

00:28:08,799 --> 00:28:13,440
if somebody is actually an adult or a

00:28:11,919 --> 00:28:15,760
child so

00:28:13,440 --> 00:28:18,799
we can do this logic where we take the

00:28:15,760 --> 00:28:21,919
age and then we take like this person

00:28:18,799 --> 00:28:22,640
and we will return the boolean so we'll

00:28:21,919 --> 00:28:26,240
say

00:28:22,640 --> 00:28:29,360
is this person actually 18 years

00:28:26,240 --> 00:28:31,840
old and we can say true or false and so

00:28:29,360 --> 00:28:31,840
on so forth

00:28:32,559 --> 00:28:35,679
so the good thing about these small

00:28:34,320 --> 00:28:38,240
snippets is that we just

00:28:35,679 --> 00:28:40,240
define them more or less in single lines

00:28:38,240 --> 00:28:41,120
in most cases and sometimes a bit more

00:28:40,240 --> 00:28:43,520
complex

00:28:41,120 --> 00:28:44,960
but once we make this small lego blocks

00:28:43,520 --> 00:28:47,520
we can just combine them

00:28:44,960 --> 00:28:48,480
so here we have this product type and an

00:28:47,520 --> 00:28:50,640
equivalent

00:28:48,480 --> 00:28:53,039
record type where we have labels and now

00:28:50,640 --> 00:28:56,559
we just take some type where we combine

00:28:53,039 --> 00:28:59,120
those two product and record types

00:28:56,559 --> 00:29:00,399
so this will actually make like the

00:28:59,120 --> 00:29:03,039
cartesian product of

00:29:00,399 --> 00:29:05,039
all the elements of bytes and chars and

00:29:03,039 --> 00:29:06,320
this will make all

00:29:05,039 --> 00:29:08,240
yeah the same constitution product

00:29:06,320 --> 00:29:12,720
because those two are equivalent

00:29:08,240 --> 00:29:15,600
and here we just combined those two um

00:29:12,720 --> 00:29:17,679
can you say new sets we just combine it

00:29:15,600 --> 00:29:20,000
into a whole new set

00:29:17,679 --> 00:29:20,720
so as we will see in the next couple of

00:29:20,000 --> 00:29:22,720
slides

00:29:20,720 --> 00:29:25,440
we can see how this is actually ideal

00:29:22,720 --> 00:29:28,480
because all your domain will just be

00:29:25,440 --> 00:29:30,240
placed as a data or type definitions in

00:29:28,480 --> 00:29:34,640
your actually code

00:29:30,240 --> 00:29:37,039
so this is why jarominsky who is

00:29:34,640 --> 00:29:38,640
i think he's the cto of james street he

00:29:37,039 --> 00:29:40,880
come with this

00:29:38,640 --> 00:29:42,960
sentence in a tweet or was it a blog

00:29:40,880 --> 00:29:44,480
post where you say

00:29:42,960 --> 00:29:46,159
by using this kind of approach we can

00:29:44,480 --> 00:29:47,279
actually make illegal states

00:29:46,159 --> 00:29:49,919
unrepresentable so

00:29:47,279 --> 00:29:50,640
if we don't allow them to be possible in

00:29:49,919 --> 00:29:52,720
the domain

00:29:50,640 --> 00:29:54,240
or we cannot do them in the code it's

00:29:52,720 --> 00:29:56,480
not possible to actually

00:29:54,240 --> 00:29:58,320
represent them afterwards and if you

00:29:56,480 --> 00:29:58,960
cannot represent invalid dates in your

00:29:58,320 --> 00:30:01,279
code base

00:29:58,960 --> 00:30:03,440
you never have to test for it which will

00:30:01,279 --> 00:30:06,799
actually minimize the amount of

00:30:03,440 --> 00:30:09,600
use cases or unit test cases that we

00:30:06,799 --> 00:30:11,679
add to our code in order to go into all

00:30:09,600 --> 00:30:15,440
these corner cases that we sometimes

00:30:11,679 --> 00:30:18,159
forget about so this is like

00:30:15,440 --> 00:30:18,159
a common

00:30:18,559 --> 00:30:22,080
diagram that i use to to to to show when

00:30:21,760 --> 00:30:26,720
i

00:30:22,080 --> 00:30:26,720
talk about domain-driven design

00:30:28,960 --> 00:30:32,320
so you have a lot of business analysts

00:30:30,640 --> 00:30:34,480
that provides this kind of a

00:30:32,320 --> 00:30:36,640
documentation with diagrams like this

00:30:34,480 --> 00:30:40,159
and in case is in the er

00:30:36,640 --> 00:30:41,679
diagram so so we can see that

00:30:40,159 --> 00:30:43,279
the domain of this is has to do

00:30:41,679 --> 00:30:46,720
something about planes

00:30:43,279 --> 00:30:49,919
spooking hotel hotels and cars

00:30:46,720 --> 00:30:51,360
and so on and so forth and maybe it's a

00:30:49,919 --> 00:30:54,559
bit outdated because of

00:30:51,360 --> 00:30:57,360
the virus right now so nobody's actually

00:30:54,559 --> 00:30:58,960
traveling anywhere around but hey it's

00:30:57,360 --> 00:31:01,679
it is what it is

00:30:58,960 --> 00:31:03,440
so so normally what i do is i i tend to

00:31:01,679 --> 00:31:09,279
say it's intuitive

00:31:03,440 --> 00:31:09,279
to see well we cannot really see that

00:31:10,159 --> 00:31:13,360
well so so what we can see if we

00:31:11,919 --> 00:31:16,080
understand

00:31:13,360 --> 00:31:17,919
er diagrams we can see that in order to

00:31:16,080 --> 00:31:20,640
do a booking we need to have a plane

00:31:17,919 --> 00:31:23,679
right this is why the one is specified

00:31:20,640 --> 00:31:25,519
but we can also see well

00:31:23,679 --> 00:31:26,880
we need to book a plane but we really

00:31:25,519 --> 00:31:27,600
don't need to book a hotel because it

00:31:26,880 --> 00:31:30,159
can be

00:31:27,600 --> 00:31:31,440
either be zero or one and it's the same

00:31:30,159 --> 00:31:33,840
with a car right so this is something

00:31:31,440 --> 00:31:36,640
that we can get out of this

00:31:33,840 --> 00:31:37,840
image or this diagram right so mandatory

00:31:36,640 --> 00:31:40,240
we need to work a plane

00:31:37,840 --> 00:31:42,880
when we do a broken but we but we could

00:31:40,240 --> 00:31:45,360
book a hotel or rent a car

00:31:42,880 --> 00:31:47,200
this is optional and this is what

00:31:45,360 --> 00:31:50,240
happening when we see these diagrams

00:31:47,200 --> 00:31:50,799
is that this is um this is at most what

00:31:50,240 --> 00:31:54,399
we can get

00:31:50,799 --> 00:31:57,519
out of this diagram right

00:31:54,399 --> 00:31:59,760
so could we actually

00:31:57,519 --> 00:32:01,440
devise from this diagram which products

00:31:59,760 --> 00:32:03,200
are being offered

00:32:01,440 --> 00:32:05,360
well i would say that's that's not

00:32:03,200 --> 00:32:08,559
possible right

00:32:05,360 --> 00:32:08,559
so this is actually my

00:32:11,120 --> 00:32:18,480
my kind of way on how to domain design

00:32:15,279 --> 00:32:19,039
with a code but it's still not code that

00:32:18,480 --> 00:32:21,200
implements

00:32:19,039 --> 00:32:22,640
logic it's still it's just code that

00:32:21,200 --> 00:32:25,919
define

00:32:22,640 --> 00:32:28,159
a domain so if we do it like this way so

00:32:25,919 --> 00:32:30,240
we can say okay we know that the

00:32:28,159 --> 00:32:32,080
center is like a booking so we can say

00:32:30,240 --> 00:32:34,799
well we can have a basic

00:32:32,080 --> 00:32:35,840
booking which is just booking a plane we

00:32:34,799 --> 00:32:37,440
can do a combo

00:32:35,840 --> 00:32:39,360
which we will see in a bit and then we

00:32:37,440 --> 00:32:40,880
can go with the full packwoods where

00:32:39,360 --> 00:32:43,919
we actually book everything right so we

00:32:40,880 --> 00:32:46,720
put the plane the hotel and the car

00:32:43,919 --> 00:32:47,360
the plane itself we need to specify a

00:32:46,720 --> 00:32:49,919
date

00:32:47,360 --> 00:32:51,679
when we go to the place and then i'll

00:32:49,919 --> 00:32:53,279
return that when we come back

00:32:51,679 --> 00:32:55,840
but also like the destination where we

00:32:53,279 --> 00:32:58,080
want to go right the combo

00:32:55,840 --> 00:32:59,840
again this is like we have three

00:32:58,080 --> 00:33:01,360
different possibilities in the booking

00:32:59,840 --> 00:33:03,919
the combo we can actually go with a

00:33:01,360 --> 00:33:04,399
hotel and we can also go with a car

00:33:03,919 --> 00:33:05,919
right

00:33:04,399 --> 00:33:07,919
so when we go with a hotel it's just

00:33:05,919 --> 00:33:10,480
like okay we'll take the plane

00:33:07,919 --> 00:33:12,080
and we book the hotel as well and with

00:33:10,480 --> 00:33:15,519
the car we booked the plane

00:33:12,080 --> 00:33:17,760
and the car so the hotel we need to

00:33:15,519 --> 00:33:19,519
provide some kind of a arrival date but

00:33:17,760 --> 00:33:23,120
also a departure date

00:33:19,519 --> 00:33:25,679
and of course the location and the same

00:33:23,120 --> 00:33:26,640
with the car we need to know where we

00:33:25,679 --> 00:33:28,720
want to book it from

00:33:26,640 --> 00:33:31,200
and maybe where we want to deliver it to

00:33:28,720 --> 00:33:33,519
right because we can go to one airport

00:33:31,200 --> 00:33:35,039
and rent a car there and then we go to

00:33:33,519 --> 00:33:36,000
another airport and leave the car there

00:33:35,039 --> 00:33:38,080
right

00:33:36,000 --> 00:33:40,159
so the city itself is just a string in

00:33:38,080 --> 00:33:42,720
this case very basic

00:33:40,159 --> 00:33:43,200
and the date is just like the system

00:33:42,720 --> 00:33:46,559
date

00:33:43,200 --> 00:33:47,840
time from from fp but now we can see

00:33:46,559 --> 00:33:49,840
here that it's no

00:33:47,840 --> 00:33:51,360
logic whatsoever implementation logic

00:33:49,840 --> 00:33:54,480
whatsoever

00:33:51,360 --> 00:33:55,600
but we have already defined much more

00:33:54,480 --> 00:33:58,799
information that we did

00:33:55,600 --> 00:34:00,799
in the diagram before so we can see that

00:33:58,799 --> 00:34:02,080
this software needs to handle three kind

00:34:00,799 --> 00:34:04,720
of products right basic

00:34:02,080 --> 00:34:06,720
carbon full pack and the combo itself is

00:34:04,720 --> 00:34:07,679
divided into two sub products which are

00:34:06,720 --> 00:34:10,320
with hotel

00:34:07,679 --> 00:34:12,240
and with cars so we can see those

00:34:10,320 --> 00:34:12,960
constraints i was talking before with

00:34:12,240 --> 00:34:16,079
this

00:34:12,960 --> 00:34:19,839
notion of tuples pens and triples

00:34:16,079 --> 00:34:22,480
so in order for us to instantiate

00:34:19,839 --> 00:34:23,200
for all of us to to choose which kind of

00:34:22,480 --> 00:34:25,280
a

00:34:23,200 --> 00:34:26,560
product or booking we want to do we have

00:34:25,280 --> 00:34:29,520
to go into this

00:34:26,560 --> 00:34:31,280
union and say well is it a full pack or

00:34:29,520 --> 00:34:34,159
we want the three things if we provide

00:34:31,280 --> 00:34:36,480
the three things it's a full pack right

00:34:34,159 --> 00:34:38,480
and we know that for the basic thing we

00:34:36,480 --> 00:34:40,399
need to provide a plane that's it

00:34:38,480 --> 00:34:42,320
that's just a single element which is

00:34:40,399 --> 00:34:43,760
pretty simple but if we go for the combo

00:34:42,320 --> 00:34:46,639
we can either provide it with

00:34:43,760 --> 00:34:48,240
this uh pair or those two parameters

00:34:46,639 --> 00:34:50,000
which is the plane of the hotel

00:34:48,240 --> 00:34:52,000
and the plane in the car and if we don't

00:34:50,000 --> 00:34:54,079
do this we cannot instantiate this

00:34:52,000 --> 00:34:55,280
type of object and the same goes with

00:34:54,079 --> 00:34:58,240
the full park

00:34:55,280 --> 00:34:59,680
and we also have we have exactly the

00:34:58,240 --> 00:35:03,119
same constraints

00:34:59,680 --> 00:35:05,920
in in playing cards and hotels and so on

00:35:03,119 --> 00:35:10,480
and so forth that we actually need to

00:35:05,920 --> 00:35:10,480
provide these arguments on instantiation

00:35:10,800 --> 00:35:14,320
so so this is why i say that this is a

00:35:12,800 --> 00:35:18,160
really good way of

00:35:14,320 --> 00:35:18,640
uh introducing the design of your

00:35:18,160 --> 00:35:21,359
software

00:35:18,640 --> 00:35:22,480
directly into code but you still have

00:35:21,359 --> 00:35:24,800
this separation between

00:35:22,480 --> 00:35:25,920
implementation and design and the good

00:35:24,800 --> 00:35:29,200
thing about this

00:35:25,920 --> 00:35:31,680
design is that this goes into your

00:35:29,200 --> 00:35:32,880
repository where you keep all your code

00:35:31,680 --> 00:35:36,640
so you can always see

00:35:32,880 --> 00:35:38,079
how your domain evolves over time

00:35:36,640 --> 00:35:40,000
your node application live type

00:35:38,079 --> 00:35:42,960
management because no software

00:35:40,000 --> 00:35:44,000
stays as as it was at the beginning so

00:35:42,960 --> 00:35:46,079
this will actually

00:35:44,000 --> 00:35:47,440
allow you to see that in the history oh

00:35:46,079 --> 00:35:49,680
but we have basic products

00:35:47,440 --> 00:35:51,119
perform time and now we add them again

00:35:49,680 --> 00:35:53,839
and maybe in six months again we'll

00:35:51,119 --> 00:35:53,839
remove it again

00:35:56,079 --> 00:36:00,880
so so this is more or less in

00:36:01,200 --> 00:36:04,240
what i want to to show and and now we'll

00:36:03,280 --> 00:36:07,520
try to do some

00:36:04,240 --> 00:36:10,079
live coding where i will try to

00:36:07,520 --> 00:36:12,480
implement the domain of a book that can

00:36:10,079 --> 00:36:14,480
both be used for a bookstore but also

00:36:12,480 --> 00:36:17,200
like a library

00:36:14,480 --> 00:36:18,800
so i'm just going to take a code here so

00:36:17,200 --> 00:36:21,119
let me go to

00:36:18,800 --> 00:36:21,119
book

00:36:23,599 --> 00:36:28,800
i'm going to start a rebel just to see

00:36:26,320 --> 00:36:31,119
here over here

00:36:28,800 --> 00:36:31,119
yes

00:36:32,320 --> 00:36:35,680
so let's try to read up before what we

00:36:35,359 --> 00:36:38,720
do

00:36:35,680 --> 00:36:40,720
so we know that now in

00:36:38,720 --> 00:36:42,560
nowaday nowadays we have more more or

00:36:40,720 --> 00:36:44,960
less these three kind of type of

00:36:42,560 --> 00:36:46,960
books right so we have audiobooks which

00:36:44,960 --> 00:36:48,640
we normally call ebooks

00:36:46,960 --> 00:36:50,240
we have electronic books what we

00:36:48,640 --> 00:36:52,160
normally call ebooks

00:36:50,240 --> 00:36:54,320
and then we have the good old physical

00:36:52,160 --> 00:36:57,920
books which we call printed

00:36:54,320 --> 00:37:00,000
books right each of these

00:36:57,920 --> 00:37:02,320
types of books can actually have several

00:37:00,000 --> 00:37:05,680
formats right so we can have aac

00:37:02,320 --> 00:37:08,720
mp3s and 4b

00:37:05,680 --> 00:37:10,640
and the old wave format and with

00:37:08,720 --> 00:37:14,160
electronic books we can have epub

00:37:10,640 --> 00:37:17,760
we can have moby and also pdf

00:37:14,160 --> 00:37:19,040
and good old printed books we have

00:37:17,760 --> 00:37:21,040
hardcore

00:37:19,040 --> 00:37:23,280
sorry hardcover books which are the ones

00:37:21,040 --> 00:37:26,400
that i prefer

00:37:23,280 --> 00:37:28,079
because paperbacks tend to

00:37:26,400 --> 00:37:29,920
what can you say when you read a lot of

00:37:28,079 --> 00:37:32,960
them that seems to get

00:37:29,920 --> 00:37:35,280
bent too much which is not really nice

00:37:32,960 --> 00:37:36,000
so what we can devise when we talk about

00:37:35,280 --> 00:37:39,040
books is that we

00:37:36,000 --> 00:37:40,400
have some kind of common fields so this

00:37:39,040 --> 00:37:42,000
is why i state here that should be

00:37:40,400 --> 00:37:44,800
mandatory that we have a title

00:37:42,000 --> 00:37:46,240
for the book in order to recognize it

00:37:44,800 --> 00:37:48,079
sometimes you can have

00:37:46,240 --> 00:37:49,520
a lot of authors you can have one and

00:37:48,079 --> 00:37:52,640
sometimes you can have none

00:37:49,520 --> 00:37:53,920
which is when it is anonymous written

00:37:52,640 --> 00:37:56,800
normally you will also have like a

00:37:53,920 --> 00:37:59,760
publisher so this will give sense

00:37:56,800 --> 00:38:00,720
the language which is written in also

00:37:59,760 --> 00:38:02,560
helps a lot

00:38:00,720 --> 00:38:04,560
and then you have this two kind of

00:38:02,560 --> 00:38:06,160
identification and

00:38:04,560 --> 00:38:09,119
because they are a bit complex because

00:38:06,160 --> 00:38:12,480
they they involve some modulus

00:38:09,119 --> 00:38:16,640
i don't know if it's 11 or 13 and

00:38:12,480 --> 00:38:17,359
when you add in this this logic i'm just

00:38:16,640 --> 00:38:18,800
going to

00:38:17,359 --> 00:38:20,160
specify them but i'm not going to

00:38:18,800 --> 00:38:22,400
implement it here because it can take

00:38:20,160 --> 00:38:23,920
sometimes

00:38:22,400 --> 00:38:25,920
one of the things that would be optional

00:38:23,920 --> 00:38:28,400
is that that would be pages because

00:38:25,920 --> 00:38:30,160
electronic books and printed books they

00:38:28,400 --> 00:38:32,640
both have pages right

00:38:30,160 --> 00:38:33,920
that's what books are but the audiobooks

00:38:32,640 --> 00:38:36,720
they don't have pages

00:38:33,920 --> 00:38:38,160
because we listen to them from our

00:38:36,720 --> 00:38:42,160
either laptops or

00:38:38,160 --> 00:38:44,160
tablets or phones right smartphones

00:38:42,160 --> 00:38:46,240
and here i would like to showcase how

00:38:44,160 --> 00:38:47,440
you can do like we want a raisin to see

00:38:46,240 --> 00:38:48,880
if they're good so we're going to give

00:38:47,440 --> 00:38:50,560
them one to five stars

00:38:48,880 --> 00:38:52,480
and here we'll actually showcase you how

00:38:50,560 --> 00:38:54,640
you can limit

00:38:52,480 --> 00:38:56,079
a given primitive type so in this case

00:38:54,640 --> 00:38:59,040
we will use a byte

00:38:56,079 --> 00:39:00,079
but how to ensure in my whole domain

00:38:59,040 --> 00:39:03,119
that

00:39:00,079 --> 00:39:04,240
i know for a certainty that a book will

00:39:03,119 --> 00:39:07,359
always have

00:39:04,240 --> 00:39:09,520
either a value from one to five

00:39:07,359 --> 00:39:10,720
and it will never have another value so

00:39:09,520 --> 00:39:12,480
this is something that we can do in

00:39:10,720 --> 00:39:13,599
algebraic data type if we combine it

00:39:12,480 --> 00:39:14,960
with some

00:39:13,599 --> 00:39:17,119
fancy stuff that i will show you in a

00:39:14,960 --> 00:39:17,119
bit

00:39:17,359 --> 00:39:21,280
so i can see here that the first thing i

00:39:18,800 --> 00:39:23,280
did was put in the review

00:39:21,280 --> 00:39:24,880
and it was a rating so let's do a type

00:39:23,280 --> 00:39:28,240
rating

00:39:24,880 --> 00:39:31,280
and that would just be so the trick is

00:39:28,240 --> 00:39:34,800
in haskell by default

00:39:31,280 --> 00:39:37,920
your logic and your modules

00:39:34,800 --> 00:39:41,359
here is actually hidden

00:39:37,920 --> 00:39:41,920
it's not exposed but both in ocam and if

00:39:41,359 --> 00:39:44,000
y'all

00:39:41,920 --> 00:39:46,000
that this logic is actually exposed by

00:39:44,000 --> 00:39:47,359
default so what you need to do is you

00:39:46,000 --> 00:39:51,760
need to say well

00:39:47,359 --> 00:39:51,760
my constructor needs to be

00:39:52,640 --> 00:39:57,839
hidden so now we can do lit

00:39:59,839 --> 00:40:07,359
rate of x and we can say

00:40:03,599 --> 00:40:07,359
if x is

00:40:07,920 --> 00:40:14,720
greater equal to zero and if x

00:40:11,200 --> 00:40:18,880
is equal to five then we will get

00:40:14,720 --> 00:40:22,560
some x otherwise we will not

00:40:18,880 --> 00:40:22,560
get a valid rate right

00:40:22,640 --> 00:40:26,319
and just to see if this works we can

00:40:24,400 --> 00:40:28,640
actually look into the snippet here

00:40:26,319 --> 00:40:28,640
and do

00:40:34,560 --> 00:40:41,040
so we can do our review and we can say

00:40:38,000 --> 00:40:42,960
i want to do a rate of 42.

00:40:41,040 --> 00:40:45,040
now the code itself tell us well the

00:40:42,960 --> 00:40:47,359
constructor is not available

00:40:45,040 --> 00:40:48,400
so you need to use other kind of logic

00:40:47,359 --> 00:40:50,839
in order to do this

00:40:48,400 --> 00:40:52,000
and because i implemented a rate

00:40:50,839 --> 00:40:53,599
function

00:40:52,000 --> 00:40:56,079
now i would say well the value you have

00:40:53,599 --> 00:40:59,760
given me is not actually available

00:40:56,079 --> 00:41:03,440
so what if i give it a valid one

00:40:59,760 --> 00:41:03,440
oh now i actually have

00:41:04,839 --> 00:41:13,520
oh and this is actually wrong

00:41:08,560 --> 00:41:13,520
because it needs to be a rate of x yes

00:41:15,520 --> 00:41:23,839
because otherwise if i expose the

00:41:18,839 --> 00:41:26,240
uh i understand that

00:41:23,839 --> 00:41:28,800
see how type type systems help you to

00:41:26,240 --> 00:41:32,400
code better

00:41:28,800 --> 00:41:32,400
yes and now we do it so

00:41:33,680 --> 00:41:37,839
we 42 with the byte and here we just say

00:41:36,400 --> 00:41:40,560
wow

00:41:37,839 --> 00:41:42,960
so now we actually have a valid rate

00:41:40,560 --> 00:41:42,960
value

00:41:43,119 --> 00:41:48,160
and now we need to provide this rate

00:41:46,079 --> 00:41:50,160
information into our domain so we ensure

00:41:48,160 --> 00:41:51,520
that our books only have a valid rate

00:41:50,160 --> 00:41:53,760
right

00:41:51,520 --> 00:41:55,680
so let's look into the formats and we

00:41:53,760 --> 00:41:59,760
can see the formats we can have

00:41:55,680 --> 00:42:04,480
both types for audio

00:41:59,760 --> 00:42:09,520
and we will go with a h2

00:42:04,480 --> 00:42:09,520
b3 e4b

00:42:11,359 --> 00:42:19,839
then we have electronic

00:42:16,160 --> 00:42:24,000
and we have input modem

00:42:19,839 --> 00:42:26,880
pdf and then we'll have

00:42:24,000 --> 00:42:26,880
print of course

00:42:27,520 --> 00:42:31,839
hard column

00:42:36,480 --> 00:42:40,560
so now we use three some types to

00:42:39,599 --> 00:42:43,760
specify

00:42:40,560 --> 00:42:46,800
the different formats that are actually

00:42:43,760 --> 00:42:50,319
available for each of

00:42:46,800 --> 00:42:54,160
each of the different types right

00:42:50,319 --> 00:42:54,160
so now as before we saw with

00:42:54,800 --> 00:42:59,839
the booking type we're going to have

00:42:56,319 --> 00:42:59,839
three kind of

00:42:59,920 --> 00:43:04,400
three kind of book types so we're going

00:43:01,520 --> 00:43:08,560
to say well we're going to have an audio

00:43:04,400 --> 00:43:12,880
of audio then we're going to have a

00:43:08,560 --> 00:43:16,160
electronic of electronic

00:43:12,880 --> 00:43:18,560
and we're going to have a print of

00:43:16,160 --> 00:43:18,560
print

00:43:22,720 --> 00:43:26,560
this is i add some spaces just to make

00:43:25,680 --> 00:43:30,079
it a bit more

00:43:26,560 --> 00:43:32,160
um readable if i just run this code as

00:43:30,079 --> 00:43:34,720
it is it will actually complain because

00:43:32,160 --> 00:43:35,839
there's nothing called audio yet right

00:43:34,720 --> 00:43:38,319
so what you can do

00:43:35,839 --> 00:43:39,040
with um sharp in this case is that you

00:43:38,319 --> 00:43:44,000
can add in

00:43:39,040 --> 00:43:47,599
an add clause where you say well

00:43:44,000 --> 00:43:47,599
we will have a audiobook

00:43:48,400 --> 00:43:52,480
oh yes audio type of book that will

00:43:50,720 --> 00:43:56,160
equals

00:43:52,480 --> 00:43:56,800
and we can say of course we will need

00:43:56,160 --> 00:43:59,359
all this

00:43:56,800 --> 00:44:00,720
mandatory information because this is

00:43:59,359 --> 00:44:02,720
what we have in common

00:44:00,720 --> 00:44:04,240
but we don't need these pages and we

00:44:02,720 --> 00:44:07,040
will also have the rating right so what

00:44:04,240 --> 00:44:12,160
we need to do is we're going to say

00:44:07,040 --> 00:44:14,880
we will need a common values

00:44:12,160 --> 00:44:16,640
and then we will need well only the

00:44:14,880 --> 00:44:20,240
rating

00:44:16,640 --> 00:44:24,960
which is of the type

00:44:20,240 --> 00:44:27,839
a review and then it's rating

00:44:24,960 --> 00:44:29,520
notice that i added a as the type itself

00:44:27,839 --> 00:44:30,160
i don't add it as an option type is

00:44:29,520 --> 00:44:32,880
because i

00:44:30,160 --> 00:44:34,079
only want to have valid ratings on the

00:44:32,880 --> 00:44:37,440
books

00:44:34,079 --> 00:44:38,960
so what i need to do is i need to ensure

00:44:37,440 --> 00:44:40,079
that i get a valid rating with this

00:44:38,960 --> 00:44:45,359
functionality

00:44:40,079 --> 00:44:47,520
and based on this sum none case i can

00:44:45,359 --> 00:44:48,960
if i have the valid data i can actually

00:44:47,520 --> 00:44:51,359
pass it to the next

00:44:48,960 --> 00:44:53,440
logic encode and i can actually generate

00:44:51,359 --> 00:44:57,680
or instantiate an audio book or

00:44:53,440 --> 00:44:57,680
a type of book that has exactly

00:44:57,839 --> 00:45:08,960
a valid rating so then we also have

00:45:05,280 --> 00:45:08,960
and we will have an electronic

00:45:09,200 --> 00:45:15,440
and that will be you will also need

00:45:12,240 --> 00:45:15,440
a common one

00:45:15,839 --> 00:45:20,160
common is just all this mandatory fields

00:45:18,720 --> 00:45:24,400
and here we will actually have

00:45:20,160 --> 00:45:27,599
some pages and i think we can

00:45:24,400 --> 00:45:33,200
get away with an unsigned

00:45:27,599 --> 00:45:36,720
integer 65 and just to see that system

00:45:33,200 --> 00:45:36,720
let's look at this

00:45:39,119 --> 00:45:43,920
yeah i have never written a book that

00:45:41,440 --> 00:45:45,040
has more than 65 000 pages so i think

00:45:43,920 --> 00:45:46,560
that will do

00:45:45,040 --> 00:45:48,800
and of course we will need a rating as

00:45:46,560 --> 00:45:48,800
well

00:45:53,200 --> 00:45:57,040
i don't know why i keep forgetting to

00:45:55,200 --> 00:46:00,720
put electronically see at the end

00:45:57,040 --> 00:46:02,400
that's kind of strange

00:46:00,720 --> 00:46:03,920
and then the last book we need is just

00:46:02,400 --> 00:46:09,599
good old print books

00:46:03,920 --> 00:46:09,599
and we can mourn this

00:46:10,560 --> 00:46:14,480
copy paste this so what i'm seeing here

00:46:12,400 --> 00:46:16,319
is actually a

00:46:14,480 --> 00:46:17,680
missing part so i would really like to

00:46:16,319 --> 00:46:22,240
add formats

00:46:17,680 --> 00:46:25,920
and format would be audio here

00:46:22,240 --> 00:46:29,839
and format would be

00:46:25,920 --> 00:46:29,839
format electronic

00:46:30,800 --> 00:46:38,800
and here the format would be

00:46:34,400 --> 00:46:38,800
format print

00:46:41,280 --> 00:46:44,640
yes so this is more like the domain i

00:46:44,160 --> 00:46:47,839
will

00:46:44,640 --> 00:46:49,280
like to use so if we run this now

00:46:47,839 --> 00:46:51,520
it's going to give an error because we

00:46:49,280 --> 00:46:54,560
don't have common specified yet

00:46:51,520 --> 00:46:58,160
so now we can just do and

00:46:54,560 --> 00:46:58,160
comma just equal

00:46:58,560 --> 00:47:03,760
all the title will be some kind of

00:47:01,680 --> 00:47:10,319
string

00:47:03,760 --> 00:47:14,079
all those which will be

00:47:10,319 --> 00:47:14,079
would be some kind of list

00:47:15,119 --> 00:47:25,839
list of strings and what else

00:47:19,280 --> 00:47:25,839
a publisher would also be a string

00:47:26,400 --> 00:47:33,599
and then we have the language

00:47:29,760 --> 00:47:33,599
which would be a type language

00:47:34,000 --> 00:47:39,839
and the espn 10

00:47:43,599 --> 00:47:48,400
13 and so on so forth and we will need

00:47:46,880 --> 00:47:52,960
to do

00:47:48,400 --> 00:47:56,720
m plane which will be of type

00:47:52,960 --> 00:47:59,280
well let's sweden so we have english

00:47:56,720 --> 00:48:00,640
and we have swedish because of false

00:47:59,280 --> 00:48:05,359
north

00:48:00,640 --> 00:48:08,880
and we have espn 10 which is

00:48:05,359 --> 00:48:08,880
type espn

00:48:08,960 --> 00:48:11,200
00:48:18,880 --> 00:48:21,839
string does not

00:48:28,160 --> 00:48:34,480
yes so now we actually have specified

00:48:30,480 --> 00:48:38,160
the domain for our

00:48:34,480 --> 00:48:39,520
book and nobody says this is the right

00:48:38,160 --> 00:48:43,040
way to do it this is just

00:48:39,520 --> 00:48:44,640
how i see it gives sense for me

00:48:43,040 --> 00:48:46,720
but the good thing is that we have

00:48:44,640 --> 00:48:49,040
specified a lot of

00:48:46,720 --> 00:48:51,200
constraints into the domain so for

00:48:49,040 --> 00:48:55,280
example we never need to test if an

00:48:51,200 --> 00:48:56,960
audiobook has a pages right this is not

00:48:55,280 --> 00:49:00,319
part of the

00:48:56,960 --> 00:49:02,160
record type which is part of the overall

00:49:00,319 --> 00:49:04,640
some type so this is something that we

00:49:02,160 --> 00:49:06,319
never need to to to test with right

00:49:04,640 --> 00:49:08,000
and if we put into this object or

00:49:06,319 --> 00:49:11,359
orientative

00:49:08,000 --> 00:49:14,640
paradigm where we sometimes make this an

00:49:11,359 --> 00:49:16,240
abstract class of course we can solve

00:49:14,640 --> 00:49:18,720
this with a

00:49:16,240 --> 00:49:20,640
interface where we just say that both

00:49:18,720 --> 00:49:24,160
electronic and print need to implement

00:49:20,640 --> 00:49:27,040
the the the pages interface

00:49:24,160 --> 00:49:28,000
but but it it can get sometimes a

00:49:27,040 --> 00:49:30,480
cumbersome

00:49:28,000 --> 00:49:32,240
to to to do all this logic and it gives

00:49:30,480 --> 00:49:33,839
sense in the object-oriented way

00:49:32,240 --> 00:49:35,680
but the problem as i see it when i work

00:49:33,839 --> 00:49:37,119
with this is once you have a list with

00:49:35,680 --> 00:49:39,440
all these elements in there

00:49:37,119 --> 00:49:40,559
when you begin to opcast and downcast

00:49:39,440 --> 00:49:43,119
and you don't have

00:49:40,559 --> 00:49:44,640
all the logic right because if we

00:49:43,119 --> 00:49:46,559
implement the interface on

00:49:44,640 --> 00:49:48,319
electronic and print they will have an

00:49:46,559 --> 00:49:49,440
extra method that when you call it it

00:49:48,319 --> 00:49:51,200
will say pages

00:49:49,440 --> 00:49:52,800
but the problem is you don't have that

00:49:51,200 --> 00:49:56,240
method on audio

00:49:52,800 --> 00:50:00,319
so you need to distinguish in some way

00:49:56,240 --> 00:50:04,000
and well this innovative

00:50:00,319 --> 00:50:07,359
element has of the type

00:50:04,000 --> 00:50:08,400
audio and these other ones have of the

00:50:07,359 --> 00:50:11,280
type

00:50:08,400 --> 00:50:13,680
electronic and print and those two types

00:50:11,280 --> 00:50:16,319
have an extra method that you can call

00:50:13,680 --> 00:50:17,599
so so at least with the the parameting

00:50:16,319 --> 00:50:20,960
here in the job you can

00:50:17,599 --> 00:50:21,760
ensure that as we saw in the first like

00:50:20,960 --> 00:50:24,880
if we just go

00:50:21,760 --> 00:50:27,680
back here that

00:50:24,880 --> 00:50:29,280
when we provide logic which is not bound

00:50:27,680 --> 00:50:31,280
to the data type itself

00:50:29,280 --> 00:50:32,960
we can always deconstruct the different

00:50:31,280 --> 00:50:41,839
kind of types that are built

00:50:32,960 --> 00:50:41,839
that are bound to this overall type

00:50:43,119 --> 00:50:48,480
yeah so so just a note

00:50:46,319 --> 00:50:50,720
what i showed at the beginning this rate

00:50:48,480 --> 00:50:50,720
thing

00:50:51,119 --> 00:50:54,240
so this is the way that we do in a

00:50:52,880 --> 00:50:55,599
functional program this is the way we

00:50:54,240 --> 00:50:58,079
encapsulate data

00:50:55,599 --> 00:50:59,440
by limiting exposure of private

00:50:58,079 --> 00:51:01,280
constructors

00:50:59,440 --> 00:51:03,680
so so this way we can actually more or

00:51:01,280 --> 00:51:06,160
less achieve and i will not say the

00:51:03,680 --> 00:51:08,079
the case where we can actually somehow

00:51:06,160 --> 00:51:10,000
bypass it but there's still ways to

00:51:08,079 --> 00:51:11,599
to to reduce that bypassing but this is

00:51:10,000 --> 00:51:12,400
small is that the way we would try to

00:51:11,599 --> 00:51:16,400
mimic

00:51:12,400 --> 00:51:19,440
the object-oriented encapsulation

00:51:16,400 --> 00:51:23,280
approach so

00:51:19,440 --> 00:51:26,400
i really hope that i more or less

00:51:23,280 --> 00:51:30,079
show you a new way of thinking on how

00:51:26,400 --> 00:51:34,240
you can actually make a more reliable

00:51:30,079 --> 00:51:35,839
sound application by modeling

00:51:34,240 --> 00:51:38,000
the business logic itself into the

00:51:35,839 --> 00:51:39,839
application by using these

00:51:38,000 --> 00:51:42,480
algebraic data types to design the

00:51:39,839 --> 00:51:44,319
system and afterwards we will use

00:51:42,480 --> 00:51:46,319
all parts of the code to actually

00:51:44,319 --> 00:51:48,559
implement it and i really really hope

00:51:46,319 --> 00:51:51,200
that this gets out to the

00:51:48,559 --> 00:51:51,760
shisha design scene so they finally add

00:51:51,200 --> 00:51:53,680
this

00:51:51,760 --> 00:51:55,599
component to to the language which is

00:51:53,680 --> 00:51:58,720
good at

00:51:55,599 --> 00:52:02,319
as it is but i still made uh i still

00:51:58,720 --> 00:52:05,040
miss that little thing for me but

00:52:02,319 --> 00:52:06,800
and again i go back to this thing that

00:52:05,040 --> 00:52:07,599
because we use these adts we can

00:52:06,800 --> 00:52:11,040
actually

00:52:07,599 --> 00:52:11,599
uh use these mathematical constraints of

00:52:11,040 --> 00:52:15,760
uh

00:52:11,599 --> 00:52:20,480
offsets and uh to to to limit um

00:52:15,760 --> 00:52:24,880
the the logic that we can have in

00:52:20,480 --> 00:52:27,119
in our applications and

00:52:24,880 --> 00:52:29,040
yes and as i mentioned also like if you

00:52:27,119 --> 00:52:30,960
can't represent a validator

00:52:29,040 --> 00:52:33,839
you never have to think about test and

00:52:30,960 --> 00:52:35,839
test for it

00:52:33,839 --> 00:52:39,680
and i think that was what i wanted to

00:52:35,839 --> 00:52:39,680
say so if there are any question

00:52:40,079 --> 00:52:46,000
yes thank you there are questions

00:52:43,359 --> 00:52:47,920
we got one question here from gino how

00:52:46,000 --> 00:52:49,280
do you get an organization to invest in

00:52:47,920 --> 00:52:51,520
functional programming

00:52:49,280 --> 00:52:53,839
aren't all non-academics and especially

00:52:51,520 --> 00:52:56,559
managers very scared of it independent

00:52:53,839 --> 00:52:56,559
of the benefits

00:52:56,640 --> 00:53:02,559
it is a bit problematic because uh

00:53:00,240 --> 00:53:04,079
you can do some really really cool stuff

00:53:02,559 --> 00:53:06,000
with this approach

00:53:04,079 --> 00:53:08,480
but if it's only a small subset of

00:53:06,000 --> 00:53:10,800
people in your organization doing this

00:53:08,480 --> 00:53:12,000
when those people leave because let's

00:53:10,800 --> 00:53:15,200
face it

00:53:12,000 --> 00:53:17,200
i see people swept around all the time

00:53:15,200 --> 00:53:19,760
so if you don't have a global

00:53:17,200 --> 00:53:21,760
understanding of this approach

00:53:19,760 --> 00:53:23,280
it's not going to be viable to to to

00:53:21,760 --> 00:53:25,760
maintain this piece of code

00:53:23,280 --> 00:53:27,440
so this is why i like the approach of

00:53:25,760 --> 00:53:28,800
c-sharp that

00:53:27,440 --> 00:53:30,319
they're beginning to take a lot of

00:53:28,800 --> 00:53:32,079
chunks of fsharp and they're beginning

00:53:30,319 --> 00:53:35,119
to port it into the language

00:53:32,079 --> 00:53:35,760
and this way c-sharp people will work as

00:53:35,119 --> 00:53:37,200
they do

00:53:35,760 --> 00:53:38,559
and every time this comes one of these

00:53:37,200 --> 00:53:39,680
features these are people get really

00:53:38,559 --> 00:53:41,680
really excited because

00:53:39,680 --> 00:53:43,520
wow this is really cool but this is what

00:53:41,680 --> 00:53:44,960
we have sharper so camouflage haskell

00:53:43,520 --> 00:53:47,520
has been doing all the time

00:53:44,960 --> 00:53:49,280
so i don't mind if they steal with pride

00:53:47,520 --> 00:53:50,160
from f-sharp and put it directly into

00:53:49,280 --> 00:53:51,839
c-sharp

00:53:50,160 --> 00:53:54,000
because when i work on this freeland

00:53:51,839 --> 00:53:56,640
contract i can actually work

00:53:54,000 --> 00:53:58,400
the way my brain gives sense and people

00:53:56,640 --> 00:54:00,319
once they see it in the c-sharp context

00:53:58,400 --> 00:54:01,760
they will just say wow this is amazing

00:54:00,319 --> 00:54:04,000
this is what happened with the link

00:54:01,760 --> 00:54:06,319
right everybody thinks link is the

00:54:04,000 --> 00:54:08,319
the best thing that ever happened to

00:54:06,319 --> 00:54:09,680
c-sharp right but the whole paradigm of

00:54:08,319 --> 00:54:11,200
link is built on

00:54:09,680 --> 00:54:13,119
functional programming and the way that

00:54:11,200 --> 00:54:15,040
you actually

00:54:13,119 --> 00:54:16,319
work with data in functional programming

00:54:15,040 --> 00:54:19,119
so

00:54:16,319 --> 00:54:19,440
i i'm i'm not even mad as the meme says

00:54:19,119 --> 00:54:22,559
right

00:54:19,440 --> 00:54:23,599
so please bring all this fancy things

00:54:22,559 --> 00:54:27,440
from

00:54:23,599 --> 00:54:29,760
a functional programming paradigm into

00:54:27,440 --> 00:54:31,200
languages like c sharp and we already

00:54:29,760 --> 00:54:32,720
have them in rust and we already have

00:54:31,200 --> 00:54:37,359
them in shrimp so

00:54:32,720 --> 00:54:39,520
it's just like keeping coming

00:54:37,359 --> 00:54:40,799
yeah and the next question actually sort

00:54:39,520 --> 00:54:43,440
of ties into that

00:54:40,799 --> 00:54:44,799
it's from johan how does it how does the

00:54:43,440 --> 00:54:46,960
f-sharp interface

00:54:44,799 --> 00:54:49,200
look to the c-sharp world is it is this

00:54:46,960 --> 00:54:51,119
a good way to build types for an

00:54:49,200 --> 00:54:53,440
object-oriented system by using

00:54:51,119 --> 00:54:56,799
functional programming methods

00:54:53,440 --> 00:54:59,440
uh so so the the thing about fsharp is

00:54:56,799 --> 00:55:01,520
because it's built into the net

00:54:59,440 --> 00:55:02,480
ecosystem it it can actually coexist

00:55:01,520 --> 00:55:05,280
very well like

00:55:02,480 --> 00:55:07,040
it can access almost seamlessly

00:55:05,280 --> 00:55:10,160
seemingly

00:55:07,040 --> 00:55:11,839
logic on for example c-sharp libraries

00:55:10,160 --> 00:55:13,280
but when you do that you still need to

00:55:11,839 --> 00:55:14,319
understand that there can be null

00:55:13,280 --> 00:55:17,040
pointers that can be

00:55:14,319 --> 00:55:18,799
all this kind of behavior that you have

00:55:17,040 --> 00:55:22,160
in c-sharp

00:55:18,799 --> 00:55:22,559
when you call it um in a what can you

00:55:22,160 --> 00:55:27,119
say

00:55:22,559 --> 00:55:30,480
in a uh in a trivial way

00:55:27,119 --> 00:55:32,160
you might pour all that kind of uh

00:55:30,480 --> 00:55:34,480
misbehavior into your shop so this is

00:55:32,160 --> 00:55:36,240
why you need to make some kind of

00:55:34,480 --> 00:55:37,280
constraints when you interact with those

00:55:36,240 --> 00:55:39,200
libraries

00:55:37,280 --> 00:55:41,440
and and the way you can do it from f

00:55:39,200 --> 00:55:43,359
sharp to c sharp is try to do a lot of

00:55:41,440 --> 00:55:44,720
try catching and then the other way

00:55:43,359 --> 00:55:47,760
around is expose

00:55:44,720 --> 00:55:48,480
your f-sharp libraries with a c-sharp

00:55:47,760 --> 00:55:50,960
wrapper

00:55:48,480 --> 00:55:52,319
so it's more seamlessly seamlessly to

00:55:50,960 --> 00:55:56,640
work with from

00:55:52,319 --> 00:55:58,319
c-sharp oh so so if you don't do these

00:55:56,640 --> 00:55:59,920
wrappers it becomes

00:55:58,319 --> 00:56:01,920
just like any other foreign function

00:55:59,920 --> 00:56:04,640
interface i guess uh

00:56:01,920 --> 00:56:06,160
yeah yeah so so it's you have to do a

00:56:04,640 --> 00:56:09,359
lot of definitive programming because

00:56:06,160 --> 00:56:11,839
it's um it's it's a bit um

00:56:09,359 --> 00:56:12,960
yeah problematic especially if you see

00:56:11,839 --> 00:56:16,000
it from the f-sharp

00:56:12,960 --> 00:56:17,839
perspective yeah yeah of course uh

00:56:16,000 --> 00:56:19,839
then i had a question which is uh sort

00:56:17,839 --> 00:56:22,160
of uh i mean now we're talking about the

00:56:19,839 --> 00:56:25,119
algebraic data types and how to

00:56:22,160 --> 00:56:25,520
how to protect uh against the bad states

00:56:25,119 --> 00:56:28,400
why

00:56:25,520 --> 00:56:30,799
why not take it all the way and just use

00:56:28,400 --> 00:56:33,599
dependently type programming instead

00:56:30,799 --> 00:56:35,040
where you would yeah but dependently

00:56:33,599 --> 00:56:38,160
type programming

00:56:35,040 --> 00:56:41,119
yeah yeah but i think there's still

00:56:38,160 --> 00:56:42,079
uh isn't like still a big gap from

00:56:41,119 --> 00:56:45,760
academia to

00:56:42,079 --> 00:56:48,240
industry as i see it now we still

00:56:45,760 --> 00:56:49,599
have a bit of problem to get the

00:56:48,240 --> 00:56:50,720
functional programming language into

00:56:49,599 --> 00:56:52,000
industry

00:56:50,720 --> 00:56:53,760
and just imagine if you have to put

00:56:52,000 --> 00:56:55,599
independent types right

00:56:53,760 --> 00:56:57,119
yeah it's similar to the the question

00:56:55,599 --> 00:57:00,880
from gina before that

00:56:57,119 --> 00:57:02,799
you need sort of a critical mass

00:57:00,880 --> 00:57:04,640
i would still say that in order to get

00:57:02,799 --> 00:57:06,559
dependent typing you might

00:57:04,640 --> 00:57:07,839
have to read out to people working with

00:57:06,559 --> 00:57:11,839
cork actor

00:57:07,839 --> 00:57:14,720
or e3s but in order to get people uh

00:57:11,839 --> 00:57:16,079
and and i i i guess that requires more

00:57:14,720 --> 00:57:18,640
as an academic

00:57:16,079 --> 00:57:19,680
degree but i still think that functional

00:57:18,640 --> 00:57:21,599
programming languages

00:57:19,680 --> 00:57:22,799
i have this group in copenhagen and we

00:57:21,599 --> 00:57:25,119
have people working

00:57:22,799 --> 00:57:26,000
with closure that never uh went to

00:57:25,119 --> 00:57:27,280
university

00:57:26,000 --> 00:57:29,200
so there's a lot of flavors in

00:57:27,280 --> 00:57:31,280
functional programming so there's a lot

00:57:29,200 --> 00:57:34,799
of people coming in from

00:57:31,280 --> 00:57:38,000
all all around so so i think it's

00:57:34,799 --> 00:57:41,040
maybe easier to get fp fp

00:57:38,000 --> 00:57:41,599
in to a uh politic uh technologies then

00:57:41,040 --> 00:57:45,119
maybe

00:57:41,599 --> 00:57:48,319
dependent types yup yup sure

00:57:45,119 --> 00:57:49,839
all right i think that's yeah

00:57:48,319 --> 00:57:51,920
that's all the questions we had we had

00:57:49,839 --> 00:57:55,520
no new ones on the live chat

00:57:51,920 --> 00:57:57,280
uh thanks a lot ramon yeah thank you

00:57:55,520 --> 00:58:00,000
and uh johan do you want to say

00:57:57,280 --> 00:58:01,599
something before we head off to lunch

00:58:00,000 --> 00:58:03,680
no i wanted to say that we're heading

00:58:01,599 --> 00:58:04,559
off for lunch so the stream will resume

00:58:03,680 --> 00:58:08,160
at 2.

00:58:04,559 --> 00:58:12,400
uh it will stay open so so feel free to

00:58:08,160 --> 00:58:14,400
uh to join us back at two o'clock

00:58:12,400 --> 00:58:16,160
and until then big thanks for everyone

00:58:14,400 --> 00:58:23,839
showing up speakers

00:58:16,160 --> 00:58:23,839
viewers and then the rest of you cheers

00:58:24,799 --> 00:58:26,880

YouTube URL: https://www.youtube.com/watch?v=2kOETAB-9xI


