Title: Getting pixels on screen on Linux: introduction to Kernel Mode Setting - Simon Ser
Publication date: 2020-11-02
Playlist: foss-north 2020ii
Description: 
	Talk details: https://foss-north.se/2020ii/speakers-and-talks.html#sser
Conference details: https://foss-north.se/2020ii/
Captions: 
	00:00:12,480 --> 00:00:16,960
welcome to another

00:00:13,759 --> 00:00:31,840
virtual frost north event big thanks to

00:00:16,960 --> 00:00:31,840
our sponsors and partners

00:00:32,640 --> 00:00:36,399
so welcome back everyone um it's time

00:00:35,360 --> 00:00:42,079
for our next speaker

00:00:36,399 --> 00:00:42,079
simon zere so simon it's all yours

00:00:42,320 --> 00:00:50,239
yeah hi um i'm simon sir

00:00:47,039 --> 00:00:52,320
or immersion i work at uh sorcererhart

00:00:50,239 --> 00:00:56,000
and i'll be talking to you about getting

00:00:52,320 --> 00:00:56,000
pixels on screen and linux

00:00:56,960 --> 00:01:01,600
so i'm going to talk about the kernel

00:01:00,239 --> 00:01:04,000
interface to get

00:01:01,600 --> 00:01:06,000
pixels on screen and linux it's called

00:01:04,000 --> 00:01:10,320
the kernel mod setting

00:01:06,000 --> 00:01:13,680
it's part of drm

00:01:10,320 --> 00:01:16,640
so i've been working uh in

00:01:13,680 --> 00:01:17,360
uh the wayland ecosystem for a few years

00:01:16,640 --> 00:01:19,439
um

00:01:17,360 --> 00:01:20,640
i'm the island maintainer also

00:01:19,439 --> 00:01:23,920
maintainer of sway

00:01:20,640 --> 00:01:25,439
double roots western uh so

00:01:23,920 --> 00:01:28,080
yeah i've been working with kms for a

00:01:25,439 --> 00:01:30,320
while and um i wanted to share that with

00:01:28,080 --> 00:01:30,320
you

00:01:30,400 --> 00:01:37,119
so let's maybe start with

00:01:34,079 --> 00:01:40,799
uh what is kms

00:01:37,119 --> 00:01:43,360
uh so basically when

00:01:40,799 --> 00:01:44,560
an app wants to get something displayed

00:01:43,360 --> 00:01:46,960
on screen

00:01:44,560 --> 00:01:48,560
a regular app doesn't directly talk to

00:01:46,960 --> 00:01:51,600
the kernel

00:01:48,560 --> 00:01:54,799
a regular apps first talk to a

00:01:51,600 --> 00:01:57,840
compositor a display server so

00:01:54,799 --> 00:02:02,159
for instance if i have a

00:01:57,840 --> 00:02:04,560
terminal application um it

00:02:02,159 --> 00:02:05,280
renders an image and then it hands over

00:02:04,560 --> 00:02:08,560
the image

00:02:05,280 --> 00:02:10,720
to x11 or vlan

00:02:08,560 --> 00:02:12,400
and then the compositor is responsible

00:02:10,720 --> 00:02:15,120
for

00:02:12,400 --> 00:02:17,520
taking images from multiple clients

00:02:15,120 --> 00:02:19,280
blending them together in a single image

00:02:17,520 --> 00:02:22,319
and then the compositor talks to the

00:02:19,280 --> 00:02:24,879
kernel um

00:02:22,319 --> 00:02:25,440
so yeah that's the interface between the

00:02:24,879 --> 00:02:27,040
kernel

00:02:25,440 --> 00:02:29,599
and the compositor that we're going to

00:02:27,040 --> 00:02:29,599
talk about

00:02:30,879 --> 00:02:38,400
um so the compositor here is

00:02:35,280 --> 00:02:42,400
a user space it's running in user space

00:02:38,400 --> 00:02:47,840
and it will hand over images

00:02:42,400 --> 00:02:51,680
to the kernel via the kms api

00:02:47,840 --> 00:02:54,319
kms has a common code but also has a

00:02:51,680 --> 00:02:57,760
driver specific code

00:02:54,319 --> 00:03:02,480
so for instance the i915 driver

00:02:57,760 --> 00:03:05,360
will drive gpus produced by intro

00:03:02,480 --> 00:03:07,040
but also drivers for other vendors uh

00:03:05,360 --> 00:03:09,519
amd gpu for amd

00:03:07,040 --> 00:03:11,280
and so on and so forth and the driver

00:03:09,519 --> 00:03:14,480
will be able to directly

00:03:11,280 --> 00:03:14,480
program the hardware

00:03:14,720 --> 00:03:22,480
so what's nice about kms is

00:03:18,000 --> 00:03:24,799
that it's a unified interface

00:03:22,480 --> 00:03:27,120
so you don't need to write driver

00:03:24,799 --> 00:03:31,760
specific code basically

00:03:27,120 --> 00:03:36,000
you can write code that works on any gpu

00:03:31,760 --> 00:03:36,000
and you also at get very

00:03:36,080 --> 00:03:43,440
low level control and the gpu

00:03:39,599 --> 00:03:45,840
so you if you want to do

00:03:43,440 --> 00:03:46,799
to to to have a lot of control and to be

00:03:45,840 --> 00:03:50,239
able to take

00:03:46,799 --> 00:03:51,920
most of your gpu that's the that's how

00:03:50,239 --> 00:03:55,280
you can do it

00:03:51,920 --> 00:03:57,439
so yeah why use kms

00:03:55,280 --> 00:03:58,319
uh the first thing i'd like to say is

00:03:57,439 --> 00:04:00,480
that don't

00:03:58,319 --> 00:04:03,040
because when you're writing a simple app

00:04:00,480 --> 00:04:04,879
you you don't really need to use kms

00:04:03,040 --> 00:04:07,200
uh if you're writing calculator app a

00:04:04,879 --> 00:04:07,920
thumbnail up uh video player you don't

00:04:07,200 --> 00:04:10,159
really need to

00:04:07,920 --> 00:04:11,200
talk to kms you need to talk to wayland

00:04:10,159 --> 00:04:14,480
or x11

00:04:11,200 --> 00:04:17,759
and that way the composition

00:04:14,480 --> 00:04:20,799
that can do the work for you uh

00:04:17,759 --> 00:04:23,919
but there are a few uh use cases where

00:04:20,799 --> 00:04:26,720
uh talking directly to kms uh

00:04:23,919 --> 00:04:26,720
is desirable

00:04:27,280 --> 00:04:31,759
so the niche use cases i'm talking about

00:04:31,280 --> 00:04:34,479
here

00:04:31,759 --> 00:04:35,919
is uh when you want to have a program

00:04:34,479 --> 00:04:39,040
which has

00:04:35,919 --> 00:04:41,680
exclusive access to output devices so

00:04:39,040 --> 00:04:43,470
on screen you only only see this

00:04:41,680 --> 00:04:44,639
particular program

00:04:43,470 --> 00:04:47,919
[Music]

00:04:44,639 --> 00:04:51,680
and you really need a low level control

00:04:47,919 --> 00:04:54,960
over the gpu so for instance

00:04:51,680 --> 00:04:58,560
if you want to take care of

00:04:54,960 --> 00:05:01,600
optimizations for to display a video

00:04:58,560 --> 00:05:04,720
or something like that then

00:05:01,600 --> 00:05:06,960
you can do it with kms so

00:05:04,720 --> 00:05:07,759
kms users typically include display

00:05:06,960 --> 00:05:11,199
servers

00:05:07,759 --> 00:05:14,560
so i've already talked about x11

00:05:11,199 --> 00:05:14,560
and wylan compositors

00:05:15,520 --> 00:05:18,560
but there are also a few other users

00:05:18,000 --> 00:05:22,960
like

00:05:18,560 --> 00:05:25,199
media players and some so for instance

00:05:22,960 --> 00:05:27,120
i don't know if you know about cody but

00:05:25,199 --> 00:05:30,320
um

00:05:27,120 --> 00:05:33,919
cody has a kms uh backend

00:05:30,320 --> 00:05:36,639
so if you want to have to

00:05:33,919 --> 00:05:38,080
in in your home other media center you

00:05:36,639 --> 00:05:40,639
can directly run kodi

00:05:38,080 --> 00:05:42,880
without any x11 stuff or well-known

00:05:40,639 --> 00:05:42,880
stuff

00:05:43,120 --> 00:05:46,320
also some embedded use cases so if you

00:05:44,960 --> 00:05:48,080
want to have a raspberry pi

00:05:46,320 --> 00:05:50,080
which displays i don't know the weather

00:05:48,080 --> 00:05:52,320
or something you could use kms to do

00:05:50,080 --> 00:05:52,320
this

00:05:53,039 --> 00:05:56,560
also for virtual reality and extended

00:05:55,840 --> 00:06:00,080
reality

00:05:56,560 --> 00:06:04,960
kms is often used because

00:06:00,080 --> 00:06:04,960
their latency is very important so

00:06:05,120 --> 00:06:10,639
the games and the vr applications

00:06:08,800 --> 00:06:12,000
typically want to reduce latency to

00:06:10,639 --> 00:06:14,319
minimum and want

00:06:12,000 --> 00:06:15,360
to remove the compositor from the

00:06:14,319 --> 00:06:21,840
equation

00:06:15,360 --> 00:06:21,840
and have as low level access as possible

00:06:24,080 --> 00:06:29,280
um yeah so

00:06:27,199 --> 00:06:30,560
what should you why should you learn

00:06:29,280 --> 00:06:33,120
about kms

00:06:30,560 --> 00:06:34,000
so the reason i personally learned about

00:06:33,120 --> 00:06:37,039
kms is that

00:06:34,000 --> 00:06:39,680
i was i was

00:06:37,039 --> 00:06:42,080
interested in learning how it works

00:06:39,680 --> 00:06:44,479
under the hood

00:06:42,080 --> 00:06:45,840
but it's also useful to contribute to

00:06:44,479 --> 00:06:47,360
existing projects

00:06:45,840 --> 00:06:49,520
for instance if you want to contribute

00:06:47,360 --> 00:06:52,639
to alan compositor or to cody

00:06:49,520 --> 00:06:55,840
i don't know anything like this

00:06:52,639 --> 00:06:58,639
and if you need to write a new program

00:06:55,840 --> 00:07:00,000
described in the use cases i just talked

00:06:58,639 --> 00:07:02,479
about before

00:07:00,000 --> 00:07:04,720
then you can you also need to learn

00:07:02,479 --> 00:07:09,280
about kms

00:07:04,720 --> 00:07:09,919
so here i'm doing this presentation here

00:07:09,280 --> 00:07:13,120
because

00:07:09,919 --> 00:07:15,440
um there are some docs

00:07:13,120 --> 00:07:16,240
some good documentation about kms but

00:07:15,440 --> 00:07:19,440
it's mostly

00:07:16,240 --> 00:07:22,960
for drivers so

00:07:19,440 --> 00:07:25,840
typically a gpu vendors who want to

00:07:22,960 --> 00:07:27,599
to write a linux kernel driver for their

00:07:25,840 --> 00:07:30,319
gpu

00:07:27,599 --> 00:07:31,440
they need to learn about kms so there

00:07:30,319 --> 00:07:35,120
are docs for this

00:07:31,440 --> 00:07:38,160
but it's not really um

00:07:35,120 --> 00:07:41,199
very it's not a good way to

00:07:38,160 --> 00:07:45,520
to to learn the user interface as a

00:07:41,199 --> 00:07:48,879
user space api basically

00:07:45,520 --> 00:07:52,560
because uh the the ducks

00:07:48,879 --> 00:07:54,400
uh describe a lot of internal kernel

00:07:52,560 --> 00:07:55,840
functions and stuff like this so it's

00:07:54,400 --> 00:07:58,400
pretty confusing

00:07:55,840 --> 00:07:59,919
so kms lacks some talks i'm trying to

00:07:58,400 --> 00:08:02,720
fix this

00:07:59,919 --> 00:08:04,560
but yeah that's the rule point of this

00:08:02,720 --> 00:08:07,199
talk basically

00:08:04,560 --> 00:08:08,160
and very few people know about kms and

00:08:07,199 --> 00:08:10,080
how it works

00:08:08,160 --> 00:08:12,160
how the even driver developers don't

00:08:10,080 --> 00:08:14,960
know how the user space api

00:08:12,160 --> 00:08:18,000
works so i think it's very important to

00:08:14,960 --> 00:08:21,280
get more people on board

00:08:18,000 --> 00:08:22,800
so yeah let's get started how do we get

00:08:21,280 --> 00:08:26,560
an image on screen

00:08:22,800 --> 00:08:29,199
so we'll try to display a red

00:08:26,560 --> 00:08:31,680
image a solid red image on screen with

00:08:29,199 --> 00:08:31,680
kms

00:08:32,240 --> 00:08:38,479
i won't care a lot about legacy apis

00:08:36,479 --> 00:08:39,680
there are some legacy apis in kms

00:08:38,479 --> 00:08:43,120
because

00:08:39,680 --> 00:08:46,640
it wasn't perfect from day one so

00:08:43,120 --> 00:08:49,200
there's some historical baggage

00:08:46,640 --> 00:08:49,920
we're gonna skip all that and just use

00:08:49,200 --> 00:08:53,839
the latest

00:08:49,920 --> 00:08:54,640
stuff so that means it suddenly works on

00:08:53,839 --> 00:08:58,000
mostly

00:08:54,640 --> 00:08:59,839
recent gpus so in practice an intel it

00:08:58,000 --> 00:09:02,880
works well

00:08:59,839 --> 00:09:04,800
and amd you need a recent

00:09:02,880 --> 00:09:06,000
if you have an old amd card it won't

00:09:04,800 --> 00:09:10,000
support the

00:09:06,000 --> 00:09:12,399
new apis but if you have

00:09:10,000 --> 00:09:14,640
something but not not so old it will be

00:09:12,399 --> 00:09:14,640
high

00:09:15,680 --> 00:09:21,200
so yeah let's start with opening the gpu

00:09:19,519 --> 00:09:22,080
so opening the gpu is the first thing

00:09:21,200 --> 00:09:24,000
you need to do

00:09:22,080 --> 00:09:25,920
and it's pretty simple it's basically

00:09:24,000 --> 00:09:29,600
just

00:09:25,920 --> 00:09:30,000
the open syscall we'll open a file

00:09:29,600 --> 00:09:34,240
called

00:09:30,000 --> 00:09:36,560
slash dev dri slash card 0.

00:09:34,240 --> 00:09:37,920
if you have multiple gpus you will have

00:09:36,560 --> 00:09:40,000
multiple levels

00:09:37,920 --> 00:09:41,360
so card one card two and so on and so

00:09:40,000 --> 00:09:43,279
forth

00:09:41,360 --> 00:09:44,959
and there you have it you have a file

00:09:43,279 --> 00:09:48,959
descriptor

00:09:44,959 --> 00:09:52,080
with um so primary node we call this

00:09:48,959 --> 00:09:54,399
primary node and you you'll be able to

00:09:52,080 --> 00:09:56,800
control the gpu with this file

00:09:54,399 --> 00:09:59,600
descriptor

00:09:56,800 --> 00:09:59,600
so in practice

00:10:00,640 --> 00:10:04,880
if you write a real kms application you

00:10:04,480 --> 00:10:07,279
maybe

00:10:04,880 --> 00:10:10,399
want to list the devices with few days

00:10:07,279 --> 00:10:13,839
leave you there for something

00:10:10,399 --> 00:10:17,680
in our slides i don't i leave

00:10:13,839 --> 00:10:20,399
error handling out of the way

00:10:17,680 --> 00:10:20,880
so that's something you'll need to care

00:10:20,399 --> 00:10:24,800
about

00:10:20,880 --> 00:10:27,519
when if you write a real client as well

00:10:24,800 --> 00:10:28,560
so the first thing you'll want to do

00:10:27,519 --> 00:10:32,079
with the

00:10:28,560 --> 00:10:33,040
drm file descriptor is to get a list of

00:10:32,079 --> 00:10:38,880
resources

00:10:33,040 --> 00:10:42,079
drm exposes multiple different resources

00:10:38,880 --> 00:10:44,640
um so here we can see that

00:10:42,079 --> 00:10:46,640
there are different types of resources

00:10:44,640 --> 00:10:51,200
fbs are from buffers

00:10:46,640 --> 00:10:54,399
crtc's connectors encoders

00:10:51,200 --> 00:10:58,720
so all of these have a ways

00:10:54,399 --> 00:11:02,880
of using 32 items

00:10:58,720 --> 00:11:06,000
these are object ids so kms exposes

00:11:02,880 --> 00:11:09,200
um objects with ids and each id

00:11:06,000 --> 00:11:10,800
each object has a type um so yeah

00:11:09,200 --> 00:11:12,560
primer first here this isn't sent so

00:11:10,800 --> 00:11:15,200
forth

00:11:12,560 --> 00:11:16,079
so i'll do a little demo here a friend

00:11:15,200 --> 00:11:19,360
of mine

00:11:16,079 --> 00:11:22,480
what a little call a tool called the drm

00:11:19,360 --> 00:11:25,839
info which just

00:11:22,480 --> 00:11:28,640
lists everything it can

00:11:25,839 --> 00:11:31,920
it can display about kms so there's

00:11:28,640 --> 00:11:31,920
quite a lot of information

00:11:34,000 --> 00:11:37,760
but we can see that we have a bunch of

00:11:36,399 --> 00:11:40,839
connectors here

00:11:37,760 --> 00:11:43,120
and each connector has a lot of

00:11:40,839 --> 00:11:45,920
properties

00:11:43,120 --> 00:11:46,640
i have two connectors three connectors

00:11:45,920 --> 00:11:49,200
four connect

00:11:46,640 --> 00:11:49,839
yeah five connectors total there's a

00:11:49,200 --> 00:11:53,040
bunch of

00:11:49,839 --> 00:11:56,639
encoders crtc's with

00:11:53,040 --> 00:11:58,800
each object ids and properties

00:11:56,639 --> 00:12:01,519
and other stuff as well we'll see about

00:11:58,800 --> 00:12:03,839
that in a moment

00:12:01,519 --> 00:12:06,000
so once we have this object ids we want

00:12:03,839 --> 00:12:06,000
to

00:12:06,560 --> 00:12:11,279
get more information about the objects

00:12:09,519 --> 00:12:14,320
because an id

00:12:11,279 --> 00:12:17,920
is just an id we don't care that

00:12:14,320 --> 00:12:19,279
about the id that much um so

00:12:17,920 --> 00:12:20,959
let's start with connectors so

00:12:19,279 --> 00:12:22,720
connectors are just

00:12:20,959 --> 00:12:24,880
physical connectors on the back of your

00:12:22,720 --> 00:12:26,560
gpu so

00:12:24,880 --> 00:12:28,320
some types of connectors you might be

00:12:26,560 --> 00:12:31,360
familiar with are

00:12:28,320 --> 00:12:34,560
displayport hdmi vga

00:12:31,360 --> 00:12:34,560
usbc nowadays

00:12:34,800 --> 00:12:41,680
so yeah that's pretty straightforward

00:12:38,480 --> 00:12:44,000
um so once you

00:12:41,680 --> 00:12:46,079
have a connector id you can use the

00:12:44,000 --> 00:12:48,800
diamond get connector function to get

00:12:46,079 --> 00:12:51,200
the armored connector object and it has

00:12:48,800 --> 00:12:56,000
a bunch of

00:12:51,200 --> 00:12:57,920
fields uh it has a connector type

00:12:56,000 --> 00:13:00,320
which i just talked about it can be

00:12:57,920 --> 00:13:02,800
displayport hdmi and so on

00:13:00,320 --> 00:13:03,680
um there's also a field called

00:13:02,800 --> 00:13:06,240
connection

00:13:03,680 --> 00:13:06,959
which says whether something is plugged

00:13:06,240 --> 00:13:10,000
into the

00:13:06,959 --> 00:13:10,000
connector or not

00:13:10,240 --> 00:13:13,040
we can use this

00:13:13,360 --> 00:13:16,880
you can also have a bunch of stuff like

00:13:15,920 --> 00:13:21,839
the

00:13:16,880 --> 00:13:21,839
size of the screen in millimeters

00:13:22,320 --> 00:13:26,560
so typically

00:13:27,760 --> 00:13:31,680
you could you could think that

00:13:32,720 --> 00:13:35,839
the list of connectors on your computers

00:13:35,120 --> 00:13:38,240
uh

00:13:35,839 --> 00:13:38,880
is a fixed list and doesn't change at

00:13:38,240 --> 00:13:40,880
one time

00:13:38,880 --> 00:13:42,720
but the well nowadays that's not the

00:13:40,880 --> 00:13:43,279
case anymore because you have things

00:13:42,720 --> 00:13:46,839
like

00:13:43,279 --> 00:13:49,920
usbc docs uh with where your

00:13:46,839 --> 00:13:51,440
plugin usbc connector and then you can

00:13:49,920 --> 00:13:54,160
have multiple

00:13:51,440 --> 00:13:55,680
display ports or hdmi connectors at the

00:13:54,160 --> 00:13:59,040
back of the hub

00:13:55,680 --> 00:14:02,320
so the list of connectors

00:13:59,040 --> 00:14:03,760
can change at one time pretty fun to

00:14:02,320 --> 00:14:06,959
handle

00:14:03,760 --> 00:14:11,120
in in code each connector

00:14:06,959 --> 00:14:16,079
has a list of modes it supports

00:14:11,120 --> 00:14:19,279
if a screen is is plugged in

00:14:16,079 --> 00:14:23,199
mods are basically a a resolution and

00:14:19,279 --> 00:14:27,760
a refresh height each screen

00:14:23,199 --> 00:14:29,519
has a fixed set of supported modes

00:14:27,760 --> 00:14:31,839
so far let's take an example for

00:14:29,519 --> 00:14:36,160
instance on my gpu

00:14:31,839 --> 00:14:38,399
i have a displayport connector here

00:14:36,160 --> 00:14:40,480
which is connected to a screen you can

00:14:38,399 --> 00:14:42,959
see the size in millimeters

00:14:40,480 --> 00:14:44,399
and here we can see that i have a lot of

00:14:42,959 --> 00:14:46,880
modes here it's

00:14:44,399 --> 00:14:51,079
my connector supports a lot of mods so

00:14:46,880 --> 00:14:55,600
4k modes but it can go back to

00:14:51,079 --> 00:14:58,880
720p if i want

00:14:55,600 --> 00:15:00,160
so i can pick any of this and there's a

00:14:58,880 --> 00:15:03,440
refresh right here

00:15:00,160 --> 00:15:06,240
in hertz so it's

00:15:03,440 --> 00:15:07,920
it's pretty important to to to say that

00:15:06,240 --> 00:15:12,079
refresh rate is fixed

00:15:07,920 --> 00:15:14,639
and cannot be changed

00:15:12,079 --> 00:15:15,920
also if you want to switch from one mode

00:15:14,639 --> 00:15:18,720
to another screen

00:15:15,920 --> 00:15:20,079
you'll probably get a black screen

00:15:18,720 --> 00:15:24,000
during a few seconds

00:15:20,079 --> 00:15:28,320
during the mod set operation

00:15:24,000 --> 00:15:30,320
so you don't want to do that a lot

00:15:28,320 --> 00:15:32,880
because that's not very good user

00:15:30,320 --> 00:15:32,880
experience

00:15:32,959 --> 00:15:41,040
um so let's see

00:15:36,240 --> 00:15:41,600
if i can write a little kms client that

00:15:41,040 --> 00:15:44,399
just

00:15:41,600 --> 00:15:46,959
lists uh all the mods supported by my

00:15:44,399 --> 00:15:50,320
connectors

00:15:46,959 --> 00:15:52,240
so i can get a use

00:15:50,320 --> 00:15:54,079
drm.get connector function i talked

00:15:52,240 --> 00:15:56,320
about earlier

00:15:54,079 --> 00:15:57,279
then check if the connection is

00:15:56,320 --> 00:16:00,480
connected

00:15:57,279 --> 00:16:04,320
if something is plugged to the connector

00:16:00,480 --> 00:16:07,680
and once i know that

00:16:04,320 --> 00:16:10,959
i can print uh

00:16:07,680 --> 00:16:13,120
the list of modes um iterate

00:16:10,959 --> 00:16:14,160
the list of modes here and just print

00:16:13,120 --> 00:16:18,079
the edge display

00:16:14,160 --> 00:16:21,199
v display and we will v refresh

00:16:18,079 --> 00:16:21,199
and that's about it

00:16:21,279 --> 00:16:23,839
so

00:16:25,600 --> 00:16:32,079
i'm maybe gonna show you

00:16:28,720 --> 00:16:33,680
the final code here uh so

00:16:32,079 --> 00:16:36,079
you'll be able to find the code in a git

00:16:33,680 --> 00:16:39,759
repository at the end of the talk

00:16:36,079 --> 00:16:41,839
but that's basically the

00:16:39,759 --> 00:16:43,759
code on the slide in a file and i

00:16:41,839 --> 00:16:48,320
compiled it

00:16:43,759 --> 00:16:50,720
and if i run it you can see that

00:16:48,320 --> 00:16:51,440
for the connect for this connector i

00:16:50,720 --> 00:16:55,440
have

00:16:51,440 --> 00:16:58,480
the list of modes that drm info

00:16:55,440 --> 00:16:58,480
printed earlier

00:16:58,800 --> 00:17:03,040
so yeah we got a list of mods cool

00:17:03,199 --> 00:17:06,400
so now that we have a list of modes

00:17:05,439 --> 00:17:08,319
let's talk about

00:17:06,400 --> 00:17:10,720
frame buffers frame buffers are

00:17:08,319 --> 00:17:11,439
basically how we're going to display

00:17:10,720 --> 00:17:13,360
something

00:17:11,439 --> 00:17:16,000
on screen and it's a slice of memory

00:17:13,360 --> 00:17:19,679
containing pixels

00:17:16,000 --> 00:17:23,199
so frame before i have an object ids

00:17:19,679 --> 00:17:25,679
an object id um they also have a width

00:17:23,199 --> 00:17:29,280
and a height

00:17:25,679 --> 00:17:32,880
um this pitch here it's also

00:17:29,280 --> 00:17:36,080
sometimes called the the stride

00:17:32,880 --> 00:17:39,120
it's the number of bytes in each

00:17:36,080 --> 00:17:39,120
row of pixel

00:17:39,200 --> 00:17:45,440
and there are some other stuff

00:17:42,240 --> 00:17:46,240
so like dev we don't care a lot about it

00:17:45,440 --> 00:17:50,960
but

00:17:46,240 --> 00:17:53,520
bpp is the bits per pixel

00:17:50,960 --> 00:17:54,080
number of bits for each pixel there's

00:17:53,520 --> 00:17:57,520
also

00:17:54,080 --> 00:17:57,520
a handle

00:17:58,240 --> 00:18:03,840
for each fb frame buffer

00:18:01,679 --> 00:18:05,520
so the handle is a driver specific

00:18:03,840 --> 00:18:08,559
handle and

00:18:05,520 --> 00:18:11,360
it's separate from the frame buffer id

00:18:08,559 --> 00:18:12,960
and it will be used to import a frame

00:18:11,360 --> 00:18:16,400
buffer into kms

00:18:12,960 --> 00:18:20,080
because kms can't uh directly

00:18:16,400 --> 00:18:22,240
um allocate buffers and

00:18:20,080 --> 00:18:23,120
or anything like that we're going to use

00:18:22,240 --> 00:18:25,200
something else

00:18:23,120 --> 00:18:28,480
and then import the frame buffer into

00:18:25,200 --> 00:18:30,400
kms get the frame buffer id

00:18:28,480 --> 00:18:33,039
to import it yeah we're going to use

00:18:30,400 --> 00:18:33,039
this handle

00:18:33,200 --> 00:18:36,559
so frameworks

00:18:37,840 --> 00:18:42,799
they also have formats and the format

00:18:41,360 --> 00:18:44,960
describes how pixels are

00:18:42,799 --> 00:18:47,120
laid out in the buffer so there are a

00:18:44,960 --> 00:18:52,640
bunch of different formats

00:18:47,120 --> 00:18:52,640
the list can be found in drm4cc.h

00:18:52,799 --> 00:19:00,000
some very commonly supported formats are

00:18:55,720 --> 00:19:03,120
xrgb8888 and aagb8888

00:19:00,000 --> 00:19:04,080
so what does this mean basically how to

00:19:03,120 --> 00:19:06,960
interpret this

00:19:04,080 --> 00:19:06,960
drm format

00:19:08,080 --> 00:19:12,559
so let's take for example the color one

00:19:11,280 --> 00:19:16,160
one two two three three

00:19:12,559 --> 00:19:17,280
so the wet component set to uh eleven in

00:19:16,160 --> 00:19:20,000
x

00:19:17,280 --> 00:19:21,039
j component two two two and b component

00:19:20,000 --> 00:19:23,600
to free free

00:19:21,039 --> 00:19:24,720
and then alpha component set to

00:19:23,600 --> 00:19:28,160
completely opaque

00:19:24,720 --> 00:19:30,160
so ff then

00:19:28,160 --> 00:19:31,280
how do we express this color in these

00:19:30,160 --> 00:19:33,440
two formats

00:19:31,280 --> 00:19:33,440
so

00:19:34,640 --> 00:19:42,720
so yeah let's start with argb8888

00:19:39,440 --> 00:19:43,679
um the so the the first part here

00:19:42,720 --> 00:19:47,520
describes

00:19:43,679 --> 00:19:50,080
uh the order in which uh the

00:19:47,520 --> 00:19:50,559
components are laid out in memory and

00:19:50,080 --> 00:19:53,039
then

00:19:50,559 --> 00:19:55,200
the second part here with the 888

00:19:53,039 --> 00:19:55,520
describes how many bits per components

00:19:55,200 --> 00:19:58,960
there

00:19:55,520 --> 00:20:01,360
are so here

00:19:58,960 --> 00:20:02,960
we start with the a components so alpha

00:20:01,360 --> 00:20:06,640
components

00:20:02,960 --> 00:20:09,679
with eight bytes bits sorry

00:20:06,640 --> 00:20:10,640
then the red component with 8 bytes j

00:20:09,679 --> 00:20:12,880
components

00:20:10,640 --> 00:20:14,320
with 8 bytes and b components with 8

00:20:12,880 --> 00:20:18,799
bytes

00:20:14,320 --> 00:20:18,799
but you may notice that in

00:20:18,840 --> 00:20:26,080
the bites i want here

00:20:21,840 --> 00:20:27,520
the a is at the end here

00:20:26,080 --> 00:20:29,760
that's because there's a little good

00:20:27,520 --> 00:20:29,760
show

00:20:29,840 --> 00:20:34,799
drm formats are expressed in little

00:20:34,080 --> 00:20:38,000
indian

00:20:34,799 --> 00:20:38,200
so you basically need to read them back

00:20:38,000 --> 00:20:39,600
here

00:20:38,200 --> 00:20:42,880
[Music]

00:20:39,600 --> 00:20:45,520
to store the byte in memory so you need

00:20:42,880 --> 00:20:48,799
to start with b

00:20:45,520 --> 00:20:52,480
b is free free and then j to 2

00:20:48,799 --> 00:20:54,320
and then r 1 1 and then a f f

00:20:52,480 --> 00:20:55,919
so yeah you need to be a little bit

00:20:54,320 --> 00:20:59,679
careful about this and

00:20:55,919 --> 00:21:02,720
also other formats like opengl formats

00:20:59,679 --> 00:21:05,840
are in big ndm so you need to yeah

00:21:02,720 --> 00:21:07,840
have a mapping table which takes care of

00:21:05,840 --> 00:21:10,320
the

00:21:07,840 --> 00:21:12,799
mapping from dm formats to opengl

00:21:10,320 --> 00:21:12,799
formats

00:21:14,320 --> 00:21:17,440
so these are pretty simple formats

00:21:16,080 --> 00:21:19,760
there's another example

00:21:17,440 --> 00:21:22,159
um there are also some more complicated

00:21:19,760 --> 00:21:25,600
formats for instance xrjb

00:21:22,159 --> 00:21:29,039
2 1 2 10 10 10. so x-men

00:21:25,600 --> 00:21:31,360
means some bytes are not used so

00:21:29,039 --> 00:21:32,640
here i have two bytes at the beginning

00:21:31,360 --> 00:21:36,240
that are not used

00:21:32,640 --> 00:21:40,159
then 10 by up sorry here i have

00:21:36,240 --> 00:21:43,600
two bits that are not used then uh

00:21:40,159 --> 00:21:46,320
10 bits for r and 10 bits for g and b

00:21:43,600 --> 00:21:47,039
j and b but also some more complicated

00:21:46,320 --> 00:21:50,240
formats

00:21:47,039 --> 00:21:50,720
y uv and multiplier formats but we're

00:21:50,240 --> 00:21:54,320
not

00:21:50,720 --> 00:21:57,679
going to talk about this yet

00:21:54,320 --> 00:21:59,919
okay so now i know about formats and i

00:21:57,679 --> 00:22:03,039
know about german formats so we're gonna

00:21:59,919 --> 00:22:05,280
see how to allocate a frame buffer so

00:22:03,039 --> 00:22:09,600
we're going to use something called the

00:22:05,280 --> 00:22:09,600
drm dumbbell frame buffers

00:22:10,080 --> 00:22:15,039
so to allocate a done buffer

00:22:13,679 --> 00:22:17,120
so done before i call this way because

00:22:15,039 --> 00:22:19,200
they are pretty simple

00:22:17,120 --> 00:22:21,280
pretty inefficient but pretty simple so

00:22:19,200 --> 00:22:24,320
we're going to start with that

00:22:21,280 --> 00:22:27,760
uh i'm going to perform manually

00:22:24,320 --> 00:22:31,280
a niocitable called

00:22:27,760 --> 00:22:34,880
create dump i'm gonna pass the

00:22:31,280 --> 00:22:38,080
width and the height of the

00:22:34,880 --> 00:22:41,200
frame buffer i want to create and also

00:22:38,080 --> 00:22:44,480
on the bits per pixel

00:22:41,200 --> 00:22:45,440
so if i want to use the dm format xrgb

00:22:44,480 --> 00:22:50,000
00:22:45,440 --> 00:22:50,000
the bits per pixel is 32.

00:22:50,080 --> 00:22:54,960
so once i've performed this iota i get

00:22:52,320 --> 00:22:56,799
back a handle a stride and a size

00:22:54,960 --> 00:22:58,799
i'm gonna use all of this information

00:22:56,799 --> 00:23:02,799
later and you can see that the handle

00:22:58,799 --> 00:23:06,320
here can be used to import

00:23:02,799 --> 00:23:09,200
the frame buffer into kms

00:23:06,320 --> 00:23:09,919
so yeah let's import talking about

00:23:09,200 --> 00:23:13,440
importing

00:23:09,919 --> 00:23:15,919
to kms this is done uh with the drm mode

00:23:13,440 --> 00:23:18,720
add fb2 function

00:23:15,919 --> 00:23:19,360
so it takes the drm file descriptor the

00:23:18,720 --> 00:23:22,480
width

00:23:19,360 --> 00:23:25,600
the height the format i want to use

00:23:22,480 --> 00:23:26,320
it also takes the handle the stride i i

00:23:25,600 --> 00:23:30,080
got back

00:23:26,320 --> 00:23:33,360
from the create them ioctl

00:23:30,080 --> 00:23:37,440
and that's all um it gives back

00:23:33,360 --> 00:23:40,880
a frame buffer id which channel will be

00:23:37,440 --> 00:23:44,400
i will be able to use this object uh

00:23:40,880 --> 00:23:45,840
later on um you configure the screen to

00:23:44,400 --> 00:23:50,159
display it

00:23:45,840 --> 00:23:52,799
so now i have allocated the frame buffer

00:23:50,159 --> 00:23:54,000
i have imported it into kms but the

00:23:52,799 --> 00:23:57,120
frame buffer is empty

00:23:54,000 --> 00:23:59,760
or has undefined contents so

00:23:57,120 --> 00:24:01,200
i need to write into the the frame

00:23:59,760 --> 00:24:04,320
buffer

00:24:01,200 --> 00:24:07,919
to paint everything in red so

00:24:04,320 --> 00:24:12,080
i'm going to use an ioc here

00:24:07,919 --> 00:24:12,080
called map dump

00:24:12,799 --> 00:24:19,760
so this is your ctl takes a handle

00:24:16,080 --> 00:24:20,320
and gives back uh an offset which can be

00:24:19,760 --> 00:24:23,840
used

00:24:20,320 --> 00:24:26,640
in a map call with the drm fd

00:24:23,840 --> 00:24:27,039
so yeah it's a lot of polar plates but

00:24:26,640 --> 00:24:30,320
the

00:24:27,039 --> 00:24:33,120
end result is that i get a data pointer

00:24:30,320 --> 00:24:34,720
so it's just a regular pointer i ch it's

00:24:33,120 --> 00:24:37,520
a slice of memory i can just

00:24:34,720 --> 00:24:39,840
write into like any other memory and

00:24:37,520 --> 00:24:43,279
just swipe pixels

00:24:39,840 --> 00:24:47,440
um and then they will be

00:24:43,279 --> 00:24:52,000
copied to the gpu automatically

00:24:47,440 --> 00:24:54,559
okay cool so

00:24:52,000 --> 00:24:55,360
i have now a frame before i can paint

00:24:54,559 --> 00:24:58,400
paint it

00:24:55,360 --> 00:25:01,039
in red by writing into the

00:24:58,400 --> 00:25:02,000
data pointer and i also have a frame

00:25:01,039 --> 00:25:05,120
buffer id

00:25:02,000 --> 00:25:07,760
uh i can use uh so

00:25:05,120 --> 00:25:10,400
how can i use this from before id to

00:25:07,760 --> 00:25:13,520
display something

00:25:10,400 --> 00:25:16,799
we are going to need to talk about a

00:25:13,520 --> 00:25:18,720
few more objects so

00:25:16,799 --> 00:25:20,080
we already talked about frame buffers

00:25:18,720 --> 00:25:23,679
and connectors

00:25:20,080 --> 00:25:28,400
we need to talk about planes and crtc's

00:25:23,679 --> 00:25:32,559
it's two other types of kms objects

00:25:28,400 --> 00:25:34,400
and basically the pixels will flow from

00:25:32,559 --> 00:25:37,279
the frame buffer to the plane

00:25:34,400 --> 00:25:38,559
then to the crtc then to the connector

00:25:37,279 --> 00:25:42,559
then to the

00:25:38,559 --> 00:25:45,919
actual screen

00:25:42,559 --> 00:25:47,520
so you might be wondering why do we have

00:25:45,919 --> 00:25:50,640
these two extra objects

00:25:47,520 --> 00:25:52,559
why can't be can it be more simple and

00:25:50,640 --> 00:25:56,640
why can't the pixels fall directly from

00:25:52,559 --> 00:26:01,840
the frame buffer to the connector

00:25:56,640 --> 00:26:01,840
so the reason why crtc's exists

00:26:03,120 --> 00:26:11,279
is that we have a feature called the

00:26:07,600 --> 00:26:11,760
clone screens um it's when you want to

00:26:11,279 --> 00:26:14,720
have

00:26:11,760 --> 00:26:15,919
the the the same image displaying on two

00:26:14,720 --> 00:26:17,919
different screens

00:26:15,919 --> 00:26:19,679
so for instance if you have a projector

00:26:17,919 --> 00:26:20,799
and you need to do a presentation about

00:26:19,679 --> 00:26:22,720
kms

00:26:20,799 --> 00:26:24,240
then you maybe want to have the same

00:26:22,720 --> 00:26:28,080
image on your laptop

00:26:24,240 --> 00:26:31,760
and the projector so

00:26:28,080 --> 00:26:34,000
maybe yeah

00:26:31,760 --> 00:26:35,919
in some cases it's possible to use the

00:26:34,000 --> 00:26:37,600
same crtc connected to multiple

00:26:35,919 --> 00:26:39,360
connectors so the pixels from

00:26:37,600 --> 00:26:40,960
flow from the frame buffer to the plane

00:26:39,360 --> 00:26:42,880
and then the crtc

00:26:40,960 --> 00:26:45,279
and then the image is duplicated and

00:26:42,880 --> 00:26:47,120
both connectors

00:26:45,279 --> 00:26:48,960
so yeah two connectors right up to

00:26:47,120 --> 00:26:51,360
single crtc

00:26:48,960 --> 00:26:52,720
that's the reason why crtc's exist so

00:26:51,360 --> 00:26:56,400
crtc's

00:26:52,720 --> 00:26:59,279
their name don't pay too attention

00:26:56,400 --> 00:27:00,799
attention to it it comes from crt

00:26:59,279 --> 00:27:03,679
cathode way to con

00:27:00,799 --> 00:27:05,120
that catered away tube but the name is

00:27:03,679 --> 00:27:08,720
meaningless nowadays it's

00:27:05,120 --> 00:27:08,720
just there for historical reasons

00:27:10,159 --> 00:27:17,440
so now planes why do we have planes

00:27:14,080 --> 00:27:17,440
the reason we have planes is that

00:27:17,520 --> 00:27:21,679
some gpus can display multiple frame

00:27:20,559 --> 00:27:25,679
buffers

00:27:21,679 --> 00:27:28,399
on a single crtc

00:27:25,679 --> 00:27:29,120
for instance here i'm talking to you

00:27:28,399 --> 00:27:31,520
with

00:27:29,120 --> 00:27:34,320
the presentation in the background and a

00:27:31,520 --> 00:27:34,320
little camera

00:27:34,799 --> 00:27:40,720
so all of this uses one plane

00:27:37,919 --> 00:27:42,399
and my cursor which i move around here

00:27:40,720 --> 00:27:46,640
uses another plane called the

00:27:42,399 --> 00:27:48,399
cursor plane the primary plane for

00:27:46,640 --> 00:27:50,000
all my desktop and the cos appliance for

00:27:48,399 --> 00:27:53,200
just my cursor

00:27:50,000 --> 00:27:56,559
so this allows power savings and

00:27:53,200 --> 00:28:00,720
more efficient use of the gpu

00:27:56,559 --> 00:28:01,679
so yeah in my case here the compositor

00:28:00,720 --> 00:28:04,880
attaches

00:28:01,679 --> 00:28:07,840
both planes to a single crtc and

00:28:04,880 --> 00:28:10,320
both frame buffers are displayed at the

00:28:07,840 --> 00:28:10,320
same time

00:28:12,559 --> 00:28:20,960
so um

00:28:17,120 --> 00:28:24,240
maybe yeah we we can

00:28:20,960 --> 00:28:26,640
just like connectors we can get more

00:28:24,240 --> 00:28:29,360
information about crtc's with the dr

00:28:26,640 --> 00:28:32,960
modget crtc function which takes a

00:28:29,360 --> 00:28:36,720
an object id the crtc id and gives back

00:28:32,960 --> 00:28:40,320
this diamond crtc structure

00:28:36,720 --> 00:28:45,840
it has a bunch of information

00:28:40,320 --> 00:28:45,840
like the mode currently used on the crtc

00:28:46,240 --> 00:28:54,399
yeah we don't care about this a lot um

00:28:50,480 --> 00:28:55,440
planes planes also have a function to

00:28:54,399 --> 00:28:59,440
get

00:28:55,440 --> 00:29:02,000
but they work a little bit differently

00:28:59,440 --> 00:29:03,440
so the first thing we need to you to do

00:29:02,000 --> 00:29:06,960
to to use planes

00:29:03,440 --> 00:29:10,080
uh is to set a client capability

00:29:06,960 --> 00:29:11,360
uh universal planes it's just to say uh

00:29:10,080 --> 00:29:13,840
to kms

00:29:11,360 --> 00:29:15,360
hey i'm not a legacy client i support

00:29:13,840 --> 00:29:18,080
the the new apis

00:29:15,360 --> 00:29:19,039
so don't worry about me and then tell me

00:29:18,080 --> 00:29:22,640
kms will

00:29:19,039 --> 00:29:26,960
let us use other planes

00:29:22,640 --> 00:29:29,120
once we've done that um we can

00:29:26,960 --> 00:29:31,679
use the dm mode get planes resources

00:29:29,120 --> 00:29:35,360
function to get a list of planes

00:29:31,679 --> 00:29:37,520
uh we get a list of plane ids

00:29:35,360 --> 00:29:39,120
and then we can use the zr mod get plane

00:29:37,520 --> 00:29:42,720
function to get

00:29:39,120 --> 00:29:45,360
plane structs plane strokes also have a

00:29:42,720 --> 00:29:48,000
bunch of uh

00:29:45,360 --> 00:29:48,799
fields here uh the most interesting one

00:29:48,000 --> 00:29:52,000
is probably

00:29:48,799 --> 00:29:54,320
the formats array it describes

00:29:52,000 --> 00:29:55,600
all the drm formats supported by your

00:29:54,320 --> 00:29:58,799
plane

00:29:55,600 --> 00:29:58,799
so for example

00:30:01,919 --> 00:30:05,360
with the arm info i showed the list of

00:30:04,159 --> 00:30:09,200
connectors

00:30:05,360 --> 00:30:11,200
but we can see also the list of crtc's

00:30:09,200 --> 00:30:14,480
here

00:30:11,200 --> 00:30:17,600
uh and the list of planes uh

00:30:14,480 --> 00:30:19,520
so for instance here i have a plane with

00:30:17,600 --> 00:30:22,240
all of these formats supported so

00:30:19,520 --> 00:30:24,320
there's xlgb 8888 i

00:30:22,240 --> 00:30:26,559
talked about earlier but a bunch of

00:30:24,320 --> 00:30:29,840
different other formats as well

00:30:26,559 --> 00:30:33,600
uh yeah so you can use this tool

00:30:29,840 --> 00:30:36,320
trm info to list all capabilities

00:30:33,600 --> 00:30:39,039
on your gpu it's pretty handy when

00:30:36,320 --> 00:30:43,360
developing a drm application

00:30:39,039 --> 00:30:46,399
um so we've talked about a lot about

00:30:43,360 --> 00:30:51,159
reading some some fields here

00:30:46,399 --> 00:30:54,240
from the diamond plane dr mode connector

00:30:51,159 --> 00:30:57,200
grm.crtc structures

00:30:54,240 --> 00:30:58,880
but how do we change those so we are

00:30:57,200 --> 00:31:02,640
going to use something called

00:30:58,880 --> 00:31:06,640
object properties so as as i've said

00:31:02,640 --> 00:31:09,200
kms exposes objects

00:31:06,640 --> 00:31:11,440
which have an id a type but these

00:31:09,200 --> 00:31:14,640
objects also have properties

00:31:11,440 --> 00:31:19,840
um so we can list the properties with

00:31:14,640 --> 00:31:19,840
drm mode objective properties

00:31:20,799 --> 00:31:27,039
we just provide the object id

00:31:24,000 --> 00:31:28,640
and the object type and it gives a list

00:31:27,039 --> 00:31:31,679
of properties

00:31:28,640 --> 00:31:33,600
so property ids as always so

00:31:31,679 --> 00:31:34,880
yeah you can you can start to see a

00:31:33,600 --> 00:31:36,720
pattern here uh

00:31:34,880 --> 00:31:38,159
once you have a property id we can use

00:31:36,720 --> 00:31:42,720
drmodius property

00:31:38,159 --> 00:31:46,159
to get the property extract

00:31:42,720 --> 00:31:49,919
and yeah there's a lot of stuff in there

00:31:46,159 --> 00:31:53,279
the most interesting interesting uh

00:31:49,919 --> 00:31:57,039
field is probably the name because

00:31:53,279 --> 00:31:58,880
it's human readable so it's pretty handy

00:31:57,039 --> 00:32:00,240
we can see that properties also have

00:31:58,880 --> 00:32:04,559
values

00:32:00,240 --> 00:32:04,559
which are uint64

00:32:04,640 --> 00:32:09,840
items so

00:32:11,440 --> 00:32:16,320
here when if i go back to my to my plane

00:32:14,960 --> 00:32:20,240
here in the army form

00:32:16,320 --> 00:32:23,600
uh we can see a properties uh node

00:32:20,240 --> 00:32:26,320
with um a

00:32:23,600 --> 00:32:27,600
property named type which is set to

00:32:26,320 --> 00:32:30,720
primary

00:32:27,600 --> 00:32:32,200
a framework for id property also set to

00:32:30,720 --> 00:32:35,120
one of the

00:32:32,200 --> 00:32:38,480
127.

00:32:35,120 --> 00:32:41,519
so yeah basically what we want to do

00:32:38,480 --> 00:32:44,559
here i have a framework id i look i

00:32:41,519 --> 00:32:45,519
allocated earlier and i want to pick a

00:32:44,559 --> 00:32:48,880
plane

00:32:45,519 --> 00:32:51,919
set the frame of id property to the

00:32:48,880 --> 00:32:56,159
fb id i created earlier and then

00:32:51,919 --> 00:33:00,320
i'll be done basically

00:32:56,159 --> 00:33:03,440
so i'm gonna just uh write a little

00:33:00,320 --> 00:33:07,760
uh helper

00:33:03,440 --> 00:33:07,760
called gel get property value

00:33:08,720 --> 00:33:11,919
it will take an object id an object type

00:33:11,519 --> 00:33:15,200
and

00:33:11,919 --> 00:33:15,760
a human readable string for the property

00:33:15,200 --> 00:33:18,320
name

00:33:15,760 --> 00:33:19,760
and just iterate over the list of

00:33:18,320 --> 00:33:23,120
properties

00:33:19,760 --> 00:33:24,960
compare if the name matches the inputs

00:33:23,120 --> 00:33:26,799
and then just return the value if that's

00:33:24,960 --> 00:33:27,600
the case so that's just a little helper

00:33:26,799 --> 00:33:30,960
to

00:33:27,600 --> 00:33:36,840
get a property value from a name

00:33:30,960 --> 00:33:38,799
um and with that i'm going to be able

00:33:36,840 --> 00:33:40,960
to

00:33:38,799 --> 00:33:43,200
yeah so basically the function is just

00:33:40,960 --> 00:33:43,200
there

00:33:43,679 --> 00:33:50,320
to i i will so my end goal is

00:33:47,120 --> 00:33:52,559
to set the fbid property on a plane but

00:33:50,320 --> 00:33:55,760
i first need to select a

00:33:52,559 --> 00:34:00,480
crtc and a plane um i'm

00:33:55,760 --> 00:34:03,200
interested in so yeah

00:34:00,480 --> 00:34:05,679
well for simplicity we're just gonna

00:34:03,200 --> 00:34:07,039
pick the first crtc that is currently

00:34:05,679 --> 00:34:10,480
lighted up

00:34:07,039 --> 00:34:13,599
so we're gonna iterate our

00:34:10,480 --> 00:34:16,879
over all crtc's and

00:34:13,599 --> 00:34:19,839
check if mod valley is mod valid is true

00:34:16,879 --> 00:34:22,480
if that's the case we just pick this

00:34:19,839 --> 00:34:22,480
crtc

00:34:22,639 --> 00:34:27,919
uh so we're gonna use the mode currently

00:34:25,760 --> 00:34:31,040
set in the crtc

00:34:27,919 --> 00:34:33,040
so just logging it here for debug

00:34:31,040 --> 00:34:36,480
purposes

00:34:33,040 --> 00:34:39,760
and then we're just going to try to

00:34:36,480 --> 00:34:42,879
iterate over the list of planes

00:34:39,760 --> 00:34:46,079
get the plane object and

00:34:42,879 --> 00:34:49,359
read the property value for the tie and

00:34:46,079 --> 00:34:50,639
check if the type is primary and if it's

00:34:49,359 --> 00:34:53,679
a primary plane

00:34:50,639 --> 00:34:56,960
then i'm going to use this plane to set

00:34:53,679 --> 00:34:56,960
the frame buffer on it

00:34:57,839 --> 00:35:05,599
so if i just run this thing

00:35:02,400 --> 00:35:09,520
oh yeah

00:35:05,599 --> 00:35:09,520
i can type apparently okay

00:35:09,920 --> 00:35:16,960
i just picked a crtc 45

00:35:12,960 --> 00:35:20,000
on a plane 31 but i will be able to use

00:35:16,960 --> 00:35:23,599
to display my frame buffer

00:35:20,000 --> 00:35:24,480
so i should have now almost all the

00:35:23,599 --> 00:35:27,599
tools

00:35:24,480 --> 00:35:30,640
i need the only missing piece is

00:35:27,599 --> 00:35:32,800
how do i set the fbid property to change

00:35:30,640 --> 00:35:36,480
it to my

00:35:32,800 --> 00:35:38,800
fb id i allocated

00:35:36,480 --> 00:35:41,280
so i'm gonna use something called atomic

00:35:38,800 --> 00:35:41,280
commits

00:35:41,440 --> 00:35:47,359
but you might be wondering

00:35:44,880 --> 00:35:50,160
um how to make comments why is there

00:35:47,359 --> 00:35:52,960
atomic in there

00:35:50,160 --> 00:35:55,839
because i could that could just be a

00:35:52,960 --> 00:35:57,760
function that just sets the frame buffer

00:35:55,839 --> 00:35:59,599
to the one i want to the frame buffer i

00:35:57,760 --> 00:36:02,160
want and i'm done with that

00:35:59,599 --> 00:36:04,079
so actually that that's how the legacy

00:36:02,160 --> 00:36:07,839
api worked

00:36:04,079 --> 00:36:12,400
but it had a few issues uh for instance

00:36:07,839 --> 00:36:16,880
uh if i wanted to uh

00:36:12,400 --> 00:36:19,200
update the cursor plane so when when

00:36:16,880 --> 00:36:21,040
when i move the mouse sometimes it moves

00:36:19,200 --> 00:36:24,079
over um

00:36:21,040 --> 00:36:27,280
so it moves and it can change the

00:36:24,079 --> 00:36:30,400
the cursor icon also

00:36:27,280 --> 00:36:32,560
so the compositor may want to do both at

00:36:30,400 --> 00:36:37,280
the same time

00:36:32,560 --> 00:36:40,480
um so when using the legacy api

00:36:37,280 --> 00:36:42,800
there was a one request so one

00:36:40,480 --> 00:36:43,599
ioctl to set the cursor plane frame

00:36:42,800 --> 00:36:45,680
buffer

00:36:43,599 --> 00:36:47,520
and another request to move the cursor

00:36:45,680 --> 00:36:50,480
so the competitor will do

00:36:47,520 --> 00:36:51,119
one and then the other and the issue is

00:36:50,480 --> 00:36:54,560
that

00:36:51,119 --> 00:36:58,720
is that the monitor uh

00:36:54,560 --> 00:37:02,560
reads at a very fixed refresh rate uh

00:36:58,720 --> 00:37:05,839
the crtc image the crtc output

00:37:02,560 --> 00:37:07,599
so what might happen is that the

00:37:05,839 --> 00:37:09,920
compositor sets the cursor plane frame

00:37:07,599 --> 00:37:12,960
buffer then the monitor

00:37:09,920 --> 00:37:16,240
reads the image and then the compress

00:37:12,960 --> 00:37:20,079
the compositor moves the cursor and i

00:37:16,240 --> 00:37:23,280
end up in the situation where

00:37:20,079 --> 00:37:26,480
the cursor hasn't moved yet but has

00:37:23,280 --> 00:37:27,119
already changed the image so that might

00:37:26,480 --> 00:37:30,240
not be

00:37:27,119 --> 00:37:30,720
uh a big issue for cursors because it's

00:37:30,240 --> 00:37:33,359
not that

00:37:30,720 --> 00:37:34,640
important for cursors but uh as you

00:37:33,359 --> 00:37:38,960
could see there are a lot of

00:37:34,640 --> 00:37:41,119
over other object properties

00:37:38,960 --> 00:37:43,680
so if you want to change a lot of

00:37:41,119 --> 00:37:47,119
properties at once you might end up in

00:37:43,680 --> 00:37:51,119
a bad state a state

00:37:47,119 --> 00:37:53,359
where something uh

00:37:51,119 --> 00:37:54,720
part of the image is new and part of the

00:37:53,359 --> 00:38:00,160
image is

00:37:54,720 --> 00:38:00,160
the previous image so that's not great

00:38:00,400 --> 00:38:07,040
another issue with legacy apis so

00:38:04,400 --> 00:38:07,599
having two requests multiple requests to

00:38:07,040 --> 00:38:10,400
change

00:38:07,599 --> 00:38:10,400
each property

00:38:10,640 --> 00:38:18,000
is that sometimes the

00:38:14,160 --> 00:38:19,280
kms can say the gpu is not capable of

00:38:18,000 --> 00:38:22,400
doing something

00:38:19,280 --> 00:38:22,880
so for instance if i set the plane frame

00:38:22,400 --> 00:38:26,480
buffer

00:38:22,880 --> 00:38:28,320
kms might say okay that's fine

00:38:26,480 --> 00:38:29,760
and then after if i try to move the

00:38:28,320 --> 00:38:32,960
plane

00:38:29,760 --> 00:38:35,680
kms might say i can't do that

00:38:32,960 --> 00:38:37,599
and then if i'm in the position of the

00:38:35,680 --> 00:38:40,720
user space here

00:38:37,599 --> 00:38:42,320
it's a little tricky because i need to

00:38:40,720 --> 00:38:45,119
fall back

00:38:42,320 --> 00:38:46,000
i need to handle this quest gracefully

00:38:45,119 --> 00:38:49,280
um

00:38:46,000 --> 00:38:52,320
but already else i have

00:38:49,280 --> 00:38:55,359
already set half of the state and

00:38:52,320 --> 00:38:57,440
half of the states couldn't be set

00:38:55,359 --> 00:39:00,160
so i need to hold back the plane from

00:38:57,440 --> 00:39:02,240
buffer to the previous one and then

00:39:00,160 --> 00:39:03,680
try to do something else but that's

00:39:02,240 --> 00:39:05,599
pretty involved

00:39:03,680 --> 00:39:07,680
so when something goes wrong it's not

00:39:05,599 --> 00:39:09,599
easy to roll back to the previous

00:39:07,680 --> 00:39:13,440
configuration

00:39:09,599 --> 00:39:15,760
so atomic commits suffix this by

00:39:13,440 --> 00:39:17,040
providing a request to set multiple

00:39:15,760 --> 00:39:20,240
properties at once

00:39:17,040 --> 00:39:20,720
uh in an atomic fashion all at the same

00:39:20,240 --> 00:39:23,680
time

00:39:20,720 --> 00:39:25,520
so a request to set the plane frame

00:39:23,680 --> 00:39:26,320
buffer and move the plane at the same

00:39:25,520 --> 00:39:30,880
time

00:39:26,320 --> 00:39:35,359
and then this this fixes both issues

00:39:30,880 --> 00:39:35,359
i talked about just yeah just earlier

00:39:35,680 --> 00:39:42,000
so in practice atomic commits

00:39:38,720 --> 00:39:43,040
our list of properties to certain

00:39:42,000 --> 00:39:46,240
objects

00:39:43,040 --> 00:39:49,280
so i'll say on this object i want to set

00:39:46,240 --> 00:39:52,640
fbid to this value and

00:39:49,280 --> 00:39:52,640
i can add a bunch of these

00:39:52,880 --> 00:39:59,839
so how do i do that in codes

00:39:56,400 --> 00:40:03,119
the first thing i need to do is set the

00:39:59,839 --> 00:40:04,880
atomic client capability to say to the

00:40:03,119 --> 00:40:05,599
kernel hey i support the atomic

00:40:04,880 --> 00:40:11,839
interface

00:40:05,599 --> 00:40:11,839
not it for legacy things

00:40:14,640 --> 00:40:22,160
and then i'll allocate

00:40:17,839 --> 00:40:25,200
something called an atomic request

00:40:22,160 --> 00:40:28,640
and i'll be able to add multiple

00:40:25,200 --> 00:40:33,119
properties to this request

00:40:28,640 --> 00:40:36,319
for instance on object id for the plane

00:40:33,119 --> 00:40:37,440
i'll set the prop id for the fbid

00:40:36,319 --> 00:40:41,119
property

00:40:37,440 --> 00:40:45,680
to the fb id i allocated earlier

00:40:41,119 --> 00:40:48,960
and this will set the new fbi id

00:40:45,680 --> 00:40:49,440
i can do that a lot i can add a bunch of

00:40:48,960 --> 00:40:52,560
more

00:40:49,440 --> 00:40:54,560
bunch of properties and at the end when

00:40:52,560 --> 00:40:57,040
i'm done adding all the properties

00:40:54,560 --> 00:40:59,040
i'll submit everything at once with drm

00:40:57,040 --> 00:41:01,599
mode atomic commits

00:40:59,040 --> 00:41:04,240
which take the requests and a few flags

00:41:01,599 --> 00:41:07,839
we'll talk about this

00:41:04,240 --> 00:41:07,839
and that's about it

00:41:08,240 --> 00:41:13,280
okay we're almost done here uh i'm just

00:41:11,280 --> 00:41:17,119
going to write a little helper called

00:41:13,280 --> 00:41:19,520
alpopot add property which takes

00:41:17,119 --> 00:41:21,200
a request an object id an object type a

00:41:19,520 --> 00:41:24,160
property name as a string

00:41:21,200 --> 00:41:26,000
and a value so it works very similarly

00:41:24,160 --> 00:41:29,119
to get property value

00:41:26,000 --> 00:41:31,040
i described earlier it just iterates

00:41:29,119 --> 00:41:34,000
over all the properties

00:41:31,040 --> 00:41:35,119
finds the one that matches the name

00:41:34,000 --> 00:41:37,200
provided

00:41:35,119 --> 00:41:39,760
and then calls the mod atomic add

00:41:37,200 --> 00:41:42,960
property it adds uh

00:41:39,760 --> 00:41:47,119
the the property and the value to the

00:41:42,960 --> 00:41:47,119
atomic commit request

00:41:47,599 --> 00:41:49,839
okay

00:41:50,640 --> 00:41:57,119
so to display a buffer uh

00:41:53,680 --> 00:41:58,160
i've said i just need to set the fbid

00:41:57,119 --> 00:42:01,440
property

00:41:58,160 --> 00:42:04,880
but i lied a little we need to set

00:42:01,440 --> 00:42:08,079
a few other properties as well

00:42:04,880 --> 00:42:10,319
these other properties are crc

00:42:08,079 --> 00:42:12,480
so the source rectangle and the

00:42:10,319 --> 00:42:16,160
destination rectangle so the source

00:42:12,480 --> 00:42:19,599
rectangle is set with the four

00:42:16,160 --> 00:42:21,839
uh add pro particles here

00:42:19,599 --> 00:42:23,440
uh the source rectangle is used to crop

00:42:21,839 --> 00:42:26,720
a buffer so if you want to

00:42:23,440 --> 00:42:27,760
have a frame buffer and only display a

00:42:26,720 --> 00:42:30,319
subset of it

00:42:27,760 --> 00:42:32,400
you're going to set the source

00:42:30,319 --> 00:42:35,920
coordinates to

00:42:32,400 --> 00:42:36,960
something to to to a rectangle smaller

00:42:35,920 --> 00:42:39,359
than the full

00:42:36,960 --> 00:42:41,599
buffer but here i'm not interested in

00:42:39,359 --> 00:42:44,720
that so i'm going to just say

00:42:41,599 --> 00:42:47,200
x y to 0 and width height to the width

00:42:44,720 --> 00:42:52,079
and height of my frame buffer

00:42:47,200 --> 00:42:52,079
there's yeah there's a little um

00:42:52,800 --> 00:42:56,240
you need to shift the width and the

00:42:55,359 --> 00:42:59,839
height

00:42:56,240 --> 00:43:03,119
by uh 16 bits here because

00:42:59,839 --> 00:43:06,079
um the source and

00:43:03,119 --> 00:43:07,599
so the source rectangle is given in a

00:43:06,079 --> 00:43:10,720
fixed point

00:43:07,599 --> 00:43:13,440
coordinates so yeah

00:43:10,720 --> 00:43:14,240
if you need to yeah it doesn't matter

00:43:13,440 --> 00:43:18,400
that much

00:43:14,240 --> 00:43:18,400
just something to care about

00:43:18,560 --> 00:43:22,400
the other thing we are going to to do is

00:43:21,280 --> 00:43:26,640
set the destination

00:43:22,400 --> 00:43:29,760
rectangle so this allows to scale uh

00:43:26,640 --> 00:43:30,560
a frame buffer so if i have a small

00:43:29,760 --> 00:43:33,839
frame buffer

00:43:30,560 --> 00:43:35,200
and i want to scale it to be larger uh i

00:43:33,839 --> 00:43:36,800
can do that with

00:43:35,200 --> 00:43:38,880
the destination rectangle i'm not

00:43:36,800 --> 00:43:40,000
interested in that so i'm just like the

00:43:38,880 --> 00:43:43,839
source rectangle i'm going

00:43:40,000 --> 00:43:46,160
to set it to the full frame buffer

00:43:43,839 --> 00:43:48,000
uh once i'm done with that i can just

00:43:46,160 --> 00:43:50,960
perform an atomic commit

00:43:48,000 --> 00:43:52,400
i'm going to set the flags to non-block

00:43:50,960 --> 00:43:54,319
because i'm not interested

00:43:52,400 --> 00:43:56,240
in waiting for the frame buffer to be

00:43:54,319 --> 00:43:58,400
displayed on screen or anything

00:43:56,240 --> 00:43:59,520
so i just want to return as soon as

00:43:58,400 --> 00:44:03,760
possible

00:43:59,520 --> 00:44:07,359
and cue the atomic commits

00:44:03,760 --> 00:44:11,760
so that was a lot of things

00:44:07,359 --> 00:44:15,040
i i i did the presentation

00:44:11,760 --> 00:44:18,560
that was quick i hope you coach that

00:44:15,040 --> 00:44:22,800
so i collected everything

00:44:18,560 --> 00:44:26,079
in a show fb function

00:44:22,800 --> 00:44:27,920
so yeah basically it's

00:44:26,079 --> 00:44:30,160
all the code in the slides just in the

00:44:27,920 --> 00:44:33,599
single function get property

00:44:30,160 --> 00:44:33,599
value add property

00:44:34,000 --> 00:44:41,119
the code from earlier to select the crtc

00:44:37,200 --> 00:44:42,319
and the plane there's a code familiar to

00:44:41,119 --> 00:44:45,599
allocate the

00:44:42,319 --> 00:44:48,160
buffer and

00:44:45,599 --> 00:44:48,720
to create the memory mapping i've added

00:44:48,160 --> 00:44:51,440
some code

00:44:48,720 --> 00:44:52,560
to fill the the frame buffer to white to

00:44:51,440 --> 00:44:56,200
the frame buffer

00:44:52,560 --> 00:44:59,200
with solid red here uh

00:44:56,200 --> 00:45:03,119
bgrx and r is set to ff

00:44:59,200 --> 00:45:07,280
so plain plain red i'm just copying the

00:45:03,119 --> 00:45:09,280
the pixels to the buffer here

00:45:07,280 --> 00:45:10,480
and then i submit the atomic commits

00:45:09,280 --> 00:45:14,400
with the

00:45:10,480 --> 00:45:16,400
fbid set to the id i got earlier

00:45:14,400 --> 00:45:18,079
and that's about it sleeping for a few

00:45:16,400 --> 00:45:22,480
seconds so that

00:45:18,079 --> 00:45:25,599
i can see the results that's about it

00:45:22,480 --> 00:45:29,839
so i have a camera here

00:45:25,599 --> 00:45:34,400
set to uh my demo computer

00:45:29,839 --> 00:45:37,599
i'm just going to run my demo here

00:45:34,400 --> 00:45:40,640
we can see that it allocated the fb

00:45:37,599 --> 00:45:44,839
and used the

00:45:40,640 --> 00:45:47,680
crtc 45-41

00:45:44,839 --> 00:45:50,720
and we can see that

00:45:47,680 --> 00:45:51,040
the screen is red so we finally managed

00:45:50,720 --> 00:45:53,760
to

00:45:51,040 --> 00:45:56,480
display something on screen i have

00:45:53,760 --> 00:45:59,520
another demo which

00:45:56,480 --> 00:46:04,000
animates the fb a little bit

00:45:59,520 --> 00:46:04,000
so it's it's a little bit cooler

00:46:04,319 --> 00:46:08,480
yeah you can change the color of a time

00:46:06,240 --> 00:46:11,920
just by writing to the buffer in a loop

00:46:08,480 --> 00:46:13,440
and submitting atomic commits in lobe

00:46:11,920 --> 00:46:16,160
pretty simple i don't know if you can

00:46:13,440 --> 00:46:19,599
see it here but

00:46:16,160 --> 00:46:19,599
there's a lot of uh

00:46:19,760 --> 00:46:23,440
there's some tearing so basically

00:46:22,720 --> 00:46:27,200
there's

00:46:23,440 --> 00:46:30,240
some mismatches sometimes the

00:46:27,200 --> 00:46:30,960
the the colors are mixed a little that's

00:46:30,240 --> 00:46:32,160
because

00:46:30,960 --> 00:46:34,800
it's completely missing in the

00:46:32,160 --> 00:46:37,119
synchronization so we need to add some

00:46:34,800 --> 00:46:37,839
double buffering in there to to be able

00:46:37,119 --> 00:46:40,480
to

00:46:37,839 --> 00:46:42,960
fix that but i i won't have time to to

00:46:40,480 --> 00:46:46,960
talk about this

00:46:42,960 --> 00:46:49,760
uh yeah there you have it what screen

00:46:46,960 --> 00:46:49,760
with kms

00:46:50,319 --> 00:46:56,720
so there's a lot of other stuff to

00:46:54,640 --> 00:46:58,480
to do with kms which was just an

00:46:56,720 --> 00:47:01,520
introduction

00:46:58,480 --> 00:47:04,160
so there are a bunch of

00:47:01,520 --> 00:47:04,720
objects we need to do and to perform a

00:47:04,160 --> 00:47:07,680
mod set

00:47:04,720 --> 00:47:09,359
it's a little bit more involved you

00:47:07,680 --> 00:47:12,400
might also want to handle

00:47:09,359 --> 00:47:15,040
patchflip events which say

00:47:12,400 --> 00:47:16,880
when when a buffer is finally displayed

00:47:15,040 --> 00:47:19,200
on screen

00:47:16,880 --> 00:47:21,599
to prevent tiering you you might be

00:47:19,200 --> 00:47:23,280
interested in double buffering

00:47:21,599 --> 00:47:25,440
you might also be interested in hot plug

00:47:23,280 --> 00:47:26,079
events to know when a new screen is

00:47:25,440 --> 00:47:29,920
plugged in

00:47:26,079 --> 00:47:30,480
or unplugged atomic test templates

00:47:29,920 --> 00:47:34,400
allows

00:47:30,480 --> 00:47:37,760
to query some if hardware supports

00:47:34,400 --> 00:47:39,599
a particular capability or not and you

00:47:37,760 --> 00:47:43,119
might also be interested in

00:47:39,599 --> 00:47:46,400
integrating with opengl to duo because

00:47:43,119 --> 00:47:48,880
drawing with dumb frameworks is good for

00:47:46,400 --> 00:47:52,240
demos and for simple cases

00:47:48,880 --> 00:47:53,920
but to take advantage of the gpu

00:47:52,240 --> 00:47:56,319
you likely want to use something like

00:47:53,920 --> 00:47:59,119
opengl to draw

00:47:56,319 --> 00:47:59,119
stuff on screen

00:47:59,520 --> 00:48:03,040
and there are also a bunch of other

00:48:01,119 --> 00:48:06,640
things you might be interested in

00:48:03,040 --> 00:48:09,760
i just put it there if you want

00:48:06,640 --> 00:48:13,520
also demos you can find it uh find it

00:48:09,760 --> 00:48:16,720
in a git repo there's also a few

00:48:13,520 --> 00:48:19,599
other resources about kms

00:48:16,720 --> 00:48:20,400
the i mean for the tool i talked about

00:48:19,599 --> 00:48:23,760
is available

00:48:20,400 --> 00:48:26,960
here i built also a dm database

00:48:23,760 --> 00:48:30,559
of dm info dumps to know which

00:48:26,960 --> 00:48:35,680
gpus support words and yeah

00:48:30,559 --> 00:48:38,720
kind of rivets at dri devil and freynart

00:48:35,680 --> 00:48:41,440
that was it so let me know if you have

00:48:38,720 --> 00:48:41,440
any questions

00:48:41,520 --> 00:48:46,400
thanks a lot for for the talk

00:48:44,720 --> 00:48:48,079
we have some questions that have come in

00:48:46,400 --> 00:48:51,200
on the on the youtube live

00:48:48,079 --> 00:48:53,520
chat the first question was what if i

00:48:51,200 --> 00:48:55,680
what if i use a different offset than

00:48:53,520 --> 00:48:57,040
the one provided in the map

00:48:55,680 --> 00:49:00,720
would it be possible to access the

00:48:57,040 --> 00:49:03,920
memory region i'm not supposed to access

00:49:00,720 --> 00:49:07,280
that's a good question um

00:49:03,920 --> 00:49:08,960
so the question is about

00:49:07,280 --> 00:49:12,079
[Music]

00:49:08,960 --> 00:49:13,040
let me find it allocating yeah here i

00:49:12,079 --> 00:49:17,680
have a map

00:49:13,040 --> 00:49:20,960
and the drm fd with an offset here

00:49:17,680 --> 00:49:22,720
and offset is provided by the map done

00:49:20,960 --> 00:49:25,920
by octl

00:49:22,720 --> 00:49:28,400
so i think it will

00:49:25,920 --> 00:49:29,200
just fail but i haven't actually read

00:49:28,400 --> 00:49:32,720
the code

00:49:29,200 --> 00:49:34,640
so uh i'm not sure

00:49:32,720 --> 00:49:35,839
that's a good question i should read the

00:49:34,640 --> 00:49:39,599
code for this

00:49:35,839 --> 00:49:40,160
uh mapdam function in the kernel and

00:49:39,599 --> 00:49:44,400
find out

00:49:40,160 --> 00:49:46,480
i don't know my guess is it will fail

00:49:44,400 --> 00:49:48,559
yeah that that would make sense but it's

00:49:46,480 --> 00:49:51,599
always always nice to know

00:49:48,559 --> 00:49:53,760
for sure yeah uh

00:49:51,599 --> 00:49:55,520
a question the second question was what

00:49:53,760 --> 00:49:56,720
was it that made you look into learning

00:49:55,520 --> 00:49:58,640
these apis

00:49:56,720 --> 00:50:00,640
are you working with vr or something

00:49:58,640 --> 00:50:03,760
like that that promote the

00:50:00,640 --> 00:50:07,040
interest so i already

00:50:03,760 --> 00:50:10,319
originally worked on this because

00:50:07,040 --> 00:50:13,440
i started getting interested in wayland

00:50:10,319 --> 00:50:14,160
so i started contributing to sway and w

00:50:13,440 --> 00:50:17,040
ella woods

00:50:14,160 --> 00:50:19,920
uh so the w alot is a library to write

00:50:17,040 --> 00:50:22,880
white on compositors and it uses kms

00:50:19,920 --> 00:50:23,839
so i just wanted to improve the bodywork

00:50:22,880 --> 00:50:28,240
roots

00:50:23,839 --> 00:50:30,800
uh so a friend scott anderson wrote

00:50:28,240 --> 00:50:31,599
a lot of the kms uh stuff in double

00:50:30,800 --> 00:50:34,640
roads

00:50:31,599 --> 00:50:35,119
but i eventually needed to change some

00:50:34,640 --> 00:50:38,000
things

00:50:35,119 --> 00:50:38,800
uh all of this was pretty obscure at the

00:50:38,000 --> 00:50:43,040
moment

00:50:38,800 --> 00:50:43,040
at the time so yeah

00:50:43,760 --> 00:50:47,200
over time i just learned more and more

00:50:46,160 --> 00:50:49,359
about kms

00:50:47,200 --> 00:50:50,400
and finally got to the point where i am

00:50:49,359 --> 00:50:53,760
now but

00:50:50,400 --> 00:50:57,280
yeah it was pretty difficult to

00:50:53,760 --> 00:51:00,960
to to get there since then

00:50:57,280 --> 00:51:04,160
some new resources are now available

00:51:00,960 --> 00:51:07,599
like the scott anderson dm dock

00:51:04,160 --> 00:51:08,800
and danielle's kms quads so maybe that

00:51:07,599 --> 00:51:12,000
helps

00:51:08,800 --> 00:51:13,520
but uh yeah uh we definitely need to

00:51:12,000 --> 00:51:16,160
improve ducks again

00:51:13,520 --> 00:51:18,000
once again uh so yeah the reason was

00:51:16,160 --> 00:51:19,680
wrote

00:51:18,000 --> 00:51:20,960
it's it's it's the usual case that you

00:51:19,680 --> 00:51:21,599
started with something small and then

00:51:20,960 --> 00:51:25,200
you just got

00:51:21,599 --> 00:51:28,400
in deep yeah

00:51:25,200 --> 00:51:28,400
i can i can relate

00:51:28,480 --> 00:51:31,680
and then there was a question which

00:51:29,839 --> 00:51:32,400
repository contains the drm info but

00:51:31,680 --> 00:51:34,960
that's the one

00:51:32,400 --> 00:51:36,720
shown on this slide right yeah you can

00:51:34,960 --> 00:51:39,520
uh just click on this link

00:51:36,720 --> 00:51:40,480
uh and then it will yeah it's pretty

00:51:39,520 --> 00:51:42,559
simple to build

00:51:40,480 --> 00:51:44,160
uh yeah yeah just try and we will make

00:51:42,559 --> 00:51:46,000
sure that the slides are available later

00:51:44,160 --> 00:51:49,200
on the foster north website as well

00:51:46,000 --> 00:51:51,040
cool all right i think that's

00:51:49,200 --> 00:51:52,640
uh all the questions we had for this

00:51:51,040 --> 00:51:56,480
talk thank you very much

00:51:52,640 --> 00:51:58,000
simon no problem and i'll hand over to

00:51:56,480 --> 00:52:01,200
johan

00:51:58,000 --> 00:52:02,400
yeah big thanks uh we will have another

00:52:01,200 --> 00:52:19,839
nine minute break

00:52:02,400 --> 00:52:19,839
and i'll see you at 11. thank you

00:52:26,319 --> 00:52:28,400

YouTube URL: https://www.youtube.com/watch?v=haes4_Xnc5Q


