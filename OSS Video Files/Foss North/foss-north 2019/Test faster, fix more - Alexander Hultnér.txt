Title: Test faster, fix more - Alexander Hultnér
Publication date: 2019-04-22
Playlist: foss-north 2019
Description: 
	Did you ever miss that corner case bug? Maybe it was a negative integer, strange timezone conversion behaviour, off by one error or something entirely else. These subtle bugs are often hard to catch and are easily missed in test cases. You like me have probably ran into plenty of code utilising only happy path testing, only to later discover subtle bugs which are easily fixed once pointed out.
This is where property based testing comes into the picture. In this talk I will focus on a wonderful Python library called Hypothesis but the concepts apply to other languages as well. Hypethesis is based on the same concept as the famous QuickCheck library for Haskell, which in turn have been ported a large number of languages. Hypothesis uses a wide range of input to find edge cases that you could otherwise easily miss, once it finds these cases it narrows down the input to the minimal breaking example to provide failures which are easier to understand.

---

Alex is technologist by hearth and have been working in the industry for the past 10 years and were contributing to open source prior to that. He’s worked in a wide range of industries including but not limited to Industrial IoT, smart greenhouses, public procurement systems, facility management systems, quality systems, communication systems and more.
He’s on twitter as @ahultner, https://twitter.com/ahultner
Alex can also be reached via his website, https://hultner.se 

https://foss-north.se/2019/speakers-and-talks.html#ahultner
Captions: 
	00:00:15,950 --> 00:00:24,590
yeah hello everyone my name is Alexander

00:00:20,150 --> 00:00:27,439
Heffner I'm gonna talk about something

00:00:24,590 --> 00:00:30,050
called property based testing and I'm

00:00:27,439 --> 00:00:32,419
gonna be using Python but the concept

00:00:30,050 --> 00:00:35,600
should apply to other languages as well

00:00:32,419 --> 00:00:38,420
and you can also use Python to test

00:00:35,600 --> 00:00:43,430
other language I will show some examples

00:00:38,420 --> 00:00:46,280
for that so let's just first how many

00:00:43,430 --> 00:00:51,110
here have used automated testing I

00:00:46,280 --> 00:00:53,480
suppose a lot of you yeah and how many

00:00:51,110 --> 00:00:59,210
of you have used property based testing

00:00:53,480 --> 00:01:01,850
a few less okay so I've also noticed

00:00:59,210 --> 00:01:03,739
that not that it's not that common that

00:01:01,850 --> 00:01:05,840
people use property based testing but

00:01:03,739 --> 00:01:11,590
it's very interesting so therefore I'd

00:01:05,840 --> 00:01:16,280
like to shed some more light on it and

00:01:11,590 --> 00:01:19,869
I'll start with presenting myself a

00:01:16,280 --> 00:01:22,399
little bit my name is Alexander hotner I

00:01:19,869 --> 00:01:27,170
run my own company called hotner

00:01:22,399 --> 00:01:31,310
technologies I mainly do consulting and

00:01:27,170 --> 00:01:35,380
product development in software you can

00:01:31,310 --> 00:01:39,850
contact me at Twitter at a at a counter

00:01:35,380 --> 00:01:43,819
or email me at contact at hot nerd @se

00:01:39,850 --> 00:01:47,569
my website is hot nerd odesi all the

00:01:43,819 --> 00:01:49,520
slides will be available on actually a

00:01:47,569 --> 00:01:52,429
spelling mistake there I see but it's on

00:01:49,520 --> 00:01:55,670
slides comm slash shortener I will tweet

00:01:52,429 --> 00:01:58,609
it out as well later and I will put all

00:01:55,670 --> 00:02:02,119
the content on my github as well which

00:01:58,609 --> 00:02:07,209
is my name is just hot nerd there as

00:02:02,119 --> 00:02:09,890
well so if you want to go back and

00:02:07,209 --> 00:02:12,730
retrieve links you don't have to note

00:02:09,890 --> 00:02:15,020
them now just check my Twitter or

00:02:12,730 --> 00:02:19,660
whatever and you will find the slides

00:02:15,020 --> 00:02:27,590
and get everything from there yeah so

00:02:19,660 --> 00:02:30,370
let's start so a basic outline of what

00:02:27,590 --> 00:02:33,310
I'm going to be talking about today

00:02:30,370 --> 00:02:37,540
first what is property based testing and

00:02:33,310 --> 00:02:41,200
why should we use it short cheat sheet

00:02:37,540 --> 00:02:43,900
where I just cover some of the most

00:02:41,200 --> 00:02:46,180
important things so if you're gonna fall

00:02:43,900 --> 00:02:49,959
asleep just listen to those two minutes

00:02:46,180 --> 00:02:52,390
at least then I'm gonna be talking about

00:02:49,959 --> 00:02:55,319
the library called hypothesis it's a

00:02:52,390 --> 00:02:58,660
Python library which is very useful for

00:02:55,319 --> 00:03:01,690
building your property strategies and

00:02:58,660 --> 00:03:04,299
building good tests and I'm gonna go

00:03:01,690 --> 00:03:07,180
through some usage examples get it for

00:03:04,299 --> 00:03:08,860
getting started and I'm gonna talk a

00:03:07,180 --> 00:03:11,470
little bit about some more advanced

00:03:08,860 --> 00:03:14,890
strategies but I'm not gonna go into too

00:03:11,470 --> 00:03:17,489
much depth it's more gonna be like an

00:03:14,890 --> 00:03:20,730
introduction to property based testing

00:03:17,489 --> 00:03:24,130
I'm gonna mention rule state machines

00:03:20,730 --> 00:03:27,610
because they are a very powerful concept

00:03:24,130 --> 00:03:29,799
but I'm not gonna go into detail because

00:03:27,610 --> 00:03:32,319
it's outside the scope of this talk it

00:03:29,799 --> 00:03:35,200
would take another day maybe to get

00:03:32,319 --> 00:03:38,260
through everything but I'm gonna have an

00:03:35,200 --> 00:03:41,350
interactive demo in demo in Jupiter

00:03:38,260 --> 00:03:44,170
where I'm gonna show how it could be

00:03:41,350 --> 00:03:48,880
used to find some sub tool bugs in

00:03:44,170 --> 00:03:52,980
software and then a short conclusion and

00:03:48,880 --> 00:03:56,140
a QA where I also will list all the

00:03:52,980 --> 00:04:00,970
links to find data slides and other

00:03:56,140 --> 00:04:04,269
material so what is property based

00:04:00,970 --> 00:04:10,109
testing and why should we use it let's

00:04:04,269 --> 00:04:12,880
start with traditional unit at Oh wrong

00:04:10,109 --> 00:04:16,019
traditional unit tests so they are

00:04:12,880 --> 00:04:19,870
usually based on specific examples and

00:04:16,019 --> 00:04:22,990
tend to have a bit of repetition because

00:04:19,870 --> 00:04:24,910
usually you make a few tests testing

00:04:22,990 --> 00:04:29,650
okay what happens if I do it like this

00:04:24,910 --> 00:04:31,810
or this or have this input and that also

00:04:29,650 --> 00:04:35,080
tends to lead to happy path testing

00:04:31,810 --> 00:04:37,630
where you test what you know should work

00:04:35,080 --> 00:04:40,810
but maybe you don't try out all the edge

00:04:37,630 --> 00:04:43,360
cases which might actually break your

00:04:40,810 --> 00:04:46,389
application

00:04:43,360 --> 00:04:50,740
with property-based testing you have

00:04:46,389 --> 00:04:54,759
another approach you generate thousands

00:04:50,740 --> 00:04:58,270
of examples by specifying this sort of

00:04:54,759 --> 00:05:01,330
input the the application can take so

00:04:58,270 --> 00:05:04,330
it's more about specifying the behavior

00:05:01,330 --> 00:05:08,439
and verifying that it actually works as

00:05:04,330 --> 00:05:13,419
you said and it can shrink these

00:05:08,439 --> 00:05:15,849
problems what that means is that it will

00:05:13,419 --> 00:05:18,099
try to trigger an error but maybe it

00:05:15,849 --> 00:05:21,009
uses a very large input and then it will

00:05:18,099 --> 00:05:24,370
try to do a binary search to find

00:05:21,009 --> 00:05:26,860
exactly where the error happens and in

00:05:24,370 --> 00:05:29,560
that way it's much easier also to locate

00:05:26,860 --> 00:05:32,580
what might go wrong

00:05:29,560 --> 00:05:36,219
it's very good at detecting sub dog bugs

00:05:32,580 --> 00:05:39,460
I've found stuff like time zone

00:05:36,219 --> 00:05:41,650
conversions where it can drift a couple

00:05:39,460 --> 00:05:43,840
of seconds between an application

00:05:41,650 --> 00:05:46,719
language and certain databases for

00:05:43,840 --> 00:05:49,389
instance which might not be noticeable

00:05:46,719 --> 00:05:51,669
very quickly but if you do several round

00:05:49,389 --> 00:05:56,169
trips it will eventually add up to days

00:05:51,669 --> 00:05:59,139
so those kind of things can be very hard

00:05:56,169 --> 00:06:02,440
to find otherwise another example I've

00:05:59,139 --> 00:06:06,129
seen is where negative IDs does weird

00:06:02,440 --> 00:06:08,469
things and can sometimes crash your

00:06:06,129 --> 00:06:12,490
application or in other cases I've seen

00:06:08,469 --> 00:06:17,289
hash algorithms go crazy with negative

00:06:12,490 --> 00:06:19,180
IDs and it's very useful as well for

00:06:17,289 --> 00:06:21,909
comparing implementations when doing

00:06:19,180 --> 00:06:25,089
refactorings or rewrites basically you

00:06:21,909 --> 00:06:27,339
can throw input to both your new

00:06:25,089 --> 00:06:30,069
implementation and to your old one and

00:06:27,339 --> 00:06:32,349
you know that you should get the same

00:06:30,069 --> 00:06:34,839
results consider if the old

00:06:32,349 --> 00:06:40,889
implementation works and you just want

00:06:34,839 --> 00:06:40,889
to refactor it to a more nice state

00:06:44,390 --> 00:06:53,970
so here's my quick cheat sheet as I said

00:06:50,090 --> 00:06:56,490
it's about defining input and behavior

00:06:53,970 --> 00:06:59,730
not specific examples although you can

00:06:56,490 --> 00:07:03,930
do that if you want to specifically try

00:06:59,730 --> 00:07:06,870
some things and I recommend looking at

00:07:03,930 --> 00:07:10,380
quick check by young use that's actually

00:07:06,870 --> 00:07:12,840
how I got introduced to it by actually

00:07:10,380 --> 00:07:17,880
taking a course here at Chalmers a few

00:07:12,840 --> 00:07:21,420
years back and I took the course because

00:07:17,880 --> 00:07:25,290
I'm I'm a hobbyist lace packer and

00:07:21,420 --> 00:07:26,940
wanted to try out Haskell but what was

00:07:25,290 --> 00:07:29,270
the greatest takeaway from it was

00:07:26,940 --> 00:07:31,740
probably the property based testing

00:07:29,270 --> 00:07:36,330
something I did not expect going into

00:07:31,740 --> 00:07:38,250
that course and then I'm gonna talk

00:07:36,330 --> 00:07:41,670
about hypothesis which is basically a

00:07:38,250 --> 00:07:44,100
port of quick check to - but they have

00:07:41,670 --> 00:07:47,480
also added other concepts on top of that

00:07:44,100 --> 00:07:51,810
making it easier to use and very

00:07:47,480 --> 00:07:53,670
powerful for a lot of stuff here are

00:07:51,810 --> 00:07:58,050
some links to some other videos if

00:07:53,670 --> 00:08:00,660
you're if you thinking about using it so

00:07:58,050 --> 00:08:03,480
beyond unit tests is a talk at last

00:08:00,660 --> 00:08:09,000
year's PyCon by hey lil wayne and it

00:08:03,480 --> 00:08:11,700
talks about about hypothesis and also

00:08:09,000 --> 00:08:14,520
how you can go beyond your unit tests

00:08:11,700 --> 00:08:17,400
and there is also better testing with

00:08:14,520 --> 00:08:19,890
less code an older PyCon talk which also

00:08:17,400 --> 00:08:24,270
talks about hypothesis and property

00:08:19,890 --> 00:08:28,560
based testing this is a resource using

00:08:24,270 --> 00:08:31,710
properties based testing f-sharp this is

00:08:28,560 --> 00:08:33,420
for the f-sharp implementation of quick

00:08:31,710 --> 00:08:36,000
check I don't remember the name right

00:08:33,420 --> 00:08:39,240
now but I think it's like F check or

00:08:36,000 --> 00:08:42,150
something like that but the things they

00:08:39,240 --> 00:08:44,490
mentioned in the article rings true for

00:08:42,150 --> 00:08:47,130
all kinds of property based testing so

00:08:44,490 --> 00:08:49,350
it's more about how you should define

00:08:47,130 --> 00:08:52,440
your properties and develop good

00:08:49,350 --> 00:08:54,300
strategies to test your application so I

00:08:52,440 --> 00:08:57,080
recommend reading it even if you're not

00:08:54,300 --> 00:08:57,080
using f sharp

00:09:00,080 --> 00:09:09,020
okay so hypothesis it's a Python library

00:09:05,310 --> 00:09:13,050
their website this hypothesis that works

00:09:09,020 --> 00:09:16,710
they have some very neat stuff my

00:09:13,050 --> 00:09:19,620
computer fell asleep they have some very

00:09:16,710 --> 00:09:24,780
nice neat stuff and as I said previously

00:09:19,620 --> 00:09:27,510
it's based on on quick check but they

00:09:24,780 --> 00:09:30,000
have added a lot more stuff they have a

00:09:27,510 --> 00:09:34,020
very large library of what they call

00:09:30,000 --> 00:09:36,870
strategies strategies are different ways

00:09:34,020 --> 00:09:41,070
of generating input some notable

00:09:36,870 --> 00:09:45,600
examples are DP contracts which is used

00:09:41,070 --> 00:09:47,730
for contract driven development and if

00:09:45,600 --> 00:09:50,130
you don't know what that is you can look

00:09:47,730 --> 00:09:53,550
into it it's a very powerful command

00:09:50,130 --> 00:09:58,140
concept where you define a contract for

00:09:53,550 --> 00:10:00,770
how your software should behave and you

00:09:58,140 --> 00:10:03,420
can use this as a formal way of

00:10:00,770 --> 00:10:05,670
validating that your implementation

00:10:03,420 --> 00:10:08,010
actually works so it's very very good

00:10:05,670 --> 00:10:09,380
for that mission-critical code which

00:10:08,010 --> 00:10:11,910
can't go wrong

00:10:09,380 --> 00:10:14,160
I'm not gonna cover that too much today

00:10:11,910 --> 00:10:16,670
but it's very worth looking at if you're

00:10:14,160 --> 00:10:19,260
interesting interested in that and

00:10:16,670 --> 00:10:20,670
swaggered conformance testing that's a

00:10:19,260 --> 00:10:23,610
very interesting one you can basically

00:10:20,670 --> 00:10:29,100
throw a swagger spec two hypotheses and

00:10:23,610 --> 00:10:31,080
it can then run tests towards this API

00:10:29,100 --> 00:10:32,940
for those of you who don't know what

00:10:31,080 --> 00:10:36,420
swagger is I think it's actually named

00:10:32,940 --> 00:10:40,590
open API now but the UI is still named

00:10:36,420 --> 00:10:43,140
swagger and this implementation threat

00:10:40,590 --> 00:10:45,150
of the strategies also named at but

00:10:43,140 --> 00:10:48,960
basically it will take the specification

00:10:45,150 --> 00:10:51,420
of the API and it will look at the sort

00:10:48,960 --> 00:10:53,460
of input the API should handle and it

00:10:51,420 --> 00:10:55,230
will just generate a lot of cases out of

00:10:53,460 --> 00:10:58,110
that and try to break your

00:10:55,230 --> 00:10:59,700
implementation usually you can find some

00:10:58,110 --> 00:11:03,540
fun errors that way

00:10:59,700 --> 00:11:06,180
there are also strategies for pandas

00:11:03,540 --> 00:11:08,970
numpy if you're doing data science stuff

00:11:06,180 --> 00:11:10,170
there is for django models if you're

00:11:08,970 --> 00:11:12,540
using Django

00:11:10,170 --> 00:11:16,620
I haven't tried that one myself but I've

00:11:12,540 --> 00:11:18,120
heard it's good then we have rules which

00:11:16,620 --> 00:11:20,520
I talked a little bit before it's

00:11:18,120 --> 00:11:24,750
basically a way of defining state

00:11:20,520 --> 00:11:26,730
machines where you can get steps to

00:11:24,750 --> 00:11:29,520
reproduce an error so you don't actually

00:11:26,730 --> 00:11:32,550
define the test case the library

00:11:29,520 --> 00:11:36,960
actually does the test case for you you

00:11:32,550 --> 00:11:41,520
just say what the application can do and

00:11:36,960 --> 00:11:43,830
here is a minimal usage example in this

00:11:41,520 --> 00:11:46,260
case we want to generate two positional

00:11:43,830 --> 00:11:50,340
arguments you can use keyword arguments

00:11:46,260 --> 00:11:52,500
as well so we have two integers and we

00:11:50,340 --> 00:11:54,840
want to check that they are commutative

00:11:52,500 --> 00:11:58,860
so we want to see that X plus y always

00:11:54,840 --> 00:12:00,990
is the same as Y plus X so this is a

00:11:58,860 --> 00:12:04,530
very simple test but it's one of the

00:12:00,990 --> 00:12:07,470
basic samples and from the hypothesis

00:12:04,530 --> 00:12:09,390
documents and I think it showcases how

00:12:07,470 --> 00:12:11,910
easy it can be to actually get started

00:12:09,390 --> 00:12:17,100
with it so this is just a PI test test

00:12:11,910 --> 00:12:20,940
and you just define some inputs and then

00:12:17,100 --> 00:12:22,920
what those should be you can use other

00:12:20,940 --> 00:12:25,080
strategies there are four lists there

00:12:22,920 --> 00:12:27,420
are four tuples and floats and there are

00:12:25,080 --> 00:12:29,700
third party strategies for about

00:12:27,420 --> 00:12:31,830
everything you can think of and if there

00:12:29,700 --> 00:12:35,610
aren't you can probably define one

00:12:31,830 --> 00:12:40,290
yourself you can also pass them some

00:12:35,610 --> 00:12:41,870
more stuff to customize the behavior I

00:12:40,290 --> 00:12:48,090
will talk a little bit more about that

00:12:41,870 --> 00:12:52,080
in another slide so shrinking errors and

00:12:48,090 --> 00:12:54,330
I talked about this so when you find an

00:12:52,080 --> 00:12:57,990
error maybe maybe you have some very

00:12:54,330 --> 00:13:01,350
large arbitrary input and you're not

00:12:57,990 --> 00:13:05,310
quite sure why it's breaking so if

00:13:01,350 --> 00:13:08,250
you're using maybe just randomized data

00:13:05,310 --> 00:13:11,790
and not doing any shrinking maybe you

00:13:08,250 --> 00:13:13,920
don't understand the problem but here's

00:13:11,790 --> 00:13:17,340
an example where we have shrunken an

00:13:13,920 --> 00:13:20,970
error so I'm doing a test and testing an

00:13:17,340 --> 00:13:23,550
add function and I can see that if I'm

00:13:20,970 --> 00:13:26,730
throwing a minus one

00:13:23,550 --> 00:13:27,240
and b12 it it's actually getting an

00:13:26,730 --> 00:13:30,089
error

00:13:27,240 --> 00:13:32,610
the original failing test could have

00:13:30,089 --> 00:13:34,470
been something entirely different but

00:13:32,610 --> 00:13:37,410
this was the smallest case it could find

00:13:34,470 --> 00:13:40,740
that still triggers error so this is

00:13:37,410 --> 00:13:42,930
kind of if you go one up it will not

00:13:40,740 --> 00:13:46,140
trigger the error anymore so let's see

00:13:42,930 --> 00:13:49,680
what the buggy code looks like well it's

00:13:46,140 --> 00:13:51,810
not that strange we're looking if a is

00:13:49,680 --> 00:13:55,200
less than zero then just return a

00:13:51,810 --> 00:13:57,390
otherwise add them up so obviously it's

00:13:55,200 --> 00:13:59,790
gonna be bugging but it's a good way to

00:13:57,390 --> 00:14:05,610
show how it actually found exactly the

00:13:59,790 --> 00:14:08,250
edge case where it breaks and of course

00:14:05,610 --> 00:14:12,810
once you've found this kind of error you

00:14:08,250 --> 00:14:16,980
can use examples so this way we have

00:14:12,810 --> 00:14:19,860
added an example with the previously

00:14:16,980 --> 00:14:22,110
buggy version and this way we can ensure

00:14:19,860 --> 00:14:23,940
that we're not getting rare regressions

00:14:22,110 --> 00:14:26,519
at the later point because we know that

00:14:23,940 --> 00:14:29,100
with this example hypothesis will always

00:14:26,519 --> 00:14:31,709
test this case and this is very useful

00:14:29,100 --> 00:14:33,540
if you already know some tricky cases

00:14:31,709 --> 00:14:36,180
for your application or if you know

00:14:33,540 --> 00:14:38,579
you've had previous bugs which you don't

00:14:36,180 --> 00:14:40,950
want to reappear hypotheses will

00:14:38,579 --> 00:14:45,270
actually also store all bugs it

00:14:40,950 --> 00:14:48,360
encounters or all failures in your local

00:14:45,270 --> 00:14:49,980
database but that's only on your machine

00:14:48,360 --> 00:14:52,589
or on the machine that's running the

00:14:49,980 --> 00:14:54,660
test so it's not shared between all code

00:14:52,589 --> 00:14:55,320
and unless you've set it up in some way

00:14:54,660 --> 00:14:58,110
to do that

00:14:55,320 --> 00:15:01,350
so using these examples are a very good

00:14:58,110 --> 00:15:08,699
way to explicitly show that always try

00:15:01,350 --> 00:15:11,730
this so back to strategies you saw the

00:15:08,699 --> 00:15:15,720
integers but we have stuff like tuples

00:15:11,730 --> 00:15:17,880
and lists you can also say how large the

00:15:15,720 --> 00:15:20,040
list should be maybe you don't want an

00:15:17,880 --> 00:15:24,120
infinite large list or maybe you don't

00:15:20,040 --> 00:15:26,880
want empty lists and sets of course as

00:15:24,120 --> 00:15:29,190
well you have text but you also have

00:15:26,880 --> 00:15:31,620
characters you can also define which

00:15:29,190 --> 00:15:33,209
characters the text should use so maybe

00:15:31,620 --> 00:15:35,310
if you're just trying ascii maybe you

00:15:33,209 --> 00:15:36,930
don't want the entire Unicode or maybe

00:15:35,310 --> 00:15:38,250
you want entire Unicode to see if

00:15:36,930 --> 00:15:41,640
you're breaking something with your

00:15:38,250 --> 00:15:44,730
encoding and decoding you have floats

00:15:41,640 --> 00:15:47,399
and integers and as you saw there it

00:15:44,730 --> 00:15:49,800
also tries negative ones but you can

00:15:47,399 --> 00:15:52,410
also say that it should only test

00:15:49,800 --> 00:15:57,200
positive ones if that's the only thing

00:15:52,410 --> 00:16:00,480
the function should support and you have

00:15:57,200 --> 00:16:03,120
day times you have time zones these are

00:16:00,480 --> 00:16:05,910
very useful I've used them to test time

00:16:03,120 --> 00:16:08,070
conversion time stuff that does a lot of

00:16:05,910 --> 00:16:10,770
things with time where there can be sub

00:16:08,070 --> 00:16:12,300
bugs sometimes very good if you're

00:16:10,770 --> 00:16:15,390
trying to build something that's

00:16:12,300 --> 00:16:17,220
creating let's say a calendar event and

00:16:15,390 --> 00:16:19,230
you want to see realizations and then

00:16:17,220 --> 00:16:21,480
deserialize it and verify that your

00:16:19,230 --> 00:16:25,230
library for parsing the calendar events

00:16:21,480 --> 00:16:27,480
actually works as it should yeah and you

00:16:25,230 --> 00:16:30,089
can narrow down these strategies using

00:16:27,480 --> 00:16:30,899
for instance Max and min like max length

00:16:30,089 --> 00:16:35,640
min length

00:16:30,899 --> 00:16:37,290
max size mean size max value means value

00:16:35,640 --> 00:16:39,839
but there are other things as well you

00:16:37,290 --> 00:16:42,120
can do but if you want to see everything

00:16:39,839 --> 00:16:44,910
you should look at the documentation and

00:16:42,120 --> 00:16:47,459
here's a link you can click when you get

00:16:44,910 --> 00:16:49,589
a slides as well to see all their first

00:16:47,459 --> 00:16:51,360
and third party extensions of course

00:16:49,589 --> 00:16:53,279
there are more for third party

00:16:51,360 --> 00:16:57,870
extensions as well but there is a lot of

00:16:53,279 --> 00:16:59,790
them there is an neat API forcing

00:16:57,870 --> 00:17:03,060
example in the docs this is not a swag

00:16:59,790 --> 00:17:05,100
conformance one it's probably just it's

00:17:03,060 --> 00:17:09,030
a bit more general it's just trying to

00:17:05,100 --> 00:17:18,449
get the server to run 500 by running

00:17:09,030 --> 00:17:21,660
some data towards an API and of course

00:17:18,449 --> 00:17:25,679
rules so I'm not gonna go into every

00:17:21,660 --> 00:17:28,590
detail of this but it's very very neat

00:17:25,679 --> 00:17:31,650
and I think everyone should at least

00:17:28,590 --> 00:17:33,480
have heard about it so if you want to go

00:17:31,650 --> 00:17:34,800
further with your property based testing

00:17:33,480 --> 00:17:37,950
this is something you should look into

00:17:34,800 --> 00:17:40,230
but this is a quote from hypothesis

00:17:37,950 --> 00:17:43,530
which says with hypothesis stateful

00:17:40,230 --> 00:17:45,750
testing hypothesis instead tries to

00:17:43,530 --> 00:17:49,260
generate not just data but entire tests

00:17:45,750 --> 00:17:50,760
and I think that it's quite neatly

00:17:49,260 --> 00:17:53,130
basically

00:17:50,760 --> 00:17:56,160
you you define a state machine where you

00:17:53,130 --> 00:17:58,410
say what your application can do like

00:17:56,160 --> 00:18:03,090
add this item to cart remove it from

00:17:58,410 --> 00:18:07,049
cart update prices yeah whatever

00:18:03,090 --> 00:18:09,960
and then my hypothesis will go in and it

00:18:07,049 --> 00:18:12,059
will try to do as much stuff as possible

00:18:09,960 --> 00:18:14,850
with your application until an error

00:18:12,059 --> 00:18:18,240
occurs once there were occurs it will

00:18:14,850 --> 00:18:20,820
show you the actual steps it took to get

00:18:18,240 --> 00:18:22,980
the error so you actually get the steps

00:18:20,820 --> 00:18:27,179
to reproduce which you might not always

00:18:22,980 --> 00:18:29,280
get in your bug reports otherwise so I

00:18:27,179 --> 00:18:30,900
think you should look into this if you

00:18:29,280 --> 00:18:34,620
want to go further with your property

00:18:30,900 --> 00:18:37,410
based testing and now I'm gonna show you

00:18:34,620 --> 00:18:40,070
a demo I've put together in Jupiter

00:18:37,410 --> 00:18:46,799
notebook with some more interactive

00:18:40,070 --> 00:18:51,750
examples let's put this in presentation

00:18:46,799 --> 00:18:58,400
mode can you guys see it is it large

00:18:51,750 --> 00:19:04,980
enough yeah so I have a case about a

00:18:58,400 --> 00:19:08,340
made up bank sweep on in this demo and I

00:19:04,980 --> 00:19:12,360
will use it to show some subdue bugs

00:19:08,340 --> 00:19:14,640
which we might be able to figure out Sui

00:19:12,360 --> 00:19:17,400
Bank are very confident in their

00:19:14,640 --> 00:19:18,990
software and they have 100% line

00:19:17,400 --> 00:19:21,360
coverage so they are sure that

00:19:18,990 --> 00:19:23,100
everything is great but somehow they are

00:19:21,360 --> 00:19:29,280
still having problems they're not sure

00:19:23,100 --> 00:19:31,200
why and here's an example of one

00:19:29,280 --> 00:19:35,400
algorithm they are having problems with

00:19:31,200 --> 00:19:38,669
so they have a stock market and on the

00:19:35,400 --> 00:19:42,120
stock market it's illegal to buy stocks

00:19:38,669 --> 00:19:46,620
from and to yourself because then you

00:19:42,120 --> 00:19:48,480
could manipulate the prices and so in

00:19:46,620 --> 00:19:51,450
their matching algorithm they actually

00:19:48,480 --> 00:19:54,540
look who's the buyer and seller but they

00:19:51,450 --> 00:19:56,970
want you to buy it from their own bank

00:19:54,540 --> 00:19:58,980
customers if they can because then they

00:19:56,970 --> 00:20:02,850
don't have to pay the fees to another

00:19:58,980 --> 00:20:04,650
bank so they they're trying to find a

00:20:02,850 --> 00:20:06,570
matching buyer that is not yourself

00:20:04,650 --> 00:20:07,890
but from the same Bank if they can't

00:20:06,570 --> 00:20:10,380
find out they will look in the other

00:20:07,890 --> 00:20:12,540
banks as well so they have this simple

00:20:10,380 --> 00:20:16,290
function which takes in a stock ticker a

00:20:12,540 --> 00:20:18,120
buyer and a list of sellers so you have

00:20:16,290 --> 00:20:22,320
to buy order and the sell orders it's

00:20:18,120 --> 00:20:27,030
basically a customer ID string and a

00:20:22,320 --> 00:20:30,270
price what they do is that they look for

00:20:27,030 --> 00:20:33,360
the price and seller in all the sellers

00:20:30,270 --> 00:20:40,650
and if the price matches the buyer price

00:20:33,360 --> 00:20:42,870
and the seller bank ID so this is maybe

00:20:40,650 --> 00:20:45,150
not the most beautiful implementation

00:20:42,870 --> 00:20:49,650
but the first free letters are the

00:20:45,150 --> 00:20:52,590
bank's ID basically so by looking if

00:20:49,650 --> 00:20:55,680
it's being Cade and it's suis bonk but

00:20:52,590 --> 00:20:57,510
if it's or VL then is the rival bank

00:20:55,680 --> 00:21:02,580
which they don't want to trade with if

00:20:57,510 --> 00:21:04,740
they don't have to and then they also

00:21:02,580 --> 00:21:07,470
check that the seller is not the same as

00:21:04,740 --> 00:21:10,650
the buyer if they find a match they will

00:21:07,470 --> 00:21:13,200
return that but if they can't they will

00:21:10,650 --> 00:21:16,470
look in all the sellers and see if there

00:21:13,200 --> 00:21:19,080
is a match and if they can't find any

00:21:16,470 --> 00:21:23,520
match at all then they return on because

00:21:19,080 --> 00:21:26,040
the trade can't be executed so Swee bank

00:21:23,520 --> 00:21:31,530
have quite further testing they have

00:21:26,040 --> 00:21:34,260
actually broken it out so they don't

00:21:31,530 --> 00:21:36,750
have just cases for everything they

00:21:34,260 --> 00:21:40,500
actually have some different cases test

00:21:36,750 --> 00:21:43,770
data and have para meters for trying out

00:21:40,500 --> 00:21:47,310
it and they also have lists of some

00:21:43,770 --> 00:21:49,950
different sellers and they have 100%

00:21:47,310 --> 00:21:52,620
line coverage and they are confident in

00:21:49,950 --> 00:21:56,580
their solution so they are not sure why

00:21:52,620 --> 00:21:58,230
they are having these problems I'm not

00:21:56,580 --> 00:22:00,450
sure if any of you can spot the bug

00:21:58,230 --> 00:22:02,840
right now and no worries if you can't

00:22:00,450 --> 00:22:06,300
it's quite subtool if you can then it's

00:22:02,840 --> 00:22:08,340
extra points for you and but there is a

00:22:06,300 --> 00:22:10,260
bug in this code maybe it's not the most

00:22:08,340 --> 00:22:18,890
pretty code but it's Bank software so

00:22:10,260 --> 00:22:22,710
what do you expect so here we can see

00:22:18,890 --> 00:22:28,770
swank running their tests and we can see

00:22:22,710 --> 00:22:30,870
that they assert that winner that if

00:22:28,770 --> 00:22:33,210
there isn't a winner there's no price

00:22:30,870 --> 00:22:36,960
that matches the buyer price and if

00:22:33,210 --> 00:22:40,440
there is a winner it's not the buyer and

00:22:36,960 --> 00:22:43,770
that the match process also they check

00:22:40,440 --> 00:22:46,350
if the winner bank is not the same as

00:22:43,770 --> 00:22:51,809
the buyer bank then ensure that there is

00:22:46,350 --> 00:22:54,000
actually no seller in the entire list of

00:22:51,809 --> 00:22:56,970
sellers that actually match their bank

00:22:54,000 --> 00:23:00,270
and they get a hundred percent complete

00:22:56,970 --> 00:23:02,159
with full coverage so it looks like

00:23:00,270 --> 00:23:04,679
everything is fine but since they are

00:23:02,159 --> 00:23:06,150
having problems they hired me from

00:23:04,679 --> 00:23:08,970
holding our technologies to see if

00:23:06,150 --> 00:23:11,370
there's room to improve their testing

00:23:08,970 --> 00:23:13,020
and of course we will use property based

00:23:11,370 --> 00:23:16,650
testing to see if we can find some

00:23:13,020 --> 00:23:19,200
problems so we define a con a customer

00:23:16,650 --> 00:23:22,350
and it's basically a string of text

00:23:19,200 --> 00:23:25,890
that's at least four characters because

00:23:22,350 --> 00:23:30,090
it's at least a bank identifier and some

00:23:25,890 --> 00:23:35,010
kind of ID and for orders it's a

00:23:30,090 --> 00:23:39,390
customer and a price then we generate a

00:23:35,010 --> 00:23:41,520
list of orders and a buy order we give

00:23:39,390 --> 00:23:43,830
this to our test trade function which we

00:23:41,520 --> 00:23:47,059
have simplified a little bit but it's

00:23:43,830 --> 00:23:49,530
heavily based on the 1s where bank had

00:23:47,059 --> 00:23:52,679
previously because it's a it's a quite

00:23:49,530 --> 00:23:55,320
good verifier so we don't have to do a

00:23:52,679 --> 00:23:57,690
lot to actually adopt their tests to the

00:23:55,320 --> 00:23:59,970
property based solution basically we

00:23:57,690 --> 00:24:01,770
just have to give this decorator and

00:23:59,970 --> 00:24:05,520
make sure they actually take in sellers

00:24:01,770 --> 00:24:08,010
as a parameter as well then we run our

00:24:05,520 --> 00:24:11,700
match by and we do the same sorts of

00:24:08,010 --> 00:24:16,110
asserts and now let's run this and see

00:24:11,700 --> 00:24:19,470
oh there's a failure so let's see what's

00:24:16,110 --> 00:24:23,520
happening while running the tests we can

00:24:19,470 --> 00:24:27,030
see that if you have the buyer quadruple

00:24:23,520 --> 00:24:29,640
zero so from bank zero zero zero ID 0 it

00:24:27,030 --> 00:24:32,190
will actually match a sell a seller

00:24:29,640 --> 00:24:34,770
which is the same person with this

00:24:32,190 --> 00:24:39,630
price so this is an illegal trade with

00:24:34,770 --> 00:24:45,060
yourself and yeah we can also see the

00:24:39,630 --> 00:24:47,220
exact falsifying example here so it has

00:24:45,060 --> 00:24:49,740
shrunk and error to the minimal case it

00:24:47,220 --> 00:24:50,610
can fines so what does this why does

00:24:49,740 --> 00:24:52,680
this happen

00:24:50,610 --> 00:24:56,220
well this is because they're checking

00:24:52,680 --> 00:24:57,930
identity not equality in Python if you

00:24:56,220 --> 00:25:00,780
have a short string or a simple string

00:24:57,930 --> 00:25:02,610
they will use the same place or at least

00:25:00,780 --> 00:25:04,800
in the C Python implementation the same

00:25:02,610 --> 00:25:07,170
space in memory so they will have the

00:25:04,800 --> 00:25:09,690
same identity but if the string grows or

00:25:07,170 --> 00:25:11,550
if it has some special characters it

00:25:09,690 --> 00:25:14,340
will not use the same space in memory

00:25:11,550 --> 00:25:17,550
then it will not have the same identity

00:25:14,340 --> 00:25:22,230
but it will be equal so here you can see

00:25:17,550 --> 00:25:24,570
bonk bang will not match bonk bang

00:25:22,230 --> 00:25:29,880
because it will not use the same space

00:25:24,570 --> 00:25:34,020
in memory so basically this row is the

00:25:29,880 --> 00:25:36,690
problem seller is not buyer can actually

00:25:34,020 --> 00:25:39,330
evaluate it true even though it's the

00:25:36,690 --> 00:25:43,230
same person because it's just checking

00:25:39,330 --> 00:25:45,710
the identity it's quite easily fixed we

00:25:43,230 --> 00:25:49,020
just used not equals instead of it's not

00:25:45,710 --> 00:25:52,140
in two places of course they should have

00:25:49,020 --> 00:25:55,380
broken this logic out common function

00:25:52,140 --> 00:25:58,500
but that's another step let's just see

00:25:55,380 --> 00:26:01,110
if we can fix it for now so we run our

00:25:58,500 --> 00:26:03,420
test again and you can see it's not

00:26:01,110 --> 00:26:06,870
allowing the illegal trades anymore

00:26:03,420 --> 00:26:09,690
so with these learnings they're swear

00:26:06,870 --> 00:26:11,940
bonk engineers started to look at

00:26:09,690 --> 00:26:13,710
another problem they were having they

00:26:11,940 --> 00:26:17,760
had another part of their business where

00:26:13,710 --> 00:26:21,750
something illegal was happening namely

00:26:17,760 --> 00:26:23,970
some money-laundering protection I'm not

00:26:21,750 --> 00:26:26,190
sure what's happening here so do not

00:26:23,970 --> 00:26:27,780
tell me that do not tell them today

00:26:26,190 --> 00:26:28,770
showed you this software because it's

00:26:27,780 --> 00:26:31,290
top secret

00:26:28,770 --> 00:26:34,130
only enterprise software with security

00:26:31,290 --> 00:26:36,270
clearance so this money laundry

00:26:34,130 --> 00:26:38,610
protection is actually a little bit

00:26:36,270 --> 00:26:42,020
simpler than the previous one but it's

00:26:38,610 --> 00:26:45,630
still Bank software basically they are

00:26:42,020 --> 00:26:48,960
looking for bad accounts in a blacklist

00:26:45,630 --> 00:26:51,690
if it matches the blacklist then it will

00:26:48,960 --> 00:26:53,510
not allow the transfer to go through so

00:26:51,690 --> 00:26:56,640
basically you should not be able to

00:26:53,510 --> 00:27:01,770
transfer money laundered money into this

00:26:56,640 --> 00:27:05,309
way bonk but they are having problems so

00:27:01,770 --> 00:27:07,770
they tried the same approaches and did a

00:27:05,309 --> 00:27:10,230
list of transactions and tried it

00:27:07,770 --> 00:27:12,900
towards a list of blacklist and sure

00:27:10,230 --> 00:27:15,270
enough they had the same problem with

00:27:12,900 --> 00:27:17,700
some special characters in the account

00:27:15,270 --> 00:27:20,610
name or with a longer account name it

00:27:17,700 --> 00:27:23,549
would allow blacklisted accounts to

00:27:20,610 --> 00:27:26,460
actually do transfers to swear bonk so

00:27:23,549 --> 00:27:27,929
of course they allowed illegal trades

00:27:26,460 --> 00:27:30,240
they just didn't know it because they

00:27:27,929 --> 00:27:33,480
had 100% line coverage so they fought

00:27:30,240 --> 00:27:35,299
their code was secure and safe and

00:27:33,480 --> 00:27:37,830
thanks to this they could actually

00:27:35,299 --> 00:27:39,600
quickly try to improve their

00:27:37,830 --> 00:27:41,789
implementation and actually made it more

00:27:39,600 --> 00:27:43,770
pythonic in the way now they're just

00:27:41,789 --> 00:27:46,830
checking if account is not in the

00:27:43,770 --> 00:27:49,919
blacklist and it's actually working so

00:27:46,830 --> 00:27:51,780
there you have it that's how swear bond

00:27:49,919 --> 00:27:53,610
could improve their software using

00:27:51,780 --> 00:28:00,559
property based testing in some simple

00:27:53,610 --> 00:28:03,809
cases ok so I hope you liked the demo

00:28:00,559 --> 00:28:08,240
it's not a real bank but it could be any

00:28:03,809 --> 00:28:10,860
bank conclusion you can write more

00:28:08,240 --> 00:28:14,280
extensive tests much faster you don't

00:28:10,860 --> 00:28:18,150
have to define every test case you can

00:28:14,280 --> 00:28:20,429
find much more bugs and you can crush

00:28:18,150 --> 00:28:22,020
them it's not a silver bullet for all

00:28:20,429 --> 00:28:24,960
testing of course you will have some

00:28:22,020 --> 00:28:26,940
some relay examples and you will have

00:28:24,960 --> 00:28:28,919
some traditional unit tests as well but

00:28:26,940 --> 00:28:31,080
it's a very powerful tool in your belt

00:28:28,919 --> 00:28:34,110
and you should use it to make your

00:28:31,080 --> 00:28:36,840
testing better and you should think

00:28:34,110 --> 00:28:39,539
about defining property is not specific

00:28:36,840 --> 00:28:42,000
examples so my recommendation would be

00:28:39,539 --> 00:28:44,100
just start playing with it just try it

00:28:42,000 --> 00:28:46,740
out and see how it works because it's

00:28:44,100 --> 00:28:49,799
often simpler than most people think

00:28:46,740 --> 00:28:52,590
and if you have any further questions

00:28:49,799 --> 00:28:56,040
you can take them now if we have time

00:28:52,590 --> 00:28:58,440
otherwise send send them to me a Twitter

00:28:56,040 --> 00:29:00,899
or email or pioneer

00:28:58,440 --> 00:29:03,149
channel and if you want to learn more

00:29:00,899 --> 00:29:05,909
you can contact me as well I'm available

00:29:03,149 --> 00:29:09,000
for training or workshops or consulting

00:29:05,909 --> 00:29:10,230
at your companies and yeah and that's

00:29:09,000 --> 00:29:16,200
everything for me

00:29:10,230 --> 00:29:18,090
thank you oh yeah

00:29:16,200 --> 00:29:21,590
do grab a business card for me on the

00:29:18,090 --> 00:29:24,710
way out if you want to talk with me more

00:29:21,590 --> 00:29:24,710
thank you

00:29:28,129 --> 00:29:34,259
I'm just curious to see if couldn't you

00:29:31,679 --> 00:29:38,549
use to implement the unique tests using

00:29:34,259 --> 00:29:41,250
examples in hypothesis sorry the

00:29:38,549 --> 00:29:43,860
question was you you wanted to know if

00:29:41,250 --> 00:29:47,190
you could implement examples with unit

00:29:43,860 --> 00:29:48,629
tests in high P or the opposite it's the

00:29:47,190 --> 00:29:51,240
same thing

00:29:48,629 --> 00:29:53,970
examples are basically I like defining

00:29:51,240 --> 00:29:57,000
some like some traditional unit tests so

00:29:53,970 --> 00:29:58,799
you could use it this way but usually if

00:29:57,000 --> 00:30:00,990
you have a very large suite of tests

00:29:58,799 --> 00:30:03,000
maybe you don't want to run them every

00:30:00,990 --> 00:30:05,340
time with the entire hypothesis library

00:30:03,000 --> 00:30:07,559
because generating all these examples

00:30:05,340 --> 00:30:10,350
could take some time and maybe you want

00:30:07,559 --> 00:30:12,269
to do it faster but in your maybe your

00:30:10,350 --> 00:30:14,490
CI system or something you actually want

00:30:12,269 --> 00:30:21,529
to run the full suite and a full set of

00:30:14,490 --> 00:30:21,529
input yeah any more questions

00:30:25,870 --> 00:30:32,690
it's is this similar to firstly testing

00:30:29,450 --> 00:30:36,560
sorry Susie testing is that like at the

00:30:32,690 --> 00:30:39,280
very first faucet yeah it's very similar

00:30:36,560 --> 00:30:42,590
basically faucet testing is kind of an

00:30:39,280 --> 00:30:44,930
unstructured way of doing property based

00:30:42,590 --> 00:30:47,840
testing so there are fasting tools today

00:30:44,930 --> 00:30:49,640
which do some clever introspection to

00:30:47,840 --> 00:30:52,510
the code and actually tries to trigger

00:30:49,640 --> 00:30:56,690
as many branches as possible like a FL

00:30:52,510 --> 00:30:58,610
but it's not still at the same level as

00:30:56,690 --> 00:31:00,740
defining the actual properties of the

00:30:58,610 --> 00:31:03,590
software so first thing is more about

00:31:00,740 --> 00:31:04,100
your throwing as much random input as

00:31:03,590 --> 00:31:06,770
possible

00:31:04,100 --> 00:31:09,290
and see what happens and property based

00:31:06,770 --> 00:31:11,660
testing is more like this is the way the

00:31:09,290 --> 00:31:13,600
protocol should behave and if you do

00:31:11,660 --> 00:31:19,460
something else then something is wrong

00:31:13,600 --> 00:31:24,710
is that a good answer for you yeah any

00:31:19,460 --> 00:31:27,100
more questions okay if not thank you

00:31:24,710 --> 00:31:27,100
very much

00:31:28,580 --> 00:31:31,690
[Applause]

00:31:36,429 --> 00:31:38,490

YouTube URL: https://www.youtube.com/watch?v=qKHB0Xr-Yjg


