Title: Integrate IoT cloud analytics and over-the-air (OTA) updates with Google and Mender.io - Mirza Krak
Publication date: 2019-04-17
Playlist: foss-north 2019
Description: 
	We will demonstrate how to use and integrate analytics and OTA updates into an IoT product. We will cover the integration of software update management into a Cloud IoT solution that allows you to easily and securely connect, manage, and ingest data from millions of globally dispersed devices, providing a complete solution for collecting, processing, analyzing, and visualizing IoT data in real-time.
In this talk, we will specifically use the integration between Google’s Cloud IoT Core and the Mender open source project. We’ll walk the audience through the following:

   - Overview of device registration in Google IoT Core and Mender
   - IoT device level OTA update services and how it is orchestrated between IoT images (Google Cloud Storage), the Mender OS Build System (Google Compute Engine), and the Mender Management Server (Google Compute Engine)
   - Preauthorization of devices in the Mender Server using the same credentials as IoT Core, keeping the security model robust but simple
   - Central management of your entire IoT data network from a single pane of glass
   - Demo of IoT analytics application with OTA updates in Yocto Project

---

Mirza Krak is an embedded Linux solution specialist with seven years of experience in the field and is currently employed by Northern.tech, the commercial entity behind the Mender project.
Mirza was a Mender community member for a couple of years which led to him joining the Mender project full-time in 2018. He is involved in various other open source projects and is a Linux kernel contributor. Mirza's expertise is within Board Support Package development which ranges from hardware bringup, bootloaders, Linux kernel and build systems (Yocto/OE-core). Mirza has spoken at various conferences including Embedded Linux Conference and FOSS-North.

https://foss-north.se/2019/speakers-and-talks.html#mkrak
Captions: 
	00:00:15,700 --> 00:00:20,650
thank you for joining me today today

00:00:18,400 --> 00:00:23,430
we're going to talk about integrating

00:00:20,650 --> 00:00:26,590
iot-cloud analytics and other updates

00:00:23,430 --> 00:00:29,290
Google and mater and I just wanted to

00:00:26,590 --> 00:00:35,530
get a feeling about how many of you have

00:00:29,290 --> 00:00:37,900
heard of it lots of things and IOT and I

00:00:35,530 --> 00:00:43,840
mean how many can define my ot in one

00:00:37,900 --> 00:00:47,710
sentence what it is I don't know if I

00:00:43,840 --> 00:00:51,850
can make that claim but the session

00:00:47,710 --> 00:00:54,040
overview we're going to talk about over

00:00:51,850 --> 00:00:57,879
where software updates for IOT omit

00:00:54,040 --> 00:01:00,220
matter and how we did a reference

00:00:57,879 --> 00:01:02,799
integration with Google IOT core and

00:01:00,220 --> 00:01:05,290
then this is a presentation on what this

00:01:02,799 --> 00:01:07,390
reference integration what you did there

00:01:05,290 --> 00:01:10,030
no problems we try to solve by doing

00:01:07,390 --> 00:01:12,820
this no loss at the end share there is a

00:01:10,030 --> 00:01:16,080
very detailed tutorial on or be do this

00:01:12,820 --> 00:01:20,740
on the Google cloud community so you can

00:01:16,080 --> 00:01:22,859
do further really and in more detail so

00:01:20,740 --> 00:01:26,530
about me quickly my name is Mira

00:01:22,859 --> 00:01:29,020
primarily titled as a Linux developer

00:01:26,530 --> 00:01:33,100
I'll be working with this in for the

00:01:29,020 --> 00:01:36,250
last eight years primarily development

00:01:33,100 --> 00:01:37,479
in you both the Linux kernel the last

00:01:36,250 --> 00:01:40,600
few years have been working a lot with

00:01:37,479 --> 00:01:44,950
the Yocto and build root systems and

00:01:40,600 --> 00:01:47,320
more integration work and development I

00:01:44,950 --> 00:01:49,780
come from a company or from a project

00:01:47,320 --> 00:01:52,240
called the mandroid on Io which is an

00:01:49,780 --> 00:01:54,850
open-source update solution for embedded

00:01:52,240 --> 00:01:58,109
Linux devices and a open source Apache

00:01:54,850 --> 00:02:02,350
License and supports a different

00:01:58,109 --> 00:02:04,270
variation of update styles I was talking

00:02:02,350 --> 00:02:06,969
about a bit more about it and I just

00:02:04,270 --> 00:02:08,830
want to mention the the northern tech is

00:02:06,969 --> 00:02:10,479
the commercial entity or the company

00:02:08,830 --> 00:02:13,000
behind the vendor on your project so

00:02:10,479 --> 00:02:16,180
that's why my email says as well at

00:02:13,000 --> 00:02:21,690
northern tech is that instead of another

00:02:16,180 --> 00:02:21,690
time and just quickly we are hiring

00:02:21,980 --> 00:02:28,099
interested so internet of things let's

00:02:25,730 --> 00:02:31,610
come back to that definition what it is

00:02:28,099 --> 00:02:34,970
I'm just sourcing Kabylia and you try to

00:02:31,610 --> 00:02:36,260
explain it but in short it means taking

00:02:34,970 --> 00:02:37,930
all the things in the world and

00:02:36,260 --> 00:02:40,940
connecting them to the Internet which

00:02:37,930 --> 00:02:44,090
sounds both exciting and frightening at

00:02:40,940 --> 00:02:47,650
the same time and this is something that

00:02:44,090 --> 00:02:50,629
I mean we are trying to address but

00:02:47,650 --> 00:02:52,280
security and I mean the most thing that

00:02:50,629 --> 00:02:58,069
were connected in internet earlier has

00:02:52,280 --> 00:03:01,370
been servers enterprise with Sarah parks

00:02:58,069 --> 00:03:03,319
data centers and it's fairly well known

00:03:01,370 --> 00:03:06,410
the security practices and there's

00:03:03,319 --> 00:03:09,500
certifications and so on how to do this

00:03:06,410 --> 00:03:12,230
but now anyone can buy a Raspberry Pi

00:03:09,500 --> 00:03:15,470
and connected to the Internet and this

00:03:12,230 --> 00:03:18,609
creates a lot of opportunities but there

00:03:15,470 --> 00:03:24,200
was also a lot of problems and which are

00:03:18,609 --> 00:03:26,720
interesting to solve so I mean once you

00:03:24,200 --> 00:03:29,180
connect all the devices in the world to

00:03:26,720 --> 00:03:31,459
be internet you need to have some way of

00:03:29,180 --> 00:03:32,810
opting the software of these devices

00:03:31,459 --> 00:03:35,450
because now they are exposed to

00:03:32,810 --> 00:03:37,250
everything that's out there so I mean

00:03:35,450 --> 00:03:40,130
there will be bugs in your code that you

00:03:37,250 --> 00:03:43,349
need to fix by doing

00:03:40,130 --> 00:03:45,599
updates they were also over time become

00:03:43,349 --> 00:03:47,880
known when I babysit but one abilities

00:03:45,599 --> 00:03:50,190
in your system and this is not something

00:03:47,880 --> 00:03:53,489
that you can avoid is just how things

00:03:50,190 --> 00:03:55,349
work people find the exploits and they

00:03:53,489 --> 00:03:57,209
are well known over time and if you

00:03:55,349 --> 00:03:59,790
don't fix them your devices are very

00:03:57,209 --> 00:04:03,780
exposed and this is where we see a lot

00:03:59,790 --> 00:04:05,670
of this there's this concept of botnets

00:04:03,780 --> 00:04:10,650
that is keeps growing and that means

00:04:05,670 --> 00:04:12,600
there is like yeah applications or

00:04:10,650 --> 00:04:16,109
scripts that are probing the internet

00:04:12,600 --> 00:04:19,280
for portable devices that are usually

00:04:16,109 --> 00:04:22,410
they probe devices might known as for

00:04:19,280 --> 00:04:25,889
default plugins right and if you haven't

00:04:22,410 --> 00:04:27,990
changed that they try to inject malware

00:04:25,889 --> 00:04:31,590
into these devices and if you use these

00:04:27,990 --> 00:04:33,540
devices they mean the Mirage ultimate

00:04:31,590 --> 00:04:36,000
attack took down the best internet on

00:04:33,540 --> 00:04:38,970
the west coast like took down the sites

00:04:36,000 --> 00:04:40,350
like github ready and so on so I mean

00:04:38,970 --> 00:04:46,650
you can do a lot of things if you

00:04:40,350 --> 00:04:48,690
activate million devices things you also

00:04:46,650 --> 00:04:50,490
want to be able to deploy new features

00:04:48,690 --> 00:04:52,620
obviously if you deploy your devices

00:04:50,490 --> 00:04:54,570
into the field if you have the

00:04:52,620 --> 00:04:58,169
possibility to deploy features over the

00:04:54,570 --> 00:05:01,770
air you can get like faster faster to

00:04:58,169 --> 00:05:05,039
the market and you feel just as you go

00:05:01,770 --> 00:05:07,710
or later on and there are a lot of like

00:05:05,039 --> 00:05:10,229
scary examples that I mean the fight

00:05:07,710 --> 00:05:11,910
price for a recall or it's very common

00:05:10,229 --> 00:05:15,650
to recall cars because there's some

00:05:11,910 --> 00:05:15,650
software bug that needs to be fixed

00:05:17,270 --> 00:05:22,229
solve problems for people and there are

00:05:20,789 --> 00:05:24,330
some challenges when you really are in

00:05:22,229 --> 00:05:27,000
this IOT space and you're connecting

00:05:24,330 --> 00:05:30,479
things and things are as normally not

00:05:27,000 --> 00:05:32,430
something that you have like physical

00:05:30,479 --> 00:05:33,710
access it can be installed in a car

00:05:32,430 --> 00:05:37,490
that's moving

00:05:33,710 --> 00:05:39,380
we distributed devices over the country

00:05:37,490 --> 00:05:41,000
the world and so on so you don't have

00:05:39,380 --> 00:05:42,790
like the physical access if something

00:05:41,000 --> 00:05:47,360
goes wrong if you're not fix it easily

00:05:42,790 --> 00:05:51,170
so you need some and that poses some

00:05:47,360 --> 00:05:53,090
challenges of course I mean and these

00:05:51,170 --> 00:05:56,360
things little things devices are

00:05:53,090 --> 00:05:58,670
normally had long expected lifetime so

00:05:56,360 --> 00:06:00,110
you don't want to have maintenance on

00:05:58,670 --> 00:06:02,900
them so once you install them somewhere

00:06:00,110 --> 00:06:04,610
in a rocking remote location to expect

00:06:02,900 --> 00:06:07,490
it expect it to live for five to ten

00:06:04,610 --> 00:06:10,550
years and that also brings a lot of new

00:06:07,490 --> 00:06:13,810
challenges and another channel that

00:06:10,550 --> 00:06:19,190
unique for this environment is

00:06:13,810 --> 00:06:22,100
unreliable power which might not always

00:06:19,190 --> 00:06:24,770
be there it's installing a car if you

00:06:22,100 --> 00:06:28,670
shut down the core you lose the power to

00:06:24,770 --> 00:06:31,520
your device or if you have a handle

00:06:28,670 --> 00:06:33,560
these kind of cases as well and also a

00:06:31,520 --> 00:06:36,200
gorilla unreliable network if you are

00:06:33,560 --> 00:06:39,800
using 3G connections and you have moving

00:06:36,200 --> 00:06:43,730
vehicles and you are going to get media

00:06:39,800 --> 00:06:46,850
connectivity and and so on there's a lot

00:06:43,730 --> 00:06:49,790
of challenges in there in this space and

00:06:46,850 --> 00:06:52,610
some of the criterias for deploying I

00:06:49,790 --> 00:06:55,820
over-the-air software updates I mean if

00:06:52,610 --> 00:06:58,340
you have a distributed devices around

00:06:55,820 --> 00:07:00,590
the globe and you need to be the

00:06:58,340 --> 00:07:02,990
confidence and the solution that you are

00:07:00,590 --> 00:07:05,510
using you must be robust and secure that

00:07:02,990 --> 00:07:07,790
means if something was wrong and that it

00:07:05,510 --> 00:07:09,200
needs to be some failsafe mechanism so

00:07:07,790 --> 00:07:11,810
you can recover your devices you don't

00:07:09,200 --> 00:07:13,520
know bricked innocence if something goes

00:07:11,810 --> 00:07:15,980
wrong so you have to make that manually

00:07:13,520 --> 00:07:18,230
fly there or sent the technician to fix

00:07:15,980 --> 00:07:20,560
that it should always like go back to

00:07:18,230 --> 00:07:23,570
work in the state if something was wrong

00:07:20,560 --> 00:07:25,540
atomic installation CC is really

00:07:23,570 --> 00:07:28,550
important if you are managing a fleet of

00:07:25,540 --> 00:07:30,200
thousand or 10,000 of devices when you

00:07:28,550 --> 00:07:33,140
deploy an update you want to make sure

00:07:30,200 --> 00:07:35,810
that all of those 10,000 devices got the

00:07:33,140 --> 00:07:39,250
same software organ right now you cannot

00:07:35,810 --> 00:07:41,320
have a like atomic you station means

00:07:39,250 --> 00:07:44,560
it's either installed in full or not at

00:07:41,320 --> 00:07:48,160
all so nothing in between which could

00:07:44,560 --> 00:07:49,900
cause problems because I have a fleet of

00:07:48,160 --> 00:07:54,250
10,000 devices that all had different

00:07:49,900 --> 00:07:57,180
software right so some important

00:07:54,250 --> 00:07:59,410
criteria is automatic installation

00:07:57,180 --> 00:08:01,660
security is a big thing in our or

00:07:59,410 --> 00:08:03,460
important thing in doing this as well so

00:08:01,660 --> 00:08:05,470
you have a need to have some kind of

00:08:03,460 --> 00:08:07,810
secure transport if you're transferring

00:08:05,470 --> 00:08:12,190
a payload from a server to a client

00:08:07,810 --> 00:08:15,160
needs to be encrypted and you also must

00:08:12,190 --> 00:08:16,690
be able to cryptographic the sign your

00:08:15,160 --> 00:08:19,450
pillows if you're saying the Kyoto

00:08:16,690 --> 00:08:21,640
access so the device can verify this a

00:08:19,450 --> 00:08:24,120
node is coming for me and not from a

00:08:21,640 --> 00:08:24,120
third party

00:08:25,680 --> 00:08:30,610
yeah it should also integrate well with

00:08:27,760 --> 00:08:31,540
existing development environments easy

00:08:30,610 --> 00:08:33,880
to get started

00:08:31,540 --> 00:08:35,680
bandwidth consumption if you are in all

00:08:33,880 --> 00:08:40,479
of these devices are connected through a

00:08:35,680 --> 00:08:43,000
3G or 4G or something less then you have

00:08:40,479 --> 00:08:47,500
this restriction on the bandwidth how

00:08:43,000 --> 00:08:49,930
much data you can consume or and one

00:08:47,500 --> 00:08:52,210
thing also that's really put it in its

00:08:49,930 --> 00:08:55,330
downtime during the update so if you

00:08:52,210 --> 00:08:58,300
think about how Android previously does

00:08:55,330 --> 00:09:00,010
that doesn't did that that means you get

00:08:58,300 --> 00:09:02,800
pinged it at yeah there's an update you

00:09:00,010 --> 00:09:05,230
want to reboot it install it and while

00:09:02,800 --> 00:09:11,950
you are doing this install your phone is

00:09:05,230 --> 00:09:14,480
unusable and this can be very important

00:09:11,950 --> 00:09:16,970
use case

00:09:14,480 --> 00:09:19,589
depending on the product if that

00:09:16,970 --> 00:09:21,629
downtime is acceptable that while you

00:09:19,589 --> 00:09:28,859
are doing an update the device is not

00:09:21,629 --> 00:09:33,329
functional and there is this a generic

00:09:28,859 --> 00:09:37,769
coyote update manager workflow every

00:09:33,329 --> 00:09:39,989
solution should have so it should detect

00:09:37,769 --> 00:09:42,089
an update by using a secure Channel

00:09:39,989 --> 00:09:44,819
there should be a built-in capability

00:09:42,089 --> 00:09:49,439
check and which means that if you have a

00:09:44,819 --> 00:09:51,269
different type of devices there should

00:09:49,439 --> 00:09:54,059
be a built-in functionality to make sure

00:09:51,269 --> 00:09:54,929
that the update is targeting a specific

00:09:54,059 --> 00:09:58,999
device

00:09:54,929 --> 00:10:01,109
you cannot deploy a an update to an

00:09:58,999 --> 00:10:03,660
unsupported by Sun breaking it basically

00:10:01,109 --> 00:10:06,239
they have to download which is also done

00:10:03,660 --> 00:10:08,970
securely I need to do integrity checks

00:10:06,239 --> 00:10:11,249
so this is checksum application that's

00:10:08,970 --> 00:10:13,410
verifying the signature and in some

00:10:11,249 --> 00:10:15,509
cases you want to encrypt the payload as

00:10:13,410 --> 00:10:18,360
well so you have to decrypt it on the

00:10:15,509 --> 00:10:22,919
device side before you install it and I

00:10:18,360 --> 00:10:25,110
have the extraction install steps but

00:10:22,919 --> 00:10:26,819
the last episode always be I mean once

00:10:25,110 --> 00:10:28,079
you deploy update there should be some

00:10:26,819 --> 00:10:30,839
kind of sanity check

00:10:28,079 --> 00:10:33,029
did this work it does this new software

00:10:30,839 --> 00:10:35,369
work and doesn't just mean that your

00:10:33,029 --> 00:10:37,259
device starts it could be additional

00:10:35,369 --> 00:10:39,449
checks it doesn't connect to the

00:10:37,259 --> 00:10:41,929
internet again which is quite important

00:10:39,449 --> 00:10:44,850
if like if you're breaking that

00:10:41,929 --> 00:10:46,529
completed again so I mean so the neither

00:10:44,850 --> 00:10:49,829
of these sanity checks when you deploy

00:10:46,529 --> 00:10:51,749
something to your devices and in case

00:10:49,829 --> 00:10:53,279
you're selling the checks fails you

00:10:51,749 --> 00:11:04,009
always should go back to something that

00:10:53,279 --> 00:11:07,249
is a working state and this is very like

00:11:04,009 --> 00:11:09,600
what will you do at vendor we provide a

00:11:07,249 --> 00:11:12,629
end-to-end solution that is open source

00:11:09,600 --> 00:11:15,539
for managing time trying to tackle these

00:11:12,629 --> 00:11:17,339
problems that are every I mean it's it's

00:11:15,539 --> 00:11:19,919
common problems for anyone that's using

00:11:17,339 --> 00:11:21,470
these little devices and we're target

00:11:19,919 --> 00:11:25,049
targeting specifically

00:11:21,470 --> 00:11:27,119
Linux devices and we didn't buy entry

00:11:25,049 --> 00:11:28,709
and also we mean we provide both to like

00:11:27,119 --> 00:11:30,389
a you need a client that you're running

00:11:28,709 --> 00:11:34,709
a device but you're also providing

00:11:30,389 --> 00:11:40,529
management back-end data management - so

00:11:34,709 --> 00:11:42,569
you manage your devices so there's no

00:11:40,529 --> 00:11:46,949
need to global clue several projects to

00:11:42,569 --> 00:11:48,720
just do over things one solution and the

00:11:46,949 --> 00:11:51,029
server can integrate really easily with

00:11:48,720 --> 00:11:54,149
third-party clients or if you have a

00:11:51,029 --> 00:11:56,489
separate software that's

00:11:54,149 --> 00:11:58,019
device management software you can

00:11:56,489 --> 00:11:59,579
integrate with the server using the rest

00:11:58,019 --> 00:12:03,029
of the API it's which are fully exposed

00:11:59,579 --> 00:12:05,029
on the server side and who supports

00:12:03,029 --> 00:12:08,189
different different updating types so I

00:12:05,029 --> 00:12:11,189
come into this this page

00:12:08,189 --> 00:12:12,629
samandar is focused really from the

00:12:11,189 --> 00:12:14,909
beginning we've been focusing on

00:12:12,629 --> 00:12:18,959
something called duality system layout

00:12:14,909 --> 00:12:21,419
updates and to get this robustness and

00:12:18,959 --> 00:12:23,909
to be able to load by something that is

00:12:21,419 --> 00:12:26,850
a working state you basically keep two

00:12:23,909 --> 00:12:30,659
copies of your operating system and in

00:12:26,850 --> 00:12:32,220
this example we have our say USB and I

00:12:30,659 --> 00:12:34,649
say is the running system that is

00:12:32,220 --> 00:12:36,319
currently active and always be is

00:12:34,649 --> 00:12:39,269
inactive so it's not in use at all

00:12:36,319 --> 00:12:42,779
trusting to or it's waiting so when you

00:12:39,269 --> 00:12:44,440
deploy an update you update USB or you

00:12:42,779 --> 00:12:47,529
sent an appointment to

00:12:44,440 --> 00:12:50,079
there must be in this example you reboot

00:12:47,529 --> 00:12:52,839
your device and you switch so let us be

00:12:50,079 --> 00:12:54,579
becomes the active one and if it doesn't

00:12:52,839 --> 00:12:56,500
work you can always go back to what I

00:12:54,579 --> 00:13:00,040
say that because that's the like no

00:12:56,500 --> 00:13:02,610
working state and this is a fully atomic

00:13:00,040 --> 00:13:04,990
and they're like robust approach so

00:13:02,610 --> 00:13:10,660
whatever happens it can always go back

00:13:04,990 --> 00:13:12,910
to the working state or working and

00:13:10,660 --> 00:13:15,040
whatever you can also implement like the

00:13:12,910 --> 00:13:17,230
criteria for successful update is

00:13:15,040 --> 00:13:19,569
different depending on use case or

00:13:17,230 --> 00:13:22,509
different than depending a product so it

00:13:19,569 --> 00:13:25,750
doesn't it's not just like reboot and if

00:13:22,509 --> 00:13:29,430
it's successful you need to you need to

00:13:25,750 --> 00:13:32,139
do implement custom sanity checks that

00:13:29,430 --> 00:13:33,939
that the system is still operating and

00:13:32,139 --> 00:13:36,100
by default the matter with them in the

00:13:33,939 --> 00:13:38,079
client will actually the default path

00:13:36,100 --> 00:13:40,300
here is determined a client is able to

00:13:38,079 --> 00:13:42,160
connect to the server after not they'd

00:13:40,300 --> 00:13:44,290
done it it's gonna mark it as a

00:13:42,160 --> 00:13:48,160
successful otherwise it's gonna look

00:13:44,290 --> 00:13:49,779
like and there's no no like downtime in

00:13:48,160 --> 00:13:52,870
this case so while you are deploying an

00:13:49,779 --> 00:13:54,970
update or say a still active so you just

00:13:52,870 --> 00:13:58,509
write in the update to always be the

00:13:54,970 --> 00:14:00,459
inactive system so the system is fully

00:13:58,509 --> 00:14:01,990
functional during the update and the

00:14:00,459 --> 00:14:04,740
only thing that's necessary to activate

00:14:01,990 --> 00:14:07,300
this new system is to reboot the system

00:14:04,740 --> 00:14:09,189
so depending on how long the reboot

00:14:07,300 --> 00:14:11,620
states that's that your time down time

00:14:09,189 --> 00:14:12,850
of your functionality and this is not

00:14:11,620 --> 00:14:15,040
something that we had meant that I mean

00:14:12,850 --> 00:14:18,790
this is fairly standard in this world

00:14:15,040 --> 00:14:20,529
and this is how Android is doing it

00:14:18,790 --> 00:14:21,130
nowadays or with the newer Android

00:14:20,529 --> 00:14:24,069
releases

00:14:21,130 --> 00:14:25,670
they're also do or and in Chrome OS as

00:14:24,069 --> 00:14:27,920
well this is all they'll be doing

00:14:25,670 --> 00:14:29,600
or very long time it's not something

00:14:27,920 --> 00:14:32,330
like didn't pimenta it's just like

00:14:29,600 --> 00:14:35,420
standard practice and if you want fully

00:14:32,330 --> 00:14:41,600
robust system or you need to help me see

00:14:35,420 --> 00:14:45,260
I just quickly to cover the vendor

00:14:41,600 --> 00:14:48,470
server all the green parts here are

00:14:45,260 --> 00:14:53,090
developed by us and it's all open source

00:14:48,470 --> 00:14:56,780
which is but I'm not going to go too

00:14:53,090 --> 00:14:59,090
much into detail it consists of micro

00:14:56,780 --> 00:15:01,280
services that are connected with each

00:14:59,090 --> 00:15:06,490
other there's a long routine to take the

00:15:01,280 --> 00:15:08,720
babies we store a persistent information

00:15:06,490 --> 00:15:12,050
every all the functionality of the

00:15:08,720 --> 00:15:14,720
server are exposed to restful api you

00:15:12,050 --> 00:15:17,420
can manage devices or manage the server

00:15:14,720 --> 00:15:19,640
create appointments using the api is but

00:15:17,420 --> 00:15:21,790
there's also a dashboard or from time to

00:15:19,640 --> 00:15:24,080
where you can do it and you typically

00:15:21,790 --> 00:15:27,350
when you scale up and you have maybe

00:15:24,080 --> 00:15:29,930
10,000 100,000 devices and you try to

00:15:27,350 --> 00:15:32,960
then probably are gonna move to like

00:15:29,930 --> 00:15:37,070
using the api it's instead of the front

00:15:32,960 --> 00:15:39,380
end and on the server there's always two

00:15:37,070 --> 00:15:46,910
ports that are permanent instead think

00:15:39,380 --> 00:15:49,250
this it's wrong it's HTTP support so you

00:15:46,910 --> 00:15:51,860
should like you using TLS communication

00:15:49,250 --> 00:15:56,180
so you need to have HTTPS support open

00:15:51,860 --> 00:15:58,670
and port 9000 is used to a download the

00:15:56,180 --> 00:16:00,020
image from a decline and there are no

00:15:58,670 --> 00:16:02,870
ports offered on the cleaner on the

00:16:00,020 --> 00:16:07,960
client side because the client Yorba

00:16:02,870 --> 00:16:11,660
clip all the server so there's no like

00:16:07,960 --> 00:16:13,550
bi-directional communication and it's

00:16:11,660 --> 00:16:17,470
also security measure to not keep open

00:16:13,550 --> 00:16:17,470
ports on the device or required

00:16:22,330 --> 00:16:28,070
and I just sort of mentioned something

00:16:25,040 --> 00:16:29,960
that's called in this Google oil T

00:16:28,070 --> 00:16:32,630
integration we've used something and the

00:16:29,960 --> 00:16:37,070
quantity of the project which is a tool

00:16:32,630 --> 00:16:39,350
to create custom Linux distributions and

00:16:37,070 --> 00:16:41,900
this is the primary integration point as

00:16:39,350 --> 00:16:44,120
well for mentors if you are using this

00:16:41,900 --> 00:16:46,310
in your product it's fairly easy to

00:16:44,120 --> 00:16:49,390
integrate member into an existing

00:16:46,310 --> 00:16:53,740
solution and in this reference

00:16:49,390 --> 00:16:56,990
implementation there's different layers

00:16:53,740 --> 00:16:59,540
metal and ER is our standard metal layer

00:16:56,990 --> 00:17:06,890
for integrating it under there's an

00:16:59,540 --> 00:17:09,709
additional layer provided by Google and

00:17:06,890 --> 00:17:11,990
this has no additional applications that

00:17:09,709 --> 00:17:19,810
connect to Google IOT core which I'll

00:17:11,990 --> 00:17:22,339
explain a bit later so Google IOT core

00:17:19,810 --> 00:17:24,260
is a phony a fully managed service that

00:17:22,339 --> 00:17:27,380
allows you to easily and securely

00:17:24,260 --> 00:17:30,920
connect manager just the data from a lot

00:17:27,380 --> 00:17:36,020
of connected devices it supports two

00:17:30,920 --> 00:17:38,360
protocols and utt and HTTP protocols and

00:17:36,020 --> 00:17:39,620
some of the benefits it scales like that

00:17:38,360 --> 00:17:42,440
doesn't matter how many devices you have

00:17:39,620 --> 00:17:45,170
it should like scale automatically and

00:17:42,440 --> 00:17:47,750
it's managed by follow industry standard

00:17:45,170 --> 00:17:52,630
security protocols to protect your data

00:17:47,750 --> 00:17:55,910
and so and this is our like a reference

00:17:52,630 --> 00:17:58,340
implementation of what you have you

00:17:55,910 --> 00:18:02,890
could structure it using the Google IOT

00:17:58,340 --> 00:18:07,550
core so here we have this is the device

00:18:02,890 --> 00:18:10,130
that's collecting the inter from sensors

00:18:07,550 --> 00:18:12,410
from our building or something something

00:18:10,130 --> 00:18:17,270
for me she's collecting some real world

00:18:12,410 --> 00:18:20,180
information and this device is feeding

00:18:17,270 --> 00:18:21,560
that cloud IOT or with this data and

00:18:20,180 --> 00:18:24,200
then you can connect to different

00:18:21,560 --> 00:18:29,000
functions to these days our data to

00:18:24,200 --> 00:18:31,550
store it in a database and so there's

00:18:29,000 --> 00:18:33,070
this different way to workforce that you

00:18:31,550 --> 00:18:36,020
can apply for this later

00:18:33,070 --> 00:18:38,180
and that at the end you are interested

00:18:36,020 --> 00:18:41,450
in analyzing the data or produce reports

00:18:38,180 --> 00:18:45,080
or insights that these devices are

00:18:41,450 --> 00:18:55,100
generally that you can attach insights

00:18:45,080 --> 00:18:57,560
tools to these databases and what in

00:18:55,100 --> 00:19:00,410
more depth like IOT core in itself it's

00:18:57,560 --> 00:19:03,050
protocol bridge so it's connecting the

00:19:00,410 --> 00:19:05,780
devices are communicating with IOT core

00:19:03,050 --> 00:19:09,200
using mqtt and instead of MTT the

00:19:05,780 --> 00:19:14,030
endpoints for it but it's also a device

00:19:09,200 --> 00:19:18,980
manager so you add devices you know

00:19:14,030 --> 00:19:22,240
technical devices so that they were able

00:19:18,980 --> 00:19:26,870
to communicate you in to manage devices

00:19:22,240 --> 00:19:28,610
and I mean connecting devices to

00:19:26,870 --> 00:19:30,560
something and there needs to be some

00:19:28,610 --> 00:19:33,080
carnival authentication workflow right

00:19:30,560 --> 00:19:34,640
because just because a device connects

00:19:33,080 --> 00:19:38,240
the server it's not easy

00:19:34,640 --> 00:19:40,340
immediately or authorized to feed it

00:19:38,240 --> 00:19:42,710
they need our maybe request data

00:19:40,340 --> 00:19:44,480
someone needs to verify that this is a

00:19:42,710 --> 00:19:48,680
trusted device this is something that I

00:19:44,480 --> 00:19:54,150
have produced that's connecting to my

00:19:48,680 --> 00:19:56,370
interface and this is fairly complex or

00:19:54,150 --> 00:19:59,040
it can become very complex and this is

00:19:56,370 --> 00:20:02,010
also if you're using multiple services

00:19:59,040 --> 00:20:04,110
maybe multiple services have their own

00:20:02,010 --> 00:20:05,510
implementation or how this optimization

00:20:04,110 --> 00:20:09,320
workload works

00:20:05,510 --> 00:20:11,730
sunita maybe multiple keys or multiple

00:20:09,320 --> 00:20:13,260
implementations of workflows to

00:20:11,730 --> 00:20:21,050
authorize one device in multiple

00:20:13,260 --> 00:20:23,820
application and I just hope you or how

00:20:21,050 --> 00:20:26,640
device application Google healthy court

00:20:23,820 --> 00:20:29,130
works and it's based on our like kept

00:20:26,640 --> 00:20:32,670
keep here you store the private key on

00:20:29,130 --> 00:20:34,350
your device and it's gonna publish the

00:20:32,670 --> 00:20:36,990
topic he together with the device

00:20:34,350 --> 00:20:39,510
identity to the Google LT device manager

00:20:36,990 --> 00:20:44,430
and someone needs to accept that

00:20:39,510 --> 00:20:47,370
identity ensure that this device is

00:20:44,430 --> 00:20:49,140
trusted and this is just an example

00:20:47,370 --> 00:20:56,250
there are multiple ways of how you can

00:20:49,140 --> 00:21:00,210
do it do this this is and this is a more

00:20:56,250 --> 00:21:02,490
detailed explanation so you joined the

00:21:00,210 --> 00:21:06,090
previous session in this room there was

00:21:02,490 --> 00:21:15,900
a talk about JSON web tokens it's used

00:21:06,090 --> 00:21:17,750
in this case as well so your expert yeah

00:21:15,900 --> 00:21:20,400
but this just explains how the

00:21:17,750 --> 00:21:25,340
communication or authentication workflow

00:21:20,400 --> 00:21:25,340
becomes can become or what it looks like

00:21:27,500 --> 00:21:33,900
but then we go to a vendor which is also

00:21:31,440 --> 00:21:37,290
a server and there's also education

00:21:33,900 --> 00:21:40,560
workflow which is quite similar to all

00:21:37,290 --> 00:21:41,950
Google IOT core works but we have also

00:21:40,560 --> 00:21:45,820
workflows in now

00:21:41,950 --> 00:21:47,380
workflows and you need to have you need

00:21:45,820 --> 00:21:50,380
to authenticate other bodies in two

00:21:47,380 --> 00:21:55,149
locations instead of one but it's

00:21:50,380 --> 00:21:56,830
similar I mean we also use a client keep

00:21:55,149 --> 00:22:00,309
here you have a private key on your

00:21:56,830 --> 00:22:02,799
device and then years about the vise

00:22:00,309 --> 00:22:07,769
identity and the device identity the

00:22:02,799 --> 00:22:07,769
public key or the identity of the device

00:22:07,860 --> 00:22:20,019
and devices need to be accepted and

00:22:12,000 --> 00:22:22,870
server-side what we did in in this

00:22:20,019 --> 00:22:26,769
reference of integration that we did

00:22:22,870 --> 00:22:29,919
with Google IOT core is to simplify this

00:22:26,769 --> 00:22:32,529
authentication workflow so that you

00:22:29,919 --> 00:22:34,899
don't have to authenticate a device into

00:22:32,529 --> 00:22:37,649
location but you can just do it in one I

00:22:34,899 --> 00:22:39,809
mean they are interconnected so that

00:22:37,649 --> 00:22:45,850
information is shared between two

00:22:39,809 --> 00:22:48,789
services and the workflow is the

00:22:45,850 --> 00:22:53,529
integration that we did existing here so

00:22:48,789 --> 00:22:57,220
first you create a device in chlorotic

00:22:53,529 --> 00:23:02,110
worth but the identity and the key

00:22:57,220 --> 00:23:05,980
extracted from the vendor client or the

00:23:02,110 --> 00:23:10,299
key that you have on your devices and so

00:23:05,980 --> 00:23:13,360
instead of manually actually authorize

00:23:10,299 --> 00:23:16,690
it in two locations there is optimal

00:23:13,360 --> 00:23:19,779
thanks to these restful api s you can

00:23:16,690 --> 00:23:22,510
integrate the Google IOT core to call

00:23:19,779 --> 00:23:23,450
the manner API is to authenticate advice

00:23:22,510 --> 00:23:27,370
based on the

00:23:23,450 --> 00:23:30,559
information that's already in IOT core

00:23:27,370 --> 00:23:32,750
so it's once you're registered device in

00:23:30,559 --> 00:23:37,429
IOT core it's automatically and that

00:23:32,750 --> 00:23:39,950
matter server as well and the workflow

00:23:37,429 --> 00:23:40,789
and the second reference implementation

00:23:39,950 --> 00:23:43,159
is that Jenny

00:23:40,789 --> 00:23:49,899
he uses a Google IOT core to collect

00:23:43,159 --> 00:23:52,279
entry and data to send 20 core analyzed

00:23:49,899 --> 00:23:55,240
but with this you city that you can also

00:23:52,279 --> 00:23:58,490
you can utilize this to deploy new

00:23:55,240 --> 00:24:03,010
features to device or if you find

00:23:58,490 --> 00:24:03,010
problems you can extend also it using

00:24:07,750 --> 00:24:11,760
and yeah well chef otherwise that either

00:24:12,179 --> 00:24:23,049
robustly deploy updates based on the

00:24:15,610 --> 00:24:24,850
analysis that you've done today so what

00:24:23,049 --> 00:24:27,640
we would then result is that you have

00:24:24,850 --> 00:24:29,500
only one key pair instead of two so we

00:24:27,640 --> 00:24:34,480
have two services that you're using but

00:24:29,500 --> 00:24:36,880
are sharing the authentication and on

00:24:34,480 --> 00:24:40,780
the device you're like a TT TT client

00:24:36,880 --> 00:24:42,370
that talks to the Google IOT core you

00:24:40,780 --> 00:24:44,799
know my mentor agent or the mentor

00:24:42,370 --> 00:24:50,440
client that talks to the majority a

00:24:44,799 --> 00:24:52,809
server and you have this different

00:24:50,440 --> 00:24:55,299
channels of information flow goals we

00:24:52,809 --> 00:24:57,940
have the telemetry and data plane and

00:24:55,299 --> 00:25:06,549
then you have on this side over-the-air

00:24:57,940 --> 00:25:10,179
updates and web management and the

00:25:06,549 --> 00:25:12,370
actual link to this reference

00:25:10,179 --> 00:25:15,340
integration is there's a very detailed

00:25:12,370 --> 00:25:17,530
step-by-step tutorial on how that this

00:25:15,340 --> 00:25:21,809
is done or you can actually do it

00:25:17,530 --> 00:25:25,750
yourself if you set up ft for instance

00:25:21,809 --> 00:25:28,960
you can in that story impossible to set

00:25:25,750 --> 00:25:30,940
up the minder server running on Google

00:25:28,960 --> 00:25:36,090
IOT cloud as well so you'll have to have

00:25:30,940 --> 00:25:44,730
it like all integrated into one place

00:25:36,090 --> 00:25:44,730
that's that's questions

00:25:47,409 --> 00:25:50,860
it was first

00:25:54,789 --> 00:25:58,940
are you aware about the ietf is doing

00:25:57,710 --> 00:26:02,239
with the suits were to group and are you

00:25:58,940 --> 00:26:06,019
guys participating in us not

00:26:02,239 --> 00:26:11,330
participating not fully a lot have fully

00:26:06,019 --> 00:26:11,720
inside what you're talking what are you

00:26:11,330 --> 00:26:13,480
doing

00:26:11,720 --> 00:26:15,889
so they're they're doing kind of

00:26:13,480 --> 00:26:19,429
designing a premier death restraint

00:26:15,889 --> 00:26:22,279
devices at a workflow for constraint

00:26:19,429 --> 00:26:24,859
yeah our focus has been mostly on button

00:26:22,279 --> 00:26:28,489
Linux devices so which requires a bit

00:26:24,859 --> 00:26:31,429
more power it's easier we have started

00:26:28,489 --> 00:26:34,820
exploring more concentrate devices as

00:26:31,429 --> 00:26:38,559
well the problem currently I guess is

00:26:34,820 --> 00:26:41,419
that fragmentation of there's so many

00:26:38,559 --> 00:26:44,029
places that operating systems

00:26:41,419 --> 00:26:46,340
I guess that are trying to have that

00:26:44,029 --> 00:26:49,159
address that foundation is go to create

00:26:46,340 --> 00:26:57,590
the standard that you can integrate to

00:26:49,159 --> 00:27:01,419
it and an Imagineer a be partitioning we

00:26:57,590 --> 00:27:04,369
should obviously use which makes sense

00:27:01,419 --> 00:27:08,480
you also mentioned that you can uptake

00:27:04,369 --> 00:27:09,889
containers so how does this apply so

00:27:08,480 --> 00:27:12,230
that's in which you would like to update

00:27:09,889 --> 00:27:16,190
just the container or just one component

00:27:12,230 --> 00:27:17,629
do I get a new partition no in that case

00:27:16,190 --> 00:27:20,260
if you are if you want to deploy

00:27:17,629 --> 00:27:22,059
applications or something

00:27:20,260 --> 00:27:25,900
you notice that you're just working with

00:27:22,059 --> 00:27:27,580
the active partition compliance and you

00:27:25,900 --> 00:27:30,730
always have their full image as a

00:27:27,580 --> 00:27:33,010
fallback so in case of something went

00:27:30,730 --> 00:27:35,080
wrong with the container or application

00:27:33,010 --> 00:27:36,669
update then you're just a powerfully

00:27:35,080 --> 00:27:44,770
mentioned and it's going to be deployed

00:27:36,669 --> 00:27:47,380
to always be in this example sorry if

00:27:44,770 --> 00:27:50,080
the little mention you update has one

00:27:47,380 --> 00:27:51,720
component within one of the partitions

00:27:50,080 --> 00:27:55,570
what happens if you don't do a full

00:27:51,720 --> 00:27:59,919
update what happens is they all do you

00:27:55,570 --> 00:28:02,320
move them over do you figure out if they

00:27:59,919 --> 00:28:03,549
can be run water future delete them

00:28:02,320 --> 00:28:08,429
fetch new ones

00:28:03,549 --> 00:28:12,220
I realize this one one blog missing here

00:28:08,429 --> 00:28:14,320
were typically how you have a date a

00:28:12,220 --> 00:28:16,929
petition or where you store like

00:28:14,320 --> 00:28:18,940
persistent information and this is

00:28:16,929 --> 00:28:21,580
information that you want to keep across

00:28:18,940 --> 00:28:25,419
updates or image updates because when

00:28:21,580 --> 00:28:28,360
you do this a B system your operating

00:28:25,419 --> 00:28:31,090
system is basically stateless like root

00:28:28,360 --> 00:28:33,170
filesystem but then you keep a separate

00:28:31,090 --> 00:28:40,220
partition you maybe keep teeth

00:28:33,170 --> 00:28:50,720
across a shared between updates any more

00:28:40,220 --> 00:28:54,770
questions so having two routes part of

00:28:50,720 --> 00:28:59,090
it is obviously the way to go but how do

00:28:54,770 --> 00:29:00,380
you take the bootloader yeah that's and

00:28:59,090 --> 00:29:04,460
we get that question from time to time

00:29:00,380 --> 00:29:06,890
and the bootloader is very application

00:29:04,460 --> 00:29:08,720
specific core project specific I would

00:29:06,890 --> 00:29:13,250
say and that's not something that we can

00:29:08,720 --> 00:29:16,750
cover or create like a generic solution

00:29:13,250 --> 00:29:19,940
for so it's mostly handled case-by-case

00:29:16,750 --> 00:29:23,510
and the company integrates member out

00:29:19,940 --> 00:29:25,100
there I mean because the normal problem

00:29:23,510 --> 00:29:26,900
with the bootloader is you cannot update

00:29:25,100 --> 00:29:30,140
it unless you have some kind of

00:29:26,900 --> 00:29:33,370
redundancy and this you typically need

00:29:30,140 --> 00:29:37,070
to solve it using hardware unless you're

00:29:33,370 --> 00:29:40,130
both code in the processor supports some

00:29:37,070 --> 00:29:48,610
kind of redundancy so it's very

00:29:40,130 --> 00:29:48,610
application specific anyway

00:30:01,620 --> 00:30:09,029
I thank you for a very interesting talk

00:30:04,549 --> 00:30:10,740
you mentioned Google cloud services do

00:30:09,029 --> 00:30:17,630
you have a integration with any other

00:30:10,740 --> 00:30:24,779
plant services not the same fashion I

00:30:17,630 --> 00:30:27,210
mean we run and they're on AWS but it's

00:30:24,779 --> 00:30:34,260
possible this specific integration is

00:30:27,210 --> 00:30:38,870
all Mako glad and now I will turn around

00:30:34,260 --> 00:30:46,610
before asking any more questions

00:30:38,870 --> 00:30:46,610
otherwise I suppose yeah

00:30:50,020 --> 00:30:58,419
it was interesting Brooke think you

00:30:53,380 --> 00:31:01,929
could I ask about sanity testing smoke

00:30:58,419 --> 00:31:06,909
testing that is done before to verify

00:31:01,929 --> 00:31:11,770
that it was right slightly but this

00:31:06,909 --> 00:31:19,000
partition OSBI right and could be wrong

00:31:11,770 --> 00:31:30,520
how how many tests because it is saying

00:31:19,000 --> 00:31:34,419
that it is 1 million testing yeah so I

00:31:30,520 --> 00:31:37,690
mean we do not actually provide any 17

00:31:34,419 --> 00:31:39,640
tests or the default sanity test is that

00:31:37,690 --> 00:31:41,830
the metric client is equal to connect

00:31:39,640 --> 00:31:44,950
them in the server but we do provide

00:31:41,830 --> 00:31:46,600
other ways of extending this so that

00:31:44,950 --> 00:31:49,809
because it's also very application

00:31:46,600 --> 00:31:52,360
specific what you wanted to test is your

00:31:49,809 --> 00:31:55,510
process or application running is it

00:31:52,360 --> 00:31:58,480
connecting to this service and so on so

00:31:55,510 --> 00:32:00,190
we provide ways of extending the custom

00:31:58,480 --> 00:32:09,340
connected sanity checks you can

00:32:00,190 --> 00:32:12,480
implement your own dependence from warm

00:32:09,340 --> 00:32:12,480
up application

00:32:14,820 --> 00:32:18,099
[Music]

00:32:25,320 --> 00:32:30,000
anymore hands otherwise they propose

00:32:27,900 --> 00:32:37,140
would you begin to to mess up

00:32:30,000 --> 00:32:37,140
[Applause]

00:32:42,100 --> 00:32:44,160

YouTube URL: https://www.youtube.com/watch?v=LczA5OduUa0


