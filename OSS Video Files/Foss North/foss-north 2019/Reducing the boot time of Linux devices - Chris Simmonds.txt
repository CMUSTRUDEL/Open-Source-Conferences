Title: Reducing the boot time of Linux devices - Chris Simmonds
Publication date: 2019-04-20
Playlist: foss-north 2019
Description: 
	We all want our devices to boot faster, but how much effort do you want to dedicate to optimizing and maintaining a custom kernel and apps? This presentation offers a graded list of things you can do to reduce boot time. They start with simple changes, such as adjusting the position of your main application the init sequence. Then there are the changes you can make to the kernel and bootloader configuration to speed things up, and finally, there are moderately advanced techniques such as using U-Boot in falcon mode.
All of this is done using standard configuration techniques, with the idea of being able to maintain these changes in the future. I will show the effect of each of these changes on typical a embedded dev board so that you can judge for yourself where on the journey you want to jump off.

---

Chris Simmonds is a software consultant and trainer living in southern England. He has spent almost two decades designing and building open-source embedded systems of all shapes and sizes, and he has encapsulated much of that experience in his book, “Mastering Embedded Linux Programming”.
He is a frequent presenter at open source and embedded conferences, including the Embedded Linux Conference and Embedded World. You can see some of his work on the “Inner Penguin” blog at www.2net.co.uk

https://foss-north.se/2019/speakers-and-talks.html#csimmonds
Captions: 
	00:00:15,730 --> 00:00:22,640
okay so good afternoon and welcome to

00:00:19,340 --> 00:00:27,380
this talk on reducing boot time of Linux

00:00:22,640 --> 00:00:29,000
devices I am Chris Simmons and let me

00:00:27,380 --> 00:00:32,230
just quickly go through this this just

00:00:29,000 --> 00:00:35,840
licensing stuff a little bit about me

00:00:32,230 --> 00:00:38,260
I've been using Linux as an embedded

00:00:35,840 --> 00:00:41,450
operating system for 20 years now and

00:00:38,260 --> 00:00:45,590
Android for about 10 you're often

00:00:41,450 --> 00:00:49,250
finally at conferences such as this and

00:00:45,590 --> 00:00:51,200
I've written a book just to show you

00:00:49,250 --> 00:00:55,700
there is actually quite a good book just

00:00:51,200 --> 00:01:01,240
to say and you can contact me by various

00:00:55,700 --> 00:01:04,280
electronic means so this is a talk about

00:01:01,240 --> 00:01:09,049
Linux devices but so I meaning Linux

00:01:04,280 --> 00:01:10,880
running in some kind of equipment where

00:01:09,049 --> 00:01:13,340
it's the the is the main application so

00:01:10,880 --> 00:01:15,020
I'm talking about things like the

00:01:13,340 --> 00:01:17,390
weighing scales and the supermarket the

00:01:15,020 --> 00:01:22,850
way your bananas or the entertainment

00:01:17,390 --> 00:01:28,249
system in in-flight entertainment that

00:01:22,850 --> 00:01:30,979
kind of thing and almost always boot

00:01:28,249 --> 00:01:33,710
time is an issue these are things that

00:01:30,979 --> 00:01:35,929
are not visibly computers so you turn it

00:01:33,710 --> 00:01:37,850
on you want it to happen straight away

00:01:35,929 --> 00:01:45,289
or at least as close as straight away as

00:01:37,850 --> 00:01:49,759
you can get okay so yeah we can reduce

00:01:45,289 --> 00:01:52,549
boot time we are software engineers so

00:01:49,759 --> 00:01:54,409
we can always twiddle things we can

00:01:52,549 --> 00:02:00,020
always up to Mai's things there is no

00:01:54,409 --> 00:02:04,369
there's no limit to that so the really

00:02:00,020 --> 00:02:06,909
issue is how much effort do you want to

00:02:04,369 --> 00:02:10,789
put into this optimization phase and

00:02:06,909 --> 00:02:14,569
crucially how big a mess will you leave

00:02:10,789 --> 00:02:16,930
when you finished so this is coming from

00:02:14,569 --> 00:02:20,000
the fact that I've worked on a number of

00:02:16,930 --> 00:02:22,580
projects where a lot of time has been

00:02:20,000 --> 00:02:24,500
put into optimizing the boot time but

00:02:22,580 --> 00:02:27,379
it's left a system that is kind of

00:02:24,500 --> 00:02:29,540
unmaintainable so let me just illustrate

00:02:27,379 --> 00:02:33,330
that

00:02:29,540 --> 00:02:36,000
so this is a Reliant Robin three wheeler

00:02:33,330 --> 00:02:36,980
car if you've ever watched Top Gear I'm

00:02:36,000 --> 00:02:39,629
sure you will have seen one of these

00:02:36,980 --> 00:02:43,830
probably being turned over us or blown

00:02:39,629 --> 00:02:47,670
up or something so it has a problem in

00:02:43,830 --> 00:02:48,120
in start-up time zero to 60 miles per

00:02:47,670 --> 00:02:50,099
hour

00:02:48,120 --> 00:02:53,280
you need a calendar rather than a

00:02:50,099 --> 00:02:59,489
stopwatch to measure that okay

00:02:53,280 --> 00:03:02,849
so let's let up tamai is it so it's been

00:02:59,489 --> 00:03:05,069
optimized it can do the the startup much

00:03:02,849 --> 00:03:07,650
more quickly but is it really what you

00:03:05,069 --> 00:03:09,599
want is it maintainable imagine the

00:03:07,650 --> 00:03:13,440
support issues from from a vehicle like

00:03:09,599 --> 00:03:15,510
this so there is a danger of over

00:03:13,440 --> 00:03:21,980
optimizing so what I'm talking about

00:03:15,510 --> 00:03:25,950
here then is how to pragmatically

00:03:21,980 --> 00:03:30,000
improve the the the boot time without

00:03:25,950 --> 00:03:32,040
going to do crazy things and this is

00:03:30,000 --> 00:03:34,709
inspired by a talk by a guy called

00:03:32,040 --> 00:03:37,980
Andrew Murray who has done a number of

00:03:34,709 --> 00:03:39,900
similar talks that I've attended and in

00:03:37,980 --> 00:03:42,630
one of them well in the first one he

00:03:39,900 --> 00:03:45,000
described in extreme detail how you can

00:03:42,630 --> 00:03:49,470
boot a particular application in less

00:03:45,000 --> 00:03:52,319
than one second and then subsequently at

00:03:49,470 --> 00:03:55,859
a later conference he explained that

00:03:52,319 --> 00:03:57,060
whilst that is possible it turned out to

00:03:55,859 --> 00:04:00,989
be not maintainable the particular

00:03:57,060 --> 00:04:02,849
customer that was done for maintain it

00:04:00,989 --> 00:04:04,260
for one product cycle and then they

00:04:02,849 --> 00:04:08,549
found it too hard and they went back to

00:04:04,260 --> 00:04:10,650
much longer boot cycles so I'm

00:04:08,549 --> 00:04:15,000
emphasizing here things that are fairly

00:04:10,650 --> 00:04:18,359
easy to do and can be built into the

00:04:15,000 --> 00:04:21,720
build system so that they will be there

00:04:18,359 --> 00:04:25,560
for the future and the guiding

00:04:21,720 --> 00:04:27,210
principles are measure evaluate modify

00:04:25,560 --> 00:04:29,039
there's no point optimizing something

00:04:27,210 --> 00:04:34,919
until you've measured what it is that

00:04:29,039 --> 00:04:38,280
you're optimizing the examples I'm going

00:04:34,919 --> 00:04:40,919
to be showing are based on a sample

00:04:38,280 --> 00:04:43,360
system which is my favorite little bore

00:04:40,919 --> 00:04:46,240
the the BeagleBone black

00:04:43,360 --> 00:04:50,680
it's a nice little board fairly slow

00:04:46,240 --> 00:04:53,620
processor just a single core and the

00:04:50,680 --> 00:04:56,979
particular implementation I I did was

00:04:53,620 --> 00:05:01,270
based on a Yocto project build and the

00:04:56,979 --> 00:05:02,800
application I'm running is a QT app QT

00:05:01,270 --> 00:05:04,389
for for no particular good reason other

00:05:02,800 --> 00:05:07,560
than I couldn't actually get QT 5 to

00:05:04,389 --> 00:05:09,820
build in the time that I had available I

00:05:07,560 --> 00:05:12,580
went just to make things difficult for

00:05:09,820 --> 00:05:17,580
myself I'm using system D as the init

00:05:12,580 --> 00:05:17,580
daemon rather than plain old system 5

00:05:19,199 --> 00:05:23,320
just a little bit about the measuring

00:05:21,220 --> 00:05:25,930
part of this first then so you couldn't

00:05:23,320 --> 00:05:29,139
measure first I'm going to be talking

00:05:25,930 --> 00:05:32,889
about three different tools grab serial

00:05:29,139 --> 00:05:34,870
boot chart and boot graph they all do

00:05:32,889 --> 00:05:37,449
that they're all good at different

00:05:34,870 --> 00:05:40,360
things so grumps here was really good

00:05:37,449 --> 00:05:42,580
because it simply grabs the serial

00:05:40,360 --> 00:05:46,479
output to the C report of your device

00:05:42,580 --> 00:05:48,039
and add time add timestamps in so no

00:05:46,479 --> 00:05:50,729
modification of software inside the

00:05:48,039 --> 00:05:53,470
device required it gives you a

00:05:50,729 --> 00:05:57,370
broad-brush idea of how long it's taken

00:05:53,470 --> 00:05:59,789
to get to various stages boot chart is

00:05:57,370 --> 00:06:02,440
handy because it gives you a nice

00:05:59,789 --> 00:06:05,669
graphical view of what happens when you

00:06:02,440 --> 00:06:08,699
boot a system up so it's great for

00:06:05,669 --> 00:06:10,930
looking at the the user space start up

00:06:08,699 --> 00:06:12,220
the order in which applications start

00:06:10,930 --> 00:06:16,479
and therefore why doesn't your

00:06:12,220 --> 00:06:19,960
application start sooner and then boot

00:06:16,479 --> 00:06:22,599
graph is a kernel tool for profiling the

00:06:19,960 --> 00:06:26,860
kernel boot up time so I look at all

00:06:22,599 --> 00:06:30,039
three of those in turn these are all

00:06:26,860 --> 00:06:31,900
software approaches to measuring and so

00:06:30,039 --> 00:06:35,139
since you are measuring software with

00:06:31,900 --> 00:06:39,340
software there is some observer effect

00:06:35,139 --> 00:06:40,990
going on here you can get more accurate

00:06:39,340 --> 00:06:43,360
measurements using a little bit of

00:06:40,990 --> 00:06:48,190
hardware so the typical approach here

00:06:43,360 --> 00:06:49,630
would be to use a GPIO pin and twiddle

00:06:48,190 --> 00:06:51,279
that pin up and down when you reach

00:06:49,630 --> 00:06:53,860
certain critical points and the software

00:06:51,279 --> 00:06:55,660
and then you use or oscilloscope or

00:06:53,860 --> 00:06:57,790
logic analyzer

00:06:55,660 --> 00:06:59,590
that when you power on and then you can

00:06:57,790 --> 00:07:02,230
see exactly how long it takes to the

00:06:59,590 --> 00:07:04,360
point at which it triggers it whittles

00:07:02,230 --> 00:07:10,180
the GPIO and that means you've got to a

00:07:04,360 --> 00:07:11,260
particular relevant point I'm not going

00:07:10,180 --> 00:07:15,540
to scribe that any further but I'm just

00:07:11,260 --> 00:07:15,540
saying that that is an option

00:07:16,230 --> 00:07:23,290
so grab cor then first of all nice

00:07:19,180 --> 00:07:25,590
little tool little Python script you

00:07:23,290 --> 00:07:29,050
just run it like this

00:07:25,590 --> 00:07:33,430
so grab serial minus D and the serial

00:07:29,050 --> 00:07:35,710
port on your device on your your your

00:07:33,430 --> 00:07:37,600
host system your laptop or people or PC

00:07:35,710 --> 00:07:39,670
or whatever typically that's gonna be a

00:07:37,600 --> 00:07:44,830
USB port these days so it'd be teaching

00:07:39,670 --> 00:07:46,270
why USB zero in my case minus T because

00:07:44,830 --> 00:07:47,440
we wanted to print timestamps that's

00:07:46,270 --> 00:07:51,040
kind of the whole point of doing this in

00:07:47,440 --> 00:07:53,440
actual fact and then minus M and you

00:07:51,040 --> 00:07:56,140
give a string this is the trigger string

00:07:53,440 --> 00:07:58,090
so it's going to stop it's going to

00:07:56,140 --> 00:08:00,280
start timeing from the point at which

00:07:58,090 --> 00:08:05,020
you seize that string on the serial port

00:08:00,280 --> 00:08:08,560
and then optionally we can log this to a

00:08:05,020 --> 00:08:12,240
file with the - oh boot bit - oh boot

00:08:08,560 --> 00:08:15,340
log and if you log into a file like this

00:08:12,240 --> 00:08:16,900
you need to tell grab serial to close

00:08:15,340 --> 00:08:19,870
the file at some point otherwise you're

00:08:16,900 --> 00:08:23,860
going to lose the last few blocks of

00:08:19,870 --> 00:08:26,830
data so - ether t means it will close

00:08:23,860 --> 00:08:28,930
the file after 30 seconds if you just

00:08:26,830 --> 00:08:31,690
dumping stuff for the console then you

00:08:28,930 --> 00:08:33,430
can miss off the - see in the - oh and

00:08:31,690 --> 00:08:41,169
just see what sir what appears on the

00:08:33,430 --> 00:08:45,580
screen so running that for my demo

00:08:41,169 --> 00:08:49,270
system I see something like this so

00:08:45,580 --> 00:08:54,430
there's the the trigger which is the

00:08:49,270 --> 00:08:58,600
same string as we gate here so that says

00:08:54,430 --> 00:09:00,670
that it actually took 398 microseconds

00:08:58,600 --> 00:09:03,130
to output this string as I think it's

00:09:00,670 --> 00:09:05,800
really speaking from the end of the

00:09:03,130 --> 00:09:08,770
trigger to the end of the line is 398

00:09:05,800 --> 00:09:09,790
microseconds so this column here this is

00:09:08,770 --> 00:09:12,480
the times

00:09:09,790 --> 00:09:16,649
and this column here is the Delta

00:09:12,480 --> 00:09:18,940
between this line and the previous line

00:09:16,649 --> 00:09:22,270
so we can see it's checking that way

00:09:18,940 --> 00:09:24,790
doing staff and I'd left left a bit out

00:09:22,270 --> 00:09:26,860
here and then we get to running the

00:09:24,790 --> 00:09:28,950
application and that took eleven point

00:09:26,860 --> 00:09:34,410
seven five six something or other whoops

00:09:28,950 --> 00:09:34,410
microsecond their seconds actual seconds

00:09:34,950 --> 00:09:41,200
so putting that all together we find

00:09:38,500 --> 00:09:45,190
that the entire boot is I've split it

00:09:41,200 --> 00:09:48,520
into three four eight three phases the

00:09:45,190 --> 00:09:51,130
bootloader then the kernel and then user

00:09:48,520 --> 00:09:57,250
space so putting it all together comes

00:09:51,130 --> 00:09:58,839
to 11.76 ish seconds that's quite a long

00:09:57,250 --> 00:10:01,450
time considering it's not doing a huge

00:09:58,839 --> 00:10:03,250
amount so I'd like to reduce that as

00:10:01,450 --> 00:10:05,800
much as possible

00:10:03,250 --> 00:10:07,510
my initial aim when I was putting this

00:10:05,800 --> 00:10:10,240
presentation together was to do it in

00:10:07,510 --> 00:10:12,130
less than two seconds as you'll see I

00:10:10,240 --> 00:10:19,839
didn't quite achieve that but I got

00:10:12,130 --> 00:10:22,600
quite close oh and I'm gonna do the

00:10:19,839 --> 00:10:25,810
optimization optimizations starting from

00:10:22,600 --> 00:10:28,329
the back starting from the right hand

00:10:25,810 --> 00:10:31,899
side so user space then kernel then you

00:10:28,329 --> 00:10:33,490
boot and that's kind of the logical way

00:10:31,899 --> 00:10:35,470
of doing things it's generally easier to

00:10:33,490 --> 00:10:37,450
do things in user space and

00:10:35,470 --> 00:10:39,070
optimizations here and then skip on to

00:10:37,450 --> 00:10:46,300
looking at the kernel and then skip onto

00:10:39,070 --> 00:10:49,600
you boot the kind of things that you'd

00:10:46,300 --> 00:10:51,910
be looking at when optimizing the the

00:10:49,600 --> 00:10:54,250
user space part of the boot the main

00:10:51,910 --> 00:10:58,600
thing really is optimizing the boot

00:10:54,250 --> 00:10:59,829
script or the boot order itself you

00:10:58,600 --> 00:11:02,290
really want to make sure since this is

00:10:59,829 --> 00:11:04,060
the most important application that a

00:11:02,290 --> 00:11:08,290
niche is going to launch you want to

00:11:04,060 --> 00:11:10,209
make sure it does that's early on other

00:11:08,290 --> 00:11:13,720
things you could look at doing and

00:11:10,209 --> 00:11:16,209
typically do do you can tweak compiler

00:11:13,720 --> 00:11:18,160
settings try different optimization

00:11:16,209 --> 00:11:20,800
levels see which works best on your

00:11:18,160 --> 00:11:22,580
particular processor and combination of

00:11:20,800 --> 00:11:26,960
[Music]

00:11:22,580 --> 00:11:29,700
and you can go to extreme lengths to

00:11:26,960 --> 00:11:33,360
optimize the libraries you can preload

00:11:29,700 --> 00:11:34,230
things you can reorder library segments

00:11:33,360 --> 00:11:36,390
you can do all kinds of crazy things

00:11:34,230 --> 00:11:41,000
each of which will save you a little bit

00:11:36,390 --> 00:11:41,000
of time but I'm not gonna go into that

00:11:42,890 --> 00:11:47,370
before we get to actually doing the

00:11:45,060 --> 00:11:50,160
optimizations then we need to measure

00:11:47,370 --> 00:11:52,440
what it is we're optimizing and for this

00:11:50,160 --> 00:11:53,640
we're going to be using butchart so

00:11:52,440 --> 00:12:05,760
bouchard is a really nice

00:11:53,640 --> 00:12:07,230
general-purpose logging tool yep boot

00:12:05,760 --> 00:12:09,710
cut has very nice general purpose

00:12:07,230 --> 00:12:14,130
logging tool lot of stuff about it here

00:12:09,710 --> 00:12:16,260
if you're using Yocto it's part of their

00:12:14,130 --> 00:12:19,230
packages in Yocto and openembedded for

00:12:16,260 --> 00:12:22,430
that and there's even a little cut-down

00:12:19,230 --> 00:12:22,430
version of this in busybox

00:12:22,730 --> 00:12:28,820
essentially the idea then is that you

00:12:25,950 --> 00:12:32,340
run the boot chart tool instead of in it

00:12:28,820 --> 00:12:34,920
so you change the kernel command line to

00:12:32,340 --> 00:12:38,370
look something like this so that runs

00:12:34,920 --> 00:12:39,600
the boot chant daemon and then once it

00:12:38,370 --> 00:12:42,810
started their daemon running it down

00:12:39,600 --> 00:12:44,660
forks then executes a copy of in it so

00:12:42,810 --> 00:12:47,520
then it boots up as normal

00:12:44,660 --> 00:12:50,040
so then butchart daemon is going to

00:12:47,520 --> 00:12:53,760
capture the data and it will end up

00:12:50,040 --> 00:12:54,780
writing it to this file here by default

00:12:53,760 --> 00:12:58,940
you can change that if you wish but

00:12:54,780 --> 00:12:58,940
that's where it will end up typically

00:12:59,420 --> 00:13:08,310
and then oops and then you run the boot

00:13:05,520 --> 00:13:11,280
chart application which will analyze

00:13:08,310 --> 00:13:13,620
that that boot chart ttg Zed file and

00:13:11,280 --> 00:13:16,950
give you a nice graph as shown briefly

00:13:13,620 --> 00:13:18,690
on the next slide I just want to say you

00:13:16,950 --> 00:13:21,120
are not expected to read what's on the

00:13:18,690 --> 00:13:24,590
slide because it's way too detailed but

00:13:21,120 --> 00:13:27,990
I just like the picture it's really nice

00:13:24,590 --> 00:13:33,300
so this is the kind of thing you get at

00:13:27,990 --> 00:13:35,370
a boot chart if you put on your opera

00:13:33,300 --> 00:13:41,070
glasses you can just about see

00:13:35,370 --> 00:13:42,270
here this is the QT demo program so this

00:13:41,070 --> 00:13:45,150
is the thing that we actually tried to

00:13:42,270 --> 00:13:47,910
run and again if use a little bit of

00:13:45,150 --> 00:13:49,950
imagination that comes out it's

00:13:47,910 --> 00:13:55,190
somewhere ran about eight seconds on

00:13:49,950 --> 00:13:57,980
that timeline at the top there okay and

00:13:55,190 --> 00:14:00,839
the other interesting thing here it is

00:13:57,980 --> 00:14:03,810
in this part here this is showing you

00:14:00,839 --> 00:14:07,050
the CPU usage as it goes through the

00:14:03,810 --> 00:14:09,450
boot process and really you looking for

00:14:07,050 --> 00:14:11,810
a sari blue bar here because that

00:14:09,450 --> 00:14:14,760
indicates that the CPU is 100% busy

00:14:11,810 --> 00:14:22,290
because if it's 100% busy it's doing

00:14:14,760 --> 00:14:23,880
100% of the work and indeed it is so

00:14:22,290 --> 00:14:26,040
it's so see a careful analysis of the

00:14:23,880 --> 00:14:28,190
boot chart shows that cutie demo is not

00:14:26,040 --> 00:14:32,580
started until three point five seconds

00:14:28,190 --> 00:14:34,430
after in it begins that's actually bit

00:14:32,580 --> 00:14:36,540
of a lie let me just say something

00:14:34,430 --> 00:14:38,010
careful and also that of the chart

00:14:36,540 --> 00:14:43,500
actually shows it starts at about eight

00:14:38,010 --> 00:14:46,380
seconds but what I haven't said on the

00:14:43,500 --> 00:14:48,750
slide is that boot chart actually starts

00:14:46,380 --> 00:14:52,200
measuring here from the point at which

00:14:48,750 --> 00:14:54,510
the kernel starts running so we need to

00:14:52,200 --> 00:14:56,240
subtract four point five three seconds

00:14:54,510 --> 00:14:59,610
from the eight point whatever it was and

00:14:56,240 --> 00:15:04,260
that does come out to be three point

00:14:59,610 --> 00:15:06,510
seven eight seconds in other words this

00:15:04,260 --> 00:15:10,250
this this part from here to here is the

00:15:06,510 --> 00:15:13,890
kernel booting this is where system D

00:15:10,250 --> 00:15:15,330
starts up well the numbers are slightly

00:15:13,890 --> 00:15:17,700
off but believe me that that's that's

00:15:15,330 --> 00:15:21,170
that's the true start and so this is

00:15:17,700 --> 00:15:21,170
three point whatever it was seconds in

00:15:24,860 --> 00:15:29,690
so we need to move it up the batting

00:15:28,170 --> 00:15:33,270
order apologize for this this is a

00:15:29,690 --> 00:15:35,880
English sporting metaphor relating to

00:15:33,270 --> 00:15:37,320
cricket I'm assuming not many people

00:15:35,880 --> 00:15:39,690
here play crickets though that probably

00:15:37,320 --> 00:15:43,410
doesn't really work nevermind you can

00:15:39,690 --> 00:15:46,920
imagine what it means so we need to make

00:15:43,410 --> 00:15:48,840
it to happen sooner and this isn't too

00:15:46,920 --> 00:15:50,460
difficult to do you just need to try

00:15:48,840 --> 00:15:54,720
change the way that your own it demon

00:15:50,460 --> 00:15:56,970
works so if you're using system 5 in it

00:15:54,720 --> 00:16:04,110
system 5 in it starts things in the

00:15:56,970 --> 00:16:06,660
order of the s scripts so s 0 1 will be

00:16:04,110 --> 00:16:09,600
the first thing that started and s 99

00:16:06,660 --> 00:16:12,030
will be the last thing so just move it

00:16:09,600 --> 00:16:15,750
up to a higher number for example s 0 1

00:16:12,030 --> 00:16:18,210
will get you there if you're using

00:16:15,750 --> 00:16:20,340
system D you can do something so much

00:16:18,210 --> 00:16:23,280
similar you need to change the

00:16:20,340 --> 00:16:26,100
dependency in the service unit for the

00:16:23,280 --> 00:16:27,660
thing that starts your service and I've

00:16:26,100 --> 00:16:29,730
got an example of how to do that at the

00:16:27,660 --> 00:16:31,830
end of the slides which we may or may

00:16:29,730 --> 00:16:35,670
not get on - depending on how much time

00:16:31,830 --> 00:16:37,650
we have spare so you can do either of

00:16:35,670 --> 00:16:40,710
those things in fact what I actually did

00:16:37,650 --> 00:16:44,640
do in the example is I cheated

00:16:40,710 --> 00:16:46,740
completely and I actually changed it to

00:16:44,640 --> 00:16:50,550
run my program first and then in its

00:16:46,740 --> 00:16:53,940
second so the Qt demo starts up and then

00:16:50,550 --> 00:16:57,380
I start in it that guarantees I get the

00:16:53,940 --> 00:16:57,380
first bite of the cookie

00:16:58,970 --> 00:17:05,370
there are downsizing doing this if the

00:17:02,730 --> 00:17:07,590
earlier you are in the init a sequence

00:17:05,370 --> 00:17:11,220
the less of the system that is actually

00:17:07,590 --> 00:17:13,500
working so if you do as I've done here

00:17:11,220 --> 00:17:16,020
and you start up before in it runs it

00:17:13,500 --> 00:17:17,970
means that probably that your root

00:17:16,020 --> 00:17:21,720
filesystem is going to be read-only at

00:17:17,970 --> 00:17:23,070
this point there may not that the dev

00:17:21,720 --> 00:17:25,800
directory may not have been populated

00:17:23,070 --> 00:17:29,580
yet and various other things may not

00:17:25,800 --> 00:17:31,320
have worked yet so it depends how much

00:17:29,580 --> 00:17:32,940
of the system you expect to be working

00:17:31,320 --> 00:17:35,250
at the point at which your application

00:17:32,940 --> 00:17:37,790
starts if you simply want to display

00:17:35,250 --> 00:17:40,500
something on the screen and be able to

00:17:37,790 --> 00:17:47,040
start accepting some kind of input then

00:17:40,500 --> 00:17:52,610
this works fine so the way to do that is

00:17:47,040 --> 00:17:58,320
with a little shell script like this so

00:17:52,610 --> 00:18:01,620
I called it run QT demo and so this is

00:17:58,320 --> 00:18:02,730
run in place of an X so we put in it

00:18:01,620 --> 00:18:05,150
equals

00:18:02,730 --> 00:18:06,929
cutie demo on the colonel command line

00:18:05,150 --> 00:18:09,210
runs this script

00:18:06,929 --> 00:18:14,190
this is grip then is being run instead

00:18:09,210 --> 00:18:17,160
of in it so this is PID 1 this line here

00:18:14,190 --> 00:18:20,520
is going to run a copy of my program QT

00:18:17,160 --> 00:18:24,000
demo the ampersand means it will fork a

00:18:20,520 --> 00:18:26,490
new a new process so that will run with

00:18:24,000 --> 00:18:30,780
a different PID ok

00:18:26,490 --> 00:18:33,900
and then I exact in it so that means

00:18:30,780 --> 00:18:35,400
that I now run in it still as PID 1 and

00:18:33,900 --> 00:18:38,210
it turns out that it's important

00:18:35,400 --> 00:18:40,620
actually that in it runs with PID 1

00:18:38,210 --> 00:18:48,419
various things will go wrong if in it

00:18:40,620 --> 00:18:50,340
isn't the ID 1 this little bit here is a

00:18:48,419 --> 00:18:54,960
bit of a hack

00:18:50,340 --> 00:18:57,360
but if you run in it immediately after

00:18:54,960 --> 00:18:59,250
running your your application then in it

00:18:57,360 --> 00:19:04,049
comes along and it starts stealing CPU

00:18:59,250 --> 00:19:06,660
cycles from you so this little sleep

00:19:04,049 --> 00:19:10,470
here is to give this a head start so

00:19:06,660 --> 00:19:14,429
that it gets guess it's initialization

00:19:10,470 --> 00:19:16,110
done before we run the unit program ok

00:19:14,429 --> 00:19:18,390
so this this number here is somewhat

00:19:16,110 --> 00:19:24,240
empirical you'll have to tweak that

00:19:18,390 --> 00:19:27,780
somewhat ok so that guarantees that we

00:19:24,240 --> 00:19:29,970
get started early on and good news is

00:19:27,780 --> 00:19:31,919
we've saved 3 and a half seconds off the

00:19:29,970 --> 00:19:35,390
boot time because now the users base

00:19:31,919 --> 00:19:38,970
boot up is almost nothing so that's nice

00:19:35,390 --> 00:19:42,360
so that's good so we're down to just a

00:19:38,970 --> 00:19:44,640
little over 8 seconds so we're getting

00:19:42,360 --> 00:19:46,530
there you can kind of see by the way

00:19:44,640 --> 00:19:49,020
that of course there's no magic bullet

00:19:46,530 --> 00:19:50,580
were to do this it is a question when

00:19:49,020 --> 00:19:53,400
you're optimizing boot time to look at

00:19:50,580 --> 00:20:02,910
each element and optimize each one

00:19:53,400 --> 00:20:06,030
individually ah the next thing then is

00:20:02,910 --> 00:20:11,580
the kernel so what kind of thing could

00:20:06,030 --> 00:20:13,320
we expect to do here ok well there's one

00:20:11,580 --> 00:20:15,299
very simple thing to do actually this is

00:20:13,320 --> 00:20:19,770
this quiet thing this is a handy little

00:20:15,299 --> 00:20:22,980
little easy win most embedded devices

00:20:19,770 --> 00:20:25,500
have a serial port for the console so

00:20:22,980 --> 00:20:28,080
all the staff that Linux prints out as

00:20:25,500 --> 00:20:31,799
it boots up goes to a serial console

00:20:28,080 --> 00:20:36,540
typically a we running at 115 200 board

00:20:31,799 --> 00:20:39,470
that's quite slow so just outputting all

00:20:36,540 --> 00:20:42,450
that stuff slows things down quite a lot

00:20:39,470 --> 00:20:45,570
you can simply add Quietus to the kernel

00:20:42,450 --> 00:20:47,820
command line to vastly reduce the amount

00:20:45,570 --> 00:20:54,350
of stuff that it prints out and that can

00:20:47,820 --> 00:20:54,350
be a big win other things you can do

00:20:55,370 --> 00:21:01,140
typically well the time you got to this

00:20:57,510 --> 00:21:03,390
point here if you're just using the the

00:21:01,140 --> 00:21:06,690
kernel configuration that was that you

00:21:03,390 --> 00:21:08,549
had with your dev board or whatever you

00:21:06,690 --> 00:21:11,280
got it from probably there is more

00:21:08,549 --> 00:21:13,980
functionality enabled in the kernel than

00:21:11,280 --> 00:21:17,880
you really need and each one of those

00:21:13,980 --> 00:21:19,919
device drivers takes time to to

00:21:17,880 --> 00:21:22,380
initialize plus it takes time to

00:21:19,919 --> 00:21:26,299
actually load the kernel into memory and

00:21:22,380 --> 00:21:28,790
decompress it so it's worthwhile

00:21:26,299 --> 00:21:32,630
optimizing the kernel configuration and

00:21:28,790 --> 00:21:36,270
chopping that stuff that you don't need

00:21:32,630 --> 00:21:37,860
you can do something similar by instead

00:21:36,270 --> 00:21:40,080
of hacking at the kernel you can hack at

00:21:37,860 --> 00:21:42,270
the device tree and you can just go

00:21:40,080 --> 00:21:45,540
through the device tree and just prune

00:21:42,270 --> 00:21:48,659
out any branches that don't do anything

00:21:45,540 --> 00:21:51,299
useful but of course doing it through

00:21:48,659 --> 00:21:54,270
the device tree doesn't reduce the size

00:21:51,299 --> 00:21:56,340
of the kernel so you still you you're

00:21:54,270 --> 00:21:58,350
gaining by not initializing so quite so

00:21:56,340 --> 00:22:00,720
many device drivers but you don't get

00:21:58,350 --> 00:22:04,549
the gain of reducing the size of the

00:22:00,720 --> 00:22:04,549
load into memory in the first place

00:22:05,330 --> 00:22:12,200
another thing you can do that's it says

00:22:08,580 --> 00:22:12,200
tricky here is not hugely tricky but

00:22:12,409 --> 00:22:16,800
some did

00:22:14,160 --> 00:22:18,630
drivers have we're all device drivers

00:22:16,800 --> 00:22:20,910
have a probe function which is called by

00:22:18,630 --> 00:22:23,310
the carnal to interrogate the hardware

00:22:20,910 --> 00:22:25,530
and see what's there and sometimes there

00:22:23,310 --> 00:22:28,440
are timeouts involved in checking if a

00:22:25,530 --> 00:22:31,410
piece of hardware is there quite often

00:22:28,440 --> 00:22:34,770
you can go through and optimize these

00:22:31,410 --> 00:22:36,960
things out but this is modifying the

00:22:34,770 --> 00:22:39,810
kernel code so it's not so maintainable

00:22:36,960 --> 00:22:47,040
and it requires a degree of skill of

00:22:39,810 --> 00:22:49,110
knowing which bits to to optimize again

00:22:47,040 --> 00:22:53,010
before we start hanging around we need

00:22:49,110 --> 00:22:57,480
to do some measurements so for this I'm

00:22:53,010 --> 00:23:02,070
going to introduce you to boot graph so

00:22:57,480 --> 00:23:06,060
boot graph is a kernel feature you turn

00:23:02,070 --> 00:23:08,280
it on just by you need to turn on these

00:23:06,060 --> 00:23:09,930
two things conflict print K time config

00:23:08,280 --> 00:23:13,340
okay or sims in your kernel

00:23:09,930 --> 00:23:17,190
configuration if they're not already and

00:23:13,340 --> 00:23:21,900
you need to boot up with in it called

00:23:17,190 --> 00:23:29,200
debug on the kernel command line so that

00:23:21,900 --> 00:23:31,880
will somebody get a phone call that will

00:23:29,200 --> 00:23:36,180
[Music]

00:23:31,880 --> 00:23:41,220
that will instrument the the output to

00:23:36,180 --> 00:23:42,030
the to the console and then you can take

00:23:41,220 --> 00:23:45,180
a copy of that

00:23:42,030 --> 00:23:47,940
so D message by a redirect to boot that

00:23:45,180 --> 00:23:53,340
log copy that back to your development

00:23:47,940 --> 00:23:55,740
PC and you then run this script will

00:23:53,340 --> 00:23:58,680
take your boot log file and generate an

00:23:55,740 --> 00:24:01,860
SVG file and then you can then you can

00:23:58,680 --> 00:24:06,450
display the SVG file and you'll see

00:24:01,860 --> 00:24:09,000
something like this so this is the

00:24:06,450 --> 00:24:11,760
actual one I got for the Beagle bone

00:24:09,000 --> 00:24:14,760
this by the way is not the entire file

00:24:11,760 --> 00:24:18,240
it goes on beyond there but III

00:24:14,760 --> 00:24:20,510
truncated it at this point but one big

00:24:18,240 --> 00:24:24,510
thing jumps out at you which is this big

00:24:20,510 --> 00:24:26,600
bluish color bar here which is taking

00:24:24,510 --> 00:24:29,430
almost two seconds

00:24:26,600 --> 00:24:32,460
so what is that so

00:24:29,430 --> 00:24:34,620
I rotated my head through 90 degrees and

00:24:32,460 --> 00:24:37,980
got a microscope and read that text

00:24:34,620 --> 00:24:44,370
there and it says raid six select I'll

00:24:37,980 --> 00:24:48,720
go WTF what's that doing there this is

00:24:44,370 --> 00:24:50,100
the rate device so I did a bit of grep

00:24:48,720 --> 00:24:52,920
in a bit of googling and a bit of

00:24:50,100 --> 00:24:57,240
scratching of the head and I eventually

00:24:52,920 --> 00:25:00,570
discovered that rage 6 raid 6 select

00:24:57,240 --> 00:25:09,090
algo is there because of a configuration

00:25:00,570 --> 00:25:10,680
option btrfs butter FS FS and butter

00:25:09,090 --> 00:25:12,480
affair was only enabled because this was

00:25:10,680 --> 00:25:14,460
a generic carnal so it's just one of the

00:25:12,480 --> 00:25:18,450
many fast systems I could possibly have

00:25:14,460 --> 00:25:20,880
used on my BeagleBone black well I'm not

00:25:18,450 --> 00:25:25,350
using it and so I don't need to spend

00:25:20,880 --> 00:25:27,420
two seconds for it not to do anything so

00:25:25,350 --> 00:25:34,290
this is easy we just scrape out butter

00:25:27,420 --> 00:25:36,240
FS and throw the toast on the floor so I

00:25:34,290 --> 00:25:42,630
did that so that's the big way and that

00:25:36,240 --> 00:25:44,220
saves me 108 is so 1.8 seconds I was had

00:25:42,630 --> 00:25:48,090
acquired to the command line that saved

00:25:44,220 --> 00:25:50,130
me 700 milliseconds and then I spent a

00:25:48,090 --> 00:25:53,070
happy hour or so hacking away at the

00:25:50,130 --> 00:25:55,680
kernel configuration and I managed to

00:25:53,070 --> 00:26:00,410
slim it down from 5 point 6 megabytes to

00:25:55,680 --> 00:26:03,960
3.2 and I saved myself 450 milliseconds

00:26:00,410 --> 00:26:05,400
cool so all together

00:26:03,960 --> 00:26:07,830
add those together numbers together I

00:26:05,400 --> 00:26:09,960
hope that comes to actually doesn't been

00:26:07,830 --> 00:26:12,350
ever mind it comes to just over three

00:26:09,960 --> 00:26:12,350
seconds

00:26:17,490 --> 00:26:21,549
there's a there's a slight missing there

00:26:19,510 --> 00:26:25,419
nevermind so that's good so we're

00:26:21,549 --> 00:26:29,760
getting there so that leaves one more

00:26:25,419 --> 00:26:29,760
area to look at which is the bootloader

00:26:30,299 --> 00:26:33,580
the bootloader we're using here is you

00:26:33,159 --> 00:26:36,580
boot

00:26:33,580 --> 00:26:38,740
so most embedded devices use you boot or

00:26:36,580 --> 00:26:42,490
at least aren't most ARM based embedded

00:26:38,740 --> 00:26:45,250
devices you to boot so kind of things

00:26:42,490 --> 00:26:48,279
you can do with you boot there's one

00:26:45,250 --> 00:26:50,519
rather trivial thing you can do the

00:26:48,279 --> 00:26:53,230
default configuration at most you boot

00:26:50,519 --> 00:26:56,440
installations actually has a delay for a

00:26:53,230 --> 00:26:59,260
number seconds and during that delay you

00:26:56,440 --> 00:27:01,330
can press a usually the spacebar and it

00:26:59,260 --> 00:27:02,740
gives you a you brute you boot command

00:27:01,330 --> 00:27:05,549
prompt and then you can do an

00:27:02,740 --> 00:27:07,240
interactive session with you boot

00:27:05,549 --> 00:27:15,399
obviously we don't need that on a

00:27:07,240 --> 00:27:19,110
production system also you boot has its

00:27:15,399 --> 00:27:21,279
own command language and the default

00:27:19,110 --> 00:27:23,769
configuration of you boot typically will

00:27:21,279 --> 00:27:28,260
try lots of different ways of loading a

00:27:23,769 --> 00:27:28,260
kernel and a device tree and a ram disk

00:27:28,320 --> 00:27:35,649
so we could look at optimizing that

00:27:31,149 --> 00:27:37,120
sequence and then if you want to go a

00:27:35,649 --> 00:27:40,120
step further there is a thing called

00:27:37,120 --> 00:27:42,190
Falcon mode which I won't describe

00:27:40,120 --> 00:27:44,740
further here but again at the end of the

00:27:42,190 --> 00:27:48,789
slides there is a description of Falcon

00:27:44,740 --> 00:27:51,490
mode and I give you the commands to run

00:27:48,789 --> 00:27:55,320
you boot in Falcon mode on the

00:27:51,490 --> 00:27:56,700
BeagleBone and that would in itself save

00:27:55,320 --> 00:27:59,230
mm-hmm

00:27:56,700 --> 00:28:00,880
we're talking hundreds of milliseconds

00:27:59,230 --> 00:28:07,750
we're not talking seconds here but it

00:28:00,880 --> 00:28:11,250
does make a saving so first one then

00:28:07,750 --> 00:28:15,549
this one's really really easy we need to

00:28:11,250 --> 00:28:17,380
disable the boot delay so this is what

00:28:15,549 --> 00:28:19,450
you see on the screen press space to

00:28:17,380 --> 00:28:21,429
abort order boat in two seconds you then

00:28:19,450 --> 00:28:23,740
have two seconds set their space bar if

00:28:21,429 --> 00:28:25,809
you do that you go into interactive mode

00:28:23,740 --> 00:28:28,059
and you can talk to you boot otherwise

00:28:25,809 --> 00:28:30,840
it goes into auto boot mode and loads

00:28:28,059 --> 00:28:30,840
the kernel

00:28:31,420 --> 00:28:37,150
we can just type set end boot delay zero

00:28:33,760 --> 00:28:41,410
and save NF and that sets it to zero

00:28:37,150 --> 00:28:43,930
seconds so we won't see this as a mind

00:28:41,410 --> 00:28:46,660
of interest you can still hit the

00:28:43,930 --> 00:28:47,830
spacebar if you're quick enough so as

00:28:46,660 --> 00:28:50,500
long as you hit the space bar within

00:28:47,830 --> 00:28:54,880
zero seconds you can still get a command

00:28:50,500 --> 00:28:56,560
prompt actually it's a slight cheat

00:28:54,880 --> 00:28:58,450
actually if you press the space bar

00:28:56,560 --> 00:29:02,170
after you boot has initialized but

00:28:58,450 --> 00:29:04,390
before it reads the the input the space

00:29:02,170 --> 00:29:07,090
bar character will be in the input

00:29:04,390 --> 00:29:11,280
buffer and it will read it so you

00:29:07,090 --> 00:29:11,280
actually are doing it before zero

00:29:11,400 --> 00:29:17,650
anyhow so this is nice low-hanging fruit

00:29:14,290 --> 00:29:23,620
fruit that saves us two seconds without

00:29:17,650 --> 00:29:26,500
too much effort the other thing that I

00:29:23,620 --> 00:29:27,670
looked at is the set of Buddha scripts

00:29:26,500 --> 00:29:29,740
particularly for the BeagleBone black

00:29:27,670 --> 00:29:31,630
which are quite complex because there

00:29:29,740 --> 00:29:33,190
are a lot of different configurations

00:29:31,630 --> 00:29:36,130
depending which capes you've got plugged

00:29:33,190 --> 00:29:44,730
in and whether you're booting from SSD

00:29:36,130 --> 00:29:47,920
or mm-mm C or whatever so the default

00:29:44,730 --> 00:29:50,110
you boot scripts look like this well

00:29:47,920 --> 00:29:53,280
this is the first 21 lines

00:29:50,110 --> 00:29:55,480
I am it'ld the remaining hundred lines

00:29:53,280 --> 00:29:57,460
so there's a lot of stuff going on here

00:29:55,480 --> 00:29:59,740
each one of these is going to take some

00:29:57,460 --> 00:30:04,060
time to execute even if it's a small

00:29:59,740 --> 00:30:07,210
amount of time it still is some time so

00:30:04,060 --> 00:30:08,350
I decided that I would just blow all

00:30:07,210 --> 00:30:10,450
this other way because it doesn't do

00:30:08,350 --> 00:30:14,860
anything that I really need and I

00:30:10,450 --> 00:30:20,920
replaced 100 122 lines of code with four

00:30:14,860 --> 00:30:24,280
lines because this is all I need to load

00:30:20,920 --> 00:30:33,220
and run the BeagleBone in the particular

00:30:24,280 --> 00:30:34,930
environment that I want so that saved me

00:30:33,220 --> 00:30:38,350
two seconds from getting rid of the boot

00:30:34,930 --> 00:30:44,490
delay 230 milliseconds from optimizing

00:30:38,350 --> 00:30:44,490
the boot scripts so this is my final

00:30:45,450 --> 00:30:52,720
measurement so now we have a little over

00:30:50,500 --> 00:30:55,000
a second a little under a second in the

00:30:52,720 --> 00:30:57,250
bootloader one and a half seconds

00:30:55,000 --> 00:31:00,580
loading the carnal and then almost no

00:30:57,250 --> 00:31:03,130
time loading user space so put it all

00:31:00,580 --> 00:31:07,090
together that comes to 2.6 1 seconds

00:31:03,130 --> 00:31:09,970
which isn't quite my 2 second target but

00:31:07,090 --> 00:31:13,000
it's it's close enough for there for the

00:31:09,970 --> 00:31:14,890
purposes of this talk so if I want to go

00:31:13,000 --> 00:31:17,080
further I would I would obviously need

00:31:14,890 --> 00:31:18,429
to look further at optimizing the kernel

00:31:17,080 --> 00:31:20,679
one and a half seconds to boot account

00:31:18,429 --> 00:31:22,330
Ollie's quite a long time I would have

00:31:20,679 --> 00:31:26,890
to start hacking out some more stuff I

00:31:22,330 --> 00:31:29,020
think and by switching to using Falcon

00:31:26,890 --> 00:31:31,799
mode for the u4u boot I could probably

00:31:29,020 --> 00:31:36,429
get down back down to 500 milliseconds

00:31:31,799 --> 00:31:38,140
so illustrates however that you have

00:31:36,429 --> 00:31:40,750
this this law of diminishing returns

00:31:38,140 --> 00:31:43,120
that once you got to this point here you

00:31:40,750 --> 00:31:45,100
you've done all the simple things it

00:31:43,120 --> 00:31:56,250
gets harder and harder and harder to

00:31:45,100 --> 00:31:58,690
make it go still faster how we doing ok

00:31:56,250 --> 00:32:02,440
yeah so that's that's the main part of

00:31:58,690 --> 00:32:05,409
it then so conclusion boot time

00:32:02,440 --> 00:32:08,500
reduction is one of these things that

00:32:05,409 --> 00:32:11,380
gets incremental more difficult the more

00:32:08,500 --> 00:32:14,320
time you want to optimize but the simple

00:32:11,380 --> 00:32:15,760
things I've gone through possibly with

00:32:14,320 --> 00:32:20,110
exception of the Falcon though think

00:32:15,760 --> 00:32:22,690
they're eminently scriptable and they

00:32:20,110 --> 00:32:25,690
don't impact the the maintained

00:32:22,690 --> 00:32:28,510
maintenance going forwards of your

00:32:25,690 --> 00:32:31,270
system the more of course you hack

00:32:28,510 --> 00:32:32,289
around at at the code level the more

00:32:31,270 --> 00:32:36,450
maintenance problems you're going to

00:32:32,289 --> 00:32:36,450
have so we're trying to avoid that oh

00:32:37,830 --> 00:32:45,520
and look to the future there the point I

00:32:41,530 --> 00:32:47,799
want to make there is that once you've

00:32:45,520 --> 00:32:50,980
done this so what typically happens is

00:32:47,799 --> 00:32:52,840
that somewhere late in the product

00:32:50,980 --> 00:32:54,400
development somebody realizes that boot

00:32:52,840 --> 00:32:57,460
time is an issue so we go through all

00:32:54,400 --> 00:32:59,020
this stuff and we optimize it and then

00:32:57,460 --> 00:33:00,580
once the optimization is

00:32:59,020 --> 00:33:02,110
done typically the team that did that

00:33:00,580 --> 00:33:02,500
sort of disappears often to something

00:33:02,110 --> 00:33:05,200
else

00:33:02,500 --> 00:33:07,920
and then you get into the bit rot phase

00:33:05,200 --> 00:33:11,620
where people make changes here and there

00:33:07,920 --> 00:33:13,900
people add-on functions new features and

00:33:11,620 --> 00:33:17,830
whatever each one of which increases the

00:33:13,900 --> 00:33:22,540
boot time again so this isn't a one-shot

00:33:17,830 --> 00:33:24,550
you have to do this on a regular basis

00:33:22,540 --> 00:33:28,450
in order to make sure that you don't

00:33:24,550 --> 00:33:30,070
slip back to where you were okay so it's

00:33:28,450 --> 00:33:37,510
on it's an ongoing process of what I'm

00:33:30,070 --> 00:33:38,830
trying to say okay so that's the main

00:33:37,510 --> 00:33:40,840
bit are there I've got a few more slides

00:33:38,830 --> 00:33:44,260
after this which I'll briefly go through

00:33:40,840 --> 00:33:46,120
and then we'll do the Q&A bit but let me

00:33:44,260 --> 00:33:50,170
just say then that the slides are

00:33:46,120 --> 00:33:55,900
available on SlideShare and I'll I'll

00:33:50,170 --> 00:33:59,020
tweet that URL shortly and the remainder

00:33:55,900 --> 00:34:03,550
of this slide is is a blatant plug I've

00:33:59,020 --> 00:34:05,770
got to say but this is basically part of

00:34:03,550 --> 00:34:08,560
what I do for my day job I rent training

00:34:05,770 --> 00:34:10,419
classes embedded Linux and this and many

00:34:08,560 --> 00:34:15,070
other things are covered in my training

00:34:10,419 --> 00:34:16,899
classes thank you so wait wait wait wait

00:34:15,070 --> 00:34:22,810
wait wait we haven't got we got to the

00:34:16,899 --> 00:34:24,159
end yet yeah so I always have a few

00:34:22,810 --> 00:34:27,850
slides at the end of my presentation

00:34:24,159 --> 00:34:30,960
just to allow for the fact these are

00:34:27,850 --> 00:34:34,929
quite long time slots this this show so

00:34:30,960 --> 00:34:36,250
I've kind of met my 40 minutes time slot

00:34:34,929 --> 00:34:38,260
but I'm actually a few more minutes ago

00:34:36,250 --> 00:34:40,510
so let me just briefly go through some

00:34:38,260 --> 00:34:41,470
of the extra slides at the end I'm gonna

00:34:40,510 --> 00:34:43,419
go through every single one but let's

00:34:41,470 --> 00:34:48,669
just do the interesting bits and then

00:34:43,419 --> 00:34:49,929
we'll do the Q&A so oh yeah this is a

00:34:48,669 --> 00:34:52,000
bit about systemd I don't know how

00:34:49,929 --> 00:34:55,419
familiar you guys are with system D this

00:34:52,000 --> 00:35:00,580
is a system D service unit for my QT

00:34:55,419 --> 00:35:04,000
demo and the important thing here is

00:35:00,580 --> 00:35:06,550
they wanted by bit so this is wanted by

00:35:04,000 --> 00:35:08,290
multi user targets so when when we hit

00:35:06,550 --> 00:35:11,470
multi user target then it will run this

00:35:08,290 --> 00:35:12,380
unit multi you as the target is the last

00:35:11,470 --> 00:35:16,359
target

00:35:12,380 --> 00:35:19,009
that systemd executes during the boot up

00:35:16,359 --> 00:35:22,099
if we want to move it up the batting

00:35:19,009 --> 00:35:26,150
order as I call it then you could do

00:35:22,099 --> 00:35:29,450
something like this and also don't

00:35:26,150 --> 00:35:31,549
really is I've just selected sis in it

00:35:29,450 --> 00:35:35,769
as the target so sit on it it's one of

00:35:31,549 --> 00:35:38,420
the first targets that systemd gets to

00:35:35,769 --> 00:35:40,910
so you could try cisternae at it be

00:35:38,420 --> 00:35:44,210
aware though that it is really early in

00:35:40,910 --> 00:35:46,220
the sequence so you still are going to

00:35:44,210 --> 00:35:48,170
be initialised ahead of say the network

00:35:46,220 --> 00:35:51,229
so at this point the network will not be

00:35:48,170 --> 00:35:56,089
up and running your root filesystem it's

00:35:51,229 --> 00:35:57,499
probably still read-only etc etc etc if

00:35:56,089 --> 00:35:59,989
you don't like sis Annette there's also

00:35:57,499 --> 00:36:01,910
another target called basic target so

00:35:59,989 --> 00:36:05,809
basic target is somewhere between sis in

00:36:01,910 --> 00:36:07,549
it target and multi-user target so you

00:36:05,809 --> 00:36:09,739
can experiment with each one of those

00:36:07,549 --> 00:36:12,859
three and see what which one works best

00:36:09,739 --> 00:36:14,569
for you or you can just say mmm we don't

00:36:12,859 --> 00:36:17,420
need we don't need in it at all and

00:36:14,569 --> 00:36:21,579
we'll do it using their little hack I

00:36:17,420 --> 00:36:21,579
showed earlier on in the presentation

00:36:23,019 --> 00:36:33,829
and I just want to do the first cup of

00:36:27,799 --> 00:36:40,519
slides about u-boot Falcon mode this is

00:36:33,829 --> 00:36:44,359
kind of low level the idea is that the

00:36:40,519 --> 00:36:47,329
way a typical embedded SOC boots is in

00:36:44,359 --> 00:36:50,930
several phases so specifically three

00:36:47,329 --> 00:36:52,219
three phases so the first phase is the

00:36:50,930 --> 00:36:55,549
ROM code face

00:36:52,219 --> 00:36:57,529
so the ROM code is code built into the

00:36:55,549 --> 00:37:01,819
chip itself it's mask programmed when

00:36:57,529 --> 00:37:04,009
the chip was manufactured and it's a

00:37:01,819 --> 00:37:09,019
simple bit of code generally speaking is

00:37:04,009 --> 00:37:11,180
just going to load some then the next

00:37:09,019 --> 00:37:14,180
stage of bootloader into some static

00:37:11,180 --> 00:37:15,859
memory it has to be static memory

00:37:14,180 --> 00:37:17,869
because at this point the dynamic Ram

00:37:15,859 --> 00:37:20,749
controller hasn't been initialized so we

00:37:17,869 --> 00:37:23,749
don't have any any main Ram we only have

00:37:20,749 --> 00:37:25,970
the static Ram that's on chip problem is

00:37:23,749 --> 00:37:28,070
that static Ram is quite expensive

00:37:25,970 --> 00:37:33,560
and most chips only have a few hundred

00:37:28,070 --> 00:37:36,050
kilobytes of static RAM so what we call

00:37:33,560 --> 00:37:41,060
next the SPL the second stage program

00:37:36,050 --> 00:37:43,640
loader has to fit into that SRAM in the

00:37:41,060 --> 00:37:49,220
case of the BeagleBone the the we have

00:37:43,640 --> 00:37:51,790
120 K bytes free 120 K bytes is not

00:37:49,220 --> 00:37:55,940
enough for you boot for the bootloader

00:37:51,790 --> 00:37:59,390
so we load the SPL second stage program

00:37:55,940 --> 00:38:02,240
loader into an SRAM that has enough

00:37:59,390 --> 00:38:06,230
functionality however to initialize the

00:38:02,240 --> 00:38:09,560
DRAM the main memory so at this point

00:38:06,230 --> 00:38:12,020
once this is run we now have half a

00:38:09,560 --> 00:38:15,710
gigabyte of memory to play with so then

00:38:12,020 --> 00:38:19,130
the SPL loads the main bootloader into D

00:38:15,710 --> 00:38:21,980
Ram and then you boot the main boot

00:38:19,130 --> 00:38:23,750
loader loads the kernel and the device

00:38:21,980 --> 00:38:27,080
tree and the Ram disk and whatever else

00:38:23,750 --> 00:38:29,750
and then sets are all running so that's

00:38:27,080 --> 00:38:31,570
the normal boot sequence not only for

00:38:29,750 --> 00:38:36,859
the BeagleBone but for pretty much every

00:38:31,570 --> 00:38:39,170
embedded processor that there is the

00:38:36,859 --> 00:38:42,650
idea then a Falcom mode is basically to

00:38:39,170 --> 00:38:44,390
merge steps 2 & 3 together in other

00:38:42,650 --> 00:38:48,140
words wouldn't it be nice if we could

00:38:44,390 --> 00:38:51,710
actually create a shrunk version of you

00:38:48,140 --> 00:38:53,540
boot that fits in the SRAM which means

00:38:51,710 --> 00:38:57,950
in the case of the chip on the

00:38:53,540 --> 00:39:02,900
BeagleBone it has to fit in 120 k so you

00:38:57,950 --> 00:39:04,700
can do this just about but um you lose

00:39:02,900 --> 00:39:06,500
quite a lot of things so you lose the

00:39:04,700 --> 00:39:11,450
command shell so you can't do any user

00:39:06,500 --> 00:39:13,849
interaction with it you lose the

00:39:11,450 --> 00:39:14,869
scripting capabilities a whole bunch of

00:39:13,849 --> 00:39:17,990
other things so you have to basically

00:39:14,869 --> 00:39:20,180
hard code the Falcom mode to do exactly

00:39:17,990 --> 00:39:22,070
what you want and if you want to change

00:39:20,180 --> 00:39:28,790
anything you will have to go back and

00:39:22,070 --> 00:39:30,800
recode it all and then the remainder oh

00:39:28,790 --> 00:39:33,140
this is all documented in the u-boot

00:39:30,800 --> 00:39:34,910
source code in the reboot falcon file if

00:39:33,140 --> 00:39:39,200
you want to delve into more details of

00:39:34,910 --> 00:39:40,010
this and the remainder of the slides

00:39:39,200 --> 00:39:42,740
which i'm not gonna go

00:39:40,010 --> 00:39:45,770
drue describe how to do this for the a

00:39:42,740 --> 00:39:47,930
m33 5x ship that's on the BeagleBone and

00:39:45,770 --> 00:39:51,080
there are similar procedures for IMX

00:39:47,930 --> 00:39:52,970
chips and I think for some of the

00:39:51,080 --> 00:39:55,970
Qualcomm MSM chips and so on it's not as

00:39:52,970 --> 00:40:03,260
on but I'll leave you to research that

00:39:55,970 --> 00:40:05,390
at your leisure I think that yeah that's

00:40:03,260 --> 00:40:10,880
all I really want to do so I want to

00:40:05,390 --> 00:40:13,550
come back this slide here yeah so that's

00:40:10,880 --> 00:40:17,320
the end of the presentation so it's time

00:40:13,550 --> 00:40:22,150
to open up you to you guys for some Q&A

00:40:17,320 --> 00:40:22,150
so does anybody have any questions so

00:40:27,490 --> 00:40:32,300
with the guy at the back isn't it so is

00:40:31,370 --> 00:40:34,490
the guy at the back who asked the

00:40:32,300 --> 00:40:37,010
questions I'm just thinking of the poll

00:40:34,490 --> 00:40:40,610
in the air there the microphone man go

00:40:37,010 --> 00:40:42,410
ahead so your method with having like a

00:40:40,610 --> 00:40:46,130
shell script that starts here acute

00:40:42,410 --> 00:40:48,500
application first one disadvantage I see

00:40:46,130 --> 00:40:50,180
is that system D will no longer

00:40:48,500 --> 00:40:54,200
supervise that process have you

00:40:50,180 --> 00:40:57,320
researched into a way to make system D

00:40:54,200 --> 00:41:01,940
retro actively aware of that process

00:40:57,320 --> 00:41:04,310
with some clever hack or something I

00:41:01,940 --> 00:41:09,460
think the simple answer to that is no I

00:41:04,310 --> 00:41:12,110
haven't researched that anybody have any

00:41:09,460 --> 00:41:16,100
assistant D foo in the audience who

00:41:12,110 --> 00:41:20,510
would know how to do that I suspect it's

00:41:16,100 --> 00:41:22,010
not possible then so no I my assumption

00:41:20,510 --> 00:41:24,800
is that once it's running it's running

00:41:22,010 --> 00:41:26,990
and it's like you say it's outside of

00:41:24,800 --> 00:41:28,430
system DS knowledge this is something

00:41:26,990 --> 00:41:32,330
which system Li doesn't know about of

00:41:28,430 --> 00:41:34,670
course so that's both a good thing and a

00:41:32,330 --> 00:41:36,760
bad thing I'm assuming that it's not an

00:41:34,670 --> 00:41:36,760
issue

00:41:41,500 --> 00:41:49,609
anyone else well you doing that can I

00:41:47,930 --> 00:41:51,260
just ask how many people here are in

00:41:49,609 --> 00:41:52,880
very developers just for you ask the

00:41:51,260 --> 00:41:56,119
question oh my god

00:41:52,880 --> 00:41:58,160
almost everybody whoa cool I suppose you

00:41:56,119 --> 00:42:01,460
wouldn't be here if you weren't okay

00:41:58,160 --> 00:42:03,799
good yeah I just wanted to know if you

00:42:01,460 --> 00:42:05,839
looked into because the boot timings now

00:42:03,799 --> 00:42:08,869
are measured up until you start the

00:42:05,839 --> 00:42:12,200
application like did you do you have any

00:42:08,869 --> 00:42:15,770
nice tricks to actually optimize the

00:42:12,200 --> 00:42:17,839
start like statically linking minimal

00:42:15,770 --> 00:42:20,540
version of QT into it's not like because

00:42:17,839 --> 00:42:22,940
I guess if you load too too much things

00:42:20,540 --> 00:42:24,680
dynamically it would also add time until

00:42:22,940 --> 00:42:26,480
the application is actually showing

00:42:24,680 --> 00:42:30,849
something on the screen or what your

00:42:26,480 --> 00:42:35,210
application is doing yeah right so

00:42:30,849 --> 00:42:37,190
largely because it's I didn't have a way

00:42:35,210 --> 00:42:38,809
of measuring the point at which the

00:42:37,190 --> 00:42:40,099
application appears on the screen I

00:42:38,809 --> 00:42:41,480
would need some kind of camera and some

00:42:40,099 --> 00:42:43,690
kind of thing to recognize that it's

00:42:41,480 --> 00:42:45,680
done that and I or I could just put a I

00:42:43,690 --> 00:42:46,790
suppose a print statement in the

00:42:45,680 --> 00:42:49,250
application but I didn't actually do

00:42:46,790 --> 00:42:51,530
that so I'm kind of missing out a little

00:42:49,250 --> 00:42:53,210
bit the actual length of time for an

00:42:51,530 --> 00:42:56,720
application starting in other words the

00:42:53,210 --> 00:42:58,099
point at which we exec QT demo to the

00:42:56,720 --> 00:43:03,740
point it would actually appears on the

00:42:58,099 --> 00:43:06,380
screen there are as you indicates a lot

00:43:03,740 --> 00:43:10,369
of interesting Hanks you can perform to

00:43:06,380 --> 00:43:12,200
improve that I'm not sure the static

00:43:10,369 --> 00:43:14,900
Lincoln would really help in this case

00:43:12,200 --> 00:43:18,130
because the dynamic link was fairly

00:43:14,900 --> 00:43:21,680
efficient but you could carefully

00:43:18,130 --> 00:43:23,180
arrange things so that you don't bring

00:43:21,680 --> 00:43:24,530
in all the functionality in other words

00:43:23,180 --> 00:43:26,990
don't call don't make all the library

00:43:24,530 --> 00:43:29,510
calls at once and therefore load all the

00:43:26,990 --> 00:43:31,220
libraries into memory at once but if you

00:43:29,510 --> 00:43:33,380
carefully sequence things so you have a

00:43:31,220 --> 00:43:36,369
module which is going to display the

00:43:33,380 --> 00:43:39,140
initial screen and then another separate

00:43:36,369 --> 00:43:41,900
module which cause another live in so

00:43:39,140 --> 00:43:44,270
Amazon and you can also do some clever

00:43:41,900 --> 00:43:49,099
things with library linking scripts but

00:43:44,270 --> 00:43:50,480
that gets to be somewhat painful so yeah

00:43:49,099 --> 00:43:54,040
there are things you can do which I

00:43:50,480 --> 00:43:55,770
haven't got details of actually if you

00:43:54,040 --> 00:43:57,790
want to go into that if you look at the

00:43:55,770 --> 00:44:01,090
presentation from Andrew Murray who I

00:43:57,790 --> 00:44:03,190
referenced earlier on he does go into

00:44:01,090 --> 00:44:06,850
great detail on how to create an

00:44:03,190 --> 00:44:08,800
optimized set of cute libraries so I'd

00:44:06,850 --> 00:44:12,750
recommend go back to his presentation

00:44:08,800 --> 00:44:22,570
for about 2001 2002 by 2011 or 2012

00:44:12,750 --> 00:44:24,130
there's got a lot of detail on that when

00:44:22,570 --> 00:44:26,590
are you planning to have a speech about

00:44:24,130 --> 00:44:34,780
reducing the boot time of Android

00:44:26,590 --> 00:44:39,870
devices so yes doing the same thing for

00:44:34,780 --> 00:44:42,010
Android is an interesting challenge and

00:44:39,870 --> 00:44:45,700
relevant challenge as well as Android

00:44:42,010 --> 00:44:48,520
becomes used more and more in automotive

00:44:45,700 --> 00:44:51,310
applications and typically in automotive

00:44:48,520 --> 00:44:53,710
applications there is a legal

00:44:51,310 --> 00:44:56,020
requirement that the system becomes

00:44:53,710 --> 00:44:57,190
active within two seconds of turning on

00:44:56,020 --> 00:44:59,620
the ignition key or something along

00:44:57,190 --> 00:45:00,880
those lines specifically for the

00:44:59,620 --> 00:45:03,250
rear-view camera if you if you start

00:45:00,880 --> 00:45:07,480
reversing you want to see people before

00:45:03,250 --> 00:45:09,750
you run them over ideally so to answer

00:45:07,480 --> 00:45:13,540
the question then can you optimize

00:45:09,750 --> 00:45:19,750
Android boot time and the answer is yes

00:45:13,540 --> 00:45:20,800
a bit but I mean you can basically

00:45:19,750 --> 00:45:22,330
optimize the bits that I've kind of

00:45:20,800 --> 00:45:26,740
mentioned on there on the presentation

00:45:22,330 --> 00:45:29,380
applied to to Android but you're left

00:45:26,740 --> 00:45:32,550
with a big chunk of initialization which

00:45:29,380 --> 00:45:32,550
is starting up the android framework

00:45:32,820 --> 00:45:41,430
which is done by a java program called

00:45:37,150 --> 00:45:45,610
system server and it's kind of huge and

00:45:41,430 --> 00:45:49,600
it's kind of coded sequentially there's

00:45:45,610 --> 00:45:51,100
no parallelization in there and sort of

00:45:49,600 --> 00:45:53,380
completely rewriting it and given that

00:45:51,100 --> 00:45:55,180
it's I don't know the million lines of

00:45:53,380 --> 00:45:58,690
code or something there isn't really

00:45:55,180 --> 00:46:02,050
much you can do about it so my advice to

00:45:58,690 --> 00:46:04,440
optimizing Android boot time is don't

00:46:02,050 --> 00:46:04,440
even try

00:46:06,640 --> 00:46:13,940
it's basically not possible to get it

00:46:08,840 --> 00:46:17,330
below about 20 seconds so hey guys you

00:46:13,940 --> 00:46:18,830
gotta live with it which brings me then

00:46:17,330 --> 00:46:22,520
on to thing I just mentioned that how

00:46:18,830 --> 00:46:24,440
come we're using or certain companies in

00:46:22,520 --> 00:46:29,150
this vicinity are about to use Android

00:46:24,440 --> 00:46:31,330
in the head unit of their vehicles how

00:46:29,150 --> 00:46:34,280
do you get around the regulation of

00:46:31,330 --> 00:46:37,910
needing to display the the rear view

00:46:34,280 --> 00:46:40,040
camera within two seconds so Android has

00:46:37,910 --> 00:46:42,440
a way of doing this called the EVs the

00:46:40,040 --> 00:46:49,240
exterior view system you've heard of it

00:46:42,440 --> 00:46:53,600
so the EVs is a two components is a

00:46:49,240 --> 00:46:54,650
camera device and a display device and a

00:46:53,600 --> 00:46:58,730
little application that you're joins

00:46:54,650 --> 00:47:03,470
them together all written in C++ so no

00:46:58,730 --> 00:47:06,050
Java no dependencies on the framework so

00:47:03,470 --> 00:47:08,240
what actually happens is that the EVs

00:47:06,050 --> 00:47:09,350
system gets started up before the

00:47:08,240 --> 00:47:12,530
framework gets started

00:47:09,350 --> 00:47:13,850
and so if you do the things I mentioned

00:47:12,530 --> 00:47:16,100
on the slide here you can do that within

00:47:13,850 --> 00:47:17,480
two seconds so within two seconds then

00:47:16,100 --> 00:47:21,050
you'll have the camera streaming video

00:47:17,480 --> 00:47:26,150
to the display completely bypassing

00:47:21,050 --> 00:47:27,230
Android that's the way to do it and

00:47:26,150 --> 00:47:34,480
that's the Google way to do it I'm going

00:47:27,230 --> 00:47:34,480
to say okay any other questions

00:47:37,390 --> 00:47:48,640
I do have a name tip some catching stuff

00:47:44,589 --> 00:47:53,940
early on in the boot process very early

00:47:48,640 --> 00:48:01,359
on on the first few milliseconds like

00:47:53,940 --> 00:48:03,789
stuff happens with loading and internal

00:48:01,359 --> 00:48:09,519
boat loaders into the microcontroller

00:48:03,789 --> 00:48:11,950
around catch early output from the U

00:48:09,519 --> 00:48:15,609
earth that we that you it's pretty hard

00:48:11,950 --> 00:48:18,009
to catch sometimes yes my approach is

00:48:15,609 --> 00:48:21,099
using grab cereal which requires the

00:48:18,009 --> 00:48:23,349
UART to be operational and for something

00:48:21,099 --> 00:48:25,569
to be outputting text to the to the to

00:48:23,349 --> 00:48:29,619
the serial port if you want to capture

00:48:25,569 --> 00:48:32,230
things before that point then really

00:48:29,619 --> 00:48:34,019
you're down to using logic analyzers

00:48:32,230 --> 00:48:36,519
that's the only way you're gonna do it

00:48:34,019 --> 00:48:38,619
so you need a logic analyzer trigger it

00:48:36,519 --> 00:48:42,069
when the reset button is pressed on the

00:48:38,619 --> 00:48:43,960
processor and then stop it when a GPIO

00:48:42,069 --> 00:48:46,749
so you have to go and modify some code

00:48:43,960 --> 00:48:49,420
somewhere to twiddle some GPIO s and

00:48:46,749 --> 00:48:50,739
then you know you could then measure

00:48:49,420 --> 00:48:54,400
that length of time and then optimize

00:48:50,739 --> 00:48:56,109
insolent way this is assuming of course

00:48:54,400 --> 00:48:58,930
that you have the source code that you

00:48:56,109 --> 00:49:00,279
can modify the boot process at this

00:48:58,930 --> 00:49:03,220
point quite often at this point actually

00:49:00,279 --> 00:49:08,019
you are running proprietary binary blobs

00:49:03,220 --> 00:49:10,150
which you have no control over you can

00:49:08,019 --> 00:49:13,299
get some way actually just by monitoring

00:49:10,150 --> 00:49:16,140
the the current load but you just by

00:49:13,299 --> 00:49:18,609
measuring that the power consumed and

00:49:16,140 --> 00:49:20,880
you will then see that you know that the

00:49:18,609 --> 00:49:24,190
power starts at zero and then when you

00:49:20,880 --> 00:49:26,140
hit the power button it's going to ramp

00:49:24,190 --> 00:49:29,170
up as it goes through various loading

00:49:26,140 --> 00:49:32,640
processes so you can sometimes relate

00:49:29,170 --> 00:49:35,380
that power graph back to particular

00:49:32,640 --> 00:49:38,950
modules being loaded and then you go

00:49:35,380 --> 00:49:41,920
back to your SOC vendor and say we think

00:49:38,950 --> 00:49:44,140
that the the trustzone is taking a long

00:49:41,920 --> 00:49:46,089
time to initialize or we think that the

00:49:44,140 --> 00:49:48,350
power manager is is taking a long time

00:49:46,089 --> 00:49:50,480
to start up for some reason but

00:49:48,350 --> 00:49:51,740
let's say usually at that point you

00:49:50,480 --> 00:49:54,950
don't actually have control of the

00:49:51,740 --> 00:49:57,770
source code and so whatever you discover

00:49:54,950 --> 00:49:59,660
at that point you are gonna have to go

00:49:57,770 --> 00:50:08,120
back to the vendor in order to get any

00:49:59,660 --> 00:50:09,170
changes made where the comment is yeah

00:50:08,120 --> 00:50:16,910
we could always maybe choose a different

00:50:09,170 --> 00:50:18,650
microprocessor so yeah so ideally I mean

00:50:16,910 --> 00:50:20,570
the choosing a different microprocessor

00:50:18,650 --> 00:50:23,060
is a great thing to do because it

00:50:20,570 --> 00:50:25,580
teaches the other guy not to do whatever

00:50:23,060 --> 00:50:28,010
it is they're doing wrong unfortunately

00:50:25,580 --> 00:50:30,650
usually you don't discover this point

00:50:28,010 --> 00:50:32,150
until you you have committed or at least

00:50:30,650 --> 00:50:35,210
your hardware engineers have committed

00:50:32,150 --> 00:50:36,590
to use in that particular SOC and they

00:50:35,210 --> 00:50:40,400
may even have bought a few hundred

00:50:36,590 --> 00:50:42,820
thousand of them so it's usually too

00:50:40,400 --> 00:50:46,850
late to change manufacture at that point

00:50:42,820 --> 00:50:49,580
which is a pity but yeah current

00:50:46,850 --> 00:50:51,500
measuring is a good good deal okay with

00:50:49,580 --> 00:50:54,320
God look a few minutes well we've got a

00:50:51,500 --> 00:50:57,440
couple minutes thanks for a great speech

00:50:54,320 --> 00:51:01,490
I have my question you have to try G

00:50:57,440 --> 00:51:08,920
together with the Linux system we tried

00:51:01,490 --> 00:51:11,840
which using G tag okay tag sorry like

00:51:08,920 --> 00:51:17,360
actually I haven't for a long time used

00:51:11,840 --> 00:51:19,430
JTAG but would that help you I guess you

00:51:17,360 --> 00:51:21,590
can help that would help you by being

00:51:19,430 --> 00:51:22,910
able to set breakpoints on certain

00:51:21,590 --> 00:51:26,720
memory addresses which you know are

00:51:22,910 --> 00:51:29,540
being used so I guess a JTAG or some

00:51:26,720 --> 00:51:32,150
other imporant circuit debug probe would

00:51:29,540 --> 00:51:35,360
help you on that I don't have any

00:51:32,150 --> 00:51:37,010
personal experience of that not in the

00:51:35,360 --> 00:51:39,400
last 15 years at least that will be

00:51:37,010 --> 00:51:49,460
useful as anyone else in here damn it

00:51:39,400 --> 00:51:52,430
Andy J take hackers here okay nice okay

00:51:49,460 --> 00:51:55,070
thank you I think we probably need to

00:51:52,430 --> 00:51:57,000
wrap it up at this point so thank you

00:51:55,070 --> 00:52:00,450
very much for

00:51:57,000 --> 00:52:02,759
but for listening patiently to me and if

00:52:00,450 --> 00:52:05,250
you want to talk to me I'll be hanging

00:52:02,759 --> 00:52:08,330
around in the for a for the next next

00:52:05,250 --> 00:52:12,869
presentation so thank you all very much

00:52:08,330 --> 00:52:12,869
[Applause]

00:52:17,980 --> 00:52:20,040

YouTube URL: https://www.youtube.com/watch?v=VpwXj93_yZk


