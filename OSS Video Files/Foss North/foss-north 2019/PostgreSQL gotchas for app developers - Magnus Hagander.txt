Title: PostgreSQL gotchas for app developers - Magnus Hagander
Publication date: 2019-04-18
Playlist: foss-north 2019
Description: 
	Some things when it comes to working with databases are obvious to everybody. Other things are hidden from everybody. Yet some can be obvious to an experienced DBA, but come as a big surprise to application developers, and these can often be different between different databases.
In this talk I'll go through some of the common mistakes I've seen in applications built against PostgreSQL that made perfect sense, yet were suboptimal or failed.
Magnus Hagander is a member of the PostgreSQL Core Team and a developer and code committer in the PostgreSQL Global Development Group.

---

Magnus is one of the original developers of the Windows port of PostgreSQL. These days, he mostly works on other parts of the PostgreSQL backend, recently with a focus on security features, monitoring and backup/replication interfaces and tools.
He is also one of the core members of the postgresql.org infrastructure team, maintaining the servers that power the project, and one of the maintainers of the postgresql.org website. He also contributes to pgAdmin and other related projects.
He's been a PostgreSQL user since version 6 (with some non-serious use of Postgres 95 before that), and currently serves on the Core Team and as President of the Board for PostgreSQL Europe.
To pay the bills, he is a PostgreSQL and open source software consultant at Redpill Linpro in Stockholm, Sweden, where he works on consulting, support and training services, as well as custom development work.

https://foss-north.se/2019/speakers-and-talks.html#mhagander
Captions: 
	00:00:16,710 --> 00:00:22,570
well good morning and we're running a

00:00:20,500 --> 00:00:24,850
few minutes late those who you were note

00:00:22,570 --> 00:00:29,100
that for once it's not actually my fault

00:00:24,850 --> 00:00:32,470
usually it would be but this happened

00:00:29,100 --> 00:00:35,410
my name is Magnus hacker I'm here today

00:00:32,470 --> 00:00:36,610
to talk about those physical just for

00:00:35,410 --> 00:00:38,680
app developers oh really

00:00:36,610 --> 00:00:41,140
Cole just might or might not be the

00:00:38,680 --> 00:00:44,100
right word but poster is for app

00:00:41,140 --> 00:00:46,420
developers in a way you know all sort of

00:00:44,100 --> 00:00:48,550
what are you doing that you shouldn't be

00:00:46,420 --> 00:00:50,769
doing what are you not doing that you

00:00:48,550 --> 00:00:52,839
should be doing few things like that

00:00:50,769 --> 00:00:56,050
I work for a company called red balloon

00:00:52,839 --> 00:00:57,790
Pro we're an open-source services and

00:00:56,050 --> 00:00:59,739
consultancy business around the

00:00:57,790 --> 00:01:01,180
Scandinavian region we do have an office

00:00:59,739 --> 00:01:03,190
here in Gothenburg I'm working out of

00:01:01,180 --> 00:01:05,770
the Stockholm office myself or I'm

00:01:03,190 --> 00:01:09,700
leading up our database work can promote

00:01:05,770 --> 00:01:12,310
only on the sort of devil's side I'm a

00:01:09,700 --> 00:01:14,320
part of the post pristine part of the

00:01:12,310 --> 00:01:16,120
poster is for team one of the committers

00:01:14,320 --> 00:01:19,570
who actually write code in the backend

00:01:16,120 --> 00:01:23,439
database and of course I also write code

00:01:19,570 --> 00:01:24,909
that uses the database and I do a lot of

00:01:23,439 --> 00:01:26,469
that because he works and things like

00:01:24,909 --> 00:01:29,170
that in an organization called puss with

00:01:26,469 --> 00:01:32,259
Europe which is basically due to group

00:01:29,170 --> 00:01:34,810
coordination across Europe but in

00:01:32,259 --> 00:01:37,090
particular in my role I've read the

00:01:34,810 --> 00:01:39,670
liberal and of interfacing a lot with

00:01:37,090 --> 00:01:40,990
people at shall because other layers of

00:01:39,670 --> 00:01:41,380
the stack because I mean I should be on

00:01:40,990 --> 00:01:43,539
the final

00:01:41,380 --> 00:01:45,399
an apple program so who amongst you

00:01:43,539 --> 00:01:47,969
would consider yourself an app developer

00:01:45,399 --> 00:01:52,750
regardless of Halloween and to find that

00:01:47,969 --> 00:01:56,340
who's a DBA ok that's surprisingly at

00:01:52,750 --> 00:01:58,750
least one so this is not for you sorry

00:01:56,340 --> 00:01:59,859
and I'm most definitely not what you

00:01:58,750 --> 00:02:00,869
know today everyone's supposed to be a

00:01:59,859 --> 00:02:03,189
full stacked up right

00:02:00,869 --> 00:02:06,130
I've only full stack mean so far that I

00:02:03,189 --> 00:02:08,619
can break the stack at every layer but I

00:02:06,130 --> 00:02:12,490
can really only fix it so back in the

00:02:08,619 --> 00:02:14,670
town but what I do in my role at rental

00:02:12,490 --> 00:02:16,870
is have to long work with people

00:02:14,670 --> 00:02:18,520
throughout the stack that's right I

00:02:16,870 --> 00:02:22,150
think so I see all the things that a lot

00:02:18,520 --> 00:02:24,519
of times they come to us when they have

00:02:22,150 --> 00:02:25,280
a problem and then you can go there and

00:02:24,519 --> 00:02:27,050
come

00:02:25,280 --> 00:02:29,780
from the bottom end of the stack and say

00:02:27,050 --> 00:02:31,880
well that's not gonna work that should

00:02:29,780 --> 00:02:35,390
be on this turns out it wasn't obvious

00:02:31,880 --> 00:02:37,550
right so I'll bring in a bunch of

00:02:35,390 --> 00:02:38,959
examples now when I do things higher up

00:02:37,550 --> 00:02:40,910
in the stack my sort of drug of choice

00:02:38,959 --> 00:02:43,250
is usually writing code in Python and

00:02:40,910 --> 00:02:45,650
using Django because that's easy for me

00:02:43,250 --> 00:02:48,200
and I don't do the advanced stuff which

00:02:45,650 --> 00:02:49,940
means that the examples that I do I will

00:02:48,200 --> 00:02:51,950
do in Python and Django but they all

00:02:49,940 --> 00:02:53,630
apply across frameworks it doesn't

00:02:51,950 --> 00:02:56,260
matter what language you're using these

00:02:53,630 --> 00:02:59,360
are more on the principle level of

00:02:56,260 --> 00:03:01,370
technologies and ideas that were using

00:02:59,360 --> 00:03:03,730
so what do I qualify to capture within

00:03:01,370 --> 00:03:05,750
the context of this talk it's like a

00:03:03,730 --> 00:03:08,269
working title of this was you know it

00:03:05,750 --> 00:03:10,430
seemed like a good idea at the time like

00:03:08,269 --> 00:03:13,100
it seemed obvious until you realize what

00:03:10,430 --> 00:03:14,780
actually happened further down or in a

00:03:13,100 --> 00:03:17,480
lot of cases it's people who knew that

00:03:14,780 --> 00:03:19,580
it was going to be a problem they just

00:03:17,480 --> 00:03:23,569
assumed there was no way no other way to

00:03:19,580 --> 00:03:25,850
do it but a lot of the time there were

00:03:23,569 --> 00:03:28,940
to say there were good intentions with

00:03:25,850 --> 00:03:31,430
unintended consequences or there were

00:03:28,940 --> 00:03:33,950
simply things that were clearly

00:03:31,430 --> 00:03:37,040
suboptimal but it wasn't necessarily

00:03:33,950 --> 00:03:40,040
clear why and these are obviously things

00:03:37,040 --> 00:03:42,560
that you want to get faced so let's get

00:03:40,040 --> 00:03:43,820
started I'm sure many of you if you were

00:03:42,560 --> 00:03:45,140
in here you've at one point or other

00:03:43,820 --> 00:03:47,269
built some sort of a database

00:03:45,140 --> 00:03:50,150
application or some sort of application

00:03:47,269 --> 00:03:51,739
that in one way or another use the

00:03:50,150 --> 00:03:53,440
database so there's probably a whole

00:03:51,739 --> 00:03:56,390
bunch of things in here that you know

00:03:53,440 --> 00:03:58,130
but if I go through the things and a lot

00:03:56,390 --> 00:03:59,359
of the times I can see recommendations

00:03:58,130 --> 00:04:01,760
coming from people who've built

00:03:59,359 --> 00:04:03,769
applications for 20 years against

00:04:01,760 --> 00:04:07,310
databases and giving people the wrong

00:04:03,769 --> 00:04:09,049
advice in fairness I've also seen people

00:04:07,310 --> 00:04:10,310
build databases for 20 years to give

00:04:09,049 --> 00:04:13,640
people the wrong advice about their own

00:04:10,310 --> 00:04:16,130
database so it happens right and

00:04:13,640 --> 00:04:18,919
probably the single most common one that

00:04:16,130 --> 00:04:21,320
I've run into very commonly in the areas

00:04:18,919 --> 00:04:23,419
of posters with our customers is this

00:04:21,320 --> 00:04:24,710
whole idea of a connection Pooler right

00:04:23,419 --> 00:04:27,440
everyone knows you should have a

00:04:24,710 --> 00:04:29,180
connection pool right but that's really

00:04:27,440 --> 00:04:30,800
not enough because then you can set up

00:04:29,180 --> 00:04:33,370
this connection pool to do really really

00:04:30,800 --> 00:04:33,370
stupid things

00:04:34,120 --> 00:04:38,620
Postgres in particular in this case is

00:04:36,860 --> 00:04:40,470
extra sensitive to not

00:04:38,620 --> 00:04:43,240
doing the really really stupid things

00:04:40,470 --> 00:04:45,190
some databases like particularly like

00:04:43,240 --> 00:04:46,840
Oracle for example has a really good way

00:04:45,190 --> 00:04:49,360
of handling the fact when the app does

00:04:46,840 --> 00:04:51,040
really stupid things and it like

00:04:49,360 --> 00:04:53,740
rewrites them and changes them into less

00:04:51,040 --> 00:04:55,090
stupid things and does better admission

00:04:53,740 --> 00:04:57,940
control into the database and things

00:04:55,090 --> 00:04:59,699
like that to not overload things just

00:04:57,940 --> 00:05:02,440
because you feel configured it stupidly

00:04:59,699 --> 00:05:04,960
post Chris doesn't do that if you're

00:05:02,440 --> 00:05:06,970
throwing work at it in a really stupid

00:05:04,960 --> 00:05:09,490
way it will do its best to run it in a

00:05:06,970 --> 00:05:12,160
really stupid way so you don't want to

00:05:09,490 --> 00:05:15,130
do that and Postgres is designed for

00:05:12,160 --> 00:05:17,590
there being a connection pool starting

00:05:15,130 --> 00:05:19,389
up new connections in Postgres just when

00:05:17,590 --> 00:05:21,460
you connect you authenticate you pre

00:05:19,389 --> 00:05:23,530
populate caches and things like that is

00:05:21,460 --> 00:05:25,419
a lot more expensive than in many other

00:05:23,530 --> 00:05:27,370
databases but in practice the same

00:05:25,419 --> 00:05:29,650
problem is everywhere at the lowest

00:05:27,370 --> 00:05:32,050
level just opening a new TCP connection

00:05:29,650 --> 00:05:34,120
to the database for every web request in

00:05:32,050 --> 00:05:37,510
your app for example that's a lot of

00:05:34,120 --> 00:05:40,630
unnecessary overhead so everyone knows

00:05:37,510 --> 00:05:42,160
it but the common things that you make a

00:05:40,630 --> 00:05:44,950
mistake is you have too many connection

00:05:42,160 --> 00:05:46,180
pools because the way that the works and

00:05:44,950 --> 00:05:47,680
a lot of database and certainly in

00:05:46,180 --> 00:05:49,599
Postgres is you will have one connection

00:05:47,680 --> 00:05:52,539
pool per combination of user and

00:05:49,599 --> 00:05:54,660
database that user and Postgres user not

00:05:52,539 --> 00:05:57,099
necessarily end user of your application

00:05:54,660 --> 00:05:58,479
so even if you thought you had maybe 10

00:05:57,099 --> 00:06:01,360
connections in your database but then

00:05:58,479 --> 00:06:03,010
you had 10 connections in your pool but

00:06:01,360 --> 00:06:05,560
then you had 10 debit databases and 50

00:06:03,010 --> 00:06:08,289
users you actually had 5,000 connections

00:06:05,560 --> 00:06:09,520
and then at some point you ran into the

00:06:08,289 --> 00:06:10,810
limits in Postgres and you would

00:06:09,520 --> 00:06:14,229
increase the limits in Postgres or

00:06:10,810 --> 00:06:17,020
something like that and the single most

00:06:14,229 --> 00:06:19,720
common one is that your pools are too

00:06:17,020 --> 00:06:21,699
large and that's where I've

00:06:19,720 --> 00:06:24,610
unfortunately run into a lot of the

00:06:21,699 --> 00:06:28,300
cases where you have very well founded

00:06:24,610 --> 00:06:30,520
just you know misinformed guides from

00:06:28,300 --> 00:06:33,430
the people who are building frameworks

00:06:30,520 --> 00:06:35,800
at a higher level which basically boils

00:06:33,430 --> 00:06:38,349
down to if anything runs slow double the

00:06:35,800 --> 00:06:40,800
size of the connection pool and if it's

00:06:38,349 --> 00:06:45,030
still running slow try doubling it again

00:06:40,800 --> 00:06:47,950
whereas in reality I've never not once

00:06:45,030 --> 00:06:49,330
come across personally a case on an

00:06:47,950 --> 00:06:53,050
application that had a connection pool

00:06:49,330 --> 00:06:57,220
that was too small and I've all the time

00:06:53,050 --> 00:06:58,900
come across cases where it's too big and

00:06:57,220 --> 00:07:00,940
the reason for that is well there's a

00:06:58,900 --> 00:07:04,569
limit to what the database can do if

00:07:00,940 --> 00:07:07,810
your database server actually has say

00:07:04,569 --> 00:07:09,280
500 CPU cores then maybe your connection

00:07:07,810 --> 00:07:11,740
pool is correctly sized most people

00:07:09,280 --> 00:07:14,169
don't end up to have that and in theory

00:07:11,740 --> 00:07:16,020
a sort of good rule of thumb tends to be

00:07:14,169 --> 00:07:18,280
as if you're looking at CPU level loads

00:07:16,020 --> 00:07:21,460
somewhere between two and three times

00:07:18,280 --> 00:07:23,650
the number of CPU cores is the number of

00:07:21,460 --> 00:07:28,509
active queries your database can take it

00:07:23,650 --> 00:07:29,919
after that it all becomes overhead so

00:07:28,509 --> 00:07:31,150
whenever you see people setting up

00:07:29,919 --> 00:07:32,919
things like you know a thousand

00:07:31,150 --> 00:07:34,870
connections in a pool like I'd like to

00:07:32,919 --> 00:07:37,440
play with your server if you really have

00:07:34,870 --> 00:07:39,340
you know five hundred plus CPUs in it

00:07:37,440 --> 00:07:41,380
that sounds like a really interesting

00:07:39,340 --> 00:07:44,020
piece of machinery to play with but you

00:07:41,380 --> 00:07:45,880
probably don't one of my records have

00:07:44,020 --> 00:07:48,849
seen someone trying to run two thousand

00:07:45,880 --> 00:07:52,150
parallel queries on one virtualized CPU

00:07:48,849 --> 00:07:53,530
core and I mean yes that's when you see

00:07:52,150 --> 00:07:57,340
things like the Linux load average

00:07:53,530 --> 00:07:59,500
spiking up to over 2,000 we know that's

00:07:57,340 --> 00:08:01,030
not good and this solution then turns

00:07:59,500 --> 00:08:01,530
out not to be to double the connection

00:08:01,030 --> 00:08:03,759
pool again

00:08:01,530 --> 00:08:07,120
but it's actually to reduce it in this

00:08:03,759 --> 00:08:09,130
case we reduced it from that down to ten

00:08:07,120 --> 00:08:14,340
and the problem was gone everything

00:08:09,130 --> 00:08:14,340
worked it's a very common thing

00:08:15,150 --> 00:08:20,740
now speaking of users in your database

00:08:18,180 --> 00:08:22,630
and there's something I will say if

00:08:20,740 --> 00:08:24,430
anyone's noticed that has anyone read

00:08:22,630 --> 00:08:28,150
the security things around Postgres in

00:08:24,430 --> 00:08:29,979
the past week maybe one or two so I

00:08:28,150 --> 00:08:31,270
promise I have this slide in there

00:08:29,979 --> 00:08:32,560
before because I've had this slide in

00:08:31,270 --> 00:08:35,430
here for like 20 years

00:08:32,560 --> 00:08:39,700
don't ever ever ever use a superuser

00:08:35,430 --> 00:08:41,829
ever just don't

00:08:39,700 --> 00:08:44,110
not even for running your migrations not

00:08:41,829 --> 00:08:46,149
for nothing because the superuser in

00:08:44,110 --> 00:08:50,079
Postgres just as in most other databases

00:08:46,149 --> 00:08:52,660
can do anything and by anything we don't

00:08:50,079 --> 00:08:55,149
just mean drop all your tables we mean

00:08:52,660 --> 00:08:57,190
upload files to the server run commands

00:08:55,149 --> 00:09:00,010
on the server things like that and this

00:08:57,190 --> 00:09:02,050
turns out to be it was just last week

00:09:00,010 --> 00:09:04,870
some I'm gonna put it in quotes and say

00:09:02,050 --> 00:09:06,130
security researcher filed CVEs against

00:09:04,870 --> 00:09:06,790
Postgres for the fact that if you logged

00:09:06,130 --> 00:09:08,430
in as a soupy

00:09:06,790 --> 00:09:11,350
you could do things as a super user

00:09:08,430 --> 00:09:12,970
which you know seems kind of scary we're

00:09:11,350 --> 00:09:14,680
waiting for them to follow the reports

00:09:12,970 --> 00:09:16,930
against Linux for having a root user and

00:09:14,680 --> 00:09:18,970
things like that but the thing that you

00:09:16,930 --> 00:09:21,610
need to realize that super user can

00:09:18,970 --> 00:09:23,950
break out of Postgres now they'll still

00:09:21,610 --> 00:09:25,450
be limited to the post press operating

00:09:23,950 --> 00:09:27,270
system user right because the database

00:09:25,450 --> 00:09:29,800
will not run its route even if you try

00:09:27,270 --> 00:09:32,350
it'll refuse to start if you try to run

00:09:29,800 --> 00:09:34,690
it as root but you can still get out

00:09:32,350 --> 00:09:36,100
there and you can plant backdoors in you

00:09:34,690 --> 00:09:39,390
can do whatever you want so you should

00:09:36,100 --> 00:09:42,660
never ever grant anyone Super User and

00:09:39,390 --> 00:09:44,350
certainly not your application

00:09:42,660 --> 00:09:45,760
unfortunately it's of course really

00:09:44,350 --> 00:09:47,710
convenient because if you do that all

00:09:45,760 --> 00:09:50,680
those pesky permission denied bearers go

00:09:47,710 --> 00:09:52,810
away but there are better ways to do

00:09:50,680 --> 00:09:54,430
that even within the database I mean

00:09:52,810 --> 00:09:55,780
even if you don't want them you really

00:09:54,430 --> 00:09:57,700
should be using the database level

00:09:55,780 --> 00:09:59,170
permissions just like you should be

00:09:57,700 --> 00:10:00,490
setting filesystem level permissions and

00:09:59,170 --> 00:10:02,560
not give everyone write permissions

00:10:00,490 --> 00:10:04,330
everywhere things like that but even if

00:10:02,560 --> 00:10:05,920
you want to bypass that and just say I

00:10:04,330 --> 00:10:08,230
just want my app to have access to

00:10:05,920 --> 00:10:11,590
everything you can do that without

00:10:08,230 --> 00:10:13,660
granting Super User you can grant the

00:10:11,590 --> 00:10:14,860
schema owner or a database owner which

00:10:13,660 --> 00:10:17,290
point it will get all of those things

00:10:14,860 --> 00:10:21,160
but it will be unable to break out of

00:10:17,290 --> 00:10:25,090
the database itself so don't use Super

00:10:21,160 --> 00:10:26,370
User and on the same topic Postgres is

00:10:25,090 --> 00:10:28,690
something called a trust authentication

00:10:26,370 --> 00:10:30,130
you should regularly audit all your

00:10:28,690 --> 00:10:32,770
systems to see if it use than if it is

00:10:30,130 --> 00:10:34,390
turn it off immediately because trust

00:10:32,770 --> 00:10:37,090
authentication basically means turns off

00:10:34,390 --> 00:10:39,640
turn off every piece of security in the

00:10:37,090 --> 00:10:41,470
whole system anyone who wants can just

00:10:39,640 --> 00:10:42,130
claim to be the Super User and they're

00:10:41,470 --> 00:10:44,500
good to go

00:10:42,130 --> 00:10:45,730
and based on what said before well they

00:10:44,500 --> 00:10:48,400
can run commands on your server and

00:10:45,730 --> 00:10:53,710
things like that so absolutely do not

00:10:48,400 --> 00:10:54,880
ever use trust the foundation so that

00:10:53,710 --> 00:10:57,250
was a bit of a side-effect let's start

00:10:54,880 --> 00:10:59,080
talking about the application side of

00:10:57,250 --> 00:11:01,090
things everyone knows JSON is the new

00:10:59,080 --> 00:11:02,770
cool thing right we haven't quite

00:11:01,090 --> 00:11:04,870
replaced it at the app level yet I'm

00:11:02,770 --> 00:11:06,310
sure we will soon because Jason is now

00:11:04,870 --> 00:11:08,260
starting to gain all the features from

00:11:06,310 --> 00:11:10,180
XML and we don't want that so you know

00:11:08,260 --> 00:11:11,730
it's turning into XML with curly braces

00:11:10,180 --> 00:11:14,080
and that's not really helping anyone

00:11:11,730 --> 00:11:16,270
and of course postcodes has excellent

00:11:14,080 --> 00:11:18,750
JSON support in fact we have multiple

00:11:16,270 --> 00:11:20,769
different JSON data types to work with

00:11:18,750 --> 00:11:24,129
so we start seeing people do

00:11:20,769 --> 00:11:26,529
this right you know let's create one

00:11:24,129 --> 00:11:28,660
table for all of my data which just has

00:11:26,529 --> 00:11:30,249
an ID field and then JSON and then I can

00:11:28,660 --> 00:11:31,660
just dump everything in the JSON field I

00:11:30,249 --> 00:11:35,709
don't have to deal with columns and

00:11:31,660 --> 00:11:39,489
stuff and and this works it works it

00:11:35,709 --> 00:11:43,029
works like a no sequel database don't do

00:11:39,489 --> 00:11:46,089
that right it's not the smart way to use

00:11:43,029 --> 00:11:48,910
your relational database you're not

00:11:46,089 --> 00:11:50,769
you're you're cutting away 90% of the

00:11:48,910 --> 00:11:52,209
good features of the database in order

00:11:50,769 --> 00:11:54,579
to make it emulate something that it

00:11:52,209 --> 00:11:56,649
isn't now it turns out when this came

00:11:54,579 --> 00:11:59,589
out it was actually faster than the

00:11:56,649 --> 00:12:01,540
leading JSON databases on even when you

00:11:59,589 --> 00:12:02,949
did this I don't think that's true

00:12:01,540 --> 00:12:04,869
anymore because they have improved over

00:12:02,949 --> 00:12:07,629
the past couple of years but still don't

00:12:04,869 --> 00:12:09,459
do that Jason is a data type should be

00:12:07,629 --> 00:12:11,790
used for things that are actually

00:12:09,459 --> 00:12:16,299
unstructured or things that are actually

00:12:11,790 --> 00:12:17,529
unknown so a common way to look at it is

00:12:16,299 --> 00:12:18,970
instead while you have your table

00:12:17,529 --> 00:12:21,009
probably not all my data you're probably

00:12:18,970 --> 00:12:23,410
have more than one of them and for

00:12:21,009 --> 00:12:25,809
everything that you know is going to be

00:12:23,410 --> 00:12:28,439
there most of the time and you know what

00:12:25,809 --> 00:12:33,100
it is and you know what it's called

00:12:28,439 --> 00:12:35,319
you make a regular column but then it

00:12:33,100 --> 00:12:37,689
can make perfect sense to sort of at the

00:12:35,319 --> 00:12:39,309
end of every list you add something like

00:12:37,689 --> 00:12:41,549
you know actual unstructured data and

00:12:39,309 --> 00:12:44,649
just add adjacent column towards the end

00:12:41,549 --> 00:12:47,679
that contains the things that you can't

00:12:44,649 --> 00:12:49,869
map the real columns it might be

00:12:47,679 --> 00:12:52,920
hierarchical data it might be attributes

00:12:49,869 --> 00:12:55,839
that you don't know what they are a

00:12:52,920 --> 00:12:57,459
fairly smart thing that I've seen a

00:12:55,839 --> 00:12:59,230
number of places do when they're large

00:12:57,459 --> 00:13:02,470
is if they don't really know when you're

00:12:59,230 --> 00:13:03,999
you know doing a/b testing or whatever

00:13:02,470 --> 00:13:06,040
you want to deploy a feature you don't

00:13:03,999 --> 00:13:07,660
know if you're gonna need it creating

00:13:06,040 --> 00:13:09,699
new columns and maintaining new columns

00:13:07,660 --> 00:13:11,049
might be hard so what they do is

00:13:09,699 --> 00:13:12,939
whenever they want to add something new

00:13:11,049 --> 00:13:14,259
they added two adjacent be calling at

00:13:12,939 --> 00:13:16,480
the end of the table and then when

00:13:14,259 --> 00:13:18,220
they've run with that for a few

00:13:16,480 --> 00:13:20,169
iterations of the app and they realize

00:13:18,220 --> 00:13:20,939
okay this is actually something that

00:13:20,169 --> 00:13:23,410
we're gonna use

00:13:20,939 --> 00:13:27,519
then they migrate it into a real column

00:13:23,410 --> 00:13:29,319
and if it turns out they're not going to

00:13:27,519 --> 00:13:31,480
use it they just leave it there and

00:13:29,319 --> 00:13:33,880
incrementally remove it as the rows get

00:13:31,480 --> 00:13:35,980
updated throughout the system

00:13:33,880 --> 00:13:38,740
now with newer versions of Postgres it's

00:13:35,980 --> 00:13:40,449
a lot cheaper to add columns you used to

00:13:38,740 --> 00:13:43,089
have a problem in Postgres as well as in

00:13:40,449 --> 00:13:44,110
many other databases whereby if you want

00:13:43,089 --> 00:13:46,480
to add to call them with the default

00:13:44,110 --> 00:13:47,860
value it when you look at your table and

00:13:46,480 --> 00:13:49,420
rewrite the whole thing and you will be

00:13:47,860 --> 00:13:52,149
looking at hours worth of downtown if

00:13:49,420 --> 00:13:54,550
your table was big that's not really a

00:13:52,149 --> 00:13:56,740
problem anymore in modern versions of

00:13:54,550 --> 00:13:58,420
Postgres because you can do that without

00:13:56,740 --> 00:14:00,190
locking and rewriting the table so that

00:13:58,420 --> 00:14:02,769
takes up one reason for it but there are

00:14:00,190 --> 00:14:06,339
still particularly in interaction with

00:14:02,769 --> 00:14:08,850
application frameworks sometimes side

00:14:06,339 --> 00:14:13,300
effects let's call them that of adding

00:14:08,850 --> 00:14:14,680
real-world columns so Jason's an awesome

00:14:13,300 --> 00:14:17,199
feature but you have to use it the right

00:14:14,680 --> 00:14:22,509
way just don't replace everything with

00:14:17,199 --> 00:14:23,709
it and speaking of adding columns let's

00:14:22,509 --> 00:14:25,660
talk a little bit about the topic of

00:14:23,709 --> 00:14:26,980
migrations and now we're not talking

00:14:25,660 --> 00:14:28,029
about you know migrating from Oracle to

00:14:26,980 --> 00:14:31,240
postcards because you should all

00:14:28,029 --> 00:14:32,620
obviously do that but the migrations in

00:14:31,240 --> 00:14:34,720
your application from one version to

00:14:32,620 --> 00:14:36,839
another adding columns adding tables

00:14:34,720 --> 00:14:39,759
removing columns and things like that

00:14:36,839 --> 00:14:41,500
the thing that we unfortunately see is a

00:14:39,759 --> 00:14:42,699
lot of people end up doing when it

00:14:41,500 --> 00:14:45,720
involves just adding a column that's

00:14:42,699 --> 00:14:47,529
fine when it involves modifying data

00:14:45,720 --> 00:14:49,839
avoid doing that in the application

00:14:47,529 --> 00:14:52,269
pretty much everywhere because what it

00:14:49,839 --> 00:14:54,639
ends up being and unfortunately again

00:14:52,269 --> 00:14:57,189
this is often being auto-generated

00:14:54,639 --> 00:14:59,019
migrations in your framework that you're

00:14:57,189 --> 00:15:00,189
going to have to go in and overwrite

00:14:59,019 --> 00:15:03,550
what they're doing if you want it to be

00:15:00,189 --> 00:15:05,139
efficient because what you end up is

00:15:03,550 --> 00:15:08,529
looping over every single row in your

00:15:05,139 --> 00:15:10,600
database and making a change that's not

00:15:08,529 --> 00:15:11,769
good that works perfectly fine in

00:15:10,600 --> 00:15:14,139
development when you have a thousand

00:15:11,769 --> 00:15:15,399
rows not in production where you have a

00:15:14,139 --> 00:15:18,069
billion and a half rows and it might

00:15:15,399 --> 00:15:20,259
take weeks to run and you can't really

00:15:18,069 --> 00:15:23,050
blame the database for that side pretty

00:15:20,259 --> 00:15:25,990
much for everything you do if you can

00:15:23,050 --> 00:15:28,720
push that work into the database it will

00:15:25,990 --> 00:15:31,110
be much faster and it will also be much

00:15:28,720 --> 00:15:31,110
safer

00:15:31,660 --> 00:15:36,900
so just as an example I'm taking this

00:15:34,300 --> 00:15:38,710
guy's because this is more or less

00:15:36,900 --> 00:15:40,180
directly taken from a customer

00:15:38,710 --> 00:15:42,220
application where we had that so they

00:15:40,180 --> 00:15:45,490
had a migration where they wanted to set

00:15:42,220 --> 00:15:47,350
a field to true and what they learned

00:15:45,490 --> 00:15:49,390
was well if you add a column and add a

00:15:47,350 --> 00:15:50,830
default value to it that's really slow

00:15:49,390 --> 00:15:52,180
so they knew not to do that so instead

00:15:50,830 --> 00:15:54,130
they wrote something like this and said

00:15:52,180 --> 00:15:56,200
okay I'm gonna loop over every object

00:15:54,130 --> 00:15:57,910
this is just the Django syntax for

00:15:56,200 --> 00:16:02,350
generating a query we're created was

00:15:57,910 --> 00:16:04,270
before January 1st of 2018 and then

00:16:02,350 --> 00:16:07,180
update this something field to true set

00:16:04,270 --> 00:16:09,940
the modified to now and save so running

00:16:07,180 --> 00:16:13,600
that over 400 million rows turned into

00:16:09,940 --> 00:16:18,880
400 million SQL queries that was not

00:16:13,600 --> 00:16:21,760
very fast imagine that and of course if

00:16:18,880 --> 00:16:26,740
you can just do that one is SQL it's a

00:16:21,760 --> 00:16:28,030
single statement update that something's

00:16:26,740 --> 00:16:33,070
true modify current times then were

00:16:28,030 --> 00:16:36,730
created is this right yes it still has

00:16:33,070 --> 00:16:38,200
to modify 400 million rows it's still

00:16:36,730 --> 00:16:40,570
not going to be super fast if you have

00:16:38,200 --> 00:16:43,210
to modify 400 million rows but it's one

00:16:40,570 --> 00:16:45,340
query it's one one TCP round-trip it's

00:16:43,210 --> 00:16:47,800
one entry into the planner it's it's one

00:16:45,340 --> 00:16:50,860
of a lot of other things that used to be

00:16:47,800 --> 00:16:52,930
400 and it turns out you can almost

00:16:50,860 --> 00:16:56,050
always do it even for very very complex

00:16:52,930 --> 00:16:59,590
transformations you can usually do that

00:16:56,050 --> 00:17:01,570
by pushing it into the database in a lot

00:16:59,590 --> 00:17:04,060
of cases it can even be worth creating a

00:17:01,570 --> 00:17:05,260
temporary stored procedure to do this

00:17:04,060 --> 00:17:08,020
update and then just getting rid of it

00:17:05,260 --> 00:17:10,240
after your migration is done and here

00:17:08,020 --> 00:17:11,800
you can really use the power of Postgres

00:17:10,240 --> 00:17:13,240
multi-language stored procedure so if

00:17:11,800 --> 00:17:15,010
your application happens to be Python

00:17:13,240 --> 00:17:17,620
you can write your stored procedure in

00:17:15,010 --> 00:17:18,910
Python if your application is Perl you

00:17:17,620 --> 00:17:22,120
can write your stored procedure as part

00:17:18,910 --> 00:17:24,189
in Perl if it's JavaScript you can write

00:17:22,120 --> 00:17:26,260
your stored procedure in JavaScript it's

00:17:24,189 --> 00:17:29,820
all there but then you're able to run

00:17:26,260 --> 00:17:33,010
your code very close to your data and

00:17:29,820 --> 00:17:35,140
then you combine this with the fact that

00:17:33,010 --> 00:17:36,670
Postgres has fully transactional DDL so

00:17:35,140 --> 00:17:38,650
you can still take your big migration

00:17:36,670 --> 00:17:40,870
which also includes a few create tables

00:17:38,650 --> 00:17:42,700
or alter tables and create columns and

00:17:40,870 --> 00:17:43,930
things and just wrap them all in one big

00:17:42,700 --> 00:17:45,270
transaction so that your application

00:17:43,930 --> 00:17:47,730
doesn't get confused

00:17:45,270 --> 00:17:52,920
if something happens halfway through the

00:17:47,730 --> 00:17:54,390
migration or something like that it

00:17:52,920 --> 00:17:56,970
tends to work because you know nobody's

00:17:54,390 --> 00:17:58,710
happy when you're applying what you

00:17:56,970 --> 00:18:02,490
think is a small version upgrade and you

00:17:58,710 --> 00:18:04,290
get three days worth of downtime things

00:18:02,490 --> 00:18:09,960
I think nobody's happy would seem weird

00:18:04,290 --> 00:18:12,179
if they were so again the database in

00:18:09,960 --> 00:18:14,210
any relational database is designed to

00:18:12,179 --> 00:18:16,890
run SQL it'll run that faster

00:18:14,210 --> 00:18:18,630
don't run it as what we call I Sam which

00:18:16,890 --> 00:18:20,130
is you know how with the databases in

00:18:18,630 --> 00:18:22,710
the 60s which was move one record

00:18:20,130 --> 00:18:25,610
forward update this feel safe move one

00:18:22,710 --> 00:18:30,840
record forward we don't do that anymore

00:18:25,610 --> 00:18:32,190
so speaking of SQL I mean I'm a database

00:18:30,840 --> 00:18:33,090
bride so of course you should never use

00:18:32,190 --> 00:18:36,150
SQL yeah

00:18:33,090 --> 00:18:37,559
that's evil in an old school and nobody

00:18:36,150 --> 00:18:39,000
wants that and everything is better in

00:18:37,559 --> 00:18:41,490
modern languages right yeah you didn't

00:18:39,000 --> 00:18:42,600
buy that maybe it came with the whole

00:18:41,490 --> 00:18:45,630
thing that I put on the first slide

00:18:42,600 --> 00:18:46,910
saying I'm working with databases but

00:18:45,630 --> 00:18:49,559
there are a number of things obviously

00:18:46,910 --> 00:18:51,690
there are things that are not best done

00:18:49,559 --> 00:18:54,720
in SQL but most of the things that deal

00:18:51,690 --> 00:18:56,700
with your data probably are now there

00:18:54,720 --> 00:18:58,740
are some gotchas through this and in

00:18:56,700 --> 00:19:00,150
particular this one that I've seen a lot

00:18:58,740 --> 00:19:03,300
of people fall into when it comes to

00:19:00,150 --> 00:19:06,720
Postgres which is something called CT es

00:19:03,300 --> 00:19:08,370
or common table expressions it's a

00:19:06,720 --> 00:19:09,900
wonderful term isn't it there are a lot

00:19:08,370 --> 00:19:11,790
of wonderful so - you just listen to

00:19:09,900 --> 00:19:13,170
talk about standards right the sequel

00:19:11,790 --> 00:19:14,220
standard is written by the sequel

00:19:13,170 --> 00:19:15,600
standards committee which is a

00:19:14,220 --> 00:19:18,770
subcommittee of ANSI which is a

00:19:15,600 --> 00:19:20,970
subcommittee ISO or something like that

00:19:18,770 --> 00:19:23,040
they use a different language than

00:19:20,970 --> 00:19:24,390
everyone else they use of different lots

00:19:23,040 --> 00:19:25,980
of things that everyone else so common

00:19:24,390 --> 00:19:28,020
table expressions if you've written SQL

00:19:25,980 --> 00:19:29,730
queries it's something we've generally

00:19:28,020 --> 00:19:31,620
referred to as with queries it's the one

00:19:29,730 --> 00:19:33,120
where you say with and you say okay take

00:19:31,620 --> 00:19:35,610
this whole expression that I have here

00:19:33,120 --> 00:19:37,770
treat it as a virtual table and run a

00:19:35,610 --> 00:19:40,830
query against it and then you can have

00:19:37,770 --> 00:19:43,230
multiple of those and you can make them

00:19:40,830 --> 00:19:45,030
recursive you can do like treat

00:19:43,230 --> 00:19:48,000
reversals and graph traversal from

00:19:45,030 --> 00:19:49,650
things and you can do them either

00:19:48,000 --> 00:19:51,000
recursively or non recursively and they

00:19:49,650 --> 00:19:52,770
turn out to be a really neat way to

00:19:51,000 --> 00:19:54,570
reach to structure your code because it

00:19:52,770 --> 00:19:55,650
makes it a lot readable so for those

00:19:54,570 --> 00:19:56,910
who've you're not used to them its

00:19:55,650 --> 00:19:58,919
syntax is something like this you know

00:19:56,910 --> 00:20:01,679
say with you create this virtual table

00:19:58,919 --> 00:20:04,379
ws and you can put an arbitrarily

00:20:01,679 --> 00:20:05,639
complicated select in there and in

00:20:04,379 --> 00:20:07,529
postcards you could also put an update

00:20:05,639 --> 00:20:09,509
or an insert or delete in there and then

00:20:07,529 --> 00:20:12,779
act upon the result of the update for

00:20:09,509 --> 00:20:14,999
example and then we can just do a select

00:20:12,779 --> 00:20:16,470
and we take W which then we'll take this

00:20:14,999 --> 00:20:18,570
virtual table and join it to its

00:20:16,470 --> 00:20:20,669
different table and things like that and

00:20:18,570 --> 00:20:22,499
there can be multiple sets of joins

00:20:20,669 --> 00:20:24,210
there can be multiple levels and again

00:20:22,499 --> 00:20:27,269
the width can say with recursive in

00:20:24,210 --> 00:20:29,279
which case it can join to itself then

00:20:27,269 --> 00:20:30,889
you can generate infinite loops in SQL

00:20:29,279 --> 00:20:32,850
isn't that fun

00:20:30,889 --> 00:20:34,470
so you can do a lot of things now in

00:20:32,850 --> 00:20:37,019
Postgres the this part is sequel

00:20:34,470 --> 00:20:38,789
standard this part supposedly and

00:20:37,019 --> 00:20:42,149
logically works the same in every

00:20:38,789 --> 00:20:43,619
database in Postgres prior to version 12

00:20:42,149 --> 00:20:45,269
which I'm pretty sure all of you are

00:20:43,619 --> 00:20:48,960
running because version 12 hasn't been

00:20:45,269 --> 00:20:52,590
released yet CTE is in Postgres act as

00:20:48,960 --> 00:20:56,519
an optimization barrier which means that

00:20:52,590 --> 00:20:59,909
when you run a query like this okay this

00:20:56,519 --> 00:21:01,619
is very simple where X but if this where

00:20:59,909 --> 00:21:03,330
condition here postcodes doesn't know if

00:21:01,619 --> 00:21:06,210
there is a relationship between Doggett

00:21:03,330 --> 00:21:10,019
doesn't push optimizations inside of the

00:21:06,210 --> 00:21:11,399
CTE it will run the whole city and then

00:21:10,019 --> 00:21:13,190
it will do something with the result of

00:21:11,399 --> 00:21:16,169
it

00:21:13,190 --> 00:21:19,289
Postgres 12 will start actually

00:21:16,169 --> 00:21:21,749
optimizing the query across these CTE

00:21:19,289 --> 00:21:23,999
borders but if you're using Postgres

00:21:21,749 --> 00:21:25,859
before that unfortunately a lot of the

00:21:23,999 --> 00:21:28,769
time it's really neat to use these CTS

00:21:25,859 --> 00:21:30,989
in order to structure your code but

00:21:28,769 --> 00:21:32,039
you're paying a high price because

00:21:30,989 --> 00:21:35,639
you're basically turning off

00:21:32,039 --> 00:21:37,109
optimization now of course there's also

00:21:35,639 --> 00:21:39,389
the use case when you actually wanted

00:21:37,109 --> 00:21:42,450
that right you can use this to ensure

00:21:39,389 --> 00:21:44,879
that a sub expression is only ever run

00:21:42,450 --> 00:21:48,269
once because that's why we have the CTA

00:21:44,879 --> 00:21:49,830
right so as Postgres 12 turns this off

00:21:48,269 --> 00:21:51,090
there will actually be a new keyword so

00:21:49,830 --> 00:21:54,509
you will be able to say with

00:21:51,090 --> 00:21:57,389
materialized in which case it will still

00:21:54,509 --> 00:21:59,399
ensure that it runs once it materializes

00:21:57,389 --> 00:22:02,330
the result and then it starts processing

00:21:59,399 --> 00:22:02,330
the rest of the query

00:22:04,970 --> 00:22:10,369
but basically if you're using an

00:22:07,970 --> 00:22:12,559
existing version of Postgres because

00:22:10,369 --> 00:22:16,249
only I'm crazy enough to run posters 12

00:22:12,559 --> 00:22:17,149
in production avoid using these unless

00:22:16,249 --> 00:22:18,830
you really know what you're doing

00:22:17,149 --> 00:22:19,489
because they do act as an optimization

00:22:18,830 --> 00:22:21,470
barrier

00:22:19,489 --> 00:22:23,989
it's luckily going away as far as I know

00:22:21,470 --> 00:22:27,080
no other database did that that was very

00:22:23,989 --> 00:22:29,139
much a Postgres thing which is probably

00:22:27,080 --> 00:22:33,099
one of the reasons why a lot of people

00:22:29,139 --> 00:22:36,399
got caught in that trouble

00:22:33,099 --> 00:22:38,539
so speaking of optimization we're all

00:22:36,399 --> 00:22:40,609
building nice applications you're all

00:22:38,539 --> 00:22:42,169
running tests right and then you all run

00:22:40,609 --> 00:22:43,279
explain on your queries to see that

00:22:42,169 --> 00:22:44,779
they're really efficient and they go

00:22:43,279 --> 00:22:46,369
like yes I fetched your three lines of

00:22:44,779 --> 00:22:49,279
data from your 10 line table really

00:22:46,369 --> 00:22:51,229
really fast and we all know that that's

00:22:49,279 --> 00:22:53,869
not good right we all know well you know

00:22:51,229 --> 00:22:55,369
if I'm testing it in in my dev

00:22:53,869 --> 00:22:57,710
environment I need an appropriate amount

00:22:55,369 --> 00:22:59,059
of data if I have a million rows in

00:22:57,710 --> 00:23:01,729
production I should have a million row

00:22:59,059 --> 00:23:03,349
in my test system right so you generate

00:23:01,729 --> 00:23:06,769
a million identical rows and you run it

00:23:03,349 --> 00:23:08,090
and it's still fast the problem that a

00:23:06,769 --> 00:23:10,009
lot of people run into and that turns

00:23:08,090 --> 00:23:14,139
out to actually be really hard is you

00:23:10,009 --> 00:23:17,119
need to test with representative data

00:23:14,139 --> 00:23:18,739
it's not enough I mean obviously

00:23:17,119 --> 00:23:19,879
everything is better than testing

00:23:18,739 --> 00:23:21,649
against an empty system because that

00:23:19,879 --> 00:23:26,419
will just verify that your query syntax

00:23:21,649 --> 00:23:28,879
is correct but it's also really hard

00:23:26,419 --> 00:23:30,499
with fabricated data because the query

00:23:28,879 --> 00:23:32,749
optimizer in any database today is

00:23:30,499 --> 00:23:34,580
pattern based and it's statistics based

00:23:32,749 --> 00:23:36,379
and it will look at your data and it

00:23:34,580 --> 00:23:39,169
will know that well you know oh and

00:23:36,379 --> 00:23:41,059
number of percent of your data contains

00:23:39,169 --> 00:23:43,159
strings longer than 100 characters and

00:23:41,059 --> 00:23:44,899
if you did then generated test data with

00:23:43,159 --> 00:23:48,109
only 10 character long strings all over

00:23:44,899 --> 00:23:50,330
it it's not a relevant test if you

00:23:48,109 --> 00:23:53,539
generated test data with perfect linear

00:23:50,330 --> 00:23:55,419
sequences of numbers and then it turned

00:23:53,539 --> 00:23:59,570
out production was not that perfect

00:23:55,419 --> 00:24:01,129
you're not testing relevant things the

00:23:59,570 --> 00:24:03,109
best thing you can do is of course to

00:24:01,129 --> 00:24:06,830
actually test on a copy of production

00:24:03,109 --> 00:24:08,840
data in a lot of cases that then neatly

00:24:06,830 --> 00:24:09,950
ends up in in some legal issues because

00:24:08,840 --> 00:24:12,259
you're not really allowed to copy

00:24:09,950 --> 00:24:13,759
production data at least not if

00:24:12,259 --> 00:24:15,830
production data contains personal

00:24:13,759 --> 00:24:17,119
information you don't want to be

00:24:15,830 --> 00:24:18,500
deploying that on you know every

00:24:17,119 --> 00:24:21,020
developers laptop

00:24:18,500 --> 00:24:23,120
thing so you will probably need a

00:24:21,020 --> 00:24:25,100
multi-stage setup that you have some

00:24:23,120 --> 00:24:26,600
finish at least on your developer

00:24:25,100 --> 00:24:27,919
laptops and then you have a performance

00:24:26,600 --> 00:24:29,919
testing environment somewhere where you

00:24:27,919 --> 00:24:32,000
have actual production data for example

00:24:29,919 --> 00:24:34,370
or you know you can just push the

00:24:32,000 --> 00:24:35,780
production and test there but everybody

00:24:34,370 --> 00:24:39,380
does not agree with that method for some

00:24:35,780 --> 00:24:40,820
strange reason there are things again

00:24:39,380 --> 00:24:42,380
that we look at postcodes looks at most

00:24:40,820 --> 00:24:44,179
at least common values it looks at

00:24:42,380 --> 00:24:47,169
distribution of values it looks as how

00:24:44,179 --> 00:24:50,000
big a percentage of your table is null

00:24:47,169 --> 00:24:52,010
all sorts of things so which means the

00:24:50,000 --> 00:24:54,830
exact same data sorry the exact same

00:24:52,010 --> 00:24:58,610
size of data can give wildly different

00:24:54,830 --> 00:25:01,220
query plans especially when your data is

00:24:58,610 --> 00:25:03,799
nonlinear especially have if you have

00:25:01,220 --> 00:25:05,450
these use cases where oh you know 20% of

00:25:03,799 --> 00:25:08,500
the table has exactly the same value and

00:25:05,450 --> 00:25:11,510
the other 80% has unique values in it

00:25:08,500 --> 00:25:14,179
like the optimizer tends to do a really

00:25:11,510 --> 00:25:15,770
good job with that but you're not

00:25:14,179 --> 00:25:20,090
testing the same thing if you then just

00:25:15,770 --> 00:25:22,370
replace it with generating data and in

00:25:20,090 --> 00:25:24,110
particular oh let's just put random data

00:25:22,370 --> 00:25:26,120
in there yeah but if you have a good

00:25:24,110 --> 00:25:29,120
random number generator your random data

00:25:26,120 --> 00:25:31,820
will be perfectly distributed your

00:25:29,120 --> 00:25:35,179
customers are not that random most

00:25:31,820 --> 00:25:36,530
likely there are patterns and you will

00:25:35,179 --> 00:25:38,350
need to try to find them of course if

00:25:36,530 --> 00:25:40,429
you actually need to generate data

00:25:38,350 --> 00:25:41,690
postcards have some very neat ways of

00:25:40,429 --> 00:25:43,220
doing that and I just like to put this

00:25:41,690 --> 00:25:44,480
into as many of my presentations as

00:25:43,220 --> 00:25:46,400
possible because people don't know about

00:25:44,480 --> 00:25:49,280
it it's a very useful function in post

00:25:46,400 --> 00:25:50,630
good called generate series it works

00:25:49,280 --> 00:25:52,940
really easy you can do select star from

00:25:50,630 --> 00:25:54,650
generate series you know 1 comma 10,000

00:25:52,940 --> 00:25:57,890
it'll give you every number from 1 to

00:25:54,650 --> 00:25:59,419
10,000 each on a row it's very useful

00:25:57,890 --> 00:26:01,370
just running that query alone is

00:25:59,419 --> 00:26:02,840
probably not very useful because you

00:26:01,370 --> 00:26:04,580
probably know how to count from 1 to

00:26:02,840 --> 00:26:08,210
10,000 in the application you don't need

00:26:04,580 --> 00:26:09,710
a sequel query for that I mean I haven't

00:26:08,210 --> 00:26:12,620
seen people use that but I have seen

00:26:09,710 --> 00:26:15,799
applications that have cold ran and SQL

00:26:12,620 --> 00:26:17,690
query to multiply two values instead of

00:26:15,799 --> 00:26:19,340
doing it in the application so you know

00:26:17,690 --> 00:26:21,110
it's not as far-fetched as you'd think

00:26:19,340 --> 00:26:22,760
but these are also useful things so you

00:26:21,110 --> 00:26:24,470
can use it in a join for example you can

00:26:22,760 --> 00:26:27,350
take a query and join it to a generate

00:26:24,470 --> 00:26:29,179
series see what theta comes out you can

00:26:27,350 --> 00:26:31,840
use generate series to generate testing

00:26:29,179 --> 00:26:33,820
data it will generate a uniform sequence

00:26:31,840 --> 00:26:35,680
but at least you know how big it will be

00:26:33,820 --> 00:26:38,260
but it also exists any few other

00:26:35,680 --> 00:26:40,180
versions you can for example use the

00:26:38,260 --> 00:26:42,610
tempura version of it where you can say

00:26:40,180 --> 00:26:45,820
you know select generate series from now

00:26:42,610 --> 00:26:48,580
until now plus one week with an interval

00:26:45,820 --> 00:26:51,130
of eight hours and then it will actually

00:26:48,580 --> 00:26:54,550
give you a timestamp every eight hours

00:26:51,130 --> 00:26:55,600
in the coming week you might not

00:26:54,550 --> 00:26:57,400
necessarily want to start with now

00:26:55,600 --> 00:26:59,530
because that does give you now with a

00:26:57,400 --> 00:27:00,760
microsecond resolution you might want to

00:26:59,530 --> 00:27:02,140
start you know at the beginning of the

00:27:00,760 --> 00:27:06,040
day or something there's a date version

00:27:02,140 --> 00:27:09,100
of it we start from a date and you can

00:27:06,040 --> 00:27:12,370
use this to join with data to for

00:27:09,100 --> 00:27:14,640
example get values in Windows of eight

00:27:12,370 --> 00:27:17,110
hours and things like that

00:27:14,640 --> 00:27:18,370
I've seen I'm sure if any of you have

00:27:17,110 --> 00:27:20,050
been working a lot with data-driven

00:27:18,370 --> 00:27:21,400
applications you'll see things like oh

00:27:20,050 --> 00:27:24,730
there is a table that contains every

00:27:21,400 --> 00:27:28,180
date in here you know numbers 1 through

00:27:24,730 --> 00:27:29,560
31 for example I've seen those I've seen

00:27:28,180 --> 00:27:32,530
databases where they literally is a

00:27:29,560 --> 00:27:34,180
table called 10,000 that contains every

00:27:32,530 --> 00:27:37,990
number from 1 to 10,000 just in order to

00:27:34,180 --> 00:27:39,490
have something to join with that's kind

00:27:37,990 --> 00:27:41,320
of silly there is actually such a table

00:27:39,490 --> 00:27:45,190
in the Postgres regression test suite

00:27:41,320 --> 00:27:49,270
yes it's a test suite it's useful there

00:27:45,190 --> 00:27:51,730
but nowhere else so if you are ever in

00:27:49,270 --> 00:27:53,410
need of sort of generating transient

00:27:51,730 --> 00:27:54,550
data this is a really good way of doing

00:27:53,410 --> 00:27:56,110
it there are a couple of other versions

00:27:54,550 --> 00:27:59,860
of it you can do numerix you can do

00:27:56,110 --> 00:28:02,200
weird things with it so I talked about

00:27:59,860 --> 00:28:03,880
SQL and said you should never use it and

00:28:02,200 --> 00:28:05,530
you didn't believe it so what next next

00:28:03,880 --> 00:28:08,050
I'm going to tell you to just use or RMS

00:28:05,530 --> 00:28:11,170
right I mean I'm a database guy I'm kind

00:28:08,050 --> 00:28:12,420
of obliged I have to tell you to avoid

00:28:11,170 --> 00:28:14,710
using or elms

00:28:12,420 --> 00:28:15,970
otherwise they would like fire me or

00:28:14,710 --> 00:28:18,730
something I don't know how that works in

00:28:15,970 --> 00:28:20,170
open source but they would try if I told

00:28:18,730 --> 00:28:22,540
you to do it but the fact is that RMS

00:28:20,170 --> 00:28:24,400
are actually quite useful and you

00:28:22,540 --> 00:28:26,110
shouldn't stop using but there are a

00:28:24,400 --> 00:28:30,040
couple of things that are M tends to do

00:28:26,110 --> 00:28:31,930
that you should stop doing I like to

00:28:30,040 --> 00:28:33,370
call them a where I'm over select I made

00:28:31,930 --> 00:28:36,430
that word up myself because I couldn't

00:28:33,370 --> 00:28:39,280
find what other people called it so you

00:28:36,430 --> 00:28:41,740
know feel free and avoid ORM driven

00:28:39,280 --> 00:28:43,570
loops these are really the two things

00:28:41,740 --> 00:28:45,370
the rest of what RMS do is actually

00:28:43,570 --> 00:28:47,920
pretty useful the

00:28:45,370 --> 00:28:49,570
place a lot of boilerplate and there is

00:28:47,920 --> 00:28:52,440
no point in spending a lot of time doing

00:28:49,570 --> 00:28:54,940
things that the computer could do for us

00:28:52,440 --> 00:28:56,830
so what I mean when I say or I'm over

00:28:54,940 --> 00:28:59,890
select it's basically the RM version of

00:28:56,830 --> 00:29:01,120
select star from and that's one of those

00:28:59,890 --> 00:29:02,740
things you learn early if you're

00:29:01,120 --> 00:29:04,510
actually you know taking classes on

00:29:02,740 --> 00:29:06,910
writing SQL applications is don't use

00:29:04,510 --> 00:29:10,059
select star from explicitly list the

00:29:06,910 --> 00:29:14,140
columns that you want it saves a bunch

00:29:10,059 --> 00:29:15,610
of things the biggest problem here so

00:29:14,140 --> 00:29:17,290
you then start doing it with a join so

00:29:15,610 --> 00:29:19,120
you're joining a ten column table with a

00:29:17,290 --> 00:29:23,110
fifteen column table now you're bringing

00:29:19,120 --> 00:29:24,580
back 25 columns and the way that ORM is

00:29:23,110 --> 00:29:26,020
tend to work is they're no they're not

00:29:24,580 --> 00:29:27,790
smart enough to know what you're gonna

00:29:26,020 --> 00:29:29,950
be doing with the objects that you're

00:29:27,790 --> 00:29:32,170
retrieving from the database so they

00:29:29,950 --> 00:29:37,030
fetch everything just in case you might

00:29:32,170 --> 00:29:38,950
need it and that's easier and if you're

00:29:37,030 --> 00:29:40,390
actually going to be reading and using

00:29:38,950 --> 00:29:42,100
every single field that's the most

00:29:40,390 --> 00:29:45,100
efficient way to do it but most of the

00:29:42,100 --> 00:29:46,420
time you probably aren't and the thing

00:29:45,100 --> 00:29:47,800
that's obvious Terrell's well you know

00:29:46,420 --> 00:29:49,240
if it happens to be big text fields

00:29:47,800 --> 00:29:51,309
you're sending a lot of data across the

00:29:49,240 --> 00:29:53,530
network just to throw it away that seems

00:29:51,309 --> 00:29:55,809
useless but it turns out there is

00:29:53,530 --> 00:29:57,520
actually even more than that that it

00:29:55,809 --> 00:29:59,679
turns off some optimizations that you

00:29:57,520 --> 00:30:01,110
can do on the database side in

00:29:59,679 --> 00:30:04,150
particular in Postgres we deal with

00:30:01,110 --> 00:30:06,520
we're transparent dealing with larger

00:30:04,150 --> 00:30:08,140
values it's easiest to see an example

00:30:06,520 --> 00:30:09,940
when we're using text fields it also

00:30:08,140 --> 00:30:12,429
applies to really big numbers it applies

00:30:09,940 --> 00:30:15,850
to geographical regions it applies to

00:30:12,429 --> 00:30:17,620
all sorts of large data but if we look

00:30:15,850 --> 00:30:18,850
at a simple base table I've got a table

00:30:17,620 --> 00:30:22,860
I got an ID you got a first name I got a

00:30:18,850 --> 00:30:22,860
last name right okay that part's simple

00:30:22,920 --> 00:30:28,750
if these are all short strings these are

00:30:25,510 --> 00:30:30,309
all stored within table so if I create a

00:30:28,750 --> 00:30:32,679
table these are literally just stored

00:30:30,309 --> 00:30:35,350
directly in the table and we can read

00:30:32,679 --> 00:30:36,910
them but assuming my table looks

00:30:35,350 --> 00:30:38,770
something like this I have my ID and

00:30:36,910 --> 00:30:40,660
then I have a profile this is more or

00:30:38,770 --> 00:30:43,000
less taken out of a actually a

00:30:40,660 --> 00:30:44,350
conference management system so I will

00:30:43,000 --> 00:30:45,190
show you some other example queries from

00:30:44,350 --> 00:30:47,679
it later as well

00:30:45,190 --> 00:30:50,530
so that's a description and then the

00:30:47,679 --> 00:30:52,720
names and the description can typically

00:30:50,530 --> 00:30:55,840
be you know a couple of paragraphs it'll

00:30:52,720 --> 00:30:57,250
be bigger and what Postgres does when it

00:30:55,840 --> 00:30:59,049
sees the table like this is it'll

00:30:57,250 --> 00:31:00,909
automatically know didn't notice

00:30:59,049 --> 00:31:03,009
individual value basis so not even on

00:31:00,909 --> 00:31:05,440
table or column basis but for every

00:31:03,009 --> 00:31:07,539
individual value Co this description

00:31:05,440 --> 00:31:10,269
hero of Bruce margin is a long

00:31:07,539 --> 00:31:12,070
description and then it'll break it all

00:31:10,269 --> 00:31:13,480
out and it'll actually remove those from

00:31:12,070 --> 00:31:16,389
the table and replace them with a tiny

00:31:13,480 --> 00:31:18,190
pointer and this pointer points into a

00:31:16,389 --> 00:31:21,669
different relation that then contains

00:31:18,190 --> 00:31:23,379
the bigger text and this means if you do

00:31:21,669 --> 00:31:24,970
a select star whenever you read from

00:31:23,379 --> 00:31:26,379
this table it's gonna have to read the

00:31:24,970 --> 00:31:28,360
row and it's gonna have to jump out to

00:31:26,379 --> 00:31:30,639
this other place and fetch the longer

00:31:28,360 --> 00:31:32,799
text but if you're really only

00:31:30,639 --> 00:31:35,139
interested in the name if you just

00:31:32,799 --> 00:31:36,669
select the name not only does it not

00:31:35,139 --> 00:31:38,769
have to send the description across the

00:31:36,669 --> 00:31:40,690
network it doesn't even have to look at

00:31:38,769 --> 00:31:43,210
this extra relation that has the long

00:31:40,690 --> 00:31:46,359
texts at all it can just completely

00:31:43,210 --> 00:31:49,539
ignore it and bypass it which means that

00:31:46,359 --> 00:31:51,789
the wind that you get from not including

00:31:49,539 --> 00:31:54,429
things that you don't really need it's

00:31:51,789 --> 00:31:57,279
even bigger on Postgres than what you'll

00:31:54,429 --> 00:31:59,739
see on a lot of other databases long

00:31:57,279 --> 00:32:02,679
again as an example in the case of

00:31:59,739 --> 00:32:04,330
Python and Django you can usually and

00:32:02,679 --> 00:32:05,980
this is true of most ORM syntax

00:32:04,330 --> 00:32:08,139
obviously different you can either say

00:32:05,980 --> 00:32:11,350
you know I'm getting my messages with

00:32:08,139 --> 00:32:12,820
only these two columns and that will

00:32:11,350 --> 00:32:15,309
actually generate a column that now just

00:32:12,820 --> 00:32:16,809
does is select date comas under I think

00:32:15,309 --> 00:32:19,059
it actually selects the ID comma date

00:32:16,809 --> 00:32:22,210
coma Sandra but but it gets those or you

00:32:19,059 --> 00:32:23,799
can explicitly say defer these fields

00:32:22,210 --> 00:32:26,950
don't get these fields get me everything

00:32:23,799 --> 00:32:29,169
else in case you want to explicitly get

00:32:26,950 --> 00:32:30,730
rid of the big fields now what will

00:32:29,169 --> 00:32:32,919
happen in this case at least in Django

00:32:30,730 --> 00:32:35,409
is if I run this for example I say defer

00:32:32,919 --> 00:32:37,649
body text and then I try to read that

00:32:35,409 --> 00:32:40,029
from my object in the application later

00:32:37,649 --> 00:32:43,210
it's gonna run another query to fetch

00:32:40,029 --> 00:32:46,149
just that one body text and that's

00:32:43,210 --> 00:32:47,590
terrible you really don't want that then

00:32:46,149 --> 00:32:49,179
it's better to include it at the

00:32:47,590 --> 00:32:52,419
beginning of course so it just means

00:32:49,179 --> 00:32:53,889
hint your ORM and let it know which

00:32:52,419 --> 00:32:57,639
fields you're actually going to be

00:32:53,889 --> 00:33:00,190
reading so that it can make the query

00:32:57,639 --> 00:33:03,190
smarter so that the database can

00:33:00,190 --> 00:33:05,489
properly optimize the execution of that

00:33:03,190 --> 00:33:05,489
query

00:33:06,119 --> 00:33:12,059
I say the other thing that we can avoid

00:33:07,669 --> 00:33:14,969
looping in the application tends to call

00:33:12,059 --> 00:33:17,219
slaughter queries right this can quickly

00:33:14,969 --> 00:33:19,139
become exponential I've seen cases with

00:33:17,219 --> 00:33:22,049
over 100,000 SQL queries to load a

00:33:19,139 --> 00:33:28,559
single web page there's no way to make

00:33:22,049 --> 00:33:29,909
that fast latency starts mattering at

00:33:28,559 --> 00:33:31,379
this point even if your database server

00:33:29,909 --> 00:33:33,569
is really close and has maybe one

00:33:31,379 --> 00:33:35,639
millisecond if you're running a hundred

00:33:33,569 --> 00:33:38,519
thousand queries and even the network

00:33:35,639 --> 00:33:40,589
latency is one millisecond that's almost

00:33:38,519 --> 00:33:42,299
two minutes of just waiting for the

00:33:40,589 --> 00:33:45,059
network we haven't even started running

00:33:42,299 --> 00:33:49,529
your query yet so that obviously cannot

00:33:45,059 --> 00:33:51,299
possibly be fast and again the RMS are

00:33:49,529 --> 00:33:53,129
very different here some more amps are

00:33:51,299 --> 00:33:56,069
actually quite smart at figuring things

00:33:53,129 --> 00:33:58,079
out and pushing joins down early most of

00:33:56,069 --> 00:33:59,999
them can't do that because they don't

00:33:58,079 --> 00:34:01,499
know whether you're gonna be looking at

00:33:59,999 --> 00:34:03,059
this other table or not until you look

00:34:01,499 --> 00:34:06,959
at it in that point they already ran the

00:34:03,059 --> 00:34:09,389
previous query and it's too late but as

00:34:06,959 --> 00:34:10,950
a general rule it's almost always better

00:34:09,389 --> 00:34:14,519
to run the Joyner Lee even if it means

00:34:10,950 --> 00:34:17,249
more data because it means fewer queries

00:34:14,519 --> 00:34:19,139
now of course if your first query is

00:34:17,249 --> 00:34:20,819
gonna return 10,000 rows and you're only

00:34:19,139 --> 00:34:23,279
going to be needing the other table for

00:34:20,819 --> 00:34:25,829
three of them yeah you're gonna run an

00:34:23,279 --> 00:34:28,139
extra query right but if you're gonna

00:34:25,829 --> 00:34:30,059
need the other table for 500 of your

00:34:28,139 --> 00:34:34,769
10,000 rows it's probably faster to run

00:34:30,059 --> 00:34:37,619
a join it's that much faster and again

00:34:34,769 --> 00:34:39,329
sometimes you have to hint them there is

00:34:37,619 --> 00:34:42,569
another example those in the Django one

00:34:39,329 --> 00:34:45,149
you say select related to say well I'm

00:34:42,569 --> 00:34:46,739
querying from this model here and as

00:34:45,149 --> 00:34:48,809
they will also fetch this model and this

00:34:46,739 --> 00:34:51,839
model and that'll force the system to

00:34:48,809 --> 00:34:53,279
run and join already at the first time

00:34:51,839 --> 00:34:59,519
because I know that I'm gonna be looking

00:34:53,279 --> 00:35:01,259
at this data or maybe I know that it is

00:34:59,519 --> 00:35:02,789
likely that I'm going to be looking at

00:35:01,259 --> 00:35:07,079
this data it's probably the the more

00:35:02,789 --> 00:35:08,160
appropriate way the thing no worms deal

00:35:07,079 --> 00:35:09,539
with that one pretty well the things

00:35:08,160 --> 00:35:12,289
that they tend to deal with really badly

00:35:09,539 --> 00:35:14,989
today in my experience is dealing with

00:35:12,289 --> 00:35:18,299
group by queries and hierarchical data

00:35:14,989 --> 00:35:19,820
because they're really like the the

00:35:18,299 --> 00:35:21,320
impedance mismatch

00:35:19,820 --> 00:35:22,910
in the object model and the relational

00:35:21,320 --> 00:35:24,830
model is already bad and then you start

00:35:22,910 --> 00:35:28,340
doing recursive necessary things then

00:35:24,830 --> 00:35:30,590
becomes really really bad now we have

00:35:28,340 --> 00:35:32,200
great support for something that

00:35:30,590 --> 00:35:35,120
sometimes called collecting aggregates

00:35:32,200 --> 00:35:37,310
and it turns out the drivers tend to

00:35:35,120 --> 00:35:38,960
have really good support for it but the

00:35:37,310 --> 00:35:41,060
ORM s don't necessarily have it so this

00:35:38,960 --> 00:35:43,700
is a typical case of where it might help

00:35:41,060 --> 00:35:47,240
to override the ORM to push more data

00:35:43,700 --> 00:35:48,410
into the SQL itself so just to show an

00:35:47,240 --> 00:35:49,730
example I have a query I'm just gonna

00:35:48,410 --> 00:35:51,590
start by explaining what it is before I

00:35:49,730 --> 00:35:53,330
show it again this is from a conference

00:35:51,590 --> 00:35:54,800
management system that I I stole it out

00:35:53,330 --> 00:35:58,610
of because it's easy to steal from

00:35:54,800 --> 00:36:01,300
open-source software list conference

00:35:58,610 --> 00:36:03,740
sessions right talks okay here's my talk

00:36:01,300 --> 00:36:04,340
each session would have zero or more

00:36:03,740 --> 00:36:06,050
speakers

00:36:04,340 --> 00:36:07,790
that's where we start getting into the

00:36:06,050 --> 00:36:09,590
problem right it might have more might

00:36:07,790 --> 00:36:10,490
have two speakers might have five might

00:36:09,590 --> 00:36:12,640
have a hundred thousand speakers

00:36:10,490 --> 00:36:14,930
probably not but you know it's possible

00:36:12,640 --> 00:36:16,220
and we want to get the list of the data

00:36:14,930 --> 00:36:18,230
that we need to draw the schedule and

00:36:16,220 --> 00:36:19,040
that's a classic example of things that

00:36:18,230 --> 00:36:20,390
tends to be Oh

00:36:19,040 --> 00:36:22,520
fetch all the list of all the sessions

00:36:20,390 --> 00:36:25,340
then loop for each session fetch the

00:36:22,520 --> 00:36:28,220
list of speakers which is really really

00:36:25,340 --> 00:36:29,810
inefficient so if we start with the easy

00:36:28,220 --> 00:36:32,870
part of this query well we say select

00:36:29,810 --> 00:36:35,870
session ID title and start time from

00:36:32,870 --> 00:36:37,790
sessions and we left join it two

00:36:35,870 --> 00:36:39,320
speakers we have the left join so that

00:36:37,790 --> 00:36:40,790
otherwise if we had a session that had

00:36:39,320 --> 00:36:42,770
no speaker the session would go away

00:36:40,790 --> 00:36:45,260
that would be bad we want it on the

00:36:42,770 --> 00:36:46,880
schedule and then we left join the

00:36:45,260 --> 00:36:50,210
session speakers table into the

00:36:46,880 --> 00:36:52,910
speaker's table so that we get a list of

00:36:50,210 --> 00:36:54,710
the actual speakers and in this case we

00:36:52,910 --> 00:36:57,140
just limit it to the conference ID

00:36:54,710 --> 00:36:58,130
number 17 which happens to be I think

00:36:57,140 --> 00:37:02,030
the first conference where I gave this

00:36:58,130 --> 00:37:05,210
talk and then somehow we have to put the

00:37:02,030 --> 00:37:06,860
speakers in here and we have to put some

00:37:05,210 --> 00:37:08,210
something in there that is aggregate

00:37:06,860 --> 00:37:09,530
otherwise if I just put the speaker name

00:37:08,210 --> 00:37:11,320
in there it will fail as soon as the

00:37:09,530 --> 00:37:13,250
session has more than one speaker right

00:37:11,320 --> 00:37:14,570
then I will get two copies of the

00:37:13,250 --> 00:37:17,240
session and my schedule will look really

00:37:14,570 --> 00:37:19,070
weird now one way you can deal with it

00:37:17,240 --> 00:37:20,780
is you can do a string aggregate and

00:37:19,070 --> 00:37:23,420
just put comma separated list of names

00:37:20,780 --> 00:37:25,760
but then here comes the speaker with a

00:37:23,420 --> 00:37:27,230
comma in their neck like that's unusual

00:37:25,760 --> 00:37:28,580
no it's not because some people will

00:37:27,230 --> 00:37:32,480
just write last name comma first name

00:37:28,580 --> 00:37:33,860
and then it happens so for that we have

00:37:32,480 --> 00:37:35,780
the ability to do an array

00:37:33,860 --> 00:37:38,240
aggregations in this case I say array

00:37:35,780 --> 00:37:40,250
aggregates speaker name so spk that

00:37:38,240 --> 00:37:43,400
would be the alias for this table down

00:37:40,250 --> 00:37:45,890
here so I can aggregate the speaker name

00:37:43,400 --> 00:37:48,730
now we'll get that array of the speakers

00:37:45,890 --> 00:37:53,030
and then I can actually put an order by

00:37:48,730 --> 00:37:56,270
inside the aggregate to make sure that I

00:37:53,030 --> 00:37:58,520
get my speaker's ordered by name in the

00:37:56,270 --> 00:38:01,910
aggregate but then I get the sessions

00:37:58,520 --> 00:38:04,100
ordered by the starting time which turns

00:38:01,910 --> 00:38:08,450
out to be exactly what I wanted that's

00:38:04,100 --> 00:38:10,820
good and then I just add the group by

00:38:08,450 --> 00:38:14,090
session ID so that I get one row for

00:38:10,820 --> 00:38:15,920
each individual session and then it will

00:38:14,090 --> 00:38:22,070
automatically know that okay so create

00:38:15,920 --> 00:38:24,110
an array of each speaker per session and

00:38:22,070 --> 00:38:25,670
if I look at this again I'm showing the

00:38:24,110 --> 00:38:28,700
example from Python if I just run this

00:38:25,670 --> 00:38:31,040
query it comes out as you can see this

00:38:28,700 --> 00:38:33,680
is the Python tuple so it's basically an

00:38:31,040 --> 00:38:35,840
immutable list with four columns and in

00:38:33,680 --> 00:38:39,530
particular the last one here is an array

00:38:35,840 --> 00:38:41,690
of two strings that you there indicates

00:38:39,530 --> 00:38:42,890
that it's a Unicode string because of

00:38:41,690 --> 00:38:45,530
course we're dealing with Unicode and

00:38:42,890 --> 00:38:47,000
also we were you know well-versed in

00:38:45,530 --> 00:38:48,950
Python knows that yes that's Python -

00:38:47,000 --> 00:38:50,090
this system has been upgraded now but it

00:38:48,950 --> 00:38:54,200
hadn't been upgraded what made this

00:38:50,090 --> 00:38:56,750
slide so it gives you back a native

00:38:54,200 --> 00:38:58,370
array which is probably what you wanted

00:38:56,750 --> 00:39:01,190
like your application framework or

00:38:58,370 --> 00:39:02,450
language knows how to deal with erase so

00:39:01,190 --> 00:39:06,440
that works pretty well but then what

00:39:02,450 --> 00:39:09,200
about structure we have a lot of more

00:39:06,440 --> 00:39:11,120
advanced patterns than erase what if we

00:39:09,200 --> 00:39:13,190
have you know we've both a name and a

00:39:11,120 --> 00:39:15,590
company of the speaker how we're gonna

00:39:13,190 --> 00:39:17,780
deal with that well we get multiple

00:39:15,590 --> 00:39:20,120
arrays but it becomes really strange

00:39:17,780 --> 00:39:21,560
when you include the order by because

00:39:20,120 --> 00:39:23,270
you might put the wrong company if you

00:39:21,560 --> 00:39:25,160
can't order the speakers by name and

00:39:23,270 --> 00:39:26,930
then the companies by name and then some

00:39:25,160 --> 00:39:29,870
our loop over them what if we have a

00:39:26,930 --> 00:39:31,400
deeper level structure now we can do

00:39:29,870 --> 00:39:33,320
things like an array of array but that's

00:39:31,400 --> 00:39:35,660
really a pain in the ass if what we're

00:39:33,320 --> 00:39:39,830
dealing with this different data at

00:39:35,660 --> 00:39:41,720
different levels and this is another

00:39:39,830 --> 00:39:43,460
good example of where we can use the

00:39:41,720 --> 00:39:45,920
Postgres json support right because

00:39:43,460 --> 00:39:47,530
jason is a structured format it comes

00:39:45,920 --> 00:39:49,700
back as a single value

00:39:47,530 --> 00:39:50,950
and again it turns out the drivers

00:39:49,700 --> 00:39:53,630
support for this is pretty decent

00:39:50,950 --> 00:39:55,250
everybody supports a race and almost

00:39:53,630 --> 00:39:57,800
everybody supports Jason and it turns I

00:39:55,250 --> 00:39:59,480
mean Jason has become the the format of

00:39:57,800 --> 00:40:03,250
choice so if you look at the same query

00:39:59,480 --> 00:40:07,609
and instead of using the array aggregate

00:40:03,250 --> 00:40:09,320
we use a Jason build object which is a

00:40:07,609 --> 00:40:11,540
function in Postgres that basically

00:40:09,320 --> 00:40:14,030
takes regular data and turns it into a

00:40:11,540 --> 00:40:15,650
JSON object with proper escaping with

00:40:14,030 --> 00:40:17,119
proper layering and things like that so

00:40:15,650 --> 00:40:20,390
here we say create the JSON build object

00:40:17,119 --> 00:40:22,700
that has a key called name with the

00:40:20,390 --> 00:40:25,910
value of full from the column full name

00:40:22,700 --> 00:40:31,609
and a key called company with the value

00:40:25,910 --> 00:40:35,840
from the column company and then with a

00:40:31,609 --> 00:40:38,930
JSON aggregate this so JSON tag of JSON

00:40:35,840 --> 00:40:41,930
objects an order by speaker name that

00:40:38,930 --> 00:40:44,200
means that we get a JSON array which

00:40:41,930 --> 00:40:52,340
where each row contains a JSON object

00:40:44,200 --> 00:40:54,290
with two keys which when we run it comes

00:40:52,340 --> 00:40:56,150
back and it gets turned into in this

00:40:54,290 --> 00:40:59,869
case again Python comes back into a

00:40:56,150 --> 00:41:00,950
native dict it's an array so a list is

00:40:59,869 --> 00:41:03,859
what we'll call them in Python this is a

00:41:00,950 --> 00:41:06,680
list of actual objects and we can access

00:41:03,859 --> 00:41:08,780
them as if they were objects and we can

00:41:06,680 --> 00:41:11,060
pass this directly out into our

00:41:08,780 --> 00:41:14,000
templates and access them as objects

00:41:11,060 --> 00:41:16,000
within the templates and even when

00:41:14,000 --> 00:41:24,650
running across pretty large sets of data

00:41:16,000 --> 00:41:26,300
this is actually really fast so the

00:41:24,650 --> 00:41:29,960
final thing about the ORM loops is the

00:41:26,300 --> 00:41:31,310
acting on multiple objects things so

00:41:29,960 --> 00:41:33,230
let's go through the problem like we

00:41:31,310 --> 00:41:34,609
will you've all learned to use bound

00:41:33,230 --> 00:41:36,140
parameters right we're not supposed to

00:41:34,609 --> 00:41:37,550
use string concatenation to build our

00:41:36,140 --> 00:41:40,510
queries and then you know invite people

00:41:37,550 --> 00:41:42,710
to do SQL injection and things like that

00:41:40,510 --> 00:41:44,300
so you use something like this and again

00:41:42,710 --> 00:41:47,570
the syntax in the Python driver would be

00:41:44,300 --> 00:41:49,520
execute you say percent and the key name

00:41:47,570 --> 00:41:51,920
s and then you give the key name and

00:41:49,520 --> 00:41:55,570
give an actual value so it works fine

00:41:51,920 --> 00:41:57,890
but what if I want to update 20 objects

00:41:55,570 --> 00:41:59,750
the naive way of doing it is of course

00:41:57,890 --> 00:42:01,960
let's loop over 20 objects and run this

00:41:59,750 --> 00:42:04,609
20 times

00:42:01,960 --> 00:42:07,070
or I can do this you know I can say

00:42:04,609 --> 00:42:10,550
where X in then I can do ID 1 an ID 2

00:42:07,070 --> 00:42:12,560
and you know do that and then I can do

00:42:10,550 --> 00:42:14,599
one version for three of them and I can

00:42:12,560 --> 00:42:17,930
do one version for four of them and and

00:42:14,599 --> 00:42:19,040
that does not scale it doesn't scale

00:42:17,930 --> 00:42:20,660
from your application perspective

00:42:19,040 --> 00:42:22,880
because you'd write different things all

00:42:20,660 --> 00:42:24,440
the time we wanted to avoid doing that

00:42:22,880 --> 00:42:26,359
that's why we were using these tools in

00:42:24,440 --> 00:42:28,369
the first place it generates a whole

00:42:26,359 --> 00:42:29,869
bunch of unique queries which will make

00:42:28,369 --> 00:42:31,250
it much harder to monitor your system

00:42:29,869 --> 00:42:33,369
because it's actually the same query but

00:42:31,250 --> 00:42:36,109
the system has no way of knowing that

00:42:33,369 --> 00:42:38,210
you can easily flood these like top most

00:42:36,109 --> 00:42:40,280
common queries are all versions of this

00:42:38,210 --> 00:42:42,369
just one with one parameter one win 3-1

00:42:40,280 --> 00:42:45,980
with 4 one with seven one with 15 and

00:42:42,369 --> 00:42:50,000
things like that so so we have all of

00:42:45,980 --> 00:42:53,570
these ways of dealing with it we can

00:42:50,000 --> 00:42:56,810
always do this right we can do where X

00:42:53,570 --> 00:43:00,700
in and then coma and we join the list of

00:42:56,810 --> 00:43:02,329
IDs and did we not learn this

00:43:00,700 --> 00:43:03,680
unfortunately I see this all the time

00:43:02,329 --> 00:43:05,000
right from all the people who have

00:43:03,680 --> 00:43:07,040
learned that you should never do string

00:43:05,000 --> 00:43:08,839
concatenation well guess what that is

00:43:07,040 --> 00:43:12,010
string concatenation and we're putting a

00:43:08,839 --> 00:43:15,560
string right in there don't do that ever

00:43:12,010 --> 00:43:18,740
in this case as long as if we know that

00:43:15,560 --> 00:43:20,990
the ID list is only integers if we know

00:43:18,740 --> 00:43:22,640
that then yes it will not be a sequel

00:43:20,990 --> 00:43:26,599
injection attack it will just be an

00:43:22,640 --> 00:43:28,160
inefficient query but what if you knew

00:43:26,599 --> 00:43:30,079
that it was only integers and then

00:43:28,160 --> 00:43:32,329
tomorrow somebody takes a user parameter

00:43:30,079 --> 00:43:33,859
and lets it through because everybody

00:43:32,329 --> 00:43:35,930
knows that we escape everything that

00:43:33,859 --> 00:43:40,069
goes into the database and then BOOM you

00:43:35,930 --> 00:43:43,069
didn't and you were lost the way that we

00:43:40,069 --> 00:43:44,390
can deal with this is using a race and

00:43:43,069 --> 00:43:46,130
we're getting back to it we use the race

00:43:44,390 --> 00:43:48,980
in the aggregates to get data out of the

00:43:46,130 --> 00:43:51,530
database we can bind arrays to our calls

00:43:48,980 --> 00:43:54,380
to get multiple objects into the

00:43:51,530 --> 00:43:58,730
database so this is my query my update

00:43:54,380 --> 00:44:01,940
or delete where x equals any ID list and

00:43:58,730 --> 00:44:04,119
this here is the actual array so a query

00:44:01,940 --> 00:44:06,880
that can be written as where X in

00:44:04,119 --> 00:44:09,170
parentheses and a list of values is

00:44:06,880 --> 00:44:11,990
identical to a query that says where x

00:44:09,170 --> 00:44:13,660
equals any and an array of the same

00:44:11,990 --> 00:44:15,250
values

00:44:13,660 --> 00:44:16,869
you can see this actually because if you

00:44:15,250 --> 00:44:19,569
look at a post quest query plan of those

00:44:16,869 --> 00:44:22,779
two queries it's the same it even

00:44:19,569 --> 00:44:26,470
rewrites it to this for you

00:44:22,779 --> 00:44:27,880
and you bind the array and what happens

00:44:26,470 --> 00:44:29,289
there is that the driver and posters

00:44:27,880 --> 00:44:32,079
will agree upon the fact that this is an

00:44:29,289 --> 00:44:34,329
array of integers for example or this is

00:44:32,079 --> 00:44:36,460
an array of strings and everything will

00:44:34,329 --> 00:44:39,549
be properly escaped and everything will

00:44:36,460 --> 00:44:43,240
actually work and it works equally well

00:44:39,549 --> 00:44:45,519
for functions select my function give it

00:44:43,240 --> 00:44:47,500
an array you call the function once or

00:44:45,519 --> 00:44:49,380
the stored procedure then you can do

00:44:47,500 --> 00:44:54,420
smart things in that stored procedure

00:44:49,380 --> 00:44:58,599
across multiple objects do that and

00:44:54,420 --> 00:45:01,119
don't do loops because running many many

00:44:58,599 --> 00:45:03,880
many queries in loops is the single most

00:45:01,119 --> 00:45:06,700
common reason for database driven

00:45:03,880 --> 00:45:08,500
applications to actually be slow you're

00:45:06,700 --> 00:45:13,630
not letting the database do what it's

00:45:08,500 --> 00:45:14,980
good at and you should be doing that so

00:45:13,630 --> 00:45:16,390
I'm just gonna mention one final thing I

00:45:14,980 --> 00:45:17,799
can see you want is even getting up here

00:45:16,390 --> 00:45:19,930
is getting ready to push me off stage

00:45:17,799 --> 00:45:23,079
but I'm not running over just yet are

00:45:19,930 --> 00:45:24,579
you gonna pull this thing up so get even

00:45:23,079 --> 00:45:25,720
one final thing which is just one of

00:45:24,579 --> 00:45:26,920
those classics which is really not

00:45:25,720 --> 00:45:28,660
something you have to do actually it

00:45:26,920 --> 00:45:31,329
probably is who's ever who's ever like

00:45:28,660 --> 00:45:33,250
search Stack Overflow for something yeah

00:45:31,329 --> 00:45:34,809
yeah so this is a good this is a good

00:45:33,250 --> 00:45:35,289
case of it you probably don't have a

00:45:34,809 --> 00:45:38,049
deadlock

00:45:35,289 --> 00:45:39,309
I see Suman so many people who search

00:45:38,049 --> 00:45:41,579
for that we get questions from our

00:45:39,309 --> 00:45:43,720
customers about their being deadlocks

00:45:41,579 --> 00:45:46,269
you have to separate the idea of a

00:45:43,720 --> 00:45:48,549
blocking lock from a deadlock because

00:45:46,269 --> 00:45:51,039
every database application that has more

00:45:48,549 --> 00:45:52,509
than one user will have blocking locks

00:45:51,039 --> 00:45:54,789
so what's a blocking lock well it means

00:45:52,509 --> 00:45:56,500
this session is do something this other

00:45:54,789 --> 00:45:59,349
session is waiting for this guy to get

00:45:56,500 --> 00:46:02,049
done okay that's a blocking log if this

00:45:59,349 --> 00:46:03,400
guy takes two weeks to get done this one

00:46:02,049 --> 00:46:04,809
will wait for two weeks and then it will

00:46:03,400 --> 00:46:07,779
do its thing right and people say oh

00:46:04,809 --> 00:46:09,670
that's a deadlock no it's not that's a

00:46:07,779 --> 00:46:11,710
regular lock now post-course is mostly a

00:46:09,670 --> 00:46:13,359
lot less database but there still looks

00:46:11,710 --> 00:46:15,339
for some things for example this this

00:46:13,359 --> 00:46:17,140
slow guy could be rewriting a table

00:46:15,339 --> 00:46:19,299
doing an alter table in an incompatible

00:46:17,140 --> 00:46:22,029
way right everybody has to wait that is

00:46:19,299 --> 00:46:25,630
not a deadlock a deadlock is a lock that

00:46:22,029 --> 00:46:27,280
can be proven to never be resolved to

00:46:25,630 --> 00:46:30,300
never get loosed

00:46:27,280 --> 00:46:33,100
so for example if I have a session a

00:46:30,300 --> 00:46:35,860
that's waiting for session B and session

00:46:33,100 --> 00:46:38,380
B is waiting for session a they're

00:46:35,860 --> 00:46:39,130
waiting for each other that will never

00:46:38,380 --> 00:46:40,780
be resolved

00:46:39,130 --> 00:46:43,000
that's a deadlock and it can be two

00:46:40,780 --> 00:46:44,650
sessions it can be session a waiting for

00:46:43,000 --> 00:46:46,990
be waiting for C waiting for D waiting

00:46:44,650 --> 00:46:49,240
for E and E is waiting for a and you

00:46:46,990 --> 00:46:50,010
have a circle that will never get

00:46:49,240 --> 00:46:53,620
resolved

00:46:50,010 --> 00:46:55,180
that's a deadlock right and what happens

00:46:53,620 --> 00:46:57,760
then is Postgres has a deadlock detector

00:46:55,180 --> 00:46:59,170
it'll kick in if by default after one

00:46:57,760 --> 00:47:00,460
second if it detects with her multiple

00:46:59,170 --> 00:47:01,720
sessions that are somehow waiting on

00:47:00,460 --> 00:47:03,460
each other and then it will do an

00:47:01,720 --> 00:47:05,470
enumeration and see if there is actually

00:47:03,460 --> 00:47:08,920
a deadlock if it is it'll pick one of

00:47:05,470 --> 00:47:11,590
those and kill it so deadlocks won't

00:47:08,920 --> 00:47:13,210
actually make your application stop what

00:47:11,590 --> 00:47:14,320
it will do is it will kill your queries

00:47:13,210 --> 00:47:16,390
and you will get an error to the

00:47:14,320 --> 00:47:18,850
application but that's a very different

00:47:16,390 --> 00:47:21,130
thing now both of them can happen

00:47:18,850 --> 00:47:22,510
regular blocking locks is normal but

00:47:21,130 --> 00:47:24,600
depending on how they happen it's

00:47:22,510 --> 00:47:26,530
something you need to deal with

00:47:24,600 --> 00:47:28,120
deadlocks usually mean you need to

00:47:26,530 --> 00:47:30,940
restructure application and run your

00:47:28,120 --> 00:47:32,260
code in a different order because it's

00:47:30,940 --> 00:47:34,240
typically happens when you're doing two

00:47:32,260 --> 00:47:36,010
very similar things but you're accessing

00:47:34,240 --> 00:47:37,510
the data in opposite orders then the

00:47:36,010 --> 00:47:39,760
locks come in in opposite orders and you

00:47:37,510 --> 00:47:40,990
get a deadlock right but in particular

00:47:39,760 --> 00:47:44,050
look for the right thing when you look

00:47:40,990 --> 00:47:45,190
at stack overflow and also today look

00:47:44,050 --> 00:47:46,510
for the wrong thing when you look on

00:47:45,190 --> 00:47:48,760
stack overflow because so many people

00:47:46,510 --> 00:47:51,820
get that wrong that you will actually

00:47:48,760 --> 00:47:56,110
find answers under the wrong terms so

00:47:51,820 --> 00:47:57,760
look for both of them and that is it for

00:47:56,110 --> 00:47:59,470
me thank you very much for paying the

00:47:57,760 --> 00:48:02,080
attention I think we might have like two

00:47:59,470 --> 00:48:04,270
minutes or so for a question and then

00:48:02,080 --> 00:48:09,120
we'll have to give the next one so

00:48:04,270 --> 00:48:11,590
anyone I'm ready to run raise your hand

00:48:09,120 --> 00:48:14,280
yes it was someone in the back he has to

00:48:11,590 --> 00:48:14,280
truly run

00:48:19,870 --> 00:48:25,720
you were so entire of using lists in

00:48:23,200 --> 00:48:29,290
order to speed up carries with a lot of

00:48:25,720 --> 00:48:31,300
iterations of the same carry what is the

00:48:29,290 --> 00:48:34,380
performance of using temporary tables

00:48:31,300 --> 00:48:38,170
instead of embedded lists into a carry

00:48:34,380 --> 00:48:41,500
so temporary tables in Postgres are

00:48:38,170 --> 00:48:43,180
pretty slow as in the temporary table

00:48:41,500 --> 00:48:45,370
itself is not pretty slow but it's the

00:48:43,180 --> 00:48:47,080
creation and dropping of temporary

00:48:45,370 --> 00:48:49,570
tables that are fairly slow they're very

00:48:47,080 --> 00:48:52,150
different in different databases in for

00:48:49,570 --> 00:48:54,660
example Sybase level two Sybase and

00:48:52,150 --> 00:48:57,730
microsoft databases they're pretty fast

00:48:54,660 --> 00:48:59,020
in oracle group databases they're

00:48:57,730 --> 00:49:02,200
somewhere in the middle and in Postgres

00:48:59,020 --> 00:49:04,510
they're pretty slow in general if you

00:49:02,200 --> 00:49:06,100
create a temporary table it has two the

00:49:04,510 --> 00:49:08,140
cost is it has to create a bunch of

00:49:06,100 --> 00:49:10,480
things in the system tables it has to

00:49:08,140 --> 00:49:13,000
create an actual file to back it even if

00:49:10,480 --> 00:49:14,680
that file may never leave the cache it

00:49:13,000 --> 00:49:16,710
will never actually hit disk it has to

00:49:14,680 --> 00:49:21,520
be created and then it has to be removed

00:49:16,710 --> 00:49:23,050
so if you can write it in a way that you

00:49:21,520 --> 00:49:25,030
don't need temporary tables you're

00:49:23,050 --> 00:49:26,860
probably better off you can very often

00:49:25,030 --> 00:49:29,620
get away with for example using one of

00:49:26,860 --> 00:49:31,960
these CT es or a with table with a set

00:49:29,620 --> 00:49:33,460
of values but of course it comes down to

00:49:31,960 --> 00:49:38,710
how much you need to do with your data

00:49:33,460 --> 00:49:45,550
as part of the running do we have one

00:49:38,710 --> 00:49:46,870
more and I'd like to silence then thank

00:49:45,550 --> 00:49:48,370
you very much I'll be around the whole

00:49:46,870 --> 00:49:50,170
time see if you have any further

00:49:48,370 --> 00:49:52,030
questions just grab me I'll be in the

00:49:50,170 --> 00:49:53,950
hole well I'll be over red pill has a

00:49:52,030 --> 00:49:55,630
sponsor booth which is sort of out the

00:49:53,950 --> 00:49:57,070
door and on the left you'll probably

00:49:55,630 --> 00:49:59,290
find me there a bit if you want to talk

00:49:57,070 --> 00:50:00,600
more Postgres or databases in general so

00:49:59,290 --> 00:50:02,980
so thank you very much

00:50:00,600 --> 00:50:05,040
[Music]

00:50:02,980 --> 00:50:05,040
you

00:50:11,920 --> 00:50:13,980

YouTube URL: https://www.youtube.com/watch?v=GhCCs_K7194


