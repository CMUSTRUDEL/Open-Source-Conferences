Title: The ultimate guide to software updates on embedded Linux devices - Mirza Krak
Publication date: 2018-04-27
Playlist: foss-north 2018
Description: 
	Software updates on embedded Linux devices has for a long time been a mess, consisting of "homegrown" solutions specific to a certain project and there was very little re-usage between projects and very little collaboration in our community to solve these complex problems. Luckily for us that time is over and the community around this topic has grown over last couple years and still is growing as the demand increases with the IoT revolution and OTA firmware updates (which introduces even more complexity).

There are now well established open-source solutions that have been "battle tested" that we can collaborate on to make the complexity of software updates manageable. We are heading for a time where a quality Board Support Package should provide an software update implementation because it really should be solved at this level instead of handing this over to application developers which have limited knowledge of low lever architecture on a embedded device.

In this talk Mirza will present some of the challenges of doing software updates on embedded system. He will also present the available open-source projects that help with solving these challenges. The projects are: SWupdate, Mender, RAUC, aktualizr (libostree) and resin.io.

He will also do a head-to-head comparison of them. There is no "one fits all" solution and each one has different goals and approaches to solving the problem. This is something that we have come accustom to in the open-source community and is how we thrive. 

---

Mirza Krak is an embedded Linux developer with over six years of experience in the field and is currently employed by Endian Technologies AB, where he works as a consultant helping companies to deploy embedded Linux devices. He is involved in various open-source projects and is a Linux kernel contributor. Mirza enjoys learning new things and in general sees solutions/opportunities instead of problems. 

http://foss-north.se/2018/speakers-and-talks.html#mkrak
Captions: 
	00:00:14,700 --> 00:00:20,870
yes it's an honor to finish off the

00:00:17,870 --> 00:00:23,330
hopefully were able to stay awake you

00:00:20,870 --> 00:00:28,550
know one day and I have a lot of

00:00:23,330 --> 00:00:33,100
information I'm gonna throw at you let's

00:00:28,550 --> 00:00:36,220
get to this so yeah my talk is about

00:00:33,100 --> 00:00:40,070
doing software updates on embedded Linux

00:00:36,220 --> 00:00:43,489
so a quick session overview I will do a

00:00:40,070 --> 00:00:46,640
quick intro on myself and then we're

00:00:43,489 --> 00:00:48,200
gonna go through some basic concepts of

00:00:46,640 --> 00:00:50,750
doing software updates on aberrant

00:00:48,200 --> 00:00:54,320
limits and then we're going to try to

00:00:50,750 --> 00:00:57,080
take a look at open source ecosystem

00:00:54,320 --> 00:01:00,170
around software updates the existing

00:00:57,080 --> 00:01:04,280
projects the disease out there and we'll

00:01:00,170 --> 00:01:06,800
focus on which strategy tragedy they

00:01:04,280 --> 00:01:09,560
employ which keep which are key features

00:01:06,800 --> 00:01:11,810
of each project and also take a look how

00:01:09,560 --> 00:01:16,150
active the communities or our bigger

00:01:11,810 --> 00:01:19,100
communities around this project so

00:01:16,150 --> 00:01:22,160
quickly about me positives just of

00:01:19,100 --> 00:01:24,590
course I'm here and speaking work mostly

00:01:22,160 --> 00:01:29,890
with board Support Package development

00:01:24,590 --> 00:01:32,240
so I do a lot of awareness of loaders

00:01:29,890 --> 00:01:35,480
the last few years has been a lot of the

00:01:32,240 --> 00:01:37,520
Yocto and the way core work now employed

00:01:35,480 --> 00:01:41,720
by an Indian supplied technologies which

00:01:37,520 --> 00:01:44,780
is our local contractor company and I

00:01:41,720 --> 00:01:47,270
would also like the disclaimer I am a

00:01:44,780 --> 00:01:51,770
moral man there is a project that I'm

00:01:47,270 --> 00:01:54,350
gonna cover which I am involved in in

00:01:51,770 --> 00:01:56,180
the community so but I would try not to

00:01:54,350 --> 00:02:00,650
be biased when I'm comparing it to the

00:01:56,180 --> 00:02:04,460
other ones you know and but it limits

00:02:00,650 --> 00:02:06,860
the biases question is yeah what's an

00:02:04,460 --> 00:02:09,140
embedded Linux device well nowadays

00:02:06,860 --> 00:02:12,500
Linux is in everything so in public

00:02:09,140 --> 00:02:16,250
transport in trash cans and faucets to

00:02:12,500 --> 00:02:17,690
some reason so bluemix is everywhere so

00:02:16,250 --> 00:02:20,390
it's pretty generic what are the

00:02:17,690 --> 00:02:23,030
embedded into this device is but they

00:02:20,390 --> 00:02:26,930
all run run software and you all need to

00:02:23,030 --> 00:02:30,340
update software of course and there are

00:02:26,930 --> 00:02:30,340
some key factors

00:02:30,630 --> 00:02:36,930
the better Linux environment has some

00:02:33,260 --> 00:02:42,750
differences compared to like desktop PC

00:02:36,930 --> 00:02:45,360
Linux or server-side so nowadays we have

00:02:42,750 --> 00:02:50,010
a lot of connected devices so usually

00:02:45,360 --> 00:02:52,080
you have yeah you have no physical

00:02:50,010 --> 00:02:54,090
access to your devices or it's very hard

00:02:52,080 --> 00:02:56,850
to get to your devices or it's very

00:02:54,090 --> 00:02:59,700
costly to get tax physical physical

00:02:56,850 --> 00:03:01,739
access to your device so that's a

00:02:59,700 --> 00:03:04,050
limitation that you have to like

00:03:01,739 --> 00:03:06,720
consider when deploying embedded Linux

00:03:04,050 --> 00:03:08,220
devices and normally the long lifespan

00:03:06,720 --> 00:03:14,820
is pretty long the embedded Linux

00:03:08,220 --> 00:03:16,739
compared to other products so it's

00:03:14,820 --> 00:03:18,810
getting even longer as like a better

00:03:16,739 --> 00:03:20,880
little Linux is deployed in cars of

00:03:18,810 --> 00:03:24,600
course with more than five to ten years

00:03:20,880 --> 00:03:27,660
hopefully so that's one of them one of

00:03:24,600 --> 00:03:30,959
the key consideration have to keep in

00:03:27,660 --> 00:03:33,239
mind and a common thing is like also on

00:03:30,959 --> 00:03:35,910
real about unreliable power supply is

00:03:33,239 --> 00:03:37,950
something that if you have a device

00:03:35,910 --> 00:03:41,340
installed in a public transport like in

00:03:37,950 --> 00:03:43,709
a bus you can lose power at any time so

00:03:41,340 --> 00:03:44,010
you have to take keep that in mind when

00:03:43,709 --> 00:03:46,019
doing

00:03:44,010 --> 00:03:52,049
for example software updates please

00:03:46,019 --> 00:03:53,970
bigger to handle this situation and

00:03:52,049 --> 00:03:57,510
often if it's if the device is connected

00:03:53,970 --> 00:04:00,470
and somehow they usually connected with

00:03:57,510 --> 00:04:04,700
mobile or so you have unreliable

00:04:00,470 --> 00:04:07,079
connectivity which you also have to yeah

00:04:04,700 --> 00:04:09,470
it's a limitation if you have that you

00:04:07,079 --> 00:04:11,940
have to handle in your embedded device

00:04:09,470 --> 00:04:13,820
so why do we need software updates well

00:04:11,940 --> 00:04:17,039
these are hopefully pretty obvious but

00:04:13,820 --> 00:04:19,440
just quickly so we need to fix issues we

00:04:17,039 --> 00:04:22,470
don't write perfect software so once we

00:04:19,440 --> 00:04:23,729
deploy our devices we need to be able to

00:04:22,470 --> 00:04:27,479
update the software in the devices

00:04:23,729 --> 00:04:30,590
either locally or remotely you want to

00:04:27,479 --> 00:04:35,220
be able to add features so once you

00:04:30,590 --> 00:04:36,990
deploy your device and this is quite

00:04:35,220 --> 00:04:39,000
critical nowadays where time to market

00:04:36,990 --> 00:04:42,210
is often a thing and the devices are

00:04:39,000 --> 00:04:44,430
washed so then you can ship your device

00:04:42,210 --> 00:04:46,200
with some critical features and add more

00:04:44,430 --> 00:04:49,220
features playing around with software

00:04:46,200 --> 00:04:52,289
updates and of course security updates

00:04:49,220 --> 00:04:55,020
is one of the biggest reasons why we

00:04:52,289 --> 00:04:57,419
need to keep doing updates when the

00:04:55,020 --> 00:05:00,960
devices are in the file because like

00:04:57,419 --> 00:05:03,810
most of us know as software gets older

00:05:00,960 --> 00:05:05,880
it gets more and more known exploits and

00:05:03,810 --> 00:05:08,010
vulnerabilities of course so there's

00:05:05,880 --> 00:05:10,620
even a fancy dead data database that you

00:05:08,010 --> 00:05:12,360
can go and look up known exploits on

00:05:10,620 --> 00:05:15,180
components that are critical in embedded

00:05:12,360 --> 00:05:19,680
Linux devices so here's an example for

00:05:15,180 --> 00:05:22,770
drop-in SSH server and anybody can look

00:05:19,680 --> 00:05:24,510
this information up and exploit that if

00:05:22,770 --> 00:05:28,200
you haven't updated at that component

00:05:24,510 --> 00:05:30,150
okay so we need to continuously update

00:05:28,200 --> 00:05:35,580
our devices to close the security holes

00:05:30,150 --> 00:05:38,640
that are exposed so one use case when

00:05:35,580 --> 00:05:40,349
doing software updates is doing it on

00:05:38,640 --> 00:05:43,080
site and that means that you have

00:05:40,349 --> 00:05:46,110
physical access and the device doesn't

00:05:43,080 --> 00:05:47,940
have internet connectivity so you have

00:05:46,110 --> 00:05:50,250
to have a technician or the other user

00:05:47,940 --> 00:05:53,490
and this usually involves like a USB

00:05:50,250 --> 00:05:55,349
flash drive it's some kind of a belief

00:05:53,490 --> 00:05:58,560
that you need to plug into the device

00:05:55,349 --> 00:06:01,710
you can update so this is a fairly easy

00:05:58,560 --> 00:06:04,260
use case but nowadays it's more focused

00:06:01,710 --> 00:06:06,060
on like doing over-the-air updates

00:06:04,260 --> 00:06:08,039
because devices are getting connected

00:06:06,060 --> 00:06:11,610
and then we can you utilize the

00:06:08,039 --> 00:06:14,580
connectivity to do software updates not

00:06:11,610 --> 00:06:17,010
requiring a technician or a user going

00:06:14,580 --> 00:06:21,270
to the device with a USB flash stick and

00:06:17,010 --> 00:06:22,800
this opens opportunities but also there

00:06:21,270 --> 00:06:24,750
comes some challenges with this of

00:06:22,800 --> 00:06:25,919
course it's not an easy thing to

00:06:24,750 --> 00:06:29,639
implement

00:06:25,919 --> 00:06:31,979
in a robust way but we do software

00:06:29,639 --> 00:06:33,990
updates over there you you usually need

00:06:31,979 --> 00:06:35,879
some kind of deployment server

00:06:33,990 --> 00:06:38,310
management server where you can manage

00:06:35,879 --> 00:06:44,400
your devices and the deploy the software

00:06:38,310 --> 00:06:47,340
updates to the device typical components

00:06:44,400 --> 00:06:50,849
of our embedded Linux device a bit

00:06:47,340 --> 00:06:52,590
simplified but this is generally what I

00:06:50,849 --> 00:06:54,629
see when I look at the embedded Linux

00:06:52,590 --> 00:06:58,129
device issue you normally have some kind

00:06:54,629 --> 00:07:00,539
of bootloader most cases it's your boots

00:06:58,129 --> 00:07:03,689
then you have some kind of we have the

00:07:00,539 --> 00:07:05,580
Linux kernel and as I work mostly with

00:07:03,689 --> 00:07:07,729
arm devices you need to have a device

00:07:05,580 --> 00:07:09,949
tree and that goes to the Linux kernel

00:07:07,729 --> 00:07:12,900
and then you have your root filesystem

00:07:09,949 --> 00:07:15,270
the distribution part and this means

00:07:12,900 --> 00:07:18,240
this I mean like your image manager your

00:07:15,270 --> 00:07:20,129
network manager and all the software

00:07:18,240 --> 00:07:22,169
that you don't actually write you just

00:07:20,129 --> 00:07:24,749
rely on this functionality to be there

00:07:22,169 --> 00:07:27,419
in your Linux distribution and then you

00:07:24,749 --> 00:07:30,419
have some kind of customer application

00:07:27,419 --> 00:07:33,750
on top of that in some cases you also

00:07:30,419 --> 00:07:36,210
have some kind of MCU or microcontroller

00:07:33,750 --> 00:07:38,219
on the side of the Linux that also needs

00:07:36,210 --> 00:07:41,330
software updates but I'm not really

00:07:38,219 --> 00:07:45,149
going to cover that but it's still there

00:07:41,330 --> 00:07:50,729
so some basic requirements that you need

00:07:45,149 --> 00:07:53,460
when you do software updates there are

00:07:50,729 --> 00:07:54,629
some requirements of course you need you

00:07:53,460 --> 00:07:57,810
need to be able to update all the

00:07:54,629 --> 00:07:58,139
components that you have so you need to

00:07:57,810 --> 00:08:00,240
update

00:07:58,139 --> 00:08:03,089
be able to update a Linux kernel because

00:08:00,240 --> 00:08:06,870
the kernel also has one abilities over

00:08:03,089 --> 00:08:09,060
time that are exposed we need two new

00:08:06,870 --> 00:08:12,960
features enabled in the Linux kernel the

00:08:09,060 --> 00:08:16,289
sabre-2 device tree so you need to be

00:08:12,960 --> 00:08:18,300
able to update each and normally you

00:08:16,289 --> 00:08:20,279
don't update the bootloader because

00:08:18,300 --> 00:08:22,560
that's a single point of failure and you

00:08:20,279 --> 00:08:26,879
don't really there is no way to build in

00:08:22,560 --> 00:08:28,850
redundancy in that so if that fails your

00:08:26,879 --> 00:08:32,930
device becomes a brick

00:08:28,850 --> 00:08:35,539
and that's the second most like a

00:08:32,930 --> 00:08:38,240
software update it shall not be able to

00:08:35,539 --> 00:08:40,010
break the device ever no matter what

00:08:38,240 --> 00:08:42,680
happens if there's a power loss or if

00:08:40,010 --> 00:08:45,290
there's well whatever you do to the

00:08:42,680 --> 00:08:46,700
device like during a software update

00:08:45,290 --> 00:08:51,890
it should never render the device

00:08:46,700 --> 00:08:52,850
useless because so that needs to be

00:08:51,890 --> 00:08:56,630
taken care of

00:08:52,850 --> 00:08:59,150
of course atomic updates and that means

00:08:56,630 --> 00:09:02,360
when you do a software update

00:08:59,150 --> 00:09:06,790
it can't be 50% successful so it has to

00:09:02,360 --> 00:09:06,790
either be fully installed or nothing

00:09:07,180 --> 00:09:11,900
because even if you if you have an

00:09:09,470 --> 00:09:14,540
update system that isn't atomic you can

00:09:11,900 --> 00:09:17,270
update 50% of the system and it's still

00:09:14,540 --> 00:09:19,220
bootable but then to introduce weirdness

00:09:17,270 --> 00:09:24,670
because you don't really know what's

00:09:19,220 --> 00:09:27,560
updated was it has to be atomic rollback

00:09:24,670 --> 00:09:31,340
that's a likely if but if your middle

00:09:27,560 --> 00:09:34,490
earlier update and you remove the power

00:09:31,340 --> 00:09:37,190
it should revert back to the working

00:09:34,490 --> 00:09:39,170
software before that's not always

00:09:37,190 --> 00:09:41,450
possible so we're gonna get into that a

00:09:39,170 --> 00:09:43,730
bit more later and you need something

00:09:41,450 --> 00:09:45,080
basically it's basic integrity checks

00:09:43,730 --> 00:09:47,660
might check some Sanyal

00:09:45,080 --> 00:09:49,840
update images so they are not corrupted

00:09:47,660 --> 00:09:53,120
when you are transfer them to the device

00:09:49,840 --> 00:09:55,850
you need some kind of sign signing

00:09:53,120 --> 00:09:57,730
mechanism of your update images to

00:09:55,850 --> 00:10:00,080
disallow like third parties to like

00:09:57,730 --> 00:10:02,180
computer USB flash drive with some

00:10:00,080 --> 00:10:02,390
random image and just run it on your

00:10:02,180 --> 00:10:05,060
device

00:10:02,390 --> 00:10:07,790
so usually you sign these kind of images

00:10:05,060 --> 00:10:08,750
so it's so they are from a trusted

00:10:07,790 --> 00:10:10,940
source

00:10:08,750 --> 00:10:14,630
you only want that if it's signed

00:10:10,940 --> 00:10:16,640
something and there's needs to be some

00:10:14,630 --> 00:10:20,950
kind of compability check in your update

00:10:16,640 --> 00:10:20,950
system so if you have multiple devices

00:10:21,640 --> 00:10:27,070
the update image should contain like

00:10:24,290 --> 00:10:30,470
this image is for this device should not

00:10:27,070 --> 00:10:32,090
sure you're not able to like cross

00:10:30,470 --> 00:10:36,040
install two images to two different

00:10:32,090 --> 00:10:36,040
devices and like

00:10:37,150 --> 00:10:44,480
yeah so some basic requirements for a

00:10:41,990 --> 00:10:46,130
pentacle over-the-air as well so you

00:10:44,480 --> 00:10:48,800
need to have a secure communication

00:10:46,130 --> 00:10:50,390
channel because you know over-the-air

00:10:48,800 --> 00:10:52,190
means you have a client running on the

00:10:50,390 --> 00:10:57,080
device and you have a server in the

00:10:52,190 --> 00:10:59,060
cloud which deploys the updates so you

00:10:57,080 --> 00:11:02,570
need to have a secure channel to

00:10:59,060 --> 00:11:05,030
communicate so no-one can eavesdrop and

00:11:02,570 --> 00:11:07,730
you also need to have trust in your

00:11:05,030 --> 00:11:11,090
system so device devices authentication

00:11:07,730 --> 00:11:15,140
is important so that the device trusts

00:11:11,090 --> 00:11:17,060
the server and the other way around it's

00:11:15,140 --> 00:11:19,190
it's a one-liner here but it's quite

00:11:17,060 --> 00:11:21,560
complex if you if I could have a talk

00:11:19,190 --> 00:11:25,420
just about it if I certification

00:11:21,560 --> 00:11:28,640
pinkett-smith it's quite complicated so

00:11:25,420 --> 00:11:32,320
some common approaches that exist in the

00:11:28,640 --> 00:11:34,790
middle pair linux world so normally

00:11:32,320 --> 00:11:36,790
historically image based or block based

00:11:34,790 --> 00:11:41,210
updates have been the most common

00:11:36,790 --> 00:11:43,010
strategy to use in a better linux and

00:11:41,210 --> 00:11:44,600
mostly because it's easy to implement

00:11:43,010 --> 00:11:47,330
it's easy to test it is easy to verify

00:11:44,600 --> 00:11:50,630
maintain and the simplicity is really

00:11:47,330 --> 00:11:53,810
key and I'm doing this but I'll cover

00:11:50,630 --> 00:11:55,340
this a bit more in detail then there is

00:11:53,810 --> 00:11:58,030
another another approach where we have

00:11:55,340 --> 00:12:01,700
still image based updates but atomically

00:11:58,030 --> 00:12:05,890
incremental so that's also commonly

00:12:01,700 --> 00:12:08,180
referred to as dealt updates you only

00:12:05,890 --> 00:12:10,880
yeah we'll get into that a bit more

00:12:08,180 --> 00:12:13,690
later and there's some there's some

00:12:10,880 --> 00:12:16,550
projects that you to software updates

00:12:13,690 --> 00:12:18,380
through container technology but that

00:12:16,550 --> 00:12:20,570
means that you need to run containers on

00:12:18,380 --> 00:12:23,180
your better than Linux device and then

00:12:20,570 --> 00:12:25,310
you automatically inherit some of the

00:12:23,180 --> 00:12:27,410
functionality of containers and updates

00:12:25,310 --> 00:12:33,110
and stuff but there's a project that I

00:12:27,410 --> 00:12:35,690
will cover that does this native there's

00:12:33,110 --> 00:12:38,690
the standard desktop package managers

00:12:35,690 --> 00:12:40,630
which that's question often write arises

00:12:38,690 --> 00:12:43,790
like why can't we use package managers

00:12:40,630 --> 00:12:46,610
and the biggest problem is primarily not

00:12:43,790 --> 00:12:50,059
designed for embedded use case and the

00:12:46,610 --> 00:12:51,559
embedded environment so they're in there

00:12:50,059 --> 00:12:54,949
are situations where they are they can

00:12:51,559 --> 00:12:59,329
work but still the biggest problem is

00:12:54,949 --> 00:13:02,839
it's not atomic so normally when you do

00:12:59,329 --> 00:13:07,069
enough to get update you get a hierarchy

00:13:02,839 --> 00:13:09,559
of like updates and if you get a power

00:13:07,069 --> 00:13:13,009
loss in one of these steps you will have

00:13:09,559 --> 00:13:15,439
a larger partially updated the system so

00:13:13,009 --> 00:13:21,199
it's not it's not atomic and that's what

00:13:15,439 --> 00:13:23,269
most people avoid it devices and there's

00:13:21,199 --> 00:13:28,009
some complex complexity to handle

00:13:23,269 --> 00:13:33,470
packages as well in testing and to

00:13:28,009 --> 00:13:36,949
manage a package feed so image based

00:13:33,470 --> 00:13:41,720
updates so what's an image so this is an

00:13:36,949 --> 00:13:43,429
image so what you do basically you

00:13:41,720 --> 00:13:45,470
bundle everything that you have when

00:13:43,429 --> 00:13:46,999
you're abandoning this device beside the

00:13:45,470 --> 00:13:51,230
bootloader because you don't really

00:13:46,999 --> 00:13:53,989
update it so we have our root filesystem

00:13:51,230 --> 00:13:56,449
and we make sure that our Linux kernel

00:13:53,989 --> 00:13:57,110
and the device tree is inside the root

00:13:56,449 --> 00:14:00,499
filesystem

00:13:57,110 --> 00:14:01,970
normally on the /boot and then you have

00:14:00,499 --> 00:14:04,369
your distribution components then you

00:14:01,970 --> 00:14:08,419
have application or if you and you have

00:14:04,369 --> 00:14:10,129
an update client and you have a micro

00:14:08,419 --> 00:14:13,279
controller firmware maybe if you have

00:14:10,129 --> 00:14:16,249
external media update and this is the

00:14:13,279 --> 00:14:19,759
image so when you create an update image

00:14:16,249 --> 00:14:22,579
it contains everything always so if you

00:14:19,759 --> 00:14:25,759
are updating just the apps you still

00:14:22,579 --> 00:14:29,929
write the whole thing you always have a

00:14:25,759 --> 00:14:34,759
single working image that you fashion

00:14:29,929 --> 00:14:37,009
advice this is the most yet last five 15

00:14:34,759 --> 00:14:37,939
20 years this is what's been used

00:14:37,009 --> 00:14:43,249
basically

00:14:37,939 --> 00:14:44,899
devices so there are two kind of

00:14:43,249 --> 00:14:47,749
strategies that that are normally

00:14:44,899 --> 00:14:51,069
deployed when using image based updates

00:14:47,749 --> 00:14:53,739
or like how you structure your system

00:14:51,069 --> 00:14:56,239
normally have a bootloader

00:14:53,739 --> 00:14:59,449
and you have some kind of recovery

00:14:56,239 --> 00:15:02,289
operating system and this is normally in

00:14:59,449 --> 00:15:06,589
the toward a system or image from disk

00:15:02,289 --> 00:15:08,720
and then you have your main West well

00:15:06,589 --> 00:15:10,279
your the Linux kernel around all the

00:15:08,720 --> 00:15:14,539
components that I've in my previous

00:15:10,279 --> 00:15:16,549
slide where they are this is how Android

00:15:14,539 --> 00:15:20,539
has been doing like the operating system

00:15:16,549 --> 00:15:22,220
updates forever so if you think I

00:15:20,539 --> 00:15:24,289
enjoyed you get a notification there's

00:15:22,220 --> 00:15:28,399
an update you want to reboot or install

00:15:24,289 --> 00:15:29,869
you press yes and it reboots so that's

00:15:28,399 --> 00:15:33,019
what happens it goes to the recovery of

00:15:29,869 --> 00:15:38,449
us and then you have like wait for 20

00:15:33,019 --> 00:15:41,449
minutes for it to install and this is

00:15:38,449 --> 00:15:43,819
really it has built-in safety so even if

00:15:41,449 --> 00:15:45,409
that update fails you always have the

00:15:43,819 --> 00:15:48,169
possibility to go back to the recovery

00:15:45,409 --> 00:15:50,179
us and try again because normally you

00:15:48,169 --> 00:15:54,379
store the update image in a persistent

00:15:50,179 --> 00:15:58,099
share area between the recovery within

00:15:54,379 --> 00:16:00,229
the main was the biggest downside with

00:15:58,099 --> 00:16:02,029
this approach is downtime because while

00:16:00,229 --> 00:16:05,149
you are flashing your updates the

00:16:02,029 --> 00:16:07,269
devices is unmusical and historically

00:16:05,149 --> 00:16:10,129
like am do it as it takes forever

00:16:07,269 --> 00:16:12,579
updated so what it's updating you can't

00:16:10,129 --> 00:16:12,579
do anything

00:16:13,480 --> 00:16:18,730
and this next approach to image based

00:16:15,970 --> 00:16:21,459
updates is remove the recovery less and

00:16:18,730 --> 00:16:23,109
I still have two operating system

00:16:21,459 --> 00:16:26,730
components that are identical to each

00:16:23,109 --> 00:16:28,839
other and you always have an active

00:16:26,730 --> 00:16:32,799
operating system and you have an

00:16:28,839 --> 00:16:36,040
inactive your operating system and this

00:16:32,799 --> 00:16:40,839
is what Android is moving towards on new

00:16:36,040 --> 00:16:44,529
devices deployed with the latest Android

00:16:40,839 --> 00:16:47,319
version so they have also moved to this

00:16:44,529 --> 00:16:49,660
strategy an Android markets this is as

00:16:47,319 --> 00:16:51,699
seamless updates because one of the

00:16:49,660 --> 00:16:55,059
benefits of this is that you can update

00:16:51,699 --> 00:16:58,629
the secondary operating system while it

00:16:55,059 --> 00:17:01,749
was is running so you don't really have

00:16:58,629 --> 00:17:05,049
a downtime besides you need to reboot to

00:17:01,749 --> 00:17:09,519
switch so once you have updated main of

00:17:05,049 --> 00:17:12,429
SB you reboot and tell you boot tell the

00:17:09,519 --> 00:17:14,709
bootloader now I want to change us to

00:17:12,429 --> 00:17:16,929
the secondary one and the other one

00:17:14,709 --> 00:17:19,480
becomes inactive and we keep doing that

00:17:16,929 --> 00:17:21,429
switching every time you update and this

00:17:19,480 --> 00:17:23,199
is also how by built-in safety and

00:17:21,429 --> 00:17:25,689
built-in rollback so if the failure

00:17:23,199 --> 00:17:28,449
update doesn't the updated image doesn't

00:17:25,689 --> 00:17:32,769
boot it cannot easily fall back to the

00:17:28,449 --> 00:17:34,419
previous working one but the biggest the

00:17:32,769 --> 00:17:35,950
biggest downside of course with this is

00:17:34,419 --> 00:17:41,470
that you need to have two copies of the

00:17:35,950 --> 00:17:43,899
operating system which is not a big

00:17:41,470 --> 00:17:47,440
problem nowadays because flash storage

00:17:43,899 --> 00:17:49,510
is cheaper so at least the devices that

00:17:47,440 --> 00:17:54,130
I work with usually have gigabytes like

00:17:49,510 --> 00:17:56,380
storage so it's not really a problem

00:17:54,130 --> 00:18:01,269
nowadays but it was before when flash

00:17:56,380 --> 00:18:04,330
like storage was expensive so the open

00:18:01,269 --> 00:18:06,340
source ecosystem around software updates

00:18:04,330 --> 00:18:08,740
it has gotten quite big over the past

00:18:06,340 --> 00:18:10,720
five six years so there's so many

00:18:08,740 --> 00:18:14,559
project that can hardly fit them in one

00:18:10,720 --> 00:18:16,690
slide that that solve a lot of the

00:18:14,559 --> 00:18:17,080
complex complexity of this so you don't

00:18:16,690 --> 00:18:19,630
have to

00:18:17,080 --> 00:18:22,650
reinvent the wheel every time you do a

00:18:19,630 --> 00:18:27,430
new product because there are existing

00:18:22,650 --> 00:18:30,700
projects so I've split up the projects

00:18:27,430 --> 00:18:33,370
into two main areas because they have a

00:18:30,700 --> 00:18:36,180
lot of different focus so there are the

00:18:33,370 --> 00:18:40,300
project at all so-called frameworks

00:18:36,180 --> 00:18:42,280
which is they actually enable their that

00:18:40,300 --> 00:18:45,310
there are a set of tools that enable you

00:18:42,280 --> 00:18:48,010
to design your update system so they are

00:18:45,310 --> 00:18:49,990
not like they're not aiming to be an

00:18:48,010 --> 00:18:51,850
out-of-the-box solution so these

00:18:49,990 --> 00:18:53,830
projects are like just giving you the

00:18:51,850 --> 00:18:55,930
tools doing that some of the low level

00:18:53,830 --> 00:18:59,440
stuff to design an update system so to

00:18:55,930 --> 00:19:02,980
say so the first project and the oldest

00:18:59,440 --> 00:19:08,950
one that's been around since 2012 well

00:19:02,980 --> 00:19:13,270
is software update generically so it

00:19:08,950 --> 00:19:17,110
came out of date the German contractor

00:19:13,270 --> 00:19:19,420
company which is also belong to boot and

00:19:17,110 --> 00:19:23,170
Stefan Babbage who works there is the

00:19:19,420 --> 00:19:26,920
creator maintainer this so basically

00:19:23,170 --> 00:19:28,840
what it is it's a update agent that's

00:19:26,920 --> 00:19:33,370
written in C so and it's licensed under

00:19:28,840 --> 00:19:35,830
GPL v2 and it also integrates like

00:19:33,370 --> 00:19:40,450
tooling to create an update image that

00:19:35,830 --> 00:19:42,520
you want this project focuses on the

00:19:40,450 --> 00:19:46,570
symmetric and asymmetric image based

00:19:42,520 --> 00:19:48,940
updates only and in some cases it can

00:19:46,570 --> 00:19:52,960
actually do like single file updates or

00:19:48,940 --> 00:19:55,270
you can really live like flexibility is

00:19:52,960 --> 00:19:57,550
one of the aims of this project so

00:19:55,270 --> 00:20:01,480
because it is a frame framework more

00:19:57,550 --> 00:20:03,280
than a out-of-the-box solution and one

00:20:01,480 --> 00:20:06,760
of the cool features of this is it has

00:20:03,280 --> 00:20:09,730
an integrated web server in the update

00:20:06,760 --> 00:20:11,890
agent so if you deploy this on the

00:20:09,730 --> 00:20:14,710
device you have a web server

00:20:11,890 --> 00:20:17,470
already there to upload new updates so

00:20:14,710 --> 00:20:19,480
they say so just like through the web

00:20:17,470 --> 00:20:21,750
browser so you can upload images which

00:20:19,480 --> 00:20:25,420
removes the need for the flash drive

00:20:21,750 --> 00:20:28,140
which is a nice nice feature and most of

00:20:25,420 --> 00:20:31,300
them of course its supports like you've

00:20:28,140 --> 00:20:36,730
54 cryptographic signing and

00:20:31,300 --> 00:20:39,280
verification about this and it works on

00:20:36,730 --> 00:20:41,440
all the file systems it has a unit

00:20:39,280 --> 00:20:44,230
socket interface to get to read out some

00:20:41,440 --> 00:20:46,680
status information so like progress bar

00:20:44,230 --> 00:20:50,620
of an update you can read that through a

00:20:46,680 --> 00:20:53,080
UNIX API and all these projects need to

00:20:50,620 --> 00:20:54,580
integrate with boot loaders so and

00:20:53,080 --> 00:20:56,910
software updates integrates well with

00:20:54,580 --> 00:20:59,800
you go to grow up

00:20:56,910 --> 00:21:01,750
and for integration most of these

00:20:59,800 --> 00:21:04,030
projects and even software update

00:21:01,750 --> 00:21:08,650
focused on doctor so there's chapter

00:21:04,030 --> 00:21:13,740
layers to get started quickly so say

00:21:08,650 --> 00:21:16,060
it's also build root support it's also a

00:21:13,740 --> 00:21:17,580
extensible with over-the-air updates

00:21:16,060 --> 00:21:20,590
because it doesn't have a built-in

00:21:17,580 --> 00:21:23,020
over-the-air update technology so it's

00:21:20,590 --> 00:21:25,240
just on the device but it's extensible

00:21:23,020 --> 00:21:27,790
to talk with something that's called the

00:21:25,240 --> 00:21:30,310
hoc bit I will cover that later but it's

00:21:27,790 --> 00:21:34,930
what we desire open source server

00:21:30,310 --> 00:21:36,550
component for over-the-air updates so

00:21:34,930 --> 00:21:37,870
the community is pretty big around

00:21:36,550 --> 00:21:41,380
software update because it's been around

00:21:37,870 --> 00:21:44,350
for quite a while and they've done so

00:21:41,380 --> 00:21:46,690
far 18 releases and they do like a four

00:21:44,350 --> 00:21:49,350
month cycle release so every four months

00:21:46,690 --> 00:21:52,180
they do when you release as a lot of

00:21:49,350 --> 00:21:55,900
contributors very active mailing list

00:21:52,180 --> 00:21:58,030
and they take all contributions to to

00:21:55,900 --> 00:21:59,800
the mailing list so total requests on

00:21:58,030 --> 00:22:03,730
github is not accepted

00:21:59,800 --> 00:22:05,920
they take patches don't wait there's

00:22:03,730 --> 00:22:07,450
also reference boards to get to started

00:22:05,920 --> 00:22:12,250
quickly like Raspberry Pi bigger on

00:22:07,450 --> 00:22:15,910
black so it's really easy to try out and

00:22:12,250 --> 00:22:18,040
the next project very similar but from

00:22:15,910 --> 00:22:18,440
Peng atronics from Germany so there's

00:22:18,040 --> 00:22:21,820
like

00:22:18,440 --> 00:22:26,000
some competition going on here but it's

00:22:21,820 --> 00:22:28,759
also see client update agent and there's

00:22:26,000 --> 00:22:32,450
also hopes tooling to create update or

00:22:28,759 --> 00:22:34,190
effects focuses also initially focused

00:22:32,450 --> 00:22:37,429
on a symmetric and asymmetric image

00:22:34,190 --> 00:22:41,179
based updates only and one of the main

00:22:37,429 --> 00:22:43,429
goals with rock is to integrate well

00:22:41,179 --> 00:22:47,210
with applications so they expose a

00:22:43,429 --> 00:22:49,580
deep-ass API for example so you can

00:22:47,210 --> 00:22:52,610
control the update process from an

00:22:49,580 --> 00:22:55,580
application via d-bus and retrieve

00:22:52,610 --> 00:22:58,480
update status as well there's an

00:22:55,580 --> 00:23:03,080
experimental features to do

00:22:58,480 --> 00:23:07,850
Delp updates as well with toc but it's

00:23:03,080 --> 00:23:09,919
still marked as experimental and as I

00:23:07,850 --> 00:23:12,350
said the bus interface it works with all

00:23:09,919 --> 00:23:15,230
this common storage mediums found in

00:23:12,350 --> 00:23:18,559
very Linux devices it works well with

00:23:15,230 --> 00:23:20,720
the most common boot loaders that exist

00:23:18,559 --> 00:23:25,700
also has a doctor layer for integration

00:23:20,720 --> 00:23:27,950
and also connects to is able to cook to

00:23:25,700 --> 00:23:30,320
connect to hock bit for over-the-air

00:23:27,950 --> 00:23:36,980
updates but they provide a fight on

00:23:30,320 --> 00:23:38,509
library for that and something that they

00:23:36,980 --> 00:23:39,679
have done really well is they have a

00:23:38,509 --> 00:23:42,080
solid testing future if the

00:23:39,679 --> 00:23:43,700
infrastructure on their active agent so

00:23:42,080 --> 00:23:47,029
there's a lot of unit tests will be

00:23:43,700 --> 00:23:48,290
around 70% code coverage which is always

00:23:47,029 --> 00:23:51,470
nice

00:23:48,290 --> 00:23:53,330
little testy but it's fairly it's not

00:23:51,470 --> 00:23:55,520
been around it as much as a software

00:23:53,330 --> 00:23:58,280
update so they're wrong without six

00:23:55,520 --> 00:24:01,070
releases and it's still about one point

00:23:58,280 --> 00:24:04,040
zero so that it's also something it's

00:24:01,070 --> 00:24:05,630
not really but they do take

00:24:04,040 --> 00:24:12,350
contributions I think they're like issue

00:24:05,630 --> 00:24:15,860
have they but I don't really farm find

00:24:12,350 --> 00:24:18,380
any reference boards to us I'd never do

00:24:15,860 --> 00:24:21,080
try this one because I can't find any

00:24:18,380 --> 00:24:25,610
reference implementations of integration

00:24:21,080 --> 00:24:28,910
the integration work so quickly just hoc

00:24:25,610 --> 00:24:31,180
bit I'm not that this is a Eclipse

00:24:28,910 --> 00:24:33,980
Foundation project so it's a standalone

00:24:31,180 --> 00:24:42,170
server component to manage like

00:24:33,980 --> 00:24:44,080
over-the-air updates for IOT and this is

00:24:42,170 --> 00:24:46,730
what I like the software updated route

00:24:44,080 --> 00:24:49,040
integrate with so like there's

00:24:46,730 --> 00:24:53,450
standalone components but is exposing my

00:24:49,040 --> 00:24:56,540
API that they can utilize which fairly

00:24:53,450 --> 00:24:58,940
it's based on Java and Java spring boots

00:24:56,540 --> 00:25:01,340
so these are technologies that I'm not

00:24:58,940 --> 00:25:05,590
very familiar with so it's I've never

00:25:01,340 --> 00:25:05,590
really tried to set this up myself so

00:25:13,600 --> 00:25:18,110
the next project we are still on the

00:25:16,520 --> 00:25:21,580
framework project that are not like

00:25:18,110 --> 00:25:25,550
other end to end solutions so Lee poetry

00:25:21,580 --> 00:25:29,480
often describe like get for operating

00:25:25,550 --> 00:25:32,120
system binaries and the reason behind

00:25:29,480 --> 00:25:34,010
the description it's it's the tooling

00:25:32,120 --> 00:25:37,670
around the divorce tree is very get like

00:25:34,010 --> 00:25:42,980
she will get pause and get worse triples

00:25:37,670 --> 00:25:45,590
but the way it does Delta updates is

00:25:42,980 --> 00:25:49,190
also very it has a lot like a repository

00:25:45,590 --> 00:25:51,470
and an object store and it's very trying

00:25:49,190 --> 00:25:53,310
to make it but for like operating

00:25:51,470 --> 00:25:57,360
systems

00:25:53,310 --> 00:26:00,720
you'd see LGPL and the main feature for

00:25:57,360 --> 00:26:06,330
the voice free does only binary Delta's

00:26:00,720 --> 00:26:11,700
on image images so say but this comes

00:26:06,330 --> 00:26:14,400
with some complexity so it's complex it

00:26:11,700 --> 00:26:16,680
has to be so just quickly what is what

00:26:14,400 --> 00:26:19,800
what the structure is to like just to

00:26:16,680 --> 00:26:22,320
get any insight in what it is so

00:26:19,800 --> 00:26:24,240
normally what we have is like /os trivia

00:26:22,320 --> 00:26:27,300
book you have a repository of the file

00:26:24,240 --> 00:26:31,100
system on your device and you also have

00:26:27,300 --> 00:26:33,600
that repository somewhere on the server

00:26:31,100 --> 00:26:35,280
then you have some kind of structure

00:26:33,600 --> 00:26:39,420
where you have deployed and they have

00:26:35,280 --> 00:26:42,900
different deployments and what they

00:26:39,420 --> 00:26:45,000
actually do is like slash user is the

00:26:42,900 --> 00:26:47,520
only directory that which three manages

00:26:45,000 --> 00:26:50,460
so everything has to be especially so if

00:26:47,520 --> 00:26:52,980
you want people to update it but slash

00:26:50,460 --> 00:26:59,220
user is only hard links to the Westry

00:26:52,980 --> 00:27:02,490
repository so kinda deviates a bit from

00:26:59,220 --> 00:27:03,900
the like standard Linux structure that

00:27:02,490 --> 00:27:07,920
you're familiar with so you have to

00:27:03,900 --> 00:27:10,800
adopt adopt your system to this and you

00:27:07,920 --> 00:27:16,650
normally you need to boot to them in its

00:27:10,800 --> 00:27:18,510
ROM FS to change routes to deploy it and

00:27:16,650 --> 00:27:20,520
then also slash bar is like where you

00:27:18,510 --> 00:27:22,230
store the persistent state so if you

00:27:20,520 --> 00:27:24,990
want to keep things between updates

00:27:22,230 --> 00:27:30,000
that's when you store it because yeah

00:27:24,990 --> 00:27:34,950
the boys tree doesn't do anything it has

00:27:30,000 --> 00:27:38,760
some problems according to me it came

00:27:34,950 --> 00:27:41,250
it's it's targeted for PC running Linux

00:27:38,760 --> 00:27:46,250
and it came out of a project called the

00:27:41,250 --> 00:27:49,920
norm continuous so it didn't really like

00:27:46,250 --> 00:27:53,310
the embedded use case wasn't there from

00:27:49,920 --> 00:27:56,070
the beginning but people have adopted it

00:27:53,310 --> 00:27:58,279
for a better because Dell top dates is

00:27:56,070 --> 00:28:02,200
really good if you have like a limit

00:27:58,279 --> 00:28:04,779
when we to mobile network for example

00:28:02,200 --> 00:28:09,349
but there's also your cointegration

00:28:04,779 --> 00:28:11,450
there's a meta updated layer and

00:28:09,349 --> 00:28:14,320
reference news you can try it out quite

00:28:11,450 --> 00:28:14,320
quickly on a Raspberry Pi

00:28:15,399 --> 00:28:20,509
so these are some of the projects that

00:28:18,139 --> 00:28:24,019
I've got adopted live live austrie so

00:28:20,509 --> 00:28:27,340
it's mostly like no continuous is where

00:28:24,019 --> 00:28:30,889
it started and your flat back which is a

00:28:27,340 --> 00:28:32,539
package manager desktop and we have

00:28:30,889 --> 00:28:42,559
something called Project atomic which is

00:28:32,539 --> 00:28:45,769
also a desktop server project QT OTA is

00:28:42,559 --> 00:28:49,249
based on the boys tree as well and then

00:28:45,769 --> 00:28:51,710
you have a component called actualize er

00:28:49,249 --> 00:28:54,710
which is part of Geneva Geneva

00:28:51,710 --> 00:28:58,659
SOTA I will cover that project a bit

00:28:54,710 --> 00:28:58,659
more later on

00:28:58,749 --> 00:29:04,969
just quickly there's another project

00:29:00,979 --> 00:29:10,039
called software update but it's a

00:29:04,969 --> 00:29:12,229
generic name again very similar to the

00:29:10,039 --> 00:29:16,849
boys tree they also focus only on Delta

00:29:12,229 --> 00:29:19,039
based updates it comes out of an

00:29:16,849 --> 00:29:24,529
internal Linux distribution called clear

00:29:19,039 --> 00:29:26,839
Linux where they use this project but

00:29:24,529 --> 00:29:28,700
also it seems that that's the only place

00:29:26,839 --> 00:29:32,450
where it's used so I haven't seen any

00:29:28,700 --> 00:29:37,789
like any big community or that a lot of

00:29:32,450 --> 00:29:41,889
people opting it but there's also doctor

00:29:37,789 --> 00:29:41,889
layer which is actually inactive

00:29:42,580 --> 00:29:50,110
hasn't admitting updates in a while but

00:29:44,980 --> 00:29:51,940
I just want to mention it so now we're

00:29:50,110 --> 00:29:54,519
gonna move to that end to end solutions

00:29:51,940 --> 00:29:57,700
so these are projects that focus on the

00:29:54,519 --> 00:30:00,580
whole chain like Cespedes especially for

00:29:57,700 --> 00:30:04,600
over there updates so the first project

00:30:00,580 --> 00:30:06,789
is a vendor which is an m2 m2 open

00:30:04,600 --> 00:30:10,899
source solution for software updates of

00:30:06,789 --> 00:30:13,269
embedded Linux devices and the key thing

00:30:10,899 --> 00:30:16,750
here is that they have a client that

00:30:13,269 --> 00:30:18,580
runs on the device and the server

00:30:16,750 --> 00:30:21,519
components where you can manage your

00:30:18,580 --> 00:30:31,539
deployments is open source as well so

00:30:21,519 --> 00:30:34,750
you have the whole chain so to say some

00:30:31,539 --> 00:30:36,610
insights in how mentor works so when

00:30:34,750 --> 00:30:40,419
they deploy is a symmetric a be update

00:30:36,610 --> 00:30:46,149
strategy so that means that you have two

00:30:40,419 --> 00:30:49,210
copies of your main operating system but

00:30:46,149 --> 00:30:50,440
as I said today the whole chain is open

00:30:49,210 --> 00:30:53,350
source you have a management server

00:30:50,440 --> 00:30:55,870
where you connect your devices and where

00:30:53,350 --> 00:30:58,630
you can manage deployments and send the

00:30:55,870 --> 00:31:01,600
bound services and some of the key

00:30:58,630 --> 00:31:03,760
things is the updates are streamed from

00:31:01,600 --> 00:31:07,000
the server to the device so they are

00:31:03,760 --> 00:31:08,620
never intermediately stored that's one

00:31:07,000 --> 00:31:11,649
of the benefits you have with two

00:31:08,620 --> 00:31:14,230
operating system we just read update

00:31:11,649 --> 00:31:18,279
today in active part just have to store

00:31:14,230 --> 00:31:20,679
it locally and they of course also

00:31:18,279 --> 00:31:23,799
support signing what they update images

00:31:20,679 --> 00:31:27,010
like that that's all quite basic things

00:31:23,799 --> 00:31:29,529
that they need to be supported so you

00:31:27,010 --> 00:31:31,269
have to integration again most of these

00:31:29,529 --> 00:31:33,880
projects focused on like integrating

00:31:31,269 --> 00:31:37,120
well with yocto there's a meta meta

00:31:33,880 --> 00:31:40,299
layer they also focus a lot on test

00:31:37,120 --> 00:31:44,649
coverage so they have quite a large

00:31:40,299 --> 00:31:46,809
suite of unit tests the client that runs

00:31:44,649 --> 00:31:49,570
from the device but they also have the

00:31:46,809 --> 00:31:53,139
it's open source as well integration

00:31:49,570 --> 00:31:56,110
tests on qumu raspberry pi black will be

00:31:53,139 --> 00:31:58,570
cable black so they do like that full

00:31:56,110 --> 00:32:05,320
testing of the server and do like

00:31:58,570 --> 00:32:08,679
updates on each of the sources which is

00:32:05,320 --> 00:32:12,039
cool and there's a protective community

00:32:08,679 --> 00:32:15,520
and part of it as well as much but they

00:32:12,039 --> 00:32:19,840
use like Jared there's an open open JIRA

00:32:15,520 --> 00:32:21,610
instance where you do they manage when

00:32:19,840 --> 00:32:23,230
you do bug reports and you can also go

00:32:21,610 --> 00:32:26,049
there and see like what they are working

00:32:23,230 --> 00:32:30,190
on currently and join the discussions

00:32:26,049 --> 00:32:32,919
that they've done ten releases if that

00:32:30,190 --> 00:32:35,710
says everything there's a mailing list

00:32:32,919 --> 00:32:38,770
which is quite that active for asking

00:32:35,710 --> 00:32:43,690
questions as a bug that contributions on

00:32:38,770 --> 00:32:45,909
github normal pests but the cool thing

00:32:43,690 --> 00:32:49,090
is also that they have like 30 pass

00:32:45,909 --> 00:32:50,590
stories in their organization so they

00:32:49,090 --> 00:32:53,440
have all the tooling

00:32:50,590 --> 00:32:56,620
like I said integration tests the unit

00:32:53,440 --> 00:32:59,049
tests all of these develop this is open

00:32:56,620 --> 00:33:01,559
source so that's where they are so many

00:32:59,049 --> 00:33:01,559
repositories

00:33:01,960 --> 00:33:10,049
the next project is a resume oh yeah and

00:33:06,639 --> 00:33:10,049
this is yeah

00:33:10,980 --> 00:33:20,860
they utilize containers or container

00:33:14,919 --> 00:33:22,749
technology which means that you need to

00:33:20,860 --> 00:33:23,980
run a container on your device and you

00:33:22,749 --> 00:33:26,649
need to run your application in a

00:33:23,980 --> 00:33:32,769
container and then they can inherit the

00:33:26,649 --> 00:33:34,899
functionality of docker containers or to

00:33:32,769 --> 00:33:37,600
get to Delta updates so if you just

00:33:34,899 --> 00:33:43,119
update the application you can get like

00:33:37,600 --> 00:33:45,009
small updates chunks but the problem one

00:33:43,119 --> 00:33:47,320
of the problems with resin is that the

00:33:45,009 --> 00:33:49,649
management server is still proprietary

00:33:47,320 --> 00:33:52,570
so that it's not open source even if

00:33:49,649 --> 00:33:54,429
they are anything in their blog posts

00:33:52,570 --> 00:33:58,659
that they are climbing and releasing it

00:33:54,429 --> 00:34:00,549
but it's not it has not happened yet but

00:33:58,659 --> 00:34:02,889
they have open stores the resin the

00:34:00,549 --> 00:34:04,740
resin us which is the operating system

00:34:02,889 --> 00:34:06,730
that you're running your device with

00:34:04,740 --> 00:34:08,589
where you have to contain the

00:34:06,730 --> 00:34:12,669
technologies for the same so you can

00:34:08,589 --> 00:34:16,990
build something so just quick code you

00:34:12,669 --> 00:34:21,099
how it works they're actually written on

00:34:16,990 --> 00:34:25,990
their own doctor compatible container

00:34:21,099 --> 00:34:28,510
client which is the initially use docker

00:34:25,990 --> 00:34:31,659
but they realized that it wasn't really

00:34:28,510 --> 00:34:33,520
well-suited for embedded devices so

00:34:31,659 --> 00:34:37,389
that's pretty cool that's open source so

00:34:33,520 --> 00:34:40,899
they have created a container client

00:34:37,389 --> 00:34:46,629
favorite devices specifically and that's

00:34:40,899 --> 00:34:48,879
how we get like the Delta updates but

00:34:46,629 --> 00:34:50,020
this means that your applications needs

00:34:48,879 --> 00:34:54,240
to running

00:34:50,020 --> 00:34:57,390
container physical or multiple occasions

00:34:54,240 --> 00:35:00,820
but they do symmetric a be updates for

00:34:57,390 --> 00:35:03,119
this part still so if you want to update

00:35:00,820 --> 00:35:06,340
the underlying operating system they've

00:35:03,119 --> 00:35:08,950
they do similar to member or do an

00:35:06,340 --> 00:35:11,369
operating system approach so they have

00:35:08,950 --> 00:35:14,619
the possibility to update that as well

00:35:11,369 --> 00:35:17,380
but they only support the MMC SD cards

00:35:14,619 --> 00:35:22,440
so what I've seen they don't support you

00:35:17,380 --> 00:35:29,110
VI or integers and flushes for example

00:35:22,440 --> 00:35:35,740
and 80s garage is a project from

00:35:29,110 --> 00:35:38,320
advanced telematics so this is built on

00:35:35,740 --> 00:35:40,330
top of a liberal Westry so there they

00:35:38,320 --> 00:35:46,270
have a client written a client in C++

00:35:40,330 --> 00:35:49,480
and that is able to communicate with the

00:35:46,270 --> 00:35:55,530
backend but still the users live Westry

00:35:49,480 --> 00:35:58,030
underneath so they have a ETS garage

00:35:55,530 --> 00:36:01,330
where you can login for this observer

00:35:58,030 --> 00:36:03,460
component which is propriety but they

00:36:01,330 --> 00:36:07,890
have out the Community Edition so you

00:36:03,460 --> 00:36:09,930
can deploy the server yourself but still

00:36:07,890 --> 00:36:12,569
[Music]

00:36:09,930 --> 00:36:15,099
haven't seen misstated releases and it's

00:36:12,569 --> 00:36:17,650
it's not really there the Community

00:36:15,099 --> 00:36:25,809
Edition it seems it's not really there

00:36:17,650 --> 00:36:28,450
yet there's so many projects so this is

00:36:25,809 --> 00:36:30,369
writing you want to me I'm like when I

00:36:28,450 --> 00:36:32,490
was doing research for this talk I found

00:36:30,369 --> 00:36:35,589
this one I have never heard of it before

00:36:32,490 --> 00:36:39,039
but it's good more more open source

00:36:35,589 --> 00:36:41,289
projects so it's called update hub I

00:36:39,039 --> 00:36:45,359
don't really know much about it I just

00:36:41,289 --> 00:36:47,619
wanted to mention it because it is there

00:36:45,359 --> 00:36:51,279
seems to be family out at the ferry news

00:36:47,619 --> 00:36:53,789
since December 2070 could be worth

00:36:51,279 --> 00:36:53,789
looking into

00:36:57,990 --> 00:37:04,660
so yeah that's the projects I take and

00:37:01,740 --> 00:37:07,570
to summarize all this there's quite a

00:37:04,660 --> 00:37:09,130
big ecosystem and these projects have

00:37:07,570 --> 00:37:11,620
been around for quite a while now as

00:37:09,130 --> 00:37:16,450
well so the uh proven solutions out

00:37:11,620 --> 00:37:20,760
there that simplify integrating a proper

00:37:16,450 --> 00:37:24,420
robust update solution on the devices so

00:37:20,760 --> 00:37:27,000
no reason to go home wrong start tacking

00:37:24,420 --> 00:37:29,440
because there are o transpose

00:37:27,000 --> 00:37:42,150
well-established open source projects

00:37:29,440 --> 00:37:42,150
that we can collaborate questions yeah

00:37:49,440 --> 00:37:55,600
the most common approach I guess if you

00:37:51,970 --> 00:38:01,360
if you're not able to do to deploy a

00:37:55,600 --> 00:38:06,280
tool a be the next step back is deployed

00:38:01,360 --> 00:38:08,410
recover us yeah you have a smaller

00:38:06,280 --> 00:38:10,630
recovery operating system that you need

00:38:08,410 --> 00:38:14,200
to boot into to be able to fast

00:38:10,630 --> 00:38:17,470
now your state safe but you still have

00:38:14,200 --> 00:38:19,300
to have a intermediate storage because

00:38:17,470 --> 00:38:23,250
if you downloaded updating the main

00:38:19,300 --> 00:38:23,250
operating system it store it somewhere

00:38:24,300 --> 00:38:29,280
yeah yeah I'm smaller maybe because you

00:38:27,660 --> 00:38:32,640
can come to compress to update images

00:38:29,280 --> 00:38:35,210
and stuff like that so that's the next

00:38:32,640 --> 00:38:35,210
step but

00:38:37,980 --> 00:38:44,790
so which component you served yes yes

00:38:40,700 --> 00:39:15,200
well it's mostly a software update on

00:38:44,790 --> 00:39:18,359
the route they have because it's so

00:39:15,200 --> 00:39:25,740
let's say the new you were switching to

00:39:18,359 --> 00:39:28,410
be but it's pains you want to it's

00:39:25,740 --> 00:39:31,980
different for every bootloader but yeah

00:39:28,410 --> 00:39:33,660
Bhutan has to have logic to handle you

00:39:31,980 --> 00:39:37,980
would has this built-in already called

00:39:33,660 --> 00:39:39,510
something boot counters so simply a boot

00:39:37,980 --> 00:39:41,970
counter that you store in new boot

00:39:39,510 --> 00:39:44,309
environment so every time you boot it

00:39:41,970 --> 00:39:46,740
counts up once so you can set the

00:39:44,309 --> 00:39:48,319
threshold if if it has booted ten times

00:39:46,740 --> 00:39:51,150
do something else

00:39:48,319 --> 00:39:53,309
like trying to but what you normally do

00:39:51,150 --> 00:39:56,970
if you are able to boot you clear that

00:39:53,309 --> 00:40:00,720
counter so remote has built-in like a

00:39:56,970 --> 00:40:02,750
feature for this already I'm not quite

00:40:00,720 --> 00:40:02,750
sure

00:40:42,300 --> 00:40:47,890
yeah you know the only features that you

00:40:45,370 --> 00:40:50,200
need in the bootloader is like you just

00:40:47,890 --> 00:40:53,440
mentioned that the boot counter feature

00:40:50,200 --> 00:40:56,080
so that you can set like if this boot

00:40:53,440 --> 00:40:59,830
fails so if if you update me nervous B

00:40:56,080 --> 00:41:02,170
and tries to boot it but like it fails

00:40:59,830 --> 00:41:04,500
and there needs to be some logic to

00:41:02,170 --> 00:41:12,310
revert back that and this is usually

00:41:04,500 --> 00:41:15,460
handled in know if it's able to boot

00:41:12,310 --> 00:41:17,350
your device without this yeah it should

00:41:15,460 --> 00:41:26,850
work it's just that feature that you

00:41:17,350 --> 00:41:29,920
mean something quite similar this but we

00:41:26,850 --> 00:41:31,630
kernel executes that the new kernel so

00:41:29,920 --> 00:41:34,840
you could site loaded in runtime without

00:41:31,630 --> 00:41:36,190
needing and reboot but sometimes it

00:41:34,840 --> 00:41:38,710
could fail but then you could just do a

00:41:36,190 --> 00:41:42,610
full reboot and they became you would

00:41:38,710 --> 00:41:44,630
revert back to the old was it's kind of

00:41:42,610 --> 00:41:47,030
the same but you don't always have

00:41:44,630 --> 00:41:50,200
reboost entire operating system when

00:41:47,030 --> 00:41:53,300
doing since a bit faster doesn't weigh

00:41:50,200 --> 00:41:55,250
monkey sure dude see if you like a new

00:41:53,300 --> 00:41:57,550
kernel executes that uh approach don't

00:41:55,250 --> 00:42:03,850
Colonel do you do a new unit as well

00:41:57,550 --> 00:42:03,850
yeah you know dude KX yeah

00:42:21,760 --> 00:42:27,950
doesn't have to be yeah that's for

00:42:25,250 --> 00:42:30,320
example the bender which does this like

00:42:27,950 --> 00:42:32,720
the whole way it has to be able to

00:42:30,320 --> 00:42:36,230
communicate with the server it has a

00:42:32,720 --> 00:42:41,630
notion of commit so until you commit

00:42:36,230 --> 00:42:44,300
your freshly installed image next time

00:42:41,630 --> 00:42:52,790
it reboots it will go to the old one set

00:42:44,300 --> 00:42:54,650
so you can add well the most critical

00:42:52,790 --> 00:42:56,600
one if you have a server component I

00:42:54,650 --> 00:43:00,500
would say that you're able to talk to

00:42:56,600 --> 00:43:03,140
the server after the update in that case

00:43:00,500 --> 00:43:05,690
you can always update again but if you

00:43:03,140 --> 00:43:08,510
are not able to talk to you server after

00:43:05,690 --> 00:43:11,470
update it makes sense to revert back

00:43:08,510 --> 00:43:11,470
because something

00:43:26,030 --> 00:43:35,200
why not use Delta Delta so good but

00:43:32,180 --> 00:43:38,330
there's no really good solution for it

00:43:35,200 --> 00:43:41,210
so it's just probably gonna be some

00:43:38,330 --> 00:43:45,800
someone's gonna fix this properly

00:43:41,210 --> 00:43:47,710
but the Estrella stuff it's really it's

00:43:45,800 --> 00:43:50,210
really care great but it's not really

00:43:47,710 --> 00:43:52,430
doesn't cover all the corner cases it's

00:43:50,210 --> 00:43:54,020
the problem is it's pretty bald so you

00:43:52,430 --> 00:43:55,910
can bill do around that so you have we

00:43:54,020 --> 00:43:57,530
can build them like if you combine maybe

00:43:55,910 --> 00:44:01,100
a recovery worse

00:43:57,530 --> 00:44:03,620
with the boys tree and like then you can

00:44:01,100 --> 00:44:08,990
probably like close all the gap that

00:44:03,620 --> 00:44:15,200
exists so yeah tilt update is great

00:44:08,990 --> 00:44:17,360
basically but not really solved these

00:44:15,200 --> 00:44:21,010
full image updates its simplicity

00:44:17,360 --> 00:44:24,200
because you already know what you flash

00:44:21,010 --> 00:44:26,780
and that's easy to do if you have ten

00:44:24,200 --> 00:44:29,650
thousand devices we know that they all

00:44:26,780 --> 00:44:32,270
gonna end up with the same software

00:44:29,650 --> 00:44:34,850
because you do like flash everything

00:44:32,270 --> 00:44:37,010
every time and that's easy to verify if

00:44:34,850 --> 00:44:40,130
you if you have a device out in the

00:44:37,010 --> 00:44:42,080
field it has an issue you just take that

00:44:40,130 --> 00:44:44,630
same image flash your device that we

00:44:42,080 --> 00:44:46,520
have locally and hopefully you can like

00:44:44,630 --> 00:44:47,750
and you're pretty sure that you're

00:44:46,520 --> 00:44:50,680
running the same software that you have

00:44:47,750 --> 00:44:50,680
in your in the field

00:45:00,320 --> 00:45:16,320
yeah yeah so Delta image-based up to

00:45:04,830 --> 00:45:16,830
stop us we actually have support to

00:45:16,320 --> 00:45:19,470
rollback

00:45:16,830 --> 00:45:42,320
but that means City it must be able to

00:45:19,470 --> 00:45:42,320
interact yeah so you need to that's what

00:45:53,180 --> 00:45:57,900
that's what I feel is like the next all

00:45:56,580 --> 00:46:00,630
of these projects are doing which be

00:45:57,900 --> 00:46:04,650
that updates they are experimenting with

00:46:00,630 --> 00:46:06,870
chaos seeing all the tools to do just

00:46:04,650 --> 00:46:09,300
download the deltas and apply them even

00:46:06,870 --> 00:46:12,440
if they are and then you really have a

00:46:09,300 --> 00:46:12,440
robust and

00:46:16,810 --> 00:46:20,140
maybe take

00:46:32,170 --> 00:46:51,880
yeah that that's yeah you have to move

00:46:33,820 --> 00:46:53,590
work around yeah you can still do it in

00:46:51,880 --> 00:46:55,780
the most of this system but it's not

00:46:53,590 --> 00:46:57,640
something that's recommended to do

00:46:55,780 --> 00:47:00,340
because that's your single point if

00:46:57,640 --> 00:47:04,750
these that fails you can't recover from

00:47:00,340 --> 00:47:06,490
that so you can still do it there's

00:47:04,750 --> 00:47:10,150
nothing stopping you you know like post

00:47:06,490 --> 00:47:20,740
install script yeah but if yes if you

00:47:10,150 --> 00:47:23,020
want to drinkable system it in no it's

00:47:20,740 --> 00:47:24,880
not which has to be like the boot rom

00:47:23,020 --> 00:47:26,590
has to be able to boot from different

00:47:24,880 --> 00:47:30,640
locations if you want to add like

00:47:26,590 --> 00:47:32,800
redundant boot loaders so the chip can

00:47:30,640 --> 00:47:35,200
you're running must be able to like

00:47:32,800 --> 00:47:38,440
probe for two locations for this to be

00:47:35,200 --> 00:47:40,660
impossible because right now it's like

00:47:38,440 --> 00:47:42,730
yeah it's very fixed where the

00:47:40,660 --> 00:47:46,350
bootloader is a bit and if you try to

00:47:42,730 --> 00:47:49,090
update that and you fail there's no like

00:47:46,350 --> 00:47:53,610
so it's really a problem on the hardware

00:47:49,090 --> 00:47:55,960
to solve to make the update redundant

00:47:53,610 --> 00:47:58,170
maybe there are some chips that will do

00:47:55,960 --> 00:47:58,170
that

00:47:59,150 --> 00:48:08,029
just a comment using a I think it

00:48:04,849 --> 00:48:13,569
started off as a attempt that goes to

00:48:08,029 --> 00:48:13,569
the core processing have ever change

00:48:13,819 --> 00:48:22,749
the self updates by keeping the initial

00:48:17,769 --> 00:48:22,749
or whatever doing this

00:48:28,150 --> 00:48:36,950
I'm not sure how safe it is yep yeah boo

00:48:34,760 --> 00:48:40,569
Toto could probably solve this by like

00:48:36,950 --> 00:48:40,569
being more than a bootloader

00:48:48,079 --> 00:48:57,049
I'm not sure how about that stickers

00:48:54,459 --> 00:49:04,839
very supporting humans as well for

00:48:57,049 --> 00:49:04,839
redundancy by using yeah that's

00:49:12,069 --> 00:49:17,390
yeah so yeah boo problems can solve this

00:49:15,200 --> 00:49:21,200
by being like yeah primary Bunco there's

00:49:17,390 --> 00:49:35,410
a secondary stage and stage like a piece

00:49:21,200 --> 00:49:35,410
of that more questions I like questions

00:49:38,040 --> 00:49:41,780

YouTube URL: https://www.youtube.com/watch?v=JyqHQgvarlc


