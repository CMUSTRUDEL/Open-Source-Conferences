Title: Speculo: shared memory made easy - Alberto Mardegan
Publication date: 2018-04-24
Playlist: foss-north 2018
Description: 
	How you can implement a lockless inter-process communication (IPC) mechanism on top of shared memory and nothing else. The talk will cover the details of how the speculo library handles its shared memory areas and how a stream of messages can be implemented on shared memory. Despite being low-level, the session does not require knowledge of algorithms or a strong background on IPC.
The talk might touch some philosophical considerations about the evolution of software solutions.

---

Alberto is a software engineer with a long development experience on Linux mobile devices. Formerly part of the Nokia Maemo team and Canonical Ubuntu phone efforts, he currently works in the automotive domain at Luxoft. His spare time is subdivided among innumerable hobbies and projects, among which a few programming ones concerning Qt, photography and the Ubports project. 

http://foss-north.se/2018/speakers-and-talks.html#amardegan
Captions: 
	00:00:16,609 --> 00:00:22,920
thanks for being here I will briefly

00:00:21,000 --> 00:00:26,210
introduce myself my name is Herbert

00:00:22,920 --> 00:00:29,789
romantic man I live in Hooksett the

00:00:26,210 --> 00:00:34,250
automotive field since a few months

00:00:29,789 --> 00:00:39,420
before that I was working at canonical

00:00:34,250 --> 00:00:42,270
most of the time on a route to four

00:00:39,420 --> 00:00:44,010
airports and then previously I was

00:00:42,270 --> 00:00:47,489
working at Nokia and of course it'll

00:00:44,010 --> 00:00:51,870
still forms especially with Conte a

00:00:47,489 --> 00:00:55,020
magma lava which is living space and

00:00:51,870 --> 00:01:00,239
today I want to talk you about speculum

00:00:55,020 --> 00:01:03,899
which is spare time project of mine that

00:01:00,239 --> 00:01:09,479
I started a few years ago but it was

00:01:03,899 --> 00:01:13,680
actually caused by some by some needs

00:01:09,479 --> 00:01:16,710
that I found I seek I found at work

00:01:13,680 --> 00:01:20,490
especially during many years of Nokia

00:01:16,710 --> 00:01:24,000
because if this linux-based form we are

00:01:20,490 --> 00:01:25,860
using we're making a lot of use of the

00:01:24,000 --> 00:01:30,180
bus I don't know if you are familiar

00:01:25,860 --> 00:01:34,200
with it it's it's a system for

00:01:30,180 --> 00:01:37,890
inter-process communication and it is a

00:01:34,200 --> 00:01:40,979
bit peculiar because every every message

00:01:37,890 --> 00:01:43,770
that is changed between two processes

00:01:40,979 --> 00:01:47,220
actually passes through a third process

00:01:43,770 --> 00:01:49,649
that is the message broker that then

00:01:47,220 --> 00:01:50,630
deliver deliver his message today he

00:01:49,649 --> 00:01:58,130
threated

00:01:50,630 --> 00:02:01,119
cbons and we found out that this was a

00:01:58,130 --> 00:02:05,060
bit of a bottleneck in our architecture

00:02:01,119 --> 00:02:08,690
we were we were using when I was part of

00:02:05,060 --> 00:02:12,410
the instant messaging and voice calls

00:02:08,690 --> 00:02:15,470
County communication team and we were

00:02:12,410 --> 00:02:19,880
using a framework called telepathy which

00:02:15,470 --> 00:02:24,400
was I was making very heavy use of Debus

00:02:19,880 --> 00:02:27,860
to select a lot of process every every

00:02:24,400 --> 00:02:29,750
messaging provider was running its own

00:02:27,860 --> 00:02:32,030
process that they were the user

00:02:29,750 --> 00:02:34,730
interfaces it was its own process the

00:02:32,030 --> 00:02:38,360
locker was its own process so you can

00:02:34,730 --> 00:02:41,209
imagine that especially during the boot

00:02:38,360 --> 00:02:44,599
or early phases after the boot where the

00:02:41,209 --> 00:02:48,290
focus still doing other things it was

00:02:44,599 --> 00:02:51,200
actually kind of a bottleneck a bit

00:02:48,290 --> 00:02:55,810
because we were using it properly in my

00:02:51,200 --> 00:03:00,049
opinion like too much things on this bus

00:02:55,810 --> 00:03:02,780
but also because of its own nature that

00:03:00,049 --> 00:03:06,709
every message that pass through the

00:03:02,780 --> 00:03:11,389
central broker he spent some time

00:03:06,709 --> 00:03:15,040
thinking about a solution and it was

00:03:11,389 --> 00:03:20,540
2011 he made blog I wrote a post about

00:03:15,040 --> 00:03:26,000
kiba's which which was just an idea how

00:03:20,540 --> 00:03:28,280
I would if I had to start from fresh it

00:03:26,000 --> 00:03:32,299
was like discovering what I would have

00:03:28,280 --> 00:03:34,970
done but of course that was totally

00:03:32,299 --> 00:03:37,280
learning and a few months after writing

00:03:34,970 --> 00:03:41,989
this blog post we had this change of

00:03:37,280 --> 00:03:43,230
strategy that Nokia kind of migrated to

00:03:41,989 --> 00:03:47,220
the micron

00:03:43,230 --> 00:03:54,060
episode platform so I left the company

00:03:47,220 --> 00:03:58,650
and yeah it kind of stay there still

00:03:54,060 --> 00:04:04,530
this idea kept a bit running through my

00:03:58,650 --> 00:04:10,739
mind and I decided to try to spend some

00:04:04,530 --> 00:04:14,120
of my own time to to start this project

00:04:10,739 --> 00:04:17,280
with a much smaller scope and it was

00:04:14,120 --> 00:04:22,949
writing just a library for shared memory

00:04:17,280 --> 00:04:25,229
management I guess most of you know what

00:04:22,949 --> 00:04:30,240
is shared memory basically it is when

00:04:25,229 --> 00:04:32,550
they run what part of run of your PC is

00:04:30,240 --> 00:04:36,120
actually shared between different

00:04:32,550 --> 00:04:40,500
processes typically you have one writer

00:04:36,120 --> 00:04:45,389
and many readers but there are many

00:04:40,500 --> 00:04:49,260
other possible uses for this so what is

00:04:45,389 --> 00:04:51,150
specular well the world internally which

00:04:49,260 --> 00:04:54,710
is a nice language that I invite

00:04:51,150 --> 00:04:58,789
everybody to learn that means be wrong

00:04:54,710 --> 00:05:03,120
and yeah it's just because shared memory

00:04:58,789 --> 00:05:07,050
reminded me of a year it's a very very

00:05:03,120 --> 00:05:09,150
small library about 2,000 lines of

00:05:07,050 --> 00:05:13,410
course and actually most of them are

00:05:09,150 --> 00:05:19,889
comments and it is I would say other

00:05:13,410 --> 00:05:25,010
than a thin wrapper is easy SH and open

00:05:19,889 --> 00:05:29,370
and it is not less that's I think one

00:05:25,010 --> 00:05:32,610
important thing so it is meant to have

00:05:29,370 --> 00:05:34,470
only one writer and many readers and I

00:05:32,610 --> 00:05:37,260
will show you how it is possible to

00:05:34,470 --> 00:05:40,650
achieve this without having any locks at

00:05:37,260 --> 00:05:47,900
all it is zero copy it is

00:05:40,650 --> 00:05:50,880
that the writer could for instance pass

00:05:47,900 --> 00:05:54,930
the progress of the shared memory to a

00:05:50,880 --> 00:05:58,320
system function that brings a file for

00:05:54,930 --> 00:06:00,990
example so the data will be returned

00:05:58,320 --> 00:06:06,270
from the file inside the shared memory

00:06:00,990 --> 00:06:11,240
area without being copied and everything

00:06:06,270 --> 00:06:11,240
is written just using POSIX API

00:06:14,090 --> 00:06:30,210
ok now I would not mention that but it

00:06:17,100 --> 00:06:34,260
is possible really so what are the

00:06:30,210 --> 00:06:40,410
design principles well we know that to

00:06:34,260 --> 00:06:45,120
achieve this lot less goal I had to

00:06:40,410 --> 00:06:47,849
decide to make it that every part every

00:06:45,120 --> 00:06:50,130
part of the shared memory most of it at

00:06:47,849 --> 00:06:52,229
least there are a few cultural bias here

00:06:50,130 --> 00:06:54,900
that can actually changed but most of

00:06:52,229 --> 00:07:01,199
the data that you write to the shared

00:06:54,900 --> 00:07:04,919
memory never changes and yeah of course

00:07:01,199 --> 00:07:07,940
purina's need the little hope in the

00:07:04,919 --> 00:07:12,539
shell and very error only read-only mode

00:07:07,940 --> 00:07:18,000
so there is no reason that we will stop

00:07:12,539 --> 00:07:20,539
with actual data I am so going to show

00:07:18,000 --> 00:07:23,940
you how it works

00:07:20,539 --> 00:07:26,550
there is no useful concept that it must

00:07:23,940 --> 00:07:31,740
be aware of and that is of memory

00:07:26,550 --> 00:07:36,000
carriers memory polymers are a way to

00:07:31,740 --> 00:07:40,289
guarantee that the data that once you

00:07:36,000 --> 00:07:42,720
write a certain flag all the data that

00:07:40,289 --> 00:07:46,380
you have written before right this flag

00:07:42,720 --> 00:07:47,190
is also visible to other processes you

00:07:46,380 --> 00:07:52,080
can think

00:07:47,190 --> 00:07:54,720
has caught meat in the databases or seek

00:07:52,080 --> 00:08:00,000
flash for the file system they just

00:07:54,720 --> 00:08:02,880
applies to rap and this is actually the

00:08:00,000 --> 00:08:05,790
thing that I mentioned before when I was

00:08:02,880 --> 00:08:10,170
talking about pulsing it's a this memory

00:08:05,790 --> 00:08:12,300
barriers they are compiler specific so

00:08:10,170 --> 00:08:14,550
the header file a key to have different

00:08:12,300 --> 00:08:17,730
macros for them and they have

00:08:14,550 --> 00:08:20,310
implemented them only for GCC and Ceylon

00:08:17,730 --> 00:08:23,310
so if someone wants to compile this

00:08:20,310 --> 00:08:24,870
library with the other two - this

00:08:23,310 --> 00:08:27,140
probably something that needs to be

00:08:24,870 --> 00:08:27,140
addressed

00:08:27,830 --> 00:08:34,979
ok and now I'm going to show you how

00:08:32,419 --> 00:08:39,050
actually this works how the data is

00:08:34,979 --> 00:08:42,840
being written today memory in a way that

00:08:39,050 --> 00:08:49,170
every religion gets a consistent view of

00:08:42,840 --> 00:08:52,860
the data and yeah and how it is possible

00:08:49,170 --> 00:08:56,040
to achieve this without logs I'm only

00:08:52,860 --> 00:09:00,000
going to show you the writer side just

00:08:56,040 --> 00:09:03,060
for a space limitation on this slide but

00:09:00,000 --> 00:09:05,550
you should try that every step to

00:09:03,060 --> 00:09:08,760
imagine what would happen if our reader

00:09:05,550 --> 00:09:16,310
would suddenly try to open this memory

00:09:08,760 --> 00:09:21,710
area start reading it okay it's actually

00:09:16,310 --> 00:09:24,240
okay yes so it all starts with a

00:09:21,710 --> 00:09:27,870
function call that is specular area you

00:09:24,240 --> 00:09:28,460
know it takes the name of the unit can

00:09:27,870 --> 00:09:30,860
be any

00:09:28,460 --> 00:09:36,080
paternity string well I think it must be

00:09:30,860 --> 00:09:38,420
abandoned funding that flags just say if

00:09:36,080 --> 00:09:42,860
the area must be existing or if we are

00:09:38,420 --> 00:09:45,890
printing a new one and this doesn't

00:09:42,860 --> 00:09:48,650
allocate anything on the shared memory

00:09:45,890 --> 00:09:52,670
yeah just allocate the structure of the

00:09:48,650 --> 00:09:55,490
hip and it initializes it with with a

00:09:52,670 --> 00:09:58,700
bit of data that is needed to control it

00:09:55,490 --> 00:10:04,310
after that that a writer can call other

00:09:58,700 --> 00:10:07,700
functions to proxy to customize the

00:10:04,310 --> 00:10:10,580
behavior of the library like how big

00:10:07,700 --> 00:10:13,790
this memory error must be there are

00:10:10,580 --> 00:10:17,390
other settings about how to use it later

00:10:13,790 --> 00:10:21,410
how to compact the memory like what is

00:10:17,390 --> 00:10:24,290
the percentage of all the data that is

00:10:21,410 --> 00:10:27,980
acceptable to having the area before it

00:10:24,290 --> 00:10:31,970
gets compacted and other things and

00:10:27,980 --> 00:10:36,470
finally it called spectral create a

00:10:31,970 --> 00:10:43,100
spectral era create and and this one

00:10:36,470 --> 00:10:50,240
actually creates an object a file shared

00:10:43,100 --> 00:10:52,580
memory and just it is set sunlight step

00:10:50,240 --> 00:10:54,230
that says that the state of this manual

00:10:52,580 --> 00:10:57,440
here is initialized

00:10:54,230 --> 00:10:59,960
it's not ready so if a reader started to

00:10:57,440 --> 00:11:05,960
look at this file it will know that I

00:10:59,960 --> 00:11:07,850
don't have to touch it yet still this

00:11:05,960 --> 00:11:13,390
function when it continues to do other

00:11:07,850 --> 00:11:17,000
stuff so it continues to write a few a

00:11:13,390 --> 00:11:19,400
few data that are needed for perspective

00:11:17,000 --> 00:11:24,209
to operate the size of the memory area

00:11:19,400 --> 00:11:29,399
and MV and then they this chocolaty

00:11:24,209 --> 00:11:32,759
you can read it it's it's a counter for

00:11:29,399 --> 00:11:36,949
the idea of the various choc chance

00:11:32,759 --> 00:11:42,059
blocks that will be allocated later and

00:11:36,949 --> 00:11:47,309
the last one is so from after this the

00:11:42,059 --> 00:11:50,689
chocolatey it starts to be the space or

00:11:47,309 --> 00:11:54,119
the memory charge that will be allocated

00:11:50,689 --> 00:11:57,800
so we start with setting a flag that

00:11:54,119 --> 00:12:03,059
says that the first chunk is is a

00:11:57,800 --> 00:12:05,639
negated not located which means that any

00:12:03,059 --> 00:12:11,790
reader will to see that there is nothing

00:12:05,639 --> 00:12:13,800
in the memory area and yeah this the

00:12:11,790 --> 00:12:18,689
flag of the memory area nice change to

00:12:13,800 --> 00:12:21,059
Brady so and these flags are always

00:12:18,689 --> 00:12:24,529
changed with the memory barriers which

00:12:21,059 --> 00:12:27,899
means that when I changed these already

00:12:24,529 --> 00:12:29,759
any reader would also see the size they

00:12:27,899 --> 00:12:34,769
did and all the other data that have

00:12:29,759 --> 00:12:38,970
been written so far and at this point

00:12:34,769 --> 00:12:42,059
also a manifest file and identified the

00:12:38,970 --> 00:12:45,509
file system gets created it tells the

00:12:42,059 --> 00:12:47,519
reader where how to find this memory

00:12:45,509 --> 00:12:50,459
area I will not give you the detail

00:12:47,519 --> 00:12:51,839
actually this value is only one byte at

00:12:50,459 --> 00:12:55,439
the moment at least in the current

00:12:51,839 --> 00:13:01,619
implementation and this file always gets

00:12:55,439 --> 00:13:04,639
updated chronically so you will see why

00:13:01,619 --> 00:13:04,639
this needs to be updated

00:13:04,999 --> 00:13:08,549
ok

00:13:06,149 --> 00:13:10,769
as I said if reader will start to read

00:13:08,549 --> 00:13:14,119
the memory area at this point would see

00:13:10,769 --> 00:13:17,549
that there is nothing so let's try to

00:13:14,119 --> 00:13:19,829
write something there the function to

00:13:17,549 --> 00:13:22,279
write is inspector area create Chuck

00:13:19,829 --> 00:13:26,369
again this doesn't do really anything

00:13:22,279 --> 00:13:27,150
the chunk parameter is a structure that

00:13:26,369 --> 00:13:29,220
you have

00:13:27,150 --> 00:13:32,850
located on the staff it just initialize

00:13:29,220 --> 00:13:35,160
it the function to located is

00:13:32,850 --> 00:13:38,430
speculation allocate and it just state

00:13:35,160 --> 00:13:41,220
takes the size and that is the amount of

00:13:38,430 --> 00:13:43,920
data that you intend to write a shared

00:13:41,220 --> 00:13:45,780
memory for for this block when I say

00:13:43,920 --> 00:13:49,500
chocolate beans I don't know if it's

00:13:45,780 --> 00:13:54,420
proper English that's it it returns a

00:13:49,500 --> 00:13:57,770
porter you see the memory error that

00:13:54,420 --> 00:14:01,080
we've created pretty much already

00:13:57,770 --> 00:14:03,990
it's like the last ID that was taken

00:14:01,080 --> 00:14:06,780
from the Creator the one earlier gets

00:14:03,990 --> 00:14:12,030
you can enter paragraph so that next job

00:14:06,780 --> 00:14:15,720
will take different any here letter

00:14:12,030 --> 00:14:20,940
other ApS that can be caught on the

00:14:15,720 --> 00:14:24,810
chart structure to change the expiration

00:14:20,940 --> 00:14:26,240
time step and other things we will see

00:14:24,810 --> 00:14:30,170
them later

00:14:26,240 --> 00:14:35,280
but after we decided hoping it will be

00:14:30,170 --> 00:14:35,970
at the end of memory block we write

00:14:35,280 --> 00:14:42,140
again

00:14:35,970 --> 00:14:42,140
while state flag again is not located

00:14:44,030 --> 00:14:53,430
and our and the state for our track is

00:14:49,800 --> 00:14:55,470
changed to a located okay so what

00:14:53,430 --> 00:14:57,690
happens if our leader tries to redesign

00:14:55,470 --> 00:14:58,230
it says that okay the membrane area is

00:14:57,690 --> 00:15:01,680
ready

00:14:58,230 --> 00:15:04,800
the first shock is there but still in

00:15:01,680 --> 00:15:09,180
Arcata face it's not meant to be read

00:15:04,800 --> 00:15:13,700
yet it can continue to read our next

00:15:09,180 --> 00:15:13,700
chart says it's not look

00:15:14,329 --> 00:15:20,160
now pop the rights to the memory anyway

00:15:17,459 --> 00:15:22,740
we have a bottle so we can just use any

00:15:20,160 --> 00:15:26,670
function that we want here you see copy

00:15:22,740 --> 00:15:30,570
the right side there nothing we have to

00:15:26,670 --> 00:15:32,490
call it this is very important the

00:15:30,570 --> 00:15:37,800
commit operation is very simple it's

00:15:32,490 --> 00:15:40,560
just toggling of the state flag and it

00:15:37,800 --> 00:15:44,880
becomes written which means that at this

00:15:40,560 --> 00:15:50,760
point it's actually meaningful for any

00:15:44,880 --> 00:15:52,410
readers we can write one more shock I

00:15:50,760 --> 00:15:54,720
will not go through all the steps but

00:15:52,410 --> 00:15:58,470
they are exactly the same so first thing

00:15:54,720 --> 00:16:01,170
you set the chart track state to when it

00:15:58,470 --> 00:16:03,480
is already allocated but you create a

00:16:01,170 --> 00:16:05,550
new one at the end of the memory error

00:16:03,480 --> 00:16:08,279
that says I'm allocated you start

00:16:05,550 --> 00:16:12,720
filling it you write the data white

00:16:08,279 --> 00:16:18,839
comet is changed finally the biggest

00:16:12,720 --> 00:16:23,339
change to every 10 so what happens when

00:16:18,839 --> 00:16:25,290
you end will you end up exhausted the

00:16:23,339 --> 00:16:28,500
memory error like there is no space to

00:16:25,290 --> 00:16:33,959
write anything that's the interesting

00:16:28,500 --> 00:16:36,209
part because of course I said we are not

00:16:33,959 --> 00:16:40,519
going to qualify this memory area so it

00:16:36,209 --> 00:16:44,190
creates final copy what happens is that

00:16:40,519 --> 00:16:48,839
specularly clade and you share the area

00:16:44,190 --> 00:16:50,490
the same size it will not increase it I

00:16:48,839 --> 00:16:53,610
mean this is something that can be

00:16:50,490 --> 00:16:56,010
changed with flags but typically it

00:16:53,610 --> 00:16:58,170
should not increase and then all the

00:16:56,010 --> 00:17:01,440
village chunks are going to be copied

00:16:58,170 --> 00:17:05,040
over why do I say well it because

00:17:01,440 --> 00:17:07,709
they're also paid so invalidated artists

00:17:05,040 --> 00:17:11,370
that are expired I mentioned briefly

00:17:07,709 --> 00:17:13,799
before expert means that if you write a

00:17:11,370 --> 00:17:16,169
check and see that this is valid only

00:17:13,799 --> 00:17:20,820
for a couple of seconds for the next two

00:17:16,169 --> 00:17:22,560
seconds well of course when we finished

00:17:20,820 --> 00:17:24,810
space in the memory area and we look

00:17:22,560 --> 00:17:27,300
through all the charts which are per

00:17:24,810 --> 00:17:30,030
plan steps now if they are too old then

00:17:27,300 --> 00:17:32,490
we will not copy them and then there are

00:17:30,030 --> 00:17:42,660
also obsolete a chance that we will

00:17:32,490 --> 00:17:45,690
explain in previous ones and once we

00:17:42,660 --> 00:17:49,670
have created our copy of the memory area

00:17:45,690 --> 00:17:53,490
only with a valid chance we update

00:17:49,670 --> 00:17:57,300
atomically the manifest file so that new

00:17:53,490 --> 00:18:01,680
readers will will immediately start

00:17:57,300 --> 00:18:03,690
reading the newest and so what happens

00:18:01,680 --> 00:18:06,990
to the water it is those who have

00:18:03,690 --> 00:18:11,130
already this opened well we set the

00:18:06,990 --> 00:18:15,390
state of the area to obsoleted and every

00:18:11,130 --> 00:18:18,870
faction in the reader of specula always

00:18:15,390 --> 00:18:21,120
checks the state before actually written

00:18:18,870 --> 00:18:24,090
to every area so if it says that it is

00:18:21,120 --> 00:18:26,640
also latent it would not continue

00:18:24,090 --> 00:18:30,300
reading it it will close this memory

00:18:26,640 --> 00:18:32,460
area and it will open that you want when

00:18:30,300 --> 00:18:38,600
you read in the manifest file and

00:18:32,460 --> 00:18:42,600
figuring out where it is and finally the

00:18:38,600 --> 00:18:45,750
old memory area this one gets a leaked

00:18:42,600 --> 00:18:52,470
leaked like it's very daily cooperation

00:18:45,750 --> 00:18:55,820
of the of POSIX so this file basically

00:18:52,470 --> 00:19:02,190
disappears from the shared memory

00:18:55,820 --> 00:19:04,590
subtree however as you know like UNIX if

00:19:02,190 --> 00:19:07,140
you are reading a file and you delete it

00:19:04,590 --> 00:19:07,980
you can see continue reading it if you

00:19:07,140 --> 00:19:12,630
have it open

00:19:07,980 --> 00:19:16,260
Denis fine so you have met this

00:19:12,630 --> 00:19:22,020
in your in your process so you can

00:19:16,260 --> 00:19:27,510
continue reading it when the last reader

00:19:22,020 --> 00:19:31,740
will close it then of course a operating

00:19:27,510 --> 00:19:34,470
system will get rid of this one okay

00:19:31,740 --> 00:19:37,320
I mentioned obsolete date and so as I

00:19:34,470 --> 00:19:40,140
said it's charts which have expired but

00:19:37,320 --> 00:19:42,980
also we it's chance which have been

00:19:40,140 --> 00:19:48,720
updated so we have an update operation

00:19:42,980 --> 00:19:52,860
which takes the this structure of a

00:19:48,720 --> 00:19:56,610
chunk and the new size and basically it

00:19:52,860 --> 00:19:58,890
searches any one location it creates a

00:19:56,610 --> 00:19:59,460
completely new chunk it just retains the

00:19:58,890 --> 00:20:03,570
cicchetti

00:19:59,460 --> 00:20:08,820
and the reader the readers with note

00:20:03,570 --> 00:20:12,360
that this is how to say a new version of

00:20:08,820 --> 00:20:16,650
the chunk of the data you can think of

00:20:12,360 --> 00:20:19,200
it for instance if you have if you're

00:20:16,650 --> 00:20:23,250
using speculum for configuration like

00:20:19,200 --> 00:20:26,250
take for example you're studying JSON

00:20:23,250 --> 00:20:29,880
file Michelle angry okay when you change

00:20:26,250 --> 00:20:32,190
a flag in digital file then you would

00:20:29,880 --> 00:20:35,700
call this method here you would create

00:20:32,190 --> 00:20:39,300
you update with the new size you write

00:20:35,700 --> 00:20:41,760
in your own choice out there and the

00:20:39,300 --> 00:20:49,590
reader will know that I have to forget

00:20:41,760 --> 00:20:56,290
that all the values own okay so how can

00:20:49,590 --> 00:20:58,750
specular be used at least the way that I

00:20:56,290 --> 00:21:02,620
they see it is that it can be used as a

00:20:58,750 --> 00:21:05,980
stream of messages so you have a writer

00:21:02,620 --> 00:21:09,280
that continuously but when it needs to

00:21:05,980 --> 00:21:12,490
it writes memory writes messages in the

00:21:09,280 --> 00:21:14,380
memory area you can be short can be long

00:21:12,490 --> 00:21:17,500
there can be big messages doesn't matter

00:21:14,380 --> 00:21:21,970
but it sets an expiration time on each

00:21:17,500 --> 00:21:26,260
of them those like it's it really

00:21:21,970 --> 00:21:29,770
depends on the needs but if you think of

00:21:26,260 --> 00:21:31,150
if I always thinking of the use case

00:21:29,770 --> 00:21:35,800
that we had in our case it was like

00:21:31,150 --> 00:21:38,670
instant messaging and like notifications

00:21:35,800 --> 00:21:41,320
about incoming call and stuff like

00:21:38,670 --> 00:21:43,560
expiration times the couple of seconds

00:21:41,320 --> 00:21:46,120
because we know that a couple of seconds

00:21:43,560 --> 00:21:50,220
all other processes should have been

00:21:46,120 --> 00:21:55,390
able to read this memory to smell a big

00:21:50,220 --> 00:21:59,170
big messages and you can have like a

00:21:55,390 --> 00:22:03,580
network of processes talking to each

00:21:59,170 --> 00:22:06,100
other but still you must make sure I

00:22:03,580 --> 00:22:10,420
mean it's a limitation on speculoos

00:22:06,100 --> 00:22:11,860
it's a everyone who has something to say

00:22:10,420 --> 00:22:16,000
needs to be a writer

00:22:11,860 --> 00:22:18,790
so every process that is going to send

00:22:16,000 --> 00:22:21,790
not coming messages into an inspector as

00:22:18,790 --> 00:22:23,800
a writer or another use case is

00:22:21,790 --> 00:22:25,570
publishing a doctor blocking so they

00:22:23,800 --> 00:22:30,580
case the dimension

00:22:25,570 --> 00:22:34,030
with Jesus right for example okay that

00:22:30,580 --> 00:22:36,340
is all about what they wanted to say you

00:22:34,030 --> 00:22:40,900
can find a cool documentation you can

00:22:36,340 --> 00:22:44,320
email me my blog I am writing about

00:22:40,900 --> 00:22:46,150
everything so not only technology and

00:22:44,320 --> 00:22:48,090
everything in English in Tahlequah

00:22:46,150 --> 00:22:50,890
talent so it might not be that

00:22:48,090 --> 00:22:53,980
interesting I have another blog in

00:22:50,890 --> 00:22:58,090
Russia only studying Russian so it's for

00:22:53,980 --> 00:22:59,800
my mistakes I was on Twitter there I

00:22:58,090 --> 00:23:06,700
have to wonder it's mostly political

00:22:59,800 --> 00:23:08,800
context so propaganda and I want to say

00:23:06,700 --> 00:23:12,840
a couple of words before taking

00:23:08,800 --> 00:23:16,060
questions we have time because there is

00:23:12,840 --> 00:23:18,010
it's kind of ugly out of it but it was

00:23:16,060 --> 00:23:22,090
consideration that they wanted to make

00:23:18,010 --> 00:23:25,920
that it looks to me like software is

00:23:22,090 --> 00:23:29,970
evolving in a strange way because

00:23:25,920 --> 00:23:34,270
software tends to be to grow like to

00:23:29,970 --> 00:23:39,180
gain new features and then at some

00:23:34,270 --> 00:23:45,040
points there are kind of wholesale drops

00:23:39,180 --> 00:23:48,310
like software can get from scratch and

00:23:45,040 --> 00:23:50,380
sometimes it gets rewritten even with a

00:23:48,310 --> 00:23:54,790
completely different spirit or like new

00:23:50,380 --> 00:23:57,790
projects take over the world to us and I

00:23:54,790 --> 00:24:02,230
have in mind the case of Weyland for

00:23:57,790 --> 00:24:04,840
example and systemd and one thing that

00:24:02,230 --> 00:24:07,120
strikes me is that if you look at these

00:24:04,840 --> 00:24:11,350
technologies there is nothing really

00:24:07,120 --> 00:24:11,830
that couldn't have been done 30 or 40

00:24:11,350 --> 00:24:14,310
years ago

00:24:11,830 --> 00:24:16,010
oh consistently which is a sea cruise

00:24:14,310 --> 00:24:18,740
taking cues of

00:24:16,010 --> 00:24:21,590
staff sure but like the spirit I

00:24:18,740 --> 00:24:24,590
remember that they read a blog post from

00:24:21,590 --> 00:24:26,900
laughs totaling about like when who was

00:24:24,590 --> 00:24:29,360
actually introduced insistently and it

00:24:26,900 --> 00:24:32,780
was kind of striking that they were new

00:24:29,360 --> 00:24:37,900
ideas but using the old concept it was

00:24:32,780 --> 00:24:43,429
very interesting and refreshing and I I

00:24:37,900 --> 00:24:46,610
don't want to say that this applies to

00:24:43,429 --> 00:24:48,830
specular as well because actually I

00:24:46,610 --> 00:24:53,690
don't know anyone using it yet because I

00:24:48,830 --> 00:24:56,120
haven't doing for some it myself because

00:24:53,690 --> 00:25:00,110
of a lack of free time and interesting

00:24:56,120 --> 00:25:06,470
more projects but it's interesting to

00:25:00,110 --> 00:25:08,270
see how software while becoming much if

00:25:06,470 --> 00:25:11,660
you look at Whalen for example Whalen

00:25:08,270 --> 00:25:15,230
and accelerate that Pixlr it's extremely

00:25:11,660 --> 00:25:17,419
complex it's for remote machines can do

00:25:15,230 --> 00:25:20,240
really everything and think of Whalen

00:25:17,419 --> 00:25:22,700
which is not super that it is exactly

00:25:20,240 --> 00:25:26,780
what we get okay

00:25:22,700 --> 00:25:35,540
and that's if you feel and you should

00:25:26,780 --> 00:25:37,720
have questions already please do you

00:25:35,540 --> 00:25:41,270
plan to wrap this in a higher level

00:25:37,720 --> 00:25:43,640
framework like the deepest or which is

00:25:41,270 --> 00:25:47,480
can be just a tool kit for from your own

00:25:43,640 --> 00:25:51,440
magazine that was the idea that was the

00:25:47,480 --> 00:25:54,410
idea and if I will have time I will do

00:25:51,440 --> 00:26:00,650
that but I realized that it is a very

00:25:54,410 --> 00:26:05,059
very thematic project peepers yeah

00:26:00,650 --> 00:26:07,970
because he I cannot just do a bad

00:26:05,059 --> 00:26:09,059
relative as it means to be compatible at

00:26:07,970 --> 00:26:13,320
it

00:26:09,059 --> 00:26:14,879
while someone will use it and this is a

00:26:13,320 --> 00:26:18,600
bit tricky

00:26:14,879 --> 00:26:20,129
yeah one thing it that they can say one

00:26:18,600 --> 00:26:23,279
nice thing I can say about Spectre is

00:26:20,129 --> 00:26:27,179
that it doesn't use any fine descriptor

00:26:23,279 --> 00:26:29,429
so what you need a fun descriptor when

00:26:27,179 --> 00:26:31,440
you open the shelter memory but then

00:26:29,429 --> 00:26:34,499
once it's meant into your process you

00:26:31,440 --> 00:26:37,830
can actually close it so you don't have

00:26:34,499 --> 00:26:40,019
to worry about 33 proliferation of my

00:26:37,830 --> 00:26:42,600
finest victims you know there might be

00:26:40,019 --> 00:26:45,720
something especially if it's better

00:26:42,600 --> 00:26:48,269
devices so you okay

00:26:45,720 --> 00:26:50,940
specular doesn't have any signaling of

00:26:48,269 --> 00:26:53,070
itself it does a technical way that is

00:26:50,940 --> 00:26:54,990
data to be written so you need to use I

00:26:53,070 --> 00:26:58,769
don't know if you want to use Linux it

00:26:54,990 --> 00:27:09,149
as or UNIX sockets but you can do that

00:26:58,769 --> 00:27:15,110
because you have have you tried to

00:27:09,149 --> 00:27:19,559
benchmark it performance-wise oops okay

00:27:15,110 --> 00:27:22,200
yes I mean I did they're not very easy

00:27:19,559 --> 00:27:26,159
does need to be honest I one thing I

00:27:22,200 --> 00:27:29,100
noticed is that setting up shell is very

00:27:26,159 --> 00:27:31,759
expensive so I also mentioned that it

00:27:29,100 --> 00:27:35,340
will go like that immediately but

00:27:31,759 --> 00:27:38,159
creating the memory area and when you

00:27:35,340 --> 00:27:42,570
start writing to it I think it's it

00:27:38,159 --> 00:27:45,869
seems that there is the biggest cost and

00:27:42,570 --> 00:27:49,080
that's why it's nice that you can write

00:27:45,869 --> 00:27:55,769
different type of blocks inside the same

00:27:49,080 --> 00:28:00,330
memory area say memory file so now I

00:27:55,769 --> 00:28:00,899
didn't try to write unit tests and they

00:28:00,330 --> 00:28:03,600
prayed

00:28:00,899 --> 00:28:09,480
timing information I didn't find a way

00:28:03,600 --> 00:28:10,059
to reliably test the speed no way that

00:28:09,480 --> 00:28:12,519
could be

00:28:10,059 --> 00:28:14,950
fair to compare because the technology

00:28:12,519 --> 00:28:16,960
is very different from UNIX sockets if I

00:28:14,950 --> 00:28:19,899
compare that with UNIX sockets how many

00:28:16,960 --> 00:28:22,869
processes we have to put I know that if

00:28:19,899 --> 00:28:24,789
I put like 100 processes talking

00:28:22,869 --> 00:28:28,119
together with the mix of the sockets

00:28:24,789 --> 00:28:31,179
specularly of course we but then if

00:28:28,119 --> 00:28:33,519
there are only two I tried with to serve

00:28:31,179 --> 00:28:37,779
two processes talking by sockets is

00:28:33,519 --> 00:28:40,779
simply the fastest thing ever so surface

00:28:37,779 --> 00:28:43,330
are extremely efficient but when you

00:28:40,779 --> 00:28:45,249
have more parties to get to each other

00:28:43,330 --> 00:28:47,469
depends how big are the blocks of

00:28:45,249 --> 00:28:50,889
commitment they are so it's it's very

00:28:47,469 --> 00:28:53,349
tricky to measure I think I won't need

00:28:50,889 --> 00:29:04,179
to know what is the use case and then we

00:28:53,349 --> 00:29:08,349
can try it would it be practice in this

00:29:04,179 --> 00:29:12,450
library or set up for two parties that

00:29:08,349 --> 00:29:16,179
are both interested in making it work

00:29:12,450 --> 00:29:20,080
I'd like to speak about security so the

00:29:16,179 --> 00:29:21,849
opposite of that would be that the the

00:29:20,080 --> 00:29:25,899
two programs don't trust each other

00:29:21,849 --> 00:29:28,330
fully have you considered that and I

00:29:25,899 --> 00:29:31,330
mean to follow up with a question about

00:29:28,330 --> 00:29:39,899
sealing of do you know the ceiling

00:29:31,330 --> 00:29:45,580
feature of shared memory in the future

00:29:39,899 --> 00:29:50,080
so yes I've done studies and I think it

00:29:45,580 --> 00:29:52,089
is security we assess that if they files

00:29:50,080 --> 00:29:55,210
can be protected if you can rule out the

00:29:52,089 --> 00:29:56,120
fact that only the writer can write that

00:29:55,210 --> 00:29:59,390
file

00:29:56,120 --> 00:30:02,840
right yeah the problem is rather if you

00:29:59,390 --> 00:30:05,870
have a a writer who's trying to trick

00:30:02,840 --> 00:30:09,650
the readers somehow the ceiling features

00:30:05,870 --> 00:30:13,070
essentially makes the shared memory read

00:30:09,650 --> 00:30:16,490
only once it has one sir that's been

00:30:13,070 --> 00:30:18,289
committed so the reader can know that it

00:30:16,490 --> 00:30:21,620
cannot be changed during the time that

00:30:18,289 --> 00:30:23,150
it has read read part of it towards the

00:30:21,620 --> 00:30:25,669
time it is reading the end of it

00:30:23,150 --> 00:30:28,070
essentially or if it does it's a

00:30:25,669 --> 00:30:30,529
protocol or the implementation and read

00:30:28,070 --> 00:30:33,049
is such that it will go back to the but

00:30:30,529 --> 00:30:36,289
for multiple times he wants to know that

00:30:33,049 --> 00:30:40,340
the date has not been changed in between

00:30:36,289 --> 00:30:43,909
and so I in this case would it be

00:30:40,340 --> 00:30:46,820
possible for me as a writer to basically

00:30:43,909 --> 00:30:48,620
open the shared memory and bypass your

00:30:46,820 --> 00:30:51,350
library so could I open it and get a

00:30:48,620 --> 00:30:54,230
file descriptor and then write things to

00:30:51,350 --> 00:31:01,640
it without following the protocol that

00:30:54,230 --> 00:31:04,100
their libraries actually yeah I'm doing

00:31:01,640 --> 00:31:06,710
something with the shared memories or

00:31:04,100 --> 00:31:10,039
certain some flags that it's meant to be

00:31:06,710 --> 00:31:13,279
read sequentially like just for

00:31:10,039 --> 00:31:16,399
optimization it might be that this can

00:31:13,279 --> 00:31:19,610
be changed to actually take to account

00:31:16,399 --> 00:31:23,809
your suggestions so if we set the size

00:31:19,610 --> 00:31:26,510
if we when the right advocates besides

00:31:23,809 --> 00:31:28,520
maybe increase it to say that it is at

00:31:26,510 --> 00:31:31,520
least one page for example I guess that

00:31:28,520 --> 00:31:37,039
the feature that you mentioned works for

00:31:31,520 --> 00:31:39,200
every single page right I don't know

00:31:37,039 --> 00:31:41,600
that but if you talk about the sealing

00:31:39,200 --> 00:31:44,870
feature I know that you can you can

00:31:41,600 --> 00:31:46,880
basically say that this is now read-only

00:31:44,870 --> 00:31:49,039
and the kernel will enforce that so

00:31:46,880 --> 00:31:53,059
there we here knows that from this point

00:31:49,039 --> 00:31:54,470
forward the writer cannot change the

00:31:53,059 --> 00:31:58,039
data that they did

00:31:54,470 --> 00:31:59,629
we committed the kind of attack would be

00:31:58,039 --> 00:32:02,149
that here you're fooling the reader to

00:31:59,629 --> 00:32:04,730
think that it's it's one thing and then

00:32:02,149 --> 00:32:06,769
the reader goes into certain frog part

00:32:04,730 --> 00:32:09,230
of the program and later on you you

00:32:06,769 --> 00:32:12,409
switch some data around making the

00:32:09,230 --> 00:32:14,269
reader implementation malfunction so I

00:32:12,409 --> 00:32:18,440
thank you for your answer I think it's

00:32:14,269 --> 00:32:20,090
still a very useful library but if you

00:32:18,440 --> 00:32:24,259
were to implement something like B bus

00:32:20,090 --> 00:32:25,970
this the the aspect of the two parties

00:32:24,259 --> 00:32:37,100
much fully trusting each other would

00:32:25,970 --> 00:32:41,980
have to be addressed somehow yeah yeah

00:32:37,100 --> 00:32:43,510
any more questions thank you very much

00:32:41,980 --> 00:32:46,809
[Applause]

00:32:43,510 --> 00:32:46,809

YouTube URL: https://www.youtube.com/watch?v=pdpxXCV4_5M


