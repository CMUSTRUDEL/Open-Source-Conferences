Title: Introducing Rook - Kristoffer GrÃ¶nlund
Publication date: 2020-04-05
Playlist: foss-north 2020 virtual
Description: 
	Talk details: https://foss-north.se/2020/speakers-and-talks.html#kgronlund
Conference details: https://foss-north.se/2020/
Captions: 
	00:00:00,030 --> 00:00:05,640
welcome to force north the virtual

00:00:02,790 --> 00:00:07,799
edition we would like to thank all our

00:00:05,640 --> 00:00:11,969
sponsors and partners in this difficult

00:00:07,799 --> 00:00:15,469
situation our gold sponsors look soft

00:00:11,969 --> 00:00:19,640
and ansible by Red Hat

00:00:15,469 --> 00:00:21,860
our silver sponsors ITRs group and make

00:00:19,640 --> 00:00:25,520
it right

00:00:21,860 --> 00:00:28,580
our base sponsors

00:00:25,520 --> 00:00:30,770
our partner projects the open source

00:00:28,580 --> 00:00:33,890
community and the region of Gothenburg

00:00:30,770 --> 00:00:35,930
and a huge thanks to our awesome

00:00:33,890 --> 00:00:40,700
community this would not have been

00:00:35,930 --> 00:00:43,070
possible without you today we're happy

00:00:40,700 --> 00:00:45,620
to to start for North the virtual

00:00:43,070 --> 00:00:47,780
edition and first out of all our brave

00:00:45,620 --> 00:00:50,510
speakers is Christopher garland who will

00:00:47,780 --> 00:00:55,150
be introducing rook to us so I'm handing

00:00:50,510 --> 00:01:00,560
over the the view to him now welcome

00:00:55,150 --> 00:01:04,369
thank you yes so I will be introducing

00:01:00,560 --> 00:01:07,610
rook and telling you what it is and what

00:01:04,369 --> 00:01:10,670
is useful for my name is Chris Overland

00:01:07,610 --> 00:01:12,649
I work for a Sousa and I work in the

00:01:10,670 --> 00:01:15,050
storage team so we're doing a product

00:01:12,649 --> 00:01:17,540
called storage which is based on safe

00:01:15,050 --> 00:01:21,920
and the thing I've been working on the

00:01:17,540 --> 00:01:26,869
last year is basically Brooke which is

00:01:21,920 --> 00:01:29,660
running safe on kubernetes so in this

00:01:26,869 --> 00:01:32,060
talk I'm gonna be talking about three

00:01:29,660 --> 00:01:33,500
different things I'm gonna talk a little

00:01:32,060 --> 00:01:37,640
bit about safe a little bit about

00:01:33,500 --> 00:01:40,090
kubernetes and a little bit of a look if

00:01:37,640 --> 00:01:42,800
anyone is unfamiliar with all of these

00:01:40,090 --> 00:01:46,039
unfortunately I won't be able to go into

00:01:42,800 --> 00:01:47,869
too much depth I'm gonna talk a bit more

00:01:46,039 --> 00:01:50,149
about safe and rook then about

00:01:47,869 --> 00:01:54,110
kubernetes because Q net is is a massive

00:01:50,149 --> 00:01:55,580
topic on sale so the first thing I want

00:01:54,110 --> 00:01:59,300
to talk about is software-defined

00:01:55,580 --> 00:02:02,090
storage Ceph is a software-defined

00:01:59,300 --> 00:02:03,890
storage solution and software-defined

00:02:02,090 --> 00:02:06,590
storage is kind of contrasted against

00:02:03,890 --> 00:02:08,450
traditional storage solutions so buying

00:02:06,590 --> 00:02:11,569
a storage array from a vendor is just

00:02:08,450 --> 00:02:13,910
like a big box full of hard drives the

00:02:11,569 --> 00:02:16,340
benefits of Software Defined storage is

00:02:13,910 --> 00:02:19,700
that it's cheaper and it's more flexible

00:02:16,340 --> 00:02:23,090
more adaptable to your storage needs

00:02:19,700 --> 00:02:26,750
and it's cloud compatible which is you

00:02:23,090 --> 00:02:28,880
can run on public cloud the downside is

00:02:26,750 --> 00:02:31,010
that there's more calm sight complexity

00:02:28,880 --> 00:02:33,050
for user handles so the traditional

00:02:31,010 --> 00:02:35,050
storage solution you use buy a box you

00:02:33,050 --> 00:02:38,750
plug it in and you have your storage

00:02:35,050 --> 00:02:39,300
with something like SEF a lot of the

00:02:38,750 --> 00:02:41,550
work

00:02:39,300 --> 00:02:43,530
maintaining it and managing it falls on

00:02:41,550 --> 00:02:46,980
the system administrator so there's a

00:02:43,530 --> 00:02:50,060
bit more of a cognitive lobe there but

00:02:46,980 --> 00:02:56,570
the benefits are huge

00:02:50,060 --> 00:03:00,270
so SEF is open source project LGPL

00:02:56,570 --> 00:03:06,570
license it's a distributed cluster

00:03:00,270 --> 00:03:10,860
solution so the it's based on a bunch of

00:03:06,570 --> 00:03:13,080
nodes collaborating it's massively

00:03:10,860 --> 00:03:15,450
scalable and I'll talk a little bit more

00:03:13,080 --> 00:03:17,600
about how that is and what it means but

00:03:15,450 --> 00:03:20,340
basically means that there's really no

00:03:17,600 --> 00:03:22,410
theoretical limits for how much you can

00:03:20,340 --> 00:03:25,350
scale a safe cluster how much storage

00:03:22,410 --> 00:03:27,180
you can add to it and it's scalable

00:03:25,350 --> 00:03:28,950
meaning that you can add or remove nodes

00:03:27,180 --> 00:03:32,010
as you need

00:03:28,950 --> 00:03:35,430
it's self-healing so it does a lot of

00:03:32,010 --> 00:03:38,730
work to automatically detect them route

00:03:35,430 --> 00:03:41,010
around failures in the cluster and it

00:03:38,730 --> 00:03:44,040
runs on commodity hardware or on the

00:03:41,010 --> 00:03:47,940
public cloud so it's flexible in that

00:03:44,040 --> 00:03:51,030
sense as well another nice thing about

00:03:47,940 --> 00:03:53,400
SEF is that it has a lot of interfaces

00:03:51,030 --> 00:03:55,860
so basically any kind of any way that

00:03:53,400 --> 00:03:57,900
you could theoretically interact with a

00:03:55,860 --> 00:04:00,420
storage solution you can interact with

00:03:57,900 --> 00:04:04,860
SEF so it provides object storage

00:04:00,420 --> 00:04:07,620
interfaces so REST API is like s3 so it

00:04:04,860 --> 00:04:11,100
as an API compatible with the Amazon s3

00:04:07,620 --> 00:04:14,459
if you're the OpenStack Swift API

00:04:11,100 --> 00:04:17,760
there's other kind of REST API so you

00:04:14,459 --> 00:04:20,730
can mount storage on SEF block device so

00:04:17,760 --> 00:04:23,370
you smarter as a role device and format

00:04:20,730 --> 00:04:26,400
your own file system on top and it also

00:04:23,370 --> 00:04:28,770
provides a file system called cephas so

00:04:26,400 --> 00:04:32,580
it's a POSIX compatible file system the

00:04:28,770 --> 00:04:36,590
amounts as any kind of other file system

00:04:32,580 --> 00:04:41,540
and it also provides a library

00:04:36,590 --> 00:04:45,270
liberators which is just a direct

00:04:41,540 --> 00:04:48,060
interface to the storage cluster so you

00:04:45,270 --> 00:04:50,220
can interfacing it from your favorite

00:04:48,060 --> 00:04:51,950
programming language and access the

00:04:50,220 --> 00:04:55,190
storage that way

00:04:51,950 --> 00:04:57,800
there are also a few other things so it

00:04:55,190 --> 00:04:59,840
has an effect gateway a samba gateway

00:04:57,800 --> 00:05:01,970
things like that so you really you can

00:04:59,840 --> 00:05:07,060
interface with a cluster from any

00:05:01,970 --> 00:05:11,750
operating system in any any client so

00:05:07,060 --> 00:05:14,240
radius is the name of the Ceph cluster

00:05:11,750 --> 00:05:18,350
so I'm gonna go through some of the

00:05:14,240 --> 00:05:20,810
terms used in cepheus because yeah

00:05:18,350 --> 00:05:22,520
otherwise know what I'm saying later

00:05:20,810 --> 00:05:24,830
it's gonna make sense so hopefully you

00:05:22,520 --> 00:05:26,750
can remember some of these so yeah it's

00:05:24,830 --> 00:05:30,010
a radius is the name of the object store

00:05:26,750 --> 00:05:33,560
cluster and it's basically a cluster of

00:05:30,010 --> 00:05:36,620
independent kind of peers there are

00:05:33,560 --> 00:05:38,300
intelligent in the sense that they they

00:05:36,620 --> 00:05:42,320
don't just do what they're being told by

00:05:38,300 --> 00:05:43,880
some kind of master node and they find

00:05:42,320 --> 00:05:47,800
out what the state of a cluster is and

00:05:43,880 --> 00:05:52,730
makes decisions based on that and

00:05:47,800 --> 00:05:54,830
there's kind of two main types of nodes

00:05:52,730 --> 00:05:56,300
in the cluster and there are storage

00:05:54,830 --> 00:05:58,610
nodes that have storage and then there's

00:05:56,300 --> 00:06:00,920
something called monitors which are kind

00:05:58,610 --> 00:06:04,330
of the nodes responsible for creating

00:06:00,920 --> 00:06:06,590
making sure that everyone is in sync

00:06:04,330 --> 00:06:11,810
there's more to it but I'm getting into

00:06:06,590 --> 00:06:14,510
that later the secret sauce of Ceph so

00:06:11,810 --> 00:06:16,070
to speak is something called crush so

00:06:14,510 --> 00:06:18,290
this is kind of the theoretical

00:06:16,070 --> 00:06:23,270
framework that that's the basis for how

00:06:18,290 --> 00:06:25,490
Ceph works and basically the crush is an

00:06:23,270 --> 00:06:27,890
algorithm used both by clients of the

00:06:25,490 --> 00:06:31,010
cluster and the cluster itself to figure

00:06:27,890 --> 00:06:34,910
out where a particular piece of data is

00:06:31,010 --> 00:06:37,160
or should be in the cluster and I'm

00:06:34,910 --> 00:06:39,310
gonna talk to me about that more more

00:06:37,160 --> 00:06:41,040
later

00:06:39,310 --> 00:06:43,470
the two main

00:06:41,040 --> 00:06:46,110
the nodes in the cluster are called OSTs

00:06:43,470 --> 00:06:47,370
and months so always these are storage

00:06:46,110 --> 00:06:50,490
demons

00:06:47,370 --> 00:06:55,170
these are you have one storage demon per

00:06:50,490 --> 00:06:59,610
disk it's a per SSD or hard drive or

00:06:55,170 --> 00:07:02,040
nvme storage component so you can have

00:06:59,610 --> 00:07:04,440
multiple storage demons on one node if

00:07:02,040 --> 00:07:06,600
you have multiple hard drives on it they

00:07:04,440 --> 00:07:08,640
all serve data to clients and they also

00:07:06,600 --> 00:07:09,210
handle peer-to-peer replication and

00:07:08,640 --> 00:07:14,420
recovery

00:07:09,210 --> 00:07:18,500
so when there is a change in the cluster

00:07:14,420 --> 00:07:21,470
the osts will react to it and sync

00:07:18,500 --> 00:07:26,700
between each other without any kind of

00:07:21,470 --> 00:07:33,020
external master node and then the Manas

00:07:26,700 --> 00:07:35,430
are kind of basically maintaining a

00:07:33,020 --> 00:07:39,150
synchronized database used by the u.s.

00:07:35,430 --> 00:07:41,700
these two share the piece of data that

00:07:39,150 --> 00:07:44,700
they need to synchronize so the models

00:07:41,700 --> 00:07:47,430
are completely out of the data path they

00:07:44,700 --> 00:07:49,860
are not involved in any kind of serving

00:07:47,430 --> 00:07:52,650
of data but they're used by the overseas

00:07:49,860 --> 00:07:54,720
to synchronize the clustering typically

00:07:52,650 --> 00:07:58,350
you have like three or five of these in

00:07:54,720 --> 00:08:02,070
a cluster and regardless of size so this

00:07:58,350 --> 00:08:04,230
week there are a few other kind of

00:08:02,070 --> 00:08:05,810
demons in the safe cluster so there's

00:08:04,230 --> 00:08:08,010
the manage daemon which runs

00:08:05,810 --> 00:08:10,820
services for the cluster so for example

00:08:08,010 --> 00:08:13,590
the dashboard of the screenshot later

00:08:10,820 --> 00:08:15,600
there are M DST mist the handle file

00:08:13,590 --> 00:08:17,940
system metadata for an ACEF infest file

00:08:15,600 --> 00:08:20,220
system there's something called radius

00:08:17,940 --> 00:08:22,440
gateways which are the nodes that

00:08:20,220 --> 00:08:25,910
actually provide the REST API stay we

00:08:22,440 --> 00:08:31,650
use to connect using the s3 or swift ApS

00:08:25,910 --> 00:08:35,460
and so on and here's kind of a picture

00:08:31,650 --> 00:08:37,080
of what the cluster looks like so the

00:08:35,460 --> 00:08:39,780
core of the cluster is the radius of

00:08:37,080 --> 00:08:42,599
your store which consists of a number of

00:08:39,780 --> 00:08:46,440
nodes to have OSD demons running on them

00:08:42,599 --> 00:08:48,300
each OSD maps to a device and then you

00:08:46,440 --> 00:08:50,730
have a number of monitor servers that

00:08:48,300 --> 00:08:52,290
are used by the OSD in order to

00:08:50,730 --> 00:08:54,630
synchronize

00:08:52,290 --> 00:08:57,180
and then above that you have a few

00:08:54,630 --> 00:08:59,190
different nodes providing interfaces to

00:08:57,180 --> 00:09:02,790
cluster and then about that you have the

00:08:59,190 --> 00:09:06,330
clients and the clients can be client

00:09:02,790 --> 00:09:09,780
machines accessing block storage it can

00:09:06,330 --> 00:09:14,520
be applications access in the object

00:09:09,780 --> 00:09:20,330
storage or it can be nodes mapping the

00:09:14,520 --> 00:09:20,330
surface file system s as a file system

00:09:21,930 --> 00:09:28,110
one key thing about Seth or kind of the

00:09:25,370 --> 00:09:29,670
cool thing about self is that there is

00:09:28,110 --> 00:09:33,390
no single point of failure in the

00:09:29,670 --> 00:09:35,670
cluster there is no single entry point

00:09:33,390 --> 00:09:38,180
in the cluster that everything kind of

00:09:35,670 --> 00:09:41,380
has to go through or there are no

00:09:38,180 --> 00:09:42,570
bottlenecks in that sense and

00:09:41,380 --> 00:09:45,450
[Music]

00:09:42,570 --> 00:09:47,790
clients of the cluster use the crush

00:09:45,450 --> 00:09:50,910
algorithm that I described before to

00:09:47,790 --> 00:09:53,520
figure out where the data that neither

00:09:50,910 --> 00:09:56,070
is or should be and then they can go

00:09:53,520 --> 00:10:00,050
directly to those nodes and interact

00:09:56,070 --> 00:10:02,400
with those nodes and directly so

00:10:00,050 --> 00:10:05,730
basically works kind of like in my

00:10:02,400 --> 00:10:07,890
amazing drawing here you take a piece of

00:10:05,730 --> 00:10:10,890
data you use the crush algorithm to

00:10:07,890 --> 00:10:12,720
figure out where it should be and then

00:10:10,890 --> 00:10:16,200
you go to the OSD where it should be and

00:10:12,720 --> 00:10:18,150
either if you're breathing you ask they

00:10:16,200 --> 00:10:21,270
will see for the piece of data or if

00:10:18,150 --> 00:10:27,660
you're writing you write the data to the

00:10:21,270 --> 00:10:33,480
LC and kind of the the reason why it's

00:10:27,660 --> 00:10:37,020
working like this is that it allows the

00:10:33,480 --> 00:10:39,300
cluster to scale far beyond what it will

00:10:37,020 --> 00:10:43,140
be able to if you kind of had to go

00:10:39,300 --> 00:10:46,050
through some kind of intermediate

00:10:43,140 --> 00:10:48,390
service so to dig into that a little bit

00:10:46,050 --> 00:10:50,280
more why wouldn't you have kind of a

00:10:48,390 --> 00:10:53,790
directory server that tells you where

00:10:50,280 --> 00:10:56,790
the data is located the problem is that

00:10:53,790 --> 00:10:58,170
first of all doing that means you have

00:10:56,790 --> 00:10:59,940
to do a two-stage lookups you have to

00:10:58,170 --> 00:11:01,890
contact that server and then once you

00:10:59,940 --> 00:11:05,010
get a reply you have to then go to the

00:11:01,890 --> 00:11:07,740
server that has data or that server

00:11:05,010 --> 00:11:09,360
would like you have a kind of a gateway

00:11:07,740 --> 00:11:13,440
and that sir will go and find the data

00:11:09,360 --> 00:11:15,510
and then head back to you these limits

00:11:13,440 --> 00:11:17,780
scalability so now you have kind of a

00:11:15,510 --> 00:11:22,050
you have to be able to scale those

00:11:17,780 --> 00:11:23,520
intermediate nodes and also you have the

00:11:22,050 --> 00:11:26,370
problem of keeping that directory in

00:11:23,520 --> 00:11:28,920
sync so now you have to for every piece

00:11:26,370 --> 00:11:31,020
of data that's changing you have to

00:11:28,920 --> 00:11:35,550
contact that directory and tell it ok

00:11:31,020 --> 00:11:38,580
now this piece of data is over here the

00:11:35,550 --> 00:11:40,350
first thing you might have is to do kind

00:11:38,580 --> 00:11:43,050
of a single step placement which is you

00:11:40,350 --> 00:11:44,250
hash the data so you get a hash you run

00:11:43,050 --> 00:11:46,650
the hash function over the data you get

00:11:44,250 --> 00:11:48,000
a number the describes describes it and

00:11:46,650 --> 00:11:48,410
then you use that to determine where it

00:11:48,000 --> 00:11:50,850
should be

00:11:48,410 --> 00:11:52,530
the problem with that is that if the

00:11:50,850 --> 00:11:54,260
cluster changing so you add or server

00:11:52,530 --> 00:11:56,430
remove a server

00:11:54,260 --> 00:11:58,020
everything we kind of shuffle around so

00:11:56,430 --> 00:11:59,760
then you would have to have this you

00:11:58,020 --> 00:12:02,520
know to post the cluster and then move

00:11:59,760 --> 00:12:05,010
everything around you know to put things

00:12:02,520 --> 00:12:07,710
where they're supposed to be which would

00:12:05,010 --> 00:12:09,840
be slower and slower to be the cluster

00:12:07,710 --> 00:12:13,020
we get and the more often it would

00:12:09,840 --> 00:12:16,860
change so that we don't want so kind of

00:12:13,020 --> 00:12:19,350
the trick that saved us a kind of secret

00:12:16,860 --> 00:12:22,590
within the crush algorithm is to do a

00:12:19,350 --> 00:12:24,930
two step placement so what you do is you

00:12:22,590 --> 00:12:28,070
hash the data object into what's called

00:12:24,930 --> 00:12:32,540
a placement group and then you decide

00:12:28,070 --> 00:12:34,950
how to wear those placement groups go

00:12:32,540 --> 00:12:37,140
independently so you have kind of you

00:12:34,950 --> 00:12:40,260
hash your space of objects into

00:12:37,140 --> 00:12:44,910
placement groups and then you place

00:12:40,260 --> 00:12:46,440
those groups on to service the nice

00:12:44,910 --> 00:12:48,030
thing about this is that you can scale

00:12:46,440 --> 00:12:51,150
the number of locations for data

00:12:48,030 --> 00:12:54,600
independently of kind of the hashing so

00:12:51,150 --> 00:12:56,340
you can hash into a number of placement

00:12:54,600 --> 00:12:57,930
groups and there you can decide okay

00:12:56,340 --> 00:13:00,870
this particular group of objects should

00:12:57,930 --> 00:13:03,030
be on three servers and that means that

00:13:00,870 --> 00:13:04,740
if one server disappears it goes down

00:13:03,030 --> 00:13:07,110
the data is still around them to other

00:13:04,740 --> 00:13:09,570
servers and the replacement server for

00:13:07,110 --> 00:13:11,490
the server went down can use the

00:13:09,570 --> 00:13:13,410
algorithm to figure out where the data

00:13:11,490 --> 00:13:18,839
it's supposed to be is and asked those

00:13:13,410 --> 00:13:20,910
nodes for the data so the the storage

00:13:18,839 --> 00:13:23,550
nodes can kill them independently of any

00:13:20,910 --> 00:13:27,990
kind of external control figure out how

00:13:23,550 --> 00:13:30,360
to recover from failure you can also add

00:13:27,990 --> 00:13:33,240
and remove storage locations so when a

00:13:30,360 --> 00:13:35,640
node fails or if there's a new node you

00:13:33,240 --> 00:13:37,200
can use to say okay so the things that

00:13:35,640 --> 00:13:39,510
were on that server now have to be

00:13:37,200 --> 00:13:41,310
somewhere else and if we have a new node

00:13:39,510 --> 00:13:42,780
we can use decide okay so these things

00:13:41,310 --> 00:13:45,240
should now be on the server and we can

00:13:42,780 --> 00:13:49,040
go and ask existing places where that

00:13:45,240 --> 00:13:49,040
data is for the data it needs

00:13:49,570 --> 00:13:56,540
so sort of it sort of looks like this

00:13:53,300 --> 00:13:59,180
you hash the object into what's called

00:13:56,540 --> 00:14:01,490
the placement group idea and then you

00:13:59,180 --> 00:14:03,680
run the crush algorithm with the

00:14:01,490 --> 00:14:08,420
placement group ID and a cluster

00:14:03,680 --> 00:14:12,410
topology so that is which servers are in

00:14:08,420 --> 00:14:18,949
the cluster and the output is a list of

00:14:12,410 --> 00:14:21,440
names of locations where beta is so this

00:14:18,949 --> 00:14:24,709
is pretty cool there's there's a bit

00:14:21,440 --> 00:14:28,940
much more to it in reality so the crush

00:14:24,709 --> 00:14:30,680
map topology is actually kind of a tree

00:14:28,940 --> 00:14:35,180
that you have a lot of control over so

00:14:30,680 --> 00:14:36,860
you can mark up your nodes to say okay

00:14:35,180 --> 00:14:39,350
so these nodes are in the same data

00:14:36,860 --> 00:14:41,600
center or in the same rack and so we

00:14:39,350 --> 00:14:43,760
want to make sure that we spread the

00:14:41,600 --> 00:14:46,519
data around so let's say we have three

00:14:43,760 --> 00:14:48,260
replicas with piece of data we want to

00:14:46,519 --> 00:14:50,510
make sure that those three replicas

00:14:48,260 --> 00:14:53,750
aren't on the same rack in the same data

00:14:50,510 --> 00:14:56,000
center so that if the rack goes down or

00:14:53,750 --> 00:14:58,880
the data center goes down today they see

00:14:56,000 --> 00:15:01,670
the still available somewhere there's a

00:14:58,880 --> 00:15:03,800
lot of things like that you can also so

00:15:01,670 --> 00:15:04,220
it also keeps track of what kind of

00:15:03,800 --> 00:15:08,600
storage

00:15:04,220 --> 00:15:12,319
each OSD has if it's a SSD or HDD drive

00:15:08,600 --> 00:15:14,449
and it then knows if it's fast to access

00:15:12,319 --> 00:15:17,510
a slow to access and it can make sure

00:15:14,449 --> 00:15:20,000
that the kind of the primary location

00:15:17,510 --> 00:15:21,500
for a piece of data is the SSD one so

00:15:20,000 --> 00:15:25,610
you can say okay so every data should be

00:15:21,500 --> 00:15:27,769
on one SSD drive and two HD drives and

00:15:25,610 --> 00:15:30,980
the HD drives work is kind of backups

00:15:27,769 --> 00:15:33,589
for the SSD drive and there's a lot of

00:15:30,980 --> 00:15:37,190
things you can do like that since it's

00:15:33,589 --> 00:15:39,139
pretty cool in other way yeah I also

00:15:37,190 --> 00:15:42,889
wanted to show the dashboard so Ceph

00:15:39,139 --> 00:15:44,540
comes with this user-friendly dashboard

00:15:42,889 --> 00:15:47,120
it has integration for Prometheus

00:15:44,540 --> 00:15:51,319
monitoring so you have a graph on the

00:15:47,120 --> 00:15:53,569
dashboard kind of built into the chef

00:15:51,319 --> 00:15:55,519
dashboard you can control a lot of

00:15:53,569 --> 00:15:58,550
things that the cluster does directly

00:15:55,519 --> 00:16:01,010
from the dashboard and some of the work

00:15:58,550 --> 00:16:02,910
that we're doing for kind of next

00:16:01,010 --> 00:16:06,240
release

00:16:02,910 --> 00:16:08,040
SEF is to provide more of that

00:16:06,240 --> 00:16:10,020
functionality within the dashboard even

00:16:08,040 --> 00:16:12,930
in the case of running on Cuban a DS so

00:16:10,020 --> 00:16:14,070
you can control a lot of the cluster

00:16:12,930 --> 00:16:16,250
functionality directly from the

00:16:14,070 --> 00:16:16,250
dashboard

00:16:17,810 --> 00:16:25,579
so now kubernetes yeah if you don't know

00:16:22,879 --> 00:16:28,999
what kubernetes is this talk is from

00:16:25,579 --> 00:16:31,310
kind of healthy damage but briefly

00:16:28,999 --> 00:16:35,420
kubernetes is container orchestration

00:16:31,310 --> 00:16:37,490
platform so it basically you take a

00:16:35,420 --> 00:16:39,350
bunch of containers and you give them to

00:16:37,490 --> 00:16:41,240
community so you can take a description

00:16:39,350 --> 00:16:42,559
of the containers that you want running

00:16:41,240 --> 00:16:43,870
in your cluster you give it to

00:16:42,559 --> 00:16:46,579
communities and communities decides

00:16:43,870 --> 00:16:48,470
where to spin up and where to use in

00:16:46,579 --> 00:16:49,970
announcer this week and kubernetes

00:16:48,470 --> 00:16:53,930
automatically handles things like

00:16:49,970 --> 00:16:55,309
employment of containers scaling

00:16:53,930 --> 00:16:57,439
continuous up and down so you can say

00:16:55,309 --> 00:17:00,170
okay I want ten replicas of this

00:16:57,439 --> 00:17:01,930
container and kubernetes handles storing

00:17:00,170 --> 00:17:06,890
them on different nodes and so on and

00:17:01,930 --> 00:17:08,360
general kind of management the one key

00:17:06,890 --> 00:17:10,309
thing about kubernetes is that the

00:17:08,360 --> 00:17:15,559
interface to interact with kubernetes

00:17:10,309 --> 00:17:17,959
is declarative so you define you the way

00:17:15,559 --> 00:17:22,669
you want your cluster to look in a bunch

00:17:17,959 --> 00:17:25,010
of yamo documents and accumulators takes

00:17:22,669 --> 00:17:26,360
these and then figure out okay so this

00:17:25,010 --> 00:17:28,490
is the current state of the cluster

00:17:26,360 --> 00:17:30,559
here's what it should look like these

00:17:28,490 --> 00:17:32,390
are the changes I need to do to you to

00:17:30,559 --> 00:17:33,860
make sure that it becomes what it's

00:17:32,390 --> 00:17:35,809
supposed to be

00:17:33,860 --> 00:17:39,169
hello things like yeah like load

00:17:35,809 --> 00:17:42,460
balancing rollouts so you can do gradual

00:17:39,169 --> 00:17:45,860
rollout of new new versions of

00:17:42,460 --> 00:17:47,659
containers rollback so if you're

00:17:45,860 --> 00:17:50,480
encountering problems you can roll back

00:17:47,659 --> 00:17:53,690
to a previous solution and it's

00:17:50,480 --> 00:17:56,840
self-healing so in the case of problems

00:17:53,690 --> 00:18:01,840
or issues kubernetes takes care of kind

00:17:56,840 --> 00:18:05,000
of figuring out how to solve the issues

00:18:01,840 --> 00:18:06,620
it also handles things like secret

00:18:05,000 --> 00:18:09,370
management and configuration management

00:18:06,620 --> 00:18:09,370
things like that

00:18:09,570 --> 00:18:16,309
so kubernetes comes with a lot of

00:18:11,809 --> 00:18:20,279
concepts that you kind of had to learn

00:18:16,309 --> 00:18:24,779
if you read the original paper

00:18:20,279 --> 00:18:28,200
describing kubernetes it's based on the

00:18:24,779 --> 00:18:30,600
google borg project so it's a project

00:18:28,200 --> 00:18:33,830
internal to Google that he used to

00:18:30,600 --> 00:18:38,340
manage all their deployments internally

00:18:33,830 --> 00:18:43,259
and it's kind of meant to be an object

00:18:38,340 --> 00:18:45,539
oriented model for infrastructure and so

00:18:43,259 --> 00:18:47,729
what they do is they come they've come

00:18:45,539 --> 00:18:50,509
up with all these concepts that kind of

00:18:47,729 --> 00:18:54,960
abstractly describes infrastructure and

00:18:50,509 --> 00:18:59,190
they're yeah I don't know they're meant

00:18:54,960 --> 00:19:02,159
to be easy to understand I think but the

00:18:59,190 --> 00:19:05,549
really unique to kubernetes so you

00:19:02,159 --> 00:19:08,759
basically just have to learn them yes I

00:19:05,549 --> 00:19:10,799
don't know any easy way to get over this

00:19:08,759 --> 00:19:12,029
other than to actually understand

00:19:10,799 --> 00:19:14,179
unfortunately there's not too many of

00:19:12,029 --> 00:19:18,059
them anyone who's worked with OpenStack

00:19:14,179 --> 00:19:19,799
know the ocean stack has a bunch of code

00:19:18,059 --> 00:19:22,409
names for everything and yeah you just

00:19:19,799 --> 00:19:25,320
have to learn what Neutron and Swift and

00:19:22,409 --> 00:19:29,279
all these things are it's not quite that

00:19:25,320 --> 00:19:33,059
bad I feel with communities but anyway a

00:19:29,279 --> 00:19:35,519
pod is the basic execution unit of an

00:19:33,059 --> 00:19:37,820
app so it's it's an application and a

00:19:35,519 --> 00:19:41,609
pod consists of one or more containers

00:19:37,820 --> 00:19:45,210
and any kind of resources needed for

00:19:41,609 --> 00:19:48,570
that container so it's let's say you

00:19:45,210 --> 00:19:50,999
have a container that runs nginx for

00:19:48,570 --> 00:19:53,190
example you might have some sidecar

00:19:50,999 --> 00:19:54,779
containers in the pod together with

00:19:53,190 --> 00:19:56,700
nginx that provides things like

00:19:54,779 --> 00:20:00,450
monitoring so you made maybe a node

00:19:56,700 --> 00:20:03,869
exporter for Prometheus and then you

00:20:00,450 --> 00:20:06,720
also have things like volume attachments

00:20:03,869 --> 00:20:07,259
or matched Network attachments things

00:20:06,720 --> 00:20:09,149
like that

00:20:07,259 --> 00:20:13,470
they tell you how to run this

00:20:09,149 --> 00:20:15,809
application in the cluster a service is

00:20:13,470 --> 00:20:17,190
the interface to accessing the

00:20:15,809 --> 00:20:20,159
application from the outside so it's

00:20:17,190 --> 00:20:21,360
basically mapping a DNS name to a set of

00:20:20,159 --> 00:20:25,049
pods

00:20:21,360 --> 00:20:28,019
and then handling load balancing for the

00:20:25,049 --> 00:20:30,929
pod so you use the service to access

00:20:28,019 --> 00:20:34,169
your application and you might you don't

00:20:30,929 --> 00:20:35,940
really know how that access is handled

00:20:34,169 --> 00:20:38,460
in the back end and accumulators takes

00:20:35,940 --> 00:20:40,379
care of its kind of spinning up and

00:20:38,460 --> 00:20:44,399
spinning down thoughts to provide the

00:20:40,379 --> 00:20:45,809
service that you need kubernetes also

00:20:44,399 --> 00:20:48,029
has a corset called name space so

00:20:45,809 --> 00:20:50,369
everything in kubernetes is organized

00:20:48,029 --> 00:20:54,330
into namespaces so you can kind of keep

00:20:50,369 --> 00:20:57,679
things separated this so everything that

00:20:54,330 --> 00:21:01,950
rook does within kubernetes is within

00:20:57,679 --> 00:21:04,019
one specific namespace that's the reason

00:21:01,950 --> 00:21:06,960
why I mention that and then the final

00:21:04,019 --> 00:21:09,989
thing and also there's some call volumes

00:21:06,960 --> 00:21:11,730
which is storage in communities but the

00:21:09,989 --> 00:21:13,559
final thing I want to mention is the CR

00:21:11,730 --> 00:21:17,489
DS so this is the custom resource

00:21:13,559 --> 00:21:19,200
definitions and this is what allows you

00:21:17,489 --> 00:21:22,859
to extend the functionality of

00:21:19,200 --> 00:21:26,309
communities and this is how Luke also

00:21:22,859 --> 00:21:32,970
extends communities to provide storage

00:21:26,309 --> 00:21:35,179
and yeah that's pretty much it

00:21:32,970 --> 00:21:39,690
yes oh yeah forgot to mention

00:21:35,179 --> 00:21:42,570
controllers as well in there there's a

00:21:39,690 --> 00:21:45,239
lot of things so controllers are things

00:21:42,570 --> 00:21:47,309
that create and manage pods you could

00:21:45,239 --> 00:21:49,710
say so there are these things called

00:21:47,309 --> 00:21:52,230
daemon sets and replica sets but

00:21:49,710 --> 00:21:55,919
basically these are things used by

00:21:52,230 --> 00:21:59,460
controllers to create and manage kind of

00:21:55,919 --> 00:22:02,940
sets of pods so you have like multiple

00:21:59,460 --> 00:22:07,980
applications that together form a

00:22:02,940 --> 00:22:10,420
service for example yeah I don't know if

00:22:07,980 --> 00:22:13,780
that makes sense

00:22:10,420 --> 00:22:18,250
all right so let's talk about storage

00:22:13,780 --> 00:22:23,770
specifically in kubernetes storage in

00:22:18,250 --> 00:22:28,180
communities is kind of evolving story I

00:22:23,770 --> 00:22:30,430
would say originally the idea of the

00:22:28,180 --> 00:22:32,980
purpose for kubernetes was to handle

00:22:30,430 --> 00:22:34,120
stateless services so containers that

00:22:32,980 --> 00:22:36,730
spin-up or spin-down

00:22:34,120 --> 00:22:40,270
that don't have any internal state but

00:22:36,730 --> 00:22:42,730
to rely on some external storage or

00:22:40,270 --> 00:22:46,450
database to store their the state they

00:22:42,730 --> 00:22:48,750
need to do the work they do and this is

00:22:46,450 --> 00:22:52,300
as I said modeled on Google's Borg and

00:22:48,750 --> 00:22:54,520
of course at Google the storage or the

00:22:52,300 --> 00:22:57,190
database is provided by Google's

00:22:54,520 --> 00:23:01,960
proprietary technology and things like

00:22:57,190 --> 00:23:04,030
BigTable and spanner so storage was

00:23:01,960 --> 00:23:08,050
never really part of the design of

00:23:04,030 --> 00:23:11,620
communities and so as people outside of

00:23:08,050 --> 00:23:13,390
Google had need of storage these kind of

00:23:11,620 --> 00:23:16,210
interfaces have gradually been added to

00:23:13,390 --> 00:23:17,950
coolants but it's still kind of a yeah

00:23:16,210 --> 00:23:20,380
it's still an evolving story it's not

00:23:17,950 --> 00:23:21,850
quite there yet so it started out with

00:23:20,380 --> 00:23:25,330
having something called volume plugins

00:23:21,850 --> 00:23:28,420
so kubernetes has a bunch of plugins

00:23:25,330 --> 00:23:31,690
that provides storage for different

00:23:28,420 --> 00:23:36,010
things like native storage on various

00:23:31,690 --> 00:23:39,700
clouds local storage that's on nodes and

00:23:36,010 --> 00:23:42,400
so on and eventually people figured out

00:23:39,700 --> 00:23:44,460
that they wanted some way to add or

00:23:42,400 --> 00:23:47,050
remove storage in a more dynamic way

00:23:44,460 --> 00:23:49,510
instead of having to have all these

00:23:47,050 --> 00:23:51,310
different kind of plugins and so the

00:23:49,510 --> 00:23:53,010
first thing a first attempt to solve

00:23:51,310 --> 00:23:56,530
this was something called flex volumes

00:23:53,010 --> 00:24:00,310
and this is basically a scriptable

00:23:56,530 --> 00:24:03,340
volume and so you can kind of in a

00:24:00,310 --> 00:24:09,790
controller define what what the volume

00:24:03,340 --> 00:24:12,580
actually does this is used by Rooke in

00:24:09,790 --> 00:24:15,490
older versions and yeah it still still

00:24:12,580 --> 00:24:17,200
used well the next phase of this was

00:24:15,490 --> 00:24:18,970
something called CSI or the container

00:24:17,200 --> 00:24:20,920
storage interface and this is kind of

00:24:18,970 --> 00:24:22,360
the current state of the art in

00:24:20,920 --> 00:24:26,650
communities

00:24:22,360 --> 00:24:30,490
and this is calibre an abstract

00:24:26,650 --> 00:24:32,500
interface to storage and so it makes

00:24:30,490 --> 00:24:35,910
things a bit more flexible a bit more

00:24:32,500 --> 00:24:39,040
user friendly and this is also what

00:24:35,910 --> 00:24:44,830
Brooke uses to provide storage for acun

00:24:39,040 --> 00:24:47,410
for containers in in communities there's

00:24:44,830 --> 00:24:50,310
a fourth thing a thing called the load

00:24:47,410 --> 00:24:54,940
load local volume static provisioner and

00:24:50,310 --> 00:24:57,910
this was added in kubernetes 1.14 and it

00:24:54,940 --> 00:24:59,680
looks likely that look and other storage

00:24:57,910 --> 00:25:04,560
solutions are gonna move to kind of a

00:24:59,680 --> 00:25:07,660
model that involves using the LVS where

00:25:04,560 --> 00:25:12,930
kubernetes kind of on its own can figure

00:25:07,660 --> 00:25:15,970
out what storage or what device is like

00:25:12,930 --> 00:25:19,360
volume devices all right are available

00:25:15,970 --> 00:25:22,090
and then Brooke provides kind of the CSI

00:25:19,360 --> 00:25:24,100
interface on top of that I yeah I'm not

00:25:22,090 --> 00:25:25,750
a hundred percent sure about how this

00:25:24,100 --> 00:25:28,020
works but this seems to be where things

00:25:25,750 --> 00:25:28,020
are going

00:25:29,110 --> 00:25:34,139
if you want to know more about

00:25:30,489 --> 00:25:37,299
kubernetes then what i've told you now

00:25:34,139 --> 00:25:40,389
yeah I would recommend kind of any talk

00:25:37,299 --> 00:25:42,249
by Kelsey Hightower on YouTube he's he's

00:25:40,389 --> 00:25:43,149
really good he has a bunch of talks

00:25:42,249 --> 00:25:46,179
they're all good they're all about

00:25:43,149 --> 00:25:48,369
kubernetes I wanted to mention this one

00:25:46,179 --> 00:25:51,730
in particular so he has this talk called

00:25:48,369 --> 00:25:53,049
kubernetes for developers and really the

00:25:51,730 --> 00:25:56,049
reason why I want to mention it is

00:25:53,049 --> 00:25:58,029
because after his stomachs presentation

00:25:56,049 --> 00:26:01,809
he starts taking questions the first

00:25:58,029 --> 00:26:04,210
question is is he gets is what what

00:26:01,809 --> 00:26:05,919
things are committed is not good at like

00:26:04,210 --> 00:26:08,889
what should you not use kubernetes form

00:26:05,919 --> 00:26:10,749
and he says that kubernetes was signed

00:26:08,889 --> 00:26:12,249
for stateless services so really you

00:26:10,749 --> 00:26:14,409
shouldn't use it for anything stateful

00:26:12,249 --> 00:26:17,919
and you shouldn't run your database in

00:26:14,409 --> 00:26:22,090
kubernetes and I think that's actually

00:26:17,919 --> 00:26:24,309
quite true in case of databases you

00:26:22,090 --> 00:26:25,869
really should have your database outside

00:26:24,309 --> 00:26:29,889
of cabinets given it's just isn't very

00:26:25,869 --> 00:26:33,100
good at dealing with with state but I

00:26:29,889 --> 00:26:34,809
think in the case of general storage so

00:26:33,100 --> 00:26:37,509
where where your application use needs a

00:26:34,809 --> 00:26:40,600
hard driver a file system to you to

00:26:37,509 --> 00:26:43,720
write to you the interface that rook

00:26:40,600 --> 00:26:46,059
provides for storage inconvenience is

00:26:43,720 --> 00:26:47,559
actually pretty good but uh but yeah

00:26:46,059 --> 00:26:49,869
it's it's definitely something to keep

00:26:47,559 --> 00:26:52,269
in mind when thinking about storage and

00:26:49,869 --> 00:26:54,489
communities is that kubernetes itself

00:26:52,269 --> 00:26:56,529
was designed for stateless services and

00:26:54,489 --> 00:27:00,029
there's there's a lot in there that kind

00:26:56,529 --> 00:27:04,989
of reveals that that's the case and so

00:27:00,029 --> 00:27:08,889
yeah take that su as you wish I'm going

00:27:04,989 --> 00:27:12,009
forward but yeah so what are the

00:27:08,889 --> 00:27:12,519
challenges or I guess what's the

00:27:12,009 --> 00:27:14,289
alternative

00:27:12,519 --> 00:27:15,580
so yeah if you say okay so communis was

00:27:14,289 --> 00:27:17,559
designed for stateless services so

00:27:15,580 --> 00:27:19,720
what's the alternative then if we don't

00:27:17,559 --> 00:27:22,179
do our storage through kubernetes but

00:27:19,720 --> 00:27:25,749
we're running within kubernetes what can

00:27:22,179 --> 00:27:28,419
we do so one answer might be okay so we

00:27:25,749 --> 00:27:32,200
used use whatever storage our cloud

00:27:28,419 --> 00:27:36,009
provider provides there is some issues

00:27:32,200 --> 00:27:38,480
that though one big one is that now

00:27:36,009 --> 00:27:40,609
you're locked into

00:27:38,480 --> 00:27:41,989
particular cloud provider so if you want

00:27:40,609 --> 00:27:44,269
to move to another cloud provider they

00:27:41,989 --> 00:27:47,330
have a different storage solution that

00:27:44,269 --> 00:27:50,659
they provide if you want to move off the

00:27:47,330 --> 00:27:53,629
public cloud and move into your own bare

00:27:50,659 --> 00:27:54,950
metal communities cluster instead now

00:27:53,629 --> 00:27:58,309
you have to figure out how to provide

00:27:54,950 --> 00:28:01,970
storage that you previously got through

00:27:58,309 --> 00:28:04,369
the ban the cloud vendor so it kind of

00:28:01,970 --> 00:28:05,960
limits you both like it locks you into a

00:28:04,369 --> 00:28:10,429
particular vendor it limits your

00:28:05,960 --> 00:28:15,139
portability it limits the connectivity

00:28:10,429 --> 00:28:16,580
or well I guess having storage outside

00:28:15,139 --> 00:28:18,769
the cabinets means that now you have to

00:28:16,580 --> 00:28:20,210
deal with it in a different way so you

00:28:18,769 --> 00:28:22,730
have to deal with the connectivity

00:28:20,210 --> 00:28:25,999
between kubernetes and the storage

00:28:22,730 --> 00:28:28,009
cluster and so there's this deployment

00:28:25,999 --> 00:28:30,049
burden and there's questions lucky so

00:28:28,009 --> 00:28:32,210
who is responsible for the storage who

00:28:30,049 --> 00:28:34,850
is responsible for the kubernetes

00:28:32,210 --> 00:28:37,340
cluster this there's a lot of reasons

00:28:34,850 --> 00:28:40,399
why it might make sense to say okay no I

00:28:37,340 --> 00:28:43,879
I do want to manage all my or everything

00:28:40,399 --> 00:28:48,019
for my application in one place so to

00:28:43,879 --> 00:28:52,369
speak and really this is where comes in

00:28:48,019 --> 00:28:55,279
so rook is a cloud native storage

00:28:52,369 --> 00:28:57,350
Orchestrator and basically what that

00:28:55,279 --> 00:28:59,330
means is that rook extends kubernetes

00:28:57,350 --> 00:29:01,999
with a set of new primitives for storage

00:28:59,330 --> 00:29:04,999
and it configures and manage the storage

00:29:01,999 --> 00:29:11,389
providers in kubernetes and expose the

00:29:04,999 --> 00:29:14,330
storage to pods so it provides a general

00:29:11,389 --> 00:29:16,279
storage interface so yeah so its uses to

00:29:14,330 --> 00:29:19,519
the CSI or the flex volume interfaces in

00:29:16,279 --> 00:29:23,809
and criminalist to provide storage to

00:29:19,519 --> 00:29:28,850
pods and it does this using a variety of

00:29:23,809 --> 00:29:33,409
different storage implementations so the

00:29:28,850 --> 00:29:36,769
main ones that are in rook are SEF and

00:29:33,409 --> 00:29:42,820
HDFS so in the current version which is

00:29:36,769 --> 00:29:45,529
rook 1.2 SEF NH FS are considered stable

00:29:42,820 --> 00:29:48,669
but there are also implementations for a

00:29:45,529 --> 00:29:50,830
number of other storage solutions

00:29:48,669 --> 00:29:54,549
and but they're all in various states

00:29:50,830 --> 00:29:57,429
states of beta or alpha quality so to

00:29:54,549 --> 00:29:58,960
speak the only one I'm gonna talk about

00:29:57,429 --> 00:30:05,590
itself because that's the one that I

00:29:58,960 --> 00:30:08,799
work with Brooke provides automation for

00:30:05,590 --> 00:30:09,690
a number of different aspects of storage

00:30:08,799 --> 00:30:14,309
management

00:30:09,690 --> 00:30:17,440
it handles deployment configuration

00:30:14,309 --> 00:30:20,350
bootstrapping provisioning scaling

00:30:17,440 --> 00:30:24,999
upgrading migration discuss recovery

00:30:20,350 --> 00:30:27,850
monitoring research management and it

00:30:24,999 --> 00:30:32,710
uses whatever facilities are provided by

00:30:27,850 --> 00:30:36,129
the container manager like like yeah

00:30:32,710 --> 00:30:40,029
like communities to do what it needs to

00:30:36,129 --> 00:30:42,130
do but the idea is to make storage

00:30:40,029 --> 00:30:46,419
management

00:30:42,130 --> 00:30:48,700
simple and painless as possible the main

00:30:46,419 --> 00:30:52,710
component of rook that does all this is

00:30:48,700 --> 00:30:55,690
called an operator so the operator is

00:30:52,710 --> 00:30:58,630
basically a pot which bootstraps and

00:30:55,690 --> 00:31:02,080
monitors the storage cluster for you it

00:30:58,630 --> 00:31:07,679
manages all the Ceph demons like the

00:31:02,080 --> 00:31:10,240
Mons and OSTs it creates all the custom

00:31:07,679 --> 00:31:13,570
resource definitions they need for

00:31:10,240 --> 00:31:17,830
things lot like object stores file

00:31:13,570 --> 00:31:22,750
systems block devices and it creates

00:31:17,830 --> 00:31:24,820
rook agents so the other part of rook is

00:31:22,750 --> 00:31:28,750
these agents that run on all the nodes

00:31:24,820 --> 00:31:30,220
and handle any kind of physical storage

00:31:28,750 --> 00:31:33,010
needs the answer

00:31:30,220 --> 00:31:40,030
formats and mounts volumes and it

00:31:33,010 --> 00:31:44,260
touches network storage the way in more

00:31:40,030 --> 00:31:45,730
detail how volumes work in in kubernetes

00:31:44,260 --> 00:31:47,559
is that you have something called a

00:31:45,730 --> 00:31:49,659
persistent volume so this is a volume

00:31:47,559 --> 00:31:54,460
that persists beyond the lifetime of any

00:31:49,659 --> 00:31:56,110
given pod and it it kind of maps to an

00:31:54,460 --> 00:31:57,970
actual slice of storage so you would say

00:31:56,110 --> 00:32:01,090
okay so I need a persistent volume of

00:31:57,970 --> 00:32:04,510
one gigabyte or like I have a persistent

00:32:01,090 --> 00:32:06,429
volume 1 gigabyte persistent volumes can

00:32:04,510 --> 00:32:08,830
be either manually provisioned by an

00:32:06,429 --> 00:32:12,130
administrator of communities through

00:32:08,830 --> 00:32:14,169
them you define them in their llamo

00:32:12,130 --> 00:32:15,880
files sort of week or it can be

00:32:14,169 --> 00:32:20,590
dynamically provisioned by storage

00:32:15,880 --> 00:32:23,830
classes like those provided by rook the

00:32:20,590 --> 00:32:25,210
way you map those into pods is through

00:32:23,830 --> 00:32:29,559
something called persistent volume

00:32:25,210 --> 00:32:32,470
claims or PVCs so the pod will in its

00:32:29,559 --> 00:32:33,909
definition have a request for storage

00:32:32,470 --> 00:32:37,600
you will say ok so this part needs

00:32:33,909 --> 00:32:39,850
persistent storage one gigabyte for

00:32:37,600 --> 00:32:42,990
example so yeah so this application

00:32:39,850 --> 00:32:46,090
needs when you buy storage to run and

00:32:42,990 --> 00:32:49,090
kubernetes takes care of mapping those

00:32:46,090 --> 00:32:51,370
claims to the actual persistent volumes

00:32:49,090 --> 00:32:54,880
to exist you can

00:32:51,370 --> 00:32:57,570
Qwest based on size access needs so if

00:32:54,880 --> 00:33:02,890
you read need really rewrite write only

00:32:57,570 --> 00:33:04,690
things like that and then finally the

00:33:02,890 --> 00:33:06,850
storage classes defines the types of

00:33:04,690 --> 00:33:08,800
stories that are available and this is

00:33:06,850 --> 00:33:13,950
the story classes what enables the

00:33:08,800 --> 00:33:16,559
dynamic storage provisioning and yeah so

00:33:13,950 --> 00:33:21,010
that's that's how that all works and

00:33:16,559 --> 00:33:23,860
this is kind of an an overview of how it

00:33:21,010 --> 00:33:26,050
all comes together so you have on the

00:33:23,860 --> 00:33:28,480
left side you have kubernetes and the

00:33:26,050 --> 00:33:30,640
kubernetes api s-- and on the right side

00:33:28,480 --> 00:33:33,480
you have the things provided by rogue so

00:33:30,640 --> 00:33:36,970
you have the rogue operator you have

00:33:33,480 --> 00:33:41,530
clients that accessed the safe storage

00:33:36,970 --> 00:33:43,270
and you have the daemons the makeup SEF

00:33:41,530 --> 00:33:45,000
and they're all running within

00:33:43,270 --> 00:33:48,100
kubernetes

00:33:45,000 --> 00:33:53,679
so this is kind of how it all comes

00:33:48,100 --> 00:33:57,460
together there is a there are a few

00:33:53,679 --> 00:33:59,740
different use cases for hook the first

00:33:57,460 --> 00:34:02,520
one would be to just have a dedicated

00:33:59,740 --> 00:34:05,160
kubernetes cluster for running SEF so

00:34:02,520 --> 00:34:07,929
configuring and managing self can be

00:34:05,160 --> 00:34:11,889
complicated I mean it's a it's a full-on

00:34:07,929 --> 00:34:14,800
cluster of of demons that need to be

00:34:11,889 --> 00:34:16,870
administered and if you're if you're

00:34:14,800 --> 00:34:18,129
already a kubernetes administrator in

00:34:16,870 --> 00:34:20,200
your company you're familiar and

00:34:18,129 --> 00:34:22,379
comfortable with that and if you want to

00:34:20,200 --> 00:34:24,850
have a safe cluster maybe not even for

00:34:22,379 --> 00:34:27,490
workloads that are running in inside the

00:34:24,850 --> 00:34:29,409
kubernetes or maybe you have an existing

00:34:27,490 --> 00:34:32,710
cobra this application cluster but you

00:34:29,409 --> 00:34:34,899
don't want to mix in the storage into

00:34:32,710 --> 00:34:37,179
the same cluster you can have a

00:34:34,899 --> 00:34:39,490
dedicated kubernetes cluster that runs

00:34:37,179 --> 00:34:44,320
safe and then we can serve other

00:34:39,490 --> 00:34:48,070
clusters with storage this isn't too

00:34:44,320 --> 00:34:50,740
common I think if you asked Kelsey

00:34:48,070 --> 00:34:53,110
Hightower I don't want to speak for him

00:34:50,740 --> 00:34:56,080
but it's the impression I got if you ask

00:34:53,110 --> 00:34:57,430
him he would say that this is probably

00:34:56,080 --> 00:34:59,470
what you wanted you you want to separate

00:34:57,430 --> 00:35:03,520
your storage and your stateless

00:34:59,470 --> 00:35:05,890
applications but in my experience and

00:35:03,520 --> 00:35:09,700
in our experience we don't see this too

00:35:05,890 --> 00:35:12,180
much more commonly what you see is a

00:35:09,700 --> 00:35:16,500
shared cluster where you have one

00:35:12,180 --> 00:35:19,180
kubernetes cluster and maybe you have a

00:35:16,500 --> 00:35:20,770
cluster where you petition the nodes so

00:35:19,180 --> 00:35:24,010
that some nodes in the cluster are

00:35:20,770 --> 00:35:25,840
dedicated to storage using SEF and some

00:35:24,010 --> 00:35:28,119
nodes are dedicated to running

00:35:25,840 --> 00:35:30,250
applications and the way you would do

00:35:28,119 --> 00:35:33,760
this labeling and the different nodes

00:35:30,250 --> 00:35:36,010
and making sure that ruk only uses some

00:35:33,760 --> 00:35:39,760
of the nodes and your applications only

00:35:36,010 --> 00:35:41,800
run on other nodes there is also the

00:35:39,760 --> 00:35:44,880
option of just running one cluster and

00:35:41,800 --> 00:35:49,690
letting kubernetes taking care of

00:35:44,880 --> 00:35:51,430
scheduling things on there and I

00:35:49,690 --> 00:35:55,540
this is kind of the most common use case

00:35:51,430 --> 00:35:58,030
that we see so far but it it is also I

00:35:55,540 --> 00:36:00,880
don't know personally I think that it's

00:35:58,030 --> 00:36:04,000
a little bit scary because yeah you're

00:36:00,880 --> 00:36:06,460
mixing your storage which is very

00:36:04,000 --> 00:36:08,920
critical in the sense that if you lose

00:36:06,460 --> 00:36:10,960
your storage you lose your your data and

00:36:08,920 --> 00:36:13,600
then you mixing it with applications

00:36:10,960 --> 00:36:15,070
that may be in let's say in the case of

00:36:13,600 --> 00:36:17,770
you having you're administering a

00:36:15,070 --> 00:36:21,100
cluster that runs workloads that come

00:36:17,770 --> 00:36:24,370
from developers within your organization

00:36:21,100 --> 00:36:26,920
or ever maybe all of them aren't perfect

00:36:24,370 --> 00:36:29,260
maybe there's some issues sometimes and

00:36:26,920 --> 00:36:31,750
now you're kind of risking things a bit

00:36:29,260 --> 00:36:34,840
but if by mixing these things on the

00:36:31,750 --> 00:36:36,100
same notes I don't know but yeah this is

00:36:34,840 --> 00:36:40,510
the most common solution that we're

00:36:36,100 --> 00:36:43,030
seeing there's one final use case that

00:36:40,510 --> 00:36:45,280
rook can handle and that's the case

00:36:43,030 --> 00:36:47,170
where you already have a safe cluster or

00:36:45,280 --> 00:36:49,380
if you're if you really want to run your

00:36:47,170 --> 00:36:53,950
safe cluster and minister it's yourself

00:36:49,380 --> 00:36:56,020
you can use rook to provide an interface

00:36:53,950 --> 00:36:58,630
for for yourself cluster with the end

00:36:56,020 --> 00:37:03,280
kubernetes so you can access the storage

00:36:58,630 --> 00:37:05,920
provided by the the safe cluster through

00:37:03,280 --> 00:37:08,350
your kubernetes applications using rook

00:37:05,920 --> 00:37:11,670
even though the surf glossary self isn't

00:37:08,350 --> 00:37:16,890
managed by rook and this was added in

00:37:11,670 --> 00:37:16,890
rook 1.1 so it's relatively recent

00:37:18,160 --> 00:37:23,950
alright so in order to try this out so

00:37:22,390 --> 00:37:25,780
if you want to try rock

00:37:23,950 --> 00:37:28,000
what you need is basically you need a

00:37:25,780 --> 00:37:31,809
convenience cluster you should be

00:37:28,000 --> 00:37:35,170
running version 1.12 when you are it

00:37:31,809 --> 00:37:38,710
might even be 1.13 a newer with the

00:37:35,170 --> 00:37:40,539
latest releases I promise you what they

00:37:38,710 --> 00:37:42,819
do that slide

00:37:40,539 --> 00:37:45,579
and you need something of the following

00:37:42,819 --> 00:37:49,299
so you need some devices on your nodes

00:37:45,579 --> 00:37:51,880
that run kubernetes the has storage but

00:37:49,299 --> 00:37:53,740
there aren't uh Tischendorf don't have

00:37:51,880 --> 00:37:55,150
filesystem on them or you can have a

00:37:53,740 --> 00:37:56,740
bunch of roll partitions with a file

00:37:55,150 --> 00:38:02,130
system on them

00:37:56,740 --> 00:38:02,130
or you can have other kinds of

00:38:02,789 --> 00:38:09,460
persistent volumes within communities to

00:38:06,430 --> 00:38:12,839
provide block storage so the storage

00:38:09,460 --> 00:38:15,520
class of these pivots are block mode

00:38:12,839 --> 00:38:19,359
that's that's what rooking used to

00:38:15,520 --> 00:38:22,510
provide this thing so i'm gonna run a

00:38:19,359 --> 00:38:24,579
little animation just to show how easy

00:38:22,510 --> 00:38:28,779
it is to try this if you already have a

00:38:24,579 --> 00:38:31,839
criminal's cluster this yeah I know it's

00:38:28,779 --> 00:38:36,460
mellow it's not a small prerequisite but

00:38:31,839 --> 00:38:38,589
anyway so all you have to do is clone

00:38:36,460 --> 00:38:40,869
the got the git repo for Brooke and

00:38:38,589 --> 00:38:42,880
within the git repo there is a bunch of

00:38:40,869 --> 00:38:45,880
example configurations provided so you

00:38:42,880 --> 00:38:47,559
can go to cluster examples given NSF and

00:38:45,880 --> 00:38:50,260
within there there are a bunch of llamo

00:38:47,559 --> 00:38:52,660
files and so the first of these are

00:38:50,260 --> 00:38:54,069
pretty straightforward you have a common

00:38:52,660 --> 00:38:56,799
dilemma which she sees the bash of

00:38:54,069 --> 00:39:00,309
common functionality used by Rick you

00:38:56,799 --> 00:39:03,849
then run operator demo which deploys the

00:39:00,309 --> 00:39:05,859
rook operator and then you run cluster

00:39:03,849 --> 00:39:09,279
lady EMA which tells the operator what

00:39:05,859 --> 00:39:11,799
kind of safe class do you want and then

00:39:09,279 --> 00:39:16,029
it doesn't spin up quite this quickly

00:39:11,799 --> 00:39:18,549
but in real life but yeah then you can

00:39:16,029 --> 00:39:19,809
look at your new I created the cluster

00:39:18,549 --> 00:39:21,120
and hopefully everything is up and

00:39:19,809 --> 00:39:28,470
running

00:39:21,120 --> 00:39:31,140
so it really is that simple so the

00:39:28,470 --> 00:39:34,320
comment at yellow just creates the basic

00:39:31,140 --> 00:39:35,850
resources used by rook the only reason

00:39:34,320 --> 00:39:37,770
you would need to edit this is still if

00:39:35,850 --> 00:39:39,720
you want to deploy rook in a different

00:39:37,770 --> 00:39:42,420
name space by default it deploys into a

00:39:39,720 --> 00:39:45,480
nice piece called rooks F let's say if

00:39:42,420 --> 00:39:46,980
you had multiple rook instances within

00:39:45,480 --> 00:39:49,980
the same kubernetes cluster you might

00:39:46,980 --> 00:39:52,670
want to rename this but really I don't

00:39:49,980 --> 00:39:55,440
think it's too common to have to do this

00:39:52,670 --> 00:39:59,400
the next file that you want to look at

00:39:55,440 --> 00:40:01,200
is the operator at the mo in this file

00:39:59,400 --> 00:40:03,900
you can change some options for the

00:40:01,200 --> 00:40:06,720
operator things like the log level so

00:40:03,900 --> 00:40:08,670
how much it logs varies feature flags so

00:40:06,720 --> 00:40:12,570
you can turn on and off things like this

00:40:08,670 --> 00:40:17,340
ffs support yeah support for flex

00:40:12,570 --> 00:40:19,950
volumes or CSI things like this you can

00:40:17,340 --> 00:40:22,740
also instead of using these llaman files

00:40:19,950 --> 00:40:25,350
directly use the rook helm short so

00:40:22,740 --> 00:40:27,380
within the repository there is helm

00:40:25,350 --> 00:40:30,810
short provided so if you use helm you

00:40:27,380 --> 00:40:33,630
can use that to deploy rook and I

00:40:30,810 --> 00:40:35,970
haven't done this too much myself but my

00:40:33,630 --> 00:40:37,830
understanding is that helm also helps

00:40:35,970 --> 00:40:39,840
you with upgrading so there's a bit of

00:40:37,830 --> 00:40:41,130
many work that you need to do when

00:40:39,840 --> 00:40:44,970
you're upgrading from one version of

00:40:41,130 --> 00:40:47,580
raqqa to the next and he'll makes that a

00:40:44,970 --> 00:40:50,990
bit easier on the other hand you have

00:40:47,580 --> 00:40:54,609
kind of the complexion of helm on top so

00:40:50,990 --> 00:40:56,559
it's a trade off you

00:40:54,609 --> 00:41:00,640
nowwhat helm is helm is kind of a

00:40:56,559 --> 00:41:03,910
package manager for work so it just

00:41:00,640 --> 00:41:06,970
provides all the ammo files for

00:41:03,910 --> 00:41:08,559
deploying different things through a bit

00:41:06,970 --> 00:41:11,410
nicer interface so you can you say okay

00:41:08,559 --> 00:41:14,230
spin up nginx for me with these

00:41:11,410 --> 00:41:16,029
parameters and helm take care of

00:41:14,230 --> 00:41:21,220
creating the mo files and applying them

00:41:16,029 --> 00:41:23,140
to kubernetes right so the file you

00:41:21,220 --> 00:41:26,400
might have to edit or probably do you

00:41:23,140 --> 00:41:29,950
have to edit if you want to spin up a

00:41:26,400 --> 00:41:32,890
cook self cluster it's the cluster not

00:41:29,950 --> 00:41:36,309
the mo file and this is the file that

00:41:32,890 --> 00:41:39,609
defines which nodes in the cluster and

00:41:36,309 --> 00:41:42,819
which devices to use to provide storage

00:41:39,609 --> 00:41:44,829
by default these truck tries to use all

00:41:42,819 --> 00:41:47,170
the nodes in the cluster and all of the

00:41:44,829 --> 00:41:49,029
devices on those nodes and all the

00:41:47,170 --> 00:41:52,420
devices means all devices that it

00:41:49,029 --> 00:41:53,859
determines are not used by the operating

00:41:52,420 --> 00:42:00,369
system or not mounted and so on

00:41:53,859 --> 00:42:02,849
so any unmounted unused devices are

00:42:00,369 --> 00:42:05,200
deemed to be available for storage you

00:42:02,849 --> 00:42:07,809
can limit this in different ways you can

00:42:05,200 --> 00:42:09,609
as I said before you can label nodes and

00:42:07,809 --> 00:42:12,309
then say ok so only use two nodes with

00:42:09,609 --> 00:42:14,859
this particular label you can limit the

00:42:12,309 --> 00:42:17,619
device issues to devices with a certain

00:42:14,859 --> 00:42:19,989
path you can specify exactly which

00:42:17,619 --> 00:42:23,319
devices use on which nodes and so on so

00:42:19,989 --> 00:42:25,539
there's a lot of flexibility there this

00:42:23,319 --> 00:42:29,999
file also defines how many of each type

00:42:25,539 --> 00:42:33,549
of Ceph daemon to deploy so how many

00:42:29,999 --> 00:42:37,450
months months are the demons used to

00:42:33,549 --> 00:42:40,029
synchronize between nodes in the safe

00:42:37,450 --> 00:42:42,220
cluster and as I said before you

00:42:40,029 --> 00:42:45,190
typically have three or five so by

00:42:42,220 --> 00:42:47,680
default the cluster UML defines three of

00:42:45,190 --> 00:42:50,920
these but if you're doing kind of a

00:42:47,680 --> 00:42:54,369
small test you might only want one so

00:42:50,920 --> 00:42:57,220
you can do that managers are those

00:42:54,369 --> 00:43:01,150
providing extra services like monitoring

00:42:57,220 --> 00:43:04,420
and the dashboard and the gateways are

00:43:01,150 --> 00:43:08,050
rest gateways things like that

00:43:04,420 --> 00:43:09,839
and then you can also deploy optional

00:43:08,050 --> 00:43:13,270
services like yeah like Prometheus

00:43:09,839 --> 00:43:17,910
thinks I then you also define which

00:43:13,270 --> 00:43:17,910
version of Ceph to deploy in this file

00:43:19,020 --> 00:43:22,930
once you have your cluster up and

00:43:21,369 --> 00:43:26,560
running you can add additional services

00:43:22,930 --> 00:43:29,710
to it so in this example we're creating

00:43:26,560 --> 00:43:33,849
an object store shinobi store is kind of

00:43:29,710 --> 00:43:39,640
the s3 interface that you can use to

00:43:33,849 --> 00:43:42,280
access storage and then used create it

00:43:39,640 --> 00:43:47,230
with the file and then wait for the pod

00:43:42,280 --> 00:43:48,580
to appear and since this one is not too

00:43:47,230 --> 00:43:51,400
big and not too complicated I thought I

00:43:48,580 --> 00:43:52,990
could show you what it looks like so you

00:43:51,400 --> 00:43:55,599
have something called a safe object

00:43:52,990 --> 00:43:57,580
store you give it a name you say which

00:43:55,599 --> 00:44:01,080
names ways to put it in it's almost

00:43:57,580 --> 00:44:05,560
always work stuff you say ok so we want

00:44:01,080 --> 00:44:09,849
three replicate instances we want racial

00:44:05,560 --> 00:44:12,730
coding so means the data that we store

00:44:09,849 --> 00:44:18,010
within the object store should be

00:44:12,730 --> 00:44:21,040
replicated over in three places with two

00:44:18,010 --> 00:44:23,490
data chunks in one KO'ing chunk I'm not

00:44:21,040 --> 00:44:25,930
gonna go into a ratio going to much

00:44:23,490 --> 00:44:29,040
there is other options so you can say

00:44:25,930 --> 00:44:33,390
okay so which port to provide and so on

00:44:29,040 --> 00:44:33,390
which port to provide the storage on

00:44:36,080 --> 00:44:40,640
it's very simple to turn on let's use

00:44:37,850 --> 00:44:44,150
the boolean flag in the cluster

00:44:40,640 --> 00:44:46,490
Damo you say enable a dashboard and then

00:44:44,150 --> 00:44:52,090
rook will spin up the dashboard service

00:44:46,490 --> 00:44:55,790
and you can get the IP import the X's on

00:44:52,090 --> 00:44:59,420
rook also comes with a toolbox so the

00:44:55,790 --> 00:45:01,490
toolbox is a pod where you have all of

00:44:59,420 --> 00:45:04,220
the tooling force F available so if you

00:45:01,490 --> 00:45:06,410
want to do debugging or you want to make

00:45:04,220 --> 00:45:10,040
sure that the safe cluster is running a

00:45:06,410 --> 00:45:13,040
secured or a used one you need to dig

00:45:10,040 --> 00:45:15,680
into the cluster manually you can you

00:45:13,040 --> 00:45:18,260
spin up to box and then you can jump

00:45:15,680 --> 00:45:20,090
into it using this command and you can

00:45:18,260 --> 00:45:25,340
you have access to all of the safe

00:45:20,090 --> 00:45:28,370
commands you would expect there's a lot

00:45:25,340 --> 00:45:30,200
more to rook than this as I said the

00:45:28,370 --> 00:45:33,260
earlier rook provides storage interface

00:45:30,200 --> 00:45:35,830
is not just for safe but also for ETFs

00:45:33,260 --> 00:45:38,380
and a bunch of other storage solutions

00:45:35,830 --> 00:45:40,520
for more information about rook and the

00:45:38,380 --> 00:45:47,360
documentation you can go to a rook at

00:45:40,520 --> 00:45:49,340
i/o so in conclusion I guess the

00:45:47,360 --> 00:45:52,910
question the you might have is why would

00:45:49,340 --> 00:45:56,510
I want to use rook my answer would be if

00:45:52,910 --> 00:45:59,510
you need storage that is not database

00:45:56,510 --> 00:46:01,220
storage but disk storage for your

00:45:59,510 --> 00:46:01,900
applications and you're running on

00:46:01,220 --> 00:46:04,190
kubernetes

00:46:01,900 --> 00:46:07,430
it really isn't anything else the

00:46:04,190 --> 00:46:09,110
comparison is rook provides storage

00:46:07,430 --> 00:46:10,730
within kubernetes it provides some

00:46:09,110 --> 00:46:12,290
consistent interface wherever you run

00:46:10,730 --> 00:46:14,000
the kubernetes so if you move between

00:46:12,290 --> 00:46:16,520
cloud providers you have the same

00:46:14,000 --> 00:46:19,670
interface if you move our foo your cloak

00:46:16,520 --> 00:46:21,530
providers to bare metal deployment you

00:46:19,670 --> 00:46:24,620
have the same interface and so on so it

00:46:21,530 --> 00:46:26,900
provides a unified simple interface to

00:46:24,620 --> 00:46:28,820
storage where you go and as I said

00:46:26,900 --> 00:46:30,950
before all of the benefits of self still

00:46:28,820 --> 00:46:34,600
applies it's it's highly scalable and

00:46:30,950 --> 00:46:39,800
will scale according to your needs and

00:46:34,600 --> 00:46:44,750
so on the most recent version released

00:46:39,800 --> 00:46:46,910
of rook as of today is one the 2007 and

00:46:44,750 --> 00:46:47,970
the Stefan back-end is definitely the

00:46:46,910 --> 00:46:50,190
most mature

00:46:47,970 --> 00:46:53,849
sefa back in is the one that I would

00:46:50,190 --> 00:46:57,840
sort of recommend it's yeah it's the one

00:46:53,849 --> 00:47:01,349
I would say is in production quality SEF

00:46:57,840 --> 00:47:02,550
itself is definitely proven technology

00:47:01,349 --> 00:47:06,080
it's been running in production since

00:47:02,550 --> 00:47:10,500
2012 used in all kinds of locations

00:47:06,080 --> 00:47:12,000
Brook is a bit younger than that so keep

00:47:10,500 --> 00:47:16,800
that in mind if you want to be

00:47:12,000 --> 00:47:21,440
conservative and finally I want to

00:47:16,800 --> 00:47:25,619
mention that Sousa which is my employer

00:47:21,440 --> 00:47:30,780
provides a productized version it's pro

00:47:25,619 --> 00:47:32,670
version of self and now I was a rook we

00:47:30,780 --> 00:47:35,609
have in the current version that's

00:47:32,670 --> 00:47:37,710
released successor six we have this

00:47:35,609 --> 00:47:41,010
available on communities as a technology

00:47:37,710 --> 00:47:42,330
preview and the goal is for the next

00:47:41,010 --> 00:47:46,260
version which is going to be a Susan

00:47:42,330 --> 00:47:50,369
story 7 to have full support for for

00:47:46,260 --> 00:47:53,580
running on the kubernetes and that's it

00:47:50,369 --> 00:47:56,670
for me thank you very much and we have

00:47:53,580 --> 00:47:58,920
to take questions alright thanks a lot

00:47:56,670 --> 00:48:02,580
Chris offer this is to be us from force

00:47:58,920 --> 00:48:04,380
north I have been watching the question

00:48:02,580 --> 00:48:06,900
box that we have a slide oh and there

00:48:04,380 --> 00:48:09,650
have been a bunch of questions that I

00:48:06,900 --> 00:48:13,290
hope you will be able to answer for us

00:48:09,650 --> 00:48:16,680
first is not so much a question but more

00:48:13,290 --> 00:48:18,720
of a thank you for from a guy groovey

00:48:16,680 --> 00:48:28,260
steamie who was excited to learn about

00:48:18,720 --> 00:48:30,839
safe and then the first question

00:48:28,260 --> 00:48:32,849
otherwise the top one so to speak is how

00:48:30,839 --> 00:48:35,250
stable is work will it be able to handle

00:48:32,849 --> 00:48:37,020
enterprise size would say 300 developers

00:48:35,250 --> 00:48:40,800
using it on a daily basis it's a

00:48:37,020 --> 00:48:44,250
question from Gina yeah so that's a good

00:48:40,800 --> 00:48:48,060
question I would say like officially if

00:48:44,250 --> 00:48:51,660
you ask me as my role as a sous employee

00:48:48,060 --> 00:48:53,520
delivering Lisa storage as I said the

00:48:51,660 --> 00:48:56,700
version that we have out now is a

00:48:53,520 --> 00:49:00,330
technology preview and the means we

00:48:56,700 --> 00:49:01,800
don't support it for production we are

00:49:00,330 --> 00:49:05,060
getting close to release

00:49:01,800 --> 00:49:09,360
six or seven which means that if

00:49:05,060 --> 00:49:12,540
everything goes as it should I would say

00:49:09,360 --> 00:49:16,320
that yes we we've determined that it is

00:49:12,540 --> 00:49:20,130
ready for production we're not quite

00:49:16,320 --> 00:49:23,280
there yet if I guess it depends on how

00:49:20,130 --> 00:49:25,800
brave you feel storage is one of those

00:49:23,280 --> 00:49:27,750
topics where you really don't want

00:49:25,800 --> 00:49:31,100
things to go wrong you don't want to

00:49:27,750 --> 00:49:33,810
lose your datum and kubernetes is

00:49:31,100 --> 00:49:39,380
changing very quickly rook is a

00:49:33,810 --> 00:49:43,380
relatively young project SEF itself is

00:49:39,380 --> 00:49:47,940
mature it is complicated so there are

00:49:43,380 --> 00:49:50,400
still ways to mess up there to actually

00:49:47,940 --> 00:49:57,300
lose your data in SEF it's quite

00:49:50,400 --> 00:49:59,280
difficult but yeah I um I don't know if

00:49:57,300 --> 00:50:01,110
I want to say that yes sure rook is

00:49:59,280 --> 00:50:04,770
production-ready you can go and use it

00:50:01,110 --> 00:50:08,730
today and you'll be fine it is it is

00:50:04,770 --> 00:50:09,600
quite quite fresh still I would say but

00:50:08,730 --> 00:50:11,610
it's getting there

00:50:09,600 --> 00:50:13,500
it's getting close all right maybe

00:50:11,610 --> 00:50:15,210
there's there's a related question here

00:50:13,500 --> 00:50:17,220
that might put it put it in a different

00:50:15,210 --> 00:50:18,960
light what's the largest deployment of

00:50:17,220 --> 00:50:20,700
group that you've worked on and he says

00:50:18,960 --> 00:50:23,940
a customer self hosted thing or is it

00:50:20,700 --> 00:50:25,440
something that Suzy runs so definitely

00:50:23,940 --> 00:50:29,460
the largest cluster that I've been

00:50:25,440 --> 00:50:33,900
involved in is customer run and exactly

00:50:29,460 --> 00:50:39,099
how big it is I couldn't tell you um we

00:50:33,900 --> 00:50:41,829
yeah we don't have any

00:50:39,099 --> 00:50:45,880
in production already I think I have to

00:50:41,829 --> 00:50:47,799
confess that I'm I'm a developer I'm

00:50:45,880 --> 00:50:50,079
kind of on the development side of

00:50:47,799 --> 00:50:52,210
things I'm not that involved in actual

00:50:50,079 --> 00:50:53,769
deployments so I don't know for sure

00:50:52,210 --> 00:50:57,099
what the actual status of things are

00:50:53,769 --> 00:50:59,890
right now when it comes to SEF

00:50:57,099 --> 00:51:01,359
we have some really big informants again

00:50:59,890 --> 00:51:03,489
I don't know the exact sizes we're

00:51:01,359 --> 00:51:08,579
talking thousands and tens of thousands

00:51:03,489 --> 00:51:08,579
of nodes and massive amounts of storage

00:51:08,640 --> 00:51:18,430
running SEF through rook on kubernetes I

00:51:14,940 --> 00:51:19,089
don't know of any kind of additional

00:51:18,430 --> 00:51:22,839
bottlenecks

00:51:19,089 --> 00:51:27,039
or issues there that you might want to

00:51:22,839 --> 00:51:30,369
look out for but yeah I can't say that

00:51:27,039 --> 00:51:31,960
I've seen anything in the thousands yet

00:51:30,369 --> 00:51:37,059
I wouldn't say so

00:51:31,960 --> 00:51:39,609
so yeah not not nothing huge yet I would

00:51:37,059 --> 00:51:43,420
say maybe it's coming with an expression

00:51:39,609 --> 00:51:45,989
then probably yes

00:51:43,420 --> 00:51:50,440
we have another question from Gina here

00:51:45,989 --> 00:51:52,749
how big is the community around its

00:51:50,440 --> 00:51:55,239
fairly big so there are I would say that

00:51:52,749 --> 00:51:56,920
there are three main companies that are

00:51:55,239 --> 00:51:59,410
kind of contributing to Rock you're

00:51:56,920 --> 00:52:02,769
working on Brooke one is Susan the other

00:51:59,410 --> 00:52:04,779
is Red Hat and the final one is

00:52:02,769 --> 00:52:09,099
upbound which is the company that kind

00:52:04,779 --> 00:52:11,259
of created rook so and the number of

00:52:09,099 --> 00:52:15,489
people involved is a core I would say

00:52:11,259 --> 00:52:17,999
it's maybe 10 15 people working actively

00:52:15,489 --> 00:52:21,789
like as their day jobs working a rock

00:52:17,999 --> 00:52:23,950
but the community is much larger than

00:52:21,789 --> 00:52:26,440
that so there are a lot of people

00:52:23,950 --> 00:52:27,489
involved and there are kind of yeah it's

00:52:26,440 --> 00:52:31,210
an open source project

00:52:27,489 --> 00:52:36,099
there are contributors from just private

00:52:31,210 --> 00:52:38,950
people or companies or whatever the last

00:52:36,099 --> 00:52:43,680
question for this talk is related to the

00:52:38,950 --> 00:52:46,539
question that was given to mr. Hightower

00:52:43,680 --> 00:52:47,850
what are things that Luke is not good

00:52:46,539 --> 00:52:52,050
for

00:52:47,850 --> 00:52:56,220
ah that is a good question I would say

00:52:52,050 --> 00:52:59,430
probably the same things that safe

00:52:56,220 --> 00:53:01,500
aren't isn't good for so SEF is great if

00:52:59,430 --> 00:53:06,000
you need kind of the infinite

00:53:01,500 --> 00:53:07,830
scalability or you know you need to be

00:53:06,000 --> 00:53:10,860
able to scale up in the future and so on

00:53:07,830 --> 00:53:14,370
if you don't have that need then Seth is

00:53:10,860 --> 00:53:16,460
overly complicated and that is probably

00:53:14,370 --> 00:53:20,940
true work as well so if you don't need

00:53:16,460 --> 00:53:23,070
the the benefits that Brook provides you

00:53:20,940 --> 00:53:26,160
probably don't need rook either I mean

00:53:23,070 --> 00:53:27,960
if you have only a few applications that

00:53:26,160 --> 00:53:30,870
you deploy and they don't have much

00:53:27,960 --> 00:53:32,760
storage needs and they aren't too

00:53:30,870 --> 00:53:35,430
complicated then moving to a different

00:53:32,760 --> 00:53:38,670
cloud and rewriting to use the different

00:53:35,430 --> 00:53:41,520
cloud storage wouldn't be too difficult

00:53:38,670 --> 00:53:43,890
for a way if you don't have a need for

00:53:41,520 --> 00:53:45,360
storage in that way you use the database

00:53:43,890 --> 00:53:46,800
and you have boy they store it in a

00:53:45,360 --> 00:53:49,440
database and you manage that separately

00:53:46,800 --> 00:53:53,100
then you don't need rookies well either

00:53:49,440 --> 00:53:54,870
so yeah I would say look at the look

00:53:53,100 --> 00:53:58,230
itself and look at what's F is designed

00:53:54,870 --> 00:54:03,630
for and think about whether your use

00:53:58,230 --> 00:54:06,090
case matches that all right great thanks

00:54:03,630 --> 00:54:09,150
and thank you again for a great talk

00:54:06,090 --> 00:54:14,220
it's been super interesting to follow

00:54:09,150 --> 00:54:18,690
and I will hand back to Johan take it

00:54:14,220 --> 00:54:20,460
away thank you thank you and we have

00:54:18,690 --> 00:54:23,220
five more minutes left until the next

00:54:20,460 --> 00:54:25,370
speaker so stay tuned and we'll see you

00:54:23,220 --> 00:54:25,370
around

00:54:26,390 --> 00:54:30,710
and with that I would like to thank our

00:54:28,730 --> 00:54:33,160
speakers our sponsors and all our

00:54:30,710 --> 00:54:33,160
viewers

00:54:39,040 --> 00:54:41,100

YouTube URL: https://www.youtube.com/watch?v=1Fh_NB21_ME


