Title: Linux on RISC-V - Drew Fustini
Publication date: 2020-03-24
Playlist: foss-north 2020 virtual
Description: 
	Lightning talk from foss-north 2020


https://foss-north.se/2020/speakers-and-talks.html#lt-dfustini
Captions: 
	00:00:00,030 --> 00:00:06,000
welcome to force north the virtual

00:00:03,149 --> 00:00:08,130
edition we would like to thank all our

00:00:06,000 --> 00:00:12,330
sponsors and partners in this difficult

00:00:08,130 --> 00:00:15,830
situation our gold sponsors look soft

00:00:12,330 --> 00:00:20,000
and ansible by Red Hat

00:00:15,830 --> 00:00:22,220
our silver sponsors ITRs group and make

00:00:20,000 --> 00:00:25,900
it right

00:00:22,220 --> 00:00:28,960
our base sponsors

00:00:25,900 --> 00:00:31,150
our partner projects the open source

00:00:28,960 --> 00:00:34,239
community and the region of Gothenburg

00:00:31,150 --> 00:00:36,309
and a huge thanks to our awesome

00:00:34,239 --> 00:00:39,970
community this would not have been

00:00:36,309 --> 00:00:42,489
possible without you so my name is drew

00:00:39,970 --> 00:00:45,280
Festina and i wanted to talk about linux

00:00:42,489 --> 00:00:48,940
on risk 5 which are few things that i'm

00:00:45,280 --> 00:00:51,040
quite excited about so when you read a

00:00:48,940 --> 00:00:53,470
program like for example in the arduino

00:00:51,040 --> 00:00:56,589
ide or whatever ide you might be using

00:00:53,470 --> 00:00:58,839
for programming if it's a language like

00:00:56,589 --> 00:01:01,330
c it gets compiled into instructions

00:00:58,839 --> 00:01:04,150
that run on the biker controller on your

00:01:01,330 --> 00:01:06,430
processor but how does the compiler know

00:01:04,150 --> 00:01:08,680
instructions that your chip understands

00:01:06,430 --> 00:01:11,470
this is defined by the instruction set

00:01:08,680 --> 00:01:13,479
architecture or ISA so it's a set of

00:01:11,470 --> 00:01:16,360
rules that defines what tasks the

00:01:13,479 --> 00:01:18,310
processor can perform so examples of

00:01:16,360 --> 00:01:22,119
this you probably heard of would be x86

00:01:18,310 --> 00:01:23,380
which refers to Intel AMD's common

00:01:22,119 --> 00:01:25,570
instruction set this on all of our

00:01:23,380 --> 00:01:28,240
desktops and laptops and servers and

00:01:25,570 --> 00:01:30,370
then arm so if you have a smartphone

00:01:28,240 --> 00:01:32,590
with you it is most definitely running

00:01:30,370 --> 00:01:34,600
an ARM processor so arms another example

00:01:32,590 --> 00:01:37,300
of an instruction set now both of these

00:01:34,600 --> 00:01:39,130
are proprietary um and if you want to

00:01:37,300 --> 00:01:41,500
use them you need to have a commercial

00:01:39,130 --> 00:01:43,560
license from arm or with Intel and AMD

00:01:41,500 --> 00:01:46,840
of mine having possible to get a license

00:01:43,560 --> 00:01:48,490
so about ten years ago at the University

00:01:46,840 --> 00:01:50,650
of California Berkeley there was a

00:01:48,490 --> 00:01:53,460
computer architecture research group

00:01:50,650 --> 00:01:56,590
there in order to do their own research

00:01:53,460 --> 00:01:58,479
into computer architecture they didn't

00:01:56,590 --> 00:02:00,280
want to be constrained by having to

00:01:58,479 --> 00:02:02,440
license some commercial is a so they

00:02:00,280 --> 00:02:05,110
created a new instruction set called

00:02:02,440 --> 00:02:06,850
risk 5 this is the fifth RISC

00:02:05,110 --> 00:02:10,860
architecture that come out of Berkley

00:02:06,850 --> 00:02:10,860
going all the way back to the 80s

00:02:10,940 --> 00:02:17,180
and then so essentially the risk five is

00:02:14,030 --> 00:02:19,600
a is free and open for anyone to use

00:02:17,180 --> 00:02:21,310
it's licensed under a Creative Commons

00:02:19,600 --> 00:02:24,050
license

00:02:21,310 --> 00:02:26,270
I'm is just a lightning talk so I can't

00:02:24,050 --> 00:02:29,090
go into everything if you're interested

00:02:26,270 --> 00:02:31,430
in learning more about this megan walks

00:02:29,090 --> 00:02:34,220
from sy5 give a great talk at the

00:02:31,430 --> 00:02:36,800
hackaday super conference last year and

00:02:34,220 --> 00:02:38,620
goes into everest 5 and also FPGAs which

00:02:36,800 --> 00:02:41,120
i'm going to just talk about briefly

00:02:38,620 --> 00:02:43,190
also wrote a column and hack space

00:02:41,120 --> 00:02:45,380
magazine is a free magazine that you can

00:02:43,190 --> 00:02:47,930
download online go a little bit more

00:02:45,380 --> 00:02:50,480
into what risk 5 is so you can check out

00:02:47,930 --> 00:02:52,040
it check that out as well and then

00:02:50,480 --> 00:02:53,300
specifically what i want to talk about

00:02:52,040 --> 00:02:55,100
was when we were at the hackaday

00:02:53,300 --> 00:02:56,750
conference last year in november

00:02:55,100 --> 00:02:59,090
everyone at the conference got this

00:02:56,750 --> 00:03:00,650
badge here which i'll hold up to the

00:02:59,090 --> 00:03:03,080
camera so if you don't know if you can

00:03:00,650 --> 00:03:04,850
see this but this was the badge everyone

00:03:03,080 --> 00:03:06,830
got an idea was he could weird around

00:03:04,850 --> 00:03:08,960
your neck and have animations with your

00:03:06,830 --> 00:03:11,210
name and video games and stuff like that

00:03:08,960 --> 00:03:14,870
so a really cool badge but we thought

00:03:11,210 --> 00:03:16,610
hey it'd be nice if it ran Linux so a

00:03:14,870 --> 00:03:20,300
group of us got together and tried to do

00:03:16,610 --> 00:03:22,760
that now what was on the badge is not a

00:03:20,300 --> 00:03:25,340
normal processors an fpga

00:03:22,760 --> 00:03:27,410
so in fpga it stands for field

00:03:25,340 --> 00:03:30,080
programmable gate array and this is a

00:03:27,410 --> 00:03:33,320
sea of logic gates like the one on this

00:03:30,080 --> 00:03:35,150
chip has 45,000 gates and we can

00:03:33,320 --> 00:03:37,160
configure that to be any sort of digital

00:03:35,150 --> 00:03:40,430
logic that we want to design including a

00:03:37,160 --> 00:03:41,989
processor and go a little bit more into

00:03:40,430 --> 00:03:44,180
FPGAs if you want to know about that

00:03:41,989 --> 00:03:46,310
including the really exciting world of

00:03:44,180 --> 00:03:47,840
open-source tools for FPGAs route

00:03:46,310 --> 00:03:49,100
another column in tak space you can

00:03:47,840 --> 00:03:51,260
download for free if you want to check

00:03:49,100 --> 00:03:53,420
that out also at the end i'll share a

00:03:51,260 --> 00:03:55,760
link to the slides there's links and all

00:03:53,420 --> 00:03:59,480
that in the PDF for everything

00:03:55,760 --> 00:04:01,700
so this fpga that was on the badge was

00:03:59,480 --> 00:04:03,920
an e CP v fpga from a company called

00:04:01,700 --> 00:04:05,239
lattice and there's an open-source tool

00:04:03,920 --> 00:04:06,800
chain for it which means that we don't

00:04:05,239 --> 00:04:09,140
have to download some gigantic

00:04:06,800 --> 00:04:10,880
proprietary piece of software just to

00:04:09,140 --> 00:04:12,680
load things onto that pjo you can use

00:04:10,880 --> 00:04:15,800
these open-source tools which is very

00:04:12,680 --> 00:04:18,890
exciting and then specifically how did

00:04:15,800 --> 00:04:21,560
we create a soft core that can be loaded

00:04:18,890 --> 00:04:24,740
into the fpga we leveraged this project

00:04:21,560 --> 00:04:27,229
called light x so light x is based on

00:04:24,740 --> 00:04:29,630
a framework called me Jen for python

00:04:27,229 --> 00:04:33,050
this allows us to actually do chip

00:04:29,630 --> 00:04:35,900
design in Python so you might have heard

00:04:33,050 --> 00:04:37,550
of ver log or VHDL these are hardware

00:04:35,900 --> 00:04:40,490
description languages that you typically

00:04:37,550 --> 00:04:42,050
use for FPGAs but instead of those

00:04:40,490 --> 00:04:44,120
languages in this case you can use

00:04:42,050 --> 00:04:46,669
Python which I found to be quite

00:04:44,120 --> 00:04:48,280
powerful so me Jen is this Python

00:04:46,669 --> 00:04:50,810
framework that allows us to do

00:04:48,280 --> 00:04:53,360
essentially describe digital circuitry

00:04:50,810 --> 00:04:56,090
in Python and then light x builds upon

00:04:53,360 --> 00:04:58,130
that and has a set of cores and

00:04:56,090 --> 00:04:59,870
different peripherals that we need for

00:04:58,130 --> 00:05:02,630
building a full system on chip in this

00:04:59,870 --> 00:05:05,960
case something that had a serial port in

00:05:02,630 --> 00:05:08,770
a dram controller you can find more

00:05:05,960 --> 00:05:11,569
about it on a light X's on github there

00:05:08,770 --> 00:05:13,849
here's a nice little diagram of it so me

00:05:11,569 --> 00:05:16,370
Jen is that Python language for doing

00:05:13,849 --> 00:05:19,039
chip design and then it also ties into

00:05:16,370 --> 00:05:23,780
those open source FPA FPGA tool chains

00:05:19,039 --> 00:05:25,880
that the an analogy to compiling our

00:05:23,780 --> 00:05:27,800
source code with processor is we do a

00:05:25,880 --> 00:05:30,440
thing called synthesis BGA so the way

00:05:27,800 --> 00:05:31,820
that we actually take that hardware

00:05:30,440 --> 00:05:33,259
description language and turn it into

00:05:31,820 --> 00:05:36,440
something that can be loaded onto the

00:05:33,259 --> 00:05:38,630
FPGA is with a synthesis tool so it

00:05:36,440 --> 00:05:40,520
pulls all these things together and

00:05:38,630 --> 00:05:44,300
specifically there's a program called

00:05:40,520 --> 00:05:48,500
Linux on latex vex risk so vex risk is a

00:05:44,300 --> 00:05:50,659
small 32 bit capable risk 5 CPU so it's

00:05:48,500 --> 00:05:53,060
a processor design that can be loaded

00:05:50,659 --> 00:05:55,280
into an FPGA that is running the risk 5

00:05:53,060 --> 00:05:58,190
instruction set and it supports the

00:05:55,280 --> 00:06:00,500
ability to run Linux on it and then with

00:05:58,190 --> 00:06:03,110
light x were able to grab the other bits

00:06:00,500 --> 00:06:04,639
of chip design that we need so DRAM

00:06:03,110 --> 00:06:05,960
controller we're not using on this

00:06:04,639 --> 00:06:07,669
design but in other words you have

00:06:05,960 --> 00:06:10,280
Ethernet controller PCI Express

00:06:07,669 --> 00:06:12,110
controller you can sada so if you have a

00:06:10,280 --> 00:06:15,229
more capable at VGA board you could pull

00:06:12,110 --> 00:06:16,969
in other functionality as well with this

00:06:15,229 --> 00:06:21,229
batch project we basically just had a

00:06:16,969 --> 00:06:23,719
serial port and DRAM so this was us at

00:06:21,229 --> 00:06:28,250
how could a super conference trying to

00:06:23,719 --> 00:06:30,380
get the badge to run Linux and big

00:06:28,250 --> 00:06:33,710
thanks to the people that help out

00:06:30,380 --> 00:06:37,159
Michael Welling Tim Ansel Sean Krauss

00:06:33,710 --> 00:06:37,940
and Jacob in particular we we have Jacob

00:06:37,159 --> 00:06:39,560
to think for have

00:06:37,940 --> 00:06:41,180
thought ahead and having designed this

00:06:39,560 --> 00:06:44,000
little board so on the back of the badge

00:06:41,180 --> 00:06:45,590
there was an expansion port meant for if

00:06:44,000 --> 00:06:47,570
he wanted attach traditional hardware

00:06:45,590 --> 00:06:49,310
Jacob before the conference decided hey

00:06:47,570 --> 00:06:51,650
I'll make a board that has additional

00:06:49,310 --> 00:06:52,940
RAM in this case we needed it because we

00:06:51,650 --> 00:06:55,640
weren't able to run Linux on the

00:06:52,940 --> 00:06:57,830
built-in 16 megabytes of memory we

00:06:55,640 --> 00:06:59,950
needed the external DRAM which so this

00:06:57,830 --> 00:07:02,600
came in really handy at the conference

00:06:59,950 --> 00:07:03,950
and this is what the badge looks like so

00:07:02,600 --> 00:07:05,720
on the front there's the screen on the

00:07:03,950 --> 00:07:07,820
backside is where we have the expansion

00:07:05,720 --> 00:07:10,340
board plugged in with that 32 megabytes

00:07:07,820 --> 00:07:12,230
of DRAM and this is what it looks like

00:07:10,340 --> 00:07:14,720
connected to a terminal emulator on my

00:07:12,230 --> 00:07:17,540
laptop and this is what it looks like

00:07:14,720 --> 00:07:20,460
when the soft core inside the FPGA then

00:07:17,540 --> 00:07:23,310
goes in boots Linux

00:07:20,460 --> 00:07:25,410
and after we got back from the

00:07:23,310 --> 00:07:27,090
conference I wanted to make sure that

00:07:25,410 --> 00:07:28,949
this was up screamed into the light ex

00:07:27,090 --> 00:07:30,270
project so I went through and figured

00:07:28,949 --> 00:07:32,970
all the little things we did to get it

00:07:30,270 --> 00:07:34,530
to work at the conference so well you

00:07:32,970 --> 00:07:35,789
may not have this badge but if you want

00:07:34,530 --> 00:07:38,220
to take a look at what does it look like

00:07:35,789 --> 00:07:40,199
if you have another fpga board and you

00:07:38,220 --> 00:07:43,470
want to get linux and light x running on

00:07:40,199 --> 00:07:45,270
it you can take a look at this in to

00:07:43,470 --> 00:07:47,009
give you a flavor i think it's important

00:07:45,270 --> 00:07:48,810
to show you that if you're familiar with

00:07:47,009 --> 00:07:50,310
python it's much easier to understand

00:07:48,810 --> 00:07:52,560
what's going on here

00:07:50,310 --> 00:07:55,500
whereas I don't not really very

00:07:52,560 --> 00:07:58,139
experienced with VHDL or Verilog so here

00:07:55,500 --> 00:08:00,060
is example of for our board we took an

00:07:58,139 --> 00:08:01,680
existing board and we copied it and then

00:08:00,060 --> 00:08:04,080
change what was specific to this batch

00:08:01,680 --> 00:08:05,400
so things like the pins that we have

00:08:04,080 --> 00:08:08,280
here so these are called the pin

00:08:05,400 --> 00:08:10,320
constraints kind of mapping what pins we

00:08:08,280 --> 00:08:12,570
have go to which peripherals in the FPGA

00:08:10,320 --> 00:08:15,720
and as you can see it's all just Python

00:08:12,570 --> 00:08:18,000
so understandable from anyone that

00:08:15,720 --> 00:08:20,610
understands Python syntax there's things

00:08:18,000 --> 00:08:23,159
that are specific to this light x

00:08:20,610 --> 00:08:26,880
framework and the the media and language

00:08:23,159 --> 00:08:30,120
that's using Python but at least it's

00:08:26,880 --> 00:08:31,919
easy to look at at a glance I think more

00:08:30,120 --> 00:08:33,209
than a very lager beige deal for most

00:08:31,919 --> 00:08:36,229
people that come from a software

00:08:33,209 --> 00:08:39,020
background and here's taking a look at

00:08:36,229 --> 00:08:44,730
we have we're pulling in things like

00:08:39,020 --> 00:08:47,190
clocks in SDRAM and this were building

00:08:44,730 --> 00:08:51,060
up our system on chip using these Python

00:08:47,190 --> 00:08:53,190
modules and one of the other things that

00:08:51,060 --> 00:08:55,410
we had to do was add a definition of

00:08:53,190 --> 00:08:56,760
what our board was so we copied one of

00:08:55,410 --> 00:08:59,670
the existing ones and just add it in

00:08:56,760 --> 00:09:02,820
what we have and then how do we load on

00:08:59,670 --> 00:09:06,270
to the batch the specific output up our

00:09:02,820 --> 00:09:08,130
fpga tools and then one of the other

00:09:06,270 --> 00:09:12,450
nice things was so we had this 32

00:09:08,130 --> 00:09:13,860
megabyte SDRAM chip and normally you'd

00:09:12,450 --> 00:09:16,230
have to potentially write a bunch of

00:09:13,860 --> 00:09:18,630
vÃ©ra log or VHDL to get a new DRAM chip

00:09:16,230 --> 00:09:20,700
working in this case we can leverage the

00:09:18,630 --> 00:09:23,220
object-oriented nature of Python and

00:09:20,700 --> 00:09:24,990
just copy an existing class and then

00:09:23,220 --> 00:09:26,700
change it to the specific settings that

00:09:24,990 --> 00:09:28,800
are in the data sheet for this SDRAM

00:09:26,700 --> 00:09:32,200
module so kind of leveraging the

00:09:28,800 --> 00:09:33,730
object-oriented nature of Python

00:09:32,200 --> 00:09:36,160
one of the fun things was it was running

00:09:33,730 --> 00:09:36,670
really slow who's going 300 seconds to

00:09:36,160 --> 00:09:39,070
boot up

00:09:36,670 --> 00:09:41,140
I posted a github issue and Laurent who

00:09:39,070 --> 00:09:44,080
does or Florence are that does the light

00:09:41,140 --> 00:09:45,640
X get help he responded with a fix that

00:09:44,080 --> 00:09:47,710
made a run 10 times faster which was

00:09:45,640 --> 00:09:49,110
really cool here's a little movie what

00:09:47,710 --> 00:09:52,210
it looks like for Linux to boot on it

00:09:49,110 --> 00:09:56,920
and then we've been working on

00:09:52,210 --> 00:09:59,950
optimizing the performance and Greg here

00:09:56,920 --> 00:10:02,140
who's an awesome hacker in Australia he

00:09:59,950 --> 00:10:04,780
got the display working finally so here

00:10:02,140 --> 00:10:06,220
we have a vga terminal on the LCD so you

00:10:04,780 --> 00:10:08,140
can actually see Linux booting up

00:10:06,220 --> 00:10:10,450
without having to have it connected to

00:10:08,140 --> 00:10:12,850
your computer and then real quick just

00:10:10,450 --> 00:10:14,800
some bonus slides here Greg is going on

00:10:12,850 --> 00:10:16,180
to make an open-source Hardware board so

00:10:14,800 --> 00:10:18,150
this badge is just for people at the

00:10:16,180 --> 00:10:21,580
conference but if you want to get a

00:10:18,150 --> 00:10:23,290
Linux capable fpga board it's open

00:10:21,580 --> 00:10:26,070
hardware the orange crab just launched

00:10:23,290 --> 00:10:29,350
on group gets crowdfunding campain there

00:10:26,070 --> 00:10:31,480
and it does run Linux as Greg shows here

00:10:29,350 --> 00:10:33,150
and then there's also this radio and

00:10:31,480 --> 00:10:35,500
aboard from a hacker space in Croatia

00:10:33,150 --> 00:10:37,270
and that's also up for crowdfunding

00:10:35,500 --> 00:10:40,660
right now so if you want to get started

00:10:37,270 --> 00:10:43,030
on your own there's that and real quick

00:10:40,660 --> 00:10:45,610
here there are some chips

00:10:43,030 --> 00:10:47,620
not just FPGA is that can run Linux on

00:10:45,610 --> 00:10:50,650
risk 5 one is from a company called sigh

00:10:47,620 --> 00:10:52,690
5 they just did this board is kind of an

00:10:50,650 --> 00:10:54,730
evaluation so it's not something that is

00:10:52,690 --> 00:10:58,750
generally feel available yet but it is a

00:10:54,730 --> 00:11:01,720
quite capable board and people at Fedora

00:10:58,750 --> 00:11:05,410
are using it to get fedora running on

00:11:01,720 --> 00:11:08,620
risk 5 and then also we have Debian as

00:11:05,410 --> 00:11:10,600
well has a port for risk 5 and then a

00:11:08,620 --> 00:11:12,430
very inexpensive board is has a

00:11:10,600 --> 00:11:15,790
processor on it called the canned right

00:11:12,430 --> 00:11:18,340
the Kendrick a 210 so this is a board

00:11:15,790 --> 00:11:21,040
that you can get for $13 from scipy and

00:11:18,340 --> 00:11:23,200
it has a dual core 64-bit RISC like

00:11:21,040 --> 00:11:26,260
processor but it only has 8 megabytes of

00:11:23,200 --> 00:11:28,120
SRAM so someone named gabion them all at

00:11:26,260 --> 00:11:30,130
Western judo worked a bunch to get it

00:11:28,120 --> 00:11:31,780
working on there so you can get one of

00:11:30,130 --> 00:11:33,220
these 13 dollar boards and boot Linux on

00:11:31,780 --> 00:11:35,620
it as well

00:11:33,220 --> 00:11:37,120
and maybe next year we'll have some more

00:11:35,620 --> 00:11:42,190
boards but that's all we have for now

00:11:37,120 --> 00:11:46,080
and I'll leave it on the end here which

00:11:42,190 --> 00:11:46,080
is the link to the slides

00:11:46,770 --> 00:11:54,340
okay so here's a question are there any

00:11:50,410 --> 00:11:57,280
affordable risk five boards or risk V

00:11:54,340 --> 00:12:01,060
boards available for hacking how is the

00:11:57,280 --> 00:12:04,360
to change support yeah so let me go back

00:12:01,060 --> 00:12:06,100
here to so the this IP board with this

00:12:04,360 --> 00:12:06,820
Kendra chip is probably the best bet

00:12:06,100 --> 00:12:09,070
right now

00:12:06,820 --> 00:12:10,810
this one's thirteen dollars and this one

00:12:09,070 --> 00:12:14,260
has more peripherals it's forty dollars

00:12:10,810 --> 00:12:16,330
and they're both supported by mainline

00:12:14,260 --> 00:12:18,310
Linux kernel now so the great thing

00:12:16,330 --> 00:12:22,330
Myra's five is we have support in GCC

00:12:18,310 --> 00:12:24,280
clang LLVM so all that kind of the

00:12:22,330 --> 00:12:26,170
existing open source tool chains a lot

00:12:24,280 --> 00:12:29,950
of them support it now so there's pretty

00:12:26,170 --> 00:12:32,530
good support there's limited silicon so

00:12:29,950 --> 00:12:35,380
this is one one one way to do it the

00:12:32,530 --> 00:12:38,530
other way is with an fpga board like i

00:12:35,380 --> 00:12:40,120
was showing the third way is with QV mu

00:12:38,530 --> 00:12:43,540
so anyone that wants to right now can go

00:12:40,120 --> 00:12:51,190
download fedora or debian and run it and

00:12:43,540 --> 00:12:52,750
QEMU on their computer great thank you

00:12:51,190 --> 00:12:54,940
and we we also have a second question

00:12:52,750 --> 00:12:57,580
where where does risk 5 fit in so to

00:12:54,940 --> 00:13:00,730
speak what does it replace performance

00:12:57,580 --> 00:13:02,350
wise well I mean it's bigger than an 18

00:13:00,730 --> 00:13:03,940
mega which is one of the alternatives

00:13:02,350 --> 00:13:06,160
here but where do you see it does it

00:13:03,940 --> 00:13:08,260
replace our makes 86 what does it do

00:13:06,160 --> 00:13:11,500
what doesn't it well I think the idea

00:13:08,260 --> 00:13:13,600
was to be an open instruction set that

00:13:11,500 --> 00:13:17,470
could handle any sort of computing needs

00:13:13,600 --> 00:13:19,570
so they have a small 32-bit version for

00:13:17,470 --> 00:13:23,320
embedded microcontrollers all of you up

00:13:19,570 --> 00:13:25,600
to full 64-bit and they even have an

00:13:23,320 --> 00:13:28,060
option to do a 128-bit if we ever need

00:13:25,600 --> 00:13:30,420
to address that much memory so it's

00:13:28,060 --> 00:13:32,860
meant to be an open instruction set that

00:13:30,420 --> 00:13:35,230
anyone could use for everything from a

00:13:32,860 --> 00:13:38,050
small microcontroller to a smartphone to

00:13:35,230 --> 00:13:41,320
a server now that's just the instruction

00:13:38,050 --> 00:13:42,970
set the implementations there's many

00:13:41,320 --> 00:13:45,760
different ones or some open one source

00:13:42,970 --> 00:13:48,190
or proprietary ones for right now like

00:13:45,760 --> 00:13:50,770
Ali Baba's doing server clash chips with

00:13:48,190 --> 00:13:52,300
it there's also a lot of commercial

00:13:50,770 --> 00:13:54,520
microcontrollers that are being built

00:13:52,300 --> 00:13:56,680
with it I think a gap right now is to

00:13:54,520 --> 00:13:58,579
have like this sort of system on chip

00:13:56,680 --> 00:14:01,680
that you need for doing

00:13:58,579 --> 00:14:03,300
something like a phone or a laptop we

00:14:01,680 --> 00:14:06,180
don't necessarily have that sort of

00:14:03,300 --> 00:14:09,149
performance yet I have some big chips

00:14:06,180 --> 00:14:12,060
and then some smaller ones so but the

00:14:09,149 --> 00:14:13,459
instruction set itself is just the the

00:14:12,060 --> 00:14:16,079
instructions that the processor

00:14:13,459 --> 00:14:22,130
implements so it's kind of agnostic to

00:14:16,079 --> 00:14:22,130

YouTube URL: https://www.youtube.com/watch?v=NHnJuO39AQM


