Title: Functional Programming with JavaScript - Simon Painter
Publication date: 2020-04-25
Playlist: foss-north 2020 virtual
Description: 
	Talk details: https://foss-north.se/2020/speakers-and-talks.html#spainter
Conference details: https://foss-north.se/2020/
Captions: 
	00:00:00,030 --> 00:00:05,879
welcome to force north the virtual

00:00:03,030 --> 00:00:08,160
edition we would like to thank all our

00:00:05,879 --> 00:00:12,210
sponsors and partners in this difficult

00:00:08,160 --> 00:00:15,690
situation our gold sponsors look soft

00:00:12,210 --> 00:00:19,890
and ansible by Red Hat

00:00:15,690 --> 00:00:22,150
our silver sponsors ITRs group and make

00:00:19,890 --> 00:00:25,820
it right

00:00:22,150 --> 00:00:28,849
our base sponsors

00:00:25,820 --> 00:00:31,039
our partner projects the open source

00:00:28,849 --> 00:00:34,160
community and the region of Gothenburg

00:00:31,039 --> 00:00:36,199
and a huge thanks to our awesome

00:00:34,160 --> 00:00:41,059
community this would not have been

00:00:36,199 --> 00:00:44,180
possible without you welcome to our

00:00:41,059 --> 00:00:46,040
second session for today coming up now

00:00:44,180 --> 00:00:49,690
is Simon painter who will talk about

00:00:46,040 --> 00:00:53,510
functional programming in JavaScript

00:00:49,690 --> 00:00:58,610
which I'm really looking forward to the

00:00:53,510 --> 00:01:01,939
stage is yours hello folks I was

00:00:58,610 --> 00:01:04,850
speaking to you from the rather small

00:01:01,939 --> 00:01:07,250
but very cozy fourth bedroom of my my

00:01:04,850 --> 00:01:08,600
house at the moments my reason of all

00:01:07,250 --> 00:01:11,840
the rubbish is going on in the world so

00:01:08,600 --> 00:01:15,170
talking about functional programming in

00:01:11,840 --> 00:01:16,880
JavaScript but contact details are there

00:01:15,170 --> 00:01:18,979
on the screen at the moment feel free to

00:01:16,880 --> 00:01:20,869
grab them if anyone's interested I'll

00:01:18,979 --> 00:01:23,509
try and put this back up at the end I'm

00:01:20,869 --> 00:01:25,399
around on social media and available if

00:01:23,509 --> 00:01:29,890
anyone has any further questions slash

00:01:25,399 --> 00:01:32,450
abuse to hurl at me so I'll move on a

00:01:29,890 --> 00:01:34,310
little bit about me I've been doing

00:01:32,450 --> 00:01:36,860
software development for about 15 years

00:01:34,310 --> 00:01:39,200
now started off working for a little

00:01:36,860 --> 00:01:41,930
mobile application development company

00:01:39,200 --> 00:01:46,280
here in my hometown where I had to do

00:01:41,930 --> 00:01:48,500
stuff like develop a mapping system for

00:01:46,280 --> 00:01:51,049
buses which was great because I had to

00:01:48,500 --> 00:01:53,479
test it by going for a walk around the

00:01:51,049 --> 00:01:57,080
local park repeatedly absolutely had to

00:01:53,479 --> 00:02:00,799
is the only way to do it then moved on

00:01:57,080 --> 00:02:02,479
to Capgemini where I worked on a system

00:02:00,799 --> 00:02:05,299
that made sure that everyone in the UK

00:02:02,479 --> 00:02:08,060
pays the taxes and of course I've never

00:02:05,299 --> 00:02:10,069
had any abuse for that the Works was a

00:02:08,060 --> 00:02:11,629
big book shop firm in the UK proto labs

00:02:10,069 --> 00:02:15,049
their manufacturing company for the US

00:02:11,629 --> 00:02:17,180
and Europeans are now recently I have

00:02:15,049 --> 00:02:20,120
become one of those contractors that

00:02:17,180 --> 00:02:21,409
your mum always warned you about so I'm

00:02:20,120 --> 00:02:23,739
working for all sorts of people at the

00:02:21,409 --> 00:02:23,739
moment

00:02:23,959 --> 00:02:28,849
I'm a big fan of films so I don't have

00:02:26,750 --> 00:02:30,590
so much have a schedule as a program of

00:02:28,849 --> 00:02:34,519
events and we are going with the

00:02:30,590 --> 00:02:36,739
slightly inaccurately named six w's who

00:02:34,519 --> 00:02:41,389
what where when why and how a functional

00:02:36,739 --> 00:02:43,010
programming so first off who is it I'm

00:02:41,389 --> 00:02:44,810
going to introduce three people

00:02:43,010 --> 00:02:48,079
significant to the history of functional

00:02:44,810 --> 00:02:49,879
programming one of these guys is a

00:02:48,079 --> 00:02:52,219
software developer see if you can guess

00:02:49,879 --> 00:02:55,609
which as we go around but this first

00:02:52,219 --> 00:02:57,319
gentleman is Alonzo Church he I didn't

00:02:55,609 --> 00:03:01,129
have anyone who can see my Mac and

00:02:57,319 --> 00:03:03,489
focusing my mouse pointer I'll take your

00:03:01,129 --> 00:03:05,870
silence as a yes

00:03:03,489 --> 00:03:07,220
okay wonderful sorry didn't how

00:03:05,870 --> 00:03:11,120
interactive we are this is the first of

00:03:07,220 --> 00:03:12,379
these I've done so this gentleman is

00:03:11,120 --> 00:03:14,590
significant for a few reasons

00:03:12,379 --> 00:03:18,019
amongst them for us as developers is

00:03:14,590 --> 00:03:19,939
this guy the arrow function that's what

00:03:18,019 --> 00:03:21,439
this is it's an arrow function this is

00:03:19,939 --> 00:03:23,450
mathematics though this is from an old

00:03:21,439 --> 00:03:25,609
mask paper for the fifties and the

00:03:23,450 --> 00:03:27,409
second is this guy here this donator

00:03:25,609 --> 00:03:30,049
parameter it's the Greek letter lambda

00:03:27,409 --> 00:03:35,959
and this is where we get the term lambda

00:03:30,049 --> 00:03:37,790
expression this is Haskell curry who has

00:03:35,959 --> 00:03:40,519
something like three programming

00:03:37,790 --> 00:03:42,650
languages named after him and we're

00:03:40,519 --> 00:03:44,620
interested in him for this which are

00:03:42,650 --> 00:03:46,669
beginning to later this is currying

00:03:44,620 --> 00:03:49,000
don't worry about what that means at the

00:03:46,669 --> 00:03:49,000
moment

00:03:49,290 --> 00:03:55,680
guy might well be a software developer

00:03:52,380 --> 00:03:59,180
imagine why we'd think that this is John

00:03:55,680 --> 00:04:01,080
McCarthy he developed arguably the first

00:03:59,180 --> 00:04:01,650
functional programming language in the

00:04:01,080 --> 00:04:08,910
whole world

00:04:01,650 --> 00:04:11,760
Lisp in the 1960s so what his functional

00:04:08,910 --> 00:04:14,340
program not the point of the last few

00:04:11,760 --> 00:04:16,800
slides was to point out that it's not

00:04:14,340 --> 00:04:19,739
new there's nothing new about functional

00:04:16,800 --> 00:04:21,930
programming in fact I started digging

00:04:19,739 --> 00:04:23,460
into the maths papers that formed the

00:04:21,930 --> 00:04:25,550
foundation of functional programming and

00:04:23,460 --> 00:04:28,530
they date back to the late 1800s

00:04:25,550 --> 00:04:30,690
honestly I can't understand a single

00:04:28,530 --> 00:04:32,940
thing written in any of them because I'm

00:04:30,690 --> 00:04:35,970
not a mathematician I'm an engineer I

00:04:32,940 --> 00:04:37,730
don't understand it frankly but it isn't

00:04:35,970 --> 00:04:40,530
new at all it's not like the latest

00:04:37,730 --> 00:04:42,450
version of angular react or whatever

00:04:40,530 --> 00:04:45,300
it's not the latest framework that's

00:04:42,450 --> 00:04:47,130
competing with the others it's old it's

00:04:45,300 --> 00:04:49,080
been around for a long time the first

00:04:47,130 --> 00:04:51,690
programming language dates back to the

00:04:49,080 --> 00:04:55,230
60s and most of the heavy work dates

00:04:51,690 --> 00:04:58,370
back actually to the 50s it's not

00:04:55,230 --> 00:05:01,320
actually a language it's a paradigm a

00:04:58,370 --> 00:05:03,450
paradigm is a style of programming in in

00:05:01,320 --> 00:05:05,970
a way if we want the metaphor of a

00:05:03,450 --> 00:05:08,220
guitar then we may take our guitar and

00:05:05,970 --> 00:05:11,340
we may play many forms of music on it we

00:05:08,220 --> 00:05:12,960
can play rock we can play pop we can

00:05:11,340 --> 00:05:15,450
play country if you have no soul

00:05:12,960 --> 00:05:17,010
whatever but the point is that you could

00:05:15,450 --> 00:05:19,200
take your language and do many things so

00:05:17,010 --> 00:05:23,610
similarly with our programming language

00:05:19,200 --> 00:05:26,880
we can do procedural we can do object

00:05:23,610 --> 00:05:28,020
orientated we can do functional and an

00:05:26,880 --> 00:05:30,690
awful lot of languages these days

00:05:28,020 --> 00:05:33,090
support all three JavaScript

00:05:30,690 --> 00:05:37,170
particularly support functional very

00:05:33,090 --> 00:05:39,650
well and what is it also not it is not

00:05:37,170 --> 00:05:41,850
imperative nor is it object orientated

00:05:39,650 --> 00:05:44,280
most of the folks that I found that

00:05:41,850 --> 00:05:45,390
struggle with understanding are the

00:05:44,280 --> 00:05:48,870
folks that have been doing object

00:05:45,390 --> 00:05:51,120
orientated for 10 plus years and find it

00:05:48,870 --> 00:05:52,630
hard to adopt to a slightly new style of

00:05:51,120 --> 00:05:55,630
work

00:05:52,630 --> 00:05:57,340
it's not the solution to all of our

00:05:55,630 --> 00:05:59,410
problems although I would argue it's the

00:05:57,340 --> 00:06:01,180
solution to many as hopefully I will

00:05:59,410 --> 00:06:04,570
demonstrate over the coming 40 minutes

00:06:01,180 --> 00:06:06,640
or so it's also not difficult and argue

00:06:04,570 --> 00:06:08,350
it's really not it means dropping some

00:06:06,640 --> 00:06:10,600
preconceptions and learning a slightly

00:06:08,350 --> 00:06:14,830
new way of looking at a dev but it's not

00:06:10,600 --> 00:06:18,280
necessarily difficult so what actually

00:06:14,830 --> 00:06:20,290
is it there's a whole load of concepts a

00:06:18,280 --> 00:06:21,850
lot of these have got rather strange

00:06:20,290 --> 00:06:23,350
complicated names although what they

00:06:21,850 --> 00:06:27,310
actually mean generally isn't all that

00:06:23,350 --> 00:06:29,050
hard to grasp immutability this just

00:06:27,310 --> 00:06:30,910
means that once you've set a variable

00:06:29,050 --> 00:06:32,560
you can't change its state in the

00:06:30,910 --> 00:06:34,690
JavaScript world pretty much just means

00:06:32,560 --> 00:06:39,040
stick const on nearly everything and

00:06:34,690 --> 00:06:41,350
stop using less over higher-order

00:06:39,040 --> 00:06:42,700
functions this is something that folks

00:06:41,350 --> 00:06:45,250
in the JavaScript community have been

00:06:42,700 --> 00:06:48,490
doing for ages compared to folks over in

00:06:45,250 --> 00:06:49,990
like dotnet and Java this is passing

00:06:48,490 --> 00:06:53,230
around functions as if they were

00:06:49,990 --> 00:06:55,200
variables either as parameters to a

00:06:53,230 --> 00:06:57,970
function as the return from a function

00:06:55,200 --> 00:07:01,540
however but that's all it is function as

00:06:57,970 --> 00:07:03,910
functions passed around as variables it

00:07:01,540 --> 00:07:06,580
emphasizes functions not statements nor

00:07:03,910 --> 00:07:10,960
does that make a statement is something

00:07:06,580 --> 00:07:13,480
like an if it's aware it's for anything

00:07:10,960 --> 00:07:14,590
of that sort generally speaking as a

00:07:13,480 --> 00:07:17,170
rule of thumb in functional programming

00:07:14,590 --> 00:07:19,270
if there is a question the answer is

00:07:17,170 --> 00:07:22,900
usually functions more functions and

00:07:19,270 --> 00:07:26,470
that holds surprisingly true for a lot

00:07:22,900 --> 00:07:30,930
of situations ref

00:07:26,470 --> 00:07:33,610
so transparency this means that a

00:07:30,930 --> 00:07:36,790
function does not rely on anything

00:07:33,610 --> 00:07:38,590
beyond its parameters and the

00:07:36,790 --> 00:07:41,470
consequence of this is that it becomes

00:07:38,590 --> 00:07:45,100
extremely predictable in its behavior it

00:07:41,470 --> 00:07:47,230
means that given the same parameters it

00:07:45,100 --> 00:07:49,420
will always return the same answer no

00:07:47,230 --> 00:07:51,100
matter what no matter the life of the

00:07:49,420 --> 00:07:54,400
universe no matter the state of the

00:07:51,100 --> 00:07:57,670
system well let's switch it off no

00:07:54,400 --> 00:08:00,900
matter anything so this makes it very

00:07:57,670 --> 00:08:02,950
very very testable very predictable

00:08:00,900 --> 00:08:05,080
recursion I'm hoping we're all good on

00:08:02,950 --> 00:08:06,970
recursion if we're not going to dwell on

00:08:05,080 --> 00:08:08,770
recursion much in this talk but you know

00:08:06,970 --> 00:08:11,320
yeah most importantly pattern

00:08:08,770 --> 00:08:13,330
recognition we'll come to that this is

00:08:11,320 --> 00:08:17,380
kind of like a case statement with knobs

00:08:13,330 --> 00:08:19,419
on stateless there's no state object

00:08:17,380 --> 00:08:21,370
orientated tends to rely on the paradigm

00:08:19,419 --> 00:08:24,040
of you've got your state object you

00:08:21,370 --> 00:08:26,110
update it and you keep touching this

00:08:24,040 --> 00:08:27,880
same state object we don't generally do

00:08:26,110 --> 00:08:32,950
that in the functional world there are

00:08:27,880 --> 00:08:34,450
reasons amongst them it's and one of the

00:08:32,950 --> 00:08:38,740
great benefits it brings you is that

00:08:34,450 --> 00:08:40,150
things like async become very easy to

00:08:38,740 --> 00:08:41,650
support because you don't have a shared

00:08:40,150 --> 00:08:46,089
state between functions there are other

00:08:41,650 --> 00:08:48,460
ways now the monads monads is the one

00:08:46,089 --> 00:08:50,500
that has a reputation for being an awful

00:08:48,460 --> 00:08:53,050
pain in the bum to understand and

00:08:50,500 --> 00:08:54,910
certainly if you go looking on Wikipedia

00:08:53,050 --> 00:08:57,760
and some of these slightly more math see

00:08:54,910 --> 00:09:00,670
sites you will see these really horrid

00:08:57,760 --> 00:09:02,290
definitions of monad that involve f of G

00:09:00,670 --> 00:09:03,880
is G over there or whatever I don't

00:09:02,290 --> 00:09:06,250
really know I don't understand I'm not a

00:09:03,880 --> 00:09:09,730
mathematician but it gone to Douglas

00:09:06,250 --> 00:09:11,500
Crockford the curse of the monad is that

00:09:09,730 --> 00:09:13,990
once you gain the ability to explain it

00:09:11,500 --> 00:09:16,030
you lose once it once you gain the

00:09:13,990 --> 00:09:18,700
ability to understand the monad you lose

00:09:16,030 --> 00:09:23,070
the ability to explain it so not really

00:09:18,700 --> 00:09:24,270
necessarily planning to and it is not

00:09:23,070 --> 00:09:26,130
difficult

00:09:24,270 --> 00:09:29,820
as I'm hoping I'll demonstrate over

00:09:26,130 --> 00:09:32,040
there over this talk so where is it

00:09:29,820 --> 00:09:34,709
where do we find it there are of course

00:09:32,040 --> 00:09:37,170
the pure functional languages a school

00:09:34,709 --> 00:09:39,720
Erlang L never used them personally I

00:09:37,170 --> 00:09:41,910
know some folks that swear by Haskell

00:09:39,720 --> 00:09:45,149
airline I think it has got its uses all

00:09:41,910 --> 00:09:46,589
over I believe there are some queueing

00:09:45,149 --> 00:09:48,720
systems out there that are written in

00:09:46,589 --> 00:09:51,050
airline rabbitmq I think that's an

00:09:48,720 --> 00:09:51,050
airline

00:09:57,370 --> 00:10:01,750
I support functional programming with

00:10:00,040 --> 00:10:04,330
each iteration of dotnet that gets

00:10:01,750 --> 00:10:06,970
released and it's working out pretty

00:10:04,330 --> 00:10:08,980
well and they've even got a mostly

00:10:06,970 --> 00:10:11,080
functional language F sharp which is an

00:10:08,980 --> 00:10:13,390
alternative to c-sharp BB whatever and

00:10:11,080 --> 00:10:15,279
of course JavaScript JavaScript

00:10:13,390 --> 00:10:20,050
definitely does support functional very

00:10:15,279 --> 00:10:23,020
well when is it so when is it

00:10:20,050 --> 00:10:26,050
particularly good it's good for data

00:10:23,020 --> 00:10:27,550
processing that is given this data turn

00:10:26,050 --> 00:10:29,020
it into this data that's the sort of

00:10:27,550 --> 00:10:31,270
thing functional does really well that's

00:10:29,020 --> 00:10:33,880
very pure that's not requiring much

00:10:31,270 --> 00:10:35,770
interaction concurrent systems that is

00:10:33,880 --> 00:10:37,720
it's where you want to stack a whole

00:10:35,770 --> 00:10:40,680
load of instances of the same function

00:10:37,720 --> 00:10:43,839
side by side there's no shared state so

00:10:40,680 --> 00:10:47,310
concurrency is very enabled by

00:10:43,839 --> 00:10:49,360
functional high criticality because

00:10:47,310 --> 00:10:53,610
functional programs in general tend to

00:10:49,360 --> 00:10:55,990
be more robust than object orientated or

00:10:53,610 --> 00:10:57,580
procedural code so if it's very

00:10:55,990 --> 00:10:59,980
important that your system go up and

00:10:57,580 --> 00:11:01,420
stay up then functional might well be

00:10:59,980 --> 00:11:04,360
something to consider

00:11:01,420 --> 00:11:06,420
allegedly with stuff like a Erlang once

00:11:04,360 --> 00:11:08,920
you've actually got it furred to compile

00:11:06,420 --> 00:11:11,440
then nothing on this earth will ever

00:11:08,920 --> 00:11:12,940
make it break now I don't know I've not

00:11:11,440 --> 00:11:15,880
tried that but it seems entirely

00:11:12,940 --> 00:11:18,850
plausible and service if we're just in

00:11:15,880 --> 00:11:21,700
service mostly for the the previous

00:11:18,850 --> 00:11:22,750
three reasons that's again functional is

00:11:21,700 --> 00:11:26,190
the sort of thing that might easily

00:11:22,750 --> 00:11:26,190
enable you to get into service

00:11:26,329 --> 00:11:30,799
so where is it not now it's not that

00:11:28,369 --> 00:11:32,149
functional can't do these things it's

00:11:30,799 --> 00:11:36,319
just that these are some of the areas

00:11:32,149 --> 00:11:40,179
where you have to make compromises you I

00:11:36,319 --> 00:11:40,179
obviously because there is nothing more

00:11:40,720 --> 00:11:44,299
imperial impure as it gets to the

00:11:43,459 --> 00:11:46,850
computer world

00:11:44,299 --> 00:11:49,699
now obviously JavaScript office office

00:11:46,850 --> 00:11:52,610
often meant to be out on the front line

00:11:49,699 --> 00:11:55,610
with the user but what we need to do

00:11:52,610 --> 00:11:57,319
generally is maximize the pure area of

00:11:55,610 --> 00:12:00,519
functionality and then minimize the

00:11:57,319 --> 00:12:02,720
amount of dirty human interaction

00:12:00,519 --> 00:12:05,470
external interactions with other systems

00:12:02,720 --> 00:12:07,999
same sort of reason input input

00:12:05,470 --> 00:12:09,529
interacted with files because who knows

00:12:07,999 --> 00:12:11,629
that the file is there is not there

00:12:09,529 --> 00:12:15,019
whatever this is all and high

00:12:11,629 --> 00:12:16,899
performance okay I don't know why that

00:12:15,019 --> 00:12:21,619
oh yes high performance systems because

00:12:16,899 --> 00:12:24,319
sometimes it depends this might not be

00:12:21,619 --> 00:12:26,569
the case with JavaScript so much with

00:12:24,319 --> 00:12:28,759
some systems with some programming

00:12:26,569 --> 00:12:29,899
languages certainly like C sharp making

00:12:28,759 --> 00:12:32,569
it more functional may not necessarily

00:12:29,899 --> 00:12:35,360
be functionally the most performant

00:12:32,569 --> 00:12:37,309
choice but this may not be the only

00:12:35,360 --> 00:12:40,839
concern you have when developing your

00:12:37,309 --> 00:12:43,910
system often we're more interested in

00:12:40,839 --> 00:12:46,040
testability in sustainability

00:12:43,910 --> 00:12:48,860
readability if you're more interested in

00:12:46,040 --> 00:12:50,569
those things which in fairness I would

00:12:48,860 --> 00:12:54,259
agree argue that most businesses are

00:12:50,569 --> 00:12:55,970
because most businesses are keen that

00:12:54,259 --> 00:12:58,489
the development efforts get done fast

00:12:55,970 --> 00:13:00,049
rather than anything else then again

00:12:58,489 --> 00:13:05,119
functionally still probably what you

00:13:00,049 --> 00:13:08,779
want so why is it why why are we

00:13:05,119 --> 00:13:10,610
interested it's concise you can now

00:13:08,779 --> 00:13:12,649
normally our gesture wildly with my arms

00:13:10,610 --> 00:13:16,610
but you have to imagine that at the

00:13:12,649 --> 00:13:19,239
moment but note you can compress pages

00:13:16,610 --> 00:13:22,009
of code down to just a couple of lines

00:13:19,239 --> 00:13:24,110
potentially it's a lot more concise than

00:13:22,009 --> 00:13:26,929
old-fashioned object orientated it's

00:13:24,110 --> 00:13:29,059
procedural code it's more readable

00:13:26,929 --> 00:13:31,579
mostly because of the concision that

00:13:29,059 --> 00:13:35,289
you've added in with compacting the code

00:13:31,579 --> 00:13:37,369
write down and it tends to enforce the

00:13:35,289 --> 00:13:39,560
writing the code in and order of

00:13:37,369 --> 00:13:42,290
operations that's more logical and

00:13:39,560 --> 00:13:44,180
with what we're actually trying to we're

00:13:42,290 --> 00:13:45,589
trying to achieve a testable mention

00:13:44,180 --> 00:13:49,009
that and concurrency I've mentioned that

00:13:45,589 --> 00:13:52,399
and robustness hey and it's fun I hope

00:13:49,009 --> 00:13:55,569
everyone will agree by the end so this

00:13:52,399 --> 00:13:57,800
is an old-fashioned bit of

00:13:55,569 --> 00:14:01,399
object-oriented a 2d procedural code

00:13:57,800 --> 00:14:02,870
ever if I gave everyone five seconds to

00:14:01,399 --> 00:14:05,870
understand what on earth this was doing

00:14:02,870 --> 00:14:07,399
you'd probably struggle and there's a

00:14:05,870 --> 00:14:09,350
good and that's because our order of

00:14:07,399 --> 00:14:11,360
operations is all over the place there's

00:14:09,350 --> 00:14:12,439
all sorts of bits of code structure in

00:14:11,360 --> 00:14:14,930
there that are just there to be

00:14:12,439 --> 00:14:20,420
structure it's it's a bit harder to read

00:14:14,930 --> 00:14:22,040
than say something oh sorry I'll go on

00:14:20,420 --> 00:14:26,360
to that in a moment sorry slides ordered

00:14:22,040 --> 00:14:27,949
change there okay but in functional we

00:14:26,360 --> 00:14:31,100
could just write this on about a line or

00:14:27,949 --> 00:14:33,499
so so this is my test case this is what

00:14:31,100 --> 00:14:35,600
I'm actually feeding into the thing so

00:14:33,499 --> 00:14:40,430
this is a test I what I'm actually doing

00:14:35,600 --> 00:14:43,129
is I'm taking a small little CSV of the

00:14:40,430 --> 00:14:45,319
titles of Doctor Who stories for those

00:14:43,129 --> 00:14:48,170
unfamiliar doctor who is the greatest TV

00:14:45,319 --> 00:14:50,509
series in the entire world and this is

00:14:48,170 --> 00:14:54,649
the story titles from the first series

00:14:50,509 --> 00:14:57,259
in 1963 along with my personal rating of

00:14:54,649 --> 00:15:00,920
those stories so what I actually want to

00:14:57,259 --> 00:15:03,589
get out of it is pass this down to data

00:15:00,920 --> 00:15:05,569
structure and then take out my favorite

00:15:03,589 --> 00:15:07,639
stories and then give us back the titles

00:15:05,569 --> 00:15:10,660
which is what this lock is actually

00:15:07,639 --> 00:15:12,379
doing you know slightly convoluted way

00:15:10,660 --> 00:15:16,210
and this is how I would do it

00:15:12,379 --> 00:15:18,450
functionally if they don't thinking

00:15:16,210 --> 00:15:22,500
is just an awful lot of out-of-the-box

00:15:18,450 --> 00:15:24,220
es6 functions there yet pretty much

00:15:22,500 --> 00:15:27,430
that's what it is

00:15:24,220 --> 00:15:30,070
and if you've been developing in this

00:15:27,430 --> 00:15:32,140
style you've pretty much been doing

00:15:30,070 --> 00:15:35,649
functional programming for a while now

00:15:32,140 --> 00:15:37,839
and what how are we doing again the

00:15:35,649 --> 00:15:40,930
order of operations is nice and simple

00:15:37,839 --> 00:15:43,870
and laid out in a flow split on new line

00:15:40,930 --> 00:15:47,410
then split each of those lines on comma

00:15:43,870 --> 00:15:49,120
do a filter where I'm pausing item 2 to

00:15:47,410 --> 00:15:53,250
an int and then checking it to before

00:15:49,120 --> 00:15:57,160
and then finally select out just item 1

00:15:53,250 --> 00:16:00,820
easy that's an awful lot more compact

00:15:57,160 --> 00:16:02,320
than the first code sample it's a lot

00:16:00,820 --> 00:16:03,880
easy to read and understand what it's

00:16:02,320 --> 00:16:06,100
done it's a lot easy to modify because

00:16:03,880 --> 00:16:08,980
we can easily just throw an extra line

00:16:06,100 --> 00:16:11,380
into this functional flow it's obvious

00:16:08,980 --> 00:16:13,209
where to make a change in our and that's

00:16:11,380 --> 00:16:15,790
what functional programming is what we

00:16:13,209 --> 00:16:17,529
want to do in effect is put the rest of

00:16:15,790 --> 00:16:21,570
our language into this structure in

00:16:17,529 --> 00:16:26,170
order to continue and I'll demonstrate

00:16:21,570 --> 00:16:28,820
using some one of my favorite libraries

00:16:26,170 --> 00:16:31,250
are the juice in a moment and

00:16:28,820 --> 00:16:36,500
I did say that I would get into it the

00:16:31,250 --> 00:16:41,000
concept of currying so in a normal non

00:16:36,500 --> 00:16:43,850
curried function we let's say an ad we

00:16:41,000 --> 00:16:45,440
take an int there should be a bar I may

00:16:43,850 --> 00:16:49,250
possibly have reuse these slides from

00:16:45,440 --> 00:16:51,860
another language don't tell anyone

00:16:49,250 --> 00:16:54,710
we've got a VAR a if RB and we're just

00:16:51,860 --> 00:16:57,620
saying it goes to a plus B so that's

00:16:54,710 --> 00:17:01,550
easy give it a 10 or 20 we get a 30 if

00:16:57,620 --> 00:17:04,820
this were a hypothetical curried ad and

00:17:01,550 --> 00:17:06,680
we gave it only the 10 does anybody out

00:17:04,820 --> 00:17:10,810
they want to hazard a guess as to what

00:17:06,680 --> 00:17:10,810
we get out as the value of answer to

00:17:12,500 --> 00:17:17,750
well the answer in fact is that you get

00:17:16,590 --> 00:17:20,410
back

00:17:17,750 --> 00:17:22,790
function because as dolphin in

00:17:20,410 --> 00:17:26,390
JavaScript in functional programming the

00:17:22,790 --> 00:17:29,960
answer is a function or functions so if

00:17:26,390 --> 00:17:33,050
you give this curried as simply one

00:17:29,960 --> 00:17:35,480
parameter the ten you get back a

00:17:33,050 --> 00:17:39,710
function which kind of demonstrating

00:17:35,480 --> 00:17:41,900
here which has the one firm value filled

00:17:39,710 --> 00:17:43,940
in and the second still required and

00:17:41,900 --> 00:17:47,990
that is a parameter to the function has

00:17:43,940 --> 00:17:50,210
been returned so by giving our add a

00:17:47,990 --> 00:17:57,020
single parameter we've converted it into

00:17:50,210 --> 00:17:58,760
an add ten function and this seems a bit

00:17:57,020 --> 00:18:01,520
strange but it is in fact very very

00:17:58,760 --> 00:18:03,470
powerful and then you can just give it

00:18:01,520 --> 00:18:06,020
the second one the you can call this

00:18:03,470 --> 00:18:07,160
answer to function give it a second

00:18:06,020 --> 00:18:12,080
parameter and you get back an answer

00:18:07,160 --> 00:18:14,270
finally so the way to the ER we've could

00:18:12,080 --> 00:18:15,680
introduce this to JavaScript is by one

00:18:14,270 --> 00:18:18,800
of my very favorite libraries in the

00:18:15,680 --> 00:18:22,250
whole world this is round two Jas I'm a

00:18:18,800 --> 00:18:23,570
huge fan of this guy and most of the

00:18:22,250 --> 00:18:25,690
rest of the talk is going to be using

00:18:23,570 --> 00:18:27,950
Ram de which I'm a big fan of this

00:18:25,690 --> 00:18:30,100
provides an awful lot of functions that

00:18:27,950 --> 00:18:34,490
are very similar to things that like

00:18:30,100 --> 00:18:37,180
underscore or lodash give you but given

00:18:34,490 --> 00:18:39,920
a more a more distinctly functional and

00:18:37,180 --> 00:18:43,850
approach and using currying on

00:18:39,920 --> 00:18:45,800
everything by default so this is an

00:18:43,850 --> 00:18:49,490
example of a ram des function this is

00:18:45,800 --> 00:18:53,150
one filling in all the parameters n here

00:18:49,490 --> 00:18:55,880
so Ram D uses it and what to call a

00:18:53,150 --> 00:18:57,200
namespace are generally I mean when

00:18:55,880 --> 00:18:59,480
you're importing it you can call it what

00:18:57,200 --> 00:19:04,160
you like of course but R is as good as

00:18:59,480 --> 00:19:05,750
anything so our dough enth says give me

00:19:04,160 --> 00:19:08,909
this array and I will give you the

00:19:05,750 --> 00:19:11,009
whatever is in the enth position

00:19:08,909 --> 00:19:14,190
nice and simple so all it means is in

00:19:11,009 --> 00:19:15,809
the warmth position or whatever your

00:19:14,190 --> 00:19:17,129
you're getting that item so Julie wrote

00:19:15,809 --> 00:19:20,639
one it's that one

00:19:17,129 --> 00:19:23,099
so we're saying one is the position data

00:19:20,639 --> 00:19:24,830
is the data it gives back a capital B

00:19:23,099 --> 00:19:30,779
because that is of one that's there so

00:19:24,830 --> 00:19:33,269
far so good but what we can do is we can

00:19:30,779 --> 00:19:35,759
only give it the one we haven't given it

00:19:33,269 --> 00:19:38,309
the data at this point so what that

00:19:35,759 --> 00:19:41,249
means is that get array one here is now

00:19:38,309 --> 00:19:44,009
a function it's a function that given

00:19:41,249 --> 00:19:47,159
any array fed into it it will give you

00:19:44,009 --> 00:19:50,099
whatever is in position one in that

00:19:47,159 --> 00:19:54,239
array so now I've defined to erase data

00:19:50,099 --> 00:19:56,700
one and A two and I'm forming an array

00:19:54,239 --> 00:19:59,999
here down here which is a call to get

00:19:56,700 --> 00:20:02,279
array one here with data one fed in and

00:19:59,999 --> 00:20:04,440
the data two so I'm reusing the exact

00:20:02,279 --> 00:20:07,169
same code to fetch the first item out of

00:20:04,440 --> 00:20:08,970
each so we end up with an array at the

00:20:07,169 --> 00:20:11,429
end which is a B and an F a B for this

00:20:08,970 --> 00:20:13,109
one left this one and have defined in

00:20:11,429 --> 00:20:15,889
one position what the logic is for

00:20:13,109 --> 00:20:18,299
turning my reins of the data that I want

00:20:15,889 --> 00:20:19,529
this is a ridiculously simple example

00:20:18,299 --> 00:20:21,359
and wouldn't necessarily do this in the

00:20:19,529 --> 00:20:25,759
real world but it's just to demonstrate

00:20:21,359 --> 00:20:29,909
the principle and you can just easily

00:20:25,759 --> 00:20:33,889
slide it into my existing functional

00:20:29,909 --> 00:20:37,289
chain here are the enth one here because

00:20:33,889 --> 00:20:39,470
everything in ram de unless you supply

00:20:37,289 --> 00:20:41,489
every single parameters of the thing

00:20:39,470 --> 00:20:45,149
evaluates generally to another function

00:20:41,489 --> 00:20:47,099
so this is my arrow function simplified

00:20:45,149 --> 00:20:51,809
without the arrow into a simple call to

00:20:47,099 --> 00:20:54,239
enth one and what I'd like to do is to

00:20:51,809 --> 00:20:56,549
try and pop the rest of this structure

00:20:54,239 --> 00:20:59,190
into this same use this same approach to

00:20:56,549 --> 00:21:00,599
compact it down and hopefully simplify

00:20:59,190 --> 00:21:03,409
further what we're actually trying to do

00:21:00,599 --> 00:21:07,409
but first I need to introduce another

00:21:03,409 --> 00:21:10,409
structure that I'll be using so I used

00:21:07,409 --> 00:21:12,840
to work for a US company and beam

00:21:10,409 --> 00:21:14,820
British one of the things we would often

00:21:12,840 --> 00:21:16,980
do is discuss the weather

00:21:14,820 --> 00:21:19,799
because this is no joke what British

00:21:16,980 --> 00:21:21,480
people do a lot so the American folks

00:21:19,799 --> 00:21:23,100
would say and I'm not doing the accent

00:21:21,480 --> 00:21:25,769
because I can't and it's embarrassing

00:21:23,100 --> 00:21:28,470
but they would say something like it's a

00:21:25,769 --> 00:21:30,720
hundred degrees outside now I would

00:21:28,470 --> 00:21:34,110
think 100 degrees ooh that's hot enough

00:21:30,720 --> 00:21:36,529
to boil water what the hell but of

00:21:34,110 --> 00:21:39,000
course they mean a hundred Fahrenheit

00:21:36,529 --> 00:21:43,049
the system used a further 'men we're

00:21:39,000 --> 00:21:45,029
only within the US so the formula for

00:21:43,049 --> 00:21:48,120
converting from Fahrenheit to Celsius is

00:21:45,029 --> 00:21:50,879
deduct 32 multiplied by 5 divided by 9

00:21:48,120 --> 00:21:55,289
because of course it is why wouldn't it

00:21:50,879 --> 00:21:59,700
be for what we have is a series of

00:21:55,289 --> 00:22:02,909
operations here and each one is taking a

00:21:59,700 --> 00:22:04,799
value operating on it storing that

00:22:02,909 --> 00:22:07,500
somewhere and then the next line is

00:22:04,799 --> 00:22:10,440
taking the previous step modifying it

00:22:07,500 --> 00:22:13,409
further and so on step two step two step

00:22:10,440 --> 00:22:16,649
like a relay race now because of that

00:22:13,409 --> 00:22:18,840
we've got an awful lot of code noise

00:22:16,649 --> 00:22:20,549
here we've got all these contests that

00:22:18,840 --> 00:22:22,259
actually we're never gonna use aside

00:22:20,549 --> 00:22:25,200
from just in this one instance this A's

00:22:22,259 --> 00:22:27,509
unused here this beyond here we've got

00:22:25,200 --> 00:22:28,769
the return and so on here well strictly

00:22:27,509 --> 00:22:33,179
speaking all of this we don't really

00:22:28,769 --> 00:22:34,710
need we could use a perfectly nice

00:22:33,179 --> 00:22:38,940
structure and rambling which I will be

00:22:34,710 --> 00:22:40,860
getting to but first Ram de does have an

00:22:38,940 --> 00:22:44,070
add subtract multiply divide it has all

00:22:40,860 --> 00:22:45,960
of these guys so we can start throwing

00:22:44,070 --> 00:22:49,500
these into functional trees as well

00:22:45,960 --> 00:22:53,009
these of course are all curried so if we

00:22:49,500 --> 00:22:55,679
simply wanted to add or multiply then

00:22:53,009 --> 00:22:58,019
it's very easy to create a quick curried

00:22:55,679 --> 00:23:00,149
version of those if we do the adds and

00:22:58,019 --> 00:23:01,529
call our pass only attend to it then we

00:23:00,149 --> 00:23:03,240
add 10 easy-peasy

00:23:01,529 --> 00:23:05,100
we've got a tad tent function similarly

00:23:03,240 --> 00:23:06,480
with the multiply because the order of

00:23:05,100 --> 00:23:10,620
operations doesn't matter with these

00:23:06,480 --> 00:23:12,509
guys but with the subtract and the

00:23:10,620 --> 00:23:16,409
divide the order of operations is

00:23:12,509 --> 00:23:19,110
important when I say subtract 20 15 here

00:23:16,409 --> 00:23:20,820
this is 20 minus 15 it's actually in the

00:23:19,110 --> 00:23:23,100
order that you would sort of say it when

00:23:20,820 --> 00:23:24,629
you're describing describing a

00:23:23,100 --> 00:23:27,010
mathematical operation to divide some

00:23:24,629 --> 00:23:30,280
leaves they're a hundred divided by five

00:23:27,010 --> 00:23:34,179
so if we want to curry these guys we

00:23:30,280 --> 00:23:37,890
probably want to actually change the

00:23:34,179 --> 00:23:41,830
order of operations or to curry a

00:23:37,890 --> 00:23:44,890
function other than let's provide other

00:23:41,830 --> 00:23:47,340
than the the second one is our parameter

00:23:44,890 --> 00:23:51,460
to our resulting curried function so

00:23:47,340 --> 00:23:53,169
lambda has a feature here called our dot

00:23:51,460 --> 00:23:55,570
it's an underscore underscore their

00:23:53,169 --> 00:23:58,000
specially two underscores this is a

00:23:55,570 --> 00:24:01,059
function that is a special case well its

00:23:58,000 --> 00:24:04,059
meaning is really subtract I am

00:24:01,059 --> 00:24:05,980
supplying all of the parameters but I'm

00:24:04,059 --> 00:24:07,630
saying that the one that the curried

00:24:05,980 --> 00:24:09,130
function that comes out of it should

00:24:07,630 --> 00:24:11,650
actually supplies as parameter is the

00:24:09,130 --> 00:24:13,090
one I'm saying I'm saying this is the

00:24:11,650 --> 00:24:14,830
whole this is the bit that needs to be

00:24:13,090 --> 00:24:17,620
filled in by the next call to the

00:24:14,830 --> 00:24:19,990
function we're generating so by doing

00:24:17,620 --> 00:24:22,240
this I'm saying please now yet next

00:24:19,990 --> 00:24:25,179
person supply the first one and then

00:24:22,240 --> 00:24:27,460
I'll give you the 15 so that in a fact

00:24:25,179 --> 00:24:29,940
means I've now created a ooh that's

00:24:27,460 --> 00:24:34,419
wrong that's wrong I've now created a

00:24:29,940 --> 00:24:36,820
subtract fifteen function and down here

00:24:34,419 --> 00:24:39,340
again I am telling the thing that this

00:24:36,820 --> 00:24:43,980
is the one I want to be supplied later

00:24:39,340 --> 00:24:50,080
so I've now just created 8/5 function

00:24:43,980 --> 00:24:52,690
easy so then finally we could put all of

00:24:50,080 --> 00:24:55,000
this stuff into my new Fahrenheit to

00:24:52,690 --> 00:24:58,600
Celsius converter using something called

00:24:55,000 --> 00:25:01,330
pipe and pipe does exactly the process

00:24:58,600 --> 00:25:04,390
that you saw on the old version of this

00:25:01,330 --> 00:25:06,760
code it's now bearing in mind of course

00:25:04,390 --> 00:25:10,660
as again with almost everything around

00:25:06,760 --> 00:25:12,010
it this is a function so our dope pipe

00:25:10,660 --> 00:25:13,809
is a function that takes a single

00:25:12,010 --> 00:25:16,000
parameter which is whatever it is that's

00:25:13,809 --> 00:25:18,160
been supplied in which hopefully is a

00:25:16,000 --> 00:25:20,049
number you probably want to actually do

00:25:18,160 --> 00:25:21,429
some validation of that in the real

00:25:20,049 --> 00:25:24,130
world but I'll keep it means a little

00:25:21,429 --> 00:25:26,710
simple here so other pipe takes our

00:25:24,130 --> 00:25:29,380
single parameter which will be our

00:25:26,710 --> 00:25:31,990
hundred degrees and then it passes it to

00:25:29,380 --> 00:25:35,380
the first function in the chain which is

00:25:31,990 --> 00:25:36,809
a subtract and we're filling in the

00:25:35,380 --> 00:25:39,380
blank here so it's taking whatever that

00:25:36,809 --> 00:25:41,440
parameter passed in is

00:25:39,380 --> 00:25:44,090
filling it in there subtracting 32

00:25:41,440 --> 00:25:46,280
whatever the results of that is pipe

00:25:44,090 --> 00:25:48,440
will now push it in to this one it's a

00:25:46,280 --> 00:25:50,810
multiplied by five whatever the result

00:25:48,440 --> 00:25:52,760
of that is will push into here and then

00:25:50,810 --> 00:25:56,870
we'll fill that final value here and

00:25:52,760 --> 00:25:58,820
divide it by 9 this in its very simplest

00:25:56,870 --> 00:26:01,400
form is a monad in case anyone was

00:25:58,820 --> 00:26:03,830
interested there's more to a monad than

00:26:01,400 --> 00:26:07,550
this but this is the very simplest

00:26:03,830 --> 00:26:10,670
version of that that concept a relay

00:26:07,550 --> 00:26:13,340
race just a series of operations each

00:26:10,670 --> 00:26:15,110
one passing a value to the next after

00:26:13,340 --> 00:26:17,240
operating on it until finally we

00:26:15,110 --> 00:26:22,730
collapse out to a final value at the end

00:26:17,240 --> 00:26:24,980
and returning to our our function here

00:26:22,730 --> 00:26:27,080
this is our parser so if we wanted to

00:26:24,980 --> 00:26:31,760
convert all of this into a rounded up

00:26:27,080 --> 00:26:34,670
structure we can now use our pipe yep

00:26:31,760 --> 00:26:36,770
there we go like that so Piper says give

00:26:34,670 --> 00:26:39,680
me the value then I will do our dot

00:26:36,770 --> 00:26:42,110
split and again all of these are curried

00:26:39,680 --> 00:26:43,760
functions these all generally take one

00:26:42,110 --> 00:26:45,650
more parameter than you're seeing here

00:26:43,760 --> 00:26:47,810
and that final parameter is almost

00:26:45,650 --> 00:26:51,350
always the value of the data on which to

00:26:47,810 --> 00:26:53,630
operate so I am splitting on new line

00:26:51,350 --> 00:26:55,250
then I'm doing a map and our dot map is

00:26:53,630 --> 00:26:57,050
just the same as a map as we're used to

00:26:55,250 --> 00:26:59,960
it and into that I'm passing the

00:26:57,050 --> 00:27:03,290
function R or split so split on new line

00:26:59,960 --> 00:27:06,770
split each line of that on comma then a

00:27:03,290 --> 00:27:08,290
filter which is filling it in longhand

00:27:06,770 --> 00:27:10,220
there I'm actually creating an arrow

00:27:08,290 --> 00:27:12,830
function to do that there's probably a

00:27:10,220 --> 00:27:15,860
smarter way but that's that looks good

00:27:12,830 --> 00:27:19,310
enough to me and finally a mod map where

00:27:15,860 --> 00:27:21,140
I'm passing it order n which is that

00:27:19,310 --> 00:27:22,720
means go through the entire array and

00:27:21,140 --> 00:27:25,160
select out the first item from it and

00:27:22,720 --> 00:27:27,170
functionally this is exactly identical

00:27:25,160 --> 00:27:29,660
to all the previous versions of the

00:27:27,170 --> 00:27:31,490
parser you've seen you can run this two

00:27:29,660 --> 00:27:34,310
unit tests you'll get the precise same

00:27:31,490 --> 00:27:38,300
results but this is a bit more compact

00:27:34,310 --> 00:27:41,730
and we're relying a lot more on code

00:27:38,300 --> 00:27:45,120
that someone else has provided for us

00:27:41,730 --> 00:27:47,430
so moving on to another sort of example

00:27:45,120 --> 00:27:51,180
of the sort of functional structures we

00:27:47,430 --> 00:27:53,880
we would do this is a password validator

00:27:51,180 --> 00:27:56,730
it's a password validator with a series

00:27:53,880 --> 00:27:58,530
of rules but it's quite long it's got a

00:27:56,730 --> 00:28:01,500
lot of repeated structure with these

00:27:58,530 --> 00:28:03,660
early return falses and we could compact

00:28:01,500 --> 00:28:06,000
this down a whole load make this a bit

00:28:03,660 --> 00:28:07,500
easier to follow because I've seen how

00:28:06,000 --> 00:28:09,930
out of hand these things can get if you

00:28:07,500 --> 00:28:12,540
let them I've seen functions of this

00:28:09,930 --> 00:28:15,300
sort that end up growing so much they

00:28:12,540 --> 00:28:17,010
end up looking like family trees and the

00:28:15,300 --> 00:28:18,900
functional structure will tend to

00:28:17,010 --> 00:28:23,580
restrict people in terms of how much of

00:28:18,900 --> 00:28:26,840
that sort of craziness they try so we've

00:28:23,580 --> 00:28:26,840
got our rules we must not be

00:28:27,190 --> 00:28:31,750
not be undefined and then convert to a

00:28:29,800 --> 00:28:34,840
string and then we're saying it must be

00:28:31,750 --> 00:28:37,180
a less than or equal to it must be

00:28:34,840 --> 00:28:42,190
greater than ten it must not be Justin

00:28:37,180 --> 00:28:44,370
Bieber because it must not so that first

00:28:42,190 --> 00:28:46,960
bit is e that last bit sorry is easy a

00:28:44,370 --> 00:28:49,210
function in RAM de to determine whether

00:28:46,960 --> 00:28:52,150
something equals Justin Bieber is easy

00:28:49,210 --> 00:28:54,100
that's just our dot equals so this again

00:28:52,150 --> 00:28:56,320
is a curried function so whatever you

00:28:54,100 --> 00:28:58,060
pass into is evil now it will evaluate

00:28:56,320 --> 00:29:01,930
it against this and to tell me whether

00:28:58,060 --> 00:29:03,220
or not it's it's to say this is what

00:29:01,930 --> 00:29:07,030
we've actually generated behind the

00:29:03,220 --> 00:29:10,450
scenes but if we want to find out if it

00:29:07,030 --> 00:29:13,360
is not that if we want to reverse the

00:29:10,450 --> 00:29:16,570
the logic of that's that function then

00:29:13,360 --> 00:29:20,530
add a compliment is what we would use so

00:29:16,570 --> 00:29:23,830
hard a compliment takes a function that

00:29:20,530 --> 00:29:26,980
returns boolean and then it returns you

00:29:23,830 --> 00:29:30,100
back another function but one which does

00:29:26,980 --> 00:29:32,050
the opposite of that so this r dot

00:29:30,100 --> 00:29:32,740
equals checks whether we are equal to

00:29:32,050 --> 00:29:35,320
Justin Bieber

00:29:32,740 --> 00:29:38,410
they are the complement of that checks

00:29:35,320 --> 00:29:44,760
that we are not equal so it is not X is

00:29:38,410 --> 00:29:44,760
triple equal to Justin Bieber easy and

00:29:45,180 --> 00:29:51,100
if we wanted to assert against

00:29:47,890 --> 00:29:54,310
properties well that's not too difficult

00:29:51,100 --> 00:29:57,940
either this prop eke does exactly that

00:29:54,310 --> 00:29:59,800
it says that this sir here gets back a

00:29:57,940 --> 00:30:03,970
function which asserts that the property

00:29:59,800 --> 00:30:07,960
B is equal to capital B so if we were to

00:30:03,970 --> 00:30:09,460
feed this function this object we get

00:30:07,960 --> 00:30:12,940
back a true because it does have a B and

00:30:09,460 --> 00:30:16,260
a B so that's fine but the property that

00:30:12,940 --> 00:30:18,550
we want to assert against is length and

00:30:16,260 --> 00:30:20,680
we don't want to say that it's equal to

00:30:18,550 --> 00:30:23,410
something we want to say that it's

00:30:20,680 --> 00:30:24,640
within a range now there is actually

00:30:23,410 --> 00:30:27,700
another function for doing this in

00:30:24,640 --> 00:30:30,100
rambler and that's prop satisfies and

00:30:27,700 --> 00:30:35,250
what prop satisfies requires is wouldn't

00:30:30,100 --> 00:30:36,900
you know it a function which is the

00:30:35,250 --> 00:30:38,580
hurt that's the predicate that we're

00:30:36,900 --> 00:30:40,860
saying has to be met in order for this

00:30:38,580 --> 00:30:42,540
prop satisfies to return true so we're

00:30:40,860 --> 00:30:44,580
saying that whatever this property is it

00:30:42,540 --> 00:30:45,780
has to be greater than 2 here we're

00:30:44,580 --> 00:30:48,360
saying that the property we're asserting

00:30:45,780 --> 00:30:51,000
against his length so this now has

00:30:48,360 --> 00:30:54,180
returned a function which will check the

00:30:51,000 --> 00:30:55,800
length of any given object you pass to

00:30:54,180 --> 00:30:58,980
it and assert that it's length is

00:30:55,800 --> 00:31:01,680
greater than 2 now we can go step

00:30:58,980 --> 00:31:03,930
further and just use our GT greater than

00:31:01,680 --> 00:31:08,780
and pass it to and we've got back

00:31:03,930 --> 00:31:14,910
exactly the same thing so this then is

00:31:08,780 --> 00:31:17,550
the new version of my password rules so

00:31:14,910 --> 00:31:21,900
I'm using a structure here called our

00:31:17,550 --> 00:31:23,580
dot all now all would be they're

00:31:21,900 --> 00:31:27,870
certainly very familiar to me from my

00:31:23,580 --> 00:31:30,720
c-sharp days and what all means is I am

00:31:27,870 --> 00:31:33,720
going to give a whole list of functions

00:31:30,720 --> 00:31:37,800
and I'm going to evaluate them one after

00:31:33,720 --> 00:31:40,650
the other and given that any of them

00:31:37,800 --> 00:31:42,960
return false then I will terminate the

00:31:40,650 --> 00:31:47,100
sole thing early and return out false

00:31:42,960 --> 00:31:48,780
and in this case what we're doing is

00:31:47,100 --> 00:31:50,820
this again is a single parameter

00:31:48,780 --> 00:31:53,070
function this whole thing validate

00:31:50,820 --> 00:31:54,990
password is a function which takes a

00:31:53,070 --> 00:31:57,900
single parameter which is our data which

00:31:54,990 --> 00:32:00,230
will be hopefully our password one

00:31:57,900 --> 00:32:00,230
second

00:32:00,740 --> 00:32:09,480
sorry so and it's pressing that same

00:32:06,000 --> 00:32:12,870
value one after the other into each of

00:32:09,480 --> 00:32:15,540
these functions I have generated so the

00:32:12,870 --> 00:32:18,240
first is actually an r dot is nil

00:32:15,540 --> 00:32:21,060
and this is our catch-all check against

00:32:18,240 --> 00:32:23,190
whether the value of the variable is

00:32:21,060 --> 00:32:25,800
defined or not and I'm doing the r dot

00:32:23,190 --> 00:32:27,810
complement of it so this effectively

00:32:25,800 --> 00:32:31,680
means first check that this thing is

00:32:27,810 --> 00:32:34,140
undefined or whatever and this thing

00:32:31,680 --> 00:32:38,160
means do the inverse so what I'm saying

00:32:34,140 --> 00:32:39,600
is that I'm actually saying that all of

00:32:38,160 --> 00:32:42,930
these things have to be true in order to

00:32:39,600 --> 00:32:45,630
be validated so this is an effector it's

00:32:42,930 --> 00:32:50,370
not nil it's not undefined it's not

00:32:45,630 --> 00:32:51,840
whatever our dough is is so flippin

00:32:50,370 --> 00:32:55,770
useful that I would use it all over the

00:32:51,840 --> 00:32:58,200
place and this is passing the type as it

00:32:55,770 --> 00:32:59,940
were that you wish to check it to be and

00:32:58,200 --> 00:33:03,750
it'll tell you what that's true or not

00:32:59,940 --> 00:33:05,010
so I'm saying R that is string so we've

00:33:03,750 --> 00:33:06,930
passed in our password we're checking

00:33:05,010 --> 00:33:10,440
that it's not undefined now we're

00:33:06,930 --> 00:33:13,100
checking that it's a string so the rest

00:33:10,440 --> 00:33:15,810
of the predicate can't continue

00:33:13,100 --> 00:33:17,790
safely on the assumption that this is a

00:33:15,810 --> 00:33:19,260
string because otherwise once we start

00:33:17,790 --> 00:33:20,570
checking its length it could be an array

00:33:19,260 --> 00:33:24,060
or who knows what

00:33:20,570 --> 00:33:25,410
so prop satisfied I'm saying greater

00:33:24,060 --> 00:33:27,330
than 2

00:33:25,410 --> 00:33:30,270
and props satisfied less than or equal

00:33:27,330 --> 00:33:32,370
to ten so that's our lengths satisfied

00:33:30,270 --> 00:33:36,770
and also that it is not just in Bieber

00:33:32,370 --> 00:33:39,240
because it must not be so all of that

00:33:36,770 --> 00:33:42,960
gives us our set of password rules but

00:33:39,240 --> 00:33:46,200
again written in a fairly nice fairly

00:33:42,960 --> 00:33:48,870
easy to read way it's very easy to

00:33:46,200 --> 00:33:50,370
understand how exactly to modify if if I

00:33:48,870 --> 00:33:51,690
were ever to throw in a new rule it

00:33:50,370 --> 00:33:53,850
would literally just be an extra one

00:33:51,690 --> 00:33:58,260
line in this structure or maybe a

00:33:53,850 --> 00:33:59,850
modification and it's I would argue it's

00:33:58,260 --> 00:34:01,080
a lot easier to work with I mean there

00:33:59,850 --> 00:34:03,840
is a little bit of the overhead of this

00:34:01,080 --> 00:34:05,790
i dot business but once you pass that

00:34:03,840 --> 00:34:11,820
the rest of it's quite easy to work with

00:34:05,790 --> 00:34:13,820
so another example require us to do some

00:34:11,820 --> 00:34:15,780
slightly different work and this is

00:34:13,820 --> 00:34:17,040
something that probably an awful lot of

00:34:15,780 --> 00:34:20,550
us and the programming base will be

00:34:17,040 --> 00:34:22,560
familiar with and that's fizzbuzz for

00:34:20,550 --> 00:34:24,200
those unfamiliar in them I'm not

00:34:22,560 --> 00:34:27,300
thinking there's gonna be many of you

00:34:24,200 --> 00:34:30,360
this is a very simple game where we

00:34:27,300 --> 00:34:33,330
write out numbers if one of them is

00:34:30,360 --> 00:34:36,419
divisible by three we had fears if it's

00:34:33,330 --> 00:34:38,940
divisible by five we had buzz if it's

00:34:36,419 --> 00:34:43,650
divisible by both like fifteen we add

00:34:38,940 --> 00:34:46,919
fizz buzz I don't know why but this this

00:34:43,650 --> 00:34:50,850
is the go-to coding exercise I often get

00:34:46,919 --> 00:34:53,400
set in interviews but so how do

00:34:50,850 --> 00:34:53,970
we do this using our functional rammed a

00:34:53,400 --> 00:34:55,860
code

00:34:53,970 --> 00:34:59,670
well first off we'll need a map of

00:34:55,860 --> 00:35:01,230
course and I will get onto exactly what

00:34:59,670 --> 00:35:03,690
the implementation of this cat this is

00:35:01,230 --> 00:35:05,970
this is the thing that says given a

00:35:03,690 --> 00:35:08,120
number here's the output that I'm gonna

00:35:05,970 --> 00:35:11,040
give you either a number or a string

00:35:08,120 --> 00:35:13,560
I'll get into that in a second but first

00:35:11,040 --> 00:35:16,740
we're generating a range now the range

00:35:13,560 --> 00:35:20,790
is saying generate me an array between

00:35:16,740 --> 00:35:23,370
Oh length water between which has values

00:35:20,790 --> 00:35:26,670
in it between one and whatever num is

00:35:23,370 --> 00:35:27,960
whatever the whatever the highest number

00:35:26,670 --> 00:35:32,190
that you want in my previous example

00:35:27,960 --> 00:35:35,730
it's twenty so this is generating as an

00:35:32,190 --> 00:35:36,200
array of integers between 1 and 20 and

00:35:35,730 --> 00:35:38,359
then

00:35:36,200 --> 00:35:45,050
map with feeding each and every one of

00:35:38,359 --> 00:35:45,380
those into this function here so another

00:35:45,050 --> 00:35:48,200
straw

00:35:45,380 --> 00:35:51,380
to introduce that's the if-else we'll be

00:35:48,200 --> 00:35:54,290
using that in just a moment and this is

00:35:51,380 --> 00:35:57,020
a handy little kind of light logical

00:35:54,290 --> 00:35:58,850
switch statement and this again is a

00:35:57,020 --> 00:36:00,920
function and takes a single parameter

00:35:58,850 --> 00:36:03,620
like everything else and it's saying

00:36:00,920 --> 00:36:06,080
first off whatever the parameter is pass

00:36:03,620 --> 00:36:10,070
it into the first item in the structure

00:36:06,080 --> 00:36:11,180
that's in my case it's R equals 5 so

00:36:10,070 --> 00:36:13,820
what it's saying is whatever they've

00:36:11,180 --> 00:36:16,340
been passed into this function here pass

00:36:13,820 --> 00:36:21,580
it here and this will tell me whether or

00:36:16,340 --> 00:36:22,710
not it equals 5 if it does equal 5 then

00:36:21,580 --> 00:36:25,260
passage

00:36:22,710 --> 00:36:28,380
to this function and do the

00:36:25,260 --> 00:36:31,290
transformation now always means that's

00:36:28,380 --> 00:36:33,240
what it always returns so always means

00:36:31,290 --> 00:36:38,330
disregard the parameter and just return

00:36:33,240 --> 00:36:42,510
this so if it is five we get back f i-b

00:36:38,330 --> 00:36:44,910
e5 as a string otherwise pass the

00:36:42,510 --> 00:36:46,800
parameter into this one identity now

00:36:44,910 --> 00:36:49,680
identity actually also means disregard

00:36:46,800 --> 00:36:52,260
the parameter well no it doesn't what it

00:36:49,680 --> 00:36:55,530
means is take the parameter and just

00:36:52,260 --> 00:36:57,359
return it completely unmodified so a

00:36:55,530 --> 00:37:00,119
little if-else structure here is saying

00:36:57,359 --> 00:37:02,550
take a parameter check whether it's five

00:37:00,119 --> 00:37:05,310
if it's five return back the texture

00:37:02,550 --> 00:37:08,670
five otherwise if it was three let's say

00:37:05,310 --> 00:37:11,839
then return that back that three exactly

00:37:08,670 --> 00:37:11,839
as it was without touching it

00:37:13,290 --> 00:37:18,420
so moving on we've got

00:37:19,250 --> 00:37:26,880
we've got a pipe here and the pipe is

00:37:22,770 --> 00:37:29,850
using the if-else so this is a pipe so

00:37:26,880 --> 00:37:32,220
it's passing the parameter this this is

00:37:29,850 --> 00:37:34,860
the thing that's called by the map in

00:37:32,220 --> 00:37:37,470
our previous line of code so that means

00:37:34,860 --> 00:37:40,410
that this is operating on each item in

00:37:37,470 --> 00:37:42,240
this range array between 1 and 20 so the

00:37:40,410 --> 00:37:44,580
parameter to these is an integer between

00:37:42,240 --> 00:37:46,200
1 and 20 its operating on each one

00:37:44,580 --> 00:37:48,560
individually one after the other and

00:37:46,200 --> 00:37:52,110
it's checking them against these rules

00:37:48,560 --> 00:37:55,230
it's saying first is it divisible by 3

00:37:52,110 --> 00:37:57,960
I'll get onto that in a moment and if it

00:37:55,230 --> 00:38:01,140
is do add up concatenate I'm putting the

00:37:57,960 --> 00:38:04,950
hole here to say my original item goes

00:38:01,140 --> 00:38:08,130
here and then we append fizz otherwise

00:38:04,950 --> 00:38:11,340
if it is not divisible by 3 then our

00:38:08,130 --> 00:38:14,280
identity that means return the original

00:38:11,340 --> 00:38:17,880
value back unmodified similarly here if

00:38:14,280 --> 00:38:22,320
it's divisible by 5 then we concatenate

00:38:17,880 --> 00:38:25,530
buzz so that's a pipe and we are either

00:38:22,320 --> 00:38:28,760
a concatenated a 3 we concatenate F is

00:38:25,530 --> 00:38:31,109
where all of buzz or if neither of those

00:38:28,760 --> 00:38:33,810
divisible x' were true then we're simply

00:38:31,109 --> 00:38:36,540
returning identity an unmodified value

00:38:33,810 --> 00:38:38,670
so that's all of our logic for doing our

00:38:36,540 --> 00:38:40,340
fizzbuzz pretty much in that one

00:38:38,670 --> 00:38:42,720
statement

00:38:40,340 --> 00:38:45,359
Medan diddly is divisible by by the way

00:38:42,720 --> 00:38:48,840
looks a bit like this and that's a pipe

00:38:45,359 --> 00:38:50,869
where we pass it math mod is our modulus

00:38:48,840 --> 00:38:53,040
by bathing in a mathematical way which

00:38:50,869 --> 00:38:54,930
apparently the the percentage in

00:38:53,040 --> 00:38:58,830
JavaScript doesn't always we're saying

00:38:54,930 --> 00:39:00,900
pop the value there num is 3 or 5 as

00:38:58,830 --> 00:39:03,630
appropriate and then we're saying return

00:39:00,900 --> 00:39:06,930
back whenever this was passed into

00:39:03,630 --> 00:39:11,609
equals compared here at zero so there we

00:39:06,930 --> 00:39:13,890
go that's a divisible by 1 of the last

00:39:11,609 --> 00:39:15,840
of my examples so this is a card game

00:39:13,890 --> 00:39:17,850
that was introduced to me as pontoon

00:39:15,840 --> 00:39:20,640
but apparent in the US is known as

00:39:17,850 --> 00:39:23,010
blackjack I've also heard it called 21

00:39:20,640 --> 00:39:24,810
and a few other names but the basic idea

00:39:23,010 --> 00:39:26,820
is that you're taking cards one after

00:39:24,810 --> 00:39:28,650
the other from the dealer if it's a

00:39:26,820 --> 00:39:31,440
number card it's equal to that number if

00:39:28,650 --> 00:39:32,740
it's a jack or a queen or a king the

00:39:31,440 --> 00:39:35,320
value of that is 10

00:39:32,740 --> 00:39:38,200
the ace actually is equal to either 1 or

00:39:35,320 --> 00:39:40,030
11 I've simplified a little because I

00:39:38,200 --> 00:39:42,640
don't want to get bogged down too much

00:39:40,030 --> 00:39:44,200
so I'm saying the ACE is 11 and the idea

00:39:42,640 --> 00:39:47,050
is that you're taking cards to get as

00:39:44,200 --> 00:39:51,609
close to 21 as you can but if you go

00:39:47,050 --> 00:39:52,119
over 21 then you've lost it amused me as

00:39:51,609 --> 00:39:55,960
a kid

00:39:52,119 --> 00:39:58,089
and if you wanted to do old scale school

00:39:55,960 --> 00:40:01,750
you'd do something like this if

00:39:58,089 --> 00:40:03,070
statement stuff all over the place but

00:40:01,750 --> 00:40:05,920
all we're doing is the scoring at the

00:40:03,070 --> 00:40:12,099
moment my dad is because frankly it's

00:40:05,920 --> 00:40:14,440
too useful not to so there is an r dot

00:40:12,099 --> 00:40:16,900
contains because I don't want to do big

00:40:14,440 --> 00:40:19,150
long strings of ifs looking at Queen

00:40:16,900 --> 00:40:20,800
looking at King so on when the answer is

00:40:19,150 --> 00:40:22,359
all the same I'd want to do one I want

00:40:20,800 --> 00:40:23,770
to compact that a bit further the

00:40:22,359 --> 00:40:26,440
problem is our dock contains as it works

00:40:23,770 --> 00:40:29,470
in a slightly interesting way for what

00:40:26,440 --> 00:40:32,109
I'm used to and that is that first you

00:40:29,470 --> 00:40:34,480
say the thing that should be contained

00:40:32,109 --> 00:40:36,640
in the array then you pass the array

00:40:34,480 --> 00:40:38,920
which is the other way around to what

00:40:36,640 --> 00:40:40,330
I'd kind of was kind of like I would

00:40:38,920 --> 00:40:41,740
like the array and then I would like to

00:40:40,330 --> 00:40:44,589
pass in the thing to check it contains

00:40:41,740 --> 00:40:47,470
so all of that just means that we need

00:40:44,589 --> 00:40:49,330
to use another r dot underscore

00:40:47,470 --> 00:40:52,869
underscore to fill in the two till it's

00:40:49,330 --> 00:40:54,400
fill in the blank here but this is using

00:40:52,869 --> 00:40:56,980
another functional structure called

00:40:54,400 --> 00:40:59,890
which round is called cond can't for

00:40:56,980 --> 00:41:02,290
condition and each parameter to this

00:40:59,890 --> 00:41:04,839
this whole thing is an array and each

00:41:02,290 --> 00:41:07,869
item in the array is itself an array a

00:41:04,839 --> 00:41:10,750
two-part array the left-hand side of

00:41:07,869 --> 00:41:12,810
each of these is a predicate that is

00:41:10,750 --> 00:41:15,190
something that takes the parameter

00:41:12,810 --> 00:41:18,160
evaluates it and then returns a true or

00:41:15,190 --> 00:41:23,710
a false this true or false is does this

00:41:18,160 --> 00:41:26,830
rule apply so our dough is a number

00:41:23,710 --> 00:41:30,160
means if whatever the per the parameter

00:41:26,830 --> 00:41:32,800
is is a number then simply return it

00:41:30,160 --> 00:41:34,750
unmodified moving on to the next line

00:41:32,800 --> 00:41:37,690
we've got a slightly more complicated

00:41:34,750 --> 00:41:39,060
condition and that's it contains and I'm

00:41:37,690 --> 00:41:41,160
saying

00:41:39,060 --> 00:41:43,410
our blank is here so we're filling in

00:41:41,160 --> 00:41:45,900
here and I'm saying look in this array

00:41:43,410 --> 00:41:48,990
if our value is contained within this

00:41:45,900 --> 00:41:52,590
array return ten so two are two always

00:41:48,990 --> 00:41:55,050
ten otherwise if it's an ace and are

00:41:52,590 --> 00:41:56,460
there always for eleven so this

00:41:55,050 --> 00:41:59,220
structure this is pattern recognition

00:41:56,460 --> 00:42:02,000
this is what it is where it's kind of

00:41:59,220 --> 00:42:04,200
like a switch statement but with full on

00:42:02,000 --> 00:42:08,100
functional expressions on the left hand

00:42:04,200 --> 00:42:10,020
side rather than simply checking against

00:42:08,100 --> 00:42:12,570
value and then on the right hand side

00:42:10,020 --> 00:42:15,540
again we've got a full-on function of

00:42:12,570 --> 00:42:18,930
some kind this sort of structure is

00:42:15,540 --> 00:42:20,970
extremely powerful and can enable you to

00:42:18,930 --> 00:42:24,350
write an awful lot of code that would

00:42:20,970 --> 00:42:29,100
otherwise be complicated and long-winded

00:42:24,350 --> 00:42:30,810
and they're moving on too so if you want

00:42:29,100 --> 00:42:34,230
to imagine the sort of basic functional

00:42:30,810 --> 00:42:36,000
flow we start with an item let's call it

00:42:34,230 --> 00:42:38,100
strength generally speaking the first

00:42:36,000 --> 00:42:40,800
option either chance you get you split

00:42:38,100 --> 00:42:43,260
it into an array of strings or string or

00:42:40,800 --> 00:42:46,220
whatever maybe you do aware or something

00:42:43,260 --> 00:42:49,920
or a filter rather to reduce the number

00:42:46,220 --> 00:42:51,990
select or Maps rather to convert to

00:42:49,920 --> 00:42:54,300
something else then finally aggregate

00:42:51,990 --> 00:42:55,980
into a single value again that's the

00:42:54,300 --> 00:42:57,540
sort of standard flow that will run

00:42:55,980 --> 00:43:00,210
through when we're doing a functional

00:42:57,540 --> 00:43:01,830
process but this aggregation is the last

00:43:00,210 --> 00:43:05,130
step in the process I haven't really

00:43:01,830 --> 00:43:07,890
touched on so far there are some

00:43:05,130 --> 00:43:09,870
built-in simple aggregators some will do

00:43:07,890 --> 00:43:12,870
exactly what you think pass it at a rate

00:43:09,870 --> 00:43:15,750
you get back the some mean it takes you

00:43:12,870 --> 00:43:18,390
an average easy but we want to do

00:43:15,750 --> 00:43:21,900
something slightly more complicated we

00:43:18,390 --> 00:43:24,720
want to take an array of cards in our

00:43:21,900 --> 00:43:26,760
hand so in my imaginary example I've got

00:43:24,720 --> 00:43:29,550
a wire a 5 and okay so that's one five

00:43:26,760 --> 00:43:34,230
and a king Kings worth 10 so that's 16

00:43:29,550 --> 00:43:36,360
and I want to convert all of this into a

00:43:34,230 --> 00:43:37,890
single value of the score and that's

00:43:36,360 --> 00:43:40,920
where our dot reduce

00:43:37,890 --> 00:43:43,610
comes in so add it reduce takes a

00:43:40,920 --> 00:43:46,560
function with two parameters the

00:43:43,610 --> 00:43:51,150
accumulator and the value so the

00:43:46,560 --> 00:43:53,100
accumulator is the running total so far

00:43:51,150 --> 00:43:56,430
and the value is the current item out of

00:43:53,100 --> 00:43:58,590
the array it also need to pass it the

00:43:56,430 --> 00:44:00,240
starting value which when we're

00:43:58,590 --> 00:44:04,320
calculating our scoring cards is is

00:44:00,240 --> 00:44:06,390
going to be zero so when we run this the

00:44:04,320 --> 00:44:08,790
first time the accumulator will be zero

00:44:06,390 --> 00:44:10,350
because that's here the value will be

00:44:08,790 --> 00:44:12,810
the first item out of our array which is

00:44:10,350 --> 00:44:15,960
a 1 and so we're saying that the new

00:44:12,810 --> 00:44:19,500
running total is accumulator that is the

00:44:15,960 --> 00:44:21,450
old running total add the score of the

00:44:19,500 --> 00:44:22,860
card which is over here that's this

00:44:21,450 --> 00:44:26,640
function that we created this this

00:44:22,860 --> 00:44:29,610
pattern recognition structure so 1 will

00:44:26,640 --> 00:44:31,470
go into scorecard it'll actually match

00:44:29,610 --> 00:44:35,280
there is a number come back as identity

00:44:31,470 --> 00:44:38,370
so the new running total is 1 so then

00:44:35,280 --> 00:44:41,310
we'll call this function again and the

00:44:38,370 --> 00:44:44,400
new accumulator is 1 the new value is

00:44:41,310 --> 00:44:47,490
now 5 and we're saying that that is

00:44:44,400 --> 00:44:49,950
equal to the old value that is 1 plus

00:44:47,490 --> 00:44:52,100
the score now again it will be 5 so that

00:44:49,950 --> 00:44:54,630
means that the new accumulator is 6

00:44:52,100 --> 00:44:57,780
calling this again we've got 6 here and

00:44:54,630 --> 00:45:00,060
we've got K here so when that goes into

00:44:57,780 --> 00:45:02,610
our score card this will not match so we

00:45:00,060 --> 00:45:05,100
won't do identity this won't will though

00:45:02,610 --> 00:45:07,140
and it will match on King so that means

00:45:05,100 --> 00:45:11,520
we'll bring back at 10 so finally we'll

00:45:07,140 --> 00:45:14,220
get back our 16 took me an awful long

00:45:11,520 --> 00:45:16,320
time to explain that but didn't take me

00:45:14,220 --> 00:45:17,820
very long to write it and once you're

00:45:16,320 --> 00:45:19,980
used to working with this pattern it's

00:45:17,820 --> 00:45:24,570
not really all that difficult to throw

00:45:19,980 --> 00:45:28,710
these together and if we want to go

00:45:24,570 --> 00:45:31,170
another step further more complicated we

00:45:28,710 --> 00:45:34,350
could do a pipe which is first which

00:45:31,170 --> 00:45:38,160
then first as I reduce which is reducing

00:45:34,350 --> 00:45:40,860
our array down from this list of curve

00:45:38,160 --> 00:45:44,270
cards to a value and then do an if else

00:45:40,860 --> 00:45:46,560
to say if it's less than or equal to 21

00:45:44,270 --> 00:45:49,770
we'll do identity so that's your actual

00:45:46,560 --> 00:45:52,950
score otherwise we'll do it always with

00:45:49,770 --> 00:45:54,540
bust so in my examine example if we pass

00:45:52,950 --> 00:45:58,350
in the 1 the 5 and the King will again

00:45:54,540 --> 00:45:59,340
back a 16 otherwise if we have a queen

00:45:58,350 --> 00:46:02,700
in there too

00:45:59,340 --> 00:46:04,680
now the Queen will take 16 to 26 and

00:46:02,700 --> 00:46:08,730
that means that we will

00:46:04,680 --> 00:46:11,400
being bussed there again

00:46:08,730 --> 00:46:16,260
awful long time to explain not much time

00:46:11,400 --> 00:46:19,920
to read or to understand so this is the

00:46:16,260 --> 00:46:22,470
last bit and then you can all relax so

00:46:19,920 --> 00:46:23,880
I've got a hypothetical DB get of some

00:46:22,470 --> 00:46:26,010
description I don't really know what

00:46:23,880 --> 00:46:27,750
it's doing I don't really care and it's

00:46:26,010 --> 00:46:30,839
getting a wreck or based on an ID and

00:46:27,750 --> 00:46:33,809
inside this is a data object of some

00:46:30,839 --> 00:46:37,050
kind it's I'm imagining its user data or

00:46:33,809 --> 00:46:40,109
something of that sort and I want to say

00:46:37,050 --> 00:46:44,190
hello to whomever I've details I've just

00:46:40,109 --> 00:46:45,630
fetched possibly the devil and I will

00:46:44,190 --> 00:46:49,380
call first name or that put it into a

00:46:45,630 --> 00:46:52,260
string now that's fine provided that

00:46:49,380 --> 00:46:55,920
this actually works that we actually do

00:46:52,260 --> 00:46:58,290
have a record coming out of this and

00:46:55,920 --> 00:47:01,260
this is not just undefined because

00:46:58,290 --> 00:47:02,910
otherwise this is gonna explode so there

00:47:01,260 --> 00:47:05,339
is a structure in functional programming

00:47:02,910 --> 00:47:07,349
that would allow us to do this sort of

00:47:05,339 --> 00:47:09,930
thing without having to in say a sort in

00:47:07,349 --> 00:47:11,430
an awful lot of checks against undefined

00:47:09,930 --> 00:47:13,859
all over the place

00:47:11,430 --> 00:47:17,089
muddying up the code and getting in the

00:47:13,859 --> 00:47:19,859
way of understanding what's going on

00:47:17,089 --> 00:47:22,619
this is one way of implementing it I've

00:47:19,859 --> 00:47:26,970
seen it done all sorts of other ways but

00:47:22,619 --> 00:47:29,780
typically it's called maybe and maybe is

00:47:26,970 --> 00:47:32,490
an object that just contains a value I

00:47:29,780 --> 00:47:33,869
think of it as a thing of the box so

00:47:32,490 --> 00:47:35,460
we've got our value we're popping it

00:47:33,869 --> 00:47:37,950
inside the box maybe is the name of the

00:47:35,460 --> 00:47:39,869
box and we've got two functions hanging

00:47:37,950 --> 00:47:41,609
up its prototype the first is to get

00:47:39,869 --> 00:47:43,859
Bali which is just take the thing out of

00:47:41,609 --> 00:47:49,020
the box and hand it over and the second

00:47:43,859 --> 00:47:52,410
is bind a bind takes a function and what

00:47:49,020 --> 00:47:56,250
we do is we check whether this this

00:47:52,410 --> 00:47:57,150
value is actually defined or not if it's

00:47:56,250 --> 00:48:00,660
not defined

00:47:57,150 --> 00:48:02,839
we will not execute the function we'll

00:48:00,660 --> 00:48:06,720
just return another maybe with undefined

00:48:02,839 --> 00:48:08,880
contained within it otherwise we'll

00:48:06,720 --> 00:48:11,940
return a new maybe and this time we will

00:48:08,880 --> 00:48:14,069
execute func whatever this is with the

00:48:11,940 --> 00:48:15,290
value from inside our box popped into

00:48:14,069 --> 00:48:17,420
that

00:48:15,290 --> 00:48:20,720
and that's what it would actually look

00:48:17,420 --> 00:48:23,330
like when you run it so I'm saying my

00:48:20,720 --> 00:48:25,580
message is a new maybe and I'm starting

00:48:23,330 --> 00:48:29,600
with my ID and I'm using bind and

00:48:25,580 --> 00:48:31,490
passing it in a DB get record so X here

00:48:29,600 --> 00:48:33,980
is the six six six and that's going into

00:48:31,490 --> 00:48:36,350
there and that's executing now if this

00:48:33,980 --> 00:48:37,910
worked this means that this would

00:48:36,350 --> 00:48:39,980
actually spurs bind would return a new

00:48:37,910 --> 00:48:42,560
maybe with whatever the result of that

00:48:39,980 --> 00:48:44,870
is popped into it and then the new maybe

00:48:42,560 --> 00:48:48,260
would have a bind on it and this would

00:48:44,870 --> 00:48:50,840
be the result of that and then we could

00:48:48,260 --> 00:48:54,290
safely operate knowing that this is

00:48:50,840 --> 00:48:56,000
defined it might not be a terrible idea

00:48:54,290 --> 00:48:57,890
to possibly put a try-catch around it

00:48:56,000 --> 00:49:00,020
again just in case first name doesn't

00:48:57,890 --> 00:49:01,820
really exist and it finally called that

00:49:00,020 --> 00:49:05,840
value at the end to get the value out of

00:49:01,820 --> 00:49:11,090
it but if on the other hand this return

00:49:05,840 --> 00:49:12,590
nothing then this type of this value

00:49:11,090 --> 00:49:14,510
would be true that would be undefined

00:49:12,590 --> 00:49:16,970
and we're simply gonna return our new

00:49:14,510 --> 00:49:20,810
maybe so that means if DB get record

00:49:16,970 --> 00:49:22,850
return nothing this bind will not run

00:49:20,810 --> 00:49:26,930
this function here this function will

00:49:22,850 --> 00:49:28,430
never be run but an undefined will be

00:49:26,930 --> 00:49:30,530
returned so the value at the end will be

00:49:28,430 --> 00:49:33,020
undefined and we can do something like

00:49:30,530 --> 00:49:33,890
get our Condor whatever to decide what

00:49:33,020 --> 00:49:38,690
to do with it

00:49:33,890 --> 00:49:41,150
but the point is that I've written my my

00:49:38,690 --> 00:49:43,880
flow of operations in this single chain

00:49:41,150 --> 00:49:46,640
and I don't need to start adding in lots

00:49:43,880 --> 00:49:49,040
of codes to check against whether the

00:49:46,640 --> 00:49:50,540
previous operation worked or not I can

00:49:49,040 --> 00:49:52,580
add in as many extra lines as I like and

00:49:50,540 --> 00:49:55,790
all of these can assume that the

00:49:52,580 --> 00:49:59,000
previous step have succeeded because

00:49:55,790 --> 00:50:00,740
otherwise the step will not be executed

00:49:59,000 --> 00:50:02,720
and this is what a monad really is this

00:50:00,740 --> 00:50:05,060
is the sort of thing that we really do

00:50:02,720 --> 00:50:08,450
with them there's a whole load of other

00:50:05,060 --> 00:50:09,830
monads covering all sorts of other other

00:50:08,450 --> 00:50:13,240
eventualities

00:50:09,830 --> 00:50:15,530
you could have monads which return

00:50:13,240 --> 00:50:18,020
different objects depending on where the

00:50:15,530 --> 00:50:20,570
previous steps worked or not you could

00:50:18,020 --> 00:50:22,160
have monads that switch to containing

00:50:20,570 --> 00:50:25,280
error messages and the result that an

00:50:22,160 --> 00:50:27,590
error occurred in fact if you've been

00:50:25,280 --> 00:50:30,260
messing with promises those are a monad

00:50:27,590 --> 00:50:34,340
as well so you may have been using some

00:50:30,260 --> 00:50:36,080
of these longer than you expected so

00:50:34,340 --> 00:50:38,450
I've got about ten minutes left which is

00:50:36,080 --> 00:50:41,020
not bad timing at all does anybody have

00:50:38,450 --> 00:50:44,450
any questions at this point

00:50:41,020 --> 00:50:47,780
thanks a lot Simon I I am in charge of

00:50:44,450 --> 00:50:51,920
the questionnaire site there are

00:50:47,780 --> 00:51:01,760
questions for you all well yeah it's not

00:50:51,920 --> 00:51:03,800
scary how many of them contain abuse the

00:51:01,760 --> 00:51:06,950
first question is for someone who knows

00:51:03,800 --> 00:51:08,810
programming C and Java what do you think

00:51:06,950 --> 00:51:11,960
would be the best functional programming

00:51:08,810 --> 00:51:16,460
language any books you can recommend for

00:51:11,960 --> 00:51:18,470
C and Eve well okay I'm haven't done C

00:51:16,460 --> 00:51:20,540
since I was at university and that's

00:51:18,470 --> 00:51:21,700
longer ago than they really care to

00:51:20,540 --> 00:51:24,860
admit

00:51:21,700 --> 00:51:28,400
Java though I again don't know Java but

00:51:24,860 --> 00:51:30,320
I do know C sharp so C sharp is actually

00:51:28,400 --> 00:51:32,540
a really good one at the moment for

00:51:30,320 --> 00:51:35,020
getting into functional programming

00:51:32,540 --> 00:51:37,130
because as I said right at the beginning

00:51:35,020 --> 00:51:40,280
Microsoft now have a policy of

00:51:37,130 --> 00:51:41,630
introducing more functional abilities to

00:51:40,280 --> 00:51:43,700
their language as they go along they

00:51:41,630 --> 00:51:48,560
things like the the pattern recognition

00:51:43,700 --> 00:51:49,850
it's not entirely as excuse me as

00:51:48,560 --> 00:51:51,110
powerful as the structure I showed you

00:51:49,850 --> 00:51:51,860
there but it's getting there and I

00:51:51,110 --> 00:51:54,500
believe it's something they're

00:51:51,860 --> 00:51:56,990
continuing to work on so I would

00:51:54,500 --> 00:51:58,570
actually recommend a book called the

00:51:56,990 --> 00:52:03,290
it's functional programming in c-sharp

00:51:58,570 --> 00:52:06,410
by Enrico banano it's published by

00:52:03,290 --> 00:52:08,450
Manning and it's honestly one of the

00:52:06,410 --> 00:52:11,990
best programming books I've read in a

00:52:08,450 --> 00:52:12,410
very long time I absolutely adored that

00:52:11,990 --> 00:52:15,500
book

00:52:12,410 --> 00:52:17,120
and it's examples of how you can start

00:52:15,500 --> 00:52:21,560
doing functional programming and c-sharp

00:52:17,120 --> 00:52:24,260
today using no extra libraries and it

00:52:21,560 --> 00:52:26,900
explains things like the monad and the

00:52:24,260 --> 00:52:29,450
pattern recognition system so nicely but

00:52:26,900 --> 00:52:32,450
it's it's easy to work with and the best

00:52:29,450 --> 00:52:34,880
thing you can do is don't just read it

00:52:32,450 --> 00:52:37,910
grab out Visual Studio or whatever and

00:52:34,880 --> 00:52:39,380
do it because a lot of the difficulty in

00:52:37,910 --> 00:52:41,600
understanding functional programming

00:52:39,380 --> 00:52:43,670
often comes from that the concepts and

00:52:41,600 --> 00:52:46,430
getting your head around it and if you

00:52:43,670 --> 00:52:49,880
sit there and do it I almost guarantee

00:52:46,430 --> 00:52:51,830
that would after some time there'll be a

00:52:49,880 --> 00:52:54,710
light bulb moment and suddenly it'll all

00:52:51,830 --> 00:52:56,990
become just obvious and certainly for me

00:52:54,710 --> 00:53:00,020
now I get a little annoyed if I have to

00:52:56,990 --> 00:53:01,880
write everything out longhand as it were

00:53:00,020 --> 00:53:03,290
you know doing it the old way rather

00:53:01,880 --> 00:53:05,840
than doing it the nice quick easy

00:53:03,290 --> 00:53:08,240
functional way so that's that's my

00:53:05,840 --> 00:53:10,970
personal favorite book there is

00:53:08,240 --> 00:53:13,550
functional programming in JavaScript by

00:53:10,970 --> 00:53:15,530
the same publishers I haven't read that

00:53:13,550 --> 00:53:17,780
in a great deal of detail it looked

00:53:15,530 --> 00:53:21,650
quite good but it wasn't entirely what I

00:53:17,780 --> 00:53:24,800
was after personally it uses underscore

00:53:21,650 --> 00:53:27,380
so if you use familiar with underscore

00:53:24,800 --> 00:53:29,510
you might find that one useful but

00:53:27,380 --> 00:53:32,060
personally lamda is is one of my

00:53:29,510 --> 00:53:33,890
all-time favorite libraries for almost

00:53:32,060 --> 00:53:35,360
any programming language ever ever so

00:53:33,890 --> 00:53:37,580
also I'd recommend checking out the

00:53:35,360 --> 00:53:40,690
Rambler website they have extensive

00:53:37,580 --> 00:53:44,120
documentation on how their library works

00:53:40,690 --> 00:53:45,350
nice yeah we'll make sure that we'll get

00:53:44,120 --> 00:53:46,520
the links for the books and we can

00:53:45,350 --> 00:53:49,220
publish them together with the slides

00:53:46,520 --> 00:53:51,530
later on JK Oh tell you what I haven't

00:53:49,220 --> 00:53:52,100
got my good I put my camera on so that

00:53:51,530 --> 00:53:57,520
you nice people

00:53:52,100 --> 00:53:59,960
hey you're currently not visible though

00:53:57,520 --> 00:54:08,600
they can only always cheon's

00:53:59,960 --> 00:54:14,330
I can put your I'm already I'm already

00:54:08,600 --> 00:54:16,160
married I'm sorry what do you think of

00:54:14,330 --> 00:54:19,430
observable hq.com

00:54:16,160 --> 00:54:21,800
if you've heard of it I have not I am

00:54:19,430 --> 00:54:25,190
really sorry and I'm literally writing

00:54:21,800 --> 00:54:26,130
down that right now because I'm I'm so

00:54:25,190 --> 00:54:31,829
sorry but I've never

00:54:26,130 --> 00:54:35,160
all right one last question which goes

00:54:31,829 --> 00:54:41,029
more on the yes what do you think about

00:54:35,160 --> 00:54:43,380
rusts again not heard of that one

00:54:41,029 --> 00:54:45,839
apologies to everybody that's a

00:54:43,380 --> 00:54:49,170
programming language I think isn't it so

00:54:45,839 --> 00:54:50,220
I do not like that in my car I have I

00:54:49,170 --> 00:54:52,729
don't know anything about it as a

00:54:50,220 --> 00:54:54,809
programming language so again apologies

00:54:52,729 --> 00:54:58,380
javascript in c-sharp but predominately

00:54:54,809 --> 00:55:00,839
all they ever work in all right that's

00:54:58,380 --> 00:55:03,390
all the questions we had thanks a lot

00:55:00,839 --> 00:55:07,019
for the talk for me as a Haskell

00:55:03,390 --> 00:55:09,150
evangelist ever since I first saw it's

00:55:07,019 --> 00:55:10,680
it's great to see that functional

00:55:09,150 --> 00:55:11,660
programming is catching on everywhere

00:55:10,680 --> 00:55:14,700
nowadays

00:55:11,660 --> 00:55:15,749
yeah if in fact I was having a chat with

00:55:14,700 --> 00:55:16,920
the summer into it when I was in the

00:55:15,749 --> 00:55:18,710
u.s. I'd have a chat with that their

00:55:16,920 --> 00:55:22,140
summer interns and they were saying that

00:55:18,710 --> 00:55:23,309
in their universities now functional is

00:55:22,140 --> 00:55:26,430
the sort of programming that they're

00:55:23,309 --> 00:55:28,319
teaching them so I do get the fee and

00:55:26,430 --> 00:55:31,170
certainly when I go to things like NDC

00:55:28,319 --> 00:55:32,219
Oslo and things like that I get the

00:55:31,170 --> 00:55:34,710
impression there is more functional

00:55:32,219 --> 00:55:37,109
content each year compared to the

00:55:34,710 --> 00:55:38,819
previous and people are starting to name

00:55:37,109 --> 00:55:40,920
check at least functional and even in

00:55:38,819 --> 00:55:43,109
the non-functional talk so it is

00:55:40,920 --> 00:55:45,650
definitely a very coming thing and

00:55:43,109 --> 00:55:47,999
something that's becoming extremely

00:55:45,650 --> 00:55:52,109
they're increasingly important as the

00:55:47,999 --> 00:55:54,910
years go on yeah it's nice and thanks

00:55:52,109 --> 00:55:57,339
again for great tours

00:55:54,910 --> 00:55:59,289
and with that I would like to thank our

00:55:57,339 --> 00:56:01,710
speakers our sponsors and all our

00:55:59,289 --> 00:56:01,710
viewers

00:56:07,579 --> 00:56:09,640

YouTube URL: https://www.youtube.com/watch?v=mLSNxtFPVlg


