Title: Privacy-preserving statistical analyses - Elisabet Lobo-Vesga
Publication date: 2020-05-08
Playlist: foss-north 2020 virtual
Description: 
	Talk details: https://foss-north.se/2020/speakers-and-talks.html#elobovesga
Conference details: https://foss-north.se/2020/
Captions: 
	00:00:00,030 --> 00:00:05,700
welcome to force north the virtual

00:00:02,850 --> 00:00:07,980
edition we would like to thank all our

00:00:05,700 --> 00:00:12,030
sponsors and partners in this difficult

00:00:07,980 --> 00:00:15,490
situation our gold sponsors look soft

00:00:12,030 --> 00:00:19,689
and ansible by Red Hat

00:00:15,490 --> 00:00:21,910
our silver sponsors ITRs group and make

00:00:19,689 --> 00:00:25,570
it right

00:00:21,910 --> 00:00:28,660
our base sponsors

00:00:25,570 --> 00:00:30,820
our partner projects the open source

00:00:28,660 --> 00:00:33,940
community and the region of Gothenburg

00:00:30,820 --> 00:00:35,920
and a huge thanks to our awesome

00:00:33,940 --> 00:00:39,070
community this would not have been

00:00:35,920 --> 00:00:41,680
possible without you so for the next

00:00:39,070 --> 00:00:44,280
section we're welcoming Elizabeth who

00:00:41,680 --> 00:00:46,930
will talk about differential privacy

00:00:44,280 --> 00:00:48,670
this is a pre-recorded session but

00:00:46,930 --> 00:00:53,940
Elizabeth will be available for Q&A

00:00:48,670 --> 00:00:53,940
afterwards so here it goes

00:00:54,780 --> 00:01:00,850
hey my name is Elizabeth Laveau I'm a

00:00:58,420 --> 00:01:03,309
PhD student at Chalmers and today I'll

00:01:00,850 --> 00:01:05,740
be talking about how to preserve users

00:01:03,309 --> 00:01:08,860
privacy while sharing a statistical

00:01:05,740 --> 00:01:11,800
analysis of their data this is a joint

00:01:08,860 --> 00:01:13,930
work with Alejandro Russo and Marco

00:01:11,800 --> 00:01:17,289
Gilardi from Chalmers and Boston

00:01:13,930 --> 00:01:19,780
University so we are constantly sharing

00:01:17,289 --> 00:01:22,240
personal information with companies and

00:01:19,780 --> 00:01:24,789
they use it to learn about users

00:01:22,240 --> 00:01:26,920
behavior improve their services and

00:01:24,789 --> 00:01:29,740
ultimately make some money

00:01:26,920 --> 00:01:33,250
all these statistical analyses can be

00:01:29,740 --> 00:01:35,259
beneficial for society but we don't want

00:01:33,250 --> 00:01:38,560
it to be at the expense of someone's

00:01:35,259 --> 00:01:41,140
privacy in particular we want to avoid

00:01:38,560 --> 00:01:43,150
people observing the statistics and

00:01:41,140 --> 00:01:46,150
being able to identify specific

00:01:43,150 --> 00:01:48,100
individuals in the data this means all

00:01:46,150 --> 00:01:49,420
our statistics should be

00:01:48,100 --> 00:01:52,390
privacy-preserving

00:01:49,420 --> 00:01:55,329
which is especially useful for GDP our

00:01:52,390 --> 00:01:57,579
compliance since any information that

00:01:55,329 --> 00:02:00,460
can be used to identify an individual

00:01:57,579 --> 00:02:03,490
must be treated as sensitive data and

00:02:00,460 --> 00:02:06,189
then could not be share or sell without

00:02:03,490 --> 00:02:10,750
the users consent not ensuring privacy

00:02:06,189 --> 00:02:12,910
then restricts the uses of data and if

00:02:10,750 --> 00:02:15,549
not done carefully my even get us fine

00:02:12,910 --> 00:02:17,920
so there are two approaches to tackle

00:02:15,549 --> 00:02:20,380
this issue one would be to protect the

00:02:17,920 --> 00:02:22,930
data when it's being collected and the

00:02:20,380 --> 00:02:25,660
other is to protect it when the analysis

00:02:22,930 --> 00:02:28,600
is being disclosed during this talk we

00:02:25,660 --> 00:02:31,000
will focus on this last scenario so now

00:02:28,600 --> 00:02:33,370
let's take a look at a simple example

00:02:31,000 --> 00:02:35,530
let's say we want to know the percentage

00:02:33,370 --> 00:02:38,109
of males and females extreme in the

00:02:35,530 --> 00:02:39,370
stock this question could be very broad

00:02:38,109 --> 00:02:41,769
since hopefully we

00:02:39,370 --> 00:02:43,989
thousands of movers then an attacker may

00:02:41,769 --> 00:02:46,030
have a hard time identifying someone in

00:02:43,989 --> 00:02:48,400
particular but this might not be the

00:02:46,030 --> 00:02:50,459
case if the question refers to a more

00:02:48,400 --> 00:02:54,099
narrow group of people for instance

00:02:50,459 --> 00:02:56,920
viewers from Gothenburg using X internet

00:02:54,099 --> 00:03:00,280
provider so at the end we will like all

00:02:56,920 --> 00:03:02,049
our analysis to be privacy-preserving no

00:03:00,280 --> 00:03:05,739
matter how detailed the question might

00:03:02,049 --> 00:03:08,140
be trying to protect users privacy has

00:03:05,739 --> 00:03:11,049
been relevant a relevant research topic

00:03:08,140 --> 00:03:13,299
for many years and several techniques

00:03:11,049 --> 00:03:15,970
have been developed to try to solve this

00:03:13,299 --> 00:03:19,239
problem one of these techniques is known

00:03:15,970 --> 00:03:23,079
as data anonymous Asian which basically

00:03:19,239 --> 00:03:25,599
remove all identifiers like names and

00:03:23,079 --> 00:03:27,609
Social Security numbers from the

00:03:25,599 --> 00:03:30,310
database before the analyses are

00:03:27,609 --> 00:03:32,349
performed the idea is that since no

00:03:30,310 --> 00:03:36,000
identifying information is being used

00:03:32,349 --> 00:03:38,379
there shouldn't be any breach of privacy

00:03:36,000 --> 00:03:41,109
unfortunately this technique does not

00:03:38,379 --> 00:03:44,049
consider the impact of other external

00:03:41,109 --> 00:03:46,180
data that correlates with the analysis

00:03:44,049 --> 00:03:49,299
being shared and that could be used to

00:03:46,180 --> 00:03:51,310
Deanna Mize the database this is exactly

00:03:49,299 --> 00:03:54,760
what happened to Netflix when they

00:03:51,310 --> 00:03:56,769
publish an anonymous data set as part of

00:03:54,760 --> 00:03:59,500
a contest to improve their rating

00:03:56,769 --> 00:04:01,510
algorithm in just a few days a group of

00:03:59,500 --> 00:04:03,760
people realized that there was some

00:04:01,510 --> 00:04:07,480
correlations between Netflix information

00:04:03,760 --> 00:04:10,299
and I am Divis review data this was then

00:04:07,480 --> 00:04:12,489
used to D anonymize Netflix data set and

00:04:10,299 --> 00:04:15,310
of course at the end they had to pay for

00:04:12,489 --> 00:04:17,650
it except the stations have also been

00:04:15,310 --> 00:04:20,500
dealing with the problem of preserving

00:04:17,650 --> 00:04:22,720
privacy and their approach consists on

00:04:20,500 --> 00:04:25,810
adding some noise to the results before

00:04:22,720 --> 00:04:28,000
publishing them this way they randomize

00:04:25,810 --> 00:04:30,550
their analyses avoiding possible

00:04:28,000 --> 00:04:32,610
correlations with our data while still

00:04:30,550 --> 00:04:34,780
providing anonymity

00:04:32,610 --> 00:04:37,630
unfortunately this technique is also

00:04:34,780 --> 00:04:39,910
broken and it has been shown that it

00:04:37,630 --> 00:04:42,580
does not preserve privacy in the long

00:04:39,910 --> 00:04:45,099
term since an attacker will enough

00:04:42,580 --> 00:04:47,229
computational power can take several

00:04:45,099 --> 00:04:49,690
analyses from the same data set and

00:04:47,229 --> 00:04:52,120
separate the noise from the real data

00:04:49,690 --> 00:04:53,150
which will ultimately allow her to

00:04:52,120 --> 00:04:55,910
reconstruct the

00:04:53,150 --> 00:04:58,880
entire database among several entities

00:04:55,910 --> 00:05:00,830
the US Census Bureau realized that this

00:04:58,880 --> 00:05:03,500
was a problem with some of their publish

00:05:00,830 --> 00:05:05,030
analysis and they now advocated for a

00:05:03,500 --> 00:05:08,330
more refined approach called

00:05:05,030 --> 00:05:10,280
differential privacy then what is

00:05:08,330 --> 00:05:12,860
differential privacy it can be

00:05:10,280 --> 00:05:15,500
considered a more robust way of adding

00:05:12,860 --> 00:05:17,680
noise to your statistical analysis in

00:05:15,500 --> 00:05:22,100
order to better preserve the privacy

00:05:17,680 --> 00:05:24,020
let's say we have an SQL query Q that

00:05:22,100 --> 00:05:28,840
counts the number of employees with

00:05:24,020 --> 00:05:30,830
salaries above 60 K given a database D a

00:05:28,840 --> 00:05:34,490
differentially private version of this

00:05:30,830 --> 00:05:38,990
query will be Q tilde that takes the

00:05:34,490 --> 00:05:41,050
same database D execute skill and obtain

00:05:38,990 --> 00:05:43,430
the real count and finally add some

00:05:41,050 --> 00:05:45,710
calibrated knowledge to it in

00:05:43,430 --> 00:05:47,900
differential privacy we pay special

00:05:45,710 --> 00:05:50,780
attention to the type of noise that

00:05:47,900 --> 00:05:52,670
we're adding because we want to satisfy

00:05:50,780 --> 00:05:54,830
certain properties which will

00:05:52,670 --> 00:05:57,310
distinguish this technique from just a

00:05:54,830 --> 00:06:00,050
naive randomization of the results

00:05:57,310 --> 00:06:02,690
intuitively we want all our noisy

00:06:00,050 --> 00:06:05,930
queries to mask the membership of any

00:06:02,690 --> 00:06:09,650
user from the output let's say we have a

00:06:05,930 --> 00:06:12,470
database the one with Alice's Bob's and

00:06:09,650 --> 00:06:15,430
Charlie's information and then we create

00:06:12,470 --> 00:06:17,630
another database d2 without Bob a

00:06:15,430 --> 00:06:20,450
differentially private query should

00:06:17,630 --> 00:06:22,640
ensure that by looking at this output

00:06:20,450 --> 00:06:25,550
one shouldn't be able to know which

00:06:22,640 --> 00:06:28,940
database was used for its execution

00:06:25,550 --> 00:06:31,700
this means listen between the results of

00:06:28,940 --> 00:06:34,310
executing the noisy query with the one

00:06:31,700 --> 00:06:37,070
and executing it we D 2 should be

00:06:34,310 --> 00:06:39,500
ideally close to zero since we're

00:06:37,070 --> 00:06:41,660
dealing with noise we can't really talk

00:06:39,500 --> 00:06:44,720
about the specific points but a

00:06:41,660 --> 00:06:47,420
distribution of values so to measure the

00:06:44,720 --> 00:06:50,060
distance between the two outputs we look

00:06:47,420 --> 00:06:53,240
at their curves and see how far apart

00:06:50,060 --> 00:06:55,940
they are to be epsilon differentially

00:06:53,240 --> 00:06:58,280
private our noisy query needs to

00:06:55,940 --> 00:07:01,520
guarantee to the distance between the

00:06:58,280 --> 00:07:04,100
blue and red graph are at most Epsilon

00:07:01,520 --> 00:07:06,220
the bigger the epsilon the further apart

00:07:04,100 --> 00:07:09,850
our results are allowed to

00:07:06,220 --> 00:07:12,220
and by extension the least private for

00:07:09,850 --> 00:07:16,540
this reason epsilon is considered a

00:07:12,220 --> 00:07:18,300
quantification of the lost of privacy so

00:07:16,540 --> 00:07:21,190
now that we have an intuition of how

00:07:18,300 --> 00:07:23,920
differential privacy works how do we

00:07:21,190 --> 00:07:26,740
actually use this in real life first we

00:07:23,920 --> 00:07:29,080
consider two different roles one is the

00:07:26,740 --> 00:07:31,590
data owner and the other is a group of

00:07:29,080 --> 00:07:33,880
analysts that want to use the data

00:07:31,590 --> 00:07:37,540
analysts are not allowed to directly

00:07:33,880 --> 00:07:39,970
query the database instead they send the

00:07:37,540 --> 00:07:42,370
queries to the data owner which then

00:07:39,970 --> 00:07:45,970
executes them and give the result that

00:07:42,370 --> 00:07:48,160
the owner sets a maximum privacy loss

00:07:45,970 --> 00:07:51,100
for the data which we will call the

00:07:48,160 --> 00:07:53,860
global epsilon and then she makes sure

00:07:51,100 --> 00:07:57,580
that it is preserved by all the provided

00:07:53,860 --> 00:08:00,370
analysis however each of these analyses

00:07:57,580 --> 00:08:02,680
has its stone among the privacy laws or

00:08:00,370 --> 00:08:05,080
local Epsilon's so now the question is

00:08:02,680 --> 00:08:07,980
how can she enforce the global epsilon

00:08:05,080 --> 00:08:10,750
for all the analysis as a whole

00:08:07,980 --> 00:08:13,180
thankfully differential privacy is a

00:08:10,750 --> 00:08:15,940
compositional property so in order to

00:08:13,180 --> 00:08:18,940
calculate the total privacy lost of a

00:08:15,940 --> 00:08:22,180
set of queries we can use at their local

00:08:18,940 --> 00:08:24,640
Epsilon's knowing this the job of the

00:08:22,180 --> 00:08:27,100
data owner consists of checking the

00:08:24,640 --> 00:08:30,190
global epsilon being greater than the

00:08:27,100 --> 00:08:33,250
total privacy loss of the given analysis

00:08:30,190 --> 00:08:36,250
now we can think of the global epsilon

00:08:33,250 --> 00:08:38,919
as a privacy budget and the local

00:08:36,250 --> 00:08:41,349
Epsilon's as the price the analyst way

00:08:38,919 --> 00:08:44,830
to extract information from the database

00:08:41,349 --> 00:08:47,200
as we can see this limits the amount of

00:08:44,830 --> 00:08:49,810
queries that can be executed in database

00:08:47,200 --> 00:08:52,440
avoiding the problems that this edition

00:08:49,810 --> 00:08:55,960
had before now that we have established

00:08:52,440 --> 00:08:58,390
how an analysis is performed we would

00:08:55,960 --> 00:09:01,030
like to know how useful the results will

00:08:58,390 --> 00:09:03,790
be since we are adding noise to it if we

00:09:01,030 --> 00:09:06,040
recall our previous example we were

00:09:03,790 --> 00:09:09,910
interested in knowing the number of

00:09:06,040 --> 00:09:11,770
employees with the salary over 60 K in

00:09:09,910 --> 00:09:14,560
order to protect the privacy of the

00:09:11,770 --> 00:09:17,740
employees our noisy algorithm will

00:09:14,560 --> 00:09:19,510
return a result around the actual count

00:09:17,740 --> 00:09:22,360
let's say

00:09:19,510 --> 00:09:25,540
the real count is five so we might get

00:09:22,360 --> 00:09:27,670
results like three or seven now of

00:09:25,540 --> 00:09:30,190
course we as analysts don't know what

00:09:27,670 --> 00:09:32,920
they're real hunter is second will

00:09:30,190 --> 00:09:35,500
receive a three or a seven how do we

00:09:32,920 --> 00:09:38,350
know if this information is useful if

00:09:35,500 --> 00:09:40,390
the real count is for instance 100 then

00:09:38,350 --> 00:09:42,970
receiving a three means that we are just

00:09:40,390 --> 00:09:46,090
getting some random number in this case

00:09:42,970 --> 00:09:48,430
have it a notion of how close we are to

00:09:46,090 --> 00:09:51,340
the real data without actually knowing

00:09:48,430 --> 00:09:53,650
what the real value is might become

00:09:51,340 --> 00:09:56,470
really handy we describe this as the

00:09:53,650 --> 00:09:59,860
accuracy or utility of our solution and

00:09:56,470 --> 00:10:03,370
it simply bounds how far can we be from

00:09:59,860 --> 00:10:06,850
the real value a high accuracy means we

00:10:03,370 --> 00:10:09,460
are very close while a low one means we

00:10:06,850 --> 00:10:12,670
might be farther away and then we should

00:10:09,460 --> 00:10:15,220
probably discard this solution when we

00:10:12,670 --> 00:10:18,100
consider these alongside with privacy it

00:10:15,220 --> 00:10:20,920
is clear that one directly affects the

00:10:18,100 --> 00:10:23,770
other increasing privacy means adding

00:10:20,920 --> 00:10:27,640
more noise to the answer and therefore

00:10:23,770 --> 00:10:29,560
being less accurate and vice versa so

00:10:27,640 --> 00:10:31,870
after this brief introduction to

00:10:29,560 --> 00:10:34,240
difference for privacy I hope you're

00:10:31,870 --> 00:10:36,820
eager to go and create your own privacy

00:10:34,240 --> 00:10:40,090
preserving queries so for that we have

00:10:36,820 --> 00:10:42,190
carried the pella the pella is an SQL

00:10:40,090 --> 00:10:44,140
like language that allows you to create

00:10:42,190 --> 00:10:46,120
differentially private queries and

00:10:44,140 --> 00:10:48,910
reason about the trade-off between

00:10:46,120 --> 00:10:52,470
privacy and accuracy in a programmatic

00:10:48,910 --> 00:10:55,650
way let's just see how it works

00:10:52,470 --> 00:10:59,790
so we have created the pella as a

00:10:55,650 --> 00:11:02,650
library in Haskell Haskell is a

00:10:59,790 --> 00:11:04,360
functional programming language and if

00:11:02,650 --> 00:11:05,980
you're unfamiliar with it don't worry I

00:11:04,360 --> 00:11:09,550
will walk you through the notation

00:11:05,980 --> 00:11:13,090
during this demo so let's say we're the

00:11:09,550 --> 00:11:16,630
analysts that want to compute the number

00:11:13,090 --> 00:11:18,190
of employees with the salary over 60

00:11:16,630 --> 00:11:20,520
Kaiser it's the example that we have

00:11:18,190 --> 00:11:25,210
been talking to the entire presentation

00:11:20,520 --> 00:11:30,190
so we just need to create a query that

00:11:25,210 --> 00:11:30,870
takes an epsilon a data set and then we

00:11:30,190 --> 00:11:33,779
return

00:11:30,870 --> 00:11:36,330
returned account but we as analysts

00:11:33,779 --> 00:11:39,570
don't have access to the data set so

00:11:36,330 --> 00:11:43,800
what do we have access to is the schema

00:11:39,570 --> 00:11:47,940
of the data set so this is what the

00:11:43,800 --> 00:11:51,450
analyst can see and it is a description

00:11:47,940 --> 00:11:55,230
of the attributes of the employees table

00:11:51,450 --> 00:11:58,770
it doesn't contain any sensitive data is

00:11:55,230 --> 00:12:02,850
just the structure of it so in this case

00:11:58,770 --> 00:12:05,790
we have a table employees with

00:12:02,850 --> 00:12:09,230
attributes containing the name the last

00:12:05,790 --> 00:12:13,320
name gender social security number and

00:12:09,230 --> 00:12:15,839
salary you can ignore this or these

00:12:13,320 --> 00:12:19,140
functions below since they are going to

00:12:15,839 --> 00:12:22,220
be used just like auxiliary functions so

00:12:19,140 --> 00:12:26,250
this is what we that we as analysts have

00:12:22,220 --> 00:12:30,470
but this will be enough for us to create

00:12:26,250 --> 00:12:33,270
our query so let's go back to our file

00:12:30,470 --> 00:12:36,589
so what we have is just a function that

00:12:33,270 --> 00:12:41,990
takes any epsilon in a database and

00:12:36,589 --> 00:12:45,810
first we filter the database this one

00:12:41,990 --> 00:12:49,339
taking the attribute salary and taking

00:12:45,810 --> 00:12:53,220
all the values than are bigger than

00:12:49,339 --> 00:12:56,570
60,000 this one will return a filter

00:12:53,220 --> 00:13:00,050
database and then we can perform a count

00:12:56,570 --> 00:13:04,500
that is epsilon differentially private

00:13:00,050 --> 00:13:07,140
over this filtered database we as

00:13:04,500 --> 00:13:09,330
analysts don't have access to the run

00:13:07,140 --> 00:13:12,900
function if you remember the only one

00:13:09,330 --> 00:13:18,510
that is allowed to run queries is the

00:13:12,900 --> 00:13:22,920
data owner so we will want to send this

00:13:18,510 --> 00:13:25,050
function to the data owner where we

00:13:22,920 --> 00:13:28,950
establish what would be the value of

00:13:25,050 --> 00:13:32,339
epsilon so we have like three scenarios

00:13:28,950 --> 00:13:35,910
here we have three analysis where we

00:13:32,339 --> 00:13:39,980
bury eight the value of epsilon but we

00:13:35,910 --> 00:13:43,140
don't know yet the answer for this query

00:13:39,980 --> 00:13:43,890
so before running we would like to know

00:13:43,140 --> 00:13:48,600
the

00:13:43,890 --> 00:13:52,320
let's say juice the error that we may

00:13:48,600 --> 00:13:56,970
get if we run this query in the database

00:13:52,320 --> 00:14:00,420
using each of these values of epsilon we

00:13:56,970 --> 00:14:02,670
don't want to first run and then do an

00:14:00,420 --> 00:14:07,890
analysis over the error because that

00:14:02,670 --> 00:14:10,470
will we will be spending our epsilon

00:14:07,890 --> 00:14:14,040
right remember that we have certain

00:14:10,470 --> 00:14:18,750
epsilon that we can expand and we will

00:14:14,040 --> 00:14:21,750
value this so the Pella have an open a

00:14:18,750 --> 00:14:25,980
door called accuracy where you can just

00:14:21,750 --> 00:14:28,320
put your query indicate but will be the

00:14:25,980 --> 00:14:32,100
value of your epsilon and then saying

00:14:28,320 --> 00:14:35,790
run it in a symbolic data set this

00:14:32,100 --> 00:14:38,940
embody data said it is the skeleton of a

00:14:35,790 --> 00:14:43,640
table that contains they had the

00:14:38,940 --> 00:14:46,410
structure of the the table but we have

00:14:43,640 --> 00:14:48,870
indicated we want to run our query in

00:14:46,410 --> 00:14:54,089
but this symbolic data set doesn't

00:14:48,870 --> 00:14:57,810
contain any data at all so the accuracy

00:14:54,089 --> 00:15:00,870
is given or let's say the error is

00:14:57,810 --> 00:15:04,230
calculated calculated with a confidence

00:15:00,870 --> 00:15:09,110
within a confidence interval so these

00:15:04,230 --> 00:15:14,160
accuracy would return the error of our

00:15:09,110 --> 00:15:17,910
query with a confidence of 90% so we can

00:15:14,160 --> 00:15:20,100
run this and this is not running in the

00:15:17,910 --> 00:15:22,769
database this is just an ascetical

00:15:20,100 --> 00:15:27,449
analysis that we perform over the

00:15:22,769 --> 00:15:29,610
queries that you have created so this is

00:15:27,449 --> 00:15:32,070
the interpreter and then we would like

00:15:29,610 --> 00:15:38,430
to know what will be the error of our

00:15:32,070 --> 00:15:46,829
query when the epsilon has value 0.5 so

00:15:38,430 --> 00:15:49,680
here we have an error of 5.9 and I mean

00:15:46,829 --> 00:15:53,040
we don't know yet oh how good that is

00:15:49,680 --> 00:15:57,270
right but then we can check different

00:15:53,040 --> 00:16:04,399
values of epsilon like 0.5

00:15:57,270 --> 00:16:08,810
1 & 5 so I'm sorry this will be Iran -

00:16:04,399 --> 00:16:15,510
so every time we increase the value of

00:16:08,810 --> 00:16:21,300
epsilon it will of course decrease the

00:16:15,510 --> 00:16:22,890
error right yeah so this will be just an

00:16:21,300 --> 00:16:25,260
information that will be super useful

00:16:22,890 --> 00:16:28,020
for the analyst you know beforehand

00:16:25,260 --> 00:16:31,290
before actually running because you can

00:16:28,020 --> 00:16:36,600
adjust how much epsilon you want to

00:16:31,290 --> 00:16:39,120
spend in India analysis so now let's

00:16:36,600 --> 00:16:45,180
check how the running function will work

00:16:39,120 --> 00:16:48,570
so let's go to the view of sorry the

00:16:45,180 --> 00:16:53,790
view of the data owner so the data owner

00:16:48,570 --> 00:16:57,560
has a simple tasks task and literally

00:16:53,790 --> 00:17:01,890
just need to import the database schema

00:16:57,560 --> 00:17:06,510
the run function and all the analyses

00:17:01,890 --> 00:17:08,730
that the analyst want run so here we're

00:17:06,510 --> 00:17:12,360
gonna we're not gonna restrict the

00:17:08,730 --> 00:17:14,339
number of queries that the analyst want

00:17:12,360 --> 00:17:16,500
to perform and which is gonna run the

00:17:14,339 --> 00:17:21,480
three of those analysis at what you see

00:17:16,500 --> 00:17:24,900
so when we run salary 1 what we're gonna

00:17:21,480 --> 00:17:28,820
do is like first we load our table that

00:17:24,900 --> 00:17:32,309
is saved as a comma separated value file

00:17:28,820 --> 00:17:36,240
and then we just return the value of

00:17:32,309 --> 00:17:38,760
running the first analysis over the

00:17:36,240 --> 00:17:42,059
database or the table that we have just

00:17:38,760 --> 00:17:47,670
load with the epsilon double as

00:17:42,059 --> 00:17:53,760
indicated by the analyst so let's do

00:17:47,670 --> 00:17:56,300
that so I love this new module and then

00:17:53,760 --> 00:18:02,970
we just run

00:17:56,300 --> 00:18:08,870
salary 1 so the value that we have

00:18:02,970 --> 00:18:11,610
obtaining is 5 and here I just have

00:18:08,870 --> 00:18:14,040
having a notation where I say like we

00:18:11,610 --> 00:18:17,040
have 30 employees so in this file we

00:18:14,040 --> 00:18:21,120
have 30 employees and the real count is

00:18:17,040 --> 00:18:25,740
7 so if you remember the error for this

00:18:21,120 --> 00:18:28,740
analysis was within 5 for 9 let's say 7

00:18:25,740 --> 00:18:31,980
so what it means is that these valuable

00:18:28,740 --> 00:18:40,470
that we have obtained obtained varies

00:18:31,980 --> 00:18:42,690
and it can be 7 plus 5 or 7 minus 7

00:18:40,470 --> 00:18:46,370
between that that range will be moving

00:18:42,690 --> 00:18:52,680
so we run it several times you will see

00:18:46,370 --> 00:18:56,490
that this is actually the case right so

00:18:52,680 --> 00:19:00,330
this is obvious that there's molder the

00:18:56,490 --> 00:19:03,620
epsilon the bigger the error and we can

00:19:00,330 --> 00:19:10,770
see that while even running the queries

00:19:03,620 --> 00:19:16,800
so if we run the query number 2 this is

00:19:10,770 --> 00:19:20,280
the one with epsilon 1 we obtain

00:19:16,800 --> 00:19:24,720
something closer to the real value you

00:19:20,280 --> 00:19:27,300
remember the error was just two so every

00:19:24,720 --> 00:19:33,420
time we run these we're gonna see

00:19:27,300 --> 00:19:35,270
something around 7 plus minus 2 it's

00:19:33,420 --> 00:19:39,810
actually pretty close all the time yeah

00:19:35,270 --> 00:19:42,480
nice so even if we increase our epsilon

00:19:39,810 --> 00:19:48,780
more and more so that will be the case

00:19:42,480 --> 00:19:51,540
when we run salary number 3 we will see

00:19:48,780 --> 00:19:54,570
that we are closer and closer because

00:19:51,540 --> 00:20:01,940
the error for this one was calculated at

00:19:54,570 --> 00:20:01,940
just point five right so this is how we

00:20:02,060 --> 00:20:09,030
run the queries and I mean the analyst

00:20:06,690 --> 00:20:11,640
just need to run one of these in

00:20:09,030 --> 00:20:16,590
return the value but if you remember we

00:20:11,640 --> 00:20:19,740
said that the analysts have a global

00:20:16,590 --> 00:20:22,350
budget in this case it will be this fair

00:20:19,740 --> 00:20:25,080
argument that sorry yeah this third

00:20:22,350 --> 00:20:29,250
argument that I'm passing by so it's

00:20:25,080 --> 00:20:31,410
zero point five one and five but this is

00:20:29,250 --> 00:20:34,140
exactly what the analysts want to spend

00:20:31,410 --> 00:20:37,530
so what happened if I reduce it like hey

00:20:34,140 --> 00:20:40,890
want to spend five and I said no the

00:20:37,530 --> 00:20:45,420
global will be just two so in this case

00:20:40,890 --> 00:20:48,930
we want our system to reject these

00:20:45,420 --> 00:20:51,360
analysis and return an error since the

00:20:48,930 --> 00:20:53,850
analysis Doublemint around doesn't

00:20:51,360 --> 00:20:58,250
satisfy the privacy laws that we want to

00:20:53,850 --> 00:21:03,450
enforce so we learned it again and run

00:20:58,250 --> 00:21:05,430
salary three so it says that you have

00:21:03,450 --> 00:21:07,500
you don't have enough budget to execute

00:21:05,430 --> 00:21:13,020
the query and this will be the error

00:21:07,500 --> 00:21:17,450
that the data owner will return to the

00:21:13,020 --> 00:21:23,360
analyst and the analyst will lost its

00:21:17,450 --> 00:21:28,470
local Epsilon so let's keep it like here

00:21:23,360 --> 00:21:31,260
right so let's go back to the analyst

00:21:28,470 --> 00:21:33,930
part and we have know that so now we

00:21:31,260 --> 00:21:35,820
have shown that you as an analyst can

00:21:33,930 --> 00:21:39,480
play a little bit with this trade-off

00:21:35,820 --> 00:21:41,970
between privacy and accuracy and since

00:21:39,480 --> 00:21:44,160
this is a library in Haskell you can

00:21:41,970 --> 00:21:47,640
create your own functions to optimize

00:21:44,160 --> 00:21:49,880
the selection of Epsilon or we had to

00:21:47,640 --> 00:21:53,610
adjust to a certain error that one and

00:21:49,880 --> 00:21:58,320
this we wouldn't cost you anything in

00:21:53,610 --> 00:22:01,860
terms of privacy budget but now we check

00:21:58,320 --> 00:22:04,470
how the system deals with composition so

00:22:01,860 --> 00:22:08,370
if you remember I said that if you have

00:22:04,470 --> 00:22:12,530
two differential privacy queries each

00:22:08,370 --> 00:22:15,690
one with epsilon 1 and epsilon 2

00:22:12,530 --> 00:22:18,789
guarantees then composing these two

00:22:15,690 --> 00:22:20,739
analyses will be the sum of the two

00:22:18,789 --> 00:22:24,249
let's say that we went to perform the

00:22:20,739 --> 00:22:27,639
same query the salary the kind of

00:22:24,249 --> 00:22:30,070
employees that have a salary over 60 K

00:22:27,639 --> 00:22:33,429
but now we want to do it by gender and

00:22:30,070 --> 00:22:35,499
we went to return had two counts in the

00:22:33,429 --> 00:22:39,849
list so it will be a list with two

00:22:35,499 --> 00:22:42,809
values so first we just filter the table

00:22:39,849 --> 00:22:46,599
in the salary part and the salary

00:22:42,809 --> 00:22:49,899
attribute for those values that are over

00:22:46,599 --> 00:22:52,719
60 K and then we create two different

00:22:49,899 --> 00:22:56,739
filters one for the ones that check all

00:22:52,719 --> 00:22:59,639
the males that have a salary over 60 K

00:22:56,739 --> 00:23:03,009
and another one to have all the females

00:22:59,639 --> 00:23:05,859
then we perform the confident - but if

00:23:03,009 --> 00:23:09,239
you notice here we have something called

00:23:05,859 --> 00:23:12,129
epsilon local so these are two different

00:23:09,239 --> 00:23:16,179
differentially private queries and each

00:23:12,129 --> 00:23:20,379
of those are using these value of

00:23:16,179 --> 00:23:24,639
epsilon local so now we have two analyst

00:23:20,379 --> 00:23:27,909
two analysis one with epsilon local 0.5

00:23:24,639 --> 00:23:30,569
and another one with three we want to

00:23:27,909 --> 00:23:35,819
see what is the actual value of the

00:23:30,569 --> 00:23:39,339
whole analysis so it will be the actual

00:23:35,819 --> 00:23:43,059
epsilon that computing these two counts

00:23:39,339 --> 00:23:45,669
will require so in the parallel we have

00:23:43,059 --> 00:23:49,779
an operator called budget that allows

00:23:45,669 --> 00:23:53,289
you to check the cost of your analysis

00:23:49,779 --> 00:23:59,409
before their execution so let's say we

00:23:53,289 --> 00:24:03,219
have we want to run the budget running

00:23:59,409 --> 00:24:11,259
this query with an epsilon local of 0.5

00:24:03,219 --> 00:24:17,949
so these we refer to below the head so

00:24:11,259 --> 00:24:23,469
it would be cost 4 and in this case the

00:24:17,949 --> 00:24:28,179
sum of 0.5 and 0.5 just give us 1 and

00:24:23,469 --> 00:24:31,270
similarly the cost of 3 and 3 give us 6

00:24:28,179 --> 00:24:33,880
but I mean here we have

00:24:31,270 --> 00:24:40,360
there isn't the same one but I can

00:24:33,880 --> 00:24:43,750
enforce something like a five and we can

00:24:40,360 --> 00:24:48,760
perform the same analysis again so the

00:24:43,750 --> 00:24:54,730
cost of four will be five point five and

00:24:48,760 --> 00:24:57,190
the cost of five will be eight so this

00:24:54,730 --> 00:25:01,510
is just a simple overview of how the

00:24:57,190 --> 00:25:03,130
pillar works there are more analysis and

00:25:01,510 --> 00:25:05,980
more complicated analysis that you can

00:25:03,130 --> 00:25:10,120
do but we wanted just to give you an

00:25:05,980 --> 00:25:12,190
overview of the type of reasoning that

00:25:10,120 --> 00:25:17,170
you can perform when building your

00:25:12,190 --> 00:25:20,340
queries and estimating how your

00:25:17,170 --> 00:25:24,450
parameter should be set before execution

00:25:20,340 --> 00:25:24,450
thanks so much for your attention

00:25:26,980 --> 00:25:32,710
and that's the end of the pre-recorded

00:25:30,580 --> 00:25:36,010
session from a Lizabeth so so welcome to

00:25:32,710 --> 00:25:38,410
the live session thank you so so we have

00:25:36,010 --> 00:25:41,350
I think I can cluster the questions and

00:25:38,410 --> 00:25:45,010
and we have to the one that we have two

00:25:41,350 --> 00:25:46,929
of is this differential analysis getting

00:25:45,010 --> 00:25:49,630
an attraction is it used among the big

00:25:46,929 --> 00:25:51,040
players or where is it used today oh

00:25:49,630 --> 00:25:53,230
yeah of course

00:25:51,040 --> 00:25:56,260
I mean we have a lot of research in

00:25:53,230 --> 00:25:58,720
Google Amazon Microsoft Research

00:25:56,260 --> 00:26:01,600
actually have another language for

00:25:58,720 --> 00:26:03,460
differential privacy and I think I

00:26:01,600 --> 00:26:05,940
mentioned that the Census Bureau is also

00:26:03,460 --> 00:26:11,410
pushing it so there are big companies

00:26:05,940 --> 00:26:14,080
getting into it cool interesting the

00:26:11,410 --> 00:26:15,970
second question is what's the purpose of

00:26:14,080 --> 00:26:21,510
Dan'l is needing to write Haskell

00:26:15,970 --> 00:26:26,290
instead of SQL well we love Haskell so

00:26:21,510 --> 00:26:28,630
Haskell is strongly typed and we use the

00:26:26,290 --> 00:26:32,350
fact that I mean we leverage on that

00:26:28,630 --> 00:26:35,470
type system to do the static analysis so

00:26:32,350 --> 00:26:38,730
in particular the accuracy part of the

00:26:35,470 --> 00:26:43,299
Pella is the novelty and it's our killer

00:26:38,730 --> 00:26:45,940
feature and we could only do it in

00:26:43,299 --> 00:26:48,510
Haskell because of the types so that's

00:26:45,940 --> 00:26:52,299
basically the reason why we use Haskell

00:26:48,510 --> 00:26:55,030
yep thank you very much

00:26:52,299 --> 00:26:58,440
and then I thank you for for your talk

00:26:55,030 --> 00:26:58,440
and to all our viewers

00:27:00,350 --> 00:27:04,669
and with that I would like to thank our

00:27:02,720 --> 00:27:07,120
speakers our sponsors and all our

00:27:04,669 --> 00:27:07,120
viewers

00:27:13,080 --> 00:27:15,140

YouTube URL: https://www.youtube.com/watch?v=SM_Z8x4ssOc


