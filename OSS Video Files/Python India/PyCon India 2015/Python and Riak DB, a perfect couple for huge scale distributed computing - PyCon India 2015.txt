Title: Python and Riak DB, a perfect couple for huge scale distributed computing - PyCon India 2015
Publication date: 2015-10-11
Playlist: PyCon India 2015
Description: 
	Speaker: Naren

A hands-on guide for working with both Python and Riak DB using Python Riak client . From setup to running samples in few minutes. Our exploration starts with "why Amazon Dynamo DB model is good for storing things in cloud?". Riak DB is an exact open source implementation of Amazon Dynamo DB. After this session audience will be able to integrate Riak DB in their Python projects successfully and knows how to to deliver maximum data availability by distributing data across multiple servers .

Details: https://in.pycon.org/cfp/pycon-india-2015/proposals/python-and-riak-db-a-perfect-couple-for-huge-scale-distributed-computing/
Captions: 
	00:00:00,130 --> 00:00:05,290
good evening guys we are ready for the

00:00:02,230 --> 00:00:07,420
next session the next session is Python

00:00:05,290 --> 00:00:10,150
and react database a perfect couple for

00:00:07,420 --> 00:00:11,860
you scale distributed computing the

00:00:10,150 --> 00:00:15,040
speaker for this session is Narain

00:00:11,860 --> 00:00:17,980
Narain is a devil devops engineer from

00:00:15,040 --> 00:00:19,810
na larity communications bangalore so i

00:00:17,980 --> 00:00:25,390
request marine to kindly start with the

00:00:19,810 --> 00:00:27,640
session ok let us start yes this is the

00:00:25,390 --> 00:00:31,029
talk which i am going to give python and

00:00:27,640 --> 00:00:35,940
react DB how many of you heard about the

00:00:31,029 --> 00:00:35,940
reactivity for please raise your hands

00:00:36,300 --> 00:00:42,490
have you used it before in your company

00:00:39,010 --> 00:00:47,980
or anywhere else just raise your hands

00:00:42,490 --> 00:00:50,950
if you used it before okay so this is my

00:00:47,980 --> 00:00:53,020
talk and why I'm concentrated on react

00:00:50,950 --> 00:00:57,480
DB this time is because of the problems

00:00:53,020 --> 00:01:00,460
we face in our company and this is me

00:00:57,480 --> 00:01:02,710
I'm a DevOps engineer at no loyalty and

00:01:00,460 --> 00:01:06,100
a programmer in Python and JavaScript

00:01:02,710 --> 00:01:08,319
from past two years and also many of you

00:01:06,100 --> 00:01:10,210
could have seen my blog I am byth honest

00:01:08,319 --> 00:01:13,899
how many of you saw that I am byth

00:01:10,210 --> 00:01:17,679
honest so let me ask you a few questions

00:01:13,899 --> 00:01:20,530
or I want to take few ideas from you

00:01:17,679 --> 00:01:24,069
like have you ever wondered that how

00:01:20,530 --> 00:01:27,520
Amazon is handling such a huge huge

00:01:24,069 --> 00:01:29,979
traffic and how it's maintaining how

00:01:27,520 --> 00:01:35,979
it's recording all the transactions

00:01:29,979 --> 00:01:38,709
every day yes have you seen any such

00:01:35,979 --> 00:01:40,959
organization equivalent to Amazon in

00:01:38,709 --> 00:01:44,670
handling such a big number of

00:01:40,959 --> 00:01:44,670
transaction list and all

00:01:46,480 --> 00:01:50,860
there are few technologies which can

00:01:48,790 --> 00:01:53,020
handle equal into amazon but amazon is

00:01:50,860 --> 00:01:54,520
doing that because of one technology its

00:01:53,020 --> 00:01:59,580
DynamoDB it's the paper which is

00:01:54,520 --> 00:02:01,420
released by amazon in 2007 okay so react

00:01:59,580 --> 00:02:05,500
react is an open-source implementation

00:02:01,420 --> 00:02:10,720
of dynamo dB so it is capable of doing

00:02:05,500 --> 00:02:13,630
all the things that amazon s3 can do see

00:02:10,720 --> 00:02:16,270
their characteristics one hundred

00:02:13,630 --> 00:02:17,940
percent of time infinite scale one

00:02:16,270 --> 00:02:20,920
hundred percent of time is not possible

00:02:17,940 --> 00:02:23,950
in the reality right hundred percent

00:02:20,920 --> 00:02:26,470
nothing can be up but we will talk in

00:02:23,950 --> 00:02:28,180
the sense of relative relative position

00:02:26,470 --> 00:02:30,690
saying that it's hundred percent up time

00:02:28,180 --> 00:02:33,250
means there will be no downtime and all

00:02:30,690 --> 00:02:37,420
infinite scale is not possible but we

00:02:33,250 --> 00:02:39,040
will say that scalability should be

00:02:37,420 --> 00:02:41,830
there and it should increase

00:02:39,040 --> 00:02:45,010
horizontally as we add new resources or

00:02:41,830 --> 00:02:47,050
notes to eat and fault recovery they

00:02:45,010 --> 00:02:50,290
should know if any of the node in the

00:02:47,050 --> 00:02:53,170
cluster when stone you should be able to

00:02:50,290 --> 00:02:55,060
recover the entire cluster using the

00:02:53,170 --> 00:02:58,330
other nodes which are existing and low

00:02:55,060 --> 00:03:00,520
latency each latency means it's the

00:02:58,330 --> 00:03:05,320
delay which is experienced by the user

00:03:00,520 --> 00:03:07,780
so low latency means the delay should be

00:03:05,320 --> 00:03:13,420
less so that customer user experience

00:03:07,780 --> 00:03:16,239
will be very good so why we need to care

00:03:13,420 --> 00:03:18,370
the fault tolerance because nowadays

00:03:16,239 --> 00:03:21,070
even the two seconds and three seconds

00:03:18,370 --> 00:03:23,739
delay can cause the user to go to other

00:03:21,070 --> 00:03:27,670
website like take snapdeal and flip cut

00:03:23,739 --> 00:03:29,590
if snapdeal lags you will instantly open

00:03:27,670 --> 00:03:33,700
a new tab and you will go to flipkart

00:03:29,590 --> 00:03:35,380
yes or no so the snapdeal is lost one

00:03:33,700 --> 00:03:39,580
customer I am taking it as an example it

00:03:35,380 --> 00:03:41,530
may be the case of flipkart too so that

00:03:39,580 --> 00:03:46,540
that's why you need to take care of

00:03:41,530 --> 00:03:51,400
fault tolerance so you should never lose

00:03:46,540 --> 00:03:52,900
a customer business customer many of the

00:03:51,400 --> 00:03:56,380
companies currently which are existing

00:03:52,900 --> 00:04:00,400
in bangalore are startups and I I don't

00:03:56,380 --> 00:04:01,989
think they'd grown very big but

00:04:00,400 --> 00:04:03,640
eventually all the companies from

00:04:01,989 --> 00:04:05,379
startups will go into the final stage

00:04:03,640 --> 00:04:08,860
where they need to handle lot of

00:04:05,379 --> 00:04:11,769
requests and lot of users and lot of

00:04:08,860 --> 00:04:15,370
traffic and they should scale their data

00:04:11,769 --> 00:04:17,949
the databases so at the time even the

00:04:15,370 --> 00:04:19,449
loss of one second will cost you

00:04:17,949 --> 00:04:21,389
billions of dollars or millions of

00:04:19,449 --> 00:04:25,030
dollars whatever it may be amazon will

00:04:21,389 --> 00:04:27,310
amazon will lose if they cannot provide

00:04:25,030 --> 00:04:30,850
the scalable solution for the customers

00:04:27,310 --> 00:04:34,060
if any latency were there then finished

00:04:30,850 --> 00:04:39,729
business will be will went into a huge

00:04:34,060 --> 00:04:42,430
loss so react I will come to Python in

00:04:39,729 --> 00:04:44,740
the second half because react is totally

00:04:42,430 --> 00:04:46,780
a different solution which is offered I

00:04:44,740 --> 00:04:50,260
think you know about my sequel and no

00:04:46,780 --> 00:04:53,500
sequel database solutions right so in no

00:04:50,260 --> 00:04:56,199
sequel we have many types of no sequel

00:04:53,500 --> 00:05:01,150
databases like MongoDB CouchDB

00:04:56,199 --> 00:05:02,680
foundation DB reddish and react since

00:05:01,150 --> 00:05:04,300
many of you do not know about the react

00:05:02,680 --> 00:05:06,190
what is the speciality why we need to

00:05:04,300 --> 00:05:09,099
use it because there are lot of options

00:05:06,190 --> 00:05:11,680
available why I should use react so it

00:05:09,099 --> 00:05:14,590
is a no sequel database I will say use

00:05:11,680 --> 00:05:17,440
it for two main reasons because it's

00:05:14,590 --> 00:05:22,810
built on airline how many of you

00:05:17,440 --> 00:05:25,289
programmed in airline here please raise

00:05:22,810 --> 00:05:25,289
your hands

00:05:25,920 --> 00:05:32,520
oh it's ed lang is a function

00:05:30,150 --> 00:05:35,790
programming language this is not a

00:05:32,520 --> 00:05:37,680
looong corn so I cannot extend it but

00:05:35,790 --> 00:05:41,880
ere lang is the thing which is powering

00:05:37,680 --> 00:05:44,010
the wats app so this is built on airline

00:05:41,880 --> 00:05:45,800
l lang in the sense there will be actors

00:05:44,010 --> 00:05:48,840
and concurrent programming in which

00:05:45,800 --> 00:05:50,520
everything is fault recovery like one

00:05:48,840 --> 00:05:53,160
process even though if it dies it won't

00:05:50,520 --> 00:05:55,290
crash the system it is independent all

00:05:53,160 --> 00:05:58,080
the process will communicate with each

00:05:55,290 --> 00:06:00,660
other using the messages they won't be

00:05:58,080 --> 00:06:02,160
shared resources and all so obviously

00:06:00,660 --> 00:06:04,680
there will not be crash even though one

00:06:02,160 --> 00:06:08,790
process dice so reactive is built on

00:06:04,680 --> 00:06:10,770
airline so it will be robust if you take

00:06:08,790 --> 00:06:15,210
MongoDB it is on C++ and if you take

00:06:10,770 --> 00:06:17,220
Cassandra it is on Java so the second

00:06:15,210 --> 00:06:19,080
point I told you in the beginning that

00:06:17,220 --> 00:06:21,870
it's the open source implementation of

00:06:19,080 --> 00:06:26,820
dynamo DB dynamo has a specific

00:06:21,870 --> 00:06:30,840
architecture and how it process the

00:06:26,820 --> 00:06:33,810
clustering how it maintain the different

00:06:30,840 --> 00:06:36,960
nodes virtual nodes is the main thing we

00:06:33,810 --> 00:06:39,120
are going to discuss here and in dynamo

00:06:36,960 --> 00:06:40,830
paper the architecture which they

00:06:39,120 --> 00:06:43,110
mentioned is not master slave like

00:06:40,830 --> 00:06:46,020
MongoDB many of you have heard about

00:06:43,110 --> 00:06:48,360
shouting in MongoDB when you want to

00:06:46,020 --> 00:06:52,530
scale it up yes or no shouting shouting

00:06:48,360 --> 00:06:55,910
is the process where you scale so in

00:06:52,530 --> 00:06:57,720
dynamo dB there is no master slave

00:06:55,910 --> 00:07:01,740
architecture everything is peer-to-peer

00:06:57,720 --> 00:07:05,070
like all the guys in the loads are equal

00:07:01,740 --> 00:07:06,690
and they will know all other nodes so

00:07:05,070 --> 00:07:09,510
there is no single point of failure

00:07:06,690 --> 00:07:12,140
saying that in MongoDB if master is

00:07:09,510 --> 00:07:15,240
failed then everything is lost but in

00:07:12,140 --> 00:07:22,230
dynamo everybody is a master so

00:07:15,240 --> 00:07:24,210
everybody can see all the things so if

00:07:22,230 --> 00:07:25,980
you use react the main advantage as a

00:07:24,210 --> 00:07:29,040
DevOps engineer you will get is there

00:07:25,980 --> 00:07:31,650
will be note 2 p.m. calls to am sorry 2

00:07:29,040 --> 00:07:36,320
a.m. calls will not be there there is 2

00:07:31,650 --> 00:07:38,790
p.m. because even though one node fails

00:07:36,320 --> 00:07:39,660
the other node will come to save your

00:07:38,790 --> 00:07:47,310
life and

00:07:39,660 --> 00:07:49,700
it will process the request so how many

00:07:47,310 --> 00:07:54,420
of you work with distributed databases

00:07:49,700 --> 00:07:55,920
just raise your hands so what are the

00:07:54,420 --> 00:07:57,260
two main characteristics in the

00:07:55,920 --> 00:08:01,500
distributed databases is like

00:07:57,260 --> 00:08:03,870
replication and partition you know the

00:08:01,500 --> 00:08:05,430
meaning of replication right you have

00:08:03,870 --> 00:08:08,120
one set of data and you want to take a

00:08:05,430 --> 00:08:10,380
copy of it back up exactly clone of it

00:08:08,120 --> 00:08:12,210
it is called as the replication and

00:08:10,380 --> 00:08:14,460
partition means cut it into half and

00:08:12,210 --> 00:08:16,020
place one half in one container and

00:08:14,460 --> 00:08:18,000
another one in the another place it is

00:08:16,020 --> 00:08:22,710
called the partition but what are the

00:08:18,000 --> 00:08:25,080
uses of by seeing the picture you will

00:08:22,710 --> 00:08:27,750
come to know there are those our country

00:08:25,080 --> 00:08:29,880
names from A to Z we are doing

00:08:27,750 --> 00:08:33,210
replication there means all the country

00:08:29,880 --> 00:08:35,370
names from A to Z we are storing them in

00:08:33,210 --> 00:08:37,860
node B also not be nodes are like

00:08:35,370 --> 00:08:40,229
systems virtual nodes or servers we can

00:08:37,860 --> 00:08:42,210
call them so we are copying them into

00:08:40,229 --> 00:08:44,010
node B but what's the main disadvantage

00:08:42,210 --> 00:08:46,470
here we can copy everything we can give

00:08:44,010 --> 00:08:48,480
ten hundred backups in case of data

00:08:46,470 --> 00:08:54,270
failure but what's the main problem with

00:08:48,480 --> 00:08:56,160
this replication capacity we need to

00:08:54,270 --> 00:08:59,880
have lot of capacity and wastage of

00:08:56,160 --> 00:09:02,430
memory will be happening always because

00:08:59,880 --> 00:09:04,590
we are taking unwanted backups right but

00:09:02,430 --> 00:09:07,590
we need to think how we can come up with

00:09:04,590 --> 00:09:11,310
a solution which returns us the data at

00:09:07,590 --> 00:09:12,570
the time of failure of node but it

00:09:11,310 --> 00:09:14,070
should not be the replication and there

00:09:12,570 --> 00:09:17,070
is one more technique as i told you is

00:09:14,070 --> 00:09:20,130
partition so in partition we will cut it

00:09:17,070 --> 00:09:22,650
into two parts and keep half of it in no

00:09:20,130 --> 00:09:28,260
da and half of it in not be but what is

00:09:22,650 --> 00:09:31,140
the advantage here space we are

00:09:28,260 --> 00:09:33,030
utilizing all the space to fill entered

00:09:31,140 --> 00:09:36,630
data but what is the disadvantage if

00:09:33,030 --> 00:09:42,830
node B when stone we are out like we

00:09:36,630 --> 00:09:45,270
will get a 2 2 a.m. call so

00:09:42,830 --> 00:09:48,570
when we talk about distributed databases

00:09:45,270 --> 00:09:51,300
and scalability and all these things

00:09:48,570 --> 00:09:53,730
there will be one demon coming into our

00:09:51,300 --> 00:09:57,720
way it is called cap theorem how many of

00:09:53,730 --> 00:09:59,310
you have heard cap theorem so cap

00:09:57,720 --> 00:10:01,020
theorem states that at the time of

00:09:59,310 --> 00:10:03,750
network partition network partition

00:10:01,020 --> 00:10:05,760
means you have four nodes and four are

00:10:03,750 --> 00:10:10,800
connected to internet and they are

00:10:05,760 --> 00:10:13,170
clustered okay so let us think network

00:10:10,800 --> 00:10:16,650
plug network plug is unplugged from node

00:10:13,170 --> 00:10:18,030
C then note C cannot contact with the

00:10:16,650 --> 00:10:19,860
other guys because internet is down

00:10:18,030 --> 00:10:21,930
right so it is called the network

00:10:19,860 --> 00:10:24,440
partition so at the time of network

00:10:21,930 --> 00:10:28,440
partition you can have only two things

00:10:24,440 --> 00:10:32,370
one is availability or other one is

00:10:28,440 --> 00:10:34,980
consistency I will tell you why only two

00:10:32,370 --> 00:10:37,950
things can be there let us take an

00:10:34,980 --> 00:10:42,900
example like we have a database and

00:10:37,950 --> 00:10:46,530
there is a network partition take note C

00:10:42,900 --> 00:10:48,870
and you have some data in node C and at

00:10:46,530 --> 00:10:51,300
the same time one guy is trying to write

00:10:48,870 --> 00:10:53,220
to node D and the other guy is reading

00:10:51,300 --> 00:10:54,930
from node C which do not know about the

00:10:53,220 --> 00:10:57,560
other nodes so it will return the old

00:10:54,930 --> 00:11:02,400
value osorno at the time of partition

00:10:57,560 --> 00:11:04,560
but if you want to stop that you need to

00:11:02,400 --> 00:11:06,630
log the database yes or no you need to

00:11:04,560 --> 00:11:09,540
log the data by saying that sorry one

00:11:06,630 --> 00:11:11,400
node is in the failure so let us repair

00:11:09,540 --> 00:11:14,600
it first and then you can write it but

00:11:11,400 --> 00:11:18,330
here availability is not there yes or no

00:11:14,600 --> 00:11:20,180
so similarly if you leave him right he

00:11:18,330 --> 00:11:22,830
will write that value to a dead node

00:11:20,180 --> 00:11:24,390
that is not available to the other nodes

00:11:22,830 --> 00:11:27,300
so other people will see the different

00:11:24,390 --> 00:11:30,180
values here consistency is lost if you

00:11:27,300 --> 00:11:32,130
allow him so if I availability is there

00:11:30,180 --> 00:11:34,530
then there will be no consistency and if

00:11:32,130 --> 00:11:36,480
consistency is their availability will

00:11:34,530 --> 00:11:39,230
not be there in vice versa so how you

00:11:36,480 --> 00:11:42,680
can overcome that riac has a very good

00:11:39,230 --> 00:11:45,750
feature which enables you to set the

00:11:42,680 --> 00:11:48,810
level of consistency and availability

00:11:45,750 --> 00:11:50,730
like they both are not opposite but you

00:11:48,810 --> 00:11:53,750
can set the levels of consistency and

00:11:50,730 --> 00:11:53,750
availability using react

00:11:54,610 --> 00:11:58,430
see this is what I told about level of

00:11:57,200 --> 00:12:02,420
availability and level of consistency

00:11:58,430 --> 00:12:05,690
can be set using react so how react does

00:12:02,420 --> 00:12:07,910
that react has a strategy called mrw n

00:12:05,690 --> 00:12:14,270
means number of nodes to replicate the

00:12:07,910 --> 00:12:15,680
data are means how many nodes it should

00:12:14,270 --> 00:12:17,540
be the data which is given by the

00:12:15,680 --> 00:12:20,870
customer should be written so that we

00:12:17,540 --> 00:12:24,530
should treat it as a successful read our

00:12:20,870 --> 00:12:26,720
means right means it's obvious like how

00:12:24,530 --> 00:12:30,290
many nodes you need to write in order to

00:12:26,720 --> 00:12:31,360
make it a successful right by seeing

00:12:30,290 --> 00:12:36,620
this picture you will come to know

00:12:31,360 --> 00:12:41,000
perfectly see there we have no da a note

00:12:36,620 --> 00:12:43,550
C right so if there are fine oats in our

00:12:41,000 --> 00:12:45,980
cluster and we are saying n equal to 3

00:12:43,550 --> 00:12:48,650
it means just replicate this data to

00:12:45,980 --> 00:12:51,170
three nodes out of 5 so that if anything

00:12:48,650 --> 00:12:54,940
is lost no DS failed then I can get it

00:12:51,170 --> 00:12:58,640
from node C an OD w equals to two means

00:12:54,940 --> 00:13:00,620
write this thing to at least two objects

00:12:58,640 --> 00:13:04,490
to confirm it is a successful write and

00:13:00,620 --> 00:13:06,350
read read at least two nodes you can say

00:13:04,490 --> 00:13:07,820
that you can read from node C and give

00:13:06,350 --> 00:13:10,220
to the customer saying that this is the

00:13:07,820 --> 00:13:12,500
thing but in react we can set from the

00:13:10,220 --> 00:13:14,810
program itself how many notes I can read

00:13:12,500 --> 00:13:17,840
so that if you sit n equals to two it is

00:13:14,810 --> 00:13:20,420
like confirming okay this read is

00:13:17,840 --> 00:13:22,790
perfectly read from two servers so it it

00:13:20,420 --> 00:13:25,130
might be consistent if you say n equals

00:13:22,790 --> 00:13:27,110
R equals to 3 it will read from all

00:13:25,130 --> 00:13:28,640
three replicated service and say yes

00:13:27,110 --> 00:13:30,350
this is the correct data because we read

00:13:28,640 --> 00:13:33,620
from all three servers that's how you

00:13:30,350 --> 00:13:35,800
can set availability and consistency

00:13:33,620 --> 00:13:42,140
values in the reactivity mainly its

00:13:35,800 --> 00:13:45,500
consistency so how reacts towards the

00:13:42,140 --> 00:13:47,180
things in the database is depicted in

00:13:45,500 --> 00:13:51,260
this picture it's very beautiful one

00:13:47,180 --> 00:13:54,770
like I told you react is masterless

00:13:51,260 --> 00:13:57,170
means all our masters in react not like

00:13:54,770 --> 00:13:59,680
MongoDB there is no master here all are

00:13:57,170 --> 00:14:01,910
equal this is actually a virtual ring

00:13:59,680 --> 00:14:06,329
this is not physical this is a virtual

00:14:01,910 --> 00:14:08,970
ring in which we have all the nodes

00:14:06,329 --> 00:14:10,589
and all the nodes know what is happening

00:14:08,970 --> 00:14:16,499
in the other nodes that is called the

00:14:10,589 --> 00:14:19,049
ring state this is actually a algorithm

00:14:16,499 --> 00:14:22,049
occurring how react stores data in the

00:14:19,049 --> 00:14:24,509
database is like when you give data to

00:14:22,049 --> 00:14:26,670
react it will hash it using shavon

00:14:24,509 --> 00:14:28,739
algorithm and it will get some hash

00:14:26,670 --> 00:14:35,369
value right so that hash value is used

00:14:28,739 --> 00:14:38,129
to insert data in this ring so so let us

00:14:35,369 --> 00:14:41,009
take the key called favorite and hash it

00:14:38,129 --> 00:14:44,549
you will get some value that value is

00:14:41,009 --> 00:14:50,459
used to insert that favorite key at the

00:14:44,549 --> 00:14:53,129
place three okay means here three these

00:14:50,459 --> 00:14:55,199
ABCDE our physical nodes like my laptop

00:14:53,129 --> 00:14:57,660
is one node his laptop is another his

00:14:55,199 --> 00:15:01,829
laptop is another so there are fine oats

00:14:57,660 --> 00:15:04,199
fine oats and water these things are

00:15:01,829 --> 00:15:05,999
called virtual nodes each node I mean

00:15:04,199 --> 00:15:09,420
each system will be divided into virtual

00:15:05,999 --> 00:15:12,089
nodes so react will allocate those

00:15:09,420 --> 00:15:14,939
virtual nodes to each node using shower

00:15:12,089 --> 00:15:20,100
an algorithm that's the case so 1 2 3 4

00:15:14,939 --> 00:15:23,059
5 it will allocate all 64 virtual nodes

00:15:20,100 --> 00:15:26,639
in this manner for a final configuration

00:15:23,059 --> 00:15:29,910
okay so when we say n equals 2 3 by

00:15:26,639 --> 00:15:32,669
default for a fine ode cluster n equals

00:15:29,910 --> 00:15:36,079
2 3 means replicate to three nodes so

00:15:32,669 --> 00:15:39,480
let us think favorite key is stored in

00:15:36,079 --> 00:15:41,579
33 so it will be replicated to four and

00:15:39,480 --> 00:15:45,329
five but here what are the physical

00:15:41,579 --> 00:15:48,929
nodes ABCDE our fiscal notes so if dnd

00:15:45,329 --> 00:15:51,779
fails you will get value from see yes or

00:15:48,929 --> 00:15:53,819
no this is called the partitioning which

00:15:51,779 --> 00:15:56,279
we saw before we cut down half of the

00:15:53,819 --> 00:15:58,379
country list and put another half into

00:15:56,279 --> 00:16:00,540
another right so this is the

00:15:58,379 --> 00:16:02,429
partitioning how react partitions the

00:16:00,540 --> 00:16:04,649
virtual nodes in different nodes a

00:16:02,429 --> 00:16:07,470
physical nodes these all our fiscal

00:16:04,649 --> 00:16:10,470
notes and these are virtual nodes so

00:16:07,470 --> 00:16:12,959
react does that and it will replicate

00:16:10,470 --> 00:16:15,059
but but when we see the ring three four

00:16:12,959 --> 00:16:16,949
five are very adjacent right three four

00:16:15,059 --> 00:16:18,630
five are adjacent but when we see

00:16:16,949 --> 00:16:21,210
physically

00:16:18,630 --> 00:16:22,770
these things are in different machines

00:16:21,210 --> 00:16:25,350
or different nodes different physical

00:16:22,770 --> 00:16:30,540
nodes so even though d fails he will

00:16:25,350 --> 00:16:34,170
give the request and also people will

00:16:30,540 --> 00:16:36,930
think that how to add a node to the

00:16:34,170 --> 00:16:39,290
cluster how to remove because first

00:16:36,930 --> 00:16:41,760
thing you have 400 requests or something

00:16:39,290 --> 00:16:43,800
next you got two thousand requests so

00:16:41,760 --> 00:16:46,770
you need to add five more nodes in order

00:16:43,800 --> 00:16:48,990
to satisfy those two thousand requests

00:16:46,770 --> 00:16:51,180
right it is called horizontal scaling so

00:16:48,990 --> 00:16:52,980
people will think if you are using a

00:16:51,180 --> 00:16:56,070
database then it will it will be a very

00:16:52,980 --> 00:16:58,290
tough and complex job to add notes to a

00:16:56,070 --> 00:17:00,150
cluster and remove it but in react it's

00:16:58,290 --> 00:17:03,300
very simple you will have a comment

00:17:00,150 --> 00:17:05,699
called react admin so using react admin

00:17:03,300 --> 00:17:08,550
you can do all the things like add a

00:17:05,699 --> 00:17:12,030
node remove a node replace it destroy it

00:17:08,550 --> 00:17:14,310
you can do anything so cluster join

00:17:12,030 --> 00:17:16,439
react at the rate of 127 point zero

00:17:14,310 --> 00:17:19,650
point zero point one so that is the

00:17:16,439 --> 00:17:21,900
machine name like let us take my node so

00:17:19,650 --> 00:17:23,959
if you say cluster join node name it

00:17:21,900 --> 00:17:27,329
will draw into the cluster that's it and

00:17:23,959 --> 00:17:29,100
if you say leave it is like we are

00:17:27,329 --> 00:17:30,720
removing a note from the cluster with a

00:17:29,100 --> 00:17:35,160
single command with a single command we

00:17:30,720 --> 00:17:37,500
can do that and if some node is failed

00:17:35,160 --> 00:17:40,920
and we need to replace it because that

00:17:37,500 --> 00:17:43,280
node is failed due to hardware failure

00:17:40,920 --> 00:17:45,960
or network then we can do it using

00:17:43,280 --> 00:17:47,670
cluster replace node 1 and node to those

00:17:45,960 --> 00:17:51,570
two are what machine names like IP

00:17:47,670 --> 00:17:53,130
address so you can also get the cluster

00:17:51,570 --> 00:17:55,290
status using those commands it's very

00:17:53,130 --> 00:17:59,550
simple with a one-line you can do that

00:17:55,290 --> 00:18:03,360
and you heard of acid right in the

00:17:59,550 --> 00:18:05,190
database acid when you are dealing with

00:18:03,360 --> 00:18:09,540
my sequel or relational databases you

00:18:05,190 --> 00:18:13,320
will see the acid atomic durable and all

00:18:09,540 --> 00:18:14,880
those things so reactive space base is

00:18:13,320 --> 00:18:17,250
the common terminology we are using in

00:18:14,880 --> 00:18:18,780
the distributed databases saying that it

00:18:17,250 --> 00:18:20,370
should be available be means basically

00:18:18,780 --> 00:18:25,320
available it should be available to the

00:18:20,370 --> 00:18:27,960
customer all the time soft state means

00:18:25,320 --> 00:18:29,970
the state of the data should be

00:18:27,960 --> 00:18:32,280
preserved and eventually consistent

00:18:29,970 --> 00:18:35,130
means the last right should

00:18:32,280 --> 00:18:37,230
like those who like we will call it as

00:18:35,130 --> 00:18:40,920
transactions in relational databases

00:18:37,230 --> 00:18:42,480
right so similar to that durable means

00:18:40,920 --> 00:18:44,720
it should be there the data should be

00:18:42,480 --> 00:18:47,280
perfectly returned to the database

00:18:44,720 --> 00:18:50,010
because we can have durable rights or

00:18:47,280 --> 00:18:53,610
not that is our choice in react like if

00:18:50,010 --> 00:18:55,890
it is not durable the request for

00:18:53,610 --> 00:18:57,930
writing the data will go to the node but

00:18:55,890 --> 00:19:01,170
it won't acknowledge but if you mention

00:18:57,930 --> 00:19:02,970
that it is a durable right then that

00:19:01,170 --> 00:19:04,740
process will sit there and after

00:19:02,970 --> 00:19:06,540
successfully the thing is written to the

00:19:04,740 --> 00:19:09,500
disk then it will come back and say yes

00:19:06,540 --> 00:19:12,630
it is curable right so react is durable

00:19:09,500 --> 00:19:15,090
you can set aright durable or not in the

00:19:12,630 --> 00:19:17,040
request itself that's the react as full

00:19:15,090 --> 00:19:19,070
customization like you can set all the

00:19:17,040 --> 00:19:25,020
levels which you want according to the

00:19:19,070 --> 00:19:29,400
customer experience so now I came to

00:19:25,020 --> 00:19:31,050
python actually at molarity I am working

00:19:29,400 --> 00:19:34,380
the no larity right we are a cloud

00:19:31,050 --> 00:19:36,540
telephony company so we use Python a lot

00:19:34,380 --> 00:19:38,970
we use Python as our main programming

00:19:36,540 --> 00:19:42,720
language to build all the systems there

00:19:38,970 --> 00:19:44,640
so you are seeing coding in Python is

00:19:42,720 --> 00:19:46,950
very fun and it's also very simple

00:19:44,640 --> 00:19:49,140
language and there are many reasons to

00:19:46,950 --> 00:19:51,630
pick up the Python actually I'm not

00:19:49,140 --> 00:19:54,060
picking a Python as using we have cast

00:19:51,630 --> 00:19:55,890
the database but we are using Python and

00:19:54,060 --> 00:19:57,480
we want to scale we want to scale

00:19:55,890 --> 00:20:01,860
because we need to handle like lakhs of

00:19:57,480 --> 00:20:04,560
phone calls every heart so we are in the

00:20:01,860 --> 00:20:07,590
direction moving towards react slowly so

00:20:04,560 --> 00:20:09,090
I'm sharing my experience with you what

00:20:07,590 --> 00:20:15,540
mainstream is in Python we are reducing

00:20:09,090 --> 00:20:18,150
Django as our back-end so this is what

00:20:15,540 --> 00:20:19,830
we all know because of its expressive

00:20:18,150 --> 00:20:22,380
power with short lines of code you can

00:20:19,830 --> 00:20:24,870
do wonderful things and because of its

00:20:22,380 --> 00:20:28,650
simplicity and a lot of libraries are

00:20:24,870 --> 00:20:34,650
available to do anything in single word

00:20:28,650 --> 00:20:37,920
we can say this so now you might have a

00:20:34,650 --> 00:20:39,270
question for me like this you have a

00:20:37,920 --> 00:20:41,850
Python client you are talking about

00:20:39,270 --> 00:20:43,770
react and also Python there is a driver

00:20:41,850 --> 00:20:45,330
which connects both of this you can ask

00:20:43,770 --> 00:20:48,900
me yes there is a very

00:20:45,330 --> 00:20:51,270
Python client which is written already

00:20:48,900 --> 00:20:57,090
like two to three years back and it is

00:20:51,270 --> 00:21:00,660
matured so this is the short snippet I

00:20:57,090 --> 00:21:03,480
am showing you how to insert data how to

00:21:00,660 --> 00:21:06,570
connect to a node and how to insert data

00:21:03,480 --> 00:21:08,790
instantly see there I am real i'm

00:21:06,570 --> 00:21:12,270
importing the react client import react

00:21:08,790 --> 00:21:16,580
and creating the rear client creating

00:21:12,270 --> 00:21:21,060
the bucket have you heard about bucket

00:21:16,580 --> 00:21:22,950
how many of you worked with s3 many of

00:21:21,060 --> 00:21:27,780
you I think right so bucket is not a new

00:21:22,950 --> 00:21:31,410
term to you but let me explain here data

00:21:27,780 --> 00:21:34,260
is not stored as the table and row here

00:21:31,410 --> 00:21:37,410
data is stored as the bucket key and Val

00:21:34,260 --> 00:21:40,200
Val you okay bucket is the namespace

00:21:37,410 --> 00:21:42,750
which is used to hold the keys key is

00:21:40,200 --> 00:21:45,150
the identity using which you will fetch

00:21:42,750 --> 00:21:48,150
the value so think it has a bucket in

00:21:45,150 --> 00:21:50,430
bucket you will have keys and value

00:21:48,150 --> 00:21:53,010
pairs using key you can fish the data

00:21:50,430 --> 00:21:54,840
and using key you can insert data so i

00:21:53,010 --> 00:21:57,270
am creating a bucket let us create

00:21:54,840 --> 00:21:59,460
create a bucket and in that bucket i am

00:21:57,270 --> 00:22:01,710
creating a new key called python

00:21:59,460 --> 00:22:04,320
developer one and i'm inserting my data

00:22:01,710 --> 00:22:06,750
there and when I say store it will get

00:22:04,320 --> 00:22:12,090
stored that's it with with violence you

00:22:06,750 --> 00:22:15,870
go to your your data is stored in the

00:22:12,090 --> 00:22:18,690
database right so this is what I'm

00:22:15,870 --> 00:22:20,670
talking about react client bucket new

00:22:18,690 --> 00:22:22,980
and store these are the methods I am

00:22:20,670 --> 00:22:27,900
talking about which are used to insert

00:22:22,980 --> 00:22:30,330
the data okay but react client we saw

00:22:27,900 --> 00:22:31,710
the normal version you may you might be

00:22:30,330 --> 00:22:34,620
wondering where is the clustering where

00:22:31,710 --> 00:22:36,030
are the nodes where are the scalability

00:22:34,620 --> 00:22:37,530
things you talked about till now you are

00:22:36,030 --> 00:22:39,720
showing just one node and saying that I

00:22:37,530 --> 00:22:41,730
am inserting data into that where are

00:22:39,720 --> 00:22:45,000
the nodes and where is the cluster so

00:22:41,730 --> 00:22:48,810
let us see about it these are the other

00:22:45,000 --> 00:22:51,920
two methods used to fetch a bucket and a

00:22:48,810 --> 00:22:51,920
value from it

00:22:52,040 --> 00:22:59,310
by seeing that code you will get we are

00:22:57,810 --> 00:23:01,770
creating a client and connecting to the

00:22:59,310 --> 00:23:03,930
database if you if you give nothing like

00:23:01,770 --> 00:23:05,940
we are client with no arguments means

00:23:03,930 --> 00:23:09,300
it's in the local host that is same for

00:23:05,940 --> 00:23:11,640
all other database lines like MongoDB

00:23:09,300 --> 00:23:14,850
and all so bucket equals to Klein dot

00:23:11,640 --> 00:23:16,800
bucket of developers and Narine equals

00:23:14,850 --> 00:23:19,320
to use a bucket not get by Thunder Lupo

00:23:16,800 --> 00:23:21,390
one and I am getting the data out of it

00:23:19,320 --> 00:23:24,600
using get data you will get the data

00:23:21,390 --> 00:23:28,560
from the object which is written for a

00:23:24,600 --> 00:23:31,140
key so this is what I am speaking about

00:23:28,560 --> 00:23:33,870
before you just told rear client and you

00:23:31,140 --> 00:23:36,360
just connect it to the local machine how

00:23:33,870 --> 00:23:40,140
you can say it will work on cluster or

00:23:36,360 --> 00:23:43,320
multiple nodes how how we will connect

00:23:40,140 --> 00:23:45,630
to multiple nodes multiple systems so

00:23:43,320 --> 00:23:47,550
see the second one second one is for

00:23:45,630 --> 00:23:50,430
single load like which is in the remote

00:23:47,550 --> 00:23:52,830
place like it may be easy to instance or

00:23:50,430 --> 00:23:55,200
something you can connect to that ec2

00:23:52,830 --> 00:23:58,620
instance using the address and port of

00:23:55,200 --> 00:24:00,120
that particular ec2 and third one is

00:23:58,620 --> 00:24:03,660
interesting it's actually the thing

00:24:00,120 --> 00:24:05,490
which we want there is an argument in

00:24:03,660 --> 00:24:08,130
the third form of react client it is

00:24:05,490 --> 00:24:09,510
nodes it is a dictionary which consists

00:24:08,130 --> 00:24:14,310
of the machine information node

00:24:09,510 --> 00:24:17,030
information here the node this this node

00:24:14,310 --> 00:24:19,470
is just the local host right this thing

00:24:17,030 --> 00:24:21,360
this is one dictionary so you can pass

00:24:19,470 --> 00:24:24,420
any number of dictionaries let us say we

00:24:21,360 --> 00:24:26,520
have five nodes called react on react to

00:24:24,420 --> 00:24:29,270
react three we have four and five so you

00:24:26,520 --> 00:24:32,280
can add all those nodes in this reactant

00:24:29,270 --> 00:24:34,710
form and when you say create client it

00:24:32,280 --> 00:24:35,880
will create a cluster it will connect to

00:24:34,710 --> 00:24:37,890
the entire cluster rather than

00:24:35,880 --> 00:24:45,590
connecting to a single load so using

00:24:37,890 --> 00:24:45,590
with one statement you can connect it ok

00:24:49,030 --> 00:24:56,410
okay in relational databases how you

00:24:53,020 --> 00:24:58,120
will search on the multiple like when

00:24:56,410 --> 00:25:02,770
data is distributed on multiple systems

00:24:58,120 --> 00:25:04,630
how you will search in all of them how

00:25:02,770 --> 00:25:06,190
many of you implemented the open-source

00:25:04,630 --> 00:25:09,750
search technology loosen in your

00:25:06,190 --> 00:25:12,940
projects loosen or solar Apache Solr

00:25:09,750 --> 00:25:15,220
okay so solar is a open source

00:25:12,940 --> 00:25:17,080
technology you can use it to implement

00:25:15,220 --> 00:25:21,900
your own search in your website or

00:25:17,080 --> 00:25:26,440
anywhere you want and you can use it and

00:25:21,900 --> 00:25:29,680
it will search with lightning speed as a

00:25:26,440 --> 00:25:31,750
so this react uses the solar search as

00:25:29,680 --> 00:25:34,300
the back end to search things on the

00:25:31,750 --> 00:25:37,240
multiple systems which are spreaded over

00:25:34,300 --> 00:25:39,190
the cluster like one node can be in

00:25:37,240 --> 00:25:41,560
Singapore another node is in u.s. west

00:25:39,190 --> 00:25:44,020
another one is in u.s. East but you can

00:25:41,560 --> 00:25:46,660
call a query from a node and you can get

00:25:44,020 --> 00:25:49,090
results from all of the nodes you can

00:25:46,660 --> 00:25:52,450
search in all the nodes using a single

00:25:49,090 --> 00:25:53,920
command in react in relational databases

00:25:52,450 --> 00:25:56,050
it is not possible and it's not that

00:25:53,920 --> 00:25:59,680
easy even though you are adding some

00:25:56,050 --> 00:26:04,150
add-ons or something and react also how

00:25:59,680 --> 00:26:05,800
the MapReduce architecture like normally

00:26:04,150 --> 00:26:10,020
you do map reducing in order to

00:26:05,800 --> 00:26:12,040
aggregate and find the results from the

00:26:10,020 --> 00:26:15,040
data which is stored in the database

00:26:12,040 --> 00:26:17,740
it's not like actually map reducing is

00:26:15,040 --> 00:26:19,900
taking code to data rather than taking

00:26:17,740 --> 00:26:24,850
data to code and executing some results

00:26:19,900 --> 00:26:27,040
and fetching it so react distributes the

00:26:24,850 --> 00:26:29,950
mapping part and also the reducing part

00:26:27,040 --> 00:26:31,900
equally to all the notes so that they

00:26:29,950 --> 00:26:35,350
will execute them independently and send

00:26:31,900 --> 00:26:39,490
result to a single load which aggregates

00:26:35,350 --> 00:26:41,460
them and redistributes the tasks so even

00:26:39,490 --> 00:26:45,010
react has a very good MapReduce

00:26:41,460 --> 00:26:48,220
architecture but what we are getting

00:26:45,010 --> 00:26:51,370
here using react and python python it's

00:26:48,220 --> 00:26:53,500
easy to start for anyone like for all

00:26:51,370 --> 00:26:56,350
the other developers who are coming from

00:26:53,500 --> 00:26:58,420
the different domains they can easily

00:26:56,350 --> 00:27:02,110
add out to python because it is easy to

00:26:58,420 --> 00:27:04,179
learn and easy to start

00:27:02,110 --> 00:27:07,690
so it is a developer friendly stack

00:27:04,179 --> 00:27:11,770
react react has a very bad documentation

00:27:07,690 --> 00:27:14,920
exactly one year before but before one

00:27:11,770 --> 00:27:16,660
year exactly react to was released so at

00:27:14,920 --> 00:27:18,370
the time they took concept they they are

00:27:16,660 --> 00:27:20,500
more concentrated on the documentation

00:27:18,370 --> 00:27:23,890
so now you can find a very good

00:27:20,500 --> 00:27:25,830
documentation on react in the Bashaw

00:27:23,890 --> 00:27:28,179
website Bashaw is the company which

00:27:25,830 --> 00:27:30,700
created react which implemented the

00:27:28,179 --> 00:27:32,530
open-source version of dynamo like you

00:27:30,700 --> 00:27:34,990
know MongoDB right so tangent is the

00:27:32,530 --> 00:27:37,059
company which created I mean which build

00:27:34,990 --> 00:27:39,070
the MongoDB so similarly bash or

00:27:37,059 --> 00:27:41,679
technology sister company which builds

00:27:39,070 --> 00:27:44,679
the react so on their website you can

00:27:41,679 --> 00:27:48,940
find lot of documentation for the Python

00:27:44,679 --> 00:27:52,320
client so before that let me show you a

00:27:48,940 --> 00:27:52,320
working demonstration of it

00:27:55,590 --> 00:27:59,970
so I am trying to create a cluster in

00:27:58,620 --> 00:28:03,210
the docker container how many of you

00:27:59,970 --> 00:28:07,470
worked with docker to how many of you

00:28:03,210 --> 00:28:09,240
know docker have you have you created

00:28:07,470 --> 00:28:11,809
containers and deployed something in

00:28:09,240 --> 00:28:16,350
that created images and pushed it to

00:28:11,809 --> 00:28:18,480
cloud repository so dr. is nothing but

00:28:16,350 --> 00:28:19,620
it simulates a virtual environment for

00:28:18,480 --> 00:28:21,539
you so that you can create a virtual

00:28:19,620 --> 00:28:24,870
environment and execute things in it and

00:28:21,539 --> 00:28:28,799
dr. Willis in a random ip22 a container

00:28:24,870 --> 00:28:31,289
so that you can use it sa you can use it

00:28:28,799 --> 00:28:33,240
as a virtual system because i don't have

00:28:31,289 --> 00:28:35,640
my systems here right which is connected

00:28:33,240 --> 00:28:38,340
through the land to show the demo so I

00:28:35,640 --> 00:28:44,549
am creating Phi nodes in the darker and

00:28:38,340 --> 00:28:48,200
i will use them to connect ok i think

00:28:44,549 --> 00:28:51,299
there's some problem with this ok and

00:28:48,200 --> 00:28:55,080
you may ask where we should not use the

00:28:51,299 --> 00:28:56,789
react i can show you but i think

00:28:55,080 --> 00:28:59,929
something happened to my daugher demon

00:28:56,789 --> 00:29:02,850
so I experimented with it in the morning

00:28:59,929 --> 00:29:04,919
so where you should not use it if you

00:29:02,850 --> 00:29:09,360
are a start-up and you don't have much

00:29:04,919 --> 00:29:10,980
data to handle and you are not scaling

00:29:09,360 --> 00:29:13,080
you are not thinking about scaling for

00:29:10,980 --> 00:29:16,169
coming five years then don't use it

00:29:13,080 --> 00:29:20,610
simply because there will be more react

00:29:16,169 --> 00:29:22,950
hitters than who are going to get it so

00:29:20,610 --> 00:29:24,840
if you are no static about sequel and

00:29:22,950 --> 00:29:27,779
you you do not want to leave it and come

00:29:24,840 --> 00:29:30,299
to no sequel world then you can use it

00:29:27,779 --> 00:29:34,919
and mainly if you don't have any problem

00:29:30,299 --> 00:29:38,610
no you can skip using the react where

00:29:34,919 --> 00:29:42,090
you should use react I told this as the

00:29:38,610 --> 00:29:44,429
first point that your data is so

00:29:42,090 --> 00:29:46,980
critical and your customer need not wait

00:29:44,429 --> 00:29:50,010
even a single second to get the data or

00:29:46,980 --> 00:29:53,250
write an operation so if your business

00:29:50,010 --> 00:29:55,710
is like that then you should use react

00:29:53,250 --> 00:29:57,779
compulsorily because even though one

00:29:55,710 --> 00:30:02,669
node fails the other one will come to

00:29:57,779 --> 00:30:04,950
the rescue ok you will get much more

00:30:02,669 --> 00:30:06,950
things there is a very good book on

00:30:04,950 --> 00:30:08,750
react called react book

00:30:06,950 --> 00:30:10,070
and there are client libraries for

00:30:08,750 --> 00:30:12,740
measure T of the programming languages

00:30:10,070 --> 00:30:15,110
not only for the Python and Python and

00:30:12,740 --> 00:30:17,840
reactive is a perfect couple in my

00:30:15,110 --> 00:30:20,840
opinion because you can use Python to

00:30:17,840 --> 00:30:29,029
build websites very soon and react to

00:30:20,840 --> 00:30:31,870
scale it horizontally so thank you if

00:30:29,029 --> 00:30:35,630
you have any questions you can ask now

00:30:31,870 --> 00:30:40,159
it's an open sourced one you can fork it

00:30:35,630 --> 00:30:43,639
and you can use it as it is but there is

00:30:40,159 --> 00:30:46,580
an enterprise edition also in bash oh it

00:30:43,639 --> 00:30:50,419
has many additional features which is

00:30:46,580 --> 00:30:52,490
not required normally but they are

00:30:50,419 --> 00:30:57,470
required when your things are going out

00:30:52,490 --> 00:30:59,480
of hand but for a big scale business you

00:30:57,470 --> 00:31:13,250
can use the open-source version and get

00:30:59,480 --> 00:31:15,500
what do you want yes no no I i gave you

00:31:13,250 --> 00:31:17,809
commands to do that right it just just

00:31:15,500 --> 00:31:20,450
purchase Oh OpenStack machines or any

00:31:17,809 --> 00:31:22,100
other thing and just add those machines

00:31:20,450 --> 00:31:25,460
to the cluster it will scale up

00:31:22,100 --> 00:31:27,380
automatically it's not required that's

00:31:25,460 --> 00:31:29,539
what I told if you take databases like

00:31:27,380 --> 00:31:31,639
Cassandra and other things if you want

00:31:29,539 --> 00:31:35,690
to scale it up you need to follow a

00:31:31,639 --> 00:31:38,919
boilerplate procedure to do that is

00:31:35,690 --> 00:31:41,090
react really good for transactions

00:31:38,919 --> 00:31:46,159
that's why I told it's eventually

00:31:41,090 --> 00:31:49,789
consistent yes there is a technique

00:31:46,159 --> 00:31:52,760
called vector clocks in react it will

00:31:49,789 --> 00:31:55,220
track all the right operations and also

00:31:52,760 --> 00:31:59,299
read operations using a thing called

00:31:55,220 --> 00:32:01,549
vector clock so this vector clock will

00:31:59,299 --> 00:32:03,490
be it's a time stamp which will be

00:32:01,549 --> 00:32:06,200
converted in multiple geographies

00:32:03,490 --> 00:32:08,510
multiple locations on multiple nodes and

00:32:06,200 --> 00:32:10,669
it will automatically transfer it into a

00:32:08,510 --> 00:32:16,039
single value single relative value and

00:32:10,669 --> 00:32:17,720
compare that are there any benchmarks

00:32:16,039 --> 00:32:19,730
done to compare react with the other

00:32:17,720 --> 00:32:20,899
databases yes there are there are many

00:32:19,730 --> 00:32:23,359
benchmarks

00:32:20,899 --> 00:32:26,029
in the web and it's it's almost

00:32:23,359 --> 00:32:28,639
equivalent to good with mongodb but one

00:32:26,029 --> 00:32:31,309
thing which really awesome about react

00:32:28,639 --> 00:32:34,249
DB is like if you are going to add a

00:32:31,309 --> 00:32:35,929
node which is having more course then

00:32:34,249 --> 00:32:38,179
react will perform like a Superman

00:32:35,929 --> 00:32:40,729
because it's running on L Lang edline

00:32:38,179 --> 00:32:44,179
can use all the fourth course to execute

00:32:40,729 --> 00:32:48,379
the things I accept Cassandra and react

00:32:44,179 --> 00:32:49,839
both are came from dynamo paper they

00:32:48,379 --> 00:32:53,089
both are implemented from the dynamo

00:32:49,839 --> 00:32:56,059
concept which is given by the Amazon but

00:32:53,089 --> 00:32:59,149
if you take react then if you are

00:32:56,059 --> 00:33:02,359
currently the systems with multiple

00:32:59,149 --> 00:33:05,149
courses common right so if you add four

00:33:02,359 --> 00:33:08,359
core system then reacts or will be

00:33:05,149 --> 00:33:11,149
doubled but not with the Cassandra so

00:33:08,359 --> 00:33:14,059
does that mean react performs better

00:33:11,149 --> 00:33:16,309
when at more cores are added to react or

00:33:14,059 --> 00:33:18,919
no no obviously it performs better

00:33:16,309 --> 00:33:20,919
because I mean better than mom say mr

00:33:18,919 --> 00:33:24,440
Wood EBR it will do really better than

00:33:20,919 --> 00:33:26,269
MongoDB if more cores are at it because

00:33:24,440 --> 00:33:33,139
I relying likes course like anything

00:33:26,269 --> 00:33:36,849
thanks how one goes 10 yeah oh where how

00:33:33,139 --> 00:33:39,409
is up how is a concurrent read and write

00:33:36,849 --> 00:33:42,379
handled in react because you have all

00:33:39,409 --> 00:33:45,169
this problems in in any distributed

00:33:42,379 --> 00:33:48,769
system this concurrent read and write

00:33:45,169 --> 00:33:51,889
problem will be there so that's what I

00:33:48,769 --> 00:33:54,440
told at the time of concurrent right at

00:33:51,889 --> 00:33:56,899
the time of concurrent right react

00:33:54,440 --> 00:33:59,929
allows you to choose what to happen like

00:33:56,899 --> 00:34:03,759
you need to take last right win strategy

00:33:59,929 --> 00:34:07,129
or you need to create siblings so that

00:34:03,759 --> 00:34:11,480
there is a option in react client if you

00:34:07,129 --> 00:34:15,829
said that client option then the last

00:34:11,480 --> 00:34:17,629
right will win it like if but if two

00:34:15,829 --> 00:34:19,940
people are doing I told you the vector

00:34:17,629 --> 00:34:21,500
clock before right so it's concurrent

00:34:19,940 --> 00:34:23,599
means they are not going to do it in the

00:34:21,500 --> 00:34:26,210
same microsecond which it is going to

00:34:23,599 --> 00:34:28,849
insert into the database right so there

00:34:26,210 --> 00:34:30,859
will be a time lag so you can overwrite

00:34:28,849 --> 00:34:33,200
one value with the other at the time of

00:34:30,859 --> 00:34:34,669
concurrent like you and I both are

00:34:33,200 --> 00:34:40,460
inserting same thing into

00:34:34,669 --> 00:34:42,470
but for us it may be 445 or 450 but for

00:34:40,460 --> 00:34:44,690
react it will go into micro second level

00:34:42,470 --> 00:34:46,429
and there is a vector clock it will

00:34:44,690 --> 00:34:48,730
check that vector clock what is the

00:34:46,429 --> 00:34:51,319
exact time it is going to hit the disk

00:34:48,730 --> 00:34:53,270
according to that it will overwrite or

00:34:51,319 --> 00:34:55,970
it will keep two records according to

00:34:53,270 --> 00:34:58,819
the option you specify there is a option

00:34:55,970 --> 00:35:02,329
called allow multiple nodes if you set

00:34:58,819 --> 00:35:04,339
it as true then it will create siblings

00:35:02,329 --> 00:35:06,410
if you set it as false then last right

00:35:04,339 --> 00:35:08,660
wins it's according to your thing there

00:35:06,410 --> 00:35:15,770
is no way to come around that situation

00:35:08,660 --> 00:35:18,650
but you can keep siblings you can remove

00:35:15,770 --> 00:35:21,559
the ambiguity there so that data is not

00:35:18,650 --> 00:35:23,089
lost about the weeds the time it will be

00:35:21,559 --> 00:35:28,640
dirty right because the right is

00:35:23,089 --> 00:35:31,040
happening that's according to the ratio

00:35:28,640 --> 00:35:32,799
or the probability which we choose the

00:35:31,040 --> 00:35:34,819
consistence your availability level

00:35:32,799 --> 00:35:37,069
actually in react there is one more good

00:35:34,819 --> 00:35:39,619
thing like for each request you can set

00:35:37,069 --> 00:35:41,569
the readability and right ability levels

00:35:39,619 --> 00:35:44,630
which I showed you before the number of

00:35:41,569 --> 00:35:46,609
nodes it should it should be read it to

00:35:44,630 --> 00:35:50,150
get the data and number of nodes it is

00:35:46,609 --> 00:35:52,280
needed to write it so those things you

00:35:50,150 --> 00:35:54,290
can make it per request but in other

00:35:52,280 --> 00:35:56,869
databases it needs to be set in some

00:35:54,290 --> 00:36:00,440
configuration file and we need to

00:35:56,869 --> 00:36:05,569
restart it to modify but here and it is

00:36:00,440 --> 00:36:08,720
done automatically in react okay are we

00:36:05,569 --> 00:36:14,750
having any more questions questions

00:36:08,720 --> 00:36:17,390
anyone you can ask okay I don't think

00:36:14,750 --> 00:36:19,660
that any more questions are there so I

00:36:17,390 --> 00:36:23,000
thank you all for coming today and

00:36:19,660 --> 00:36:25,430
attending pikin I hope to see you

00:36:23,000 --> 00:36:27,319
tomorrow also and I thank nothing for

00:36:25,430 --> 00:36:32,290
such a wonderful session Thank You Larry

00:36:27,319 --> 00:36:32,290

YouTube URL: https://www.youtube.com/watch?v=NAwFrYcAY8Y


