Title: How to build micro services using ZeroMQ and WSGI - PyCon India 2015
Publication date: 2015-10-12
Playlist: PyCon India 2015
Description: 
	Speaker: Srinath G S

Zwsgi, a ZeroMQ to WSGI bridge that gives your existing WSGI applications the power of the rich ZeroMQ messaging library.

I will cover how zwsgi can be used as a building block to design application architectures based on micro services. I will elaborate using a simple use case, that defines a reliable service-oriented request-reply dialog between a set of client applications, a broker and a set of worker applications.

Details: https://in.pycon.org/cfp/pycon-india-2015/proposals/design-distributed-web-applications-using-zeromq/
Captions: 
	00:00:00,060 --> 00:00:07,710
so the next talk is how to build a micro

00:00:02,970 --> 00:00:10,769
surface using 0 mq and WSGI by C naught

00:00:07,710 --> 00:00:14,040
GS he is a header of engineering team at

00:00:10,769 --> 00:00:17,039
idea device building an audience

00:00:14,040 --> 00:00:20,689
platform for data center activities and

00:00:17,039 --> 00:00:24,840
application life lifecycle management

00:00:20,689 --> 00:00:27,050
hi hi everyone I'm Trina I work at IDEO

00:00:24,840 --> 00:00:30,230
device as technical lead we are building

00:00:27,050 --> 00:00:33,360
the next-gen orchestration platform and

00:00:30,230 --> 00:00:35,460
we are trying to solve complicated use

00:00:33,360 --> 00:00:38,640
cases with cloud application lifecycle

00:00:35,460 --> 00:00:42,570
management so in the process of building

00:00:38,640 --> 00:00:47,280
an orchestration engine we wait we

00:00:42,570 --> 00:00:51,199
stumbled upon a lot of patterns with

00:00:47,280 --> 00:00:56,969
micro services and we also started using

00:00:51,199 --> 00:01:00,530
0 mq and and we we end up we ended up

00:00:56,969 --> 00:01:02,489
writing writing a framework for

00:01:00,530 --> 00:01:06,630
framework which will serve as a bridge

00:01:02,489 --> 00:01:12,240
between 0 mq and the Pythons standard

00:01:06,630 --> 00:01:14,340
whiskey protocol all right so today I'm

00:01:12,240 --> 00:01:17,549
going to take you through all these

00:01:14,340 --> 00:01:21,299
topics I think most of you would know

00:01:17,549 --> 00:01:24,630
about all of these things so we'll see

00:01:21,299 --> 00:01:27,900
about what micro services are and how

00:01:24,630 --> 00:01:32,549
and what is 0 mq + y 0 MK helps us in

00:01:27,900 --> 00:01:35,880
building micro services and how to build

00:01:32,549 --> 00:01:38,909
restful micro services with 0 mq as well

00:01:35,880 --> 00:01:41,490
and then we will see a small real-world

00:01:38,909 --> 00:01:43,950
example and then we'll also discuss

00:01:41,490 --> 00:01:48,290
about how that whiskey can be improved

00:01:43,950 --> 00:01:51,780
further right so what are micro services

00:01:48,290 --> 00:01:54,750
micro services is an architectural style

00:01:51,780 --> 00:01:57,719
where multiple independent processes

00:01:54,750 --> 00:01:59,790
communicate among each other and each

00:01:57,719 --> 00:02:03,149
and every independent process does a

00:01:59,790 --> 00:02:05,969
well-defined small subset of a

00:02:03,149 --> 00:02:10,860
particular big task which is supposed to

00:02:05,969 --> 00:02:13,710
be done so micro services are the only

00:02:10,860 --> 00:02:17,850
way to scale your back-end services

00:02:13,710 --> 00:02:19,380
as of now and so given that it is so

00:02:17,850 --> 00:02:22,260
awesome that you can build a highly

00:02:19,380 --> 00:02:25,530
scalable web application or highly

00:02:22,260 --> 00:02:27,960
scalable any sort of application with

00:02:25,530 --> 00:02:31,560
micro services there are some problems

00:02:27,960 --> 00:02:34,520
associated with it as well so one of the

00:02:31,560 --> 00:02:37,560
main problems is service discovery and

00:02:34,520 --> 00:02:40,320
there's without knowing which end point

00:02:37,560 --> 00:02:42,930
to connect to and without knowing which

00:02:40,320 --> 00:02:45,960
end point to connect to to do a specific

00:02:42,930 --> 00:02:49,320
task it becomes highly complicated for

00:02:45,960 --> 00:02:52,320
all the backend services to talk to each

00:02:49,320 --> 00:02:56,910
other so that's problem number one and

00:02:52,320 --> 00:02:59,850
given that all these micro services all

00:02:56,910 --> 00:03:03,300
the processes talk to each other among

00:02:59,850 --> 00:03:07,170
the communication channel so we suggest

00:03:03,300 --> 00:03:10,320
having HTTP or just having a simple TCP

00:03:07,170 --> 00:03:14,130
server would not suffice because each

00:03:10,320 --> 00:03:17,160
and every task can be done by each by

00:03:14,130 --> 00:03:19,890
its by some Microsoft micro service

00:03:17,160 --> 00:03:22,710
which might not be exposed out directly

00:03:19,890 --> 00:03:26,900
through some end point right so I'm

00:03:22,710 --> 00:03:29,250
talking about load balanced and and

00:03:26,900 --> 00:03:31,890
service-oriented architectures here when

00:03:29,250 --> 00:03:35,010
I'm talking about communication patterns

00:03:31,890 --> 00:03:37,350
and stuff so why not just use HTTP and

00:03:35,010 --> 00:03:40,170
live with it so one of the major

00:03:37,350 --> 00:03:42,780
problems with HTTP is that you need to

00:03:40,170 --> 00:03:44,970
know which port to connect to and you

00:03:42,780 --> 00:03:46,410
need to know you need so you can avoid

00:03:44,970 --> 00:03:51,000
that problem by having a load balancer

00:03:46,410 --> 00:03:54,690
so probably that that part of the

00:03:51,000 --> 00:03:57,360
problem can be solved but then even

00:03:54,690 --> 00:03:59,520
before a particular process comes up you

00:03:57,360 --> 00:04:01,020
cannot know where you should connect to

00:03:59,520 --> 00:04:04,590
you wouldn't know where you should

00:04:01,020 --> 00:04:07,620
connect to and always you know how a

00:04:04,590 --> 00:04:11,100
tipi follows this request reply request

00:04:07,620 --> 00:04:12,990
reply sort of a pattern where you send a

00:04:11,100 --> 00:04:16,230
request you wait for a response after

00:04:12,990 --> 00:04:18,690
the response is given to you you assume

00:04:16,230 --> 00:04:21,840
that you assume that there the task is

00:04:18,690 --> 00:04:25,410
done and one more process one more

00:04:21,840 --> 00:04:26,990
problem that comes with HTTP is that you

00:04:25,410 --> 00:04:31,160
need to have

00:04:26,990 --> 00:04:33,199
a way to manage timeouts retries and if

00:04:31,160 --> 00:04:37,449
you have n number of workers which

00:04:33,199 --> 00:04:40,550
worker can do what task and how can you

00:04:37,449 --> 00:04:43,630
allocate work among these workers as

00:04:40,550 --> 00:04:47,300
such so that becomes a big problem so

00:04:43,630 --> 00:04:52,210
here is where here is where 0 mq would

00:04:47,300 --> 00:04:56,240
actually fit in and 0 mq helps us build

00:04:52,210 --> 00:04:58,210
su 0 mq helps us build distribute micro

00:04:56,240 --> 00:05:01,490
services which can be distributed

00:04:58,210 --> 00:05:05,030
amongst different machines in your data

00:05:01,490 --> 00:05:07,159
center or it can be it can be in a

00:05:05,030 --> 00:05:10,009
single machine as well it's supposed all

00:05:07,159 --> 00:05:13,159
sorts of communications like it

00:05:10,009 --> 00:05:16,900
basically it provides us sockets right

00:05:13,159 --> 00:05:20,690
so sockets which can be done which which

00:05:16,900 --> 00:05:26,300
comply with the TCP or which can which

00:05:20,690 --> 00:05:28,520
can be a UNIX domain socket and the 0 mq

00:05:26,300 --> 00:05:30,740
in itself also gives us a lot of other

00:05:28,520 --> 00:05:35,270
features like in process communication

00:05:30,740 --> 00:05:38,599
and and other stuff so starting from

00:05:35,270 --> 00:05:43,729
version 4 they have they have integrated

00:05:38,599 --> 00:05:47,240
with lib curve curves ZM ZM q which is

00:05:43,729 --> 00:05:51,940
which uses elliptical cryptography so

00:05:47,240 --> 00:05:56,240
you can have have used 0 mq you can have

00:05:51,940 --> 00:05:59,479
0 mq bound on a public interface so the

00:05:56,240 --> 00:06:03,409
the security is also taken care of right

00:05:59,479 --> 00:06:06,680
so all these is fine but why would you

00:06:03,409 --> 00:06:09,590
want to use as a separate you know

00:06:06,680 --> 00:06:12,949
separate module which just gives us

00:06:09,590 --> 00:06:15,740
sockets but nothing else why would you

00:06:12,949 --> 00:06:19,789
want to use such a thing when I can

00:06:15,740 --> 00:06:22,280
build something on my own right but it's

00:06:19,789 --> 00:06:25,819
not just that 0 MP gives us only sockets

00:06:22,280 --> 00:06:29,569
but it also gives us a variety of

00:06:25,819 --> 00:06:33,860
communication patterns to to deal with

00:06:29,569 --> 00:06:39,750
and it also supports 4 supports G event

00:06:33,860 --> 00:06:42,300
so that way we can have optimal

00:06:39,750 --> 00:06:45,900
utilization when you're doing an i/o

00:06:42,300 --> 00:06:48,360
call or when you are doing a weight for

00:06:45,900 --> 00:06:50,280
a particular process to come up or wait

00:06:48,360 --> 00:06:53,370
for a particular worker to be available

00:06:50,280 --> 00:06:56,820
or something like that so if you use G

00:06:53,370 --> 00:07:00,420
when the G events event based cues and

00:06:56,820 --> 00:07:03,390
even based are your systems so zero

00:07:00,420 --> 00:07:06,450
empty also gives us a polar mechanism

00:07:03,390 --> 00:07:10,710
called green polar so if you use all of

00:07:06,450 --> 00:07:14,300
these things the the application tear

00:07:10,710 --> 00:07:18,630
ends up using lesser amount of resources

00:07:14,300 --> 00:07:21,419
so let's look at the 0mv patterns so

00:07:18,630 --> 00:07:24,000
first one is request to apply I think

00:07:21,419 --> 00:07:27,510
everyone knows about what requests reply

00:07:24,000 --> 00:07:30,350
is right so request reply pattern is

00:07:27,510 --> 00:07:33,780
where you have n number of clients and

00:07:30,350 --> 00:07:36,720
any any of the client can connect to the

00:07:33,780 --> 00:07:41,340
server and the server then sends a

00:07:36,720 --> 00:07:43,820
response back after doing specific you

00:07:41,340 --> 00:07:48,510
know requests or something like that so

00:07:43,820 --> 00:07:52,470
so this is one of the most used patterns

00:07:48,510 --> 00:07:54,960
even in today's world because even HTTP

00:07:52,470 --> 00:07:57,390
follows this lockstep mechanism where

00:07:54,960 --> 00:08:01,590
you send a request and then you get you

00:07:57,390 --> 00:08:05,450
wait for a response right all right so

00:08:01,590 --> 00:08:08,340
okay the next pattern available is

00:08:05,450 --> 00:08:11,790
publish/subscribe so where you can have

00:08:08,340 --> 00:08:14,310
multiple publishers you know pushing

00:08:11,790 --> 00:08:17,880
data two to one subscriber or you can

00:08:14,310 --> 00:08:20,460
have one publisher pushing data to many

00:08:17,880 --> 00:08:23,220
subscribers and these subscribers can

00:08:20,460 --> 00:08:27,270
also have can also subscribe to a

00:08:23,220 --> 00:08:29,850
specific topic so to say so the

00:08:27,270 --> 00:08:35,219
publisher can when when it is publishing

00:08:29,850 --> 00:08:38,190
it can send send events based on events

00:08:35,219 --> 00:08:40,890
pertaining to a specific talk topic so

00:08:38,190 --> 00:08:44,150
so the subscriber which which has

00:08:40,890 --> 00:08:49,620
subscribed to a topic can get the

00:08:44,150 --> 00:08:51,400
request right so okay next thing with

00:08:49,620 --> 00:08:54,790
0mk gives us

00:08:51,400 --> 00:08:56,680
is router dealer pattern so in case of a

00:08:54,790 --> 00:08:59,800
router dealer pattern what happens is

00:08:56,680 --> 00:09:02,530
that so you have set of dealers

00:08:59,800 --> 00:09:05,920
connected to a router right

00:09:02,530 --> 00:09:08,770
so all these dealers when they're

00:09:05,920 --> 00:09:11,590
connecting to a router so zero empty

00:09:08,770 --> 00:09:14,500
also gives us this ability called zero

00:09:11,590 --> 00:09:18,040
empty socket identity so this the all

00:09:14,500 --> 00:09:21,130
the dealers in the in the connected to

00:09:18,040 --> 00:09:25,570
the router can be addressed uniquely by

00:09:21,130 --> 00:09:27,250
using this socket identity right so so

00:09:25,570 --> 00:09:29,650
when you want to send a request to a

00:09:27,250 --> 00:09:32,890
specific dealer for example if you want

00:09:29,650 --> 00:09:35,770
to send a specific request to d3 then

00:09:32,890 --> 00:09:40,060
the the server code the application code

00:09:35,770 --> 00:09:42,820
which is written in s1 can just send a

00:09:40,060 --> 00:09:46,330
request send a request on the router

00:09:42,820 --> 00:09:50,020
socket with a specific identity which is

00:09:46,330 --> 00:09:52,240
equal to the dealer d3 identity right so

00:09:50,020 --> 00:09:54,360
then the dealer d3 will get the request

00:09:52,240 --> 00:09:57,850
and then it can then further process it

00:09:54,360 --> 00:10:01,090
and you can build complex pipelining

00:09:57,850 --> 00:10:04,840
mechanisms using zero and cube by using

00:10:01,090 --> 00:10:06,820
this push-pull mechanism for example you

00:10:04,840 --> 00:10:10,270
have a producer p1 which pushes to

00:10:06,820 --> 00:10:14,230
consumer c1 and then the consumer c1 in

00:10:10,270 --> 00:10:18,850
turn can push to an aggregator probably

00:10:14,230 --> 00:10:22,600
right so so these are these are the

00:10:18,850 --> 00:10:26,800
different patterns available so alright

00:10:22,600 --> 00:10:29,260
so now we love 0 and Q 0 MK is cool I

00:10:26,800 --> 00:10:32,200
want to use 0 and Q but I have my

00:10:29,260 --> 00:10:36,070
project written in Django or pyramid or

00:10:32,200 --> 00:10:39,010
flask or any other Python web framework

00:10:36,070 --> 00:10:41,470
so I don't want to change a lot of my

00:10:39,010 --> 00:10:43,960
business logic I I want to do some

00:10:41,470 --> 00:10:48,190
minimalistic changes and I want to be

00:10:43,960 --> 00:10:50,470
able to run things using 0 mq so which

00:10:48,190 --> 00:10:52,810
is where python presents us with this

00:10:50,470 --> 00:10:56,320
nice thing called webserver gateway

00:10:52,810 --> 00:10:58,440
interface so where whiskey stands for

00:10:56,320 --> 00:11:01,930
Webster webserver gateway interface and

00:10:58,440 --> 00:11:05,560
it is the Python standard for web web

00:11:01,930 --> 00:11:07,450
applications so what it does

00:11:05,560 --> 00:11:09,640
the web server gateway interface gives

00:11:07,450 --> 00:11:13,660
us two end points one is the web server

00:11:09,640 --> 00:11:16,680
or the Gateway site and the other one is

00:11:13,660 --> 00:11:20,860
the application or the framework side so

00:11:16,680 --> 00:11:24,280
python whiskey has given as guidelines

00:11:20,860 --> 00:11:27,510
as to what all the the Gateway sites

00:11:24,280 --> 00:11:30,070
should implement and what all the

00:11:27,510 --> 00:11:32,740
applications application side should

00:11:30,070 --> 00:11:36,310
implement so we have these two

00:11:32,740 --> 00:11:38,680
interfaces so what now we're now that we

00:11:36,310 --> 00:11:41,260
have we already are in the premise that

00:11:38,680 --> 00:11:44,860
I have written all my application code

00:11:41,260 --> 00:11:48,220
in Django or pyramid of or flowers I

00:11:44,860 --> 00:11:51,940
don't want to change my code so we can

00:11:48,220 --> 00:11:54,780
leave the application side of code as

00:11:51,940 --> 00:11:58,060
such we don't have to change a lot of

00:11:54,780 --> 00:12:00,430
stuff in that we can only change the

00:11:58,060 --> 00:12:06,070
server side of it so by changing the

00:12:00,430 --> 00:12:09,460
server side actually our libraries add

00:12:06,070 --> 00:12:12,010
whiskey does change only the server side

00:12:09,460 --> 00:12:15,040
of it so that way we get the best of

00:12:12,010 --> 00:12:19,210
both worlds so to say right so one of

00:12:15,040 --> 00:12:21,730
the awesome things with using HTTP

00:12:19,210 --> 00:12:24,430
framework a web framework like Django or

00:12:21,730 --> 00:12:26,380
pyramid or or anything of that sort is

00:12:24,430 --> 00:12:31,300
that we don't have to write a complex

00:12:26,380 --> 00:12:33,880
function dispatch table so so if if

00:12:31,300 --> 00:12:36,400
packet type is this dispatch to this

00:12:33,880 --> 00:12:39,130
function if parameter is this dispatch

00:12:36,400 --> 00:12:41,500
to this function if request method is

00:12:39,130 --> 00:12:45,130
this dispatch to this function so all of

00:12:41,500 --> 00:12:47,740
these things are handled thoroughly by

00:12:45,130 --> 00:12:50,140
the during the routes configuration

00:12:47,740 --> 00:12:52,180
stage itself so the function dispatch

00:12:50,140 --> 00:12:54,130
table is sort of sort of in a way

00:12:52,180 --> 00:12:56,110
written in the routes but we don't

00:12:54,130 --> 00:13:01,240
exactly right the function dispatch

00:12:56,110 --> 00:13:04,660
tables right all right so zero so now

00:13:01,240 --> 00:13:06,940
now we know we have 0 mq and we have a

00:13:04,660 --> 00:13:09,580
whiskey application we want to make a

00:13:06,940 --> 00:13:12,790
bridge between them right so which is

00:13:09,580 --> 00:13:15,730
where our whiskey will come and z

00:13:12,790 --> 00:13:17,020
whiskey is open source you can access it

00:13:15,730 --> 00:13:20,200
at github

00:13:17,020 --> 00:13:24,880
comes to hide a device / zealously so it

00:13:20,200 --> 00:13:28,600
helps us to write restful api swith 0 mq

00:13:24,880 --> 00:13:30,690
it others to the whiskey protocol and we

00:13:28,600 --> 00:13:36,280
get all we get the best of both words

00:13:30,690 --> 00:13:38,680
right alright so this is okay so now

00:13:36,280 --> 00:13:42,610
when we talk about real-world scenarios

00:13:38,680 --> 00:13:45,970
real-world scenarios we have yeah you

00:13:42,610 --> 00:13:48,670
know we have n number of clients and all

00:13:45,970 --> 00:13:51,990
the clients let's say they want to make

00:13:48,670 --> 00:13:54,400
a specific task right they they want the

00:13:51,990 --> 00:13:58,240
server your back-end to do a specific

00:13:54,400 --> 00:14:02,350
task and thus that specific task can be

00:13:58,240 --> 00:14:06,760
split into n number of small tasks for

00:14:02,350 --> 00:14:10,960
example in the URL that is given so RFC

00:14:06,760 --> 00:14:14,050
dot 0 m q dot alt / spec : 7 so it

00:14:10,960 --> 00:14:17,700
describes the majordomo protocol MDP

00:14:14,050 --> 00:14:21,790
where where you know the clients ask for

00:14:17,700 --> 00:14:26,260
make to make clients ask the server to

00:14:21,790 --> 00:14:31,510
make tea right tea requires water milk

00:14:26,260 --> 00:14:35,440
and tea obviously right tea powder so so

00:14:31,510 --> 00:14:38,620
you have a set of workers assigned one

00:14:35,440 --> 00:14:40,660
assigned for doing a specific task so

00:14:38,620 --> 00:14:43,020
now the central dispatcher can then

00:14:40,660 --> 00:14:45,910
dispatch split the work into smaller

00:14:43,020 --> 00:14:48,550
items and then it can dispatch it to

00:14:45,910 --> 00:14:50,590
different workers and then get the

00:14:48,550 --> 00:14:53,080
consolidated output and written back to

00:14:50,590 --> 00:14:55,510
the client right so that is one model

00:14:53,080 --> 00:14:58,030
that's that's probably one model of do

00:14:55,510 --> 00:15:01,360
one way of doing it we can also have an

00:14:58,030 --> 00:15:03,400
a synchronous way of execution where we

00:15:01,360 --> 00:15:04,990
send we send a request to central

00:15:03,400 --> 00:15:06,730
dispatcher and then the central

00:15:04,990 --> 00:15:10,750
dispatcher says that it will be done

00:15:06,730 --> 00:15:12,760
when it's going to be done and then and

00:15:10,750 --> 00:15:15,960
then it can then dispatch the word to

00:15:12,760 --> 00:15:20,350
all the other workers that are available

00:15:15,960 --> 00:15:22,990
right so so this protocol in short is

00:15:20,350 --> 00:15:26,590
called as a majordomo protocol and a

00:15:22,990 --> 00:15:30,290
majordomo protocol in it also has

00:15:26,590 --> 00:15:33,529
further other specifications laid or

00:15:30,290 --> 00:15:36,639
for example heartbeats and heartbeats

00:15:33,529 --> 00:15:41,440
and yeah and all the URL schemes and

00:15:36,639 --> 00:15:47,269
everything else associated with it right

00:15:41,440 --> 00:15:49,459
all right so before that so okay so this

00:15:47,269 --> 00:15:52,819
is one of the product that we are

00:15:49,459 --> 00:15:57,860
building right now right so this can

00:15:52,819 --> 00:15:59,569
bring up bring up all these nodes and it

00:15:57,860 --> 00:16:02,149
can automatically figure out all the

00:15:59,569 --> 00:16:05,509
dependency dependencies and it can

00:16:02,149 --> 00:16:10,130
orchestrate it can basically realize

00:16:05,509 --> 00:16:12,410
this given graph to to orchestrate by

00:16:10,130 --> 00:16:15,529
orchestrating specific parts of it and

00:16:12,410 --> 00:16:17,540
it can figure out which parts need to be

00:16:15,529 --> 00:16:19,899
done parallely and which part needs to

00:16:17,540 --> 00:16:22,790
be done serially and all and then

00:16:19,899 --> 00:16:26,779
finally you will get a get a sentry

00:16:22,790 --> 00:16:29,420
cluster you will get a Postgres database

00:16:26,779 --> 00:16:34,100
and you would have ready sitting on

00:16:29,420 --> 00:16:39,279
docker and and H a proxy separately

00:16:34,100 --> 00:16:44,449
right so so all of this is done by using

00:16:39,279 --> 00:16:47,839
Zed whisky and in inside whisky also we

00:16:44,449 --> 00:16:53,329
we have we have implemented the complete

00:16:47,839 --> 00:16:58,899
majordomo protocol on our own right it

00:16:53,329 --> 00:16:58,899
will take some time for running

00:17:06,520 --> 00:17:12,709
so okay what is the road ahead for Zed

00:17:09,950 --> 00:17:15,260
whiskey asset right so using that

00:17:12,709 --> 00:17:19,010
whiskey we can probably build an

00:17:15,260 --> 00:17:21,620
enterprise message bus we can do queuing

00:17:19,010 --> 00:17:26,680
and we can throttle all the requests we

00:17:21,620 --> 00:17:29,050
can come up with some HS strategies or

00:17:26,680 --> 00:17:31,550
normally also when you have

00:17:29,050 --> 00:17:33,950
micro-services you would want some admin

00:17:31,550 --> 00:17:37,190
channel where you can interest where you

00:17:33,950 --> 00:17:40,250
can go and inspect all the processes

00:17:37,190 --> 00:17:44,120
that are there in your cluster and and

00:17:40,250 --> 00:17:46,550
with 0 mq we also get to this problem

00:17:44,120 --> 00:17:49,130
where we don't have a direct way to talk

00:17:46,550 --> 00:17:52,670
to zero you need a gateway you need a

00:17:49,130 --> 00:17:56,570
hash TTP 2 0 mq gateway and we can also

00:17:52,670 --> 00:17:58,730
have certain client libraries like for

00:17:56,570 --> 00:18:02,950
doing gatepost

00:17:58,730 --> 00:18:06,170
all and broadcast and all those requests

00:18:02,950 --> 00:18:08,300
probably it can be based out of the

00:18:06,170 --> 00:18:10,400
request library itself request library

00:18:08,300 --> 00:18:14,600
allows us to change the transport layer

00:18:10,400 --> 00:18:16,580
so and also the though we have an

00:18:14,600 --> 00:18:18,770
implementation where we have heartbeats

00:18:16,580 --> 00:18:22,610
and worker management done via read to

00:18:18,770 --> 00:18:27,140
open source the heartbeat management

00:18:22,610 --> 00:18:28,450
habit and worker management for for the

00:18:27,140 --> 00:18:33,130
outside world

00:18:28,450 --> 00:18:33,130
all right this has started

00:18:37,730 --> 00:18:44,590
oh there is some approval pending I did

00:18:41,810 --> 00:18:44,590
not think of this

00:18:57,929 --> 00:19:02,509
a landmine is like

00:19:05,630 --> 00:19:10,360
yep

00:19:07,700 --> 00:19:10,360
so

00:19:21,960 --> 00:19:27,480
so it has brought up a docker host it

00:19:24,659 --> 00:19:30,149
has installed HF proxy on it and it is

00:19:27,480 --> 00:19:34,529
bringing up all these other components

00:19:30,149 --> 00:19:39,419
on the same docker host so in a way we

00:19:34,529 --> 00:19:45,539
also help build micro services all right

00:19:39,419 --> 00:19:47,990
so so I'm done so do you have any

00:19:45,539 --> 00:19:47,990
questions

00:19:50,570 --> 00:19:56,490
hey great talk thanks for that

00:19:53,990 --> 00:20:00,090
potentially the question is like here on

00:19:56,490 --> 00:20:02,250
cue exposes a Python API as such yes

00:20:00,090 --> 00:20:05,190
so bindings are available for almost all

00:20:02,250 --> 00:20:07,380
languages there are bindings available

00:20:05,190 --> 00:20:10,140
for go there are bindings available for

00:20:07,380 --> 00:20:14,520
so for dotnet they rewrote the complete

00:20:10,140 --> 00:20:20,750
0mk code and for Python we have pi zero

00:20:14,520 --> 00:20:24,240
and pi so pi c mq does not allow you to

00:20:20,750 --> 00:20:27,420
accept requests like HTTP requests right

00:20:24,240 --> 00:20:31,830
so you don't have a facility to have

00:20:27,420 --> 00:20:36,210
URLs and you don't have this HTTP spec

00:20:31,830 --> 00:20:38,130
as such implemented in pi 0 and Q ok so

00:20:36,210 --> 00:20:41,040
typically the scenario that I am talking

00:20:38,130 --> 00:20:44,850
about us like we are having a storage

00:20:41,040 --> 00:20:47,610
solution ok and let's say we have samba

00:20:44,850 --> 00:20:49,260
configured in that so whenever I make

00:20:47,610 --> 00:20:51,840
some changes I want some bus service to

00:20:49,260 --> 00:20:54,150
restart basically okay so how we

00:20:51,840 --> 00:20:57,210
typically approach to it this like we

00:20:54,150 --> 00:20:59,640
use the Python 0 MK p ice and then

00:20:57,210 --> 00:21:01,170
instead of restarting the service

00:20:59,640 --> 00:21:03,090
through django application basically

00:21:01,170 --> 00:21:06,330
django hangs off once you do any service

00:21:03,090 --> 00:21:08,310
restarts so we span out of 0 and Q micro

00:21:06,330 --> 00:21:11,700
service through the api s-- and it just

00:21:08,310 --> 00:21:14,610
just job so why our whiskey again I

00:21:11,700 --> 00:21:18,000
don't really need a hash TTP to directly

00:21:14,610 --> 00:21:21,780
go to so it depends on your application

00:21:18,000 --> 00:21:24,570
right so what what necessarily is that

00:21:21,780 --> 00:21:28,170
see in your case you have built all the

00:21:24,570 --> 00:21:30,300
micro services which talk over HTTP but

00:21:28,170 --> 00:21:32,700
they don't talk over 0 mq and they're

00:21:30,300 --> 00:21:34,620
not taking advantage of the 0 mq

00:21:32,700 --> 00:21:37,110
patterns that are available for example

00:21:34,620 --> 00:21:39,540
router dealer is such a powerful pattern

00:21:37,110 --> 00:21:42,900
that you don't have to know the IP

00:21:39,540 --> 00:21:45,780
address of the of IP address all the

00:21:42,900 --> 00:21:47,850
port that is there in the that that is

00:21:45,780 --> 00:21:49,740
going to be there in it can be there

00:21:47,850 --> 00:21:52,170
either in your machine or it can be

00:21:49,740 --> 00:21:55,680
there in any other machine but you can

00:21:52,170 --> 00:21:59,400
allocate tasks to that so given that 0

00:21:55,680 --> 00:22:03,070
mq has such very powerful patterns in it

00:21:59,400 --> 00:22:06,690
right so your so by just having

00:22:03,070 --> 00:22:09,389
a hasty teepee based microservice

00:22:06,690 --> 00:22:12,549
architecture you are not utilizing the

00:22:09,389 --> 00:22:16,899
complete potential of zero Inc you write

00:22:12,549 --> 00:22:19,750
a question hello yeah great talk Thanks

00:22:16,899 --> 00:22:23,139
0m q as far as I understand it is broker

00:22:19,750 --> 00:22:25,360
less right could you compare and

00:22:23,139 --> 00:22:28,750
contrast maybe like the difference

00:22:25,360 --> 00:22:35,200
between with broker versus brokenness

00:22:28,750 --> 00:22:37,240
and maybe some use cases where by itself

00:22:35,200 --> 00:22:40,000
it does not dictate whether you need a

00:22:37,240 --> 00:22:41,620
broker or not right but you can end up

00:22:40,000 --> 00:22:43,629
with configuration for example this

00:22:41,620 --> 00:22:45,549
majordomo protocol involved us in

00:22:43,629 --> 00:22:48,250
central dispatcher which sort of is a

00:22:45,549 --> 00:22:51,309
broker which sort of is a proxy between

00:22:48,250 --> 00:22:53,639
all the backend processes to the player

00:22:51,309 --> 00:22:57,399
to the clients right so so you can

00:22:53,639 --> 00:22:59,379
arrive at a point where you have brokers

00:22:57,399 --> 00:23:00,909
in your architecture you can arrive at a

00:22:59,379 --> 00:23:03,850
point where you don't have brokers with

00:23:00,909 --> 00:23:05,710
your in your architecture so so if you

00:23:03,850 --> 00:23:08,860
don't have brokers it becomes very

00:23:05,710 --> 00:23:10,929
difficult for you to you know identify

00:23:08,860 --> 00:23:13,419
all the end points where you have to do

00:23:10,929 --> 00:23:15,279
where you have to connect to write but

00:23:13,419 --> 00:23:18,429
if you have a broker it is just a single

00:23:15,279 --> 00:23:20,649
end point for you right so so these are

00:23:18,429 --> 00:23:23,320
sort of the trade offs between having a

00:23:20,649 --> 00:23:24,879
broker and not having a broker but one

00:23:23,320 --> 00:23:26,799
of the major downsides of having a

00:23:24,879 --> 00:23:31,769
broker would mean that if that broker

00:23:26,799 --> 00:23:34,029
goes down then you then all your other

00:23:31,769 --> 00:23:40,179
processes would be rendered unreachable

00:23:34,029 --> 00:23:42,220
right hi this is not about 0nq but in

00:23:40,179 --> 00:23:45,210
general in micro services how do you

00:23:42,220 --> 00:23:48,970
handle authentication between services

00:23:45,210 --> 00:23:50,950
authentication between services so so

00:23:48,970 --> 00:23:56,230
authentication between services can be

00:23:50,950 --> 00:23:58,389
done by either if all all of your micro

00:23:56,230 --> 00:24:00,840
services have to have some

00:23:58,389 --> 00:24:03,669
authentication then you can come up with

00:24:00,840 --> 00:24:06,220
your internal component level

00:24:03,669 --> 00:24:07,710
authentication mechanism that's one way

00:24:06,220 --> 00:24:09,759
to do it or you can use whatever

00:24:07,710 --> 00:24:13,779
authentication mechanism that you use

00:24:09,759 --> 00:24:16,900
for your external external components

00:24:13,779 --> 00:24:19,960
for example user user authentication or

00:24:16,900 --> 00:24:22,960
so I said something like JSON web tokens

00:24:19,960 --> 00:24:29,110
JWT you can use anything that you would

00:24:22,960 --> 00:24:31,440
want to text questions any more

00:24:29,110 --> 00:24:31,440

YouTube URL: https://www.youtube.com/watch?v=98AKS-aMi0g


