Title: Keynote - Jake Vanderplas
Publication date: 2019-11-16
Playlist: PyCon India 2019
Description: 
	This talk was presented at PyCon India 2019, on Oct 12th - 13th, at the Chennai Trade Centre.
Website: https://in.pycon.org/2019
Captions: 
	00:00:04,710 --> 00:00:10,680
today what I would like to talk about is

00:00:07,290 --> 00:00:12,590
a little bit of pythons journey to data

00:00:10,680 --> 00:00:15,150
science you know a lot of people today

00:00:12,590 --> 00:00:18,150
think of Python as a data science

00:00:15,150 --> 00:00:19,410
language and it's not always been that

00:00:18,150 --> 00:00:21,150
way and I want to talk a little bit

00:00:19,410 --> 00:00:23,789
about how we've gotten to where we are

00:00:21,150 --> 00:00:27,060
right now and then give a little bit of

00:00:23,789 --> 00:00:29,730
a sort of survey of where python is now

00:00:27,060 --> 00:00:31,619
in the data science space so any of you

00:00:29,730 --> 00:00:34,130
out there who are hoping to get started

00:00:31,619 --> 00:00:36,750
kind of have a roadmap of where to start

00:00:34,130 --> 00:00:39,930
first a little bit about me my name is

00:00:36,750 --> 00:00:41,910
Jake Jake VDP you can find me on github

00:00:39,930 --> 00:00:45,810
or Twitter or Stack Overflow or other

00:00:41,910 --> 00:00:48,630
places like that and and my path has

00:00:45,810 --> 00:00:51,180
been a interesting one I started

00:00:48,630 --> 00:00:53,640
studying physics which led me to

00:00:51,180 --> 00:00:56,130
studying astronomy which led me to

00:00:53,640 --> 00:00:57,870
analyzing large data sets and getting

00:00:56,130 --> 00:00:59,940
into data science and python and

00:00:57,870 --> 00:01:02,280
eventually that led me into software

00:00:59,940 --> 00:01:04,500
engineering because I realized the the

00:01:02,280 --> 00:01:06,180
real core of data science is good

00:01:04,500 --> 00:01:08,820
software engineering and so currently

00:01:06,180 --> 00:01:11,160
after after all this stuff I'm working

00:01:08,820 --> 00:01:12,390
now as a software engineer at Google and

00:01:11,160 --> 00:01:14,610
it's been a really interesting

00:01:12,390 --> 00:01:16,170
experience and I can if you if you're

00:01:14,610 --> 00:01:20,400
curious about that I can chat with you

00:01:16,170 --> 00:01:22,860
afterwards in the Python world I've done

00:01:20,400 --> 00:01:24,600
a lot of things I've been working on a

00:01:22,860 --> 00:01:28,710
lot of different open-source projects

00:01:24,600 --> 00:01:30,840
over the years including Syfy Altair so

00:01:28,710 --> 00:01:32,909
I could learn Astro PI and I have a

00:01:30,840 --> 00:01:34,440
couple books that some of you might have

00:01:32,909 --> 00:01:38,720
seen before the Python data science

00:01:34,440 --> 00:01:41,880
handbook and if you're into kind of like

00:01:38,720 --> 00:01:43,620
real sort of Astrophysical data analysis

00:01:41,880 --> 00:01:45,600
you can check out this we have this

00:01:43,620 --> 00:01:49,470
graduate text and astronomy data

00:01:45,600 --> 00:01:51,030
processing so lots of fun stuff but so I

00:01:49,470 --> 00:01:53,880
want to start out by saying as I

00:01:51,030 --> 00:01:55,890
mentioned Python has come a long way to

00:01:53,880 --> 00:01:58,470
where it is now as a data science

00:01:55,890 --> 00:02:01,170
language and and it started as the way

00:01:58,470 --> 00:02:03,630
it started out Python was not designed

00:02:01,170 --> 00:02:06,180
to be a data science language and you

00:02:03,630 --> 00:02:09,420
see kind of vestiges of this sometimes

00:02:06,180 --> 00:02:11,879
when you approach Python asking data

00:02:09,420 --> 00:02:15,010
science questions so for example if you

00:02:11,879 --> 00:02:16,900
say I want to visualize some data

00:02:15,010 --> 00:02:20,019
and you go out in the world and ask

00:02:16,900 --> 00:02:21,640
various you know tools how to do that if

00:02:20,019 --> 00:02:23,739
you ask someone from the art community

00:02:21,640 --> 00:02:26,799
they'll say you visualize data with

00:02:23,739 --> 00:02:29,170
ggplot right is anybody used r and

00:02:26,799 --> 00:02:31,330
ggplot a few people out there it's a

00:02:29,170 --> 00:02:33,310
phenomenal tool it's phenomenal tool for

00:02:31,330 --> 00:02:37,170
data analysis data visualization data

00:02:33,310 --> 00:02:39,940
science by comparison if you ask Python

00:02:37,170 --> 00:02:42,040
how to visualize some data you say this

00:02:39,940 --> 00:02:43,780
says okay you should use matplotlib oh

00:02:42,040 --> 00:02:45,640
you know unless you want to do some

00:02:43,780 --> 00:02:46,930
interactive data than solitaire or you

00:02:45,640 --> 00:02:48,879
can use plotly or you can you see

00:02:46,930 --> 00:02:50,349
Seaborn's good for data science and you

00:02:48,879 --> 00:02:52,269
can use a bouquet for other

00:02:50,349 --> 00:02:54,069
visualization stuff and all of you is is

00:02:52,269 --> 00:02:55,660
this new thing you know there's all

00:02:54,069 --> 00:02:58,900
these different answers to the same

00:02:55,660 --> 00:03:00,220
question how do you visualize data and

00:02:58,900 --> 00:03:02,109
all these different packages and

00:03:00,220 --> 00:03:04,150
approaches people have developed and

00:03:02,109 --> 00:03:07,239
this is this is sometimes a little bit

00:03:04,150 --> 00:03:10,060
of infuriating and especially if you

00:03:07,239 --> 00:03:13,030
look at this thing the the Zen of Python

00:03:10,060 --> 00:03:15,549
has anyone ever typed import this in a

00:03:13,030 --> 00:03:17,650
Python interpreter you get this nice Zen

00:03:15,549 --> 00:03:19,269
of Python all these sort of rules that

00:03:17,650 --> 00:03:21,910
you can meditate about to make your

00:03:19,269 --> 00:03:24,250
Python as effective as possible and one

00:03:21,910 --> 00:03:26,590
of them is there should be one and

00:03:24,250 --> 00:03:29,349
preferably only one obvious way to do

00:03:26,590 --> 00:03:31,510
things and in the data science world

00:03:29,349 --> 00:03:34,660
this is just not the case right I show

00:03:31,510 --> 00:03:37,389
the visualization here but also storing

00:03:34,660 --> 00:03:40,000
data you can use numpy or pandas or or

00:03:37,389 --> 00:03:42,040
x-ray or tensorflow arrays or pi torch

00:03:40,000 --> 00:03:43,959
there's all these different ways to do

00:03:42,040 --> 00:03:45,940
things and it's a little bit of Uri a

00:03:43,959 --> 00:03:50,200
ting when you're getting started you say

00:03:45,940 --> 00:03:53,950
you know how why is python this way and

00:03:50,200 --> 00:03:56,230
what it what it comes down to why can't

00:03:53,950 --> 00:03:59,260
there just be one way it comes down to

00:03:56,230 --> 00:04:00,849
the fact that that python didn't start

00:03:59,260 --> 00:04:03,099
as a data science tool it wasn't

00:04:00,849 --> 00:04:05,230
designed as a data science tool or even

00:04:03,099 --> 00:04:08,290
a numerical or statistical computing

00:04:05,230 --> 00:04:10,840
tool at all you know if you rewind the

00:04:08,290 --> 00:04:12,910
clock almost thirty years and go back to

00:04:10,840 --> 00:04:15,519
the beginning actually where we're

00:04:12,910 --> 00:04:16,989
getting close to 40 years no huh you go

00:04:15,519 --> 00:04:20,940
back to the beginning of Python this is

00:04:16,989 --> 00:04:23,550
Guido van Rossum and he created Python

00:04:20,940 --> 00:04:26,979
basically as a teaching language and

00:04:23,550 --> 00:04:28,260
also to bridge the gap between the shell

00:04:26,979 --> 00:04:30,940
and

00:04:28,260 --> 00:04:33,490
and you look at look at what python was

00:04:30,940 --> 00:04:35,440
in the early years and it it basically

00:04:33,490 --> 00:04:38,590
was designed to be kind of an

00:04:35,440 --> 00:04:40,570
alternative to Bosch coding it was it

00:04:38,590 --> 00:04:42,130
was like a friendlier way to stitch

00:04:40,570 --> 00:04:44,650
together the different things you were

00:04:42,130 --> 00:04:46,930
doing in your computer and and Guido

00:04:44,650 --> 00:04:49,330
gave an interview a while ago where he

00:04:46,930 --> 00:04:51,460
talked about his expectations in

00:04:49,330 --> 00:04:53,440
developing Python and he said you know I

00:04:51,460 --> 00:04:56,950
thought we'd write small Python programs

00:04:53,440 --> 00:04:59,830
maybe 10 lines maybe 50 maybe 500 yellow

00:04:56,950 --> 00:05:01,750
lines and that would be a big one and

00:04:59,830 --> 00:05:04,510
you compare that to where we are today

00:05:01,750 --> 00:05:07,990
where the top companies around the world

00:05:04,510 --> 00:05:10,270
have millions of lines of Python driving

00:05:07,990 --> 00:05:14,050
their products in everything from data

00:05:10,270 --> 00:05:18,460
analysis to finance to two fields in

00:05:14,050 --> 00:05:21,130
between so how how did we go from that

00:05:18,460 --> 00:05:22,900
almost 40 years ago thinking python

00:05:21,130 --> 00:05:25,360
scripts we're gonna be a dozen lines of

00:05:22,900 --> 00:05:27,220
the most to where we are today where

00:05:25,360 --> 00:05:29,470
python is this is this data science

00:05:27,220 --> 00:05:31,930
powerhouse where sixteen hundred people

00:05:29,470 --> 00:05:33,910
gather in Chennai India to talk about

00:05:31,930 --> 00:05:36,730
how they're using Python in their work

00:05:33,910 --> 00:05:40,380
right it's it's an amazing story and and

00:05:36,730 --> 00:05:43,030
I sort of like I like to trace this back

00:05:40,380 --> 00:05:44,740
through a few a few different decades

00:05:43,030 --> 00:05:48,040
and kind of organizing it into a few

00:05:44,740 --> 00:05:50,020
arrows and I'm gonna pick on I'm gonna

00:05:48,040 --> 00:05:52,420
pick on Dave Beasley right now he's one

00:05:50,020 --> 00:05:55,930
of the later keynote speakers but I

00:05:52,420 --> 00:05:57,940
thought I'd I'd stick him up here this

00:05:55,930 --> 00:06:00,190
picture up here right now so in the 90s

00:05:57,940 --> 00:06:03,340
I think if Python in the 90s is like

00:06:00,190 --> 00:06:05,440
being in the scripting era and Python

00:06:03,340 --> 00:06:07,030
was sort of this alternative to bash you

00:06:05,440 --> 00:06:09,000
know people wanted to write bash

00:06:07,030 --> 00:06:11,860
programs to stitch together different

00:06:09,000 --> 00:06:14,200
workflows they were using and Python was

00:06:11,860 --> 00:06:17,580
just a nicer program to use and and if

00:06:14,200 --> 00:06:20,530
you if you read what Dave wrote back

00:06:17,580 --> 00:06:22,540
nineteen years ago and this in this

00:06:20,530 --> 00:06:24,880
paper and scientific computing with

00:06:22,540 --> 00:06:26,890
Python he said you know scientists

00:06:24,880 --> 00:06:29,560
worked with a wide variety of systems

00:06:26,890 --> 00:06:31,660
ranging from simulation codes to data

00:06:29,560 --> 00:06:33,100
analysis packages to databases and

00:06:31,660 --> 00:06:35,740
visualization tools and homegrown

00:06:33,100 --> 00:06:37,750
software each of which presents the user

00:06:35,740 --> 00:06:38,900
with a different set of interfaces and

00:06:37,750 --> 00:06:40,669
file formats

00:06:38,900 --> 00:06:43,070
as a result the scientists may spend

00:06:40,669 --> 00:06:44,750
considerable amounts of time simply

00:06:43,070 --> 00:06:47,990
trying to get all these components to

00:06:44,750 --> 00:06:50,060
work together in some manner and Dave

00:06:47,990 --> 00:06:52,970
and others during that time really

00:06:50,060 --> 00:06:55,610
pushed Python as a solution to do this

00:06:52,970 --> 00:06:58,580
kind of gluing of different processes

00:06:55,610 --> 00:07:02,000
together and submit some interesting

00:06:58,580 --> 00:07:04,789
code from that time as an example as is

00:07:02,000 --> 00:07:07,789
the simplified wrapper and interface

00:07:04,789 --> 00:07:10,100
generator swig and basically what swig

00:07:07,789 --> 00:07:13,490
did was it gave you this really nice

00:07:10,100 --> 00:07:16,070
interface to kind of take your C code or

00:07:13,490 --> 00:07:18,289
your other compiled code and generate

00:07:16,070 --> 00:07:20,930
Python interfaces so you could use them

00:07:18,289 --> 00:07:23,510
more interactively and more more

00:07:20,930 --> 00:07:26,240
intuitively and this really helped pave

00:07:23,510 --> 00:07:28,310
the way for all the sorts of things that

00:07:26,240 --> 00:07:31,880
came later and all the tools that you

00:07:28,310 --> 00:07:33,860
use today so that was a scripting era in

00:07:31,880 --> 00:07:36,949
that in the 90s python is an alternative

00:07:33,860 --> 00:07:39,860
to bash in in the 2000s I like to think

00:07:36,949 --> 00:07:42,440
about that as the SyFy era so the if if

00:07:39,860 --> 00:07:44,660
the sci-fi era had a motto it would be

00:07:42,440 --> 00:07:47,449
Python as an alternative to MATLAB

00:07:44,660 --> 00:07:49,550
you know MATLAB is this is this powerful

00:07:47,449 --> 00:07:51,830
system that a lot of scientists and

00:07:49,550 --> 00:07:53,930
engineer engineers have used and still

00:07:51,830 --> 00:07:56,000
use to do data analysis data

00:07:53,930 --> 00:07:58,669
visualization and things like this and

00:07:56,000 --> 00:08:01,400
in the in the early 2000s a lot of

00:07:58,669 --> 00:08:03,860
people were pretty jazzed about about

00:08:01,400 --> 00:08:05,750
Python as a tool for gluing together

00:08:03,860 --> 00:08:08,210
their data analysis workflows and said

00:08:05,750 --> 00:08:09,800
hey you know why can't we use Python for

00:08:08,210 --> 00:08:14,030
the kind of things that we're using

00:08:09,800 --> 00:08:16,490
MATLAB for right now and one person who

00:08:14,030 --> 00:08:19,940
was instrumental in this is John Hunter

00:08:16,490 --> 00:08:22,490
and in 2012 shortly before he passed

00:08:19,940 --> 00:08:26,300
away he gave a keynote at Syfy where he

00:08:22,490 --> 00:08:28,940
talked about the history of the

00:08:26,300 --> 00:08:31,220
matplotlib project which is the project

00:08:28,940 --> 00:08:32,930
that he created and he said basically in

00:08:31,220 --> 00:08:34,820
the before matplotlib he had a

00:08:32,930 --> 00:08:37,430
hodgepodge of work processes he would

00:08:34,820 --> 00:08:39,589
have Perl scripts and called C++

00:08:37,430 --> 00:08:41,900
routines it would dump data files

00:08:39,589 --> 00:08:43,789
he'd load them in the MATLAB and after a

00:08:41,900 --> 00:08:46,940
while he got tired of MATLAB and he

00:08:43,789 --> 00:08:48,680
started using gnuplot instead

00:08:46,940 --> 00:08:51,200
he looked at this and said you know I

00:08:48,680 --> 00:08:52,910
want I want Python tools that can take

00:08:51,200 --> 00:08:54,950
all these different pieces of my

00:08:52,910 --> 00:08:56,720
workflow and put them into one one

00:08:54,950 --> 00:08:59,440
package

00:08:56,720 --> 00:09:02,810
similarly Travis Oliphant who created

00:08:59,440 --> 00:09:05,150
co-created numpy and Syfy with some

00:09:02,810 --> 00:09:07,400
others in the community he said prior to

00:09:05,150 --> 00:09:10,430
Python I used Perl for a year then

00:09:07,400 --> 00:09:12,920
MATLAB and shell scripts and Fortran C++

00:09:10,430 --> 00:09:14,750
libraries and when I discovered Python I

00:09:12,920 --> 00:09:17,450
really liked the language but it was

00:09:14,750 --> 00:09:19,790
very nation and lacked lots of libraries

00:09:17,450 --> 00:09:21,500
and I felt like I could add value to the

00:09:19,790 --> 00:09:23,780
world by connecting these low-level

00:09:21,500 --> 00:09:26,660
libraries together to high-level usage

00:09:23,780 --> 00:09:28,430
in Python so again the same story he had

00:09:26,660 --> 00:09:30,260
all these different tools he was working

00:09:28,430 --> 00:09:32,020
with and he wanted Python to glue them

00:09:30,260 --> 00:09:34,190
together and to be this kind of one

00:09:32,020 --> 00:09:36,160
workhorse that could do all these

00:09:34,190 --> 00:09:38,870
numerical things

00:09:36,160 --> 00:09:41,360
similarly Fernando Perez who you might

00:09:38,870 --> 00:09:44,930
know as the creator of the ipython and

00:09:41,360 --> 00:09:47,120
Jupiter projects he was a quantum

00:09:44,930 --> 00:09:49,550
physicist at the time and he said he

00:09:47,120 --> 00:09:51,740
remembers looking at his desk seeing all

00:09:49,550 --> 00:09:55,460
the books of languages stacked with

00:09:51,740 --> 00:09:59,960
books on C C++ UNIX utilities Perl

00:09:55,460 --> 00:10:01,130
IDL Mathematica make and I realized I

00:09:59,960 --> 00:10:03,590
was probably spending more time

00:10:01,130 --> 00:10:06,080
switching between languages than getting

00:10:03,590 --> 00:10:08,180
anything done and this is what drove him

00:10:06,080 --> 00:10:10,040
to create the ipython project and to

00:10:08,180 --> 00:10:12,290
start using Python to stitch these

00:10:10,040 --> 00:10:14,870
workflows together so if you look at the

00:10:12,290 --> 00:10:16,640
software that came out of these three

00:10:14,870 --> 00:10:18,620
folks and all the folks around them that

00:10:16,640 --> 00:10:21,290
we're working on the same things these

00:10:18,620 --> 00:10:25,460
big big software packages are a mat plot

00:10:21,290 --> 00:10:28,400
lib around 2000 to scifi around 2000 I

00:10:25,460 --> 00:10:31,880
rapped numpy into sy PI there and I

00:10:28,400 --> 00:10:33,980
Python around 2001 and and I dug through

00:10:31,880 --> 00:10:35,990
the internet to find these like original

00:10:33,980 --> 00:10:38,240
logos for each of these packages they're

00:10:35,990 --> 00:10:41,000
pretty awesome I love the I love the red

00:10:38,240 --> 00:10:44,600
on yellow of matplotlib it's a really

00:10:41,000 --> 00:10:47,960
really good design choice but as time

00:10:44,600 --> 00:10:50,470
went on actually originally each of

00:10:47,960 --> 00:10:53,330
these packages had some components of

00:10:50,470 --> 00:10:55,010
that overlapped they they all had some

00:10:53,330 --> 00:10:57,459
component of visualizations some

00:10:55,010 --> 00:11:00,279
computational tools some

00:10:57,459 --> 00:11:02,829
tools and and eventually as as these

00:11:00,279 --> 00:11:05,050
folks started talking to each other they

00:11:02,829 --> 00:11:07,569
realized that they had some overlap and

00:11:05,050 --> 00:11:09,999
decided to start working together and so

00:11:07,569 --> 00:11:12,660
that brought us to our modern situation

00:11:09,999 --> 00:11:16,629
where we have matplotlib Syfy ipython

00:11:12,660 --> 00:11:19,689
which have distinct use cases within

00:11:16,629 --> 00:11:21,970
within the scientific analysis stack and

00:11:19,689 --> 00:11:23,619
they're all built on numpy which is this

00:11:21,970 --> 00:11:26,019
unified array library that goes

00:11:23,619 --> 00:11:28,779
underneath them all so this is kind of

00:11:26,019 --> 00:11:31,179
like 2000 to 2010 this sort of stuff

00:11:28,779 --> 00:11:33,850
kind of percolate it out and we ended up

00:11:31,179 --> 00:11:36,069
with a really nice stack where we could

00:11:33,850 --> 00:11:38,290
do in Python the kinds of things that

00:11:36,069 --> 00:11:40,689
scientists and engineers had been doing

00:11:38,290 --> 00:11:43,929
in MATLAB and and we're doing and are

00:11:40,689 --> 00:11:45,670
still doing in MATLAB so yeah so that's

00:11:43,929 --> 00:11:47,259
that's the SyFy era and if you look at

00:11:45,670 --> 00:11:49,929
the key conference series the SyFy

00:11:47,259 --> 00:11:52,420
conferences where we're big in that

00:11:49,929 --> 00:11:54,429
starting as a sort of meetups for the

00:11:52,420 --> 00:11:57,579
people developing these tools - now

00:11:54,429 --> 00:11:59,470
where they are the they're the core

00:11:57,579 --> 00:12:03,040
meetups for the for the users of the

00:11:59,470 --> 00:12:04,990
scientific stack in Python ok so we had

00:12:03,040 --> 00:12:06,670
the scripting era that's kind of Python

00:12:04,990 --> 00:12:08,829
as an alternative to bash we have the

00:12:06,670 --> 00:12:11,799
Syfy era Python as an alternative to

00:12:08,829 --> 00:12:13,689
MATLAB and where are we in the last 10

00:12:11,799 --> 00:12:16,420
years that I like to think of the last

00:12:13,689 --> 00:12:19,629
10 years as the as the PI data era and

00:12:16,420 --> 00:12:22,480
if PI data has a motto it would be

00:12:19,629 --> 00:12:26,199
Python as an alternative to our you know

00:12:22,480 --> 00:12:28,660
our has really developed as as a

00:12:26,199 --> 00:12:32,679
powerhouse of a tool for statistical

00:12:28,660 --> 00:12:34,689
analysis in particular and for for

00:12:32,679 --> 00:12:38,889
cleaning and analyzing and interpreting

00:12:34,689 --> 00:12:41,699
and visualizing data in particular and a

00:12:38,889 --> 00:12:45,730
lot a lot of folks in the Python world

00:12:41,699 --> 00:12:47,379
wanted one at a Python alternative to

00:12:45,730 --> 00:12:50,319
our you know they really appreciated the

00:12:47,379 --> 00:12:51,850
beauty of Python and syntax and didn't

00:12:50,319 --> 00:12:53,019
want to have to switch languages when

00:12:51,850 --> 00:12:56,499
they were doing this kind of data

00:12:53,019 --> 00:12:59,499
analysis so I think what kind of kicked

00:12:56,499 --> 00:13:01,450
off the PI data era in a lot of ways was

00:12:59,499 --> 00:13:05,260
Wes McKinney and his work

00:13:01,450 --> 00:13:07,420
the pandas package and and pandas an is

00:13:05,260 --> 00:13:09,340
interesting you know Wes was working at

00:13:07,420 --> 00:13:12,100
the time as a consultant in the

00:13:09,340 --> 00:13:14,800
financial sector where a lot of people

00:13:12,100 --> 00:13:18,010
were using our and other tools of that

00:13:14,800 --> 00:13:20,080
flavor to do data analysis and Wes was

00:13:18,010 --> 00:13:22,600
again one of these people who who wanted

00:13:20,080 --> 00:13:24,670
to use Python he loved the Python

00:13:22,600 --> 00:13:27,120
language and wanted to be able to use

00:13:24,670 --> 00:13:31,030
Python for those kinds of applications

00:13:27,120 --> 00:13:33,730
so if you read in the intro of his book

00:13:31,030 --> 00:13:36,610
Python for data analysis he has a really

00:13:33,730 --> 00:13:39,640
nice discussion of what what led him to

00:13:36,610 --> 00:13:42,040
develop pandas as a library for Python

00:13:39,640 --> 00:13:43,450
and he said I had a distinct set of

00:13:42,040 --> 00:13:45,070
requirements that were not well

00:13:43,450 --> 00:13:47,920
addressed by any single tool at my

00:13:45,070 --> 00:13:50,230
disposal data structures with labelled

00:13:47,920 --> 00:13:53,020
axes integrated time series

00:13:50,230 --> 00:13:55,840
functionality arithmetic operations and

00:13:53,020 --> 00:13:59,020
reductions flexible handling of missing

00:13:55,840 --> 00:14:01,180
data merge and relational operations and

00:13:59,020 --> 00:14:02,800
I wanted to do all these things in one

00:14:01,180 --> 00:14:04,660
place preferably in a language

00:14:02,800 --> 00:14:07,870
well-suited to general purpose software

00:14:04,660 --> 00:14:09,910
development so again you see this theme

00:14:07,870 --> 00:14:12,310
coming through it's people who have

00:14:09,910 --> 00:14:15,040
workflows that involve multiple tools

00:14:12,310 --> 00:14:17,530
and saying you know Python is the tool I

00:14:15,040 --> 00:14:20,230
want to use for this and figuring out

00:14:17,530 --> 00:14:22,570
how can i how can I bring these

00:14:20,230 --> 00:14:25,180
workflows into Python in a way that'll

00:14:22,570 --> 00:14:29,440
help me and help others and so Wes

00:14:25,180 --> 00:14:31,270
created the pandas package other key

00:14:29,440 --> 00:14:33,880
software developments that kind of at

00:14:31,270 --> 00:14:36,310
the in the early 2010's where

00:14:33,880 --> 00:14:38,440
scikit-learn which is a machine learning

00:14:36,310 --> 00:14:41,770
library that a lot of you are familiar

00:14:38,440 --> 00:14:44,040
with Conda is this package manager that

00:14:41,770 --> 00:14:46,540
came around and solved a lot of the

00:14:44,040 --> 00:14:48,880
difficulties with packaging scientific

00:14:46,540 --> 00:14:52,510
software the ipython notebook and later

00:14:48,880 --> 00:14:56,680
the Jupiter project provide a nice

00:14:52,510 --> 00:14:59,320
compute environment for for working on

00:14:56,680 --> 00:15:02,770
analyses and sharing them with your your

00:14:59,320 --> 00:15:04,510
co-workers and colleagues and there was

00:15:02,770 --> 00:15:06,190
this key conference series the PI data

00:15:04,510 --> 00:15:10,740
conference which is expanded to this

00:15:06,190 --> 00:15:13,020
this international set of workshops and

00:15:10,740 --> 00:15:15,810
meetings and it's been really

00:15:13,020 --> 00:15:18,029
interesting to see it to see it grow

00:15:15,810 --> 00:15:20,100
you know the PI data conference is very

00:15:18,029 --> 00:15:23,399
kind of close to my heart because it was

00:15:20,100 --> 00:15:25,500
my first my first Python meeting the

00:15:23,399 --> 00:15:27,720
first talk I gave at a Python meeting

00:15:25,500 --> 00:15:30,450
was at the first PI data workshop in

00:15:27,720 --> 00:15:32,480
March of 2012 I've never been to a

00:15:30,450 --> 00:15:34,230
python conference before that and

00:15:32,480 --> 00:15:36,630
because I'd been working on the

00:15:34,230 --> 00:15:38,220
scikit-learn project they asked me to

00:15:36,630 --> 00:15:41,070
come talk about machine learning and

00:15:38,220 --> 00:15:42,360
Python and it was it was the wildest

00:15:41,070 --> 00:15:44,580
thing you know I walked into this room

00:15:42,360 --> 00:15:47,010
and there were all these there all these

00:15:44,580 --> 00:15:49,830
people who had heard of before who had

00:15:47,010 --> 00:15:51,029
used their software you know Travis all

00:15:49,830 --> 00:15:53,820
the font was sitting over there and

00:15:51,029 --> 00:15:56,520
Fernando Perez and and all these people

00:15:53,820 --> 00:15:58,170
that were like you know in my mind there

00:15:56,520 --> 00:15:59,820
were these these gods of the Python

00:15:58,170 --> 00:16:01,110
language and then I was sitting in the

00:15:59,820 --> 00:16:04,230
room with them and it turned out they're

00:16:01,110 --> 00:16:07,080
just normal people like me and and it

00:16:04,230 --> 00:16:09,360
was so interesting to meet them and to

00:16:07,080 --> 00:16:11,550
get into that and I've been I've been

00:16:09,360 --> 00:16:14,790
enjoying the Python community ever since

00:16:11,550 --> 00:16:16,950
then um so anyway we have these these

00:16:14,790 --> 00:16:19,529
three kind of eras of the Python

00:16:16,950 --> 00:16:21,959
language there were Python developed

00:16:19,529 --> 00:16:24,270
from this kind of alternative to bash

00:16:21,959 --> 00:16:27,300
where you could write dozen line scripts

00:16:24,270 --> 00:16:30,180
all the way into now where you can use

00:16:27,300 --> 00:16:33,329
Python as a as the full stack for

00:16:30,180 --> 00:16:38,279
scientific or scientific data analysis

00:16:33,329 --> 00:16:39,930
and related things so um if there's any

00:16:38,279 --> 00:16:43,770
theme that I want you to take from this

00:16:39,930 --> 00:16:45,899
survey it's that you know people want to

00:16:43,770 --> 00:16:50,820
use Python because they think it's an

00:16:45,899 --> 00:16:55,290
intuitive beautiful language and and

00:16:50,820 --> 00:16:57,750
people people look to the the tasks that

00:16:55,290 --> 00:17:00,000
they have to do and figure out how they

00:16:57,750 --> 00:17:02,399
can use Python for it and that that's

00:17:00,000 --> 00:17:04,260
why we're here today it's because of all

00:17:02,399 --> 00:17:06,120
these individuals who decided they

00:17:04,260 --> 00:17:10,920
wanted to use Python wanted to make the

00:17:06,120 --> 00:17:13,709
ecosystem better and so python has

00:17:10,920 --> 00:17:15,660
incorporated all these lessons learned

00:17:13,709 --> 00:17:17,670
and other tools and communities and

00:17:15,660 --> 00:17:21,480
that's what's what makes Python the

00:17:17,670 --> 00:17:23,250
powerhouse that it is today so it's

00:17:21,480 --> 00:17:24,480
important then to recognize with this

00:17:23,250 --> 00:17:26,220
perspective that

00:17:24,480 --> 00:17:29,760
Python is not a data science language

00:17:26,220 --> 00:17:31,710
right but because of all these

00:17:29,760 --> 00:17:33,840
commitments over the years and all these

00:17:31,710 --> 00:17:36,179
contributions from people it's become

00:17:33,840 --> 00:17:42,059
this this general-purpose language that

00:17:36,179 --> 00:17:43,590
can do data data science well so one way

00:17:42,059 --> 00:17:45,480
I like to think about Python is it sort

00:17:43,590 --> 00:17:47,820
of a Swiss Army knife right you have you

00:17:45,480 --> 00:17:51,090
have this one package with with lots of

00:17:47,820 --> 00:17:52,440
different tools in it but it's different

00:17:51,090 --> 00:17:53,820
than a normal Swiss Army knife because

00:17:52,440 --> 00:17:56,910
it's a it's a Swiss Army knife that

00:17:53,820 --> 00:17:59,390
anybody can contribute to right and so

00:17:56,910 --> 00:18:01,260
so you have lots and lots of different

00:17:59,390 --> 00:18:02,850
opportunities of different tools that

00:18:01,260 --> 00:18:05,610
you can use that are written in Python

00:18:02,850 --> 00:18:08,010
but the strength of that is you have a

00:18:05,610 --> 00:18:10,080
huge capability but the weakness is like

00:18:08,010 --> 00:18:12,390
it's hard to know where to start

00:18:10,080 --> 00:18:15,150
right there's no there's no top-down

00:18:12,390 --> 00:18:16,799
governing bodies saying that this is the

00:18:15,150 --> 00:18:19,559
new package that you should use for

00:18:16,799 --> 00:18:21,150
visualization you have a half dozen

00:18:19,559 --> 00:18:23,220
people trying to solve their own

00:18:21,150 --> 00:18:26,340
visualization problems and putting tools

00:18:23,220 --> 00:18:28,260
out there for you to use and it's really

00:18:26,340 --> 00:18:30,000
hard to work to know where to start when

00:18:28,260 --> 00:18:31,919
you want to do something in Python if

00:18:30,000 --> 00:18:36,210
you've if you've never if you've never

00:18:31,919 --> 00:18:39,299
started with it so the second half of

00:18:36,210 --> 00:18:41,610
the talk now with this framework of you

00:18:39,299 --> 00:18:43,500
know where we've come from what I want

00:18:41,610 --> 00:18:45,809
to talk about now is is where we are

00:18:43,500 --> 00:18:48,240
right now and if you're someone who is

00:18:45,809 --> 00:18:50,850
looking at Python as a potential tool

00:18:48,240 --> 00:18:53,010
for data analysis or for your own work

00:18:50,850 --> 00:18:54,270
you know where should you start and I

00:18:53,010 --> 00:18:56,549
want to give you a little bit of a road

00:18:54,270 --> 00:18:59,160
map of the types of tools that are out

00:18:56,549 --> 00:19:01,890
there and and what you should look at as

00:18:59,160 --> 00:19:05,220
you as you look into this so first you

00:19:01,890 --> 00:19:07,290
need to start by installing Python and

00:19:05,220 --> 00:19:10,290
installing various packages that you can

00:19:07,290 --> 00:19:12,780
use in it and and I would recommend this

00:19:10,290 --> 00:19:15,390
this conda installer

00:19:12,780 --> 00:19:18,090
I know Python packaging has come a long

00:19:15,390 --> 00:19:20,220
way in the last 10 years but Conda was a

00:19:18,090 --> 00:19:24,270
real turning point in my experience

00:19:20,220 --> 00:19:27,090
where you know prior to 2012 I remember

00:19:24,270 --> 00:19:30,240
struggling for hours and hours to try to

00:19:27,090 --> 00:19:32,820
get tools like numpy and Syfy to install

00:19:30,240 --> 00:19:34,860
on my system you know and I was using

00:19:32,820 --> 00:19:37,110
Linux where it was easy you know if

00:19:34,860 --> 00:19:40,080
you're using Windows and forget about it

00:19:37,110 --> 00:19:43,590
never tried compiling scifi on windows

00:19:40,080 --> 00:19:45,840
it's like it's a it's an experience I

00:19:43,590 --> 00:19:49,620
would not wish on my worst enemy

00:19:45,840 --> 00:19:52,860
but unfortunately fortunately the the

00:19:49,620 --> 00:19:54,840
Conda team basically solved this and in

00:19:52,860 --> 00:19:56,790
one swoop where they created this

00:19:54,840 --> 00:19:58,799
package manager called Khan Zdenek it

00:19:56,790 --> 00:20:02,160
basically comes in two flavors you have

00:19:58,799 --> 00:20:03,840
the mini Conda which is basically the

00:20:02,160 --> 00:20:06,240
the smallest thing you need to get

00:20:03,840 --> 00:20:08,100
started it's Python plus the Conda

00:20:06,240 --> 00:20:10,470
installer and you can start installing

00:20:08,100 --> 00:20:12,000
the package as you need or if you don't

00:20:10,470 --> 00:20:14,790
want to have to make decisions you can

00:20:12,000 --> 00:20:17,640
install anaconda which is basically mini

00:20:14,790 --> 00:20:20,490
Conda plus the entire universe of useful

00:20:17,640 --> 00:20:22,530
Python packages so you install that it's

00:20:20,490 --> 00:20:24,900
a few gigabytes and you're just ready to

00:20:22,530 --> 00:20:26,429
go I usually start with mini Conda

00:20:24,900 --> 00:20:29,070
because it's more lightweight and you

00:20:26,429 --> 00:20:31,049
can you can build up what you need and

00:20:29,070 --> 00:20:33,000
if you go to the Conda website you can

00:20:31,049 --> 00:20:36,929
see there's Windows Mac and Linux

00:20:33,000 --> 00:20:37,890
versions 64-bit and 32-bit Python -

00:20:36,929 --> 00:20:39,390
Python 3

00:20:37,890 --> 00:20:42,120
you can choose where you want to start

00:20:39,390 --> 00:20:44,880
I'd say I choose the Python 3 at this

00:20:42,120 --> 00:20:47,100
point and then once you download it you

00:20:44,880 --> 00:20:48,630
install it and you get a get a nice

00:20:47,100 --> 00:20:51,900
little installer and your command line

00:20:48,630 --> 00:20:54,480
and then you have this two things

00:20:51,900 --> 00:20:56,520
installed you have the Conda tool which

00:20:54,480 --> 00:20:58,740
helps you install packages you have

00:20:56,520 --> 00:21:02,160
Python itself which lets you you know

00:20:58,740 --> 00:21:05,160
run Python code and these are both in

00:21:02,160 --> 00:21:07,140
both executables that are installed by

00:21:05,160 --> 00:21:08,940
Conda and now if you want to start

00:21:07,140 --> 00:21:11,760
installing packages you say Conda

00:21:08,940 --> 00:21:14,250
install numpy sci-fi pandas matte bottle

00:21:11,760 --> 00:21:16,650
of Jupiter and it will install them on

00:21:14,250 --> 00:21:18,510
your computer it'll install precompiled

00:21:16,650 --> 00:21:21,960
binaries whether you're on linux or mac

00:21:18,510 --> 00:21:24,840
or windows and it's just it's just slick

00:21:21,960 --> 00:21:26,880
and it works so start with Conda and

00:21:24,840 --> 00:21:29,160
install those those packages you can

00:21:26,880 --> 00:21:31,049
also do more fancy things like create

00:21:29,160 --> 00:21:34,169
environments like you can have a Python

00:21:31,049 --> 00:21:36,240
2.7 environment next to your Python 3.7

00:21:34,169 --> 00:21:38,580
environment with separate packages it

00:21:36,240 --> 00:21:42,360
really makes the whole thing a whole

00:21:38,580 --> 00:21:44,760
thing nice so when you activate this new

00:21:42,360 --> 00:21:46,830
environment then you have different

00:21:44,760 --> 00:21:47,800
Python versions and you can you can

00:21:46,830 --> 00:21:49,570
actually

00:21:47,800 --> 00:21:52,410
run the Python command and you're

00:21:49,570 --> 00:21:55,960
getting your new Python binary it there

00:21:52,410 --> 00:21:58,330
so anyway I feel if you look at my if

00:21:55,960 --> 00:22:01,180
you look at my computer and I and list

00:21:58,330 --> 00:22:03,490
all the environments I tend to use Conda

00:22:01,180 --> 00:22:06,430
to basically separate all the different

00:22:03,490 --> 00:22:08,410
projects that I'm doing I have Conda

00:22:06,430 --> 00:22:10,570
versions for all the major continents

00:22:08,410 --> 00:22:13,570
for all the major python versions and

00:22:10,570 --> 00:22:15,790
then for the various thing various tools

00:22:13,570 --> 00:22:18,280
that I'm working on I have development

00:22:15,790 --> 00:22:20,650
environments for say Astro pie or sigh

00:22:18,280 --> 00:22:24,840
higher scikit-learn or Vega and keeping

00:22:20,650 --> 00:22:27,790
these things separate means that when I

00:22:24,840 --> 00:22:30,790
say when I when I try something new and

00:22:27,790 --> 00:22:33,070
Sai PI I don't break the environment

00:22:30,790 --> 00:22:35,530
that I need to use to start analyzing my

00:22:33,070 --> 00:22:37,120
data for for my other projects so it's

00:22:35,530 --> 00:22:39,970
nice to sort of keep things separate

00:22:37,120 --> 00:22:41,620
Kondos a good tool for this and just as

00:22:39,970 --> 00:22:44,890
a little side note there's also this

00:22:41,620 --> 00:22:46,450
tool called pip which is for installing

00:22:44,890 --> 00:22:48,310
Python packages and if you're curious

00:22:46,450 --> 00:22:52,270
about the difference between Conda and

00:22:48,310 --> 00:22:54,580
pip it just briefly pip is something

00:22:52,270 --> 00:22:57,340
that installs Python packages in any

00:22:54,580 --> 00:23:00,190
environments and Conda is something them

00:22:57,340 --> 00:23:02,740
stalls any package in a Conda

00:23:00,190 --> 00:23:04,750
environment right so so Conda is a

00:23:02,740 --> 00:23:07,810
little more broad and that it can

00:23:04,750 --> 00:23:11,910
install things like Fortran tools that

00:23:07,810 --> 00:23:14,380
underlie your libraries but pizzle is

00:23:11,910 --> 00:23:16,660
specific to python but it can it can

00:23:14,380 --> 00:23:18,940
kind of work anywhere so anyway that

00:23:16,660 --> 00:23:21,730
that's package managers for for you for

00:23:18,940 --> 00:23:23,980
getting started with python so and now

00:23:21,730 --> 00:23:25,600
if you once you have your packages

00:23:23,980 --> 00:23:28,000
installed you need an environment to

00:23:25,600 --> 00:23:31,000
start coding in and I often recommend

00:23:28,000 --> 00:23:35,260
people start with Jupiter or Jupiter lab

00:23:31,000 --> 00:23:37,030
so Jupiter lab is is basically you can

00:23:35,260 --> 00:23:41,470
think about it as a front end in which

00:23:37,030 --> 00:23:45,250
you can develop your code execute your

00:23:41,470 --> 00:23:47,800
code and share it so if you cond install

00:23:45,250 --> 00:23:49,540
Jupiter lab and then run Jupiter lab

00:23:47,800 --> 00:23:52,210
from the command line you get this this

00:23:49,540 --> 00:23:53,980
nice little web UI coming up and what

00:23:52,210 --> 00:23:56,500
jupiter does is it gives you a

00:23:53,980 --> 00:23:58,400
browser-based interface where you can

00:23:56,500 --> 00:24:01,370
start executing pi

00:23:58,400 --> 00:24:03,140
code so you open a new notebook and you

00:24:01,370 --> 00:24:06,020
have the stupider notebook right here

00:24:03,140 --> 00:24:10,580
you start entering code and the cool

00:24:06,020 --> 00:24:12,530
thing about Jupiter lab is that the the

00:24:10,580 --> 00:24:14,510
outputs of the code are embedded right

00:24:12,530 --> 00:24:16,190
there in the notebook including

00:24:14,510 --> 00:24:18,440
visualizations you know you don't have a

00:24:16,190 --> 00:24:20,480
separate window popping up and you can

00:24:18,440 --> 00:24:23,750
kind of keep all your code all your data

00:24:20,480 --> 00:24:26,240
all your outputs in one place and and

00:24:23,750 --> 00:24:29,570
jupiter lab is a really interesting and

00:24:26,240 --> 00:24:31,430
dynamic thing it's the the it's it's

00:24:29,570 --> 00:24:33,620
built on the jupiter notebook which has

00:24:31,430 --> 00:24:36,110
been around for about seven years now in

00:24:33,620 --> 00:24:39,830
one form or another but jupiter lab

00:24:36,110 --> 00:24:42,740
itself is is a more full-featured ide a

00:24:39,830 --> 00:24:45,080
full-featured interactive development

00:24:42,740 --> 00:24:48,290
environment where you can you can edit

00:24:45,080 --> 00:24:50,480
text files you can edit notebooks you

00:24:48,290 --> 00:24:53,270
can view images you can view various

00:24:50,480 --> 00:24:56,210
file types and it gives you a really

00:24:53,270 --> 00:24:59,900
flexible way to start exploring the the

00:24:56,210 --> 00:25:02,450
python ecosystem so that that's the

00:24:59,900 --> 00:25:04,070
coding environment and and something

00:25:02,450 --> 00:25:05,900
that's that's based on the Jupiter

00:25:04,070 --> 00:25:07,220
system and and built on top of that

00:25:05,900 --> 00:25:09,710
which is really interesting is this

00:25:07,220 --> 00:25:13,640
project called binder and you can think

00:25:09,710 --> 00:25:15,560
of binder as a way to take your Jupiter

00:25:13,640 --> 00:25:16,970
notebooks and your Jupiter lab projects

00:25:15,560 --> 00:25:20,540
that are stored on a place like github

00:25:16,970 --> 00:25:22,340
and and open them and view them live

00:25:20,540 --> 00:25:25,460
without having to do anything on your

00:25:22,340 --> 00:25:28,340
own computer it's it's a way of kind of

00:25:25,460 --> 00:25:32,090
like turning your get git repo into

00:25:28,340 --> 00:25:35,690
something that you or the users or your

00:25:32,090 --> 00:25:39,440
collaborators can execute and and work

00:25:35,690 --> 00:25:41,510
with interactively so for example my

00:25:39,440 --> 00:25:44,930
Python data science handbook I have this

00:25:41,510 --> 00:25:47,030
this launch binder button and all the

00:25:44,930 --> 00:25:49,550
content of the book is on github in the

00:25:47,030 --> 00:25:51,500
form of Jupiter notebooks and with

00:25:49,550 --> 00:25:53,720
binder what this means is you can you

00:25:51,500 --> 00:25:56,210
can launch it and you have the

00:25:53,720 --> 00:25:58,250
interactive notebooks there to start

00:25:56,210 --> 00:26:00,650
executing code and exploring the code

00:25:58,250 --> 00:26:02,510
and modifying things and seeing what you

00:26:00,650 --> 00:26:02,990
can do without having to run anything on

00:26:02,510 --> 00:26:06,200
your own

00:26:02,990 --> 00:26:07,520
computer so it's a really cool system

00:26:06,200 --> 00:26:10,809
that's been developed by it by the

00:26:07,520 --> 00:26:13,340
Jupiter folks I should also mention a

00:26:10,809 --> 00:26:15,050
similar in some ways similar thing as

00:26:13,340 --> 00:26:16,940
this project called Google collab this

00:26:15,050 --> 00:26:19,040
has been the project that I've worked on

00:26:16,940 --> 00:26:22,280
at Google in the last year or so and

00:26:19,040 --> 00:26:24,530
it's basically a Jupiter notebook on top

00:26:22,280 --> 00:26:27,170
of Google's computing infrastructure and

00:26:24,530 --> 00:26:30,790
backed by Google Drive so if you use

00:26:27,170 --> 00:26:33,350
Google Docs to to store your files

00:26:30,790 --> 00:26:35,630
collab is basically a way to store your

00:26:33,350 --> 00:26:38,000
Jupiter notebooks on Google Drive and to

00:26:35,630 --> 00:26:41,090
execute them in the cloud all for free

00:26:38,000 --> 00:26:43,610
and a nice thing about it is it's zero

00:26:41,090 --> 00:26:46,250
setup you can share with people and you

00:26:43,610 --> 00:26:48,620
have free access to hardware like GPUs

00:26:46,250 --> 00:26:51,590
and TP use that let you do powerful

00:26:48,620 --> 00:26:54,140
computing without having to invest in

00:26:51,590 --> 00:26:57,800
you know invest in your own computer and

00:26:54,140 --> 00:27:00,790
the amount of money and time it takes to

00:26:57,800 --> 00:27:04,010
get something like that set up locally

00:27:00,790 --> 00:27:06,950
so from there you know we have that our

00:27:04,010 --> 00:27:08,660
computing environment now what if you

00:27:06,950 --> 00:27:12,320
want to do some numerical computation

00:27:08,660 --> 00:27:15,830
the real powerhouse behind most of

00:27:12,320 --> 00:27:17,660
pythons machine learning and data

00:27:15,830 --> 00:27:20,600
analysis packages is this package called

00:27:17,660 --> 00:27:22,990
numpy numpy stands for numerical Python

00:27:20,600 --> 00:27:26,240
you can Conda install a numpy and

00:27:22,990 --> 00:27:29,240
essentially the core of what numpy is is

00:27:26,240 --> 00:27:32,540
an ND array objects it's basically a

00:27:29,240 --> 00:27:35,990
very flexible container for your data

00:27:32,540 --> 00:27:37,610
and you can you can define your data and

00:27:35,990 --> 00:27:40,309
you can start doing arithmetic

00:27:37,610 --> 00:27:42,670
operations on your data like here we're

00:27:40,309 --> 00:27:46,160
taking the the contents of this X ray

00:27:42,670 --> 00:27:48,740
multiplying it by 2 and adding 1 and we

00:27:46,160 --> 00:27:51,500
get the array out this element or a wise

00:27:48,740 --> 00:27:56,030
arithmetic and notice that the like the

00:27:51,500 --> 00:27:59,559
loops and and the handling of memory and

00:27:56,030 --> 00:27:59,559
things like that here are implicit

00:28:02,450 --> 00:28:07,260
so with with numpy you can do a lot of

00:28:05,190 --> 00:28:09,510
different numerical computation for

00:28:07,260 --> 00:28:10,980
example linear algebra is built-in if

00:28:09,510 --> 00:28:12,870
you want to do something like a singular

00:28:10,980 --> 00:28:15,180
value decomposition this is a

00:28:12,870 --> 00:28:19,050
fundamental operation that underlies a

00:28:15,180 --> 00:28:22,590
lot of machine learning algorithms you

00:28:19,050 --> 00:28:25,110
can do that in one line and numpy and if

00:28:22,590 --> 00:28:29,250
you look into more high-level tools like

00:28:25,110 --> 00:28:31,920
scikit-learn scikit-learn is using numpy

00:28:29,250 --> 00:28:33,870
linear algebra tools under the hood to

00:28:31,920 --> 00:28:36,780
provide you an API to do machine

00:28:33,870 --> 00:28:38,850
learning in a very convenient manner you

00:28:36,780 --> 00:28:41,510
can do other things like fast Fourier

00:28:38,850 --> 00:28:46,830
transforms and a lot of the core

00:28:41,510 --> 00:28:49,110
routines that underlie data analysis so

00:28:46,830 --> 00:28:50,970
the key to using numpy effectively if

00:28:49,110 --> 00:28:55,920
you if you start digging into this is

00:28:50,970 --> 00:28:58,440
something known as vectorization so if

00:28:55,920 --> 00:29:00,990
you come from a language like C or Java

00:28:58,440 --> 00:29:03,720
or Fortran you might be used to doing

00:29:00,990 --> 00:29:05,820
these kinds of things by hand now you

00:29:03,720 --> 00:29:08,820
have an array of data and you say I want

00:29:05,820 --> 00:29:11,340
to I want to operate on each value in

00:29:08,820 --> 00:29:14,250
this array you might be tempted to write

00:29:11,340 --> 00:29:16,710
a for loop where you take the you take a

00:29:14,250 --> 00:29:20,280
define an array for the result you loop

00:29:16,710 --> 00:29:21,840
through each value you assign the you

00:29:20,280 --> 00:29:23,940
operate on each value and assign it to

00:29:21,840 --> 00:29:26,760
the output but if you time this in

00:29:23,940 --> 00:29:29,580
Python this for for what is this 10

00:29:26,760 --> 00:29:32,610
million values takes about 6 seconds

00:29:29,580 --> 00:29:36,600
which is really phenomenally slow in the

00:29:32,610 --> 00:29:38,310
age of of modern CPUs right Python when

00:29:36,600 --> 00:29:40,800
you start looping over data and doing

00:29:38,310 --> 00:29:44,520
repeated operations Python is really

00:29:40,800 --> 00:29:47,550
really slow but when you use tools like

00:29:44,520 --> 00:29:49,800
numpy you get by by using this

00:29:47,550 --> 00:29:52,050
vectorized approach not only do you do

00:29:49,800 --> 00:29:55,080
you avoid the need to write these for

00:29:52,050 --> 00:29:59,220
loops explicitly but you get a hundred x

00:29:55,080 --> 00:30:01,800
speed-up just by writing writing more

00:29:59,220 --> 00:30:03,600
intuitive code that's because what numpy

00:30:01,800 --> 00:30:05,520
is doing is it's taking these operations

00:30:03,600 --> 00:30:08,190
and pushing them from the slow Python

00:30:05,520 --> 00:30:08,780
layer down into the compiled C layer

00:30:08,190 --> 00:30:13,250
under the

00:30:08,780 --> 00:30:16,160
hood so if you want to know more about

00:30:13,250 --> 00:30:17,630
this I have a talk from PyCon 2015 and

00:30:16,160 --> 00:30:20,870
there's this also a lot of other

00:30:17,630 --> 00:30:23,030
interesting resources online to learn

00:30:20,870 --> 00:30:26,660
more about vectorization and using numpy

00:30:23,030 --> 00:30:28,970
effectively so so numpy is good for kind

00:30:26,660 --> 00:30:32,540
of raw data sets but if in the real

00:30:28,970 --> 00:30:35,060
world data has labels right you have and

00:30:32,540 --> 00:30:36,830
and often you don't want to access your

00:30:35,060 --> 00:30:39,500
data by index you want to access your

00:30:36,830 --> 00:30:41,420
data by the the labels of the columns

00:30:39,500 --> 00:30:44,060
and this is where where pandas comes in

00:30:41,420 --> 00:30:46,820
pandas the name comes from panel data

00:30:44,060 --> 00:30:49,460
and it's basically an answer to ours

00:30:46,820 --> 00:30:52,700
data frame within within the Python

00:30:49,460 --> 00:30:54,560
world and what what pandas gives you is

00:30:52,700 --> 00:30:57,340
kind of a wrapper around num PI's

00:30:54,560 --> 00:30:59,840
functionality that lets you access

00:30:57,340 --> 00:31:02,720
sections of your data by name rather

00:30:59,840 --> 00:31:04,940
than by index so you create a data frame

00:31:02,720 --> 00:31:07,250
with a with a column named X and the

00:31:04,940 --> 00:31:10,580
column name y and you can start

00:31:07,250 --> 00:31:12,980
manipulating these data these pieces of

00:31:10,580 --> 00:31:16,040
data by name so create a new column

00:31:12,980 --> 00:31:18,650
that's called X plus 2y and just do do

00:31:16,040 --> 00:31:20,450
what comes natural undo the column plus

00:31:18,650 --> 00:31:22,930
two times the other column and and it

00:31:20,450 --> 00:31:26,020
creates the data frame for you

00:31:22,930 --> 00:31:29,960
pandas have the real strength is reading

00:31:26,020 --> 00:31:31,310
serialized data files like CSV numpy has

00:31:29,960 --> 00:31:33,830
some tools for this but they're not

00:31:31,310 --> 00:31:36,380
nearly as mature user-friendly as the

00:31:33,830 --> 00:31:39,050
pandas versions so you can read data in

00:31:36,380 --> 00:31:42,490
one line from a CSV file or a JSON file

00:31:39,050 --> 00:31:45,260
or a database or any other data source

00:31:42,490 --> 00:31:48,770
and then once you have the data you can

00:31:45,260 --> 00:31:50,660
start doing fast sequel like grouping

00:31:48,770 --> 00:31:56,150
and aggregation and the other the other

00:31:50,660 --> 00:31:59,210
types of of algorithms that really go

00:31:56,150 --> 00:32:02,330
that go into more complicated data

00:31:59,210 --> 00:32:04,750
analysis so we can group by the ID and

00:32:02,330 --> 00:32:08,420
take the sum and we see here that I

00:32:04,750 --> 00:32:10,250
gotta make my tools go away this sum sum

00:32:08,420 --> 00:32:12,500
of all the a values is four and the sum

00:32:10,250 --> 00:32:15,400
of all the B values is six this might

00:32:12,500 --> 00:32:17,540
seem small but but having this kind of

00:32:15,400 --> 00:32:19,880
functionality and in a very efficient

00:32:17,540 --> 00:32:21,100
manner is huge and there's not really

00:32:19,880 --> 00:32:25,390
any easy

00:32:21,100 --> 00:32:27,220
to do this and numpy by itself okay so

00:32:25,390 --> 00:32:29,490
you have your data analysis numpy and

00:32:27,220 --> 00:32:32,380
pandas and now you want to visualize it

00:32:29,490 --> 00:32:34,809
matplotlib is this core visualization

00:32:32,380 --> 00:32:38,080
tool that's been used for for almost

00:32:34,809 --> 00:32:41,950
twenty years now and to give you an idea

00:32:38,080 --> 00:32:44,289
of how pervasive matplotlib is in my PhD

00:32:41,950 --> 00:32:47,080
work in astronomy basically every

00:32:44,289 --> 00:32:49,210
research paper I ever published had all

00:32:47,080 --> 00:32:51,309
matte palette plots I never used any

00:32:49,210 --> 00:32:54,159
other visualization tool to create plots

00:32:51,309 --> 00:32:56,470
and my papers so if a matte pot Lib is

00:32:54,159 --> 00:32:58,150
really powerful and lets you do do a lot

00:32:56,470 --> 00:33:00,549
of amazing things you can create pretty

00:32:58,150 --> 00:33:01,860
much any figure in any visualization

00:33:00,549 --> 00:33:05,020
with matplotlib

00:33:01,860 --> 00:33:08,169
so what it looks like is this is you

00:33:05,020 --> 00:33:10,600
have a plot function and you pass in two

00:33:08,169 --> 00:33:15,309
arrays and it gives you the output so

00:33:10,600 --> 00:33:17,260
here's plotting a sine and a cosine but

00:33:15,309 --> 00:33:19,360
these days is that there's a lot of

00:33:17,260 --> 00:33:22,000
things that that people want to do that

00:33:19,360 --> 00:33:24,309
matplotlib can't do and the biggest

00:33:22,000 --> 00:33:27,340
example of that is interactive

00:33:24,309 --> 00:33:29,200
visualization on the web so if you click

00:33:27,340 --> 00:33:30,970
on a website and you see an interactive

00:33:29,200 --> 00:33:33,400
chart where you're clicking and zooming

00:33:30,970 --> 00:33:34,900
and scrolling matplotlib can't really do

00:33:33,400 --> 00:33:36,940
that so there's there's been a number of

00:33:34,900 --> 00:33:39,480
packages that have come along that have

00:33:36,940 --> 00:33:42,450
tried to address this need Oh

00:33:39,480 --> 00:33:44,289
[Music]

00:33:42,450 --> 00:33:46,330
before I get into the interactive

00:33:44,289 --> 00:33:49,980
packages see the other thing that matte

00:33:46,330 --> 00:33:53,289
pot Lib doesn't do very well is Handel

00:33:49,980 --> 00:33:55,600
named data like in pandas so pandas

00:33:53,289 --> 00:33:56,049
itself actually has a wrapper on mat pot

00:33:55,600 --> 00:33:59,860
Lib

00:33:56,049 --> 00:34:02,440
that lets you plot data by name rather

00:33:59,860 --> 00:34:04,780
than by index so if we take a data frame

00:34:02,440 --> 00:34:06,400
and we do plot dot scatter and say we

00:34:04,780 --> 00:34:08,409
want to scatter the petal length versus

00:34:06,400 --> 00:34:12,820
the petal width we get that scatter

00:34:08,409 --> 00:34:16,300
plots and similarly the Seabourn package

00:34:12,820 --> 00:34:19,050
has this pear plot function and an other

00:34:16,300 --> 00:34:22,750
functionality that lets you do more

00:34:19,050 --> 00:34:26,580
let's see do more specialized plotting

00:34:22,750 --> 00:34:26,580
in in a few lines of code

00:34:28,450 --> 00:34:33,290
another another package that's really

00:34:31,010 --> 00:34:36,559
interesting that builds on matplotlib is

00:34:33,290 --> 00:34:39,800
this one called plot 9 and if you if

00:34:36,559 --> 00:34:41,389
you're used to r as a GG plot plot 9 is

00:34:39,800 --> 00:34:43,909
a really nice answer to that it

00:34:41,389 --> 00:34:47,179
basically gives you the GG plot API with

00:34:43,909 --> 00:34:49,669
in Python and outputs matplotlib plots

00:34:47,179 --> 00:34:52,730
so you can do things like define the

00:34:49,669 --> 00:34:55,609
aesthetic define the geometry whoops

00:34:52,730 --> 00:34:57,980
define the statistics and the kinds of

00:34:55,609 --> 00:34:59,720
facet you want and if you're an R user

00:34:57,980 --> 00:35:01,490
this should look really familiar you get

00:34:59,720 --> 00:35:04,040
this sort of grammatical approach to

00:35:01,490 --> 00:35:04,960
plotting that but you get it with

00:35:04,040 --> 00:35:07,490
matplotlib

00:35:04,960 --> 00:35:09,290
so yeah a lot of tools built on

00:35:07,490 --> 00:35:11,750
matplotlib and then and then going into

00:35:09,290 --> 00:35:14,390
this more like web visual interactive

00:35:11,750 --> 00:35:16,970
visualizations stuff there's a tool

00:35:14,390 --> 00:35:18,800
called bouquet and bouquets strengths

00:35:16,970 --> 00:35:22,790
are that it's really good at analyzing

00:35:18,800 --> 00:35:27,230
large data sets in a in an interactive

00:35:22,790 --> 00:35:28,640
in browser manner you can do lots lots

00:35:27,230 --> 00:35:31,160
of different things so again you can

00:35:28,640 --> 00:35:33,859
check this out another tool there's a

00:35:31,160 --> 00:35:36,680
company a startup called plotly that has

00:35:33,859 --> 00:35:39,220
a tool called plot lay that that does is

00:35:36,680 --> 00:35:41,869
similar in spirit let's see do a lot of

00:35:39,220 --> 00:35:45,230
interesting kind of interactive and

00:35:41,869 --> 00:35:47,450
dynamic visualization from Python and

00:35:45,230 --> 00:35:50,660
one thing that plotly does really well

00:35:47,450 --> 00:35:52,160
is it has tools for animations so if

00:35:50,660 --> 00:35:55,040
you--if you want to create animations

00:35:52,160 --> 00:35:58,069
within your browser in python plotly is

00:35:55,040 --> 00:36:00,650
a good tool for you and then a tool that

00:35:58,069 --> 00:36:03,079
i've been working on as this has been my

00:36:00,650 --> 00:36:05,420
project my open source project for the

00:36:03,079 --> 00:36:07,700
last couple years is called altair and

00:36:05,420 --> 00:36:12,290
basically this is what we wanted to do

00:36:07,700 --> 00:36:14,359
with altair is provide a grammar based

00:36:12,290 --> 00:36:17,510
approach to plotting similar in spirit

00:36:14,359 --> 00:36:20,119
to ggplot but based on a somewhat

00:36:17,510 --> 00:36:23,260
different grammar of graphics that lets

00:36:20,119 --> 00:36:25,540
you kind of more intuitively define

00:36:23,260 --> 00:36:29,990
complicated interactive visualizations

00:36:25,540 --> 00:36:31,339
from Python and Altair lets you do lets

00:36:29,990 --> 00:36:35,119
you do a lot of interesting things like

00:36:31,339 --> 00:36:37,549
linking plots across each other so you

00:36:35,119 --> 00:36:40,699
can you interact with one plot and at

00:36:37,549 --> 00:36:43,099
it updates the other plots and things

00:36:40,699 --> 00:36:46,939
like this and all of this in a in a very

00:36:43,099 --> 00:36:48,199
compact sensical API so if you're

00:36:46,939 --> 00:36:49,849
interested in that I have some talks

00:36:48,199 --> 00:36:53,029
online that you can look at or you can

00:36:49,849 --> 00:36:54,859
look at the Saltaire tutorial or other

00:36:53,029 --> 00:36:57,289
altaïr resources online and I'm happy to

00:36:54,859 --> 00:37:01,939
chat about that a little bit with you

00:36:57,289 --> 00:37:03,259
afterwards so if you want to kind of

00:37:01,939 --> 00:37:04,789
make sense of it all and you don't know

00:37:03,259 --> 00:37:07,999
where to start in the visualization

00:37:04,789 --> 00:37:10,219
world there's this cool website called

00:37:07,999 --> 00:37:13,459
PI VA's which is essentially an effort

00:37:10,219 --> 00:37:21,079
to to organize this information about

00:37:13,459 --> 00:37:22,219
visualization and ok so so some

00:37:21,079 --> 00:37:26,509
interesting things that have happened

00:37:22,219 --> 00:37:28,159
recently in this space are something for

00:37:26,509 --> 00:37:30,009
for dashboarding there's this project

00:37:28,159 --> 00:37:35,059
called panel that's come out recently

00:37:30,009 --> 00:37:39,640
and what what this lets you do is use

00:37:35,059 --> 00:37:42,979
Python to to to quickly define

00:37:39,640 --> 00:37:44,869
interactive dashboards with callbacks to

00:37:42,979 --> 00:37:48,499
the Python kernel that you can even post

00:37:44,869 --> 00:37:50,779
on websites and and let you know kind of

00:37:48,499 --> 00:37:52,880
users see without having to without

00:37:50,779 --> 00:37:55,399
having them them having to run the code

00:37:52,880 --> 00:37:57,409
themselves so this is an example if you

00:37:55,399 --> 00:38:00,289
take if you take an Altair chart and

00:37:57,409 --> 00:38:03,380
this is a simple basically a function

00:38:00,289 --> 00:38:06,049
that makes a chart given a stock symbol

00:38:03,380 --> 00:38:07,819
so we we get the stock data and we

00:38:06,049 --> 00:38:10,429
choose that symbol from there and we

00:38:07,819 --> 00:38:13,909
chart mark line and encode the date

00:38:10,429 --> 00:38:16,880
versus the price and so if we plot Apple

00:38:13,909 --> 00:38:20,269
here from this data we see apples stock

00:38:16,880 --> 00:38:22,369
chart there and what panel lets you do

00:38:20,269 --> 00:38:25,309
is it lets you take this function this

00:38:22,369 --> 00:38:27,049
make chart function and pass it to a

00:38:25,309 --> 00:38:31,429
method that creates an interactive

00:38:27,049 --> 00:38:35,839
version of it and then embeds that in an

00:38:31,429 --> 00:38:37,849
output display and it gives you it gives

00:38:35,839 --> 00:38:40,130
you a little widget that lets you lets

00:38:37,849 --> 00:38:42,380
you choose the input value lets the user

00:38:40,130 --> 00:38:44,869
choose the input value and then have the

00:38:42,380 --> 00:38:47,299
result be reflected right there and the

00:38:44,869 --> 00:38:49,699
key to this is that this function this

00:38:47,299 --> 00:38:50,990
make chart function can do anything you

00:38:49,699 --> 00:38:53,030
know this could be

00:38:50,990 --> 00:38:55,520
this could run a machine learning model

00:38:53,030 --> 00:38:58,010
or fit some sort of some sort of

00:38:55,520 --> 00:39:00,829
sophisticated process to your data and

00:38:58,010 --> 00:39:03,109
if you look at the panel website they

00:39:00,829 --> 00:39:05,240
have examples of this where this is live

00:39:03,109 --> 00:39:07,069
on the internet you click on the example

00:39:05,240 --> 00:39:09,200
and you get a version of this that you

00:39:07,069 --> 00:39:11,119
can just you can just look at and it's

00:39:09,200 --> 00:39:13,490
you know it's it's a dozen lines of

00:39:11,119 --> 00:39:15,500
Python code and it makes the it makes

00:39:13,490 --> 00:39:17,990
creating kind of interactive

00:39:15,500 --> 00:39:22,609
browser-based explorations of data a

00:39:17,990 --> 00:39:24,440
very intuitive and easy thing to do so

00:39:22,609 --> 00:39:26,510
it's it's a cool project and like I say

00:39:24,440 --> 00:39:28,339
this is relatively new I've just heard

00:39:26,510 --> 00:39:30,230
about this in the last maybe six months

00:39:28,339 --> 00:39:32,420
and it's out from the same people who

00:39:30,230 --> 00:39:35,150
created anaconda and bouquet and some of

00:39:32,420 --> 00:39:37,460
those other projects so to check it out

00:39:35,150 --> 00:39:42,530
take a look at that it's a it's fun to

00:39:37,460 --> 00:39:45,859
look at ok so we have our computing

00:39:42,530 --> 00:39:47,930
platform and Jupiter we have our we have

00:39:45,859 --> 00:39:50,119
our numerical data analysis libraries

00:39:47,930 --> 00:39:51,859
wherever visualization what if you want

00:39:50,119 --> 00:39:54,650
to go a little bit beyond that and start

00:39:51,859 --> 00:39:57,710
doing some more sophisticated analysis

00:39:54,650 --> 00:40:00,020
so Syfy is the the tool that you want

00:39:57,710 --> 00:40:01,700
for that and this has been like I

00:40:00,020 --> 00:40:05,000
mentioned this has been used for about

00:40:01,700 --> 00:40:07,670
the past 20 years as a tool for doing

00:40:05,000 --> 00:40:09,250
scientific analysis in Python and it has

00:40:07,670 --> 00:40:12,440
a whole host of interesting

00:40:09,250 --> 00:40:14,809
functionality you know a lot of the when

00:40:12,440 --> 00:40:17,359
I was doing when I was developing new

00:40:14,809 --> 00:40:19,730
algorithms to analyze Astrophysical data

00:40:17,359 --> 00:40:21,950
a lot of the approaches that I used were

00:40:19,730 --> 00:40:25,460
straight out of Syfy because it has

00:40:21,950 --> 00:40:27,819
things for sparse matrix interpolation

00:40:25,460 --> 00:40:30,460
of data and numerical integration

00:40:27,819 --> 00:40:33,559
spatial metrics statistical functions

00:40:30,460 --> 00:40:35,390
optimization linear algebra mathematical

00:40:33,559 --> 00:40:37,700
functions if you're if you're a

00:40:35,390 --> 00:40:39,349
physicist and you you like your Bessel

00:40:37,700 --> 00:40:42,619
functions you can compete your Bessel

00:40:39,349 --> 00:40:44,450
functions with sci-fi related trance for

00:40:42,619 --> 00:40:46,670
your transform Fourier transforms and

00:40:44,450 --> 00:40:49,099
similar things so anything you want to

00:40:46,670 --> 00:40:53,119
do in Python you can you can basically

00:40:49,099 --> 00:40:57,500
do with sci-fi an example of this here's

00:40:53,119 --> 00:41:01,950
a few lines of code where we create a

00:40:57,500 --> 00:41:05,240
we create an X grid we minimize the

00:41:01,950 --> 00:41:09,780
first order bessel function over that X

00:41:05,240 --> 00:41:12,840
we plot the result and we plot the the

00:41:09,780 --> 00:41:15,240
minimum play the the minimum point in

00:41:12,840 --> 00:41:17,160
that result right here so this red point

00:41:15,240 --> 00:41:20,370
right here is the minimum that we found

00:41:17,160 --> 00:41:21,930
based on this optimize minimize so a few

00:41:20,370 --> 00:41:24,390
lines of code and you're able to do

00:41:21,930 --> 00:41:26,970
these things that you know if you're

00:41:24,390 --> 00:41:29,370
right if you're used to being a old

00:41:26,970 --> 00:41:31,080
school scientific code or doing this by

00:41:29,370 --> 00:41:33,660
hand this would be a lot of lines of

00:41:31,080 --> 00:41:35,400
Fortran but you can do it in in just a

00:41:33,660 --> 00:41:37,230
few lines of Python and that's really

00:41:35,400 --> 00:41:40,200
the power of Python for for data

00:41:37,230 --> 00:41:42,750
analysis if you want to go a little bit

00:41:40,200 --> 00:41:44,700
beyond that and and do machine learning

00:41:42,750 --> 00:41:46,530
you can you can use this package called

00:41:44,700 --> 00:41:48,780
scikit-learn and essentially what

00:41:46,530 --> 00:41:51,240
scikit-learn does is it takes numpy and

00:41:48,780 --> 00:41:53,250
SCI PI and all the tools the lower-level

00:41:51,240 --> 00:41:56,490
tools available in there and gives you a

00:41:53,250 --> 00:41:59,040
high-level API for machine learning so

00:41:56,490 --> 00:42:03,660
here's an example if we create an array

00:41:59,040 --> 00:42:07,860
of random X points we compute a function

00:42:03,660 --> 00:42:10,020
Y is sine X plus some noise we plot it

00:42:07,860 --> 00:42:10,560
we get we get some data that looks like

00:42:10,020 --> 00:42:13,260
this

00:42:10,560 --> 00:42:15,480
now how might you find kind of smooth

00:42:13,260 --> 00:42:18,480
this data and find the line of best fit

00:42:15,480 --> 00:42:20,460
in there with it with scikit-learn it's

00:42:18,480 --> 00:42:22,770
a it's a few lines of code we can use

00:42:20,460 --> 00:42:25,080
basically we use something like a random

00:42:22,770 --> 00:42:26,730
forest regressor this is just one

00:42:25,080 --> 00:42:31,590
example of a machine learning algorithm

00:42:26,730 --> 00:42:34,170
that's available and once you have your

00:42:31,590 --> 00:42:36,720
once you have your model that you create

00:42:34,170 --> 00:42:39,120
you can fit it to your data so we're

00:42:36,720 --> 00:42:41,460
gonna fit it to our X data and our Y

00:42:39,120 --> 00:42:43,680
data this little colon newaccess thing

00:42:41,460 --> 00:42:45,840
is just to basically take the data from

00:42:43,680 --> 00:42:49,290
a row array and turn it into a column

00:42:45,840 --> 00:42:51,720
array and then we can compute the grid

00:42:49,290 --> 00:42:54,540
on which we want to fit it and then we

00:42:51,720 --> 00:42:56,870
predict on this grid and figure out what

00:42:54,540 --> 00:42:59,370
the Y values are and we plot the results

00:42:56,870 --> 00:43:01,020
plot plot the data and plot the fit on

00:42:59,370 --> 00:43:04,050
top of it so this is this is what a

00:43:01,020 --> 00:43:06,360
simple random forest model gives for

00:43:04,050 --> 00:43:09,060
this data set and and the power of

00:43:06,360 --> 00:43:10,830
scikit-learn is that the API is regular

00:43:09,060 --> 00:43:13,320
enough that if you want to use a

00:43:10,830 --> 00:43:16,290
current model like a support vector

00:43:13,320 --> 00:43:18,210
machine regressor you just drop in a

00:43:16,290 --> 00:43:20,790
different model and look the the rest of

00:43:18,210 --> 00:43:23,520
the code stays exactly the same it's

00:43:20,790 --> 00:43:26,310
just the the Python class we use that

00:43:23,520 --> 00:43:27,510
defines which model you're gonna use and

00:43:26,310 --> 00:43:30,120
you can see that the support vector

00:43:27,510 --> 00:43:32,640
machine has different characteristics it

00:43:30,120 --> 00:43:34,200
doesn't it doesn't conform as closely to

00:43:32,640 --> 00:43:36,770
the individual data points it does a

00:43:34,200 --> 00:43:39,540
little more more kind of smoothing and

00:43:36,770 --> 00:43:41,130
as you dig in and learn more about these

00:43:39,540 --> 00:43:43,890
machine learning models you can get an

00:43:41,130 --> 00:43:45,510
intuition for for which one is better

00:43:43,890 --> 00:43:48,090
depending on what you want to do with

00:43:45,510 --> 00:43:50,520
your data and your model so psychic

00:43:48,090 --> 00:43:52,860
learns are a really cool package for

00:43:50,520 --> 00:43:54,720
that and this is something that ii learn

00:43:52,860 --> 00:43:57,270
was sort of the way that I got into the

00:43:54,720 --> 00:43:59,430
Python open source world as I started

00:43:57,270 --> 00:44:02,640
contributing to this package and that

00:43:59,430 --> 00:44:06,900
ten years ago 2009 and it's been a been

00:44:02,640 --> 00:44:08,940
a cool thing to be involved with so we

00:44:06,900 --> 00:44:10,440
have all this numerical analysis CyHi

00:44:08,940 --> 00:44:12,270
scikit-learn we're starting to build up

00:44:10,440 --> 00:44:14,430
a really interesting tool set what if

00:44:12,270 --> 00:44:18,140
you want to start moving to larger data

00:44:14,430 --> 00:44:21,300
sets there's this great tool called desk

00:44:18,140 --> 00:44:23,130
that that a number of people I've

00:44:21,300 --> 00:44:24,930
already talked to a few people today who

00:44:23,130 --> 00:44:28,170
are using this in their their own work

00:44:24,930 --> 00:44:33,060
what desk does is it basically provides

00:44:28,170 --> 00:44:36,810
a Python API around massively parallel

00:44:33,060 --> 00:44:40,020
execution of code and the cool thing

00:44:36,810 --> 00:44:42,030
about this out this API is that it lets

00:44:40,020 --> 00:44:44,550
you do things without without having to

00:44:42,030 --> 00:44:46,890
worry about the details yourself so a

00:44:44,550 --> 00:44:49,710
typical data and a manipulation with

00:44:46,890 --> 00:44:51,660
numpy we have an array we multiply it by

00:44:49,710 --> 00:44:53,730
four we take the minimum and we print

00:44:51,660 --> 00:44:57,510
the result something like that the same

00:44:53,730 --> 00:45:00,840
thing in desk is basically the same code

00:44:57,510 --> 00:45:02,760
except we import desk array and we

00:45:00,840 --> 00:45:04,290
create our array we multiply it by four

00:45:02,760 --> 00:45:05,910
we take the minimum and we print the

00:45:04,290 --> 00:45:08,700
result and in this case though the

00:45:05,910 --> 00:45:12,030
result is not a number this this result

00:45:08,700 --> 00:45:15,120
is an abstract representation of the

00:45:12,030 --> 00:45:16,470
calculations that you just did and there

00:45:15,120 --> 00:45:18,780
are ways to visualize what this

00:45:16,470 --> 00:45:21,240
representation is and basically you're

00:45:18,780 --> 00:45:23,050
taking your your array you're splitting

00:45:21,240 --> 00:45:24,520
it into five chunks

00:45:23,050 --> 00:45:26,410
you're creating a raise for the both of

00:45:24,520 --> 00:45:29,680
those you're multiplying each chunk by

00:45:26,410 --> 00:45:32,320
four then you're taking the minimum of

00:45:29,680 --> 00:45:34,120
that chunk and then you're combining all

00:45:32,320 --> 00:45:35,920
these chunks together taking the minimum

00:45:34,120 --> 00:45:38,560
of each and you get the minimum value

00:45:35,920 --> 00:45:40,750
right so that way instead of doing all

00:45:38,560 --> 00:45:44,170
these multiplications and minimums on

00:45:40,750 --> 00:45:47,170
one process in one core you're splitting

00:45:44,170 --> 00:45:49,390
it among multiple processes so this is a

00:45:47,170 --> 00:45:51,250
little silly for multiplying an array by

00:45:49,390 --> 00:45:53,260
four and taking the minimum but you can

00:45:51,250 --> 00:45:56,350
imagine how this generalizes to more

00:45:53,260 --> 00:45:58,270
more sophisticated operations and what

00:45:56,350 --> 00:46:01,150
it means is that you can you can call

00:45:58,270 --> 00:46:03,580
compute on this task graph and get the

00:46:01,150 --> 00:46:05,530
result and the power of this approach is

00:46:03,580 --> 00:46:07,810
of this task graph this abstract

00:46:05,530 --> 00:46:12,340
representation of what you're trying to

00:46:07,810 --> 00:46:16,840
do with your data can be sent out to an

00:46:12,340 --> 00:46:19,690
AWS cluster it can be sent to a GPU on

00:46:16,840 --> 00:46:21,880
your machine it can be sent to a condor

00:46:19,690 --> 00:46:23,350
cluster of all the desktop machines in

00:46:21,880 --> 00:46:25,690
your academic department if you have

00:46:23,350 --> 00:46:28,720
something like that it's it's a really

00:46:25,690 --> 00:46:31,900
flexible way to to describe the problems

00:46:28,720 --> 00:46:34,750
you're doing and to evaluate them so

00:46:31,900 --> 00:46:36,220
with another sort of code optimization

00:46:34,750 --> 00:46:38,110
thing that that you might have come

00:46:36,220 --> 00:46:40,390
across and the Python world is numba

00:46:38,110 --> 00:46:42,790
this is a really cool package and

00:46:40,390 --> 00:46:45,880
basically what it is does is it tries to

00:46:42,790 --> 00:46:49,600
take Python code and compile it down

00:46:45,880 --> 00:46:52,630
into fast LLVM code without much extra

00:46:49,600 --> 00:46:54,340
work so a typical example you know

00:46:52,630 --> 00:46:56,470
everyone likes their Fibonacci numbers

00:46:54,340 --> 00:46:59,590
so here's here's a Fibonacci number

00:46:56,470 --> 00:47:02,080
calculator in Python and to compute the

00:46:59,590 --> 00:47:05,650
10,000th Fibonacci number using this

00:47:02,080 --> 00:47:07,930
sort of loop based approach is is 2

00:47:05,650 --> 00:47:09,970
milliseconds per loop so you might think

00:47:07,930 --> 00:47:11,860
that's that's sort of fast but it's you

00:47:09,970 --> 00:47:14,590
know it's it's sort of slow if you if

00:47:11,860 --> 00:47:16,390
you do the equivalent in a compiled

00:47:14,590 --> 00:47:18,640
language like Fortran or C it's gonna be

00:47:16,390 --> 00:47:21,460
a lot faster what number lets you do is

00:47:18,640 --> 00:47:23,050
add a decorator to this function look I

00:47:21,460 --> 00:47:26,560
haven't changed anything except for

00:47:23,050 --> 00:47:29,710
adding this decorator and you get a 500x

00:47:26,560 --> 00:47:32,770
speed-up in these sort of loop based

00:47:29,710 --> 00:47:34,510
approaches to to analyzing or - to

00:47:32,770 --> 00:47:36,730
working with data

00:47:34,510 --> 00:47:39,370
what this is actually doing is it's

00:47:36,730 --> 00:47:42,670
taking the byte code in this defined

00:47:39,370 --> 00:47:44,740
function compiling it to LLVM which is

00:47:42,670 --> 00:47:47,920
sort of like a like a compiled fast

00:47:44,740 --> 00:47:49,990
language compile it to LVL vm compiling

00:47:47,920 --> 00:47:52,390
that and then executing the compiled

00:47:49,990 --> 00:47:55,630
code rather than the python code and

00:47:52,390 --> 00:47:56,590
dropping in the result for you so

00:47:55,630 --> 00:47:59,260
there's been some really interesting

00:47:56,590 --> 00:48:01,510
things done with numba to kind of speed

00:47:59,260 --> 00:48:04,870
up more sophisticated analysis and

00:48:01,510 --> 00:48:07,480
particularly in image manipulation and

00:48:04,870 --> 00:48:09,100
things like this so so check that out if

00:48:07,480 --> 00:48:17,200
you're interested in like how to make

00:48:09,100 --> 00:48:21,730
your Python code faster so another one I

00:48:17,200 --> 00:48:24,610
should mention real quickly as is scythe

00:48:21,730 --> 00:48:29,590
on so scythe on is sort of a way to

00:48:24,610 --> 00:48:31,750
marry C and Python and it's similarly if

00:48:29,590 --> 00:48:34,330
you take this Fibonacci number generator

00:48:31,750 --> 00:48:37,900
what psyphon does is it allows you to

00:48:34,330 --> 00:48:40,930
compile your python code into c rather

00:48:37,900 --> 00:48:43,300
than to LLVM and for example if you if

00:48:40,930 --> 00:48:45,340
you just run this basic Python code

00:48:43,300 --> 00:48:47,800
through the scythe on interpreter you

00:48:45,340 --> 00:48:50,260
get a 10% speed-up you know it's not not

00:48:47,800 --> 00:48:52,600
that much but where you can really start

00:48:50,260 --> 00:48:56,050
taking advantage of things in scythe on

00:48:52,600 --> 00:48:59,470
as if you kind of combine the idioms of

00:48:56,050 --> 00:49:02,140
Python and C into one script and you

00:48:59,470 --> 00:49:04,450
start defining typed variables inside

00:49:02,140 --> 00:49:07,900
your your scythe on code then you get

00:49:04,450 --> 00:49:10,240
the same 500 X speed up as as numba just

00:49:07,900 --> 00:49:12,730
by kind of like compiling into optimized

00:49:10,240 --> 00:49:14,650
code and I often say that scythe on is

00:49:12,730 --> 00:49:16,150
my favorite language to program in

00:49:14,650 --> 00:49:17,860
because it's like it's got all the

00:49:16,150 --> 00:49:21,220
beauty of Python and all the express

00:49:17,860 --> 00:49:22,690
ability of C and so I really enjoy

00:49:21,220 --> 00:49:24,820
writing code in scythe on because it

00:49:22,690 --> 00:49:27,370
lets you do some some interesting things

00:49:24,820 --> 00:49:30,070
and scythe on is really a powerhouse

00:49:27,370 --> 00:49:32,500
behind all the tools that you're using

00:49:30,070 --> 00:49:34,330
in the Python data science world your

00:49:32,500 --> 00:49:37,690
numpy side pipe and O's scikit-learn

00:49:34,330 --> 00:49:40,720
Astro PI some pie pan and a lot more are

00:49:37,690 --> 00:49:43,420
using pipe scythe on at their core to

00:49:40,720 --> 00:49:46,390
make the tools you use fast

00:49:43,420 --> 00:49:48,220
so there's so much more out there that I

00:49:46,390 --> 00:49:51,640
haven't talked about it I just wanted to

00:49:48,220 --> 00:49:54,099
basically give you a brief survey of the

00:49:51,640 --> 00:49:56,140
core tools that if you're jumping into

00:49:54,099 --> 00:49:58,420
Python data science that you you should

00:49:56,140 --> 00:49:59,950
get familiar with if you look at all the

00:49:58,420 --> 00:50:02,319
tools that have been built on top of

00:49:59,950 --> 00:50:04,059
these there's there's a ton from all

00:50:02,319 --> 00:50:06,640
different domains and all different

00:50:04,059 --> 00:50:10,299
fields whether you're working in in

00:50:06,640 --> 00:50:11,650
neuro imaging or astronomy or biology or

00:50:10,299 --> 00:50:13,900
anywhere in between

00:50:11,650 --> 00:50:16,750
people are out there writing Python code

00:50:13,900 --> 00:50:20,740
and making Python tools to do the kind

00:50:16,750 --> 00:50:23,589
of workflows that they have and so as we

00:50:20,740 --> 00:50:26,740
as I as I finished this I want to remind

00:50:23,589 --> 00:50:28,839
you that you should not think of Python

00:50:26,740 --> 00:50:30,880
as a data science language because

00:50:28,839 --> 00:50:33,369
that's not what it was created to be it

00:50:30,880 --> 00:50:35,920
was created to be a language that's easy

00:50:33,369 --> 00:50:38,230
to use a language that's expressible and

00:50:35,920 --> 00:50:42,010
a language that's beautiful and fun to

00:50:38,230 --> 00:50:44,349
code in and this this is probably its

00:50:42,010 --> 00:50:47,079
greatest strength right because python

00:50:44,349 --> 00:50:50,200
is such a great language to use people

00:50:47,079 --> 00:50:53,049
invest time into making it work for

00:50:50,200 --> 00:50:55,269
their own use cases you know Python is a

00:50:53,049 --> 00:50:58,089
successful because people just like you

00:50:55,269 --> 00:51:01,200
used it to solve their problems and

00:50:58,089 --> 00:51:03,490
shared their solutions with the world

00:51:01,200 --> 00:51:05,680
and this is this is kind of what I want

00:51:03,490 --> 00:51:07,210
to leave you with you know the 90s I

00:51:05,680 --> 00:51:10,509
talked about Python being the scripting

00:51:07,210 --> 00:51:12,789
era to thousands of the SyFy era 2010s

00:51:10,509 --> 00:51:16,480
is the PI data era we're coming into

00:51:12,789 --> 00:51:19,000
another decade and what where python

00:51:16,480 --> 00:51:21,430
goes from here is up to the people who

00:51:19,000 --> 00:51:23,650
use it up to the people who build these

00:51:21,430 --> 00:51:26,559
tools that other people are using so you

00:51:23,650 --> 00:51:29,769
know it's up to you any any of you can

00:51:26,559 --> 00:51:32,619
kind of decide and influence where

00:51:29,769 --> 00:51:35,200
Python goes as we move forward in this

00:51:32,619 --> 00:51:38,859
next decade and I for one I'm interested

00:51:35,200 --> 00:51:41,559
to see where what comes out and where it

00:51:38,859 --> 00:51:44,500
all goes so thanks very much here's my

00:51:41,559 --> 00:51:45,060
my information and I'd love to take some

00:51:44,500 --> 00:51:48,270
questions

00:51:45,060 --> 00:51:48,270
[Applause]

00:51:48,390 --> 00:51:53,830
and so you talked about the next

00:51:51,190 --> 00:51:57,360
generation I'd like from so what do you

00:51:53,830 --> 00:51:59,440
think of air Python will be is it HPC

00:51:57,360 --> 00:52:02,380
high-performance computing or making

00:51:59,440 --> 00:52:04,270
file a Python more faster yeah I don't

00:52:02,380 --> 00:52:06,810
know it's hard hard to say where where

00:52:04,270 --> 00:52:09,130
Python will be in ten years I mean I

00:52:06,810 --> 00:52:11,230
don't know I don't know if anyone would

00:52:09,130 --> 00:52:13,870
have predicted ten years ago where we

00:52:11,230 --> 00:52:17,170
are now with iPhone being the kind of

00:52:13,870 --> 00:52:19,090
the core algorithm core tool for deep

00:52:17,170 --> 00:52:22,750
learning and things like that what I

00:52:19,090 --> 00:52:25,930
really hope I really hope is that Python

00:52:22,750 --> 00:52:28,480
can become more of a tool for the web

00:52:25,930 --> 00:52:31,900
you know javascript is taking over

00:52:28,480 --> 00:52:34,420
because it's because everybody everybody

00:52:31,900 --> 00:52:36,370
has a JavaScript interpreter on their

00:52:34,420 --> 00:52:40,300
phone or in their computer or on their

00:52:36,370 --> 00:52:42,130
watch even and and I'd love for Python

00:52:40,300 --> 00:52:46,660
to kind of make headway into the world

00:52:42,130 --> 00:52:48,130
of the web and the browser so I don't

00:52:46,660 --> 00:52:52,810
know if I'm predicting that will happen

00:52:48,130 --> 00:52:54,360
but I hope that happens still we see by

00:52:52,810 --> 00:52:58,780
10 in the field of web development

00:52:54,360 --> 00:53:01,030
generally but we have Fortran from last

00:52:58,780 --> 00:53:04,270
twenty third twenty years but we don't

00:53:01,030 --> 00:53:05,390
see Python there in HPC

00:53:04,270 --> 00:53:07,700
[Music]

00:53:05,390 --> 00:53:12,160
okay learner switching erm catch that

00:53:07,700 --> 00:53:12,160
I'm sorry oh nice over here

00:53:13,509 --> 00:53:20,150
hello thanks a lot for your talk Jake it

00:53:17,960 --> 00:53:23,359
was really nice knowing the road map and

00:53:20,150 --> 00:53:26,119
how can we proceed so I am intrigued by

00:53:23,359 --> 00:53:27,619
the tool that particularly that you work

00:53:26,119 --> 00:53:29,569
on is that all day rather you are

00:53:27,619 --> 00:53:32,059
talking about and from what I understood

00:53:29,569 --> 00:53:34,609
it's a kind of a visualization tool so

00:53:32,059 --> 00:53:36,650
my question to you is well while you are

00:53:34,609 --> 00:53:38,569
working on it and designing on it I'll

00:53:36,650 --> 00:53:40,519
be also looking it from the Universal

00:53:38,569 --> 00:53:44,470
Design Festival for example me being a

00:53:40,519 --> 00:53:48,109
visually impaired person I cannot access

00:53:44,470 --> 00:53:50,450
these graphs globally just looking at

00:53:48,109 --> 00:53:52,269
the screen so are we also trying to

00:53:50,450 --> 00:53:54,980
build there's no capacity in these

00:53:52,269 --> 00:53:57,049
application and thing we have some

00:53:54,980 --> 00:53:59,180
insight into this as well at all in our

00:53:57,049 --> 00:54:02,480
talk at around 11:00 but I would I would

00:53:59,180 --> 00:54:05,359
like to know your new views on that yeah

00:54:02,480 --> 00:54:09,369
yeah thank you for that question that's

00:54:05,359 --> 00:54:11,900
a that's a really good point that we

00:54:09,369 --> 00:54:14,839
need to figure out how to how to build

00:54:11,900 --> 00:54:19,009
sort of broad accessibility into our

00:54:14,839 --> 00:54:20,480
into our tools and into our analysis one

00:54:19,009 --> 00:54:23,029
thing I will say with the with the

00:54:20,480 --> 00:54:25,700
Altair project that I'm working on we've

00:54:23,029 --> 00:54:28,430
we've thought a bit about that and one

00:54:25,700 --> 00:54:31,970
of the strengths there is that any plot

00:54:28,430 --> 00:54:35,749
generated with the Altair project also

00:54:31,970 --> 00:54:38,509
has kind of a full description and of

00:54:35,749 --> 00:54:41,960
the plot and all the data embedded with

00:54:38,509 --> 00:54:45,039
it so there's some work on the on the

00:54:41,960 --> 00:54:48,739
Vega light library which underlies it to

00:54:45,039 --> 00:54:51,619
add more accessibility tools on to the

00:54:48,739 --> 00:54:53,599
Vega light chart display and and I'm

00:54:51,619 --> 00:54:56,210
excited about that because it means that

00:54:53,599 --> 00:54:58,249
you know the the visualization is no

00:54:56,210 --> 00:55:01,339
longer just a grid of pixels on the

00:54:58,249 --> 00:55:04,270
screen but it's a the data set and a

00:55:01,339 --> 00:55:06,579
full description of the data set in

00:55:04,270 --> 00:55:09,069
a girl in a grammar of visualization

00:55:06,579 --> 00:55:12,250
that that offers a lot of opportunities

00:55:09,069 --> 00:55:14,380
to make these more more accessible so

00:55:12,250 --> 00:55:16,770
it's a good reminder though thanks for

00:55:14,380 --> 00:55:16,770
the question

00:55:19,070 --> 00:55:30,290
heisig it was a wonderful talk I I

00:55:25,510 --> 00:55:32,690
wanted to ask about number so why should

00:55:30,290 --> 00:55:34,460
we why can't we just always use number

00:55:32,690 --> 00:55:36,920
what are the kind of best practices

00:55:34,460 --> 00:55:40,610
practices to use number and in what

00:55:36,920 --> 00:55:44,540
situations number won't be able to cause

00:55:40,610 --> 00:55:47,000
a major speed up yeah it's a four number

00:55:44,540 --> 00:55:48,680
and scythe on both the times that you

00:55:47,000 --> 00:55:51,350
want to use them is when you find

00:55:48,680 --> 00:55:55,730
yourself writing big loops and Python

00:55:51,350 --> 00:55:57,320
and looping over data if you can if

00:55:55,730 --> 00:56:00,310
there are things that you can't express

00:55:57,320 --> 00:56:03,170
in terms of numpy vectorization

00:56:00,310 --> 00:56:04,310
primitives then the number and size on

00:56:03,170 --> 00:56:07,820
are the way to go

00:56:04,310 --> 00:56:10,430
so essentially like for loops and python

00:56:07,820 --> 00:56:16,430
or slow and you need to a way to speed

00:56:10,430 --> 00:56:20,440
them up yeah so I think this is going to

00:56:16,430 --> 00:56:20,440
be last question so last taker

00:56:22,200 --> 00:56:30,059
okay yeah so like you said that Python

00:56:26,940 --> 00:56:31,260
kept evolving with data science I'd

00:56:30,059 --> 00:56:32,880
actually like to ask a question about

00:56:31,260 --> 00:56:35,970
quantum computation which I am working

00:56:32,880 --> 00:56:37,349
on currently and how Cirque and quiz kit

00:56:35,970 --> 00:56:39,210
and everything's is coming on to that

00:56:37,349 --> 00:56:40,799
how do you think pythons gonna evolve on

00:56:39,210 --> 00:56:42,990
those kinds of future technologies

00:56:40,799 --> 00:56:45,569
yeah quantum computation that's a good

00:56:42,990 --> 00:56:48,000
question I look looking at the past and

00:56:45,569 --> 00:56:50,640
how we've gotten here I I imagine that

00:56:48,000 --> 00:56:53,549
Python will start you know people will

00:56:50,640 --> 00:56:55,349
have kind of ways to call their quantum

00:56:53,549 --> 00:56:57,839
routines or more sophisticated routines

00:56:55,349 --> 00:56:59,220
and Python will start as glue to call

00:56:57,839 --> 00:57:00,510
vollis you know rather than writing a

00:56:59,220 --> 00:57:02,970
bash script you'll write a Python script

00:57:00,510 --> 00:57:04,559
and then maybe after a while someone

00:57:02,970 --> 00:57:07,200
will come up with a higher level API

00:57:04,559 --> 00:57:09,329
that can wrap that and you know maybe

00:57:07,200 --> 00:57:11,460
eventually you'll be writing your your

00:57:09,329 --> 00:57:15,569
quantum computation scripts in Python

00:57:11,460 --> 00:57:18,000
with with built on quantify or whatever

00:57:15,569 --> 00:57:21,390
whatever package you end up writing for

00:57:18,000 --> 00:57:23,400
all of us to use so thanks very much I'm

00:57:21,390 --> 00:57:26,309
gonna be around for today and tomorrow

00:57:23,400 --> 00:57:28,380
and I'm happy to chat and answer any

00:57:26,309 --> 00:57:31,009
other questions you have I appreciate

00:57:28,380 --> 00:57:31,009

YouTube URL: https://www.youtube.com/watch?v=VIal-4zz9HI


