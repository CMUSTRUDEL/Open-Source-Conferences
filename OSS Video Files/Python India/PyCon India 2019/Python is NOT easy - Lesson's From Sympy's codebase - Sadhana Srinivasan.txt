Title: Python is NOT easy - Lesson's From Sympy's codebase - Sadhana Srinivasan
Publication date: 2019-11-16
Playlist: PyCon India 2019
Description: 
	This talk was presented at PyCon India 2019, on Oct 12th - 13th, at the Chennai Trade Centre.
Website: https://in.pycon.org/2019
Captions: 
	00:00:04,810 --> 00:00:12,170
so just let me know so yeah I'm going to

00:00:10,190 --> 00:00:15,469
talk about why I think Python is not

00:00:12,170 --> 00:00:17,420
easy and why I hope and I hope this talk

00:00:15,469 --> 00:00:19,430
will help you think that it is easy when

00:00:17,420 --> 00:00:22,220
you actually do open source the same of

00:00:19,430 --> 00:00:25,220
this talk so what do I do

00:00:22,220 --> 00:00:27,430
I'm sadness universe and I work in AI

00:00:25,220 --> 00:00:30,590
nml research at a company called

00:00:27,430 --> 00:00:34,370
sama-sama works in optimizing clinical

00:00:30,590 --> 00:00:36,920
trials using AI nml currently I'm trying

00:00:34,370 --> 00:00:39,140
to figure out if neural networks can be

00:00:36,920 --> 00:00:41,780
forced to follow hard logic they're

00:00:39,140 --> 00:00:45,880
famously something that you cannot

00:00:41,780 --> 00:00:48,770
control but we're trying to work on that

00:00:45,880 --> 00:00:50,690
the south is based of simple it's based

00:00:48,770 --> 00:00:53,960
of some work that I did for the company

00:00:50,690 --> 00:00:55,760
using simple the idea was to be able to

00:00:53,960 --> 00:01:00,290
run neural networks on a quantum

00:00:55,760 --> 00:01:01,970
computer in a nice and intuitive way we

00:01:00,290 --> 00:01:03,829
had to use some PI for that but it was

00:01:01,970 --> 00:01:07,460
too slow and we had to optimize it so

00:01:03,829 --> 00:01:11,450
this is things that I encountered when I

00:01:07,460 --> 00:01:13,700
had to work with it so why do we say

00:01:11,450 --> 00:01:17,000
that Python is a really easy language

00:01:13,700 --> 00:01:20,690
it's it's very easy to learn you spend

00:01:17,000 --> 00:01:23,390
25 hours 14 hours and you're good to go

00:01:20,690 --> 00:01:26,360
you can start building web servers you

00:01:23,390 --> 00:01:28,820
can start building apps and it's very

00:01:26,360 --> 00:01:30,560
intuitive to use and once you have some

00:01:28,820 --> 00:01:32,630
experience you can also predict how

00:01:30,560 --> 00:01:33,830
other libraries with all of their

00:01:32,630 --> 00:01:35,570
awesome functions are going to behave

00:01:33,830 --> 00:01:38,510
you you know it's going to be as simple

00:01:35,570 --> 00:01:40,640
as import something instantiate an

00:01:38,510 --> 00:01:42,530
object give the object some data taking

00:01:40,640 --> 00:01:46,010
ski get our scikit-learn as an example

00:01:42,530 --> 00:01:48,530
and then fit it so you can expect that

00:01:46,010 --> 00:01:52,520
sort of simplicity and that's why python

00:01:48,530 --> 00:01:57,470
is so easy but I say that Python is not

00:01:52,520 --> 00:02:00,619
easy like we saw in the keynote today

00:01:57,470 --> 00:02:02,659
Python is was not meant to do what it is

00:02:00,619 --> 00:02:05,900
doing right now and it's grown in

00:02:02,659 --> 00:02:08,299
complexity over time and all of that

00:02:05,900 --> 00:02:10,250
complexity is still happening behind the

00:02:08,299 --> 00:02:13,610
scenes where the end user does not

00:02:10,250 --> 00:02:15,440
really see it but as an open source

00:02:13,610 --> 00:02:17,540
first time open source contributor

00:02:15,440 --> 00:02:18,470
you're going to have to deal with some

00:02:17,540 --> 00:02:20,870
of that complex

00:02:18,470 --> 00:02:23,450
and this talk is centered around

00:02:20,870 --> 00:02:26,990
concepts that you will encounter when

00:02:23,450 --> 00:02:28,760
you start doing this so in this talk I'm

00:02:26,990 --> 00:02:30,710
going to touch upon inheritance in

00:02:28,760 --> 00:02:32,630
Python I'm going to talk about mixing

00:02:30,710 --> 00:02:34,880
classes which is a good to know and it

00:02:32,630 --> 00:02:37,180
is not a feature of Python then you're

00:02:34,880 --> 00:02:39,590
going to talk about decorators slots

00:02:37,180 --> 00:02:43,030
meta classes and then I'm going to talk

00:02:39,590 --> 00:02:46,220
about just a bit about what simp is and

00:02:43,030 --> 00:02:51,110
how all of this combines in the sample

00:02:46,220 --> 00:02:53,390
code base so we all know what

00:02:51,110 --> 00:02:56,600
inheritance is let's say you have three

00:02:53,390 --> 00:02:58,940
classes you have a class person which

00:02:56,600 --> 00:03:01,460
could be inherited by a class royalty

00:02:58,940 --> 00:03:04,880
and then you can have the Queen of

00:03:01,460 --> 00:03:07,490
England who inherits from the class

00:03:04,880 --> 00:03:10,160
royalty so this is nice linear

00:03:07,490 --> 00:03:11,990
inheritance we know this but Python

00:03:10,160 --> 00:03:14,990
allows multiple inheritance and most

00:03:11,990 --> 00:03:17,110
other languages don't allow this and the

00:03:14,990 --> 00:03:20,540
reason they don't allow this is because

00:03:17,110 --> 00:03:23,000
if you look at the class II that I have

00:03:20,540 --> 00:03:24,890
in this diagram which is an example

00:03:23,000 --> 00:03:28,370
inheritance flow that you could see in

00:03:24,890 --> 00:03:32,510
Python you have Class E which is

00:03:28,370 --> 00:03:34,880
inheriting from D and C and it can also

00:03:32,510 --> 00:03:38,060
inherit and DNC in turn have inherited

00:03:34,880 --> 00:03:41,150
from B and also a so any property that

00:03:38,060 --> 00:03:43,430
it has both B and C are going to have

00:03:41,150 --> 00:03:46,690
and when it comes to E you don't you're

00:03:43,430 --> 00:03:49,550
not really sure which property to keep

00:03:46,690 --> 00:03:52,880
but this obviously works in Python this

00:03:49,550 --> 00:03:55,790
is a toy example so I have parent class

00:03:52,880 --> 00:03:58,790
1 and firing class 2 both have the exact

00:03:55,790 --> 00:04:01,519
same attribute parent name and I am

00:03:58,790 --> 00:04:04,130
instantiating as child sauce which

00:04:01,519 --> 00:04:06,470
inherits from final class 1 and 2 now

00:04:04,130 --> 00:04:10,720
when I check this particular attribute

00:04:06,470 --> 00:04:13,670
it prints out Eve now this is due to

00:04:10,720 --> 00:04:16,850
pythons dynamic ordering which has a

00:04:13,670 --> 00:04:18,709
system for how the attributes of

00:04:16,850 --> 00:04:22,190
different classes are overridden when we

00:04:18,709 --> 00:04:24,140
do inheritance so whenever you do

00:04:22,190 --> 00:04:27,470
multiple inheritance if there is a class

00:04:24,140 --> 00:04:30,050
the leftmost class or the first class

00:04:27,470 --> 00:04:32,060
that you gave into that inheritance is

00:04:30,050 --> 00:04:33,740
the one whose properties are going to

00:04:32,060 --> 00:04:38,250
get

00:04:33,740 --> 00:04:40,800
so that's all about inheritance and I'm

00:04:38,250 --> 00:04:43,440
going to talk about mixing classes this

00:04:40,800 --> 00:04:45,870
is not a feature of Python you will not

00:04:43,440 --> 00:04:48,000
find this documented anywhere as such

00:04:45,870 --> 00:04:50,030
it's just something that you kind of

00:04:48,000 --> 00:04:53,220
encountered in different code bases

00:04:50,030 --> 00:04:55,680
simpie is one's angles and other what

00:04:53,220 --> 00:04:58,710
they essentially mean is it's it's a

00:04:55,680 --> 00:05:02,280
nice way of encapsulating behaviors so

00:04:58,710 --> 00:05:05,240
let's say you have for example taking

00:05:02,280 --> 00:05:08,880
some PI as an example let's say you have

00:05:05,240 --> 00:05:12,570
different expressions polynomials you

00:05:08,880 --> 00:05:16,080
have integrals all of these expressions

00:05:12,570 --> 00:05:20,100
can be evaluated so the behavior that

00:05:16,080 --> 00:05:22,320
something can be evaluated can be put in

00:05:20,100 --> 00:05:26,460
a separate class and whichever other

00:05:22,320 --> 00:05:29,910
class needs that behavior can just take

00:05:26,460 --> 00:05:32,250
this extra class and mix it in so that

00:05:29,910 --> 00:05:34,650
behavior gets mixed in the reason this

00:05:32,250 --> 00:05:35,610
is done is that it makes the code base

00:05:34,650 --> 00:05:37,800
is very readable

00:05:35,610 --> 00:05:39,570
once you see a mixin class you know it's

00:05:37,800 --> 00:05:42,450
a repeated behavior that occurs in the

00:05:39,570 --> 00:05:44,550
code base and when you read really huge

00:05:42,450 --> 00:05:51,300
code bases this can be very helpful if

00:05:44,550 --> 00:05:58,410
it exists in the code base so now I am

00:05:51,300 --> 00:06:01,080
going to talk about decorators so before

00:05:58,410 --> 00:06:03,240
that everything in python is an object

00:06:01,080 --> 00:06:05,880
every single thing in python is an

00:06:03,240 --> 00:06:08,520
object so functions are also objects so

00:06:05,880 --> 00:06:11,340
functions are an object of type function

00:06:08,520 --> 00:06:12,990
and they have no other attributes but

00:06:11,340 --> 00:06:14,460
since functions are objects you could

00:06:12,990 --> 00:06:16,260
also do something like this which is

00:06:14,460 --> 00:06:18,510
very pointless I don't think you should

00:06:16,260 --> 00:06:21,060
do it but you can do this just add an

00:06:18,510 --> 00:06:25,169
extra attribute to a function you can do

00:06:21,060 --> 00:06:27,300
it but since functions are objects you

00:06:25,169 --> 00:06:30,389
can pass functions as input to other

00:06:27,300 --> 00:06:34,260
functions and this is the basis of what

00:06:30,389 --> 00:06:36,960
decorators are so here you have the

00:06:34,260 --> 00:06:41,010
decorator function which takes another

00:06:36,960 --> 00:06:43,380
function as its input and it this one

00:06:41,010 --> 00:06:45,030
finds the function so I check the time

00:06:43,380 --> 00:06:45,729
at the beginning and I check the time at

00:06:45,030 --> 00:06:49,419
the end prints

00:06:45,729 --> 00:06:51,430
difference so this this way of using

00:06:49,419 --> 00:06:53,949
functions as decorators is syntactic

00:06:51,430 --> 00:06:56,830
sugar for saying decorate a function of

00:06:53,949 --> 00:06:59,559
this long process that I've defined so

00:06:56,830 --> 00:07:04,059
it will run this long process and print

00:06:59,559 --> 00:07:05,830
out my the amount of time it took so why

00:07:04,059 --> 00:07:07,779
would we use decorators it's it's

00:07:05,830 --> 00:07:09,729
repeatable you have this function that

00:07:07,779 --> 00:07:12,580
will always time something so you can

00:07:09,729 --> 00:07:14,620
just whichever function you want a time

00:07:12,580 --> 00:07:18,370
you can just decorate it with this

00:07:14,620 --> 00:07:22,300
function and will work so you can also

00:07:18,370 --> 00:07:24,129
use classes as decorators except when

00:07:22,300 --> 00:07:26,229
you're using a class as a decorator

00:07:24,129 --> 00:07:29,259
you'd have to modify the call function

00:07:26,229 --> 00:07:31,240
and let's say you have a class error

00:07:29,259 --> 00:07:32,740
check so you have to initialize it

00:07:31,240 --> 00:07:35,620
saying that yes you're going to get a

00:07:32,740 --> 00:07:38,080
function as an input and you're going to

00:07:35,620 --> 00:07:39,430
tell whatever else you want to happen

00:07:38,080 --> 00:07:42,249
you're going to have to do it and call

00:07:39,430 --> 00:07:43,659
and Here I am saying okay I want to

00:07:42,249 --> 00:07:48,610
check the parameters and I want to make

00:07:43,659 --> 00:07:52,270
sure all of them are of the type are not

00:07:48,610 --> 00:07:55,180
string basically so I have another

00:07:52,270 --> 00:07:56,770
function which is add numbers and I

00:07:55,180 --> 00:07:59,349
decorate that with error checks so the

00:07:56,770 --> 00:08:03,009
first one will run if I say add one two

00:07:59,349 --> 00:08:05,770
three it'll run as expected but if I try

00:08:03,009 --> 00:08:08,860
one string two and three that's gonna

00:08:05,770 --> 00:08:11,949
throw up an error and again decorators

00:08:08,860 --> 00:08:15,399
help whenever you know you you want to

00:08:11,949 --> 00:08:17,110
make things very repeatable so you can

00:08:15,399 --> 00:08:20,020
also get create classes I don't have an

00:08:17,110 --> 00:08:24,459
example for that here but how many of

00:08:20,020 --> 00:08:26,469
you have used by test all of us okay a

00:08:24,459 --> 00:08:31,389
lot of us so you could actually

00:08:26,469 --> 00:08:34,089
reimplemented using decorators you could

00:08:31,389 --> 00:08:37,810
say okay I have this particular class I

00:08:34,089 --> 00:08:39,909
want to test it and every you can

00:08:37,810 --> 00:08:42,159
encapsulate all of the tests in

00:08:39,909 --> 00:08:44,680
different classes decorate each of those

00:08:42,159 --> 00:08:47,319
classes so that whenever you run tests

00:08:44,680 --> 00:08:49,510
you can just run each of those functions

00:08:47,319 --> 00:08:52,899
so decorators allow you to do this sort

00:08:49,510 --> 00:08:54,550
of thing you could also do things like

00:08:52,899 --> 00:08:57,779
check which functions are used more

00:08:54,550 --> 00:08:59,620
often whenever a function is called you

00:08:57,779 --> 00:09:01,840
modify a global variable

00:08:59,620 --> 00:09:04,240
you modify something which gives you a

00:09:01,840 --> 00:09:06,580
count of how many times this function is

00:09:04,240 --> 00:09:08,170
used so you can use decorators in many

00:09:06,580 --> 00:09:10,660
different ways you can use them in very

00:09:08,170 --> 00:09:17,610
creative ways and these are some things

00:09:10,660 --> 00:09:21,550
that you will always see and each yeah

00:09:17,610 --> 00:09:23,740
so I'm going quite fast so in case

00:09:21,550 --> 00:09:25,990
someone wants to stop me please feel

00:09:23,740 --> 00:09:28,420
free so now I'm going to talk about

00:09:25,990 --> 00:09:31,780
slots this is where classes don't behave

00:09:28,420 --> 00:09:34,120
like classes anymore so then you have

00:09:31,780 --> 00:09:36,820
sorry then you have a normal class in

00:09:34,120 --> 00:09:39,670
Python this is a normal class which is a

00:09:36,820 --> 00:09:42,520
person you have a name you have an age

00:09:39,670 --> 00:09:45,340
and I'm saying that by default everybody

00:09:42,520 --> 00:09:48,730
is a coder and I have a normal in it I

00:09:45,340 --> 00:09:51,130
have an object I try to add an attribute

00:09:48,730 --> 00:09:52,690
to that object all of this works this is

00:09:51,130 --> 00:09:56,020
behavior that we are all very familiar

00:09:52,690 --> 00:09:58,030
with for classes here I'm just showing

00:09:56,020 --> 00:10:02,020
all of the attributes of the dick of

00:09:58,030 --> 00:10:05,350
each of these objects so Vsauce is an

00:10:02,020 --> 00:10:08,830
object and you have the name age and the

00:10:05,350 --> 00:10:12,130
extra attribute that we just added I'm

00:10:08,830 --> 00:10:14,590
also showing you the attributes of the

00:10:12,130 --> 00:10:16,780
class person since person is also an

00:10:14,590 --> 00:10:19,390
object it will also have an attribute

00:10:16,780 --> 00:10:21,700
dictionary so you check that you have

00:10:19,390 --> 00:10:24,820
your name age and coder which is just

00:10:21,700 --> 00:10:25,630
here if coder has a default value that's

00:10:24,820 --> 00:10:29,350
already here

00:10:25,630 --> 00:10:31,510
so this is how it looks but it's going

00:10:29,350 --> 00:10:34,000
to look slightly different with slots so

00:10:31,510 --> 00:10:35,800
the way I define it is I'd say I have a

00:10:34,000 --> 00:10:39,100
class person which has three different

00:10:35,800 --> 00:10:39,520
slots same in it there's absolutely no

00:10:39,100 --> 00:10:41,830
change

00:10:39,520 --> 00:10:45,670
same way we initialize objects there is

00:10:41,830 --> 00:10:48,640
no change I'm printing the attribute

00:10:45,670 --> 00:10:51,070
dictionary of person before and then I'm

00:10:48,640 --> 00:10:55,150
trying to add an attribute to that

00:10:51,070 --> 00:11:00,010
object as you see this will fail and if

00:10:55,150 --> 00:11:02,740
you check the attribute of person you'll

00:11:00,010 --> 00:11:05,620
see that age becomes a particular member

00:11:02,740 --> 00:11:08,460
it's not just something that it's not a

00:11:05,620 --> 00:11:11,960
placeholder anymore

00:11:08,460 --> 00:11:14,990
so what is actually happening so

00:11:11,960 --> 00:11:18,350
by default Python will use a dictionary

00:11:14,990 --> 00:11:20,720
and whenever you use a dictionary it's

00:11:18,350 --> 00:11:22,550
mutable you can add attributes and you

00:11:20,720 --> 00:11:26,360
can add attributes at runtime you can

00:11:22,550 --> 00:11:29,300
change them but since it is so mutable

00:11:26,360 --> 00:11:31,370
it also slows down the whole process but

00:11:29,300 --> 00:11:33,740
when you use slots you're telling Python

00:11:31,370 --> 00:11:35,930
hey look don't do all this I know I'm

00:11:33,740 --> 00:11:38,209
only going to use these three slots or

00:11:35,930 --> 00:11:42,649
these four slots you can go ahead and

00:11:38,209 --> 00:11:47,480
allocate memory for this and why do we

00:11:42,649 --> 00:11:50,060
do this because one it the the use of

00:11:47,480 --> 00:11:52,850
RAM becomes much better optimized things

00:11:50,060 --> 00:11:54,680
run much faster and if you have a really

00:11:52,850 --> 00:11:56,899
huge code base and you're entirely sure

00:11:54,680 --> 00:11:59,180
about exactly how the class is supposed

00:11:56,899 --> 00:12:00,920
to be used you can prevent accidentally

00:11:59,180 --> 00:12:02,990
misuse of classes you won't have an

00:12:00,920 --> 00:12:05,270
obscure part of the code where somebody

00:12:02,990 --> 00:12:06,649
just does something with some attribute

00:12:05,270 --> 00:12:10,060
and you don't know you don't see it

00:12:06,649 --> 00:12:13,190
anywhere else you won't have that now

00:12:10,060 --> 00:12:17,930
why would we do this so let's let's take

00:12:13,190 --> 00:12:19,940
simple simple has symbols and it has

00:12:17,930 --> 00:12:21,890
multiple other classes which gets

00:12:19,940 --> 00:12:24,410
initialized before symbols get

00:12:21,890 --> 00:12:27,860
initialized and there are classes in

00:12:24,410 --> 00:12:29,420
some pipe which for normal use will get

00:12:27,860 --> 00:12:32,209
you to easily a hundred different

00:12:29,420 --> 00:12:35,029
objects that exist at the same time so

00:12:32,209 --> 00:12:37,459
slots help optimize all that you don't

00:12:35,029 --> 00:12:44,779
want your system crashing so it starts

00:12:37,459 --> 00:12:46,490
help with that so now I am actually

00:12:44,779 --> 00:12:51,550
going to talk about metal classes and

00:12:46,490 --> 00:12:56,180
this is where I slow down in Python most

00:12:51,550 --> 00:12:58,520
every class is of type type classes

00:12:56,180 --> 00:13:01,610
class definitions are objects and they

00:12:58,520 --> 00:13:03,650
are objects of type type and this

00:13:01,610 --> 00:13:06,890
enables all of the default behavior that

00:13:03,650 --> 00:13:09,110
we see we see by default we have in it

00:13:06,890 --> 00:13:11,480
we have called we have all of these

00:13:09,110 --> 00:13:14,060
behaviors that we are used to this is

00:13:11,480 --> 00:13:16,970
what enables all of those behaviors meta

00:13:14,060 --> 00:13:21,079
classes allow programmers to take

00:13:16,970 --> 00:13:24,620
control of all of these behaviors so

00:13:21,079 --> 00:13:25,680
this is just an example I have a example

00:13:24,620 --> 00:13:28,740
class

00:13:25,680 --> 00:13:33,059
and I checked the type of that example

00:13:28,740 --> 00:13:35,610
floss and it's of type type this is a

00:13:33,059 --> 00:13:38,910
bit of syntax so how do we define a meta

00:13:35,610 --> 00:13:41,040
class any class that inherits from type

00:13:38,910 --> 00:13:43,829
is a meta class so you inherit from type

00:13:41,040 --> 00:13:45,689
and then you change whatever behavior

00:13:43,829 --> 00:13:48,089
you want to change you don't want to

00:13:45,689 --> 00:13:49,709
have to change and define every single

00:13:48,089 --> 00:13:51,179
behavior every time so that's why it's

00:13:49,709 --> 00:13:53,519
done like this

00:13:51,179 --> 00:13:54,929
we also have to tell Python that look

00:13:53,519 --> 00:13:56,670
we're not going to inherit from object

00:13:54,929 --> 00:14:00,420
we're not going to we are going to have

00:13:56,670 --> 00:14:03,119
our own meta class defined so this is a

00:14:00,420 --> 00:14:05,879
class meta this is so you have class

00:14:03,119 --> 00:14:08,369
meta which inherits from type and all

00:14:05,879 --> 00:14:10,499
I'm doing here is that every time an

00:14:08,369 --> 00:14:14,339
object is initialized I'm saying I want

00:14:10,499 --> 00:14:16,740
this attribute to be added and so I have

00:14:14,339 --> 00:14:18,629
a class where I'm defining that matter

00:14:16,740 --> 00:14:20,579
clause this is how you specify it

00:14:18,629 --> 00:14:22,980
there's no other definition there

00:14:20,579 --> 00:14:27,019
initialize an object and then when I

00:14:22,980 --> 00:14:29,519
print Brown dot coder voila you see true

00:14:27,019 --> 00:14:33,720
but when you see when you check the type

00:14:29,519 --> 00:14:36,360
of that object it's no longer it's no

00:14:33,720 --> 00:14:39,420
longer of the usual type object it's of

00:14:36,360 --> 00:14:41,879
type main meta it's done remained under

00:14:39,420 --> 00:14:47,069
because this meta class was defined in

00:14:41,879 --> 00:14:49,670
main and so this is another much better

00:14:47,069 --> 00:14:51,839
example of how metaclasses could be used

00:14:49,670 --> 00:14:54,319
this is the same example that I

00:14:51,839 --> 00:14:57,209
mentioned before in decorators we can

00:14:54,319 --> 00:15:00,959
sorry we can use meta classes to keep

00:14:57,209 --> 00:15:04,829
track of objects which get initialized

00:15:00,959 --> 00:15:06,509
in certain classes and we'd image the

00:15:04,829 --> 00:15:09,149
idea is we want to keep track and we

00:15:06,509 --> 00:15:10,410
want to know the number of objects and

00:15:09,149 --> 00:15:13,259
the number of ways in which our

00:15:10,410 --> 00:15:16,139
different class is being used so here I

00:15:13,259 --> 00:15:17,790
have a global variable models and I have

00:15:16,139 --> 00:15:21,149
a meta class which will update this

00:15:17,790 --> 00:15:23,759
global variable every time a new object

00:15:21,149 --> 00:15:25,799
is initialized and then I have a class

00:15:23,759 --> 00:15:28,199
model which inherits this meta class I

00:15:25,799 --> 00:15:32,009
mean like when I initialize it and

00:15:28,199 --> 00:15:35,850
afterwards I check the global variable I

00:15:32,009 --> 00:15:38,399
have that automatically updated you

00:15:35,850 --> 00:15:39,420
could also do this with decorators like

00:15:38,399 --> 00:15:41,460
I mentioned before

00:15:39,420 --> 00:15:45,840
but it's just that I personally find

00:15:41,460 --> 00:15:48,090
this cleaner and every anything that you

00:15:45,840 --> 00:15:50,820
inherit from models will inherit the

00:15:48,090 --> 00:15:53,210
same behavior so I find this a little

00:15:50,820 --> 00:15:53,210
bit cleaner

00:15:53,360 --> 00:15:58,620
so yeah this could be achieved by a

00:15:55,830 --> 00:16:00,660
decorator but that's not as clean but

00:15:58,620 --> 00:16:03,180
Mara classes are way more powerful you

00:16:00,660 --> 00:16:05,460
can change the sorting I think I skip

00:16:03,180 --> 00:16:09,750
this right yeah you can change the basic

00:16:05,460 --> 00:16:12,960
structure of a class itself so this we

00:16:09,750 --> 00:16:15,240
just saw that you have the classes are

00:16:12,960 --> 00:16:17,730
you classes use dictionaries suppose we

00:16:15,240 --> 00:16:19,230
have to process that dictionary and for

00:16:17,730 --> 00:16:20,790
some reason we don't want it to be a

00:16:19,230 --> 00:16:23,370
dictionary but we want it to be an

00:16:20,790 --> 00:16:24,780
ordered dictionary metaclasses will

00:16:23,370 --> 00:16:27,240
allow you to change things like that

00:16:24,780 --> 00:16:29,850
here again I'm defining a met applause

00:16:27,240 --> 00:16:31,620
and since I'm changing the way the class

00:16:29,850 --> 00:16:34,320
itself the objects are going to be I

00:16:31,620 --> 00:16:37,080
changed prepared and instead of

00:16:34,320 --> 00:16:39,150
returning a normal dictionary it's going

00:16:37,080 --> 00:16:42,030
to return an ordered dictionary this in

00:16:39,150 --> 00:16:43,710
this case I'm changing you just to print

00:16:42,030 --> 00:16:46,230
out the list of attributes that are

00:16:43,710 --> 00:16:49,410
there there's nothing really going on

00:16:46,230 --> 00:16:51,120
there and I have a class a this one has

00:16:49,410 --> 00:16:54,240
a meta clause it has a few attributes

00:16:51,120 --> 00:16:58,920
and if you look at the attributes list

00:16:54,240 --> 00:17:00,780
you see that it's all ordered and that

00:16:58,920 --> 00:17:02,280
that was the point of this example and

00:17:00,780 --> 00:17:06,000
you can you can change this to anything

00:17:02,280 --> 00:17:07,800
you want you want order diction you need

00:17:06,000 --> 00:17:09,750
it to be some sort of dictionary or

00:17:07,800 --> 00:17:14,190
topple or something like that but other

00:17:09,750 --> 00:17:16,530
than that you have complete control you

00:17:14,190 --> 00:17:19,079
can also change the base class so going

00:17:16,530 --> 00:17:22,230
back to the initial example that I used

00:17:19,079 --> 00:17:23,699
with inheritance you have the class

00:17:22,230 --> 00:17:27,030
Queen of England

00:17:23,699 --> 00:17:31,410
which has inherited from royalty and

00:17:27,030 --> 00:17:33,600
royalty has inherited from person now we

00:17:31,410 --> 00:17:36,690
obviously do one queen of England to

00:17:33,600 --> 00:17:38,760
also identify as person which means we

00:17:36,690 --> 00:17:40,500
want its base class to also be person so

00:17:38,760 --> 00:17:42,780
if you want to manipulate the base class

00:17:40,500 --> 00:17:45,180
if you want to manipulate the name of a

00:17:42,780 --> 00:17:48,180
class all of that meta classes allow you

00:17:45,180 --> 00:17:51,370
to do so here in in this case you have

00:17:48,180 --> 00:17:53,470
to change new so

00:17:51,370 --> 00:17:56,049
here you can you can change what the

00:17:53,470 --> 00:17:59,620
metaclass is to here for record-keeping

00:17:56,049 --> 00:18:01,929
so here I'm instead of returning just

00:17:59,620 --> 00:18:04,059
the object I'm saying I want you to

00:18:01,929 --> 00:18:07,179
define it in this way I want to change

00:18:04,059 --> 00:18:10,840
the name to Foo and I want to change the

00:18:07,179 --> 00:18:14,320
base class to int and so I have a base

00:18:10,840 --> 00:18:16,720
class which has the metaclass this meta

00:18:14,320 --> 00:18:18,250
class and then you have class a which

00:18:16,720 --> 00:18:20,830
inherits from base class and you have

00:18:18,250 --> 00:18:22,929
class B which inherits from a so by

00:18:20,830 --> 00:18:25,299
default if you try to check is be a

00:18:22,929 --> 00:18:28,870
subclass of Base loss it won't evaluate

00:18:25,299 --> 00:18:31,750
true but here I'm checking a is named

00:18:28,870 --> 00:18:34,419
foo B is named foo the outputs are below

00:18:31,750 --> 00:18:36,250
and you also try to check is be a

00:18:34,419 --> 00:18:38,980
subclass of eight now that will evaluate

00:18:36,250 --> 00:18:43,270
to false because basis is empty with

00:18:38,980 --> 00:18:45,970
except for end and is be a subclass of

00:18:43,270 --> 00:18:50,710
NTS B is a subclass of n because we've

00:18:45,970 --> 00:18:51,399
defined it to be that way a word of

00:18:50,710 --> 00:18:53,110
caution

00:18:51,399 --> 00:18:55,630
whether classes are really powerful

00:18:53,110 --> 00:18:57,240
they're really flexible but they add a

00:18:55,630 --> 00:18:59,559
lot of complexity to the code and

00:18:57,240 --> 00:19:02,679
especially it becomes very hard to read

00:18:59,559 --> 00:19:05,049
good you you might use a meta class now

00:19:02,679 --> 00:19:08,799
and then you inherit five other classes

00:19:05,049 --> 00:19:11,350
from it and you you keep using and then

00:19:08,799 --> 00:19:13,570
you inherit from those classes the

00:19:11,350 --> 00:19:16,210
behavior of the metaclass is propagated

00:19:13,570 --> 00:19:18,279
but for you to actually figure out that

00:19:16,210 --> 00:19:20,500
this particular object is behaving

00:19:18,279 --> 00:19:22,600
weirdly because somebody has changed the

00:19:20,500 --> 00:19:25,179
better class downstream somewhere can

00:19:22,600 --> 00:19:27,100
get really hard for someone so use it

00:19:25,179 --> 00:19:28,960
with a pinch of salt but if you can't

00:19:27,100 --> 00:19:35,470
find any other solution this is the way

00:19:28,960 --> 00:19:38,980
to go so this is I'm just gonna touch

00:19:35,470 --> 00:19:41,770
upon what simp is simple is symbolic

00:19:38,980 --> 00:19:43,840
Python we all have done symbolic

00:19:41,770 --> 00:19:46,270
mathematics which is the mathematics

00:19:43,840 --> 00:19:49,690
that we use in school you have symbols x

00:19:46,270 --> 00:19:51,190
y&z and you try to solve for them in

00:19:49,690 --> 00:19:52,750
some way and you manipulate those

00:19:51,190 --> 00:19:56,020
symbols without actually knowing what

00:19:52,750 --> 00:19:58,600
value they carry so some PI lets you

00:19:56,020 --> 00:20:00,789
initialize symbols so they're the

00:19:58,600 --> 00:20:02,990
fundamental thing in sci-fi so here I

00:20:00,789 --> 00:20:05,210
have three variables and

00:20:02,990 --> 00:20:07,520
I'm solving this particular equation

00:20:05,210 --> 00:20:10,160
which is sine X minus X and I can even

00:20:07,520 --> 00:20:14,120
define a domain I can say hey solve this

00:20:10,160 --> 00:20:16,250
equation within this domain and you can

00:20:14,120 --> 00:20:18,290
also do solving of linear equations

00:20:16,250 --> 00:20:20,450
where you can define those equations say

00:20:18,290 --> 00:20:22,190
solve for x y&z you can get those

00:20:20,450 --> 00:20:23,780
answers so this is what sin Phi does sin

00:20:22,190 --> 00:20:26,480
Phi does all sort of symbolic

00:20:23,780 --> 00:20:28,580
mathematics it's similar to well shrim

00:20:26,480 --> 00:20:33,590
it's similar to other things that have

00:20:28,580 --> 00:20:36,770
seen so I said I worked with sin pi this

00:20:33,590 --> 00:20:38,929
is a bit of simple inheritance tree

00:20:36,770 --> 00:20:40,850
simper has around thousand two hundred

00:20:38,929 --> 00:20:42,679
classes thousand seven hundred classes

00:20:40,850 --> 00:20:44,570
something like that this is a part of it

00:20:42,679 --> 00:20:49,820
this is what I had to work with mostly

00:20:44,570 --> 00:20:52,160
so I knew I had to work with around

00:20:49,820 --> 00:20:54,590
thousand symbols at the same time and

00:20:52,160 --> 00:20:58,550
manipulate all of them and we wanted to

00:20:54,590 --> 00:21:00,290
make that a synchronous and we wanted to

00:20:58,550 --> 00:21:02,300
add some properties to help speed up

00:21:00,290 --> 00:21:04,010
things further so that's when we hit

00:21:02,300 --> 00:21:06,440
upon slots we realized we can't just add

00:21:04,010 --> 00:21:09,080
properties and that's when we realized

00:21:06,440 --> 00:21:10,730
metaclasses also exists and managed

00:21:09,080 --> 00:21:14,300
properties is not going to behave like a

00:21:10,730 --> 00:21:17,210
normal class and that property starts

00:21:14,300 --> 00:21:18,740
propagating you also have a value F

00:21:17,210 --> 00:21:22,010
mixin which is the only thing that kind

00:21:18,740 --> 00:21:23,480
of helped where you have this is the

00:21:22,010 --> 00:21:26,600
point where a function gets evaluated

00:21:23,480 --> 00:21:29,059
and that's it that's inherited by

00:21:26,600 --> 00:21:31,130
addition subtraction multiplication and

00:21:29,059 --> 00:21:34,550
all of them have this so you change the

00:21:31,130 --> 00:21:37,309
value of mix in everything works and

00:21:34,550 --> 00:21:42,980
every anything that inherits that is

00:21:37,309 --> 00:21:47,870
going to work just like that so this is

00:21:42,980 --> 00:21:49,460
mostly what I have to say I want we've

00:21:47,870 --> 00:21:51,260
talked about inheritance we've talked

00:21:49,460 --> 00:21:54,040
about a lot of things we talked about

00:21:51,260 --> 00:21:56,420
inheritance mixin classes decorators

00:21:54,040 --> 00:21:59,120
metaclasses we've talked about how they

00:21:56,420 --> 00:22:02,870
could be used and are used in some PI

00:21:59,120 --> 00:22:06,160
and yeah I think we're open to questions

00:22:02,870 --> 00:22:06,160
we have questions

00:22:07,840 --> 00:22:16,380
oh sorry

00:22:11,350 --> 00:22:16,380
do we have questions yeah

00:22:26,110 --> 00:22:31,030
[Music]

00:22:28,620 --> 00:22:34,630
someone saying something I can't hear it

00:22:31,030 --> 00:22:36,790
hey yeah yeah you are

00:22:34,630 --> 00:22:37,600
yeah so about the mixing classes can you

00:22:36,790 --> 00:22:39,940
elaborate on that

00:22:37,600 --> 00:22:43,510
is it like calling the super function or

00:22:39,940 --> 00:22:45,660
no it's it's just a convention I'm gonna

00:22:43,510 --> 00:22:48,640
take this off so it's just a convention

00:22:45,660 --> 00:22:51,760
it's like it's just something that

00:22:48,640 --> 00:22:54,400
people do which makes code bases more

00:22:51,760 --> 00:22:56,080
maintainable and more readable it is not

00:22:54,400 --> 00:22:57,700
a feature of Python it's not involved

00:22:56,080 --> 00:23:03,610
with super it's just a class that you

00:22:57,700 --> 00:23:06,850
define let's say you have okay let's say

00:23:03,610 --> 00:23:08,470
you're doing something in which which

00:23:06,850 --> 00:23:10,809
models all of the people and you're

00:23:08,470 --> 00:23:13,210
gonna have an object a class for every

00:23:10,809 --> 00:23:15,850
person in the world and there is a

00:23:13,210 --> 00:23:17,620
property that people can read instead

00:23:15,850 --> 00:23:20,559
and they can read different things

00:23:17,620 --> 00:23:22,179
people can read English people can read

00:23:20,559 --> 00:23:25,179
Hindi there's there's a lot of different

00:23:22,179 --> 00:23:27,429
things that reading can do but you can

00:23:25,179 --> 00:23:28,900
just keep this but everybody reads in

00:23:27,429 --> 00:23:32,169
the same way you see something you do

00:23:28,900 --> 00:23:35,740
some processing and you read so you you

00:23:32,169 --> 00:23:39,220
isolate that behavior reading as read

00:23:35,740 --> 00:23:41,740
mixin maybe and then whenever you have a

00:23:39,220 --> 00:23:45,040
class person who can read you just mix

00:23:41,740 --> 00:23:47,290
that behavior and presumably you have

00:23:45,040 --> 00:23:50,380
languages that dictionary etc as

00:23:47,290 --> 00:23:53,290
attributes which will which will then be

00:23:50,380 --> 00:23:55,090
processed so that it's a way to isolate

00:23:53,290 --> 00:23:58,929
behavior so that the code is really

00:23:55,090 --> 00:24:02,500
readable right here back here in the

00:23:58,929 --> 00:24:05,620
back okay hi I said thank you it was a

00:24:02,500 --> 00:24:17,250
gray on e so so you don't have questions

00:24:05,620 --> 00:24:19,720
yeah yeah so at the beginning are you

00:24:17,250 --> 00:24:22,179
when you are talking about simple you

00:24:19,720 --> 00:24:25,299
had mentioned something about hard logic

00:24:22,179 --> 00:24:29,380
in neural networks could you elaborate

00:24:25,299 --> 00:24:32,970
on that possibly show some references to

00:24:29,380 --> 00:24:35,609
any research papers you were working on

00:24:32,970 --> 00:24:37,470
for the research papers you just just

00:24:35,609 --> 00:24:39,629
google neural networks and logic you're

00:24:37,470 --> 00:24:43,109
gonna get a lot of them symbolic logic

00:24:39,629 --> 00:24:45,899
and neural networks basically what it is

00:24:43,109 --> 00:24:48,899
is that neural networks are really hard

00:24:45,899 --> 00:24:52,919
to control and their behavior becomes

00:24:48,899 --> 00:24:57,479
undefined beyond certain boundaries the

00:24:52,919 --> 00:24:59,849
this research is to basically not have

00:24:57,479 --> 00:25:01,979
that happen and have some control over

00:24:59,849 --> 00:25:06,029
the way neural network behaves despite

00:25:01,979 --> 00:25:07,529
you know the inputs that we get we can

00:25:06,029 --> 00:25:11,359
talk about this later I don't think it's

00:25:07,529 --> 00:25:11,359
directly related we can talk about it

00:25:18,360 --> 00:25:21,670
well so this is regarding

00:25:20,440 --> 00:25:24,460
metaprogramming

00:25:21,670 --> 00:25:26,380
so I also use a lot of meta classes in

00:25:24,460 --> 00:25:28,870
my work so there is one problem that I

00:25:26,380 --> 00:25:30,360
have not been able to solve is if let's

00:25:28,870 --> 00:25:33,640
say you are in the main function and

00:25:30,360 --> 00:25:36,790
there are functions in that main body

00:25:33,640 --> 00:25:39,670
that are not part of any class so can

00:25:36,790 --> 00:25:43,960
you control those as part of your meta

00:25:39,670 --> 00:25:46,120
programming in any way probably I really

00:25:43,960 --> 00:25:47,350
don't know you attentively could but I

00:25:46,120 --> 00:25:50,170
would say please don't use that many

00:25:47,350 --> 00:25:51,850
mattr classes okay but good for

00:25:50,170 --> 00:25:54,940
readability that are good for

00:25:51,850 --> 00:25:58,230
maintainability unless you absolutely

00:25:54,940 --> 00:25:58,230

YouTube URL: https://www.youtube.com/watch?v=SwQJ7FUj4B0


