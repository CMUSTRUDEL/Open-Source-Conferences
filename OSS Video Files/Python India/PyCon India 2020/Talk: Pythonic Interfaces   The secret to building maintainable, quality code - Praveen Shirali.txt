Title: Talk: Pythonic Interfaces   The secret to building maintainable, quality code - Praveen Shirali
Publication date: 2020-12-03
Playlist: PyCon India 2020
Description: 
	This talk was presented at PyCon India 2020 Online.

PyCon India is the largest gathering of Pythonistas in India for the Python programming language. The 12th edition of PyCon India took place online from 2nd October to 5th October 2020.

Talk Detail: https://in.pycon.org/cfp/2020/proposals/pythonic-interfaces-the-secret-to-building-maintainable-quality-code~bYjYd/

Click here to subscribe to the PyCon India channel: https://www.youtube.com/user/inpycon?sub_confirmation=1
Follow PyCon India on Twitter: https://twitter.com/pyconindia
Follow PyCon India on Facebook: https://www.facebook.com/PyConIndia/
Captions: 
	                              we have praveen with us                               hey praveen welcome to the stream                               hi hello everyone hey uh nice we can                               hear you clearly                               so praveen will be taking us through the                               pythonic interfaces presentation                               and uh status all your subscribing                               thank you um                               hello everyone uh i hope you are all                                having a great time at                                pycon india uh and i hope your day one                                was very interesting and enjoyable                                welcome to day two so my name is praveen                                shirali                                and i'll be talking today on a pythonic                                approach                                to interfaces and interface enforcement                                if this is the first time you are                                exploring the subject then                                don't worry we'll be discussing concepts                                from scratch                                at the end of this talk there is a slide                                which has references                                and links for further reading and that                                should help you dig deeper into the                                subject                                so you can check that out later so i've                                been told by the coordinators that there                                could be a lag between me                                presenting and you listening so if we                                pause for questions in between let me                                delay                                uh things a little so in the interest of                                time                                i'll take questions at the end of this                                talk                                at the bottom right of the screen you                                will find slide numbers                                and if you have questions which are                                specific to a slide then do make note of                                the slide number                                i am happy to run back through the                                slides to                                refer to that the slides are also                                available on the url                                listed here at the bottom so you can                                refer to the slides independently during                                q and a                                uh if you don't find sufficient time for                                q then uh please feel free to reach out                                to me                                directly at some later point the last                                slide has information on how to reach me                                all right so with that uh let's get                                started                                so yeah so in this talk                                uh we'll try to understand what really                                is an interface and why is it important                                we'll see what benefits we derive from                                enforcing interfaces we'll also explore                                what options we have in python                                  and                                                                    this                                finally we look at a couple of factors                                to keep in mind when                                choosing a solution and what are the                                pros and cons and stuff                                okay so let's get started so                                what is an interface an interface is                                a shared boundary across which                                two or more components share information                                so do note the terms highlighted                                so we'll try to explore this with an                                example okay                                so consider an application and that's                                sort of represented by the box over here                                so this application has a class called a                                data processor                                which is responsible for processing some                                data                                now this data processor is responsible                                only for processing the data                                and it relies on another component                                somewhere inside this application                                to help fetch that data                                and somewhere in this application is a                                class called                                a file io class and this class is                                capable of reading data from a file and                                writing data to a file and so on                                it does this through the read and write                                methods typically found on file like                                objects and the data processor                                depends on the file i o instance and                                calls its                                read and write methods somewhere during                                its execution                                now let's say that the application needs                                to support more such data sources in the                                 future                                 so consider that there is a class called                                 memio and this is very similar to the                                 file io class                                 it defines exactly the same methods as                                 file i o                                 they behave in the same manner as well                                 but the memio class operates entirely in                                 memory                                 it doesn't read or write from a file on                                 disk                                 so this gets interesting for the data                                 processor                                 because it has to work with classes                                 which are similar                                 so you could say that the data processor                                 now requires a class which implements a                                 read write method so to put that in                                 context                                 think of a data processor as a first                                 person                                 right so the data browser is advertising                                 to                                 everybody else that i i can perform read                                 and write operations                                 and i can work with any class which                                 helps me do that                                 and what i'm doing is i'm going to call                                 your read and your write method                                 and for me to do that i expect that your                                 read and your write methods                                 follow a particular format in the form                                 of                                 the arguments that have to be passed                                 so if we were to express this                                 relationship in the form of code                                 we could define a completely new class                                 so let's call it read writer because it                                 does read and write                                 and let us define the read and write                                 methods inside it                                 but it got nothing else there is no                                 implementation whatsoever it is just                                 empty methods now this represents an                                 interface                                 it's an empty class which only defines                                 what methods need to exist                                 and this serves as a blueprint for other                                 classes which actually implement these                                 methods                                 like fileio and memio implement these                                 methods                                 now does file i o have methods with the                                 same definition                                 as rewriter yeah                                 it does right so we expect read to read                                 and we expect right to perform a write                                 operation and so on so the even the                                 behavior                                 is as per the spec so you could say that                                 file io class                                 satisfies the read writer interface                                 mind you we are like doing this this                                 implicit                                 assumption because we are comparing it                                 by just visual inspection                                 but if we could programmatically verify                                 this then we would say that the file i o                                 class implements the read i o we read                                 the writer interface                                 similarly you can observe that the memio                                 class                                 also satisfies the rewriter interface                                 now if there are future needs for                                 similar                                 i o classes could a completely new class                                 implement                                 the interface yeah it could write                                 so all it needs to do is it needs to                                 ensure                                 that the read and write methods are                                 exactly the same                                 or they're implemented in exactly the                                 same form                                 but is it really necessary to have                                 interfaces like why do we have to be so                                 strict could we choose not to be strict                                 like for example this class here is a                                 less strict version of the io class                                 right it defines read and write methods                                 which could work                                 with the data processor but uh you don't                                 see it matching the interface                                 right but technically it should work                                 but the question really is do you want                                 to take a chance with this                                 because if there are issues you will                                 discover them during execution                                 when those read and write methods                                 actually get called                                 so sure you may have unit tests and                                 stuff but it's like                                 pretty late you're going to discover                                 them when you run those tests um                                 and everything depends on that the fact                                 that you've written your tests well and                                 so on                                 but ideally it would be awesome for you                                 to know about these when you're writing                                 the code itself                                 right that's that's a good early stage                                 to know when things are deviating                                 so this leads us to an interesting                                 thought like could we detect and verify                                 interface deviation automatically so                                 that we don't leave this to chance                                 rather can we write code to enforce the                                 fact that the implementations like file                                 and mio must implement methods as per                                 spec                                 in this case as defined by read writer                                 interface                                 because if we are able to do that then                                 we can detect missing methods                                 wrong arguments misspelled method names                                 bad declarations and absolutely any                                 deviation that might arise                                 right we don't have to test for such                                 deviation specifically                                 but we just get some code in our                                 application to do that for us                                 so what does interface enforcement mean                                 exactly this                                 we basically find some code which                                 ensures that a class adheres to an                                 interface                                 and if it doesn't then the application                                 raises errors                                 so rather than testing for it we make it                                 a requirement for the application for it                                 to start or run correctly                                 and what do we really want to enforce we                                 want the                                 method names to be correct we don't want                                 to miss                                 any methods we want method signatures to                                 match                                 that is the arguments the order of                                 arguments                                 type annotations etc we wanted to                                 respect descriptors and decorators like                                 static method                                 property etc if some methods are                                 generators                                 or async methods we should be able to                                 detect those as well                                 and really anything along those lines if                                 you feel that there's some sort of a                                 structure that has to be followed by all                                 of the implementations you could try to                                 enforce it                                 so in summary the expectation is                                 if you have an interface and this                                 interface defines certain methods in a                                 certain format                                 and there are specific arguments                                 specific                                 decorators which define it and so on you                                 want                                 all implementations to implement it in                                 exactly the same way as the interface                                 defines it                                 why is this really important well                                 clearly there are some                                 benefits but like what problem does it                                 solve in the real world so let's again                                 try to understand this with an example                                 consider an application again again                                 represented by this box                                 and assume that this application                                 consists of a lot of components                                 and this components could be modules                                 classes                                 functions and so on just code                                 distributed across the application                                 and all of these components are classes                                 they talk to each other                                 the instances talk to each other and                                 over time                                 the application is constantly evolving                                 some components are getting added                                 some components are getting removed we                                 may improve some of the components as                                 well                                 you'll have better versions of the same                                 components working in its place                                 and over time the application begins to                                 take shape                                 at some point when you introduce a                                 change to a component                                 we end up breaking the application now                                 one of the reasons could be that the                                 interface between these components are                                 not clearly defined                                 so one of these components which could                                 be these                                 empty boxes makes a call to the                                 component                                 in the green box expecting that a                                 certain method is available                                 and expecting that it will behave in a                                 certain manner which it doesn't anymore                                 so what we ideally want is a scenario                                 where we can                                 plug and play such components or classes                                 right without worrying about                                 breaking method calls at least if you                                 are able to ensure that                                 then that the interfaces are honored                                 then that's one less problem to worry                                 about                                 so what really are the benefits for a                                 start we get clear boundaries of                                 separation                                 and responsibility for each of the                                 classes                                 and that makes it easier to maintain                                 applications                                 because they are less prone to errors                                 if we are able to enforce interfaces                                 then we could prevent some errors as                                 well                                 right and knowing them very early is a                                 huge win it saves time                                 a lot of engineering effort and also                                 improves quality                                 so how do we enforce interfaces                                 so python has a library called abstract                                 based classes                                 right abc in short and abc provides                                 mechanisms to achieve                                 what we discussed to some degree                                 so interfaces are enforced using meta                                 classes                                 and interface class sets abc meta                                 as a meta class abc meta is a class                                 inside                                 abc and abc meta                                 actually has the code that does the                                 enforcement                                 additionally we need to decorate each of                                 the methods                                 with this abstract method the decorator                                 indicating that this must be present in                                 the implementation                                 so an example of what this would look                                 like                                 in this case let's look at memio so                                 memio                                 inherits from read writer which is the                                 interface                                 and then we have the read                                 and the right methods actually                                 implemented in this class                                 and when you try to create an instance                                 of memio that is when                                 the checks are performed to see whether                                 read and write are implemented or not                                 so just note this once again that the                                 interface marks the abstract method                                 interface marks                                 those methods which are meant to be                                 mandatory                                 and the implementation actually                                 implements it                                 so how does enforcement kick in right so                                 let's say you have a version of memio                                 which does not have the right method                                 right now when you try to create an                                 instance of memio                                 then the compliance code will kick in                                 and say                                 your memio class does not implement a                                 write method                                 so that's the type error that's raised                                 over here and this error is raised when                                 the instance is created                                 when you're instantiating the class                                 now there are some limitations to what                                 abc can do                                 you can see an implementation here of                                 memio                                 where the read and write methods have no                                 arguments at all however no exceptions                                 are raised                                 when the instance is created                                 so while abstract based classes can                                 enforce the presence of methods                                 they can't do anything beyond that                                 on the positive side as the                                 entire mechanism is defined using meta                                 classes and inheritance                                 uh the subclasses tend to automatically                                 benefit from the                                 advantage of interfaces which are                                 already defined                                 in the in the interface the                                 implementation                                 tends to benefit from it                                 but abc has actually been around since                                 python                                                        and perhaps at that time the goals were                                 different right                                 uh now there's an interesting talk by                                 raymond hettinger                                 on this which uh sheds some more light                                 on                                 the abc's history and so on so                                 the link for that is there in the                                 reference slide and you can have a look                                 at it                                 later but python                                                     and let's see what we can do with that                                 so let's explore python                                               libraries and what                                 it can offer                                 so python                                                        annotations                                 async better typing                                 there is an inspect library which is                                 part of the standard library                                 and the inspect library is actually kept                                 up with the times                                 besides python offers expressive ways of                                 defining                                 apis methods can be defined in a lot of                                 ways                                 we are going to look at a few of them                                 now but obviously there is                                 more that python can do than what we are                                 covering in this stock                                 so like let's look at some ways to                                 define a method                                 in this case and                                 while we do so let's also observe some                                 uh factors that matter                                 it's likely that any python                                   application you are writing today                                 will likely have methods defined in all                                 of these forms                                 or at least a majority of these forms so                                 so this stuff is very relevant to python                                                                   applications of today right                                 so let's start with the first one                                 obviously the name is name of the method                                 is very important                                 it is the identifier with which the                                 methods can be retrieved and                                 everything else is verified using that                                 as the first step                                 next the method signature is important                                 because they define the arguments type                                 annotations etc                                 then we have data descriptors um                                 like the property decorator etc etc                                 these are interesting because though                                 they those members look like methods                                 they're not really callable and they                                 behave like attributes                                 then we have class method and static                                 method                                 decorators we also have generator                                 functions co-routine functions                                 which lend themselves to different                                 behavior as compared to regular methods                                 so what can we do with inspect                                 so inspect has a function called                                 signature and as the name suggests                                 this function returns a signature object                                 and the signature object represents the                                 arguments their order                                 type annotations basically everything                                 that follows the method name                                 and signature objects can be compared                                 against each other so you can                                 use this easily to verify signatures                                 across                                 an interface and an implementation so                                 that you can know whether an                                 implementation actually                                 implements it correctly or not                                 now again data descriptors are special                                 so you have methods which look                                 like they have the same name but they                                 are decorated with property setters                                 getters etc                                 these are not callable so inspect dot                                 signature will fail on them                                 but there's a handy function called is                                 data descriptor                                 which can tell you whether a method is a                                 descriptor or not                                 and you can use that as a mechanism to                                 further fetch the actual getters and                                 shutters                                 there are also functions which can                                 detect generator functions and                                 co-routine functions as well                                 so there's east generator function                                 e-score routine function it's pretty                                 straight forward                                 this is a little interesting so the                                 class methods and static methods                                 can be detected first by fetching the                                 method from the class that actually                                 implements it                                 and we can do this by navigating the                                 classes                                 mro the mro stands for method resolution                                 order                                 and the the dunder mro attribute holds                                 the                                 entire class hierarchy so once we fetch                                 we can then use ease instance to check                                 whether a method is a class method or                                 static method                                 and the reason you need to do this is                                 because uh the methods could also be                                 inherited                                 by an implementation though though the                                 inherited class does not define it                                 uh it's likely that the parent defines                                 it and the                                 decorator is actually used in the parent                                 class so that's why we need this                                 method to fetch the actual uh class                                 where that method is implemented and                                 then check on it                                 so let's revisit our list right so if                                 you                                 look at the method definition list here                                 we have a way to identify                                 everything that's on the list so it's                                 pretty easy to build enforcement                                 capabilities                                 so if an implementation does not satisfy                                 a check and just raise an error                                 and that's time yeah hello sorry to                                 interrupt                                 yeah but uh the attendees are saying                                 that the slides are not getting changed                                 are you on the same slide slide number                                                                    yeah sorry sorry uh i could see that                                 yeah                                 oh um i'm sorry let me just run through                                 the slides again                                 sure thank you yeah yeah thanks for                                 pointing this out                                 um right so uh i'll just take one minute                                 to quickly run through the slides that i                                 explained                                 i'm sorry for the miss so we were                                 looking at this slide                                 with where all the methods were defined                                 and like various methods ways in which                                 you can define these methods                                 and what we can do with inspect so the                                 first                                 function we saw is inspect.signature                                 which can be used to                                 retrieve a signature object these                                 signature objects are actually                                 comparable                                 so you can use this to verify whether                                 a defined signature from an interface                                 matches that of an                                 implementation for                                 property decorators and data descriptors                                 there are some special mechanisms                                 in place so basically the method names                                 look the same                                 but they are actually decorated so the                                 inspector signature                                 does not work because these methods are                                 not callable                                 but there is a function called ease data                                 descriptor                                 so you can use that to detect whether a                                 method is a data descriptor or not and                                 if it is                                 then you can start fetching specific                                 elements from it                                 for generator and coroutine functions                                 there are again ready functions                                 which you can just call                                 for class method and static method you                                 need to go through a route to actually                                 fetch the method from the class which                                 implements it                                 and then check whether a class method or                                 a static method decorator has been                                 applied on it or not                                 so coming back the                                 types of method definitions that we                                 originally listed                                 we feel that there is a there is a                                 way to actually verify all of these                                 and build an enforcement mechanism to                                 detect these and also raise errors                                 so in fact there are some third-party                                 libraries which already do this pretty                                 well                                 uh so so there are more than these                                 libraries so i'm just listing three of                                 them here                                 uh implements python interfaces and                                 zob.interface                                 implements is a very simple                                 library which does a lot of enforcement                                 basically it's just one decorator that                                 you need to                                 import and use on your implementation                                 python interfaces                                 uh has wider support for python                                       python                                                        and job.interfaces is a huge package                                 it's got very descriptive apis and so on                                 so how do you choose a solution that                                 matches your needs so                                 there are a bunch of factors which are                                 of importance                                 so let's do some very quick comparison                                 of just some of the main factors there                                 are a lot more                                 uh so one of the main ones is                                 composition versus inheritance                                 and this is very evident from the way                                 you bind the interface with the                                 implementation                                 so in case of implements you have your                                 class which is your implementation in                                 this case my class                                 and you just put a decorator on top of                                 it that says implements and then pass it                                 the class name which is actually the                                 interface so it's that simple                                 so the class you can when you look at                                 the class you straight away know                                 what interface it implements so this is                                 a very clean wrapper                                 it is very explicit uh you can                                 read it very easily now on the right                                 side                                 both abc and python interface packages                                 use meta classes                                 for enforcement and the in                                 the inheritance is used to propagate                                 enforcement                                 this is not as explicit as the decorator                                 based approach                                 because you need to know the entire                                 class hierarchy                                 but on a positive side because of                                 inheritance all these subclasses also                                 enjoy the benefit of the interface                                 enforcement                                 so if you already have a code base which                                 uses                                 inheritance heavily or you have already                                 been using                                 abc to do enforcement of interfaces then                                 python interface is a great choice to                                 work as a replacement                                 another important factor is uh early                                 versus late enforcement                                 uh which is actually the main advantage                                 that you can                                 draw out of it so implements                                 and python interface uh they                                 enforce on import or class creation                                 so as soon as your application runs when                                 all your packages are getting                                 you know imported that is when this                                 kicks in so it is really really early                                 and it can stop your application right                                 there in case some errors are found                                 right and this is really useful                                 on the other hand with abc                                 it is based on the philosophy that the                                 right time to check                                 for any sort of enforcement or adherence                                 is just before when just before the                                 creation of the                                 instance um yeah but however i feel uh                                 knowing things early pays great                                 dividends so so you can make a trade-off                                 over here                                 i'm sorry i didn't advance the slide so                                 um yeah so early versus late enforcement                                 is like this so i think we are at the                                 end of my talk                                 so let's just do a recap so                                 we defined uh interfaces what those are                                 and we've seen that interfaces help                                 and the interface enforce                                 it even better we've seen on offer                                 what python                                                             third party libraries can provide                                 and really in today's world with python                                                                                              using abc anymore there are much better                                 alternatives                                 we can see how inspect can be used and                                 how enforcement can help us                                 find interface errors early and                                 with that we are at the end of this talk                                 so here are some references for future                                 reading                                 the links are the slides are shared so                                 you can actually go through these at a                                 later point                                 so thanks a lot these are ways in which                                 you can                                 reach me if you have any questions at a                                 later time                                 all the slides are also available online                                 on github for you to refer to                                 so i'm open to questions now thank you                                 thanks a lot praveen that was great now                                 let me just quickly go through                                 the attendees and what they are saying                                 and uh let's start from the beginning                                 when you were almost midway through the                                 slides                                 sridhara says we can have a adapter for                                 data input                                 for data processor adapter design                                 pattern right                                 um is is that the question                                 no he's just a comment he's trying to                                 suggest                                 that particular option right now says                                 um looks similar to a java interface i                                 think this is when you were                                 before slide number                                           yeah and we have a fairly big question                                 okay so priyasha says what's the link                                 for slides on twitter so um for all the                                 attendees                                 after the session is over if you want to                                 have a conversation with the speaker                                 feel free to                                 visit zulip and go to                                                    stage forward slash delhi and there you                                 can find                                 praveen you can ask any question you                                 want offline as well praveen will also                                 share all the resources that he wants to                                 share the code base the slides and                                 everything                                 there only okay and we have                                 a big question uh sairam says the                                 advantage                                 of developing in python let me just                                 quickly copy this                                 and paste as a banner so that everybody                                 else can see it                                 okay so how much time do we really                                 uh have left for q a so i guess we have                                 a couple of minutes left                                 and there is a five minute buffer so we                                 have                                 if you see the max amount of time we                                 have seven minutes so if someone else                                 wants to ask a question feel free to                                 write there                                 so the question goes uh let me just can                                 i connect to the first question can i                                 take them in order                                 yeah sure yeah so on the first question                                 yes the adapter pattern helps                                 the adapter pattern is a way of bridging                                 uh                                 two different uh classes on what they                                 offer and the adapter fits them                                 fits in somewhere in between and                                 translates what one class requires and                                 how a different class can                                 you know offer it uh ideally                                 that that comes at a fairly advanced                                 stage where you want to                                 where you are at a situation where you                                 don't have the flexibility of modifying                                 a class                                 because let's say it is being offered by                                 a third party package and you                                 you can't really modify it so you build                                 an adapter so that you can bridge                                 the connection between these two uh                                 however the interface mechanism is there                                 for you to establish                                 a common language for two classes to                                 talk to each other                                 so it is different from the adapter                                 pattern in that it is trying to just                                 formulate rules saying                                 i am a dependent class uh say i am data                                 processor and i need to depend on                                 class number a class a class b class c                                 and in order for these classes to                                 give me what i want i am going to define                                 this interface which they are supposed                                 to                                 obey and if they're they are compliant                                 then i can work with them                                 so the purpose is slightly different                                 though that you can use either of these                                 to accomplish share me                                 um so can we move to the                                 next question yeah let me just comment                                 like it looks similar                                 yeah it does look similar to the java                                 interfaces where you have                                 it clearly defined and so on uh so it's                                 a bridge between java interfaces                                 and sort of what go tries to accomplish                                 golan                                 uh but it's yeah we're not get we are                                 not there yet this is a fairly pythonic                                 way of trying to draw similar benefits                                 from what other languages already                                 implement and it's actually part of                                 their language                                 as well so for us it's something we have                                 to build on                                 um another question is i understand that                                 python interfaces and sorry that's                                 what you must use yeah yeah so                                 implements is uh just uses a decorator                                 called improvement                                 right and what implements does this when                                 you when you give it an implement                                 when you give it an interface class it                                 goes through all the methods that it has                                 it fetches all of them and understands                                 its signature                                 understands whether there's a decorator                                 on it and so on and then it tries to                                 compare that with the implementation                                 and see whether the implementation has                                 it or not so the moment so all of that                                 logic is built into that                                 interface decorator sorry the                                 implementation decorator                                 so the moment that decorator kicks in                                 it's going to do that comparison for you                                 on import so the the                                 the enforcement is done right there when                                 you're like loading the                                 loading all of the modules                                 i i hope that answers the question all                                 right i'll link to more details later                                 it's uh there's another question it's                                 situational but given that both methods                                 are applicable                                 so yeah if you're writing fresh code                                 today                                 uh and you have a complete choice of                                 whether you want to do a lot of                                 inheritance or not                                 then composition is a better way to go                                 about it                                 but if you're dealing with a huge legacy                                 code base where you're doing a lot of                                 inheritance already                                 or you're already using a abcs and you                                 want to just transition that code to                                 work with interfaces better than maybe                                 python interfaces                                 or your python interfaces or zoop or one                                 of these                                 could be a better choice it depends on                                 what what change you want how early you                                 would like to detect changes and so on                                 so it's just trade-offs and how much                                 effort that goes into                                 picking one of the methods okay                                 another question is too long so it might                                 cut off on the screen i'm just going to                                 read it from the                                 chat sorry                                 yeah so uh the trade-off here is                                 how clearly do you know the requirements                                 for one class to depend on another class                                 so when you say fast development uh the                                 the the methodology uh matters here like                                 are you writing code to then                                 understand how classes work or do you                                 have a predefined                                 understanding of how the classes are                                 supposed to talk to each other so if you                                 already have some predefined                                 understanding                                 of how class a should talk to class b                                 then you will be able to define                                 interfaces better                                 sometimes these interfaces also come out                                 of evaluation of                                 development as well so i don't think it                                 slows down the development process that                                 much                                 because the the work involved in getting                                 the                                 interface in place is not much you just                                 have to define the methods clearly                                 as a class and then all the classes                                 which are supposed to implement it you                                 just decorate it or                                 insert in some way so the effort                                 required to integrate is not much                                 uh but the thought that goes into                                 exactly defining the interface that is                                 much higher                                 so yeah that's where the tradeoff is                                 there is a second part of this question                                 what are the scenarios where interfaces                                 must be enforced and where to relax                                 um interfaces give really good value if                                 you have                                 one class which is going to talk to                                 multiple variants of                                 other classes like we saw this data                                 processor right and data browser talking                                 to file i o mio                                 let's say there are like four or five                                 other such classes and you want to                                 enforce rules on multiple such classes                                 so in such cases interfaces work really                                 well ideally you should be trying to use                                 this everywhere                                 but there may be some places where the                                 api itself is very experimental you are                                 not sure whether the method definitions                                 you                                 have defined today are the right ones or                                 not                                 and for you to make changes it may                                 require you to make a lot of changes all                                 over the place                                 so in those cases you may want to relax                                 so that you have solidified                                 the interfaces to a certain degree where                                 you feel that things are stable                                 and then enforce it great                                 thanks a lot praveen and uh i hope you                                 had to                                 um sleep chat for more questions and to                                 all the attendees feel feel free to                                 reach out to praveen if you have more                                 questions                                 thanks a lot thank you see you all have                                 a good day                                 bye
YouTube URL: https://www.youtube.com/watch?v=rIsG7fx-U7M


