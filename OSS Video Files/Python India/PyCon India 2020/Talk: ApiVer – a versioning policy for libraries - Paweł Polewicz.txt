Title: Talk: ApiVer – a versioning policy for libraries - Paweł Polewicz
Publication date: 2020-12-03
Playlist: PyCon India 2020
Description: 
	This talk was presented at PyCon India 2020 Online.

PyCon India is the largest gathering of Pythonistas in India for the Python programming language. The 12th edition of PyCon India took place online from 2nd October to 5th October 2020.

Talk Detail: https://in.pycon.org/cfp/2020/proposals/apiver-a-versioning-policy-for-libraries~eXmga/

Click here to subscribe to the PyCon India channel: https://www.youtube.com/user/inpycon?sub_confirmation=1
Follow PyCon India on Twitter: https://twitter.com/pyconindia
Follow PyCon India on Facebook: https://www.facebook.com/PyConIndia/
Captions: 
	                              we have                               we have an announcement for you all so                               the announcement goes group discussion                               starts at                                    isd in deshaw india booth number one                               however gave a thought on whether we                               should have python as the first language                               to be taught in universities and                               colleges                                if not this is the time to think and                                share your views we                                look forward to some interesting                                discussion here and of course                                there are some exciting prizes of for                                crap                                that's that's amazing thanks the show                                for that                                so feel free to check out julie if you                                go to the announcement channel you'll                                find a                                link to wherever the booth is on hop in                                or you can                                check the booth on hop in itself if you                                want to                                and there are some forms to be filled if                                you want to grab those gifts                                and prizes so go to zolip                                announcement channel you'll find a link                                to the registration form                                you'll find the link to the booth as                                well                                now moving on to powell hey province can                                you hear me                                hello hey i can hear you clearly                                so i'm just gonna share your screen now                                and the stage is all yours                                okay hello my name is pavel kolevich and                                today i'm going to                                speak about library interfaces changing                                over time                                let's begin                                version operates can be painful but for                                developers those are often worse than                                for regular users                                i'm going to tell you a story about the                                debian server upgrade that i took part                                of in                                                                    after upgrading the operating system                                version all services were fine                                except one ftp it accepted connections                                but refused to transfer files                                this ftp was the only way for us to put                                new music on a streaming server                                of the largest e-radio station on the                                planet                                at that time so we had to get it up                                first we tried                                the init script just stop it within the                                script                                but it didn't do nothing so but you know                                in its scripts they they sometimes have                                bugs                                sometimes they rely on peat files that                                are not there                                so i thought okay this is not working                                let's                                list the process list find the the ftp                                process                                send it to kill                                so that's what we did but it didn't work                                either so                                we thought more okay okay so what what                                else can we do kill means nine                                sick kill um so we sent that                                but amazingly did still                                not kill the process for                                             accepting connections not transferring                                files                                you kind of puddled but then                                one of the admins has remembered that                                there is a command that can kill every                                process                                it was kilo pi he invoked the command                                without any parameters                                to see what the proper syntax is                                because you know most commands if you if                                you just type the command name it was a                                error missing argument but the density's                                terminal froze                                no help was displayed                                and that happened because kilo                                          accept any arguments it kills all the                                processes                                in the system                                every service died including ssh                                we couldn't log in anymore the stream                                switched to                                to the backup server and there was no                                 kvm so we couldn't connect to that                                 server either                                 uh by that but                                 even after this                                 the port                                                        connections                                 so we had to call the data center i                                 asked them to                                 press the physical button on the machine                                 to reboot it                                 when i think about that story my smile                                 it was fun but not all version                                 upgrade stories are that funny                                 non-backward compatible changes are a                                 major issue with long-term support                                 maybe young startups don't feel it that                                 much                                 but successful projects eventually have                                 to operate their dependencies                                 startups that take a longer time to get                                 to the market                                 are impacted most by this because their                                 stock is getting old                                 and they still have very limited                                 resources                                 poppy products the ones that are closest                                 to our hearts                                 during our free time those are hit the                                 hardest because there's almost no                                 resources                                 and dependencies are changing their                                 version                                 and you have to follow them otherwise                                 your project just doesn't work                                 the interface changes in the libraries                                 eventually force the application                                 developers to adopt their code                                 to work with the new api so for them it                                 would be best to never                                 have any non backward compatible changes                                 the thing shown on the screen is the                                 most famous                                 adapter in the world on board of apollo                                                                     i want us as a community to make less of                                 those                                 the thing is if a library has                                           and non-backward compatible change will                                 eventually force all of those users to                                 go over the change log and adapt their                                 code to the new interface                                 but most of this effort is hidden from                                 the library maintainer                                 while hundreds of engineers try to                                 migrate their applications over to the                                 new interface                                 the library maintainer already works in                                 new features and next                                 changes so there is a great disparity                                 between the effort                                 that the community needs to make to                                 follow the version and the amount of                                 work that this developer                                 can do to to increase the major                                 assembler to release a new                                 non-compatible version                                 both users and maintainers face the same                                 problem from different sites                                 maintainers want to improve their                                 interface                                 for the new users the old users would                                 like to keep their applications running                                 so they don't want the interface to                                 change                                 meanwhile new users want a new a                                 new modern nice api but as soon as they                                 start using it                                 they want stability they become old                                 users and they don't want                                 the interface to change anymore                                 users also generally want access to new                                 features                                 performance and maintainability                                 improvements even after they settle for                                 an interface barrier                                 so library maintainers need to introduce                                 non-backup compatible changes to their                                 apis to improve them                                 but then eventually application                                 developers                                 have to follow those changes in order to                                 receive security updates and support                                 because the maintainer will not keep                                 maintaining the old versions old                                 branches of the library and                                 fixing bugs on all of them eventually                                 the support is going to be dropped                                 version                                                               third day                                 regardless of popularity or version one                                 because nobody can adapt the record yet                                 and there seems that there is no other                                 way                                 but maybe there is                                 turns out there might be a way                                 actually i think it's not that hard i                                 pulled the abstraction of the interface                                 which solves this problem                                 apiver because it assumes that the api                                 of the library will                                 have different values here is how it                                 looks for the unit                                 now this is how we previously imported                                 cog so there is the internal                                 structure of the library is exposed a                                 little bit                                 and then the user needs to know this to                                 import a function                                 and                                 this is the new way that i propose                                 so the obvious question here is what                                 about namespaces                                 so it is unlikely that you really need                                 them                                 if you even have two file                                 classes in different modules that do                                 different things                                 you might want to change their names a                                 little bit so that's less confusing                                 alternatively just the twist and                                 keep a little bit of your external                                 structure                                 of your internal structure in the                                 interface i realized that                                 my library is like medium size and it                                 can be flattened to a to a simple name                                 space                                 easily                                 [Music]                                 the important part is that v                                  which gives you back your freedom                                 if you use api verb you can move your                                 code around                                 as much as you want really because users                                 won't mind                                 in fact most of them won't even know                                 that something happened                                 imagine what your users would think if                                 you'd like to rearrange modules                                 so that the structure is slightly more                                 consistent there's no functional change                                 to it but                                 it looks more tidy for you                                 but then sometime later you decide                                 something between the old system and the                                 current system would be even better and                                 you change it again                                 everybody would have to fix their                                 imports                                 and then fix them their imports again                                 so you're creating a lot of work for all                                 of your users                                 you break compatibility for them for no                                 functional change                                 if you use apiver you are free to change                                 your internal structure without                                 impacting the users                                 okay so how how does the implementation                                 look like how does how do we do this                                 well it turns out it's not expensive                                 it's one line                                 per public member on the of the                                 interface                                 so function class or constant that's all                                 it takes                                 see for yourself                                 the newest version                                 imports from your internal structure so                                 this is version two                                 and it's imports from uh from the                                 structure that you haven't got the                                 imports                                 seem similar to how we used to import                                 before                                 the copyr version version one                                 imports from second version                                 so so this one init file                                 is the adapter that bridges the gap                                 between                                 version one and version two changes                                 the older versions import from the one                                 above them                                 version one impersonal version two                                 version two in person version three and                                 so on                                 so you only need to focus on one adapter                                 at the time                                 to cover the api differences between the                                 last release                                 and your current pull request                                 okay so that's moving but how about                                 renaming a function of the class let's                                 do that                                 version three is again one line                                 in fact it's the same line that you used                                 to have                                 in version                                                              except it now imports a rename function                                 and users of version                                                 function by its new name by rename                                 function                                 while users of version                                             the function the same name as they used                                 to call it                                 and it will still work for them and the                                 adapter for version                                                    line                                 no need to release a new major version                                 no need to adjust code for all the users                                 just works                                 okay how about adding a new mandatory                                 argument                                 so here we assume that version four                                 needs to explicitly provide the value                                 and version                                                  it's up to the developer to decide if                                 the style keyword argument should be                                 available for version                                         here there seems to be no benefit in                                 finding it the alternative is to do this                                 so just you don't expose it in the                                 version                                             uh so they can't define this style                                 but but it is defined for them                                 okay so in version two we have moved the                                 code around in version three we have                                 renamed functions in version four we                                 have added mandatory arguments                                 now imagine that we would also refactor                                 portions of the code                                 keeping the same interface in version                                   but then we would fix an old bug                                 so if we had different versions of the                                 code on different branches                                 we would not be using apiver we would                                 have to                                 backport the fix through code movement                                 renaming and refactoring and                                 that requires more and more more more                                 and more work                                 from the maintainer the farther we go                                 into the past                                 that is the reason why people cut off                                 support                                 but then some bug needs to be fixed in                                 different implementations                                 refactor and pulse refactor so you're                                 doing the same thing twice                                 and it is wasteful                                 if you are using apivert the fixing of                                 the top version is enough                                 and also there is no need to drop                                 support for the old versions because                                 there are                                 no old versions no need to force folks                                 using the old versions to adjust their                                 code just works                                 okay so that's all good but there can be                                 some issues                                 so these are the ones that i found some                                 wrappers                                 may be hard to write if you                                 change a lot in your interface                                 and that means the users would have to                                 adapt their code                                 so either everyone implements their own                                 adapter                                 or they change their code which is even                                 more aware                                 so we can do this                                                      entire community                                 right or we can do this in one place                                 in the library itself the cost                                 is way lower but the other person bears                                 the cost                                 so that's a little bit of a problem                                 i have to say that if you are the person                                 that is breaking the compatibility                                 you know the old interface you know the                                 new interface                                 you have all the code in your memory                                 and you're making that change so                                 creating an adapter for you is quite                                 easy                                 creating an adapter for someone else                                 that                                 you just installed your library three                                 years ago                                 and has no understanding about the                                 internals                                 is way more difficult so it's not like                                 it's                                           easier for you to do that it's even more                                 some tooling would be nice we can                                 probably manage things better we can add                                 decorators to indicate the                                 in the documentation that the given                                 method is going to be phased out in the                                 future                                 um but not future major release but                                 future                                 happy release we can automatically list                                 the differences between the interface                                 versions and so on                                 that link is not here yet we can make                                 and if you think if you don't think                                 about your interface                                 which methods and functions should be                                 public and constants                                 adams and and uh you are all                                 ready above version                                        you may want to cut down the interface                                 to what should actually be public                                 in a major december release before                                 adopting apiver                                 because supporting internal                                 infrastructure with                                 wrappers it's just not necessary nobody                                 will ever use those                                 wrappers but you don't really know                                 because                                 you don't know which methods are public                                 or which are private                                 defining the interface surface is                                 important in december                                 not all people do that that's that's a                                 good movement to do it                                 okay so what's next                                 you already know how not to use your                                 internal module structure                                 as a library interface just create one                                 file                                 which expose the flat interface                                 preferably flat                                 and let people use that                                 so if you start using upper you you can                                 start using it now                                 but you'll probably learn something and                                 please share that learning with me                                 so that we can make it better                                 and yeah i'm sure it can be improved but                                 for that we need to                                 start using it and we have to talk                                 is the shoot summary this is how it                                 looks for the user                                 this is how you implement something                                 right there the the wrapper so just                                 create an init file and uh                                 and take from the higher one or from the                                 um                                 if you're on the top version just just                                 import from your internal structure                                 and benefit that you get from that is                                 freedom to do whatever you want with                                 your internal                                 structure of the code without messing                                 everything up for                                 all of your users and                                 on version                                                           room problem where you just release the                                 second version                                 but nobody can use it because                                 they already use the old version and                                 they don't really have time                                 to modify their codes on your schedule                                 thank you let's talk during the break                                 and um                                 thanks for watching oh yeah so                                 let me finish if you'd like to discuss                                 this subject with me further                                 or any other python backend subject for                                 that matter                                 find me during the break in the hallway                                 um which will seem he will                                 mention in a moment and here's my email                                 if you want to write to me                                 uh finally many things to the organizers                                 of the conference                                 or letting me share this i hope it will                                 make the                                 world a slightly tiny                                 little better place than it used to be                                 okay thanks thank you pavel                                 we have one question would you like to                                 take that right now                                 all right yeah so the question goes does                                 that mean when we implement the tenth                                 version of a library                                 we have to include ninth eighth seventh                                 version in the                                 package wouldn't that increase the size                                 of the package a lot                                 um okay that's a very good question                                 so you don't                                 include the entire code base of it you                                 only include the top version                                 and wrappers for the old versions but                                 those are only one file                                 that has one line per interface member                                 so it's extremely light and pip also                                 zips                                 it and most of it is going to be import                                 statements and the                                 zip eats those pretty well so                                 maybe the package will become a little                                 bit bigger                                 but you shouldn't even notice it                                 like i i don't think it's a major                                 concern the storage                                 cost now is very small and it takes you                                 a                                 tiny little bit fraction of the scent to                                 store this forever so                                 kinda yes but it's not a really big                                 problem                                 okay any other questions                                 anyway um let's let's go to the                                 oh we maybe discuss this video we                                 actually have a video chat on                                 [Music]                                 that we can go into and discuss it on on                                 video                                 sure so i have this second front                                 yes so i have this uh hollywood track                                 as you can see we have a lot of hallway                                 tracks which are completely free to join                                 and one of the holiday tracks which is                                 mercury is completely free right now                                 and we can invite to invite all the                                 attendees who are watching right now if                                 you have any questions if you want to                                 communicate                                 i will after the session feel free to                                 join mercury hallway track                                 and uh ask your questions or uh have a                                 conversation                                 talk more about how you can do it right                                 here if it's a bad idea please come and                                 tell me                                 if it's please come and tell me you got                                 it                                 so i'm sure you'll find a lot of uh                                 questions there                                 and thanks a lot pablo thanks a lot we                                 see you on the hallway track now                                 okay and uh sure thanks see you there                                 bye-bye                                 okay so major announcement after this                                 session                                 is that we are going to have our                                 keynote um speaker on the bangalore                                 stage so naomi said i will be joining us                                 she will be giving a keynote session at                                                                                                                           and it is going to start in just three                                 minutes                                 so if you want to check out that keynote                                 session please head towards bangalore                                 stage uh so we are going to                                 stop the delhi stage stream right now                                 feel free to head towards the bangalore                                 stage                                 you'll find the that uh session running                                 on the stages click on bangalore and                                 you'll be in                                 okay thanks a lot everyone for joining                                 on day one                                 on delhi stage and uh see you tomorrow                                 sure share your feedbacks or questions                                 uh in the comments on hopping chat                                 tweet about this section tag at the                                 right python india                                 hashtag pycon india                                      and uh yeah thank you                                 bye
YouTube URL: https://www.youtube.com/watch?v=FgcoAKchPjk


