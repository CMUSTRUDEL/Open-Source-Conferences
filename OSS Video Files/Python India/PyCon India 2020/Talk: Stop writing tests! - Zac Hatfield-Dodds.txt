Title: Talk: Stop writing tests! - Zac Hatfield-Dodds
Publication date: 2020-12-03
Playlist: PyCon India 2020
Description: 
	This talk was presented at PyCon India 2020 Online.

PyCon India is the largest gathering of Pythonistas in India for the Python programming language. The 12th edition of PyCon India took place online from 2nd October to 5th October 2020.

Talk Detail: https://in.pycon.org/cfp/2020/proposals/stop-writing-tests~aKWGa/

Click here to subscribe to the PyCon India channel: https://www.youtube.com/user/inpycon?sub_confirmation=1
Follow PyCon India on Twitter: https://twitter.com/pyconindia
Follow PyCon India on Facebook: https://www.facebook.com/PyConIndia/
Captions: 
	                              hi everyone welcome back                               so our next talk is stop writing test by                               zach hatfield                               so like the change is yours now thanks                               very much                               uh so today i'm talking to you                               about stop writing tests and given that                               i work on a number of testing libraries                               you might guess i'm going to be a little                                provocative but i'm also giving a                                serious talk this is not a joke                                i don't think you should do less testing                                but i do think that you should stop                                writing quite so many tests as you                                probably do at the moment                                but yep see                                there we go the first thing i need to do                                is an australian tradition                                i'm giving this talk from the beautiful                                city of canberra australia                                where i was born just off to the right                                hand side of this photo                                live just off to the left and work in                                the middle                                canberra is the land of the none of all                                people the first australians who came                                here about                                                 and i want to start my talk by paying my                                respects to their elders past                                and present and emerging and                                acknowledged that australia was                                colonized not peacefully settled                                but back to the testing part of this                                talk                                when i talk about testing i mean an                                activity that we do                                as part of our software development                                process where we execute our code in                                order to find bugs                                or check for regressions and let's step                                through that kind of line by line                                so first of all testing is something                                that we do as developers or as                                testers and the execution of code is                                what distinguishes it from other very                                helpful things we can do                                to try to make our code correct i would                                encourage all of you to look at                                type checkers like my pi or linters like                                flocate or pylint which can read your                                code and check for errors automatically                                or use tools like black which format                                your code and exclude a whole bunch of                                confusing style problems that can lead                                to errors                                those are great but they're not what i'm                                talking about today i mean testing where                                you actually run your code                                see what it does and check that it does                                the right thing                                and the last part to either find bugs or                                check for regressions                                speaks to a bit of a philosophical split                                in the testing community                                some people say that the reason we write                                tests is to actually look for bugs                                it's because we're not sure whether or                                not our code is correct and we want to                                search for counter examples that would                                demonstrate that there's some kind of                                problem with it                                the other view which i've heard more                                often from companies or starts who have                                a kind of move fast without breaking                                things idea is that the role of testing                                at least in continuous integration                                isn't necessarily to find bugs it's just                                to confirm that you didn't break                                anything which was previously known to                                be working                                this is a bit of a deep distinction but                                since the techniques and the tools you                                use are more or less the same in each                                case                                i'm just going to ignore it again until                                closer to the end of this talk                                and so the activities that we do when                                we're testing i basically break up into                                four parts                                the first is that we choose what inputs                                we're going to test on                                and that could be what files do we feed                                in it could be                                what do we call our test function with                                it might be what websites or buttons do                                i click on                                then we run whatever the code is that                                we're testing that's the core part                                and then at the end we check that it did                                 the right thing or at least it didn't do                                 anything that we know to be wrong like                                 crash or raise an exception and then                                 finally we repeat that as often as we                                 need to                                 so for this talk i'm going to split it                                 into three rough parts in the first part                                 i'm going to talk about                                 why would we automatically generate test                                 cases and                                 how would we get the computer to do that                                 for us in the second i'll talk about how                                 to test                                 properties of your code so thinking                                 about the more general things that                                 should always be true rather than                                 specific inputs                                 and then last of all i'm going to                                 introduce you to some exciting work i've                                 been doing recently                                 about fuzzing your test suite and i'll                                 explain that too                                 but to start with we often talk about                                 automated testing                                 and i want to make the case that                                 automated testing is actually pretty                                 much                                 still manual so when we say an automated                                 test                                 what we usually mean is there's a test                                 scenario                                 which we've expressed in code and the                                 advantage is that that makes it much                                 cheaper to re-run                                 right after the first time that you                                 write out all the test inputs and then                                 test logic                                 you can just run it by typing pi test or                                 maybe unit test or whatever                                 else you prefer and that does save a lot                                 of time                                 but i think this is still much more like                                 the mechanical turk                                 you might be familiar with that because                                 amazon runs a service called mechanical                                 turk where                                 humans do work that is then attributed                                 often to computers                                 but the name actually dates back to a                                 chess playing robot                                 in the                                                                   the time because no one could work out                                 how you would make clockwork play chess                                 in fact some scientists got a little                                 over excited and declared that                                 machines would never be able to play                                 chess which                                 turns out to be wrong of course but at                                 the time it was true the machine could                                 not in fact                                 play chess there was simply a dwarf a                                 small human                                 with a good grasp of chess and a                                 complicated periscope tucked up inside                                 the mechanism                                 and so when we talk about automated                                 testing i reckon that what we're talking                                 about is still more like the mechanical                                 turk                                 than a modern chess playing computer                                 [Music]                                 so let's get into some examples but i do                                 need to warn you                                 right when i'm talking about examples in                                 this talk because they all have to fit                                 on a slide they're going to be quite                                 simple                                 they're going to be relatively simple                                 code relatively simple data inputs                                 but i just want to promise you that this                                 these techniques do actually scale to                                 more complicated data                                 if you have really complicated json                                 structures or django models or whatever                                 else it is                                 you can still test it with the same                                 techniques what you can't do                                 is put them on a single slide in small                                 enough font                                 that you can fit it all on and still                                 have people able to read it                                 so forgive me and then for my friend                                 david i promise i'm not going to reverse                                 a list                                 let's try sorting lists instead                                 so this is like a basic exercise you'll                                 get all the time right if you                                 learn computer science you'll probably                                 be told there are many many ways to sort                                 lists you've got                                 bubble sort quick sort merge sort heap                                 sort bogo sort bogo bogo sort                                 bogo bogo bogo sword and a bunch of                                 other slower things                                 but i reckon hypothetically i've                                 invented a faster way to sort lists                                 it's a way that takes only constant time                                 so it's a super fast list sorting                                 mechanism                                 and without spoiling what it is let's                                 work out how i might test this                                 the first thing i usually do when i'm                                 testing is not automated at                                 all i just open up a python session and                                 i run the code and in this case i've                                 thought of two basic cases i should test                                 the first is that if i sort a list which                                 is already in sorted order                                 i get the expected output that is the                                 sorted list one two three                                 and then the other case is if the list                                 is not in order and i sort it i should                                 still get the sort of list back right                                 one two three instead of two three one                                 and so to make this an automated unit                                 test                                 i would just write the test functions                                 and then i could run pi test on this                                 file                                 and each of those assertions would be                                 checked automatically so this is                                 actually a little more work the first                                 time i run this test if i'm automating                                 it                                 but it makes it much less work                                 afterwards                                 and as your project grows beyond the                                 trivially small                                 that's a really good investment then of                                 course                                 we're probably told we shouldn't repeat                                 ourselves as software engineers                                 and so because our assertions are                                 basically the same we can put that into                                 a parameterized                                 test where we list out the arguments to                                 the function                                 and the expected results and then we can                                 check that with a single test body                                 there's only one problem with this                                 when i told you that i'd implemented a                                 sorting function i had lied                                 this sorting function will always return                                 the list one two three no matter what                                 the input is                                 and so the output is sorted and it                                 passes all the tests                                 but we might not think that that means                                 it's actually working                                 so what else could we do well the first                                 one is that we probably need to come up                                 with examples that aren't just                                 one two three or two three one and                                 that's going to be easier if we don't                                 have to work out what the output should                                 be                                 and so if we can write a test function                                 that looks like this that says                                 given any list when we sort the list and                                 then we compare each pair of elements                                 in the result they should be in order                                 and now this function can detect a whole                                 bunch of                                 wrong implementations that our previous                                 test                                 couldn't detect what it can't do is                                 actually find the bug before                                 what we also need to do is assert that                                 we have the same list elements in the                                 output                                 this test checks that our result is in                                 fact a sorted list                                 when we add the counter line that checks                                 that it's a sorted version                                 of the input list and now all we need to                                 do is run this test function                                 on very many different kinds of lists                                 and we're sure to find almost any bug                                 that we could have                                 and notably in order to write this test                                 we don't actually have to know how to                                 sort a list ourselves                                 in the case of sorting we could just                                 compare the results to python's                                 sorted built-in but we don't have to do                                 that to be able to use this technique                                 and so this is called property-based                                 testing because                                 we're testing more general properties of                                 our code and i find that as well as                                 being a really great way to find bugs                                 this also helps me think more clearly                                 about the design of my api                                 it helps me think clearly about what my                                 code should do as well as helping me                                 check that it does                                 actually do that and                                 generating test inputs once we've                                 written a test that can have any of them                                 is great                                 because it means that our tests are no                                 longer limited by our imaginations                                 and that means that our tests can find                                 bugs that we didn't even know were                                 possible                                 and that might seem a little crazy but                                 this has happened to me many times i've                                 actually learned things about how                                 python implements a quality based on the                                 tests that i've written                                 and i'm going to demonstrate that later                                 in the talk as well so                                 here's the foolproof plan step one is to                                 install hypothesis                                 hypothesis is python's leading and i                                 think in fact only library for                                 property-based testing                                 and that's just pip install hypothesis                                 if you're on python                                                                                                    version if you're on an older version                                                                                                    latest version was when                                 they went out at the end of life then                                 you can read the documentation                                 and then profit but let me show you                                 through                                 an example right and i'm not going to                                 talk about sorting a list again                                 that kind of algorithmic library code is                                 great right property-based testing is                                 great for it but you can also test stuff                                 that looks more like complicated                                 business logic                                 and there's an example of that that i                                 think we'll be familiar with i'm going                                 to think about                                 get so a business requirement is that if                                 you check out a new branch in a                                 repository                                 then the current branch is whatever                                 branch you just checked out and this has                                 a number of side effects right you've                                 got to think                                 it's actually touching the disk so it's                                 having persistent effects                                 on the file system it's got state it's                                 got multiple steps it's not just                                 comparing inputs and outputs right                                 but we can still write a property based                                 test and in fact we can even migrate                                 our existing tests to be more property                                 based                                 so the first step is just to say that                                 if this should work for any branch name                                 we can just make that an argument to the                                 function                                 this is still the same test but we're                                 expressing better                                 what our constraints are and in                                 particular we're saying the specific                                 name of the branch shouldn't matter                                 and then if we start to use hypothesis                                 we can say given the branch name which                                 is just the string new branch                                 same test so we still haven't changed                                 the logic but now we're using hypothesis                                 so that's a great start and then because                                 we don't want to repeat ourselves                                 we can also define our valid branch                                 names function                                 which returns the strategy the just                                 generator                                 which describes what valid branch names                                 should be                                 and that means that we can reuse it                                 easily between many different tests that                                 i'd know do something with branches                                 but recall we're still running the same                                 code                                 we haven't actually changed anything yet                                 but we're ready to                                 and this is where the design feedback                                 comes in if you say                                 a branch name should be any string                                 you're going to run into a lot of                                 problems i tried this briefly and i                                 discovered                                 git branch names can't have trailing or                                 leading white space                                 they also can't have trailing or leading                                 dashes it turns out that                                 many services reject names which are too                                 long                                 and unicode text or right to left                                 text can also cause a lot of problems                                 so we ended up discovering something                                 about get                                 just by trying to write a test for it                                 and we can easily tell hypothesis                                 to restrict the range of inputs so we                                 say maybe                                 we should be able to pass the test of                                 all things but we're just going to do                                 this for now                                 and that's a really useful thing to be                                 able to do while you're migrating                                 and then if we go back to the body of                                 our test we can see                                 we're still only ever using new                                 repositories so                                 the final version of this test that i                                 would try to migrate to says                                 given any valid branch name and any                                 repository                                 if we assume that the branch name isn't                                 yet in the branches of that repository                                 and we check out that branch then the                                 active branch is the branch we just                                 checked out                                 so property-based testing in a nutshell                                 but what happens if you don't have any                                 existing tests that you can migrate or                                 you've migrated your whole test suite                                 good work and now you want to move on                                 well this is why i introduce you to the                                 hypothesis ghostwriter                                 the ghostwriter is a project i've been                                 working on for about six months earlier                                 this year                                 and announced just a few weeks ago at                                 pike on australia so you guys are the                                 second audience in the world to see it                                 and i am so excited to share it with you                                 so if you have pip installed                                 hypothesis                                 with all of the optional dependencies                                 let's actually just go with the                                 ghostwriter                                 all right and i'm updating my                                 installation which is a good habit tab                                 now we can ask hypothesis to write us                                 some tests in fact let's just ask how do                                 we write tests first of all                                 well the ghostwriter the hypothesis                                 write command                                 will write your property-based tests for                                 you                                 if you have cart annotations it will                                 actually inspect those to work out what                                 the arguments should be                                 but even without them it can sometimes                                 guess and when it can't guess                                 it'll just leave a little template for                                 you to fill in so                                 let's start with this suggested version                                 let's test                                 the re dot compile function that's                                 regular expression compile                                 and you can see that we have a couple of                                 parts here                                 so hypothesis first of all we import                                 the functions that we're going to use we                                 have a note that we need to                                 specify what the pattern can be and then                                 we have our test function                                 let's try a more complicated example                                 let's think about json values so                                 one test that we could write for json                                 would be that if we have a json object                                 and we serialize it to a string and then                                 we read it back into python objects                                 we should have an equal object at the                                 end of that that's kind of the basic                                 idea of saving or loading data                                 and this is one of the most powerful                                 properties that you can test                                 because almost every application will                                 translate data between different formats                                 whether that's to send it between the                                 front end of the back-end                                 or to save it in the database and load                                 it back and testing that your data round                                 trips correctly                                 is something which should always be true                                 so that's a great use case for                                 hypothesis                                 so let's test that if we use json.jumps                                 and then json.loads                                 that's dumping to a string and loading                                 to a string                                 and so i've got the code hypothesis                                 right over in my editor window this time                                 and you can see that there are way more                                 options to these json functions                                 than i would have naively expected when                                 i first wrote this                                 and then ultimately our function has                                 been written for us we                                 dump to a string then we load the string                                 back into a value and then we compare to                                 check that they're equal                                 and so our comment says we just have to                                 replace the nothing                                 strategy so json is a recursive                                 value which consists of                                 either none or                                 booleans or json can have                                 integers or                                 it can have floats or it can have                                 text and so that's our json values right                                 but then because json is recursive                                 we can also have lists of json                                 or we can have dictionaries                                 of text so that's unicode strings                                 basel                                 so that's all we needed to do to write                                 our entire test                                 and now let's run pi test on it and see                                 if this actually                                 passes any bets i want you to think                                 about whether you expect this to pass                                 before i run it                                 and if you think it will fail why                                 all right here goes                                 alright so we've actually got                                 two distinct failures here the first one                                 is that if we have the allowed man                                 argument equal to true                                 but our object is nan then ah the                                 floating point not a number is not equal                                 to itself                                 that makes sense our second argument                                 though                                 tells us something different if we have                                 allow none equals false                                 this is python's option which says the                                 json spec doesn't actually allow for not                                 a number or infinity                                 and so if we pass infinity then we get                                 an error                                 because this isn't really a compliant                                 json value                                 so the correct way to handle this would                                 be to tell our                                 float strategy that we don't allow                                 infinity                                 and we don't allow not a number                                 if we run our test again we'll discover                                 that this time                                 it passes so that's the power of                                 property-based testing it can teach you                                 about your code                                 and it can do so very quickly and it                                 finds errors that you might not have                                 thought were even possible                                 the other fun side of course is just                                 because i have these tools                                 i can write convenient tests that for                                 example hit                                 the entire numpy api                                 and this is going to be a big one so                                 with one line of code we have generated                                 three and a half                                 thousand lines of tests                                 and they're pretty good tests i'm not                                 going to promise that they're amazing                                 tests but they're pretty good                                 so final thing that's the ghostwriter                                 and now i want to tell you about fuzzing                                 so fuzzing is the practice of getting                                 more out of your existing tests                                 instead of just generating random data                                 you actually keep track of                                 which inputs major functions do                                 something new                                 so you run the whole thing under                                 coverage and every time you find a new                                 covering example                                 you then keep track of that and use it                                 to generate more                                 so hypothesis has this is a demo it's                                 not open source yet but                                 i've been working on it for a while                                 shhh                                 [Music]                                 all right and so this is the live view                                 of                                 the hypothesis fuzzer i've been working                                 on                                 and what happens here is that it will                                 automatically collect your tests                                 and start running them constantly not                                 one at a time for a few seconds each                                 but interleaving them working out which                                 one is currently making the fastest                                 progress                                 and running them indefinitely you can                                 run this overnight                                 over the weekend and the cool bit is                                 whenever it finds an                                 error it will save that error in the                                 same way as hypothesis                                 so if you just run your test with pi                                 test again it will replay                                 all of the failing examples that are                                 found through this fancier fuzzer                                 and i think that is getting me pretty                                 much to time                                 so at this point i think i'm going to                                 say                                 thank you very much i hope you have                                 learned something or maybe even decided                                 to use hypothesis                                 and i'm happy to take questions                                 [Music]                                 just loading up the chat so i can                                 actually see your questions                                 awesome prehab i am delighted that you                                 are interested in hypothesis                                 how does the ghostwriter work with                                 custom methods it really depends on what                                 your methods                                 are so the short version is                                 let me mute this so i don't have to                                 listen to my self-talk                                 the ghostwriter works perfectly well                                 with custom methods as long as it can                                 introspect them                                 but the only short pitch i can give is                                 try it and i'm pretty sure it will work                                 for you and if you don't the                                 documentation is                                 on our documentation site                                 uh the fuzzer is not yet available but                                 it does have the website at                                 hyperfuzz.com                                 and i am hoping that that will be                                 available for businesses                                 in the next few weeks there's a lot of                                 accounting stuff to work out before i                                 can release it sorry                                 and yep that is the link to my talk page                                 where                                 all of these links and details are                                 available                                 this link right here for anyone who is                                 watching the video later it's also                                 in the chat                                 yes hypothesis does in fact integrate                                 with django natively                                 so if you have a form or a model you                                 don't even have to specify                                 all the arguments you can just tell a                                 hypothesis hey give me                                 instances that fit this model and it                                 will even generate them in the database                                 for you                                 so it works very well with django it                                 also works very well with pendants we                                 have a whole pandas extension so you can                                 say                                 databases defined either by the rows or                                 the columns so you can say                                 you know i want columns for this or i                                 want rows for that                                 and the same for numpy support                                 okay                                 pancaj has asked does every test run a                                 different set of cases                                 with hypothesis and the answer that                                 actually depends on the settings you                                 choose                                 by default each time you run pi test                                 we'll spend                                 a couple of cases replaying things that                                 we've seen before                                 so if your test failed before we'll try                                 to replay those examples so they                                 don't flakily start and stop failing the                                 idea is that                                 if they fail you try something to fix                                 the failure and then you run your tests                                 again                                 if they pass you can be confident that                                 they really are passing now                                 but otherwise if you want them to be                                 deterministic so they run the same set                                 of test cases each time there is an                                 option for that                                 but we tend to recommend generating nude                                 ones each time you run the test and                                 that's what it does by default                                 uh davida has asked does this work for                                 keras machine learnings or another                                 person has asked for high spark support                                 the main response to that is if you want                                 a raise of numbers you can do that via                                 the numpy                                 support and then convert those into pi                                 spark objects                                 and i do know people are doing that and                                 it works pretty well for them                                 uh indranil hypothesis is absolutely                                 free for                                 commercial usage it's under the mozilla                                 public license which is kind of like the                                 lgpl                                 the fuzzer is probably not free for                                 commercial usage because we need to fund                                 work on hypothesis                                 somehow and substantially because                                 i think for non-commercial uses most of                                 the value actually comes from hypothesis                                 itself to get a lot of value out of the                                 fuzzer                                 you probably actually want to have                                 professional software engineers and a                                 couple of servers to run it on                                 and most hobby or even open source                                 projects just don't have the resources                                 to take advantage of that                                 and yes you can integrate hypothesis and                                 the ghostwriter into                                 projects with existing pi test tests and                                 in fact as you saw on the stream                                 when i write tests with hypothesis i                                 then actually run them with pi test                                 so they work really well together if you                                 want to use hypothesis with unit test or                                 with nose that also works really well                                 sound raj asks does it support code                                 coverage yes it does                                 uh the hypothesis test suite uses                                 hypothesis and coverage and pi test                                 babu asks do we have metrics that define                                 the success of the library                                 that's a bit of a tough question so one                                 option one way of thinking about that                                 would be                                 how do we see if it's done what if it's                                 accomplished what we set out to                                 accomplish                                 and in the manifesto on our site we                                 define the goal of hypothesis is                                 to drag the world kicking and screaming                                 into a new age of higher quality                                 software with less bugs                                 i like to think we're making some                                 progress but we're certainly not there                                 yet                                 the other one would just be the                                 straightforward idea of how many people                                 are using it                                 according to the python software                                 foundation survey four or five percent                                 of python users are already using                                 hypothesis                                 and it's a little less than fifty                                 percent are using pi test                                 so where we have about                                           possible users who download                                 any testing tools at all i think that's                                 pretty good but i'd still like to do                                 better                                 perform asks what does this mean for                                 test driven development                                 uh property property-based tests are not                                 a different way for testing to fit into                                 your development cycle                                 but rather a different kind of test you                                 can write                                 so property-based tests fit just as well                                 into test-driven development as unit                                 tests or integration tests do                                 shashank asks where can i learn more                                 about testing in python                                 uh i'm afraid i don't have an easy                                 answer for you                                 aside from the way i learned it was                                 really just modeling my way through                                 so i found the hypothesis documentation                                 there are a couple of really good books                                 about it                                 but part of it would be i would suggest                                 finding some projects that you use                                 and looking at their tests or projects                                 which are similar to what you're looking                                 working on and imitating the way they're                                 testing things                                 pratt asks do i see this competing with                                 any other peer libraries                                 there are similar libraries in many                                 other languages                                 but it's rare for anyone to be deciding                                 you know do i use                                 java quick check or hypothesis because                                 if you're writing java you                                 use the java library and if you're                                 writing python you use hypothesis                                 in python uh i don't know of any                                 competitors                                 i think largely because as an open                                 source project                                 hypothesis is usable by anyone and                                 maybe i'm immodest here but too good to                                 compete with                                 ankit asks is my ideal recommend                                 recommendation unit testing plus                                 hypothesis testing or just hypothesis                                 i almost always do both there are some                                 edge cases that i want to make sure are                                 always executed                                 and hypothesis does have support for                                 decorating here are specific inputs to                                 always test and then generate more                                 uh but some edge cases it's just not                                 worth pulling out hypothesis so                                 for me probably about                                                  of the tests i write are hypothesis                                 tests                                 which means                                                             of my tests are generated by hypothesis                                 but i wouldn't say never write anything                                 else that's for sure                                 uh hi zach you can totally use mocks and                                 stubs with                                 hypothesis and with pi test we have                                 we have we completed our time zach                                 all right thank you very much uh it was                                 a great talk and                                 yeah thanks very much everyone i will be                                 hanging out in the zulu for a while                                 so thanks very much and i look forward                                 to seeing you around the conference
YouTube URL: https://www.youtube.com/watch?v=3hWY5P3ogZc


