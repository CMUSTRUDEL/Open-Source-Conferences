Title: FSOSS 2015 - Raffi Der Haroutiounian & Diogo Monteiro - Dockerizing Microservices
Publication date: 2015-11-12
Playlist: FSOSS 2015
Description: 
	FSOSS 2015 - Raffi Der Haroutiounian & Diogo Monteiro - Dockerizing Microservices
Captions: 
	00:00:01,100 --> 00:00:11,179
okay so our next presentation is about

00:00:08,120 --> 00:00:15,680
as you can see you're crazy

00:00:11,179 --> 00:00:22,470
microservices our speakers are durable

00:00:15,680 --> 00:00:26,160
material and roughly there cartoonion is

00:00:22,470 --> 00:00:30,570
that correct job thank you okay I'll

00:00:26,160 --> 00:00:33,780
just give you the bio box Yoga Yoga is a

00:00:30,570 --> 00:00:37,230
software engineer working on CD dot OS

00:00:33,780 --> 00:00:39,660
and 12 management platform focusing on

00:00:37,230 --> 00:00:43,160
software-defined infrastructure work

00:00:39,660 --> 00:00:46,379
flows by creating a single pane of glass

00:00:43,160 --> 00:00:50,039
where clouds operations can connect to

00:00:46,379 --> 00:00:55,579
public and private cloud providers such

00:00:50,039 --> 00:01:00,000
as OpenStack whilst I am us and talk and

00:00:55,579 --> 00:01:04,159
finish the environment to a unified rest

00:01:00,000 --> 00:01:07,979
api providing portable TM flexibility

00:01:04,159 --> 00:01:11,040
yoga is also involved in the research of

00:01:07,979 --> 00:01:15,200
different techniques and tools that can

00:01:11,040 --> 00:01:17,909
utilize to improve development adulti

00:01:15,200 --> 00:01:21,920
techniques from the start of

00:01:17,909 --> 00:01:25,320
methodologies and tools like JIRA get

00:01:21,920 --> 00:01:28,560
jinkies and proper are you spies on

00:01:25,320 --> 00:01:32,490
daily basis which allows for small

00:01:28,560 --> 00:01:35,250
iterations to be performed on each

00:01:32,490 --> 00:01:40,799
individual microservice to move been

00:01:35,250 --> 00:01:43,710
delivered to SDI sex ed pipeline data

00:01:40,799 --> 00:01:47,100
from the feedback group of holding

00:01:43,710 --> 00:01:50,850
measuring and the regus then evaluated

00:01:47,100 --> 00:01:54,119
without snow in focus and improve the

00:01:50,850 --> 00:01:59,820
product development lifecycle on this

00:01:54,119 --> 00:02:03,469
stair time he preserves now rafi is an

00:01:59,820 --> 00:02:04,659
adaptable for construct engineer rules

00:02:03,469 --> 00:02:06,969
changes

00:02:04,659 --> 00:02:10,750
possibilities include working to improve

00:02:06,969 --> 00:02:15,040
and develop the front end UI and UX of

00:02:10,750 --> 00:02:19,330
CD dot OS using javascript and work

00:02:15,040 --> 00:02:22,420
players and note the jas while also

00:02:19,330 --> 00:02:26,980
adding functionality to be back-end API

00:02:22,420 --> 00:02:29,890
and database using java and mysql we

00:02:26,980 --> 00:02:32,830
won't swallow early wars with OpenStack

00:02:29,890 --> 00:02:37,329
CloudStack docker and Amazon Web

00:02:32,830 --> 00:02:42,069
Services to normalize their future sets

00:02:37,329 --> 00:02:46,269
to a coming easy to use UI and set of

00:02:42,069 --> 00:02:50,319
api's most recently he has been working

00:02:46,269 --> 00:02:53,110
on a new service catalogue platform with

00:02:50,319 --> 00:02:57,040
the intended to provide a solution to

00:02:53,110 --> 00:03:00,250
the company complications of the point

00:02:57,040 --> 00:03:05,459
complex applications on various cloud

00:03:00,250 --> 00:03:11,260
providers in the spare time right e

00:03:05,459 --> 00:03:13,480
experiment experiment with new and

00:03:11,260 --> 00:03:16,000
upcoming technologies to better

00:03:13,480 --> 00:03:19,959
understand them and determine if they

00:03:16,000 --> 00:03:22,690
may be useful a side project have led

00:03:19,959 --> 00:03:26,829
him to study more about daughter and the

00:03:22,690 --> 00:03:30,489
usefulness of centralization in both

00:03:26,829 --> 00:03:35,609
development and production scenarios

00:03:30,489 --> 00:03:35,609
please welcome Iago and

00:03:38,870 --> 00:03:49,140
thank you thanks for coming to our talk

00:03:44,720 --> 00:03:50,910
now that you know my whole life story we

00:03:49,140 --> 00:03:55,770
can start talking about docker izing

00:03:50,910 --> 00:03:57,270
microservices yoga and I are both recent

00:03:55,770 --> 00:04:00,000
graduates from the BSD program here at

00:03:57,270 --> 00:04:06,570
Seneca I see some familiar faces some

00:04:00,000 --> 00:04:09,600
not so hello today we're going to be

00:04:06,570 --> 00:04:11,280
talking about well the presentation is

00:04:09,600 --> 00:04:13,680
split up into two sections the first

00:04:11,280 --> 00:04:17,880
part is about the fundamentals and a

00:04:13,680 --> 00:04:19,739
little bit of a an overview of what

00:04:17,880 --> 00:04:21,330
docker is and containers will talk about

00:04:19,739 --> 00:04:23,400
monolithic versus microservice

00:04:21,330 --> 00:04:25,430
architectures the types of

00:04:23,400 --> 00:04:29,220
virtualization that's available to us

00:04:25,430 --> 00:04:33,750
the history of containers docker what it

00:04:29,220 --> 00:04:36,510
is why we would use it we'll talk

00:04:33,750 --> 00:04:38,610
briefly about cloud dynamics CDOs which

00:04:36,510 --> 00:04:41,250
is our current product that we're

00:04:38,610 --> 00:04:44,520
working on and I'll briefly mention the

00:04:41,250 --> 00:04:46,470
12 factor app which I'll detail in a few

00:04:44,520 --> 00:04:49,320
minutes second half is going to be more

00:04:46,470 --> 00:04:51,690
about the actual act of docker izing

00:04:49,320 --> 00:04:53,070
your application so we'll talk about

00:04:51,690 --> 00:04:56,340
preparing for dr eyes in your

00:04:53,070 --> 00:04:58,530
application what docker images are the

00:04:56,340 --> 00:05:01,290
complexities of them optimizing those

00:04:58,530 --> 00:05:03,930
images the ins and outs of docker

00:05:01,290 --> 00:05:05,730
networking the docker pipeline for

00:05:03,930 --> 00:05:08,370
continuous integration and continuous to

00:05:05,730 --> 00:05:13,919
play deployment and then finally some

00:05:08,370 --> 00:05:16,740
tips on running docker and production so

00:05:13,919 --> 00:05:18,630
to get started I'm not because we're not

00:05:16,740 --> 00:05:20,760
sure about the depth of skill sets in

00:05:18,630 --> 00:05:22,770
the audience were just wanted to briefly

00:05:20,760 --> 00:05:24,270
make sure we're on allness all on the

00:05:22,770 --> 00:05:27,270
same page about virtualization and cloud

00:05:24,270 --> 00:05:28,919
computing so when we say virtualization

00:05:27,270 --> 00:05:30,600
were referring to the creation of a

00:05:28,919 --> 00:05:34,410
virtual machine that acts like it's a

00:05:30,600 --> 00:05:36,120
real computer it it increases the

00:05:34,410 --> 00:05:37,860
productivity of your hardware because

00:05:36,120 --> 00:05:40,470
instead of running one application on

00:05:37,860 --> 00:05:42,330
each box you're running potentially

00:05:40,470 --> 00:05:44,640
hundreds of them and it's used

00:05:42,330 --> 00:05:46,510
extensively in organizations and even

00:05:44,640 --> 00:05:50,920
institutions like Seneca

00:05:46,510 --> 00:05:52,750
cloud computing is a little bit of a it

00:05:50,920 --> 00:05:54,430
builds on top of virtualization we hear

00:05:52,750 --> 00:05:56,350
a lot about cloud what is cloud it's

00:05:54,430 --> 00:05:58,000
just this thing in the sky but it is

00:05:56,350 --> 00:05:59,620
really just a layer on top of

00:05:58,000 --> 00:06:02,200
virtualization that enables on-demand

00:05:59,620 --> 00:06:07,570
access to a shared pool of resources and

00:06:02,200 --> 00:06:09,460
it's primarily used to enable developers

00:06:07,570 --> 00:06:11,350
and you know operations to focus on

00:06:09,460 --> 00:06:13,540
delivering a product rather than having

00:06:11,350 --> 00:06:18,640
to deal with infrastructure complexities

00:06:13,540 --> 00:06:19,750
and owning your own hardware so to

00:06:18,640 --> 00:06:21,400
understand what docker izing

00:06:19,750 --> 00:06:23,950
microservices even means we first have

00:06:21,400 --> 00:06:25,660
to understand what the term is my

00:06:23,950 --> 00:06:28,870
monolithic and micro service

00:06:25,660 --> 00:06:30,760
architecture is even mean monolithic

00:06:28,870 --> 00:06:34,480
application monolithic application

00:06:30,760 --> 00:06:37,720
structures are referred to one cohesive

00:06:34,480 --> 00:06:40,030
unit of code that's sharing the memory

00:06:37,720 --> 00:06:41,680
space and resources and all the

00:06:40,030 --> 00:06:44,200
different components are working

00:06:41,680 --> 00:06:46,810
together in a fairly tightly coupled

00:06:44,200 --> 00:06:49,180
manner an example of this would be an

00:06:46,810 --> 00:06:51,610
asp.net web forms application where the

00:06:49,180 --> 00:06:53,410
you server delivers the UI and then you

00:06:51,610 --> 00:06:55,120
have with all the business logic tied in

00:06:53,410 --> 00:06:58,240
with the application there's not a lot

00:06:55,120 --> 00:07:00,580
of separation of purposes the benefits

00:06:58,240 --> 00:07:01,990
of monolithic applications are that the

00:07:00,580 --> 00:07:03,330
different components it's really easy

00:07:01,990 --> 00:07:06,250
for them to communicate with each other

00:07:03,330 --> 00:07:08,460
if Billy needs access to user data it's

00:07:06,250 --> 00:07:10,960
right there and vice versa and

00:07:08,460 --> 00:07:14,950
potentially it could perform better

00:07:10,960 --> 00:07:17,440
because on shared memory accesses a lot

00:07:14,950 --> 00:07:19,570
more efficient than inter process

00:07:17,440 --> 00:07:23,080
communication though it's a bit of a

00:07:19,570 --> 00:07:24,940
debatable topic at this point the

00:07:23,080 --> 00:07:26,590
downsides of monolithic applications is

00:07:24,940 --> 00:07:28,750
that because it's so easy for those

00:07:26,590 --> 00:07:31,660
components to talk to each other it

00:07:28,750 --> 00:07:34,840
becomes tightly coupled so there's no

00:07:31,660 --> 00:07:36,280
reason for user the user component of

00:07:34,840 --> 00:07:38,200
the application to have references to

00:07:36,280 --> 00:07:40,330
building or vice versa but on often

00:07:38,200 --> 00:07:43,600
cases because it's there we end up

00:07:40,330 --> 00:07:45,370
coding it in that way and that can make

00:07:43,600 --> 00:07:47,410
it difficult to scale because if one

00:07:45,370 --> 00:07:51,540
server one component of your application

00:07:47,410 --> 00:07:54,450
is only getting hit one time per session

00:07:51,540 --> 00:07:56,280
access meanwhile your building is being

00:07:54,450 --> 00:07:58,080
hit multiple times a second because it's

00:07:56,280 --> 00:07:59,760
it's counting all your resources that

00:07:58,080 --> 00:08:01,740
you're using which one would you rather

00:07:59,760 --> 00:08:02,940
scale you don't want to scale both of

00:08:01,740 --> 00:08:04,440
them at the same time it's a waste of

00:08:02,940 --> 00:08:06,420
resources but with monolithic

00:08:04,440 --> 00:08:10,770
applications you get either all of them

00:08:06,420 --> 00:08:13,530
or none of them with micro service

00:08:10,770 --> 00:08:16,290
applications you have a lot of smaller

00:08:13,530 --> 00:08:18,360
independent applications that have their

00:08:16,290 --> 00:08:20,240
own memory space and potentially even

00:08:18,360 --> 00:08:22,410
running on completely separate machines

00:08:20,240 --> 00:08:24,600
the benefits of that is that you have

00:08:22,410 --> 00:08:27,300
improved application organization so in

00:08:24,600 --> 00:08:31,170
a lot of cases you have a service that

00:08:27,300 --> 00:08:33,630
just does one job if you have a proper

00:08:31,170 --> 00:08:35,490
micro service organisation hierarchy

00:08:33,630 --> 00:08:38,330
then you'll have that service doing one

00:08:35,490 --> 00:08:42,140
job you know that it does that job and

00:08:38,330 --> 00:08:44,490
subsequently you can scale that

00:08:42,140 --> 00:08:46,620
application independently of all the

00:08:44,490 --> 00:08:49,830
other ones so you can make better use of

00:08:46,620 --> 00:08:51,390
all your hardware resources because now

00:08:49,830 --> 00:08:53,280
you don't have to scale all these things

00:08:51,390 --> 00:08:55,020
that and all that extra overhead along

00:08:53,280 --> 00:08:57,270
with it that thing that only gets hit

00:08:55,020 --> 00:08:59,070
one time per session leave it there it's

00:08:57,270 --> 00:09:01,620
only going to get hit one time billing

00:08:59,070 --> 00:09:04,920
or whatever other resource you have to

00:09:01,620 --> 00:09:07,290
scale it up and it will and it will make

00:09:04,920 --> 00:09:08,490
better use of your hardware the

00:09:07,290 --> 00:09:11,070
downsides of the micro service

00:09:08,490 --> 00:09:12,780
architecture are not really a downfall

00:09:11,070 --> 00:09:14,840
of the architecture itself it's more

00:09:12,780 --> 00:09:18,390
that when you migrate from a monolithic

00:09:14,840 --> 00:09:21,510
application you end up with potentially

00:09:18,390 --> 00:09:23,130
having cross relating components reveal

00:09:21,510 --> 00:09:24,840
themselves that you didn't know you had

00:09:23,130 --> 00:09:28,470
before and that can increase the scope

00:09:24,840 --> 00:09:31,320
of actually getting that migration done

00:09:28,470 --> 00:09:33,390
on time and correctly and potentially

00:09:31,320 --> 00:09:35,820
you could end up with the very messy

00:09:33,390 --> 00:09:37,110
code base because if you if you go a

00:09:35,820 --> 00:09:38,640
little bit too ahead of yourself and you

00:09:37,110 --> 00:09:39,990
end up with hundreds of services then

00:09:38,640 --> 00:09:41,730
it's not any better than a monolithic

00:09:39,990 --> 00:09:46,290
application at that point you don't know

00:09:41,730 --> 00:09:49,430
where anything is I want to talk briefly

00:09:46,290 --> 00:09:54,110
about three types of virtualization

00:09:49,430 --> 00:09:54,110
hardware platform and operating system

00:09:54,350 --> 00:09:59,370
hardware virtualization is basically a

00:09:57,690 --> 00:10:00,780
virtual machine if you run a virtual box

00:09:59,370 --> 00:10:03,150
on your machine running Windows or Linux

00:10:00,780 --> 00:10:05,160
you're running a virtual machine you

00:10:03,150 --> 00:10:09,480
give it a dedicated set of resources

00:10:05,160 --> 00:10:10,920
like CPU memory disk and that guest OS

00:10:09,480 --> 00:10:12,360
thinks it's running on dedicated

00:10:10,920 --> 00:10:14,250
hardware it has no idea it's being

00:10:12,360 --> 00:10:15,810
virtualized and that's really good for

00:10:14,250 --> 00:10:17,850
running legacy software because

00:10:15,810 --> 00:10:20,699
sometimes it's not worth the effort of

00:10:17,850 --> 00:10:24,720
bringing old software over to new modern

00:10:20,699 --> 00:10:27,600
operating systems platform level of

00:10:24,720 --> 00:10:28,740
virtualization is done on it is also

00:10:27,600 --> 00:10:30,750
known as application level

00:10:28,740 --> 00:10:33,990
virtualization because it allows

00:10:30,750 --> 00:10:36,269
developers to focus on their software

00:10:33,990 --> 00:10:38,310
and not how to deploy it or the hardware

00:10:36,269 --> 00:10:39,930
it needs to run on it abstracts away all

00:10:38,310 --> 00:10:41,790
the hardware and you say I want to

00:10:39,930 --> 00:10:44,279
deploy my application do whatever it

00:10:41,790 --> 00:10:45,930
takes to make it happen sure there's

00:10:44,279 --> 00:10:47,579
examples of that like open shift in bit

00:10:45,930 --> 00:10:49,670
nami if you're not familiar you could

00:10:47,579 --> 00:10:51,899
just go kind of one click and you have

00:10:49,670 --> 00:10:53,519
WordPress or any application that you

00:10:51,899 --> 00:10:54,720
want to deploy and it's just up and

00:10:53,519 --> 00:10:57,649
running you don't have to worry about

00:10:54,720 --> 00:11:00,180
networking and all these things

00:10:57,649 --> 00:11:02,250
operating system-level virtualization is

00:11:00,180 --> 00:11:03,689
container based and the rest of this

00:11:02,250 --> 00:11:07,319
presentation is kind of based off of

00:11:03,689 --> 00:11:09,569
this type of virtualization each

00:11:07,319 --> 00:11:12,480
container share is a single kernel which

00:11:09,569 --> 00:11:13,680
makes it really efficient on hardware

00:11:12,480 --> 00:11:15,839
resources because you don't get the

00:11:13,680 --> 00:11:17,490
overhead of every single application you

00:11:15,839 --> 00:11:18,810
want to launch having its own set of

00:11:17,490 --> 00:11:20,970
resources that comes along as

00:11:18,810 --> 00:11:24,870
dependencies for no reason you already

00:11:20,970 --> 00:11:27,420
have it so it just uses it before we get

00:11:24,870 --> 00:11:29,880
too much into containers and docker a

00:11:27,420 --> 00:11:32,639
brief history of containers and how we

00:11:29,880 --> 00:11:34,980
even got here in the first place way

00:11:32,639 --> 00:11:38,130
back in nineteen eighty-two way back I

00:11:34,980 --> 00:11:41,430
guess linux came with a feature called

00:11:38,130 --> 00:11:42,839
schrute or chroot which changed the

00:11:41,430 --> 00:11:44,699
apparent root directory of the current

00:11:42,839 --> 00:11:46,740
process you're in and his child

00:11:44,699 --> 00:11:49,800
processes and effectively made the rest

00:11:46,740 --> 00:11:51,509
of the filesystem hidden that modified

00:11:49,800 --> 00:11:54,000
environment is called a Schrute jail and

00:11:51,509 --> 00:11:55,439
if you're a Seneca student you're

00:11:54,000 --> 00:11:57,689
probably experiencing something similar

00:11:55,439 --> 00:12:00,509
to this when you log into matrix where

00:11:57,689 --> 00:12:02,100
your user account is your route and you

00:12:00,509 --> 00:12:04,319
can't really leave that area because

00:12:02,100 --> 00:12:07,040
that's that's area late you've been

00:12:04,319 --> 00:12:07,040
given access to

00:12:11,769 --> 00:12:20,060
that's a good point the neck well the

00:12:17,240 --> 00:12:21,800
next point I think this was more on I

00:12:20,060 --> 00:12:23,480
don't have an answer for to you actually

00:12:21,800 --> 00:12:25,970
it's a good point because the next slide

00:12:23,480 --> 00:12:27,620
actually refers to BS details which is

00:12:25,970 --> 00:12:29,120
the next iteration on top of that which

00:12:27,620 --> 00:12:30,889
partitioned the system into several

00:12:29,120 --> 00:12:33,529
independent mini systems called jails

00:12:30,889 --> 00:12:35,720
and that was different from Schrute in

00:12:33,529 --> 00:12:38,470
that it actually sandboxed the jailed

00:12:35,720 --> 00:12:41,899
processes so that now actually it is

00:12:38,470 --> 00:12:43,550
isolated whereas on shrewd it was it's

00:12:41,899 --> 00:12:46,519
not truly isolated it's just the rest of

00:12:43,550 --> 00:12:47,350
the file system was hidden from you and

00:12:46,519 --> 00:12:49,639
that serves three purposes

00:12:47,350 --> 00:12:52,339
virtualization security and ease of

00:12:49,639 --> 00:12:54,980
delegation and he's a delegation in the

00:12:52,339 --> 00:12:57,350
sense that because the jails had limited

00:12:54,980 --> 00:12:59,779
scope you could be you could give access

00:12:57,350 --> 00:13:02,060
to a process to say you had access to

00:12:59,779 --> 00:13:03,860
jail and not worry about it somehow

00:13:02,060 --> 00:13:07,220
gaining superuser access to the rest of

00:13:03,860 --> 00:13:10,220
the system but I'll try to follow up

00:13:07,220 --> 00:13:12,709
with you on that one I'm not following

00:13:10,220 --> 00:13:15,319
that came Solaris zones which just

00:13:12,709 --> 00:13:17,360
another iteration which had zones that

00:13:15,319 --> 00:13:18,800
acted like isolated virtual servers but

00:13:17,360 --> 00:13:21,560
the point I'm trying to make here with

00:13:18,800 --> 00:13:23,029
the history is that we saw that fairly

00:13:21,560 --> 00:13:26,620
early on they tried to solve this

00:13:23,029 --> 00:13:26,620
container based virtualization

00:13:26,740 --> 00:13:32,990
methodology and slowly especially near

00:13:29,569 --> 00:13:35,959
the 2000s we started to see a more of an

00:13:32,990 --> 00:13:37,639
increase in actual focus on developing

00:13:35,959 --> 00:13:40,759
these kinds of tools on the Linux kernel

00:13:37,639 --> 00:13:43,819
and so to developers from google ended

00:13:40,759 --> 00:13:47,290
up creating Linux control groups and on

00:13:43,819 --> 00:13:51,350
top of that namespace isolation which

00:13:47,290 --> 00:13:53,060
our kernel level features so see groups

00:13:51,350 --> 00:13:55,699
for example isolate the system resources

00:13:53,060 --> 00:13:57,560
of a collection of processes and limits

00:13:55,699 --> 00:13:59,839
them and prioritizes the hardware like

00:13:57,560 --> 00:14:02,120
the CPU the disk the memory the network

00:13:59,839 --> 00:14:03,680
and then the namespace isolation will

00:14:02,120 --> 00:14:05,209
take those separate groups of processes

00:14:03,680 --> 00:14:07,639
and make sure that they can't see other

00:14:05,209 --> 00:14:10,819
resources that are running in in other

00:14:07,639 --> 00:14:12,709
groups so those two Linux kernel

00:14:10,819 --> 00:14:16,490
features are you then utilized by docker

00:14:12,709 --> 00:14:20,269
by way of LX c and LX c is just an

00:14:16,490 --> 00:14:21,950
acronym for linux containers the LXE

00:14:20,269 --> 00:14:23,630
combines goes both

00:14:21,950 --> 00:14:26,150
with those tools to provide an isolated

00:14:23,630 --> 00:14:27,980
environment for applications and you can

00:14:26,150 --> 00:14:30,530
view Alexi kind of like an in-between

00:14:27,980 --> 00:14:32,720
between Schrute and a full vm because

00:14:30,530 --> 00:14:35,050
you get almost a full linux kernel

00:14:32,720 --> 00:14:39,260
installation but without the need for

00:14:35,050 --> 00:14:43,700
that Colonel on each container it shares

00:14:39,260 --> 00:14:46,160
one kernel for all of them so now we're

00:14:43,700 --> 00:14:49,580
at docker this was around in 2013 docker

00:14:46,160 --> 00:14:53,240
was released just as a show of hands how

00:14:49,580 --> 00:14:54,890
many of you know about docker ok that's

00:14:53,240 --> 00:14:59,480
good how many of you have actually used

00:14:54,890 --> 00:15:01,010
docker ok just about right and how many

00:14:59,480 --> 00:15:05,030
of you have actually deployed dr. in

00:15:01,010 --> 00:15:07,100
production that's we got one that's more

00:15:05,030 --> 00:15:10,430
than that's one more than I expected ok

00:15:07,100 --> 00:15:13,670
so so that's good that now we know we

00:15:10,430 --> 00:15:14,720
all know why we're here then so for

00:15:13,670 --> 00:15:17,120
those of you who didn't raise your hand

00:15:14,720 --> 00:15:18,740
about knowing about docker docker is an

00:15:17,120 --> 00:15:21,260
open source project that basically takes

00:15:18,740 --> 00:15:23,090
application it automates the deployment

00:15:21,260 --> 00:15:25,220
of applications inside software

00:15:23,090 --> 00:15:27,080
containers so it provides an additional

00:15:25,220 --> 00:15:30,440
layer on top of that operating system

00:15:27,080 --> 00:15:31,820
level of virtualization and the result

00:15:30,440 --> 00:15:34,490
of that is very very lightweight

00:15:31,820 --> 00:15:36,350
containers because of two particular

00:15:34,490 --> 00:15:39,500
features Union file system and

00:15:36,350 --> 00:15:41,450
copy-on-write yoga is going to go a

00:15:39,500 --> 00:15:43,340
little bit more into in depth on the

00:15:41,450 --> 00:15:45,530
union file system and copy-on-write but

00:15:43,340 --> 00:15:48,230
just on a high level a union file system

00:15:45,530 --> 00:15:50,720
is a file system that amalgamates all a

00:15:48,230 --> 00:15:53,600
different collection of different file

00:15:50,720 --> 00:15:55,520
systems into one logical file system and

00:15:53,600 --> 00:15:57,530
it does so by building layers of file

00:15:55,520 --> 00:16:00,050
systems on top of each other with just

00:15:57,530 --> 00:16:02,330
enough libraries and binaries that it

00:16:00,050 --> 00:16:06,650
needs to run your application no more

00:16:02,330 --> 00:16:09,710
and each container that has similar

00:16:06,650 --> 00:16:12,020
layers shares them until the point where

00:16:09,710 --> 00:16:13,640
copy-on-write kicks in where you need to

00:16:12,020 --> 00:16:16,250
make a change to one of those layers it

00:16:13,640 --> 00:16:17,900
will make a copy of it locally and then

00:16:16,250 --> 00:16:20,090
you kind of treat that as a new layer

00:16:17,900 --> 00:16:22,100
but until that point it shares them so

00:16:20,090 --> 00:16:24,920
when you have three containers but they

00:16:22,100 --> 00:16:26,840
are all based on ubuntu linux you don't

00:16:24,920 --> 00:16:30,100
get 30 copies of Ubuntu Linux it shares

00:16:26,840 --> 00:16:30,100
all those kernels together

00:16:31,069 --> 00:16:35,399
so why containers as opposed to just

00:16:33,720 --> 00:16:38,490
sticking with virtual machines and

00:16:35,399 --> 00:16:40,920
platform virtualization hardware

00:16:38,490 --> 00:16:43,470
virtualization is limited on one end in

00:16:40,920 --> 00:16:46,410
that virtual machines are not designed

00:16:43,470 --> 00:16:48,689
to share hardware so sure hardware

00:16:46,410 --> 00:16:50,550
resources rather so when you give it one

00:16:48,689 --> 00:16:51,990
gig of ram it takes one gig of ram and

00:16:50,550 --> 00:16:53,879
it's not going to give that back until

00:16:51,990 --> 00:16:55,529
you shut it down whether the application

00:16:53,879 --> 00:16:59,040
inside needs it or not or ends of

00:16:55,529 --> 00:17:00,899
utilizing it and the hypervisor itself

00:16:59,040 --> 00:17:04,380
consumes about ten to fifteen percent of

00:17:00,899 --> 00:17:05,909
your machine resources so you're really

00:17:04,380 --> 00:17:07,169
giving a lot of way just to run a

00:17:05,909 --> 00:17:09,329
virtual machine and you're getting a way

00:17:07,169 --> 00:17:10,649
too much overhead on the other side of

00:17:09,329 --> 00:17:13,049
the limitation spectrum you have

00:17:10,649 --> 00:17:14,850
platform virtualization which is too

00:17:13,049 --> 00:17:17,059
simplistic for a lot of complicated

00:17:14,850 --> 00:17:20,339
applications especially microservices

00:17:17,059 --> 00:17:22,620
because at that point it's really easy

00:17:20,339 --> 00:17:24,689
to deploy ok I want WordPress but beyond

00:17:22,620 --> 00:17:26,939
that it gets complicated and very hazy

00:17:24,689 --> 00:17:30,059
when you want to do enter component

00:17:26,939 --> 00:17:32,549
communication ah operating system-level

00:17:30,059 --> 00:17:35,100
virtualization maximizes tendency and

00:17:32,549 --> 00:17:36,899
performance and that's because you will

00:17:35,100 --> 00:17:42,630
take all the unused resources and

00:17:36,899 --> 00:17:44,820
reallocate it to those who need it so

00:17:42,630 --> 00:17:48,210
then why darker specifically as opposed

00:17:44,820 --> 00:17:49,919
to just using Linux containers talker is

00:17:48,210 --> 00:17:52,580
a unique feature in that you can encode

00:17:49,919 --> 00:17:54,720
the development and deployment processes

00:17:52,580 --> 00:17:57,659
practices do directly into the image

00:17:54,720 --> 00:17:59,010
like a blueprint and that's handy for

00:17:57,659 --> 00:18:01,590
developers because then I could use the

00:17:59,010 --> 00:18:03,779
same image for development as I do in

00:18:01,590 --> 00:18:05,549
production and then I can focus on what

00:18:03,779 --> 00:18:08,159
I actually want to do which is develop

00:18:05,549 --> 00:18:10,350
as opposed to you know operations and

00:18:08,159 --> 00:18:12,029
infrastructure which me and Iago have

00:18:10,350 --> 00:18:13,950
way to know way too much about

00:18:12,029 --> 00:18:17,510
operations and infrastructure because of

00:18:13,950 --> 00:18:19,559
this for operations it actually

00:18:17,510 --> 00:18:21,480
simplifies the deployment process

00:18:19,559 --> 00:18:24,440
because all the dependencies are baked

00:18:21,480 --> 00:18:26,760
in you just have to deploy the image and

00:18:24,440 --> 00:18:29,820
at that point you can also argue that

00:18:26,760 --> 00:18:31,380
there's no more well my work on my

00:18:29,820 --> 00:18:34,409
machine and then the developer walks

00:18:31,380 --> 00:18:35,940
away kind of thing yeah if it worked on

00:18:34,409 --> 00:18:37,919
the developers machine it will work on

00:18:35,940 --> 00:18:39,360
the production because the environment

00:18:37,919 --> 00:18:40,590
the application is running in is the

00:18:39,360 --> 00:18:42,570
same

00:18:40,590 --> 00:18:44,190
but the most important feature is

00:18:42,570 --> 00:18:48,090
probably that you have sub second start

00:18:44,190 --> 00:18:50,190
time so docker images are ephemeral and

00:18:48,090 --> 00:18:51,690
Diago is going to go into more into what

00:18:50,190 --> 00:18:53,789
that means later but basically it means

00:18:51,690 --> 00:18:55,919
the image is stateless the container is

00:18:53,789 --> 00:18:58,980
stateless so you can start up and start

00:18:55,919 --> 00:19:00,600
stop docker containers no problem so for

00:18:58,980 --> 00:19:03,600
operations if there's a component of the

00:19:00,600 --> 00:19:05,279
application that's messing up you just

00:19:03,600 --> 00:19:07,710
take it off put another one in within

00:19:05,279 --> 00:19:09,360
half a second no one even know knew that

00:19:07,710 --> 00:19:11,580
you brought a service down and back up

00:19:09,360 --> 00:19:13,169
it's really good for you know trying to

00:19:11,580 --> 00:19:16,380
get assuming there's no bugs in your

00:19:13,169 --> 00:19:20,549
code you can get the production back up

00:19:16,380 --> 00:19:23,220
and running if something hits a wall so

00:19:20,549 --> 00:19:27,419
to briefly talk about sedo's or CDOs

00:19:23,220 --> 00:19:28,919
depending on your inclination a cloud

00:19:27,419 --> 00:19:30,960
dynamics for developing a cloud

00:19:28,919 --> 00:19:33,059
management platform called CDOs which

00:19:30,960 --> 00:19:38,240
basically is designed to simplify public

00:19:33,059 --> 00:19:41,039
and private cloud platforms into one

00:19:38,240 --> 00:19:44,159
unified platform so we have OpenStack

00:19:41,039 --> 00:19:46,440
cloudstack docker AWS and a couple of

00:19:44,159 --> 00:19:48,000
more on down the pipe it allows you to

00:19:46,440 --> 00:19:49,799
build the ploy monitor and manage your

00:19:48,000 --> 00:19:51,240
cloud provider your cloud environment

00:19:49,799 --> 00:19:54,029
through a single source which would be

00:19:51,240 --> 00:19:57,659
CDOs and in addition to that it provides

00:19:54,029 --> 00:20:00,659
a full the unified REST API so if you're

00:19:57,659 --> 00:20:03,480
a developer who wants to talk to AWS and

00:20:00,659 --> 00:20:05,850
OpenStack but you don't want to have

00:20:03,480 --> 00:20:07,980
multiple paths of code just to talk to

00:20:05,850 --> 00:20:09,630
different providers this API would allow

00:20:07,980 --> 00:20:10,890
you to deal with all those complicated

00:20:09,630 --> 00:20:13,919
mappings because we've already done it

00:20:10,890 --> 00:20:15,090
for you we've also added on user

00:20:13,919 --> 00:20:16,860
management with two factor

00:20:15,090 --> 00:20:19,110
authentication building and usage

00:20:16,860 --> 00:20:21,080
reports service catalogs which are

00:20:19,110 --> 00:20:23,610
basically one-click deployment of

00:20:21,080 --> 00:20:25,230
applications and theme management and

00:20:23,610 --> 00:20:27,960
white labeling so if you want to be a

00:20:25,230 --> 00:20:29,190
reseller and give this as a solution to

00:20:27,960 --> 00:20:31,950
your clients there's also that

00:20:29,190 --> 00:20:34,740
capability the reason why I'm mentioning

00:20:31,950 --> 00:20:37,320
this product is because we too had a

00:20:34,740 --> 00:20:41,789
monolithic application structure where

00:20:37,320 --> 00:20:44,039
it was just one blob of code and it

00:20:41,789 --> 00:20:45,330
would crash and if it crashed the whole

00:20:44,039 --> 00:20:47,370
thing would go down and then it would

00:20:45,330 --> 00:20:49,679
take time to get a new patch up and

00:20:47,370 --> 00:20:51,450
running transmit the build to the server

00:20:49,679 --> 00:20:53,789
get it up and running the down times

00:20:51,450 --> 00:20:55,859
were horrendous it just wasn't working

00:20:53,789 --> 00:20:57,779
now that's why we even started on this

00:20:55,859 --> 00:20:58,919
endeavor for microservices because now

00:20:57,779 --> 00:21:03,570
we ended up with something more like

00:20:58,919 --> 00:21:06,299
this which each individual job has a

00:21:03,570 --> 00:21:10,710
service and if it has problems it may go

00:21:06,299 --> 00:21:12,509
down we may fix it or update it or work

00:21:10,710 --> 00:21:16,080
on it but the rest of the application

00:21:12,509 --> 00:21:17,789
stands alone and it makes things easier

00:21:16,080 --> 00:21:19,710
to update as well so we could iterative

00:21:17,789 --> 00:21:21,869
iteratively develop on top of things

00:21:19,710 --> 00:21:23,309
while it's on production because we

00:21:21,869 --> 00:21:25,529
could just take one single component

00:21:23,309 --> 00:21:28,679
bring a new one in and not there's no

00:21:25,529 --> 00:21:30,659
downtime it also makes it easier to work

00:21:28,679 --> 00:21:32,309
with other developers without stepping

00:21:30,659 --> 00:21:34,049
on each other's toes because if I'm

00:21:32,309 --> 00:21:35,519
working on one component and someone

00:21:34,049 --> 00:21:36,989
else is working on another we don't have

00:21:35,519 --> 00:21:38,519
merge conflicts or I don't have to pull

00:21:36,989 --> 00:21:43,619
his changes before I commit it makes

00:21:38,519 --> 00:21:45,330
things a lot easier so the final thing I

00:21:43,619 --> 00:21:47,849
want to mention is the 12 factor app

00:21:45,330 --> 00:21:50,159
which is a methodology for building

00:21:47,849 --> 00:21:52,169
modern cloud applications I'm not going

00:21:50,159 --> 00:21:53,849
to go into too many details here if you

00:21:52,169 --> 00:21:57,210
want more information the URLs right

00:21:53,849 --> 00:21:59,309
there 12 factor net but basically if

00:21:57,210 --> 00:22:01,499
you're developing a cloud application

00:21:59,309 --> 00:22:03,720
you should be following these principles

00:22:01,499 --> 00:22:05,249
and the one we found particularly useful

00:22:03,720 --> 00:22:07,859
was the third factor which was

00:22:05,249 --> 00:22:10,859
configuration we used to use Jason

00:22:07,859 --> 00:22:12,960
config files we're depending on if you

00:22:10,859 --> 00:22:15,779
run develop development QA or production

00:22:12,960 --> 00:22:17,429
we would tweeted string and then it

00:22:15,779 --> 00:22:20,070
would do different things for for debug

00:22:17,429 --> 00:22:21,749
mode or whatnot when we went to docker

00:22:20,070 --> 00:22:23,970
images because those images are

00:22:21,749 --> 00:22:26,039
immutable are trees they can't be

00:22:23,970 --> 00:22:27,509
changed the configuration had to be

00:22:26,039 --> 00:22:29,820
injected through environment variables

00:22:27,509 --> 00:22:32,489
which is exactly what the 12 factor app

00:22:29,820 --> 00:22:34,049
suggests if you have the environment

00:22:32,489 --> 00:22:35,729
specific changes you should do it on the

00:22:34,049 --> 00:22:37,799
environment variables because then that

00:22:35,729 --> 00:22:40,529
way your code is the same no matter

00:22:37,799 --> 00:22:42,210
where it's deployed and just if there

00:22:40,529 --> 00:22:45,119
has to be some variations is done on the

00:22:42,210 --> 00:22:48,629
environment variable level just a tip in

00:22:45,119 --> 00:22:49,889
case you want it to go live with one so

00:22:48,629 --> 00:22:52,320
at this point I want to pass it off to

00:22:49,889 --> 00:22:56,540
do go we will talk about actually dr.

00:22:52,320 --> 00:23:02,250
izing your application okay hello hello

00:22:56,540 --> 00:23:04,800
right Thank You Roxy okay so it comes

00:23:02,250 --> 00:23:07,260
time to add our cries replication a

00:23:04,800 --> 00:23:09,360
couple of vinyl concepts that's it's

00:23:07,260 --> 00:23:11,100
important to understand first of all

00:23:09,360 --> 00:23:13,050
that graphic match before the container

00:23:11,100 --> 00:23:15,420
should be ephemeral meaning that they

00:23:13,050 --> 00:23:17,040
should be transient so the application

00:23:15,420 --> 00:23:18,960
shouldn't store data on the container

00:23:17,040 --> 00:23:21,480
itself it should you know start the data

00:23:18,960 --> 00:23:24,330
on a database for example so if the end

00:23:21,480 --> 00:23:26,100
users connecting to our application in a

00:23:24,330 --> 00:23:28,320
cluster mode I should be able to remove

00:23:26,100 --> 00:23:31,440
a container at anyone and that shooting

00:23:28,320 --> 00:23:33,480
impact end user the next point which is

00:23:31,440 --> 00:23:35,130
crucial is that a container is the same

00:23:33,480 --> 00:23:36,960
as a process so if you look at the

00:23:35,130 --> 00:23:39,870
darker host where all the containers or

00:23:36,960 --> 00:23:41,750
no run you will see that each container

00:23:39,870 --> 00:23:44,580
has you know individual process and that

00:23:41,750 --> 00:23:45,960
dino brings to the other point which the

00:23:44,580 --> 00:23:48,000
container should only have one process

00:23:45,960 --> 00:23:49,800
in the foreground that's not a technical

00:23:48,000 --> 00:23:52,020
limitation but more of a community

00:23:49,800 --> 00:23:53,610
preference and that like time back to

00:23:52,020 --> 00:23:56,100
the monolithic versus you know

00:23:53,610 --> 00:23:57,810
microservers architecture if you keep

00:23:56,100 --> 00:23:59,790
multiple you know processing a single

00:23:57,810 --> 00:24:01,590
container wedding complexity to likes

00:23:59,790 --> 00:24:03,570
harder to maintain and then I know

00:24:01,590 --> 00:24:06,210
becomes really bad so we really want to

00:24:03,570 --> 00:24:07,530
separate that now can give an example

00:24:06,210 --> 00:24:10,350
you know when we were pouring new seed

00:24:07,530 --> 00:24:13,500
us to run on docker the billing service

00:24:10,350 --> 00:24:15,810
was an only both an HTTP interface and

00:24:13,500 --> 00:24:17,460
had the schedule Outen so then he came a

00:24:15,810 --> 00:24:21,150
time we had to know scale horizontally

00:24:17,460 --> 00:24:24,270
the billing service so my concept lines

00:24:21,150 --> 00:24:26,160
the schedule got I know skilled as well

00:24:24,270 --> 00:24:27,660
but the schedule wasn't no building to

00:24:26,160 --> 00:24:29,700
run a cluster mode Stanley had some

00:24:27,660 --> 00:24:31,620
problems so if you follow the principle

00:24:29,700 --> 00:24:33,000
and you keep one single service running

00:24:31,620 --> 00:24:36,030
in a single container you can avoid

00:24:33,000 --> 00:24:37,770
those complications if however that's

00:24:36,030 --> 00:24:39,600
not a possibility for you you have the

00:24:37,770 --> 00:24:41,550
application you can't modify it then

00:24:39,600 --> 00:24:43,530
there are some workarounds so the first

00:24:41,550 --> 00:24:46,110
workaround you can use a supervisor

00:24:43,530 --> 00:24:48,180
which are in the foreground inside the

00:24:46,110 --> 00:24:50,670
container and then spawns you know

00:24:48,180 --> 00:24:52,620
multiple demons in the background the

00:24:50,670 --> 00:24:54,720
next option is I know first just use

00:24:52,620 --> 00:24:56,010
Alexi you got to know the same benefits

00:24:54,720 --> 00:24:57,990
you know a stalker because you know runs

00:24:56,010 --> 00:24:59,880
on containers but then you don't have I

00:24:57,990 --> 00:25:04,560
know the one process limitation you guys

00:24:59,880 --> 00:25:06,180
do a full OS you to play with so what

00:25:04,560 --> 00:25:09,060
about docker images so images are there

00:25:06,180 --> 00:25:11,740
the basis for containers

00:25:09,060 --> 00:25:14,110
so rough you mentioned before about you

00:25:11,740 --> 00:25:15,700
know layers so I know docker uses the

00:25:14,110 --> 00:25:17,860
Union file system which is a combination

00:25:15,700 --> 00:25:20,140
of files and folders which they call on

00:25:17,860 --> 00:25:22,780
branches each branch can have a rib or a

00:25:20,140 --> 00:25:25,330
read/write permission so darker has a

00:25:22,780 --> 00:25:28,000
variety of storage backend provides it

00:25:25,330 --> 00:25:30,670
works with the a ufs the RTF fast over

00:25:28,000 --> 00:25:33,400
last the fs you name it so each storage

00:25:30,670 --> 00:25:35,290
driver has a different use case so when

00:25:33,400 --> 00:25:36,910
you deploy blocking production you could

00:25:35,290 --> 00:25:38,260
you know try to achieve more advancing

00:25:36,910 --> 00:25:40,750
so then you choose a different driver

00:25:38,260 --> 00:25:43,060
where we want more performance there's a

00:25:40,750 --> 00:25:45,160
really good talk about that from Jerome

00:25:43,060 --> 00:25:46,720
you know dr. developer and then we're

00:25:45,160 --> 00:25:50,770
going to link on the presentation I

00:25:46,720 --> 00:25:52,510
don't notes like on so the image itself

00:25:50,770 --> 00:25:53,620
is the you know the basis that you can

00:25:52,510 --> 00:25:55,240
run the container but then how do you

00:25:53,620 --> 00:25:58,180
create an image you need a docker file

00:25:55,240 --> 00:26:00,010
so docker file is just turn or set of

00:25:58,180 --> 00:26:01,840
instructions so even before talking

00:26:00,010 --> 00:26:03,670
about the instructions well one point

00:26:01,840 --> 00:26:05,110
the one I want to make is that you can

00:26:03,670 --> 00:26:06,970
think about you know the image layers

00:26:05,110 --> 00:26:09,250
the same way is takan you think about

00:26:06,970 --> 00:26:11,470
get so we'd get you track in your

00:26:09,250 --> 00:26:12,760
application source code with Dino image

00:26:11,470 --> 00:26:14,740
layers you're going to be tracking the

00:26:12,760 --> 00:26:18,040
application stall steps this is the same

00:26:14,740 --> 00:26:19,630
concept so the back our final

00:26:18,040 --> 00:26:21,040
instructions so there are a bunch of our

00:26:19,630 --> 00:26:22,480
instructions you can use or now in your

00:26:21,040 --> 00:26:24,070
dacha file we're going to be covering

00:26:22,480 --> 00:26:27,130
just you know the four more important

00:26:24,070 --> 00:26:28,660
ones so starting is the front so every

00:26:27,130 --> 00:26:30,670
docker file needs to have a from

00:26:28,660 --> 00:26:33,880
instruction on the top which mainly

00:26:30,670 --> 00:26:35,680
refers which based image to use so if

00:26:33,880 --> 00:26:37,060
you know object oriented programming you

00:26:35,680 --> 00:26:38,470
know you can have a base class and then

00:26:37,060 --> 00:26:40,600
you're going to know extend that base

00:26:38,470 --> 00:26:42,670
class which consequently you're going to

00:26:40,600 --> 00:26:44,440
Herot all the properties that's the same

00:26:42,670 --> 00:26:47,100
concept here you just you inheriting a

00:26:44,440 --> 00:26:50,080
set of instructions from the base image

00:26:47,100 --> 00:26:51,970
next instruction is the run so run you

00:26:50,080 --> 00:26:53,980
can execute some commands to build your

00:26:51,970 --> 00:26:56,080
image so you can do an EPT gackt yum

00:26:53,980 --> 00:26:58,870
install curl whatever you need to do to

00:26:56,080 --> 00:27:00,430
build your application you have copy

00:26:58,870 --> 00:27:01,990
which allows you to copy your

00:27:00,430 --> 00:27:03,730
application source code to inside the

00:27:01,990 --> 00:27:06,130
image and then finally you have the

00:27:03,730 --> 00:27:07,900
command the command defines the entry

00:27:06,130 --> 00:27:10,720
point for application and that ties back

00:27:07,900 --> 00:27:12,880
to I know running one price on the

00:27:10,720 --> 00:27:14,260
foreground per container so in the in

00:27:12,880 --> 00:27:15,640
the beginning when we were just you know

00:27:14,260 --> 00:27:17,860
first you know porting the you know

00:27:15,640 --> 00:27:20,110
microservices to run on docker we just

00:27:17,860 --> 00:27:22,150
grab all the install scripts that were

00:27:20,110 --> 00:27:22,870
for VMS and we just dumped in the docker

00:27:22,150 --> 00:27:24,430
file

00:27:22,870 --> 00:27:26,350
bill damage and then we're trying not to

00:27:24,430 --> 00:27:28,450
run the micro service and then the

00:27:26,350 --> 00:27:30,490
container would start and exit right

00:27:28,450 --> 00:27:32,680
away and then no laughter no scratching

00:27:30,490 --> 00:27:34,990
our heads and try to debug we realize

00:27:32,680 --> 00:27:37,330
that because the vm stall strips were

00:27:34,990 --> 00:27:38,890
running the application as a demon in

00:27:37,330 --> 00:27:40,660
the background which the way we want to

00:27:38,890 --> 00:27:41,950
do it if you run in your application the

00:27:40,660 --> 00:27:44,260
virtual machine which you can t know

00:27:41,950 --> 00:27:45,820
just lock the foreground but in doctors

00:27:44,260 --> 00:27:47,470
the contrary you wanna run the

00:27:45,820 --> 00:27:49,450
application in the foreground if not the

00:27:47,470 --> 00:27:53,050
container won't be inoue in an active

00:27:49,450 --> 00:27:54,910
mode final piece is the image cache so

00:27:53,050 --> 00:27:57,700
that's a very neat feature know from dr.

00:27:54,910 --> 00:28:00,220
so when you build the image from the

00:27:57,700 --> 00:28:03,429
dockerfile what happens is darker looks

00:28:00,220 --> 00:28:06,070
at the from base image creates a new

00:28:03,429 --> 00:28:09,429
container which gives you a rid right I

00:28:06,070 --> 00:28:10,780
no image layer then it executes the

00:28:09,429 --> 00:28:12,820
following instruction inside the

00:28:10,780 --> 00:28:14,710
container and then it commits that into

00:28:12,820 --> 00:28:16,600
a new image and then keeps doing that

00:28:14,710 --> 00:28:18,730
until it doesn't have any more

00:28:16,600 --> 00:28:20,890
instructions in the docker file so that

00:28:18,730 --> 00:28:22,540
allows you to cash all the you know

00:28:20,890 --> 00:28:25,990
instructions you have in your doctor

00:28:22,540 --> 00:28:28,420
file so this image right here kind of

00:28:25,990 --> 00:28:30,220
like you know I know you know visualize

00:28:28,420 --> 00:28:31,450
in the works app in the background so

00:28:30,220 --> 00:28:33,340
you have you know all the storage

00:28:31,450 --> 00:28:34,990
drivers you know as the the bottom layer

00:28:33,340 --> 00:28:36,760
and they don't have a base image and

00:28:34,990 --> 00:28:39,429
then one in structure you know two nyt

00:28:36,760 --> 00:28:41,050
max and then you can make that you have

00:28:39,429 --> 00:28:42,610
another instruction to an Apache and

00:28:41,050 --> 00:28:44,890
then later when you run the container

00:28:42,610 --> 00:28:50,350
it's just a collection of images with

00:28:44,890 --> 00:28:56,290
the read write permission so how about

00:28:50,350 --> 00:28:58,900
creating efficient images the first step

00:28:56,290 --> 00:29:02,710
you want to take is gonna chain commands

00:28:58,900 --> 00:29:05,140
so what you you don't want to do is have

00:29:02,710 --> 00:29:07,450
multiple run instructions so let's say

00:29:05,140 --> 00:29:10,059
you're going to install no dry-ass so it

00:29:07,450 --> 00:29:12,040
first installed w get download the node

00:29:10,059 --> 00:29:14,740
artifacts you want turret and then you

00:29:12,040 --> 00:29:17,110
move around create some legs and then

00:29:14,740 --> 00:29:19,000
you have note however that is creating

00:29:17,110 --> 00:29:20,950
an image layer for each instruction and

00:29:19,000 --> 00:29:22,780
then once that layers committed you

00:29:20,950 --> 00:29:24,880
cannot remove the files that were

00:29:22,780 --> 00:29:27,670
committing to that so I going to end up

00:29:24,880 --> 00:29:30,100
with your image width w get and the

00:29:27,670 --> 00:29:31,960
linux the node.js artifacts which are

00:29:30,100 --> 00:29:34,090
not crucial to run your application and

00:29:31,960 --> 00:29:36,580
and just going to increase the final

00:29:34,090 --> 00:29:38,409
size of the image so

00:29:36,580 --> 00:29:40,659
if you're going to be pushing that image

00:29:38,409 --> 00:29:42,460
over the wire you want to reduce the

00:29:40,659 --> 00:29:43,990
size as much as you can as you know then

00:29:42,460 --> 00:29:47,470
you're going to the gonna introduce some

00:29:43,990 --> 00:29:49,539
line or time penalties so what you do

00:29:47,470 --> 00:29:50,919
want to do you want to combine and chain

00:29:49,539 --> 00:29:52,750
all the commands into a single

00:29:50,919 --> 00:29:55,210
instruction the first install w got

00:29:52,750 --> 00:29:57,279
download the notes artifacts on turret

00:29:55,210 --> 00:29:58,720
and then you remove the artifacts and

00:29:57,279 --> 00:30:00,070
then you go about you know we move it to

00:29:58,720 --> 00:30:01,210
link it and then you won't install

00:30:00,070 --> 00:30:05,470
double yet so then you're going to

00:30:01,210 --> 00:30:07,630
reduce the final size of your image the

00:30:05,470 --> 00:30:09,370
other approach you can take is the top

00:30:07,630 --> 00:30:12,070
to bottom so that means you're going to

00:30:09,370 --> 00:30:14,110
use the cash when it makes sense so what

00:30:12,070 --> 00:30:15,940
you don't want to do is to copy first

00:30:14,110 --> 00:30:18,490
replication source code and then put at

00:30:15,940 --> 00:30:20,470
the bar at the bottom I know an apt get

00:30:18,490 --> 00:30:21,610
update that's going to take a while it's

00:30:20,470 --> 00:30:24,190
going to download some system package

00:30:21,610 --> 00:30:25,570
from the internet and the next time you

00:30:24,190 --> 00:30:27,250
modify application source code the new

00:30:25,570 --> 00:30:28,809
copy and then it when you build it's

00:30:27,250 --> 00:30:30,940
going to validate the apt get update

00:30:28,809 --> 00:30:32,649
cash so we're just going to know like

00:30:30,940 --> 00:30:35,080
take more time to build it what you do

00:30:32,649 --> 00:30:36,669
want to do is the first round apt-get or

00:30:35,080 --> 00:30:38,260
any other system and instructions that

00:30:36,669 --> 00:30:39,940
you can cash and then you cup your

00:30:38,260 --> 00:30:41,830
application source code so when the cash

00:30:39,940 --> 00:30:43,750
is invalidated by modifying the source

00:30:41,830 --> 00:30:45,309
code you can still reuse the cache of

00:30:43,750 --> 00:30:48,460
the apt gackt which is a previous new

00:30:45,309 --> 00:30:50,860
layer but even better you can run your

00:30:48,460 --> 00:30:52,539
apt get cash that and in a copier the

00:30:50,860 --> 00:30:53,380
files that never changes you know it's a

00:30:52,539 --> 00:30:54,850
file that you know it's going to be

00:30:53,380 --> 00:30:56,769
there and not constantly mother finally

00:30:54,850 --> 00:30:58,659
develop and then you copy file the

00:30:56,769 --> 00:31:00,549
changes sometimes and then you copy the

00:30:58,659 --> 00:31:02,380
files that always changes this way

00:31:00,549 --> 00:31:05,019
darker can you know better utilizing the

00:31:02,380 --> 00:31:10,389
cash and after know better and times for

00:31:05,019 --> 00:31:12,429
a bill so how do we are in our in power

00:31:10,389 --> 00:31:14,529
created the the base images throughout

00:31:12,429 --> 00:31:17,019
the micro services will run and claw

00:31:14,529 --> 00:31:19,210
dynamics so initially we're using the

00:31:17,019 --> 00:31:21,460
Ubuntu image but you know later we

00:31:19,210 --> 00:31:23,230
switched to debut because you know it's

00:31:21,460 --> 00:31:25,389
a bit smaller about like 100 megabytes

00:31:23,230 --> 00:31:26,710
might not sound much like I said when

00:31:25,389 --> 00:31:28,179
you're pushing and pulling you want to

00:31:26,710 --> 00:31:30,880
make sure you have no the smallest image

00:31:28,179 --> 00:31:34,299
as possible then we are we a stirred I

00:31:30,880 --> 00:31:35,889
know a Java Runtime image image which I

00:31:34,299 --> 00:31:37,600
know we configure maven you know we

00:31:35,889 --> 00:31:39,909
modifying or some environment variables

00:31:37,600 --> 00:31:41,649
we have a node.js no run time as well we

00:31:39,909 --> 00:31:44,470
utter an image like that and then we

00:31:41,649 --> 00:31:46,029
have a goal and image with golang not

00:31:44,470 --> 00:31:47,940
sure if during your goal and developers

00:31:46,029 --> 00:31:49,740
in the room but

00:31:47,940 --> 00:31:52,409
the community and views package

00:31:49,740 --> 00:31:54,779
management in a very peculiar way so

00:31:52,409 --> 00:31:57,179
when you build a goal anger you know

00:31:54,779 --> 00:31:59,190
application you actually all the

00:31:57,179 --> 00:32:00,840
dependencies are statically linked even

00:31:59,190 --> 00:32:02,759
the wrong time itself the static linked

00:32:00,840 --> 00:32:06,059
so theoretically what you could do it

00:32:02,759 --> 00:32:07,950
could have a very tiny docker image like

00:32:06,059 --> 00:32:09,720
a two megabyte image can you can use a

00:32:07,950 --> 00:32:12,210
busy box and then you can just you know

00:32:09,720 --> 00:32:13,860
run your golang application there but

00:32:12,210 --> 00:32:17,340
you know that's a no topic for another

00:32:13,860 --> 00:32:20,039
time so about oh I know that the image

00:32:17,340 --> 00:32:22,049
you know building process first thing

00:32:20,039 --> 00:32:24,059
you don't want to do is deploy images

00:32:22,049 --> 00:32:27,149
straight from the internet to your

00:32:24,059 --> 00:32:28,950
environment you do want to keep track of

00:32:27,149 --> 00:32:30,570
all the dependencies of your

00:32:28,950 --> 00:32:33,779
applications in an internal repo that

00:32:30,570 --> 00:32:35,279
means you first analyze the dependencies

00:32:33,779 --> 00:32:37,289
download them and any provider

00:32:35,279 --> 00:32:39,899
developers in an internal repository

00:32:37,289 --> 00:32:41,639
most of the public repositories for in a

00:32:39,899 --> 00:32:44,370
variety of languages we do not run on

00:32:41,639 --> 00:32:45,809
HTTPS like it's very easy for somebody

00:32:44,370 --> 00:32:48,240
no to exploit you with the man in the

00:32:45,809 --> 00:32:49,950
middle attack you want to avoid that the

00:32:48,240 --> 00:32:52,409
second bit is going to create a process

00:32:49,950 --> 00:32:55,620
to after the base images and then make

00:32:52,409 --> 00:32:58,470
them available to developers so the goal

00:32:55,620 --> 00:33:00,509
is to avoid black boxes so if anybody

00:32:58,470 --> 00:33:02,519
here is familiar return our big data

00:33:00,509 --> 00:33:05,009
applications under the apache umbrella

00:33:02,519 --> 00:33:07,379
you know I know like Kafka zookeeper

00:33:05,009 --> 00:33:09,059
storm you know that to install them and

00:33:07,379 --> 00:33:10,350
you're like a team of people like it's

00:33:09,059 --> 00:33:13,529
not just like a single like one-liner

00:33:10,350 --> 00:33:15,840
script and usually in that process of

00:33:13,529 --> 00:33:17,789
installment I know you got a no download

00:33:15,840 --> 00:33:19,200
a library that a dude compile know

00:33:17,789 --> 00:33:20,669
somewhere and then you know that's

00:33:19,200 --> 00:33:22,440
pulling some the panas from another

00:33:20,669 --> 00:33:24,600
place that you have no idea so you end

00:33:22,440 --> 00:33:26,399
up with this big black box and you have

00:33:24,600 --> 00:33:28,110
no idea to verify that all the palaces

00:33:26,399 --> 00:33:30,690
inside the black box are actually you

00:33:28,110 --> 00:33:34,169
know like a good like they could be no

00:33:30,690 --> 00:33:36,690
exploited and the final bit is you want

00:33:34,169 --> 00:33:38,850
to think about failure scenarios so

00:33:36,690 --> 00:33:40,409
imagine you deploy you know hundreds if

00:33:38,850 --> 00:33:42,240
not thousands of containers production

00:33:40,409 --> 00:33:44,610
and then you know a new you know Java in

00:33:42,240 --> 00:33:47,730
0 0 the exploit you know convey no pops

00:33:44,610 --> 00:33:50,279
n how can you update all these

00:33:47,730 --> 00:33:52,259
containers in a timely fashion manner

00:33:50,279 --> 00:33:54,899
and I want to take this gonna take you

00:33:52,259 --> 00:33:56,940
know minutes hours so if you have that

00:33:54,899 --> 00:33:58,500
hygiene process you can easily you know

00:33:56,940 --> 00:34:01,060
push patches you know to your own

00:33:58,500 --> 00:34:03,620
environments

00:34:01,060 --> 00:34:05,690
but then you know live in all the

00:34:03,620 --> 00:34:08,090
technical bits aside what's the secret

00:34:05,690 --> 00:34:09,620
sauce about docker like why you know an

00:34:08,090 --> 00:34:11,600
open source project that has you know

00:34:09,620 --> 00:34:15,290
like about two years old it's so big and

00:34:11,600 --> 00:34:17,600
got so much popularity so in my view

00:34:15,290 --> 00:34:19,250
that the first part know if anybody here

00:34:17,600 --> 00:34:21,890
ever had to deal with the Linux

00:34:19,250 --> 00:34:23,870
containers you know that to share the

00:34:21,890 --> 00:34:25,790
root filesystem of the container like

00:34:23,870 --> 00:34:28,790
it's a pain like you know that there's

00:34:25,790 --> 00:34:30,830
no easy way and with docker they created

00:34:28,790 --> 00:34:32,720
this concept of a docker image which is

00:34:30,830 --> 00:34:34,490
not a new technologies using like Linux

00:34:32,720 --> 00:34:36,350
you know proven technologies well then

00:34:34,490 --> 00:34:38,840
it gives you the option to create a

00:34:36,350 --> 00:34:40,970
human readable tag and then share that

00:34:38,840 --> 00:34:43,520
image via you know like an image

00:34:40,970 --> 00:34:45,649
repository so doctor may like really

00:34:43,520 --> 00:34:47,690
easy to use and made the made the

00:34:45,649 --> 00:34:49,370
process sociable so if there's only like

00:34:47,690 --> 00:34:51,380
one thing it you know take from this

00:34:49,370 --> 00:34:53,450
presentation that if you make your

00:34:51,380 --> 00:34:55,010
project easy to use and you make a

00:34:53,450 --> 00:34:59,750
sociable like you have you know the

00:34:55,010 --> 00:35:01,850
recipe for success okay so all that

00:34:59,750 --> 00:35:04,780
sounds good then I hope I now we're able

00:35:01,850 --> 00:35:07,370
to convey why would you use darker but

00:35:04,780 --> 00:35:11,840
without networking how the containers

00:35:07,370 --> 00:35:14,390
would be no useless so here is just I

00:35:11,840 --> 00:35:17,390
know like an overview of the default

00:35:14,390 --> 00:35:20,180
network mode and darker comes win in

00:35:17,390 --> 00:35:22,130
with so initially you have you know your

00:35:20,180 --> 00:35:24,260
host you know physical interface to 80 0

00:35:22,130 --> 00:35:26,630
right there and then dr. create a buck

00:35:24,260 --> 00:35:28,970
or 0 virtual bridge and in from that

00:35:26,630 --> 00:35:31,130
bridge when you create containers it

00:35:28,970 --> 00:35:32,570
creates a pair of F's one vest which is

00:35:31,130 --> 00:35:35,690
a virtual interface inside a container

00:35:32,570 --> 00:35:38,480
and another pair in the darker zero you

00:35:35,690 --> 00:35:40,490
know bridge so this way the containers

00:35:38,480 --> 00:35:43,730
can communicate with each other and also

00:35:40,490 --> 00:35:45,050
rich the the whole network then you

00:35:43,730 --> 00:35:47,240
might be thinking okay the containers

00:35:45,050 --> 00:35:49,520
can communicate they can go out how do I

00:35:47,240 --> 00:35:51,740
get access to the containers so darker

00:35:49,520 --> 00:35:53,660
has this concept of I know exposing

00:35:51,740 --> 00:35:56,000
parts inside the container so you can

00:35:53,660 --> 00:35:57,530
tell darker which application which port

00:35:56,000 --> 00:36:00,260
your application is going to be listened

00:35:57,530 --> 00:36:03,410
to inside a container and then look in

00:36:00,260 --> 00:36:05,420
the Kaldari to publish you know a port

00:36:03,410 --> 00:36:07,550
on the host so what is really doing a

00:36:05,420 --> 00:36:09,500
port mapping so then you could have the

00:36:07,550 --> 00:36:11,960
application like web server inside the

00:36:09,500 --> 00:36:13,070
container listen on port 80 and then you

00:36:11,960 --> 00:36:15,410
can publish the port

00:36:13,070 --> 00:36:17,300
88 on the host so behind the scenes what

00:36:15,410 --> 00:36:19,790
doctor is doing is writing an IP tables

00:36:17,300 --> 00:36:22,490
I know for Drew you know to for the

00:36:19,790 --> 00:36:27,410
traffic from the host interface to the

00:36:22,490 --> 00:36:29,390
container you know this so the way I see

00:36:27,410 --> 00:36:31,130
all this because you know coming from my

00:36:29,390 --> 00:36:33,110
developer so take with a grain of salt

00:36:31,130 --> 00:36:35,390
you know like like networking heart I

00:36:33,110 --> 00:36:36,740
know Anna to be honest I don't know if

00:36:35,390 --> 00:36:40,370
anybody like it besides networking

00:36:36,740 --> 00:36:43,070
people no offense but I see docker

00:36:40,370 --> 00:36:44,840
creating network as a service like it's

00:36:43,070 --> 00:36:46,400
wrapping all the complexity and then

00:36:44,840 --> 00:36:48,230
just you know giving developers an easy

00:36:46,400 --> 00:36:49,760
way to manage infrastructure without

00:36:48,230 --> 00:36:54,560
having to know about all the

00:36:49,760 --> 00:36:58,310
infrastructure details so how about

00:36:54,560 --> 00:36:59,570
running simple containers so initially

00:36:58,310 --> 00:37:02,030
you know let's assume you're on the side

00:36:59,570 --> 00:37:03,740
you know taking like one of the Civil

00:37:02,030 --> 00:37:05,210
Services you know its application

00:37:03,740 --> 00:37:07,310
container and then you have a database

00:37:05,210 --> 00:37:09,710
container so they both get an IP on the

00:37:07,310 --> 00:37:11,780
same network but then following the 12

00:37:09,710 --> 00:37:13,730
factor at principles you're not going to

00:37:11,780 --> 00:37:15,170
be hard coding the IP of the database

00:37:13,730 --> 00:37:17,600
sintra application you're going to be

00:37:15,170 --> 00:37:19,460
using domain name so then the

00:37:17,600 --> 00:37:21,830
application tries to resolve the

00:37:19,460 --> 00:37:24,410
database domain name but then it can't

00:37:21,830 --> 00:37:27,080
find an IP so then I know this single

00:37:24,410 --> 00:37:30,920
model is broken so how the question is

00:37:27,080 --> 00:37:33,320
how do you link applications so darker

00:37:30,920 --> 00:37:35,930
has a native solution for the inter

00:37:33,320 --> 00:37:38,060
container communication problem so use

00:37:35,930 --> 00:37:39,800
the same example you have your

00:37:38,060 --> 00:37:41,690
application container but then the stein

00:37:39,800 --> 00:37:44,000
you tell darker to link to the database

00:37:41,690 --> 00:37:46,340
container so then darker goes and

00:37:44,000 --> 00:37:48,980
associates the database domain name with

00:37:46,340 --> 00:37:51,590
the database container IP so now the

00:37:48,980 --> 00:37:56,120
application can resolve database domain

00:37:51,590 --> 00:37:58,370
and let's connect to it but ok so under

00:37:56,120 --> 00:38:01,340
the hood what's happening so darker

00:37:58,370 --> 00:38:02,630
creates a et Cie hosts file if anybody

00:38:01,340 --> 00:38:04,460
familiar with linux which i believe

00:38:02,630 --> 00:38:07,070
people are since this is open source

00:38:04,460 --> 00:38:08,810
conference on the enola on the linux OS

00:38:07,070 --> 00:38:10,460
you have the atc hosts file which you

00:38:08,810 --> 00:38:12,740
have a list of IP addresses and domains

00:38:10,460 --> 00:38:15,500
so dr. creates one for each container

00:38:12,740 --> 00:38:17,540
and then mounts that et Cie hosts inside

00:38:15,500 --> 00:38:18,920
the container so then but by the time

00:38:17,540 --> 00:38:21,320
you link the container with another

00:38:18,920 --> 00:38:23,420
container darker updates the ATC hosts

00:38:21,320 --> 00:38:26,090
with the container IP and with the

00:38:23,420 --> 00:38:26,420
domain name you specify so in the end

00:38:26,090 --> 00:38:27,740
okay

00:38:26,420 --> 00:38:29,690
is that I know the link container is

00:38:27,740 --> 00:38:31,940
restarted dr. would assign a new IP

00:38:29,690 --> 00:38:34,040
address then because its mounting than

00:38:31,940 --> 00:38:36,579
TC hosts file inside the container it

00:38:34,040 --> 00:38:38,510
has a way to go and update dynamically

00:38:36,579 --> 00:38:41,290
besides you know managing all the

00:38:38,510 --> 00:38:43,730
domains when you link her containers and

00:38:41,290 --> 00:38:46,369
darker also does some IP table

00:38:43,730 --> 00:38:49,069
management in the in the back so darker

00:38:46,369 --> 00:38:51,440
has a flag to disable inter container

00:38:49,069 --> 00:38:54,079
communication which it could be useful

00:38:51,440 --> 00:38:56,180
if you have you know a self-serve in a

00:38:54,079 --> 00:38:57,920
cloud environment you don't want to have

00:38:56,180 --> 00:38:59,240
no flat network where like all the

00:38:57,920 --> 00:39:01,430
containers can you know talk to

00:38:59,240 --> 00:39:04,190
everybody so you can disable that if you

00:39:01,430 --> 00:39:07,520
do by enabling links darker creates a

00:39:04,190 --> 00:39:13,700
iptables to allow communication only

00:39:07,520 --> 00:39:16,280
between the link maintainers okay but

00:39:13,700 --> 00:39:19,010
Lincoln is not you know all the best

00:39:16,280 --> 00:39:21,319
there are some limitations so first

00:39:19,010 --> 00:39:24,140
limitation does not support by Direction

00:39:21,319 --> 00:39:25,460
communication channels so in a micro

00:39:24,140 --> 00:39:28,069
servers application you're going to find

00:39:25,460 --> 00:39:29,809
out more often or not that you have

00:39:28,069 --> 00:39:31,880
services communicating in a

00:39:29,809 --> 00:39:33,140
bidirectional way so if you just have a

00:39:31,880 --> 00:39:34,430
database the application is going to

00:39:33,140 --> 00:39:35,900
communicate to the database but the

00:39:34,430 --> 00:39:38,119
database does not need to communicate to

00:39:35,900 --> 00:39:40,579
the application but in a micro servicing

00:39:38,119 --> 00:39:42,890
architecture that's not the case that's

00:39:40,579 --> 00:39:45,049
why I probably are you guys I know are

00:39:42,890 --> 00:39:46,549
going to see that that store no diagram

00:39:45,049 --> 00:39:49,040
being a reference when talking about

00:39:46,549 --> 00:39:50,869
micro services like in a monolithic way

00:39:49,040 --> 00:39:52,490
you have you know like nice layers and

00:39:50,869 --> 00:39:54,440
no arrows you know only go in one

00:39:52,490 --> 00:39:55,880
direction when in microservices you have

00:39:54,440 --> 00:39:57,380
you know like hundreds of services and

00:39:55,880 --> 00:40:01,630
everything's communicating with

00:39:57,380 --> 00:40:04,730
everything okay so about about linking

00:40:01,630 --> 00:40:06,890
besides the bidirectional problem and

00:40:04,730 --> 00:40:08,720
another issue is that if you recreate

00:40:06,890 --> 00:40:10,339
the container so let's say in your

00:40:08,720 --> 00:40:12,260
development workflow you're going to

00:40:10,339 --> 00:40:13,579
make code changes to your application

00:40:12,260 --> 00:40:14,569
i'm going to rebuild the image and then

00:40:13,579 --> 00:40:17,000
you're going to relaunch the container

00:40:14,569 --> 00:40:18,530
any existing links to that container are

00:40:17,000 --> 00:40:20,599
going to be destroyed then you're going

00:40:18,530 --> 00:40:22,190
to have you know to recreate pretty much

00:40:20,599 --> 00:40:24,829
your whole application which had some

00:40:22,190 --> 00:40:26,569
overhead it's not ideal another reason

00:40:24,829 --> 00:40:28,670
you know why links you know shouldn't be

00:40:26,569 --> 00:40:30,770
used you know across the board that you

00:40:28,670 --> 00:40:33,020
want to have a later in between your

00:40:30,770 --> 00:40:34,760
services it could be you know proxy or

00:40:33,020 --> 00:40:36,710
it could be a load balancer you want to

00:40:34,760 --> 00:40:40,460
have hard links between in all your

00:40:36,710 --> 00:40:43,400
services so then if you don't use links

00:40:40,460 --> 00:40:48,290
how can you offer service discovery for

00:40:43,400 --> 00:40:51,710
your applications so that's where DNS

00:40:48,290 --> 00:40:55,040
dock comes into play so first of all

00:40:51,710 --> 00:40:57,349
like why DNS so DNS like you guys you

00:40:55,040 --> 00:40:59,000
know saw I know docker uses the NS you

00:40:57,349 --> 00:41:01,160
know when in form of links in a way and

00:40:59,000 --> 00:41:02,810
then DNS is also like a proven

00:41:01,160 --> 00:41:05,359
technology you know a lot of people are

00:41:02,810 --> 00:41:07,030
familiar with pretty much every no

00:41:05,359 --> 00:41:09,859
network stack of operating systems

00:41:07,030 --> 00:41:11,780
supports dns so it makes sense to just

00:41:09,859 --> 00:41:13,310
you know we used an ax instead of like

00:41:11,780 --> 00:41:16,849
reinventing the wheel when dealing with

00:41:13,310 --> 00:41:20,950
a no service discovery and what else you

00:41:16,849 --> 00:41:23,839
know dns doc so dns doc is a dns server

00:41:20,950 --> 00:41:25,460
implemented in golang so go Lange's the

00:41:23,839 --> 00:41:30,290
same language that darker has been

00:41:25,460 --> 00:41:32,869
written with so DNS stock it hooks to

00:41:30,290 --> 00:41:35,060
the darker event you know bus so then

00:41:32,869 --> 00:41:37,220
every time a curt container is created

00:41:35,060 --> 00:41:38,930
you know DNS stock is aware because it's

00:41:37,220 --> 00:41:40,910
listening to all the doctor events and

00:41:38,930 --> 00:41:43,220
then you know looks at the container IP

00:41:40,910 --> 00:41:45,109
and then adds an entry on its own

00:41:43,220 --> 00:41:49,130
internal server with that container ID

00:41:45,109 --> 00:41:52,040
and a name you can specify DNS talk also

00:41:49,130 --> 00:41:54,290
provides a rest HTTP interface to manage

00:41:52,040 --> 00:41:56,540
all the names and it's driven by

00:41:54,290 --> 00:41:59,660
environment variables so you can say no

00:41:56,540 --> 00:42:01,580
it's cloud where another in a very

00:41:59,660 --> 00:42:03,440
important point and I know when the

00:42:01,580 --> 00:42:06,830
reasons why we choose to use the NS doc

00:42:03,440 --> 00:42:08,450
was well when you have a new technology

00:42:06,830 --> 00:42:10,580
it's never the case you're going to

00:42:08,450 --> 00:42:12,440
migrate all your environment at once

00:42:10,580 --> 00:42:14,330
usually going to take baby steps going

00:42:12,440 --> 00:42:16,040
to be like a negative approach you

00:42:14,330 --> 00:42:17,930
migrate first and non critical pieces

00:42:16,040 --> 00:42:19,910
and slowly when the team gets more

00:42:17,930 --> 00:42:21,109
familiar the technology matures you're

00:42:19,910 --> 00:42:23,839
going to migrate the mission critical

00:42:21,109 --> 00:42:27,140
pieces so we then I stuck because it has

00:42:23,839 --> 00:42:29,119
an interface you can add domain no

00:42:27,140 --> 00:42:31,190
entries for services running virtual

00:42:29,119 --> 00:42:33,109
machines in other networks in bare metal

00:42:31,190 --> 00:42:35,030
servers it doesn't care its platform

00:42:33,109 --> 00:42:37,580
agnostic that sites it's a good benefit

00:42:35,030 --> 00:42:40,609
and there's you know like to make a

00:42:37,580 --> 00:42:41,930
point about you know a dns you guys

00:42:40,609 --> 00:42:45,109
probably heard about to OpenStack today

00:42:41,930 --> 00:42:47,060
and just on the latest release the

00:42:45,109 --> 00:42:49,490
OpenStack colibri released they

00:42:47,060 --> 00:42:51,859
introduced a concept of DNS the service

00:42:49,490 --> 00:42:54,050
so up to this day which I believe like

00:42:51,859 --> 00:42:55,940
openstax like three or four years old

00:42:54,050 --> 00:42:57,410
the National Service but you can see

00:42:55,940 --> 00:42:58,700
that's the direction they're going so

00:42:57,410 --> 00:43:02,270
the whole industry is kind of like you

00:42:58,700 --> 00:43:03,980
know trying to use DNS as you know the

00:43:02,270 --> 00:43:07,940
the tool of choice you know to handle

00:43:03,980 --> 00:43:09,620
the new service discovery so here you

00:43:07,940 --> 00:43:12,590
can see I know just you know basic you

00:43:09,620 --> 00:43:15,440
know topology of how you know our host

00:43:12,590 --> 00:43:17,930
and it looked like so you have all the

00:43:15,440 --> 00:43:19,790
application containers and you can see

00:43:17,930 --> 00:43:21,200
they all have an IP address so by the

00:43:19,790 --> 00:43:23,540
time they are created you know

00:43:21,200 --> 00:43:25,790
automatically DNS stock no ads an entry

00:43:23,540 --> 00:43:27,950
with therapy and the domain name we want

00:43:25,790 --> 00:43:30,140
no to resolve to and then in this case

00:43:27,950 --> 00:43:32,330
we have an overt machine running a

00:43:30,140 --> 00:43:34,460
database and then manually we can add

00:43:32,330 --> 00:43:36,740
you know that IP and the domain to the

00:43:34,460 --> 00:43:38,360
dns server which then enables all the

00:43:36,740 --> 00:43:39,980
containers to resolve you know the

00:43:38,360 --> 00:43:44,660
database you know domain name to the

00:43:39,980 --> 00:43:47,210
correct IP address ok so what about you

00:43:44,660 --> 00:43:50,060
know orchestrating containers in a mana

00:43:47,210 --> 00:43:51,560
left monolithic application you just

00:43:50,060 --> 00:43:52,940
have one script to run it your

00:43:51,560 --> 00:43:55,040
application is up you don't gotta worry

00:43:52,940 --> 00:43:57,590
about then if you have no multiple

00:43:55,040 --> 00:43:59,420
microservices you gotta somehow have a

00:43:57,590 --> 00:44:01,250
way to start them at the correct order

00:43:59,420 --> 00:44:04,010
and the find settings you know in a

00:44:01,250 --> 00:44:05,480
proper way so mainly when you look at

00:44:04,010 --> 00:44:07,850
the orchestration you want to have a

00:44:05,480 --> 00:44:10,940
blueprint to run you know your micro

00:44:07,850 --> 00:44:13,520
service application so the native

00:44:10,940 --> 00:44:16,160
solution the darker no offers it's

00:44:13,520 --> 00:44:18,020
called bucker compose so it first

00:44:16,160 --> 00:44:20,710
started with the project called a fig

00:44:18,020 --> 00:44:23,180
which later no darker ink you know

00:44:20,710 --> 00:44:24,980
what's called cloud before you know the

00:44:23,180 --> 00:44:26,660
wire fed and then incorporated that into

00:44:24,980 --> 00:44:30,290
the darker ecosystem and named our

00:44:26,660 --> 00:44:32,480
compost so dr. Campos it's a mainly

00:44:30,290 --> 00:44:33,950
consists of one yamo configuration file

00:44:32,480 --> 00:44:36,140
which you can define all the

00:44:33,950 --> 00:44:37,700
relationship of your services and then

00:44:36,140 --> 00:44:39,710
find settings for those services and

00:44:37,700 --> 00:44:41,420
then we tell I know one script you can

00:44:39,710 --> 00:44:42,920
you know run and then you know have the

00:44:41,420 --> 00:44:45,130
micro service application you know like

00:44:42,920 --> 00:44:49,100
up and running in your dog or host

00:44:45,130 --> 00:44:51,200
however I know orchestration is still an

00:44:49,100 --> 00:44:53,390
open market in 04 tools the reason one

00:44:51,200 --> 00:44:55,220
the fact or two that everybody uses so

00:44:53,390 --> 00:44:56,900
if you look around you know some tools

00:44:55,220 --> 00:45:00,320
you might you know be interested would

00:44:56,900 --> 00:45:02,210
be Mastro shipyard crane clocker know

00:45:00,320 --> 00:45:05,090
Bosh Bosh it so it's a good one right

00:45:02,210 --> 00:45:08,200
compose as well swarm which is also no

00:45:05,090 --> 00:45:10,640
part of the doctor ecosystem

00:45:08,200 --> 00:45:12,530
okay so now you have all the pieces how

00:45:10,640 --> 00:45:16,280
do we integrate darker into your into

00:45:12,530 --> 00:45:17,660
existing pipeline so I thought I call

00:45:16,280 --> 00:45:20,930
dynamics we already had you know a

00:45:17,660 --> 00:45:22,640
Jenkins in a pipeline built so when we

00:45:20,930 --> 00:45:24,950
decided to integrate no doctor into that

00:45:22,640 --> 00:45:26,570
we didn't want to disrupt the existing

00:45:24,950 --> 00:45:28,430
no build pipeline because some of the

00:45:26,570 --> 00:45:30,380
clients they were relying on the

00:45:28,430 --> 00:45:32,540
artifacts we're producing to a run you

00:45:30,380 --> 00:45:35,150
know our application of ertl machine so

00:45:32,540 --> 00:45:37,760
we just created separate you know

00:45:35,150 --> 00:45:40,070
janking jobs for each new micro service

00:45:37,760 --> 00:45:42,230
we were introducing we decided to use

00:45:40,070 --> 00:45:44,240
the cloud nice plugin it's a very know

00:45:42,230 --> 00:45:45,710
like nimble in the darker a plugin for

00:45:44,240 --> 00:45:47,869
Jenkins that offers like all the

00:45:45,710 --> 00:45:49,970
functionality you are going to need and

00:45:47,869 --> 00:45:52,340
then we had a pool of a darker build

00:45:49,970 --> 00:45:54,080
service which we would use to build the

00:45:52,340 --> 00:45:56,480
images for all the micro services and

00:45:54,080 --> 00:46:00,980
then finally we decided to use docker

00:45:56,480 --> 00:46:03,530
hub which is the the SAS very registry

00:46:00,980 --> 00:46:07,220
that t know doc or offers pretty much is

00:46:03,530 --> 00:46:09,410
that image repository so the the flow in

00:46:07,220 --> 00:46:12,200
an overview where I we would look like

00:46:09,410 --> 00:46:13,760
it's like first I know each microservice

00:46:12,200 --> 00:46:16,070
job would pull the code from bitbucket

00:46:13,760 --> 00:46:18,650
and then I would build the image you

00:46:16,070 --> 00:46:20,390
know for that service and then if the

00:46:18,650 --> 00:46:22,730
build was success would push the new

00:46:20,390 --> 00:46:25,430
image to the backer hub and then for QA

00:46:22,730 --> 00:46:27,290
environments we would automatically

00:46:25,430 --> 00:46:32,390
orchestrate the deployment of the new

00:46:27,290 --> 00:46:33,740
belts using docker compost so what about

00:46:32,390 --> 00:46:35,660
incorporating barker into the

00:46:33,740 --> 00:46:37,730
development workflow because that's

00:46:35,660 --> 00:46:39,380
important as well because if ur you're

00:46:37,730 --> 00:46:40,730
going to move to use darker you're going

00:46:39,380 --> 00:46:42,530
to make sure the valve purrs can still

00:46:40,730 --> 00:46:46,820
you know like operate and I know use

00:46:42,530 --> 00:46:48,980
docker on a daily basis so for linux i

00:46:46,820 --> 00:46:51,619
know runs natively since it relies on

00:46:48,980 --> 00:46:54,140
seminole linux kernel features for

00:46:51,619 --> 00:46:55,970
windows on the latest version I believed

00:46:54,140 --> 00:46:58,670
it just you know and should do support

00:46:55,970 --> 00:47:02,600
for the running back on it natively as

00:46:58,670 --> 00:47:04,850
well using the hyper-v so has no a

00:47:02,600 --> 00:47:07,250
different you know view of what I know I

00:47:04,850 --> 00:47:09,740
know isolate in each process but then it

00:47:07,250 --> 00:47:11,720
just provides the same API you know

00:47:09,740 --> 00:47:13,400
interface so then dr. doesn't care as

00:47:11,720 --> 00:47:15,680
long as you know the underlying system

00:47:13,400 --> 00:47:18,710
has that you know functionality blogger

00:47:15,680 --> 00:47:20,480
can work with so if you are running a

00:47:18,710 --> 00:47:21,950
mac which you know

00:47:20,480 --> 00:47:25,040
dynamics pretty much everybody runs a

00:47:21,950 --> 00:47:27,260
Mac we had to use docker machine so dr.

00:47:25,040 --> 00:47:28,910
machine is the the tool that darker you

00:47:27,260 --> 00:47:31,730
know created and offer for Mac

00:47:28,910 --> 00:47:33,920
developers to run docker into a Mac you

00:47:31,730 --> 00:47:37,250
know environment so what it does it

00:47:33,920 --> 00:47:39,109
creates a Linux virtual machine and not

00:47:37,250 --> 00:47:40,970
that virtual machines is very tiny it's

00:47:39,109 --> 00:47:43,340
about you know like 24 megabytes and

00:47:40,970 --> 00:47:45,530
then runs a buck or demon and then also

00:47:43,340 --> 00:47:47,060
installs the darker client on the Mac so

00:47:45,530 --> 00:47:49,310
then you can Ino access darker

00:47:47,060 --> 00:47:51,020
transparently also does other things

00:47:49,310 --> 00:47:53,270
like you know like sharing the folders

00:47:51,020 --> 00:47:54,619
from your Mac with VM so then this way

00:47:53,270 --> 00:47:56,390
like you can build damages and like

00:47:54,619 --> 00:47:59,119
mouth volumes and it's all transparently

00:47:56,390 --> 00:48:02,060
to you but however if you're looking for

00:47:59,119 --> 00:48:05,450
better performance you might want to

00:48:02,060 --> 00:48:09,140
check out vagrant boxes like not getting

00:48:05,450 --> 00:48:11,240
a lot of details but if you use NFS you

00:48:09,140 --> 00:48:12,890
know share with vagrant boxes you might

00:48:11,240 --> 00:48:15,020
gain a little bit of a performance when

00:48:12,890 --> 00:48:17,540
you know like sharing the your I know

00:48:15,020 --> 00:48:21,740
folders to wet you know the Linux VM

00:48:17,540 --> 00:48:23,570
running darker ok so what about like

00:48:21,740 --> 00:48:24,800
rocking production as we saw I think

00:48:23,570 --> 00:48:26,540
there's one person in the room that

00:48:24,800 --> 00:48:29,510
actually no deploy no docket production

00:48:26,540 --> 00:48:31,820
at skol dynamics we haven't deployed to

00:48:29,510 --> 00:48:33,710
production client yet we have a run in

00:48:31,820 --> 00:48:35,990
our QA environment and our development

00:48:33,710 --> 00:48:37,220
environment but you know we planning no

00:48:35,990 --> 00:48:39,859
to get darker and open running

00:48:37,220 --> 00:48:42,230
production soon so a couple of points to

00:48:39,859 --> 00:48:43,970
think about before in ongoing production

00:48:42,230 --> 00:48:45,830
first when I think about container

00:48:43,970 --> 00:48:47,240
monitoring so we're going to have you

00:48:45,830 --> 00:48:49,670
know hundreds or thousands of containers

00:48:47,240 --> 00:48:50,750
how do you monitoring monitor and make

00:48:49,670 --> 00:48:53,180
sure you know the containers are

00:48:50,750 --> 00:48:55,250
performing the way you expect second is

00:48:53,180 --> 00:48:56,750
log management the containers are going

00:48:55,250 --> 00:48:59,570
to be generating logs how are going to

00:48:56,750 --> 00:49:01,730
aggregate that and like visualize it and

00:48:59,570 --> 00:49:03,800
find like a multi host deployment how do

00:49:01,730 --> 00:49:06,080
you make sure you know containers

00:49:03,800 --> 00:49:09,410
running multiple hosts have a singly a

00:49:06,080 --> 00:49:13,190
pro I know management you know plane to

00:49:09,410 --> 00:49:16,100
your tools so some tools that people are

00:49:13,190 --> 00:49:18,190
creating to run document production our

00:49:16,100 --> 00:49:20,930
ranch urban areas and cloud foundry

00:49:18,190 --> 00:49:24,170
rancher it's a tool being developed by

00:49:20,930 --> 00:49:26,950
the ax cloudstack founders as well as

00:49:24,170 --> 00:49:29,990
seminal developed developers from sin

00:49:26,950 --> 00:49:33,800
cooper natus it's being developed by

00:49:29,990 --> 00:49:35,450
google it's known as the DX borg project

00:49:33,800 --> 00:49:37,760
and then you have called foundry which

00:49:35,450 --> 00:49:39,620
is being developed by pivotal so they're

00:49:37,760 --> 00:49:41,120
all open source projects you can okay go

00:49:39,620 --> 00:49:44,750
to the websites you know you can check

00:49:41,120 --> 00:49:46,520
out some demos we personally have been

00:49:44,750 --> 00:49:49,190
following ranch or more for like about a

00:49:46,520 --> 00:49:52,160
year we know the team and I know we'll

00:49:49,190 --> 00:49:53,750
be using know their power plataform you

00:49:52,160 --> 00:49:55,100
know in your local environments and we

00:49:53,750 --> 00:49:56,930
believe like in a few years that's going

00:49:55,100 --> 00:49:58,700
to be the place that's going to kind of

00:49:56,930 --> 00:50:00,410
like you know have a control on the

00:49:58,700 --> 00:50:04,790
darker production deployment so I

00:50:00,410 --> 00:50:07,100
encourage you guys check it out so

00:50:04,790 --> 00:50:09,680
that's pretty much it if you guys want

00:50:07,100 --> 00:50:11,870
to find more about us you can I know

00:50:09,680 --> 00:50:13,430
twitter twitter is that the call dynamic

00:50:11,870 --> 00:50:14,600
sandal and we're going to be posting the

00:50:13,430 --> 00:50:23,450
presentation notes you know they're

00:50:14,600 --> 00:50:36,100
after the fact so thank you if you guys

00:50:23,450 --> 00:50:38,840
have any questions please gives you 50

00:50:36,100 --> 00:50:41,960
complexity in georgia stalker has to the

00:50:38,840 --> 00:50:45,800
complexity from to operation and

00:50:41,960 --> 00:50:49,580
production so essentially what i don't

00:50:45,800 --> 00:50:51,770
get off this is let's say we have a vm

00:50:49,580 --> 00:50:54,320
scenario yes there was a lot of wastage

00:50:51,770 --> 00:50:56,090
but then we knew exactly a production

00:50:54,320 --> 00:51:00,160
time that this is what the difference of

00:50:56,090 --> 00:51:08,440
the hardware world when it comes to

00:51:00,160 --> 00:51:12,099
containers how exactly orchestra I am on

00:51:08,440 --> 00:51:13,869
something deployment is fine but then

00:51:12,099 --> 00:51:15,789
when it's running out with the action

00:51:13,869 --> 00:51:17,530
maybe that's because that'll out of the

00:51:15,789 --> 00:51:20,020
scope of your presentation the other

00:51:17,530 --> 00:51:24,089
question that I had was let's take the

00:51:20,020 --> 00:51:24,089
car situation where you are saying about

00:51:25,530 --> 00:51:28,530
bitnami

00:51:28,590 --> 00:51:36,420
an important shipment the other way you

00:51:32,070 --> 00:51:38,280
have blood press so I don't see how that

00:51:36,420 --> 00:51:44,190
problem exactly because it's still a

00:51:38,280 --> 00:51:47,790
slice and let's say you have to install

00:51:44,190 --> 00:51:53,460
MySQL guidance for HD there was a little

00:51:47,790 --> 00:51:58,130
bit of us that would be yes dr. does

00:51:53,460 --> 00:51:58,130
that does be some some excellent work in

00:51:59,510 --> 00:52:04,710
I think your first question you can

00:52:03,060 --> 00:52:07,710
still like in two parts so the first is

00:52:04,710 --> 00:52:09,720
about in a resource utilization so with

00:52:07,710 --> 00:52:12,060
the vm like no graphic covered you have

00:52:09,720 --> 00:52:13,980
no the hypervisor which is just already

00:52:12,060 --> 00:52:15,960
consuming fifty percent of the hardware

00:52:13,980 --> 00:52:18,030
available so with darker you can still

00:52:15,960 --> 00:52:20,400
apply some constraints using see groups

00:52:18,030 --> 00:52:22,830
so you can tell a container can only use

00:52:20,400 --> 00:52:25,020
for gigs of RAM or like it can only use

00:52:22,830 --> 00:52:27,090
two cars available in sauce so you still

00:52:25,020 --> 00:52:28,410
have a way to manage the resources but

00:52:27,090 --> 00:52:31,230
you don't have the overhead of running a

00:52:28,410 --> 00:52:33,540
hypervisor as far as the orchestration I

00:52:31,230 --> 00:52:35,790
like it's still a new field people are

00:52:33,540 --> 00:52:37,800
creating tools but the same way you have

00:52:35,790 --> 00:52:39,780
problems orchestrating the deployment of

00:52:37,800 --> 00:52:41,460
vertical machines and I go oh I have an

00:52:39,780 --> 00:52:42,870
orchestrated applications run inside the

00:52:41,460 --> 00:52:44,910
virtual machines that you know that

00:52:42,870 --> 00:52:46,530
problem translate as water darker but

00:52:44,910 --> 00:52:48,330
then if you look at the community people

00:52:46,530 --> 00:52:50,190
are focusing on trying to solve that

00:52:48,330 --> 00:52:52,080
problem using docker and like the

00:52:50,190 --> 00:52:55,260
virtual machine is already becoming like

00:52:52,080 --> 00:52:59,250
a legacy no technology then I guess on

00:52:55,260 --> 00:53:01,050
the bit numb piece yeah like with the

00:52:59,250 --> 00:53:03,990
point with the open shift in badami was

00:53:01,050 --> 00:53:06,510
more packed with with the linking of

00:53:03,990 --> 00:53:10,710
charities in DNS talk or just really

00:53:06,510 --> 00:53:13,170
neat you can solve lotos you can still

00:53:10,710 --> 00:53:13,740
have the separation of purpose of these

00:53:13,170 --> 00:53:15,860
contain

00:53:13,740 --> 00:53:19,170
and the canonical each other whereas on

00:53:15,860 --> 00:53:21,390
compromises service providers they tend

00:53:19,170 --> 00:53:24,150
to focus on just one application you

00:53:21,390 --> 00:53:26,700
want wordpress to that container is

00:53:24,150 --> 00:53:30,090
going to be set up with both WordPress

00:53:26,700 --> 00:53:31,500
like apache and mysql and what they

00:53:30,090 --> 00:53:34,710
don't really spit up two containers and

00:53:31,500 --> 00:53:36,630
link them so that level that's fine for

00:53:34,710 --> 00:53:38,280
WordPress but when you get beyond two

00:53:36,630 --> 00:53:40,560
more complicated applications like ours

00:53:38,280 --> 00:53:43,470
where we have like maybe up to 20

00:53:40,560 --> 00:53:45,720
services need to talk to each other with

00:53:43,470 --> 00:53:47,880
platform as a service I don't really

00:53:45,720 --> 00:53:54,530
know of a way to accomplish that if you

00:53:47,880 --> 00:53:57,660
have one let me know thanks I'm good I

00:53:54,530 --> 00:53:59,820
didn't question how you guys have been

00:53:57,660 --> 00:54:02,040
its actual self your blog management

00:53:59,820 --> 00:54:05,280
issues with so many stalkery services

00:54:02,040 --> 00:54:06,750
right yes well right now we're still

00:54:05,280 --> 00:54:09,240
working on that we're looking at options

00:54:06,750 --> 00:54:11,820
like low log stash and then we have like

00:54:09,240 --> 00:54:13,110
lovely to you know like syslog is

00:54:11,820 --> 00:54:14,820
another tool so like are we so like

00:54:13,110 --> 00:54:16,230
blade around some options and then we're

00:54:14,820 --> 00:54:18,210
going to decide which one when I like my

00:54:16,230 --> 00:54:21,960
dad highly suggest monster lochside sure

00:54:18,210 --> 00:54:25,160
we can elaborate things are even we've

00:54:21,960 --> 00:54:25,160
been looking a lot of diversity

00:54:30,499 --> 00:54:39,509
well if you're spitting up WordPress in

00:54:33,479 --> 00:54:42,900
battle and stuff like that what I don't

00:54:39,509 --> 00:54:45,359
really understand the moving parts at

00:54:42,900 --> 00:54:47,190
the base are you saying that you have

00:54:45,359 --> 00:54:49,890
several different things that would

00:54:47,190 --> 00:54:52,410
share the same my sequel or your

00:54:49,890 --> 00:54:56,269
WordPress in your whatever the hell

00:54:52,410 --> 00:54:59,400
would have their own copies of my sequel

00:54:56,269 --> 00:55:01,979
well like in our scenario at these

00:54:59,400 --> 00:55:06,239
currently we have multiple services

00:55:01,979 --> 00:55:08,160
talking to one database but inside I'm

00:55:06,239 --> 00:55:09,569
up to you to actually isolate that we

00:55:08,160 --> 00:55:11,670
may eventually add up at a point where

00:55:09,569 --> 00:55:15,229
each service cuz it's a separation of

00:55:11,670 --> 00:55:15,229
purpose it happened

00:55:23,500 --> 00:55:32,200
what is it like a little bit process I

00:55:30,700 --> 00:55:34,300
think just to get back to the question

00:55:32,200 --> 00:55:36,670
light with the Linux processes like dr.

00:55:34,300 --> 00:55:38,530
itself it's a linux process so it's more

00:55:36,670 --> 00:55:40,270
like you need you're not changing the

00:55:38,530 --> 00:55:42,790
underlying technology using traditional

00:55:40,270 --> 00:55:45,010
tool to make development and operations

00:55:42,790 --> 00:55:46,720
on easier and then by doing that like

00:55:45,010 --> 00:55:49,690
you've gained performance and then like

00:55:46,720 --> 00:55:51,910
Weibo to utilize on a harder battery but

00:55:49,690 --> 00:55:53,980
in a sign sets you have like a database

00:55:51,910 --> 00:55:55,750
you know container and then if you look

00:55:53,980 --> 00:55:58,570
at you know domain-driven you know like

00:55:55,750 --> 00:56:00,430
batters I guess like to radically want

00:55:58,570 --> 00:56:02,350
to have in a completely no separate or

00:56:00,430 --> 00:56:04,150
name then each service would have its

00:56:02,350 --> 00:56:06,700
own database it could be running the

00:56:04,150 --> 00:56:08,500
same my physical Mexico server where it

00:56:06,700 --> 00:56:10,180
could be no spun approximate requesters

00:56:08,500 --> 00:56:11,920
but that yeah year you're like

00:56:10,180 --> 00:56:16,290
introducing booze to help another

00:56:11,920 --> 00:56:16,290
process I know easier

00:56:19,110 --> 00:56:26,310
when you does it pop up an easel and all

00:56:26,770 --> 00:56:32,890
virtual switch is already resolved in

00:56:29,680 --> 00:56:36,850
craft space that that's a performance

00:56:32,890 --> 00:56:40,300
question action ok so the underlining in

00:56:36,850 --> 00:56:42,130
olenka way but the user networking when

00:56:40,300 --> 00:56:44,320
they were to answer a specific what I

00:56:42,130 --> 00:56:46,900
can say is that each container does not

00:56:44,320 --> 00:56:49,300
running from privileged mode so where it

00:56:46,900 --> 00:56:50,980
does not have an admin privileges to the

00:56:49,300 --> 00:56:53,410
hope that sexual i can run the

00:56:50,980 --> 00:56:55,180
containers but as far as performance

00:56:53,410 --> 00:56:58,420
that part i'll have to go back to you

00:56:55,180 --> 00:57:09,250
just in if you watch a packet traveling

00:56:58,420 --> 00:57:11,890
from the real network virtualization the

00:57:09,250 --> 00:57:14,680
switch at the hear the like darker uses

00:57:11,890 --> 00:57:17,560
in over two bridges so I know user is

00:57:14,680 --> 00:57:19,750
Jesus bridges and also this to enable

00:57:17,560 --> 00:57:21,460
the container into communication as far

00:57:19,750 --> 00:57:23,890
as i could float packets in the

00:57:21,460 --> 00:57:26,160
performance that part i know i'm not

00:57:23,890 --> 00:57:26,160

YouTube URL: https://www.youtube.com/watch?v=3e-jpT1OsYw


