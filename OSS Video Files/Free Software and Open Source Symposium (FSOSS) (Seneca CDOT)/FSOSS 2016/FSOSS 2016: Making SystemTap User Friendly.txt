Title: FSOSS 2016: Making SystemTap User Friendly
Publication date: 2016-11-25
Playlist: FSOSS 2016
Description: 
	Speaker: Cody Santing, Software Engineering Intern with RedHat

SystemTap is a powerful tracing and probing tool that allows users to analyze and monitor system wide events on live Linux systems. This presentation will cover the basics of SystemTap as well as recent and current work on improving the experience for new users.
Captions: 
	00:00:04,819 --> 00:00:10,670
hello my name is Cody Santa today I'm

00:00:07,490 --> 00:00:12,590
working at Red Hat's today I'm going to

00:00:10,670 --> 00:00:14,090
talk about system tap including the

00:00:12,590 --> 00:00:17,420
basics of using it and what we're doing

00:00:14,090 --> 00:00:20,180
to make it more new user friendly so I

00:00:17,420 --> 00:00:22,700
want you to take away and following from

00:00:20,180 --> 00:00:24,380
this presentation first what exactly is

00:00:22,700 --> 00:00:26,150
system tap and how is it useful for you

00:00:24,380 --> 00:00:26,660
and what are some of the things you can

00:00:26,150 --> 00:00:29,510
do with it

00:00:26,660 --> 00:00:30,890
second the basics of using system tap at

00:00:29,510 --> 00:00:33,440
the end of this presentation everyone

00:00:30,890 --> 00:00:35,750
should be able to go home and make a

00:00:33,440 --> 00:00:38,059
system tap script third to have

00:00:35,750 --> 00:00:39,670
increased awareness of some of the

00:00:38,059 --> 00:00:41,989
features available to help newer users

00:00:39,670 --> 00:00:43,399
I'll also demonstrate these features so

00:00:41,989 --> 00:00:45,859
that you already know how they work once

00:00:43,399 --> 00:00:48,649
you start using system tap and finally

00:00:45,859 --> 00:00:51,109
for you guys to know some of the plans

00:00:48,649 --> 00:00:54,979
that we have to provide even more

00:00:51,109 --> 00:00:58,519
resources for newer users ok there's a

00:00:54,979 --> 00:01:00,949
quick outline I'm gonna go over what is

00:00:58,519 --> 00:01:03,049
system tap the basics of using it I'm

00:01:00,949 --> 00:01:04,820
gonna talk about interactive modes

00:01:03,049 --> 00:01:08,540
some recent work and the motivation

00:01:04,820 --> 00:01:10,670
behind it next what's next and some

00:01:08,540 --> 00:01:12,230
questions and how to get involved I will

00:01:10,670 --> 00:01:14,510
have a demonstration after I've covered

00:01:12,230 --> 00:01:16,340
the basics and another demonstration

00:01:14,510 --> 00:01:19,910
after I've gone over recent work and

00:01:16,340 --> 00:01:22,220
motivation so what exactly is system tab

00:01:19,910 --> 00:01:24,110
well the system tap is a powerful open

00:01:22,220 --> 00:01:25,790
source tracing and probing tool use some

00:01:24,110 --> 00:01:29,570
modern activities of the system in fine

00:01:25,790 --> 00:01:31,460
detail it'sit's very useful finding out

00:01:29,570 --> 00:01:34,190
exactly what is going wrong and how it

00:01:31,460 --> 00:01:35,900
can be fixed when fixing bugs typical

00:01:34,190 --> 00:01:38,330
tools you would use our profilers

00:01:35,900 --> 00:01:40,250
tracers and debuggers these are all very

00:01:38,330 --> 00:01:41,780
useful tools but they have some their

00:01:40,250 --> 00:01:44,000
downsides

00:01:41,780 --> 00:01:46,490
so profilers are useful but simple ones

00:01:44,000 --> 00:01:48,530
are too abstract

00:01:46,490 --> 00:01:52,040
while more intricate ones require a lot

00:01:48,530 --> 00:01:53,540
of setup tracers provide more

00:01:52,040 --> 00:01:54,950
information than necessary which can be

00:01:53,540 --> 00:01:57,140
a bit overwhelming and slow down the

00:01:54,950 --> 00:01:59,960
debugging process typically when you use

00:01:57,140 --> 00:02:02,090
a tracer you will need to filter some of

00:01:59,960 --> 00:02:05,200
the data you receive which can cause

00:02:02,090 --> 00:02:07,820
relevant information to be lost

00:02:05,200 --> 00:02:10,480
debuggers are very good but it's not

00:02:07,820 --> 00:02:12,829
always an option to stop the program

00:02:10,480 --> 00:02:15,709
change the source code recompile and

00:02:12,829 --> 00:02:16,790
then run again so for example let's say

00:02:15,709 --> 00:02:17,390
you have a service running a server that

00:02:16,790 --> 00:02:22,930
a lot

00:02:17,390 --> 00:02:22,930
of clients our reliance on then you will

00:02:24,069 --> 00:02:31,160
okay a little bit okay it's not always

00:02:28,490 --> 00:02:32,060
an option to stop the program and then

00:02:31,160 --> 00:02:34,580
rerun it

00:02:32,060 --> 00:02:35,959
so systemtap offers similar

00:02:34,580 --> 00:02:37,790
functionality to all of these while also

00:02:35,959 --> 00:02:39,380
offering a solution to their downfalls

00:02:37,790 --> 00:02:42,800
allows you to write scripts to probe

00:02:39,380 --> 00:02:45,110
events system-wide and live so now how

00:02:42,800 --> 00:02:47,750
systemtap works so first you write a

00:02:45,110 --> 00:02:49,520
system top script then it gets converted

00:02:47,750 --> 00:02:51,200
into a kernel module and that kernel

00:02:49,520 --> 00:02:52,580
module gets inserted into the kernel and

00:02:51,200 --> 00:02:57,050
then you get the feedback that you

00:02:52,580 --> 00:02:59,030
request from your script so why would

00:02:57,050 --> 00:03:01,400
you use systemtap well you may be on an

00:02:59,030 --> 00:03:03,260
unfamiliar and busy system and you can't

00:03:01,400 --> 00:03:05,540
stop that system or maybe you need to

00:03:03,260 --> 00:03:07,010
fix a bug without recompiling or perhaps

00:03:05,540 --> 00:03:08,750
you're trying to become familiar with

00:03:07,010 --> 00:03:10,760
how a program works but don't want to

00:03:08,750 --> 00:03:12,800
break anything so systemtap has

00:03:10,760 --> 00:03:15,489
lightweight syscall tracing that is read

00:03:12,800 --> 00:03:18,920
only by default so it is not intrusive

00:03:15,489 --> 00:03:20,209
now some of the basics of system tap so

00:03:18,920 --> 00:03:22,010
each script will contain a number of

00:03:20,209 --> 00:03:24,380
probes probes have two elements to them

00:03:22,010 --> 00:03:28,489
the trigger and the handler so a trigger

00:03:24,380 --> 00:03:32,840
is the point or condition that needs to

00:03:28,489 --> 00:03:35,780
be met in order for your probe to be

00:03:32,840 --> 00:03:39,829
invoked the handler is the actions to

00:03:35,780 --> 00:03:42,799
take upon the probe being invoked so

00:03:39,829 --> 00:03:44,000
let's say for example you know

00:03:42,799 --> 00:03:45,709
something's wrong with your program may

00:03:44,000 --> 00:03:48,860
be a function isn't returning the proper

00:03:45,709 --> 00:03:50,420
value you can have a probe that will

00:03:48,860 --> 00:03:51,980
trigger when that function returns and

00:03:50,420 --> 00:03:54,140
you can check the return value so here's

00:03:51,980 --> 00:03:56,660
a another small example probe begin

00:03:54,140 --> 00:03:59,690
print line hello world now probe begin

00:03:56,660 --> 00:04:02,720
will trigger when your system tap script

00:03:59,690 --> 00:04:05,239
first starts and it's just prints hello

00:04:02,720 --> 00:04:08,239
world it's a basic example here's

00:04:05,239 --> 00:04:09,500
another one process LS begin when the LS

00:04:08,239 --> 00:04:12,860
process has started

00:04:09,500 --> 00:04:14,870
then this probe will trigger so even

00:04:12,860 --> 00:04:17,959
with such a simple probe you can detect

00:04:14,870 --> 00:04:20,440
when any process has begun no matter

00:04:17,959 --> 00:04:23,210
where on your system it originates from

00:04:20,440 --> 00:04:25,160
okay so now I'm gonna go over a few more

00:04:23,210 --> 00:04:28,550
probes so system tonight's system tab

00:04:25,160 --> 00:04:29,160
supports many triggers also known as pro

00:04:28,550 --> 00:04:31,560
points

00:04:29,160 --> 00:04:34,140
some more important ones are colonel and

00:04:31,560 --> 00:04:36,810
process statement and function probes so

00:04:34,140 --> 00:04:39,480
in this first one this will detect when

00:04:36,810 --> 00:04:41,250
aligned 501 of the readwrite file which

00:04:39,480 --> 00:04:42,960
happens to be in the SIS read function

00:04:41,250 --> 00:04:46,530
execute you can see you can have some

00:04:42,960 --> 00:04:48,690
very specific probes the second one will

00:04:46,530 --> 00:04:51,090
trigger any time the user process LS

00:04:48,690 --> 00:04:52,680
hits its main function the important

00:04:51,090 --> 00:04:54,240
thing to take away from here is that you

00:04:52,680 --> 00:04:55,920
can have both the user space and kernel

00:04:54,240 --> 00:04:58,800
space probes and you can have them

00:04:55,920 --> 00:05:00,750
running at the same time for those of

00:04:58,800 --> 00:05:02,370
you that use Java there are some Java

00:05:00,750 --> 00:05:05,510
specific probes so when a specific

00:05:02,370 --> 00:05:09,450
method method and a certain class of a

00:05:05,510 --> 00:05:12,270
specified Java process ID runs then this

00:05:09,450 --> 00:05:15,270
third one will trigger there are a few

00:05:12,270 --> 00:05:17,790
other types so timer probes timer probe

00:05:15,270 --> 00:05:19,230
will trigger every X amount of time no

00:05:17,790 --> 00:05:23,150
matter where in the code the kernel is

00:05:19,230 --> 00:05:26,120
net filter for networking events per

00:05:23,150 --> 00:05:28,770
points for hardware performance counters

00:05:26,120 --> 00:05:31,200
and there's a here's a helpful command

00:05:28,770 --> 00:05:34,850
you can do I'll demonstrate that that

00:05:31,200 --> 00:05:34,850
allows you to see all of the support its

00:05:35,390 --> 00:05:38,750
probe points

00:05:39,669 --> 00:05:45,410
it's so easy to read yeah well it's kind

00:05:42,560 --> 00:05:49,220
of cut off so you can see there's quite

00:05:45,410 --> 00:05:50,720
a few it supports those don't really

00:05:49,220 --> 00:05:52,639
that command doesn't really give

00:05:50,720 --> 00:05:54,710
descriptions of the pro points so you

00:05:52,639 --> 00:05:56,720
can use Man stat probes so you can read

00:05:54,710 --> 00:05:58,509
more about what the pro points to and

00:05:56,720 --> 00:06:00,979
while I'm on the topic of documentation

00:05:58,509 --> 00:06:03,889
systemtap has a lot of documentation so

00:06:00,979 --> 00:06:06,050
if you check the manual pages using the

00:06:03,889 --> 00:06:10,190
case which then you can see all of the

00:06:06,050 --> 00:06:11,599
supported or all of the manual pages so

00:06:10,190 --> 00:06:13,419
now the language so the system tap

00:06:11,599 --> 00:06:15,470
language is relatively straightforward

00:06:13,419 --> 00:06:17,419
it has all of the elements you would

00:06:15,470 --> 00:06:19,580
expect in a higher level programming and

00:06:17,419 --> 00:06:21,889
scripting language so it has variables

00:06:19,580 --> 00:06:22,520
conditionals loops functions arrays and

00:06:21,889 --> 00:06:25,250
so on

00:06:22,520 --> 00:06:27,259
anyone who has programmed in a higher

00:06:25,250 --> 00:06:28,970
level scripting or programming language

00:06:27,259 --> 00:06:31,190
won't really be too surprised by what

00:06:28,970 --> 00:06:33,380
they find in these basic elements oh it

00:06:31,190 --> 00:06:35,120
also does includes a few extra things so

00:06:33,380 --> 00:06:37,400
tuple key to raise and for each loops

00:06:35,120 --> 00:06:40,310
tuple keet array is essentially an array

00:06:37,400 --> 00:06:44,270
that allows you to use expressions and

00:06:40,310 --> 00:06:46,310
not just integers as indices so you can

00:06:44,270 --> 00:06:48,199
have an integer and a string or a string

00:06:46,310 --> 00:06:50,060
and a string and a string I believe it

00:06:48,199 --> 00:06:53,120
can support up to nine different

00:06:50,060 --> 00:06:54,979
expressions and for each loops are used

00:06:53,120 --> 00:06:58,669
to iterate through these two Paquita

00:06:54,979 --> 00:07:00,470
arrays next we have aggregates aggregate

00:06:58,669 --> 00:07:02,659
is essentially a large collection of

00:07:00,470 --> 00:07:05,060
numbers that you perform statistical

00:07:02,659 --> 00:07:08,090
operations on so at the minimum the

00:07:05,060 --> 00:07:10,880
maximum the average the some similar

00:07:08,090 --> 00:07:14,900
ones that macros macros work the same as

00:07:10,880 --> 00:07:16,250
they do in C so you have an identifier

00:07:14,900 --> 00:07:20,240
that gets expanded to something else

00:07:16,250 --> 00:07:21,949
during the personing stage regular

00:07:20,240 --> 00:07:24,620
expression matching to match regular

00:07:21,949 --> 00:07:26,930
expressions to strings and automated

00:07:24,620 --> 00:07:30,139
type interface so in system tap you

00:07:26,930 --> 00:07:31,729
don't declare you don't declare your

00:07:30,139 --> 00:07:33,139
variable types that gets done

00:07:31,729 --> 00:07:34,699
automatically so let's say you need to

00:07:33,139 --> 00:07:36,320
access some hidden internal data but

00:07:34,699 --> 00:07:39,080
don't know its type rather than wasting

00:07:36,320 --> 00:07:40,370
time using trial and error system tap

00:07:39,080 --> 00:07:44,360
just will figure it out we'll just

00:07:40,370 --> 00:07:46,039
figure that out for you so now accessing

00:07:44,360 --> 00:07:47,840
variables assistant tab provides the

00:07:46,039 --> 00:07:49,520
option of accessing context variables

00:07:47,840 --> 00:07:51,310
which can be very powerful so what

00:07:49,520 --> 00:07:52,780
exactly does that mean

00:07:51,310 --> 00:07:55,180
means at the point being probe you have

00:07:52,780 --> 00:07:57,130
access to any local variable in that

00:07:55,180 --> 00:08:01,060
code so for probing a function for

00:07:57,130 --> 00:08:03,700
example you can see the parameters that

00:08:01,060 --> 00:08:05,670
are passed to that function so here's an

00:08:03,700 --> 00:08:09,100
example from before the sis writes

00:08:05,670 --> 00:08:11,350
kernel function probe points this could

00:08:09,100 --> 00:08:13,720
for example be a write system call and

00:08:11,350 --> 00:08:15,280
some C code when the probe triggers you

00:08:13,720 --> 00:08:17,140
have access to every variable that is

00:08:15,280 --> 00:08:19,420
local at that point in the code if you

00:08:17,140 --> 00:08:23,530
use the - L option which would look like

00:08:19,420 --> 00:08:25,000
that then you can see all of the context

00:08:23,530 --> 00:08:26,830
variables you have access to so you

00:08:25,000 --> 00:08:28,960
would get something like this at first

00:08:26,830 --> 00:08:31,300
notice that the probe point has updated

00:08:28,960 --> 00:08:33,370
and now specifies which line and in

00:08:31,300 --> 00:08:36,010
which file that function is in so line

00:08:33,370 --> 00:08:37,990
599 of the read/write file and now

00:08:36,010 --> 00:08:39,610
you'll see a couple variables that are

00:08:37,990 --> 00:08:42,550
prefixed by a dollar sign the dollar

00:08:39,610 --> 00:08:45,180
sign just means it's a context variable

00:08:42,550 --> 00:08:48,100
so we have FD 'the file descriptor

00:08:45,180 --> 00:08:49,750
buffer and then count if you're familiar

00:08:48,100 --> 00:08:52,530
with the write function call and C then

00:08:49,750 --> 00:08:55,810
that is that parameters you pass to it

00:08:52,530 --> 00:08:58,480
you can also use the - L option on

00:08:55,810 --> 00:09:01,270
functions so this probe will trigger any

00:08:58,480 --> 00:09:05,800
time any function in the le whoops

00:09:01,270 --> 00:09:08,850
LS process is called so you can see all

00:09:05,800 --> 00:09:08,850
the functions of a process

00:09:08,890 --> 00:09:13,330
okay next tap sets so system tap

00:09:11,080 --> 00:09:15,700
includes something called tap sets which

00:09:13,330 --> 00:09:17,020
are essentially libraries similar to

00:09:15,700 --> 00:09:19,290
other languages so they have a few

00:09:17,020 --> 00:09:22,120
different things so first probe aliases

00:09:19,290 --> 00:09:23,980
alias is another way of writing the

00:09:22,120 --> 00:09:26,320
probe points so here's an example the

00:09:23,980 --> 00:09:30,010
sister i'ts function is equivalent to

00:09:26,320 --> 00:09:31,210
sis call dot writes if you use this call

00:09:30,010 --> 00:09:32,860
that right then this will attempt to

00:09:31,210 --> 00:09:34,990
capture the correct kernel function call

00:09:32,860 --> 00:09:36,610
without you having to look that up using

00:09:34,990 --> 00:09:37,840
sis called outright it's a lot easy to

00:09:36,610 --> 00:09:41,590
remember and you don't need to look up

00:09:37,840 --> 00:09:45,580
the specific function that triggers when

00:09:41,590 --> 00:09:48,300
you use this write system call next is

00:09:45,580 --> 00:09:53,020
useful functions so here's an example

00:09:48,300 --> 00:09:55,420
users string n this function will go to

00:09:53,020 --> 00:09:57,520
the address buffer and returned as a

00:09:55,420 --> 00:10:01,170
string its contents up to a length of

00:09:57,520 --> 00:10:04,130
count next you can have more variables

00:10:01,170 --> 00:10:08,690
so the variable here is

00:10:04,130 --> 00:10:10,399
string with our extreme it's returns all

00:10:08,690 --> 00:10:11,930
in that in this example with assists

00:10:10,399 --> 00:10:13,310
called outright it returns all of the

00:10:11,930 --> 00:10:16,639
context variables you would use if you

00:10:13,310 --> 00:10:18,589
use the - L switch concatenate it as a

00:10:16,639 --> 00:10:20,620
string so it's a lot more convenient to

00:10:18,589 --> 00:10:23,930
write our extreme than it is to writes

00:10:20,620 --> 00:10:27,370
file descriptor buffer accounts it's a

00:10:23,930 --> 00:10:29,089
lot neater it's a lot more portable

00:10:27,370 --> 00:10:31,459
alright

00:10:29,089 --> 00:10:33,380
one thing that to take an account is

00:10:31,459 --> 00:10:34,490
that you can create your own tap sets

00:10:33,380 --> 00:10:35,750
you don't just have to use the ones

00:10:34,490 --> 00:10:37,100
include with system tap so you can

00:10:35,750 --> 00:10:39,860
create some and share them with your

00:10:37,100 --> 00:10:43,970
team for example so now some useful

00:10:39,860 --> 00:10:48,529
functions and variables here's the first

00:10:43,970 --> 00:10:49,850
one process nano function open file this

00:10:48,529 --> 00:10:52,610
probe will trigger any time the open

00:10:49,850 --> 00:10:56,149
file function of the Nano process is

00:10:52,610 --> 00:10:58,130
called and you can see it has this parms

00:10:56,149 --> 00:11:01,399
variable in there that parms contains

00:10:58,130 --> 00:11:02,899
the parameters you pass to open file the

00:11:01,399 --> 00:11:05,720
double dollar sign on either side of

00:11:02,899 --> 00:11:09,560
parms basically means pretty print so

00:11:05,720 --> 00:11:13,699
it's easy for a human to read this next

00:11:09,560 --> 00:11:16,550
one process LS function star this will

00:11:13,699 --> 00:11:19,490
trigger anytime any function in the LS

00:11:16,550 --> 00:11:22,759
process is called on the flips on the

00:11:19,490 --> 00:11:24,350
first line you see the PP function the

00:11:22,759 --> 00:11:26,029
PP you will basically return the probe

00:11:24,350 --> 00:11:27,709
points that gets updated based on which

00:11:26,029 --> 00:11:30,110
function so if the main function is

00:11:27,709 --> 00:11:34,670
called this will return a string that

00:11:30,110 --> 00:11:36,319
contains process LS function main PP

00:11:34,670 --> 00:11:40,370
func function on the second line will

00:11:36,319 --> 00:11:42,230
just return main system commands you can

00:11:40,370 --> 00:11:44,839
execute system commands using the system

00:11:42,230 --> 00:11:47,180
function and this last one is probably

00:11:44,839 --> 00:11:50,420
the most important in my opinion PID

00:11:47,180 --> 00:11:52,220
filtering using the - X switch so when

00:11:50,420 --> 00:11:55,579
you use the - X which you would specify

00:11:52,220 --> 00:11:58,189
a process ID and that process ID gets

00:11:55,579 --> 00:12:02,600
returned when you use the targets

00:11:58,189 --> 00:12:05,209
variable you can see in the handler when

00:12:02,600 --> 00:12:07,790
you use the PID function on the Left it

00:12:05,209 --> 00:12:11,540
returns the process ID of the process

00:12:07,790 --> 00:12:13,279
that triggered the sis call right so if

00:12:11,540 --> 00:12:15,230
they are not equivalent then you just

00:12:13,279 --> 00:12:16,790
you hit the next statement which will

00:12:15,230 --> 00:12:18,680
skip the remainder of the probe

00:12:16,790 --> 00:12:20,810
this can be useful if you want to

00:12:18,680 --> 00:12:22,880
troubleshoot one specific program but

00:12:20,810 --> 00:12:27,530
don't want to capture all of the other

00:12:22,880 --> 00:12:29,090
right system calls okay so I'm gonna

00:12:27,530 --> 00:12:30,740
have a bit of a demo it's gonna be a

00:12:29,090 --> 00:12:32,420
live fix so meaning I'm going to run

00:12:30,740 --> 00:12:35,660
this program and I'm not going to stop

00:12:32,420 --> 00:12:37,940
it and fix the issues that we have so

00:12:35,660 --> 00:12:40,070
let's just take a look at the code first

00:12:37,940 --> 00:12:43,780
you have next number function just

00:12:40,070 --> 00:12:48,200
returns a counter so 0 1 2 3 and so on

00:12:43,780 --> 00:12:51,860
in the main function we just call next

00:12:48,200 --> 00:12:53,530
number a few times so I'm gonna point

00:12:51,860 --> 00:12:56,330
out a few important things so first

00:12:53,530 --> 00:12:57,920
counter is of type shorts so we return a

00:12:56,330 --> 00:13:01,670
value between short minimum and short

00:12:57,920 --> 00:13:03,500
maximum next next number is called int

00:13:01,670 --> 00:13:06,320
maximum time so some of you already

00:13:03,500 --> 00:13:09,140
probably see the issue here but what is

00:13:06,320 --> 00:13:11,660
the issue it's that counter will

00:13:09,140 --> 00:13:13,190
overflow so unless you're on a system

00:13:11,660 --> 00:13:14,720
size of short in size of integer

00:13:13,190 --> 00:13:18,050
equivalent then counter will overflow

00:13:14,720 --> 00:13:19,970
and produce a negative state for the

00:13:18,050 --> 00:13:22,940
sake of this demo I'm going to print the

00:13:19,970 --> 00:13:25,310
date anytime state is invalid so if it

00:13:22,940 --> 00:13:29,630
is negative so imagine this program is

00:13:25,310 --> 00:13:31,100
in a larger system and you if you have

00:13:29,630 --> 00:13:32,420
an issue like this it goes to an invalid

00:13:31,100 --> 00:13:34,490
state then you could bring down the

00:13:32,420 --> 00:13:35,740
whole system but you can't just stop it

00:13:34,490 --> 00:13:37,940
and maybe something important like a

00:13:35,740 --> 00:13:39,230
nuclear reactor you can't just stop

00:13:37,940 --> 00:13:41,210
everything and they know all I gotta

00:13:39,230 --> 00:13:44,240
change this short to an integer or

00:13:41,210 --> 00:13:46,220
something I don't know then you have to

00:13:44,240 --> 00:13:48,200
or you have to figure out a way to fix

00:13:46,220 --> 00:13:51,050
it without stopping the code so how can

00:13:48,200 --> 00:13:53,750
you do that well systemtap there are

00:13:51,050 --> 00:13:57,830
three things we want this script to do

00:13:53,750 --> 00:13:59,360
so first keep track of the state once if

00:13:57,830 --> 00:14:02,960
we know the state value we can detect if

00:13:59,360 --> 00:14:04,550
it is invalid and we can correct it so

00:14:02,960 --> 00:14:08,300
we can do that using this probe point

00:14:04,550 --> 00:14:14,720
this probe will trigger any time line 13

00:14:08,300 --> 00:14:17,120
of the main C function is reached so

00:14:14,720 --> 00:14:21,770
that line 13 is when state gets assigned

00:14:17,120 --> 00:14:22,850
the value of next number so the next

00:14:21,770 --> 00:14:25,850
thing we want to do is catch the next

00:14:22,850 --> 00:14:27,260
number return value if we detect that

00:14:25,850 --> 00:14:29,360
richer it is going to return a negative

00:14:27,260 --> 00:14:30,320
value we want to correct it to be but

00:14:29,360 --> 00:14:32,210
we'll just set it to

00:14:30,320 --> 00:14:36,620
zero so we can do that using the

00:14:32,210 --> 00:14:38,330
function next number return the last

00:14:36,620 --> 00:14:40,940
thing is to reset the counter so if we

00:14:38,330 --> 00:14:43,790
detected that we got an invalid return

00:14:40,940 --> 00:14:45,890
value we want to correct counter to go

00:14:43,790 --> 00:14:49,930
back to zero so it can continue counting

00:14:45,890 --> 00:14:52,340
as we intended it to so that can be done

00:14:49,930 --> 00:14:55,310
by detecting when the next number

00:14:52,340 --> 00:14:58,640
function is called so let's take a look

00:14:55,310 --> 00:15:00,350
at what the script looks like at the top

00:14:58,640 --> 00:15:02,240
here you see a global state and reset

00:15:00,350 --> 00:15:05,030
counter state will just keep track of

00:15:02,240 --> 00:15:07,040
the value of the state function and C in

00:15:05,030 --> 00:15:09,290
the C code we make it global so we can

00:15:07,040 --> 00:15:12,140
share it between all of our probes reset

00:15:09,290 --> 00:15:13,820
counter is just a flag that we will set

00:15:12,140 --> 00:15:14,240
when we want to reset counter back to

00:15:13,820 --> 00:15:18,170
zero

00:15:14,240 --> 00:15:20,780
so you look at the first function States

00:15:18,170 --> 00:15:23,660
the systemtap variable state gets the

00:15:20,780 --> 00:15:26,210
context variable state so the context

00:15:23,660 --> 00:15:28,790
variable state is from the C code this

00:15:26,210 --> 00:15:30,650
next handler if the context regular

00:15:28,790 --> 00:15:34,580
return value is less than zero then

00:15:30,650 --> 00:15:36,470
print a helpful message reset and then

00:15:34,580 --> 00:15:37,910
reset the return value to be zero so it

00:15:36,470 --> 00:15:40,460
is no longer negative and doesn't break

00:15:37,910 --> 00:15:44,300
our program and then we'll set the reset

00:15:40,460 --> 00:15:49,220
counter flag high one thing to note is

00:15:44,300 --> 00:15:51,620
by default this systemtap only observes

00:15:49,220 --> 00:15:53,570
in the context it doesn't actually make

00:15:51,620 --> 00:15:55,100
changes so if you want to make changes

00:15:53,570 --> 00:15:56,660
such as changing the return value we

00:15:55,100 --> 00:16:00,370
need to enter what is called guru mode

00:15:56,660 --> 00:16:04,460
that can be entered using the G switch

00:16:00,370 --> 00:16:05,780
so in the third probe we have we check

00:16:04,460 --> 00:16:07,640
to see if that flag is high

00:16:05,780 --> 00:16:09,740
whenever the function is next number is

00:16:07,640 --> 00:16:12,170
called if it is reset counter and then

00:16:09,740 --> 00:16:16,270
reset the flag so I'm going to

00:16:12,170 --> 00:16:16,270
demonstrate that looks like

00:16:20,209 --> 00:16:23,209
see

00:16:27,120 --> 00:16:36,240
so here is the system top script I show

00:16:31,170 --> 00:16:40,199
you is it that's pretty clear and here

00:16:36,240 --> 00:16:42,870
is the C code that I showed you so I'm

00:16:40,199 --> 00:16:45,899
going to run the previously compiled C

00:16:42,870 --> 00:16:47,970
code you see it already is printing the

00:16:45,899 --> 00:16:50,850
time and date on the left so it already

00:16:47,970 --> 00:16:52,829
has reached an invalid state so state

00:16:50,850 --> 00:16:57,870
that the state variable is negative so

00:16:52,829 --> 00:16:59,819
let's run the system tap script so I

00:16:57,870 --> 00:17:02,579
have the G command so I can enter guru

00:16:59,819 --> 00:17:04,980
mode and make changes to context

00:17:02,579 --> 00:17:07,890
variables so now we already have

00:17:04,980 --> 00:17:09,360
messages printing on the right and if

00:17:07,890 --> 00:17:11,159
you look at the left you will see that

00:17:09,360 --> 00:17:14,130
is not the time is no longer updating so

00:17:11,159 --> 00:17:18,179
that means we did we have successfully

00:17:14,130 --> 00:17:20,189
captured the return value and changed it

00:17:18,179 --> 00:17:23,149
to be zero so it is no longer negative

00:17:20,189 --> 00:17:26,610
so if I stop my assistive touch script

00:17:23,149 --> 00:17:32,850
now the time is updating again on the

00:17:26,610 --> 00:17:39,510
left so we broke it run one more time

00:17:32,850 --> 00:17:41,610
and the time no longer updates so it's

00:17:39,510 --> 00:17:43,409
pretty powerful that you can make

00:17:41,610 --> 00:17:52,279
changes to context variables like that

00:17:43,409 --> 00:17:52,279
so let's show these okay

00:17:53,370 --> 00:17:58,410
okay so that kind of concludes the first

00:17:56,370 --> 00:17:59,940
part of the presentation or I go over as

00:17:58,410 --> 00:18:02,010
them as the symtab basic so this quick

00:17:59,940 --> 00:18:03,270
summary I covered what is systemtap some

00:18:02,010 --> 00:18:05,580
of the things you can do with it and the

00:18:03,270 --> 00:18:09,210
basics of system top so the basics

00:18:05,580 --> 00:18:11,190
include probes probe points elements of

00:18:09,210 --> 00:18:13,980
the system tapped language variables and

00:18:11,190 --> 00:18:15,540
tap sets so system tap includes

00:18:13,980 --> 00:18:17,040
something called interactive mode which

00:18:15,540 --> 00:18:20,190
was first made available with version

00:18:17,040 --> 00:18:23,130
3.0 you can enter it using the eye or

00:18:20,190 --> 00:18:25,980
interactive switches OS interactive mode

00:18:23,130 --> 00:18:27,870
is essentially allows incremental and

00:18:25,980 --> 00:18:29,190
interactive script building with the

00:18:27,870 --> 00:18:31,080
option of loading and updating an

00:18:29,190 --> 00:18:33,390
existing script or creating a brand new

00:18:31,080 --> 00:18:35,340
one also available as a feature that

00:18:33,390 --> 00:18:37,860
will automatically analyze your script

00:18:35,340 --> 00:18:40,800
giving it information on each variable

00:18:37,860 --> 00:18:42,180
probe and function one reason to use

00:18:40,800 --> 00:18:45,180
interactive mode over just running

00:18:42,180 --> 00:18:45,600
system tap directly is this Auto analyze

00:18:45,180 --> 00:18:47,790
feature

00:18:45,600 --> 00:18:49,530
so the typical skip strip building

00:18:47,790 --> 00:18:52,050
process involves editing your script

00:18:49,530 --> 00:18:54,060
compiling it running it seeing error

00:18:52,050 --> 00:18:56,370
messages and repeating that now auto

00:18:54,060 --> 00:18:59,820
analyze will remove the compile and run

00:18:56,370 --> 00:19:01,500
step speeding up the process interactive

00:18:59,820 --> 00:19:03,450
mode also provides a way to discover

00:19:01,500 --> 00:19:04,980
example scripts included a system tap

00:19:03,450 --> 00:19:07,050
which is a good way to learn about

00:19:04,980 --> 00:19:08,310
various probe points as well as some of

00:19:07,050 --> 00:19:09,810
the capabilities of the tool I'm going

00:19:08,310 --> 00:19:13,080
to get more into that's example

00:19:09,810 --> 00:19:14,460
discovery in a little bit so the next

00:19:13,080 --> 00:19:16,080
time demo will entirely be an

00:19:14,460 --> 00:19:19,590
interactive mode but before I get to

00:19:16,080 --> 00:19:22,500
that demo recent work and the motivation

00:19:19,590 --> 00:19:24,120
behind it so a lot of recent work has

00:19:22,500 --> 00:19:27,210
been focused on improving the experience

00:19:24,120 --> 00:19:30,000
for interactive mode as it's the best

00:19:27,210 --> 00:19:31,680
place for new users to play around these

00:19:30,000 --> 00:19:33,420
updates include more helpful messages

00:19:31,680 --> 00:19:36,020
such as suggesting commands for users

00:19:33,420 --> 00:19:37,980
who are not sure what they want to do

00:19:36,020 --> 00:19:40,200
aliasing some of the commands to make

00:19:37,980 --> 00:19:42,150
them easier to discover and a new

00:19:40,200 --> 00:19:44,610
command which is used for example

00:19:42,150 --> 00:19:46,920
discovery I'll get into a game shortly

00:19:44,610 --> 00:19:48,600
the motivation behind these updates have

00:19:46,920 --> 00:19:52,020
been making systemtap easier for newer

00:19:48,600 --> 00:19:53,640
users to get into system tap is a bit

00:19:52,020 --> 00:19:55,380
lower level than some other debug

00:19:53,640 --> 00:19:57,210
debugging tools so the learning curve is

00:19:55,380 --> 00:19:59,820
somewhat steeper as I said before

00:19:57,210 --> 00:20:02,160
interactive mode is a great place for

00:19:59,820 --> 00:20:03,390
newer users to get used to system tops

00:20:02,160 --> 00:20:05,250
so we're going to focus some attention

00:20:03,390 --> 00:20:09,990
on it

00:20:05,250 --> 00:20:14,220
so now a demonstration I'm gonna enter

00:20:09,990 --> 00:20:16,860
interactive mode and helps I'm gonna run

00:20:14,220 --> 00:20:20,130
through some of these commands so let's

00:20:16,860 --> 00:20:22,710
cut off a bit yeah

00:20:20,130 --> 00:20:25,919
first we have ad so ad allows you to

00:20:22,710 --> 00:20:28,500
append a global variable a probe or a

00:20:25,919 --> 00:20:30,419
function to your current script police

00:20:28,500 --> 00:20:33,059
allows you to remove a specific or a

00:20:30,419 --> 00:20:36,090
range of lines from your scripts list

00:20:33,059 --> 00:20:39,539
will show you your script edit allows

00:20:36,090 --> 00:20:40,940
you to open in an external editor the

00:20:39,539 --> 00:20:44,159
script to make any changes you'd like

00:20:40,940 --> 00:20:46,380
load to loads and existing ones save to

00:20:44,159 --> 00:20:49,350
save the current scripts and then run to

00:20:46,380 --> 00:20:52,740
run it's a sample will search and load

00:20:49,350 --> 00:20:56,309
for an example script and now this sets

00:20:52,740 --> 00:21:01,500
an option value all these option here

00:20:56,309 --> 00:21:03,510
options here are similar to switches you

00:21:01,500 --> 00:21:05,669
would use in the command line and using

00:21:03,510 --> 00:21:07,230
set allows you to set their value and

00:21:05,669 --> 00:21:10,049
show will show all of their current

00:21:07,230 --> 00:21:14,789
values so I'm gonna go ahead and start

00:21:10,049 --> 00:21:17,940
with the add so add probe one shot now a

00:21:14,789 --> 00:21:20,880
one shot is an alias that I like I

00:21:17,940 --> 00:21:23,850
discussed before so the one shot it's

00:21:20,880 --> 00:21:25,470
equivalent to a probe begin so that will

00:21:23,850 --> 00:21:27,630
start when the system taps script starts

00:21:25,470 --> 00:21:29,970
the difference between a one shot and

00:21:27,630 --> 00:21:33,030
begin is that a one shot will append a

00:21:29,970 --> 00:21:37,200
call to the exit func function at the

00:21:33,030 --> 00:21:38,669
end of the handler so it will exit the

00:21:37,200 --> 00:21:43,230
rest of the script even if other Pro

00:21:38,669 --> 00:21:45,140
points haven't been triggered so I'll

00:21:43,230 --> 00:21:48,090
add that probe you can see it's already

00:21:45,140 --> 00:21:50,070
asking or expecting me to enter my

00:21:48,090 --> 00:21:54,169
scripts line by line so I'm going to

00:21:50,070 --> 00:21:54,169
enter just a simple hello world

00:21:57,200 --> 00:22:03,840
and I'll close it off and now it has

00:21:59,809 --> 00:22:05,640
accepted my probe so I will use the list

00:22:03,840 --> 00:22:07,289
function you can see my current scripts

00:22:05,640 --> 00:22:10,230
because I only had the one probe added

00:22:07,289 --> 00:22:13,340
it's a short script if I run that it

00:22:10,230 --> 00:22:13,340
does exactly as expected

00:22:18,120 --> 00:22:26,549
currently no we cannot so next I'll just

00:22:24,330 --> 00:22:29,549
delete maybe I don't want to delete

00:22:26,549 --> 00:22:30,960
maybe I didn't want to delete the second

00:22:29,549 --> 00:22:33,360
print statement so I'll remove that

00:22:30,960 --> 00:22:35,789
hopefully it's gone if I use the edit

00:22:33,360 --> 00:22:39,600
command you can now see the current

00:22:35,789 --> 00:22:42,799
scripts and so you can see the current

00:22:39,600 --> 00:22:45,600
script and that line is thankfully gone

00:22:42,799 --> 00:22:49,350
so I can run again and it just prints

00:22:45,600 --> 00:22:53,159
hello so now I'm going to show some of

00:22:49,350 --> 00:22:54,360
the options you can set so here's a list

00:22:53,159 --> 00:22:57,240
of all of them the first one I'm going

00:22:54,360 --> 00:22:58,890
to cover is Auto analyze so Auto analyze

00:22:57,240 --> 00:23:00,750
I discussed earlier will give you

00:22:58,890 --> 00:23:04,230
information on each probe variable end

00:23:00,750 --> 00:23:07,679
function in your script so I'm gonna set

00:23:04,230 --> 00:23:11,850
Auto analyze to one and show again you

00:23:07,679 --> 00:23:15,720
can see I have set it to one so if I

00:23:11,850 --> 00:23:20,070
make it auto analyze will be invoked any

00:23:15,720 --> 00:23:23,850
time a change is made to the script so

00:23:20,070 --> 00:23:26,789
I'm gonna just add a few variables so we

00:23:23,850 --> 00:23:29,120
can see the type of information that

00:23:26,789 --> 00:23:29,120
gives

00:23:36,680 --> 00:23:40,130
have a typo

00:23:42,700 --> 00:23:49,780
okay so I'm gonna save that script and

00:23:46,890 --> 00:23:54,970
now has analyzed the script so first we

00:23:49,780 --> 00:23:57,970
see Global's we have test I set as 15

00:23:54,970 --> 00:24:00,580
typed long we have functions I said that

00:23:57,970 --> 00:24:02,560
the one-shot probe has the exit function

00:24:00,580 --> 00:24:05,320
appended to the end so we see that

00:24:02,560 --> 00:24:07,270
function here and now we have the begin

00:24:05,320 --> 00:24:09,310
probe which was expanded from the

00:24:07,270 --> 00:24:12,190
one-shots and within the begin probe is

00:24:09,310 --> 00:24:19,720
the local variable test - which is of

00:24:12,190 --> 00:24:20,650
type string the next next option I'll go

00:24:19,720 --> 00:24:26,950
over is timing

00:24:20,650 --> 00:24:28,600
so if isset timing I run that it gives

00:24:26,950 --> 00:24:31,920
this nice probe hit report which gives

00:24:28,600 --> 00:24:34,780
the probe how many times it was hit and

00:24:31,920 --> 00:24:36,190
a number of cycles it took in on minimum

00:24:34,780 --> 00:24:38,350
average and maximum because this is a

00:24:36,190 --> 00:24:42,730
one shot it exits right away and it only

00:24:38,350 --> 00:24:44,380
has one hit I'm gonna be showing a few

00:24:42,730 --> 00:24:50,740
examples a little later on so you can

00:24:44,380 --> 00:24:55,000
see a larger probe hit report so some of

00:24:50,740 --> 00:24:57,280
these other options I'm just going to

00:24:55,000 --> 00:24:59,170
talk about not actually show so first is

00:24:57,280 --> 00:25:01,750
the Guru mode I talked about guru mode

00:24:59,170 --> 00:25:03,490
it allowed you to make changes to

00:25:01,750 --> 00:25:05,470
context variables and not just observe

00:25:03,490 --> 00:25:10,690
them it also allows you to run embedded

00:25:05,470 --> 00:25:13,660
C code in your system tap script target

00:25:10,690 --> 00:25:16,510
process ID is the back - X option I

00:25:13,660 --> 00:25:19,150
talked about now command command allows

00:25:16,510 --> 00:25:21,010
you to run a system command that will

00:25:19,150 --> 00:25:23,980
execute the same time as your system tap

00:25:21,010 --> 00:25:26,620
script what this also does is it ties

00:25:23,980 --> 00:25:30,550
the process ID of the command that you

00:25:26,620 --> 00:25:32,710
entered to the target function so when

00:25:30,550 --> 00:25:36,280
you use target it would typically return

00:25:32,710 --> 00:25:40,870
the process ID you specify with the - X

00:25:36,280 --> 00:25:45,580
option but it also if you use a command

00:25:40,870 --> 00:25:48,580
it will tie to the command option code

00:25:45,580 --> 00:25:50,920
of everything I wanted to actually auto

00:25:48,580 --> 00:25:52,750
analyze by default is enabled and it

00:25:50,920 --> 00:25:55,270
should be enabled just for the sake of

00:25:52,750 --> 00:26:00,060
this demo I changed the code so that

00:25:55,270 --> 00:26:03,370
it's off okay one thing to note about

00:26:00,060 --> 00:26:05,920
setting these options is that the

00:26:03,370 --> 00:26:08,170
process of setting them is going to be

00:26:05,920 --> 00:26:11,650
simplified in the near future I'm going

00:26:08,170 --> 00:26:13,840
to get into exactly how shortly so next

00:26:11,650 --> 00:26:16,780
and talk about the newer sample command

00:26:13,840 --> 00:26:19,150
so systemtap includes about 150 or so

00:26:16,780 --> 00:26:21,430
example scripts so most of these scripts

00:26:19,150 --> 00:26:23,740
were used in production for fixing bugs

00:26:21,430 --> 00:26:24,520
and testing there's a wide range of

00:26:23,740 --> 00:26:26,500
scripts to choose from including

00:26:24,520 --> 00:26:28,870
analysis of memory network and other

00:26:26,500 --> 00:26:31,060
system resources so how exactly can you

00:26:28,870 --> 00:26:33,640
find and play around with these scripts

00:26:31,060 --> 00:26:35,400
well the sample command what the sample

00:26:33,640 --> 00:26:38,740
command does is it searches through

00:26:35,400 --> 00:26:40,720
description files of each script with

00:26:38,740 --> 00:26:42,910
the provided keyword and we'll turn a

00:26:40,720 --> 00:26:44,740
list for you return a list from you to

00:26:42,910 --> 00:26:46,540
select from then give you a description

00:26:44,740 --> 00:26:51,730
and the name and the title of the script

00:26:46,540 --> 00:26:55,120
so that you can load and run it so I'm

00:26:51,730 --> 00:26:57,300
going to try a few so sample IO see

00:26:55,120 --> 00:26:59,760
there's a quite an extensive list of

00:26:57,300 --> 00:27:04,780
example scripts related to IO

00:26:59,760 --> 00:27:07,360
so I'll select one now it gives it the

00:27:04,780 --> 00:27:09,250
title the name and in description I'd

00:27:07,360 --> 00:27:11,350
asked me so I want to load that I want

00:27:09,250 --> 00:27:16,780
to choose another one so I'm going to

00:27:11,350 --> 00:27:20,410
select another related strip so what

00:27:16,780 --> 00:27:23,980
this script will do is it will measure

00:27:20,410 --> 00:27:27,790
all of the reads writes and data written

00:27:23,980 --> 00:27:29,680
during all executables that are running

00:27:27,790 --> 00:27:31,690
while this system top script is running

00:27:29,680 --> 00:27:34,840
so I'm gonna go ahead and select that

00:27:31,690 --> 00:27:36,370
one my script curtain currently exists

00:27:34,840 --> 00:27:38,770
but I don't really need that one just a

00:27:36,370 --> 00:27:42,490
one shot so I'm gonna overwrite it by

00:27:38,770 --> 00:27:44,110
list you can see I have the new script

00:27:42,490 --> 00:27:49,030
so it's a little more complex than the

00:27:44,110 --> 00:27:50,260
one I had before if I run that I'll give

00:27:49,030 --> 00:27:54,640
it a few seconds to collect some data

00:27:50,260 --> 00:27:56,170
and here we go it the script prints some

00:27:54,640 --> 00:28:00,280
nice information on the number of reads

00:27:56,170 --> 00:28:03,910
and writes and opens a number of bytes

00:28:00,280 --> 00:28:06,760
and kilobytes for all of those opens

00:28:03,910 --> 00:28:10,660
now here's a more extensive hit reports

00:28:06,760 --> 00:28:12,790
you can see here's one function the SIS

00:28:10,660 --> 00:28:15,880
read function the hide of 190 hits on

00:28:12,790 --> 00:28:19,380
and gives information on minimum average

00:28:15,880 --> 00:28:24,370
and maximum times to run through it

00:28:19,380 --> 00:28:27,600
that's one let's look at some networking

00:28:24,370 --> 00:28:27,600
events oops

00:28:28,800 --> 00:28:39,190
so there's not quite as many as there

00:28:31,840 --> 00:28:40,780
are io related ones select one now this

00:28:39,190 --> 00:28:43,240
script is similar to the previous one

00:28:40,780 --> 00:28:46,300
except it monitors packets and bytes

00:28:43,240 --> 00:28:47,860
sent between IP addresses so I'm going

00:28:46,300 --> 00:28:51,070
to load that one overwrite my current

00:28:47,860 --> 00:28:55,830
script if I use list you can see it is a

00:28:51,070 --> 00:28:57,940
different script now so this one uses

00:28:55,830 --> 00:29:04,920
these are the aggregates I talked about

00:28:57,940 --> 00:29:04,920
and a topic e to Ray so if I run that

00:29:05,010 --> 00:29:11,620
give it a few seconds and I stop and you

00:29:10,030 --> 00:29:12,970
can see these are the IP addresses and

00:29:11,620 --> 00:29:14,260
those are the number of packets and

00:29:12,970 --> 00:29:19,350
bytes sent between each of them and

00:29:14,260 --> 00:29:19,350
again a more extensive probe hit report

00:29:21,730 --> 00:29:26,649
so these example scripts I'm not

00:29:24,669 --> 00:29:27,940
actually going to run and show but I'll

00:29:26,649 --> 00:29:29,529
just talk about them so these are

00:29:27,940 --> 00:29:31,330
emergency band-aids of real

00:29:29,529 --> 00:29:32,830
vulnerabilities they are created

00:29:31,330 --> 00:29:34,240
specifically to protect from newly

00:29:32,830 --> 00:29:36,789
discovered vulnerabilities while a

00:29:34,240 --> 00:29:38,289
permanent fix was being developed they

00:29:36,789 --> 00:29:40,840
really show some of the versatility of

00:29:38,289 --> 00:29:43,419
system top if you want to learn more

00:29:40,840 --> 00:29:44,799
about these vulnerabilities then you can

00:29:43,419 --> 00:29:46,120
just google name of the scripts and

00:29:44,799 --> 00:29:50,200
you'll find a lot of information on both

00:29:46,120 --> 00:29:52,409
the bug and the fix that was used I can

00:29:50,200 --> 00:29:59,139
just blow us some I've got a lot of time

00:29:52,409 --> 00:30:03,220
so this one five one nine five leaves

00:29:59,139 --> 00:30:05,409
the dirty Cal vulnerability what this

00:30:03,220 --> 00:30:08,110
script does is it detects when there's a

00:30:05,409 --> 00:30:10,659
memory rights and it will set the count

00:30:08,110 --> 00:30:16,210
to zero so it essentially prevents you

00:30:10,659 --> 00:30:18,490
from using that system call here's a fun

00:30:16,210 --> 00:30:23,380
one there's actually a few games made in

00:30:18,490 --> 00:30:29,019
system tap so you can play a 2048 for

00:30:23,380 --> 00:30:32,830
example so someone someone made 2048 in

00:30:29,019 --> 00:30:40,929
system tap which is pretty cool so

00:30:32,830 --> 00:30:43,659
that's the sample commands it's a great

00:30:40,929 --> 00:30:45,039
place to play around and try to discover

00:30:43,659 --> 00:30:46,570
scripts related to something you're

00:30:45,039 --> 00:30:48,519
intending to do so before you start

00:30:46,570 --> 00:30:50,470
making your script it's a good idea

00:30:48,519 --> 00:30:51,760
enter a keyword related to it and maybe

00:30:50,470 --> 00:30:53,860
someone has already made what you've

00:30:51,760 --> 00:30:55,929
done or maybe someone's done something

00:30:53,860 --> 00:30:58,179
similar so you can build upon it or draw

00:30:55,929 --> 00:30:59,889
ideas from it one thing to note about

00:30:58,179 --> 00:31:02,049
this command it is not been officially

00:30:59,889 --> 00:31:04,029
released so you have to clone the most

00:31:02,049 --> 00:31:05,169
recent sources I'll provide a link at

00:31:04,029 --> 00:31:08,440
the end of the presentation where you

00:31:05,169 --> 00:31:10,659
can do that also what that link is a

00:31:08,440 --> 00:31:12,279
list of every example that there is so

00:31:10,659 --> 00:31:13,840
you can look through those manually

00:31:12,279 --> 00:31:15,519
rather than the sample command if you

00:31:13,840 --> 00:31:17,730
don't want to clone the most recent

00:31:15,519 --> 00:31:17,730
sources

00:31:18,610 --> 00:31:26,799
okay so now some future plans the work

00:31:25,510 --> 00:31:28,630
some of them I work in the near future

00:31:26,799 --> 00:31:30,370
will be focused on improving newer user

00:31:28,630 --> 00:31:32,440
experiences mostly with an interactive

00:31:30,370 --> 00:31:34,450
mode as I mentioned before setting

00:31:32,440 --> 00:31:36,309
options will be simplified so rather

00:31:34,450 --> 00:31:38,649
than typing each option one at a time

00:31:36,309 --> 00:31:42,070
and setting the value one at a time it

00:31:38,649 --> 00:31:44,649
will the plan is to have it accept a

00:31:42,070 --> 00:31:46,500
parcel SAP command line so that you can

00:31:44,649 --> 00:31:49,029
enter multiple at a time

00:31:46,500 --> 00:31:50,889
also within interactive mode is the

00:31:49,029 --> 00:31:52,149
sample command so the next steps for

00:31:50,889 --> 00:31:53,769
sample is to prove improve

00:31:52,149 --> 00:31:57,070
discoverability as the scripts as much

00:31:53,769 --> 00:32:00,190
as possible so this can be done one way

00:31:57,070 --> 00:32:02,080
of accepting multiple keywords so what I

00:32:00,190 --> 00:32:04,090
can either can be more inclusive with

00:32:02,080 --> 00:32:06,610
the selecting scripts related to any of

00:32:04,090 --> 00:32:09,090
the keywords or more exclusive accepting

00:32:06,610 --> 00:32:11,049
scripts related to all of the keywords

00:32:09,090 --> 00:32:13,570
also another way to improve

00:32:11,049 --> 00:32:16,690
discoverability is to add keywords to

00:32:13,570 --> 00:32:19,059
some of the description files the

00:32:16,690 --> 00:32:21,070
biggest thing to plan to reduce the

00:32:19,059 --> 00:32:23,980
barrier of entry in systemtap is that

00:32:21,070 --> 00:32:25,779
tutorial you see up there the tutorial

00:32:23,980 --> 00:32:27,519
is planned to be a command with an

00:32:25,779 --> 00:32:30,429
interactive mode and is essentially an

00:32:27,519 --> 00:32:31,570
interactive version of ad it would walk

00:32:30,429 --> 00:32:33,370
the users step by step through

00:32:31,570 --> 00:32:35,049
construction of a script so this

00:32:33,370 --> 00:32:38,380
includes selection of pro points whether

00:32:35,049 --> 00:32:39,639
it's the kernel a process or a module by

00:32:38,380 --> 00:32:41,350
listing available context variables

00:32:39,639 --> 00:32:44,080
similar to the else which automatically

00:32:41,350 --> 00:32:48,970
users will quickly get an idea of what

00:32:44,080 --> 00:32:51,639
type of data and what type of data they

00:32:48,970 --> 00:32:53,139
can view for their scripts after a probe

00:32:51,639 --> 00:32:54,760
has point has been selected then the

00:32:53,139 --> 00:32:56,860
tutorial will guide the user in

00:32:54,760 --> 00:32:59,350
construction of the handler so it will

00:32:56,860 --> 00:33:01,659
suggest a list of potential actions like

00:32:59,350 --> 00:33:03,039
maybe tracing or time measuring and will

00:33:01,659 --> 00:33:05,740
display those for the user to select

00:33:03,039 --> 00:33:07,690
from also plan is an interactive

00:33:05,740 --> 00:33:11,110
completion feature such as variable

00:33:07,690 --> 00:33:13,120
spelling correction now the purpose of

00:33:11,110 --> 00:33:14,799
this mode is to reduce difficulty in

00:33:13,120 --> 00:33:19,240
becoming familiar with system tab and

00:33:14,799 --> 00:33:20,799
its many features for newer users so

00:33:19,240 --> 00:33:23,529
it's kind of the end of the presentation

00:33:20,799 --> 00:33:24,789
I guess it went a little fast if you

00:33:23,529 --> 00:33:27,700
would like to get involved then you can

00:33:24,789 --> 00:33:28,840
go to the source where systemtap website

00:33:27,700 --> 00:33:30,520
up there

00:33:28,840 --> 00:33:31,929
how you'll find a ton of information on

00:33:30,520 --> 00:33:34,240
getting started including beginners

00:33:31,929 --> 00:33:35,980
guides tutorial a tap set reference and

00:33:34,240 --> 00:33:37,539
a language reference there's also

00:33:35,980 --> 00:33:41,890
information on contributing if you'd

00:33:37,539 --> 00:33:43,659
like to contribute if you want to ask

00:33:41,890 --> 00:33:45,309
any questions you can go to the system

00:33:43,659 --> 00:33:47,200
tap channel on freenode there's almost

00:33:45,309 --> 00:33:49,360
always someone there who is willing to

00:33:47,200 --> 00:33:52,299
help you if you for free email there is

00:33:49,360 --> 00:33:54,390
a mailing list so does anyone have any

00:33:52,299 --> 00:33:54,390
questions

00:33:54,690 --> 00:34:03,370
yep Debian I don't know the specific

00:34:01,840 --> 00:34:05,289
ones available but it does support a lot

00:34:03,370 --> 00:34:07,080
so on the Wikipedia page there's

00:34:05,289 --> 00:34:10,080
information on which ones are supported

00:34:07,080 --> 00:34:10,080
yep

00:34:14,370 --> 00:34:24,200
well yes I'll demonstrate that again

00:34:17,340 --> 00:34:24,200
they so a little quick let's just say

00:34:33,830 --> 00:34:46,770
okay thank you so for this one I'll load

00:34:43,380 --> 00:34:55,490
that first script so you can see I

00:34:46,770 --> 00:35:00,620
loaded the network-related scripts now

00:34:55,490 --> 00:35:04,080
can you see at the bottom there oh well

00:35:00,620 --> 00:35:05,640
yeah just so first load that one and

00:35:04,080 --> 00:35:09,600
then it asks if you would like to over

00:35:05,640 --> 00:35:13,790
overwrite the existing script so over

00:35:09,600 --> 00:35:13,790
writes and now we have the new one

00:35:15,950 --> 00:35:18,549
yes

00:35:22,009 --> 00:35:34,259
very specific thanks to the keywords I

00:35:31,519 --> 00:35:38,999
did have a few Pro points let me try to

00:35:34,259 --> 00:35:41,190
find some of those so in this in this

00:35:38,999 --> 00:35:44,099
example here Pro processed my app

00:35:41,190 --> 00:35:46,589
statements my app dot C line 13 so it is

00:35:44,099 --> 00:35:48,989
in C and C++ I'm not sure if there are

00:35:46,589 --> 00:36:01,349
too many betters just support it kind of

00:35:48,989 --> 00:36:04,799
like Java how they just so there are

00:36:01,349 --> 00:36:07,529
some Java specific ones here here we are

00:36:04,799 --> 00:36:09,269
I don't believe there are too many

00:36:07,529 --> 00:36:10,920
supported like that I think maybe Python

00:36:09,269 --> 00:36:14,130
and Python is being working worked on

00:36:10,920 --> 00:36:16,380
but you can still use like a process

00:36:14,130 --> 00:36:17,509
like I had back in the demonstration

00:36:16,380 --> 00:36:22,050
here

00:36:17,509 --> 00:36:24,450
welcome yep

00:36:22,050 --> 00:36:27,660
I'm impressed assistant at when I first

00:36:24,450 --> 00:36:27,660
that works

00:36:30,510 --> 00:36:34,550
four points or something

00:36:36,900 --> 00:36:42,180
but it's even lives in the colonel

00:36:39,440 --> 00:36:46,160
putting tracks and using witness

00:36:42,180 --> 00:36:46,160
yeah this is very powerful

00:36:47,890 --> 00:36:51,329
my ability

00:36:54,090 --> 00:37:06,100
usual and stuff it seems like magic the

00:37:02,980 --> 00:37:07,780
top of my head like so the way it works

00:37:06,100 --> 00:37:11,250
is it generates the C code and then it

00:37:07,780 --> 00:37:15,520
executes the C code and I think by

00:37:11,250 --> 00:37:21,270
chucking and yeah I'll get I'll give

00:37:15,520 --> 00:37:21,270
back to you on that yeah

00:37:21,420 --> 00:37:32,880
any other questions yeah

00:37:39,400 --> 00:37:42,670
yeah so one advantage of this is you

00:37:41,019 --> 00:37:49,359
don't actually have to stop the code

00:37:42,670 --> 00:37:51,430
like gdb for example okay looks like

00:37:49,359 --> 00:37:52,990
that's it's anyone has any other

00:37:51,430 --> 00:37:56,549
questions afterwards I'll be at the

00:37:52,990 --> 00:37:56,549
reception so thank you

00:38:06,440 --> 00:38:08,500

YouTube URL: https://www.youtube.com/watch?v=Ps9889XwyVc


