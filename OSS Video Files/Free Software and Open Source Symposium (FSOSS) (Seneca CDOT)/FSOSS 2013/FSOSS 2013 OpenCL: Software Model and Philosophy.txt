Title: FSOSS 2013 OpenCL: Software Model and Philosophy
Publication date: 2013-10-28
Playlist: FSOSS 2013
Description: 
	OpenCL: Software Model and Philosophy presentation by Adrien Guillon
Captions: 
	00:00:20,420 --> 00:00:25,220
AJ is a graduate of the University

00:00:25,279 --> 00:00:30,019
thanks for the introduction that is my

00:00:27,150 --> 00:00:32,910
first slide so this is a little bit of a

00:00:30,019 --> 00:00:36,030
time-saver this picture here is actually

00:00:32,910 --> 00:00:37,620
of New Zealand which is a very nice

00:00:36,030 --> 00:00:40,020
place and Siva nicer for open-source

00:00:37,620 --> 00:00:42,450
people like us because there are no

00:00:40,020 --> 00:00:44,129
software patents the skies are bluer the

00:00:42,450 --> 00:00:46,950
grass is greener everything's wonderful

00:00:44,129 --> 00:00:49,789
because we're unencumbered that someone

00:00:46,950 --> 00:00:52,649
owns the concept of the for loop

00:00:49,789 --> 00:00:55,079
Microsoft I think patented six months

00:00:52,649 --> 00:00:57,239
ago and a couple years ago Microsoft did

00:00:55,079 --> 00:00:59,250
patent the concept of using gpus for

00:00:57,239 --> 00:01:02,489
graphics computation I don't know what

00:00:59,250 --> 00:01:05,460
Nvidia AMD was thinking but it was not

00:01:02,489 --> 00:01:08,040
there is a key insight so did a

00:01:05,460 --> 00:01:10,320
wonderful job introducing myself my

00:01:08,040 --> 00:01:11,970
background is a little bit strange

00:01:10,320 --> 00:01:13,590
because I considered myself both the

00:01:11,970 --> 00:01:15,869
computer scientist and software engineer

00:01:13,590 --> 00:01:17,700
which means I like to apply theory to

00:01:15,869 --> 00:01:21,750
something that's actually happening in

00:01:17,700 --> 00:01:23,280
real life so I have my bachelor's from

00:01:21,750 --> 00:01:24,570
University of Toronto let's not go any

00:01:23,280 --> 00:01:27,360
further than that that was not very

00:01:24,570 --> 00:01:29,670
pleasant I consider myself an expert in

00:01:27,360 --> 00:01:31,110
C++ I didn't do laundry so that's why

00:01:29,670 --> 00:01:33,180
I'm wearing this suit I had my linux

00:01:31,110 --> 00:01:34,380
shirt but I wasn't quite sure I didn't

00:01:33,180 --> 00:01:37,140
have any pants that would do at the

00:01:34,380 --> 00:01:38,220
presentation justice so this is you know

00:01:37,140 --> 00:01:42,869
as you run low and laundry you look

00:01:38,220 --> 00:01:44,670
nicer and nicer I'm a enthusiast in high

00:01:42,869 --> 00:01:47,340
performance computing and I consider

00:01:44,670 --> 00:01:49,200
that the problems in hpc are actually in

00:01:47,340 --> 00:01:52,530
many ways more difficult than the

00:01:49,200 --> 00:01:54,899
current Big Data kind of thing and the

00:01:52,530 --> 00:01:56,040
reason for that is that the the

00:01:54,899 --> 00:01:58,110
engineering problems if you're

00:01:56,040 --> 00:01:59,610
stimulating a car or you're doing

00:01:58,110 --> 00:02:02,130
weather modeling there's a lot of

00:01:59,610 --> 00:02:03,479
computational density to that we're as

00:02:02,130 --> 00:02:06,149
big data I mean there's some interesting

00:02:03,479 --> 00:02:08,300
aspects to it or there's a distribution

00:02:06,149 --> 00:02:12,530
upgrade I'm almost ready to go to 1004

00:02:08,300 --> 00:02:14,540
if it works don't play with it so

00:02:12,530 --> 00:02:17,330
I spend quite a bit of my time working

00:02:14,540 --> 00:02:19,790
on the hardest problems hpc that's

00:02:17,330 --> 00:02:21,230
something that you ft does to you so

00:02:19,790 --> 00:02:23,840
right now I'm spending most of my time

00:02:21,230 --> 00:02:25,700
trying to figure out these big issues a

00:02:23,840 --> 00:02:28,420
first issue that i'm currently looking

00:02:25,700 --> 00:02:30,290
for venture funding is a approach to

00:02:28,420 --> 00:02:32,030
numerical software development which is

00:02:30,290 --> 00:02:33,920
motivated by a lot of the kind of

00:02:32,030 --> 00:02:36,350
theoretical aspects and i'm an open

00:02:33,920 --> 00:02:41,360
source developer i did participate in

00:02:36,350 --> 00:02:43,760
some way explaining to MPs in new

00:02:41,360 --> 00:02:46,010
zealand why open source software in

00:02:43,760 --> 00:02:47,989
wausau is beneficial to the economy and

00:02:46,010 --> 00:02:50,239
why software patents are fundamentally a

00:02:47,989 --> 00:02:52,730
bad thing so I consider myself quite the

00:02:50,239 --> 00:02:55,850
advocates of open source I feel very at

00:02:52,730 --> 00:02:57,290
home with this symposium so I started

00:02:55,850 --> 00:02:58,700
with opencl which is a topic of this

00:02:57,290 --> 00:02:59,569
talk and you don't have to worry if you

00:02:58,700 --> 00:03:00,920
don't have the background is not

00:02:59,569 --> 00:03:04,610
required and you're not gonna see any

00:03:00,920 --> 00:03:05,600
code sorry disappoint to you I start in

00:03:04,610 --> 00:03:09,470
two thousand eight which is when the

00:03:05,600 --> 00:03:11,930
specification first came out and at this

00:03:09,470 --> 00:03:14,569
point I'm working on some libraries or

00:03:11,930 --> 00:03:16,670
middleware and C++ you'll see some of

00:03:14,569 --> 00:03:17,959
the reason why this is important my goal

00:03:16,670 --> 00:03:20,150
is to develop some dual licensed

00:03:17,959 --> 00:03:22,730
software I love open source but I also

00:03:20,150 --> 00:03:24,170
like to eat so it's important to figure

00:03:22,730 --> 00:03:27,950
out how to maintain a balance between

00:03:24,170 --> 00:03:29,890
open source and not panhandling so I'm

00:03:27,950 --> 00:03:33,140
going to trying to find a good way to

00:03:29,890 --> 00:03:36,110
get to to charge for software which was

00:03:33,140 --> 00:03:37,190
novel and useful so if anyone has any

00:03:36,110 --> 00:03:38,750
suggestions this is something that's

00:03:37,190 --> 00:03:41,299
really important to me to figure out how

00:03:38,750 --> 00:03:43,100
to do a good bounce I recently launched

00:03:41,299 --> 00:03:44,690
a media wiki site for documenting opencl

00:03:43,100 --> 00:03:46,970
really nothing to say about that it's a

00:03:44,690 --> 00:03:48,290
wiki like 10 billion other ones and I

00:03:46,970 --> 00:03:50,570
have a series of technical articles on

00:03:48,290 --> 00:03:53,390
my blog another interesting thing about

00:03:50,570 --> 00:03:56,299
me is well also recording a series of

00:03:53,390 --> 00:03:57,320
youtube videos there's a I don't see as

00:03:56,299 --> 00:04:01,640
much on this screen I have to start

00:03:57,320 --> 00:04:05,090
using this one there's a there's a lack

00:04:01,640 --> 00:04:07,100
of good training for opencl a lot of the

00:04:05,090 --> 00:04:10,760
stuff you will see online is someone

00:04:07,100 --> 00:04:13,519
saying oh this is how to print to the

00:04:10,760 --> 00:04:14,209
screen or this is how to do something

00:04:13,519 --> 00:04:16,250
which you could have read the

00:04:14,209 --> 00:04:18,079
specification for what I'm trying to do

00:04:16,250 --> 00:04:19,370
is actually convey to you why you care

00:04:18,079 --> 00:04:21,019
about these things what the big picture

00:04:19,370 --> 00:04:22,940
of and this talk is really going to

00:04:21,019 --> 00:04:25,640
motivate and show you why opencl is very

00:04:22,940 --> 00:04:26,090
relevant there's a picture of one the

00:04:25,640 --> 00:04:28,699
few play

00:04:26,090 --> 00:04:32,810
I can escape technology water doesn't

00:04:28,699 --> 00:04:36,949
work so well with the GPUs or hpc so

00:04:32,810 --> 00:04:39,199
this is a water polo high performance is

00:04:36,949 --> 00:04:41,210
a way of life so high-performance sports

00:04:39,199 --> 00:04:42,620
is also a big thing I'm trying to

00:04:41,210 --> 00:04:45,110
maintain you know reduce the programmer

00:04:42,620 --> 00:04:47,449
physique and the only way I can do that

00:04:45,110 --> 00:04:48,680
is to up into a pool and be embarrassed

00:04:47,449 --> 00:04:49,729
if I have too much it were programmed

00:04:48,680 --> 00:04:53,000
with physical though it is an advantage

00:04:49,729 --> 00:04:54,530
of water pool okay very big so let's

00:04:53,000 --> 00:04:58,669
motivate heterogeneous computing and not

00:04:54,530 --> 00:05:00,110
think of me in a speedo too much so I'm

00:04:58,669 --> 00:05:02,180
not assuming you have any background so

00:05:00,110 --> 00:05:05,810
let's look at this is traditional

00:05:02,180 --> 00:05:07,639
computing this is how i learned it this

00:05:05,810 --> 00:05:08,720
is how you know most people in high

00:05:07,639 --> 00:05:12,979
schools is probably going to be the

00:05:08,720 --> 00:05:14,990
curriculum until 2273 but we basically

00:05:12,979 --> 00:05:18,919
have a cpu which is not the box by the

00:05:14,990 --> 00:05:20,780
way it is a processor we have a cpu

00:05:18,919 --> 00:05:22,370
which is the central actor in the system

00:05:20,780 --> 00:05:26,389
we have main memory we have i/o devices

00:05:22,370 --> 00:05:28,430
and we have a disk this is you know if

00:05:26,389 --> 00:05:30,800
this is not review it's going to get a

00:05:28,430 --> 00:05:32,419
little bit more complicated but the the

00:05:30,800 --> 00:05:34,280
basic situation is that this is what

00:05:32,419 --> 00:05:36,680
computing has looked like if we had an

00:05:34,280 --> 00:05:38,630
infinitely fast cpu nothing would have

00:05:36,680 --> 00:05:40,160
to change wouldn't need a GPU we didn't

00:05:38,630 --> 00:05:42,050
need an fpga but an infinitely fast

00:05:40,160 --> 00:05:44,240
memory we wouldn't need any of this

00:05:42,050 --> 00:05:46,430
stuff right this is the traditional

00:05:44,240 --> 00:05:51,169
software stack we've all seen this okay

00:05:46,430 --> 00:05:53,780
we have a program which the operating

00:05:51,169 --> 00:05:55,820
system as you see is mediating

00:05:53,780 --> 00:05:58,099
everything from the outside world hey

00:05:55,820 --> 00:05:59,539
you have a file system which again you

00:05:58,099 --> 00:06:02,450
only access the operating system or

00:05:59,539 --> 00:06:04,010
libraries can only talk to the OS the

00:06:02,450 --> 00:06:07,250
only thing that process believes it

00:06:04,010 --> 00:06:09,560
actually has is complete access to the

00:06:07,250 --> 00:06:11,120
RAM and that's just an illusion that is

00:06:09,560 --> 00:06:15,500
done through the processor and through

00:06:11,120 --> 00:06:16,610
the way that the memory system is you

00:06:15,500 --> 00:06:20,000
know it's an illusion portrayed by the

00:06:16,610 --> 00:06:24,200
US so computing today looks a little bit

00:06:20,000 --> 00:06:26,510
different we now have this situation we

00:06:24,200 --> 00:06:29,150
have a multi-core CPU you probably have

00:06:26,510 --> 00:06:30,710
a GPU attached you have a network card

00:06:29,150 --> 00:06:32,810
which allows you to access even more

00:06:30,710 --> 00:06:35,590
services than you ever want to access

00:06:32,810 --> 00:06:38,620
you have a raid controller which is also

00:06:35,590 --> 00:06:39,800
programmable and you have main memory

00:06:38,620 --> 00:06:41,120
what's in

00:06:39,800 --> 00:06:43,699
resting about this is in every device

00:06:41,120 --> 00:06:45,889
whether it's a GPU network card raid

00:06:43,699 --> 00:06:47,599
controller they're all programmable and

00:06:45,889 --> 00:06:49,789
they're all capable of doing computation

00:06:47,599 --> 00:06:51,830
in some manner they all have different

00:06:49,789 --> 00:06:52,940
is azor you can think about is assembly

00:06:51,830 --> 00:06:56,780
language they're all running different

00:06:52,940 --> 00:06:59,360
things and no this is what the

00:06:56,780 --> 00:07:01,190
heterogeneous software is all about this

00:06:59,360 --> 00:07:02,810
is a heterogeneous software stack I will

00:07:01,190 --> 00:07:04,940
point out that the reason that systems

00:07:02,810 --> 00:07:07,669
have changed so much is it this there is

00:07:04,940 --> 00:07:11,300
a trend to alleviate pressure from the

00:07:07,669 --> 00:07:13,250
cpu we want to offload computation right

00:07:11,300 --> 00:07:15,860
we want to offload memory transfers we

00:07:13,250 --> 00:07:17,599
want to free up the CPUs time we're in

00:07:15,860 --> 00:07:19,729
this kind of funny situation today where

00:07:17,599 --> 00:07:21,830
we freed up so much of the CPUs time the

00:07:19,729 --> 00:07:23,629
devices are actually better computation

00:07:21,830 --> 00:07:27,080
than the CPU is so we're in a very

00:07:23,629 --> 00:07:29,180
strange world right now and this is how

00:07:27,080 --> 00:07:31,879
the stack has changed is that you now

00:07:29,180 --> 00:07:35,690
have your program which you see these

00:07:31,879 --> 00:07:37,610
dotted lines at the bottom has access to

00:07:35,690 --> 00:07:40,580
another device which has its own program

00:07:37,610 --> 00:07:42,740
its own processor its own Ram ok and you

00:07:40,580 --> 00:07:45,020
see the top stack in ovaries you see

00:07:42,740 --> 00:07:47,150
that Ram is connected we don't have a

00:07:45,020 --> 00:07:51,590
necessarily a unified address space here

00:07:47,150 --> 00:07:53,300
they are separate things so the goal of

00:07:51,590 --> 00:07:55,460
opencl is to provide a model that allows

00:07:53,300 --> 00:07:57,830
us to work in this world opencl is not

00:07:55,460 --> 00:07:59,210
just a competitor to cuda it's not just

00:07:57,830 --> 00:08:01,909
an attempt at doing high performance

00:07:59,210 --> 00:08:04,279
computing it's a much bigger thing so

00:08:01,909 --> 00:08:06,110
this is how opencl sees the world we

00:08:04,279 --> 00:08:08,569
have a series of devices here and we

00:08:06,110 --> 00:08:11,599
have a host now these links what are

00:08:08,569 --> 00:08:13,159
they who knows these links could be

00:08:11,599 --> 00:08:15,529
network connections they could be

00:08:13,159 --> 00:08:18,500
physical pins on a board these could be

00:08:15,529 --> 00:08:19,789
anything the device what is it I don't

00:08:18,500 --> 00:08:21,680
know what it is it could be anything

00:08:19,789 --> 00:08:23,060
could be remote service there is an

00:08:21,680 --> 00:08:26,419
implementation of opencl that allows you

00:08:23,060 --> 00:08:28,190
distribute work to a cluster ok so the

00:08:26,419 --> 00:08:29,569
open sale model is very general because

00:08:28,190 --> 00:08:33,380
it's trying to do something very unique

00:08:29,569 --> 00:08:36,709
and we'll get into that in a moment the

00:08:33,380 --> 00:08:40,339
host part what is the host right it's a

00:08:36,709 --> 00:08:42,529
fair question to ask the host is defined

00:08:40,339 --> 00:08:44,690
in a careful way as being something that

00:08:42,529 --> 00:08:46,250
just makes API calls the reason that

00:08:44,690 --> 00:08:48,560
there's no guarantee that the host is a

00:08:46,250 --> 00:08:50,270
CPU there's no guarantee that the host

00:08:48,560 --> 00:08:52,960
is anything in particular there's a lot

00:08:50,270 --> 00:08:55,300
of flexibility here

00:08:52,960 --> 00:08:57,220
the host basically discovers what's

00:08:55,300 --> 00:08:59,860
available you know what implementations

00:08:57,220 --> 00:09:03,340
do I have of opencl how do I talk to

00:08:59,860 --> 00:09:06,190
them and what devices do I want to use

00:09:03,340 --> 00:09:08,050
okay and the host is going to take on

00:09:06,190 --> 00:09:11,320
some what the role of the operating

00:09:08,050 --> 00:09:12,730
system traditionally and that now rather

00:09:11,320 --> 00:09:14,440
than just deferring to libraries you're

00:09:12,730 --> 00:09:16,660
going to manage a device I'm in a

00:09:14,440 --> 00:09:18,970
situation where my program is a

00:09:16,660 --> 00:09:20,710
miniature operating system but I'm

00:09:18,970 --> 00:09:22,660
actually telling it you do that you do

00:09:20,710 --> 00:09:24,640
this you do this this makes braking

00:09:22,660 --> 00:09:29,560
writing opencl programs extraordinarily

00:09:24,640 --> 00:09:33,840
difficult so we'll get into second what

00:09:29,560 --> 00:09:36,070
to the devices do first need some water

00:09:33,840 --> 00:09:39,940
I'm going to pause at specific intervals

00:09:36,070 --> 00:09:41,500
to ask if there's questions so devices

00:09:39,940 --> 00:09:43,630
are usually programmable they don't have

00:09:41,500 --> 00:09:45,940
to be I mean I want to convey that the

00:09:43,630 --> 00:09:48,850
the goal of opencl is something really

00:09:45,940 --> 00:09:50,430
big and novel that you know we're doing

00:09:48,850 --> 00:09:52,770
something we've never done before the

00:09:50,430 --> 00:09:54,760
computational model has changed

00:09:52,770 --> 00:09:58,060
potentially you can use opencl to write

00:09:54,760 --> 00:10:03,210
programs to control these devices opencl

00:09:58,060 --> 00:10:05,590
is like c99 it's not but it's similar

00:10:03,210 --> 00:10:07,900
opencl devices execute function so you

00:10:05,590 --> 00:10:09,250
can tell the device do this do that no

00:10:07,900 --> 00:10:11,560
different than an operating system can

00:10:09,250 --> 00:10:13,390
say run main and whatever you do go for

00:10:11,560 --> 00:10:15,340
it okay you can load programs from

00:10:13,390 --> 00:10:17,160
sorcerer binary really this is kind of

00:10:15,340 --> 00:10:20,080
boring it's not that interesting yet

00:10:17,160 --> 00:10:22,510
you're opencl devices have memory you

00:10:20,080 --> 00:10:25,150
can copy and map things and you might

00:10:22,510 --> 00:10:27,160
have special hardware so this device

00:10:25,150 --> 00:10:29,620
might be an FPGA that has some sort of

00:10:27,160 --> 00:10:31,390
fixed capability built into it you can

00:10:29,620 --> 00:10:33,640
just call it and say I don't know how

00:10:31,390 --> 00:10:35,830
you're programmed but that function that

00:10:33,640 --> 00:10:37,600
you've been built for to do I'm going to

00:10:35,830 --> 00:10:41,470
invoke you on this data and it can just

00:10:37,600 --> 00:10:43,060
do its job ok so when as a side note

00:10:41,470 --> 00:10:47,320
that's managed asynchronously that's a

00:10:43,060 --> 00:10:49,420
detail now this is a few audience

00:10:47,320 --> 00:10:52,030
participation opportunities and this

00:10:49,420 --> 00:10:54,430
talk it's a it's the benevolent dictator

00:10:52,030 --> 00:10:57,970
type of talk what does this look like to

00:10:54,430 --> 00:11:00,250
you step back for a second you know what

00:10:57,970 --> 00:11:03,090
this should remind you of something this

00:11:00,250 --> 00:11:03,090
model of the world

00:11:05,199 --> 00:11:12,589
exactly so distribute computer so if you

00:11:08,660 --> 00:11:14,420
think about it we inside your pc now or

00:11:12,589 --> 00:11:18,860
even inside your cell phones you're

00:11:14,420 --> 00:11:21,050
entering into a situation where you have

00:11:18,860 --> 00:11:23,029
several devices available several

00:11:21,050 --> 00:11:25,129
interconnects several trade-offs and all

00:11:23,029 --> 00:11:26,810
of the problems of hpc start to ruin

00:11:25,129 --> 00:11:28,519
your day and all you're trying to do is

00:11:26,810 --> 00:11:29,899
write an email application that is GPU

00:11:28,519 --> 00:11:34,490
accelerated or whatever you're trying to

00:11:29,899 --> 00:11:36,079
do so it's very relevant and that's why

00:11:34,490 --> 00:11:38,029
open sales so interesting is that we're

00:11:36,079 --> 00:11:40,490
starting to enter this world where you

00:11:38,029 --> 00:11:41,959
actually are programming your PC as if

00:11:40,490 --> 00:11:43,129
it's a distributed system and the

00:11:41,959 --> 00:11:44,629
distributed system is a very good

00:11:43,129 --> 00:11:47,629
analogy because of the rate of

00:11:44,629 --> 00:11:49,730
computation versus memory access is very

00:11:47,629 --> 00:11:51,410
similar to the type of situations you

00:11:49,730 --> 00:11:54,019
have if you're doing distributed

00:11:51,410 --> 00:11:56,600
computing so we're going to talk about

00:11:54,019 --> 00:11:59,180
philosophy so you know what is air what

00:11:56,600 --> 00:12:02,029
is computation and there's a very good

00:11:59,180 --> 00:12:03,620
quote it's printed here mostly for the

00:12:02,029 --> 00:12:07,550
benefit of people i will put the slides

00:12:03,620 --> 00:12:09,560
up on my blog there's a quote from tim

00:12:07,550 --> 00:12:13,730
mats and principal engineer at intel

00:12:09,560 --> 00:12:15,980
corporation and it's interesting to note

00:12:13,730 --> 00:12:18,529
that opencl is being driven by the

00:12:15,980 --> 00:12:20,660
hardware vendors hey you don't you see

00:12:18,529 --> 00:12:21,829
one software application of one software

00:12:20,660 --> 00:12:24,529
vendor you will have heard of and that's

00:12:21,829 --> 00:12:29,569
adobe for the most part it's people like

00:12:24,529 --> 00:12:31,189
intel AMD Nvidia trying to say no one in

00:12:29,569 --> 00:12:32,750
software is tackling the hard problems

00:12:31,189 --> 00:12:35,149
because we're too busy selling people's

00:12:32,750 --> 00:12:37,189
personal information so it's up to the

00:12:35,149 --> 00:12:39,110
hardware vendors to create this

00:12:37,189 --> 00:12:42,470
wonderful opportunity because no one's

00:12:39,110 --> 00:12:43,850
around to do it and you know this to me

00:12:42,470 --> 00:12:46,009
is what Silicon Valley should be working

00:12:43,850 --> 00:12:47,779
on this is really kind of neat that

00:12:46,009 --> 00:12:48,949
we're getting in this situation that we

00:12:47,779 --> 00:12:50,600
can start to talk to all these different

00:12:48,949 --> 00:12:52,579
devices for the purpose of a single

00:12:50,600 --> 00:12:55,639
application so I'll get into a

00:12:52,579 --> 00:12:58,490
motivation a second but Tim Matson

00:12:55,639 --> 00:13:00,050
basically says opencl however is an

00:12:58,490 --> 00:13:02,240
unusually complex parallel programming

00:13:00,050 --> 00:13:03,860
standard it has to be I'm aware of no

00:13:02,240 --> 00:13:06,009
other parallel programming model that

00:13:03,860 --> 00:13:09,639
addresses such a wide array of systems

00:13:06,009 --> 00:13:12,470
GPU CPUs fpgas embedded processors in

00:13:09,639 --> 00:13:14,149
combinations of these systems opencl is

00:13:12,470 --> 00:13:17,029
also complicated by the goals of its

00:13:14,149 --> 00:13:17,990
creators you see in creating opencl we

00:13:17,029 --> 00:13:19,730
decided the best way

00:13:17,990 --> 00:13:21,020
to impact the industry would be to

00:13:19,730 --> 00:13:22,850
create a programming model for the

00:13:21,020 --> 00:13:24,680
performance oriented programmer wanting

00:13:22,850 --> 00:13:27,290
full access to the details of our system

00:13:24,680 --> 00:13:28,880
our reasoning was that over time high

00:13:27,290 --> 00:13:31,130
level models would be created to map

00:13:28,880 --> 00:13:32,570
onto opencl by creating a common

00:13:31,130 --> 00:13:34,310
low-level target for these higher level

00:13:32,570 --> 00:13:36,399
models would enable a rich marketplace

00:13:34,310 --> 00:13:38,899
of ideas and programmers would win

00:13:36,399 --> 00:13:40,970
opencl therefore doesn't give you many

00:13:38,899 --> 00:13:43,130
abstractions to make your job easier you

00:13:40,970 --> 00:13:45,080
have to do all that work yourself so

00:13:43,130 --> 00:13:47,300
open CL is very young it's a very nice

00:13:45,080 --> 00:13:49,250
opportunity so we can summarize a

00:13:47,300 --> 00:13:51,110
philosophy as follows open seals a

00:13:49,250 --> 00:13:53,000
low-level standard and trust me you

00:13:51,110 --> 00:13:55,820
don't want to use it directly it's very

00:13:53,000 --> 00:13:58,250
complicated I mean some people love to

00:13:55,820 --> 00:14:00,230
feel very macho because I know likessee

00:13:58,250 --> 00:14:03,500
and I can hand code my own operating

00:14:00,230 --> 00:14:04,970
system everything you can like open sale

00:14:03,500 --> 00:14:06,890
allows you to be that low level but

00:14:04,970 --> 00:14:08,510
you'll find very quickly that you're

00:14:06,890 --> 00:14:10,130
repeating yourself so much they're not

00:14:08,510 --> 00:14:12,140
being productive instead the role of

00:14:10,130 --> 00:14:13,970
opencl is to to build the higher level

00:14:12,140 --> 00:14:17,660
abstractions are useful for your purpose

00:14:13,970 --> 00:14:18,860
and to use those one of the problems is

00:14:17,660 --> 00:14:20,420
that we really don't know what the high

00:14:18,860 --> 00:14:22,339
level libraries or abstractions are

00:14:20,420 --> 00:14:25,550
going to be but we're able to search for

00:14:22,339 --> 00:14:28,040
them this is so unique that am I mean

00:14:25,550 --> 00:14:30,260
was relevant about this quote is it was

00:14:28,040 --> 00:14:34,959
written by Intel as an introduction to a

00:14:30,260 --> 00:14:37,579
book written by AMD so the hardware guys

00:14:34,959 --> 00:14:40,220
really really are coming together in

00:14:37,579 --> 00:14:42,110
such a nice way it has happened so

00:14:40,220 --> 00:14:44,870
rarely before that everyone comes

00:14:42,110 --> 00:14:46,940
together and agrees to interoperate at

00:14:44,870 --> 00:14:48,200
the hardware level and unfortunately the

00:14:46,940 --> 00:14:50,779
programmers are too busy wondering

00:14:48,200 --> 00:14:52,730
around facebooking each other or

00:14:50,779 --> 00:14:54,440
whatever to say these you know the

00:14:52,730 --> 00:14:57,110
hardware people are begging you please

00:14:54,440 --> 00:14:58,640
develop the killer application and we're

00:14:57,110 --> 00:15:01,430
too busy selling grandma's information

00:14:58,640 --> 00:15:03,310
but you know the whole point is are

00:15:01,430 --> 00:15:07,339
trying to enable an ecosystem here and

00:15:03,310 --> 00:15:09,170
well before i get into the open sale 2.0

00:15:07,339 --> 00:15:11,089
i want to give you a little bit of

00:15:09,170 --> 00:15:14,899
motivation of what an application open

00:15:11,089 --> 00:15:16,520
sale might be like so we have all of

00:15:14,899 --> 00:15:17,899
these devices they can all do different

00:15:16,520 --> 00:15:21,920
things we can talk to them in different

00:15:17,899 --> 00:15:23,450
ways you could have multiple GPUs you

00:15:21,920 --> 00:15:25,459
could have an FPGA on your system you

00:15:23,450 --> 00:15:28,010
could have a cpu by the way the device

00:15:25,459 --> 00:15:29,750
could be the CPU itself you could manage

00:15:28,010 --> 00:15:31,740
yourself as a device even though you're

00:15:29,750 --> 00:15:33,570
running the device in hoster this

00:15:31,740 --> 00:15:35,190
one of the reasons you might want to do

00:15:33,570 --> 00:15:38,310
that is open sale is actually really

00:15:35,190 --> 00:15:41,670
nice generating instructions for AVX or

00:15:38,310 --> 00:15:43,680
for vectorized instructions opencl does

00:15:41,670 --> 00:15:46,110
an amazing job if you've ever tried to

00:15:43,680 --> 00:15:49,110
do this and see my sympathies it's very

00:15:46,110 --> 00:15:51,810
hard to do but opencl provides us for

00:15:49,110 --> 00:15:54,450
you so consider an application in which

00:15:51,810 --> 00:15:56,280
you have a video game and maybe you're

00:15:54,450 --> 00:15:58,590
going to offload rendering to one GPU

00:15:56,280 --> 00:16:00,600
maybe you offload collision detection to

00:15:58,590 --> 00:16:03,240
this GPU and maybe you have some sort of

00:16:00,600 --> 00:16:06,480
low latency operation to be done that

00:16:03,240 --> 00:16:08,910
you offload to the CPU you can really

00:16:06,480 --> 00:16:11,700
build applications that use all of these

00:16:08,910 --> 00:16:13,860
things together in a very nice way you

00:16:11,700 --> 00:16:15,750
do see for instance that we use supports

00:16:13,860 --> 00:16:17,910
opencl 1.0 i'm not sure if you actually

00:16:15,750 --> 00:16:19,620
can directly access it there's a lot of

00:16:17,910 --> 00:16:23,090
controversy from android they're trying

00:16:19,620 --> 00:16:24,900
to allow your taxes opencl but

00:16:23,090 --> 00:16:28,530
fundamentally you're entering into this

00:16:24,900 --> 00:16:30,930
very interesting situation in which

00:16:28,530 --> 00:16:33,030
you're writing programs that are using

00:16:30,930 --> 00:16:37,170
many things to achieve whatever your

00:16:33,030 --> 00:16:38,610
actual application purpose is so open co

00:16:37,170 --> 00:16:39,600
has some changes I didn't it were in the

00:16:38,610 --> 00:16:42,540
history but every couple of years

00:16:39,600 --> 00:16:48,570
something changes but opencl opencl 2.0

00:16:42,540 --> 00:16:51,690
is a big change some of the changes

00:16:48,570 --> 00:16:53,730
there is a showed you that diagram or

00:16:51,690 --> 00:16:56,250
the memory cyst is different that is the

00:16:53,730 --> 00:16:57,720
current philosophy but now with opencl

00:16:56,250 --> 00:17:00,690
to its assuming that you can have a

00:16:57,720 --> 00:17:03,780
unified space so you share virtual

00:17:00,690 --> 00:17:05,700
addresses in fact across devices this

00:17:03,780 --> 00:17:08,370
will allow you to basically just grab

00:17:05,700 --> 00:17:10,850
data direct from your main memory system

00:17:08,370 --> 00:17:12,690
using as a GPU or something this

00:17:10,850 --> 00:17:16,790
sometimes I mean there's always corner

00:17:12,690 --> 00:17:19,200
cases on this it's adding c11 Atomics

00:17:16,790 --> 00:17:20,700
the problem with opencl is it the way

00:17:19,200 --> 00:17:22,980
that you do atomic operations has

00:17:20,700 --> 00:17:25,020
changed with every single release so

00:17:22,980 --> 00:17:26,600
changing them again one day we'll get

00:17:25,020 --> 00:17:29,820
them right one of the biggest

00:17:26,600 --> 00:17:31,260
philosophical changes is that devices

00:17:29,820 --> 00:17:32,580
can in queue their own kernel so a

00:17:31,260 --> 00:17:34,440
kernel is a function that you're telling

00:17:32,580 --> 00:17:36,540
the device to do something now instead

00:17:34,440 --> 00:17:38,100
of the hosts as I mentioned is telling

00:17:36,540 --> 00:17:41,130
you what to do now you can tell yourself

00:17:38,100 --> 00:17:42,900
to do something ok so this is beginning

00:17:41,130 --> 00:17:44,430
a change where you have a true

00:17:42,900 --> 00:17:45,950
distributed system and maybe this is

00:17:44,430 --> 00:17:47,690
where open sales going

00:17:45,950 --> 00:17:49,850
Chronos is very cagey as to what we're

00:17:47,690 --> 00:17:51,200
doing if you'd like to give them

00:17:49,850 --> 00:17:52,550
feedback you can give them a check for

00:17:51,200 --> 00:17:54,710
fifteen thousand USD and they will

00:17:52,550 --> 00:17:57,320
happily listen to you this is one of the

00:17:54,710 --> 00:18:00,080
things I posted on my blog to directly

00:17:57,320 --> 00:18:01,810
say you know this is a major issue with

00:18:00,080 --> 00:18:04,580
the way that the community is developing

00:18:01,810 --> 00:18:06,710
because hardware guys love to be secret

00:18:04,580 --> 00:18:09,020
and they're not really cooperating very

00:18:06,710 --> 00:18:10,580
well the software community but what

00:18:09,020 --> 00:18:13,700
theoretically will happen is that we may

00:18:10,580 --> 00:18:15,320
enter the situation in which you could

00:18:13,700 --> 00:18:16,700
have several devices operating

00:18:15,320 --> 00:18:19,060
themselves in a completely distributed

00:18:16,700 --> 00:18:21,110
way in your pc so you might have a

00:18:19,060 --> 00:18:22,940
system I don't want to get into too much

00:18:21,110 --> 00:18:24,620
of you know the next section we'll get

00:18:22,940 --> 00:18:26,120
that open sale is built for a very

00:18:24,620 --> 00:18:28,460
specific purpose right now of

00:18:26,120 --> 00:18:31,040
general-purpose computation and I think

00:18:28,460 --> 00:18:32,660
it can be a lot more than that but I

00:18:31,040 --> 00:18:34,610
don't want you to think that it is more

00:18:32,660 --> 00:18:35,990
than that now okay I'll get into these

00:18:34,610 --> 00:18:37,730
specific suggestions at the moment

00:18:35,990 --> 00:18:40,400
there's lots of other changes i'm not

00:18:37,730 --> 00:18:42,860
going to get into it another thing

00:18:40,400 --> 00:18:44,990
that's come out as SP ir which is a

00:18:42,860 --> 00:18:47,930
standard portable intermediate

00:18:44,990 --> 00:18:52,180
representation this is a kind of a

00:18:47,930 --> 00:18:54,890
global method of doing representation of

00:18:52,180 --> 00:18:56,600
you know it's an ir so you can think of

00:18:54,890 --> 00:18:58,100
it as kind of like a unified assembly

00:18:56,600 --> 00:18:59,720
language that rather than doing

00:18:58,100 --> 00:19:02,000
interpretation or something of a

00:18:59,720 --> 00:19:03,920
language i'm going to rather than giving

00:19:02,000 --> 00:19:08,810
you a C program I'm just going to hand

00:19:03,920 --> 00:19:10,310
you some sort of instructions and you if

00:19:08,810 --> 00:19:12,590
you have the implementation will quickly

00:19:10,310 --> 00:19:14,540
compile it to arm to Intel the GPU don't

00:19:12,590 --> 00:19:18,110
do an Intel processor to GPU whatever it

00:19:14,540 --> 00:19:20,030
is you have this is really neat I don't

00:19:18,110 --> 00:19:21,890
know I mean I'm not a hardware guy I've

00:19:20,030 --> 00:19:23,480
never written a compiler but I really

00:19:21,890 --> 00:19:25,640
don't know of any other time or you were

00:19:23,480 --> 00:19:27,320
able to write a single application with

00:19:25,640 --> 00:19:29,710
a single kind of portable assembly

00:19:27,320 --> 00:19:32,270
language that'll go to every vendors

00:19:29,710 --> 00:19:34,910
devices normally I think vendors really

00:19:32,270 --> 00:19:40,190
don't want that but now they're being

00:19:34,910 --> 00:19:42,490
really forced to do this there's a

00:19:40,190 --> 00:19:42,490
google thing

00:19:45,620 --> 00:19:55,440
but is it a low level I say then why is

00:19:49,530 --> 00:19:56,940
it in a web browser you know it's not

00:19:55,440 --> 00:19:58,140
against you but seriously like I see

00:19:56,940 --> 00:20:00,659
these things like why are you doing

00:19:58,140 --> 00:20:04,020
processor emulation in JavaScript use

00:20:00,659 --> 00:20:06,480
the processor but no I've never heard of

00:20:04,020 --> 00:20:09,600
this particular I say all of the stuff

00:20:06,480 --> 00:20:12,179
I'm describing is very low level very

00:20:09,600 --> 00:20:13,980
very low level it's going to be the goal

00:20:12,179 --> 00:20:15,750
of SP ir is actually do a very quick

00:20:13,980 --> 00:20:17,309
translation that i have this kind of

00:20:15,750 --> 00:20:20,850
unified is a and I very quickly

00:20:17,309 --> 00:20:22,950
translate to the ice a of this

00:20:20,850 --> 00:20:24,809
particular device the reasons they did

00:20:22,950 --> 00:20:25,980
it were for obfuscation which is kind of

00:20:24,809 --> 00:20:27,150
silly rather the port of it so this is

00:20:25,980 --> 00:20:28,650
an accident that we have this feature

00:20:27,150 --> 00:20:29,669
because I want to be secretive but they

00:20:28,650 --> 00:20:34,530
actually gave us something kind of cool

00:20:29,669 --> 00:20:35,549
in the name of secrecy you mean

00:20:34,530 --> 00:20:36,510
basically you're going to allow

00:20:35,549 --> 00:20:37,799
instructors because if you see the

00:20:36,510 --> 00:20:40,799
instructions you can never figure out

00:20:37,799 --> 00:20:42,390
what the program does you can write your

00:20:40,799 --> 00:20:44,720
own compiler I have a major issue with

00:20:42,390 --> 00:20:46,530
opencl see I actually really hate it

00:20:44,720 --> 00:20:48,659
that's probably because I do a lot of

00:20:46,530 --> 00:20:50,039
C++ but and I don't know how to see

00:20:48,659 --> 00:20:51,570
people do general data structures all

00:20:50,039 --> 00:20:55,020
this stuff I'm sure there is a way it's

00:20:51,570 --> 00:20:57,900
just not the way I think and what

00:20:55,020 --> 00:21:00,299
happens is that now we can actually cart

00:20:57,900 --> 00:21:01,980
we can build our own languages so SP ir

00:21:00,299 --> 00:21:05,760
is a very positive thing it's coming out

00:21:01,980 --> 00:21:06,870
Intel is the one who pushed this the SPI

00:21:05,760 --> 00:21:10,440
architecture is going to look a little

00:21:06,870 --> 00:21:12,000
bit like this no this is you're used to

00:21:10,440 --> 00:21:13,380
seeing this you know this is a

00:21:12,000 --> 00:21:15,390
no-brainer you know you have an

00:21:13,380 --> 00:21:16,590
application you can you c or c++ and it

00:21:15,390 --> 00:21:19,919
goes to an assembly language ooh

00:21:16,590 --> 00:21:21,809
interesting well profound but the thing

00:21:19,919 --> 00:21:24,270
is we can change the hardware now so you

00:21:21,809 --> 00:21:25,260
can actually independently change you

00:21:24,270 --> 00:21:26,909
know now you're going to run this on a

00:21:25,260 --> 00:21:29,010
cpu now you're gonna run on a GPU not

00:21:26,909 --> 00:21:30,600
gonna run on fpga and your same program

00:21:29,010 --> 00:21:32,429
you can adjust the compiler to target

00:21:30,600 --> 00:21:34,559
all these different things and if you

00:21:32,429 --> 00:21:38,030
want you could have javascript right

00:21:34,559 --> 00:21:40,169
underneath there you could totally do it

00:21:38,030 --> 00:21:43,409
high-performance javascript it's coming

00:21:40,169 --> 00:21:45,990
soon and don't worry so i'm going to

00:21:43,409 --> 00:21:47,520
talk about my feedback at this point

00:21:45,990 --> 00:21:49,530
you've seen basically would open sale is

00:21:47,520 --> 00:21:51,870
about at this point the biggest

00:21:49,530 --> 00:21:53,640
application of open sale is to hpc so if

00:21:51,870 --> 00:21:55,429
you're a group of engineers you probably

00:21:53,640 --> 00:21:58,050
want to use opencl for performance

00:21:55,429 --> 00:22:00,490
report ability

00:21:58,050 --> 00:22:01,750
but I want to provide a little bit more

00:22:00,490 --> 00:22:04,180
feedback so I'm going to pause here for

00:22:01,750 --> 00:22:06,400
a moment to ask if there's any basic

00:22:04,180 --> 00:22:08,230
questions if I everyone's confused as to

00:22:06,400 --> 00:22:25,680
what's going on if it makes basic sense

00:22:08,230 --> 00:22:25,680
and then we'll go from there okay so

00:22:26,910 --> 00:22:36,220
right so here's the interesting thing is

00:22:30,190 --> 00:22:37,450
it there is a portable subset of open

00:22:36,220 --> 00:22:41,140
sale but you have to figure out what it

00:22:37,450 --> 00:22:43,180
is I don't want to get well I don't want

00:22:41,140 --> 00:22:45,460
it mean see is not performance portable

00:22:43,180 --> 00:22:46,900
I mean there's the same C program on

00:22:45,460 --> 00:22:52,360
different hardware architectures could

00:22:46,900 --> 00:22:53,860
have very different performance but you

00:22:52,360 --> 00:22:56,140
will find that the compiler can do

00:22:53,860 --> 00:22:58,390
really good jobs with code structure to

00:22:56,140 --> 00:22:59,470
a certain way I don't want to get to

00:22:58,390 --> 00:23:08,650
advance do i can show you on a

00:22:59,470 --> 00:23:10,930
chalkboard or something but it can be

00:23:08,650 --> 00:23:13,570
done this is something I was working on

00:23:10,930 --> 00:23:21,670
doing benchmarks to publish to show that

00:23:13,570 --> 00:23:24,130
it can be done what it's it can be done

00:23:21,670 --> 00:23:26,470
but it's up to you to find out the

00:23:24,130 --> 00:23:30,550
subset that is portable that's not as

00:23:26,470 --> 00:23:32,020
big a challenge because the hardware

00:23:30,550 --> 00:23:34,740
vendors are kind of agreeing I mean

00:23:32,020 --> 00:23:36,730
everyone's using llvm in the back gap

00:23:34,740 --> 00:23:39,310
what's difficult with heterogeneous

00:23:36,730 --> 00:23:41,710
systems is that some systems natively

00:23:39,310 --> 00:23:46,600
supports a vectors vector operations

00:23:41,710 --> 00:23:49,210
some systems don't yeah so there is a

00:23:46,600 --> 00:23:51,190
subset that's portable but rather than

00:23:49,210 --> 00:23:52,330
forcing you to only write programs that

00:23:51,190 --> 00:23:53,350
can add two numbers because the only

00:23:52,330 --> 00:23:55,330
thing we can guarantee this portable

00:23:53,350 --> 00:23:57,970
it's a matter that you have to kind of

00:23:55,330 --> 00:24:00,310
search for where you get the losses and

00:23:57,970 --> 00:24:02,770
how acceptable they are but once someone

00:24:00,310 --> 00:24:04,360
demonstrates to you how to basically do

00:24:02,770 --> 00:24:05,890
that you can write something that's

00:24:04,360 --> 00:24:07,480
portable but I would also tell you that

00:24:05,890 --> 00:24:09,520
if you're trying to squeeze out every

00:24:07,480 --> 00:24:11,789
last cycle of your JavaScript opencl

00:24:09,520 --> 00:24:13,499
engine what's going to happen is

00:24:11,789 --> 00:24:16,109
you're going to always target that

00:24:13,499 --> 00:24:17,279
particular architecture anyways so what

00:24:16,109 --> 00:24:20,009
you really want is something that's

00:24:17,279 --> 00:24:22,229
performance portable enough but if you

00:24:20,009 --> 00:24:24,269
really really want the last bit of

00:24:22,229 --> 00:24:26,519
performance from that one processor you

00:24:24,269 --> 00:24:46,649
can do it hopefully that is answered

00:24:26,519 --> 00:24:48,989
your question yes the one of the

00:24:46,649 --> 00:24:50,249
intentions is that you who you might be

00:24:48,989 --> 00:24:53,009
calling something that you don't even

00:24:50,249 --> 00:24:55,559
know that behind the in the back end its

00:24:53,009 --> 00:24:57,599
encapsulation that you don't know that

00:24:55,559 --> 00:24:59,190
this thing is actually using whatever

00:24:57,599 --> 00:25:01,830
devices you have all you know is that

00:24:59,190 --> 00:25:05,849
this class now is faster sometimes

00:25:01,830 --> 00:25:07,649
mysteriously on this device so you can

00:25:05,849 --> 00:25:09,059
do this composition it gets much harder

00:25:07,649 --> 00:25:11,729
when you want to link opencl

00:25:09,059 --> 00:25:15,509
applications together where I have you

00:25:11,729 --> 00:25:17,669
know it's not impossible but extremely

00:25:15,509 --> 00:25:21,210
difficult to build libraries that you

00:25:17,669 --> 00:25:23,749
link of open CL C functions very very

00:25:21,210 --> 00:25:26,159
hard right now most of that is because

00:25:23,749 --> 00:25:29,220
we'll have to we'll have to bleep this

00:25:26,159 --> 00:25:31,859
the hardware guys don't necessarily have

00:25:29,220 --> 00:25:33,239
the same view that we do right to them

00:25:31,859 --> 00:25:35,159
their jobs done oh you can program the

00:25:33,239 --> 00:25:40,710
hardware okay we'd like to have a

00:25:35,159 --> 00:25:42,470
library a header file you know it's it's

00:25:40,710 --> 00:25:47,309
getting there honestly I think that

00:25:42,470 --> 00:25:49,320
opencl is not going to be directly used

00:25:47,309 --> 00:25:51,809
so much as you're going to generate SPI

00:25:49,320 --> 00:25:54,179
our code then I mean that's a that's the

00:25:51,809 --> 00:25:56,039
best thing about opencl is the spr code

00:25:54,179 --> 00:25:58,139
I think we'll see that other approaches

00:25:56,039 --> 00:26:00,450
where will generate that code and target

00:25:58,139 --> 00:26:02,159
and actually build reusable data

00:26:00,450 --> 00:26:04,440
structures that's why i love SBIR so

00:26:02,159 --> 00:26:08,460
much as I finally can get rid of open CL

00:26:04,440 --> 00:26:11,179
C will do one more question then i'll go

00:26:08,460 --> 00:26:11,179
so you

00:26:14,410 --> 00:26:29,860
I don't know anything about robotics I

00:26:26,790 --> 00:26:32,230
am a computer scientist which means that

00:26:29,860 --> 00:26:35,170
I sip coffee I and I draw pictures of

00:26:32,230 --> 00:26:40,360
programs as a bubble you know this

00:26:35,170 --> 00:26:42,550
program has its NC completes I'm done so

00:26:40,360 --> 00:26:45,580
I have proven that such an algorithm

00:26:42,550 --> 00:26:47,020
exists so I don't know the specific

00:26:45,580 --> 00:26:49,030
cases but let me get into my feedback

00:26:47,020 --> 00:26:54,460
now because I think you'll see how with

00:26:49,030 --> 00:26:56,560
a little bit of dust of some form we

00:26:54,460 --> 00:26:57,910
will be able to take open sale and make

00:26:56,560 --> 00:26:59,320
it a lot more powerful than what's been

00:26:57,910 --> 00:27:01,690
advertised to do and the question

00:26:59,320 --> 00:27:03,820
becomes does anyone want it to become

00:27:01,690 --> 00:27:05,890
this I think that we really the feedback

00:27:03,820 --> 00:27:08,200
I've provided provides an opportunity

00:27:05,890 --> 00:27:10,570
for opencl to become something much more

00:27:08,200 --> 00:27:15,160
than it probably has been intended to be

00:27:10,570 --> 00:27:17,680
so I really love this quote from a

00:27:15,160 --> 00:27:20,610
software project I don't use anymore but

00:27:17,680 --> 00:27:22,630
the the book had this nice quote it said

00:27:20,610 --> 00:27:24,070
deal with the thing well there's still

00:27:22,630 --> 00:27:26,530
nothing keep a thing in order before

00:27:24,070 --> 00:27:28,690
disaster sets in this is my man show for

00:27:26,530 --> 00:27:30,700
programming it's so easy when it's just

00:27:28,690 --> 00:27:32,740
a little bubbly thing to make a little

00:27:30,700 --> 00:27:36,190
line and as soon as you ship it i mean

00:27:32,740 --> 00:27:37,930
yeah game over so my motivation

00:27:36,190 --> 00:27:39,700
providing feedback to open sale right

00:27:37,930 --> 00:27:40,780
now a very strong feedback because i

00:27:39,700 --> 00:27:43,480
think we have an opportunity to fix

00:27:40,780 --> 00:27:46,390
things or to change things before we

00:27:43,480 --> 00:27:50,050
wind up having things that are features

00:27:46,390 --> 00:27:52,090
forever so most of my feedback is

00:27:50,050 --> 00:27:54,430
technical and requires background opencl

00:27:52,090 --> 00:27:56,560
and even if you had the background you

00:27:54,430 --> 00:27:59,860
would argue with me a lot so this is why

00:27:56,560 --> 00:28:01,900
we avoid it but there is a central piece

00:27:59,860 --> 00:28:03,550
of feedback that I'm giving which is

00:28:01,900 --> 00:28:05,080
that I'm advocating that we future-proof

00:28:03,550 --> 00:28:06,130
programs I'm one of these strange people

00:28:05,080 --> 00:28:07,960
that I don't like having to rewrite

00:28:06,130 --> 00:28:09,520
software every three days because the

00:28:07,960 --> 00:28:12,460
API is changed I don't know what that is

00:28:09,520 --> 00:28:16,150
but once I ship it is not my problem it

00:28:12,460 --> 00:28:18,370
should continue to work so this is the

00:28:16,150 --> 00:28:21,370
this is the feedback and here's my

00:28:18,370 --> 00:28:23,040
objectives my main objective is to

00:28:21,370 --> 00:28:25,510
separate hardware and software concerns

00:28:23,040 --> 00:28:27,460
we have to acknowledge you know as

00:28:25,510 --> 00:28:27,970
software people we can design for

00:28:27,460 --> 00:28:29,770
problems

00:28:27,970 --> 00:28:32,110
you can design some 14 people problems

00:28:29,770 --> 00:28:34,570
no matter what we say the hardware

00:28:32,110 --> 00:28:35,920
vendors will stay secretive so maybe we

00:28:34,570 --> 00:28:39,610
can design to accommodate for this

00:28:35,920 --> 00:28:41,440
feature of their community we want the

00:28:39,610 --> 00:28:43,060
software community to be as open as

00:28:41,440 --> 00:28:44,320
possible that's probably why we're here

00:28:43,060 --> 00:28:47,650
I don't think anyone will disagree with

00:28:44,320 --> 00:28:49,660
that in this audience and I want to

00:28:47,650 --> 00:28:51,730
improve program portability right now I

00:28:49,660 --> 00:28:54,580
can't really take an open CL application

00:28:51,730 --> 00:28:57,700
it's programmed for opencl 1.0 I can't

00:28:54,580 --> 00:29:02,500
even link it to an open CL 1.1 library

00:28:57,700 --> 00:29:04,920
this is a disaster so you know there's

00:29:02,500 --> 00:29:07,000
no stable API you know again the

00:29:04,920 --> 00:29:08,320
hardware guys have done great but it's

00:29:07,000 --> 00:29:10,480
time for us to come in and they need to

00:29:08,320 --> 00:29:12,790
give us the tools and we will finish the

00:29:10,480 --> 00:29:16,810
job okay so we need to anticipate major

00:29:12,790 --> 00:29:18,910
changes and we need to keep softer

00:29:16,810 --> 00:29:21,880
running even though we know opencl has

00:29:18,910 --> 00:29:23,560
to change and you know one of the

00:29:21,880 --> 00:29:25,210
reasons for that is it any specification

00:29:23,560 --> 00:29:27,730
we do today is going to be wrong

00:29:25,210 --> 00:29:29,530
tomorrow this isn't pessimism this is

00:29:27,730 --> 00:29:30,940
the nature of parallel programming and

00:29:29,530 --> 00:29:32,950
high performance computing today's we

00:29:30,940 --> 00:29:35,470
really don't know what to do we're kind

00:29:32,950 --> 00:29:37,210
of stuck because our machine has changed

00:29:35,470 --> 00:29:38,710
in ways we can't even understand I mean

00:29:37,210 --> 00:29:40,480
how many of us are familiar with time

00:29:38,710 --> 00:29:42,730
complexity like Big O notation right

00:29:40,480 --> 00:29:45,070
hopefully all of us is there such a

00:29:42,730 --> 00:29:47,380
thing for parallel algorithms not really

00:29:45,070 --> 00:29:49,750
it's really hard to even describe a

00:29:47,380 --> 00:29:52,690
parallel album there's no parallel model

00:29:49,750 --> 00:29:54,550
of computation that we have yet so it's

00:29:52,690 --> 00:29:56,410
not likely that opencl is the perfect

00:29:54,550 --> 00:29:59,440
one that's going to work so we have to

00:29:56,410 --> 00:30:02,080
say that we want to be performance we

00:29:59,440 --> 00:30:04,300
want to acknowledge that we're still at

00:30:02,080 --> 00:30:05,860
the beginning of this journey of

00:30:04,300 --> 00:30:07,450
parallel programming abstractions and

00:30:05,860 --> 00:30:11,380
that the computer architectures are

00:30:07,450 --> 00:30:13,420
changing and we do want even in the face

00:30:11,380 --> 00:30:14,620
of this complete change to bear in mind

00:30:13,420 --> 00:30:17,470
that we want software we write today

00:30:14,620 --> 00:30:20,020
continues to work tomorrow right I was

00:30:17,470 --> 00:30:22,080
working at a company that used it was

00:30:20,020 --> 00:30:27,010
the year of Linux desktop for them since

00:30:22,080 --> 00:30:29,130
1996 but they basically are still

00:30:27,010 --> 00:30:31,570
running I don't favorite sort of applix

00:30:29,130 --> 00:30:34,540
really old word processor for sun

00:30:31,570 --> 00:30:37,630
they're still running it fine no issues

00:30:34,540 --> 00:30:39,280
right that's because the ABI 4x has not

00:30:37,630 --> 00:30:39,770
changed since what make an 87 or

00:30:39,280 --> 00:30:42,740
whatever

00:30:39,770 --> 00:30:46,520
and you know like you want to be in that

00:30:42,740 --> 00:30:48,440
position for opencl because we shouldn't

00:30:46,520 --> 00:30:51,260
just break applications because you know

00:30:48,440 --> 00:30:53,030
you have to get the cool update I mean I

00:30:51,260 --> 00:30:55,400
still play quest for glory on boss box

00:30:53,030 --> 00:30:57,170
every night you know like and is in fact

00:30:55,400 --> 00:30:58,850
you know I was so happy to get a GPU

00:30:57,170 --> 00:31:00,290
because normally i just had one with vga

00:30:58,850 --> 00:31:02,480
things and i could actually play games

00:31:00,290 --> 00:31:04,850
so i went like doom 3 this is awesome

00:31:02,480 --> 00:31:08,420
there's 2009 but you know got there

00:31:04,850 --> 00:31:09,590
figured it out one of the other

00:31:08,420 --> 00:31:10,730
assumptions I'm going to reduce is it

00:31:09,590 --> 00:31:12,140
top performance software is

00:31:10,730 --> 00:31:13,460
hardware-specific I don't think anyone's

00:31:12,140 --> 00:31:16,100
going to argue with that even between

00:31:13,460 --> 00:31:18,410
you know intel processor AMD processor

00:31:16,100 --> 00:31:20,450
if you really want that much performance

00:31:18,410 --> 00:31:22,250
there's minor things are gonna have to

00:31:20,450 --> 00:31:23,930
take into account ok so these are the

00:31:22,250 --> 00:31:25,400
assumptions and hardware vendors are

00:31:23,930 --> 00:31:27,080
going to keep adding features and never

00:31:25,400 --> 00:31:29,210
tell us into the last second you know we

00:31:27,080 --> 00:31:30,590
have to call me for that so I'm going to

00:31:29,210 --> 00:31:31,520
do something called capabilities it's

00:31:30,590 --> 00:31:33,650
been brought to my attention that

00:31:31,520 --> 00:31:35,150
something like this was done and by some

00:31:33,650 --> 00:31:37,090
company that starts with an m and ends

00:31:35,150 --> 00:31:39,860
with his soft I don't know these people

00:31:37,090 --> 00:31:41,600
I so of course I never heard of this

00:31:39,860 --> 00:31:44,150
approach it was something and direct3d

00:31:41,600 --> 00:31:45,950
or whatever not a graphics person to me

00:31:44,150 --> 00:31:48,410
graphics of a GPU is a historical

00:31:45,950 --> 00:31:50,930
artifact I'm arrested general-purpose

00:31:48,410 --> 00:31:53,570
stuff so I'm going to propose that we

00:31:50,930 --> 00:31:55,220
have a capability interface capabilities

00:31:53,570 --> 00:31:57,530
and isolated well defined and externally

00:31:55,220 --> 00:31:59,840
documented component of opencl it's all

00:31:57,530 --> 00:32:01,310
you need to know about okay and here's

00:31:59,840 --> 00:32:05,030
some examples of capabilities you could

00:32:01,310 --> 00:32:06,050
have the memory model of opencl we want

00:32:05,030 --> 00:32:07,460
the memory more will be able to change

00:32:06,050 --> 00:32:09,140
independently so let's just say that

00:32:07,460 --> 00:32:11,300
this is the memory model that we have

00:32:09,140 --> 00:32:13,940
right now hardware transactional memory

00:32:11,300 --> 00:32:14,930
I mean even memories and sacred how many

00:32:13,940 --> 00:32:16,700
people are familiar with hardware

00:32:14,930 --> 00:32:21,200
transactional memory up-and-coming yeah

00:32:16,700 --> 00:32:23,150
so I mean even our precious box of RAM

00:32:21,200 --> 00:32:24,500
is changing right and how can we a

00:32:23,150 --> 00:32:26,480
software developers accommodate for this

00:32:24,500 --> 00:32:29,840
but we should take into account that

00:32:26,480 --> 00:32:32,570
opencl 3.2 might have hardwood trees

00:32:29,840 --> 00:32:34,400
actual memory support another capability

00:32:32,570 --> 00:32:36,110
has nothing to do with the memory model

00:32:34,400 --> 00:32:38,300
but maybe we just have a device that can

00:32:36,110 --> 00:32:40,000
provide random bits to us that's all it

00:32:38,300 --> 00:32:43,430
does is gives us some random information

00:32:40,000 --> 00:32:44,750
some of this may be I mean many of us

00:32:43,430 --> 00:32:47,780
have accidentally written sources of

00:32:44,750 --> 00:32:50,450
random bits but it might be a good

00:32:47,780 --> 00:32:52,730
source of random bits matrix operations

00:32:50,450 --> 00:32:53,510
you know maybe maybe what we want is

00:32:52,730 --> 00:32:55,940
something that's really

00:32:53,510 --> 00:32:57,650
fast at matrix operations okay maybe

00:32:55,940 --> 00:33:00,440
it's really good at on image operations

00:32:57,650 --> 00:33:02,420
images are already are a part of opencl

00:33:00,440 --> 00:33:04,700
and I really don't like them because

00:33:02,420 --> 00:33:06,140
they have there's a philosophical

00:33:04,700 --> 00:33:08,330
problems with image processing on a

00:33:06,140 --> 00:33:10,030
graphics processing unit and I mean I'm

00:33:08,330 --> 00:33:12,890
very popular when I bring this up but

00:33:10,030 --> 00:33:15,170
image processing is a conceptual problem

00:33:12,890 --> 00:33:17,330
because I should be able to write a

00:33:15,170 --> 00:33:19,130
library that does image processing in a

00:33:17,330 --> 00:33:21,320
nice way with something like opencl but

00:33:19,130 --> 00:33:23,390
I can't if you read the articles on my

00:33:21,320 --> 00:33:25,790
blog I go into detail as to exactly why

00:33:23,390 --> 00:33:28,550
we can't build a library how to amend

00:33:25,790 --> 00:33:30,980
the language so that we can and we'll

00:33:28,550 --> 00:33:33,050
see how far that goes so this is a

00:33:30,980 --> 00:33:34,460
capability interface basically I'm

00:33:33,050 --> 00:33:36,740
proposing is that you still have your

00:33:34,460 --> 00:33:38,990
host you have implementations and I can

00:33:36,740 --> 00:33:42,200
just ask you what can you do it'll tell

00:33:38,990 --> 00:33:46,040
you I can provide you with random bits I

00:33:42,200 --> 00:33:47,900
know what an image is or I do hardware

00:33:46,040 --> 00:33:49,400
transactional memory right so

00:33:47,900 --> 00:33:50,810
programming wise you don't want to

00:33:49,400 --> 00:33:52,340
program this directly but you're able to

00:33:50,810 --> 00:33:54,890
enumerate what it is you assume you have

00:33:52,340 --> 00:33:56,570
and the architecture of the application

00:33:54,890 --> 00:33:59,600
is going to change a little bit so you

00:33:56,570 --> 00:34:00,890
have capabilities that are going to tap

00:33:59,600 --> 00:34:02,780
into the hardware and you know it's

00:34:00,890 --> 00:34:04,310
going to tell you what can you do and

00:34:02,780 --> 00:34:05,660
one of the reasons you want capabilities

00:34:04,310 --> 00:34:09,169
is you know I went to a presentation

00:34:05,660 --> 00:34:10,520
this morning on arm and I mean we're

00:34:09,169 --> 00:34:14,090
entering this world where I'm

00:34:10,520 --> 00:34:16,429
programming something and the the reason

00:34:14,090 --> 00:34:17,770
that I want to use this device because

00:34:16,429 --> 00:34:20,210
it's really fast at integer operations

00:34:17,770 --> 00:34:21,679
so why don't I say what I'm looking for

00:34:20,210 --> 00:34:24,169
is something really fast at integer

00:34:21,679 --> 00:34:26,300
operations and allow the system to

00:34:24,169 --> 00:34:28,100
determine what is best to do interrupt

00:34:26,300 --> 00:34:30,620
your operations right now maybe it's a

00:34:28,100 --> 00:34:32,540
GPU maybe at some point the source of

00:34:30,620 --> 00:34:33,679
say random bits is a raid controller or

00:34:32,540 --> 00:34:36,190
network controller has some sort of

00:34:33,679 --> 00:34:39,169
feature you can just suck it out right

00:34:36,190 --> 00:34:42,440
so what I propose is basically this kind

00:34:39,169 --> 00:34:44,000
of thing and what's going to happen did

00:34:42,440 --> 00:34:45,679
you basically take opencl and you snip

00:34:44,000 --> 00:34:46,879
it in the different parts your package

00:34:45,679 --> 00:34:49,550
the Miss capabilities and there's some

00:34:46,879 --> 00:34:51,649
advantages to this the first advantage

00:34:49,550 --> 00:34:53,570
is it eliminates opencl versions I don't

00:34:51,649 --> 00:34:54,889
know about you but i think that sea

00:34:53,570 --> 00:34:56,240
would not have been so popular if there

00:34:54,889 --> 00:34:59,180
is a see one point to which broke

00:34:56,240 --> 00:35:01,430
compatibility to C 1.1 and 1.0 you know

00:34:59,180 --> 00:35:03,230
I'm not a fan of this versioning and we

00:35:01,430 --> 00:35:04,730
don't need versions if we say that you

00:35:03,230 --> 00:35:06,560
know we have these capabilities you can

00:35:04,730 --> 00:35:07,460
do this you can do this you can do this

00:35:06,560 --> 00:35:09,230
your memory model these are the

00:35:07,460 --> 00:35:10,880
functions you can call so a capability

00:35:09,230 --> 00:35:13,130
would provide in my version of the world

00:35:10,880 --> 00:35:16,400
maybe some instructions in SP ir or it

00:35:13,130 --> 00:35:18,260
would provide api functions or would be

00:35:16,400 --> 00:35:23,200
a pseudo capability that just tells us

00:35:18,260 --> 00:35:25,280
this is how it views memory okay and

00:35:23,200 --> 00:35:27,890
there's something called a custom device

00:35:25,280 --> 00:35:29,840
and opencl so open CL is full of

00:35:27,890 --> 00:35:31,910
exemptions there's some popular health

00:35:29,840 --> 00:35:34,370
care systems are like this but you know

00:35:31,910 --> 00:35:36,560
we basically say oh this is open CL but

00:35:34,370 --> 00:35:38,960
guess what you could be a custom device

00:35:36,560 --> 00:35:41,510
and then none of the supplies so it's

00:35:38,960 --> 00:35:43,220
really kind of a broken standard there's

00:35:41,510 --> 00:35:44,930
also a full and embedded profile so the

00:35:43,220 --> 00:35:46,520
behavior opencl is different if you're

00:35:44,930 --> 00:35:48,830
an embedded processor but first as a

00:35:46,520 --> 00:35:50,360
normal processor technically it doesn't

00:35:48,830 --> 00:35:52,520
matter the processor because they're

00:35:50,360 --> 00:35:53,960
trying to extract it but we can get rid

00:35:52,520 --> 00:35:55,340
of that because it doesn't matter you

00:35:53,960 --> 00:35:58,250
just have some set of features you

00:35:55,340 --> 00:35:59,540
support some set that you don't and will

00:35:58,250 --> 00:36:01,970
most important thing is this provides a

00:35:59,540 --> 00:36:03,980
stable API because what you do is rather

00:36:01,970 --> 00:36:06,230
than exporting the symbols you export

00:36:03,980 --> 00:36:08,540
something like I octal and use inline

00:36:06,230 --> 00:36:09,740
ish see things and I've been told

00:36:08,540 --> 00:36:13,640
there's a way to do in line and see I

00:36:09,740 --> 00:36:15,050
don't know it but theoretically you know

00:36:13,640 --> 00:36:16,880
what you want is to be able to have an

00:36:15,050 --> 00:36:19,250
ABI and I do outline this on my blog

00:36:16,880 --> 00:36:20,990
that's very simple like five functions

00:36:19,250 --> 00:36:24,140
and all it's doing is allowing you to

00:36:20,990 --> 00:36:25,070
kind of make calls through it in a way

00:36:24,140 --> 00:36:27,650
that you don't have to change the

00:36:25,070 --> 00:36:29,360
symbols ever and if you do that if we

00:36:27,650 --> 00:36:31,640
have this capability interface we wind

00:36:29,360 --> 00:36:34,030
up being in a nice situation where all

00:36:31,640 --> 00:36:36,950
the sudden maybe I can say you know this

00:36:34,030 --> 00:36:39,910
is what I need to have this capability

00:36:36,950 --> 00:36:43,790
is gone but maybe I can emulate it okay

00:36:39,910 --> 00:36:46,010
so that's the concept of concept and

00:36:43,790 --> 00:36:47,120
source translation maybe we have a new

00:36:46,010 --> 00:36:48,650
processor which does hardware

00:36:47,120 --> 00:36:51,320
transactional memory and we have the old

00:36:48,650 --> 00:36:53,480
memory model but we can take your old

00:36:51,320 --> 00:36:56,300
memory model calls and translate them to

00:36:53,480 --> 00:36:57,770
the assist of course we're going to want

00:36:56,300 --> 00:37:00,200
to be able to rewrite our software to

00:36:57,770 --> 00:37:02,810
get top performance but we have to bear

00:37:00,200 --> 00:37:04,940
in mind that sometimes the advantage is

00:37:02,810 --> 00:37:07,550
offered by a system emulating the old

00:37:04,940 --> 00:37:09,950
system is far better than what you're

00:37:07,550 --> 00:37:11,930
doing now so for example if you come out

00:37:09,950 --> 00:37:14,480
with a processor that's just simply ten

00:37:11,930 --> 00:37:16,760
times faster it doesn't really matter

00:37:14,480 --> 00:37:19,460
that you're emulating anymore you're

00:37:16,760 --> 00:37:21,080
taking a hit of twenty percent it's okay

00:37:19,460 --> 00:37:23,390
because your customers can start to use

00:37:21,080 --> 00:37:25,190
it right now and then they get to pay

00:37:23,390 --> 00:37:26,390
you for the patch which gives the full

00:37:25,190 --> 00:37:27,800
performance you know there's a whole

00:37:26,390 --> 00:37:30,770
skin so I'm wearing the suit you know

00:37:27,800 --> 00:37:32,270
this is a is a trick to this but it's

00:37:30,770 --> 00:37:33,860
different the other model is pay you

00:37:32,270 --> 00:37:38,030
know we just break it and then work

00:37:33,860 --> 00:37:39,860
anymore not 1.2 compliant you know and

00:37:38,030 --> 00:37:41,570
here's another advantage of the

00:37:39,860 --> 00:37:43,880
capability interface let's say there is

00:37:41,570 --> 00:37:45,500
a really popular capability like image

00:37:43,880 --> 00:37:47,480
manipulation you know actually that's

00:37:45,500 --> 00:37:48,770
about example that one resist but say

00:37:47,480 --> 00:37:50,330
another one you know to me it doesn't

00:37:48,770 --> 00:37:52,280
exist but another really popular

00:37:50,330 --> 00:37:53,840
capability maybe matrix operations and

00:37:52,280 --> 00:37:55,760
because we've defined that matrix

00:37:53,840 --> 00:37:57,800
operations have this API call have this

00:37:55,760 --> 00:37:58,880
capability our hardware vendor can come

00:37:57,800 --> 00:38:00,770
in and say you know what we're going to

00:37:58,880 --> 00:38:03,440
build this into the hardware we export

00:38:00,770 --> 00:38:04,490
the capability and now by using it you

00:38:03,440 --> 00:38:05,780
don't know that you're not being

00:38:04,490 --> 00:38:08,120
emulated now you're all of a sudden

00:38:05,780 --> 00:38:11,270
running on the hardware but you have not

00:38:08,120 --> 00:38:14,180
changed the program at all so this is

00:38:11,270 --> 00:38:16,670
what opencl is to me which is very

00:38:14,180 --> 00:38:17,780
contentious because you know it leads

00:38:16,670 --> 00:38:21,260
you to fights with people who know

00:38:17,780 --> 00:38:23,210
opencl so my proposed philosophy is a

00:38:21,260 --> 00:38:25,430
little bit different open sale remains a

00:38:23,210 --> 00:38:26,930
low-level standard that hasn't changed i

00:38:25,430 --> 00:38:28,700
mean we're not suddenly going to do java

00:38:26,930 --> 00:38:30,200
well sorry i shouldn't say that there's

00:38:28,700 --> 00:38:33,440
something called a rappy or whatever

00:38:30,200 --> 00:38:35,600
which actually is javon open sale but to

00:38:33,440 --> 00:38:37,940
me low-level I mean I'm all these people

00:38:35,600 --> 00:38:40,490
that you know if I'm not at like the

00:38:37,940 --> 00:38:42,350
very why work below sea level right so

00:38:40,490 --> 00:38:43,700
you want to be as close to the

00:38:42,350 --> 00:38:45,500
hardware's possible for top performance

00:38:43,700 --> 00:38:46,970
that's the intention of opencl but you

00:38:45,500 --> 00:38:48,800
can have higher level abstractions that

00:38:46,970 --> 00:38:53,060
have minor penalties but make you more

00:38:48,800 --> 00:38:56,270
productive my philosophy amendment would

00:38:53,060 --> 00:38:58,040
be that there is no set of abstractions

00:38:56,270 --> 00:38:59,600
that are correct we have to deal with

00:38:58,040 --> 00:39:01,610
change and we should be able to take a

00:38:59,600 --> 00:39:03,710
program written against the bad

00:39:01,610 --> 00:39:05,540
assumptions and see if we can do some

00:39:03,710 --> 00:39:07,310
sort of translation I'm not saying

00:39:05,540 --> 00:39:09,800
interpretation or anything i'm talking

00:39:07,310 --> 00:39:14,390
potentially translation of the the raw i

00:39:09,800 --> 00:39:16,970
say or something like that this becomes

00:39:14,390 --> 00:39:18,980
a buzz word open sale becomes a

00:39:16,970 --> 00:39:20,780
service-oriented architecture how many

00:39:18,980 --> 00:39:24,980
of you have heard that buzz word so

00:39:20,780 --> 00:39:26,390
there we go and i kind of have this

00:39:24,980 --> 00:39:28,490
weird approach to programming right kind

00:39:26,390 --> 00:39:30,680
of wander all over the place but this

00:39:28,490 --> 00:39:32,240
would allow opencl to kind of satisfy a

00:39:30,680 --> 00:39:33,710
little bit of the intention of good

00:39:32,240 --> 00:39:35,450
computing in some sense

00:39:33,710 --> 00:39:38,420
that you're able to say you know what do

00:39:35,450 --> 00:39:41,300
you have this mr. hardware and mr.

00:39:38,420 --> 00:39:44,390
hardware says I have this I have that I

00:39:41,300 --> 00:39:45,530
have this or these capabilities I'm not

00:39:44,390 --> 00:39:46,910
telling you that they're even

00:39:45,530 --> 00:39:49,160
necessarily hardware they might be

00:39:46,910 --> 00:39:51,349
providing you an illusion of a piece of

00:39:49,160 --> 00:39:54,680
software that's dispatching to the cloud

00:39:51,349 --> 00:39:56,690
and if if you hack it properly the NSA

00:39:54,680 --> 00:39:59,060
can see all your computations so it's a

00:39:56,690 --> 00:40:01,460
win-win scenario you know if you

00:39:59,060 --> 00:40:03,349
randomly generate bits that are bad you

00:40:01,460 --> 00:40:05,180
know you're you're really gonna have a

00:40:03,349 --> 00:40:08,089
bad day so be careful the bits you

00:40:05,180 --> 00:40:09,410
generate I've always wondered what

00:40:08,089 --> 00:40:14,210
happens if you randomly generate a

00:40:09,410 --> 00:40:16,099
copyright movie it's possible i mean

00:40:14,210 --> 00:40:20,780
it's it's mathematically there's a

00:40:16,099 --> 00:40:21,980
probability what's that well it's the

00:40:20,780 --> 00:40:26,450
infinite monkeys but it's also the

00:40:21,980 --> 00:40:28,820
infinite lawyers infinite penalties

00:40:26,450 --> 00:40:32,570
that's why you moved to New Zealand Kim

00:40:28,820 --> 00:40:35,119
calm had some success with that some no

00:40:32,570 --> 00:40:37,099
so the idea is that applications really

00:40:35,119 --> 00:40:39,560
are discovering services what can you do

00:40:37,099 --> 00:40:40,910
and I know that this is going to be hard

00:40:39,560 --> 00:40:42,740
sell to Intel what the heck is a

00:40:40,910 --> 00:40:45,109
service-oriented architecture and what I

00:40:42,740 --> 00:40:46,220
mean this is a processor but look at

00:40:45,109 --> 00:40:49,369
processors look how much they've changed

00:40:46,220 --> 00:40:51,920
you know processors we have SSC has

00:40:49,369 --> 00:40:53,570
different versions right the processor

00:40:51,920 --> 00:40:55,430
capabilities are changing how we have

00:40:53,570 --> 00:40:56,930
hardware transactional memory so I see

00:40:55,430 --> 00:40:58,490
this as a good way of I'm kind of

00:40:56,930 --> 00:41:00,710
warning you that 10 years from now

00:40:58,490 --> 00:41:03,260
things are going to be very bad unless

00:41:00,710 --> 00:41:05,660
we take some minimal steps to protect

00:41:03,260 --> 00:41:08,390
ourselves from what's going to change in

00:41:05,660 --> 00:41:09,710
the future and the nice thing is that

00:41:08,390 --> 00:41:11,810
service is compl amended in software

00:41:09,710 --> 00:41:13,580
hardware so if you see me now you have a

00:41:11,810 --> 00:41:14,990
new opportunity you do profiling you see

00:41:13,580 --> 00:41:16,730
that ninety percent of your time is

00:41:14,990 --> 00:41:17,960
spent running this function you've tuned

00:41:16,730 --> 00:41:20,300
that you've tuned it is still not fast

00:41:17,960 --> 00:41:23,260
enough have some custom hardware built

00:41:20,300 --> 00:41:26,660
attach it there you go very fast now and

00:41:23,260 --> 00:41:29,270
you know for the JavaScript people maybe

00:41:26,660 --> 00:41:32,210
there's some sort of rendering thing

00:41:29,270 --> 00:41:34,550
right so I mean that's in our JavaScript

00:41:32,210 --> 00:41:36,670
but like you can suddenly build these

00:41:34,550 --> 00:41:39,050
really high level things that are very

00:41:36,670 --> 00:41:40,849
efficient and hardware that you just

00:41:39,050 --> 00:41:44,390
can't do with general purpose systems

00:41:40,849 --> 00:41:45,680
because general purpose systems are you

00:41:44,390 --> 00:41:47,170
know they pretend to be high level but

00:41:45,680 --> 00:41:49,610
they're very low level

00:41:47,170 --> 00:41:52,130
and the you know middleware another

00:41:49,610 --> 00:41:53,150
buzzword to throw at you is the idea is

00:41:52,130 --> 00:41:55,070
that you want something you don't use

00:41:53,150 --> 00:41:56,450
this capability interfaces ever directly

00:41:55,070 --> 00:41:59,360
you want to use something else that's

00:41:56,450 --> 00:42:00,800
going to help you along and as Tim

00:41:59,360 --> 00:42:03,170
Matson said we want to have this

00:42:00,800 --> 00:42:04,850
situation where we're searching for

00:42:03,170 --> 00:42:06,680
abstractions so if I generate

00:42:04,850 --> 00:42:07,910
abstractions that are really nice you

00:42:06,680 --> 00:42:09,830
should use my abstractions and I'll

00:42:07,910 --> 00:42:11,720
translate to these capabilities and the

00:42:09,830 --> 00:42:13,670
capabilities that I use may change over

00:42:11,720 --> 00:42:14,930
time because I may say that you know

00:42:13,670 --> 00:42:16,220
what now that I have this new hardware

00:42:14,930 --> 00:42:18,080
I'm just going to switch and use

00:42:16,220 --> 00:42:19,370
something else but if you think about it

00:42:18,080 --> 00:42:22,610
carefully what I've outlined will

00:42:19,370 --> 00:42:26,240
maintain binary compatibility with a

00:42:22,610 --> 00:42:29,120
heterogeneous system and there is a

00:42:26,240 --> 00:42:32,110
final word and you knew this was coming

00:42:29,120 --> 00:42:34,190
is if you have any spare change

00:42:32,110 --> 00:42:36,320
consulting work funds everything I do

00:42:34,190 --> 00:42:37,520
for open source so the middleware that

00:42:36,320 --> 00:42:38,840
I'm developing so I'm doing a couple

00:42:37,520 --> 00:42:41,830
things right now this capability

00:42:38,840 --> 00:42:47,140
interface I have been discussing with

00:42:41,830 --> 00:42:49,310
some members of the opencl committee who

00:42:47,140 --> 00:42:52,040
fortunately introduced themselves to me

00:42:49,310 --> 00:42:53,270
and i'll be discussing you know they've

00:42:52,040 --> 00:42:54,290
looked at my blog but i don't know what

00:42:53,270 --> 00:42:56,300
they think of the blog they're just

00:42:54,290 --> 00:42:58,220
being polite if they like it or what but

00:42:56,300 --> 00:43:00,380
you know very direct person will just

00:42:58,220 --> 00:43:01,400
ask hopefully is not reading this yet

00:43:00,380 --> 00:43:03,830
we'll make sure this is posted after

00:43:01,400 --> 00:43:05,750
that phone call but the idea is that I

00:43:03,830 --> 00:43:06,830
think that I can do the capability

00:43:05,750 --> 00:43:08,960
interface now and that's what I've

00:43:06,830 --> 00:43:10,610
started to do is decomposed it so that

00:43:08,960 --> 00:43:12,170
we have us but if you don't have buy-in

00:43:10,610 --> 00:43:15,260
from the standards organization your

00:43:12,170 --> 00:43:17,150
life is going to be so awful because

00:43:15,260 --> 00:43:18,650
it's going to be a continuous you know

00:43:17,150 --> 00:43:20,600
I'm doing all the job of making their

00:43:18,650 --> 00:43:22,250
stuff usable and they don't care they

00:43:20,600 --> 00:43:24,410
continually play this game of making it

00:43:22,250 --> 00:43:26,120
more unusable so what I'm trying to do

00:43:24,410 --> 00:43:29,090
is do a prototype implementation to

00:43:26,120 --> 00:43:31,640
demonstrate the advantages it is a big

00:43:29,090 --> 00:43:33,530
problem with linking opencl applications

00:43:31,640 --> 00:43:36,140
if you build with opencl 1.0 you can't

00:43:33,530 --> 00:43:38,450
link to 1.2 with this system you could

00:43:36,140 --> 00:43:40,430
link it so there is an opportunity my

00:43:38,450 --> 00:43:43,910
intention is to release this under an

00:43:40,430 --> 00:43:46,670
open source license probably something

00:43:43,910 --> 00:43:50,240
very permissive we'll see about that and

00:43:46,670 --> 00:43:52,640
I'm also working on a another version of

00:43:50,240 --> 00:43:54,170
opencl middleware that will use this to

00:43:52,640 --> 00:43:57,590
provide those higher level abstractions

00:43:54,170 --> 00:43:59,150
so if you use this c++ library the

00:43:57,590 --> 00:44:00,690
capabilities on so I mean what I'm

00:43:59,150 --> 00:44:03,630
trying to propose is the capability

00:44:00,690 --> 00:44:04,859
would change underneath and everything

00:44:03,630 --> 00:44:07,619
else will just continue to work so

00:44:04,859 --> 00:44:08,910
that's the introduction you can i will

00:44:07,619 --> 00:44:09,839
be posting i mean if this video is

00:44:08,910 --> 00:44:11,280
coming up it saves me some time

00:44:09,839 --> 00:44:13,260
otherwise i'll post a youtube video of

00:44:11,280 --> 00:44:14,609
the same kind of talk the slides will be

00:44:13,260 --> 00:44:18,540
on my blog i encourage you to read the

00:44:14,609 --> 00:44:19,740
blog and contact me and I have some

00:44:18,540 --> 00:44:22,109
business cards up here if you're

00:44:19,740 --> 00:44:24,119
interested in if you if you buy me

00:44:22,109 --> 00:44:25,079
something potentially coffee I may be

00:44:24,119 --> 00:44:30,089
able to give you a lot of free advice

00:44:25,079 --> 00:44:31,349
and if you buy me breakfast I'll give

00:44:30,089 --> 00:44:35,520
you a couple hours of you know

00:44:31,349 --> 00:44:37,230
programming work or something so that's

00:44:35,520 --> 00:44:38,460
one of the things with open source is it

00:44:37,230 --> 00:44:40,230
I love open source but right now I'm

00:44:38,460 --> 00:44:43,290
really trying to figure out how exactly

00:44:40,230 --> 00:44:45,480
to to follow the open source and not

00:44:43,290 --> 00:44:47,520
work for a company that's going to own

00:44:45,480 --> 00:44:50,359
me because I dared get training and then

00:44:47,520 --> 00:44:53,430
sign a contract to be paid by them so

00:44:50,359 --> 00:44:54,690
now if there's any questions or comments

00:44:53,430 --> 00:44:57,450
or you completely disagree with my

00:44:54,690 --> 00:45:01,040
version of opencl let me know hopefully

00:44:57,450 --> 00:45:08,910
I've motivated it in an interesting way

00:45:01,040 --> 00:45:10,800
before Joe hacker probably thinks you

00:45:08,910 --> 00:45:13,319
can program it open CEO Joe hacker

00:45:10,800 --> 00:45:16,260
should really wait this is still a low

00:45:13,319 --> 00:45:17,970
level performance system and as you

00:45:16,260 --> 00:45:20,520
notice you bypass the operating system

00:45:17,970 --> 00:45:23,700
this is a big issue if you do while one

00:45:20,520 --> 00:45:25,890
guess what you free 0s because the

00:45:23,700 --> 00:45:28,109
driver people don't really play nice as

00:45:25,890 --> 00:45:29,760
is and now you're loading an application

00:45:28,109 --> 00:45:31,470
on something with a proprietary driver

00:45:29,760 --> 00:45:33,480
and you know I'm not going to give you

00:45:31,470 --> 00:45:37,230
the latest impression of nvidia but you

00:45:33,480 --> 00:45:40,770
know you you have a big issue so i don't

00:45:37,230 --> 00:45:42,480
know that joe the plumber or joe the

00:45:40,770 --> 00:45:43,440
hacker you know hackers a bad thing you

00:45:42,480 --> 00:45:45,930
violate you know a Fourth Amendment

00:45:43,440 --> 00:45:47,190
rights now to be hacker but I don't

00:45:45,930 --> 00:45:48,750
think that Joe hacker should use

00:45:47,190 --> 00:45:50,940
something like this Joe hacker should

00:45:48,750 --> 00:45:53,460
use higher level libraries and

00:45:50,940 --> 00:45:56,040
abstractions the point of opencl is it's

00:45:53,460 --> 00:45:58,619
more like something like p threats that

00:45:56,040 --> 00:46:01,410
you wind up having a very low interface

00:45:58,619 --> 00:46:03,450
or in c++ 11 now you have memory

00:46:01,410 --> 00:46:05,569
consistency models which we're totally

00:46:03,450 --> 00:46:07,920
not by choice but they're there now and

00:46:05,569 --> 00:46:10,020
you don't want to use those directly but

00:46:07,920 --> 00:46:12,630
it allows people like me to build the

00:46:10,020 --> 00:46:13,970
applications that hides that from you I

00:46:12,630 --> 00:46:15,890
need to deal with them

00:46:13,970 --> 00:46:18,290
so answer your question I mean open seal

00:46:15,890 --> 00:46:20,330
has really good stuff for Joe hacker to

00:46:18,290 --> 00:46:22,609
do right now you will get performance

00:46:20,330 --> 00:46:24,770
gains but I have not talked about how to

00:46:22,609 --> 00:46:27,230
actually get the illusionary performance

00:46:24,770 --> 00:46:30,710
yes you can get amazing performance but

00:46:27,230 --> 00:46:33,710
it is really really really hard to get

00:46:30,710 --> 00:46:40,160
it and there's no general method at this

00:46:33,710 --> 00:46:41,660
point to do that what proprietary API

00:46:40,160 --> 00:46:43,340
because what we're starting to see is

00:46:41,660 --> 00:46:46,099
that things are really unifying around

00:46:43,340 --> 00:46:50,150
us so Joe hacker why does Joe hacker

00:46:46,099 --> 00:46:51,890
want to use a GPU if he's trying to get

00:46:50,150 --> 00:46:54,530
it performant then Joe hacker isn't Joe

00:46:51,890 --> 00:46:56,960
hacker Joe hackers GPU hacker then he

00:46:54,530 --> 00:46:59,140
should be using opencl right I mean how

00:46:56,960 --> 00:47:02,180
many people how many Joe hackers use

00:46:59,140 --> 00:47:03,859
vector instructions right they rely upon

00:47:02,180 --> 00:47:05,000
a vectorizing compiler and hope it does

00:47:03,859 --> 00:47:07,730
a really good job but you probably won't

00:47:05,000 --> 00:47:09,200
but we hope for it and we you know buy

00:47:07,730 --> 00:47:12,220
something from Intel and take the credit

00:47:09,200 --> 00:47:15,109
for the performance but I would say that

00:47:12,220 --> 00:47:16,700
opencl is not really I mean AMD has also

00:47:15,109 --> 00:47:21,260
acknowledged this that open sale is the

00:47:16,700 --> 00:47:24,560
low base level right something will be

00:47:21,260 --> 00:47:26,000
built on top of that over time now if

00:47:24,560 --> 00:47:27,619
you really are performance obsessed

00:47:26,000 --> 00:47:30,589
opencl is wonderful and you really

00:47:27,619 --> 00:47:31,910
should use it but it's going to take a

00:47:30,589 --> 00:47:33,349
little bit time but if you have

00:47:31,910 --> 00:47:34,640
something that meeches matches all the

00:47:33,349 --> 00:47:36,140
requirements like you need to use all

00:47:34,640 --> 00:47:37,400
these devices you really should you

00:47:36,140 --> 00:47:39,170
let's open sale just because there's

00:47:37,400 --> 00:47:40,849
nothing else out there and you want to

00:47:39,170 --> 00:47:42,109
encourage the community to grow you

00:47:40,849 --> 00:47:43,670
don't want to send a message that you

00:47:42,109 --> 00:47:45,740
know to the hardware guys who are

00:47:43,670 --> 00:47:48,470
actually trying to do us a favor big

00:47:45,740 --> 00:47:50,210
favor to help I mean they're kind of

00:47:48,470 --> 00:47:52,609
wordless it's so cute they're walking

00:47:50,210 --> 00:47:54,980
along like we're writing libraries right

00:47:52,609 --> 00:47:56,839
like we want to encourage them to really

00:47:54,980 --> 00:47:58,430
provide us with something I don't know

00:47:56,839 --> 00:48:00,800
that hardware vendors are usually that

00:47:58,430 --> 00:48:02,810
good at coming together and providing us

00:48:00,800 --> 00:48:06,020
the general method because usually want

00:48:02,810 --> 00:48:09,980
to compete with each other so we need to

00:48:06,020 --> 00:48:12,099
support them nurture them love them go

00:48:09,980 --> 00:48:12,099
ahead

00:48:18,859 --> 00:48:36,989
yeah they don't okay so open CL

00:48:35,239 --> 00:48:40,409
theoretically you can run multiple

00:48:36,989 --> 00:48:42,749
processes or is their memory protection

00:48:40,409 --> 00:48:44,880
it's coming let me the biggest issue

00:48:42,749 --> 00:48:46,349
with the OS the reason it can do this

00:48:44,880 --> 00:48:49,079
illusion is because you have memory

00:48:46,349 --> 00:48:53,640
protection if you GPU there you have no

00:48:49,079 --> 00:48:56,159
memory protection not yet but GPU I mean

00:48:53,640 --> 00:48:57,869
opencl is a software interface that is

00:48:56,159 --> 00:48:59,009
really motivated by the hardware when

00:48:57,869 --> 00:49:01,049
all the hardware guys are at a certain

00:48:59,009 --> 00:49:04,679
level it has no capabilities so now we

00:49:01,049 --> 00:49:07,649
do see memory protection coming in we do

00:49:04,679 --> 00:49:09,899
see a unified view with the you know I

00:49:07,649 --> 00:49:11,609
don't know exactly how it's going to add

00:49:09,899 --> 00:49:13,259
a hardware level deal with things like

00:49:11,609 --> 00:49:14,640
cache coherence and stuff with this but

00:49:13,259 --> 00:49:22,979
we are seeing these types of protections

00:49:14,640 --> 00:49:24,689
I think we will get there no virtual

00:49:22,979 --> 00:49:27,149
memory hear you over locate your days

00:49:24,689 --> 00:49:28,649
over you better be very careful of your

00:49:27,149 --> 00:49:30,029
array sizes before you ship an

00:49:28,649 --> 00:49:40,380
application the hardware you don't know

00:49:30,029 --> 00:49:42,329
about yes very much so but I want to

00:49:40,380 --> 00:49:44,429
give you the impression that open CL is

00:49:42,329 --> 00:49:47,009
not a complete thing opencl is a

00:49:44,429 --> 00:49:48,959
beginning thing and I would tell you

00:49:47,009 --> 00:49:51,329
that you know we do need something you

00:49:48,959 --> 00:49:53,639
know how i made the the distinction that

00:49:51,329 --> 00:49:55,019
this is kind of becoming oh i see what

00:49:53,639 --> 00:49:57,659
we really need is something that we

00:49:55,019 --> 00:49:58,859
don't want to have the hardware being

00:49:57,659 --> 00:50:00,059
directly controlled by the programming

00:49:58,859 --> 00:50:01,859
won't have another layer that's just

00:50:00,059 --> 00:50:03,719
counting you know it's the same with iOS

00:50:01,859 --> 00:50:06,389
it's the OS that figures out the memory

00:50:03,719 --> 00:50:08,159
location for us but now we want that's

00:50:06,389 --> 00:50:10,819
the role of the middleware now if

00:50:08,159 --> 00:50:13,559
something's going to be an OS like layer

00:50:10,819 --> 00:50:14,669
so that should answer your question but

00:50:13,559 --> 00:50:16,529
opens till you can't do that right now

00:50:14,669 --> 00:50:18,479
because they're kind of playing both

00:50:16,529 --> 00:50:20,869
sides open sale technically provide

00:50:18,479 --> 00:50:23,759
something called a buffer which will

00:50:20,869 --> 00:50:26,400
pretend to do what you want but it

00:50:23,759 --> 00:50:28,289
doesn't in practice so

00:50:26,400 --> 00:50:29,460
but open stairs not bad about opencl are

00:50:28,289 --> 00:50:31,950
just beginning and if you compare it to

00:50:29,460 --> 00:50:33,630
kuta or something like that I mean open

00:50:31,950 --> 00:50:35,069
sale is not specific to GPUs it allows

00:50:33,630 --> 00:50:36,450
you to target everything but is a

00:50:35,069 --> 00:50:37,799
technology that's up and coming and it

00:50:36,450 --> 00:50:39,380
isn't its infancy there's going to be a

00:50:37,799 --> 00:50:44,029
lot of issues just as you've described

00:50:39,380 --> 00:50:44,029
more questions another couple go ahead

00:50:44,569 --> 00:50:49,980
that's the plan it depends upon how much

00:50:47,819 --> 00:50:52,020
coffees I get but New Zealand has banned

00:50:49,980 --> 00:50:54,059
software patents or as they call them

00:50:52,020 --> 00:50:57,809
pittance so because there are no

00:50:54,059 --> 00:50:59,520
software patents in New Zealand I think

00:50:57,809 --> 00:51:01,650
that this makes this a golden

00:50:59,520 --> 00:51:03,650
opportunity for the next generation of

00:51:01,650 --> 00:51:06,210
technology firms to be able to export

00:51:03,650 --> 00:51:09,240
technology without threat of destruction

00:51:06,210 --> 00:51:11,579
or self destruct buttons imposed by

00:51:09,240 --> 00:51:17,549
people who have more money than you when

00:51:11,579 --> 00:51:19,650
you're still growing yes the new zealand

00:51:17,549 --> 00:51:21,630
new zealand is open for business so

00:51:19,650 --> 00:51:23,490
incorporation in canada cost me three

00:51:21,630 --> 00:51:27,240
thousand dollars last time i did it new

00:51:23,490 --> 00:51:28,650
zealand it cost $150 filing taxes here

00:51:27,240 --> 00:51:30,270
cost me five thousand dollars new

00:51:28,650 --> 00:51:33,599
zealand you click on a website and they

00:51:30,270 --> 00:51:36,960
say thank you so it's really kind of

00:51:33,599 --> 00:51:38,279
streamlined the new zealand knows that

00:51:36,960 --> 00:51:40,470
they're going to have a hard time

00:51:38,279 --> 00:51:41,849
attracting people that's how come they

00:51:40,470 --> 00:51:43,890
filmed lord of the rings there because

00:51:41,849 --> 00:51:46,440
now every programmer can walk around go

00:51:43,890 --> 00:51:49,529
to work in your costume and be very

00:51:46,440 --> 00:51:52,440
happy so they're trying to bring us over

00:51:49,529 --> 00:51:53,520
and you know they've really I'm so

00:51:52,440 --> 00:51:55,170
impressed with how much they've

00:51:53,520 --> 00:51:58,380
streamlined the ability for you to open

00:51:55,170 --> 00:52:00,119
and run a technology business and New

00:51:58,380 --> 00:52:02,250
Zealand and my opinion will be silicon

00:52:00,119 --> 00:52:03,510
valley to you know I don't know that

00:52:02,250 --> 00:52:05,520
we're going to see the creepy technology

00:52:03,510 --> 00:52:06,900
being developed there but I do think

00:52:05,520 --> 00:52:08,819
that you know you're going to see you

00:52:06,900 --> 00:52:11,490
already see a lot of that new zealand is

00:52:08,819 --> 00:52:13,380
primarily architecture sorry agriculture

00:52:11,490 --> 00:52:15,539
if you eat sheep you you've eaten New

00:52:13,380 --> 00:52:18,059
Zealand product and one of the things

00:52:15,539 --> 00:52:20,609
that happened quite by accident is that

00:52:18,059 --> 00:52:22,920
the new zealand exports of technology

00:52:20,609 --> 00:52:24,869
have matched that of agriculture that's

00:52:22,920 --> 00:52:26,849
according i do mean that's according to

00:52:24,869 --> 00:52:28,680
the institute of technology professional

00:52:26,849 --> 00:52:30,059
professionals from New Zealand but okay

00:52:28,680 --> 00:52:30,990
that was probably last question I'm

00:52:30,059 --> 00:52:32,250
going to hang out here I have business

00:52:30,990 --> 00:52:34,500
cards if you want to come take me to

00:52:32,250 --> 00:52:35,960
coffee and extract information and then

00:52:34,500 --> 00:52:40,170
I'm going to go have even more coffee

00:52:35,960 --> 00:52:41,309
across I'm hard to miss so thank you for

00:52:40,170 --> 00:52:44,180
telling my presentation and hopefully

00:52:41,309 --> 00:52:44,180

YouTube URL: https://www.youtube.com/watch?v=dXCB4pfwDHs


