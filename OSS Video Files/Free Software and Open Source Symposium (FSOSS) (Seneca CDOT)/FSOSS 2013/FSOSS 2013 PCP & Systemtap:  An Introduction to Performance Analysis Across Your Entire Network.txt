Title: FSOSS 2013 PCP & Systemtap:  An Introduction to Performance Analysis Across Your Entire Network
Publication date: 2013-10-28
Playlist: FSOSS 2013
Description: 
	PCP & Systemtap:  An Introduction to Performance Analysis Across Your Entire Network presentation by Lukas Berk and Jonathan Lebon
Captions: 
	00:00:00,709 --> 00:00:06,720
my name is mike hart and i teach at

00:00:03,149 --> 00:00:09,420
Seneca College and given the opportunity

00:00:06,720 --> 00:00:12,330
to introduce our speakers it's the third

00:00:09,420 --> 00:00:14,340
session in the morning because I'll make

00:00:12,330 --> 00:00:16,470
the announcement now no use the glass or

00:00:14,340 --> 00:00:19,230
if one of us with the following this

00:00:16,470 --> 00:00:20,910
session is lunch lunch will be in that

00:00:19,230 --> 00:00:22,470
room right across the courtyard there

00:00:20,910 --> 00:00:25,490
the store is under the link those

00:00:22,470 --> 00:00:29,189
windows ok so you proceed over them

00:00:25,490 --> 00:00:32,430
alright today we're just the sexual go

00:00:29,189 --> 00:00:36,030
taco PCP and system at our presenters

00:00:32,430 --> 00:00:38,129
are music Burke and medical ha Lucas's

00:00:36,030 --> 00:00:40,770
performance tools engineer at Red Hat

00:00:38,129 --> 00:00:43,379
attributing the system app since 2010

00:00:40,770 --> 00:00:47,250
his work has included providing

00:00:43,379 --> 00:00:50,640
additional OpenJDK hotspot pro support

00:00:47,250 --> 00:00:54,360
an enabling system distant app to

00:00:50,640 --> 00:00:57,510
natively probe java programs Jonathan

00:00:54,360 --> 00:00:59,309
LaVon is a York student currently in

00:00:57,510 --> 00:01:02,690
training at Manhattan as part of the

00:00:59,309 --> 00:01:05,189
system tap team he has worked on funding

00:01:02,690 --> 00:01:07,920
improvements such as making better

00:01:05,189 --> 00:01:10,500
suggestions on airs he's presently

00:01:07,920 --> 00:01:12,630
working on a consistent path work toward

00:01:10,500 --> 00:01:15,229
easily with virtual machines he's

00:01:12,630 --> 00:01:19,009
welcome in welcoming Lucas it done

00:01:15,229 --> 00:01:19,009
everybody thank you for the introduction

00:01:20,570 --> 00:01:25,700
so as we alluded to earlier we're going

00:01:23,009 --> 00:01:29,220
to give me a talk on PCP insist on tap

00:01:25,700 --> 00:01:31,920
there we go so quick overview today's

00:01:29,220 --> 00:01:35,220
topic will introduce the idea while

00:01:31,920 --> 00:01:38,340
we're here give a couple demos and let's

00:01:35,220 --> 00:01:40,500
go so we know we don't appreciate and

00:01:38,340 --> 00:01:42,750
like if our software and systems ran

00:01:40,500 --> 00:01:44,310
perfectly all the time but realistically

00:01:42,750 --> 00:01:46,200
we know that doesn't always happen

00:01:44,310 --> 00:01:47,850
you're probably spending half your time

00:01:46,200 --> 00:01:50,520
debugging things or making sure that

00:01:47,850 --> 00:01:53,040
things work as I should so we'll over

00:01:50,520 --> 00:01:54,869
you the six stages as you bugging get

00:01:53,040 --> 00:01:57,270
the bug report that can't happen but it

00:01:54,869 --> 00:02:01,590
doesn't happen quickly switches to oh

00:01:57,270 --> 00:02:03,390
that doesn't have from my machine okay

00:02:01,590 --> 00:02:07,860
it does happen my machine that shouldn't

00:02:03,390 --> 00:02:10,259
happen so why does that happen hi oh I

00:02:07,860 --> 00:02:13,709
see why that happens and how did that

00:02:10,259 --> 00:02:14,130
ever work and if you're if you're like

00:02:13,709 --> 00:02:16,260
me

00:02:14,130 --> 00:02:19,500
there's two bonus here who wrote that

00:02:16,260 --> 00:02:24,630
and you might know what's going oh I

00:02:19,500 --> 00:02:27,150
wrote that uh-huh so ya so the first

00:02:24,630 --> 00:02:29,280
step is acceptance and emitting you've

00:02:27,150 --> 00:02:31,800
got a problem but we're here to focus on

00:02:29,280 --> 00:02:34,140
steps cream for that shouldn't happen

00:02:31,800 --> 00:02:36,330
and why does that happen so hopefully we

00:02:34,140 --> 00:02:39,600
can get to you know accelerating through

00:02:36,330 --> 00:02:41,670
fixing it and deploying your fix so in

00:02:39,600 --> 00:02:43,980
other words our main objectives are

00:02:41,670 --> 00:02:46,500
early detection of a potential problem

00:02:43,980 --> 00:02:47,520
if we can detect that we may have a

00:02:46,500 --> 00:02:49,530
problem before it actually happens

00:02:47,520 --> 00:02:52,440
that's even better so we can avoid the

00:02:49,530 --> 00:02:54,720
problem and rapidly drilling down to

00:02:52,440 --> 00:02:56,730
pinpoint the issue a lot of times you're

00:02:54,720 --> 00:02:58,430
very complex distributed systems there's

00:02:56,730 --> 00:03:00,120
a lot of information at your disposal

00:02:58,430 --> 00:03:01,530
making sure you get the right

00:03:00,120 --> 00:03:05,250
information and use the right

00:03:01,530 --> 00:03:06,990
information is critical so how does it

00:03:05,250 --> 00:03:09,600
typically been done if your systems

00:03:06,990 --> 00:03:11,190
administrator perhaps developer you've

00:03:09,600 --> 00:03:15,420
got the typical logging tools such as

00:03:11,190 --> 00:03:17,790
rsyslog this log ND journal d so these

00:03:15,420 --> 00:03:19,860
are really just kind of accumulating

00:03:17,790 --> 00:03:22,290
totals of information they're very

00:03:19,860 --> 00:03:25,050
linear one way and it's your job to

00:03:22,290 --> 00:03:28,020
parse through them all you also have

00:03:25,050 --> 00:03:30,420
tools called you know top iostat vmstat

00:03:28,020 --> 00:03:32,520
so these are in a profiling tool or

00:03:30,420 --> 00:03:33,780
monitoring tools where you're given a

00:03:32,520 --> 00:03:36,120
set of information and it's not very

00:03:33,780 --> 00:03:38,760
malleable right top provides you say

00:03:36,120 --> 00:03:41,520
with the processes and cpu usage if you

00:03:38,760 --> 00:03:44,430
want al so that's too bad what if you

00:03:41,520 --> 00:03:46,110
want some more detailed information you

00:03:44,430 --> 00:03:48,300
might use a mixture of scripting

00:03:46,110 --> 00:03:50,940
languages uh if you're unlucky you get a

00:03:48,300 --> 00:03:52,770
completely unreadable perl script handed

00:03:50,940 --> 00:03:54,540
down to you and you probably use these

00:03:52,770 --> 00:03:57,150
scripts to make you no sense of the

00:03:54,540 --> 00:04:00,180
first two items you know this can be

00:03:57,150 --> 00:04:02,040
very hairy we'd like you know a common

00:04:00,180 --> 00:04:04,320
set of language that you can use on all

00:04:02,040 --> 00:04:06,270
your systems and the thing is the

00:04:04,320 --> 00:04:08,250
specific tools vary by the system you're

00:04:06,270 --> 00:04:10,500
using across architectures across

00:04:08,250 --> 00:04:12,750
operations operating systems you know

00:04:10,500 --> 00:04:14,670
I'm a Linux fan I want open source from

00:04:12,750 --> 00:04:17,459
realistically environment you might not

00:04:14,670 --> 00:04:20,100
have just Linux might have you know AIX

00:04:17,459 --> 00:04:22,950
or Mac OS or Windows right that's a much

00:04:20,100 --> 00:04:25,050
more typical use case and proper

00:04:22,950 --> 00:04:27,270
analysis requires more context simply

00:04:25,050 --> 00:04:28,020
seeing you know I had a log message

00:04:27,270 --> 00:04:29,300
error or my

00:04:28,020 --> 00:04:31,530
old script pull this bit of information

00:04:29,300 --> 00:04:33,090
you know you need more than that and

00:04:31,530 --> 00:04:35,160
you're going to find throughout this

00:04:33,090 --> 00:04:36,300
presentation that you need more

00:04:35,160 --> 00:04:38,400
information about those events

00:04:36,300 --> 00:04:39,990
specifically unit of time or if it's

00:04:38,400 --> 00:04:43,740
hurts or percentage right simply a

00:04:39,990 --> 00:04:45,509
number doesn't do it so we got the tools

00:04:43,740 --> 00:04:48,960
made us to solve this and introducing

00:04:45,509 --> 00:04:50,569
performance co-pilot so a couple points

00:04:48,960 --> 00:04:53,129
of interest what we like about this tool

00:04:50,569 --> 00:04:55,470
it's got a unix-like component design

00:04:53,129 --> 00:05:00,330
meaning you got a lot of small programs

00:04:55,470 --> 00:05:01,740
that do one thing they do them well it

00:05:00,330 --> 00:05:03,659
complements your existing system

00:05:01,740 --> 00:05:05,130
functionality performance copilot

00:05:03,659 --> 00:05:07,860
doesn't ask you to throw out everything

00:05:05,130 --> 00:05:12,720
you've got it complements it and just

00:05:07,860 --> 00:05:13,710
kind of adds to it let's see so we're

00:05:12,720 --> 00:05:15,630
not asking you to relearn everything

00:05:13,710 --> 00:05:18,360
you've ever learned it's cross platform

00:05:15,630 --> 00:05:20,310
so you know it comes just about on every

00:05:18,360 --> 00:05:23,880
OS on the Sun and get a full list at our

00:05:20,310 --> 00:05:26,069
website ubiquitous unit measurement so

00:05:23,880 --> 00:05:28,020
again I said this before it's going to

00:05:26,069 --> 00:05:30,030
come up again I want to know if it's a

00:05:28,020 --> 00:05:31,919
percentage if it's a unit of time you

00:05:30,030 --> 00:05:34,020
know frequencies it counts per second

00:05:31,919 --> 00:05:35,789
that information is very important and

00:05:34,020 --> 00:05:40,020
it's built in from the ground up and PCP

00:05:35,789 --> 00:05:42,270
and it's extremely extensible we realize

00:05:40,020 --> 00:05:44,159
that we give a lot of great defaults but

00:05:42,270 --> 00:05:46,409
you probably have some users police user

00:05:44,159 --> 00:05:48,419
space program that we don't know about

00:05:46,409 --> 00:05:50,430
and if you want information from that

00:05:48,419 --> 00:05:52,770
program that's most key what you want to

00:05:50,430 --> 00:05:55,919
know we've made it very easy to you know

00:05:52,770 --> 00:05:59,460
extend PCP into your own program and

00:05:55,919 --> 00:06:02,279
that's open source your open source so

00:05:59,460 --> 00:06:04,919
how does performance cope i laid out

00:06:02,279 --> 00:06:07,680
well in the most basic case a one

00:06:04,919 --> 00:06:09,479
machine you have two components first is

00:06:07,680 --> 00:06:13,860
called performance metric domain agents

00:06:09,479 --> 00:06:15,990
big long name for basically saying this

00:06:13,860 --> 00:06:17,460
is the small and program that simply

00:06:15,990 --> 00:06:19,560
knows how to talk to the domain of

00:06:17,460 --> 00:06:23,069
interest there'd be the colonel your

00:06:19,560 --> 00:06:24,419
user space application your network this

00:06:23,069 --> 00:06:27,270
knows how to talk to that specific

00:06:24,419 --> 00:06:28,650
domain and the flip side of things you

00:06:27,270 --> 00:06:30,599
have a performance metric collection

00:06:28,650 --> 00:06:32,759
Damon this is the tool that knows how to

00:06:30,599 --> 00:06:35,009
talk to the agents right you'll have one

00:06:32,759 --> 00:06:37,469
of these in the box you might have like

00:06:35,009 --> 00:06:39,060
multiples at the agents so breezy use

00:06:37,469 --> 00:06:41,550
going forward we're going to call the

00:06:39,060 --> 00:06:41,849
first one agents a second one the PM CD

00:06:41,550 --> 00:06:45,149
so

00:06:41,849 --> 00:06:47,129
easier to say so for the agents you

00:06:45,149 --> 00:06:49,139
might have things say information on the

00:06:47,129 --> 00:06:51,959
colonel your web server called patchy

00:06:49,139 --> 00:06:54,569
and genetics your database management

00:06:51,959 --> 00:06:56,490
system and you know network there's

00:06:54,569 --> 00:06:58,679
there's more of these there's we ship a

00:06:56,490 --> 00:07:01,349
whole set by default it's just a sample

00:06:58,679 --> 00:07:04,830
and then on the same system you know you

00:07:01,349 --> 00:07:06,270
got your PM CD and this is the tool that

00:07:04,830 --> 00:07:08,879
actually pulls the information in and

00:07:06,270 --> 00:07:10,529
out of those agents right so this isn't

00:07:08,879 --> 00:07:12,689
just on one system but once again we

00:07:10,529 --> 00:07:14,219
might be on a distributed enterprise

00:07:12,689 --> 00:07:15,569
solution where you know I've got a

00:07:14,219 --> 00:07:16,589
server in Australia because they don't

00:07:15,569 --> 00:07:19,229
want to come over across North America

00:07:16,589 --> 00:07:20,879
information so we work then and we've

00:07:19,229 --> 00:07:23,669
got the agents communicate with the PM's

00:07:20,879 --> 00:07:26,809
ed and then we got clients to pull the

00:07:23,669 --> 00:07:31,159
information out of that so we got pai e

00:07:26,809 --> 00:07:33,830
vmstat p.m. Val cam cherry game info

00:07:31,159 --> 00:07:36,300
like I've mentioned before unix-like

00:07:33,830 --> 00:07:38,009
component design each of these tools I

00:07:36,300 --> 00:07:39,689
give you a bit of a demonstration on but

00:07:38,009 --> 00:07:43,339
they do one thing they do them well and

00:07:39,689 --> 00:07:45,749
they pull information on the p.m. CT

00:07:43,339 --> 00:07:47,189
great so we got the agents p.m. CT and

00:07:45,749 --> 00:07:49,409
clients and this is what i would do

00:07:47,189 --> 00:07:51,689
earlier in the remote p.m. cds will feed

00:07:49,409 --> 00:07:54,379
into the clients right so i can come up

00:07:51,689 --> 00:07:58,709
from australia and europe what have you

00:07:54,379 --> 00:08:00,629
not making sense so a couple useful

00:07:58,709 --> 00:08:02,849
commands you know you install pcp what

00:08:00,629 --> 00:08:05,009
might you want to do out of the box well

00:08:02,849 --> 00:08:06,269
there's pcp just gives you a brief

00:08:05,009 --> 00:08:09,180
summary of installation on that

00:08:06,269 --> 00:08:11,009
particular machine you can do PM stat

00:08:09,180 --> 00:08:12,719
hostname and that's just you know a

00:08:11,009 --> 00:08:14,339
high-level overview so it's kind of a

00:08:12,719 --> 00:08:17,429
combination of the tools we saw earlier

00:08:14,339 --> 00:08:19,800
such as top iostat be honest at mpm

00:08:17,429 --> 00:08:22,019
chart I mean it's a configurable metrics

00:08:19,800 --> 00:08:24,209
chart so once again depending on what

00:08:22,019 --> 00:08:26,819
you're looking to measure or diagnose or

00:08:24,209 --> 00:08:28,589
analyze it changes this GUI is very

00:08:26,819 --> 00:08:30,269
flexible and it can change the

00:08:28,589 --> 00:08:33,180
information displayed based on what you

00:08:30,269 --> 00:08:36,599
want to look at a demo second so a

00:08:33,180 --> 00:08:38,579
couple example outputs pcp this is the

00:08:36,599 --> 00:08:40,860
output it'll give you a lot to parse

00:08:38,579 --> 00:08:42,509
through but the idea is you know you get

00:08:40,860 --> 00:08:45,000
an overview of your system you can see

00:08:42,509 --> 00:08:47,430
the time zone so once again if it's

00:08:45,000 --> 00:08:49,380
across the world you got the PM das so

00:08:47,430 --> 00:08:51,870
these the agents right in this typical

00:08:49,380 --> 00:08:55,199
case i'm interested in the PM CD itself

00:08:51,870 --> 00:08:56,100
proc linux few more name these are

00:08:55,199 --> 00:08:57,269
what's configurable

00:08:56,100 --> 00:09:01,740
every machine might look different

00:08:57,269 --> 00:09:03,509
lessons and yet the lugger instance p.m.

00:09:01,740 --> 00:09:04,829
stat so this is the overview notice i

00:09:03,509 --> 00:09:06,839
want to get information from multiple

00:09:04,829 --> 00:09:08,850
hosts so I've told him birth which is my

00:09:06,839 --> 00:09:11,819
little server box and Saturn which is

00:09:08,850 --> 00:09:14,490
one of my work stations it'll give you a

00:09:11,819 --> 00:09:18,300
readout you know what note it is the

00:09:14,490 --> 00:09:20,220
average load memory swap and this

00:09:18,300 --> 00:09:22,009
appends right so every second or so

00:09:20,220 --> 00:09:23,970
you're going to see a readout like this

00:09:22,009 --> 00:09:26,100
just kind of giving you a high-level

00:09:23,970 --> 00:09:29,339
overview and it'll keep the pending as

00:09:26,100 --> 00:09:32,459
you go as long as you let it right this

00:09:29,339 --> 00:09:34,410
is a sample p.m. chart I can figure this

00:09:32,459 --> 00:09:37,170
one to show the cpu utilization the

00:09:34,410 --> 00:09:39,269
middle section is network I oh and the

00:09:37,170 --> 00:09:40,470
bottom is memory usage so a couple

00:09:39,269 --> 00:09:43,380
things I want to draw your attention to

00:09:40,470 --> 00:09:44,819
it's a very bottom again units of

00:09:43,380 --> 00:09:47,759
measurement we're doing this in seconds

00:09:44,819 --> 00:09:51,839
on you know if you want a larger sample

00:09:47,759 --> 00:09:53,970
it might be ours it depends you start

00:09:51,839 --> 00:09:56,009
and stop so you can play back live data

00:09:53,970 --> 00:09:57,839
or you can do this over a log file if

00:09:56,009 --> 00:10:02,009
you want to see things happen from the

00:09:57,839 --> 00:10:04,310
log again units so we have an idea of

00:10:02,009 --> 00:10:08,819
what this is measuring gigabytes

00:10:04,310 --> 00:10:11,370
megabytes a second and percentage so

00:10:08,819 --> 00:10:13,139
here I ran a program on which my machine

00:10:11,370 --> 00:10:14,370
called stress does exactly what it

00:10:13,139 --> 00:10:17,130
sounds like it just stresses your box

00:10:14,370 --> 00:10:20,100
out it also got a spike and memory usage

00:10:17,130 --> 00:10:22,350
and cpu usage just give you an idea

00:10:20,100 --> 00:10:25,350
what's going on the system and here are

00:10:22,350 --> 00:10:26,850
my virtual machines on the machine i ran

00:10:25,350 --> 00:10:29,009
a yum update so there's a lot of i/o

00:10:26,850 --> 00:10:31,050
traffic on the network at the same time

00:10:29,009 --> 00:10:34,589
you might notice a trend say you know

00:10:31,050 --> 00:10:37,230
the interrupt context on the cpu is is

00:10:34,589 --> 00:10:38,459
higher so you know these are great

00:10:37,230 --> 00:10:40,290
overview tools but i thought at the

00:10:38,459 --> 00:10:41,699
beginning we said you know you want more

00:10:40,290 --> 00:10:43,110
than that you want more than overview

00:10:41,699 --> 00:10:48,420
from going to do this why not just use

00:10:43,110 --> 00:10:53,009
top say well we have the technology so

00:10:48,420 --> 00:10:54,480
what PCP does is we basically have this

00:10:53,009 --> 00:10:56,730
it was called performance metrics

00:10:54,480 --> 00:10:59,459
namespaces and what that means is a

00:10:56,730 --> 00:11:01,949
subsystem based hierarchal hierarchical

00:10:59,459 --> 00:11:03,569
naming scheme so because you have a lot

00:11:01,949 --> 00:11:05,220
of information available to you have a

00:11:03,569 --> 00:11:07,439
lot of things you can try and find the

00:11:05,220 --> 00:11:09,690
metrics from what you want to do is be

00:11:07,439 --> 00:11:11,340
able to organize this properly

00:11:09,690 --> 00:11:12,780
so this is what it might look like your

00:11:11,340 --> 00:11:15,840
whole tree of information available to

00:11:12,780 --> 00:11:18,330
you this is how it works if i want to

00:11:15,840 --> 00:11:21,450
say look at the network tcp received

00:11:18,330 --> 00:11:23,250
packet metric you go network tcp

00:11:21,450 --> 00:11:24,780
received packet that's what it's a poem

00:11:23,250 --> 00:11:26,880
naming scheme would look like i can

00:11:24,780 --> 00:11:30,960
change based on cpu usage or what other

00:11:26,880 --> 00:11:33,350
agents you have available to you so how

00:11:30,960 --> 00:11:36,330
do we make use of these metrics well

00:11:33,350 --> 00:11:37,860
p.m. mpho f is what something you can

00:11:36,330 --> 00:11:39,750
just run quickly and it'll give you a

00:11:37,860 --> 00:11:41,610
list of absolutely every metric they

00:11:39,750 --> 00:11:43,200
have available to you I was just writing

00:11:41,610 --> 00:11:48,030
to this through less because there's a

00:11:43,200 --> 00:11:49,590
lot of output so p.m. info TD and the

00:11:48,030 --> 00:11:51,180
metric name so you pinpointed something

00:11:49,590 --> 00:11:53,550
you're interested in and we're going to

00:11:51,180 --> 00:11:54,990
give you kind of a help like what is

00:11:53,550 --> 00:11:58,290
this metric actually measuring because

00:11:54,990 --> 00:11:59,400
there's a lot of them and once you find

00:11:58,290 --> 00:12:03,890
a metric you're really interested in

00:11:59,400 --> 00:12:03,890
p.m. Bell what is this metric right now

00:12:04,100 --> 00:12:10,890
so a couple site below puts payment

00:12:06,600 --> 00:12:13,350
poached ed colonel all sis fork and you

00:12:10,890 --> 00:12:15,090
don't know what that is well it's the

00:12:13,350 --> 00:12:16,890
fork great metric from aprox that and

00:12:15,090 --> 00:12:19,200
it'll give you some information say it's

00:12:16,890 --> 00:12:22,800
the 64 bit unsigned integer and the

00:12:19,200 --> 00:12:24,300
unit's again is counts so I've got a

00:12:22,800 --> 00:12:27,380
metric I'm interested what's the actual

00:12:24,300 --> 00:12:29,040
value well if you PM bell disk all right

00:12:27,380 --> 00:12:31,230
again I'll give you a very quick

00:12:29,040 --> 00:12:32,820
overview in case you've forgotten and

00:12:31,230 --> 00:12:35,760
notice we've converted it here two

00:12:32,820 --> 00:12:37,800
counts a second so you can change this

00:12:35,760 --> 00:12:39,870
to pay on the metric and you're going to

00:12:37,800 --> 00:12:43,500
get a list that just kind of depends do

00:12:39,870 --> 00:12:47,970
it as you go so individual cases great

00:12:43,500 --> 00:12:50,700
what do we do with it so again this is

00:12:47,970 --> 00:12:53,280
there are layout so far well p.m. CD

00:12:50,700 --> 00:12:55,470
will then talk to a tool called p.m. IE

00:12:53,280 --> 00:12:57,030
and well again this is more in a second

00:12:55,470 --> 00:12:59,370
but this is where some really powerful

00:12:57,030 --> 00:13:01,200
stuff comes into play and if you have

00:12:59,370 --> 00:13:03,540
metrics that you want to log for later

00:13:01,200 --> 00:13:05,130
we use p.m. lager and this will create

00:13:03,540 --> 00:13:06,990
log archives this is you know the

00:13:05,130 --> 00:13:09,570
typical logging that you may have seen

00:13:06,990 --> 00:13:10,950
before the same data it will you work

00:13:09,570 --> 00:13:14,280
for last 10 years we'll work on the

00:13:10,950 --> 00:13:15,690
current clients as well so that that's

00:13:14,280 --> 00:13:17,430
very important to us we don't want any

00:13:15,690 --> 00:13:19,320
difference between the data you can use

00:13:17,430 --> 00:13:22,970
10 years ago and the data can you can

00:13:19,320 --> 00:13:25,699
use today but for PMI

00:13:22,970 --> 00:13:28,759
so PMI the performance metrics inference

00:13:25,699 --> 00:13:31,250
engine what is it will allows you to

00:13:28,759 --> 00:13:33,139
form metrics based expressions for

00:13:31,250 --> 00:13:34,939
evaluation all right this is how you

00:13:33,139 --> 00:13:38,899
gain real insight and what the metrics

00:13:34,939 --> 00:13:40,459
are telling you so it's it's language

00:13:38,899 --> 00:13:42,740
that you know you can see ratios from

00:13:40,459 --> 00:13:45,199
the metrics counts aggregates you can do

00:13:42,740 --> 00:13:47,420
percentiles so you know everything in

00:13:45,199 --> 00:13:50,720
the 90th percentile the disk rights I

00:13:47,420 --> 00:13:52,430
want to see something happen so what

00:13:50,720 --> 00:13:54,170
happens if you know if your machine is

00:13:52,430 --> 00:13:56,889
writing like crazy you can raise alarms

00:13:54,170 --> 00:13:59,689
log entries shell commands name a few

00:13:56,889 --> 00:14:01,370
and what it's important is you can run

00:13:59,689 --> 00:14:03,019
some live data so you know you can have

00:14:01,370 --> 00:14:04,279
this on your server box and you get a

00:14:03,019 --> 00:14:05,899
notification you know we've got a

00:14:04,279 --> 00:14:08,720
problem or you can run it kind of

00:14:05,899 --> 00:14:10,610
post-mortem on logs to a tested the

00:14:08,720 --> 00:14:12,560
rural you're going to write and see if

00:14:10,610 --> 00:14:15,370
it would have triggered it or just to

00:14:12,560 --> 00:14:17,540
see statistical trends within your data

00:14:15,370 --> 00:14:19,310
and you can run these rules across

00:14:17,540 --> 00:14:20,870
multiple hosts so if you know you've got

00:14:19,310 --> 00:14:25,459
three machines doing X across the world

00:14:20,870 --> 00:14:28,120
you can find out it on all them so let's

00:14:25,459 --> 00:14:32,899
take a look couple possible examples

00:14:28,120 --> 00:14:34,250
disco right / dis called total x 100 my

00:14:32,899 --> 00:14:36,620
guess that that's the percentage of all

00:14:34,250 --> 00:14:38,569
dis cooperation of rights right so you

00:14:36,620 --> 00:14:42,410
kind of get a sense on how you're going

00:14:38,569 --> 00:14:44,329
to use these rules de step total so

00:14:42,410 --> 00:14:45,709
that's you know the operations total the

00:14:44,329 --> 00:14:48,410
device if it's greater than 10 so you

00:14:45,709 --> 00:14:51,639
know if it's more than just booted up if

00:14:48,410 --> 00:14:55,639
and the disgrace on the disk I read all

00:14:51,639 --> 00:14:59,240
right so you can combine expressions to

00:14:55,639 --> 00:15:02,000
form more powerful rules and you so how

00:14:59,240 --> 00:15:04,009
would you use these type of rules will

00:15:02,000 --> 00:15:05,480
say what if you want to know that your

00:15:04,009 --> 00:15:09,439
Ethernet has stopped functioning right

00:15:05,480 --> 00:15:10,939
this is the possible scenario verbose

00:15:09,439 --> 00:15:12,649
but let me give you a rundown you've got

00:15:10,939 --> 00:15:13,819
some conditionals so you say some

00:15:12,649 --> 00:15:15,949
instance this is almost like an f

00:15:13,819 --> 00:15:19,670
statement so if you know we have an

00:15:15,949 --> 00:15:22,519
instant smashing EF 0 or sorry ETA chori

00:15:19,670 --> 00:15:26,059
m which your typical linux Ethernet the

00:15:22,519 --> 00:15:28,579
limiters are names so if the network

00:15:26,059 --> 00:15:30,259
interface total errors is greater than

00:15:28,579 --> 00:15:32,660
10 a second again you can specify the

00:15:30,259 --> 00:15:34,730
time then we want to write to the syslog

00:15:32,660 --> 00:15:36,040
we got ethernet errors and the number of

00:15:34,730 --> 00:15:37,999
errors

00:15:36,040 --> 00:15:40,610
right so a quick demo mode how this

00:15:37,999 --> 00:15:44,629
might actually work on a system and

00:15:40,610 --> 00:15:51,800
you'll read that okay sounds good so

00:15:44,629 --> 00:15:53,870
I've written rule called load demo so

00:15:51,800 --> 00:15:56,540
the basic gist the rule is the one

00:15:53,870 --> 00:15:58,040
minute load average exceeds you know 1

00:15:56,540 --> 00:15:59,809
times the number of CPUs on your host

00:15:58,040 --> 00:16:00,920
this isn't a realistic rule you'd use in

00:15:59,809 --> 00:16:05,180
real life you'd probably want to add

00:16:00,920 --> 00:16:06,709
that up a little bit but you only see in

00:16:05,180 --> 00:16:08,449
a second line the hosts I want to run

00:16:06,709 --> 00:16:10,670
this on my localhost again we can run

00:16:08,449 --> 00:16:12,529
this on multiple hosts the Delta is

00:16:10,670 --> 00:16:14,089
going to be 10 seconds realistically

00:16:12,529 --> 00:16:15,350
you'd have a higher Delta I mean you

00:16:14,089 --> 00:16:18,110
might have spikes you don't really care

00:16:15,350 --> 00:16:20,990
about but for the sake of Tamil and then

00:16:18,110 --> 00:16:23,269
on the high load on some host again you

00:16:20,990 --> 00:16:25,970
can run this on multiples I'm a colonel

00:16:23,269 --> 00:16:27,800
all load so all processors on the host

00:16:25,970 --> 00:16:30,230
of interest for the one minute load

00:16:27,800 --> 00:16:32,809
average is that greater than the number

00:16:30,230 --> 00:16:34,069
of CPUs on this machine if it is high

00:16:32,809 --> 00:16:35,809
load average are you stressed out again

00:16:34,069 --> 00:16:37,850
so to demo this I'm going to run a tool

00:16:35,809 --> 00:16:39,319
called stress as I mentioned before and

00:16:37,850 --> 00:16:41,569
all stress will do is run a set number

00:16:39,319 --> 00:16:44,029
of CPU processes that are very intensive

00:16:41,569 --> 00:16:47,540
a little stress how the machine so to

00:16:44,029 --> 00:16:53,240
start the journal is just like the

00:16:47,540 --> 00:16:55,720
syslog entry essentially and just going

00:16:53,240 --> 00:17:03,559
to grip pcp make life a little easier

00:16:55,720 --> 00:17:05,299
and so this is the rule loading p.m. i

00:17:03,559 --> 00:17:05,929
see which is the configuration and

00:17:05,299 --> 00:17:08,500
they're going to run it in the

00:17:05,929 --> 00:17:08,500
background for you

00:17:17,830 --> 00:17:26,090
and to actually run it out so see stress

00:17:24,170 --> 00:17:29,930
you go out oh you see the rules and

00:17:26,090 --> 00:17:31,160
loaded stress 20 cpus they are tasks in

00:17:29,930 --> 00:17:36,950
our time out of 60 seconds we should

00:17:31,160 --> 00:17:40,940
hopefully not actually hit that cool so

00:17:36,950 --> 00:17:43,100
we're dispatching 2020 CPU cycles give

00:17:40,940 --> 00:17:45,550
it a little bit you'll see a pop-up the

00:17:43,100 --> 00:17:45,550
bottom here

00:18:00,200 --> 00:18:04,460
so bz ppm a high load average or you're

00:18:03,110 --> 00:18:06,919
stressing out again right so you can see

00:18:04,460 --> 00:18:11,450
how you would extend this to say your

00:18:06,919 --> 00:18:12,350
application your your systems hopefully

00:18:11,450 --> 00:18:15,549
this will help you sleep a little bit

00:18:12,350 --> 00:18:18,049
more and I went get those alarms at 4am

00:18:15,549 --> 00:18:19,940
so cool so as I mentioned earlier we

00:18:18,049 --> 00:18:21,380
want to be able to extend this to as

00:18:19,940 --> 00:18:24,919
much as possible to your user space

00:18:21,380 --> 00:18:26,149
application so but if a quote if it is

00:18:24,919 --> 00:18:27,649
important for monitoring system

00:18:26,149 --> 00:18:29,450
performance and you can measure it you

00:18:27,649 --> 00:18:32,120
can easily integrate it into the PCP

00:18:29,450 --> 00:18:34,639
framework someone famous the piece of

00:18:32,120 --> 00:18:36,590
user guide so there's several ways to

00:18:34,639 --> 00:18:38,450
extend PCP to your advantage to your

00:18:36,590 --> 00:18:39,769
user space application you can write

00:18:38,450 --> 00:18:41,299
your own agent right so this is the

00:18:39,769 --> 00:18:43,669
program just the small a little bit that

00:18:41,299 --> 00:18:46,100
talks to your program you can write your

00:18:43,669 --> 00:18:48,799
own seal I or GUI interface so something

00:18:46,100 --> 00:18:51,350
like p.m. chart that will extract the

00:18:48,799 --> 00:18:53,000
proper information or way you want it or

00:18:51,350 --> 00:18:56,210
directly add sampling and trace and

00:18:53,000 --> 00:18:57,440
instrumentation we owe this is bit

00:18:56,210 --> 00:18:58,880
outside the scope of the talk what we

00:18:57,440 --> 00:19:00,740
have plenty of documentation out of

00:18:58,880 --> 00:19:03,919
programmatic they do these things honest

00:19:00,740 --> 00:19:12,200
all our website any quick questions

00:19:03,919 --> 00:19:15,169
before we move on yeah right now it's

00:19:12,200 --> 00:19:18,549
just typical unit sockets and on my

00:19:15,169 --> 00:19:20,929
systems I have cause I bahi running so

00:19:18,549 --> 00:19:22,760
you can either give it the IP address or

00:19:20,929 --> 00:19:26,120
just like it's just typical unix sockets

00:19:22,760 --> 00:19:30,380
in that sense I poor work for four three

00:19:26,120 --> 00:19:32,240
two one we're at a map that's that's

00:19:30,380 --> 00:19:34,309
we're like latest release coming up that

00:19:32,240 --> 00:19:40,610
deal we've got a lot of effort on that

00:19:34,309 --> 00:19:42,200
right now whatever else ok so this point

00:19:40,610 --> 00:19:44,799
we've hopefully detected a potential

00:19:42,200 --> 00:19:47,899
problem hopefully avoided it but hey

00:19:44,799 --> 00:19:49,100
identified the possible culprits but how

00:19:47,899 --> 00:19:51,649
do we know what's causing the issue

00:19:49,100 --> 00:19:52,639
right we've seen the issue happen but we

00:19:51,649 --> 00:19:54,669
got to drill down a little bit further

00:19:52,639 --> 00:19:59,360
and for that Jonathan's going to label

00:19:54,669 --> 00:20:02,840
hello everyone so I'm going to talk to

00:19:59,360 --> 00:20:05,210
you about system tab so as Lucas

00:20:02,840 --> 00:20:07,340
mentioned he talked about PCB and how it

00:20:05,210 --> 00:20:09,710
can help you just monitor the health of

00:20:07,340 --> 00:20:11,090
your whole network so at the same time

00:20:09,710 --> 00:20:13,700
it can help you whenever something goes

00:20:11,090 --> 00:20:16,130
wrong pinpoint really quickly where

00:20:13,700 --> 00:20:17,600
exactly something has gone wrong so in

00:20:16,130 --> 00:20:20,360
that sense system type is kind of like

00:20:17,600 --> 00:20:23,289
the second half of that story it helps

00:20:20,360 --> 00:20:25,730
you you know do some more detailed

00:20:23,289 --> 00:20:27,620
investigative work to find out what

00:20:25,730 --> 00:20:32,029
exactly is going wrong and how you can

00:20:27,620 --> 00:20:34,870
fix it so what is system tab well

00:20:32,029 --> 00:20:37,279
normally the tools you would use for

00:20:34,870 --> 00:20:41,000
fixing bugs you know would be stuff like

00:20:37,279 --> 00:20:43,159
tracers profilers or debuggers now the

00:20:41,000 --> 00:20:46,460
thing is tracers for example limit you

00:20:43,159 --> 00:20:47,720
to function calls and sometimes it can

00:20:46,460 --> 00:20:50,539
give you information you don't want

00:20:47,720 --> 00:20:53,090
right so they can overload you profilers

00:20:50,539 --> 00:20:56,559
are nice but the simple ones are just

00:20:53,090 --> 00:20:59,779
too abstract and more intricate ones

00:20:56,559 --> 00:21:02,269
require a lot of setup debuggers of

00:20:59,779 --> 00:21:03,950
course are the ultimate tool but it's

00:21:02,269 --> 00:21:06,080
not as an option to you know stop the

00:21:03,950 --> 00:21:09,649
program change this works code recompile

00:21:06,080 --> 00:21:11,720
something stuff like that so system tab

00:21:09,649 --> 00:21:15,080
kind of fills the gap between all of

00:21:11,720 --> 00:21:16,490
those it allows you to write scripts to

00:21:15,080 --> 00:21:21,440
observe all sorts of events on your

00:21:16,490 --> 00:21:24,740
machine system-wide live so if you know

00:21:21,440 --> 00:21:27,380
dtrace it's a similar idea to DTrace so

00:21:24,740 --> 00:21:30,019
how exactly does it work pretty much you

00:21:27,380 --> 00:21:32,090
write a system tab script and then the

00:21:30,019 --> 00:21:35,570
script gets converted into a linux

00:21:32,090 --> 00:21:37,399
kernel a linux module kernel module

00:21:35,570 --> 00:21:40,610
which then gets inserted into the kernel

00:21:37,399 --> 00:21:43,010
and then you just get data back from the

00:21:40,610 --> 00:21:45,559
module so the reason why system tap is

00:21:43,010 --> 00:21:47,690
so powerful is because we're in the

00:21:45,559 --> 00:21:49,250
kernel that means we can see pretty much

00:21:47,690 --> 00:21:54,830
everything that happens it's on the

00:21:49,250 --> 00:21:56,299
system so so just imagine you know you

00:21:54,830 --> 00:21:58,100
kind of know where something is going

00:21:56,299 --> 00:22:00,740
wrong you know you've pinpointed kind of

00:21:58,100 --> 00:22:02,659
the trouble spots in the source code and

00:22:00,740 --> 00:22:06,200
you want to find out more information

00:22:02,659 --> 00:22:08,389
about those spots so the basic structure

00:22:06,200 --> 00:22:10,850
of assistant app script reflects that so

00:22:08,389 --> 00:22:12,679
you pretty much have a trigger and a

00:22:10,850 --> 00:22:15,139
handler so the trigger is whatever you

00:22:12,679 --> 00:22:16,970
want to monitor for whatever you want to

00:22:15,139 --> 00:22:20,059
watch out for and inhaler is what you

00:22:16,970 --> 00:22:22,580
want to execute when the trigger is

00:22:20,059 --> 00:22:25,340
fired so to give a simple example for

00:22:22,580 --> 00:22:27,590
example hello world so here we're just

00:22:25,340 --> 00:22:29,390
triggering whenever the begin probe is

00:22:27,590 --> 00:22:31,880
fired which pretty much happens when the

00:22:29,390 --> 00:22:33,260
system top section is started and all we

00:22:31,880 --> 00:22:35,029
do in the handler is just print hello

00:22:33,260 --> 00:22:38,980
world you know pretty straightforward a

00:22:35,029 --> 00:22:42,590
more realistic example is you know

00:22:38,980 --> 00:22:45,740
process begin so whenever the LS process

00:22:42,590 --> 00:22:47,690
is started we just print LS web started

00:22:45,740 --> 00:22:49,400
so if you've never used system that

00:22:47,690 --> 00:22:51,020
before I mean even just that it's pretty

00:22:49,400 --> 00:22:55,159
cool you know you get to detect whenever

00:22:51,020 --> 00:22:59,240
else started no matter from where yeah

00:22:55,159 --> 00:23:01,340
on this on the whole system so we

00:22:59,240 --> 00:23:02,779
already soft crosses that begin and you

00:23:01,340 --> 00:23:05,720
know begin so those are pretty basic

00:23:02,779 --> 00:23:07,250
probes but since that supports a lot of

00:23:05,720 --> 00:23:09,620
different types of pro points which

00:23:07,250 --> 00:23:14,059
triggers or pro points that's the that's

00:23:09,620 --> 00:23:15,710
the system tapawingo for triggers so the

00:23:14,059 --> 00:23:17,419
more useful bunch of the colonel and

00:23:15,710 --> 00:23:19,909
process probes on statements and

00:23:17,419 --> 00:23:23,779
functions so for example here we're

00:23:19,909 --> 00:23:26,390
placing a probe at the statement located

00:23:23,779 --> 00:23:28,610
in the SIS read function at this

00:23:26,390 --> 00:23:31,190
specific line in this file so you see

00:23:28,610 --> 00:23:33,380
can be very precise at where you want to

00:23:31,190 --> 00:23:35,390
place your probe so this probe will fire

00:23:33,380 --> 00:23:40,010
any time the colonel goes over that line

00:23:35,390 --> 00:23:42,200
of the code in this probe we want to

00:23:40,010 --> 00:23:45,020
detect every time the main function of

00:23:42,200 --> 00:23:47,450
LS is entered so the key thing to note

00:23:45,020 --> 00:23:49,429
here is system that can do both kernels

00:23:47,450 --> 00:23:51,559
to kernel space stuff and user space

00:23:49,429 --> 00:23:54,200
stuff and in fact nothing stops you from

00:23:51,559 --> 00:23:56,630
writing a script with both both of them

00:23:54,200 --> 00:23:59,809
together which means that allows you to

00:23:56,630 --> 00:24:01,549
do probing throughout the stack and

00:23:59,809 --> 00:24:05,330
really just follow everything that

00:24:01,549 --> 00:24:07,909
happens all the way down we also support

00:24:05,330 --> 00:24:11,120
java method probes so for example you

00:24:07,909 --> 00:24:13,990
can you can fire probe anytime a certain

00:24:11,120 --> 00:24:17,059
method matching a specific pattern is

00:24:13,990 --> 00:24:21,049
it's called in a specific class name in

00:24:17,059 --> 00:24:23,299
a certain PID of a java process other

00:24:21,049 --> 00:24:25,399
noteworthy types include perf probes if

00:24:23,299 --> 00:24:27,919
you want to use performance counters

00:24:25,399 --> 00:24:29,630
hardware performance counters timer

00:24:27,919 --> 00:24:32,179
probes if you want to for example fire

00:24:29,630 --> 00:24:34,270
something every 100 microseconds

00:24:32,179 --> 00:24:37,630
regardless of where you are in the code

00:24:34,270 --> 00:24:41,270
netfilter probes if you want to react to

00:24:37,630 --> 00:24:45,560
network events sdt marker probes

00:24:41,270 --> 00:24:48,260
those are useful if you place if you

00:24:45,560 --> 00:24:51,890
place probes inside of your code like in

00:24:48,260 --> 00:24:53,840
your source code and yeah so you can

00:24:51,890 --> 00:24:56,180
explicitly say where you want to place

00:24:53,840 --> 00:24:58,310
the probes so we give you the include

00:24:56,180 --> 00:25:00,860
file for that and you can just pop it in

00:24:58,310 --> 00:25:02,480
and in fact this is also compatible with

00:25:00,860 --> 00:25:04,820
dtrace marker probes if you already use

00:25:02,480 --> 00:25:08,000
those in your code that's system that

00:25:04,820 --> 00:25:10,040
can use those as well so if you want to

00:25:08,000 --> 00:25:12,530
list all the supported probe types of

00:25:10,040 --> 00:25:15,620
system tap you can just do stab dash

00:25:12,530 --> 00:25:26,690
dash down probe types so in fact I can

00:25:15,620 --> 00:25:27,950
do that right now so these are all the

00:25:26,690 --> 00:25:29,990
types of probes that system tough

00:25:27,950 --> 00:25:32,150
support so we we talked about the timer

00:25:29,990 --> 00:25:34,190
probes and you're just you've got a lot

00:25:32,150 --> 00:25:36,040
of stuff here so you know I would

00:25:34,190 --> 00:25:38,330
encourage you like before you write your

00:25:36,040 --> 00:25:40,460
script you know just take a look and see

00:25:38,330 --> 00:25:45,500
what could interest you it's really a

00:25:40,460 --> 00:25:47,530
wealth of possibilities so the language

00:25:45,500 --> 00:25:49,370
itself the system tap language is pretty

00:25:47,530 --> 00:25:50,780
straightforward it's what you would

00:25:49,370 --> 00:25:52,010
expect from a scripting language you've

00:25:50,780 --> 00:25:54,230
got you know your variables your

00:25:52,010 --> 00:25:56,360
conditionals your loops your functions

00:25:54,230 --> 00:25:58,280
so pretty much if you've programmed in

00:25:56,360 --> 00:26:00,860
any high-level scripting language before

00:25:58,280 --> 00:26:02,300
you should be fine should be ok so

00:26:00,860 --> 00:26:05,510
there's a few things that are more

00:26:02,300 --> 00:26:07,460
specific to system tab so we have a

00:26:05,510 --> 00:26:09,620
couple key to raise which pretty much

00:26:07,460 --> 00:26:12,290
means that you can have a race that are

00:26:09,620 --> 00:26:14,750
not just indexed by an integer but by

00:26:12,290 --> 00:26:17,270
two integers or an integer n string or

00:26:14,750 --> 00:26:19,250
whatever you want you know and then you

00:26:17,270 --> 00:26:21,710
also have for each loops which kind of

00:26:19,250 --> 00:26:25,250
our special loops to iterate through

00:26:21,710 --> 00:26:27,160
those special kinds of arrays you also

00:26:25,250 --> 00:26:29,990
have aggregates which are pretty much

00:26:27,160 --> 00:26:31,370
sets which allow you to collect sets of

00:26:29,990 --> 00:26:33,770
numbers and then just perform

00:26:31,370 --> 00:26:37,580
statistical operations on them like main

00:26:33,770 --> 00:26:40,190
max mean you have mackerels if you know

00:26:37,580 --> 00:26:43,730
c macros it's the exact same idea so

00:26:40,190 --> 00:26:45,530
pretty much identifiers that the that

00:26:43,730 --> 00:26:48,470
are expanded to something else during

00:26:45,530 --> 00:26:49,790
the parsing stage and then you know

00:26:48,470 --> 00:26:51,710
regular expression matching if you want

00:26:49,790 --> 00:26:54,279
to check if the string matches a regular

00:26:51,710 --> 00:26:55,960
expression so

00:26:54,279 --> 00:26:58,029
the really powerful thing about system

00:26:55,960 --> 00:27:00,090
tab is that it allows you to access

00:26:58,029 --> 00:27:03,399
context variables so what does that mean

00:27:00,090 --> 00:27:05,590
so for example here we're probing for

00:27:03,399 --> 00:27:07,359
the sis right kernel function so this

00:27:05,590 --> 00:27:09,759
could correspond to the right system

00:27:07,359 --> 00:27:12,969
call when you when you're doing your C

00:27:09,759 --> 00:27:14,919
coding and whenever that Pro fires you

00:27:12,969 --> 00:27:17,499
can actually have access to whatever

00:27:14,919 --> 00:27:19,749
variable is local in that point of the

00:27:17,499 --> 00:27:21,129
code so if you want to find out what are

00:27:19,749 --> 00:27:23,080
those variables I that you would have

00:27:21,129 --> 00:27:25,599
access to it you can use the dash L

00:27:23,080 --> 00:27:27,999
option of system tab so here are just do

00:27:25,599 --> 00:27:31,690
you know stabbed a shell kernel function

00:27:27,999 --> 00:27:32,739
this right and it'll tell you ok this is

00:27:31,690 --> 00:27:35,529
the function this is where it's located

00:27:32,739 --> 00:27:37,269
line 5 16 and if you do probe this

00:27:35,529 --> 00:27:40,509
function you will have access to the

00:27:37,269 --> 00:27:42,700
file descriptor the buffer the count and

00:27:40,509 --> 00:27:45,249
right which is which is just a local

00:27:42,700 --> 00:27:47,259
variable so so the FD buffing count if

00:27:45,249 --> 00:27:48,820
you like no see those are pretty much

00:27:47,259 --> 00:27:52,450
the parameters that you pass to right

00:27:48,820 --> 00:27:57,219
right so so I mean it's pretty powerful

00:27:52,450 --> 00:28:00,849
stuff so the dash L notation in general

00:27:57,219 --> 00:28:03,729
it's it's good to just figure out what

00:28:00,849 --> 00:28:06,669
are the probable functions so here we're

00:28:03,729 --> 00:28:08,229
doing process LS that function star so

00:28:06,669 --> 00:28:14,559
storming pretty much means all the

00:28:08,229 --> 00:28:16,119
functions so if I actually run this so

00:28:14,559 --> 00:28:22,839
I'm just going to cat it first to show

00:28:16,119 --> 00:28:24,369
you right it just do that does that so

00:28:22,839 --> 00:28:27,460
these are all the functions that you can

00:28:24,369 --> 00:28:31,169
probe in the ls process right so I mean

00:28:27,460 --> 00:28:34,839
just to give you a simple example here

00:28:31,169 --> 00:28:39,009
so for example here rev s your comp a

00:28:34,839 --> 00:28:41,909
time right so it's telling you that if

00:28:39,009 --> 00:28:45,009
you if you probe that that function

00:28:41,909 --> 00:28:50,799
you'll have access to the a context

00:28:45,009 --> 00:28:54,399
variable and the B complex variable ok

00:28:50,799 --> 00:28:57,729
so system tab comes shaped with task

00:28:54,399 --> 00:28:59,320
sets which are pretty much like the it's

00:28:57,729 --> 00:29:02,409
pretty much analogous to a library in

00:28:59,320 --> 00:29:04,690
your in your north in other languages so

00:29:02,409 --> 00:29:07,149
what do they contain one of the major

00:29:04,690 --> 00:29:07,990
things they contain our probe aliases so

00:29:07,149 --> 00:29:11,470
what does that mean

00:29:07,990 --> 00:29:14,380
for example as we saw before instead of

00:29:11,470 --> 00:29:17,020
probing the kernel function sis right

00:29:14,380 --> 00:29:18,490
call you can just do sis called out

00:29:17,020 --> 00:29:21,580
right so what is the advantage of that

00:29:18,490 --> 00:29:23,500
well depending on what kind of system

00:29:21,580 --> 00:29:26,080
you're on the right system call won't

00:29:23,500 --> 00:29:28,900
always map onto the cyst right kernel

00:29:26,080 --> 00:29:31,330
function call so instead you can just do

00:29:28,900 --> 00:29:33,550
sis called out right and that'll dip on

00:29:31,330 --> 00:29:36,880
whatever machine you're on that will try

00:29:33,550 --> 00:29:40,300
to catch the kernel function that

00:29:36,880 --> 00:29:42,550
corresponds to a right call let's say so

00:29:40,300 --> 00:29:44,230
in that sense tap set the probe alias

00:29:42,550 --> 00:29:45,940
kind of allows you to abstract away the

00:29:44,230 --> 00:29:49,780
differences between architectures and

00:29:45,940 --> 00:29:52,179
make your script more portable so taxes

00:29:49,780 --> 00:29:55,929
also contain helper functions so for

00:29:52,179 --> 00:29:58,300
example here were probing Cisco Cisco

00:29:55,929 --> 00:30:00,130
out right any any times that anything

00:29:58,300 --> 00:30:03,070
that happens we use the use of string

00:30:00,130 --> 00:30:07,110
and function to retrieve whatever string

00:30:03,070 --> 00:30:09,580
is located at at the address buff and

00:30:07,110 --> 00:30:11,380
cut that off and only print the first

00:30:09,580 --> 00:30:13,390
count number of characters so of course

00:30:11,380 --> 00:30:15,940
that'll only work if it's a string right

00:30:13,390 --> 00:30:18,010
maybe it's just binary dinner but I want

00:30:15,940 --> 00:30:19,900
you to notice here right buff encounter

00:30:18,010 --> 00:30:21,220
the context variables we saw earlier

00:30:19,900 --> 00:30:23,620
they're just the parameters that were

00:30:21,220 --> 00:30:25,600
passed right but the more important

00:30:23,620 --> 00:30:28,809
thing is this is really powerful stuff

00:30:25,600 --> 00:30:31,570
it allows you to catch or intercept all

00:30:28,809 --> 00:30:34,000
the right system calls through the whole

00:30:31,570 --> 00:30:37,000
system I mean that gives you a lot of

00:30:34,000 --> 00:30:38,590
things to play with the tab set also

00:30:37,000 --> 00:30:40,600
includes helper variables so for example

00:30:38,590 --> 00:30:43,630
here again we're just probing sis called

00:30:40,600 --> 00:30:45,280
out right and instead of you know trying

00:30:43,630 --> 00:30:49,000
to look at each individual parameter we

00:30:45,280 --> 00:30:50,710
just use the arc string variable and

00:30:49,000 --> 00:30:52,690
that will just give you a nice little

00:30:50,710 --> 00:30:54,370
printout of all the primaries our past

00:30:52,690 --> 00:30:56,830
to write and string format instead of

00:30:54,370 --> 00:30:58,870
just trying to hunt down all the

00:30:56,830 --> 00:31:00,370
different parameters so if you notice

00:30:58,870 --> 00:31:01,780
here there's no dollar sign in front

00:31:00,370 --> 00:31:03,460
because that's just a normal regular

00:31:01,780 --> 00:31:09,610
variable assistant that variable it's

00:31:03,460 --> 00:31:11,050
not a context variable oh it's one

00:31:09,610 --> 00:31:13,990
string with all the parameters

00:31:11,050 --> 00:31:16,179
concatenated in string format so you

00:31:13,990 --> 00:31:19,330
would have liked FD buff which will

00:31:16,179 --> 00:31:21,900
probably be the address and then the

00:31:19,330 --> 00:31:21,900
count

00:31:27,769 --> 00:31:35,159
yeah I'll get into that there's another

00:31:30,720 --> 00:31:37,440
yeah so okay so other useful types of

00:31:35,159 --> 00:31:40,769
functions so returning strings we saw

00:31:37,440 --> 00:31:42,629
that with user string n retrieving mean

00:31:40,769 --> 00:31:45,450
and function arguments so for example if

00:31:42,629 --> 00:31:48,809
she have the process if you're looking

00:31:45,450 --> 00:31:51,120
for any time the main function of LS is

00:31:48,809 --> 00:31:52,529
entered you can use the command line

00:31:51,120 --> 00:31:54,799
string function which would pretty much

00:31:52,529 --> 00:31:56,940
print out in a pretty human readable

00:31:54,799 --> 00:31:59,610
format what were the parameters ever

00:31:56,940 --> 00:32:01,289
passed two LS so in fact this is not

00:31:59,610 --> 00:32:04,440
specific to me and you can call that

00:32:01,289 --> 00:32:06,629
from other process probes but anyway

00:32:04,440 --> 00:32:10,289
yeah it'll print out the arguments

00:32:06,629 --> 00:32:12,450
passed to LS here we're catching every

00:32:10,289 --> 00:32:14,879
time the open file function of nano is

00:32:12,450 --> 00:32:17,639
entered and so here we use this notation

00:32:14,879 --> 00:32:20,070
so that addresses your question a bit so

00:32:17,639 --> 00:32:21,990
we have dollar sign to dollar signs in

00:32:20,070 --> 00:32:24,119
front and two dollars in the back and we

00:32:21,990 --> 00:32:26,279
use parms and what that pretty much

00:32:24,119 --> 00:32:29,029
means is print all the parameters that

00:32:26,279 --> 00:32:31,710
were passed to the open file function in

00:32:29,029 --> 00:32:34,590
human friendly format so for example if

00:32:31,710 --> 00:32:36,570
if they're strings try to you know print

00:32:34,590 --> 00:32:38,220
out the string if it's a struct try to

00:32:36,570 --> 00:32:43,889
follow the members and print out the

00:32:38,220 --> 00:32:45,419
members of the shot stuff like that i'm

00:32:43,889 --> 00:32:49,200
not sure i'm not familiar with that

00:32:45,419 --> 00:32:50,940
stray so it does its best to in this

00:32:49,200 --> 00:32:53,190
case just print out the parameters of

00:32:50,940 --> 00:33:02,419
that function what do you mean

00:32:53,190 --> 00:33:02,419
specifically like ashtrays though yeah

00:33:02,809 --> 00:33:08,419
yeah exactly so what does that's exactly

00:33:05,490 --> 00:33:08,419
what this does yeah

00:33:15,120 --> 00:33:19,929
so other useful test functions if you

00:33:18,460 --> 00:33:22,150
want to retrieve the name of the pro

00:33:19,929 --> 00:33:24,340
point or the function probe so let me

00:33:22,150 --> 00:33:27,130
explain that one so here we're probing

00:33:24,340 --> 00:33:29,200
all the functions in LS right so I use a

00:33:27,130 --> 00:33:31,929
star notation that means going to fire

00:33:29,200 --> 00:33:34,900
any time any function in LS is it's

00:33:31,929 --> 00:33:36,820
called so of course whenever it fires

00:33:34,900 --> 00:33:39,100
you want to know what function was

00:33:36,820 --> 00:33:42,010
actually fired so for that purpose you

00:33:39,100 --> 00:33:44,410
have the pp and the pp funk function so

00:33:42,010 --> 00:33:46,120
PP will just resolve to the full name of

00:33:44,410 --> 00:33:47,740
the pro point so for example if main was

00:33:46,120 --> 00:33:50,830
fired it's going to contain a string

00:33:47,740 --> 00:33:53,169
containing process LS function main on

00:33:50,830 --> 00:33:54,940
the other hand PP funk just holds the

00:33:53,169 --> 00:33:56,470
name of the function alone so if its

00:33:54,940 --> 00:34:00,790
main it's going to just be made in

00:33:56,470 --> 00:34:03,070
strength format if you want to issue a

00:34:00,790 --> 00:34:05,770
system a system command you can use the

00:34:03,070 --> 00:34:10,359
system tab set function so here anytime

00:34:05,770 --> 00:34:15,070
mean is entered we just spawn echo main

00:34:10,359 --> 00:34:16,960
started you know okay so another cool

00:34:15,070 --> 00:34:20,139
thing with system tab is the dash X

00:34:16,960 --> 00:34:23,139
switch so let me explain why that's

00:34:20,139 --> 00:34:25,090
really useful so here we're using we're

00:34:23,139 --> 00:34:26,919
probing all the right system calls right

00:34:25,090 --> 00:34:28,540
now of course that's powerful stuff you

00:34:26,919 --> 00:34:29,830
can see the whole system but most of the

00:34:28,540 --> 00:34:31,300
time is going to be one you're going to

00:34:29,830 --> 00:34:34,270
want to be focusing on a specific

00:34:31,300 --> 00:34:36,460
process right so what you would do in

00:34:34,270 --> 00:34:38,200
that case is you can pass the PID of the

00:34:36,460 --> 00:34:40,960
process you're interested in two systems

00:34:38,200 --> 00:34:42,909
app with the dash X switch and then when

00:34:40,960 --> 00:34:44,440
you're in your system tab script that

00:34:42,909 --> 00:34:46,419
will trend that will end up in the

00:34:44,440 --> 00:34:47,980
target function so whenever target is

00:34:46,419 --> 00:34:49,840
called that just returns this PID that

00:34:47,980 --> 00:34:53,230
you that you passed with the dash X

00:34:49,840 --> 00:34:54,760
which so so okay so we have target

00:34:53,230 --> 00:34:57,070
function and then the PID function

00:34:54,760 --> 00:34:59,050
returns whatever is the PID of the

00:34:57,070 --> 00:35:01,300
process that did the right system call

00:34:59,050 --> 00:35:04,450
so what we're pretty much doing here is

00:35:01,300 --> 00:35:07,420
whenever right system call is is

00:35:04,450 --> 00:35:09,100
performed check if the PID of the

00:35:07,420 --> 00:35:10,900
process who did the right is the same

00:35:09,100 --> 00:35:14,080
PID as the one we're interested in and

00:35:10,900 --> 00:35:15,580
if it is then print you know users a

00:35:14,080 --> 00:35:17,890
string and to print like whatever the

00:35:15,580 --> 00:35:19,690
user was trying to write so using just a

00:35:17,890 --> 00:35:21,460
simple technique you can filter out all

00:35:19,690 --> 00:35:25,510
the noise and just focus on what you

00:35:21,460 --> 00:35:27,390
want so now i'll show you a couple of

00:35:25,510 --> 00:35:30,759
system tap examples

00:35:27,390 --> 00:35:33,430
so Lucas talked earlier about stress and

00:35:30,759 --> 00:35:36,849
now he used it to stress his CPU and

00:35:33,430 --> 00:35:41,039
memory so you know how how to stress

00:35:36,849 --> 00:35:44,589
work Oh what functions does it have and

00:35:41,039 --> 00:35:46,569
when you do something like stress cpu 3

00:35:44,589 --> 00:35:48,279
where does it Spanish time stressing the

00:35:46,569 --> 00:35:50,799
CPU so those are the kind of questions

00:35:48,279 --> 00:35:52,059
that system that can easily answer so

00:35:50,799 --> 00:35:54,099
the first question what functions does

00:35:52,059 --> 00:35:56,349
it have well we saw that already right

00:35:54,099 --> 00:35:58,329
you can just do stabbed a shell process

00:35:56,349 --> 00:36:02,980
stress the function and use the star

00:35:58,329 --> 00:36:06,099
notation so in fact if I do this so I'll

00:36:02,980 --> 00:36:09,339
just show you the contents of the of

00:36:06,099 --> 00:36:12,609
this so you know exactly what I shows

00:36:09,339 --> 00:36:14,049
you and then so these are all the

00:36:12,609 --> 00:36:17,529
functions aren't stressed you know so

00:36:14,049 --> 00:36:21,609
okay not a big list you know maybe 10 12

00:36:17,529 --> 00:36:23,109
12 functions so that's pretty cool the

00:36:21,609 --> 00:36:25,299
cooler question is where does the

00:36:23,109 --> 00:36:27,039
Spanish time stressing the CPU so for

00:36:25,299 --> 00:36:29,349
that we can write a very simple system

00:36:27,039 --> 00:36:31,569
tab script so I'm going to go through it

00:36:29,349 --> 00:36:33,670
line by line with you so first we

00:36:31,569 --> 00:36:36,190
declared two global variables funks and

00:36:33,670 --> 00:36:39,369
cur so Fox is pretty much going to be a

00:36:36,190 --> 00:36:41,410
an array and Kerr is just going to be a

00:36:39,369 --> 00:36:46,059
string so I'll show you why what they're

00:36:41,410 --> 00:36:48,309
for so the first prob'ly place is to

00:36:46,059 --> 00:36:50,349
catch all the function calls in the

00:36:48,309 --> 00:36:53,499
process in the in the stress process and

00:36:50,349 --> 00:36:55,119
all we do in the handler is just pick up

00:36:53,499 --> 00:36:57,220
whatever the name of the function is

00:36:55,119 --> 00:36:59,890
using the PT funktastic function we saw

00:36:57,220 --> 00:37:03,039
earlier and put that in the curve global

00:36:59,890 --> 00:37:04,690
variable ok so if man is fired curve

00:37:03,039 --> 00:37:06,999
will be coming here I kind of cheat

00:37:04,690 --> 00:37:09,039
because i use i initialize screw with me

00:37:06,999 --> 00:37:11,380
which is not like like technically true

00:37:09,039 --> 00:37:13,359
because if you look at a trace main it's

00:37:11,380 --> 00:37:17,200
not the very first function but it's

00:37:13,359 --> 00:37:20,710
good enough for first approximation so

00:37:17,200 --> 00:37:22,690
then the second prob'ly place is a timer

00:37:20,710 --> 00:37:25,239
probe which will fire every 100

00:37:22,690 --> 00:37:28,119
microseconds and all we do in there is

00:37:25,239 --> 00:37:30,489
increment the value of the element

00:37:28,119 --> 00:37:33,460
associated of the array element

00:37:30,489 --> 00:37:36,519
associated with the function so for

00:37:33,460 --> 00:37:39,279
example if if we're still in Maine then

00:37:36,519 --> 00:37:41,200
the value add funks main will be

00:37:39,279 --> 00:37:42,430
incremented so

00:37:41,200 --> 00:37:44,230
the end what we're going to have is

00:37:42,430 --> 00:37:47,680
folks will just be an array full of

00:37:44,230 --> 00:37:50,710
functions as the key and the amount of

00:37:47,680 --> 00:37:52,930
time spent as the value right so in that

00:37:50,710 --> 00:37:55,030
way you can kind of think of function on

00:37:52,930 --> 00:37:59,260
as an irregular map but it's pretty much

00:37:55,030 --> 00:38:02,290
the idea so then at the end we use a

00:37:59,260 --> 00:38:04,480
probe end or an N probe which pretty

00:38:02,290 --> 00:38:07,630
much gets fired whenever the system tap

00:38:04,480 --> 00:38:10,420
session is ended so all we do in in the

00:38:07,630 --> 00:38:13,660
handler is we use a for each loop to

00:38:10,420 --> 00:38:15,220
trap traverse the funks array and here

00:38:13,660 --> 00:38:17,680
if you notice I have a little minus sign

00:38:15,220 --> 00:38:20,740
after funks so that pretty much means I

00:38:17,680 --> 00:38:22,950
want to iterate through the array in

00:38:20,740 --> 00:38:26,380
order of decreasing value so that means

00:38:22,950 --> 00:38:28,660
the function where we spent the most

00:38:26,380 --> 00:38:32,079
time will be printed out first right and

00:38:28,660 --> 00:38:33,790
then in the actual loop we just say you

00:38:32,079 --> 00:38:36,460
just print out how much time was spent

00:38:33,790 --> 00:38:41,710
and the name of the function so if I

00:38:36,460 --> 00:38:48,550
actually run this it's six so again I'll

00:38:41,710 --> 00:38:51,190
just show you right so I'm just running

00:38:48,550 --> 00:38:54,460
the staff script which is the six dot

00:38:51,190 --> 00:38:57,190
SCP which is the the what was on the

00:38:54,460 --> 00:38:58,780
slide and then i use the dash c switch

00:38:57,190 --> 00:39:00,040
and the dash cease which is pretty much

00:38:58,780 --> 00:39:02,440
the same thing you can think of it as

00:39:00,040 --> 00:39:04,930
the same thing as a dash x switch where

00:39:02,440 --> 00:39:06,940
you assign a PID instead except that

00:39:04,930 --> 00:39:09,339
here system tab actually runs the

00:39:06,940 --> 00:39:14,050
command for you and assigns the PID of

00:39:09,339 --> 00:39:17,500
the resulting command to the to the to

00:39:14,050 --> 00:39:19,930
the spawn command so that's why if you

00:39:17,500 --> 00:39:21,670
if you saw in the in the script I just

00:39:19,930 --> 00:39:24,069
did process dot I didn't have to specify

00:39:21,670 --> 00:39:28,630
what process it was because i use the

00:39:24,069 --> 00:39:29,589
dash c switch so let's just run it so

00:39:28,630 --> 00:39:32,099
here all we're going to do is we're

00:39:29,589 --> 00:39:36,040
going to run stress on three CPUs or

00:39:32,099 --> 00:39:38,710
three instances for five seconds so it's

00:39:36,040 --> 00:39:41,290
running and then it gives us a printout

00:39:38,710 --> 00:39:43,569
so these lines are from stress itself

00:39:41,290 --> 00:39:46,540
and these lines are from the system tab

00:39:43,569 --> 00:39:48,400
module right so it's done is that ok of

00:39:46,540 --> 00:39:51,069
the five seconds that we're in stress

00:39:48,400 --> 00:39:54,190
for 4.99 seven seconds were in a

00:39:51,069 --> 00:39:55,180
function called Hawk cpu ok sounds

00:39:54,190 --> 00:39:58,119
pretty

00:39:55,180 --> 00:40:00,670
believable three point nine milliseconds

00:39:58,119 --> 00:40:02,170
were spent in Maine and four point three

00:40:00,670 --> 00:40:03,970
point four milliseconds were spent in

00:40:02,170 --> 00:40:06,849
effort f probably when I was printing

00:40:03,970 --> 00:40:09,609
those two print statements so the point

00:40:06,849 --> 00:40:11,050
here is 0 actually normally that one

00:40:09,609 --> 00:40:15,190
doesn't show up but yeah 100

00:40:11,050 --> 00:40:18,040
microseconds and a tall I'm score s so

00:40:15,190 --> 00:40:21,069
the point is here with a very few lines

00:40:18,040 --> 00:40:23,559
of scripting you can get very rich

00:40:21,069 --> 00:40:25,089
information back you know and in fact if

00:40:23,559 --> 00:40:27,819
you notice here I haven't written the

00:40:25,089 --> 00:40:29,800
word stress once in the whole script

00:40:27,819 --> 00:40:31,809
right that means you can use this script

00:40:29,800 --> 00:40:34,180
with any executable you want and i'll

00:40:31,809 --> 00:40:36,220
give you the same preta of course it

00:40:34,180 --> 00:40:39,819
would have to be like a C or C++ program

00:40:36,220 --> 00:40:43,059
where you have debug info on the on the

00:40:39,819 --> 00:40:47,440
functions for the for the for the

00:40:43,059 --> 00:40:49,150
executable okay so now I'll show you a

00:40:47,440 --> 00:40:51,550
second example which is a little more

00:40:49,150 --> 00:40:53,740
involved but it really shows you the

00:40:51,550 --> 00:40:56,770
power of system tab so here we've got a

00:40:53,740 --> 00:40:58,839
really simple C program so let's just

00:40:56,770 --> 00:41:02,829
focus on main first and main all we do

00:40:58,839 --> 00:41:04,839
is we call next number in max times okay

00:41:02,829 --> 00:41:08,230
and then next number what does it do it

00:41:04,839 --> 00:41:10,960
just returns 0 then 1 then 2 etc right

00:41:08,230 --> 00:41:12,700
now there's two things to note first of

00:41:10,960 --> 00:41:15,040
all next number of returns are short

00:41:12,700 --> 00:41:17,020
okay that means it's going to that means

00:41:15,040 --> 00:41:19,599
counter will always be between short min

00:41:17,020 --> 00:41:23,200
and short max the other thing is in

00:41:19,599 --> 00:41:24,760
Maine we call next number in max time so

00:41:23,200 --> 00:41:29,380
what does that mean what could happen

00:41:24,760 --> 00:41:31,569
here exactly right so if you're on a

00:41:29,380 --> 00:41:33,970
system where a short and an int are the

00:41:31,569 --> 00:41:36,970
same thing you'll be safe right you you

00:41:33,970 --> 00:41:39,549
won't call an ex number you yo your

00:41:36,970 --> 00:41:42,160
state variable will never overflow but

00:41:39,549 --> 00:41:44,980
otherwise your state variable will wrap

00:41:42,160 --> 00:41:46,569
around before its time and that will

00:41:44,980 --> 00:41:48,130
give you a negative state which can have

00:41:46,569 --> 00:41:50,559
disastrous consequences right just

00:41:48,130 --> 00:41:53,349
imagine this is just scale this idea up

00:41:50,559 --> 00:41:55,839
to a huge program and you know you get

00:41:53,349 --> 00:41:59,200
into an invalid state that's just the n

00:41:55,839 --> 00:42:01,059
right so here just for the purpose of

00:41:59,200 --> 00:42:04,480
the demo we've added two lines which

00:42:01,059 --> 00:42:07,000
just pretty much prints out a statement

00:42:04,480 --> 00:42:08,290
anytime state is negative of course if

00:42:07,000 --> 00:42:09,190
you're writing code and you have these

00:42:08,290 --> 00:42:10,599
lines that means

00:42:09,190 --> 00:42:12,849
you're thinking that state could be

00:42:10,599 --> 00:42:16,950
negative so you take the precaution so

00:42:12,849 --> 00:42:19,630
that's why I had these lines after so

00:42:16,950 --> 00:42:21,339
just imagine it's part of a way bigger

00:42:19,630 --> 00:42:23,230
program you know you can't just stop it

00:42:21,339 --> 00:42:25,300
fix it and recompile it has to keep

00:42:23,230 --> 00:42:27,220
running so how can you make sure that

00:42:25,300 --> 00:42:31,930
you never end up in an invalid negative

00:42:27,220 --> 00:42:35,740
state well that's the perfect job for

00:42:31,930 --> 00:42:37,540
system tab so how can you use system tap

00:42:35,740 --> 00:42:39,640
or something like this okay so we just

00:42:37,540 --> 00:42:42,520
need to place three probes okay the

00:42:39,640 --> 00:42:44,680
first probe we place it at the statement

00:42:42,520 --> 00:42:46,900
at line 13 does anyone remember what

00:42:44,680 --> 00:42:51,670
length 13 is that's okay I don't either

00:42:46,900 --> 00:42:53,470
so line 13 is line 13 is where state is

00:42:51,670 --> 00:42:56,109
assigned in the next number so this

00:42:53,470 --> 00:42:57,970
probe will fire after that line is

00:42:56,109 --> 00:43:01,060
executed so state would have just

00:42:57,970 --> 00:43:02,260
received its new value right so we can

00:43:01,060 --> 00:43:04,960
use that probe to keep track of the

00:43:02,260 --> 00:43:06,520
state the second probe we use it to

00:43:04,960 --> 00:43:08,560
intercept whenever the next number

00:43:06,520 --> 00:43:11,770
function is returned and we watch out

00:43:08,560 --> 00:43:13,839
for an invalid transition so again right

00:43:11,770 --> 00:43:16,450
just process my app function and then

00:43:13,839 --> 00:43:19,210
notice dot return at the end to mean I

00:43:16,450 --> 00:43:20,619
don't want to I don't want I don't I

00:43:19,210 --> 00:43:22,119
don't want this fire when we enter the

00:43:20,619 --> 00:43:23,619
function I wanted to fire when we return

00:43:22,119 --> 00:43:27,160
the function when we return from the

00:43:23,619 --> 00:43:30,460
function okay and the third probe is

00:43:27,160 --> 00:43:31,480
when we enter next function so it's

00:43:30,460 --> 00:43:35,170
pretty much the same thing without the

00:43:31,480 --> 00:43:37,089
dot return suffix and we out it'll make

00:43:35,170 --> 00:43:39,190
more sense in the script but will use it

00:43:37,089 --> 00:43:42,940
to reset the counter so let me show you

00:43:39,190 --> 00:43:45,099
the script now so first we have to go

00:43:42,940 --> 00:43:47,680
above Arial state and reset counter and

00:43:45,099 --> 00:43:49,089
then we have our first probe from the

00:43:47,680 --> 00:43:51,849
previous slide and all it does is you

00:43:49,089 --> 00:43:54,130
know pick up the new state from the

00:43:51,849 --> 00:43:56,650
context state variable and put it in the

00:43:54,130 --> 00:43:58,420
global state variable and then the

00:43:56,650 --> 00:44:00,520
second probe we saw which is when next

00:43:58,420 --> 00:44:02,920
number returns we just check if the

00:44:00,520 --> 00:44:04,960
return value is negative so here again

00:44:02,920 --> 00:44:07,390
right notice the dollar sign in front so

00:44:04,960 --> 00:44:09,720
this is a context variable it's it'll be

00:44:07,390 --> 00:44:12,460
the value that next number will return

00:44:09,720 --> 00:44:13,810
so all we do here is check if it's

00:44:12,460 --> 00:44:15,160
negative because we don't want it to be

00:44:13,810 --> 00:44:17,500
negative right we check for negative and

00:44:15,160 --> 00:44:19,510
if it is then we say okay invalid state

00:44:17,500 --> 00:44:21,520
detected we're about to go from this

00:44:19,510 --> 00:44:22,779
positive value to that negative value

00:44:21,520 --> 00:44:25,059
and then

00:44:22,779 --> 00:44:28,209
this is where the true power assistant

00:44:25,059 --> 00:44:30,640
app shines you can modify the context

00:44:28,209 --> 00:44:33,339
variable so we're like stop it set

00:44:30,640 --> 00:44:36,759
return to zero you know and then we have

00:44:33,339 --> 00:44:38,529
we set reset counter to one and the

00:44:36,759 --> 00:44:41,140
reason for this is that in the next

00:44:38,529 --> 00:44:43,679
probe which is fired whenever next

00:44:41,140 --> 00:44:46,779
number is entered if reset counter is is

00:44:43,679 --> 00:44:48,159
one we also reset the counter the

00:44:46,779 --> 00:44:50,229
counter context variable so the reason

00:44:48,159 --> 00:44:53,380
for this if you remember the C code it's

00:44:50,229 --> 00:44:56,349
so that whenever the return value is

00:44:53,380 --> 00:44:58,269
negative we not only reset the return

00:44:56,349 --> 00:45:00,400
value on the spot so that state is never

00:44:58,269 --> 00:45:02,079
assigned the negative value but we also

00:45:00,400 --> 00:45:04,329
make sure that when next number is

00:45:02,079 --> 00:45:06,069
called the next time it's going to be

00:45:04,329 --> 00:45:09,849
the counter will also be reset to zero

00:45:06,069 --> 00:45:14,229
so we restart from zero and off so how

00:45:09,849 --> 00:45:16,319
does this work in practice okay so and I

00:45:14,229 --> 00:45:21,009
got remember so first I'm just going to

00:45:16,319 --> 00:45:23,799
recompile the program can never be can

00:45:21,009 --> 00:45:26,949
never hurt so on in the bottom window

00:45:23,799 --> 00:45:28,449
I'll just run the application so if you

00:45:26,949 --> 00:45:29,859
remember we had print statements that

00:45:28,449 --> 00:45:32,380
would print out something anytime the

00:45:29,859 --> 00:45:37,449
state was negative right so that's that

00:45:32,380 --> 00:45:39,909
print statement so its present premiere

00:45:37,449 --> 00:45:42,849
showing us that state is going into the

00:45:39,909 --> 00:45:45,339
negatives right and then here I'm going

00:45:42,849 --> 00:45:46,959
to run the system tab script so here I'm

00:45:45,339 --> 00:45:48,519
going to use the dash V switch which

00:45:46,959 --> 00:45:51,969
means we're both so give me more output

00:45:48,519 --> 00:45:54,369
and the GSG switch which pretty much

00:45:51,969 --> 00:45:57,009
means allow me to modify context

00:45:54,369 --> 00:45:59,049
variables because you might always want

00:45:57,009 --> 00:46:01,779
people to be able to modify it anyway I

00:45:59,049 --> 00:46:08,489
will get into it but G G stands for guru

00:46:01,779 --> 00:46:13,839
mode enemies I know what I'm doing and

00:46:08,489 --> 00:46:16,719
then so now let's start the system tab

00:46:13,839 --> 00:46:19,329
script so what will happen is as soon as

00:46:16,719 --> 00:46:21,880
the module is inserted system tab will

00:46:19,329 --> 00:46:24,009
intercept any time the state is about to

00:46:21,880 --> 00:46:26,769
go into an invalid state and stop it

00:46:24,009 --> 00:46:28,659
from happening see so right away it

00:46:26,769 --> 00:46:31,299
stops printing out invalid state because

00:46:28,659 --> 00:46:33,400
we catch it before it goes into the

00:46:31,299 --> 00:46:34,989
negatives NS system tab tells us you

00:46:33,400 --> 00:46:36,610
know in bad state detected about to go

00:46:34,989 --> 00:46:39,010
from 32,000 2-30

00:46:36,610 --> 00:46:42,910
two thousand and in fact if I stop the

00:46:39,010 --> 00:46:44,950
system tab script BAM we go it starts

00:46:42,910 --> 00:46:54,580
going back to think about it again start

00:46:44,950 --> 00:46:57,280
it again and we're happy sad happy right

00:46:54,580 --> 00:46:58,660
it's just it's just an example but

00:46:57,280 --> 00:47:00,820
depending on your application right you

00:46:58,660 --> 00:47:02,710
would have something more complex you

00:47:00,820 --> 00:47:04,390
know maybe you know you're checking for

00:47:02,710 --> 00:47:06,040
the index with your rate not to be

00:47:04,390 --> 00:47:07,990
negative or out of bounds you know it

00:47:06,040 --> 00:47:09,670
just depends on your application but the

00:47:07,990 --> 00:47:13,390
big point here that I want to focus on

00:47:09,670 --> 00:47:16,270
is that let me just just so Lucas is

00:47:13,390 --> 00:47:18,460
laptop this and freaked out so the big

00:47:16,270 --> 00:47:20,950
picture here is that you know first of

00:47:18,460 --> 00:47:23,320
all we're able to inspect context

00:47:20,950 --> 00:47:25,630
variables and on top of that we can

00:47:23,320 --> 00:47:28,690
modify context variables so this gives

00:47:25,630 --> 00:47:30,640
you really awesome power to do you know

00:47:28,690 --> 00:47:34,060
all sorts of really neat stuff right and

00:47:30,640 --> 00:47:39,870
I mean this has been used to fix you

00:47:34,060 --> 00:47:43,120
know 0d 0a security holes just as like a

00:47:39,870 --> 00:47:50,250
temporary fix until a real a real fix

00:47:43,120 --> 00:47:50,250
comes out and that's it any questions

00:47:51,900 --> 00:48:17,560
yeah well for I can only speak for me

00:48:14,950 --> 00:48:20,050
personally but for sup live right so

00:48:17,560 --> 00:48:22,120
what I've used for sitting up for for

00:48:20,050 --> 00:48:24,100
example is I was writing another

00:48:22,120 --> 00:48:25,810
application which is actually part of

00:48:24,100 --> 00:48:30,880
which is going to be persistent app soon

00:48:25,810 --> 00:48:32,950
and I for some reason the another

00:48:30,880 --> 00:48:35,110
process that was relying on was creating

00:48:32,950 --> 00:48:36,850
a file using the wrong permissions but

00:48:35,110 --> 00:48:39,760
like okay let's your system tap and try

00:48:36,850 --> 00:48:41,740
to see what if it's called you mask to

00:48:39,760 --> 00:48:43,840
to set you master something different

00:48:41,740 --> 00:48:46,150
and maybe that's why the and just like

00:48:43,840 --> 00:48:47,920
that you know i can i can i place a

00:48:46,150 --> 00:48:49,930
probe right before the fast created and

00:48:47,920 --> 00:48:50,350
see what the umask is at that point in

00:48:49,930 --> 00:48:53,470
time

00:48:50,350 --> 00:48:56,620
so just I mean that that type stuff you

00:48:53,470 --> 00:48:58,660
can't do even with gdb I mean I'm I've

00:48:56,620 --> 00:49:00,850
no clue what the program does I mean how

00:48:58,660 --> 00:49:02,860
the program works internally right so be

00:49:00,850 --> 00:49:05,140
a hassle to you know go through the

00:49:02,860 --> 00:49:06,850
source code and like try to understand

00:49:05,140 --> 00:49:09,610
all the stuff and step through all that

00:49:06,850 --> 00:49:12,130
stuff so systems I've just right away i

00:49:09,610 --> 00:49:14,050
can i can do that much more quickly in

00:49:12,130 --> 00:49:16,240
comparison as well the gdb you have to

00:49:14,050 --> 00:49:18,010
again like stop the program look at it

00:49:16,240 --> 00:49:19,780
then recompile this could be on a live

00:49:18,010 --> 00:49:22,810
system right I could be like the

00:49:19,780 --> 00:49:24,520
machines at a circular or not and I you

00:49:22,810 --> 00:49:28,660
can't stop it but you gotta fix it until

00:49:24,520 --> 00:49:31,780
you can be deployed the program right

00:49:28,660 --> 00:49:33,730
you could attach yeah I don't mean that

00:49:31,780 --> 00:49:42,970
program is still owe ya right in a way

00:49:33,730 --> 00:49:44,680
right bomb we didn't stop it right I

00:49:42,970 --> 00:49:46,810
debug info needs to be liable right if

00:49:44,680 --> 00:49:48,940
you're on say no a fedora system if you

00:49:46,810 --> 00:49:50,470
saw the debug info packages say it's not

00:49:48,940 --> 00:49:52,090
program you've written install that you

00:49:50,470 --> 00:49:55,740
can then change the state their CEO its

00:49:52,090 --> 00:49:55,740
interacting with your user space program

00:50:00,180 --> 00:50:05,020
we do a very good job of catching things

00:50:02,470 --> 00:50:07,830
like inlining and optimizations let us

00:50:05,020 --> 00:50:07,830
not be miss something

00:50:28,660 --> 00:50:39,180
I was incurring heavy because might

00:50:32,980 --> 00:50:39,180
abort report to trace back to my

00:50:57,060 --> 00:50:59,120
you

00:51:10,390 --> 00:51:15,380
we support a lot of architecture on with

00:51:12,709 --> 00:51:16,699
all of them but not all of them but I

00:51:15,380 --> 00:51:19,910
mean the big ones so I think that will

00:51:16,699 --> 00:51:26,259
get URL ships with will we support so

00:51:19,910 --> 00:51:31,249
x86 was a power a iook not I actor I'm a

00:51:26,259 --> 00:51:32,420
i-64 believe still I'm s390 ah there's

00:51:31,249 --> 00:51:49,329
an octave work being done on right now

00:51:32,420 --> 00:52:09,799
it's at arm's length yeah I bad joke yes

00:51:49,329 --> 00:52:15,920
yes you can all right yeah tell us your

00:52:09,799 --> 00:52:23,660
story after tell us your story here any

00:52:15,920 --> 00:52:24,799
other questions okay thanks guys if you

00:52:23,660 --> 00:52:35,809
won't you get in contact with us this

00:52:24,799 --> 00:52:40,549
for you thank you very much she than

00:52:35,809 --> 00:52:44,199
very much for the poem thanks Dora lunch

00:52:40,549 --> 00:52:44,199

YouTube URL: https://www.youtube.com/watch?v=o3ztWWjBVOQ


