Title: FSOSS 2014 Andrew Oatley-Willis 64-bit ARM
Publication date: 2014-10-30
Playlist: FSOSS 2014
Description: 
	
Captions: 
	00:00:14,750 --> 00:00:24,450
great okay oh good morning my name is

00:00:21,779 --> 00:00:27,060
mike martin i'm a faculty member here at

00:00:24,450 --> 00:00:30,270
senate ecology and i'm here to introduce

00:00:27,060 --> 00:00:32,430
for you today the first talked up the

00:00:30,270 --> 00:00:35,370
heels of andrew lee lewis who is a

00:00:32,430 --> 00:00:39,150
research assistant at CDOT and home step

00:00:35,370 --> 00:00:41,580
into the lower but most 851 he works on

00:00:39,150 --> 00:00:43,710
arm are 64 system administration's

00:00:41,580 --> 00:00:46,620
programming and working with unstable

00:00:43,710 --> 00:00:54,960
develop deportes sums of interest so

00:00:46,620 --> 00:00:56,399
these not going to be a weapon yet just

00:00:54,960 --> 00:01:00,270
to fill in more information on some of

00:00:56,399 --> 00:01:02,730
those acronyms CDOT if you're inside the

00:01:00,270 --> 00:01:05,250
keynote center for development of open

00:01:02,730 --> 00:01:07,350
technologies here at Seneca I'm a

00:01:05,250 --> 00:01:09,840
research assistant there and I work on

00:01:07,350 --> 00:01:12,450
the Oh step team which is open source

00:01:09,840 --> 00:01:14,100
technology for emerging platforms so

00:01:12,450 --> 00:01:16,950
dealing basically with emerging

00:01:14,100 --> 00:01:19,470
platforms that show up and working on

00:01:16,950 --> 00:01:21,810
them for a lot of things so the talk i'm

00:01:19,470 --> 00:01:24,390
going to be giving today is on 64-bit

00:01:21,810 --> 00:01:27,150
ARM and it's more of an introductory

00:01:24,390 --> 00:01:30,229
talk to a little of arm but then it

00:01:27,150 --> 00:01:34,380
moves over to 64-bit ARM which is

00:01:30,229 --> 00:01:35,729
recently emerging and i'll be talking

00:01:34,380 --> 00:01:40,170
about some of the differences between

00:01:35,729 --> 00:01:43,229
them the improvement on the newer 64-bit

00:01:40,170 --> 00:01:47,640
ARM and the future of both 32-bit arm

00:01:43,229 --> 00:01:50,790
and 64-bit ARM so here's the overview

00:01:47,640 --> 00:01:54,240
first the introduction differences this

00:01:50,790 --> 00:01:57,090
status of the software of 64-bit ARM so

00:01:54,240 --> 00:02:01,680
where they are in the process of porting

00:01:57,090 --> 00:02:03,450
current software over to 64 darme the

00:02:01,680 --> 00:02:05,939
status of the hardware whether you can

00:02:03,450 --> 00:02:08,670
get it how much it costs what it looks

00:02:05,939 --> 00:02:12,660
like and what it will look like when

00:02:08,670 --> 00:02:16,100
it's in a more mature form and finally

00:02:12,660 --> 00:02:20,480
just the future of 64-bit ARM and yeah

00:02:16,100 --> 00:02:24,630
so before I begin here I'll just ask

00:02:20,480 --> 00:02:28,770
introduction arm who knows what arm is

00:02:24,630 --> 00:02:32,970
alright um it's a fair amount so what is

00:02:28,770 --> 00:02:36,170
arm it's a cpu architecture similar to

00:02:32,970 --> 00:02:39,630
how x86 is a architecture so your

00:02:36,170 --> 00:02:43,380
computer you'd have at home so what arm

00:02:39,630 --> 00:02:45,330
is it's an energy-efficient cpu which

00:02:43,380 --> 00:02:51,350
has been around for a very long time

00:02:45,330 --> 00:02:54,840
it's even older than x86 64 and it's

00:02:51,350 --> 00:02:57,600
also the most popular or widely used

00:02:54,840 --> 00:02:59,910
processor in the world you might not

00:02:57,600 --> 00:03:02,730
know not necessarily in computers but in

00:02:59,910 --> 00:03:05,880
embedded devices and microcontrollers

00:03:02,730 --> 00:03:07,860
for many robotics or even in your

00:03:05,880 --> 00:03:12,090
microwave you'd have at home it has a

00:03:07,860 --> 00:03:15,150
little display on it so arm is kind of

00:03:12,090 --> 00:03:16,890
everywhere and in everything this is the

00:03:15,150 --> 00:03:21,150
32-bit arm so this is just a bit of a

00:03:16,890 --> 00:03:22,950
history on it so one thing you're going

00:03:21,150 --> 00:03:25,020
to notice during my presentation is

00:03:22,950 --> 00:03:28,700
there's a lot of really weird names in

00:03:25,020 --> 00:03:31,980
arm and it gets even more convoluted but

00:03:28,700 --> 00:03:34,800
we'll just start with these two arm v7

00:03:31,980 --> 00:03:37,680
is just another word for the

00:03:34,800 --> 00:03:39,090
architecture for the 32-bit arm there's

00:03:37,680 --> 00:03:41,760
a few others but they're not worth

00:03:39,090 --> 00:03:47,330
mentioning right now and arm VA is the

00:03:41,760 --> 00:03:51,090
newest 64-bit ARM some other names there

00:03:47,330 --> 00:03:55,470
within the umbrella of the architecture

00:03:51,090 --> 00:03:57,810
arm v8 which is the 64-bit ARM you have

00:03:55,470 --> 00:04:00,030
a arc 64 so if you ever see this

00:03:57,810 --> 00:04:03,030
anywhere or anything i'm not sure if

00:04:00,030 --> 00:04:09,540
anyone has seen this before that's the

00:04:03,030 --> 00:04:13,410
execution state for ya forearm v6 our

00:04:09,540 --> 00:04:15,570
sorry arm v8 and it's also what they

00:04:13,410 --> 00:04:20,250
call the instruction set for its

00:04:15,570 --> 00:04:24,410
assembly language a arc 32 is a

00:04:20,250 --> 00:04:30,270
secondary execution state within the arm

00:04:24,410 --> 00:04:33,320
v8 but it allows for the execution not

00:04:30,270 --> 00:04:36,650
of legacy code but of code written for

00:04:33,320 --> 00:04:36,650
32-bit registers

00:04:36,700 --> 00:04:43,210
so what this means is it allows you to

00:04:39,500 --> 00:04:47,060
write code or write software for a

00:04:43,210 --> 00:04:50,990
32-bit arm device using the instruction

00:04:47,060 --> 00:04:54,310
set of a 64-bit ARM device and that code

00:04:50,990 --> 00:04:57,170
will be backwards compatible with all 32

00:04:54,310 --> 00:04:59,600
32-bit arm devices this doesn't mean

00:04:57,170 --> 00:05:02,660
that you can write necessarily code for

00:04:59,600 --> 00:05:04,910
older devices and move it to Eric 64

00:05:02,660 --> 00:05:08,150
it'll just it just means you can move it

00:05:04,910 --> 00:05:13,610
backwards from the new 64-bit ARM to the

00:05:08,150 --> 00:05:16,400
older ones this is sort of an important

00:05:13,610 --> 00:05:19,150
note because it allows you to bring back

00:05:16,400 --> 00:05:22,880
older software but for the most part

00:05:19,150 --> 00:05:26,420
64-bit ARM has actually removed most of

00:05:22,880 --> 00:05:32,120
the legacy code within it so it won't

00:05:26,420 --> 00:05:34,010
run any older arm devices much older so

00:05:32,120 --> 00:05:36,320
that's one of the differences I'll be

00:05:34,010 --> 00:05:38,360
talking about next so what are the

00:05:36,320 --> 00:05:42,590
differences between the 32-bit arm and

00:05:38,360 --> 00:05:45,950
the new 64-bit are so the first one to

00:05:42,590 --> 00:05:47,840
note is in the 32-bit architecture you

00:05:45,950 --> 00:05:50,990
are limp you have a limited address

00:05:47,840 --> 00:05:55,540
space so the base address space i

00:05:50,990 --> 00:05:59,810
believe is up to 4 gigabytes of memory

00:05:55,540 --> 00:06:03,350
with some neat little memory hacking you

00:05:59,810 --> 00:06:06,290
can do pae which is the physical address

00:06:03,350 --> 00:06:08,530
extension I believe it's called which

00:06:06,290 --> 00:06:11,930
can increase your amount of memory but

00:06:08,530 --> 00:06:17,060
it's definitely hacky and it's only one

00:06:11,930 --> 00:06:20,300
of the limitations but what 64-bit ARM

00:06:17,060 --> 00:06:21,710
brings sort of to the game here is not

00:06:20,300 --> 00:06:24,230
only does it have the increased memory

00:06:21,710 --> 00:06:25,910
that I can't even remember the number

00:06:24,230 --> 00:06:31,580
right now it's a ridiculously large

00:06:25,910 --> 00:06:36,110
number and the terabytes but it earlier

00:06:31,580 --> 00:06:40,520
I said that 64-bit ARM has removed a lot

00:06:36,110 --> 00:06:42,890
of the legacy code from the previous the

00:06:40,520 --> 00:06:46,520
previous 32-bit arm devices what this

00:06:42,890 --> 00:06:48,980
actually means is when you have a CPU

00:06:46,520 --> 00:06:49,470
architecture and you want to make it

00:06:48,980 --> 00:06:51,870
more

00:06:49,470 --> 00:06:54,510
Plex you want it to do more things and

00:06:51,870 --> 00:06:56,550
it'll have more instructions that can do

00:06:54,510 --> 00:07:00,540
more powerful things in support more

00:06:56,550 --> 00:07:01,710
software software functions what you're

00:07:00,540 --> 00:07:04,320
actually doing is you're just adding

00:07:01,710 --> 00:07:07,440
more transistors into this cpu you're

00:07:04,320 --> 00:07:11,270
making it just more complex and over the

00:07:07,440 --> 00:07:15,150
years for exhibit an example is x86 64

00:07:11,270 --> 00:07:17,730
it can actually still boot doss like

00:07:15,150 --> 00:07:19,020
like operating systems back in the

00:07:17,730 --> 00:07:21,810
eighties like it's it can still do it

00:07:19,020 --> 00:07:23,850
it's there for legacy purposes but what

00:07:21,810 --> 00:07:26,760
this means is that they have to have all

00:07:23,850 --> 00:07:29,940
these extra pieces built into the actual

00:07:26,760 --> 00:07:32,160
processor itself and by doing this

00:07:29,940 --> 00:07:36,540
you're actually just cutting off its

00:07:32,160 --> 00:07:39,870
power efficiency and it can add up when

00:07:36,540 --> 00:07:42,650
you look at the the Watts used per

00:07:39,870 --> 00:07:46,650
performance when you're comparing arm to

00:07:42,650 --> 00:07:51,750
x86 and I believe right now you're

00:07:46,650 --> 00:07:54,930
looking at a power savings of our usage

00:07:51,750 --> 00:07:59,550
of like one ninth the same as an x86 for

00:07:54,930 --> 00:08:02,240
the same performance so that's one of

00:07:59,550 --> 00:08:06,840
the main advantages is the power savings

00:08:02,240 --> 00:08:10,729
another one so another note in the

00:08:06,840 --> 00:08:14,640
differences here is it's hard to look at

00:08:10,729 --> 00:08:17,100
then arm v8 as just sort of an improved

00:08:14,640 --> 00:08:19,800
arm because it's not necessarily just

00:08:17,100 --> 00:08:25,020
building up on top of the arm 32-bit

00:08:19,800 --> 00:08:31,080
architecture like x86 64 bit built on

00:08:25,020 --> 00:08:33,810
top of the x86 architecture arm v8 for a

00:08:31,080 --> 00:08:34,890
64-bit ARM is actually a brand new

00:08:33,810 --> 00:08:38,640
architecture they've rewritten

00:08:34,890 --> 00:08:41,820
everything they've completely redesigned

00:08:38,640 --> 00:08:43,349
how the programming or how the processor

00:08:41,820 --> 00:08:46,530
works and all the functions and features

00:08:43,349 --> 00:08:50,700
that exist within it some specific

00:08:46,530 --> 00:08:54,450
examples are for the c plus plus 11 and

00:08:50,700 --> 00:08:57,740
c++ 14 standards they introduce new

00:08:54,450 --> 00:09:00,920
features acquire load and

00:08:57,740 --> 00:09:02,750
and a couple others that were really

00:09:00,920 --> 00:09:03,860
useful and what arm decided do is there

00:09:02,750 --> 00:09:06,170
they're looking at it and they're saying

00:09:03,860 --> 00:09:09,260
these are being implemented in the c++

00:09:06,170 --> 00:09:13,340
standards so let's actually implement

00:09:09,260 --> 00:09:16,190
them into the Eric 64like execution

00:09:13,340 --> 00:09:17,810
state itself so it can now take

00:09:16,190 --> 00:09:21,770
advantage of a lot of these functions

00:09:17,810 --> 00:09:28,010
that GC c or c++ just the standards are

00:09:21,770 --> 00:09:34,910
using so when we look at the the future

00:09:28,010 --> 00:09:36,680
of 64-bit ARM we're mostly just looking

00:09:34,910 --> 00:09:40,360
at the software that's running on it and

00:09:36,680 --> 00:09:43,310
how power efficient the hardware is and

00:09:40,360 --> 00:09:46,430
this state that the server software is

00:09:43,310 --> 00:09:50,870
in so when we look at the software we

00:09:46,430 --> 00:09:53,720
have good news and bad news so right now

00:09:50,870 --> 00:09:55,720
the software for almost all linux

00:09:53,720 --> 00:09:59,450
distributions so I'd be like fedora

00:09:55,720 --> 00:10:02,540
debian open Seuss arc I believe that

00:09:59,450 --> 00:10:07,190
they have basically ported almost every

00:10:02,540 --> 00:10:08,990
piece of software so I'm not going to

00:10:07,190 --> 00:10:12,140
even try and bring up the internet right

00:10:08,990 --> 00:10:17,150
now but we have a 64-bit ARM machine

00:10:12,140 --> 00:10:19,370
running in the other building and it's

00:10:17,150 --> 00:10:22,090
currently running just a native install

00:10:19,370 --> 00:10:24,620
of Fedora running the latest packages

00:10:22,090 --> 00:10:28,190
all the software's working so you can

00:10:24,620 --> 00:10:30,140
yum install whatever you need there's a

00:10:28,190 --> 00:10:33,860
couple packages here and there that have

00:10:30,140 --> 00:10:35,810
specific x86 stuff in it or certain

00:10:33,860 --> 00:10:38,390
things that aren't quite there but it's

00:10:35,810 --> 00:10:43,190
basically over ninety-nine percent I

00:10:38,390 --> 00:10:45,710
believe but one of the bad things that

00:10:43,190 --> 00:10:49,340
sort of happened is during the porting

00:10:45,710 --> 00:10:51,860
process there's sort of like this rush

00:10:49,340 --> 00:10:54,590
everyone's trying to get each package

00:10:51,860 --> 00:10:56,050
built on to this new architecture and

00:10:54,590 --> 00:10:58,900
they're trying to get it working and

00:10:56,050 --> 00:11:01,430
they're fixing little things but

00:10:58,900 --> 00:11:03,290
sometimes it's not called fixing it's

00:11:01,430 --> 00:11:05,870
just hacking and they're just like just

00:11:03,290 --> 00:11:07,699
sticking the the fastest thing they can

00:11:05,870 --> 00:11:10,730
get done in order to get it built

00:11:07,699 --> 00:11:12,709
so what this means is it's not the

00:11:10,730 --> 00:11:15,589
software that exists for Eric 64 right

00:11:12,709 --> 00:11:17,209
now is not well optimized I mean when

00:11:15,589 --> 00:11:20,989
you look at it and you're running it on

00:11:17,209 --> 00:11:24,679
an eight core CPU or a very powerful

00:11:20,989 --> 00:11:28,189
server you don't really notice that oh

00:11:24,679 --> 00:11:29,769
this should be a little faster but

00:11:28,189 --> 00:11:32,119
currently there are a lot of

00:11:29,769 --> 00:11:35,629
optimizations that need to be done for

00:11:32,119 --> 00:11:43,009
Eric 64 to sort of really thrive in a

00:11:35,629 --> 00:11:45,769
server environment that being said the

00:11:43,009 --> 00:11:46,609
hardware it doesn't really matter if

00:11:45,769 --> 00:11:48,879
it's going to thrive in a server

00:11:46,609 --> 00:11:53,389
environment at the moment because you

00:11:48,879 --> 00:11:55,100
can't find the 64-bit hardware piece

00:11:53,389 --> 00:11:58,129
like right now it's it's very very

00:11:55,100 --> 00:12:00,589
difficult here's a picture of one this

00:11:58,129 --> 00:12:04,100
is a small development board it's I

00:12:00,589 --> 00:12:08,929
believe mini-itx standard it's a eight

00:12:04,100 --> 00:12:14,749
core 64-bit ARM called the Mustang from

00:12:08,929 --> 00:12:19,699
a pc and on it has some standard stuff

00:12:14,749 --> 00:12:26,660
like Ethernet USB sfp+ for connecting

00:12:19,699 --> 00:12:28,609
fast linked normal ddr ram but this this

00:12:26,660 --> 00:12:31,189
little board for eight cores and all

00:12:28,609 --> 00:12:36,009
this stuff actually costs three thousand

00:12:31,189 --> 00:12:40,879
dollars right now so it's extremely

00:12:36,009 --> 00:12:48,739
expensive here and these are development

00:12:40,879 --> 00:12:53,569
boards yes this is a PM applied micro i

00:12:48,739 --> 00:12:54,480
believe a vm v chips six workers are

00:12:53,569 --> 00:12:58,110
mark

00:12:54,480 --> 00:12:59,610
right so we're no problem this a good

00:12:58,110 --> 00:13:02,339
question so that's one of the other

00:12:59,610 --> 00:13:06,240
things the AMD Seattle I believe is what

00:13:02,339 --> 00:13:07,709
it's called and am d we we've been in

00:13:06,240 --> 00:13:09,240
response with AMD you know we're very

00:13:07,709 --> 00:13:10,889
interested we're on their waiting list

00:13:09,240 --> 00:13:14,190
we want to pick up one of these

00:13:10,889 --> 00:13:15,990
Seattle's and they keep telling us you

00:13:14,190 --> 00:13:18,329
know that they're ready we're going to

00:13:15,990 --> 00:13:21,060
ship them very soon but it's being about

00:13:18,329 --> 00:13:22,139
six months since they been saying

00:13:21,060 --> 00:13:24,899
they're ready and they're still saying

00:13:22,139 --> 00:13:28,050
they're ready so they're not ready but

00:13:24,899 --> 00:13:30,389
they do exist out there there's some

00:13:28,050 --> 00:13:31,800
videos online of people who have gotten

00:13:30,389 --> 00:13:34,800
a hold of them and are doing some

00:13:31,800 --> 00:13:37,199
presentations a little more in depth

00:13:34,800 --> 00:13:43,709
than this one but with actual Hardware

00:13:37,199 --> 00:13:45,410
in front of it and AMD seattle's so wise

00:13:43,709 --> 00:13:51,740
sources

00:13:45,410 --> 00:13:54,040
I problems your iPad um yes but I mean

00:13:51,740 --> 00:13:57,310
the use case there is very different

00:13:54,040 --> 00:14:02,060
between like development board and

00:13:57,310 --> 00:14:08,569
apples sort of special spin on the arm

00:14:02,060 --> 00:14:09,680
64 bit yeah yep yeah it's one of the few

00:14:08,569 --> 00:14:17,509
out there I guess there's a lot out

00:14:09,680 --> 00:14:22,250
there now so speaking of apples 64-bit

00:14:17,509 --> 00:14:24,529
ARM device the future of 64-bit ARM why

00:14:22,250 --> 00:14:27,920
it's sort of created and what it's

00:14:24,529 --> 00:14:32,060
specifically designed to do so it's not

00:14:27,920 --> 00:14:35,500
really designed to be a stick in your

00:14:32,060 --> 00:14:37,759
phone device or stick in a little

00:14:35,500 --> 00:14:39,769
microcontroller or anything that like a

00:14:37,759 --> 00:14:44,000
raspberry PI's does or something like

00:14:39,769 --> 00:14:46,699
that its target is for like the server

00:14:44,000 --> 00:14:48,860
market they're looking for data centers

00:14:46,699 --> 00:14:54,920
they're looking for very very large

00:14:48,860 --> 00:14:59,870
computers because I'll talk about a

00:14:54,920 --> 00:15:04,490
small fact about just the current state

00:14:59,870 --> 00:15:08,120
of our data centers so currently they

00:15:04,490 --> 00:15:09,949
use I actually I don't know if I can

00:15:08,120 --> 00:15:13,579
pull out the numbers for this but i

00:15:09,949 --> 00:15:17,449
believe it's like one gigawatt of power

00:15:13,579 --> 00:15:22,850
to run a data center which i believe was

00:15:17,449 --> 00:15:27,279
equivalent to basically a small nuclear

00:15:22,850 --> 00:15:30,019
power plant and so what's going on is

00:15:27,279 --> 00:15:34,189
new data centers that sort of start

00:15:30,019 --> 00:15:36,709
arising are happening very very close to

00:15:34,189 --> 00:15:38,540
power plants now because the amount of

00:15:36,709 --> 00:15:40,790
electricity need is just so large that

00:15:38,540 --> 00:15:45,110
building it close just makes the most

00:15:40,790 --> 00:15:46,730
sense and what's going on is these data

00:15:45,110 --> 00:15:49,819
centers are appearing because we have

00:15:46,730 --> 00:15:52,699
more mobile devices and the mobile

00:15:49,819 --> 00:15:54,360
device market right now including Apple

00:15:52,699 --> 00:15:57,390
Android

00:15:54,360 --> 00:16:00,750
maybe windows phones but it's basically

00:15:57,390 --> 00:16:03,390
just exponentially increasing and what

00:16:00,750 --> 00:16:06,329
this means is as there are more people

00:16:03,390 --> 00:16:09,000
using the services online there needs to

00:16:06,329 --> 00:16:12,260
be a back-end to support it and this is

00:16:09,000 --> 00:16:15,660
what the data centers are for and while

00:16:12,260 --> 00:16:20,220
the mobile phones can easily be spread

00:16:15,660 --> 00:16:22,470
out sold and given away the N and

00:16:20,220 --> 00:16:24,690
exponentially increase the data centers

00:16:22,470 --> 00:16:26,459
and the nuclear power plants are not

00:16:24,690 --> 00:16:29,730
going to be doing that they are not

00:16:26,459 --> 00:16:31,470
going to exponentially increase so the

00:16:29,730 --> 00:16:36,240
current plan for the future of 64-bit

00:16:31,470 --> 00:16:38,880
ARM is if we can not only cut the power

00:16:36,240 --> 00:16:40,800
down that we're using in computers but

00:16:38,880 --> 00:16:43,110
also cut down the heat we're using on

00:16:40,800 --> 00:16:45,959
them you're getting rid of air

00:16:43,110 --> 00:16:47,670
conditioning you're getting rid of that

00:16:45,959 --> 00:16:49,890
that would be used to cool down an

00:16:47,670 --> 00:16:52,170
entire data center it would be basically

00:16:49,890 --> 00:16:56,899
a building as big as this filled with

00:16:52,170 --> 00:16:59,930
computers and so getting rid of about

00:16:56,899 --> 00:17:02,519
like ninety percent of the power usage

00:16:59,930 --> 00:17:06,829
would definitely make a hit on the

00:17:02,519 --> 00:17:10,530
server market so when you're thinking of

00:17:06,829 --> 00:17:13,559
the new 64-bit ARM computers you're not

00:17:10,530 --> 00:17:16,049
thinking of a standard development board

00:17:13,559 --> 00:17:17,459
for example like we see here it's not

00:17:16,049 --> 00:17:20,880
something that would come in a single

00:17:17,459 --> 00:17:22,620
case it will come in a standard you rack

00:17:20,880 --> 00:17:26,100
that you'd see in a server environment

00:17:22,620 --> 00:17:29,400
but what it would look like is something

00:17:26,100 --> 00:17:32,790
kind of like this so if we look here

00:17:29,400 --> 00:17:37,020
this card is just an example this is

00:17:32,790 --> 00:17:40,110
actually a 32-bit arm development

00:17:37,020 --> 00:17:43,890
environment but this is an idea of what

00:17:40,110 --> 00:17:46,830
hyperscale computing actually is and so

00:17:43,890 --> 00:17:48,780
this card here has four nodes on it as

00:17:46,830 --> 00:17:52,260
what they're called and each node is

00:17:48,780 --> 00:17:55,460
actually a quad core computer and so the

00:17:52,260 --> 00:17:58,200
idea is to have a big server rack and

00:17:55,460 --> 00:18:01,630
fill this entire server rack with these

00:17:58,200 --> 00:18:04,610
cards and so you have yes

00:18:01,630 --> 00:18:06,290
yet there are SATA ports on there so it

00:18:04,610 --> 00:18:09,170
looks like each node has three SATA

00:18:06,290 --> 00:18:12,890
ports here and a single stick of memory

00:18:09,170 --> 00:18:14,570
for each node and you'll notice that

00:18:12,890 --> 00:18:16,880
there are no Ethernet saan here either

00:18:14,570 --> 00:18:20,350
so there's no Ethernet wires running

00:18:16,880 --> 00:18:22,610
into this case and the way this works is

00:18:20,350 --> 00:18:24,920
the board that these are all getting

00:18:22,610 --> 00:18:29,630
plugged in has an internal network

00:18:24,920 --> 00:18:31,880
fabric that a lots of different designs

00:18:29,630 --> 00:18:33,890
but it gets fairly complicated and what

00:18:31,880 --> 00:18:36,470
happens is each node can sort of talk to

00:18:33,890 --> 00:18:40,550
each other in a crisscross sort of

00:18:36,470 --> 00:18:42,730
fashion and this is such a high density

00:18:40,550 --> 00:18:46,370
environment that doesn't exist right now

00:18:42,730 --> 00:18:49,790
and in the end we're looking at having

00:18:46,370 --> 00:18:52,060
like hundreds and maybe even up to a

00:18:49,790 --> 00:18:56,200
thousand computers in a single rack

00:18:52,060 --> 00:18:58,760
because there's not really a need for

00:18:56,200 --> 00:19:04,100
expensive cooling we can make them

00:18:58,760 --> 00:19:05,630
smaller we can make them just a lot we

00:19:04,100 --> 00:19:08,690
can make them have like more high count

00:19:05,630 --> 00:19:15,310
of course with arm technology because

00:19:08,690 --> 00:19:15,310
the cores actually run a lot cooler yeah

00:19:15,460 --> 00:19:21,290
so if anyone is interested in more

00:19:19,310 --> 00:19:26,120
information on this stuff there's a lot

00:19:21,290 --> 00:19:28,340
of places to go like linaro org which

00:19:26,120 --> 00:19:32,920
has multiple projects related to arm and

00:19:28,340 --> 00:19:36,830
are one of the current people pushing

00:19:32,920 --> 00:19:41,320
the development of eric 64 and 64-bit

00:19:36,830 --> 00:19:44,000
ARM arm camels has tons of resources on

00:19:41,320 --> 00:19:48,980
using arms starting with arm they have

00:19:44,000 --> 00:19:53,720
reference guides instruction sets but

00:19:48,980 --> 00:19:57,610
unfortunately hardware will be very rare

00:19:53,720 --> 00:20:02,710
and expensive for quite a while probably

00:19:57,610 --> 00:20:04,790
the next year maybe longer I'm not a

00:20:02,710 --> 00:20:09,080
people of guests when it's going to show

00:20:04,790 --> 00:20:14,029
up but the guesses are like late 2015

00:20:09,080 --> 00:20:16,700
too early 2016 but

00:20:14,029 --> 00:20:21,169
the guesses before were early 2014 which

00:20:16,700 --> 00:20:24,679
didn't happen so is there a are there

00:20:21,169 --> 00:20:32,269
any questions yes yeah what about six

00:20:24,679 --> 00:20:43,580
both this war for GPU the party Mellie

00:20:32,269 --> 00:20:45,710
GPUs I'm not sure yes my opinion which

00:20:43,580 --> 00:20:48,679
is not educated by the inside knowledge

00:20:45,710 --> 00:20:54,259
is it 64-bit ARM is going to be

00:20:48,679 --> 00:20:55,849
pervasive because already if something

00:20:54,259 --> 00:20:58,099
was just telling that their phone has

00:20:55,849 --> 00:21:01,039
three gigs of RAM in it and that's sort

00:20:58,099 --> 00:21:03,979
of about where you'd want to stop to bid

00:21:01,039 --> 00:21:07,399
architecture it just seems that

00:21:03,979 --> 00:21:11,440
everybody is hitting the RAM wall that's

00:21:07,399 --> 00:21:13,759
the reason why 64 should be pervasive I

00:21:11,440 --> 00:21:16,609
think what you're really saying is what

00:21:13,759 --> 00:21:21,309
your focus is the server world but I

00:21:16,609 --> 00:21:26,749
think I'm 64 has gotta get everywhere

00:21:21,309 --> 00:21:31,070
sort of yes I believe that arm 64 will

00:21:26,749 --> 00:21:33,830
hit like the mobile market because the

00:21:31,070 --> 00:21:36,320
way that our Eric 64 is actually

00:21:33,830 --> 00:21:38,299
designed may improve battery life a lot

00:21:36,320 --> 00:21:40,309
as well because it's it's really being

00:21:38,299 --> 00:21:42,259
cut down from what it was before into

00:21:40,309 --> 00:21:45,080
something smaller as well as a lot of

00:21:42,259 --> 00:21:47,599
benefits like that but I believe that

00:21:45,080 --> 00:21:50,119
32-bit arm will still have its place in

00:21:47,599 --> 00:21:52,249
the world so I think it still has a

00:21:50,119 --> 00:21:54,589
future in a lot of embedded devices and

00:21:52,249 --> 00:21:57,799
much smaller devices which may not need

00:21:54,589 --> 00:22:03,109
a lot of memory or any specific things

00:21:57,799 --> 00:22:06,559
going on in them yeah yes the size of

00:22:03,109 --> 00:22:09,270
that are 64 that new processor the

00:22:06,559 --> 00:22:12,890
shrink sighs looks like the part to the

00:22:09,270 --> 00:22:19,470
to the point 249 and heater 11.8 but oh

00:22:12,890 --> 00:22:21,690
I i have no idea probably depends on the

00:22:19,470 --> 00:22:23,810
boundary because arm itself doesn't make

00:22:21,690 --> 00:22:26,790
any chips at all no it doesn't make a

00:22:23,810 --> 00:22:28,830
intellectual property and then people

00:22:26,790 --> 00:22:31,740
take that and take it to their favorite

00:22:28,830 --> 00:22:36,450
boundary which is the ones you usually

00:22:31,740 --> 00:22:38,820
rubber smc and global and those guys are

00:22:36,450 --> 00:22:42,540
maybe this is the keyboard those guys

00:22:38,820 --> 00:22:45,540
are as far as I recollect an older to

00:22:42,540 --> 00:22:48,110
time in tell all the time they don't

00:22:45,540 --> 00:22:50,640
usually give out that that space for

00:22:48,110 --> 00:22:53,670
little guys usually that's dominated by

00:22:50,640 --> 00:22:55,650
the larger order companies i was

00:22:53,670 --> 00:22:57,780
wondering maybe baby the shrink size

00:22:55,650 --> 00:23:01,290
being larger does already have that

00:22:57,780 --> 00:23:07,530
powered about that power pro on eating

00:23:01,290 --> 00:23:08,940
this dissipation so curious just what if

00:23:07,530 --> 00:23:11,610
you're following an Intel of course

00:23:08,940 --> 00:23:15,360
notes are Moses is coming and they have

00:23:11,610 --> 00:23:18,270
the releasing microscale chips atoms and

00:23:15,360 --> 00:23:20,760
BTW or paint or 32 for atoms or hundred

00:23:18,270 --> 00:23:23,670
courtship don't look to play too many of

00:23:20,760 --> 00:23:28,880
those how they compare to something you

00:23:23,670 --> 00:23:32,700
have some numbers if you look at so

00:23:28,880 --> 00:23:35,670
right so we I I haven't personally

00:23:32,700 --> 00:23:38,130
played with any of the more advanced

00:23:35,670 --> 00:23:41,700
Intel chips that I I have heard that

00:23:38,130 --> 00:23:42,990
they're pretty good for power savings

00:23:41,700 --> 00:23:47,070
and stuff like their recent one doesn't

00:23:42,990 --> 00:23:48,900
have fans in it or anything well most of

00:23:47,070 --> 00:23:51,810
the tests that we were able to do uh

00:23:48,900 --> 00:23:54,900
were a little while back on comparable

00:23:51,810 --> 00:23:57,240
arm to x86 devices so it's not quite a

00:23:54,900 --> 00:24:00,560
fair comparison but like it was it was

00:23:57,240 --> 00:24:03,560
old arm and it was kind of old x86 so

00:24:00,560 --> 00:24:03,560
yeah

00:24:03,910 --> 00:24:13,570
yes no just because are some of the

00:24:10,900 --> 00:24:15,400
benefits of the entry or 64 sufficient

00:24:13,570 --> 00:24:17,200
things like extra registers and all that

00:24:15,400 --> 00:24:21,040
they would be worth doing any harm

00:24:17,200 --> 00:24:23,200
slides into the exit 67 yep the Linux

00:24:21,040 --> 00:24:25,890
x32 area where you were running

00:24:23,200 --> 00:24:30,270
essentially using 64-bit register file

00:24:25,890 --> 00:24:33,250
but only has 32 along in order to extend

00:24:30,270 --> 00:24:35,430
to sort of memory access overhead

00:24:33,250 --> 00:24:35,430
because

00:24:42,880 --> 00:24:48,100
well not sure if an argument has been

00:24:45,110 --> 00:24:54,410
made but it would be completely possible

00:24:48,100 --> 00:25:02,270
like I know things like register file

00:24:54,410 --> 00:25:04,460
change sometime interesting to note

00:25:02,270 --> 00:25:15,020
we'll probably get into the benefit of

00:25:04,460 --> 00:25:19,880
having a real well good sort of the way

00:25:15,020 --> 00:25:22,700
that they are 64 assembly language and

00:25:19,880 --> 00:25:26,420
instruction set sort of works is they do

00:25:22,700 --> 00:25:31,610
have the 32-bit registers built into it

00:25:26,420 --> 00:25:34,910
and they their philosophy I guess is to

00:25:31,610 --> 00:25:38,720
do things in a more simpler fashion so

00:25:34,910 --> 00:25:40,460
what they so what they have done is

00:25:38,720 --> 00:25:44,390
they've made all their instructions a

00:25:40,460 --> 00:25:48,170
fixed length of 32 bits and what that

00:25:44,390 --> 00:25:49,460
means is while x86 has a variable length

00:25:48,170 --> 00:25:51,770
so you can just sort of throw whatever

00:25:49,460 --> 00:25:55,430
in there you'd need multiple

00:25:51,770 --> 00:25:58,250
instructions to perform a single load of

00:25:55,430 --> 00:26:01,640
say a 64 bit register so you could see

00:25:58,250 --> 00:26:03,920
in some places like that maybe you could

00:26:01,640 --> 00:26:09,970
actually see a very good benefit in

00:26:03,920 --> 00:26:09,970
using the smaller registers or something

00:26:11,000 --> 00:26:22,850
just use more than just there's more

00:26:15,880 --> 00:26:29,510
okay yeah so as it seems like most

00:26:22,850 --> 00:26:38,110
things yeah i'm not sure if anyone will

00:26:29,510 --> 00:26:41,300
but yeah what about me yawn yawn um i

00:26:38,110 --> 00:26:47,630
believe that neon is supported in Eric

00:26:41,300 --> 00:26:52,940
64 or or comes out as simdi what would

00:26:47,630 --> 00:26:55,400
specifically about it I yeah I believe

00:26:52,940 --> 00:26:59,120
simdi is available you can interact with

00:26:55,400 --> 00:27:03,920
it through yeah does anyone else know

00:26:59,120 --> 00:27:06,580
more about interacting with this md yeah

00:27:03,920 --> 00:27:06,580
I know it's there

00:27:17,420 --> 00:27:21,299
he said you installed the Dora on it you

00:27:20,190 --> 00:27:22,740
got up and running have you got anything

00:27:21,299 --> 00:27:24,929
else that you probe like we've written

00:27:22,740 --> 00:27:26,580
programs for them used like a cumulation

00:27:24,929 --> 00:27:28,710
you later have you actually didn't

00:27:26,580 --> 00:27:32,220
develop a code for running it seeing

00:27:28,710 --> 00:27:33,450
like how how usable is it um your

00:27:32,220 --> 00:27:36,660
experience like what you would actually

00:27:33,450 --> 00:27:40,380
like working on it besides young right

00:27:36,660 --> 00:27:43,440
yeah so it it's in a pretty usable state

00:27:40,380 --> 00:27:44,880
it's running all in sort of open

00:27:43,440 --> 00:27:48,690
standard things one of the things with

00:27:44,880 --> 00:27:50,429
Eric 64 is it needs to if you want to

00:27:48,690 --> 00:27:54,630
sort of ship it out it needs to support

00:27:50,429 --> 00:27:56,190
or be able to run UEFI so the idea there

00:27:54,630 --> 00:27:58,740
is that everything needs to boot the

00:27:56,190 --> 00:28:00,690
same way you can't have 300 different

00:27:58,740 --> 00:28:04,940
devices all running you boot that are

00:28:00,690 --> 00:28:07,860
custom and just really bad at looting

00:28:04,940 --> 00:28:09,299
how is your change how is a UEFI

00:28:07,860 --> 00:28:11,760
experience and I've been playing some

00:28:09,299 --> 00:28:13,950
non x86 servers why it varies from

00:28:11,760 --> 00:28:16,980
firmware version it's it's all over the

00:28:13,950 --> 00:28:20,910
place right um so my experience with it

00:28:16,980 --> 00:28:24,510
has been pretty pleasant so far we

00:28:20,910 --> 00:28:27,240
actually had to a flat flash the actual

00:28:24,510 --> 00:28:29,490
firmware onto it for you okay i but once

00:28:27,240 --> 00:28:32,400
it was on it was a pretty standard net

00:28:29,490 --> 00:28:36,660
install and we also did another install

00:28:32,400 --> 00:28:40,320
with USB and that also worked so they

00:28:36,660 --> 00:28:42,570
install his work we have classes

00:28:40,320 --> 00:28:45,650
currently at seneca college right now

00:28:42,570 --> 00:28:49,470
that are developing on these machines

00:28:45,650 --> 00:28:52,919
for us the course is called software

00:28:49,470 --> 00:28:55,590
Portability and optimization and I

00:28:52,919 --> 00:28:58,950
believe this semester their focuses more

00:28:55,590 --> 00:29:00,750
on optimization for Eric 64 and they're

00:28:58,950 --> 00:29:04,710
the ones that are currently spending

00:29:00,750 --> 00:29:09,090
most of the time on building packages I

00:29:04,710 --> 00:29:11,070
think and trying out things it is there

00:29:09,090 --> 00:29:15,410
anyone in here in the SPO class that can

00:29:11,070 --> 00:29:19,230
get more info baby yeah so

00:29:15,410 --> 00:29:22,470
um yes so Chris Fowler itches of course

00:29:19,230 --> 00:29:24,750
and we're working with De Niro they have

00:29:22,470 --> 00:29:29,430
a full list of packages that are correct

00:29:24,750 --> 00:29:31,800
either only for x86 and for have arm 32

00:29:29,430 --> 00:29:34,950
now we're trying to port toward the AR

00:29:31,800 --> 00:29:38,520
AR 64 architectures a lot of what we're

00:29:34,950 --> 00:29:41,190
looking at specifically is architecture

00:29:38,520 --> 00:29:44,160
specific instructions or assembly which

00:29:41,190 --> 00:29:48,600
can or cannot be translated to run into

00:29:44,160 --> 00:29:50,970
a are 64 so at the assembly all um not

00:29:48,600 --> 00:29:54,480
sure if there's actually any specific

00:29:50,970 --> 00:29:59,060
questions there and course i can try an

00:29:54,480 --> 00:30:02,040
edger but it's a very interesting course

00:29:59,060 --> 00:30:04,380
like he said porting it over and

00:30:02,040 --> 00:30:07,410
optimization so what kind of package

00:30:04,380 --> 00:30:09,290
items jurors oh there's huge ones which

00:30:07,410 --> 00:30:13,500
everyone should know like java python

00:30:09,290 --> 00:30:17,900
dash and swollen ones that for example

00:30:13,500 --> 00:30:21,120
can apply that is calmer hugging three

00:30:17,900 --> 00:30:24,210
elder brother thing like 30 the package

00:30:21,120 --> 00:30:28,350
really vary in size some not as often

00:30:24,210 --> 00:30:32,370
used others the package list i believe

00:30:28,350 --> 00:30:34,290
is up on the linaro website i can't

00:30:32,370 --> 00:30:39,540
remember the exact link but searching

00:30:34,290 --> 00:30:41,160
for mad dog and linaro or eric 64 will

00:30:39,540 --> 00:30:42,720
find you the project that actually works

00:30:41,160 --> 00:30:45,030
on it and they actually have like a

00:30:42,720 --> 00:30:47,010
public package list that has names

00:30:45,030 --> 00:30:48,420
beside them where people have taken them

00:30:47,010 --> 00:30:50,580
and there's a bunch that are just empty

00:30:48,420 --> 00:30:53,670
no one's working on them and these

00:30:50,580 --> 00:30:55,320
packages will vary from you know this

00:30:53,670 --> 00:30:58,650
might actually be a very simple fix like

00:30:55,320 --> 00:31:00,390
oh this is using some vectors here in a

00:30:58,650 --> 00:31:02,640
way that's only specific to this

00:31:00,390 --> 00:31:05,940
architecture while others may be like a

00:31:02,640 --> 00:31:11,010
very complex fix that would need to be

00:31:05,940 --> 00:31:16,820
done or yeah another distribution

00:31:11,010 --> 00:31:19,860
like boom tube that's ready to go on the

00:31:16,820 --> 00:31:21,810
yeah so we've we've talked to some of

00:31:19,860 --> 00:31:25,140
the other distributions like people who

00:31:21,810 --> 00:31:27,420
run them and they've said that open sous

00:31:25,140 --> 00:31:30,180
is available Debbie ins available and

00:31:27,420 --> 00:31:35,340
you bunt to is the one that is currently

00:31:30,180 --> 00:31:38,520
being developed on by linaro so there's

00:31:35,340 --> 00:31:40,470
a lot out there already that have that

00:31:38,520 --> 00:31:41,910
apparently work I have not tested any of

00:31:40,470 --> 00:31:44,700
the other ones personally I've just

00:31:41,910 --> 00:31:53,940
gotten through are going but definitely

00:31:44,700 --> 00:31:57,270
will try the other one soon I am

00:31:53,940 --> 00:32:03,090
actually not sure yeah I have not looked

00:31:57,270 --> 00:32:07,200
at any of those yes so I guess my

00:32:03,090 --> 00:32:11,610
default assumption coming from unix

00:32:07,200 --> 00:32:14,130
world is supporting a new processor once

00:32:11,610 --> 00:32:17,370
you get the compiler but of course that

00:32:14,130 --> 00:32:20,150
isn't true this Linux has spent so much

00:32:17,370 --> 00:32:23,220
time centered on the x86 architecture

00:32:20,150 --> 00:32:26,580
that it's wrong

00:32:23,220 --> 00:32:29,610
mm-hmm but the two things that strike me

00:32:26,580 --> 00:32:34,110
both a few things that strengthens what

00:32:29,610 --> 00:32:37,200
one is our 64 was created after they

00:32:34,110 --> 00:32:39,120
realized the mess of every different

00:32:37,200 --> 00:32:41,070
processor every different arm and

00:32:39,120 --> 00:32:43,799
location the location of getting

00:32:41,070 --> 00:32:46,470
different configurations stuff yeah do

00:32:43,799 --> 00:32:50,090
the all arm 60 hortons device for

00:32:46,470 --> 00:32:53,940
example mm no so I believe that

00:32:50,090 --> 00:32:57,870
currently I think they might but there's

00:32:53,940 --> 00:33:00,059
like a transition process for example if

00:32:57,870 --> 00:33:01,559
you're developing one and having it out

00:33:00,059 --> 00:33:04,380
it has to boot through you fi for

00:33:01,559 --> 00:33:06,750
example but I believe there's a step

00:33:04,380 --> 00:33:09,450
forward where you're removing all use of

00:33:06,750 --> 00:33:11,100
the device tree it's just they're sort

00:33:09,450 --> 00:33:16,470
of in the transition period of getting

00:33:11,100 --> 00:33:18,690
from there to there so that's one aspect

00:33:16,470 --> 00:33:21,179
together aspects of disaster and the

00:33:18,690 --> 00:33:25,200
armor of the video should be able to

00:33:21,179 --> 00:33:28,710
route to their none of them has an open

00:33:25,200 --> 00:33:31,020
source driver or maybe they're starting

00:33:28,710 --> 00:33:33,809
just I think nvidia talked about release

00:33:31,020 --> 00:33:37,460
Mally a night I believe that work but

00:33:33,809 --> 00:33:42,809
the is a sauce no I'm good I believe

00:33:37,460 --> 00:33:47,039
recently Nvidia and AMD have released

00:33:42,809 --> 00:33:49,830
very half-completed open-source drivers

00:33:47,039 --> 00:33:51,870
or work on it what they're doing they're

00:33:49,830 --> 00:33:55,110
causing the food of give you engine on

00:33:51,870 --> 00:33:56,310
the same guy ah their arms you submit

00:33:55,110 --> 00:34:00,990
yourself as a tick

00:33:56,310 --> 00:34:03,660
right whatever and so that's not really

00:34:00,990 --> 00:34:06,630
the same as a de Janerio so keep you

00:34:03,660 --> 00:34:10,080
support such as Valley mm-hmm all right

00:34:06,630 --> 00:34:13,830
so that's a really sad part of that

00:34:10,080 --> 00:34:15,420
world CC malli runs opencl hmm so if

00:34:13,830 --> 00:34:17,640
you're uncool you're in the am beauty of

00:34:15,420 --> 00:34:19,710
camp yeah it's good for a nvidia not

00:34:17,640 --> 00:34:26,970
very good for you right but you said go

00:34:19,710 --> 00:34:30,600
opencl any other yeah it makes sense a

00:34:26,970 --> 00:34:32,520
server-based so the opencl of interest

00:34:30,600 --> 00:34:34,410
is not graphic central graphics but

00:34:32,520 --> 00:34:35,670
great I've seen better about going into

00:34:34,410 --> 00:34:40,710
now the roof than you are with the

00:34:35,670 --> 00:34:43,530
nvidia tegra maintenance a little bit

00:34:40,710 --> 00:34:46,050
insight into the GPU state so Andy for

00:34:43,530 --> 00:34:48,390
example it actually does provide you

00:34:46,050 --> 00:34:51,360
know very feature full open-source

00:34:48,390 --> 00:34:53,460
drivers two GPUs as far as the arm chips

00:34:51,360 --> 00:34:55,410
there were several projects that are

00:34:53,460 --> 00:34:57,930
ongoing that ever played reverse

00:34:55,410 --> 00:35:00,360
engineer projects which one for a jury

00:34:57,930 --> 00:35:06,320
no objection so never I dad is working

00:35:00,360 --> 00:35:06,320
on there's one for levante and I'll

00:35:08,769 --> 00:35:15,369
they promised delivery yeah

00:35:18,390 --> 00:35:27,690
there any other questions okay alrighty

00:35:32,830 --> 00:35:40,780
great discussion it's a small token of

00:35:36,460 --> 00:35:40,780

YouTube URL: https://www.youtube.com/watch?v=gT3xn0Jo_V4


