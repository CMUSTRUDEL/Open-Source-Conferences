Title: OpenVDB: News Features and Open Discussions
Publication date: 2020-08-24
Playlist: Open Source Days 2020
Description: 
	OpenVDB: News Features and Open Discussions
Speakers: Ken Museth, Nick Avramoussis

For more information about the Academy Software Foundation go to: https://www.aswf.io/

The purpose of this meeting is twofold; to summarize the state of the OpenVDB project and invite attendees to openly discuss issues and possible future directions. To this end we will first give a brief introduction to OpenVDB and it's governance, followed by an overview of new and upcoming features - including an exciting new announcement! For the second half we invite attendees to participate in an open discussion about anything related to our project, including suggestions for new features,  bugs and issues, and questions on how to get involved etc.
Captions: 
	00:00:00,000 --> 00:00:03,040
hi everyone and welcome to this session

00:00:02,399 --> 00:00:06,240
on

00:00:03,040 --> 00:00:06,240
the openvdb project

00:00:06,319 --> 00:00:12,880
we've decided to split the session in

00:00:09,679 --> 00:00:15,440
two parts so nick and myself

00:00:12,880 --> 00:00:17,600
will give a brief introduction to the

00:00:15,440 --> 00:00:19,840
projects some of the latest activities

00:00:17,600 --> 00:00:21,680
uh we'll make an announcement and then

00:00:19,840 --> 00:00:22,960
the second half of this session will be

00:00:21,680 --> 00:00:24,800
sort of a live

00:00:22,960 --> 00:00:26,720
live session where we try to um to

00:00:24,800 --> 00:00:28,880
answer questions so

00:00:26,720 --> 00:00:30,720
you're really encouraged to to use the q

00:00:28,880 --> 00:00:33,040
a uh chat

00:00:30,720 --> 00:00:34,880
window and and uh give us as many

00:00:33,040 --> 00:00:37,920
questions as you can come up with

00:00:34,880 --> 00:00:39,680
um but we will we will talk about uh we

00:00:37,920 --> 00:00:42,879
would give two presentations first so we

00:00:39,680 --> 00:00:44,239
we ask you to please have patience uh

00:00:42,879 --> 00:00:46,079
in the second half we'll start answering

00:00:44,239 --> 00:00:48,719
those questions so

00:00:46,079 --> 00:00:50,320
um let me first introduce you to uh the

00:00:48,719 --> 00:00:53,600
steering committee for

00:00:50,320 --> 00:00:54,879
openvdb so as you probably know openvdb

00:00:53,600 --> 00:00:57,280
transitioned as one of the first

00:00:54,879 --> 00:01:00,239
projects to the aswf

00:00:57,280 --> 00:01:01,760
uh a little over a year ago uh at this

00:01:00,239 --> 00:01:04,000
point we have four members

00:01:01,760 --> 00:01:04,960
uh there is nick from double negative

00:01:04,000 --> 00:01:07,200
who's actually

00:01:04,960 --> 00:01:08,240
part of this presentation there is dan

00:01:07,200 --> 00:01:11,360
bailey from

00:01:08,240 --> 00:01:12,960
ilm there is peter cooker who is

00:01:11,360 --> 00:01:14,479
officially still a member but he's

00:01:12,960 --> 00:01:16,960
currently on leave

00:01:14,479 --> 00:01:18,320
jeff laid um who's at side effects and

00:01:16,960 --> 00:01:21,840
then there's myself

00:01:18,320 --> 00:01:24,000
who's at nvidia um in case you want to

00:01:21,840 --> 00:01:24,880
join our weekly meetings it's every

00:01:24,000 --> 00:01:29,759
tuesday

00:01:24,880 --> 00:01:32,159
at 10 a.m public so anyone can show up

00:01:29,759 --> 00:01:33,680
and we also actually post sometimes we

00:01:32,159 --> 00:01:36,000
we update the time so you can

00:01:33,680 --> 00:01:36,880
you can follow the second url on this

00:01:36,000 --> 00:01:39,439
slide

00:01:36,880 --> 00:01:40,400
to see as we you know might change or

00:01:39,439 --> 00:01:43,840
cancel a meeting

00:01:40,400 --> 00:01:44,640
um and finally the the the minutes of

00:01:43,840 --> 00:01:48,000
the meetings

00:01:44,640 --> 00:01:50,320
are uh posted in the um repository the

00:01:48,000 --> 00:01:52,000
github repository so you can also go and

00:01:50,320 --> 00:01:54,399
sort of look back and see what what we

00:01:52,000 --> 00:01:56,399
talked about decided on

00:01:54,399 --> 00:01:58,159
all right so now i i wanted to give you

00:01:56,399 --> 00:01:59,600
sort of a very quick

00:01:58,159 --> 00:02:01,520
uh introduction and actually a

00:01:59,600 --> 00:02:03,840
motivation for for

00:02:01,520 --> 00:02:04,640
openvdb and sparse volumes in particular

00:02:03,840 --> 00:02:07,200
um so

00:02:04,640 --> 00:02:08,399
bear with me if you if this is uh too

00:02:07,200 --> 00:02:10,319
simple but

00:02:08,399 --> 00:02:11,680
i think it does actually serve a good

00:02:10,319 --> 00:02:14,160
purpose um

00:02:11,680 --> 00:02:16,480
so as you probably know it's relatively

00:02:14,160 --> 00:02:19,440
easy to design a data structure

00:02:16,480 --> 00:02:20,239
uh that's fast i spot data structure

00:02:19,440 --> 00:02:22,959
that's fast

00:02:20,239 --> 00:02:24,400
right um we typically just need a very

00:02:22,959 --> 00:02:27,760
shallow tree

00:02:24,400 --> 00:02:30,959
like a tile grid that actually offers

00:02:27,760 --> 00:02:32,879
a guaranteed constant time access which

00:02:30,959 --> 00:02:34,959
is sort of ideal

00:02:32,879 --> 00:02:37,760
the problem with this approach is that

00:02:34,959 --> 00:02:40,879
the memory overhead of storing the

00:02:37,760 --> 00:02:43,680
list of blocks the table itself

00:02:40,879 --> 00:02:45,519
um can get prohibitedly large and it

00:02:43,680 --> 00:02:48,480
actually doesn't scale this approach

00:02:45,519 --> 00:02:49,920
um so on the other sort of end of the

00:02:48,480 --> 00:02:53,280
spectrum

00:02:49,920 --> 00:02:54,959
we have very compact data structures

00:02:53,280 --> 00:02:57,040
and sort of the prototypical example of

00:02:54,959 --> 00:02:58,879
that is of course an octree

00:02:57,040 --> 00:03:00,959
that has ideal additivity it's two in

00:02:58,879 --> 00:03:04,720
its coordinate direction

00:03:00,959 --> 00:03:06,640
so it often produces fairly tall trees

00:03:04,720 --> 00:03:08,159
when you have a lot of resolution and

00:03:06,640 --> 00:03:10,000
the problem with that approach is that

00:03:08,159 --> 00:03:11,760
navigating tall trees can be

00:03:10,000 --> 00:03:14,239
computationally expensive

00:03:11,760 --> 00:03:15,040
so really the motivation behind the core

00:03:14,239 --> 00:03:18,319
data structure

00:03:15,040 --> 00:03:20,239
in openvdb is to try and strike a

00:03:18,319 --> 00:03:23,440
balance between these two extremes

00:03:20,239 --> 00:03:25,440
um and that leads to this this

00:03:23,440 --> 00:03:26,560
data structure called a vdb structure

00:03:25,440 --> 00:03:30,799
and it's sort of a it's a

00:03:26,560 --> 00:03:33,840
it's a hybrid um and this is a

00:03:30,799 --> 00:03:36,959
1d illustration of a typical

00:03:33,840 --> 00:03:38,000
um vdb data structure and it's as you

00:03:36,959 --> 00:03:39,680
can see it's it's a

00:03:38,000 --> 00:03:41,599
it's a four level tree so it's very

00:03:39,680 --> 00:03:43,280
shallow um

00:03:41,599 --> 00:03:44,959
and the root note is the only node

00:03:43,280 --> 00:03:46,159
that's actually dynamic the rest are

00:03:44,959 --> 00:03:48,319
depths

00:03:46,159 --> 00:03:49,840
with progressively smaller leaf nodes if

00:03:48,319 --> 00:03:53,040
you want more details you can

00:03:49,840 --> 00:03:56,080
look at the paper listed below so

00:03:53,040 --> 00:03:58,840
the way that you typically extract

00:03:56,080 --> 00:04:00,959
values from a data structure three data

00:03:58,840 --> 00:04:01,599
structure in fact any tree data

00:04:00,959 --> 00:04:03,760
structure

00:04:01,599 --> 00:04:05,519
is through a top-down traversal right so

00:04:03,760 --> 00:04:07,360
let's say we want to look up the value

00:04:05,519 --> 00:04:10,720
at xyz

00:04:07,360 --> 00:04:11,680
you typically navigate the tree starting

00:04:10,720 --> 00:04:13,920
at the very top

00:04:11,680 --> 00:04:16,000
the root node and you navigate through

00:04:13,920 --> 00:04:18,799
the branch until you have a hit

00:04:16,000 --> 00:04:19,199
and you return the value the good news

00:04:18,799 --> 00:04:20,720
is

00:04:19,199 --> 00:04:22,880
it's a shallow tree so it should be

00:04:20,720 --> 00:04:25,040
fairly fairly fast

00:04:22,880 --> 00:04:26,080
compared to let's say an octre the bad

00:04:25,040 --> 00:04:28,800
news is

00:04:26,080 --> 00:04:29,600
the first node is a dynamic node it's a

00:04:28,800 --> 00:04:32,720
root node

00:04:29,600 --> 00:04:36,639
so that actually has a computational

00:04:32,720 --> 00:04:39,360
cost associated with it so vdb

00:04:36,639 --> 00:04:41,280
actually makes use of a technique that i

00:04:39,360 --> 00:04:43,280
believe is pretty unique to

00:04:41,280 --> 00:04:45,680
this data structure it allows you to do

00:04:43,280 --> 00:04:48,000
not top-down but bottom-up traversal

00:04:45,680 --> 00:04:50,720
and the idea is very simple suppose

00:04:48,000 --> 00:04:53,199
you've done one access already

00:04:50,720 --> 00:04:55,120
what you do is you cache the pointer

00:04:53,199 --> 00:04:58,160
structures

00:04:55,120 --> 00:05:01,039
of that of that traversal and

00:04:58,160 --> 00:05:01,759
for subsequent access you do a few bit

00:05:01,039 --> 00:05:05,759
operations

00:05:01,759 --> 00:05:08,400
to um to check and see if the subsequent

00:05:05,759 --> 00:05:09,680
access falls in the same leaf node and

00:05:08,400 --> 00:05:11,520
if it does

00:05:09,680 --> 00:05:13,280
well then there's no traversal involved

00:05:11,520 --> 00:05:16,400
you immediately um

00:05:13,280 --> 00:05:16,880
return the value if there's a miss you

00:05:16,400 --> 00:05:19,360
move

00:05:16,880 --> 00:05:20,240
up to the second entry in this small

00:05:19,360 --> 00:05:22,320
hash table

00:05:20,240 --> 00:05:25,280
so it's a common ancestor of the leave

00:05:22,320 --> 00:05:28,800
node and you perform another check

00:05:25,280 --> 00:05:29,919
and if there's a match you go down and

00:05:28,800 --> 00:05:32,479
then you return the value

00:05:29,919 --> 00:05:33,840
so the idea is that you on average

00:05:32,479 --> 00:05:36,320
completely avoid the

00:05:33,840 --> 00:05:38,240
overhead of the road node and it

00:05:36,320 --> 00:05:39,280
actually on average produces a constant

00:05:38,240 --> 00:05:42,400
time access which is

00:05:39,280 --> 00:05:44,800
which is great so it's fast um

00:05:42,400 --> 00:05:47,440
so these are some of the highlights uh

00:05:44,800 --> 00:05:49,039
so the vdb data structure is unbounded

00:05:47,440 --> 00:05:51,039
to within the bid procession of the quad

00:05:49,039 --> 00:05:53,680
nuts which is typically 32 bit

00:05:51,039 --> 00:05:54,400
science integers it's compact both the

00:05:53,680 --> 00:05:57,919
memory and

00:05:54,400 --> 00:06:00,319
disk it offers fast random access and

00:05:57,919 --> 00:06:03,360
sequential access

00:06:00,319 --> 00:06:04,479
we also have our own file formats and we

00:06:03,360 --> 00:06:06,319
have our own

00:06:04,479 --> 00:06:08,240
codecs to make sure that the footprint

00:06:06,319 --> 00:06:10,639
is very small on disk

00:06:08,240 --> 00:06:12,000
and the fact that it's a native sorry

00:06:10,639 --> 00:06:12,479
that it's a tree data structure actually

00:06:12,000 --> 00:06:15,440
means that

00:06:12,479 --> 00:06:16,880
it also has a native acceleration

00:06:15,440 --> 00:06:18,400
structure which can accelerate

00:06:16,880 --> 00:06:20,000
many different applications like ray

00:06:18,400 --> 00:06:23,039
tracing or even things like

00:06:20,000 --> 00:06:25,360
boolean operations um

00:06:23,039 --> 00:06:26,400
it does have quite a lot of external

00:06:25,360 --> 00:06:30,240
dependencies

00:06:26,400 --> 00:06:31,680
and uh that among other things means

00:06:30,240 --> 00:06:35,680
that it's actually limited to

00:06:31,680 --> 00:06:38,400
to the cpu um so openvdb has

00:06:35,680 --> 00:06:40,400
enjoyed over a decade of adoption in the

00:06:38,400 --> 00:06:44,000
vfx industry and these are

00:06:40,400 --> 00:06:45,520
some of the third-party software

00:06:44,000 --> 00:06:47,120
that have adopted most of them are

00:06:45,520 --> 00:06:50,319
actually

00:06:47,120 --> 00:06:52,000
renders um so

00:06:50,319 --> 00:06:53,360
most people are probably more excited

00:06:52,000 --> 00:06:54,960
about uh

00:06:53,360 --> 00:06:56,400
the tools that come with open b and not

00:06:54,960 --> 00:06:59,440
so much about the data structure

00:06:56,400 --> 00:07:01,199
and uh there are a lot far far

00:06:59,440 --> 00:07:02,880
more than we can cover in this brief

00:07:01,199 --> 00:07:05,199
presentation

00:07:02,880 --> 00:07:06,720
but at this point we're actually over a

00:07:05,199 --> 00:07:08,479
hundred different

00:07:06,720 --> 00:07:10,639
tools that have been developed over the

00:07:08,479 --> 00:07:12,560
past 10 years

00:07:10,639 --> 00:07:14,479
there is there's there's one tool i just

00:07:12,560 --> 00:07:16,720
want to call out because we actually

00:07:14,479 --> 00:07:19,120
released it last week so we just

00:07:16,720 --> 00:07:21,039
released version seven one

00:07:19,120 --> 00:07:22,800
seven one is is a big release it has far

00:07:21,039 --> 00:07:25,680
more than what i'm going to tell you now

00:07:22,800 --> 00:07:28,319
um but this is one of the new sort of

00:07:25,680 --> 00:07:31,599
tools that we added in this release

00:07:28,319 --> 00:07:32,319
and it's a new way of computing assigned

00:07:31,599 --> 00:07:35,360
distances

00:07:32,319 --> 00:07:38,560
and also computing or extending

00:07:35,360 --> 00:07:39,039
attributes off surfaces um so it comes

00:07:38,560 --> 00:07:41,440
in

00:07:39,039 --> 00:07:42,880
in many different flavors um there are

00:07:41,440 --> 00:07:45,039
these two tools that

00:07:42,880 --> 00:07:46,960
allow you to go from an arbitrary scalar

00:07:45,039 --> 00:07:47,360
field it could be a fog volume it could

00:07:46,960 --> 00:07:49,759
be

00:07:47,360 --> 00:07:51,599
an existing sign distance field and then

00:07:49,759 --> 00:07:54,879
it produces

00:07:51,599 --> 00:07:57,599
a narrow band sign distance field very

00:07:54,879 --> 00:07:58,319
very efficiently there are two other

00:07:57,599 --> 00:08:01,039
flavors

00:07:58,319 --> 00:08:02,639
um that actually allow you to take

00:08:01,039 --> 00:08:05,520
attributes that are defined

00:08:02,639 --> 00:08:07,199
on an isosurface and sort of extend them

00:08:05,520 --> 00:08:08,800
into the embedding of the surface itself

00:08:07,199 --> 00:08:10,160
which can be very useful so for instance

00:08:08,800 --> 00:08:12,560
it could be you have velocities on the

00:08:10,160 --> 00:08:14,800
surface but you actually need

00:08:12,560 --> 00:08:17,840
to have velocities associated with

00:08:14,800 --> 00:08:19,759
values that are outside of the surface

00:08:17,840 --> 00:08:21,919
these two methods will do that and there

00:08:19,759 --> 00:08:24,080
are combinations

00:08:21,919 --> 00:08:26,000
of these four methods that actually

00:08:24,080 --> 00:08:29,520
perform both tasks at the same time so

00:08:26,000 --> 00:08:32,000
it both extends velocities and

00:08:29,520 --> 00:08:33,919
and also attributes from the surface and

00:08:32,000 --> 00:08:36,399
finally there are two

00:08:33,919 --> 00:08:37,200
methods that actually sort of

00:08:36,399 --> 00:08:39,599
complements

00:08:37,200 --> 00:08:40,800
methods that we already have but but it

00:08:39,599 --> 00:08:43,519
turns out these are

00:08:40,800 --> 00:08:44,159
significantly faster so we can take an

00:08:43,519 --> 00:08:46,080
existing

00:08:44,159 --> 00:08:48,320
sign distance field narrowband and we

00:08:46,080 --> 00:08:51,279
can dilate it sort of inflate it

00:08:48,320 --> 00:08:53,040
make the the nare bandwidth wider and as

00:08:51,279 --> 00:08:56,080
a completely new thing we can also

00:08:53,040 --> 00:08:58,800
extend a sign distance field into

00:08:56,080 --> 00:09:00,160
a mask of another grid which is a

00:08:58,800 --> 00:09:04,080
complete new feature

00:09:00,160 --> 00:09:06,800
all right so at this point i uh

00:09:04,080 --> 00:09:08,240
i'm going to make what i believe is is a

00:09:06,800 --> 00:09:10,320
pretty exciting uh

00:09:08,240 --> 00:09:11,360
announcement for for openvdb so as i

00:09:10,320 --> 00:09:14,560
mentioned before

00:09:11,360 --> 00:09:18,240
openvdb was from the onset a sort of

00:09:14,560 --> 00:09:21,279
develop for the cpu

00:09:18,240 --> 00:09:25,839
and today nvidia is actually

00:09:21,279 --> 00:09:28,160
sharing a library called nanovdb um

00:09:25,839 --> 00:09:29,360
that was developed actually since the

00:09:28,160 --> 00:09:31,040
the beginning of the year when i when i

00:09:29,360 --> 00:09:33,360
joined nvidia

00:09:31,040 --> 00:09:35,760
and it's the first attempt to try and

00:09:33,360 --> 00:09:39,120
take some of the workflows

00:09:35,760 --> 00:09:40,720
in openvdb to the gpu you should really

00:09:39,120 --> 00:09:42,640
read something into the name

00:09:40,720 --> 00:09:44,720
nano right it's not an attempt to take

00:09:42,640 --> 00:09:46,480
the full open vdb library and port it to

00:09:44,720 --> 00:09:49,279
the gpu

00:09:46,480 --> 00:09:51,040
this is taking sort of a small subset of

00:09:49,279 --> 00:09:52,240
problems specifically it's looking at

00:09:51,040 --> 00:09:53,839
things like rendering real-time

00:09:52,240 --> 00:09:55,760
rendering and ray tracing

00:09:53,839 --> 00:09:57,600
and also things like collision detection

00:09:55,760 --> 00:10:02,160
um so what is it

00:09:57,600 --> 00:10:04,959
it's essentially a sort of a a

00:10:02,160 --> 00:10:05,920
snapshot of an existing vdb data

00:10:04,959 --> 00:10:08,480
structure

00:10:05,920 --> 00:10:10,640
reshuffling the memory into a contiguous

00:10:08,480 --> 00:10:14,000
block of memory

00:10:10,640 --> 00:10:16,880
and then it also gets rid of pointers so

00:10:14,000 --> 00:10:18,240
it's very efficient to copy between cpu

00:10:16,880 --> 00:10:20,959
and gpu

00:10:18,240 --> 00:10:22,640
it offers the same constant time random

00:10:20,959 --> 00:10:24,399
access that we looked at earlier

00:10:22,640 --> 00:10:26,079
that you will find in openvdb in fact it

00:10:24,399 --> 00:10:28,640
turns out that

00:10:26,079 --> 00:10:31,040
they're slightly faster in nanovdb than

00:10:28,640 --> 00:10:32,800
in openvdb

00:10:31,040 --> 00:10:34,320
simply because it's it's a more nimble

00:10:32,800 --> 00:10:37,040
implementation um

00:10:34,320 --> 00:10:38,160
it has a few extra things that openvdb

00:10:37,040 --> 00:10:40,000
does not have

00:10:38,160 --> 00:10:41,760
which is specifically to accelerate ray

00:10:40,000 --> 00:10:45,040
tracing so

00:10:41,760 --> 00:10:47,040
it bakes in meta data in the nodes

00:10:45,040 --> 00:10:48,399
that accelerate things like volume

00:10:47,040 --> 00:10:50,640
rendering

00:10:48,399 --> 00:10:52,399
and ray intersection so it it has

00:10:50,640 --> 00:10:53,600
bounding boxes of the active values at

00:10:52,399 --> 00:10:56,480
every single node

00:10:53,600 --> 00:10:58,079
and it also has statistics like min max

00:10:56,480 --> 00:11:00,399
values

00:10:58,079 --> 00:11:02,079
it supports all the types that you will

00:11:00,399 --> 00:11:04,160
find in openvdb

00:11:02,079 --> 00:11:05,600
including points with arbitrary

00:11:04,160 --> 00:11:07,600
attributes so point index squares and

00:11:05,600 --> 00:11:11,360
point data grids are also supported in

00:11:07,600 --> 00:11:13,279
nanovcdp um another thing that's

00:11:11,360 --> 00:11:15,440
quite exciting is that it's it's

00:11:13,279 --> 00:11:18,240
virtually agnostic to the platform

00:11:15,440 --> 00:11:18,880
so it's implemented in both c plus plus

00:11:18,240 --> 00:11:22,079
00:11:18,880 --> 00:11:26,320
and also there's a c99 version uh

00:11:22,079 --> 00:11:29,279
that geoflate actually uh ported

00:11:26,320 --> 00:11:30,560
this the core data structure itself um

00:11:29,279 --> 00:11:33,360
is a single header file

00:11:30,560 --> 00:11:33,839
so in theory your client code only needs

00:11:33,360 --> 00:11:35,200
to

00:11:33,839 --> 00:11:37,360
include a single header file and this

00:11:35,200 --> 00:11:39,680
set of header file has

00:11:37,360 --> 00:11:41,120
uh no dependencies like optionally of

00:11:39,680 --> 00:11:43,120
course you can

00:11:41,120 --> 00:11:45,600
have a dependency on openvdb in case you

00:11:43,120 --> 00:11:48,560
want to go from openvdb to nanovdb

00:11:45,600 --> 00:11:50,000
but for a renderer to pick up nanovdb

00:11:48,560 --> 00:11:52,560
you actually don't have any other

00:11:50,000 --> 00:11:55,440
dependencies in this single header fr

00:11:52,560 --> 00:11:57,440
it's using explicit memory alignment so

00:11:55,440 --> 00:11:59,839
32 byte alignment

00:11:57,440 --> 00:12:02,000
which is required so we can tap into all

00:11:59,839 --> 00:12:05,920
the different graphics apis out there so

00:12:02,000 --> 00:12:09,120
it supports cuda optics opengl opencl

00:12:05,920 --> 00:12:11,920
gsl and sperf it also has

00:12:09,120 --> 00:12:14,399
a cpu fallback so it works equally well

00:12:11,920 --> 00:12:17,279
on the cpu and the gpu

00:12:14,399 --> 00:12:18,079
and currently nvidia's are also working

00:12:17,279 --> 00:12:22,320
on adding

00:12:18,079 --> 00:12:25,360
support for directx that's coming

00:12:22,320 --> 00:12:26,880
soon um there's also a fast mapping

00:12:25,360 --> 00:12:28,639
between the two and we can actually do

00:12:26,880 --> 00:12:30,800
round trips so you can both go both from

00:12:28,639 --> 00:12:31,360
openvdb to nanovdb and you can go back

00:12:30,800 --> 00:12:34,480
again

00:12:31,360 --> 00:12:35,839
um all right so it also comes with a

00:12:34,480 --> 00:12:37,600
separate file format

00:12:35,839 --> 00:12:39,760
um it's not that we are sort of

00:12:37,600 --> 00:12:43,200
promoting the file format of any

00:12:39,760 --> 00:12:45,120
of nanowrimo b to replace openvdb um

00:12:43,200 --> 00:12:47,279
but it does allow as i mentioned before

00:12:45,120 --> 00:12:51,200
it does allow applications like a render

00:12:47,279 --> 00:12:52,480
to only depend on uh the nanovb library

00:12:51,200 --> 00:12:54,880
itself in case you want that

00:12:52,480 --> 00:12:55,920
um so we as i said we can do

00:12:54,880 --> 00:12:58,880
serialization

00:12:55,920 --> 00:13:00,880
in both directions uh we include a few

00:12:58,880 --> 00:13:06,560
functions in the library as well

00:13:00,880 --> 00:13:08,639
uh particular to cater for rendering so

00:13:06,560 --> 00:13:10,079
serial first second and third order

00:13:08,639 --> 00:13:12,720
interpolation

00:13:10,079 --> 00:13:14,000
there's also the ability to actually

00:13:12,720 --> 00:13:17,279
generate

00:13:14,000 --> 00:13:20,000
nano vdb grids out of pretty much

00:13:17,279 --> 00:13:20,720
any other volumetric data structure

00:13:20,000 --> 00:13:22,800
without

00:13:20,720 --> 00:13:24,160
necessarily converting to an openvdb

00:13:22,800 --> 00:13:25,760
first there's a this is what's called

00:13:24,160 --> 00:13:29,040
the grid builder

00:13:25,760 --> 00:13:31,200
um there's a very advanced and cool

00:13:29,040 --> 00:13:32,880
uh renderer including that was developed

00:13:31,200 --> 00:13:36,320
by will breitbart

00:13:32,880 --> 00:13:37,279
at nvidia uh that's actually included as

00:13:36,320 --> 00:13:39,680
a demonstration

00:13:37,279 --> 00:13:41,760
of of how to use nanodb with all these

00:13:39,680 --> 00:13:43,040
different graphics apis and and as you

00:13:41,760 --> 00:13:45,680
probably noticed

00:13:43,040 --> 00:13:46,560
uh it's not that nanov only supports

00:13:45,680 --> 00:13:48,959
nvidia's

00:13:46,560 --> 00:13:49,839
api right so it's also open opengl

00:13:48,959 --> 00:13:52,079
opencl

00:13:49,839 --> 00:13:55,040
and some of the other ones so it's in

00:13:52,079 --> 00:13:58,399
that sense it is truly agnostic

00:13:55,040 --> 00:14:00,959
and there's also acceleration for uh

00:13:58,399 --> 00:14:02,000
rate reversal and so skipping of empty

00:14:00,959 --> 00:14:04,959
space this thing called

00:14:02,000 --> 00:14:06,000
an an hdda hierarchical digital

00:14:04,959 --> 00:14:08,480
differential

00:14:06,000 --> 00:14:10,480
analyzer which is actually something an

00:14:08,480 --> 00:14:12,399
idea that came from from openvdb

00:14:10,480 --> 00:14:13,920
uh so it's been ported it's actually a

00:14:12,399 --> 00:14:16,240
different implementation

00:14:13,920 --> 00:14:18,079
and it turns out to be uh outperforming

00:14:16,240 --> 00:14:21,839
the one in openvdb

00:14:18,079 --> 00:14:24,480
um so these are some uh

00:14:21,839 --> 00:14:25,120
oh sorry these are some uh benchmark

00:14:24,480 --> 00:14:28,240
tests

00:14:25,120 --> 00:14:29,040
uh it's just these actually very old but

00:14:28,240 --> 00:14:32,399
they still hold up

00:14:29,040 --> 00:14:35,760
so this is ray tracing uh the amadillo

00:14:32,399 --> 00:14:37,600
um it's casting close to two billion or

00:14:35,760 --> 00:14:40,720
two million rays per frame

00:14:37,600 --> 00:14:43,040
um and uh the first thing you'll note is

00:14:40,720 --> 00:14:45,760
that conversion from openvp's nanovdb

00:14:43,040 --> 00:14:47,120
is is really fast it's about 30

00:14:45,760 --> 00:14:50,399
milliseconds in this case

00:14:47,120 --> 00:14:53,680
um and you're seeing different

00:14:50,399 --> 00:14:56,800
um computational times

00:14:53,680 --> 00:14:57,440
for single threaded cpu uh multi-core

00:14:56,800 --> 00:15:01,839
cpu

00:14:57,440 --> 00:15:03,600
actually 44 cores um and then

00:15:01,839 --> 00:15:05,040
the acceleration that you get from using

00:15:03,600 --> 00:15:07,519
the hdda and

00:15:05,040 --> 00:15:08,959
to sort of make a long story short uh

00:15:07,519 --> 00:15:09,440
for this particular example we're able

00:15:08,959 --> 00:15:12,399
to

00:15:09,440 --> 00:15:13,199
retrace over a billion rays per second

00:15:12,399 --> 00:15:17,199
which is

00:15:13,199 --> 00:15:19,600
quite fast this is

00:15:17,199 --> 00:15:20,639
another example just to show that it

00:15:19,600 --> 00:15:24,079
really doesn't depend

00:15:20,639 --> 00:15:27,120
much on the complexity of the model

00:15:24,079 --> 00:15:30,160
it also has close to two million rays

00:15:27,120 --> 00:15:32,880
um and again it's it's achieving

00:15:30,160 --> 00:15:33,440
more than a billion ray intersections

00:15:32,880 --> 00:15:37,040
per

00:15:33,440 --> 00:15:38,800
second so this is this is full on um

00:15:37,040 --> 00:15:40,240
ray level sets intersect so we're

00:15:38,800 --> 00:15:41,040
obviously not rendering a match we're

00:15:40,240 --> 00:15:44,399
actually rendering

00:15:41,040 --> 00:15:47,680
a level set volume um this

00:15:44,399 --> 00:15:51,199
is a screen session uh from

00:15:47,680 --> 00:15:54,320
will's viewer that we are including

00:15:51,199 --> 00:15:56,320
um so you can you can point it to an

00:15:54,320 --> 00:15:58,560
open vdb file you can point it to a nano

00:15:56,320 --> 00:16:01,440
vdp file and the nvp file of course can

00:15:58,560 --> 00:16:02,480
um encapsulate many different grids of

00:16:01,440 --> 00:16:05,199
arbitrary type

00:16:02,480 --> 00:16:06,399
uh you can on the right hand side you

00:16:05,199 --> 00:16:08,399
can actually have you have a drop down

00:16:06,399 --> 00:16:10,000
menu so you can drop down and take

00:16:08,399 --> 00:16:13,199
different graphics apis

00:16:10,000 --> 00:16:16,560
uh so there's cuda optics

00:16:13,199 --> 00:16:18,720
there is uh intel's threat building

00:16:16,560 --> 00:16:20,800
blocks so the cpu

00:16:18,720 --> 00:16:23,120
and so on you have the um you have the

00:16:20,800 --> 00:16:26,240
frame count um

00:16:23,120 --> 00:16:27,920
you have statistics um and you have drop

00:16:26,240 --> 00:16:30,720
down menus where you can sort of

00:16:27,920 --> 00:16:31,040
switch between your grids um so this is

00:16:30,720 --> 00:16:34,079
the

00:16:31,040 --> 00:16:35,519
the disney cloud um and of course we get

00:16:34,079 --> 00:16:38,000
interactive frame rates

00:16:35,519 --> 00:16:40,079
which is sort of the main point here

00:16:38,000 --> 00:16:43,040
it's obviously not a production render

00:16:40,079 --> 00:16:44,240
never it was never intended to be but

00:16:43,040 --> 00:16:46,880
it's great for

00:16:44,240 --> 00:16:48,480
debugging it's great for a sort of

00:16:46,880 --> 00:16:50,480
example and starting code

00:16:48,480 --> 00:16:53,040
in case you want to know how to use this

00:16:50,480 --> 00:16:56,959
let's say for opencl

00:16:53,040 --> 00:16:59,120
there are also lots of examples included

00:16:56,959 --> 00:17:00,639
i'll point you to how to get to the

00:16:59,120 --> 00:17:03,279
software at the end of this

00:17:00,639 --> 00:17:05,839
presentation so this is importing point

00:17:03,279 --> 00:17:05,839
cloud

00:17:06,480 --> 00:17:10,480
and yeah i think i'll move on to the

00:17:09,600 --> 00:17:14,400
next slide

00:17:10,480 --> 00:17:18,000
so um this is actually an internal

00:17:14,400 --> 00:17:20,160
application of a nanov

00:17:18,000 --> 00:17:22,799
so andrew ritmeyer has developed a

00:17:20,160 --> 00:17:25,919
really cool interactive

00:17:22,799 --> 00:17:26,640
fluid solver called flow and he was able

00:17:25,919 --> 00:17:30,559
to pick up

00:17:26,640 --> 00:17:32,720
nanovdb and use it for sourcing

00:17:30,559 --> 00:17:34,720
in the span of a couple of days um and

00:17:32,720 --> 00:17:37,760
he's able to source

00:17:34,720 --> 00:17:40,000
uh uh fuel on the left-hand side

00:17:37,760 --> 00:17:41,919
and smoke density on the right-hand side

00:17:40,000 --> 00:17:45,200
at about a millisecond per frame so

00:17:41,919 --> 00:17:46,640
random access uh is very fast on on the

00:17:45,200 --> 00:17:48,960
device

00:17:46,640 --> 00:17:50,880
um these are two other examples uh this

00:17:48,960 --> 00:17:52,480
these are kind of silly examples but we

00:17:50,880 --> 00:17:56,000
really wanted to sort of

00:17:52,480 --> 00:17:59,280
stress a point that the ray tracing

00:17:56,000 --> 00:18:00,960
performance is is virtually independent

00:17:59,280 --> 00:18:02,480
of the complexity of the model itself in

00:18:00,960 --> 00:18:04,880
the sense that

00:18:02,480 --> 00:18:05,600
the vdb data structure offers constant

00:18:04,880 --> 00:18:07,919
time

00:18:05,600 --> 00:18:09,679
access um so on the left hand side

00:18:07,919 --> 00:18:11,280
you're seeing a level set of volume

00:18:09,679 --> 00:18:14,799
representation of a hair ball

00:18:11,280 --> 00:18:17,360
uh using two billion boxes which is

00:18:14,799 --> 00:18:18,640
it's granted it's overkill but a certain

00:18:17,360 --> 00:18:20,000
guess gives the point across we still

00:18:18,640 --> 00:18:22,400
get interactive frame rates

00:18:20,000 --> 00:18:24,480
and on the right hand side we have again

00:18:22,400 --> 00:18:26,240
the disney cloud

00:18:24,480 --> 00:18:29,840
but at a much higher resolution than you

00:18:26,240 --> 00:18:32,400
saw earlier

00:18:29,840 --> 00:18:33,679
all right so i really want to thank uh

00:18:32,400 --> 00:18:36,160
obviously nvidia

00:18:33,679 --> 00:18:37,280
for contributing this to the openvdb

00:18:36,160 --> 00:18:38,559
project

00:18:37,280 --> 00:18:40,960
but i also want to thank a number of

00:18:38,559 --> 00:18:43,440
other companies that were helped us

00:18:40,960 --> 00:18:45,039
sort of mature it and gave feedback uh

00:18:43,440 --> 00:18:47,440
particular side effects ilm

00:18:45,039 --> 00:18:48,400
and pixar and then i want to call out a

00:18:47,440 --> 00:18:51,039
few people so

00:18:48,400 --> 00:18:52,480
especially will breitbart have been an

00:18:51,039 --> 00:18:56,480
amazing collaborator

00:18:52,480 --> 00:19:00,160
as i mentioned he wrote the included

00:18:56,480 --> 00:19:01,280
interactive raytracer um and he did a

00:19:00,160 --> 00:19:04,160
lot of things as well

00:19:01,280 --> 00:19:06,480
he did the cmake and and helped help

00:19:04,160 --> 00:19:09,760
with the memory alignment and stuff

00:19:06,480 --> 00:19:10,240
jeff uh was a great contributor as well

00:19:09,760 --> 00:19:12,080
he

00:19:10,240 --> 00:19:13,440
jeff who's actually on the on the tsc

00:19:12,080 --> 00:19:16,000
committee uh

00:19:13,440 --> 00:19:17,760
he ported uh the first c plus plus

00:19:16,000 --> 00:19:20,960
implementation to c

00:19:17,760 --> 00:19:24,559
and actually integrated nanovdb in

00:19:20,960 --> 00:19:26,960
uh the next major release of houdini

00:19:24,559 --> 00:19:28,000
so it's it's already on the way there's

00:19:26,960 --> 00:19:31,280
also andrew

00:19:28,000 --> 00:19:34,480
uh and frank that were uh very helpful

00:19:31,280 --> 00:19:36,240
uh they're both at nvidia so

00:19:34,480 --> 00:19:37,760
uh in case in case you want to try it

00:19:36,240 --> 00:19:40,160
out i should say that

00:19:37,760 --> 00:19:41,760
the release that we have today is sort

00:19:40,160 --> 00:19:45,440
of a better release it's not a

00:19:41,760 --> 00:19:45,440
production release it still needs to

00:19:45,520 --> 00:19:49,840
go undergo some changes we need to add

00:19:48,000 --> 00:19:51,679
directx support

00:19:49,840 --> 00:19:53,600
we also need to go through the regular

00:19:51,679 --> 00:19:56,880
sort of code review

00:19:53,600 --> 00:19:59,440
but it's available uh it's actually

00:19:56,880 --> 00:19:59,919
exists in what's called a feature branch

00:19:59,440 --> 00:20:02,720
in

00:19:59,919 --> 00:20:03,120
uh the openvp repository so just check

00:20:02,720 --> 00:20:06,400
out

00:20:03,120 --> 00:20:09,120
the the repo uh

00:20:06,400 --> 00:20:09,520
and check out the feature itself so it's

00:20:09,120 --> 00:20:12,640
called

00:20:09,520 --> 00:20:13,039
features less nano db um and we also

00:20:12,640 --> 00:20:16,640
have

00:20:13,039 --> 00:20:18,559
a live blog that's hosted at nvidia

00:20:16,640 --> 00:20:20,320
that discusses nano vdb a little bit

00:20:18,559 --> 00:20:22,240
further and actually show some

00:20:20,320 --> 00:20:24,799
performance tests and also some of the

00:20:22,240 --> 00:20:24,799
examples

00:20:25,039 --> 00:20:30,400
so that is it for me um

00:20:28,480 --> 00:20:34,240
i think it's over to you now nick i'll

00:20:30,400 --> 00:20:37,600
just stop sharing

00:20:34,240 --> 00:20:38,240
awesome thanks ken yeah just a reminder

00:20:37,600 --> 00:20:40,320
uh

00:20:38,240 --> 00:20:41,919
any questions please put them in the q a

00:20:40,320 --> 00:20:44,240
and we'll get to them afterwards

00:20:41,919 --> 00:20:44,240
uh

00:20:45,520 --> 00:20:48,880
but yeah we are we are watching it thank

00:20:47,520 --> 00:20:50,559
you very much guys for tuning in thanks

00:20:48,880 --> 00:20:53,280
ken um

00:20:50,559 --> 00:20:53,840
cool so i'm going to give a very brief

00:20:53,280 --> 00:20:55,840
uh

00:20:53,840 --> 00:20:57,840
recap or and uh presentation on

00:20:55,840 --> 00:20:59,919
openbdbax

00:20:57,840 --> 00:21:01,200
uh for those that aren't aware i'm going

00:20:59,919 --> 00:21:02,880
to do a bit of a history

00:21:01,200 --> 00:21:04,559
very brief history of the project um

00:21:02,880 --> 00:21:05,840
where we're at today and what the

00:21:04,559 --> 00:21:07,120
project is

00:21:05,840 --> 00:21:08,480
and also where we're what we're

00:21:07,120 --> 00:21:08,960
currently working on where we see the

00:21:08,480 --> 00:21:12,400
project

00:21:08,960 --> 00:21:15,600
uh going so super quickly so

00:21:12,400 --> 00:21:17,760
quick recap open bdb x was open source

00:21:15,600 --> 00:21:18,960
at digipro in 2018

00:21:17,760 --> 00:21:21,440
it was always intended to be

00:21:18,960 --> 00:21:22,880
incorporated into openvdb

00:21:21,440 --> 00:21:26,320
and it's something that the tfc wants to

00:21:22,880 --> 00:21:28,480
do uh but since the teens tsc's

00:21:26,320 --> 00:21:30,080
creation uh roughly around the same time

00:21:28,480 --> 00:21:32,400
we've had a lot of stuff

00:21:30,080 --> 00:21:34,000
uh on the on the backlog to work through

00:21:32,400 --> 00:21:36,640
so it's been a bit delayed

00:21:34,000 --> 00:21:38,640
but i think we see a part in in the near

00:21:36,640 --> 00:21:39,600
future to get openvp ax into the core

00:21:38,640 --> 00:21:41,120
repository

00:21:39,600 --> 00:21:42,480
it currently exists as a feature branch

00:21:41,120 --> 00:21:44,720
and i'll share links for this at the end

00:21:42,480 --> 00:21:46,720
of the slides as well

00:21:44,720 --> 00:21:48,320
ax itself for those that are unaware is

00:21:46,720 --> 00:21:48,880
a just-in-time compiled expression

00:21:48,320 --> 00:21:51,440
language

00:21:48,880 --> 00:21:52,640
for focus around manipulating geometry

00:21:51,440 --> 00:21:54,799
attributes

00:21:52,640 --> 00:21:56,640
it's it aims to provide compiled time

00:21:54,799 --> 00:21:58,799
cpr plus equivalent performance

00:21:56,640 --> 00:22:00,320
but also provide the portability and

00:21:58,799 --> 00:22:01,760
deterministic behavior associated with

00:22:00,320 --> 00:22:05,440
an expression language so you can plug

00:22:01,760 --> 00:22:08,080
it into a variety of applications

00:22:05,440 --> 00:22:08,720
and it's domain specific for vdb which

00:22:08,080 --> 00:22:10,640
is

00:22:08,720 --> 00:22:12,400
which is half true the language is

00:22:10,640 --> 00:22:13,600
agnostic technically to the underlying

00:22:12,400 --> 00:22:15,679
primitive types

00:22:13,600 --> 00:22:17,360
but since it's since its original design

00:22:15,679 --> 00:22:20,559
it was always intended to be specific

00:22:17,360 --> 00:22:22,720
for openvdb points and volumes

00:22:20,559 --> 00:22:24,720
and focusing on that allows us to tailor

00:22:22,720 --> 00:22:26,720
the language

00:22:24,720 --> 00:22:28,159
features to better act on those kind of

00:22:26,720 --> 00:22:30,559
data types and i don't see that changing

00:22:28,159 --> 00:22:33,919
anytime soon

00:22:30,559 --> 00:22:37,360
so this is a super simple example

00:22:33,919 --> 00:22:39,840
of how ax can be used

00:22:37,360 --> 00:22:41,120
uh and also kind of highlights why we

00:22:39,840 --> 00:22:42,720
wanted it in the first place well we

00:22:41,120 --> 00:22:43,280
came up with the idea why we worked on

00:22:42,720 --> 00:22:46,159
it

00:22:43,280 --> 00:22:48,000
uh so this is a very basic uh openvdb

00:22:46,159 --> 00:22:49,280
simulation we've got overview points

00:22:48,000 --> 00:22:50,400
being a defective through a vpdp

00:22:49,280 --> 00:22:52,080
velocity field

00:22:50,400 --> 00:22:54,480
uh the level level set representing the

00:22:52,080 --> 00:22:55,600
collision and it's pretty boring it's

00:22:54,480 --> 00:22:57,840
pretty smooth

00:22:55,600 --> 00:22:59,600
so one technique that we could use to uh

00:22:57,840 --> 00:23:01,200
make this more interesting is by

00:22:59,600 --> 00:23:03,200
injecting some cone noise injecting any

00:23:01,200 --> 00:23:04,799
noise at all really onto

00:23:03,200 --> 00:23:07,280
some of the particle velocities within a

00:23:04,799 --> 00:23:08,880
certain scale

00:23:07,280 --> 00:23:10,799
this is kind of what that looks like in

00:23:08,880 --> 00:23:12,240
c plus plus you don't need to

00:23:10,799 --> 00:23:14,080
be able to see the code here this is

00:23:12,240 --> 00:23:15,919
more just to highlight how much

00:23:14,080 --> 00:23:18,400
boilerplate there is

00:23:15,919 --> 00:23:19,600
and just stuff you have to do before you

00:23:18,400 --> 00:23:20,080
can actually get to the interesting

00:23:19,600 --> 00:23:23,039
parts

00:23:20,080 --> 00:23:25,679
of your operation um which is basically

00:23:23,039 --> 00:23:27,760
running your per point manipulation

00:23:25,679 --> 00:23:29,440
and altering those velocity values and

00:23:27,760 --> 00:23:30,080
you can kind of think of ax as a window

00:23:29,440 --> 00:23:32,799
into

00:23:30,080 --> 00:23:34,159
that side of interfacing with bdb data

00:23:32,799 --> 00:23:37,120
when it handles

00:23:34,159 --> 00:23:38,960
the uh or everything else for you and

00:23:37,120 --> 00:23:40,640
here's what the code looks like

00:23:38,960 --> 00:23:42,240
in ax so this is the equivalent coding

00:23:40,640 --> 00:23:43,760
ax um

00:23:42,240 --> 00:23:45,600
just to kind of talk through the syntax

00:23:43,760 --> 00:23:48,880
hopefully this isn't too um

00:23:45,600 --> 00:23:50,880
unfamiliar with other coding styles

00:23:48,880 --> 00:23:52,480
looping over every point in this case

00:23:50,880 --> 00:23:54,400
this dollar syntax is pulling from

00:23:52,480 --> 00:23:55,679
user-defined parameters

00:23:54,400 --> 00:23:57,039
and then we have a little function here

00:23:55,679 --> 00:23:57,760
that's building there uh building some

00:23:57,039 --> 00:24:00,720
noise

00:23:57,760 --> 00:24:01,840
and applying that to uh open uh point

00:24:00,720 --> 00:24:04,960
velocity attributes

00:24:01,840 --> 00:24:06,159
this could also run over uh vdb or vw

00:24:04,960 --> 00:24:08,000
velocity field but in this case we're

00:24:06,159 --> 00:24:11,679
running over points and accumulating

00:24:08,000 --> 00:24:11,679
uh velocity attribute with this syntax

00:24:11,840 --> 00:24:14,880
and that's this is what the result looks

00:24:14,159 --> 00:24:18,559
like

00:24:14,880 --> 00:24:20,799
um so yeah fairly fairly simple and

00:24:18,559 --> 00:24:22,080
fairly simple kind of example but i just

00:24:20,799 --> 00:24:23,279
wanted to show

00:24:22,080 --> 00:24:24,480
everyone that's unfamiliar with what the

00:24:23,279 --> 00:24:26,480
language looks like and what the project

00:24:24,480 --> 00:24:28,799
is how it can be used to influence vdb

00:24:26,480 --> 00:24:28,799
data

00:24:29,279 --> 00:24:33,440
cool so i want to spend the majority of

00:24:32,080 --> 00:24:35,760
the presentation talking about new

00:24:33,440 --> 00:24:36,960
features and where the project's going

00:24:35,760 --> 00:24:39,600
uh the first thing we've done is

00:24:36,960 --> 00:24:41,360
documentation which might not be

00:24:39,600 --> 00:24:43,039
the most exciting thing but it's

00:24:41,360 --> 00:24:46,640
definitely one of the most useful

00:24:43,039 --> 00:24:48,559
uh parts of uh the the new release

00:24:46,640 --> 00:24:50,640
it's uh currently hosted on my personal

00:24:48,559 --> 00:24:53,039
github but will be moved into the um

00:24:50,640 --> 00:24:54,000
open bdb docs uh when that merges

00:24:53,039 --> 00:24:55,200
completes

00:24:54,000 --> 00:24:57,200
so please check that out the language

00:24:55,200 --> 00:24:58,640
docs are looking pretty good now

00:24:57,200 --> 00:25:00,159
still a lot more work needs to be done

00:24:58,640 --> 00:25:03,919
here but it's going to be a work in

00:25:00,159 --> 00:25:03,919
progress up until that that gold release

00:25:04,320 --> 00:25:07,520
other new features so previously you

00:25:06,480 --> 00:25:10,400
could only iterate

00:25:07,520 --> 00:25:11,360
over voxels within vdb you can now

00:25:10,400 --> 00:25:14,480
specify any

00:25:11,360 --> 00:25:15,600
uh tree level within a vb data structure

00:25:14,480 --> 00:25:18,240
to execute over

00:25:15,600 --> 00:25:19,440
so if you run back to ken's presentation

00:25:18,240 --> 00:25:21,279
you can choose any

00:25:19,440 --> 00:25:23,200
uh node level within the vdb data

00:25:21,279 --> 00:25:24,960
structure and iterate over those

00:25:23,200 --> 00:25:27,200
and allows you to manipulate every value

00:25:24,960 --> 00:25:28,159
in a vdb

00:25:27,200 --> 00:25:29,520
and we've just made a bunch of

00:25:28,159 --> 00:25:31,279
improvements and fixes which you can

00:25:29,520 --> 00:25:33,120
also check out at the uh

00:25:31,279 --> 00:25:36,400
changes blog and i'll provide that link

00:25:33,120 --> 00:25:36,400
to the end of the presentation as well

00:25:36,799 --> 00:25:40,640
one of the uh other additions we made is

00:25:38,960 --> 00:25:42,480
the introduction of this header file

00:25:40,640 --> 00:25:43,919
so for those that are familiar with the

00:25:42,480 --> 00:25:45,760
project before

00:25:43,919 --> 00:25:47,279
to run like a full ax pipeline from

00:25:45,760 --> 00:25:48,960
parsing uh

00:25:47,279 --> 00:25:50,559
compiling code generation to execution

00:25:48,960 --> 00:25:53,760
you have to interface with a few

00:25:50,559 --> 00:25:54,880
uh different parts of ax this kind of

00:25:53,760 --> 00:25:57,039
wraps all that in to get

00:25:54,880 --> 00:25:58,400
all that together so at the c plus plus

00:25:57,039 --> 00:25:59,919
in c plus api

00:25:58,400 --> 00:26:03,600
you can now run a single function and

00:25:59,919 --> 00:26:03,600
incorporate that into your programs

00:26:06,240 --> 00:26:09,600
so i just want to demo that super

00:26:07,679 --> 00:26:11,440
quickly so this is a really

00:26:09,600 --> 00:26:12,960
hamming example really simple file about

00:26:11,440 --> 00:26:13,840
uh sorry simple example where you can

00:26:12,960 --> 00:26:15,760
read in

00:26:13,840 --> 00:26:17,039
uh an openvdb file it's not doing

00:26:15,760 --> 00:26:18,400
anything with it and then just writing

00:26:17,039 --> 00:26:20,960
writing it back out

00:26:18,400 --> 00:26:22,480
and then to incorporate ax uh we can

00:26:20,960 --> 00:26:24,799
step through this particular

00:26:22,480 --> 00:26:27,120
uh code on the left we're going to

00:26:24,799 --> 00:26:28,960
include ax as a header

00:26:27,120 --> 00:26:30,240
we're going to initialize ax in a

00:26:28,960 --> 00:26:34,080
similar way that you initialize

00:26:30,240 --> 00:26:36,320
um openvdb we can then run any custom

00:26:34,080 --> 00:26:38,320
ax code so here we're looking for a

00:26:36,320 --> 00:26:40,400
surface attribute or grid

00:26:38,320 --> 00:26:42,080
uh attribute if it's points um grid

00:26:40,400 --> 00:26:43,600
obviously if it's a vdb volume

00:26:42,080 --> 00:26:45,440
and we're accumulating a just a small

00:26:43,600 --> 00:26:46,640
value onto that um

00:26:45,440 --> 00:26:48,480
and passing in the grids that we've read

00:26:46,640 --> 00:26:50,400
from the file

00:26:48,480 --> 00:26:52,000
making sure we uninitialize ax and then

00:26:50,400 --> 00:26:54,559
writing everything back out to

00:26:52,000 --> 00:26:55,919
disk so hopefully that demonstrates um

00:26:54,559 --> 00:26:57,679
how simple it can be to

00:26:55,919 --> 00:27:00,080
incorporate ax into existing b2b

00:26:57,679 --> 00:27:00,080
workflows

00:27:00,559 --> 00:27:04,000
so a couple of uh things that we're

00:27:02,880 --> 00:27:05,840
working on that aren't currently

00:27:04,000 --> 00:27:08,000
released but we'd like to get

00:27:05,840 --> 00:27:08,960
out as soon as possible as i mentioned

00:27:08,000 --> 00:27:12,720
ax was a bit

00:27:08,960 --> 00:27:14,400
a bit in feature lock to uh try and

00:27:12,720 --> 00:27:15,840
help with the adoption into the openvp

00:27:14,400 --> 00:27:17,440
project um

00:27:15,840 --> 00:27:19,200
but since then we've added a few we're

00:27:17,440 --> 00:27:20,000
working on a few new features the first

00:27:19,200 --> 00:27:22,480
is

00:27:20,000 --> 00:27:24,559
attribute function syntax and this

00:27:22,480 --> 00:27:25,919
syntax is subject to change so

00:27:24,559 --> 00:27:27,919
this might might change before its

00:27:25,919 --> 00:27:28,640
release but the idea here is to be able

00:27:27,919 --> 00:27:30,080
to call

00:27:28,640 --> 00:27:31,679
functions which are specific to a

00:27:30,080 --> 00:27:34,080
primitive type and have specific

00:27:31,679 --> 00:27:34,880
behavior for that primitive type so in

00:27:34,080 --> 00:27:36,480
this example

00:27:34,880 --> 00:27:38,159
all these functions that you see here

00:27:36,480 --> 00:27:41,679
that are being called

00:27:38,159 --> 00:27:44,960
after this app surface syntax

00:27:41,679 --> 00:27:46,720
are specific for vdbe volumes

00:27:44,960 --> 00:27:48,159
so the first four here we are retrieving

00:27:46,720 --> 00:27:48,799
arbitrary coordinates and performing

00:27:48,159 --> 00:27:51,360
arbitrary

00:27:48,799 --> 00:27:52,720
samples from a coordinate the next three

00:27:51,360 --> 00:27:54,320
here are retrieving transform

00:27:52,720 --> 00:27:56,320
information from a volume

00:27:54,320 --> 00:27:57,760
and the last two here are querying

00:27:56,320 --> 00:27:59,600
whether or not a particular coordinates

00:27:57,760 --> 00:28:01,440
is a voxel which will return force if

00:27:59,600 --> 00:28:03,039
it's a tile or another node type

00:28:01,440 --> 00:28:04,559
uh and also whether or not i know it is

00:28:03,039 --> 00:28:06,399
active or not um

00:28:04,559 --> 00:28:07,919
and you can see with the last few

00:28:06,399 --> 00:28:10,159
functions here how

00:28:07,919 --> 00:28:11,360
focusing on vdb specific functionality

00:28:10,159 --> 00:28:14,000
lets the language

00:28:11,360 --> 00:28:15,440
uh uh leverages the language to be out

00:28:14,000 --> 00:28:16,399
and called to be able to focus on more

00:28:15,440 --> 00:28:18,880
specific vdb

00:28:16,399 --> 00:28:19,520
features so for example the activation

00:28:18,880 --> 00:28:21,120
uh

00:28:19,520 --> 00:28:23,120
kind of node masking of the bdb or

00:28:21,120 --> 00:28:26,720
whether or not a vdb is app uh noise at

00:28:23,120 --> 00:28:26,720
a particular level within a bdb

00:28:27,360 --> 00:28:30,720
cool so this is a quick demo just going

00:28:29,039 --> 00:28:34,159
to pause it

00:28:30,720 --> 00:28:37,440
so this is a super quick demo in houdini

00:28:34,159 --> 00:28:39,039
which demonstrates these new features

00:28:37,440 --> 00:28:40,880
so i'm reading in the dragon asset that

00:28:39,039 --> 00:28:42,799
you can get from the vdb websites

00:28:40,880 --> 00:28:45,039
and on the left here i've got a smooth

00:28:42,799 --> 00:28:48,480
operation and forming a mean filter

00:28:45,039 --> 00:28:50,320
with five within five voxels

00:28:48,480 --> 00:28:51,840
so with these new operations you can

00:28:50,320 --> 00:28:53,520
construct your own filters you can

00:28:51,840 --> 00:28:55,840
match existing functionality and you can

00:28:53,520 --> 00:28:56,399
extend it as well so if we don't uh jump

00:28:55,840 --> 00:28:58,240
into this

00:28:56,399 --> 00:28:59,440
little subnet here so a very one

00:28:58,240 --> 00:29:01,440
unfamiliar this

00:28:59,440 --> 00:29:02,880
uh node network on the right is going to

00:29:01,440 --> 00:29:04,799
try and match the same network on the

00:29:02,880 --> 00:29:07,360
left

00:29:04,799 --> 00:29:07,919
uh this is this is a vdb ax sop which is

00:29:07,360 --> 00:29:10,000
part of the

00:29:07,919 --> 00:29:12,159
um part of the software that we're

00:29:10,000 --> 00:29:13,200
that's publicly available um on the

00:29:12,159 --> 00:29:14,559
right here you can

00:29:13,200 --> 00:29:17,120
maybe just make out the kind of code

00:29:14,559 --> 00:29:18,559
that's being run uh which is this node

00:29:17,120 --> 00:29:20,799
that's not attached to anything

00:29:18,559 --> 00:29:22,320
and this just simply demonstrates how a

00:29:20,799 --> 00:29:23,360
naive implementation or a naive

00:29:22,320 --> 00:29:25,840
implementation of

00:29:23,360 --> 00:29:27,200
a mean filter which is accumulating

00:29:25,840 --> 00:29:28,640
neighboring values and forming an

00:29:27,200 --> 00:29:30,080
average and then writing to the original

00:29:28,640 --> 00:29:32,880
level sets

00:29:30,080 --> 00:29:33,760
on the left here instead we have these

00:29:32,880 --> 00:29:35,760
three ax

00:29:33,760 --> 00:29:38,399
nodes which are chained together which

00:29:35,760 --> 00:29:41,760
perform individual mean filters across

00:29:38,399 --> 00:29:44,159
this vdb and are gathering uh

00:29:41,760 --> 00:29:46,080
voxels in a particular axis summing them

00:29:44,159 --> 00:29:47,440
together averaging them and writing them

00:29:46,080 --> 00:29:49,360
back to the level sets

00:29:47,440 --> 00:29:50,480
and the idea here is that that that no

00:29:49,360 --> 00:29:52,559
chain on the

00:29:50,480 --> 00:29:55,679
left matches the result exactly which

00:29:52,559 --> 00:29:58,159
hopefully you can see now

00:29:55,679 --> 00:29:58,960
so this isn't a particularly uh perhaps

00:29:58,159 --> 00:30:01,600
not a

00:29:58,960 --> 00:30:02,559
too interesting example in terms of new

00:30:01,600 --> 00:30:04,159
functionality

00:30:02,559 --> 00:30:06,240
but hopefully you can immediately see

00:30:04,159 --> 00:30:07,919
how just by accessing

00:30:06,240 --> 00:30:09,679
the different kernels the different uh

00:30:07,919 --> 00:30:11,760
ways that you're looping over voxels

00:30:09,679 --> 00:30:13,039
you could manipulate this mean filter

00:30:11,760 --> 00:30:15,520
and uh

00:30:13,039 --> 00:30:17,200
change uh perhaps the width of one axis

00:30:15,520 --> 00:30:20,000
the scaling of an axis or

00:30:17,200 --> 00:30:23,840
incorporate a whole different type of uh

00:30:20,000 --> 00:30:23,840
voxel lookup pattern

00:30:24,960 --> 00:30:28,880
lastly just to cover where we're looking

00:30:26,960 --> 00:30:30,640
to take the project

00:30:28,880 --> 00:30:31,919
so the first major thing is point volume

00:30:30,640 --> 00:30:34,080
interaction

00:30:31,919 --> 00:30:35,520
currently with ax you have to only

00:30:34,080 --> 00:30:38,399
execute over

00:30:35,520 --> 00:30:39,440
vdb numerical volumes or vdb points this

00:30:38,399 --> 00:30:41,120
is a

00:30:39,440 --> 00:30:42,960
bit annoying because with things like

00:30:41,120 --> 00:30:44,399
sampling it's such a common operation

00:30:42,960 --> 00:30:46,399
for you to be able to sample

00:30:44,399 --> 00:30:47,600
from a points position onto another

00:30:46,399 --> 00:30:49,200
points attribute

00:30:47,600 --> 00:30:51,279
um so this is this is definitely i think

00:30:49,200 --> 00:30:52,960
our number one priority uh to be able to

00:30:51,279 --> 00:30:56,399
incorporate different volume

00:30:52,960 --> 00:30:59,919
uh functions with points and vice versa

00:30:56,399 --> 00:31:00,799
uh a metadata executable so executables

00:30:59,919 --> 00:31:03,760
in ax

00:31:00,799 --> 00:31:04,159
are linked to the geometry that they're

00:31:03,760 --> 00:31:06,159
uh

00:31:04,159 --> 00:31:08,080
accessing so the two current executables

00:31:06,159 --> 00:31:11,120
we have are points and volumes

00:31:08,080 --> 00:31:14,080
a metadata executable would allow you to

00:31:11,120 --> 00:31:15,519
iterate once over each individual vdb

00:31:14,080 --> 00:31:17,840
still provide you read and write access

00:31:15,519 --> 00:31:19,519
to that vdb but also allow you to write

00:31:17,840 --> 00:31:21,519
completely arbitrary metadata to the

00:31:19,519 --> 00:31:24,080
grid which supports metadata

00:31:21,519 --> 00:31:28,080
uh read from that metadata and perform

00:31:24,080 --> 00:31:28,080
wholesale operations across a vdb

00:31:28,159 --> 00:31:31,600
uh user functions so we spent a long

00:31:30,880 --> 00:31:34,320
time

00:31:31,600 --> 00:31:36,080
uh improving the c plus plus api for

00:31:34,320 --> 00:31:37,919
developers to be able to customize

00:31:36,080 --> 00:31:40,320
how you can inject c plus bindings into

00:31:37,919 --> 00:31:43,039
ax uh so that's come a long way

00:31:40,320 --> 00:31:43,440
and the reason we did that is because

00:31:43,039 --> 00:31:45,200
that's

00:31:43,440 --> 00:31:47,120
one of our first ports of call to be

00:31:45,200 --> 00:31:48,559
able to extend ax's functionality just

00:31:47,120 --> 00:31:49,360
very quickly we have a complicated c

00:31:48,559 --> 00:31:51,200
plus plus

00:31:49,360 --> 00:31:52,799
method but if it's purely mathematical

00:31:51,200 --> 00:31:54,000
we can quickly inject that into ax and

00:31:52,799 --> 00:31:56,000
that becomes available

00:31:54,000 --> 00:31:57,519
however what you can't do is customize

00:31:56,000 --> 00:31:58,960
and define user front-end functions

00:31:57,519 --> 00:32:01,360
currently so that's that's definitely on

00:31:58,960 --> 00:32:04,559
the roadmap

00:32:01,360 --> 00:32:07,600
python bindings we python bindings do

00:32:04,559 --> 00:32:09,519
exist in the standalone repository but

00:32:07,600 --> 00:32:11,360
uh they probably won't be part of the

00:32:09,519 --> 00:32:14,640
original merge into the

00:32:11,360 --> 00:32:16,480
uh into the openvdb repository

00:32:14,640 --> 00:32:18,080
uh they need a bit of work but they do

00:32:16,480 --> 00:32:20,880
allow you to run ax

00:32:18,080 --> 00:32:22,799
through python so you can use the python

00:32:20,880 --> 00:32:25,039
library that b2b provides to read in

00:32:22,799 --> 00:32:26,000
uh vdb grid you can use these pipe

00:32:25,039 --> 00:32:29,120
bindings to

00:32:26,000 --> 00:32:31,519
then call ax from python

00:32:29,120 --> 00:32:32,640
and finally uh nanobeat nano bdb support

00:32:31,519 --> 00:32:34,880
as as ken has

00:32:32,640 --> 00:32:36,880
announced we would love to be able to

00:32:34,880 --> 00:32:37,600
instead of targeting points and volumes

00:32:36,880 --> 00:32:39,519
in the cpu

00:32:37,600 --> 00:32:40,720
target nano vdb uh back-end kernels on

00:32:39,519 --> 00:32:42,399
the gpu

00:32:40,720 --> 00:32:43,840
ix as far as the language is concerned

00:32:42,399 --> 00:32:45,440
wouldn't change you'd still write the

00:32:43,840 --> 00:32:45,760
exact same code but this would allow you

00:32:45,440 --> 00:32:48,559
to

00:32:45,760 --> 00:32:51,760
manipulate and write custom kernels for

00:32:48,559 --> 00:32:51,760
nano vdb data types

00:32:52,240 --> 00:32:57,760
and that's that's everything yeah so

00:32:56,000 --> 00:32:59,600
if you have any questions please let me

00:32:57,760 --> 00:33:00,320
know um and if anything doesn't get

00:32:59,600 --> 00:33:02,159
answered

00:33:00,320 --> 00:33:03,600
feel free to uh email this the

00:33:02,159 --> 00:33:04,960
developers here

00:33:03,600 --> 00:33:07,039
uh i just want to give a quick shout out

00:33:04,960 --> 00:33:07,519
to rich jones as well i think he's on

00:33:07,039 --> 00:33:09,760
the

00:33:07,519 --> 00:33:11,039
in my me might be listening uh but he

00:33:09,760 --> 00:33:11,519
was also a big part of this entire

00:33:11,039 --> 00:33:12,960
project

00:33:11,519 --> 00:33:14,720
and is continuously working on it as

00:33:12,960 --> 00:33:16,960
well in terms of

00:33:14,720 --> 00:33:19,279
accessing the projects it's in a bit of

00:33:16,960 --> 00:33:22,000
a weird transition because we're still

00:33:19,279 --> 00:33:23,519
getting it into vdb you can access it as

00:33:22,000 --> 00:33:26,000
a standalone project through

00:33:23,519 --> 00:33:27,120
the dnx github or you can access it as a

00:33:26,000 --> 00:33:28,480
feature branch

00:33:27,120 --> 00:33:30,720
through the academy software

00:33:28,480 --> 00:33:33,440
foundation's fork of openvdb

00:33:30,720 --> 00:33:34,000
where it will um where will be migrated

00:33:33,440 --> 00:33:36,240
to

00:33:34,000 --> 00:33:37,279
the dna repository will be retired once

00:33:36,240 --> 00:33:41,679
that's once that's

00:33:37,279 --> 00:33:42,960
completed that's that's everything um

00:33:41,679 --> 00:33:45,039
so i guess now we can move on to

00:33:42,960 --> 00:33:46,000
questions i'm gonna before we do that

00:33:45,039 --> 00:33:48,559
what i'm gonna do is

00:33:46,000 --> 00:33:49,760
pull up a more generic roadmap for

00:33:48,559 --> 00:33:51,760
openvdb

00:33:49,760 --> 00:33:53,519
i should probably i should probably not

00:33:51,760 --> 00:33:56,559
call this a robot this is more of just

00:33:53,519 --> 00:33:58,559
a bunch of things that we are we have

00:33:56,559 --> 00:34:01,519
discussed over the last few years

00:33:58,559 --> 00:34:03,919
we know there is interest in and we

00:34:01,519 --> 00:34:06,240
would love to pursue further

00:34:03,919 --> 00:34:07,600
so as well as questions if anyone has

00:34:06,240 --> 00:34:09,040
any comments any thoughts

00:34:07,600 --> 00:34:10,960
if there's enough if there are things

00:34:09,040 --> 00:34:11,919
here that you would like to see

00:34:10,960 --> 00:34:14,480
or if you just want to get something a

00:34:11,919 --> 00:34:16,639
plus one please just uh

00:34:14,480 --> 00:34:20,000
yeah please put it in the chat um but

00:34:16,639 --> 00:34:24,000
yeah i'll hand over to questions now

00:34:20,000 --> 00:34:27,679
let's have a look cool

00:34:24,000 --> 00:34:31,040
uh so i think the first

00:34:27,679 --> 00:34:35,520
question uh is from

00:34:31,040 --> 00:34:38,240
an anonymous uh teddy it asks about

00:34:35,520 --> 00:34:38,960
i'm assuming this is related to nanowriv

00:34:38,240 --> 00:34:43,119
that's about

00:34:38,960 --> 00:34:45,280
um with gl if webgl is supported um

00:34:43,119 --> 00:34:46,560
it isn't today but it's actually one of

00:34:45,280 --> 00:34:48,720
the things that uh

00:34:46,560 --> 00:34:50,000
we're looking at so that's a good chance

00:34:48,720 --> 00:34:54,560
that it will be

00:34:50,000 --> 00:34:54,560
uh uh

00:34:54,960 --> 00:34:58,640
oh yeah actually i i forgot there's

00:34:56,960 --> 00:35:01,680
there's one name that i forgot to

00:34:58,640 --> 00:35:02,720
to add to my uh list of acknowledgements

00:35:01,680 --> 00:35:05,760
so

00:35:02,720 --> 00:35:06,640
uh yomning who i'm i'm might actually be

00:35:05,760 --> 00:35:08,720
butchering your name

00:35:06,640 --> 00:35:11,119
or in your promising nation i'm sorry uh

00:35:08,720 --> 00:35:13,920
but he's he provided the um

00:35:11,119 --> 00:35:15,680
the softbody simulation uh that you saw

00:35:13,920 --> 00:35:18,960
in the in the beginning of the nov

00:35:15,680 --> 00:35:21,760
presentation using tai chi so uh

00:35:18,960 --> 00:35:22,240
he has also added uh support for nano

00:35:21,760 --> 00:35:26,720
vtb

00:35:22,240 --> 00:35:30,000
in in tai chi um

00:35:26,720 --> 00:35:31,760
let's can can see

00:35:30,000 --> 00:35:33,280
just see the uh roadblock right now is

00:35:31,760 --> 00:35:36,160
that okay

00:35:33,280 --> 00:35:37,520
yeah okay okay you want to talk about

00:35:36,160 --> 00:35:38,640
that or do you want to go through

00:35:37,520 --> 00:35:40,560
[Music]

00:35:38,640 --> 00:35:42,160
i just wanted to make sure that uh that

00:35:40,560 --> 00:35:43,599
that you were seeing just the roadmap

00:35:42,160 --> 00:35:45,680
so i can bring up the questions as well

00:35:43,599 --> 00:35:50,000
yeah feel free to

00:35:45,680 --> 00:35:52,000
cool um oh cool yeah so i can i can

00:35:50,000 --> 00:35:53,599
see so the next one is uh how ax

00:35:52,000 --> 00:35:54,320
compares against the tai chi programming

00:35:53,599 --> 00:35:55,599
language

00:35:54,320 --> 00:35:58,640
is there any comparison against it in

00:35:55,599 --> 00:36:01,040
terms of performance um

00:35:58,640 --> 00:36:02,560
so i think that's a good question there

00:36:01,040 --> 00:36:06,240
are two very different things

00:36:02,560 --> 00:36:07,760
so tai chi is is a is a high level

00:36:06,240 --> 00:36:09,760
uh programming language for for

00:36:07,760 --> 00:36:12,560
simulation specifically uh whereas

00:36:09,760 --> 00:36:15,119
nanovdb today is

00:36:12,560 --> 00:36:16,640
um specifically for vdb and it's

00:36:15,119 --> 00:36:17,359
specifically targeting real-time

00:36:16,640 --> 00:36:20,400
rendering

00:36:17,359 --> 00:36:23,200
um in in a way that's agnostic

00:36:20,400 --> 00:36:24,800
so it's it's a little bit like apples

00:36:23,200 --> 00:36:27,680
and bananas

00:36:24,800 --> 00:36:30,320
you know it it's it's it's possible that

00:36:27,680 --> 00:36:33,200
they will overlap more in the future but

00:36:30,320 --> 00:36:33,839
today i think it's it's very difficult

00:36:33,200 --> 00:36:36,000
because

00:36:33,839 --> 00:36:37,119
because nano b2j cannot do the

00:36:36,000 --> 00:36:40,240
simulations that

00:36:37,119 --> 00:36:40,880
um that tai chi can do and tai chi can't

00:36:40,240 --> 00:36:42,880
do the

00:36:40,880 --> 00:36:43,920
the real-time rendering that uh nanov

00:36:42,880 --> 00:36:46,320
can do so

00:36:43,920 --> 00:36:47,280
yeah i don't really know how to answer

00:36:46,320 --> 00:36:50,560
that question

00:36:47,280 --> 00:36:53,119
um but but if you're interested in

00:36:50,560 --> 00:36:54,400
in benchmark specifically uh the blog

00:36:53,119 --> 00:36:57,200
post that i

00:36:54,400 --> 00:36:58,560
mentioned the one that's hosted on uh

00:36:57,200 --> 00:37:00,000
nvidia's website actually has some

00:36:58,560 --> 00:37:02,320
benchmarks

00:37:00,000 --> 00:37:03,280
and the repository itself has several

00:37:02,320 --> 00:37:06,839
benchmark tests

00:37:03,280 --> 00:37:10,240
that you can you can try

00:37:06,839 --> 00:37:10,720
and in terms of ax in comparison to tai

00:37:10,240 --> 00:37:12,000
chi

00:37:10,720 --> 00:37:14,320
it's not something we've actually

00:37:12,000 --> 00:37:15,760
investigated um

00:37:14,320 --> 00:37:17,440
tai chi as far as i understand it

00:37:15,760 --> 00:37:18,400
attempts to solve a similar but slightly

00:37:17,440 --> 00:37:22,480
different problem

00:37:18,400 --> 00:37:23,520
ax is more designed to um manipulate

00:37:22,480 --> 00:37:26,400
attributes

00:37:23,520 --> 00:37:27,280
run this specific kernels per attribute

00:37:26,400 --> 00:37:30,320
on a very

00:37:27,280 --> 00:37:31,760
uh on a more granular level whereas tai

00:37:30,320 --> 00:37:32,640
chi you're able to build entire solar

00:37:31,760 --> 00:37:35,520
frameworks

00:37:32,640 --> 00:37:36,160
out of um i i imagine there is some

00:37:35,520 --> 00:37:40,000
crossover

00:37:36,160 --> 00:37:42,000
and i know that tai chi also um uh

00:37:40,000 --> 00:37:43,760
it is targeting similar you know compile

00:37:42,000 --> 00:37:45,200
time parallel performance

00:37:43,760 --> 00:37:47,119
uh so i'd like to think that they're

00:37:45,200 --> 00:37:49,200
very similar because the in our

00:37:47,119 --> 00:37:52,079
benchmarking against cbos plus code

00:37:49,200 --> 00:37:53,520
we come out very very very similar so if

00:37:52,079 --> 00:37:56,720
tai chi is doing the same thing then i'm

00:37:53,520 --> 00:37:56,720
not sure there'll be too much difference

00:37:57,200 --> 00:38:05,119
right uh i see that's a question about

00:38:00,880 --> 00:38:07,839
support for metal um

00:38:05,119 --> 00:38:09,040
and it's it's the same answer it's not

00:38:07,839 --> 00:38:11,920
in there today

00:38:09,040 --> 00:38:12,640
but uh we're working on it definitely

00:38:11,920 --> 00:38:15,440
should be

00:38:12,640 --> 00:38:17,200
uh supportive so so the goal the goal is

00:38:15,440 --> 00:38:18,880
really to try and support us

00:38:17,200 --> 00:38:20,400
as many of these apis as possible

00:38:18,880 --> 00:38:21,760
without you know

00:38:20,400 --> 00:38:24,079
there are some apis that have some

00:38:21,760 --> 00:38:27,440
restrictions uh that are

00:38:24,079 --> 00:38:30,880
tough to work around i believe metal has

00:38:27,440 --> 00:38:34,880
a limitation in terms of 64-bit uh ins

00:38:30,880 --> 00:38:37,839
and floats um but we can probably

00:38:34,880 --> 00:38:38,560
find a work around that um and and only

00:38:37,839 --> 00:38:40,960
support

00:38:38,560 --> 00:38:42,079
single person grids i don't know but it

00:38:40,960 --> 00:38:47,839
is something we're working on

00:38:42,079 --> 00:38:47,839
for sure um

00:38:48,240 --> 00:38:52,000
make feel free to pitch in oh yeah sure

00:38:51,200 --> 00:38:54,640
sorry um

00:38:52,000 --> 00:38:56,480
so one way uh is the nano vdb viewer

00:38:54,640 --> 00:38:59,920
available to download is open source

00:38:56,480 --> 00:39:00,240
yes to both yes yes it is uh you have to

00:38:59,920 --> 00:39:01,359
check

00:39:00,240 --> 00:39:03,119
it's like it currently exists as a

00:39:01,359 --> 00:39:03,760
feature branch in the economy software

00:39:03,119 --> 00:39:06,960
foundations

00:39:03,760 --> 00:39:08,240
uh over the repository right

00:39:06,960 --> 00:39:11,680
actually i think i think what we'll do

00:39:08,240 --> 00:39:14,720
is we will make a little post

00:39:11,680 --> 00:39:17,359
on the openvdb website

00:39:14,720 --> 00:39:18,960
uh sort of announcing that nanovdb is

00:39:17,359 --> 00:39:20,720
available but also tell you how to

00:39:18,960 --> 00:39:25,440
access it how to get it

00:39:20,720 --> 00:39:25,440
it's quite simple but we'll spell it out

00:39:27,280 --> 00:39:33,520
what else lots of questions on nanovdb

00:39:30,320 --> 00:39:36,800
uh these are mainly for you ken right

00:39:33,520 --> 00:39:37,520
so i think common a common thread in

00:39:36,800 --> 00:39:39,280
these questions

00:39:37,520 --> 00:39:40,640
are sort of related to simulation like

00:39:39,280 --> 00:39:43,920
will nanovdb

00:39:40,640 --> 00:39:47,119
be able to do simulations in the future

00:39:43,920 --> 00:39:50,480
um that's a that's a good question

00:39:47,119 --> 00:39:52,960
uh so i i should emphasize

00:39:50,480 --> 00:39:54,640
that the data structure itself the

00:39:52,960 --> 00:39:55,119
linearization when you go from an open

00:39:54,640 --> 00:39:58,560
vdb

00:39:55,119 --> 00:40:00,880
to a nanovdb is actually

00:39:58,560 --> 00:40:02,560
it's sort of a snapshot so it's not a

00:40:00,880 --> 00:40:05,680
dynamic data structure today

00:40:02,560 --> 00:40:09,359
on the gpu so we will have to

00:40:05,680 --> 00:40:11,040
to add changes to support dynamic trees

00:40:09,359 --> 00:40:12,560
um that's not to say that it's

00:40:11,040 --> 00:40:14,960
impossible um

00:40:12,560 --> 00:40:17,440
and i should also for full disclosure

00:40:14,960 --> 00:40:17,920
say that nvidia is actually working on

00:40:17,440 --> 00:40:20,880
something

00:40:17,920 --> 00:40:22,079
of this nature um but i can't really say

00:40:20,880 --> 00:40:25,359
much more than that

00:40:22,079 --> 00:40:26,000
so it is coming in in one form or

00:40:25,359 --> 00:40:29,760
another

00:40:26,000 --> 00:40:31,200
um but today uh the only thing you can

00:40:29,760 --> 00:40:35,760
use that nano for

00:40:31,200 --> 00:40:38,640
are things that involve static trees um

00:40:35,760 --> 00:40:39,440
so as i said ray tracing is sort of the

00:40:38,640 --> 00:40:41,920
the

00:40:39,440 --> 00:40:42,960
prime example but actually the way that

00:40:41,920 --> 00:40:45,359
this is used

00:40:42,960 --> 00:40:46,880
in houdini today is for collision

00:40:45,359 --> 00:40:48,480
detection so

00:40:46,880 --> 00:40:51,280
imagine that you have a class

00:40:48,480 --> 00:40:52,960
formulation or some character simulation

00:40:51,280 --> 00:40:55,119
and you're actually representing the

00:40:52,960 --> 00:40:58,240
collision geometry as an implicit

00:40:55,119 --> 00:40:58,560
um sine distance field and that's that's

00:40:58,240 --> 00:41:01,440
a

00:40:58,560 --> 00:41:01,839
brilliant um use case for nano db right

00:41:01,440 --> 00:41:04,240
because

00:41:01,839 --> 00:41:05,520
all you have to do is you do you do very

00:41:04,240 --> 00:41:08,000
fast queries

00:41:05,520 --> 00:41:08,880
into the volume data structure to

00:41:08,000 --> 00:41:10,800
compute

00:41:08,880 --> 00:41:13,200
inside outside and closest point

00:41:10,800 --> 00:41:13,200
transform

00:41:14,800 --> 00:41:18,560
so so oh sorry go ahead that's right i

00:41:17,680 --> 00:41:19,680
was going to

00:41:18,560 --> 00:41:22,319
address another question if you were

00:41:19,680 --> 00:41:24,800
going to carry on yeah

00:41:22,319 --> 00:41:26,240
yeah so one uh is there any example i

00:41:24,800 --> 00:41:28,240
know yeah is there any example of usage

00:41:26,240 --> 00:41:29,839
of openvdb on hpc cluster using

00:41:28,240 --> 00:41:31,119
distributed memory parallelization or

00:41:29,839 --> 00:41:34,400
hybrid open

00:41:31,119 --> 00:41:35,599
uh mpi tbb um

00:41:34,400 --> 00:41:36,960
i don't think there's an example that i

00:41:35,599 --> 00:41:38,079
can point to but it's something that

00:41:36,960 --> 00:41:40,000
we're very interested in

00:41:38,079 --> 00:41:42,160
pursuing uh i think it appears in the

00:41:40,000 --> 00:41:45,119
roadmap it's it's been brought up before

00:41:42,160 --> 00:41:46,079
um using openmpi specific specifically

00:41:45,119 --> 00:41:49,040
for distributed

00:41:46,079 --> 00:41:50,800
bdb tasks would be uh very interesting

00:41:49,040 --> 00:41:53,119
to pursue

00:41:50,800 --> 00:41:54,079
uh it would still obviously be parallel

00:41:53,119 --> 00:41:56,319
under the hood

00:41:54,079 --> 00:41:58,079
um each individual cluster would have uh

00:41:56,319 --> 00:42:00,400
would would be able to leverage

00:41:58,079 --> 00:42:02,079
the overview these multi-threaded tools

00:42:00,400 --> 00:42:03,520
but we'd look to distribute the work

00:42:02,079 --> 00:42:05,599
um with some kind of you know halo

00:42:03,520 --> 00:42:06,640
communication jeff is you gonna put

00:42:05,599 --> 00:42:09,200
chiming yeah

00:42:06,640 --> 00:42:10,400
yeah because uh here's an example dan um

00:42:09,200 --> 00:42:12,720
added graph

00:42:10,400 --> 00:42:14,800
a few years back of the distributed

00:42:12,720 --> 00:42:18,160
fluid solver based on vdb

00:42:14,800 --> 00:42:19,760
and likewise um there's a toolkit

00:42:18,160 --> 00:42:24,560
example in houdini now

00:42:19,760 --> 00:42:26,400
of doing uh sliced distribution of vdbs

00:42:24,560 --> 00:42:30,000
yeah so those are two examples of people

00:42:26,400 --> 00:42:32,079
trying to do distribution

00:42:30,000 --> 00:42:34,000
so the short story is that there are

00:42:32,079 --> 00:42:37,040
there are several examples of people

00:42:34,000 --> 00:42:38,560
that have done it and are doing it uh

00:42:37,040 --> 00:42:39,920
but it's not part of the distribution

00:42:38,560 --> 00:42:41,200
yet and that's that's actually what's

00:42:39,920 --> 00:42:44,079
listed under the

00:42:41,200 --> 00:42:44,400
major proposals on the roadmap uh i

00:42:44,079 --> 00:42:46,720
think

00:42:44,400 --> 00:42:47,680
nick is trying to see if he can possibly

00:42:46,720 --> 00:42:50,000
share

00:42:47,680 --> 00:42:51,599
some of the some of the code that you

00:42:50,000 --> 00:42:54,880
guys are using at d-neck

00:42:51,599 --> 00:42:56,960
that um yeah api

00:42:54,880 --> 00:42:58,640
yeah so so my experience with this is

00:42:56,960 --> 00:43:01,040
specifically of open mpi and it

00:42:58,640 --> 00:43:01,680
is completely possible it is it's a it's

00:43:01,040 --> 00:43:04,960
a huge

00:43:01,680 --> 00:43:06,480
task uh so and it would be

00:43:04,960 --> 00:43:08,000
to design a kind of a generic framework

00:43:06,480 --> 00:43:12,160
to work with openvdb

00:43:08,000 --> 00:43:13,680
and and all of its tools as well so uh

00:43:12,160 --> 00:43:16,160
but if if it's good to know that other

00:43:13,680 --> 00:43:18,319
people are also interested in this

00:43:16,160 --> 00:43:18,319
right

00:43:23,920 --> 00:43:28,400
can is there any other yeah there's a

00:43:26,160 --> 00:43:31,599
question about what version of dslr

00:43:28,400 --> 00:43:34,800
uh does an nwdb require actually

00:43:31,599 --> 00:43:36,560
i i don't know i can definitely find out

00:43:34,800 --> 00:43:39,119
but i don't know so

00:43:36,560 --> 00:43:40,079
uh i encourage whoever submitted that to

00:43:39,119 --> 00:43:42,240
maybe shoot me

00:43:40,079 --> 00:43:45,040
an email directly and i promise to find

00:43:42,240 --> 00:43:48,319
out for you um

00:43:45,040 --> 00:43:52,000
we'll write for you we'll we'll know

00:43:48,319 --> 00:43:54,240
uh there's one uh is there any example

00:43:52,000 --> 00:43:56,000
how uh how to extract sharp features

00:43:54,240 --> 00:43:58,400
when doing mesh to volume back to volume

00:43:56,000 --> 00:43:58,400
to mesh

00:43:58,960 --> 00:44:03,920
oh is this um

00:44:02,240 --> 00:44:05,760
is this part of the houdini toolkit is

00:44:03,920 --> 00:44:08,079
this what we pulled up before yeah

00:44:05,760 --> 00:44:09,200
yeah i think it is the best example we

00:44:08,079 --> 00:44:12,800
have is the

00:44:09,200 --> 00:44:16,400
um houdini open vdb houdini um

00:44:12,800 --> 00:44:17,760
uh bdb2 polygons node which i think has

00:44:16,400 --> 00:44:19,520
all the code in

00:44:17,760 --> 00:44:21,040
like open source there for how you have

00:44:19,520 --> 00:44:21,520
to do it it calls into the functions all

00:44:21,040 --> 00:44:22,800
the time

00:44:21,520 --> 00:44:24,240
so you'd have to figure out the

00:44:22,800 --> 00:44:25,359
equivalent for polygons are but you'd

00:44:24,240 --> 00:44:26,800
have to do that anyways forever your

00:44:25,359 --> 00:44:28,240
local polygon libraries

00:44:26,800 --> 00:44:30,079
but we did recognize this is something

00:44:28,240 --> 00:44:31,760
missing from the uh

00:44:30,079 --> 00:44:33,839
default toolkit ideally there would be

00:44:31,760 --> 00:44:34,480
something that does it entirely in dvd

00:44:33,839 --> 00:44:35,760
land

00:44:34,480 --> 00:44:38,079
if you make something like he's

00:44:35,760 --> 00:44:41,040
contributed to the project

00:44:38,079 --> 00:44:43,359
i think i think the main problem is that

00:44:41,040 --> 00:44:47,040
the openvp library doesn't really have

00:44:43,359 --> 00:44:50,240
a very sophisticated mesh data structure

00:44:47,040 --> 00:44:53,440
so it's it's not easy for us to

00:44:50,240 --> 00:44:53,760
provide an example outside of a dcc that

00:44:53,440 --> 00:44:58,000
has

00:44:53,760 --> 00:45:00,720
its own mesh data structure like houdini

00:44:58,000 --> 00:45:02,880
but but the idea itself is actually

00:45:00,720 --> 00:45:05,839
quite straightforward

00:45:02,880 --> 00:45:07,040
the idea is that you use you use the

00:45:05,839 --> 00:45:10,400
original

00:45:07,040 --> 00:45:13,440
um mesh um

00:45:10,400 --> 00:45:16,079
to sort of project the the the sharp

00:45:13,440 --> 00:45:18,000
features of the new mesh

00:45:16,079 --> 00:45:19,760
onto and that's what allows you to

00:45:18,000 --> 00:45:21,119
preserve these very sharp

00:45:19,760 --> 00:45:22,960
sharp corners when you're doing let's

00:45:21,119 --> 00:45:25,280
say um

00:45:22,960 --> 00:45:26,160
when you're doing cst operations uh

00:45:25,280 --> 00:45:28,800
let's say you

00:45:26,160 --> 00:45:30,560
you're breaking up a structure um and

00:45:28,800 --> 00:45:33,200
you want to have a swap frame

00:45:30,560 --> 00:45:34,480
so you want to pre-fracture everything

00:45:33,200 --> 00:45:36,160
but you want to do it in a way that's

00:45:34,480 --> 00:45:38,400
sort of seamless

00:45:36,160 --> 00:45:39,680
and that's a great application for this

00:45:38,400 --> 00:45:43,359
so you do your your

00:45:39,680 --> 00:45:45,839
volumetric csg that that on in itself

00:45:43,359 --> 00:45:47,839
actually will create increases but then

00:45:45,839 --> 00:45:51,040
this mesh extraction tool

00:45:47,839 --> 00:45:54,160
will allow you to project the new mesh

00:45:51,040 --> 00:45:55,839
onto the original mesh

00:45:54,160 --> 00:45:58,079
such that these creases are completely

00:45:55,839 --> 00:45:58,079
gone

00:45:58,319 --> 00:46:02,319
but we we can try and see if we can if

00:46:00,240 --> 00:46:06,000
we can provide an example

00:46:02,319 --> 00:46:09,200
in openvp itself it's just not

00:46:06,000 --> 00:46:13,119
so straightforward and um question any

00:46:09,200 --> 00:46:16,640
plans to extend nanovdb to multi gpu

00:46:13,119 --> 00:46:19,520
yes definitely definitely

00:46:16,640 --> 00:46:19,520
cool easy answer

00:46:19,920 --> 00:46:23,040
um i think i've i've mentioned this

00:46:22,160 --> 00:46:25,280
before but i'll

00:46:23,040 --> 00:46:26,800
say it one more time so so what we're

00:46:25,280 --> 00:46:29,599
releasing today

00:46:26,800 --> 00:46:31,599
is is a better release right it's not

00:46:29,599 --> 00:46:33,200
it's not a production release

00:46:31,599 --> 00:46:34,720
you're absolutely encouraged to pick it

00:46:33,200 --> 00:46:38,079
up and you know

00:46:34,720 --> 00:46:40,800
kick tires and give us feedback um

00:46:38,079 --> 00:46:42,319
and as i mentioned houdini is already

00:46:40,800 --> 00:46:44,640
going to ship with it

00:46:42,319 --> 00:46:46,960
but we will be making changes we will be

00:46:44,640 --> 00:46:49,359
making improvements so

00:46:46,960 --> 00:46:50,560
yeah let us know if there are things

00:46:49,359 --> 00:46:51,280
things that are missing that you'd like

00:46:50,560 --> 00:46:55,599
to see

00:46:51,280 --> 00:46:56,319
added to it and then hopefully hopefully

00:46:55,599 --> 00:46:57,920
it will be

00:46:56,319 --> 00:47:00,960
in a production release before the end

00:46:57,920 --> 00:47:03,440
of this year that's at least my goal

00:47:00,960 --> 00:47:04,880
does uh nano b2b currently support iso

00:47:03,440 --> 00:47:07,440
surface extraction and level set

00:47:04,880 --> 00:47:11,359
conversion on the gpu

00:47:07,440 --> 00:47:14,319
no it does not um

00:47:11,359 --> 00:47:16,000
but again that's that is something that

00:47:14,319 --> 00:47:18,319
we've talked about something

00:47:16,000 --> 00:47:21,599
we're looking into but whether it will

00:47:18,319 --> 00:47:25,040
be in nanovdb and or some other gpu

00:47:21,599 --> 00:47:27,920
library i don't know but i think it's

00:47:25,040 --> 00:47:31,040
fair to say it's coming

00:47:27,920 --> 00:47:34,160
and i think you addressed the glsl

00:47:31,040 --> 00:47:35,520
question one sure but uh uh

00:47:34,160 --> 00:47:37,760
next one was as far as i understand

00:47:35,520 --> 00:47:41,839
nanovdb is focused on ray tracing would

00:47:37,760 --> 00:47:41,839
3d printing benefit from that big b2

00:47:42,160 --> 00:47:48,880
um that's a a good question i

00:47:45,760 --> 00:47:50,960
it depends on what what what you use it

00:47:48,880 --> 00:47:53,839
for like if you're actually manipulating

00:47:50,960 --> 00:47:55,359
the volume uh changing the tree

00:47:53,839 --> 00:47:59,280
structure

00:47:55,359 --> 00:48:01,839
probably not uh if you're

00:47:59,280 --> 00:48:03,280
obviously if if anything that you're

00:48:01,839 --> 00:48:05,839
you're using a static

00:48:03,280 --> 00:48:07,760
sparse volume for would be a great

00:48:05,839 --> 00:48:10,160
candidate for for nanoadb

00:48:07,760 --> 00:48:11,920
um but if you're if you're dynamically

00:48:10,160 --> 00:48:15,200
modifying it

00:48:11,920 --> 00:48:17,920
uh probably not i need to

00:48:15,200 --> 00:48:19,760
clarify it's not about ray tracing

00:48:17,920 --> 00:48:21,680
that's how it was originally

00:48:19,760 --> 00:48:23,280
discussed but it's actually very much

00:48:21,680 --> 00:48:26,079
just about having the sparse

00:48:23,280 --> 00:48:28,079
volume on the gpu and um so like

00:48:26,079 --> 00:48:29,440
everything we use was not ray tracing

00:48:28,079 --> 00:48:31,119
and so i could think of a lot of things

00:48:29,440 --> 00:48:32,880
for 3d printing that would work

00:48:31,119 --> 00:48:35,359
right off the bat without having to

00:48:32,880 --> 00:48:38,000
manipulate topologies to work with it

00:48:35,359 --> 00:48:40,160
right right oh that's true that is true

00:48:38,000 --> 00:48:41,839
and in fact jeff you

00:48:40,160 --> 00:48:43,440
you're the first one to sort of break

00:48:41,839 --> 00:48:45,839
break the tradition and use it for

00:48:43,440 --> 00:48:49,839
something completely different

00:48:45,839 --> 00:48:49,839
uh your collision detection right

00:48:50,400 --> 00:48:54,640
got a got a good one here uh where's the

00:48:52,559 --> 00:48:55,839
best forum location is it the google

00:48:54,640 --> 00:48:58,880
forum group or

00:48:55,839 --> 00:49:02,800
via the aswf that's a great question

00:48:58,880 --> 00:49:05,760
we ask ourselves that every week

00:49:02,800 --> 00:49:05,760
it's the google forum

00:49:07,200 --> 00:49:10,480
i i think the google forum we've been

00:49:09,200 --> 00:49:13,520
looking at as uh

00:49:10,480 --> 00:49:15,119
more of an open discussion about uh you

00:49:13,520 --> 00:49:16,000
know high level discussion about tools

00:49:15,119 --> 00:49:18,960
and features

00:49:16,000 --> 00:49:18,960
whereas um

00:49:19,280 --> 00:49:22,640
again we we do use github issues as well

00:49:21,040 --> 00:49:24,000
for more specific software

00:49:22,640 --> 00:49:26,000
issue uh specific issues with the

00:49:24,000 --> 00:49:29,119
software but yeah i don't think we're

00:49:26,000 --> 00:49:30,640
currently using the aswf abs developers

00:49:29,119 --> 00:49:32,000
for too much discussion

00:49:30,640 --> 00:49:34,160
that doesn't revolve around the tfc

00:49:32,000 --> 00:49:35,520
meetings

00:49:34,160 --> 00:49:38,559
i agree that it would be good to try and

00:49:35,520 --> 00:49:38,559
consolidate some of these

00:49:41,520 --> 00:49:45,520
in major proposals how does

00:49:43,440 --> 00:49:48,880
multi-resolution bbb

00:49:45,520 --> 00:49:50,400
differ from current pdb uh

00:49:48,880 --> 00:49:52,559
i think the main thing here so there is

00:49:50,400 --> 00:49:53,839
actually a again again uh can i guess

00:49:52,559 --> 00:49:54,800
i'll let you talk to this because it was

00:49:53,839 --> 00:49:57,280
your implementation

00:49:54,800 --> 00:49:58,160
of the current multi-grid supports that

00:49:57,280 --> 00:50:01,680
exists in

00:49:58,160 --> 00:50:03,040
bdb right so so

00:50:01,680 --> 00:50:04,960
there is sort of limited what i call

00:50:03,040 --> 00:50:05,280
limited support for multi-resolution

00:50:04,960 --> 00:50:08,480
grids

00:50:05,280 --> 00:50:11,200
in vdb today through the tool called

00:50:08,480 --> 00:50:13,040
multi-res grid and it is essentially it

00:50:11,200 --> 00:50:15,440
builds um

00:50:13,040 --> 00:50:16,240
again it's it's for static applications

00:50:15,440 --> 00:50:19,760
and it builds

00:50:16,240 --> 00:50:23,359
a level of detail hierarchy of

00:50:19,760 --> 00:50:25,680
of graceful progressively coarser

00:50:23,359 --> 00:50:27,119
voxel sampling so imagine that you have

00:50:25,680 --> 00:50:28,960
a high resolution

00:50:27,119 --> 00:50:30,559
let's say you have a high resolution uh

00:50:28,960 --> 00:50:31,839
stf that you want to use for creation

00:50:30,559 --> 00:50:36,240
detection

00:50:31,839 --> 00:50:39,760
um you can then build a hierarchy of

00:50:36,240 --> 00:50:41,440
of trees uh with progressively

00:50:39,760 --> 00:50:43,839
caution causal resolution that you can

00:50:41,440 --> 00:50:47,040
probe um

00:50:43,839 --> 00:50:48,800
but the the proposal that's listed in

00:50:47,040 --> 00:50:51,359
in the roadmap is something entirely

00:50:48,800 --> 00:50:54,800
different um it's actually

00:50:51,359 --> 00:50:57,520
um it's so we've been in dialogue

00:50:54,800 --> 00:50:58,880
with the bifrost team at autodesk and

00:50:57,520 --> 00:51:01,440
they have a very cool

00:50:58,880 --> 00:51:02,640
uh multi-resolution volumetric grid

00:51:01,440 --> 00:51:05,119
that's dynamic

00:51:02,640 --> 00:51:06,559
um and as far as i understand they're

00:51:05,119 --> 00:51:09,680
actually using

00:51:06,559 --> 00:51:11,920
openvdb for io um

00:51:09,680 --> 00:51:13,680
so we've been looking into unfortunately

00:51:11,920 --> 00:51:14,640
it's it's not moving very fast i think

00:51:13,680 --> 00:51:16,800
the ball is

00:51:14,640 --> 00:51:17,680
our caught to be honest um well we've

00:51:16,800 --> 00:51:19,520
been talking

00:51:17,680 --> 00:51:22,720
with them about adopting essentially

00:51:19,520 --> 00:51:25,920
their their great structure and that's

00:51:22,720 --> 00:51:28,000
that's a uh an adaptive um

00:51:25,920 --> 00:51:29,280
structure so so maybe it's worth

00:51:28,000 --> 00:51:30,720
pointing out when we say at

00:51:29,280 --> 00:51:33,280
when we say motor resolution and

00:51:30,720 --> 00:51:34,640
adaptive um

00:51:33,280 --> 00:51:36,480
you know additivity can mean many

00:51:34,640 --> 00:51:38,319
different things

00:51:36,480 --> 00:51:40,720
and in this case what we mean by

00:51:38,319 --> 00:51:43,440
multi-resolution is the fact that

00:51:40,720 --> 00:51:45,440
a grid value can be sampled at different

00:51:43,440 --> 00:51:49,119
resolutions

00:51:45,440 --> 00:51:51,599
so a single a single value may exist

00:51:49,119 --> 00:51:52,400
at different levels in this in this tree

00:51:51,599 --> 00:51:55,440
structure

00:51:52,400 --> 00:51:56,880
whereas currently in vdb a grid value

00:51:55,440 --> 00:51:59,920
ijk

00:51:56,880 --> 00:52:01,760
only exists at a one level

00:51:59,920 --> 00:52:03,359
you know it can either be at a leaf node

00:52:01,760 --> 00:52:05,280
at the finest resolution

00:52:03,359 --> 00:52:07,520
or it can be higher up in the tree at a

00:52:05,280 --> 00:52:10,319
tile

00:52:07,520 --> 00:52:12,079
the fact that that vdb has a very very

00:52:10,319 --> 00:52:15,040
high fade out factor

00:52:12,079 --> 00:52:16,079
remember remember the diagram i showed

00:52:15,040 --> 00:52:18,640
you with

00:52:16,079 --> 00:52:20,240
four different levels uh demonstrating

00:52:18,640 --> 00:52:22,319
that it's a very shallow tree

00:52:20,240 --> 00:52:24,480
the reason it's so shallow is that the

00:52:22,319 --> 00:52:26,079
fan out factor is very high

00:52:24,480 --> 00:52:28,400
that's great for access but it's not

00:52:26,079 --> 00:52:30,800
very good for adaptivity

00:52:28,400 --> 00:52:32,800
because the refinement in resolution

00:52:30,800 --> 00:52:36,160
when you jump from one level to the next

00:52:32,800 --> 00:52:38,960
is is very big um you know

00:52:36,160 --> 00:52:39,520
you can sort of contrast it to an octree

00:52:38,960 --> 00:52:41,680
which has

00:52:39,520 --> 00:52:43,079
ideal refinement because it's one in

00:52:41,680 --> 00:52:46,079
sorry it's two in its coordinate

00:52:43,079 --> 00:52:48,800
direction um

00:52:46,079 --> 00:52:49,599
so yeah so it's a long way of saying

00:52:48,800 --> 00:52:50,960
there is

00:52:49,599 --> 00:52:53,440
there is some support for ultra

00:52:50,960 --> 00:52:55,440
resolution today in vdb uh

00:52:53,440 --> 00:52:57,359
but but if you're looking for something

00:52:55,440 --> 00:53:01,839
that's adaptive dynamic

00:52:57,359 --> 00:53:01,839
uh you still have to wait a bit um

00:53:02,400 --> 00:53:06,559
just before we go on to the next

00:53:04,240 --> 00:53:08,319
question um jeff makes a good point

00:53:06,559 --> 00:53:10,880
we are considering removing the

00:53:08,319 --> 00:53:12,880
makefiles from the vb distribution

00:53:10,880 --> 00:53:14,400
and if anyone has any thoughts about

00:53:12,880 --> 00:53:14,960
that or concerns or doesn't want us to

00:53:14,400 --> 00:53:18,960
do that

00:53:14,960 --> 00:53:20,559
just let us know soon or now um

00:53:18,960 --> 00:53:23,760
uh yeah just wanted to mention that

00:53:20,559 --> 00:53:23,760
before we go on to the next question

00:53:24,559 --> 00:53:28,640
uh ken one for you can nanovdb use

00:53:26,720 --> 00:53:30,559
paging or similar methods on the gpu to

00:53:28,640 --> 00:53:34,160
reach large volumes

00:53:30,559 --> 00:53:36,079
eg production caches onto the gpu

00:53:34,160 --> 00:53:37,760
while staying within gpu memory limits i

00:53:36,079 --> 00:53:40,880
assume we're talking about streaming

00:53:37,760 --> 00:53:44,240
that's just something to extend here

00:53:40,880 --> 00:53:45,280
um not not today uh but there is

00:53:44,240 --> 00:53:47,760
actually

00:53:45,280 --> 00:53:49,040
there is uh another team at nvidia

00:53:47,760 --> 00:53:52,240
that's that's working on this

00:53:49,040 --> 00:53:54,839
so nvidia has a commercial product

00:53:52,240 --> 00:53:56,160
called index it's a scientific

00:53:54,839 --> 00:53:59,760
utilization

00:53:56,160 --> 00:54:01,839
tool that allows you to visualize

00:53:59,760 --> 00:54:03,359
very very large scientific data sets

00:54:01,839 --> 00:54:05,040
like typically stuff that comes out of

00:54:03,359 --> 00:54:08,079
hpc

00:54:05,040 --> 00:54:11,359
and it actually uses obviously

00:54:08,079 --> 00:54:14,079
multiple gpus that actually use the api

00:54:11,359 --> 00:54:15,599
and they're working on adapt on adding

00:54:14,079 --> 00:54:18,800
other core support to

00:54:15,599 --> 00:54:19,839
nano adp i'm i'm hoping i don't know for

00:54:18,800 --> 00:54:23,119
sure but i'm hoping that

00:54:19,839 --> 00:54:26,319
we can share that back but the

00:54:23,119 --> 00:54:27,839
the idea of using memory pools is a

00:54:26,319 --> 00:54:29,119
great idea and obviously this is what

00:54:27,839 --> 00:54:32,160
you need

00:54:29,119 --> 00:54:33,200
to have a dynamic data structure on on

00:54:32,160 --> 00:54:36,240
the gpu

00:54:33,200 --> 00:54:37,200
um and because nanovdb doesn't have this

00:54:36,240 --> 00:54:39,839
pool

00:54:37,200 --> 00:54:40,240
you know that that's also why it's not

00:54:39,839 --> 00:54:43,839
it's

00:54:40,240 --> 00:54:48,319
not um it's limited it's not

00:54:43,839 --> 00:54:48,319
able to uh modify the tree yet

00:54:50,839 --> 00:54:55,680
um

00:54:52,880 --> 00:54:57,920
last one again was about communication

00:54:55,680 --> 00:55:00,319
how about slack or discord group

00:54:57,920 --> 00:55:02,160
i don't think we're opposed to any forum

00:55:00,319 --> 00:55:04,640
type for discussion

00:55:02,160 --> 00:55:08,400
uh is perhaps something we should bring

00:55:04,640 --> 00:55:08,400
up in in one of our steering committees

00:55:09,839 --> 00:55:13,520
i would love slack i have great

00:55:12,559 --> 00:55:17,280
experience with it

00:55:13,520 --> 00:55:21,680
um i can't remember does aswf

00:55:17,280 --> 00:55:25,160
have a slack channel or a slack account

00:55:21,680 --> 00:55:26,400
yeah we do have a slack group we do go

00:55:25,160 --> 00:55:29,280
slack.aswf.io

00:55:26,400 --> 00:55:30,160
and there's an openvdb channel on there

00:55:29,280 --> 00:55:33,440
oh there it is

00:55:30,160 --> 00:55:37,200
wow okay there you go

00:55:33,440 --> 00:55:37,200
maybe we should start using it

00:55:38,640 --> 00:55:42,559
cool cool

00:55:43,200 --> 00:55:49,200
yeah looks like we've exhausted all the

00:55:46,839 --> 00:55:52,160
questions

00:55:49,200 --> 00:55:54,559
um is there anything more you want to

00:55:52,160 --> 00:55:58,160
say about the robot nick

00:55:54,559 --> 00:56:02,480
um is there anything you could say about

00:55:58,160 --> 00:56:05,599
like when do you think ax will be

00:56:02,480 --> 00:56:10,160
available you think you know this year

00:56:05,599 --> 00:56:12,960
or i mean you don't know ax is ax is

00:56:10,160 --> 00:56:14,400
is ready to go i think uh it obviously

00:56:12,960 --> 00:56:18,079
it still needs to be vetted

00:56:14,400 --> 00:56:19,920
thoroughly by the tsc um we've had a

00:56:18,079 --> 00:56:21,359
good round on the front end language on

00:56:19,920 --> 00:56:23,760
the actual language specifically

00:56:21,359 --> 00:56:24,960
so i think that's in pretty solid states

00:56:23,760 --> 00:56:28,079
uh

00:56:24,960 --> 00:56:30,480
so we would like to see it i think

00:56:28,079 --> 00:56:34,079
in a 7.2 or eight release basically the

00:56:30,480 --> 00:56:34,079
next release of bbb

00:56:34,960 --> 00:56:39,599
cool i don't know if anyone else has any

00:56:36,720 --> 00:56:39,599
comments on the roadmap

00:56:39,680 --> 00:56:43,760
yeah i can make a few quick comments um

00:56:42,400 --> 00:56:44,079
i'm just going to quickly mention that

00:56:43,760 --> 00:56:46,640
like

00:56:44,079 --> 00:56:48,160
some of our focus uh over the last year

00:56:46,640 --> 00:56:49,440
or so and i imagine going forward will

00:56:48,160 --> 00:56:51,520
be the case as well is

00:56:49,440 --> 00:56:52,720
trying to kind of streamline the library

00:56:51,520 --> 00:56:54,720
and the tree hierarchy

00:56:52,720 --> 00:56:56,240
a little bit uh over the years it's kind

00:56:54,720 --> 00:56:57,839
of grown in size and there's more and

00:56:56,240 --> 00:56:59,760
more tools that are that are in the tree

00:56:57,839 --> 00:57:02,079
hierarchy and especially with

00:56:59,760 --> 00:57:03,520
uh examples like nanovdb where a very

00:57:02,079 --> 00:57:04,480
lightweight hierarchy has a lot of

00:57:03,520 --> 00:57:07,040
benefits

00:57:04,480 --> 00:57:08,079
uh we're trying to sort of pull some of

00:57:07,040 --> 00:57:09,839
those tools out

00:57:08,079 --> 00:57:11,200
uh we've also found some performance

00:57:09,839 --> 00:57:12,559
improvements through through some of

00:57:11,200 --> 00:57:13,920
those tools being

00:57:12,559 --> 00:57:15,839
being separate so that we can use

00:57:13,920 --> 00:57:17,920
different kind of techniques for

00:57:15,839 --> 00:57:18,960
for paralyzing uh that makes them a bit

00:57:17,920 --> 00:57:21,680
faster

00:57:18,960 --> 00:57:22,640
um and so yeah so some of the work

00:57:21,680 --> 00:57:25,440
that's happening with that

00:57:22,640 --> 00:57:26,640
and then obviously framework building

00:57:25,440 --> 00:57:28,079
stuff improving the c

00:57:26,640 --> 00:57:29,839
make we've done a huge amount of work on

00:57:28,079 --> 00:57:31,520
the cmake over the last year or so

00:57:29,839 --> 00:57:33,920
and there's a lot more to do with that i

00:57:31,520 --> 00:57:35,839
think but uh it's getting to a stage

00:57:33,920 --> 00:57:37,760
where it's becoming a lot more mature

00:57:35,839 --> 00:57:39,359
so definitely we're trying to formalize

00:57:37,760 --> 00:57:40,880
that and that's giving us opportunities

00:57:39,359 --> 00:57:42,640
to try and reorganize the code base a

00:57:40,880 --> 00:57:44,400
little bit move things around a bit

00:57:42,640 --> 00:57:47,440
just kind of tidying up and modernize it

00:57:44,400 --> 00:57:51,680
in a few places where it needs to be

00:57:47,440 --> 00:57:52,480
um yeah i haven't got any more comments

00:57:51,680 --> 00:57:53,839
in terms of the

00:57:52,480 --> 00:57:56,000
different features that are there we we

00:57:53,839 --> 00:57:57,920
need to kind of discuss some of the

00:57:56,000 --> 00:57:59,599
roadmap items and figure out which of

00:57:57,920 --> 00:58:01,599
the big kind of priorities but yeah for

00:57:59,599 --> 00:58:02,880
the for the time being ax and nanov

00:58:01,599 --> 00:58:06,000
remain the two

00:58:02,880 --> 00:58:07,920
sort of focus points at the moment

00:58:06,000 --> 00:58:11,839
one last question uh ken how does

00:58:07,920 --> 00:58:16,160
nanovdb compare against gvdb

00:58:11,839 --> 00:58:19,440
oh um i honestly don't know

00:58:16,160 --> 00:58:22,960
um so i think i think

00:58:19,440 --> 00:58:26,559
gvdb so actually the

00:58:22,960 --> 00:58:29,920
rama the the core

00:58:26,559 --> 00:58:33,280
architect of tvdb uh

00:58:29,920 --> 00:58:35,040
has left nvidia and i

00:58:33,280 --> 00:58:36,559
believe the project is not being

00:58:35,040 --> 00:58:38,720
developed more

00:58:36,559 --> 00:58:38,720
so

00:58:39,760 --> 00:58:44,160
nvidia itself is actually is moving on

00:58:42,400 --> 00:58:45,040
to another project that unfortunately i

00:58:44,160 --> 00:58:48,559
can't talk about

00:58:45,040 --> 00:58:48,960
um but in terms of comparison between tv

00:58:48,559 --> 00:58:52,160
db

00:58:48,960 --> 00:58:54,240
and nano vdb it's

00:58:52,160 --> 00:58:56,160
again it's it's a little bit apples and

00:58:54,240 --> 00:58:59,280
bananas because gvdb

00:58:56,160 --> 00:59:01,440
allows you to do simulation uh

00:58:59,280 --> 00:59:02,720
nano video does not uh that will be

00:59:01,440 --> 00:59:05,359
focusing on rendering

00:59:02,720 --> 00:59:06,160
i have not i i'm pretty sure dvdb can

00:59:05,359 --> 00:59:09,599
also do

00:59:06,160 --> 00:59:10,240
uh uh ray tracing i have not compared

00:59:09,599 --> 00:59:12,880
the two

00:59:10,240 --> 00:59:14,400
uh i would be surprised if there's a if

00:59:12,880 --> 00:59:16,960
there's a big performance difference

00:59:14,400 --> 00:59:19,680
there really shouldn't be because

00:59:16,960 --> 00:59:21,520
underneath i think gvdb is using a data

00:59:19,680 --> 00:59:24,559
structure that's fairly similar to

00:59:21,520 --> 00:59:26,400
to the vdb data structure so

00:59:24,559 --> 00:59:28,079
yeah i think that's that's actually a

00:59:26,400 --> 00:59:30,880
good question i should uh

00:59:28,079 --> 00:59:33,200
i should check that out um i see a

00:59:30,880 --> 00:59:35,200
comment came in uh that apparently gvdb

00:59:33,200 --> 00:59:37,680
will be out of support for nanobb in a

00:59:35,200 --> 00:59:37,680
few days

00:59:38,559 --> 00:59:42,160
oh sorry gvdb will be out of support in

00:59:40,799 --> 00:59:45,200
a few days

00:59:42,160 --> 00:59:47,119
no add in support for nanovdb in a few

00:59:45,200 --> 00:59:50,480
days it's in the chat

00:59:47,119 --> 00:59:51,839
oh cool okay sounds like someone is

00:59:50,480 --> 00:59:55,359
still working on it

00:59:51,839 --> 00:59:56,720
that is cool okay i take i take back

00:59:55,359 --> 00:59:58,000
what i said then

00:59:56,720 --> 01:00:00,000
there was another question i

00:59:58,000 --> 01:00:02,880
accidentally dismissed it was

01:00:00,000 --> 01:00:03,760
oh is it over that's no i just i just

01:00:02,880 --> 01:00:06,960
ended the

01:00:03,760 --> 01:00:08,480
screenshot um what was the license for

01:00:06,960 --> 01:00:09,839
this and can be used for commercial uh

01:00:08,480 --> 01:00:11,119
development i hope it can be used for

01:00:09,839 --> 01:00:14,640
commercial development because

01:00:11,119 --> 01:00:17,119
uh houdini is

01:00:14,640 --> 01:00:18,240
oh i forgot to mention that there's a

01:00:17,119 --> 01:00:21,119
pig light no

01:00:18,240 --> 01:00:22,079
um it's it's the exact same license as

01:00:21,119 --> 01:00:25,599
open 3db

01:00:22,079 --> 01:00:26,000
right so the same same same restrictions

01:00:25,599 --> 01:00:28,079
or

01:00:26,000 --> 01:00:31,760
lag off as open vb so yes you could

01:00:28,079 --> 01:00:31,760
definitely use it for commercials also

01:00:32,319 --> 01:00:35,440
if we have time super quickly one last

01:00:34,079 --> 01:00:37,920
one are there any examples of how to

01:00:35,440 --> 01:00:39,920
load triangle meshes to nano bdb

01:00:37,920 --> 01:00:41,440
i guess you could go through open vdb to

01:00:39,920 --> 01:00:42,799
a nano vtp

01:00:41,440 --> 01:00:45,520
yes that would that would be the

01:00:42,799 --> 01:00:49,280
workflow today so so think of

01:00:45,520 --> 01:00:52,000
think of nanovdb as a bridge to the gpu

01:00:49,280 --> 01:00:54,400
uh where you can do anything on the gpu

01:00:52,000 --> 01:00:55,920
that involves a static tree

01:00:54,400 --> 01:00:57,119
and as i mentioned many times before

01:00:55,920 --> 01:00:58,559
rendering is one example creation

01:00:57,119 --> 01:00:59,680
detection is another one

01:00:58,559 --> 01:01:01,280
i'm sure there's a bunch of other

01:00:59,680 --> 01:01:01,920
examples that we haven't even thought of

01:01:01,280 --> 01:01:05,280
yet

01:01:01,920 --> 01:01:08,640
um but in terms of authoring

01:01:05,280 --> 01:01:13,599
uh vdbs from a mesh you

01:01:08,640 --> 01:01:13,599
currently have to go through um openvdb

01:01:13,839 --> 01:01:19,040
um but that that may change

01:01:19,200 --> 01:01:27,280
so cool i think we're spot on

01:01:23,599 --> 01:01:30,559
uh yeah so so thanks everyone for

01:01:27,280 --> 01:01:32,799
uh dialing in and for listening to this

01:01:30,559 --> 01:01:33,920
uh presentation uh if you have more

01:01:32,799 --> 01:01:37,760
questions

01:01:33,920 --> 01:01:39,680
by all means please reach out uh you can

01:01:37,760 --> 01:01:41,359
you can use email you can use the the

01:01:39,680 --> 01:01:46,960
two forums that we talked about

01:01:41,359 --> 01:01:50,240
um and we'll try and keep you up to date

01:01:46,960 --> 01:01:52,559
yes thank everyone

01:01:50,240 --> 01:01:52,559

YouTube URL: https://www.youtube.com/watch?v=VJBv9lh5kqg


