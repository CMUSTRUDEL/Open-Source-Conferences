Title: Rez BoF, SIGGRAPH 2019
Publication date: 2019-08-08
Playlist: SIGGRAPH 2019: Open Source Day
Description: 
	An overview of how Method Studios integrates Rez into their pipeline, followed by an overview of outstanding feature development and a conversation about the future goals of the project. Part of Open Source Day at SIGGRAPH 2019, hosted by Academy Software Foundation.

Speakers: 
Allan Johns, Method Studios
Stephen Mackenzie, Method Studios
Captions: 
	00:00:00,030 --> 00:00:08,280
hi everyone welcome to the res ball for

00:00:04,560 --> 00:00:10,590
2019 we're gonna break this into three

00:00:08,280 --> 00:00:12,870
sections so the first part is going to

00:00:10,590 --> 00:00:17,520
be an overview of how we've integrated

00:00:12,870 --> 00:00:19,770
res at Method studios the second part is

00:00:17,520 --> 00:00:22,439
going to be a roadmap for development so

00:00:19,770 --> 00:00:24,390
I was going to talk about what's been

00:00:22,439 --> 00:00:29,550
done and what's coming up in the next

00:00:24,390 --> 00:00:32,850
year and the last third will be a Q&A so

00:00:29,550 --> 00:00:36,000
let's get started so I'm Alan Jones I'm

00:00:32,850 --> 00:00:38,820
a lead-pipe dev at method LA and I wrote

00:00:36,000 --> 00:00:40,350
res and my colleague he's doing the

00:00:38,820 --> 00:00:42,809
first part of the presentation is Steve

00:00:40,350 --> 00:00:45,420
McKenzie he's Alf hourly pipe dev at

00:00:42,809 --> 00:00:50,160
method New York and he builds lots of

00:00:45,420 --> 00:00:52,230
stuff and Reza fires lots of stuff thank

00:00:50,160 --> 00:00:53,850
you to the Academy for making this

00:00:52,230 --> 00:00:57,949
happen and specifically for sponsoring

00:00:53,850 --> 00:00:57,949
me to make this just this talk possible

00:00:58,070 --> 00:01:03,390
first of all I just want to start with a

00:01:00,329 --> 00:01:09,900
bit of a poll so who's using raise at

00:01:03,390 --> 00:01:12,119
their studio hands up and so from those

00:01:09,900 --> 00:01:16,549
people to what extent are you using it

00:01:12,119 --> 00:01:16,549
so a across most all of production

00:01:19,610 --> 00:01:26,490
partially like maybe one department or

00:01:22,140 --> 00:01:31,860
maybe just for building and testing or

00:01:26,490 --> 00:01:33,659
kind of beta phase all right and and

00:01:31,860 --> 00:01:40,320
who's already reasonably familiar with

00:01:33,659 --> 00:01:42,390
res ok all right so very briefly a

00:01:40,320 --> 00:01:45,090
history of the project it started life

00:01:42,390 --> 00:01:47,790
at a SEO in Sydney called dr. D it was

00:01:45,090 --> 00:01:51,659
called dat config at the time it was

00:01:47,790 --> 00:01:53,850
open sourced and renamed in 2012 the

00:01:51,659 --> 00:01:56,189
first version was really just the

00:01:53,850 --> 00:01:58,799
dependency solver in written in Python

00:01:56,189 --> 00:02:02,159
with some bash stuck around it to get it

00:01:58,799 --> 00:02:04,710
to be useful in a practical way there

00:02:02,159 --> 00:02:06,030
was then a version to rewrite that it

00:02:04,710 --> 00:02:08,849
was pretty much a complete rewrite that

00:02:06,030 --> 00:02:10,319
turned into a full API or written in

00:02:08,849 --> 00:02:12,930
Python cross-platform multiple shell

00:02:10,319 --> 00:02:13,340
support and a python-based package

00:02:12,930 --> 00:02:16,160
definition

00:02:13,340 --> 00:02:17,569
format which change things so as you can

00:02:16,160 --> 00:02:19,220
see there's there's a bit of a

00:02:17,569 --> 00:02:23,239
reasonable spike of activity just

00:02:19,220 --> 00:02:24,590
recently as well so that's good I'll now

00:02:23,239 --> 00:02:28,209
hand it over to Stephen to talk about

00:02:24,590 --> 00:02:28,209
how we integrated it method

00:02:28,360 --> 00:02:39,799
[Applause]

00:02:34,689 --> 00:02:41,750
everybody so so first of all it's useful

00:02:39,799 --> 00:02:43,250
to ask the problem of like just what

00:02:41,750 --> 00:02:46,099
does production even want out of their

00:02:43,250 --> 00:02:48,290
situation generally speaking we have a

00:02:46,099 --> 00:02:50,150
variety of needs things like I need to

00:02:48,290 --> 00:02:52,840
use five different versions of Maya or

00:02:50,150 --> 00:02:54,950
five different versions of nuke we also

00:02:52,840 --> 00:02:57,200
commonly come across the issue of how we

00:02:54,950 --> 00:02:59,269
migrate operating systems in a sane way

00:02:57,200 --> 00:03:02,000
where we're stepping from you know a

00:02:59,269 --> 00:03:03,620
bunt to descent OS or even sub versions

00:03:02,000 --> 00:03:05,720
between like sent OS seven point two

00:03:03,620 --> 00:03:07,489
three four kind of ways of versioning

00:03:05,720 --> 00:03:09,139
forward you know in a way that does not

00:03:07,489 --> 00:03:10,879
break the pipeline while people are

00:03:09,139 --> 00:03:14,810
working on in a way we can do migrations

00:03:10,879 --> 00:03:17,450
in a stepwise manner and as well as just

00:03:14,810 --> 00:03:19,250
to like essentially flexibility around

00:03:17,450 --> 00:03:21,109
our runtime environments so that when

00:03:19,250 --> 00:03:23,329
developers inevitably screw something up

00:03:21,109 --> 00:03:26,269
we are able to quickly adapt to that

00:03:23,329 --> 00:03:27,889
situation it's also becoming more common

00:03:26,269 --> 00:03:30,319
that we want to be able to plug on new

00:03:27,889 --> 00:03:31,879
renderers or different situations

00:03:30,319 --> 00:03:33,319
workflow types into different

00:03:31,879 --> 00:03:34,939
environments and quickly and rapidly

00:03:33,319 --> 00:03:36,889
assemble a different workflow for a

00:03:34,939 --> 00:03:38,359
certain kind of production you know I've

00:03:36,889 --> 00:03:39,620
got a feature that needs to use render

00:03:38,359 --> 00:03:41,720
man I've got a commercial I'm using

00:03:39,620 --> 00:03:43,250
redshift whatever being able to split

00:03:41,720 --> 00:03:45,109
environments up and sort of add on

00:03:43,250 --> 00:03:46,370
optional functionalities onto your DCC

00:03:45,109 --> 00:03:49,609
dynamically it's always been really

00:03:46,370 --> 00:03:51,199
helpful for us and of course production

00:03:49,609 --> 00:03:53,769
wants to be able to have low impact

00:03:51,199 --> 00:03:56,479
events whenever things are screwed up so

00:03:53,769 --> 00:03:59,930
being able to have an artist to be able

00:03:56,479 --> 00:04:01,639
to do something as simple as work as if

00:03:59,930 --> 00:04:03,139
it were yesterday before pipelines

00:04:01,639 --> 00:04:04,549
screwed something up then you know

00:04:03,139 --> 00:04:06,889
that's a that's a level of adaptation

00:04:04,549 --> 00:04:10,579
that we can present to the user in a way

00:04:06,889 --> 00:04:12,459
that actually functions you know in a

00:04:10,579 --> 00:04:16,729
way that is completely dynamic to them

00:04:12,459 --> 00:04:18,169
and just to be able to like optionally

00:04:16,729 --> 00:04:20,570
provide different plugins like I was

00:04:18,169 --> 00:04:22,340
talking about before like not every nuke

00:04:20,570 --> 00:04:23,720
that runs needs to use every license to

00:04:22,340 --> 00:04:25,090
plug in in your facility and maybe you

00:04:23,720 --> 00:04:27,560
want to be able to have compositors

00:04:25,090 --> 00:04:31,370
dynamically add something on

00:04:27,560 --> 00:04:33,169
so essentially runtime management

00:04:31,370 --> 00:04:36,500
just a little timeline for context about

00:04:33,169 --> 00:04:39,500
how method used rez for a long time sort

00:04:36,500 --> 00:04:41,450
of - 2015 and prior we used a system of

00:04:39,500 --> 00:04:43,130
site suites where every single suite

00:04:41,450 --> 00:04:44,040
basically had a folder of context that

00:04:43,130 --> 00:04:47,470
would get up

00:04:44,040 --> 00:04:50,710
constantly somewhere around 15 to 16 in

00:04:47,470 --> 00:04:52,480
that range we got to a point where it

00:04:50,710 --> 00:04:55,840
became obvious we needed to sort of have

00:04:52,480 --> 00:04:58,270
show sweets on top of site sweets so

00:04:55,840 --> 00:04:59,980
that we could have a essentially like a

00:04:58,270 --> 00:05:02,020
show could override a specific tool set

00:04:59,980 --> 00:05:03,660
and then what I'm going to talk about a

00:05:02,020 --> 00:05:06,100
little bit in more detail soon is

00:05:03,660 --> 00:05:07,720
something we've cobbled together called

00:05:06,100 --> 00:05:10,150
and I'm config and in production and

00:05:07,720 --> 00:05:12,250
that's got some implications down the

00:05:10,150 --> 00:05:14,680
line eventually what this has given us

00:05:12,250 --> 00:05:18,040
is an ability to give artists

00:05:14,680 --> 00:05:19,930
essentially a command that is running

00:05:18,040 --> 00:05:21,669
their version of Maya or nuke or

00:05:19,930 --> 00:05:23,080
whatever but is dynamically resolving

00:05:21,669 --> 00:05:25,210
what they want at the exact time they

00:05:23,080 --> 00:05:27,100
ask for it so there's no more staleness

00:05:25,210 --> 00:05:30,400
in terms of an artist opening something

00:05:27,100 --> 00:05:33,010
up and you know having a shell open for

00:05:30,400 --> 00:05:34,720
like a week and ending up like in some

00:05:33,010 --> 00:05:36,160
bad environment where maybe some service

00:05:34,720 --> 00:05:37,870
has been migrated and things are not

00:05:36,160 --> 00:05:39,610
functioning quite right so it's to avoid

00:05:37,870 --> 00:05:42,010
a lot of those issues and then I'll just

00:05:39,610 --> 00:05:43,630
very briefly outline a model we're

00:05:42,010 --> 00:05:45,490
moving to called our software deployment

00:05:43,630 --> 00:05:48,970
system and that'll just have a slide at

00:05:45,490 --> 00:05:50,979
the end just for one thing so generally

00:05:48,970 --> 00:05:52,750
this is kind of our artist experience at

00:05:50,979 --> 00:05:56,350
the simplest we want it to be as simple

00:05:52,750 --> 00:05:58,720
as set your shot and you know be able to

00:05:56,350 --> 00:06:00,880
seee to something convenient and run

00:05:58,720 --> 00:06:03,669
your application at it's more

00:06:00,880 --> 00:06:06,180
complicated we are exposing two artists

00:06:03,669 --> 00:06:08,020
a time flag with the ability to

00:06:06,180 --> 00:06:10,180
essentially turn on or off the

00:06:08,020 --> 00:06:12,100
visibility of packages that have been

00:06:10,180 --> 00:06:13,840
released so as you know res packages

00:06:12,100 --> 00:06:16,229
have a timestamp associated with them so

00:06:13,840 --> 00:06:19,210
our set shot system can essentially

00:06:16,229 --> 00:06:22,120
inform res as to the - - time flag

00:06:19,210 --> 00:06:24,340
passed along so if you walk in in the

00:06:22,120 --> 00:06:26,440
morning on Tuesday when we've updated a

00:06:24,340 --> 00:06:27,910
whole bunch of packages the artists

00:06:26,440 --> 00:06:29,560
experience is a break nooks not

00:06:27,910 --> 00:06:30,850
launching hey what's going on ok let me

00:06:29,560 --> 00:06:32,710
just set it to yesterday until the

00:06:30,850 --> 00:06:35,800
pipeline guys come in at their leisurely

00:06:32,710 --> 00:06:37,660
hour and start actually fixing things

00:06:35,800 --> 00:06:39,340
it's also possible for us later on I'll

00:06:37,660 --> 00:06:40,840
get into this unstable previous table

00:06:39,340 --> 00:06:43,389
bit but essentially we have a concept

00:06:40,840 --> 00:06:47,680
called package views which maps to a

00:06:43,389 --> 00:06:49,720
channel or a service managed package

00:06:47,680 --> 00:06:51,880
path that is taking the raw package path

00:06:49,720 --> 00:06:54,610
of the studio and translating it into a

00:06:51,880 --> 00:06:55,960
specific sort of channel of packages

00:06:54,610 --> 00:06:57,050
that are being timed out in a specific

00:06:55,960 --> 00:06:59,370
way

00:06:57,050 --> 00:07:02,310
and the artist has the ability to patch

00:06:59,370 --> 00:07:03,600
on existing tools additional reza jizz

00:07:02,310 --> 00:07:05,220
into their environment dynamically

00:07:03,600 --> 00:07:08,850
because it's happening at tool launch

00:07:05,220 --> 00:07:12,600
time and you'll notice the new 10.5 as

00:07:08,850 --> 00:07:14,280
in rez contexts from long time ago you

00:07:12,600 --> 00:07:15,870
are able to suffix your tools so you're

00:07:14,280 --> 00:07:18,000
able to present as many versions of nuke

00:07:15,870 --> 00:07:19,590
or Maya to the facility as you want we

00:07:18,000 --> 00:07:21,360
usually take the step of making a

00:07:19,590 --> 00:07:23,190
certain default present so in our case

00:07:21,360 --> 00:07:24,690
like nuke 11 is the default so if you

00:07:23,190 --> 00:07:28,080
have to backpedal for some reason you

00:07:24,690 --> 00:07:30,710
can you can run the nuke 10.5 there and

00:07:28,080 --> 00:07:33,180
on the flip side as a developer it's

00:07:30,710 --> 00:07:35,130
very helpful to be able to test in the

00:07:33,180 --> 00:07:37,050
production environment with your extra

00:07:35,130 --> 00:07:39,060
stuff so we have some flags that

00:07:37,050 --> 00:07:40,560
essentially are again dynamically adding

00:07:39,060 --> 00:07:44,130
this in but are allowing things like

00:07:40,560 --> 00:07:46,020
local packages to the developer having

00:07:44,130 --> 00:07:47,460
sane ways of just quickly printing out

00:07:46,020 --> 00:07:50,190
the resolved package lists to help debug

00:07:47,460 --> 00:07:51,900
and at the at the very bottom you'll see

00:07:50,190 --> 00:07:54,510
sort of typical things I find myself

00:07:51,900 --> 00:07:57,180
doing when debugging or resolve pulling

00:07:54,510 --> 00:07:58,920
out the the DC C's requests and starting

00:07:57,180 --> 00:07:59,970
to graph things find the conflicts be

00:07:58,920 --> 00:08:04,020
able to mess around with things a little

00:07:59,970 --> 00:08:05,970
bit that way so just a brief overview

00:08:04,020 --> 00:08:07,920
for people that aren't terribly exposed

00:08:05,970 --> 00:08:10,020
to res all that much a context is

00:08:07,920 --> 00:08:12,570
basically just a request that has been

00:08:10,020 --> 00:08:15,420
resolved and baked off and so the way

00:08:12,570 --> 00:08:18,060
our even current course suite is handled

00:08:15,420 --> 00:08:20,820
is essentially just a system of having a

00:08:18,060 --> 00:08:22,590
folder full of contexts and you're able

00:08:20,820 --> 00:08:24,510
to use the - - fetch command on a

00:08:22,590 --> 00:08:26,220
context to see what would update so

00:08:24,510 --> 00:08:28,200
that's a fantastic preview device to say

00:08:26,220 --> 00:08:30,570
what am I about to expose to my facility

00:08:28,200 --> 00:08:31,770
before I've gone and done it so that's

00:08:30,570 --> 00:08:35,400
kind of a critical step when we're

00:08:31,770 --> 00:08:36,390
making sure we you know aren't it might

00:08:35,400 --> 00:08:38,550
be we're sending up a warning to

00:08:36,390 --> 00:08:39,990
production when like some very large new

00:08:38,550 --> 00:08:41,460
version of things with many dependencies

00:08:39,990 --> 00:08:43,740
is about to come in it's like okay guys

00:08:41,460 --> 00:08:45,920
just so you know like let us know if

00:08:43,740 --> 00:08:48,360
there's going to be problems or whatever

00:08:45,920 --> 00:08:50,730
and then the concept of a suite is

00:08:48,360 --> 00:08:53,690
basically as I said a whole bunch of

00:08:50,730 --> 00:08:55,650
contexts that are in a folder and

00:08:53,690 --> 00:08:57,270
essentially just wrapping that fetch

00:08:55,650 --> 00:08:59,070
functionality we can do something like

00:08:57,270 --> 00:09:01,590
just quickly query what all of these

00:08:59,070 --> 00:09:06,660
contexts are going to expose to the

00:09:01,590 --> 00:09:07,710
facility and simply as as shown at the

00:09:06,660 --> 00:09:08,940
top there where you're creating a

00:09:07,710 --> 00:09:10,350
context just to take

00:09:08,940 --> 00:09:12,180
request and bake it out into a new one

00:09:10,350 --> 00:09:14,100
that's really all you're doing with this

00:09:12,180 --> 00:09:16,080
- - update flag - basically actually

00:09:14,100 --> 00:09:19,830
take that fetched context and bake it

00:09:16,080 --> 00:09:22,350
back into the resolve there's a little

00:09:19,830 --> 00:09:25,130
script somewhere called soma that has

00:09:22,350 --> 00:09:27,330
some rich history add method that

00:09:25,130 --> 00:09:29,490
essentially is wrapping even that

00:09:27,330 --> 00:09:31,830
process to say all right I'm going to

00:09:29,490 --> 00:09:34,170
create a version subfolder that takes

00:09:31,830 --> 00:09:37,230
copies of all the contexts and starts to

00:09:34,170 --> 00:09:39,210
bake out the tools present in the

00:09:37,230 --> 00:09:41,340
contexts out to a bin path in that

00:09:39,210 --> 00:09:43,280
structure so essentially what we end up

00:09:41,340 --> 00:09:45,720
with down here at the bottom is

00:09:43,280 --> 00:09:47,280
assembling putting two sim links one

00:09:45,720 --> 00:09:49,440
pointing to current one point to latest

00:09:47,280 --> 00:09:50,760
and so which we can manipulate if we

00:09:49,440 --> 00:09:52,470
have to and just kind of sim like one

00:09:50,760 --> 00:09:54,690
thing to the other if or backpedal

00:09:52,470 --> 00:09:56,670
aversion and what you exposed to your

00:09:54,690 --> 00:09:58,860
path is this path to your current or

00:09:56,670 --> 00:10:01,650
latest depending on what your what your

00:09:58,860 --> 00:10:03,750
attitude is /bin and that's where all

00:10:01,650 --> 00:10:05,550
your tools live so that's just kind of

00:10:03,750 --> 00:10:07,710
like a super simple way to take a

00:10:05,550 --> 00:10:09,300
facility that doesn't use res yet and

00:10:07,710 --> 00:10:12,600
just kind of put on a very basic level

00:10:09,300 --> 00:10:14,270
of of management around a very core set

00:10:12,600 --> 00:10:17,370
of tools that are being constantly used

00:10:14,270 --> 00:10:20,460
with method we sort of came to the

00:10:17,370 --> 00:10:22,050
conclusion that managing individual show

00:10:20,460 --> 00:10:24,150
Suites for literally hundreds of shows

00:10:22,050 --> 00:10:26,160
was untenable so you know we handle

00:10:24,150 --> 00:10:27,930
commercials we handle features so while

00:10:26,160 --> 00:10:30,480
I'm in Vancouver I might have six ten

00:10:27,930 --> 00:10:33,570
fifteen shows in New York I have a new

00:10:30,480 --> 00:10:36,630
one every week so it's important to be

00:10:33,570 --> 00:10:38,520
able to not just not just be able to

00:10:36,630 --> 00:10:39,900
manage context and like one singular way

00:10:38,520 --> 00:10:41,420
but also be able to manage them

00:10:39,900 --> 00:10:44,550
dynamically so that's we're gonna head

00:10:41,420 --> 00:10:46,440
so we have something called M config and

00:10:44,550 --> 00:10:48,150
production and fig when you hear me

00:10:46,440 --> 00:10:50,160
saying M config and fig it's really the

00:10:48,150 --> 00:10:52,290
same thing but the MM config is the

00:10:50,160 --> 00:10:54,540
disk-based version of this and fig as

00:10:52,290 --> 00:10:55,860
the is the newer service based model

00:10:54,540 --> 00:10:58,650
that we're currently a middle of

00:10:55,860 --> 00:11:00,660
migrating on - so just same concept but

00:10:58,650 --> 00:11:02,280
once completely restful and all of that

00:11:00,660 --> 00:11:05,670
and then the other is just based on like

00:11:02,280 --> 00:11:07,290
grabbing the ml files off of disk so and

00:11:05,670 --> 00:11:10,050
a little look at sort of simplified

00:11:07,290 --> 00:11:12,660
infrastructure of this we really want to

00:11:10,050 --> 00:11:15,089
expose to our workstations and our

00:11:12,660 --> 00:11:18,690
render farm the exact same environments

00:11:15,089 --> 00:11:20,400
so it's kind of important to just take a

00:11:18,690 --> 00:11:21,990
quick peek at how your overall

00:11:20,400 --> 00:11:22,240
infrastructure is and make sure that

00:11:21,990 --> 00:11:24,130
this

00:11:22,240 --> 00:11:26,440
something that works and very

00:11:24,130 --> 00:11:28,510
importantly for optimisation reasons

00:11:26,440 --> 00:11:30,250
it's important to expose a memcache D

00:11:28,510 --> 00:11:32,140
server to res because we're able to

00:11:30,250 --> 00:11:34,990
catch the resolves and you'll see later

00:11:32,140 --> 00:11:37,570
on some metrics about exactly how much

00:11:34,990 --> 00:11:39,520
the caching is helping us out and at the

00:11:37,570 --> 00:11:41,470
bottom here I just want to really stress

00:11:39,520 --> 00:11:43,420
that we've got some replication of our

00:11:41,470 --> 00:11:45,430
files in our database stuff to other

00:11:43,420 --> 00:11:47,080
sites so what's really neat about the

00:11:45,430 --> 00:11:49,300
system is I'm changing something in New

00:11:47,080 --> 00:11:51,070
York and that same exact definition is

00:11:49,300 --> 00:11:52,570
changing in Vancouver and LA and

00:11:51,070 --> 00:11:55,089
everywhere else at the same exact time

00:11:52,570 --> 00:11:57,399
so my entire facility is being upgraded

00:11:55,089 --> 00:12:02,050
at just by changing one file in one

00:11:57,399 --> 00:12:03,640
location here's a look at the sort of

00:12:02,050 --> 00:12:06,820
illustrating the EM production and M

00:12:03,640 --> 00:12:08,790
config system so what what M production

00:12:06,820 --> 00:12:10,930
is is abstracting sort of methods

00:12:08,790 --> 00:12:14,880
configuration of file system you know in

00:12:10,930 --> 00:12:19,180
a way so that I provide shards of

00:12:14,880 --> 00:12:23,080
requirements to res in a way that I'm

00:12:19,180 --> 00:12:25,990
able to associate with the in production

00:12:23,080 --> 00:12:27,399
entity that my facility or sorry that my

00:12:25,990 --> 00:12:29,829
artist is using so they're on a specific

00:12:27,399 --> 00:12:33,010
shot on a specific job and a specific

00:12:29,829 --> 00:12:34,570
task and production is kind of looking

00:12:33,010 --> 00:12:37,779
at the various places we can figure this

00:12:34,570 --> 00:12:40,209
data and in concert with fig which is

00:12:37,779 --> 00:12:42,670
actually performing the the merge of

00:12:40,209 --> 00:12:45,190
this information is presenting me with a

00:12:42,670 --> 00:12:47,680
final request that I've made so every

00:12:45,190 --> 00:12:49,300
single one of our you know at the

00:12:47,680 --> 00:12:52,140
facility level at the show level of the

00:12:49,300 --> 00:12:55,690
sequence and shot level we're able to

00:12:52,140 --> 00:12:57,790
completely override any given request

00:12:55,690 --> 00:12:59,649
for any given tool that's being

00:12:57,790 --> 00:13:01,120
presented to the pipeline so at the end

00:12:59,649 --> 00:13:03,370
of the day what's happening is again the

00:13:01,120 --> 00:13:05,140
artist is running their new plus peeking

00:13:03,370 --> 00:13:07,029
tools and so it's merged together that

00:13:05,140 --> 00:13:09,880
request from our file system or from our

00:13:07,029 --> 00:13:12,970
service side and presenting essentially

00:13:09,880 --> 00:13:14,860
to res one flattened request that is the

00:13:12,970 --> 00:13:16,810
result of the entity that they are in

00:13:14,860 --> 00:13:19,750
and the way that has found the fragments

00:13:16,810 --> 00:13:22,690
of Y amel to merge together so res the

00:13:19,750 --> 00:13:24,610
resolve happens the tool runs and it's

00:13:22,690 --> 00:13:25,570
kind of also important to note that you

00:13:24,610 --> 00:13:27,520
know there's environment variables

00:13:25,570 --> 00:13:29,670
available to you in res that are going

00:13:27,520 --> 00:13:32,910
to pass into your DCC s that you can use

00:13:29,670 --> 00:13:34,230
and to guide the way that your your

00:13:32,910 --> 00:13:36,210
render farm will eventually handle

00:13:34,230 --> 00:13:39,300
things so we're passing in our timestamp

00:13:36,210 --> 00:13:41,130
of when the user did their MSS and

00:13:39,300 --> 00:13:43,080
passing in the request that's been used

00:13:41,130 --> 00:13:45,060
to the render farm so that the render

00:13:43,080 --> 00:13:48,900
farm can run exactly with the same code

00:13:45,060 --> 00:13:50,040
that the that the artist was using when

00:13:48,900 --> 00:13:51,450
they launched their application so

00:13:50,040 --> 00:13:53,760
there's no schism if someone launches a

00:13:51,450 --> 00:13:55,250
new app new a new new release of

00:13:53,760 --> 00:13:58,860
something it's not going to get into

00:13:55,250 --> 00:14:00,360
what the artist is using this is just

00:13:58,860 --> 00:14:02,010
kind of a little overview of just like

00:14:00,360 --> 00:14:04,410
the simplicity of this configuration so

00:14:02,010 --> 00:14:06,180
an example profile that is exposing

00:14:04,410 --> 00:14:07,890
these requirements and tools over on the

00:14:06,180 --> 00:14:09,510
left to saying well I needed a version

00:14:07,890 --> 00:14:10,800
of open image i/o a need a version open

00:14:09,510 --> 00:14:14,730
Colorado here are the tools that are

00:14:10,800 --> 00:14:18,000
exposed the views yeah Mel is how we is

00:14:14,730 --> 00:14:21,770
how we specify the suffix Inge prefixing

00:14:18,000 --> 00:14:26,580
of any given set of tools so you'll see

00:14:21,770 --> 00:14:28,470
that the Maya set of stuff has a default

00:14:26,580 --> 00:14:30,840
of my 2018 at the moment in the facility

00:14:28,470 --> 00:14:33,480
and everything else has done prefix so

00:14:30,840 --> 00:14:36,210
you can access those individually also

00:14:33,480 --> 00:14:38,190
super helpfully until the software

00:14:36,210 --> 00:14:39,570
deployment system we had is is being

00:14:38,190 --> 00:14:42,210
moved to you we've used a system of

00:14:39,570 --> 00:14:46,290
locks that uses a cron syntax which is

00:14:42,210 --> 00:14:48,990
essentially driving the res - tee time

00:14:46,290 --> 00:14:50,580
flag so that new packages are only

00:14:48,990 --> 00:14:53,880
allowed into a resolve at a specific

00:14:50,580 --> 00:14:55,410
cron like time so for us the one method

00:14:53,880 --> 00:14:56,730
we found to be super helpful was that on

00:14:55,410 --> 00:14:58,740
Tuesdays Wednesdays and Thursdays at

00:14:56,730 --> 00:15:00,360
4:00 in the morning new packages are

00:14:58,740 --> 00:15:03,030
allowed in from the previous cycle

00:15:00,360 --> 00:15:04,410
because things break on Friday I have to

00:15:03,030 --> 00:15:05,880
get renders out for the weekend and I

00:15:04,410 --> 00:15:08,490
need Monday to fix whatever went wrong

00:15:05,880 --> 00:15:10,470
on the weekend and then from there we

00:15:08,490 --> 00:15:13,140
also just have a little like a shard of

00:15:10,470 --> 00:15:15,030
this common Amal which adds a request to

00:15:13,140 --> 00:15:16,830
every single profile that is in our

00:15:15,030 --> 00:15:19,050
system whatsoever so we can put common

00:15:16,830 --> 00:15:21,390
things there or common constraints like

00:15:19,050 --> 00:15:23,460
beak requirements on something important

00:15:21,390 --> 00:15:24,990
like our review system that needs to be

00:15:23,460 --> 00:15:26,880
a common version across an entire

00:15:24,990 --> 00:15:29,610
production or cost an entire facility

00:15:26,880 --> 00:15:32,520
and just a brief note about the software

00:15:29,610 --> 00:15:35,160
deployment system we're moving to so we

00:15:32,520 --> 00:15:37,880
have a method of taking service based a

00:15:35,160 --> 00:15:40,530
service based approach to essentially

00:15:37,880 --> 00:15:42,840
maintaining a raw unstable pre-release

00:15:40,530 --> 00:15:43,540
and stable set of packages where all the

00:15:42,840 --> 00:15:46,630
res builds

00:15:43,540 --> 00:15:48,910
against a common raw set of packages

00:15:46,630 --> 00:15:52,120
that are just the base res repository

00:15:48,910 --> 00:15:55,509
and then we essentially construct dummy

00:15:52,120 --> 00:15:57,759
packages that are copies or sim links to

00:15:55,509 --> 00:16:00,610
those packages in a new in a new

00:15:57,759 --> 00:16:02,769
location point artists as far as their

00:16:00,610 --> 00:16:04,630
package path is to a specific package

00:16:02,769 --> 00:16:06,579
view or channel or we have how you want

00:16:04,630 --> 00:16:08,920
to think about it and just kind of

00:16:06,579 --> 00:16:10,389
migrate this forward giving pipeline the

00:16:08,920 --> 00:16:12,790
ability to promote and demote from these

00:16:10,389 --> 00:16:14,410
various channels so that by the time

00:16:12,790 --> 00:16:16,089
something gets to pre-release and into

00:16:14,410 --> 00:16:18,550
stable it's already been vetted by a few

00:16:16,089 --> 00:16:21,519
key users that are identified TDS as

00:16:18,550 --> 00:16:24,699
people that are going to be working with

00:16:21,519 --> 00:16:26,410
this so a couple of metrics that are

00:16:24,699 --> 00:16:28,509
just kind of nice to look at and

00:16:26,410 --> 00:16:30,190
interesting to think about when thinking

00:16:28,509 --> 00:16:32,139
about the volume of resolves that might

00:16:30,190 --> 00:16:33,610
happen as we just said our farm is

00:16:32,139 --> 00:16:35,649
performing a res resolve it's not

00:16:33,610 --> 00:16:37,149
passing along an environment it's

00:16:35,649 --> 00:16:40,959
passing along the recipe to rebuild the

00:16:37,149 --> 00:16:43,209
environment so sorry can I go into a

00:16:40,959 --> 00:16:45,519
couple things here so on average we've

00:16:43,209 --> 00:16:48,970
got 8 requests in a profile and

00:16:45,519 --> 00:16:50,949
maximally 53 and in every four tools

00:16:48,970 --> 00:16:54,579
less than our profiles as on average

00:16:50,949 --> 00:16:59,230
it's 3 and 27 is our max I think that's

00:16:54,579 --> 00:17:02,560
our Houdini profiles the packages in our

00:16:59,230 --> 00:17:04,030
resolves generally speaking our resolves

00:17:02,560 --> 00:17:05,470
have averaged out at about a hundred and

00:17:04,030 --> 00:17:07,540
nine packages per resolve and the

00:17:05,470 --> 00:17:09,640
highest one I could find was my ax at

00:17:07,540 --> 00:17:10,500
three hundred and thirty which is as

00:17:09,640 --> 00:17:13,000
you'll see in the next slide

00:17:10,500 --> 00:17:16,059
approximately a third of our ecosystem

00:17:13,000 --> 00:17:18,189
so our my is a little bit heavy this is

00:17:16,059 --> 00:17:20,559
the breakdown of how many packages we

00:17:18,189 --> 00:17:21,939
have built internally and externally and

00:17:20,559 --> 00:17:23,860
you'll see that a huge portion of our

00:17:21,939 --> 00:17:26,140
external packages are individually

00:17:23,860 --> 00:17:28,150
packaged pip packages res is more than

00:17:26,140 --> 00:17:30,940
happy to handle this level of volume and

00:17:28,150 --> 00:17:32,500
granularity of course there are plenty

00:17:30,940 --> 00:17:34,419
of times where it's not worth packaging

00:17:32,500 --> 00:17:36,280
all the stuff individually there are

00:17:34,419 --> 00:17:39,280
sometimes meta packages where someone's

00:17:36,280 --> 00:17:40,600
taken ten pip requirements and just like

00:17:39,280 --> 00:17:41,860
shoved it into one package and calling

00:17:40,600 --> 00:17:45,549
it a day because sometimes you just need

00:17:41,860 --> 00:17:47,110
to get it done so this is our this is

00:17:45,549 --> 00:17:49,360
the config system metrics that are worth

00:17:47,110 --> 00:17:50,740
seeing it's worth keeping in mind that

00:17:49,360 --> 00:17:52,600
fig is not just fielding res

00:17:50,740 --> 00:17:54,700
configuration request is also fielding

00:17:52,600 --> 00:17:56,770
requests for every single package ax

00:17:54,700 --> 00:17:57,230
bowl configuration attribute in our

00:17:56,770 --> 00:17:59,059
system

00:17:57,230 --> 00:18:01,790
so and this isn't even in full

00:17:59,059 --> 00:18:03,110
production yet it's in it's in mostly in

00:18:01,790 --> 00:18:04,280
production in Vancouver right now and so

00:18:03,110 --> 00:18:06,980
that for example this is Vancouver

00:18:04,280 --> 00:18:09,500
metrics fielding 31 million config

00:18:06,980 --> 00:18:11,390
requests every this is you know in a

00:18:09,500 --> 00:18:14,570
week

00:18:11,390 --> 00:18:16,760
here's a 7-day slice of our resolve

00:18:14,570 --> 00:18:19,220
metrics and a 60 hour slice below that

00:18:16,760 --> 00:18:20,690
of the same same area where you can sort

00:18:19,220 --> 00:18:24,500
of see the heartbeat of our studio as

00:18:20,690 --> 00:18:28,490
people come online in mornings this is

00:18:24,500 --> 00:18:31,520
showing that in one site at a time we're

00:18:28,490 --> 00:18:33,470
peaking at about 25 results per second

00:18:31,520 --> 00:18:34,940
definitely a result of the render farm

00:18:33,470 --> 00:18:37,130
ability but we're able to handle it just

00:18:34,940 --> 00:18:40,910
fine and that comes up in the next

00:18:37,130 --> 00:18:43,280
little bit where we start looking at how

00:18:40,910 --> 00:18:45,620
resolves are cached and how how long

00:18:43,280 --> 00:18:49,820
uncashed resolves take this particular

00:18:45,620 --> 00:18:51,830
graph is histograms of the maximum

00:18:49,820 --> 00:18:53,990
resolved time for an uncashed resolved

00:18:51,830 --> 00:18:55,429
could be as high as 180 seconds in our

00:18:53,990 --> 00:18:57,380
facility it's very rare but it does

00:18:55,429 --> 00:18:57,980
happen like even if one resolved took a

00:18:57,380 --> 00:18:59,840
long time

00:18:57,980 --> 00:19:02,390
so imagine what's happening if your cash

00:18:59,840 --> 00:19:04,010
and resolves the first person to run

00:19:02,390 --> 00:19:05,600
nuke for the day is gonna experience a

00:19:04,010 --> 00:19:07,040
little lag time but then that resolve is

00:19:05,600 --> 00:19:09,200
now cached because that's when the

00:19:07,040 --> 00:19:11,179
package is changed and now everything

00:19:09,200 --> 00:19:13,970
every other user of that package is

00:19:11,179 --> 00:19:16,760
essentially using the same resolve on

00:19:13,970 --> 00:19:18,620
average though every uncashed resolve is

00:19:16,760 --> 00:19:22,940
three to seven seconds depending on this

00:19:18,620 --> 00:19:24,890
is a week worth of metric and and you'll

00:19:22,940 --> 00:19:26,240
see like the min for a given day is

00:19:24,890 --> 00:19:27,880
usually like zero to one because there's

00:19:26,240 --> 00:19:30,350
just results that are blindingly fast

00:19:27,880 --> 00:19:32,750
and here's a little bit of histogram of

00:19:30,350 --> 00:19:35,360
the ratio of caching so you'll see on

00:19:32,750 --> 00:19:39,200
the right with the pie chart that we're

00:19:35,360 --> 00:19:42,799
achieving a little bit this fluctuates a

00:19:39,200 --> 00:19:45,440
little bit but generally no more than 2%

00:19:42,799 --> 00:19:46,490
of resolves are uncashed in a given time

00:19:45,440 --> 00:19:48,049
and that's taking to account that

00:19:46,490 --> 00:19:50,120
artists are doing things like patching

00:19:48,049 --> 00:19:52,880
on a specific plugin or altering things

00:19:50,120 --> 00:19:54,460
a little bit slightly and you'll see at

00:19:52,880 --> 00:19:57,440
the very bottom that we're pulling

00:19:54,460 --> 00:20:00,080
500,000 resolves in a day only seven of

00:19:57,440 --> 00:20:02,720
which are uncashed so generally speaking

00:20:00,080 --> 00:20:04,490
this is a tremendous benefit and you'll

00:20:02,720 --> 00:20:06,890
remember back here when I said there was

00:20:04,490 --> 00:20:09,429
a max of 180 well on the top right what

00:20:06,890 --> 00:20:11,179
we're seeing is that in this week only

00:20:09,429 --> 00:20:13,789
25 resolves

00:20:11,179 --> 00:20:16,460
took more than 60 seconds and five took

00:20:13,789 --> 00:20:18,409
more than 120 so essentially like the

00:20:16,460 --> 00:20:19,940
number of slow resolves is extremely

00:20:18,409 --> 00:20:21,589
small and probably that was because

00:20:19,940 --> 00:20:23,719
someone was resolving something that was

00:20:21,589 --> 00:20:26,779
uncashed on a bogged down host that was

00:20:23,719 --> 00:20:29,570
not doing something terribly happy so

00:20:26,779 --> 00:20:31,159
just bear worth it's keeping in mind and

00:20:29,570 --> 00:20:34,129
on the left is just a histogram of how

00:20:31,159 --> 00:20:38,299
many the how many seconds each resolve

00:20:34,129 --> 00:20:40,309
each each resolve is taken

00:20:38,299 --> 00:20:42,679
we're also doing a lot of metrics based

00:20:40,309 --> 00:20:45,049
gathering so here we've got a breakdown

00:20:42,679 --> 00:20:47,509
of which packages were used in resolves

00:20:45,049 --> 00:20:49,460
at that point in time and we treat this

00:20:47,509 --> 00:20:52,339
very granular lis we can even do it by

00:20:49,460 --> 00:20:54,559
package version so we're able to sort of

00:20:52,339 --> 00:20:57,169
keep eyeballs on asking questions like

00:20:54,559 --> 00:20:58,820
how far are we to migrating on to a new

00:20:57,169 --> 00:21:02,119
version of something what's the what's

00:20:58,820 --> 00:21:04,099
our ability to be able to introspect

00:21:02,119 --> 00:21:05,979
into artists are actually using look at

00:21:04,099 --> 00:21:08,179
versions of things that have problems

00:21:05,979 --> 00:21:09,950
associate this with other metrics in our

00:21:08,179 --> 00:21:11,719
systems that are you know logging errors

00:21:09,950 --> 00:21:14,359
and seeing how we can move forward in

00:21:11,719 --> 00:21:16,489
our ecosystems in order to push you know

00:21:14,359 --> 00:21:17,869
push further into you know say Python 3

00:21:16,489 --> 00:21:20,480
usage and that kind of thing and Louis

00:21:17,869 --> 00:21:21,609
Python to 7 is our top used Python

00:21:20,480 --> 00:21:25,999
[Music]

00:21:21,609 --> 00:21:28,249
failed Sol's in a week 78 out of 3.8

00:21:25,999 --> 00:21:31,249
million it's pretty rare so it usually

00:21:28,249 --> 00:21:32,629
just developers so just really good to

00:21:31,249 --> 00:21:34,009
have this level of confidence in your

00:21:32,629 --> 00:21:35,419
system that generally speaking there

00:21:34,009 --> 00:21:38,960
aren't a ton of artists trying to run a

00:21:35,419 --> 00:21:42,349
tool and failing and just a little fun

00:21:38,960 --> 00:21:44,469
that's our maya graph just couldn't help

00:21:42,349 --> 00:21:44,469
myself

00:21:44,839 --> 00:21:49,789
next up so just a couple quick bits of

00:21:47,299 --> 00:21:51,830
advice things we found useful in general

00:21:49,789 --> 00:21:53,599
we find it super helpful to externalize

00:21:51,830 --> 00:21:55,969
our licensing details to some kind of

00:21:53,599 --> 00:21:58,009
like oh it's like the package needs the

00:21:55,969 --> 00:21:59,419
license but you don't need to read the

00:21:58,009 --> 00:22:00,889
license from the package you can read

00:21:59,419 --> 00:22:02,599
the license from some file outside so

00:22:00,889 --> 00:22:04,909
it's good to manage that separately

00:22:02,599 --> 00:22:06,320
stand not like a sign license servers

00:22:04,909 --> 00:22:07,729
into packages and then have to release

00:22:06,320 --> 00:22:10,580
something arbitrarily just kind of

00:22:07,729 --> 00:22:12,200
little silly we find people it's common

00:22:10,580 --> 00:22:13,429
to see that as a first pattern that

00:22:12,200 --> 00:22:14,869
people use and they're like aha why

00:22:13,429 --> 00:22:17,210
can't I change my package on the fly and

00:22:14,869 --> 00:22:19,579
then expect everything to work well as

00:22:17,210 --> 00:22:21,589
well as adaptive packages here's a sort

00:22:19,579 --> 00:22:23,599
of reactionary approach that a package

00:22:21,589 --> 00:22:24,830
is taking to the presence of other

00:22:23,599 --> 00:22:26,990
packages in the resolved

00:22:24,830 --> 00:22:30,019
so it can be useful to do things like

00:22:26,990 --> 00:22:31,490
check if if your resolve has Maya in it

00:22:30,019 --> 00:22:33,649
and react accordingly presents certain

00:22:31,490 --> 00:22:36,019
plugin paths in that way you can present

00:22:33,649 --> 00:22:37,399
just one variant or one mega variant of

00:22:36,019 --> 00:22:40,850
something that has a lot of components

00:22:37,399 --> 00:22:42,200
if if need be and simply add on features

00:22:40,850 --> 00:22:43,580
in a way and that's something that is

00:22:42,200 --> 00:22:47,630
going to get expounded on more with

00:22:43,580 --> 00:22:49,039
Alan's work we often get asked things

00:22:47,630 --> 00:22:50,600
about like what about configuration

00:22:49,039 --> 00:22:53,539
management what about details that have

00:22:50,600 --> 00:22:55,220
to do with say you want to alter

00:22:53,539 --> 00:22:56,980
something in a task-based way that

00:22:55,220 --> 00:23:00,320
somehow ties together with a package and

00:22:56,980 --> 00:23:01,789
the way our system works it's not always

00:23:00,320 --> 00:23:03,889
transparent to be able to do that but

00:23:01,789 --> 00:23:06,529
one thing that we found useful is res

00:23:03,889 --> 00:23:08,480
has a in its commands section has a

00:23:06,529 --> 00:23:11,809
command directive that can be used that

00:23:08,480 --> 00:23:13,250
injects things into the context SH file

00:23:11,809 --> 00:23:17,000
that's generated to produce the resolve

00:23:13,250 --> 00:23:19,940
for the user we've used a tool that

00:23:17,000 --> 00:23:22,789
basically at that point in time will

00:23:19,940 --> 00:23:24,559
look at the environment and react

00:23:22,789 --> 00:23:27,500
accordingly and do things essentially

00:23:24,559 --> 00:23:29,360
abstracting our tasks system and using

00:23:27,500 --> 00:23:31,190
the exact same configuration methodology

00:23:29,360 --> 00:23:33,289
as the EM production stuff where I can

00:23:31,190 --> 00:23:35,559
set context of show shot whatever all

00:23:33,289 --> 00:23:38,090
the stuff and sort of drill down and say

00:23:35,559 --> 00:23:40,250
if my ax is in there is in the

00:23:38,090 --> 00:23:42,200
environment and if the task is animation

00:23:40,250 --> 00:23:46,580
maybe I want a disable OCIO and it turns

00:23:42,200 --> 00:23:48,559
it off so it's I find it I find it wise

00:23:46,580 --> 00:23:50,539
to try to find a way to abstract what

00:23:48,559 --> 00:23:53,539
you might consider to be configuration

00:23:50,539 --> 00:23:55,549
management for yourself problems we

00:23:53,539 --> 00:23:59,720
experience we get mutual exclusivity

00:23:55,549 --> 00:24:02,059
issues where a good example would be for

00:23:59,720 --> 00:24:03,380
USD we build a katana variant and a Maya

00:24:02,059 --> 00:24:06,320
variant because we haven't quite broken

00:24:03,380 --> 00:24:08,690
it down into sub packages yet and then

00:24:06,320 --> 00:24:11,750
essentially we might have a resolve that

00:24:08,690 --> 00:24:13,250
actually has both Maya and katana in the

00:24:11,750 --> 00:24:16,100
environment for some other exotic

00:24:13,250 --> 00:24:18,080
reasons and res is going to pick one and

00:24:16,100 --> 00:24:19,490
can't be using two variants at the same

00:24:18,080 --> 00:24:22,549
time so that's the problem for us

00:24:19,490 --> 00:24:25,399
occasionally thankfully I think we have

00:24:22,549 --> 00:24:27,289
a solution for that on the way it's also

00:24:25,399 --> 00:24:29,179
hard to set up build chains that do

00:24:27,289 --> 00:24:31,789
things in a useful way when you want to

00:24:29,179 --> 00:24:33,559
clarify whether something is a release

00:24:31,789 --> 00:24:35,179
build or a debug build past that to see

00:24:33,559 --> 00:24:36,830
make be able to build multiple build

00:24:35,179 --> 00:24:37,510
chains one that's your debug build chain

00:24:36,830 --> 00:24:39,760
and once you're really

00:24:37,510 --> 00:24:41,890
they'll chain you can kind of do it with

00:24:39,760 --> 00:24:43,420
like sort of dummy packages that you use

00:24:41,890 --> 00:24:46,060
to alter your resolve but it gets come

00:24:43,420 --> 00:24:48,310
it gets cumbersome and extends file

00:24:46,060 --> 00:24:51,430
paths a little too long for comfort and

00:24:48,310 --> 00:24:52,720
so on similarly lack of negations and

00:24:51,430 --> 00:24:55,780
variance is definitely an issue for us

00:24:52,720 --> 00:24:59,200
right now where I may want to exclude

00:24:55,780 --> 00:25:00,550
everything in a specific variant and

00:24:59,200 --> 00:25:02,500
it's just not really possible to do that

00:25:00,550 --> 00:25:03,910
because file paths don't like

00:25:02,500 --> 00:25:07,060
exclamation marks all that well or our

00:25:03,910 --> 00:25:07,420
shells don't at least configuration

00:25:07,060 --> 00:25:08,410
management

00:25:07,420 --> 00:25:11,710
I was ready going into that a little bit

00:25:08,410 --> 00:25:13,800
so I'll skip over that and it's a common

00:25:11,710 --> 00:25:16,420
complaint with our system engineers that

00:25:13,800 --> 00:25:19,770
storing all of our packages on central

00:25:16,420 --> 00:25:22,090
file servers is a huge burden of i/o and

00:25:19,770 --> 00:25:23,920
querying these packages and pulling data

00:25:22,090 --> 00:25:26,230
together actually contributes to the

00:25:23,920 --> 00:25:28,390
overall load of the system we've started

00:25:26,230 --> 00:25:29,740
looking at localization strategies I'm

00:25:28,390 --> 00:25:31,150
led to believe I think that's that's

00:25:29,740 --> 00:25:32,560
something that a couple studios are

00:25:31,150 --> 00:25:35,050
dealing with they're localizing packages

00:25:32,560 --> 00:25:38,440
to their hosts will have something to

00:25:35,050 --> 00:25:39,790
say about that common thing is kind of

00:25:38,440 --> 00:25:41,440
the question of how far do you take this

00:25:39,790 --> 00:25:42,610
where do you where do you stop when

00:25:41,440 --> 00:25:44,490
you're trying to resolve dependencies

00:25:42,610 --> 00:25:46,210
when you're trying to make packages I

00:25:44,490 --> 00:25:48,580
we've definitely made the mistake of

00:25:46,210 --> 00:25:51,220
going too far at times where like we've

00:25:48,580 --> 00:25:52,930
gone so far back in system level

00:25:51,220 --> 00:25:55,510
dependencies that it became unwieldy on

00:25:52,930 --> 00:25:56,680
its own so it's good to like have talks

00:25:55,510 --> 00:25:58,240
with your system engineers and think

00:25:56,680 --> 00:25:59,620
about your use cases and how much

00:25:58,240 --> 00:26:01,180
exactly you need to represent in

00:25:59,620 --> 00:26:03,550
dependencies what do you actually need

00:26:01,180 --> 00:26:04,990
multiple versions of in production and

00:26:03,550 --> 00:26:08,110
what's provided by your operating system

00:26:04,990 --> 00:26:09,940
in a really clean way and yeah we're

00:26:08,110 --> 00:26:12,850
looking at how to do some performance

00:26:09,940 --> 00:26:14,620
testing with rest with the res tests

00:26:12,850 --> 00:26:17,590
themselves I don't mean res tests in the

00:26:14,620 --> 00:26:19,060
packages and once in a while like

00:26:17,590 --> 00:26:21,010
something weird happens with our resolve

00:26:19,060 --> 00:26:22,510
and it's kind of hard to debug when a

00:26:21,010 --> 00:26:24,580
backpedal happens when some new

00:26:22,510 --> 00:26:26,650
requirement is added and it backpedals

00:26:24,580 --> 00:26:28,150
your entire resolve like a huge distance

00:26:26,650 --> 00:26:30,130
back to some really older set of stuff

00:26:28,150 --> 00:26:32,700
it'd be nice to have something that

00:26:30,130 --> 00:26:36,420
could detect situations like that and

00:26:32,700 --> 00:26:36,420
with that I'll pass it over down

00:26:40,820 --> 00:26:46,230
thanks Steven okay so now I'm going to

00:26:43,830 --> 00:26:49,830
talk about where we're going in terms of

00:26:46,230 --> 00:26:52,260
development with res so we've introduced

00:26:49,830 --> 00:26:55,410
this new idea on the github project of

00:26:52,260 --> 00:26:57,210
reps of stolen the idea of peps there is

00:26:55,410 --> 00:26:59,580
enhancement proposals they're kind of

00:26:57,210 --> 00:27:02,580
analogous to epochs in agile so they'll

00:26:59,580 --> 00:27:04,440
describe a sub project within the res

00:27:02,580 --> 00:27:06,720
project and attempt to break it down

00:27:04,440 --> 00:27:10,080
into the tasks required to implement it

00:27:06,720 --> 00:27:12,960
and they're labeled as rep in the issues

00:27:10,080 --> 00:27:15,809
in github we have three reps at the

00:27:12,960 --> 00:27:17,640
moment we've got one based on some

00:27:15,809 --> 00:27:19,140
enhancements to res tests which I won't

00:27:17,640 --> 00:27:22,080
cover right right now it's a fairly

00:27:19,140 --> 00:27:23,880
minor point rep oo2 is the main one that

00:27:22,080 --> 00:27:26,100
I'll talk a lot about and that's getting

00:27:23,880 --> 00:27:27,240
us to the point where well I'll explain

00:27:26,100 --> 00:27:30,120
it in a second but it's called recipe

00:27:27,240 --> 00:27:32,460
repositories and repo 3 which I'll talk

00:27:30,120 --> 00:27:39,240
about now is something called package

00:27:32,460 --> 00:27:41,100
and context localization so localized

00:27:39,240 --> 00:27:43,530
means removing the need for external

00:27:41,100 --> 00:27:45,450
resources and by that I mean when you

00:27:43,530 --> 00:27:48,240
create a context by running rows em what

00:27:45,450 --> 00:27:49,950
doing what if you want to do there's

00:27:48,240 --> 00:27:51,540
currently two external resources you

00:27:49,950 --> 00:27:53,520
typically need you need to access

00:27:51,540 --> 00:27:55,320
memcache D in order to pull down the

00:27:53,520 --> 00:27:57,140
entire package definition to get the

00:27:55,320 --> 00:28:00,450
commands to configure the environment

00:27:57,140 --> 00:28:02,490
and you also typically need access over

00:28:00,450 --> 00:28:04,260
NFS to get to the to the package

00:28:02,490 --> 00:28:05,669
installation and as Stephan already

00:28:04,260 --> 00:28:09,290
mentioned that can be problematic and

00:28:05,669 --> 00:28:13,919
put a lot of load on the filer

00:28:09,290 --> 00:28:15,480
so why localized there's two reasons one

00:28:13,919 --> 00:28:17,280
as I just mentioned is to speed things

00:28:15,480 --> 00:28:19,260
up with regard to performance and stop

00:28:17,280 --> 00:28:20,730
feeding the filer so much but the other

00:28:19,260 --> 00:28:23,510
reason is because you might want some

00:28:20,730 --> 00:28:28,799
sort of standalone installation

00:28:23,510 --> 00:28:30,360
particularly for services for example so

00:28:28,799 --> 00:28:32,190
this is what happens currently you

00:28:30,360 --> 00:28:33,390
create a context and in a context it

00:28:32,190 --> 00:28:35,340
contains these things called variant

00:28:33,390 --> 00:28:37,440
handles just small metadata dictionaries

00:28:35,340 --> 00:28:41,990
that give enough information to be able

00:28:37,440 --> 00:28:44,669
to fetch the entire package definition

00:28:41,990 --> 00:28:45,780
when you source one of those contexts it

00:28:44,669 --> 00:28:47,490
will then create the resolving

00:28:45,780 --> 00:28:49,290
environment the process running inside

00:28:47,490 --> 00:28:51,630
that environment is typically in a hit

00:28:49,290 --> 00:28:56,070
and a first in order to pull down Python

00:28:51,630 --> 00:28:59,190
Python sauce files so by localizing both

00:28:56,070 --> 00:29:02,070
of those things you remove any

00:28:59,190 --> 00:29:03,840
externalities so the package definitions

00:29:02,070 --> 00:29:05,820
themselves end up completely embedded

00:29:03,840 --> 00:29:09,300
into the context which just results in a

00:29:05,820 --> 00:29:11,760
larger JSON file basically and the

00:29:09,300 --> 00:29:13,500
process you run will end up on hitting

00:29:11,760 --> 00:29:19,260
package payloads that are actually on

00:29:13,500 --> 00:29:20,370
the local disk instead to give you

00:29:19,260 --> 00:29:22,290
fine-grained control

00:29:20,370 --> 00:29:24,240
there'll be a new tool that that does

00:29:22,290 --> 00:29:26,790
this that allows you to do this and I've

00:29:24,240 --> 00:29:28,500
got some examples here so you may have

00:29:26,790 --> 00:29:31,380
an existing context and you want to then

00:29:28,500 --> 00:29:33,900
populate a localized package cache with

00:29:31,380 --> 00:29:36,360
its variants so you'd be able to do that

00:29:33,900 --> 00:29:39,240
you'd be able to just introspect the the

00:29:36,360 --> 00:29:41,250
cache directly you'll be able to create

00:29:39,240 --> 00:29:43,710
a context and explicitly associate that

00:29:41,250 --> 00:29:45,990
context with a given cache

00:29:43,710 --> 00:29:48,560
you might want to modify an existing

00:29:45,990 --> 00:29:50,790
cache and associate it with a different

00:29:48,560 --> 00:29:53,940
with the different cache context saurian

00:29:50,790 --> 00:29:55,200
as I said the different cache or you

00:29:53,940 --> 00:29:56,610
might want to source an existing context

00:29:55,200 --> 00:29:58,530
and override where the cache it had

00:29:56,610 --> 00:30:01,560
already specified if any so those are

00:29:58,530 --> 00:30:03,930
just some examples this is a more

00:30:01,560 --> 00:30:05,370
interesting case where you want to

00:30:03,930 --> 00:30:07,920
create a context that's entirely

00:30:05,370 --> 00:30:09,270
standalone so this example would create

00:30:07,920 --> 00:30:12,330
a directory that contains both the

00:30:09,270 --> 00:30:14,250
context and all of the variants of that

00:30:12,330 --> 00:30:15,810
context refers to you would then

00:30:14,250 --> 00:30:18,690
literally be able to just copy that onto

00:30:15,810 --> 00:30:21,900
a server or into a into an image or

00:30:18,690 --> 00:30:23,400
something into a containerized situation

00:30:21,900 --> 00:30:25,560
and have something running completely

00:30:23,400 --> 00:30:27,240
standalone the only prerequisite you

00:30:25,560 --> 00:30:28,770
need at that point is that res would

00:30:27,240 --> 00:30:34,200
have to be installed on the target

00:30:28,770 --> 00:30:36,240
system ok now on to the main the main

00:30:34,200 --> 00:30:39,260
point which is something called res

00:30:36,240 --> 00:30:41,430
repositories a recipe repository sorry

00:30:39,260 --> 00:30:43,650
so one of the biggest goals from res

00:30:41,430 --> 00:30:44,970
from the start has been to be able to

00:30:43,650 --> 00:30:46,440
install packages from public

00:30:44,970 --> 00:30:50,760
repositories much in the same way that

00:30:46,440 --> 00:30:52,530
something like pip can right now studios

00:30:50,760 --> 00:30:54,480
do spend a lot of time having to build

00:30:52,530 --> 00:30:58,400
their own packages and what we what we

00:30:54,480 --> 00:31:00,750
call Reza Phi packages as a result

00:30:58,400 --> 00:31:01,420
there's not really any sharing of

00:31:00,750 --> 00:31:03,400
package

00:31:01,420 --> 00:31:04,780
munitions across studios or all the

00:31:03,400 --> 00:31:06,820
build code associated with those and

00:31:04,780 --> 00:31:08,410
there's no standardization either in

00:31:06,820 --> 00:31:10,600
terms of what what particular variants

00:31:08,410 --> 00:31:14,230
might get created for a given package

00:31:10,600 --> 00:31:15,700
for example and so we're going to

00:31:14,230 --> 00:31:18,760
introduce a new tool called res install

00:31:15,700 --> 00:31:21,160
and that will install packages and

00:31:18,760 --> 00:31:23,110
package and its dependencies and also

00:31:21,160 --> 00:31:25,120
give you control over over the built

00:31:23,110 --> 00:31:26,680
configurations as well I'm going to show

00:31:25,120 --> 00:31:30,760
you how that is theoretically going to

00:31:26,680 --> 00:31:32,710
work so you can already write reusable

00:31:30,760 --> 00:31:36,700
package definitions that build the party

00:31:32,710 --> 00:31:38,440
software to an extent it's helped a lot

00:31:36,700 --> 00:31:41,860
by the fact that package definition

00:31:38,440 --> 00:31:44,170
files right now quite programmatic you

00:31:41,860 --> 00:31:46,000
have early and late down requirements up

00:31:44,170 --> 00:31:48,580
earlier late bound attributes that'll a

00:31:46,000 --> 00:31:50,470
to define something like the the

00:31:48,580 --> 00:31:53,740
requires section of a package as a

00:31:50,470 --> 00:31:55,450
function that's very very useful but we

00:31:53,740 --> 00:31:57,130
need to we need to build on that so the

00:31:55,450 --> 00:31:58,930
problems at the moment is no dependency

00:31:57,130 --> 00:32:01,200
tracking res build which is the tool

00:31:58,930 --> 00:32:05,320
used to build a package or res install

00:32:01,200 --> 00:32:06,940
doesn't determine and and build and

00:32:05,320 --> 00:32:10,030
install dependencies and shouldn't it's

00:32:06,940 --> 00:32:11,680
never been its job there's no build

00:32:10,030 --> 00:32:13,990
configuration support in the sense that

00:32:11,680 --> 00:32:15,370
you can hack around but it's it's quite

00:32:13,990 --> 00:32:16,690
difficult to say well I want to build a

00:32:15,370 --> 00:32:18,460
debug version of this package and

00:32:16,690 --> 00:32:20,950
release it as such and they have some

00:32:18,460 --> 00:32:22,690
other package or person consume that

00:32:20,950 --> 00:32:24,310
package but specifying that they want

00:32:22,690 --> 00:32:28,660
that they want to put that particular

00:32:24,310 --> 00:32:30,370
build type so here's an example of what

00:32:28,660 --> 00:32:31,690
res install will probably look like and

00:32:30,370 --> 00:32:35,170
I've just used open behavior here as an

00:32:31,690 --> 00:32:38,040
example so you'd pull down what's going

00:32:35,170 --> 00:32:40,360
to be called a well it's a recipe and

00:32:38,040 --> 00:32:41,740
recipes just contains standard package

00:32:40,360 --> 00:32:42,850
definitions exactly the same as you'd

00:32:41,740 --> 00:32:45,490
have when you build your package to

00:32:42,850 --> 00:32:46,840
apply it's no different but they reside

00:32:45,490 --> 00:32:49,150
on a different search path which is

00:32:46,840 --> 00:32:52,180
defined by Reza's recipes path rather

00:32:49,150 --> 00:32:54,250
than res packages path to inform res

00:32:52,180 --> 00:32:57,040
that they haven't been built yet and so

00:32:54,250 --> 00:32:58,900
it should expect some some things in

00:32:57,040 --> 00:33:00,430
that in that some build in that package

00:32:58,900 --> 00:33:03,640
definition that it wouldn't see in

00:33:00,430 --> 00:33:04,870
released packages and then it's going to

00:33:03,640 --> 00:33:06,160
go through and find some packages that

00:33:04,870 --> 00:33:08,680
need to be built and do that in the

00:33:06,160 --> 00:33:09,730
right order and then perhaps some that

00:33:08,680 --> 00:33:12,210
don't because they're already installed

00:33:09,730 --> 00:33:12,210
at the studio

00:33:12,559 --> 00:33:16,339
so yeah packet I already explained I

00:33:14,389 --> 00:33:20,839
think of what it's just now packages can

00:33:16,339 --> 00:33:22,070
exist in recipe repositories so their

00:33:20,839 --> 00:33:24,169
standard package definitions but what

00:33:22,070 --> 00:33:25,969
they do is they programmatically

00:33:24,169 --> 00:33:27,289
construct a single variant to be

00:33:25,969 --> 00:33:30,919
installed and that will make it a bit

00:33:27,289 --> 00:33:33,289
more sense in a second what it then does

00:33:30,919 --> 00:33:35,449
in order to determine what packages what

00:33:33,289 --> 00:33:38,109
what dependencies need to be built it

00:33:35,449 --> 00:33:39,889
actually will perform a standard resolve

00:33:38,109 --> 00:33:41,179
across both the rest of your

00:33:39,889 --> 00:33:43,699
repositories on whatever existing

00:33:41,179 --> 00:33:44,959
package repositories you have and then

00:33:43,699 --> 00:33:46,969
when you get the result of that result

00:33:44,959 --> 00:33:47,989
and you go up in a reverse dependency

00:33:46,969 --> 00:33:49,429
order that actually tells you what

00:33:47,989 --> 00:33:52,549
packages need to be built in order to

00:33:49,429 --> 00:33:54,409
satisfy all the requirements so here's

00:33:52,549 --> 00:33:56,329
what it looks like graphically res

00:33:54,409 --> 00:33:58,940
install so we want to install a it

00:33:56,329 --> 00:34:01,279
doesn't resolve the graph there shows

00:33:58,940 --> 00:34:02,149
you the resulting result and the green

00:34:01,279 --> 00:34:03,799
ones are the ones that have come from

00:34:02,149 --> 00:34:05,809
recipe repositories and so their

00:34:03,799 --> 00:34:07,639
packages that haven't been built yet so

00:34:05,809 --> 00:34:10,399
we then just traverse the graph from

00:34:07,639 --> 00:34:16,609
bottom to top and we build DNA in this

00:34:10,399 --> 00:34:20,359
case so package features are a crucial

00:34:16,609 --> 00:34:21,710
part of this this doesn't exist yet it's

00:34:20,359 --> 00:34:23,839
a way for package to describe their

00:34:21,710 --> 00:34:26,299
properties and so for example you might

00:34:23,839 --> 00:34:28,339
model the build mode of the package that

00:34:26,299 --> 00:34:30,109
you know it was built as a debugger

00:34:28,339 --> 00:34:31,609
release you describe that as a package

00:34:30,109 --> 00:34:33,349
which would be some information that's

00:34:31,609 --> 00:34:37,399
that's now available a runtime from that

00:34:33,349 --> 00:34:39,319
from that package definition features

00:34:37,399 --> 00:34:41,990
are listed in invariants much like

00:34:39,319 --> 00:34:44,569
normal requirements and both users or

00:34:41,990 --> 00:34:46,250
packages that request packages can

00:34:44,569 --> 00:34:49,129
request them by their features and I'll

00:34:46,250 --> 00:34:51,019
show you how that works in a second if a

00:34:49,129 --> 00:34:53,659
package feature is asked for then only

00:34:51,019 --> 00:34:58,490
packages with that feature can can be

00:34:53,659 --> 00:34:59,839
returned can match the request and

00:34:58,490 --> 00:35:01,220
they're based on something else that

00:34:59,839 --> 00:35:04,660
I'll explain in a second called the

00:35:01,220 --> 00:35:06,829
ephemeral packages so here's an example

00:35:04,660 --> 00:35:08,750
let's say you want version 1 or greater

00:35:06,829 --> 00:35:11,690
of some packaged food but you want it to

00:35:08,750 --> 00:35:12,769
be built in debug mode sorry you want to

00:35:11,690 --> 00:35:15,200
retrieve the version of food that was

00:35:12,769 --> 00:35:17,029
built in debug mode this is what that

00:35:15,200 --> 00:35:18,140
will look like so resin through one plus

00:35:17,029 --> 00:35:19,700
which are gonna be very familiar with

00:35:18,140 --> 00:35:21,259
but then you have this kind of odd

00:35:19,700 --> 00:35:23,420
syntax here which I'll explain shortly

00:35:21,259 --> 00:35:25,910
and this is actually requesting

00:35:23,420 --> 00:35:29,980
feature the feature in this case is the

00:35:25,910 --> 00:35:29,980
fact that food was built in debug mode

00:35:31,120 --> 00:35:37,940
so ephemeral packages are packages that

00:35:34,160 --> 00:35:42,250
don't exist which sounds odd but they'll

00:35:37,940 --> 00:35:44,210
be very useful they start with a dot

00:35:42,250 --> 00:35:46,430
currently packages can't start with a

00:35:44,210 --> 00:35:49,100
dot so that works out nicely because I

00:35:46,430 --> 00:35:50,900
won't be any clashing they behave the

00:35:49,100 --> 00:35:52,220
same way as standard packages but they

00:35:50,900 --> 00:35:55,610
never resolve to a version because they

00:35:52,220 --> 00:35:59,030
don't exist and it turns out there's a

00:35:55,610 --> 00:36:00,890
few different ways we can use these that

00:35:59,030 --> 00:36:02,450
the turn out to be quite useful one of

00:36:00,890 --> 00:36:04,880
them is to model a requirement of a

00:36:02,450 --> 00:36:07,040
package that is a bit of an abstract

00:36:04,880 --> 00:36:08,990
concept it's not actually a package and

00:36:07,040 --> 00:36:11,360
an example that you could that you could

00:36:08,990 --> 00:36:13,880
use to describe this is the platform in

00:36:11,360 --> 00:36:16,550
the current platform so for example for

00:36:13,880 --> 00:36:18,770
Linux it's it's an ephemeral thing you

00:36:16,550 --> 00:36:20,000
don't necessarily need to configure

00:36:18,770 --> 00:36:23,540
something in the environment or if like

00:36:20,000 --> 00:36:24,650
that depending on what your setup is it

00:36:23,540 --> 00:36:27,260
turns out also that you can use

00:36:24,650 --> 00:36:29,240
ephemeral as a general way to pass

00:36:27,260 --> 00:36:31,160
information to packages so that they can

00:36:29,240 --> 00:36:34,550
change their definitions or change their

00:36:31,160 --> 00:36:35,900
behavior and when they use this way they

00:36:34,550 --> 00:36:37,310
called a package option but there's

00:36:35,900 --> 00:36:39,710
nothing special about them besides that

00:36:37,310 --> 00:36:44,750
and the last point is that they also

00:36:39,710 --> 00:36:47,330
form the basis for package features so

00:36:44,750 --> 00:36:48,500
here's an example of a package option we

00:36:47,330 --> 00:36:49,700
have some package here and what it's

00:36:48,500 --> 00:36:53,510
going to do is it's going to check to

00:36:49,700 --> 00:36:57,620
see if an ephemeral is in the request

00:36:53,510 --> 00:36:59,720
called food CLI and if it falls within

00:36:57,620 --> 00:37:01,190
the version range 0 and if it does then

00:36:59,720 --> 00:37:03,320
it's going to take that to mean well I

00:37:01,190 --> 00:37:06,890
shouldn't make my my binaries available

00:37:03,320 --> 00:37:09,200
on path and then a user can can simply

00:37:06,890 --> 00:37:11,720
put that option in and you won't get

00:37:09,200 --> 00:37:13,580
those command-line tools bare mind also

00:37:11,720 --> 00:37:15,950
that packages would also be able to do

00:37:13,580 --> 00:37:17,150
this like everything else with requests

00:37:15,950 --> 00:37:19,250
in res there's no difference between

00:37:17,150 --> 00:37:21,020
what you can do as somebody using res m

00:37:19,250 --> 00:37:22,250
and what a package can do when it's

00:37:21,020 --> 00:37:25,690
requesting other packages

00:37:22,250 --> 00:37:27,800
so that's all it's all quite homogeneous

00:37:25,690 --> 00:37:29,210
so using a femorals as the basis for

00:37:27,800 --> 00:37:31,250
package options and features actually

00:37:29,210 --> 00:37:33,680
avoids a lot of extra complexity there's

00:37:31,250 --> 00:37:34,860
a lot of the behavior of packages that

00:37:33,680 --> 00:37:37,530
match the behavior of what we want

00:37:34,860 --> 00:37:39,420
see in these cases and it just means

00:37:37,530 --> 00:37:40,800
just means a lot of extra stuff in the

00:37:39,420 --> 00:37:42,870
code doesn't need to be added so just

00:37:40,800 --> 00:37:45,660
avoids complexity but it does also look

00:37:42,870 --> 00:37:47,940
a bit weird so we're gonna support some

00:37:45,660 --> 00:37:50,880
use some taxes so you can see here slash

00:37:47,940 --> 00:37:56,730
that's a going to specify an option and

00:37:50,880 --> 00:37:58,920
a colon will specify a feature so here's

00:37:56,730 --> 00:38:00,630
a full example recipe it's open BTB i've

00:37:58,920 --> 00:38:03,780
made it really really simple for for

00:38:00,630 --> 00:38:06,500
display purposes and i'll just run

00:38:03,780 --> 00:38:08,610
through it now so get debug is just a

00:38:06,500 --> 00:38:10,770
utility function that would get stripped

00:38:08,610 --> 00:38:13,440
when the package is released it's just

00:38:10,770 --> 00:38:15,360
figuring out if the debug feature has

00:38:13,440 --> 00:38:17,040
been asked for and says it's a 0 or 1

00:38:15,360 --> 00:38:19,230
accordingly and defaults to zero I mean

00:38:17,040 --> 00:38:21,990
you generally want to release pack a non

00:38:19,230 --> 00:38:24,800
debug package the crucial part of this

00:38:21,990 --> 00:38:27,210
is the variance section which is

00:38:24,800 --> 00:38:29,550
dynamically defining the requirements of

00:38:27,210 --> 00:38:33,950
this package as a response to a res

00:38:29,550 --> 00:38:36,930
install request so it has a bunch of

00:38:33,950 --> 00:38:38,790
packages in the in the list which are

00:38:36,930 --> 00:38:40,710
standard so it always requires boost

00:38:38,790 --> 00:38:42,660
styling based on open XR and avoids a

00:38:40,710 --> 00:38:44,280
particular version openexr but then what

00:38:42,660 --> 00:38:47,490
it does as well is it checks what the

00:38:44,280 --> 00:38:49,110
debug feature should be and then sets

00:38:47,490 --> 00:38:51,810
that feature in to its own requirements

00:38:49,110 --> 00:38:53,610
in response to the request from the user

00:38:51,810 --> 00:38:55,350
whose run res install so it's adapting

00:38:53,610 --> 00:38:58,260
to what's been asked for by the by the

00:38:55,350 --> 00:39:01,380
Installer and lastly just as a point

00:38:58,260 --> 00:39:03,720
here I've shown just a example scenario

00:39:01,380 --> 00:39:05,400
where it may be true that if open VB is

00:39:03,720 --> 00:39:07,400
getting built in debug mode and also

00:39:05,400 --> 00:39:13,710
wants access to a debug build a boost

00:39:07,400 --> 00:39:14,970
that's just by way of example so ok I've

00:39:13,710 --> 00:39:16,290
already explained packages dynamic the

00:39:14,970 --> 00:39:21,030
construct barriers to respond to the

00:39:16,290 --> 00:39:22,980
request a problem that this raises is

00:39:21,030 --> 00:39:25,230
that you're gonna get really weird long

00:39:22,980 --> 00:39:27,810
variants that are not necessarily POSIX

00:39:25,230 --> 00:39:31,380
compliant or will probably screw up

00:39:27,810 --> 00:39:33,930
build systems and shells so we have

00:39:31,380 --> 00:39:35,670
something new these are called hashed

00:39:33,930 --> 00:39:38,190
variants hash variants already

00:39:35,670 --> 00:39:39,840
implemented and they do away with the

00:39:38,190 --> 00:39:40,890
full very installation path which up

00:39:39,840 --> 00:39:43,290
till now has been based on the

00:39:40,890 --> 00:39:44,950
requirements of the variant and instead

00:39:43,290 --> 00:39:48,310
they they based on a hash

00:39:44,950 --> 00:39:49,480
now what you see here is not a hash it's

00:39:48,310 --> 00:39:51,730
something else called a short link a

00:39:49,480 --> 00:39:53,440
short link is just another process in

00:39:51,730 --> 00:39:55,570
the release that goes through and um

00:39:53,440 --> 00:39:57,880
just creates a very short version which

00:39:55,570 --> 00:39:59,140
is assembling to the hash and does it in

00:39:57,880 --> 00:40:00,940
a way that's not gonna it's not going to

00:39:59,140 --> 00:40:03,730
cause some conflicts within that already

00:40:00,940 --> 00:40:05,740
or any release package to do that you

00:40:03,730 --> 00:40:07,480
just add this new attribute called hash

00:40:05,740 --> 00:40:12,490
variance you said it's true and of your

00:40:07,480 --> 00:40:17,079
uncle we have a new type of requirements

00:40:12,490 --> 00:40:18,700
expansion so so what this is oftentimes

00:40:17,079 --> 00:40:21,579
I'll have a package that before it has

00:40:18,700 --> 00:40:23,020
been built is compatible with some large

00:40:21,579 --> 00:40:25,089
number of versions of a package but then

00:40:23,020 --> 00:40:27,040
after it's built and compiled and linked

00:40:25,089 --> 00:40:29,670
against whether that is then that turns

00:40:27,040 --> 00:40:32,560
into into a hardened requirement and so

00:40:29,670 --> 00:40:34,359
you can currently express that but it

00:40:32,560 --> 00:40:36,250
doesn't work too well as a few problems

00:40:34,359 --> 00:40:38,829
with it the syntax is too limiting and

00:40:36,250 --> 00:40:40,420
that expansion happens too early so I'm

00:40:38,829 --> 00:40:45,280
planning on replacing that completely

00:40:40,420 --> 00:40:46,359
with a new syntax and a new system the

00:40:45,280 --> 00:40:48,099
slash slash is something called a

00:40:46,359 --> 00:40:50,740
request directive it'll be it'll

00:40:48,099 --> 00:40:52,450
indicate that what's there is some kind

00:40:50,740 --> 00:40:57,369
of a modifier that alters the the

00:40:52,450 --> 00:40:59,410
request at some point provides

00:40:57,369 --> 00:41:01,060
functionality is something that has been

00:40:59,410 --> 00:41:03,609
thought about for a long time

00:41:01,060 --> 00:41:05,710
it's a specialization of package

00:41:03,609 --> 00:41:07,000
features and it's a way for a package to

00:41:05,710 --> 00:41:09,849
tell other packages that it also

00:41:07,000 --> 00:41:11,770
provides another package the classic

00:41:09,849 --> 00:41:16,450
case being the DCC that comes with

00:41:11,770 --> 00:41:17,859
Python what it will do is if the native

00:41:16,450 --> 00:41:19,180
version of that package is also present

00:41:17,859 --> 00:41:20,650
in a resolve it will effectively

00:41:19,180 --> 00:41:22,359
override it and will remove that

00:41:20,650 --> 00:41:24,069
packages ability to configure that so

00:41:22,359 --> 00:41:26,500
configure the environment and here we

00:41:24,069 --> 00:41:28,480
have an example of Maya expressing two

00:41:26,500 --> 00:41:34,180
other packages that it actually already

00:41:28,480 --> 00:41:36,190
provides provides Python this one's

00:41:34,180 --> 00:41:38,890
really interesting so Steven mentioned

00:41:36,190 --> 00:41:40,060
already that we have issues where there

00:41:38,890 --> 00:41:41,800
are cases where we can't reliably

00:41:40,060 --> 00:41:44,589
guarantee that a particular variant of

00:41:41,800 --> 00:41:45,490
the package will be chosen even though

00:41:44,589 --> 00:41:48,130
the rules the

00:41:45,490 --> 00:41:50,860
that do choose a very a completely

00:41:48,130 --> 00:41:54,310
deterministic it can be very hard to

00:41:50,860 --> 00:41:56,610
tell why your Maya variant wasn't chosen

00:41:54,310 --> 00:41:58,840
and instead you're Houdini one was or

00:41:56,610 --> 00:42:02,710
your variant that actually doesn't have

00:41:58,840 --> 00:42:05,850
a TCC was chosen so the way that we can

00:42:02,710 --> 00:42:08,140
solve that which is kind of neat is to

00:42:05,850 --> 00:42:10,540
consider all the requirements of a

00:42:08,140 --> 00:42:13,119
package as being features unto

00:42:10,540 --> 00:42:15,100
themselves and because now we can

00:42:13,119 --> 00:42:17,500
actually request package features we now

00:42:15,100 --> 00:42:19,660
have a way to say explicitly well I want

00:42:17,500 --> 00:42:22,420
a version of foo in this example shown

00:42:19,660 --> 00:42:24,340
here that actually requires Houdini and

00:42:22,420 --> 00:42:25,480
so now you've struck that down to only

00:42:24,340 --> 00:42:31,210
be able to select those variants that

00:42:25,480 --> 00:42:33,730
match that request the end goal of all

00:42:31,210 --> 00:42:35,410
this is to be able to install anything

00:42:33,730 --> 00:42:37,060
easily from the VFX reference platform

00:42:35,410 --> 00:42:38,910
which is where we really like to get to

00:42:37,060 --> 00:42:40,869
sometime next year

00:42:38,910 --> 00:42:42,280
with full control over the build

00:42:40,869 --> 00:42:45,430
configurations that you would need in

00:42:42,280 --> 00:42:46,840
order to do that and one example of how

00:42:45,430 --> 00:42:48,340
this would be used in practices that

00:42:46,840 --> 00:42:49,930
we'd also have a VFX reference platform

00:42:48,340 --> 00:42:52,540
package which just acts as like a bundle

00:42:49,930 --> 00:42:54,609
it would just be a big list of weak weak

00:42:52,540 --> 00:42:56,859
package references that they're just

00:42:54,609 --> 00:43:00,570
limited versions and here's an example

00:42:56,859 --> 00:43:02,170
of how you have your dres install USD

00:43:00,570 --> 00:43:04,750
specifically saying that you want to

00:43:02,170 --> 00:43:05,920
install the maya plugin for USD the -

00:43:04,750 --> 00:43:07,300
end is something i haven't really

00:43:05,920 --> 00:43:10,570
touched on but it's basically something

00:43:07,300 --> 00:43:12,430
that will be added to res build as well

00:43:10,570 --> 00:43:14,710
and res release mr. sway of narrowing

00:43:12,430 --> 00:43:16,240
the build environment so in this case

00:43:14,710 --> 00:43:18,820
your by adding the effects reference

00:43:16,240 --> 00:43:21,310
platform to the environment to the build

00:43:18,820 --> 00:43:23,200
environment sorry you will in effect be

00:43:21,310 --> 00:43:25,030
limiting the versions of USD to whatever

00:43:23,200 --> 00:43:26,290
the reference platform is specified so

00:43:25,030 --> 00:43:28,690
you don't have to know what that version

00:43:26,290 --> 00:43:33,580
is you just you just reference the

00:43:28,690 --> 00:43:34,570
reference platform loads more detail

00:43:33,580 --> 00:43:37,150
about everything I've just talked about

00:43:34,570 --> 00:43:38,800
are available on the wrap 0:02 ticket on

00:43:37,150 --> 00:43:44,200
the github projects and the links there

00:43:38,800 --> 00:43:45,490
it seemed easy to find other stuff were

00:43:44,200 --> 00:43:46,869
in the middle of pythons report at the

00:43:45,490 --> 00:43:49,330
moment it's coming along it should be

00:43:46,869 --> 00:43:50,830
ready I think reasonably soon Python 2

00:43:49,330 --> 00:43:52,810
will be supported at the same time you

00:43:50,830 --> 00:43:54,540
will not be forced to use Python 3 once

00:43:52,810 --> 00:43:56,220
that version of res is released

00:43:54,540 --> 00:43:57,930
the Installer Perez itself has been

00:43:56,220 --> 00:44:01,080
updated I won't get into details but

00:43:57,930 --> 00:44:03,480
it's it's modernized now and it's all

00:44:01,080 --> 00:44:05,040
going fine whole bunch of Windows fixes

00:44:03,480 --> 00:44:07,110
a new shell was added PowerShell support

00:44:05,040 --> 00:44:08,880
was added there's been a lot of work

00:44:07,110 --> 00:44:12,030
done on respit which is the integration

00:44:08,880 --> 00:44:15,690
tool that allows us to install pip and

00:44:12,030 --> 00:44:19,050
and a pip package converted to res

00:44:15,690 --> 00:44:21,180
packages lots and lots and lots of your

00:44:19,050 --> 00:44:27,450
packages can be reliably installed this

00:44:21,180 --> 00:44:28,890
way it also more correctly generates the

00:44:27,450 --> 00:44:31,740
matching variants and a res pocket

00:44:28,890 --> 00:44:34,440
analogous to the PIP package so for

00:44:31,740 --> 00:44:36,450
example if ap package is pure Python

00:44:34,440 --> 00:44:37,830
then it won't variant on the platform

00:44:36,450 --> 00:44:40,230
architecture and operating system for

00:44:37,830 --> 00:44:41,700
example it does some more things of that

00:44:40,230 --> 00:44:43,470
though and takes into account things in

00:44:41,700 --> 00:44:45,330
pip called environment markers which if

00:44:43,470 --> 00:44:47,490
you're a Python packaging geek you'll

00:44:45,330 --> 00:44:48,930
know about people extras aren't

00:44:47,490 --> 00:44:50,400
supported yet because they don't fit

00:44:48,930 --> 00:44:51,600
into the model res at the moment but

00:44:50,400 --> 00:44:53,670
when package features are there they

00:44:51,600 --> 00:44:55,340
will and it should be fairly trivial to

00:44:53,670 --> 00:44:58,170
support them in that point in time

00:44:55,340 --> 00:44:59,940
further work just very briefly further

00:44:58,170 --> 00:45:01,860
things that we can do resolver

00:44:59,940 --> 00:45:04,080
optimizations that will have to come I

00:45:01,860 --> 00:45:06,210
suspect that as a result of this kind of

00:45:04,080 --> 00:45:07,740
stuff which i've just talked about that

00:45:06,210 --> 00:45:09,090
you would tend to see more packages and

00:45:07,740 --> 00:45:11,340
more variants on the go in any given

00:45:09,090 --> 00:45:13,050
solve and so it's possible but that will

00:45:11,340 --> 00:45:16,080
cut that will cause some solve x to blow

00:45:13,050 --> 00:45:18,570
out further fortunately I think there's

00:45:16,080 --> 00:45:21,240
a lot of room for optimization still so

00:45:18,570 --> 00:45:22,980
that's good in order to optimize you

00:45:21,240 --> 00:45:24,360
need to know how long souls take and

00:45:22,980 --> 00:45:27,030
it's very difficult to do that right now

00:45:24,360 --> 00:45:28,920
because they can vary a lot from one

00:45:27,030 --> 00:45:32,010
cell to another so we really need a

00:45:28,920 --> 00:45:35,010
benchmarking suite and I'd quite like to

00:45:32,010 --> 00:45:36,390
take our suite of packages from method

00:45:35,010 --> 00:45:38,310
and anonymize it and put it into one big

00:45:36,390 --> 00:45:39,900
repo and have a whole bunch of results

00:45:38,310 --> 00:45:41,220
you can graph out the results and then

00:45:39,900 --> 00:45:43,620
you can really see what differences

00:45:41,220 --> 00:45:45,510
occur short of python pass so long

00:45:43,620 --> 00:45:47,550
Python path is a big deal I won't get

00:45:45,510 --> 00:45:49,050
into now cuz running out of time but

00:45:47,550 --> 00:45:50,250
we've got that in mind and better

00:45:49,050 --> 00:45:51,420
environment variable management and I'm

00:45:50,250 --> 00:45:54,450
going to stop there cos we need to

00:45:51,420 --> 00:45:57,990
hasn't your name governance is changing

00:45:54,450 --> 00:45:59,190
I've been B DFL and it would be good to

00:45:57,990 --> 00:46:00,480
change that because it's just it's

00:45:59,190 --> 00:46:00,710
becoming too much work and I really want

00:46:00,480 --> 00:46:03,380
to keep

00:46:00,710 --> 00:46:05,119
project moving board a small group of

00:46:03,380 --> 00:46:07,790
collaborators have actually been added

00:46:05,119 --> 00:46:11,589
as of now but I am open to a new

00:46:07,790 --> 00:46:11,589
governance model in the coming year

00:46:12,609 --> 00:46:16,670
anyone who wants to get involved please

00:46:14,359 --> 00:46:18,050
- there's 17 tickets listed our repo -

00:46:16,670 --> 00:46:21,970
already so that probably means there's

00:46:18,050 --> 00:46:24,380
loads more thank you to all contributors

00:46:21,970 --> 00:46:25,630
any questions

00:46:24,380 --> 00:46:28,820
[Applause]

00:46:25,630 --> 00:46:28,820

YouTube URL: https://www.youtube.com/watch?v=y5VSPeeqJbM


