Title: Higher Order Components - ReactJS Girls  - November 17
Publication date: 2018-02-10
Playlist: ReactJS Girls
Description: 
	Van Le (https://twitter.com/vannio/) - Software Engineer @ Wonderbly (https://twitter.com/wonderblyHQ)

A HOC isn't just the noise you make when you have a winter cough, it's also a Higher Order Component! HOCs can be used as an elegant, expressive design pattern that will change the way you build React Components. This talk will cover the anatomy of a HOC and some super useful examples of what they can be used for.

About Van:

Van is a full-stack engineer at Wonderbly (formerly Lost My Name), and accidentally became a developer after coming from a background in Science and Comms.

_________________________________________________________________

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,000 --> 00:00:05,250
hi everyone I'm van I am software

00:00:03,540 --> 00:00:07,200
engineer and I work a company could

00:00:05,250 --> 00:00:09,480
wonder bleah so I've been working with

00:00:07,200 --> 00:00:10,980
react for about a year now so I'd

00:00:09,480 --> 00:00:13,950
probably done what most of you guys have

00:00:10,980 --> 00:00:16,770
done and I've done like tutorials and I

00:00:13,950 --> 00:00:20,220
wrote a to-do list but it wasn't like

00:00:16,770 --> 00:00:21,750
useful or very inspiring and then I

00:00:20,220 --> 00:00:23,730
joined the company and they showed me

00:00:21,750 --> 00:00:27,900
code like this and I was like what's

00:00:23,730 --> 00:00:29,519
going on here so the most like the only

00:00:27,900 --> 00:00:32,579
familiar part really was this like

00:00:29,519 --> 00:00:34,770
button and some prop types and then I

00:00:32,579 --> 00:00:36,630
saw this stuff like enhanced bear which

00:00:34,770 --> 00:00:39,090
confused the hell out of me I was like

00:00:36,630 --> 00:00:41,730
why do bears me to be enhanced it's very

00:00:39,090 --> 00:00:44,160
strange and then one of my colleagues

00:00:41,730 --> 00:00:45,660
gonna sat me down and explained it and

00:00:44,160 --> 00:00:47,309
walk through it so that's why I'm here

00:00:45,660 --> 00:00:53,340
today because I want to kind of share my

00:00:47,309 --> 00:00:56,219
knowledge so in order to look at higher

00:00:53,340 --> 00:00:57,899
order components we need to kind of go

00:00:56,219 --> 00:01:01,800
over some basic terminology for

00:00:57,899 --> 00:01:03,780
functional programming so this okay so

00:01:01,800 --> 00:01:05,760
functional programming is the process of

00:01:03,780 --> 00:01:11,670
building software by composing pure

00:01:05,760 --> 00:01:16,200
functions so a pure function is

00:01:11,670 --> 00:01:18,409
something like this this is a really

00:01:16,200 --> 00:01:22,850
simple one it adds two numbers together

00:01:18,409 --> 00:01:25,350
any number that you pass into it it's

00:01:22,850 --> 00:01:28,890
you'll always get the expected result

00:01:25,350 --> 00:01:30,869
there's nothing that can change it's

00:01:28,890 --> 00:01:33,390
really easy to test because you just get

00:01:30,869 --> 00:01:36,600
the two numbers it doesn't rely on

00:01:33,390 --> 00:01:39,540
anything outside of the function and

00:01:36,600 --> 00:01:41,700
it's great this is an example of an

00:01:39,540 --> 00:01:46,140
impure function so you've got X where

00:01:41,700 --> 00:01:47,850
I've introduced shared state so someone

00:01:46,140 --> 00:01:51,329
could come along and change the value of

00:01:47,850 --> 00:01:53,100
X and then if someone else tried to use

00:01:51,329 --> 00:01:54,540
the bad sum function they wouldn't

00:01:53,100 --> 00:01:58,979
really understand what's going to come

00:01:54,540 --> 00:02:01,320
out of it impure functions okay

00:01:58,979 --> 00:02:04,439
so the next thing is a higher-order

00:02:01,320 --> 00:02:06,360
function quite simply it's a function

00:02:04,439 --> 00:02:10,039
that expects a function as an argument

00:02:06,360 --> 00:02:13,200
and then it returns a new function and

00:02:10,039 --> 00:02:16,830
I'll go over this a bit further

00:02:13,200 --> 00:02:19,860
in the next part okay so I'm gonna talk

00:02:16,830 --> 00:02:23,099
about higher-order components now in a

00:02:19,860 --> 00:02:26,010
similar way to high order functions it

00:02:23,099 --> 00:02:29,190
will take in a component and return a

00:02:26,010 --> 00:02:30,900
slightly different component high order

00:02:29,190 --> 00:02:34,560
functions and higher order components

00:02:30,900 --> 00:02:42,890
are pure functions again no side effects

00:02:34,560 --> 00:02:45,060
no mutations and so on so that's the

00:02:42,890 --> 00:02:46,380
that's the definition of a high order

00:02:45,060 --> 00:02:50,190
function you can see it's not very

00:02:46,380 --> 00:02:52,709
different from high order component so I

00:02:50,190 --> 00:02:55,019
like to use this analogy for a high

00:02:52,709 --> 00:02:57,330
order component that's a caterpillar

00:02:55,019 --> 00:03:00,690
turning into a butterfly so if you think

00:02:57,330 --> 00:03:02,730
of the cocoon as a high order component

00:03:00,690 --> 00:03:05,100
you have a caterpillar that kind of goes

00:03:02,730 --> 00:03:08,370
into it does some transformations and it

00:03:05,100 --> 00:03:11,250
comes out as a butterfly it's the same

00:03:08,370 --> 00:03:14,220
thing but slightly different and kind of

00:03:11,250 --> 00:03:18,900
supercharged and that's how I see how do

00:03:14,220 --> 00:03:23,310
I order components so this is an example

00:03:18,900 --> 00:03:25,500
of really basic highroad a component can

00:03:23,310 --> 00:03:29,340
see it's a function it takes in a

00:03:25,500 --> 00:03:31,440
component and then it wraps it in a new

00:03:29,340 --> 00:03:34,410
component and then renders the original

00:03:31,440 --> 00:03:36,450
component it adds some stuff list of

00:03:34,410 --> 00:03:42,329
bears because the component needs a list

00:03:36,450 --> 00:03:45,630
of bears okay so in summary higher-order

00:03:42,329 --> 00:03:48,690
components are pure functions it means

00:03:45,630 --> 00:03:52,530
you can clean up a component and take

00:03:48,690 --> 00:03:55,290
out all the handlers any lifecycle

00:03:52,530 --> 00:03:57,030
methods and stuff separate them out so

00:03:55,290 --> 00:03:59,269
that you have a pure presentation or

00:03:57,030 --> 00:04:02,819
function bear presentational component

00:03:59,269 --> 00:04:04,470
it's a lot easier to read and then if

00:04:02,819 --> 00:04:06,560
you have a bunch of higher-order

00:04:04,470 --> 00:04:09,329
components you can reuse them and wrap

00:04:06,560 --> 00:04:13,470
multiple components with them elsewhere

00:04:09,329 --> 00:04:15,450
in your code so we're going to take a

00:04:13,470 --> 00:04:18,299
step back into functional programming

00:04:15,450 --> 00:04:20,430
just to cover one last thing function

00:04:18,299 --> 00:04:22,560
composition and it's the act of putting

00:04:20,430 --> 00:04:24,750
two functions together to form a third

00:04:22,560 --> 00:04:27,090
function where the output of one

00:04:24,750 --> 00:04:29,310
function is the input of an

00:04:27,090 --> 00:04:34,530
the more I look at the sentence the more

00:04:29,310 --> 00:04:36,290
confusing it gets so hopefully this will

00:04:34,530 --> 00:04:38,760
clear up a little bit so I've got two

00:04:36,290 --> 00:04:40,710
basic functions one that triples a

00:04:38,760 --> 00:04:43,070
number and another function that will

00:04:40,710 --> 00:04:46,200
round that up to the nearest whole digit

00:04:43,070 --> 00:04:49,130
and then the third function is like a

00:04:46,200 --> 00:04:53,640
mishmash of the two together and that's

00:04:49,130 --> 00:04:56,600
composition it's just multiple functions

00:04:53,640 --> 00:04:56,600
chained together

00:04:59,480 --> 00:05:04,470
so to recap pure functions are

00:05:02,010 --> 00:05:05,550
predictable they don't allow for any

00:05:04,470 --> 00:05:08,490
side effects

00:05:05,550 --> 00:05:11,370
they don't mutate any data elsewhere and

00:05:08,490 --> 00:05:13,470
there's no shared state high order

00:05:11,370 --> 00:05:15,510
function is a pure function that returns

00:05:13,470 --> 00:05:17,430
another function a higher order

00:05:15,510 --> 00:05:19,290
component is a type of higher order

00:05:17,430 --> 00:05:22,410
function that returns a component

00:05:19,290 --> 00:05:25,790
instead of a function and composition is

00:05:22,410 --> 00:05:30,060
the act of merging them all together

00:05:25,790 --> 00:05:33,930
okay so we use a library at wonderly

00:05:30,060 --> 00:05:35,430
called recompose which makes chaining up

00:05:33,930 --> 00:05:37,550
of higher-order components really nice

00:05:35,430 --> 00:05:40,130
this is an example of not using

00:05:37,550 --> 00:05:41,550
recomposed so you can see it's a bit

00:05:40,130 --> 00:05:44,100
confusing

00:05:41,550 --> 00:05:47,610
there's loads of like nested function

00:05:44,100 --> 00:05:49,260
calls and if you're going to wrap more

00:05:47,610 --> 00:05:52,830
higher components on it it's just going

00:05:49,260 --> 00:05:54,840
to look horrible and messy so this is

00:05:52,830 --> 00:05:57,150
what recompose does so you've got a

00:05:54,840 --> 00:06:00,060
compose function and now you can list or

00:05:57,150 --> 00:06:04,350
your higher-order components in order it

00:06:00,060 --> 00:06:05,760
makes sense it's readable someone else

00:06:04,350 --> 00:06:10,440
can jump in on the project and know

00:06:05,760 --> 00:06:12,270
what's going to go on so then we go back

00:06:10,440 --> 00:06:14,370
to the original code where I was really

00:06:12,270 --> 00:06:15,840
confused and now it can break it down so

00:06:14,370 --> 00:06:18,750
you've got your connect which is your

00:06:15,840 --> 00:06:20,940
redox tour if you use it with tracking

00:06:18,750 --> 00:06:23,670
as our own higher-order component with

00:06:20,940 --> 00:06:26,040
handlers as part of recompose that adds

00:06:23,670 --> 00:06:27,600
in a bunch of functions and then map

00:06:26,040 --> 00:06:31,440
translations of their own so now we can

00:06:27,600 --> 00:06:32,940
see what each of the things is doing and

00:06:31,440 --> 00:06:35,570
you wrap it around the original function

00:06:32,940 --> 00:06:38,520
and then that's that

00:06:35,570 --> 00:06:39,880
so recompose also has a bunch of other

00:06:38,520 --> 00:06:42,040
utility functions

00:06:39,880 --> 00:06:44,560
so we've got with props where you can

00:06:42,040 --> 00:06:48,610
pass extra data to your original

00:06:44,560 --> 00:06:52,410
component with state and with handlers

00:06:48,610 --> 00:06:55,600
work together with state allows you to

00:06:52,410 --> 00:06:58,240
have internal state for your component

00:06:55,600 --> 00:07:02,110
rather than global state using the Redux

00:06:58,240 --> 00:07:05,830
tour handlers are like what happens when

00:07:02,110 --> 00:07:07,030
you click a button but it means you can

00:07:05,830 --> 00:07:10,590
take you all of this out of your

00:07:07,030 --> 00:07:13,600
component and separate the concerns

00:07:10,590 --> 00:07:15,790
branches and other goods on so the first

00:07:13,600 --> 00:07:17,800
argument it takes is an expression that

00:07:15,790 --> 00:07:20,860
evaluates to either like true or false

00:07:17,800 --> 00:07:23,890
and then depending off its true it will

00:07:20,860 --> 00:07:26,830
show the original component no it will

00:07:23,890 --> 00:07:30,700
show a loading spinner if it's false it

00:07:26,830 --> 00:07:32,350
will show the original component so this

00:07:30,700 --> 00:07:36,370
is a really useful one for conditional

00:07:32,350 --> 00:07:38,410
loading of rent of components lifecycle

00:07:36,370 --> 00:07:40,600
methods I mentioned earlier that you can

00:07:38,410 --> 00:07:44,590
pull out lifecycle methods from your

00:07:40,600 --> 00:07:46,990
react component this is really nice for

00:07:44,590 --> 00:07:50,830
just cleaning up your code and taking

00:07:46,990 --> 00:07:52,750
out the bloat from your components and

00:07:50,830 --> 00:07:56,260
then this is an example of them all

00:07:52,750 --> 00:07:59,250
chained together again it's pretty

00:07:56,260 --> 00:08:03,010
simple to see what what's going on

00:07:59,250 --> 00:08:04,990
you've got Redux you've got with Rooter

00:08:03,010 --> 00:08:07,660
which is reactor eater that handles all

00:08:04,990 --> 00:08:09,220
the routing with props you adding in

00:08:07,660 --> 00:08:12,970
extra props with state

00:08:09,220 --> 00:08:15,460
adding an internal state and then the

00:08:12,970 --> 00:08:17,560
component that it's wrapped around has

00:08:15,460 --> 00:08:21,220
access to everything here as like props

00:08:17,560 --> 00:08:23,970
dot is visible props dot set is visible

00:08:21,220 --> 00:08:23,970
and so on

00:08:24,600 --> 00:08:30,570
okay so I'm going to go through some

00:08:27,870 --> 00:08:34,890
examples of how we use higher-order

00:08:30,570 --> 00:08:37,740
components at Wonder Blee this is a

00:08:34,890 --> 00:08:41,400
pretty simple one so you can log what a

00:08:37,740 --> 00:08:44,220
component has as props this is really

00:08:41,400 --> 00:08:48,510
good for debugging especially if you've

00:08:44,220 --> 00:08:50,670
got some weird behavior somewhere so it

00:08:48,510 --> 00:08:52,080
takes in a component and then it does

00:08:50,670 --> 00:08:55,680
the logging of the props and then it

00:08:52,080 --> 00:08:57,960
returns the same component cleaning up

00:08:55,680 --> 00:09:00,270
props is a useful one so a component

00:08:57,960 --> 00:09:02,610
might have loads and loads of props

00:09:00,270 --> 00:09:07,200
coming into it and you might want to

00:09:02,610 --> 00:09:10,380
clear it up because it's it just cleaner

00:09:07,200 --> 00:09:15,270
to read component doesn't get too

00:09:10,380 --> 00:09:18,410
confused as to what's happening if you

00:09:15,270 --> 00:09:24,600
can use higher order components to

00:09:18,410 --> 00:09:27,150
create reusable sets of data so if you

00:09:24,600 --> 00:09:31,080
find you've got a component that needs

00:09:27,150 --> 00:09:34,050
the same shape of props quite often you

00:09:31,080 --> 00:09:37,470
can abstract that and use it multiple

00:09:34,050 --> 00:09:41,100
times in multiple areas and if you're

00:09:37,470 --> 00:09:44,340
going to do that you can export the prop

00:09:41,100 --> 00:09:48,230
type to shape as well so you don't have

00:09:44,340 --> 00:09:51,840
to declare this for multiple components

00:09:48,230 --> 00:09:54,060
we can use it for Google Analytics so if

00:09:51,840 --> 00:09:57,300
you've got event tracking on like button

00:09:54,060 --> 00:10:00,900
clicks you can separate that as their

00:09:57,300 --> 00:10:04,950
concern and like just have a Google

00:10:00,900 --> 00:10:08,040
Analytics high-order component you can

00:10:04,950 --> 00:10:10,080
use it for internationalization so we

00:10:08,040 --> 00:10:13,710
use a service called one sky that holds

00:10:10,080 --> 00:10:16,680
a bunch of keys like bear's bottom CTA

00:10:13,710 --> 00:10:18,990
and then we pass it a language and then

00:10:16,680 --> 00:10:20,760
the service once guy will give us the

00:10:18,990 --> 00:10:22,740
translated string in that particular

00:10:20,760 --> 00:10:26,240
language you can use a higher-order

00:10:22,740 --> 00:10:30,030
component to map the key with the string

00:10:26,240 --> 00:10:33,600
and then pass it to the component you

00:10:30,030 --> 00:10:37,110
can use it to create metadata so with

00:10:33,600 --> 00:10:39,149
ruther will tell you what path you're on

00:10:37,110 --> 00:10:41,550
and then you can use that to generate I

00:10:39,149 --> 00:10:46,500
know your H ref lungs or canonical

00:10:41,550 --> 00:10:49,080
lengths and so on and then finally you

00:10:46,500 --> 00:10:51,330
can use higher-order components to

00:10:49,080 --> 00:10:54,060
effect from an API this is technically

00:10:51,330 --> 00:10:56,490
not a pure function because it does some

00:10:54,060 --> 00:11:01,350
stuff and it's you know create some side

00:10:56,490 --> 00:11:03,959
effects but it might be useful so you

00:11:01,350 --> 00:11:05,850
can fetch from an API endpoint and then

00:11:03,959 --> 00:11:08,339
render a certain component if it's

00:11:05,850 --> 00:11:10,860
successful if it fails you can render an

00:11:08,339 --> 00:11:14,390
error message if it's pending you can

00:11:10,860 --> 00:11:17,940
render a loading spinner for example

00:11:14,390 --> 00:11:21,209
yeah so that's how we hire water

00:11:17,940 --> 00:11:24,180
components at wonderly that's actually

00:11:21,209 --> 00:11:25,709
the end of the talk I think I went

00:11:24,180 --> 00:11:28,079
through that a lot faster than I was

00:11:25,709 --> 00:11:31,079
meant to but if you've got any questions

00:11:28,079 --> 00:11:33,690
I will hang around for a little bit or

00:11:31,079 --> 00:11:38,869
you can tweet me thank you

00:11:33,690 --> 00:11:38,869

YouTube URL: https://www.youtube.com/watch?v=8_Rt_8vNVfw


