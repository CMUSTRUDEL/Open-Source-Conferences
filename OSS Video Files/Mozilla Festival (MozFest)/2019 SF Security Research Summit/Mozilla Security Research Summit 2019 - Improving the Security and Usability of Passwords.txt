Title: Mozilla Security Research Summit 2019 - Improving the Security and Usability of Passwords
Publication date: 2019-06-24
Playlist: 2019 SF Security Research Summit
Description: 
	Thomas Ristenpart - Improving the Security and Usability of Passwords

Talk from the 2019 SF Security Research Summit (https://events.mozilla.org/moz2019securityresearchsummit). This event is part of the Security Engineering University Relationship Framework (SURF) initiative, which aims to increase collaboration between Mozilla and the academic community. We would like to leverage academic talent to help explore security and privacy research problems, and to strengthen Mozilla's ties to the academic community. Mozilla security engineers aim to actively participate in the research community through thesis supervision, collaborations, placements and Mozilla-hosted security summits. For more info see: https://surf.mozilla.org/

Slides: https://drive.google.com/open?id=1Yo28Loa06ml5BnK5jM4AyIIa8sKO9zfZ
Captions: 
	00:00:00,000 --> 00:00:02,580
[Applause]

00:00:00,350 --> 00:00:04,680
all right so yeah today I'm gonna talk

00:00:02,580 --> 00:00:07,740
about not any of the things he listed I

00:00:04,680 --> 00:00:09,840
guess but about passwords and we all

00:00:07,740 --> 00:00:11,670
know passwords really well we use them

00:00:09,840 --> 00:00:14,280
every day for the purpose this talk

00:00:11,670 --> 00:00:15,480
we'll think of a pretty simple setting

00:00:14,280 --> 00:00:17,100
right where you have a login server

00:00:15,480 --> 00:00:20,520
maybe has hundreds of millions or even

00:00:17,100 --> 00:00:24,750
more accounts people register a password

00:00:20,520 --> 00:00:26,490
they log in at some point of course real

00:00:24,750 --> 00:00:28,470
production password and authentication

00:00:26,490 --> 00:00:29,789
systems are much more complicated than

00:00:28,470 --> 00:00:31,650
what we're talking about today there's

00:00:29,789 --> 00:00:33,329
all these soft machine learning based

00:00:31,650 --> 00:00:36,000
tools for detecting if it seems like

00:00:33,329 --> 00:00:38,910
it's a fraudulent login we have second

00:00:36,000 --> 00:00:41,010
factors and all this type of stuff will

00:00:38,910 --> 00:00:42,840
be glossing over those details just

00:00:41,010 --> 00:00:44,460
point out that all the stuff that we're

00:00:42,840 --> 00:00:46,860
talking about in the talk today is gonna

00:00:44,460 --> 00:00:50,399
be relevant and work in conjunction with

00:00:46,860 --> 00:00:52,079
those types of tools so we all hate

00:00:50,399 --> 00:00:54,000
passwords right they kind of suck

00:00:52,079 --> 00:00:57,239
there's lots of problems with them I'll

00:00:54,000 --> 00:00:59,489
just be focusing about a couple examples

00:00:57,239 --> 00:01:02,370
of things that are coming up with that

00:00:59,489 --> 00:01:04,049
our work is addressing so one is

00:01:02,370 --> 00:01:06,420
obviously we need to deal with password

00:01:04,049 --> 00:01:07,890
database compromises you know we can't a

00:01:06,420 --> 00:01:11,280
day doesn't go by when we hear about a

00:01:07,890 --> 00:01:13,560
new huge compromise these are being used

00:01:11,280 --> 00:01:15,180
increasingly now the the prevalence of

00:01:13,560 --> 00:01:18,450
password data on the web is being used

00:01:15,180 --> 00:01:20,939
to a fuel remote guessing attacks

00:01:18,450 --> 00:01:22,320
so-called credential stuffing attacks

00:01:20,939 --> 00:01:25,140
are one of the biggest sources of

00:01:22,320 --> 00:01:26,930
compromise these days and then the

00:01:25,140 --> 00:01:28,979
usability is a big pain right memory

00:01:26,930 --> 00:01:31,590
errors I always forget which passwords

00:01:28,979 --> 00:01:32,720
which you know typos people have trouble

00:01:31,590 --> 00:01:35,939
typing particularly complicated

00:01:32,720 --> 00:01:37,799
passwords and despite the you know

00:01:35,939 --> 00:01:39,659
potential for things like password

00:01:37,799 --> 00:01:43,200
managers including things like built

00:01:39,659 --> 00:01:46,229
into Firefox for dealing with this they

00:01:43,200 --> 00:01:49,079
don't seem to get be adopted quite

00:01:46,229 --> 00:01:50,790
widely so we've been doing a lot of work

00:01:49,079 --> 00:01:52,860
on various aspects of all those problems

00:01:50,790 --> 00:01:55,079
I'm just going to mostly touch upon two

00:01:52,860 --> 00:01:56,850
one is this very recent work on

00:01:55,079 --> 00:01:59,040
understanding a generalization of

00:01:56,850 --> 00:02:00,899
credential stuffing attacks what we've

00:01:59,040 --> 00:02:04,170
started calling credential tweaking

00:02:00,899 --> 00:02:06,869
attacks and in addition the first kind

00:02:04,170 --> 00:02:09,239
of defense that's that we're aware of

00:02:06,869 --> 00:02:10,739
proposed for dealing with this something

00:02:09,239 --> 00:02:12,150
we're calling personalized password

00:02:10,739 --> 00:02:13,020
strength meters I think this is

00:02:12,150 --> 00:02:16,110
something that I'm hoping

00:02:13,020 --> 00:02:20,070
that will get widely deployed at some

00:02:16,110 --> 00:02:21,390
point soon and then at the end time

00:02:20,070 --> 00:02:22,980
along I think all the time we'll talk

00:02:21,390 --> 00:02:24,600
through some of our work on type of

00:02:22,980 --> 00:02:26,100
tolerant password checking so trying to

00:02:24,600 --> 00:02:29,310
deal with this particular usability

00:02:26,100 --> 00:02:31,700
issue of miss typing your password when

00:02:29,310 --> 00:02:34,170
you're manually are entering it

00:02:31,700 --> 00:02:35,820
okay so first part will be on the

00:02:34,170 --> 00:02:37,110
security issues and definitely with

00:02:35,820 --> 00:02:39,840
security of passwords it's like

00:02:37,110 --> 00:02:42,210
impossible to avoid seeing headlines I

00:02:39,840 --> 00:02:43,650
guess this is the most recent one about

00:02:42,210 --> 00:02:46,320
Google having trouble with their

00:02:43,650 --> 00:02:47,700
plaintext passwords I guess the short

00:02:46,320 --> 00:02:49,410
answer to that question is that no it

00:02:47,700 --> 00:02:50,460
doesn't really affect you in the end I

00:02:49,410 --> 00:02:52,530
think they don't think there was

00:02:50,460 --> 00:02:55,200
actually any access to these passwords

00:02:52,530 --> 00:02:57,180
but still indicative of how companies

00:02:55,200 --> 00:02:59,940
have been having a hard time ensuring

00:02:57,180 --> 00:03:02,580
that they have proper properly secured

00:02:59,940 --> 00:03:05,250
password storage and then now the

00:03:02,580 --> 00:03:06,540
prevalence of these leaks is there you

00:03:05,250 --> 00:03:08,100
just get dumped on the web you know a

00:03:06,540 --> 00:03:10,530
paste bin or other parts of the

00:03:08,100 --> 00:03:12,420
so-called dark web and there's just tons

00:03:10,530 --> 00:03:15,180
and tons of data out there that is being

00:03:12,420 --> 00:03:17,130
used in attacks and so these types of

00:03:15,180 --> 00:03:18,870
headlines really speak to two of the

00:03:17,130 --> 00:03:21,180
more important threat models that come

00:03:18,870 --> 00:03:23,700
up with passwords and I'll just go over

00:03:21,180 --> 00:03:25,350
each of these in turn the first this

00:03:23,700 --> 00:03:27,209
issue of server compromised so had

00:03:25,350 --> 00:03:29,340
Google servers gone compromised with

00:03:27,209 --> 00:03:33,450
these plain text passwords that be a big

00:03:29,340 --> 00:03:34,890
problem right and so this motivates the

00:03:33,450 --> 00:03:38,100
need for password protections for

00:03:34,890 --> 00:03:42,209
storage and right now that kind of takes

00:03:38,100 --> 00:03:44,790
two parts the first is the use of slow

00:03:42,209 --> 00:03:46,709
hashing salting + slow hashing so you

00:03:44,790 --> 00:03:50,220
take a cryptographic hash function like

00:03:46,709 --> 00:03:52,800
sha-256 you choose a random salt per

00:03:50,220 --> 00:03:57,120
user accounts and you hash this over and

00:03:52,800 --> 00:03:59,100
over again right and this is that's the

00:03:57,120 --> 00:04:00,840
like kind of more traditional approach

00:03:59,100 --> 00:04:02,250
nowadays we also have these memory hard

00:04:00,840 --> 00:04:04,380
hash functions as well things like s

00:04:02,250 --> 00:04:06,000
crypt are gone to which are being

00:04:04,380 --> 00:04:07,920
increasingly deployed that not only take

00:04:06,000 --> 00:04:09,480
longer to compute the hash but also take

00:04:07,920 --> 00:04:13,500
up a bunch of memory when you're

00:04:09,480 --> 00:04:15,989
required to do that these are really

00:04:13,500 --> 00:04:17,850
useful because they slow down cracking

00:04:15,989 --> 00:04:19,919
attacks right when you reach the server

00:04:17,850 --> 00:04:22,350
you now have something like this that's

00:04:19,919 --> 00:04:24,060
stored in the server you have access the

00:04:22,350 --> 00:04:26,280
salts it's a public function so you can

00:04:24,060 --> 00:04:27,120
compute it as the attacker but it takes

00:04:26,280 --> 00:04:30,449
you longer to

00:04:27,120 --> 00:04:32,010
you each guess you might try against the

00:04:30,449 --> 00:04:35,360
the password hash and therefore slows

00:04:32,010 --> 00:04:37,350
down the attacks it doesn't prevent them

00:04:35,360 --> 00:04:41,160
and so that's something that has

00:04:37,350 --> 00:04:43,740
motivated using even further storage

00:04:41,160 --> 00:04:45,150
protections which are what I started

00:04:43,740 --> 00:04:47,660
calling backend crypto service I think

00:04:45,150 --> 00:04:49,410
other people call them that as well and

00:04:47,660 --> 00:04:51,030
the idea here is that we're gonna

00:04:49,410 --> 00:04:52,650
basically have a split trust model that

00:04:51,030 --> 00:04:54,090
we have a front end like log in service

00:04:52,650 --> 00:04:56,370
that actually is you know has access

00:04:54,090 --> 00:04:58,470
directly to the password hash database

00:04:56,370 --> 00:05:00,360
we're also going to have a separate

00:04:58,470 --> 00:05:02,789
system that has some type of secret

00:05:00,360 --> 00:05:04,740
cryptographic key and whenever we're

00:05:02,789 --> 00:05:06,389
going to check a password we now do kind

00:05:04,740 --> 00:05:08,250
of interact a protocol just a one round

00:05:06,389 --> 00:05:10,830
trip protocol to talk to that back-end

00:05:08,250 --> 00:05:16,229
crypto service to help us compute what

00:05:10,830 --> 00:05:18,360
is now a secretly keyed hash so you know

00:05:16,229 --> 00:05:20,910
companies like Facebook and others they

00:05:18,360 --> 00:05:22,650
use like just a keyed hash function like

00:05:20,910 --> 00:05:24,150
H Mac you just think about this is

00:05:22,650 --> 00:05:26,310
something like sha-256

00:05:24,150 --> 00:05:28,530
but the point is now that if you get

00:05:26,310 --> 00:05:30,180
access to that login server and you get

00:05:28,530 --> 00:05:32,610
actually that database you can't check

00:05:30,180 --> 00:05:34,139
password guesses now by yourself you

00:05:32,610 --> 00:05:38,340
have to go talk to this server someone

00:05:34,139 --> 00:05:39,690
who has this cryptographic key k a bunch

00:05:38,340 --> 00:05:40,979
of years ago we did some work on trying

00:05:39,690 --> 00:05:42,690
to improve these to like deal with

00:05:40,979 --> 00:05:44,940
various deficiencies of this H Mac

00:05:42,690 --> 00:05:47,070
approach like the fact that you may want

00:05:44,940 --> 00:05:48,570
to rotate this key K from time period to

00:05:47,070 --> 00:05:51,419
time period and that's hard to do if

00:05:48,570 --> 00:05:54,360
you're just using H Mac and also to

00:05:51,419 --> 00:05:55,830
support like outsourcing this key crypto

00:05:54,360 --> 00:05:57,150
service to third-party services you

00:05:55,830 --> 00:05:59,099
don't necessarily want to trust even

00:05:57,150 --> 00:06:01,380
with the hash of the password which is

00:05:59,099 --> 00:06:03,960
how this H Mac system approach works and

00:06:01,380 --> 00:06:06,419
support things like blinding and that's

00:06:03,960 --> 00:06:08,810
the system we call Pythia but I'm not

00:06:06,419 --> 00:06:12,270
going to talk about it in more detail

00:06:08,810 --> 00:06:14,070
ok so that's the first kind of important

00:06:12,270 --> 00:06:15,750
threat model and we have some pretty

00:06:14,070 --> 00:06:18,720
good approaches for helping deal with

00:06:15,750 --> 00:06:21,330
those types of issues the second big

00:06:18,720 --> 00:06:23,360
issue is threat models remote guessing

00:06:21,330 --> 00:06:26,280
attacks right and here you have some

00:06:23,360 --> 00:06:28,620
person on the internet who is sending

00:06:26,280 --> 00:06:31,229
guesses against particular accounts to

00:06:28,620 --> 00:06:33,300
the login service they typically have

00:06:31,229 --> 00:06:35,640
restriction how many guesses you can

00:06:33,300 --> 00:06:38,729
make before something should be flagged

00:06:35,640 --> 00:06:39,689
by the web login servers so you have

00:06:38,729 --> 00:06:41,610
some type of

00:06:39,689 --> 00:06:44,039
lockout threshold maybe a thousand or

00:06:41,610 --> 00:06:46,789
better yet like 10 or 100 before you

00:06:44,039 --> 00:06:50,059
know this account gets locked and you

00:06:46,789 --> 00:06:52,079
notify the user that something's wrong

00:06:50,059 --> 00:06:53,639
so this may seem good because we only

00:06:52,079 --> 00:06:55,679
get a few guesses right and you know

00:06:53,639 --> 00:06:58,019
even with the bad passwords people pick

00:06:55,679 --> 00:07:01,139
maybe locking someone out after 10

00:06:58,019 --> 00:07:03,689
guesses is fine but increasingly what

00:07:01,139 --> 00:07:05,969
attackers are doing is doing taking

00:07:03,689 --> 00:07:07,259
advantage of leaked data and mounting

00:07:05,969 --> 00:07:09,239
what are called credential stuffing

00:07:07,259 --> 00:07:11,219
attacks so remember there's like

00:07:09,239 --> 00:07:13,050
billions and billions of users passwords

00:07:11,219 --> 00:07:16,079
that are now available for anyone to go

00:07:13,050 --> 00:07:18,119
download and so you get a big list of

00:07:16,079 --> 00:07:20,550
people's passwords in fact my password

00:07:18,119 --> 00:07:21,959
which was not password 1 but was

00:07:20,550 --> 00:07:26,519
something equally bad from like 20 years

00:07:21,959 --> 00:07:28,529
ago what is in this for IQ data bell and

00:07:26,519 --> 00:07:29,759
also explains like why my Skype account

00:07:28,529 --> 00:07:30,479
got hacked a few years ago very

00:07:29,759 --> 00:07:33,689
embarrassing

00:07:30,479 --> 00:07:35,459
I can ask me about it later so anyway

00:07:33,689 --> 00:07:37,469
you go grab this database and what do

00:07:35,459 --> 00:07:40,469
you do you just try like you know login

00:07:37,469 --> 00:07:41,849
Tom at this particular service and you

00:07:40,469 --> 00:07:44,189
try the password that's in the database

00:07:41,849 --> 00:07:47,159
and this works surprisingly well

00:07:44,189 --> 00:07:49,289
simulations suggest that you know 40% of

00:07:47,159 --> 00:07:53,429
the time this is gonna work you know if

00:07:49,289 --> 00:07:54,989
your usernames in the breach with almost

00:07:53,429 --> 00:07:56,189
half the time you know that passwords

00:07:54,989 --> 00:07:58,169
the right wand and why because people

00:07:56,189 --> 00:07:59,369
reuse passwords across sites right

00:07:58,169 --> 00:08:02,159
that's what all the measurement studies

00:07:59,369 --> 00:08:03,179
indicate and there's some industry

00:08:02,159 --> 00:08:04,619
report suggests and actually the

00:08:03,179 --> 00:08:06,119
majority of account compromised remote

00:08:04,619 --> 00:08:10,050
compromises because of credential

00:08:06,119 --> 00:08:14,849
stuffing these days so that's motivated

00:08:10,050 --> 00:08:17,159
a move to defense which I'll just call

00:08:14,849 --> 00:08:18,719
trench stomach countermeasure or breach

00:08:17,159 --> 00:08:20,669
notification service we're basically

00:08:18,719 --> 00:08:22,529
like now the login server is going to

00:08:20,669 --> 00:08:25,319
get information about when their users

00:08:22,529 --> 00:08:26,969
end up in a breach ok

00:08:25,319 --> 00:08:29,099
they could go download actually these

00:08:26,969 --> 00:08:31,019
dumps themselves you can pay companies

00:08:29,099 --> 00:08:34,199
now to give you a like a notification if

00:08:31,019 --> 00:08:36,599
one of your users ends up in a breach

00:08:34,199 --> 00:08:37,919
and when they see that you know Tom

00:08:36,599 --> 00:08:39,990
password one and ends up in a breach

00:08:37,919 --> 00:08:43,949
they'll say hey Tom go reset your

00:08:39,990 --> 00:08:45,540
password ok and this should prevent at

00:08:43,949 --> 00:08:49,620
least the credential stuffing kind of

00:08:45,540 --> 00:08:50,639
attack what it doesn't prevent is oh and

00:08:49,620 --> 00:08:51,660
then you know I'll go and actually

00:08:50,639 --> 00:08:53,160
change my password because they're

00:08:51,660 --> 00:08:55,170
forcing me to maybe they restrict

00:08:53,160 --> 00:08:56,699
me from choosing my password this is

00:08:55,170 --> 00:08:59,690
exactly how a Cornell does it for

00:08:56,699 --> 00:09:02,550
example and I'll pick some new password

00:08:59,690 --> 00:09:04,019
well yeah maybe even see the animation

00:09:02,550 --> 00:09:05,819
but I went from password 1 to password 1

00:09:04,019 --> 00:09:09,509
2 3 which will be very important so

00:09:05,819 --> 00:09:10,889
thank you so now this attack doesn't

00:09:09,509 --> 00:09:13,560
work but the obvious thing an attacker

00:09:10,889 --> 00:09:15,360
can try now is exactly kind of

00:09:13,560 --> 00:09:19,410
iterations Oh before I can do that I'm

00:09:15,360 --> 00:09:20,610
sorry this is like such a important

00:09:19,410 --> 00:09:22,500
thing now that you actually see a bunch

00:09:20,610 --> 00:09:24,269
of services that are trying to like make

00:09:22,500 --> 00:09:26,730
this very easy to access breach

00:09:24,269 --> 00:09:28,769
notification so have I been pwned if

00:09:26,730 --> 00:09:30,769
you've heard of that is this service

00:09:28,769 --> 00:09:33,660
that CloudFlare and how operates in

00:09:30,769 --> 00:09:35,189
collaboration Troy hunt to check if

00:09:33,660 --> 00:09:36,810
passwords inner breach and then Google

00:09:35,189 --> 00:09:39,740
just released an extension a few months

00:09:36,810 --> 00:09:41,819
ago for doing a password checkup and

00:09:39,740 --> 00:09:43,139
basically these are like trying to do

00:09:41,819 --> 00:09:44,730
secure protocols for these type of

00:09:43,139 --> 00:09:46,889
checkups and we have some work on kind

00:09:44,730 --> 00:09:51,420
of in this space as well that you can

00:09:46,889 --> 00:09:52,620
ask me about later right so what can an

00:09:51,420 --> 00:09:54,089
attacker do to adapt to these

00:09:52,620 --> 00:09:55,259
countermeasures well they can do what we

00:09:54,089 --> 00:09:56,910
started calling credential tweaking

00:09:55,259 --> 00:09:59,009
attacks which is exactly this idea that

00:09:56,910 --> 00:10:00,300
maybe users are choosing very slight

00:09:59,009 --> 00:10:02,310
variants of the things that are in

00:10:00,300 --> 00:10:04,860
breaches and I could just try hey maybe

00:10:02,310 --> 00:10:06,660
capital P password oh maybe I'll try

00:10:04,860 --> 00:10:08,910
adding a two and three on the end and

00:10:06,660 --> 00:10:10,410
sure enough this will compromise in just

00:10:08,910 --> 00:10:11,910
a few guesses you know less than the

00:10:10,410 --> 00:10:15,089
threshold before an account lockout

00:10:11,910 --> 00:10:16,740
occurs so I should say I don't know if

00:10:15,089 --> 00:10:18,060
there's any evidence that attackers have

00:10:16,740 --> 00:10:19,620
really started doing this in bulk

00:10:18,060 --> 00:10:21,569
I think credential stuffing still works

00:10:19,620 --> 00:10:23,130
in a lot of context there's kind of

00:10:21,569 --> 00:10:24,360
sticking with that we don't know I don't

00:10:23,130 --> 00:10:26,160
know if they're not if they're using

00:10:24,360 --> 00:10:27,240
these or not in the wild there hasn't

00:10:26,160 --> 00:10:29,519
been any evidence so this would be a

00:10:27,240 --> 00:10:30,990
good measurement study target but there

00:10:29,519 --> 00:10:32,250
have been some academic works kind of

00:10:30,990 --> 00:10:33,860
indicating that you know at least in

00:10:32,250 --> 00:10:36,870
simulation this is going to definitely

00:10:33,860 --> 00:10:38,370
be effective and you can kind of see

00:10:36,870 --> 00:10:39,959
immediately once you get some data about

00:10:38,370 --> 00:10:41,459
how people pick passwords there's gonna

00:10:39,959 --> 00:10:43,709
be similarities you can kind of generate

00:10:41,459 --> 00:10:45,389
some mangling rules for generating

00:10:43,709 --> 00:10:48,029
guesses given someone's breached

00:10:45,389 --> 00:10:49,620
password and I should all say that

00:10:48,029 --> 00:10:50,670
doesn't seem to be any defenses that

00:10:49,620 --> 00:10:52,559
have really been discussed much

00:10:50,670 --> 00:10:56,639
literature beyond kind of checking based

00:10:52,559 --> 00:10:58,439
on trying to do an attack so we started

00:10:56,639 --> 00:11:00,660
tackling this from the point of view of

00:10:58,439 --> 00:11:02,430
trying to understand both how bad

00:11:00,660 --> 00:11:04,710
attacks can get credential swing attacks

00:11:02,430 --> 00:11:06,390
and also how much we can how

00:11:04,710 --> 00:11:08,070
we can prevent them and the unifying

00:11:06,390 --> 00:11:09,750
theme underlying it all is a kind of

00:11:08,070 --> 00:11:12,990
data-driven approach where we're trying

00:11:09,750 --> 00:11:14,880
to learn password similarity models so

00:11:12,990 --> 00:11:16,920
we started also by grabbing this breach

00:11:14,880 --> 00:11:18,690
data which is like I said publicly

00:11:16,920 --> 00:11:21,150
available and it's huge right there's

00:11:18,690 --> 00:11:23,940
1.4 billion email password pairs there's

00:11:21,150 --> 00:11:28,460
about a billion unique emails and it's

00:11:23,940 --> 00:11:31,320
lots of passwords there's a lot of

00:11:28,460 --> 00:11:33,390
common lot of usernames in this that

00:11:31,320 --> 00:11:35,520
have this multiple passwords right and

00:11:33,390 --> 00:11:37,020
this is useful for us because what we

00:11:35,520 --> 00:11:38,160
actually have from this database is

00:11:37,020 --> 00:11:40,320
something more like this where you see

00:11:38,160 --> 00:11:42,750
that you know maybe I have password one

00:11:40,320 --> 00:11:45,630
I also have Cornell tech yay exclamation

00:11:42,750 --> 00:11:48,390
point another people have other paths

00:11:45,630 --> 00:11:49,860
passwords and you can start seeing

00:11:48,390 --> 00:11:52,200
patterns already right if you just start

00:11:49,860 --> 00:11:53,700
doing simple checks like oh how how

00:11:52,200 --> 00:11:55,170
close in edit distance are people's

00:11:53,700 --> 00:11:59,400
passwords like a lot of people are

00:11:55,170 --> 00:12:01,410
picking very similar passwords right so

00:11:59,400 --> 00:12:02,760
for example in this you can see the

00:12:01,410 --> 00:12:04,590
other people made you can see this

00:12:02,760 --> 00:12:06,480
pattern of you know replacing a one with

00:12:04,590 --> 00:12:07,830
a one two three at the end and this is

00:12:06,480 --> 00:12:10,740
how we're gonna start getting some

00:12:07,830 --> 00:12:13,500
glimpse of how to build you know

00:12:10,740 --> 00:12:15,270
mangling type rules we want to take a

00:12:13,500 --> 00:12:17,190
data-driven approach we didn't want to

00:12:15,270 --> 00:12:18,870
like sort through this manually or semi

00:12:17,190 --> 00:12:20,510
manually and instead just through

00:12:18,870 --> 00:12:22,470
machine learning at it essentially

00:12:20,510 --> 00:12:24,990
because this ends up being a very nice

00:12:22,470 --> 00:12:26,370
natural language processing type problem

00:12:24,990 --> 00:12:28,920
since these are human shows and

00:12:26,370 --> 00:12:31,440
passwords so what we want to do in the

00:12:28,920 --> 00:12:33,120
end is train a conditional basically an

00:12:31,440 --> 00:12:34,950
estimate of a conditional probability

00:12:33,120 --> 00:12:36,660
distribution like probability of W prime

00:12:34,950 --> 00:12:38,250
like a new password given some old

00:12:36,660 --> 00:12:40,740
password W this is the thing that's in

00:12:38,250 --> 00:12:43,290
the breech and we want to be able do

00:12:40,740 --> 00:12:46,680
that for all the W's that we see out

00:12:43,290 --> 00:12:48,870
there and if we get such a good kind of

00:12:46,680 --> 00:12:50,100
estimate of this past of similarity

00:12:48,870 --> 00:12:51,780
model this ends up giving us a good

00:12:50,100 --> 00:12:53,550
credential tweaking attack because you

00:12:51,780 --> 00:12:55,970
can basically stick in the breech

00:12:53,550 --> 00:12:57,120
password and with a little bit of work

00:12:55,970 --> 00:13:00,120
enumerates

00:12:57,120 --> 00:13:02,190
a bunch of passwords in probability

00:13:00,120 --> 00:13:04,140
order under this good conditional

00:13:02,190 --> 00:13:06,810
probability distribution there is some

00:13:04,140 --> 00:13:11,640
work to do here but it's it's not it's

00:13:06,810 --> 00:13:14,250
not too bad okay so we want to do that

00:13:11,640 --> 00:13:15,750
so we started exploring how to build

00:13:14,250 --> 00:13:18,630
such good passwords similar any models

00:13:15,750 --> 00:13:20,640
and there's a lot of machine

00:13:18,630 --> 00:13:22,230
learning techniques built for this if

00:13:20,640 --> 00:13:24,150
you're familiar with like machine

00:13:22,230 --> 00:13:26,640
translation type tasks it's kind of

00:13:24,150 --> 00:13:28,650
similar to that type of task and so we

00:13:26,640 --> 00:13:30,300
started with that literature and at the

00:13:28,650 --> 00:13:31,860
end you end up wanting to use something

00:13:30,300 --> 00:13:33,930
like a recurrent neural network encoder

00:13:31,860 --> 00:13:35,760
decoder architecture or you kind of

00:13:33,930 --> 00:13:37,800
stick something in it converts a

00:13:35,760 --> 00:13:39,450
password into some vector representation

00:13:37,800 --> 00:13:41,460
of it kind of encode some information

00:13:39,450 --> 00:13:43,200
that's relevant to the learning and then

00:13:41,460 --> 00:13:45,120
from that you can decode to like

00:13:43,200 --> 00:13:46,580
generate things that are correlated with

00:13:45,120 --> 00:13:49,050
this password

00:13:46,580 --> 00:13:50,970
the most obvious approaches of applying

00:13:49,050 --> 00:13:53,610
like things like sequence to sequence

00:13:50,970 --> 00:13:55,500
which is a classic approach from the

00:13:53,610 --> 00:13:57,030
machine learning world didn't quite work

00:13:55,500 --> 00:13:58,860
very well they they didn't they didn't

00:13:57,030 --> 00:14:00,870
outperform the previous attacks in this

00:13:58,860 --> 00:14:02,700
space I'm gonna do a bit of like feature

00:14:00,870 --> 00:14:04,650
engineering kind of type stuff to make

00:14:02,700 --> 00:14:06,330
this work and then we ended up with a

00:14:04,650 --> 00:14:08,280
system we called passed a path which

00:14:06,330 --> 00:14:09,810
instead of actually just outputting you

00:14:08,280 --> 00:14:12,330
know character by character password at

00:14:09,810 --> 00:14:15,540
the other end you actually output like

00:14:12,330 --> 00:14:18,990
differences with the password W to get W

00:14:15,540 --> 00:14:21,420
Prime turns out this kind of I think

00:14:18,990 --> 00:14:22,980
helped the system better kind of focus

00:14:21,420 --> 00:14:25,470
on the the mangling kind of things and

00:14:22,980 --> 00:14:26,700
learning those patterns but I and I

00:14:25,470 --> 00:14:28,350
think many other people have no good

00:14:26,700 --> 00:14:31,080
intuition about why deep learning works

00:14:28,350 --> 00:14:35,010
very well this empirically outperformed

00:14:31,080 --> 00:14:36,420
past other approaches so in the end

00:14:35,010 --> 00:14:38,730
where this ends up being pretty big you

00:14:36,420 --> 00:14:41,310
know took a couple days on a pretty well

00:14:38,730 --> 00:14:43,110
stock machine it's its large it's kind

00:14:41,310 --> 00:14:44,610
of a clunky model which would become

00:14:43,110 --> 00:14:46,950
relevant for some other stuff in a

00:14:44,610 --> 00:14:49,320
minute but it works you know you can

00:14:46,950 --> 00:14:50,580
generate at least guesses for things we

00:14:49,320 --> 00:14:53,100
would care about in the remote guessing

00:14:50,580 --> 00:14:56,970
attack world like thousands of guesses

00:14:53,100 --> 00:14:58,530
you know in in milliseconds so we did a

00:14:56,970 --> 00:15:00,270
bunch of work to show via simulations

00:14:58,530 --> 00:15:01,710
you know splitting up our lot of data

00:15:00,270 --> 00:15:03,170
into test and train stats and kind of

00:15:01,710 --> 00:15:05,100
showing via simulation that this

00:15:03,170 --> 00:15:09,390
outperforms prior attacks and does a

00:15:05,100 --> 00:15:13,520
good job cracking passwords we also were

00:15:09,390 --> 00:15:16,650
able to partner with Cornell IT to do a

00:15:13,520 --> 00:15:20,370
an actual like audit of the Cornell

00:15:16,650 --> 00:15:22,350
accounts and this was exciting because

00:15:20,370 --> 00:15:24,120
it's really the first kind of actual

00:15:22,350 --> 00:15:28,620
real-world investigation of how well

00:15:24,120 --> 00:15:30,210
credential tweaking can work so Cornell

00:15:28,620 --> 00:15:31,649
is actually like I guess midsize

00:15:30,210 --> 00:15:33,209
business in some sense

00:15:31,649 --> 00:15:35,309
we have about hundreds we have a hundred

00:15:33,209 --> 00:15:39,119
thousands accounts we do use a breach

00:15:35,309 --> 00:15:42,059
notification service so things that end

00:15:39,119 --> 00:15:43,199
up in breaches end up getting reset and

00:15:42,059 --> 00:15:44,579
we have some various password

00:15:43,199 --> 00:15:46,680
requirements and stuff that required

00:15:44,579 --> 00:15:49,559
some customization of our machine

00:15:46,680 --> 00:15:52,439
learning we spend a lot of energy to try

00:15:49,559 --> 00:15:56,129
and make this a safe experiment you know

00:15:52,439 --> 00:15:57,749
getting access to passwords is not good

00:15:56,129 --> 00:15:59,220
even password hashes we actually went up

00:15:57,749 --> 00:16:01,410
to Ithaca we're based in New York City

00:15:59,220 --> 00:16:03,269
to go do this like in the presence of

00:16:01,410 --> 00:16:04,769
the IT engineers and like they were

00:16:03,269 --> 00:16:07,709
mediating all of our access to the

00:16:04,769 --> 00:16:09,360
password hashes it's a picture of us

00:16:07,709 --> 00:16:12,179
working up there it was a lot of fun

00:16:09,360 --> 00:16:14,339
actually in the end so there's about

00:16:12,179 --> 00:16:16,740
15,000 of these accounts are actually in

00:16:14,339 --> 00:16:19,410
the 4iq data leak and so then we

00:16:16,740 --> 00:16:22,470
basically generated guesses based on the

00:16:19,410 --> 00:16:24,420
passwords that were in the the breach

00:16:22,470 --> 00:16:27,089
data set for those and were able to

00:16:24,420 --> 00:16:29,129
compromise of the 15,000 about 8.4

00:16:27,089 --> 00:16:33,360
percent in less than a thousand guesses

00:16:29,129 --> 00:16:36,660
which is actually the the quota for

00:16:33,360 --> 00:16:39,600
Cornell and so and then we put these you

00:16:36,660 --> 00:16:41,999
know 1300 accounts on a watch list so we

00:16:39,600 --> 00:16:43,139
could protect them better and as I

00:16:41,999 --> 00:16:44,600
mentioned this is the kind of first real

00:16:43,139 --> 00:16:47,009
boat evaluation of correctional tweaking

00:16:44,600 --> 00:16:48,800
well compared to the simulation based

00:16:47,009 --> 00:16:51,720
approaches that people have done before

00:16:48,800 --> 00:16:53,220
this is definitely a problem in the

00:16:51,720 --> 00:16:54,480
sense that we worry that if attackers

00:16:53,220 --> 00:16:56,269
start using these types of techniques

00:16:54,480 --> 00:16:58,709
they're gonna have some success right

00:16:56,269 --> 00:17:00,059
and so we wanted to understand how to do

00:16:58,709 --> 00:17:01,740
defense as obviously we can do these

00:17:00,059 --> 00:17:03,389
types of audits but these audits are

00:17:01,740 --> 00:17:05,250
expensive right we had to go up to

00:17:03,389 --> 00:17:07,049
Ithaca it unless at least cost some bus

00:17:05,250 --> 00:17:08,490
tickets I mean they can do it themselves

00:17:07,049 --> 00:17:09,750
I guess but it's it's a lot of

00:17:08,490 --> 00:17:12,120
computational power to do these types of

00:17:09,750 --> 00:17:13,620
audits and we might want to build new

00:17:12,120 --> 00:17:16,439
approaches that kind of work better in

00:17:13,620 --> 00:17:18,179
the workflow for password handling that

00:17:16,439 --> 00:17:21,779
don't require like special cracking

00:17:18,179 --> 00:17:23,490
experiments and so in particular if we

00:17:21,779 --> 00:17:26,220
go back to this you know view like when

00:17:23,490 --> 00:17:28,199
you get a breach notification about my

00:17:26,220 --> 00:17:31,529
password being in this breach we might

00:17:28,199 --> 00:17:34,020
like to try to steer users away from

00:17:31,529 --> 00:17:37,380
picking something that's going to be a

00:17:34,020 --> 00:17:39,659
crackable in this type of credential

00:17:37,380 --> 00:17:40,830
tweaking attack and so this led us this

00:17:39,659 --> 00:17:43,230
idea of what we start a client

00:17:40,830 --> 00:17:44,220
personalized password strength meter so

00:17:43,230 --> 00:17:45,240
basically trying to take into account

00:17:44,220 --> 00:17:47,070
these breach

00:17:45,240 --> 00:17:48,809
passwords these pastors have been

00:17:47,070 --> 00:17:53,070
publicly breached when giving a strength

00:17:48,809 --> 00:17:54,870
score to users so starting point for

00:17:53,070 --> 00:17:56,280
this is a regular strength meter so

00:17:54,870 --> 00:17:58,770
you've probably seen strength meters at

00:17:56,280 --> 00:18:00,780
many sites now like things like zxe vbn

00:17:58,770 --> 00:18:02,309
which is a bit of a mouthful they take

00:18:00,780 --> 00:18:04,530
in a password give you a score right

00:18:02,309 --> 00:18:07,679
maybe a 1 through 5 or a 0 through 4

00:18:04,530 --> 00:18:09,720
kind of score so we want to do this and

00:18:07,679 --> 00:18:12,780
just add the ability to take as input

00:18:09,720 --> 00:18:13,890
some prior breached passwords and take

00:18:12,780 --> 00:18:15,300
that into account

00:18:13,890 --> 00:18:16,860
right and intuitively what we want to do

00:18:15,300 --> 00:18:18,210
is say okay if password 1 2 3 is too

00:18:16,860 --> 00:18:20,370
close to this breach password password

00:18:18,210 --> 00:18:25,080
one we should steer it you know give it

00:18:20,370 --> 00:18:26,490
a low score and there's lots of you know

00:18:25,080 --> 00:18:27,660
you can imagine other kind of contacts

00:18:26,490 --> 00:18:30,030
but here we're really thinking about

00:18:27,660 --> 00:18:33,990
these old passwords being the ones that

00:18:30,030 --> 00:18:35,130
are from a breach so the approach for

00:18:33,990 --> 00:18:38,360
this again we use machine learning for

00:18:35,130 --> 00:18:40,890
and we in particular train what's

00:18:38,360 --> 00:18:42,750
variants of a word embedding but for

00:18:40,890 --> 00:18:44,490
password so we created Li called a

00:18:42,750 --> 00:18:46,200
password embedding which is basically a

00:18:44,490 --> 00:18:48,600
function that map's you know passwords

00:18:46,200 --> 00:18:50,040
down to some vector representation and

00:18:48,600 --> 00:18:52,440
you learn in a way that kind of

00:18:50,040 --> 00:18:54,600
preserves semantic similarities it's a

00:18:52,440 --> 00:18:56,130
very classic well understood technique

00:18:54,600 --> 00:18:58,500
from the machine learning and LP

00:18:56,130 --> 00:19:00,270
communities the point is you can just

00:18:58,500 --> 00:19:02,490
take the this embedding run it on to

00:19:00,270 --> 00:19:04,679
passwords and then take a dot product of

00:19:02,490 --> 00:19:06,480
the resultant vectors and if that dot

00:19:04,679 --> 00:19:10,290
product is smaller than a threshold you

00:19:06,480 --> 00:19:13,200
know then you get a good sense that this

00:19:10,290 --> 00:19:14,820
is very similar and specifically we're

00:19:13,200 --> 00:19:19,170
built something based on fast text which

00:19:14,820 --> 00:19:23,160
is a well-known algorithm and this helps

00:19:19,170 --> 00:19:24,570
a lot so first off it's really pretty

00:19:23,160 --> 00:19:27,510
simple like at the end of day these

00:19:24,570 --> 00:19:29,820
embeddings just a kind of lookup table

00:19:27,510 --> 00:19:31,410
that you can use it's like three

00:19:29,820 --> 00:19:33,090
megabytes or so so it's even small

00:19:31,410 --> 00:19:35,460
enough to after we did some compression

00:19:33,090 --> 00:19:37,950
stuff to deploy it on the client side if

00:19:35,460 --> 00:19:39,210
you want to deploy it there we combined

00:19:37,950 --> 00:19:41,160
it with a regular strength meter like

00:19:39,210 --> 00:19:42,420
zxv VPNs because we also want you to

00:19:41,160 --> 00:19:45,300
have an all-in-one just kind of strength

00:19:42,420 --> 00:19:47,460
meter solution and for example it marked

00:19:45,300 --> 00:19:49,620
all the when we did our experiments we

00:19:47,460 --> 00:19:52,140
also checked this an embedding based

00:19:49,620 --> 00:19:53,580
defense and it would have marked all of

00:19:52,140 --> 00:19:55,740
the past two paths one herbal Cornell

00:19:53,580 --> 00:19:56,880
passwords as trivially week despite the

00:19:55,740 --> 00:19:58,770
fact that we're using kind of different

00:19:56,880 --> 00:20:00,150
machine learning approaches I

00:19:58,770 --> 00:20:01,770
definitely say we have not yet done any

00:20:00,150 --> 00:20:03,150
proper usability studies I guess there's

00:20:01,770 --> 00:20:04,680
a lot of questions about like how a user

00:20:03,150 --> 00:20:08,270
would react if you kind of told them

00:20:04,680 --> 00:20:12,390
things are too close to something else

00:20:08,270 --> 00:20:13,950
okay so that was the first part and the

00:20:12,390 --> 00:20:16,800
second part don't worry is not 20

00:20:13,950 --> 00:20:20,100
minutes long so I'll be finished before

00:20:16,800 --> 00:20:21,720
the top but that and that was focusing

00:20:20,100 --> 00:20:23,580
specifically on security issues and

00:20:21,720 --> 00:20:26,220
these kind of like targeted attacks

00:20:23,580 --> 00:20:28,590
specifically and I'm hoping that these

00:20:26,220 --> 00:20:30,210
tools like the embeddings based

00:20:28,590 --> 00:20:32,280
personalized power strike meters are

00:20:30,210 --> 00:20:35,360
something that will be able to deploy in

00:20:32,280 --> 00:20:37,380
various places to help improve security

00:20:35,360 --> 00:20:39,180
so what I'll do in the time range just

00:20:37,380 --> 00:20:40,470
mention briefly some of this work we've

00:20:39,180 --> 00:20:42,150
been doing now for a bunch of years on

00:20:40,470 --> 00:20:45,410
typo tolerant posture tracking which is

00:20:42,150 --> 00:20:49,860
trying to improve usability for

00:20:45,410 --> 00:20:53,970
passwords so I this the starting point

00:20:49,860 --> 00:20:55,680
for this work for me well was pretty

00:20:53,970 --> 00:20:57,420
much that I can't type my password very

00:20:55,680 --> 00:20:59,010
well my password is not password one and

00:20:57,420 --> 00:21:00,510
I'd like miss type my password a lot in

00:20:59,010 --> 00:21:02,070
fact when we did measurements later I I

00:21:00,510 --> 00:21:03,570
missed out my passwords like a scary

00:21:02,070 --> 00:21:05,520
amount of time like 35 percent of the

00:21:03,570 --> 00:21:07,140
time and so at some point I got on this

00:21:05,520 --> 00:21:08,580
mission like hey you know wouldn't be

00:21:07,140 --> 00:21:10,590
great if we could fix it so that I don't

00:21:08,580 --> 00:21:11,910
have to keep retyping my password I

00:21:10,590 --> 00:21:15,030
could have chosen a different password I

00:21:11,910 --> 00:21:16,350
guess but I was very stubborn but I'm

00:21:15,030 --> 00:21:18,990
not the only person who's had problems

00:21:16,350 --> 00:21:20,910
with this and in fact Facebook and some

00:21:18,990 --> 00:21:23,370
other companies long actually for a long

00:21:20,910 --> 00:21:28,500
time now is like a 2011 article have

00:21:23,370 --> 00:21:34,050
been tolerant of mystech mistakes and

00:21:28,500 --> 00:21:36,870
typos typos in passwords so for example

00:21:34,050 --> 00:21:38,310
password Facebook would accept password

00:21:36,870 --> 00:21:40,590
one you know the correct password are

00:21:38,310 --> 00:21:43,290
also two variants of it capital P

00:21:40,590 --> 00:21:46,170
password one and all caps password one

00:21:43,290 --> 00:21:49,020
and you know the capital P password one

00:21:46,170 --> 00:21:51,660
is it was really important I think when

00:21:49,020 --> 00:21:53,430
they first deployed their app on mobile

00:21:51,660 --> 00:21:55,710
because mobile keyboards was always

00:21:53,430 --> 00:21:57,390
automatically capitalizing the first

00:21:55,710 --> 00:21:58,890
character of passwords when they're

00:21:57,390 --> 00:22:01,620
deployed and so this was an easy fix for

00:21:58,890 --> 00:22:03,330
that but this raises this broader

00:22:01,620 --> 00:22:06,330
question of like oh you know is this

00:22:03,330 --> 00:22:08,010
secure like what other typos should we

00:22:06,330 --> 00:22:11,040
be trying to tolerate this type of thing

00:22:08,010 --> 00:22:12,570
and really leads in this question of how

00:22:11,040 --> 00:22:15,389
we can study typos taller

00:22:12,570 --> 00:22:17,370
password checking right so we've been

00:22:15,389 --> 00:22:18,720
doing a lot of work over the years on

00:22:17,370 --> 00:22:20,519
this we kind of did the first big

00:22:18,720 --> 00:22:22,259
measurement studies Facebook clearly had

00:22:20,519 --> 00:22:23,610
done something internally but didn't

00:22:22,259 --> 00:22:25,710
didn't report on it so we did a first

00:22:23,610 --> 00:22:27,000
measurement study I'll briefly mentioned

00:22:25,710 --> 00:22:28,679
something about that looked at new

00:22:27,000 --> 00:22:30,480
cryptographic constructions I won't talk

00:22:28,679 --> 00:22:32,789
about that and then I'll just explain

00:22:30,480 --> 00:22:34,830
what the the solution that finally

00:22:32,789 --> 00:22:36,750
solved my problem which is this idea of

00:22:34,830 --> 00:22:38,880
a personalized typo tolerant a password

00:22:36,750 --> 00:22:42,149
checking system and I'll explain that in

00:22:38,880 --> 00:22:44,130
a moment so the approach that Facebook

00:22:42,149 --> 00:22:45,450
is using and it's kind of the natural

00:22:44,130 --> 00:22:49,019
approach is what we started calling

00:22:45,450 --> 00:22:50,129
relaxed checking and you know the

00:22:49,019 --> 00:22:51,929
complexity is we're not storing

00:22:50,129 --> 00:22:53,789
passwords in the clear right if you got

00:22:51,929 --> 00:22:55,470
in an incorrect password password one

00:22:53,789 --> 00:22:56,850
and just hash it it's just you know some

00:22:55,470 --> 00:22:59,909
random looking string that's unrelated

00:22:56,850 --> 00:23:01,320
to the hash that's in the database and

00:22:59,909 --> 00:23:03,149
so this question how can you actually

00:23:01,320 --> 00:23:04,620
then you know check we don't want to

00:23:03,149 --> 00:23:05,759
just accept any possible string that

00:23:04,620 --> 00:23:06,870
someone sends in that would be too

00:23:05,759 --> 00:23:08,909
permissive we want to check something

00:23:06,870 --> 00:23:10,830
that's close but there's an easy

00:23:08,909 --> 00:23:12,899
solution if you have just a handful of

00:23:10,830 --> 00:23:14,309
types of typos that you care about and

00:23:12,899 --> 00:23:16,409
that's this relaxed checking approach

00:23:14,309 --> 00:23:18,750
basically you check the password I

00:23:16,409 --> 00:23:21,059
submitted this won't work it'll be some

00:23:18,750 --> 00:23:22,950
other random string then you apply what

00:23:21,059 --> 00:23:24,570
we call a corrector right so say we

00:23:22,950 --> 00:23:26,399
apply a caps lock corrector to the

00:23:24,570 --> 00:23:28,830
password those mitad we just flip the

00:23:26,399 --> 00:23:30,029
case of all the passwords of all the

00:23:28,830 --> 00:23:32,820
characters in the password and then

00:23:30,029 --> 00:23:34,230
rehash it okay and then check did this

00:23:32,820 --> 00:23:36,659
is this matching the thing that's in the

00:23:34,230 --> 00:23:38,929
database we can do that again and again

00:23:36,659 --> 00:23:42,049
with other characters maybe we just

00:23:38,929 --> 00:23:44,940
change various things and finally get

00:23:42,049 --> 00:23:47,009
the the right password because we hit

00:23:44,940 --> 00:23:48,509
the right corrector okay and that means

00:23:47,009 --> 00:23:50,730
that we get the same hash and we're good

00:23:48,509 --> 00:23:52,320
to go this is really nice because it

00:23:50,730 --> 00:23:54,750
actually doesn't require any changes to

00:23:52,320 --> 00:23:57,690
the database you just use the same

00:23:54,750 --> 00:23:59,399
hashing system and you just have to add

00:23:57,690 --> 00:24:00,899
some extra code to like while you have

00:23:59,399 --> 00:24:03,509
that password in memory on the web

00:24:00,899 --> 00:24:07,590
server you just check it a couple more

00:24:03,509 --> 00:24:10,200
times right it does have the downside

00:24:07,590 --> 00:24:11,970
that if you want to make G sub K really

00:24:10,200 --> 00:24:13,590
slow like we said before you know you

00:24:11,970 --> 00:24:15,000
may have some performance issues you may

00:24:13,590 --> 00:24:17,370
have to make the time to compute that

00:24:15,000 --> 00:24:18,750
take into account the a number of

00:24:17,370 --> 00:24:22,980
Corrections you need to do if you want

00:24:18,750 --> 00:24:24,120
to hit a certain level latency it's

00:24:22,980 --> 00:24:25,470
interesting this actually you know I

00:24:24,120 --> 00:24:26,640
said it works with password Hart

00:24:25,470 --> 00:24:28,410
existing past hiring

00:24:26,640 --> 00:24:30,030
scheme's doesn't change restored and in

00:24:28,410 --> 00:24:31,680
some of our initials like simulation

00:24:30,030 --> 00:24:33,360
work if you set you know the number of

00:24:31,680 --> 00:24:35,430
practice pretty small like so the total

00:24:33,360 --> 00:24:37,530
number of things you check is for say

00:24:35,430 --> 00:24:39,870
like in this example that actually hits

00:24:37,530 --> 00:24:42,360
like 20% of the typos that people seem

00:24:39,870 --> 00:24:44,550
to make in Mechanical Turk studies so

00:24:42,360 --> 00:24:46,590
that was pretty surprising but I guess a

00:24:44,550 --> 00:24:48,150
lot of people make caps-lock

00:24:46,590 --> 00:24:50,490
errors for example and also a

00:24:48,150 --> 00:24:51,750
capitalization errors we wanted to see

00:24:50,490 --> 00:24:53,070
if this is true in the real world and we

00:24:51,750 --> 00:24:54,300
partnered with Dropbox to do a

00:24:53,070 --> 00:24:56,690
measurement study of their

00:24:54,300 --> 00:24:58,530
authentication infrastructure is really

00:24:56,690 --> 00:25:01,410
cool

00:24:58,530 --> 00:25:02,910
collaboration my perspective to measure

00:25:01,410 --> 00:25:05,430
what this impact would be

00:25:02,910 --> 00:25:06,780
so we basically instrumented to do this

00:25:05,430 --> 00:25:08,160
type of type of taller password

00:25:06,780 --> 00:25:09,690
authentication but we didn't actually

00:25:08,160 --> 00:25:11,160
change the authentication policy we just

00:25:09,690 --> 00:25:12,540
checked if it would have worked and then

00:25:11,160 --> 00:25:14,790
recorded some you know anonymous

00:25:12,540 --> 00:25:16,590
statistics about that I just say we

00:25:14,790 --> 00:25:18,030
didn't do anything they did all that and

00:25:16,590 --> 00:25:20,600
we just talked to them about it we

00:25:18,030 --> 00:25:23,280
didn't touch on either code

00:25:20,600 --> 00:25:25,710
collaborators did that but it was pretty

00:25:23,280 --> 00:25:27,810
surprising like in a 24 hour run where

00:25:25,710 --> 00:25:29,610
we gathered this data about 3% of all

00:25:27,810 --> 00:25:32,250
the people who tried to log in like

00:25:29,610 --> 00:25:34,860
failed because of just like the most

00:25:32,250 --> 00:25:36,420
popular top three typos like the ones I

00:25:34,860 --> 00:25:39,330
showed on the previous slides type of

00:25:36,420 --> 00:25:40,890
capitalization errors and I failed login

00:25:39,330 --> 00:25:43,380
I mean they came they tried to login

00:25:40,890 --> 00:25:45,420
they had that typo they left and like

00:25:43,380 --> 00:25:48,840
didn't log in again in that 24 hour

00:25:45,420 --> 00:25:50,760
period and about 20% users would have

00:25:48,840 --> 00:25:54,540
made you know would have saved at least

00:25:50,760 --> 00:25:57,420
about a minute of login time if we had

00:25:54,540 --> 00:25:59,190
done typo tolerance right and so in the

00:25:57,420 --> 00:26:01,830
end like aggregated over the hundreds of

00:25:59,190 --> 00:26:03,420
hundred millions of users you know this

00:26:01,830 --> 00:26:04,710
would have saved you know several person

00:26:03,420 --> 00:26:08,750
months or would added several person

00:26:04,710 --> 00:26:11,970
months of logging time every day to

00:26:08,750 --> 00:26:13,380
Dropbox which you know for companies

00:26:11,970 --> 00:26:15,360
that are engagement trip in this is

00:26:13,380 --> 00:26:17,490
actually a lot of this is like money

00:26:15,360 --> 00:26:19,020
right and so you can see why Facebook

00:26:17,490 --> 00:26:21,450
was probably very excited to turn this

00:26:19,020 --> 00:26:23,760
on the more subtle issue is whether

00:26:21,450 --> 00:26:25,350
security degrades I don't have time to

00:26:23,760 --> 00:26:27,210
go into the details and you can you can

00:26:25,350 --> 00:26:29,520
talk to me afterwards or see the papers

00:26:27,210 --> 00:26:30,960
on it but the high level bit is that the

00:26:29,520 --> 00:26:35,370
security actually doesn't degrade if you

00:26:30,960 --> 00:26:39,840
choose these things carefully okay and

00:26:35,370 --> 00:26:41,760
then lastly we wanted to that type

00:26:39,840 --> 00:26:43,590
relax checking approach didn't fix the

00:26:41,760 --> 00:26:45,540
typo that I always have it's some like

00:26:43,590 --> 00:26:48,720
transposition error in the middle of my

00:26:45,540 --> 00:26:50,070
passphrase and so I was really I was in

00:26:48,720 --> 00:26:51,780
status for yet so we had to go on to do

00:26:50,070 --> 00:26:53,790
more work and we came about this idea of

00:26:51,780 --> 00:26:55,380
what we started client personalized typo

00:26:53,790 --> 00:26:58,500
tolerant checking which I'll just now

00:26:55,380 --> 00:26:59,790
briefly explain and the idea is that at

00:26:58,500 --> 00:27:00,870
a high level we just want to learn we

00:26:59,790 --> 00:27:02,280
have a system that is stateful we're

00:27:00,870 --> 00:27:04,410
gonna learn over time the particular

00:27:02,280 --> 00:27:07,080
typos that a particular user makes and

00:27:04,410 --> 00:27:09,000
we're going to do that as we proceed so

00:27:07,080 --> 00:27:10,710
say I missed I up and do password one

00:27:09,000 --> 00:27:12,240
well what we would like to do is

00:27:10,710 --> 00:27:14,550
something like this we're gonna you know

00:27:12,240 --> 00:27:17,160
just cache we're gonna check that it to

00:27:14,550 --> 00:27:18,270
see if it is correct and it's not and so

00:27:17,160 --> 00:27:21,090
we're just gonna add it to a wait list

00:27:18,270 --> 00:27:24,840
of recent kind of incorrect password

00:27:21,090 --> 00:27:27,930
submissions okay and then I'm gonna get

00:27:24,840 --> 00:27:30,600
frustrated that we'll get at it as well

00:27:27,930 --> 00:27:32,960
and then finally I log in correctly at

00:27:30,600 --> 00:27:35,790
that point we can check that password

00:27:32,960 --> 00:27:37,980
one and this previously in corrects me

00:27:35,790 --> 00:27:40,200
to think capital pass P password 1 are

00:27:37,980 --> 00:27:42,060
very similar and they satisfy some like

00:27:40,200 --> 00:27:45,600
typo policy and so we can just add that

00:27:42,060 --> 00:27:48,170
now as it under a new salted hash to a

00:27:45,600 --> 00:27:52,040
set of what we call a typo cache and we

00:27:48,170 --> 00:27:55,440
basically then from that on can allow

00:27:52,040 --> 00:27:58,350
submissions of that typo'd version to

00:27:55,440 --> 00:28:01,500
succeed in log in by checking both of

00:27:58,350 --> 00:28:03,150
the hashes so there's an obvious problem

00:28:01,500 --> 00:28:04,440
with this approach as I described it

00:28:03,150 --> 00:28:06,180
which is that we are in for a while

00:28:04,440 --> 00:28:07,410
storing and clear these wait list

00:28:06,180 --> 00:28:10,260
passwords and we can't do that for

00:28:07,410 --> 00:28:11,880
security reasons and so we did some work

00:28:10,260 --> 00:28:14,490
to figure out how to basically avoid

00:28:11,880 --> 00:28:16,110
ever storing anything in the clear at a

00:28:14,490 --> 00:28:17,730
high level the idea is we are going to

00:28:16,110 --> 00:28:19,560
use some public key seek public key

00:28:17,730 --> 00:28:21,930
encryption and we're going to encrypt

00:28:19,560 --> 00:28:24,240
this wait list under a public key the

00:28:21,930 --> 00:28:26,790
secret key is then encrypted under the

00:28:24,240 --> 00:28:31,500
passwords that we are allowing login

00:28:26,790 --> 00:28:32,820
under and so the final data structure

00:28:31,500 --> 00:28:35,130
looks something like this nothing is

00:28:32,820 --> 00:28:40,080
ever stored in the clear when you go to

00:28:35,130 --> 00:28:41,940
login you check the hash if it succeeds

00:28:40,080 --> 00:28:45,150
you actually also can read arrive the

00:28:41,940 --> 00:28:46,530
the decryption of s K and then decrypt

00:28:45,150 --> 00:28:49,800
the wait list and clear and check things

00:28:46,530 --> 00:28:52,440
out but there's lots of details

00:28:49,800 --> 00:28:53,130
turns out this did fix my pair that was

00:28:52,440 --> 00:28:56,940
great it

00:28:53,130 --> 00:28:59,310
also turns out to be secure there's a

00:28:56,940 --> 00:29:01,020
bunch of theorems and statements in the

00:28:59,310 --> 00:29:02,100
paper I'm just gonna gloss over this the

00:29:01,020 --> 00:29:04,410
high level biz that this doesn't

00:29:02,100 --> 00:29:07,560
actually degrade security just by the

00:29:04,410 --> 00:29:10,950
fact that we've added some other values

00:29:07,560 --> 00:29:13,320
to the to the stored list there's an

00:29:10,950 --> 00:29:15,090
open source implementation of this it

00:29:13,320 --> 00:29:16,830
works I'm using it on my laptop right

00:29:15,090 --> 00:29:19,590
now I finally solved my problem long

00:29:16,830 --> 00:29:21,360
story short and with that I guess I'll

00:29:19,590 --> 00:29:23,420
just stop and take questions yeah thank

00:29:21,360 --> 00:29:27,130
you very much

00:29:23,420 --> 00:29:27,130

YouTube URL: https://www.youtube.com/watch?v=ZVmbWngtb4E


