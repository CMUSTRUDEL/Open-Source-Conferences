Title: ET Speaker Series - Bionic Tools for Documenting Code - Andrew Head, UC Berkeley
Publication date: 2019-08-26
Playlist: Emerging Technologies Speaker Series
Description: 
	Writing programming documentation is challenging, time-intensive, and fundamentally creative. In this talk, I introduce bionic documentation tools---tools that leverage code analysis to capture, shape, amplify, and share developer insight. I describe two tools that provide new ways for programmers to write and propagate documentation. The first tool finds code examples in tutorial pages and generates explanations of their tricky syntax. The second helps programmers extract self-contained, executable code examples that capture the essence of important patterns in their complex code. These tools build on techniques from program slicing to natural language generation, to gosh-darn simple hand-written rules. Our usability studies indicate the tools are useful. I believe they will ultimately help programmers capture and share programming knowledge otherwise locked away in their minds and code.
Captions: 
	00:01:15,610 --> 00:01:18,360
thank you

00:01:21,640 --> 00:01:26,350
good morning my name is Joe fish kay and

00:01:24,490 --> 00:01:27,940
principal research scientist in emerging

00:01:26,350 --> 00:01:30,310
technologies and today I have the

00:01:27,940 --> 00:01:32,380
pleasure and joy of introducing Andrew

00:01:30,310 --> 00:01:36,040
head who's a graduate student at UC

00:01:32,380 --> 00:01:40,680
Berkeley in Byung Harmons group I met

00:01:36,040 --> 00:01:42,940
Andrew at a conference called Chi and

00:01:40,680 --> 00:01:44,590
Andrew and beyond told me a little bit

00:01:42,940 --> 00:01:47,140
about the work he was doing and what I

00:01:44,590 --> 00:01:49,150
thought was fascinating was how vital

00:01:47,140 --> 00:01:51,850
and how important this work is for the

00:01:49,150 --> 00:01:54,060
stuff we do at Mozilla every day both in

00:01:51,850 --> 00:01:56,860
the terms of the work that we do at mdn

00:01:54,060 --> 00:01:58,660
in which we're explaining the web to the

00:01:56,860 --> 00:02:00,040
world but also the work that we do

00:01:58,660 --> 00:02:01,960
internally in which we collaborate on

00:02:00,040 --> 00:02:03,850
code we document code we collaborate

00:02:01,960 --> 00:02:05,350
with people a great distance is a great

00:02:03,850 --> 00:02:06,910
times and I thought it would be a great

00:02:05,350 --> 00:02:08,860
person to come in and talk about some of

00:02:06,910 --> 00:02:13,330
that stuff so without any further ado

00:02:08,860 --> 00:02:15,489
Andrew thanks Joe fish for that kind

00:02:13,330 --> 00:02:17,140
introduction I'm really excited to be

00:02:15,489 --> 00:02:21,250
here today as part of this emerging

00:02:17,140 --> 00:02:24,640
technologies seminar series I I really

00:02:21,250 --> 00:02:27,760
love Mozilla and a lot of the ideals of

00:02:24,640 --> 00:02:29,709
openness that that drives a lot of the

00:02:27,760 --> 00:02:31,570
work and I think those same ideals

00:02:29,709 --> 00:02:33,820
motivate a lot of this work I'll be

00:02:31,570 --> 00:02:37,630
presenting today called Bionic tools for

00:02:33,820 --> 00:02:39,130
documenting code so the Bionic tools for

00:02:37,630 --> 00:02:41,709
documenting code was designed to

00:02:39,130 --> 00:02:43,830
overcome a lot of problems that I see in

00:02:41,709 --> 00:02:46,720
my day to day work as a programmer

00:02:43,830 --> 00:02:49,570
problems like in documentation having

00:02:46,720 --> 00:02:51,970
bad usage examples here's an old Nabal

00:02:49,570 --> 00:02:54,489
post that has a code example it right in

00:02:51,970 --> 00:02:56,860
the middle of it and this is a bad usage

00:02:54,489 --> 00:02:59,860
example because in order to actually use

00:02:56,860 --> 00:03:01,630
it it requires another 30 or 40 lines of

00:02:59,860 --> 00:03:03,850
boilerplate code in order to get it to

00:03:01,630 --> 00:03:05,620
run it requires a meaningful piece of

00:03:03,850 --> 00:03:08,049
data and if I just want to use this five

00:03:05,620 --> 00:03:09,910
line code snippet right here it's going

00:03:08,049 --> 00:03:11,860
to take a lot more effort than just

00:03:09,910 --> 00:03:14,769
finding and reading this code example in

00:03:11,860 --> 00:03:17,080
order to get it up and running other

00:03:14,769 --> 00:03:19,269
issues like missing explanations for

00:03:17,080 --> 00:03:22,510
code here's a here's a command called

00:03:19,269 --> 00:03:24,459
open SSL and you can use this in order

00:03:22,510 --> 00:03:27,910
to generate in order to generate

00:03:24,459 --> 00:03:29,500
certificates for an HTTP server but in

00:03:27,910 --> 00:03:32,110
order to use this and modify and

00:03:29,500 --> 00:03:34,060
understand it a lot of questions will

00:03:32,110 --> 00:03:34,780
come to someone's mind for instance what

00:03:34,060 --> 00:03:37,660
is this are

00:03:34,780 --> 00:03:40,900
say : 4096 is it important that this

00:03:37,660 --> 00:03:42,069
4096 is a power of two is there some

00:03:40,900 --> 00:03:44,860
other way for me to change the

00:03:42,069 --> 00:03:46,930
encryption for this how about this x.509

00:03:44,860 --> 00:03:50,200
if I get rid of this will it make my

00:03:46,930 --> 00:03:52,090
server less secure a lot of times the

00:03:50,200 --> 00:03:53,890
accompanying explanations for code

00:03:52,090 --> 00:03:55,330
examples like this just aren't there

00:03:53,890 --> 00:03:57,370
which makes it really difficult for

00:03:55,330 --> 00:04:00,930
people to understand work with and

00:03:57,370 --> 00:04:00,930
modify this code for their own purposes

00:04:01,050 --> 00:04:04,959
documentation in general lacks the

00:04:03,010 --> 00:04:06,640
attention that it deserves we as

00:04:04,959 --> 00:04:08,440
programmers have a lot of things that

00:04:06,640 --> 00:04:09,970
demand our attention fixing bugs

00:04:08,440 --> 00:04:11,830
developing new features and

00:04:09,970 --> 00:04:14,320
documentation often hits the cutting

00:04:11,830 --> 00:04:15,940
room floor and this is a problem because

00:04:14,320 --> 00:04:18,040
writing documentation is something

00:04:15,940 --> 00:04:20,079
that's fundamentally iterative time

00:04:18,040 --> 00:04:22,330
consuming creative it requires us to

00:04:20,079 --> 00:04:25,180
think about what we want to document and

00:04:22,330 --> 00:04:26,860
what our audience knows and to be able

00:04:25,180 --> 00:04:28,840
to put that in words and try things out

00:04:26,860 --> 00:04:30,700
and put it in front of people and make

00:04:28,840 --> 00:04:33,520
sure that we're communicating ourselves

00:04:30,700 --> 00:04:35,889
properly that said it's really hard to

00:04:33,520 --> 00:04:38,440
to justify the time that it takes to

00:04:35,889 --> 00:04:40,330
write documentation in the words of one

00:04:38,440 --> 00:04:42,160
of our maintainer x' in one of the

00:04:40,330 --> 00:04:44,500
studies that i'll be presenting in a bit

00:04:42,160 --> 00:04:46,419
they told us about one of their files of

00:04:44,500 --> 00:04:48,700
documentation that it's unlikely that

00:04:46,419 --> 00:04:49,990
this will ever get changed again and if

00:04:48,700 --> 00:04:51,550
I hadn't scheduled this meeting with

00:04:49,990 --> 00:04:53,800
them they would have forgotten the file

00:04:51,550 --> 00:04:55,930
existed this isn't out of the ordinary

00:04:53,800 --> 00:04:57,610
we have so many projects that we're

00:04:55,930 --> 00:04:58,780
working on that often times helping

00:04:57,610 --> 00:05:02,160
people and the projects that are already

00:04:58,780 --> 00:05:04,660
there is something that gets neglected

00:05:02,160 --> 00:05:07,120
my work at Berkeley is all about what I

00:05:04,660 --> 00:05:09,630
call Bionic documentation tools these

00:05:07,120 --> 00:05:12,789
tools they're aimed to help programmers

00:05:09,630 --> 00:05:14,050
capture share amplify shape their

00:05:12,789 --> 00:05:16,750
insights and share them with other

00:05:14,050 --> 00:05:19,360
programmers I focus on two of the really

00:05:16,750 --> 00:05:22,390
key parts of documentation producing

00:05:19,360 --> 00:05:23,669
usage examples and explanations and it's

00:05:22,390 --> 00:05:26,919
Bionic because it combines both

00:05:23,669 --> 00:05:29,919
automation and human insight the human

00:05:26,919 --> 00:05:32,410
insight part is very important it's what

00:05:29,919 --> 00:05:34,690
brings the goals to documentation what

00:05:32,410 --> 00:05:36,100
should i document domain knowledge what

00:05:34,690 --> 00:05:37,360
do people need to know about and how

00:05:36,100 --> 00:05:39,520
should I explain this in a way that's

00:05:37,360 --> 00:05:41,560
tax task relevant to them and then this

00:05:39,520 --> 00:05:43,419
idea of empathy who's my audience what

00:05:41,560 --> 00:05:44,620
details do I have to share with them so

00:05:43,419 --> 00:05:47,950
they're capable of getting up and

00:05:44,620 --> 00:05:49,390
running with this code this human part

00:05:47,950 --> 00:05:50,950
is really important to producing

00:05:49,390 --> 00:05:52,150
documentation and it's something that

00:05:50,950 --> 00:05:54,580
we're not going to get rid of anytime

00:05:52,150 --> 00:05:56,830
soon the other part of Bionic

00:05:54,580 --> 00:05:58,510
documentation is the automated side of

00:05:56,830 --> 00:06:00,010
it the side that's capable of

00:05:58,510 --> 00:06:02,320
guaranteeing the correctness and

00:06:00,010 --> 00:06:04,810
completeness of code examples as capable

00:06:02,320 --> 00:06:06,550
of giving existing documentation and

00:06:04,810 --> 00:06:08,440
ideas greater reach than they would have

00:06:06,550 --> 00:06:10,570
if a programmer was to just write a

00:06:08,440 --> 00:06:12,370
single documentation page and to be able

00:06:10,570 --> 00:06:14,650
to adapt to this documentation to new

00:06:12,370 --> 00:06:17,770
audiences and new pieces of code using

00:06:14,650 --> 00:06:21,040
the same fundamental insights all this

00:06:17,770 --> 00:06:23,470
together you know the human side

00:06:21,040 --> 00:06:25,690
together with this automated side bring

00:06:23,470 --> 00:06:28,060
they come together into these Bionic

00:06:25,690 --> 00:06:29,650
documentation tools which leverage code

00:06:28,060 --> 00:06:32,380
analysis in many different ways to help

00:06:29,650 --> 00:06:34,090
programmers capture shape amplify and

00:06:32,380 --> 00:06:35,280
share their insights with other

00:06:34,090 --> 00:06:37,660
programmers

00:06:35,280 --> 00:06:38,950
in this talk I'm going to talk about

00:06:37,660 --> 00:06:41,260
three different projects that have

00:06:38,950 --> 00:06:42,610
worked on during my PhD research that

00:06:41,260 --> 00:06:44,770
are aimed to help programmers share

00:06:42,610 --> 00:06:47,410
examples and explanations of code with

00:06:44,770 --> 00:06:49,900
each other the first of these is called

00:06:47,410 --> 00:06:51,400
code code scoop and it's an intelligent

00:06:49,900 --> 00:06:53,950
assistant that plugs into your editor

00:06:51,400 --> 00:06:55,600
that helps programmers extract examples

00:06:53,950 --> 00:06:59,560
that are tailored to a specific audience

00:06:55,600 --> 00:07:01,510
out of their own tangled code the second

00:06:59,560 --> 00:07:02,800
project is called tutor ins it's called

00:07:01,510 --> 00:07:06,190
tutor islands because you can imagine it

00:07:02,800 --> 00:07:07,960
as items of tutorials these context

00:07:06,190 --> 00:07:11,140
relevant explanations that can be added

00:07:07,960 --> 00:07:14,920
on the fly to existing code examples in

00:07:11,140 --> 00:07:17,140
tutorials and then the last one is a

00:07:14,920 --> 00:07:19,690
project about telemetry how can we learn

00:07:17,140 --> 00:07:21,670
more about the questions that API users

00:07:19,690 --> 00:07:24,940
have about the AP is that they're using

00:07:21,670 --> 00:07:27,490
how can we get how can we get these

00:07:24,940 --> 00:07:29,530
questions in a way that's ecologically

00:07:27,490 --> 00:07:31,210
valid in a way that captures these

00:07:29,530 --> 00:07:33,370
ephemeral questions that might only come

00:07:31,210 --> 00:07:37,630
up once every few hours during part of

00:07:33,370 --> 00:07:39,130
programming work so I'm gonna leave in

00:07:37,630 --> 00:07:40,540
with the codes group project which is

00:07:39,130 --> 00:07:42,550
all about providing an intelligent

00:07:40,540 --> 00:07:44,500
assistant help programmers extract usage

00:07:42,550 --> 00:07:48,520
examples out of meaningful patterns in

00:07:44,500 --> 00:07:51,790
their own code why did we focus on code

00:07:48,520 --> 00:07:53,890
examples well code examples are a really

00:07:51,790 --> 00:07:55,960
great currency of knowledge exchange for

00:07:53,890 --> 00:07:59,470
programmers we use them all the time in

00:07:55,960 --> 00:08:00,520
our tutorials in our online textbooks we

00:07:59,470 --> 00:08:02,919
use them in on

00:08:00,520 --> 00:08:04,870
QA things like stackoverflow in order to

00:08:02,919 --> 00:08:07,870
communicate these insights about how to

00:08:04,870 --> 00:08:10,270
do things in just a few lines of code we

00:08:07,870 --> 00:08:12,039
shared them over chat in order to

00:08:10,270 --> 00:08:15,039
explain to other people what we've done

00:08:12,039 --> 00:08:16,569
how they can build on it and we also

00:08:15,039 --> 00:08:21,550
post them on code sharing sites for

00:08:16,569 --> 00:08:23,560
other people to build on and extend Marc

00:08:21,550 --> 00:08:25,780
Sachs has a great quote about code

00:08:23,560 --> 00:08:28,270
examples and their role in on-the-job

00:08:25,780 --> 00:08:30,190
learning in 1994 when he observed

00:08:28,270 --> 00:08:32,709
programmers working he said that people

00:08:30,190 --> 00:08:34,570
learn more and do more work by copying

00:08:32,709 --> 00:08:36,339
and following examples and by working

00:08:34,570 --> 00:08:39,099
their way through exercises than by any

00:08:36,339 --> 00:08:40,539
other single activity code examples are

00:08:39,099 --> 00:08:42,700
fundamental part of the craft of

00:08:40,539 --> 00:08:46,660
learning how to do new things on the fly

00:08:42,700 --> 00:08:48,040
in picking up new technologies the main

00:08:46,660 --> 00:08:50,320
question that was behind the code scope

00:08:48,040 --> 00:08:51,880
work was how can tools make it easier

00:08:50,320 --> 00:08:54,760
for programmers to share examples that

00:08:51,880 --> 00:08:57,040
are based on their own code so when a

00:08:54,760 --> 00:08:59,020
programmer has a program that they've

00:08:57,040 --> 00:09:01,029
written which might be detailed highly

00:08:59,020 --> 00:09:02,860
personal highly tangulls have a bunch of

00:09:01,029 --> 00:09:05,079
business logic in it how can we help

00:09:02,860 --> 00:09:07,120
them extract out concise pipey

00:09:05,079 --> 00:09:08,890
self-contained executive all code

00:09:07,120 --> 00:09:11,730
example that demonstrates an important

00:09:08,890 --> 00:09:15,310
pattern which then they can do with

00:09:11,730 --> 00:09:16,990
whatever they want do serve any of the

00:09:15,310 --> 00:09:19,420
purposes that we usually do with usage

00:09:16,990 --> 00:09:22,480
examples sharing it as know-how over

00:09:19,420 --> 00:09:26,290
chat posting it to blogs wiki's QA and

00:09:22,480 --> 00:09:28,420
so on and the reason we wanted to build

00:09:26,290 --> 00:09:30,160
a tool for this is because simplifying

00:09:28,420 --> 00:09:31,630
code and making it executive all in

00:09:30,160 --> 00:09:33,850
tweakable by other people is actually a

00:09:31,630 --> 00:09:35,350
really challenging thing once you try to

00:09:33,850 --> 00:09:37,270
make these examples useable to other

00:09:35,350 --> 00:09:38,860
people rather than just copying and

00:09:37,270 --> 00:09:41,380
pasting chunks of code and because a

00:09:38,860 --> 00:09:42,790
very involved process when we invited

00:09:41,380 --> 00:09:44,740
programmers into the lab to make

00:09:42,790 --> 00:09:46,630
executive all examples from interesting

00:09:44,740 --> 00:09:49,050
patterns in their existing code it was

00:09:46,630 --> 00:09:52,420
this tedious and time-consuming process

00:09:49,050 --> 00:09:54,040
so this is an example of a work

00:09:52,420 --> 00:09:55,570
environment of one of these programmers

00:09:54,040 --> 00:09:56,950
who is trying to create an executive

00:09:55,570 --> 00:09:59,620
world example and you can see there's a

00:09:56,950 --> 00:10:01,630
lot going on here's an editor where they

00:09:59,620 --> 00:10:04,089
were building up this example slowly by

00:10:01,630 --> 00:10:06,520
moving lines of code over from their

00:10:04,089 --> 00:10:08,949
original source program this programmer

00:10:06,520 --> 00:10:10,660
also had yet a third editor open as a

00:10:08,949 --> 00:10:11,980
testing environment where they could run

00:10:10,660 --> 00:10:12,750
this example and make sure that they

00:10:11,980 --> 00:10:14,490
hadn't broken

00:10:12,750 --> 00:10:17,520
you think about the behavior they wanted

00:10:14,490 --> 00:10:19,110
to preserve and then they also had a

00:10:17,520 --> 00:10:21,210
browser open so that they could recall

00:10:19,110 --> 00:10:22,470
some of these details about their code

00:10:21,210 --> 00:10:25,050
that they might have forgotten since

00:10:22,470 --> 00:10:26,160
they originally wrote it there were tons

00:10:25,050 --> 00:10:28,800
of errors that were introduced through

00:10:26,160 --> 00:10:31,710
the process of producing examples for

00:10:28,800 --> 00:10:33,870
instance transcription errors and errors

00:10:31,710 --> 00:10:36,420
introduced when they edited the code in

00:10:33,870 --> 00:10:38,340
order to tweak its behavior sometimes

00:10:36,420 --> 00:10:39,750
they forgot code you can imagine that

00:10:38,340 --> 00:10:41,040
sometimes your copy and paste is going

00:10:39,750 --> 00:10:42,750
to be incomplete and you find out

00:10:41,040 --> 00:10:45,990
they're undefined variables undefined

00:10:42,750 --> 00:10:47,670
imports and if a programmer started with

00:10:45,990 --> 00:10:51,180
a big project and try to whittle it down

00:10:47,670 --> 00:10:53,220
into a Pythian example this could be

00:10:51,180 --> 00:10:56,400
really time-consuming to requiring them

00:10:53,220 --> 00:10:57,720
to identify a lot of dead code and so

00:10:56,400 --> 00:11:01,020
well none of these errors is

00:10:57,720 --> 00:11:02,730
particularly nefarious and while most of

00:11:01,020 --> 00:11:04,650
these things were relatively easy to fix

00:11:02,730 --> 00:11:06,810
they happened all the time making

00:11:04,650 --> 00:11:08,940
something that would otherwise that

00:11:06,810 --> 00:11:11,220
should take only a few minutes take a

00:11:08,940 --> 00:11:13,080
long long time in order to iterate

00:11:11,220 --> 00:11:15,660
gently go through trial and error

00:11:13,080 --> 00:11:17,100
pulling code out and fixing it up in the

00:11:15,660 --> 00:11:21,810
pursuit of trying to produce useful

00:11:17,100 --> 00:11:23,310
examples from this study we decided that

00:11:21,810 --> 00:11:25,560
an intelligent assistant for creating

00:11:23,310 --> 00:11:27,480
code examples to do a few things it

00:11:25,560 --> 00:11:29,100
should be able to suggest lines of code

00:11:27,480 --> 00:11:31,470
that the current example needs to run

00:11:29,100 --> 00:11:33,210
that you're building up it should

00:11:31,470 --> 00:11:35,370
constrain your manual code edits to make

00:11:33,210 --> 00:11:36,720
sure that you can make these changes but

00:11:35,370 --> 00:11:39,570
that it will continue to preserve the

00:11:36,720 --> 00:11:41,280
behavior and compile it should enable

00:11:39,570 --> 00:11:43,410
early and frequent testing of the code

00:11:41,280 --> 00:11:44,970
so that if you do make any edits you can

00:11:43,410 --> 00:11:46,350
check them right away to make sure that

00:11:44,970 --> 00:11:49,620
they haven't broken anything important

00:11:46,350 --> 00:11:52,050
and in order to keep these code examples

00:11:49,620 --> 00:11:53,910
concise and easy and ready to plug in it

00:11:52,050 --> 00:11:55,710
should emit code except for explicit

00:11:53,910 --> 00:11:57,750
selections that a program programmer has

00:11:55,710 --> 00:12:02,100
made and fixes that they've made those

00:11:57,750 --> 00:12:04,110
examples our vision of a tool was say

00:12:02,100 --> 00:12:05,790
this is a code example that fetches a

00:12:04,110 --> 00:12:08,490
line from a database that I want to

00:12:05,790 --> 00:12:10,920
share and it ends up storing this in

00:12:08,490 --> 00:12:13,050
some important data structure like this

00:12:10,920 --> 00:12:16,110
book data data structure that I want to

00:12:13,050 --> 00:12:18,330
use later the vision of this was say

00:12:16,110 --> 00:12:21,690
that that piece of code is this tasty

00:12:18,330 --> 00:12:23,880
ice cream we wanted to make a tool that

00:12:21,690 --> 00:12:25,930
made it possible to scoop out the

00:12:23,880 --> 00:12:28,300
relevant parts of the code

00:12:25,930 --> 00:12:30,279
and serve it up as a tasty example for

00:12:28,300 --> 00:12:33,520
other programmers to consume play with

00:12:30,279 --> 00:12:35,890
and read and we called it code scoop

00:12:33,520 --> 00:12:41,440
because we were designing this scooping

00:12:35,890 --> 00:12:42,580
interaction for code examples Oh at this

00:12:41,440 --> 00:12:44,410
point I want to show you a little bit

00:12:42,580 --> 00:12:47,680
about what code scoop looks like to use

00:12:44,410 --> 00:12:49,029
and how we embody some of these ideas of

00:12:47,680 --> 00:12:51,540
what an intelligent is sustained for

00:12:49,029 --> 00:12:59,459
making usage examples what it look like

00:12:51,540 --> 00:13:02,380
so I'm gonna pull up a demo okay cool

00:12:59,459 --> 00:13:05,110
so here's a piece of existing code that

00:13:02,380 --> 00:13:07,330
a developer has written it's got a bunch

00:13:05,110 --> 00:13:09,130
of it's got a bunch of logic in it that

00:13:07,330 --> 00:13:11,200
ultimately what it does is it queries a

00:13:09,130 --> 00:13:12,820
database for a row out of that database

00:13:11,200 --> 00:13:14,220
and then it stores it in this book data

00:13:12,820 --> 00:13:17,110
structure that we've been talking about

00:13:14,220 --> 00:13:20,050
let's say I want to scoop out a relevant

00:13:17,110 --> 00:13:21,820
usage example for someone else to use my

00:13:20,050 --> 00:13:23,649
first step is to identify kind of the

00:13:21,820 --> 00:13:25,750
core of the pattern the part of it that

00:13:23,649 --> 00:13:27,640
should absolutely be there that

00:13:25,750 --> 00:13:30,220
represents an interesting pattern for

00:13:27,640 --> 00:13:32,910
someone else to reuse here it's really

00:13:30,220 --> 00:13:36,010
embodied in this line right here which

00:13:32,910 --> 00:13:37,779
which queries which uses this cursor

00:13:36,010 --> 00:13:40,990
data structure in order to get the data

00:13:37,779 --> 00:13:43,630
in a particular column of a row I start

00:13:40,990 --> 00:13:47,410
out by clicking this scoop button here

00:13:43,630 --> 00:13:49,510
and the first thing that happens is that

00:13:47,410 --> 00:13:51,070
the editor breaks into two panes on the

00:13:49,510 --> 00:13:52,839
left side we have the original source

00:13:51,070 --> 00:13:55,000
program and on the right side we have

00:13:52,839 --> 00:13:57,160
this work-in-progress code example that

00:13:55,000 --> 00:13:58,810
I'm going to be building up the first

00:13:57,160 --> 00:14:00,520
thing that code scoop does is it wraps

00:13:58,810 --> 00:14:02,890
this in some boilerplate that will allow

00:14:00,520 --> 00:14:04,300
it to compile and run but it also starts

00:14:02,890 --> 00:14:05,470
flagging some of the errors of some of

00:14:04,300 --> 00:14:07,570
the things that I've missed in this

00:14:05,470 --> 00:14:11,020
example for instance this undefined

00:14:07,570 --> 00:14:13,450
cursor in column index title variable if

00:14:11,020 --> 00:14:14,829
then assist me in resolving this usage

00:14:13,450 --> 00:14:17,350
example and building out into something

00:14:14,829 --> 00:14:19,000
complete and executable so for this

00:14:17,350 --> 00:14:20,950
cursor variable I can click on this

00:14:19,000 --> 00:14:22,779
define button and it provides me with

00:14:20,950 --> 00:14:24,459
what's essentially a quick fix

00:14:22,779 --> 00:14:27,339
except it's grounded in the original

00:14:24,459 --> 00:14:29,230
code so points me to the original line

00:14:27,339 --> 00:14:30,610
where cursor was defined you can see

00:14:29,230 --> 00:14:32,980
that highlighted on the left and

00:14:30,610 --> 00:14:34,240
flashing I can click here and that's

00:14:32,980 --> 00:14:37,420
going to include that line and you can

00:14:34,240 --> 00:14:39,470
see it's now part of the example you can

00:14:37,420 --> 00:14:40,880
see code scope is also now as

00:14:39,470 --> 00:14:42,770
if I want to include a forest structure

00:14:40,880 --> 00:14:45,800
so it's providing these intelligent

00:14:42,770 --> 00:14:47,780
advice as to other lines of code that I

00:14:45,800 --> 00:14:49,760
might want to include in this example in

00:14:47,780 --> 00:14:51,410
this case it recommends all control

00:14:49,760 --> 00:14:53,570
structures that are between lines of

00:14:51,410 --> 00:14:55,580
code that I've already included so this

00:14:53,570 --> 00:14:57,620
title equals cursor docket string is

00:14:55,580 --> 00:15:00,590
inside of this for structure this cursor

00:14:57,620 --> 00:15:03,050
is outside of it it recommends it I can

00:15:00,590 --> 00:15:05,120
see this in context realize that I don't

00:15:03,050 --> 00:15:06,620
really want this for structure there's a

00:15:05,120 --> 00:15:07,160
couple of these others that I can review

00:15:06,620 --> 00:15:08,300
too

00:15:07,160 --> 00:15:10,220
I don't really want this while

00:15:08,300 --> 00:15:11,840
structuring if structure and it's going

00:15:10,220 --> 00:15:15,050
to be capable of preserving the behavior

00:15:11,840 --> 00:15:17,270
and it adds noise to the example that I

00:15:15,050 --> 00:15:18,620
don't want but one of the things that I

00:15:17,270 --> 00:15:20,600
personally think is semantically

00:15:18,620 --> 00:15:23,210
relevant to this example is including

00:15:20,600 --> 00:15:25,610
this try structure that wraps any calls

00:15:23,210 --> 00:15:27,290
to the database in catching a connection

00:15:25,610 --> 00:15:30,410
exception I just think that's part of a

00:15:27,290 --> 00:15:34,430
clean database query so I will accept

00:15:30,410 --> 00:15:36,800
this and then it also recommends for

00:15:34,430 --> 00:15:38,390
this cursor variable other uses of this

00:15:36,800 --> 00:15:40,160
variable that might have modified it so

00:15:38,390 --> 00:15:43,270
you can see in this case this curse

00:15:40,160 --> 00:15:47,000
about execute query this one and the

00:15:43,270 --> 00:15:49,190
fetch one calls are both necessary for

00:15:47,000 --> 00:15:51,440
loading this data from a row into the

00:15:49,190 --> 00:15:52,970
cursor so code scope helps make sure

00:15:51,440 --> 00:15:55,940
that I don't forget any of this relevant

00:15:52,970 --> 00:15:59,390
code in the original program I'm gonna

00:15:55,940 --> 00:16:01,640
skip the rest another thing that we do

00:15:59,390 --> 00:16:03,530
with code scope is instead of just

00:16:01,640 --> 00:16:06,320
resolving code based on code from the

00:16:03,530 --> 00:16:07,820
original program it enables people to

00:16:06,320 --> 00:16:10,820
make these simplifications to the code

00:16:07,820 --> 00:16:12,950
to to hopefully make it more concise so

00:16:10,820 --> 00:16:15,500
for any variable that we have dynamic

00:16:12,950 --> 00:16:17,180
execution data from from the most recent

00:16:15,500 --> 00:16:19,040
execution of the program we're capable

00:16:17,180 --> 00:16:20,990
of recommending these literal values

00:16:19,040 --> 00:16:23,240
that those variables took on during the

00:16:20,990 --> 00:16:25,550
program's execution so for this column

00:16:23,240 --> 00:16:28,340
index title variable I can set it to the

00:16:25,550 --> 00:16:30,440
value of 1 which was the the value for

00:16:28,340 --> 00:16:32,330
this essentially the index that this

00:16:30,440 --> 00:16:34,160
column took on during the program's most

00:16:32,330 --> 00:16:37,850
recent runtime that we got from

00:16:34,160 --> 00:16:39,830
instrumenting that program and what this

00:16:37,850 --> 00:16:41,690
allows me to do is if there were lines

00:16:39,830 --> 00:16:43,520
that ended up computing this this

00:16:41,690 --> 00:16:47,300
variable through many involved steps I

00:16:43,520 --> 00:16:49,070
now get to remove those completely so

00:16:47,300 --> 00:16:50,870
I'll set that value there I'll make a

00:16:49,070 --> 00:16:51,880
couple more fixes here for instance

00:16:50,870 --> 00:16:53,889
replacing this career

00:16:51,880 --> 00:16:55,120
with a literal value the literal query

00:16:53,889 --> 00:16:58,630
that it took on during the program's

00:16:55,120 --> 00:17:00,069
execution and then I'll also define this

00:16:58,630 --> 00:17:02,470
database by including the original

00:17:00,069 --> 00:17:03,819
variable - and the last step is you saw

00:17:02,470 --> 00:17:06,579
that there were a bunch of automatic

00:17:03,819 --> 00:17:08,289
fixes that occurred specifically those

00:17:06,579 --> 00:17:10,809
import statements that God added to the

00:17:08,289 --> 00:17:12,250
top whenever there's a choice whenever

00:17:10,809 --> 00:17:13,839
there is a fix that could be made and

00:17:12,250 --> 00:17:15,549
there's only one possible way of

00:17:13,839 --> 00:17:17,530
resolving it coat scoop makes that fix

00:17:15,549 --> 00:17:19,419
and so in the case of these import

00:17:17,530 --> 00:17:21,429
statements it's capable of inspecting

00:17:19,419 --> 00:17:22,900
the original program identifying what

00:17:21,429 --> 00:17:24,789
import statements each of those types

00:17:22,900 --> 00:17:27,010
depend on and just pulls them into the

00:17:24,789 --> 00:17:28,419
into the top of the file resolving any

00:17:27,010 --> 00:17:30,220
of the ambiguities that might be there

00:17:28,419 --> 00:17:31,419
in a typical quick fix again we have the

00:17:30,220 --> 00:17:32,530
original working program

00:17:31,419 --> 00:17:33,970
why don't we leverage some of the

00:17:32,530 --> 00:17:35,710
knowledge about how that program worked

00:17:33,970 --> 00:17:37,860
when helping people fill out a code

00:17:35,710 --> 00:17:37,860
example

00:17:40,289 --> 00:17:46,360
so to summarize the scooping process

00:17:43,809 --> 00:17:47,740
this all begins with initial selections

00:17:46,360 --> 00:17:50,890
of a pattern that a programmer wants to

00:17:47,740 --> 00:17:52,780
share and then a series of resolutions

00:17:50,890 --> 00:17:54,880
and code fixes to that code example

00:17:52,780 --> 00:17:58,080
pulling in other relevant code that will

00:17:54,880 --> 00:18:00,490
preserve the behavior that someone wants

00:17:58,080 --> 00:18:02,409
then a programmer can review other

00:18:00,490 --> 00:18:04,270
optional things to include things like

00:18:02,409 --> 00:18:06,190
other uses of a variable or certain

00:18:04,270 --> 00:18:08,530
control structures that might add bloat

00:18:06,190 --> 00:18:09,909
instead of changing instead of being

00:18:08,530 --> 00:18:11,289
important to the pattern that's more

00:18:09,909 --> 00:18:13,870
lines to demonstrate you can choose to

00:18:11,289 --> 00:18:15,370
include those or not and then there's

00:18:13,870 --> 00:18:16,870
also the step of including

00:18:15,370 --> 00:18:19,630
simplifications to the code itself

00:18:16,870 --> 00:18:22,270
trying to eliminate irrelevant logic by

00:18:19,630 --> 00:18:23,919
replacing it with with code

00:18:22,270 --> 00:18:26,289
simplifications in this case something

00:18:23,919 --> 00:18:27,520
like variable substitutions and while

00:18:26,289 --> 00:18:28,630
these are the steps that are in the

00:18:27,520 --> 00:18:31,179
current version of the code Scoop

00:18:28,630 --> 00:18:32,770
prototype we see this as being kind of

00:18:31,179 --> 00:18:34,750
the first set of the family of

00:18:32,770 --> 00:18:37,000
primitives in the scooping and example

00:18:34,750 --> 00:18:38,909
extraction process you can imagine other

00:18:37,000 --> 00:18:41,230
types of simplifications things like

00:18:38,909 --> 00:18:42,850
substituting equivalent method sequences

00:18:41,230 --> 00:18:45,730
that are conceptually simpler to follow

00:18:42,850 --> 00:18:47,620
or stubbing out these big objects with

00:18:45,730 --> 00:18:49,150
these more concise test tubes that are

00:18:47,620 --> 00:18:50,799
capable of replicating behavior if

00:18:49,150 --> 00:18:51,789
they're not really part of the behavior

00:18:50,799 --> 00:18:55,960
that someone wants to share in an

00:18:51,789 --> 00:18:58,480
example so altogether these the

00:18:55,960 --> 00:19:00,940
selections fix-ups optional reviews and

00:18:58,480 --> 00:19:04,710
simplifications are kinds of primitives

00:19:00,940 --> 00:19:07,690
out of which a scooping tool is built

00:19:04,710 --> 00:19:09,460
in order to build a scooping tool you

00:19:07,690 --> 00:19:11,050
need a bunch of different components so

00:19:09,460 --> 00:19:13,450
and you need to support a programmer

00:19:11,050 --> 00:19:15,700
after they have selected code and adding

00:19:13,450 --> 00:19:17,260
in forgotten lines in being able to

00:19:15,700 --> 00:19:19,510
simplify the code and also making some

00:19:17,260 --> 00:19:21,010
of these automated fixes so some of the

00:19:19,510 --> 00:19:23,560
things that we orchestrate together in

00:19:21,010 --> 00:19:25,510
the backend of this tool is static data

00:19:23,560 --> 00:19:27,760
flow analysis in order to find all of

00:19:25,510 --> 00:19:29,230
the definitions and uses of variable to

00:19:27,760 --> 00:19:32,350
be able to locate the places where

00:19:29,230 --> 00:19:34,240
variables are defined in order to help

00:19:32,350 --> 00:19:36,310
people simplify the code we instrument

00:19:34,240 --> 00:19:38,440
the code at runtime in order to find out

00:19:36,310 --> 00:19:39,970
the values that objects and variables

00:19:38,440 --> 00:19:41,770
take on during the program's execution

00:19:39,970 --> 00:19:44,340
and being able to serve those up as

00:19:41,770 --> 00:19:47,350
options to simplifying a piece of code

00:19:44,340 --> 00:19:49,660
in order to make automated fixes for

00:19:47,350 --> 00:19:51,970
instance like including these imports we

00:19:49,660 --> 00:19:55,210
use reflections to be able to find out

00:19:51,970 --> 00:19:58,270
what what import statements define

00:19:55,210 --> 00:19:59,650
certain types and throughout all of this

00:19:58,270 --> 00:20:01,930
we use a whole bunch of per

00:19:59,650 --> 00:20:05,170
streetwalkers because what we have to do

00:20:01,930 --> 00:20:07,510
is we have to map locations from the

00:20:05,170 --> 00:20:08,980
analyses back to concrete locations in

00:20:07,510 --> 00:20:10,540
the original code that we can highlight

00:20:08,980 --> 00:20:12,580
and make interactive as someone is

00:20:10,540 --> 00:20:15,190
building up this example mapping all of

00:20:12,580 --> 00:20:18,130
these analyses into these hooks in the

00:20:15,190 --> 00:20:20,140
in the code interface so all of these

00:20:18,130 --> 00:20:25,630
things compose together make up a

00:20:20,140 --> 00:20:28,090
scooping tool we ran a lab study where

00:20:25,630 --> 00:20:30,430
invited participants to make make

00:20:28,090 --> 00:20:33,100
examples with both code scoop and a

00:20:30,430 --> 00:20:34,810
baseline text editor and what we ended

00:20:33,100 --> 00:20:37,000
up finding out was that code scoop was

00:20:34,810 --> 00:20:38,380
capable of removing some of that tedium

00:20:37,000 --> 00:20:40,270
and time-consuming nature of

00:20:38,380 --> 00:20:42,160
constructing examples that we saw in

00:20:40,270 --> 00:20:43,600
that formative study participants were

00:20:42,160 --> 00:20:45,580
faster when they created usage examples

00:20:43,600 --> 00:20:47,050
with code scooped at a baseline they

00:20:45,580 --> 00:20:48,970
also reported that they found it easier

00:20:47,050 --> 00:20:51,430
to use more enjoyable to use and they

00:20:48,970 --> 00:20:54,430
were also happier with the examples that

00:20:51,430 --> 00:20:56,020
they created but one of the things that

00:20:54,430 --> 00:20:57,880
I was most excited about seeing in this

00:20:56,020 --> 00:21:00,310
study was that there were actually many

00:20:57,880 --> 00:21:02,500
styles for extracting a snippet we could

00:21:00,310 --> 00:21:05,170
give multiple participants the same task

00:21:02,500 --> 00:21:06,970
of of a piece of code that they should

00:21:05,170 --> 00:21:08,290
extract a sample out of and they might

00:21:06,970 --> 00:21:09,520
resolve it in different ways because

00:21:08,290 --> 00:21:11,890
they had different conceptions about

00:21:09,520 --> 00:21:13,990
what a good example looked like so for

00:21:11,890 --> 00:21:16,120
instance when we asked some participants

00:21:13,990 --> 00:21:18,130
to do this task of extracting an example

00:21:16,120 --> 00:21:22,360
that queried a database for

00:21:18,130 --> 00:21:24,340
of data one of the participants found it

00:21:22,360 --> 00:21:26,260
very important to wrap this this call in

00:21:24,340 --> 00:21:27,940
a try-catch block and also a check to

00:21:26,260 --> 00:21:31,780
make sure that the cursor I'd returned

00:21:27,940 --> 00:21:34,060
any data at all before getting data from

00:21:31,780 --> 00:21:35,200
a particular column but another

00:21:34,060 --> 00:21:36,730
participant thought that it wasn't

00:21:35,200 --> 00:21:39,280
important to include any of this error

00:21:36,730 --> 00:21:41,470
handling logic but they did want to give

00:21:39,280 --> 00:21:43,510
explicit variable names to each of the

00:21:41,470 --> 00:21:45,610
variables instead of literal values and

00:21:43,510 --> 00:21:47,530
they also wanted to wrap up the save

00:21:45,610 --> 00:21:49,210
data into this book data structure to

00:21:47,530 --> 00:21:50,820
show someone a little bit about what you

00:21:49,210 --> 00:21:52,900
might do with the data that you've query

00:21:50,820 --> 00:21:55,150
one of the cool things about this is

00:21:52,900 --> 00:21:56,830
that this really adheres to this vision

00:21:55,150 --> 00:22:00,370
of Bionic documentation tools where

00:21:56,830 --> 00:22:02,110
automation alone can do a lot but you

00:22:00,370 --> 00:22:04,330
still want to incorporate human insight

00:22:02,110 --> 00:22:06,370
into the process because humans are

00:22:04,330 --> 00:22:08,140
capable of empathizing with and thinking

00:22:06,370 --> 00:22:09,820
about their audience and making these

00:22:08,140 --> 00:22:11,350
decisions about what they want to

00:22:09,820 --> 00:22:13,510
include in documentation and what they

00:22:11,350 --> 00:22:15,010
should leave out and what's semantically

00:22:13,510 --> 00:22:20,170
important to people understanding how to

00:22:15,010 --> 00:22:22,390
do a task so as a Bionic documentation

00:22:20,170 --> 00:22:24,100
tool code scoop addresses the space of

00:22:22,390 --> 00:22:26,680
helping people generate these usage

00:22:24,100 --> 00:22:27,850
examples encoding some of the goals that

00:22:26,680 --> 00:22:29,170
they have and there was initial

00:22:27,850 --> 00:22:31,090
selections that they make in the code

00:22:29,170 --> 00:22:32,680
encoding some of their empathy by

00:22:31,090 --> 00:22:34,660
allowing them to resolve these choices

00:22:32,680 --> 00:22:36,250
in multiple ways it's helped them build

00:22:34,660 --> 00:22:37,420
out an example that will be more suited

00:22:36,250 --> 00:22:39,280
to the audience that they're addressing

00:22:37,420 --> 00:22:40,720
while also ensuring the correctness and

00:22:39,280 --> 00:22:45,520
completeness of the examples that they

00:22:40,720 --> 00:22:47,800
create so that's the first Bionic

00:22:45,520 --> 00:22:49,660
documentation tool and once

00:22:47,800 --> 00:22:50,700
documentation has examples the next

00:22:49,660 --> 00:22:53,170
thing that is going to need is

00:22:50,700 --> 00:22:55,270
explanations written descriptions of

00:22:53,170 --> 00:22:56,740
what the code does and how you can

00:22:55,270 --> 00:22:59,920
modify it in order to make it suit your

00:22:56,740 --> 00:23:02,380
purposes that's what this tutor on was

00:22:59,920 --> 00:23:05,680
all about the case that we wanted to

00:23:02,380 --> 00:23:07,510
support with two neurons was so say I'm

00:23:05,680 --> 00:23:10,060
looking for a command that allows me to

00:23:07,510 --> 00:23:14,320
download a bunch of data archives from

00:23:10,060 --> 00:23:15,930
an existing website I might end up on a

00:23:14,320 --> 00:23:18,190
tutorial like the one that you see here

00:23:15,930 --> 00:23:22,420
looking at a command like the one that

00:23:18,190 --> 00:23:24,450
you see right here W guy - R - l1 - H

00:23:22,420 --> 00:23:27,550
and a whole bunch of other options and

00:23:24,450 --> 00:23:31,320
this is pretty close to what I need if I

00:23:27,550 --> 00:23:33,240
change the value of that - April

00:23:31,320 --> 00:23:35,280
then I can make a download data archive

00:23:33,240 --> 00:23:37,020
of a certain type but as it turns out

00:23:35,280 --> 00:23:39,000
this is broken for me because I wanted

00:23:37,020 --> 00:23:41,400
to recurse into the folders on this

00:23:39,000 --> 00:23:43,230
website go several layers deep in order

00:23:41,400 --> 00:23:45,600
to find these pieces of data instead of

00:23:43,230 --> 00:23:46,890
just one level deep and just looking at

00:23:45,600 --> 00:23:49,910
this it's not really clear what I have

00:23:46,890 --> 00:23:51,720
to change and if I rely on conventional

00:23:49,910 --> 00:23:53,130
documentation for instance these man

00:23:51,720 --> 00:23:56,010
pages that I might be able to Google

00:23:53,130 --> 00:23:59,490
well these things go on and on and on in

00:23:56,010 --> 00:24:01,500
the case of of this man page is 89 pages

00:23:59,490 --> 00:24:04,260
if you print it out on a laser printer

00:24:01,500 --> 00:24:06,990
it's just really long and while you can

00:24:04,260 --> 00:24:08,610
control f within it it's still a lot of

00:24:06,990 --> 00:24:10,440
this information it's fragmented in

00:24:08,610 --> 00:24:11,910
different places sometimes it's an

00:24:10,440 --> 00:24:13,559
effort of just finding the authoritative

00:24:11,910 --> 00:24:15,450
place where this documentation is in the

00:24:13,559 --> 00:24:17,010
first place and so for someone who's

00:24:15,450 --> 00:24:19,020
never looked at it W get command before

00:24:17,010 --> 00:24:21,660
this can provide this can produce some

00:24:19,020 --> 00:24:25,860
barriers to being able to follow and

00:24:21,660 --> 00:24:28,140
modify these these snippets of code so

00:24:25,860 --> 00:24:30,030
what we envisioned was we wanted to for

00:24:28,140 --> 00:24:33,210
some of these four code snippets some of

00:24:30,030 --> 00:24:35,550
these cryptic domain-specific languages

00:24:33,210 --> 00:24:38,220
like this command or later I'll show you

00:24:35,550 --> 00:24:39,960
CSS selectors and regular expressions we

00:24:38,220 --> 00:24:42,059
wanted to be able to detect these

00:24:39,960 --> 00:24:44,280
automatically and then when someone

00:24:42,059 --> 00:24:46,410
found a code snippet like this and a

00:24:44,280 --> 00:24:48,390
piece of documentation generate these

00:24:46,410 --> 00:24:51,570
context relevant explanations on-the-fly

00:24:48,390 --> 00:24:54,210
like the one that you see here we wanted

00:24:51,570 --> 00:24:56,700
to do this in the browser and in fact we

00:24:54,210 --> 00:24:57,870
we implemented this as both a library

00:24:56,700 --> 00:25:00,420
that people could incorporate into

00:24:57,870 --> 00:25:03,090
tutorial pages as well as an add-on for

00:25:00,420 --> 00:25:07,380
the for I think I'm Oh still a browser

00:25:03,090 --> 00:25:09,570
actually because programmers do a lot of

00:25:07,380 --> 00:25:15,360
their information seeking in search in

00:25:09,570 --> 00:25:16,920
the browser and what we what this

00:25:15,360 --> 00:25:18,750
project was all about was thinking about

00:25:16,920 --> 00:25:20,670
what these explanations might look like

00:25:18,750 --> 00:25:22,559
if you could give someone a context

00:25:20,670 --> 00:25:24,300
relevant explanation and explain just

00:25:22,559 --> 00:25:26,340
what someone needs to know in order to

00:25:24,300 --> 00:25:28,170
understand why a piece of code exists

00:25:26,340 --> 00:25:30,600
what it does and how to modify it what

00:25:28,170 --> 00:25:32,100
would you show in it this is one

00:25:30,600 --> 00:25:34,260
explanation that's built by a tutor on

00:25:32,100 --> 00:25:35,520
for the W git command line and you can

00:25:34,260 --> 00:25:37,070
see that there are a few things that we

00:25:35,520 --> 00:25:40,020
thought was important to include in this

00:25:37,070 --> 00:25:42,279
first introducing the language saying

00:25:40,020 --> 00:25:44,619
that this is a W get command it's

00:25:42,279 --> 00:25:45,879
to command it's a terminal command that

00:25:44,619 --> 00:25:48,399
lets you download pages from the

00:25:45,879 --> 00:25:50,139
internet so for someone who is not it's

00:25:48,399 --> 00:25:51,700
not knowledgeable about the UNIX space

00:25:50,139 --> 00:25:54,090
at all this is enough for them to get

00:25:51,700 --> 00:25:55,690
some context about what that code does

00:25:54,090 --> 00:25:57,190
then we give these high-level

00:25:55,690 --> 00:25:59,139
descriptions of what it does for

00:25:57,190 --> 00:26:02,080
instance it recursively scrapes web

00:25:59,139 --> 00:26:05,080
pages of type mp3 from URLs from the

00:26:02,080 --> 00:26:06,460
file mp3 sites dot txt and then the next

00:26:05,080 --> 00:26:09,129
thing it does is it provides this

00:26:06,460 --> 00:26:10,749
low-level breakdown of the syntax but

00:26:09,129 --> 00:26:13,299
just the pieces of syntax that are in

00:26:10,749 --> 00:26:15,339
this command so W gate has around 150

00:26:13,299 --> 00:26:16,809
options and this shows that the relevant

00:26:15,339 --> 00:26:19,629
help strings for just the ten that we're

00:26:16,809 --> 00:26:20,950
used in this command this - are this - L

00:26:19,629 --> 00:26:22,210
that the programmer is going to have to

00:26:20,950 --> 00:26:25,499
change if they want this to recurse

00:26:22,210 --> 00:26:27,820
deeper into the site and so on

00:26:25,499 --> 00:26:29,710
this project was all about thinking

00:26:27,820 --> 00:26:31,119
about if you could make these

00:26:29,710 --> 00:26:32,409
explanations automatically you what

00:26:31,119 --> 00:26:34,570
would you explain and how would you

00:26:32,409 --> 00:26:36,489
generate these explanations you might

00:26:34,570 --> 00:26:38,139
want to explain individual tokens or

00:26:36,489 --> 00:26:39,849
false statements you might want to

00:26:38,139 --> 00:26:42,279
explain what a language is typically for

00:26:39,849 --> 00:26:43,719
or provide these links to other relevant

00:26:42,279 --> 00:26:46,299
references that someone might not have

00:26:43,719 --> 00:26:48,129
found on their own how can we generate

00:26:46,299 --> 00:26:51,489
these we can make string templates that

00:26:48,129 --> 00:26:53,529
describe common usage of these commands

00:26:51,489 --> 00:26:56,049
and these CSS selectors and regular

00:26:53,529 --> 00:26:57,549
expressions we can use these rule based

00:26:56,049 --> 00:26:59,769
approaches to build up these natural

00:26:57,549 --> 00:27:01,719
language sentences from scratch we can

00:26:59,769 --> 00:27:03,549
leverage community tools because a lot

00:27:01,719 --> 00:27:05,889
of the time communities have already

00:27:03,549 --> 00:27:08,320
made these tools for understanding these

00:27:05,889 --> 00:27:09,669
these hard to understand languages we

00:27:08,320 --> 00:27:12,039
can take snippets out of existing

00:27:09,669 --> 00:27:14,799
documentation we can render this

00:27:12,039 --> 00:27:19,869
ultimately as text input/output examples

00:27:14,799 --> 00:27:22,559
and diagrams so what do some of these

00:27:19,869 --> 00:27:25,690
two neurons look like in the wild so

00:27:22,559 --> 00:27:29,019
here is a tutorial page and this

00:27:25,690 --> 00:27:31,869
tutorial page is it's about web scraping

00:27:29,019 --> 00:27:33,629
with Python and this web tutorial uses

00:27:31,869 --> 00:27:36,429
CSS selectors in order to identify

00:27:33,629 --> 00:27:39,460
elements and web pages out of wish you'd

00:27:36,429 --> 00:27:42,549
want to extract data and you can see

00:27:39,460 --> 00:27:44,979
highlighted in purple here's a here's a

00:27:42,549 --> 00:27:47,139
couple of CSS selectors that a tutor on

00:27:44,979 --> 00:27:51,789
has identified this day of pound video

00:27:47,139 --> 00:27:53,710
box h3 diff pound sidebar a href carrot

00:27:51,789 --> 00:27:54,860
Igor slash speaker and so on and so

00:27:53,710 --> 00:27:55,940
forth

00:27:54,860 --> 00:27:57,860
these are things that if you have never

00:27:55,940 --> 00:27:59,570
used CSS selectors before or even if

00:27:57,860 --> 00:28:01,610
you're a little rusty on CSS selectors

00:27:59,570 --> 00:28:03,470
if you want to be able to understand

00:28:01,610 --> 00:28:05,150
what these are doing and be able to

00:28:03,470 --> 00:28:06,980
modify these it can be really

00:28:05,150 --> 00:28:08,929
challenging to understand how to do so

00:28:06,980 --> 00:28:12,320
without having like a really firm basis

00:28:08,929 --> 00:28:14,330
in CSS selectors this is the type of

00:28:12,320 --> 00:28:17,210
explanation that that are produced for

00:28:14,330 --> 00:28:21,049
this CSS selector tutor on and you can

00:28:17,210 --> 00:28:23,720
see like with the W gate selector we we

00:28:21,049 --> 00:28:25,760
explain what the what these what

00:28:23,720 --> 00:28:27,140
selectors are for we say if you haven't

00:28:25,760 --> 00:28:30,260
seen them before these are what

00:28:27,140 --> 00:28:32,540
selectors do we also generate these

00:28:30,260 --> 00:28:34,160
natural language descriptions so as it

00:28:32,540 --> 00:28:35,929
turns out for CSS selectors the

00:28:34,160 --> 00:28:37,970
correspondence between a natural

00:28:35,929 --> 00:28:40,910
language constituency tree and a parse

00:28:37,970 --> 00:28:43,490
tree are actually pretty clear you can

00:28:40,910 --> 00:28:45,169
describe how some some inner element is

00:28:43,490 --> 00:28:47,030
getting selected from an outer element

00:28:45,169 --> 00:28:50,240
to be able to produce explanations like

00:28:47,030 --> 00:28:52,010
this selector chooses all links with an

00:28:50,240 --> 00:28:54,710
address that starts with speaker from

00:28:52,010 --> 00:28:56,330
div elements that have IV sidebar and

00:28:54,710 --> 00:28:58,669
with some for someone who hasn't ever

00:28:56,330 --> 00:28:59,900
seen a CSS selector before they can

00:28:58,669 --> 00:29:01,460
already start to do some pattern

00:28:59,900 --> 00:29:03,500
matching to know how they should modify

00:29:01,460 --> 00:29:04,700
the CSS selector for instance if they

00:29:03,500 --> 00:29:06,710
want to change something related to an

00:29:04,700 --> 00:29:10,580
ID they now know that a corresponds to

00:29:06,710 --> 00:29:12,860
it's a hash mark we also generate these

00:29:10,580 --> 00:29:15,730
input output examples again starting at

00:29:12,860 --> 00:29:19,100
the the leaf nodes of this parse tree

00:29:15,730 --> 00:29:21,230
building up these pieces of an HTML web

00:29:19,100 --> 00:29:23,360
page that would match and slowly

00:29:21,230 --> 00:29:25,370
climbing that parse tree and generating

00:29:23,360 --> 00:29:27,559
these outer elements showing that for

00:29:25,370 --> 00:29:30,200
instance this bolded anchor right here

00:29:27,559 --> 00:29:32,870
is what will get selected from an from a

00:29:30,200 --> 00:29:35,660
part of an HTML page that has a div with

00:29:32,870 --> 00:29:37,340
an ID sidebar and an ancestor with an

00:29:35,660 --> 00:29:41,299
anchor with an href that starts with

00:29:37,340 --> 00:29:43,190
speaker you can also see that this

00:29:41,299 --> 00:29:45,320
tutorial has multiple to durant's

00:29:43,190 --> 00:29:47,450
enabled for it so we have one for both

00:29:45,320 --> 00:29:49,460
these CSS selectors as well as for

00:29:47,450 --> 00:29:51,320
Python built-ins so it is detected this

00:29:49,460 --> 00:29:53,870
in one and what we've done is we've

00:29:51,320 --> 00:29:55,520
snipped up the Python reference

00:29:53,870 --> 00:29:57,290
documentation and we serve up the

00:29:55,520 --> 00:29:58,730
relevant doc strings from this as well

00:29:57,290 --> 00:30:00,850
as pointers to the original Python

00:29:58,730 --> 00:30:00,850
documentation

00:30:03,960 --> 00:30:07,900
we also experimented with incorporating

00:30:06,520 --> 00:30:09,820
existing community tools and

00:30:07,900 --> 00:30:12,220
visualizations so here's a regular

00:30:09,820 --> 00:30:14,260
expression that appeared in a Stack

00:30:12,220 --> 00:30:18,780
Overflow post about server configuration

00:30:14,260 --> 00:30:21,790
and you can see this diagram with the

00:30:18,780 --> 00:30:23,920
dark gray and the lime-green and what

00:30:21,790 --> 00:30:26,530
this is this is a railroad diagram and

00:30:23,920 --> 00:30:27,820
you can read it from left to right in

00:30:26,530 --> 00:30:29,620
order to understand what this regular

00:30:27,820 --> 00:30:32,470
expression is doing matches a start up

00:30:29,620 --> 00:30:34,540
line followed by an optional WW followed

00:30:32,470 --> 00:30:37,360
by any character followed by domain and

00:30:34,540 --> 00:30:38,890
so on and so forth this describes at a

00:30:37,360 --> 00:30:40,450
fine-grained level what this regular

00:30:38,890 --> 00:30:41,710
expression is doing and if you follow it

00:30:40,450 --> 00:30:43,600
left to right you can get a pretty good

00:30:41,710 --> 00:30:45,460
intuition for how it's doing the match

00:30:43,600 --> 00:30:47,020
the other cool thing is that with this

00:30:45,460 --> 00:30:49,270
particular explanation you can find a

00:30:47,020 --> 00:30:50,920
bug with this example which is that that

00:30:49,270 --> 00:30:52,570
dot should be escaped because it's

00:30:50,920 --> 00:30:54,850
actually matching any character and

00:30:52,570 --> 00:30:57,570
since your since you're trying to match

00:30:54,850 --> 00:31:00,400
a URL it should really be backslash dawn

00:30:57,570 --> 00:31:02,230
we also generate these input-output

00:31:00,400 --> 00:31:04,440
examples that's at the very bottom where

00:31:02,230 --> 00:31:08,080
you can see that this pattern matches

00:31:04,440 --> 00:31:13,390
mention of strings including wwp domain

00:31:08,080 --> 00:31:15,070
equals comm and domain pipe comm this

00:31:13,390 --> 00:31:16,510
railroad diagram was actually generated

00:31:15,070 --> 00:31:18,820
through a tool called reg expert that

00:31:16,510 --> 00:31:20,410
already exists that developers have

00:31:18,820 --> 00:31:22,000
created for other developers as an

00:31:20,410 --> 00:31:24,070
online web app where you can plug in

00:31:22,000 --> 00:31:26,230
arbitrary regular expressions to produce

00:31:24,070 --> 00:31:28,120
these visualizations so a lot of this

00:31:26,230 --> 00:31:29,710
machinery is already sitting around

00:31:28,120 --> 00:31:32,080
why don't we plug them into these

00:31:29,710 --> 00:31:33,670
contexts relevant explanation saying can

00:31:32,080 --> 00:31:36,900
we appear right in the places where

00:31:33,670 --> 00:31:36,900
programmers are asking these questions

00:31:38,070 --> 00:31:42,670
so that's a little bit about how we

00:31:40,510 --> 00:31:46,870
explored this space of what to explain

00:31:42,670 --> 00:31:49,000
and how with deuterons 4w gate commands

00:31:46,870 --> 00:31:53,140
for CSS selectors regular expressions

00:31:49,000 --> 00:31:54,400
and Python built-ins there's a lot of

00:31:53,140 --> 00:31:57,850
boilerplate that goes into building

00:31:54,400 --> 00:32:01,210
these so for instance fetching these web

00:31:57,850 --> 00:32:03,100
pages and then traversing them in order

00:32:01,210 --> 00:32:05,370
to try to find these explainable regions

00:32:03,100 --> 00:32:07,870
highlighting them enabling these

00:32:05,370 --> 00:32:09,520
tooltips to appear on click and having

00:32:07,870 --> 00:32:11,530
this communication between the web page

00:32:09,520 --> 00:32:14,380
in the server we've abstracted all of

00:32:11,530 --> 00:32:15,900
this out into to two projects one of

00:32:14,380 --> 00:32:18,420
them on the server side one of them

00:32:15,900 --> 00:32:20,690
library site and so in order to create a

00:32:18,420 --> 00:32:22,860
new tutor on that is very basic

00:32:20,690 --> 00:32:24,840
something that's capable of looking for

00:32:22,860 --> 00:32:26,790
particular tokens and serving up

00:32:24,840 --> 00:32:27,930
explanations from a dictionary this is

00:32:26,790 --> 00:32:30,450
something that can be implemented with

00:32:27,930 --> 00:32:31,920
around ten lines of novel code if you

00:32:30,450 --> 00:32:34,230
want to do something more involved that

00:32:31,920 --> 00:32:35,160
might require hundreds or so but a lot

00:32:34,230 --> 00:32:37,950
of that boilerplate

00:32:35,160 --> 00:32:41,280
of detecting regions within a web page

00:32:37,950 --> 00:32:42,960
and then mapping them back to these to

00:32:41,280 --> 00:32:45,210
these explanations that you can display

00:32:42,960 --> 00:32:47,310
has already been done upfront so if

00:32:45,210 --> 00:32:48,930
anyone was interested in trying out this

00:32:47,310 --> 00:32:54,570
interaction we've done a lot of that

00:32:48,930 --> 00:32:57,120
legwork for you in order to better

00:32:54,570 --> 00:33:00,960
understand the potential of having these

00:32:57,120 --> 00:33:02,310
small context relevant explanations as a

00:33:00,960 --> 00:33:04,500
tool for programmers to understand

00:33:02,310 --> 00:33:07,740
documentation we did a pilot usability

00:33:04,500 --> 00:33:10,890
study where we give programmers tasks

00:33:07,740 --> 00:33:12,660
like for instance writing a CSS selector

00:33:10,890 --> 00:33:15,090
that selects only elements of a specific

00:33:12,660 --> 00:33:17,130
class and then we showed them a code

00:33:15,090 --> 00:33:18,660
example that was somewhat relevant to

00:33:17,130 --> 00:33:21,270
this task but didn't give them the exact

00:33:18,660 --> 00:33:23,730
answer for half of the tasks we allowed

00:33:21,270 --> 00:33:24,630
them to access to Terron generated micro

00:33:23,730 --> 00:33:26,670
exfoliations

00:33:24,630 --> 00:33:29,130
and that were capable of giving more

00:33:26,670 --> 00:33:30,840
context about what this snippet did and

00:33:29,130 --> 00:33:32,850
we observed how often they had to access

00:33:30,840 --> 00:33:36,660
external documentation when performing

00:33:32,850 --> 00:33:38,310
this code modification task participants

00:33:36,660 --> 00:33:39,870
in general accessed external

00:33:38,310 --> 00:33:42,000
documentation significantly less

00:33:39,870 --> 00:33:44,790
frequently when these explanations were

00:33:42,000 --> 00:33:46,560
available which is good it suggests that

00:33:44,790 --> 00:33:48,210
these explanations are doing just what

00:33:46,560 --> 00:33:50,280
we wanted them to do providing people

00:33:48,210 --> 00:33:52,380
with just as much information as they

00:33:50,280 --> 00:33:54,950
would need to understand and modify the

00:33:52,380 --> 00:33:57,390
code without requiring them to get

00:33:54,950 --> 00:34:02,790
bogged down in the details of external

00:33:57,390 --> 00:34:04,680
documentation the two neurons project

00:34:02,790 --> 00:34:07,320
represents another paradigm for Bionic

00:34:04,680 --> 00:34:09,570
documentation tools instead of helping

00:34:07,320 --> 00:34:12,659
programmers produce examples it helps

00:34:09,570 --> 00:34:14,340
them generate these explanations unlike

00:34:12,659 --> 00:34:16,290
the code scoop tool where a programmer

00:34:14,340 --> 00:34:18,270
and a tool worked hand in hand in real

00:34:16,290 --> 00:34:19,919
time with a tutor on project a

00:34:18,270 --> 00:34:22,350
programmer invests a lot of their domain

00:34:19,919 --> 00:34:24,929
knowledge up front building some of

00:34:22,350 --> 00:34:27,000
these detectors and explainers but then

00:34:24,929 --> 00:34:29,280
after that some of these explanations of

00:34:27,000 --> 00:34:31,230
code are capable of achieving much

00:34:29,280 --> 00:34:32,580
reach than they would have had before a

00:34:31,230 --> 00:34:34,380
programmer would have had to write these

00:34:32,580 --> 00:34:36,570
individually and figure out what were

00:34:34,380 --> 00:34:38,970
the relevant arguments of relevant parts

00:34:36,570 --> 00:34:42,300
of the syntax to explain in every

00:34:38,970 --> 00:34:44,820
tutorial in this case having a tutor on

00:34:42,300 --> 00:34:46,830
that's embedded in a webpage or in a

00:34:44,820 --> 00:34:48,300
browser extension makes it possible to

00:34:46,830 --> 00:34:49,919
have these explanations anywhere that

00:34:48,300 --> 00:34:52,380
the code appears in context relevant

00:34:49,919 --> 00:34:54,120
form and of course these explanations

00:34:52,380 --> 00:35:00,450
are also adapted to the code that

00:34:54,120 --> 00:35:03,150
someone is seeing so I'll wrap up with

00:35:00,450 --> 00:35:05,010
our last project which is such

00:35:03,150 --> 00:35:07,200
laboratory project that I did as an

00:35:05,010 --> 00:35:09,240
intern at Google last summer we were

00:35:07,200 --> 00:35:10,500
interested in better understanding the

00:35:09,240 --> 00:35:14,430
types of questions that people had about

00:35:10,500 --> 00:35:16,440
C++ api's so let's say you're the

00:35:14,430 --> 00:35:20,190
maintainer for an API of like this one

00:35:16,440 --> 00:35:21,600
the abseil format time API when people

00:35:20,190 --> 00:35:22,980
use an API like this they're going to

00:35:21,600 --> 00:35:25,650
have questions about how to use it

00:35:22,980 --> 00:35:27,570
questions like what is the second

00:35:25,650 --> 00:35:28,890
argument this landing argument what are

00:35:27,570 --> 00:35:32,400
the types that it can take what are

00:35:28,890 --> 00:35:35,150
valid values to pass in questions like

00:35:32,400 --> 00:35:38,900
will this crash if I pass in a past time

00:35:35,150 --> 00:35:41,670
rather than a current or future time and

00:35:38,900 --> 00:35:43,860
is there one of these % special

00:35:41,670 --> 00:35:45,990
characters that I can use to format the

00:35:43,860 --> 00:35:48,060
time four seconds or milliseconds

00:35:45,990 --> 00:35:49,260
these are just three a whole bunch of

00:35:48,060 --> 00:35:52,230
questions that people are going to have

00:35:49,260 --> 00:35:53,820
when they're coming to this API and yet

00:35:52,230 --> 00:35:55,710
what we found was that when we were

00:35:53,820 --> 00:35:58,530
connecting with API maintainer as well

00:35:55,710 --> 00:36:00,360
as technical writers at Google they all

00:35:58,530 --> 00:36:01,980
had these questions about what are the

00:36:00,360 --> 00:36:04,110
questions that the users are asking

00:36:01,980 --> 00:36:06,570
about these api's is my documentation

00:36:04,110 --> 00:36:08,670
answering everybody's questions the

00:36:06,570 --> 00:36:10,110
issue with answering this and finding

00:36:08,670 --> 00:36:12,690
out what questions people are asking

00:36:10,110 --> 00:36:17,640
about your tools is that typical

00:36:12,690 --> 00:36:20,460
usability usability typical techniques

00:36:17,640 --> 00:36:22,080
for finding usability bugs and software

00:36:20,460 --> 00:36:24,330
bugs just aren't really adequate for

00:36:22,080 --> 00:36:26,160
finding documentation bugs things like

00:36:24,330 --> 00:36:28,110
bug reports aren't likely to get

00:36:26,160 --> 00:36:30,120
submitted for documentation because a

00:36:28,110 --> 00:36:32,820
lot of times they don't actually cause

00:36:30,120 --> 00:36:36,330
code to crash or they aren't a blocker

00:36:32,820 --> 00:36:39,150
in someone's work surveys are inadequate

00:36:36,330 --> 00:36:40,380
because by the time that you send out

00:36:39,150 --> 00:36:42,000
the survey and get people's feedback

00:36:40,380 --> 00:36:42,870
they might have forgotten about really

00:36:42,000 --> 00:36:44,430
important FM

00:36:42,870 --> 00:36:48,210
questions for which they had already

00:36:44,430 --> 00:36:49,650
found the answers observation bringing

00:36:48,210 --> 00:36:51,960
people into the lab and having them work

00:36:49,650 --> 00:36:53,820
isn't so great either because these

00:36:51,960 --> 00:36:55,470
questions that the really critical ones

00:36:53,820 --> 00:36:57,150
with certain tools might only come up

00:36:55,470 --> 00:37:01,770
once every few hours or so

00:36:57,150 --> 00:37:03,660
so it's an inefficient process we were

00:37:01,770 --> 00:37:06,510
working with some of the maintainer for

00:37:03,660 --> 00:37:07,920
a C++ API is at Google and we came up

00:37:06,510 --> 00:37:09,710
with this idea about how we could

00:37:07,920 --> 00:37:12,720
connect with some of the questions that

00:37:09,710 --> 00:37:14,450
API users were using we're we're we're

00:37:12,720 --> 00:37:17,340
having during their everyday work

00:37:14,450 --> 00:37:19,260
specifically we had this hunch about C++

00:37:17,340 --> 00:37:23,370
code navigation and how that related to

00:37:19,260 --> 00:37:25,050
questions the idea was that in C++ code

00:37:23,370 --> 00:37:27,650
is divided between header files and

00:37:25,050 --> 00:37:29,910
implementation files header files

00:37:27,650 --> 00:37:31,800
include all of the methods signatures

00:37:29,910 --> 00:37:34,680
for the functions as well as this

00:37:31,800 --> 00:37:36,420
low-level usage documentation about how

00:37:34,680 --> 00:37:38,760
to call this function what you pass into

00:37:36,420 --> 00:37:42,210
it when you get back to it the expected

00:37:38,760 --> 00:37:43,980
behavior of that function the function

00:37:42,210 --> 00:37:46,320
itself is implemented in what's called a

00:37:43,980 --> 00:37:48,690
cc or an implementation file this is

00:37:46,320 --> 00:37:51,150
where the code that encodes the behavior

00:37:48,690 --> 00:37:53,760
actually exists so all of the lines of

00:37:51,150 --> 00:37:56,370
code that that implement format time are

00:37:53,760 --> 00:37:58,830
going to be in the CC file and in C++

00:37:56,370 --> 00:38:02,670
usually there is one cc file for every

00:37:58,830 --> 00:38:04,980
header file our hunch was that if parts

00:38:02,670 --> 00:38:07,080
if if programmers left these header

00:38:04,980 --> 00:38:09,030
files to open up implementation files

00:38:07,080 --> 00:38:11,760
that might indicate that they have API

00:38:09,030 --> 00:38:13,710
questions like those ones about what do

00:38:11,760 --> 00:38:15,360
these arguments do or will this crashed

00:38:13,710 --> 00:38:17,070
if I pass in a parameter of a certain

00:38:15,360 --> 00:38:18,750
type that might indicate that there are

00:38:17,070 --> 00:38:22,920
some questions that are being unanswered

00:38:18,750 --> 00:38:24,480
by the existing documentation the cool

00:38:22,920 --> 00:38:26,340
thing was that at Google like many other

00:38:24,480 --> 00:38:28,110
companies they had this central code

00:38:26,340 --> 00:38:30,540
search interface for all of their code

00:38:28,110 --> 00:38:32,130
this here it is right here you can see

00:38:30,540 --> 00:38:33,840
there's this file browser on the Left

00:38:32,130 --> 00:38:36,360
there's this query bar up at top and

00:38:33,840 --> 00:38:38,810
then you can look at the contents of the

00:38:36,360 --> 00:38:40,980
code in this main pane in the middle

00:38:38,810 --> 00:38:43,980
hundreds and thousands of programmers

00:38:40,980 --> 00:38:46,380
use this every day and so what we

00:38:43,980 --> 00:38:47,790
thought is if at that moment when

00:38:46,380 --> 00:38:50,220
someone leaves this header file to an

00:38:47,790 --> 00:38:52,869
implementation file we could provide

00:38:50,220 --> 00:38:55,450
this short easy to dismiss

00:38:52,869 --> 00:38:56,980
survey to ask about their questions this

00:38:55,450 --> 00:38:58,089
would help us get to those ephemeral

00:38:56,980 --> 00:38:59,559
moments where people who are having

00:38:58,089 --> 00:39:01,329
questions that weren't answered in the

00:38:59,559 --> 00:39:02,950
documentation would that be really cool

00:39:01,329 --> 00:39:06,099
if that allowed us to like connect with

00:39:02,950 --> 00:39:07,839
programmers right at that moment so we

00:39:06,099 --> 00:39:08,859
ask these questions like which best

00:39:07,839 --> 00:39:11,890
describes the information you're looking

00:39:08,859 --> 00:39:14,650
for and also to do a deeper drill down

00:39:11,890 --> 00:39:16,450
into the implications of this and the

00:39:14,650 --> 00:39:17,410
types of questions they were asking what

00:39:16,450 --> 00:39:19,269
would be the most convenient location

00:39:17,410 --> 00:39:20,920
for you to find this information and

00:39:19,269 --> 00:39:23,799
what question are you trying to answer

00:39:20,920 --> 00:39:25,599
about the API we deployed this over the

00:39:23,799 --> 00:39:28,720
course of a couple of days across all

00:39:25,599 --> 00:39:32,200
the C++ API code and it allowed us to do

00:39:28,720 --> 00:39:33,940
some cool things we collected a sample

00:39:32,200 --> 00:39:35,650
of API questions that people were asking

00:39:33,940 --> 00:39:37,599
as they were transitioning from header

00:39:35,650 --> 00:39:39,490
files to implementation files for

00:39:37,599 --> 00:39:42,640
instance what does the return value mean

00:39:39,490 --> 00:39:45,849
and how can this method fail and these

00:39:42,640 --> 00:39:47,740
fell into these nine categories which we

00:39:45,849 --> 00:39:50,079
labeled as these low-level usage

00:39:47,740 --> 00:39:52,569
questions about input values and return

00:39:50,079 --> 00:39:54,670
values about api's as these high-level

00:39:52,569 --> 00:39:57,630
usage questions about what are the

00:39:54,670 --> 00:40:00,609
recommended practices for using this API

00:39:57,630 --> 00:40:02,289
how can I what's the right API member

00:40:00,609 --> 00:40:05,380
and function to use if I'm trying to

00:40:02,289 --> 00:40:07,720
accomplish this task and also these

00:40:05,380 --> 00:40:09,910
questions about implementation so what

00:40:07,720 --> 00:40:12,009
are the hidden contracts about how I

00:40:09,910 --> 00:40:14,079
initialize this valuable before I pass

00:40:12,009 --> 00:40:16,420
in and who takes care of the memory with

00:40:14,079 --> 00:40:18,249
this variable and these questions about

00:40:16,420 --> 00:40:21,339
implementation details and side-effects

00:40:18,249 --> 00:40:22,480
like is this doing any logging that I

00:40:21,339 --> 00:40:25,329
should know about what are some of the

00:40:22,480 --> 00:40:26,739
log messages that this M is the other

00:40:25,329 --> 00:40:29,650
cool thing is that we got to ask about

00:40:26,739 --> 00:40:32,739
where where the programmers preferred to

00:40:29,650 --> 00:40:34,119
find this information and most of them

00:40:32,739 --> 00:40:36,369
unsurprisingly wanted to find this

00:40:34,119 --> 00:40:38,499
information in the header files this

00:40:36,369 --> 00:40:39,759
isn't so surprising because they started

00:40:38,499 --> 00:40:41,440
out in the header files to begin with

00:40:39,759 --> 00:40:42,900
this would have probably saved most of

00:40:41,440 --> 00:40:44,890
them time if it I've been right there

00:40:42,900 --> 00:40:46,480
but what's interesting to me is that

00:40:44,890 --> 00:40:48,430
even for some of these implementation

00:40:46,480 --> 00:40:50,140
questions that light blue bar that you

00:40:48,430 --> 00:40:52,779
can see there these were questions that

00:40:50,140 --> 00:40:54,549
participants that there are respondents

00:40:52,779 --> 00:40:56,499
also wanted to have answered in the

00:40:54,549 --> 00:40:59,170
header documentation something that is

00:40:56,499 --> 00:41:01,450
seen as inappropriate in like javadoc

00:40:59,170 --> 00:41:02,859
documentation specs the fact that you

00:41:01,450 --> 00:41:03,960
would talk about any of that internal

00:41:02,859 --> 00:41:08,010
behavior that's out

00:41:03,960 --> 00:41:10,140
side of the contract and outside of you

00:41:08,010 --> 00:41:12,630
know what uh what a method takes in and

00:41:10,140 --> 00:41:14,550
what it produces and this really starts

00:41:12,630 --> 00:41:16,950
to blur the line between what belongs

00:41:14,550 --> 00:41:18,300
where and if people think that these

00:41:16,950 --> 00:41:20,369
answers really belong in the header

00:41:18,300 --> 00:41:22,230
files do they belong there even if our

00:41:20,369 --> 00:41:24,180
conventions say that we should mostly

00:41:22,230 --> 00:41:28,589
focus on low-level usage stuff in this

00:41:24,180 --> 00:41:31,080
header documentation we also use this as

00:41:28,589 --> 00:41:32,369
an opportunity to connect with some of

00:41:31,080 --> 00:41:34,050
the maintainer x' for these projects

00:41:32,369 --> 00:41:36,000
that had questions that we're going

00:41:34,050 --> 00:41:38,099
unanswered in order to get more of an

00:41:36,000 --> 00:41:40,320
idea about why these questions for

00:41:38,099 --> 00:41:43,260
missing answers we found hope what you

00:41:40,320 --> 00:41:44,940
might expect one of the themes was that

00:41:43,260 --> 00:41:47,660
sometimes it's not the right time to

00:41:44,940 --> 00:41:50,460
document so a team might be working on

00:41:47,660 --> 00:41:52,050
debugging the code or implementing new

00:41:50,460 --> 00:41:54,270
features and didn't really see it as the

00:41:52,050 --> 00:41:55,770
right stage to document right now other

00:41:54,270 --> 00:41:57,960
teams might have moved on to entirely

00:41:55,770 --> 00:42:00,420
other projects and really just wanted

00:41:57,960 --> 00:42:01,650
this project to die even though people

00:42:00,420 --> 00:42:04,380
were still searching for it in the

00:42:01,650 --> 00:42:06,420
codebase and finding it this quote from

00:42:04,380 --> 00:42:08,190
the maintainer that I that I shared

00:42:06,420 --> 00:42:10,170
earlier and it's unlikely that these

00:42:08,190 --> 00:42:13,010
files will ever get changed again they

00:42:10,170 --> 00:42:15,570
would have forgotten this file existed

00:42:13,010 --> 00:42:17,970
there's also this issue of this tension

00:42:15,570 --> 00:42:20,310
between keeping explanations minimal and

00:42:17,970 --> 00:42:21,630
concise and appropriately detailed and

00:42:20,310 --> 00:42:23,220
the words of one of the maintainer x'

00:42:21,630 --> 00:42:25,890
how often do you want to go into the

00:42:23,220 --> 00:42:27,480
details which can easily be too much if

00:42:25,890 --> 00:42:28,950
you answer every possible question about

00:42:27,480 --> 00:42:30,359
an API you're going to have these walls

00:42:28,950 --> 00:42:32,700
of texts that are going to get in the

00:42:30,359 --> 00:42:36,330
way of people navigating code and and

00:42:32,700 --> 00:42:37,770
reading any of the documentation to me

00:42:36,330 --> 00:42:40,619
this really underscores a few of the

00:42:37,770 --> 00:42:42,750
issues that these Bionic documentation

00:42:40,619 --> 00:42:44,010
tools are trying to address in the case

00:42:42,750 --> 00:42:46,770
of it not being the right time to

00:42:44,010 --> 00:42:48,180
document trying to reduce the amount of

00:42:46,770 --> 00:42:50,369
time that it takes for a programmer to

00:42:48,180 --> 00:42:52,380
invest so we can get the most insightful

00:42:50,369 --> 00:42:53,970
parts of them out while using the right

00:42:52,380 --> 00:42:55,710
machinery in the back end to guarantee

00:42:53,970 --> 00:42:59,310
this correctness and amplify the reach

00:42:55,710 --> 00:43:01,109
of examples and explanations but on this

00:42:59,310 --> 00:43:05,070
issue of keeping explanations minimal in

00:43:01,109 --> 00:43:07,050
this tension between conciseness and

00:43:05,070 --> 00:43:08,220
detail and documentation well it's also

00:43:07,050 --> 00:43:10,950
something that we're trying to address

00:43:08,220 --> 00:43:12,630
with Teutons by producing these context

00:43:10,950 --> 00:43:14,010
relevant explanations that can be viewed

00:43:12,630 --> 00:43:15,900
only when someone needs additional

00:43:14,010 --> 00:43:16,650
detail about this and then has these

00:43:15,900 --> 00:43:18,390
degree

00:43:16,650 --> 00:43:19,829
grading levels of detail from these

00:43:18,390 --> 00:43:21,510
high-level introductions of the language

00:43:19,829 --> 00:43:23,099
these high-level descriptions of the

00:43:21,510 --> 00:43:24,869
behavior all the way down to the

00:43:23,099 --> 00:43:29,760
fine-grained syntax of each individual

00:43:24,869 --> 00:43:32,250
token as a Bionic documentation tool

00:43:29,760 --> 00:43:34,140
this telemetry experiment was pretty

00:43:32,250 --> 00:43:36,119
unique because this code analysis was

00:43:34,140 --> 00:43:38,190
very simple in comparison to the other

00:43:36,119 --> 00:43:39,660
projects we were just looking at people

00:43:38,190 --> 00:43:42,539
transitioning from header files to

00:43:39,660 --> 00:43:43,619
implementation files but it allowed us

00:43:42,539 --> 00:43:45,420
to do a couple of things that we

00:43:43,619 --> 00:43:46,589
couldn't do with the other projects use

00:43:45,420 --> 00:43:49,619
this tool as a way of helping

00:43:46,589 --> 00:43:51,150
programmers refine their goals and and

00:43:49,619 --> 00:43:53,700
their sense of empathy and their

00:43:51,150 --> 00:43:55,020
awareness of audience as they were

00:43:53,700 --> 00:43:57,599
trying to put together their

00:43:55,020 --> 00:44:00,299
documentation and to be able to amplify

00:43:57,599 --> 00:44:01,650
their reach by getting closer to people

00:44:00,299 --> 00:44:04,020
at the times they were asking these

00:44:01,650 --> 00:44:06,930
questions rather than having to rely on

00:44:04,020 --> 00:44:08,670
common knowledge or asking friends or

00:44:06,930 --> 00:44:10,770
relying on bug reports in order to find

00:44:08,670 --> 00:44:17,700
out about these documentation usability

00:44:10,770 --> 00:44:19,039
issues altogether this is our third case

00:44:17,700 --> 00:44:22,049
and talking about these Bionic

00:44:19,039 --> 00:44:23,910
documentation tools and another way that

00:44:22,049 --> 00:44:25,200
we can think about tools that leverage

00:44:23,910 --> 00:44:27,930
code analysis in order to help

00:44:25,200 --> 00:44:29,880
programmers capture shape amplify and

00:44:27,930 --> 00:44:32,789
share programmers insights with other

00:44:29,880 --> 00:44:35,460
people and so while the highest level

00:44:32,789 --> 00:44:38,190
takeaway of this talk is that code

00:44:35,460 --> 00:44:40,289
analysis used at the rate times can help

00:44:38,190 --> 00:44:42,510
capture and amplify programmer insights

00:44:40,289 --> 00:44:44,520
in new ways to make them more effective

00:44:42,510 --> 00:44:48,660
at documenting and remove some of these

00:44:44,520 --> 00:44:50,369
barriers and a fine-grained level from

00:44:48,660 --> 00:44:52,410
each of these projects we also see

00:44:50,369 --> 00:44:54,930
examples of tools that provide different

00:44:52,410 --> 00:44:56,910
models of Bionic documentation so ID

00:44:54,930 --> 00:44:59,220
have a tool that works hand in hand real

00:44:56,910 --> 00:45:00,930
time with a programmer in an editor that

00:44:59,220 --> 00:45:02,430
helps them simplify their code into

00:45:00,930 --> 00:45:04,650
something that will be tailored to the

00:45:02,430 --> 00:45:05,970
specific audience and share with other

00:45:04,650 --> 00:45:09,420
people a pattern that they might not

00:45:05,970 --> 00:45:11,220
have otherwise share the Troodons

00:45:09,420 --> 00:45:12,869
project which suggests this other model

00:45:11,220 --> 00:45:14,789
of Bionic documentation where all of

00:45:12,869 --> 00:45:16,799
this effort is front-loaded in this

00:45:14,789 --> 00:45:19,260
first encoding the knowledge step of

00:45:16,799 --> 00:45:21,299
figuring out how you convert found code

00:45:19,260 --> 00:45:22,920
into these explanations and then allow

00:45:21,299 --> 00:45:26,010
an automated assistant to do all of the

00:45:22,920 --> 00:45:27,630
work afterwards in tailoring it to the

00:45:26,010 --> 00:45:28,130
individual code examples that are found

00:45:27,630 --> 00:45:29,780
to make

00:45:28,130 --> 00:45:32,660
to attach it to all of the places where

00:45:29,780 --> 00:45:34,820
it's relevant and then this third

00:45:32,660 --> 00:45:36,890
example of these lightweight techniques

00:45:34,820 --> 00:45:39,170
that we can plug in at the right times

00:45:36,890 --> 00:45:42,140
the right moments of code search and

00:45:39,170 --> 00:45:43,670
navigation in order to help elicit these

00:45:42,140 --> 00:45:45,710
questions that programmers have about

00:45:43,670 --> 00:45:47,210
their api's and tools that are otherwise

00:45:45,710 --> 00:45:49,040
ephemeral and we wouldn't have been able

00:45:47,210 --> 00:45:51,920
to connect to without some form of

00:45:49,040 --> 00:45:53,930
automation altogether this shows the

00:45:51,920 --> 00:45:55,610
rich space of Bionic documentation tools

00:45:53,930 --> 00:45:57,920
the types of ways that you can integrate

00:45:55,610 --> 00:45:59,870
together a code analysis and human

00:45:57,920 --> 00:46:02,420
insight in order to try to do these

00:45:59,870 --> 00:46:05,720
tasks of capturing shaping amplifying

00:46:02,420 --> 00:46:21,800
and sharing program or insight and with

00:46:05,720 --> 00:46:24,590
that I'd like to welcome questions so

00:46:21,800 --> 00:46:26,060
for for to Turin's did do you find that

00:46:24,590 --> 00:46:28,010
it highlights things that are that are

00:46:26,060 --> 00:46:30,620
not actually code or like hashtags as

00:46:28,010 --> 00:46:33,440
CSS selectors and things like that yes

00:46:30,620 --> 00:46:34,790
so one part of this that I didn't

00:46:33,440 --> 00:46:36,290
mention in this talk with some of our

00:46:34,790 --> 00:46:38,570
work that went into trying to build out

00:46:36,290 --> 00:46:42,020
those detectors there's a little bit of

00:46:38,570 --> 00:46:43,520
kind of handcrafted wisdom and trial and

00:46:42,020 --> 00:46:45,290
error that goes into trying to make sure

00:46:43,520 --> 00:46:47,360
that it detects the right things with

00:46:45,290 --> 00:46:48,800
something like regular expressions it

00:46:47,360 --> 00:46:50,600
can be kind of tricky because regular

00:46:48,800 --> 00:46:52,280
expressions appear in all kinds of

00:46:50,600 --> 00:46:54,470
different languages so what you ideally

00:46:52,280 --> 00:46:55,940
want for high recognition is to find

00:46:54,470 --> 00:46:58,490
this in like Python to find it in

00:46:55,940 --> 00:47:00,740
JavaScript find it in like TCL shell and

00:46:58,490 --> 00:47:05,150
like these rear config files for servers

00:47:00,740 --> 00:47:06,830
and that kind of thing so you know where

00:47:05,150 --> 00:47:08,690
is something like W get is something

00:47:06,830 --> 00:47:10,490
that like false positive rate is it's

00:47:08,690 --> 00:47:12,230
relatively low for because you look for

00:47:10,490 --> 00:47:13,610
our code block that starts with W get

00:47:12,230 --> 00:47:15,770
and then everything else is just that

00:47:13,610 --> 00:47:19,580
code example so the answer is that

00:47:15,770 --> 00:47:22,040
violence varies and there's a little bit

00:47:19,580 --> 00:47:23,900
of handcrafted human wisdom that also

00:47:22,040 --> 00:47:25,490
goes into the process of trying to make

00:47:23,900 --> 00:47:28,880
sure that it's finding the right pieces

00:47:25,490 --> 00:47:31,040
of code and then second question is have

00:47:28,880 --> 00:47:32,600
you looked into integrating any of these

00:47:31,040 --> 00:47:34,550
sorts of tools into into browser

00:47:32,600 --> 00:47:36,230
developer tools is like looking at the

00:47:34,550 --> 00:47:38,600
JavaScript that's running on a

00:47:36,230 --> 00:47:40,330
particular page and then getting an

00:47:38,600 --> 00:47:42,400
explanation of what's going on would be

00:47:40,330 --> 00:47:43,780
really handy yeah that would be so cool

00:47:42,400 --> 00:47:45,850
so you know one of the ways that

00:47:43,780 --> 00:47:48,310
programmers often learn about things is

00:47:45,850 --> 00:47:50,620
by looking at other people's code and so

00:47:48,310 --> 00:47:51,910
one of the ways places where I can see

00:47:50,620 --> 00:47:54,280
this as being really useful it's like

00:47:51,910 --> 00:47:55,750
inside of like eclipse developer tools

00:47:54,280 --> 00:47:57,760
or like Mozilla is debugging and

00:47:55,750 --> 00:47:59,620
development tools I think it's a totally

00:47:57,760 --> 00:48:01,980
appropriate place to deploy something

00:47:59,620 --> 00:48:01,980
like this

00:48:06,000 --> 00:48:08,950
hey Andrea I love that thank you very

00:48:08,080 --> 00:48:10,360
much

00:48:08,950 --> 00:48:12,820
one of the things I thought was really

00:48:10,360 --> 00:48:15,190
interesting as a sort of meta example in

00:48:12,820 --> 00:48:16,570
all three of your cases was this way in

00:48:15,190 --> 00:48:19,110
which you pulled out this notion of

00:48:16,570 --> 00:48:24,220
empathy as being a value of

00:48:19,110 --> 00:48:27,250
documentation right and that idea that

00:48:24,220 --> 00:48:28,780
that empathy is part of coding and

00:48:27,250 --> 00:48:31,060
writing documentation something that on

00:48:28,780 --> 00:48:32,950
one hand feels very alien to the set of

00:48:31,060 --> 00:48:34,660
values that we assume a part of this and

00:48:32,950 --> 00:48:37,690
on the other hand seems to at least with

00:48:34,660 --> 00:48:39,610
me seems to resonate a lot having spent

00:48:37,690 --> 00:48:43,330
my time reading man pages that seem to

00:48:39,610 --> 00:48:45,850
be vituperative at best I saw a proposal

00:48:43,330 --> 00:48:48,400
recently which I really liked which was

00:48:45,850 --> 00:48:50,050
do you know what growth mindset is yes

00:48:48,400 --> 00:48:52,990
right this is like a big thing in all

00:48:50,050 --> 00:48:54,760
you know classroom it's basically right

00:48:52,990 --> 00:48:56,290
the idea is that you don't it's like

00:48:54,760 --> 00:48:58,030
it's not that you don't understand

00:48:56,290 --> 00:49:01,810
regular expressions you don't understand

00:48:58,030 --> 00:49:03,790
regular expressions yet right that being

00:49:01,810 --> 00:49:06,490
said I've spent 20 years still not yet

00:49:03,790 --> 00:49:08,530
understand rate expressions but yeah I

00:49:06,490 --> 00:49:10,960
wanted to pull that out that notion of

00:49:08,530 --> 00:49:13,270
empathy as a value that seems to go

00:49:10,960 --> 00:49:15,400
across these other other ones that you

00:49:13,270 --> 00:49:18,940
think may be values that we want to look

00:49:15,400 --> 00:49:22,330
at across the board in terms of helping

00:49:18,940 --> 00:49:24,670
programmers do what they do hmm I'm not

00:49:22,330 --> 00:49:27,670
sure so you mean like other other

00:49:24,670 --> 00:49:29,140
inherently inherently human things sure

00:49:27,670 --> 00:49:33,160
that we can bring to the documentation

00:49:29,140 --> 00:49:35,470
process well or are the values that seem

00:49:33,160 --> 00:49:37,600
to be surfaced that may I mean I don't

00:49:35,470 --> 00:49:40,150
want to pre a priori assume that these

00:49:37,600 --> 00:49:42,820
are you know a set of should we say soft

00:49:40,150 --> 00:49:44,230
human values right no it could be that

00:49:42,820 --> 00:49:48,670
it turns out leaving lots of white space

00:49:44,230 --> 00:49:49,600
is really valuable right yeah um that's

00:49:48,670 --> 00:49:52,320
a good question

00:49:49,600 --> 00:49:54,900
I think so one of the things that I'd

00:49:52,320 --> 00:49:55,980
spend very much time on in this talk

00:49:54,900 --> 00:49:58,140
Minh has been a part of some of the

00:49:55,980 --> 00:50:00,690
other tools I've worked on is this idea

00:49:58,140 --> 00:50:03,960
of kind of the filtering that comes with

00:50:00,690 --> 00:50:05,490
domain knowledge about identifying the

00:50:03,960 --> 00:50:07,620
things that are kind of important to a

00:50:05,490 --> 00:50:11,310
craft identifying the things that go

00:50:07,620 --> 00:50:13,380
beyond language design and syntactic

00:50:11,310 --> 00:50:15,960
primitives to the idea of like how you

00:50:13,380 --> 00:50:17,430
might want to use something one of the

00:50:15,960 --> 00:50:21,120
other projects that I've worked on in my

00:50:17,430 --> 00:50:23,340
PhD is about in that in the computing

00:50:21,120 --> 00:50:25,230
education domain where we use program

00:50:23,340 --> 00:50:27,390
synthesis to be able to identify certain

00:50:25,230 --> 00:50:29,880
problems in student code and be able to

00:50:27,390 --> 00:50:31,350
match that just teacher feedback that

00:50:29,880 --> 00:50:33,510
can say more than just like you have an

00:50:31,350 --> 00:50:35,640
error on line one to sing like you might

00:50:33,510 --> 00:50:38,400
be missing a base case or like go back

00:50:35,640 --> 00:50:40,800
to your lecture notes from from Chapter

00:50:38,400 --> 00:50:45,780
five in those cases that kind of higher

00:50:40,800 --> 00:50:48,360
level domain understanding of I guess

00:50:45,780 --> 00:50:50,340
why things are relevant to someone and

00:50:48,360 --> 00:50:52,950
kind of what principles they need to

00:50:50,340 --> 00:50:54,660
draw in from their experience that's

00:50:52,950 --> 00:50:55,980
another thing that's that's a part of

00:50:54,660 --> 00:50:57,720
this this space that we've been

00:50:55,980 --> 00:51:01,020
exploring and that I want to explore

00:50:57,720 --> 00:51:02,550
more it's an interesting question I

00:51:01,020 --> 00:51:04,620
think there there are other things out

00:51:02,550 --> 00:51:05,610
there besides goals and empathy and I'd

00:51:04,620 --> 00:51:07,020
love to hear from you if there's

00:51:05,610 --> 00:51:08,820
anything else that that you think is

00:51:07,020 --> 00:51:10,890
it's fundamental it's just human

00:51:08,820 --> 00:51:14,280
communication that we can bring into

00:51:10,890 --> 00:51:18,450
these schools - hmm there are other

00:51:14,280 --> 00:51:21,390
questions online or in any of the

00:51:18,450 --> 00:51:27,480
Commons if not I've got like two more

00:51:21,390 --> 00:51:30,090
but a Norman aa pelez so I want to

00:51:27,480 --> 00:51:31,770
follow up on I have a note my first note

00:51:30,090 --> 00:51:33,780
from your talk and then you just brought

00:51:31,770 --> 00:51:35,460
it back up um one of the things that's

00:51:33,780 --> 00:51:36,660
very exciting about being Mozilla is we

00:51:35,460 --> 00:51:39,330
actually have people who write

00:51:36,660 --> 00:51:43,410
programming languages here and you and I

00:51:39,330 --> 00:51:45,360
were talking earlier about how so often

00:51:43,410 --> 00:51:46,500
programming languages are not used by

00:51:45,360 --> 00:51:48,330
people and yet we didn't have a

00:51:46,500 --> 00:51:49,770
reasonably good track record of writing

00:51:48,330 --> 00:51:52,260
programming languages that are used by

00:51:49,770 --> 00:51:54,390
people which is wonderful what are the

00:51:52,260 --> 00:51:56,450
implications of design for programming

00:51:54,390 --> 00:51:59,030
languages to think about these issues

00:51:56,450 --> 00:52:02,880
particularly I'm thinking about of

00:51:59,030 --> 00:52:05,160
exemplars shareability are there best

00:52:02,880 --> 00:52:06,859
practices that you've seen I mean you

00:52:05,160 --> 00:52:08,700
you're examples here were from a

00:52:06,859 --> 00:52:11,460
relatively small set of programming

00:52:08,700 --> 00:52:13,319
languages are there examples that you

00:52:11,460 --> 00:52:15,299
have other things for example that work

00:52:13,319 --> 00:52:16,559
better in Java than C because of some

00:52:15,299 --> 00:52:19,079
inherent property of the language and

00:52:16,559 --> 00:52:21,569
are things that we could learn from when

00:52:19,079 --> 00:52:23,099
building rust or wiser more whatever you

00:52:21,569 --> 00:52:24,630
know whatever else language we're gonna

00:52:23,099 --> 00:52:26,190
have and then I'm gonna be about

00:52:24,630 --> 00:52:29,460
it and it's gonna be a massive success

00:52:26,190 --> 00:52:31,049
right absolutely yeah so there were

00:52:29,460 --> 00:52:32,670
definitely languages for which it was

00:52:31,049 --> 00:52:35,490
much easier to build these tools and

00:52:32,670 --> 00:52:37,819
others so in the in the case of the CSS

00:52:35,490 --> 00:52:40,140
selectors that was a case where we could

00:52:37,819 --> 00:52:41,910
traverse a parse tree in order to build

00:52:40,140 --> 00:52:43,140
up this natural language explanation

00:52:41,910 --> 00:52:44,910
that's not something that we were

00:52:43,140 --> 00:52:46,950
capable of doing for W get or regular

00:52:44,910 --> 00:52:49,170
expressions just because of the way that

00:52:46,950 --> 00:52:52,109
you would explain something like the way

00:52:49,170 --> 00:52:54,390
that that that parsed program would

00:52:52,109 --> 00:52:57,839
operate so I think for the

00:52:54,390 --> 00:52:59,220
domain-specific language is case there

00:52:57,839 --> 00:53:01,109
you know there are certainly things that

00:52:59,220 --> 00:53:03,569
you can do in terms of the structure of

00:53:01,109 --> 00:53:05,130
the program as it gets parsed that can

00:53:03,569 --> 00:53:07,500
make it a lot easier to generate these

00:53:05,130 --> 00:53:09,539
explanations and enable new types of

00:53:07,500 --> 00:53:11,819
explanations anything that you can

00:53:09,539 --> 00:53:13,680
derive statically from code in the case

00:53:11,819 --> 00:53:15,480
of you know W get by just looking at the

00:53:13,680 --> 00:53:17,549
options instead of having to run it and

00:53:15,480 --> 00:53:18,990
understand what it does if you can get

00:53:17,549 --> 00:53:20,369
meaning statically from code that'll

00:53:18,990 --> 00:53:23,759
make it easier to generate these types

00:53:20,369 --> 00:53:27,359
of explanations and the other thing is

00:53:23,759 --> 00:53:29,670
that for a tool like code scoop that's

00:53:27,359 --> 00:53:31,079
it's easier to build something that can

00:53:29,670 --> 00:53:33,599
make these correctness guarantees as

00:53:31,079 --> 00:53:36,150
people are pulling out the examples with

00:53:33,599 --> 00:53:38,700
a statically typed language that gets

00:53:36,150 --> 00:53:39,779
compiled than with a dynamically typed

00:53:38,700 --> 00:53:42,079
language that you don't know if there

00:53:39,779 --> 00:53:44,700
are bugs in it and so in some odd places

00:53:42,079 --> 00:53:46,170
it enables you to reason a lot more

00:53:44,700 --> 00:53:47,490
about what the code is actually doing

00:53:46,170 --> 00:53:51,390
make sure you're not leaving anything

00:53:47,490 --> 00:53:53,579
out so I think if you want to make a

00:53:51,390 --> 00:53:56,279
scoopable language static typing is

00:53:53,579 --> 00:53:58,319
pretty helpful and if you want to make

00:53:56,279 --> 00:54:01,289
an easily explainable language with lots

00:53:58,319 --> 00:54:03,029
of opportunities to explain it having

00:54:01,289 --> 00:54:05,279
these parse structures that correspond

00:54:03,029 --> 00:54:06,839
to ways that you might explain it and

00:54:05,279 --> 00:54:08,039
having a lot of facts that you can

00:54:06,839 --> 00:54:10,079
derive from the static representation

00:54:08,039 --> 00:54:12,390
helps out an awful lot

00:54:10,079 --> 00:54:13,769
i I think it would be totally awesome if

00:54:12,390 --> 00:54:15,779
people kept this in mind as they were

00:54:13,769 --> 00:54:17,849
generating programming languages in

00:54:15,779 --> 00:54:18,140
terms of what might future documentation

00:54:17,849 --> 00:54:20,119
to

00:54:18,140 --> 00:54:22,069
be able to do with what it learns from

00:54:20,119 --> 00:54:23,539
the language well I'd like those as

00:54:22,069 --> 00:54:25,760
examples as they both seem to be

00:54:23,539 --> 00:54:27,890
correlated with human rement readability

00:54:25,760 --> 00:54:29,480
and human understandability and rather

00:54:27,890 --> 00:54:31,369
than that them being sort of specific

00:54:29,480 --> 00:54:32,630
tools specific things these are these

00:54:31,369 --> 00:54:35,180
are characteristics that I would suggest

00:54:32,630 --> 00:54:37,670
would tend towards more readable and

00:54:35,180 --> 00:54:39,470
thus less less less buggy languages

00:54:37,670 --> 00:54:41,109
which seems like success all around yeah

00:54:39,470 --> 00:54:43,549
absolutely it might be able to lend

00:54:41,109 --> 00:54:45,260
readability to the language itself as

00:54:43,549 --> 00:54:47,779
well as you know the potential to use

00:54:45,260 --> 00:54:50,769
some of these tools cool any other

00:54:47,779 --> 00:54:53,779
questions we have a few more minutes

00:54:50,769 --> 00:54:59,359
anything Portland San Francisco Toronto

00:54:53,779 --> 00:55:01,819
Vancouver Alberta all right I'd like you

00:54:59,359 --> 00:55:03,010
to all join me in thanking and remote

00:55:01,819 --> 00:55:10,269
for coming

00:55:03,010 --> 00:55:10,269

YouTube URL: https://www.youtube.com/watch?v=uumMUia80d0


