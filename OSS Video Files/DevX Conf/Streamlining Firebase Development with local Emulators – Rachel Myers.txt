Title: Streamlining Firebase Development with local Emulators – Rachel Myers
Publication date: 2021-04-29
Playlist: DevX Conf
Description: 
	People love Firebase for making every read or write just an API call away. What they didn’t love was that, for years, the only development environment where you could reliably test changes was a duplicate Firebase project. It was expensive, prone to mishaps, and required an internet connection at all times. This is the story of building local emulators that let a developer set up a new Firebase dev environment in about a minute, and the mistakes we made along the way.

About DevX Conf:
DevX Conf is a two-day virtual conference. It's a space where creators collaborate, listen, discuss and declutter our workflows, toolchains, and minds. To improve developer experience. Organized by Gitpod.
https://devxconf.org/
Captions: 
	00:00:14,639 --> 00:00:17,760
hi

00:00:15,280 --> 00:00:19,920
i'm rachel i'm an engineer on firebase

00:00:17,760 --> 00:00:22,080
and i focus on building tools that help

00:00:19,920 --> 00:00:25,199
developers build secure applications

00:00:22,080 --> 00:00:27,279
that protect end users privacy

00:00:25,199 --> 00:00:29,920
if you haven't used firebase before

00:00:27,279 --> 00:00:31,599
we're a backend as a service platform

00:00:29,920 --> 00:00:33,520
the products that we're best known for

00:00:31,599 --> 00:00:34,320
and the products that i work with most

00:00:33,520 --> 00:00:36,000
closely

00:00:34,320 --> 00:00:38,559
are the primary building blocks for

00:00:36,000 --> 00:00:40,800
creating applications

00:00:38,559 --> 00:00:42,800
the real-time database is a nosql

00:00:40,800 --> 00:00:44,000
database that eliminates the need for

00:00:42,800 --> 00:00:47,200
polling by pushing

00:00:44,000 --> 00:00:49,280
updates to the clients firestore is a

00:00:47,200 --> 00:00:51,280
database of collections and documents

00:00:49,280 --> 00:00:53,920
it's also real time and it's built to

00:00:51,280 --> 00:00:55,920
scale up with you

00:00:53,920 --> 00:00:58,079
firebase storage hosts your images and

00:00:55,920 --> 00:01:00,239
files just like you'd expect

00:00:58,079 --> 00:01:02,079
firebase authentication handles user

00:01:00,239 --> 00:01:03,840
management

00:01:02,079 --> 00:01:05,920
and firebase hosting hosts flat web

00:01:03,840 --> 00:01:07,840
pages it can be combined with the other

00:01:05,920 --> 00:01:09,200
products to become a full-fledged web

00:01:07,840 --> 00:01:11,520
app

00:01:09,200 --> 00:01:13,680
and firebase functions is bits of

00:01:11,520 --> 00:01:16,000
compute the glue that connects firebase

00:01:13,680 --> 00:01:18,000
products together

00:01:16,000 --> 00:01:20,320
looking at all these products they may

00:01:18,000 --> 00:01:22,880
seem not that special

00:01:20,320 --> 00:01:24,400
after all all cloud providers offer

00:01:22,880 --> 00:01:26,640
databases

00:01:24,400 --> 00:01:27,840
firebase is differentiated by the

00:01:26,640 --> 00:01:30,640
developer experience

00:01:27,840 --> 00:01:32,880
by our sdks and our tooling we track

00:01:30,640 --> 00:01:34,560
developer satisfaction scores the way

00:01:32,880 --> 00:01:36,159
that most companies track their net

00:01:34,560 --> 00:01:37,520
promoter scores

00:01:36,159 --> 00:01:40,320
but i don't want to say that we have it

00:01:37,520 --> 00:01:42,240
all figured out it's constant trade-off

00:01:40,320 --> 00:01:43,439
this talk is a story of what we've

00:01:42,240 --> 00:01:45,680
experimented with

00:01:43,439 --> 00:01:48,479
where we stumbled and had to learn and

00:01:45,680 --> 00:01:50,640
what we want to do more of

00:01:48,479 --> 00:01:51,600
when firebase was starting out one

00:01:50,640 --> 00:01:53,680
primary goal

00:01:51,600 --> 00:01:56,079
was that anyone could get a new app up

00:01:53,680 --> 00:01:58,320
and running in about five minutes

00:01:56,079 --> 00:02:00,159
this was a huge factor and firebase is

00:01:58,320 --> 00:02:02,320
becoming popular with app developers

00:02:00,159 --> 00:02:04,159
especially mobile developers

00:02:02,320 --> 00:02:07,439
and i understand the importance of

00:02:04,159 --> 00:02:09,759
having a great first impression

00:02:07,439 --> 00:02:11,039
i remember the first time i ran git push

00:02:09,759 --> 00:02:13,760
heroku main

00:02:11,039 --> 00:02:15,680
and a minute later my rails app was live

00:02:13,760 --> 00:02:17,280
on the internet it blew my mind that it

00:02:15,680 --> 00:02:18,959
was that easy

00:02:17,280 --> 00:02:21,040
firebase wanted to do that for a

00:02:18,959 --> 00:02:21,680
different developer the first five

00:02:21,040 --> 00:02:25,040
minutes

00:02:21,680 --> 00:02:25,440
should feel like things just work we did

00:02:25,040 --> 00:02:28,319
this

00:02:25,440 --> 00:02:29,200
mostly by being opinionated instead of

00:02:28,319 --> 00:02:30,959
getting all the

00:02:29,200 --> 00:02:33,200
dials and knobs you would get with a

00:02:30,959 --> 00:02:34,959
cloud provider firebase gives you

00:02:33,200 --> 00:02:36,959
reasonable defaults

00:02:34,959 --> 00:02:38,080
where the cloud developer says i need

00:02:36,959 --> 00:02:40,239
this size database

00:02:38,080 --> 00:02:41,920
instance that is located here and it

00:02:40,239 --> 00:02:44,400
should replicate like this

00:02:41,920 --> 00:02:46,400
the firebase developer says i need a

00:02:44,400 --> 00:02:48,400
database

00:02:46,400 --> 00:02:50,160
i should point out here that after

00:02:48,400 --> 00:02:52,319
firebase was acquired by google

00:02:50,160 --> 00:02:53,760
firebase products were rewritten to work

00:02:52,319 --> 00:02:56,239
with google backends

00:02:53,760 --> 00:02:58,239
today for most firebase products you can

00:02:56,239 --> 00:02:59,280
use firebase or an equivalent google

00:02:58,239 --> 00:03:01,440
cloud product

00:02:59,280 --> 00:03:02,800
people choose to use firebase because

00:03:01,440 --> 00:03:05,360
they would rather focus on building

00:03:02,800 --> 00:03:07,519
their app

00:03:05,360 --> 00:03:09,519
i want to start with a story of how this

00:03:07,519 --> 00:03:11,599
emphasis on the first impression

00:03:09,519 --> 00:03:14,239
caused some debt that we had to work out

00:03:11,599 --> 00:03:18,319
of and i should say at the start this is

00:03:14,239 --> 00:03:19,040
not what we do anymore first if you were

00:03:18,319 --> 00:03:21,680
setting up

00:03:19,040 --> 00:03:23,519
a new traditional database you would

00:03:21,680 --> 00:03:25,840
need to configure the database

00:03:23,519 --> 00:03:26,640
and the server that ends up being a few

00:03:25,840 --> 00:03:28,879
hours of

00:03:26,640 --> 00:03:31,040
pasting environment variables and

00:03:28,879 --> 00:03:33,280
writing yaml

00:03:31,040 --> 00:03:35,280
but in the end you have a server that

00:03:33,280 --> 00:03:36,239
acts as a natural place to restrict

00:03:35,280 --> 00:03:38,000
access

00:03:36,239 --> 00:03:39,440
only the server can talk to the storage

00:03:38,000 --> 00:03:41,840
layer

00:03:39,440 --> 00:03:45,200
firebase went a different direction

00:03:41,840 --> 00:03:47,840
clients connect directly to the back end

00:03:45,200 --> 00:03:49,599
and the only way that that is okay is

00:03:47,840 --> 00:03:50,159
that there's a security configuration

00:03:49,599 --> 00:03:52,720
file

00:03:50,159 --> 00:03:54,239
called security rules it enforces limits

00:03:52,720 --> 00:03:57,519
on who is allowed to access

00:03:54,239 --> 00:03:59,599
any specific part of the database

00:03:57,519 --> 00:04:00,640
here's what firestore security rules

00:03:59,599 --> 00:04:02,959
look like

00:04:00,640 --> 00:04:04,159
say i have an e-commerce app i can write

00:04:02,959 --> 00:04:06,720
a rule that says

00:04:04,159 --> 00:04:08,159
users can only read from or write to

00:04:06,720 --> 00:04:10,480
their own cart

00:04:08,159 --> 00:04:12,959
but users can't see or modify other

00:04:10,480 --> 00:04:15,760
people's carts

00:04:12,959 --> 00:04:16,880
this decision was choosing a side in a

00:04:15,760 --> 00:04:18,959
trade-off

00:04:16,880 --> 00:04:20,320
we've made it fast to try something out

00:04:18,959 --> 00:04:22,320
and get something working

00:04:20,320 --> 00:04:24,240
but before developers ship their app and

00:04:22,320 --> 00:04:26,320
start saving real user data they'll need

00:04:24,240 --> 00:04:28,240
to go back and configure permissions in

00:04:26,320 --> 00:04:31,360
this separate file

00:04:28,240 --> 00:04:33,199
when i joined firebase they said to me

00:04:31,360 --> 00:04:36,000
we think we have lots of insecure

00:04:33,199 --> 00:04:38,000
projects we're not really sure how many

00:04:36,000 --> 00:04:39,120
it's your job to reduce that number

00:04:38,000 --> 00:04:42,880
whatever it is

00:04:39,120 --> 00:04:45,280
good luck oh boy

00:04:42,880 --> 00:04:47,040
so i started looking into it figuring

00:04:45,280 --> 00:04:48,880
out how firebase back-ends

00:04:47,040 --> 00:04:52,639
were becoming insecure what was

00:04:48,880 --> 00:04:52,639
happening there and why was it happening

00:04:52,720 --> 00:04:57,280
in order to make sure that people's

00:04:54,880 --> 00:04:59,280
first moment with the product was not a

00:04:57,280 --> 00:05:00,639
permission denied error

00:04:59,280 --> 00:05:03,120
the first product that we had the

00:05:00,639 --> 00:05:05,120
real-time database had default security

00:05:03,120 --> 00:05:06,080
rules that allowed any user who was

00:05:05,120 --> 00:05:09,280
signed in

00:05:06,080 --> 00:05:10,000
to do anything we told developers that

00:05:09,280 --> 00:05:11,840
they needed to go

00:05:10,000 --> 00:05:14,720
back and update their security rules

00:05:11,840 --> 00:05:17,120
before they became a production app

00:05:14,720 --> 00:05:19,520
but lots of them ignored us so we

00:05:17,120 --> 00:05:21,919
learned from that

00:05:19,520 --> 00:05:24,080
when we launched firestore we knew that

00:05:21,919 --> 00:05:25,919
we wanted to try something else

00:05:24,080 --> 00:05:27,600
when someone added firestore to their

00:05:25,919 --> 00:05:29,600
project they had to choose if they

00:05:27,600 --> 00:05:31,759
wanted their security rules to start in

00:05:29,600 --> 00:05:34,320
test mode where access was open or

00:05:31,759 --> 00:05:36,720
locked mode where access was locked down

00:05:34,320 --> 00:05:37,680
this may seem like a trivial change

00:05:36,720 --> 00:05:39,600
because they could still

00:05:37,680 --> 00:05:41,039
choose to start with wide open security

00:05:39,600 --> 00:05:43,520
rules but this was an

00:05:41,039 --> 00:05:44,080
improvement for a couple of reasons it

00:05:43,520 --> 00:05:46,160
was

00:05:44,080 --> 00:05:47,280
only a moment of friction in creating

00:05:46,160 --> 00:05:49,840
your project just

00:05:47,280 --> 00:05:51,919
one dialog box you had to click through

00:05:49,840 --> 00:05:52,479
and there's not a right or wrong answer

00:05:51,919 --> 00:05:54,639
here

00:05:52,479 --> 00:05:57,600
either way you still need to tailor

00:05:54,639 --> 00:05:59,360
these security rules to your application

00:05:57,600 --> 00:06:01,039
but it's a reminder at the very

00:05:59,360 --> 00:06:02,639
beginning that you need to come back to

00:06:01,039 --> 00:06:04,560
this

00:06:02,639 --> 00:06:06,240
when i was early in my career i thought

00:06:04,560 --> 00:06:08,080
that all friction was bad

00:06:06,240 --> 00:06:09,840
the goal of building great products was

00:06:08,080 --> 00:06:11,680
to remove friction

00:06:09,840 --> 00:06:13,440
after working in the authentication and

00:06:11,680 --> 00:06:15,360
security space for years

00:06:13,440 --> 00:06:16,720
i know that friction is a tool to make

00:06:15,360 --> 00:06:19,520
developers pause

00:06:16,720 --> 00:06:20,319
and think about something this tiny bit

00:06:19,520 --> 00:06:22,720
of friction

00:06:20,319 --> 00:06:24,800
didn't solve everything of course people

00:06:22,720 --> 00:06:28,000
still were able to ship insecure apps

00:06:24,800 --> 00:06:31,440
and they did but far fewer of them did

00:06:28,000 --> 00:06:33,440
still we need to keep iterating our next

00:06:31,440 --> 00:06:36,560
attempt at reducing insecure projects

00:06:33,440 --> 00:06:38,880
was to change the default rules

00:06:36,560 --> 00:06:40,319
the new defaults let all requests

00:06:38,880 --> 00:06:42,080
through for a month

00:06:40,319 --> 00:06:43,919
after a month if they still hadn't

00:06:42,080 --> 00:06:45,840
updated the rules they'd start getting

00:06:43,919 --> 00:06:47,360
emails from us

00:06:45,840 --> 00:06:49,680
and they'd start getting permission

00:06:47,360 --> 00:06:51,360
denied errors in their app

00:06:49,680 --> 00:06:52,960
some percentage of these developers

00:06:51,360 --> 00:06:53,759
would just update this hard-coded

00:06:52,960 --> 00:06:56,560
timestamp

00:06:53,759 --> 00:06:57,520
to be further in the future and in that

00:06:56,560 --> 00:07:00,560
case we sent them

00:06:57,520 --> 00:07:02,880
even more annoying emails but most

00:07:00,560 --> 00:07:05,680
developers would stop and actually write

00:07:02,880 --> 00:07:08,560
configurations here

00:07:05,680 --> 00:07:10,880
this is a deferred friction point it

00:07:08,560 --> 00:07:13,520
keeps the immediate flow of creating an

00:07:10,880 --> 00:07:15,039
app smooth but after you've had time to

00:07:13,520 --> 00:07:17,440
build your app we put up a wall the

00:07:15,039 --> 00:07:19,360
developers have to respond to

00:07:17,440 --> 00:07:20,800
eventually with new defaults with

00:07:19,360 --> 00:07:22,560
annoying emails

00:07:20,800 --> 00:07:25,280
we were able to reduce the number of

00:07:22,560 --> 00:07:27,280
insecure projects

00:07:25,280 --> 00:07:28,400
i still think we have more iterating to

00:07:27,280 --> 00:07:30,639
do though

00:07:28,400 --> 00:07:32,000
if you are writing your security rules

00:07:30,639 --> 00:07:33,120
at the same time that you're building

00:07:32,000 --> 00:07:35,360
your application

00:07:33,120 --> 00:07:37,440
your security rules act like a schema

00:07:35,360 --> 00:07:38,800
you end up creating a cleaner database

00:07:37,440 --> 00:07:40,720
if you're thinking about the access

00:07:38,800 --> 00:07:42,880
patterns from the start

00:07:40,720 --> 00:07:44,720
and it's less painful than if you try to

00:07:42,880 --> 00:07:45,680
bolt security on to an already written

00:07:44,720 --> 00:07:47,360
app

00:07:45,680 --> 00:07:49,840
so hopefully we can tighten up this

00:07:47,360 --> 00:07:50,479
timeline give them a few days to try

00:07:49,840 --> 00:07:52,800
things out

00:07:50,479 --> 00:07:54,479
and experiment with data structures and

00:07:52,800 --> 00:07:56,319
then they need to start thinking about

00:07:54,479 --> 00:07:58,960
security

00:07:56,319 --> 00:08:01,280
this space is really full of trade-offs

00:07:58,960 --> 00:08:02,240
by optimizing for the initial developer

00:08:01,280 --> 00:08:03,919
experience

00:08:02,240 --> 00:08:05,840
we limited what we could do for the

00:08:03,919 --> 00:08:07,919
developers who are building on firebase

00:08:05,840 --> 00:08:09,120
day in and day out those are our power

00:08:07,919 --> 00:08:10,960
users

00:08:09,120 --> 00:08:13,440
and i know this happens at other places

00:08:10,960 --> 00:08:14,479
too at a previous company i worked for

00:08:13,440 --> 00:08:16,479
the longest time

00:08:14,479 --> 00:08:19,440
we couldn't add some features that would

00:08:16,479 --> 00:08:21,199
have helped newcomers feel more welcome

00:08:19,440 --> 00:08:22,800
we worried that it would slow down our

00:08:21,199 --> 00:08:25,039
power users

00:08:22,800 --> 00:08:26,240
eventually that shifted that was when we

00:08:25,039 --> 00:08:29,120
decided that we needed

00:08:26,240 --> 00:08:29,120
more customers

00:08:29,680 --> 00:08:33,120
luckily we had a group of power users

00:08:31,680 --> 00:08:34,640
inside of firebase

00:08:33,120 --> 00:08:37,039
who could make the changes that they

00:08:34,640 --> 00:08:38,479
needed while most people have a few

00:08:37,039 --> 00:08:40,560
firebase projects

00:08:38,479 --> 00:08:42,000
the developer relations engineers each

00:08:40,560 --> 00:08:43,919
have a few hundred

00:08:42,000 --> 00:08:45,680
we make tons of apps and we feel all the

00:08:43,919 --> 00:08:47,519
pain points

00:08:45,680 --> 00:08:48,959
the devel engineers start amusing to

00:08:47,519 --> 00:08:50,640
themselves

00:08:48,959 --> 00:08:52,560
what would it be like if there was a

00:08:50,640 --> 00:08:53,360
version of firebase running on my local

00:08:52,560 --> 00:08:56,320
machine

00:08:53,360 --> 00:08:57,680
that could cut the iteration time maybe

00:08:56,320 --> 00:08:59,440
drastically

00:08:57,680 --> 00:09:01,600
imagine if i'm working on a cloud

00:08:59,440 --> 00:09:03,839
function instead of having to deploy it

00:09:01,600 --> 00:09:05,440
to firebase which takes a few minutes

00:09:03,839 --> 00:09:06,959
and then i make a few changes and i

00:09:05,440 --> 00:09:08,880
deploy it again

00:09:06,959 --> 00:09:10,720
what if i could test it as quickly as

00:09:08,880 --> 00:09:12,640
just refreshing a browser

00:09:10,720 --> 00:09:14,320
if i could try 10 things in a minute i'm

00:09:12,640 --> 00:09:18,080
going to do better work than if i can

00:09:14,320 --> 00:09:19,360
just try one what if that local version

00:09:18,080 --> 00:09:21,680
of firebase would have

00:09:19,360 --> 00:09:23,760
hot reloading and pick up changes from

00:09:21,680 --> 00:09:25,279
this app source code without needing to

00:09:23,760 --> 00:09:27,360
refresh or restart

00:09:25,279 --> 00:09:29,600
that could bring the iteration time even

00:09:27,360 --> 00:09:29,600
more

00:09:29,760 --> 00:09:32,959
it would have to be as close as possible

00:09:31,680 --> 00:09:35,360
to production though

00:09:32,959 --> 00:09:36,880
if something works on my machine but

00:09:35,360 --> 00:09:38,800
breaks when it's deployed we're not

00:09:36,880 --> 00:09:40,399
helping anybody

00:09:38,800 --> 00:09:41,760
so it should probably pull in binary

00:09:40,399 --> 00:09:42,160
straight from production code when it

00:09:41,760 --> 00:09:43,360
can

00:09:42,160 --> 00:09:46,080
and where that doesn't work we could

00:09:43,360 --> 00:09:48,800
re-implement the apis

00:09:46,080 --> 00:09:50,240
what if it had a clean simple interface

00:09:48,800 --> 00:09:52,000
you wouldn't need to start a local

00:09:50,240 --> 00:09:52,399
version of each firebase product that

00:09:52,000 --> 00:09:54,000
you

00:09:52,399 --> 00:09:55,519
want to use or pass in a lot of

00:09:54,000 --> 00:09:56,959
environment variables

00:09:55,519 --> 00:09:58,240
you shouldn't even need to tell it what

00:09:56,959 --> 00:09:59,839
products you're using it should be able

00:09:58,240 --> 00:10:02,320
to look and see

00:09:59,839 --> 00:10:04,399
actually there was an existing emulator

00:10:02,320 --> 00:10:07,040
that google cloud made for functions

00:10:04,399 --> 00:10:08,480
but it only ran one function if you

00:10:07,040 --> 00:10:10,240
needed to test more than one function

00:10:08,480 --> 00:10:12,240
then you need to start that functions

00:10:10,240 --> 00:10:14,399
emulator several times

00:10:12,240 --> 00:10:15,680
this simulator that we would build this

00:10:14,399 --> 00:10:17,040
would be different

00:10:15,680 --> 00:10:19,360
there could be one command that would

00:10:17,040 --> 00:10:22,240
start everything you need

00:10:19,360 --> 00:10:23,519
what if it had self-healing errors if

00:10:22,240 --> 00:10:25,200
something goes wrong

00:10:23,519 --> 00:10:27,600
give me a link to what i need to enable

00:10:25,200 --> 00:10:29,839
or tell me how to fix it

00:10:27,600 --> 00:10:31,760
like if it doesn't see any javascript

00:10:29,839 --> 00:10:32,560
files but it does see some typescript

00:10:31,760 --> 00:10:34,800
files

00:10:32,560 --> 00:10:35,920
instead of telling me file not found

00:10:34,800 --> 00:10:38,480
what if you told me

00:10:35,920 --> 00:10:40,720
did you forget to compile because yes i

00:10:38,480 --> 00:10:40,720
did

00:10:41,200 --> 00:10:45,040
and this is what became the firebase

00:10:43,680 --> 00:10:47,200
emulator suite

00:10:45,040 --> 00:10:49,040
a place where instead of optimizing for

00:10:47,200 --> 00:10:49,760
the first five minutes we could optimize

00:10:49,040 --> 00:10:52,560
for the day in

00:10:49,760 --> 00:10:54,399
and day out routine of development a few

00:10:52,560 --> 00:10:56,880
unexpected things started to happen

00:10:54,399 --> 00:10:59,440
once the emulator emulators got off the

00:10:56,880 --> 00:11:02,399
ground and started to gain adoption

00:10:59,440 --> 00:11:04,320
every quarter firebase had goals of

00:11:02,399 --> 00:11:05,760
about how much we should try to grow the

00:11:04,320 --> 00:11:07,519
number of firebase projects it was

00:11:05,760 --> 00:11:10,399
always some large multiple

00:11:07,519 --> 00:11:12,399
and frankly not having emulators to

00:11:10,399 --> 00:11:13,360
artificially inflate the numbers towards

00:11:12,399 --> 00:11:16,480
those goals

00:11:13,360 --> 00:11:18,959
caught us by surprise

00:11:16,480 --> 00:11:21,040
how many firebase products projects does

00:11:18,959 --> 00:11:23,360
it take to build an app

00:11:21,040 --> 00:11:24,880
n plus one where n is the number of

00:11:23,360 --> 00:11:26,399
development and test environments that

00:11:24,880 --> 00:11:27,519
you need plus your one production

00:11:26,399 --> 00:11:29,519
instance

00:11:27,519 --> 00:11:30,959
requiring developers to set up extra

00:11:29,519 --> 00:11:32,000
projects for the development test

00:11:30,959 --> 00:11:34,399
environments

00:11:32,000 --> 00:11:35,200
was great for helping us meet our goal

00:11:34,399 --> 00:11:37,040
numbers

00:11:35,200 --> 00:11:38,240
but it also made the numbers less

00:11:37,040 --> 00:11:40,959
meaningful

00:11:38,240 --> 00:11:43,040
now that each new product is one app our

00:11:40,959 --> 00:11:45,360
goal numbers are a better reflection of

00:11:43,040 --> 00:11:47,279
reality

00:11:45,360 --> 00:11:49,040
we've also started to build things into

00:11:47,279 --> 00:11:50,079
the emulator that will never make it to

00:11:49,040 --> 00:11:52,320
production

00:11:50,079 --> 00:11:54,639
my favorite example is functionality to

00:11:52,320 --> 00:11:56,800
test and debug your security rules

00:11:54,639 --> 00:11:58,320
we know that writing security rules is

00:11:56,800 --> 00:11:59,279
the kind of thing that scares some

00:11:58,320 --> 00:12:00,639
people

00:11:59,279 --> 00:12:02,480
if you make a mistake you could

00:12:00,639 --> 00:12:04,560
accidentally break your application

00:12:02,480 --> 00:12:06,399
by cutting off access that it needs to

00:12:04,560 --> 00:12:08,800
operate or even worse

00:12:06,399 --> 00:12:09,519
make public data sorry make personal

00:12:08,800 --> 00:12:12,000
data

00:12:09,519 --> 00:12:13,839
public to the entire world if the only

00:12:12,000 --> 00:12:17,200
place you have to test those changes is

00:12:13,839 --> 00:12:18,800
in production that's really scary but

00:12:17,200 --> 00:12:20,560
the emulator should give you all the

00:12:18,800 --> 00:12:23,040
tools that you need to be confident that

00:12:20,560 --> 00:12:25,120
you're doing the right thing

00:12:23,040 --> 00:12:26,560
for example we've created a testing

00:12:25,120 --> 00:12:28,480
library that you can use with the

00:12:26,560 --> 00:12:30,079
emulator for unit testing your security

00:12:28,480 --> 00:12:32,000
rules

00:12:30,079 --> 00:12:33,360
these kinds of tests are quick to write

00:12:32,000 --> 00:12:34,959
you step out the user with the

00:12:33,360 --> 00:12:37,200
attributes that you want to test

00:12:34,959 --> 00:12:39,040
and assert if the user should be denied

00:12:37,200 --> 00:12:40,240
or permitted when they make a specific

00:12:39,040 --> 00:12:43,120
request

00:12:40,240 --> 00:12:45,040
i love these tests it brings developing

00:12:43,120 --> 00:12:46,720
your security rules up to the standards

00:12:45,040 --> 00:12:48,240
of the rest of your development

00:12:46,720 --> 00:12:50,480
you get all the confidence that you're

00:12:48,240 --> 00:12:52,480
used to with automated tests

00:12:50,480 --> 00:12:53,760
you can add it to ci and now you know

00:12:52,480 --> 00:12:57,040
that someone won't accidentally

00:12:53,760 --> 00:12:59,200
dismantle the logic that you've written

00:12:57,040 --> 00:13:01,040
we've also added methods for debugging

00:12:59,200 --> 00:13:02,160
security rules that only work in the

00:13:01,040 --> 00:13:04,560
emulators

00:13:02,160 --> 00:13:06,880
for instance comparing time is always a

00:13:04,560 --> 00:13:08,800
little bit tricky here i have a rule

00:13:06,880 --> 00:13:11,279
that says a comment can be edited

00:13:08,800 --> 00:13:13,360
for an hour after it is written i can

00:13:11,279 --> 00:13:14,240
add a debug statement to any expression

00:13:13,360 --> 00:13:16,079
in my rules

00:13:14,240 --> 00:13:17,279
and the emulator will log that to

00:13:16,079 --> 00:13:19,839
standard out

00:13:17,279 --> 00:13:20,880
just to let me double check my logic

00:13:19,839 --> 00:13:22,800
this may seem

00:13:20,880 --> 00:13:24,079
like a feature that should also go into

00:13:22,800 --> 00:13:27,519
production

00:13:24,079 --> 00:13:28,639
honestly it won't rules are code that

00:13:27,519 --> 00:13:30,639
was written by a user

00:13:28,639 --> 00:13:32,720
and that we're evaling in a time

00:13:30,639 --> 00:13:33,600
critical path when a request comes into

00:13:32,720 --> 00:13:36,000
firebase

00:13:33,600 --> 00:13:37,519
so we can strain what can happen in

00:13:36,000 --> 00:13:40,320
rules we want to make sure that we can

00:13:37,519 --> 00:13:42,160
always evaluate this quickly we're super

00:13:40,320 --> 00:13:44,480
strict about latency in rules so we

00:13:42,160 --> 00:13:46,240
don't want to add any extra io

00:13:44,480 --> 00:13:48,720
but that doesn't apply to the local

00:13:46,240 --> 00:13:50,720
emulator so going forward we're going to

00:13:48,720 --> 00:13:51,440
make the emulator the best place to

00:13:50,720 --> 00:13:54,720
debug

00:13:51,440 --> 00:13:56,800
test and develop to wrap

00:13:54,720 --> 00:13:58,880
up we've learned a lot of things from

00:13:56,800 --> 00:14:00,399
trying to cater to the first five minute

00:13:58,880 --> 00:14:02,000
experience in firebase

00:14:00,399 --> 00:14:04,079
we've discovered that we weren't leaving

00:14:02,000 --> 00:14:06,000
our developers in a great place

00:14:04,079 --> 00:14:08,800
and we were giving them a dopamine hit

00:14:06,000 --> 00:14:10,480
rather than setting them up for success

00:14:08,800 --> 00:14:12,959
now with the emulator suite we're trying

00:14:10,480 --> 00:14:15,120
to find a balance the emulator started

00:14:12,959 --> 00:14:17,360
as a place for our power users

00:14:15,120 --> 00:14:18,800
the irony is that as we've continued to

00:14:17,360 --> 00:14:21,519
build out the emulators

00:14:18,800 --> 00:14:22,720
it's now becoming mini newcomers first

00:14:21,519 --> 00:14:25,040
moment with firebase

00:14:22,720 --> 00:14:25,920
with a different focus instead of

00:14:25,040 --> 00:14:28,160
emphasizing

00:14:25,920 --> 00:14:30,320
look your app is live the emulators

00:14:28,160 --> 00:14:32,959
emphasize learning to debug and test

00:14:30,320 --> 00:14:34,959
before anything goes live both aim to

00:14:32,959 --> 00:14:36,959
keep your developers moving fast

00:14:34,959 --> 00:14:40,320
but where production dazzles the

00:14:36,959 --> 00:14:42,240
emulators want to help you develop

00:14:40,320 --> 00:14:43,920
so thanks for having me and i want to

00:14:42,240 --> 00:14:46,160
take a moment to applaud everyone who's

00:14:43,920 --> 00:14:54,160
contributed to the firebase emulators

00:14:46,160 --> 00:14:54,160

YouTube URL: https://www.youtube.com/watch?v=0AXj96IXueg


