Title: Cloud Native Java – Josh Long
Publication date: 2021-04-26
Playlist: DevX Conf
Description: 
	“It is not necessary to change. Survival is not mandatory.” -W. Edwards Deming

Work takes time to flow through an organization and ultimately be deployed to production where it captures value. It’s critical to reduce time-to-production. Software - for many organizations and industries - is a competitive advantage. Organizations break their larger software ambitions into smaller, independently deployable, feature -centric batches of work - microservices. In order to reduce the round-trip between stations of work, organizations collapse or consolidate as much of them as possible and automate the rest; developers and operations beget “devops,” cloud-based services and platforms automate operations work and break down the need for ITIL tickets and change management boards. But velocity, for velocity’s sake, is dangerous. Microservices invite architectural complexity that few are prepared to address. In this talk, we’ll look at how high performance organizations like Ticketmaster, Alibaba, and Netflix make short work of that complexity with Spring Boot and Spring Cloud.

About DevX Conf:
DevX Conf is about developer experience - a space where creators collaborate, listen, discuss and declutter our workflows, toolchains, and minds. Organized by Gitpod
https://devxconf.org/
Captions: 
	00:00:13,840 --> 00:00:16,080
hi everybody

00:00:14,960 --> 00:00:17,600
in this video we're going to look at

00:00:16,080 --> 00:00:19,119
cloud native java we're going to look at

00:00:17,600 --> 00:00:20,880
things that you can do to lessen the

00:00:19,119 --> 00:00:22,640
impact of building distributed systems

00:00:20,880 --> 00:00:24,320
that are intended for the cloud a lot of

00:00:22,640 --> 00:00:26,480
us are moving to microservices

00:00:24,320 --> 00:00:28,000
microservices give us a lot of benefits

00:00:26,480 --> 00:00:30,400
not least of which is that they make it

00:00:28,000 --> 00:00:32,640
so that we can have smaller teams uh

00:00:30,400 --> 00:00:34,239
focused on individual deliverables that

00:00:32,640 --> 00:00:35,520
can be delivered independently of other

00:00:34,239 --> 00:00:37,040
parts of the organization

00:00:35,520 --> 00:00:38,719
this gives them a greater autonomy and

00:00:37,040 --> 00:00:41,120
gives them the ability to respond

00:00:38,719 --> 00:00:41,760
more efficiently more readily to changes

00:00:41,120 --> 00:00:44,320
in the

00:00:41,760 --> 00:00:44,879
ever growing ever changing marketplace

00:00:44,320 --> 00:00:47,280
but

00:00:44,879 --> 00:00:48,559
that said they do imply some

00:00:47,280 --> 00:00:50,079
complications because you're building

00:00:48,559 --> 00:00:51,680
interest distributed systems

00:00:50,079 --> 00:00:53,360
and you run the risk of running afoul of

00:00:51,680 --> 00:00:54,160
all the sort of fallacies of distributed

00:00:53,360 --> 00:00:55,600
computing

00:00:54,160 --> 00:00:56,800
so what we're going to look at are just

00:00:55,600 --> 00:00:58,559
a number of things that we can do to

00:00:56,800 --> 00:00:59,280
build software that's better intended

00:00:58,559 --> 00:01:01,199
for production

00:00:59,280 --> 00:01:02,480
so let's go to my second favorite place

00:01:01,199 --> 00:01:03,680
on the internet obviously my first

00:01:02,480 --> 00:01:06,240
favorite place on the internet

00:01:03,680 --> 00:01:06,880
is production but my second favorite

00:01:06,240 --> 00:01:08,240
place is

00:01:06,880 --> 00:01:09,760
start that spring that i owe if you

00:01:08,240 --> 00:01:10,640
haven't been to production you can begin

00:01:09,760 --> 00:01:13,360
your journey here

00:01:10,640 --> 00:01:14,799
at start that's spring trail when your

00:01:13,360 --> 00:01:15,600
children are restless and they cannot

00:01:14,799 --> 00:01:18,640
sleep

00:01:15,600 --> 00:01:19,920
start that spring that i owe

00:01:18,640 --> 00:01:21,840
when you wake up in the morning and you

00:01:19,920 --> 00:01:25,439
need inspiration before a cup of tea

00:01:21,840 --> 00:01:27,600
or coffee start that spring

00:01:25,439 --> 00:01:29,520
and if you suffer from indigestion after

00:01:27,600 --> 00:01:33,600
a long night of alcohol abuse

00:01:29,520 --> 00:01:34,400
and php start that spring

00:01:33,600 --> 00:01:36,079
and what we're going to do is we're

00:01:34,400 --> 00:01:37,520
going to build a new application uh that

00:01:36,079 --> 00:01:38,640
manages customer data

00:01:37,520 --> 00:01:40,240
and we're going to use the latest and

00:01:38,640 --> 00:01:41,600
greatest version of apache maven the

00:01:40,240 --> 00:01:43,200
build tool we're going to use

00:01:41,600 --> 00:01:44,799
java but any language will work just

00:01:43,200 --> 00:01:46,159
fine java groovy kotlin

00:01:44,799 --> 00:01:48,159
whatever we're going to use the latest

00:01:46,159 --> 00:01:50,320
and greatest version of spring boot

00:01:48,159 --> 00:01:51,680
and we're going to settle with the

00:01:50,320 --> 00:01:52,159
current long-term support version of

00:01:51,680 --> 00:01:54,960
java

00:01:52,159 --> 00:01:56,399
you can use the spring boot actuator

00:01:54,960 --> 00:01:58,000
like so

00:01:56,399 --> 00:01:59,759
we're going to add lumbar which is a

00:01:58,000 --> 00:02:01,439
compile-time meditation processor

00:01:59,759 --> 00:02:03,040
we're going to use the reactive support

00:02:01,439 --> 00:02:03,439
reactive programming and spring as a way

00:02:03,040 --> 00:02:06,079
to

00:02:03,439 --> 00:02:08,319
build non-blocking event loop style

00:02:06,079 --> 00:02:11,280
applications kind of like node.js

00:02:08,319 --> 00:02:13,040
we're going to use uh the h2 in memory

00:02:11,280 --> 00:02:14,480
embedded sql database now because it's

00:02:13,040 --> 00:02:17,040
in memory because it's embedded

00:02:14,480 --> 00:02:17,599
it'll give us a way to embed a database

00:02:17,040 --> 00:02:20,800
that we can

00:02:17,599 --> 00:02:21,360
we can use for ease of demonstration and

00:02:20,800 --> 00:02:22,720
i think

00:02:21,360 --> 00:02:24,480
that ought to do it that'll give us

00:02:22,720 --> 00:02:25,680
everything we need to be productive out

00:02:24,480 --> 00:02:29,599
of the box let's hit

00:02:25,680 --> 00:02:29,599
generate open this up

00:02:31,920 --> 00:02:36,080
okay so we have our our public static

00:02:35,360 --> 00:02:38,239
void main

00:02:36,080 --> 00:02:40,319
entry point application we're going to

00:02:38,239 --> 00:02:41,280
model data that talks to a sql database

00:02:40,319 --> 00:02:44,000
we're going to use

00:02:41,280 --> 00:02:44,720
a an entity an object that does that

00:02:44,000 --> 00:02:47,440
work

00:02:44,720 --> 00:02:48,879
the object has a primary key we signal

00:02:47,440 --> 00:02:50,720
as much with that annotation

00:02:48,879 --> 00:02:52,239
we want getters and setters and tostring

00:02:50,720 --> 00:02:54,160
and equals and ash codes and

00:02:52,239 --> 00:02:56,400
all that good stuff we could write it by

00:02:54,160 --> 00:02:58,560
ourselves but i'd much prefer to let the

00:02:56,400 --> 00:03:00,400
annotations do the talking so these are

00:02:58,560 --> 00:03:02,159
lumbar annotations they

00:03:00,400 --> 00:03:03,760
synthesize getter setters to string

00:03:02,159 --> 00:03:05,760
equals hat and all that kind of stuff

00:03:03,760 --> 00:03:06,800
and then to persist instances of this

00:03:05,760 --> 00:03:08,720
into the database

00:03:06,800 --> 00:03:10,319
i'm going to create a repository a

00:03:08,720 --> 00:03:12,480
repository of course being a

00:03:10,319 --> 00:03:14,159
design pattern designed to insulate

00:03:12,480 --> 00:03:16,560
business logic from the tedious

00:03:14,159 --> 00:03:17,519
soul annihilatingly boring uh read write

00:03:16,560 --> 00:03:20,560
update and delete

00:03:17,519 --> 00:03:21,680
lifecycle management okay so command

00:03:20,560 --> 00:03:22,879
line runner

00:03:21,680 --> 00:03:24,720
we're going to implement this method

00:03:22,879 --> 00:03:25,760
here i'm going to create a bean of type

00:03:24,720 --> 00:03:29,200
component

00:03:25,760 --> 00:03:30,560
and we're going to inject collaborating

00:03:29,200 --> 00:03:32,319
objects right something that'll

00:03:30,560 --> 00:03:34,319
implement the contract of customer

00:03:32,319 --> 00:03:36,319
repository notice that we haven't

00:03:34,319 --> 00:03:38,000
had to implement that interface spring

00:03:36,319 --> 00:03:40,239
will provide a bean an object

00:03:38,000 --> 00:03:41,680
that satisfies that contract and give us

00:03:40,239 --> 00:03:43,200
that reference when we ask for it

00:03:41,680 --> 00:03:45,920
in the constructor that's what the

00:03:43,200 --> 00:03:47,360
sanitation signals it's it synthesizes

00:03:45,920 --> 00:03:48,319
using it's another long book annotation

00:03:47,360 --> 00:03:50,720
it synthesizes

00:03:48,319 --> 00:03:52,000
a constructor uh with one parameter a

00:03:50,720 --> 00:03:54,239
custom repository

00:03:52,000 --> 00:03:56,000
and so now we're going to write some

00:03:54,239 --> 00:03:57,280
names to the database this is a reactive

00:03:56,000 --> 00:03:59,680
streams type it's

00:03:57,280 --> 00:04:00,879
it's a container type for a bunch of

00:03:59,680 --> 00:04:02,480
things right and that's

00:04:00,879 --> 00:04:04,319
that those things could be potentially

00:04:02,480 --> 00:04:05,920
unbounded and unlimited etc

00:04:04,319 --> 00:04:07,599
and so let's get some people on the

00:04:05,920 --> 00:04:15,840
spring team my name is josh it is so

00:04:07,599 --> 00:04:15,840
lovely to meet you

00:04:20,000 --> 00:04:23,440
and i need to force it to evaluate the

00:04:21,680 --> 00:04:25,840
pipeline and you would do that with

00:04:23,440 --> 00:04:27,120
subscribe so subscribe the problem is

00:04:25,840 --> 00:04:28,400
that this is asynchronous there's no

00:04:27,120 --> 00:04:30,479
guarantee that

00:04:28,400 --> 00:04:31,440
anything that succeeds it will occur

00:04:30,479 --> 00:04:32,400
immediately after anything that

00:04:31,440 --> 00:04:33,919
perceives it

00:04:32,400 --> 00:04:35,840
instead this happens on a different

00:04:33,919 --> 00:04:36,560
thread typically so you need to use the

00:04:35,840 --> 00:04:38,240
operators

00:04:36,560 --> 00:04:39,919
and i do have some things that need to

00:04:38,240 --> 00:04:42,479
happen in a particular order

00:04:39,919 --> 00:04:44,240
namely i need to create the database

00:04:42,479 --> 00:04:45,360
table remember it's an embedded database

00:04:44,240 --> 00:04:47,280
like um

00:04:45,360 --> 00:04:48,880
like uh sqlite or something like that

00:04:47,280 --> 00:04:57,840
right so i'm going to

00:04:48,880 --> 00:04:57,840
use dbc and this will be the ddl

00:05:00,960 --> 00:05:04,720
and here's all the records

00:05:05,199 --> 00:05:08,320
dot find all and i want these things to

00:05:07,120 --> 00:05:09,120
happen in order so i'll use the

00:05:08,320 --> 00:05:13,600
operators i'll say

00:05:09,120 --> 00:05:16,000
then this and then

00:05:13,600 --> 00:05:17,440
that and then finally when i subscribe

00:05:16,000 --> 00:05:20,320
to the whole thing

00:05:17,440 --> 00:05:21,280
and print it out so system out print

00:05:20,320 --> 00:05:23,199
line

00:05:21,280 --> 00:05:24,400
okay that's it that's the entire

00:05:23,199 --> 00:05:25,360
initialization logic

00:05:24,400 --> 00:05:27,199
obviously you wouldn't do this in a

00:05:25,360 --> 00:05:27,680
production application but as this is a

00:05:27,199 --> 00:05:28,960
demo

00:05:27,680 --> 00:05:30,639
and it gave us a chance to kind of look

00:05:28,960 --> 00:05:31,360
at reactive programming i felt like it

00:05:30,639 --> 00:05:33,520
was okay

00:05:31,360 --> 00:05:35,039
so we're going to create a http endpoint

00:05:33,520 --> 00:05:37,199
customer rest controller

00:05:35,039 --> 00:05:39,919
we'll inject the customer repository

00:05:37,199 --> 00:05:41,680
there not the customer er the repository

00:05:39,919 --> 00:05:43,120
uh it's going to be the customer's

00:05:41,680 --> 00:05:47,199
endpoint returning

00:05:43,120 --> 00:05:49,600
a reactive stream of customers so

00:05:47,199 --> 00:05:51,280
here we are and of course as before

00:05:49,600 --> 00:05:52,479
we'll synthesize the getters that etc is

00:05:51,280 --> 00:05:54,160
the two string and the hash code

00:05:52,479 --> 00:05:56,639
let's go ahead and start this and see

00:05:54,160 --> 00:05:56,639
what happens

00:06:00,720 --> 00:06:04,560
okay there it is it has worked we can

00:06:03,120 --> 00:06:05,199
visit this endpoint we've got our eight

00:06:04,560 --> 00:06:07,919
records

00:06:05,199 --> 00:06:08,560
great now i want to build an r socket

00:06:07,919 --> 00:06:09,840
endpoint

00:06:08,560 --> 00:06:12,000
so i'll go back to start that spring

00:06:09,840 --> 00:06:15,840
rail and here rather than using

00:06:12,000 --> 00:06:17,840
uh the http support i'll use r socket

00:06:15,840 --> 00:06:19,360
our socket is a binary protocol that's

00:06:17,840 --> 00:06:20,479
developed by engineers at netflix who

00:06:19,360 --> 00:06:21,600
then went to facebook

00:06:20,479 --> 00:06:24,080
it's designed to solve some of the

00:06:21,600 --> 00:06:27,600
limitations of http and http 2 and

00:06:24,080 --> 00:06:29,759
grpc and the like it provides a

00:06:27,600 --> 00:06:31,120
full range of message exchange patterns

00:06:29,759 --> 00:06:32,880
including fire and forget request

00:06:31,120 --> 00:06:34,560
response streaming etc

00:06:32,880 --> 00:06:36,160
it's bi-directional so once connected

00:06:34,560 --> 00:06:37,440
either side can initiate the

00:06:36,160 --> 00:06:39,680
conversation or

00:06:37,440 --> 00:06:41,600
uh you know ask questions of the other

00:06:39,680 --> 00:06:42,639
it's also multiplexed so you have one

00:06:41,600 --> 00:06:44,400
open socket that you

00:06:42,639 --> 00:06:45,680
originate at the very beginning of the

00:06:44,400 --> 00:06:47,280
the application life cycle

00:06:45,680 --> 00:06:49,759
and that then stays open and it can

00:06:47,280 --> 00:06:51,360
serve requests thereafter

00:06:49,759 --> 00:06:52,639
so it's a really interesting protocol we

00:06:51,360 --> 00:06:54,080
don't have a lot of time to get all into

00:06:52,639 --> 00:06:54,960
it but it's well supported in spring

00:06:54,080 --> 00:06:57,919
because it is

00:06:54,960 --> 00:06:59,680
a reactive technology it is it rarefies

00:06:57,919 --> 00:07:01,360
the concepts of reactive programming

00:06:59,680 --> 00:07:03,840
on the wire so we're going to create a

00:07:01,360 --> 00:07:03,840
new service here

00:07:04,400 --> 00:07:08,319
here we are orders and we're just going

00:07:06,160 --> 00:07:10,400
to create a simple

00:07:08,319 --> 00:07:11,360
object called an order and this is the

00:07:10,400 --> 00:07:12,639
order for

00:07:11,360 --> 00:07:14,479
our customers right so we're going to

00:07:12,639 --> 00:07:15,440
have customers and they in turn will

00:07:14,479 --> 00:07:17,360
have orders

00:07:15,440 --> 00:07:19,280
and you know you might argue about

00:07:17,360 --> 00:07:20,479
whether one should be a part of the same

00:07:19,280 --> 00:07:22,160
aggregate as the other

00:07:20,479 --> 00:07:24,319
uh or not and you know that's a fair

00:07:22,160 --> 00:07:27,039
discussion but to my thinking

00:07:24,319 --> 00:07:27,759
uh you know we've got a customer entity

00:07:27,039 --> 00:07:30,880
and

00:07:27,759 --> 00:07:32,800
should that customer then

00:07:30,880 --> 00:07:34,639
be deleted or tombstone or whatever you

00:07:32,800 --> 00:07:36,639
would still keep the order data around

00:07:34,639 --> 00:07:38,400
for revenue recognition purposes

00:07:36,639 --> 00:07:39,520
uh or something like that so i don't

00:07:38,400 --> 00:07:40,800
know i imagine these things have a

00:07:39,520 --> 00:07:42,960
separate life cycle but

00:07:40,800 --> 00:07:44,000
it is really a design discussion and

00:07:42,960 --> 00:07:47,039
that's not what we're here for

00:07:44,000 --> 00:07:50,720
so controller

00:07:47,039 --> 00:07:52,639
map and i'm going to build an endpoint

00:07:50,720 --> 00:07:59,840
here

00:07:52,639 --> 00:07:59,840
customer id

00:08:04,479 --> 00:08:13,840
all right

00:08:17,680 --> 00:08:20,319
so there's our

00:08:21,280 --> 00:08:25,039
orders controller it's going to return

00:08:23,520 --> 00:08:27,039
data from this in-memory

00:08:25,039 --> 00:08:28,319
concurrent map of data and obviously we

00:08:27,039 --> 00:08:29,680
have to put some data in there so

00:08:28,319 --> 00:08:32,640
i'll just do that for the sake of our

00:08:29,680 --> 00:08:36,000
demo here in the constructor

00:08:32,640 --> 00:08:38,560
we'll say for var customer id

00:08:36,000 --> 00:08:39,120
equals one customer id is less than or

00:08:38,560 --> 00:08:41,519
equal to

00:08:39,120 --> 00:08:43,039
eight customer id plus plus and we're

00:08:41,519 --> 00:08:46,560
gonna say var

00:08:43,039 --> 00:08:51,600
uh list of orders equals new

00:08:46,560 --> 00:09:09,839
arraylist and we want this to be orders

00:08:51,600 --> 00:09:09,839
for our order id equals one

00:09:13,120 --> 00:09:17,680
all right so we've got now some random

00:09:15,440 --> 00:09:21,040
data and let's just put that in here

00:09:17,680 --> 00:09:24,000
like so customer id

00:09:21,040 --> 00:09:24,640
to orders and now when somebody looks at

00:09:24,000 --> 00:09:26,160
the data

00:09:24,640 --> 00:09:27,440
they'll have something to look at great

00:09:26,160 --> 00:09:28,720
so let's start this up we wanted to

00:09:27,440 --> 00:09:30,399
start it on a different port obviously

00:09:28,720 --> 00:09:32,160
it's not the same as an http service

00:09:30,399 --> 00:09:34,000
so we started it up on the r socket port

00:09:32,160 --> 00:09:36,170
that we specify here

00:09:34,000 --> 00:09:37,600
let's restart

00:09:36,170 --> 00:09:40,000
[Music]

00:09:37,600 --> 00:09:41,040
okay it's up and running we can just as

00:09:40,000 --> 00:09:42,800
we can curl

00:09:41,040 --> 00:09:45,279
the http service that we created earlier

00:09:42,800 --> 00:09:45,279
like this

00:09:45,519 --> 00:09:53,120
we can also use rsc to get the data from

00:09:50,080 --> 00:09:53,120
the our second endpoint

00:09:53,279 --> 00:10:00,640
so 81 81 and

00:09:56,880 --> 00:10:02,480
the route is orders let's say two

00:10:00,640 --> 00:10:03,760
and the interaction type is a stream

00:10:02,480 --> 00:10:05,839
there we go so we have our

00:10:03,760 --> 00:10:07,680
http and we have our socket endpoints

00:10:05,839 --> 00:10:08,800
let's create a gateway and we're going

00:10:07,680 --> 00:10:10,800
to go back here

00:10:08,800 --> 00:10:12,560
to start that sprinkle and here we're

00:10:10,800 --> 00:10:14,959
going to create an api gateway

00:10:12,560 --> 00:10:15,920
okay now here we can use spring cloud

00:10:14,959 --> 00:10:18,959
gateway we can use

00:10:15,920 --> 00:10:22,320
lumbok the reactive web support and

00:10:18,959 --> 00:10:24,240
our socket support i've inadvertently

00:10:22,320 --> 00:10:26,000
created two so let me get rid of that

00:10:24,240 --> 00:10:33,839
okay i'm happy with that let's go ahead

00:10:26,000 --> 00:10:33,839
and hit generate

00:10:36,399 --> 00:10:40,000
so our gateway is just a it's a place

00:10:38,480 --> 00:10:41,279
where we can address cross-cutting kinds

00:10:40,000 --> 00:10:43,760
of concerns things like

00:10:41,279 --> 00:10:45,839
routing refreshing uh circuit breaking

00:10:43,760 --> 00:10:48,079
security authentication

00:10:45,839 --> 00:10:49,839
caching etc there's two things you might

00:10:48,079 --> 00:10:50,480
do at an edge service like this you

00:10:49,839 --> 00:10:53,519
might

00:10:50,480 --> 00:10:55,440
do generic cross-cutting kinds of things

00:10:53,519 --> 00:10:57,200
you know that affect all the services

00:10:55,440 --> 00:10:57,760
all the downstream services regardless

00:10:57,200 --> 00:10:59,279
of

00:10:57,760 --> 00:11:01,839
their particular semantics of their

00:10:59,279 --> 00:11:04,640
particular protocol this is a great

00:11:01,839 --> 00:11:06,000
use of a api gateway api gateways are a

00:11:04,640 --> 00:11:08,399
great place to do kind of

00:11:06,000 --> 00:11:09,839
aop but for the web okay and so what i'm

00:11:08,399 --> 00:11:13,040
going to do is i'm going to

00:11:09,839 --> 00:11:15,760
create an api gateway that

00:11:13,040 --> 00:11:17,279
when it receives a request to this host

00:11:15,760 --> 00:11:20,560
and port which by the way

00:11:17,279 --> 00:11:24,079
will be 99.99

00:11:20,560 --> 00:11:26,240
we'll forward the request to localhost

00:11:24,079 --> 00:11:28,160
8080 for customers which of course you

00:11:26,240 --> 00:11:30,800
might remember since we just wrote it

00:11:28,160 --> 00:11:32,959
is where our customer service lives and

00:11:30,800 --> 00:11:36,160
that's an http service but the thing is

00:11:32,959 --> 00:11:37,680
uh we can't take the incoming request

00:11:36,160 --> 00:11:39,600
that matches this predicate of

00:11:37,680 --> 00:11:41,360
forward slash proxy and afford it to

00:11:39,600 --> 00:11:42,800
this one because it would concatenate

00:11:41,360 --> 00:11:44,480
the request it would try and

00:11:42,800 --> 00:11:46,320
merge the incoming request and forward

00:11:44,480 --> 00:11:47,519
it basically unadulterated to the

00:11:46,320 --> 00:11:49,519
downtrend service

00:11:47,519 --> 00:11:51,040
so what we want to do is to process the

00:11:49,519 --> 00:11:53,120
request as it arrives

00:11:51,040 --> 00:11:55,839
and we do this with the use of filters

00:11:53,120 --> 00:11:57,680
so set path

00:11:55,839 --> 00:11:59,200
and then we send that down here now

00:11:57,680 --> 00:12:00,800
these filters are where the real power

00:11:59,200 --> 00:12:02,399
of spring cloud gateway lay

00:12:00,800 --> 00:12:04,639
these filters do things like rate

00:12:02,399 --> 00:12:06,000
limiting you can do retries you can do

00:12:04,639 --> 00:12:07,600
circuit breakers you can do

00:12:06,000 --> 00:12:09,600
just about everything you add add

00:12:07,600 --> 00:12:10,800
headers modify the request body the

00:12:09,600 --> 00:12:13,600
response body

00:12:10,800 --> 00:12:13,920
etc etc so a lot of power there there's

00:12:13,600 --> 00:12:16,320
our

00:12:13,920 --> 00:12:16,959
api gateway we can uh you know see that

00:12:16,320 --> 00:12:18,240
in action

00:12:16,959 --> 00:12:20,399
the other thing that you will probably

00:12:18,240 --> 00:12:21,279
want to do is to create an api adapter

00:12:20,399 --> 00:12:24,880
so let's say

00:12:21,279 --> 00:12:26,399
i create a crm client and this in turn

00:12:24,880 --> 00:12:29,040
is going to talk to the downtrend

00:12:26,399 --> 00:12:31,680
services so i'll create some dtos

00:12:29,040 --> 00:12:32,560
to represent the downstream data the

00:12:31,680 --> 00:12:35,440
data we might get

00:12:32,560 --> 00:12:35,920
from the downstream services uh it's

00:12:35,440 --> 00:12:38,000
going to look

00:12:35,920 --> 00:12:39,920
awfully familiar and you might even

00:12:38,000 --> 00:12:43,040
extract out those types from those

00:12:39,920 --> 00:12:45,839
other services into some sort of mutual

00:12:43,040 --> 00:12:46,240
shared uh you know representation maybe

00:12:45,839 --> 00:12:50,079
a

00:12:46,240 --> 00:12:53,440
swagger or something like that okay so

00:12:50,079 --> 00:12:56,880
string name private

00:12:53,440 --> 00:12:59,920
i teacher id okay

00:12:56,880 --> 00:12:59,920
so as before

00:13:01,279 --> 00:13:08,800
we'll use these we got these types here

00:13:06,000 --> 00:13:08,800
add component

00:13:09,440 --> 00:13:16,880
order get orders for

00:13:13,279 --> 00:13:16,880
integer customer id

00:13:18,320 --> 00:13:22,079
and we're just going to stub these out

00:13:19,920 --> 00:13:23,920
for the moment so that we kind of know

00:13:22,079 --> 00:13:25,279
what we're trying to do here

00:13:23,920 --> 00:13:27,839
uh sorry i'm not getting worse get

00:13:25,279 --> 00:13:27,839
customers

00:13:29,120 --> 00:13:33,360
okay so we want to create we want to

00:13:31,920 --> 00:13:35,760
make a call to the http service i'm

00:13:33,360 --> 00:13:38,240
going to do that using our non-blocking

00:13:35,760 --> 00:13:39,120
http client web client and we're going

00:13:38,240 --> 00:13:41,920
to do

00:13:39,120 --> 00:13:42,480
the same for the r socket endpoint using

00:13:41,920 --> 00:13:45,360
our

00:13:42,480 --> 00:13:46,320
non-blocking r socket client called our

00:13:45,360 --> 00:13:47,279
socket requester

00:13:46,320 --> 00:13:48,959
we're going to synthesize the

00:13:47,279 --> 00:13:50,639
constructor so that we can have a some

00:13:48,959 --> 00:13:52,480
place for the framework to inject

00:13:50,639 --> 00:13:54,720
collaborating references we need the

00:13:52,480 --> 00:13:57,199
factory we need to vend or produce or

00:13:54,720 --> 00:13:58,959
you know make available instances of

00:13:57,199 --> 00:14:04,240
these types and we can do that as

00:13:58,959 --> 00:14:07,519
more beans here so r socket requester

00:14:04,240 --> 00:14:11,680
or socket requester.builder

00:14:07,519 --> 00:14:14,160
b dot build okay localhost

00:14:11,680 --> 00:14:14,720
8181 and remember r socket when it

00:14:14,160 --> 00:14:17,920
starts up

00:14:14,720 --> 00:14:18,720
you uh you connect up front right you

00:14:17,920 --> 00:14:22,480
can do that

00:14:18,720 --> 00:14:23,760
each time okay uh

00:14:22,480 --> 00:14:26,079
you don't have to redo it each time

00:14:23,760 --> 00:14:27,440
rather okay so we've got our http

00:14:26,079 --> 00:14:28,160
endpoints we've got our r socket

00:14:27,440 --> 00:14:30,959
endpoint

00:14:28,160 --> 00:14:33,199
um uh we've got clients or both right so

00:14:30,959 --> 00:14:35,279
here's our socket there's http

00:14:33,199 --> 00:14:36,800
now we have the ability to actually

00:14:35,279 --> 00:14:40,240
build these requests out so

00:14:36,800 --> 00:14:43,519
this taught http dot git dot uri

00:14:40,240 --> 00:14:44,480
http localhost 8080 forward slash

00:14:43,519 --> 00:14:46,000
customers

00:14:44,480 --> 00:14:47,600
and we're going to retrieve the data i'm

00:14:46,000 --> 00:14:49,839
going to say body to flux

00:14:47,600 --> 00:14:51,839
customer.class now this assumes of

00:14:49,839 --> 00:14:53,519
course uh naively of course that

00:14:51,839 --> 00:14:55,199
the downstream service is always going

00:14:53,519 --> 00:14:55,839
to be available which just is just not

00:14:55,199 --> 00:14:58,399
the case

00:14:55,839 --> 00:14:59,279
there things could you know go bump in

00:14:58,399 --> 00:15:02,399
the night right the

00:14:59,279 --> 00:15:05,120
the internet is a dangerous place

00:15:02,399 --> 00:15:06,959
so we have to uh handle failure we can

00:15:05,120 --> 00:15:09,279
do that by doing retries or

00:15:06,959 --> 00:15:10,560
retry when and we can do a back off

00:15:09,279 --> 00:15:13,040
perhaps and we can

00:15:10,560 --> 00:15:14,880
back off with a you know a number of

00:15:13,040 --> 00:15:17,279
seconds or something like this

00:15:14,880 --> 00:15:18,800
etc you can do all these you can use

00:15:17,279 --> 00:15:20,639
these operators and they come

00:15:18,800 --> 00:15:22,160
for free when you use reactive types so

00:15:20,639 --> 00:15:22,959
it doesn't matter that i'm doing http

00:15:22,160 --> 00:15:25,120
here and i'm doing

00:15:22,959 --> 00:15:27,279
r socket there it's just part of the api

00:15:25,120 --> 00:15:28,480
part of the abstraction

00:15:27,279 --> 00:15:30,800
and this is one of the reasons that you

00:15:28,480 --> 00:15:32,399
get more more robust code by using

00:15:30,800 --> 00:15:35,759
reactive apis

00:15:32,399 --> 00:15:37,360
so the route is orders the customer id

00:15:35,759 --> 00:15:38,720
is the second parameter there

00:15:37,360 --> 00:15:42,639
and we're going to get the data and turn

00:15:38,720 --> 00:15:44,399
it into a stream of order data

00:15:42,639 --> 00:15:46,480
and then finally i want to take all of

00:15:44,399 --> 00:15:48,160
that and i'm going to create a

00:15:46,480 --> 00:15:49,519
an aggregate i'm going to do scatter

00:15:48,160 --> 00:15:50,880
gather service orchestration and

00:15:49,519 --> 00:15:54,399
composition

00:15:50,880 --> 00:15:55,360
like so so i'll say class and it's just

00:15:54,399 --> 00:15:58,959
going to be a

00:15:55,360 --> 00:16:01,839
stream of customers a stream of orders

00:15:58,959 --> 00:16:01,839
or list of orders

00:16:05,120 --> 00:16:09,360
all right that's the representation we

00:16:08,160 --> 00:16:10,399
can do

00:16:09,360 --> 00:16:12,800
we're going to call two different

00:16:10,399 --> 00:16:15,759
services and but we don't care that one

00:16:12,800 --> 00:16:17,279
is http and the other uh is our socket

00:16:15,759 --> 00:16:18,560
because at the end of the day

00:16:17,279 --> 00:16:20,399
they're just reactive streams and

00:16:18,560 --> 00:16:22,880
reactive streams makes it trivial for us

00:16:20,399 --> 00:16:23,519
to compose disparate data sources so i'm

00:16:22,880 --> 00:16:25,040
going to say

00:16:23,519 --> 00:16:27,839
give me the customers and then for each

00:16:25,040 --> 00:16:33,120
customer i'm going to create a tuple

00:16:27,839 --> 00:16:36,320
okay so mono.zip mono.just

00:16:33,120 --> 00:16:39,920
customer on one side

00:16:36,320 --> 00:16:40,959
and all the orders on the other side so

00:16:39,920 --> 00:16:44,079
customer dot

00:16:40,959 --> 00:16:47,680
get id dot collect list

00:16:44,079 --> 00:16:51,120
and what that does is it gives me this

00:16:47,680 --> 00:16:52,959
stream this stream of tuples

00:16:51,120 --> 00:16:54,720
and you can see each tuple has a type so

00:16:52,959 --> 00:16:55,360
t1 is the customer t2 is the list of

00:16:54,720 --> 00:16:57,040
orders

00:16:55,360 --> 00:16:59,920
so i'm going to just put those into the

00:16:57,040 --> 00:16:59,920
custom order object

00:17:00,000 --> 00:17:06,000
like so and voila

00:17:03,600 --> 00:17:07,360
right so now we've got the entire

00:17:06,000 --> 00:17:09,199
application

00:17:07,360 --> 00:17:10,720
really really easy to kind of understand

00:17:09,199 --> 00:17:11,839
i've just made a network call

00:17:10,720 --> 00:17:13,120
and for each one i'm getting the

00:17:11,839 --> 00:17:14,640
customer and i'm getting orders but

00:17:13,120 --> 00:17:16,480
because i'm using reactive apis

00:17:14,640 --> 00:17:18,160
behind the scenes this is never blocking

00:17:16,480 --> 00:17:18,720
it's doing concurrent scattered gather

00:17:18,160 --> 00:17:20,480
kinds of

00:17:18,720 --> 00:17:21,679
surface orchestration composition and

00:17:20,480 --> 00:17:23,120
yet you don't see a single cyclic

00:17:21,679 --> 00:17:25,120
barrier or countdown latcher

00:17:23,120 --> 00:17:26,559
or whatever so let's go ahead and see

00:17:25,120 --> 00:17:29,360
this in action we'll create one more

00:17:26,559 --> 00:17:30,240
component here one more object a rest

00:17:29,360 --> 00:17:35,039
endpoint

00:17:30,240 --> 00:17:35,039
customer orders rest controller

00:17:35,440 --> 00:17:43,280
and we'll say git mapping cos

00:17:39,039 --> 00:17:43,280
publisher of customer order

00:17:43,360 --> 00:17:48,640
and of course we'll use the crm client

00:17:45,919 --> 00:17:48,640
that we just created

00:17:49,280 --> 00:17:53,520
all right there's our injected type

00:17:54,000 --> 00:17:57,360
and that's it that's the thing so let's

00:17:55,840 --> 00:17:58,559
go ahead and start this up and see what

00:17:57,360 --> 00:18:00,559
happens

00:17:58,559 --> 00:18:03,840
remember we've created an api gateway

00:18:00,559 --> 00:18:03,840
and an api adapter

00:18:04,720 --> 00:18:11,200
all right localhost

00:18:08,320 --> 00:18:12,240
99.99 cos there it is there's the

00:18:11,200 --> 00:18:14,160
customer data

00:18:12,240 --> 00:18:16,240
and the orders for the customer and of

00:18:14,160 --> 00:18:17,280
course here's the proxy endpoint

00:18:16,240 --> 00:18:18,880
that gives us the data from the

00:18:17,280 --> 00:18:20,080
downstream so we've looked at a number

00:18:18,880 --> 00:18:20,799
of patterns that make it easy to

00:18:20,080 --> 00:18:23,280
integrate

00:18:20,799 --> 00:18:25,280
uh different sources and streams of data

00:18:23,280 --> 00:18:28,400
and to do so in a robust retriable

00:18:25,280 --> 00:18:29,760
convenient consistent and efficient way

00:18:28,400 --> 00:18:31,200
that said we're not yet ready for

00:18:29,760 --> 00:18:31,679
production so one of the things i want

00:18:31,200 --> 00:18:33,360
when i

00:18:31,679 --> 00:18:34,799
for example go back to my customer

00:18:33,360 --> 00:18:35,679
service is i want to support

00:18:34,799 --> 00:18:37,919
observability

00:18:35,679 --> 00:18:38,720
and that's why i added the spring boot

00:18:37,919 --> 00:18:40,559
actuator

00:18:38,720 --> 00:18:41,760
the actuator are a set of managed http

00:18:40,559 --> 00:18:43,120
endpoints that give me

00:18:41,760 --> 00:18:45,600
insight into the state of the

00:18:43,120 --> 00:18:47,679
application so i can expose all the

00:18:45,600 --> 00:18:49,679
endpoints here i can say expose them all

00:18:47,679 --> 00:18:51,200
i want the health endpoint to show me

00:18:49,679 --> 00:18:52,400
all the details and i want the

00:18:51,200 --> 00:18:55,039
kubernetes probes

00:18:52,400 --> 00:18:56,000
to be enabled as well these are great

00:18:55,039 --> 00:18:57,120
for a demo but obviously

00:18:56,000 --> 00:18:58,960
you're going to want to lock down these

00:18:57,120 --> 00:18:59,280
endpoints or more to the point you want

00:18:58,960 --> 00:19:01,679
to

00:18:59,280 --> 00:19:02,720
not open them up as i just did so that

00:19:01,679 --> 00:19:04,880
they don't

00:19:02,720 --> 00:19:06,480
spew secret sensitive information

00:19:04,880 --> 00:19:08,840
they're good for our purposes however so

00:19:06,480 --> 00:19:11,520
localhost

00:19:08,840 --> 00:19:14,320
localhost 8080

00:19:11,520 --> 00:19:15,520
forward slash actuator you can see we've

00:19:14,320 --> 00:19:17,200
got a number of different endpoints

00:19:15,520 --> 00:19:19,840
beans caches health

00:19:17,200 --> 00:19:20,240
the health endpoint gives us a set of

00:19:19,840 --> 00:19:22,960
you know

00:19:20,240 --> 00:19:24,720
it gives us a a listing an enumeration

00:19:22,960 --> 00:19:27,600
of all the subsystems that may imperil

00:19:24,720 --> 00:19:29,039
our services overall health and you can

00:19:27,600 --> 00:19:30,160
also see that we've got two probes that

00:19:29,039 --> 00:19:32,240
correspond to

00:19:30,160 --> 00:19:33,840
kubernetes concept of a liveness probe

00:19:32,240 --> 00:19:34,400
which is to say is the service still

00:19:33,840 --> 00:19:36,240
alive

00:19:34,400 --> 00:19:38,320
and a readiness probe which is to say

00:19:36,240 --> 00:19:40,000
does the service is the service able to

00:19:38,320 --> 00:19:41,840
respond to

00:19:40,000 --> 00:19:43,120
to be put into traffic right into to be

00:19:41,840 --> 00:19:45,200
put into production

00:19:43,120 --> 00:19:47,200
if these services if any of those

00:19:45,200 --> 00:19:49,360
endpoints the health or the probes

00:19:47,200 --> 00:19:50,720
should ever return uh false or if you

00:19:49,360 --> 00:19:51,440
wanted to have a custom probe you very

00:19:50,720 --> 00:19:53,120
easily could

00:19:51,440 --> 00:19:54,640
uh then kubernetes would eventually

00:19:53,120 --> 00:19:56,720
decide okay well it needs to just

00:19:54,640 --> 00:19:58,160
it needs to kill that pod and then

00:19:56,720 --> 00:19:59,280
create a new one and um

00:19:58,160 --> 00:20:01,039
the question is does it kill it

00:19:59,280 --> 00:20:02,159
immediately does it or does it give you

00:20:01,039 --> 00:20:05,280
enough time to drain

00:20:02,159 --> 00:20:08,080
existing traffic and uh give it you know

00:20:05,280 --> 00:20:08,880
to taper off your work you can control

00:20:08,080 --> 00:20:11,360
that with

00:20:08,880 --> 00:20:12,080
you know your shutdown here so you can

00:20:11,360 --> 00:20:13,679
say instead of

00:20:12,080 --> 00:20:15,520
immediate which is the default you get

00:20:13,679 --> 00:20:16,880
graceful shutdown so in this case you'll

00:20:15,520 --> 00:20:18,799
get sig term and then

00:20:16,880 --> 00:20:20,000
some interval which is configurable of

00:20:18,799 --> 00:20:20,880
course but i think it's like 30 seconds

00:20:20,000 --> 00:20:22,799
by default

00:20:20,880 --> 00:20:24,559
and then you'll get sig kill this makes

00:20:22,799 --> 00:20:25,520
your services more robust

00:20:24,559 --> 00:20:27,120
the next thing we're going to worry

00:20:25,520 --> 00:20:28,640
about when we get to production is of

00:20:27,120 --> 00:20:31,440
course taking the software

00:20:28,640 --> 00:20:32,880
and containerizing it right and no don't

00:20:31,440 --> 00:20:35,039
freak out i'm not talking about

00:20:32,880 --> 00:20:36,240
writing a docker file or yaml yamo is

00:20:35,039 --> 00:20:38,400
why people leave it

00:20:36,240 --> 00:20:39,280
i'm not for it instead we're going to

00:20:38,400 --> 00:20:41,919
use something called

00:20:39,280 --> 00:20:41,919
build packs

00:20:44,799 --> 00:20:52,000
all right let's go to customer service

00:20:48,960 --> 00:20:55,440
and we're going to do maven clean

00:20:52,000 --> 00:20:58,559
spring boot sorry maven clean

00:20:55,440 --> 00:21:01,919
package spring boot colon

00:20:58,559 --> 00:21:02,880
build image this is going to kick off

00:21:01,919 --> 00:21:05,360
the pipeline

00:21:02,880 --> 00:21:07,280
that uses pacquiao to build a container

00:21:05,360 --> 00:21:08,640
now because we're doing a native image

00:21:07,280 --> 00:21:10,480
and because this is a very resource

00:21:08,640 --> 00:21:12,159
intensive thing this takes about five

00:21:10,480 --> 00:21:14,159
minutes because it's going to recompile

00:21:12,159 --> 00:21:15,919
not just our source code but all the

00:21:14,159 --> 00:21:17,280
byte code that's on the class path which

00:21:15,919 --> 00:21:19,360
is typically what we consider

00:21:17,280 --> 00:21:20,720
the binary for the application it's

00:21:19,360 --> 00:21:24,720
going to then turn that all into

00:21:20,720 --> 00:21:31,840
x you know in this case x86 machine code

00:21:24,720 --> 00:21:31,840
or whatever your platform is

00:21:33,600 --> 00:21:37,360
all right our build is completed now

00:21:35,840 --> 00:21:38,000
let's run this and see what that looks

00:21:37,360 --> 00:21:39,760
like

00:21:38,000 --> 00:21:41,280
the benefit of this container technology

00:21:39,760 --> 00:21:42,880
is that we've

00:21:41,280 --> 00:21:44,720
built a native image which will start up

00:21:42,880 --> 00:21:46,320
in much much faster

00:21:44,720 --> 00:21:48,320
uh time you can see that most of my

00:21:46,320 --> 00:21:48,880
services take a second or less to start

00:21:48,320 --> 00:21:51,200
but

00:21:48,880 --> 00:21:52,000
still around a second right with this

00:21:51,200 --> 00:21:53,360
however

00:21:52,000 --> 00:21:55,840
now that it's been converted to a native

00:21:53,360 --> 00:21:59,679
image we can start it up in

00:21:55,840 --> 00:22:01,679
a mere fraction of that

00:21:59,679 --> 00:22:03,200
i want to thank you so much for joining

00:22:01,679 --> 00:22:03,760
my talk today i hope you got something

00:22:03,200 --> 00:22:05,520
out of it

00:22:03,760 --> 00:22:12,640
hope you're all doing well stay healthy

00:22:05,520 --> 00:22:12,640

YouTube URL: https://www.youtube.com/watch?v=oq5FcnqEMxk


