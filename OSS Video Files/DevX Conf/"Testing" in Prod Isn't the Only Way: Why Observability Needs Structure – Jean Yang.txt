Title: "Testing" in Prod Isn't the Only Way: Why Observability Needs Structure â€“ Jean Yang
Publication date: 2021-04-29
Playlist: DevX Conf
Description: 
	The rise of APIs and service-oriented architectures has made it easier than ever before to build complex web applications. But the developer tools we use were made for a simpler time, one where developers had more control over all of the software they ran. Today, web applications contain many heterogeneous components, all talking to each other across the network, many of them SaaS apps. "Testing" in production has become the only way to make sense. I'll talk about why we need to update our idea of testing, how we can do better at understanding prod, and how bringing structure to observability is the way forward for both.

About DevX Conf:
DevX Conf is a two-day virtual conference. It's a space where creators collaborate, listen, discuss and declutter our workflows, toolchains, and minds. To improve developer experience. Organized by Gitpod.
https://devxconf.org/
Captions: 
	00:00:13,840 --> 00:00:16,320
hi

00:00:14,080 --> 00:00:18,080
i'm jean and today we're going to talk

00:00:16,320 --> 00:00:20,480
about facing reality

00:00:18,080 --> 00:00:21,680
facing the reality of software facing

00:00:20,480 --> 00:00:23,439
the reality of

00:00:21,680 --> 00:00:25,680
software engineering the first reality

00:00:23,439 --> 00:00:27,359
is this if you talk to most software

00:00:25,680 --> 00:00:29,599
teams they'll say something like

00:00:27,359 --> 00:00:30,640
oh we try to be good about integration

00:00:29,599 --> 00:00:32,800
tests

00:00:30,640 --> 00:00:35,120
but we really don't know if a change

00:00:32,800 --> 00:00:38,000
will take down our site until production

00:00:35,120 --> 00:00:39,680
and so while there's this theory of

00:00:38,000 --> 00:00:41,360
tests should happen in tests all this

00:00:39,680 --> 00:00:42,160
stuff should happen before you run your

00:00:41,360 --> 00:00:44,079
code

00:00:42,160 --> 00:00:46,480
most software teams that i've talked to

00:00:44,079 --> 00:00:50,879
effectively test in production

00:00:46,480 --> 00:00:53,280
and they either openly or secretly

00:00:50,879 --> 00:00:55,039
completely diverge from everything that

00:00:53,280 --> 00:00:56,480
we learned in school about software

00:00:55,039 --> 00:00:58,640
engineering

00:00:56,480 --> 00:01:00,640
and so this talk is about how we can be

00:00:58,640 --> 00:01:04,159
rethinking software engineering for

00:01:00,640 --> 00:01:06,080
2020 and beyond the first part is about

00:01:04,159 --> 00:01:07,920
why software has outgrown software

00:01:06,080 --> 00:01:10,080
engineering as we know it

00:01:07,920 --> 00:01:10,960
so someone said to me the other day that

00:01:10,080 --> 00:01:13,520
the 80s

00:01:10,960 --> 00:01:14,799
are as far from today as the 40s were

00:01:13,520 --> 00:01:16,720
from the 80s which was

00:01:14,799 --> 00:01:18,720
nuts to me i was born in the 80s so i

00:01:16,720 --> 00:01:21,360
was like i'm not that old but

00:01:18,720 --> 00:01:22,240
you know forever is the sweetest con and

00:01:21,360 --> 00:01:23,920
uh

00:01:22,240 --> 00:01:25,280
it uh shouldn't be surprising that a

00:01:23,920 --> 00:01:28,560
term coined in the 80s

00:01:25,280 --> 00:01:29,600
needs uh needs an update so the second

00:01:28,560 --> 00:01:31,360
section of this talk

00:01:29,600 --> 00:01:33,680
is about how we're going to meet

00:01:31,360 --> 00:01:36,320
software development where it is today

00:01:33,680 --> 00:01:37,280
so um as you might have guessed from the

00:01:36,320 --> 00:01:38,960
title of this talk

00:01:37,280 --> 00:01:40,479
i don't believe that we should settle

00:01:38,960 --> 00:01:42,479
for testing and production there are

00:01:40,479 --> 00:01:43,200
many good reasons to test and test but

00:01:42,479 --> 00:01:46,079
we need to

00:01:43,200 --> 00:01:47,200
change how that looks and so we'll talk

00:01:46,079 --> 00:01:49,680
about that

00:01:47,200 --> 00:01:51,119
and if you say well gene it would be

00:01:49,680 --> 00:01:52,720
great to do all this stuff but i don't

00:01:51,119 --> 00:01:54,720
believe it can be real

00:01:52,720 --> 00:01:56,799
well i agree there needs to be new

00:01:54,720 --> 00:01:59,439
technical approaches to all of this

00:01:56,799 --> 00:02:00,799
so the last part of my talk is about why

00:01:59,439 --> 00:02:02,960
i believe structure

00:02:00,799 --> 00:02:04,240
and observability but block box

00:02:02,960 --> 00:02:07,360
observability

00:02:04,240 --> 00:02:10,399
is the answer to tooling for a new kind

00:02:07,360 --> 00:02:10,399
of software engineering

00:02:10,640 --> 00:02:14,080
and as for why i'm here talking to you

00:02:12,640 --> 00:02:16,640
about this well

00:02:14,080 --> 00:02:18,160
uh for a little bit of background i was

00:02:16,640 --> 00:02:19,920
previously a professor

00:02:18,160 --> 00:02:22,879
at carnegie mellon university before i

00:02:19,920 --> 00:02:24,400
started my company akita i have spent my

00:02:22,879 --> 00:02:26,800
whole life

00:02:24,400 --> 00:02:28,400
programming and then i've spent all of

00:02:26,800 --> 00:02:30,480
my career going after

00:02:28,400 --> 00:02:31,599
this dream of making better programming

00:02:30,480 --> 00:02:34,319
tools for

00:02:31,599 --> 00:02:36,160
web apps which i thought were just a

00:02:34,319 --> 00:02:36,560
space that could really benefit from

00:02:36,160 --> 00:02:38,879
better

00:02:36,560 --> 00:02:40,400
developer experience and so i had

00:02:38,879 --> 00:02:42,560
initially gone to grad school because i

00:02:40,400 --> 00:02:45,200
wanted to work on tools but not perf

00:02:42,560 --> 00:02:47,040
um i ended up writing papers on things

00:02:45,200 --> 00:02:48,000
like proving software systems correct so

00:02:47,040 --> 00:02:49,680
my first paper ever

00:02:48,000 --> 00:02:51,200
was about proving operating systems to

00:02:49,680 --> 00:02:53,840
be type safe

00:02:51,200 --> 00:02:54,959
i worked on language design my phd

00:02:53,840 --> 00:02:57,040
thesis was about

00:02:54,959 --> 00:02:58,560
a language for automatically enforcing

00:02:57,040 --> 00:03:00,400
security policies

00:02:58,560 --> 00:03:02,480
and so i was i was doing very

00:03:00,400 --> 00:03:04,000
application level stuff when i realized

00:03:02,480 --> 00:03:06,080
that modern software

00:03:04,000 --> 00:03:07,360
is like a rain forest it's a whole

00:03:06,080 --> 00:03:09,360
ecosystem

00:03:07,360 --> 00:03:10,959
and what i was working on was you know

00:03:09,360 --> 00:03:12,879
how do we make sure the feathers are

00:03:10,959 --> 00:03:14,640
okay on a single bird or how do we make

00:03:12,879 --> 00:03:15,200
sure all the leaves are okay on a single

00:03:14,640 --> 00:03:18,080
tree

00:03:15,200 --> 00:03:19,599
and that stuff is very very valuable but

00:03:18,080 --> 00:03:22,400
i was kind of like well

00:03:19,599 --> 00:03:24,159
the rainforest needs some tooling too so

00:03:22,400 --> 00:03:27,519
let's talk about why we need to

00:03:24,159 --> 00:03:29,840
move beyond the 80s so

00:03:27,519 --> 00:03:31,040
i'm as you probably know software

00:03:29,840 --> 00:03:33,760
development today looks

00:03:31,040 --> 00:03:34,400
nothing like software development did 40

00:03:33,760 --> 00:03:38,239
years ago

00:03:34,400 --> 00:03:39,840
apis are all over the place um people

00:03:38,239 --> 00:03:41,280
there's there's great ease with which

00:03:39,840 --> 00:03:42,239
people can use software that other

00:03:41,280 --> 00:03:44,159
people have written

00:03:42,239 --> 00:03:46,000
but on the flip side what this means is

00:03:44,159 --> 00:03:47,920
that creating software isn't about

00:03:46,000 --> 00:03:49,120
building and shipping anymore like and

00:03:47,920 --> 00:03:50,959
back in the day i was building and

00:03:49,120 --> 00:03:52,000
shipping shrink wrap software but now

00:03:50,959 --> 00:03:54,400
it's it's about

00:03:52,000 --> 00:03:56,720
um operating software components so

00:03:54,400 --> 00:03:58,159
you're taking these apis off the shelf

00:03:56,720 --> 00:04:00,640
you don't have very much control over

00:03:58,159 --> 00:04:01,120
them and uh you're trying to make your

00:04:00,640 --> 00:04:03,280
code

00:04:01,120 --> 00:04:04,400
work with this code that you took off

00:04:03,280 --> 00:04:05,680
the shelf and don't have very much

00:04:04,400 --> 00:04:07,280
control over but you can really

00:04:05,680 --> 00:04:09,840
configure a lot

00:04:07,280 --> 00:04:11,760
so i'm as you can imagine traditional

00:04:09,840 --> 00:04:14,080
testing just really covers a smaller

00:04:11,760 --> 00:04:15,280
part of the picture than ever before and

00:04:14,080 --> 00:04:17,519
as part of testing

00:04:15,280 --> 00:04:19,440
i also mean static analysis dynamic

00:04:17,519 --> 00:04:20,560
analysis a lot of the stuff i worked on

00:04:19,440 --> 00:04:22,720
in a past life

00:04:20,560 --> 00:04:24,000
but you know like one of these pixelated

00:04:22,720 --> 00:04:26,479
nodes on the graph

00:04:24,000 --> 00:04:27,680
that's like the scope of everything i

00:04:26,479 --> 00:04:29,120
worked on before

00:04:27,680 --> 00:04:31,040
there's a lot of testing that now

00:04:29,120 --> 00:04:32,320
effectively happens in production with

00:04:31,040 --> 00:04:34,240
um

00:04:32,320 --> 00:04:36,000
with good reason because this is a

00:04:34,240 --> 00:04:38,400
really complicated picture

00:04:36,000 --> 00:04:39,440
and then also something i like to say is

00:04:38,400 --> 00:04:41,840
there's no truth

00:04:39,440 --> 00:04:43,680
only what happened yesterday because

00:04:41,840 --> 00:04:45,440
when you have something that evolved as

00:04:43,680 --> 00:04:46,960
organically as this

00:04:45,440 --> 00:04:48,639
there's um there's some stuff you can

00:04:46,960 --> 00:04:50,720
say like well you know this thing needs

00:04:48,639 --> 00:04:51,919
to do an sms thing and so you call

00:04:50,720 --> 00:04:54,880
twilio for that

00:04:51,919 --> 00:04:56,720
but in terms of how does this perform um

00:04:54,880 --> 00:04:58,240
what's the impact on this user like

00:04:56,720 --> 00:04:59,120
where does the data go there's a lot of

00:04:58,240 --> 00:05:00,960
questions

00:04:59,120 --> 00:05:02,720
that you used to have control over that

00:05:00,960 --> 00:05:05,600
you do not have the same level of

00:05:02,720 --> 00:05:09,520
control or visibility into anymore

00:05:05,600 --> 00:05:11,120
and no surprise most of our tooling was

00:05:09,520 --> 00:05:13,440
built for the other world

00:05:11,120 --> 00:05:14,240
and so the rest of this talk will be how

00:05:13,440 --> 00:05:17,440
do we

00:05:14,240 --> 00:05:19,120
adapt and so if we think about

00:05:17,440 --> 00:05:20,960
you know software engineering lessons

00:05:19,120 --> 00:05:23,680
that gave software engineers of

00:05:20,960 --> 00:05:24,560
yay old a lot of solace and a lot of

00:05:23,680 --> 00:05:28,479
order

00:05:24,560 --> 00:05:30,320
they don't really exist anymore so i'm

00:05:28,479 --> 00:05:31,919
up through you know when i was doing

00:05:30,320 --> 00:05:34,160
internships in college and grad school

00:05:31,919 --> 00:05:36,639
and i was you know in the industry

00:05:34,160 --> 00:05:38,479
um something that people believed in was

00:05:36,639 --> 00:05:40,720
you know debug with a debugger not

00:05:38,479 --> 00:05:42,720
printf that's what debuggers are for

00:05:40,720 --> 00:05:44,160
use type checkers linters and other

00:05:42,720 --> 00:05:45,759
analyzers to help

00:05:44,160 --> 00:05:48,000
you catch preventable errors before

00:05:45,759 --> 00:05:49,919
running your code test your code on

00:05:48,000 --> 00:05:50,880
small examples before running on the

00:05:49,919 --> 00:05:52,960
whole thing

00:05:50,880 --> 00:05:55,280
well when you're in this uh distributed

00:05:52,960 --> 00:05:56,960
system when you have service oriented

00:05:55,280 --> 00:05:57,840
api oriented systems they are

00:05:56,960 --> 00:05:59,759
distributed

00:05:57,840 --> 00:06:01,199
they go cross-application they're

00:05:59,759 --> 00:06:03,199
heterogeneous so

00:06:01,199 --> 00:06:04,880
as a result you're stuck debugging with

00:06:03,199 --> 00:06:06,160
logs you really don't have much better

00:06:04,880 --> 00:06:08,000
than logs in fact

00:06:06,160 --> 00:06:09,280
reconciling where logs came from and

00:06:08,000 --> 00:06:12,000
what order they were made

00:06:09,280 --> 00:06:13,600
that's already a hard enough problem as

00:06:12,000 --> 00:06:15,919
for type checkers linters other

00:06:13,600 --> 00:06:18,720
analyzers these do not exist across

00:06:15,919 --> 00:06:19,440
apis you might say well gene what about

00:06:18,720 --> 00:06:22,479
you know

00:06:19,440 --> 00:06:25,520
my graphql my grpc my my

00:06:22,479 --> 00:06:27,120
statically typed idl um well i counter

00:06:25,520 --> 00:06:29,280
with what happens when you call across

00:06:27,120 --> 00:06:30,800
an api that you don't control

00:06:29,280 --> 00:06:33,120
what happens when you call across the

00:06:30,800 --> 00:06:34,080
legacy api which is an api you do not

00:06:33,120 --> 00:06:37,680
have very much control

00:06:34,080 --> 00:06:40,479
over uh there you go you can

00:06:37,680 --> 00:06:42,319
you can cover a lot of the world with uh

00:06:40,479 --> 00:06:44,880
with nice idles but also

00:06:42,319 --> 00:06:46,639
uh the la there there hasn't been any

00:06:44,880 --> 00:06:48,479
homogenization of idls

00:06:46,639 --> 00:06:50,400
there has not been any homogenization of

00:06:48,479 --> 00:06:52,240
programming languages and i don't expect

00:06:50,400 --> 00:06:52,720
this to happen anytime soon for reasons

00:06:52,240 --> 00:06:54,400
i will

00:06:52,720 --> 00:06:56,240
keep talking about throughout the course

00:06:54,400 --> 00:06:58,319
of this talk and then

00:06:56,240 --> 00:06:59,919
as for testing and production well

00:06:58,319 --> 00:07:01,360
production is not simple

00:06:59,919 --> 00:07:03,039
that's one of the reasons a lot of

00:07:01,360 --> 00:07:06,400
issues don't arise until then

00:07:03,039 --> 00:07:08,720
but if we save uh many uh most

00:07:06,400 --> 00:07:10,639
most of our issues for for these complex

00:07:08,720 --> 00:07:13,599
cases where it's hard to isolate

00:07:10,639 --> 00:07:15,120
uh any issue in a clean way well we're

00:07:13,599 --> 00:07:18,479
spending a lot more time

00:07:15,120 --> 00:07:18,479
testing than we could be

00:07:19,599 --> 00:07:23,280
so you're probably at this conference

00:07:21,680 --> 00:07:24,479
because you feel like developer

00:07:23,280 --> 00:07:25,120
experience should be better and

00:07:24,479 --> 00:07:27,360
programming

00:07:25,120 --> 00:07:28,960
should be more delightful so i probably

00:07:27,360 --> 00:07:31,199
do not need to tell you this

00:07:28,960 --> 00:07:32,800
but what happens when developers uh get

00:07:31,199 --> 00:07:35,039
left behind by their tools

00:07:32,800 --> 00:07:36,240
is life is very hard so there's this

00:07:35,039 --> 00:07:38,000
nice graph on the left

00:07:36,240 --> 00:07:39,759
based on an outdated notion of the

00:07:38,000 --> 00:07:40,400
software development life cycle that i

00:07:39,759 --> 00:07:44,000
will

00:07:40,400 --> 00:07:46,960
um i will talk more about shortly

00:07:44,000 --> 00:07:48,560
but basically the the later you find a

00:07:46,960 --> 00:07:50,960
bug the harder it is

00:07:48,560 --> 00:07:52,639
for the company you know that like all

00:07:50,960 --> 00:07:54,000
these all these diagrams are based on

00:07:52,639 --> 00:07:55,919
cost to the company

00:07:54,000 --> 00:07:58,400
but it's also very very hard on the

00:07:55,919 --> 00:08:00,080
developer so if developers cannot figure

00:07:58,400 --> 00:08:01,199
out if a change will take down their app

00:08:00,080 --> 00:08:03,120
so if a change will

00:08:01,199 --> 00:08:04,720
cause some sort of breakage will cause

00:08:03,120 --> 00:08:06,240
some sort of performance bottleneck will

00:08:04,720 --> 00:08:08,639
cause some sort of issues

00:08:06,240 --> 00:08:10,160
then issues get uncovered later and they

00:08:08,639 --> 00:08:12,479
take longer to fix

00:08:10,160 --> 00:08:14,000
and what this also means is that issues

00:08:12,479 --> 00:08:16,000
are more painful to fix

00:08:14,000 --> 00:08:17,360
since the context has gotten paged out

00:08:16,000 --> 00:08:19,280
so it's not just okay

00:08:17,360 --> 00:08:20,800
the developer working on this bug is now

00:08:19,280 --> 00:08:24,720
working on something else

00:08:20,800 --> 00:08:27,280
but when ops comes to dev and says hey

00:08:24,720 --> 00:08:28,160
you know sights down there's a cascading

00:08:27,280 --> 00:08:30,400
failure

00:08:28,160 --> 00:08:31,840
like there is no code change involved in

00:08:30,400 --> 00:08:33,039
that like the code change that

00:08:31,840 --> 00:08:34,479
introduced the bug could have happened a

00:08:33,039 --> 00:08:36,000
really long time ago all you're getting

00:08:34,479 --> 00:08:38,959
are logs of okay this

00:08:36,000 --> 00:08:40,719
this network trace happened here this

00:08:38,959 --> 00:08:41,200
thing happened here this went down this

00:08:40,719 --> 00:08:43,919
is still

00:08:41,200 --> 00:08:44,720
up and so there's a lot of forensic

00:08:43,919 --> 00:08:46,399
mapping

00:08:44,720 --> 00:08:48,399
that developers need to do in their

00:08:46,399 --> 00:08:50,080
heads right now because not only is

00:08:48,399 --> 00:08:50,800
there not the context of when you wrote

00:08:50,080 --> 00:08:54,080
the bug

00:08:50,800 --> 00:08:55,360
like the the code and the code changes

00:08:54,080 --> 00:08:57,760
and everything that was going on then

00:08:55,360 --> 00:09:00,720
have been taken out of context

00:08:57,760 --> 00:09:02,640
and so what this also means is uh you

00:09:00,720 --> 00:09:04,320
probably all know roadmaps become less

00:09:02,640 --> 00:09:06,560
predictable

00:09:04,320 --> 00:09:08,000
and then whenever things become less

00:09:06,560 --> 00:09:09,920
predictable and people want

00:09:08,000 --> 00:09:12,880
more predictability what happens is

00:09:09,920 --> 00:09:15,120
caution so developers use an update apis

00:09:12,880 --> 00:09:16,959
with more caution and i don't know about

00:09:15,120 --> 00:09:18,560
you but i got into programming so i was

00:09:16,959 --> 00:09:19,040
like you can write as much code as you

00:09:18,560 --> 00:09:22,640
want

00:09:19,040 --> 00:09:24,399
as often as you want all the time and so

00:09:22,640 --> 00:09:26,560
if you are told to be cautious about

00:09:24,399 --> 00:09:28,240
this stuff well development is not

00:09:26,560 --> 00:09:28,880
delightful anymore you're spending a lot

00:09:28,240 --> 00:09:31,440
of your time

00:09:28,880 --> 00:09:37,040
trying to find bugs life is just not as

00:09:31,440 --> 00:09:39,360
fun as it could be

00:09:37,040 --> 00:09:40,640
and so now we're going to talk about how

00:09:39,360 --> 00:09:43,040
tools

00:09:40,640 --> 00:09:45,360
can do a better job of meeting software

00:09:43,040 --> 00:09:47,839
development where it is today

00:09:45,360 --> 00:09:50,640
and how we can make programming more

00:09:47,839 --> 00:09:53,839
delightful again

00:09:50,640 --> 00:09:55,519
so we'll start by just

00:09:53,839 --> 00:09:57,519
taking down the building and shipping

00:09:55,519 --> 00:09:59,040
myth so you know people are like yeah

00:09:57,519 --> 00:10:00,640
you build then you ship this is where

00:09:59,040 --> 00:10:02,640
shrink wrap software we have not shrink

00:10:00,640 --> 00:10:05,200
graph software for a really long time

00:10:02,640 --> 00:10:07,040
so you know to to speak in the language

00:10:05,200 --> 00:10:08,640
of the young people these days how it

00:10:07,040 --> 00:10:10,240
started was we had requirements and

00:10:08,640 --> 00:10:11,600
analysis we had design we had

00:10:10,240 --> 00:10:12,480
development we had testing we had

00:10:11,600 --> 00:10:14,200
maintenance

00:10:12,480 --> 00:10:16,240
and you know this is left over from the

00:10:14,200 --> 00:10:18,000
waterfall model where

00:10:16,240 --> 00:10:20,079
you know we built software like we built

00:10:18,000 --> 00:10:21,519
bridges but very quickly people realize

00:10:20,079 --> 00:10:23,360
software is different from bridges we

00:10:21,519 --> 00:10:25,519
can update software all the time

00:10:23,360 --> 00:10:27,200
and in fact we don't even need to plan

00:10:25,519 --> 00:10:29,360
what software we built and an advantage

00:10:27,200 --> 00:10:31,279
of software is updating it all the time

00:10:29,360 --> 00:10:32,880
and so essentially what's happened is

00:10:31,279 --> 00:10:35,200
for requirements and analysis

00:10:32,880 --> 00:10:36,720
what is expected behavior anymore

00:10:35,200 --> 00:10:37,600
software is really a process of

00:10:36,720 --> 00:10:39,360
iteration

00:10:37,600 --> 00:10:40,640
you can build software like this but not

00:10:39,360 --> 00:10:42,399
bridges um

00:10:40,640 --> 00:10:45,120
maybe not all software maybe not our

00:10:42,399 --> 00:10:48,320
voting machines side note anyway

00:10:45,120 --> 00:10:50,399
um as for design design has become much

00:10:48,320 --> 00:10:51,440
less top-down and much more organic than

00:10:50,399 --> 00:10:53,600
ever before

00:10:51,440 --> 00:10:55,920
development cycles are shorter testing

00:10:53,600 --> 00:10:58,480
has decreased in scope because it's just

00:10:55,920 --> 00:11:00,480
honestly not as effective in these new

00:10:58,480 --> 00:11:03,279
kinds of architectures and so

00:11:00,480 --> 00:11:05,600
maintenance becomes a really fun step

00:11:03,279 --> 00:11:07,440
and it's more complex than ever

00:11:05,600 --> 00:11:09,519
and so how it's going is that

00:11:07,440 --> 00:11:10,959
development happens in a decentralized

00:11:09,519 --> 00:11:13,040
way at high speed it's just like you

00:11:10,959 --> 00:11:14,399
know code flying everywhere or people

00:11:13,040 --> 00:11:17,839
want to at least

00:11:14,399 --> 00:11:20,560
um at least it's uh the development to

00:11:17,839 --> 00:11:22,720
planning ratio is is very high um

00:11:20,560 --> 00:11:24,640
testing still happens there's still qa

00:11:22,720 --> 00:11:26,079
but the the scope of that is becoming

00:11:24,640 --> 00:11:29,440
increasingly limited

00:11:26,079 --> 00:11:30,880
um and i think that a lot of qa has also

00:11:29,440 --> 00:11:32,560
moved to like let's

00:11:30,880 --> 00:11:34,480
let's test everything at the same time

00:11:32,560 --> 00:11:35,760
in a non-traditional like using testing

00:11:34,480 --> 00:11:39,040
techniques way

00:11:35,760 --> 00:11:41,040
um a lot of testing happens in prod now

00:11:39,040 --> 00:11:44,000
um because like the the gap between

00:11:41,040 --> 00:11:46,800
development and prod is just like

00:11:44,000 --> 00:11:48,959
development to prod immediately analysis

00:11:46,800 --> 00:11:50,880
is often now post hoc so programming by

00:11:48,959 --> 00:11:52,240
observation is a term someone told me

00:11:50,880 --> 00:11:53,760
the other day but you know

00:11:52,240 --> 00:11:55,360
instead of analyzing this is how we

00:11:53,760 --> 00:11:56,000
think our system will behave and should

00:11:55,360 --> 00:11:59,279
behave before

00:11:56,000 --> 00:12:01,600
it happens we uh we watch our system

00:11:59,279 --> 00:12:02,480
after things happen and take some notes

00:12:01,600 --> 00:12:05,279
and then uh

00:12:02,480 --> 00:12:07,440
maintenance is full of uh it's a

00:12:05,279 --> 00:12:09,519
minefield it's full of surprises full of

00:12:07,440 --> 00:12:12,480
places where things can go wrong

00:12:09,519 --> 00:12:13,200
and so this is workable like people are

00:12:12,480 --> 00:12:15,839
surviving

00:12:13,200 --> 00:12:17,839
a lot of software is getting created in

00:12:15,839 --> 00:12:20,560
this environment but it's really not

00:12:17,839 --> 00:12:21,040
optimal and the reason it's not optimal

00:12:20,560 --> 00:12:24,000
is

00:12:21,040 --> 00:12:26,160
like i said before our notion of testing

00:12:24,000 --> 00:12:29,279
was for a really different time

00:12:26,160 --> 00:12:30,880
and uh there have been observability

00:12:29,279 --> 00:12:32,639
observability tools that have come in

00:12:30,880 --> 00:12:34,720
and said well hey look you know

00:12:32,639 --> 00:12:37,120
testing happens in prod now you know

00:12:34,720 --> 00:12:39,120
things everything happens across apis

00:12:37,120 --> 00:12:40,880
but they've taken you know the idea of

00:12:39,120 --> 00:12:43,360
testing and then applied it

00:12:40,880 --> 00:12:45,279
to um to this new world but in the new

00:12:43,360 --> 00:12:46,959
world like we we just do not have the

00:12:45,279 --> 00:12:47,680
control that we do we can't instrument

00:12:46,959 --> 00:12:49,680
the code we

00:12:47,680 --> 00:12:50,880
like we don't have control over certain

00:12:49,680 --> 00:12:54,639
performance things

00:12:50,880 --> 00:12:56,320
and so i um i would say

00:12:54,639 --> 00:12:58,000
it's it's high time to rethink the

00:12:56,320 --> 00:12:59,200
software development life cycle

00:12:58,000 --> 00:13:01,040
and there are there are a few things

00:12:59,200 --> 00:13:03,040
that i believe we should do for that

00:13:01,040 --> 00:13:05,040
so in terms of how it's going well

00:13:03,040 --> 00:13:07,519
development happens without the context

00:13:05,040 --> 00:13:08,399
of emergent behaviors of the code

00:13:07,519 --> 00:13:10,079
testing

00:13:08,399 --> 00:13:11,680
is only able to test functions in

00:13:10,079 --> 00:13:13,279
isolation really like the

00:13:11,680 --> 00:13:14,800
the emergent behaviors part really

00:13:13,279 --> 00:13:16,560
missing now uh

00:13:14,800 --> 00:13:18,639
testing in prod serves many different

00:13:16,560 --> 00:13:20,079
purposes much of it which

00:13:18,639 --> 00:13:22,000
i believe should be served by the

00:13:20,079 --> 00:13:24,000
development and testing phases

00:13:22,000 --> 00:13:25,040
analysis happens by reading through logs

00:13:24,000 --> 00:13:27,600
and traces there's

00:13:25,040 --> 00:13:29,519
there's not very much uh high level

00:13:27,600 --> 00:13:30,639
structure and high level insight that's

00:13:29,519 --> 00:13:33,279
happening there

00:13:30,639 --> 00:13:34,639
and uh maintenance more complex than

00:13:33,279 --> 00:13:37,680
ever

00:13:34,639 --> 00:13:39,120
so how it could be going is you can

00:13:37,680 --> 00:13:42,079
imagine a world

00:13:39,120 --> 00:13:43,360
in which development gets a lot more

00:13:42,079 --> 00:13:46,160
feedback from prod

00:13:43,360 --> 00:13:47,600
than it does today and so right now

00:13:46,160 --> 00:13:49,680
development's just like all right i do

00:13:47,600 --> 00:13:51,360
some stuff i write some code source code

00:13:49,680 --> 00:13:52,079
increasingly disconnected from what's

00:13:51,360 --> 00:13:54,320
going on

00:13:52,079 --> 00:13:56,000
but what if you could get at the api

00:13:54,320 --> 00:13:57,120
graph that effectively happens instead

00:13:56,000 --> 00:13:59,360
of getting the call graph with your

00:13:57,120 --> 00:14:01,199
debugger what if during development time

00:13:59,360 --> 00:14:02,959
you could get information from prodback

00:14:01,199 --> 00:14:04,240
same with tests right now test is very

00:14:02,959 --> 00:14:05,519
limited in scope because the

00:14:04,240 --> 00:14:07,600
interconnects

00:14:05,519 --> 00:14:09,120
between uh between the different

00:14:07,600 --> 00:14:10,079
services between different components is

00:14:09,120 --> 00:14:12,000
just really hard

00:14:10,079 --> 00:14:13,839
but what if you had a better way to test

00:14:12,000 --> 00:14:15,920
that feeding data back from prod

00:14:13,839 --> 00:14:18,000
and testing in prod that can be much

00:14:15,920 --> 00:14:19,680
much smaller much cleaner you can

00:14:18,000 --> 00:14:21,040
keep the test things for tests where you

00:14:19,680 --> 00:14:22,800
can simplify things

00:14:21,040 --> 00:14:24,959
but what if prod also got fed

00:14:22,800 --> 00:14:26,639
information from from the code changes

00:14:24,959 --> 00:14:28,639
from all that stuff so you're not

00:14:26,639 --> 00:14:30,160
you're not just like looking through

00:14:28,639 --> 00:14:31,120
logs and traces you've got a little more

00:14:30,160 --> 00:14:33,440
context

00:14:31,120 --> 00:14:35,519
and so what if analysis maintenance had

00:14:33,440 --> 00:14:36,959
both the context of here's the structure

00:14:35,519 --> 00:14:39,120
we have from all of this

00:14:36,959 --> 00:14:40,639
and here's some information that we we

00:14:39,120 --> 00:14:42,560
piped all the way from development

00:14:40,639 --> 00:14:44,160
and testing which we maybe were able to

00:14:42,560 --> 00:14:46,399
do because we had that structure then

00:14:44,160 --> 00:14:46,399
too

00:14:46,959 --> 00:14:50,720
so this is very abstract so i'm not

00:14:49,360 --> 00:14:51,839
going to spend very much time on it but

00:14:50,720 --> 00:14:53,519
the high level is

00:14:51,839 --> 00:14:55,199
there's really this gap between

00:14:53,519 --> 00:14:57,040
development testing source code

00:14:55,199 --> 00:14:58,480
and then like prod this is what really

00:14:57,040 --> 00:15:00,880
happens behavioral stuff

00:14:58,480 --> 00:15:02,160
like what what if we could have a better

00:15:00,880 --> 00:15:04,320
connection of the two

00:15:02,160 --> 00:15:06,320
and kind of pipe data across the whole

00:15:04,320 --> 00:15:08,800
thing so that we can catch

00:15:06,320 --> 00:15:09,440
issues sooner we can catch issues better

00:15:08,800 --> 00:15:12,240
and we can

00:15:09,440 --> 00:15:12,720
fix them faster and again this was

00:15:12,240 --> 00:15:14,240
really

00:15:12,720 --> 00:15:16,160
really abstract so i'm going to try to

00:15:14,240 --> 00:15:18,480
get concrete really quickly

00:15:16,160 --> 00:15:19,920
but in my view what it takes to bridge

00:15:18,480 --> 00:15:21,680
the test production gap

00:15:19,920 --> 00:15:23,360
is there needs to be a better way to

00:15:21,680 --> 00:15:24,560
connect code changes with behavioral

00:15:23,360 --> 00:15:26,320
changes

00:15:24,560 --> 00:15:28,000
there also needs a way uh there needs to

00:15:26,320 --> 00:15:29,839
be a way to automatically help us

00:15:28,000 --> 00:15:31,199
understand the emergent behaviors across

00:15:29,839 --> 00:15:33,360
services and apis

00:15:31,199 --> 00:15:34,959
so right now the emergent behavior so

00:15:33,360 --> 00:15:36,560
like where does this piece of data go is

00:15:34,959 --> 00:15:37,199
there a product is there a performance

00:15:36,560 --> 00:15:38,720
bottleneck

00:15:37,199 --> 00:15:40,320
is there going to be a cascading failure

00:15:38,720 --> 00:15:41,199
these are all what i call emergent

00:15:40,320 --> 00:15:43,440
behaviors

00:15:41,199 --> 00:15:44,240
and these are opaque to developers until

00:15:43,440 --> 00:15:45,920
they happen

00:15:44,240 --> 00:15:47,440
and after they happen why they happen

00:15:45,920 --> 00:15:48,639
they don't get like a map that's like

00:15:47,440 --> 00:15:49,839
all right let's talk to that and let's

00:15:48,639 --> 00:15:51,600
talk to that and this is how everything

00:15:49,839 --> 00:15:53,279
fits together here's what's happening

00:15:51,600 --> 00:15:55,440
it's just like here's a dump here's the

00:15:53,279 --> 00:15:57,440
temple logs here's a number traces

00:15:55,440 --> 00:15:59,440
um and so can we do better there and

00:15:57,440 --> 00:16:01,680
then finally can we work across

00:15:59,440 --> 00:16:02,800
a heterogeneous set of components so as

00:16:01,680 --> 00:16:04,720
i mentioned before

00:16:02,800 --> 00:16:05,920
i believe any system of sufficient

00:16:04,720 --> 00:16:08,079
maturity

00:16:05,920 --> 00:16:10,720
there's been an evolution of tools like

00:16:08,079 --> 00:16:11,199
maybe graphql is the idl today but then

00:16:10,720 --> 00:16:13,839
you know

00:16:11,199 --> 00:16:15,199
protocols evolve communities evolve

00:16:13,839 --> 00:16:16,480
there's some idl that's better in the

00:16:15,199 --> 00:16:17,920
future

00:16:16,480 --> 00:16:20,639
there's always going to be different

00:16:17,920 --> 00:16:23,519
tools and so how do we get something

00:16:20,639 --> 00:16:26,720
that actually embraces heterogeneity by

00:16:23,519 --> 00:16:26,720
meeting the tools where they are

00:16:27,839 --> 00:16:30,959
and so this brings me to the last and

00:16:29,519 --> 00:16:32,800
shortest part of my talk

00:16:30,959 --> 00:16:34,800
which is how i have been solving this

00:16:32,800 --> 00:16:36,240
problem for the last few years

00:16:34,800 --> 00:16:37,839
which is with structure and

00:16:36,240 --> 00:16:40,639
observability so

00:16:37,839 --> 00:16:41,199
what i've been doing at akita is turning

00:16:40,639 --> 00:16:43,680
api

00:16:41,199 --> 00:16:44,720
traffic into api models for insights

00:16:43,680 --> 00:16:47,360
diffs and more

00:16:44,720 --> 00:16:47,839
so what akita does at a very high quick

00:16:47,360 --> 00:16:50,160
level

00:16:47,839 --> 00:16:52,399
is we watch api traffic across your

00:16:50,160 --> 00:16:54,800
environment so in test and prod

00:16:52,399 --> 00:16:56,480
we build models out of that traffic so

00:16:54,800 --> 00:16:59,279
these models represent your endpoints

00:16:56,480 --> 00:17:01,519
your data types your data formats etc

00:16:59,279 --> 00:17:02,399
and then this feeds back into

00:17:01,519 --> 00:17:05,199
development

00:17:02,399 --> 00:17:06,000
so we give developers here's your diffs

00:17:05,199 --> 00:17:07,919
here's how

00:17:06,000 --> 00:17:09,600
different apis are talking to each other

00:17:07,919 --> 00:17:11,280
here's your api graph

00:17:09,600 --> 00:17:13,280
uh is what we're building towards as

00:17:11,280 --> 00:17:15,520
opposed to your call graph

00:17:13,280 --> 00:17:17,520
and then um if you want a plan

00:17:15,520 --> 00:17:20,079
developers can also feed us specs

00:17:17,520 --> 00:17:20,959
and do things there now i'll give a very

00:17:20,079 --> 00:17:22,400
quick demo

00:17:20,959 --> 00:17:23,679
and then hopefully this will ground

00:17:22,400 --> 00:17:24,400
everything else i've been saying a

00:17:23,679 --> 00:17:26,480
little more

00:17:24,400 --> 00:17:28,559
so first i'll just show the generation

00:17:26,480 --> 00:17:29,440
of a single akita model by watching

00:17:28,559 --> 00:17:31,200
traffic

00:17:29,440 --> 00:17:32,480
so here i have a docker container of

00:17:31,200 --> 00:17:35,200
akibox little

00:17:32,480 --> 00:17:36,160
dropbox like demo system what i'm going

00:17:35,200 --> 00:17:40,480
to do

00:17:36,160 --> 00:17:42,559
is invoke akita to listen to traffic

00:17:40,480 --> 00:17:43,600
going to that container so there are a

00:17:42,559 --> 00:17:46,480
few ways that

00:17:43,600 --> 00:17:47,679
akita watches apis one is as an agent

00:17:46,480 --> 00:17:50,160
watching traffic

00:17:47,679 --> 00:17:50,880
one is alongside proxies or alongside

00:17:50,160 --> 00:17:52,480
browsers

00:17:50,880 --> 00:17:56,000
which can generate hard files from

00:17:52,480 --> 00:17:58,880
watching traffic and then akita also

00:17:56,000 --> 00:18:00,640
can integrate with integration tests by

00:17:58,880 --> 00:18:02,640
looking at the traffic going to the test

00:18:00,640 --> 00:18:04,160
framework box

00:18:02,640 --> 00:18:07,280
so here i'm just going to send a few

00:18:04,160 --> 00:18:10,240
tests to akibox

00:18:07,280 --> 00:18:11,679
and so this agent can run along you know

00:18:10,240 --> 00:18:13,440
standalone triggered by you

00:18:11,679 --> 00:18:15,200
it can run as part of ci on every pull

00:18:13,440 --> 00:18:16,240
request there's a variety of ways that

00:18:15,200 --> 00:18:18,960
it can run

00:18:16,240 --> 00:18:19,840
so here i show the api model that akita

00:18:18,960 --> 00:18:22,240
generated

00:18:19,840 --> 00:18:23,280
so akita gives a summary of the

00:18:22,240 --> 00:18:25,919
different kinds

00:18:23,280 --> 00:18:27,360
of information you might want to know

00:18:25,919 --> 00:18:28,400
for instance where you have bearer

00:18:27,360 --> 00:18:30,080
tokens

00:18:28,400 --> 00:18:32,320
and then you can drill down into each

00:18:30,080 --> 00:18:35,200
endpoint for for more information

00:18:32,320 --> 00:18:36,559
going to just very quickly make a change

00:18:35,200 --> 00:18:38,720
uh

00:18:36,559 --> 00:18:40,240
from international to us phone number to

00:18:38,720 --> 00:18:42,160
show this is the kind of bug that people

00:18:40,240 --> 00:18:43,120
have told us causes cascading failures

00:18:42,160 --> 00:18:45,039
in the past

00:18:43,120 --> 00:18:47,840
and it's often very hard to catch it's

00:18:45,039 --> 00:18:50,000
very hard to catch with a typed idl

00:18:47,840 --> 00:18:52,960
and what i'm going to do is show how we

00:18:50,000 --> 00:18:55,039
catch this using akita

00:18:52,960 --> 00:18:57,760
so i'm just going to make a quick commit

00:18:55,039 --> 00:19:00,320
just a small change no big deal

00:18:57,760 --> 00:19:00,320
and then

00:19:01,120 --> 00:19:05,280
we're gonna make a pull request all

00:19:03,360 --> 00:19:07,840
right here we see that akita

00:19:05,280 --> 00:19:09,520
is done running has left a comment on

00:19:07,840 --> 00:19:11,679
our pull request saying look

00:19:09,520 --> 00:19:12,880
one endpoint changed this user's

00:19:11,679 --> 00:19:14,720
endpoint and

00:19:12,880 --> 00:19:16,640
the u.s phone number was added the

00:19:14,720 --> 00:19:20,000
international phone number was removed

00:19:16,640 --> 00:19:23,760
and we can also see this change happen

00:19:20,000 --> 00:19:25,679
on the akita console here

00:19:23,760 --> 00:19:27,840
and so additionally on the akita console

00:19:25,679 --> 00:19:30,080
akita summarizes the sensitive

00:19:27,840 --> 00:19:31,919
format information so this wasn't a very

00:19:30,080 --> 00:19:32,240
long talk but i hope what you got out of

00:19:31,919 --> 00:19:34,559
it

00:19:32,240 --> 00:19:35,440
is we need different kinds of developer

00:19:34,559 --> 00:19:38,240
tools to have

00:19:35,440 --> 00:19:38,960
truly good truly empowered developer

00:19:38,240 --> 00:19:41,919
experience

00:19:38,960 --> 00:19:42,640
in this new era where software is

00:19:41,919 --> 00:19:44,720
complex

00:19:42,640 --> 00:19:45,679
it's heterogeneous and we're spending a

00:19:44,720 --> 00:19:47,919
lot of time

00:19:45,679 --> 00:19:49,760
operating other software this lets us

00:19:47,919 --> 00:19:51,440
fly but we've also given up

00:19:49,760 --> 00:19:53,840
a ton more control than we have in the

00:19:51,440 --> 00:19:55,120
past i'd love to talk more about this so

00:19:53,840 --> 00:19:56,799
find me on twitter

00:19:55,120 --> 00:19:58,960
find me on twitch i have a weekly

00:19:56,799 --> 00:20:01,360
programming tools live stream there

00:19:58,960 --> 00:20:03,600
and you can always find me on the akita

00:20:01,360 --> 00:20:06,320
beta so if you want a surefire way to

00:20:03,600 --> 00:20:08,080
hear from me every day work on

00:20:06,320 --> 00:20:09,840
structured observability with me

00:20:08,080 --> 00:20:11,520
tell us how we can help you with your

00:20:09,840 --> 00:20:12,720
api breaking changes structured

00:20:11,520 --> 00:20:14,559
observability with me

00:20:12,720 --> 00:20:16,559
tell us how we can help you with your

00:20:14,559 --> 00:20:21,840
api breaking changes tell us how we can

00:20:16,559 --> 00:20:21,840
help you understand your apis better

00:20:21,919 --> 00:20:24,000

YouTube URL: https://www.youtube.com/watch?v=0nrd5-9Lf7E


