Title: Building Supabase Storage. DevX, performance, security - choose three â€“ Inian Parameshwaran
Publication date: 2021-04-29
Playlist: DevX Conf
Description: 
	Balancing Developer Experience with other concerns like performance and security is not straightforward. For example, you might be able to expose a simpler API at the cost of system performance. This talk goes into how we balance these concerns when we launched Supabase Storage.

Supabase Storage is an object storage service that tightly integrates with Postgres and leverages our existing Auth System elegantly. There are a lot of interesting design choices we had to make along the way to build the storage middleware and the client APIs. We explore why we built yet another object storage system and the pitfalls we avoided by evaluating prior work. The architecture we settled on also had the benefit of being extensible to more storage backends in the future. We also put in a lot of thought in making the storage client APIs simple and familiar.

About DevX Conf:
DevX Conf is a two-day virtual conference. It's a space where creators collaborate, listen, discuss and declutter our workflows, toolchains, and minds. To improve developer experience. Organized by Gitpod.
https://devxconf.org/
Captions: 
	00:00:14,240 --> 00:00:17,600
hi everyone

00:00:15,360 --> 00:00:19,279
i'm indian i'm a senior software

00:00:17,600 --> 00:00:21,680
engineer at superbase

00:00:19,279 --> 00:00:23,119
and you can follow me on twitter at ever

00:00:21,680 --> 00:00:25,039
confused guy

00:00:23,119 --> 00:00:26,960
today i'm going to be talking about

00:00:25,039 --> 00:00:27,439
superbase storage how we built the

00:00:26,960 --> 00:00:30,080
product

00:00:27,439 --> 00:00:31,920
and how we balance different aspects of

00:00:30,080 --> 00:00:32,880
developer experience performance and

00:00:31,920 --> 00:00:36,160
security

00:00:32,880 --> 00:00:38,719
while building the product

00:00:36,160 --> 00:00:40,559
what is super base super base is an open

00:00:38,719 --> 00:00:42,879
source firebase alternative

00:00:40,559 --> 00:00:44,000
when you sign up to super base you get a

00:00:42,879 --> 00:00:47,200
full-fledged postgres

00:00:44,000 --> 00:00:50,640
database and you get the necessary tools

00:00:47,200 --> 00:00:54,800
to build your own authentication flows

00:00:50,640 --> 00:00:56,480
in your website or mobile apps and

00:00:54,800 --> 00:00:58,800
you of course get storage which i'll be

00:00:56,480 --> 00:01:00,640
talking about today and also

00:00:58,800 --> 00:01:02,000
we'll be releasing super bass function

00:01:00,640 --> 00:01:05,039
soon which is our own

00:01:02,000 --> 00:01:05,039
serverless platform

00:01:05,280 --> 00:01:09,439
so super base storage is an object

00:01:06,960 --> 00:01:13,600
storage service anything that's too big

00:01:09,439 --> 00:01:16,560
to directly store in your database like

00:01:13,600 --> 00:01:17,280
images or videos or csv files it's

00:01:16,560 --> 00:01:18,799
better to

00:01:17,280 --> 00:01:20,560
store it in something like an object

00:01:18,799 --> 00:01:23,280
storage service

00:01:20,560 --> 00:01:25,759
and that's what we have built let me

00:01:23,280 --> 00:01:28,400
show you a quick demo of what

00:01:25,759 --> 00:01:29,119
the dashboard to storage looks like so

00:01:28,400 --> 00:01:32,400
this is

00:01:29,119 --> 00:01:34,159
the dashboard we have built

00:01:32,400 --> 00:01:35,600
a way for you to easily explore

00:01:34,159 --> 00:01:37,680
different objects in

00:01:35,600 --> 00:01:40,240
your buckets so you can create new

00:01:37,680 --> 00:01:41,920
buckets you can explore existing buckets

00:01:40,240 --> 00:01:43,360
and we show rich previews of the

00:01:41,920 --> 00:01:45,360
different files

00:01:43,360 --> 00:01:47,360
in the different buckets and we have

00:01:45,360 --> 00:01:48,720
built the ux to be very similar to that

00:01:47,360 --> 00:01:52,560
of a file explorer

00:01:48,720 --> 00:01:54,880
so even if you have not used an object

00:01:52,560 --> 00:01:56,479
storage service before this should feel

00:01:54,880 --> 00:01:58,159
pretty intuitive on what

00:01:56,479 --> 00:02:00,560
are the different capabilities that you

00:01:58,159 --> 00:02:00,560
provide

00:02:05,439 --> 00:02:11,280
so uh before we started building super

00:02:09,360 --> 00:02:13,440
base storage we decided to list down

00:02:11,280 --> 00:02:16,959
what are the constraints that we had

00:02:13,440 --> 00:02:19,360
and the primary thing that we looked at

00:02:16,959 --> 00:02:20,160
was how well an existing solution can

00:02:19,360 --> 00:02:22,720
integrate

00:02:20,160 --> 00:02:25,120
with the super base ecosystem we wanted

00:02:22,720 --> 00:02:28,400
the storage service to integrate well

00:02:25,120 --> 00:02:29,760
with postgres and also our existing cod

00:02:28,400 --> 00:02:33,599
solution that

00:02:29,760 --> 00:02:33,599
we have built out for our users

00:02:34,080 --> 00:02:37,280
the second thing that we looked at was

00:02:36,239 --> 00:02:39,040
to make sure that

00:02:37,280 --> 00:02:42,000
the service that we built or ended up

00:02:39,040 --> 00:02:45,120
using had a pretty small footprint

00:02:42,000 --> 00:02:46,720
superbase has a very generous detail and

00:02:45,120 --> 00:02:50,080
we wanted to make sure that

00:02:46,720 --> 00:02:52,319
storage was one of the services that

00:02:50,080 --> 00:02:53,760
even users in the free tier could use

00:02:52,319 --> 00:02:55,680
and making sure it was small and

00:02:53,760 --> 00:02:58,159
efficient made sure that we could

00:02:55,680 --> 00:03:00,959
add super base storage as a feature to

00:02:58,159 --> 00:03:00,959
all our users

00:03:01,200 --> 00:03:05,599
and of course since multiple users are

00:03:03,680 --> 00:03:06,239
using super base for it to be efficient

00:03:05,599 --> 00:03:09,680
we needed

00:03:06,239 --> 00:03:11,840
a multi-tenant solution and we

00:03:09,680 --> 00:03:14,159
decided that we are primarily going to

00:03:11,840 --> 00:03:16,879
be focused on digital native companies

00:03:14,159 --> 00:03:18,560
which means that as a company we will be

00:03:16,879 --> 00:03:22,319
focusing more on users

00:03:18,560 --> 00:03:24,080
who are using the hosted platform

00:03:22,319 --> 00:03:25,440
or even if they're self-hosting super

00:03:24,080 --> 00:03:26,159
base they are going to be launching

00:03:25,440 --> 00:03:28,239
super base

00:03:26,159 --> 00:03:29,280
themselves in a cloud provider which

00:03:28,239 --> 00:03:32,239
means that we could

00:03:29,280 --> 00:03:34,000
use managed services like s3 or google

00:03:32,239 --> 00:03:37,200
cloud storage to actually store

00:03:34,000 --> 00:03:39,200
the different objects so in the end

00:03:37,200 --> 00:03:41,040
we decided to build our own server again

00:03:39,200 --> 00:03:43,280
spoiler alert but

00:03:41,040 --> 00:03:45,360
before that we evaluated a lot of open

00:03:43,280 --> 00:03:48,560
source

00:03:45,360 --> 00:03:50,879
middlewares like theft swift mineo and

00:03:48,560 --> 00:03:53,920
zenko

00:03:50,879 --> 00:03:55,439
but the main deal breaker was that

00:03:53,920 --> 00:03:57,519
none of these systems integrated

00:03:55,439 --> 00:03:59,760
natively with postgres

00:03:57,519 --> 00:04:00,959
we already launched a full-fledged

00:03:59,760 --> 00:04:03,120
postgres database

00:04:00,959 --> 00:04:04,720
for our users and it made sense to use

00:04:03,120 --> 00:04:08,319
that as the data store

00:04:04,720 --> 00:04:09,519
instead of say hcd which menu requires

00:04:08,319 --> 00:04:12,959
in multi-user mode

00:04:09,519 --> 00:04:15,120
or mongodb and kafka which requires

00:04:12,959 --> 00:04:17,680
uh which is required by cinco for its

00:04:15,120 --> 00:04:19,840
full operation

00:04:17,680 --> 00:04:21,600
and the other problem that we had with

00:04:19,840 --> 00:04:23,040
existing systems was that they came with

00:04:21,600 --> 00:04:25,440
their own odd systems

00:04:23,040 --> 00:04:26,320
there is no elegant way to map super

00:04:25,440 --> 00:04:29,440
base usage

00:04:26,320 --> 00:04:33,040
users with same menu users

00:04:29,440 --> 00:04:35,520
and we couldn't find a proper solution

00:04:33,040 --> 00:04:37,280
for this and didn't feel nice to sort of

00:04:35,520 --> 00:04:39,120
throw the problem over to

00:04:37,280 --> 00:04:41,600
developers building on top of super base

00:04:39,120 --> 00:04:43,600
and expect them to figure it out as well

00:04:41,600 --> 00:04:45,840
so we wanted to do something better over

00:04:43,600 --> 00:04:45,840
here

00:04:46,400 --> 00:04:49,600
and there are a lot of features which

00:04:47,680 --> 00:04:50,240
are not directly relevant to our use

00:04:49,600 --> 00:04:52,000
case

00:04:50,240 --> 00:04:53,759
for example features like pit rod

00:04:52,000 --> 00:04:56,000
protection and

00:04:53,759 --> 00:04:57,919
making sure that drives wouldn't fail

00:04:56,000 --> 00:05:01,280
and if a new drive is attached how to

00:04:57,919 --> 00:05:03,600
make use of that new space

00:05:01,280 --> 00:05:04,560
to store your objects all these features

00:05:03,600 --> 00:05:06,800
were not

00:05:04,560 --> 00:05:08,479
uh relevant to us because we decided to

00:05:06,800 --> 00:05:11,199
go with a managed service like

00:05:08,479 --> 00:05:14,080
aws s3 or google cloud storage to

00:05:11,199 --> 00:05:16,400
actually store the different objects

00:05:14,080 --> 00:05:18,320
and some of these solutions were also

00:05:16,400 --> 00:05:21,360
deal breakers because

00:05:18,320 --> 00:05:22,880
we found out there were limits to which

00:05:21,360 --> 00:05:24,639
in terms of the number of packets that

00:05:22,880 --> 00:05:27,840
you could create and so on

00:05:24,639 --> 00:05:30,320
and they weren't aligned with

00:05:27,840 --> 00:05:32,960
the number of users we expected super

00:05:30,320 --> 00:05:32,960
base to have

00:05:34,800 --> 00:05:38,000
so this is the final architecture that

00:05:36,400 --> 00:05:39,919
we came up with

00:05:38,000 --> 00:05:41,520
it consists of three different layers

00:05:39,919 --> 00:05:42,880
the storage front end

00:05:41,520 --> 00:05:44,320
is the dashboard that i showed you

00:05:42,880 --> 00:05:45,280
before and the different client

00:05:44,320 --> 00:05:48,400
libraries

00:05:45,280 --> 00:05:51,440
with which you can integrate with the

00:05:48,400 --> 00:05:54,639
api server the api server itself has

00:05:51,440 --> 00:05:56,400
an api gateway cong which we use across

00:05:54,639 --> 00:05:58,160
our super base ecosystem

00:05:56,400 --> 00:05:59,919
and the api server also talks to

00:05:58,160 --> 00:06:04,400
postgres

00:05:59,919 --> 00:06:07,280
where we store our object metadata like

00:06:04,400 --> 00:06:09,039
when object is stored who uploaded it at

00:06:07,280 --> 00:06:11,199
what time and so on

00:06:09,039 --> 00:06:13,280
the object itself is stored in a managed

00:06:11,199 --> 00:06:17,360
service like s3

00:06:13,280 --> 00:06:19,680
or backplace or wasabi and so on

00:06:17,360 --> 00:06:21,199
even though we decided to build our own

00:06:19,680 --> 00:06:24,479
object storage service

00:06:21,199 --> 00:06:27,440
we looked at prior work to see

00:06:24,479 --> 00:06:30,160
how we can better change the defaults to

00:06:27,440 --> 00:06:31,680
suit users building on top of super base

00:06:30,160 --> 00:06:33,759
and one of the things that we realized

00:06:31,680 --> 00:06:37,600
is that having a max upload

00:06:33,759 --> 00:06:38,400
size of say 160 gb of s3 didn't make

00:06:37,600 --> 00:06:40,960
sense

00:06:38,400 --> 00:06:41,600
for super bass users most of them are

00:06:40,960 --> 00:06:43,680
building

00:06:41,600 --> 00:06:44,880
websites or mobile applications and

00:06:43,680 --> 00:06:47,840
having a 160 gb

00:06:44,880 --> 00:06:50,560
file is rarely what you need so we

00:06:47,840 --> 00:06:54,080
decided to cap the upload size to

00:06:50,560 --> 00:06:58,000
50 mb and another thing that we changed

00:06:54,080 --> 00:07:01,759
the default for uh is the cache time

00:06:58,000 --> 00:07:02,400
so any file that you upload to s3 by

00:07:01,759 --> 00:07:04,960
default

00:07:02,400 --> 00:07:07,039
does not have a cache time attached to

00:07:04,960 --> 00:07:08,000
it which leads to very poor performance

00:07:07,039 --> 00:07:10,240
if you are using it

00:07:08,000 --> 00:07:11,520
in your mobile apps and websites because

00:07:10,240 --> 00:07:15,199
the client has to

00:07:11,520 --> 00:07:17,199
revalidate with the s3 server every time

00:07:15,199 --> 00:07:18,639
if the object has changed or not for

00:07:17,199 --> 00:07:21,919
superbase you get

00:07:18,639 --> 00:07:24,800
a default cache time of one hour which

00:07:21,919 --> 00:07:25,599
you can of course change when you upload

00:07:24,800 --> 00:07:28,000
the object

00:07:25,599 --> 00:07:30,400
to a different time depending on your

00:07:28,000 --> 00:07:32,240
use case

00:07:30,400 --> 00:07:34,000
this is an example where we try to

00:07:32,240 --> 00:07:34,880
balance performance and developer

00:07:34,000 --> 00:07:36,400
experience

00:07:34,880 --> 00:07:38,960
when we started building super base

00:07:36,400 --> 00:07:40,800
storage this is what the

00:07:38,960 --> 00:07:43,520
simplified version of the schema looked

00:07:40,800 --> 00:07:44,080
like we had two tables buckets and

00:07:43,520 --> 00:07:47,599
objects

00:07:44,080 --> 00:07:50,960
each of them had a uuid

00:07:47,599 --> 00:07:52,879
and the objects table contains a foreign

00:07:50,960 --> 00:07:54,960
key to the buckets table

00:07:52,879 --> 00:07:56,080
but we realized the most common access

00:07:54,960 --> 00:07:59,759
pattern did not

00:07:56,080 --> 00:08:01,599
really involve the uuid at all

00:07:59,759 --> 00:08:04,080
it directly involves the name of the

00:08:01,599 --> 00:08:06,319
bucket and the object name

00:08:04,080 --> 00:08:07,280
and this also leads to inefficient

00:08:06,319 --> 00:08:11,440
queries because

00:08:07,280 --> 00:08:14,319
every time someone accesses slash avatar

00:08:11,440 --> 00:08:14,720
jpg we need to join both of these tables

00:08:14,319 --> 00:08:16,800
to

00:08:14,720 --> 00:08:17,759
get the relevant row in the objects

00:08:16,800 --> 00:08:20,800
table

00:08:17,759 --> 00:08:22,720
and we decided to just use

00:08:20,800 --> 00:08:24,000
the bucket name as the primary key for

00:08:22,720 --> 00:08:27,280
the buckets table

00:08:24,000 --> 00:08:29,840
and drop the uuid com completely

00:08:27,280 --> 00:08:30,879
this made it easier to write queries

00:08:29,840 --> 00:08:33,919
which

00:08:30,879 --> 00:08:36,320
just use the bucket name

00:08:33,919 --> 00:08:36,959
and it's faster because you can get the

00:08:36,320 --> 00:08:41,599
relevant

00:08:36,959 --> 00:08:43,519
row by just accessing the object table

00:08:41,599 --> 00:08:45,839
we also had to balance security and

00:08:43,519 --> 00:08:48,399
developer experience

00:08:45,839 --> 00:08:50,160
from prior experience we realized that

00:08:48,399 --> 00:08:52,880
it was pretty easy to

00:08:50,160 --> 00:08:54,880
leave your s3 bucket open to the public

00:08:52,880 --> 00:08:55,920
so in super base buckets are not public

00:08:54,880 --> 00:08:58,240
by default

00:08:55,920 --> 00:08:59,600
for each and every object that you want

00:08:58,240 --> 00:09:01,519
to expose publicly

00:08:59,600 --> 00:09:03,680
you have to intentionally create a

00:09:01,519 --> 00:09:05,600
signed url for that object

00:09:03,680 --> 00:09:07,279
uh this makes it harder if you just want

00:09:05,600 --> 00:09:10,000
to host your website

00:09:07,279 --> 00:09:10,880
on superbase and if you want to make the

00:09:10,000 --> 00:09:14,880
entire pop

00:09:10,880 --> 00:09:17,680
bucket public so at some point we might

00:09:14,880 --> 00:09:20,000
expose a way to make this easier to make

00:09:17,680 --> 00:09:22,720
the entire market public but for now

00:09:20,000 --> 00:09:23,279
you need to create signed urls for uh

00:09:22,720 --> 00:09:25,360
every

00:09:23,279 --> 00:09:27,920
object that you want to expose publicly

00:09:25,360 --> 00:09:29,519
and this makes your intention very clear

00:09:27,920 --> 00:09:32,320
as to whether you want the object to be

00:09:29,519 --> 00:09:32,320
public or not

00:09:32,560 --> 00:09:38,080
another decision we had to make was to

00:09:36,320 --> 00:09:40,480
where to store the object metadata

00:09:38,080 --> 00:09:41,680
itself so we could either store it in

00:09:40,480 --> 00:09:43,760
our own internal

00:09:41,680 --> 00:09:45,200
database which we don't expose to the

00:09:43,760 --> 00:09:47,120
user or we can

00:09:45,200 --> 00:09:49,839
store it in the postgres database that

00:09:47,120 --> 00:09:52,240
we provision as part of every product

00:09:49,839 --> 00:09:54,720
project that the user launches

00:09:52,240 --> 00:09:56,560
um we decided to do the latter because

00:09:54,720 --> 00:09:57,279
it gives full control of the data to the

00:09:56,560 --> 00:09:59,760
user

00:09:57,279 --> 00:10:01,360
so even if the user wants to sell for

00:09:59,760 --> 00:10:02,000
super base or move to a different

00:10:01,360 --> 00:10:04,720
provider

00:10:02,000 --> 00:10:06,240
he has full control of the data and also

00:10:04,720 --> 00:10:08,959
users can adapt

00:10:06,240 --> 00:10:09,360
the database to their own workloads by

00:10:08,959 --> 00:10:12,640
say

00:10:09,360 --> 00:10:16,399
adding a new index to the objects table

00:10:12,640 --> 00:10:19,040
uh based on their existing workloads

00:10:16,399 --> 00:10:20,560
this is something that as developers of

00:10:19,040 --> 00:10:22,320
super base we can't predict what the

00:10:20,560 --> 00:10:25,360
workload would look like so

00:10:22,320 --> 00:10:26,320
uh but the developers who build on top

00:10:25,360 --> 00:10:27,680
of superbase

00:10:26,320 --> 00:10:29,600
might have a better understanding of

00:10:27,680 --> 00:10:32,320
this and might be able to fine tune the

00:10:29,600 --> 00:10:34,640
database to their needs

00:10:32,320 --> 00:10:36,399
but this also comes with some challenges

00:10:34,640 --> 00:10:38,880
because users can

00:10:36,399 --> 00:10:40,880
tamper with the tables for example you

00:10:38,880 --> 00:10:42,800
can delete the entire objects table

00:10:40,880 --> 00:10:44,880
leading to incorrect behavior or

00:10:42,800 --> 00:10:47,120
upgrades

00:10:44,880 --> 00:10:48,320
so the solution we decided was that we

00:10:47,120 --> 00:10:50,079
prevent showing

00:10:48,320 --> 00:10:52,320
or modifying these tables from the

00:10:50,079 --> 00:10:54,160
dashboard but the developer can still

00:10:52,320 --> 00:10:58,079
connect to the database

00:10:54,160 --> 00:11:00,480
and run sql in that case we assume that

00:10:58,079 --> 00:11:03,200
the developer knows what he's doing

00:11:00,480 --> 00:11:05,279
and can fine tune the database to his

00:11:03,200 --> 00:11:07,279
needs

00:11:05,279 --> 00:11:08,399
so i'll be talking a bit about how we

00:11:07,279 --> 00:11:10,800
built our

00:11:08,399 --> 00:11:11,839
authorization system for the rest of the

00:11:10,800 --> 00:11:14,959
presentation

00:11:11,839 --> 00:11:16,880
so here i we already use a

00:11:14,959 --> 00:11:18,320
open source project called go through

00:11:16,880 --> 00:11:20,720
which generates

00:11:18,320 --> 00:11:22,560
json web tokens for every user who

00:11:20,720 --> 00:11:23,519
successfully authenticates with the

00:11:22,560 --> 00:11:26,880
system

00:11:23,519 --> 00:11:29,360
and the idea was to reuse this jwd

00:11:26,880 --> 00:11:32,000
for making calls to the storage api

00:11:29,360 --> 00:11:32,000
server as well

00:11:32,560 --> 00:11:36,320
and this is how

00:11:36,399 --> 00:11:40,399
authorization policies look for other

00:11:38,640 --> 00:11:43,120
systems like firebase or

00:11:40,399 --> 00:11:43,920
aws s3 if you have written policies for

00:11:43,120 --> 00:11:46,959
these systems

00:11:43,920 --> 00:11:48,399
these might look familiar but the main

00:11:46,959 --> 00:11:51,040
thing that we wanted to do

00:11:48,399 --> 00:11:52,639
was to see if we can reuse an existing

00:11:51,040 --> 00:11:55,440
language like sql

00:11:52,639 --> 00:11:56,399
and not build another dsl or domain

00:11:55,440 --> 00:11:58,639
specific language

00:11:56,399 --> 00:12:00,800
to write these policies and this makes

00:11:58,639 --> 00:12:01,600
it faster for our users to get started

00:12:00,800 --> 00:12:05,839
because there's

00:12:01,600 --> 00:12:08,240
one less thing for them to learn and

00:12:05,839 --> 00:12:09,680
before i get into how we achieve that

00:12:08,240 --> 00:12:11,920
just give you a quick intro

00:12:09,680 --> 00:12:14,000
to postgres role level security if you

00:12:11,920 --> 00:12:15,680
haven't used it before

00:12:14,000 --> 00:12:17,120
so using grow level security you are

00:12:15,680 --> 00:12:19,920
able to attach policies

00:12:17,120 --> 00:12:20,880
to different tables so for example here

00:12:19,920 --> 00:12:24,880
i'm attaching

00:12:20,880 --> 00:12:27,440
a policy to the users table for

00:12:24,880 --> 00:12:28,639
the select statement where users are

00:12:27,440 --> 00:12:30,880
only able to select

00:12:28,639 --> 00:12:32,399
rows which have the id belonging to the

00:12:30,880 --> 00:12:35,680
current user

00:12:32,399 --> 00:12:36,320
so for example even if a user comes with

00:12:35,680 --> 00:12:38,480
an id

00:12:36,320 --> 00:12:39,360
1 and if he tries to do select start

00:12:38,480 --> 00:12:42,560
from users

00:12:39,360 --> 00:12:44,880
only the first row is returned because

00:12:42,560 --> 00:12:46,079
that row has the particular id belonging

00:12:44,880 --> 00:12:48,959
to that user

00:12:46,079 --> 00:12:49,600
and similarly rls policies can be added

00:12:48,959 --> 00:12:52,959
for

00:12:49,600 --> 00:12:56,720
other statements like

00:12:52,959 --> 00:12:56,720
update delete and so on

00:12:58,560 --> 00:13:01,600
and the main insight here was to that we

00:13:01,279 --> 00:13:03,920
could

00:13:01,600 --> 00:13:04,800
reuse these row level security policies

00:13:03,920 --> 00:13:07,600
and it can

00:13:04,800 --> 00:13:08,959
be mapped to the permissions required to

00:13:07,600 --> 00:13:11,920
make an api call

00:13:08,959 --> 00:13:12,800
for example if to find out if a user has

00:13:11,920 --> 00:13:16,000
permissions to

00:13:12,800 --> 00:13:18,399
upload a new object you just see if

00:13:16,000 --> 00:13:19,200
the user has the permission to insert a

00:13:18,399 --> 00:13:21,760
new row

00:13:19,200 --> 00:13:22,480
in the objects table and if he has that

00:13:21,760 --> 00:13:24,880
permission

00:13:22,480 --> 00:13:26,639
we let him upload the object as well and

00:13:24,880 --> 00:13:27,440
this can be mapped to other crud

00:13:26,639 --> 00:13:30,720
operations

00:13:27,440 --> 00:13:30,720
in a seamless way too

00:13:30,959 --> 00:13:34,000
so this is an example of an actual

00:13:32,480 --> 00:13:37,200
policy that you can write

00:13:34,000 --> 00:13:39,839
on super base storage this uh

00:13:37,200 --> 00:13:40,639
policy applies to the objects table and

00:13:39,839 --> 00:13:44,079
it checks

00:13:40,639 --> 00:13:46,800
for for a particular file name

00:13:44,079 --> 00:13:49,040
called profile slash complete.jpg and it

00:13:46,800 --> 00:13:52,800
allows the user with uid1

00:13:49,040 --> 00:13:54,000
to do all crowd operations on that

00:13:52,800 --> 00:13:55,920
particular object

00:13:54,000 --> 00:13:57,839
so the advantage of price writing

00:13:55,920 --> 00:13:58,880
policies in this way is that it's just

00:13:57,839 --> 00:14:01,199
sql

00:13:58,880 --> 00:14:03,040
you get the full power of sql all the

00:14:01,199 --> 00:14:04,639
internal functions all the helper

00:14:03,040 --> 00:14:06,079
functions that we have built like file

00:14:04,639 --> 00:14:09,199
name folder name

00:14:06,079 --> 00:14:12,320
uh extension and so on

00:14:09,199 --> 00:14:13,519
and also you get the helper functions in

00:14:12,320 --> 00:14:17,360
the odd schema like

00:14:13,519 --> 00:14:20,639
uid email to make use of

00:14:17,360 --> 00:14:21,600
while writing your policies and for

00:14:20,639 --> 00:14:23,600
users who

00:14:21,600 --> 00:14:26,000
do not have much experience with sql

00:14:23,600 --> 00:14:27,920
before we are also building a gui into

00:14:26,000 --> 00:14:31,839
the dashboard so that it's easier

00:14:27,920 --> 00:14:31,839
to get started with these policies

00:14:32,639 --> 00:14:36,320
there's another key piece of the

00:14:34,240 --> 00:14:39,040
solution which made it easier

00:14:36,320 --> 00:14:40,800
to build the authorization system this

00:14:39,040 --> 00:14:44,240
way and that was postquest

00:14:40,800 --> 00:14:46,560
so postcrest is an api server which

00:14:44,240 --> 00:14:48,240
exposes a rest api on top of your

00:14:46,560 --> 00:14:51,920
postgres database

00:14:48,240 --> 00:14:52,880
and postgres.js is the client library

00:14:51,920 --> 00:14:56,000
which we built

00:14:52,880 --> 00:14:58,160
to interact with postgres and say if a

00:14:56,000 --> 00:15:00,880
user comes and he wants to list

00:14:58,160 --> 00:15:01,440
all images in the folder the easy way to

00:15:00,880 --> 00:15:04,320
do this

00:15:01,440 --> 00:15:05,360
would be to just instantiate a new

00:15:04,320 --> 00:15:09,279
postgres client

00:15:05,360 --> 00:15:10,639
as that user and we already get the jwt

00:15:09,279 --> 00:15:13,519
token from the user

00:15:10,639 --> 00:15:15,279
and we can instantiate a postgres client

00:15:13,519 --> 00:15:17,600
using that jwd

00:15:15,279 --> 00:15:18,320
and this lets us assume the role of that

00:15:17,600 --> 00:15:20,320
user

00:15:18,320 --> 00:15:21,760
and any further database operations that

00:15:20,320 --> 00:15:24,880
we do would be done

00:15:21,760 --> 00:15:27,519
as part under the user's role

00:15:24,880 --> 00:15:28,000
so this lets the storage api server

00:15:27,519 --> 00:15:30,560
switch

00:15:28,000 --> 00:15:31,920
roles between different users easily and

00:15:30,560 --> 00:15:34,079
carry out operations

00:15:31,920 --> 00:15:36,320
which solve the problem in an elegant

00:15:34,079 --> 00:15:36,320
way

00:15:36,800 --> 00:15:41,440
we also wanted super base storage to

00:15:39,199 --> 00:15:44,560
integrate well with the rest of the

00:15:41,440 --> 00:15:46,000
storage ecosystem and we wanted to see

00:15:44,560 --> 00:15:48,639
what other storage back-ends

00:15:46,000 --> 00:15:49,440
developers wanted us to integrate with

00:15:48,639 --> 00:15:51,920
and

00:15:49,440 --> 00:15:54,000
we created a github discussion for it

00:15:51,920 --> 00:15:57,759
people responded everything from

00:15:54,000 --> 00:16:01,279
google cloud storage to s3 to even ipfs

00:15:57,759 --> 00:16:02,639
and the way we solved this problem of

00:16:01,279 --> 00:16:03,199
integrating with different storage

00:16:02,639 --> 00:16:05,759
back-ends

00:16:03,199 --> 00:16:06,639
was that we decided to target the s3 api

00:16:05,759 --> 00:16:08,160
first

00:16:06,639 --> 00:16:10,079
we realized that a lot of existing

00:16:08,160 --> 00:16:13,600
storage backends already target

00:16:10,079 --> 00:16:15,519
s3 and this makes it easier to add new

00:16:13,600 --> 00:16:18,480
storage back into the future

00:16:15,519 --> 00:16:19,920
and our existing api surface area also

00:16:18,480 --> 00:16:23,279
just consists of these

00:16:19,920 --> 00:16:25,279
six operations so even if your exists

00:16:23,279 --> 00:16:26,320
your storage backend doesn't support the

00:16:25,279 --> 00:16:28,639
s3 api

00:16:26,320 --> 00:16:30,320
as long as you're able to re-implement

00:16:28,639 --> 00:16:32,959
these six operations

00:16:30,320 --> 00:16:34,160
it should be easy to expand support to

00:16:32,959 --> 00:16:37,839
that

00:16:34,160 --> 00:16:37,839
back end as well

00:16:38,320 --> 00:16:42,480
finally i also wanted to talk about

00:16:40,079 --> 00:16:44,480
designing the client apis

00:16:42,480 --> 00:16:45,759
so this is what the postgres api looks

00:16:44,480 --> 00:16:49,199
like when you want to read

00:16:45,759 --> 00:16:52,800
data from the table and

00:16:49,199 --> 00:16:54,000
this is what our initial api for the

00:16:52,800 --> 00:16:56,079
storage look like

00:16:54,000 --> 00:16:58,399
this had a few different problems one

00:16:56,079 --> 00:17:01,360
was that it wasn't obvious that

00:16:58,399 --> 00:17:03,199
all of api operations have to be scoped

00:17:01,360 --> 00:17:05,199
to a particular bucket

00:17:03,199 --> 00:17:06,400
and we realized that by changing the api

00:17:05,199 --> 00:17:08,480
to something like this

00:17:06,400 --> 00:17:10,079
it's much more obvious that all api

00:17:08,480 --> 00:17:13,120
operations only happen

00:17:10,079 --> 00:17:16,079
at the bucket level and

00:17:13,120 --> 00:17:19,439
it also matches the postgres syntax

00:17:16,079 --> 00:17:23,039
loosely which was an added advantage

00:17:19,439 --> 00:17:25,679
so that's it that's concludes my talk uh

00:17:23,039 --> 00:17:26,720
hopefully you got something from how we

00:17:25,679 --> 00:17:28,240
balanced

00:17:26,720 --> 00:17:30,799
developer experience performance and

00:17:28,240 --> 00:17:32,160
security and how we made it easier for

00:17:30,799 --> 00:17:34,720
developers to get started

00:17:32,160 --> 00:17:35,679
with super base storage you can find me

00:17:34,720 --> 00:17:38,080
on twitter

00:17:35,679 --> 00:17:42,240
at ever country sky and you can find out

00:17:38,080 --> 00:17:42,240
more about superbase at superways.com

00:17:44,840 --> 00:17:47,840

YouTube URL: https://www.youtube.com/watch?v=YsUYOsq_o7g


