Title: Azure Friday | What’s New in Azure Cosmos DB’s API for MongoDB
Publication date: 2017-11-02
Playlist: Microsoft Open Source Summit
Description: 
	Emily Lawton joins Scott Hanselman to discuss what's new in Azure Cosmos DB's API for Mongo DB, including new preview features such as support for the aggregation pipeline and unique indexes. They discuss tips and tricks for importing large backups using MongoDB Tools.

For more information, see:

Azure Cosmos DB: API for MongoDB - https://docs.microsoft.com/en-us/azure/cosmos-db/mongodb-introduction
Azure Cosmos DB: Import MongoDB Data - https://docs.microsoft.com/en-us/azure/cosmos-db/mongodb-migrate
Captions: 
	00:00:01,120 --> 00:00:03,658
Hey friends, I'm Scott Hanselman and it's another episode

00:00:03,658 --> 00:00:06,243
of Azure Friday, I'm here with Emily Lawton she's a software

00:00:06,243 --> 00:00:07,232
engineer on Cosmos DB.

00:00:07,232 --> 00:00:07,893
How are you?

00:00:07,893 --> 00:00:08,648
>> I'm great, Scott.

00:00:08,648 --> 00:00:10,171
Thanks for having me, happy to be here.

00:00:10,171 --> 00:00:11,004
>> Yeah, it's cool.

00:00:11,004 --> 00:00:14,788
So I've used Cosmos DB with some Mongo apps where I literally

00:00:14,788 --> 00:00:18,125
just swapped the URL out for the connection string and

00:00:18,125 --> 00:00:20,230
it totally worked.

00:00:20,230 --> 00:00:20,730
>> Yeah.

00:00:20,730 --> 00:00:22,430
>> And then I just said to myself,

00:00:22,430 --> 00:00:25,000
wow that's amazing, it's a hundred percent compatible.

00:00:25,000 --> 00:00:26,890
Is that true, is it 100% compatible?

00:00:26,890 --> 00:00:29,408
>> So, that's why I'm thrilled to be here today because we

00:00:29,408 --> 00:00:32,031
have a number of new features that been working on in the past

00:00:32,031 --> 00:00:34,192
couple months, and even the past couple weeks.

00:00:34,192 --> 00:00:38,611
That will enable Mongo customers to migrate much more complex and

00:00:38,611 --> 00:00:41,031
powerful applications to Cosmos.

00:00:41,031 --> 00:00:44,852
And we have, with these updates we can much more confidently say

00:00:44,852 --> 00:00:48,390
we do support all of the most sought after Mongo features and

00:00:48,390 --> 00:00:51,716
are fully invested in really making sure that we have any

00:00:51,716 --> 00:00:53,911
developers coming over from Mongo,

00:00:53,911 --> 00:00:57,095
that we are there to support them with proper tools and

00:00:57,095 --> 00:00:59,668
resources to succeed in Cosmos.

00:00:59,668 --> 00:01:00,726
Now there's, I imagine,

00:01:00,726 --> 00:01:03,167
a pie chart of all the features that Cosmos could have, right?

00:01:03,167 --> 00:01:04,270
>> Yeah, there's a lot.

00:01:04,270 --> 00:01:05,730
>> There's a lot of stuff, right?

00:01:05,730 --> 00:01:08,550
And you're doing like some percentage of them but

00:01:08,550 --> 00:01:09,410
it's less than a 100%.

00:01:09,410 --> 00:01:10,418
>> Yes. >> But still 80%,

00:01:10,418 --> 00:01:12,800
90% some big number cuz it works really well.

00:01:13,800 --> 00:01:18,080
When a Mongo application talks to Cosmos and

00:01:18,080 --> 00:01:22,340
it doesn't support that, does it just go Or how does it say,

00:01:22,340 --> 00:01:23,240
I don't know how to do that?

00:01:23,240 --> 00:01:26,916
>> Yeah we're constantly working on improving this experience,

00:01:26,916 --> 00:01:30,260
and like just the other day, we were working on updating.

00:01:30,260 --> 00:01:32,130
So we have a lot of features in private previews, so

00:01:32,130 --> 00:01:33,040
you need to email us.

00:01:33,040 --> 00:01:35,820
Make sure we're giving much more gentle error messages,

00:01:35,820 --> 00:01:38,290
to let them know that you know, we do support this,

00:01:38,290 --> 00:01:39,770
we're working on it.

00:01:39,770 --> 00:01:40,740
>> Okay.

00:01:40,740 --> 00:01:41,838
Yes [CROSSTALK] >> So if you're an active

00:01:41,838 --> 00:01:44,129
user of this and you really want to engage with the Cosmos

00:01:44,129 --> 00:01:46,610
team then you could talk to you via private previews.

00:01:46,610 --> 00:01:47,780
>> Yeah. >> And then when you start to

00:01:47,780 --> 00:01:49,322
use a new feature, it could say,

00:01:49,322 --> 00:01:52,135
we're totally working on this feature, don't forget.

00:01:52,135 --> 00:01:54,580
>> Yeah, and all the things we support are completely based on,

00:01:54,580 --> 00:01:56,710
we heard this customer yesterday that really needs this

00:01:56,710 --> 00:01:58,305
feature and [CROSSTALK] >> Really?

00:01:58,305 --> 00:01:58,820
>> We run and

00:01:58,820 --> 00:02:02,270
are fighting fires everyday to make sure we help them out.

00:02:02,270 --> 00:02:04,601
>> What are some new things that are happening in Cosmos space?

00:02:04,601 --> 00:02:07,723
>> So the three things I'm going to discuss today are some tips

00:02:07,723 --> 00:02:10,471
and tricks for a successful migration, support for

00:02:10,471 --> 00:02:13,840
the aggregation pipeline and support for unique indexes.

00:02:13,840 --> 00:02:16,432
>> And aggregation pipeline is a feature that people who use

00:02:16,432 --> 00:02:18,329
Mongo really like and it's one [CROSSTALK]

00:02:18,329 --> 00:02:18,887
>> They love it.

00:02:18,887 --> 00:02:19,502
>> Of their most asked-for ones.

00:02:19,502 --> 00:02:20,489
>> Yeah, yeah.

00:02:20,489 --> 00:02:24,879
So, one of the major pain points that our Mongo customers hit

00:02:24,879 --> 00:02:29,012
when moving over to Cosmos is simply just migrating their

00:02:29,012 --> 00:02:29,540
data.

00:02:29,540 --> 00:02:32,150
So we have a few updates to help squash any errors that

00:02:32,150 --> 00:02:33,180
they're running into there.

00:02:34,210 --> 00:02:36,758
When customers have a lot of data we generally ask them to go

00:02:36,758 --> 00:02:39,054
to the MongoDB download center, get Mongo import.

00:02:39,054 --> 00:02:42,920
And a lot of times when they run this they'll hit throttling

00:02:42,920 --> 00:02:43,547
errors.

00:02:43,547 --> 00:02:48,072
And this is largely because collections when created in

00:02:48,072 --> 00:02:52,345
Cosmos are defined within 1000 provision RUs.

00:02:52,345 --> 00:02:57,650
Oftentimes this isn't enough for a large data migration.

00:02:57,650 --> 00:03:00,650
So one of the first steps we want our customers to know is

00:03:00,650 --> 00:03:02,985
that it's best if you go into the Azure portal and

00:03:02,985 --> 00:03:05,285
pre-create the collections you wanna import data into.

00:03:05,285 --> 00:03:05,969
>> Mm-hm. >> And

00:03:05,969 --> 00:03:09,707
bump up the RUs during the migration then once migration is

00:03:09,707 --> 00:03:12,236
complete go down and decrease the RUs.

00:03:12,236 --> 00:03:16,520
So this is one way to help get past these issues.

00:03:16,520 --> 00:03:19,280
Another thing is that we've added two new options through

00:03:19,280 --> 00:03:20,865
the Mongo import command.

00:03:20,865 --> 00:03:21,474
>> Mm-hm.

00:03:21,474 --> 00:03:23,950
>> One is number of insertion workers and batch size.

00:03:23,950 --> 00:03:26,919
And I've included a link here which goes through a very

00:03:26,919 --> 00:03:29,641
detailed process of how to compute these values.

00:03:29,641 --> 00:03:33,738
And when computed correctly, you won't see any throttling, and

00:03:33,738 --> 00:03:37,470
your migration will be much smoother, and you'll get up and

00:03:37,470 --> 00:03:40,240
going with cosmos much quicker, right?

00:03:40,240 --> 00:03:42,480
>> Do you have a rule of thumb or general sense,

00:03:42,480 --> 00:03:43,830
cuz you said large.

00:03:43,830 --> 00:03:45,830
>> Yeah. >> And like, I did a migration,

00:03:45,830 --> 00:03:47,600
but I don't know what I'm doing.

00:03:47,600 --> 00:03:50,950
And I used an application called MongoChef Core.

00:03:50,950 --> 00:03:54,650
And I basically opened up two connections, one to Cosmos and

00:03:54,650 --> 00:03:55,240
one to Mongo.

00:03:55,240 --> 00:03:56,400
And I dragged and dropped.

00:03:56,400 --> 00:03:57,540
I don't know if that was bad.

00:03:57,540 --> 00:04:01,970
>> Yeah, no, so it's a lot of experimentation to get the right

00:04:01,970 --> 00:04:04,095
parameters here to make sure your migration is smooth.

00:04:04,095 --> 00:04:04,680
>> Mm-hm.

00:04:04,680 --> 00:04:06,809
>> But I swear by this link, if you go to it,

00:04:06,809 --> 00:04:09,403
it goes through details how to compute [CROSSTALK]

00:04:09,403 --> 00:04:11,343
>> That is the bible for

00:04:11,343 --> 00:04:13,300
Cosmos DB migrate.

00:04:13,300 --> 00:04:13,805
>> Yes. >> Cool, so

00:04:13,805 --> 00:04:15,730
if I follow those then I would have a good experience.

00:04:15,730 --> 00:04:16,290
>> You will.

00:04:16,290 --> 00:04:16,990
>> Okay cool, thank you.

00:04:18,380 --> 00:04:20,760
>> The next update that I'd love to talk about today is our

00:04:20,760 --> 00:04:22,533
support for the aggravation pipeline.

00:04:22,533 --> 00:04:23,171
>> Okay.

00:04:23,171 --> 00:04:25,411
>> So we know in today's data-driven age,

00:04:25,411 --> 00:04:28,930
it's incredibly important to give tools to our developers.

00:04:28,930 --> 00:04:31,810
To make sure that they can quickly gain insights into their

00:04:31,810 --> 00:04:32,625
data.

00:04:32,625 --> 00:04:33,195
So Mongo

00:04:33,195 --> 00:04:35,535
developed this framework called aggregation pipeline.

00:04:36,645 --> 00:04:40,365
Which is essentially an alternative to map reduce.

00:04:40,365 --> 00:04:43,253
But it's much more lightweight, it's easier to get ramped up on.

00:04:43,253 --> 00:04:46,433
And it's used whenever the complexity

00:04:46,433 --> 00:04:49,245
of map reduce is unwarranted.

00:04:49,245 --> 00:04:52,942
So I'll go through some demonstrations of the things

00:04:52,942 --> 00:04:55,990
that you can do with aggregation pipeline.

00:04:55,990 --> 00:04:57,446
>> Please. >> This is something our team

00:04:57,446 --> 00:04:59,127
has been working on for [CROSSTALK]

00:04:59,127 --> 00:05:00,124
>> And out of curiosity,

00:05:00,124 --> 00:05:03,530
what would I have seen if I'd tried to do these things before?

00:05:03,530 --> 00:05:04,590
Would Mongo have given?

00:05:04,590 --> 00:05:06,180
Would Cosmos have said an error or unsupported.

00:05:06,180 --> 00:05:07,950
>> It would have said, yeah, we don't support this.

00:05:07,950 --> 00:05:09,850
>> Okay, but it returns an error that

00:05:09,850 --> 00:05:11,070
indicates a lack of support.

00:05:11,070 --> 00:05:11,690
>> Yes, yes.

00:05:11,690 --> 00:05:13,520
>> Not like a general- >> Not just some-

00:05:13,520 --> 00:05:13,870
>> 500 error.

00:05:13,870 --> 00:05:14,810
>> Yeah, of course.

00:05:14,810 --> 00:05:15,980
>> Okay, that's cool.

00:05:15,980 --> 00:05:18,250
>> So, one of my favorite hobbies is running.

00:05:18,250 --> 00:05:20,522
So, let's connect to my account and

00:05:20,522 --> 00:05:24,640
I've loaded up the results of the 2017 Boston Marathon here.

00:05:24,640 --> 00:05:27,303
>> And you're in the Mongo shell, you're just in

00:05:27,303 --> 00:05:29,134
the Windows [CROSSTALK] >> This is the Mongo shell.

00:05:29,134 --> 00:05:29,912
>> The Mongo shell.

00:05:29,912 --> 00:05:32,199
Is it bad that the shell and the server versions don't match?

00:05:32,199 --> 00:05:33,185
Does that mean anything?

00:05:33,185 --> 00:05:35,600
>> In this scenario it's not a problem.

00:05:35,600 --> 00:05:38,175
There were some new operators that were added in 3.4.

00:05:38,175 --> 00:05:40,250
>> Okay, not a big deal.

00:05:40,250 --> 00:05:41,540
>> Yeah.

00:05:41,540 --> 00:05:43,010
So, let's first just do.

00:05:43,010 --> 00:05:44,287
>> Did you say you ran the Boston Marathon?

00:05:44,287 --> 00:05:45,205
>> No, I did not run it.

00:05:45,205 --> 00:05:46,388
I wish!

00:05:46,388 --> 00:05:51,790
So an aggregate command takes an array of stages.

00:05:51,790 --> 00:05:52,290
>> Okay.

00:05:52,290 --> 00:05:54,619
>> So, let's just experiment with a match stage first.

00:05:56,090 --> 00:05:58,618
So it matches, essentially, just a SQL where clause.

00:05:58,618 --> 00:06:01,160
>> Okay. >> So let's say we wanna find

00:06:01,160 --> 00:06:05,050
all the data we have about the runner Galen Rupp.

00:06:05,050 --> 00:06:07,560
Galen is an American

00:06:07,560 --> 00:06:08,590
professional long distance runner.

00:06:08,590 --> 00:06:10,230
He runs for the Nike Oregon project,

00:06:10,230 --> 00:06:12,210
he's a role model of mine.

00:06:12,210 --> 00:06:12,710
>> That's cool. >> So let's see [CROSSTALK]

00:06:12,710 --> 00:06:13,542
>> I'm from Oregon,

00:06:13,542 --> 00:06:15,170
I grew up down the street from Nike.

00:06:15,170 --> 00:06:16,990
>> Nice. >> If I bump in to him

00:06:16,990 --> 00:06:19,425
while I'm walking, then I will say hi.

00:06:19,425 --> 00:06:23,059
>> [CROSSTALK] So this is what a match query looks like and so

00:06:23,059 --> 00:06:27,091
we see this is a document that is associated with Galen Rupp.

00:06:27,091 --> 00:06:31,043
We see he's from Portland, his official time was 2 hours and

00:06:31,043 --> 00:06:32,760
9 minutes.

00:06:32,760 --> 00:06:34,440
>> And his overall place was second.

00:06:34,440 --> 00:06:35,990
>> It's about 26 miles.

00:06:35,990 --> 00:06:37,581
>> Yes. >> That's like 12 miles an hour.

00:06:37,581 --> 00:06:39,043
>> It's 26.2, yeah.

00:06:39,043 --> 00:06:39,995
>> I don't think I can run like that.

00:06:39,995 --> 00:06:43,820
>> [LAUGH] So he had very impressive finish.

00:06:45,350 --> 00:06:47,480
So this type of query isn't that interesting.

00:06:47,480 --> 00:06:49,247
So let's do some more interesting types of [CROSSTALK]

00:06:49,247 --> 00:06:50,257
>> Out of curiosity,

00:06:50,257 --> 00:06:52,213
is that the user aggregated query but

00:06:52,213 --> 00:06:54,421
there is ways that I could have queried for

00:06:54,421 --> 00:06:57,279
that without using that [CROSSTALK] cuz I was aware of.

00:06:57,279 --> 00:07:01,174
>> Yeah, you could also do a simple refined query and

00:07:01,174 --> 00:07:04,630
specify the filter that you wanna specify.

00:07:04,630 --> 00:07:06,500
And I should note that you always want it,

00:07:06,500 --> 00:07:08,690
when using the aggregation pipeline, this is just a tip for

00:07:08,690 --> 00:07:11,220
once you get started in using this, you wanna do the match

00:07:11,220 --> 00:07:14,520
stage generally as early on in pipeline as you can

00:07:14,520 --> 00:07:17,700
to filter out and make sure you have fewer documents.

00:07:17,700 --> 00:07:18,960
As you go through the pipeline.

00:07:18,960 --> 00:07:22,280
>> I see, so it is a pipeline, like a sales pipeline,

00:07:22,280 --> 00:07:24,470
it's like the smaller it gets, the less data you have to deal

00:07:24,470 --> 00:07:26,020
with further down in the pipeline.

00:07:26,020 --> 00:07:27,590
>> Yeah. >> Okay, cool.

00:07:27,590 --> 00:07:30,190
>> So let's find all the runners that actually ran faster than

00:07:30,190 --> 00:07:31,180
three hours.

00:07:31,180 --> 00:07:33,700
So here we'll use a conditional operator,

00:07:33,700 --> 00:07:36,856
less than, still the same type of match query.

00:07:36,856 --> 00:07:40,220
And now we'll get a long list of all the runners that

00:07:40,220 --> 00:07:41,300
ran faster than three hours.

00:07:41,300 --> 00:07:45,536
This is not that interesting because it's hard to kind of

00:07:45,536 --> 00:07:48,900
visualize or scroll through these results.

00:07:48,900 --> 00:07:50,375
But let's say we actually,

00:07:50,375 --> 00:07:53,270
now let's do something a little bit more interesting.

00:07:53,270 --> 00:07:57,010
Let's say we want to group the runners by their country and see

00:07:57,010 --> 00:08:00,590
what the average place of the runners In those groups of his.

00:08:01,590 --> 00:08:03,165
>> So here we add the group stage.

00:08:03,165 --> 00:08:06,366
And all group stages require an underscore ID field,

00:08:06,366 --> 00:08:09,364
which is what you're grouping the documents by.

00:08:09,364 --> 00:08:12,193
>> If I understand your tip from before, if I had flipped this

00:08:12,193 --> 00:08:14,618
around and did the group first and then the match,

00:08:14,618 --> 00:08:17,276
it's kind of silly because I'd be taking everyone and

00:08:17,276 --> 00:08:20,323
grouping them by country, and then Chopping them up by time?

00:08:20,323 --> 00:08:22,648
>> Yes, yes.

00:08:22,648 --> 00:08:25,640
So let's go ahead and make sure I copy that one.

00:08:27,030 --> 00:08:28,637
>> Feels like PowerShell for data.

00:08:28,637 --> 00:08:29,727
>> [LAUGH] Kind of, and

00:08:29,727 --> 00:08:33,133
again we get a list of an array of all of the countries that had

00:08:33,133 --> 00:08:35,690
runners that ran faster than three hours.

00:08:35,690 --> 00:08:37,010
>> And is it sorted?

00:08:37,010 --> 00:08:37,810
>> This is not sorted,

00:08:37,810 --> 00:08:42,080
I'm gonna, I've another query that will, getting ahead of us?

00:08:42,080 --> 00:08:42,600
>> No, pardon me.

00:08:42,600 --> 00:08:45,290
>> So the next one, let's find the number of runners in each of

00:08:45,290 --> 00:08:48,420
those groups which will be a be a little bit more interesting

00:08:48,420 --> 00:08:53,780
and here we can specify within the group stage, an accumulator

00:08:53,780 --> 00:08:56,080
and we're gonna use the summing accumulator and sum up one for

00:08:56,080 --> 00:08:59,890
each runner in each group >> Sum up one, okay so,

00:08:59,890 --> 00:09:01,800
then, it will be the count of the number of people

00:09:03,330 --> 00:09:05,000
under three hours per country.

00:09:05,000 --> 00:09:05,630
>> Yes.

00:09:05,630 --> 00:09:07,850
>> Okay, so you're doing a projection at this point,

00:09:07,850 --> 00:09:09,040
you're making a new kind of-.

00:09:09,040 --> 00:09:11,070
>> Yeah, we created a new field.

00:09:11,070 --> 00:09:15,230
And so here we see, again it's kind of hard to understand.

00:09:15,230 --> 00:09:17,668
>> Austria had eight, that's good, Egypt had one.

00:09:17,668 --> 00:09:21,060
>> Yeah and then the next thing we'll do is, let's

00:09:21,060 --> 00:09:23,850
find the average like we wanted to and like I said earlier find

00:09:23,850 --> 00:09:26,860
the average overall place of each of the countries.

00:09:26,860 --> 00:09:30,110
But let's order them in a way such that we can actually see

00:09:30,110 --> 00:09:32,752
which country had the fastest average time.

00:09:32,752 --> 00:09:33,288
>> That's a good point,

00:09:33,288 --> 00:09:34,424
otherwise I'm just scrolling around, okay.

00:09:34,424 --> 00:09:36,973
>> And we're going to sort by average place, and we pass

00:09:36,973 --> 00:09:40,390
the negative one because we want to sort in descending order.

00:09:40,390 --> 00:09:42,200
>> Negative one is descending, okay.

00:09:42,200 --> 00:09:42,820
And here we see.

00:09:42,820 --> 00:09:43,360
>> Zimbabwe.

00:09:43,360 --> 00:09:49,340
>> Zimbabwe actually had the fastest, or the lowest

00:09:49,340 --> 00:09:51,670
average place, which was 14 but they only had one runner.

00:09:52,800 --> 00:09:55,300
So last query we will do is let's see

00:09:55,300 --> 00:09:57,759
who had the most runners who finished less than three hours.

00:09:59,690 --> 00:10:00,665
My wife's from Zimbabwe.

00:10:00,665 --> 00:10:03,144
>> [LAUGH] >> Okay, cool.

00:10:03,144 --> 00:10:06,189
>> And here we see the United States had the most runners that

00:10:06,189 --> 00:10:08,240
finished faster than three hours.

00:10:08,240 --> 00:10:09,814
>> Are we last, though?

00:10:09,814 --> 00:10:11,325
>> We are not.

00:10:11,325 --> 00:10:12,272
>> We sorted last on this.

00:10:12,272 --> 00:10:13,405
>> You can also find that.

00:10:13,405 --> 00:10:15,615
Well, no I sorted in ascending order this time.

00:10:15,615 --> 00:10:16,315
>> Okay good.

00:10:16,315 --> 00:10:19,455
>> So you can see that we had over a thousand runners which is

00:10:19,455 --> 00:10:21,905
over ten times more than the next country had.

00:10:21,905 --> 00:10:23,685
>> Which makes sense cuz it was in Boston.

00:10:23,685 --> 00:10:24,405
>> It was in Boston.

00:10:25,589 --> 00:10:28,655
>> That is pretty slick and it's coming back so fast though.

00:10:28,655 --> 00:10:32,755
>> Yeah, so this data site had, I think, 25,000 documents, so

00:10:32,755 --> 00:10:34,000
it's not huge.

00:10:34,000 --> 00:10:36,780
But we're continually working on making sure this

00:10:36,780 --> 00:10:37,730
pipeline is scalable.

00:10:39,020 --> 00:10:42,110
Because when you pair it with all of the features that you get

00:10:42,110 --> 00:10:46,340
that come with Cosmos like autoscaling with provisionary

00:10:46,340 --> 00:10:50,445
use, auto-sharding, and automatic indexing, it makes for

00:10:50,445 --> 00:10:54,000
a really synergistic effect and a great experience.

00:10:54,000 --> 00:10:56,480
>> Yeah I mean you're getting the feeling of your favorite

00:10:56,480 --> 00:10:59,880
database, your Mongo experience, and the familiarity.

00:10:59,880 --> 00:11:02,028
That I can see that you have with the syntax, but

00:11:02,028 --> 00:11:04,286
it's a global database, it's geo replicated,

00:11:04,286 --> 00:11:05,880
it's the best of both worlds.

00:11:05,880 --> 00:11:06,890
>> Yep, exactly.

00:11:06,890 --> 00:11:07,840
>> That's pretty slick.

00:11:07,840 --> 00:11:09,320
>> So it's super fun to work on.

00:11:10,830 --> 00:11:13,840
>> And then, quickly, one other update that I'd like to discuss

00:11:13,840 --> 00:11:15,490
is support for unique indexes.

00:11:15,490 --> 00:11:18,732
This was another thing that our customers have been badgering us

00:11:18,732 --> 00:11:20,660
for, so we went ahead and delivered.

00:11:22,490 --> 00:11:23,823
And as the name suggests,

00:11:23,823 --> 00:11:26,853
unique indexes just ensure that the fields that you specify

00:11:26,853 --> 00:11:29,770
the unique indexes on cannot have duplicate values.

00:11:29,770 --> 00:11:31,730
>> Interesting, that feels like it blurs the line a little bit

00:11:31,730 --> 00:11:34,280
between document database, we just throw anything into it.

00:11:34,280 --> 00:11:34,790
>> Yeah.

00:11:34,790 --> 00:11:37,110
>> And relational database where the ID matters.

00:11:37,110 --> 00:11:38,082
>> Yeah.

00:11:38,082 --> 00:11:41,250
You can imagine if you had some sort of a collection, that was

00:11:41,250 --> 00:11:45,540
containing account data that had the tax ID field or something.

00:11:45,540 --> 00:11:47,120
Wanna make sure that field is unique, so

00:11:47,120 --> 00:11:50,480
that you don't have multiple accounts with the same tax id.

00:11:50,480 --> 00:11:51,860
>> Okay.

00:11:51,860 --> 00:11:53,920
>> And so quickly, here's the syntax for

00:11:53,920 --> 00:11:55,970
how you create a unique index.

00:11:55,970 --> 00:11:58,900
You can go ahead and once you have this feature enabled

00:11:58,900 --> 00:12:01,190
on your account you can create it on any field.

00:12:01,190 --> 00:12:03,040
For instance, this is the user_id field and

00:12:03,040 --> 00:12:05,440
then you just specify the unique attribute to true.

00:12:05,440 --> 00:12:06,780
>> That seems pretty straightforward.

00:12:06,780 --> 00:12:07,530
>> Yeah.

00:12:07,530 --> 00:12:09,160
>> What if it already has a bunch of data in it?

00:12:10,560 --> 00:12:13,685
So one thing to know is that you cannot actually create a unique

00:12:13,685 --> 00:12:18,050
index field that already, Does not follow

00:12:18,050 --> 00:12:18,825
the constraint, right?

00:12:18,825 --> 00:12:20,814
>> Okay, I see, so it's only at the time of creation that you do

00:12:20,814 --> 00:12:21,517
that, is modified.

00:12:21,517 --> 00:12:22,123
>> Yes, well,

00:12:22,123 --> 00:12:24,825
you can still actually create it once the field has already

00:12:24,825 --> 00:12:25,440
been there.

00:12:25,440 --> 00:12:28,012
But we'll just go through and we'll make sure that you don't

00:12:28,012 --> 00:12:30,540
already have duplicate values there cuz you can't do that.

00:12:30,540 --> 00:12:33,080
>> And then if you did, you would deal with that?

00:12:33,080 --> 00:12:34,860
>> We'll still work on a better experience.

00:12:34,860 --> 00:12:37,020
>> But it sounds like it's pretty straight forward.

00:12:37,020 --> 00:12:38,620
I can just make a temporary collection,

00:12:38,620 --> 00:12:42,710
spin through it project over to it and de-doop.

00:12:42,710 --> 00:12:45,580
Very cool, and is this all right now happening now or

00:12:45,580 --> 00:12:46,740
do I have to sign up for a preview?

00:12:46,740 --> 00:12:47,410
How do I get involved?

00:12:47,410 --> 00:12:49,570
>> So these two features are currently in private preview,

00:12:49,570 --> 00:12:52,302
which means I've included the link that you can email us at.

00:12:52,302 --> 00:12:53,290
And we'll enable this,

00:12:53,290 --> 00:12:55,920
we're very quick about enabling it on accounts.

00:12:55,920 --> 00:12:57,930
And by the end of the year this will be in public preview and

00:12:57,930 --> 00:13:00,080
you can actually go into the Azure portal,

00:13:00,080 --> 00:13:02,360
in a self serve fashion enable it on our accounts.

00:13:02,360 --> 00:13:02,948
>> Very cool. >> And

00:13:02,948 --> 00:13:05,050
take advantage of all these new updates.

00:13:05,050 --> 00:13:07,920
>> And you were saying that you are doing all of these features

00:13:07,920 --> 00:13:09,860
in this order because people are asking for them.

00:13:09,860 --> 00:13:11,080
>> Yeah. >> And if they email you,

00:13:11,080 --> 00:13:13,350
like real people are on the other end of that email and

00:13:13,350 --> 00:13:17,010
a team is excited to hear about what you're using with Mongo and

00:13:17,010 --> 00:13:18,680
Cosmos and how to make it better.

00:13:18,680 --> 00:13:19,490
>> Yes.

00:13:19,490 --> 00:13:20,730
>> Very cool. Thanks so much for your time.

00:13:20,730 --> 00:13:21,840
>> Thank you for having me.

00:13:21,840 --> 00:13:24,749
All right, I am learning all about Mongo DB and

00:13:24,749 --> 00:13:27,142
Azure Cosmos DB here on Azure Friday.

00:13:27,142 --> 00:13:31,538

YouTube URL: https://www.youtube.com/watch?v=7rPv3F1vKV8


