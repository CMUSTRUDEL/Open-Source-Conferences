Title: Azure Friday | DocumentDB Stored Procedures Best Practices
Publication date: 2017-05-25
Playlist: Microsoft Open Source Summit
Description: 
	Andrew Liu joins Scott Hanselman to talk about Azure DocumentDB's language integrated, transactional execution of JavaScript, which enables developers write stored procedures, triggers and user defined functions (UDFs) natively in JavaScript. Andrew also shares best practices for writing these stored procedures. 

For an enterprise cloud strategy ebook, visit: http://aka.ms/enterprisecloudebook
Captions: 
	00:00:00,505 --> 00:00:04,360
[MUSIC]

00:00:07,936 --> 00:00:10,119
Hey, I'm Scott Hanselman, and it's Azure Friday.

00:00:10,119 --> 00:00:13,584
And here we're talking about DocumentDB stored procedures with

00:00:13,584 --> 00:00:14,305
Andrew Liu.

00:00:14,305 --> 00:00:15,015
How's it going?

00:00:15,015 --> 00:00:16,895
>> Yep, it's great, thanks for having me here.

00:00:16,895 --> 00:00:18,839
>> So stored procs, so I think stored procs,

00:00:18,839 --> 00:00:20,189
I kinda think old school SQL.

00:00:20,189 --> 00:00:26,180
What does that bring to a world of NoSQL databases at a world scale?

00:00:26,180 --> 00:00:28,130
>> So this is actually pretty cool.

00:00:28,130 --> 00:00:32,321
A few nuances that are different from SQL is we made a bet

00:00:32,321 --> 00:00:32,900
on JavaScripts so

00:00:32,900 --> 00:00:35,590
you have a full blown programming language to implement these.

00:00:35,590 --> 00:00:36,200
>> That's cool.

00:00:36,200 --> 00:00:39,428
>> Part of this reason why is because well, when you're dealing

00:00:39,428 --> 00:00:42,484
with JSON Data, JSON is JavaScript's Object Notation.

00:00:42,484 --> 00:00:45,130
JavaScript is very natural to interact with this data.

00:00:45,130 --> 00:00:45,828
>> Yeah.

00:00:45,828 --> 00:00:50,600
>> And the other thing that I think is really cool is a lot of NoSQL

00:00:50,600 --> 00:00:54,170
databases, they relax transactions a lot.

00:00:54,170 --> 00:00:57,793
Right, they give you transactions as a transactions around a single

00:00:57,793 --> 00:00:59,792
document, and what we've found is,

00:00:59,792 --> 00:01:02,368
this is really hard to program against, right?

00:01:02,368 --> 00:01:05,300
And so if you wanna get ACID transactions across

00:01:05,300 --> 00:01:06,693
multiple documents,

00:01:06,693 --> 00:01:10,443
well this is what we intended stored procedures to give you.

00:01:10,443 --> 00:01:11,604
>> Mm-hm.

00:01:11,604 --> 00:01:14,410
>> And so I think this is really cool.

00:01:14,410 --> 00:01:17,326
>> It makes me feel a little bit like there's NoSQL databases,

00:01:17,326 --> 00:01:18,880
without mentioning any names.

00:01:18,880 --> 00:01:19,472
>> Mm-hm.

00:01:19,472 --> 00:01:22,644
>> That are nice for medium to small applications, but

00:01:22,644 --> 00:01:27,300
when you need to get serious, when enterprise work needs to get done.

00:01:27,300 --> 00:01:31,490
The reality of transactions happens and those tend to fall down.

00:01:31,490 --> 00:01:34,790
>> Yeah, yeah, I can even show you a use case.

00:01:34,790 --> 00:01:38,123
So what I have here is I have a sample dataset in my DocumentDB

00:01:38,123 --> 00:01:38,732
account.

00:01:38,732 --> 00:01:39,500
>> Mm-hm.

00:01:39,500 --> 00:01:42,150
>> And what it is it's a product catalog.

00:01:42,150 --> 00:01:42,767
>> Okay.

00:01:42,767 --> 00:01:45,860
>> And let me load this real quick.

00:01:45,860 --> 00:01:47,210
>> Okay.

00:01:47,210 --> 00:01:51,560
And so basically what I have done here is I've got a dataset that is

00:01:51,560 --> 00:01:55,940
a product catalog containing things like bike frames, helmets, jerseys.

00:01:55,940 --> 00:01:56,480
>> Sure.

00:01:56,480 --> 00:01:58,940
>> And what I wanna do with this product catalog is I wanna add the

00:01:58,940 --> 00:02:02,370
functionality of let's say revealing the items, setting our rating.

00:02:02,370 --> 00:02:03,060
>> Right.

00:02:03,060 --> 00:02:06,280
>> And in order to do this, what I wanna do is I wanna create

00:02:06,280 --> 00:02:10,860
a review document with a comment as well as update let's say,

00:02:10,860 --> 00:02:14,200
what is the rating from zero to ten?

00:02:14,200 --> 00:02:16,438
How many reviews does this particular product has?

00:02:16,438 --> 00:02:17,040
>> Mm-hm.

00:02:17,040 --> 00:02:19,966
>> And so what happens is I'm updating one document, and

00:02:19,966 --> 00:02:22,080
I am writing a new document.

00:02:22,080 --> 00:02:25,040
And what I wanna do is I wanna make this happen transactionally so

00:02:25,040 --> 00:02:30,170
that I don't just update the rating without having a review underneath.

00:02:30,170 --> 00:02:31,480
>> Right. >> Or create a dangling

00:02:31,480 --> 00:02:34,160
review comment that doesn't actually effect the product.

00:02:34,160 --> 00:02:35,380
>> And it might sound like a small thing, but

00:02:35,380 --> 00:02:36,680
we've all had that experience.

00:02:36,680 --> 00:02:38,460
We've gone to a website and we've seen, well,

00:02:38,460 --> 00:02:41,000
there's three comments here and the count says five.

00:02:41,000 --> 00:02:44,630
What's going on, inconsistency, it's bad for a number of reasons.

00:02:44,630 --> 00:02:48,880
>> Yep, and so let me jump into the stored procedure for doing this.

00:02:49,890 --> 00:02:51,980
So here I'm in the Azure portal.

00:02:51,980 --> 00:02:53,098
I'm going to our Script Explorer.

00:02:53,098 --> 00:02:53,774
>> Mm-hm.

00:02:53,774 --> 00:02:58,138
>> And I've written a quick stored procedure for applying this review.

00:02:58,138 --> 00:02:58,857
>> Okay.

00:02:58,857 --> 00:03:03,071
>> Now, a couple things to really know about stored procedures is

00:03:03,071 --> 00:03:03,945
number one,

00:03:03,945 --> 00:03:08,318
because we've optimized around the use case for transactions,

00:03:08,318 --> 00:03:12,760
these work best when you have some kind of write operation.

00:03:12,760 --> 00:03:16,115
If you have strictly let's say a sequence of reads-

00:03:16,115 --> 00:03:16,350
>> Mm-hm.

00:03:16,350 --> 00:03:18,870
>> This is actually best implemented on the client SDKs.

00:03:18,870 --> 00:03:19,752
>> Hm.

00:03:19,752 --> 00:03:22,898
>> Now within the stored procedure,

00:03:22,898 --> 00:03:27,810
what we have here is I've taken a set of parameters.

00:03:27,810 --> 00:03:30,576
So what product I wanna update, who the reviewer is,

00:03:30,576 --> 00:03:33,968
what kind of rating and what the reviewer's comment is, right?

00:03:33,968 --> 00:03:35,152
>> Okay.

00:03:35,152 --> 00:03:38,260
>> I do some validation and basically I'm gonna do two things.

00:03:38,260 --> 00:03:40,040
I'm gonna create the review document, and

00:03:40,040 --> 00:03:43,500
I'm gonna update the product document.

00:03:43,500 --> 00:03:47,265
Within this, these helper functions, it's pretty simple, right?

00:03:47,265 --> 00:03:50,558
>> Are those helper functions also stored procedures or they literally

00:03:50,558 --> 00:03:53,910
just helper functions within the larger name stored procedure?

00:03:53,910 --> 00:03:56,185
>> There was just JavaScript functions that I have embedded into

00:03:56,185 --> 00:03:57,174
this stored procedure.

00:03:57,174 --> 00:03:59,240
>> Okay. >> And this is actually a really

00:03:59,240 --> 00:04:02,349
cool thing about also using JavaScript is,

00:04:02,349 --> 00:04:04,793
the Java ecosystem is humongous.

00:04:04,793 --> 00:04:05,409
>> Yeah.

00:04:05,409 --> 00:04:08,497
>> So the number of JavaScript libraries out there that you can

00:04:08,497 --> 00:04:12,264
embed into a stored procedure, let's say if you wanna bring in a popular

00:04:12,264 --> 00:04:14,366
JavaScript machine learning library,

00:04:14,366 --> 00:04:17,541
you can actually then embed that into the stored procedure.

00:04:17,541 --> 00:04:20,068
Cuz we have a full blown JavaScript runtime running

00:04:20,068 --> 00:04:22,638
behind the scenes, so- >> Then it's then enlisted into

00:04:22,638 --> 00:04:24,275
the transaction and either worked or

00:04:24,275 --> 00:04:26,510
it didn't and you'll take care of stuff.

00:04:26,510 --> 00:04:27,273
>> That's correct. >> That's great.

00:04:27,273 --> 00:04:28,313
So I wanna bring Moment.js or

00:04:28,313 --> 00:04:30,368
whatever makes me happy in there to do work where it can do-

00:04:30,368 --> 00:04:32,986
>> Yeah, yeah.

00:04:32,986 --> 00:04:36,690
And so the way our API works is

00:04:37,910 --> 00:04:40,880
we have a bunch of crowd and query operations.

00:04:40,880 --> 00:04:43,551
These methods create a document, just createDocument,

00:04:43,551 --> 00:04:45,150
pretty straightforward.

00:04:45,150 --> 00:04:48,750
But one thing to know about the JavaScript Runtimes we host,

00:04:48,750 --> 00:04:51,370
is DocumentDB is a multi-tenant service.

00:04:51,370 --> 00:04:54,026
We do need to govern the resources to make sure one tenant doesn't

00:04:54,026 --> 00:04:55,489
cause problems for other tenants.

00:04:55,489 --> 00:04:56,173
>> Right.

00:04:56,173 --> 00:05:00,597
>> And so what we do is we actually bound the execution of the stored

00:05:00,597 --> 00:05:04,310
procedures to a set number of CPU and time.

00:05:04,310 --> 00:05:05,215
And in order to do,

00:05:05,215 --> 00:05:08,332
let's say long running transactions, if you want to go beyond,

00:05:08,332 --> 00:05:11,409
we gave you plenty of budget for most day-to-day operations.

00:05:11,409 --> 00:05:12,056
>> Mm-hm. >> But

00:05:12,056 --> 00:05:14,588
if you wanna do something very, very sizeable,

00:05:14,588 --> 00:05:17,386
what we do is we ask you to build a continuation model.

00:05:17,386 --> 00:05:18,131
>> Mm-hm.

00:05:18,131 --> 00:05:21,267
>> An example of a continuation model is let's say I want to delete

00:05:21,267 --> 00:05:24,370
a very, very large set of documents transactionally.

00:05:24,370 --> 00:05:26,273
>> Right. >> What I might do here is I

00:05:26,273 --> 00:05:27,573
will delete a set,

00:05:27,573 --> 00:05:32,063
I will then return a Boolean back to the client side application.

00:05:32,063 --> 00:05:35,242
And at the client side application sees that that Boolean is true and

00:05:35,242 --> 00:05:37,695
knows hey, that's a signal that I didn't finish,

00:05:37,695 --> 00:05:39,605
I'm going to run this again.

00:05:39,605 --> 00:05:42,145
Now if the Boolean returns false,

00:05:42,145 --> 00:05:45,745
that means there's actually more time and CPU budgeted for

00:05:45,745 --> 00:05:47,855
this execution so you can continue running.

00:05:47,855 --> 00:05:51,351
>> So you're chunking those big operations?

00:05:51,351 --> 00:05:52,675
Is that what you do?

00:05:52,675 --> 00:05:53,592
You're chunking them? >> Yeah.

00:05:53,592 --> 00:05:54,938
>> Let's say I have a million to do, and

00:05:54,938 --> 00:05:57,377
we'll do them 10,000 at a time or 100,000 at a time.

00:05:57,377 --> 00:05:58,015
>> That's correct.

00:05:58,015 --> 00:06:01,119
>> And if the whole thing failed on the last page,

00:06:01,119 --> 00:06:03,275
would it roll back everything?

00:06:03,275 --> 00:06:07,689
>> No, so that is something to build into your continuation model.

00:06:07,689 --> 00:06:11,293
And there are techniques for doing this but basically each run of

00:06:11,293 --> 00:06:15,109
the stored procedure, that gets applied transactionally.

00:06:15,109 --> 00:06:15,835
>> Okay. >> And

00:06:15,835 --> 00:06:19,770
just to kinda make this as a signal for the user to know when did

00:06:19,770 --> 00:06:23,253
I need to kick out and return a message to the clients.

00:06:23,253 --> 00:06:24,019
>> Mm-hm.

00:06:24,019 --> 00:06:28,095
>> Each of these crowd operations return this true/false Boolean as

00:06:28,095 --> 00:06:29,510
accepted.

00:06:29,510 --> 00:06:35,230
And what I do here is if a crowd operation was not accepted

00:06:35,230 --> 00:06:37,870
then if I throw an exception, this is the signal to roll back.

00:06:37,870 --> 00:06:39,691
Whenever an exception is thrown,

00:06:39,691 --> 00:06:42,970
all of the logic within the stored procedures is rolled back.

00:06:42,970 --> 00:06:43,692
>> Mm-hm.

00:06:43,692 --> 00:06:46,770
>> And this can be really nice for doing some validation.

00:06:46,770 --> 00:06:49,930
So an example is if I've already created that review document in

00:06:49,930 --> 00:06:52,880
the function above, let's say now I wanna update the product document

00:06:52,880 --> 00:06:54,390
and I couldn't find it.

00:06:54,390 --> 00:06:57,860
Rather than having this dangling review document, I can now just roll

00:06:57,860 --> 00:07:01,290
this back and say, hey, ignore everything I've done in here, I'm

00:07:01,290 --> 00:07:05,350
gonna fail this, I wanna roll back because of this validation check.

00:07:05,350 --> 00:07:06,710
>> And to make sure I get the language right, and

00:07:06,710 --> 00:07:07,510
people understand as well.

00:07:07,510 --> 00:07:09,995
When we say roll back, it's as if it never happened.

00:07:09,995 --> 00:07:12,133
These aren't compensating transactions, right?

00:07:12,133 --> 00:07:12,910
>> Right, right.

00:07:12,910 --> 00:07:16,294
>> If I'm adding something like if I'm doing finance,

00:07:16,294 --> 00:07:19,044
if I'm transferring money- >> Mm-hm.

00:07:19,044 --> 00:07:21,650
>> And that fails, it's like it never happened at all.

00:07:21,650 --> 00:07:22,780
It's not that it failed and

00:07:22,780 --> 00:07:25,660
then I transferred it back with a compensating transaction.

00:07:25,660 --> 00:07:26,430
>> That's correct.

00:07:26,430 --> 00:07:29,271
So at the beginning of the execution in the stored procedure,

00:07:29,271 --> 00:07:31,956
what we do is we actually take a snapshot of your database.

00:07:31,956 --> 00:07:32,501
>> Mm.

00:07:32,501 --> 00:07:34,570
>> And then at the end of, when it completes,

00:07:34,570 --> 00:07:37,042
let's say you don't wanna fail it or roll it back,

00:07:37,042 --> 00:07:39,132
you don't throw an exception- >> Mm-hm.

00:07:39,132 --> 00:07:41,374
>> What we do is we apply all of those mutations all at once at

00:07:41,374 --> 00:07:42,439
the end of the execution.

00:07:42,439 --> 00:07:43,742
So that's the equivalent to a commit.

00:07:43,742 --> 00:07:44,483
>> Very cool.

00:07:44,483 --> 00:07:46,946
>> Yeah.

00:07:46,946 --> 00:07:51,420
Now, some things to also note about this in terms of just best

00:07:51,420 --> 00:07:52,540
practices.

00:07:52,540 --> 00:07:55,480
I have seen a lot of folks if you're coming from let's say

00:07:55,480 --> 00:07:58,900
a Java background like I came from or .NET background.

00:07:58,900 --> 00:08:02,960
You might not be used to the control flow of JavaScript, and

00:08:02,960 --> 00:08:06,540
JavaScript, I mean really embraces async operations, right?

00:08:06,540 --> 00:08:10,630
And so one of the main things to point out, I think

00:08:10,630 --> 00:08:13,543
if you're new to JavaScript and new to writing stored procedures,

00:08:13,543 --> 00:08:17,540
is make sure that when you do the control flow for

00:08:17,540 --> 00:08:20,300
the script, make sure that you line it up in call backs.

00:08:20,300 --> 00:08:23,670
Don't fire a bunch of async operations all at once.

00:08:23,670 --> 00:08:24,632
>> Mm-hm.

00:08:24,632 --> 00:08:27,875
If you're bounding your CPU, then those async operations will

00:08:27,875 --> 00:08:31,117
just fly away and then eventually you'll just slap them down and

00:08:31,117 --> 00:08:33,690
you won't know whether they happened or not?

00:08:33,690 --> 00:08:35,262
>> Right. So it'd be very hard to control

00:08:35,262 --> 00:08:37,035
the IO and understand what's going on.

00:08:37,035 --> 00:08:40,277
So in this case if you wanna perform this IO sequentially,

00:08:40,277 --> 00:08:44,060
you'll want to make sure that you follow the call back convention.

00:08:44,060 --> 00:08:45,187
>> Mm-hm.

00:08:45,187 --> 00:08:46,707
>> As a matter of chance,

00:08:46,707 --> 00:08:50,237
since this is implemented actually on ChakraCore.

00:08:50,237 --> 00:08:54,000
>> ChakraCore, the open source JavaScript library that we use.

00:08:54,000 --> 00:08:55,146
>> Yes.

00:08:55,146 --> 00:08:57,109
The JavaScript runtime that we use.

00:08:57,109 --> 00:09:01,879
We have full ES6 compatibility so should you wanna use premises or

00:09:01,879 --> 00:09:04,690
something else to alter the control for

00:09:04,690 --> 00:09:07,430
any of the other ES6 functionality.

00:09:07,430 --> 00:09:10,970
Which I think is really awesome in the JavaScript world.

00:09:10,970 --> 00:09:16,240
We do have that available, and one of the other cool things

00:09:16,240 --> 00:09:20,870
about this is our JavaScript runtime isn't just for stored procedures,

00:09:20,870 --> 00:09:23,630
we gave you transaction semantics around triggers.

00:09:23,630 --> 00:09:27,311
So if you wanna apply let's say a JavaScript script attached to

00:09:27,311 --> 00:09:31,270
a crowd operation, and this might be updating let's say a metadata

00:09:31,270 --> 00:09:34,834
document and you want to have that happen transactionally.

00:09:34,834 --> 00:09:35,522
>> Mm-hm.

00:09:35,522 --> 00:09:38,677
>> Or if you wanna do user defined functions and

00:09:38,677 --> 00:09:43,900
augment our query language, we also let you use the JS Runtime for that.

00:09:43,900 --> 00:09:47,290
So, an example is in the product catalog I had a bunch of documents

00:09:47,290 --> 00:09:48,890
which had a weight.

00:09:48,890 --> 00:09:50,280
Those weights were in grams.

00:09:50,280 --> 00:09:52,375
And let's say I wanna present back to the user in a product

00:09:52,375 --> 00:09:52,949
listing page.

00:09:52,949 --> 00:09:53,725
>> Mm-hm.

00:09:53,725 --> 00:09:55,830
>> I want to show them this in pounds.

00:09:55,830 --> 00:09:59,000
I can do this conversion and then embed this into a SQL query.

00:09:59,000 --> 00:10:01,690
>> And now anyone who's in that collection can use that

00:10:01,690 --> 00:10:04,260
in their stored procedures and build on it, and whatever.

00:10:04,260 --> 00:10:05,651
>> Yes. >> So your developers could build

00:10:05,651 --> 00:10:08,456
a whole library of user defined functions that they could all then

00:10:08,456 --> 00:10:10,310
exploit within their stored procedures.

00:10:10,310 --> 00:10:10,910
>> Yes.

00:10:10,910 --> 00:10:13,310
So that's all getting embedded in the SQL query.

00:10:13,310 --> 00:10:15,420
And then as part of the stored procedure,

00:10:15,420 --> 00:10:18,860
you can run these SQL queries, and so you can include the UDF if

00:10:18,860 --> 00:10:22,610
you choose to, as part of the select clause or the where clause, yeah.

00:10:22,610 --> 00:10:25,480
>> This seems such a nice compromise.

00:10:25,480 --> 00:10:28,358
And I don't mean compromise in an everyone loses way, but

00:10:28,358 --> 00:10:31,885
literally everyone wins, cuz you've got enterprise developers with

00:10:31,885 --> 00:10:34,783
a familiarity for things like stored procs, UDFs, SQL.

00:10:34,783 --> 00:10:35,502
>> Mm-hm.

00:10:35,502 --> 00:10:37,753
>> And you've got the new generation of people that wanna push

00:10:37,753 --> 00:10:39,869
JSON around, they want it on structured database, and

00:10:39,869 --> 00:10:41,682
they want world scale and they want it for free.

00:10:41,682 --> 00:10:42,321
>> Mm.

00:10:42,321 --> 00:10:44,506
>> You're giving, for lack of a better world,

00:10:44,506 --> 00:10:46,633
both the young people and the older people,

00:10:46,633 --> 00:10:50,460
what they want to make applications that are gonna run at huge scale.

00:10:50,460 --> 00:10:51,160
>> Yes.

00:10:51,160 --> 00:10:52,824
And speaking of world scale,

00:10:52,824 --> 00:10:56,347
I mean one of the things that DocumentDB has really cool is all of

00:10:56,347 --> 00:11:00,160
the partitioning is built into the server side itself.

00:11:00,160 --> 00:11:02,041
All of the partitions are transparent, right?

00:11:02,041 --> 00:11:02,692
>> Mm-hm.

00:11:02,692 --> 00:11:04,910
>> All you need to define is a partition key.

00:11:04,910 --> 00:11:08,120
One thing to note about stored procedures is we do need to

00:11:08,120 --> 00:11:11,230
have some scope on where that transaction runs.

00:11:11,230 --> 00:11:14,230
And so we scope these two with the partition key.

00:11:14,230 --> 00:11:15,960
So when you make a request from the SDK,

00:11:15,960 --> 00:11:20,210
what you wanna do is put into the request options what partition key

00:11:20,210 --> 00:11:21,615
you wanna run this transaction on.

00:11:21,615 --> 00:11:23,093
>> Mm-hm. >> And that is the scope for

00:11:23,093 --> 00:11:24,020
the transaction.

00:11:25,960 --> 00:11:28,795
Something that then call out from that is as a user, when you're

00:11:28,795 --> 00:11:31,631
thinking about how you wanna partition your data to really kinda

00:11:31,631 --> 00:11:33,930
leverage this scale out capability- >> Mm-hm.

00:11:33,930 --> 00:11:37,290
>> Is your choice of partition key should reflect what kinda

00:11:37,290 --> 00:11:39,710
transactions you wanna do.

00:11:39,710 --> 00:11:41,620
So in the context of, let's say, a product catalog,

00:11:41,620 --> 00:11:44,210
I know that I can scale out

00:11:44,210 --> 00:11:47,800
perhaps by choosing a partition on maybe the product category.

00:11:47,800 --> 00:11:50,670
I know that my transaction scope will fit within

00:11:50,670 --> 00:11:52,182
that product category.

00:11:52,182 --> 00:11:54,676
Let's say I'm just reviewing a single product and

00:11:54,676 --> 00:11:57,670
creating review documents, that'll fit well.

00:11:57,670 --> 00:12:00,538
But this is a design consideration you'll wanna think about up front.

00:12:00,538 --> 00:12:04,556
So I guess I'll walk you through this stored procedure.

00:12:04,556 --> 00:12:08,203
Run it and kinda just call some things out.

00:12:08,203 --> 00:12:10,512
>> Yeah, well let's see it run as we end here.

00:12:10,512 --> 00:12:15,029
>> So I basically created two functions.

00:12:15,029 --> 00:12:17,071
One to create a doc, one to update a doc.

00:12:17,071 --> 00:12:20,615
>> Mm-hm. >> Fairly straightforward.

00:12:20,615 --> 00:12:23,496
>> You're using different objects like collection of those objects

00:12:23,496 --> 00:12:25,408
just intrinsic and just available always?

00:12:25,408 --> 00:12:27,421
>> Say that one more time?

00:12:27,421 --> 00:12:28,793
>> For example, scroll down this page.

00:12:28,793 --> 00:12:29,670
>> Yes. >> You said,

00:12:29,670 --> 00:12:31,114
collection.createDocument.

00:12:31,114 --> 00:12:31,972
Where is collection coming from?

00:12:31,972 --> 00:12:32,912
>> Yes.

00:12:32,912 --> 00:12:37,111
So all the crowd operations come from a context object.

00:12:37,111 --> 00:12:37,909
>> There it is.

00:12:37,909 --> 00:12:41,775
>> And so the way the API is, is you can get the current collection and

00:12:41,775 --> 00:12:45,020
this will reveal all of the crowd and query operators.

00:12:45,020 --> 00:12:46,564
>> Mm-hm. >> You can also get the response and

00:12:46,564 --> 00:12:49,660
this is where you can change the response and say hey, this is what I

00:12:49,660 --> 00:12:52,810
want returned at the end of the execution of this stored proc.

00:12:52,810 --> 00:12:54,690
>> Cool and we can run it and test it right here?

00:12:54,690 --> 00:12:57,805
>> Yes, so let me grab a product real quick from our product catalog

00:12:57,805 --> 00:12:59,026
and let's add a review.

00:12:59,026 --> 00:12:59,688
>> Yeah.

00:13:03,533 --> 00:13:05,623
>> So let's say I wanna review this helmet.

00:13:05,623 --> 00:13:08,931
And the product number HL-U509,

00:13:08,931 --> 00:13:14,005
this is what my stored procedure is expecting in the body.

00:13:14,005 --> 00:13:14,539
>> All right.

00:13:14,539 --> 00:13:15,793
>> Or in the parameter.

00:13:15,793 --> 00:13:18,988
I go to reviewProduct.

00:13:18,988 --> 00:13:24,560
I will go down here to- >> Little

00:13:24,560 --> 00:13:26,747
challenging on a small screen.

00:13:26,747 --> 00:13:27,326
>> Yes.

00:13:27,326 --> 00:13:29,125
>> Looks fine on a big screen.

00:13:29,125 --> 00:13:31,250
>> Looks good on a higher resolution.

00:13:31,250 --> 00:13:32,522
[LAUGH] >> Yep, all right, so

00:13:32,522 --> 00:13:33,327
there's your inputs.

00:13:33,327 --> 00:13:38,111
>> So our inputs, what we're expecting here is a product number.

00:13:38,111 --> 00:13:42,840
The reviewer, so we're gonna say Scott really loves this helmet.

00:13:42,840 --> 00:13:47,273
He's gonna give it a 10 out of 10, and he's saying this thing rocks.

00:13:51,766 --> 00:13:54,505
Oops.

00:13:54,505 --> 00:13:55,607
Hit Execute.

00:13:55,607 --> 00:13:59,620
And assuming that I got all the inputs right,

00:13:59,620 --> 00:14:02,159
what we'll see here below.

00:14:02,159 --> 00:14:04,653
There is the response.

00:14:04,653 --> 00:14:07,678
So what we've done is we've created a review object,

00:14:07,678 --> 00:14:09,924
as well as we've updated that product.

00:14:09,924 --> 00:14:10,598
>> Yeah.

00:14:10,598 --> 00:14:13,050
>> And so in the product itself, what you'll see here-

00:14:13,050 --> 00:14:14,488
>> There it is.

00:14:14,488 --> 00:14:15,988
>> As part of it is the new score.

00:14:15,988 --> 00:14:17,900
So we've added a review.

00:14:17,900 --> 00:14:19,650
We calculated the new score.

00:14:19,650 --> 00:14:21,930
And this is kind of the beauty of JavaScript, right?

00:14:21,930 --> 00:14:24,160
It's a full blown programming language.

00:14:24,160 --> 00:14:27,567
You can have fairly complex logic within this.

00:14:27,567 --> 00:14:28,243
>> Very cool.

00:14:28,243 --> 00:14:28,890
>> Yeah. >> Well,

00:14:28,890 --> 00:14:31,180
we're learning all about stored procedures at world scale.

00:14:31,180 --> 00:14:35,153
With Azure DocumentDB, here on Azure Friday.

00:14:35,153 --> 00:14:38,892

YouTube URL: https://www.youtube.com/watch?v=GSQDcI3zJ4g


