Title: OCTO Speaker Series Episode 2: John Hughes
Publication date: 2020-10-15
Playlist: OCTO Speaker Series
Description: 
	Experiences with QuickCheck: Testing the Hard Stuff

If you've ever wondered whether there is a better way to test software than by writing and maintaining thousands of test cases, then this talk is for you. I'll explain "property-based testing", which combines test case generation, test case simplification, and using properties to specify your code. I'll show you what you need to think about to make it work in practice, and tell you tales of some of our more entertaining bugs.

About John Hughes
I've loved functional programming all my career; I wrote "Why Functional Programming Matters", a manifesto for the field, way back in the eighties. I urged lazy evaluation on John Backus (but failed to persuade him). I was a co-designer of Haskell. I moved to Sweden, home of the Lazy ML compiler, in the nineties, and at the turn of the millennium I co-invented property-based testing. I co-founded a startup in 2006 to bring PBT to industry, and I've learned to love (other peoples') buggy software! My motto: "make hard things easy with functional programming".

Twitter: @rjmh
GitHub: rjmh
Web: http://www.cse.chalmers.se/~rjmh/

Learn more about the OCTO Speaker series here: https://octo.github.com/
Captions: 
	00:00:06,860 --> 00:00:13,599
[Music]

00:00:11,920 --> 00:00:15,839
hello everybody

00:00:13,599 --> 00:00:19,039
welcome to this webinar organized by the

00:00:15,839 --> 00:00:21,279
office of the cto at github

00:00:19,039 --> 00:00:23,439
today it's my pleasure to introduce john

00:00:21,279 --> 00:00:26,720
news professor of computer science

00:00:23,439 --> 00:00:28,320
at the university of chelmas like many

00:00:26,720 --> 00:00:28,960
computer science students in the late

00:00:28,320 --> 00:00:31,279
80s

00:00:28,960 --> 00:00:32,480
i was personally deeply influenced by

00:00:31,279 --> 00:00:35,360
john's paper

00:00:32,480 --> 00:00:37,200
by functional programming methods

00:00:35,360 --> 00:00:38,640
instead of merely preaching the merits

00:00:37,200 --> 00:00:39,840
of technical features of functional

00:00:38,640 --> 00:00:42,160
languages

00:00:39,840 --> 00:00:43,360
the paper clearly demonstrated their

00:00:42,160 --> 00:00:45,760
practical benefits

00:00:43,360 --> 00:00:48,480
and it convinced many of us to pursue a

00:00:45,760 --> 00:00:51,039
career in programming languages

00:00:48,480 --> 00:00:53,280
indeed without john's inspiration i

00:00:51,039 --> 00:00:56,640
wouldn't be at github today so

00:00:53,280 --> 00:00:58,399
very much thanks for that john

00:00:56,640 --> 00:00:59,840
john continues to push the boundaries of

00:00:58,399 --> 00:01:02,640
programming language technology

00:00:59,840 --> 00:01:04,720
in particular as the ceo of cubic which

00:01:02,640 --> 00:01:07,840
offers products and services

00:01:04,720 --> 00:01:10,400
around property-based testing

00:01:07,840 --> 00:01:10,880
it is a powerful technique that deserves

00:01:10,400 --> 00:01:14,000
to be

00:01:10,880 --> 00:01:16,479
much better known than it is today uh

00:01:14,000 --> 00:01:18,479
he's going to tell us more about it

00:01:16,479 --> 00:01:20,799
before he does that a few housekeeping

00:01:18,479 --> 00:01:23,759
remarks if you have questions for john

00:01:20,799 --> 00:01:24,880
please use the q a feature of the go to

00:01:23,759 --> 00:01:27,600
webinar

00:01:24,880 --> 00:01:28,960
app to post these we'll collect them

00:01:27,600 --> 00:01:31,520
throughout the session

00:01:28,960 --> 00:01:32,479
and at the end john will answer as many

00:01:31,520 --> 00:01:38,000
of these live

00:01:32,479 --> 00:01:38,000
as possible john please take it away

00:01:39,600 --> 00:01:43,040
okay thank you for the introduction

00:01:41,200 --> 00:01:45,920
again so

00:01:43,040 --> 00:01:46,960
i hope you can all see my slide i am

00:01:45,920 --> 00:01:48,320
actually physically

00:01:46,960 --> 00:01:51,119
in the west of sweden this is what it

00:01:48,320 --> 00:01:52,880
looks like um but i'm going to tell you

00:01:51,119 --> 00:01:54,799
about some adventures with

00:01:52,880 --> 00:01:58,079
property-based testing

00:01:54,799 --> 00:02:01,119
so for a start what is it

00:01:58,079 --> 00:02:02,799
i want to kick off with a small example

00:02:01,119 --> 00:02:04,399
here's the code you don't have to read

00:02:02,799 --> 00:02:07,600
it it's a little bit of c

00:02:04,399 --> 00:02:08,959
code and what it does is it implements a

00:02:07,600 --> 00:02:12,239
queue

00:02:08,959 --> 00:02:14,720
as a circular buffer so i'll

00:02:12,239 --> 00:02:15,680
show you the api uh just to show you

00:02:14,720 --> 00:02:17,840
what it does

00:02:15,680 --> 00:02:18,959
and i'd like to do that interactively in

00:02:17,840 --> 00:02:22,480
a rebel

00:02:18,959 --> 00:02:25,920
c doesn't have a does the replica

00:02:22,480 --> 00:02:26,640
so let me just um do a simulated demo on

00:02:25,920 --> 00:02:29,680
the slide

00:02:26,640 --> 00:02:30,959
and and show you what the api does so

00:02:29,680 --> 00:02:33,760
this is the adlang

00:02:30,959 --> 00:02:34,879
rapple uh the 24 the black stuff is the

00:02:33,760 --> 00:02:36,720
prompt ignore it

00:02:34,879 --> 00:02:39,040
the orange stuff is what i typed and

00:02:36,720 --> 00:02:40,879
here i've called the new function

00:02:39,040 --> 00:02:43,120
to create a queue with space for four

00:02:40,879 --> 00:02:43,840
elements and the green stuff is the

00:02:43,120 --> 00:02:46,480
response

00:02:43,840 --> 00:02:48,000
i get back the address okay so what can

00:02:46,480 --> 00:02:50,959
i do with a key once i've got one

00:02:48,000 --> 00:02:52,640
well i can put data into it this queue

00:02:50,959 --> 00:02:55,840
holds integer so let's put one

00:02:52,640 --> 00:02:57,680
let's put two um then i can ask

00:02:55,840 --> 00:02:59,920
how many items are in the queue well

00:02:57,680 --> 00:03:02,159
obviously two right so i call the size

00:02:59,920 --> 00:03:03,599
function and that returns two

00:03:02,159 --> 00:03:05,200
and i can take things out of the queue

00:03:03,599 --> 00:03:08,800
again um

00:03:05,200 --> 00:03:11,040
i'll get i get the one i get the two

00:03:08,800 --> 00:03:12,800
i get uninitialized memory i get some

00:03:11,040 --> 00:03:14,959
more uninitialized memory

00:03:12,800 --> 00:03:17,120
i get the one and the two again remember

00:03:14,959 --> 00:03:20,080
it's a circular buffer

00:03:17,120 --> 00:03:20,879
um so it behaves exactly as you would

00:03:20,080 --> 00:03:23,760
expect

00:03:20,879 --> 00:03:26,879
c code with no error checking to behave

00:03:23,760 --> 00:03:29,200
that's fine you can see that it works

00:03:26,879 --> 00:03:30,640
so that's a little live demo as it were

00:03:29,200 --> 00:03:32,239
of what the code does

00:03:30,640 --> 00:03:33,680
but of course i would also like to have

00:03:32,239 --> 00:03:35,760
tests for this code

00:03:33,680 --> 00:03:37,599
and uh one thing i can do is just take

00:03:35,760 --> 00:03:38,879
these calls and turn them into an

00:03:37,599 --> 00:03:40,480
automated test

00:03:38,879 --> 00:03:42,959
and just put them into an outline

00:03:40,480 --> 00:03:44,000
function now maybe i don't want to

00:03:42,959 --> 00:03:46,720
include

00:03:44,000 --> 00:03:48,239
the calls that read uninitialized memory

00:03:46,720 --> 00:03:50,239
i was really abusing the api

00:03:48,239 --> 00:03:51,599
there but if i take the others i can put

00:03:50,239 --> 00:03:54,319
them into a little function

00:03:51,599 --> 00:03:55,519
that just makes those calls and then

00:03:54,319 --> 00:03:57,200
matches the result

00:03:55,519 --> 00:03:58,879
against the expected value if any

00:03:57,200 --> 00:04:01,840
function returns a different result

00:03:58,879 --> 00:04:01,840
then the test will fail

00:04:03,280 --> 00:04:06,319
the one interesting thing i want to

00:04:04,720 --> 00:04:10,480
point out about this

00:04:06,319 --> 00:04:11,680
very simple test case is it covers 100

00:04:10,480 --> 00:04:13,680
of the code

00:04:11,680 --> 00:04:14,959
that's great i've got 100 branch

00:04:13,680 --> 00:04:16,239
coverage

00:04:14,959 --> 00:04:18,079
which is quite easy because there aren't

00:04:16,239 --> 00:04:21,040
any branches here but

00:04:18,079 --> 00:04:22,160
nevertheless it covers 100 of the code

00:04:21,040 --> 00:04:25,520
so that's great right

00:04:22,160 --> 00:04:28,320
so i've got simple program seems to work

00:04:25,520 --> 00:04:29,919
and i've got excellent testing for it so

00:04:28,320 --> 00:04:34,240
i'm done

00:04:29,919 --> 00:04:36,000
or am i the way i like to test code is

00:04:34,240 --> 00:04:38,880
not like this of course

00:04:36,000 --> 00:04:41,440
it's using property based tests so let

00:04:38,880 --> 00:04:43,759
me show you what happens when i do that

00:04:41,440 --> 00:04:45,360
i call our property-based testing tool

00:04:43,759 --> 00:04:46,960
quick check to do so

00:04:45,360 --> 00:04:49,120
and i have to give it a property of the

00:04:46,960 --> 00:04:49,759
code i'm not going to show you this uh

00:04:49,120 --> 00:04:51,680
test code

00:04:49,759 --> 00:04:53,280
i'll explain a little bit what it looks

00:04:51,680 --> 00:04:56,479
like but let's just see what happens

00:04:53,280 --> 00:04:58,479
when we run these tests

00:04:56,479 --> 00:05:00,880
quick check starts generating random

00:04:58,479 --> 00:05:03,759
test cases and whoops

00:05:00,880 --> 00:05:05,680
one of them failed so it looks as though

00:05:03,759 --> 00:05:08,800
the code isn't quite as good as

00:05:05,680 --> 00:05:10,320
um as i gave the impression earlier when

00:05:08,800 --> 00:05:13,360
the test fails

00:05:10,320 --> 00:05:16,479
it's a randomly generated test case it's

00:05:13,360 --> 00:05:17,840
large it goes on and on and on and i

00:05:16,479 --> 00:05:19,520
think the one thing you can conclude

00:05:17,840 --> 00:05:22,240
about that is you don't want to use that

00:05:19,520 --> 00:05:22,720
as a starting point for debugging but no

00:05:22,240 --> 00:05:24,800
problem

00:05:22,720 --> 00:05:26,560
because the next thing quick check does

00:05:24,800 --> 00:05:28,639
is shrink the test case

00:05:26,560 --> 00:05:30,800
so called that is try and simplify it

00:05:28,639 --> 00:05:32,880
exactly what you would do manually

00:05:30,800 --> 00:05:35,759
every time you get a failed test that is

00:05:32,880 --> 00:05:38,160
more complicated than it needs to be

00:05:35,759 --> 00:05:40,240
and the result of shrinking is that we

00:05:38,160 --> 00:05:42,479
end up with a much smaller

00:05:40,240 --> 00:05:43,600
uh in a sense a minimal test case that

00:05:42,479 --> 00:05:45,840
has failed

00:05:43,600 --> 00:05:47,919
and this is the output that i got and

00:05:45,840 --> 00:05:50,800
the bit i wanted to look at on the slide

00:05:47,919 --> 00:05:52,639
is highlighted in yellow now so this

00:05:50,800 --> 00:05:55,039
just shows the sequence of steps

00:05:52,639 --> 00:05:56,720
that the test case performed and we can

00:05:55,039 --> 00:05:59,039
see what went wrong

00:05:56,720 --> 00:06:01,039
so let's look at it what happened first

00:05:59,039 --> 00:06:04,639
of all i created a queue

00:06:01,039 --> 00:06:08,000
with space for one element okay

00:06:04,639 --> 00:06:08,800
then i put something into it okay that's

00:06:08,000 --> 00:06:10,880
fine

00:06:08,800 --> 00:06:12,880
now the queue is full uh there's one

00:06:10,880 --> 00:06:15,840
thing in it and then i asked how many

00:06:12,880 --> 00:06:15,840
items are in the queue

00:06:16,400 --> 00:06:22,400
i got zero okay that's clearly wrong

00:06:20,400 --> 00:06:25,600
and so a post condition in my property

00:06:22,400 --> 00:06:28,800
will fail that's why the test failed

00:06:25,600 --> 00:06:29,360
so um now we have a little example we

00:06:28,800 --> 00:06:31,280
can just

00:06:29,360 --> 00:06:33,680
work through this example look at the

00:06:31,280 --> 00:06:35,600
code and see if we can debug it

00:06:33,680 --> 00:06:38,720
okay what happened first first i created

00:06:35,600 --> 00:06:41,680
a queue of size one

00:06:38,720 --> 00:06:44,240
and um what i did with that parameter to

00:06:41,680 --> 00:06:46,000
knew was i saved it in the size field

00:06:44,240 --> 00:06:47,840
of the data structure again you don't

00:06:46,000 --> 00:06:50,720
need to read the code but just remember

00:06:47,840 --> 00:06:52,560
the size field is one and then at the

00:06:50,720 --> 00:06:53,360
end of the test i called the size

00:06:52,560 --> 00:06:55,759
function

00:06:53,360 --> 00:06:57,280
to see how many items are in the queue

00:06:55,759 --> 00:06:59,840
and

00:06:57,280 --> 00:07:01,039
here's the code for that look i'm taking

00:06:59,840 --> 00:07:03,360
the difference between

00:07:01,039 --> 00:07:04,720
an input position at an output position

00:07:03,360 --> 00:07:08,720
same sounds reasonable

00:07:04,720 --> 00:07:12,880
modulo the size but the size

00:07:08,720 --> 00:07:17,280
is one every number modulo one

00:07:12,880 --> 00:07:20,800
is zero that's why this doesn't work

00:07:17,280 --> 00:07:24,319
this size function can only return zero

00:07:20,800 --> 00:07:25,120
when the size is one so so of course it

00:07:24,319 --> 00:07:26,880
doesn't work

00:07:25,120 --> 00:07:28,319
actually the situation is worse than

00:07:26,880 --> 00:07:29,039
that because if i look at the code for

00:07:28,319 --> 00:07:32,639
putting something

00:07:29,039 --> 00:07:33,120
in the other part of the test we can see

00:07:32,639 --> 00:07:35,120
that

00:07:33,120 --> 00:07:37,840
it writes some data into a buffer and

00:07:35,120 --> 00:07:40,880
that it increments this input position

00:07:37,840 --> 00:07:43,039
modulo the size modulo 1

00:07:40,880 --> 00:07:44,319
and that means that that is also going

00:07:43,039 --> 00:07:46,479
to remain at zero

00:07:44,319 --> 00:07:47,440
i have a little animation to show us

00:07:46,479 --> 00:07:49,039
what happened

00:07:47,440 --> 00:07:51,120
i've got a buffer and i've got this

00:07:49,039 --> 00:07:53,520
input and output pointer into it

00:07:51,120 --> 00:07:55,759
i put something in increment the input

00:07:53,520 --> 00:08:00,160
pointer

00:07:55,759 --> 00:08:02,000
modulo one and now the buffer is full

00:08:00,160 --> 00:08:04,319
but those input and output pointers are

00:08:02,000 --> 00:08:06,240
exactly where they were at the beginning

00:08:04,319 --> 00:08:07,919
so here's the problem the code doesn't

00:08:06,240 --> 00:08:10,400
work because a full buffer

00:08:07,919 --> 00:08:11,919
looks exactly like an empty one and if

00:08:10,400 --> 00:08:13,599
you think about it this isn't just a

00:08:11,919 --> 00:08:15,520
problem when the size is one

00:08:13,599 --> 00:08:16,639
if i had a buffer at any size and filled

00:08:15,520 --> 00:08:18,319
it completely

00:08:16,639 --> 00:08:20,000
the input pointer would wrap back to the

00:08:18,319 --> 00:08:21,919
beginning and

00:08:20,000 --> 00:08:23,919
so the full buffer looks like an empty

00:08:21,919 --> 00:08:26,080
buffer

00:08:23,919 --> 00:08:27,840
so i've got to fix the code now and i

00:08:26,080 --> 00:08:30,879
have to fix this problem

00:08:27,840 --> 00:08:32,479
and i'm going to do it using a very nice

00:08:30,879 --> 00:08:34,959
hack

00:08:32,479 --> 00:08:35,919
it's very clever the problem only

00:08:34,959 --> 00:08:38,159
appears

00:08:35,919 --> 00:08:39,599
when the buffer becomes entirely full

00:08:38,159 --> 00:08:41,919
right

00:08:39,599 --> 00:08:42,719
so what i'm going to do when i'm asked

00:08:41,919 --> 00:08:46,480
to create

00:08:42,719 --> 00:08:48,560
a buffer of size n but under the hood

00:08:46,480 --> 00:08:50,720
i'm going to create a buffer of size n

00:08:48,560 --> 00:08:54,000
plus 1

00:08:50,720 --> 00:08:57,279
and now when i do that the bug can only

00:08:54,000 --> 00:08:58,399
appear if somebody tries to put n plus

00:08:57,279 --> 00:09:01,519
one things

00:08:58,399 --> 00:09:01,920
into a buffer of size n and if they do

00:09:01,519 --> 00:09:05,279
that

00:09:01,920 --> 00:09:09,600
that's their fault not mine

00:09:05,279 --> 00:09:12,640
and so i claim my code works

00:09:09,600 --> 00:09:14,080
so if i make this change then i can

00:09:12,640 --> 00:09:17,360
rerun the last test

00:09:14,080 --> 00:09:18,240
like this uh eqc check saves the last

00:09:17,360 --> 00:09:20,240
test and

00:09:18,240 --> 00:09:22,160
so it can be repeated and of course now

00:09:20,240 --> 00:09:24,720
it passes

00:09:22,160 --> 00:09:26,800
okay so the code wasn't as perfect as i

00:09:24,720 --> 00:09:29,440
thought i found one bug

00:09:26,800 --> 00:09:31,200
let's run some more random tests and see

00:09:29,440 --> 00:09:34,880
what happens

00:09:31,200 --> 00:09:37,680
okay so if i do that wow

00:09:34,880 --> 00:09:39,440
another test fails but once again the

00:09:37,680 --> 00:09:41,760
randomly generated one is huge we don't

00:09:39,440 --> 00:09:45,040
want to see it

00:09:41,760 --> 00:09:48,080
but after shrinking we end up with

00:09:45,040 --> 00:09:49,519
something which is again quite simple

00:09:48,080 --> 00:09:51,040
once again i want us to look at the

00:09:49,519 --> 00:09:53,760
yellow bit here that shows us what

00:09:51,040 --> 00:09:56,880
happened at the test

00:09:53,760 --> 00:09:59,839
so what did i do well i made

00:09:56,880 --> 00:10:02,640
a cue of size one again under the hood

00:09:59,839 --> 00:10:02,640
that's really two

00:10:02,800 --> 00:10:07,680
i put something in it's nice full i took

00:10:06,160 --> 00:10:10,240
it out

00:10:07,680 --> 00:10:11,920
put something in again now it's full it

00:10:10,240 --> 00:10:14,959
contains one item obviously

00:10:11,920 --> 00:10:18,079
and i asked for the size

00:10:14,959 --> 00:10:21,600
i got minus one what

00:10:18,079 --> 00:10:24,079
what is going on let me show you an

00:10:21,600 --> 00:10:27,279
animation of this example

00:10:24,079 --> 00:10:30,320
i put something in

00:10:27,279 --> 00:10:33,440
i took it out and that increments the

00:10:30,320 --> 00:10:36,079
output pointer i put

00:10:33,440 --> 00:10:36,640
something in again and now i've put two

00:10:36,079 --> 00:10:40,320
items

00:10:36,640 --> 00:10:43,120
into a circular buffer of size two so

00:10:40,320 --> 00:10:43,360
the input pointer wraps around and then

00:10:43,120 --> 00:10:45,120
i

00:10:43,360 --> 00:10:47,600
called the size function what did that

00:10:45,120 --> 00:10:49,040
do he took the difference between the

00:10:47,600 --> 00:10:51,519
input and output position

00:10:49,040 --> 00:10:53,200
modular the size let's just fill in the

00:10:51,519 --> 00:10:57,200
numbers

00:10:53,200 --> 00:11:00,959
that's zero minus one modulo two

00:10:57,200 --> 00:11:04,640
or minus one modulo two what is that

00:11:00,959 --> 00:11:09,279
-1 modulo 2 is plus 1.

00:11:04,640 --> 00:11:09,279
i know that i have a mathematics degree

00:11:10,000 --> 00:11:17,680
but in c minus 1 percent two

00:11:14,560 --> 00:11:19,839
is minus one because

00:11:17,680 --> 00:11:21,440
the percent sign in c is not

00:11:19,839 --> 00:11:24,480
mathematical modulus

00:11:21,440 --> 00:11:27,680
it's remainder and that's different when

00:11:24,480 --> 00:11:29,519
the first argument is negative so that's

00:11:27,680 --> 00:11:31,920
why i get a negative result from size

00:11:29,519 --> 00:11:34,240
which is clearly bonkers

00:11:31,920 --> 00:11:35,680
what i have to do is i have to make sure

00:11:34,240 --> 00:11:38,079
that that expression in the size

00:11:35,680 --> 00:11:39,360
function is never negative

00:11:38,079 --> 00:11:42,000
because i'll get the wrong answer if it

00:11:39,360 --> 00:11:42,640
is and of course there's an easy way to

00:11:42,000 --> 00:11:45,200
do that

00:11:42,640 --> 00:11:47,120
here let me patch it i'll just call the

00:11:45,200 --> 00:11:49,040
absolute value function

00:11:47,120 --> 00:11:51,120
right and then instead of taking minus

00:11:49,040 --> 00:11:53,279
one remainder two i'm

00:11:51,120 --> 00:11:55,519
taking plus one remainder two and the

00:11:53,279 --> 00:11:58,480
value will be plus one

00:11:55,519 --> 00:11:59,360
and if i make that fix in the size

00:11:58,480 --> 00:12:03,040
function

00:11:59,360 --> 00:12:06,480
like that and repeat the last test

00:12:03,040 --> 00:12:09,279
it passes that's great so now i want to

00:12:06,480 --> 00:12:11,760
think about what we've done

00:12:09,279 --> 00:12:12,959
i had found a bug in my code slightly

00:12:11,760 --> 00:12:15,440
softer one

00:12:12,959 --> 00:12:16,399
i created a test case to provoke that

00:12:15,440 --> 00:12:19,120
bug

00:12:16,399 --> 00:12:20,560
i patched my code i repeated the test

00:12:19,120 --> 00:12:25,279
now it passes

00:12:20,560 --> 00:12:28,160
all my tests are green i'm done right

00:12:25,279 --> 00:12:28,959
people might often think so but of

00:12:28,160 --> 00:12:31,040
course

00:12:28,959 --> 00:12:33,360
i don't trust a single test i like to

00:12:31,040 --> 00:12:36,839
generate them

00:12:33,360 --> 00:12:38,399
so let's run some more random tests what

00:12:36,839 --> 00:12:41,600
happens

00:12:38,399 --> 00:12:43,120
another failure and

00:12:41,600 --> 00:12:46,320
if we look at the shrunk test in this

00:12:43,120 --> 00:12:49,040
case it's a little bigger

00:12:46,320 --> 00:12:50,880
and it starts off by creating a queue

00:12:49,040 --> 00:12:53,600
with space for two elements instead of

00:12:50,880 --> 00:12:56,639
one why is that

00:12:53,600 --> 00:12:59,760
it's because cues of size one work now

00:12:56,639 --> 00:13:02,800
progress but this case

00:12:59,760 --> 00:13:03,760
of size two doesn't so we create a cue

00:13:02,800 --> 00:13:06,880
of size two

00:13:03,760 --> 00:13:08,160
under the hood that's really three what

00:13:06,880 --> 00:13:10,880
does the test case do

00:13:08,160 --> 00:13:11,680
it puts three things in that's going to

00:13:10,880 --> 00:13:14,480
make that in

00:13:11,680 --> 00:13:16,000
pointer wrap around it takes one thing

00:13:14,480 --> 00:13:19,519
out

00:13:16,000 --> 00:13:23,200
how many things are in the queue two

00:13:19,519 --> 00:13:25,920
what did the size function return one

00:13:23,200 --> 00:13:27,440
that's the problem and if i animate this

00:13:25,920 --> 00:13:31,440
for you

00:13:27,440 --> 00:13:34,480
you see i put one thing in i took it out

00:13:31,440 --> 00:13:35,680
i put another thing in i put a third

00:13:34,480 --> 00:13:38,959
thing in

00:13:35,680 --> 00:13:42,079
the pointer wrapped around and then i

00:13:38,959 --> 00:13:42,079
called the size function

00:13:42,320 --> 00:13:46,959
which takes this difference modulo size

00:13:45,120 --> 00:13:48,639
so that's what i started off doing and

00:13:46,959 --> 00:13:52,720
if i fill in the numbers

00:13:48,639 --> 00:13:55,600
that's computing minus one modulo three

00:13:52,720 --> 00:13:56,240
minus one modulo three mathematically is

00:13:55,600 --> 00:13:59,600
two

00:13:56,240 --> 00:14:01,600
that's the right answer but

00:13:59,600 --> 00:14:03,920
if i put in the absolute value function

00:14:01,600 --> 00:14:05,600
which worked for the previous example

00:14:03,920 --> 00:14:07,839
then of course it's going to turn the

00:14:05,600 --> 00:14:09,199
minus one into a plus one

00:14:07,839 --> 00:14:11,279
and so we get the wrong results and

00:14:09,199 --> 00:14:13,519
that's what's gone wrong my fix was

00:14:11,279 --> 00:14:16,639
buggy

00:14:13,519 --> 00:14:17,600
so my fixer i had thought correctly that

00:14:16,639 --> 00:14:20,320
i have to make sure

00:14:17,600 --> 00:14:21,600
that first argument of percent is uh

00:14:20,320 --> 00:14:24,480
never negative

00:14:21,600 --> 00:14:26,399
but abs is the wrong way to achieve that

00:14:24,480 --> 00:14:29,360
and luckily there's a different way

00:14:26,399 --> 00:14:30,880
what i can do instead is just add on the

00:14:29,360 --> 00:14:32,959
size

00:14:30,880 --> 00:14:34,480
and that's going to be enough it's three

00:14:32,959 --> 00:14:36,560
in this case to make sure that that

00:14:34,480 --> 00:14:38,639
first argument is negative negative

00:14:36,560 --> 00:14:40,079
but adding size doesn't change the value

00:14:38,639 --> 00:14:42,079
modular size

00:14:40,079 --> 00:14:43,440
and so i'll end up with the correct

00:14:42,079 --> 00:14:46,320
result

00:14:43,440 --> 00:14:47,279
if i repeat that last test of course it

00:14:46,320 --> 00:14:50,399
passes

00:14:47,279 --> 00:14:52,240
and indeed any number of tests will now

00:14:50,399 --> 00:14:55,760
pass and i i rang ten thousand

00:14:52,240 --> 00:14:55,760
so that gives me some confidence

00:14:56,320 --> 00:14:59,680
so there we are there's a little example

00:14:58,240 --> 00:15:02,160
of testing some

00:14:59,680 --> 00:15:03,360
some code and what have we seen a number

00:15:02,160 --> 00:15:05,120
of things

00:15:03,360 --> 00:15:07,360
we've seen that even though i started

00:15:05,120 --> 00:15:09,760
off with a test

00:15:07,360 --> 00:15:11,279
for the code that had 100 coverage there

00:15:09,760 --> 00:15:12,560
were still bugs there

00:15:11,279 --> 00:15:14,720
and i could find them with

00:15:12,560 --> 00:15:16,800
property-based testing

00:15:14,720 --> 00:15:18,320
we've seen that i could find several

00:15:16,800 --> 00:15:21,519
different bugs

00:15:18,320 --> 00:15:22,959
with the same test and

00:15:21,519 --> 00:15:25,360
that's something that happens all the

00:15:22,959 --> 00:15:27,279
time with property-based testing

00:15:25,360 --> 00:15:29,120
we've also seen that when a bug is found

00:15:27,279 --> 00:15:30,800
it's reported as a minimal

00:15:29,120 --> 00:15:33,040
test case that provokes the bug thanks

00:15:30,800 --> 00:15:35,120
to shrinking and that makes those bugs

00:15:33,040 --> 00:15:38,000
easy to understand

00:15:35,120 --> 00:15:38,800
but we also saw that when i made a wrong

00:15:38,000 --> 00:15:41,519
bug fix

00:15:38,800 --> 00:15:42,079
and i overfitted by fix the failing test

00:15:41,519 --> 00:15:45,519
that i

00:15:42,079 --> 00:15:47,920
happen to have i didn't get away with it

00:15:45,519 --> 00:15:49,040
i immediately found a slightly different

00:15:47,920 --> 00:15:52,240
example that showed

00:15:49,040 --> 00:15:55,040
that the underlying bug was still there

00:15:52,240 --> 00:15:55,680
and i don't know about you but i've seen

00:15:55,040 --> 00:15:58,079
so much

00:15:55,680 --> 00:15:59,360
weird code in production systems that

00:15:58,079 --> 00:16:01,120
was obviously put there

00:15:59,360 --> 00:16:03,040
by somebody trying to make a test case

00:16:01,120 --> 00:16:04,959
pass and they put something that made

00:16:03,040 --> 00:16:06,720
their case past but didn't fix the

00:16:04,959 --> 00:16:09,759
underlying bug

00:16:06,720 --> 00:16:11,040
and with property-based testing you

00:16:09,759 --> 00:16:13,920
can't get away with that

00:16:11,040 --> 00:16:15,120
thank goodness so what's the overall

00:16:13,920 --> 00:16:18,240
picture

00:16:15,120 --> 00:16:20,720
we're generating random test cases

00:16:18,240 --> 00:16:21,920
we need to have a property that can

00:16:20,720 --> 00:16:24,079
inspect the result of

00:16:21,920 --> 00:16:26,240
each test and tell us whether or not

00:16:24,079 --> 00:16:29,440
this test failed

00:16:26,240 --> 00:16:30,639
when a test does fail the test case that

00:16:29,440 --> 00:16:32,959
we get the random one

00:16:30,639 --> 00:16:35,279
is usually very big and ugly and not a

00:16:32,959 --> 00:16:37,120
good starting point for debugging

00:16:35,279 --> 00:16:38,399
but that's no problem because the next

00:16:37,120 --> 00:16:41,440
thing we can do

00:16:38,399 --> 00:16:42,880
is take that nasty test case and start

00:16:41,440 --> 00:16:44,720
shrinking it

00:16:42,880 --> 00:16:46,880
when it shrinks down to a minimal

00:16:44,720 --> 00:16:47,920
example a small example that provokes

00:16:46,880 --> 00:16:51,519
the bug

00:16:47,920 --> 00:16:54,320
then it becomes easy to squash

00:16:51,519 --> 00:16:54,880
so this picture shows the basic idea

00:16:54,320 --> 00:16:57,920
behind

00:16:54,880 --> 00:16:57,920
property-based testing

00:16:58,160 --> 00:17:00,560
okay

00:17:01,360 --> 00:17:04,559
so the kind of property that i've been

00:17:03,600 --> 00:17:07,439
using here

00:17:04,559 --> 00:17:09,120
is a state machine model i just want to

00:17:07,439 --> 00:17:11,280
briefly sketch how those work

00:17:09,120 --> 00:17:13,600
um because we use them a whole lot for

00:17:11,280 --> 00:17:15,360
many different kinds of software

00:17:13,600 --> 00:17:17,679
we generate test cases that are a

00:17:15,360 --> 00:17:21,439
sequence of calls to an api

00:17:17,679 --> 00:17:23,839
so these squares represent those steps

00:17:21,439 --> 00:17:24,959
how do we know what each call should

00:17:23,839 --> 00:17:28,160
return

00:17:24,959 --> 00:17:30,880
well we make a model as simple as we can

00:17:28,160 --> 00:17:32,400
at the state of the system for the queue

00:17:30,880 --> 00:17:34,000
it was just a list of the values that

00:17:32,400 --> 00:17:35,679
should be in the key

00:17:34,000 --> 00:17:37,679
and then we write a model state

00:17:35,679 --> 00:17:39,039
transition function for each kind of

00:17:37,679 --> 00:17:41,360
operation in the test

00:17:39,039 --> 00:17:42,880
and that lets quick check figure out

00:17:41,360 --> 00:17:45,679
what the model state will be

00:17:42,880 --> 00:17:46,000
at each point in the test we run the

00:17:45,679 --> 00:17:48,559
test

00:17:46,000 --> 00:17:49,440
on the real system and we write post

00:17:48,559 --> 00:17:51,600
conditions

00:17:49,440 --> 00:17:53,600
that compare the real outputs to the

00:17:51,600 --> 00:17:55,520
model

00:17:53,600 --> 00:17:56,880
so that's what a state machine model

00:17:55,520 --> 00:17:57,440
looks like that's its structure and

00:17:56,880 --> 00:18:00,080
we've found

00:17:57,440 --> 00:18:01,679
so many bugs with this kind of test i

00:18:00,080 --> 00:18:03,440
want to show you some of my favorite

00:18:01,679 --> 00:18:06,480
bugs

00:18:03,440 --> 00:18:10,480
the first one is a bug that we found in

00:18:06,480 --> 00:18:12,559
an ericsson firewall product and

00:18:10,480 --> 00:18:14,400
the purpose of this product was to

00:18:12,559 --> 00:18:16,880
connect multimedia calls

00:18:14,400 --> 00:18:18,480
across the firewall the way that you

00:18:16,880 --> 00:18:21,360
connect a call is you add

00:18:18,480 --> 00:18:22,080
a caller to it and there's a step in the

00:18:21,360 --> 00:18:25,200
protocol

00:18:22,080 --> 00:18:27,679
that says do just that so you add the

00:18:25,200 --> 00:18:29,440
first caller you add the second caller

00:18:27,679 --> 00:18:31,120
and once you've done that then you can

00:18:29,440 --> 00:18:32,559
enable communication and the call is

00:18:31,120 --> 00:18:35,840
underway

00:18:32,559 --> 00:18:37,039
when you finish the call you subtract

00:18:35,840 --> 00:18:39,840
the callers again

00:18:37,039 --> 00:18:40,880
so here i have subtracted one and the

00:18:39,840 --> 00:18:43,360
happy case

00:18:40,880 --> 00:18:44,960
the case that had been tested was of

00:18:43,360 --> 00:18:46,080
course that you then subtract the other

00:18:44,960 --> 00:18:48,720
corner

00:18:46,080 --> 00:18:50,799
but you don't have to do that um what

00:18:48,720 --> 00:18:53,360
you can do instead

00:18:50,799 --> 00:18:54,960
is add a third caller so you switch the

00:18:53,360 --> 00:18:56,480
call from one person to another

00:18:54,960 --> 00:18:58,240
do you remember old phones used to be

00:18:56,480 --> 00:18:59,679
able to do that you could switch between

00:18:58,240 --> 00:19:02,559
several different corners

00:18:59,679 --> 00:19:04,480
well this protocol would let you do that

00:19:02,559 --> 00:19:07,600
okay so i might talk to um

00:19:04,480 --> 00:19:09,120
another person and then we can subtract

00:19:07,600 --> 00:19:11,280
a caller

00:19:09,120 --> 00:19:12,720
but even here you don't have to stop now

00:19:11,280 --> 00:19:13,120
and subtract the other one you can keep

00:19:12,720 --> 00:19:16,240
going

00:19:13,120 --> 00:19:18,240
you can add a fourth quarter and it this

00:19:16,240 --> 00:19:20,240
is what our test case did

00:19:18,240 --> 00:19:22,880
and it turns out that when you subtract

00:19:20,240 --> 00:19:22,880
the third

00:19:23,039 --> 00:19:29,440
the thing crashes okay

00:19:26,320 --> 00:19:30,160
so i really love this bug why well one

00:19:29,440 --> 00:19:32,000
reason

00:19:30,160 --> 00:19:33,840
is that this was the bug that persuaded

00:19:32,000 --> 00:19:35,280
eriksen to invest in property-based

00:19:33,840 --> 00:19:38,640
testing

00:19:35,280 --> 00:19:39,440
but um i love it also because this is a

00:19:38,640 --> 00:19:41,360
test case

00:19:39,440 --> 00:19:43,360
that nobody in their right minds would

00:19:41,360 --> 00:19:44,960
write in a test suite

00:19:43,360 --> 00:19:47,200
look at it what's it doing it's adding

00:19:44,960 --> 00:19:49,600
and subtracting your caller

00:19:47,200 --> 00:19:50,400
we try it once it worked we tried it

00:19:49,600 --> 00:19:52,960
twice

00:19:50,400 --> 00:19:54,400
it worked by induction it must work any

00:19:52,960 --> 00:19:56,799
number of times

00:19:54,400 --> 00:19:58,720
only it doesn't it fails the third time

00:19:56,799 --> 00:20:00,480
why would you test that

00:19:58,720 --> 00:20:02,000
and bear in mind that the protocol has a

00:20:00,480 --> 00:20:03,520
dozen different commands you could be

00:20:02,000 --> 00:20:04,799
using in your tests

00:20:03,520 --> 00:20:07,760
why would you write a test that does

00:20:04,799 --> 00:20:09,919
this and yet this is the smallest test

00:20:07,760 --> 00:20:12,320
that provokes the bug

00:20:09,919 --> 00:20:14,559
you might think that it's also something

00:20:12,320 --> 00:20:17,520
that is unlikely to happen in practice

00:20:14,559 --> 00:20:18,720
well maybe so but this is the test case

00:20:17,520 --> 00:20:22,880
that revealed the bug

00:20:18,720 --> 00:20:25,840
what was the bug the bug was

00:20:22,880 --> 00:20:29,360
that every time you subtracted a caller

00:20:25,840 --> 00:20:31,520
the subtraction operation corrupted data

00:20:29,360 --> 00:20:33,520
just so happened that if the next thing

00:20:31,520 --> 00:20:35,840
you did was subtract the other caller

00:20:33,520 --> 00:20:37,679
then you threw away the corrupt data

00:20:35,840 --> 00:20:39,679
before it could cause a problem

00:20:37,679 --> 00:20:42,000
but of course it's bad to have corrupt

00:20:39,679 --> 00:20:44,799
data in your system and this test case

00:20:42,000 --> 00:20:48,000
turned data corruption into a crash

00:20:44,799 --> 00:20:50,400
making it detectable

00:20:48,000 --> 00:20:51,600
so this looks like a simple example um i

00:20:50,400 --> 00:20:53,760
just want to add that

00:20:51,600 --> 00:20:55,039
the rfc we had to read to write the

00:20:53,760 --> 00:20:58,880
tests

00:20:55,039 --> 00:21:01,120
was 212 pages plus another 183

00:20:58,880 --> 00:21:02,720
about how erikson planned to use it so

00:21:01,120 --> 00:21:04,080
this was actually quite a substantial

00:21:02,720 --> 00:21:07,840
testing effort

00:21:04,080 --> 00:21:07,840
but we found this lovely bug as a result

00:21:08,400 --> 00:21:11,679
i want to show you a couple more here is

00:21:10,720 --> 00:21:14,720
a bug

00:21:11,679 --> 00:21:15,200
that we found for volvo cars um volvo

00:21:14,720 --> 00:21:17,679
cars

00:21:15,200 --> 00:21:18,720
hired us to uh test software from the

00:21:17,679 --> 00:21:20,480
suppliers

00:21:18,720 --> 00:21:22,000
but it's the basic software running in

00:21:20,480 --> 00:21:24,240
cars

00:21:22,000 --> 00:21:26,240
and uh some of the software in the car

00:21:24,240 --> 00:21:27,840
manages what's called the can bus

00:21:26,240 --> 00:21:30,240
that's the network that's most widely

00:21:27,840 --> 00:21:32,559
used in vehicles so we were testing a

00:21:30,240 --> 00:21:34,960
protocol stack for the canvas

00:21:32,559 --> 00:21:36,880
and here's the book that we found so

00:21:34,960 --> 00:21:39,200
when you send a message on the canvas

00:21:36,880 --> 00:21:40,960
it has a message identifier that

00:21:39,200 --> 00:21:43,360
identifies the type of message

00:21:40,960 --> 00:21:45,280
but is also its priority so the test

00:21:43,360 --> 00:21:48,000
case starts off by sending a message of

00:21:45,280 --> 00:21:50,720
priority one

00:21:48,000 --> 00:21:52,400
what happens well we see it being sent

00:21:50,720 --> 00:21:55,600
that's good

00:21:52,400 --> 00:21:58,320
now the bus is busy and our test case

00:21:55,600 --> 00:21:59,200
sends two more messages with priorities

00:21:58,320 --> 00:22:01,679
two and three

00:21:59,200 --> 00:22:03,600
they have to be queued up in the

00:22:01,679 --> 00:22:07,039
protocol stack

00:22:03,600 --> 00:22:09,200
the final step the test case

00:22:07,039 --> 00:22:11,280
is one that's a call that's usually made

00:22:09,200 --> 00:22:12,240
by the driver software for the bus

00:22:11,280 --> 00:22:14,400
hardware

00:22:12,240 --> 00:22:15,840
and it confirms that message number one

00:22:14,400 --> 00:22:18,480
has been sent

00:22:15,840 --> 00:22:19,840
so now the bus is free the stack can

00:22:18,480 --> 00:22:20,799
send another message what are the cued

00:22:19,840 --> 00:22:22,640
ones

00:22:20,799 --> 00:22:24,400
it should choose the highest priority

00:22:22,640 --> 00:22:26,960
message and

00:22:24,400 --> 00:22:29,679
highest priority means lowest number so

00:22:26,960 --> 00:22:32,559
it should send message number two

00:22:29,679 --> 00:22:32,559
sent to wrong one

00:22:32,880 --> 00:22:39,120
now why did that happen

00:22:36,480 --> 00:22:41,919
it turns out that it's because of a

00:22:39,120 --> 00:22:43,760
weirdness in the can bus protocol

00:22:41,919 --> 00:22:45,360
so these priorities they're also the

00:22:43,760 --> 00:22:46,640
messenger identifier they identify the

00:22:45,360 --> 00:22:48,320
type of message

00:22:46,640 --> 00:22:49,679
and the first version of the protocol

00:22:48,320 --> 00:22:52,080
allowed 11 bits

00:22:49,679 --> 00:22:54,000
for this value but that means you could

00:22:52,080 --> 00:22:56,640
only have 2 000 different message

00:22:54,000 --> 00:22:58,320
types in the entire car it's just not

00:22:56,640 --> 00:22:59,840
enough in a modern vehicle

00:22:58,320 --> 00:23:02,080
modern vehicles contain about 100

00:22:59,840 --> 00:23:04,640
million lines of code it's like saying

00:23:02,080 --> 00:23:06,720
100 million line java program may only

00:23:04,640 --> 00:23:09,840
use 2000 classes

00:23:06,720 --> 00:23:12,640
of course it's too few

00:23:09,840 --> 00:23:14,240
so newer versions of the protocol also

00:23:12,640 --> 00:23:17,919
allow an extended

00:23:14,240 --> 00:23:19,760
identifier of 29 bits

00:23:17,919 --> 00:23:22,400
and the protocol stack has to support

00:23:19,760 --> 00:23:24,799
both but it has to know whether

00:23:22,400 --> 00:23:26,640
its current message has an extended id

00:23:24,799 --> 00:23:28,159
or a standard one so it can encode the

00:23:26,640 --> 00:23:30,320
packet correctly

00:23:28,159 --> 00:23:33,280
so this particular stack store the can

00:23:30,320 --> 00:23:35,200
id in an unsigned 32-bit integer

00:23:33,280 --> 00:23:36,559
and because there are three spare bits

00:23:35,200 --> 00:23:39,280
at the top of the word

00:23:36,559 --> 00:23:40,799
it used the top bit to encode whether

00:23:39,280 --> 00:23:43,760
this id was extended

00:23:40,799 --> 00:23:46,000
or not well now you can perhaps imagine

00:23:43,760 --> 00:23:48,400
what really happened

00:23:46,000 --> 00:23:51,120
that priority two message had an

00:23:48,400 --> 00:23:53,360
extended can id

00:23:51,120 --> 00:23:56,559
and the code should have masked off that

00:23:53,360 --> 00:23:59,520
top bit before comparing the priorities

00:23:56,559 --> 00:24:00,400
but somebody forgot to do that as a

00:23:59,520 --> 00:24:02,720
result

00:24:00,400 --> 00:24:04,400
the message with priority 2 was treated

00:24:02,720 --> 00:24:07,600
as a message with priority

00:24:04,400 --> 00:24:10,720
2 to the 31 plus 2 and so of course it

00:24:07,600 --> 00:24:10,720
was not sent next

00:24:10,880 --> 00:24:15,760
so i love this bug as well i love it

00:24:14,240 --> 00:24:17,440
partly because it really matters those

00:24:15,760 --> 00:24:18,720
priorities are there for a reason

00:24:17,440 --> 00:24:21,679
everything in the car talks on the

00:24:18,720 --> 00:24:23,760
canvas you know the stereo the brakes

00:24:21,679 --> 00:24:25,120
you want the critical messages to have

00:24:23,760 --> 00:24:28,400
priority

00:24:25,120 --> 00:24:30,480
so it really matters but secondly

00:24:28,400 --> 00:24:33,279
it's unlikely that you would find this

00:24:30,480 --> 00:24:34,799
bug by a handwritten test case

00:24:33,279 --> 00:24:36,960
you might write a test case that looked

00:24:34,799 --> 00:24:38,799
like this but the bug depends on a

00:24:36,960 --> 00:24:41,760
feature interact interaction

00:24:38,799 --> 00:24:43,120
between priorities for the bus and

00:24:41,760 --> 00:24:44,640
whether you have an extended or a

00:24:43,120 --> 00:24:46,799
standard can id

00:24:44,640 --> 00:24:48,400
you probably wouldn't write this very

00:24:46,799 --> 00:24:50,960
test case which is needed

00:24:48,400 --> 00:24:51,600
to provoke the bug so it's another kind

00:24:50,960 --> 00:24:53,600
of bug

00:24:51,600 --> 00:24:55,840
that you can really only find by

00:24:53,600 --> 00:24:58,559
generating tests

00:24:55,840 --> 00:25:00,640
so this was a great project we read 3

00:24:58,559 --> 00:25:02,480
000 pages of pdfs

00:25:00,640 --> 00:25:04,000
we turned that into twenty thousand

00:25:02,480 --> 00:25:06,320
lines of quick check code

00:25:04,000 --> 00:25:07,440
six pages six lines per page that's not

00:25:06,320 --> 00:25:09,279
so bad

00:25:07,440 --> 00:25:11,520
we tested more than a million lines of c

00:25:09,279 --> 00:25:14,000
code from six different suppliers

00:25:11,520 --> 00:25:14,720
and we found more than two hundred in

00:25:14,000 --> 00:25:19,200
this

00:25:14,720 --> 00:25:19,200
critical code so so that was great

00:25:19,760 --> 00:25:22,960
let me tell you about my favorite bug of

00:25:21,360 --> 00:25:25,840
all time

00:25:22,960 --> 00:25:27,440
this was a bug in a database used at

00:25:25,840 --> 00:25:30,720
corner

00:25:27,440 --> 00:25:32,320
clark were a hugely successful swedish

00:25:30,720 --> 00:25:34,880
startup in the 2000s they're a big

00:25:32,320 --> 00:25:36,400
company now supporting payments for web

00:25:34,880 --> 00:25:40,320
shops

00:25:36,400 --> 00:25:40,960
but in the 2000s their database didn't

00:25:40,320 --> 00:25:42,640
work

00:25:40,960 --> 00:25:44,960
and here's a quote about it there's a

00:25:42,640 --> 00:25:46,720
lurking bug we've got bad objects and

00:25:44,960 --> 00:25:48,720
premature enderphile every other month

00:25:46,720 --> 00:25:50,400
the last year

00:25:48,720 --> 00:25:52,159
so this was a big problem for them it

00:25:50,400 --> 00:25:54,480
crashed their main server

00:25:52,159 --> 00:25:56,559
once every couple of months and then

00:25:54,480 --> 00:25:57,520
they could keep serving customers with

00:25:56,559 --> 00:25:59,200
backup servers

00:25:57,520 --> 00:26:00,960
but they would have to rebuild the

00:25:59,200 --> 00:26:03,679
database on the main server every time

00:26:00,960 --> 00:26:05,840
it happened it took hours

00:26:03,679 --> 00:26:07,200
so by the time i looked at this problem

00:26:05,840 --> 00:26:08,320
then the crashes

00:26:07,200 --> 00:26:10,559
had actually increased they were

00:26:08,320 --> 00:26:12,320
happening every week and the guys

00:26:10,559 --> 00:26:13,039
working with the database implementation

00:26:12,320 --> 00:26:15,360
had spent

00:26:13,039 --> 00:26:17,279
more than six weeks at planner trying to

00:26:15,360 --> 00:26:19,039
figure out what was going on

00:26:17,279 --> 00:26:20,480
and the best hypothesis at the end of

00:26:19,039 --> 00:26:22,480
that was

00:26:20,480 --> 00:26:24,000
it seems to happen when the file is

00:26:22,480 --> 00:26:25,039
about one gigabyte

00:26:24,000 --> 00:26:27,679
maybe it's something to do with

00:26:25,039 --> 00:26:27,679
rehashing

00:26:28,000 --> 00:26:31,919
so it was obviously some kind of race

00:26:29,600 --> 00:26:34,640
condition and i thought let's try

00:26:31,919 --> 00:26:36,000
generating parallel tests for this

00:26:34,640 --> 00:26:38,480
problem

00:26:36,000 --> 00:26:40,159
so parallel tests are a little trickier

00:26:38,480 --> 00:26:41,200
than the sequential tests i already

00:26:40,159 --> 00:26:44,000
talked about

00:26:41,200 --> 00:26:46,080
um we generate tests that look like this

00:26:44,000 --> 00:26:48,480
first of all you do some random stuff

00:26:46,080 --> 00:26:49,919
to get into a random state then you fork

00:26:48,480 --> 00:26:52,400
off parallel processes

00:26:49,919 --> 00:26:54,320
and they each do some more random stuff

00:26:52,400 --> 00:26:56,159
the question is how do you know

00:26:54,320 --> 00:26:57,679
whether or not the results that you get

00:26:56,159 --> 00:26:59,039
are correct how do you know if your test

00:26:57,679 --> 00:27:00,559
has passed

00:26:59,039 --> 00:27:02,960
it turns out there's a very simple way

00:27:00,559 --> 00:27:04,880
of doing that and that is to take the

00:27:02,960 --> 00:27:08,320
results that you get from those

00:27:04,880 --> 00:27:09,760
parallel calls and just see is there

00:27:08,320 --> 00:27:11,360
some order

00:27:09,760 --> 00:27:13,679
in which we could have performed those

00:27:11,360 --> 00:27:14,640
calls that would make the results

00:27:13,679 --> 00:27:17,520
consistent

00:27:14,640 --> 00:27:18,399
with the sequential model if so the

00:27:17,520 --> 00:27:20,799
behavior was

00:27:18,399 --> 00:27:21,919
linearizable and we'll say that the test

00:27:20,799 --> 00:27:25,039
passed

00:27:21,919 --> 00:27:27,440
if not it failed so

00:27:25,039 --> 00:27:28,159
using this idea i can take a sequential

00:27:27,440 --> 00:27:29,679
model

00:27:28,159 --> 00:27:31,919
and i made one for this part of the

00:27:29,679 --> 00:27:34,640
database it was only 100 lines of code

00:27:31,919 --> 00:27:36,640
so quite simple and by changing two

00:27:34,640 --> 00:27:38,480
lines i could use it for race condition

00:27:36,640 --> 00:27:41,760
testing instead

00:27:38,480 --> 00:27:45,200
and here is my favorite bug

00:27:41,760 --> 00:27:46,840
of all time look at it this provokes the

00:27:45,200 --> 00:27:50,399
premature end of file

00:27:46,840 --> 00:27:51,120
error first of all sequentially we open

00:27:50,399 --> 00:27:54,320
the file

00:27:51,120 --> 00:27:56,960
we close it we open it again and then we

00:27:54,320 --> 00:27:59,360
do three things in parallel one lookup

00:27:56,960 --> 00:28:02,000
and two insertions

00:27:59,360 --> 00:28:03,520
do all of that and occasionally you get

00:28:02,000 --> 00:28:05,840
a premature end of file error the file

00:28:03,520 --> 00:28:08,799
is corrupted

00:28:05,840 --> 00:28:10,720
so when i saw this test case i thought

00:28:08,799 --> 00:28:13,039
that something wrong is shrinking

00:28:10,720 --> 00:28:15,600
this cannot possibly be the smallest

00:28:13,039 --> 00:28:18,799
test that provokes this bug

00:28:15,600 --> 00:28:20,399
but it is look at that open closed open

00:28:18,799 --> 00:28:21,919
i thought no no it must be enough just

00:28:20,399 --> 00:28:24,559
to open it once

00:28:21,919 --> 00:28:26,159
so i manually simplified the test case i

00:28:24,559 --> 00:28:28,480
ran that simplified test

00:28:26,159 --> 00:28:30,880
tens of thousands of times passed every

00:28:28,480 --> 00:28:33,919
single time

00:28:30,880 --> 00:28:36,159
and indeed today i know why because

00:28:33,919 --> 00:28:37,440
when we start the test case the file

00:28:36,159 --> 00:28:39,600
doesn't exist

00:28:37,440 --> 00:28:41,279
we open the file that creates it we

00:28:39,600 --> 00:28:43,919
close it the second open

00:28:41,279 --> 00:28:45,279
opens an existing file it's very

00:28:43,919 --> 00:28:47,120
slightly different

00:28:45,279 --> 00:28:49,279
you get into a very slightly different

00:28:47,120 --> 00:28:51,520
state and that difference is

00:28:49,279 --> 00:28:53,919
critical for making the race condition

00:28:51,520 --> 00:28:53,919
possible

00:28:54,320 --> 00:29:00,080
so once again ask yourselves this would

00:28:57,120 --> 00:29:03,120
you write this test in a test suite

00:29:00,080 --> 00:29:05,120
of course not why pick that and yet this

00:29:03,120 --> 00:29:08,159
is the smallest test

00:29:05,120 --> 00:29:10,399
that can possibly reveal this bug

00:29:08,159 --> 00:29:12,240
and it took about 10 minutes of

00:29:10,399 --> 00:29:15,440
property-based testing to find

00:29:12,240 --> 00:29:18,640
so hard work but um

00:29:15,440 --> 00:29:20,000
but worth it and i also found the bad

00:29:18,640 --> 00:29:21,120
object bug i'm not going to talk you

00:29:20,000 --> 00:29:23,440
through it

00:29:21,120 --> 00:29:25,120
you can see it's about the same size not

00:29:23,440 --> 00:29:28,080
complicated

00:29:25,120 --> 00:29:29,760
so before i did this more than six weeks

00:29:28,080 --> 00:29:32,320
of effort was spent

00:29:29,760 --> 00:29:34,240
uh people thought you needed a gigabyte

00:29:32,320 --> 00:29:38,159
of data to make it happen

00:29:34,240 --> 00:29:40,320
now we know i spent less than one day

00:29:38,159 --> 00:29:41,600
in total writing this model and running

00:29:40,320 --> 00:29:44,559
the tests

00:29:41,600 --> 00:29:46,799
um you need a database with at most one

00:29:44,559 --> 00:29:48,720
record to provoke the bugs

00:29:46,799 --> 00:29:50,640
in each case you can reproduce them with

00:29:48,720 --> 00:29:54,640
only five or six calls

00:29:50,640 --> 00:29:56,159
and given those bugs that i showed you

00:29:54,640 --> 00:29:57,919
the developer of the code was able to

00:29:56,159 --> 00:30:00,720
fix the problem in less than a day

00:29:57,919 --> 00:30:01,919
in each case so this really shows the

00:30:00,720 --> 00:30:05,039
enormous power

00:30:01,919 --> 00:30:07,279
of shrinking and the

00:30:05,039 --> 00:30:09,200
of shrunk test cases for debugging

00:30:07,279 --> 00:30:10,799
compared to trying to debug faults like

00:30:09,200 --> 00:30:12,640
this in production

00:30:10,799 --> 00:30:14,000
when not only the five or six six

00:30:12,640 --> 00:30:15,919
relevant things but

00:30:14,000 --> 00:30:18,159
millions of irrelevant things have also

00:30:15,919 --> 00:30:20,159
happened

00:30:18,159 --> 00:30:22,320
okay so that's a race condition bug that

00:30:20,159 --> 00:30:24,240
we found this way

00:30:22,320 --> 00:30:27,200
i can't resist also showing you some

00:30:24,240 --> 00:30:30,000
bugs we found in dropbox

00:30:27,200 --> 00:30:30,640
so testing dropbox is tricky because

00:30:30,000 --> 00:30:32,480
there is

00:30:30,640 --> 00:30:34,159
the dropbox demon in the background that

00:30:32,480 --> 00:30:36,640
can be taking actions

00:30:34,159 --> 00:30:37,600
so in our model we don't know what state

00:30:36,640 --> 00:30:39,039
we're in we

00:30:37,600 --> 00:30:41,279
know what stake we tried to get to

00:30:39,039 --> 00:30:43,600
perhaps but then we have to model

00:30:41,279 --> 00:30:45,679
all of the possible background actions

00:30:43,600 --> 00:30:47,520
that dropbox might take

00:30:45,679 --> 00:30:49,600
and then we'll carry out a step in the

00:30:47,520 --> 00:30:52,000
test like maybe write a file

00:30:49,600 --> 00:30:53,279
and we don't know what state we're in we

00:30:52,000 --> 00:30:55,919
don't know what state we reach

00:30:53,279 --> 00:30:57,600
but after we've taken an action dropbox

00:30:55,919 --> 00:30:58,640
might take a bunch of other background

00:30:57,600 --> 00:31:01,360
actions

00:30:58,640 --> 00:31:03,039
and so on so there's a whole tree of

00:31:01,360 --> 00:31:06,720
possible states that we might

00:31:03,039 --> 00:31:08,399
get into we have to model them all

00:31:06,720 --> 00:31:10,960
luckily we can keep it down to a

00:31:08,399 --> 00:31:11,840
manageable number if every time we take

00:31:10,960 --> 00:31:14,240
an action

00:31:11,840 --> 00:31:15,760
we also observe something about the

00:31:14,240 --> 00:31:17,760
files in the dropbox

00:31:15,760 --> 00:31:20,080
and those observations will rule out

00:31:17,760 --> 00:31:23,440
many of the possible states

00:31:20,080 --> 00:31:27,120
so we do that as we run the tests

00:31:23,440 --> 00:31:28,799
and if we can find a path

00:31:27,120 --> 00:31:31,679
that where all the observations are

00:31:28,799 --> 00:31:34,960
consistent with the model

00:31:31,679 --> 00:31:35,679
um we'll say the test passed and if we

00:31:34,960 --> 00:31:38,559
can't

00:31:35,679 --> 00:31:40,320
then we'll say the test failed and uh in

00:31:38,559 --> 00:31:42,240
practice we found that we had to track

00:31:40,320 --> 00:31:44,320
maybe up to a thousand possible states

00:31:42,240 --> 00:31:45,600
during the test but not more than that

00:31:44,320 --> 00:31:48,399
that was enough to find some really

00:31:45,600 --> 00:31:50,480
interesting behavior

00:31:48,399 --> 00:31:51,919
here's what i like these two arrows

00:31:50,480 --> 00:31:54,880
represent two different

00:31:51,919 --> 00:31:57,519
nodes each of which is running dropbox

00:31:54,880 --> 00:31:59,919
uh and there's they're synchronizing

00:31:57,519 --> 00:32:01,679
so first of all on one of the nodes

00:31:59,919 --> 00:32:02,799
we'll write to a file we're only using

00:32:01,679 --> 00:32:06,240
one file here

00:32:02,799 --> 00:32:08,559
we'll write a to it that's fine

00:32:06,240 --> 00:32:09,600
then on the other node we'll write b to

00:32:08,559 --> 00:32:12,640
it

00:32:09,600 --> 00:32:14,480
and we'll observe that we overwrote a

00:32:12,640 --> 00:32:16,399
file containing a

00:32:14,480 --> 00:32:18,159
so when we see that that tells us that

00:32:16,399 --> 00:32:19,360
dropbox must have synchronized the file

00:32:18,159 --> 00:32:22,240
from one node to the other

00:32:19,360 --> 00:32:23,440
between those two calls so we know a bit

00:32:22,240 --> 00:32:25,760
what's going on

00:32:23,440 --> 00:32:27,360
what next let's delete the file on the

00:32:25,760 --> 00:32:28,799
first node

00:32:27,360 --> 00:32:31,200
and when we delete it we see that it

00:32:28,799 --> 00:32:33,760
we're deleting a file containing a

00:32:31,200 --> 00:32:35,279
so that means that dropbox have not

00:32:33,760 --> 00:32:38,320
synchronized the b

00:32:35,279 --> 00:32:41,440
back to the original node yet

00:32:38,320 --> 00:32:42,880
and now we'll write c to the file

00:32:41,440 --> 00:32:44,720
and once again we'll see that the file

00:32:42,880 --> 00:32:47,360
didn't exist so

00:32:44,720 --> 00:32:49,200
the b hasn't been synchronized back so

00:32:47,360 --> 00:32:51,039
now we've got a conflict right we've got

00:32:49,200 --> 00:32:53,279
we've written b on one node c on the

00:32:51,039 --> 00:32:54,320
other when we read the file what will we

00:32:53,279 --> 00:32:57,519
see

00:32:54,320 --> 00:33:00,240
we might see b we might see c

00:32:57,519 --> 00:33:00,240
here's what happened

00:33:00,640 --> 00:33:07,519
doesn't exist what

00:33:04,000 --> 00:33:10,720
surely we should see either b or c

00:33:07,519 --> 00:33:13,200
well that's that's a bit uh worrying now

00:33:10,720 --> 00:33:16,320
actually this is timing dependent if you

00:33:13,200 --> 00:33:18,799
wait long enough the file does reappear

00:33:16,320 --> 00:33:20,799
so i think it's weird that it doesn't

00:33:18,799 --> 00:33:22,840
exist that's one problem

00:33:20,799 --> 00:33:24,880
but if we then wait for everything to

00:33:22,840 --> 00:33:26,960
stabilize it should reappear

00:33:24,880 --> 00:33:29,440
and it might contain b it might contain

00:33:26,960 --> 00:33:31,120
c we don't know which

00:33:29,440 --> 00:33:33,039
in this case when we ran the test it

00:33:31,120 --> 00:33:34,880
contains c

00:33:33,039 --> 00:33:36,480
but those of you who are dropbox users

00:33:34,880 --> 00:33:39,440
will know that

00:33:36,480 --> 00:33:40,080
the b should not disappear the b should

00:33:39,440 --> 00:33:42,960
appear

00:33:40,080 --> 00:33:43,279
in a conflict version of the file right

00:33:42,960 --> 00:33:46,480
so

00:33:43,279 --> 00:33:48,480
so that you don't lose data if the

00:33:46,480 --> 00:33:51,519
timing is right in this test

00:33:48,480 --> 00:33:52,000
no conflict file ever appears and so

00:33:51,519 --> 00:33:54,960
this is

00:33:52,000 --> 00:33:55,279
again i think weird weird behavior and

00:33:54,960 --> 00:33:57,679
the

00:33:55,279 --> 00:34:00,480
dropbox developers agreed this was a bug

00:33:57,679 --> 00:34:03,919
it should have been fixed by now luckily

00:34:00,480 --> 00:34:06,399
and it was always rare um but

00:34:03,919 --> 00:34:08,079
we found these rather cool behaviors in

00:34:06,399 --> 00:34:09,359
a distributed system like dropbox as

00:34:08,079 --> 00:34:12,639
well

00:34:09,359 --> 00:34:14,960
so i've shown you um lots of examples

00:34:12,639 --> 00:34:14,960
of

00:34:15,839 --> 00:34:19,359
nice bugs that we could found defined by

00:34:18,000 --> 00:34:22,240
property-based testing

00:34:19,359 --> 00:34:23,119
and it works insanely well so you might

00:34:22,240 --> 00:34:24,639
wonder why

00:34:23,119 --> 00:34:27,760
and i'm going to try and give you some

00:34:24,639 --> 00:34:29,599
intuition for why it works so well

00:34:27,760 --> 00:34:31,119
we generate test cases that do quite a

00:34:29,599 --> 00:34:33,520
lot of steps

00:34:31,119 --> 00:34:35,119
and usually when a test fails it's not

00:34:33,520 --> 00:34:37,040
because of every step

00:34:35,119 --> 00:34:38,159
it's because of just a sub sequence of

00:34:37,040 --> 00:34:39,919
steps

00:34:38,159 --> 00:34:42,000
you know maybe in this case there are

00:34:39,919 --> 00:34:44,079
five steps that cause the failure

00:34:42,000 --> 00:34:45,919
and that's the bug we're looking for

00:34:44,079 --> 00:34:46,320
it's those five steps we want to shrink

00:34:45,919 --> 00:34:49,359
to

00:34:46,320 --> 00:34:50,639
that will show us what the problem was

00:34:49,359 --> 00:34:53,839
but you'll notice there are lots of

00:34:50,639 --> 00:34:53,839
other steps here as well

00:34:54,480 --> 00:34:58,480
often those other actions don't matter

00:34:56,960 --> 00:35:00,240
much

00:34:58,480 --> 00:35:03,280
so it's not always true of course but

00:35:00,240 --> 00:35:04,880
often if those five red steps appear

00:35:03,280 --> 00:35:07,920
anywhere in your test case

00:35:04,880 --> 00:35:09,680
the test will fail so what does that

00:35:07,920 --> 00:35:10,960
mean that means when we run one longer

00:35:09,680 --> 00:35:12,960
test

00:35:10,960 --> 00:35:14,839
in a sense we're testing every

00:35:12,960 --> 00:35:16,480
subsequence and how many of those are

00:35:14,839 --> 00:35:20,320
there

00:35:16,480 --> 00:35:23,599
we're getting exponentially much value

00:35:20,320 --> 00:35:24,640
out of a linear amount of testing work i

00:35:23,599 --> 00:35:26,880
think

00:35:24,640 --> 00:35:28,240
this strictly speaking this isn't true

00:35:26,880 --> 00:35:31,040
but it is truthy

00:35:28,240 --> 00:35:31,839
to borrow a word from stephen colbert so

00:35:31,040 --> 00:35:35,200
um

00:35:31,839 --> 00:35:35,520
this is intuition for why this approach

00:35:35,200 --> 00:35:37,359
of

00:35:35,520 --> 00:35:39,760
generating tests and shrinking them

00:35:37,359 --> 00:35:42,880
works so extremely well

00:35:39,760 --> 00:35:44,800
of course it doesn't always work nicely

00:35:42,880 --> 00:35:46,640
let me just mention a couple of things

00:35:44,800 --> 00:35:49,119
that can go wrong

00:35:46,640 --> 00:35:50,480
one of the things that can go wrong is

00:35:49,119 --> 00:35:54,160
if you use this approach

00:35:50,480 --> 00:35:57,760
of defining a model of your system

00:35:54,160 --> 00:36:01,040
sometimes not always but sometimes

00:35:57,760 --> 00:36:03,280
the model can end up

00:36:01,040 --> 00:36:05,200
getting more and more complicated and

00:36:03,280 --> 00:36:06,720
start looking rather like the system

00:36:05,200 --> 00:36:08,960
itself

00:36:06,720 --> 00:36:10,480
this is one trap you can fall into when

00:36:08,960 --> 00:36:12,880
you use a model as a

00:36:10,480 --> 00:36:14,720
reference for testing a real system you

00:36:12,880 --> 00:36:16,880
end up replicating

00:36:14,720 --> 00:36:18,000
some of the code from the system in the

00:36:16,880 --> 00:36:20,880
model

00:36:18,000 --> 00:36:21,599
that's not good for a start it's

00:36:20,880 --> 00:36:22,960
expensive

00:36:21,599 --> 00:36:26,400
it feels as though you're doing the same

00:36:22,960 --> 00:36:29,520
work twice expensive is not good

00:36:26,400 --> 00:36:31,520
but even worse if you do this

00:36:29,520 --> 00:36:33,599
and you've made a mistake in the system

00:36:31,520 --> 00:36:35,119
because of some misunderstanding

00:36:33,599 --> 00:36:37,200
the chances are you make the same

00:36:35,119 --> 00:36:40,240
mistake in the model

00:36:37,200 --> 00:36:41,680
so it's not only expensive it's low

00:36:40,240 --> 00:36:44,240
value

00:36:41,680 --> 00:36:45,040
and obviously if a technique is both

00:36:44,240 --> 00:36:47,599
expensive

00:36:45,040 --> 00:36:49,359
and low value people aren't going to use

00:36:47,599 --> 00:36:52,560
it

00:36:49,359 --> 00:36:54,400
so models often work well

00:36:52,560 --> 00:36:56,640
but sometimes they don't and you need an

00:36:54,400 --> 00:36:58,240
alternative approach in those cases

00:36:56,640 --> 00:37:00,720
and luckily there is one it's something

00:36:58,240 --> 00:37:02,720
that i call metamorphic properties

00:37:00,720 --> 00:37:05,040
i'm going to illustrate the idea uh

00:37:02,720 --> 00:37:05,920
talking about testing insertion into a

00:37:05,040 --> 00:37:08,640
collection

00:37:05,920 --> 00:37:10,800
and i'm calling my collection t because

00:37:08,640 --> 00:37:13,440
in my case it was a tree

00:37:10,800 --> 00:37:15,040
okay so we're going to test inserting a

00:37:13,440 --> 00:37:17,200
key value pair

00:37:15,040 --> 00:37:18,640
into the collection t and we get some

00:37:17,200 --> 00:37:21,920
new collection

00:37:18,640 --> 00:37:24,880
so how do we test this how do we predict

00:37:21,920 --> 00:37:27,440
what the resulting collection should be

00:37:24,880 --> 00:37:28,640
well of course we could re-implement

00:37:27,440 --> 00:37:31,599
insert

00:37:28,640 --> 00:37:33,119
in the test code but there's no point in

00:37:31,599 --> 00:37:34,160
doing that right we'll be falling into

00:37:33,119 --> 00:37:36,800
the trap

00:37:34,160 --> 00:37:38,560
that we don't want to fall into but

00:37:36,800 --> 00:37:41,040
here's a different way of thinking

00:37:38,560 --> 00:37:42,720
about how to test this operation you can

00:37:41,040 --> 00:37:46,079
ask yourself

00:37:42,720 --> 00:37:49,680
how would changing the input of insert

00:37:46,079 --> 00:37:50,480
change its result changing the input

00:37:49,680 --> 00:37:52,400
what i mean well

00:37:50,480 --> 00:37:54,960
for example suppose we insert something

00:37:52,400 --> 00:37:57,200
else before we do the insertion we want

00:37:54,960 --> 00:37:59,680
to test

00:37:57,200 --> 00:38:01,520
now you might say instead of having one

00:37:59,680 --> 00:38:02,000
unknown collection on my slide i've got

00:38:01,520 --> 00:38:05,040
three

00:38:02,000 --> 00:38:05,680
is that better yes it is better because

00:38:05,040 --> 00:38:07,359
the two

00:38:05,680 --> 00:38:09,680
unknown collections at the bottom of the

00:38:07,359 --> 00:38:12,320
slide should be related

00:38:09,680 --> 00:38:13,760
how the one on the right should be just

00:38:12,320 --> 00:38:16,880
like the one on the left

00:38:13,760 --> 00:38:18,640
except that it also contains the key k

00:38:16,880 --> 00:38:20,880
prime

00:38:18,640 --> 00:38:22,240
so if i take the one on the left and i

00:38:20,880 --> 00:38:24,480
insert k prime and v

00:38:22,240 --> 00:38:25,520
prime into it i should get the same

00:38:24,480 --> 00:38:27,680
result

00:38:25,520 --> 00:38:29,440
as doing the insertion in the other

00:38:27,680 --> 00:38:31,440
order

00:38:29,440 --> 00:38:32,800
so here i still don't know what any of

00:38:31,440 --> 00:38:35,520
those three collections should be

00:38:32,800 --> 00:38:37,920
i can't predict that but i can predict

00:38:35,520 --> 00:38:40,640
that both ways around this square

00:38:37,920 --> 00:38:42,720
should lead to the same result and that

00:38:40,640 --> 00:38:45,440
lets me write a property for testing

00:38:42,720 --> 00:38:46,400
here's how it looks in haskell so here

00:38:45,440 --> 00:38:48,320
the property

00:38:46,400 --> 00:38:49,760
is parameterized on the two key value

00:38:48,320 --> 00:38:52,240
pairs and the collection and all of

00:38:49,760 --> 00:38:55,359
those will be randomly generated

00:38:52,240 --> 00:38:55,680
and the property just says that whether

00:38:55,359 --> 00:38:56,960
you

00:38:55,680 --> 00:38:59,040
you know whatever order you do the

00:38:56,960 --> 00:39:02,320
insertion in you get the same

00:38:59,040 --> 00:39:07,280
collection as a result very simple

00:39:02,320 --> 00:39:10,640
nice test of course you may be wondering

00:39:07,280 --> 00:39:12,000
is this really true you may be thinking

00:39:10,640 --> 00:39:15,200
about it

00:39:12,000 --> 00:39:16,960
don't think i like to let quick check do

00:39:15,200 --> 00:39:18,480
my thinking for me

00:39:16,960 --> 00:39:20,880
so if i want to know if this is really

00:39:18,480 --> 00:39:24,000
true i'll just test it

00:39:20,880 --> 00:39:28,240
and when we do that

00:39:24,000 --> 00:39:30,880
it's not look at the example uh the

00:39:28,240 --> 00:39:32,880
interesting part is in red

00:39:30,880 --> 00:39:35,119
so these are the two key value pairs

00:39:32,880 --> 00:39:39,599
that make this property false and

00:39:35,119 --> 00:39:41,680
oh yes if i insert the same key twice

00:39:39,599 --> 00:39:43,599
for this kind of collection there's only

00:39:41,680 --> 00:39:46,640
one value per key

00:39:43,599 --> 00:39:49,040
so the last insertion wins obviously

00:39:46,640 --> 00:39:51,280
but what the property says is that the

00:39:49,040 --> 00:39:53,760
order of insertion doesn't matter

00:39:51,280 --> 00:39:55,680
that can't be right so when you

00:39:53,760 --> 00:39:56,560
construct metamorphic properties like

00:39:55,680 --> 00:39:58,880
this

00:39:56,560 --> 00:40:00,640
very often they're not always true

00:39:58,880 --> 00:40:01,200
there's some case like this some special

00:40:00,640 --> 00:40:03,599
case

00:40:01,200 --> 00:40:04,960
that makes them false that doesn't mean

00:40:03,599 --> 00:40:07,040
we have to throw it away

00:40:04,960 --> 00:40:09,599
it means we have to adapt the property a

00:40:07,040 --> 00:40:11,520
little bit so i can just

00:40:09,599 --> 00:40:13,280
add a clause that says if the keys are

00:40:11,520 --> 00:40:14,560
equal then what i just said the last

00:40:13,280 --> 00:40:16,880
insertion wins

00:40:14,560 --> 00:40:17,599
otherwise you can swap the assertions

00:40:16,880 --> 00:40:20,640
over

00:40:17,599 --> 00:40:23,119
and by doing that i get a property that

00:40:20,640 --> 00:40:26,160
passes all its tests that's great and

00:40:23,119 --> 00:40:28,000
it's a useful test of insert

00:40:26,160 --> 00:40:29,520
the cool thing about this is i didn't

00:40:28,000 --> 00:40:32,720
need to write a model

00:40:29,520 --> 00:40:34,800
and if we take this idea and we've got

00:40:32,720 --> 00:40:38,160
an api with n ways

00:40:34,800 --> 00:40:41,040
of changing a collection

00:40:38,160 --> 00:40:42,319
we get a quadratic number of ideas for

00:40:41,040 --> 00:40:43,920
properties we can write

00:40:42,319 --> 00:40:46,079
so we can write a lot of testing

00:40:43,920 --> 00:40:47,359
properties without ever needing to

00:40:46,079 --> 00:40:49,200
construct a model

00:40:47,359 --> 00:40:50,839
and that makes metamorphic properties

00:40:49,200 --> 00:40:55,040
quite an effective way

00:40:50,839 --> 00:40:55,040
of testing this kind of code

00:40:55,599 --> 00:40:58,240
there's one more thing that can go wrong

00:40:56,960 --> 00:41:00,240
and to do that i'm going to show you a

00:40:58,240 --> 00:41:02,640
really really tiny example

00:41:00,240 --> 00:41:03,599
uh this is not real code but it's

00:41:02,640 --> 00:41:06,560
inspired by

00:41:03,599 --> 00:41:07,760
code from a cryptocurrency company um

00:41:06,560 --> 00:41:09,200
not bitcoin obviously

00:41:07,760 --> 00:41:11,119
who implemented their blockchain in

00:41:09,200 --> 00:41:14,160
haskell

00:41:11,119 --> 00:41:18,079
so when you implement uh cryptocurrency

00:41:14,160 --> 00:41:19,599
then you need to represent coin amount

00:41:18,079 --> 00:41:21,520
let's have a type for that this defines

00:41:19,599 --> 00:41:23,359
a new type in haskell a coin basically

00:41:21,520 --> 00:41:26,400
just contains an it

00:41:23,359 --> 00:41:28,560
but it's not the same as an int because

00:41:26,400 --> 00:41:30,800
there is an upper limit on the total

00:41:28,560 --> 00:41:32,560
number of coins that may ever exist

00:41:30,800 --> 00:41:35,200
and i'm gonna just assume that it's one

00:41:32,560 --> 00:41:37,200
million for the purposes of this example

00:41:35,200 --> 00:41:39,680
in reality it's much more than that like

00:41:37,200 --> 00:41:39,680
billions

00:41:39,760 --> 00:41:43,359
um but now there should never be a coin

00:41:42,960 --> 00:41:45,119
value

00:41:43,359 --> 00:41:47,440
larger than one million so let's just

00:41:45,119 --> 00:41:49,839
write a validity checking function

00:41:47,440 --> 00:41:52,880
a coin is valid if the integer in it is

00:41:49,839 --> 00:41:55,359
in the correct range of values

00:41:52,880 --> 00:41:57,359
and then we need to define operations on

00:41:55,359 --> 00:41:58,480
coin values like for example

00:41:57,359 --> 00:42:00,640
addition we're going to need to be able

00:41:58,480 --> 00:42:02,480
to combine coin quantities and all of

00:42:00,640 --> 00:42:05,680
these functions have to

00:42:02,480 --> 00:42:06,960
uh check for overflow and if the flow

00:42:05,680 --> 00:42:10,480
occurs then

00:42:06,960 --> 00:42:12,720
um in haskell typically we would return

00:42:10,480 --> 00:42:14,240
nothing instead of the value so nothing

00:42:12,720 --> 00:42:15,440
it's the hassle equivalent of the null

00:42:14,240 --> 00:42:18,720
pointer

00:42:15,440 --> 00:42:20,640
so no results in that case okay

00:42:18,720 --> 00:42:22,400
so this code is all very simple but it

00:42:20,640 --> 00:42:24,079
still needs to be tested right

00:42:22,400 --> 00:42:26,800
so what property could i write for

00:42:24,079 --> 00:42:28,720
testing this well i could write

00:42:26,800 --> 00:42:31,520
an addition property that takes two

00:42:28,720 --> 00:42:33,520
randomly generated coins as arguments

00:42:31,520 --> 00:42:35,280
adds them together and then checks we

00:42:33,520 --> 00:42:38,000
get the right result

00:42:35,280 --> 00:42:39,920
what is the right result well i don't

00:42:38,000 --> 00:42:42,720
want to replicate the code and add

00:42:39,920 --> 00:42:44,640
but let's suppose i just make a coin

00:42:42,720 --> 00:42:47,599
that contains the sum of their values

00:42:44,640 --> 00:42:48,160
that might be valid or not if that is

00:42:47,599 --> 00:42:50,480
valid

00:42:48,160 --> 00:42:51,440
then that's what i should get and if

00:42:50,480 --> 00:42:54,800
it's not valid

00:42:51,440 --> 00:42:57,359
then i should get nothing as the result

00:42:54,800 --> 00:42:58,000
okay so i can write this property run

00:42:57,359 --> 00:43:00,880
lots of tests

00:42:58,000 --> 00:43:02,960
10 000 in this case and it passes that's

00:43:00,880 --> 00:43:04,640
great

00:43:02,960 --> 00:43:06,319
so that's a very simple piece of

00:43:04,640 --> 00:43:07,520
property-based testing

00:43:06,319 --> 00:43:09,760
but here's what you should be asking

00:43:07,520 --> 00:43:13,119
yourself

00:43:09,760 --> 00:43:14,720
what did i test exactly so here

00:43:13,119 --> 00:43:17,200
we've got two kinds of cases we've got

00:43:14,720 --> 00:43:20,400
the normal case and the overflow case

00:43:17,200 --> 00:43:21,680
did i test them both maybe all my random

00:43:20,400 --> 00:43:22,720
coins were smaller but i never

00:43:21,680 --> 00:43:25,200
overflowed

00:43:22,720 --> 00:43:26,800
i just don't know and this is a problem

00:43:25,200 --> 00:43:29,119
with property-based testing that because

00:43:26,800 --> 00:43:31,040
you don't see the test cases

00:43:29,119 --> 00:43:32,480
there's a risk but you're doing a lot of

00:43:31,040 --> 00:43:35,200
trivial tests

00:43:32,480 --> 00:43:36,480
and but you don't realize it so we

00:43:35,200 --> 00:43:38,800
always have to

00:43:36,480 --> 00:43:40,079
mitigate that risk by making

00:43:38,800 --> 00:43:42,240
measurements of the actual

00:43:40,079 --> 00:43:43,839
tests what we do is we label the test

00:43:42,240 --> 00:43:46,960
cases and there's a function

00:43:43,839 --> 00:43:49,119
in the quick check api for doing that

00:43:46,960 --> 00:43:50,079
so i'll just attach a label to every

00:43:49,119 --> 00:43:52,000
test

00:43:50,079 --> 00:43:53,680
that is a string and i've written a

00:43:52,000 --> 00:43:54,640
little function summarize for computing

00:43:53,680 --> 00:43:56,960
that

00:43:54,640 --> 00:43:58,079
so if the total is in the right range i

00:43:56,960 --> 00:44:00,720
return normal

00:43:58,079 --> 00:44:02,560
if it's outside it i return overflow and

00:44:00,720 --> 00:44:03,920
now when i run the tests i'll get some

00:44:02,560 --> 00:44:06,400
statistics

00:44:03,920 --> 00:44:07,520
and we can see that oh yeah it's good

00:44:06,400 --> 00:44:09,440
i've got about 50

00:44:07,520 --> 00:44:10,880
of each so that's good both kinds of

00:44:09,440 --> 00:44:14,640
tests are

00:44:10,880 --> 00:44:17,520
appearing often okay

00:44:14,640 --> 00:44:18,160
now just think about this a little bit

00:44:17,520 --> 00:44:19,839
one of the

00:44:18,160 --> 00:44:21,040
important lessons here is that just

00:44:19,839 --> 00:44:22,240
because you're doing property-based

00:44:21,040 --> 00:44:25,760
testing

00:44:22,240 --> 00:44:28,400
doesn't mean you don't need your brain

00:44:25,760 --> 00:44:29,599
so ask yourself what cases would you

00:44:28,400 --> 00:44:32,240
want to test here

00:44:29,599 --> 00:44:33,280
if you were to write unit tests for the

00:44:32,240 --> 00:44:36,560
add function

00:44:33,280 --> 00:44:40,480
what tests would you write

00:44:36,560 --> 00:44:44,720
i would say the add function is imposing

00:44:40,480 --> 00:44:46,720
a boundary between normal and overflow

00:44:44,720 --> 00:44:48,319
is that boundary in exactly the right

00:44:46,720 --> 00:44:51,119
place

00:44:48,319 --> 00:44:51,599
to find out i need to run tests that

00:44:51,119 --> 00:44:54,720
fall

00:44:51,599 --> 00:44:56,800
close to the boundary at the moment i

00:44:54,720 --> 00:45:00,880
don't know how many tests did that

00:44:56,800 --> 00:45:03,040
but i can find out i can just enrich my

00:45:00,880 --> 00:45:04,640
labeling function and i've chosen

00:45:03,040 --> 00:45:07,680
arbitrarily to say

00:45:04,640 --> 00:45:10,560
uh if the total is within three of

00:45:07,680 --> 00:45:12,160
the maximum then this is a boundary case

00:45:10,560 --> 00:45:16,079
so how many of those am i running

00:45:12,160 --> 00:45:16,079
let's see rub my measurements

00:45:16,160 --> 00:45:22,800
oh not a single boundary case

00:45:20,480 --> 00:45:24,000
so in fact i ran 10 000 tests which

00:45:22,800 --> 00:45:25,440
sounds good

00:45:24,000 --> 00:45:27,920
but i'm actually not testing the most

00:45:25,440 --> 00:45:30,400
interesting cases at all

00:45:27,920 --> 00:45:33,040
and why is that because the generator

00:45:30,400 --> 00:45:36,079
which i also had to write for coins

00:45:33,040 --> 00:45:37,440
looks like this all you you have to pay

00:45:36,079 --> 00:45:38,960
attention to here is that i'm calling

00:45:37,440 --> 00:45:41,520
the choose function

00:45:38,960 --> 00:45:44,240
to choose a uniform random number

00:45:41,520 --> 00:45:46,319
between zero and the maximum value

00:45:44,240 --> 00:45:47,359
well obviously if i take two of those

00:45:46,319 --> 00:45:50,079
and add them together

00:45:47,359 --> 00:45:51,680
it's very unlikely that the result will

00:45:50,079 --> 00:45:52,960
fall close to the boundary that i care

00:45:51,680 --> 00:45:54,240
about

00:45:52,960 --> 00:45:55,920
now at this point you might be tempted

00:45:54,240 --> 00:45:57,119
to say well why don't i just write those

00:45:55,920 --> 00:46:00,480
unit tests instead

00:45:57,119 --> 00:46:01,839
don't do that much better is to change

00:46:00,480 --> 00:46:04,079
the generator

00:46:01,839 --> 00:46:06,480
so that it makes those tests more likely

00:46:04,079 --> 00:46:09,200
for example like this

00:46:06,480 --> 00:46:10,640
let me start by picking a non-negative n

00:46:09,200 --> 00:46:12,720
and that that will be a small

00:46:10,640 --> 00:46:14,319
number i know that because of the way uh

00:46:12,720 --> 00:46:15,680
the library works

00:46:14,319 --> 00:46:18,079
and then i'll choose between three

00:46:15,680 --> 00:46:20,720
things either

00:46:18,079 --> 00:46:23,280
just return the small number or return

00:46:20,720 --> 00:46:25,760
the maximum value minus the small number

00:46:23,280 --> 00:46:28,000
or choose uniformly in the entire range

00:46:25,760 --> 00:46:31,119
so this generator can still generate any

00:46:28,000 --> 00:46:34,160
coin value that's valid but it will more

00:46:31,119 --> 00:46:36,400
often generate values near the endpoints

00:46:34,160 --> 00:46:38,560
and if i change this generator instead

00:46:36,400 --> 00:46:42,079
and re-test by property

00:46:38,560 --> 00:46:44,240
oh it fails actually it fails for the

00:46:42,079 --> 00:46:46,880
case of zero of a million

00:46:44,240 --> 00:46:48,720
because when you add them together add

00:46:46,880 --> 00:46:51,200
returns nothing

00:46:48,720 --> 00:46:53,280
and the property expects it to return

00:46:51,200 --> 00:46:55,119
just one million

00:46:53,280 --> 00:46:57,520
if i show you the code again i've

00:46:55,119 --> 00:46:59,920
highlighted the bits that caused the bug

00:46:57,520 --> 00:47:02,319
and it's obvious what the problem is uh

00:46:59,920 --> 00:47:04,079
in the validity test i said

00:47:02,319 --> 00:47:05,520
a valid coin must have a value less than

00:47:04,079 --> 00:47:08,000
or equal to the max

00:47:05,520 --> 00:47:09,599
and in the addition function i just

00:47:08,000 --> 00:47:12,880
tested is it less than max

00:47:09,599 --> 00:47:14,560
so i've got an off by one error and it's

00:47:12,880 --> 00:47:16,240
impossible to say which one is right i

00:47:14,560 --> 00:47:17,760
can make either choice but i must make

00:47:16,240 --> 00:47:19,760
it consistently

00:47:17,760 --> 00:47:22,160
and if i change the code so that it is

00:47:19,760 --> 00:47:25,440
consistent then the tests pass

00:47:22,160 --> 00:47:28,160
and again see the measurements

00:47:25,440 --> 00:47:30,000
and it seems that about four percent uh

00:47:28,160 --> 00:47:31,200
are boundary cases now

00:47:30,000 --> 00:47:32,880
the nice thing about changing the

00:47:31,200 --> 00:47:34,559
generator instead of just writing some

00:47:32,880 --> 00:47:37,200
unit tests for add

00:47:34,559 --> 00:47:38,160
is that with this new generator every

00:47:37,200 --> 00:47:40,640
property

00:47:38,160 --> 00:47:41,440
that needs some random coins will get

00:47:40,640 --> 00:47:43,839
ones

00:47:41,440 --> 00:47:45,040
that provoke values close to the

00:47:43,839 --> 00:47:45,839
boundary when they're added together

00:47:45,040 --> 00:47:47,359
sometimes

00:47:45,839 --> 00:47:50,839
so other properties will be tested

00:47:47,359 --> 00:47:53,040
better as well because i have a better

00:47:50,839 --> 00:47:55,520
generator

00:47:53,040 --> 00:47:56,800
you can even ask quick check to show you

00:47:55,520 --> 00:48:00,319
minimal examples

00:47:56,800 --> 00:48:03,280
with each kind of label so for example

00:48:00,319 --> 00:48:04,880
here's a normal case zero plus zero yeah

00:48:03,280 --> 00:48:06,920
that's normal

00:48:04,880 --> 00:48:11,200
here's a boundary case that sums to

00:48:06,920 --> 00:48:12,880
99999 you just add zero and 99999

00:48:11,200 --> 00:48:14,559
here's one that sums to one million zero

00:48:12,880 --> 00:48:15,839
and a million

00:48:14,559 --> 00:48:17,839
here's one that sums for a million of

00:48:15,839 --> 00:48:19,520
one zero and a billion and one oh

00:48:17,839 --> 00:48:21,200
oh no you can't do that of course

00:48:19,520 --> 00:48:22,000
because a million one would not be a

00:48:21,200 --> 00:48:23,839
valid argument

00:48:22,000 --> 00:48:25,359
no here you need one of the million and

00:48:23,839 --> 00:48:28,319
one so you see quick check

00:48:25,359 --> 00:48:30,319
finds a way of hitting each of these

00:48:28,319 --> 00:48:32,960
things in a valid way

00:48:30,319 --> 00:48:34,720
here's the overflow case um you can add

00:48:32,960 --> 00:48:37,520
three to a million and that

00:48:34,720 --> 00:48:39,920
will then be labeled as an overflow case

00:48:37,520 --> 00:48:41,760
so it's really useful to look at these

00:48:39,920 --> 00:48:43,680
because they show you if you've made a

00:48:41,760 --> 00:48:45,680
mistake in your labeling

00:48:43,680 --> 00:48:47,839
and you're relying a lot on labeling to

00:48:45,680 --> 00:48:49,839
be sure your testing is effective

00:48:47,839 --> 00:48:51,280
so it's important to see some examples

00:48:49,839 --> 00:48:52,480
these are useful to look at for that

00:48:51,280 --> 00:48:54,559
reason

00:48:52,480 --> 00:48:56,400
so there's actually a method here that

00:48:54,559 --> 00:48:57,920
one can use

00:48:56,400 --> 00:48:59,440
when you're writing property-based tests

00:48:57,920 --> 00:49:01,440
of course you have to write a property

00:48:59,440 --> 00:49:03,280
but you should still think about what

00:49:01,440 --> 00:49:04,240
are the important kinds of case you want

00:49:03,280 --> 00:49:07,040
to test

00:49:04,240 --> 00:49:09,359
but don't write unit tests write

00:49:07,040 --> 00:49:12,000
labeling code

00:49:09,359 --> 00:49:13,520
measure how often each kind of important

00:49:12,000 --> 00:49:15,680
test is generated

00:49:13,520 --> 00:49:16,720
and if you don't like the result tune

00:49:15,680 --> 00:49:19,680
the generation

00:49:16,720 --> 00:49:20,800
and keep doing it until every kind of

00:49:19,680 --> 00:49:24,319
important test

00:49:20,800 --> 00:49:24,319
is tested sufficiently often

00:49:25,119 --> 00:49:29,680
okay so what have we seen well i've

00:49:28,559 --> 00:49:31,599
shown you that

00:49:29,680 --> 00:49:32,720
property-based testing has helped us

00:49:31,599 --> 00:49:34,640
find

00:49:32,720 --> 00:49:37,119
bugs in real systems that you would

00:49:34,640 --> 00:49:38,720
never find with a handwritten test case

00:49:37,119 --> 00:49:40,319
it's particularly good at finding

00:49:38,720 --> 00:49:41,119
feature interactions which is just

00:49:40,319 --> 00:49:43,040
impractical

00:49:41,119 --> 00:49:45,200
to write tests for all of those but

00:49:43,040 --> 00:49:47,119
property-based testing can find them

00:49:45,200 --> 00:49:48,319
i hope i've persuaded you that the

00:49:47,119 --> 00:49:50,000
result of shrinking

00:49:48,319 --> 00:49:51,599
those shrunk and failed tests are really

00:49:50,000 --> 00:49:53,200
easy to debug

00:49:51,599 --> 00:49:54,720
a lot of the test case simplification

00:49:53,200 --> 00:49:57,920
that you would do manually

00:49:54,720 --> 00:49:59,119
is done for you i've talked about model

00:49:57,920 --> 00:50:00,800
based tests

00:49:59,119 --> 00:50:02,800
uh i've shown how to apply them in

00:50:00,800 --> 00:50:05,280
sequential settings concurrent settings

00:50:02,800 --> 00:50:07,359
distributed settings

00:50:05,280 --> 00:50:10,319
but they sometimes have a weakness that

00:50:07,359 --> 00:50:12,400
you replicate too much code in the tests

00:50:10,319 --> 00:50:13,760
if that happens i've shown you

00:50:12,400 --> 00:50:17,680
metamorphic tests

00:50:13,760 --> 00:50:20,800
that avoid that problem and uh

00:50:17,680 --> 00:50:22,960
i've also discussed how you have to

00:50:20,800 --> 00:50:24,640
still think about what are the important

00:50:22,960 --> 00:50:26,559
kinds of tests you want to run

00:50:24,640 --> 00:50:28,160
don't turn off your brain think about

00:50:26,559 --> 00:50:30,880
what's important

00:50:28,160 --> 00:50:33,200
label the important cases measure and

00:50:30,880 --> 00:50:33,200
tune

00:50:33,760 --> 00:50:42,720
what's the tldr don't write tests

00:50:39,200 --> 00:50:45,599
generate and if you'd like to know more

00:50:42,720 --> 00:50:47,760
uh then here is a slide with three links

00:50:45,599 --> 00:50:50,160
to two papers and another talk

00:50:47,760 --> 00:50:52,800
that go into more detail about all of

00:50:50,160 --> 00:50:57,200
the things that i've talked about

00:50:52,800 --> 00:50:57,200
okay and uh that's me

00:51:00,800 --> 00:51:03,760
have we any questions

00:51:04,960 --> 00:51:11,520
thanks very much john oh fascinating

00:51:08,480 --> 00:51:14,000
tool so uh everyone on the

00:51:11,520 --> 00:51:16,480
here on the webinar uh if you have

00:51:14,000 --> 00:51:19,599
questions uh please submit them via the

00:51:16,480 --> 00:51:22,800
uh go to webinar our questions

00:51:19,599 --> 00:51:23,839
facility uh a couple of them i have come

00:51:22,800 --> 00:51:26,960
in already so

00:51:23,839 --> 00:51:29,920
uh if that's all right so uh i'll be the

00:51:26,960 --> 00:51:30,400
uh uh the possibility uh uh who uh

00:51:29,920 --> 00:51:34,079
passes

00:51:30,400 --> 00:51:37,280
them on um so john you talked about

00:51:34,079 --> 00:51:40,480
uh how you generate uh uh

00:51:37,280 --> 00:51:44,559
are quite large are failing failing

00:51:40,480 --> 00:51:48,640
inputs um and then you shrink them down

00:51:44,559 --> 00:51:51,280
um can you say a little bit more about

00:51:48,640 --> 00:51:52,079
why why that shrinking step is necessary

00:51:51,280 --> 00:51:54,880
couldn't you

00:51:52,079 --> 00:51:57,359
have made the generator generate little

00:51:54,880 --> 00:52:00,480
tests to start with

00:51:57,359 --> 00:52:05,520
yes uh that's a very good question

00:52:00,480 --> 00:52:09,520
may i show my slides again

00:52:05,520 --> 00:52:11,760
is the slide now visible no it's not

00:52:09,520 --> 00:52:12,720
okay let me just wait a moment so what

00:52:11,760 --> 00:52:15,920
i'm going to show you

00:52:12,720 --> 00:52:19,119
is results of a small experiment and

00:52:15,920 --> 00:52:20,960
that illustrates why we do this so

00:52:19,119 --> 00:52:23,200
this is an experiment when i was looking

00:52:20,960 --> 00:52:25,200
for a bug that i knew existed

00:52:23,200 --> 00:52:26,720
that was just four steps long and fairly

00:52:25,200 --> 00:52:28,640
easy to find

00:52:26,720 --> 00:52:30,720
so what i could do is i could generate

00:52:28,640 --> 00:52:33,280
random tests of various sizes and see

00:52:30,720 --> 00:52:36,160
how many of them hit the bug

00:52:33,280 --> 00:52:38,079
and what you see here is the measured

00:52:36,160 --> 00:52:40,000
probability of failure

00:52:38,079 --> 00:52:41,359
as a function of the number of steps in

00:52:40,000 --> 00:52:43,280
the test case

00:52:41,359 --> 00:52:46,079
now you might think i'm looking for a

00:52:43,280 --> 00:52:47,440
bug that i know is four steps long so

00:52:46,079 --> 00:52:50,480
why don't i just generate

00:52:47,440 --> 00:52:52,000
four step tests well the measured

00:52:50,480 --> 00:52:54,880
probability

00:52:52,000 --> 00:52:56,400
of finding the bug with a four step test

00:52:54,880 --> 00:52:58,559
is zero

00:52:56,400 --> 00:53:01,440
no four step test that i ever generated

00:52:58,559 --> 00:53:03,520
in this experiment actually failed

00:53:01,440 --> 00:53:06,319
on the other hand if we look at the

00:53:03,520 --> 00:53:09,520
tests that are say 40 steps long

00:53:06,319 --> 00:53:13,280
then um 60 of those tests

00:53:09,520 --> 00:53:14,079
revealed the bug so we can see here that

00:53:13,280 --> 00:53:17,200
the probably

00:53:14,079 --> 00:53:20,400
probability of a test revealing the bug

00:53:17,200 --> 00:53:21,040
rises dramatically as the size of the

00:53:20,400 --> 00:53:23,760
test

00:53:21,040 --> 00:53:24,720
case increases and the intuition is the

00:53:23,760 --> 00:53:27,119
one that i

00:53:24,720 --> 00:53:28,079
gave during the talk right it's because

00:53:27,119 --> 00:53:31,280
what matters is

00:53:28,079 --> 00:53:33,040
that somewhere in this larger test

00:53:31,280 --> 00:53:34,559
the bad sequence that provokes the bug

00:53:33,040 --> 00:53:37,040
happens um

00:53:34,559 --> 00:53:38,240
but it doesn't matter so much exactly

00:53:37,040 --> 00:53:39,920
where it appears

00:53:38,240 --> 00:53:41,520
now you might object and you might say

00:53:39,920 --> 00:53:43,680
well yes

00:53:41,520 --> 00:53:44,800
longer tests may be more likely to hit

00:53:43,680 --> 00:53:48,480
the bug

00:53:44,800 --> 00:53:51,680
but they're also more expensive to run

00:53:48,480 --> 00:53:52,640
of course that's true so the right thing

00:53:51,680 --> 00:53:55,440
to measure here

00:53:52,640 --> 00:53:56,720
is not the probability of failure per

00:53:55,440 --> 00:54:00,480
test

00:53:56,720 --> 00:54:03,520
but the probability of failure per step

00:54:00,480 --> 00:54:06,800
right per unit of work and

00:54:03,520 --> 00:54:08,880
if we look at that graph here it is

00:54:06,800 --> 00:54:10,480
on the x-axis you still have the total

00:54:08,880 --> 00:54:12,400
size of each test case

00:54:10,480 --> 00:54:13,680
but what this shows is how much each

00:54:12,400 --> 00:54:16,000
step contributes

00:54:13,680 --> 00:54:18,240
to the probability of failure so if you

00:54:16,000 --> 00:54:21,520
generate test cases of length four

00:54:18,240 --> 00:54:22,839
as we saw it's zero if you generate test

00:54:21,520 --> 00:54:26,079
cases of length

00:54:22,839 --> 00:54:28,559
30 we're around the peak and

00:54:26,079 --> 00:54:29,440
for each step then you've got you know

00:54:28,559 --> 00:54:31,680
1.6

00:54:29,440 --> 00:54:33,280
chance of fighting the bug and this

00:54:31,680 --> 00:54:36,480
graph really shows

00:54:33,280 --> 00:54:39,920
how the bang for the testing buck varies

00:54:36,480 --> 00:54:42,319
as the size of the test case grows

00:54:39,920 --> 00:54:44,000
longer tests are quite simply far more

00:54:42,319 --> 00:54:46,079
effective per unit of effort

00:54:44,000 --> 00:54:47,520
of provoking faults and this is an

00:54:46,079 --> 00:54:49,280
effect that we have observed

00:54:47,520 --> 00:54:51,280
many many times with property-based

00:54:49,280 --> 00:54:52,079
tests and other people working in random

00:54:51,280 --> 00:54:54,000
testing have also

00:54:52,079 --> 00:54:56,640
observed something similar so it seems

00:54:54,000 --> 00:54:58,400
to be a very general phenomenon

00:54:56,640 --> 00:55:00,240
and you want to know about it and take

00:54:58,400 --> 00:55:02,079
advantage of it the way you take

00:55:00,240 --> 00:55:03,359
advantage of it is by generating larger

00:55:02,079 --> 00:55:05,119
tests

00:55:03,359 --> 00:55:07,760
but to make debugging the results

00:55:05,119 --> 00:55:10,960
feasible you need to shrink them

00:55:07,760 --> 00:55:16,400
to a minimal fading result so this is

00:55:10,960 --> 00:55:16,400
a key reason why this works so well

00:55:17,839 --> 00:55:22,079
thank you very much another question

00:55:19,680 --> 00:55:24,559
came in um

00:55:22,079 --> 00:55:27,760
is property-based testing restricted to

00:55:24,559 --> 00:55:31,040
functional programming languages

00:55:27,760 --> 00:55:35,520
um well

00:55:31,040 --> 00:55:38,160
so the second test that i showed you

00:55:35,520 --> 00:55:38,720
was testing low level c code that runs

00:55:38,160 --> 00:55:42,000
on

00:55:38,720 --> 00:55:44,960
the hundred or so processors in cars so

00:55:42,000 --> 00:55:46,400
absolutely not um some of the most

00:55:44,960 --> 00:55:48,400
exciting projects we've done have been

00:55:46,400 --> 00:55:50,319
for customers who have not been using

00:55:48,400 --> 00:55:52,000
functional programming languages for

00:55:50,319 --> 00:55:53,440
their system

00:55:52,000 --> 00:55:56,079
but we used functional programming

00:55:53,440 --> 00:55:59,119
languages for the properties

00:55:56,079 --> 00:56:02,160
for the models and

00:55:59,119 --> 00:56:04,400
that that is um i think you really do

00:56:02,160 --> 00:56:06,559
want to use purely functional properties

00:56:04,400 --> 00:56:08,319
purely functional models because if you

00:56:06,559 --> 00:56:09,839
start getting tests failing because of

00:56:08,319 --> 00:56:12,240
side effects

00:56:09,839 --> 00:56:14,000
in your model you know god help you

00:56:12,240 --> 00:56:15,040
especially once you start shrinking it's

00:56:14,000 --> 00:56:18,079
not at all

00:56:15,040 --> 00:56:20,079
obvious to the user what order different

00:56:18,079 --> 00:56:21,920
bits the model will get evaluated in

00:56:20,079 --> 00:56:23,599
and people who try to use side effects

00:56:21,920 --> 00:56:25,839
there get very confused

00:56:23,599 --> 00:56:28,240
that said there are re-implementations

00:56:25,839 --> 00:56:31,440
of the property-based testing idea

00:56:28,240 --> 00:56:31,920
in virtually every major programming

00:56:31,440 --> 00:56:33,200
language

00:56:31,920 --> 00:56:36,079
including the ones that are not

00:56:33,200 --> 00:56:38,960
functional um but i would say

00:56:36,079 --> 00:56:40,480
when you use those implementations you

00:56:38,960 --> 00:56:41,440
should use them in a purely functional

00:56:40,480 --> 00:56:44,799
way

00:56:41,440 --> 00:56:47,280
just to avoid your brain exploding

00:56:44,799 --> 00:56:49,680
exploded brains are ugly we don't like

00:56:47,280 --> 00:56:49,680
to see that

00:56:49,839 --> 00:56:54,319
all right uh uh there are there are some

00:56:52,160 --> 00:56:57,520
more questions but unfortunately we're

00:56:54,319 --> 00:56:58,240
upon uh up on time uh thanks very much

00:56:57,520 --> 00:57:00,640
john

00:56:58,240 --> 00:57:02,319
for uh for giving the giving the talk

00:57:00,640 --> 00:57:05,440
and answering our questions

00:57:02,319 --> 00:57:05,920
uh thanks everybody for uh for attending

00:57:05,440 --> 00:57:08,960
and

00:57:05,920 --> 00:57:12,160
i hope to see you at the next uh octo

00:57:08,960 --> 00:57:25,960
webinar thank you very much thank you

00:57:12,160 --> 00:57:31,119
very much you guys it was great fun

00:57:25,960 --> 00:57:33,200
[Music]

00:57:31,119 --> 00:57:33,200

YouTube URL: https://www.youtube.com/watch?v=1LNEWF8s1hI


