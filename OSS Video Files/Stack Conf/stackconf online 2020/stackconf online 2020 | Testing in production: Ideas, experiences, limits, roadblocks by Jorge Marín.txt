Title: stackconf online 2020 | Testing in production: Ideas, experiences, limits, roadblocks by Jorge MarÃ­n
Publication date: 2020-06-27
Playlist: stackconf online 2020
Description: 
	Are you afraid of testing in production? Do you test in production? Do you use real data? By definition testing in production is hard. This talk puts together my experience testing in production a large scale backend system and APIs that affects millions of users. Experience, ideas, limits, roadblocks, tips and more.

NETWAYS
Konferenzen: https://www.netways.de/events
Schulungen: https://www.netways.de/schulungen
Shop: https://shop.netways.de/
Blog: http://blog.netways.de/
NWS: https://nws.netways.de 

Webinare
Archiv Link: https://www.netways.de/webinare/archi...
Aktuell: https://www.netways.de/wb

Social Media
SlideShare: http://de.slideshare.net/netways
YouTube: https://www.netways.de/youtube
Facebook: https://www.facebook.com/netways
Twitter: https://twitter.com/netways
Instagram: https://www.instagram.com/netwaysgmbh/

Music: Walking on Air - https://www.frametraxx.de/
Captions: 
	00:00:00,450 --> 00:00:17,770
[Music]

00:00:13,140 --> 00:00:19,779
all right let's do this let's do this hi

00:00:17,770 --> 00:00:21,640
welcome to the session about testing in

00:00:19,779 --> 00:00:23,740
production as Provost our comfort to a

00:00:21,640 --> 00:00:25,599
20/20 I hope you're having a good day

00:00:23,740 --> 00:00:27,310
and if it goes well you enjoy the

00:00:25,599 --> 00:00:33,430
presentation I'll learn something new

00:00:27,310 --> 00:00:35,380
today try I won't bore you with details

00:00:33,430 --> 00:00:37,420
about my life all I want to say is that

00:00:35,380 --> 00:00:39,070
my name is Jorge and I'm an engineer I

00:00:37,420 --> 00:00:41,530
work on all tournaments indoor

00:00:39,070 --> 00:00:43,180
navigation for UAVs that was my passion

00:00:41,530 --> 00:00:45,579
but then got dragged to the cloud space

00:00:43,180 --> 00:00:47,469
and currently working a Dyson as a

00:00:45,579 --> 00:00:49,449
software engineer just a vacuum cleaner

00:00:47,469 --> 00:00:53,469
company and no I don't have any spare

00:00:49,449 --> 00:00:55,839
despairity scan codes now every time

00:00:53,469 --> 00:00:58,510
every presentation I like to start with

00:00:55,839 --> 00:01:01,780
a small port time and I'll ask the

00:00:58,510 --> 00:01:03,850
public to raise your hands but given

00:01:01,780 --> 00:01:06,190
this is a virtual conference I won't see

00:01:03,850 --> 00:01:08,620
you raising your hands so please use the

00:01:06,190 --> 00:01:10,120
comment section and then after the

00:01:08,620 --> 00:01:12,850
slides follow me into it and like and

00:01:10,120 --> 00:01:15,130
subscribe now raise your hands I want

00:01:12,850 --> 00:01:17,920
you to raise your hand if you are having

00:01:15,130 --> 00:01:21,490
a good day or you often forget to squash

00:01:17,920 --> 00:01:24,250
before merge now if you know what

00:01:21,490 --> 00:01:26,200
testing is if you know about the testing

00:01:24,250 --> 00:01:28,780
pyramid and any other way of classifying

00:01:26,200 --> 00:01:30,850
different testing levels if you have a

00:01:28,780 --> 00:01:33,220
production environment probably you do

00:01:30,850 --> 00:01:36,550
and if you're testing your services in

00:01:33,220 --> 00:01:37,990
production I hope you are and also raise

00:01:36,550 --> 00:01:40,470
your hand so put it in the comments

00:01:37,990 --> 00:01:44,200
section if you prefer spaces to tops

00:01:40,470 --> 00:01:45,880
now this talk is going to be mostly

00:01:44,200 --> 00:01:47,860
answer to frequent ask questions around

00:01:45,880 --> 00:01:50,230
the end-to-end test and the different

00:01:47,860 --> 00:01:52,360
levels of testing for production systems

00:01:50,230 --> 00:01:54,520
it's not going to be too technical and

00:01:52,360 --> 00:01:57,190
it's based on my experience on the

00:01:54,520 --> 00:02:00,090
spirits I acquired by while working at

00:01:57,190 --> 00:02:02,860
Dyson for the past two and a half years

00:02:00,090 --> 00:02:07,289
the main takeaways for this session I

00:02:02,860 --> 00:02:10,929
want you to understand or to learn is

00:02:07,289 --> 00:02:12,580
why do you need tests in production I'm

00:02:10,929 --> 00:02:15,489
gonna explain that to a certain level

00:02:12,580 --> 00:02:17,500
what is was the right level of testing

00:02:15,489 --> 00:02:19,590
against production systems what is the

00:02:17,500 --> 00:02:22,360
kind of testing that's appropriate and

00:02:19,590 --> 00:02:24,550
then I'm gonna talk a bit about how to

00:02:22,360 --> 00:02:28,630
build and twin tests for mic

00:02:24,550 --> 00:02:33,060
service API base architecture and then

00:02:28,630 --> 00:02:35,380
finally how to fight dragons so a lousy

00:02:33,060 --> 00:02:37,930
why do you need testing in production

00:02:35,380 --> 00:02:39,940
well that's a good question but first we

00:02:37,930 --> 00:02:43,750
need to answer what do you mean by

00:02:39,940 --> 00:02:45,910
testing in production let's put this to

00:02:43,750 --> 00:02:48,370
guarantee that your lambda your service

00:02:45,910 --> 00:02:51,430
or your application continues to work

00:02:48,370 --> 00:02:54,340
consistently after their release or the

00:02:51,430 --> 00:02:57,280
deployment this means that you have you

00:02:54,340 --> 00:02:59,740
need to have some kind of automatic

00:02:57,280 --> 00:03:02,470
scheduled tests to guarantee that your

00:02:59,740 --> 00:03:04,090
application still works as suspected

00:03:02,470 --> 00:03:07,210
after being deployed to production

00:03:04,090 --> 00:03:11,470
because the users are being constantly

00:03:07,210 --> 00:03:13,690
using it and you might say well I have

00:03:11,470 --> 00:03:15,370
the best real-time health dashboard that

00:03:13,690 --> 00:03:18,370
will notify me if something goes wrong

00:03:15,370 --> 00:03:20,800
and I'll know and then I'll just fix it

00:03:18,370 --> 00:03:22,150
what's the problem with that well are

00:03:20,800 --> 00:03:25,090
you sure you are really protected

00:03:22,150 --> 00:03:27,430
against bugs in production let me put

00:03:25,090 --> 00:03:31,750
this a sample so imagine a function

00:03:27,430 --> 00:03:33,850
right a server less service the only

00:03:31,750 --> 00:03:36,270
purpose is to return the current date so

00:03:33,850 --> 00:03:39,430
it has a function let's go get date and

00:03:36,270 --> 00:03:42,160
whenever you perform a get action on it

00:03:39,430 --> 00:03:44,290
it returns the current date it's a

00:03:42,160 --> 00:03:48,610
pretty simple I'm pretty easy to use

00:03:44,290 --> 00:03:50,500
function it has been unit tested we also

00:03:48,610 --> 00:03:52,750
have integration tests and it has also

00:03:50,500 --> 00:03:54,400
been manually tested several times and

00:03:52,750 --> 00:03:58,750
it always returned did occur in date

00:03:54,400 --> 00:04:01,450
right so what's the problem well until

00:03:58,750 --> 00:04:04,950
the year 2038 so what happens in the

00:04:01,450 --> 00:04:07,450
year 2038 we have what's called the y2k

00:04:04,950 --> 00:04:11,950
38 which is similar to the problem of

00:04:07,450 --> 00:04:14,530
y2k the happen back in and the 2000 so

00:04:11,950 --> 00:04:17,709
most programs or most computers store

00:04:14,530 --> 00:04:20,830
the date the current date as a signed

00:04:17,709 --> 00:04:24,490
32-bit integer and you can see on the

00:04:20,830 --> 00:04:27,940
screen all that many zeros those are 32

00:04:24,490 --> 00:04:30,580
zeros and this is a starting date so

00:04:27,940 --> 00:04:33,250
it's the first of January in 1970 at the

00:04:30,580 --> 00:04:36,370
zero zero zero zero zero zero in UTC of

00:04:33,250 --> 00:04:38,290
course so it's plus zero seconds this is

00:04:36,370 --> 00:04:42,700
the beginning of the unix time

00:04:38,290 --> 00:04:47,890
now what's today today looks like this

00:04:42,700 --> 00:04:50,710
today is the 17th of June of 2020 it's

00:04:47,890 --> 00:04:53,470
plush one five nine twenty three seventy

00:04:50,710 --> 00:04:56,830
nine zero zero zero seconds and it

00:04:53,470 --> 00:05:02,260
looked like that in the registry now if

00:04:56,830 --> 00:05:05,200
we go ahead in time we we we go to the

00:05:02,260 --> 00:05:09,100
future and then we have stop at the

00:05:05,200 --> 00:05:12,070
moment this registry is all ones except

00:05:09,100 --> 00:05:14,470
the first digit what date is that one so

00:05:12,070 --> 00:05:19,120
that date is going to be the 19th of

00:05:14,470 --> 00:05:24,850
january 2038 at 3 a.m. 14 minutes 7

00:05:19,120 --> 00:05:27,760
seconds that moment in the year 2038 all

00:05:24,850 --> 00:05:30,070
that registry is going to be one it's

00:05:27,760 --> 00:05:33,130
going to have the value of 1 in binary

00:05:30,070 --> 00:05:36,280
except the first digit which is 0 what

00:05:33,130 --> 00:05:38,080
happens the next second so this is

00:05:36,280 --> 00:05:42,490
remember this is the the number of

00:05:38,080 --> 00:05:45,790
seconds since 1970 so if we add one

00:05:42,490 --> 00:05:48,610
second to this registry we get this

00:05:45,790 --> 00:05:51,580
number right what's wrong with it well

00:05:48,610 --> 00:05:57,190
if you again remember I said that this

00:05:51,580 --> 00:06:00,520
is a 32-bit a sign integer so the first

00:05:57,190 --> 00:06:04,090
digit is the sign of the number so this

00:06:00,520 --> 00:06:07,180
represent - two one four seven four

00:06:04,090 --> 00:06:12,070
eight three six four eight seconds which

00:06:07,180 --> 00:06:17,620
correspond to the day before the 13 of

00:06:12,070 --> 00:06:18,820
December 1901 like it was a Friday like

00:06:17,620 --> 00:06:21,430
a hundred years ago

00:06:18,820 --> 00:06:23,800
it's one day after Guillermo Marconi

00:06:21,430 --> 00:06:26,110
received the first transatlantic radio

00:06:23,800 --> 00:06:29,950
signal from Kong Warren England to

00:06:26,110 --> 00:06:31,450
Newfoundland in Canada so it you're

00:06:29,950 --> 00:06:32,920
gonna have this problem no matter how

00:06:31,450 --> 00:06:35,590
many tests you perform before their

00:06:32,920 --> 00:06:37,210
release they get that functioning so

00:06:35,590 --> 00:06:39,550
we're going to return the current date

00:06:37,210 --> 00:06:40,990
up to this point at this point the

00:06:39,550 --> 00:06:43,300
function breaks and it's going to break

00:06:40,990 --> 00:06:45,370
for all your user base so the bug will

00:06:43,300 --> 00:06:49,390
only share when in production as most

00:06:45,370 --> 00:06:52,090
bugs to be honest so yeah

00:06:49,390 --> 00:06:53,440
tic-tac tic-tac but don't worry it's

00:06:52,090 --> 00:06:54,970
gonna be the end of the world stop

00:06:53,440 --> 00:06:57,550
runnin all over your apartment screaming

00:06:54,970 --> 00:06:59,620
we already know this and our systems are

00:06:57,550 --> 00:07:04,210
and programs are already prepare and

00:06:59,620 --> 00:07:06,550
patch by them so now put this example

00:07:04,210 --> 00:07:08,740
extrapolated to a real service so one of

00:07:06,550 --> 00:07:10,900
your estate for services becoming

00:07:08,740 --> 00:07:13,030
consistent and I start failing for all

00:07:10,900 --> 00:07:14,770
customers by the time you start looking

00:07:13,030 --> 00:07:16,630
at the problem a big part of your

00:07:14,770 --> 00:07:19,720
customer base is already effective and

00:07:16,630 --> 00:07:21,220
your customer line is on fire and your

00:07:19,720 --> 00:07:23,650
customer might be saying things that I

00:07:21,220 --> 00:07:26,050
cannot login or I cannot change my

00:07:23,650 --> 00:07:28,900
profile picture or can order a chocolate

00:07:26,050 --> 00:07:32,410
milkshake to take away at this moment in

00:07:28,900 --> 00:07:34,270
time you you consider making this

00:07:32,410 --> 00:07:36,880
decision you consider you start

00:07:34,270 --> 00:07:39,040
comparing the two different things

00:07:36,880 --> 00:07:41,080
testing in production and not testing in

00:07:39,040 --> 00:07:43,300
production so if you don't test in

00:07:41,080 --> 00:07:45,160
production you have this real pain real

00:07:43,300 --> 00:07:47,350
angry paying customers calling you

00:07:45,160 --> 00:07:50,110
because what they paid for it's not

00:07:47,350 --> 00:07:52,360
working and then you fix the bad yeah

00:07:50,110 --> 00:07:55,270
that's alright but you already have all

00:07:52,360 --> 00:07:58,710
your customers behind you telling you

00:07:55,270 --> 00:08:01,450
that it didn't work when they need it

00:07:58,710 --> 00:08:04,840
now compare that to having an automated

00:08:01,450 --> 00:08:07,360
process acting as a real user that

00:08:04,840 --> 00:08:09,550
performs so the actions are a real user

00:08:07,360 --> 00:08:12,520
is supposed to perform but in an

00:08:09,550 --> 00:08:15,310
automated way and it's gonna be so fast

00:08:12,520 --> 00:08:19,020
that you're going to be notified even

00:08:15,310 --> 00:08:24,280
before any actual real customer can

00:08:19,020 --> 00:08:28,570
stumble upon the bug now are you

00:08:24,280 --> 00:08:30,970
convinced already or not yeah well let's

00:08:28,570 --> 00:08:34,240
compare the speed of the two methods

00:08:30,970 --> 00:08:37,870
right so if we have the first method no

00:08:34,240 --> 00:08:40,029
test in production or your customers are

00:08:37,870 --> 00:08:42,520
running behind you and telling you that

00:08:40,029 --> 00:08:44,350
your application is not working whereas

00:08:42,520 --> 00:08:46,930
if you use this testing in production

00:08:44,350 --> 00:08:49,300
approach you will fail fast you will

00:08:46,930 --> 00:08:54,070
notify your engineers fast and you'll

00:08:49,300 --> 00:08:56,970
fix fast so the buck might be fixed even

00:08:54,070 --> 00:09:01,150
before reaching your user base

00:08:56,970 --> 00:09:05,710
now if we compare the losses you're

00:09:01,150 --> 00:09:08,860
losing time money and also losing

00:09:05,710 --> 00:09:10,900
you are spending a lot of resources on

00:09:08,860 --> 00:09:12,100
support because all your customers are

00:09:10,900 --> 00:09:14,050
going to be calling the support line

00:09:12,100 --> 00:09:16,690
telling you that it's not working and

00:09:14,050 --> 00:09:18,160
that's time and that's money but if you

00:09:16,690 --> 00:09:20,710
have this automated process

00:09:18,160 --> 00:09:26,470
you don't need to have that many support

00:09:20,710 --> 00:09:30,160
lines and it will find the bug faster

00:09:26,470 --> 00:09:33,100
than I use a wood and the last thing is

00:09:30,160 --> 00:09:37,450
reputation so if a lot of users are

00:09:33,100 --> 00:09:39,130
experienced in the same error then a the

00:09:37,450 --> 00:09:41,530
reputation of your company of the

00:09:39,130 --> 00:09:43,720
reputation for your service it's going

00:09:41,530 --> 00:09:47,140
to be pretty low and users are going to

00:09:43,720 --> 00:09:48,850
be a bit angry at you but if you have

00:09:47,140 --> 00:09:50,890
this automated process and you're

00:09:48,850 --> 00:09:53,350
testing in production constantly the

00:09:50,890 --> 00:09:57,810
amount of users that will get hit by

00:09:53,350 --> 00:10:01,690
this but this bug will be will be much

00:09:57,810 --> 00:10:05,380
significant less are you convinced

00:10:01,690 --> 00:10:06,850
already now you should but let's talk a

00:10:05,380 --> 00:10:10,780
bit more about what's the right level

00:10:06,850 --> 00:10:12,790
for testing in production right so most

00:10:10,780 --> 00:10:15,580
of you have already seen the testing

00:10:12,790 --> 00:10:18,850
pyramid it might look like this one or

00:10:15,580 --> 00:10:22,780
like this one or like this one or like

00:10:18,850 --> 00:10:25,510
this one ad infinitum right so let's

00:10:22,780 --> 00:10:27,580
take this one for example and let's talk

00:10:25,510 --> 00:10:30,010
a bit about it so at the bottom you have

00:10:27,580 --> 00:10:31,660
the unit tests then we have the

00:10:30,010 --> 00:10:35,350
integration tests and finally we have

00:10:31,660 --> 00:10:39,670
the end-to-end test of course the more

00:10:35,350 --> 00:10:42,430
at the bottom we are and there's a small

00:10:39,670 --> 00:10:46,960
area the size of the test but also the

00:10:42,430 --> 00:10:50,500
more up we go the long they're more

00:10:46,960 --> 00:10:53,080
expensive it is to run the test is to

00:10:50,500 --> 00:10:56,260
write them is to run them in terms of

00:10:53,080 --> 00:10:58,990
time in terms of resources it's more

00:10:56,260 --> 00:11:01,150
complicated right but they give more

00:10:58,990 --> 00:11:03,940
value more user values they deliver more

00:11:01,150 --> 00:11:05,800
user value so if we look at their at the

00:11:03,940 --> 00:11:08,770
middle one which is which are the

00:11:05,800 --> 00:11:11,230
integration test this would test the

00:11:08,770 --> 00:11:13,900
minimal unit after the deployment so

00:11:11,230 --> 00:11:15,670
when you deploy a service you do some

00:11:13,900 --> 00:11:17,800
kind of integration test against our

00:11:15,670 --> 00:11:19,420
service to to see if that service is

00:11:17,800 --> 00:11:21,790
working final know your

00:11:19,420 --> 00:11:24,250
in the service as a black box and you

00:11:21,790 --> 00:11:25,990
only interface with that service and the

00:11:24,250 --> 00:11:28,210
next level is to have the end-to-end

00:11:25,990 --> 00:11:32,830
test the end-to-end tests are looking at

00:11:28,210 --> 00:11:36,100
all the services at a time as a real

00:11:32,830 --> 00:11:39,010
user will do so it's the minimal unit I

00:11:36,100 --> 00:11:41,260
use this now a minimal unit after the

00:11:39,010 --> 00:11:44,260
deployment but what the user actually is

00:11:41,260 --> 00:11:47,740
interacting with so it always refers to

00:11:44,260 --> 00:11:50,290
a user action I user intent or what we

00:11:47,740 --> 00:11:54,430
call I use a journey so for example

00:11:50,290 --> 00:11:57,160
changing checking your profile picture

00:11:54,430 --> 00:11:59,560
it's a user journey because it will

00:11:57,160 --> 00:12:01,870
involve several it might involve several

00:11:59,560 --> 00:12:04,630
micro services so you want to test all

00:12:01,870 --> 00:12:09,330
the services at the whole as a whole and

00:12:04,630 --> 00:12:12,400
not the single services separated now

00:12:09,330 --> 00:12:13,840
let's put some examples right so now

00:12:12,400 --> 00:12:17,130
that I'm talking about the entrant test

00:12:13,840 --> 00:12:20,530
and saying how how important are they

00:12:17,130 --> 00:12:23,740
let's talk at how we implemented this or

00:12:20,530 --> 00:12:26,380
how we approach this a Dyson the company

00:12:23,740 --> 00:12:27,520
including working for so a Dyson at the

00:12:26,380 --> 00:12:30,240
moment we have more than 1 million

00:12:27,520 --> 00:12:33,550
connected devices connected devices like

00:12:30,240 --> 00:12:35,380
robots like vacuum cleaners like air

00:12:33,550 --> 00:12:37,450
purifiers that are connected to the

00:12:35,380 --> 00:12:39,010
cloud right and we need to interact with

00:12:37,450 --> 00:12:40,930
them and the user is also interacting

00:12:39,010 --> 00:12:43,390
and sending commands to the machine to

00:12:40,930 --> 00:12:46,120
say hey could you please start clean hey

00:12:43,390 --> 00:12:48,160
Dyson could you tell me what the quality

00:12:46,120 --> 00:12:50,620
was the air quality and my bedroom is

00:12:48,160 --> 00:12:53,830
and that kind of stuff and we are

00:12:50,620 --> 00:12:56,140
approaching 2 million devices now we

00:12:53,830 --> 00:12:58,360
have users all over the world and all

00:12:56,140 --> 00:13:00,280
the users are performing the actions as

00:12:58,360 --> 00:13:04,120
for example renaming the robot or

00:13:00,280 --> 00:13:06,280
telling the robot to clean but how can

00:13:04,120 --> 00:13:09,970
we define that end to end test that

00:13:06,280 --> 00:13:17,350
example so we could define an in to add

00:13:09,970 --> 00:13:20,320
test like a mix or a batch of single

00:13:17,350 --> 00:13:24,520
actions or very specific actions that in

00:13:20,320 --> 00:13:26,680
the end that Indian describe an end to

00:13:24,520 --> 00:13:30,250
end user journey and describe a specific

00:13:26,680 --> 00:13:32,350
a scenario so to put as an example we

00:13:30,250 --> 00:13:33,960
could have this given an existing user

00:13:32,350 --> 00:13:37,390
with this config

00:13:33,960 --> 00:13:39,550
when the user and the user locks in the

00:13:37,390 --> 00:13:42,490
user then changes the robot name to

00:13:39,550 --> 00:13:45,310
robohelp 9000 then the robot name has

00:13:42,490 --> 00:13:47,290
chained to robohelp 9000 that's it as

00:13:45,310 --> 00:13:50,890
simple as that doesn't lessen Lu

00:13:47,290 --> 00:13:53,200
that's a user journey from n to n so the

00:13:50,890 --> 00:13:55,990
user starts do you have a user you have

00:13:53,200 --> 00:13:58,030
a configuration and the end is they use

00:13:55,990 --> 00:14:00,310
it the robot name has changed to the

00:13:58,030 --> 00:14:02,290
name that the user has set in the middle

00:14:00,310 --> 00:14:04,690
of the test and this is testing several

00:14:02,290 --> 00:14:07,600
services in the middle this is testing

00:14:04,690 --> 00:14:09,370
the logging services testing the micro

00:14:07,600 --> 00:14:11,500
service for changing the robot name is

00:14:09,370 --> 00:14:17,220
testing also that the robot is receiving

00:14:11,500 --> 00:14:20,050
their correct commands and much more now

00:14:17,220 --> 00:14:22,930
in terms of the architecture how would

00:14:20,050 --> 00:14:27,160
you how would you create or how how

00:14:22,930 --> 00:14:29,470
would you define this level this

00:14:27,160 --> 00:14:31,900
individual steps because you need a real

00:14:29,470 --> 00:14:33,580
user you'll need a real machine and you

00:14:31,900 --> 00:14:36,610
need a real cloud to see all the

00:14:33,580 --> 00:14:38,920
interactions going around as you can see

00:14:36,610 --> 00:14:41,080
here you have the users which talk to

00:14:38,920 --> 00:14:43,120
the cloud through the through the

00:14:41,080 --> 00:14:46,420
smartphone app and we also have the

00:14:43,120 --> 00:14:49,150
machine in this case a robot what

00:14:46,420 --> 00:14:51,610
happens is that we can write a service

00:14:49,150 --> 00:14:55,300
that interacts with the cloud but also

00:14:51,610 --> 00:14:57,970
inside has mock or there has it's

00:14:55,300 --> 00:15:00,070
emulating what the users or what the

00:14:57,970 --> 00:15:03,160
smartphone app or what the robot will do

00:15:00,070 --> 00:15:06,490
and it's just a single app it's it's all

00:15:03,160 --> 00:15:09,160
software so it's it's gonna be talking

00:15:06,490 --> 00:15:10,750
to the cloud and all we care about it

00:15:09,160 --> 00:15:12,610
was happening in the cloud and we are

00:15:10,750 --> 00:15:15,520
receiving and that we are receiving the

00:15:12,610 --> 00:15:17,290
correct responses and we are acting with

00:15:15,520 --> 00:15:22,089
the correct commands and answering with

00:15:17,290 --> 00:15:25,300
the correct data so this is how you

00:15:22,089 --> 00:15:27,730
define it and then if you want to know a

00:15:25,300 --> 00:15:30,190
bit more about how to implement this in

00:15:27,730 --> 00:15:33,370
a real war scenario we could use a

00:15:30,190 --> 00:15:36,060
library that's called koo kumba is the

00:15:33,370 --> 00:15:39,070
cocoon bird library is defined in this

00:15:36,060 --> 00:15:41,589
behavior driving test where you tell the

00:15:39,070 --> 00:15:43,270
test what are you doing and what do you

00:15:41,589 --> 00:15:46,180
expect and you don't care what's

00:15:43,270 --> 00:15:47,240
happening inside as we explain the user

00:15:46,180 --> 00:15:49,940
login the user

00:15:47,240 --> 00:15:50,959
the robot name and then the Robin name

00:15:49,940 --> 00:15:53,600
gets changed

00:15:50,959 --> 00:15:56,300
that's how cuckoo bird works so it's a

00:15:53,600 --> 00:15:58,700
combination of this library khumba is

00:15:56,300 --> 00:15:59,860
the request and a cell library because

00:15:58,700 --> 00:16:04,190
we are working with

00:15:59,860 --> 00:16:06,770
microservices api's so we have as I said

00:16:04,190 --> 00:16:08,779
lots of single steps defining the calls

00:16:06,770 --> 00:16:11,510
to the different api's and doing data

00:16:08,779 --> 00:16:14,089
transformations to emulate or simulate

00:16:11,510 --> 00:16:16,850
the users and their and the machines and

00:16:14,089 --> 00:16:20,720
then we group them together to form a

00:16:16,850 --> 00:16:23,390
user journey or a scenario these are

00:16:20,720 --> 00:16:25,490
some examples of scenarios you could

00:16:23,390 --> 00:16:27,920
define given an existing user with this

00:16:25,490 --> 00:16:29,870
configuration when the user locks in and

00:16:27,920 --> 00:16:32,540
the user changes Devon into Robo mode

00:16:29,870 --> 00:16:36,110
9000 then the robot name has changed to

00:16:32,540 --> 00:16:38,000
Robin Robin hobb 9000 given a 16 user

00:16:36,110 --> 00:16:39,980
with this configuration when the user

00:16:38,000 --> 00:16:42,529
logs in and the use of schedules are

00:16:39,980 --> 00:16:45,170
clean then the robot starts to clean

00:16:42,529 --> 00:16:47,600
within 10 seconds and another one will

00:16:45,170 --> 00:16:50,270
be given an existing user the user locks

00:16:47,600 --> 00:16:52,640
in the user stops to clean then the

00:16:50,270 --> 00:16:58,399
robot returns to the base within 10

00:16:52,640 --> 00:17:00,890
seconds so those are examples but these

00:16:58,399 --> 00:17:03,110
are the end-to-end tests they sound cool

00:17:00,890 --> 00:17:04,610
they are cool but they have its sound

00:17:03,110 --> 00:17:06,620
down sights because you are testing in

00:17:04,610 --> 00:17:09,620
production you're gonna have some issues

00:17:06,620 --> 00:17:13,309
as this is production and all your

00:17:09,620 --> 00:17:15,620
customer base or your users are also

00:17:13,309 --> 00:17:18,890
using the same system in production if

00:17:15,620 --> 00:17:20,480
your test is or if your tests are too

00:17:18,890 --> 00:17:23,179
close to the real users and the real

00:17:20,480 --> 00:17:25,880
actions do you might have a side effect

00:17:23,179 --> 00:17:27,800
where your tests are affecting your

00:17:25,880 --> 00:17:31,670
platform and are affecting for example

00:17:27,800 --> 00:17:34,520
there the backend so let's say you run a

00:17:31,670 --> 00:17:37,040
lot of end-to-end tests because you want

00:17:34,520 --> 00:17:38,929
to know how your Services is doing its

00:17:37,040 --> 00:17:41,210
performing and you do it I don't know

00:17:38,929 --> 00:17:43,520
let's say you do it every minute you are

00:17:41,210 --> 00:17:46,610
testing your services like like a user

00:17:43,520 --> 00:17:49,940
would do right maybe you are testing

00:17:46,610 --> 00:17:53,240
them so hard that you are that your

00:17:49,940 --> 00:17:56,390
service are affected by the load you are

00:17:53,240 --> 00:17:58,700
putting on them and this reflects in a

00:17:56,390 --> 00:18:01,190
slowdown for your user so your service

00:17:58,700 --> 00:18:02,600
is actually slower than before

00:18:01,190 --> 00:18:04,970
just because you're putting more load on

00:18:02,600 --> 00:18:07,730
it but it's not real you solo this your

00:18:04,970 --> 00:18:09,110
your own into end test but as you are

00:18:07,730 --> 00:18:12,320
doing against production there's no

00:18:09,110 --> 00:18:15,350
other way and another other example so

00:18:12,320 --> 00:18:17,030
for example if you have a database for

00:18:15,350 --> 00:18:21,020
example let's say you have a dynamo DB

00:18:17,030 --> 00:18:23,480
which is a database in AWS and imagine

00:18:21,020 --> 00:18:27,410
you're making a lot of requests you have

00:18:23,480 --> 00:18:30,290
a capacity when you when you spin up a

00:18:27,410 --> 00:18:32,510
new a new database a new DynamoDB table

00:18:30,290 --> 00:18:36,070
you set a specific capacity to it

00:18:32,510 --> 00:18:38,750
because capacity is not infinite but

00:18:36,070 --> 00:18:40,850
then if you are testing with your

00:18:38,750 --> 00:18:43,180
end-to-end tests in real time in the

00:18:40,850 --> 00:18:46,430
production system you may reach those

00:18:43,180 --> 00:18:49,400
limits and then your dynamo DB your

00:18:46,430 --> 00:18:51,650
database might start throttling and that

00:18:49,400 --> 00:18:53,360
will affect the users and but they

00:18:51,650 --> 00:18:56,360
haven't done anything wrong it's just

00:18:53,360 --> 00:18:59,870
your end-to-end test fiddling with the

00:18:56,360 --> 00:19:02,570
production system right so one solution

00:18:59,870 --> 00:19:04,160
to it could be to space this and twin

00:19:02,570 --> 00:19:06,770
test so instead of running them every

00:19:04,160 --> 00:19:09,620
minion do you run them every 15 minutes

00:19:06,770 --> 00:19:11,420
or every 20 minutes and the more often

00:19:09,620 --> 00:19:14,660
you run them the faster you will notice

00:19:11,420 --> 00:19:19,070
an issue but it also if you run them a

00:19:14,660 --> 00:19:20,990
lot more often you get more noise and

00:19:19,070 --> 00:19:22,730
it's slowing down your production system

00:19:20,990 --> 00:19:27,440
so you need to strike a balance between

00:19:22,730 --> 00:19:30,200
how how many times an hour you want to

00:19:27,440 --> 00:19:33,760
run the end-to-end test so that you are

00:19:30,200 --> 00:19:38,390
know having done many side effects to it

00:19:33,760 --> 00:19:41,330
it is also true that by using this bit

00:19:38,390 --> 00:19:44,110
relies users it's also interact with

00:19:41,330 --> 00:19:48,080
your login service or with you whatever

00:19:44,110 --> 00:19:50,590
your login button is and you'll need

00:19:48,080 --> 00:19:53,720
tune you need to use the spiritual users

00:19:50,590 --> 00:19:55,550
with their own configuration so they

00:19:53,720 --> 00:19:57,560
need to have their own email their own

00:19:55,550 --> 00:20:01,310
history of actions their own

00:19:57,560 --> 00:20:05,540
configuration and this user should be

00:20:01,310 --> 00:20:08,930
set up as real users but with fake email

00:20:05,540 --> 00:20:12,320
accounts or fake configuration but issue

00:20:08,930 --> 00:20:14,550
as I said it should imitate the real

00:20:12,320 --> 00:20:17,790
user behavior and the real and

00:20:14,550 --> 00:20:19,980
music configuration now that's another

00:20:17,790 --> 00:20:23,820
problem when you're going to design to

00:20:19,980 --> 00:20:26,190
entering production as you're performing

00:20:23,820 --> 00:20:28,680
as a real user you are faking the system

00:20:26,190 --> 00:20:33,360
telling telling telling me that you are

00:20:28,680 --> 00:20:36,270
a real user you're you might be also you

00:20:33,360 --> 00:20:39,680
may also be eschewing your statistics

00:20:36,270 --> 00:20:42,300
your metrics so every request to an API

00:20:39,680 --> 00:20:45,270
it comes from the end-to-end test or it

00:20:42,300 --> 00:20:46,770
comes from a real user it will add a it

00:20:45,270 --> 00:20:49,380
will add a count to the number of

00:20:46,770 --> 00:20:52,830
requests and it will add latency to your

00:20:49,380 --> 00:20:55,470
registries and it will add everything to

00:20:52,830 --> 00:20:57,620
any metric any status to you you want to

00:20:55,470 --> 00:21:02,160
take out from your production systems

00:20:57,620 --> 00:21:05,160
any problem so as I said yeah all day

00:21:02,160 --> 00:21:07,490
all the metrics API you CH ever count

00:21:05,160 --> 00:21:10,500
etc and also the locks in production

00:21:07,490 --> 00:21:13,860
sometimes inspecting the locks is useful

00:21:10,500 --> 00:21:16,620
to to find out bugs and to find out what

00:21:13,860 --> 00:21:18,600
problems are some users having with your

00:21:16,620 --> 00:21:21,660
system but if you have this end-to-end

00:21:18,600 --> 00:21:23,400
test they add a lot of noise to the to

00:21:21,660 --> 00:21:24,780
the locks and you'll get mixed locks and

00:21:23,400 --> 00:21:28,710
it's going to be difficult to

00:21:24,780 --> 00:21:30,360
differentiate between what a real what

00:21:28,710 --> 00:21:32,160
the locks are for real users and what

00:21:30,360 --> 00:21:34,290
are the locks for you for your

00:21:32,160 --> 00:21:37,050
end-to-end test so it's it's getting

00:21:34,290 --> 00:21:38,580
complicated now right well there's some

00:21:37,050 --> 00:21:42,090
solutions to it if you're thinking in

00:21:38,580 --> 00:21:44,490
terms of where P is and in terms of HTTP

00:21:42,090 --> 00:21:47,120
requests you can create a correlation ID

00:21:44,490 --> 00:21:49,560
so you can put in the HTTP header a

00:21:47,120 --> 00:21:52,380
correlation ID header with a specific

00:21:49,560 --> 00:21:54,510
UID and then you can filter out those

00:21:52,380 --> 00:21:56,490
two IDs from your logs and from your

00:21:54,510 --> 00:21:58,980
metrics you can also change the user

00:21:56,490 --> 00:22:02,220
agent which is another HTTP header you

00:21:58,980 --> 00:22:04,800
can set to a specific string saying I

00:22:02,220 --> 00:22:07,620
don't know my testing app version 0 0 0

00:22:04,800 --> 00:22:12,780
so you can then filter them out or you

00:22:07,620 --> 00:22:14,640
can use custom HTTP headers what else

00:22:12,780 --> 00:22:16,140
well we have more problems or more

00:22:14,640 --> 00:22:18,090
things to take into account when you run

00:22:16,140 --> 00:22:22,230
into an test run in testing production

00:22:18,090 --> 00:22:25,010
is great right but or the faith that

00:22:22,230 --> 00:22:27,870
they generate what do we do with that

00:22:25,010 --> 00:22:28,320
well it's going to fill our database

00:22:27,870 --> 00:22:30,000
it's going

00:22:28,320 --> 00:22:35,220
fill our buckets is gonna fill our

00:22:30,000 --> 00:22:37,950
storage it's just stress right so we

00:22:35,220 --> 00:22:40,019
need to automatically clean as much

00:22:37,950 --> 00:22:42,720
testing items as possible after each

00:22:40,019 --> 00:22:44,429
test basically the main object objective

00:22:42,720 --> 00:22:47,190
is to leave the system as you found it

00:22:44,429 --> 00:22:48,539
so the end-to-end test of course they're

00:22:47,190 --> 00:22:50,940
going to affect production because you

00:22:48,539 --> 00:22:53,130
are running them against production but

00:22:50,940 --> 00:22:56,210
you should leave production as you found

00:22:53,130 --> 00:22:59,990
it and avoid cluttering it with a

00:22:56,210 --> 00:23:02,730
testing user with testing artifacts

00:22:59,990 --> 00:23:04,710
because in the in the long term as you

00:23:02,730 --> 00:23:06,960
run this end-to-end test more and more

00:23:04,710 --> 00:23:09,960
often your systems are going to be

00:23:06,960 --> 00:23:13,019
clogged up with all these fake users

00:23:09,960 --> 00:23:16,679
that you don't really care about so yeah

00:23:13,019 --> 00:23:19,409
cleaning up is very important it's also

00:23:16,679 --> 00:23:22,080
helps because if you clean after every

00:23:19,409 --> 00:23:25,409
test it's also helps to start the next

00:23:22,080 --> 00:23:28,259
test from a cleaner state avoiding false

00:23:25,409 --> 00:23:32,039
false negatives and avoiding clutter in

00:23:28,259 --> 00:23:34,590
your production databases it also when

00:23:32,039 --> 00:23:38,789
you clean it up boys exhausting all the

00:23:34,590 --> 00:23:40,799
limited resources like space making real

00:23:38,789 --> 00:23:46,049
data much more difficult to retrieve and

00:23:40,799 --> 00:23:48,120
search if you don't clean up now this

00:23:46,049 --> 00:23:50,009
concept about end-to-end tests and how

00:23:48,120 --> 00:23:51,840
to implement that is very interesting

00:23:50,009 --> 00:23:55,970
but you might have a lot of questions

00:23:51,840 --> 00:23:59,519
now and I'm gonna try to answer them in

00:23:55,970 --> 00:24:01,200
in this presentation and if still after

00:23:59,519 --> 00:24:03,629
the presentation you have more questions

00:24:01,200 --> 00:24:05,009
Jukka you can write them on the comment

00:24:03,629 --> 00:24:08,879
sections I don't know it's gonna be on

00:24:05,009 --> 00:24:10,909
my left or my right but yeah please type

00:24:08,879 --> 00:24:13,950
them there and I'll be watching

00:24:10,909 --> 00:24:16,679
so for the new questions you you might

00:24:13,950 --> 00:24:22,279
say can you end-to-end test pass and you

00:24:16,679 --> 00:24:22,279
still have problems yes you can

00:24:24,970 --> 00:24:29,409
you can still have problems but the

00:24:27,220 --> 00:24:31,090
thing is that the more the closer you

00:24:29,409 --> 00:24:33,250
make your end-to-end tests to a real

00:24:31,090 --> 00:24:35,860
user journey to a real user interaction

00:24:33,250 --> 00:24:38,380
the closer it gets to represent the

00:24:35,860 --> 00:24:43,510
state of your services and the state of

00:24:38,380 --> 00:24:45,909
of your cloud or your micro services all

00:24:43,510 --> 00:24:48,549
right so if you do exactly what users

00:24:45,909 --> 00:24:50,620
are doing then yes if an end-to-end test

00:24:48,549 --> 00:24:52,299
fail then you have problems if an

00:24:50,620 --> 00:24:54,130
end-to-end test passes

00:24:52,299 --> 00:24:56,980
you don't have problems because an

00:24:54,130 --> 00:24:59,230
end-to-end test is really like a user

00:24:56,980 --> 00:25:00,760
performing the actions so if the

00:24:59,230 --> 00:25:04,120
end-to-end test can perform the action

00:25:00,760 --> 00:25:06,039
probably the user can - right now

00:25:04,120 --> 00:25:08,919
there's another question by the nature

00:25:06,039 --> 00:25:11,200
and - entire span multiple services and

00:25:08,919 --> 00:25:13,419
teams who is responsible for writing

00:25:11,200 --> 00:25:16,590
them or how do teams collaborate to

00:25:13,419 --> 00:25:19,780
write them well here at Dyson we have a

00:25:16,590 --> 00:25:22,230
team responsible for the mainframe work

00:25:19,780 --> 00:25:24,850
on for defining the little steps that

00:25:22,230 --> 00:25:28,360
you saw earlier so for example user

00:25:24,850 --> 00:25:30,370
locks in that's a little step a small

00:25:28,360 --> 00:25:32,620
step a predefined step that everyone

00:25:30,370 --> 00:25:35,590
could use and to build up on top of that

00:25:32,620 --> 00:25:37,780
and so yeah this team responsible for

00:25:35,590 --> 00:25:40,059
the main framework and then each team

00:25:37,780 --> 00:25:41,890
will try to write the tests based on

00:25:40,059 --> 00:25:44,289
those single actions so the single

00:25:41,890 --> 00:25:45,760
action remember you put a lot of single

00:25:44,289 --> 00:25:49,000
actions together and get our next

00:25:45,760 --> 00:25:51,610
scenario and a scenario so that's how

00:25:49,000 --> 00:25:53,919
how we collaborate within Dyson in terms

00:25:51,610 --> 00:25:56,080
of end to end test but all the teams are

00:25:53,919 --> 00:25:59,230
responsible for maintaining dos because

00:25:56,080 --> 00:26:01,390
this is how they tie some cloud that

00:25:59,230 --> 00:26:03,970
this is how they compendium of all of

00:26:01,390 --> 00:26:06,159
our services is behaving against the

00:26:03,970 --> 00:26:09,429
user so all teams should be concerned

00:26:06,159 --> 00:26:11,350
about it another question you might have

00:26:09,429 --> 00:26:13,960
is how do end-to-end test compared to

00:26:11,350 --> 00:26:17,590
Darko can i deployment do you need both

00:26:13,960 --> 00:26:21,429
and well obviously there are constant

00:26:17,590 --> 00:26:23,409
process for each of them definitely do

00:26:21,429 --> 00:26:26,799
you you should be using a can or a

00:26:23,409 --> 00:26:29,950
deployments but you could also run the

00:26:26,799 --> 00:26:32,440
end-to-end test to make sure your

00:26:29,950 --> 00:26:34,990
services is your services are ready to

00:26:32,440 --> 00:26:36,580
to be deployed to production so for

00:26:34,990 --> 00:26:38,860
example you can run this end-to-end test

00:26:36,580 --> 00:26:41,170
even though they are designed to be

00:26:38,860 --> 00:26:43,900
in production systems you can run them

00:26:41,170 --> 00:26:46,929
in your staging environment or in your

00:26:43,900 --> 00:26:49,120
development environment to verify to

00:26:46,929 --> 00:26:50,770
assert that the new version of your

00:26:49,120 --> 00:26:52,660
service it's not breaking any user

00:26:50,770 --> 00:26:53,320
journey so that when you deploy to

00:26:52,660 --> 00:26:54,880
production

00:26:53,320 --> 00:26:56,950
you're still gonna run the intro in

00:26:54,880 --> 00:26:59,260
testing production but you are certain

00:26:56,950 --> 00:27:02,340
that the user journeys are still there

00:26:59,260 --> 00:27:06,220
and still working so do you need both

00:27:02,340 --> 00:27:09,970
yes and how to boil it into an tests

00:27:06,220 --> 00:27:14,370
become becoming fragile so to have this

00:27:09,970 --> 00:27:16,630
flicker in states where one in 20s is

00:27:14,370 --> 00:27:19,270
successful but the next one is failing

00:27:16,630 --> 00:27:21,850
just because the previous one has made

00:27:19,270 --> 00:27:25,210
an action and it's made the system

00:27:21,850 --> 00:27:28,510
inconsistent or whatever basically by

00:27:25,210 --> 00:27:30,790
cleaning after I clean after you and by

00:27:28,510 --> 00:27:33,160
cleaning after the test you'll avoid

00:27:30,790 --> 00:27:40,510
them getting fragile and getting all

00:27:33,160 --> 00:27:43,929
those force negatives and yeah as a

00:27:40,510 --> 00:27:47,110
recap for the whole presentation testing

00:27:43,929 --> 00:27:50,190
in production is good and necessary I've

00:27:47,110 --> 00:27:53,710
explained an example of testing

00:27:50,190 --> 00:27:56,230
microservices AP is with HTTP calls but

00:27:53,710 --> 00:27:57,850
you can apply this a whole concept of

00:27:56,230 --> 00:28:00,700
testing in production using end-to-end

00:27:57,850 --> 00:28:03,309
tests to any kind of interface for

00:28:00,700 --> 00:28:05,380
example you could do end-to-end test UI

00:28:03,309 --> 00:28:08,919
end to end test using the browser using

00:28:05,380 --> 00:28:11,410
selenium using puppeteer or any other

00:28:08,919 --> 00:28:14,650
kind of headless browser as long as you

00:28:11,410 --> 00:28:17,049
test what a real user is gonna do and to

00:28:14,650 --> 00:28:18,610
end its a user journey you don't need to

00:28:17,049 --> 00:28:20,500
click on all the buttons for example in

00:28:18,610 --> 00:28:22,390
the UI did not need to clock to click on

00:28:20,500 --> 00:28:25,000
every single link or every single button

00:28:22,390 --> 00:28:28,540
you need to represent you need to your

00:28:25,000 --> 00:28:31,120
test is a it's a model for what the real

00:28:28,540 --> 00:28:33,460
user will do if that test passes then

00:28:31,120 --> 00:28:37,000
the user should be able to perform the

00:28:33,460 --> 00:28:40,090
action too you need to think as a user

00:28:37,000 --> 00:28:41,590
and act as an user this is the same that

00:28:40,090 --> 00:28:43,960
I described before

00:28:41,590 --> 00:28:46,600
koo kumba das is a good start if you

00:28:43,960 --> 00:28:51,130
want to start writing this end-to-end

00:28:46,600 --> 00:28:53,020
test in using the no des platform you

00:28:51,130 --> 00:28:55,960
also need to think about your system

00:28:53,020 --> 00:28:57,790
city not to overload your system running

00:28:55,960 --> 00:29:00,520
into antis every minute if they're if

00:28:57,790 --> 00:29:03,760
your system is not capable to cope with

00:29:00,520 --> 00:29:05,980
that load also you need to mark your

00:29:03,760 --> 00:29:07,840
test intents to differentiate them from

00:29:05,980 --> 00:29:10,030
real user interactions using the

00:29:07,840 --> 00:29:13,240
correlation IDs or using custom HTTP

00:29:10,030 --> 00:29:17,470
headers basically so you can filter them

00:29:13,240 --> 00:29:19,420
out also clear your test date and reset

00:29:17,470 --> 00:29:23,080
all the connection and status after each

00:29:19,420 --> 00:29:25,960
test or clean after yourself that's

00:29:23,080 --> 00:29:28,120
that's basically it if you have any more

00:29:25,960 --> 00:29:30,880
questions as I cannot answer them right

00:29:28,120 --> 00:29:33,100
now live but you can use the comment

00:29:30,880 --> 00:29:35,080
section and I'll be there answering all

00:29:33,100 --> 00:29:37,270
or your question please follow me on

00:29:35,080 --> 00:29:40,000
Twitter and like and subscribe that's

00:29:37,270 --> 00:29:44,250
all folks and you are you brave enough

00:29:40,000 --> 00:29:44,250
to die some production thank you

00:29:47,380 --> 00:29:58,130
[Music]

00:29:58,290 --> 00:30:03,869
you

00:29:59,320 --> 00:30:03,869

YouTube URL: https://www.youtube.com/watch?v=P-clFhViJXw


