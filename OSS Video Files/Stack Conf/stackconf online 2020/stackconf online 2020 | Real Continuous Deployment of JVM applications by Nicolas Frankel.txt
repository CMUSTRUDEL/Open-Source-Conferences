Title: stackconf online 2020 | Real Continuous Deployment of JVM applications by Nicolas Frankel
Publication date: 2020-06-27
Playlist: stackconf online 2020
Description: 
	A couple of years ago, continuous integration in the JVM ecosystem meant Jenkins. Since that time, a lot of other tools have been made available. But new tools don’t mean new features, just new ways. Beside that, what about continuous deployment? There’s no tool that allows to deploy new versions of a JVM-based application without downtime. The only way to achieve zero downtime is to have multiple nodes deployed on a platform, and let that platform achieve that _e.g._ Kubernetes.

And yet, achieving true continuous deployment of bytecode on one single JVM instance is possible if one changes one’s way of looking at things. What if compilation could be seen as changes? What if those changes could be stored in a data store, and a listener on this data store could stream those changes to the running production JVM via the Attach API?

In that talk, I’ll demo exactly that using Hazelcast and Hazelcast Jet – but it’s possible to re-use the principles that will be shown using other streaming technologies.


NETWAYS
Konferenzen: https://www.netways.de/events
Schulungen: https://www.netways.de/schulungen
Shop: https://shop.netways.de/
Blog: http://blog.netways.de/
NWS: https://nws.netways.de 

Webinare
Archiv Link: https://www.netways.de/webinare/archi...
Aktuell: https://www.netways.de/wb

Social Media
SlideShare: http://de.slideshare.net/netways
YouTube: https://www.netways.de/youtube
Facebook: https://www.facebook.com/netways
Twitter: https://twitter.com/netways
Instagram: https://www.instagram.com/netwaysgmbh/

Music: Walking on Air - https://www.frametraxx.de/
Captions: 
	00:00:00,450 --> 00:00:14,869
[Music]

00:00:11,559 --> 00:00:17,300
hi everybody thanks to be here with me

00:00:14,869 --> 00:00:20,800
for this talk about an experiment in

00:00:17,300 --> 00:00:24,890
continuous deployment of JVM application

00:00:20,800 --> 00:00:30,050
I'm Nicola Franco I've been working as a

00:00:24,890 --> 00:00:32,629
consultant this developer team lead in

00:00:30,050 --> 00:00:38,120
different technical roles in projects

00:00:32,629 --> 00:00:42,739
and because I had enough of projects and

00:00:38,120 --> 00:00:45,440
deadlines and let's say not super

00:00:42,739 --> 00:00:48,290
achievable goals two years ago only

00:00:45,440 --> 00:00:51,350
three years ago I decided to be a

00:00:48,290 --> 00:00:54,620
developer advocate the good thing with

00:00:51,350 --> 00:00:57,739
this role is it allows me to have those

00:00:54,620 --> 00:01:01,850
crazy ideas and to try to implement them

00:00:57,739 --> 00:01:03,860
which is the role of this talk I work

00:01:01,850 --> 00:01:06,320
for a company called hazel cost and

00:01:03,860 --> 00:01:10,280
hazel casts we have two different

00:01:06,320 --> 00:01:14,409
products the first one is MDG in-memory

00:01:10,280 --> 00:01:17,030
data grids you can think about it like

00:01:14,409 --> 00:01:22,219
distributed data structures so you have

00:01:17,030 --> 00:01:25,850
the niceness of your hash map or queue

00:01:22,219 --> 00:01:28,700
or whatever under the same or very close

00:01:25,850 --> 00:01:30,889
to the same API and then your data

00:01:28,700 --> 00:01:35,240
structure is distributed along several

00:01:30,889 --> 00:01:38,240
nodes the other project that we have is

00:01:35,240 --> 00:01:41,719
called hezekiah yet and I will use it in

00:01:38,240 --> 00:01:46,009
this talk so let's not go too much into

00:01:41,719 --> 00:01:47,929
detail so continuous integration we have

00:01:46,009 --> 00:01:52,099
been doing continuous integration for a

00:01:47,929 --> 00:01:56,240
long time I mean the idea of continuous

00:01:52,099 --> 00:01:59,539
integration of bringing all work from

00:01:56,240 --> 00:02:01,219
all developers in the single points and

00:01:59,539 --> 00:02:05,299
to check that everything works together

00:02:01,219 --> 00:02:07,549
has been like nearly there since I

00:02:05,299 --> 00:02:10,880
started working as I mentioned like

00:02:07,549 --> 00:02:14,060
nearly 20 years ago and so we want to

00:02:10,880 --> 00:02:17,270
make sure that everything compiles

00:02:14,060 --> 00:02:21,050
together that everything can be unit

00:02:17,270 --> 00:02:22,640
tested together and up until the storing

00:02:21,050 --> 00:02:25,700
in the registry

00:02:22,640 --> 00:02:28,760
in general I hope that every one of you

00:02:25,700 --> 00:02:32,600
has this continuous integration pipeline

00:02:28,760 --> 00:02:36,610
in place that when you start compiling

00:02:32,600 --> 00:02:39,830
then you commit then everything is

00:02:36,610 --> 00:02:42,650
handled in this pipeline and of course

00:02:39,830 --> 00:02:45,860
the the contents the steps in the

00:02:42,650 --> 00:02:48,080
pipelines might be specific but the fact

00:02:45,860 --> 00:02:49,910
that you want to compile that you wants

00:02:48,080 --> 00:02:54,140
to unit test that we want to package

00:02:49,910 --> 00:02:59,570
that you want well this is in general

00:02:54,140 --> 00:03:01,670
what we are doing but continues stuff

00:02:59,570 --> 00:03:03,650
doesn't stop there as I mentioned

00:03:01,670 --> 00:03:07,340
continuous integration should be the

00:03:03,650 --> 00:03:09,290
norm again the exact steps might depend

00:03:07,340 --> 00:03:11,390
on your context but continuous

00:03:09,290 --> 00:03:14,270
integration in general should be the

00:03:11,390 --> 00:03:15,680
norm whereas we can go a bit further and

00:03:14,270 --> 00:03:20,330
this bit actually

00:03:15,680 --> 00:03:22,280
is very very very far away like you you

00:03:20,330 --> 00:03:26,570
have continuous delivery which means

00:03:22,280 --> 00:03:29,209
that you will be doing the same but you

00:03:26,570 --> 00:03:31,610
take the package that you have just

00:03:29,209 --> 00:03:34,400
created and you you deploy it to

00:03:31,610 --> 00:03:39,080
production and it sits there just

00:03:34,400 --> 00:03:41,330
waiting the release by in general a

00:03:39,080 --> 00:03:45,380
business owner that gives a go and I say

00:03:41,330 --> 00:03:48,190
yes let's deploy it for real and then

00:03:45,380 --> 00:03:52,820
you have these continuous deployment

00:03:48,190 --> 00:03:57,620
which means that there is no decision at

00:03:52,820 --> 00:03:59,660
all that the Komets of the push of a

00:03:57,620 --> 00:04:03,019
developer like triggers the whole

00:03:59,660 --> 00:04:06,590
pipeline and in the end the code is

00:04:03,019 --> 00:04:10,580
deployed into production and to be

00:04:06,590 --> 00:04:16,580
honest I've not seen it in my career

00:04:10,580 --> 00:04:19,700
only big companies do it because there

00:04:16,580 --> 00:04:23,090
is one big problem with that is you

00:04:19,700 --> 00:04:26,000
shouldn't have any downtime and the

00:04:23,090 --> 00:04:28,610
problem of the Chilam is that the

00:04:26,000 --> 00:04:30,919
traditional deployment of JVM

00:04:28,610 --> 00:04:35,570
application whether you are using a core

00:04:30,919 --> 00:04:36,439
a war is to stop the JVM then you deploy

00:04:35,570 --> 00:04:39,379
your application

00:04:36,439 --> 00:04:42,559
which means like overrides the old

00:04:39,379 --> 00:04:47,479
package and then you start the gvm again

00:04:42,559 --> 00:04:49,699
and again this is true for like

00:04:47,479 --> 00:04:52,339
application servers you bring down the

00:04:49,699 --> 00:04:54,439
application server you deploy your new

00:04:52,339 --> 00:04:58,489
application and you start it up again or

00:04:54,439 --> 00:05:02,989
for this new model of self executable

00:04:58,489 --> 00:05:05,959
jars it doesn't change I think and the

00:05:02,989 --> 00:05:09,289
problem with downtime is that in general

00:05:05,959 --> 00:05:10,909
if you have internal users they can be

00:05:09,289 --> 00:05:15,039
warned about it they don't like it so

00:05:10,909 --> 00:05:18,800
much but it's acceptable as soon as you

00:05:15,039 --> 00:05:20,929
face customers then it's not really

00:05:18,800 --> 00:05:23,959
acceptable right for example if you have

00:05:20,929 --> 00:05:25,879
Facebook or Gmail or whatever they don't

00:05:23,959 --> 00:05:28,300
have the concept of downtime so people

00:05:25,879 --> 00:05:31,159
are getting used with is no downtime

00:05:28,300 --> 00:05:33,889
model and they don't understand when you

00:05:31,159 --> 00:05:37,249
have this static page thing a please

00:05:33,889 --> 00:05:38,209
wait a bit we are coming back in a few

00:05:37,249 --> 00:05:40,490
in a few minutes

00:05:38,209 --> 00:05:44,179
especially if you in some in some

00:05:40,490 --> 00:05:45,979
domains such as e-commerce like every

00:05:44,179 --> 00:05:48,349
second of the hunt time is second way

00:05:45,979 --> 00:05:52,429
you don't sell and where customers will

00:05:48,349 --> 00:05:55,999
go to your competitors so going down it

00:05:52,429 --> 00:05:59,199
is not really feasible and of course in

00:05:55,999 --> 00:06:02,539
order to cope with that we have some

00:05:59,199 --> 00:06:03,679
existing pattern already for example you

00:06:02,539 --> 00:06:07,759
might know about these Bluegreen

00:06:03,679 --> 00:06:11,179
deployments so you have two two contexts

00:06:07,759 --> 00:06:14,179
two environments they are completely my

00:06:11,179 --> 00:06:16,369
words one of them is the production the

00:06:14,179 --> 00:06:19,789
other is a production so for example in

00:06:16,369 --> 00:06:21,769
the image here the green is the

00:06:19,789 --> 00:06:24,679
production and the blue is a production

00:06:21,769 --> 00:06:26,809
so you set everything up in the blue

00:06:24,679 --> 00:06:28,729
environments you deploy your new

00:06:26,809 --> 00:06:31,759
application and when you are ready you

00:06:28,729 --> 00:06:33,079
switch the role of the rutter from the

00:06:31,759 --> 00:06:34,999
green environment to the blue

00:06:33,079 --> 00:06:36,079
environment and of course everything is

00:06:34,999 --> 00:06:38,389
fine

00:06:36,079 --> 00:06:40,759
well of course everything is not fine it

00:06:38,389 --> 00:06:44,029
is not easy as it appears like they are

00:06:40,759 --> 00:06:45,949
a couple of issues like if you have two

00:06:44,029 --> 00:06:48,439
databases how do you copy

00:06:45,949 --> 00:06:49,689
instantly copied the data that is

00:06:48,439 --> 00:06:52,029
written on the green

00:06:49,689 --> 00:06:55,209
- the blue environment but until the

00:06:52,029 --> 00:06:57,039
last second of course you can say oh but

00:06:55,209 --> 00:06:59,679
I will have a single database but then

00:06:57,039 --> 00:07:03,099
if you have schema changes might be a

00:06:59,679 --> 00:07:06,989
bit harder to cope with there are ways

00:07:03,099 --> 00:07:10,629
but there are they are not super fun

00:07:06,989 --> 00:07:13,029
coupon it is rolling update of course if

00:07:10,629 --> 00:07:15,669
you use the kubernetes platform then you

00:07:13,029 --> 00:07:18,729
can say oh then it's easy I will just

00:07:15,669 --> 00:07:21,699
like do like rolling a blade of all my

00:07:18,729 --> 00:07:24,729
nodes and in the end I will have the

00:07:21,699 --> 00:07:26,979
right application again it's it's not

00:07:24,729 --> 00:07:29,589
the problem of the compute node the

00:07:26,979 --> 00:07:35,289
problem lies in the state database and

00:07:29,589 --> 00:07:37,989
how do you handle database changes and

00:07:35,289 --> 00:07:40,539
then we can say oh but let's keep

00:07:37,989 --> 00:07:44,319
everything Aditi's and just try to

00:07:40,539 --> 00:07:46,809
change the pinecone inside the gvm and

00:07:44,319 --> 00:07:49,389
and without any downtime how can how can

00:07:46,809 --> 00:07:52,239
we do it it sounds a bit like magic and

00:07:49,389 --> 00:07:54,899
probably it is if you don't know about

00:07:52,239 --> 00:07:57,639
those tools but actually it's possible

00:07:54,899 --> 00:08:00,689
so first let me tell you about something

00:07:57,639 --> 00:08:04,509
called the attach API and the attach API

00:08:00,689 --> 00:08:09,459
is like very easy concept it allows you

00:08:04,509 --> 00:08:12,099
to load an agent from a running GM from

00:08:09,459 --> 00:08:17,079
another GM so you have this like

00:08:12,099 --> 00:08:21,610
production JVM and you run a huge event

00:08:17,079 --> 00:08:24,249
that will like attach you code into the

00:08:21,610 --> 00:08:28,059
running one and and the good side of it

00:08:24,249 --> 00:08:31,959
is it doesn't need to run the production

00:08:28,059 --> 00:08:33,939
GM doesn't need to run in debug mode you

00:08:31,959 --> 00:08:36,399
have only two requirements that they

00:08:33,939 --> 00:08:39,819
need to run on to the same system

00:08:36,399 --> 00:08:44,589
whether it's a virtual machine or a real

00:08:39,819 --> 00:08:48,069
operating system and the the attaching

00:08:44,589 --> 00:08:51,459
given must know the PID of the running

00:08:48,069 --> 00:08:54,639
JVM so those are only the two

00:08:51,459 --> 00:08:59,439
requirements and the model is quite easy

00:08:54,639 --> 00:09:02,649
you have this virtual machine here which

00:08:59,439 --> 00:09:07,959
has a static method you say a attach to

00:09:02,649 --> 00:09:10,779
his PID and it will create a new virtual

00:09:07,959 --> 00:09:13,689
machine and then you can load an agent

00:09:10,779 --> 00:09:15,850
so you must know the pass to the agent

00:09:13,689 --> 00:09:19,269
chore and we will see just afterwards

00:09:15,850 --> 00:09:21,369
what I mean by agent you can test in

00:09:19,269 --> 00:09:23,769
some strength and it's done so in two

00:09:21,369 --> 00:09:25,689
lines of code you can achieve that again

00:09:23,769 --> 00:09:31,179
with those two requirements run on the

00:09:25,689 --> 00:09:35,139
same system and knowing the PID and so

00:09:31,179 --> 00:09:37,779
Java agents first one must understand

00:09:35,139 --> 00:09:40,300
that Java agents are not like wild

00:09:37,779 --> 00:09:43,569
beasts you might have heard like the

00:09:40,300 --> 00:09:46,769
term before it is just specific draw an

00:09:43,569 --> 00:09:50,319
agent is judge or we've dedicated

00:09:46,769 --> 00:09:53,050
metadata and in this metadata in is in

00:09:50,319 --> 00:09:56,649
the manifest dot M F and this is bought

00:09:53,050 --> 00:09:59,559
another API or called the estimation API

00:09:56,649 --> 00:10:01,720
and the instrumentation API allows to

00:09:59,559 --> 00:10:05,519
change the bytecode of running

00:10:01,720 --> 00:10:09,100
application and if you if you have used

00:10:05,519 --> 00:10:11,170
monitoring tools of java application in

00:10:09,100 --> 00:10:18,009
the past that's exactly what you are

00:10:11,170 --> 00:10:20,620
doing you are using the common line to

00:10:18,009 --> 00:10:24,959
point to the path of an agent on the

00:10:20,620 --> 00:10:28,420
same system and and using the java agent

00:10:24,959 --> 00:10:32,290
option on the command line but this is

00:10:28,420 --> 00:10:33,910
only one way to actually use an agent as

00:10:32,290 --> 00:10:36,579
i mentioned there are two ways there are

00:10:33,910 --> 00:10:40,389
the static one and the dynamic one and

00:10:36,579 --> 00:10:45,309
the dynamic one is by using the attach

00:10:40,389 --> 00:10:50,049
API that i've just mentioned and to

00:10:45,309 --> 00:10:52,509
create an agent it's very easy depending

00:10:50,049 --> 00:10:54,790
on whether it's static or dynamic but

00:10:52,509 --> 00:10:57,970
basically they are my world on the

00:10:54,790 --> 00:11:00,490
static and the static side of saying you

00:10:57,970 --> 00:11:02,740
have this pre main method so in a new

00:11:00,490 --> 00:11:05,769
normal executable drawer you have this

00:11:02,740 --> 00:11:09,129
main method which takes which must be

00:11:05,769 --> 00:11:13,480
public static void must be called men

00:11:09,129 --> 00:11:16,240
and accepts an array of strength and

00:11:13,480 --> 00:11:19,240
here it's the same it's

00:11:16,240 --> 00:11:22,990
it's premium method and it takes an

00:11:19,240 --> 00:11:27,300
array of strings as well and also an

00:11:22,990 --> 00:11:29,560
additional interface that will be

00:11:27,300 --> 00:11:31,899
provided by the JVM called

00:11:29,560 --> 00:11:34,450
instrumentation I will talk about it in

00:11:31,899 --> 00:11:38,860
just a few moment and on the dynamic

00:11:34,450 --> 00:11:42,120
side of thing the signature is the same

00:11:38,860 --> 00:11:45,910
just is agent main instead of remain and

00:11:42,120 --> 00:11:47,770
just as in a self executable drawer you

00:11:45,910 --> 00:11:50,649
have these men clause in your manifest

00:11:47,770 --> 00:11:53,290
dot M F on a static agent you must have

00:11:50,649 --> 00:11:55,510
premium cloth and then dynamic agent you

00:11:53,290 --> 00:12:00,100
must have an agent clause and of course

00:11:55,510 --> 00:12:03,370
if you both have the the methods and

00:12:00,100 --> 00:12:06,580
both metadata into the same drawer then

00:12:03,370 --> 00:12:09,100
you can have an agent that can be used

00:12:06,580 --> 00:12:12,220
as a static agent and also as a dynamic

00:12:09,100 --> 00:12:16,260
agent so both are possible a jar can be

00:12:12,220 --> 00:12:19,930
both static agent and a dynamic agent

00:12:16,260 --> 00:12:22,870
and with instrumentation you can do very

00:12:19,930 --> 00:12:25,000
interesting stuff the thing that we will

00:12:22,870 --> 00:12:27,910
do here is of course we will change the

00:12:25,000 --> 00:12:31,089
existing implementation of the class of

00:12:27,910 --> 00:12:34,860
course there are limitations that you

00:12:31,089 --> 00:12:37,720
cannot overcome but you can do a lot or

00:12:34,860 --> 00:12:40,000
otherwise you can apply automatic

00:12:37,720 --> 00:12:42,910
transformation of bytecode so when when

00:12:40,000 --> 00:12:45,520
the class is loading into the JVM then

00:12:42,910 --> 00:12:47,170
you can do something like automatic and

00:12:45,520 --> 00:12:51,850
always the same choose as adding

00:12:47,170 --> 00:12:54,850
attributes or whatever the model of the

00:12:51,850 --> 00:12:58,270
instrumentation API is also quite easy

00:12:54,850 --> 00:13:00,430
you have these interfaces are called

00:12:58,270 --> 00:13:03,399
instrumentation as I mentioned is passed

00:13:00,430 --> 00:13:05,920
to you by the Chilam in the pre main or

00:13:03,399 --> 00:13:08,589
agent main class and as I mentioned you

00:13:05,920 --> 00:13:11,529
can add an automatic transformer here

00:13:08,589 --> 00:13:14,470
and you can see that if you are using

00:13:11,529 --> 00:13:17,079
the new Java module system it's also

00:13:14,470 --> 00:13:20,140
module friendly so you can do it even

00:13:17,079 --> 00:13:23,290
when you are doing modules if your

00:13:20,140 --> 00:13:27,190
application is like module compatible

00:13:23,290 --> 00:13:29,850
and here we will use in our use case

00:13:27,190 --> 00:13:33,730
these really fine classes

00:13:29,850 --> 00:13:35,710
method and basically what you are doing

00:13:33,730 --> 00:13:39,580
you are passing this class definition

00:13:35,710 --> 00:13:43,440
and class definition is just a class

00:13:39,580 --> 00:13:46,510
itself with the bytes of the class files

00:13:43,440 --> 00:13:50,080
so to create a class definition you just

00:13:46,510 --> 00:13:53,440
have an already existing class and the

00:13:50,080 --> 00:13:55,870
bytecode of the new implementation that

00:13:53,440 --> 00:13:58,060
you want to have and then you create

00:13:55,870 --> 00:14:00,670
this cause definition you call redefine

00:13:58,060 --> 00:14:05,010
classes and presto you will add this new

00:14:00,670 --> 00:14:09,400
running byte code inside your JVM now

00:14:05,010 --> 00:14:12,010
there is one final question is we know

00:14:09,400 --> 00:14:15,340
how when you have a running given to

00:14:12,010 --> 00:14:19,540
attach itself to it and to have these

00:14:15,340 --> 00:14:21,850
new codes but how do you move the byte

00:14:19,540 --> 00:14:23,850
code this new code how do we move it

00:14:21,850 --> 00:14:26,380
around

00:14:23,850 --> 00:14:29,740
there are basically two options the

00:14:26,380 --> 00:14:33,730
first one is bachik so every now and

00:14:29,740 --> 00:14:35,530
then we will call the batch and say oh

00:14:33,730 --> 00:14:38,080
we will take the new byte code and move

00:14:35,530 --> 00:14:40,390
it around or we have this streaming

00:14:38,080 --> 00:14:43,450
model which seems much much better

00:14:40,390 --> 00:14:45,940
because it means that if nothing happens

00:14:43,450 --> 00:14:49,060
like if there is no new code

00:14:45,940 --> 00:14:51,610
then we won't deliver it is this the

00:14:49,060 --> 00:14:53,590
existing code and as soon as you have

00:14:51,610 --> 00:14:55,570
new code then it will be moved around so

00:14:53,590 --> 00:14:59,410
I believe the streaming model is much

00:14:55,570 --> 00:15:03,040
better adapted we will use an in-memory

00:14:59,410 --> 00:15:06,550
stream engine and you might know about

00:15:03,040 --> 00:15:10,480
some of them so in the cloud like every

00:15:06,550 --> 00:15:13,720
cloud provider proposes one so you have

00:15:10,480 --> 00:15:15,970
Amazon kinases IBM streams Google

00:15:13,720 --> 00:15:18,610
pub/sub this kind of stuff you can also

00:15:15,970 --> 00:15:23,200
have a processing engine on creamy so

00:15:18,610 --> 00:15:27,420
just as fling or jets a special mention

00:15:23,200 --> 00:15:27,420
to beam because it tries to abstract

00:15:27,870 --> 00:15:31,810
implementation-dependent

00:15:29,620 --> 00:15:33,880
processing engine of course it's a leaky

00:15:31,810 --> 00:15:36,250
abstraction because there is no standard

00:15:33,880 --> 00:15:39,640
in this domain so it's it's an

00:15:36,250 --> 00:15:41,209
afterthought that they try to take the

00:15:39,640 --> 00:15:44,149
common part of all

00:15:41,209 --> 00:15:48,740
and try to make an abstraction on top of

00:15:44,149 --> 00:15:53,059
them it's it's a good effort I think but

00:15:48,740 --> 00:15:56,179
it's very leaky anyway let's talk about

00:15:53,059 --> 00:16:00,050
jets so it's an Apache to open-source

00:15:56,179 --> 00:16:02,300
license jar you can use it as a library

00:16:00,050 --> 00:16:04,670
so embedding in your application you can

00:16:02,300 --> 00:16:07,639
also use it in a client-server mode so

00:16:04,670 --> 00:16:10,910
you will just like launched your and

00:16:07,639 --> 00:16:13,670
your application will be the client the

00:16:10,910 --> 00:16:16,399
good thing about jet is basically the

00:16:13,670 --> 00:16:19,699
batch and streaming API are only fight

00:16:16,399 --> 00:16:22,490
so you can use jet as batching so with a

00:16:19,699 --> 00:16:25,240
definite start and end when all items

00:16:22,490 --> 00:16:29,720
have been processed or as trimming so

00:16:25,240 --> 00:16:33,470
until you get while you get items you

00:16:29,720 --> 00:16:36,559
will deliver them and the change to go

00:16:33,470 --> 00:16:38,990
from one batching to streaming is just

00:16:36,559 --> 00:16:41,449
adding a timestamp it's very very easy

00:16:38,990 --> 00:16:45,290
to move from one to the other so if you

00:16:41,449 --> 00:16:47,209
have more familiar with batching then

00:16:45,290 --> 00:16:50,029
you can start with batching and then

00:16:47,209 --> 00:16:52,730
when you get more used to streaming you

00:16:50,029 --> 00:16:59,179
can change your model to streaming in

00:16:52,730 --> 00:17:02,869
one line of code this is the possible

00:16:59,179 --> 00:17:06,470
infrastructure of jet on the left you

00:17:02,869 --> 00:17:09,649
can see there are like the inputs or the

00:17:06,470 --> 00:17:12,500
sources and this is what jet can read

00:17:09,649 --> 00:17:16,669
from by default or by some extensions

00:17:12,500 --> 00:17:18,980
and if you don't have here what you want

00:17:16,669 --> 00:17:21,829
to read for example I don't know a

00:17:18,980 --> 00:17:23,360
dedicated file because the file

00:17:21,829 --> 00:17:26,360
WorkFirst doesn't suit you need and

00:17:23,360 --> 00:17:29,360
there is an API so that you can create

00:17:26,360 --> 00:17:32,419
your own on the opposite here you have

00:17:29,360 --> 00:17:36,110
the targets the things where you can put

00:17:32,419 --> 00:17:40,279
your data the output and in the middle

00:17:36,110 --> 00:17:43,029
you can have as I mentioned jet so here

00:17:40,279 --> 00:17:46,159
you can of course like combine different

00:17:43,029 --> 00:17:47,990
streams of data and you can do like

00:17:46,159 --> 00:17:52,789
distributed computing and then of course

00:17:47,990 --> 00:17:54,830
if you know about an Java 8 transforms

00:17:52,789 --> 00:17:58,070
you can do exactly the same you can

00:17:54,830 --> 00:18:01,279
magic and filter this kind of of stuff

00:17:58,070 --> 00:18:03,919
the good thing about jet is that it's

00:18:01,279 --> 00:18:07,070
very well integrated with MDG so

00:18:03,919 --> 00:18:10,490
basically if you have like you want to

00:18:07,070 --> 00:18:12,860
enrich a string with some data that sits

00:18:10,490 --> 00:18:15,409
in a MDG then it's made for that and

00:18:12,860 --> 00:18:20,240
since everything is in memory it's very

00:18:15,409 --> 00:18:23,179
very fast so back to our application now

00:18:20,240 --> 00:18:25,340
we have all the pieces we have the

00:18:23,179 --> 00:18:28,279
attach API we have the instrumentation

00:18:25,340 --> 00:18:29,990
API and we have the streaming API so

00:18:28,279 --> 00:18:34,220
let's bring everything together

00:18:29,990 --> 00:18:36,529
I will have my like streaming well let's

00:18:34,220 --> 00:18:40,700
talk about first the product and even it

00:18:36,529 --> 00:18:44,210
runs the app and this is self-contained

00:18:40,700 --> 00:18:47,690
and it will just need to allow the

00:18:44,210 --> 00:18:50,210
attached API by default if you have no

00:18:47,690 --> 00:18:52,940
security manager the attached API is

00:18:50,210 --> 00:18:55,730
open which can be an issue so just think

00:18:52,940 --> 00:18:58,429
about it it might also be a security

00:18:55,730 --> 00:19:03,279
issue but here for this talk this is

00:18:58,429 --> 00:19:06,860
very good and then we will have this

00:19:03,279 --> 00:19:12,110
injection gvm that will run that will

00:19:06,860 --> 00:19:16,909
basically load the jar of the jet job

00:19:12,110 --> 00:19:19,789
and actually like inject it into the app

00:19:16,909 --> 00:19:23,269
and basically what it will be doing it

00:19:19,789 --> 00:19:28,820
that the app now will be listening to

00:19:23,269 --> 00:19:30,500
the as the cost a MDG changes and so on

00:19:28,820 --> 00:19:33,169
the other side we will have this

00:19:30,500 --> 00:19:35,630
streaming JVM which can be on a

00:19:33,169 --> 00:19:38,690
completely different machine that will

00:19:35,630 --> 00:19:43,090
read the file system of the developer of

00:19:38,690 --> 00:19:46,010
the CI or whatever I mean it can read

00:19:43,090 --> 00:19:48,919
changes from a folder and reads new

00:19:46,010 --> 00:19:52,070
classes and which will deliver them to

00:19:48,919 --> 00:19:55,450
I'm hazel cost MDG so every time there

00:19:52,070 --> 00:19:58,309
is a change this app now which have

00:19:55,450 --> 00:20:00,590
enhanced capabilities will listen to the

00:19:58,309 --> 00:20:04,970
change and will really redefine the

00:20:00,590 --> 00:20:07,490
classes inside and from a like dynamic

00:20:04,970 --> 00:20:07,970
point of view from a flow point of view

00:20:07,490 --> 00:20:10,910
for

00:20:07,970 --> 00:20:14,060
we'll stop the jet job so it will loop

00:20:10,910 --> 00:20:16,880
and constantly read if there are changes

00:20:14,060 --> 00:20:20,660
if there are changes it will put them in

00:20:16,880 --> 00:20:22,310
the hassle cost MDG map then we will

00:20:20,660 --> 00:20:25,250
have the agent that will attach itself

00:20:22,310 --> 00:20:27,860
to the product and JVM and we'll make

00:20:25,250 --> 00:20:31,130
this production JVM subscribe to change

00:20:27,860 --> 00:20:33,560
into the other cost map and every time

00:20:31,130 --> 00:20:36,050
there is a change then the production

00:20:33,560 --> 00:20:38,930
CBM will be triggered it will read

00:20:36,050 --> 00:20:42,170
changes and it will reload the bytecode

00:20:38,930 --> 00:20:48,560
and now there is time for demo because

00:20:42,170 --> 00:20:52,970
otherwise is just like talk so here i've

00:20:48,560 --> 00:20:56,900
created this application and i want to

00:20:52,970 --> 00:20:59,630
add this source so this is my production

00:20:56,900 --> 00:21:03,350
JVM and basically my production given is

00:20:59,630 --> 00:21:10,880
just a simple servlet a very very simple

00:21:03,350 --> 00:21:12,860
servlet and here sorry this is my sorry

00:21:10,880 --> 00:21:15,470
this is not my production genome this is

00:21:12,860 --> 00:21:18,290
what I will be working on my production

00:21:15,470 --> 00:21:21,200
JVM is here this edo servlet it's exact

00:21:18,290 --> 00:21:24,260
actually the same and here I have a main

00:21:21,200 --> 00:21:29,000
class which allows an embedded tom can't

00:21:24,260 --> 00:21:35,920
and and use these this servlet as to

00:21:29,000 --> 00:21:39,830
display it so I will just run this and

00:21:35,920 --> 00:21:46,970
your very important I just run it like

00:21:39,830 --> 00:21:49,370
normally no debug mode and now if I go

00:21:46,970 --> 00:21:55,120
there and I do hello

00:21:49,370 --> 00:21:55,120
I have this hello world while amazing

00:21:55,360 --> 00:22:02,420
second step so this is in production

00:22:00,410 --> 00:22:07,100
this work is in production so I will

00:22:02,420 --> 00:22:09,230
close it and I will forget about it I

00:22:07,100 --> 00:22:15,500
just need to have like the existing

00:22:09,230 --> 00:22:20,060
source here in my IDE sorry now what I

00:22:15,500 --> 00:22:21,280
will do is I will attach myself to this

00:22:20,060 --> 00:22:24,190
running

00:22:21,280 --> 00:22:26,080
application and this running the

00:22:24,190 --> 00:22:28,240
attaching itself as I mentioned is very

00:22:26,080 --> 00:22:29,880
easy here I have cutting code but you

00:22:28,240 --> 00:22:35,200
can do it in any

00:22:29,880 --> 00:22:38,080
gvm language you want two steps you get

00:22:35,200 --> 00:22:40,930
the PID and because I didn't want to

00:22:38,080 --> 00:22:46,300
have a manual process to check the PID

00:22:40,930 --> 00:22:48,700
of the existing production JVM I just

00:22:46,300 --> 00:22:50,740
have a function that computes it

00:22:48,700 --> 00:22:53,490
automatically because it knows the main

00:22:50,740 --> 00:23:00,480
method and then I load the agent and

00:22:53,490 --> 00:23:00,480
loading the agent is as easy as that so

00:23:00,510 --> 00:23:07,000
and I have a pass to the update agent

00:23:04,960 --> 00:23:11,700
that I've created previously so I will

00:23:07,000 --> 00:23:11,700
attach myself to the agents

00:23:16,700 --> 00:23:25,690
and meanwhile I will just start the

00:23:23,000 --> 00:23:25,690
streaming job

00:23:41,299 --> 00:23:48,379
so now the agents has been attaching

00:23:45,289 --> 00:23:52,009
itself to the production gvm and I have

00:23:48,379 --> 00:23:53,720
a streaming job that basically sees that

00:23:52,009 --> 00:23:56,450
there is no change and tells me no

00:23:53,720 --> 00:24:00,559
change no change no change no change

00:23:56,450 --> 00:24:06,980
great the update agents is the one where

00:24:00,559 --> 00:24:08,960
the magic happens of course it takes a

00:24:06,980 --> 00:24:12,229
bit of resources on my machine

00:24:08,960 --> 00:24:12,229
[Music]

00:24:20,299 --> 00:24:26,269
so this is what I attached the

00:24:23,149 --> 00:24:29,719
production GM and ethically what it does

00:24:26,269 --> 00:24:33,499
it will add a bytecode change listener

00:24:29,719 --> 00:24:38,749
so when there is a change then it will

00:24:33,499 --> 00:24:42,049
get the name out of the event because in

00:24:38,749 --> 00:24:45,619
the MDG I will have put the class name

00:24:42,049 --> 00:24:47,599
and I will have put the bytecode itself

00:24:45,619 --> 00:24:49,759
and so basically when there is a change

00:24:47,599 --> 00:24:52,039
I will call the instrumentation and

00:24:49,759 --> 00:24:56,079
redefine classes and the instrumentation

00:24:52,039 --> 00:25:03,559
I get it because I have stored it in

00:24:56,079 --> 00:25:07,690
from the agent main changes so now

00:25:03,559 --> 00:25:19,999
everything is set I will just need to

00:25:07,690 --> 00:25:23,389
change here the class which sits in my

00:25:19,999 --> 00:25:26,599
source folder so here I'm I'm completely

00:25:23,389 --> 00:25:29,509
unrelated to the product in JVM and when

00:25:26,599 --> 00:25:38,419
I change here saying hello world I will

00:25:29,509 --> 00:25:42,499
say hello stack comes and I just need to

00:25:38,419 --> 00:25:45,919
compile so when I compile the target

00:25:42,499 --> 00:25:49,719
classes will get updated the jet job

00:25:45,919 --> 00:25:52,849
will read it will send it to I'm DG and

00:25:49,719 --> 00:25:57,950
the production rhythm will be made aware

00:25:52,849 --> 00:26:01,009
of it and will reload the classes if i

00:25:57,950 --> 00:26:06,619
refresh my running given I will say lost

00:26:01,009 --> 00:26:10,070
accounts and it works for anything I can

00:26:06,619 --> 00:26:14,259
type here okay I can write something

00:26:10,070 --> 00:26:14,259
else here out dot right

00:26:25,179 --> 00:26:38,889
yes sorry I I don't have any idea of

00:26:31,139 --> 00:26:42,089
smart stuff to say I compiled the ellow

00:26:38,889 --> 00:26:45,429
servlets which sits in my source and

00:26:42,089 --> 00:26:49,859
magically on my application on my

00:26:45,429 --> 00:26:52,419
running JVM I have the stuff that I want

00:26:49,859 --> 00:26:56,979
let's stop this because it takes a lot

00:26:52,419 --> 00:27:03,759
of resources of my machine and let's get

00:26:56,979 --> 00:27:06,219
back to the slides so of course there

00:27:03,759 --> 00:27:09,099
are limitations to these like simple

00:27:06,219 --> 00:27:11,679
demo the first if you are not used to

00:27:09,099 --> 00:27:14,589
continuous deployment if you are used to

00:27:11,679 --> 00:27:18,279
a let's create a job put the jar in the

00:27:14,589 --> 00:27:22,239
package registry and and with a tag then

00:27:18,279 --> 00:27:24,460
here I have no tagging and this is part

00:27:22,239 --> 00:27:27,279
of the continuous deployment stuff and

00:27:24,460 --> 00:27:31,179
once you start doing continuous

00:27:27,279 --> 00:27:34,509
deployment you you don't have like like

00:27:31,179 --> 00:27:38,139
very specific artifacts with versions

00:27:34,509 --> 00:27:41,859
though if you are not comfortable with

00:27:38,139 --> 00:27:43,809
that if you want to have a specific

00:27:41,859 --> 00:27:48,999
version it's hard to do continuous

00:27:43,809 --> 00:27:51,639
deployment another limitation is because

00:27:48,999 --> 00:27:54,729
of the redefined classes method you have

00:27:51,639 --> 00:27:59,559
no loading of of new classes so by

00:27:54,729 --> 00:28:01,419
redefining sorry here I don't handle

00:27:59,559 --> 00:28:03,969
loading of newest classes I could have

00:28:01,419 --> 00:28:07,889
done it but I didn't do it because it's

00:28:03,969 --> 00:28:10,629
more work also the redefine class is

00:28:07,889 --> 00:28:13,119
tells you that you have some limitations

00:28:10,629 --> 00:28:15,429
so for example you cannot add remove or

00:28:13,119 --> 00:28:17,169
rename fields or method or whatever you

00:28:15,429 --> 00:28:20,859
are limited to changing the

00:28:17,169 --> 00:28:23,739
implementation of the class you can also

00:28:20,859 --> 00:28:25,239
not change the inner ratings hierarchy

00:28:23,739 --> 00:28:30,009
because it would record work with the

00:28:25,239 --> 00:28:32,529
whole given loading model however you

00:28:30,009 --> 00:28:35,800
can it's already a lot of stuff that you

00:28:32,529 --> 00:28:37,990
can do and if you want to go or further

00:28:35,800 --> 00:28:40,780
if you want to build upon this demo

00:28:37,990 --> 00:28:43,720
because perhaps you think it might have

00:28:40,780 --> 00:28:45,550
been a good idea then you cannot stream

00:28:43,720 --> 00:28:47,800
from the developer machine because then

00:28:45,550 --> 00:28:49,690
every developer would stream from is own

00:28:47,800 --> 00:28:51,910
machine there would be no continuous

00:28:49,690 --> 00:28:54,100
integration anymore but you can do the

00:28:51,910 --> 00:28:56,530
same with streaming from the CIE

00:28:54,100 --> 00:28:58,840
pipeline so the source wouldn't be the

00:28:56,530 --> 00:29:00,970
folder on the developer machine but the

00:28:58,840 --> 00:29:04,510
folder on your continuous integration

00:29:00,970 --> 00:29:07,240
server this works pretty well you can

00:29:04,510 --> 00:29:10,050
also add if you if you want to have

00:29:07,240 --> 00:29:13,300
tanks for example you can also add

00:29:10,050 --> 00:29:15,280
additional tagging metadata in each

00:29:13,300 --> 00:29:19,510
class for example if you take your

00:29:15,280 --> 00:29:21,340
stream from get or from the CI pipeline

00:29:19,510 --> 00:29:24,430
then you probably add the key text

00:29:21,340 --> 00:29:26,170
somewhere and you can like inject the

00:29:24,430 --> 00:29:30,430
tagging metadata in each cross so you

00:29:26,170 --> 00:29:34,510
know a this class is from these commits

00:29:30,430 --> 00:29:37,240
so it's also possible so thanks a lot

00:29:34,510 --> 00:29:40,990
for intention I hoped you liked it you

00:29:37,240 --> 00:29:43,420
can read my blog where I publish weekly

00:29:40,990 --> 00:29:45,370
post on Sunday evening you can subscribe

00:29:43,420 --> 00:29:47,440
to my Twitter account which is always

00:29:45,370 --> 00:29:49,450
nice and more importantly if you are

00:29:47,440 --> 00:29:51,790
interested to dig a bit further or

00:29:49,450 --> 00:29:56,500
because the demo was a bit fast you can

00:29:51,790 --> 00:29:58,480
get the code on github and like clone it

00:29:56,500 --> 00:30:01,540
and perhaps change it and adapt it to

00:29:58,480 --> 00:30:03,610
your needs and see how it works in more

00:30:01,540 --> 00:30:07,770
details so thanks a lot for your

00:30:03,610 --> 00:30:18,509
attention and have a good stack count

00:30:07,770 --> 00:30:18,509
[Music]

00:30:18,640 --> 00:30:24,249
you

00:30:19,700 --> 00:30:24,249

YouTube URL: https://www.youtube.com/watch?v=snS2j-N_37U


