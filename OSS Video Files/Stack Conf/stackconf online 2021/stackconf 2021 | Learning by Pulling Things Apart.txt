Title: stackconf 2021 | Learning by Pulling Things Apart
Publication date: 2021-06-24
Playlist: stackconf online 2021
Description: 
	by Adam Gordon Bell

What happens when you take a Docker file and build it? How is the series of commands turned into a container image and then a running container? I wanted to find out, and so I started peeling back the layers of technology. In this session, Iâ€™ll share what I learned. It will involve containers. But also compilers, programming languages, and how to approach professional learning challenges.


NETWAYS
Konferenzen: https://www.netways.de/events
Schulungen: https://www.netways.de/schulungen
Shop: https://shop.netways.de/
Blog: http://blog.netways.de/
NWS: https://nws.netways.de 

Webinare
Archiv Link: https://www.netways.de/netways/webinare/

Social Media
SlideShare: http://de.slideshare.net/netways
YouTube: https://www.netways.de/youtube
Facebook: https://www.facebook.com/netways
Twitter: https://twitter.com/netways
Instagram: https://www.instagram.com/netwaysgmbh/


Musik: https://www.frametraxx.de/
Captions: 
	00:00:05,660 --> 00:00:12,799
[Applause]

00:00:06,120 --> 00:00:13,280
[Music]

00:00:12,799 --> 00:00:15,519
hello

00:00:13,280 --> 00:00:17,760
welcome to my talk learning by taking

00:00:15,519 --> 00:00:19,439
things apart

00:00:17,760 --> 00:00:21,439
i'm going to talk about how container

00:00:19,439 --> 00:00:23,359
images are made

00:00:21,439 --> 00:00:24,800
and i'm going to show a tool that i

00:00:23,359 --> 00:00:27,359
think is really cool called build kit

00:00:24,800 --> 00:00:29,119
and teach you about compilers also do

00:00:27,359 --> 00:00:30,720
some code demos and talk about the

00:00:29,119 --> 00:00:32,559
future of containerization

00:00:30,720 --> 00:00:34,719
and the big takeaway that i hope to give

00:00:32,559 --> 00:00:36,000
everybody is an intuition about how

00:00:34,719 --> 00:00:37,600
containers are created

00:00:36,000 --> 00:00:39,600
and show you some things that maybe you

00:00:37,600 --> 00:00:41,840
didn't know were possible

00:00:39,600 --> 00:00:43,920
so the idea for this talk came when i

00:00:41,840 --> 00:00:44,559
was presenting at a meetup i was talking

00:00:43,920 --> 00:00:46,960
about

00:00:44,559 --> 00:00:49,120
containerized uh continuous integration

00:00:46,960 --> 00:00:50,879
and earthly this open source build tool

00:00:49,120 --> 00:00:52,879
that i work on and someone asked a

00:00:50,879 --> 00:00:53,600
question about the way containers were

00:00:52,879 --> 00:00:56,160
created

00:00:53,600 --> 00:00:57,600
not the external commands that you call

00:00:56,160 --> 00:00:59,120
like docker build but the actual

00:00:57,600 --> 00:01:00,000
mechanics of creating a container like

00:00:59,120 --> 00:01:01,840
what are the steps

00:01:00,000 --> 00:01:03,760
and what happens and i didn't really

00:01:01,840 --> 00:01:05,360
know but but now i do

00:01:03,760 --> 00:01:07,840
so that's the thing that i want to talk

00:01:05,360 --> 00:01:10,159
about today

00:01:07,840 --> 00:01:11,280
about me i'm adam gordon bell i'm a

00:01:10,159 --> 00:01:14,960
software engineer

00:01:11,280 --> 00:01:17,360
i am a developer advocate at earthly i

00:01:14,960 --> 00:01:19,200
like compilers and devtools i have a

00:01:17,360 --> 00:01:21,920
podcast about software development

00:01:19,200 --> 00:01:22,799
and what else i'm canadian that's

00:01:21,920 --> 00:01:26,240
probably

00:01:22,799 --> 00:01:28,479
enough so a little background

00:01:26,240 --> 00:01:29,520
before we jump into it i'm not going to

00:01:28,479 --> 00:01:31,200
be talking today about

00:01:29,520 --> 00:01:33,200
running containers like when you do

00:01:31,200 --> 00:01:35,520
docker run and start up a container or

00:01:33,200 --> 00:01:36,960
whatever happens in kubernetes i'm going

00:01:35,520 --> 00:01:38,400
to be taking a step

00:01:36,960 --> 00:01:39,600
back from that talking about a step

00:01:38,400 --> 00:01:40,000
before that the step where you're

00:01:39,600 --> 00:01:42,960
actually

00:01:40,000 --> 00:01:44,720
creating the container image do you know

00:01:42,960 --> 00:01:46,159
the difference between a container and

00:01:44,720 --> 00:01:46,720
an image so the way i like to think

00:01:46,159 --> 00:01:49,119
about it

00:01:46,720 --> 00:01:50,560
is by analogy an executable is like a

00:01:49,119 --> 00:01:52,479
program you run on your computer

00:01:50,560 --> 00:01:53,920
when you launch it becomes a process you

00:01:52,479 --> 00:01:55,439
can launch however many processes you

00:01:53,920 --> 00:01:57,040
want from that executable

00:01:55,439 --> 00:01:59,439
similarly an image is something that's

00:01:57,040 --> 00:02:01,280
not running when you run that image

00:01:59,439 --> 00:02:02,719
it becomes a container and you can run

00:02:01,280 --> 00:02:05,840
as many containers as you want

00:02:02,719 --> 00:02:08,160
from a single image so an executable is

00:02:05,840 --> 00:02:09,200
to an image as a container is to a

00:02:08,160 --> 00:02:10,879
process

00:02:09,200 --> 00:02:12,480
and you could imagine how like a virtual

00:02:10,879 --> 00:02:13,760
machine might fit in that as well like a

00:02:12,480 --> 00:02:15,040
there you can have a virtual machine

00:02:13,760 --> 00:02:15,599
image and when you start it up you have

00:02:15,040 --> 00:02:17,840
a running

00:02:15,599 --> 00:02:18,720
virtual machine except an image for a

00:02:17,840 --> 00:02:20,560
container

00:02:18,720 --> 00:02:23,360
is immutable just like an executable

00:02:20,560 --> 00:02:24,800
doesn't change when you run it

00:02:23,360 --> 00:02:27,040
anyways this analogy is going to be

00:02:24,800 --> 00:02:30,239
important as we talk about

00:02:27,040 --> 00:02:30,239
how docker build works

00:02:30,319 --> 00:02:33,920
so the the question that i was asked uh

00:02:32,800 --> 00:02:37,040
was sort of this

00:02:33,920 --> 00:02:39,680
right you have a doctor file and

00:02:37,040 --> 00:02:41,840
you turn that into an image like like

00:02:39,680 --> 00:02:44,959
what actually happens there

00:02:41,840 --> 00:02:46,319
like what happens down in the weeds like

00:02:44,959 --> 00:02:47,680
what are the details of

00:02:46,319 --> 00:02:49,519
turning this into something that i can

00:02:47,680 --> 00:02:50,000
run somewhere and it turns out that

00:02:49,519 --> 00:02:51,840
that's a

00:02:50,000 --> 00:02:53,519
super interesting question and to

00:02:51,840 --> 00:02:56,720
understand that we have to kind of take

00:02:53,519 --> 00:02:56,720
a bit of a step back

00:02:56,959 --> 00:03:01,440
so talking about executables where does

00:03:00,159 --> 00:03:03,599
an executable come from

00:03:01,440 --> 00:03:06,080
how is an executable like a program

00:03:03,599 --> 00:03:08,239
created so here's an example c program

00:03:06,080 --> 00:03:09,519
from dennis ritchie and brian kernan's

00:03:08,239 --> 00:03:11,360
book on c

00:03:09,519 --> 00:03:12,640
and the compiler the program is just a

00:03:11,360 --> 00:03:14,800
simple hello world

00:03:12,640 --> 00:03:16,000
and and clang is the compiler and clang

00:03:14,800 --> 00:03:18,159
is a front end

00:03:16,000 --> 00:03:20,400
for the c language and it's part of a

00:03:18,159 --> 00:03:22,400
compiler known as llvm

00:03:20,400 --> 00:03:26,080
so this is how we can build it turning

00:03:22,400 --> 00:03:26,080
an executable and then run it

00:03:26,480 --> 00:03:30,080
so when we build that program we get

00:03:28,159 --> 00:03:32,640
something like this i'm compiling it to

00:03:30,080 --> 00:03:35,519
x86 assembly and

00:03:32,640 --> 00:03:37,440
this is what i get the assembly code

00:03:35,519 --> 00:03:40,319
maps almost directly on a machine code

00:03:37,440 --> 00:03:42,319
which is binary and much harder to read

00:03:40,319 --> 00:03:43,760
but machine code is what your actual cpu

00:03:42,319 --> 00:03:44,959
understands it's the machine

00:03:43,760 --> 00:03:47,840
architecture of your

00:03:44,959 --> 00:03:47,840
your cpu

00:03:48,080 --> 00:03:51,440
and no one really does this but you can

00:03:49,599 --> 00:03:53,680
actually write assembly code yourself by

00:03:51,440 --> 00:03:53,680
hand

00:03:54,000 --> 00:03:57,040
so the dockerfile equivalent looks like

00:03:56,560 --> 00:03:59,360
this

00:03:57,040 --> 00:04:00,400
we have a dockerfile on top we build it

00:03:59,360 --> 00:04:03,439
using docker build

00:04:00,400 --> 00:04:04,400
and we produce an image and the process

00:04:03,439 --> 00:04:06,720
is similar to

00:04:04,400 --> 00:04:07,599
how we made our hello world docker file

00:04:06,720 --> 00:04:09,360
is passed

00:04:07,599 --> 00:04:11,439
to something called build kits which is

00:04:09,360 --> 00:04:13,200
inside of the docker build command

00:04:11,439 --> 00:04:14,879
along with our build context which is a

00:04:13,200 --> 00:04:16,799
dot in this case generally each

00:04:14,879 --> 00:04:18,400
statement is turned into a layer

00:04:16,799 --> 00:04:21,440
as part of this build step and those

00:04:18,400 --> 00:04:22,479
layers are packaged up into an image

00:04:21,440 --> 00:04:24,560
one thing that's different from a

00:04:22,479 --> 00:04:26,000
traditional compiler is that with a

00:04:24,560 --> 00:04:27,280
compiler you're just taking in source

00:04:26,000 --> 00:04:29,199
code but docker builds you're actually

00:04:27,280 --> 00:04:30,639
taking in a file system context

00:04:29,199 --> 00:04:32,400
so in this case we're passing in our

00:04:30,639 --> 00:04:33,680
present working directory which is what

00:04:32,400 --> 00:04:35,680
we need to do that copy

00:04:33,680 --> 00:04:37,360
copying that readme in and you can

00:04:35,680 --> 00:04:39,919
actually create an image manually

00:04:37,360 --> 00:04:42,000
yourself each layer is just a

00:04:39,919 --> 00:04:43,120
it's kind of like a zip file where the

00:04:42,000 --> 00:04:46,400
name of it is a

00:04:43,120 --> 00:04:49,040
shaw 52 hash of its content

00:04:46,400 --> 00:04:49,680
so you could create one yourself uh each

00:04:49,040 --> 00:04:51,440
layer

00:04:49,680 --> 00:04:53,280
and then you could make a manifest which

00:04:51,440 --> 00:04:55,120
is what describes the image format it's

00:04:53,280 --> 00:04:56,240
just a pretty simple json file

00:04:55,120 --> 00:04:58,639
describing the layers

00:04:56,240 --> 00:04:59,840
and some metadata once again no nobody's

00:04:58,639 --> 00:05:03,680
really making these by hand but

00:04:59,840 --> 00:05:05,600
but it can be done so comparing our c

00:05:03,680 --> 00:05:07,440
program to our docker building we can

00:05:05,600 --> 00:05:09,280
see how they look quite similar

00:05:07,440 --> 00:05:11,039
we have our container image compiler

00:05:09,280 --> 00:05:12,639
that does the heavy lifting

00:05:11,039 --> 00:05:14,639
and we have clang that does the heavy

00:05:12,639 --> 00:05:18,639
lifting and the heavy lifting on

00:05:14,639 --> 00:05:18,639
the docker side is done by buildkit

00:05:19,039 --> 00:05:23,360
so this is buildkit on github and it

00:05:21,680 --> 00:05:25,120
drives not just docker build but

00:05:23,360 --> 00:05:26,560
a number of interesting cloud native

00:05:25,120 --> 00:05:29,600
projects one of them

00:05:26,560 --> 00:05:31,440
is open fast which is a project to run

00:05:29,600 --> 00:05:33,840
serverless functions on kubernetes

00:05:31,440 --> 00:05:34,560
uh rancher rio is a application

00:05:33,840 --> 00:05:36,240
development

00:05:34,560 --> 00:05:39,039
engine for the cloud and there's

00:05:36,240 --> 00:05:40,960
probably a whole bunch more earthly

00:05:39,039 --> 00:05:42,639
uses build kits which is how i kind of

00:05:40,960 --> 00:05:44,240
got involved in this whole story

00:05:42,639 --> 00:05:45,680
and if you try to dig in like well how

00:05:44,240 --> 00:05:46,880
does build kit work

00:05:45,680 --> 00:05:49,199
you come up with this thing that they

00:05:46,880 --> 00:05:53,520
have in their readme which says llb

00:05:49,199 --> 00:05:55,600
is to dockerfile what llvmir is to see

00:05:53,520 --> 00:05:57,280
okay seems like we're going back to

00:05:55,600 --> 00:05:58,880
compiler so so let's dig in

00:05:57,280 --> 00:06:01,120
a little bit more on what this statement

00:05:58,880 --> 00:06:04,319
might mean

00:06:01,120 --> 00:06:05,280
so earlier we have this diagram of how

00:06:04,319 --> 00:06:08,080
the compiler

00:06:05,280 --> 00:06:09,680
works and once you get into the details

00:06:08,080 --> 00:06:13,520
of what a compiler actually does this

00:06:09,680 --> 00:06:13,520
turns out to be a little bit of a lie

00:06:13,600 --> 00:06:17,680
on the left here is the pdp 11. the

00:06:15,840 --> 00:06:19,360
first c compiler was written for the

00:06:17,680 --> 00:06:21,199
pdb11 by dennis ritchie

00:06:19,360 --> 00:06:23,039
who worked with brian kernahan on the

00:06:21,199 --> 00:06:25,199
book and the hello world example

00:06:23,039 --> 00:06:26,319
we saw earlier um but it worked totally

00:06:25,199 --> 00:06:28,160
like that diagram

00:06:26,319 --> 00:06:30,240
the seco will be taken in by a compiler

00:06:28,160 --> 00:06:32,160
and will be converted to pdb

00:06:30,240 --> 00:06:34,080
uh 11 assembly instructions which would

00:06:32,160 --> 00:06:34,800
be converted to machine code and

00:06:34,080 --> 00:06:37,680
executed

00:06:34,800 --> 00:06:39,280
but this direct mapping poses a problem

00:06:37,680 --> 00:06:42,319
whenever you have a new machine

00:06:39,280 --> 00:06:43,919
it means you need a new compiler and

00:06:42,319 --> 00:06:44,479
what language do you write that compiler

00:06:43,919 --> 00:06:47,120
in

00:06:44,479 --> 00:06:47,520
so the first c compiler was written in i

00:06:47,120 --> 00:06:50,160
believe

00:06:47,520 --> 00:06:51,919
pdp 11 assembly but you don't want to

00:06:50,160 --> 00:06:54,000
have to rewrite every compiler

00:06:51,919 --> 00:06:55,520
in the assembly language of whatever

00:06:54,000 --> 00:06:56,319
machine you want to target because like

00:06:55,520 --> 00:06:58,639
what happens

00:06:56,319 --> 00:07:00,080
when the vax 11 comes out which which

00:06:58,639 --> 00:07:03,039
followed the pdp 11

00:07:00,080 --> 00:07:04,880
or you know the new apple m1 these have

00:07:03,039 --> 00:07:06,560
different instruction sets and so the

00:07:04,880 --> 00:07:07,840
assembly is different and you'd need to

00:07:06,560 --> 00:07:11,280
rewrite it

00:07:07,840 --> 00:07:12,960
not a good solution so this problem was

00:07:11,280 --> 00:07:14,319
very quickly solved by the compiler

00:07:12,960 --> 00:07:16,319
authors who came up with this

00:07:14,319 --> 00:07:18,400
structure we see here they said a

00:07:16,319 --> 00:07:20,479
compiler can be split into three steps

00:07:18,400 --> 00:07:21,520
you have a front end that takes in your

00:07:20,479 --> 00:07:24,160
source

00:07:21,520 --> 00:07:25,440
and your various files and it tokenizes

00:07:24,160 --> 00:07:27,520
them and parses them

00:07:25,440 --> 00:07:29,039
you have a middle that is an optimizer

00:07:27,520 --> 00:07:30,800
it does performance optimizations to

00:07:29,039 --> 00:07:31,840
make the code faster

00:07:30,800 --> 00:07:34,160
at some point they called this the

00:07:31,840 --> 00:07:35,520
middle end which is not my

00:07:34,160 --> 00:07:37,680
favorite term so i'm glad it didn't

00:07:35,520 --> 00:07:39,120
catch on and then you have a back end

00:07:37,680 --> 00:07:41,280
which actually generates

00:07:39,120 --> 00:07:43,280
the assembly that can be run on the

00:07:41,280 --> 00:07:45,039
various machine architectures

00:07:43,280 --> 00:07:46,400
so now you don't actually have to make a

00:07:45,039 --> 00:07:47,680
new compiler for each machine

00:07:46,400 --> 00:07:50,000
architecture

00:07:47,680 --> 00:07:52,560
all you have to do is make a new back

00:07:50,000 --> 00:07:54,960
end for each machine architecture

00:07:52,560 --> 00:07:55,919
and this will all relate back to docker

00:07:54,960 --> 00:07:58,000
builds trust me

00:07:55,919 --> 00:07:59,360
the trick is getting all these back ends

00:07:58,000 --> 00:08:01,680
speaking the same language

00:07:59,360 --> 00:08:03,360
right so to do that you need an

00:08:01,680 --> 00:08:05,360
intermediate representation

00:08:03,360 --> 00:08:07,039
you need some way that all these back

00:08:05,360 --> 00:08:10,400
ends can speak the same language but

00:08:07,039 --> 00:08:12,080
generate different machine code

00:08:10,400 --> 00:08:14,639
so you need a language that basically

00:08:12,080 --> 00:08:16,240
isn't c but isn't the machine specific

00:08:14,639 --> 00:08:17,199
assembly either it needs to be somewhere

00:08:16,240 --> 00:08:18,879
in between

00:08:17,199 --> 00:08:20,720
and once you have that language all the

00:08:18,879 --> 00:08:22,879
back ends need to do is translate it

00:08:20,720 --> 00:08:24,160
from it to machine architecture

00:08:22,879 --> 00:08:26,000
the machine architecture that they need

00:08:24,160 --> 00:08:28,080
to run on in our first

00:08:26,000 --> 00:08:30,080
c example we use clang which is the

00:08:28,080 --> 00:08:31,199
front end for llvm

00:08:30,080 --> 00:08:33,360
and hopefully that's starting to make

00:08:31,199 --> 00:08:35,760
sense now llvm is a compiler that

00:08:33,360 --> 00:08:39,120
follows this three-tier structure

00:08:35,760 --> 00:08:41,120
clang is a front-end for it so llvm was

00:08:39,120 --> 00:08:44,800
created as a research project but now

00:08:41,120 --> 00:08:44,800
it's heavily supported by apple

00:08:45,920 --> 00:08:50,080
so once you have that kind of structure

00:08:48,320 --> 00:08:52,800
you can now have multiple front ends

00:08:50,080 --> 00:08:54,160
this is what modern llvm looks like it

00:08:52,800 --> 00:08:55,680
started with the clang front end and now

00:08:54,160 --> 00:08:56,320
it has many front ends there's been sort

00:08:55,680 --> 00:08:58,399
of a

00:08:56,320 --> 00:08:59,760
cambrian explosion of ahead of time

00:08:58,399 --> 00:09:01,360
compiled languages

00:08:59,760 --> 00:09:03,680
that happened in the past like 10 years

00:09:01,360 --> 00:09:06,399
or so and it's it's a result of it being

00:09:03,680 --> 00:09:07,600
easy to add a new front end to llvm

00:09:06,399 --> 00:09:09,600
all you need to do is create that new

00:09:07,600 --> 00:09:10,399
front end now you have a new programming

00:09:09,600 --> 00:09:13,120
language and

00:09:10,399 --> 00:09:14,720
it can target it can run on anywhere

00:09:13,120 --> 00:09:17,839
that there's a back end for

00:09:14,720 --> 00:09:18,240
lvm available the reason for this is

00:09:17,839 --> 00:09:20,240
that

00:09:18,240 --> 00:09:22,080
this ir acts as a common interface

00:09:20,240 --> 00:09:23,920
between layers and on the back end

00:09:22,080 --> 00:09:26,480
a webassembly back-end means that you

00:09:23,920 --> 00:09:27,279
can write c or rust or julia that can

00:09:26,480 --> 00:09:29,519
run in your

00:09:27,279 --> 00:09:31,279
web browser and there's even a gpu

00:09:29,519 --> 00:09:33,279
back-end so

00:09:31,279 --> 00:09:35,440
maybe you can compile things down to run

00:09:33,279 --> 00:09:37,519
on pixel shaders

00:09:35,440 --> 00:09:39,440
if you can build a front end and emit

00:09:37,519 --> 00:09:40,000
this ir you now have a new programming

00:09:39,440 --> 00:09:42,560
language

00:09:40,000 --> 00:09:43,360
and if you can build a new back end then

00:09:42,560 --> 00:09:46,240
all of a sudden

00:09:43,360 --> 00:09:48,160
you can run all of these languages on

00:09:46,240 --> 00:09:50,720
whatever that back end is targeting

00:09:48,160 --> 00:09:52,160
this is super cool stuff because the

00:09:50,720 --> 00:09:53,760
secret is just this format this

00:09:52,160 --> 00:09:57,360
intermediate representation

00:09:53,760 --> 00:09:58,800
um it's a pretty neat little trick

00:09:57,360 --> 00:10:00,399
so now bringing it back to container

00:09:58,800 --> 00:10:00,959
images we can finally understand that

00:10:00,399 --> 00:10:03,839
quote

00:10:00,959 --> 00:10:04,800
build kit works the same way as llvm it

00:10:03,839 --> 00:10:06,480
has something called

00:10:04,800 --> 00:10:08,160
llb which is its intermediate

00:10:06,480 --> 00:10:09,760
representation and

00:10:08,160 --> 00:10:11,519
it has this because containers need to

00:10:09,760 --> 00:10:12,240
be able to run on a number of machine

00:10:11,519 --> 00:10:15,200
architectures

00:10:12,240 --> 00:10:16,640
and once you have that that ir that llb

00:10:15,200 --> 00:10:18,399
for varying the back ends you can start

00:10:16,640 --> 00:10:20,160
to have many front ends as well

00:10:18,399 --> 00:10:21,760
right now obviously the most common

00:10:20,160 --> 00:10:23,440
front end is docker files like we were

00:10:21,760 --> 00:10:27,120
just looking at

00:10:23,440 --> 00:10:27,120
but that doesn't need to be the limit

00:10:28,480 --> 00:10:32,160
lvm ir looks like this it looks like

00:10:30,399 --> 00:10:34,640
kind of a verbose and

00:10:32,160 --> 00:10:35,440
explicit programming language lb looks

00:10:34,640 --> 00:10:37,920
quite different

00:10:35,440 --> 00:10:39,680
where llvm is the basics of a simple

00:10:37,920 --> 00:10:42,480
programming language on the left

00:10:39,680 --> 00:10:45,040
llb ir is a language for creating

00:10:42,480 --> 00:10:47,279
self-contained cloud native packages

00:10:45,040 --> 00:10:48,079
and now that we understand the structure

00:10:47,279 --> 00:10:50,240
behind

00:10:48,079 --> 00:10:51,360
making a docker build statement let's

00:10:50,240 --> 00:10:52,880
play around with it let's see what we

00:10:51,360 --> 00:10:55,600
can do

00:10:52,880 --> 00:10:56,640
all right demo time so this is the

00:10:55,600 --> 00:10:58,160
docker file

00:10:56,640 --> 00:11:00,079
that i showed at the beginning very

00:10:58,160 --> 00:11:01,920
simple we start from alpine

00:11:00,079 --> 00:11:03,200
we're going to copy in our readme which

00:11:01,920 --> 00:11:06,720
you can now see is

00:11:03,200 --> 00:11:10,000
over here and then we're going to echo

00:11:06,720 --> 00:11:11,920
to a file standard docker build

00:11:10,000 --> 00:11:14,320
this uh this whole demo i'm going to

00:11:11,920 --> 00:11:16,560
take you guys through

00:11:14,320 --> 00:11:17,680
is available also if you want to play

00:11:16,560 --> 00:11:19,440
along at home

00:11:17,680 --> 00:11:21,360
so it's on github under my username

00:11:19,440 --> 00:11:23,440
which is ag bell under compiling

00:11:21,360 --> 00:11:25,040
containers

00:11:23,440 --> 00:11:27,120
um so the first thing we're going to do

00:11:25,040 --> 00:11:28,079
is just a standard docker build so we're

00:11:27,120 --> 00:11:30,000
going to

00:11:28,079 --> 00:11:31,519
just build it pass in the present

00:11:30,000 --> 00:11:34,000
working directory

00:11:31,519 --> 00:11:34,959
um and then we're going to call that ag

00:11:34,000 --> 00:11:38,560
bell

00:11:34,959 --> 00:11:41,600
demo1 we build it like that and then

00:11:38,560 --> 00:11:42,240
once we have that image built we can run

00:11:41,600 --> 00:11:46,079
it

00:11:42,240 --> 00:11:49,600
so we're gonna run it interactively

00:11:46,079 --> 00:11:53,120
ag bell demo one and then

00:11:49,600 --> 00:11:54,240
we will start up a shell so now we're

00:11:53,120 --> 00:11:57,680
inside of it

00:11:54,240 --> 00:11:58,399
we can see everything so our readme is

00:11:57,680 --> 00:12:01,519
there

00:11:58,399 --> 00:12:02,240
right and then our our build file we can

00:12:01,519 --> 00:12:05,360
see right there

00:12:02,240 --> 00:12:06,880
standard docker build also like maybe we

00:12:05,360 --> 00:12:07,920
don't even have to look it around inside

00:12:06,880 --> 00:12:09,519
because we can see

00:12:07,920 --> 00:12:11,920
it running right here it prints out what

00:12:09,519 --> 00:12:13,680
it's doing as it builds the images

00:12:11,920 --> 00:12:16,639
but you know it's sometimes it's nice to

00:12:13,680 --> 00:12:19,760
verify these things

00:12:16,639 --> 00:12:20,320
okay so that's just a very simple build

00:12:19,760 --> 00:12:22,160
now

00:12:20,320 --> 00:12:24,399
let's build something directly using

00:12:22,160 --> 00:12:27,680
build kit so to do that we are going to

00:12:24,399 --> 00:12:29,760
install build kit so the

00:12:27,680 --> 00:12:31,200
the first build happened using buildkit

00:12:29,760 --> 00:12:32,560
as well but docker

00:12:31,200 --> 00:12:34,560
the docker daemon was running in the

00:12:32,560 --> 00:12:36,160
background and

00:12:34,560 --> 00:12:37,760
had build kit running inside of it and

00:12:36,160 --> 00:12:39,440
used it to build it but now we're going

00:12:37,760 --> 00:12:40,639
to use it directly so now that we have

00:12:39,440 --> 00:12:43,440
it installed

00:12:40,639 --> 00:12:44,959
we get this kind of build ctl program

00:12:43,440 --> 00:12:47,279
which we can use to interact

00:12:44,959 --> 00:12:50,800
with the buildkit daemon and then we

00:12:47,279 --> 00:12:50,800
need to start up the daemon

00:12:51,360 --> 00:12:55,680
the way i like to do that because i'm on

00:12:53,120 --> 00:12:57,519
a mac is i start buildkit

00:12:55,680 --> 00:12:59,440
which has this docker image moby build

00:12:57,519 --> 00:13:03,120
kit as a privileged container

00:12:59,440 --> 00:13:03,120
and i just name it build kit

00:13:04,399 --> 00:13:07,920
looks like i already have it running and

00:13:06,160 --> 00:13:11,120
then i just need to

00:13:07,920 --> 00:13:12,160
tell build ctl where to find it so build

00:13:11,120 --> 00:13:14,399
ctl looks

00:13:12,160 --> 00:13:17,760
at this environmental variable so i'll

00:13:14,399 --> 00:13:20,160
just tell it that it's running there

00:13:17,760 --> 00:13:21,680
so then once i have that in place i can

00:13:20,160 --> 00:13:23,360
do the same type of build

00:13:21,680 --> 00:13:25,120
except we're not going to call it a

00:13:23,360 --> 00:13:28,800
standard docker build anymore

00:13:25,120 --> 00:13:28,800
let's call it a build kit

00:13:29,600 --> 00:13:37,279
we'll get direct build let's try that

00:13:34,399 --> 00:13:37,760
so build kit uh build ctl is a little

00:13:37,279 --> 00:13:39,360
bit

00:13:37,760 --> 00:13:41,920
more verbose it has a couple more

00:13:39,360 --> 00:13:43,760
options so here is a

00:13:41,920 --> 00:13:45,920
build ctl build so we're going to call

00:13:43,760 --> 00:13:47,120
build we get to specify our front end

00:13:45,920 --> 00:13:48,560
which you might remember from that

00:13:47,120 --> 00:13:52,079
diagram uh

00:13:48,560 --> 00:13:53,920
pass in our context um and then here we

00:13:52,079 --> 00:13:54,720
have kind of the backend option so we

00:13:53,920 --> 00:13:57,120
can choose

00:13:54,720 --> 00:13:57,920
outputs you can output an image or a tar

00:13:57,120 --> 00:14:00,240
file or

00:13:57,920 --> 00:14:01,440
whatever type of back ends it supports

00:14:00,240 --> 00:14:03,600
and then we're

00:14:01,440 --> 00:14:06,240
going to call this demo 2 and we're

00:14:03,600 --> 00:14:06,240
going to push it

00:14:07,199 --> 00:14:12,399
so we can build that and we can see here

00:14:10,399 --> 00:14:13,680
it building it and the reason for

00:14:12,399 --> 00:14:14,959
pushing it is kind of interesting too

00:14:13,680 --> 00:14:17,040
because now we're building it inside

00:14:14,959 --> 00:14:18,399
that container i started up we need to

00:14:17,040 --> 00:14:20,720
like push it somewhere

00:14:18,399 --> 00:14:22,480
so that we can retrieve it and run it so

00:14:20,720 --> 00:14:24,160
we should be able to actually pull it

00:14:22,480 --> 00:14:27,839
now

00:14:24,160 --> 00:14:31,040
demo two like that and then we can

00:14:27,839 --> 00:14:31,600
run it the same way we did before docker

00:14:31,040 --> 00:14:34,560
run

00:14:31,600 --> 00:14:36,320
age bell demo 2 and we'll start up our

00:14:34,560 --> 00:14:41,519
shell

00:14:36,320 --> 00:14:41,519
and then if we look inside of our

00:14:42,000 --> 00:14:46,800
isn't that yeah there we go so now we

00:14:44,880 --> 00:14:48,240
get build kit direct built

00:14:46,800 --> 00:14:49,839
and we should be able to see that our

00:14:48,240 --> 00:14:51,600
readme is there as well

00:14:49,839 --> 00:14:55,440
so that worked so now we're just

00:14:51,600 --> 00:14:55,440
building it directly with buildkit

00:14:55,920 --> 00:15:03,199
all right so what should we do next

00:14:59,680 --> 00:15:05,760
so if you recall from our diagrams

00:15:03,199 --> 00:15:07,040
earlier we were saying that the this

00:15:05,760 --> 00:15:09,680
kind of three-phase

00:15:07,040 --> 00:15:10,639
architecture means that a front-end

00:15:09,680 --> 00:15:14,399
communicates

00:15:10,639 --> 00:15:15,360
with build kit or the communicates with

00:15:14,399 --> 00:15:18,720
the middle

00:15:15,360 --> 00:15:23,279
and it sends its results to the back end

00:15:18,720 --> 00:15:27,839
and all of these stages are

00:15:23,279 --> 00:15:27,839
specified in terms of this llb

00:15:28,160 --> 00:15:35,360
right so one thing we can do is actually

00:15:32,720 --> 00:15:36,079
llb one thing we can try to do is

00:15:35,360 --> 00:15:39,360
actually

00:15:36,079 --> 00:15:42,720
send llb directly to

00:15:39,360 --> 00:15:46,079
this build kit daemon so

00:15:42,720 --> 00:15:47,839
llb is specified in terms of a protocol

00:15:46,079 --> 00:15:49,680
buffer and you can actually make these

00:15:47,839 --> 00:15:52,720
calls against bill kit using

00:15:49,680 --> 00:15:54,160
grpc so basically in any language that

00:15:52,720 --> 00:15:56,480
has support for

00:15:54,160 --> 00:15:57,279
protocol buffers you should be able to

00:15:56,480 --> 00:15:59,839
write something

00:15:57,279 --> 00:16:01,199
that generates this and then send it

00:15:59,839 --> 00:16:04,320
along to buildkit

00:16:01,199 --> 00:16:09,199
so i built an example of this i don't

00:16:04,320 --> 00:16:12,560
know why i can't close that

00:16:09,199 --> 00:16:13,279
um yeah so i built an example of this

00:16:12,560 --> 00:16:15,759
called right

00:16:13,279 --> 00:16:15,759
llb

00:16:16,720 --> 00:16:20,959
so here i'm going i'm using go because

00:16:19,199 --> 00:16:22,000
go already has nice bindings for lb but

00:16:20,959 --> 00:16:22,959
yeah as i said you could use any

00:16:22,000 --> 00:16:26,320
language you want

00:16:22,959 --> 00:16:27,440
you can see my create lob state is very

00:16:26,320 --> 00:16:30,000
similar

00:16:27,440 --> 00:16:30,560
to our original docker file we have our

00:16:30,000 --> 00:16:33,040
image

00:16:30,560 --> 00:16:33,920
specified here then we're going to copy

00:16:33,040 --> 00:16:36,240
our readme

00:16:33,920 --> 00:16:37,519
we have to specify context the only

00:16:36,240 --> 00:16:39,600
stage that's

00:16:37,519 --> 00:16:41,759
drastic well the only stage is somewhat

00:16:39,600 --> 00:16:45,600
different is our run statement where

00:16:41,759 --> 00:16:47,199
because we are pushing standard out to a

00:16:45,600 --> 00:16:48,720
file which is kind of a shell command we

00:16:47,199 --> 00:16:50,720
have to launch a shell

00:16:48,720 --> 00:16:54,240
and then run that inside of it it's

00:16:50,720 --> 00:16:56,880
pretty close to our original

00:16:54,240 --> 00:16:56,880
dockerfile

00:16:57,440 --> 00:17:04,160
so to run this

00:17:00,480 --> 00:17:09,839
we can just do go run

00:17:04,160 --> 00:17:12,799
and then it is called right lb.go

00:17:09,839 --> 00:17:14,720
and then we get this nice output um so

00:17:12,799 --> 00:17:16,319
protobox is a binary format

00:17:14,720 --> 00:17:18,640
and if you see here we're actually just

00:17:16,319 --> 00:17:20,720
writing to standard out

00:17:18,640 --> 00:17:22,400
which lets us see the raw llb but

00:17:20,720 --> 00:17:25,039
certainly not super useful

00:17:22,400 --> 00:17:26,640
so if we want to see what it looks like

00:17:25,039 --> 00:17:29,760
in a nice format

00:17:26,640 --> 00:17:34,160
then build ctl has a nice thing

00:17:29,760 --> 00:17:34,160
called i think it's called dump llb

00:17:36,480 --> 00:17:41,360
and then if we want to format that

00:17:38,559 --> 00:17:44,320
nicely we can pass it to jq

00:17:41,360 --> 00:17:46,240
and then we get this nice formatted lob

00:17:44,320 --> 00:17:49,440
output and we can see actually what

00:17:46,240 --> 00:17:51,679
this is generating um

00:17:49,440 --> 00:17:52,640
it's for both but it's all here we can

00:17:51,679 --> 00:17:57,120
see like here

00:17:52,640 --> 00:17:58,960
is our run statement

00:17:57,120 --> 00:18:00,320
we should be able to see here's our

00:17:58,960 --> 00:18:00,880
here's our readme so you can see the

00:18:00,320 --> 00:18:04,400
action

00:18:00,880 --> 00:18:05,039
copy readme um you should be able to see

00:18:04,400 --> 00:18:08,240
here's our

00:18:05,039 --> 00:18:10,400
sort of from equivalent

00:18:08,240 --> 00:18:12,720
so that's what lob kind of looks like in

00:18:10,400 --> 00:18:14,240
the raw i mean when formatted nicely so

00:18:12,720 --> 00:18:17,760
now let's try to actually

00:18:14,240 --> 00:18:20,799
build this so we can use similar

00:18:17,760 --> 00:18:22,799
statements as before

00:18:20,799 --> 00:18:26,559
let's start there we're going to build

00:18:22,799 --> 00:18:26,559
it but instead of just piping it out

00:18:27,600 --> 00:18:31,760
we're gonna tell build ctl to actually

00:18:30,640 --> 00:18:35,360
build it so

00:18:31,760 --> 00:18:38,080
we say build ctl build our context

00:18:35,360 --> 00:18:39,600
is present working directory and then

00:18:38,080 --> 00:18:42,720
similar stuff to before

00:18:39,600 --> 00:18:43,840
we're gonna make it as demo three and

00:18:42,720 --> 00:18:45,600
push that

00:18:43,840 --> 00:18:47,280
so now yeah like this program is

00:18:45,600 --> 00:18:49,360
generating llb and we're just using this

00:18:47,280 --> 00:18:50,000
build ctl as like a helper to pipe it

00:18:49,360 --> 00:18:52,880
through

00:18:50,000 --> 00:18:52,880
uh to build kit

00:18:53,600 --> 00:18:57,840
so now like if i were you know building

00:18:56,320 --> 00:18:59,760
if i were productionizing

00:18:57,840 --> 00:19:01,280
my little five line thing i might not

00:18:59,760 --> 00:19:04,160
want to use this build ctl

00:19:01,280 --> 00:19:05,039
program i might actually want to you

00:19:04,160 --> 00:19:06,880
know

00:19:05,039 --> 00:19:08,799
see you know check that environmental

00:19:06,880 --> 00:19:10,799
variable myself or or somehow know

00:19:08,799 --> 00:19:12,320
where build kit damon is running you

00:19:10,799 --> 00:19:13,039
know connect to it and send the stuff

00:19:12,320 --> 00:19:14,640
directly

00:19:13,039 --> 00:19:16,320
maybe start it up if it's not there but

00:19:14,640 --> 00:19:21,200
this works really nice especially

00:19:16,320 --> 00:19:24,720
for a demo um so it seems like it built

00:19:21,200 --> 00:19:25,440
right so then kind of similar as before

00:19:24,720 --> 00:19:29,440
i can do

00:19:25,440 --> 00:19:33,440
docker on it i will pull it first

00:19:29,440 --> 00:19:36,960
and sell my own name right

00:19:33,440 --> 00:19:36,960
and i think we're on demo three

00:19:37,120 --> 00:19:40,880
and then let's start at the shell

00:19:41,280 --> 00:19:44,640
see it pulls down and if we look at our

00:19:43,679 --> 00:19:46,960
build file

00:19:44,640 --> 00:19:49,360
we can see programmatically built bam so

00:19:46,960 --> 00:19:49,360
it worked

00:19:51,200 --> 00:19:54,559
so i mean this is a really little demo

00:19:53,520 --> 00:19:57,679
but

00:19:54,559 --> 00:19:58,400
i think this is really cool because you

00:19:57,679 --> 00:20:01,200
can use

00:19:58,400 --> 00:20:01,600
all the abstraction and control flow

00:20:01,200 --> 00:20:03,200
that

00:20:01,600 --> 00:20:04,640
the programming languages offer you

00:20:03,200 --> 00:20:05,039
right if you want to do like some sort

00:20:04,640 --> 00:20:07,200
of

00:20:05,039 --> 00:20:08,640
control flow or loops or something like

00:20:07,200 --> 00:20:10,640
that inside of a docker file

00:20:08,640 --> 00:20:12,000
it's not entirely clear to me how you

00:20:10,640 --> 00:20:13,760
would do that

00:20:12,000 --> 00:20:15,600
and here you get to kind of raise the

00:20:13,760 --> 00:20:17,200
abstraction level right everything

00:20:15,600 --> 00:20:18,080
that's available to you in a programming

00:20:17,200 --> 00:20:20,320
language you can

00:20:18,080 --> 00:20:21,840
now do to generate docker files

00:20:20,320 --> 00:20:22,799
including using like libraries that

00:20:21,840 --> 00:20:24,720
might be available

00:20:22,799 --> 00:20:26,159
in your language of choice so i think

00:20:24,720 --> 00:20:28,640
it's pretty neat just

00:20:26,159 --> 00:20:30,720
being able to do this let's move on

00:20:28,640 --> 00:20:34,000
let's let's keep going from here

00:20:30,720 --> 00:20:37,120
right so

00:20:34,000 --> 00:20:38,559
that was a front end right but it was a

00:20:37,120 --> 00:20:43,039
front end that just

00:20:38,559 --> 00:20:45,360
sent llb directly to buildkit

00:20:43,039 --> 00:20:46,640
but like a true front end probably does

00:20:45,360 --> 00:20:48,880
other stuff right it

00:20:46,640 --> 00:20:49,919
probably like is more like a real

00:20:48,880 --> 00:20:53,280
compiler where

00:20:49,919 --> 00:20:57,120
it takes in source and it like parses

00:20:53,280 --> 00:20:58,000
it um and maybe produces some errors and

00:20:57,120 --> 00:21:00,400
whatever and then it

00:20:58,000 --> 00:21:01,440
makes the intermediate representation uh

00:21:00,400 --> 00:21:02,799
that it then

00:21:01,440 --> 00:21:06,000
sends through to buildkit so there's a

00:21:02,799 --> 00:21:08,240
bunch more layers right

00:21:06,000 --> 00:21:09,600
and it's actually pretty easy to build

00:21:08,240 --> 00:21:12,720
something like this

00:21:09,600 --> 00:21:15,840
um with docker and with buildkit um

00:21:12,720 --> 00:21:19,039
so docker has

00:21:15,840 --> 00:21:20,960
syntax where you can say in the front

00:21:19,039 --> 00:21:22,080
on the top line of your docker file you

00:21:20,960 --> 00:21:24,960
can say syntax

00:21:22,080 --> 00:21:25,280
and then you can give an image name and

00:21:24,960 --> 00:21:28,320
then

00:21:25,280 --> 00:21:31,039
it interprets that to mean this is

00:21:28,320 --> 00:21:31,679
a docker image that contains the front

00:21:31,039 --> 00:21:34,240
end

00:21:31,679 --> 00:21:35,360
that i would like to have this build run

00:21:34,240 --> 00:21:38,400
in right so

00:21:35,360 --> 00:21:40,960
now we can have a a true front end and

00:21:38,400 --> 00:21:42,240
and use it right so to build something

00:21:40,960 --> 00:21:44,000
like this you need to have it somewhere

00:21:42,240 --> 00:21:46,240
the docker can pull from but it also

00:21:44,000 --> 00:21:48,240
needs to do all these steps right it

00:21:46,240 --> 00:21:50,159
needs to accept text as an input it

00:21:48,240 --> 00:21:50,799
needs to tokenize it and parse it and

00:21:50,159 --> 00:21:54,080
generate

00:21:50,799 --> 00:21:55,760
the llb and then you know the docker

00:21:54,080 --> 00:21:58,400
build will take care of the plumbing

00:21:55,760 --> 00:21:59,520
of sending that on to the next step so i

00:21:58,400 --> 00:22:02,000
did this i built

00:21:59,520 --> 00:22:04,400
a trivial front-end programming language

00:22:02,000 --> 00:22:06,000
for for docker build

00:22:04,400 --> 00:22:07,520
and and it's called ic file and you can

00:22:06,000 --> 00:22:10,640
find it in this

00:22:07,520 --> 00:22:12,799
uh repository as well so

00:22:10,640 --> 00:22:14,000
the first thing that we should do to

00:22:12,799 --> 00:22:16,400
show how it works is

00:22:14,000 --> 00:22:18,000
is actually build a docker container uh

00:22:16,400 --> 00:22:20,320
that contains it so we can do this type

00:22:18,000 --> 00:22:20,320
of thing

00:22:20,880 --> 00:22:27,520
don't save so

00:22:24,240 --> 00:22:31,039
um i have that here this

00:22:27,520 --> 00:22:33,919
is my docker file for my docker

00:22:31,039 --> 00:22:35,039
front end so he uses golang it's going

00:22:33,919 --> 00:22:38,080
to copy in the source

00:22:35,039 --> 00:22:39,520
it's going to run a build command

00:22:38,080 --> 00:22:41,360
and then it's just going gonna set as

00:22:39,520 --> 00:22:44,960
the entry point the executable

00:22:41,360 --> 00:22:48,080
we're creating so i can build this

00:22:44,960 --> 00:22:51,280
docker build

00:22:48,080 --> 00:22:52,640
uh same stuff but now um we have a

00:22:51,280 --> 00:22:55,679
different file name

00:22:52,640 --> 00:22:59,440
so we need to do ik file

00:22:55,679 --> 00:23:00,320
docker file um and then we're going to

00:22:59,440 --> 00:23:03,600
tag it ag

00:23:00,320 --> 00:23:06,400
bell before

00:23:03,600 --> 00:23:06,400
we build this

00:23:06,640 --> 00:23:10,320
so we're actually building a docker

00:23:09,039 --> 00:23:12,240
container that we're later

00:23:10,320 --> 00:23:13,520
going to use to build a docker container

00:23:12,240 --> 00:23:16,640
which i think is

00:23:13,520 --> 00:23:20,159
kind of interesting

00:23:16,640 --> 00:23:20,159
you know recursion see recursion

00:23:20,640 --> 00:23:24,240
and then once we have this then we can

00:23:23,360 --> 00:23:27,280
use it

00:23:24,240 --> 00:23:29,520
so how the ic file works

00:23:27,280 --> 00:23:31,520
is it has you know all the steps you

00:23:29,520 --> 00:23:34,640
might expect of a parser

00:23:31,520 --> 00:23:36,640
so it has steps to convert

00:23:34,640 --> 00:23:38,480
from a kind of standard dockerfile

00:23:36,640 --> 00:23:41,279
format to llb

00:23:38,480 --> 00:23:41,919
it has some kind of parsing commands and

00:23:41,279 --> 00:23:43,679
etc

00:23:41,919 --> 00:23:45,520
and i didn't actually build this in

00:23:43,679 --> 00:23:48,080
entirety what i did is i started

00:23:45,520 --> 00:23:50,960
with the existing docker file front end

00:23:48,080 --> 00:23:52,400
i extracted it from the mobi project and

00:23:50,960 --> 00:23:54,880
then i made some changes to it

00:23:52,400 --> 00:23:55,440
and the main changes i made to it was

00:23:54,880 --> 00:23:57,520
based

00:23:55,440 --> 00:23:59,120
on this programming language called

00:23:57,520 --> 00:24:01,600
intracal

00:23:59,120 --> 00:24:04,000
so intercal is this programming language

00:24:01,600 --> 00:24:06,240
from the 70s that was kind of made as a

00:24:04,000 --> 00:24:07,360
joke it was made to look like fortran

00:24:06,240 --> 00:24:10,240
but kind of

00:24:07,360 --> 00:24:11,200
in silly ways so in intercal you have to

00:24:10,240 --> 00:24:13,919
say

00:24:11,200 --> 00:24:16,559
instead of just saying two plus two you

00:24:13,919 --> 00:24:18,480
have to say please two plus two

00:24:16,559 --> 00:24:20,480
so one thing i've done is i've changed

00:24:18,480 --> 00:24:21,039
the run command in a docker file to be

00:24:20,480 --> 00:24:24,159
please

00:24:21,039 --> 00:24:26,000
which i feel is much more polite um

00:24:24,159 --> 00:24:28,080
and and also change some other things so

00:24:26,000 --> 00:24:28,640
instead of copy you can say stash which

00:24:28,080 --> 00:24:30,960
is another

00:24:28,640 --> 00:24:32,240
keyword from intracal and to start an

00:24:30,960 --> 00:24:35,679
entry point you know you

00:24:32,240 --> 00:24:38,559
do please do and etc um

00:24:35,679 --> 00:24:41,840
it looks like we have it built now so

00:24:38,559 --> 00:24:44,880
let's see what we can do with it

00:24:41,840 --> 00:24:47,919
so this is our x file i'm calling it

00:24:44,880 --> 00:24:49,360
an x-file because that uh the intra-cal

00:24:47,919 --> 00:24:50,960
compiler was called ich

00:24:49,360 --> 00:24:52,960
and yeah i'm just stealing a lot of

00:24:50,960 --> 00:24:55,360
naming stuff from them so

00:24:52,960 --> 00:24:56,159
intrical had the great innovation of the

00:24:55,360 --> 00:24:59,200
come from

00:24:56,159 --> 00:25:00,400
operation which was the uh the reverse

00:24:59,200 --> 00:25:03,679
of go to

00:25:00,400 --> 00:25:05,520
so if you recall there was a

00:25:03,679 --> 00:25:06,880
some sort of essay written called go

00:25:05,520 --> 00:25:08,640
to's considered harmful

00:25:06,880 --> 00:25:10,799
so these guys created a come from

00:25:08,640 --> 00:25:12,320
argument which it's like go to but worse

00:25:10,799 --> 00:25:14,880
because you're going in the reverse

00:25:12,320 --> 00:25:14,880
direction

00:25:15,120 --> 00:25:18,960
anyways in a nick file instead of saying

00:25:17,120 --> 00:25:22,799
from you say come from

00:25:18,960 --> 00:25:24,880
instead of a copy you have stash and etc

00:25:22,799 --> 00:25:26,159
so now that we have this and we've built

00:25:24,880 --> 00:25:29,200
our demo 4

00:25:26,159 --> 00:25:30,880
we can just use this as our new

00:25:29,200 --> 00:25:34,799
syntactical front end

00:25:30,880 --> 00:25:38,559
um so do that we'll do docker build

00:25:34,799 --> 00:25:43,200
um we'll pass it as a file

00:25:38,559 --> 00:25:46,880
our ic file yeah our egg file

00:25:43,200 --> 00:25:49,600
and then we're going to tag it ag bell

00:25:46,880 --> 00:25:49,600
demo 5.

00:25:50,799 --> 00:25:56,000
and now we've just built something using

00:25:53,600 --> 00:25:57,919
keywords that docker itself does not

00:25:56,000 --> 00:25:59,840
support right we are using a please

00:25:57,919 --> 00:26:03,840
command and a stash command

00:25:59,840 --> 00:26:06,080
and a uh come from

00:26:03,840 --> 00:26:07,279
which i think is pretty cool um and then

00:26:06,080 --> 00:26:11,840
let's run this

00:26:07,279 --> 00:26:11,840
so you docker run

00:26:14,159 --> 00:26:21,360
demo five then we start

00:26:17,600 --> 00:26:24,240
our shell and then if we

00:26:21,360 --> 00:26:24,880
look inside of our build and see custom

00:26:24,240 --> 00:26:28,320
make file

00:26:24,880 --> 00:26:31,840
builds front end there we go we built

00:26:28,320 --> 00:26:33,440
a custom front end we put that into a

00:26:31,840 --> 00:26:35,919
docker image and then we used that

00:26:33,440 --> 00:26:39,039
docker image to build things using

00:26:35,919 --> 00:26:40,640
our new syntax kind of neat so i think

00:26:39,039 --> 00:26:41,760
all this is pretty neat we started with

00:26:40,640 --> 00:26:43,440
an interesting question

00:26:41,760 --> 00:26:45,440
about how containers are actually

00:26:43,440 --> 00:26:47,840
created and now i can answer it

00:26:45,440 --> 00:26:49,840
and and now i've built my own front end

00:26:47,840 --> 00:26:51,200
and i can also create my own back ends

00:26:49,840 --> 00:26:53,279
for containerization

00:26:51,200 --> 00:26:54,880
these are just proofs of concept but you

00:26:53,279 --> 00:26:57,279
can actually do really neat things

00:26:54,880 --> 00:26:57,919
with with this ability something you

00:26:57,279 --> 00:27:00,799
could do

00:26:57,919 --> 00:27:02,559
is build your own aws lambda clone using

00:27:00,799 --> 00:27:04,000
the programmatic functionality that i

00:27:02,559 --> 00:27:05,360
showed earlier you could easily build a

00:27:04,000 --> 00:27:08,000
service that takes in

00:27:05,360 --> 00:27:09,760
a javascript function via a post request

00:27:08,000 --> 00:27:12,000
and then programmatically calls build it

00:27:09,760 --> 00:27:13,840
build kit to create a docker container

00:27:12,000 --> 00:27:16,159
uh throws that javascript in it

00:27:13,840 --> 00:27:18,240
ships it off to kubernetes that might

00:27:16,159 --> 00:27:19,919
not be that hard right

00:27:18,240 --> 00:27:22,240
proof of concept of that maybe a couple

00:27:19,919 --> 00:27:23,679
hundred lines of code

00:27:22,240 --> 00:27:25,679
another thing you could do is just build

00:27:23,679 --> 00:27:27,520
a specific image format for your org

00:27:25,679 --> 00:27:28,880
uh this one here is called mocker file

00:27:27,520 --> 00:27:30,640
created by somebody online

00:27:28,880 --> 00:27:32,399
the the creator noted that the docker

00:27:30,640 --> 00:27:34,159
files in his organization they were

00:27:32,399 --> 00:27:35,440
mainly just a list of a whole bunch of

00:27:34,159 --> 00:27:37,760
things that you needed to call

00:27:35,440 --> 00:27:39,600
apt get on and you could do them on a

00:27:37,760 --> 00:27:40,640
per line basis but that generates a

00:27:39,600 --> 00:27:42,559
layer per line

00:27:40,640 --> 00:27:44,080
so instead people just end up jamming

00:27:42,559 --> 00:27:46,320
them all onto a single line

00:27:44,080 --> 00:27:48,720
and that's kind of unideal right it's

00:27:46,320 --> 00:27:49,600
just kind of a mess so in the mocker

00:27:48,720 --> 00:27:51,360
file format

00:27:49,600 --> 00:27:52,880
which is specified in yaml you just

00:27:51,360 --> 00:27:54,080
provide a list of packages and the

00:27:52,880 --> 00:27:56,480
mocker file will

00:27:54,080 --> 00:27:57,760
send the llb to install all those into a

00:27:56,480 --> 00:27:59,360
single layer

00:27:57,760 --> 00:28:01,200
for this specific use case it's kind of

00:27:59,360 --> 00:28:03,120
the best of both worlds right you have

00:28:01,200 --> 00:28:04,480
cleaner code it's less prone to errors

00:28:03,120 --> 00:28:06,559
or duplication

00:28:04,480 --> 00:28:07,840
and uh i don't know the mocker file is

00:28:06,559 --> 00:28:09,360
specified in yaml which

00:28:07,840 --> 00:28:10,960
isn't always the best tool for the job

00:28:09,360 --> 00:28:13,200
but i think it works really nice in this

00:28:10,960 --> 00:28:13,200
case

00:28:13,679 --> 00:28:16,960
the other thing is just there's much

00:28:15,760 --> 00:28:19,440
more to learn here

00:28:16,960 --> 00:28:20,640
i know how front ends works now and we

00:28:19,440 --> 00:28:22,000
kind of showed some of that but we

00:28:20,640 --> 00:28:24,080
haven't even explored the middle

00:28:22,000 --> 00:28:25,840
and the back end there's a lot that can

00:28:24,080 --> 00:28:28,159
be done here like what could you build

00:28:25,840 --> 00:28:30,240
with this ability that's my big message

00:28:28,159 --> 00:28:32,000
like what could we create

00:28:30,240 --> 00:28:34,880
with this we won't actually know until

00:28:32,000 --> 00:28:37,200
we do when llvm was first created it was

00:28:34,880 --> 00:28:39,279
for making a c and c plus plus back end

00:28:37,200 --> 00:28:41,520
rust didn't exist swift didn't exist

00:28:39,279 --> 00:28:42,640
there was no pixel shader back ends or

00:28:41,520 --> 00:28:44,880
web assembly

00:28:42,640 --> 00:28:46,480
now we have these tools for creating uh

00:28:44,880 --> 00:28:47,360
cloud native workflows so what should we

00:28:46,480 --> 00:28:49,760
do with that

00:28:47,360 --> 00:28:51,200
i work on this project earthly and we

00:28:49,760 --> 00:28:52,559
use some of the build kit features to

00:28:51,200 --> 00:28:54,240
pretty neat effect but

00:28:52,559 --> 00:28:56,000
it's kind of a playground that's

00:28:54,240 --> 00:28:58,159
available here for anybody what

00:28:56,000 --> 00:29:00,000
what can you build on this on historical

00:28:58,159 --> 00:29:01,039
scale i think we're super early in terms

00:29:00,000 --> 00:29:03,039
of cloud computing

00:29:01,039 --> 00:29:06,159
so i want to see other people use this

00:29:03,039 --> 00:29:06,159
to build something cool

00:29:06,559 --> 00:29:10,159
and that's kind of my big message go out

00:29:08,640 --> 00:29:12,000
there and build something and and if you

00:29:10,159 --> 00:29:15,200
do let me know

00:29:12,000 --> 00:29:16,480
i'm adam gordon bell thank you so much

00:29:15,200 --> 00:29:17,679
i'll share the links to the source if

00:29:16,480 --> 00:29:19,279
you want to play around with this and

00:29:17,679 --> 00:29:21,039
yeah if you build something let me know

00:29:19,279 --> 00:29:22,799
and if you're looking for inspiration

00:29:21,039 --> 00:29:23,520
obviously check out earthly i think it's

00:29:22,799 --> 00:29:27,840
pretty cool

00:29:23,520 --> 00:29:27,840
thank you so much for watching my talk

00:29:29,020 --> 00:29:37,420
[Music]

00:29:41,520 --> 00:29:43,600

YouTube URL: https://www.youtube.com/watch?v=txEBrue-8XY


