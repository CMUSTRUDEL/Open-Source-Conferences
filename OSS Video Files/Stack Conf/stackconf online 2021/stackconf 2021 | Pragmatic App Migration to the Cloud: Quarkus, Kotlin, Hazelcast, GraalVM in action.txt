Title: stackconf 2021 | Pragmatic App Migration to the Cloud: Quarkus, Kotlin, Hazelcast, GraalVM in action
Publication date: 2021-06-24
Playlist: stackconf online 2021
Description: 
	by Nicolas Fränkel

At a point in the past, it was forecast that Java would die, but the JVM platform would be its legacy. And in fact, for a long time, the JVM has been tremendously successful. Wikipedia itself lists a bunch of languages that run on it, some of them close to Java e.g., Kotlin, some of them very remote e.g., Clojure. But nowadays, the Cloud is becoming ubiquitous. Containerization is the way to go to alleviate some of the vendor lock-in issues. Kubernetes is a de facto platform. If a container needs to be killed for whatever reason (resource consumption, unhealthy, etc.), a new one needs to replace it as fast as possible. In that context, the JVM seems to be a dead-end: its startup time is huge in comparison to a native process. Likewise, it consumes a lot of memory that just increase the monthly bill. What does that mean for us developers? Has all the time spent in learning the JVM ecosystem been invested with no hope of return over investment? Shall we need to invest even more time in new languages, frameworks, libraries, etc.? That is one possibility for sure. But we can also leverage our existing knowledge and embrace the Cloud and containers ways with the help of some tools. In this talk, I’ll create a simple URL shortener with a “standard” stack: Kotlin, JAX-RS and Hazelcast. Then, with the help of Quarkus and GraalVM, I’ll turn this application into a native executable with all Cloud/Container related work has been moved to the build process.



NETWAYS
Konferenzen: https://www.netways.de/events
Schulungen: https://www.netways.de/schulungen
Shop: https://shop.netways.de/
Blog: http://blog.netways.de/
NWS: https://nws.netways.de 

Webinare
Archiv Link: https://www.netways.de/netways/webinare/

Social Media
SlideShare: http://de.slideshare.net/netways
YouTube: https://www.netways.de/youtube
Facebook: https://www.facebook.com/netways
Twitter: https://twitter.com/netways
Instagram: https://www.instagram.com/netwaysgmbh/


Musik: https://www.frametraxx.de/
Captions: 
	00:00:05,660 --> 00:00:13,119
[Applause]

00:00:06,120 --> 00:00:13,119
[Music]

00:00:13,360 --> 00:00:16,000
hi

00:00:13,679 --> 00:00:17,359
folks thanks to be here for this talk

00:00:16,000 --> 00:00:20,480
about a pragmatic

00:00:17,359 --> 00:00:25,039
application migration to the cloud with

00:00:20,480 --> 00:00:27,519
caucus kotlin hazel cast and growl vm

00:00:25,039 --> 00:00:31,119
i'm nicola frankel i've been a former

00:00:27,519 --> 00:00:34,160
developer and other technical roles

00:00:31,119 --> 00:00:37,280
i worked in the backend

00:00:34,160 --> 00:00:40,000
fields and mainly in java with javay

00:00:37,280 --> 00:00:43,120
and spring technologies and right now

00:00:40,000 --> 00:00:45,280
i'm a developer advocate

00:00:43,120 --> 00:00:47,440
i work for a company called hazelcast

00:00:45,280 --> 00:00:50,559
has all cost has two products

00:00:47,440 --> 00:00:52,480
the first one is an in-memory data grid

00:00:50,559 --> 00:00:55,760
and you can think about an in-memory

00:00:52,480 --> 00:00:58,000
data grid as distributed data structures

00:00:55,760 --> 00:00:59,920
so you would have a cluster of nodes and

00:00:58,000 --> 00:01:02,960
you can short the data

00:00:59,920 --> 00:01:05,360
over several nodes or replicate it and

00:01:02,960 --> 00:01:10,080
the other one is that will cause jets

00:01:05,360 --> 00:01:10,080
and this is in memory stream processing

00:01:10,240 --> 00:01:17,600
today i will talk to you about

00:01:14,080 --> 00:01:21,360
the clouds so there is

00:01:17,600 --> 00:01:24,159
no denying that today everybody

00:01:21,360 --> 00:01:25,360
goes to the clouds you can think about

00:01:24,159 --> 00:01:28,720
it as a

00:01:25,360 --> 00:01:31,040
sort of gold rush and

00:01:28,720 --> 00:01:32,320
there are good reasons to migrate to the

00:01:31,040 --> 00:01:35,439
cloud and there are

00:01:32,320 --> 00:01:39,119
not so good reasons

00:01:35,439 --> 00:01:41,680
so let's talk about the good reasons

00:01:39,119 --> 00:01:42,960
the first reason why you would like to

00:01:41,680 --> 00:01:46,479
migrate to the cloud

00:01:42,960 --> 00:01:50,720
is visibility that's very

00:01:46,479 --> 00:01:53,920
important some people think

00:01:50,720 --> 00:01:56,560
mistakenly that a we will migrate to the

00:01:53,920 --> 00:01:59,840
cloud it will be less expensive

00:01:56,560 --> 00:02:03,520
well it might be the case it probably

00:01:59,840 --> 00:02:06,640
won't but the reason is not about

00:02:03,520 --> 00:02:09,759
the exact sum the fact is

00:02:06,640 --> 00:02:13,520
in traditional id you

00:02:09,759 --> 00:02:17,200
know the cost of as acquisition

00:02:13,520 --> 00:02:20,239
you might know the cost of maintenance

00:02:17,200 --> 00:02:20,640
because you have contracts but besides

00:02:20,239 --> 00:02:23,920
that

00:02:20,640 --> 00:02:27,120
you you really it's very hard to to

00:02:23,920 --> 00:02:32,879
compute exactly the cost

00:02:27,120 --> 00:02:32,879
of uh running a piece of infrastructure

00:02:33,200 --> 00:02:39,040
there are people you don't know really

00:02:36,000 --> 00:02:41,120
exactly how much time this spans

00:02:39,040 --> 00:02:42,959
there are a lot of factors that can

00:02:41,120 --> 00:02:46,239
influence it

00:02:42,959 --> 00:02:49,920
and well it's very hard

00:02:46,239 --> 00:02:52,400
to compute and before we talked about

00:02:49,920 --> 00:02:54,879
the total cost of ownership

00:02:52,400 --> 00:02:55,920
and yeah there are metrics there are

00:02:54,879 --> 00:02:59,120
like

00:02:55,920 --> 00:03:02,159
diagrams sheets whatever but

00:02:59,120 --> 00:03:06,480
still it takes a lot of effort and

00:03:02,159 --> 00:03:08,239
in the end it's a best guess

00:03:06,480 --> 00:03:10,159
now if you migrate to the cloud it's

00:03:08,239 --> 00:03:12,879
very simple because

00:03:10,159 --> 00:03:13,440
you have your build and it's broken down

00:03:12,879 --> 00:03:16,640
into

00:03:13,440 --> 00:03:19,920
yeah you use this service and you use

00:03:16,640 --> 00:03:23,519
this much memory and this much data

00:03:19,920 --> 00:03:27,440
and this much cpu and it cost you

00:03:23,519 --> 00:03:27,920
that so transparency visibility is the

00:03:27,440 --> 00:03:30,840
first

00:03:27,920 --> 00:03:32,480
argument regarding migrating to the

00:03:30,840 --> 00:03:36,400
cloud

00:03:32,480 --> 00:03:37,519
the second is flexibility in traditional

00:03:36,400 --> 00:03:40,000
i.t

00:03:37,519 --> 00:03:41,040
when you you buy your own hardware you

00:03:40,000 --> 00:03:43,519
must

00:03:41,040 --> 00:03:45,599
scale your hardware according to the

00:03:43,519 --> 00:03:48,799
maximum peak of usage

00:03:45,599 --> 00:03:51,920
so if you are an e-commerce

00:03:48,799 --> 00:03:54,400
shop you probably will buy your hardware

00:03:51,920 --> 00:03:56,879
and scale it according to black friday

00:03:54,400 --> 00:04:00,239
cyber monday this kind of stuff

00:03:56,879 --> 00:04:00,959
so very high peak and during the rest of

00:04:00,239 --> 00:04:04,720
the year

00:04:00,959 --> 00:04:07,840
the difference between uh normal loads

00:04:04,720 --> 00:04:11,360
and the peak loads is just waste

00:04:07,840 --> 00:04:13,200
you just bought that hardware for this

00:04:11,360 --> 00:04:16,880
peak the rest of the the rest

00:04:13,200 --> 00:04:19,440
the rest of the years really it's wasted

00:04:16,880 --> 00:04:20,079
so the idea is in the cloud at least you

00:04:19,440 --> 00:04:22,880
pay

00:04:20,079 --> 00:04:23,600
average when you need average and you

00:04:22,880 --> 00:04:26,560
pay

00:04:23,600 --> 00:04:28,639
like much more when you need much more

00:04:26,560 --> 00:04:32,240
so it's very flexible you can

00:04:28,639 --> 00:04:35,280
scale nearly at at will

00:04:32,240 --> 00:04:36,400
the last argument that um i i was not

00:04:35,280 --> 00:04:40,080
really um

00:04:36,400 --> 00:04:44,320
aware of that because i work mainly in

00:04:40,080 --> 00:04:47,520
like large or at least medium companies

00:04:44,320 --> 00:04:50,320
is if you are um a small team

00:04:47,520 --> 00:04:52,240
even like a single developer and you

00:04:50,320 --> 00:04:55,600
want to develop a product

00:04:52,240 --> 00:04:59,360
and well you will need to acquire

00:04:55,600 --> 00:04:59,759
underwear and again that this is a big

00:04:59,360 --> 00:05:02,000
step

00:04:59,759 --> 00:05:03,360
at the beginning when you have nothing

00:05:02,000 --> 00:05:04,560
when you just want to create your

00:05:03,360 --> 00:05:08,160
business

00:05:04,560 --> 00:05:09,680
so the cloud allows anybody to virtually

00:05:08,160 --> 00:05:12,720
start

00:05:09,680 --> 00:05:15,039
and they have wonderful ideas they have

00:05:12,720 --> 00:05:18,479
the skills to implement them

00:05:15,039 --> 00:05:22,400
that they can start their journey like

00:05:18,479 --> 00:05:22,400
on day one nearly on day one

00:05:22,880 --> 00:05:27,360
as i mentioned those are good reasons

00:05:25,680 --> 00:05:30,479
not so good reasons

00:05:27,360 --> 00:05:32,080
well do like everybody else this is the

00:05:30,479 --> 00:05:35,759
worst reason of all

00:05:32,080 --> 00:05:37,919
and again let me reinstate it

00:05:35,759 --> 00:05:39,520
like if you think you you're migrating

00:05:37,919 --> 00:05:42,560
to the cloud you will

00:05:39,520 --> 00:05:44,880
like gain money or at least

00:05:42,560 --> 00:05:46,800
a waste less money that's probably a

00:05:44,880 --> 00:05:52,080
very wrong assumption

00:05:46,800 --> 00:05:56,080
and please be aware of that

00:05:52,080 --> 00:05:59,360
now imagine you already have

00:05:56,080 --> 00:06:01,680
software how do you migrate how do you

00:05:59,360 --> 00:06:04,800
take this software that was

00:06:01,680 --> 00:06:07,199
made for the old words for on-site

00:06:04,800 --> 00:06:10,720
hardware to the clouds

00:06:07,199 --> 00:06:13,600
well there are three main paths

00:06:10,720 --> 00:06:15,440
the first is you check it and you move

00:06:13,600 --> 00:06:18,560
it to the cloud that's called

00:06:15,440 --> 00:06:20,400
lift and shift and the second is

00:06:18,560 --> 00:06:21,840
hey it's no good let's rewrite

00:06:20,400 --> 00:06:25,680
everything

00:06:21,840 --> 00:06:27,919
and the third in which i would

00:06:25,680 --> 00:06:29,039
propose you advise you at least that's

00:06:27,919 --> 00:06:32,000
the

00:06:29,039 --> 00:06:34,240
the gist of this talk is to to walk the

00:06:32,000 --> 00:06:37,600
middle part that is between

00:06:34,240 --> 00:06:39,120
the two so let's first talk about the

00:06:37,600 --> 00:06:42,639
lift and shift

00:06:39,120 --> 00:06:44,880
uh lift and shift is very easy i mean

00:06:42,639 --> 00:06:46,160
the cloud is just somebody else's

00:06:44,880 --> 00:06:49,039
computer

00:06:46,160 --> 00:06:50,639
so you just say oh instead of deploying

00:06:49,039 --> 00:06:53,599
inside

00:06:50,639 --> 00:06:54,479
my on my site on my hardware i will

00:06:53,599 --> 00:06:57,520
deploy it

00:06:54,479 --> 00:07:01,039
on another's hardware

00:06:57,520 --> 00:07:02,800
and it's like most of the times it's

00:07:01,039 --> 00:07:05,919
relatively easy

00:07:02,800 --> 00:07:07,840
because then every cloud provider they

00:07:05,919 --> 00:07:10,880
provide some way to run

00:07:07,840 --> 00:07:14,000
containers so you just

00:07:10,880 --> 00:07:15,440
containerize your application and you

00:07:14,000 --> 00:07:19,039
deploy it

00:07:15,440 --> 00:07:22,400
and actually it has a high chances of

00:07:19,039 --> 00:07:25,319
like working as expected you will be

00:07:22,400 --> 00:07:28,639
able to deploy it

00:07:25,319 --> 00:07:31,840
unfortunately it might

00:07:28,639 --> 00:07:35,840
not be so good in the like

00:07:31,840 --> 00:07:38,319
middle term worst case

00:07:35,840 --> 00:07:39,199
it won't run at all it will be deployed

00:07:38,319 --> 00:07:42,000
but it won't run

00:07:39,199 --> 00:07:42,800
at all because hey your application it

00:07:42,000 --> 00:07:45,840
expected

00:07:42,800 --> 00:07:49,360
some hardcoded parties or

00:07:45,840 --> 00:07:52,479
some some local resource

00:07:49,360 --> 00:07:56,319
that is not available or available

00:07:52,479 --> 00:07:58,720
for another interface in the cloud

00:07:56,319 --> 00:08:00,560
best case it will run because you

00:07:58,720 --> 00:08:03,840
thought about everything

00:08:00,560 --> 00:08:05,599
but your application was not designed to

00:08:03,840 --> 00:08:08,960
run on the cloud so

00:08:05,599 --> 00:08:12,160
wasting some cpu cycles

00:08:08,960 --> 00:08:15,199
wasting some memory that was not so

00:08:12,160 --> 00:08:16,960
important when you run on premise

00:08:15,199 --> 00:08:18,479
now when you run in the clouds

00:08:16,960 --> 00:08:22,240
everything counts

00:08:18,479 --> 00:08:24,639
so this wastes it it might cost you a

00:08:22,240 --> 00:08:24,639
lot

00:08:24,840 --> 00:08:29,120
actually

00:08:26,720 --> 00:08:31,039
and perhaps you have already stumbled

00:08:29,120 --> 00:08:34,159
upon those 12 factor

00:08:31,039 --> 00:08:37,200
app sheets and it's

00:08:34,159 --> 00:08:40,399
a lists 12

00:08:37,200 --> 00:08:41,680
principle that cloud native applications

00:08:40,399 --> 00:08:45,040
must follow

00:08:41,680 --> 00:08:49,200
i i won't go through all of them uh

00:08:45,040 --> 00:08:53,120
here there are for a as a reminder

00:08:49,200 --> 00:08:57,040
but i have been a java developer

00:08:53,120 --> 00:09:00,720
and let's like check what a standard

00:08:57,040 --> 00:09:04,160
gvm web application whether it's it's

00:09:00,720 --> 00:09:06,720
compliant with those principle

00:09:04,160 --> 00:09:07,519
well the second factor says hey you

00:09:06,720 --> 00:09:09,519
should declare

00:09:07,519 --> 00:09:13,279
all your dependency your application

00:09:09,519 --> 00:09:16,240
should declare all its dependency

00:09:13,279 --> 00:09:19,120
okay now if we have a regular jvm web

00:09:16,240 --> 00:09:23,279
application it's probably a war

00:09:19,120 --> 00:09:27,440
and you expect it to be deployed

00:09:23,279 --> 00:09:30,560
on an application server or at least a

00:09:27,440 --> 00:09:34,000
gsp servlet container but you don't

00:09:30,560 --> 00:09:34,000
declare any dependency

00:09:34,240 --> 00:09:40,959
okay so remove this

00:09:37,360 --> 00:09:44,160
issue and say now we we know

00:09:40,959 --> 00:09:47,440
how to run self-executable jar the

00:09:44,160 --> 00:09:50,320
the the jar the embeds the uh

00:09:47,440 --> 00:09:51,839
servlet container itself so they embed

00:09:50,320 --> 00:09:55,640
the tomcat

00:09:51,839 --> 00:09:58,160
and well now it's completely

00:09:55,640 --> 00:09:59,519
self-isolated i don't need to declare

00:09:58,160 --> 00:10:01,360
any dependency everything is

00:09:59,519 --> 00:10:04,399
self-contained

00:10:01,360 --> 00:10:07,440
and again it's wrong like the chiven

00:10:04,399 --> 00:10:10,800
is is a huge dependency and

00:10:07,440 --> 00:10:13,839
the jar expects a given

00:10:10,800 --> 00:10:16,160
with a minimal version and it's not

00:10:13,839 --> 00:10:19,440
declared

00:10:16,160 --> 00:10:23,200
that's one principle uh

00:10:19,440 --> 00:10:25,440
we don't follow the second one is

00:10:23,200 --> 00:10:29,120
configuration your application

00:10:25,440 --> 00:10:32,640
must be easily configurable um

00:10:29,120 --> 00:10:36,079
but with traditional

00:10:32,640 --> 00:10:40,399
wars that's completely untrue

00:10:36,079 --> 00:10:42,959
what we learned is that we are using

00:10:40,399 --> 00:10:44,160
an abstraction for example let's say a

00:10:42,959 --> 00:10:47,519
data source

00:10:44,160 --> 00:10:51,279
that is available through a virtual

00:10:47,519 --> 00:10:55,040
url and then we map this url

00:10:51,279 --> 00:10:57,680
to another real url and this is done in

00:10:55,040 --> 00:10:58,240
every environment so you you keep your

00:10:57,680 --> 00:11:00,399
war

00:10:58,240 --> 00:11:02,160
the same you promote the artifact which

00:11:00,399 --> 00:11:04,560
is good

00:11:02,160 --> 00:11:06,880
and and then the configuration is done

00:11:04,560 --> 00:11:10,079
on every application server in

00:11:06,880 --> 00:11:15,120
every environment

00:11:10,079 --> 00:11:18,240
that defeats the the third principle

00:11:15,120 --> 00:11:21,760
principle number 9 we must

00:11:18,240 --> 00:11:24,399
start up fast the reason for that

00:11:21,760 --> 00:11:25,600
is that hey let's imagine we are running

00:11:24,399 --> 00:11:28,320
on kubernetes

00:11:25,600 --> 00:11:28,720
and kubernetes is super great because

00:11:28,320 --> 00:11:32,000
when

00:11:28,720 --> 00:11:33,279
a part starts misbehaving well you just

00:11:32,000 --> 00:11:36,480
kill the parts

00:11:33,279 --> 00:11:39,760
and you start a new one but

00:11:36,480 --> 00:11:43,040
if you start a new one you assume that

00:11:39,760 --> 00:11:46,240
this new one will start fast enough

00:11:43,040 --> 00:11:46,880
and guess what the gvm was not made for

00:11:46,240 --> 00:11:51,200
that

00:11:46,880 --> 00:11:53,440
the gvm actually starts quite slowly and

00:11:51,200 --> 00:11:54,560
when it has started at the beginning

00:11:53,440 --> 00:11:57,279
it's

00:11:54,560 --> 00:11:57,839
slow it has bad performances it needs

00:11:57,279 --> 00:12:01,600
some

00:11:57,839 --> 00:12:03,680
warmer time so another principle that is

00:12:01,600 --> 00:12:06,800
defeated

00:12:03,680 --> 00:12:08,560
finally logging we must have streaming

00:12:06,800 --> 00:12:11,360
logs

00:12:08,560 --> 00:12:11,839
and in containers the streaming logs is

00:12:11,360 --> 00:12:14,560
a

00:12:11,839 --> 00:12:16,480
we we just write everything in the

00:12:14,560 --> 00:12:19,519
console

00:12:16,480 --> 00:12:22,240
but um again

00:12:19,519 --> 00:12:22,880
satellite containers not so great

00:12:22,240 --> 00:12:26,160
because

00:12:22,880 --> 00:12:28,480
your application will write in a file

00:12:26,160 --> 00:12:29,680
and the subject container will write in

00:12:28,480 --> 00:12:31,360
another file or

00:12:29,680 --> 00:12:33,200
in multiple files perhaps your

00:12:31,360 --> 00:12:34,240
application also write in different

00:12:33,200 --> 00:12:38,880
files

00:12:34,240 --> 00:12:41,600
and if if it's containerized well

00:12:38,880 --> 00:12:42,480
how do we handle that there is no single

00:12:41,600 --> 00:12:46,160
stream

00:12:42,480 --> 00:12:46,160
of log that we can follow

00:12:48,639 --> 00:12:53,519
now we've got even more issues because

00:12:51,519 --> 00:12:56,560
now it's not only about

00:12:53,519 --> 00:12:59,040
just uh the given but it's about the

00:12:56,560 --> 00:13:00,800
frameworks that we are using spring jabi

00:12:59,040 --> 00:13:04,160
whatever

00:13:00,800 --> 00:13:07,200
they use a lot of reflection and again

00:13:04,160 --> 00:13:10,160
it's a startup performance hits

00:13:07,200 --> 00:13:11,760
because at the beginning it will start

00:13:10,160 --> 00:13:15,920
to load the classes

00:13:11,760 --> 00:13:18,880
and yeah through reflection not grades

00:13:15,920 --> 00:13:19,440
and if we are talking explicitly again

00:13:18,880 --> 00:13:22,639
uh

00:13:19,440 --> 00:13:24,480
about spring and javay they will do some

00:13:22,639 --> 00:13:27,040
class past counting

00:13:24,480 --> 00:13:29,440
so they will like check through all the

00:13:27,040 --> 00:13:34,160
class bars to say hey

00:13:29,440 --> 00:13:35,839
which class has this annotation not

00:13:34,160 --> 00:13:38,639
great

00:13:35,839 --> 00:13:39,680
so it seems like the gvm is not made for

00:13:38,639 --> 00:13:42,639
the cloud

00:13:39,680 --> 00:13:44,160
so the id in that case hey we will

00:13:42,639 --> 00:13:47,519
regret the application

00:13:44,160 --> 00:13:48,000
and as engineers we love to start from

00:13:47,519 --> 00:13:50,480
scratch

00:13:48,000 --> 00:13:51,760
we love greenfield projects we we don't

00:13:50,480 --> 00:13:54,399
want to handle

00:13:51,760 --> 00:13:56,399
the mess that was made by previous

00:13:54,399 --> 00:13:57,519
developers even if those previous

00:13:56,399 --> 00:14:01,199
developers were

00:13:57,519 --> 00:14:03,440
where us um but there are a couple of

00:14:01,199 --> 00:14:04,800
issues uh if you want to rewrite the

00:14:03,440 --> 00:14:08,399
application

00:14:04,800 --> 00:14:10,639
the first is obviously the costs and

00:14:08,399 --> 00:14:11,519
if you want to rewrite the application

00:14:10,639 --> 00:14:15,360
you must have

00:14:11,519 --> 00:14:18,560
like a non-trivial budget so you will

00:14:15,360 --> 00:14:18,959
go to your manager manager will at some

00:14:18,560 --> 00:14:22,560
point

00:14:18,959 --> 00:14:26,079
go to the business and

00:14:22,560 --> 00:14:29,279
it will probably go like that hey i need

00:14:26,079 --> 00:14:30,800
x million what for to rewrite the

00:14:29,279 --> 00:14:34,560
application

00:14:30,800 --> 00:14:34,880
and what competitive advantage does it

00:14:34,560 --> 00:14:38,240
bring

00:14:34,880 --> 00:14:38,880
us what age do we have on the market

00:14:38,240 --> 00:14:42,639
with that

00:14:38,880 --> 00:14:46,000
right nothing it will be like

00:14:42,639 --> 00:14:49,360
a rewrite feature for future

00:14:46,000 --> 00:14:51,279
so you can probably imagine what will be

00:14:49,360 --> 00:14:55,680
the outcome of this

00:14:51,279 --> 00:14:59,120
conversation but imagine for a second

00:14:55,680 --> 00:15:00,720
that yeah you're the business understand

00:14:59,120 --> 00:15:04,000
the cloud

00:15:00,720 --> 00:15:04,800
i mean you already have like the biggest

00:15:04,000 --> 00:15:07,199
advantage

00:15:04,800 --> 00:15:10,160
on the markets you have no competitors

00:15:07,199 --> 00:15:10,160
everything is fine

00:15:10,839 --> 00:15:18,240
let's go a bit into the details

00:15:15,199 --> 00:15:21,680
when you start rewriting the application

00:15:18,240 --> 00:15:24,079
let's imagine you starts in january

00:15:21,680 --> 00:15:24,959
well it will take some time it will take

00:15:24,079 --> 00:15:27,680
months

00:15:24,959 --> 00:15:28,639
until you have written the application

00:15:27,680 --> 00:15:31,199
and so

00:15:28,639 --> 00:15:32,560
the the target that you are chasing the

00:15:31,199 --> 00:15:35,199
version that was done

00:15:32,560 --> 00:15:37,839
in january now is not the same anymore

00:15:35,199 --> 00:15:41,120
because the legacy version of the app

00:15:37,839 --> 00:15:44,399
probably had upgrades because

00:15:41,120 --> 00:15:47,759
the legacy version the business

00:15:44,399 --> 00:15:47,759
wants to add more features

00:15:47,839 --> 00:15:52,160
so you will be actually be like

00:15:50,639 --> 00:15:57,040
developing toward

00:15:52,160 --> 00:15:59,680
running targets which is never good

00:15:57,040 --> 00:16:01,279
of course there are risks involved i

00:15:59,680 --> 00:16:04,160
mean

00:16:01,279 --> 00:16:04,639
legacy projects there might be legacy

00:16:04,160 --> 00:16:07,680
but

00:16:04,639 --> 00:16:08,000
at least most of the bugs have already

00:16:07,680 --> 00:16:11,120
been

00:16:08,000 --> 00:16:14,720
solved because people are

00:16:11,120 --> 00:16:17,360
have already included them earlier on

00:16:14,720 --> 00:16:17,920
with a greenfield project there will be

00:16:17,360 --> 00:16:20,480
bugs

00:16:17,920 --> 00:16:21,199
for sure even with the best quality

00:16:20,480 --> 00:16:24,320
process

00:16:21,199 --> 00:16:26,240
and with the biggest test harness in the

00:16:24,320 --> 00:16:29,680
world

00:16:26,240 --> 00:16:32,560
so not great and finally

00:16:29,680 --> 00:16:33,279
if you are a team lead if you are a

00:16:32,560 --> 00:16:35,120
manager

00:16:33,279 --> 00:16:37,759
you must think how you will organize

00:16:35,120 --> 00:16:40,160
your teams

00:16:37,759 --> 00:16:42,320
rewrite means that we will need

00:16:40,160 --> 00:16:43,759
additional workforce so either we

00:16:42,320 --> 00:16:48,079
recruit

00:16:43,759 --> 00:16:51,680
temporarily or we outsource but

00:16:48,079 --> 00:16:55,519
in both cases we need additional people

00:16:51,680 --> 00:16:58,800
and the usual way to do that is

00:16:55,519 --> 00:17:01,519
those new people they will like

00:16:58,800 --> 00:17:02,800
maintain and handle the change on the

00:17:01,519 --> 00:17:05,600
legacy application

00:17:02,800 --> 00:17:08,480
while your own workforce will work on

00:17:05,600 --> 00:17:08,480
the new version

00:17:08,799 --> 00:17:15,839
but there is a high chance that since

00:17:13,199 --> 00:17:18,079
the new people they don't know the

00:17:15,839 --> 00:17:19,919
application that well they will probably

00:17:18,079 --> 00:17:23,360
need support

00:17:19,919 --> 00:17:25,679
from the people who know the application

00:17:23,360 --> 00:17:27,919
so there will be a lot of interactions

00:17:25,679 --> 00:17:32,320
of interruptions

00:17:27,919 --> 00:17:35,039
and it won't be super great

00:17:32,320 --> 00:17:36,720
so those are four reasons why rewriting

00:17:35,039 --> 00:17:41,520
the application

00:17:36,720 --> 00:17:44,000
might not be such a good idea so if

00:17:41,520 --> 00:17:46,160
lift and shift is not a good idea if

00:17:44,000 --> 00:17:47,200
rewriting the application is not a good

00:17:46,160 --> 00:17:51,520
idea

00:17:47,200 --> 00:17:54,960
we don't have that much choice

00:17:51,520 --> 00:17:58,080
we probably have a middle path

00:17:54,960 --> 00:18:01,440
and the middle path is actually to

00:17:58,080 --> 00:18:03,360
reuse the existing codes especially the

00:18:01,440 --> 00:18:07,039
annotations from spring

00:18:03,360 --> 00:18:10,320
and javay and whatever but change

00:18:07,039 --> 00:18:14,160
the way they are used so the engine that

00:18:10,320 --> 00:18:17,919
uses them is not the traditional

00:18:14,160 --> 00:18:20,880
engine and

00:18:17,919 --> 00:18:24,240
before i go further let me like

00:18:20,880 --> 00:18:26,480
introduce you about growl vm

00:18:24,240 --> 00:18:28,000
grow vm is actually a bag of many

00:18:26,480 --> 00:18:30,480
features

00:18:28,000 --> 00:18:31,440
here are a couple of them so first grab

00:18:30,480 --> 00:18:34,720
vm as

00:18:31,440 --> 00:18:37,760
a gvm platform so instead of using

00:18:34,720 --> 00:18:42,080
oracle gdk or open gdk

00:18:37,760 --> 00:18:45,120
or whatever you are using growl vm gdk

00:18:42,080 --> 00:18:46,480
okay that's fine the other thing that

00:18:45,120 --> 00:18:50,880
growl vm brings us

00:18:46,480 --> 00:18:54,559
is it it's polyglot so it can speak

00:18:50,880 --> 00:18:57,039
multiple languages you can

00:18:54,559 --> 00:18:58,480
use multiple languages in your

00:18:57,039 --> 00:19:01,200
application so that

00:18:58,480 --> 00:19:02,320
for example you can have a java

00:19:01,200 --> 00:19:04,960
application but

00:19:02,320 --> 00:19:05,919
at some point you need to use r because

00:19:04,960 --> 00:19:09,360
you need to do some

00:19:05,919 --> 00:19:10,320
statistics well it's very easy to

00:19:09,360 --> 00:19:15,520
integrate this

00:19:10,320 --> 00:19:18,640
or file into into your java application

00:19:15,520 --> 00:19:22,080
at least group vm makes it easy

00:19:18,640 --> 00:19:26,160
the reason for that is that there is

00:19:22,080 --> 00:19:28,960
an underlying framework called truffle

00:19:26,160 --> 00:19:30,240
which all those languages have been

00:19:28,960 --> 00:19:34,799
implemented with so

00:19:30,240 --> 00:19:34,799
there is for example truffle robbie

00:19:34,880 --> 00:19:38,080
and this allows you for example to

00:19:37,679 --> 00:19:41,200
create

00:19:38,080 --> 00:19:42,880
your own language as well or

00:19:41,200 --> 00:19:45,120
at least an implementation of the

00:19:42,880 --> 00:19:46,960
language using truffle for easier

00:19:45,120 --> 00:19:50,000
integration

00:19:46,960 --> 00:19:52,799
but what is of interest into this

00:19:50,000 --> 00:19:56,160
migration to the cloud is another

00:19:52,799 --> 00:19:59,520
feature of girl vm called substrate vm

00:19:56,160 --> 00:20:02,640
and this allows you to create

00:19:59,520 --> 00:20:03,440
native executable from existing

00:20:02,640 --> 00:20:06,480
bytecodes

00:20:03,440 --> 00:20:09,360
whether jars or classes

00:20:06,480 --> 00:20:10,640
through an ahead of time compilation

00:20:09,360 --> 00:20:15,679
process

00:20:10,640 --> 00:20:18,400
of course it has some limitations

00:20:15,679 --> 00:20:19,600
for example i was talking about

00:20:18,400 --> 00:20:22,640
reflection

00:20:19,600 --> 00:20:25,840
so reflection is the ability

00:20:22,640 --> 00:20:28,880
to say hey i don't know which

00:20:25,840 --> 00:20:33,039
classes will be used at compile time

00:20:28,880 --> 00:20:38,000
i will discover it at runtime and

00:20:33,039 --> 00:20:41,039
it it's really a great feature of java

00:20:38,000 --> 00:20:43,840
but that means that you need to follow

00:20:41,039 --> 00:20:47,120
the execution path

00:20:43,840 --> 00:20:48,159
and if you do some build time

00:20:47,120 --> 00:20:50,640
compilation

00:20:48,159 --> 00:20:51,679
whereas the class is available at

00:20:50,640 --> 00:20:53,360
runtime

00:20:51,679 --> 00:20:55,280
you understand there is a problem

00:20:53,360 --> 00:20:57,520
because at build time the class won't be

00:20:55,280 --> 00:20:57,520
there

00:20:58,880 --> 00:21:03,120
fortunately there are ways to cope with

00:21:01,679 --> 00:21:05,600
that you can provide

00:21:03,120 --> 00:21:07,200
a configuration file to say hey you need

00:21:05,600 --> 00:21:09,679
to keep this fine and this file

00:21:07,200 --> 00:21:10,240
well there are ways to cope with that

00:21:09,679 --> 00:21:14,320
it's

00:21:10,240 --> 00:21:18,400
not fun but it works other limitation

00:21:14,320 --> 00:21:20,720
includes the lack of uh security manager

00:21:18,400 --> 00:21:21,520
uh it's not cross-platform so if you

00:21:20,720 --> 00:21:24,559
want

00:21:21,520 --> 00:21:27,520
uh to have an executable for let's say

00:21:24,559 --> 00:21:31,120
mac os you need to begin on mac os

00:21:27,520 --> 00:21:33,440
and for uh like windows you need one for

00:21:31,120 --> 00:21:37,440
windows and so on and so forth

00:21:33,440 --> 00:21:37,440
but at least it's something

00:21:38,159 --> 00:21:45,280
so let's have a small recap

00:21:42,240 --> 00:21:46,799
on one side we have the given and on the

00:21:45,280 --> 00:21:50,159
other side we have

00:21:46,799 --> 00:21:53,440
native executables gvm

00:21:50,159 --> 00:21:57,840
american memory consumption is high

00:21:53,440 --> 00:22:01,520
native executable not so high

00:21:57,840 --> 00:22:03,840
starter time is long and even more so

00:22:01,520 --> 00:22:04,559
considering that the performance at the

00:22:03,840 --> 00:22:08,559
beginning

00:22:04,559 --> 00:22:12,720
is not great and that if you don't care

00:22:08,559 --> 00:22:16,320
it's quite fast on the opposite

00:22:12,720 --> 00:22:19,840
uh the gvm you can write your program

00:22:16,320 --> 00:22:20,960
once and run it everywhere there is a gm

00:22:19,840 --> 00:22:23,120
for that

00:22:20,960 --> 00:22:24,559
which native executable obviously you

00:22:23,120 --> 00:22:27,840
cannot do

00:22:24,559 --> 00:22:28,400
and also there is a reason why the gvm

00:22:27,840 --> 00:22:31,679
has

00:22:28,400 --> 00:22:35,120
had always had very good performances

00:22:31,679 --> 00:22:39,200
past this warm-up time is that it can

00:22:35,120 --> 00:22:42,960
adapt uh the the the native codes

00:22:39,200 --> 00:22:46,000
that it compiles to the workload so

00:22:42,960 --> 00:22:48,000
that during this warm-up time it will

00:22:46,000 --> 00:22:51,440
analyze the workload and

00:22:48,000 --> 00:22:53,919
it it will create the

00:22:51,440 --> 00:22:56,240
best native code that is possible

00:22:53,919 --> 00:22:59,520
regarding this workloads

00:22:56,240 --> 00:23:01,960
and for this reason the gvm was

00:22:59,520 --> 00:23:03,440
always at least on par with native

00:23:01,960 --> 00:23:06,240
executables

00:23:03,440 --> 00:23:07,679
or c and c plus plus programs in the

00:23:06,240 --> 00:23:10,880
past

00:23:07,679 --> 00:23:15,200
the native executable is

00:23:10,880 --> 00:23:18,240
statically compiled so you must

00:23:15,200 --> 00:23:20,080
at build time know about the the

00:23:18,240 --> 00:23:22,159
workload to

00:23:20,080 --> 00:23:25,440
use the best parameters for the

00:23:22,159 --> 00:23:25,440
compilation possible

00:23:26,880 --> 00:23:32,960
but in the clouds those are pretty

00:23:30,080 --> 00:23:34,240
good advantages and the benefits of the

00:23:32,960 --> 00:23:37,440
gbm are not so

00:23:34,240 --> 00:23:40,559
huge and so there there is now

00:23:37,440 --> 00:23:41,840
a a generation of cloud native

00:23:40,559 --> 00:23:45,279
frameworks such as

00:23:41,840 --> 00:23:45,919
micronaut or caucus i don't know much

00:23:45,279 --> 00:23:49,279
about

00:23:45,919 --> 00:23:53,279
lidon but it seems to be part of the lot

00:23:49,279 --> 00:23:56,559
and there is spring there because though

00:23:53,279 --> 00:23:58,240
spring is was not designed

00:23:56,559 --> 00:24:00,559
in the cloud native way because when it

00:23:58,240 --> 00:24:03,600
was designed there was no clouds

00:24:00,559 --> 00:24:04,080
um now there are ways to leverage crawl

00:24:03,600 --> 00:24:07,679
vm

00:24:04,080 --> 00:24:08,880
for spring but i i won't talk about

00:24:07,679 --> 00:24:12,720
spring in the session

00:24:08,880 --> 00:24:13,440
more and all those frameworks they

00:24:12,720 --> 00:24:15,600
basically

00:24:13,440 --> 00:24:16,880
have the same approach they all use

00:24:15,600 --> 00:24:18,480
graudian

00:24:16,880 --> 00:24:20,000
so in the end you have a native

00:24:18,480 --> 00:24:22,960
executable

00:24:20,000 --> 00:24:23,360
and they handle reflection in another

00:24:22,960 --> 00:24:26,799
way

00:24:23,360 --> 00:24:32,799
for example um micro node happens

00:24:26,799 --> 00:24:36,159
to like create dedicated class at

00:24:32,799 --> 00:24:41,120
build time at compile time

00:24:36,159 --> 00:24:41,120
and sq the traditional reflection

00:24:42,320 --> 00:24:48,159
so now let's have a use case imagine i

00:24:45,919 --> 00:24:50,720
want to have a url shortener

00:24:48,159 --> 00:24:52,000
and the traditional approach is hey you

00:24:50,720 --> 00:24:55,440
have this space of

00:24:52,000 --> 00:24:56,480
all urls and you have the sure like a

00:24:55,440 --> 00:25:00,720
small space

00:24:56,480 --> 00:25:03,120
of all possible short-term urls and

00:25:00,720 --> 00:25:05,840
you need to have a rejection and you

00:25:03,120 --> 00:25:08,960
need to handle the collisions

00:25:05,840 --> 00:25:09,520
great i'm not a mathematician so i

00:25:08,960 --> 00:25:13,120
prefer

00:25:09,520 --> 00:25:16,320
to use an alternative is

00:25:13,120 --> 00:25:18,000
hey i will generate random short links

00:25:16,320 --> 00:25:21,279
for a url

00:25:18,000 --> 00:25:23,440
and then i will store the mapping

00:25:21,279 --> 00:25:26,720
between the long url and the short one

00:25:23,440 --> 00:25:28,000
and also the opposite from the short url

00:25:26,720 --> 00:25:31,200
to the long one

00:25:28,000 --> 00:25:34,480
so the trade-off is instead of cpu time

00:25:31,200 --> 00:25:34,480
i will trade storage

00:25:36,480 --> 00:25:40,320
for the demo i will use the following

00:25:38,400 --> 00:25:43,520
stack i will have a java

00:25:40,320 --> 00:25:44,880
legacy java e application or now it's

00:25:43,520 --> 00:25:47,360
called joycord or e

00:25:44,880 --> 00:25:48,880
but my application is java e because

00:25:47,360 --> 00:25:51,279
it's legacy i

00:25:48,880 --> 00:25:52,640
still use kotlin to write it but it's

00:25:51,279 --> 00:25:55,360
not necessary

00:25:52,640 --> 00:25:56,559
any gbm language will do java whatever

00:25:55,360 --> 00:25:59,760
it's cover

00:25:56,559 --> 00:26:02,960
and i will be using jax rs because

00:25:59,760 --> 00:26:04,960
yeah dude it uses annotations

00:26:02,960 --> 00:26:08,320
and i will be storing the data in

00:26:04,960 --> 00:26:08,320
hazelcoast mdg

00:26:08,559 --> 00:26:16,799
so my initial state is the following

00:26:13,440 --> 00:26:20,960
i have the gvm that runs

00:26:16,799 --> 00:26:25,200
the tomcat that runs my war

00:26:20,960 --> 00:26:28,440
and when i have a request coming in

00:26:25,200 --> 00:26:31,360
tomcat does its magic probably it uses

00:26:28,440 --> 00:26:32,480
catalina.jar that realize itself on

00:26:31,360 --> 00:26:35,919
servlet.jar

00:26:32,480 --> 00:26:39,679
and jaxarrest.jar and it knows

00:26:35,919 --> 00:26:43,039
which servlet it needs to call

00:26:39,679 --> 00:26:46,240
so it's called the servlet

00:26:43,039 --> 00:26:48,559
and the servlet itself uh well

00:26:46,240 --> 00:26:50,240
wants to store or to read data from

00:26:48,559 --> 00:26:54,480
hazelcast and you choose

00:26:50,240 --> 00:26:58,480
a dedicated jar has al-qaska in the jar

00:26:54,480 --> 00:27:00,960
that's the initial states

00:26:58,480 --> 00:27:02,159
now i want to migrate to cloud native

00:27:00,960 --> 00:27:05,200
and i will use

00:27:02,159 --> 00:27:05,200
let's say quarkus

00:27:05,360 --> 00:27:09,360
so the 2b state in development i will

00:27:08,000 --> 00:27:13,120
still keep the gvm

00:27:09,360 --> 00:27:16,640
because the gvm has a nice features like

00:27:13,120 --> 00:27:20,000
you can debug you can set breakpoints

00:27:16,640 --> 00:27:23,360
well this kind of stuff we like it

00:27:20,000 --> 00:27:26,640
and in development it's not an issue

00:27:23,360 --> 00:27:30,159
so we still have the gvm but

00:27:26,640 --> 00:27:33,200
instead of having

00:27:30,159 --> 00:27:35,679
the tomcats

00:27:33,200 --> 00:27:37,039
we just replace everything with quarks

00:27:35,679 --> 00:27:41,120
so they are

00:27:37,039 --> 00:27:44,080
the same like the same capabilities

00:27:41,120 --> 00:27:46,559
but implemented by quakers so there is

00:27:44,080 --> 00:27:47,679
no catalina dot jar there is a quark of

00:27:46,559 --> 00:27:50,480
something

00:27:47,679 --> 00:27:51,039
and there is a caucus as a course client

00:27:50,480 --> 00:27:54,399
but

00:27:51,039 --> 00:27:56,000
in the same way when a a new http

00:27:54,399 --> 00:27:59,520
request comes in

00:27:56,000 --> 00:28:04,240
then caucus will redirect the request to

00:27:59,520 --> 00:28:07,440
our servlet but the best stuff

00:28:04,240 --> 00:28:09,039
happens when you want to deploy in a

00:28:07,440 --> 00:28:12,480
container

00:28:09,039 --> 00:28:13,440
like now we have the same mechanism

00:28:12,480 --> 00:28:15,679
underneath

00:28:13,440 --> 00:28:17,200
i mean i infer it's the same mechanism

00:28:15,679 --> 00:28:20,880
at least it works the same

00:28:17,200 --> 00:28:25,360
but now we have a single single process

00:28:20,880 --> 00:28:25,360
and it's a native binary

00:28:26,880 --> 00:28:33,840
i've talked a lot now it's time

00:28:30,480 --> 00:28:37,200
for some demo

00:28:33,840 --> 00:28:38,720
so this is the projects um and i must

00:28:37,200 --> 00:28:42,080
admit i cheated a bit

00:28:38,720 --> 00:28:45,919
i didn't start from

00:28:42,080 --> 00:28:48,240
a legacy application i directly created

00:28:45,919 --> 00:28:51,360
the projects

00:28:48,240 --> 00:28:54,799
using the caucus maven

00:28:51,360 --> 00:28:57,600
goals so that everything has been

00:28:54,799 --> 00:28:58,159
read for me and because yeah you need to

00:28:57,600 --> 00:29:01,279
write

00:28:58,159 --> 00:29:03,440
couple of properties and there are

00:29:01,279 --> 00:29:06,080
dependency and plugins

00:29:03,440 --> 00:29:08,720
um but you can achieve the same of

00:29:06,080 --> 00:29:12,159
course it will be more time consuming

00:29:08,720 --> 00:29:15,360
to do the same uh yourself by hand

00:29:12,159 --> 00:29:18,720
but anyway um

00:29:15,360 --> 00:29:21,360
this is just to uh to win uh

00:29:18,720 --> 00:29:23,600
some time and here you can see

00:29:21,360 --> 00:29:26,720
everything has been configured

00:29:23,600 --> 00:29:30,080
i mean i can already use it

00:29:26,720 --> 00:29:33,360
right now and i have this

00:29:30,080 --> 00:29:36,480
rest api and so you can see

00:29:33,360 --> 00:29:38,960
jack's rs annotations here

00:29:36,480 --> 00:29:39,679
and you can see this is cocaine as well

00:29:38,960 --> 00:29:42,159
and here

00:29:39,679 --> 00:29:43,039
more jax arrests so here i will respond

00:29:42,159 --> 00:29:46,320
to post

00:29:43,039 --> 00:29:48,640
here i have path and here

00:29:46,320 --> 00:29:50,080
i have the produces to tell what it

00:29:48,640 --> 00:29:53,520
returns

00:29:50,080 --> 00:29:56,480
um i don't want to delve too much

00:29:53,520 --> 00:29:58,240
into the code but just as it is now i

00:29:56,480 --> 00:30:00,720
can start a hazelcast

00:29:58,240 --> 00:30:00,720
instance

00:30:03,279 --> 00:30:10,240
and i can start the application as well

00:30:07,200 --> 00:30:12,720
and here developments i'm running inside

00:30:10,240 --> 00:30:12,720
the gvm

00:30:16,640 --> 00:30:26,559
so it will compile and

00:30:21,200 --> 00:30:26,559
after a few seconds it will

00:30:26,640 --> 00:30:29,600
run the application

00:30:35,200 --> 00:30:40,240
so it builds the application and

00:30:40,559 --> 00:30:51,520
it runs it yeah it takes a bit of time

00:30:43,919 --> 00:30:54,799
my machine needs to wake up as well

00:30:51,520 --> 00:30:56,240
so i will prepare the curl hey it has

00:30:54,799 --> 00:30:59,279
started

00:30:56,240 --> 00:31:02,799
so i want to store a new url

00:30:59,279 --> 00:31:06,480
let's say this one fubor i will

00:31:02,799 --> 00:31:06,480
just have the terminal

00:31:10,880 --> 00:31:15,679
so it has contacted azelcast it has

00:31:13,440 --> 00:31:20,480
stored this into azul cost and i want

00:31:15,679 --> 00:31:23,039
now to do the opposites i want to get

00:31:20,480 --> 00:31:25,440
the long url from the short one so i

00:31:23,039 --> 00:31:27,760
will just curl this one

00:31:25,440 --> 00:31:29,200
and it returns before so everything

00:31:27,760 --> 00:31:33,120
works as expected

00:31:29,200 --> 00:31:37,279
as expected i'm super happy

00:31:33,120 --> 00:31:40,399
now the idea is i want to build that

00:31:37,279 --> 00:31:43,440
for the clouds and

00:31:40,399 --> 00:31:46,559
when i scaffold these

00:31:43,440 --> 00:31:49,679
projects um

00:31:46,559 --> 00:31:50,240
created two docker files for me one is

00:31:49,679 --> 00:31:54,159
about

00:31:50,240 --> 00:31:58,640
a docker native and one is about

00:31:54,159 --> 00:32:01,679
docker gvm so here is the docker native

00:31:58,640 --> 00:32:03,360
as you can see it's pretty easy you just

00:32:01,679 --> 00:32:06,399
need to follow the instructions

00:32:03,360 --> 00:32:09,600
and the end package so here it takes

00:32:06,399 --> 00:32:12,720
a long long time this is actually where

00:32:09,600 --> 00:32:13,279
the magic happens and if we can if we

00:32:12,720 --> 00:32:16,640
can

00:32:13,279 --> 00:32:21,120
have a look at the size

00:32:16,640 --> 00:32:21,120
of those files torque

00:32:22,480 --> 00:32:25,519
tor get

00:32:25,840 --> 00:32:33,760
here you can see that it's a

00:32:28,960 --> 00:32:37,360
bit big and once it has been done

00:32:33,760 --> 00:32:40,640
you can build

00:32:37,360 --> 00:32:44,480
the docker image with

00:32:40,640 --> 00:32:47,919
this i mean you you you don't

00:32:44,480 --> 00:32:51,039
you won't do it explicitly and

00:32:47,919 --> 00:32:54,960
it will do it for you but this is like

00:32:51,039 --> 00:32:57,679
very very very fast here

00:32:54,960 --> 00:33:00,399
and once this is done i've created a

00:32:57,679 --> 00:33:02,559
docker compose file

00:33:00,399 --> 00:33:04,080
docker compose file is very easy it has

00:33:02,559 --> 00:33:07,760
one hazel cast node

00:33:04,080 --> 00:33:11,440
and our application and now if i

00:33:07,760 --> 00:33:14,960
i i docker composites darker

00:33:11,440 --> 00:33:16,399
compose app i will be using this new

00:33:14,960 --> 00:33:20,399
experimental feature

00:33:16,399 --> 00:33:20,399
because i like to try new stuff

00:33:20,799 --> 00:33:27,760
so now it's on

00:33:24,000 --> 00:33:31,279
and i can again try to do some curl

00:33:27,760 --> 00:33:35,840
so i will curl to create

00:33:31,279 --> 00:33:35,840
a new shortened url

00:33:36,240 --> 00:33:39,840
and now

00:33:41,519 --> 00:33:44,799
since it's randomly generated it's a new

00:33:43,840 --> 00:33:48,000
one

00:33:44,799 --> 00:33:49,279
and now i can curl to check that

00:33:48,000 --> 00:33:53,039
everything works

00:33:49,279 --> 00:33:57,519
and now this is only

00:33:53,039 --> 00:34:00,320
a native executable that runs underneath

00:33:57,519 --> 00:34:07,039
and as you can see it's it's a seamless

00:34:00,320 --> 00:34:10,480
experience it's the same experience

00:34:07,039 --> 00:34:13,839
the demo is done and now we

00:34:10,480 --> 00:34:17,280
need to do some recap so

00:34:13,839 --> 00:34:20,159
my advice would be hey like between

00:34:17,280 --> 00:34:21,200
rewriting everything and between lift

00:34:20,159 --> 00:34:23,919
and shift

00:34:21,200 --> 00:34:25,040
just walk the middle path when possible

00:34:23,919 --> 00:34:28,399
reuse

00:34:25,040 --> 00:34:31,040
your existing code you you it took

00:34:28,399 --> 00:34:33,679
you a lot of time to write it to

00:34:31,040 --> 00:34:36,960
maintain it to test it

00:34:33,679 --> 00:34:40,320
reuse it as much as possible but

00:34:36,960 --> 00:34:41,839
leverage different frameworks cloud

00:34:40,320 --> 00:34:45,679
native frameworks

00:34:41,839 --> 00:34:47,040
that know how to mess to make the best

00:34:45,679 --> 00:34:51,599
usage of it

00:34:47,040 --> 00:34:53,679
and think about return over investment

00:34:51,599 --> 00:34:56,000
thanks for your attention you can read

00:34:53,679 --> 00:34:58,720
my blog you can follow me on twitter

00:34:56,000 --> 00:35:00,880
you can read more about the caucus and

00:34:58,720 --> 00:35:03,359
hazelcost integration

00:35:00,880 --> 00:35:05,760
more interestingly you can also check

00:35:03,359 --> 00:35:06,320
the git repository so the demo that i've

00:35:05,760 --> 00:35:09,599
showed you

00:35:06,320 --> 00:35:12,160
is publicly available and if

00:35:09,599 --> 00:35:12,720
you got uh interested in handling cost

00:35:12,160 --> 00:35:16,400
please

00:35:12,720 --> 00:35:31,839
join our slack thanks a lot

00:35:16,400 --> 00:35:31,839
and have a good day

00:35:32,160 --> 00:35:34,240

YouTube URL: https://www.youtube.com/watch?v=zaFtbAKCzDo


