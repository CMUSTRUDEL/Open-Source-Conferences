Title: stackconf 2021 | Automatic Microservices Observability with Programming Language: Ballerina
Publication date: 2021-06-24
Playlist: stackconf online 2021
Description: 
	by Anjana Fernando

Modern applications are increasingly becoming more of a distributed computing problem. With the availability of feature rich cloud services, our solutions are increasingly relying on these in implementing functionality. Also, the application itself is adopting more of a disaggregated architecture in favour of extensibility, scalability, re-usability, and deployment flexibility. This is how microservices architectures are becoming popular every day. But there is no free lunch; with the benefits, there are new challenges that are introduced. Compared to monoliths, with microservices we need to handle the complexities that come with networked architectures, such as communication latency, unreliable connections, protocols, data formats, and transactions. So, while we come up with many new techniques to tackle these problems, it is vital for us to have a proper observability functionality to verify the behaviour. The Ballerina programming, which is designed from ground-up to work with networked applications, takes in a unique approach by having built-in observability functionality in language constructs. It exploits the language awareness for network operations, such as service types, remote function invocations, communication resiliency mechanisms, to automatically observe the operations done by the users. Basically, the Ballerina platform takes care of the majority observability situations automatically, so the developer can only focus on the core business logic, and not sprinkle your code with lots of observability code. In this session, we will look at these features on how this built-in functionality will be used for metrics generation and distributed tracing using the Ballerina platform.


NETWAYS
Konferenzen: https://www.netways.de/events
Schulungen: https://www.netways.de/schulungen
Shop: https://shop.netways.de/
Blog: http://blog.netways.de/
NWS: https://nws.netways.de 

Webinare
Archiv Link: https://www.netways.de/netways/webinare/

Social Media
SlideShare: http://de.slideshare.net/netways
YouTube: https://www.netways.de/youtube
Facebook: https://www.facebook.com/netways
Twitter: https://twitter.com/netways
Instagram: https://www.instagram.com/netwaysgmbh/


Musik: https://www.frametraxx.de/
Captions: 
	00:00:05,660 --> 00:00:13,119
[Applause]

00:00:06,120 --> 00:00:13,119
[Music]

00:00:14,000 --> 00:00:17,760
hi everyone welcome

00:00:15,679 --> 00:00:20,000
uh in this session we are going to talk

00:00:17,760 --> 00:00:21,520
about automatic microservice observable

00:00:20,000 --> 00:00:24,400
with ballerina

00:00:21,520 --> 00:00:25,680
uh so first of all i'll give a small

00:00:24,400 --> 00:00:29,279
introduction on to what

00:00:25,680 --> 00:00:31,599
marina is so ballerina is a

00:00:29,279 --> 00:00:33,440
programming language uh geared towards

00:00:31,599 --> 00:00:35,680
cloud native development

00:00:33,440 --> 00:00:36,719
and in this session i am going to

00:00:35,680 --> 00:00:40,000
concentrate

00:00:36,719 --> 00:00:42,640
uh primarily on the observability

00:00:40,000 --> 00:00:45,840
support we have in the language itself

00:00:42,640 --> 00:00:46,559
and how uh automatic microservices

00:00:45,840 --> 00:00:49,360
observable

00:00:46,559 --> 00:00:50,879
can be achieved uh using the language

00:00:49,360 --> 00:00:53,840
features

00:00:50,879 --> 00:00:54,800
so if we take a look at the agenda today

00:00:53,840 --> 00:00:57,199
um

00:00:54,800 --> 00:00:59,440
i'll be like first starting off with a

00:00:57,199 --> 00:01:02,879
simple hello world program to show

00:00:59,440 --> 00:01:05,040
how everything looks looks and feel

00:01:02,879 --> 00:01:06,159
and then i'm going to give a small

00:01:05,040 --> 00:01:09,680
introduction to

00:01:06,159 --> 00:01:13,200
biona services and then the

00:01:09,680 --> 00:01:14,960
main content will be based on a specific

00:01:13,200 --> 00:01:16,560
specific integration scenario i'm going

00:01:14,960 --> 00:01:19,600
to work on uh

00:01:16,560 --> 00:01:22,720
there i'm going to get a specific

00:01:19,600 --> 00:01:25,680
uh services integration scenario

00:01:22,720 --> 00:01:28,159
and show how observability mainly

00:01:25,680 --> 00:01:30,240
automated observability is applied there

00:01:28,159 --> 00:01:31,920
and how it works with metrics

00:01:30,240 --> 00:01:33,840
distributed tracing

00:01:31,920 --> 00:01:35,280
and also how different communication

00:01:33,840 --> 00:01:39,360
protocols

00:01:35,280 --> 00:01:42,720
uh interact and

00:01:39,360 --> 00:01:46,560
allow these observability uh features

00:01:42,720 --> 00:01:49,759
uh to be implemented and uh used

00:01:46,560 --> 00:01:52,320
and in the end i'm also going to uh

00:01:49,759 --> 00:01:53,040
show how these features can be indicated

00:01:52,320 --> 00:01:57,040
with

00:01:53,040 --> 00:01:59,119
uh with a cloud solution also on

00:01:57,040 --> 00:02:00,240
processing and visualizing the

00:01:59,119 --> 00:02:04,399
observability

00:02:00,240 --> 00:02:04,399
uh information

00:02:05,200 --> 00:02:12,640
so i'll be basically going some services

00:02:09,599 --> 00:02:13,280
and these different solutions that you

00:02:12,640 --> 00:02:18,080
can

00:02:13,280 --> 00:02:18,080
use to bring all of these together

00:02:19,200 --> 00:02:24,560
so let's start off with the hello world

00:02:22,319 --> 00:02:27,920
program

00:02:24,560 --> 00:02:32,080
so for this i'll quickly jump over to

00:02:27,920 --> 00:02:34,879
vs code so we have a vs code

00:02:32,080 --> 00:02:36,000
barona plugin which you can go to the

00:02:34,879 --> 00:02:39,680
marketplace and

00:02:36,000 --> 00:02:41,920
install uh also for the latest version

00:02:39,680 --> 00:02:44,000
um the current development version you

00:02:41,920 --> 00:02:45,040
can also go to the banana.io website and

00:02:44,000 --> 00:02:48,480
download

00:02:45,040 --> 00:02:50,160
the v6 file as well so here i have

00:02:48,480 --> 00:02:53,519
already installed

00:02:50,160 --> 00:02:53,519
uh the

00:02:53,599 --> 00:03:01,920
the plugin and so let me create a

00:02:58,159 --> 00:03:06,400
new project so i'm going to say

00:03:01,920 --> 00:03:09,920
bell new hello

00:03:06,400 --> 00:03:14,239
so here a new package is created

00:03:09,920 --> 00:03:16,959
and with uh

00:03:14,239 --> 00:03:17,360
with some sample source code as well so

00:03:16,959 --> 00:03:19,680
here

00:03:17,360 --> 00:03:21,200
i'm not just going to do a normal hello

00:03:19,680 --> 00:03:22,319
world but rather i'm going to create a

00:03:21,200 --> 00:03:25,120
service

00:03:22,319 --> 00:03:26,560
which does a hello world so let's see

00:03:25,120 --> 00:03:29,760
how

00:03:26,560 --> 00:03:33,440
we can do that so

00:03:29,760 --> 00:03:36,560
here we say service http

00:03:33,440 --> 00:03:38,879
uh like a quartz zipper template

00:03:36,560 --> 00:03:39,920
and you can fill in the information

00:03:38,879 --> 00:03:41,680
there

00:03:39,920 --> 00:03:43,040
so in bali now we have a service

00:03:41,680 --> 00:03:46,159
construct

00:03:43,040 --> 00:03:48,239
that you can directly use and

00:03:46,159 --> 00:03:49,840
so here we are we have created an http

00:03:48,239 --> 00:03:52,400
service and

00:03:49,840 --> 00:03:53,760
inside that we can define resources so

00:03:52,400 --> 00:03:58,720
i'm just going to say

00:03:53,760 --> 00:04:03,599
creating we don't need this

00:03:58,720 --> 00:04:03,599
and it'll return a string

00:04:06,319 --> 00:04:09,840
so that's it for the service

00:04:11,599 --> 00:04:17,280
let's try to basically run this

00:04:24,880 --> 00:04:29,600
so when you say battle run it'll uh

00:04:27,600 --> 00:04:33,040
build the existing package

00:04:29,600 --> 00:04:34,639
uh and uh compile it and write it into

00:04:33,040 --> 00:04:37,759
choosing the same command

00:04:34,639 --> 00:04:41,280
so our program is up

00:04:37,759 --> 00:04:45,120
then let's just do a

00:04:41,280 --> 00:04:49,520
curl uh against our service

00:04:45,120 --> 00:04:52,000
so it's add for 8080 and our context is

00:04:49,520 --> 00:04:52,000
creating

00:04:53,280 --> 00:04:58,160
so we see we got the hello world back

00:04:58,240 --> 00:05:05,039
so that's the basic uh

00:05:01,680 --> 00:05:05,039
basic hello world program

00:05:06,639 --> 00:05:13,360
also i'll quickly explain

00:05:10,160 --> 00:05:16,639
more on how a banner service is

00:05:13,360 --> 00:05:18,479
made up uh base

00:05:16,639 --> 00:05:20,000
so as i mentioned in bahrain we have a

00:05:18,479 --> 00:05:23,120
service construct

00:05:20,000 --> 00:05:25,759
that's a first-class

00:05:23,120 --> 00:05:26,560
concept in the language so the service

00:05:25,759 --> 00:05:28,960
construct

00:05:26,560 --> 00:05:29,759
uh the type of service is dependent on

00:05:28,960 --> 00:05:33,680
the

00:05:29,759 --> 00:05:36,240
the listener you attach it to or you

00:05:33,680 --> 00:05:37,520
basically bind it to so here for example

00:05:36,240 --> 00:05:40,000
if my service

00:05:37,520 --> 00:05:40,960
binds to an http listener it becomes an

00:05:40,000 --> 00:05:45,039
http service

00:05:40,960 --> 00:05:49,280
then it service the resource

00:05:45,039 --> 00:05:51,840
the formats and its

00:05:49,280 --> 00:05:54,960
other behavior depend like depends on

00:05:51,840 --> 00:05:54,960
the http services

00:05:56,639 --> 00:06:00,800
way of doing things so here when it's

00:05:59,360 --> 00:06:03,120
bound to an http

00:06:00,800 --> 00:06:06,000
listener in http service we can have

00:06:03,120 --> 00:06:09,280
these resource functions

00:06:06,000 --> 00:06:12,560
and also in different types of

00:06:09,280 --> 00:06:14,720
services for example in grpc we have

00:06:12,560 --> 00:06:19,039
other remote functions as well

00:06:14,720 --> 00:06:20,800
so to have gr like rpc style

00:06:19,039 --> 00:06:22,880
functions so here it's a resource

00:06:20,800 --> 00:06:26,400
basically basically

00:06:22,880 --> 00:06:29,520
maps to uh

00:06:26,400 --> 00:06:30,319
http resources so the difference between

00:06:29,520 --> 00:06:33,440
remote

00:06:30,319 --> 00:06:36,479
and resource function is like uh uh it's

00:06:33,440 --> 00:06:36,479
like a noun and verb

00:06:36,560 --> 00:06:41,039
relationship so in a resource you say

00:06:38,880 --> 00:06:43,600
give a noun saying okay

00:06:41,039 --> 00:06:44,400
i i'm going to access this in a remote

00:06:43,600 --> 00:06:48,160
function you are

00:06:44,400 --> 00:06:49,599
doing something a verb like uh back in

00:06:48,160 --> 00:06:52,319
grpc

00:06:49,599 --> 00:06:53,039
like let's say add numbers or something

00:06:52,319 --> 00:06:56,160
like that

00:06:53,039 --> 00:06:57,599
uh so depend uh depend depending on

00:06:56,160 --> 00:06:59,520
those types so we have these two

00:06:57,599 --> 00:07:02,240
different types of functions

00:06:59,520 --> 00:07:04,639
and that's controlled by the type of

00:07:02,240 --> 00:07:09,120
services you have have as well

00:07:04,639 --> 00:07:12,479
so here so the services service has a

00:07:09,120 --> 00:07:14,240
service name so in the http scenario it

00:07:12,479 --> 00:07:17,599
maps to the base path

00:07:14,240 --> 00:07:19,759
and uh also we have uh

00:07:17,599 --> 00:07:21,120
in the resource function we have a

00:07:19,759 --> 00:07:23,440
resource accessor

00:07:21,120 --> 00:07:24,240
and the resource name uh resource

00:07:23,440 --> 00:07:26,880
accessor

00:07:24,240 --> 00:07:27,759
again like the approach to the method

00:07:26,880 --> 00:07:30,160
you access the

00:07:27,759 --> 00:07:31,199
resource so these directly mapped to the

00:07:30,160 --> 00:07:35,120
http

00:07:31,199 --> 00:07:37,599
uh method that you like to

00:07:35,120 --> 00:07:38,479
access the resource so here it can have

00:07:37,599 --> 00:07:43,120
get post

00:07:38,479 --> 00:07:43,120
and so on any any type you want

00:07:43,199 --> 00:07:46,400
and the resource name so resource name

00:07:45,120 --> 00:07:50,400
also by default

00:07:46,400 --> 00:07:53,039
it maps to the uh resource context

00:07:50,400 --> 00:07:53,919
so it can be updated to have other

00:07:53,039 --> 00:07:57,280
resource level

00:07:53,919 --> 00:07:59,120
uh parameters and uh

00:07:57,280 --> 00:08:00,400
also with the resource function

00:07:59,120 --> 00:08:02,479
parameters you can define query

00:08:00,400 --> 00:08:04,080
parameters and so on as well

00:08:02,479 --> 00:08:06,240
and also there are features to do data

00:08:04,080 --> 00:08:09,360
binding uh as well

00:08:06,240 --> 00:08:12,319
by getting a structure type and

00:08:09,360 --> 00:08:14,240
binding it to the input body and so on

00:08:12,319 --> 00:08:16,879
so all of those can be defined in a

00:08:14,240 --> 00:08:20,720
parallel service

00:08:16,879 --> 00:08:23,919
so that's the basic

00:08:20,720 --> 00:08:26,000
basic overview of a banner service let's

00:08:23,919 --> 00:08:27,199
get back to our earlier hello world

00:08:26,000 --> 00:08:30,639
program

00:08:27,199 --> 00:08:33,039
so after we have a service now

00:08:30,639 --> 00:08:35,039
back to our main topic on observability

00:08:33,039 --> 00:08:38,719
okay how do we

00:08:35,039 --> 00:08:41,919
observe this so uh

00:08:38,719 --> 00:08:45,040
one thing you can do uh in

00:08:41,919 --> 00:08:45,680
in bernard's basically you can say to

00:08:45,040 --> 00:08:48,240
this

00:08:45,680 --> 00:08:49,920
burner package uh to enable

00:08:48,240 --> 00:08:54,720
observability globally

00:08:49,920 --> 00:08:57,839
so you can create

00:08:54,720 --> 00:08:57,839
a file called

00:09:06,839 --> 00:09:14,480
config.tml

00:09:09,600 --> 00:09:16,640
and say observable is enabled

00:09:14,480 --> 00:09:16,640
so

00:09:17,839 --> 00:09:21,519
say that and you also have to put this

00:09:20,800 --> 00:09:26,880
in pause

00:09:21,519 --> 00:09:26,880
at this moment so with this

00:09:27,040 --> 00:09:37,839
now if i run our

00:09:30,800 --> 00:09:37,839
service again

00:09:38,640 --> 00:09:45,200
you can see uh we got uh like more

00:09:41,760 --> 00:09:48,720
logs printed here uh specifically it

00:09:45,200 --> 00:09:51,360
starts up an endpoint

00:09:48,720 --> 00:09:51,760
for for prometheus servers to connect uh

00:09:51,360 --> 00:09:54,959
here

00:09:51,760 --> 00:09:58,320
like it uh exposes the uh the

00:09:54,959 --> 00:10:01,519
the metrics uh from this endpoint

00:09:58,320 --> 00:10:03,760
so uh probability server can pull uh

00:10:01,519 --> 00:10:06,480
data out of here and also it's

00:10:03,760 --> 00:10:09,040
publishing traces to a

00:10:06,480 --> 00:10:10,959
jaeger by default so it's using open

00:10:09,040 --> 00:10:14,000
telemetry protocol

00:10:10,959 --> 00:10:17,839
and so using these two

00:10:14,000 --> 00:10:18,480
we can get all the information that's

00:10:17,839 --> 00:10:22,079
there

00:10:18,480 --> 00:10:23,600
in our service so by default

00:10:22,079 --> 00:10:25,440
uh it tracks all the resource

00:10:23,600 --> 00:10:27,600
invocations and all

00:10:25,440 --> 00:10:28,959
other client invocations uh that are

00:10:27,600 --> 00:10:31,200
done like uh

00:10:28,959 --> 00:10:32,640
maybe an http client another different

00:10:31,200 --> 00:10:35,680
kind of connector

00:10:32,640 --> 00:10:39,120
and so on um these are all tracked

00:10:35,680 --> 00:10:42,959
uh in the banana runtime um

00:10:39,120 --> 00:10:46,800
so let me demonstrate how

00:10:42,959 --> 00:10:49,680
uh how this is this basically

00:10:46,800 --> 00:10:50,800
works so for this i'm going to start up

00:10:49,680 --> 00:10:54,560
a prometheus

00:10:50,800 --> 00:10:56,160
uh server and also jaeger

00:10:54,560 --> 00:10:57,920
and graphan as well for the

00:10:56,160 --> 00:11:00,720
visualization

00:10:57,920 --> 00:11:03,680
so here i'm going to just use docker to

00:11:00,720 --> 00:11:03,680
start up this service

00:11:06,000 --> 00:11:09,680
so first promote your server

00:11:12,839 --> 00:11:18,240
graphana and

00:11:15,440 --> 00:11:18,240
the jaeger

00:11:21,600 --> 00:11:32,160
okay now we have this up and running

00:11:26,720 --> 00:11:32,160
so let me just send some sample requests

00:11:34,880 --> 00:11:38,800
let's go to grafana and configure

00:11:40,560 --> 00:11:43,839
the data sources and

00:11:46,399 --> 00:11:57,839
the dashboards so let's first add the

00:11:49,040 --> 00:11:57,839
prometheus data source

00:12:01,120 --> 00:12:07,279
okay then

00:12:04,959 --> 00:12:10,320
we'll add the dashboard as well so

00:12:07,279 --> 00:12:14,160
there's a default baron dashboard that's

00:12:10,320 --> 00:12:16,000
there in the in graphing.com so it's

00:12:14,160 --> 00:12:19,279
already published

00:12:16,000 --> 00:12:19,279
so we just have to load it

00:12:22,639 --> 00:12:26,000
select the parameters data source we

00:12:24,160 --> 00:12:28,399
created earlier

00:12:26,000 --> 00:12:29,760
and that's it so we can see here the

00:12:28,399 --> 00:12:33,279
earlier request that was sent

00:12:29,760 --> 00:12:37,440
it's already there and in this dashboard

00:12:33,279 --> 00:12:39,839
all the the default uh

00:12:37,440 --> 00:12:39,839
information

00:12:41,120 --> 00:12:46,000
is there so

00:12:44,160 --> 00:12:47,360
like http service metrics client

00:12:46,000 --> 00:12:49,440
information

00:12:47,360 --> 00:12:50,480
uh failure rates and all this

00:12:49,440 --> 00:12:53,839
information are there

00:12:50,480 --> 00:13:07,839
and also some database access

00:12:53,839 --> 00:13:07,839
matrix are available here as well

00:13:17,519 --> 00:13:21,440
you can see the sets updating when the

00:13:19,680 --> 00:13:24,480
requests are sent

00:13:21,440 --> 00:13:25,200
so this is basically uh by tracking all

00:13:24,480 --> 00:13:27,760
the

00:13:25,200 --> 00:13:28,880
service interactions and it's visualized

00:13:27,760 --> 00:13:32,079
here

00:13:28,880 --> 00:13:32,639
uh so this is for the matrix uh part now

00:13:32,079 --> 00:13:36,320
let's

00:13:32,639 --> 00:13:39,920
uh check the the tracing aspects as well

00:13:36,320 --> 00:13:42,880
so for this we'll go to jager

00:13:39,920 --> 00:13:45,600
in jaka so we can basically select the

00:13:42,880 --> 00:13:49,839
service so the name is our base context

00:13:45,600 --> 00:13:52,880
here and if you find you can see here

00:13:49,839 --> 00:13:55,199
we have a single span

00:13:52,880 --> 00:13:56,720
uh which has information about our

00:13:55,199 --> 00:13:58,800
request

00:13:56,720 --> 00:14:00,079
on the greeting request and the

00:13:58,800 --> 00:14:03,120
information on that is

00:14:00,079 --> 00:14:04,160
there the durations and all that

00:14:03,120 --> 00:14:07,600
information

00:14:04,160 --> 00:14:09,600
so you can also add your custom tags and

00:14:07,600 --> 00:14:11,199
so on uh if you want to enrich these

00:14:09,600 --> 00:14:14,720
messages in the code

00:14:11,199 --> 00:14:16,560
um uh let me quickly

00:14:14,720 --> 00:14:17,839
show how that is done as well so these

00:14:16,560 --> 00:14:21,600
are all

00:14:17,839 --> 00:14:24,240
done uh by default so let's say

00:14:21,600 --> 00:14:26,079
you want to additionally observe and

00:14:24,240 --> 00:14:31,839
like a function you have

00:14:26,079 --> 00:14:31,839
so let's say we write a new function

00:14:42,839 --> 00:14:48,639
so

00:14:45,120 --> 00:14:51,519
call these so here i'm going to add some

00:14:48,639 --> 00:14:51,519
path parameters

00:14:54,800 --> 00:14:59,839
and i'm going to return it directly

00:15:07,920 --> 00:15:14,480
so i can say observe

00:15:12,240 --> 00:15:16,399
observer then this function invocation

00:15:14,480 --> 00:15:19,199
will also be observed

00:15:16,399 --> 00:15:19,199
and also i can

00:15:20,000 --> 00:15:22,639
do some

00:15:23,839 --> 00:15:29,040
further enrichment through the

00:15:25,920 --> 00:15:34,240
information as i mentioned earlier

00:15:29,040 --> 00:15:34,240
like attacks to spends so i can say

00:15:35,920 --> 00:15:41,839
a value is

00:15:47,759 --> 00:15:55,839
so add to the current span itself

00:16:09,120 --> 00:16:13,759
so there's a possibility that it can

00:16:10,959 --> 00:16:13,759
return an error

00:16:16,560 --> 00:16:23,839
let's do some handling as well

00:16:19,680 --> 00:16:23,839
so let's get the result also

00:16:52,480 --> 00:17:05,839
okay now let's run this one and see

00:17:12,720 --> 00:17:16,839
okay that's right now we change our

00:17:15,520 --> 00:17:20,160
context

00:17:16,839 --> 00:17:20,160
proc so

00:17:20,640 --> 00:17:25,039
you can see we got the response

00:17:29,600 --> 00:17:34,240
now let's go and check our tracing

00:17:32,240 --> 00:17:37,120
information

00:17:34,240 --> 00:17:39,039
so same service let's do some tracing

00:17:37,120 --> 00:17:42,320
now we can see we have

00:17:39,039 --> 00:17:45,200
two spans and because from

00:17:42,320 --> 00:17:47,039
uh our proc resource function we also

00:17:45,200 --> 00:17:50,799
have the add function

00:17:47,039 --> 00:17:53,280
and here we have the tags a b

00:17:50,799 --> 00:17:53,840
and the result as well so likewise we

00:17:53,280 --> 00:17:56,160
can easily

00:17:53,840 --> 00:17:57,280
render those information as well but

00:17:56,160 --> 00:18:02,559
these other information

00:17:57,280 --> 00:18:02,559
we get automatically and

00:18:09,039 --> 00:18:15,280
yeah let's go to our uh

00:18:12,480 --> 00:18:16,000
main scenario now our main use case uh

00:18:15,280 --> 00:18:18,720
so it's a

00:18:16,000 --> 00:18:20,240
it's an integration scenario which uh

00:18:18,720 --> 00:18:21,600
integrates with multiple uh remote

00:18:20,240 --> 00:18:24,960
services in the internet

00:18:21,600 --> 00:18:26,000
and it's basically a geolocation process

00:18:24,960 --> 00:18:29,840
a geocoding

00:18:26,000 --> 00:18:30,799
uh scenario where a request is sent by

00:18:29,840 --> 00:18:34,400
an user

00:18:30,799 --> 00:18:35,120
uh and um it accesses a geolocation api

00:18:34,400 --> 00:18:37,600
to

00:18:35,120 --> 00:18:39,039
figure out the coordinates uh let's do

00:18:37,600 --> 00:18:42,480
that electric longitude

00:18:39,039 --> 00:18:43,600
of the user uh by looking at the request

00:18:42,480 --> 00:18:47,120
ip

00:18:43,600 --> 00:18:51,120
and uh after it returns the coordinates

00:18:47,120 --> 00:18:53,120
uh the the the service uh doesn't again

00:18:51,120 --> 00:18:55,200
another uh request to the geocoding

00:18:53,120 --> 00:18:58,640
service uh to get an address

00:18:55,200 --> 00:19:01,760
uh at the service section approximate

00:18:58,640 --> 00:19:02,799
address of course and returns that uh to

00:19:01,760 --> 00:19:06,000
the user

00:19:02,799 --> 00:19:06,480
so we'll uh see how this interaction is

00:19:06,000 --> 00:19:08,720
tracked

00:19:06,480 --> 00:19:10,480
how the default uh like the automatic

00:19:08,720 --> 00:19:12,240
observer attracts this and what kind of

00:19:10,480 --> 00:19:14,240
information we get out of it

00:19:12,240 --> 00:19:16,320
and we'll actually be doing this in

00:19:14,240 --> 00:19:18,960
multiple

00:19:16,320 --> 00:19:19,679
approaches uh so first we'll be doing a

00:19:18,960 --> 00:19:22,400
direct

00:19:19,679 --> 00:19:24,480
invocations of these services then we'll

00:19:22,400 --> 00:19:27,600
add another intermediate service to do

00:19:24,480 --> 00:19:29,440
uh request caching uh like

00:19:27,600 --> 00:19:30,770
sorry response caching from the first

00:19:29,440 --> 00:19:32,000
service uh

00:19:30,770 --> 00:19:36,160
[Music]

00:19:32,000 --> 00:19:38,559
actually from the geocoding service um

00:19:36,160 --> 00:19:40,400
and we'll again also see some database

00:19:38,559 --> 00:19:43,120
operations as well by

00:19:40,400 --> 00:19:44,240
caching these in a database uh so we'll

00:19:43,120 --> 00:19:47,440
see how the database

00:19:44,240 --> 00:19:52,000
uh observability features are also

00:19:47,440 --> 00:19:55,360
uh working and also we'll um

00:19:52,000 --> 00:19:58,559
we'll be using uh uh like http

00:19:55,360 --> 00:20:00,720
and also we'll end up with uh showing

00:19:58,559 --> 00:20:01,600
uh other protocols as well like web

00:20:00,720 --> 00:20:05,679
sockets

00:20:01,600 --> 00:20:10,080
uh usage uh

00:20:05,679 --> 00:20:13,039
so let's start with the uh scenario

00:20:10,080 --> 00:20:13,039
uh so the first

00:20:13,679 --> 00:20:19,440
uh service is uh the location that was

00:20:16,799 --> 00:20:22,960
http1

00:20:19,440 --> 00:20:26,400
so here i'll go through the code

00:20:22,960 --> 00:20:27,600
the code is already available so here so

00:20:26,400 --> 00:20:30,960
i'll just explain

00:20:27,600 --> 00:20:33,440
uh what's done by that so

00:20:30,960 --> 00:20:35,840
again this just uses two services from

00:20:33,440 --> 00:20:38,960
google

00:20:35,840 --> 00:20:42,640
first is a geolocation one

00:20:38,960 --> 00:20:46,000
as shown here in the link and

00:20:42,640 --> 00:20:49,039
what we do is we basically first of all

00:20:46,000 --> 00:20:49,760
read in a api key as an environment

00:20:49,039 --> 00:20:52,000
variable

00:20:49,760 --> 00:20:54,640
and populate that and create a json

00:20:52,000 --> 00:20:58,320
payload saying consider the ip

00:20:54,640 --> 00:21:02,240
and do a post request to this

00:20:58,320 --> 00:21:04,880
url and we get from that we get the

00:21:02,240 --> 00:21:06,080
coordinates that we longitude and we do

00:21:04,880 --> 00:21:10,000
another call

00:21:06,080 --> 00:21:13,760
to the geocode api to get the address

00:21:10,000 --> 00:21:17,039
so the address information is encoded

00:21:13,760 --> 00:21:19,600
uh in a rather sizable json uh

00:21:17,039 --> 00:21:21,200
message so we had to process that

00:21:19,600 --> 00:21:24,080
message to get the actual

00:21:21,200 --> 00:21:26,080
address information we need so i'll

00:21:24,080 --> 00:21:31,840
quickly show an example of

00:21:26,080 --> 00:21:31,840
that content so

00:21:35,679 --> 00:21:41,360
so this is a sample response like that

00:21:39,840 --> 00:21:43,440
so here there are multiple address

00:21:41,360 --> 00:21:44,320
components and multiple entries we want

00:21:43,440 --> 00:21:47,360
to actually look

00:21:44,320 --> 00:21:50,000
for the information that's there in this

00:21:47,360 --> 00:21:51,520
location type geometric center that's

00:21:50,000 --> 00:21:54,559
the ideal one we want to get

00:21:51,520 --> 00:21:56,480
so we have to look through all these

00:21:54,559 --> 00:21:58,880
entries here and get the address that

00:21:56,480 --> 00:21:59,600
that's in the geometric center so if you

00:21:58,880 --> 00:22:02,559
want to do this

00:21:59,600 --> 00:22:03,440
uh in code only it's a bit of a tedious

00:22:02,559 --> 00:22:08,559
task

00:22:03,440 --> 00:22:08,559
so here in barona we are using a

00:22:08,799 --> 00:22:12,080
language level query feature uh which is

00:22:11,200 --> 00:22:14,880
like an sql

00:22:12,080 --> 00:22:15,520
like uh dialect that is used to query

00:22:14,880 --> 00:22:17,440
the

00:22:15,520 --> 00:22:20,000
data that we get basically the json

00:22:17,440 --> 00:22:22,720
message but this is similar to basically

00:22:20,000 --> 00:22:23,840
like link that you would find in cshop

00:22:22,720 --> 00:22:27,760
and so on

00:22:23,840 --> 00:22:30,320
so uh so likewise we have some um

00:22:27,760 --> 00:22:30,799
features based on that in order to like

00:22:30,320 --> 00:22:33,200
do

00:22:30,799 --> 00:22:34,080
uh similar kind of processing in an in

00:22:33,200 --> 00:22:37,440
an efficient

00:22:34,080 --> 00:22:39,280
and intuitive way so we do the

00:22:37,440 --> 00:22:42,400
processing and we get the

00:22:39,280 --> 00:22:43,360
addresses and we basically return that

00:22:42,400 --> 00:22:46,640
address

00:22:43,360 --> 00:22:50,000
with your location uh information

00:22:46,640 --> 00:22:55,840
uh so let's uh do a run of this

00:22:50,000 --> 00:22:55,840
and see

00:23:04,000 --> 00:23:09,840
again we just took a better run

00:23:17,600 --> 00:23:23,840
okay and let's send a request here

00:23:30,400 --> 00:23:40,000
it's location service

00:23:36,640 --> 00:23:42,799
location you can see here i

00:23:40,000 --> 00:23:43,919
actually got it addressed near to my my

00:23:42,799 --> 00:23:46,960
place actually

00:23:43,919 --> 00:23:51,679
so it did the whole round trip

00:23:46,960 --> 00:23:54,799
and got the response um

00:23:51,679 --> 00:23:56,159
so uh so here also i have uh the

00:23:54,799 --> 00:23:58,400
observability enabled

00:23:56,159 --> 00:23:58,400
um

00:24:00,320 --> 00:24:03,600
so likewise in uh similar to the earlier

00:24:02,240 --> 00:24:06,640
scenario so

00:24:03,600 --> 00:24:09,840
this should have ideally

00:24:06,640 --> 00:24:13,070
published those data

00:24:09,840 --> 00:24:14,400
to our our

00:24:13,070 --> 00:24:19,840
[Music]

00:24:14,400 --> 00:24:19,840
servers so let's go and quickly check

00:24:20,720 --> 00:24:23,279
so here

00:24:24,080 --> 00:24:28,559
it is in the last minute you can see uh

00:24:26,720 --> 00:24:33,840
so we got the information

00:24:28,559 --> 00:24:33,840
and also for the tracing

00:24:34,480 --> 00:24:37,679
you can see we have the location service

00:24:37,039 --> 00:24:41,760
we do

00:24:37,679 --> 00:24:45,520
the traces we get these bands

00:24:41,760 --> 00:24:48,240
by showing the

00:24:45,520 --> 00:24:49,200
starting from our resource invocation

00:24:48,240 --> 00:24:52,400
and

00:24:49,200 --> 00:24:52,400
which has this information

00:24:52,799 --> 00:25:03,279
and also the remote call

00:25:00,720 --> 00:25:05,120
uh this information that goes to the uh

00:25:03,279 --> 00:25:08,080
the geolocation api

00:25:05,120 --> 00:25:09,279
so all this you can get the the details

00:25:08,080 --> 00:25:11,440
on the

00:25:09,279 --> 00:25:12,640
uh on the request latencies the

00:25:11,440 --> 00:25:15,840
reconfigurations and

00:25:12,640 --> 00:25:15,840
uh all that information

00:25:18,480 --> 00:25:26,000
now as a next step let's

00:25:21,679 --> 00:25:27,840
uh extend this a bit so as i mentioned

00:25:26,000 --> 00:25:29,120
i'm going to add another service in the

00:25:27,840 --> 00:25:34,159
middle to

00:25:29,120 --> 00:25:34,159
cache this data

00:25:35,279 --> 00:25:39,760
and that is done in this

00:25:40,720 --> 00:25:57,840
other implementation i have saying

00:25:42,799 --> 00:25:57,840
location services should be cached

00:26:05,120 --> 00:26:11,840
so here um

00:26:14,000 --> 00:26:17,919
uh i'm i'm basically uh talking to

00:26:17,120 --> 00:26:21,440
another

00:26:17,919 --> 00:26:24,720
internal service um

00:26:21,440 --> 00:26:28,159
so here saying uh check it check

00:26:24,720 --> 00:26:31,440
my local data first

00:26:28,159 --> 00:26:33,679
at this service for the jio service

00:26:31,440 --> 00:26:34,480
if it's not there if it's not available

00:26:33,679 --> 00:26:37,760
we do the

00:26:34,480 --> 00:26:38,880
earlier same request and get the data

00:26:37,760 --> 00:26:41,520
and also update our

00:26:38,880 --> 00:26:42,559
local uh data as well so it's used as a

00:26:41,520 --> 00:26:44,559
cache

00:26:42,559 --> 00:26:47,520
so the first implementation we have is

00:26:44,559 --> 00:26:53,840
like an in-memory one

00:26:47,520 --> 00:26:53,840
so here let's run that

00:27:00,320 --> 00:27:03,760
so all these different services are

00:27:02,159 --> 00:27:06,400
again configured with

00:27:03,760 --> 00:27:07,440
the observability configurations so if

00:27:06,400 --> 00:27:09,840
you go to

00:27:07,440 --> 00:27:10,480
config normal i have said i have given

00:27:09,840 --> 00:27:12,880
it a

00:27:10,480 --> 00:27:13,520
unique promises port so from this will

00:27:12,880 --> 00:27:14,880
be

00:27:13,520 --> 00:27:18,720
calling all these different service

00:27:14,880 --> 00:27:18,720
ports to get the data

00:27:19,279 --> 00:27:26,720
so my in-memory the local

00:27:22,960 --> 00:27:34,799
service is running and so

00:27:26,720 --> 00:27:37,360
let's run this service as well

00:27:34,799 --> 00:27:37,360
what happens

00:27:38,799 --> 00:27:45,200
to the same request you can see here it

00:27:42,559 --> 00:27:46,559
uh said uh the local service miss

00:27:45,200 --> 00:27:48,480
because in the first one

00:27:46,559 --> 00:27:49,760
the local cache there's nothing there

00:27:48,480 --> 00:27:51,679
and it stored the

00:27:49,760 --> 00:27:52,880
okay so the subsequent one should be

00:27:51,679 --> 00:27:55,440
quick

00:27:52,880 --> 00:27:56,720
so it's hitting the local in memory uh

00:27:55,440 --> 00:28:00,000
cache and it's getting the

00:27:56,720 --> 00:28:03,840
result so

00:28:00,000 --> 00:28:03,840
it should be reflected here as well

00:28:04,320 --> 00:28:08,640
and if you go to the tracing information

00:28:07,360 --> 00:28:12,080
we can see

00:28:08,640 --> 00:28:17,840
now we have more traces which this

00:28:12,080 --> 00:28:17,840
jio service lookup as well so

00:28:20,880 --> 00:28:27,520
uh the first one uh actually

00:28:25,120 --> 00:28:27,520
there are

00:28:28,159 --> 00:28:32,240
more holes with the due to the caching

00:28:30,640 --> 00:28:35,120
um

00:28:32,240 --> 00:28:35,760
and uh the caching ended because in the

00:28:35,120 --> 00:28:38,480
first one

00:28:35,760 --> 00:28:39,919
you uh check if there's if the request

00:28:38,480 --> 00:28:42,240
is not there there's another

00:28:39,919 --> 00:28:44,960
uh store request as well uh where you do

00:28:42,240 --> 00:28:48,480
a post request to store the

00:28:44,960 --> 00:28:51,840
uh requested

00:28:48,480 --> 00:28:53,200
information uh locally so that's why you

00:28:51,840 --> 00:28:55,120
have

00:28:53,200 --> 00:28:56,320
extra steps here which you can see here

00:28:55,120 --> 00:28:59,760
in the

00:28:56,320 --> 00:29:01,919
tracing information so likewise uh

00:28:59,760 --> 00:29:03,360
there's another the next step would be

00:29:01,919 --> 00:29:07,200
the database one

00:29:03,360 --> 00:29:13,840
i'll quickly show that as well

00:29:07,200 --> 00:29:13,840
so so here

00:29:17,279 --> 00:29:22,960
rather than storing the details in

00:29:19,440 --> 00:29:22,960
memory we store it in a

00:29:24,840 --> 00:29:29,279
database

00:29:26,320 --> 00:29:29,279
so here

00:29:31,679 --> 00:29:41,840
my database is already populated

00:29:43,520 --> 00:29:45,840
okay

00:29:52,840 --> 00:29:55,840
okay

00:29:58,720 --> 00:30:04,480
okay now okay same thing happened the

00:30:01,200 --> 00:30:08,080
first one it missed then it's stored

00:30:04,480 --> 00:30:11,679
so i have the request

00:30:08,080 --> 00:30:14,799
the subsequent ones um

00:30:11,679 --> 00:30:17,919
quick so

00:30:14,799 --> 00:30:19,760
here also if

00:30:17,919 --> 00:30:22,559
uh these are updated and also we have

00:30:19,760 --> 00:30:27,360
the sql related stats as well

00:30:22,559 --> 00:30:37,679
the most used operations and so on

00:30:27,360 --> 00:30:41,440
and also in the tracing

00:30:37,679 --> 00:30:44,399
uh we have the database based operations

00:30:41,440 --> 00:30:45,440
uh shown here as well you can see the

00:30:44,399 --> 00:30:51,200
mysql clients

00:30:45,440 --> 00:30:53,120
query and so on

00:30:51,200 --> 00:30:55,120
so all this information is captured

00:30:53,120 --> 00:30:56,559
automatically as you can see

00:30:55,120 --> 00:30:59,120
so you don't have to write any extra

00:30:56,559 --> 00:31:01,840
code but most of the useful information

00:30:59,120 --> 00:31:01,840
is already there

00:31:02,840 --> 00:31:05,840
um

00:31:07,519 --> 00:31:13,840
so in the final demo here i'll

00:31:11,120 --> 00:31:15,840
also quickly show uh the websocket

00:31:13,840 --> 00:31:18,000
information as well

00:31:15,840 --> 00:31:19,840
so here the websocket implementation

00:31:18,000 --> 00:31:23,440
will simply use the

00:31:19,840 --> 00:31:26,159
existing http service to route the

00:31:23,440 --> 00:31:27,919
request so the web socket service will

00:31:26,159 --> 00:31:31,039
contact the

00:31:27,919 --> 00:31:34,640
http endpoint that we already have here

00:31:31,039 --> 00:31:36,880
so in that service so you can see here

00:31:34,640 --> 00:31:38,480
uh it's a it's a website service that's

00:31:36,880 --> 00:31:42,640
our

00:31:38,480 --> 00:31:42,640
startup here which contacts our earlier

00:31:44,840 --> 00:31:47,840
service

00:31:52,000 --> 00:31:56,640
so we start that and let's just

00:31:57,519 --> 00:32:01,840
get some javascript

00:32:13,360 --> 00:32:19,919
so then we just send a message

00:32:16,480 --> 00:32:21,360
and we should get back the location so

00:32:19,919 --> 00:32:23,919
as you can see here

00:32:21,360 --> 00:32:23,919
likewise

00:32:24,640 --> 00:32:28,000
so and again all this all these

00:32:27,440 --> 00:32:29,760
operations

00:32:28,000 --> 00:32:33,519
starting from websocket service

00:32:29,760 --> 00:32:33,519
everything is tracked here as well

00:32:38,000 --> 00:32:43,200
so uh so that's how you mix and match

00:32:41,039 --> 00:32:44,960
these different protocols and how the

00:32:43,200 --> 00:32:47,360
service uh

00:32:44,960 --> 00:32:49,440
the tracing information the context

00:32:47,360 --> 00:32:52,000
propagation and everything it happens

00:32:49,440 --> 00:32:52,559
so that's all done automatically and

00:32:52,000 --> 00:32:55,039
prior

00:32:52,559 --> 00:32:57,039
so those information inspired to you by

00:32:55,039 --> 00:33:02,080
the platform itself

00:32:57,039 --> 00:33:06,240
and uh now let's quickly go uh move on

00:33:02,080 --> 00:33:08,880
uh to one of the cloud solutions we have

00:33:06,240 --> 00:33:09,279
that complements the baroness features

00:33:08,880 --> 00:33:13,120
so

00:33:09,279 --> 00:33:14,880
now we sold our like how uh like the

00:33:13,120 --> 00:33:16,480
the observability provider uh the

00:33:14,880 --> 00:33:18,159
default observed priority is used we

00:33:16,480 --> 00:33:20,799
have used from ets

00:33:18,159 --> 00:33:21,840
and open telemetry based providers to do

00:33:20,799 --> 00:33:24,159
the matrix and the

00:33:21,840 --> 00:33:25,200
distributor tracing also we can plug in

00:33:24,159 --> 00:33:28,000
other uh

00:33:25,200 --> 00:33:29,120
observable providers as well and uh wsu

00:33:28,000 --> 00:33:32,480
has a

00:33:29,120 --> 00:33:36,559
uh uh a cloud solution

00:33:32,480 --> 00:33:39,600
uh which is an uh basically an

00:33:36,559 --> 00:33:40,640
enterprise ipas uh which is uh for

00:33:39,600 --> 00:33:43,760
developing

00:33:40,640 --> 00:33:46,960
uh uh low code and

00:33:43,760 --> 00:33:48,240
pro code based uh integrations uh cloud

00:33:46,960 --> 00:33:50,480
native integrations so

00:33:48,240 --> 00:33:51,679
as you can see here it uh there's the

00:33:50,480 --> 00:33:53,440
main highlight are

00:33:51,679 --> 00:33:55,679
mentioned here and one of the main

00:33:53,440 --> 00:33:56,159
things are its deep observability

00:33:55,679 --> 00:33:58,320
features

00:33:56,159 --> 00:34:00,159
where you can observe different aspects

00:33:58,320 --> 00:34:04,399
of your program itself

00:34:00,159 --> 00:34:07,039
how each aspect is working automatically

00:34:04,399 --> 00:34:07,519
so there's some uh so some some cool

00:34:07,039 --> 00:34:10,399
features

00:34:07,519 --> 00:34:11,839
uh available there so i recommend you to

00:34:10,399 --> 00:34:14,480
uh go and check it out

00:34:11,839 --> 00:34:15,040
uh it's available uh as a video release

00:34:14,480 --> 00:34:19,359
uh

00:34:15,040 --> 00:34:22,639
now uh so here i'll i'll quickly show

00:34:19,359 --> 00:34:26,000
uh how we can integrate our local

00:34:22,639 --> 00:34:28,399
local running applications to use the

00:34:26,000 --> 00:34:34,159
observations in

00:34:28,399 --> 00:34:37,280
industrial courier so

00:34:34,159 --> 00:34:41,599
first list uh let's

00:34:37,280 --> 00:34:41,599
let me go to the cardio uh portal

00:34:43,679 --> 00:34:47,839
and there we have something called a

00:34:45,359 --> 00:34:48,800
remote app a remote app you can give a

00:34:47,839 --> 00:34:54,480
remote

00:34:48,800 --> 00:34:54,480
uh name here let's say location service

00:34:55,440 --> 00:35:00,160
and it gives a configuration that you

00:34:58,079 --> 00:35:03,680
can copy

00:35:00,160 --> 00:35:06,800
to your config terminal

00:35:03,680 --> 00:35:06,800
so here we'll

00:35:08,000 --> 00:35:17,839
use it to in our

00:35:11,200 --> 00:35:17,839
http the enterprise service

00:35:28,839 --> 00:35:31,839
okay

00:35:32,640 --> 00:35:39,119
and also we have to okay so the

00:35:35,920 --> 00:35:43,040
kodi package should be uh as well

00:35:39,119 --> 00:35:43,040
so actually here now we don't need this

00:35:43,280 --> 00:35:45,839
watch

00:35:46,640 --> 00:35:52,240
so now it's just a matter of uh running

00:35:49,040 --> 00:35:55,040
uh this service

00:35:52,240 --> 00:35:57,119
so in berlin we can also uh so we we saw

00:35:55,040 --> 00:36:01,280
the banner on command we can also build

00:35:57,119 --> 00:36:03,119
and run the binary separately as well

00:36:01,280 --> 00:36:05,119
which is actually the

00:36:03,119 --> 00:36:06,560
preferred way because of all else it

00:36:05,119 --> 00:36:08,880
gets compiled

00:36:06,560 --> 00:36:11,280
again and again every time you use this

00:36:08,880 --> 00:36:27,839
so we do the banana build it'll

00:36:11,280 --> 00:36:27,839
compile and generate executable

00:36:31,920 --> 00:36:36,000
okay now we just run

00:36:39,760 --> 00:36:43,760
you this see here you get some logs

00:36:41,359 --> 00:36:46,800
saying it's connecting to

00:36:43,760 --> 00:36:50,079
the cloud in uh so the career service

00:36:46,800 --> 00:36:53,440
to communicate with it

00:36:50,079 --> 00:36:58,000
for sending the observability data

00:36:53,440 --> 00:36:58,000
so now let's do some sample requests

00:37:01,200 --> 00:37:05,680
let's clear this and send some requests

00:37:03,520 --> 00:37:09,839
as well

00:37:05,680 --> 00:37:09,839
send some to request

00:37:20,839 --> 00:37:23,839
okay

00:37:27,680 --> 00:37:32,560
okay we we see that our code is

00:37:31,119 --> 00:37:36,320
visualized here

00:37:32,560 --> 00:37:37,839
so in battery now so the code can be

00:37:36,320 --> 00:37:39,599
visualized as a

00:37:37,839 --> 00:37:41,040
sequence diagram as well so it's uh

00:37:39,599 --> 00:37:44,079
built from bottom up

00:37:41,040 --> 00:37:46,720
to be able to do this so uh the code is

00:37:44,079 --> 00:37:48,240
uh code can be converted to a sequence

00:37:46,720 --> 00:37:51,280
angle and the sequence engine can be

00:37:48,240 --> 00:37:52,400
uh directly transformed to the code as

00:37:51,280 --> 00:37:55,920
well so

00:37:52,400 --> 00:37:57,440
it goes both ways and so without any

00:37:55,920 --> 00:37:58,640
additional mapping one is like that the

00:37:57,440 --> 00:38:02,560
syntax is

00:37:58,640 --> 00:38:05,280
created to be uh to able to support this

00:38:02,560 --> 00:38:06,000
so here we can see uh we get this

00:38:05,280 --> 00:38:08,880
information

00:38:06,000 --> 00:38:10,160
like all the the calls network calls

00:38:08,880 --> 00:38:13,359
that are done here

00:38:10,160 --> 00:38:16,160
uh we clearly visualize uh this here

00:38:13,359 --> 00:38:18,079
and say uh give the latency information

00:38:16,160 --> 00:38:20,720
the success rates and everything is

00:38:18,079 --> 00:38:22,560
uh shown in this sequence diagram itself

00:38:20,720 --> 00:38:25,599
so it's very easy to visualize

00:38:22,560 --> 00:38:27,359
uh compared to just the uh the the spans

00:38:25,599 --> 00:38:30,560
view that we have in uh

00:38:27,359 --> 00:38:32,640
the india that as we saw earlier

00:38:30,560 --> 00:38:33,599
but this will give a i would say a more

00:38:32,640 --> 00:38:36,640
natural

00:38:33,599 --> 00:38:40,000
view on her on

00:38:36,640 --> 00:38:41,680
looking at the observability data and

00:38:40,000 --> 00:38:43,599
also we can drill down to other our

00:38:41,680 --> 00:38:45,839
other functions as well

00:38:43,599 --> 00:38:47,920
like our lookup function and you can see

00:38:45,839 --> 00:38:49,920
the success rates

00:38:47,920 --> 00:38:51,040
and other information as well the latest

00:38:49,920 --> 00:38:53,680
information

00:38:51,040 --> 00:38:55,839
and you can see here it says 67 percent

00:38:53,680 --> 00:38:59,440
uh the reason for that is actually

00:38:55,839 --> 00:39:03,280
i made the request

00:38:59,440 --> 00:39:04,400
and actually one is considered as fail

00:39:03,280 --> 00:39:07,599
because it

00:39:04,400 --> 00:39:11,920
because of the cash miss it returns

00:39:07,599 --> 00:39:14,079
uh 404 and due to that it requires it as

00:39:11,920 --> 00:39:17,280
failure so i send say three requests

00:39:14,079 --> 00:39:21,760
one one fail that's why it says uh

00:39:17,280 --> 00:39:25,839
sixty seven percent uh so

00:39:21,760 --> 00:39:29,839
if i just send now uh it hit the

00:39:25,839 --> 00:39:33,440
cache so i really should update

00:39:29,839 --> 00:39:37,040
eventually with

00:39:33,440 --> 00:39:37,040
probably 75 success rate

00:39:38,560 --> 00:39:43,839
so it'll process and update the ui

00:39:52,800 --> 00:39:55,920
yeah you can see here it becomes 75 so

00:39:55,200 --> 00:39:58,560
likewise so

00:39:55,920 --> 00:40:00,000
it's it uh it updates in real time uh

00:39:58,560 --> 00:40:00,720
you can see here all the interactions

00:40:00,000 --> 00:40:02,720
here

00:40:00,720 --> 00:40:04,720
uh the latency information and all the

00:40:02,720 --> 00:40:07,839
uh constructs that are used

00:40:04,720 --> 00:40:07,839
to execute this flow

00:40:08,800 --> 00:40:12,079
same here with the other function as

00:40:10,240 --> 00:40:15,359
well so

00:40:12,079 --> 00:40:19,119
um yeah so uh korea is in beta

00:40:15,359 --> 00:40:22,290
uh now uh so public beta so you can

00:40:19,119 --> 00:40:23,440
come and try this out as well and

00:40:22,290 --> 00:40:27,040
[Music]

00:40:23,440 --> 00:40:31,119
give feedback and and

00:40:27,040 --> 00:40:32,319
hopefully it will be a useful tool

00:40:31,119 --> 00:40:34,560
for your microservice development as

00:40:32,319 --> 00:40:34,560
well

00:40:37,359 --> 00:40:40,720
so um that's basically it for my uh

00:40:39,839 --> 00:40:43,680
presentation

00:40:40,720 --> 00:40:44,880
and for additional resources you can uh

00:40:43,680 --> 00:40:47,359
check these

00:40:44,880 --> 00:40:49,520
uh links uh so the demo scenario you can

00:40:47,359 --> 00:40:51,200
find it in my github repo

00:40:49,520 --> 00:40:52,880
uh so all the source code and the

00:40:51,200 --> 00:40:54,079
resources are there uh with the

00:40:52,880 --> 00:40:57,280
instructions

00:40:54,079 --> 00:41:00,319
and also uh the burner guides

00:40:57,280 --> 00:41:03,359
uh they are in the banana io website uh

00:41:00,319 --> 00:41:06,880
so they are like a comprehensive list of

00:41:03,359 --> 00:41:07,280
examples and uh in detail uh detail user

00:41:06,880 --> 00:41:10,000
guide

00:41:07,280 --> 00:41:11,200
as well uh this is the link to adobe's

00:41:10,000 --> 00:41:14,800
choreo

00:41:11,200 --> 00:41:18,839
so that you can

00:41:14,800 --> 00:41:21,839
check it out and play around a bit

00:41:18,839 --> 00:41:25,040
yourself and uh for other community

00:41:21,839 --> 00:41:29,119
uh channels so we have a uh uh

00:41:25,040 --> 00:41:31,280
uh a slack channel uh where most of our

00:41:29,119 --> 00:41:32,880
banner developers hang out so you can

00:41:31,280 --> 00:41:36,240
come and

00:41:32,880 --> 00:41:37,440
join talk with the uh people i'll give

00:41:36,240 --> 00:41:40,079
feedback

00:41:37,440 --> 00:41:41,200
and ask questions if you have any uh get

00:41:40,079 --> 00:41:44,400
some help

00:41:41,200 --> 00:41:46,880
uh so we encourage you to uh join there

00:41:44,400 --> 00:41:49,119
and also uh stack also you can use the

00:41:46,880 --> 00:41:53,599
bell now bell online tag

00:41:49,119 --> 00:41:56,880
to ask questions as well

00:41:53,599 --> 00:42:03,839
so i hope you found this session

00:41:56,880 --> 00:42:03,839
useful thank you for joining

00:42:05,040 --> 00:42:10,230
[Music]

00:42:14,319 --> 00:42:16,400

YouTube URL: https://www.youtube.com/watch?v=htAwwgt86c0


