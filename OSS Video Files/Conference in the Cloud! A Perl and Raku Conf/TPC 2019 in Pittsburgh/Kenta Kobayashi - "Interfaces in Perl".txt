Title: Kenta Kobayashi - "Interfaces in Perl"
Publication date: 2019-06-18
Playlist: TPC 2019 in Pittsburgh
Description: 
	Have you ever experienced the software becoming bigger and less maintenance?
In such a case, I think it is important to divide the code, make it easy to change, and make code easier to read.
For that reason, I thought the Interface was useful, and I made a module called Function::Interface.
Function::Interface checks the arguments and return type of the function at compile time.
For example, you can write like this:
package IFoo {
    use Function::Interface;
    use Types::Standard -types;
    fun hello(Str $msg) :Return(Str);
}
package Foo {
    use Function::Interface::Impl qw(IFoo);
    use Types::Standard -types;
    fun hello(Str $msg) :Return(Str) {
        return "Hello! Pittsburgh! $msg"
   }
}
It's strange but interesting!
Talk Topics
What is Interface, its importance
How can I create Interface in Perl?
Role is not Interface
DEMO Function::Interface
Inside Function::Interface
Function::Parameters, Function::Return
Keyword::Simple, PPR
Captions: 
	00:00:00,030 --> 00:00:09,929
all right everyone let's meet you for

00:00:05,940 --> 00:00:13,740
the first time I joined TPC so I'm

00:00:09,929 --> 00:00:19,199
excited I'd like to communicate or to be

00:00:13,740 --> 00:00:22,350
helped and allow empower so in this

00:00:19,199 --> 00:00:28,019
session I talked about interface in

00:00:22,350 --> 00:00:33,030
power 5 first of all please introduce

00:00:28,019 --> 00:00:39,090
myself my name is ko bokja please call

00:00:33,030 --> 00:00:47,160
me Coco K or K fry I'm Japanese I came

00:00:39,090 --> 00:00:53,120
from Tokyo I belong to mobile factory my

00:00:47,160 --> 00:00:55,920
company paid for this trip and thanks

00:00:53,120 --> 00:01:02,910
mobile factory is developing web games

00:00:55,920 --> 00:01:05,479
web service and blockchain service this

00:01:02,910 --> 00:01:09,420
game is called station memories

00:01:05,479 --> 00:01:14,240
this is geolocation game like Pokemon go

00:01:09,420 --> 00:01:21,409
Pokemon go correct Pokemon this game

00:01:14,240 --> 00:01:24,869
corrects stations my company use pol 5

00:01:21,409 --> 00:01:32,100
for example station memories uses power

00:01:24,869 --> 00:01:36,659
5 next I belong to Odin p.m. this power

00:01:32,100 --> 00:01:40,170
community in Tokyo I am the second

00:01:36,659 --> 00:01:48,149
leader or good on p.m. and first leader

00:01:40,170 --> 00:01:51,619
is he kappa hi when i held good on p.m.

00:01:48,149 --> 00:01:56,630
last mass a newcomer from my company and

00:01:51,619 --> 00:02:00,270
talked about the context of pearl Macari

00:01:56,630 --> 00:02:04,610
confused perfect context and the Akutan

00:02:00,270 --> 00:02:04,610
p.m. members taught here

00:02:07,770 --> 00:02:15,030
at five months ago I organized the up

00:02:11,640 --> 00:02:19,890
she Tokyo this is like the park

00:02:15,030 --> 00:02:24,480
conference in Japan I think it is hard

00:02:19,890 --> 00:02:29,520
to organize conference so I think TPC I

00:02:24,480 --> 00:02:32,360
think I sorry I thank for TPC stuffs and

00:02:29,520 --> 00:02:32,360
thank you

00:02:33,390 --> 00:02:43,400
this is the up she Tokyo's hot oh there

00:02:38,370 --> 00:02:43,400
are speakers there are drinkers

00:02:44,970 --> 00:02:50,400
I think good conference and good

00:02:47,310 --> 00:02:54,209
community and that's all introduce

00:02:50,400 --> 00:03:00,390
myself conclusion I love Paul and thank

00:02:54,209 --> 00:03:07,489
you let's get into the main subject I

00:03:00,390 --> 00:03:12,690
talked about interface in / v first

00:03:07,489 --> 00:03:17,120
example of interface in power v DB I is

00:03:12,690 --> 00:03:20,299
my favorite pub module do you write DB I

00:03:17,120 --> 00:03:25,620
- yeah

00:03:20,299 --> 00:03:29,070
DBI is a great module v bi provides to

00:03:25,620 --> 00:03:37,560
rub some data stores for examples MySQL

00:03:29,070 --> 00:03:41,459
SQL Postgres CSV files etc so we can

00:03:37,560 --> 00:03:43,890
handle get in unified interface without

00:03:41,459 --> 00:03:47,790
worrying up about the specific

00:03:43,890 --> 00:03:53,910
circumstance of each data to us it is

00:03:47,790 --> 00:03:57,660
very useful and when we want to add new

00:03:53,910 --> 00:04:00,600
data stores it will we promised to keep

00:03:57,660 --> 00:04:02,630
interfaces we can provide value to many

00:04:00,600 --> 00:04:07,590
people

00:04:02,630 --> 00:04:10,829
so interface is very effective due to

00:04:07,590 --> 00:04:19,230
limitations I would like to talk about

00:04:10,829 --> 00:04:22,100
this interface this is agenda I talk

00:04:19,230 --> 00:04:22,100
five sections

00:04:24,400 --> 00:04:32,930
first I made function interface so this

00:04:29,090 --> 00:04:38,750
module provides to implement Java like

00:04:32,930 --> 00:04:41,470
interface in power five please take a

00:04:38,750 --> 00:04:41,470
look up demo

00:04:54,170 --> 00:04:57,470
just more man

00:04:59,389 --> 00:05:06,039
this package is in Turkish could I see

00:05:06,370 --> 00:05:09,370
okay

00:05:09,940 --> 00:05:21,000
and use function interface oh sorry

00:05:21,270 --> 00:05:34,270
and define function defined function

00:05:27,340 --> 00:05:48,850
interface define her and drink Dom

00:05:34,270 --> 00:06:03,910
message the Oh string and they use type

00:05:48,850 --> 00:06:06,480
standard this is interface and implement

00:06:03,910 --> 00:06:06,480
interface

00:06:11,240 --> 00:06:30,319
use functional capacity input and hello

00:06:16,190 --> 00:06:36,380
interface and so we can see in Copiah

00:06:30,319 --> 00:06:38,650
lab compile time and they implement the

00:06:36,380 --> 00:06:38,650
Harrow

00:06:53,170 --> 00:06:57,240
[Laughter]

00:07:06,200 --> 00:07:09,200
sorry

00:07:21,260 --> 00:07:47,050
and so if edit a complete implementation

00:07:30,100 --> 00:07:52,390
and if changed this message that's all

00:07:47,050 --> 00:07:52,390
this is demo looks good P I looks good

00:08:11,060 --> 00:08:17,660
of this is features of function

00:08:15,500 --> 00:08:19,880
interface well

00:08:17,660 --> 00:08:28,450
typed in top peppery interface

00:08:19,880 --> 00:08:32,630
definition and check at compile time so

00:08:28,450 --> 00:08:39,380
second section what is gold and why do I

00:08:32,630 --> 00:08:43,040
make so my goal is to make it easy to

00:08:39,380 --> 00:08:44,780
maintain large power applications for

00:08:43,040 --> 00:08:49,360
large application other language may be

00:08:44,780 --> 00:08:54,590
better however changing the language is

00:08:49,360 --> 00:08:56,900
difficult decision so I'm I want to be

00:08:54,590 --> 00:09:03,650
able to maintain large application in

00:08:56,900 --> 00:09:07,700
Perl so that power application have many

00:09:03,650 --> 00:09:11,630
objects so interface define the

00:09:07,700 --> 00:09:14,570
interface of object the interface

00:09:11,630 --> 00:09:21,020
facilitates conversations between

00:09:14,570 --> 00:09:24,160
objects so most paste curry first

00:09:21,020 --> 00:09:28,820
advantage it will be easier to fix

00:09:24,160 --> 00:09:31,910
important implementation we are expected

00:09:28,820 --> 00:09:35,470
to improve implementation for examples

00:09:31,910 --> 00:09:39,560
to improve performance security

00:09:35,470 --> 00:09:44,570
little-bitty for my examples to change

00:09:39,560 --> 00:09:50,210
my escape 5.2 to mask your age or to

00:09:44,570 --> 00:09:55,010
change our version so another case if I

00:09:50,210 --> 00:10:02,140
have written code in the hurry and made

00:09:55,010 --> 00:10:06,370
data code so I need to be factoring so

00:10:02,140 --> 00:10:10,340
if you keep interfaces implementation

00:10:06,370 --> 00:10:14,630
implementers do not have to worry too

00:10:10,340 --> 00:10:20,390
much about the object user so and you

00:10:14,630 --> 00:10:23,480
can change implementation now second

00:10:20,390 --> 00:10:24,740
advantage interfaces makes the

00:10:23,480 --> 00:10:28,070
advantages

00:10:24,740 --> 00:10:32,600
so stable means let's change to the

00:10:28,070 --> 00:10:38,150
object stable means most chance to out

00:10:32,600 --> 00:10:43,730
the object if object to depends on a

00:10:38,150 --> 00:10:47,870
stable dependence sorry object depends

00:10:43,730 --> 00:10:52,880
on unstable objects we will have to

00:10:47,870 --> 00:10:57,800
check more so in general implementation

00:10:52,880 --> 00:11:00,860
is unstable then interfaces it will be

00:10:57,800 --> 00:11:08,930
nice if we could depend on stable

00:11:00,860 --> 00:11:14,630
interfaces so my goal my goal is to make

00:11:08,930 --> 00:11:21,850
it easy to maintain large apps and the

00:11:14,630 --> 00:11:27,350
interface is good for large apps so next

00:11:21,850 --> 00:11:32,990
so next and to understand more let's

00:11:27,350 --> 00:11:36,380
talk about vacationing example I want to

00:11:32,990 --> 00:11:41,090
introduce the two top equation and then

00:11:36,380 --> 00:11:46,460
leave it to the application case one in

00:11:41,090 --> 00:11:51,400
health Jane's case so to do deep out

00:11:46,460 --> 00:11:51,400
story inherit DBI

00:11:53,629 --> 00:12:03,060
this cause to the repository and this

00:11:57,810 --> 00:12:12,199
capacity sorry to the repository get to

00:12:03,060 --> 00:12:19,680
do while inside to do DBA and implement

00:12:12,199 --> 00:12:25,339
select function let's to this and to the

00:12:19,680 --> 00:12:31,670
a patoot uses is using to the repository

00:12:25,339 --> 00:12:41,490
and I implement my to-do list

00:12:31,670 --> 00:12:45,470
so let's debut this design case this

00:12:41,490 --> 00:12:48,720
shows current dependencies to drop

00:12:45,470 --> 00:12:51,480
depends on to the repository to the

00:12:48,720 --> 00:12:59,329
repository depends on to the tables and

00:12:51,480 --> 00:12:59,329
DBI so if I change

00:13:07,480 --> 00:13:19,950
no so unstable dependencies next problem

00:13:13,530 --> 00:13:23,500
look at this eBay myself this is even so

00:13:19,950 --> 00:13:29,620
to the depository car used all features

00:13:23,500 --> 00:13:36,090
of dbi because in health I wish I could

00:13:29,620 --> 00:13:42,910
just take out to do so too many features

00:13:36,090 --> 00:13:47,620
and the next problem is to develop easy

00:13:42,910 --> 00:13:53,460
to test it test and testing to the

00:13:47,620 --> 00:14:00,150
apathy what you did to the repository so

00:13:53,460 --> 00:14:08,470
power is good power is good out mock and

00:14:00,150 --> 00:14:17,710
is it amok or do you use my skill during

00:14:08,470 --> 00:14:23,790
testing test the test my scooty so so I

00:14:17,710 --> 00:14:23,790
want to like test called up only to do

00:14:26,400 --> 00:14:46,120
logic so as possible so muck or my scale

00:14:35,170 --> 00:14:51,030
process is no no I want to mess it so

00:14:46,120 --> 00:14:53,410
problems of inheritance case

00:14:51,030 --> 00:14:58,890
well-established dependencies and the

00:14:53,410 --> 00:15:06,100
too many features and message to this so

00:14:58,890 --> 00:15:10,920
next let's use law so using law so three

00:15:06,100 --> 00:15:10,920
problems in the case of inheritance

00:15:12,300 --> 00:15:29,570
first define interface using a model not

00:15:16,950 --> 00:15:37,070
all and implement to the repository and

00:15:29,570 --> 00:15:48,750
make TB hundra injectable and implement

00:15:37,070 --> 00:15:57,510
same-sex function so not to do

00:15:48,750 --> 00:16:00,020
repository and implement the same like

00:15:57,510 --> 00:16:00,020
to do list

00:16:00,860 --> 00:16:08,250
so let's leave you the lower case design

00:16:04,200 --> 00:16:11,100
and this shows current dependencies on

00:16:08,250 --> 00:16:18,120
to the output depends on to the

00:16:11,100 --> 00:16:20,490
repository interface and to the

00:16:18,120 --> 00:16:23,120
repository it depends on to the table

00:16:20,490 --> 00:16:29,750
DBI and to do the post interfaces

00:16:23,120 --> 00:16:32,910
interface so in the case of inheritance

00:16:29,750 --> 00:16:35,730
changes into the repository affected to

00:16:32,910 --> 00:16:39,660
the apathy about this case and TWP

00:16:35,730 --> 00:16:41,790
depends only on the interface so

00:16:39,660 --> 00:16:47,000
changing the implementation to the

00:16:41,790 --> 00:16:47,000
depository is not likely to be effective

00:16:48,980 --> 00:16:52,610
so more stable

00:16:53,770 --> 00:17:07,520
so fast poor babies yeah we moved and

00:17:02,650 --> 00:17:08,120
can we define the eBay method so not no

00:17:07,520 --> 00:17:12,610
I can't

00:17:08,120 --> 00:17:19,069
so because we can not any puncture dbi

00:17:12,610 --> 00:17:24,560
because not inheritance so yes and it's

00:17:19,069 --> 00:17:34,790
optioned features so minimum the second

00:17:24,560 --> 00:17:38,270
problem so in the next impairment to the

00:17:34,790 --> 00:17:42,680
repository for test so this will reduce

00:17:38,270 --> 00:17:52,520
the mob code and uses your mama SK in

00:17:42,680 --> 00:17:58,550
tests so and be easier to test and so we

00:17:52,520 --> 00:18:04,940
move the last problem ja in this case if

00:17:58,550 --> 00:18:15,910
there are no problem at all I think I

00:18:04,940 --> 00:18:15,910
have the old can be used implementation

00:18:22,600 --> 00:18:31,300
so our low is too many pictures as

00:18:28,610 --> 00:18:31,300
interface

00:18:34,220 --> 00:18:40,250
next I think the definition of the

00:18:43,340 --> 00:18:56,040
ambiguous input and biggest output so

00:18:49,860 --> 00:18:59,960
and biggest interface in summary there

00:18:56,040 --> 00:18:59,960
are two problems in lowercase

00:19:01,370 --> 00:19:10,430
let's get functioning talk function

00:19:04,680 --> 00:19:16,530
interface first define the interface

00:19:10,430 --> 00:19:22,020
select function and the input and output

00:19:16,530 --> 00:19:27,540
declare unlike loss function interface

00:19:22,020 --> 00:19:32,270
does not do use the implementation we

00:19:27,540 --> 00:19:32,270
cannot use

00:19:32,900 --> 00:19:48,200
so functioning cafes solve global

00:19:39,230 --> 00:19:50,410
problems just keep this right so looks

00:19:48,200 --> 00:19:50,410
good

00:20:05,750 --> 00:20:09,700
oh sorry

00:20:38,090 --> 00:20:54,059
so this right yes I want to see to the

00:20:50,960 --> 00:21:14,869
implementation to the is the same

00:20:54,059 --> 00:21:14,869
law same outro no and here

00:21:17,660 --> 00:21:43,300
so we can specify interface function

00:21:33,350 --> 00:21:43,300
interface types export these types sorry

00:21:43,420 --> 00:21:55,850
yeah looks good so I would like to talk

00:21:53,420 --> 00:22:02,030
about and contents of the strange

00:21:55,850 --> 00:22:08,510
mechanism from here won't use that

00:22:02,030 --> 00:22:17,780
mechanism strange it is now if it is

00:22:08,510 --> 00:22:24,230
myself so I think talk about internal so

00:22:17,780 --> 00:22:28,550
I think the function interface is on the

00:22:24,230 --> 00:22:34,030
shoulder of giant and you can see that

00:22:28,550 --> 00:22:38,030
it is a simple question there are four

00:22:34,030 --> 00:22:42,790
requirements functional implementations

00:22:38,030 --> 00:22:46,610
and the interface and the check it

00:22:42,790 --> 00:22:52,280
interface is implemented in the

00:22:46,610 --> 00:22:59,540
interface type our first function

00:22:52,280 --> 00:23:03,220
implementation function interface use

00:22:59,540 --> 00:23:12,310
function parameters this module provides

00:23:03,220 --> 00:23:12,310
subroutine signatures so we can specify

00:23:14,490 --> 00:23:22,170
Omega's in integer and die in cages

00:23:19,750 --> 00:23:22,170
Daffy

00:23:25,110 --> 00:23:46,059
we can get meta information of function

00:23:28,990 --> 00:23:51,490
argument with info function function

00:23:46,059 --> 00:23:56,850
leta specify function return types for

00:23:51,490 --> 00:23:56,850
example this code

00:24:09,950 --> 00:24:21,700
at runtime so in the we can get meta

00:24:17,810 --> 00:24:21,700
information or function leta

00:24:29,350 --> 00:24:39,070
so more details function returns so we

00:24:36,320 --> 00:24:43,430
can specify much detail body types

00:24:39,070 --> 00:24:52,280
for example this code number and the

00:24:43,430 --> 00:24:55,480
string this module and post list context

00:24:52,280 --> 00:24:55,480
to simplify

00:25:05,660 --> 00:25:18,970
so so in large application I think that

00:25:11,120 --> 00:25:24,230
is better not to use one today so so M

00:25:18,970 --> 00:25:29,270
for this context now fast Rik Mayall

00:25:24,230 --> 00:25:30,220
requirements done next function

00:25:29,270 --> 00:25:34,850
interface

00:25:30,220 --> 00:25:40,940
now this module uses keyword simple and

00:25:34,850 --> 00:26:01,870
the PPR do you know cubed simple and the

00:25:40,940 --> 00:26:01,870
ppl by

00:26:05,060 --> 00:26:23,590
so we define our return string interface

00:26:13,430 --> 00:26:32,050
and we pass this string so we get and

00:26:23,590 --> 00:26:36,040
this is so meta information is

00:26:32,050 --> 00:26:36,040
registered in the beginning phase

00:26:46,299 --> 00:27:07,750
so we can get meta information or the

00:26:52,009 --> 00:27:13,610
interface requirements is done next

00:27:07,750 --> 00:27:15,909
interface is implemented check so this

00:27:13,610 --> 00:27:26,830
is a user G is function of a simple

00:27:15,909 --> 00:27:26,830
internal so we got information

00:27:33,940 --> 00:27:45,250
so we can check if interface is

00:27:39,070 --> 00:27:48,310
implemented compared implementation meta

00:27:45,250 --> 00:27:52,930
information and interface meta

00:27:48,310 --> 00:28:00,150
information compare this runs at compile

00:27:52,930 --> 00:28:03,640
time so subtle equipments it's done last

00:28:00,150 --> 00:28:08,500
we can get type constraints by function

00:28:03,640 --> 00:28:15,750
interface typist and this module uses

00:28:08,500 --> 00:28:23,050
type tiny last requirements down okay

00:28:15,750 --> 00:28:29,560
this is internal in last section I would

00:28:23,050 --> 00:28:33,190
like to talk about commas so so by

00:28:29,560 --> 00:28:35,850
changing by checking if the interface is

00:28:33,190 --> 00:28:40,540
implemented

00:28:35,850 --> 00:28:45,430
by checking whether talita body is as

00:28:40,540 --> 00:28:50,020
expected type in the execution time but

00:28:45,430 --> 00:28:57,450
affected no no problem

00:28:50,020 --> 00:28:57,450
so no problem because I'm Japanese

00:28:57,660 --> 00:29:08,080
because functional interface simple laws

00:29:01,330 --> 00:29:12,670
at compile time not run at long time and

00:29:08,080 --> 00:29:17,760
the functional function return has no

00:29:12,670 --> 00:29:25,270
check option so internally default case

00:29:17,760 --> 00:29:29,400
function little lapse function then use

00:29:25,270 --> 00:29:35,860
no check option does not love function

00:29:29,400 --> 00:29:40,210
so during development or testing check

00:29:35,860 --> 00:29:43,920
the return values and in production it

00:29:40,210 --> 00:29:43,920
will be nice to not check

00:29:44,550 --> 00:29:53,020
and let's pinch mark our case this is

00:29:48,930 --> 00:30:24,580
benchmark cases case 1 default case and

00:29:53,020 --> 00:30:29,070
the case is so I want the it is good if

00:30:24,580 --> 00:30:29,070
case two is are enough

00:30:40,790 --> 00:30:49,310
so this is benchmark result so case why

00:30:45,290 --> 00:30:52,840
is slower than other cases and the case

00:30:49,310 --> 00:30:58,730
two case three case four it's the same

00:30:52,840 --> 00:31:02,180
so it can be the same speed as using the

00:30:58,730 --> 00:31:08,290
only function parameters so there is no

00:31:02,180 --> 00:31:14,060
problem with Bahamas so okay

00:31:08,290 --> 00:31:17,240
conclusion in summary function interface

00:31:14,060 --> 00:31:20,810
has the following features and type the

00:31:17,240 --> 00:31:28,100
interface definition and they check out

00:31:20,810 --> 00:31:33,380
compile time my goal is to make it easy

00:31:28,100 --> 00:31:37,190
to maintain large publications the first

00:31:33,380 --> 00:31:41,990
I think the interface is effective for

00:31:37,190 --> 00:31:45,080
that the first advantage is it will be

00:31:41,990 --> 00:31:48,800
easier to fix implementation the second

00:31:45,080 --> 00:31:55,280
advantage is interface makes stable

00:31:48,800 --> 00:31:58,130
dependencies internal function

00:31:55,280 --> 00:32:00,890
parameters three function implementation

00:31:58,130 --> 00:32:04,790
uses function parameters and the

00:32:00,890 --> 00:32:10,060
function return and function interface

00:32:04,790 --> 00:32:10,060
uses keyboard simple and the ppl

00:32:11,230 --> 00:32:15,790
comparator informations at compile time

00:32:16,120 --> 00:32:23,930
the performance the same speed as using

00:32:19,970 --> 00:32:27,250
only function parameters so function

00:32:23,930 --> 00:32:32,380
interface simple does at compile time

00:32:27,250 --> 00:32:32,380
function Rita has no check option so you

00:32:36,520 --> 00:32:49,630
that's all thank you any questions

00:33:11,530 --> 00:33:14,490
benchmark

00:33:20,470 --> 00:33:22,710
as

00:34:22,310 --> 00:34:28,330
this is function account so school and

00:34:35,669 --> 00:34:39,480
function McDonald

00:34:46,940 --> 00:34:59,909
but noted case did

00:34:56,679 --> 00:34:59,909
[Music]

00:35:09,420 --> 00:35:13,549
Oh Spokane yeah

00:35:16,310 --> 00:35:20,320
okay thank you

00:35:37,480 --> 00:35:42,620
so poorly mom but are we using

00:35:40,460 --> 00:35:48,890
interfaces like this in your production

00:35:42,620 --> 00:35:59,050
code base this is something you use no

00:35:48,890 --> 00:36:02,540
not production lady yes yeah you can use

00:35:59,050 --> 00:36:13,180
but yesterday I

00:36:02,540 --> 00:36:13,180
I broke yesterday Hakkasan I'm sorry

00:36:15,880 --> 00:36:19,300
any questions

00:36:28,269 --> 00:36:32,129
yeah thank you everyone

00:36:33,260 --> 00:36:36,819

YouTube URL: https://www.youtube.com/watch?v=K25OxILcbNE


