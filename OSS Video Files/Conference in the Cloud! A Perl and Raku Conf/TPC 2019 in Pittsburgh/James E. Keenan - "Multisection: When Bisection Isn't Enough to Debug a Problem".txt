Title: James E. Keenan - "Multisection: When Bisection Isn't Enough to Debug a Problem"
Publication date: 2019-06-20
Playlist: TPC 2019 in Pittsburgh
Description: 
	Bisection is a developer's tool customarily used to identify the single point in a series of change sets for a given codebase where the code's behavior changed on a given platform. Typically, we perform bisection when a test has begun to fail and we want to identify the change set where that failure first appeared.

There are, however, circumstances in which, over the course of many change sets, a given test might fail in multiple, different ways. In that case, *how* something failed becomes more important than simply *that* something failed. We may need to capture the output of the testing process at multiple transition points for later human examination. In that case we need a tool for "multiple bisection" -- or, for short, "multisection."

I developed CPAN distribution Devel-Git-MultiBisect to provide such a tool and have used it in debugging both build failures and test failures in the Perl 5 core distribution. In this presentation, however, I will not focus on the details of that library but will rather try to have attendees develop an understanding of the kind of problems for which multisectioning is appropriate.
Captions: 
	00:00:00,000 --> 00:00:03,540
this presentation is called multi

00:00:01,530 --> 00:00:07,770
section when you need to bisect more

00:00:03,540 --> 00:00:10,349
than once my name is Jim Keenan this

00:00:07,770 --> 00:00:12,389
presentation concerns a subject that

00:00:10,349 --> 00:00:15,330
falls into the area of debugging or QA

00:00:12,389 --> 00:00:19,830
and what I hope you get out of it today

00:00:15,330 --> 00:00:23,580
is at least some idea that there is a

00:00:19,830 --> 00:00:26,970
step beyond simple by sectioning which

00:00:23,580 --> 00:00:31,199
can be useful to you when you have some

00:00:26,970 --> 00:00:35,130
complex debugging problems so multi

00:00:31,199 --> 00:00:37,710
section is for me short for multiple

00:00:35,130 --> 00:00:40,379
bisection but of course that raises the

00:00:37,710 --> 00:00:42,600
question what is bisection well

00:00:40,379 --> 00:00:45,120
wikipedia tells us that bisection is a

00:00:42,600 --> 00:00:47,789
method used in software development to

00:00:45,120 --> 00:00:51,030
identify change sets that result in

00:00:47,789 --> 00:00:52,469
specific behavioral change mostly

00:00:51,030 --> 00:00:55,800
employed for finding the patch that

00:00:52,469 --> 00:00:58,050
introduced a bug code bisection has the

00:00:55,800 --> 00:01:03,149
goal of minimizing the effort to find a

00:00:58,050 --> 00:01:04,589
specific change set so when we bisect we

00:01:03,149 --> 00:01:07,260
have a series of commits let's say

00:01:04,589 --> 00:01:09,689
commit zero to commit 100 commit zero

00:01:07,260 --> 00:01:12,810
all our tests were passing commits 100

00:01:09,689 --> 00:01:15,320
there's a failure at what commit between

00:01:12,810 --> 00:01:17,640
0 and 100 was the failure introduced

00:01:15,320 --> 00:01:20,100
finding that out is the point of by

00:01:17,640 --> 00:01:22,890
sectioning and what by setting does is

00:01:20,100 --> 00:01:25,890
it tests at 0 100 divides the editor to

00:01:22,890 --> 00:01:29,189
test the commit 50 makes a decision as

00:01:25,890 --> 00:01:30,930
to whether to go up you see what on the

00:01:29,189 --> 00:01:33,659
basis of pass or fail at commit 50

00:01:30,930 --> 00:01:37,530
whether we go back to commit 25 or up to

00:01:33,659 --> 00:01:40,110
commit 75 we just basically bisect the

00:01:37,530 --> 00:01:43,579
set of commits until we find the one

00:01:40,110 --> 00:01:47,130
that introduced the bug when we

00:01:43,579 --> 00:01:50,759
bisecting we have to develop a measure

00:01:47,130 --> 00:01:52,649
of success and that has to be a boolean

00:01:50,759 --> 00:01:56,369
condition true or false

00:01:52,649 --> 00:02:00,479
pass or fail yes or no very you know

00:01:56,369 --> 00:02:03,420
very simple to understand and by session

00:02:00,479 --> 00:02:07,170
typically assumes a simple progression

00:02:03,420 --> 00:02:10,319
from pass to fail so that suppose that

00:02:07,170 --> 00:02:13,500
we began with a pass that's the green

00:02:10,319 --> 00:02:16,350
pea there and we had a series of commits

00:02:13,500 --> 00:02:18,750
that we didn't test so their status is

00:02:16,350 --> 00:02:22,920
unknown and finally we come to another

00:02:18,750 --> 00:02:24,360
commit F Fair in red where we know that

00:02:22,920 --> 00:02:26,580
there is a failure so we know that

00:02:24,360 --> 00:02:29,490
there's there's a bug been introduced

00:02:26,580 --> 00:02:32,160
somewhere along between P and F but we

00:02:29,490 --> 00:02:35,490
don't know which one we don't know the

00:02:32,160 --> 00:02:39,720
real results of each commit in between

00:02:35,490 --> 00:02:42,740
that's currently unknown to us so our

00:02:39,720 --> 00:02:47,490
typical goal is to locate the first

00:02:42,740 --> 00:02:50,180
failing commit but what if the

00:02:47,490 --> 00:02:54,390
progression is not so simple

00:02:50,180 --> 00:02:58,110
suppose that we observe a progression of

00:02:54,390 --> 00:03:00,570
per commit results such as at the top P

00:02:58,110 --> 00:03:05,250
a series of unknowns and then an F for

00:03:00,570 --> 00:03:07,740
failure then suppose that in the middle

00:03:05,250 --> 00:03:11,520
of this series of commits where I have

00:03:07,740 --> 00:03:13,830
the X we have a failure but not

00:03:11,520 --> 00:03:17,760
necessarily the same type of failure as

00:03:13,830 --> 00:03:22,050
I observed at F the final commit in the

00:03:17,760 --> 00:03:25,650
sequence suppose that X is a different

00:03:22,050 --> 00:03:29,220
kind of failure from F suppose that at X

00:03:25,650 --> 00:03:33,600
the test file simply fails some unit

00:03:29,220 --> 00:03:36,739
tests whereas at F the test files seg

00:03:33,600 --> 00:03:40,010
faults it doesn't even run to completion

00:03:36,739 --> 00:03:44,549
so what if the real but hidden

00:03:40,010 --> 00:03:49,470
progression is like this PP some X's and

00:03:44,549 --> 00:03:52,350
then some FS simple bisection will be

00:03:49,470 --> 00:03:58,650
insufficient to identify all the change

00:03:52,350 --> 00:04:02,310
points now we're in the real world might

00:03:58,650 --> 00:04:06,810
you need to identify multiple change

00:04:02,310 --> 00:04:08,940
points in the results of testing an open

00:04:06,810 --> 00:04:11,160
source application

00:04:08,940 --> 00:04:14,910
well that application is likely to be

00:04:11,160 --> 00:04:16,799
large and complex it it could be an

00:04:14,910 --> 00:04:20,130
application that needs to run on many

00:04:16,799 --> 00:04:22,169
different platforms and or it could be

00:04:20,130 --> 00:04:26,000
an application that can be configured to

00:04:22,169 --> 00:04:30,470
build in many different ways

00:04:26,000 --> 00:04:33,540
perhaps the table the combination of the

00:04:30,470 --> 00:04:35,370
number of platforms to test and the

00:04:33,540 --> 00:04:37,290
number of configurations is so great

00:04:35,370 --> 00:04:41,030
that it they're just simply too many

00:04:37,290 --> 00:04:43,410
combinations to test feasibly well

00:04:41,030 --> 00:04:45,450
that's the sort of application we're

00:04:43,410 --> 00:04:46,770
talking about and there's but there's

00:04:45,450 --> 00:04:49,680
one other thing we have to mention we

00:04:46,770 --> 00:04:52,620
have to ask what infrastructure with

00:04:49,680 --> 00:04:55,650
this application require in order for us

00:04:52,620 --> 00:04:58,139
to be able to identify a series of

00:04:55,650 --> 00:05:02,820
change points through a technique of

00:04:58,139 --> 00:05:05,880
multiple bisection well that application

00:05:02,820 --> 00:05:09,120
would have to be stored in a version

00:05:05,880 --> 00:05:11,940
control system that provides at least

00:05:09,120 --> 00:05:13,979
this functionality we need to be able to

00:05:11,940 --> 00:05:14,820
list the change sets in chronological

00:05:13,979 --> 00:05:18,800
order

00:05:14,820 --> 00:05:21,479
check out individual change sets and

00:05:18,800 --> 00:05:25,110
clean up the working directory after

00:05:21,479 --> 00:05:27,210
building a given can't change that if

00:05:25,110 --> 00:05:29,130
the VCS provides by sectioning that's

00:05:27,210 --> 00:05:33,360
helpful but surprisingly it's not

00:05:29,130 --> 00:05:36,180
actually necessary so let's talk about a

00:05:33,360 --> 00:05:38,760
real-world application in a real world

00:05:36,180 --> 00:05:40,470
version control system and for

00:05:38,760 --> 00:05:45,870
argument's sake we'll call this

00:05:40,470 --> 00:05:48,600
application pearl pearl runs on many

00:05:45,870 --> 00:05:51,300
different platforms it can be built with

00:05:48,600 --> 00:05:53,160
many different configuration options the

00:05:51,300 --> 00:05:55,139
total number of combinations of

00:05:53,160 --> 00:05:58,889
configuration options with which pearl

00:05:55,139 --> 00:06:01,680
can be built is somewhere north of 10 to

00:05:58,889 --> 00:06:03,419
the 100th power there is probably not

00:06:01,680 --> 00:06:06,389
enough time left in the history of the

00:06:03,419 --> 00:06:10,979
universe to be able to test every

00:06:06,389 --> 00:06:14,310
possible pearl configuration moreover

00:06:10,979 --> 00:06:16,289
pearl is stored currently in a

00:06:14,310 --> 00:06:18,900
real-world version control system namely

00:06:16,289 --> 00:06:21,289
get and get provides us with three

00:06:18,900 --> 00:06:24,870
functions that we will need for our

00:06:21,289 --> 00:06:27,530
multi multiple bisection get rev list

00:06:24,870 --> 00:06:30,810
get checkout and get clean

00:06:27,530 --> 00:06:32,880
there's get bisect it's useful for

00:06:30,810 --> 00:06:36,940
simple bisection but we'll see its

00:06:32,880 --> 00:06:39,310
limitations so

00:06:36,940 --> 00:06:41,050
I'm a member of the Pearl fide porters

00:06:39,310 --> 00:06:43,630
the group that maintains the parol five

00:06:41,050 --> 00:06:46,210
core distribution and in the core

00:06:43,630 --> 00:06:50,350
distribution we have a program called

00:06:46,210 --> 00:06:52,330
porting bisect IPL it's a Perl program I

00:06:50,350 --> 00:06:54,190
believe was originally written by former

00:06:52,330 --> 00:06:56,530
pumpking dick Clarke and it's

00:06:54,190 --> 00:06:59,710
essentially a nice wrapper around git

00:06:56,530 --> 00:07:04,060
bisect to handle many of the situations

00:06:59,710 --> 00:07:06,520
that we typically face simple world

00:07:04,060 --> 00:07:09,280
real-world case a couple months ago we

00:07:06,520 --> 00:07:12,520
were testing CP n modules against Pro 5

00:07:09,280 --> 00:07:14,110
bleed and in the course of investigating

00:07:12,520 --> 00:07:16,390
some bug ticket

00:07:14,110 --> 00:07:19,600
I noticed that bleed that's the cutting

00:07:16,390 --> 00:07:23,560
edge of the Perl 5 distribution the head

00:07:19,600 --> 00:07:27,520
in git repository was breaking a test in

00:07:23,560 --> 00:07:30,940
a CPM module called J code so I ran

00:07:27,520 --> 00:07:33,160
porting bisect APL with the

00:07:30,940 --> 00:07:37,090
configuration options that you see there

00:07:33,160 --> 00:07:40,060
and I was able to identify the commits

00:07:37,090 --> 00:07:42,640
that broke the test in J code it was

00:07:40,060 --> 00:07:44,170
this commit here FF ap 8 by Carly

00:07:42,640 --> 00:07:50,260
Williamson who is sitting right down

00:07:44,170 --> 00:07:52,960
there yeah and and so in my bug ticket I

00:07:50,260 --> 00:07:55,060
provided the output of the failing tests

00:07:52,960 --> 00:07:57,160
look at the what you got and what do you

00:07:55,060 --> 00:07:59,500
expect it isn't that ugly and down at

00:07:57,160 --> 00:08:03,010
the bottom of the ticket I said Carl can

00:07:59,500 --> 00:08:05,580
you take a look right so of course Carl

00:08:03,010 --> 00:08:10,330
did take a look and Carl fix the bug and

00:08:05,580 --> 00:08:13,150
he made a commit and I tested the commit

00:08:10,330 --> 00:08:15,669
by building Perl 5 bleed after his

00:08:13,150 --> 00:08:18,100
commit and successfully installing this

00:08:15,669 --> 00:08:20,890
module Jake oh that's a case of simple

00:08:18,100 --> 00:08:23,860
bisection used to diagnose and solve a

00:08:20,890 --> 00:08:27,780
problem however we've also had some

00:08:23,860 --> 00:08:30,910
complex real-world cases for example

00:08:27,780 --> 00:08:34,630
three now three development cycles ago

00:08:30,910 --> 00:08:38,080
during their 5.25 dev cycle we began to

00:08:34,630 --> 00:08:42,700
experience test failures on version 11

00:08:38,080 --> 00:08:45,450
of the FreeBSD operating system so and

00:08:42,700 --> 00:08:49,630
those those failures concerned locales

00:08:45,450 --> 00:08:50,470
in locate in computing a locale is a set

00:08:49,630 --> 00:08:51,790
of parameters

00:08:50,470 --> 00:08:53,650
that defines of the users language

00:08:51,790 --> 00:08:55,630
region and any special variant

00:08:53,650 --> 00:08:58,540
preferences that the user wants to see

00:08:55,630 --> 00:09:00,750
in their user interface such as do you

00:08:58,540 --> 00:09:07,810
use commas or periods to separate

00:09:00,750 --> 00:09:10,630
numbers by thousands we knew that we had

00:09:07,810 --> 00:09:13,870
a test in our core distribution called

00:09:10,630 --> 00:09:19,600
Lib locality and that passed when we

00:09:13,870 --> 00:09:23,560
released 5.24 in May of 2016 this pass

00:09:19,600 --> 00:09:26,050
on all platforms including FreeBSD we

00:09:23,560 --> 00:09:28,270
then began the next development cycle we

00:09:26,050 --> 00:09:31,150
committed new source code locales and

00:09:28,270 --> 00:09:32,080
tests in starting in May and June of

00:09:31,150 --> 00:09:35,020
00:09:32,080 --> 00:09:36,970
and we did an extensive smoke testing of

00:09:35,020 --> 00:09:39,460
these of this new code in these new

00:09:36,970 --> 00:09:42,040
tests on Linux and we got passes for

00:09:39,460 --> 00:09:44,080
many months however during that time we

00:09:42,040 --> 00:09:48,640
were not conducting smoke testing on any

00:09:44,080 --> 00:09:54,940
FreeBSD operating system so we come to

00:09:48,640 --> 00:09:56,710
September 2016 and we know that FreeBSD

00:09:54,940 --> 00:09:59,830
11 which was then in its development

00:09:56,710 --> 00:10:02,020
stage called current that Perl Phi 24

00:09:59,830 --> 00:10:04,570
was passing but we didn't really know

00:10:02,020 --> 00:10:08,080
the status of Perl 5 bleed the head in

00:10:04,570 --> 00:10:12,250
our repository that was unknown in

00:10:08,080 --> 00:10:14,440
October of 2016 FreeBSD 11 was promoted

00:10:12,250 --> 00:10:17,380
to release status that is that's the

00:10:14,440 --> 00:10:23,110
production and release but we still had

00:10:17,380 --> 00:10:27,850
not tested Perl 5 bleed on FreeBSD 11 so

00:10:23,110 --> 00:10:29,860
I became concerned about this and what I

00:10:27,850 --> 00:10:31,930
decided to do was to learn the art of

00:10:29,860 --> 00:10:34,120
installing virtual machines and running

00:10:31,930 --> 00:10:36,790
tests in virtual machines and I

00:10:34,120 --> 00:10:39,670
installed a FreeBSD 11 virtual machine

00:10:36,790 --> 00:10:42,610
on this Linux laptop that from which I

00:10:39,670 --> 00:10:46,120
am presenting and then I submitted a

00:10:42,610 --> 00:10:49,990
smoke test report in October of 2016 and

00:10:46,120 --> 00:10:51,850
that first report was a fail and we can

00:10:49,990 --> 00:10:55,300
pass we have time we can actually look

00:10:51,850 --> 00:10:56,950
at the failure now this was concerning

00:10:55,300 --> 00:11:01,410
because it meant that at some point

00:10:56,950 --> 00:11:04,180
between May of 2016 and October of 2016

00:11:01,410 --> 00:11:06,460
we had introduced code into the Perl

00:11:04,180 --> 00:11:09,550
five core distribution that was

00:11:06,460 --> 00:11:12,070
generating test failures in one

00:11:09,550 --> 00:11:14,950
particular test on one important

00:11:12,070 --> 00:11:17,980
operating system but at that point we

00:11:14,950 --> 00:11:22,540
didn't know where the failure had been

00:11:17,980 --> 00:11:24,910
introduced when I ran this in October I

00:11:22,540 --> 00:11:27,820
got an error message such as you see

00:11:24,910 --> 00:11:29,860
here lib locale that he failed no plan

00:11:27,820 --> 00:11:34,920
found in tap output which is usually a

00:11:29,860 --> 00:11:39,160
sign that the test file seg faltered so

00:11:34,920 --> 00:11:42,160
what I did was I tried running the test

00:11:39,160 --> 00:11:46,420
file by itself outside of the outside of

00:11:42,160 --> 00:11:50,080
make test and I found that of 680 unit

00:11:46,420 --> 00:11:56,410
tests in this file the test was failing

00:11:50,080 --> 00:11:58,690
with a seg fault at tests 380 so I first

00:11:56,410 --> 00:12:01,330
I use porting bisect IPL because I

00:11:58,690 --> 00:12:02,890
wanted to find out where was the commit

00:12:01,330 --> 00:12:04,300
that introduced the seg fault the

00:12:02,890 --> 00:12:06,010
cultists could they cause the file to

00:12:04,300 --> 00:12:10,810
fail that caused the overall smoke test

00:12:06,010 --> 00:12:13,060
report to fail so Lib locality

00:12:10,810 --> 00:12:18,100
identified one particular commit this

00:12:13,060 --> 00:12:22,390
for EBE ff1 and so I tried to build Perl

00:12:18,100 --> 00:12:25,060
on FreeBSD 11 at that commit and I got a

00:12:22,390 --> 00:12:28,209
failure but it was a different failure

00:12:25,060 --> 00:12:34,740
from the one that I got when I tested at

00:12:28,209 --> 00:12:39,100
at the head of Perl 5 in in October in

00:12:34,740 --> 00:12:42,730
this report the test file ran to

00:12:39,100 --> 00:12:45,370
completion but it had two test failures

00:12:42,730 --> 00:12:49,810
so somewhere in there in a series of

00:12:45,370 --> 00:12:52,240
commits we had one one change set that

00:12:49,810 --> 00:12:54,610
caused some unit tests to fail and later

00:12:52,240 --> 00:12:56,920
we had another change set that caused

00:12:54,610 --> 00:13:01,600
the file to seg fault and not run to

00:12:56,920 --> 00:13:05,079
completion so between May and October

00:13:01,600 --> 00:13:08,020
there were 220 commits to the core

00:13:05,079 --> 00:13:10,390
distribution my first approach to this

00:13:08,020 --> 00:13:12,430
was to capture the output of Lib

00:13:10,390 --> 00:13:15,459
locality for a commitment commit

00:13:12,430 --> 00:13:17,720
comparison as you might guess this was

00:13:15,459 --> 00:13:21,230
non-scalable the program

00:13:17,720 --> 00:13:23,500
took over 8 hours to run so I figured we

00:13:21,230 --> 00:13:26,990
need a new tool which would apply the

00:13:23,500 --> 00:13:28,759
principle of by sectioning to read it

00:13:26,990 --> 00:13:32,029
which is to reduce the number of commits

00:13:28,759 --> 00:13:35,149
to be run but instead of just looking

00:13:32,029 --> 00:13:38,720
for pass or fail would focus on

00:13:35,149 --> 00:13:42,410
differences in the entire test output

00:13:38,720 --> 00:13:44,680
the entire tap as we might say rather

00:13:42,410 --> 00:13:48,170
than just the test result pass or fail

00:13:44,680 --> 00:13:50,930
so I wanted to ask has the output of

00:13:48,170 --> 00:13:53,529
libel ocal dot e at commit and changed

00:13:50,930 --> 00:13:56,420
from the immediately previous commit

00:13:53,529 --> 00:13:59,600
simply identifying the first failing

00:13:56,420 --> 00:14:03,079
commit would not be sufficient because

00:13:59,600 --> 00:14:07,310
we knew that lib locale had failed in at

00:14:03,079 --> 00:14:09,740
least two different ways so we need to

00:14:07,310 --> 00:14:14,870
identify each commit at which the test

00:14:09,740 --> 00:14:17,540
output changed and after we identify the

00:14:14,870 --> 00:14:20,629
first change in test output we have to

00:14:17,540 --> 00:14:23,779
repeatedly bisect until we find all the

00:14:20,629 --> 00:14:27,889
points in which all the test output from

00:14:23,779 --> 00:14:30,439
Lib locality changed to accomplish this

00:14:27,889 --> 00:14:34,750
I eventually ended up writing a CPM

00:14:30,439 --> 00:14:38,689
module called devel get Multi bisect

00:14:34,750 --> 00:14:42,079
with this module I was able to identify

00:14:38,689 --> 00:14:44,660
the failing test file within the Perl 5

00:14:42,079 --> 00:14:46,699
test suite oh I'm sorry

00:14:44,660 --> 00:14:49,160
let me say this what davell get Multi

00:14:46,699 --> 00:14:51,199
bisect does how you prepare for it is

00:14:49,160 --> 00:14:53,269
you identify the first failing the the

00:14:51,199 --> 00:14:56,809
failing test file from your smoke test

00:14:53,269 --> 00:15:00,139
reports you identify the last known pass

00:14:56,809 --> 00:15:01,699
change set and this becomes the starting

00:15:00,139 --> 00:15:05,059
change set for the purpose of by

00:15:01,699 --> 00:15:08,230
sectioning let's call that index 0 then

00:15:05,059 --> 00:15:11,240
you identify the change set at which

00:15:08,230 --> 00:15:14,029
failure was reported by a your smoke

00:15:11,240 --> 00:15:16,000
testing and this becomes the end change

00:15:14,029 --> 00:15:19,670
in the targeted range

00:15:16,000 --> 00:15:21,800
so what DeVille develop Multi basic does

00:15:19,670 --> 00:15:25,069
is it assembles a list of all change

00:15:21,800 --> 00:15:29,509
sets in the targeted range it configures

00:15:25,069 --> 00:15:30,600
builds builds purl that is and each of

00:15:29,509 --> 00:15:32,819
those at the

00:15:30,600 --> 00:15:36,779
start in endpoints and runs a test file

00:15:32,819 --> 00:15:39,300
it runs the critical test file at the

00:15:36,779 --> 00:15:41,670
start and end points you capture the

00:15:39,300 --> 00:15:44,220
whole output of the file of the I'm

00:15:41,670 --> 00:15:47,250
sorry the whole output of of the test

00:15:44,220 --> 00:15:51,000
run the tap and you redirect that to a

00:15:47,250 --> 00:15:55,139
file on your system and you take an md5

00:15:51,000 --> 00:15:57,269
hex digest so that you have a a 64

00:15:55,139 --> 00:16:00,870
character string that describes the

00:15:57,269 --> 00:16:05,009
content of that file and you assign that

00:16:00,870 --> 00:16:08,699
to a particular commit in the list you

00:16:05,009 --> 00:16:11,040
divide that change set into you build at

00:16:08,699 --> 00:16:14,459
the midpoint midpoint of 220 commits

00:16:11,040 --> 00:16:16,560
would be committed member 110 you run

00:16:14,459 --> 00:16:19,620
the test you redirect the output of that

00:16:16,560 --> 00:16:22,410
test to a file you take an md5 hex

00:16:19,620 --> 00:16:26,069
digest of the file and you store it in

00:16:22,410 --> 00:16:30,449
your list and you compare that md5 hex

00:16:26,069 --> 00:16:32,519
digest to your start and end md5 hex

00:16:30,449 --> 00:16:35,310
digests so you're doing a string

00:16:32,519 --> 00:16:38,759
comparison right is this equal to this

00:16:35,310 --> 00:16:41,100
string comparison is a boolean condition

00:16:38,759 --> 00:16:42,870
you have and when you have that boolean

00:16:41,100 --> 00:16:46,079
condition you have something that you

00:16:42,870 --> 00:16:49,230
can use to say is this or is this not

00:16:46,079 --> 00:16:52,500
the failing commit or is this or is this

00:16:49,230 --> 00:16:56,759
not a commit that introduced a change a

00:16:52,500 --> 00:16:58,439
transition so the result of this is you

00:16:56,759 --> 00:17:01,560
get an array with one element for each

00:16:58,439 --> 00:17:04,110
change set if a change set did not need

00:17:01,560 --> 00:17:06,209
to be run in the in the multi sectioning

00:17:04,110 --> 00:17:09,689
process its value is simply an empty

00:17:06,209 --> 00:17:13,319
string a transition is a pair of

00:17:09,689 --> 00:17:17,010
elements where the md5 hex digest value

00:17:13,319 --> 00:17:19,470
at commit n minus 1 is different from at

00:17:17,010 --> 00:17:22,110
commit and and we do the string

00:17:19,470 --> 00:17:26,010
comparison of the adjacent digests

00:17:22,110 --> 00:17:28,409
needed for bisection so the result in

00:17:26,010 --> 00:17:31,409
this particular case was that over a

00:17:28,409 --> 00:17:33,950
range of 220 commits the output of Lib

00:17:31,409 --> 00:17:37,260
local dot e changed only three times

00:17:33,950 --> 00:17:41,880
between these pairs of indices I show

00:17:37,260 --> 00:17:43,600
here in the first case the purl 5 Porter

00:17:41,880 --> 00:17:46,930
who committed the

00:17:43,600 --> 00:17:48,400
code simply added one unit test but of

00:17:46,930 --> 00:17:52,540
course when you add a unit test you

00:17:48,400 --> 00:17:56,410
change the output of the tab and so this

00:17:52,540 --> 00:17:57,970
change in a test description resulted in

00:17:56,410 --> 00:18:02,140
a transition but it was a transition

00:17:57,970 --> 00:18:04,900
from one pass to another however a bit

00:18:02,140 --> 00:18:07,660
later the committer added two unit tests

00:18:04,900 --> 00:18:10,930
one of the unit tests failed it was

00:18:07,660 --> 00:18:16,210
graded not okay it was we the tap was

00:18:10,930 --> 00:18:20,070
not okay and so we had a pass at commit

00:18:16,210 --> 00:18:22,300
58 and have failed at commit 59 and the

00:18:20,070 --> 00:18:25,660
you know at this point we recommend a

00:18:22,300 --> 00:18:30,280
review of the source code changes a bit

00:18:25,660 --> 00:18:32,830
later between indexes 64 and 65 that's

00:18:30,280 --> 00:18:37,120
where that seg fault was introduced

00:18:32,830 --> 00:18:40,390
after unit test 380 we got a fail and we

00:18:37,120 --> 00:18:43,120
were already having a fail yet commit 64

00:18:40,390 --> 00:18:46,030
but we have a different failure at

00:18:43,120 --> 00:18:48,010
commit 65 because at commit 65 it's not

00:18:46,030 --> 00:18:50,680
simply a failing unit tests it's a seg

00:18:48,010 --> 00:18:55,150
fault and again we recommend review of

00:18:50,680 --> 00:18:57,670
source code changes so bisection

00:18:55,150 --> 00:19:03,430
typically focuses on identifying a

00:18:57,670 --> 00:19:05,920
single commit by a boolean test but when

00:19:03,430 --> 00:19:07,900
you actually have a series of failures

00:19:05,920 --> 00:19:10,600
you may need more information in order

00:19:07,900 --> 00:19:13,780
to diagnose the problem you may for

00:19:10,600 --> 00:19:18,400
example need the full test output not

00:19:13,780 --> 00:19:20,860
just pass or fail you and we need a way

00:19:18,400 --> 00:19:22,450
to reduce test output to a value which

00:19:20,860 --> 00:19:25,360
can be an argument in a boolean

00:19:22,450 --> 00:19:27,810
comparison we need to find out all the

00:19:25,360 --> 00:19:31,120
commits where the test output changed

00:19:27,810 --> 00:19:35,410
for that you need a process of multiple

00:19:31,120 --> 00:19:37,330
dice bisection or multi section and for

00:19:35,410 --> 00:19:39,430
at least the Perl 5 core and the CPM

00:19:37,330 --> 00:19:42,030
distributions to they'll get multi

00:19:39,430 --> 00:19:44,680
bisect provides that functionality

00:19:42,030 --> 00:19:48,910
there's lots more slides in the bonus

00:19:44,680 --> 00:19:51,760
slides and since we're we're running

00:19:48,910 --> 00:19:53,110
into the we have no talk immediately

00:19:51,760 --> 00:19:55,860
following here I'll be happy to stay in

00:19:53,110 --> 00:19:58,320
the room and answer questions at

00:19:55,860 --> 00:20:03,590
you know as you may have them other

00:19:58,320 --> 00:20:03,590
questions now yes sir

00:20:21,799 --> 00:20:27,720
because you don't because all the when

00:20:25,440 --> 00:20:29,340
you start the results for all the

00:20:27,720 --> 00:20:32,519
commits between the start commits and

00:20:29,340 --> 00:20:34,590
the end commit are unknown right so if

00:20:32,519 --> 00:20:38,460
it were simple bisection and your first

00:20:34,590 --> 00:20:39,899
result was a pass I would say it didn't

00:20:38,460 --> 00:20:41,399
the the problem did not occur in the

00:20:39,899 --> 00:20:44,789
first half of the commits it occurred in

00:20:41,399 --> 00:20:49,169
the second right but here you have to

00:20:44,789 --> 00:20:52,460
account for the possibility that at the

00:20:49,169 --> 00:20:57,029
say the midpoint of the run the

00:20:52,460 --> 00:20:59,759
bisection the the result was failed but

00:20:57,029 --> 00:21:04,100
it was a different type of failure

00:20:59,759 --> 00:21:04,100
I did that kid

00:21:20,230 --> 00:21:29,680
change that he has to make a decision it

00:21:25,670 --> 00:21:29,680
was work at a change

00:21:44,040 --> 00:21:52,020
well once you've once you've completed

00:21:46,440 --> 00:21:55,830
the run the calculation of the of the

00:21:52,020 --> 00:22:09,900
md5 hex digest is simple and then you're

00:21:55,830 --> 00:22:13,710
just plugging that into a list all I can

00:22:09,900 --> 00:22:19,250
say is you're possibly correct but this

00:22:13,710 --> 00:22:21,920
was the this was this was the algorithm

00:22:19,250 --> 00:22:26,480
suggested by the problem at hand and

00:22:21,920 --> 00:22:30,120
this this occurs infrequently enough

00:22:26,480 --> 00:22:32,730
that I don't have a lot of runs to

00:22:30,120 --> 00:22:35,010
suggest we're to revise the code because

00:22:32,730 --> 00:22:36,750
the revision would be very deep in the

00:22:35,010 --> 00:22:39,230
code you know it'd be you know because

00:22:36,750 --> 00:22:41,730
the the actual the place to determine

00:22:39,230 --> 00:22:43,710
what to do after a pass or failure is

00:22:41,730 --> 00:22:48,200
kind of deep in the code and so it was

00:22:43,710 --> 00:22:48,200
simply just to let it be yes

00:23:02,430 --> 00:23:05,480
I think the

00:23:10,590 --> 00:23:17,070
again that's another possibility but in

00:23:15,179 --> 00:23:19,110
other instances from this it has not

00:23:17,070 --> 00:23:20,879
been a case of like one is as one is the

00:23:19,110 --> 00:23:25,019
seg fault one is a regular test failure

00:23:20,879 --> 00:23:27,210
so I wanted a procedure that was sort of

00:23:25,019 --> 00:23:29,480
general enough to handle these various

00:23:27,210 --> 00:23:29,480
cases

00:23:39,120 --> 00:23:41,450
yes

00:23:45,029 --> 00:23:50,699
yeah but but you don't know where the

00:23:47,549 --> 00:23:55,649
segfault is at the beginning so you

00:23:50,699 --> 00:23:58,109
don't and and you you don't know how

00:23:55,649 --> 00:23:59,909
many different points of transition

00:23:58,109 --> 00:24:02,579
there were in this in the series of

00:23:59,909 --> 00:24:05,159
commits because there can be you know

00:24:02,579 --> 00:24:07,349
there could be three four or five you

00:24:05,159 --> 00:24:11,929
know different places where the tap

00:24:07,349 --> 00:24:11,929
output of a particular file changed and

00:24:12,379 --> 00:24:18,029
you want to be and at least I wanted to

00:24:14,969 --> 00:24:26,189
be able to identify each of them so that

00:24:18,029 --> 00:24:30,229
I could say yeah but we're not actually

00:24:26,189 --> 00:24:35,719
in development Multi bisect I do not use

00:24:30,229 --> 00:24:40,739
git bisect I assemble the list of

00:24:35,719 --> 00:24:42,199
commits and I manually apply the you

00:24:40,739 --> 00:24:47,789
know the mathematical formula for

00:24:42,199 --> 00:24:50,999
bisection so I don't I don't need to

00:24:47,789 --> 00:24:54,269
call get git bisect we use that we use

00:24:50,999 --> 00:25:01,049
git bisect in porting bisect at PL but

00:24:54,269 --> 00:25:03,199
it was not necessary for this yes in the

00:25:01,049 --> 00:25:03,199
back

00:25:22,750 --> 00:25:27,929
[Music]

00:25:24,429 --> 00:25:27,929
you need to filter out all

00:25:32,290 --> 00:25:38,710
yeah in in the two cases that I was

00:25:36,880 --> 00:25:42,400
concerned with namely the pro/5 core

00:25:38,710 --> 00:25:47,950
distribution and CPM distributions are

00:25:42,400 --> 00:25:52,870
relatively simple CPM distributions the

00:25:47,950 --> 00:25:59,170
I needed to filter out timestamps and I

00:25:52,870 --> 00:26:03,100
did that and in a in a later example of

00:25:59,170 --> 00:26:04,600
this where the failure in the profile or

00:26:03,100 --> 00:26:09,480
distribution was taking place during

00:26:04,600 --> 00:26:15,360
make rather than make test right where

00:26:09,480 --> 00:26:21,460
and this was like this is a case where

00:26:15,360 --> 00:26:24,250
Perl was being built on Linux with very

00:26:21,460 --> 00:26:26,290
particular and strange configuration

00:26:24,250 --> 00:26:30,550
options that had not been tested in

00:26:26,290 --> 00:26:33,460
three years and the smoke tester the

00:26:30,550 --> 00:26:34,810
person resumed testing after a hiatus of

00:26:33,460 --> 00:26:36,670
three years so suddenly we're getting

00:26:34,810 --> 00:26:42,760
these smoke test failures with these

00:26:36,670 --> 00:26:44,980
obscure options and the in the when I

00:26:42,760 --> 00:26:48,100
first tried multiple bisection there

00:26:44,980 --> 00:26:49,720
it proved difficult because if a failure

00:26:48,100 --> 00:26:51,790
is taking place during make you're

00:26:49,720 --> 00:26:55,060
getting line numbers in the source code

00:26:51,790 --> 00:26:58,030
reported and those line numbers say in

00:26:55,060 --> 00:27:01,540
SVC or other source code path change

00:26:58,030 --> 00:27:05,520
around so I had to filter out the line

00:27:01,540 --> 00:27:10,690
numbers so this so for the for whatever

00:27:05,520 --> 00:27:12,550
whatever source code body that you think

00:27:10,690 --> 00:27:14,650
you might want to apply multiple by

00:27:12,550 --> 00:27:18,280
sectioning two you're going to have to

00:27:14,650 --> 00:27:23,170
apply some hacks to to handle these

00:27:18,280 --> 00:27:26,440
these situations you know so that you

00:27:23,170 --> 00:27:29,560
can get files that when you take their

00:27:26,440 --> 00:27:33,180
md5 X digests you can compare them and

00:27:29,560 --> 00:27:33,180
the comparison is a meaningful one

00:27:36,280 --> 00:27:43,900
that was passed and he had to back

00:27:41,290 --> 00:27:46,230
failures Teresa which one which was the

00:27:43,900 --> 00:27:46,230
root cause

00:27:50,620 --> 00:27:57,850
well the thief here comes the to

00:27:53,950 --> 00:28:01,120
confession in the month that it took me

00:27:57,850 --> 00:28:04,299
to write this module and to fine-tune it

00:28:01,120 --> 00:28:09,630
such that I could reproduce the the

00:28:04,299 --> 00:28:09,630
sequence of failures Carl fixed the bug

00:28:09,929 --> 00:28:16,510
so this did this arrived a bit late at

00:28:15,039 --> 00:28:18,400
the scene for the correction of this

00:28:16,510 --> 00:28:21,460
particular bug but at least we had that

00:28:18,400 --> 00:28:23,679
you know I had a technique and then this

00:28:21,460 --> 00:28:26,559
during this past development cycle we

00:28:23,679 --> 00:28:30,730
had this new variation where it wasn't a

00:28:26,559 --> 00:28:32,950
failure in a in the tests in the test

00:28:30,730 --> 00:28:34,990
suite it was a failure during make with

00:28:32,950 --> 00:28:37,360
these obscure configuration options and

00:28:34,990 --> 00:28:41,500
that led me to write a subclass of

00:28:37,360 --> 00:28:46,120
develop multi bisect to focus on errors

00:28:41,500 --> 00:28:48,880
at the bill at the build stage and you

00:28:46,120 --> 00:28:51,880
know and once again but but in the time

00:28:48,880 --> 00:28:56,710
that it took me to you know fine-tune

00:28:51,880 --> 00:29:02,679
the the module Karl or Tony cook or

00:28:56,710 --> 00:29:04,899
somebody had identified the bug so this

00:29:02,679 --> 00:29:09,929
is a this is a you know a minor addition

00:29:04,899 --> 00:29:09,929
to our repertoire yes sir in the back

00:29:13,200 --> 00:29:16,559
speak up please

00:29:23,560 --> 00:29:29,980
yeah until two days ago

00:29:27,170 --> 00:29:36,760
I had never studied the test to output

00:29:29,980 --> 00:29:39,170
and I discussed this a bit with Chad and

00:29:36,760 --> 00:29:41,480
although I actually discussed it more in

00:29:39,170 --> 00:29:44,090
the question of the the smoke testing

00:29:41,480 --> 00:29:51,170
that is done by people out people on

00:29:44,090 --> 00:29:52,910
behalf of the core and there's a posit

00:29:51,170 --> 00:29:57,230
there's a you know that's a possible

00:29:52,910 --> 00:29:59,420
extension you know I first wrote this a

00:29:57,230 --> 00:30:02,030
couple years ago and test two had not

00:29:59,420 --> 00:30:04,310
developed it to that level at this point

00:30:02,030 --> 00:30:06,680
but it's certainly a possibility as you

00:30:04,310 --> 00:30:09,010
know then this is this is you should

00:30:06,680 --> 00:30:11,990
note in the under the devel

00:30:09,010 --> 00:30:14,900
classification on Sipan which means is

00:30:11,990 --> 00:30:16,370
it's a developer's tool which almost

00:30:14,900 --> 00:30:19,820
certainly means that there are some

00:30:16,370 --> 00:30:21,590
hacks involved and that what's more

00:30:19,820 --> 00:30:24,680
important for you today is to take away

00:30:21,590 --> 00:30:27,890
the concept of the possibility of

00:30:24,680 --> 00:30:30,140
needing multiple by sectioning and the

00:30:27,890 --> 00:30:33,020
concept of trying to figure out a way

00:30:30,140 --> 00:30:35,930
that you can get a boolean condition

00:30:33,020 --> 00:30:38,660
that with which you can use to evaluate

00:30:35,930 --> 00:30:41,810
the results of a run of your program at

00:30:38,660 --> 00:30:45,080
any given commit that's the important

00:30:41,810 --> 00:30:48,710
thing I you may have a large code base

00:30:45,080 --> 00:30:50,600
at work that you know you cannot

00:30:48,710 --> 00:30:57,290
feasibly test that every commit and you

00:30:50,600 --> 00:30:59,660
may need to to look at this module not

00:30:57,290 --> 00:31:02,330
necessarily to run it immediately it

00:30:59,660 --> 00:31:05,600
might might work it might not but to use

00:31:02,330 --> 00:31:10,000
it as a design pattern for your your

00:31:05,600 --> 00:31:10,000
debugging Carl

00:31:14,190 --> 00:31:19,830
yeah I mean this what he did was good

00:31:17,230 --> 00:31:19,830
enough for

00:31:20,390 --> 00:31:23,350
automatic

00:31:26,630 --> 00:31:29,890
soon enough with this thing

00:31:36,110 --> 00:31:41,590
but you know that's an enhancement that

00:31:38,870 --> 00:31:41,590
could come later

00:31:49,550 --> 00:31:54,350
yeah and you know in three years we've

00:31:51,680 --> 00:31:56,120
I've only come across two situations in

00:31:54,350 --> 00:31:59,210
the core distribution where this was

00:31:56,120 --> 00:32:02,180
seriously needed but people here in

00:31:59,210 --> 00:32:05,660
their day jobs maintain code bases that

00:32:02,180 --> 00:32:08,570
are much larger than pearls and then the

00:32:05,660 --> 00:32:15,230
Pearl five core so it might be useful

00:32:08,570 --> 00:32:17,470
there so any other questions thank you

00:32:15,230 --> 00:32:22,230
very much

00:32:17,470 --> 00:32:22,230

YouTube URL: https://www.youtube.com/watch?v=05CwdTRt6AM


