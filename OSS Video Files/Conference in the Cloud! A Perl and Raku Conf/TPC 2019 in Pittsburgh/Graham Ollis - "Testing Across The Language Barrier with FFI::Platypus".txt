Title: Graham Ollis - "Testing Across The Language Barrier with FFI::Platypus"
Publication date: 2019-06-18
Playlist: TPC 2019 in Pittsburgh
Description: 
	This talk is about testing in Perl, Testing (with Test2) and FFI (with FFI::Platypus). At Fastly I work on a component that generates VCL, which gets built as a .so file (dynamic library) which can be called from Perl. I'll be using as an example how I modified the test suite to call into the .so file directly to test the code was generated correctly rather than using regular expressions which were good, but could be fragile and sometimes confused.  I think the technique may have some other applications so I'd like for other Perl developers to see it to help them consider other ways for using Perl and FFI.
Captions: 
	00:00:00,530 --> 00:00:07,230
hello my name is Graham Alice I'm a

00:00:04,200 --> 00:00:10,620
software engineer at fastly an edge

00:00:07,230 --> 00:00:12,240
cloud platform that makes us a content

00:00:10,620 --> 00:00:14,250
delivery network that allows our

00:00:12,240 --> 00:00:18,049
customers to push logic to the edge

00:00:14,250 --> 00:00:18,049
meaning it's Oh

00:00:22,270 --> 00:00:30,990
there we go sorry interesting okay

00:00:51,620 --> 00:00:58,300
well this is a bit annoying okay so

00:00:55,750 --> 00:01:00,739
we're an edge cloud platform which means

00:00:58,300 --> 00:01:03,200
our customers can push logic to the edge

00:01:00,739 --> 00:01:04,850
means their customers get their

00:01:03,200 --> 00:01:09,020
responses faster and their back-end

00:01:04,850 --> 00:01:10,160
servers have a reduced load and I've

00:01:09,020 --> 00:01:11,780
been asked to let you know that we're

00:01:10,160 --> 00:01:13,880
hiring so if you're interested in

00:01:11,780 --> 00:01:20,270
interesting problems you should check us

00:01:13,880 --> 00:01:21,530
out and now we're on here okay so but

00:01:20,270 --> 00:01:24,470
today I want to talk to you about

00:01:21,530 --> 00:01:30,380
testing across the language barrier with

00:01:24,470 --> 00:01:31,729
platypus and we'll be splitting this

00:01:30,380 --> 00:01:34,280
talk up into a few different sections

00:01:31,729 --> 00:01:37,190
first I want to talk to you a little bit

00:01:34,280 --> 00:01:40,100
about FF I in general and platypus in

00:01:37,190 --> 00:01:43,190
particular I'll be talking a little bit

00:01:40,100 --> 00:01:46,460
about code generation unit testing of

00:01:43,190 --> 00:01:47,899
that generated code and at the very end

00:01:46,460 --> 00:01:55,100
we'll talk a little bit about calling

00:01:47,899 --> 00:01:56,539
Perl from C so platypus is this thing

00:01:55,100 --> 00:01:59,630
that I've been working on for a number

00:01:56,539 --> 00:02:03,289
of years and it's a foreign function

00:01:59,630 --> 00:02:07,450
interface so what's an FF I you know in

00:02:03,289 --> 00:02:11,120
the Wikipedia it says it's basically a

00:02:07,450 --> 00:02:13,550
technique that you use to call into a

00:02:11,120 --> 00:02:16,490
different programming language from the

00:02:13,550 --> 00:02:23,110
one that you're using so calling in to

00:02:16,490 --> 00:02:25,790
see from Perl for example but usually

00:02:23,110 --> 00:02:27,140
when we use the term F of I in the

00:02:25,790 --> 00:02:30,230
vernacular we're talking about

00:02:27,140 --> 00:02:32,300
specifically Lib FFI or one of the

00:02:30,230 --> 00:02:35,840
similar libraries that does the same

00:02:32,300 --> 00:02:38,020
thing and Lib FFI is basically just a c

00:02:35,840 --> 00:02:42,349
library that lets you call other

00:02:38,020 --> 00:02:45,560
compiled functions dynamically without a

00:02:42,349 --> 00:02:48,380
compiler and Lib FFI also has this neat

00:02:45,560 --> 00:02:52,870
feature that it lets you call back into

00:02:48,380 --> 00:02:54,860
the host language once you're there and

00:02:52,870 --> 00:02:57,470
platypus is the thing that I've been

00:02:54,860 --> 00:03:02,000
working on for a few years and it's a

00:02:57,470 --> 00:03:04,040
Lib FFI based FF I for Perl it's an

00:03:02,000 --> 00:03:10,290
alternative to

00:03:04,040 --> 00:03:12,270
Perls XS it's and as you expect it lets

00:03:10,290 --> 00:03:14,730
you call compiled languages from pearl

00:03:12,270 --> 00:03:19,140
and then call back into Pearl from those

00:03:14,730 --> 00:03:23,070
languages so why wouldn't you want to

00:03:19,140 --> 00:03:26,270
use XS so Sawyer also already mentioned

00:03:23,070 --> 00:03:30,570
that it's not the greatest API out there

00:03:26,270 --> 00:03:32,940
but briefly the terminology I find that

00:03:30,570 --> 00:03:35,820
is used by XS is a little our little

00:03:32,940 --> 00:03:39,060
alien you know the things like SBS and

00:03:35,820 --> 00:03:40,740
gimme values and X subs and unless

00:03:39,060 --> 00:03:43,980
you're working in the core of Perl you

00:03:40,740 --> 00:03:47,130
probably don't recognize that stuff it's

00:03:43,980 --> 00:03:51,090
written using the C preprocessor really

00:03:47,130 --> 00:03:55,680
heavily so it's difficult to read and to

00:03:51,090 --> 00:04:01,440
debug learning it is time-consuming and

00:03:55,680 --> 00:04:03,570
and difficult there are a bunch of man

00:04:01,440 --> 00:04:07,520
pages that you need to read to really

00:04:03,570 --> 00:04:10,020
understand it this is one of them so

00:04:07,520 --> 00:04:12,650
review that really quickly and we'll get

00:04:10,020 --> 00:04:12,650
on to the next slide

00:04:12,840 --> 00:04:16,920
platypus on the other hand you don't

00:04:15,510 --> 00:04:21,960
have a compiler no problem you don't

00:04:16,920 --> 00:04:23,360
actually need it recent versions of Red

00:04:21,960 --> 00:04:25,380
Hat and Debian actually come with

00:04:23,360 --> 00:04:28,650
packages of platypus you can download

00:04:25,380 --> 00:04:32,390
those and you can call into your your

00:04:28,650 --> 00:04:34,590
libraries directly without any compiler

00:04:32,390 --> 00:04:36,270
you don't have to worry about the pro

00:04:34,590 --> 00:04:39,060
guts you can focus on the language that

00:04:36,270 --> 00:04:41,520
you're calling into it's a little bit

00:04:39,060 --> 00:04:42,900
like writing pure Perl I mean it's not

00:04:41,520 --> 00:04:45,450
pure Perl because you're calling into a

00:04:42,900 --> 00:04:48,960
different language but you can put all

00:04:45,450 --> 00:04:51,000
your code into one script or module you

00:04:48,960 --> 00:04:54,630
don't have to muck around with make

00:04:51,000 --> 00:04:57,630
maker or module built and compared to

00:04:54,630 --> 00:04:59,840
inline C you don't need any temporary

00:04:57,630 --> 00:04:59,840
files

00:05:01,389 --> 00:05:07,509
so I've been working on platypus for a

00:05:03,819 --> 00:05:11,280
while and and now every time I see like

00:05:07,509 --> 00:05:14,199
a DLL a dynamic library I kind of think

00:05:11,280 --> 00:05:15,969
how can I call into that from Perl I

00:05:14,199 --> 00:05:19,349
mean it's just like my brain is we were

00:05:15,969 --> 00:05:21,490
rewired you know I thought it's like I

00:05:19,349 --> 00:05:22,210
see dynamic libraries and they're

00:05:21,490 --> 00:05:25,870
everywhere

00:05:22,210 --> 00:05:28,780
it's really weird but for my for my day

00:05:25,870 --> 00:05:31,050
job I work on a component that among

00:05:28,780 --> 00:05:33,550
other things generates code it generates

00:05:31,050 --> 00:05:37,949
VCL which is varnished configuration

00:05:33,550 --> 00:05:40,240
language it's just a DSL for configuring

00:05:37,949 --> 00:05:43,029
reverse proxies basically so it's really

00:05:40,240 --> 00:05:46,539
useful if you're a content delivery

00:05:43,029 --> 00:05:49,090
network like we are VCL gets translated

00:05:46,539 --> 00:05:51,340
into C which gets compiled and linked

00:05:49,090 --> 00:05:57,400
into a dynamic library which then is

00:05:51,340 --> 00:05:58,659
used by varnish and vcl itself it's it's

00:05:57,400 --> 00:06:00,069
kind of just a normal programming

00:05:58,659 --> 00:06:01,810
language in some ways it's got you know

00:06:00,069 --> 00:06:10,300
logic and variables it's also got some

00:06:01,810 --> 00:06:13,150
domain-specific structures like ACLs so

00:06:10,300 --> 00:06:15,430
so just as an example say we have this

00:06:13,150 --> 00:06:21,400
piece of this template which generates

00:06:15,430 --> 00:06:23,860
an ACL and we have some IP addresses or

00:06:21,400 --> 00:06:25,419
masks IP masks that we want to match and

00:06:23,860 --> 00:06:30,189
some that we don't want to match and

00:06:25,419 --> 00:06:33,729
then we've got a subroutine which if if

00:06:30,189 --> 00:06:37,330
the client IP matches the ACL it'll

00:06:33,729 --> 00:06:38,529
return pipe pipe means it sends the

00:06:37,330 --> 00:06:41,409
connection directly to the back-end

00:06:38,529 --> 00:06:44,080
server so we're not really interested

00:06:41,409 --> 00:06:45,939
interested in the subroutine itself but

00:06:44,080 --> 00:06:49,620
the fact that you have an ACL and we now

00:06:45,939 --> 00:06:49,620
want to be able to test this template

00:06:50,550 --> 00:06:57,479
this is the generated template so we've

00:06:54,490 --> 00:07:02,259
replaced the template with some actual

00:06:57,479 --> 00:07:04,270
IP addresses and subnet masks so how

00:07:02,259 --> 00:07:08,500
would you in Perl like how would you

00:07:04,270 --> 00:07:11,459
test this maybe so let's talk a little

00:07:08,500 --> 00:07:11,459
bit about unit tests

00:07:12,079 --> 00:07:16,819
well it's pearl so we're probably gonna

00:07:14,119 --> 00:07:22,459
use regular expressions right so here we

00:07:16,819 --> 00:07:26,419
slurp in the generated code we sort of

00:07:22,459 --> 00:07:27,499
get the ACL and we parse out the IP

00:07:26,419 --> 00:07:29,569
addresses that we're interested in and

00:07:27,499 --> 00:07:31,149
we see that they match or not there's a

00:07:29,569 --> 00:07:34,039
couple of problems here right because

00:07:31,149 --> 00:07:35,989
you have to match the exact how the IP

00:07:34,039 --> 00:07:37,639
IPs were specified like if it's

00:07:35,989 --> 00:07:42,739
localhost you have to say localhost you

00:07:37,639 --> 00:07:44,869
can't match like a one 2700 one and you

00:07:42,739 --> 00:07:47,509
can't really match like if a particular

00:07:44,869 --> 00:07:50,689
address matches one of the the net masks

00:07:47,509 --> 00:07:54,110
in the list so it's a little limited but

00:07:50,689 --> 00:07:55,939
you know it does test something and we

00:07:54,110 --> 00:08:00,519
run the test and it passes that so

00:07:55,939 --> 00:08:05,110
that's good so but another problem is

00:08:00,519 --> 00:08:07,339
what if you comment out the ACL right

00:08:05,110 --> 00:08:10,759
because sometimes you do that right your

00:08:07,339 --> 00:08:12,469
refactoring code and you comment

00:08:10,759 --> 00:08:14,749
something out and you have a big test

00:08:12,469 --> 00:08:16,009
suite so you may forgotten this part of

00:08:14,749 --> 00:08:20,329
the test I mean that's kind of the point

00:08:16,009 --> 00:08:22,699
of a large regression suite right well

00:08:20,329 --> 00:08:26,659
it still passes the test so that's a

00:08:22,699 --> 00:08:28,399
little unfortunate right so what we

00:08:26,659 --> 00:08:33,500
really want to do is we want to be able

00:08:28,399 --> 00:08:36,559
to load that VCL in perl and write run

00:08:33,500 --> 00:08:43,669
tests against the ACL in our tests

00:08:36,559 --> 00:08:46,459
itself so one way we can do that

00:08:43,669 --> 00:08:50,769
remember VCL gets compiled to see and i

00:08:46,459 --> 00:08:53,689
can call see from Perl this is my thing

00:08:50,769 --> 00:08:55,160
again I see dynamic libraries and I

00:08:53,689 --> 00:08:57,740
always want to call in to them so I was

00:08:55,160 --> 00:08:59,809
working on these things for a while and

00:08:57,740 --> 00:09:06,110
this is this was finally my chance to do

00:08:59,809 --> 00:09:10,279
that so varnish has a function that lets

00:09:06,110 --> 00:09:13,149
you test a match on an ACL you give it a

00:09:10,279 --> 00:09:16,569
context context is the the connection

00:09:13,149 --> 00:09:19,129
that it's working on give it the ACL and

00:09:16,569 --> 00:09:22,429
the IP address that you want to test and

00:09:19,129 --> 00:09:24,790
it returns a true or false if it matches

00:09:22,429 --> 00:09:24,790
or not

00:09:25,930 --> 00:09:30,170
and so now we kind of the building

00:09:28,220 --> 00:09:34,819
blocks we can call that function with

00:09:30,170 --> 00:09:37,399
our object from Pearl so this this sort

00:09:34,819 --> 00:09:39,079
of builds the ACL object in Pearl but

00:09:37,399 --> 00:09:40,990
the part that we're from an FOI

00:09:39,079 --> 00:09:42,769
perspective that we're interested in is

00:09:40,990 --> 00:09:46,730
creating the wrapper around that

00:09:42,769 --> 00:09:50,600
function so with platypus when you are

00:09:46,730 --> 00:09:52,730
writing a binding to a c function or

00:09:50,600 --> 00:09:54,079
another compiled language you kind of

00:09:52,730 --> 00:09:56,779
need three things you need the name of

00:09:54,079 --> 00:10:01,579
the function the argument types that it

00:09:56,779 --> 00:10:04,430
takes and the return value and so here

00:10:01,579 --> 00:10:08,600
just the the platypus lingo we use

00:10:04,430 --> 00:10:12,430
opaque for pointers and a string should

00:10:08,600 --> 00:10:12,430
be obvious and an integer is an integer

00:10:12,970 --> 00:10:22,399
and so now we can actually write our

00:10:15,439 --> 00:10:26,810
testing tools so it's this is kind of

00:10:22,399 --> 00:10:29,779
boilerplate we take in an ACL name and

00:10:26,810 --> 00:10:38,420
the IP address we want to match against

00:10:29,779 --> 00:10:41,660
we've got a test name and we look for

00:10:38,420 --> 00:10:43,250
the ACL see if it exists in the VCL if

00:10:41,660 --> 00:10:44,449
it doesn't then obviously the test

00:10:43,250 --> 00:10:48,110
should fail because you don't have an

00:10:44,449 --> 00:10:50,569
ACL with that IP address if it does

00:10:48,110 --> 00:10:53,269
exist then we test the match if it

00:10:50,569 --> 00:10:57,589
matches then we pass and if it doesn't

00:10:53,269 --> 00:10:59,420
we fail and if you remember in the test

00:10:57,589 --> 00:11:01,970
we also had some hasn't calls so if

00:10:59,420 --> 00:11:04,100
something doesn't match the ACL and you

00:11:01,970 --> 00:11:07,000
can do the same thing but with the

00:11:04,100 --> 00:11:07,000
reverse logic at the end

00:11:08,420 --> 00:11:13,410
so this is um Pat I'm running the test

00:11:11,459 --> 00:11:17,730
that I showed you before and we passed

00:11:13,410 --> 00:11:22,139
and and so what now if we go back and we

00:11:17,730 --> 00:11:26,569
comment out the ACL again the test fails

00:11:22,139 --> 00:11:26,569
so that's that's what we want to see

00:11:34,650 --> 00:11:39,690
so the other thing that I wanted to show

00:11:36,840 --> 00:11:44,460
you was an example of calling into Pearl

00:11:39,690 --> 00:11:49,590
from sea so I've written a library test

00:11:44,460 --> 00:11:51,270
two tools FFI which is used for testing

00:11:49,590 --> 00:11:53,820
dynamic libraries really but it comes

00:11:51,270 --> 00:12:01,350
bundled with this tool that library that

00:11:53,820 --> 00:12:03,890
I wrote called Lib to-to-to Lib t2t it's

00:12:01,350 --> 00:12:06,630
basically just a wrapper around the

00:12:03,890 --> 00:12:12,570
Chad's test tool to stuff so that it

00:12:06,630 --> 00:12:15,270
sends events basically to the the test

00:12:12,570 --> 00:12:23,100
to event stream so that you can mix and

00:12:15,270 --> 00:12:26,070
match pearl tests and and tests in C so

00:12:23,100 --> 00:12:27,510
here's a real quick example we've got it

00:12:26,070 --> 00:12:31,020
doesn't test anything useful it just

00:12:27,510 --> 00:12:33,360
demonstrates the test itself we have

00:12:31,020 --> 00:12:39,270
some tests and some Diagnostics some

00:12:33,360 --> 00:12:41,700
should fail some should succeed we've

00:12:39,270 --> 00:12:43,560
got a really simple protest suite that

00:12:41,700 --> 00:12:49,230
wraps or a test script that wraps around

00:12:43,560 --> 00:12:51,330
it so this one's real easy the function

00:12:49,230 --> 00:12:56,700
itself doesn't return any values and it

00:12:51,330 --> 00:12:57,990
doesn't take any arguments so we create

00:12:56,700 --> 00:13:03,150
a function that does that and we call it

00:12:57,990 --> 00:13:05,010
directly we run the test and it fails

00:13:03,150 --> 00:13:07,110
exactly where we expect it to and it

00:13:05,010 --> 00:13:10,200
passes exactly where we expect it to and

00:13:07,110 --> 00:13:13,950
the failures indicate the the lines in

00:13:10,200 --> 00:13:15,930
the C code the file name and lines in

00:13:13,950 --> 00:13:18,750
the C code rather than in the Perl code

00:13:15,930 --> 00:13:21,920
so that gets included in the diagnostic

00:13:18,750 --> 00:13:21,920
which is important for debugging

00:13:23,029 --> 00:13:27,779
so but I want to I want to I'm going to

00:13:25,529 --> 00:13:29,609
use this in VCL right I want to call a

00:13:27,779 --> 00:13:32,519
VCL function and test that it works

00:13:29,609 --> 00:13:37,319
correctly so we've got a an even simpler

00:13:32,519 --> 00:13:40,379
vcl function it just returns pipe when

00:13:37,319 --> 00:13:43,470
you hand that off to to to varnish it

00:13:40,379 --> 00:13:45,119
compiles it into this C and we're not

00:13:43,470 --> 00:13:48,749
really interested in the body itself but

00:13:45,119 --> 00:13:50,519
the function signature tells us that it

00:13:48,749 --> 00:13:58,169
takes a context object and doesn't

00:13:50,519 --> 00:14:02,699
return anything so here we're writing

00:13:58,169 --> 00:14:08,160
some tests in C that will get forwarded

00:14:02,699 --> 00:14:11,220
to the test to framework for us we're

00:14:08,160 --> 00:14:12,839
creating a context object we're running

00:14:11,220 --> 00:14:16,079
the function with that context object

00:14:12,839 --> 00:14:21,899
we're testing the return value and then

00:14:16,079 --> 00:14:23,189
we're just drawing the context but from

00:14:21,899 --> 00:14:24,629
a testing perspective these are the

00:14:23,189 --> 00:14:26,279
three things we're kind of interested in

00:14:24,629 --> 00:14:30,600
you know we use note to send a

00:14:26,279 --> 00:14:33,540
diagnostic to purl and we call the VCL

00:14:30,600 --> 00:14:36,119
function itself and then we use okay to

00:14:33,540 --> 00:14:41,699
test that the return value it came back

00:14:36,119 --> 00:14:44,129
with what we expected and then we can

00:14:41,699 --> 00:14:48,600
use more or less the same Perl code to

00:14:44,129 --> 00:14:51,299
actually call that test function we run

00:14:48,600 --> 00:14:58,610
the tests and and it succeeds so now

00:14:51,299 --> 00:15:01,649
we've tested that function so in summary

00:14:58,610 --> 00:15:05,910
we can use platypus to test generated

00:15:01,649 --> 00:15:09,299
code and we can use platypus to call

00:15:05,910 --> 00:15:12,629
back in to see from callback into pearl

00:15:09,299 --> 00:15:15,360
from see if you're interested in this

00:15:12,629 --> 00:15:18,779
FFI stuff or the other project that i

00:15:15,360 --> 00:15:20,609
work on which is alien you should join

00:15:18,779 --> 00:15:24,209
us on the native Channel and I received

00:15:20,609 --> 00:15:25,799
a pearl that org the other thing is I

00:15:24,209 --> 00:15:29,100
just really like platypuses that's where

00:15:25,799 --> 00:15:30,419
the name why it's called that actually I

00:15:29,100 --> 00:15:33,660
mean I called it because I like

00:15:30,419 --> 00:15:38,190
platypuses but I also liked the idea of

00:15:33,660 --> 00:15:39,720
glueing weird things together using FFI

00:15:38,190 --> 00:15:41,760
and I thought platypus was an

00:15:39,720 --> 00:15:46,410
appropriate name and FFI itself was

00:15:41,760 --> 00:15:50,190
already taken so that's all I have to

00:15:46,410 --> 00:15:53,480
say for today but I have I think I have

00:15:50,190 --> 00:15:53,480
plenty of time for questions

00:16:18,860 --> 00:16:26,450
so the question is can you

00:16:21,980 --> 00:16:28,970
you can call pearl from sea but do you

00:16:26,450 --> 00:16:37,940
have to call pearl to see to back to

00:16:28,970 --> 00:16:43,550
Pearl you so the answer is kind of at

00:16:37,940 --> 00:16:46,550
the moment you you you can so but you'd

00:16:43,550 --> 00:16:48,650
have to so the simple answer is the easy

00:16:46,550 --> 00:16:52,760
thing to do is to call from Pearl to see

00:16:48,650 --> 00:16:55,610
back into Pearl the little sort of more

00:16:52,760 --> 00:16:59,020
correct answer I guess is you can always

00:16:55,610 --> 00:17:01,790
embed you know your Perl interpreter

00:16:59,020 --> 00:17:05,180
into your C application and then call

00:17:01,790 --> 00:17:06,770
using pull into it using pearl but you

00:17:05,180 --> 00:17:08,300
probably need some kind of you probably

00:17:06,770 --> 00:17:10,760
need to do some kind of startup and

00:17:08,300 --> 00:17:12,770
stuff like that so so there's no reason

00:17:10,760 --> 00:17:15,620
why if you have a big C application that

00:17:12,770 --> 00:17:17,420
you couldn't have you know an embedded

00:17:15,620 --> 00:17:19,870
interpreter and use platypus to call

00:17:17,420 --> 00:17:19,870
into it

00:17:30,380 --> 00:17:37,190
yeah that's a good question so sorry the

00:17:32,809 --> 00:17:39,770
question is I mentioned rust you use

00:17:37,190 --> 00:17:43,700
this lip fi as well can can you do the

00:17:39,770 --> 00:17:45,169
same things with C I'm sorry with can

00:17:43,700 --> 00:17:48,590
you call in to rust I think is the

00:17:45,169 --> 00:17:50,840
question from pearl sure so there's some

00:17:48,590 --> 00:17:53,480
there's some documentation on the

00:17:50,840 --> 00:17:56,780
Internet in general in calling rust

00:17:53,480 --> 00:17:59,570
using FF I typed interfaces I wrote some

00:17:56,780 --> 00:18:02,720
I did some simple examples in when I

00:17:59,570 --> 00:18:04,909
wrote platypus there's also one of the

00:18:02,720 --> 00:18:06,500
things platypus has is a sort of a

00:18:04,909 --> 00:18:09,110
plug-in architecture so that you can

00:18:06,500 --> 00:18:11,210
plug in different target languages so

00:18:09,110 --> 00:18:17,150
there's one for rust one for a Fortran

00:18:11,210 --> 00:18:19,309
one for I can't remember now but since

00:18:17,150 --> 00:18:21,650
I'm mostly I'm calling in to see that's

00:18:19,309 --> 00:18:24,850
the bin to focus and I'm actually if

00:18:21,650 --> 00:18:27,950
somebody is interested in refining this

00:18:24,850 --> 00:18:33,020
the the rest plugin is definitely you

00:18:27,950 --> 00:18:35,409
know available for adoption so does

00:18:33,020 --> 00:18:43,090
anybody else have a question

00:18:35,409 --> 00:18:45,350
where's who oh yeah yeah

00:18:43,090 --> 00:18:51,710
let's put any any one more last

00:18:45,350 --> 00:18:54,619
questions all good okay thank you

00:18:51,710 --> 00:18:54,619

YouTube URL: https://www.youtube.com/watch?v=XgzBuGoxWvg


