Title: [Lightning Talk] Josh Rabinowitz - "REDUX: Indexing and Retrieving Data with Perl and SWISH-E"
Publication date: 2019-06-20
Playlist: TPC 2019 in Pittsburgh
Description: 
	SWISH-E is a powerful, fast, and flexible system for building and querying indices. Perl's text handling prowess coupled with SWISH-E's special features and perl API provide a substantial and robust system upon which to build searching systems. This presentation builds on Josh's July 2003 Linux Journal article "How To Index Anything."
Captions: 
	00:00:00,030 --> 00:00:05,160
hello everybody thank you for coming

00:00:02,250 --> 00:00:08,460
today this is a talk I did in Yap CNA in

00:00:05,160 --> 00:00:10,349
2008 about swishy which is a search

00:00:08,460 --> 00:00:15,030
engine written in C that has a Perl API

00:00:10,349 --> 00:00:19,109
for it on CPM this was before leucine

00:00:15,030 --> 00:00:21,539
before elasticsearch so this probably

00:00:19,109 --> 00:00:22,859
think this project is active anymore

00:00:21,539 --> 00:00:26,970
you could still download it and compile

00:00:22,859 --> 00:00:29,310
it but it's not the it's not the end-all

00:00:26,970 --> 00:00:30,840
be-all those search engines anymore so

00:00:29,310 --> 00:00:33,000
we're going to cover the basic usage I

00:00:30,840 --> 00:00:34,500
mentioned a pool a Perl API we'll talk

00:00:33,000 --> 00:00:37,230
about what was expected to be the first

00:00:34,500 --> 00:00:38,460
of the future development and that was

00:00:37,230 --> 00:00:41,489
gonna be called swish three but never

00:00:38,460 --> 00:00:43,500
actually happened so what it is is it

00:00:41,489 --> 00:00:45,780
makes flat file indexes for performing

00:00:43,500 --> 00:00:47,879
full-text searches the searches are very

00:00:45,780 --> 00:00:49,500
fast so it's basically a Dayne it's a

00:00:47,879 --> 00:00:51,420
customized flat file database you could

00:00:49,500 --> 00:00:53,690
look at as that that's optimized for

00:00:51,420 --> 00:00:55,949
searching the creation of the database

00:00:53,690 --> 00:00:58,859
with the reverse index was relatively

00:00:55,949 --> 00:01:00,899
slow so assuming you already had an

00:00:58,859 --> 00:01:02,430
index and in longer talks actually show

00:01:00,899 --> 00:01:04,409
you how to create the index you

00:01:02,430 --> 00:01:06,590
basically create a large XML document

00:01:04,409 --> 00:01:09,630
that describes each document each

00:01:06,590 --> 00:01:10,890
document that you want to index and then

00:01:09,630 --> 00:01:12,990
you pipe that in with a configuration

00:01:10,890 --> 00:01:15,390
file in Lybia graphic showing that so in

00:01:12,990 --> 00:01:17,250
this case this would be configuration

00:01:15,390 --> 00:01:19,439
saying I want to index all the things in

00:01:17,250 --> 00:01:21,420
the HTML directory HTML directory only

00:01:19,439 --> 00:01:23,580
index things ending with HTML and I'm

00:01:21,420 --> 00:01:25,350
going to call the index file how to HTML

00:01:23,580 --> 00:01:26,030
dot index and there would be a second

00:01:25,350 --> 00:01:29,280
father

00:01:26,030 --> 00:01:34,920
well that's unconvenient has it been all

00:01:29,280 --> 00:01:37,340
this time well I'm glad you guys enjoyed

00:01:34,920 --> 00:01:41,659
those slides

00:01:37,340 --> 00:01:45,500
I swear I tested this and now my

00:01:41,659 --> 00:01:51,470
computer's locking up now here we go

00:01:45,500 --> 00:01:53,360
okay let's turn on mirroring because

00:01:51,470 --> 00:01:56,090
otherwise I can't see my slides okay one

00:01:53,360 --> 00:01:59,570
more time can you guys see now apologies

00:01:56,090 --> 00:02:01,610
for the mix-up so again there's the

00:01:59,570 --> 00:02:03,740
configuration file there's an example of

00:02:01,610 --> 00:02:04,789
how you would create the index based on

00:02:03,740 --> 00:02:06,079
the configuration file you're saying

00:02:04,789 --> 00:02:08,060
create an index with that configuration

00:02:06,079 --> 00:02:09,830
file here's a pretty picture showing it

00:02:08,060 --> 00:02:12,170
you stuff in your in HTML files you

00:02:09,830 --> 00:02:13,430
stuff in your configuration file wait a

00:02:12,170 --> 00:02:15,519
certain amount of time and a little

00:02:13,430 --> 00:02:18,110
common index which is a pair of files

00:02:15,519 --> 00:02:20,019
here's another pretty picture you could

00:02:18,110 --> 00:02:23,750
also use a custom translation program

00:02:20,019 --> 00:02:26,299
HTML is often considered if your file is

00:02:23,750 --> 00:02:28,489
formal is actually XHTML then it can be

00:02:26,299 --> 00:02:30,019
parsed by the XML parser if it's not

00:02:28,489 --> 00:02:31,849
then you have to actually convert it

00:02:30,019 --> 00:02:33,349
into an XML format that's what this

00:02:31,849 --> 00:02:34,819
custom translation program would do then

00:02:33,349 --> 00:02:35,780
you would feed it with swishy with the

00:02:34,819 --> 00:02:38,630
configuration file and you get your

00:02:35,780 --> 00:02:41,000
index so here's an example of us

00:02:38,630 --> 00:02:43,579
actually doing a search on a swishy

00:02:41,000 --> 00:02:46,160
index we're saying search on that index

00:02:43,579 --> 00:02:48,680
give me a maximum 3 results and I want

00:02:46,160 --> 00:02:52,430
to search on the word NFS here's an

00:02:48,680 --> 00:02:54,769
actual result that I got back it did

00:02:52,430 --> 00:02:55,970
handle and/or and pent the parents that

00:02:54,769 --> 00:02:58,280
a group English if you've ever been down

00:02:55,970 --> 00:02:59,810
this road isn't particularly simple so

00:02:58,280 --> 00:03:01,280
here's some examples of and ORS and

00:02:59,810 --> 00:03:03,170
parenthetic grouping searches so this

00:03:01,280 --> 00:03:05,959
last search there would search for

00:03:03,170 --> 00:03:08,480
documents that mention Gandalf and Frodo

00:03:05,959 --> 00:03:11,450
or Lord and Rings you can see where

00:03:08,480 --> 00:03:14,000
that's going so there's a Perl API I

00:03:11,450 --> 00:03:15,709
think it's still on C pen that's just

00:03:14,000 --> 00:03:17,389
like you'd expect you can open it index

00:03:15,709 --> 00:03:19,160
you can perform searches you can iterate

00:03:17,389 --> 00:03:20,840
over results pull down result sets you

00:03:19,160 --> 00:03:22,160
cannot create indexes through the API

00:03:20,840 --> 00:03:24,680
you have to do that directly with the C

00:03:22,160 --> 00:03:26,450
program and configuration files and

00:03:24,680 --> 00:03:27,650
maybe your own external program which is

00:03:26,450 --> 00:03:30,560
often written in Perl that doesn't have

00:03:27,650 --> 00:03:32,269
to be so there were some shortcomings to

00:03:30,560 --> 00:03:35,000
swishy which are actually probably a lot

00:03:32,269 --> 00:03:38,359
of why it never went any farther it did

00:03:35,000 --> 00:03:41,209
not handle utf-8 you could put in utf-8

00:03:38,359 --> 00:03:42,500
and it would look for knowles when it

00:03:41,209 --> 00:03:44,840
did searches but then you would lose all

00:03:42,500 --> 00:03:46,280
the lower casing and all the stemming

00:03:44,840 --> 00:03:48,590
and all the english things that you

00:03:46,280 --> 00:03:51,140
could do so it didn't it didn't handle

00:03:48,590 --> 00:03:54,320
multi by characters there was no

00:03:51,140 --> 00:03:56,000
update indexes there did become a way of

00:03:54,320 --> 00:03:57,620
merging indexes so you could make like a

00:03:56,000 --> 00:03:58,820
partial index of one and a partial index

00:03:57,620 --> 00:04:00,680
apart two and then merge them together

00:03:58,820 --> 00:04:02,090
at search time and then replace part two

00:04:00,680 --> 00:04:05,090
if you wanted and I've actually done

00:04:02,090 --> 00:04:06,440
that in production environments and it

00:04:05,090 --> 00:04:07,760
was not platform independent which is a

00:04:06,440 --> 00:04:10,820
real bummer because if he created an

00:04:07,760 --> 00:04:12,710
index and 100's the safe was big endian

00:04:10,820 --> 00:04:13,880
you could not run the index on little

00:04:12,710 --> 00:04:15,530
endian ones

00:04:13,880 --> 00:04:17,900
so Peter Carmen was gonna write up

00:04:15,530 --> 00:04:20,239
switch 3 he was gonna add multiple utf-8

00:04:17,900 --> 00:04:21,739
multiple backends I don't think it ever

00:04:20,239 --> 00:04:23,270
got into fedora but it did get enough

00:04:21,739 --> 00:04:27,530
ink in debian maybe you guys remember

00:04:23,270 --> 00:04:29,600
think and it doesn't do platform

00:04:27,530 --> 00:04:30,890
independent indexes there are two papers

00:04:29,600 --> 00:04:32,750
on this subject the one that was

00:04:30,890 --> 00:04:33,890
published with Hughes Nix and one that

00:04:32,750 --> 00:04:37,040
was a Linux journal they're both

00:04:33,890 --> 00:04:39,669
available at that fuller and for kicks

00:04:37,040 --> 00:04:42,080
and giggles this is that folder and

00:04:39,669 --> 00:04:46,550
there are a series of documents in there

00:04:42,080 --> 00:04:48,110
including the one which was on the the

00:04:46,550 --> 00:04:49,550
purl journal article excuse me this was

00:04:48,110 --> 00:04:52,679
a Langstrom thank you

00:04:49,550 --> 00:04:52,679

YouTube URL: https://www.youtube.com/watch?v=xr7FforJwOs


