Title: Uri Guttman - "Perl Begat Perl"
Publication date: 2019-06-18
Playlist: TPC 2019 in Pittsburgh
Description: 
	Have you ever wondered why some CPAN modules actually generate Perl code to be eval'ed? Some of the reasons are simplicity but most often it is for getting faster running code. The key Perl feature used is eval on strings (the dangerous eval, not the safe eval of blocks). Newbies are always warned not to use string eval but this talk will show you why and how to use it for your benefit. Simple and common examples will be shown that anyone can use. Then more complex examples from existing CPAN modules (two of which are by the speaker) will be covered. They use Perl code generation for major speed gains (including 4x in one case).
Captions: 
	00:00:00,110 --> 00:00:13,620
okay we are starting please have your

00:00:03,210 --> 00:00:16,020
seats fasten your seat belts this this

00:00:13,620 --> 00:00:17,490
is about purl begat peril now the person

00:00:16,020 --> 00:00:22,949
would really be got pearl is back there

00:00:17,490 --> 00:00:26,220
but okay so what is begat we all know

00:00:22,949 --> 00:00:28,170
Emma no not know the word began okay

00:00:26,220 --> 00:00:31,920
y'all know the word begets good its

00:00:28,170 --> 00:00:34,980
pearl begat is the biblical term for

00:00:31,920 --> 00:00:42,030
making any generation and in chronicles

00:00:34,980 --> 00:00:47,010
1 chapter 2 verse 20 I was begats and

00:00:42,030 --> 00:00:50,489
I'd begat bezel ill I was we got sixty

00:00:47,010 --> 00:00:52,050
two years ago tomorrow my birthday so on

00:00:50,489 --> 00:00:54,870
the cruise tomorrow I'm gonna hear happy

00:00:52,050 --> 00:00:57,329
birthday all words that be got 5,000

00:00:54,870 --> 00:00:59,399
years ago well Larry was the generate

00:00:57,329 --> 00:01:05,339
what's the you know how far back does

00:00:59,399 --> 00:01:08,880
that go okay fine I agree with you you

00:01:05,339 --> 00:01:10,590
can't trust anything in the Bible this

00:01:08,880 --> 00:01:13,890
talk is about pearl generating pearl or

00:01:10,590 --> 00:01:18,360
really calling eval string who has never

00:01:13,890 --> 00:01:20,520
called eval string really okay that's

00:01:18,360 --> 00:01:22,500
cool I mean I means we have a pretty

00:01:20,520 --> 00:01:24,000
sophisticated audience here and we know

00:01:22,500 --> 00:01:26,580
I could skip through a lot of this stuff

00:01:24,000 --> 00:01:29,189
quickly that's important okay what is

00:01:26,580 --> 00:01:32,610
eval it's a function apparel evaluates

00:01:29,189 --> 00:01:36,360
an expression in string context as Perl

00:01:32,610 --> 00:01:38,369
code the compiler executes the string of

00:01:36,360 --> 00:01:41,220
Perl at runtime not compiled times you

00:01:38,369 --> 00:01:42,360
can call it anytime you want it returns

00:01:41,220 --> 00:01:45,329
the value of the expression

00:01:42,360 --> 00:01:50,759
it catches any syntax or runtime errors

00:01:45,329 --> 00:01:54,840
or died calls history of evo list had

00:01:50,759 --> 00:01:57,030
eval 1958 I was born 57 so we're talking

00:01:54,840 --> 00:01:58,460
a long time ago so it's not a new

00:01:57,030 --> 00:02:00,960
concept at all

00:01:58,460 --> 00:02:03,600
almost every dynamic language we know

00:02:00,960 --> 00:02:06,299
has some version of eval there's just a

00:02:03,600 --> 00:02:07,560
short list and I found a Wikipedia

00:02:06,299 --> 00:02:09,390
article in Evo which I learned about

00:02:07,560 --> 00:02:12,480
Lisp and having in 1950 I knew list had

00:02:09,390 --> 00:02:14,790
it but I didn't rise how early it had it

00:02:12,480 --> 00:02:15,510
it's kind of fun article not that you

00:02:14,790 --> 00:02:18,900
have to read it

00:02:15,510 --> 00:02:20,970
okay so pearl for needed eval to do some

00:02:18,900 --> 00:02:23,010
complex data engineering and had similar

00:02:20,970 --> 00:02:25,319
symbolic references or did not have hard

00:02:23,010 --> 00:02:27,989
references the building up nested

00:02:25,319 --> 00:02:31,890
structures was very difficult I wrote a

00:02:27,989 --> 00:02:35,040
Perl for project that did a data tree in

00:02:31,890 --> 00:02:38,790
a single array using sim refs and eval

00:02:35,040 --> 00:02:41,430
all kinds of nasty stuff so eval string

00:02:38,790 --> 00:02:45,480
receive out block now this is one of

00:02:41,430 --> 00:02:48,030
Larry's few mistakes there's a need to

00:02:45,480 --> 00:02:49,200
just catch fatal errors and die calls so

00:02:48,030 --> 00:02:51,360
even though block was put in for that

00:02:49,200 --> 00:02:53,099
purpose and he called it eval because it

00:02:51,360 --> 00:02:55,530
sounded similar to the eval string which

00:02:53,099 --> 00:02:58,530
is catching dies and fatals but it

00:02:55,530 --> 00:03:01,079
didn't execute the code that comment'

00:02:58,530 --> 00:03:03,560
i'm and executed at compile time so

00:03:01,079 --> 00:03:05,910
that's the big difference

00:03:03,560 --> 00:03:08,069
syntax errors reported with regular code

00:03:05,910 --> 00:03:09,450
time and it shouldn't call the different

00:03:08,069 --> 00:03:11,160
name like tri or something other

00:03:09,450 --> 00:03:14,640
languages have it so it's a very

00:03:11,160 --> 00:03:18,989
different eval string so eval we all

00:03:14,640 --> 00:03:21,239
know it's evil it's too easy to shoot

00:03:18,989 --> 00:03:23,639
yourself in your foot and other body

00:03:21,239 --> 00:03:27,870
parts whatever part you like the most

00:03:23,639 --> 00:03:29,760
you'll shoot yourself in that and it's

00:03:27,870 --> 00:03:31,049
not nearly needed as much as pro/5 as

00:03:29,760 --> 00:03:33,569
hard references so the whole thing of

00:03:31,049 --> 00:03:38,579
building a data tree is so much easier

00:03:33,569 --> 00:03:40,290
in perl 5 but it's still useful as going

00:03:38,579 --> 00:03:43,410
backwards there we go newbies feel it's

00:03:40,290 --> 00:03:45,329
a neat trick i teaches a line you can

00:03:43,410 --> 00:03:48,450
use I teach newbies you can use eval or

00:03:45,329 --> 00:03:51,840
sim refs until you know when not to use

00:03:48,450 --> 00:03:53,519
them it's a you know they think oh I'll

00:03:51,840 --> 00:03:54,569
use eval that's like the first thing

00:03:53,519 --> 00:03:56,700
they think of when they learn them eval

00:03:54,569 --> 00:03:58,200
they start using it and sim rest it's

00:03:56,700 --> 00:03:59,670
crazy then and neither one that's

00:03:58,200 --> 00:04:02,130
usually needed especially at newbie

00:03:59,670 --> 00:04:05,519
level code so eval can bring out the

00:04:02,130 --> 00:04:07,410
stupid now you're all sitting down this

00:04:05,519 --> 00:04:09,590
next line is going to burn your eyeballs

00:04:07,410 --> 00:04:09,590
out

00:04:10,959 --> 00:04:18,070
I was giving this by someone in London

00:04:15,489 --> 00:04:20,320
pearl mongers list and it apparently his

00:04:18,070 --> 00:04:21,759
real code somebody wrote and here's the

00:04:20,320 --> 00:04:23,949
best part about it's really fun you

00:04:21,759 --> 00:04:26,410
could take out the eval it still works

00:04:23,949 --> 00:04:26,949
you could take out the system it still

00:04:26,410 --> 00:04:29,020
works

00:04:26,949 --> 00:04:32,770
you can take a valid system it still

00:04:29,020 --> 00:04:37,120
works beli that that's a great line of

00:04:32,770 --> 00:04:39,400
code it's just wow that's some person

00:04:37,120 --> 00:04:41,500
I'm trying to think what were they

00:04:39,400 --> 00:04:43,630
thinking I don't know how they came up

00:04:41,500 --> 00:04:45,190
with doing this figure I didn't know

00:04:43,630 --> 00:04:48,729
sleepers built in the Pearl I got that

00:04:45,190 --> 00:04:49,090
so why call I was a news she'll sad

00:04:48,729 --> 00:04:51,130
silly

00:04:49,090 --> 00:04:53,199
so why calls he calls system great okay

00:04:51,130 --> 00:04:55,270
now why would he need eval on top of

00:04:53,199 --> 00:04:56,949
that the system is built island maybe

00:04:55,270 --> 00:04:59,410
it's our system was another language -

00:04:56,949 --> 00:05:01,539
and I thought eval would miss system is

00:04:59,410 --> 00:05:04,440
in Perl here it's a know what they're

00:05:01,539 --> 00:05:06,610
thinking but eval is not always evil

00:05:04,440 --> 00:05:08,889
there's some for good reason so there's

00:05:06,610 --> 00:05:10,900
others to use eval string the

00:05:08,889 --> 00:05:15,849
convenience do the impossible

00:05:10,900 --> 00:05:17,620
s with lots of ease and speed so if I

00:05:15,849 --> 00:05:19,240
string for convenience who's ever

00:05:17,620 --> 00:05:20,860
learned of the module dynamically at

00:05:19,240 --> 00:05:23,680
runtime I mean it's a pretty common

00:05:20,860 --> 00:05:25,539
thing but it's a real pain because it

00:05:23,680 --> 00:05:28,090
takes a class name only at compile time

00:05:25,539 --> 00:05:30,039
you say require class name with no

00:05:28,090 --> 00:05:31,599
quotes or anything it'll work but I've

00:05:30,039 --> 00:05:33,490
done a compile time and you want to have

00:05:31,599 --> 00:05:36,039
a database or something telling you load

00:05:33,490 --> 00:05:39,310
of a polymorphic module which I've done

00:05:36,039 --> 00:05:41,380
many times you can't do that so require

00:05:39,310 --> 00:05:43,300
to take a file name at runtime but you

00:05:41,380 --> 00:05:45,789
have to take the class name and you have

00:05:43,300 --> 00:05:48,009
to among the quote that the colons the

00:05:45,789 --> 00:05:49,870
slash appended p.m. and maybe do some

00:05:48,009 --> 00:05:52,780
other things it's that's three or four

00:05:49,870 --> 00:05:54,520
lines of code annoying so much

00:05:52,780 --> 00:05:56,380
convenient to use an eval string and

00:05:54,520 --> 00:05:58,090
this works beautifully and I've done

00:05:56,380 --> 00:05:59,380
this many times ever seen this line of

00:05:58,090 --> 00:06:01,960
codes who's seen this line of code

00:05:59,380 --> 00:06:04,419
before yeah okay so that's the standard

00:06:01,960 --> 00:06:08,530
way it's even documented as a way of

00:06:04,419 --> 00:06:10,120
doing it okay so it's not an obscure you

00:06:08,530 --> 00:06:13,770
know don't do this kind of thing it's

00:06:10,120 --> 00:06:18,699
actually in the documentation to require

00:06:13,770 --> 00:06:20,560
how here do the impossible TR which is a

00:06:18,699 --> 00:06:23,229
really neat operator does not

00:06:20,560 --> 00:06:24,330
interpolate so you want to do a TR but

00:06:23,229 --> 00:06:26,669
you want to have

00:06:24,330 --> 00:06:28,259
you know select the text the characters

00:06:26,669 --> 00:06:31,319
we translated from under the other I say

00:06:28,259 --> 00:06:32,550
translate it not transliterated Larry

00:06:31,319 --> 00:06:37,800
Knight disagree in that one

00:06:32,550 --> 00:06:39,569
so here this works you eval the TR you

00:06:37,800 --> 00:06:41,960
can interpolate the from string the

00:06:39,569 --> 00:06:46,610
phone characters and the two characters

00:06:41,960 --> 00:06:46,610
so you're doing the impossible with eval

00:06:47,330 --> 00:06:51,539
everyone get this one this is really

00:06:50,099 --> 00:06:53,340
neat stuff you can do this one things

00:06:51,539 --> 00:06:56,629
where eval comes into play you really

00:06:53,340 --> 00:07:01,379
want to do something no that's tricky

00:06:56,629 --> 00:07:03,509
now a vow string and substitute the Iman

00:07:01,379 --> 00:07:05,810
afire who has never used the even /e

00:07:03,509 --> 00:07:08,659
modifier and substitute never used it

00:07:05,810 --> 00:07:12,240
okay everyone else has used it really

00:07:08,659 --> 00:07:13,830
okay that's cool we all know what it

00:07:12,240 --> 00:07:16,169
does then I'll go quickly it makes a

00:07:13,830 --> 00:07:18,719
replacement part of the string a Perl

00:07:16,169 --> 00:07:21,330
expression and then evaluates that or it

00:07:18,719 --> 00:07:22,289
turns that value for the replacement the

00:07:21,330 --> 00:07:25,860
expressions value do this as a

00:07:22,289 --> 00:07:27,840
replacement string it's not exactly eval

00:07:25,860 --> 00:07:30,650
strings its syntax checked a compiled

00:07:27,840 --> 00:07:33,210
time it's really more like eval block

00:07:30,650 --> 00:07:36,389
but his example I use some templates

00:07:33,210 --> 00:07:39,300
simple there are placed in part in this

00:07:36,389 --> 00:07:41,069
expression is a recursive call which is

00:07:39,300 --> 00:07:43,740
really fun some each means that this

00:07:41,069 --> 00:07:46,110
eval is calling other evals below which

00:07:43,740 --> 00:07:49,849
parses the match text and returns a

00:07:46,110 --> 00:07:51,919
string reference so the first line

00:07:49,849 --> 00:07:55,529
basically there's a regular expression

00:07:51,919 --> 00:07:57,990
include re and using braces as the

00:07:55,529 --> 00:07:59,659
delimiter so the bottom line is the

00:07:57,990 --> 00:08:02,310
actual return expression i'm

00:07:59,659 --> 00:08:04,379
dereferencing the call to get template

00:08:02,310 --> 00:08:08,069
of dollar one which is the part I just

00:08:04,379 --> 00:08:09,539
matched and then I have the e operator e

00:08:08,069 --> 00:08:10,949
modify at the end which means the whole

00:08:09,539 --> 00:08:12,900
thing here is just the Perl expression

00:08:10,949 --> 00:08:16,830
but this is not string eval there's a

00:08:12,900 --> 00:08:22,639
block eval basically but there's more

00:08:16,830 --> 00:08:25,919
what about /ee anyway we've seen this

00:08:22,639 --> 00:08:27,590
well somewhat play with it one time and

00:08:25,919 --> 00:08:31,110
they found that it actually works

00:08:27,590 --> 00:08:35,520
there's not intended not designed not

00:08:31,110 --> 00:08:38,070
anything it actually works the first is

00:08:35,520 --> 00:08:42,240
as we described before it's a block

00:08:38,070 --> 00:08:48,210
evo ii ii is actually a string evil of

00:08:42,240 --> 00:08:53,580
their turn value of the first eek and it

00:08:48,210 --> 00:08:56,460
has its rare uses here's a code one a

00:08:53,580 --> 00:08:59,940
wacky temp later this replace any dollar

00:08:56,460 --> 00:09:02,130
token dollar a dollar some word with the

00:08:59,940 --> 00:09:06,210
value of the same name scalar in your

00:09:02,130 --> 00:09:08,270
current scope and we follow this

00:09:06,210 --> 00:09:12,350
expression here you're grabbing a word

00:09:08,270 --> 00:09:14,850
okay no dollar then some word token and

00:09:12,350 --> 00:09:19,280
replacing with dollar one but dollar one

00:09:14,850 --> 00:09:21,720
is being evaluated okay so basically

00:09:19,280 --> 00:09:23,670
dollar one is gonna be what's grabbed

00:09:21,720 --> 00:09:25,410
and then you can evaluate that again

00:09:23,670 --> 00:09:27,810
that's dollar foo and there's a dollar

00:09:25,410 --> 00:09:29,400
fool in your scope then this token here

00:09:27,810 --> 00:09:35,280
is being replaced by the value of dollar

00:09:29,400 --> 00:09:39,860
foo it's it's a weird little temp later

00:09:35,280 --> 00:09:49,020
but it does work and then what about

00:09:39,860 --> 00:09:51,570
slash three e's iru all adults in the

00:09:49,020 --> 00:09:57,060
room if you do that you should be coding

00:09:51,570 --> 00:10:00,600
in brain if I ever see Triple E on

00:09:57,060 --> 00:10:03,240
an S operator I will you know what I

00:10:00,600 --> 00:10:04,830
want to do okay

00:10:03,240 --> 00:10:08,040
now we're getting some much media stuff

00:10:04,830 --> 00:10:10,520
so hold on to your hats eval string for

00:10:08,040 --> 00:10:13,550
speed by pre-processing sort key

00:10:10,520 --> 00:10:17,130
extractions ever know about sorting

00:10:13,550 --> 00:10:19,560
algorithm Theory sorting is famously n

00:10:17,130 --> 00:10:20,880
log n basically that's an average and

00:10:19,560 --> 00:10:22,800
not gonna go into any details with

00:10:20,880 --> 00:10:25,080
different sorts but typical sorts or n

00:10:22,800 --> 00:10:27,930
log n which means as you grow the amount

00:10:25,080 --> 00:10:31,950
of sort data this sort work grows by the

00:10:27,930 --> 00:10:34,080
order of n times log n okay and we

00:10:31,950 --> 00:10:36,450
follow that when you have multiple key

00:10:34,080 --> 00:10:37,830
or complicated key extractions you could

00:10:36,450 --> 00:10:40,320
factor out that overhead because we're

00:10:37,830 --> 00:10:43,110
sorting every time you access that key

00:10:40,320 --> 00:10:45,840
doing an n log n times that's a lot of

00:10:43,110 --> 00:10:47,460
extra work you could be it's a big speed

00:10:45,840 --> 00:10:49,610
up and you convert that pre-processing

00:10:47,460 --> 00:10:51,560
into a generated code

00:10:49,610 --> 00:10:53,029
doing a lot of sorting on different data

00:10:51,560 --> 00:10:55,430
sets it can really give you a big

00:10:53,029 --> 00:10:57,709
speed-up and thinking the fact they're

00:10:55,430 --> 00:11:00,050
out code will be order n not n log in

00:10:57,709 --> 00:11:05,540
are you're doing it linearly on all the

00:11:00,050 --> 00:11:07,760
data sort maker a module I wrote real

00:11:05,540 --> 00:11:11,000
quick back thing I came up with the

00:11:07,760 --> 00:11:13,279
algorithm for doing sort maker sorting

00:11:11,000 --> 00:11:15,320
with string cashing back when the early

00:11:13,279 --> 00:11:17,990
Pearl conferences and I co-wrote a paper

00:11:15,320 --> 00:11:19,430
with a guy and we won best paper at this

00:11:17,990 --> 00:11:22,190
conference and there's only one reason

00:11:19,430 --> 00:11:25,880
we won best paper Damian Conway didn't

00:11:22,190 --> 00:11:28,519
enter one that year previously I heard

00:11:25,880 --> 00:11:30,950
that he they were reviewing the best

00:11:28,519 --> 00:11:33,050
papers for the award and they couldn't

00:11:30,950 --> 00:11:34,910
pick between two papers and it would

00:11:33,050 --> 00:11:37,040
really stuck on which paper is which

00:11:34,910 --> 00:11:38,360
they were anonymously entered and they

00:11:37,040 --> 00:11:42,380
found out that both were entered by

00:11:38,360 --> 00:11:46,550
Damien so he decided not to enter and

00:11:42,380 --> 00:11:48,860
let me win was as cool of him okay so

00:11:46,550 --> 00:11:50,839
there's four styles of sorting that we

00:11:48,860 --> 00:11:52,160
could generate playing which is no cash

00:11:50,839 --> 00:11:54,050
and that's your standard calling the

00:11:52,160 --> 00:11:56,240
sort operator but this is still useful

00:11:54,050 --> 00:11:57,890
this module because you're not really

00:11:56,240 --> 00:11:59,480
cool and how to write sorts which

00:11:57,890 --> 00:12:01,670
they're doing different things you can

00:11:59,480 --> 00:12:03,350
describe your sort and it'll generate

00:12:01,670 --> 00:12:05,750
code and you can learn how to do it or

00:12:03,350 --> 00:12:08,750
just use the code orcish maneuver is

00:12:05,750 --> 00:12:12,620
when you have an or equals into a hash

00:12:08,750 --> 00:12:15,800
so you're cashing the keys that way okay

00:12:12,620 --> 00:12:17,420
that's why it's orcish or cash bad pun I

00:12:15,800 --> 00:12:19,820
didn't know who was meant at that

00:12:17,420 --> 00:12:21,110
Schwartz ian is invented by our own

00:12:19,820 --> 00:12:24,170
Randall Schwartz who's here this week

00:12:21,110 --> 00:12:26,810
and he cashes the keys are extracted in

00:12:24,170 --> 00:12:28,399
an array and a final version is the

00:12:26,810 --> 00:12:30,050
Guttman Rosso transform until I tell you

00:12:28,399 --> 00:12:33,079
about the article or the paper we wrote

00:12:30,050 --> 00:12:34,790
and that stores the keys and the

00:12:33,079 --> 00:12:37,699
original data and when a single string

00:12:34,790 --> 00:12:39,890
and just called one compare on the whole

00:12:37,699 --> 00:12:42,560
thing saving you a lot more overhead so

00:12:39,890 --> 00:12:44,630
it's the fastest one we're gonna show

00:12:42,560 --> 00:12:46,930
how to generate the schwartzie and

00:12:44,630 --> 00:12:50,560
transform its most illicit of a

00:12:46,930 --> 00:12:52,730
illustrative of code generation so

00:12:50,560 --> 00:12:55,279
regular code that you're executing now

00:12:52,730 --> 00:12:57,620
being yellow the code you're generating

00:12:55,279 --> 00:12:59,870
in various places will be in green

00:12:57,620 --> 00:13:03,140
various amounts of data and blue and

00:12:59,870 --> 00:13:07,100
random other stuff will be in red

00:13:03,140 --> 00:13:09,200
so here is how you actually call sort

00:13:07,100 --> 00:13:12,380
maker mix order is the main subroutine

00:13:09,200 --> 00:13:14,600
your call and we're calling an STS

00:13:12,380 --> 00:13:16,399
watching transform and we're adding an

00:13:14,600 --> 00:13:18,320
option saying we want a reference output

00:13:16,399 --> 00:13:21,130
basically want an array reference for

00:13:18,320 --> 00:13:25,339
the output not just a strain array okay

00:13:21,130 --> 00:13:28,010
now the first key is a string the code

00:13:25,339 --> 00:13:30,820
extraction is just key one and a hash

00:13:28,010 --> 00:13:35,360
and we want no case we want basically no

00:13:30,820 --> 00:13:37,970
no case checking okay and I've learned

00:13:35,360 --> 00:13:40,930
today that I'm sorry that I'm using you

00:13:37,970 --> 00:13:44,390
see I should probably switch it to FC

00:13:40,930 --> 00:13:46,220
maybe one day I'll patch this okay the

00:13:44,390 --> 00:13:47,899
second one is the number amber at the

00:13:46,220 --> 00:13:50,390
code just granting out a key to there's

00:13:47,899 --> 00:13:53,450
a demo thing and it's a descending order

00:13:50,390 --> 00:13:56,050
you'll see why that happens okay now

00:13:53,450 --> 00:13:58,880
here's after code being generated and

00:13:56,050 --> 00:14:00,769
notice it has the map sort map if you

00:13:58,880 --> 00:14:03,170
know store chain transform that's what

00:14:00,769 --> 00:14:06,140
the famous thing the other transforms

00:14:03,170 --> 00:14:08,510
also do map sort map okay you map the

00:14:06,140 --> 00:14:12,339
input you sort on that data and then you

00:14:08,510 --> 00:14:17,180
map the output it's one long expression

00:14:12,339 --> 00:14:19,070
so here is the second comparison notice

00:14:17,180 --> 00:14:21,290
that's got the spaceship operator which

00:14:19,070 --> 00:14:25,130
is the number and the B is left then the

00:14:21,290 --> 00:14:27,790
a is right because we said descending so

00:14:25,130 --> 00:14:32,660
reverse the order of the comparison and

00:14:27,790 --> 00:14:35,149
then I don't like it fine now here the

00:14:32,660 --> 00:14:36,709
turkey extractions basically the

00:14:35,149 --> 00:14:38,870
original key goes in a dollar underscore

00:14:36,709 --> 00:14:42,860
it's coming from dollar underscore and

00:14:38,870 --> 00:14:44,570
then the first the original argument is

00:14:42,860 --> 00:14:47,600
going into dollar underscore and then we

00:14:44,570 --> 00:14:49,790
get key one and then we get key too but

00:14:47,600 --> 00:14:54,740
key one is uppercase because we said no

00:14:49,790 --> 00:14:56,630
case go forward okay there we go

00:14:54,740 --> 00:14:59,390
now here's code that's actually doing

00:14:56,630 --> 00:15:01,970
the generation okay so basically there's

00:14:59,390 --> 00:15:06,649
the main subroutine and the arguments

00:15:01,970 --> 00:15:10,579
coming in come on handing wrong key here

00:15:06,649 --> 00:15:12,620
okay there we go so now we declaring two

00:15:10,579 --> 00:15:15,260
arrays all the comparisons and all the

00:15:12,620 --> 00:15:16,510
extracts and we start with an index of a

00:15:15,260 --> 00:15:19,390
string one

00:15:16,510 --> 00:15:21,640
for indexing into that array and it's a

00:15:19,390 --> 00:15:23,770
string because I'm generating strings

00:15:21,640 --> 00:15:25,270
when it cuts compiled it'll be converted

00:15:23,770 --> 00:15:26,590
back to a number so it says why don't

00:15:25,270 --> 00:15:29,020
use a number here well because I'm

00:15:26,590 --> 00:15:30,100
actually building up strings and it

00:15:29,020 --> 00:15:31,900
could've been a number here where it

00:15:30,100 --> 00:15:34,390
worked too but it would be an extra

00:15:31,900 --> 00:15:36,910
conversion might do it now

00:15:34,390 --> 00:15:38,350
that's what s tiendas so here I'm

00:15:36,910 --> 00:15:41,740
looping over all the keys we have two

00:15:38,350 --> 00:15:44,530
keys coming in and here I build the

00:15:41,740 --> 00:15:46,330
comparison so you see a most high

00:15:44,530 --> 00:15:47,980
backslash da there because I'm not

00:15:46,330 --> 00:15:50,860
looking at the actual a I want text

00:15:47,980 --> 00:15:52,780
dollar a and the end State St int is a

00:15:50,860 --> 00:15:55,180
variable that's being used that's the

00:15:52,780 --> 00:15:57,580
one on both sides and then B is over

00:15:55,180 --> 00:16:01,210
there and here's a CMP comparison

00:15:57,580 --> 00:16:04,060
operator at default through a string but

00:16:01,210 --> 00:16:07,210
look if it's descending I translate a

00:16:04,060 --> 00:16:10,300
and B to be an A now I know this thing

00:16:07,210 --> 00:16:13,740
up here doesn't have any A's and B's

00:16:10,300 --> 00:16:15,760
other than that so this works fine

00:16:13,740 --> 00:16:18,070
modifying the code that I'm using to

00:16:15,760 --> 00:16:20,020
generate it's a neat little trick I

00:16:18,070 --> 00:16:23,230
could have done this a different way by

00:16:20,020 --> 00:16:25,840
having two different possible lines and

00:16:23,230 --> 00:16:30,550
tested that than if-else this is much

00:16:25,840 --> 00:16:33,700
neater and then I switched compared to

00:16:30,550 --> 00:16:35,560
spaceship if it's a number this could

00:16:33,700 --> 00:16:38,560
have been done with a dollar CMP

00:16:35,560 --> 00:16:40,750
variable and maybe a question of our

00:16:38,560 --> 00:16:42,550
colon kind of operator but I was in the

00:16:40,750 --> 00:16:43,380
mood to do substitute so I did it that

00:16:42,550 --> 00:16:47,200
way

00:16:43,380 --> 00:16:49,390
I mean this is the equal now I bumped

00:16:47,200 --> 00:16:51,070
the index for the next key remember it

00:16:49,390 --> 00:16:54,690
starts at one because the zero location

00:16:51,070 --> 00:16:57,400
is the original value we're sorting

00:16:54,690 --> 00:17:00,370
location 1 is the first key location 2

00:16:57,400 --> 00:17:02,470
as the second key and then I store I

00:17:00,370 --> 00:17:07,180
basically store the compares onto an

00:17:02,470 --> 00:17:10,300
array now I build up the extract code

00:17:07,180 --> 00:17:11,890
remember it's still in that loop so the

00:17:10,300 --> 00:17:14,589
extract code it's all this green is

00:17:11,890 --> 00:17:17,290
actual generated code and I have a token

00:17:14,589 --> 00:17:20,199
called extract and there's the use C

00:17:17,290 --> 00:17:23,949
built into it and I get rid of the you

00:17:20,199 --> 00:17:26,050
see if it's basically unless it's a

00:17:23,949 --> 00:17:27,910
string and it's no case for the number I

00:17:26,050 --> 00:17:29,850
get rid of the you see if it's case

00:17:27,910 --> 00:17:34,590
sensitive I get rid of the you see

00:17:29,850 --> 00:17:36,270
and that's here and then I substitute

00:17:34,590 --> 00:17:38,790
the word extract for the actual key to

00:17:36,270 --> 00:17:41,850
get the code this stupid thing should be

00:17:38,790 --> 00:17:43,590
a regular - greater than but impress

00:17:41,850 --> 00:17:45,120
converted it for me and I didn't see

00:17:43,590 --> 00:17:46,920
that one see the ones above it are

00:17:45,120 --> 00:17:49,470
correct I kept doing that I couldn't

00:17:46,920 --> 00:17:51,120
figure out why okay and now I just

00:17:49,470 --> 00:17:52,290
basically chomped that last one just to

00:17:51,120 --> 00:17:54,180
make it look pretty I get rid of the

00:17:52,290 --> 00:17:56,550
newline in the end and I store all the

00:17:54,180 --> 00:17:58,590
extracts so basically we're looping or

00:17:56,550 --> 00:18:03,900
building up compare codes or building up

00:17:58,590 --> 00:18:06,870
extract codes and to erase now I join

00:18:03,900 --> 00:18:09,420
the compare codes and I join them with

00:18:06,870 --> 00:18:11,010
pipe pipe the or operator I put a couple

00:18:09,420 --> 00:18:13,580
of tabs in there and a new line to make

00:18:11,010 --> 00:18:15,930
it look pretty but basically it's

00:18:13,580 --> 00:18:17,280
comparison or comparison or comparison

00:18:15,930 --> 00:18:22,350
and the order you give it that's the

00:18:17,280 --> 00:18:24,690
order of the sort the extracts are just

00:18:22,350 --> 00:18:26,040
join with commas and a new line also to

00:18:24,690 --> 00:18:27,720
make it look a little pretty because

00:18:26,040 --> 00:18:33,060
they're basically just degree an array

00:18:27,720 --> 00:18:36,150
now if the input is going to a reference

00:18:33,060 --> 00:18:37,740
I have to dereference it and we're not

00:18:36,150 --> 00:18:39,120
using an option in this example but if

00:18:37,740 --> 00:18:40,950
it isn't the reference that I use at

00:18:39,120 --> 00:18:43,560
underscore edge itself or I just

00:18:40,950 --> 00:18:47,010
dereference the first location and add

00:18:43,560 --> 00:18:49,200
underscore now because we're doing a

00:18:47,010 --> 00:18:52,440
reference out as we turn on as an

00:18:49,200 --> 00:18:55,680
example I am storing an Open bracket

00:18:52,440 --> 00:18:57,210
close bracket the two brackets and if

00:18:55,680 --> 00:19:01,950
there was no reference out I would have

00:18:57,210 --> 00:19:06,210
used to null strings now here as we

00:19:01,950 --> 00:19:08,450
actually build the actual code look at

00:19:06,210 --> 00:19:11,250
the map sort map just like we had before

00:19:08,450 --> 00:19:13,050
all right there we go okay now there's

00:19:11,250 --> 00:19:16,710
this compare source and there's the

00:19:13,050 --> 00:19:18,480
extract source okay so the map is

00:19:16,710 --> 00:19:20,280
basically a first map here is getting

00:19:18,480 --> 00:19:22,020
the results out of the sort of the array

00:19:20,280 --> 00:19:24,270
which sort with the compare source

00:19:22,020 --> 00:19:27,720
rebuilt and the map of the input is

00:19:24,270 --> 00:19:30,840
again the first location is the original

00:19:27,720 --> 00:19:33,300
data the extract course and then return

00:19:30,840 --> 00:19:35,250
Open bracket that's if we had when I

00:19:33,300 --> 00:19:37,020
returned a reference and returned close

00:19:35,250 --> 00:19:39,390
bracket there and the input is gonna be

00:19:37,020 --> 00:19:41,220
ad underscore or it's going to be D

00:19:39,390 --> 00:19:41,800
referenced at the first location of an

00:19:41,220 --> 00:19:47,590
underscore

00:19:41,800 --> 00:19:49,000
that's generated code and there's a code

00:19:47,590 --> 00:19:51,100
that's being generated the rest are all

00:19:49,000 --> 00:19:56,140
variables that are being interpolated

00:19:51,100 --> 00:19:58,870
into the code but there's more we're

00:19:56,140 --> 00:20:01,720
gonna eval string for pre parsing a

00:19:58,870 --> 00:20:03,850
template and we're following along so

00:20:01,720 --> 00:20:08,100
finding any quick questions we'll have

00:20:03,850 --> 00:20:09,720
time for Q&A afterwards how's my timing

00:20:08,100 --> 00:20:12,070
okay that's good

00:20:09,720 --> 00:20:14,620
okay well look at a template simple for

00:20:12,070 --> 00:20:18,370
recursive Perl code generation this is a

00:20:14,620 --> 00:20:20,500
little more complicated so rendering a

00:20:18,370 --> 00:20:22,120
template whose rendered templates with

00:20:20,500 --> 00:20:25,240
modules and you know most you've been oh

00:20:22,120 --> 00:20:26,860
okay so you have two parts of template

00:20:25,240 --> 00:20:29,950
every time you render it that's a lot of

00:20:26,860 --> 00:20:31,179
overhead some template and some odd

00:20:29,950 --> 00:20:33,520
templates in one some tables could

00:20:31,179 --> 00:20:35,530
compile a template they pre parse it and

00:20:33,520 --> 00:20:38,590
they generate Perl code or some other

00:20:35,530 --> 00:20:40,450
technique it means parsing of Perl code

00:20:38,590 --> 00:20:44,350
parsing the template generating protocol

00:20:40,450 --> 00:20:47,080
that will render it so this is done one

00:20:44,350 --> 00:20:49,090
time and you can call it many times so

00:20:47,080 --> 00:20:50,860
you have a library of templates if you

00:20:49,090 --> 00:20:52,660
pre process them or pre parse them

00:20:50,860 --> 00:20:54,510
you'll save a lot of time rendering all

00:20:52,660 --> 00:20:56,950
your code there anything on your text

00:20:54,510 --> 00:21:00,190
the template simples compiled mode is

00:20:56,950 --> 00:21:02,760
four times faster it's actually want to

00:21:00,190 --> 00:21:06,190
fastest templates you're ever gonna find

00:21:02,760 --> 00:21:09,520
so take a look at it there's a short

00:21:06,190 --> 00:21:11,910
template okay so we use the module and

00:21:09,520 --> 00:21:14,910
we just declared me sign a template and

00:21:11,910 --> 00:21:18,370
the template is this less blue stuff

00:21:14,910 --> 00:21:21,940
okay now anything with a single word is

00:21:18,370 --> 00:21:24,130
a scalar variable of a replacement start

00:21:21,940 --> 00:21:27,790
and mark what's called a chunk which is

00:21:24,130 --> 00:21:30,550
basically a a chunk that we matched onto

00:21:27,790 --> 00:21:34,420
a hash for replacement by its keys and

00:21:30,550 --> 00:21:36,100
the scalars the foo in the bar okay so

00:21:34,420 --> 00:21:38,320
we have a family chunk here but also the

00:21:36,100 --> 00:21:39,370
whole thing is an unnamed chunk we'll

00:21:38,320 --> 00:21:41,080
talk about that a little later

00:21:39,370 --> 00:21:42,929
the top-level is an unnamed chunk and

00:21:41,080 --> 00:21:46,150
then you could have nested recursive

00:21:42,929 --> 00:21:49,630
chunks all you want okay I wouldn't

00:21:46,150 --> 00:21:53,290
understand this right now these are the

00:21:49,630 --> 00:21:55,720
scalar variables being used and then

00:21:53,290 --> 00:21:59,440
okay now here's the data I'm passing

00:21:55,720 --> 00:22:01,570
so foo bar Larry wall foo bar Randall

00:21:59,440 --> 00:22:04,150
and foo bar Danny and man professor and

00:22:01,570 --> 00:22:06,520
it comes out on the Sierra I'm

00:22:04,150 --> 00:22:08,230
dereferencing and template returns

00:22:06,520 --> 00:22:10,390
scaler references all the time because

00:22:08,230 --> 00:22:12,190
faster and passing the strings on it on

00:22:10,390 --> 00:22:13,809
the stack so we do a lot of scalar

00:22:12,190 --> 00:22:16,720
referencing inside the dereferencing

00:22:13,809 --> 00:22:18,760
here's the output Larry is a wall

00:22:16,720 --> 00:22:23,409
rentals the Schwartz and demons and Mad

00:22:18,760 --> 00:22:27,190
Professor that correct Larry okay you're

00:22:23,409 --> 00:22:30,070
a wall okay so here's the generated code

00:22:27,190 --> 00:22:32,799
for that so we have an anonymous sub

00:22:30,070 --> 00:22:35,559
data coming in and this is the main

00:22:32,799 --> 00:22:39,130
output or variable now here's an

00:22:35,559 --> 00:22:41,020
interesting thing we assign the scalar

00:22:39,130 --> 00:22:44,500
data into the array data may loop over

00:22:41,020 --> 00:22:46,809
that basically because templates simple

00:22:44,500 --> 00:22:49,059
allows you to pass not just a hash to

00:22:46,809 --> 00:22:52,690
match an eight chunk you could pass an

00:22:49,059 --> 00:22:54,940
array of hashes and I'll just loop over

00:22:52,690 --> 00:22:57,100
that array there's no loop construct and

00:22:54,940 --> 00:23:00,010
templates simple you just pass in an

00:22:57,100 --> 00:23:05,470
array anytime you want and it works so

00:23:00,010 --> 00:23:08,250
this code here coming up ommm backups

00:23:05,470 --> 00:23:08,250
back back back

00:23:09,120 --> 00:23:14,200
notice I have data here and data below

00:23:11,799 --> 00:23:15,610
there's different scopes and there's a

00:23:14,200 --> 00:23:17,169
reason I keep the word data there

00:23:15,610 --> 00:23:20,710
because we're gonna be nesting and

00:23:17,169 --> 00:23:22,840
recursing and that code is not recursing

00:23:20,710 --> 00:23:25,179
but the logic is recursing so we're

00:23:22,840 --> 00:23:26,500
generating deeper and deeper code and i

00:23:25,179 --> 00:23:28,120
want to use the way the same code

00:23:26,500 --> 00:23:33,100
everywhere try to keep the same name

00:23:28,120 --> 00:23:35,049
everywhere okay so here as we see if the

00:23:33,100 --> 00:23:37,360
data coming in as an array we just

00:23:35,049 --> 00:23:38,950
pushed that data on to the data array i

00:23:37,360 --> 00:23:41,919
mean go back to the loop so basically

00:23:38,950 --> 00:23:43,750
i'm seeing a single thing here just do

00:23:41,919 --> 00:23:46,210
it if not it's an array push it all back

00:23:43,750 --> 00:23:49,330
on to the original this outer at data

00:23:46,210 --> 00:23:52,030
array that way we could just keep doing

00:23:49,330 --> 00:23:54,280
things as if it was as if it's a single

00:23:52,030 --> 00:23:55,659
one or multiply makes no difference for

00:23:54,280 --> 00:24:00,309
that line this you just bit of code

00:23:55,659 --> 00:24:02,980
you'll see several times now we are

00:24:00,309 --> 00:24:05,530
doing the top-level unnamed thing we

00:24:02,980 --> 00:24:08,470
have the title and we have it basically

00:24:05,530 --> 00:24:09,140
it's the data is a hash we'll put it in

00:24:08,470 --> 00:24:11,870
title we have

00:24:09,140 --> 00:24:14,270
hache there if it's no hash it'll use

00:24:11,870 --> 00:24:19,390
the data as it is and there's a new line

00:24:14,270 --> 00:24:22,970
which is part of the actual template now

00:24:19,390 --> 00:24:26,170
we're descending into the tree so the

00:24:22,970 --> 00:24:28,940
array data now is what's under family

00:24:26,170 --> 00:24:32,930
title is a top-level family is a list of

00:24:28,940 --> 00:24:34,910
arrays a list of hashes so Heath

00:24:32,930 --> 00:24:38,390
data equals you're doing the same wild

00:24:34,910 --> 00:24:40,400
data and the same day to equal shift

00:24:38,390 --> 00:24:42,740
data and all that this is the same code

00:24:40,400 --> 00:24:47,960
we had in the first level but we're just

00:24:42,740 --> 00:24:51,380
generating at a deeper level now we

00:24:47,960 --> 00:24:53,690
build the actual chunk and again it's

00:24:51,380 --> 00:24:58,700
either we're using the raw data or it's

00:24:53,690 --> 00:25:02,360
in this case family new line tab is the

00:24:58,700 --> 00:25:05,000
raw text from the template they were

00:25:02,360 --> 00:25:07,430
pending that with the thing in foo

00:25:05,000 --> 00:25:09,020
inside the data and then is a and a

00:25:07,430 --> 00:25:11,180
thing and bar inside the data and then a

00:25:09,020 --> 00:25:18,770
new line we're breaking it up into

00:25:11,180 --> 00:25:21,080
scalars and texts between scalars here's

00:25:18,770 --> 00:25:23,180
the pellets that know this is gonna be

00:25:21,080 --> 00:25:26,540
interesting now the main routine is

00:25:23,180 --> 00:25:30,170
called compiled chunk the top level code

00:25:26,540 --> 00:25:32,060
body and you see here I'm passing in no

00:25:30,170 --> 00:25:34,760
name the first argument is no the top

00:25:32,060 --> 00:25:36,800
level I don't have a name yet included

00:25:34,760 --> 00:25:38,540
is actually the data that the template

00:25:36,800 --> 00:25:40,520
that's been rendered with include files

00:25:38,540 --> 00:25:42,800
your lots a includes something so that's

00:25:40,520 --> 00:25:45,290
all been done before and then we have a

00:25:42,800 --> 00:25:53,660
single tab which is the current intent

00:25:45,290 --> 00:25:58,250
level so here's the entire output my

00:25:53,660 --> 00:26:00,830
data equals the add underscore you're

00:25:58,250 --> 00:26:06,460
declaring out the code body and you're

00:26:00,830 --> 00:26:08,840
returning /out that's it

00:26:06,460 --> 00:26:11,150
notice there's two different slash slash

00:26:08,840 --> 00:26:13,910
dollar outs the first one is just

00:26:11,150 --> 00:26:18,080
declaring dollar out in the generated

00:26:13,910 --> 00:26:19,820
code the second one is returning back

00:26:18,080 --> 00:26:21,560
slash dollar out but you need three back

00:26:19,820 --> 00:26:23,030
slashes there the first two are

00:26:21,560 --> 00:26:25,130
discerning one black slash

00:26:23,030 --> 00:26:30,380
and a set third one is to escape the

00:26:25,130 --> 00:26:35,690
dollar and it's all in one double quoted

00:26:30,380 --> 00:26:38,480
here doc I said before that we return

00:26:35,690 --> 00:26:41,780
and templates simple scalar references

00:26:38,480 --> 00:26:44,960
so that's what this is doing now we get

00:26:41,780 --> 00:26:47,210
to the actual work so compiled chunk

00:26:44,960 --> 00:26:51,740
takes a chunk name the template and the

00:26:47,210 --> 00:26:53,570
current indent level then it sets up at

00:26:51,740 --> 00:26:55,520
a data initialization thing which is you

00:26:53,570 --> 00:26:58,670
have a chunk name then the data is gonna

00:26:55,520 --> 00:27:00,440
be what's in the data name chunk name

00:26:58,670 --> 00:27:03,980
now mind you chunk naming this thing is

00:27:00,440 --> 00:27:05,720
a data variable using right now it would

00:27:03,980 --> 00:27:09,170
say data point the families we saw

00:27:05,720 --> 00:27:10,880
earlier okay but that the data itself is

00:27:09,170 --> 00:27:14,390
being escaped so chunk name is not

00:27:10,880 --> 00:27:17,030
escaped data is escaped those will

00:27:14,390 --> 00:27:18,530
generate data point to family because

00:27:17,030 --> 00:27:21,820
family is the name in that chunk we put

00:27:18,530 --> 00:27:25,070
in earlier they weren't following that

00:27:21,820 --> 00:27:28,130
okay I see nodding heads which is go

00:27:25,070 --> 00:27:30,590
down see shaking heads so here we assign

00:27:28,130 --> 00:27:32,230
the data in it whichever in this case

00:27:30,590 --> 00:27:35,180
would be data point the chunk name and

00:27:32,230 --> 00:27:36,620
we're signing that back into the at data

00:27:35,180 --> 00:27:38,600
again we're scaping things as we go

00:27:36,620 --> 00:27:42,980
notice there's all these indents on the

00:27:38,600 --> 00:27:45,140
left those are all single tabs they were

00:27:42,980 --> 00:27:46,610
looping over the day like we saw and

00:27:45,140 --> 00:27:48,830
this is the same cub you saw earlier be

00:27:46,610 --> 00:27:50,690
we signed single data from the array and

00:27:48,830 --> 00:27:52,730
if there's an array we push it back on

00:27:50,690 --> 00:27:54,410
so that's that generating code for that

00:27:52,730 --> 00:27:57,710
thing we saw earlier in the actual code

00:27:54,410 --> 00:28:01,640
and then we bump the indent to a higher

00:27:57,710 --> 00:28:03,860
level so I want to keep the nested code

00:28:01,640 --> 00:28:05,210
indented nicely what's easier to read

00:28:03,860 --> 00:28:11,360
and you know figure out when you're

00:28:05,210 --> 00:28:13,490
making mistakes now parts name and

00:28:11,360 --> 00:28:15,620
Parvati are results of this regular

00:28:13,490 --> 00:28:17,150
expression and it should say chunk name

00:28:15,620 --> 00:28:19,610
and chunk body I realized that today

00:28:17,150 --> 00:28:21,860
then I'm it's a naming thing I left in

00:28:19,610 --> 00:28:23,990
the code that should be changed so parse

00:28:21,860 --> 00:28:26,060
name is the name of the chunk family in

00:28:23,990 --> 00:28:28,570
this case parse body is the actual

00:28:26,060 --> 00:28:31,000
template inside the start and end

00:28:28,570 --> 00:28:33,620
so we're grabbing those out of the

00:28:31,000 --> 00:28:35,900
current template by using this very

00:28:33,620 --> 00:28:36,490
fancy chunk re expression which is not

00:28:35,900 --> 00:28:39,730
being shown

00:28:36,490 --> 00:28:41,800
now once we have that I get the left and

00:28:39,730 --> 00:28:46,660
the right index of the chunk by using

00:28:41,800 --> 00:28:48,700
who's ever used at - or at plus okay

00:28:46,660 --> 00:28:51,130
they're neat arrays that give you the

00:28:48,700 --> 00:28:55,990
indexes of all the things you've matched

00:28:51,130 --> 00:28:58,600
in a regular expression the - gives you

00:28:55,990 --> 00:29:00,490
the left location of a matched part and

00:28:58,600 --> 00:29:02,560
the plus gives you the right location

00:29:00,490 --> 00:29:05,650
I'm looking the first one because I want

00:29:02,560 --> 00:29:07,540
to get I wanna get the parse body out so

00:29:05,650 --> 00:29:12,010
now I know what the left side and right

00:29:07,540 --> 00:29:13,480
side of the of the chunk is I call

00:29:12,010 --> 00:29:15,310
compiled scalars on the left side

00:29:13,480 --> 00:29:16,960
everything before giving chunk is only

00:29:15,310 --> 00:29:18,460
contain text and scalars because I'm

00:29:16,960 --> 00:29:19,140
looking for the chunk and the irregular

00:29:18,460 --> 00:29:21,670
expression

00:29:19,140 --> 00:29:24,130
so I basically compile the scalars for

00:29:21,670 --> 00:29:26,320
that append it to the code and the text

00:29:24,130 --> 00:29:29,830
I'm passing there is the template that I

00:29:26,320 --> 00:29:32,830
got passed in starting at 0 up to the

00:29:29,830 --> 00:29:36,370
left index just the for the chunk starts

00:29:32,830 --> 00:29:38,500
and I give it the indent so that stub

00:29:36,370 --> 00:29:42,070
sir is the part that's before the

00:29:38,500 --> 00:29:44,830
currently matching chunk then this

00:29:42,070 --> 00:29:46,900
substr deletes that and the template

00:29:44,830 --> 00:29:48,490
because I really have ever at the chunk

00:29:46,900 --> 00:29:50,830
I already have the chunk in parse body

00:29:48,490 --> 00:29:52,750
this basically just saying assigned to

00:29:50,830 --> 00:29:54,400
the template starting at 0 the null

00:29:52,750 --> 00:29:56,500
string and it's just end at the right

00:29:54,400 --> 00:30:01,450
index which is the end of the matched

00:29:56,500 --> 00:30:05,110
chunk so basically we're chopping off

00:30:01,450 --> 00:30:07,390
the template plain text and scalars

00:30:05,110 --> 00:30:11,740
chunk text and scalars chunk text and

00:30:07,390 --> 00:30:13,090
scalars junk in a loop and then here we

00:30:11,740 --> 00:30:15,550
recursively call remember you had that

00:30:13,090 --> 00:30:20,560
real expression before with the with the

00:30:15,550 --> 00:30:22,720
e this is the recursive call that way if

00:30:20,560 --> 00:30:26,080
there's any more nesting chunks we will

00:30:22,720 --> 00:30:27,670
then process those in this thing the

00:30:26,080 --> 00:30:29,800
chunks are marked by starting end with

00:30:27,670 --> 00:30:32,110
the same name so you can have start

00:30:29,800 --> 00:30:37,560
family the la start children and

00:30:32,110 --> 00:30:39,790
children and family this supports that

00:30:37,560 --> 00:30:42,130
and we're basically passing in the name

00:30:39,790 --> 00:30:45,790
we just parsed out the parse body and

00:30:42,130 --> 00:30:49,140
the current indent level and recurse is

00:30:45,790 --> 00:30:49,140
back up to the previous code

00:30:49,330 --> 00:30:54,320
then we have maybe trailing scalars

00:30:52,220 --> 00:30:58,610
after the last chunk and this handles

00:30:54,320 --> 00:31:00,020
that and we chopped the in depth because

00:30:58,610 --> 00:31:03,230
now we're done with that indent level

00:31:00,020 --> 00:31:07,600
we're backing up and then finally I'm

00:31:03,230 --> 00:31:07,600
back here oops

00:31:09,460 --> 00:31:17,240
and here we append the last indent with

00:31:14,870 --> 00:31:21,050
the brace that's the closing brace of

00:31:17,240 --> 00:31:25,100
the generated loop so everything's it

00:31:21,050 --> 00:31:27,650
looks pretty I like pretty good okay

00:31:25,100 --> 00:31:28,940
everything we're doing well here so

00:31:27,650 --> 00:31:32,780
here's some tips and generating Perl

00:31:28,940 --> 00:31:34,310
code make your generate code accessible

00:31:32,780 --> 00:31:37,010
by a method or sub you notice in both

00:31:34,310 --> 00:31:39,410
cases I had either method to print out

00:31:37,010 --> 00:31:41,270
the template generated code or slub

00:31:39,410 --> 00:31:43,820
called sorter source which allows you to

00:31:41,270 --> 00:31:45,350
print out the generated code very

00:31:43,820 --> 00:31:48,500
important when you're doing this kind of

00:31:45,350 --> 00:31:49,070
stuff it's useful for coming and

00:31:48,500 --> 00:31:51,080
debugging

00:31:49,070 --> 00:31:53,000
I mean what did I generate it's blowing

00:31:51,080 --> 00:31:56,240
up on my evil you won't know they look

00:31:53,000 --> 00:31:57,620
at the code you have to do that and it's

00:31:56,240 --> 00:31:59,630
also you sort of cutting and pasting if

00:31:57,620 --> 00:32:02,660
you write a sort routine you like and

00:31:59,630 --> 00:32:04,430
you need it why call the compiler of the

00:32:02,660 --> 00:32:06,110
sort maker in your code just cut and

00:32:04,430 --> 00:32:08,780
paste it and use it in your regular

00:32:06,110 --> 00:32:11,300
production code run it offline and put

00:32:08,780 --> 00:32:14,840
it in there so that's a good reason to

00:32:11,300 --> 00:32:17,420
have access to that source I like to

00:32:14,840 --> 00:32:18,950
format the code to be readable and you

00:32:17,420 --> 00:32:20,780
know I've seen you've seen lots of feet

00:32:18,950 --> 00:32:22,730
but I think generate code it's just

00:32:20,780 --> 00:32:25,340
squished together with no white space at

00:32:22,730 --> 00:32:27,860
all I mean what's the point why supposed

00:32:25,340 --> 00:32:31,910
to slow you down and it makes it easier

00:32:27,860 --> 00:32:35,810
to bug I think it's very important again

00:32:31,910 --> 00:32:38,810
for copying pasting use dot equals who

00:32:35,810 --> 00:32:40,640
is never use dot equals good that's a

00:32:38,810 --> 00:32:44,000
good audience it's one of my favorite

00:32:40,640 --> 00:32:45,590
operators I use it all the time it

00:32:44,000 --> 00:32:47,870
sounds so simple but amazing how many

00:32:45,590 --> 00:32:51,620
people would say this equals that dot

00:32:47,870 --> 00:32:53,420
that I mean it's just you know it's just

00:32:51,620 --> 00:32:55,460
you see that a lot in newbie code they

00:32:53,420 --> 00:32:58,790
don't know about the the plus equals dot

00:32:55,460 --> 00:33:01,550
equals and all those operators I like

00:32:58,790 --> 00:33:03,320
here doc says he saw a lot of here Docs

00:33:01,550 --> 00:33:05,660
I like them on the left margin because

00:33:03,320 --> 00:33:06,290
we're generating code that's what you're

00:33:05,660 --> 00:33:08,540
gonna see

00:33:06,290 --> 00:33:11,090
whereas the new invent and the loud hair

00:33:08,540 --> 00:33:12,650
Doc's would not be what I want I want to

00:33:11,090 --> 00:33:15,140
see what's on the left margin but

00:33:12,650 --> 00:33:17,120
because I like the idea of the indented

00:33:15,140 --> 00:33:19,420
ones but I don't mind having the token

00:33:17,120 --> 00:33:22,670
on the left that's I'm used to it now

00:33:19,420 --> 00:33:25,880
this is the most important slide be

00:33:22,670 --> 00:33:27,530
careful about what you escape and the

00:33:25,880 --> 00:33:29,860
generated code you saw there times I

00:33:27,530 --> 00:33:32,090
escaped things I didn't escape things I

00:33:29,860 --> 00:33:34,730
escaped the code that being generated

00:33:32,090 --> 00:33:36,920
when I needed to and I kept variables

00:33:34,730 --> 00:33:39,290
there when I needed to put them into the

00:33:36,920 --> 00:33:41,270
code and that could be really tricky

00:33:39,290 --> 00:33:44,330
because you forgot to do this thing or

00:33:41,270 --> 00:33:45,560
you didn't do the right thing there it's

00:33:44,330 --> 00:33:48,350
definitely thing you have to focus on

00:33:45,560 --> 00:33:50,390
the most matter of fact there's one

00:33:48,350 --> 00:33:55,190
piece of code I showed you I could have

00:33:50,390 --> 00:33:57,140
put the initial part in here docks with

00:33:55,190 --> 00:33:59,240
single quotes on them and not have to

00:33:57,140 --> 00:34:02,060
escape anything then the variable the

00:33:59,240 --> 00:34:06,170
dot operator and then the trailing part

00:34:02,060 --> 00:34:08,660
with here doc that was also single quote

00:34:06,170 --> 00:34:09,800
escape and that somebody suggested idea

00:34:08,660 --> 00:34:12,110
and that's actually a good idea

00:34:09,800 --> 00:34:14,660
so if you have a lecture section when

00:34:12,110 --> 00:34:16,010
you know of any interpolation make that

00:34:14,660 --> 00:34:17,890
a single quoted thing and you can

00:34:16,010 --> 00:34:19,790
eliminate there escapes and make a code

00:34:17,890 --> 00:34:22,700
generated code easier to read when you

00:34:19,790 --> 00:34:24,230
when you're writing it so I was used to

00:34:22,700 --> 00:34:26,780
escaping so I just did it I didn't think

00:34:24,230 --> 00:34:28,190
about it that way and I know here Doxil

00:34:26,780 --> 00:34:30,650
I you did here duck so you could say

00:34:28,190 --> 00:34:33,410
here you know less than less than quote

00:34:30,650 --> 00:34:35,090
single quote token single quote that

00:34:33,410 --> 00:34:37,310
means your entire here doc a single

00:34:35,090 --> 00:34:40,700
quoted the only thing you have to escape

00:34:37,310 --> 00:34:43,880
though is backslash so I would still

00:34:40,700 --> 00:34:45,980
have to because backslash is you could

00:34:43,880 --> 00:34:49,640
say backslash quote in a single quoted

00:34:45,980 --> 00:34:51,260
string maybe not in here doc okay it's

00:34:49,640 --> 00:34:54,650
possible but a case we have to be

00:34:51,260 --> 00:34:56,510
careful about that generate an anonymous

00:34:54,650 --> 00:34:58,340
sub with your code if do anything

00:34:56,510 --> 00:35:00,710
complicated you want to make it a subs

00:34:58,340 --> 00:35:03,230
you can call it if you just doing it in

00:35:00,710 --> 00:35:04,430
line what's the point you have to be

00:35:03,230 --> 00:35:05,960
able to call it later on to make

00:35:04,430 --> 00:35:09,440
something useful if you want to get a

00:35:05,960 --> 00:35:12,140
speed-up and they can call it multiple

00:35:09,440 --> 00:35:13,670
times in your module or again and you

00:35:12,140 --> 00:35:14,940
dump the code out with the source thing

00:35:13,670 --> 00:35:16,079
that you can use it then

00:35:14,940 --> 00:35:17,910
then you could cut and paste and put

00:35:16,079 --> 00:35:19,319
give it a sub name if you want to if

00:35:17,910 --> 00:35:21,150
you're building it into the system like

00:35:19,319 --> 00:35:23,250
templates simple has it you could just

00:35:21,150 --> 00:35:25,230
use the module template simple compile

00:35:23,250 --> 00:35:28,200
the templates and use them I need an

00:35:25,230 --> 00:35:31,250
anonymous sub to get at that name sub

00:35:28,200 --> 00:35:33,930
makes no sense in that context and

00:35:31,250 --> 00:35:37,890
that's how I would thank Damien for

00:35:33,930 --> 00:35:41,640
helping with the presentation and we

00:35:37,890 --> 00:35:43,859
have questions and maybe some answers so

00:35:41,640 --> 00:35:50,880
any questions comments

00:35:43,859 --> 00:35:57,869
heckles yeah but yeah what's scope is

00:35:50,880 --> 00:35:59,369
gonna be in yeah but if he wanted then

00:35:57,869 --> 00:36:01,829
then you put a package in front of it

00:35:59,369 --> 00:36:03,270
you could do that if you commit you

00:36:01,829 --> 00:36:06,000
could declare a pet you could generate a

00:36:03,270 --> 00:36:07,770
package name package cran and then yeah

00:36:06,000 --> 00:36:11,150
you could do that if you wanted to do it

00:36:07,770 --> 00:36:11,150
generate a method that would make sense

00:36:11,569 --> 00:36:20,690
anything else okay fine that's good to

00:36:18,660 --> 00:36:20,690
know

00:36:23,960 --> 00:36:30,589
any other questions comments large sums

00:36:28,410 --> 00:36:30,589
of money

00:36:30,770 --> 00:36:34,670
no no large sums of money

00:36:39,070 --> 00:36:46,250
my oh yeah he mentioned this okay yeah

00:36:45,080 --> 00:36:48,050
you mentioned this last night here's

00:36:46,250 --> 00:36:51,580
another alternative thing if you want to

00:36:48,050 --> 00:36:54,980
do a doubly on slot a none substitute

00:36:51,580 --> 00:36:59,960
Devon said use a singly but in the

00:36:54,980 --> 00:37:01,370
expression say eval on the string it's a

00:36:59,960 --> 00:37:07,010
little clearer but you should be using

00:37:01,370 --> 00:37:08,480
doubly anyway yeah have you must use it

00:37:07,010 --> 00:37:10,280
the app but I it's like I showed you

00:37:08,480 --> 00:37:11,870
that wacky template ER I would never do

00:37:10,280 --> 00:37:15,050
that I don't really recall actually

00:37:11,870 --> 00:37:17,090
wanting to do EE but mind you the

00:37:15,050 --> 00:37:20,360
template simple is not doing EE it's

00:37:17,090 --> 00:37:34,730
recursively calling e that's the part

00:37:20,360 --> 00:37:38,000
that's fun yeah well the difference used

00:37:34,730 --> 00:37:39,590
will basically call import and if you

00:37:38,000 --> 00:37:41,720
need import if you're doing methods and

00:37:39,590 --> 00:37:43,310
you don't need import I mean he's doing

00:37:41,720 --> 00:37:46,300
an object module as you never need to

00:37:43,310 --> 00:37:48,770
use at runtime you don't need to use use

00:37:46,300 --> 00:37:50,780
I've done that where I did polymorphic

00:37:48,770 --> 00:37:53,600
modules like which codec am I using and

00:37:50,780 --> 00:37:58,010
I just do it work I do the same thing I

00:37:53,600 --> 00:38:00,410
showed you eval require class and I just

00:37:58,010 --> 00:38:02,900
I know I used the class name then to

00:38:00,410 --> 00:38:06,080
call the codec they're all the same I

00:38:02,900 --> 00:38:08,300
call class name point to new and create

00:38:06,080 --> 00:38:11,530
that object and use as my codec and that

00:38:08,300 --> 00:38:11,530
could be that comes from a config file

00:38:11,740 --> 00:38:19,360
right that's polymorphic that's one of

00:38:15,710 --> 00:38:19,360
the nice really nice things I love doing

00:38:22,840 --> 00:38:30,370
what I couldn't hear Larry Larry yell

00:38:28,960 --> 00:38:51,580
yell loud I really I want to hear you

00:38:30,370 --> 00:38:52,840
said oh oh okay yeah okay we're not

00:38:51,580 --> 00:39:01,870
talking brown six here

00:38:52,840 --> 00:39:04,690
I mean eval is useful as I showed but

00:39:01,870 --> 00:39:07,180
it's like you have to be disciplined you

00:39:04,690 --> 00:39:08,860
have to be careful you have to make sure

00:39:07,180 --> 00:39:10,480
it's what you really need to do rather

00:39:08,860 --> 00:39:12,520
than you know if you're generating a

00:39:10,480 --> 00:39:14,800
method on the fly or a training summer

00:39:12,520 --> 00:39:19,210
speed up all these things are useful but

00:39:14,800 --> 00:39:25,750
that that eval system sleep five that

00:39:19,210 --> 00:39:27,910
was an eyeball burner so any other

00:39:25,750 --> 00:39:34,180
questions comments I mean it's our

00:39:27,910 --> 00:39:37,630
timing I have ten minutes here you can

00:39:34,180 --> 00:39:45,370
go home early your vote that's oh-ho

00:39:37,630 --> 00:39:46,840
stay here go home early go home early

00:39:45,370 --> 00:39:49,989
okay thank you

00:39:46,840 --> 00:39:49,989
[Applause]

00:39:50,760 --> 00:39:56,260
that was more fun than I thought it

00:39:52,930 --> 00:39:58,860
would be thanks for being here I really

00:39:56,260 --> 00:39:58,860

YouTube URL: https://www.youtube.com/watch?v=eMW1hCpP2Is


