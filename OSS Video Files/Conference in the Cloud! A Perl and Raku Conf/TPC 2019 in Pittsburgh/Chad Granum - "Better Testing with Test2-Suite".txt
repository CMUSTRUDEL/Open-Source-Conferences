Title: Chad Granum - "Better Testing with Test2-Suite"
Publication date: 2019-06-20
Playlist: TPC 2019 in Pittsburgh
Description: 
	Test2 rewrote the internals of Test::Builder effecting nearly every testing tool on CPAN. The Test2 ecosystem and internals are significantly improved over what used to be available. This talk provides an introduction to the new internals, a new suite of tools built on top of those internals, and also gives an overview on how to convert existing tests. This talk changes a little bit every year as things further improve, and also based on feedback from previous years. This talk is a great opportunity for people to stay informed about modern testing in perl.
Captions: 
	00:00:00,030 --> 00:00:05,490
hello everyone I'm Chad Grantham go by

00:00:02,399 --> 00:00:08,519
Exodus on Sipan and this is my

00:00:05,490 --> 00:00:09,900
presentation on test 2 this is intended

00:00:08,519 --> 00:00:11,670
for people who are going to be writing

00:00:09,900 --> 00:00:14,519
tests though we will go a little bit

00:00:11,670 --> 00:00:17,820
into some of the internals so what is

00:00:14,519 --> 00:00:20,039
test 2 test 2 is the new framework that

00:00:17,820 --> 00:00:22,050
is a replacement for test builder in

00:00:20,039 --> 00:00:24,630
fact at this point test builder is just

00:00:22,050 --> 00:00:26,189
a legacy wrapper around test tube so if

00:00:24,630 --> 00:00:29,900
you have a fairly recent version of test

00:00:26,189 --> 00:00:32,040
builder it's using test2 under the hood

00:00:29,900 --> 00:00:33,899
nothing's really gonna happen to test

00:00:32,040 --> 00:00:36,030
builder in the long run there's no way

00:00:33,899 --> 00:00:38,040
it can ever be completely gotten rid of

00:00:36,030 --> 00:00:40,050
there's just too many things that use it

00:00:38,040 --> 00:00:43,010
that will never be updated but as I said

00:00:40,050 --> 00:00:45,450
it is now just a wrapper around test 2

00:00:43,010 --> 00:00:47,010
so these are old benchmarks I actually

00:00:45,450 --> 00:00:49,649
haven't updated these in a couple years

00:00:47,010 --> 00:00:51,420
so they're no longer accurate but they

00:00:49,649 --> 00:00:54,629
at least give a basic idea of where

00:00:51,420 --> 00:00:57,030
performance is basically the legacy test

00:00:54,629 --> 00:00:59,760
builder before converting to test 2 had

00:00:57,030 --> 00:01:01,350
a much quicker start up time so whenever

00:00:59,760 --> 00:01:04,140
you'd start a test it would go a bit

00:01:01,350 --> 00:01:06,659
quicker but test 2 has a much quicker

00:01:04,140 --> 00:01:08,970
runtime it can turn through a lot more

00:01:06,659 --> 00:01:10,409
okay's and other events then test

00:01:08,970 --> 00:01:12,720
builder could in the same amount of time

00:01:10,409 --> 00:01:14,310
so if your test suite is a ton of files

00:01:12,720 --> 00:01:16,080
that take less than a second to run

00:01:14,310 --> 00:01:19,350
legacy test builder would have been

00:01:16,080 --> 00:01:21,750
faster for you but if you have test

00:01:19,350 --> 00:01:24,150
Suites where your test files take a long

00:01:21,750 --> 00:01:26,850
time to run then you're gonna get a big

00:01:24,150 --> 00:01:28,530
benefit with test two you get an even

00:01:26,850 --> 00:01:30,240
bigger benefit if you use the test 2

00:01:28,530 --> 00:01:32,070
tools directly instead of going through

00:01:30,240 --> 00:01:34,710
test builder but there is still a

00:01:32,070 --> 00:01:37,320
performance gain when using legis using

00:01:34,710 --> 00:01:38,880
test builder wrapped around test 2 but

00:01:37,320 --> 00:01:40,439
as I said these benchmarks are pretty

00:01:38,880 --> 00:01:44,579
out of date I won't swear by these

00:01:40,439 --> 00:01:48,299
anymore so first I'm gonna go into a

00:01:44,579 --> 00:01:50,040
tutorial about testing this is startup

00:01:48,299 --> 00:01:51,840
for anyone who's never done any testing

00:01:50,040 --> 00:01:53,100
so it might be boring to some of you can

00:01:51,840 --> 00:01:54,960
I get a show of hands of who has

00:01:53,100 --> 00:01:58,079
actually written unit testing and Perl

00:01:54,960 --> 00:02:00,180
before ok most of you so I'm gonna go

00:01:58,079 --> 00:02:03,299
through this pretty quick at least this

00:02:00,180 --> 00:02:05,130
section so first of all you got the

00:02:03,299 --> 00:02:06,840
boilerplate if you want to use test two

00:02:05,130 --> 00:02:11,760
the best thing to do is use tests to

00:02:06,840 --> 00:02:13,640
clone : v-0 this system allows me to

00:02:11,760 --> 00:02:15,410
make changes if I decide oh some

00:02:13,640 --> 00:02:17,450
I put in the initial test bundle isn't

00:02:15,410 --> 00:02:20,690
very good I can come out in a year in

00:02:17,450 --> 00:02:23,209
release test 2v1 and nothing that used

00:02:20,690 --> 00:02:27,530
the old version Abreu 5 to make breaking

00:02:23,209 --> 00:02:29,840
changes to the interface but that loads

00:02:27,530 --> 00:02:31,310
a ton of plugins and other stuff gives

00:02:29,840 --> 00:02:34,730
you what I consider to be the most

00:02:31,310 --> 00:02:35,720
essential testing tools so first thing

00:02:34,730 --> 00:02:38,000
you have to do is you have to make a

00:02:35,720 --> 00:02:39,800
plan so the testing so that test tune

00:02:38,000 --> 00:02:43,550
knows that your tests didn't exit early

00:02:39,800 --> 00:02:45,890
with an incorrect true value an old way

00:02:43,550 --> 00:02:47,750
to do that was to just give it a number

00:02:45,890 --> 00:02:50,000
of tests and it's still a way to do it

00:02:47,750 --> 00:02:51,380
if you have a lot of forking or

00:02:50,000 --> 00:02:53,660
threading you might want to give it a

00:02:51,380 --> 00:02:55,489
hard-coded number just to be sure

00:02:53,660 --> 00:02:58,400
with test amaury you would list it when

00:02:55,489 --> 00:02:59,720
you imported test more you don't do that

00:02:58,400 --> 00:03:03,080
with test two with test two it's it's

00:02:59,720 --> 00:03:05,269
own separate declarative function plan

00:03:03,080 --> 00:03:07,370
and then the number that's because I

00:03:05,269 --> 00:03:09,230
found a lot of bugs would happen when

00:03:07,370 --> 00:03:12,410
you try and set the plan at import time

00:03:09,230 --> 00:03:16,040
so really not a good idea to do that

00:03:12,410 --> 00:03:17,930
anymore done testing is what I recommend

00:03:16,040 --> 00:03:19,640
you put it at the end of all your tests

00:03:17,930 --> 00:03:21,290
it'll output the plan automatically you

00:03:19,640 --> 00:03:23,000
don't have to do any counting and the

00:03:21,290 --> 00:03:25,280
fact that it got to done testing means

00:03:23,000 --> 00:03:28,459
that yeah the script did not exit early

00:03:25,280 --> 00:03:30,110
and do not put done testing in an end

00:03:28,459 --> 00:03:35,510
block that completely defeats the

00:03:30,110 --> 00:03:37,670
purpose of it so skip all sometimes you

00:03:35,510 --> 00:03:39,560
have a test that won't run on Windows or

00:03:37,670 --> 00:03:41,930
won't run on Mac or need certain things

00:03:39,560 --> 00:03:45,290
installed so test 2 provides the skip

00:03:41,930 --> 00:03:47,720
all planning method or sorry function so

00:03:45,290 --> 00:03:49,130
I it is skip all and the reason and if

00:03:47,720 --> 00:03:53,120
you want to throw in a conditional go

00:03:49,130 --> 00:03:53,989
ahead assertions this is the meet of

00:03:53,120 --> 00:03:56,299
testing

00:03:53,989 --> 00:03:59,150
just like with test more you get okay as

00:03:56,299 --> 00:04:02,829
your very simple okay this is true or

00:03:59,150 --> 00:04:02,829
this is false that means it's a failure

00:04:02,890 --> 00:04:08,030
comparisons this is a spot where there's

00:04:06,230 --> 00:04:11,989
a big difference from test more because

00:04:08,030 --> 00:04:15,019
test more it's is was just a string

00:04:11,989 --> 00:04:18,340
compared with tests to test to suite

00:04:15,019 --> 00:04:21,260
specifically is is always a deep compare

00:04:18,340 --> 00:04:22,340
so you can just give it an array and

00:04:21,260 --> 00:04:25,010
what you think the array should look

00:04:22,340 --> 00:04:26,250
like you can also take strings but

00:04:25,010 --> 00:04:29,040
essentially is is it

00:04:26,250 --> 00:04:30,570
went to is deeply about with much better

00:04:29,040 --> 00:04:31,020
Diagnostics that I'll be showing you

00:04:30,570 --> 00:04:34,020
later

00:04:31,020 --> 00:04:36,900
like is similar and that like is now a

00:04:34,020 --> 00:04:39,360
deep comparison but it's a relax too

00:04:36,900 --> 00:04:41,520
deep comparison anything you put in the

00:04:39,360 --> 00:04:43,890
wants section so the second argument

00:04:41,520 --> 00:04:46,020
it'll verify that is as expected but

00:04:43,890 --> 00:04:48,210
it'll ignore anything extra so if you

00:04:46,020 --> 00:04:49,740
give it a hash and the first argument

00:04:48,210 --> 00:04:51,750
and then the second argument give it a

00:04:49,740 --> 00:04:53,700
hash and only specify one key it'll

00:04:51,750 --> 00:04:56,490
verify that key but it'll ignore all the

00:04:53,700 --> 00:04:58,380
other keys so it's a relaxed check you

00:04:56,490 --> 00:05:00,240
can also just throw in a regular

00:04:58,380 --> 00:05:01,950
expression anywhere and it'll validate

00:05:00,240 --> 00:05:04,050
it so you can do a deep regular

00:05:01,950 --> 00:05:06,780
expression check here just check that

00:05:04,050 --> 00:05:09,120
this hash key has cat in it so cattle

00:05:06,780 --> 00:05:11,160
will pass so you get relaxed deep

00:05:09,120 --> 00:05:12,690
comparison and like I said it's the

00:05:11,160 --> 00:05:15,570
right hand side argument that defines

00:05:12,690 --> 00:05:17,700
how things are gonna be so if you put a

00:05:15,570 --> 00:05:19,860
reference to something in quotes on the

00:05:17,700 --> 00:05:21,510
right hand side then it will do a string

00:05:19,860 --> 00:05:27,419
comparison to whatever was on the left

00:05:21,510 --> 00:05:30,300
side there's also a DSL a special

00:05:27,419 --> 00:05:30,810
language to help you write to these

00:05:30,300 --> 00:05:32,880
things

00:05:30,810 --> 00:05:36,030
here's an example where we're giving it

00:05:32,880 --> 00:05:37,830
this complicated array and note I'm

00:05:36,030 --> 00:05:39,600
intentionally making a test that fails

00:05:37,830 --> 00:05:41,430
here to show the Diagnostics so here's

00:05:39,600 --> 00:05:43,380
the array we're checking against we're

00:05:41,430 --> 00:05:46,080
checking that it's an array the first

00:05:43,380 --> 00:05:48,419
item is X dope second item is y dope

00:05:46,080 --> 00:05:50,490
third item is a hash yes it is but

00:05:48,419 --> 00:05:52,919
inside the hash we give it values that

00:05:50,490 --> 00:05:55,410
aren't actually here this one here DNA

00:05:52,919 --> 00:05:58,229
means check that this hash key does not

00:05:55,410 --> 00:06:00,810
exist and then end to say there should

00:05:58,229 --> 00:06:02,220
be no other fields in this hash but

00:06:00,810 --> 00:06:04,200
there's actually three okay so that

00:06:02,220 --> 00:06:06,510
check will fail as well and then down

00:06:04,200 --> 00:06:08,160
here we see what Diagnostics it actually

00:06:06,510 --> 00:06:11,190
gives you when you have a deep

00:06:08,160 --> 00:06:13,860
comparison sure this array passed but

00:06:11,190 --> 00:06:16,080
look he gave it a but we were checking

00:06:13,860 --> 00:06:18,180
for X and B checking for Y then there

00:06:16,080 --> 00:06:21,479
was a hash that was good but this value

00:06:18,180 --> 00:06:23,040
didn't match and here we got one but we

00:06:21,479 --> 00:06:25,380
were checking that it doesn't exist and

00:06:23,040 --> 00:06:30,030
then the fact that we were also limiting

00:06:25,380 --> 00:06:32,330
how many keys are there that also caused

00:06:30,030 --> 00:06:32,330
a failure

00:06:35,320 --> 00:06:41,950
it doesn't cause a problem because the

00:06:39,300 --> 00:06:45,160
here we're specifying fields so the

00:06:41,950 --> 00:06:46,720
order of the fields doesn't matter it's

00:06:45,160 --> 00:06:48,490
just checking that it has those fields

00:06:46,720 --> 00:06:50,260
it doesn't check that the fields are in

00:06:48,490 --> 00:06:53,320
the order you specified because that

00:06:50,260 --> 00:06:55,660
doesn't make any sense in Perl and by

00:06:53,320 --> 00:06:57,070
the way I don't mind taking questions in

00:06:55,660 --> 00:06:58,420
the middle of the talk save your

00:06:57,070 --> 00:07:03,640
question just raise your hand and I'll

00:06:58,420 --> 00:07:06,580
probably know if there is currently no

00:07:03,640 --> 00:07:08,410
no plan if you still load test builder

00:07:06,580 --> 00:07:10,240
there is a legacy support for things

00:07:08,410 --> 00:07:12,850
that are already doing no plan with test

00:07:10,240 --> 00:07:20,410
builder but test 2 does not support no

00:07:12,850 --> 00:07:21,820
plan only if you are actually counting

00:07:20,410 --> 00:07:25,660
that but you should be using done

00:07:21,820 --> 00:07:27,190
testing unless you're in a very odd

00:07:25,660 --> 00:07:32,730
situation we're done testing wouldn't

00:07:27,190 --> 00:07:32,730
work yes

00:07:33,080 --> 00:07:38,370
okay so anyway these are the kinds of

00:07:36,240 --> 00:07:39,870
Diagnostics that test-tube provides and

00:07:38,370 --> 00:07:44,010
one of the big reasons you might want to

00:07:39,870 --> 00:07:46,410
switch like yesterday to do test two

00:07:44,010 --> 00:07:49,460
uses a different method of get the

00:07:46,410 --> 00:07:53,090
chiefing test - sorry of achieving to do

00:07:49,460 --> 00:07:57,750
with test more you would localize the

00:07:53,090 --> 00:08:00,360
scoped variable called to do it was just

00:07:57,750 --> 00:08:03,870
kind of a weird interface with test two

00:08:00,360 --> 00:08:05,940
you get a to do function first argument

00:08:03,870 --> 00:08:07,620
is always the reason for the to do then

00:08:05,940 --> 00:08:09,360
you can pass it a sub and everything in

00:08:07,620 --> 00:08:11,040
that sub will be to do or you can

00:08:09,360 --> 00:08:13,290
capture the return from that and it'll

00:08:11,040 --> 00:08:14,640
be in to do until end of scope so if

00:08:13,290 --> 00:08:17,250
you're trying to replace one of those

00:08:14,640 --> 00:08:19,230
legacy things that use the the upper

00:08:17,250 --> 00:08:21,020
case to do variable you could replace it

00:08:19,230 --> 00:08:23,850
with this pretty easily without

00:08:21,020 --> 00:08:25,740
rewriting your code it's also useful if

00:08:23,850 --> 00:08:27,450
you've got a test that's verifying stack

00:08:25,740 --> 00:08:30,570
depths in some way and you don't want to

00:08:27,450 --> 00:08:34,110
add another scope so if you're using

00:08:30,570 --> 00:08:36,840
test two you need to list it in like

00:08:34,110 --> 00:08:38,820
your in your build tools what versions

00:08:36,840 --> 00:08:41,940
of modules you need what you should do

00:08:38,820 --> 00:08:44,250
is you should depend on the specific

00:08:41,940 --> 00:08:46,410
bundle that you are using don't depend

00:08:44,250 --> 00:08:48,150
on test to suite don't depend on test

00:08:46,410 --> 00:08:50,100
two or any specific versions of those

00:08:48,150 --> 00:08:52,020
you should depend specifically on

00:08:50,100 --> 00:08:54,720
whatever modules you are loading in your

00:08:52,020 --> 00:08:57,540
test class so here's an example with de

00:08:54,720 --> 00:08:59,490
Silla this is wrong you shouldn't do

00:08:57,540 --> 00:09:01,470
that because what's actually inside test

00:08:59,490 --> 00:09:04,230
to suite might change as it evolves

00:09:01,470 --> 00:09:06,300
however if you require the test to be

00:09:04,230 --> 00:09:08,430
zero bundle that will guarantee you

00:09:06,300 --> 00:09:11,250
always have everything you need for that

00:09:08,430 --> 00:09:14,840
to work and here's the same example and

00:09:11,250 --> 00:09:17,520
make maker okay

00:09:14,840 --> 00:09:19,020
now you know the basics of writing tests

00:09:17,520 --> 00:09:20,880
and a few little differences between

00:09:19,020 --> 00:09:22,440
test more and test two are there any

00:09:20,880 --> 00:09:25,400
questions on this before I move on to

00:09:22,440 --> 00:09:25,400
description of the tools

00:09:27,779 --> 00:09:33,880
yes this is all online I'll go back here

00:09:30,430 --> 00:09:36,220
real quick test - more github do slash

00:09:33,880 --> 00:09:38,920
test - - man oh that's actually

00:09:36,220 --> 00:09:41,620
incorrect but it has a redirect so

00:09:38,920 --> 00:09:45,760
you'll be fine okay

00:09:41,620 --> 00:09:47,680
moving on to the tools so in test two

00:09:45,760 --> 00:09:50,050
things are divided into a couple

00:09:47,680 --> 00:09:52,480
different categories or namespaces the

00:09:50,050 --> 00:09:54,310
tools namespace is for anything that you

00:09:52,480 --> 00:09:56,290
want people to bring in that provides

00:09:54,310 --> 00:09:58,750
functions or other things that are

00:09:56,290 --> 00:10:02,980
exported for actually making your tests

00:09:58,750 --> 00:10:06,250
go these tools generally generate test -

00:10:02,980 --> 00:10:08,560
events everything in test - is an event

00:10:06,250 --> 00:10:10,960
which is itself an object that gets

00:10:08,560 --> 00:10:15,010
passed around so every time you do okay

00:10:10,960 --> 00:10:17,410
that generates at least one event so

00:10:15,010 --> 00:10:19,350
there's the test - tools basic just

00:10:17,410 --> 00:10:21,940
about everything here is included in v-0

00:10:19,350 --> 00:10:24,400
these are just it gives you okay it

00:10:21,940 --> 00:10:25,720
gives you pass/fail diagnose to do skip

00:10:24,400 --> 00:10:28,990
all the things you used to with test

00:10:25,720 --> 00:10:30,820
more so I'm gonna skip that one because

00:10:28,990 --> 00:10:34,330
I'm hoping most of you already know what

00:10:30,820 --> 00:10:36,339
all those do test - tools class is tools

00:10:34,330 --> 00:10:40,060
that help you verify a class such as is

00:10:36,339 --> 00:10:41,710
ax okay and can okay and does okay those

00:10:40,060 --> 00:10:44,470
are a little bit different than the test

00:10:41,710 --> 00:10:49,030
more counterparts because the test more

00:10:44,470 --> 00:10:52,660
ones everyone used them wrong is ax okay

00:10:49,030 --> 00:10:54,430
and test more the first argument was the

00:10:52,660 --> 00:10:56,500
thing to check the second argument was a

00:10:54,430 --> 00:10:58,060
class and then the third argument was

00:10:56,500 --> 00:11:00,670
actually an alternative way of

00:10:58,060 --> 00:11:02,620
representing the class in Diagnostics

00:11:00,670 --> 00:11:04,180
but most people didn't understand that

00:11:02,620 --> 00:11:07,060
and just gave a bunch of things to make

00:11:04,180 --> 00:11:08,500
sure this is a all these things and test

00:11:07,060 --> 00:11:10,750
more wouldn't complain about that it

00:11:08,500 --> 00:11:13,180
would just pass even though it might not

00:11:10,750 --> 00:11:13,780
be true that it wasn't doing what you

00:11:13,180 --> 00:11:16,089
want

00:11:13,780 --> 00:11:18,220
whereas can okay has always accepted

00:11:16,089 --> 00:11:20,200
multiple things to check against so test

00:11:18,220 --> 00:11:22,390
more was very inconsistent in its

00:11:20,200 --> 00:11:23,140
interface but in test two these are

00:11:22,390 --> 00:11:25,180
consistent

00:11:23,140 --> 00:11:27,130
is it okay first is always the thing to

00:11:25,180 --> 00:11:29,110
check then every single thing you list

00:11:27,130 --> 00:11:31,240
after that is a class is a class to

00:11:29,110 --> 00:11:32,860
check against if you want to give a

00:11:31,240 --> 00:11:36,310
custom test name then your second

00:11:32,860 --> 00:11:38,110
argument should be an array ref and then

00:11:36,310 --> 00:11:38,540
your third argument will be seen as a

00:11:38,110 --> 00:11:40,700
test

00:11:38,540 --> 00:11:45,260
and these are completely consistent

00:11:40,700 --> 00:11:46,850
unlike the test more ones though test 2

00:11:45,260 --> 00:11:48,830
wasn't initially released with the array

00:11:46,850 --> 00:11:50,150
form so just to elicit as new even

00:11:48,830 --> 00:11:56,690
though it's been there about two years

00:11:50,150 --> 00:11:58,610
now this microphone is falling so the

00:11:56,690 --> 00:12:00,860
compare tools I'm gonna get to in a bit

00:11:58,610 --> 00:12:02,810
we already saw a little them defer most

00:12:00,860 --> 00:12:05,750
of you will never need this but if you

00:12:02,810 --> 00:12:08,720
need to make assertions before you've

00:12:05,750 --> 00:12:11,480
even loaded test two such as a case

00:12:08,720 --> 00:12:13,760
where test tube being loaded will change

00:12:11,480 --> 00:12:15,710
the results of your tests you can load

00:12:13,760 --> 00:12:18,500
test two tools defer which will not

00:12:15,710 --> 00:12:21,050
actually load any test to stuff except

00:12:18,500 --> 00:12:25,760
for test two tools do it for you specify

00:12:21,050 --> 00:12:29,510
your tests so here we're defining or

00:12:25,760 --> 00:12:31,490
we're saying we want to do an okay one

00:12:29,510 --> 00:12:33,370
is the first argument and pass it'll

00:12:31,490 --> 00:12:35,840
store that so if your second argument

00:12:33,370 --> 00:12:38,570
sorry if your argument here starts with

00:12:35,840 --> 00:12:39,530
a function call it'll store the result

00:12:38,570 --> 00:12:41,450
of that function call

00:12:39,530 --> 00:12:43,430
then later when you do do def it'll

00:12:41,450 --> 00:12:45,170
actually run okay against whatever that

00:12:43,430 --> 00:12:47,420
result was to make sure it matches so

00:12:45,170 --> 00:12:49,040
this is where you get to capture the

00:12:47,420 --> 00:12:51,710
things you want to test but wait to

00:12:49,040 --> 00:12:53,480
actually make the assertion later that

00:12:51,710 --> 00:12:56,420
way loading things doesn't mess up your

00:12:53,480 --> 00:12:58,910
results this is mostly used to test test

00:12:56,420 --> 00:13:02,000
two itself so there's very few cases

00:12:58,910 --> 00:13:03,260
where most of you will use that encoding

00:13:02,000 --> 00:13:06,140
anyone who's tried to change the

00:13:03,260 --> 00:13:09,080
encoding in test Morneau's that it is a

00:13:06,140 --> 00:13:10,610
royal pain it's very difficult I don't

00:13:09,080 --> 00:13:13,100
even have an example up here because

00:13:10,610 --> 00:13:14,900
it's just full hoops with test two you

00:13:13,100 --> 00:13:19,940
can simply call setting coding to

00:13:14,900 --> 00:13:21,640
whatever encoding you want done test two

00:13:19,940 --> 00:13:24,680
comes with exception testers

00:13:21,640 --> 00:13:26,540
specifically ones like test fatal I

00:13:24,680 --> 00:13:29,450
believe it is so you actually capture

00:13:26,540 --> 00:13:31,370
the exception and then you can write

00:13:29,450 --> 00:13:35,990
tests against it there's no equivalent

00:13:31,370 --> 00:13:37,820
of dies okay because there's a lot of

00:13:35,990 --> 00:13:39,650
really nasty bugs that can come from

00:13:37,820 --> 00:13:42,440
that interface that I don't have time to

00:13:39,650 --> 00:13:45,020
go into today exports there are tools

00:13:42,440 --> 00:13:47,600
for you to check your exporters imported

00:13:45,020 --> 00:13:50,240
okay and not imported okay

00:13:47,600 --> 00:13:51,820
imported okay will only pass if those

00:13:50,240 --> 00:13:53,860
functions are found

00:13:51,820 --> 00:13:56,020
the current name-space it does not check

00:13:53,860 --> 00:13:57,280
inheritance so you can't inherit them

00:13:56,020 --> 00:13:59,770
they have to be in the current namespace

00:13:57,280 --> 00:14:01,750
but they have to have been defined in a

00:13:59,770 --> 00:14:03,850
different namespace if they're defined

00:14:01,750 --> 00:14:06,730
in this namespace it will fail because

00:14:03,850 --> 00:14:09,040
they clearly weren't weren't imported

00:14:06,730 --> 00:14:12,550
they were just already there so it's

00:14:09,040 --> 00:14:14,320
really useful check refs ekang since is

00:14:12,550 --> 00:14:16,030
is now a deep check using it to check

00:14:14,320 --> 00:14:18,310
that two references are the exact same

00:14:16,030 --> 00:14:20,650
reference doesn't actually work the way

00:14:18,310 --> 00:14:22,030
you'd think it would so we now have ref

00:14:20,650 --> 00:14:24,130
okay to check that something is a

00:14:22,030 --> 00:14:26,620
reference or of a certain type and ref

00:14:24,130 --> 00:14:29,050
is to verify that two references are in

00:14:26,620 --> 00:14:31,050
fact the same reference and ref is not

00:14:29,050 --> 00:14:33,430
just because why not

00:14:31,050 --> 00:14:36,340
sub test there are two ways to achieve

00:14:33,430 --> 00:14:38,560
sub tests and test two there's using sub

00:14:36,340 --> 00:14:42,070
tests buffered which is useful if you're

00:14:38,560 --> 00:14:43,720
in threaded or forking tests because it

00:14:42,070 --> 00:14:46,330
won't actually output the sub test until

00:14:43,720 --> 00:14:48,460
it is complete that way they don't get

00:14:46,330 --> 00:14:50,080
all mixed together like they would if

00:14:48,460 --> 00:14:54,070
you just use test more and forked or

00:14:50,080 --> 00:14:56,260
threaded so that's that's the buffered

00:14:54,070 --> 00:14:58,570
and then streamed is basically the told

00:14:56,260 --> 00:14:59,620
style where it's gonna output the result

00:14:58,570 --> 00:15:02,050
as soon as it happens

00:14:59,620 --> 00:15:04,990
eat well before the sub test is done you

00:15:02,050 --> 00:15:09,040
do not want to use that if you've got

00:15:04,990 --> 00:15:10,300
any threading or forking going on it

00:15:09,040 --> 00:15:11,950
also has a bunch of tools for testing

00:15:10,300 --> 00:15:13,900
warnings I'm not going to go into too

00:15:11,950 --> 00:15:15,820
much detail here just know that if you

00:15:13,900 --> 00:15:19,810
need to test warnings you got all the

00:15:15,820 --> 00:15:23,130
tools you need now compare any questions

00:15:19,810 --> 00:15:23,130
on that before I go to comparisons

00:15:28,959 --> 00:15:37,360
and I I it's so if I believe if you load

00:15:35,079 --> 00:15:39,970
test to v-0 it just gives you sub test

00:15:37,360 --> 00:15:42,699
and it is the buffered but if you're

00:15:39,970 --> 00:15:45,550
loading the sub test module directly

00:15:42,699 --> 00:15:47,379
instead of going through v-0 you have a

00:15:45,550 --> 00:15:48,519
choice that's the only reason I listed

00:15:47,379 --> 00:15:53,550
those there and some people do prefer

00:15:48,519 --> 00:15:56,199
the classic stuff other questions

00:15:53,550 --> 00:15:57,970
okay so I've already gone over these

00:15:56,199 --> 00:15:59,769
compare tools a little bit but this is

00:15:57,970 --> 00:16:02,589
the deep dive into the compare tools

00:15:59,769 --> 00:16:04,779
you've got isn't like isn't and unlike

00:16:02,589 --> 00:16:06,550
and then a bunch of other helpers here

00:16:04,779 --> 00:16:10,300
that I'll go over in a moment that

00:16:06,550 --> 00:16:12,309
really make testing deep structures nice

00:16:10,300 --> 00:16:15,639
once again isn't like our now always

00:16:12,309 --> 00:16:17,920
deep checks so you can check the state

00:16:15,639 --> 00:16:20,319
of something you can say is this true

00:16:17,920 --> 00:16:24,129
with the T helper is this false with the

00:16:20,319 --> 00:16:25,480
false helper is this defined and those

00:16:24,129 --> 00:16:26,860
can be used deeply like here we're

00:16:25,480 --> 00:16:28,809
checking that there should not be a

00:16:26,860 --> 00:16:31,149
second item in this array by saying does

00:16:28,809 --> 00:16:33,819
not exist here we're checking this hash

00:16:31,149 --> 00:16:37,569
key does not exist so that's really

00:16:33,819 --> 00:16:40,120
helpful FD any is false or does not

00:16:37,569 --> 00:16:42,550
exist so any kind of fall sing value

00:16:40,120 --> 00:16:43,870
including not existing works so if you

00:16:42,550 --> 00:16:46,420
don't know if something's gonna give you

00:16:43,870 --> 00:16:48,189
0 and undef or just fail to give you the

00:16:46,420 --> 00:16:49,600
key that is the helper to use because

00:16:48,189 --> 00:16:51,189
you don't care which it is you just care

00:16:49,600 --> 00:16:54,639
that it's false when something checks to

00:16:51,189 --> 00:16:58,929
see if it's there really really helpful

00:16:54,639 --> 00:17:00,610
I cannot stress how often I use this so

00:16:58,929 --> 00:17:03,069
there's also some directed checks for

00:17:00,610 --> 00:17:04,449
instance if you're using is you wouldn't

00:17:03,069 --> 00:17:06,549
normally be able to give it a regular

00:17:04,449 --> 00:17:09,730
expression to match against however you

00:17:06,549 --> 00:17:12,220
can say is match against this reg X and

00:17:09,730 --> 00:17:14,529
suddenly your is can behave just the

00:17:12,220 --> 00:17:17,289
same as like for whatever you're

00:17:14,529 --> 00:17:19,000
checking you can also do mismatch you

00:17:17,289 --> 00:17:21,189
can check that something is the number

00:17:19,000 --> 00:17:24,189
12 and then it won't care if it's got

00:17:21,189 --> 00:17:25,839
decimals or not and you can check hey

00:17:24,189 --> 00:17:27,130
this thing in string compare though you

00:17:25,839 --> 00:17:30,159
could also just wrap it in quotes so

00:17:27,130 --> 00:17:33,309
string is kind of useless you can also

00:17:30,159 --> 00:17:35,770
check is the value of this key this

00:17:33,309 --> 00:17:37,779
exact reference and it'll check that

00:17:35,770 --> 00:17:39,580
instead of doing a deep dive into the

00:17:37,779 --> 00:17:40,900
reference it will check that it's the

00:17:39,580 --> 00:17:42,820
same reference and then move

00:17:40,900 --> 00:17:45,130
which is really useful if you've got

00:17:42,820 --> 00:17:47,800
cycles in any of your data structures

00:17:45,130 --> 00:17:49,920
and all these can be used as deep as you

00:17:47,800 --> 00:17:53,770
want you can use match 10 levels deep

00:17:49,920 --> 00:17:55,720
just doesn't care it just works you can

00:17:53,770 --> 00:17:57,400
do custom checks I'm not too fond of

00:17:55,720 --> 00:17:58,840
this interface so I'm just gonna blast

00:17:57,400 --> 00:18:01,780
right through this I'm looking to update

00:17:58,840 --> 00:18:04,390
that at some point sets you can check

00:18:01,780 --> 00:18:06,400
that Apple is in the set pear apple or

00:18:04,390 --> 00:18:08,590
orange or you can check that it's not in

00:18:06,400 --> 00:18:10,450
the set or you can do a check set where

00:18:08,590 --> 00:18:14,500
it has to match absolutely every check

00:18:10,450 --> 00:18:17,650
in that set those are really useful so

00:18:14,500 --> 00:18:20,230
ray checks basically say hey I've got an

00:18:17,650 --> 00:18:22,570
array here's the items if you don't give

00:18:20,230 --> 00:18:24,850
it an index it'll just automatically

00:18:22,570 --> 00:18:26,860
increment the index for each one but

00:18:24,850 --> 00:18:29,110
here I'm saying specifically three

00:18:26,860 --> 00:18:30,880
should be this which basically means I

00:18:29,110 --> 00:18:32,830
didn't bother to do a check for index

00:18:30,880 --> 00:18:34,990
two because I did a check for index zero

00:18:32,830 --> 00:18:36,490
index one then skipped right to checking

00:18:34,990 --> 00:18:40,270
index three because I don't care what's

00:18:36,490 --> 00:18:43,809
at index two and once again really nice

00:18:40,270 --> 00:18:45,250
Diagnostics if you get it wrong hash is

00:18:43,809 --> 00:18:47,710
not a whole lot different except you use

00:18:45,250 --> 00:18:50,800
field instead of item you require data

00:18:47,710 --> 00:18:53,710
key and since hashes aren't in any order

00:18:50,800 --> 00:18:55,660
you don't give it a numerical value also

00:18:53,710 --> 00:18:58,990
of note this works for both arrays and

00:18:55,660 --> 00:19:00,820
hashes you specify and to say hey there

00:18:58,990 --> 00:19:04,090
should be nothing else in this hash you

00:19:00,820 --> 00:19:05,530
can also specify etc' as I don't care

00:19:04,090 --> 00:19:08,230
what else is in this hash only check

00:19:05,530 --> 00:19:10,720
these things at that point you can

00:19:08,230 --> 00:19:13,090
basically do the exact same thing in is

00:19:10,720 --> 00:19:15,010
and like and the only thing that's

00:19:13,090 --> 00:19:19,120
different is how strict it is this stuff

00:19:15,010 --> 00:19:20,950
you didn't specify directly we've also

00:19:19,120 --> 00:19:23,080
got meta check which lets you check

00:19:20,950 --> 00:19:25,000
properties of the thing you're looking

00:19:23,080 --> 00:19:26,830
at like let's check that this is blessed

00:19:25,000 --> 00:19:31,030
let's check that this has this ref type

00:19:26,830 --> 00:19:33,700
let's check that this array is size 4 it

00:19:31,030 --> 00:19:35,980
also works as a key count on hashes and

00:19:33,700 --> 00:19:38,230
this lets you reference the thing itself

00:19:35,980 --> 00:19:43,179
so you can nest again and say this

00:19:38,230 --> 00:19:46,000
should be an array and all that and

00:19:43,179 --> 00:19:49,060
there's object checks and in an object

00:19:46,000 --> 00:19:50,530
check you can do either field or item

00:19:49,060 --> 00:19:53,220
depending on whether your object is a

00:19:50,530 --> 00:19:55,710
blessed hash or a blessed array

00:19:53,220 --> 00:19:58,379
the prop checked from Metta checks works

00:19:55,710 --> 00:20:00,629
fine and objects you can also say call

00:19:58,379 --> 00:20:01,919
this sub and this should be the result

00:20:00,629 --> 00:20:04,259
or call this method and this should be

00:20:01,919 --> 00:20:06,690
the result and you can even specify a

00:20:04,259 --> 00:20:10,320
custom sub to call against the object so

00:20:06,690 --> 00:20:12,629
it could do your object this custom sub

00:20:10,320 --> 00:20:14,190
and use it as a method which is really

00:20:12,629 --> 00:20:16,769
useful if you have a method that returns

00:20:14,190 --> 00:20:19,169
a list as opposed to an array ref you

00:20:16,769 --> 00:20:20,399
can use this to wrap that and that way

00:20:19,169 --> 00:20:28,799
you don't need all kinds of fancy things

00:20:20,399 --> 00:20:31,109
to to directly say hey wrap this meta is

00:20:28,799 --> 00:20:32,669
specifically only it only lets you check

00:20:31,109 --> 00:20:34,739
for properties of whatever you're

00:20:32,669 --> 00:20:36,840
looking at whereas object has a bunch of

00:20:34,739 --> 00:20:39,239
stuff specific to objects and includes

00:20:36,840 --> 00:20:43,979
everything meta includes so you can

00:20:39,239 --> 00:20:47,450
think of object as a subclass of meta ok

00:20:43,979 --> 00:20:50,220
any questions on the comparison tools

00:20:47,450 --> 00:20:53,099
moving on another namespace under test

00:20:50,220 --> 00:20:54,929
two is the plugins namespace there are a

00:20:53,099 --> 00:20:56,759
few here that people have been asking

00:20:54,929 --> 00:21:00,779
for for years but were impossible to do

00:20:56,759 --> 00:21:02,129
in tests more such as bail on failed his

00:21:00,779 --> 00:21:05,580
plug-in will cause your entire test

00:21:02,129 --> 00:21:08,369
suite to just abort if it encounters any

00:21:05,580 --> 00:21:11,309
failure it stops right there with a bail

00:21:08,369 --> 00:21:12,779
out and there's also died on fail which

00:21:11,309 --> 00:21:15,259
is the same except you died instead of

00:21:12,779 --> 00:21:20,159
bail and looks like I have a typo there

00:21:15,259 --> 00:21:21,929
but these are something that for over 15

00:21:20,159 --> 00:21:24,570
years people were asking for this

00:21:21,929 --> 00:21:26,909
capability and test more and it couldn't

00:21:24,570 --> 00:21:28,679
be done because you'd make an okay or

00:21:26,909 --> 00:21:30,629
the test tool you were doing would do it

00:21:28,679 --> 00:21:32,460
okay and generate that line of tap and

00:21:30,629 --> 00:21:34,590
then things would die and then none of

00:21:32,460 --> 00:21:36,269
your Diagnostics on why it died would be

00:21:34,590 --> 00:21:39,119
printed out because those took place

00:21:36,269 --> 00:21:41,700
after the failure and so you just

00:21:39,119 --> 00:21:43,950
couldn't do it with a test more but test

00:21:41,700 --> 00:21:47,099
2 uses a system under the hood that

00:21:43,950 --> 00:21:49,499
makes this not just possible but trivial

00:21:47,099 --> 00:21:52,619
and it will know when your Diagnostics

00:21:49,499 --> 00:21:55,109
are done because new tools have started

00:21:52,619 --> 00:21:57,509
and it will bail after you get your

00:21:55,109 --> 00:22:00,509
Diagnostics unless you are still using

00:21:57,509 --> 00:22:03,509
legacy test builder on everything it

00:22:00,509 --> 00:22:05,249
can't fix that but any any tests to

00:22:03,509 --> 00:22:06,260
tools will finish putting out their

00:22:05,249 --> 00:22:11,840
Diagnostics

00:22:06,260 --> 00:22:14,450
for the bail a bailout will completely

00:22:11,840 --> 00:22:16,400
kill the testsuite like prove or EF will

00:22:14,450 --> 00:22:17,270
see it and choose not to run anymore

00:22:16,400 --> 00:22:19,130
test files

00:22:17,270 --> 00:22:20,660
whereas Dai will abort the current test

00:22:19,130 --> 00:22:28,580
file but the rest of your files will

00:22:20,660 --> 00:22:30,920
still run okay there's also exit summary

00:22:28,580 --> 00:22:32,450
this one is loaded by default with v-0

00:22:30,920 --> 00:22:35,980
it just gives you all the diagnostics

00:22:32,450 --> 00:22:41,120
you expect after a test is done running

00:22:35,980 --> 00:22:44,000
s Rand this seeds random with the

00:22:41,120 --> 00:22:46,550
current date that means that any random

00:22:44,000 --> 00:22:49,100
behavior any time you call shuffle will

00:22:46,550 --> 00:22:50,840
be consistent on any given day so will

00:22:49,100 --> 00:22:52,630
always run in the same order if you've

00:22:50,840 --> 00:22:55,310
shuffled something on a given day but

00:22:52,630 --> 00:22:57,140
over the course of a week it'll have

00:22:55,310 --> 00:22:59,510
seven different runs so you're still

00:22:57,140 --> 00:23:01,880
verifying random behavior but if you

00:22:59,510 --> 00:23:03,650
want to reproduce that random behavior

00:23:01,880 --> 00:23:05,750
to find out why it failed in a certain

00:23:03,650 --> 00:23:08,540
run you can be guaranteed that it's

00:23:05,750 --> 00:23:10,460
going to have the same seed which makes

00:23:08,540 --> 00:23:11,810
it possible to track down a lot of

00:23:10,460 --> 00:23:14,360
heisenbugs that would otherwise be

00:23:11,810 --> 00:23:16,250
impossible to track down and there's a

00:23:14,360 --> 00:23:19,600
utf8 plugin that just automatically

00:23:16,250 --> 00:23:19,600
makes everything utf-8

00:23:28,440 --> 00:23:34,950
so when you import tests to v-0 there is

00:23:32,160 --> 00:23:36,780
a flag to disable that I believe if not

00:23:34,950 --> 00:23:38,370
you can just copy test T of V zero make

00:23:36,780 --> 00:23:39,900
your own bundle it's really trivial I'll

00:23:38,370 --> 00:23:45,900
be talking about that when I get to the

00:23:39,900 --> 00:23:47,970
bundle section require these are so

00:23:45,900 --> 00:23:51,330
require is a namespace under test to so

00:23:47,970 --> 00:23:52,920
its test to require blank and these are

00:23:51,330 --> 00:23:54,780
to make it so your test is skipped if

00:23:52,920 --> 00:23:56,340
certain conditions aren't met such as

00:23:54,780 --> 00:23:58,710
tests that you only want to run when you

00:23:56,340 --> 00:24:01,440
have author testing set you'd require

00:23:58,710 --> 00:24:03,510
tests to require author testing you can

00:24:01,440 --> 00:24:06,300
also check any arbitrary environment

00:24:03,510 --> 00:24:09,570
variable you can skip a test if forking

00:24:06,300 --> 00:24:11,670
isn't available this one is a difficult

00:24:09,570 --> 00:24:13,800
one here's an example of the code you

00:24:11,670 --> 00:24:17,250
would have to write yourself if you

00:24:13,800 --> 00:24:19,590
wanted a test to skip when forking isn't

00:24:17,250 --> 00:24:21,390
available it is this difficult to find

00:24:19,590 --> 00:24:23,790
out whether or not you have some form of

00:24:21,390 --> 00:24:25,080
forking so this plug-in just does all

00:24:23,790 --> 00:24:27,210
this for you so you don't have to write

00:24:25,080 --> 00:24:29,790
all that and then there's real fork

00:24:27,210 --> 00:24:31,950
which only lets the test run if your

00:24:29,790 --> 00:24:34,110
system actually truly supports fork as

00:24:31,950 --> 00:24:37,800
opposed to the emulation that happens on

00:24:34,110 --> 00:24:39,810
say Windows you can also test require

00:24:37,800 --> 00:24:42,870
module and some module or a given

00:24:39,810 --> 00:24:45,630
version of it require certain version of

00:24:42,870 --> 00:24:47,670
Perl or require threads once again it's

00:24:45,630 --> 00:24:49,590
very complicated to check if the current

00:24:47,670 --> 00:24:52,830
system actually supports threads so this

00:24:49,590 --> 00:24:54,690
does all the work for you okay moving on

00:24:52,830 --> 00:24:56,550
to mocking test 2 comes with some

00:24:54,690 --> 00:24:59,130
mocking libraries that are really quite

00:24:56,550 --> 00:25:00,720
nice these are based on mock quick which

00:24:59,130 --> 00:25:02,430
is a previous mocking module I've

00:25:00,720 --> 00:25:06,000
written but this makes up for a lot of

00:25:02,430 --> 00:25:09,810
shortcomings in that module so with a

00:25:06,000 --> 00:25:11,310
test the test to mock tools you you do

00:25:09,810 --> 00:25:13,830
your mocking and it returns to you a

00:25:11,310 --> 00:25:16,200
control object if that control object

00:25:13,830 --> 00:25:17,880
goes out of scope the mocking is undone

00:25:16,200 --> 00:25:20,040
restoring whatever was there originally

00:25:17,880 --> 00:25:22,620
or getting rid of everything if there

00:25:20,040 --> 00:25:24,900
was nothing there originally so here's

00:25:22,620 --> 00:25:27,330
how you'd use it here's the hard way to

00:25:24,900 --> 00:25:29,040
use it let me clarify test to mock knew

00:25:27,330 --> 00:25:31,110
what class what you want to override

00:25:29,040 --> 00:25:32,700
what methods you want to add there's

00:25:31,110 --> 00:25:34,980
also a set for if you're not sure

00:25:32,700 --> 00:25:37,410
whether or not it already exists but for

00:25:34,980 --> 00:25:39,990
instance override will fail if that

00:25:37,410 --> 00:25:41,110
method does not already exist add will

00:25:39,990 --> 00:25:44,050
fail if the

00:25:41,110 --> 00:25:45,250
it does already exist and set is if you

00:25:44,050 --> 00:25:47,410
just don't care whether or not it's

00:25:45,250 --> 00:25:49,060
there you want to override it and it

00:25:47,410 --> 00:25:50,920
gives you the control object that lets

00:25:49,060 --> 00:25:54,160
you then override it as many times as

00:25:50,920 --> 00:25:56,410
you want you can restore things if you

00:25:54,160 --> 00:25:58,560
want you can totally reset back to the

00:25:56,410 --> 00:26:00,820
original uncertainty on any method and

00:25:58,560 --> 00:26:02,950
once again once it's out of scope all

00:26:00,820 --> 00:26:06,720
the mocking goes away and it cleans up

00:26:02,950 --> 00:26:10,420
its mess so you're left in a clean state

00:26:06,720 --> 00:26:13,630
so there's also sugar for the mocking

00:26:10,420 --> 00:26:15,010
libraries there's the mock keyword which

00:26:13,630 --> 00:26:17,140
allows you to do anything

00:26:15,010 --> 00:26:19,090
there's mocked to check if something is

00:26:17,140 --> 00:26:20,770
been mocked and if you want to be very

00:26:19,090 --> 00:26:22,690
explicit on what you're doing you can

00:26:20,770 --> 00:26:26,230
call mock class or mock object instead

00:26:22,690 --> 00:26:28,060
of just mock so here's an example of

00:26:26,230 --> 00:26:29,620
using that here's art we're capturing

00:26:28,060 --> 00:26:31,750
our control object we're mocking some

00:26:29,620 --> 00:26:33,520
packages we're adding the foo method and

00:26:31,750 --> 00:26:35,140
we're overwriting the bar method and we

00:26:33,520 --> 00:26:40,510
can call them and then we can clear our

00:26:35,140 --> 00:26:43,150
mock you can also yeah you can also say

00:26:40,510 --> 00:26:45,070
mock class to specify you are mocking a

00:26:43,150 --> 00:26:47,920
class or mock underscore class that

00:26:45,070 --> 00:26:49,660
other helper there's Tim toady here you

00:26:47,920 --> 00:26:51,310
can also mock an object directly without

00:26:49,660 --> 00:26:53,680
creating a random class here we're

00:26:51,310 --> 00:26:55,060
mocking an object this is the hash that

00:26:53,680 --> 00:26:56,320
will be blessed to the object and we

00:26:55,060 --> 00:26:59,230
want to make sure it has a foo method

00:26:56,320 --> 00:27:02,740
and it'll just create that object with a

00:26:59,230 --> 00:27:05,490
random namespace for you and questions

00:27:02,740 --> 00:27:05,490
about the mocking

00:27:11,679 --> 00:27:16,100
she'd do that you'd want to prevent the

00:27:14,120 --> 00:27:18,050
original from loading and then you can

00:27:16,100 --> 00:27:31,130
do that yes you can you can mock a class

00:27:18,050 --> 00:27:32,630
that has not been loaded well with that

00:27:31,130 --> 00:27:34,790
you can just use the regular Perl tools

00:27:32,630 --> 00:27:40,100
and do this object can and then whatever

00:27:34,790 --> 00:27:41,780
method you're looking for okay moving on

00:27:40,100 --> 00:27:44,480
those of you who were at Dave Russkies

00:27:41,780 --> 00:27:45,940
talk heard him talk about test more what

00:27:44,480 --> 00:27:50,360
is a test

00:27:45,940 --> 00:27:53,480
TCM test class boosts and this is my

00:27:50,360 --> 00:27:56,270
competitor to test class moose so here

00:27:53,480 --> 00:27:58,690
we go if any of you have used r-spec in

00:27:56,270 --> 00:28:01,910
Ruby this will look very familiar to you

00:27:58,690 --> 00:28:04,160
so you can define test blocks it's with

00:28:01,910 --> 00:28:05,990
a test keyword so test foo and then the

00:28:04,160 --> 00:28:08,630
block and all these and then done

00:28:05,990 --> 00:28:10,640
testing is what triggers them to run and

00:28:08,630 --> 00:28:13,850
so once it hits done testing it'll

00:28:10,640 --> 00:28:16,490
actually run all those subs you can pass

00:28:13,850 --> 00:28:18,590
parameters to these subs such as oh this

00:28:16,490 --> 00:28:21,020
one's flat that means don't make it into

00:28:18,590 --> 00:28:23,929
a sub test just show it at the top level

00:28:21,020 --> 00:28:26,840
you can say hey this entire test block

00:28:23,929 --> 00:28:28,400
is to do so I'll fix it later don't fail

00:28:26,840 --> 00:28:30,230
when things go wrong in here you can

00:28:28,400 --> 00:28:31,790
tell it to skip one like let's say

00:28:30,230 --> 00:28:32,900
you've got a bug and if you actually ran

00:28:31,790 --> 00:28:36,740
that test it would format your hard

00:28:32,900 --> 00:28:38,390
drive you'd want to pop in the skip then

00:28:36,740 --> 00:28:40,550
there's two new ones that don't have

00:28:38,390 --> 00:28:43,490
equivalents and others there's ISO which

00:28:40,550 --> 00:28:46,010
means isolate this what that'll do is

00:28:43,490 --> 00:28:48,050
it'll cause the test to fork run

00:28:46,010 --> 00:28:50,360
everything in the fork and then return

00:28:48,050 --> 00:28:52,400
control back to the original with those

00:28:50,360 --> 00:28:54,710
results that way nothing you do in that

00:28:52,400 --> 00:28:56,360
test block can possibly affect the first

00:28:54,710 --> 00:28:58,100
test block and unless you share a

00:28:56,360 --> 00:29:00,050
database handle or something that way

00:28:58,100 --> 00:29:02,120
you are guaranteed that test block will

00:29:00,050 --> 00:29:03,440
not screw up the environment for any

00:29:02,120 --> 00:29:06,200
test that will run later

00:29:03,440 --> 00:29:08,420
there's also async which says you can

00:29:06,200 --> 00:29:13,190
run this in parallel you can fork and

00:29:08,420 --> 00:29:14,750
run this but you don't have to and I

00:29:13,190 --> 00:29:17,360
think I just explained everything in

00:29:14,750 --> 00:29:19,910
there so described you can create

00:29:17,360 --> 00:29:22,600
describe blocks which will group lots of

00:29:19,910 --> 00:29:24,610
tests Minuten tests together

00:29:22,600 --> 00:29:26,800
and you can nest those this key becomes

00:29:24,610 --> 00:29:28,650
useful when you then bring in your setup

00:29:26,800 --> 00:29:33,100
and teardown things such as before

00:29:28,650 --> 00:29:34,360
before all run this sub before each run

00:29:33,100 --> 00:29:36,250
the sub the difference there is the

00:29:34,360 --> 00:29:38,410
before all will happen once before

00:29:36,250 --> 00:29:40,360
everything runs before each will happen

00:29:38,410 --> 00:29:43,060
before each test block again and again

00:29:40,360 --> 00:29:45,280
and again you can group those along with

00:29:43,060 --> 00:29:48,640
specific test blocks within a describe

00:29:45,280 --> 00:29:49,960
so this before all will happen before

00:29:48,640 --> 00:29:52,150
all these tests this before each will

00:29:49,960 --> 00:29:54,250
happen before red green blue as well as

00:29:52,150 --> 00:29:56,800
before anything in this nested describe

00:29:54,250 --> 00:29:59,140
block so it's really powerful

00:29:56,800 --> 00:30:01,450
then there's after and then there's a

00:29:59,140 --> 00:30:02,620
round so you can do a round all or

00:30:01,450 --> 00:30:06,580
around each and that's kind of like

00:30:02,620 --> 00:30:08,890
mooses mooses around or moose the things

00:30:06,580 --> 00:30:10,960
moose can do there though this does not

00:30:08,890 --> 00:30:12,790
use moose none of the tests to tools use

00:30:10,960 --> 00:30:16,390
moose directly you can still use moose

00:30:12,790 --> 00:30:19,240
but they don't require you to you can

00:30:16,390 --> 00:30:22,000
also do cases every one of these cases

00:30:19,240 --> 00:30:23,710
all the test blocks will run under it so

00:30:22,000 --> 00:30:25,840
first it'll set the C variable to read

00:30:23,710 --> 00:30:27,880
then run all the tests blocks then it'll

00:30:25,840 --> 00:30:29,980
set the C variable to green and run them

00:30:27,880 --> 00:30:32,760
all again this way you can test multiple

00:30:29,980 --> 00:30:35,170
cases with the same set of test blocks

00:30:32,760 --> 00:30:36,910
it's really handy the the problem there

00:30:35,170 --> 00:30:38,350
is if you've got like a thousand test

00:30:36,910 --> 00:30:40,420
blocks and a thousand cases you're

00:30:38,350 --> 00:30:42,850
suddenly running you know multiply those

00:30:40,420 --> 00:30:46,000
together I really suck at math but it's

00:30:42,850 --> 00:30:47,860
exponential growth you can also modify

00:30:46,000 --> 00:30:49,930
cases this is where I go a little

00:30:47,860 --> 00:30:53,590
overkill and you can do before case an

00:30:49,930 --> 00:30:56,140
after case in a round case mocking the

00:30:53,590 --> 00:30:57,940
mock tools know when you are in a spec

00:30:56,140 --> 00:31:00,040
test like this so you don't actually

00:30:57,940 --> 00:31:02,950
have to capture control it'll just know

00:31:00,040 --> 00:31:06,070
that mock will only apply to the tests

00:31:02,950 --> 00:31:08,680
inside this describe block and so mock

00:31:06,070 --> 00:31:11,620
becomes its own before each or before

00:31:08,680 --> 00:31:13,870
all you can still capture the control

00:31:11,620 --> 00:31:15,760
but it won't help you much because

00:31:13,870 --> 00:31:19,930
describe will end before any of the

00:31:15,760 --> 00:31:22,180
tests inside of it run there there is

00:31:19,930 --> 00:31:24,370
also test to plug in spec declare which

00:31:22,180 --> 00:31:27,190
uses devil declare to give you really

00:31:24,370 --> 00:31:29,710
nice sugar so that you don't have to put

00:31:27,190 --> 00:31:31,750
the sub keyword or the semicolon at the

00:31:29,710 --> 00:31:33,940
end of your subs they work just like any

00:31:31,750 --> 00:31:36,879
other subroutines now

00:31:33,940 --> 00:31:38,620
and it is really useful and it is really

00:31:36,879 --> 00:31:40,799
stable despite using devil declare if

00:31:38,620 --> 00:31:43,210
not add any problems with it

00:31:40,799 --> 00:31:49,350
questions about speck which I highly

00:31:43,210 --> 00:31:49,350
recommend you use okay bundles sorry

00:31:55,730 --> 00:32:03,630
yes and if you set them day synchronous

00:31:59,070 --> 00:32:05,460
it will automatically if so the default

00:32:03,630 --> 00:32:07,680
is to do up to three processes so if

00:32:05,460 --> 00:32:10,260
you're using spec and you specify all

00:32:07,680 --> 00:32:11,940
your blocks as async then it will use

00:32:10,260 --> 00:32:14,970
three processes to get through all your

00:32:11,940 --> 00:32:17,640
tests and it will fork to do that you

00:32:14,970 --> 00:32:19,380
can disable that if you want but but

00:32:17,640 --> 00:32:22,580
yeah so spec does come with some

00:32:19,380 --> 00:32:22,580
concurrency built in

00:32:32,640 --> 00:32:38,090
I have never cared for tests class so

00:32:36,299 --> 00:32:40,830
I'm not the person to ask about that

00:32:38,090 --> 00:32:43,010
most I've done is patch a bug when I was

00:32:40,830 --> 00:32:44,670
updating things to test - so

00:32:43,010 --> 00:32:47,630
unfortunately I can't say much about

00:32:44,670 --> 00:32:47,630
test class Oh

00:32:51,000 --> 00:32:56,880
so yes with speck there there is

00:32:55,080 --> 00:32:59,429
actually I'm surprised I don't have it

00:32:56,880 --> 00:33:01,290
listed in here you can set an

00:32:59,429 --> 00:33:04,350
environment variable with the name of

00:33:01,290 --> 00:33:06,330
whatever test block or describe block

00:33:04,350 --> 00:33:07,919
you want to run and it will only run

00:33:06,330 --> 00:33:09,870
that instead of running all of them so

00:33:07,919 --> 00:33:12,559
you can specify and I've actually got

00:33:09,870 --> 00:33:15,169
hotkeys I press f8 to run whatever

00:33:12,559 --> 00:33:17,700
whatever test block is under my cursor

00:33:15,169 --> 00:33:20,100
and that environment variable can also

00:33:17,700 --> 00:33:22,799
take a line number and it'll run

00:33:20,100 --> 00:33:24,450
whatever blocks are spanning across that

00:33:22,799 --> 00:33:27,679
line number which makes editor

00:33:24,450 --> 00:33:27,679
integration really nice

00:33:36,580 --> 00:33:43,959
if I understood you correctly the answer

00:33:38,559 --> 00:33:45,459
is yes okay moving on to bundles bundles

00:33:43,959 --> 00:33:48,009
are the primary interface when you're

00:33:45,459 --> 00:33:50,589
trying to use test2 I recommend you use

00:33:48,009 --> 00:33:52,389
the V 0 bundle here's all the things

00:33:50,589 --> 00:33:56,289
that it imports by default it gives you

00:33:52,389 --> 00:33:57,700
strict warnings and utf-8 s R and which

00:33:56,289 --> 00:33:59,109
it looks like I do not have a way to

00:33:57,700 --> 00:34:02,979
directly disable that yet

00:33:59,109 --> 00:34:05,679
patches welcome but you can specify not

00:34:02,979 --> 00:34:06,999
to import certain things if you want but

00:34:05,679 --> 00:34:09,069
honestly if you were to look at this

00:34:06,999 --> 00:34:10,750
code the bundles are so simple you could

00:34:09,069 --> 00:34:14,349
easily just clone it and make a custom

00:34:10,750 --> 00:34:16,839
bundle there's the test to bundle more

00:34:14,349 --> 00:34:19,089
which is the closest thing to the test

00:34:16,839 --> 00:34:21,010
more interface if you just want to

00:34:19,089 --> 00:34:23,829
really quickly convert you can change

00:34:21,010 --> 00:34:25,960
your use test more to test to bundle

00:34:23,829 --> 00:34:27,369
more but there are a few differences

00:34:25,960 --> 00:34:28,779
that can still bite you where you'd have

00:34:27,369 --> 00:34:30,730
to update them and I've listed those

00:34:28,779 --> 00:34:32,559
there there's also a test to bundle

00:34:30,730 --> 00:34:34,480
simple which basically gives you ok

00:34:32,559 --> 00:34:39,429
planned and testing and skip all nothing

00:34:34,480 --> 00:34:42,309
else ok moving on so now we're getting

00:34:39,429 --> 00:34:45,129
to a bit of the internals with test more

00:34:42,309 --> 00:34:48,339
for instance if you wanted to write a

00:34:45,129 --> 00:34:51,849
helper so sub helper that makes 5

00:34:48,339 --> 00:34:53,679
assertions so it says ok 5 times then if

00:34:51,849 --> 00:34:54,849
one of those assertions failed it would

00:34:53,679 --> 00:34:57,010
give you the line number of that

00:34:54,849 --> 00:34:59,230
assertion and not the line number of

00:34:57,010 --> 00:35:01,210
where you called the helper function to

00:34:59,230 --> 00:35:02,950
fix that there was a special variable

00:35:01,210 --> 00:35:05,829
and test builder that most people did

00:35:02,950 --> 00:35:07,960
not know about called level and all caps

00:35:05,829 --> 00:35:10,089
and you had to localize and increment it

00:35:07,960 --> 00:35:12,369
which is not an uncommon pattern in Perl

00:35:10,089 --> 00:35:14,619
but it's a really terrible interface and

00:35:12,369 --> 00:35:18,069
it's really hard to discover if you

00:35:14,619 --> 00:35:21,270
don't know it's there context is the

00:35:18,069 --> 00:35:23,650
test 2 solution to this problem

00:35:21,270 --> 00:35:27,640
basically whenever you are writing a

00:35:23,650 --> 00:35:30,010
test 2 tool such as ok you will pull out

00:35:27,640 --> 00:35:32,079
a context object which will mark hey I'm

00:35:30,010 --> 00:35:34,150
the top level so any diagnostic should

00:35:32,079 --> 00:35:36,430
be reported just above me then you can

00:35:34,150 --> 00:35:38,020
nest functions as deep as you want and

00:35:36,430 --> 00:35:40,180
it'll always know exactly where it

00:35:38,020 --> 00:35:42,940
should actually report the errors so

00:35:40,180 --> 00:35:45,430
here's a usage we're implementing my ok

00:35:42,940 --> 00:35:48,430
which is just the same as ok first thing

00:35:45,430 --> 00:35:50,350
it does is get a context then it can

00:35:48,430 --> 00:35:53,230
actually use that context to generate

00:35:50,350 --> 00:35:55,210
defense soak on the context object has

00:35:53,230 --> 00:35:57,190
an OK method when you're done with it

00:35:55,210 --> 00:35:59,320
you release it this is important because

00:35:57,190 --> 00:36:01,450
this is where the die on fail and bail

00:35:59,320 --> 00:36:03,160
on fail hopes happen so if you wanted to

00:36:01,450 --> 00:36:05,920
pop a bunch of diagnostics under this

00:36:03,160 --> 00:36:08,320
okay line in case of failure you can and

00:36:05,920 --> 00:36:10,780
it will still show those diagnostics and

00:36:08,320 --> 00:36:12,730
it'll wait until this release to do the

00:36:10,780 --> 00:36:15,400
bail on fail therefore you get your

00:36:12,730 --> 00:36:18,100
diagnostics and you have a plugin that

00:36:15,400 --> 00:36:21,730
was impossible with test more is now

00:36:18,100 --> 00:36:24,400
possible so rules there are ten

00:36:21,730 --> 00:36:26,440
commandments of the context object get

00:36:24,400 --> 00:36:28,510
it as early as possible release it as

00:36:26,440 --> 00:36:31,300
late as possible do not forget to

00:36:28,510 --> 00:36:34,150
release it each sub it needs to get its

00:36:31,300 --> 00:36:36,250
own you do not pass around a context

00:36:34,150 --> 00:36:40,270
object it belongs to the scope where you

00:36:36,250 --> 00:36:42,010
acquired it and no others do not cash or

00:36:40,270 --> 00:36:45,190
store the context for later use because

00:36:42,010 --> 00:36:49,360
you will screw up all the things do not

00:36:45,190 --> 00:36:51,670
share a context with anyone else and it

00:36:49,360 --> 00:36:53,530
assumes it is being obtained within a

00:36:51,670 --> 00:36:55,600
sub and not on the package scope if you

00:36:53,530 --> 00:36:57,700
need a context at a package scope you

00:36:55,600 --> 00:37:00,340
have to pass it some arguments you do

00:36:57,700 --> 00:37:04,750
not ever alter the context internals

00:37:00,340 --> 00:37:06,670
this is a do not touch zone and do not

00:37:04,750 --> 00:37:08,230
monkey patch the context if you do I

00:37:06,670 --> 00:37:12,670
will laugh in your face and tell

00:37:08,230 --> 00:37:14,950
everyone never use your code so events

00:37:12,670 --> 00:37:16,570
get generated here's the events I

00:37:14,950 --> 00:37:19,180
actually recommend you use because these

00:37:16,570 --> 00:37:21,520
are optimized you used to be recommended

00:37:19,180 --> 00:37:24,340
you use context okay don't use context

00:37:21,520 --> 00:37:26,560
okay these contexts pass or context fail

00:37:24,340 --> 00:37:28,360
because this generates specific pass or

00:37:26,560 --> 00:37:30,220
fail events that'll get through the

00:37:28,360 --> 00:37:31,810
system much quicker because it already

00:37:30,220 --> 00:37:34,660
knows what to do with the pass or a fail

00:37:31,810 --> 00:37:37,840
event so your code will be much faster

00:37:34,660 --> 00:37:41,770
if your test tools use pass as a and

00:37:37,840 --> 00:37:43,150
fail as opposed to okay and I'm not

00:37:41,770 --> 00:37:44,950
going to get into all the complicated

00:37:43,150 --> 00:37:48,220
things so the legacy event generators

00:37:44,950 --> 00:37:50,650
are okay note died and skip and bail but

00:37:48,220 --> 00:37:53,110
now there's much more optimal ones and

00:37:50,650 --> 00:37:58,170
if you go to the test to manual you can

00:37:53,110 --> 00:38:00,640
see those each event has a set of facets

00:37:58,170 --> 00:38:02,680
facets are the actual information that

00:38:00,640 --> 00:38:03,710
the event tries to convey the first

00:38:02,680 --> 00:38:05,570
facet is in a bow

00:38:03,710 --> 00:38:07,910
and it basically says oh should we

00:38:05,570 --> 00:38:10,010
display this what package generated it

00:38:07,910 --> 00:38:13,280
what are some human readable details

00:38:10,010 --> 00:38:15,050
about this event Amnesty this is how to

00:38:13,280 --> 00:38:17,300
do and skip is implemented

00:38:15,050 --> 00:38:19,880
if there is an amnesty object inside the

00:38:17,300 --> 00:38:22,550
facets then the event will not actually

00:38:19,880 --> 00:38:25,130
cause a failure even if it has failing

00:38:22,550 --> 00:38:26,720
assertions an event can have an

00:38:25,130 --> 00:38:29,210
assertion it doesn't have to but it can

00:38:26,720 --> 00:38:31,369
this is where it determines whether

00:38:29,210 --> 00:38:34,339
something passes or fails you can also

00:38:31,369 --> 00:38:36,140
give it a test number and details is the

00:38:34,339 --> 00:38:39,650
human readable name of that assertion

00:38:36,140 --> 00:38:40,849
there's control which just has a bunch

00:38:39,650 --> 00:38:43,490
of internals you don't need to know

00:38:40,849 --> 00:38:46,040
about errors you can add error strings

00:38:43,490 --> 00:38:48,109
specifically to your event so that you

00:38:46,040 --> 00:38:50,180
can see oh hey test two had an error or

00:38:48,109 --> 00:38:52,099
my tool had an error that is separate

00:38:50,180 --> 00:38:53,900
from the actual failure like if there

00:38:52,099 --> 00:38:56,720
was an internal error in your test tool

00:38:53,900 --> 00:38:58,430
you could put in there info is how note

00:38:56,720 --> 00:39:01,970
and diag are implemented and you can

00:38:58,430 --> 00:39:06,800
have any number of info items in info

00:39:01,970 --> 00:39:09,290
facets inside of an event parent so it

00:39:06,800 --> 00:39:12,170
basically just gives details of hey if I

00:39:09,290 --> 00:39:15,020
am nested here's how I'm nested that's

00:39:12,170 --> 00:39:17,720
four sub tests there's a plan facet that

00:39:15,020 --> 00:39:20,210
can be thrown in and trace every single

00:39:17,720 --> 00:39:24,320
event generated by test two has a trace

00:39:20,210 --> 00:39:26,690
that tells you where it was generated it

00:39:24,320 --> 00:39:29,030
says what stack frame was it generated

00:39:26,690 --> 00:39:31,490
in what process was it generated and

00:39:29,030 --> 00:39:32,630
what thread and then a few internal

00:39:31,490 --> 00:39:34,369
things you don't need to worry about

00:39:32,630 --> 00:39:37,070
whether or not it was a buffered sub

00:39:34,369 --> 00:39:42,080
test that generated it and this is

00:39:37,070 --> 00:39:43,430
really really handy information then

00:39:42,080 --> 00:39:45,170
I've also got some slides on how to

00:39:43,430 --> 00:39:46,910
convert so many of you are probably

00:39:45,170 --> 00:39:51,020
thinking hey how can I convert to test

00:39:46,910 --> 00:39:52,430
two well first off must I know you do

00:39:51,020 --> 00:39:54,080
not have to upgrade to test you you

00:39:52,430 --> 00:39:56,210
already get a little bit of the benefit

00:39:54,080 --> 00:39:58,609
just because test builder now uses test

00:39:56,210 --> 00:40:01,190
two but I do recommend you look you

00:39:58,609 --> 00:40:03,410
convert however here's a list of things

00:40:01,190 --> 00:40:05,180
that were never updated to work with

00:40:03,410 --> 00:40:07,790
test two and to the best of my knowledge

00:40:05,180 --> 00:40:09,410
are all still broken the only one of

00:40:07,790 --> 00:40:11,869
these that anyone ever seems to care

00:40:09,410 --> 00:40:13,520
about is test aggregate and I believe

00:40:11,869 --> 00:40:16,609
someone here is actually doing a

00:40:13,520 --> 00:40:19,009
presentation on test to aggregate

00:40:16,609 --> 00:40:21,529
I personally do not recommend using

00:40:19,009 --> 00:40:23,779
aggregates I recommend you use tests to

00:40:21,529 --> 00:40:25,789
harness instead which solves the same

00:40:23,779 --> 00:40:28,910
problem but in a way that makes more

00:40:25,789 --> 00:40:30,529
logical sense and tomorrow morning at 9

00:40:28,910 --> 00:40:32,960
a.m. I'm giving a talk on tests to

00:40:30,529 --> 00:40:35,170
harness please go to that one you will

00:40:32,960 --> 00:40:37,730
not regret it

00:40:35,170 --> 00:40:38,930
so I'm not going to go into deep detail

00:40:37,730 --> 00:40:41,150
on these slides because I want to give

00:40:38,930 --> 00:40:43,069
you a little preview of tomorrow's talk

00:40:41,150 --> 00:40:45,259
in the time I have but this is all

00:40:43,069 --> 00:40:46,849
online for you to see it's deep details

00:40:45,259 --> 00:40:49,430
of what to do if you're actually

00:40:46,849 --> 00:40:50,809
converting tests but you're not gonna

00:40:49,430 --> 00:40:52,369
remember them from me talking about it

00:40:50,809 --> 00:40:54,200
now so know that there are plenty of

00:40:52,369 --> 00:40:57,739
this plenty of documentation online for

00:40:54,200 --> 00:40:59,029
that so preview for tomorrow's talk

00:40:57,739 --> 00:41:08,769
before we go to questions and answers

00:40:59,029 --> 00:41:08,769
how much time do I have okay

00:41:17,650 --> 00:41:20,430
okay

00:41:20,720 --> 00:41:26,970
so test to harness which I'll be talking

00:41:23,310 --> 00:41:30,210
in depth tomorrow about is a alternative

00:41:26,970 --> 00:41:33,330
to proof and it understands test two at

00:41:30,210 --> 00:41:34,770
an intimate level so it doesn't par step

00:41:33,330 --> 00:41:36,660
in fact when you're using test to

00:41:34,770 --> 00:41:38,940
harness your test won't even output tap

00:41:36,660 --> 00:41:42,090
they will instead output a stream of

00:41:38,940 --> 00:41:44,040
tests to events in JSON format adjacent

00:41:42,090 --> 00:41:45,750
L format to be specific which the

00:41:44,040 --> 00:41:49,350
harness can then parse which gives you

00:41:45,750 --> 00:41:52,710
lots and lots of wonderful Diagnostics

00:41:49,350 --> 00:41:53,790
abilities so since most of this is

00:41:52,710 --> 00:41:56,100
tomorrow's talk I'm not going to go

00:41:53,790 --> 00:41:59,070
through all of it but here's what the

00:41:56,100 --> 00:42:01,590
output from yes looks like it has a

00:41:59,070 --> 00:42:03,180
quiet but verbose failure mode where any

00:42:01,590 --> 00:42:05,190
test that passes it just says oh yeah

00:42:03,180 --> 00:42:07,830
that test file passed but when it tests

00:42:05,190 --> 00:42:09,690
fails it outputs everything not just the

00:42:07,830 --> 00:42:13,200
standard error so you get the full

00:42:09,690 --> 00:42:14,760
details of the tests that failed there's

00:42:13,200 --> 00:42:16,740
lots of nice features like it'll

00:42:14,760 --> 00:42:18,060
automatically timeout a test if it takes

00:42:16,740 --> 00:42:19,680
too long so you're not just sitting

00:42:18,060 --> 00:42:22,830
there overnight with a test that locked

00:42:19,680 --> 00:42:25,080
up you can preload things to make them

00:42:22,830 --> 00:42:27,180
run faster for instance moose on this

00:42:25,080 --> 00:42:29,010
laptop I think it takes two minutes to

00:42:27,180 --> 00:42:30,930
run the entire test suite but if I tell

00:42:29,010 --> 00:42:32,640
it to preload the moose module and then

00:42:30,930 --> 00:42:35,940
run the test suite it takes about 30

00:42:32,640 --> 00:42:38,250
seconds which is really really nice we

00:42:35,940 --> 00:42:40,560
use this a zip recruiter where I work to

00:42:38,250 --> 00:42:43,350
take our test run time on a single box

00:42:40,560 --> 00:42:44,760
from four hours down to just under an

00:42:43,350 --> 00:42:47,430
hour

00:42:44,760 --> 00:42:48,690
that's how useful yeah is there it's got

00:42:47,430 --> 00:42:50,790
lots of plugins and stuff

00:42:48,690 --> 00:42:52,560
lay out whether most of this you'll see

00:42:50,790 --> 00:42:55,530
tomorrow but I also want to give you

00:42:52,560 --> 00:42:58,500
this preview there is a use a graphical

00:42:55,530 --> 00:43:00,540
user interface to look at the logs that

00:42:58,500 --> 00:43:02,130
you have outputs so you can go oh that

00:43:00,540 --> 00:43:04,580
test run failed let's import the log

00:43:02,130 --> 00:43:08,460
into this tool and then it gives you

00:43:04,580 --> 00:43:11,610
this interface for actually inspecting

00:43:08,460 --> 00:43:13,560
why it failed here it looks like none

00:43:11,610 --> 00:43:15,480
passed or there'd be a pass thing here

00:43:13,560 --> 00:43:16,890
you can say hey filter out these events

00:43:15,480 --> 00:43:18,720
so here I'm saying hey I don't want to

00:43:16,890 --> 00:43:20,310
see the plan I just want to see the

00:43:18,720 --> 00:43:21,960
failures and the Diagnostics and I'll

00:43:20,310 --> 00:43:24,570
filter everything out of it else out of

00:43:21,960 --> 00:43:26,970
your display the tables that the deep

00:43:24,570 --> 00:43:28,410
comparisons test to does are actually

00:43:26,970 --> 00:43:30,270
tables in this this is a web interface

00:43:28,410 --> 00:43:31,559
so you actually have a real table

00:43:30,270 --> 00:43:35,359
instead of some ASCII

00:43:31,559 --> 00:43:37,650
that may or may not fit your screen and

00:43:35,359 --> 00:43:39,359
here is a sub test you can press the

00:43:37,650 --> 00:43:41,099
plus if you want to see what's under the

00:43:39,359 --> 00:43:43,140
sub test but it won't automatically

00:43:41,099 --> 00:43:45,109
expand them for you and that's also done

00:43:43,140 --> 00:43:47,130
via Ajax so that you're not actually

00:43:45,109 --> 00:43:48,779
wasting time loading things you don't

00:43:47,130 --> 00:43:50,430
want to look at so come to my talk

00:43:48,779 --> 00:43:54,449
tomorrow if you want to see more about

00:43:50,430 --> 00:43:56,489
how test to harness can really make your

00:43:54,449 --> 00:44:00,359
life a lot easier that's at 9:00 a.m.

00:43:56,489 --> 00:44:08,029
tomorrow I believe in this room okay so

00:44:00,359 --> 00:44:08,029
now any questions after I close it

00:44:22,560 --> 00:44:31,230
okay come on why aren't you doing my

00:44:24,790 --> 00:44:31,230
port Oh still in yes

00:44:37,180 --> 00:44:40,170
that's no good

00:44:42,480 --> 00:44:49,349
it is ungettable there we go so there

00:44:47,369 --> 00:44:56,809
that's the URL that will redirect you to

00:44:49,349 --> 00:44:56,809
the correct URL other questions

00:45:15,180 --> 00:45:20,400
and I think that might be a bigger

00:45:19,050 --> 00:45:22,050
question that we'll have to go over

00:45:20,400 --> 00:45:25,640
after the talk I don't think I don't

00:45:22,050 --> 00:45:25,640
have an answer for you right now

00:45:35,360 --> 00:45:43,700
ah okay

00:45:38,180 --> 00:45:45,079
okay okay cool yep I'll depending on

00:45:43,700 --> 00:45:48,079
when your talk is I'll probably go to it

00:45:45,079 --> 00:45:51,559
and then after mine okay then if you

00:45:48,079 --> 00:45:53,890
don't mind me heckling I'll sit in I'll

00:45:51,559 --> 00:45:53,890
be nice

00:46:17,010 --> 00:46:23,110
because devil declare is the only way to

00:46:19,660 --> 00:46:25,720
add custom keywords consistently across

00:46:23,110 --> 00:46:28,600
older pearls newer pearls have a keyword

00:46:25,720 --> 00:46:30,280
interface but I needed those tools to

00:46:28,600 --> 00:46:32,380
work on older versions of pearl for work

00:46:30,280 --> 00:46:34,630
and devil declare to date is still the

00:46:32,380 --> 00:46:38,770
most reliable way to add a keyword that

00:46:34,630 --> 00:46:41,230
said that is very cutting very well

00:46:38,770 --> 00:46:43,240
compartmentalised magic it's all off on

00:46:41,230 --> 00:46:46,090
its side it's a second thing to download

00:46:43,240 --> 00:46:48,220
from Sipan and it's very well

00:46:46,090 --> 00:46:51,490
encapsulated and tested I've been using

00:46:48,220 --> 00:46:54,010
it in production for seven years now and

00:46:51,490 --> 00:46:57,720
I've had no complaints line numbers are

00:46:54,010 --> 00:46:59,950
all still correct so it works

00:46:57,720 --> 00:47:07,690
can't remember the last time I even had

00:46:59,950 --> 00:47:10,300
to look at the code anyone else no okay

00:47:07,690 --> 00:47:15,419
then I guess we're done

00:47:10,300 --> 00:47:15,419

YouTube URL: https://www.youtube.com/watch?v=JsZw8P_PCUg


