Title: Mark Stosberg - ‎Techniques to speed up large test suites‎
Publication date: 2013-08-20
Playlist: YAPC::NA 2013
Description: 
	Slides: https://docs.google.com/presentation/d/1isXUyBbhxcw_0t9KNlFUb9MW5wA0Yco3RE5Q0NMOsQ0/pub?start=false&loop=false&delayms=3000#slide=id.p

Learn many of the techniques used to speed up a test suite with more than 20,000 tests. With years of experience building and maintaining the test suite, many techniques were used to get the run time down from over 30 minutes to under 5 minutes, allowing us to run the entire suite for every commit. Topics covered will include unit testing, WWW::Mechanize, Selenium, parallel testing, Test::Class and Moose load time.

(Reading the talk online? Press "S" to see the speaker notes).
Captions: 
	00:00:00,319 --> 00:00:09,510
I'm mark software i work at somersault

00:00:04,710 --> 00:00:13,380
I'm on pearl driven websites I've been

00:00:09,510 --> 00:00:15,480
working on the same project for 10 years

00:00:13,380 --> 00:00:18,180
and I we started with the test suite and

00:00:15,480 --> 00:00:21,210
it's continually grown we're up to the

00:00:18,180 --> 00:00:25,050
point now where we run about 20,000 test

00:00:21,210 --> 00:00:27,390
every time we push commit and that now

00:00:25,050 --> 00:00:28,830
takes about five minutes it used to take

00:00:27,390 --> 00:00:30,810
it long as 30 minutes and i'll be

00:00:28,830 --> 00:00:32,309
talking today about how you might be

00:00:30,810 --> 00:00:35,280
able to make similar games in your own

00:00:32,309 --> 00:00:38,190
test suites to get started I want to get

00:00:35,280 --> 00:00:40,950
a lay of the land of how it is for you

00:00:38,190 --> 00:00:44,550
how many people have a test that takes

00:00:40,950 --> 00:00:50,820
more than five minutes to run more than

00:00:44,550 --> 00:00:54,390
ten more than 30 more than an hour okay

00:00:50,820 --> 00:00:56,940
so some of you can i benefit about how

00:00:54,390 --> 00:01:03,030
many tests are they more than a thousand

00:00:56,940 --> 00:01:05,460
tests more than 10,000 50,000 quite

00:01:03,030 --> 00:01:07,260
allotted that sometime sometimes it's

00:01:05,460 --> 00:01:15,210
sort of arbitrary how many tests those

00:01:07,260 --> 00:01:18,299
are so we'll be speeding up Gear test in

00:01:15,210 --> 00:01:21,270
a number of ways I'll be talking about

00:01:18,299 --> 00:01:23,520
running your tests in parallel speeding

00:01:21,270 --> 00:01:25,560
up browser based test speeding up your

00:01:23,520 --> 00:01:28,770
unit test finding your slow tests and

00:01:25,560 --> 00:01:31,979
other test test process speedups the

00:01:28,770 --> 00:01:33,900
absolute number one thing is running

00:01:31,979 --> 00:01:35,520
your tests in parallel how many are

00:01:33,900 --> 00:01:39,000
running already running tests in

00:01:35,520 --> 00:01:43,110
parallel just a few so this is this is a

00:01:39,000 --> 00:01:46,939
is a big deal most machines have

00:01:43,110 --> 00:01:49,290
multiple cores in them now and you can

00:01:46,939 --> 00:01:52,470
you're running not in parallel you

00:01:49,290 --> 00:01:54,960
probably take advantage of just one core

00:01:52,470 --> 00:01:57,450
perhaps and you really can get an

00:01:54,960 --> 00:02:01,860
improvement that's a measure of change

00:01:57,450 --> 00:02:05,759
of running for X parallel can get you to

00:02:01,860 --> 00:02:07,469
close to four times faster are I said

00:02:05,759 --> 00:02:09,509
our project is a database back website

00:02:07,469 --> 00:02:11,640
we have over 50 tables and a lot of

00:02:09,509 --> 00:02:13,200
fixture data and

00:02:11,640 --> 00:02:15,300
because at the time it would take just

00:02:13,200 --> 00:02:17,250
to set up a basic database it's not

00:02:15,300 --> 00:02:19,230
feasible for us to take every test file

00:02:17,250 --> 00:02:20,400
and have that run against a fresh

00:02:19,230 --> 00:02:23,010
database so that they can all be

00:02:20,400 --> 00:02:26,370
isolated from the others in that way and

00:02:23,010 --> 00:02:29,510
still get decent performance so our

00:02:26,370 --> 00:02:32,160
techniques are built on the premise that

00:02:29,510 --> 00:02:35,520
the test there's other tests potentially

00:02:32,160 --> 00:02:37,260
modifying the same database and if you

00:02:35,520 --> 00:02:38,690
can write tests in the face of this and

00:02:37,260 --> 00:02:41,819
you can get that extra performance

00:02:38,690 --> 00:02:43,770
benefit of not doing this whole setup

00:02:41,819 --> 00:02:45,270
and teardown every time you run a test

00:02:43,770 --> 00:02:48,900
file since the test files can

00:02:45,270 --> 00:02:50,790
potentially take just a second or so to

00:02:48,900 --> 00:02:54,690
run if they're small or longer if you're

00:02:50,790 --> 00:02:57,600
large here's the some basics of

00:02:54,690 --> 00:02:59,730
parallelizing your test the proof tool

00:02:57,600 --> 00:03:02,430
which is already out there and popular

00:02:59,730 --> 00:03:05,790
it already has a J option and you can

00:03:02,430 --> 00:03:08,370
specify the number how many ways

00:03:05,790 --> 00:03:10,730
parallel you want it and a good starting

00:03:08,370 --> 00:03:13,410
point is your number of cores but keep

00:03:10,730 --> 00:03:15,150
keep checking up and down based on that

00:03:13,410 --> 00:03:17,940
and find out what the fastest is on your

00:03:15,150 --> 00:03:21,420
system it might vary a little bit and I

00:03:17,940 --> 00:03:23,790
put the syntax up for putting default in

00:03:21,420 --> 00:03:28,079
your dot prove our C file and you can

00:03:23,790 --> 00:03:30,239
just that way you can run in parallel by

00:03:28,079 --> 00:03:32,040
default and we do that even if it's we

00:03:30,239 --> 00:03:36,450
do this for what we call a smoke pot

00:03:32,040 --> 00:03:38,220
which is just the our test suite run but

00:03:36,450 --> 00:03:41,190
we also do it by default for developers

00:03:38,220 --> 00:03:44,280
and then if you you want to test just in

00:03:41,190 --> 00:03:47,519
serial you can add dash j1 to override

00:03:44,280 --> 00:03:52,829
that and do just a single run of the

00:03:47,519 --> 00:03:55,260
time the the proof tool has had for

00:03:52,829 --> 00:03:58,440
several years a mechanism to actually

00:03:55,260 --> 00:04:00,060
specify a mix of they call it rules to

00:03:58,440 --> 00:04:02,489
specify some tests running in parallel

00:04:00,060 --> 00:04:05,910
and some tests running in cereal but it

00:04:02,489 --> 00:04:09,090
went undocumented until well just in the

00:04:05,910 --> 00:04:10,890
last few months I found it researched it

00:04:09,090 --> 00:04:13,049
documented it and that documentation has

00:04:10,890 --> 00:04:16,109
only recently been and been published

00:04:13,049 --> 00:04:18,690
and so now if you go to the approved ox

00:04:16,109 --> 00:04:20,459
you'll find this rule system for

00:04:18,690 --> 00:04:23,160
specifying a mix of serial and parallel

00:04:20,459 --> 00:04:25,080
test my

00:04:23,160 --> 00:04:29,130
so then I tried to go further and

00:04:25,080 --> 00:04:30,450
implemented that but I ran into bugs and

00:04:29,130 --> 00:04:32,610
complications with it and it actually

00:04:30,450 --> 00:04:34,470
turned out for me to be fast it was

00:04:32,610 --> 00:04:36,630
faster for me to just get my test to run

00:04:34,470 --> 00:04:38,310
and be parallel safe that was to keep

00:04:36,630 --> 00:04:41,850
trying and trying and trying to support

00:04:38,310 --> 00:04:44,100
the non-parallel test so I'm not

00:04:41,850 --> 00:04:46,710
actually taking advantage of that now

00:04:44,100 --> 00:04:49,380
and I would advise you also based on my

00:04:46,710 --> 00:04:50,670
own experience they've just been some

00:04:49,380 --> 00:04:53,690
time time trying to make you not

00:04:50,670 --> 00:04:57,300
parallel test safe parallel safe and

00:04:53,690 --> 00:05:01,080
instead of trying to avoid it I'll get

00:04:57,300 --> 00:05:03,930
into more about how to do that first

00:05:01,080 --> 00:05:06,030
we'll talk about how to find your tests

00:05:03,930 --> 00:05:09,150
which are not parallel safe so fairly

00:05:06,030 --> 00:05:10,710
straightforward process you get a start

00:05:09,150 --> 00:05:13,680
by getting all your tests to pass on a

00:05:10,710 --> 00:05:16,410
serial run and then you run all your

00:05:13,680 --> 00:05:18,780
tests in parallel and then you notice

00:05:16,410 --> 00:05:24,510
what fails

00:05:18,780 --> 00:05:27,160
so so that out that's how it works but

00:05:24,510 --> 00:05:28,570
if there's randomization your test suite

00:05:27,160 --> 00:05:30,940
the orders are different the timings are

00:05:28,570 --> 00:05:34,240
different you need to really do this the

00:05:30,940 --> 00:05:36,220
last step several times because it make

00:05:34,240 --> 00:05:37,960
it might will take several runs for two

00:05:36,220 --> 00:05:40,990
things which might conflict to trigger a

00:05:37,960 --> 00:05:42,310
race condition or something but that

00:05:40,990 --> 00:05:46,330
process it does eventually work itself

00:05:42,310 --> 00:05:49,510
out this is a really basic technique the

00:05:46,330 --> 00:05:52,210
basic technique that we use for creating

00:05:49,510 --> 00:05:55,060
our tests that can safely collaborate

00:05:52,210 --> 00:05:56,650
with each other when I say entity I'm

00:05:55,060 --> 00:05:58,270
thinking a database sense it's basically

00:05:56,650 --> 00:05:59,800
inserts an entity you know the database

00:05:58,270 --> 00:06:02,800
usually through the back door cuz that's

00:05:59,800 --> 00:06:04,360
fast this just direct database insert do

00:06:02,800 --> 00:06:06,700
whatever you're testing with it because

00:06:04,360 --> 00:06:10,080
you inserts it you know the ID and then

00:06:06,700 --> 00:06:12,910
can throw it away when you're done or

00:06:10,080 --> 00:06:18,460
and that really that covers a lot of a

00:06:12,910 --> 00:06:20,590
lot of cases and it's simple to do we're

00:06:18,460 --> 00:06:22,630
a web with so web based project and

00:06:20,590 --> 00:06:25,090
sometimes our testing is stuffing web

00:06:22,630 --> 00:06:27,250
forms testing good input and lots of bad

00:06:25,090 --> 00:06:28,570
input and we don't get to know the ID of

00:06:27,250 --> 00:06:31,539
the thing that's going to be generated

00:06:28,570 --> 00:06:35,080
in advance but that's that's a fairly

00:06:31,539 --> 00:06:38,139
easy recipe for that you're probably

00:06:35,080 --> 00:06:40,300
using mechanized for your web based test

00:06:38,139 --> 00:06:41,950
you can just generate a random value

00:06:40,300 --> 00:06:45,340
like if it's the first name field you

00:06:41,950 --> 00:06:47,620
can put a first name field in and then

00:06:45,340 --> 00:06:49,690
you can then you can find the exact

00:06:47,620 --> 00:06:52,000
value that you're working with after the

00:06:49,690 --> 00:06:54,520
fact your tests we can make a select on

00:06:52,000 --> 00:06:56,530
the database and look up something with

00:06:54,520 --> 00:06:58,210
a random and unique data and now you're

00:06:56,530 --> 00:06:59,770
sort of back to that case where you know

00:06:58,210 --> 00:07:03,160
you're uniquely working with a field

00:06:59,770 --> 00:07:04,419
that you just inserted a variation of

00:07:03,160 --> 00:07:08,020
that which didn't work which I should

00:07:04,419 --> 00:07:10,300
mention is we used to say Oh after i

00:07:08,020 --> 00:07:12,639
insert i'll just select the ID of the

00:07:10,300 --> 00:07:15,160
last thing i inserted my sequel they

00:07:12,639 --> 00:07:16,630
call it last insert ID you can't do that

00:07:15,160 --> 00:07:19,060
because something else will run right at

00:07:16,630 --> 00:07:21,460
the same time and you'll get an off by

00:07:19,060 --> 00:07:22,960
one problem but if you insert a unique

00:07:21,460 --> 00:07:25,990
value and then select that then that's

00:07:22,960 --> 00:07:28,139
that's has a have a good chance of

00:07:25,990 --> 00:07:28,139
working

00:07:28,370 --> 00:07:35,560
this next technique is was sort of

00:07:35,860 --> 00:07:44,270
something I figured out which helped

00:07:37,850 --> 00:07:46,340
quite a lot and so if you have something

00:07:44,270 --> 00:07:48,290
like a search in your running a search

00:07:46,340 --> 00:07:49,729
in one part of the database on something

00:07:48,290 --> 00:07:52,790
another test might be searching the same

00:07:49,729 --> 00:07:54,500
part of the database the generic ID idea

00:07:52,790 --> 00:07:56,210
of just inserting entity working with

00:07:54,500 --> 00:08:00,500
that and cleaning it up it won't work

00:07:56,210 --> 00:08:02,180
you need more isolation than that and

00:08:00,500 --> 00:08:04,190
instead of starting with a whole new

00:08:02,180 --> 00:08:05,600
database what we found worked really

00:08:04,190 --> 00:08:12,380
well it's what I call a temporary

00:08:05,600 --> 00:08:14,479
masking table and it's just a it's a

00:08:12,380 --> 00:08:17,660
temporary table but at least in Postgres

00:08:14,479 --> 00:08:20,960
you can create a temporary table which

00:08:17,660 --> 00:08:23,600
has exactly the same name as the table

00:08:20,960 --> 00:08:26,960
as the target table so what it is it's a

00:08:23,600 --> 00:08:28,340
private copy and view of the table just

00:08:26,960 --> 00:08:30,380
for your session that nobody else can

00:08:28,340 --> 00:08:32,150
see so you can even have two tests doing

00:08:30,380 --> 00:08:35,479
the same thing in parallel and they'll

00:08:32,150 --> 00:08:40,520
each get their private copy of the table

00:08:35,479 --> 00:08:42,860
with the same name right yeah I didn't

00:08:40,520 --> 00:08:44,300
research all the other databases but you

00:08:42,860 --> 00:08:50,540
could apply the ideas and I'm sure

00:08:44,300 --> 00:08:51,680
something similar could work absolutely

00:08:50,540 --> 00:08:55,670
and automatically you don't even have to

00:08:51,680 --> 00:08:58,310
drop it yes yeah now a lot of this

00:08:55,670 --> 00:09:00,200
depends on the next trick because so

00:08:58,310 --> 00:09:02,870
I'll go into some more but for this to

00:09:00,200 --> 00:09:04,520
work your app your application has to

00:09:02,870 --> 00:09:08,990
share the same database handle as the

00:09:04,520 --> 00:09:12,230
test suite otherwise it won't be seeing

00:09:08,990 --> 00:09:14,300
the same view of the table and there's

00:09:12,230 --> 00:09:16,730
it so you get to speed ups from this or

00:09:14,300 --> 00:09:19,640
you get the parallel safe speed up but

00:09:16,730 --> 00:09:22,279
also your temporary table that you use

00:09:19,640 --> 00:09:23,660
to mask the actual table can be empty or

00:09:22,279 --> 00:09:26,900
minimally size it can be whatever you

00:09:23,660 --> 00:09:29,060
want so if the old slow test used to run

00:09:26,900 --> 00:09:29,730
on 10,000 rows you can now run on zero

00:09:29,060 --> 00:09:31,290
rows 10

00:09:29,730 --> 00:09:35,149
however many you want and I'm going to

00:09:31,290 --> 00:09:37,380
go into more detail on these points and

00:09:35,149 --> 00:09:42,410
yes as I said works at least with

00:09:37,380 --> 00:09:48,380
postgres there's temporary views to the

00:09:42,410 --> 00:09:51,000
same idea this is a sort of the first up

00:09:48,380 --> 00:09:53,010
version i took it's really just create

00:09:51,000 --> 00:09:54,779
the temporary table with the same name

00:09:53,010 --> 00:09:57,660
as the other one selects our limit one

00:09:54,779 --> 00:10:01,250
but before you take notes on that this

00:09:57,660 --> 00:10:03,720
was this is the better way to do it in

00:10:01,250 --> 00:10:08,040
Postgres you can say create temporary

00:10:03,720 --> 00:10:09,959
table with the same name like the other

00:10:08,040 --> 00:10:12,180
table and including all and what

00:10:09,959 --> 00:10:13,380
including all means is it includes all

00:10:12,180 --> 00:10:15,570
the same defaults all the same

00:10:13,380 --> 00:10:17,040
constraints all the same indexes all the

00:10:15,570 --> 00:10:20,220
same storage options and even all the

00:10:17,040 --> 00:10:23,699
same comments on it so it is extremely

00:10:20,220 --> 00:10:25,620
like the the table it's it's masking but

00:10:23,699 --> 00:10:27,660
it just takes a really small amount of

00:10:25,620 --> 00:10:29,790
time but to set up so you this temporary

00:10:27,660 --> 00:10:32,250
table it's just like your main table and

00:10:29,790 --> 00:10:35,069
you're all set to go with it and that's

00:10:32,250 --> 00:10:36,510
the one I use the first variation maybe

00:10:35,069 --> 00:10:38,579
I don't know maybe use that if you

00:10:36,510 --> 00:10:39,779
wanted tin Road the random data to start

00:10:38,579 --> 00:10:45,540
with or something from the other table

00:10:39,779 --> 00:10:49,800
but so if you have a unit test it's it's

00:10:45,540 --> 00:10:52,050
a simplest case you create the table at

00:10:49,800 --> 00:10:53,699
the top of your test script you make

00:10:52,050 --> 00:10:56,010
sure you share the same database handle

00:10:53,699 --> 00:10:57,990
which I'll show more detail and then you

00:10:56,010 --> 00:10:59,699
just run your tests as normal so it's an

00:10:57,990 --> 00:11:02,250
easy retro fit if you're writing tests

00:10:59,699 --> 00:11:03,930
we had to retrofit because we did this

00:11:02,250 --> 00:11:05,339
thing where we weren't running in

00:11:03,930 --> 00:11:11,579
parallel and then when you had to figure

00:11:05,339 --> 00:11:13,350
out how to fix things and this worked it

00:11:11,579 --> 00:11:15,029
doesn't have to be hard to share the

00:11:13,350 --> 00:11:16,709
database handle if you're already

00:11:15,029 --> 00:11:18,389
getting your app object and your half

00:11:16,709 --> 00:11:21,660
object has an easily accessible database

00:11:18,389 --> 00:11:23,810
handle in your test you can just use it

00:11:21,660 --> 00:11:26,089
in your test it doesn't have to be

00:11:23,810 --> 00:11:28,380
complicated i know i'm sure there's

00:11:26,089 --> 00:11:30,569
maybe there's some reason it could go

00:11:28,380 --> 00:11:33,360
wrong but it pragmatically it has worked

00:11:30,569 --> 00:11:35,310
for us again just another example

00:11:33,360 --> 00:11:36,690
doesn't have to be complicated it

00:11:35,310 --> 00:11:38,399
doesn't matter which way you assign

00:11:36,690 --> 00:11:38,819
which to the others just as long as they

00:11:38,399 --> 00:11:42,689
end up the

00:11:38,819 --> 00:11:44,069
the same so this capital dbh is just the

00:11:42,689 --> 00:11:48,089
idea of something if in your test suite

00:11:44,069 --> 00:11:52,489
however you want to do it just assign

00:11:48,089 --> 00:11:52,489
them to each other and and go from there

00:11:52,789 --> 00:11:56,819
now sharing a database handles

00:11:55,109 --> 00:11:58,379
mechanized tests got to be interesting

00:11:56,819 --> 00:12:00,470
because I like this technique so much I

00:11:58,379 --> 00:12:03,569
wanted to apply to more than unit tests

00:12:00,470 --> 00:12:07,919
how can I apply it to mechanize test so

00:12:03,569 --> 00:12:10,589
there's a problem to do this your app

00:12:07,919 --> 00:12:11,939
and the test and the app have to run in

00:12:10,589 --> 00:12:13,649
the same process so I'm like well I

00:12:11,939 --> 00:12:15,720
can't do that with Apache because my

00:12:13,649 --> 00:12:18,629
test suite is in this process and they

00:12:15,720 --> 00:12:20,399
Apache mod mod perl applications in this

00:12:18,629 --> 00:12:24,720
process they can't share the database

00:12:20,399 --> 00:12:27,179
handle how can i solve that so i looked

00:12:24,720 --> 00:12:28,949
at the guts of these testing modules

00:12:27,179 --> 00:12:31,199
that are available in Sipan there's test

00:12:28,949 --> 00:12:34,259
w mechanized there's catalysts or CGI

00:12:31,199 --> 00:12:36,389
active I'm focusing here on psu I but

00:12:34,259 --> 00:12:37,439
the ones I've looked at our implementing

00:12:36,389 --> 00:12:39,689
the same way it's actually the same

00:12:37,439 --> 00:12:41,339
process it's testing on the front end

00:12:39,689 --> 00:12:43,439
and then test at some point passes it

00:12:41,339 --> 00:12:45,809
off to the application in a pearl sense

00:12:43,439 --> 00:12:48,269
and it gets done returns and passes it

00:12:45,809 --> 00:12:51,179
back but it's all the same process so by

00:12:48,269 --> 00:12:54,569
using this for some tests instead of the

00:12:51,179 --> 00:12:55,829
apache mod perl usual mechanized then

00:12:54,569 --> 00:12:58,350
you can share the database handle

00:12:55,829 --> 00:13:02,789
because same problem but it's still a

00:12:58,350 --> 00:13:04,979
little bit tricky this is a closure

00:13:02,789 --> 00:13:06,659
technique I'm not necessarily this is

00:13:04,979 --> 00:13:08,579
just an example you can figure out

00:13:06,659 --> 00:13:11,729
another way to do it if your database

00:13:08,579 --> 00:13:13,889
handle was available in a class you're

00:13:11,729 --> 00:13:15,929
like a class method they could share it

00:13:13,889 --> 00:13:18,689
they could both access the same class

00:13:15,929 --> 00:13:21,449
method or in this case it's the idea

00:13:18,689 --> 00:13:25,350
that my psg I app actually has a little

00:13:21,449 --> 00:13:27,029
wrapper we're in within the wrapper

00:13:25,350 --> 00:13:28,470
access to the database handle from the

00:13:27,029 --> 00:13:31,049
test suite so they set to each other

00:13:28,470 --> 00:13:32,639
there's different ways that you could

00:13:31,049 --> 00:13:34,949
solve it but the key thing I'm sharing

00:13:32,639 --> 00:13:36,629
is the idea that you can do this because

00:13:34,949 --> 00:13:38,909
with these kinds of tools there in the

00:13:36,629 --> 00:13:40,589
they are in the same process you could

00:13:38,909 --> 00:13:46,169
also decide that well I could make that

00:13:40,589 --> 00:13:48,749
a unit test two but the main thing there

00:13:46,169 --> 00:13:51,199
is it's the idea implementation details

00:13:48,749 --> 00:13:51,199
are up to you

00:13:51,940 --> 00:13:59,870
when I'm move on to some improvements I

00:13:56,300 --> 00:14:02,120
found for browser-based test both with

00:13:59,870 --> 00:14:04,190
mechanized and selenium and when I talk

00:14:02,120 --> 00:14:06,740
about mechanize I'm talking them for me

00:14:04,190 --> 00:14:09,500
it's test ww mechanized and with

00:14:06,740 --> 00:14:12,560
selenium i'm using the selenium remote

00:14:09,500 --> 00:14:14,390
driver perl module and it has a test a

00:14:12,560 --> 00:14:25,310
similar testing related class called

00:14:14,390 --> 00:14:26,810
test webdriver and see oh yes so first

00:14:25,310 --> 00:14:28,430
one is only a selenium if there's

00:14:26,810 --> 00:14:32,690
JavaScript involved because it's it's

00:14:28,430 --> 00:14:34,850
slow when you're using mechanized you're

00:14:32,690 --> 00:14:37,010
driving a browser directly you say get a

00:14:34,850 --> 00:14:38,810
website and it gets a website when

00:14:37,010 --> 00:14:40,670
you're using selenium it's already sort

00:14:38,810 --> 00:14:42,680
of inherently slow because it's driving

00:14:40,670 --> 00:14:45,529
a real web browser but the whole model

00:14:42,680 --> 00:14:48,800
is when you say tell selenium get a web

00:14:45,529 --> 00:14:51,200
page it's sending an HTTP request to the

00:14:48,800 --> 00:14:54,140
selenium browser which is inserting HTTP

00:14:51,200 --> 00:14:57,230
request to the servers so this is extra

00:14:54,140 --> 00:15:00,829
layer of abstraction HP's extra HTTP

00:14:57,230 --> 00:15:03,500
requests are generally slow relative to

00:15:00,829 --> 00:15:07,010
just anything on a local file system so

00:15:03,500 --> 00:15:11,529
our rule is we use mechanized wherever

00:15:07,010 --> 00:15:11,529
we can and selenium where we have to

00:15:14,800 --> 00:15:23,660
let's see phantom dais has come up in

00:15:20,120 --> 00:15:27,649
some slides and some presentations

00:15:23,660 --> 00:15:29,630
already and I recommend it selenium

00:15:27,649 --> 00:15:31,670
normally drives real web browsers like

00:15:29,630 --> 00:15:35,120
desktop web browsers firefox internet

00:15:31,670 --> 00:15:37,579
explorer and that's I mentioned somewhat

00:15:35,120 --> 00:15:40,190
slow phantom jet speeds this somewhat up

00:15:37,579 --> 00:15:41,899
because it's a headless web browser so

00:15:40,190 --> 00:15:43,459
running my test on a server for this

00:15:41,899 --> 00:15:45,260
headless webkit browser can be right

00:15:43,459 --> 00:15:46,760
there in the server and that speeds up

00:15:45,260 --> 00:15:52,010
the interactions versions more network

00:15:46,760 --> 00:15:55,430
connections and so forth and phantom

00:15:52,010 --> 00:15:56,899
dias can work it I has the same

00:15:55,430 --> 00:15:58,550
interface as the selenium servers

00:15:56,899 --> 00:15:59,640
through something that calls the ghost

00:15:58,550 --> 00:16:02,580
driver extension

00:15:59,640 --> 00:16:04,410
so you can your tests can be unmodified

00:16:02,580 --> 00:16:07,670
and run first against phantom j us and

00:16:04,410 --> 00:16:14,790
also against another selenium server and

00:16:07,670 --> 00:16:16,260
I'm gets significantly faster we're just

00:16:14,790 --> 00:16:18,870
now getting into this but the plan

00:16:16,260 --> 00:16:21,080
design is that our fasts anthem Jas test

00:16:18,870 --> 00:16:23,700
we're going to run on every push and

00:16:21,080 --> 00:16:26,490
we'll run on all supported browsers on a

00:16:23,700 --> 00:16:29,210
on a nightly cron job and that's another

00:16:26,490 --> 00:16:31,920
way to keep the common case fast but

00:16:29,210 --> 00:16:36,150
still get all the quality we need from

00:16:31,920 --> 00:16:37,860
testing all the routers dude this is a

00:16:36,150 --> 00:16:41,220
pattern which I just recently fixed in

00:16:37,860 --> 00:16:43,440
my code if you're using mechanized tests

00:16:41,220 --> 00:16:45,750
this might look familiar you've got a

00:16:43,440 --> 00:16:48,570
form you want to test a good input and

00:16:45,750 --> 00:16:49,860
some bad inputs so you load the page you

00:16:48,570 --> 00:16:51,690
submit some bad inputs you check for

00:16:49,860 --> 00:16:53,460
result you load the page you check for

00:16:51,690 --> 00:16:55,200
more bad inputs you load the page you

00:16:53,460 --> 00:16:58,890
check for some good inputs and check

00:16:55,200 --> 00:17:00,810
your page well that has all these HTTP

00:16:58,890 --> 00:17:02,550
requests but this get okay that happens

00:17:00,810 --> 00:17:04,650
three times you're just doing all this

00:17:02,550 --> 00:17:06,600
work and getting the same answer all

00:17:04,650 --> 00:17:11,430
three times if you notice the form isn't

00:17:06,600 --> 00:17:13,079
changing so that can be sped up and one

00:17:11,430 --> 00:17:15,720
way to do this is to get the browser in

00:17:13,079 --> 00:17:18,540
the state you want by go ahead and

00:17:15,720 --> 00:17:20,490
creating your mechanized object you go

00:17:18,540 --> 00:17:21,810
ahead and get the page but then instead

00:17:20,490 --> 00:17:23,370
of reef etching the page you just

00:17:21,810 --> 00:17:24,660
reclone the browser that was already in

00:17:23,370 --> 00:17:26,850
the state you wanted and then you

00:17:24,660 --> 00:17:28,580
eliminate all of that extra HTTP request

00:17:26,850 --> 00:17:31,380
I just worked on a test where we

00:17:28,580 --> 00:17:32,910
retested the form like 10 times and I

00:17:31,380 --> 00:17:36,630
was able to cut out like nine of those

00:17:32,910 --> 00:17:39,420
extra requests because we just were

00:17:36,630 --> 00:17:44,280
cloning the browser at this initialized

00:17:39,420 --> 00:17:47,160
state instead this is a variation on the

00:17:44,280 --> 00:17:49,410
same idea if again if you're testing a

00:17:47,160 --> 00:17:53,400
form with mechanize a bunch of times you

00:17:49,410 --> 00:17:55,500
can submit the form once through submit

00:17:53,400 --> 00:17:57,300
form okay and that makes sure that the

00:17:55,500 --> 00:18:00,780
form has all the fields you want and

00:17:57,300 --> 00:18:03,390
that it can generally submit okay but

00:18:00,780 --> 00:18:05,640
after that you can skip reloading the

00:18:03,390 --> 00:18:08,430
page again and just eventually post to

00:18:05,640 --> 00:18:11,280
the run mode that processes it over and

00:18:08,430 --> 00:18:12,930
over this is I think a weaker test and

00:18:11,280 --> 00:18:15,000
the one I just showed you because you

00:18:12,930 --> 00:18:17,040
could accidentally submit a post request

00:18:15,000 --> 00:18:19,200
which was invalid in the sense that it

00:18:17,040 --> 00:18:22,920
wouldn't submit through the form but if

00:18:19,200 --> 00:18:25,200
you were writing the web services for

00:18:22,920 --> 00:18:26,610
api testing other some other cases i

00:18:25,200 --> 00:18:35,610
just thought it would be worth showing

00:18:26,610 --> 00:18:39,480
is another way to do things yeah so as i

00:18:35,610 --> 00:18:42,420
wrote on the slide if you have a lengthy

00:18:39,480 --> 00:18:44,430
way to do things in a shortcut take the

00:18:42,420 --> 00:18:45,810
long way once the shortcut the rest of

00:18:44,430 --> 00:18:48,030
time and I'm I'll show you a particular

00:18:45,810 --> 00:18:52,940
way that I use this idea to speed up

00:18:48,030 --> 00:18:55,980
logins with mechanized and selenium so a

00:18:52,940 --> 00:18:57,510
common thing for us is for certain

00:18:55,980 --> 00:19:00,300
features you have to be authenticated

00:18:57,510 --> 00:19:02,310
with the application you have to have a

00:19:00,300 --> 00:19:04,410
user the user has to go to the forum and

00:19:02,310 --> 00:19:05,970
login and then get to their homepage and

00:19:04,410 --> 00:19:09,690
then you can finally test the feature as

00:19:05,970 --> 00:19:12,840
this authenticated user and we put that

00:19:09,690 --> 00:19:14,700
in a function and it looks as if all

00:19:12,840 --> 00:19:19,860
this basic recipe you insert the user

00:19:14,700 --> 00:19:21,450
you get a login page you put in a

00:19:19,860 --> 00:19:23,190
username and password and you submit and

00:19:21,450 --> 00:19:25,980
that submit actually sends them to our

00:19:23,190 --> 00:19:27,420
homepage which makes an extra redirect

00:19:25,980 --> 00:19:30,030
so there's actually three HTP request

00:19:27,420 --> 00:19:31,410
here the initial form load submitting

00:19:30,030 --> 00:19:33,120
the form and then getting redirected of

00:19:31,410 --> 00:19:35,940
your home patriot anyone else writing

00:19:33,120 --> 00:19:38,670
code like this for testing websites yeah

00:19:35,940 --> 00:19:40,140
we had a lot of it and then it used to

00:19:38,670 --> 00:19:42,030
be worse because it wasn't encapsulated

00:19:40,140 --> 00:19:47,330
function it was all sort of copy pasted

00:19:42,030 --> 00:19:51,930
and test here's how we we fixed that I

00:19:47,330 --> 00:19:53,850
said okay well look we'll test the login

00:19:51,930 --> 00:19:55,680
system in one place right and we know

00:19:53,850 --> 00:19:59,670
that works we don't need to redo that

00:19:55,680 --> 00:20:01,650
everywhere else so the fix is we still

00:19:59,670 --> 00:20:03,750
insert a test user we use a backdoor

00:20:01,650 --> 00:20:05,730
function it says just set the user

00:20:03,750 --> 00:20:07,230
logged in for us that's inserting a row

00:20:05,730 --> 00:20:10,090
in a session table and getting back at

00:20:07,230 --> 00:20:13,900
session ID my probably similar

00:20:10,090 --> 00:20:15,190
your web apps the ultimate result of log

00:20:13,900 --> 00:20:17,140
in amanda's they get a cookie set in

00:20:15,190 --> 00:20:21,250
your browser there's a fairly new module

00:20:17,140 --> 00:20:24,880
HTTP cookie jar lwp and it allows you

00:20:21,250 --> 00:20:26,559
with a nice little add add method to add

00:20:24,880 --> 00:20:28,450
a cookie and then we just initialize our

00:20:26,559 --> 00:20:31,360
mechanized with the cookie it needs to

00:20:28,450 --> 00:20:34,510
login so for all these cases we went

00:20:31,360 --> 00:20:40,059
from three HTTP requests for this login

00:20:34,510 --> 00:20:41,590
set up to zero and that was a win but we

00:20:40,059 --> 00:20:43,809
are code coverage is no worse because we

00:20:41,590 --> 00:20:47,049
cover the login system still in one

00:20:43,809 --> 00:20:48,820
place somewhere else I was quite excited

00:20:47,049 --> 00:20:51,789
to see what would happen to apply that

00:20:48,820 --> 00:20:53,770
to the selenium logins which we also do

00:20:51,789 --> 00:20:55,630
and as I've just told you the selenium

00:20:53,770 --> 00:20:58,360
model is that youth first send HTTP

00:20:55,630 --> 00:21:01,000
requests to the driven browser for

00:20:58,360 --> 00:21:05,470
selenium and then it seems the HTTP

00:21:01,000 --> 00:21:07,059
request off off to the Internet and some

00:21:05,470 --> 00:21:08,860
of the methods that you see on the

00:21:07,059 --> 00:21:13,179
slides here are actually shortcut so

00:21:08,860 --> 00:21:17,370
they do more than one thing and so this

00:21:13,179 --> 00:21:21,070
same flow in selenium it actually takes

00:21:17,370 --> 00:21:23,409
12 HTTP requests between the one that

00:21:21,070 --> 00:21:25,870
you soon to the browser and the ones

00:21:23,409 --> 00:21:27,399
that's making off to the Internet so

00:21:25,870 --> 00:21:30,669
it's and then we're doing that again all

00:21:27,399 --> 00:21:32,289
the time you log someone in so you can

00:21:30,669 --> 00:21:35,590
apply the same pattern to a selenium

00:21:32,289 --> 00:21:38,940
wall again it already has an ad cookie

00:21:35,590 --> 00:21:41,230
method right there in selenium you still

00:21:38,940 --> 00:21:42,820
because it is a real browser you have to

00:21:41,230 --> 00:21:45,549
visit a page before you can set a cookie

00:21:42,820 --> 00:21:47,919
so I arbitrarily visited the login page

00:21:45,549 --> 00:21:49,630
but once I visit a login page I could

00:21:47,919 --> 00:21:51,720
skip all the other all the other steps

00:21:49,630 --> 00:21:53,649
and just set the cookie in the browser

00:21:51,720 --> 00:21:55,090
so that it's still a little more

00:21:53,649 --> 00:21:56,649
overhead because of the model so i

00:21:55,090 --> 00:21:58,840
couldn't get down to zero but i got down

00:21:56,649 --> 00:22:01,840
to three HTTP requests from 12 from his

00:21:58,840 --> 00:22:10,210
common case so that was speeding up a

00:22:01,840 --> 00:22:11,679
really common pattern again just knowing

00:22:10,210 --> 00:22:13,750
that this whole model with selenium is

00:22:11,679 --> 00:22:15,970
different it what appears to be local

00:22:13,750 --> 00:22:18,429
like you used to with mechanized is not

00:22:15,970 --> 00:22:18,909
really local with selenium so another

00:22:18,429 --> 00:22:21,489
pattern

00:22:18,909 --> 00:22:23,259
you have is we load up a page we test

00:22:21,489 --> 00:22:24,909
the content for one reg acts we tested

00:22:23,259 --> 00:22:28,029
for another tested for another tested

00:22:24,909 --> 00:22:29,529
for a Dom element what I realized was

00:22:28,029 --> 00:22:31,869
happening with selenium is when we were

00:22:29,529 --> 00:22:34,330
applying the same approach it was hit

00:22:31,869 --> 00:22:35,950
was making all these htp it was asking

00:22:34,330 --> 00:22:37,269
the browser what's your page source so I

00:22:35,950 --> 00:22:38,679
can check it what's your page search so

00:22:37,269 --> 00:22:41,320
I can check it what's your picture so I

00:22:38,679 --> 00:22:43,690
can check it so once I realize that then

00:22:41,320 --> 00:22:45,519
I realize we could refactor it so you

00:22:43,690 --> 00:22:47,859
say get the page source from selenium

00:22:45,519 --> 00:22:49,059
once and then you just check regular

00:22:47,859 --> 00:22:50,979
expressions against it multiple times

00:22:49,059 --> 00:22:52,840
since you know it's not changing if you

00:22:50,979 --> 00:22:55,419
for some reason the content might change

00:22:52,840 --> 00:22:57,759
you would need to refit the selenium

00:22:55,419 --> 00:23:00,779
remote driver is a fairly young project

00:22:57,759 --> 00:23:03,309
because the selenium API has changed so

00:23:00,779 --> 00:23:06,369
an improvement like this could become

00:23:03,309 --> 00:23:11,320
built into pearls of interface to the

00:23:06,369 --> 00:23:15,279
selenium tools but right now it's not

00:23:11,320 --> 00:23:17,289
there this is just a fancier example of

00:23:15,279 --> 00:23:19,929
the same thing if you want to use

00:23:17,289 --> 00:23:21,909
instead of just reg X's over your page

00:23:19,929 --> 00:23:23,470
if you wanted to do dham checking you

00:23:21,909 --> 00:23:27,279
could load the page source once from

00:23:23,470 --> 00:23:28,979
selenium turn it into a mojo Dom object

00:23:27,279 --> 00:23:33,399
and you could do fancy your checks

00:23:28,979 --> 00:23:35,080
against the page and selenium has a way

00:23:33,399 --> 00:23:36,159
to do that but then again you're hitting

00:23:35,080 --> 00:23:38,289
the browser every time and add you can

00:23:36,159 --> 00:23:42,519
always network request to you do your

00:23:38,289 --> 00:23:46,119
test how many of you have heard of sauce

00:23:42,519 --> 00:23:50,470
labs great though we'll whip through

00:23:46,119 --> 00:23:52,899
these it's a selenium based testing

00:23:50,470 --> 00:23:54,789
service hosted at amazon they allow you

00:23:52,899 --> 00:23:57,099
to run your tests on a combination of

00:23:54,789 --> 00:24:01,239
over 150 operating systems and browsers

00:23:57,099 --> 00:24:06,389
and that includes newer browsers mobile

00:24:01,239 --> 00:24:09,519
on iOS and Android so when we talk about

00:24:06,389 --> 00:24:11,129
running our phantom j/s tests most of

00:24:09,519 --> 00:24:13,779
the time and our other tests are

00:24:11,129 --> 00:24:17,369
supported browsers overnight we're using

00:24:13,779 --> 00:24:21,700
soft labs it also has its own parallel

00:24:17,369 --> 00:24:22,540
testing system that allows you to run

00:24:21,700 --> 00:24:26,530
tests there

00:24:22,540 --> 00:24:32,260
parallel to talk some more about

00:24:26,530 --> 00:24:34,960
speeding up unit test fork proved is a

00:24:32,260 --> 00:24:38,410
fairly new project to its i call it mod

00:24:34,960 --> 00:24:40,330
perl for test the ID the benefit that it

00:24:38,410 --> 00:24:42,820
brings from mod perl is mod perl has a

00:24:40,330 --> 00:24:44,500
startup file allows you to preload a

00:24:42,820 --> 00:24:46,000
bunch of things and then when it gets

00:24:44,500 --> 00:24:49,510
fork you already have all these things

00:24:46,000 --> 00:24:53,620
pre-loaded in your module preloaded in

00:24:49,510 --> 00:24:57,220
your process and fork proved has the

00:24:53,620 --> 00:24:58,900
same design it allows you to specify a

00:24:57,220 --> 00:25:00,730
preload file where you pre-loaded a lot

00:24:58,900 --> 00:25:05,020
of things and it would fork and run all

00:25:00,730 --> 00:25:07,960
your tests and yeah we actually made a

00:25:05,020 --> 00:25:10,300
project preload p.m. and we use we were

00:25:07,960 --> 00:25:11,890
tested it with both mod perl and for

00:25:10,300 --> 00:25:13,120
proof see if you're already doing one

00:25:11,890 --> 00:25:18,280
you don't have a lot of setup to get

00:25:13,120 --> 00:25:19,570
ready to do the other yeah if you look

00:25:18,280 --> 00:25:21,520
if you're loading a lot of moose every

00:25:19,570 --> 00:25:22,750
time you or other heavy modules every

00:25:21,520 --> 00:25:26,170
time you load a test this could be

00:25:22,750 --> 00:25:28,830
something to look into but it may not

00:25:26,170 --> 00:25:33,490
just work some things are not ready

00:25:28,830 --> 00:25:35,560
expecting to be work in this model but I

00:25:33,490 --> 00:25:37,090
and it didn't actually didn't work for

00:25:35,560 --> 00:25:39,790
us i don't remember exactly what it was

00:25:37,090 --> 00:25:45,900
it might have been cgi p.m. or something

00:25:39,790 --> 00:25:49,390
else hey but it's really cheap to try

00:25:45,900 --> 00:25:51,820
just as i said just try it and it's

00:25:49,390 --> 00:25:54,850
cheap to see what breaks and you'll have

00:25:51,820 --> 00:25:56,740
a sense of how hard it might be to get

00:25:54,850 --> 00:25:58,150
it to work when I tried it I did find it

00:25:56,740 --> 00:26:02,410
was going to benchmark better if it

00:25:58,150 --> 00:26:03,700
wasn't for the failures in there so we

00:26:02,410 --> 00:26:09,310
didn't end up using it but it's worth

00:26:03,700 --> 00:26:13,120
the driver for you just classic same

00:26:09,310 --> 00:26:15,340
coding principles applied to test 11

00:26:13,120 --> 00:26:17,920
that worked for us was just clearly

00:26:15,340 --> 00:26:20,710
naming and organizing the test it helped

00:26:17,920 --> 00:26:24,940
us find duplication let's see if with my

00:26:20,710 --> 00:26:27,910
next yep so we said okay our unit tests

00:26:24,940 --> 00:26:30,370
were all just named with no particular

00:26:27,910 --> 00:26:33,230
structure we started to name them

00:26:30,370 --> 00:26:35,929
exactly after the module name

00:26:33,230 --> 00:26:38,660
and then within the module every test

00:26:35,929 --> 00:26:40,429
method were using a test class style was

00:26:38,660 --> 00:26:42,169
named after the method and we did this

00:26:40,429 --> 00:26:44,390
some of these ad hoc naming things when

00:26:42,169 --> 00:26:48,380
we move them into this structure we

00:26:44,390 --> 00:26:50,780
found that duplication because once we

00:26:48,380 --> 00:26:52,190
put the standardized structure in we

00:26:50,780 --> 00:26:53,570
found two tests were suddenly right next

00:26:52,190 --> 00:26:54,740
to each other which were far apart and

00:26:53,570 --> 00:26:56,360
then once we saw them right next to each

00:26:54,740 --> 00:26:58,040
other we could delete some of them

00:26:56,360 --> 00:26:59,809
that's an easy way to speed up your test

00:26:58,040 --> 00:27:03,679
suite is delete duplicate code that you

00:26:59,809 --> 00:27:06,290
didn't need to be maintained anyway so

00:27:03,679 --> 00:27:07,549
if you if you don't have especially so

00:27:06,290 --> 00:27:10,460
part of what we're talking about is

00:27:07,549 --> 00:27:14,140
managing larger test suite and as you

00:27:10,460 --> 00:27:23,620
test suite girls formality helps you

00:27:14,140 --> 00:27:30,020
manage the growth oh yeah so if I was

00:27:23,620 --> 00:27:34,790
testing a if in my class I had a method

00:27:30,020 --> 00:27:36,679
named spring then when I was testing it

00:27:34,790 --> 00:27:40,700
I would name my test class message

00:27:36,679 --> 00:27:43,280
spring springs well you know it would

00:27:40,700 --> 00:27:47,770
just I would just start with a method

00:27:43,280 --> 00:27:47,770
name of the thing I was testing so that

00:27:50,830 --> 00:27:57,020
right and the there's this depending on

00:27:55,040 --> 00:27:59,570
your testing system test class moves as

00:27:57,020 --> 00:28:01,809
you pre start with a test prefix other

00:27:59,570 --> 00:28:05,540
testing systems allow you to put nicely

00:28:01,809 --> 00:28:07,190
my strings instead of trying to put a

00:28:05,540 --> 00:28:09,410
big name into a subroutine name I

00:28:07,190 --> 00:28:12,130
actually would like to use that style

00:28:09,410 --> 00:28:19,660
eventually but any kind of consistency

00:28:12,130 --> 00:28:23,929
will help you this is a something I

00:28:19,660 --> 00:28:26,299
fixed in a number of our tests was a

00:28:23,929 --> 00:28:30,440
test class style systems allow you to do

00:28:26,299 --> 00:28:32,059
/ test file setup so you do something

00:28:30,440 --> 00:28:36,049
once for each test followed running or

00:28:32,059 --> 00:28:37,669
once for each test block and we had a

00:28:36,049 --> 00:28:39,590
lot of tests which we're doing / test

00:28:37,669 --> 00:28:41,900
block set up but it was like fixture

00:28:39,590 --> 00:28:44,659
stuff that never really changed so we we

00:28:41,900 --> 00:28:47,029
were inserting deleting

00:28:44,659 --> 00:28:49,639
a lot of stuff in the same test file

00:28:47,029 --> 00:28:51,080
that didn't was never modified it was

00:28:49,639 --> 00:28:53,299
the same between all the different test

00:28:51,080 --> 00:28:55,340
blocks and I found that I could in a lot

00:28:53,299 --> 00:28:56,989
of cases just instead of doing it per

00:28:55,340 --> 00:28:59,809
every test block I could do it once per

00:28:56,989 --> 00:29:03,229
test file and that was a big that was a

00:28:59,809 --> 00:29:05,450
speed-up do so look look for those cases

00:29:03,229 --> 00:29:07,099
where if you're you may be sort of over

00:29:05,450 --> 00:29:11,119
isolating you might be able to back up a

00:29:07,099 --> 00:29:14,229
little bit this is something I create a

00:29:11,119 --> 00:29:19,820
slide and then since I I created it I

00:29:14,229 --> 00:29:21,739
I'm not sure it's a good idea we were

00:29:19,820 --> 00:29:24,019
using mousse and I thought oh moose is

00:29:21,739 --> 00:29:26,809
heavy right if I can just create a few

00:29:24,019 --> 00:29:28,340
things i'll switch them to move we won't

00:29:26,809 --> 00:29:32,629
spend so much time loading moose in our

00:29:28,340 --> 00:29:34,759
in our unit test but you have what i

00:29:32,629 --> 00:29:36,139
call a moose tipping point where once

00:29:34,759 --> 00:29:40,129
you're loading at once for anything at

00:29:36,139 --> 00:29:44,210
all you gloated it right you and you

00:29:40,129 --> 00:29:46,369
might as well have it and we actually

00:29:44,210 --> 00:29:49,639
had that we had some things which just

00:29:46,369 --> 00:29:50,989
didn't have mu equivalents but you might

00:29:49,639 --> 00:29:53,389
start with moving a new project and

00:29:50,989 --> 00:29:55,820
upgrade when you need it but the more I

00:29:53,389 --> 00:29:56,989
thought about it the more in any large

00:29:55,820 --> 00:29:59,809
project you're probably going to end up

00:29:56,989 --> 00:30:03,409
needing moose or something anyway our

00:29:59,809 --> 00:30:05,149
project uses Amazon's s3 service so we

00:30:03,409 --> 00:30:07,700
use net amazon s3 and it's based on

00:30:05,149 --> 00:30:10,940
moose there's no other not a good

00:30:07,700 --> 00:30:13,369
alternative so I guess it's something to

00:30:10,940 --> 00:30:17,809
consider but it didn't end up good

00:30:13,369 --> 00:30:20,479
chance it won't worship another marginal

00:30:17,809 --> 00:30:22,909
tip that might be more of a coat smell

00:30:20,479 --> 00:30:24,830
than a something to fix we had a base

00:30:22,909 --> 00:30:28,669
class which was used all the time and it

00:30:24,830 --> 00:30:31,479
was loading this s3 plugin and so in our

00:30:28,669 --> 00:30:34,039
unit test we were ending up loading

00:30:31,479 --> 00:30:35,840
moose a lot more than we needed to and

00:30:34,039 --> 00:30:39,700
we were able to speed up our unit test

00:30:35,840 --> 00:30:43,039
because we switch this plugin from

00:30:39,700 --> 00:30:45,440
having to use all the time to just only

00:30:43,039 --> 00:30:48,649
loading that Amazon s3 this heavy moose

00:30:45,440 --> 00:30:50,210
space module when we needed it but you

00:30:48,649 --> 00:30:51,649
could have alternately solved that with

00:30:50,210 --> 00:30:52,999
a different design pattern and say look

00:30:51,649 --> 00:30:53,870
if you're loading this all the time

00:30:52,999 --> 00:30:58,010
you're not actually you

00:30:53,870 --> 00:30:59,240
maybe you maybe you should re-engineer

00:30:58,010 --> 00:31:02,240
things so you're only loading it when

00:30:59,240 --> 00:31:03,860
you needed it but this is this technique

00:31:02,240 --> 00:31:05,630
is called lazy loading the idea of

00:31:03,860 --> 00:31:07,790
instead of using something right up

00:31:05,630 --> 00:31:10,340
front you just require it on demand when

00:31:07,790 --> 00:31:15,650
you need it and that helped us in some

00:31:10,340 --> 00:31:18,950
case and you might consider it just

00:31:15,650 --> 00:31:23,450
throwing it out there finding your slow

00:31:18,950 --> 00:31:26,390
test first we'll look at doing that with

00:31:23,450 --> 00:31:28,370
prove if you're not familiar with proof

00:31:26,390 --> 00:31:31,760
state system i recommend checking it out

00:31:28,370 --> 00:31:34,460
it can save the state of your test suite

00:31:31,760 --> 00:31:38,420
and the file and do things with it so

00:31:34,460 --> 00:31:41,660
the first example i show is saving the

00:31:38,420 --> 00:31:43,730
state and the next one here is you know

00:31:41,660 --> 00:31:46,480
it's rerunning the files that you just

00:31:43,730 --> 00:31:49,070
ran but with the slowest test first and

00:31:46,480 --> 00:31:52,160
that's one way you can sort of see

00:31:49,070 --> 00:31:53,750
what's slow in your suite and if you

00:31:52,160 --> 00:31:55,520
look at the dot proof file it contains

00:31:53,750 --> 00:31:57,890
it has that raw timing data in there

00:31:55,520 --> 00:31:59,750
this isn't my preferred way to find slow

00:31:57,890 --> 00:32:02,260
tests but we all a lot of people already

00:31:59,750 --> 00:32:04,700
have proved installed and feed you yes

00:32:02,260 --> 00:32:08,990
the testers distribution for some

00:32:04,700 --> 00:32:10,570
samples analyzers for desktop yep Rachel

00:32:08,990 --> 00:32:13,299
analyzes for you

00:32:10,570 --> 00:32:15,100
what was the model name in chess furnace

00:32:13,299 --> 00:32:17,320
test harness it distribution in the

00:32:15,100 --> 00:32:19,509
examples director told Emmaline tennis

00:32:17,320 --> 00:32:22,090
court s coke appeal it will analyze that

00:32:19,509 --> 00:32:24,159
data for you great so it's test harness

00:32:22,090 --> 00:32:27,130
any examples directory there's an

00:32:24,159 --> 00:32:28,690
analyze a file that will analyze that

00:32:27,130 --> 00:32:32,500
and dump out test data so that was very

00:32:28,690 --> 00:32:35,380
helpful we use Jenkins which has also

00:32:32,500 --> 00:32:37,600
been mentioned here it's a continuous

00:32:35,380 --> 00:32:41,139
integration server and it can also help

00:32:37,600 --> 00:32:45,940
you find your slow tests we get our

00:32:41,139 --> 00:32:50,830
tests a tap output can convert it to the

00:32:45,940 --> 00:32:53,169
j unit output and this is a slide of

00:32:50,830 --> 00:32:55,409
example of that kind of output and it

00:32:53,169 --> 00:32:57,909
has all these columns are sortable and

00:32:55,409 --> 00:33:00,429
there's a duration column so here we are

00:32:57,909 --> 00:33:03,370
sorted all of our tests by which one is

00:33:00,429 --> 00:33:07,450
is slowest and this is a great place to

00:33:03,370 --> 00:33:08,740
start to look to see to get you find

00:33:07,450 --> 00:33:11,169
your slowest test and make those run

00:33:08,740 --> 00:33:13,210
faster and this report helps you do that

00:33:11,169 --> 00:33:15,159
it's you know I wouldn't necessarily

00:33:13,210 --> 00:33:16,840
install it just to get you find your

00:33:15,159 --> 00:33:18,730
slowest test but if you're already using

00:33:16,840 --> 00:33:23,259
it make sure you you're looking for this

00:33:18,730 --> 00:33:25,360
information because it's there it also

00:33:23,259 --> 00:33:26,860
graphs your test suite run times and

00:33:25,360 --> 00:33:29,500
this is an example of that kind of graph

00:33:26,860 --> 00:33:30,759
and it shows that both in graph form and

00:33:29,500 --> 00:33:33,460
then allows you to drill down to

00:33:30,759 --> 00:33:35,500
specific runs how long each each run

00:33:33,460 --> 00:33:37,029
took and that could help you find if you

00:33:35,500 --> 00:33:39,940
made a particular improvement they got

00:33:37,029 --> 00:33:41,950
it down a lot or if you made a mistake

00:33:39,940 --> 00:33:43,779
of some sort something happened it

00:33:41,950 --> 00:33:48,759
started to go a lot worse you could find

00:33:43,779 --> 00:33:53,019
it there let's see other process speed

00:33:48,759 --> 00:33:55,419
ups you can organize your tests based on

00:33:53,019 --> 00:33:57,279
how fast or slow they run this is

00:33:55,419 --> 00:33:59,080
basically using a directory named

00:33:57,279 --> 00:34:01,629
structure or a naming structure with

00:33:59,080 --> 00:34:03,460
prefixes or suffixes to help you

00:34:01,629 --> 00:34:06,610
identify all your tests and what kind of

00:34:03,460 --> 00:34:10,480
tests they are and we already talked

00:34:06,610 --> 00:34:13,389
about standard naming conventions you

00:34:10,480 --> 00:34:16,359
could also say use Jenkins or a tool

00:34:13,389 --> 00:34:18,579
like that to organize your test into

00:34:16,359 --> 00:34:21,040
smaller suites so you might run the unit

00:34:18,579 --> 00:34:23,230
test first because they

00:34:21,040 --> 00:34:25,810
our fastest and then maybe if they fail

00:34:23,230 --> 00:34:27,550
you don't run the rest or you already

00:34:25,810 --> 00:34:29,350
get some feedback sooner because that's

00:34:27,550 --> 00:34:31,060
like a test suite and it stopped and

00:34:29,350 --> 00:34:32,410
finishings giving you a result so you

00:34:31,060 --> 00:34:34,900
could start fixing things even before

00:34:32,410 --> 00:34:36,850
the slower test run you could chain your

00:34:34,900 --> 00:34:39,280
your tests together so you get some

00:34:36,850 --> 00:34:40,630
milestone reports before the rapport to

00:34:39,280 --> 00:34:45,460
the end and that's another way you can

00:34:40,630 --> 00:34:48,850
get feedback faster don't run slow test

00:34:45,460 --> 00:34:51,010
is frequently I mentioned this option

00:34:48,850 --> 00:34:53,230
earlier you maybe there's some options

00:34:51,010 --> 00:34:54,760
instead of running things every time you

00:34:53,230 --> 00:34:56,260
push you could run some slow test

00:34:54,760 --> 00:34:58,300
overnight once and maybe that's

00:34:56,260 --> 00:35:00,640
acceptable enough for your process

00:34:58,300 --> 00:35:02,650
there's other ways just consider that

00:35:00,640 --> 00:35:04,780
idea of how you might find your slow

00:35:02,650 --> 00:35:06,250
test and then maybe this maybe maybe

00:35:04,780 --> 00:35:08,470
some of them can be run less frequently

00:35:06,250 --> 00:35:12,370
if they can't be too sort of inherently

00:35:08,470 --> 00:35:13,960
slow and I just got ahead of myself I

00:35:12,370 --> 00:35:16,330
mention the tip of using you can do

00:35:13,960 --> 00:35:18,400
continuous integration server to break

00:35:16,330 --> 00:35:20,710
up your test into smaller jobs if you're

00:35:18,400 --> 00:35:23,860
using Jenkins it has this post build

00:35:20,710 --> 00:35:27,250
action build other projects and that

00:35:23,860 --> 00:35:28,810
allows you to say in Jenkins language

00:35:27,250 --> 00:35:30,970
when this project is done build this

00:35:28,810 --> 00:35:32,710
next project and that allows you to get

00:35:30,970 --> 00:35:37,660
these intermediate reports before the

00:35:32,710 --> 00:35:40,390
end remember the test or code is

00:35:37,660 --> 00:35:42,250
something I sort of I get myself in a

00:35:40,390 --> 00:35:44,290
different mental state like oh I'm test

00:35:42,250 --> 00:35:47,680
test after think about it differently

00:35:44,290 --> 00:35:49,240
different solutions but all the things

00:35:47,680 --> 00:35:51,760
you would do to make code faster you can

00:35:49,240 --> 00:35:53,230
make tests faster and I I forget that

00:35:51,760 --> 00:35:55,000
sometimes so I thought it was worth

00:35:53,230 --> 00:35:57,760
mentioning if you're using a database

00:35:55,000 --> 00:35:59,560
and the database is persistent and make

00:35:57,760 --> 00:36:02,500
sure the database is well maintained

00:35:59,560 --> 00:36:05,050
taken care of and just use all the other

00:36:02,500 --> 00:36:08,560
tools you would use to improve your code

00:36:05,050 --> 00:36:11,980
speed encapsulate repeated code and make

00:36:08,560 --> 00:36:13,210
it faster don't do more than you need to

00:36:11,980 --> 00:36:17,500
I talked about that with the login

00:36:13,210 --> 00:36:19,010
function using smaller data sets that's

00:36:17,500 --> 00:36:29,240
all

00:36:19,010 --> 00:36:34,250
other questions this is suspecting

00:36:29,240 --> 00:36:38,460
Davidson student didn't mention that you

00:36:34,250 --> 00:36:42,060
knew your mom / circle test they were

00:36:38,460 --> 00:36:45,390
running with no loss of coverage and you

00:36:42,060 --> 00:36:49,190
discovered any insights in how we used

00:36:45,390 --> 00:36:51,870
to del coverage in large test suite that

00:36:49,190 --> 00:36:54,900
affected how you overall structure of

00:36:51,870 --> 00:37:00,000
your test Suites no I have not used the

00:36:54,900 --> 00:37:02,700
vel cover I assist with using like logic

00:37:00,000 --> 00:37:03,960
like I knew I didn't log I needed I

00:37:02,700 --> 00:37:14,370
didn't I know I didn't need to do the

00:37:03,960 --> 00:37:15,960
login sequence a hundred times yes you

00:37:14,370 --> 00:37:17,880
can unit test up and get like

00:37:15,960 --> 00:37:19,320
ninety-five percent test coverage but it

00:37:17,880 --> 00:37:22,890
turns out a lot of the code recovering

00:37:19,320 --> 00:37:25,470
is dead code and or it could be dead

00:37:22,890 --> 00:37:27,810
code so if you have say some of your

00:37:25,470 --> 00:37:29,690
test and an API directory everything

00:37:27,810 --> 00:37:32,070
that's publicly accessible for an API

00:37:29,690 --> 00:37:33,960
call record should be accessible to the

00:37:32,070 --> 00:37:36,630
API so if you just I'm devel cover it's

00:37:33,960 --> 00:37:38,160
that you don't have an accidental case

00:37:36,630 --> 00:37:41,160
where you're generating take both

00:37:38,160 --> 00:37:42,570
coverage for code for XP so that's part

00:37:41,160 --> 00:37:46,500
of how i like to structure my tests

00:37:42,570 --> 00:37:48,900
right yeah with my selenium and

00:37:46,500 --> 00:37:51,630
mechanized test I would not duplicate

00:37:48,900 --> 00:37:53,760
there but I do like having unit tests

00:37:51,630 --> 00:37:57,030
and I don't mind if my functional tests

00:37:53,760 --> 00:38:00,000
on my unit tests duplicate some what

00:37:57,030 --> 00:38:06,870
Jane is funny way easy for chow

00:38:00,000 --> 00:38:09,300
ah I don't think I'm I'm doing the

00:38:06,870 --> 00:38:11,640
inverse instead of using a tap plugin

00:38:09,300 --> 00:38:13,890
i'm generating j unit and sending it j

00:38:11,640 --> 00:38:17,580
unit and it's not beautiful and perfect

00:38:13,890 --> 00:38:21,210
either but there's a couple tap today

00:38:17,580 --> 00:38:27,810
unit converter that are out there and

00:38:21,210 --> 00:38:30,990
the white shirt database tables do you

00:38:27,810 --> 00:38:33,930
find that works i guess better faster

00:38:30,990 --> 00:38:36,300
nikolina versus doing transactions with

00:38:33,930 --> 00:38:38,370
walking so they're basically you know I

00:38:36,300 --> 00:38:40,440
imagine if you have tests are doing

00:38:38,370 --> 00:38:43,860
similar operations we're touching tables

00:38:40,440 --> 00:38:46,080
is is it faster to do the mass because

00:38:43,860 --> 00:38:50,670
you potentially massive book a lot of

00:38:46,080 --> 00:38:52,620
tables vs transaction orders ah yeah I

00:38:50,670 --> 00:38:54,360
have not done much with the transaction

00:38:52,620 --> 00:38:58,110
and roll back but I have learned that

00:38:54,360 --> 00:39:00,030
deletes are slow and one thing we do

00:38:58,110 --> 00:39:02,220
that I didn't get into here is to make

00:39:00,030 --> 00:39:04,830
our test faster we actually don't delete

00:39:02,220 --> 00:39:08,280
our test right away we use a Jenkins job

00:39:04,830 --> 00:39:11,490
called delete test data that runs later

00:39:08,280 --> 00:39:13,050
and so inserts are fast so when we need

00:39:11,490 --> 00:39:14,850
when we would insert something instead

00:39:13,050 --> 00:39:17,760
we insert a row into a table which says

00:39:14,850 --> 00:39:19,860
clean up this ID on this table later and

00:39:17,760 --> 00:39:22,500
that's again get some my results faster

00:39:19,860 --> 00:39:24,210
and then and then the cleanup job runs

00:39:22,500 --> 00:39:25,950
later it does the slow deletion later I

00:39:24,210 --> 00:39:28,140
think you run into the same problem with

00:39:25,950 --> 00:39:29,850
transactions that's kind of what would

00:39:28,140 --> 00:39:35,330
be happening in the in the rollback days

00:39:29,850 --> 00:39:35,330
but try right here

00:39:35,410 --> 00:39:41,980
is a lot of our unit tests call other

00:39:38,670 --> 00:39:45,970
modules are good things leaf striking to

00:39:41,980 --> 00:39:48,369
go cover to analyze overall as a set of

00:39:45,970 --> 00:39:51,819
unit tests what's covered what's not and

00:39:48,369 --> 00:39:53,589
we found it literally so slow that it is

00:39:51,819 --> 00:39:55,599
just not usable you would not be it

00:39:53,589 --> 00:39:58,270
would take whereas there overnight test

00:39:55,599 --> 00:40:00,099
we might take 45 minutes or an hour it

00:39:58,270 --> 00:40:02,920
would take six or seven hours to run

00:40:00,099 --> 00:40:05,079
sudo remember is great if you're working

00:40:02,920 --> 00:40:06,510
with small set of modules but it's awful

00:40:05,079 --> 00:40:10,270
for performance if you're working for

00:40:06,510 --> 00:40:12,700
yeah yeah he's saying that developer is

00:40:10,270 --> 00:40:14,440
slow and we've had the same experience

00:40:12,700 --> 00:40:39,280
and run it infrequently for the same

00:40:14,440 --> 00:40:45,240
reason specific simple like database

00:40:39,280 --> 00:40:45,240
that Woods always-on connection

00:40:52,589 --> 00:40:56,799
so you're saying you sequel light

00:40:54,730 --> 00:41:04,109
instead of say postgres for my sequel to

00:40:56,799 --> 00:41:04,109
speed things up Oracle okay green shirt

00:41:08,730 --> 00:41:18,910
parallel number one it's huge that was

00:41:12,609 --> 00:41:20,680
the biggest thing and yeah I think we

00:41:18,910 --> 00:41:23,349
actually because we we have a persistent

00:41:20,680 --> 00:41:24,549
database it also just gotten slow and we

00:41:23,349 --> 00:41:28,420
cleaned it up and that made a big

00:41:24,549 --> 00:41:29,829
difference but also something like the

00:41:28,420 --> 00:41:31,720
login thing which we're doing all the

00:41:29,829 --> 00:41:34,720
time anything you're doing if you've

00:41:31,720 --> 00:41:38,259
made have a systemic problem otherwise I

00:41:34,720 --> 00:41:40,480
head to the list of the slowest test

00:41:38,259 --> 00:41:42,309
it's probably a lot of your slowness is

00:41:40,480 --> 00:41:45,690
like 8020 rule it's probably just a few

00:41:42,309 --> 00:41:45,690
tests that are really contributing a lot

00:41:48,690 --> 00:41:53,109
yes it has what it calls build slaves

00:41:51,250 --> 00:41:55,269
which can be on the same server or on

00:41:53,109 --> 00:41:58,269
remote servers and you can also give it

00:41:55,269 --> 00:42:12,059
a maximum number of build slaves that it

00:41:58,269 --> 00:42:12,059
can do and yeah the fourth proof right

00:42:14,250 --> 00:42:21,519
yeah I was I'm not certain but I I was

00:42:19,660 --> 00:42:24,130
discussing it on Stack Overflow the

00:42:21,519 --> 00:42:26,470
question title was like how to run some

00:42:24,130 --> 00:42:28,119
tests in parallel but not others I think

00:42:26,470 --> 00:42:29,769
it wasn't producing the right result of

00:42:28,119 --> 00:42:31,359
the end like it just got to the end of

00:42:29,769 --> 00:42:35,140
the tap and stopped and didn't produce a

00:42:31,359 --> 00:42:36,640
summary and I learned from dealing with

00:42:35,140 --> 00:42:38,410
that rule system that had been

00:42:36,640 --> 00:42:40,990
documented so it was not well you people

00:42:38,410 --> 00:42:43,180
didn't know it existed so there wasn't

00:42:40,990 --> 00:42:45,759
really a lot of wisdom that I could find

00:42:43,180 --> 00:42:48,839
about how to deal with it but it might

00:42:45,759 --> 00:42:48,839
be well be fixable so

00:42:52,670 --> 00:42:57,630
yeah I did find the Pearl Corps was

00:42:55,680 --> 00:42:58,650
using it but it might have been the

00:42:57,630 --> 00:43:01,320
particular it was a particular

00:42:58,650 --> 00:43:02,730
combination of I wanted to say run all

00:43:01,320 --> 00:43:05,190
these in parallel except these 10 things

00:43:02,730 --> 00:43:07,110
at the end run in cereal and if you run

00:43:05,190 --> 00:43:18,810
the rules in a different way they work

00:43:07,110 --> 00:43:20,880
but not the way I needed them how to

00:43:18,810 --> 00:43:23,010
deal with situations we kind of either

00:43:20,880 --> 00:43:24,600
variables that are part of the state of

00:43:23,010 --> 00:43:27,030
the application but they're on the

00:43:24,600 --> 00:43:29,340
browser side or mini and what you don't

00:43:27,030 --> 00:43:30,869
want you don't want certain transactions

00:43:29,340 --> 00:43:32,940
to her more than one sec maybe it's a

00:43:30,869 --> 00:43:34,500
credit card form or something hmm that

00:43:32,940 --> 00:43:37,140
sensitive that changes the state of the

00:43:34,500 --> 00:43:39,780
system so if you've read you cloning use

00:43:37,140 --> 00:43:43,470
that same thing three or four times the

00:43:39,780 --> 00:43:45,090
first time using you expired yeah it

00:43:43,470 --> 00:43:47,450
wouldn't it wouldn't solve all those

00:43:45,090 --> 00:43:49,890
kinds of problems he was asking about

00:43:47,450 --> 00:43:51,450
the cloning trick with mechanized and

00:43:49,890 --> 00:43:53,160
how it worked at the application state

00:43:51,450 --> 00:43:54,960
is changing too it's just some cases

00:43:53,160 --> 00:43:58,050
that wouldn't work it only can work if

00:43:54,960 --> 00:44:00,600
you know your want to go back to a state

00:43:58,050 --> 00:44:01,859
that you already have and so you might

00:44:00,600 --> 00:44:07,260
need to use some other trick they're

00:44:01,859 --> 00:44:09,740
just deal with that one being slow thank

00:44:07,260 --> 00:44:09,740
you all for coming

00:44:14,200 --> 00:44:21,220
if you need any help moving your couches

00:44:17,980 --> 00:44:21,220

YouTube URL: https://www.youtube.com/watch?v=sDUnWGuJn5A


