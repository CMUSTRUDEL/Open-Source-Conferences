Title: Nick Patch - Unicode Best Practices
Publication date: 2013-08-20
Playlist: YAPC::NA 2013
Description: 
	
Captions: 
	00:00:10,099 --> 00:00:18,480
okay let's get started so I'm Nick patch

00:00:14,580 --> 00:00:22,920
and i work at shutterstock in New York

00:00:18,480 --> 00:00:25,560
on the international team I'm and we are

00:00:22,920 --> 00:00:32,130
hiring will rat the job fair right now I

00:00:25,560 --> 00:00:36,120
in New York San Francisco and Austin as

00:00:32,130 --> 00:00:38,100
well now as well as some some remote

00:00:36,120 --> 00:00:42,030
opportunities but more more in our

00:00:38,100 --> 00:00:45,510
offices anyway I on the international

00:00:42,030 --> 00:00:48,719
team what we do is work to

00:00:45,510 --> 00:00:51,750
internationalize and localize our web

00:00:48,719 --> 00:00:55,250
applications supporting many different

00:00:51,750 --> 00:00:58,530
foreign languages foreign currencies I

00:00:55,250 --> 00:01:02,670
cultures with I you know culturally

00:00:58,530 --> 00:01:05,780
relevant content and formats dates times

00:01:02,670 --> 00:01:08,400
so on and so forth I and through this I

00:01:05,780 --> 00:01:13,470
have a lot of experience working with

00:01:08,400 --> 00:01:16,590
Unicode now this talk is titled Unicode

00:01:13,470 --> 00:01:20,970
best practices but best practices that's

00:01:16,590 --> 00:01:24,630
very much a loaded term I'm I don't

00:01:20,970 --> 00:01:27,900
claim to have all the best practices but

00:01:24,630 --> 00:01:30,900
you know pro best practices came out a

00:01:27,900 --> 00:01:33,270
half decade or so gum and it's an

00:01:30,900 --> 00:01:35,369
excellent book I lots of the best

00:01:33,270 --> 00:01:39,030
practices have stood the test of time

00:01:35,369 --> 00:01:40,799
some haven't I one thing that's

00:01:39,030 --> 00:01:45,329
noticeably missing from it though is

00:01:40,799 --> 00:01:48,090
almost any mention of Unicode or utf-8

00:01:45,329 --> 00:01:53,130
so I'm hoping to fill in sort of a

00:01:48,090 --> 00:01:55,590
knowledge gap here I last year I gave a

00:01:53,130 --> 00:01:58,079
talk on fundamental Unicode and that was

00:01:55,590 --> 00:02:01,259
very much sir there beginner's guide to

00:01:58,079 --> 00:02:04,200
Unicode and utf-8 this really isn't

00:02:01,259 --> 00:02:08,459
going to get into the fundamentals of it

00:02:04,200 --> 00:02:10,720
I but even if you don't know that all of

00:02:08,459 --> 00:02:12,880
a lot of tips on what you can do

00:02:10,720 --> 00:02:15,280
in real-world solutions in your Sipan

00:02:12,880 --> 00:02:21,940
modules and web applications web

00:02:15,280 --> 00:02:24,310
services and so forth so you'll see my

00:02:21,940 --> 00:02:26,760
bias in these best practices with the

00:02:24,310 --> 00:02:30,520
very first one and that is used pearl

00:02:26,760 --> 00:02:34,420
pearl has excellent unicode support I

00:02:30,520 --> 00:02:36,670
and it has since 58 I i have many

00:02:34,420 --> 00:02:39,850
environments where i have to use 58 but

00:02:36,670 --> 00:02:44,560
that's okay well i'd like to be using I

00:02:39,850 --> 00:02:47,440
say 518 everywhere but profiling it has

00:02:44,560 --> 00:02:51,520
a lot better unicode support than many

00:02:47,440 --> 00:02:55,380
programming languages out there and you

00:02:51,520 --> 00:02:58,480
know the python folks don't commonly say

00:02:55,380 --> 00:03:01,930
many good things about pearl but i was

00:02:58,480 --> 00:03:04,840
surprised to see at app icon 2013 this

00:03:01,930 --> 00:03:08,280
is one of the core contributors to see

00:03:04,840 --> 00:03:11,350
python and pie pie implementations I

00:03:08,280 --> 00:03:12,880
giving a talk on the guts of Unicode in

00:03:11,350 --> 00:03:14,920
Python ease as perl has some of the best

00:03:12,880 --> 00:03:17,290
unicode support today especially with

00:03:14,920 --> 00:03:19,239
respect to regular expressions so we're

00:03:17,290 --> 00:03:24,400
going to go over regular expressions

00:03:19,239 --> 00:03:25,989
which I pearl is excellent at parsing

00:03:24,400 --> 00:03:28,150
unicode data then we'll go over some

00:03:25,989 --> 00:03:34,590
other aspects of working with you in a

00:03:28,150 --> 00:03:38,709
code so first off i mentioned i 58 is

00:03:34,590 --> 00:03:40,480
great for working with unicode I'm yes I

00:03:38,709 --> 00:03:44,769
prefer to work with more recent versions

00:03:40,480 --> 00:03:46,959
but in 58 I will see that in the

00:03:44,769 --> 00:03:50,200
majority of the examples throughout here

00:03:46,959 --> 00:03:52,989
we're using 58 code only word explicitly

00:03:50,200 --> 00:03:54,880
states a newer version is it needed for

00:03:52,989 --> 00:03:57,459
that version I one of the big problems

00:03:54,880 --> 00:04:00,190
with 58 though is what some people know

00:03:57,459 --> 00:04:04,570
of as the Unicode bug where you have a

00:04:00,190 --> 00:04:07,390
string and it could be it could have

00:04:04,570 --> 00:04:09,400
unicode semantics or not and it's hard

00:04:07,390 --> 00:04:12,610
to tell sometimes so that's why i

00:04:09,400 --> 00:04:15,690
recommend that if you have an option you

00:04:12,610 --> 00:04:19,709
at least use 512 because 512 largely

00:04:15,690 --> 00:04:22,199
fixes the unicode bug and then 514

00:04:19,709 --> 00:04:23,550
literates it I so if you if you have an

00:04:22,199 --> 00:04:27,419
option in the matter just use the most

00:04:23,550 --> 00:04:31,139
recent version of Perl possible and life

00:04:27,419 --> 00:04:34,380
will be easier so let's go through the

00:04:31,139 --> 00:04:37,919
steps of say you've got a perl script a

00:04:34,380 --> 00:04:39,479
perl module I you know a web request

00:04:37,919 --> 00:04:42,090
where you're working with dancer or

00:04:39,479 --> 00:04:47,099
whatever your web framework is I what

00:04:42,090 --> 00:04:50,639
the steps of I working with encoded UTF

00:04:47,099 --> 00:04:52,830
data is versus I pearl Unicode strings

00:04:50,639 --> 00:04:55,740
or character strings so first off you

00:04:52,830 --> 00:04:57,990
receive your utf-8 encoded input or

00:04:55,740 --> 00:05:01,289
really any character encoding it's just

00:04:57,990 --> 00:05:03,120
on the web well utf-8 is the most

00:05:01,289 --> 00:05:04,880
popular character encoding so that's

00:05:03,120 --> 00:05:07,979
what will receive most of the time and

00:05:04,880 --> 00:05:11,009
generally if you are working with data

00:05:07,979 --> 00:05:12,210
interchange I you should be using utf-8

00:05:11,009 --> 00:05:13,409
by default unless you've got a better

00:05:12,210 --> 00:05:15,180
reason to you something else because

00:05:13,409 --> 00:05:19,280
there are legitimate reasons so anyway

00:05:15,180 --> 00:05:23,550
we receive our utf-8 encoded content and

00:05:19,280 --> 00:05:26,460
decode it at the very beginning so that

00:05:23,550 --> 00:05:28,560
we consistently have character strings

00:05:26,460 --> 00:05:31,080
that we're working with throughout our

00:05:28,560 --> 00:05:34,009
code base then hack hack hack work on

00:05:31,080 --> 00:05:37,949
your character strings at the very end

00:05:34,009 --> 00:05:41,520
encode and you've got the utf-8 encoded

00:05:37,949 --> 00:05:43,949
output so you want to ND code and encode

00:05:41,520 --> 00:05:45,990
at the edges of your application so

00:05:43,949 --> 00:05:48,509
everything you work with is character

00:05:45,990 --> 00:05:51,300
strings I that's this is the biggest

00:05:48,509 --> 00:05:53,099
problem I see with perl code and

00:05:51,300 --> 00:05:56,009
especially legacy pro code that makes

00:05:53,099 --> 00:05:59,039
Unicode and utf-8 hard to work with is

00:05:56,009 --> 00:06:02,820
that commonly the code is all built

00:05:59,039 --> 00:06:06,050
around working with I byte strings in

00:06:02,820 --> 00:06:09,020
utf-8 encoded content or a mix of

00:06:06,050 --> 00:06:12,840
character strings and byte strings and

00:06:09,020 --> 00:06:14,430
if you start from this pattern in the

00:06:12,840 --> 00:06:22,469
beginning it just makes life so much

00:06:14,430 --> 00:06:25,830
easier so if you start your source code

00:06:22,469 --> 00:06:27,419
you're pro quo with I use utf-8 that's

00:06:25,830 --> 00:06:29,849
another thing that I recommend you to

00:06:27,419 --> 00:06:30,860
make life easier I and there's some

00:06:29,849 --> 00:06:34,430
confusion over

00:06:30,860 --> 00:06:38,990
what this does all it does is it says my

00:06:34,430 --> 00:06:41,449
source code is encoded in utf-8 it

00:06:38,990 --> 00:06:43,849
doesn't matter if you have non-ascii

00:06:41,449 --> 00:06:46,879
characters or not because well ascii is

00:06:43,849 --> 00:06:54,139
a subset of utf-8 so yes it's valid

00:06:46,879 --> 00:06:58,370
utf-8 I its end I commonly use non-ascii

00:06:54,139 --> 00:07:00,530
characters in my source code I I don't

00:06:58,370 --> 00:07:02,719
want to have to just start adding use

00:07:00,530 --> 00:07:04,699
utf-8 at the top when I introduce one

00:07:02,719 --> 00:07:08,479
instead I want all of my source code to

00:07:04,699 --> 00:07:15,139
be consistently interpreted as utf-8 not

00:07:08,479 --> 00:07:17,990
Latin one and in addition to you know

00:07:15,139 --> 00:07:22,430
pearl reading it as utf-8 it allows you

00:07:17,990 --> 00:07:26,210
to not have to decode your literal

00:07:22,430 --> 00:07:28,879
strings in your source I so if you

00:07:26,210 --> 00:07:31,610
didn't do this and you wanted to decode

00:07:28,879 --> 00:07:35,930
on input well you would have to actually

00:07:31,610 --> 00:07:37,250
have the decode utf-8 and your literal

00:07:35,930 --> 00:07:40,729
string in your source code so this

00:07:37,250 --> 00:07:43,219
avoids that and it allows you to use

00:07:40,729 --> 00:07:46,789
non-ascii characters in your identifiers

00:07:43,219 --> 00:07:52,310
if that's what you wish to do i as well

00:07:46,789 --> 00:07:55,520
as your regular expressions and I you

00:07:52,310 --> 00:07:57,229
might be a shop that locally does

00:07:55,520 --> 00:07:59,539
comments and identifiers in another

00:07:57,229 --> 00:08:01,550
language or you might just want to do

00:07:59,539 --> 00:08:04,719
some you know funny convenience things

00:08:01,550 --> 00:08:07,219
like using the the letter pi for your

00:08:04,719 --> 00:08:10,009
variable name but anyway I don't do that

00:08:07,219 --> 00:08:12,979
I just consistently use utf-8 because I

00:08:10,009 --> 00:08:15,949
rampantly use unicode characters in my

00:08:12,979 --> 00:08:18,500
regular expressions and strings I here

00:08:15,949 --> 00:08:20,719
by the way is my favorite regular

00:08:18,500 --> 00:08:23,120
expression so if you're going to use

00:08:20,719 --> 00:08:27,740
this say use utf-8 at the top of your

00:08:23,120 --> 00:08:30,229
file also I have to do a shout-out to

00:08:27,740 --> 00:08:31,310
bicycle perl mongers if you haven't

00:08:30,229 --> 00:08:36,400
heard about it joy

00:08:31,310 --> 00:08:36,400
a bicycle p.m. we put an IRC channel

00:08:36,490 --> 00:08:43,220
here's a more real world example I we

00:08:40,430 --> 00:08:45,170
have a regular expression with the

00:08:43,220 --> 00:08:48,200
Arabic script this is actually Persian

00:08:45,170 --> 00:08:54,800
and it's part of a language stemmer that

00:08:48,200 --> 00:08:56,900
I wrote and put on CPM and one thing

00:08:54,800 --> 00:08:59,450
about working with regular expressions

00:08:56,900 --> 00:09:01,310
and this isn't even related to unicode

00:08:59,450 --> 00:09:03,920
but when you start getting larger rag

00:09:01,310 --> 00:09:05,570
axes it's very important remember that

00:09:03,920 --> 00:09:08,570
regular expressions let's say that's a

00:09:05,570 --> 00:09:11,420
programming language itself and I I

00:09:08,570 --> 00:09:13,220
recommend as well as Damian and pro best

00:09:11,420 --> 00:09:17,240
practices treating it like a programming

00:09:13,220 --> 00:09:18,770
language using the ex modifier so that

00:09:17,240 --> 00:09:20,420
you can have arbitrary white space you

00:09:18,770 --> 00:09:23,830
can nicely laid things out and you can

00:09:20,420 --> 00:09:27,170
put comments I'm because in a lot of the

00:09:23,830 --> 00:09:29,690
Mets parsing that I do well it quickly

00:09:27,170 --> 00:09:31,640
becomes unreadable if there's no white

00:09:29,690 --> 00:09:35,450
space and you'll also see with a lot of

00:09:31,640 --> 00:09:38,030
the Unicode related I Rex features it

00:09:35,450 --> 00:09:40,070
will become very unreadable very fast

00:09:38,030 --> 00:09:42,080
without treating it like the proper

00:09:40,070 --> 00:09:43,340
programming language that it is so

00:09:42,080 --> 00:09:48,800
anyway these are just a couple examples

00:09:43,340 --> 00:09:51,080
of using literal utf-8 characters in a

00:09:48,800 --> 00:09:53,180
red x and i'm a big proponent of

00:09:51,080 --> 00:09:55,820
actually doing that instead of escape

00:09:53,180 --> 00:09:58,670
sequences I this is so much more

00:09:55,820 --> 00:10:01,460
readable than having to go and look up

00:09:58,670 --> 00:10:10,520
escape sequences throughout my strings

00:10:01,460 --> 00:10:13,310
and reg exes I'm then say in your pod

00:10:10,520 --> 00:10:16,310
well the use utf-8 that's not going to

00:10:13,310 --> 00:10:19,670
cover that you need to use encoding

00:10:16,310 --> 00:10:21,860
utf-8 at the top of your pod file and

00:10:19,670 --> 00:10:24,860
that makes it just so you can use any

00:10:21,860 --> 00:10:28,490
characters like say for example I back

00:10:24,860 --> 00:10:33,500
code came from this module and you can

00:10:28,490 --> 00:10:35,270
see there there a well I i use encoding

00:10:33,500 --> 00:10:38,360
utf-8 at the top of all of my pod

00:10:35,270 --> 00:10:40,190
because I so commonly use non-ascii

00:10:38,360 --> 00:10:41,600
characters in it and I just don't want

00:10:40,190 --> 00:10:42,290
to have to think about it later even if

00:10:41,600 --> 00:10:49,459
I'm adding

00:10:42,290 --> 00:10:53,690
whew in then for i 0 i well if you want

00:10:49,459 --> 00:10:57,980
your input output including you know

00:10:53,690 --> 00:11:00,459
warnings to standard error all treated

00:10:57,980 --> 00:11:03,680
as utf-8 and character strings

00:11:00,459 --> 00:11:06,139
internally this is a very convenient way

00:11:03,680 --> 00:11:09,699
to do it the open pragma you can set

00:11:06,139 --> 00:11:12,589
here that your pearl io layer is

00:11:09,699 --> 00:11:16,250
encoding set specifying the encoding as

00:11:12,589 --> 00:11:18,220
utf-8 and let's ignore this part here

00:11:16,250 --> 00:11:21,079
for a second let's ignore the standard I

00:11:18,220 --> 00:11:25,000
so what we're doing is we're saying all

00:11:21,079 --> 00:11:30,639
of my file handles that i explicitly

00:11:25,000 --> 00:11:34,519
open i will be decoded on input from

00:11:30,639 --> 00:11:37,819
utf-8 to character strings and encoded

00:11:34,519 --> 00:11:40,670
on output now if we add this standard at

00:11:37,819 --> 00:11:43,399
the end that will also cover standard in

00:11:40,670 --> 00:11:45,529
standard out and standard error so this

00:11:43,399 --> 00:11:48,230
is something that I like to use all the

00:11:45,529 --> 00:11:51,260
time because it just makes for less code

00:11:48,230 --> 00:11:53,269
i explicitly encoding or decoding and

00:11:51,260 --> 00:11:55,910
does what i want and in addition to

00:11:53,269 --> 00:11:59,019
using utf-8 so here let's take a look at

00:11:55,910 --> 00:12:02,959
it I using both of those this is a

00:11:59,019 --> 00:12:06,110
production code at shutterstock we open

00:12:02,959 --> 00:12:08,839
sourced it in the linguist mu9 bundle of

00:12:06,110 --> 00:12:11,269
language stammers based on algorithms

00:12:08,839 --> 00:12:14,389
from stemming algorithms from the

00:12:11,269 --> 00:12:15,860
University of Nationale because there

00:12:14,389 --> 00:12:18,350
are a lot of languages we work with that

00:12:15,860 --> 00:12:22,279
shutterstock that don't have pearl

00:12:18,350 --> 00:12:24,110
stammers I already on Sipan the snowball

00:12:22,279 --> 00:12:27,050
suite provides a lot of languages and we

00:12:24,110 --> 00:12:29,319
use that I but when we need to make new

00:12:27,050 --> 00:12:33,290
ones we release them back to see Pam

00:12:29,319 --> 00:12:35,689
anyone here we're using utf-8 so we can

00:12:33,290 --> 00:12:38,509
have our literal characters here and not

00:12:35,689 --> 00:12:43,220
have to do any encoding or decoding then

00:12:38,509 --> 00:12:46,160
I because of the open pragma here I the

00:12:43,220 --> 00:12:48,110
tap output will just work the warnings

00:12:46,160 --> 00:12:52,269
will just work the tap out pit will just

00:12:48,110 --> 00:12:52,269
work and this all works on pro 58

00:12:53,180 --> 00:13:02,060
then there are a lot of modules out

00:12:56,070 --> 00:13:06,779
there that you use I at the to do I ohm

00:13:02,060 --> 00:13:09,029
say you have JSON that came in through a

00:13:06,779 --> 00:13:12,510
WebQuest end you're using either the

00:13:09,029 --> 00:13:16,140
JSON or JSON excess modules to decode it

00:13:12,510 --> 00:13:20,700
well decode JSON will actually take the

00:13:16,140 --> 00:13:23,610
utf-8 encoded JSON and return a pearl

00:13:20,700 --> 00:13:27,200
data structure with containing character

00:13:23,610 --> 00:13:30,959
strings as well as say with a HTTP

00:13:27,200 --> 00:13:34,490
response the response object has a

00:13:30,959 --> 00:13:38,160
decoded content method which returns

00:13:34,490 --> 00:13:41,040
character strings I'm so often times

00:13:38,160 --> 00:13:42,920
you'll be working with frameworks and

00:13:41,040 --> 00:13:46,410
modules that already have convenience

00:13:42,920 --> 00:13:50,820
methods or functions like this but as a

00:13:46,410 --> 00:13:54,830
last resort if the open pragma and the

00:13:50,820 --> 00:13:56,399
utf-8 pragma and whatever framework or

00:13:54,830 --> 00:13:59,130
serialization formats you're using

00:13:56,399 --> 00:14:01,709
doesn't provide what you need or you're

00:13:59,130 --> 00:14:05,670
working with legacy code then explicitly

00:14:01,709 --> 00:14:08,300
decode and encode I by using the encode

00:14:05,670 --> 00:14:11,490
module that's bundled with pearl and

00:14:08,300 --> 00:14:18,029
syntax like this and it will return this

00:14:11,490 --> 00:14:22,200
will return a character string now I

00:14:18,029 --> 00:14:24,750
mentioned that I prefer to avoid escape

00:14:22,200 --> 00:14:26,850
sequences and just use the literal utf-8

00:14:24,750 --> 00:14:29,250
characters there's some cases where you

00:14:26,850 --> 00:14:32,700
really should be using escape sequences

00:14:29,250 --> 00:14:34,650
and I my favorite one to use I'll

00:14:32,700 --> 00:14:37,430
demonstrate in a second but you have to

00:14:34,650 --> 00:14:40,800
use the carronades prog num pragma and

00:14:37,430 --> 00:14:44,339
the full option to it so let's take a

00:14:40,800 --> 00:14:49,079
look at that in use I that allows us to

00:14:44,339 --> 00:14:54,149
use named unicode characters like arabic

00:14:49,079 --> 00:14:55,740
kasra I this is a character that isn't a

00:14:54,149 --> 00:14:57,990
printing character on its own but

00:14:55,740 --> 00:15:00,810
instead modifies the character that it's

00:14:57,990 --> 00:15:03,390
next to and it doesn't have a display

00:15:00,810 --> 00:15:04,750
form that would be useful to us as a

00:15:03,390 --> 00:15:06,580
literal utf-8 care

00:15:04,750 --> 00:15:08,730
so when you're using combining

00:15:06,580 --> 00:15:11,560
characters or control characters or

00:15:08,730 --> 00:15:13,780
non-printing characters I this is the

00:15:11,560 --> 00:15:16,780
method i recommend because you don't

00:15:13,780 --> 00:15:20,080
have to look up any conversions from the

00:15:16,780 --> 00:15:22,120
unicode code point value to the name of

00:15:20,080 --> 00:15:28,450
the character you can just use the name

00:15:22,120 --> 00:15:31,060
up front and if you're using Perl 5 16

00:15:28,450 --> 00:15:35,070
you don't have to specify use care name

00:15:31,060 --> 00:15:35,070
fold because it's already done for you

00:15:37,740 --> 00:15:45,010
so let's take a look at some of these I

00:15:41,140 --> 00:15:46,720
reg ex features that well first off some

00:15:45,010 --> 00:15:49,150
that may be a little confusing to folks

00:15:46,720 --> 00:15:53,350
who are used to working in an ASCII

00:15:49,150 --> 00:15:56,080
world I can this one here well it

00:15:53,350 --> 00:15:57,640
matches digits and I think probably

00:15:56,080 --> 00:16:01,630
unpretty sure everyone in this room has

00:15:57,640 --> 00:16:03,850
has used this you know your ones twos

00:16:01,630 --> 00:16:08,650
and threes but you'd be a little

00:16:03,850 --> 00:16:12,339
surprised at your in bengali 123 and lao

00:16:08,650 --> 00:16:16,780
123 that it also matches I when you're

00:16:12,339 --> 00:16:19,089
in a Unicode context and that may be

00:16:16,780 --> 00:16:21,130
great for some things but it's pretty

00:16:19,089 --> 00:16:23,260
horrible for other things say you want

00:16:21,130 --> 00:16:27,250
to parse out those numbers and do some

00:16:23,260 --> 00:16:30,100
math in pearl or you want to select say

00:16:27,250 --> 00:16:33,190
a cell number I well things are just

00:16:30,100 --> 00:16:37,290
going to blow up on you so if you

00:16:33,190 --> 00:16:41,710
actually do want to be limited to your

00:16:37,290 --> 00:16:45,490
digits 0 through 9 in you know Western

00:16:41,710 --> 00:16:46,930
Arabic syntax well just explicitly do 0

00:16:45,490 --> 00:16:48,130
through 9 now there's more than one way

00:16:46,930 --> 00:16:50,020
to do it but this is just what I do

00:16:48,130 --> 00:16:53,500
because it's so explicit I want 0

00:16:50,020 --> 00:16:57,220
through 9 and that will just match what

00:16:53,500 --> 00:17:00,070
you'd expect in an ASCII context but

00:16:57,220 --> 00:17:02,910
then there's also the word character

00:17:00,070 --> 00:17:06,520
matcher which gets a little crazy here

00:17:02,910 --> 00:17:10,449
it matches your abs and sees one twos

00:17:06,520 --> 00:17:13,049
and threes i underscore as well as your

00:17:10,449 --> 00:17:16,769
alpha beta gamma both

00:17:13,049 --> 00:17:23,399
fo and Arabic we've got some right to

00:17:16,769 --> 00:17:27,919
left action there and so anything that

00:17:23,399 --> 00:17:31,950
unicode considers an alphabetic or

00:17:27,919 --> 00:17:36,389
numeric plus the underscore this will

00:17:31,950 --> 00:17:38,999
match and well yeah you could win by the

00:17:36,389 --> 00:17:42,119
way the word boundary of course uses

00:17:38,999 --> 00:17:44,220
those semantics as well and you could go

00:17:42,119 --> 00:17:46,950
and write something like this if you

00:17:44,220 --> 00:17:49,739
wanted the to actually match the

00:17:46,950 --> 00:17:51,960
traditional ascii sense and that's the

00:17:49,739 --> 00:17:53,309
well it's a little ugly but the one

00:17:51,960 --> 00:17:55,470
thing that i want to bring up is that i

00:17:53,309 --> 00:17:57,570
don't have any time to use this I don't

00:17:55,470 --> 00:18:00,950
I know there's there argues is but I

00:17:57,570 --> 00:18:04,580
don't have any time to use this or this

00:18:00,950 --> 00:18:08,100
because alphanumerics plus underscore I

00:18:04,580 --> 00:18:10,470
whether it's limited to a ski or all of

00:18:08,100 --> 00:18:13,649
Unicode that's something that I just use

00:18:10,470 --> 00:18:16,080
as a convenience matcher on the command

00:18:13,649 --> 00:18:18,149
line when I'm doing one liners but not

00:18:16,080 --> 00:18:20,489
in production code because there's so

00:18:18,149 --> 00:18:23,029
little use for me to be limited to that

00:18:20,489 --> 00:18:28,259
specific set or that larger sati oven

00:18:23,029 --> 00:18:30,779
and by the way I there is a shortcut for

00:18:28,259 --> 00:18:33,299
the you know traditional ascii pearl

00:18:30,779 --> 00:18:35,820
word and and that uses this property

00:18:33,299 --> 00:18:40,259
we're going to take a look at character

00:18:35,820 --> 00:18:42,059
properties soon using p but first i hear

00:18:40,259 --> 00:18:46,309
a few more that are a little different

00:18:42,059 --> 00:18:49,830
in the ascii versus unicode semantics

00:18:46,309 --> 00:18:53,549
this matches white space I'm you know

00:18:49,830 --> 00:18:57,480
your space and new line and tabs and so

00:18:53,549 --> 00:18:59,820
forth and take a look at this amazed at

00:18:57,480 --> 00:19:02,720
all of the additional unicode characters

00:18:59,820 --> 00:19:02,720
that it now matches

00:19:03,780 --> 00:19:09,880
now this is one that you don't really

00:19:08,380 --> 00:19:13,300
have to worry about it's sort of like

00:19:09,880 --> 00:19:15,340
silently upgrading when you when you're

00:19:13,300 --> 00:19:16,840
using Unicode semantics it's timely

00:19:15,340 --> 00:19:18,250
upgrading to something better there's

00:19:16,840 --> 00:19:21,190
hardly any time where you're like oh

00:19:18,250 --> 00:19:24,340
yeah I just wanted the ASCII white space

00:19:21,190 --> 00:19:31,540
I the more white space the better in my

00:19:24,340 --> 00:19:34,960
opinion and I here's one that many folks

00:19:31,540 --> 00:19:38,530
may not have seen I and we know no

00:19:34,960 --> 00:19:44,790
backslash n is for the the new line but

00:19:38,530 --> 00:19:49,740
this is any line ending so it matches I

00:19:44,790 --> 00:19:53,590
LF matches CR you know form feed as well

00:19:49,740 --> 00:19:57,490
as CR LF which interestingly it's

00:19:53,590 --> 00:20:00,400
matching CR LF all as one match it's not

00:19:57,490 --> 00:20:05,640
you know CR and then LF because CR LF

00:20:00,400 --> 00:20:08,590
that's a I essentially a cluster of

00:20:05,640 --> 00:20:11,220
control characters at the end of your

00:20:08,590 --> 00:20:14,320
line and then there's a next line

00:20:11,220 --> 00:20:15,790
vertical tab and so on and so forth well

00:20:14,320 --> 00:20:17,860
it matches all of those this is very

00:20:15,790 --> 00:20:19,300
convenient because I've had a lot of

00:20:17,860 --> 00:20:21,100
situations where after you do a

00:20:19,300 --> 00:20:24,960
character class just like bundling all

00:20:21,100 --> 00:20:24,960
these different potential line endings

00:20:26,010 --> 00:20:33,820
this is the dot this is a I this this

00:20:30,220 --> 00:20:38,800
slide is a experiment in minimalism with

00:20:33,820 --> 00:20:40,300
a 200 point font I good does anyone know

00:20:38,800 --> 00:20:44,310
what the dot does can anyone shout out

00:20:40,300 --> 00:20:44,310
what I would dot matches

00:20:50,680 --> 00:21:05,630
yeah so we got some my I like being

00:20:59,150 --> 00:21:07,810
heckled by Larry wall I'm so the dot I

00:21:05,630 --> 00:21:12,920
got some answers here any character

00:21:07,810 --> 00:21:18,410
anything but new line and technically

00:21:12,920 --> 00:21:23,330
this is any unicode code point except

00:21:18,410 --> 00:21:28,310
for the new line I'm and it's important

00:21:23,330 --> 00:21:31,150
to distinguish a code point from what

00:21:28,310 --> 00:21:35,390
the user may perceive as a character

00:21:31,150 --> 00:21:38,120
because we have a match back / up

00:21:35,390 --> 00:21:40,510
against X that matches graphene clusters

00:21:38,120 --> 00:21:42,380
or extended graphene clusters I

00:21:40,510 --> 00:21:46,010
specifically and this is a Unicode

00:21:42,380 --> 00:21:50,180
concept where you can have one or more

00:21:46,010 --> 00:21:53,300
code points that I are bundled together

00:21:50,180 --> 00:21:56,510
as a graphene cluster and are in the

00:21:53,300 --> 00:21:58,370
user sense these are characters one

00:21:56,510 --> 00:22:01,250
graphing cluster is one character to

00:21:58,370 --> 00:22:06,680
your user I'm but maybe multiple code

00:22:01,250 --> 00:22:11,120
points so let's take this character I so

00:22:06,680 --> 00:22:14,090
we've got the Latin letter n with a dr

00:22:11,120 --> 00:22:16,280
SS in german you call them umlaut most

00:22:14,090 --> 00:22:18,890
people know about them but this is very

00:22:16,280 --> 00:22:25,540
much not a German character where would

00:22:18,890 --> 00:22:28,880
you use a character like this yeah I'm

00:22:25,540 --> 00:22:32,990
although this is the only known yes I I

00:22:28,880 --> 00:22:34,550
know about him and unfortunately the

00:22:32,990 --> 00:22:37,400
Unicode consortium they didn't take

00:22:34,550 --> 00:22:40,070
spinal tap into mind when defining code

00:22:37,400 --> 00:22:43,670
points so there's no single code point

00:22:40,070 --> 00:22:47,120
for n Latin letter n with combining dr

00:22:43,670 --> 00:22:51,050
SS I in order to represent this you have

00:22:47,120 --> 00:22:54,500
to have Latin letter n followed by

00:22:51,050 --> 00:22:58,610
combining dr SS I another example of

00:22:54,500 --> 00:23:01,960
when I would use the named version some

00:22:58,610 --> 00:23:06,190
this is one code point to code points

00:23:01,960 --> 00:23:08,049
I look to code points total 11 it is one

00:23:06,190 --> 00:23:11,770
graphing cluster and backslash uppercase

00:23:08,049 --> 00:23:14,620
X will match that as one so when you are

00:23:11,770 --> 00:23:17,380
working on the level of what users

00:23:14,620 --> 00:23:21,909
perceive as characters I work with

00:23:17,380 --> 00:23:24,870
graphene clusters ine and I touched on

00:23:21,909 --> 00:23:28,240
this earlier but CR LF is considered one

00:23:24,870 --> 00:23:30,730
graphene cluster it's actually a cluster

00:23:28,240 --> 00:23:33,490
of control characters that really eat in

00:23:30,730 --> 00:23:34,600
the end it functions as a single control

00:23:33,490 --> 00:23:40,360
character so that's why it's considered

00:23:34,600 --> 00:23:42,010
a graphing cluster now backslash p we

00:23:40,360 --> 00:23:44,590
saw a little bit of this before but it's

00:23:42,010 --> 00:23:47,890
used for matching unicode character

00:23:44,590 --> 00:23:52,000
properties every unicode character has

00:23:47,890 --> 00:23:55,779
metadata associated with it which I they

00:23:52,000 --> 00:23:58,450
call properties and learning some of the

00:23:55,779 --> 00:24:00,250
basics here can be very useful in

00:23:58,450 --> 00:24:03,010
pattern matching in your regular

00:24:00,250 --> 00:24:06,250
expressions I and I'll go over a few

00:24:03,010 --> 00:24:09,610
here I woke first off there's one just

00:24:06,250 --> 00:24:12,520
called asking and this will match any

00:24:09,610 --> 00:24:15,010
one ascii code point i said this is the

00:24:12,520 --> 00:24:18,909
preferred way that I match just in ascii

00:24:15,010 --> 00:24:22,149
code point I if you uppercase that p

00:24:18,909 --> 00:24:24,940
well it negates this so that's any thing

00:24:22,149 --> 00:24:26,799
that is not an ascii code point I so

00:24:24,940 --> 00:24:29,320
when a lot of people say utf-8

00:24:26,799 --> 00:24:31,149
characters or unicode characters this is

00:24:29,320 --> 00:24:34,059
what they mean even though utf-8 and

00:24:31,149 --> 00:24:37,390
unicode includes the ascii subset i use

00:24:34,059 --> 00:24:39,779
this a lot for one liners and a canned

00:24:37,390 --> 00:24:45,880
such for you know if I'm looking for

00:24:39,779 --> 00:24:50,110
non-ascii data specifically then the

00:24:45,880 --> 00:24:52,990
most important unicode property I the

00:24:50,110 --> 00:24:55,450
general category so the name here of the

00:24:52,990 --> 00:24:58,809
property is general category and the

00:24:55,450 --> 00:25:01,600
value is letter I and this just says

00:24:58,809 --> 00:25:04,779
let's match any character or

00:25:01,600 --> 00:25:07,600
specifically code point I that has the

00:25:04,779 --> 00:25:11,409
general category a general category

00:25:07,600 --> 00:25:14,520
property of letter but that's a mouthful

00:25:11,409 --> 00:25:18,420
you're putting that in my

00:25:14,520 --> 00:25:20,910
ragga axes would make them undone ruling

00:25:18,420 --> 00:25:24,570
so let's take a look I because general

00:25:20,910 --> 00:25:27,840
category is so commonly used there's a

00:25:24,570 --> 00:25:31,590
shortcut you can just use the general

00:25:27,840 --> 00:25:33,480
category property and I were just using

00:25:31,590 --> 00:25:37,470
letter here they're even more shortcuts

00:25:33,480 --> 00:25:38,850
though I uppercase L stands for letter

00:25:37,470 --> 00:25:41,610
here and even when it's just one

00:25:38,850 --> 00:25:44,970
character you can leave off the curly

00:25:41,610 --> 00:25:49,560
braces now normally I might say okay

00:25:44,970 --> 00:25:52,080
this is becoming I unreadable but if you

00:25:49,560 --> 00:25:54,840
use the X mode and you properly spaced

00:25:52,080 --> 00:25:57,030
and your reg axes and also like comment

00:25:54,840 --> 00:26:00,540
what you want to do I like this because

00:25:57,030 --> 00:26:02,750
it's just recharacterize here's some

00:26:00,540 --> 00:26:05,880
examples of other general category

00:26:02,750 --> 00:26:08,490
values like I letter mark number

00:26:05,880 --> 00:26:10,050
punctuation and so forth and they're

00:26:08,490 --> 00:26:13,830
even subcategories of the general

00:26:10,050 --> 00:26:16,350
category so let's take s4 symbol there's

00:26:13,830 --> 00:26:18,480
also math symbol currency symbol

00:26:16,350 --> 00:26:19,800
modifier symbol and there are two letter

00:26:18,480 --> 00:26:22,020
codes for that you always have to use

00:26:19,800 --> 00:26:23,790
the curly braces for them but learning a

00:26:22,020 --> 00:26:26,310
little bit about these can really help

00:26:23,790 --> 00:26:30,060
out when there are cases that you might

00:26:26,310 --> 00:26:32,250
use a character class and just throw in

00:26:30,060 --> 00:26:34,410
a bunch of characters that is like oh

00:26:32,250 --> 00:26:35,790
these are all the currency symbols well

00:26:34,410 --> 00:26:38,280
someone's already done the work for you

00:26:35,790 --> 00:26:47,730
and you don't even need a cpn module

00:26:38,280 --> 00:26:50,600
like reg s per common yes cave yes it so

00:26:47,730 --> 00:26:53,430
Dave brings up a great point that I as

00:26:50,600 --> 00:26:55,770
Unicode expands as it does frequently

00:26:53,430 --> 00:26:58,800
with new versions well new characters

00:26:55,770 --> 00:27:01,560
are added and they may also be matched

00:26:58,800 --> 00:27:03,360
by existing properties and your

00:27:01,560 --> 00:27:06,120
application will just be upgraded

00:27:03,360 --> 00:27:08,400
associate Lee when you have the new

00:27:06,120 --> 00:27:13,220
version of glow that supports the new

00:27:08,400 --> 00:27:16,170
version of Unicode I another very

00:27:13,220 --> 00:27:18,300
powerful property that's commonly is is

00:27:16,170 --> 00:27:20,280
the script property so the name is

00:27:18,300 --> 00:27:23,779
script and here's an example value of

00:27:20,280 --> 00:27:27,529
Latin I'm and this will match

00:27:23,779 --> 00:27:32,139
any character that has the latin value

00:27:27,529 --> 00:27:34,909
of the script property I you can use it

00:27:32,139 --> 00:27:38,059
as a shortcut with just the value

00:27:34,909 --> 00:27:41,389
fortunately the general category and the

00:27:38,059 --> 00:27:44,359
script properties don't have values that

00:27:41,389 --> 00:27:46,009
overlap so you can go and use your

00:27:44,359 --> 00:27:47,989
values for general category or your

00:27:46,009 --> 00:27:50,960
values from script you can't do that

00:27:47,989 --> 00:27:52,820
with most of the other Unicode

00:27:50,960 --> 00:27:56,239
properties but these two are so common

00:27:52,820 --> 00:27:58,339
that there are these shortcuts and take

00:27:56,239 --> 00:28:00,259
a look at this use in a character class

00:27:58,339 --> 00:28:04,009
here we've got a character class where

00:28:00,259 --> 00:28:07,969
we're matching I hiragana katakana I hon

00:28:04,009 --> 00:28:09,830
44 kanji laughing and all of the common

00:28:07,969 --> 00:28:12,409
characters of this common punctuation

00:28:09,830 --> 00:28:14,960
and such so this is a character class

00:28:12,409 --> 00:28:18,229
that will match any character in the

00:28:14,960 --> 00:28:21,109
Japanese writing system and they're even

00:28:18,229 --> 00:28:23,739
I shortcuts I would either standard

00:28:21,109 --> 00:28:26,830
Unicode to find a four letter

00:28:23,739 --> 00:28:28,969
abbreviations for any of the scripts and

00:28:26,830 --> 00:28:31,580
cuts down on your code sound it's still

00:28:28,969 --> 00:28:33,830
fairly readable I hear some other

00:28:31,580 --> 00:28:42,109
examples you want to use your Egyptian

00:28:33,830 --> 00:28:47,210
hieroglyphs and such and here's one in

00:28:42,109 --> 00:28:50,869
action I using the Cyrillic property and

00:28:47,210 --> 00:28:58,700
this is actually for the Bulgarian

00:28:50,869 --> 00:29:04,909
stemmer ok let's head out of the reg ex

00:28:58,700 --> 00:29:08,989
land and take a look at casing so here

00:29:04,909 --> 00:29:13,129
we have a German word that uses the

00:29:08,989 --> 00:29:16,879
sharp s I and also o with umlaut I can

00:29:13,129 --> 00:29:20,389
say that now because this is German so

00:29:16,879 --> 00:29:21,950
let's lower case this word and well yeah

00:29:20,389 --> 00:29:26,749
we get the appropriate lowercase forum

00:29:21,950 --> 00:29:28,399
for it now let's uppercase the word some

00:29:26,749 --> 00:29:31,820
folks might not expect what we get here

00:29:28,399 --> 00:29:35,989
because I in common German usage there's

00:29:31,820 --> 00:29:37,539
no uppercase form of the sharp s instead

00:29:35,989 --> 00:29:40,479
they use

00:29:37,539 --> 00:29:42,850
uppercase s uppercase s okay well that's

00:29:40,479 --> 00:29:46,809
great that probe will do this by default

00:29:42,850 --> 00:29:48,399
on argh Unicode strings but what about

00:29:46,809 --> 00:29:53,009
this brings up some trouble with

00:29:48,399 --> 00:29:56,080
comparison because here let's I

00:29:53,009 --> 00:29:57,489
lowercase it and uppercase you can then

00:29:56,080 --> 00:29:59,109
lower case it well this is not going to

00:29:57,489 --> 00:30:03,009
match because now on the right side

00:29:59,109 --> 00:30:06,609
we've met lowercase s lowercase s I and

00:30:03,009 --> 00:30:08,619
this isn't just a problem with the sharp

00:30:06,609 --> 00:30:10,239
ass up there are a lot of Greek

00:30:08,619 --> 00:30:12,220
characters where there are multiple

00:30:10,239 --> 00:30:19,330
cases depending on where they are in the

00:30:12,220 --> 00:30:21,519
world I in the word and case folding is

00:30:19,330 --> 00:30:23,769
what we need or you might refer to as

00:30:21,519 --> 00:30:26,889
fold case instead of lowercase or

00:30:23,769 --> 00:30:29,619
uppercase I this is really only you it

00:30:26,889 --> 00:30:32,859
should be used for comparison as opposed

00:30:29,619 --> 00:30:34,690
to returning a value for the end user to

00:30:32,859 --> 00:30:38,950
see you want uppercase and lowercase to

00:30:34,690 --> 00:30:42,039
return values I'm but here we are using

00:30:38,950 --> 00:30:48,539
the Unicode case fold module written by

00:30:42,039 --> 00:30:48,539
fellow shutterstock I Andrew Rodman and

00:30:49,229 --> 00:30:55,840
we are running full case on both of

00:30:52,720 --> 00:30:59,859
these what it actually does is returns

00:30:55,840 --> 00:31:02,739
the lowercase form I but the lowercase

00:30:59,859 --> 00:31:04,450
folded form so it will be lower case s

00:31:02,739 --> 00:31:07,059
lowercase s and this will match

00:31:04,450 --> 00:31:10,059
appropriately you can also use this say

00:31:07,059 --> 00:31:11,950
in sorting I where you need to compare

00:31:10,059 --> 00:31:14,859
one value to another and you want to

00:31:11,950 --> 00:31:16,899
make sure that your I got your case

00:31:14,859 --> 00:31:19,899
worked out well but you don't have to

00:31:16,899 --> 00:31:24,549
just use this I you know this Sipan

00:31:19,899 --> 00:31:27,279
module in its now core in 516 so I FC

00:31:24,549 --> 00:31:33,759
along with LC and you see can just be

00:31:27,279 --> 00:31:36,729
used I in your pearl 516 code and then

00:31:33,759 --> 00:31:38,769
there's Unicode normalization I this is

00:31:36,729 --> 00:31:40,899
important because as I mentioned they're

00:31:38,769 --> 00:31:45,450
combining characters but there are also

00:31:40,899 --> 00:31:48,510
pre combined characters here we have the

00:31:45,450 --> 00:31:52,289
letter o with combined 11 letter o with

00:31:48,510 --> 00:31:55,830
DSS but here we have Latin letter o

00:31:52,289 --> 00:31:58,679
followed by combining d heiresses I in

00:31:55,830 --> 00:32:01,049
Unicode terms these are canonically

00:31:58,679 --> 00:32:03,090
equivalent and for every intent and

00:32:01,049 --> 00:32:10,049
purpose you should treat them as the

00:32:03,090 --> 00:32:12,570
exact same I but the Pearl 5 equal

00:32:10,049 --> 00:32:14,340
operator string equality operator is not

00:32:12,570 --> 00:32:16,860
going to do that for you so you need to

00:32:14,340 --> 00:32:19,500
normalize I am fortunately Unicode

00:32:16,860 --> 00:32:21,240
normalizes bundled with core I hear

00:32:19,500 --> 00:32:22,980
we're normalizing to the normalization

00:32:21,240 --> 00:32:24,779
form composed we're not going to be able

00:32:22,980 --> 00:32:26,789
to get deeply into normalization forms

00:32:24,779 --> 00:32:29,279
but the main thing is just use the same

00:32:26,789 --> 00:32:35,549
normalization form for up both and yes

00:32:29,279 --> 00:32:37,970
this will match and a you can mix in

00:32:35,549 --> 00:32:41,730
your case folding and you're a

00:32:37,970 --> 00:32:43,110
normalization in order to match this

00:32:41,730 --> 00:32:47,210
where we've got a mix of these two

00:32:43,110 --> 00:32:51,240
different issues we just looked at so I

00:32:47,210 --> 00:32:56,490
some may find it useful to normalize at

00:32:51,240 --> 00:32:58,049
the beginning of your IM so that you can

00:32:56,490 --> 00:32:59,700
consistently work in the same

00:32:58,049 --> 00:33:00,990
normalization form so let's take a look

00:32:59,700 --> 00:33:04,169
at that chart i showed earlier with that

00:33:00,990 --> 00:33:07,080
out of him we decode our utf-8 we've got

00:33:04,169 --> 00:33:08,399
a character string normalize it there

00:33:07,080 --> 00:33:10,019
are a few different normalization forms

00:33:08,399 --> 00:33:12,210
i can't get deeply into them today but

00:33:10,019 --> 00:33:15,269
the better for different different ones

00:33:12,210 --> 00:33:19,799
are better for different uses i work on

00:33:15,269 --> 00:33:22,080
your normalized string and now this is

00:33:19,799 --> 00:33:24,510
not a requirement at all but some folks

00:33:22,080 --> 00:33:27,240
like to normalize on output because the

00:33:24,510 --> 00:33:29,970
work you do candy normalize your data

00:33:27,240 --> 00:33:31,860
and you might want to make sure that say

00:33:29,970 --> 00:33:35,190
your database because you're outputting

00:33:31,860 --> 00:33:37,950
to your database is all normalized then

00:33:35,190 --> 00:33:40,380
you encode and you've got your

00:33:37,950 --> 00:33:43,320
normalized utf-8 encoded output i

00:33:40,380 --> 00:33:45,990
remember that the normalization always

00:33:43,320 --> 00:33:51,059
happens on character strings not on your

00:33:45,990 --> 00:33:55,260
utf-8 encoded bite strings so let's take

00:33:51,059 --> 00:33:58,559
a look at first off at shutterstock on

00:33:55,260 --> 00:34:02,220
our current rate we are releasing

00:33:58,559 --> 00:34:05,990
two to four new languages each quarter I

00:34:02,220 --> 00:34:11,480
in about two months ago we released

00:34:05,990 --> 00:34:15,419
Danish Norwegian and Swedish and Finnish

00:34:11,480 --> 00:34:20,220
and in December we released a turkish

00:34:15,419 --> 00:34:23,790
czech polish and hungarian so when we

00:34:20,220 --> 00:34:26,240
originally did that there was a bug in

00:34:23,790 --> 00:34:38,399
our user interface can anyone here spot

00:34:26,240 --> 00:34:41,760
the bug exactly some I it is sorting

00:34:38,399 --> 00:34:44,490
just based on the code point the numeric

00:34:41,760 --> 00:34:46,770
value of your code point and that means

00:34:44,490 --> 00:34:49,139
that well everything ASCII will always

00:34:46,770 --> 00:34:53,429
come first but take a look at check here

00:34:49,139 --> 00:34:55,470
this uses a Latin letter C with a

00:34:53,429 --> 00:35:01,500
diacritic mark on top well that should

00:34:55,470 --> 00:35:07,650
become before the D I so we fix that and

00:35:01,500 --> 00:35:10,109
i'll show you how by using Unicode

00:35:07,650 --> 00:35:12,960
collation a Unicode defines a standard

00:35:10,109 --> 00:35:15,480
Unicode collation algorithm the uca and

00:35:12,960 --> 00:35:19,740
that's provided it's actually bundled

00:35:15,480 --> 00:35:23,430
with a pro core first you instantiate

00:35:19,740 --> 00:35:27,210
your new co later object and then with

00:35:23,430 --> 00:35:30,450
that you have the sort method and you

00:35:27,210 --> 00:35:34,290
can sort a list or awry and return the

00:35:30,450 --> 00:35:36,210
assorted content so by default this uses

00:35:34,290 --> 00:35:40,440
the the default you see a algorithm

00:35:36,210 --> 00:35:43,950
which is excellent if you have mixed

00:35:40,440 --> 00:35:49,290
data just like here this is in a variety

00:35:43,950 --> 00:35:52,170
of different languages I end the uca is

00:35:49,290 --> 00:35:53,490
great for supporting content that's in a

00:35:52,170 --> 00:35:55,560
variety of different languages it

00:35:53,490 --> 00:35:58,230
generally does the right thing it

00:35:55,560 --> 00:35:59,280
doesn't use the rules of sorting from

00:35:58,230 --> 00:36:00,480
each language because different

00:35:59,280 --> 00:36:03,599
languages have different rules of

00:36:00,480 --> 00:36:05,550
sorting if you want to do that actually

00:36:03,599 --> 00:36:07,350
i'll show you if you want to do that use

00:36:05,550 --> 00:36:10,440
unicode collate locale

00:36:07,350 --> 00:36:12,510
all of your data is German because you

00:36:10,440 --> 00:36:15,570
have say a German user and it's all

00:36:12,510 --> 00:36:18,600
German content will then use you unicode

00:36:15,570 --> 00:36:21,870
collate locale specify your locale as

00:36:18,600 --> 00:36:26,430
german and it will sort using german

00:36:21,870 --> 00:36:28,170
sort collation rules there are other

00:36:26,430 --> 00:36:30,900
things you can do than just sorting them

00:36:28,170 --> 00:36:35,340
save the example we used earlier we can

00:36:30,900 --> 00:36:38,430
actually do that comparison with the EQ

00:36:35,340 --> 00:36:41,160
method here we're using specifying a

00:36:38,430 --> 00:36:44,340
level two in our in San Shi a term there

00:36:41,160 --> 00:36:45,660
are predefined levels of support and

00:36:44,340 --> 00:36:50,490
this one is just saying we're ignoring

00:36:45,660 --> 00:36:53,900
case because we wanted to do both a case

00:36:50,490 --> 00:36:55,920
insensitive and normalization

00:36:53,900 --> 00:36:57,210
insensitive comparison here so that's

00:36:55,920 --> 00:37:04,800
another way to do it if you're already

00:36:57,210 --> 00:37:09,240
working with the Unicode collator and in

00:37:04,800 --> 00:37:11,550
addition to working in your source code

00:37:09,240 --> 00:37:14,010
for your applications and scripts and

00:37:11,550 --> 00:37:16,680
such it's also really important to test

00:37:14,010 --> 00:37:19,100
the Unicode functionality or the lack of

00:37:16,680 --> 00:37:23,520
Unicode functionality in your tests I

00:37:19,100 --> 00:37:26,760
here is code that lets see Jim Keenan

00:37:23,520 --> 00:37:28,830
has this module a text CSV hash ha and

00:37:26,760 --> 00:37:31,170
he came to me and asked well is this I

00:37:28,830 --> 00:37:34,020
am i following the rules for Unicode I

00:37:31,170 --> 00:37:36,900
and I took a look at it and one thing I

00:37:34,020 --> 00:37:42,210
noticed was that there was I that back /

00:37:36,900 --> 00:37:46,230
d being used to match a number and then

00:37:42,210 --> 00:37:49,830
parse it out and use it for the cell

00:37:46,230 --> 00:37:53,100
number in a CSV file so i sent him a

00:37:49,830 --> 00:37:56,970
patch and also several test cases here I

00:37:53,100 --> 00:37:59,670
that test it using these characters here

00:37:56,970 --> 00:38:02,910
and now i will first off using

00:37:59,670 --> 00:38:06,870
test-driven development I wrote the

00:38:02,910 --> 00:38:08,700
tests ran it it failed I so then made

00:38:06,870 --> 00:38:12,450
the fix just switched it from backslash

00:38:08,700 --> 00:38:15,330
d to the character class 0 through 9 and

00:38:12,450 --> 00:38:17,250
the test passed and submitted that

00:38:15,330 --> 00:38:20,010
through github and that's that's a

00:38:17,250 --> 00:38:23,760
pretty easy way to I

00:38:20,010 --> 00:38:26,400
with fix code that may not expect

00:38:23,760 --> 00:38:28,530
unicode character or none ascii

00:38:26,400 --> 00:38:31,620
characters as well as test that it works

00:38:28,530 --> 00:38:36,590
and even so whether you are supporting

00:38:31,620 --> 00:38:39,480
Unicode or not I recommend testing and

00:38:36,590 --> 00:38:53,160
that's that's all i have for here any

00:38:39,480 --> 00:38:58,940
questions yes yes so he brings up a

00:38:53,160 --> 00:38:58,940
great point I there is the Unicode UCD

00:38:59,000 --> 00:39:03,720
yeah the Toronto I eat some he brought

00:39:02,760 --> 00:39:06,300
up the point that you can use the

00:39:03,720 --> 00:39:08,220
Unicode UCD module bundled in core and

00:39:06,300 --> 00:39:12,300
that has a lot of helper functions for

00:39:08,220 --> 00:39:14,010
working with a unicode characters you

00:39:12,300 --> 00:39:18,690
see d stands for unicode character

00:39:14,010 --> 00:39:21,420
database I and there is a num function

00:39:18,690 --> 00:39:26,150
that you can i import and use that to

00:39:21,420 --> 00:39:30,240
convert any digit in any language two

00:39:26,150 --> 00:39:32,070
digits that pearl will accept for doing

00:39:30,240 --> 00:39:34,470
math and you know anything you'd work

00:39:32,070 --> 00:39:37,080
with numbers for I and you know there's

00:39:34,470 --> 00:39:38,940
so much content to go over for Unicode

00:39:37,080 --> 00:39:42,270
there's an entire Unicode conference

00:39:38,940 --> 00:39:45,000
it's three days long I and we only have

00:39:42,270 --> 00:39:46,920
say or 50 minutes or 45 minutes to work

00:39:45,000 --> 00:39:49,890
in here I just wanted to cover some

00:39:46,920 --> 00:39:52,590
important things that will I both help

00:39:49,890 --> 00:39:57,050
you eliminate bugs in your software as

00:39:52,590 --> 00:40:00,050
well as give you the power of Unicode

00:39:57,050 --> 00:40:00,050
yes

00:40:00,650 --> 00:40:13,050
I yes so the question is do we have the

00:40:07,590 --> 00:40:18,960
option to I turn on and off utf-8 pragma

00:40:13,050 --> 00:40:21,720
lexically and wait I wouldn't recommend

00:40:18,960 --> 00:40:24,360
it I do not recommend turning on and off

00:40:21,720 --> 00:40:29,369
utf-8 like within blocks your source

00:40:24,360 --> 00:40:31,800
code is either utf-8 or it's not I so

00:40:29,369 --> 00:40:35,369
I'm not sure if that functionality is in

00:40:31,800 --> 00:40:37,800
there or not but as early as possible in

00:40:35,369 --> 00:40:40,350
your source code say use utf-8 you are

00:40:37,800 --> 00:40:47,970
saying the rest of my file is utf-8 and

00:40:40,350 --> 00:40:50,190
just stick to that okay the comment

00:40:47,970 --> 00:40:52,230
comment from the side there is it does

00:40:50,190 --> 00:40:54,980
work he's tried it and now I'm telling

00:40:52,230 --> 00:40:54,980
you don't do it

00:41:15,369 --> 00:41:23,079
yes what about file names I parted the

00:41:19,990 --> 00:41:26,440
glitches with that if you if you open a

00:41:23,079 --> 00:41:28,569
file name that's been written as black

00:41:26,440 --> 00:41:30,430
and white encoding utf-8 in the file

00:41:28,569 --> 00:41:31,960
system and then you can catenate a

00:41:30,430 --> 00:41:35,230
Unicode string to it and then go back to

00:41:31,960 --> 00:41:37,420
over that it retranslate violated breaks

00:41:35,230 --> 00:41:40,450
so the question is about file names and

00:41:37,420 --> 00:41:44,710
that's a tricky subject because I the

00:41:40,450 --> 00:41:48,039
utf-8 support or even if they use utf-8

00:41:44,710 --> 00:41:50,349
varies from different file systems and

00:41:48,039 --> 00:41:54,970
different operating systems that's an

00:41:50,349 --> 00:42:01,029
area that I don't have as much expertise

00:41:54,970 --> 00:42:07,509
at and I I leave that as a exercise to

00:42:01,029 --> 00:42:10,950
the audience to investigate further is

00:42:07,509 --> 00:42:10,950
that a question in the back or stretch

00:42:31,490 --> 00:42:36,440
what we do something

00:42:33,770 --> 00:42:41,190
running back to avoid the

00:42:36,440 --> 00:42:44,369
mechanic is there a better approach that

00:42:41,190 --> 00:42:45,990
we're going to make sure to savor ganger

00:42:44,369 --> 00:42:50,530
you

00:42:45,990 --> 00:42:53,590
so so the question was that keeps saying

00:42:50,530 --> 00:42:56,860
he's got a project sounds like a legacy

00:42:53,590 --> 00:43:00,070
project where originally everything was

00:42:56,860 --> 00:43:01,810
being I the work was being processed on

00:43:00,070 --> 00:43:04,270
byte strings and when you needed to

00:43:01,810 --> 00:43:06,250
encode or decode to perform various

00:43:04,270 --> 00:43:08,200
operations you would do that at the

00:43:06,250 --> 00:43:12,400
point of needing to do that work instead

00:43:08,200 --> 00:43:16,960
of at the beginning and end of your code

00:43:12,400 --> 00:43:20,470
base so what to do when you're moving

00:43:16,960 --> 00:43:24,670
forward and want to just use character

00:43:20,470 --> 00:43:27,190
strings and my top recommendation is do

00:43:24,670 --> 00:43:28,810
not work with a mix of byte strings and

00:43:27,190 --> 00:43:31,360
character strings where you're sending

00:43:28,810 --> 00:43:35,140
them both around choose one or the other

00:43:31,360 --> 00:43:37,360
I either make sure everything's a

00:43:35,140 --> 00:43:38,890
character string or nothing is a

00:43:37,360 --> 00:43:40,660
character string except when you need to

00:43:38,890 --> 00:43:43,660
do those operations ideally of course

00:43:40,660 --> 00:43:45,490
everything a character string I but I've

00:43:43,660 --> 00:43:47,410
worked with legacy code bases where you

00:43:45,490 --> 00:43:51,040
never know which it's going to be and

00:43:47,410 --> 00:43:55,690
that causes so much pain in life I in

00:43:51,040 --> 00:44:00,430
those cases what I I would have to do a

00:43:55,690 --> 00:44:02,920
rewrite of some of some sort where I

00:44:00,430 --> 00:44:05,830
look at the entire code base and see how

00:44:02,920 --> 00:44:12,280
can I rewrite this so it's a big task

00:44:05,830 --> 00:44:14,580
it's it gets hairy what else ok thank

00:44:12,280 --> 00:44:14,580
you everyone

00:44:44,330 --> 00:44:54,270
alright looks to be about 2 30 so I

00:44:47,100 --> 00:44:57,560
think she'll Sark so okay everybody hear

00:44:54,270 --> 00:44:57,560

YouTube URL: https://www.youtube.com/watch?v=X2FQHUHjo8M


