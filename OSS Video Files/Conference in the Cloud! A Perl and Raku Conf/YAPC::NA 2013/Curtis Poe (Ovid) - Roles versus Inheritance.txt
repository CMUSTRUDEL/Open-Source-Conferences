Title: Curtis Poe (Ovid) - Roles versus Inheritance
Publication date: 2013-08-20
Playlist: YAPC::NA 2013
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:05,940
okay it's 305 time to get started my

00:00:04,589 --> 00:00:08,760
name is Curtis Pope better known to many

00:00:05,940 --> 00:00:10,230
of you folks as Ovid sure a lot of you

00:00:08,760 --> 00:00:12,509
folks already are familiar with who I am

00:00:10,230 --> 00:00:14,460
a little bit about my background I do

00:00:12,509 --> 00:00:16,890
want to apologize in advance for this

00:00:14,460 --> 00:00:19,080
talk some of the concepts in here tweet

00:00:16,890 --> 00:00:20,850
people's minds just a little bit it's

00:00:19,080 --> 00:00:22,920
not as complicated as the stuff that say

00:00:20,850 --> 00:00:25,230
Damien or Jonathan sometimes puts out

00:00:22,920 --> 00:00:27,150
there but at the same token is also not

00:00:25,230 --> 00:00:31,199
quite as funny so I apologize in advance

00:00:27,150 --> 00:00:33,030
it's a fair trade-off I think so this

00:00:31,199 --> 00:00:34,649
talk is not going to be a tutorial it's

00:00:33,030 --> 00:00:36,450
not about how to use roles because it

00:00:34,649 --> 00:00:40,559
turns out roles are really really easy

00:00:36,450 --> 00:00:42,149
to use instead are going to be talking

00:00:40,559 --> 00:00:44,280
about what's happening under the hood

00:00:42,149 --> 00:00:46,200
what not under the hood but what's

00:00:44,280 --> 00:00:47,789
happening design-wise the problems that

00:00:46,200 --> 00:00:49,379
rolls are designed to solve and why

00:00:47,789 --> 00:00:52,399
inheritance doesn't quite do that I

00:00:49,379 --> 00:00:54,930
don't be looking at a few similar things

00:00:52,399 --> 00:00:58,620
but first I want to go back to the past

00:00:54,930 --> 00:01:00,660
and talk about simula 1967 released in

00:00:58,620 --> 00:01:05,220
the summer of love actually when I was

00:01:00,660 --> 00:01:07,470
born yes i'm old and seamless 67 was the

00:01:05,220 --> 00:01:09,450
first modern 00 programming language

00:01:07,470 --> 00:01:11,280
that we had out there it had classes

00:01:09,450 --> 00:01:13,710
polymorphism encapsulation and

00:01:11,280 --> 00:01:15,710
inheritance and the first three of those

00:01:13,710 --> 00:01:19,049
ideas are there more or less

00:01:15,710 --> 00:01:22,290
non-controversial in the world of 00 but

00:01:19,049 --> 00:01:24,840
inheritance for going on five decades

00:01:22,290 --> 00:01:27,630
now we've been arguing about how to do

00:01:24,840 --> 00:01:28,650
inheritance correctly and that's

00:01:27,630 --> 00:01:31,380
something really interesting to think

00:01:28,650 --> 00:01:33,600
about and main languages they offer

00:01:31,380 --> 00:01:35,579
multiple inheritance where you can

00:01:33,600 --> 00:01:37,979
inherit from two or more parents at the

00:01:35,579 --> 00:01:39,600
same time and one thing I find

00:01:37,979 --> 00:01:41,130
absolutely fascinating when I was

00:01:39,600 --> 00:01:43,079
originally writing this talk and doing

00:01:41,130 --> 00:01:46,290
research into it the languages which

00:01:43,079 --> 00:01:49,320
offer multiple inheritance pearl C++ etc

00:01:46,290 --> 00:01:51,210
as a general rule style guide say you

00:01:49,320 --> 00:01:54,210
can have multiple inheritance do not use

00:01:51,210 --> 00:01:56,549
it just no we don't want you to touch

00:01:54,210 --> 00:01:58,320
that it's a bad thing if you know what

00:01:56,549 --> 00:02:00,360
you're doing fine go ahead but really

00:01:58,320 --> 00:02:02,610
you don't want to use it in fact it is

00:02:00,360 --> 00:02:05,219
so bad that many languages do not allow

00:02:02,610 --> 00:02:06,899
multiple inheritance of the languages

00:02:05,219 --> 00:02:08,700
that don't allow multiple inheritance

00:02:06,899 --> 00:02:10,560
almost every single one offers an

00:02:08,700 --> 00:02:12,599
alternative to multiple inheritance and

00:02:10,560 --> 00:02:13,430
furthermore says go ahead and use it as

00:02:12,599 --> 00:02:16,849
much as you want

00:02:13,430 --> 00:02:18,680
to it is so much better that's not

00:02:16,849 --> 00:02:21,980
always true as you're going to see as we

00:02:18,680 --> 00:02:24,079
go further along but inheritance is such

00:02:21,980 --> 00:02:25,400
a complicated thing it seems simple but

00:02:24,079 --> 00:02:26,780
it has so many subtleties that we've

00:02:25,400 --> 00:02:29,359
started to develop strategies to

00:02:26,780 --> 00:02:31,700
understand how to cope with inheritance

00:02:29,359 --> 00:02:33,170
better I'm not really going to go into

00:02:31,700 --> 00:02:35,689
these too much but we have the list

00:02:33,170 --> 00:02:37,069
cough substitution principle we have

00:02:35,689 --> 00:02:38,420
something called strict equivalence not

00:02:37,069 --> 00:02:41,120
too many people have heard about it but

00:02:38,420 --> 00:02:42,799
it's important we have c3 which I

00:02:41,120 --> 00:02:46,069
personally find to be about as useful as

00:02:42,799 --> 00:02:49,819
an ice pick on the Titanic but I won't

00:02:46,069 --> 00:02:51,799
go into that too much and then we have

00:02:49,819 --> 00:02:54,109
the alternatives to inheritance that we

00:02:51,799 --> 00:02:56,000
often deal with interfaces mix-ins

00:02:54,109 --> 00:02:58,400
delegation each which has their

00:02:56,000 --> 00:03:00,919
particular uses but again it's our

00:02:58,400 --> 00:03:03,680
struggling to deal with a fundamental

00:03:00,919 --> 00:03:05,840
issue in oo programming that we've been

00:03:03,680 --> 00:03:08,750
swinging at and failing for almost five

00:03:05,840 --> 00:03:12,200
decades now so in reality it's about

00:03:08,750 --> 00:03:13,609
four and a half decades of pain that

00:03:12,200 --> 00:03:15,500
should tell you something classes

00:03:13,609 --> 00:03:17,569
polymorphism encapsulation we don't have

00:03:15,500 --> 00:03:19,519
an issue with this but inheritance this

00:03:17,569 --> 00:03:21,319
is a code smell baked into the core of

00:03:19,519 --> 00:03:23,870
the language that you are using right

00:03:21,319 --> 00:03:25,970
now this isn't a code smell something

00:03:23,870 --> 00:03:27,530
you hack together last week so as a code

00:03:25,970 --> 00:03:29,599
smell it's worth looking at it a little

00:03:27,530 --> 00:03:33,530
closer and find out if there really is a

00:03:29,599 --> 00:03:35,120
problem here so I'm going to make you

00:03:33,530 --> 00:03:37,780
hurt just a little bit you're looking at

00:03:35,120 --> 00:03:40,010
the B object hierarchy for Pearl if

00:03:37,780 --> 00:03:42,889
you're not familiar with this this is

00:03:40,010 --> 00:03:44,720
the pure pearl front end which more or

00:03:42,889 --> 00:03:47,120
less represents what the Pearl internals

00:03:44,720 --> 00:03:48,290
look like it's not entirely accurate but

00:03:47,120 --> 00:03:50,689
it's close enough let's take a closer

00:03:48,290 --> 00:03:52,729
look at part of this we can see all

00:03:50,689 --> 00:03:54,199
these funny little classes right here

00:03:52,729 --> 00:03:56,120
and this looks rather interesting

00:03:54,199 --> 00:03:59,569
because if i zoom in that's actually

00:03:56,120 --> 00:04:01,609
multiple inheritance we have there so I

00:03:59,569 --> 00:04:03,079
want to explain this for just a second

00:04:01,609 --> 00:04:04,790
so you understand what's going on most

00:04:03,079 --> 00:04:06,680
of you are familiar that with the idea

00:04:04,790 --> 00:04:09,109
that a pearl scalar can represent a

00:04:06,680 --> 00:04:12,889
float and integer a string and other

00:04:09,109 --> 00:04:17,449
things so in this case the class at the

00:04:12,889 --> 00:04:20,750
top sv is a scalar value IV on the right

00:04:17,449 --> 00:04:23,659
is an integer value Peavy is a string

00:04:20,750 --> 00:04:25,370
value that P stands for pointer you can

00:04:23,659 --> 00:04:26,389
think of strings and see pointer to an

00:04:25,370 --> 00:04:28,789
array of care

00:04:26,389 --> 00:04:30,379
and then down at the bottom we have a PV

00:04:28,789 --> 00:04:33,110
IV this is the case when you have a

00:04:30,379 --> 00:04:34,879
scalar which has an internal integer

00:04:33,110 --> 00:04:37,279
representation and a string

00:04:34,879 --> 00:04:41,779
representation and why would you want to

00:04:37,279 --> 00:04:42,949
do that so this is pseudo code of what

00:04:41,779 --> 00:04:45,099
it could look like if any of you are

00:04:42,949 --> 00:04:47,990
familiar with dual VARs it allows you to

00:04:45,099 --> 00:04:49,249
twiddle those interesting internal

00:04:47,990 --> 00:04:52,159
representations so they don't always

00:04:49,249 --> 00:04:53,569
point to exactly the same thing and why

00:04:52,159 --> 00:04:55,999
would you want a different string value

00:04:53,569 --> 00:04:58,520
from the integer value because well on

00:04:55,999 --> 00:05:00,560
the string side three the ASCII value is

00:04:58,520 --> 00:05:01,610
51 you wouldn't want to use that in your

00:05:00,560 --> 00:05:03,949
mathematics because I would throw

00:05:01,610 --> 00:05:06,169
everything off so you keep all of those

00:05:03,949 --> 00:05:08,740
nice and separate and again this is

00:05:06,169 --> 00:05:11,599
really what these internals look like

00:05:08,740 --> 00:05:13,490
but here's what it lets you do so in

00:05:11,599 --> 00:05:15,590
Perl and Java allows something very

00:05:13,490 --> 00:05:17,180
similar this is so important that Java

00:05:15,590 --> 00:05:19,099
other one exception to operator

00:05:17,180 --> 00:05:21,800
overloading is to allow this one feature

00:05:19,099 --> 00:05:24,110
that's built into pearl my count equals

00:05:21,800 --> 00:05:26,089
three count plus equals two so we know

00:05:24,110 --> 00:05:29,150
count equals five not here we say I have

00:05:26,089 --> 00:05:31,490
count apples and again java same thing

00:05:29,150 --> 00:05:33,409
this is so incredibly useful but

00:05:31,490 --> 00:05:36,439
internally you have the numeric and the

00:05:33,409 --> 00:05:39,469
string representation so if you have if

00:05:36,439 --> 00:05:43,460
you're familiar with open my file handle

00:05:39,469 --> 00:05:46,099
mode filename or Die dollar bang dollar

00:05:43,460 --> 00:05:47,990
bang is actually a dual variable which

00:05:46,099 --> 00:05:50,029
has an integer value representing the

00:05:47,990 --> 00:05:52,009
error code and a string value which is

00:05:50,029 --> 00:05:56,180
the human readable version of that error

00:05:52,009 --> 00:05:58,339
code it's very common in Perl so again

00:05:56,180 --> 00:06:01,729
pseudo code at the top in our string

00:05:58,339 --> 00:06:04,759
package the pv a string might return the

00:06:01,729 --> 00:06:06,439
string value pv IV the integer value a

00:06:04,759 --> 00:06:09,319
string might return the integer value

00:06:06,439 --> 00:06:11,060
and our package bpv ivy it actually

00:06:09,319 --> 00:06:13,639
inherits from the string version first

00:06:11,060 --> 00:06:15,949
and then the integer version first so if

00:06:13,639 --> 00:06:17,539
you want to print it as string you're

00:06:15,949 --> 00:06:19,819
only going to get the string value you

00:06:17,539 --> 00:06:21,710
cannot get the integer value out of that

00:06:19,819 --> 00:06:24,169
that's a side effect of diamond

00:06:21,710 --> 00:06:27,139
inheritance so now you have to hard code

00:06:24,169 --> 00:06:29,509
the integer value class name into the

00:06:27,139 --> 00:06:32,089
method name in order to get that integer

00:06:29,509 --> 00:06:34,339
value so we call an encapsulation

00:06:32,089 --> 00:06:37,849
violation you don't want to know about

00:06:34,339 --> 00:06:39,689
your inheritance hierarchy now just as

00:06:37,849 --> 00:06:41,909
an aside when I first gave this talk

00:06:39,689 --> 00:06:44,580
someone asked me can you pick a simpler

00:06:41,909 --> 00:06:47,849
example and I started thinking about

00:06:44,580 --> 00:06:49,379
this and I know because the reality is

00:06:47,849 --> 00:06:51,899
when multiple inheritance works it's

00:06:49,379 --> 00:06:54,329
fine it's easy not a problem when it

00:06:51,899 --> 00:06:55,679
doesn't work this is what happens it

00:06:54,329 --> 00:06:59,009
becomes complicated ittle bit harder to

00:06:55,679 --> 00:07:00,869
think about and the reality of systems

00:06:59,009 --> 00:07:02,459
grow if we get to the point where we

00:07:00,869 --> 00:07:04,349
start relying on multiple inheritance

00:07:02,459 --> 00:07:07,199
too many times these sorts of problems

00:07:04,349 --> 00:07:10,769
crop up more often they're subtle

00:07:07,199 --> 00:07:12,149
they're difficult and what's going on

00:07:10,769 --> 00:07:14,069
the reason why we have these

00:07:12,149 --> 00:07:15,809
complications with multiple inheritance

00:07:14,069 --> 00:07:17,550
or sometimes even single inheritance is

00:07:15,809 --> 00:07:20,189
because there are two things that

00:07:17,550 --> 00:07:21,629
classes are trying to do and it's always

00:07:20,189 --> 00:07:25,009
been two things the classes have been

00:07:21,629 --> 00:07:26,939
trying to do 1a class is an agent of

00:07:25,009 --> 00:07:29,339
responsibility if there's one thing you

00:07:26,939 --> 00:07:31,079
want to think about for an object it is

00:07:29,339 --> 00:07:33,779
an expert in what it is supposed to do

00:07:31,079 --> 00:07:34,949
and as your system gets bigger and as

00:07:33,779 --> 00:07:37,919
your business rules grow more

00:07:34,949 --> 00:07:40,619
complicated now this item object needs

00:07:37,919 --> 00:07:42,419
to maybe have a wait method available to

00:07:40,619 --> 00:07:44,819
it maybe it needs to have an

00:07:42,419 --> 00:07:47,219
availability method all sorts of things

00:07:44,819 --> 00:07:50,249
get added to objects as our

00:07:47,219 --> 00:07:54,419
responsibilities increase this makes the

00:07:50,249 --> 00:07:57,029
code larger but if you reuse something

00:07:54,419 --> 00:07:58,860
like when you have a when you use list

00:07:57,029 --> 00:08:00,629
util do you import all the functions

00:07:58,860 --> 00:08:03,839
from list util know you just import the

00:08:00,629 --> 00:08:06,209
ones you want so if you're using

00:08:03,839 --> 00:08:07,979
inheritance with an object a lot of

00:08:06,209 --> 00:08:09,239
times you're doing that just because you

00:08:07,979 --> 00:08:10,829
want one or two of the behavior

00:08:09,239 --> 00:08:12,179
inheritance or the class you just want

00:08:10,829 --> 00:08:14,189
one or two of the behaviors from that

00:08:12,179 --> 00:08:17,189
class you don't necessarily want the

00:08:14,189 --> 00:08:18,869
entire thing so for code reuse you just

00:08:17,189 --> 00:08:20,939
want to reuse the code you actually want

00:08:18,869 --> 00:08:23,999
to reuse not all of it just a small

00:08:20,939 --> 00:08:26,699
amount so class responsibility wants

00:08:23,999 --> 00:08:28,589
larger classes code reuse wants a

00:08:26,699 --> 00:08:31,229
smaller set of code you have a

00:08:28,589 --> 00:08:35,430
fundamental tension than the underlying

00:08:31,229 --> 00:08:37,110
design that inheritance implies and the

00:08:35,430 --> 00:08:40,050
solution is to decouple these two things

00:08:37,110 --> 00:08:41,309
and this is where it starts to get

00:08:40,050 --> 00:08:43,860
interesting so we start looking at the

00:08:41,309 --> 00:08:45,059
field is everyone with me so far you've

00:08:43,860 --> 00:08:51,779
got a rough idea of what we're talking

00:08:45,059 --> 00:08:53,250
about okay good so Java is I find this

00:08:51,779 --> 00:08:53,610
so amusing because what they've done for

00:08:53,250 --> 00:08:56,250
the

00:08:53,610 --> 00:08:58,079
is they've created interfaces if you're

00:08:56,250 --> 00:08:59,640
not familiar with Java an interface is

00:08:58,079 --> 00:09:01,980
something that you implement and it's

00:08:59,640 --> 00:09:03,450
just a list of method signatures I'm

00:09:01,980 --> 00:09:05,399
going to implement this method that

00:09:03,450 --> 00:09:06,420
method the other method in other words

00:09:05,399 --> 00:09:09,149
this is something your class is

00:09:06,420 --> 00:09:10,769
responsible for so Java has successfully

00:09:09,149 --> 00:09:15,110
decoupled class responsibility from

00:09:10,769 --> 00:09:17,700
class responsibility well that's curious

00:09:15,110 --> 00:09:19,440
what about code reuse well I'm sorry you

00:09:17,700 --> 00:09:22,560
can't provide an implementation with

00:09:19,440 --> 00:09:24,149
interfaces so C sharp is actually going

00:09:22,560 --> 00:09:25,829
to do that Java might be doing this in

00:09:24,149 --> 00:09:27,720
the future they're trying to work on

00:09:25,829 --> 00:09:30,089
solving this issue but basically they

00:09:27,720 --> 00:09:33,050
completely failed to separate the class

00:09:30,089 --> 00:09:35,339
responsibility and the code reuse

00:09:33,050 --> 00:09:37,440
delegation is another thing which is

00:09:35,339 --> 00:09:40,110
often extremely appropriate but that

00:09:37,440 --> 00:09:41,610
also has its own problems quite often I

00:09:40,110 --> 00:09:43,890
find myself when I'm using a system

00:09:41,610 --> 00:09:46,560
which over which abuses delegation

00:09:43,890 --> 00:09:48,959
they've created small classes simply to

00:09:46,560 --> 00:09:50,610
have something to delegate to not

00:09:48,959 --> 00:09:53,010
because those things deserve to be

00:09:50,610 --> 00:09:54,420
classes and those are usually abstract

00:09:53,010 --> 00:10:01,019
behavior that other classes want to

00:09:54,420 --> 00:10:02,430
share and then we have mix-ins we also

00:10:01,019 --> 00:10:04,320
have aspects but I didn't have the time

00:10:02,430 --> 00:10:07,199
to cover their failure modes they're

00:10:04,320 --> 00:10:09,180
amusing by the way traits or roles were

00:10:07,199 --> 00:10:10,769
in partially in response to the problems

00:10:09,180 --> 00:10:12,000
that aspects have so look up

00:10:10,769 --> 00:10:14,130
aspect-oriented programming at some

00:10:12,000 --> 00:10:16,380
point mix-ins a lot of people love the

00:10:14,130 --> 00:10:17,790
idea of mix-ins so we're going to take a

00:10:16,380 --> 00:10:20,070
little look at them really quickly

00:10:17,790 --> 00:10:22,170
mix-ins did not originate with Ruby

00:10:20,070 --> 00:10:25,019
mix-ins originated with a variant of

00:10:22,170 --> 00:10:26,550
Lisp called flavors the gentleman who

00:10:25,019 --> 00:10:28,079
wrote it he was going down to his local

00:10:26,550 --> 00:10:29,760
ice cream shop and they would give him

00:10:28,079 --> 00:10:32,459
ice cream of a particular flavor and

00:10:29,760 --> 00:10:34,079
then he would mix in another flavor made

00:10:32,459 --> 00:10:37,649
it a little more interesting and he

00:10:34,079 --> 00:10:39,829
liked the idea so he built this into the

00:10:37,649 --> 00:10:41,850
flavors oo system for Lisp and

00:10:39,829 --> 00:10:44,579
eventually this worked its way into Ruby

00:10:41,850 --> 00:10:46,920
and a lot of people liked it so let's

00:10:44,579 --> 00:10:48,089
imagine just we're going to ascribe this

00:10:46,920 --> 00:10:50,640
real quickly so you can understand

00:10:48,089 --> 00:10:52,829
what's going on imagine you're writing a

00:10:50,640 --> 00:10:55,050
game you need a practical joke your

00:10:52,829 --> 00:10:58,170
character walks into a room a fuse gets

00:10:55,050 --> 00:11:00,779
set and then the thing explodes it's a

00:10:58,170 --> 00:11:02,910
practical joke character encounters now

00:11:00,779 --> 00:11:05,610
what happens is you don't want the fuse

00:11:02,910 --> 00:11:07,050
to have a random timing has to go off at

00:11:05,610 --> 00:11:08,550
a particular time

00:11:07,050 --> 00:11:11,610
but you don't want the explosion to kill

00:11:08,550 --> 00:11:13,709
the person because it's a joke so you

00:11:11,610 --> 00:11:17,100
have two classes your bomb class and

00:11:13,709 --> 00:11:18,240
your boss class and you know you have

00:11:17,100 --> 00:11:19,769
similar behavior in each of those

00:11:18,240 --> 00:11:21,959
classes and you're good programmer so

00:11:19,769 --> 00:11:23,850
you want to reuse this behavior so if

00:11:21,959 --> 00:11:25,890
you look up here you see your bomb fuse

00:11:23,850 --> 00:11:28,290
it's deterministic it goes off after a

00:11:25,890 --> 00:11:30,329
particular time you can't control your

00:11:28,290 --> 00:11:33,390
boss fuse so that's obviously not good

00:11:30,329 --> 00:11:34,890
your bomb explode that kills you your

00:11:33,390 --> 00:11:36,329
boss explodes sometimes you wish it

00:11:34,890 --> 00:11:37,529
kills you but that's really the method

00:11:36,329 --> 00:11:40,380
you want because it doesn't actually

00:11:37,529 --> 00:11:43,740
kill you so we want the bomb fuse method

00:11:40,380 --> 00:11:45,540
and the boss explode method from those

00:11:43,740 --> 00:11:49,350
other pack packages are you with me so

00:11:45,540 --> 00:11:51,810
far so let's see how this is implemented

00:11:49,350 --> 00:11:53,730
in Ruby on the left we have the bomb mix

00:11:51,810 --> 00:11:56,519
in on the right we have the boss mix in

00:11:53,730 --> 00:11:58,709
we have def explode diffuse for both of

00:11:56,519 --> 00:12:01,230
those and the bomb side says bomb

00:11:58,709 --> 00:12:03,300
explode bomb fuse and the boss I'd puts

00:12:01,230 --> 00:12:05,040
the string boss explode boss fuse fairly

00:12:03,300 --> 00:12:06,839
straightforward and here's your

00:12:05,040 --> 00:12:09,180
practical drill class you include boss

00:12:06,839 --> 00:12:11,579
you include bomb you instantiate a new

00:12:09,180 --> 00:12:15,089
practical joke object you light your

00:12:11,579 --> 00:12:16,829
fuse it explodes and it says bomb fuse

00:12:15,089 --> 00:12:22,440
bomb explode you didn't get the boss

00:12:16,829 --> 00:12:24,779
behavior why is this so in Ruby if you

00:12:22,440 --> 00:12:26,250
have ancestors is the method which will

00:12:24,779 --> 00:12:28,260
give you your inheritance tree and

00:12:26,250 --> 00:12:30,870
you'll see practical joke inherits from

00:12:28,260 --> 00:12:32,399
boss inherits from bomb inherits from

00:12:30,870 --> 00:12:34,740
object inherits from Colonel they

00:12:32,399 --> 00:12:38,250
actually implemented mix-ins via single

00:12:34,740 --> 00:12:40,740
inheritance chain so with multiple

00:12:38,250 --> 00:12:42,180
inheritance what usually happens is the

00:12:40,740 --> 00:12:43,860
first method you encounter wins the

00:12:42,180 --> 00:12:46,020
first class you've inherited from wins

00:12:43,860 --> 00:12:48,570
with mix-ins the last one you inherited

00:12:46,020 --> 00:12:50,610
from wins in any mix-ins which have a

00:12:48,570 --> 00:12:54,149
similar name method sorry you don't get

00:12:50,610 --> 00:12:56,699
them sort of this where it gets even

00:12:54,149 --> 00:12:57,870
more complicated on Ruby mailing lists

00:12:56,699 --> 00:13:00,120
every once in a while you'll encounter

00:12:57,870 --> 00:13:02,430
someone complaining about a bug where

00:13:00,120 --> 00:13:04,140
they say yeah I wrote this mixin and it

00:13:02,430 --> 00:13:05,699
called super but I didn't get my parents

00:13:04,140 --> 00:13:08,100
super method I got this other mixin

00:13:05,699 --> 00:13:09,329
method well first of all mixin shouldn't

00:13:08,100 --> 00:13:10,529
be calling super because they don't know

00:13:09,329 --> 00:13:13,380
what they're going to be mixed in too

00:13:10,529 --> 00:13:15,300
and this is just a problem with how

00:13:13,380 --> 00:13:18,449
inheritance is working if you try and

00:13:15,300 --> 00:13:21,199
abuse the system so mix-ins don't do

00:13:18,449 --> 00:13:24,240
what we want so let's look at roles

00:13:21,199 --> 00:13:25,920
left side we've got the bomb roll on the

00:13:24,240 --> 00:13:27,779
right side we have the Box roll this

00:13:25,920 --> 00:13:32,940
code is virtually identical except it's

00:13:27,779 --> 00:13:34,800
in superior language just kidding and we

00:13:32,940 --> 00:13:37,110
have our practical joke package use

00:13:34,800 --> 00:13:40,230
mousse with bomb boss joke practical

00:13:37,110 --> 00:13:42,300
joke new joke fuse joke explode and

00:13:40,230 --> 00:13:44,250
dunno method name conflict controls bomb

00:13:42,300 --> 00:13:47,130
and boss blah blah blah blah it doesn't

00:13:44,250 --> 00:13:50,699
run it doesn't know which bomb and boss

00:13:47,130 --> 00:13:52,829
methods you want and that's where very

00:13:50,699 --> 00:13:54,870
interesting because now with either

00:13:52,829 --> 00:13:56,310
multiple inheritance or mix-ins this

00:13:54,870 --> 00:13:57,540
would have been difficult but now you

00:13:56,310 --> 00:14:02,160
don't have to worry about it because

00:13:57,540 --> 00:14:06,000
it's not even going to compile so

00:14:02,160 --> 00:14:08,220
instead we with our bomb we exclude the

00:14:06,000 --> 00:14:10,470
explode method because we don't want to

00:14:08,220 --> 00:14:11,940
kill anyone with our boss we exclude the

00:14:10,470 --> 00:14:14,190
fuse method because we'd like to know

00:14:11,940 --> 00:14:15,630
when it's going to blow up and then we

00:14:14,190 --> 00:14:17,279
run the code and down at the bottom you

00:14:15,630 --> 00:14:20,060
see we have bomb fuse emboss explode

00:14:17,279 --> 00:14:22,860
exactly the behavior that we wanted

00:14:20,060 --> 00:14:24,029
fine-grained control of picking out the

00:14:22,860 --> 00:14:26,339
bits that we want so the person

00:14:24,029 --> 00:14:28,829
composing this class gets exactly what

00:14:26,339 --> 00:14:31,290
they want and the issues you have with

00:14:28,829 --> 00:14:32,790
inheritance go away you don't lose that

00:14:31,290 --> 00:14:34,829
behavior if you don't want to you can

00:14:32,790 --> 00:14:36,720
alias the method to something else and

00:14:34,829 --> 00:14:40,139
still call your original method that you

00:14:36,720 --> 00:14:42,209
moved away to avoid the conflict but it

00:14:40,139 --> 00:14:47,130
makes your life very simple lots of

00:14:42,209 --> 00:14:48,660
control and just to show you how easy it

00:14:47,130 --> 00:14:51,660
is generally to implement something like

00:14:48,660 --> 00:14:54,360
this you can also so here's the class my

00:14:51,660 --> 00:14:56,819
object it does the as llamo roll and it

00:14:54,360 --> 00:14:58,500
provides a to hash method and you see on

00:14:56,819 --> 00:15:01,380
the right side you've got the role does

00:14:58,500 --> 00:15:03,779
as llamo and it requires a to hash

00:15:01,380 --> 00:15:05,790
method so a role can say I require these

00:15:03,779 --> 00:15:08,040
methods in order to run properly and

00:15:05,790 --> 00:15:10,380
then you can see in the to yamo method

00:15:08,040 --> 00:15:12,420
we actually call the two hash method and

00:15:10,380 --> 00:15:14,459
we dump it out so you can now serialize

00:15:12,420 --> 00:15:16,350
any object that you want to as llamo as

00:15:14,459 --> 00:15:19,259
long as it provides an appropriate to

00:15:16,350 --> 00:15:20,819
hash method this is how behavior which

00:15:19,259 --> 00:15:23,189
might get shared across multiple classes

00:15:20,819 --> 00:15:26,959
which are unrelated by inheritance can

00:15:23,189 --> 00:15:26,959
easily be distributed it's very simple

00:15:27,560 --> 00:15:31,860
obviously there's a lot of caveats with

00:15:29,579 --> 00:15:33,389
us particularly since in Perl 5 we don't

00:15:31,860 --> 00:15:34,529
have method signatures this does limit

00:15:33,389 --> 00:15:37,860
the utility

00:15:34,529 --> 00:15:39,569
but we can we can see that lots of

00:15:37,860 --> 00:15:42,720
languages are really appreciating this

00:15:39,569 --> 00:15:45,569
it's been adopted all over the place but

00:15:42,720 --> 00:15:48,360
I won't go into that list so I want to

00:15:45,569 --> 00:15:50,100
talk about a real world problem just to

00:15:48,360 --> 00:15:52,050
show you that this actually does work I

00:15:50,100 --> 00:15:54,779
worked for the BBC for a number of years

00:15:52,050 --> 00:15:57,209
as many of you folks know and we were

00:15:54,779 --> 00:16:00,120
the world's largest broadcaster so at

00:15:57,209 --> 00:16:02,550
the time this has grown considerably we

00:16:00,120 --> 00:16:05,189
were representing in our and something

00:16:02,550 --> 00:16:08,430
called the PIP system the metadata about

00:16:05,189 --> 00:16:10,259
what TV shows were available so people

00:16:08,430 --> 00:16:11,850
all around the BBC their systems could

00:16:10,259 --> 00:16:14,459
call into our system and find out what's

00:16:11,850 --> 00:16:16,889
a schedule for this channel what's the

00:16:14,459 --> 00:16:18,629
schedule for this show and brands are

00:16:16,889 --> 00:16:20,819
things like fire fought Firefly

00:16:18,629 --> 00:16:23,249
Battlestar Galactica or just the name of

00:16:20,819 --> 00:16:24,660
a TV show the series for you in the

00:16:23,249 --> 00:16:28,110
American audience that's what we call

00:16:24,660 --> 00:16:31,279
the season then we had episodes you've

00:16:28,110 --> 00:16:33,509
never seen an episode of a show ever

00:16:31,279 --> 00:16:35,579
instead they aversions like the version

00:16:33,509 --> 00:16:38,370
might be edited for adult content or

00:16:35,579 --> 00:16:40,740
something like that you've never seen a

00:16:38,370 --> 00:16:43,230
version either instead you may have seen

00:16:40,740 --> 00:16:46,350
a broadcast on the television you may

00:16:43,230 --> 00:16:49,920
have seen an on-demand on sky or Hulu or

00:16:46,350 --> 00:16:51,449
something like that and on top of that

00:16:49,920 --> 00:16:56,100
even though this looks kind of top-down

00:16:51,449 --> 00:16:57,449
tree ish it started to get really gnarly

00:16:56,100 --> 00:16:59,129
you had series which could have sub

00:16:57,449 --> 00:17:00,720
series and then sub-series which could

00:16:59,129 --> 00:17:02,939
further have sub series and all sorts of

00:17:00,720 --> 00:17:04,770
constraints on them the problem domain

00:17:02,939 --> 00:17:09,209
itself looks simple it got very

00:17:04,770 --> 00:17:09,990
complicated and hairy and right now

00:17:09,209 --> 00:17:11,970
we're just going to look at how a

00:17:09,990 --> 00:17:14,549
television program might have been

00:17:11,970 --> 00:17:16,980
modeled in this system this is a lot of

00:17:14,549 --> 00:17:18,630
these stuff here is condensed down this

00:17:16,980 --> 00:17:25,530
isn't exactly what we had but it's close

00:17:18,630 --> 00:17:28,079
enough to actually be accurate mmm my

00:17:25,530 --> 00:17:30,780
apologies so you had a television

00:17:28,079 --> 00:17:32,700
program and who would inherit from

00:17:30,780 --> 00:17:35,460
tagged which would inherit from audited

00:17:32,700 --> 00:17:37,770
which inherited from our custom result

00:17:35,460 --> 00:17:39,600
source class which inherited from dbx

00:17:37,770 --> 00:17:41,490
class result source now some of you

00:17:39,600 --> 00:17:43,530
religion labels Oh programming or

00:17:41,490 --> 00:17:46,919
looking at this saying why is tagged and

00:17:43,530 --> 00:17:48,510
audited actually a class without going

00:17:46,919 --> 00:17:50,220
into too much detail the

00:17:48,510 --> 00:17:52,170
primary defense supposed to developers

00:17:50,220 --> 00:17:57,720
who had built the system before me would

00:17:52,170 --> 00:17:59,010
have said is it worked and they would

00:17:57,720 --> 00:18:01,500
inherit from things like this and it

00:17:59,010 --> 00:18:04,290
made their life fairly simple in some

00:18:01,500 --> 00:18:07,740
ways but as the system grew it started

00:18:04,290 --> 00:18:09,930
to become more unmaintained ball so

00:18:07,740 --> 00:18:12,150
again BBC world's largest broadcaster of

00:18:09,930 --> 00:18:14,280
course they had a table listing all the

00:18:12,150 --> 00:18:16,250
countries and this inherited from

00:18:14,280 --> 00:18:18,360
something a static results first class

00:18:16,250 --> 00:18:21,030
because we weren't updating this

00:18:18,360 --> 00:18:22,680
information too often we could but it

00:18:21,030 --> 00:18:24,330
had a few other behaviors in there but

00:18:22,680 --> 00:18:27,960
it was all still nice simple clean

00:18:24,330 --> 00:18:30,360
single inheritance and then the Berlin

00:18:27,960 --> 00:18:33,600
Wall fell a new country started popping

00:18:30,360 --> 00:18:35,550
up like popcorn the BBC is very very

00:18:33,600 --> 00:18:38,160
important if they accidentally miss

00:18:35,550 --> 00:18:39,780
named the new Czech Republic as the

00:18:38,160 --> 00:18:41,310
Ukraine or something like this this

00:18:39,780 --> 00:18:43,920
could cause an international incident we

00:18:41,310 --> 00:18:46,470
needed to know who was actually changing

00:18:43,920 --> 00:18:48,780
information in the country table so we

00:18:46,470 --> 00:18:50,640
wanted to audit this information but we

00:18:48,780 --> 00:18:52,320
can't actually audit this information

00:18:50,640 --> 00:18:54,660
when it gets changed this way because

00:18:52,320 --> 00:18:57,060
now everything that inherits from that

00:18:54,660 --> 00:18:59,370
static table is audited we didn't want

00:18:57,060 --> 00:19:00,570
that there's a number of ways we could

00:18:59,370 --> 00:19:05,300
have flipped this around but eventually

00:19:00,570 --> 00:19:08,490
we fell back onto this country multiple

00:19:05,300 --> 00:19:09,870
inheritance or static and that turned

00:19:08,490 --> 00:19:11,790
out to be a problem because the audited

00:19:09,870 --> 00:19:13,620
class offered a whole bunch of behavior

00:19:11,790 --> 00:19:16,530
that we didn't want for the country

00:19:13,620 --> 00:19:18,000
class but it worked and eventually you

00:19:16,530 --> 00:19:19,830
as a developer might go to your project

00:19:18,000 --> 00:19:22,230
manager and say you know this is getting

00:19:19,830 --> 00:19:24,090
to be complicated and hairy and why did

00:19:22,230 --> 00:19:26,220
I you know can you give me some advice

00:19:24,090 --> 00:19:29,190
and you know she might look at your code

00:19:26,220 --> 00:19:31,980
and say why in the heck are tagged and

00:19:29,190 --> 00:19:35,130
audited classes and then you kind of

00:19:31,980 --> 00:19:36,270
sink because you know she's right and at

00:19:35,130 --> 00:19:38,070
the end of the day you are to be writing

00:19:36,270 --> 00:19:40,800
the entire system when all you wanted to

00:19:38,070 --> 00:19:44,970
do was add a single line to a log file

00:19:40,800 --> 00:19:47,820
when someone changed the country you

00:19:44,970 --> 00:19:50,550
wanted a tiny bit of behavior added to

00:19:47,820 --> 00:19:53,310
country you didn't want to faff about

00:19:50,550 --> 00:19:54,810
with your inheritance hierarchy you

00:19:53,310 --> 00:19:56,700
didn't want to refactor your entire

00:19:54,810 --> 00:19:58,050
system you didn't want to struggle with

00:19:56,700 --> 00:20:01,240
multiple inheritance you just wanted to

00:19:58,050 --> 00:20:05,140
add that one tiny bit of behavior

00:20:01,240 --> 00:20:07,030
that's what roles do so this is what the

00:20:05,140 --> 00:20:08,830
system would look like in a Rolls model

00:20:07,030 --> 00:20:10,690
the only reason you would inherit from

00:20:08,830 --> 00:20:12,700
the results for us classes because dbx

00:20:10,690 --> 00:20:17,770
class requires you to inherit from it

00:20:12,700 --> 00:20:19,240
for its implementation in fact if it

00:20:17,770 --> 00:20:21,840
weren't for that I would not have had

00:20:19,240 --> 00:20:24,130
any inheritance in the system whatsoever

00:20:21,840 --> 00:20:25,660
so your country class might have looked

00:20:24,130 --> 00:20:27,670
like this package country use moves

00:20:25,660 --> 00:20:31,060
extends the my result source with two

00:20:27,670 --> 00:20:33,190
roles does static and does auditing so

00:20:31,060 --> 00:20:35,500
you can see pretty quickly up there what

00:20:33,190 --> 00:20:37,270
behaviors it actually implements and you

00:20:35,500 --> 00:20:42,040
minimize the inheritance and it makes it

00:20:37,270 --> 00:20:43,510
easier to understand so this hierarchy

00:20:42,040 --> 00:20:45,070
was actually fairly simple on this

00:20:43,510 --> 00:20:47,440
portion of our program you'll notice

00:20:45,070 --> 00:20:48,550
there's no without caring about what the

00:20:47,440 --> 00:20:50,770
names are there's no multiple

00:20:48,550 --> 00:20:52,360
inheritance in that but it was still

00:20:50,770 --> 00:20:54,240
getting to be a little bit annoying and

00:20:52,360 --> 00:20:56,500
afterwards it was completely flat

00:20:54,240 --> 00:21:01,660
everything just inherited from one class

00:20:56,500 --> 00:21:03,550
and if you opened up something so can

00:21:01,660 --> 00:21:05,500
anyone here maybe figure out what sort

00:21:03,550 --> 00:21:13,570
of behaviors this episode class might

00:21:05,500 --> 00:21:14,800
have implemented she yes and it's pretty

00:21:13,570 --> 00:21:17,320
simple to figure out what those various

00:21:14,800 --> 00:21:19,900
things are I can search for episodes by

00:21:17,320 --> 00:21:21,940
their broadcasts or by tags so we can

00:21:19,900 --> 00:21:23,830
possibly guess what tags are I can

00:21:21,940 --> 00:21:25,420
search for them by title by something

00:21:23,830 --> 00:21:26,950
called promotion I don't know a

00:21:25,420 --> 00:21:28,810
promotion is but I could probably learn

00:21:26,950 --> 00:21:30,940
it pretty quickly I can probably make a

00:21:28,810 --> 00:21:33,760
guess as to what a universal identify or

00:21:30,940 --> 00:21:36,910
an identifier universal is so what we

00:21:33,760 --> 00:21:38,320
have is an incredibly complex class

00:21:36,910 --> 00:21:41,440
there's actually a lot of code below

00:21:38,320 --> 00:21:42,610
this you open it up and at the top you

00:21:41,440 --> 00:21:44,290
get a convenient list of all the

00:21:42,610 --> 00:21:47,140
behaviors of this class implements a

00:21:44,290 --> 00:21:50,320
brand new programmer day one can open

00:21:47,140 --> 00:21:53,080
this up and have a pretty clear idea of

00:21:50,320 --> 00:21:58,930
a lot of what's going on underneath the

00:21:53,080 --> 00:22:00,640
hood so in short what roles offer you is

00:21:58,930 --> 00:22:03,610
they make your code easier to understand

00:22:00,640 --> 00:22:05,110
they simplify it a lot I have this

00:22:03,610 --> 00:22:07,810
happen in lots of systems by the way i

00:22:05,110 --> 00:22:09,700
want to mention i found out in perl 6 if

00:22:07,810 --> 00:22:11,590
you open up their class how in their

00:22:09,700 --> 00:22:13,300
metamodel they don't have inheritance

00:22:11,590 --> 00:22:14,029
there they have a huge list of roles

00:22:13,300 --> 00:22:15,830
just

00:22:14,029 --> 00:22:17,840
top implementing something just like

00:22:15,830 --> 00:22:19,669
this so when you read through the code

00:22:17,840 --> 00:22:21,859
it says it does this role does that role

00:22:19,669 --> 00:22:23,659
does the other role and it's very simple

00:22:21,859 --> 00:22:24,889
and it's very clear and more and more

00:22:23,659 --> 00:22:26,359
people are going with this so they're

00:22:24,889 --> 00:22:28,969
actually using roles with more of a

00:22:26,359 --> 00:22:31,489
Tinkertoy approach of assembling objects

00:22:28,969 --> 00:22:34,279
with the required behavior as opposed to

00:22:31,489 --> 00:22:36,590
using any inheritance and today I quite

00:22:34,279 --> 00:22:38,450
often write fairly complicated systems

00:22:36,590 --> 00:22:40,849
and I have no inheritance whatsoever and

00:22:38,450 --> 00:22:44,419
it makes them very easy to understand

00:22:40,849 --> 00:22:46,219
and to refactor as needed so it makes it

00:22:44,419 --> 00:22:48,320
makes your code easier to understand

00:22:46,219 --> 00:22:50,059
when you switch to roles because you're

00:22:48,320 --> 00:22:51,950
separating out the individual behaviors

00:22:50,059 --> 00:22:53,960
that you want from the class

00:22:51,950 --> 00:22:56,149
responsibilities that you need to

00:22:53,960 --> 00:22:58,249
present your code winds up being simpler

00:22:56,149 --> 00:23:00,200
your individual classes are smaller you

00:22:58,249 --> 00:23:01,820
have shallower inheritance trees so you

00:23:00,200 --> 00:23:03,769
don't have to dig through there to

00:23:01,820 --> 00:23:06,979
figure out the behavior you want and

00:23:03,769 --> 00:23:09,049
your code also happens to be safer if a

00:23:06,979 --> 00:23:12,039
role requires some methods and those

00:23:09,049 --> 00:23:14,029
methods are not there it will fail a

00:23:12,039 --> 00:23:16,729
composition time but that's close enough

00:23:14,029 --> 00:23:18,019
to compile time to ensure that you don't

00:23:16,729 --> 00:23:20,029
get a call at two thirty in the morning

00:23:18,019 --> 00:23:22,159
saying that this five hour batch job

00:23:20,029 --> 00:23:23,989
just failed with the missing method you

00:23:22,159 --> 00:23:26,719
find out immediately that you're missing

00:23:23,989 --> 00:23:28,969
those methods so that's a little bit of

00:23:26,719 --> 00:23:31,460
the benefit we get from a more static

00:23:28,969 --> 00:23:33,739
system built into our very dynamic

00:23:31,460 --> 00:23:35,089
system so we kind of get a little bit of

00:23:33,739 --> 00:23:39,229
love from both worlds there it's very

00:23:35,089 --> 00:23:46,059
nice so my wife told me to put in this

00:23:39,229 --> 00:23:46,059
slide my apologies any questions

00:24:01,559 --> 00:24:06,370
are you free specifically composition to

00:24:04,150 --> 00:24:08,440
be a delegation is that specifically

00:24:06,370 --> 00:24:10,510
what you're referring to in that case I

00:24:08,440 --> 00:24:12,280
didn't really go into this too in depth

00:24:10,510 --> 00:24:14,260
composition be a delegation so

00:24:12,280 --> 00:24:16,210
delegation by the way you have an object

00:24:14,260 --> 00:24:18,340
you know San she ate an object and has

00:24:16,210 --> 00:24:20,380
an instance of another object and the

00:24:18,340 --> 00:24:22,330
first objects methods will automatically

00:24:20,380 --> 00:24:26,650
delegate off to the methods in the other

00:24:22,330 --> 00:24:28,150
object sometimes this requires a fair

00:24:26,650 --> 00:24:29,409
amount of scaffolding depending upon the

00:24:28,150 --> 00:24:30,720
programming language that you're working

00:24:29,409 --> 00:24:32,950
with the tools that you have available

00:24:30,720 --> 00:24:34,630
sometimes you want bi-directional

00:24:32,950 --> 00:24:37,330
communication between the two because

00:24:34,630 --> 00:24:39,280
they wind up being tightly coupled my

00:24:37,330 --> 00:24:41,409
concern is the objects are delegating

00:24:39,280 --> 00:24:43,270
off to quite often winds up being

00:24:41,409 --> 00:24:45,730
something which should not be an object

00:24:43,270 --> 00:24:47,650
but it's simply there because you need

00:24:45,730 --> 00:24:50,710
to have another class to hold this

00:24:47,650 --> 00:24:53,740
behavior so I see the auditing classes I

00:24:50,710 --> 00:24:56,320
I see in systems where what is an

00:24:53,740 --> 00:24:58,419
auditing that there isn't an auditing

00:24:56,320 --> 00:25:00,730
auditing is something you do it some

00:24:58,419 --> 00:25:02,830
behaviors that you have but we often

00:25:00,730 --> 00:25:04,690
have auditing or security classes which

00:25:02,830 --> 00:25:07,750
are kind of abstract things not concrete

00:25:04,690 --> 00:25:09,880
things so this is another concern plus

00:25:07,750 --> 00:25:11,470
in Perl in particular I see delegation

00:25:09,880 --> 00:25:13,000
as being whenever I bench market it's

00:25:11,470 --> 00:25:15,100
quite a bit slower so any system which

00:25:13,000 --> 00:25:17,200
forces you to rely on delegation you

00:25:15,100 --> 00:25:18,400
wind up taking a performance hit so

00:25:17,200 --> 00:25:19,870
obviously that's not my first

00:25:18,400 --> 00:25:22,240
consideration so those are the things

00:25:19,870 --> 00:25:25,570
that I think of when someone talks to me

00:25:22,240 --> 00:25:28,000
about delegation mix-ins I just say no

00:25:25,570 --> 00:25:29,500
because they do solve some of the

00:25:28,000 --> 00:25:31,600
problem they properly separate the

00:25:29,500 --> 00:25:32,860
behavior from responsibility but you

00:25:31,600 --> 00:25:35,049
have the same ordering issues and you

00:25:32,860 --> 00:25:42,520
don't have control over it for a large

00:25:35,049 --> 00:25:44,200
system as problematic ah oh no no mix

00:25:42,520 --> 00:25:45,520
ins and rolls totally different totally

00:25:44,200 --> 00:25:53,200
different I apologize I must've

00:25:45,520 --> 00:25:55,169
misunderstood that that is correct so

00:25:53,200 --> 00:25:57,280
could you restate your question then i

00:25:55,169 --> 00:25:59,580
rambled on too long I forgot what you

00:25:57,280 --> 00:25:59,580
were saying

00:26:01,320 --> 00:26:08,530
um I love the I love doing that with

00:26:06,430 --> 00:26:10,450
rolls if I want to guarantee that this

00:26:08,530 --> 00:26:13,990
particular class implements something I

00:26:10,450 --> 00:26:19,030
do this with factory is quite a bit so

00:26:13,990 --> 00:26:25,060
that's when I use that but I'm not sure

00:26:19,030 --> 00:26:26,170
exactly what the question is I know I

00:26:25,060 --> 00:26:31,060
don't think there's any problem with

00:26:26,170 --> 00:26:32,920
that with the caveat that again we don't

00:26:31,060 --> 00:26:34,630
have method signatures as a general rule

00:26:32,920 --> 00:26:35,770
for systems if you have two methods with

00:26:34,630 --> 00:26:38,110
an identical name if they're doing

00:26:35,770 --> 00:26:39,610
semantically different things there's a

00:26:38,110 --> 00:26:41,440
problem there they want to do something

00:26:39,610 --> 00:26:42,700
which is more or less identical but

00:26:41,440 --> 00:26:44,110
because we don't have method signatures

00:26:42,700 --> 00:26:47,370
it's a little bit harder to guarantee

00:26:44,110 --> 00:26:49,540
this so we lose some safety there but

00:26:47,370 --> 00:26:50,860
ask me again later and we can talk about

00:26:49,540 --> 00:26:57,370
this more in depth I've got another

00:26:50,860 --> 00:26:59,050
question back here but can you please

00:26:57,370 --> 00:27:01,980
define what you mean by aliasing because

00:26:59,050 --> 00:27:01,980
I say yes and no

00:27:15,559 --> 00:27:22,170
various API method where you have a

00:27:18,650 --> 00:27:27,000
class that needs to be I should say a

00:27:22,170 --> 00:27:31,740
goal that needs to be executed for 180 I

00:27:27,000 --> 00:27:33,930
that a similar role for another API in

00:27:31,740 --> 00:27:38,550
those cases is there any way to alias

00:27:33,930 --> 00:27:46,950
those goals the name do you mean the

00:27:38,550 --> 00:27:55,559
package names for the method names you

00:27:46,950 --> 00:27:58,290
mean the method names like that yes

00:27:55,559 --> 00:28:01,710
that's alias the red part yeah so it's

00:27:58,290 --> 00:28:04,530
there there is a caveat to keep in mind

00:28:01,710 --> 00:28:05,760
and this is it's one of the problems

00:28:04,530 --> 00:28:07,710
that I know traits researchers and

00:28:05,760 --> 00:28:11,580
others women struggling to deal with if

00:28:07,710 --> 00:28:14,990
you have a lingua jizz with extreme late

00:28:11,580 --> 00:28:17,550
binding such as I know pearl for example

00:28:14,990 --> 00:28:21,660
what happens when you alias fuse to

00:28:17,550 --> 00:28:24,960
random fuse and internally the the boss

00:28:21,660 --> 00:28:27,960
role wants to call its fuse method for

00:28:24,960 --> 00:28:31,230
some reason then which fuse method does

00:28:27,960 --> 00:28:34,320
it get so for some languages you could

00:28:31,230 --> 00:28:35,790
bind that at compile time to guarantee

00:28:34,320 --> 00:28:38,040
that boss would still call the correct

00:28:35,790 --> 00:28:39,809
fuse method but in this case it's going

00:28:38,040 --> 00:28:42,929
to be delayed and it's actually going to

00:28:39,809 --> 00:28:46,440
the bomb fuse method so be very careful

00:28:42,929 --> 00:28:48,000
about aliasing excluding and aliasing

00:28:46,440 --> 00:28:50,400
methods you should consider it to be a

00:28:48,000 --> 00:28:52,710
code smell it is not a bad thing

00:28:50,400 --> 00:28:54,150
necessarily but it is certainly

00:28:52,710 --> 00:28:55,500
something you should look at and it is

00:28:54,150 --> 00:28:57,600
going to cause you problems if you over

00:28:55,500 --> 00:29:00,960
rely on it I tend to use this as a

00:28:57,600 --> 00:29:02,760
stopgap measure when I am refactoring a

00:29:00,960 --> 00:29:04,530
system and I find similarly named

00:29:02,760 --> 00:29:08,250
methods when I'm turning classes into

00:29:04,530 --> 00:29:10,440
roles but because of some of the issues

00:29:08,250 --> 00:29:12,570
with the timing of when methods get

00:29:10,440 --> 00:29:15,600
bound you can get a method that you did

00:29:12,570 --> 00:29:18,179
not expect so you want to avoid that if

00:29:15,600 --> 00:29:22,970
you possibly can does that answer your

00:29:18,179 --> 00:29:22,970
question yeah okay yes

00:29:26,030 --> 00:29:36,810
yes your guess is as good as mine at

00:29:32,850 --> 00:29:38,850
this point I have a I have gone back and

00:29:36,810 --> 00:29:42,060
forth a few times trying to figure out

00:29:38,850 --> 00:29:45,660
what the best thing is I've all I've

00:29:42,060 --> 00:29:48,960
often liked things does with a gerund

00:29:45,660 --> 00:29:51,140
like does targeting does blah blah blah

00:29:48,960 --> 00:29:53,400
but that doesn't always work

00:29:51,140 --> 00:29:56,280
particularly when you call object arrow

00:29:53,400 --> 00:29:58,050
does does blah blah blah you wind up

00:29:56,280 --> 00:30:00,360
getting something repetitive there I'm

00:29:58,050 --> 00:30:02,310
not sure what the best thing to do is so

00:30:00,360 --> 00:30:07,230
I wish I had a better answer I wish you

00:30:02,310 --> 00:30:21,030
had not asked that question but at least

00:30:07,230 --> 00:30:22,800
I'm honest yes my so the question was

00:30:21,030 --> 00:30:24,210
have you run into x 1 inheritance does

00:30:22,800 --> 00:30:26,430
make more sense and rolls on what with

00:30:24,210 --> 00:30:27,900
those situations be I will say

00:30:26,430 --> 00:30:29,490
inheritance does make more sense with

00:30:27,900 --> 00:30:32,040
rolls when you have a pre-existing

00:30:29,490 --> 00:30:33,690
system where the inheritance is already

00:30:32,040 --> 00:30:36,230
placed and that is the mechanism for

00:30:33,690 --> 00:30:38,280
using that system I would not suggest

00:30:36,230 --> 00:30:41,070
refactoring the system just because you

00:30:38,280 --> 00:30:42,870
feel more comfortable with rolls dbx

00:30:41,070 --> 00:30:44,190
class is a great example I've often

00:30:42,870 --> 00:30:45,900
thought it might be interesting to try

00:30:44,190 --> 00:30:47,820
and write something which would you know

00:30:45,900 --> 00:30:50,220
encapsulate that and turn it into a roll

00:30:47,820 --> 00:30:52,520
or do some fancy delegation but no

00:30:50,220 --> 00:30:55,170
inheritance is how it's designed to work

00:30:52,520 --> 00:30:57,360
some people would argue that an abstract

00:30:55,170 --> 00:30:59,340
base class you know you have a vehicle

00:30:57,360 --> 00:31:03,060
and you have a car subclass in a truck

00:30:59,340 --> 00:31:05,580
subclass or whatever some people really

00:31:03,060 --> 00:31:08,280
like that style I don't I put that into

00:31:05,580 --> 00:31:11,610
a role for the same reason that I would

00:31:08,280 --> 00:31:13,170
put a person object into a role even

00:31:11,610 --> 00:31:15,450
though I might have a subclass of

00:31:13,170 --> 00:31:19,110
employee in a subclass of manager or

00:31:15,450 --> 00:31:21,180
whatever simply because you have various

00:31:19,110 --> 00:31:22,650
things where you don't necessarily know

00:31:21,180 --> 00:31:26,100
how they might be shared across

00:31:22,650 --> 00:31:27,900
different objects and I really like the

00:31:26,100 --> 00:31:29,610
ability to assemble things as tinker

00:31:27,900 --> 00:31:31,890
toys and say this is the

00:31:29,610 --> 00:31:35,420
responsibilities I need put together all

00:31:31,890 --> 00:31:38,000
of these components avella it works

00:31:35,420 --> 00:31:39,350
but that's it's kind of a radical view

00:31:38,000 --> 00:31:40,700
there I know there are a few people

00:31:39,350 --> 00:31:42,170
going out there and building systems

00:31:40,700 --> 00:31:44,810
like this and they like that where they

00:31:42,170 --> 00:31:47,570
use no inheritance I think I'm in the

00:31:44,810 --> 00:32:00,920
minority with that so take me with a

00:31:47,570 --> 00:32:04,100
grain of salt yes he's got a good point

00:32:00,920 --> 00:32:05,780
attributes in say moose when they say is

00:32:04,100 --> 00:32:07,340
a date time and you want to pass in

00:32:05,780 --> 00:32:08,750
something that's not a date time you had

00:32:07,340 --> 00:32:13,610
better pass in something that inherits

00:32:08,750 --> 00:32:20,480
from daytime and good luck on that yes

00:32:13,610 --> 00:32:24,050
we got a few minutes left yes rolls a

00:32:20,480 --> 00:32:28,100
new there's a few issues with roles in

00:32:24,050 --> 00:32:31,370
mu on for philosophical reasons they've

00:32:28,100 --> 00:32:32,870
decided to I believe remove the alias

00:32:31,370 --> 00:32:35,990
and excludes they don't particularly

00:32:32,870 --> 00:32:37,850
feel comfortable with them also I've

00:32:35,990 --> 00:32:39,620
submitted some bug's for roles and mu

00:32:37,850 --> 00:32:41,360
because when i try to use mu and

00:32:39,620 --> 00:32:45,200
production systems i wound up with

00:32:41,360 --> 00:32:48,260
ordering issues with how i consume mu

00:32:45,200 --> 00:32:49,370
roles and i have to look at my bugs to

00:32:48,260 --> 00:32:50,570
remember exactly what they are but

00:32:49,370 --> 00:32:54,170
they're actually pretty hard things to

00:32:50,570 --> 00:32:56,150
resolve so I don't feel I think moves

00:32:54,170 --> 00:32:57,650
great but I don't feel entirely

00:32:56,150 --> 00:33:00,470
comfortable how its roles I've actually

00:32:57,650 --> 00:33:03,230
been implemented so go look at the bug

00:33:00,470 --> 00:33:10,490
q4 mu and that'll give you some ideas

00:33:03,230 --> 00:33:12,760
what's going on there I have not there's

00:33:10,490 --> 00:33:12,760
another one

00:33:13,530 --> 00:33:22,560
yes what about moves mos can you have

00:33:17,800 --> 00:33:22,560
unicode letters and the package names I

00:33:26,760 --> 00:33:33,640
don't know what I'm waiting for the

00:33:28,810 --> 00:33:40,900
infinity symbol in moose and any other

00:33:33,640 --> 00:33:44,160
questions I think that's it thank you

00:33:40,900 --> 00:33:44,160

YouTube URL: https://www.youtube.com/watch?v=cjoWu4eq1Tw


