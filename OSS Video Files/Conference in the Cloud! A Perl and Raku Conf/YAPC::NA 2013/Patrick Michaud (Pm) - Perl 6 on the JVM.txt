Title: Patrick Michaud (Pm) - Perl 6 on the JVM
Publication date: 2013-08-20
Playlist: YAPC::NA 2013
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:07,020
good morning everybody thank you for

00:00:03,000 --> 00:00:09,150
coming on out my name is Patrick and I

00:00:07,020 --> 00:00:11,580
will be talking about Pearl six on

00:00:09,150 --> 00:00:16,470
supposed to be Perl 6 on the JVM but it

00:00:11,580 --> 00:00:18,119
could be parole on the JVM and so on and

00:00:16,470 --> 00:00:19,770
to kind of give a little bit of a

00:00:18,119 --> 00:00:21,810
history about parole on the JVM where it

00:00:19,770 --> 00:00:26,730
stands now where we would like to see it

00:00:21,810 --> 00:00:30,029
go ok so this did not work this out

00:00:26,730 --> 00:00:32,009
isn't that active guy there we go all

00:00:30,029 --> 00:00:38,100
right so we'll start from the beginning

00:00:32,009 --> 00:00:40,739
of Perl 6 on the JVM for me pearl

00:00:38,100 --> 00:00:43,079
putting pearl on JVM was always kind of

00:00:40,739 --> 00:00:44,640
a thought because we have parrot and

00:00:43,079 --> 00:00:47,160
we'd been doing pearl sticks on parrot

00:00:44,640 --> 00:00:48,360
sorts of things and so it's always

00:00:47,160 --> 00:00:50,660
something was kind of thought about Bose

00:00:48,360 --> 00:00:53,219
now there's never really serious until

00:00:50,660 --> 00:00:55,680
summer of two thousand nine at yapchi 10

00:00:53,219 --> 00:00:58,170
in Pittsburgh at the end of the

00:00:55,680 --> 00:00:59,910
conference and we had a parent workshop

00:00:58,170 --> 00:01:01,170
at that conference and a variety by the

00:00:59,910 --> 00:01:03,600
things and at the end of the conference

00:01:01,170 --> 00:01:11,040
I happen to be on the bus going to the

00:01:03,600 --> 00:01:13,650
airport and where's my oh yes okay so it

00:01:11,040 --> 00:01:15,600
random parrot Riku doze it existed in

00:01:13,650 --> 00:01:18,119
2009 it would run on the parrot grammar

00:01:15,600 --> 00:01:20,759
engine it's written in pier which is the

00:01:18,119 --> 00:01:22,110
parrot intermediate representation we

00:01:20,759 --> 00:01:24,780
had this thing called the parrot

00:01:22,110 --> 00:01:26,040
compiler toolkit an early form of not

00:01:24,780 --> 00:01:28,259
quite pearl which you've heard a lot

00:01:26,040 --> 00:01:30,450
about so I'm going to give a bigger

00:01:28,259 --> 00:01:32,340
discussion about it today but we didn't

00:01:30,450 --> 00:01:34,829
have proto reg X's and if you don't know

00:01:32,340 --> 00:01:36,689
what a proto reg ex is that's fine you

00:01:34,829 --> 00:01:38,280
don't need to know what it is none of us

00:01:36,689 --> 00:01:43,220
knew what it was until four years ago

00:01:38,280 --> 00:01:45,630
either so so five now five years now but

00:01:43,220 --> 00:01:47,159
it's a new thing that got added which

00:01:45,630 --> 00:01:48,600
meant that I would have to go and

00:01:47,159 --> 00:01:52,350
rewrite the grammar engine for the

00:01:48,600 --> 00:01:54,540
fourth time so as I was on the bus I

00:01:52,350 --> 00:01:58,259
happen to be writing I was joined by

00:01:54,540 --> 00:02:00,119
Jesse Benson Oprah Oprah and he was at

00:01:58,259 --> 00:02:01,710
the time or he had just finished being

00:02:00,119 --> 00:02:03,750
what was called the Perl 6 project

00:02:01,710 --> 00:02:06,270
manager and so we're riding on the bus

00:02:03,750 --> 00:02:08,340
together and he says to me gives me a

00:02:06,270 --> 00:02:10,349
couple of observations that that he had

00:02:08,340 --> 00:02:12,510
made that he thought I should know is

00:02:10,349 --> 00:02:14,159
the pearls this guy he said all

00:02:12,510 --> 00:02:16,739
of the major scripting languages now

00:02:14,159 --> 00:02:20,610
have implementations on JVM and.net

00:02:16,739 --> 00:02:22,680
except for pearl and he said that's not

00:02:20,610 --> 00:02:25,980
exactly a good situation for us as a

00:02:22,680 --> 00:02:28,079
community to be in that we're all there

00:02:25,980 --> 00:02:30,540
and then he went one step further he

00:02:28,079 --> 00:02:33,780
said the only real way that we will ever

00:02:30,540 --> 00:02:36,690
get pearl onto the JVM or on to.net is

00:02:33,780 --> 00:02:39,540
through Perl 6 he didn't see that it was

00:02:36,690 --> 00:02:42,689
feasible or likely to happen on pro 5 so

00:02:39,540 --> 00:02:46,140
his underlying message to me was it's on

00:02:42,689 --> 00:02:49,409
you to get us onto the JVM if it's going

00:02:46,140 --> 00:02:52,680
to happen or on to.net or anything like

00:02:49,409 --> 00:02:54,959
that and that was pretty profound for me

00:02:52,680 --> 00:02:57,780
I had I hadn't taken it quite to that

00:02:54,959 --> 00:03:00,510
level of thinking yeah and I said well

00:02:57,780 --> 00:03:06,359
okay so somebody's got to write Perl 6

00:03:00,510 --> 00:03:09,000
for the JVM so who's going to do that so

00:03:06,359 --> 00:03:10,889
we thought about some more there's some

00:03:09,000 --> 00:03:12,780
other things that come along you'll see

00:03:10,889 --> 00:03:15,629
kind of the evolution of the thinking to

00:03:12,780 --> 00:03:18,780
get to that but pearl has long had a

00:03:15,629 --> 00:03:20,609
tradition of run everywhere you know you

00:03:18,780 --> 00:03:22,859
could get pearl running on VMS you can

00:03:20,609 --> 00:03:25,410
get run pearl running on lots and lots

00:03:22,859 --> 00:03:33,000
of different platforms i believe it even

00:03:25,410 --> 00:03:35,849
ran on Eunice correct and so it has this

00:03:33,000 --> 00:03:37,109
tradition but our modern day you know we

00:03:35,849 --> 00:03:39,359
used to always think of a platform is

00:03:37,109 --> 00:03:42,569
being operating system you know linux HP

00:03:39,359 --> 00:03:44,430
ux windows toss those kind of things but

00:03:42,569 --> 00:03:46,230
nowadays our platforms are just as

00:03:44,430 --> 00:03:48,720
easily virtual machines as they are

00:03:46,230 --> 00:03:50,489
operating systems the for many devices

00:03:48,720 --> 00:03:53,280
the virtual machine is the operating

00:03:50,489 --> 00:03:55,530
system and of course if you don't have

00:03:53,280 --> 00:03:56,699
pearl running on those other virtual

00:03:55,530 --> 00:03:59,040
machine environments then you're

00:03:56,699 --> 00:04:01,440
starting to miss large sections of the

00:03:59,040 --> 00:04:03,480
computing and information community that

00:04:01,440 --> 00:04:05,669
could be benefiting from pearl and so it

00:04:03,480 --> 00:04:08,699
doesn't reach those and so you know this

00:04:05,669 --> 00:04:12,269
is a way to try and get to that later in

00:04:08,699 --> 00:04:15,120
2009 we initiated the recruit estar

00:04:12,269 --> 00:04:17,099
effort so recruit a star was to be a

00:04:15,120 --> 00:04:19,889
distribution of pearl six you know

00:04:17,099 --> 00:04:21,510
something that would start to be moving

00:04:19,889 --> 00:04:23,159
beyond just we're trying to make it work

00:04:21,510 --> 00:04:25,389
too it's something that people could

00:04:23,159 --> 00:04:26,919
actually use into

00:04:25,389 --> 00:04:28,479
thousand nine that meant rewriting the

00:04:26,919 --> 00:04:31,210
grammar engine so that it would support

00:04:28,479 --> 00:04:37,020
proto reg axes and a lot of other pieces

00:04:31,210 --> 00:04:40,509
had to be done we in the process in 2009

00:04:37,020 --> 00:04:43,810
we combined the grammar engine in n QP

00:04:40,509 --> 00:04:45,669
into n QP RX so the the piece of the

00:04:43,810 --> 00:04:47,080
story that's here is as i mentioned this

00:04:45,669 --> 00:04:48,819
was going to be about the third or

00:04:47,080 --> 00:04:51,999
fourth rewrite of the grammar engine

00:04:48,819 --> 00:04:53,439
that i had done you know they have often

00:04:51,999 --> 00:04:54,969
these things to say have you written a

00:04:53,439 --> 00:04:59,229
regular expression engine and i've

00:04:54,969 --> 00:05:00,639
written several now and usually what

00:04:59,229 --> 00:05:02,289
would happen is I'd write in regular

00:05:00,639 --> 00:05:04,000
expression engine we'd start using it

00:05:02,289 --> 00:05:06,310
and then we discover there's something

00:05:04,000 --> 00:05:08,560
about the language we don't like and so

00:05:06,310 --> 00:05:11,080
we need to add some new feature into

00:05:08,560 --> 00:05:13,029
that engine to make it work which

00:05:11,080 --> 00:05:15,520
basically meant rewriting it at the core

00:05:13,029 --> 00:05:18,520
so in late two thousand nine I was tired

00:05:15,520 --> 00:05:21,069
of doing this and so I said well what's

00:05:18,520 --> 00:05:22,689
the way that I can get so that when i

00:05:21,069 --> 00:05:24,550
write this regular expression engine it

00:05:22,689 --> 00:05:27,189
will become the standard the answer was

00:05:24,550 --> 00:05:29,379
will rewrite it in perl 6 instead of in

00:05:27,189 --> 00:05:31,060
peer and then I said oh well then I'll

00:05:29,379 --> 00:05:32,830
just rewrite it in an QP which I'm gonna

00:05:31,060 --> 00:05:35,259
explain here a little bit but the

00:05:32,830 --> 00:05:37,120
evolution became the n QP was going to

00:05:35,259 --> 00:05:38,560
be more than just a language for writing

00:05:37,120 --> 00:05:39,939
the compiler portion that was actually

00:05:38,560 --> 00:05:41,680
going to be the language for writing the

00:05:39,939 --> 00:05:44,139
regular expression engine that worked

00:05:41,680 --> 00:05:46,089
out pretty well so let's talk about what

00:05:44,139 --> 00:05:48,879
n QP is because before you can talk

00:05:46,089 --> 00:05:50,800
about rokudo or pearl on the JVM for the

00:05:48,879 --> 00:05:52,599
work that we're doing we have to talk

00:05:50,800 --> 00:05:56,560
about what n QP is so it stands for not

00:05:52,599 --> 00:05:58,360
quite pearl and we'll look at how it

00:05:56,560 --> 00:06:00,580
evolved so first of all we have some

00:05:58,360 --> 00:06:02,169
perl 6 code and we want to be able to

00:06:00,580 --> 00:06:03,610
run it on something like parrot or

00:06:02,169 --> 00:06:05,889
virtual machine and this is of course

00:06:03,610 --> 00:06:08,259
where it evolved from that's a long

00:06:05,889 --> 00:06:10,419
distance wait there's i thought there

00:06:08,259 --> 00:06:14,139
was a laser on here there is one that's

00:06:10,419 --> 00:06:16,750
not it that's not it we want to get

00:06:14,139 --> 00:06:20,930
there's a long distance

00:06:16,750 --> 00:06:23,090
between pearl 6 and parrot and since

00:06:20,930 --> 00:06:25,130
parents primary programming language was

00:06:23,090 --> 00:06:26,599
peer trying to get from pearl 60 parrot

00:06:25,130 --> 00:06:29,750
through peer we discovered just wasn't

00:06:26,599 --> 00:06:32,000
going to work so there's that long

00:06:29,750 --> 00:06:34,400
distance now of course parrots goal as a

00:06:32,000 --> 00:06:36,199
virtual machine or one of its goals was

00:06:34,400 --> 00:06:38,660
to be able to run many many different

00:06:36,199 --> 00:06:42,050
languages so not just pearl six but also

00:06:38,660 --> 00:06:44,419
TCL pearl five Python Ruby and all sorts

00:06:42,050 --> 00:06:46,220
of that and what we discovered is going

00:06:44,419 --> 00:06:47,810
going through the process is that all of

00:06:46,220 --> 00:06:50,150
these languages have essentially the

00:06:47,810 --> 00:06:51,410
same steps or the same sorts of pieces

00:06:50,150 --> 00:06:53,389
that they need to build and they all

00:06:51,410 --> 00:06:55,580
have our having to make this long jump

00:06:53,389 --> 00:06:58,190
between their language specification and

00:06:55,580 --> 00:06:59,930
the other so they all needed a parser of

00:06:58,190 --> 00:07:01,970
some sort they needed an abstract syntax

00:06:59,930 --> 00:07:03,770
tree representation they need to do code

00:07:01,970 --> 00:07:05,479
generation and they would need some sort

00:07:03,770 --> 00:07:09,680
of object system underneath that was

00:07:05,479 --> 00:07:12,860
usable so instead of having them all use

00:07:09,680 --> 00:07:14,199
that one jump the goal of n QP was to be

00:07:12,860 --> 00:07:16,460
something that would sit in the middle

00:07:14,199 --> 00:07:18,770
that would provide a higher level

00:07:16,460 --> 00:07:20,840
abstraction for compiler writers to be

00:07:18,770 --> 00:07:23,419
able to work and so this is where r

00:07:20,840 --> 00:07:25,070
akuto came into came in two plays that

00:07:23,419 --> 00:07:26,659
instead of trying to go straight to pair

00:07:25,070 --> 00:07:28,580
it we now go to this intermediate

00:07:26,659 --> 00:07:31,820
representation this abstraction level

00:07:28,580 --> 00:07:34,310
called n QP and what n QP has evolved

00:07:31,820 --> 00:07:36,979
into is that where it used to be just

00:07:34,310 --> 00:07:39,620
kind of a syntactic sugar for parents

00:07:36,979 --> 00:07:42,590
subroutines it's now its own virtual

00:07:39,620 --> 00:07:44,389
machine environment it provides when you

00:07:42,590 --> 00:07:46,759
write an N QP program it's a virtual

00:07:44,389 --> 00:07:49,460
machine environment and a language that

00:07:46,759 --> 00:07:51,229
gives you parsers it gives you Perl 6

00:07:49,460 --> 00:07:53,659
grammars it gives you an abstract syntax

00:07:51,229 --> 00:07:55,430
tree representation gives you an object

00:07:53,659 --> 00:07:58,699
metamodel it gives you the ability to do

00:07:55,430 --> 00:08:03,020
code generation and so this is where r

00:07:58,699 --> 00:08:05,180
akuto essentially sits today is that it

00:08:03,020 --> 00:08:07,009
compiles down to n QP and then n QP has

00:08:05,180 --> 00:08:09,590
the tools that it to be able to cojan

00:08:07,009 --> 00:08:12,860
the rest of the way to pair it but once

00:08:09,590 --> 00:08:16,070
we're able to do that and one of the

00:08:12,860 --> 00:08:17,659
here's the key features you know pearl n

00:08:16,070 --> 00:08:19,699
QP is written using Perl 6 in tax

00:08:17,659 --> 00:08:24,199
because Perl 6 in taxes the greatest

00:08:19,699 --> 00:08:27,289
syntax known to any of us small-time a

00:08:24,199 --> 00:08:28,940
small runtime footprint fewer no

00:08:27,289 --> 00:08:29,900
built-in functions it's really designed

00:08:28,940 --> 00:08:31,370
to be a minimal

00:08:29,900 --> 00:08:33,919
language just what you need in order to

00:08:31,370 --> 00:08:36,260
get a larger thing running on top of it

00:08:33,919 --> 00:08:38,000
it has an object metamodel system it has

00:08:36,260 --> 00:08:40,010
a regular expression engine has an

00:08:38,000 --> 00:08:41,690
abstract syntax tree which we call cast

00:08:40,010 --> 00:08:44,150
if you want to know where that comes

00:08:41,690 --> 00:08:48,500
from to me the q is the big character in

00:08:44,150 --> 00:08:52,760
n QP so it's a quite an abstract syntax

00:08:48,500 --> 00:08:54,380
tree it has some base classes if you're

00:08:52,760 --> 00:08:55,970
writing a compiler there's some base

00:08:54,380 --> 00:08:57,020
classes so that somebody writing a

00:08:55,970 --> 00:08:59,360
compiler won't have to start from

00:08:57,020 --> 00:09:01,250
scratch it has the ability to natively

00:08:59,360 --> 00:09:04,520
call in to see when you're running on

00:09:01,250 --> 00:09:06,170
parrot and a key feature for this

00:09:04,520 --> 00:09:09,709
discussion is that it is self hosted

00:09:06,170 --> 00:09:13,100
that the majority of the n QP system is

00:09:09,709 --> 00:09:15,020
written using n QP and that has some

00:09:13,100 --> 00:09:17,060
really important characteristics so as

00:09:15,020 --> 00:09:18,830
we go back to this picture you can see

00:09:17,060 --> 00:09:20,420
that n QP have self-hosting and what

00:09:18,830 --> 00:09:24,410
that means is that since most of the

00:09:20,420 --> 00:09:29,120
source is written already in n QP if you

00:09:24,410 --> 00:09:31,520
change the code gen part of n QP you can

00:09:29,120 --> 00:09:35,510
use it to compile to another back-end

00:09:31,520 --> 00:09:37,580
such as the JVM so that instead of

00:09:35,510 --> 00:09:39,410
outputting pierre the parrot rip

00:09:37,580 --> 00:09:41,810
intermediate representation it now

00:09:39,410 --> 00:09:44,959
outputs Java classes and then if you can

00:09:41,810 --> 00:09:47,750
get the meta object protocol if you get

00:09:44,959 --> 00:09:53,020
an object system running on the JVM how

00:09:47,750 --> 00:09:59,270
hard was that Jonathan the order of

00:09:53,020 --> 00:10:02,240
months years weeks days oh my gosh order

00:09:59,270 --> 00:10:04,070
of days it's pretty nice because Java

00:10:02,240 --> 00:10:06,920
kind of has an object system already

00:10:04,070 --> 00:10:09,740
built in so you get a lot of things in

00:10:06,920 --> 00:10:12,650
there so if you can get that going then

00:10:09,740 --> 00:10:15,110
all of a sudden n QP is running on the

00:10:12,650 --> 00:10:17,600
JVM and those things that depend on n QP

00:10:15,110 --> 00:10:20,060
or that use n QP to build them will also

00:10:17,600 --> 00:10:22,850
run on the JVM of course we don't plan

00:10:20,060 --> 00:10:26,740
to stop there then go to the CLR there

00:10:22,850 --> 00:10:30,020
is a google Summer of Code grant or

00:10:26,740 --> 00:10:33,709
project that will be adding a back-end

00:10:30,020 --> 00:10:35,510
to go from n QP to JavaScript so that we

00:10:33,709 --> 00:10:37,190
would eventually be able to run Perl 6

00:10:35,510 --> 00:10:38,889
on JavaScript if everything works out

00:10:37,190 --> 00:10:41,589
don't know that but

00:10:38,889 --> 00:10:45,040
it's a nice it's a good project as it

00:10:41,589 --> 00:10:47,079
has good chances of succeeding so this

00:10:45,040 --> 00:10:51,549
is how we can get to a multi back-end

00:10:47,079 --> 00:10:54,189
strategy now looking at n QP and what

00:10:51,549 --> 00:10:56,109
the goals for n QP are we also want to

00:10:54,189 --> 00:10:58,389
be able to go back to some of the

00:10:56,109 --> 00:11:00,489
original idea of being able to run all

00:10:58,389 --> 00:11:02,169
of these languages as well that if you

00:11:00,489 --> 00:11:05,139
wrote your compiler your language

00:11:02,169 --> 00:11:07,209
translator in the n QP system and if the

00:11:05,139 --> 00:11:08,529
n QP is good enough to do Perl 6 it

00:11:07,209 --> 00:11:11,499
ought to be good enough to do some other

00:11:08,529 --> 00:11:14,169
languages then you would be able to

00:11:11,499 --> 00:11:16,480
write a compiler once that would run on

00:11:14,169 --> 00:11:19,209
n QP and then would be available to run

00:11:16,480 --> 00:11:20,949
on the JVM unpaired on CL r and possibly

00:11:19,209 --> 00:11:22,269
even interop operate with other

00:11:20,949 --> 00:11:24,279
languages running on that particular

00:11:22,269 --> 00:11:27,999
system so that's kind of the vision of

00:11:24,279 --> 00:11:30,939
where n QP is trying to go any questions

00:11:27,999 --> 00:11:46,689
so far I'll stop for questions at

00:11:30,939 --> 00:11:51,579
different places Jim yes but in in a

00:11:46,689 --> 00:11:53,799
word in in 2009-2010 as I was trying to

00:11:51,579 --> 00:11:57,579
think of how I how I can I make sure

00:11:53,799 --> 00:12:00,399
that Rikuo remains relevant and stuff

00:11:57,579 --> 00:12:02,259
and I mean essentially came down to

00:12:00,399 --> 00:12:04,329
somebody's going to put Perl 6 on the

00:12:02,259 --> 00:12:07,449
JVM I don't want to write another

00:12:04,329 --> 00:12:11,019
compiler from scratch right and I don't

00:12:07,449 --> 00:12:13,360
want i want rokudo to be that compiler

00:12:11,019 --> 00:12:15,009
that can be on the JVM and so it's like

00:12:13,360 --> 00:12:17,619
okay well this kind of just elevates

00:12:15,009 --> 00:12:20,489
exactly and competed that then I had

00:12:17,619 --> 00:12:20,489
another question here

00:12:32,210 --> 00:12:41,790
no probably probably nobody's point they

00:12:38,820 --> 00:12:44,840
see that side of me with the recent

00:12:41,790 --> 00:12:47,430
announcement yeah and when I went when I

00:12:44,840 --> 00:12:50,070
throughout this presentation I should

00:12:47,430 --> 00:12:56,270
note that much of this work has occurred

00:12:50,070 --> 00:12:59,490
within the last two months right right

00:12:56,270 --> 00:13:01,530
so and if you go and when I'm talking

00:12:59,490 --> 00:13:03,330
about Pearl 6 of course n QP is not all

00:13:01,530 --> 00:13:06,830
of pearl six it's a really minimal

00:13:03,330 --> 00:13:09,630
subset rokudo which is the fuller Perl 6

00:13:06,830 --> 00:13:11,100
just barely runs on the JVM at this

00:13:09,630 --> 00:13:13,620
point or maybe it's more than just

00:13:11,100 --> 00:13:14,850
barely but not much more but by as

00:13:13,620 --> 00:13:16,590
you'll see later in the talk there'll be

00:13:14,850 --> 00:13:18,930
more but yes I believe there should be

00:13:16,590 --> 00:13:21,090
another column there that distinguishes

00:13:18,930 --> 00:13:23,520
rokudo running on parrot from recruit Oh

00:13:21,090 --> 00:13:29,130
running on JVM and then I had one from

00:13:23,520 --> 00:13:31,950
Bruce and then I'll get JT yes it's down

00:13:29,130 --> 00:13:34,380
here at the bottom bore vm would be

00:13:31,950 --> 00:13:36,690
where these dots are more vm for those

00:13:34,380 --> 00:13:42,510
who hadn't heard is a new virtual

00:13:36,690 --> 00:13:44,580
machine whose single target is n QP it's

00:13:42,510 --> 00:13:46,410
a virtual machine that takes what we had

00:13:44,580 --> 00:13:48,780
from n QP and says i'm going to

00:13:46,410 --> 00:14:02,220
implement that efficiently JT you had a

00:13:48,780 --> 00:14:04,110
question so the question is does parrot

00:14:02,220 --> 00:14:09,900
still have a place in this it does for

00:14:04,110 --> 00:14:12,300
us a the inn in this particular way if

00:14:09,900 --> 00:14:15,090
we decided that we needed to experiment

00:14:12,300 --> 00:14:18,540
with a feature that is not natively

00:14:15,090 --> 00:14:20,520
available in the JVM or the clr that we

00:14:18,540 --> 00:14:22,350
wanted to try some new things we'd never

00:14:20,520 --> 00:14:24,720
be able to get those into those virtual

00:14:22,350 --> 00:14:26,670
machines parrots an open virtual machine

00:14:24,720 --> 00:14:28,620
we can make modifications we can try

00:14:26,670 --> 00:14:31,530
things more easily at the virtual

00:14:28,620 --> 00:14:34,290
machine level as more vm becomes

00:14:31,530 --> 00:14:37,360
available then that may be less relevant

00:14:34,290 --> 00:14:41,260
it may be that we can then try them in

00:14:37,360 --> 00:14:42,820
or vm and and i'll come back to that

00:14:41,260 --> 00:15:04,209
point a little bit more and then I had

00:14:42,820 --> 00:15:06,880
another question here yes right right so

00:15:04,209 --> 00:15:08,320
the question was for it was about where

00:15:06,880 --> 00:15:09,430
the comment was about threading being

00:15:08,320 --> 00:15:10,959
available already in these other

00:15:09,430 --> 00:15:12,070
platforms that aren't available in

00:15:10,959 --> 00:15:16,510
parrot and I have a slide on that a

00:15:12,070 --> 00:15:18,640
little bit so so we'll get to there okay

00:15:16,510 --> 00:15:20,490
so a little bit about n QP compiler

00:15:18,640 --> 00:15:24,490
basics there are a variety of pieces

00:15:20,490 --> 00:15:26,800
that we use to create a compiler in n QP

00:15:24,490 --> 00:15:28,930
so we have a grammar for parsing the

00:15:26,800 --> 00:15:31,329
source code it's a Perl 6 grammar so you

00:15:28,930 --> 00:15:33,220
get pearl six regular expressions rules

00:15:31,329 --> 00:15:35,110
and all of those things attached to the

00:15:33,220 --> 00:15:36,970
grammar or set of actions and the

00:15:35,110 --> 00:15:40,209
actions are the things that are done as

00:15:36,970 --> 00:15:43,390
the parse is taking place if you had

00:15:40,209 --> 00:15:44,709
like traditional compiler courses then

00:15:43,390 --> 00:15:47,230
or at least when I went and did a

00:15:44,709 --> 00:15:48,490
compiler course in college you know they

00:15:47,230 --> 00:15:49,959
always talked about you create a parse

00:15:48,490 --> 00:15:52,360
tree and then you traverse the parse

00:15:49,959 --> 00:15:53,829
tree to produce this semantic tree and

00:15:52,360 --> 00:15:56,769
then you go and use that to do codegen

00:15:53,829 --> 00:15:58,300
you can't do that in Perl in Perl while

00:15:56,769 --> 00:16:00,820
you're parsing you're doing stuff you're

00:15:58,300 --> 00:16:03,040
actually executing things things happen

00:16:00,820 --> 00:16:05,410
at compile time things happen at parse

00:16:03,040 --> 00:16:08,079
time when you're dealing with pearls so

00:16:05,410 --> 00:16:10,529
the actions are part of the parse if

00:16:08,079 --> 00:16:14,709
you've ever watched computer rikku doe

00:16:10,529 --> 00:16:17,140
compile and it prints out the stages as

00:16:14,709 --> 00:16:18,760
it's compiling like the setting then

00:16:17,140 --> 00:16:21,459
you'll notice the par stage takes

00:16:18,760 --> 00:16:23,290
forever but the abstract syntax tree

00:16:21,459 --> 00:16:24,850
stage takes zero seconds and you might

00:16:23,290 --> 00:16:26,949
wonder why is that and the answer is

00:16:24,850 --> 00:16:29,920
because it did all the apps abstract

00:16:26,949 --> 00:16:31,449
syntax tree part as it was parsing so

00:16:29,920 --> 00:16:35,110
that's kind of it doesn't fit into those

00:16:31,449 --> 00:16:37,630
phases really well the result that we

00:16:35,110 --> 00:16:39,370
expect we expect to results from doing

00:16:37,630 --> 00:16:41,199
the actions one of them is the abstract

00:16:39,370 --> 00:16:43,750
syntax tree and that's just a tree of

00:16:41,199 --> 00:16:46,810
nodes representing the operations to be

00:16:43,750 --> 00:16:48,010
performed but we also have this thing

00:16:46,810 --> 00:16:50,350
that's called the world

00:16:48,010 --> 00:16:53,530
and the world is the already compiled

00:16:50,350 --> 00:16:55,600
pieces that the compiler did in the

00:16:53,530 --> 00:16:57,130
process of doing the parson the

00:16:55,600 --> 00:16:59,710
compilation and building the abstract

00:16:57,130 --> 00:17:01,810
syntax tree again you know we have begin

00:16:59,710 --> 00:17:03,850
blocks we have things that happen at

00:17:01,810 --> 00:17:05,770
parse time that compile into executable

00:17:03,850 --> 00:17:07,480
code and we've got to keep that around

00:17:05,770 --> 00:17:09,630
somewhere so there's a serialization

00:17:07,480 --> 00:17:12,820
format and that's what the world does

00:17:09,630 --> 00:17:14,500
once you have all of that then you can

00:17:12,820 --> 00:17:16,240
take the abstract syntax tree nodes and

00:17:14,500 --> 00:17:18,520
you can generate low-level machine code

00:17:16,240 --> 00:17:21,220
so this is actually put into two parts

00:17:18,520 --> 00:17:22,449
we talk in the n QP world about the

00:17:21,220 --> 00:17:24,850
front-end compiler in the backend

00:17:22,449 --> 00:17:30,310
compiler and going back to my previous

00:17:24,850 --> 00:17:32,080
slide if I can get there right so as far

00:17:30,310 --> 00:17:34,000
as n QP is concerned the front-end

00:17:32,080 --> 00:17:36,220
compiler is the part that takes all of

00:17:34,000 --> 00:17:38,980
the languages at the top and gets them

00:17:36,220 --> 00:17:40,750
down to the the cochin and then the back

00:17:38,980 --> 00:17:43,420
end is the part that gets it from the

00:17:40,750 --> 00:17:46,810
from the AST and those parts to your

00:17:43,420 --> 00:17:49,390
specific virtual machine environment so

00:17:46,810 --> 00:17:51,460
a lot of the work a lot of the work that

00:17:49,390 --> 00:17:53,680
was done on n QP I helped prototypes

00:17:51,460 --> 00:17:55,780
back out and things like that much of

00:17:53,680 --> 00:18:00,340
the rest of this talk is me to surfing

00:17:55,780 --> 00:18:02,020
Jonathan's work for a talk so we'll just

00:18:00,340 --> 00:18:04,270
kind of identify some of the pieces here

00:18:02,020 --> 00:18:05,560
that Jonathan's done so Jonathan of

00:18:04,270 --> 00:18:07,690
course likes to tell the story so

00:18:05,560 --> 00:18:09,370
repeated that he got started in all of

00:18:07,690 --> 00:18:14,500
this with junctions way back in what

00:18:09,370 --> 00:18:17,290
2007 and it starts with started with

00:18:14,500 --> 00:18:18,970
Duncan yeah yeah exactly so it started

00:18:17,290 --> 00:18:20,530
with junctions and he discovered that oh

00:18:18,970 --> 00:18:22,060
if you really want to do junctions

00:18:20,530 --> 00:18:23,290
correctly you need to have multi

00:18:22,060 --> 00:18:25,210
dispatch so he wrote the multi

00:18:23,290 --> 00:18:26,590
dispatcher for perl 6 and then

00:18:25,210 --> 00:18:27,850
discovered well if you need to do that

00:18:26,590 --> 00:18:30,040
you're really going to have to have an

00:18:27,850 --> 00:18:31,780
object meta meta object protocol to be

00:18:30,040 --> 00:18:34,120
able to do the dispatch correctly so i

00:18:31,780 --> 00:18:36,610
ended up writing 6 model in order to be

00:18:34,120 --> 00:18:38,410
able to support that but in order to do

00:18:36,610 --> 00:18:41,440
the pre compilation correctly and get

00:18:38,410 --> 00:18:42,790
all of the meta object protocol stuff

00:18:41,440 --> 00:18:44,410
you have to have serialization in this

00:18:42,790 --> 00:18:47,560
visualization so he ended up doing that

00:18:44,410 --> 00:18:49,360
as part of an QP that led directly to n

00:18:47,560 --> 00:18:52,240
QP JVM which is kind of what i'm talking

00:18:49,360 --> 00:18:54,280
about today of course that led to more

00:18:52,240 --> 00:18:56,980
vm which was announced this last week or

00:18:54,280 --> 00:18:58,960
revealed this last week which is a

00:18:56,980 --> 00:18:59,389
virtual machine specifically designed

00:18:58,960 --> 00:19:01,729
for that

00:18:59,389 --> 00:19:03,469
and along the way Jonathan also did a

00:19:01,729 --> 00:19:14,450
recruiter debugger a grammar debuggers

00:19:03,469 --> 00:19:18,709
novel I and blitz cots so so I'm talking

00:19:14,450 --> 00:19:28,029
today about this piece which encompasses

00:19:18,709 --> 00:19:30,409
a lot of the other pieces I know so

00:19:28,029 --> 00:19:32,659
let's look at pearl six as its

00:19:30,409 --> 00:19:35,570
implemented by rokudo okay internally

00:19:32,659 --> 00:19:37,099
the compiler has these parts which I

00:19:35,570 --> 00:19:38,749
described in text before but we're going

00:19:37,099 --> 00:19:40,190
to kind of give it graphically and this

00:19:38,749 --> 00:19:43,249
is going to show what's involved in

00:19:40,190 --> 00:19:46,039
creating this n QP multi virtual machine

00:19:43,249 --> 00:19:49,159
environment so along the bottom of this

00:19:46,039 --> 00:19:53,269
there's a graph that has the different

00:19:49,159 --> 00:19:55,309
parts so in ruku tow the compiler itself

00:19:53,269 --> 00:19:57,589
consists of these five things there's a

00:19:55,309 --> 00:19:59,119
grammar that is a Perl 6 grammar the

00:19:57,589 --> 00:20:01,669
thing that we need for parsing Perl 6

00:19:59,119 --> 00:20:04,399
there are the actions the part that take

00:20:01,669 --> 00:20:05,869
the parsing and convert it into the

00:20:04,399 --> 00:20:08,089
abstract syntax tree and the world

00:20:05,869 --> 00:20:09,919
components there is the world itself

00:20:08,089 --> 00:20:13,399
which is the things that were compiled

00:20:09,919 --> 00:20:17,119
and serialized at compile time there's a

00:20:13,399 --> 00:20:20,109
set of meta objects that are the objects

00:20:17,119 --> 00:20:23,059
that define rikuo's object system

00:20:20,109 --> 00:20:24,169
whenever Perl 6 is running and then

00:20:23,059 --> 00:20:25,639
there's a thing that's called a core

00:20:24,169 --> 00:20:27,379
setting and the core setting is all the

00:20:25,639 --> 00:20:29,089
built-in functions that Perl 6

00:20:27,379 --> 00:20:31,039
programmers would typically use so

00:20:29,089 --> 00:20:32,359
that's things like push and pop and you

00:20:31,039 --> 00:20:35,479
know give me the number of elements and

00:20:32,359 --> 00:20:40,039
strings and so forth like that all of

00:20:35,479 --> 00:20:42,679
those are written in perl 6 now the core

00:20:40,039 --> 00:20:44,839
setting is written in pure Perl 6 in

00:20:42,679 --> 00:20:48,079
other words r akuto actually compiles

00:20:44,839 --> 00:20:50,950
its own setting so when the core setting

00:20:48,079 --> 00:20:53,299
is compiled it is a full Perl 6 compiler

00:20:50,950 --> 00:20:55,039
with traits and those kinds of things

00:20:53,299 --> 00:20:58,519
that are they're the ones that are in

00:20:55,039 --> 00:21:00,769
the light green r NQ PS version of Perl

00:20:58,519 --> 00:21:03,979
6 so somebody looking at the code would

00:21:00,769 --> 00:21:05,450
instantly say oh that's Perl 6 code or

00:21:03,979 --> 00:21:06,680
they would say oh that's lying noise if

00:21:05,450 --> 00:21:08,720
they really hated it

00:21:06,680 --> 00:21:10,730
um they would look at it and it's

00:21:08,720 --> 00:21:13,010
instantly recognizable as being Perl 6

00:21:10,730 --> 00:21:15,110
code but it's a minimal form of it there

00:21:13,010 --> 00:21:17,900
are some things that aren't available to

00:21:15,110 --> 00:21:19,850
you when you do that not like assignment

00:21:17,900 --> 00:21:23,510
you can't do assignment it only has

00:21:19,850 --> 00:21:25,610
binding there's no list operators in n

00:21:23,510 --> 00:21:27,560
QP you always have to put your parents

00:21:25,610 --> 00:21:30,650
in place but you do have method calls

00:21:27,560 --> 00:21:34,610
you do have the ability to do regular

00:21:30,650 --> 00:21:37,160
expression matches things like that okay

00:21:34,610 --> 00:21:40,370
so that's what r akudo looks like n QP

00:21:37,160 --> 00:21:41,780
looks much the same but the only

00:21:40,370 --> 00:21:44,630
difference being that its core setting

00:21:41,780 --> 00:21:47,660
of course is written in ink you p and so

00:21:44,630 --> 00:21:49,820
we have an n QP compiler that is written

00:21:47,660 --> 00:21:52,070
almost entirely in n QP that's what it

00:21:49,820 --> 00:21:54,830
means to be self hosted there and so you

00:21:52,070 --> 00:21:57,830
use the n QP compiler to build up all of

00:21:54,830 --> 00:22:00,020
the light green parts of Riku toe and

00:21:57,830 --> 00:22:01,250
then you use the parts that you get

00:22:00,020 --> 00:22:03,110
after doing the light green parts of

00:22:01,250 --> 00:22:05,390
akuto to compile the core setting and

00:22:03,110 --> 00:22:12,290
you have your perl 6 installation ready

00:22:05,390 --> 00:22:15,320
to go so what is n Kewpies abstraction

00:22:12,290 --> 00:22:18,950
layer what is it that n QP provides to

00:22:15,320 --> 00:22:22,100
compiler writers well it first of all it

00:22:18,950 --> 00:22:24,470
provides cast a common abstract syntax

00:22:22,100 --> 00:22:28,160
tree that it expects to be able to

00:22:24,470 --> 00:22:32,420
compile it provides six model which is a

00:22:28,160 --> 00:22:33,980
object meta object photocall it's a

00:22:32,420 --> 00:22:35,600
metal object system so you can build up

00:22:33,980 --> 00:22:38,750
your object system for whatever language

00:22:35,600 --> 00:22:40,490
you need and it provides a set of what

00:22:38,750 --> 00:22:42,380
we call n QP ops they're they're

00:22:40,490 --> 00:22:46,400
primitives they're the primitives that

00:22:42,380 --> 00:22:48,320
are available to a language author such

00:22:46,400 --> 00:22:50,450
as perl 6 or whatever they're primitives

00:22:48,320 --> 00:22:52,580
that are available to that to be able to

00:22:50,450 --> 00:22:53,960
build up your functions and whatever you

00:22:52,580 --> 00:22:57,260
need to do and so there's this nice

00:22:53,960 --> 00:23:02,480
abstraction layer that's there there are

00:22:57,260 --> 00:23:04,850
currently about 470 n QP ups and those

00:23:02,480 --> 00:23:07,850
include things like add two integers add

00:23:04,850 --> 00:23:09,440
two floating point numbers concatenate

00:23:07,850 --> 00:23:11,450
strings some of them very very simple

00:23:09,440 --> 00:23:16,730
some of them are a little bit bigger

00:23:11,450 --> 00:23:18,110
such as do a method call on something

00:23:16,730 --> 00:23:19,940
look up a method

00:23:18,110 --> 00:23:21,410
push something into an aggregate

00:23:19,940 --> 00:23:23,780
structure pop something from an

00:23:21,410 --> 00:23:25,960
aggregate structure and so forth now

00:23:23,780 --> 00:23:29,090
here we see this new color in come in

00:23:25,960 --> 00:23:31,910
when you're wanting to take n QP and put

00:23:29,090 --> 00:23:33,290
it on a new back end such as the jvm the

00:23:31,910 --> 00:23:36,230
pink parts of the part that you're going

00:23:33,290 --> 00:23:38,540
to have to write okay so you have to

00:23:36,230 --> 00:23:39,980
write an implementation of six model for

00:23:38,540 --> 00:23:42,049
whatever your back-end in as we heard

00:23:39,980 --> 00:23:43,850
from Jonathan for somebody with Jonathan

00:23:42,049 --> 00:23:47,780
super human capabilities it takes is on

00:23:43,850 --> 00:23:49,070
the order of days to do that but he's

00:23:47,780 --> 00:23:50,450
not the only person who will be doing

00:23:49,070 --> 00:23:52,130
that because we have other people

00:23:50,450 --> 00:23:55,280
porting to other ones to be able to do

00:23:52,130 --> 00:23:57,169
that and you need to be able to provide

00:23:55,280 --> 00:24:00,080
the n QP ops but those are actually

00:23:57,169 --> 00:24:04,429
pretty straightforward that's not too

00:24:00,080 --> 00:24:07,270
hard to do so then we have the vm

00:24:04,429 --> 00:24:10,309
specific parts this is the back end part

00:24:07,270 --> 00:24:12,919
that's there and so on the back end you

00:24:10,309 --> 00:24:14,690
would want to or you would need to write

00:24:12,919 --> 00:24:16,250
the thing that would convert from the

00:24:14,690 --> 00:24:18,530
abstract syntax tree to whatever

00:24:16,250 --> 00:24:21,970
representation your virtual machine

00:24:18,530 --> 00:24:24,770
wants to have for parrot is called port

00:24:21,970 --> 00:24:27,799
which is pure text I think those what

00:24:24,770 --> 00:24:29,650
stands for translation or Braille pier

00:24:27,799 --> 00:24:32,750
tree because it's a tree form of pure

00:24:29,650 --> 00:24:36,260
right and then you would run it on your

00:24:32,750 --> 00:24:38,870
on your virtual machine so for the Java

00:24:36,260 --> 00:24:41,510
Virtual Machine it's called Jost is that

00:24:38,870 --> 00:24:43,400
right ok so it's called Jost what is it

00:24:41,510 --> 00:24:45,410
I hadn't actually looked at I hadn't

00:24:43,400 --> 00:24:48,650
actually seen jest output is it text or

00:24:45,410 --> 00:24:50,390
is it a tree it's a tree and then does

00:24:48,650 --> 00:25:04,010
it go straight to dot class or does it

00:24:50,390 --> 00:25:06,169
go through a text phone ok ok and then

00:25:04,010 --> 00:25:08,990
would be able to do on run on the JVM

00:25:06,169 --> 00:25:13,850
and as other backends come up then we

00:25:08,990 --> 00:25:18,160
would be able to do those as well so why

00:25:13,850 --> 00:25:20,780
pick the JVM above all of the other ones

00:25:18,160 --> 00:25:23,450
right so of course the first one the one

00:25:20,780 --> 00:25:25,460
that Oprah kind of challenged me with or

00:25:23,450 --> 00:25:28,760
you know mentioned to me way back in

00:25:25,460 --> 00:25:31,580
2009 to bring pearl to the JVM world to

00:25:28,760 --> 00:25:34,289
actually have pearl exist on JV

00:25:31,580 --> 00:25:36,149
another reason for choosing jbm is that

00:25:34,289 --> 00:25:39,480
it's already in a highly optimized

00:25:36,149 --> 00:25:41,460
established virtual machine unlike

00:25:39,480 --> 00:25:45,629
parrot which is what we had been working

00:25:41,460 --> 00:25:47,519
with that parrot needs a lot more

00:25:45,629 --> 00:25:50,009
optimizations it needs a lot more

00:25:47,519 --> 00:25:53,789
maturity to be able to run recruit oh

00:25:50,009 --> 00:25:57,149
well and often it's nice if you have a

00:25:53,789 --> 00:26:00,389
known target that is not likely to

00:25:57,149 --> 00:26:03,750
change very much and JV n represents one

00:26:00,389 --> 00:26:05,370
of those possible targets for us so it

00:26:03,750 --> 00:26:08,129
also means that you start to put a

00:26:05,370 --> 00:26:09,750
constraint in I think in retrospect one

00:26:08,129 --> 00:26:13,470
of the one of the problems we perhaps

00:26:09,750 --> 00:26:15,830
had is that we we had a little too much

00:26:13,470 --> 00:26:17,580
freedom to move things around and

00:26:15,830 --> 00:26:19,679
sometimes you're able to progress

00:26:17,580 --> 00:26:21,120
breasts when you have some constraints

00:26:19,679 --> 00:26:22,830
that you have to work with and figure

00:26:21,120 --> 00:26:24,750
out how to solve problems with them but

00:26:22,830 --> 00:26:26,429
because parrot meant that we kind of had

00:26:24,750 --> 00:26:28,440
a blank slate if we needed to add stuff

00:26:26,429 --> 00:26:30,539
then there were a lot of questions of

00:26:28,440 --> 00:26:32,250
well where will you put this with the

00:26:30,539 --> 00:26:34,620
JVM if we want to change something in

00:26:32,250 --> 00:26:37,080
the JVM it's not likely to happen any

00:26:34,620 --> 00:26:38,580
time soon so we know where we have to

00:26:37,080 --> 00:26:42,059
put things and so some decisions

00:26:38,580 --> 00:26:44,490
becoming easier for you performance is a

00:26:42,059 --> 00:26:46,200
possible benefit of using the JVM and I

00:26:44,490 --> 00:26:48,750
have the question mark there because we

00:26:46,200 --> 00:26:50,850
don't know exactly what the performance

00:26:48,750 --> 00:26:53,009
will look like yet we have some

00:26:50,850 --> 00:26:55,320
preliminary results but that might be

00:26:53,009 --> 00:26:56,879
another reason to do it and then of

00:26:55,320 --> 00:26:58,679
course in bringing pearl to the JVM

00:26:56,879 --> 00:27:00,750
world there are some organizations some

00:26:58,679 --> 00:27:02,429
shops that only will want to deal with

00:27:00,750 --> 00:27:03,779
the JVM you can use any platform that

00:27:02,429 --> 00:27:06,990
you want any language you want as long

00:27:03,779 --> 00:27:09,120
as it's on the JVM and so this is

00:27:06,990 --> 00:27:12,629
another reason that we could look at

00:27:09,120 --> 00:27:14,370
using the JVM there's more benefits so

00:27:12,629 --> 00:27:16,769
as was mentioned earlier from one of the

00:27:14,370 --> 00:27:18,419
comments from the audience jvm already

00:27:16,769 --> 00:27:19,740
has a well-established support for

00:27:18,419 --> 00:27:23,399
threading it's well known as well

00:27:19,740 --> 00:27:26,519
understood it's been studied it's stable

00:27:23,399 --> 00:27:29,879
and one of the areas that is left to be

00:27:26,519 --> 00:27:31,950
explored in the Perl 6 specification and

00:27:29,879 --> 00:27:35,009
in the implementations is how do you do

00:27:31,950 --> 00:27:37,500
threading or threaded operations in an

00:27:35,009 --> 00:27:39,720
implementation of Perl 6 so we kind of

00:27:37,500 --> 00:27:42,450
have some ideas and I have a talk about

00:27:39,720 --> 00:27:44,999
parallel ilysm in Perl 6 tomorrow where

00:27:42,450 --> 00:27:47,519
our traditional answer for

00:27:44,999 --> 00:27:49,379
in pearl sticks has been yeah we like a

00:27:47,519 --> 00:27:50,789
lot of ideas but somebody needs to go

00:27:49,379 --> 00:27:52,289
out and implement some stuff so we can

00:27:50,789 --> 00:27:55,049
pick the best ones and put that in the

00:27:52,289 --> 00:27:56,909
spec but nobody's been able to actually

00:27:55,049 --> 00:27:59,089
implement anything now we have some

00:27:56,909 --> 00:28:01,319
opportunities to do that

00:27:59,089 --> 00:28:03,209
interoperability might be an advantage

00:28:01,319 --> 00:28:05,999
of doing this we may be able to link

00:28:03,209 --> 00:28:08,189
existing libraries Java libraries and

00:28:05,999 --> 00:28:09,929
you'd be able to ask to Java library

00:28:08,189 --> 00:28:14,189
from your perl 6 program that could be

00:28:09,929 --> 00:28:16,169
really cool it might make it available

00:28:14,189 --> 00:28:18,599
even on other platforms like Android of

00:28:16,169 --> 00:28:20,159
course is JVM based platform so we could

00:28:18,599 --> 00:28:21,929
maybe do things with Android and get

00:28:20,159 --> 00:28:25,859
pearl onto an Android system which would

00:28:21,929 --> 00:28:27,749
be really nice another benefit of jb m

00:28:25,859 --> 00:28:29,759
and this is true for any virtual machine

00:28:27,749 --> 00:28:31,439
that we do with this we can better

00:28:29,759 --> 00:28:33,269
understand the speed performance issues

00:28:31,439 --> 00:28:34,979
in ruku toe right now when we benchmark

00:28:33,269 --> 00:28:37,589
rokudo and something takes longer than

00:28:34,979 --> 00:28:40,289
we think it should it's hard to know is

00:28:37,589 --> 00:28:41,789
that because of the way the programmer

00:28:40,289 --> 00:28:43,949
wrote it is it because of the way

00:28:41,789 --> 00:28:46,739
recruit O's compiling it is it because

00:28:43,949 --> 00:28:48,929
of the way parrots executing it or that

00:28:46,739 --> 00:28:50,609
what parrots doing with it it's really

00:28:48,929 --> 00:28:54,029
really hard and it's real easy to finger

00:28:50,609 --> 00:28:56,669
point from one group to another to be

00:28:54,029 --> 00:28:58,829
able to do that now if we have another

00:28:56,669 --> 00:29:01,559
virtual machine we can say for example

00:28:58,829 --> 00:29:04,319
it runs slow on parrot but it's running

00:29:01,559 --> 00:29:06,479
fast on the JVM that tends to point a

00:29:04,319 --> 00:29:09,779
finger point that the culprit might be

00:29:06,479 --> 00:29:11,849
in parrot or if it runs slow on the JVM

00:29:09,779 --> 00:29:13,439
and on parrot slower than what we expect

00:29:11,849 --> 00:29:15,179
then we can say well it's probably

00:29:13,439 --> 00:29:17,609
somewhere up stack where we're not

00:29:15,179 --> 00:29:19,199
really thinking about it so we now have

00:29:17,609 --> 00:29:22,049
it something else to benchmark in test

00:29:19,199 --> 00:29:24,569
against which is really useful some

00:29:22,049 --> 00:29:26,009
things that we are not doing and this

00:29:24,569 --> 00:29:28,709
also came up in some of the questions

00:29:26,009 --> 00:29:30,779
we're not abandoning Rikuo on parrot at

00:29:28,709 --> 00:29:33,209
the moment Rikuo on parrot continues to

00:29:30,779 --> 00:29:35,249
be and will be for the at least the next

00:29:33,209 --> 00:29:37,079
few months and possibly longer the most

00:29:35,249 --> 00:29:39,209
feature complete perl 6 implementation

00:29:37,079 --> 00:29:41,249
that exists so we're not going to throw

00:29:39,209 --> 00:29:43,049
it out it's still the benchmark by which

00:29:41,249 --> 00:29:45,029
we have to judge whatever else is done

00:29:43,049 --> 00:29:48,959
both in terms of speed but also in terms

00:29:45,029 --> 00:29:51,419
of feature completeness so even if

00:29:48,959 --> 00:29:53,099
parrot doesn't have a lot of changes or

00:29:51,419 --> 00:29:55,039
things coming along we will continue to

00:29:53,099 --> 00:29:57,190
support recruit o on parrot for the

00:29:55,039 --> 00:30:00,160
foreseeable future

00:29:57,190 --> 00:30:02,710
discussions earlier about you know once

00:30:00,160 --> 00:30:05,800
Rikuo becomes available on the JVM will

00:30:02,710 --> 00:30:08,050
that become its primary platform for

00:30:05,800 --> 00:30:09,460
doing stuff and as the recruit Oh

00:30:08,050 --> 00:30:12,280
pumpkin I'm telling you we're not

00:30:09,460 --> 00:30:16,150
declaring a primary platform there is no

00:30:12,280 --> 00:30:18,670
official vm for recruit Oh Perl 6 now

00:30:16,150 --> 00:30:20,680
that's not a invariant it might there

00:30:18,670 --> 00:30:22,660
might be a day when we say there is a

00:30:20,680 --> 00:30:24,490
preferred platform or one that will

00:30:22,660 --> 00:30:26,470
likely be best for you but there will

00:30:24,490 --> 00:30:28,720
never be an official this is the target

00:30:26,470 --> 00:30:29,890
platform because that would mean there's

00:30:28,720 --> 00:30:32,250
only one way to do it and we don't

00:30:29,890 --> 00:30:35,110
believe in there's only one way to do it

00:30:32,250 --> 00:30:37,840
we're not going to attempt to come up

00:30:35,110 --> 00:30:39,910
with a Perl 6 that will run every pearl

00:30:37,840 --> 00:30:43,210
6 program on every platform you can

00:30:39,910 --> 00:30:46,300
imagine to me that just smacks of lowest

00:30:43,210 --> 00:30:48,100
common denominator ship so some common

00:30:46,300 --> 00:30:49,960
question I get is well if somebody

00:30:48,100 --> 00:30:52,990
writes a perl module that depends on a

00:30:49,960 --> 00:30:55,450
java library how do you use that module

00:30:52,990 --> 00:30:57,520
in an implementation of Perl 6 that's

00:30:55,450 --> 00:31:01,870
not running on Java and my answer is

00:30:57,520 --> 00:31:04,180
well you don't and you can come up with

00:31:01,870 --> 00:31:05,830
a module if you want that will figure

00:31:04,180 --> 00:31:07,600
out what platform you're on and do the

00:31:05,830 --> 00:31:09,910
right thing or you may just say look

00:31:07,600 --> 00:31:12,910
that's not a capability that's there but

00:31:09,910 --> 00:31:15,280
that's the way to me computing has been

00:31:12,910 --> 00:31:17,950
for a long time there are things that I

00:31:15,280 --> 00:31:19,840
can do in C on a window system that I

00:31:17,950 --> 00:31:21,700
can't do and see on a Linux system and

00:31:19,840 --> 00:31:24,580
vice versa and it's just that that's not

00:31:21,700 --> 00:31:25,960
something the language really needs to

00:31:24,580 --> 00:31:27,450
do if you try and make everything the

00:31:25,960 --> 00:31:32,470
same everywhere then nobody has enough

00:31:27,450 --> 00:31:35,650
it effectively what it is so where do

00:31:32,470 --> 00:31:38,860
things stand now n QP is bootstrap that

00:31:35,650 --> 00:31:41,050
is self hosted on the JVM what that

00:31:38,860 --> 00:31:42,880
means is that n QP on the JVM can be

00:31:41,050 --> 00:31:45,580
used as a cross compiler to build the

00:31:42,880 --> 00:31:47,950
other backends so we can actually build

00:31:45,580 --> 00:31:50,620
and do all of the things that we need to

00:31:47,950 --> 00:31:53,680
do within QP without ever having to

00:31:50,620 --> 00:31:56,230
touch parrot if we want to you can so

00:31:53,680 --> 00:31:58,810
you can build n QP without parrot the

00:31:56,230 --> 00:32:00,970
brick Udo on the JVM port has begun it's

00:31:58,810 --> 00:32:04,600
been underway for about two or three

00:32:00,970 --> 00:32:05,549
months not even yeah two ish not very

00:32:04,600 --> 00:32:07,739
long

00:32:05,549 --> 00:32:10,230
so this is this is you know you're

00:32:07,739 --> 00:32:11,489
receiving new details this is not you

00:32:10,230 --> 00:32:12,869
know stuff that we've been working on

00:32:11,489 --> 00:32:14,879
what we've been working on for a year

00:32:12,869 --> 00:32:18,929
but we haven't been coding it all for a

00:32:14,879 --> 00:32:22,409
year so the bakudo and JV port has begun

00:32:18,929 --> 00:32:24,869
it can do some things the process of

00:32:22,409 --> 00:32:27,090
doing that some things from rakuten

00:32:24,869 --> 00:32:29,070
parrot didn't change very much at all to

00:32:27,090 --> 00:32:30,450
get them to work on the JVM the grammar

00:32:29,070 --> 00:32:32,190
and actions those would pretty much

00:32:30,450 --> 00:32:35,100
remain the same the meta objects remain

00:32:32,190 --> 00:32:37,009
the same and that tells us that n QP had

00:32:35,100 --> 00:32:39,769
about the right abstraction leper layer

00:32:37,009 --> 00:32:42,239
for for being able to do those things

00:32:39,769 --> 00:32:44,309
some things needed some work the

00:32:42,239 --> 00:32:48,269
bootstrap process the bootstrap is where

00:32:44,309 --> 00:32:50,369
r akudo defines its its core types the

00:32:48,269 --> 00:32:53,369
really basic types like a raise and

00:32:50,369 --> 00:32:55,159
hashes that it needs and and classes

00:32:53,369 --> 00:32:58,320
like new and any and things like that

00:32:55,159 --> 00:33:00,840
that that needed a little bit more work

00:32:58,320 --> 00:33:07,710
but not too bad and then there's the

00:33:00,840 --> 00:33:12,029
setting so the core setting in ruku toe

00:33:07,710 --> 00:33:15,210
is the part that defines all of the Perl

00:33:12,029 --> 00:33:17,129
6 primitive perl 6 functions that you

00:33:15,210 --> 00:33:18,960
would want to use in my other graph

00:33:17,129 --> 00:33:21,239
earlier that was the dark green section

00:33:18,960 --> 00:33:24,659
it's written in perl 6 and is compiled

00:33:21,239 --> 00:33:26,429
by rokudo itself it's your outer scope

00:33:24,659 --> 00:33:28,139
for the user programs and you really

00:33:26,429 --> 00:33:29,309
can't run much of Perl 6 without having

00:33:28,139 --> 00:33:31,320
the setting in place because you don't

00:33:29,309 --> 00:33:33,359
have any of your basic methods in place

00:33:31,320 --> 00:33:35,730
your class definitions are missing all

00:33:33,359 --> 00:33:37,950
their methods for the most part right

00:33:35,730 --> 00:33:40,559
which means you can't do much testing

00:33:37,950 --> 00:33:42,899
without having the setting because the

00:33:40,559 --> 00:33:44,759
tests were all written in perl 6 so if

00:33:42,899 --> 00:33:46,109
you want to know how well your jvm is

00:33:44,759 --> 00:33:47,999
doing you have to be able to compile the

00:33:46,109 --> 00:33:50,970
setting so how big is the setting it's

00:33:47,999 --> 00:33:52,019
13 thousand lines of Perl 6 source so

00:33:50,970 --> 00:33:53,940
before you can know if your

00:33:52,019 --> 00:33:55,529
implementation on JVM is working you

00:33:53,940 --> 00:33:57,859
really have to be able to compile the

00:33:55,529 --> 00:34:01,399
thirteen thousand lines of source and

00:33:57,859 --> 00:34:01,399
they're all in one file

00:34:01,929 --> 00:34:11,649
so Jonathan said I'm just going to do it

00:34:08,530 --> 00:34:14,389
so start by parsing basically run the

00:34:11,649 --> 00:34:16,070
Kudo compiler as it existed on the JVM

00:34:14,389 --> 00:34:18,020
on the setting when you get to an error

00:34:16,070 --> 00:34:21,980
figure out what that error is and try

00:34:18,020 --> 00:34:25,149
again see how far you get so first time

00:34:21,980 --> 00:34:27,470
you do it you might get to what line for

00:34:25,149 --> 00:34:30,710
because you get past the comments at the

00:34:27,470 --> 00:34:32,750
beginning all right so you might get to

00:34:30,710 --> 00:34:34,339
line four and you might go from there

00:34:32,750 --> 00:34:36,560
and I stole these from another talk that

00:34:34,339 --> 00:34:40,310
Jonathan gave on the top so to get to

00:34:36,560 --> 00:34:43,070
line 100 took on the order of a week to

00:34:40,310 --> 00:34:44,810
have that part compile to get from one

00:34:43,070 --> 00:34:48,139
hundred to a thousand took another week

00:34:44,810 --> 00:34:52,010
to get from a thousand to two thousand

00:34:48,139 --> 00:34:54,790
took a day and to get from two thousand

00:34:52,010 --> 00:34:59,570
the rest of the wayland took another day

00:34:54,790 --> 00:35:01,000
all right so now the setting compiles

00:34:59,570 --> 00:35:03,320
now that doesn't mean everything works

00:35:01,000 --> 00:35:06,050
but at least you're able to get there

00:35:03,320 --> 00:35:09,020
and start running some tests and start

00:35:06,050 --> 00:35:11,420
doing some stuff to be able to make that

00:35:09,020 --> 00:35:13,250
work now it's worth noting that

00:35:11,420 --> 00:35:14,960
compiling the setting i talked earlier

00:35:13,250 --> 00:35:17,060
about how when you're compiling it's not

00:35:14,960 --> 00:35:18,740
just you know producing an abstract

00:35:17,060 --> 00:35:21,680
syntax tree and things like that in Perl

00:35:18,740 --> 00:35:24,470
6 it is actually doing stuff so it's not

00:35:21,680 --> 00:35:26,960
just compiling in the transit in the

00:35:24,470 --> 00:35:29,780
traditional sense because line 137 of

00:35:26,960 --> 00:35:31,220
the setting has a begin block which

00:35:29,780 --> 00:35:32,690
means that as you're compiling the

00:35:31,220 --> 00:35:36,440
setting you have to be able to execute

00:35:32,690 --> 00:35:39,950
some perl 6 code so you actually have to

00:35:36,440 --> 00:35:42,680
be able to call trait mod call it a the

00:35:39,950 --> 00:35:46,040
set only star method on that particular

00:35:42,680 --> 00:35:47,780
trait in order to continue compiling the

00:35:46,040 --> 00:35:49,570
rest of the setting so you have to get

00:35:47,780 --> 00:35:51,589
some pieces working in order to it

00:35:49,570 --> 00:35:54,020
things that you have to be able to

00:35:51,589 --> 00:35:55,580
execute as you're compiling a source

00:35:54,020 --> 00:35:56,720
program including the setting is you

00:35:55,580 --> 00:35:59,359
have to be able to do begin blocks

00:35:56,720 --> 00:36:02,599
traits constants all sorts of things

00:35:59,359 --> 00:36:04,420
like that that have to go in there but

00:36:02,599 --> 00:36:06,830
it's now able to compile the setting

00:36:04,420 --> 00:36:10,640
last report I heard is that it passes

00:36:06,830 --> 00:36:11,900
hello world possibly more by today I

00:36:10,640 --> 00:36:12,320
don't know what happened yesterday if

00:36:11,900 --> 00:36:14,990
any

00:36:12,320 --> 00:36:15,860
go farther I know a lot of people are I

00:36:14,990 --> 00:36:17,720
know a lot of people are downloading

00:36:15,860 --> 00:36:19,130
compiling and saying you know I can't

00:36:17,720 --> 00:36:23,090
get it to pass any of the tests which we

00:36:19,130 --> 00:36:25,760
say yeah we know but it is it is making

00:36:23,090 --> 00:36:27,920
progress so what's the performance look

00:36:25,760 --> 00:36:31,010
like if you really want to know the

00:36:27,920 --> 00:36:33,520
performance of n QP on the JVM or perl 6

00:36:31,010 --> 00:36:35,990
on the JVM as it exists today go to

00:36:33,520 --> 00:36:37,430
Jaffee's Need for Speed talk tomorrow at

00:36:35,990 --> 00:36:39,170
eleven thirty five I've seen advance

00:36:37,430 --> 00:36:42,260
copies and make comments on it there's a

00:36:39,170 --> 00:36:45,500
lot of really useful data in there our

00:36:42,260 --> 00:36:47,750
goal has not been performance as the top

00:36:45,500 --> 00:36:50,090
goal at the moment our goal is make it

00:36:47,750 --> 00:36:51,740
work and make it fast but we know where

00:36:50,090 --> 00:36:53,060
a lot of the pitfalls are from having

00:36:51,740 --> 00:36:56,180
done things with parrot in the past

00:36:53,060 --> 00:36:59,800
there are new pitfalls now to find and

00:36:56,180 --> 00:37:02,750
most of those have been avoided already

00:36:59,800 --> 00:37:04,100
performance n QP on the JVM generally

00:37:02,750 --> 00:37:07,490
runs between three and twenty times

00:37:04,100 --> 00:37:09,830
faster than n QP running on parrot for

00:37:07,490 --> 00:37:11,390
an equivalent program so we already know

00:37:09,830 --> 00:37:14,330
we're getting a pretty good speed up

00:37:11,390 --> 00:37:16,010
there and again this is n QP on parrot

00:37:14,330 --> 00:37:17,780
represents code that has been looked at

00:37:16,010 --> 00:37:20,390
and examined and optimized over several

00:37:17,780 --> 00:37:22,100
years n QP JVM is something that's only

00:37:20,390 --> 00:37:23,750
been around for a couple of months to be

00:37:22,100 --> 00:37:26,060
able to do benchmarking an optimization

00:37:23,750 --> 00:37:28,310
and we haven't really done that except

00:37:26,060 --> 00:37:32,630
when something is really egregiously

00:37:28,310 --> 00:37:35,510
wrong and we can't stand it Rikuo Jamie

00:37:32,630 --> 00:37:37,910
running on the JVM feels generally

00:37:35,510 --> 00:37:39,680
faster than rakuten parrot we don't have

00:37:37,910 --> 00:37:42,740
any numbers yet because we're not really

00:37:39,680 --> 00:37:45,020
running real tests but compiling things

00:37:42,740 --> 00:37:47,180
like the setting and doing some basic

00:37:45,020 --> 00:37:49,340
loops and stuff like that seem to be

00:37:47,180 --> 00:37:51,290
running anywhere between you know two to

00:37:49,340 --> 00:37:55,340
five times faster on the JVM than they

00:37:51,290 --> 00:37:58,910
did on parrot one downside to the JVM is

00:37:55,340 --> 00:38:00,890
has a really slow startup time it's just

00:37:58,910 --> 00:38:02,810
incredibly slow like from the time I

00:38:00,890 --> 00:38:07,100
think from on my machine from the time

00:38:02,810 --> 00:38:09,140
that I start j n QP jvm until it gives

00:38:07,100 --> 00:38:11,900
me a prompt or starts compiling is on

00:38:09,140 --> 00:38:14,900
the order of a second and so it's a

00:38:11,900 --> 00:38:17,090
really slow touch startup time so you

00:38:14,900 --> 00:38:18,980
know one benchmark that you would like

00:38:17,090 --> 00:38:20,490
to be able to do is to say well you've

00:38:18,980 --> 00:38:22,050
got n QP running on the JV

00:38:20,490 --> 00:38:24,180
m and on parrot how long does it take to

00:38:22,050 --> 00:38:26,520
run the test suite and they run about

00:38:24,180 --> 00:38:28,369
the same period of time because parrot

00:38:26,520 --> 00:38:33,390
is fast its startup but slow at

00:38:28,369 --> 00:38:35,760
execution and the tests are small and n

00:38:33,390 --> 00:38:37,290
QP on the JVM is really fasted executing

00:38:35,760 --> 00:38:40,470
the test but it takes a long time to get

00:38:37,290 --> 00:38:43,290
there so they're they're roughly the

00:38:40,470 --> 00:38:45,390
same so it's kind of hard to say I think

00:38:43,290 --> 00:38:49,290
we'll be able to do some optimizations

00:38:45,390 --> 00:38:51,119
on n QP start up for the JPM JVM and

00:38:49,290 --> 00:38:54,410
also on Rue kudo but again that's kind

00:38:51,119 --> 00:38:56,910
of you know we have to get there first

00:38:54,410 --> 00:38:58,770
as I mentioned earlier having multiple

00:38:56,910 --> 00:39:01,160
but backends really helps to locate the

00:38:58,770 --> 00:39:03,840
bottlenecks where are we going next

00:39:01,160 --> 00:39:07,500
first of all with the announcement of

00:39:03,840 --> 00:39:10,430
more vm this last week the reveal i

00:39:07,500 --> 00:39:12,660
should say i decided to adopt a new hat

00:39:10,430 --> 00:39:14,880
we have different roles for different

00:39:12,660 --> 00:39:17,880
people who play in recruit Oh pearl six

00:39:14,880 --> 00:39:20,130
so for example Carl often is the

00:39:17,880 --> 00:39:22,200
historian he likes to do the history of

00:39:20,130 --> 00:39:24,480
what's been taking place things like

00:39:22,200 --> 00:39:32,640
that my new hat is the one who lowers

00:39:24,480 --> 00:39:34,530
the expectations so it's hard at a

00:39:32,640 --> 00:39:36,420
conference like this it's hard in a blog

00:39:34,530 --> 00:39:38,609
post you go through and say we have this

00:39:36,420 --> 00:39:41,869
new machine we think it'll be faster and

00:39:38,609 --> 00:39:45,560
what everybody says is Christmas and

00:39:41,869 --> 00:39:50,880
it's like no Christmas is not here yet

00:39:45,560 --> 00:39:53,010
all right yeah it's not here yet from a

00:39:50,880 --> 00:39:55,260
lot of people Christmas is not here it's

00:39:53,010 --> 00:39:57,780
not i'm not even going to say it's going

00:39:55,260 --> 00:40:00,359
to be here this year there's a lot of

00:39:57,780 --> 00:40:02,520
stuff that still has to be worked on in

00:40:00,359 --> 00:40:05,670
order to make this work now it is

00:40:02,520 --> 00:40:07,710
becoming rokudo and Perl 6 are becoming

00:40:05,670 --> 00:40:10,530
more usable every day more and more

00:40:07,710 --> 00:40:12,480
people are using it every day for doing

00:40:10,530 --> 00:40:15,480
different things so it is a usable

00:40:12,480 --> 00:40:17,460
system but it's you know the standard

00:40:15,480 --> 00:40:19,680
question is that I get is when will it

00:40:17,460 --> 00:40:22,140
be finished and I don't even see the

00:40:19,680 --> 00:40:24,390
finish line yet so I'm just you know

00:40:22,140 --> 00:40:26,430
it's not there and especially for the

00:40:24,390 --> 00:40:29,630
JVM stuff it's really new and immature

00:40:26,430 --> 00:40:29,630
yes chip you have a question

00:40:30,580 --> 00:40:40,150
yes exactly so Jim commented the Pearl 5

00:40:34,000 --> 00:40:43,300
isn't finished it if you if what I have

00:40:40,150 --> 00:40:44,710
discovered what I've discovered and of

00:40:43,300 --> 00:40:46,390
course this is a somewhat friendly crowd

00:40:44,710 --> 00:40:48,130
right is that somebody will say to me

00:40:46,390 --> 00:40:49,360
pearl sixes and finish and I say pro/5

00:40:48,130 --> 00:40:53,050
isn't finish and they say that's a

00:40:49,360 --> 00:40:55,180
cop-out I know I and I don't think so

00:40:53,050 --> 00:40:56,950
either but you know they'll say oh great

00:40:55,180 --> 00:40:59,890
so now we're demand we're debating the

00:40:56,950 --> 00:41:01,240
semantics of finished and everything and

00:40:59,890 --> 00:41:03,190
they're like everybody knows what it

00:41:01,240 --> 00:41:04,810
means for perl 6 to be finished but but

00:41:03,190 --> 00:41:06,280
whenever asked for definition nobody can

00:41:04,810 --> 00:41:08,940
define it or they'll say well it's when

00:41:06,280 --> 00:41:15,490
one point 0 is released well ok great

00:41:08,940 --> 00:41:17,500
you know i don't want to rehash the

00:41:15,490 --> 00:41:19,780
whole thing right now it's bad stuff

00:41:17,500 --> 00:41:24,130
alright so the next step short term so

00:41:19,780 --> 00:41:27,460
the jun 2013 release of Rikuo will have

00:41:24,130 --> 00:41:30,490
the JVM back end stuff in it in fact it

00:41:27,460 --> 00:41:33,610
merged yesterday the JVM branch is

00:41:30,490 --> 00:41:36,040
merged into the main trunk yesterday so

00:41:33,610 --> 00:41:37,870
the next release will have the JVM back

00:41:36,040 --> 00:41:39,850
end code in it that's not to say it will

00:41:37,870 --> 00:41:41,560
run anything or pass all the tests but

00:41:39,850 --> 00:41:45,610
it is part of the main development

00:41:41,560 --> 00:41:47,830
branch as of now the next step so I have

00:41:45,610 --> 00:41:49,480
these up there as these are not things

00:41:47,830 --> 00:41:51,580
that it does today these are next steps

00:41:49,480 --> 00:41:53,620
of things we want to do is to get it to

00:41:51,580 --> 00:41:55,540
pass the sanity test the sanity tests

00:41:53,620 --> 00:41:57,550
are the low-level you know can you even

00:41:55,540 --> 00:41:59,140
print something to the output and can

00:41:57,550 --> 00:42:02,890
you add two numbers together a type of

00:41:59,140 --> 00:42:04,270
thing and then after getting the sanity

00:42:02,890 --> 00:42:06,340
test running next would be the roast

00:42:04,270 --> 00:42:08,350
test those are the spec tests the ones

00:42:06,340 --> 00:42:10,330
that are the Perl 6 specification

00:42:08,350 --> 00:42:12,370
definition and the target for having

00:42:10,330 --> 00:42:15,340
that running is august 2013 unless it

00:42:12,370 --> 00:42:17,410
changed or is that still the case may it

00:42:15,340 --> 00:42:19,540
probably might be you know these are

00:42:17,410 --> 00:42:23,170
fudgy numbers please please don't hold

00:42:19,540 --> 00:42:25,420
us to them yet as we get the spec test

00:42:23,170 --> 00:42:28,240
going we have to adapt the Perl 6 and r

00:42:25,420 --> 00:42:30,790
akuto ecosystems a lot of modules that

00:42:28,240 --> 00:42:33,340
exist in the Perl 6 thing we're written

00:42:30,790 --> 00:42:35,050
assuming recruit o on parrot and now we

00:42:33,340 --> 00:42:36,580
have to make sure that they still run

00:42:35,050 --> 00:42:38,350
for bakuto on jvm

00:42:36,580 --> 00:42:40,180
maybe they use some of the low-level

00:42:38,350 --> 00:42:43,060
peer stuff that we said not to use

00:42:40,180 --> 00:42:44,710
unless you absolutely have to now we may

00:42:43,060 --> 00:42:46,390
be reaching the point of discovering

00:42:44,710 --> 00:42:48,340
where the absolutely have to SR and go

00:42:46,390 --> 00:42:51,340
back and fix up n QP and do some stuff

00:42:48,340 --> 00:42:54,310
to be able to support those better but

00:42:51,340 --> 00:42:55,990
to have a Rikuo star which is a

00:42:54,310 --> 00:42:58,560
distribution of pearl six that runs

00:42:55,990 --> 00:43:02,320
modules available we're targeting

00:42:58,560 --> 00:43:04,000
september-october to this year that's

00:43:02,320 --> 00:43:05,860
the the current thing of course anything

00:43:04,000 --> 00:43:07,720
something could happen that you know

00:43:05,860 --> 00:43:10,030
some big obstacle that we hadn't

00:43:07,720 --> 00:43:11,680
imagined shows up but there and of

00:43:10,030 --> 00:43:13,150
course the next steps are always to

00:43:11,680 --> 00:43:15,520
benchmark the runtime and startup

00:43:13,150 --> 00:43:16,990
performance because we know and part of

00:43:15,520 --> 00:43:19,330
what's driven all of our work for the

00:43:16,990 --> 00:43:21,040
past couple of years is that the biggest

00:43:19,330 --> 00:43:22,540
obstacle to us to having more people

00:43:21,040 --> 00:43:24,250
using the system is it's too slow

00:43:22,540 --> 00:43:25,660
whether you want to develop whether you

00:43:24,250 --> 00:43:27,250
want to be an application right or

00:43:25,660 --> 00:43:29,980
whether you just want to contribute when

00:43:27,250 --> 00:43:32,620
it takes 10 or 15 minutes to run the

00:43:29,980 --> 00:43:34,210
tests that's just too slow a cycle for a

00:43:32,620 --> 00:43:35,590
lot of people to work on so anything we

00:43:34,210 --> 00:43:38,890
can do to make things faster we try to

00:43:35,590 --> 00:43:40,090
do any questions oh boy the tans all

00:43:38,890 --> 00:43:42,900
just went out let me start in the back

00:43:40,090 --> 00:43:42,900
into the front so Bruce

00:43:54,320 --> 00:43:58,350
okay so the question is when we recruit

00:43:56,820 --> 00:44:00,720
a release recruit Oh star which is

00:43:58,350 --> 00:44:03,750
normally released as a tarball will we

00:44:00,720 --> 00:44:05,160
do it for the JVM or for parrot or have

00:44:03,750 --> 00:44:06,510
one tarball that does pose its most

00:44:05,160 --> 00:44:10,500
likely to be one that's both and you

00:44:06,510 --> 00:44:11,940
select by a configure option that's kind

00:44:10,500 --> 00:44:14,760
of what works best for the recruiter

00:44:11,940 --> 00:44:16,460
compiler in terms of making it easier

00:44:14,760 --> 00:44:18,480
for the developers at the moment so

00:44:16,460 --> 00:44:20,220
since we're going to already have that

00:44:18,480 --> 00:44:22,950
option and configure I suspect it'll

00:44:20,220 --> 00:44:25,110
just be there now for the pre compiled

00:44:22,950 --> 00:44:26,850
binaries like the window windows ms is

00:44:25,110 --> 00:44:29,550
those will probably come out as separate

00:44:26,850 --> 00:44:30,960
binaries and and I don't know that those

00:44:29,550 --> 00:44:33,660
will be available immediately at the

00:44:30,960 --> 00:44:35,280
same time or not then I had another

00:44:33,660 --> 00:44:37,640
question let me go to chip and then I'll

00:44:35,280 --> 00:44:37,640
do Jim

00:44:53,150 --> 00:45:00,990
context like what are the boundaries of

00:44:55,860 --> 00:45:02,700
the platter right kudo or it's a thing

00:45:00,990 --> 00:45:06,330
that so the question is what is six

00:45:02,700 --> 00:45:08,340
model and six model is something that

00:45:06,330 --> 00:45:11,400
rikudou needs six model is something

00:45:08,340 --> 00:45:16,620
that n QP needs even to be able to get n

00:45:11,400 --> 00:45:19,230
QP running six model is a meta object

00:45:16,620 --> 00:45:20,490
system for building object systems that

00:45:19,230 --> 00:45:22,950
it's at its lowest level it's a metal

00:45:20,490 --> 00:45:24,930
object protocol so you can use that too

00:45:22,950 --> 00:45:26,880
it's also it also contains a

00:45:24,930 --> 00:45:28,230
representation component where you can

00:45:26,880 --> 00:45:30,570
define how you're going to represent

00:45:28,230 --> 00:45:32,550
your native types and things in your

00:45:30,570 --> 00:45:34,200
virtual machine environment so it's a

00:45:32,550 --> 00:45:35,790
set of definitions it's a set of things

00:45:34,200 --> 00:45:39,120
that when you put it all together and

00:45:35,790 --> 00:45:41,990
it's very vm specific at the moment for

00:45:39,120 --> 00:45:44,400
for some pieces of it then you get a

00:45:41,990 --> 00:45:45,780
meta object system that you can use to

00:45:44,400 --> 00:45:48,570
build up the rest of your object

00:45:45,780 --> 00:45:57,270
framework in in a vm independent manner

00:45:48,570 --> 00:46:00,810
after that works model the right way on

00:45:57,270 --> 00:46:04,620
the CDN the final result is a file or

00:46:00,810 --> 00:46:09,770
people i don't know i think it's more

00:46:04,620 --> 00:46:09,770
than that so the question was are the

00:46:10,370 --> 00:46:14,280
right right so the question was if you

00:46:12,990 --> 00:46:16,260
do it right then do you end up with the

00:46:14,280 --> 00:46:19,520
class file at the end we end up with

00:46:16,260 --> 00:46:22,140
class files for everything so but but

00:46:19,520 --> 00:46:24,240
yeah so anyway Jim you had a question

00:46:22,140 --> 00:46:29,370
and then I think I'm going to be out of

00:46:24,240 --> 00:46:35,370
time for questions yes yeah there are

00:46:29,370 --> 00:46:37,170
four more users 06 every day and I am

00:46:35,370 --> 00:46:39,930
faced with the process of the end

00:46:37,170 --> 00:46:42,510
parent project and also from like

00:46:39,930 --> 00:46:46,530
hearing Todd's might be like producing

00:46:42,510 --> 00:46:49,680
the freebsd is the question of actual

00:46:46,530 --> 00:46:52,049
users people your production users and

00:46:49,680 --> 00:46:53,819
open source technology is really

00:46:52,049 --> 00:46:55,980
critical not so much because it

00:46:53,819 --> 00:46:58,859
indicates how good the technology is

00:46:55,980 --> 00:47:01,349
because the presence of users pretend

00:46:58,859 --> 00:47:04,559
the next generation of volunteers which

00:47:01,349 --> 00:47:07,559
are needed in open source projects so

00:47:04,559 --> 00:47:09,270
I'm wondering you know I mean this

00:47:07,559 --> 00:47:12,390
course is something that a lot of people

00:47:09,270 --> 00:47:14,280
have lost in the new story way aunt

00:47:12,390 --> 00:47:17,369
pearl states from health care and so

00:47:14,280 --> 00:47:20,640
forth and this question of well who

00:47:17,369 --> 00:47:23,160
actually is using it and how does it fit

00:47:20,640 --> 00:47:26,640
into your plans for the future

00:47:23,160 --> 00:47:30,329
development of the projects so to repeat

00:47:26,640 --> 00:47:33,410
the question the question is who are the

00:47:30,329 --> 00:47:35,640
users of Perl 6 and what are our plans

00:47:33,410 --> 00:47:37,380
and how does that feed into our plans

00:47:35,640 --> 00:47:40,530
for improving the project as a whole and

00:47:37,380 --> 00:47:42,270
not just the codebase having done a

00:47:40,530 --> 00:47:45,119
couple of other open source projects

00:47:42,270 --> 00:47:46,920
before and this is not I don't claim to

00:47:45,119 --> 00:47:49,250
be an expert on open source projects I

00:47:46,920 --> 00:47:51,750
all I know is what my experience is I

00:47:49,250 --> 00:47:53,670
would create an open source project I

00:47:51,750 --> 00:47:55,230
put it out I was the lone developer for

00:47:53,670 --> 00:47:56,819
a while or maybe a couple of friends

00:47:55,230 --> 00:48:00,000
that I knew we would work on it but it

00:47:56,819 --> 00:48:02,280
was out there and stuff and then all of

00:48:00,000 --> 00:48:05,910
a sudden you end up with people coming

00:48:02,280 --> 00:48:07,500
from out of nowhere to contribute you

00:48:05,910 --> 00:48:09,510
know where they'll say and and they'll

00:48:07,500 --> 00:48:12,720
say things like i've been using your

00:48:09,510 --> 00:48:14,730
product for like four months and it

00:48:12,720 --> 00:48:16,380
works great for me but if you could add

00:48:14,730 --> 00:48:20,450
this one little feature it would be even

00:48:16,380 --> 00:48:23,460
better and you discover and you discover

00:48:20,450 --> 00:48:25,200
much as a was set in the keynote

00:48:23,460 --> 00:48:26,970
yesterday you kind of have this you're

00:48:25,200 --> 00:48:28,380
doing what moment you know like you're

00:48:26,970 --> 00:48:31,589
actually using my code for something

00:48:28,380 --> 00:48:33,780
real no stop it's not ready yet type of

00:48:31,589 --> 00:48:35,460
thing and we're starting to see those

00:48:33,780 --> 00:48:36,690
kinds of things where people are coming

00:48:35,460 --> 00:48:39,260
in and asking questions and they're

00:48:36,690 --> 00:48:42,359
saying you know I've been using this for

00:48:39,260 --> 00:48:45,540
some of my projects or things like that

00:48:42,359 --> 00:48:46,980
and do that the things that we have to

00:48:45,540 --> 00:48:47,550
do and the things that I think are the

00:48:46,980 --> 00:48:51,960
most

00:48:47,550 --> 00:49:11,220
important okay it's trying to tell me my

00:48:51,960 --> 00:49:13,980
times up the thing that I think we have

00:49:11,220 --> 00:49:16,590
to do the number two complaint without

00:49:13,980 --> 00:49:18,120
doubt about well there's two and three

00:49:16,590 --> 00:49:20,220
but the number to the one I would place

00:49:18,120 --> 00:49:21,630
number two without a doubt behind it's

00:49:20,220 --> 00:49:26,280
too slow is where's the darn

00:49:21,630 --> 00:49:29,190
documentation and what we need is we

00:49:26,280 --> 00:49:30,930
need to find more people who are users

00:49:29,190 --> 00:49:33,030
who are willing to write about their

00:49:30,930 --> 00:49:35,700
experiences or willing to contribute a

00:49:33,030 --> 00:49:38,340
little bit of documentation because I

00:49:35,700 --> 00:49:40,830
mean that those are our on ramps that

00:49:38,340 --> 00:49:42,630
are there a close number three or maybe

00:49:40,830 --> 00:49:45,810
tied with number two is to get rid of

00:49:42,630 --> 00:49:48,510
all the bugs and but that's just a slow

00:49:45,810 --> 00:49:50,100
process beyond that if there's any other

00:49:48,510 --> 00:49:51,780
suggestions meet me in the hallway or

00:49:50,100 --> 00:50:03,540
afterwards and give me other sisters and

00:49:51,780 --> 00:50:06,150
then Larry yeah i did i did a foreign a

00:50:03,540 --> 00:50:08,040
blog post i did yesterday i wanted to go

00:50:06,150 --> 00:50:10,200
and find out how many committers were

00:50:08,040 --> 00:50:12,240
there to Perl 6 over the past year and

00:50:10,200 --> 00:50:14,010
so I went and looked through the github

00:50:12,240 --> 00:50:15,900
logs to see how many committers

00:50:14,010 --> 00:50:20,790
individuals there were who had committed

00:50:15,900 --> 00:50:23,760
to either Ricou tow n QP the Perl 6

00:50:20,790 --> 00:50:26,520
documentation the Perl 6 website or the

00:50:23,760 --> 00:50:29,940
specs or the standard grammar those

00:50:26,520 --> 00:50:32,730
those locations and it was 70 there were

00:50:29,940 --> 00:50:35,070
70 committers and when I tell that to

00:50:32,730 --> 00:50:38,730
most people in the team they're like who

00:50:35,070 --> 00:50:40,500
are they right we don't know who those

00:50:38,730 --> 00:50:41,940
70 are but there were 70 committers and

00:50:40,500 --> 00:50:43,860
that was individuals I actually went and

00:50:41,940 --> 00:50:45,240
remove duplicates where you might have

00:50:43,860 --> 00:50:47,070
one commit or under two different names

00:50:45,240 --> 00:50:48,330
or two different email addresses I know

00:50:47,070 --> 00:50:51,050
I'm out of time catch me in the hallway

00:50:48,330 --> 00:50:51,050

YouTube URL: https://www.youtube.com/watch?v=XgPh5Li3k4g


