Title: Tim Bunce - Profiling Memory Usage
Publication date: 2013-08-20
Playlist: YAPC::NA 2013
Description: 
	
Captions: 
	00:00:01,669 --> 00:00:10,019
okay thank you for coming I know we were

00:00:07,410 --> 00:00:11,700
up up against the Perl 6 JVM which is

00:00:10,019 --> 00:00:14,210
kind of a very hot topic I'd like to be

00:00:11,700 --> 00:00:17,100
there myself so thank you for coming

00:00:14,210 --> 00:00:22,010
pearl memory use pearl uses lots of

00:00:17,100 --> 00:00:25,380
memory who's encountered this problem

00:00:22,010 --> 00:00:34,079
okay and if you're on Linux maybe this

00:00:25,380 --> 00:00:36,719
one or maybe this one not a way to

00:00:34,079 --> 00:00:38,640
become popular but generally things just

00:00:36,719 --> 00:00:40,559
slow down you know sort space Scouts

00:00:38,640 --> 00:00:43,980
getting used and is paging and just

00:00:40,559 --> 00:00:46,739
things get painful so a quick tour of

00:00:43,980 --> 00:00:48,329
process memory do you have a pen and

00:00:46,739 --> 00:00:51,239
paper because we can spend 20 minutes

00:00:48,329 --> 00:00:53,399
looking at these numbers does anyone

00:00:51,239 --> 00:00:54,840
know what units those numbers are in so

00:00:53,399 --> 00:00:57,090
that there's a slightly better way now

00:00:54,840 --> 00:00:59,090
I'm going to talk to you that much stad

00:00:57,090 --> 00:01:03,149
in does anyone know what units those are

00:00:59,090 --> 00:01:06,869
at PS PS makes it a little better but

00:01:03,149 --> 00:01:08,640
still what units are those but top tops

00:01:06,869 --> 00:01:11,100
good top actually tells you the units

00:01:08,640 --> 00:01:12,780
and it's behave sensibly so we're going

00:01:11,100 --> 00:01:14,280
to be looking a lot at virtual size but

00:01:12,780 --> 00:01:17,600
before we do I want to kind of take a

00:01:14,280 --> 00:01:20,280
slight detour into the residents eyes

00:01:17,600 --> 00:01:23,880
well it's kind of dig down deeper into

00:01:20,280 --> 00:01:25,830
the the structure of memory and this is

00:01:23,880 --> 00:01:27,540
the nicest way to see what your

00:01:25,830 --> 00:01:29,400
processes is doing looking at the prop

00:01:27,540 --> 00:01:32,070
status if you're lucky enough to be on

00:01:29,400 --> 00:01:33,420
Linux a vm sighs that's the size of the

00:01:32,070 --> 00:01:35,430
whole thing if you're interested in how

00:01:33,420 --> 00:01:38,100
much memory your process is using that's

00:01:35,430 --> 00:01:39,689
the one to look at or possibly vm data

00:01:38,100 --> 00:01:42,810
which is kind of the variable bit that

00:01:39,689 --> 00:01:44,490
all your pearl stuff goes in the RSS is

00:01:42,810 --> 00:01:46,500
the resident set size which is just how

00:01:44,490 --> 00:01:50,369
much happens to be in physical memory at

00:01:46,500 --> 00:01:51,930
the moment and these are your segments

00:01:50,369 --> 00:01:54,930
you've probably heard of a segmentation

00:01:51,930 --> 00:01:57,190
violation well these are the segments

00:01:54,930 --> 00:01:59,210
that get violated

00:01:57,190 --> 00:02:00,950
so you have a little bit of C code at

00:01:59,210 --> 00:02:02,720
the top and then read only data

00:02:00,950 --> 00:02:04,610
read/write day there your heap that

00:02:02,720 --> 00:02:06,140
grows then a bunch of shared libraries

00:02:04,610 --> 00:02:07,340
and then you see stack that isn't your

00:02:06,140 --> 00:02:10,220
pearl stack that the thieves deck

00:02:07,340 --> 00:02:12,170
growing that way and the way you can see

00:02:10,220 --> 00:02:14,420
these on Linux very clearly is through

00:02:12,170 --> 00:02:16,490
the maps proc maps and there you're

00:02:14,420 --> 00:02:19,280
getting one line for every segment and

00:02:16,490 --> 00:02:21,980
you can see the permissions read write

00:02:19,280 --> 00:02:23,270
execute and that's your segmentation

00:02:21,980 --> 00:02:24,830
violation if you try to write to

00:02:23,270 --> 00:02:26,360
something that a segment that you don't

00:02:24,830 --> 00:02:31,940
have write permission on you get a

00:02:26,360 --> 00:02:34,670
segmentation violation okay now for each

00:02:31,940 --> 00:02:36,739
one of those lines represents a segment

00:02:34,670 --> 00:02:39,260
if you look at the S Maps file then for

00:02:36,739 --> 00:02:41,690
every single segment you get this block

00:02:39,260 --> 00:02:44,150
of data showing how big the segment is

00:02:41,690 --> 00:02:45,920
how many pages are a map tann Awful's of

00:02:44,150 --> 00:02:48,410
other stuff that I don't need pretend to

00:02:45,920 --> 00:02:49,970
know what what I'm talking about so the

00:02:48,410 --> 00:02:52,160
processes point of view it has big

00:02:49,970 --> 00:02:54,739
chunks of continuous memory in these

00:02:52,160 --> 00:02:57,500
segments especially the heap in a lot of

00:02:54,739 --> 00:02:59,330
work goes on in heap but the operating

00:02:57,500 --> 00:03:01,790
systems view is very different the

00:02:59,330 --> 00:03:05,329
operating system thinks in terms of 4k

00:03:01,790 --> 00:03:08,269
pages or usually 4k and it's continually

00:03:05,329 --> 00:03:09,920
trying to juggle the physical 4k pages

00:03:08,269 --> 00:03:12,860
amongst all the processes that have

00:03:09,920 --> 00:03:16,700
memory so here's a pretty bad diagram

00:03:12,860 --> 00:03:18,200
trying to show that that 4k pages of

00:03:16,700 --> 00:03:20,120
physical memory are kind of being mapped

00:03:18,200 --> 00:03:23,269
in and out of all the processes that are

00:03:20,120 --> 00:03:24,560
trying to use them so the reason I kind

00:03:23,269 --> 00:03:26,900
of stress this point is quite a lot of

00:03:24,560 --> 00:03:28,549
the modules on Sipan that tried to tell

00:03:26,900 --> 00:03:30,610
you how much memory you're using are

00:03:28,549 --> 00:03:33,769
actually measuring the resident set size

00:03:30,610 --> 00:03:36,260
which is just wrong because even a while

00:03:33,769 --> 00:03:38,870
the process is growing the resident set

00:03:36,260 --> 00:03:40,850
size could be going down if some other

00:03:38,870 --> 00:03:43,820
process is accessing a whole bunch of

00:03:40,850 --> 00:03:45,110
new memory pages yeah then the colonel

00:03:43,820 --> 00:03:47,360
is going to be giving the physical pages

00:03:45,110 --> 00:03:49,370
to that process your process is still

00:03:47,360 --> 00:03:53,930
growing but the resident size is going

00:03:49,370 --> 00:03:57,050
down okay though malik and the heap I

00:03:53,930 --> 00:03:59,940
think it'd be great name for jazz band

00:03:57,050 --> 00:04:01,500
okay so that's where we need to pay

00:03:59,940 --> 00:04:03,810
attention that's where all your pearl

00:04:01,500 --> 00:04:06,900
stuff goes but between pearl and the

00:04:03,810 --> 00:04:09,300
heap is Malik and Malik sits there and

00:04:06,900 --> 00:04:12,930
pearl ask Malik for little chunks of

00:04:09,300 --> 00:04:16,110
memory and pull sometimes gives them

00:04:12,930 --> 00:04:18,030
back to back but Malik very rarely gives

00:04:16,110 --> 00:04:20,640
the back to the operating system it's

00:04:18,030 --> 00:04:23,100
kind of a one-way street if you ask for

00:04:20,640 --> 00:04:25,830
a big data structure kind of 16 k maybe

00:04:23,100 --> 00:04:28,860
the Malik will give you that as a memory

00:04:25,830 --> 00:04:31,260
mapped chunk as a chunk of memory mapped

00:04:28,860 --> 00:04:33,330
memory but when you're free it'll free

00:04:31,260 --> 00:04:35,970
that back off but it's very rare that

00:04:33,330 --> 00:04:40,800
the ordinary sort of Malik use gets free

00:04:35,970 --> 00:04:44,940
back so let's have a look but some pearl

00:04:40,800 --> 00:04:46,440
internals when you write your poco do

00:04:44,940 --> 00:04:48,000
you think in terms of integers and

00:04:46,440 --> 00:04:49,740
strings and arrays and numbers and all

00:04:48,000 --> 00:04:51,360
that kind of thing but inside the Pearl

00:04:49,740 --> 00:04:53,430
internals there's lots of tiny little

00:04:51,360 --> 00:04:56,130
data structures so here are three of

00:04:53,430 --> 00:04:57,840
them integer string and a number with a

00:04:56,130 --> 00:05:02,850
string and at the bottom there you can

00:04:57,840 --> 00:05:05,580
see head body data all scalars have a

00:05:02,850 --> 00:05:09,000
head sorry all all values in in Perl

00:05:05,580 --> 00:05:10,920
have a head most of them have a body and

00:05:09,000 --> 00:05:13,320
some of them have data so an integer is

00:05:10,920 --> 00:05:15,960
optimized now just to be ahead so that's

00:05:13,320 --> 00:05:18,450
four words you might say that before

00:05:15,960 --> 00:05:22,590
32-bit chunks on a 32-bit in phenol for

00:05:18,450 --> 00:05:25,320
64-bit chunks strings also have a body

00:05:22,590 --> 00:05:27,810
and then a variable size length the

00:05:25,320 --> 00:05:30,150
bodies are all fixed size depending on

00:05:27,810 --> 00:05:34,740
on the type and then a number with a

00:05:30,150 --> 00:05:38,490
string has a body and the data arrays

00:05:34,740 --> 00:05:42,720
slightly more complex you have the head

00:05:38,490 --> 00:05:44,490
the body and a variable sized head body

00:05:42,720 --> 00:05:47,550
variable size data with all the pointers

00:05:44,490 --> 00:05:49,560
to the elements in the array now hash

00:05:47,550 --> 00:05:51,390
starts getting very fiddly lots of

00:05:49,560 --> 00:05:54,510
little bits and pieces for the bucket

00:05:51,390 --> 00:05:59,130
chains hash entries and hash keys and

00:05:54,510 --> 00:06:00,450
iterators then we get into globs I'm not

00:05:59,130 --> 00:06:01,830
expecting you to learn this stuff the

00:06:00,450 --> 00:06:03,720
point I'm trying to make here is that

00:06:01,830 --> 00:06:08,490
there's lots of tiny bits of memory

00:06:03,720 --> 00:06:09,750
strung together with pointers I hope

00:06:08,490 --> 00:06:11,760
you'll agree this

00:06:09,750 --> 00:06:13,110
that's its it's kind of gets so crazy

00:06:11,760 --> 00:06:16,850
when you're trying to debug this stuff

00:06:13,110 --> 00:06:19,140
as few of us have lived to tell the tale

00:06:16,850 --> 00:06:21,390
so what tools do we have to look inside

00:06:19,140 --> 00:06:23,580
all all this stuff for this data well

00:06:21,390 --> 00:06:25,740
developed peak is is a handy one for

00:06:23,580 --> 00:06:27,150
looking a little way in so you can give

00:06:25,740 --> 00:06:29,190
it a reference to something and it'll

00:06:27,150 --> 00:06:32,520
show you a couple of levels and give you

00:06:29,190 --> 00:06:34,170
some of the internal information so

00:06:32,520 --> 00:06:36,030
there you can see a reference to a hash

00:06:34,170 --> 00:06:39,180
and down at the bottom you see the

00:06:36,030 --> 00:06:40,530
element in hash and you see the 12 bytes

00:06:39,180 --> 00:06:42,890
is the current length of the string and

00:06:40,530 --> 00:06:46,140
16 is how much was actually allocated

00:06:42,890 --> 00:06:48,000
now that makes the point that there's

00:06:46,140 --> 00:06:50,040
how much data you think is being used

00:06:48,000 --> 00:06:52,290
how much is actually being allocated

00:06:50,040 --> 00:06:53,880
from mark and then Malik behind the

00:06:52,290 --> 00:06:55,500
scenes will have its own overheads

00:06:53,880 --> 00:06:58,440
associated with its buckets and

00:06:55,500 --> 00:07:02,340
fragments and whatever and in the Pearl

00:06:58,440 --> 00:07:05,280
internals if we go back to hear the

00:07:02,340 --> 00:07:07,230
heads and bodies now are all allocated

00:07:05,280 --> 00:07:09,750
from arenas which is kind of very

00:07:07,230 --> 00:07:11,940
efficient fixed sized and allocation

00:07:09,750 --> 00:07:14,130
scheme but still there's overheads and

00:07:11,940 --> 00:07:17,220
one of the interesting side effects of

00:07:14,130 --> 00:07:20,280
the arenas is that there's an arena for

00:07:17,220 --> 00:07:22,169
each type of body so if you allocate a

00:07:20,280 --> 00:07:26,070
million arrays and then you free them

00:07:22,169 --> 00:07:28,770
again in the arenas that hold the bodies

00:07:26,070 --> 00:07:31,979
for the arrays have a million bodies in

00:07:28,770 --> 00:07:33,510
that will never be freed now they're

00:07:31,979 --> 00:07:38,390
there for you if you want to create

00:07:33,510 --> 00:07:38,390
another million arrays but those kind of

00:07:38,540 --> 00:07:44,700
there's a disconnect between how much

00:07:41,070 --> 00:07:48,300
memory your pearl process actually is

00:07:44,700 --> 00:07:50,100
currently using and how much the

00:07:48,300 --> 00:07:51,690
operating system has to give it because

00:07:50,100 --> 00:07:53,760
there's these two layers of buffers

00:07:51,690 --> 00:07:55,530
there's the the mark doing its own sort

00:07:53,760 --> 00:07:57,870
of buffering fragmentation and admin and

00:07:55,530 --> 00:08:01,410
then you've got these arenas doing the

00:07:57,870 --> 00:08:02,820
same thing okay arenas de Velde

00:08:01,410 --> 00:08:07,770
gladiator can kind of show you how much

00:08:02,820 --> 00:08:08,550
is in the arenas and devel size now

00:08:07,770 --> 00:08:14,910
we're going to be talking a bit about

00:08:08,550 --> 00:08:17,580
devel so developers there it just sums

00:08:14,910 --> 00:08:22,349
it up it has the logic to chase all the

00:08:17,580 --> 00:08:23,139
pointers created in 2002 by Dan Zukowski

00:08:22,349 --> 00:08:24,340
Nick

00:08:23,139 --> 00:08:25,539
nick clark has done great work

00:08:24,340 --> 00:08:27,879
maintaining it and keeping it up-to-date

00:08:25,539 --> 00:08:30,030
with all his changes to the internals

00:08:27,879 --> 00:08:32,589
next done amazing work with optimizing

00:08:30,030 --> 00:08:36,219
internals on the Pope I pulled his list

00:08:32,589 --> 00:08:38,110
with a whole bunch of good people so

00:08:36,219 --> 00:08:40,779
this is great this has the logic but it

00:08:38,110 --> 00:08:43,599
just gives you a number that says I have

00:08:40,779 --> 00:08:45,550
this much so I've already mentioned all

00:08:43,599 --> 00:08:47,579
that data that about what you want to

00:08:45,550 --> 00:08:50,380
know is what you can do about this

00:08:47,579 --> 00:08:52,839
that's what I want to know because when

00:08:50,380 --> 00:08:57,190
i did a mi tipo of people say how could

00:08:52,839 --> 00:08:58,660
you do the same thing for memory sold so

00:08:57,190 --> 00:09:00,579
the original thought was maybe we could

00:08:58,660 --> 00:09:02,350
kind of measure memory usage going up

00:09:00,579 --> 00:09:05,230
and down the same way we do for cpu

00:09:02,350 --> 00:09:06,370
usage and Nick like a game did did some

00:09:05,230 --> 00:09:08,110
great experience for that but you just

00:09:06,370 --> 00:09:10,269
turned out not to be useful you know you

00:09:08,110 --> 00:09:12,279
kind of know where memory gets allocated

00:09:10,269 --> 00:09:13,180
most of the time and you know registry

00:09:12,279 --> 00:09:17,680
what you really want knows what's

00:09:13,180 --> 00:09:19,649
holding the memory and actually that can

00:09:17,680 --> 00:09:24,279
lead to some interesting surprises so

00:09:19,649 --> 00:09:26,769
lexical variable out 10 10 meg call the

00:09:24,279 --> 00:09:33,690
function return 20 20 megs still being

00:09:26,769 --> 00:09:45,579
used why is that does anyone know well

00:09:33,690 --> 00:09:48,100
first sorry that explains 110 make so

00:09:45,579 --> 00:09:51,790
110 meg is because the buffer for the

00:09:48,100 --> 00:09:54,040
dollar vile exa chol is being preserved

00:09:51,790 --> 00:09:58,120
ready to take the next value the next

00:09:54,040 --> 00:10:01,360
time you call the summer team yes

00:09:58,120 --> 00:10:04,390
constant folding the compiler very

00:10:01,360 --> 00:10:07,180
handily said 0 X is constant and the 10

00:10:04,390 --> 00:10:08,860
meg is a constant let's build you a 10

00:10:07,180 --> 00:10:10,449
meg constant string and I'm just going

00:10:08,860 --> 00:10:11,980
to keep it here to one side so when you

00:10:10,449 --> 00:10:14,620
call the function I can just copy it

00:10:11,980 --> 00:10:17,529
into the value you want that's where

00:10:14,620 --> 00:10:20,529
your 20 mega is but we've never had a

00:10:17,529 --> 00:10:22,690
way to see this here's another example

00:10:20,529 --> 00:10:25,630
of the same thing 10 meg string but this

00:10:22,690 --> 00:10:27,130
time we recurse now we're accursed 50

00:10:25,630 --> 00:10:35,040
times and now there's a gigabyte what's

00:10:27,130 --> 00:10:39,329
going on there well every

00:10:35,040 --> 00:10:41,250
recursion level has its own pad so what

00:10:39,329 --> 00:10:43,230
we saw happened before with the

00:10:41,250 --> 00:10:46,070
preservation of the buffer of de lavar

00:10:43,230 --> 00:10:48,660
that happens at every level of recursion

00:10:46,070 --> 00:10:52,339
so if you have recursive subs that have

00:10:48,660 --> 00:10:55,050
a lot of throwing strings around a lot

00:10:52,339 --> 00:10:58,620
it's very expensive but we have no way

00:10:55,050 --> 00:11:00,990
of seeing it what we need is a way to

00:10:58,620 --> 00:11:02,550
look inside the box take off lift the

00:11:00,990 --> 00:11:05,850
hood sort of poke about to see what's

00:11:02,550 --> 00:11:07,500
going on so the only sensible way dawned

00:11:05,850 --> 00:11:09,329
on me last year was that we just have to

00:11:07,500 --> 00:11:12,300
call the whole thing call all the

00:11:09,329 --> 00:11:14,880
pointers and develop men so I devel size

00:11:12,300 --> 00:11:16,350
has the logic so what I needed to do is

00:11:14,880 --> 00:11:18,149
to extend it with the callback cook so I

00:11:16,350 --> 00:11:20,310
could kind of hit your lift as it falls

00:11:18,149 --> 00:11:22,529
around around the pointers and needed

00:11:20,310 --> 00:11:26,970
some way of naming where I was as I

00:11:22,529 --> 00:11:29,339
called call during on the tree don't the

00:11:26,970 --> 00:11:31,410
stuff to disc store it process it

00:11:29,339 --> 00:11:35,040
manipulated eyes it back kind of stuff

00:11:31,410 --> 00:11:39,600
all very experimental would you like to

00:11:35,040 --> 00:11:42,930
see it okay live demo what could go

00:11:39,600 --> 00:11:45,269
wrong ok now I'm actually can do lots of

00:11:42,930 --> 00:11:46,829
little live demos and this used to drive

00:11:45,269 --> 00:11:48,959
you nuts i wrote a script to do the live

00:11:46,829 --> 00:11:52,410
demos for me so it's not quite as

00:11:48,959 --> 00:11:54,449
dangerous so develop sighs me it's the

00:11:52,410 --> 00:11:56,220
interface is a bit funky at the moment

00:11:54,449 --> 00:11:58,250
if you don't set the size me environment

00:11:56,220 --> 00:12:01,529
variable it acts just like devel size

00:11:58,250 --> 00:12:03,180
mostly so i said that develop seismic

00:12:01,529 --> 00:12:06,300
variable and i say give me the total

00:12:03,180 --> 00:12:08,880
size of this integer so there is your IV

00:12:06,300 --> 00:12:12,269
and there's the address of the RV and

00:12:08,880 --> 00:12:17,209
there's a 24 bite head now let's try

00:12:12,269 --> 00:12:22,769
string all increase the size yes hey

00:12:17,209 --> 00:12:25,680
okay so we have 24 x 16 x body 13 x s

00:12:22,769 --> 00:12:27,750
feelin totalling 53 now we'll do a

00:12:25,680 --> 00:12:30,569
random number and then you have the head

00:12:27,750 --> 00:12:31,589
and an eight by body now we're going to

00:12:30,569 --> 00:12:32,910
do a random number that we're going to

00:12:31,589 --> 00:12:35,939
string if I we're going to use the

00:12:32,910 --> 00:12:38,069
number in the string and now we have the

00:12:35,939 --> 00:12:40,840
the head 24 but the body has been

00:12:38,069 --> 00:12:43,480
upgraded it's been upgraded from an end

00:12:40,840 --> 00:12:45,880
e2 pnv so it's gone up from eight bytes

00:12:43,480 --> 00:12:48,870
to 32 bytes and there we have the length

00:12:45,880 --> 00:12:53,920
of the cache string representation

00:12:48,870 --> 00:12:55,660
arrays to be okay now we're getting

00:12:53,920 --> 00:12:57,640
somewhere so we have an array and

00:12:55,660 --> 00:13:00,640
there's the head and the body and the

00:12:57,640 --> 00:13:04,030
buffer for the all the pointers three

00:13:00,640 --> 00:13:07,410
elements an integer and a string and a

00:13:04,030 --> 00:13:10,300
number and then if you notice it kind of

00:13:07,410 --> 00:13:13,000
annotates this information as its output

00:13:10,300 --> 00:13:14,650
and there's various other bits and

00:13:13,000 --> 00:13:20,440
pieces as sequence numbers and depths

00:13:14,650 --> 00:13:22,180
and things like that ok now that text is

00:13:20,440 --> 00:13:25,270
coming out of develops Isaac seism

00:13:22,180 --> 00:13:28,510
itself if you pipe the output to a

00:13:25,270 --> 00:13:31,330
program then it writes out the same

00:13:28,510 --> 00:13:33,250
information but as tokens so that less

00:13:31,330 --> 00:13:35,770
you write a program another program to

00:13:33,250 --> 00:13:38,010
very store that will read the tokens and

00:13:35,770 --> 00:13:40,390
manipulate the data as it passes through

00:13:38,010 --> 00:13:41,770
so this looks very much like the one you

00:13:40,390 --> 00:13:44,590
saw before but this has gone through

00:13:41,770 --> 00:13:46,290
some tree pressure processing how you

00:13:44,590 --> 00:13:50,670
can actually see what it's done but it's

00:13:46,290 --> 00:13:54,400
there because you can then write

00:13:50,670 --> 00:13:57,580
different data outputs now this

00:13:54,400 --> 00:13:59,260
information it gets really old looking

00:13:57,580 --> 00:14:00,880
at pages of this you can't really sort

00:13:59,260 --> 00:14:03,360
of see how big the substructures are

00:14:00,880 --> 00:14:07,210
what you need to do is visualize

00:14:03,360 --> 00:14:09,820
catching so those your array with your

00:14:07,210 --> 00:14:10,960
three elements and your integer and your

00:14:09,820 --> 00:14:14,740
number and your size you can see the

00:14:10,960 --> 00:14:18,250
size is there and then totaled up that's

00:14:14,740 --> 00:14:22,390
sweet now let's try it with an array of

00:14:18,250 --> 00:14:25,360
two hashes so there's an array two

00:14:22,390 --> 00:14:28,000
references two hashes with an one

00:14:25,360 --> 00:14:31,830
element each integer integer and here

00:14:28,000 --> 00:14:35,740
you can see that the hash key is shared

00:14:31,830 --> 00:14:37,600
ok now that so this was seeing twice one

00:14:35,740 --> 00:14:39,190
of them has a solid line one of them has

00:14:37,600 --> 00:14:40,270
a dash line and the dash line so well

00:14:39,190 --> 00:14:43,090
this is an alternative route to

00:14:40,270 --> 00:14:46,260
something that I've seen before the

00:14:43,090 --> 00:14:48,520
software needs to get smarter about

00:14:46,260 --> 00:14:51,190
picking which of the alternative route

00:14:48,520 --> 00:14:54,389
is gives the best name and that's kind

00:14:51,190 --> 00:14:59,549
of something I haven't got into yet

00:14:54,389 --> 00:14:59,549
so another thing that we can do now is

00:14:59,699 --> 00:15:06,549
developed eyes has very hard to

00:15:04,239 --> 00:15:09,429
understand logic about what pointers to

00:15:06,549 --> 00:15:11,589
follow devel sighs me is now driven by

00:15:09,429 --> 00:15:12,879
ref counting so effectively you're

00:15:11,589 --> 00:15:15,129
answering the question how much memory

00:15:12,879 --> 00:15:17,799
would be freed up if I destroyed this

00:15:15,129 --> 00:15:19,929
thing i'm passing to you so because

00:15:17,799 --> 00:15:23,049
we're checking all all the references we

00:15:19,929 --> 00:15:25,179
can see when we get to something that we

00:15:23,049 --> 00:15:27,850
don't get all the references to we don't

00:15:25,179 --> 00:15:30,220
see all the references so here is a

00:15:27,850 --> 00:15:32,679
reference to an array that we haven't

00:15:30,220 --> 00:15:34,419
completely seen so we don't own it so

00:15:32,679 --> 00:15:36,730
we're going to identify it here and show

00:15:34,419 --> 00:15:40,600
the ref count but not actually traverse

00:15:36,730 --> 00:15:42,730
into it now let's have some fun haha

00:15:40,600 --> 00:15:45,609
subroutine what does a subroutine look

00:15:42,730 --> 00:15:48,220
like well there you are that's what a

00:15:45,609 --> 00:15:50,829
pearl subroutine looks like so you have

00:15:48,220 --> 00:15:53,819
a cv this is the cv outside for those

00:15:50,829 --> 00:15:56,319
who know the internals there's the ops

00:15:53,819 --> 00:15:59,259
I'll talk about that mins like a pad

00:15:56,319 --> 00:16:01,989
list so those the names of the pad and

00:15:59,259 --> 00:16:05,049
there's the my ex and then here's your

00:16:01,989 --> 00:16:06,669
your pad and bum bubble bum so you can

00:16:05,049 --> 00:16:10,720
see even in that little factorial

00:16:06,669 --> 00:16:12,970
function my shift X returned and out of

00:16:10,720 --> 00:16:15,519
that few variables one line of code one

00:16:12,970 --> 00:16:17,049
line a very simple code your pad has a

00:16:15,519 --> 00:16:20,519
whole bunch of bits and pieces in in

00:16:17,049 --> 00:16:23,350
there and then up here that's the blob

00:16:20,519 --> 00:16:27,850
okay now you see this even this one line

00:16:23,350 --> 00:16:29,559
piece of code has three cop files now

00:16:27,850 --> 00:16:32,679
the files are used to record the

00:16:29,559 --> 00:16:34,299
name of the source file so if your

00:16:32,679 --> 00:16:35,709
source file is down some long path each

00:16:34,299 --> 00:16:37,539
one of those will be a long path now

00:16:35,709 --> 00:16:41,230
this pearl i'm using is a threaded pearl

00:16:37,539 --> 00:16:43,989
and I filed a bug report recently to say

00:16:41,230 --> 00:16:46,839
hey threaded pearl is using vast amounts

00:16:43,989 --> 00:16:49,350
of memory to record the name of the file

00:16:46,839 --> 00:16:52,749
for every single statement in the file

00:16:49,350 --> 00:16:55,600
we're talking hundreds of kilobytes so

00:16:52,749 --> 00:16:57,249
hopefully they will be fixed in 520 and

00:16:55,600 --> 00:17:00,080
that was shown up by being able to

00:16:57,249 --> 00:17:03,890
visualize this stuff

00:17:00,080 --> 00:17:05,180
so let's now now it's the same function

00:17:03,890 --> 00:17:06,410
but i'm going to call it so the only

00:17:05,180 --> 00:17:09,980
difference here is i'm calling this

00:17:06,410 --> 00:17:12,200
recursive function and now it's off the

00:17:09,980 --> 00:17:18,380
charts so here you can see your three

00:17:12,200 --> 00:17:19,550
pads well I've killed it Brett okay and

00:17:18,380 --> 00:17:21,050
all they were getting calm it's

00:17:19,550 --> 00:17:24,230
complicated here that'd be smoke coming

00:17:21,050 --> 00:17:26,600
out see okay so here you can see your

00:17:24,230 --> 00:17:29,540
pad one pad to pad 3 and again the being

00:17:26,600 --> 00:17:32,780
totaled up so now this function only has

00:17:29,540 --> 00:17:36,770
one variable but every level of pad is

00:17:32,780 --> 00:17:38,390
using like 2-300 bites and you can see

00:17:36,770 --> 00:17:41,000
here it all gets a bit complicated with

00:17:38,390 --> 00:17:44,570
all these pointers but because some of

00:17:41,000 --> 00:17:47,150
the values are shared Oh what's going on

00:17:44,570 --> 00:17:51,560
there it's all going to end in tears

00:17:47,150 --> 00:17:59,150
okay so how about we look at a whole

00:17:51,560 --> 00:18:04,870
package this is not working sometimes

00:17:59,150 --> 00:18:16,130
the graph is on this gets a bit upset

00:18:04,870 --> 00:18:21,260
actually I could do put them Ching okay

00:18:16,130 --> 00:18:26,240
and start that again get back to where I

00:18:21,260 --> 00:18:31,190
was right exporter so this is the whole

00:18:26,240 --> 00:18:33,770
of the exporter now you see here there's

00:18:31,190 --> 00:18:38,150
like a lot of detail and it's getting a

00:18:33,770 --> 00:18:40,100
bit crazy so these hash the hex and the

00:18:38,150 --> 00:18:41,840
he's that kind of make up the components

00:18:40,100 --> 00:18:47,210
of the hash they're not terribly

00:18:41,840 --> 00:18:50,990
interesting okay I just won't touch the

00:18:47,210 --> 00:18:53,420
keyboard heavily Wow and also there's

00:18:50,990 --> 00:18:55,400
all these cop files around somewhere

00:18:53,420 --> 00:18:57,950
wherever they go oh no I think I've

00:18:55,400 --> 00:18:59,300
hidden lose now yes nope the here cop

00:18:57,950 --> 00:19:00,680
files so it's like there's a lot of

00:18:59,300 --> 00:19:03,230
detail so it's getting hard to see the

00:19:00,680 --> 00:19:07,040
bits you're interested in so i added a

00:19:03,230 --> 00:19:09,050
mechanism oops haha that's what we're

00:19:07,040 --> 00:19:10,260
going to work now i added a mechanism

00:19:09,050 --> 00:19:12,570
here we go

00:19:10,260 --> 00:19:16,100
just hide bits that you weren't

00:19:12,570 --> 00:19:21,510
interested in so now cross your fingers

00:19:16,100 --> 00:19:23,550
yay so now this is the same thing and it

00:19:21,510 --> 00:19:25,140
started build the tension this is the

00:19:23,550 --> 00:19:27,930
same thing but without some of the

00:19:25,140 --> 00:19:33,350
detail but still it's kind of getting

00:19:27,930 --> 00:19:33,350
hard that's going to get old isn't a

00:19:34,670 --> 00:19:43,140
little wires okay it's still you can see

00:19:41,490 --> 00:19:49,590
it's kind of give it hard to visualize

00:19:43,140 --> 00:19:53,280
if you imagine a big program it gets up

00:19:49,590 --> 00:19:59,370
right I'll just described the diagrams

00:19:53,280 --> 00:20:03,180
okay so now that was exporter how about

00:19:59,370 --> 00:20:06,180
we try main now this is very likely to

00:20:03,180 --> 00:20:10,860
kill graph is so so how big do you think

00:20:06,180 --> 00:20:16,770
mains going to be well it's so big that

00:20:10,860 --> 00:20:19,560
you have to do that there is main now

00:20:16,770 --> 00:20:23,130
this this is a program that does nothing

00:20:19,560 --> 00:20:27,390
this is just yeah there's nothing here

00:20:23,130 --> 00:20:29,580
so this is it was kind of very pretty

00:20:27,390 --> 00:20:31,080
and useful at when it's small it's kind

00:20:29,580 --> 00:20:32,670
of impressive and useful but at this

00:20:31,080 --> 00:20:38,310
stage it's just impressive but it ceases

00:20:32,670 --> 00:20:40,470
to be useful which isn't good I don't

00:20:38,310 --> 00:20:44,630
like you know an impressive is good but

00:20:40,470 --> 00:20:44,630
useful is better so

00:20:44,800 --> 00:20:49,920
so what we've been doing so far is

00:20:48,250 --> 00:20:52,870
tippling the size of a data structure

00:20:49,920 --> 00:20:55,120
but you can also size the whole Perl

00:20:52,870 --> 00:20:56,800
interpreter apply that logic to

00:20:55,120 --> 00:20:58,980
absolutely everything and there's a lot

00:20:56,800 --> 00:21:01,090
of stuff that you can might not think of

00:20:58,980 --> 00:21:02,380
when when you think of a Perl

00:21:01,090 --> 00:21:04,360
interpreter you think of your stuff you

00:21:02,380 --> 00:21:06,210
can give your packages new variables but

00:21:04,360 --> 00:21:10,210
there's a lot going on behind the scenes

00:21:06,210 --> 00:21:12,370
so I'm not even going to try to render

00:21:10,210 --> 00:21:14,830
that because it would just be crazy so

00:21:12,370 --> 00:21:17,230
that's half a meg spread over 5,000

00:21:14,830 --> 00:21:19,480
nudes and you know once you get to about

00:21:17,230 --> 00:21:23,890
2,000 nodes then graph is just kind of

00:21:19,480 --> 00:21:25,000
gets very sad so what we do now rather

00:21:23,890 --> 00:21:27,640
than writing a doc file will write a

00:21:25,000 --> 00:21:29,200
database the sequel database and rather

00:21:27,640 --> 00:21:30,790
than doing a pearl size you can go one

00:21:29,200 --> 00:21:33,240
level higher up and there's a heap size

00:21:30,790 --> 00:21:35,680
function that also includes the

00:21:33,240 --> 00:21:37,290
information from Malik if you have a

00:21:35,680 --> 00:21:39,910
Malik that can tell you that information

00:21:37,290 --> 00:21:42,510
so what do you do with the database well

00:21:39,910 --> 00:21:46,780
what you do with the database is you

00:21:42,510 --> 00:21:50,830
visualize it with a tree map so I have

00:21:46,780 --> 00:21:53,530
this little little web server and it's

00:21:50,830 --> 00:21:55,660
visualizing your tree of information

00:21:53,530 --> 00:22:01,150
that you've seen as a dream app and here

00:21:55,660 --> 00:22:02,770
you can see 10 meg in any heap most of

00:22:01,150 --> 00:22:04,480
which is milk and then you pull into up

00:22:02,770 --> 00:22:06,640
to here and inside the map you can drill

00:22:04,480 --> 00:22:09,450
down and you can see well there's five

00:22:06,640 --> 00:22:13,360
mega free space sitting inside milk and

00:22:09,450 --> 00:22:15,870
this three megabytes is the difference

00:22:13,360 --> 00:22:19,240
between everything that I've sized up

00:22:15,870 --> 00:22:21,880
here and what may log says has been

00:22:19,240 --> 00:22:23,320
allocated so that's three Meg that I

00:22:21,880 --> 00:22:25,270
haven't accounted for yet so I'm going

00:22:23,320 --> 00:22:26,410
to keep trying to working to reduce that

00:22:25,270 --> 00:22:27,670
but let's have a look inside the Perl

00:22:26,410 --> 00:22:32,140
interpreter because that's much more

00:22:27,670 --> 00:22:35,830
interesting so pull interpreter ah main

00:22:32,140 --> 00:22:38,260
others freed main is kind of where

00:22:35,830 --> 00:22:39,880
you're at stephs Tash that's where all

00:22:38,260 --> 00:22:42,850
your package stuff is such your main

00:22:39,880 --> 00:22:47,350
stash others i'll get back to in a

00:22:42,850 --> 00:22:49,540
second so here's your main the pre

00:22:47,350 --> 00:22:51,580
library oh yeah this this I was loading

00:22:49,540 --> 00:22:53,830
mu so that you might have seen in the

00:22:51,580 --> 00:22:56,789
example down here this was loading

00:22:53,830 --> 00:22:59,740
just for the sake of loading something

00:22:56,789 --> 00:23:04,059
look let's overlook we can make that a

00:22:59,740 --> 00:23:08,080
bit bigger but but can you read that at

00:23:04,059 --> 00:23:11,049
the back okay well too bad you'll have

00:23:08,080 --> 00:23:15,700
to come forward but just be grateful is

00:23:11,049 --> 00:23:18,399
on screen at all ok so there's be and

00:23:15,700 --> 00:23:20,470
dinah loader and base and constant and

00:23:18,399 --> 00:23:22,659
obviously the size of the box is how

00:23:20,470 --> 00:23:24,399
much memory is being used and then over

00:23:22,659 --> 00:23:25,750
here is just a bunch of internal stuff

00:23:24,399 --> 00:23:29,169
I'm dumping there for the sake of making

00:23:25,750 --> 00:23:31,510
it visible and you can drill down so you

00:23:29,169 --> 00:23:35,679
can click on one that one of these B

00:23:31,510 --> 00:23:38,289
section output and basically it boils

00:23:35,679 --> 00:23:39,850
down to just clicking on clicking on the

00:23:38,289 --> 00:23:42,100
biggest box and you click on the biggest

00:23:39,850 --> 00:23:46,019
box ago oh why is that using so much

00:23:42,100 --> 00:23:48,940
memory so here you can see this is a CV

00:23:46,019 --> 00:23:50,380
and you see a path up up here with kind

00:23:48,940 --> 00:23:53,320
of the nodes and the links between them

00:23:50,380 --> 00:23:56,049
ops so you see there's five kilobytes of

00:23:53,320 --> 00:23:59,169
ops in the output function of the beast

00:23:56,049 --> 00:24:01,000
ash yeah all purpose let's look at a pad

00:23:59,169 --> 00:24:03,250
list so you just kind of wandered around

00:24:01,000 --> 00:24:05,139
you know it's like going for a walk and

00:24:03,250 --> 00:24:09,909
seeing where all the members being used

00:24:05,139 --> 00:24:11,380
now if we're lucky mmm that was the demo

00:24:09,909 --> 00:24:13,419
I hope would get working but it's not

00:24:11,380 --> 00:24:19,019
going to that was a production machine

00:24:13,419 --> 00:24:23,679
that I've done assigns me of some XML

00:24:19,019 --> 00:24:26,350
processing okay let's nip back up to the

00:24:23,679 --> 00:24:28,659
Perl interpreter and peek into the

00:24:26,350 --> 00:24:33,970
others any questions so far how much

00:24:28,659 --> 00:24:40,210
time do I have how much time is left 17

00:24:33,970 --> 00:24:42,639
minutes excellent okay so others now

00:24:40,210 --> 00:24:47,320
devel sighs me works by following the

00:24:42,639 --> 00:24:50,200
references so when you ask for the Pearl

00:24:47,320 --> 00:24:52,600
sighs it starts def stash and does all

00:24:50,200 --> 00:24:54,789
that never thing else I can find but it

00:24:52,600 --> 00:24:57,370
will stop whenever it comes to something

00:24:54,789 --> 00:24:58,899
that has a ref count greater than the

00:24:57,370 --> 00:25:00,730
number of times it's seen it then it

00:24:58,899 --> 00:25:02,049
just sort of bumps up the number of

00:25:00,730 --> 00:25:04,600
times it's seen it and goes off and

00:25:02,049 --> 00:25:05,210
looks elsewhere so if you have a

00:25:04,600 --> 00:25:08,160
reference

00:25:05,210 --> 00:25:10,500
at the moment it waits until it's

00:25:08,160 --> 00:25:13,140
looking through the arenas that kind of

00:25:10,500 --> 00:25:15,660
the structures that have all the SVS and

00:25:13,140 --> 00:25:17,910
it says okay is there anything that I

00:25:15,660 --> 00:25:19,410
saw but didn't see enough and this is ok

00:25:17,910 --> 00:25:25,170
that must be a ref loop so I'll go and

00:25:19,410 --> 00:25:27,300
break the ref loop in future what I need

00:25:25,170 --> 00:25:29,280
to do is kind of rework this so that at

00:25:27,300 --> 00:25:31,800
that point the data that comes out

00:25:29,280 --> 00:25:34,140
should be repented to the appropriate

00:25:31,800 --> 00:25:35,490
place in the trees at the moment it's

00:25:34,140 --> 00:25:37,260
kind of off to one side in this wreck

00:25:35,490 --> 00:25:41,970
loops and I'm not going to click on this

00:25:37,260 --> 00:25:43,740
because if I do it'll just died in in in

00:25:41,970 --> 00:25:45,480
pain because if you have something that

00:25:43,740 --> 00:25:47,280
has lots and lots and lots of structures

00:25:45,480 --> 00:25:50,580
from that's just a few but sometimes you

00:25:47,280 --> 00:25:52,920
can have tens of thousands then the

00:25:50,580 --> 00:25:56,070
browser gets upset doesn't like dealing

00:25:52,920 --> 00:25:59,510
with tens of thousands of of divs this

00:25:56,070 --> 00:26:02,670
is your string table whenever you

00:25:59,510 --> 00:26:04,410
whenever you have a hash key and pearl

00:26:02,670 --> 00:26:06,330
that's shared you might remember that

00:26:04,410 --> 00:26:08,550
from an earlier slide their shared in

00:26:06,330 --> 00:26:11,190
something called the string table so

00:26:08,550 --> 00:26:12,180
this is the string table that's all the

00:26:11,190 --> 00:26:15,240
stuff that we didn't account for

00:26:12,180 --> 00:26:18,540
elsewhere subjects forth are progressive

00:26:15,240 --> 00:26:20,220
hmm not sure where that's they but

00:26:18,540 --> 00:26:22,650
anyway this is kind of a dumping ground

00:26:20,220 --> 00:26:28,040
for stuff that I haven't sorted out

00:26:22,650 --> 00:26:28,040
better homes for yet any questions

00:26:31,920 --> 00:26:37,680
colors you'll see colors shortly but I

00:26:35,130 --> 00:26:40,410
haven't got round to actually colorizing

00:26:37,680 --> 00:26:41,610
this in Nice ways but our there's

00:26:40,410 --> 00:26:45,120
another visualization I'll show you

00:26:41,610 --> 00:26:46,530
surely all it flame graph has colors

00:26:45,120 --> 00:26:49,710
yeah you're in the wrong presentation

00:26:46,530 --> 00:26:54,030
that was last year yeah photograph is so

00:26:49,710 --> 00:26:56,340
old now so this this will be nicely

00:26:54,030 --> 00:27:01,380
colored and polished up my javascript

00:26:56,340 --> 00:27:07,190
and HTML skills are not great okay any

00:27:01,380 --> 00:27:14,010
other questions will this be useful

00:27:07,190 --> 00:27:16,440
awesome ok so the tree map is it's very

00:27:14,010 --> 00:27:18,540
scalable now you can throw a lot of Dade

00:27:16,440 --> 00:27:20,610
rabbit and just drill down works very

00:27:18,540 --> 00:27:24,090
nicely but it's a very narrow

00:27:20,610 --> 00:27:26,430
perspective he just at one point in the

00:27:24,090 --> 00:27:31,020
tree looking at what's below you in the

00:27:26,430 --> 00:27:32,790
tree excuse me what I've always wanted

00:27:31,020 --> 00:27:35,070
to be able to do since I got into this

00:27:32,790 --> 00:27:38,100
was to actually to visualize the whole

00:27:35,070 --> 00:27:43,560
tree in like the way you can do with

00:27:38,100 --> 00:27:45,420
graph is but on a grander scale so one

00:27:43,560 --> 00:27:49,350
of the other things the store can do is

00:27:45,420 --> 00:27:53,220
write a je XF file so I'll get it to do

00:27:49,350 --> 00:27:57,420
that and a button put up with them and

00:27:53,220 --> 00:27:59,850
it writes that out and then Ching starts

00:27:57,420 --> 00:28:06,600
giphy or jiffy depending what side of

00:27:59,850 --> 00:28:10,740
the pond Iran and now okay i'm going to

00:28:06,600 --> 00:28:12,350
import that file and there is your perl

00:28:10,740 --> 00:28:18,200
interpreter

00:28:12,350 --> 00:28:22,660
isn't it pretty okay let's let's make it

00:28:18,200 --> 00:28:24,770
a little bigger okay slightly put it and

00:28:22,660 --> 00:28:31,340
let's do something more interesting

00:28:24,770 --> 00:28:36,169
let's partition by the type whoa now is

00:28:31,340 --> 00:28:39,799
it pretty colors okay now let's do some

00:28:36,169 --> 00:28:44,740
ranking by the size which use a rank

00:28:39,799 --> 00:28:50,299
parameter of the size now is it pretty

00:28:44,740 --> 00:28:51,470
ok now let's let's scale that up

00:28:50,299 --> 00:28:52,490
watching there's no point scale it up

00:28:51,470 --> 00:28:57,470
because what I'm going to do now is I'm

00:28:52,490 --> 00:29:01,270
going to do a layout I like this but

00:28:57,470 --> 00:29:01,270
this is my favorite bit of the Demi

00:29:20,610 --> 00:29:31,240
this is is well every point here is a

00:29:28,240 --> 00:29:34,780
data structure and every line is a

00:29:31,240 --> 00:29:36,880
pointer and the data is the data from a

00:29:34,780 --> 00:29:42,550
Perl interpreter that has just loaded

00:29:36,880 --> 00:29:44,350
knew nothing else not a big job and what

00:29:42,550 --> 00:29:47,370
that was doing is laying out the network

00:29:44,350 --> 00:29:51,460
trying to lay it out in a way that

00:29:47,370 --> 00:29:56,230
allows you to see structure clusters now

00:29:51,460 --> 00:29:58,450
you know we have the coloring but really

00:29:56,230 --> 00:30:00,160
it's kind of this is one of those things

00:29:58,450 --> 00:30:03,610
that's still much more on the impressive

00:30:00,160 --> 00:30:05,110
sight than the useful side but let's see

00:30:03,610 --> 00:30:08,650
if we can make it a little more useful

00:30:05,110 --> 00:30:10,110
oh yes yeah I should explain what these

00:30:08,650 --> 00:30:15,850
things out let's find out what they are

00:30:10,110 --> 00:30:18,730
so that is what is that like three yeah

00:30:15,850 --> 00:30:21,430
that's the bite three so that's that's

00:30:18,730 --> 00:30:25,480
the space sitting inside milk the pearl

00:30:21,430 --> 00:30:31,990
used to do the compiling but then freed

00:30:25,480 --> 00:30:33,160
it back this yeah it's the size of the

00:30:31,990 --> 00:30:36,130
data structure now most of the data

00:30:33,160 --> 00:30:37,980
structures are just tiny you know so

00:30:36,130 --> 00:30:42,899
small that I can barely click on the

00:30:37,980 --> 00:30:50,960
button okay there you go

00:30:42,899 --> 00:30:50,960
yeah okay but this one what's that one

00:30:52,009 --> 00:31:07,139
what is that same label s feeling trim I

00:30:56,429 --> 00:31:08,969
have no idea what that is I don't think

00:31:07,139 --> 00:31:14,039
it's letting me click on this I don't

00:31:08,969 --> 00:31:21,499
know why it's confused so let's see if

00:31:14,039 --> 00:31:28,070
we can scale to node sighs give me

00:31:21,499 --> 00:31:30,059
labels now so going to work so this is

00:31:28,070 --> 00:31:34,710
this is kind of where I'm at at the

00:31:30,059 --> 00:31:37,139
moment hoop as a label by tree I'm going

00:31:34,710 --> 00:31:38,729
to shout that back at Becky now these

00:31:37,139 --> 00:31:42,179
things I think that remember these being

00:31:38,729 --> 00:31:46,019
yeah these are what are they what are

00:31:42,179 --> 00:31:47,879
you so what I need clearly this is kind

00:31:46,019 --> 00:31:49,979
of great fun to play with but I need to

00:31:47,879 --> 00:31:52,019
tip the balance now between impressive

00:31:49,979 --> 00:31:54,119
and useful because there's a lot of

00:31:52,019 --> 00:31:56,190
information also I suspect there's just

00:31:54,119 --> 00:32:01,009
too much information so this one in the

00:31:56,190 --> 00:32:04,440
middle here is I think the string table

00:32:01,009 --> 00:32:06,089
so it's like you know every every key of

00:32:04,440 --> 00:32:09,690
every hash in every data structure in

00:32:06,089 --> 00:32:11,789
the entire in terms of that so yeah it's

00:32:09,690 --> 00:32:14,519
not terribly useful so what I need to do

00:32:11,789 --> 00:32:20,089
is work on filtering so that you can

00:32:14,519 --> 00:32:22,529
actually see see the wood for the trees

00:32:20,089 --> 00:32:25,229
and the coloring is nice and I can

00:32:22,529 --> 00:32:27,809
polish that up so but it's kind of hard

00:32:25,229 --> 00:32:29,669
to see also the kind of the the size of

00:32:27,809 --> 00:32:32,239
the dots should probably be logarithmic

00:32:29,669 --> 00:32:35,129
rather than linear and things like that

00:32:32,239 --> 00:32:37,979
so there's a lot of polish to do I've

00:32:35,129 --> 00:32:41,219
been feverishly working to get it to

00:32:37,979 --> 00:32:43,109
this stage for today ah but there's a

00:32:41,219 --> 00:32:44,549
lot more so if you're interested in

00:32:43,109 --> 00:32:47,339
helping out with this because like I say

00:32:44,549 --> 00:32:49,289
my my javascript and HTML skills are

00:32:47,339 --> 00:32:51,059
very weak so if you want to help out on

00:32:49,289 --> 00:32:53,940
the pre map site that would be awesome

00:32:51,059 --> 00:32:55,820
if you're familiar with jeffy then we

00:32:53,940 --> 00:32:58,700
awesome have some help there

00:32:55,820 --> 00:33:01,460
data visualization but clearly there's a

00:32:58,700 --> 00:33:03,620
lot of potential here to actually see

00:33:01,460 --> 00:33:07,850
what the issues are so coming back to

00:33:03,620 --> 00:33:11,720
that XML parsing problem we had some big

00:33:07,850 --> 00:33:14,000
job that was taking huntin say gigabyte

00:33:11,720 --> 00:33:15,950
of space and there were lots of them

00:33:14,000 --> 00:33:18,130
running and it was using up the memory

00:33:15,950 --> 00:33:20,990
and it turned out that the problem was

00:33:18,130 --> 00:33:22,700
pausing a big XML document you know one

00:33:20,990 --> 00:33:25,340
that I started out small years ago but

00:33:22,700 --> 00:33:27,710
was now very big and it was pausing it

00:33:25,340 --> 00:33:30,020
creating a data structure and then

00:33:27,710 --> 00:33:32,260
freeing the data structure but of course

00:33:30,020 --> 00:33:35,570
you ended up with massive amounts of

00:33:32,260 --> 00:33:38,570
free heads and bodies that weren't being

00:33:35,570 --> 00:33:41,120
reused so we're just going to change it

00:33:38,570 --> 00:33:43,550
to a screaming pazza and that's the kind

00:33:41,120 --> 00:33:45,920
of insight that we haven't been able to

00:33:43,550 --> 00:33:47,690
see before and it was very obvious that

00:33:45,920 --> 00:33:50,450
there was a lot of information sitting

00:33:47,690 --> 00:33:55,250
in the the freed heads let me go back to

00:33:50,450 --> 00:33:56,990
the tree map put interpreter one of the

00:33:55,250 --> 00:34:00,110
other things you can do you're freed ok

00:33:56,990 --> 00:34:02,690
so you got a lot of stuff you freed it

00:34:00,110 --> 00:34:06,470
as far as you're concerned the memory is

00:34:02,690 --> 00:34:09,200
free but actually in here these are the

00:34:06,470 --> 00:34:12,830
free bodies these are the size of the

00:34:09,200 --> 00:34:14,390
arenas now there should be a count here

00:34:12,830 --> 00:34:16,310
but the council not working moment to

00:34:14,390 --> 00:34:19,310
tell you how many free bodies there are

00:34:16,310 --> 00:34:21,800
sitting there one of these is probably

00:34:19,310 --> 00:34:24,530
yeah there's the SV heads so if you

00:34:21,800 --> 00:34:26,840
create lots of variables and then you

00:34:24,530 --> 00:34:28,730
free them again you'd find lots of free

00:34:26,840 --> 00:34:35,950
heads here plus lots of whatever kind of

00:34:28,730 --> 00:34:35,950
body they were ok any questions

00:34:38,820 --> 00:34:44,370
so can I do this on any time during a

00:34:41,730 --> 00:34:49,710
live process DB single equals one and

00:34:44,370 --> 00:34:51,450
then yeah yep so at the moment devel

00:34:49,710 --> 00:34:53,640
sighs me you can call the function like

00:34:51,450 --> 00:34:56,670
you've seen see me doing and there's a

00:34:53,640 --> 00:34:59,340
hook set up sings hey pearl dash de

00:34:56,670 --> 00:35:03,090
colon sighs me and it will automatically

00:34:59,340 --> 00:35:07,740
call science me at the end time okay

00:35:03,090 --> 00:35:08,910
much like em develop MIT profitez so

00:35:07,740 --> 00:35:12,300
that's great that's kind of a very

00:35:08,910 --> 00:35:15,120
simple way of doing it you can also call

00:35:12,300 --> 00:35:17,040
the size bead functions in multiple

00:35:15,120 --> 00:35:18,720
places and each time it will write out

00:35:17,040 --> 00:35:20,370
the file you can use the environment

00:35:18,720 --> 00:35:23,280
variable to change where where it's

00:35:20,370 --> 00:35:26,700
going the data stream has a beginning

00:35:23,280 --> 00:35:28,490
and end token in it so it my intention

00:35:26,700 --> 00:35:33,090
is that you'll be able to stream

00:35:28,490 --> 00:35:40,550
multiple runs that visualization

00:35:33,090 --> 00:35:44,220
software actually supports streaming

00:35:40,550 --> 00:35:47,130
network changes so it ought to be

00:35:44,220 --> 00:35:51,420
possible to have this dynamically

00:35:47,130 --> 00:35:53,340
updated by your calling the heap of a

00:35:51,420 --> 00:35:55,410
running process you can say snapshot

00:35:53,340 --> 00:35:58,230
snapshot snapshot and this would update

00:35:55,410 --> 00:35:59,970
now there's huge technical hurdles in

00:35:58,230 --> 00:36:01,920
getting that to happen but it is

00:35:59,970 --> 00:36:04,620
possible so that they become an awesome

00:36:01,920 --> 00:36:07,410
demo you know that would be way up there

00:36:04,620 --> 00:36:08,670
on the impressive scale I'm not sure how

00:36:07,410 --> 00:36:14,100
useful it would be but it would just be

00:36:08,670 --> 00:36:16,590
awesome so yes I think that's answer to

00:36:14,100 --> 00:36:18,690
question the the token stream that the

00:36:16,590 --> 00:36:20,490
way it works I was actually very pleased

00:36:18,690 --> 00:36:22,800
with the way that worked out it's very

00:36:20,490 --> 00:36:25,260
efficient although it's chasing a

00:36:22,800 --> 00:36:27,300
bazillion pointers and writing out a lot

00:36:25,260 --> 00:36:29,340
information it's all done on the stack

00:36:27,300 --> 00:36:32,190
and there's no my logical or free during

00:36:29,340 --> 00:36:33,990
the process so it's blindingly fast the

00:36:32,190 --> 00:36:37,200
only limit is how fast I can stream out

00:36:33,990 --> 00:36:39,440
the tokens so if you if you pipe it to

00:36:37,200 --> 00:36:41,940
gzip for example then it's very quick

00:36:39,440 --> 00:36:44,670
now processing the tokens afterwards

00:36:41,940 --> 00:36:46,920
gets a lot slower but I haven't

00:36:44,670 --> 00:36:48,720
optimized that I just need to run a

00:36:46,920 --> 00:36:53,460
profiler maybe two

00:36:48,720 --> 00:37:08,369
optimized that I I haven't yet any other

00:36:53,460 --> 00:37:11,550
questions so what to do with the data

00:37:08,369 --> 00:37:13,619
the some data that's been freed is just

00:37:11,550 --> 00:37:15,060
one of the things that develops eyes me

00:37:13,619 --> 00:37:17,700
is showing you that we've never seen

00:37:15,060 --> 00:37:19,619
before so it's just it's an easy one for

00:37:17,700 --> 00:37:22,490
me to look at because all i've done in

00:37:19,619 --> 00:37:25,290
that program was load new you know so

00:37:22,490 --> 00:37:27,630
the free space shows up a lot because

00:37:25,290 --> 00:37:29,880
that's all the work the compiler did and

00:37:27,630 --> 00:37:30,990
then the compiler finished so there was

00:37:29,880 --> 00:37:33,180
a lot of the kind of work space for the

00:37:30,990 --> 00:37:34,290
compiler that's been freed but you know

00:37:33,180 --> 00:37:37,440
i haven't got the program to do

00:37:34,290 --> 00:37:38,940
something so if you had a program that

00:37:37,440 --> 00:37:41,460
have been doing something there would be

00:37:38,940 --> 00:37:43,619
a lot of data stashed in the program and

00:37:41,460 --> 00:37:45,660
in the pads and the references and the

00:37:43,619 --> 00:37:47,550
data structures so you would drill down

00:37:45,660 --> 00:37:51,570
through the tree map following the big

00:37:47,550 --> 00:37:57,780
boxes to see where the memory is does

00:37:51,570 --> 00:38:00,119
that answer your question give me

00:37:57,780 --> 00:38:08,330
another question give me another

00:38:00,119 --> 00:38:08,330
question yep

00:38:08,960 --> 00:38:17,150
and it is free day for both read that

00:38:13,020 --> 00:38:17,150
put your applications now using an

00:38:19,540 --> 00:38:25,400
if your if your application is only

00:38:23,990 --> 00:38:29,840
using a megabyte then you're a very

00:38:25,400 --> 00:38:33,140
fortunate person so that the the poll

00:38:29,840 --> 00:38:34,640
compiler here loading mu has freed up 10

00:38:33,140 --> 00:38:38,510
meg that it was using well while

00:38:34,640 --> 00:38:41,570
compiling 10 meg is peanuts yeah this is

00:38:38,510 --> 00:38:43,490
so as soon as you do real work in an

00:38:41,570 --> 00:38:45,500
application big enough to want to run

00:38:43,490 --> 00:38:47,240
devel saves me you know you're talking

00:38:45,500 --> 00:38:50,930
hundreds of megabytes and the freed

00:38:47,240 --> 00:38:53,240
spaces is a minor issue I it simply

00:38:50,930 --> 00:38:56,270
because it's an issue that I ran into in

00:38:53,240 --> 00:38:59,690
production recently where we didn't know

00:38:56,270 --> 00:39:01,460
where the memories face was why so much

00:38:59,690 --> 00:39:02,930
memory was was being used and the answer

00:39:01,460 --> 00:39:05,420
was it wasn't being used it had been

00:39:02,930 --> 00:39:08,360
freed but it had been freed back into

00:39:05,420 --> 00:39:10,730
the the Pearl arenas and milk so the

00:39:08,360 --> 00:39:12,050
process was still very big and Paul

00:39:10,730 --> 00:39:14,980
wasn't using it so it was just an

00:39:12,050 --> 00:39:18,800
example that I was quoting you know in

00:39:14,980 --> 00:39:21,860
most cases that you have reference leaks

00:39:18,800 --> 00:39:23,360
for example and so that would be data

00:39:21,860 --> 00:39:33,080
very much still in the pearl in

00:39:23,360 --> 00:39:37,760
interpreter perversion requirements it's

00:39:33,080 --> 00:39:41,600
actually / 58 up at the moment the the

00:39:37,760 --> 00:39:45,280
internals are hairy to put it mildly and

00:39:41,600 --> 00:39:48,050
it breaks encapsulation in so many ways

00:39:45,280 --> 00:39:49,280
it's really quite embarrassing but

00:39:48,050 --> 00:39:51,200
there's there's there's no choice

00:39:49,280 --> 00:39:53,840
because it just has to be down in the

00:39:51,200 --> 00:39:54,920
guts of pearl and has to do things in

00:39:53,840 --> 00:39:58,250
different ways for the different

00:39:54,920 --> 00:40:03,890
versions of pearl but it does work on

00:39:58,250 --> 00:40:05,750
all versions of / 58 up there are some

00:40:03,890 --> 00:40:09,170
things that you can't see until more

00:40:05,750 --> 00:40:12,410
recent versions and like the arenas for

00:40:09,170 --> 00:40:13,850
example but i forget what version of

00:40:12,410 --> 00:40:18,140
Perl the arenas arrived in is probably

00:40:13,850 --> 00:40:20,300
5-10 so the reminder differences that

00:40:18,140 --> 00:40:24,170
way but basically works on all modern

00:40:20,300 --> 00:40:25,550
versions of pearl which i'm quite

00:40:24,170 --> 00:40:26,230
pleased about really into slightly

00:40:25,550 --> 00:40:28,359
surprised

00:40:26,230 --> 00:40:30,190
there's another question if you think

00:40:28,359 --> 00:40:35,800
multiple snapshots to be tools to

00:40:30,190 --> 00:40:37,840
visualize higher not yet so it would be

00:40:35,800 --> 00:40:40,119
very common a classic case would be a

00:40:37,840 --> 00:40:42,490
web server and you want to take a

00:40:40,119 --> 00:40:44,650
snapshot and fire some requests in take

00:40:42,490 --> 00:40:46,210
another snap shot and then visualize the

00:40:44,650 --> 00:40:48,220
difference and the answer is not at the

00:40:46,210 --> 00:40:50,950
moment but I'd love you to contribute

00:40:48,220 --> 00:40:53,710
one you know it's an interesting

00:40:50,950 --> 00:40:55,510
challenge it's not it's an interesting

00:40:53,710 --> 00:40:58,030
challenge even within a single process

00:40:55,510 --> 00:41:00,280
run because a lot of the structures

00:40:58,030 --> 00:41:03,970
should stay where they were at the last

00:41:00,280 --> 00:41:06,340
run but your scalars you know the scalar

00:41:03,970 --> 00:41:07,780
might have been freed and then reuse and

00:41:06,340 --> 00:41:09,580
it's being used for some something else

00:41:07,780 --> 00:41:11,830
so there's an interesting problem of

00:41:09,580 --> 00:41:15,220
trying to traverse two trees and work

00:41:11,830 --> 00:41:17,320
out what's actually changed you know so

00:41:15,220 --> 00:41:21,670
that's a good challenge but an

00:41:17,320 --> 00:41:26,250
interesting one how do you contribute so

00:41:21,670 --> 00:41:28,510
the code is on get up and there's a

00:41:26,250 --> 00:41:31,150
there's a bug tracker there's a mailing

00:41:28,510 --> 00:41:33,910
list and there's an IRC channel ha I've

00:41:31,150 --> 00:41:36,760
got it all set up for you it's in it's

00:41:33,910 --> 00:41:38,260
on cpap right now as I've been busy

00:41:36,760 --> 00:41:40,060
making releases and letting see pen

00:41:38,260 --> 00:41:43,960
testers tell me all the portability

00:41:40,060 --> 00:41:45,280
problems um so it's on Sipan and the

00:41:43,960 --> 00:41:48,010
details are in there the the

00:41:45,280 --> 00:41:50,980
documentation is is minimal and it's

00:41:48,010 --> 00:41:51,970
mostly up to date I so you know that's

00:41:50,980 --> 00:41:53,710
what I'm going to be doing after the

00:41:51,970 --> 00:41:54,880
talk now is just checking the

00:41:53,710 --> 00:41:57,369
documentation make sure it's all

00:41:54,880 --> 00:42:00,910
reasonably sane and pushing a another

00:41:57,369 --> 00:42:02,530
release but it's on on github so I hope

00:42:00,910 --> 00:42:05,320
to see you all in the IRC channel and

00:42:02,530 --> 00:42:07,750
send me lots of patches tell me where

00:42:05,320 --> 00:42:09,310
it's working yeah and tell me where it

00:42:07,750 --> 00:42:14,250
works too it's always nice to have

00:42:09,310 --> 00:42:14,250
success stories any other questions

00:42:16,440 --> 00:42:23,970
scale of this 10 megs hmm if you on that

00:42:19,989 --> 00:42:31,329
scale or give up okay let's go back here

00:42:23,970 --> 00:42:36,519
to pop up a pop-up but don't know

00:42:31,329 --> 00:42:38,380
although yes that one okay if you under

00:42:36,519 --> 00:42:39,970
the scalar now that's an interesting

00:42:38,380 --> 00:42:44,380
question there's a subtle difference but

00:42:39,970 --> 00:42:46,839
so okay there's 10 meg in de lavar and

00:42:44,380 --> 00:42:48,759
there's 10 meg in the temporary variable

00:42:46,839 --> 00:42:52,140
that the compiler created oh so

00:42:48,759 --> 00:42:55,210
hopefully for you you can't touch that

00:42:52,140 --> 00:42:57,339
10 meg that the compiler create it sadly

00:42:55,210 --> 00:43:00,819
this is a good reason for a use less

00:42:57,339 --> 00:43:03,729
pragma to say hey you know if it's crazy

00:43:00,819 --> 00:43:05,529
big please friedhof for me the dollar

00:43:03,729 --> 00:43:07,359
VAR if you're if you've got an

00:43:05,529 --> 00:43:09,279
application thats slinging large strings

00:43:07,359 --> 00:43:11,170
around rather than references to large

00:43:09,279 --> 00:43:13,690
strings if it's actually slinging large

00:43:11,170 --> 00:43:17,470
strings around then yes it's a good idea

00:43:13,690 --> 00:43:21,759
to undef the values so a good case here

00:43:17,470 --> 00:43:24,779
is hate HTTP GET so you're using lwp

00:43:21,759 --> 00:43:28,420
you're getting downloading a big file

00:43:24,779 --> 00:43:30,969
lwp in a couple of places will hold a

00:43:28,420 --> 00:43:33,609
string with the entire contents and that

00:43:30,969 --> 00:43:36,219
buffer will always be the size of the

00:43:33,609 --> 00:43:38,259
largest thing you've downloaded yeah so

00:43:36,219 --> 00:43:39,969
that would be an example of somewhere

00:43:38,259 --> 00:43:42,969
where it might be a good idea to do and

00:43:39,969 --> 00:43:45,759
undef but you know if you did undef it

00:43:42,969 --> 00:43:47,619
then every time you call it it's got to

00:43:45,759 --> 00:43:50,319
reallocate the memory so there's a

00:43:47,619 --> 00:43:52,299
trade-off yeah so it's like it would be

00:43:50,319 --> 00:43:54,519
nice with the use less memory pragma to

00:43:52,299 --> 00:43:57,640
be able to save please free buffers

00:43:54,519 --> 00:43:58,989
bigger than X amount so if you do a

00:43:57,640 --> 00:44:02,099
legate something very big then it'll get

00:43:58,989 --> 00:44:02,099
freed again

00:44:10,109 --> 00:44:16,270
yeah okay so you could get rid of the 10

00:44:12,609 --> 00:44:20,730
meg by putting it inside a string eval

00:44:16,270 --> 00:44:23,710
so it's trading memory for performance

00:44:20,730 --> 00:44:25,809
CPU time versus memory but yes but

00:44:23,710 --> 00:44:27,430
that's a good way to get rid of that I

00:44:25,809 --> 00:44:29,829
mean not many people have this specific

00:44:27,430 --> 00:44:36,210
problem obviously I'm exaggerating here

00:44:29,829 --> 00:44:36,210
to make a point okay any more questions

00:44:38,490 --> 00:44:42,240
right thank you very much

00:45:06,090 --> 00:45:08,390
deeper

00:45:13,350 --> 00:45:23,260
alright looks to be about 2 30 so i

00:45:16,090 --> 00:45:26,550
think we'll start so okay everybody hear

00:45:23,260 --> 00:45:26,550

YouTube URL: https://www.youtube.com/watch?v=GIIeOntmojg


