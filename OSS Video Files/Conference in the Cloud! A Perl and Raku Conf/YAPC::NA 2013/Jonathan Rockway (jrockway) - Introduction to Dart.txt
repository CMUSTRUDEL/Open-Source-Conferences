Title: Jonathan Rockway (jrockway) - Introduction to Dart
Publication date: 2013-08-20
Playlist: YAPC::NA 2013
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:06,960
um ok so I'm here to talk about dark if

00:00:04,350 --> 00:00:08,849
you have any questions the link to the

00:00:06,960 --> 00:00:10,860
presentation is on the page I see a

00:00:08,849 --> 00:00:13,170
couple of people have already figured

00:00:10,860 --> 00:00:15,089
that out interviewing it I find

00:00:13,170 --> 00:00:16,980
presentations to be very boring if we

00:00:15,089 --> 00:00:20,609
view the slides in advance but that's

00:00:16,980 --> 00:00:23,760
fine with me so yeah feel free to send

00:00:20,609 --> 00:00:25,380
me an email I work at Google dart is a

00:00:23,760 --> 00:00:26,849
project from google but I don't actually

00:00:25,380 --> 00:00:28,410
work on dart I just kind of picked it up

00:00:26,849 --> 00:00:30,859
in my spare time and thought it might be

00:00:28,410 --> 00:00:33,329
interesting to introduce it to you guys

00:00:30,859 --> 00:00:37,380
and I'm also wondering is there any like

00:00:33,329 --> 00:00:45,930
wireless microphone in this room yes

00:00:37,380 --> 00:00:48,450
where I like to walk around and not just

00:00:45,930 --> 00:00:53,190
like stand into the droning into the

00:00:48,450 --> 00:00:55,440
microphone for the entire talk but until

00:00:53,190 --> 00:00:57,120
we have that figured out and I will try

00:00:55,440 --> 00:01:00,000
and attempt to go to the next slide hey

00:00:57,120 --> 00:01:01,170
it worked ok so after the talk you know

00:01:00,000 --> 00:01:02,820
it's a 20-minute talk about a

00:01:01,170 --> 00:01:05,189
programming language I don't think you

00:01:02,820 --> 00:01:07,020
can really say that much about a

00:01:05,189 --> 00:01:08,880
programming language in 20 minutes so

00:01:07,020 --> 00:01:10,200
I'm going to have links throughout the

00:01:08,880 --> 00:01:12,689
presentation where you can go to learn

00:01:10,200 --> 00:01:15,570
more there's actually the dart languid

00:01:12,689 --> 00:01:24,270
page is let me go ahead and click this

00:01:15,570 --> 00:01:29,280
allow button thank you ok this is better

00:01:24,270 --> 00:01:31,079
ok so we have the dart Lang that is

00:01:29,280 --> 00:01:34,130
filled with information has a ton of

00:01:31,079 --> 00:01:36,540
documentation has videos it has demos

00:01:34,130 --> 00:01:39,329
it's really an amazing piece of

00:01:36,540 --> 00:01:42,780
documentary work and you can learn a lot

00:01:39,329 --> 00:01:44,280
about dark by visiting that site and we

00:01:42,780 --> 00:01:45,960
have this book which is the second link

00:01:44,280 --> 00:01:48,570
which is a book that recently came out

00:01:45,960 --> 00:01:50,520
it's up to date as of m3 the current

00:01:48,570 --> 00:01:52,380
version of dart is M for the only

00:01:50,520 --> 00:01:54,420
difference between m3 and m4 is that an

00:01:52,380 --> 00:01:55,979
m4 the libraries are now stable so

00:01:54,420 --> 00:01:58,290
they're not going to be any backwards

00:01:55,979 --> 00:02:00,509
incompatible changes or at least that's

00:01:58,290 --> 00:02:02,549
my understanding I started using dart

00:02:00,509 --> 00:02:04,979
around the m1 time and it like it seemed

00:02:02,549 --> 00:02:07,340
like every week somebody had changed the

00:02:04,979 --> 00:02:09,830
names of some core method and then I had

00:02:07,340 --> 00:02:11,420
rewrite my code or actually since I was

00:02:09,830 --> 00:02:13,730
doing this at Google the dart team

00:02:11,420 --> 00:02:16,430
rewrote my code and sent me a change

00:02:13,730 --> 00:02:18,110
list to approve so that was nice but now

00:02:16,430 --> 00:02:19,819
it's stable so there shouldn't be any

00:02:18,110 --> 00:02:21,290
stability problems and you can write

00:02:19,819 --> 00:02:24,470
this code and trust that it's going to

00:02:21,290 --> 00:02:26,959
stay relatively the same so what is dart

00:02:24,470 --> 00:02:28,610
dart is a dynamic language that you

00:02:26,959 --> 00:02:30,950
might use where you would use JavaScript

00:02:28,610 --> 00:02:33,170
it compiles to JavaScript I don't know

00:02:30,950 --> 00:02:34,940
if you guys were at the talk about

00:02:33,170 --> 00:02:36,799
JavaScript but javascript is the

00:02:34,940 --> 00:02:39,530
assembly language of the web and art

00:02:36,799 --> 00:02:41,750
will compile to that what is cool though

00:02:39,530 --> 00:02:43,940
is that there's also a command line

00:02:41,750 --> 00:02:45,829
version so you can run your dart tests

00:02:43,940 --> 00:02:48,049
and sample code on the command line

00:02:45,829 --> 00:02:50,090
there's dartium which is a version of

00:02:48,049 --> 00:02:51,260
chromium that has a dart VM built in so

00:02:50,090 --> 00:02:53,569
you don't have to compile your code you

00:02:51,260 --> 00:02:55,790
can just launch dartium and immediately

00:02:53,569 --> 00:02:58,400
start hacking on it there's dr t which

00:02:55,790 --> 00:03:00,349
is dump render tree it's a WebKit

00:02:58,400 --> 00:03:02,540
debugging tool the dart supports and

00:03:00,349 --> 00:03:03,980
it's a headless browser that will dump

00:03:02,540 --> 00:03:06,260
the render tree when it's done rendering

00:03:03,980 --> 00:03:07,819
like is text and you can write your

00:03:06,260 --> 00:03:10,010
tests against that and you don't have to

00:03:07,819 --> 00:03:11,630
like start up a web browser and then

00:03:10,010 --> 00:03:13,370
like write some pixel comparison

00:03:11,630 --> 00:03:14,900
software to see if there are any like

00:03:13,370 --> 00:03:17,180
you I regressions you can just look at

00:03:14,900 --> 00:03:19,790
the dump render tree output I have not

00:03:17,180 --> 00:03:21,500
actually done that but it seems cool and

00:03:19,790 --> 00:03:23,090
finally there's dr. Jeff's which will

00:03:21,500 --> 00:03:26,959
take your dart file in all its libraries

00:03:23,090 --> 00:03:28,940
and compile it to a JavaScript file all

00:03:26,959 --> 00:03:30,950
right so why would you use dart and the

00:03:28,940 --> 00:03:32,420
big reason that dart appeal to me is

00:03:30,950 --> 00:03:35,540
because I like to organize my code I

00:03:32,420 --> 00:03:37,400
want to sit down and write a class and

00:03:35,540 --> 00:03:39,109
dark gives me this opportunity whereas

00:03:37,400 --> 00:03:40,489
with JavaScript I always felt like you

00:03:39,109 --> 00:03:42,440
know I could do things really quickly if

00:03:40,489 --> 00:03:44,840
I need to have an object you know I just

00:03:42,440 --> 00:03:46,400
say foo colon 42 and now I can call this

00:03:44,840 --> 00:03:48,500
food method that returns the value of

00:03:46,400 --> 00:03:50,000
foo it's pretty cool but I just feel

00:03:48,500 --> 00:03:51,680
like I can't keep all that in my head

00:03:50,000 --> 00:03:53,419
and when I come look at it in a year or

00:03:51,680 --> 00:03:55,459
six months I'm not going to know what's

00:03:53,419 --> 00:03:57,859
going on where's the dart I can document

00:03:55,459 --> 00:03:59,660
explicitly in a class file what my data

00:03:57,859 --> 00:04:02,180
structures look like that was the big

00:03:59,660 --> 00:04:04,099
Sal for me other people might say it

00:04:02,180 --> 00:04:05,569
looks a lot like Java and we want to

00:04:04,099 --> 00:04:08,989
look at the code i think you'll see that

00:04:05,569 --> 00:04:10,790
it's very java like all right i found it

00:04:08,989 --> 00:04:12,829
easier to write tests for than

00:04:10,790 --> 00:04:15,379
JavaScript I've never you know I've used

00:04:12,829 --> 00:04:17,359
nodejs and I've used client-side

00:04:15,379 --> 00:04:19,200
JavaScript and I could never liked get

00:04:17,359 --> 00:04:21,030
my UI code to

00:04:19,200 --> 00:04:22,740
nodejs so I couldn't like write my

00:04:21,030 --> 00:04:25,650
application and then write a smoke test

00:04:22,740 --> 00:04:27,360
and nodejs to use my application code to

00:04:25,650 --> 00:04:31,020
hit my application server and simulate a

00:04:27,360 --> 00:04:33,030
user with dark this is much easier it

00:04:31,020 --> 00:04:34,560
has a cleaner more feature for full core

00:04:33,030 --> 00:04:36,360
than JavaScript I mean it's a brand new

00:04:34,560 --> 00:04:37,890
language we've learned a lot since

00:04:36,360 --> 00:04:39,540
JavaScript came out and we didn't have

00:04:37,890 --> 00:04:41,880
to maintain backwards compatibility so

00:04:39,540 --> 00:04:44,700
that's always good the libraries are

00:04:41,880 --> 00:04:47,670
really beautiful they are very java like

00:04:44,700 --> 00:04:50,640
if you've ever used the guava library

00:04:47,670 --> 00:04:52,200
for java it's kind of like that I know

00:04:50,640 --> 00:04:54,030
Java is kind of a bad word around here

00:04:52,200 --> 00:04:57,090
but they do have a few good ideas and

00:04:54,030 --> 00:04:59,910
occasionally make good libraries they

00:04:57,090 --> 00:05:02,070
have a package manager like Sipan called

00:04:59,910 --> 00:05:03,570
pub you can just write your module type

00:05:02,070 --> 00:05:05,400
pub publish and upload it and now

00:05:03,570 --> 00:05:08,490
everybody can use your module that's

00:05:05,400 --> 00:05:12,090
pretty cool there's a full-featured IDE

00:05:08,490 --> 00:05:14,400
so there's like code highlighting and it

00:05:12,090 --> 00:05:16,290
will like do syntactic analysis and find

00:05:14,400 --> 00:05:18,620
errors and hopefully there's refactoring

00:05:16,290 --> 00:05:21,980
features I haven't actually used that I

00:05:18,620 --> 00:05:25,020
prefer Emacs for which there is a mode

00:05:21,980 --> 00:05:27,810
it does optimized code generation which

00:05:25,020 --> 00:05:29,670
means that the code that you write is

00:05:27,810 --> 00:05:31,830
not necessarily what runs and in fact

00:05:29,670 --> 00:05:34,350
code written in dart and compiled to

00:05:31,830 --> 00:05:36,030
JavaScript often runs faster than

00:05:34,350 --> 00:05:37,980
JavaScript like the same benchmark

00:05:36,030 --> 00:05:40,140
compiled with a dark compiler runs

00:05:37,980 --> 00:05:42,270
faster when compiled to JavaScript as

00:05:40,140 --> 00:05:44,280
pure JavaScript so the compiler is

00:05:42,270 --> 00:05:46,530
really smart and it's a new language so

00:05:44,280 --> 00:05:48,390
you choose where it's going right it's

00:05:46,530 --> 00:05:49,890
not in any browser it's still subject to

00:05:48,390 --> 00:05:51,900
change so you can get on the mailing

00:05:49,890 --> 00:05:55,350
list and decide how you want this to

00:05:51,900 --> 00:05:57,660
work I found a bug in the documentation

00:05:55,350 --> 00:05:59,640
in Dart a few weeks ago I filed a bug at

00:05:57,660 --> 00:06:02,010
like CR bugs or dark bugs or wherever

00:05:59,640 --> 00:06:04,950
the appropriate places and they had it

00:06:02,010 --> 00:06:07,950
fixed and pushed in an hour so it's

00:06:04,950 --> 00:06:10,200
really nice so why would you not use

00:06:07,950 --> 00:06:12,600
dart well it's a new language and you

00:06:10,200 --> 00:06:14,010
choose its future that means that your

00:06:12,600 --> 00:06:16,500
choice might be different from your

00:06:14,010 --> 00:06:18,090
choice and you have to live with that if

00:06:16,500 --> 00:06:20,460
other people make bad decisions that you

00:06:18,090 --> 00:06:26,000
disagree with it can change where's this

00:06:20,460 --> 00:06:26,000
JavaScript what it is is what it is yep

00:06:27,720 --> 00:06:40,920
sure I I would imagine it does because

00:06:37,300 --> 00:06:40,920
it works with all the JavaScript engines

00:06:54,900 --> 00:06:59,440
sure I don't think I think the dart team

00:06:57,850 --> 00:07:00,910
has said that their goal is not to be a

00:06:59,440 --> 00:07:02,430
vm for anything they don't want to have

00:07:00,910 --> 00:07:05,890
a vm it's just a development tool

00:07:02,430 --> 00:07:07,990
javascript and v8 or the vm so compiling

00:07:05,890 --> 00:07:10,780
to JavaScript is fine dart is just for

00:07:07,990 --> 00:07:15,490
humans to read and write not for

00:07:10,780 --> 00:07:20,140
machines to execute it's very much like

00:07:15,490 --> 00:07:22,150
a CoffeeScript yes all right and until

00:07:20,140 --> 00:07:23,740
recently dart changed every release so

00:07:22,150 --> 00:07:25,990
you might not want that right do you

00:07:23,740 --> 00:07:27,580
want to work on new features or you want

00:07:25,990 --> 00:07:29,440
to update your code base every time the

00:07:27,580 --> 00:07:31,330
dart team makes a new decision you have

00:07:29,440 --> 00:07:33,430
to decide whether or not you want to do

00:07:31,330 --> 00:07:35,290
that it's not as bad now as it was but

00:07:33,430 --> 00:07:36,640
you are a new user of this and there are

00:07:35,290 --> 00:07:38,830
going to be bugs and you're going to

00:07:36,640 --> 00:07:40,000
find them all right and so now you're

00:07:38,830 --> 00:07:42,480
probably wondering why are we talking

00:07:40,000 --> 00:07:44,830
about dart at a pearl conference well

00:07:42,480 --> 00:07:48,880
we've talked about a lot of languages

00:07:44,830 --> 00:07:50,800
this week perl 6 Stephens mo etc etc and

00:07:48,880 --> 00:07:52,540
there are good ideas in dart to make

00:07:50,800 --> 00:07:55,540
programming really nice that we should

00:07:52,540 --> 00:07:57,400
consider stealing and a lot of us write

00:07:55,540 --> 00:07:59,530
web apps and so we get to write the fun

00:07:57,400 --> 00:08:02,790
part in Perl and then like we have to

00:07:59,530 --> 00:08:04,960
write the client side part and

00:08:02,790 --> 00:08:06,280
JavaScript if you like javascript is

00:08:04,960 --> 00:08:07,570
good if you don't like JavaScript you

00:08:06,280 --> 00:08:09,370
just kind of want to get it over with

00:08:07,570 --> 00:08:11,110
with this you have a new more powerful

00:08:09,370 --> 00:08:13,480
tool that you might enjoy more and

00:08:11,110 --> 00:08:16,960
you'll make better user interfaces

00:08:13,480 --> 00:08:18,610
because your tools are better and look

00:08:16,960 --> 00:08:20,500
at the documentation afterwards it's

00:08:18,610 --> 00:08:22,360
it's beautiful it's up to date it's

00:08:20,500 --> 00:08:24,330
amazing look at the documentation it's

00:08:22,360 --> 00:08:26,770
definitely great ideas to take from that

00:08:24,330 --> 00:08:29,830
ok so let's just jump in and look at

00:08:26,770 --> 00:08:33,460
some code so you want to make a class a

00:08:29,830 --> 00:08:35,740
point class and it has an x and y so we

00:08:33,460 --> 00:08:38,440
declare that there's an x and y

00:08:35,740 --> 00:08:39,789
and we create this constructor now

00:08:38,440 --> 00:08:41,320
there's a lot of syntax sugar for

00:08:39,789 --> 00:08:43,990
constructors we don't say like this dot

00:08:41,320 --> 00:08:46,060
x equals x this dot y equals what we

00:08:43,990 --> 00:08:48,550
just say this value passed in becomes X

00:08:46,060 --> 00:08:51,040
and this value passed in becomes Y and

00:08:48,550 --> 00:08:52,420
we also have optional types here so we

00:08:51,040 --> 00:08:54,820
say that these are numbers actually

00:08:52,420 --> 00:08:56,770
their doubles and we say its final which

00:08:54,820 --> 00:08:58,720
means they can't be changed so this is

00:08:56,770 --> 00:09:03,399
an immutable object and the compiler

00:08:58,720 --> 00:09:05,770
will enforce that as you can see we have

00:09:03,399 --> 00:09:08,020
some other syntax so if we want to

00:09:05,770 --> 00:09:09,550
explicitly named these variables and

00:09:08,020 --> 00:09:12,130
then assign them later this is like this

00:09:09,550 --> 00:09:13,450
dot x equals x is that y equals y and we

00:09:12,130 --> 00:09:15,339
do it in this colon separated

00:09:13,450 --> 00:09:16,750
initializer so the compiler knows that

00:09:15,339 --> 00:09:18,490
we actually initialize all the final

00:09:16,750 --> 00:09:20,140
fields if you don't initialize all the

00:09:18,490 --> 00:09:21,850
final fields in the constructor it's an

00:09:20,140 --> 00:09:23,260
error if you try to change the final

00:09:21,850 --> 00:09:26,820
fields after the constructor it's an

00:09:23,260 --> 00:09:26,820
error so you have this special syntax

00:09:27,360 --> 00:09:31,690
and we can do the traditional Java style

00:09:29,890 --> 00:09:33,250
constructor if this wasn't final and

00:09:31,690 --> 00:09:40,540
just passed an x and y and then

00:09:33,250 --> 00:09:41,890
explicitly assign them ok what we can

00:09:40,540 --> 00:09:43,839
also have and art or something called

00:09:41,890 --> 00:09:46,480
named constructors so if you want to

00:09:43,839 --> 00:09:49,450
provide a different type of constructor

00:09:46,480 --> 00:09:51,880
you can do that so we have a point

00:09:49,450 --> 00:09:54,339
origin constructor this will create a

00:09:51,880 --> 00:09:56,320
point at the origin so x and y are set

00:09:54,339 --> 00:10:04,000
to 0 and this is in addition to the

00:09:56,320 --> 00:10:05,440
normal named constructor all right and

00:10:04,000 --> 00:10:07,209
you can have as many named constructors

00:10:05,440 --> 00:10:09,040
as you want so if you want to like take

00:10:07,209 --> 00:10:11,050
a JSON object and convert that to your

00:10:09,040 --> 00:10:15,880
point you can just write a constructor

00:10:11,050 --> 00:10:17,620
to do that all right and to use these

00:10:15,880 --> 00:10:19,870
constructors you just say new point as

00:10:17,620 --> 00:10:21,160
you might expect if you want to call one

00:10:19,870 --> 00:10:22,959
of the name constructors you say new

00:10:21,160 --> 00:10:25,870
point dot whatever the named constructor

00:10:22,959 --> 00:10:27,399
is and then that will just run and so no

00:10:25,870 --> 00:10:29,649
matter how you create a new object even

00:10:27,399 --> 00:10:31,480
if you're using some utility method you

00:10:29,649 --> 00:10:32,589
always call new so it's always clear to

00:10:31,480 --> 00:10:34,680
the reader of this code that you're

00:10:32,589 --> 00:10:39,070
creating a new instance of a class I

00:10:34,680 --> 00:10:41,079
like that a lot ok so let's take a look

00:10:39,070 --> 00:10:42,790
at an abstract class in abstract classes

00:10:41,079 --> 00:10:44,170
one you can instantiate because it

00:10:42,790 --> 00:10:46,300
doesn't have all the stuff in there yet

00:10:44,170 --> 00:10:47,620
ok what we're saying here is we're going

00:10:46,300 --> 00:10:48,600
to have a class called person has a

00:10:47,620 --> 00:10:50,910
Greek method that will

00:10:48,600 --> 00:10:52,410
hello to them or something like that so

00:10:50,910 --> 00:10:55,170
let's implement this class with the

00:10:52,410 --> 00:10:56,670
person in pull and it has a first name

00:10:55,170 --> 00:10:58,110
and a last name we have a constructor

00:10:56,670 --> 00:10:59,370
for that and we have a Greek method for

00:10:58,110 --> 00:11:01,350
that and it says hello first name last

00:10:59,370 --> 00:11:03,660
name you'll see that for variable

00:11:01,350 --> 00:11:05,250
interpretation interpolation it works

00:11:03,660 --> 00:11:07,440
exactly like pearl you just do dollar

00:11:05,250 --> 00:11:09,149
sign and the variable name and you don't

00:11:07,440 --> 00:11:11,790
have to say like this dot whatever self

00:11:09,149 --> 00:11:16,440
dot whatever because it's in that

00:11:11,790 --> 00:11:18,509
context already all right now what we

00:11:16,440 --> 00:11:20,370
can do that's really cool is you want to

00:11:18,509 --> 00:11:21,959
say something like new person except new

00:11:20,370 --> 00:11:23,819
person is an abstract class so you can't

00:11:21,959 --> 00:11:26,550
create an instance but what we can do is

00:11:23,819 --> 00:11:28,380
we can make a factory constructor and so

00:11:26,550 --> 00:11:29,730
we make a factory constructor for person

00:11:28,380 --> 00:11:31,380
that takes a first name and a last name

00:11:29,730 --> 00:11:33,360
and that will delegate to person impul

00:11:31,380 --> 00:11:35,310
so the users of your code don't need to

00:11:33,360 --> 00:11:36,990
know that this is an interface and you

00:11:35,310 --> 00:11:38,819
have a concrete implementation somewhere

00:11:36,990 --> 00:11:41,579
they can just create a new person and

00:11:38,819 --> 00:11:43,680
they'll get the implementation that you

00:11:41,579 --> 00:11:45,569
chose in the factory constructor and so

00:11:43,680 --> 00:11:49,050
if we run this code here it'll say hello

00:11:45,569 --> 00:11:51,959
Jonathan rockway a little another piece

00:11:49,050 --> 00:11:55,139
of syntax to point out you can declare

00:11:51,959 --> 00:11:56,699
functions with this arrow operator and

00:11:55,139 --> 00:11:58,709
that means this is just going to be a

00:11:56,699 --> 00:12:01,430
one-liner function so we say main is

00:11:58,709 --> 00:12:03,990
defined as being this one line of code

00:12:01,430 --> 00:12:06,329
and main is the entry point to your dart

00:12:03,990 --> 00:12:07,740
program there's no code just sitting out

00:12:06,329 --> 00:12:10,319
in the middle of nowhere it's in a

00:12:07,740 --> 00:12:15,779
top-level definition or class or in

00:12:10,319 --> 00:12:17,100
Maine okay so how do we run this well we

00:12:15,779 --> 00:12:20,220
can just say dark in the name of the

00:12:17,100 --> 00:12:21,810
file and it will run it how do we

00:12:20,220 --> 00:12:24,329
compile to JavaScript we can just run

00:12:21,810 --> 00:12:25,949
dark to Jas and it will output a

00:12:24,329 --> 00:12:28,889
JavaScript file that we just load you

00:12:25,949 --> 00:12:30,449
know script source equals whatever and

00:12:28,889 --> 00:12:32,519
then that will load the javascript file

00:12:30,449 --> 00:12:34,850
all of your code gets compiled into this

00:12:32,519 --> 00:12:38,040
there's an algorithm called tree shaking

00:12:34,850 --> 00:12:43,250
which causes any code that you're not

00:12:38,040 --> 00:12:43,250
using to not be included in this file

00:12:43,850 --> 00:12:48,449
okay so another thing we can talk about

00:12:46,470 --> 00:12:50,310
is that what happens if you run this

00:12:48,449 --> 00:12:51,689
remember how point took two doubles so

00:12:50,310 --> 00:12:56,610
what happens if we supply strings

00:12:51,689 --> 00:12:57,959
instead any guesses any guesses ok so

00:12:56,610 --> 00:12:58,960
somebody guess exceptions somebody

00:12:57,959 --> 00:13:02,050
guests boom

00:12:58,960 --> 00:13:03,670
wrong it just it works okay the

00:13:02,050 --> 00:13:05,230
semantics of types in dart or they

00:13:03,670 --> 00:13:06,550
cannot affect the runtime behavior of

00:13:05,230 --> 00:13:08,500
the application that can only affect

00:13:06,550 --> 00:13:10,150
compile-time behavior so now you have

00:13:08,500 --> 00:13:11,800
this invalid point object and you're

00:13:10,150 --> 00:13:14,020
thinking to yourself then what's the

00:13:11,800 --> 00:13:16,030
point of the types well you can run dart

00:13:14,020 --> 00:13:17,890
in checked mode in which case it will do

00:13:16,030 --> 00:13:19,870
static analysis and check that you're

00:13:17,890 --> 00:13:21,520
not doing something illegal so it says

00:13:19,870 --> 00:13:24,280
string is not a super tight or subtype

00:13:21,520 --> 00:13:27,160
of double so you can't use it and then

00:13:24,280 --> 00:13:29,110
the program will die finally there's

00:13:27,160 --> 00:13:30,910
also a dart analyzer which will without

00:13:29,110 --> 00:13:32,770
running your code find these errors so

00:13:30,910 --> 00:13:34,660
now we only saw X before because that

00:13:32,770 --> 00:13:37,510
was the first one but this time we get x

00:13:34,660 --> 00:13:39,430
and y and so this will alert us to any

00:13:37,510 --> 00:13:41,830
problems in our code without actually

00:13:39,430 --> 00:13:43,570
having to run it which is nice and

00:13:41,830 --> 00:13:45,490
there's also IDE support so this is the

00:13:43,570 --> 00:13:48,730
dart IDE and we'll just underline things

00:13:45,490 --> 00:13:50,830
when you can't do that all right so now

00:13:48,730 --> 00:13:56,080
I'm concerned that I'm running long time

00:13:50,830 --> 00:14:01,210
I've until 11 55 or 12 anybody new okay

00:13:56,080 --> 00:14:03,130
all right all right so the type

00:14:01,210 --> 00:14:04,660
annotations basically you don't need to

00:14:03,130 --> 00:14:06,100
use the type annotations except where

00:14:04,660 --> 00:14:07,960
somebody else is going to call your code

00:14:06,100 --> 00:14:09,220
so if you just have a helper function

00:14:07,960 --> 00:14:11,500
and you want to assign it to a variable

00:14:09,220 --> 00:14:12,910
we can just say final latitude and that

00:14:11,500 --> 00:14:15,640
means we're creating a variable of any

00:14:12,910 --> 00:14:17,500
type that can't be changed later and we

00:14:15,640 --> 00:14:19,630
calculate this now this calculate itude

00:14:17,500 --> 00:14:21,610
has a signature that says that decides

00:14:19,630 --> 00:14:24,730
on the type and that's how we decide

00:14:21,610 --> 00:14:26,740
what type this value is ok and this

00:14:24,730 --> 00:14:29,260
prevents us I mean this just saves

00:14:26,740 --> 00:14:30,820
typing so we don't detect any type

00:14:29,260 --> 00:14:32,770
errors like I could say final fool

00:14:30,820 --> 00:14:34,960
attitude and if it actually returns a

00:14:32,770 --> 00:14:36,340
double then it would blow up but that's

00:14:34,960 --> 00:14:37,690
probably not going to happen because we

00:14:36,340 --> 00:14:39,970
can just wait for it to blow up when we

00:14:37,690 --> 00:14:41,470
get here which is good enough for the

00:14:39,970 --> 00:14:43,750
interface though we do want to define

00:14:41,470 --> 00:14:45,880
the return value and the type of the

00:14:43,750 --> 00:14:47,620
arguments so that we don't so that we

00:14:45,880 --> 00:14:49,650
can use the static analyzer and detect

00:14:47,620 --> 00:14:52,690
errors before we even run the code

00:14:49,650 --> 00:14:55,180
alright so how do we test all this while

00:14:52,690 --> 00:14:57,700
there's a unit test dart and it worked

00:14:55,180 --> 00:14:59,830
just like this I apologize for the line

00:14:57,700 --> 00:15:02,020
wrapping it looks kind of bad but we

00:14:59,830 --> 00:15:03,790
just say we want to test X we have a

00:15:02,020 --> 00:15:06,640
function anonymous function that takes

00:15:03,790 --> 00:15:11,580
zero arguments and we expect that point

00:15:06,640 --> 00:15:13,620
x equals 1 point 0 and we expect that

00:15:11,580 --> 00:15:16,500
y equals to point out and then we can

00:15:13,620 --> 00:15:18,140
run this test I'm with dark in the name

00:15:16,500 --> 00:15:33,030
of the test file and it will print out

00:15:18,140 --> 00:15:35,070
something saying that it passed all

00:15:33,030 --> 00:15:36,720
right another kind of cool feature in

00:15:35,070 --> 00:15:38,220
dart is getters and setters you don't

00:15:36,720 --> 00:15:40,800
have to encapsulate your values behind

00:15:38,220 --> 00:15:42,210
methods like get foods at foo you can

00:15:40,800 --> 00:15:44,940
actually access them directly like

00:15:42,210 --> 00:15:48,090
object directly object at foo object up

00:15:44,940 --> 00:15:49,860
bar object at foo equals 42 or something

00:15:48,090 --> 00:15:52,770
like that and we can define these

00:15:49,860 --> 00:15:56,040
methods to intercept that so here's a

00:15:52,770 --> 00:15:58,290
rectangle and it has a left top width

00:15:56,040 --> 00:16:01,880
and height but you can also set right

00:15:58,290 --> 00:16:01,880
and then we'll update left for you

00:16:02,090 --> 00:16:05,970
there's operator overloading so you can

00:16:04,440 --> 00:16:08,580
just say operator + like a regular

00:16:05,970 --> 00:16:09,900
method and then you can add two points

00:16:08,580 --> 00:16:12,090
together I'm not sure that makes any

00:16:09,900 --> 00:16:13,730
mathematical sense but you can type in

00:16:12,090 --> 00:16:16,200
the code to do that if you feel like it

00:16:13,730 --> 00:16:18,630
usually to do this for equals equals so

00:16:16,200 --> 00:16:22,680
you can have like value equality rather

00:16:18,630 --> 00:16:24,420
than are these two the same objects okay

00:16:22,680 --> 00:16:26,430
one thing that I really like is the

00:16:24,420 --> 00:16:28,710
lexical scoping so in JavaScript if you

00:16:26,430 --> 00:16:31,770
create a closure in a for loop all the

00:16:28,710 --> 00:16:33,330
closures end up with the value closed

00:16:31,770 --> 00:16:35,250
over is the last iteration of the loop

00:16:33,330 --> 00:16:36,930
after you're through the loop in dart

00:16:35,250 --> 00:16:40,200
each time through the for loop you get a

00:16:36,930 --> 00:16:41,940
new lexical context and so we close / 0

00:16:40,200 --> 00:16:44,250
first then we close / 1 then we close

00:16:41,940 --> 00:16:46,560
over 2 and so when we actually evaluate

00:16:44,250 --> 00:16:52,260
this closure it prints 1 because that's

00:16:46,560 --> 00:16:53,670
what we closed over i equal to 1 all

00:16:52,260 --> 00:16:55,920
right we have exceptions that are very

00:16:53,670 --> 00:16:59,130
Java like except we say try blah blah

00:16:55,920 --> 00:17:01,050
blah on the name of the exception and we

00:16:59,130 --> 00:17:02,810
can either catch it with catchy or not

00:17:01,050 --> 00:17:05,280
type that and just ignore the value

00:17:02,810 --> 00:17:09,870
works like that finally the finally

00:17:05,280 --> 00:17:11,940
block runs to clean anything up there's

00:17:09,870 --> 00:17:13,410
this nice syntax sugar for sometimes you

00:17:11,940 --> 00:17:14,730
want to call a bunch of methods on an

00:17:13,410 --> 00:17:16,320
object but you don't want to have every

00:17:14,730 --> 00:17:17,970
method return this because that's kind

00:17:16,320 --> 00:17:19,530
of annoying you can just use the dot dot

00:17:17,970 --> 00:17:22,080
operator and so this will create a new

00:17:19,530 --> 00:17:23,459
example object then all set foo equal to

00:17:22,080 --> 00:17:25,199
42 on that then it will

00:17:23,459 --> 00:17:26,429
r equal to 1 2 3 on that and then it

00:17:25,199 --> 00:17:30,750
will call the something method on that

00:17:26,429 --> 00:17:32,940
and return that so that's nice alright

00:17:30,750 --> 00:17:35,600
so we have two ways of reusing code in

00:17:32,940 --> 00:17:37,320
dark we have libraries and packages

00:17:35,600 --> 00:17:39,240
libraries give you a little bit of

00:17:37,320 --> 00:17:41,159
privacy so if i define something in the

00:17:39,240 --> 00:17:43,679
library only things that are also in

00:17:41,159 --> 00:17:45,270
that library can access methods or

00:17:43,679 --> 00:17:47,760
fields that start with an underscore

00:17:45,270 --> 00:17:49,770
like this so if I in this library foo I

00:17:47,760 --> 00:17:51,419
include example dart and try to call

00:17:49,770 --> 00:17:56,309
this food method doesn't work it doesn't

00:17:51,419 --> 00:17:58,260
exist and that's being compiled it also

00:17:56,309 --> 00:17:59,940
lets you divide code into parts so you

00:17:58,260 --> 00:18:02,039
can say library example import a bunch

00:17:59,940 --> 00:18:03,270
of stuff to find the parts and then in

00:18:02,039 --> 00:18:05,549
each of those files you have those

00:18:03,270 --> 00:18:07,020
imports and they all become one library

00:18:05,549 --> 00:18:08,760
so you can take a library and split it

00:18:07,020 --> 00:18:11,179
up into multiple files without copying

00:18:08,760 --> 00:18:13,740
and pasting a lot of code which is nice

00:18:11,179 --> 00:18:14,880
the packages work like perl modules you

00:18:13,740 --> 00:18:16,500
make a build file and then you have a

00:18:14,880 --> 00:18:18,299
living test directory where the code Liz

00:18:16,500 --> 00:18:21,179
the build file looks something like this

00:18:18,299 --> 00:18:24,090
the minimal one just says the name of my

00:18:21,179 --> 00:18:27,630
app you can declare your dependencies

00:18:24,090 --> 00:18:30,120
install them by typing pub install and

00:18:27,630 --> 00:18:32,090
then so here's an example so in point

00:18:30,120 --> 00:18:34,529
dart we say library point class point

00:18:32,090 --> 00:18:36,899
and then from other places in our

00:18:34,529 --> 00:18:38,340
application we can refer to the this

00:18:36,899 --> 00:18:41,490
which could live anywhere doesn't have

00:18:38,340 --> 00:18:44,279
to be in lib at by the package name we

00:18:41,490 --> 00:18:46,980
defined this my app thing in the pub

00:18:44,279 --> 00:18:48,720
spec that yml and now dart knows where

00:18:46,980 --> 00:18:50,100
to find this point dark looks inside

00:18:48,720 --> 00:18:52,380
that package even though you're already

00:18:50,100 --> 00:18:54,210
inside that package that way you don't

00:18:52,380 --> 00:18:56,340
have to have nasty like relative paths

00:18:54,210 --> 00:18:59,970
like dot dot slash dot dot slash lib /

00:18:56,340 --> 00:19:01,529
point dart okay so i think we've run out

00:18:59,970 --> 00:19:03,779
of time so i'm going to open it up with

00:19:01,529 --> 00:19:12,980
questions if anybody has any questions

00:19:03,779 --> 00:19:15,870
ask me now or come see me anytime yes um

00:19:12,980 --> 00:19:17,429
yes there's a web UI sorry the question

00:19:15,870 --> 00:19:20,279
was is there a web framework for Dart

00:19:17,429 --> 00:19:21,870
yes I don't think anybody's using it for

00:19:20,279 --> 00:19:23,640
server-side web applications I'm not a

00:19:21,870 --> 00:19:25,590
hundred percent sure but client-side

00:19:23,640 --> 00:19:27,299
there's a ton of libraries I wanted to

00:19:25,590 --> 00:19:29,100
go over those but obviously 20 minutes

00:19:27,299 --> 00:19:30,690
isn't enough if you look at some of the

00:19:29,100 --> 00:19:32,279
future slides we begin talking about

00:19:30,690 --> 00:19:33,830
that and you can take a look at the

00:19:32,279 --> 00:19:35,630
demos where we

00:19:33,830 --> 00:19:37,730
where the demos use web UI there's this

00:19:35,630 --> 00:19:51,110
cool to do one that I've linked from the

00:19:37,730 --> 00:19:52,970
demo slide yes yes so all the

00:19:51,110 --> 00:19:55,549
concurrency is done with futures rather

00:19:52,970 --> 00:19:56,899
than threads I believe that v8 can run

00:19:55,549 --> 00:19:58,279
this on multiple cores but I'm not a

00:19:56,899 --> 00:20:00,169
hundred percent sure about the

00:19:58,279 --> 00:20:02,000
implementation I would ask on the dart

00:20:00,169 --> 00:20:04,899
mailing list and they'll know much

00:20:02,000 --> 00:20:17,779
better than I do good question though

00:20:04,899 --> 00:20:19,549
anything else yes okay so I guess it

00:20:17,779 --> 00:20:20,690
does look a lot like Java and if there

00:20:19,549 --> 00:20:22,880
wasn't already a language called

00:20:20,690 --> 00:20:24,620
JavaScript i would call javascript

00:20:22,880 --> 00:20:26,360
because it looks like java except as a

00:20:24,620 --> 00:20:27,799
scripting language unfortunately that

00:20:26,360 --> 00:20:30,740
name has been taken for language that

00:20:27,799 --> 00:20:32,269
looks nothing like java the reality is a

00:20:30,740 --> 00:20:34,429
lot of programmers at Google write Java

00:20:32,269 --> 00:20:35,779
and they like the look of it they wanted

00:20:34,429 --> 00:20:37,549
something that would be familiar to Java

00:20:35,779 --> 00:20:39,110
programmers since they're trying to pull

00:20:37,549 --> 00:20:41,840
people away from quit which is Java

00:20:39,110 --> 00:20:45,919
that's compiled to JavaScript and so

00:20:41,840 --> 00:20:47,899
this is what they decided on I coffee

00:20:45,919 --> 00:20:52,130
dart as far as I know is not taken as a

00:20:47,899 --> 00:20:54,230
name feel free to implement that all

00:20:52,130 --> 00:20:57,320
right guys I've gone way over the time

00:20:54,230 --> 00:20:58,639
please enjoy lunch and talk to me if you

00:20:57,320 --> 00:21:01,450
have any questions send me an email

00:20:58,639 --> 00:21:01,450
thank

00:21:01,940 --> 00:21:04,000

YouTube URL: https://www.youtube.com/watch?v=NdCchnJNfzU


