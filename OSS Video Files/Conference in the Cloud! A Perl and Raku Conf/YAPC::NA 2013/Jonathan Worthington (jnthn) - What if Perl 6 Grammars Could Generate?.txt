Title: Jonathan Worthington (jnthn) - What if Perl 6 Grammars Could Generate?
Publication date: 2013-08-20
Playlist: YAPC::NA 2013
Description: 
	
Captions: 
	00:00:00,170 --> 00:00:17,609
okay how we sitting comfortably can

00:00:09,630 --> 00:00:20,250
everybody hear me okay awesome hi I'm

00:00:17,609 --> 00:00:23,880
Jonathan it's good to be here yeah i am

00:00:20,250 --> 00:00:26,189
i am i promise i'm jonathan it's nice to

00:00:23,880 --> 00:00:28,199
have a duty Abbe cna I've done a bunch

00:00:26,189 --> 00:00:30,750
of you have ceased swimming Europe so

00:00:28,199 --> 00:00:34,380
I'm in Asia some in Russia finally I

00:00:30,750 --> 00:00:40,850
made it over to see AB cna so it's good

00:00:34,380 --> 00:00:44,550
to be here thank you so Who am I well

00:00:40,850 --> 00:00:48,840
well I'm this guy I do various stuff on

00:00:44,550 --> 00:00:50,430
Perl 6 so you know the if you were in

00:00:48,840 --> 00:00:52,079
Patrick's talk this morning then he gave

00:00:50,430 --> 00:00:53,699
a very comprehensive list of the stuff

00:00:52,079 --> 00:00:56,449
than they done or forgotten that I'd

00:00:53,699 --> 00:00:59,309
done or tried to suppress that I turn I

00:00:56,449 --> 00:01:00,840
actually have a day job too you might

00:00:59,309 --> 00:01:02,670
not believe this but as well as doing

00:01:00,840 --> 00:01:04,229
all of this post if I actually do stuff

00:01:02,670 --> 00:01:05,909
like you know teach software

00:01:04,229 --> 00:01:09,420
architecture and advanced c sharp

00:01:05,909 --> 00:01:11,159
courses so i kind of do you know a load

00:01:09,420 --> 00:01:14,340
of stuff over in the dotnet world as

00:01:11,159 --> 00:01:16,439
well it's actually good being involved

00:01:14,340 --> 00:01:18,119
in multiple language communities it's

00:01:16,439 --> 00:01:19,799
actually a really good thing and one of

00:01:18,119 --> 00:01:21,900
the reasons it's really cool is because

00:01:19,799 --> 00:01:24,479
you can sort of spot interesting things

00:01:21,900 --> 00:01:27,450
they do and say oh I like that i'm going

00:01:24,479 --> 00:01:31,530
to steal that and one of the ones that i

00:01:27,450 --> 00:01:34,920
saw recently was so fing on Donna called

00:01:31,530 --> 00:01:37,380
RX the reactive extensions so what are

00:01:34,920 --> 00:01:40,829
the reactive extensions well they

00:01:37,380 --> 00:01:43,409
realize that if you happen to know

00:01:40,829 --> 00:01:45,899
something about category theory which I

00:01:43,409 --> 00:01:51,030
kind of done but it doesn't matter

00:01:45,899 --> 00:01:52,799
anyway then if you actually take the

00:01:51,030 --> 00:01:55,380
enumerator pattern or the iterator

00:01:52,799 --> 00:01:57,299
pattern and you figure out what is the

00:01:55,380 --> 00:01:59,549
mathematical tool you get the observer

00:01:57,299 --> 00:02:02,430
pattern and that means that we can go

00:01:59,549 --> 00:02:04,469
and define all the familiar sort of

00:02:02,430 --> 00:02:06,840
enumerated Combinator's that we use

00:02:04,469 --> 00:02:08,220
every single day on observables as well

00:02:06,840 --> 00:02:12,709
now at this point you're even thinking

00:02:08,220 --> 00:02:18,540
that's awesome or her

00:02:12,709 --> 00:02:20,459
so let me explain it's easy okay so let

00:02:18,540 --> 00:02:22,650
me show you first do you numerator case

00:02:20,459 --> 00:02:25,530
and we can turn to politics for this

00:02:22,650 --> 00:02:26,940
let's talk about easy lists soul eater

00:02:25,530 --> 00:02:28,380
lists are really great because they let

00:02:26,940 --> 00:02:31,260
you talk about infinite things without

00:02:28,380 --> 00:02:33,480
filling up all of your memory so what we

00:02:31,260 --> 00:02:36,269
can do here is we can take a range that

00:02:33,480 --> 00:02:38,190
goes from one up to infinity and I'm

00:02:36,269 --> 00:02:40,560
actually choosing binding fall of this

00:02:38,190 --> 00:02:43,019
rather than assignment because binding

00:02:40,560 --> 00:02:45,420
is guaranteed not to go and try and be

00:02:43,019 --> 00:02:47,700
eager at any point in the operation and

00:02:45,420 --> 00:02:50,370
what i can do is i can take this

00:02:47,700 --> 00:02:54,510
infinite list of numbers and i can grep

00:02:50,370 --> 00:02:57,780
out all the primes so that star dot

00:02:54,510 --> 00:03:00,420
syntax makes a little closure and then

00:02:57,780 --> 00:03:03,180
we can map them so the output comes out

00:03:00,420 --> 00:03:05,700
something like you know number one and

00:03:03,180 --> 00:03:07,680
then the first prime number and number

00:03:05,700 --> 00:03:10,530
two the second prime number and so on

00:03:07,680 --> 00:03:12,180
and the game that's an infinite list

00:03:10,530 --> 00:03:14,730
okay all these it lists are infinitely

00:03:12,180 --> 00:03:19,829
long but I haven't actually done any

00:03:14,730 --> 00:03:22,380
work out what they do down here is I say

00:03:19,829 --> 00:03:24,660
I want to get the first ten things in

00:03:22,380 --> 00:03:28,940
this list so that little hat under ten

00:03:24,660 --> 00:03:35,150
makes a range it's the same as 0 dot 10

00:03:28,940 --> 00:03:35,150
9 thank you it was could be a last night

00:03:35,959 --> 00:03:41,609
so what actually happens then is at that

00:03:40,200 --> 00:03:43,440
point we go off and do the work and

00:03:41,609 --> 00:03:45,720
there's a nice little bit of syntax

00:03:43,440 --> 00:03:47,519
called the feed syntax as well so what's

00:03:45,720 --> 00:03:49,950
going on with this feed syntax this is

00:03:47,519 --> 00:03:52,590
this nice oops that's the point e 1

00:03:49,950 --> 00:03:54,060
there we go that nice little pipe thing

00:03:52,590 --> 00:03:56,489
they're basically just take this one to

00:03:54,060 --> 00:03:58,109
n and then shove it into the grep and

00:03:56,489 --> 00:04:00,810
whatever the grave grave should that

00:03:58,109 --> 00:04:02,280
into the map and then we just do the 10

00:04:00,810 --> 00:04:06,359
thing again so if you think about what

00:04:02,280 --> 00:04:08,489
happens when this is evaluated so here

00:04:06,359 --> 00:04:12,019
we have it and this this guy in the end

00:04:08,489 --> 00:04:15,630
is like hey Matt I need 10 elements and

00:04:12,019 --> 00:04:20,190
matt is like graph I need 10 things to

00:04:15,630 --> 00:04:21,570
map and crap is like Oh range you know

00:04:20,190 --> 00:04:23,070
how to make values don't you and the

00:04:21,570 --> 00:04:24,750
range is oh yeah you do hear you have

00:04:23,070 --> 00:04:28,650
some

00:04:24,750 --> 00:04:30,060
so it's pull based at the end we sort of

00:04:28,650 --> 00:04:32,850
begging for these values we're saying

00:04:30,060 --> 00:04:34,290
give me them give me them so we always

00:04:32,850 --> 00:04:36,420
block on getting the previous thing

00:04:34,290 --> 00:04:40,440
we're pulling them through the set of

00:04:36,420 --> 00:04:41,730
things so that's very familiar and i'm

00:04:40,440 --> 00:04:43,020
glad i've told you about that because we

00:04:41,730 --> 00:04:46,620
need that for the hard stuff we're going

00:04:43,020 --> 00:04:49,650
to do later but the question is what if

00:04:46,620 --> 00:04:52,530
we wanted to push instead what if we're

00:04:49,650 --> 00:04:55,350
doing something more asynchronous and we

00:04:52,530 --> 00:05:00,390
want to push data instead of pull it

00:04:55,350 --> 00:05:03,390
through pipelines like this well that's

00:05:00,390 --> 00:05:06,600
what an observable is so let's write a

00:05:03,390 --> 00:05:09,500
little observable roll not much to it we

00:05:06,600 --> 00:05:13,350
declare an attribute up here an array of

00:05:09,500 --> 00:05:16,110
things that are observing us things that

00:05:13,350 --> 00:05:20,460
when something happens to us we will

00:05:16,110 --> 00:05:25,710
invoke and then we can subscribe

00:05:20,460 --> 00:05:28,440
something to observe it we have an

00:05:25,710 --> 00:05:31,050
unsubscribe that's kind of boring and we

00:05:28,440 --> 00:05:33,479
have a publish method and all it does is

00:05:31,050 --> 00:05:36,000
whenever something happens which is

00:05:33,479 --> 00:05:38,970
represented by this object we take all

00:05:36,000 --> 00:05:42,150
the things that are observing it and we

00:05:38,970 --> 00:05:44,430
go over the observers and we call handle

00:05:42,150 --> 00:05:46,680
on all of them so basically it's

00:05:44,430 --> 00:05:49,350
publish-subscribe okay every time

00:05:46,680 --> 00:05:50,850
somebody registers or subscribes they

00:05:49,350 --> 00:05:53,250
get to know all the things that can

00:05:50,850 --> 00:05:57,479
happen that happen now it turns out that

00:05:53,250 --> 00:05:59,610
if we go and start writing stuff like

00:05:57,479 --> 00:06:01,740
this okay so i just did a really simple

00:05:59,610 --> 00:06:04,410
thing it takes a file handle it just

00:06:01,740 --> 00:06:06,780
sits getting lions from the file handle

00:06:04,410 --> 00:06:11,550
and publishing each line this is good

00:06:06,780 --> 00:06:14,400
enough to be an observable so what i can

00:06:11,550 --> 00:06:16,770
then do is they can start defining all

00:06:14,400 --> 00:06:23,610
those familiar things like crap and map

00:06:16,770 --> 00:06:25,290
and first is grep what does grep do well

00:06:23,610 --> 00:06:27,510
here's a little grab subscriber notice

00:06:25,290 --> 00:06:30,600
how i can use lexical classes I don't

00:06:27,510 --> 00:06:33,150
need to liek this anywhere else so the

00:06:30,600 --> 00:06:34,530
grep subscriber just takes hold of the

00:06:33,150 --> 00:06:36,660
matcher the thing that we're going to

00:06:34,530 --> 00:06:39,570
grap against

00:06:36,660 --> 00:06:42,870
and when it gets some input when

00:06:39,570 --> 00:06:46,740
something gets pushed into it it says

00:06:42,870 --> 00:06:48,660
does it match and if it does it

00:06:46,740 --> 00:06:52,320
publishes it out to all of the things

00:06:48,660 --> 00:06:54,720
that are observing it so then I can

00:06:52,320 --> 00:06:58,770
start writing code where I take this

00:06:54,720 --> 00:07:03,540
sort of source of events or items of

00:06:58,770 --> 00:07:06,270
data and when everyone comes in I can

00:07:03,540 --> 00:07:09,090
just use this nice pipes in tax saves on

00:07:06,270 --> 00:07:11,970
all these overloads and I can grab for

00:07:09,090 --> 00:07:14,340
all of the things coming through and I

00:07:11,970 --> 00:07:16,920
can shove them into some over observable

00:07:14,340 --> 00:07:19,560
now putting in nuns and now I can take

00:07:16,920 --> 00:07:21,390
that and I can grab out all the Prime

00:07:19,560 --> 00:07:26,070
ones and they can stick a call at the

00:07:21,390 --> 00:07:28,200
end which says all that's a prime or I

00:07:26,070 --> 00:07:31,530
can take them I can map them and I can

00:07:28,200 --> 00:07:33,030
keep count using a state variable so I

00:07:31,530 --> 00:07:36,360
can see when I get up to a hundred

00:07:33,030 --> 00:07:37,680
different things and then I say just

00:07:36,360 --> 00:07:39,690
want the first one so what it actually

00:07:37,680 --> 00:07:42,720
does is it unsubscribes after it's got

00:07:39,690 --> 00:07:44,700
one and then we call this thing at the

00:07:42,720 --> 00:07:46,860
end and what's going on is it looks very

00:07:44,700 --> 00:07:49,110
much like the code you would write if

00:07:46,860 --> 00:07:52,680
you had a thing at the end that was

00:07:49,110 --> 00:07:55,020
pulling the values through but instead

00:07:52,680 --> 00:07:57,060
what's actually happening is things are

00:07:55,020 --> 00:08:03,120
getting done at the top and they're

00:07:57,060 --> 00:08:07,680
getting pushed so if we run this here I

00:08:03,120 --> 00:08:09,780
have it okay that's a crime and I guess

00:08:07,680 --> 00:08:14,010
that's a prime i'm pretty sure that

00:08:09,780 --> 00:08:16,260
isn't it'll be very hard if it was ok

00:08:14,010 --> 00:08:18,480
and then notice that we we actually hit

00:08:16,260 --> 00:08:20,700
the more than 100 point but it's

00:08:18,480 --> 00:08:28,890
unsubscribed now so if we go and do some

00:08:20,700 --> 00:08:31,590
more ok and there we have it so well

00:08:28,890 --> 00:08:33,090
that's basically the idea behind this

00:08:31,590 --> 00:08:35,160
this kind of jewel idea and what we've

00:08:33,090 --> 00:08:39,000
done is we've taken this familiar notion

00:08:35,160 --> 00:08:41,610
of innumerable and we've taken this

00:08:39,000 --> 00:08:43,620
familiar set of operations that we use

00:08:41,610 --> 00:08:45,330
every day like grab a map and we've

00:08:43,620 --> 00:08:47,920
realized that if we just apply the jewel

00:08:45,330 --> 00:08:50,110
we can actually use all of these same

00:08:47,920 --> 00:08:52,690
familiar things working with

00:08:50,110 --> 00:08:56,820
asynchronous inputs and pushing the data

00:08:52,690 --> 00:08:59,260
through instead oh that's kind of nice

00:08:56,820 --> 00:09:02,589
there's no blocking there that's kinda

00:08:59,260 --> 00:09:05,380
nice racing and I sort of looked at this

00:09:02,589 --> 00:09:06,940
idea and you know what I sketches out in

00:09:05,380 --> 00:09:10,750
Perl 6 and I was like well okay i'm done

00:09:06,940 --> 00:09:14,230
with that one now but i started thinking

00:09:10,750 --> 00:09:17,320
is to anywhere else in Perl 6 thought i

00:09:14,230 --> 00:09:19,959
could actually take this idea of you

00:09:17,320 --> 00:09:22,920
know just turning an operation around of

00:09:19,959 --> 00:09:25,899
flipping the inputs and the outputs and

00:09:22,920 --> 00:09:33,070
maybe getting something kind of cool out

00:09:25,899 --> 00:09:36,730
of it so what about grammars the thing

00:09:33,070 --> 00:09:40,980
is and what the grammar does is it takes

00:09:36,730 --> 00:09:43,720
in the string and its bits how the tree

00:09:40,980 --> 00:09:50,250
so basically it's doing text to data

00:09:43,720 --> 00:09:50,250
structure let's take a little example

00:09:50,850 --> 00:09:59,320
this is a little grammar for Jason so

00:09:56,260 --> 00:10:01,540
what's going on in here is well let's

00:09:59,320 --> 00:10:03,430
just read through it we have a token top

00:10:01,540 --> 00:10:07,720
this is a magical token which is the

00:10:03,430 --> 00:10:09,670
start of doing the pass and then we say

00:10:07,720 --> 00:10:13,420
well JSON that the top level can either

00:10:09,670 --> 00:10:15,790
be an object or it can be an array what

00:10:13,420 --> 00:10:18,850
does an object look like well it looks

00:10:15,790 --> 00:10:21,850
like curly braces and between the curly

00:10:18,850 --> 00:10:27,910
braces there's a pair list and a pair

00:10:21,850 --> 00:10:31,120
list is a pair we have the star there

00:10:27,910 --> 00:10:35,050
that's from reg ex familia syntax that's

00:10:31,120 --> 00:10:36,550
zero or more and then they can have

00:10:35,050 --> 00:10:39,880
commas between them which is what that

00:10:36,550 --> 00:10:42,010
percent Commodus it just says there can

00:10:39,880 --> 00:10:45,370
be Connors and a go between each of

00:10:42,010 --> 00:10:49,050
these paths and a pair is a string a

00:10:45,370 --> 00:10:49,050
colon and a value

00:10:49,070 --> 00:10:57,050
with inertia because if you do not then

00:10:54,050 --> 00:11:03,680
you do not spit pass white space here

00:10:57,050 --> 00:11:07,220
under the current six base rules yeah

00:11:03,680 --> 00:11:18,430
you hadn't used to need that we may be

00:11:07,220 --> 00:11:18,430
done but this is safe okay what's that

00:11:20,050 --> 00:11:40,790
true it don't think it gets optimized as

00:11:24,680 --> 00:11:42,440
well Patrick's okay so on array list is

00:11:40,790 --> 00:11:44,390
kind of the same all right it's it's a

00:11:42,440 --> 00:11:46,880
it's a list of things that go between

00:11:44,390 --> 00:11:48,680
square brackets so you can sort of see

00:11:46,880 --> 00:11:50,570
that where we're sort of representing

00:11:48,680 --> 00:11:51,950
the sort of object graph we're going to

00:11:50,570 --> 00:11:54,110
get out we're sort of describing the

00:11:51,950 --> 00:11:55,640
shape of it in this grammar now we have

00:11:54,110 --> 00:11:58,280
these wonderful things called proto ray

00:11:55,640 --> 00:12:01,010
axis which are basically like multiple

00:11:58,280 --> 00:12:02,810
dispatch but for reg exes but instead of

00:12:01,010 --> 00:12:05,570
actually doing a multiple dispatch it

00:12:02,810 --> 00:12:07,220
runs a little automata which goes and

00:12:05,570 --> 00:12:08,810
figures out which is the best one and

00:12:07,220 --> 00:12:13,880
which ones are impossible and all of

00:12:08,810 --> 00:12:15,980
these nice things so for example we can

00:12:13,880 --> 00:12:19,790
actually just say well that's true and

00:12:15,980 --> 00:12:21,800
false which are actually just true and

00:12:19,790 --> 00:12:25,640
false the sim just lets me refer to this

00:12:21,800 --> 00:12:28,430
bit of text in here and we might have an

00:12:25,640 --> 00:12:29,930
object or we may have an array so you

00:12:28,430 --> 00:12:32,750
can see that this is getting recursive

00:12:29,930 --> 00:12:35,660
okay so we might actually have you know

00:12:32,750 --> 00:12:37,910
an array of a rate because an ArrayList

00:12:35,660 --> 00:12:40,490
is a bunch of values and the value can

00:12:37,910 --> 00:12:42,800
be an array or a string and so forth and

00:12:40,490 --> 00:12:44,840
so it goes on and I don't want to sort

00:12:42,800 --> 00:12:46,430
of go and dig any further into this one

00:12:44,840 --> 00:12:49,460
but hope you get the picture of what

00:12:46,430 --> 00:12:53,450
we're doing we're describing how to pass

00:12:49,460 --> 00:12:56,020
the string into a bunch of actually we

00:12:53,450 --> 00:12:59,350
call match objects and the former tree

00:12:56,020 --> 00:13:01,780
now that's only so useful

00:12:59,350 --> 00:13:04,270
and what makes this more useful is we

00:13:01,780 --> 00:13:08,020
have these things called actions and the

00:13:04,270 --> 00:13:11,610
actions get run after we successfully

00:13:08,020 --> 00:13:16,000
pass a grammar rule and what they do is

00:13:11,610 --> 00:13:19,180
they just take the rule the the match

00:13:16,000 --> 00:13:21,430
and they make some kind of pearl data

00:13:19,180 --> 00:13:24,310
structure and then they pass it on

00:13:21,430 --> 00:13:25,990
upwards so by the time you've gone all

00:13:24,310 --> 00:13:27,280
the way down the tree passing then

00:13:25,990 --> 00:13:30,130
you've worked all your way back up to

00:13:27,280 --> 00:13:33,060
the top you now have built up some kind

00:13:30,130 --> 00:13:35,860
of pearl representation of what you pass

00:13:33,060 --> 00:13:38,410
so in that case it turns into arrays and

00:13:35,860 --> 00:13:41,470
hashes and so forth ok so here we have a

00:13:38,410 --> 00:13:43,360
few examples so number actually just

00:13:41,470 --> 00:13:47,590
takes the string we passed and use perl

00:13:43,360 --> 00:13:49,180
6 is plus operator to come if I it the

00:13:47,590 --> 00:13:56,040
true and false we just make a Perl 6

00:13:49,180 --> 00:13:59,830
ball true and bull false for objects

00:13:56,040 --> 00:14:02,140
well let's go out from the bottom ok Paz

00:13:59,830 --> 00:14:03,610
we actually make a pulse expand and what

00:14:02,140 --> 00:14:06,330
you'll notice isn't it we're able to

00:14:03,610 --> 00:14:09,430
take whatever the string produced and

00:14:06,330 --> 00:14:11,380
get out get the object and over here

00:14:09,430 --> 00:14:13,420
we're able to get the object using the

00:14:11,380 --> 00:14:16,060
dot ast method for whatever the value

00:14:13,420 --> 00:14:18,910
produced and when we see make what we're

00:14:16,060 --> 00:14:21,280
saying is pass it on up so down here

00:14:18,910 --> 00:14:23,260
when we take the pair and we actually

00:14:21,280 --> 00:14:25,810
have a list of them and we use the hyper

00:14:23,260 --> 00:14:28,570
dispatch and we call a STR on all of

00:14:25,810 --> 00:14:30,940
them what we get is this list of pairs

00:14:28,570 --> 00:14:33,430
and then we pass that up and then object

00:14:30,940 --> 00:14:35,530
gets the pair list which is this flat

00:14:33,430 --> 00:14:44,230
list of pairs and it just calls hash on

00:14:35,530 --> 00:14:51,540
it to turn into a hash yep yep basically

00:14:44,230 --> 00:14:55,330
and it sets on dollar / right yeah ok so

00:14:51,540 --> 00:14:58,120
that's passing and you put it all

00:14:55,330 --> 00:15:00,040
together and what you can do is write

00:14:58,120 --> 00:15:02,950
something like from json which makes the

00:15:00,040 --> 00:15:05,860
actions it makes the grammar it passes

00:15:02,950 --> 00:15:08,650
in the json string it sets the actions

00:15:05,860 --> 00:15:10,720
and what comes back is some perl 6

00:15:08,650 --> 00:15:13,120
object which represents a bit of json so

00:15:10,720 --> 00:15:15,500
if DC realized it

00:15:13,120 --> 00:15:17,149
okay so we've been able to do this for

00:15:15,500 --> 00:15:22,310
ages we've been up to this feeds on

00:15:17,149 --> 00:15:25,310
years and that's great but I wondered

00:15:22,310 --> 00:15:27,890
what if sometimes it's good to ask what

00:15:25,310 --> 00:15:32,420
if I stressed all these jewels I was

00:15:27,890 --> 00:15:35,810
like well what if some grandma actually

00:15:32,420 --> 00:15:40,339
had the generate method and we could put

00:15:35,810 --> 00:15:43,580
in some kind of tree ish finger and we

00:15:40,339 --> 00:15:46,940
get out of string that is we can use the

00:15:43,580 --> 00:15:49,580
grammar not only to take text and pass

00:15:46,940 --> 00:15:51,260
it into a data structure but we can use

00:15:49,580 --> 00:15:55,490
the grammar to take a data structure and

00:15:51,260 --> 00:16:02,600
turn it into a load of texts well that's

00:15:55,490 --> 00:16:04,279
a curious concept so can we do it hey

00:16:02,600 --> 00:16:06,560
this this could be like the guy who

00:16:04,279 --> 00:16:09,380
wrote his PhD on two hundred ways not to

00:16:06,560 --> 00:16:12,170
make this chemical yeah we haven't got

00:16:09,380 --> 00:16:14,510
there yet okay so if we could make this

00:16:12,170 --> 00:16:17,779
work okay just take a really naughty

00:16:14,510 --> 00:16:20,720
example my goal is to make the JSON one

00:16:17,779 --> 00:16:22,400
work but let's start somewhere easy if

00:16:20,720 --> 00:16:25,520
we were to have a grammar that did

00:16:22,400 --> 00:16:27,260
simple sentences so you can see here the

00:16:25,520 --> 00:16:33,140
sentence has a subject a verb and object

00:16:27,260 --> 00:16:34,880
and I was to throw in and actually what

00:16:33,140 --> 00:16:36,920
are we going to send in here well it

00:16:34,880 --> 00:16:39,860
turns out that you know match objects

00:16:36,920 --> 00:16:41,240
are naturally and practical in fact if

00:16:39,860 --> 00:16:42,709
we have a match object we'd actually

00:16:41,240 --> 00:16:45,410
have the string in which case we're

00:16:42,709 --> 00:16:48,740
already done so that would be a bit too

00:16:45,410 --> 00:16:50,720
easy but we do have something in Perl 6

00:16:48,740 --> 00:16:53,630
which represents a set of positional

00:16:50,720 --> 00:16:55,430
things and a set of name things which is

00:16:53,630 --> 00:16:58,130
just what we want and that's a capture

00:16:55,430 --> 00:17:01,610
and capture literals are written using

00:16:58,130 --> 00:17:03,110
the backslash friends and then we can

00:17:01,610 --> 00:17:07,040
just put padding so what i can do is i

00:17:03,110 --> 00:17:09,439
can describe a dsl little tree which has

00:17:07,040 --> 00:17:11,209
a sentence at the top and then the

00:17:09,439 --> 00:17:15,050
subject is this the verb is this and the

00:17:11,209 --> 00:17:19,040
object is this and in theory if we take

00:17:15,050 --> 00:17:23,270
those and we call generate i hope i get

00:17:19,040 --> 00:17:26,189
out the string petrucci plays guitar who

00:17:23,270 --> 00:17:32,980
knows who john petrucci is

00:17:26,189 --> 00:17:42,760
really d it's like the only guitarist I

00:17:32,980 --> 00:17:45,880
know so let's try and break this problem

00:17:42,760 --> 00:17:49,870
down a little bit what happens when

00:17:45,880 --> 00:17:52,390
we're passing text if we take each

00:17:49,870 --> 00:17:54,220
individual reg ex construct one thing

00:17:52,390 --> 00:17:55,720
you'll realize is that while some of

00:17:54,220 --> 00:17:58,840
them could only match one particular

00:17:55,720 --> 00:18:01,179
thing some of them can actually match in

00:17:58,840 --> 00:18:03,010
multiple different ways in fact

00:18:01,179 --> 00:18:06,250
quantifiers can match in loads of ways

00:18:03,010 --> 00:18:08,559
that's what backtracking is so what I'm

00:18:06,250 --> 00:18:11,080
going to do to sort of be able to model

00:18:08,559 --> 00:18:13,840
this this of operation and think about

00:18:11,080 --> 00:18:15,910
how to twist it around is to think of

00:18:13,840 --> 00:18:19,120
every single reg ex constructors if it

00:18:15,910 --> 00:18:23,559
produces a potentially empty lazy list

00:18:19,120 --> 00:18:29,410
of all of the ways that it can match so

00:18:23,559 --> 00:18:34,360
for example if I have a be sequential or

00:18:29,410 --> 00:18:37,120
ABC and I feed it the string ABCDEF it

00:18:34,360 --> 00:18:39,520
can even match in a the way a B or ABC

00:18:37,120 --> 00:18:44,290
it to prefer this one but it can do this

00:18:39,520 --> 00:18:46,510
one if it has to so essentially every

00:18:44,290 --> 00:18:49,900
construct in my reg ex can be viewed as

00:18:46,510 --> 00:18:55,440
essentially take producing a lazy list

00:18:49,900 --> 00:18:57,760
of ways and X match so in generation

00:18:55,440 --> 00:18:59,500
will have to worry about that will have

00:18:57,760 --> 00:19:00,580
to sort of flip that around but there's

00:18:59,500 --> 00:19:03,490
another thing we're going to have to

00:19:00,580 --> 00:19:07,510
worry about which is backing off so what

00:19:03,490 --> 00:19:11,800
happens when we're passing is if we try

00:19:07,510 --> 00:19:14,860
this path subject verb object and it

00:19:11,800 --> 00:19:17,790
turns out that when we get to verb the

00:19:14,860 --> 00:19:21,309
thing that it actually says is it rained

00:19:17,790 --> 00:19:25,510
there's no object so what we do is we

00:19:21,309 --> 00:19:30,309
say oops this path does not work and we

00:19:25,510 --> 00:19:32,650
go over here I it's a thingy what do you

00:19:30,309 --> 00:19:35,580
call them platonic things I don't know

00:19:32,650 --> 00:19:35,580
and all linguist

00:19:36,909 --> 00:19:43,309
playful for some change yeah something

00:19:39,769 --> 00:19:51,109
like that well you know just plenty of

00:19:43,309 --> 00:19:55,159
ever examples why didn't I think of that

00:19:51,109 --> 00:19:56,779
one okay so if we're generating we're

00:19:55,159 --> 00:19:58,549
gonna have to worry about this too okay

00:19:56,779 --> 00:20:00,859
we're going to go down paths trying to

00:19:58,549 --> 00:20:03,229
generate stuff based on stuff that is in

00:20:00,859 --> 00:20:05,690
the tree and then we will get so far and

00:20:03,229 --> 00:20:07,759
will be like huh there's no object in

00:20:05,690 --> 00:20:09,529
this tree so we'll have to fail that

00:20:07,759 --> 00:20:12,139
path and we'll have to go back and try

00:20:09,529 --> 00:20:14,269
this one instead so we're going to have

00:20:12,139 --> 00:20:15,559
to you know when we generate we start

00:20:14,269 --> 00:20:18,440
you're going to have all of this sort of

00:20:15,559 --> 00:20:21,019
backtracking stuff going on all these

00:20:18,440 --> 00:20:23,149
sort of paths not working out and having

00:20:21,019 --> 00:20:26,179
to fail so we need to sort of do all of

00:20:23,149 --> 00:20:28,190
those bits as well so it's not quite

00:20:26,179 --> 00:20:34,309
trivial but it still seems kind of

00:20:28,190 --> 00:20:39,529
doable so let's dig into the meat of the

00:20:34,309 --> 00:20:42,559
problem so what happens when you feed a

00:20:39,529 --> 00:20:45,859
politics compiler a grammar when it

00:20:42,559 --> 00:20:49,219
passes it using a grammar appropriately

00:20:45,859 --> 00:20:53,659
enough and what it does is it turns it

00:20:49,219 --> 00:20:56,929
into an abstract syntax tree so each

00:20:53,659 --> 00:21:02,029
thing say the literals the quantifiers

00:20:56,929 --> 00:21:06,889
the rule calls they all turn into nodes

00:21:02,029 --> 00:21:09,619
in some representation of the Ray X so

00:21:06,889 --> 00:21:13,249
what if we steal that what if we find a

00:21:09,619 --> 00:21:15,889
way to steal those trees that means we

00:21:13,249 --> 00:21:17,629
don't have to pass the ray exes we can

00:21:15,889 --> 00:21:20,929
just let the perfect compiler Postum

00:21:17,629 --> 00:21:24,559
steal the AST and then use it to do the

00:21:20,929 --> 00:21:28,219
generation so the question is how the

00:21:24,559 --> 00:21:32,359
heck do you do that well the compiler is

00:21:28,219 --> 00:21:34,820
written in perl 6 and it's in ok when

00:21:32,359 --> 00:21:40,549
we're passing it sort of is in the

00:21:34,820 --> 00:21:44,419
dynamic scope so what happens if we

00:21:40,549 --> 00:21:46,190
write an export sub and this is

00:21:44,419 --> 00:21:47,040
something that gets run at the point we

00:21:46,190 --> 00:21:50,730
do a use

00:21:47,040 --> 00:21:52,110
of a module and we pass in percent star

00:21:50,730 --> 00:21:56,040
lang which is the current set of

00:21:52,110 --> 00:21:58,680
languages that we're passing and then

00:21:56,040 --> 00:22:05,550
what we do is we take the current action

00:21:58,680 --> 00:22:07,530
methods exactly and we mix a roll into

00:22:05,550 --> 00:22:09,900
them and this is kind of cool because

00:22:07,530 --> 00:22:13,290
we're mixing a plastics roll into like

00:22:09,900 --> 00:22:15,960
the compiler and it's lexically scoped

00:22:13,290 --> 00:22:19,020
so we do it yeah so if you do a use of

00:22:15,960 --> 00:22:20,670
this Eddie grammars that are inside will

00:22:19,020 --> 00:22:23,040
have the ast stolen and do the right

00:22:20,670 --> 00:22:24,210
thing and anything outside one it's like

00:22:23,040 --> 00:22:29,370
this language was really well designed

00:22:24,210 --> 00:22:36,990
or something so so then what we do is we

00:22:29,370 --> 00:22:38,970
just take an override of reg ex debt we

00:22:36,990 --> 00:22:41,040
go and look at the politics grammar and

00:22:38,970 --> 00:22:44,220
realize that the correct thing to steal

00:22:41,040 --> 00:22:47,880
is this thing called nibble omnomnom reg

00:22:44,220 --> 00:22:49,680
ex we do call same to do whatever we

00:22:47,880 --> 00:22:51,690
would have done before and then what

00:22:49,680 --> 00:22:53,940
I've done is I've also just read on the

00:22:51,690 --> 00:22:57,410
extra little matter object which gives

00:22:53,940 --> 00:23:00,300
me a place to save these pieces of AST

00:22:57,410 --> 00:23:03,270
ok so what I do as I get the current

00:23:00,300 --> 00:23:08,100
package this is the current grammar that

00:23:03,270 --> 00:23:10,680
we're passing the way inside off and I

00:23:08,100 --> 00:23:13,230
get the current declan name that is the

00:23:10,680 --> 00:23:15,570
current reg ex and these these are not

00:23:13,230 --> 00:23:17,160
sort of objects that just refer to the

00:23:15,570 --> 00:23:19,260
things these are the actual real objects

00:23:17,160 --> 00:23:21,480
ok so as we're passing your pearl six

00:23:19,260 --> 00:23:22,950
programs we're really making the grammar

00:23:21,480 --> 00:23:25,110
natural object and we're really making

00:23:22,950 --> 00:23:26,880
reg ex objects and when we get to the

00:23:25,110 --> 00:23:29,250
end if you want to make bytecode we just

00:23:26,880 --> 00:23:31,800
see realize a lot but we can get hold of

00:23:29,250 --> 00:23:33,840
donors we're passing so what we do is we

00:23:31,800 --> 00:23:37,830
just steal these bits of a st's and we

00:23:33,840 --> 00:23:40,740
save them under the rule name well that

00:23:37,830 --> 00:23:44,580
was naughty but but we didn't have to

00:23:40,740 --> 00:23:47,190
write any see ya and it's portable it'll

00:23:44,580 --> 00:23:50,690
work on recruiter on JPM eventually as

00:23:47,190 --> 00:23:52,980
well ok

00:23:50,690 --> 00:23:55,680
so let's do something less naughty but

00:23:52,980 --> 00:23:58,110
still kind of cool so what we'll do now

00:23:55,680 --> 00:24:00,570
is we kind of realize that we need that

00:23:58,110 --> 00:24:03,630
generate method so what I'm going to do

00:24:00,570 --> 00:24:06,300
is I'm actually just going to take the

00:24:03,630 --> 00:24:07,920
default metal object for grammars this

00:24:06,300 --> 00:24:11,190
is the object that says how grammars

00:24:07,920 --> 00:24:14,550
work and it turns out that they really

00:24:11,190 --> 00:24:18,060
cute idiom for sort of tweaking the way

00:24:14,550 --> 00:24:21,290
certain keywords work is you you whoops

00:24:18,060 --> 00:24:25,350
we we go into the module export how and

00:24:21,290 --> 00:24:27,330
if you write a class called grammar then

00:24:25,350 --> 00:24:28,860
this is how you can actually say how

00:24:27,330 --> 00:24:31,140
grammars are going to work differently

00:24:28,860 --> 00:24:33,720
cutely if you wanted to say our classes

00:24:31,140 --> 00:24:35,160
work different you write class class and

00:24:33,720 --> 00:24:36,810
it's the fact that it's inside of this

00:24:35,160 --> 00:24:46,320
export how module that makes it all work

00:24:36,810 --> 00:24:52,500
out yes I think so you have to put am I

00:24:46,320 --> 00:24:54,120
on no you wouldn't but you should okay

00:24:52,500 --> 00:24:56,610
so what we do is we just actually

00:24:54,120 --> 00:24:59,130
override new type we delegate to it and

00:24:56,610 --> 00:25:01,440
then we we sneak in this generative role

00:24:59,130 --> 00:25:04,590
okay so every grammar gets a generative

00:25:01,440 --> 00:25:06,120
role mixed in by default and then I have

00:25:04,590 --> 00:25:08,460
some boring code in here which I won't

00:25:06,120 --> 00:25:12,540
show you which is just a hash which maps

00:25:08,460 --> 00:25:16,740
names to the ast s that we captured for

00:25:12,540 --> 00:25:18,780
each of the rules so what about the

00:25:16,740 --> 00:25:22,560
generative role what's this where we

00:25:18,780 --> 00:25:25,680
start to get into the generation so

00:25:22,560 --> 00:25:27,540
let's take it piece by piece there's

00:25:25,680 --> 00:25:32,490
only one method in this role it's called

00:25:27,540 --> 00:25:35,520
generate it takes the thing that we're

00:25:32,490 --> 00:25:38,490
going to use to generate from it takes

00:25:35,520 --> 00:25:41,630
the rule to start generating at which

00:25:38,490 --> 00:25:44,400
defaults the top and there's a colon G

00:25:41,630 --> 00:25:47,070
which means do I want all of the

00:25:44,400 --> 00:25:50,610
possible matches or all the possible

00:25:47,070 --> 00:25:53,790
generations in this case or just one and

00:25:50,610 --> 00:25:56,940
then what I do is I go and I look up the

00:25:53,790 --> 00:25:59,580
generator for the rule of that name

00:25:56,940 --> 00:26:01,830
which is an object that knows how to

00:25:59,580 --> 00:26:03,750
generate based on a certain piece of AST

00:26:01,830 --> 00:26:05,610
I

00:26:03,750 --> 00:26:08,820
cool generate I pass in the grammar

00:26:05,610 --> 00:26:12,630
object itself I pass in the match i bind

00:26:08,820 --> 00:26:14,550
it to an array and then all i do is they

00:26:12,630 --> 00:26:17,190
say well if we need all of them then

00:26:14,550 --> 00:26:19,380
we'll just sit in a gaba and just

00:26:17,190 --> 00:26:21,240
generate and take each one otherwise

00:26:19,380 --> 00:26:22,590
we'll just get the first one okay and

00:26:21,240 --> 00:26:27,450
we're we're string if eyeing it at the

00:26:22,590 --> 00:26:30,990
end as well so that's really just the

00:26:27,450 --> 00:26:38,220
entry point to it so what about the

00:26:30,990 --> 00:26:40,140
generation well basically we sort of do

00:26:38,220 --> 00:26:41,940
a little bit of compilation in here but

00:26:40,140 --> 00:26:43,560
it's not the scary kind of compilation

00:26:41,940 --> 00:26:46,530
it's just making closures and putting

00:26:43,560 --> 00:26:48,420
them in trees so what they do the first

00:26:46,530 --> 00:26:51,300
time we call generate we don't have a

00:26:48,420 --> 00:26:53,700
generator method yet hey that's just a

00:26:51,300 --> 00:26:55,620
an attribute that's going to hold some

00:26:53,700 --> 00:26:59,130
code and this is an attribute that

00:26:55,620 --> 00:27:02,190
contains the AST so what we do is we

00:26:59,130 --> 00:27:04,230
just use the define or and if we don't

00:27:02,190 --> 00:27:06,840
have one of these we go off and compile

00:27:04,230 --> 00:27:09,330
it based on this AST and all compile

00:27:06,840 --> 00:27:14,220
does is it's just big switch statement

00:27:09,330 --> 00:27:15,420
on the type of reg ex node that we're

00:27:14,220 --> 00:27:17,690
currently compiling so it might be a

00:27:15,420 --> 00:27:20,610
quantifier it might be just concatenate

00:27:17,690 --> 00:27:24,060
elisa's of reg ex together it might be a

00:27:20,610 --> 00:27:26,390
literal and what we will do is we'll

00:27:24,060 --> 00:27:28,560
make a little closure for each of these

00:27:26,390 --> 00:27:30,120
which we're going to be able to invoke

00:27:28,560 --> 00:27:32,490
at the end and we're going to put all of

00:27:30,120 --> 00:27:36,120
these together so just to show you a

00:27:32,490 --> 00:27:42,660
couple of examples this is the one for

00:27:36,120 --> 00:27:47,670
literal so a literal has a string that

00:27:42,660 --> 00:27:50,130
we're going to to emit and we just say

00:27:47,670 --> 00:27:52,470
when we have a literal node we make

00:27:50,130 --> 00:27:54,600
disclosure it takes two arguments it

00:27:52,470 --> 00:27:56,280
completely ignores them one is the

00:27:54,600 --> 00:27:58,710
grammar one is the match but it doesn't

00:27:56,280 --> 00:28:00,660
need them in this case and we always

00:27:58,710 --> 00:28:02,100
should return a lazy list but in this

00:28:00,660 --> 00:28:03,570
case we don't need to care about the

00:28:02,100 --> 00:28:08,190
lazy because it's there's just one thing

00:28:03,570 --> 00:28:10,320
in it okay which is the string so this

00:28:08,190 --> 00:28:12,659
sort of ikea side basically all we're

00:28:10,320 --> 00:28:15,090
doing is we're saying well the

00:28:12,659 --> 00:28:18,590
that you generate the text for a literal

00:28:15,090 --> 00:28:23,059
is you just give back the literal string

00:28:18,590 --> 00:28:23,059
so there's only one possibility there

00:28:23,359 --> 00:28:28,739
what about some of the other constructs

00:28:26,149 --> 00:28:31,799
let's talk about sequential alternations

00:28:28,739 --> 00:28:36,029
these ones are more fun so the first

00:28:31,799 --> 00:28:38,249
thing that we do is we take all of the

00:28:36,029 --> 00:28:40,169
things in the alternation okay so we

00:28:38,249 --> 00:28:43,220
might if you remember we had the the

00:28:40,169 --> 00:28:46,229
sentence verb a subject verb object or

00:28:43,220 --> 00:28:48,299
subject verb ok so the subject verb

00:28:46,229 --> 00:28:50,879
object is the first thing in this list

00:28:48,299 --> 00:28:53,340
and the the subject verb would be the

00:28:50,879 --> 00:28:55,950
second and we just mapped them we call

00:28:53,340 --> 00:29:00,539
compile for each one of them so what we

00:28:55,950 --> 00:29:03,299
get back is a array of closures there in

00:29:00,539 --> 00:29:05,039
the at generators which is basically

00:29:03,299 --> 00:29:11,309
something that can generate each of

00:29:05,039 --> 00:29:14,340
these things then we return something

00:29:11,309 --> 00:29:18,239
that takes the current grammar the

00:29:14,340 --> 00:29:20,820
current match date it doesn't gather so

00:29:18,239 --> 00:29:23,460
gavotte take is a very nice little

00:29:20,820 --> 00:29:25,619
construct for building iterators you

00:29:23,460 --> 00:29:27,330
write gather and basically it runs up

00:29:25,619 --> 00:29:29,249
until the first take when it needs an

00:29:27,330 --> 00:29:31,679
item and gives the item back and if we

00:29:29,249 --> 00:29:36,149
another I Soumik runs it again until the

00:29:31,679 --> 00:29:37,619
gets to the next take and so forth so

00:29:36,149 --> 00:29:41,479
what we do is we go through the

00:29:37,619 --> 00:29:44,909
generators we invoke each one of them

00:29:41,479 --> 00:29:47,489
with the grammar and the match and we

00:29:44,909 --> 00:29:50,609
take the results we loop through the

00:29:47,489 --> 00:29:52,769
results taking each one and then there's

00:29:50,609 --> 00:29:55,229
a special exception type here which is

00:29:52,769 --> 00:29:58,799
grammar generate grammar generative

00:29:55,229 --> 00:30:01,320
enable and what this means is the path

00:29:58,799 --> 00:30:04,499
that we went down ran out of ways to

00:30:01,320 --> 00:30:05,820
produce results for us so if that

00:30:04,499 --> 00:30:08,389
happens we'll just try the next

00:30:05,820 --> 00:30:08,389
alternation

00:30:09,200 --> 00:30:16,320
apparently not there was a reason why

00:30:13,440 --> 00:30:17,820
not which boils down to the fact that if

00:30:16,320 --> 00:30:21,870
you can't generate at all you need to

00:30:17,820 --> 00:30:23,940
flow that all the way up to the top and

00:30:21,870 --> 00:30:25,290
we actually throw one here okay if we

00:30:23,940 --> 00:30:27,600
run out of ways that we can possibly

00:30:25,290 --> 00:30:30,030
generate we say at this point okay

00:30:27,600 --> 00:30:32,280
that's it we're out of ways we could

00:30:30,030 --> 00:30:34,500
potentially use an empty list to in the

00:30:32,280 --> 00:30:38,390
end of the list to indicate that as well

00:30:34,500 --> 00:30:38,390
it turned out cleaner with the exception

00:30:38,930 --> 00:30:47,480
okay so basically you do things like

00:30:43,890 --> 00:30:50,640
this but worse the concatenation

00:30:47,480 --> 00:30:52,920
alternation quantifiers sub-rule calls

00:30:50,640 --> 00:30:54,500
and anchors and anchors are a real real

00:30:52,920 --> 00:30:56,910
mess when you're doing this stuff

00:30:54,500 --> 00:30:59,010
because you sort of have to go looking

00:30:56,910 --> 00:31:00,450
either side of them but you're trying to

00:30:59,010 --> 00:31:03,710
generate the string out and I was

00:31:00,450 --> 00:31:06,690
horrible you should see the code anyway

00:31:03,710 --> 00:31:12,620
what we get by the time we've defined

00:31:06,690 --> 00:31:15,840
all of that is something where we take

00:31:12,620 --> 00:31:18,980
some JSON tiny grammar and we call

00:31:15,840 --> 00:31:22,020
generate and if you look we pass it in

00:31:18,980 --> 00:31:25,350
an object which has a pair list which

00:31:22,020 --> 00:31:29,730
has pairs and here's the string for the

00:31:25,350 --> 00:31:31,860
name here is the value sim string okay

00:31:29,730 --> 00:31:37,670
and there's another one and out the

00:31:31,860 --> 00:31:41,280
bottom pops this well there we have it

00:31:37,670 --> 00:31:44,850
the white space comes because every time

00:31:41,280 --> 00:31:47,880
it hits WS at the moment it cheats and

00:31:44,850 --> 00:31:50,840
says oh his face is always safe so it

00:31:47,880 --> 00:31:54,030
actually gets multiple of them in that

00:31:50,840 --> 00:31:56,880
we could be cleverer but I wasn't

00:31:54,030 --> 00:31:59,040
feeling Clive arena well actually is

00:31:56,880 --> 00:32:00,870
indicating that most of those angle

00:31:59,040 --> 00:32:02,940
question marks were unnecessary the

00:32:00,870 --> 00:32:04,350
original grammar because the rule

00:32:02,940 --> 00:32:08,520
calling had already ate the white space

00:32:04,350 --> 00:32:10,700
yes apparently so damn i wish i was last

00:32:08,520 --> 00:32:10,700
month

00:32:10,889 --> 00:32:17,589
okay so this is almost good however

00:32:15,369 --> 00:32:19,749
we're not quite there yet and the reason

00:32:17,589 --> 00:32:23,199
we're not quite there yet is because if

00:32:19,749 --> 00:32:26,109
you remember we had these really nice

00:32:23,199 --> 00:32:28,539
action methods we had these things where

00:32:26,109 --> 00:32:31,389
instead of you getting this big AST back

00:32:28,539 --> 00:32:33,909
this big match tree back you got a real

00:32:31,389 --> 00:32:38,549
object back so what are the equivalent

00:32:33,909 --> 00:32:41,169
to those if we think about it actions

00:32:38,549 --> 00:32:43,899
get run on the way back up okay it's all

00:32:41,169 --> 00:32:46,299
the way down the tree we pass decides

00:32:43,899 --> 00:32:48,879
where are we going and as we come back

00:32:46,299 --> 00:32:50,469
up the tree we build up that result data

00:32:48,879 --> 00:32:55,329
structure so actioned run on the way

00:32:50,469 --> 00:32:59,379
back up so what we need is something

00:32:55,329 --> 00:33:03,189
that will go the opposite way round so

00:32:59,379 --> 00:33:06,189
each need to turn it backwards we need

00:33:03,189 --> 00:33:09,969
to run something on the way down and

00:33:06,189 --> 00:33:12,519
then assemble the string on the way up

00:33:09,969 --> 00:33:14,499
okay so what we're going to be doing is

00:33:12,519 --> 00:33:18,009
running whatever we call these things as

00:33:14,499 --> 00:33:19,889
we go down and try and figure out how

00:33:18,009 --> 00:33:22,059
we're going to generate the string and

00:33:19,889 --> 00:33:23,709
will be generating the string and

00:33:22,059 --> 00:33:25,599
getting the string out at the top so

00:33:23,709 --> 00:33:30,669
basically it's just you know flipping

00:33:25,599 --> 00:33:38,349
the sides so I called these things back

00:33:30,669 --> 00:33:41,289
shins and yeah what you do is you just

00:33:38,349 --> 00:33:44,309
write methods which correspond to rule

00:33:41,289 --> 00:33:48,429
names and what they do is they produce

00:33:44,309 --> 00:33:50,619
the capture which will be used to

00:33:48,429 --> 00:33:54,359
generate that kind of rule so what you

00:33:50,619 --> 00:33:57,729
see here is if at the top we're past in

00:33:54,359 --> 00:34:00,879
some kind of array then we end up in

00:33:57,729 --> 00:34:03,399
this multi-candidate like this and what

00:34:00,879 --> 00:34:06,719
we do is we say well if you have one of

00:34:03,399 --> 00:34:09,190
these then you need to take the array

00:34:06,719 --> 00:34:11,230
half remember the grammar had a path

00:34:09,190 --> 00:34:13,089
that we could follow for arrays and for

00:34:11,230 --> 00:34:15,879
objects so we say you take the array

00:34:13,089 --> 00:34:17,529
path and then what you need to do for

00:34:15,879 --> 00:34:19,869
the array is you need to take this data

00:34:17,529 --> 00:34:21,819
structure and dice it so dice is kind of

00:34:19,869 --> 00:34:22,339
the opposite of make we have real fun

00:34:21,819 --> 00:34:24,379
coming up

00:34:22,339 --> 00:34:25,809
word for this I was trying to get Carl

00:34:24,379 --> 00:34:28,129
to help me with this on the plane and

00:34:25,809 --> 00:34:29,839
originally I went with break because you

00:34:28,129 --> 00:34:31,519
know you make or break but then I

00:34:29,839 --> 00:34:34,190
realized break would confuse every C

00:34:31,519 --> 00:34:36,049
program ever so we didn't do that one

00:34:34,190 --> 00:34:37,399
and then it's kind of like well what are

00:34:36,049 --> 00:34:40,549
equivalent to break and there's like

00:34:37,399 --> 00:34:42,139
burst destroy devastate and then it's

00:34:40,549 --> 00:34:44,479
like well no what you're doing is sort

00:34:42,139 --> 00:34:47,779
of taking it apart so you know like

00:34:44,479 --> 00:34:52,700
deconstruct and it went on forever what

00:34:47,779 --> 00:34:56,989
slice yeah we discussed slice it puns

00:34:52,700 --> 00:34:59,359
badly yeah so we ended up with dice

00:34:56,989 --> 00:35:02,569
which is well what you do with meat I

00:34:59,359 --> 00:35:07,849
guess or something so what this does is

00:35:02,569 --> 00:35:13,880
it basically what's done no no no the

00:35:07,849 --> 00:35:16,609
verb dice subs of verbs okay so apart

00:35:13,880 --> 00:35:19,910
from when you Nana so what we're doing

00:35:16,609 --> 00:35:21,529
here is we are just taking that array

00:35:19,910 --> 00:35:24,140
and just saying I want to shove that

00:35:21,529 --> 00:35:28,880
down and when we actually try to call

00:35:24,140 --> 00:35:33,469
and generate an array for the text then

00:35:28,880 --> 00:35:34,819
what we should do is we should run well

00:35:33,469 --> 00:35:36,469
the array bit of code and we did the

00:35:34,819 --> 00:35:39,289
same for object and basically this is

00:35:36,469 --> 00:35:41,839
the way that objects work okay we take

00:35:39,289 --> 00:35:45,200
the hash and weed ice it into its pass

00:35:41,839 --> 00:35:48,200
for perilous pair list gets the pass and

00:35:45,200 --> 00:35:51,469
it maps them and dices every one of them

00:35:48,200 --> 00:35:53,930
and then puts that array of pair hair is

00:35:51,469 --> 00:35:56,539
quantified so it calls pair for each

00:35:53,930 --> 00:35:59,089
individual one of them which then says

00:35:56,539 --> 00:36:03,349
well we'll have the string being this

00:35:59,089 --> 00:36:04,789
and the value will need to dice okay and

00:36:03,349 --> 00:36:07,900
then the value it's actually smart

00:36:04,789 --> 00:36:11,749
enough to sort of go and call that and

00:36:07,900 --> 00:36:14,269
just like we use protos we can actually

00:36:11,749 --> 00:36:15,859
use multiple dispatch on this site on

00:36:14,269 --> 00:36:17,749
the data structure which works out kind

00:36:15,859 --> 00:36:22,160
of nicely so this is the way we say oh

00:36:17,749 --> 00:36:24,950
this is a number so you put it all

00:36:22,160 --> 00:36:27,170
together and what we can do is we can

00:36:24,950 --> 00:36:29,509
feed this little data structure in here

00:36:27,170 --> 00:36:32,839
which is something very much like what

00:36:29,509 --> 00:36:35,360
Jason Tiny's pass with the actions would

00:36:32,839 --> 00:36:39,050
give us we feed in the back shin

00:36:35,360 --> 00:36:48,100
and we get out the JSON mission

00:36:39,050 --> 00:36:53,180
accomplished so I write to the module

00:36:48,100 --> 00:36:54,620
it's still quite experimental but

00:36:53,180 --> 00:36:56,750
basically to give a gram of these

00:36:54,620 --> 00:36:58,520
capabilities you just do use grammar

00:36:56,750 --> 00:37:00,740
generative in the scope where the

00:36:58,520 --> 00:37:04,160
grammar is and it gives you this stuff

00:37:00,740 --> 00:37:18,290
any guesses how many lines of code this

00:37:04,160 --> 00:37:19,490
one took in total I don't understand you

00:37:18,290 --> 00:37:27,440
know the answer we'll have to go and

00:37:19,490 --> 00:37:31,660
have a look it is Wow wait I already

00:37:27,440 --> 00:37:40,670
pushed this to github who was cheating

00:37:31,660 --> 00:37:42,200
okay I yeah so so the surprise was

00:37:40,670 --> 00:37:45,980
actually that the one freaking cat was

00:37:42,200 --> 00:37:49,130
really good fun and the reason the one

00:37:45,980 --> 00:37:52,190
 cat was really good fun it's

00:37:49,130 --> 00:37:53,960
because basically things being next to

00:37:52,190 --> 00:37:55,730
each other can all backtrack in all the

00:37:53,960 --> 00:37:57,890
combinations if you want to generate all

00:37:55,730 --> 00:38:00,800
the ways so what you actually end up

00:37:57,890 --> 00:38:03,320
doing is recursing cliff this collect

00:38:00,800 --> 00:38:05,000
routine which uses the signature syntax

00:38:03,320 --> 00:38:07,670
to pull out the first item and leave the

00:38:05,000 --> 00:38:09,230
rest and then it recursos and you're

00:38:07,670 --> 00:38:11,840
sort of recursively setting up this

00:38:09,230 --> 00:38:13,940
chain of gathers and then hopefully they

00:38:11,840 --> 00:38:18,560
all take to the right place and it

00:38:13,940 --> 00:38:21,830
actually works which is kind of cute my

00:38:18,560 --> 00:38:25,280
mashina homes are like 16 gigs but this

00:38:21,830 --> 00:38:30,110
actually runs by the way so the demo

00:38:25,280 --> 00:38:33,110
script is just the grammar okay and the

00:38:30,110 --> 00:38:38,360
actions the back shins even okay so you

00:38:33,110 --> 00:38:42,410
do I and there's the little line at the

00:38:38,360 --> 00:38:44,740
bottom okay oh there it is okay so that

00:38:42,410 --> 00:38:44,740
we have it

00:38:45,960 --> 00:38:53,250
okay so thank you very much that's how

00:38:48,910 --> 00:38:55,780
you turn grammas ground any questions

00:38:53,250 --> 00:38:58,840
when I read the inscription this talk

00:38:55,780 --> 00:39:00,910
about your TV doing was adding

00:38:58,840 --> 00:39:02,740
probability annotations to april six

00:39:00,910 --> 00:39:03,940
grammar than you and then using it and

00:39:02,740 --> 00:39:05,710
then turning it into a stochastic

00:39:03,940 --> 00:39:09,190
context-free grammar and using its

00:39:05,710 --> 00:39:11,530
randomly generate input for a blue fuzz

00:39:09,190 --> 00:39:13,420
testing purposes that would be a lot of

00:39:11,530 --> 00:39:16,300
fun as well and I think that's kind of

00:39:13,420 --> 00:39:18,160
why the G option is there so that you

00:39:16,300 --> 00:39:21,340
can actually get it to spit out lots of

00:39:18,160 --> 00:39:23,110
random things so I think there's gonna

00:39:21,340 --> 00:39:26,620
be a whole load of fuzzing applications

00:39:23,110 --> 00:39:28,720
for this as well down the line so that's

00:39:26,620 --> 00:39:44,830
an area of future exploration but yes it

00:39:28,720 --> 00:39:46,960
would be cool okay yeah can you deal

00:39:44,830 --> 00:39:58,330
with white space it isn't gonna put back

00:39:46,960 --> 00:40:00,760
the pod comments no yeah I mean it you

00:39:58,330 --> 00:40:03,310
know it puts in white space in the

00:40:00,760 --> 00:40:07,330
places where it stinks in you know needs

00:40:03,310 --> 00:40:12,220
it according to the ws rule but you know

00:40:07,330 --> 00:40:14,740
it doesn't preserve it as such hmm

00:40:12,220 --> 00:40:19,380
anymore I can't actually see to the back

00:40:14,740 --> 00:40:19,380
of the room is there someone there okay

00:40:21,030 --> 00:40:25,859
sorry

00:40:23,210 --> 00:40:28,799
once the network ever recording the line

00:40:25,859 --> 00:40:30,270
numbers okay the question was you want

00:40:28,799 --> 00:40:38,490
to have the line numbers attached the

00:40:30,270 --> 00:40:43,349
line numbers of what exactly yeah it's

00:40:38,490 --> 00:40:44,880
the same errors is important oh you mean

00:40:43,349 --> 00:40:50,250
when you're passing you'd like a way to

00:40:44,880 --> 00:40:56,849
get hold of the curb line number is that

00:40:50,250 --> 00:41:01,140
spect somewhere okay well you do

00:40:56,849 --> 00:41:03,059
precision so far well yeah you can

00:41:01,140 --> 00:41:04,290
always get the current position I mean

00:41:03,059 --> 00:41:05,670
if you fail you can always get the

00:41:04,290 --> 00:41:08,160
position to where you've matched up to

00:41:05,670 --> 00:41:11,220
so you can you can then count the lines

00:41:08,160 --> 00:41:15,000
from that let's just plus whatever don't

00:41:11,220 --> 00:41:16,829
lines one thing that we do when we're

00:41:15,000 --> 00:41:19,319
actually passing pearl six programs is

00:41:16,829 --> 00:41:21,290
we keep a high watermark which is the

00:41:19,319 --> 00:41:23,609
farthest we passed before we ever failed

00:41:21,290 --> 00:41:32,809
maybe we should expose dad's in a more

00:41:23,609 --> 00:41:32,809
general way maybe yeah anything else

00:41:33,440 --> 00:41:40,300
okay then I thank you for enduring this

00:41:36,890 --> 00:41:40,300

YouTube URL: https://www.youtube.com/watch?v=RPQvtfwsilM


