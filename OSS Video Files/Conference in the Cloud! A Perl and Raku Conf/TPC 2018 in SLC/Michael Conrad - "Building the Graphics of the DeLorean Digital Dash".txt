Title: Michael Conrad - "Building the Graphics of the DeLorean Digital Dash"
Publication date: 2018-06-19
Playlist: TPC 2018 in SLC
Description: 
	Come see the code behind the dashboard! Learn a bit about OpenGL, how to quickly prototype things with it, and how to speed up your inner loops with a little Inline::C
Captions: 
	00:00:00,000 --> 00:00:07,010
all right I'm Mike Conrad I've given

00:00:03,270 --> 00:00:10,080
talks in the several in the past about

00:00:07,010 --> 00:00:14,759
the dashboard software I wrote for my

00:00:10,080 --> 00:00:16,379
DeLorean it's all written in Perl it's

00:00:14,759 --> 00:00:21,390
running on a computer inside of the

00:00:16,379 --> 00:00:25,320
instrument cluster and so in the story I

00:00:21,390 --> 00:00:27,390
told three years ago was how from 2011

00:00:25,320 --> 00:00:31,740
to 2014 I was trying to write all of the

00:00:27,390 --> 00:00:34,890
software in C++ and I wasn't getting

00:00:31,740 --> 00:00:36,870
very far and you know they were the big

00:00:34,890 --> 00:00:39,090
problem was that it's complicated enough

00:00:36,870 --> 00:00:40,829
to write elaborate programs in C++ that

00:00:39,090 --> 00:00:43,340
I didn't really have time to fit it into

00:00:40,829 --> 00:00:48,450
my spare weekends and things like that

00:00:43,340 --> 00:00:51,960
so then in 2014 I had recently run

00:00:48,450 --> 00:00:55,020
across the inline cpp module and I was

00:00:51,960 --> 00:00:59,520
like you know I bet I can move a bit of

00:00:55,020 --> 00:01:01,230
my code from the C++ version into Perl

00:00:59,520 --> 00:01:03,210
and not have to rewrite everything and

00:01:01,230 --> 00:01:07,350
so I started a rewrite of the main

00:01:03,210 --> 00:01:12,060
program in Perl and then in 2015 I

00:01:07,350 --> 00:01:14,729
presented the story at yep C so now I've

00:01:12,060 --> 00:01:16,890
actually since then I haven't really

00:01:14,729 --> 00:01:18,900
done actually a whole lot of work on the

00:01:16,890 --> 00:01:20,549
main project but I've been you know

00:01:18,900 --> 00:01:22,380
people were interested and you know how

00:01:20,549 --> 00:01:23,909
I did it and what I had done and so I

00:01:22,380 --> 00:01:26,130
started trying to package some of this

00:01:23,909 --> 00:01:29,549
stuff up for Sipan and so the first

00:01:26,130 --> 00:01:31,470
thing I did was take all of my well one

00:01:29,549 --> 00:01:32,220
when I inside of the one this is running

00:01:31,470 --> 00:01:34,740
in the DeLorean

00:01:32,220 --> 00:01:37,500
there is no display manager so it's just

00:01:34,740 --> 00:01:38,759
running directly on x11 and so the first

00:01:37,500 --> 00:01:40,220
thing I did was packaged up a whole

00:01:38,759 --> 00:01:43,530
bunch of the stuff that I had done and

00:01:40,220 --> 00:01:48,240
merge it into the existing module X 11 X

00:01:43,530 --> 00:01:51,860
Lib and then all the stuff for OpenGL on

00:01:48,240 --> 00:01:56,159
x11 I packaged that up into x11 GL X and

00:01:51,860 --> 00:01:58,579
then just this past few months I have

00:01:56,159 --> 00:02:01,469
taken all of the little shorthand

00:01:58,579 --> 00:02:03,630
notation stuff or sugar you know

00:02:01,469 --> 00:02:08,970
syntactic sugar that I wrote and

00:02:03,630 --> 00:02:11,640
packaged it up into opengl sandbox and

00:02:08,970 --> 00:02:13,650
so there's there's been you know people

00:02:11,640 --> 00:02:15,659
asking me about

00:02:13,650 --> 00:02:17,280
you know what what do the graphics look

00:02:15,659 --> 00:02:19,079
like you know show the code you know

00:02:17,280 --> 00:02:20,790
what does the code look like and so now

00:02:19,079 --> 00:02:22,980
we're actually I'm actually going to be

00:02:20,790 --> 00:02:25,140
able to show some of that so without you

00:02:22,980 --> 00:02:26,819
know revealing all of the horrible crazy

00:02:25,140 --> 00:02:30,930
stuff that I threw together in the last

00:02:26,819 --> 00:02:32,909
minute but more practically because and

00:02:30,930 --> 00:02:39,000
maybe I should have emphasized this in

00:02:32,909 --> 00:02:41,340
the talk per name but I'm going to show

00:02:39,000 --> 00:02:44,640
off how to do high-performance Perl

00:02:41,340 --> 00:02:45,750
using inline C so because I you know

00:02:44,640 --> 00:02:47,519
there's probably not a whole lot of

00:02:45,750 --> 00:02:49,019
people who want to write dashboards for

00:02:47,519 --> 00:02:50,639
their car but there's probably a lot of

00:02:49,019 --> 00:02:53,639
people who are interested in getting a

00:02:50,639 --> 00:02:55,530
little extra performance out of Perl so

00:02:53,639 --> 00:03:00,030
but before that I'm going to talk about

00:02:55,530 --> 00:03:03,480
building blocks and here you have legos

00:03:00,030 --> 00:03:05,549
and they're very easy to connect

00:03:03,480 --> 00:03:08,639
together you can sit down grab Legos

00:03:05,549 --> 00:03:13,189
throw them together no problem you know

00:03:08,639 --> 00:03:17,549
and so this new is sort of analogous to

00:03:13,189 --> 00:03:20,129
you know pearl in a lot of ways and then

00:03:17,549 --> 00:03:21,419
here you have an erector set and it's

00:03:20,129 --> 00:03:23,220
made out of metal and it has little

00:03:21,419 --> 00:03:25,410
holes in the metal panels and then you

00:03:23,220 --> 00:03:27,359
get the tiny little screws and you sit

00:03:25,410 --> 00:03:29,400
there for hours on end putting tiny

00:03:27,359 --> 00:03:30,780
little nuts on tiny little screws and

00:03:29,400 --> 00:03:33,419
trying to work your fingers in between

00:03:30,780 --> 00:03:35,250
metal girders and you don't get anywhere

00:03:33,419 --> 00:03:38,629
very fast but when you're done you have

00:03:35,250 --> 00:03:41,190
a really solid thing you know it's it's

00:03:38,629 --> 00:03:44,760
has a lot of strength for the amount of

00:03:41,190 --> 00:03:49,680
weight of the device and this matters

00:03:44,760 --> 00:03:51,180
sometimes so back in a quick story back

00:03:49,680 --> 00:03:53,879
in high school we had this thing called

00:03:51,180 --> 00:03:56,310
the Science Olympiad and it was like a

00:03:53,879 --> 00:03:58,859
countywide organization and Ohio I don't

00:03:56,310 --> 00:04:01,949
know how wide that is but you know in

00:03:58,859 --> 00:04:03,840
other states but so we would get

00:04:01,949 --> 00:04:06,060
together and have like this multi event

00:04:03,840 --> 00:04:08,909
competition and one of the events was to

00:04:06,060 --> 00:04:10,229
build a site or a physics vehicle that

00:04:08,909 --> 00:04:12,810
would perform some interesting tasks

00:04:10,229 --> 00:04:15,629
using nothing but physical energy and so

00:04:12,810 --> 00:04:18,030
this one particular year they the the

00:04:15,629 --> 00:04:21,030
project was to build a device that would

00:04:18,030 --> 00:04:24,029
travel forward like 105 meters and then

00:04:21,030 --> 00:04:26,130
shoot ping pong balls at a target it had

00:04:24,029 --> 00:04:27,040
to be completely powered with mechanical

00:04:26,130 --> 00:04:29,410
energy so

00:04:27,040 --> 00:04:32,680
no electronics no chemical batteries

00:04:29,410 --> 00:04:34,000
anything like that and I was like hey

00:04:32,680 --> 00:04:35,980
you know I'll build this thing out of

00:04:34,000 --> 00:04:38,830
Legos because you know Legos are fast

00:04:35,980 --> 00:04:41,290
and you know I want to you know spend

00:04:38,830 --> 00:04:42,850
more time on the the part where I you

00:04:41,290 --> 00:04:44,200
know keep changing the design to aim the

00:04:42,850 --> 00:04:46,900
ping pong balls because I was worth a

00:04:44,200 --> 00:04:48,610
lot of points so I don't actually I

00:04:46,900 --> 00:04:51,310
couldn't find a picture of the original

00:04:48,610 --> 00:04:54,070
but I am a terrible hoarder and I still

00:04:51,310 --> 00:04:56,830
have it in a box so here's here's the

00:04:54,070 --> 00:05:00,070
the modified version two of the science

00:04:56,830 --> 00:05:02,260
olympiad vehicle you'll notice that well

00:05:00,070 --> 00:05:03,670
this one has a electric motor to aim it

00:05:02,260 --> 00:05:05,770
up and down but the original was like

00:05:03,670 --> 00:05:07,720
hand adjusted and had some extra stuff

00:05:05,770 --> 00:05:12,930
on the top for firing the ping-pong

00:05:07,720 --> 00:05:15,280
balls and it you would like you know

00:05:12,930 --> 00:05:16,840
well the details aren't very important

00:05:15,280 --> 00:05:21,540
but you'll notice how there's like this

00:05:16,840 --> 00:05:24,940
really strong build up around this lower

00:05:21,540 --> 00:05:27,100
pivot point and that wasn't there in the

00:05:24,940 --> 00:05:28,780
original version and so in we got to the

00:05:27,100 --> 00:05:30,490
science olympiad and one of the the

00:05:28,780 --> 00:05:34,060
problems was how to get the vehicle to

00:05:30,490 --> 00:05:36,370
roll forward five meters right you know

00:05:34,060 --> 00:05:37,840
and so some of the teams came up with

00:05:36,370 --> 00:05:39,580
this idea that oh well you could put it

00:05:37,840 --> 00:05:42,460
on a ramp and it would roll off the ramp

00:05:39,580 --> 00:05:43,990
well Lego wheels weren't you know they

00:05:42,460 --> 00:05:46,210
were too high friction to roll very far

00:05:43,990 --> 00:05:49,690
so rolling off a ramp wasn't gonna work

00:05:46,210 --> 00:05:51,100
and so then some people were launching

00:05:49,690 --> 00:05:52,810
it with a rubber band so you would pull

00:05:51,100 --> 00:05:54,730
it back in a rubber band and then you

00:05:52,810 --> 00:05:55,870
the timer would start you'd let go and

00:05:54,730 --> 00:05:58,060
your vehicle would go flying forward

00:05:55,870 --> 00:06:00,310
well again there's high friction in the

00:05:58,060 --> 00:06:03,190
wheels and you know so we decided to

00:06:00,310 --> 00:06:05,260
combine a ramp with rubber band for ours

00:06:03,190 --> 00:06:06,700
and so at the last minute without having

00:06:05,260 --> 00:06:08,800
actually tested it we took the vehicle

00:06:06,700 --> 00:06:09,970
and we put it on a ramp and we pulled

00:06:08,800 --> 00:06:11,650
back the rubber band and they started

00:06:09,970 --> 00:06:15,460
the timer and we launched it and it blew

00:06:11,650 --> 00:06:17,350
apart into 100 pieces and we spent the

00:06:15,460 --> 00:06:19,570
rest of our time limits attempting to

00:06:17,350 --> 00:06:22,540
reassemble it and we got you know

00:06:19,570 --> 00:06:24,100
that every second counted against you so

00:06:22,540 --> 00:06:28,650
we ended up with the largest negative

00:06:24,100 --> 00:06:31,570
score of any team in the competition so

00:06:28,650 --> 00:06:33,730
the fatal mistake I would say is that I

00:06:31,570 --> 00:06:35,680
chose to use Legos instead of something

00:06:33,730 --> 00:06:38,080
that can withstand physical stresses a

00:06:35,680 --> 00:06:39,879
little better like erector if I had

00:06:38,080 --> 00:06:41,949
built it in erector

00:06:39,879 --> 00:06:43,749
something like that we could have

00:06:41,949 --> 00:06:45,639
launched off the ramp with a giant

00:06:43,749 --> 00:06:47,349
rubber band or it could even have

00:06:45,639 --> 00:06:49,809
withstood the forces needed to wrap a

00:06:47,349 --> 00:06:54,179
rubber band around the axle and you know

00:06:49,809 --> 00:06:57,879
drive it forward far enough so anyway

00:06:54,179 --> 00:07:05,110
the lesson from that was use the right

00:06:57,879 --> 00:07:09,550
tool for the job however well and and so

00:07:05,110 --> 00:07:11,499
you know applying this to software high

00:07:09,550 --> 00:07:13,509
level software is really good for rapid

00:07:11,499 --> 00:07:16,479
development but it gives you kind of

00:07:13,509 --> 00:07:18,569
limited performance low-level software

00:07:16,479 --> 00:07:21,069
is really good for extreme efficiency

00:07:18,569 --> 00:07:24,309
but if your problem is too complex you

00:07:21,069 --> 00:07:27,069
might not finish and so the lesson I got

00:07:24,309 --> 00:07:28,119
from my DeLorean dashboard effort in

00:07:27,069 --> 00:07:34,240
00:07:28,119 --> 00:07:36,129
oh yeah is that you know I tried it the

00:07:34,240 --> 00:07:38,529
right way but I didn't have time to

00:07:36,129 --> 00:07:41,469
actually do it the right way and so the

00:07:38,529 --> 00:07:47,499
lesson is there's no point in doing it

00:07:41,469 --> 00:07:48,729
right if you never finish so there's got

00:07:47,499 --> 00:07:50,169
to be some middle ground I've had I've

00:07:48,729 --> 00:07:52,209
had a letter I've had contradictory

00:07:50,169 --> 00:07:55,240
lessons in my life on those two points

00:07:52,209 --> 00:07:57,309
and so one of the things that I have you

00:07:55,240 --> 00:07:58,899
know kind of developed an opinion on is

00:07:57,309 --> 00:08:01,300
that you should use the most efficient

00:07:58,899 --> 00:08:03,490
building blocks for the foundation of

00:08:01,300 --> 00:08:07,659
your project and then build the upper

00:08:03,490 --> 00:08:09,639
layers with glue don't expect the

00:08:07,659 --> 00:08:12,550
foundation to reach to the you know the

00:08:09,639 --> 00:08:14,889
completion of your project because the

00:08:12,550 --> 00:08:17,289
foundation blocks are at you know they

00:08:14,889 --> 00:08:19,439
take a long time to write but also don't

00:08:17,289 --> 00:08:24,419
expect glue to be your foundation and

00:08:19,439 --> 00:08:28,839
that might apply to projects like moose

00:08:24,419 --> 00:08:31,990
and so you know gluing things together

00:08:28,839 --> 00:08:34,810
with purl the most common one is see

00:08:31,990 --> 00:08:36,699
libraries with excess bindings and you

00:08:34,810 --> 00:08:38,740
know so there's good recipes and

00:08:36,699 --> 00:08:40,479
tutorials for this and you sit down with

00:08:38,740 --> 00:08:41,889
the excess tutorial and learn all the

00:08:40,479 --> 00:08:44,410
crazy details you're gonna have to go

00:08:41,889 --> 00:08:46,410
through to you know attach to the seed

00:08:44,410 --> 00:08:53,530
library and attach to pearls API

00:08:46,410 --> 00:08:55,090
internal API but excess is hard and it's

00:08:53,530 --> 00:08:57,430
really tempting to just go ahead and

00:08:55,090 --> 00:08:59,380
write the foundations in Perl because

00:08:57,430 --> 00:09:05,320
you know save you you want to save the

00:08:59,380 --> 00:09:06,910
time and you know so that the sea itself

00:09:05,320 --> 00:09:09,910
isn't that hard but it's mostly the

00:09:06,910 --> 00:09:11,980
packaging of C into libraries and then

00:09:09,910 --> 00:09:14,860
linking libraries with Perl that you

00:09:11,980 --> 00:09:17,830
know causes the hassle and that's when I

00:09:14,860 --> 00:09:21,250
discovered in line and also I want to

00:09:17,830 --> 00:09:23,110
take a quick shout out to will Braswell

00:09:21,250 --> 00:09:25,060
the author of our Perl he's kind of

00:09:23,110 --> 00:09:26,620
tackling the same issue and he's giving

00:09:25,060 --> 00:09:29,590
several talks this weekend there this

00:09:26,620 --> 00:09:34,000
week so our Perl is another way that you

00:09:29,590 --> 00:09:36,880
can get more performance directly from

00:09:34,000 --> 00:09:41,440
Perl without having to go write extra C

00:09:36,880 --> 00:09:44,560
modules externally so here's an example

00:09:41,440 --> 00:09:46,270
of X s that is the most you know simple

00:09:44,560 --> 00:09:48,130
function you can imagine it's it

00:09:46,270 --> 00:09:49,870
multiplies two numbers it takes two

00:09:48,130 --> 00:09:51,610
arguments both are floating-point it

00:09:49,870 --> 00:09:53,620
multiplies them together and it returns

00:09:51,610 --> 00:09:56,140
them but you have to read all of that

00:09:53,620 --> 00:09:57,790
boilerplate so you have to you know

00:09:56,140 --> 00:10:02,620
declare the type of the variable

00:09:57,790 --> 00:10:04,120
separate from the argument list and you

00:10:02,620 --> 00:10:06,700
know then you have this weird code and

00:10:04,120 --> 00:10:10,000
output ret vowel thing and then there's

00:10:06,700 --> 00:10:12,970
a PP code option if your output return

00:10:10,000 --> 00:10:14,650
value is not a single scalar and some

00:10:12,970 --> 00:10:17,260
other awkward stuff and you know it just

00:10:14,650 --> 00:10:18,580
takes a long time to learn and then on

00:10:17,260 --> 00:10:21,070
top of that you have to write this

00:10:18,580 --> 00:10:23,110
awkward make file so you can't just like

00:10:21,070 --> 00:10:24,850
run the program and see what it did you

00:10:23,110 --> 00:10:26,620
have to make the program and then run it

00:10:24,850 --> 00:10:28,150
and then make the you know edit the code

00:10:26,620 --> 00:10:31,750
and then run the make file and then

00:10:28,150 --> 00:10:33,370
again and you have to reinstall it after

00:10:31,750 --> 00:10:35,050
every change if you've got kind of a

00:10:33,370 --> 00:10:37,780
wider project that has multiple

00:10:35,050 --> 00:10:39,100
directories or something like that or

00:10:37,780 --> 00:10:43,180
you can make a make file for the entire

00:10:39,100 --> 00:10:45,520
project as a whole but your so it really

00:10:43,180 --> 00:10:47,290
impacts your ability to quickly develop

00:10:45,520 --> 00:10:49,330
things when you have to keep changing to

00:10:47,290 --> 00:10:50,740
a different directory and then running

00:10:49,330 --> 00:10:51,700
the make file and then running install

00:10:50,740 --> 00:10:55,150
and then going back to the first

00:10:51,700 --> 00:10:58,270
directory and running your Perl code so

00:10:55,150 --> 00:11:01,810
inline makes this way easier so there

00:10:58,270 --> 00:11:04,510
you have the use in line C that invokes

00:11:01,810 --> 00:11:06,360
the the in line can actually be plug a

00:11:04,510 --> 00:11:09,870
lot of different languages into Perl

00:11:06,360 --> 00:11:11,040
this is the so you say use inline seed

00:11:09,870 --> 00:11:18,300
to indicate that you're going to give it

00:11:11,040 --> 00:11:20,760
C code and then you give it a string of

00:11:18,300 --> 00:11:22,200
C code you can also give it a file name

00:11:20,760 --> 00:11:23,670
you can give it a you know you can

00:11:22,200 --> 00:11:25,380
deliver the C code in several different

00:11:23,670 --> 00:11:27,570
ways but the easiest one you say you

00:11:25,380 --> 00:11:30,360
just paste the C code right into the

00:11:27,570 --> 00:11:32,279
middle of your Perl code and so if you

00:11:30,360 --> 00:11:35,100
had written that in the middle of your

00:11:32,279 --> 00:11:36,450
Perl module then at runtime you know

00:11:35,100 --> 00:11:37,920
basically as soon as you run your Perl

00:11:36,450 --> 00:11:39,839
script you would have a function named

00:11:37,920 --> 00:11:42,720
add doubles available and it would take

00:11:39,839 --> 00:11:45,860
two arguments and return one value there

00:11:42,720 --> 00:11:45,860
was the two numbers multiplied together

00:11:46,399 --> 00:11:52,380
and no make file every time you run your

00:11:50,459 --> 00:11:54,660
Perl script it automatically compiles if

00:11:52,380 --> 00:11:57,810
it checks to see if it's already cashed

00:11:54,660 --> 00:11:59,339
that compliation so the end to start the

00:11:57,810 --> 00:12:02,550
startup overhead is actually really low

00:11:59,339 --> 00:12:07,079
if it's already compiled so this is this

00:12:02,550 --> 00:12:08,820
is a great way to prototype stuff so and

00:12:07,079 --> 00:12:10,500
you know so that's kind of what I want

00:12:08,820 --> 00:12:14,540
to talk about a lot is you know Perl and

00:12:10,500 --> 00:12:18,800
C++ for this talk but first I need to go

00:12:14,540 --> 00:12:22,110
address the naysayers about OpenGL so

00:12:18,800 --> 00:12:24,029
OpenGL has a classic API from you know

00:12:22,110 --> 00:12:27,360
born sometime in the 80s I think

00:12:24,029 --> 00:12:31,800
probably you know by SGI and then they

00:12:27,360 --> 00:12:33,930
have it was it kind of made 3d graphics

00:12:31,800 --> 00:12:36,449
very easy you would just kind of plot

00:12:33,930 --> 00:12:38,519
out your geometry vertex at a time and

00:12:36,449 --> 00:12:39,149
describing the you know polygons and

00:12:38,519 --> 00:12:41,310
things like that

00:12:39,149 --> 00:12:43,170
and then you know people decided that

00:12:41,310 --> 00:12:45,899
they wanted to like run their own you

00:12:43,170 --> 00:12:48,690
know custom math on the process on the

00:12:45,899 --> 00:12:50,370
graphics hardware and so they had to

00:12:48,690 --> 00:12:52,860
come up with some you know much more

00:12:50,370 --> 00:12:55,709
elaborate api's to handle that stuff so

00:12:52,860 --> 00:12:57,660
there's a you know modern open if you

00:12:55,709 --> 00:12:58,529
say OpenGL today people just probably

00:12:57,660 --> 00:13:00,779
assume that you're talking about the

00:12:58,529 --> 00:13:04,410
modern one I am NOT talking about the

00:13:00,779 --> 00:13:06,060
modern one so I'm the the stuff that

00:13:04,410 --> 00:13:08,820
I've been doing it plots out geometry

00:13:06,060 --> 00:13:10,529
with function calls which is kind of

00:13:08,820 --> 00:13:13,019
slow in Perl cuz function calling is

00:13:10,529 --> 00:13:15,510
kind of slow in Perl you maneuver

00:13:13,019 --> 00:13:17,959
through 3d space by changing your

00:13:15,510 --> 00:13:20,430
coordinate system so you actually

00:13:17,959 --> 00:13:22,560
instead of trying to plot out

00:13:20,430 --> 00:13:24,510
calculate what each of the vertices is

00:13:22,560 --> 00:13:26,370
on your polygon you can just move the

00:13:24,510 --> 00:13:28,080
whole coordinate system and then plot

00:13:26,370 --> 00:13:29,460
out some local vertices and then move

00:13:28,080 --> 00:13:31,170
the coordinate system and plot out some

00:13:29,460 --> 00:13:32,880
local vertices you can scale the

00:13:31,170 --> 00:13:38,100
coordinate system to you know stretch

00:13:32,880 --> 00:13:39,990
your model or shrink it and the the math

00:13:38,100 --> 00:13:42,450
that gets used to calculate the colors

00:13:39,990 --> 00:13:45,060
for individual pixels is all provided by

00:13:42,450 --> 00:13:46,470
OpenGL and you just kind of enable and

00:13:45,060 --> 00:13:49,200
disable some options like turn on

00:13:46,470 --> 00:13:51,600
lighting turn off lighting enable

00:13:49,200 --> 00:13:55,680
blending with the background stuff like

00:13:51,600 --> 00:13:58,470
that and so the modern GL instead of

00:13:55,680 --> 00:14:00,810
plotting the points you have to pack all

00:13:58,470 --> 00:14:03,630
of your you know vertexes you pack all

00:14:00,810 --> 00:14:05,970
of your geometry into buffers and then

00:14:03,630 --> 00:14:09,120
you instead of moving around your

00:14:05,970 --> 00:14:10,560
coordinate space you have to pack your

00:14:09,120 --> 00:14:13,740
coordinate spaces into buffers as well

00:14:10,560 --> 00:14:15,839
and then you get to describe your own

00:14:13,740 --> 00:14:16,830
pixel math with shaders so that's you

00:14:15,839 --> 00:14:19,020
know the thing the shader thing

00:14:16,830 --> 00:14:21,180
everybody's always talking about you're

00:14:19,020 --> 00:14:22,470
basically just writing custom math that

00:14:21,180 --> 00:14:25,230
will get shipped to the graphics card

00:14:22,470 --> 00:14:31,140
and executed in parallel for each pixel

00:14:25,230 --> 00:14:33,000
that applies so if you have cut if you

00:14:31,140 --> 00:14:35,970
have like graphic needs and you want to

00:14:33,000 --> 00:14:40,950
do lots of polygons or fancy lighting or

00:14:35,970 --> 00:14:42,390
shadows or moving meshes then you need

00:14:40,950 --> 00:14:45,510
to use the right tool for the job you

00:14:42,390 --> 00:14:47,700
absolutely need the modern api and so

00:14:45,510 --> 00:14:49,650
there's an example taken off of shader

00:14:47,700 --> 00:14:51,150
toy comm which has a million very

00:14:49,650 --> 00:14:53,370
awesome examples you can waste a lot of

00:14:51,150 --> 00:14:56,630
time browsing through there showing off

00:14:53,370 --> 00:15:03,120
some of the shader capabilities and

00:14:56,630 --> 00:15:05,279
there's another one so the disadvantages

00:15:03,120 --> 00:15:07,620
is that you have to plan your geometry

00:15:05,279 --> 00:15:09,750
ahead of time you have to plan the

00:15:07,620 --> 00:15:12,510
storage for your geometry ahead of time

00:15:09,750 --> 00:15:14,100
and you know ship those buffers over to

00:15:12,510 --> 00:15:16,200
the graphics card ahead of time or

00:15:14,100 --> 00:15:18,089
update the buffers and then ship

00:15:16,200 --> 00:15:19,920
modified portions of them over to the

00:15:18,089 --> 00:15:21,899
graphics card you have to learn in the

00:15:19,920 --> 00:15:24,089
shader process you have to learn the

00:15:21,899 --> 00:15:27,870
shader language and all of that takes a

00:15:24,089 --> 00:15:31,860
lot of time so there's no point doing it

00:15:27,870 --> 00:15:34,410
right if you never finish so classic

00:15:31,860 --> 00:15:36,779
works perfectly fine for things like

00:15:34,410 --> 00:15:39,660
de GLX gears demo program that comes

00:15:36,779 --> 00:15:42,569
with you know most OpenGL

00:15:39,660 --> 00:15:44,339
implementations this is a demo I wrote

00:15:42,569 --> 00:15:45,959
back in college for actually a class

00:15:44,339 --> 00:15:48,930
assignment and then I later converted it

00:15:45,959 --> 00:15:52,769
to bash in a funny story that's I'm not

00:15:48,930 --> 00:15:54,959
going to tell here but and then here's a

00:15:52,769 --> 00:16:01,680
little flight simulator this was also

00:15:54,959 --> 00:16:03,449
when I was attempting to it's attempting

00:16:01,680 --> 00:16:05,410
to create an entire video game in bash

00:16:03,449 --> 00:16:06,889
as kind of a joke

00:16:05,410 --> 00:16:10,740
[Music]

00:16:06,889 --> 00:16:12,870
and the DeLorean dashboard this is all

00:16:10,740 --> 00:16:14,670
done with the classic API because that's

00:16:12,870 --> 00:16:16,740
all I needed and all of that other stuff

00:16:14,670 --> 00:16:24,000
would have just you know impeded my

00:16:16,740 --> 00:16:26,730
progress and everything that you saw on

00:16:24,000 --> 00:16:30,509
the original PlayStation can pretty much

00:16:26,730 --> 00:16:32,040
be done with OpenGL one so you know the

00:16:30,509 --> 00:16:34,350
entire game of Final Fantasy it doesn't

00:16:32,040 --> 00:16:37,139
look that great by modern standards but

00:16:34,350 --> 00:16:39,149
everybody liked it back then so if if

00:16:37,139 --> 00:16:40,709
you've got a game idea that you've been

00:16:39,149 --> 00:16:45,829
you know cooking in the back of your

00:16:40,709 --> 00:16:45,829
head and never got around to doing it oh

00:16:47,000 --> 00:16:52,970
yeah you know the classic API might

00:16:50,130 --> 00:16:55,319
still work for you and the classic API

00:16:52,970 --> 00:16:57,240
concepts also come back in other

00:16:55,319 --> 00:16:58,470
software so while people might be saying

00:16:57,240 --> 00:17:00,420
oh well that's you know old stuff

00:16:58,470 --> 00:17:03,630
nobody's ever gonna use OpenGL one again

00:17:00,420 --> 00:17:08,640
well html5 canvases used the same

00:17:03,630 --> 00:17:11,610
concepts so if this is a little piece of

00:17:08,640 --> 00:17:13,949
a project I did for a client actually

00:17:11,610 --> 00:17:15,959
where we need to just display a sequence

00:17:13,949 --> 00:17:18,659
of stars and they wanted it as an

00:17:15,959 --> 00:17:21,240
embeddable graphic and so rather than

00:17:18,659 --> 00:17:22,949
trying to like get out Gd or one of

00:17:21,240 --> 00:17:25,770
those other packages that pro offers for

00:17:22,949 --> 00:17:29,760
rendering custom graphics I was like hey

00:17:25,770 --> 00:17:32,100
I can just SVG files are XML based or

00:17:29,760 --> 00:17:34,350
you know HTML fragments basically so you

00:17:32,100 --> 00:17:38,130
can write an SVG file with template

00:17:34,350 --> 00:17:40,980
toolkit and so this is an example where

00:17:38,130 --> 00:17:43,440
you see on where it's defining the

00:17:40,980 --> 00:17:46,080
polygon here and I can't actually

00:17:43,440 --> 00:17:47,429
highlight that there right you can

00:17:46,080 --> 00:17:48,450
specify a transform that is a

00:17:47,429 --> 00:17:50,369
translation

00:17:48,450 --> 00:17:52,379
of the coordinate system and a scale of

00:17:50,369 --> 00:17:54,029
the coordinate system and then feed it a

00:17:52,379 --> 00:17:56,129
series of points which in this case

00:17:54,029 --> 00:17:58,679
describe a star and it's kind of a long

00:17:56,129 --> 00:18:00,840
series of points goes off the screen and

00:17:58,679 --> 00:18:02,580
then right below that there's an example

00:18:00,840 --> 00:18:04,350
if where I translate to a you know

00:18:02,580 --> 00:18:06,749
specific coordinate and then scaled of a

00:18:04,350 --> 00:18:10,799
certain size and then render those texts

00:18:06,749 --> 00:18:13,710
124 reviews and so you can you can just

00:18:10,799 --> 00:18:16,019
put together graphics using these same

00:18:13,710 --> 00:18:18,690
concepts of moving the coordinate system

00:18:16,019 --> 00:18:20,460
around and plotting points there's also

00:18:18,690 --> 00:18:22,619
a clipped rectangle on the top there

00:18:20,460 --> 00:18:24,149
that so you can cut off the list of

00:18:22,619 --> 00:18:25,769
stars to make it like three and a half

00:18:24,149 --> 00:18:30,600
stars you can actually just cut the

00:18:25,769 --> 00:18:32,549
graphics right there and then another

00:18:30,600 --> 00:18:35,100
place that it came up just you know not

00:18:32,549 --> 00:18:36,600
too long ago is if you know 3d printers

00:18:35,100 --> 00:18:39,179
are all the rage it's like hey let's get

00:18:36,600 --> 00:18:41,730
a 3d printer oh wait I don't know how to

00:18:39,179 --> 00:18:43,649
model things in 3d well except that I

00:18:41,730 --> 00:18:45,929
kind of did you know so as it happened

00:18:43,649 --> 00:18:47,460
you know I didn't have to you know I was

00:18:45,929 --> 00:18:49,109
like well you know so there's some free

00:18:47,460 --> 00:18:50,850
CAD software and it relies on all of

00:18:49,109 --> 00:18:52,980
these keyboard shortcuts that all of the

00:18:50,850 --> 00:18:54,720
CAD modeling people know by heart I

00:18:52,980 --> 00:18:56,970
don't know any of them I don't have time

00:18:54,720 --> 00:19:00,119
to learn all those 3d keyboard shortcuts

00:18:56,970 --> 00:19:02,190
and so I found this program called open

00:19:00,119 --> 00:19:04,830
s CAD and is basically like a

00:19:02,190 --> 00:19:07,169
programming language for defining 3d

00:19:04,830 --> 00:19:10,379
geometry and it works on all the same

00:19:07,169 --> 00:19:12,840
concepts so there's an example of a

00:19:10,379 --> 00:19:15,330
little piece of a model I wrote it's say

00:19:12,840 --> 00:19:18,779
actually modeling a refrigerator for a

00:19:15,330 --> 00:19:22,289
miniature kind of like dollhouse for an

00:19:18,779 --> 00:19:26,190
intro type thing and so I'm you know I'm

00:19:22,289 --> 00:19:28,440
saying I know on line three there I'm

00:19:26,190 --> 00:19:30,239
saying translate to this coordinate and

00:19:28,440 --> 00:19:32,429
then draw a cube with these dimensions

00:19:30,239 --> 00:19:33,779
and then translate to the other

00:19:32,429 --> 00:19:35,549
coordinates and draw a cylinder with

00:19:33,779 --> 00:19:38,879
those dimensions and then take the

00:19:35,549 --> 00:19:41,489
intersection of those two shapes so any

00:19:38,879 --> 00:19:43,409
any 3d space that is contained by both

00:19:41,489 --> 00:19:46,440
of those will become part of the

00:19:43,409 --> 00:19:48,720
resulting shape and then the line below

00:19:46,440 --> 00:19:50,639
that I start drawing out cutouts that I

00:19:48,720 --> 00:19:55,049
want to remove from the model and that's

00:19:50,639 --> 00:19:57,239
why the the outermost command there is a

00:19:55,049 --> 00:19:59,970
difference so I'm taking one 3d shape

00:19:57,239 --> 00:20:02,140
and subtracting other 3d shapes out of

00:19:59,970 --> 00:20:05,590
it and so you can go through and define

00:20:02,140 --> 00:20:07,840
you know complex geometry and so on the

00:20:05,590 --> 00:20:09,850
left is what it looks like in the

00:20:07,840 --> 00:20:13,020
modeling program and on the right is

00:20:09,850 --> 00:20:13,020
what it looks like after you print it

00:20:14,520 --> 00:20:18,910
anyway but it's still a deprecated API

00:20:16,990 --> 00:20:20,200
so take that into consideration with

00:20:18,910 --> 00:20:22,360
everything that I'm showing you here is

00:20:20,200 --> 00:20:24,910
it's not the thing that you would use to

00:20:22,360 --> 00:20:26,080
write a 3d video game unless the reason

00:20:24,910 --> 00:20:28,270
you never got your video game written

00:20:26,080 --> 00:20:34,180
was because you know it was too much

00:20:28,270 --> 00:20:36,730
learning curve all right so a triangle

00:20:34,180 --> 00:20:38,110
example this is like the simplest thing

00:20:36,730 --> 00:20:41,350
you can draw with opengl is like a

00:20:38,110 --> 00:20:44,410
single triangle so what you do is you

00:20:41,350 --> 00:20:45,880
use the opengl module in Perl and then

00:20:44,410 --> 00:20:47,140
you create the window with a bunch of

00:20:45,880 --> 00:20:49,000
code that I don't want to show you yet

00:20:47,140 --> 00:20:50,740
and then you clear the buffer so you

00:20:49,000 --> 00:20:53,470
like wipe it clean so it's a black

00:20:50,740 --> 00:20:56,320
screen and then you say begin triangles

00:20:53,470 --> 00:20:58,690
and then every three vertex is that you

00:20:56,320 --> 00:21:00,100
give it it will draw a triangle and in

00:20:58,690 --> 00:21:01,650
this case I give it exactly three and it

00:21:00,100 --> 00:21:03,790
draw that's exactly one triangle and

00:21:01,650 --> 00:21:06,160
then you say end to mean that you're

00:21:03,790 --> 00:21:07,780
done feeding it geometry and then you

00:21:06,160 --> 00:21:09,760
have to give it another command to tell

00:21:07,780 --> 00:21:11,290
it to take those because it's been doing

00:21:09,760 --> 00:21:12,550
all this on the back buffer or nobody

00:21:11,290 --> 00:21:14,380
can see it so you have to give it a

00:21:12,550 --> 00:21:16,180
command to say put that up on the screen

00:21:14,380 --> 00:21:17,800
now and then then it gives you a fresh

00:21:16,180 --> 00:21:21,040
back buffer that you can wipe and start

00:21:17,800 --> 00:21:23,740
drawing on too so there's the rest of

00:21:21,040 --> 00:21:28,390
that code when I packaged this stuff up

00:21:23,740 --> 00:21:32,050
into the x11 GLX module with another

00:21:28,390 --> 00:21:36,340
module names x11 GLX do what i mean so

00:21:32,050 --> 00:21:37,870
you say x11 GL XD WM new and then you

00:21:36,340 --> 00:21:40,120
tell it what kind of target you want in

00:21:37,870 --> 00:21:42,220
this case I made a small you know not

00:21:40,120 --> 00:21:44,230
fullscreen window and then you render

00:21:42,220 --> 00:21:47,350
Europe and GL and then you say GL x swap

00:21:44,230 --> 00:21:49,060
buffers and then your you should also

00:21:47,350 --> 00:21:50,770
you know go and collect any error

00:21:49,060 --> 00:21:52,840
messages that OpenGL might have

00:21:50,770 --> 00:21:54,820
generated for you the opengl functions

00:21:52,840 --> 00:21:56,620
are all asynchronous so when you run an

00:21:54,820 --> 00:21:58,630
OpenGL function that's defining a vertex

00:21:56,620 --> 00:22:01,390
it's really just kind of like calling

00:21:58,630 --> 00:22:02,800
pearls Peck function it's just taking

00:22:01,390 --> 00:22:04,330
the things that you gave it packing them

00:22:02,800 --> 00:22:06,280
into a buffer and sending that somewhere

00:22:04,330 --> 00:22:08,680
so you don't actually find out whether

00:22:06,280 --> 00:22:10,990
it did anything useful or failed or ran

00:22:08,680 --> 00:22:12,610
into problems until later on basically

00:22:10,990 --> 00:22:14,500
basically not until you swap buffers and

00:22:12,610 --> 00:22:15,760
then OpenGL will send you back a message

00:22:14,500 --> 00:22:17,230
saying hey some

00:22:15,760 --> 00:22:18,760
stuff didn't work earlier so you should

00:22:17,230 --> 00:22:22,800
check errors on each frame to find out

00:22:18,760 --> 00:22:25,840
if you've got bugs in your program so

00:22:22,800 --> 00:22:27,250
now to do an animation all you do is you

00:22:25,840 --> 00:22:30,910
basically run that in a really tight

00:22:27,250 --> 00:22:33,640
loop so in this case I expand it out the

00:22:30,910 --> 00:22:36,250
coordinates for the triangle to in be

00:22:33,640 --> 00:22:37,780
the cosine and sine of an angle so I'm

00:22:36,250 --> 00:22:40,450
just kind of picking a third you know

00:22:37,780 --> 00:22:43,000
three points on a circle and then I run

00:22:40,450 --> 00:22:45,700
the angle from 1 to 360 degrees

00:22:43,000 --> 00:22:47,260
and you draw the triangle swap buffers

00:22:45,700 --> 00:22:49,660
draw the triangle swap buffers draw the

00:22:47,260 --> 00:22:59,890
triangle swap buffers and it looks like

00:22:49,660 --> 00:23:01,900
this alright so that's the basics of you

00:22:59,890 --> 00:23:08,050
know how you make the old OpenGL API

00:23:01,900 --> 00:23:09,910
work now let's try to you know that this

00:23:08,050 --> 00:23:12,130
is kind of cumbersome and awkward and

00:23:09,910 --> 00:23:14,170
difficult one of the things you can do

00:23:12,130 --> 00:23:16,960
is instead of calculating new

00:23:14,170 --> 00:23:18,850
coordinates each time you can pick out

00:23:16,960 --> 00:23:20,440
like the three coordinates of your

00:23:18,850 --> 00:23:22,660
triangle and then rotate the coordinate

00:23:20,440 --> 00:23:24,670
space so you rotate the coordinate space

00:23:22,660 --> 00:23:25,900
plot the same triangle rotate the

00:23:24,670 --> 00:23:27,640
coordinate space plot the same triangle

00:23:25,900 --> 00:23:29,680
and that saves you a little bit of math

00:23:27,640 --> 00:23:31,210
and could theoretically push that math

00:23:29,680 --> 00:23:34,870
down into the graphics card where it's

00:23:31,210 --> 00:23:37,390
run by you know specialized hardware so

00:23:34,870 --> 00:23:39,970
here's an example where I clear the

00:23:37,390 --> 00:23:42,580
buffer and then I load load identity it

00:23:39,970 --> 00:23:45,490
means basically reset the reset the

00:23:42,580 --> 00:23:48,370
coordinate system and then I rotate the

00:23:45,490 --> 00:23:52,510
coordinate system by the angle given

00:23:48,370 --> 00:23:54,280
around the vector given by 0 0 1 which

00:23:52,510 --> 00:23:55,780
is the z axis which is the axis that

00:23:54,280 --> 00:23:58,270
points toward you so basically it means

00:23:55,780 --> 00:24:00,760
rotate it in the XY plane which your

00:23:58,270 --> 00:24:02,950
screen is looking at and then you draw

00:24:00,760 --> 00:24:05,140
the triangle and now that now that the

00:24:02,950 --> 00:24:06,790
coordinates are a constant you don't

00:24:05,140 --> 00:24:08,440
have to calculate those with sine and

00:24:06,790 --> 00:24:12,640
cosine each time they're just you know

00:24:08,440 --> 00:24:15,820
constants and then end and if if your

00:24:12,640 --> 00:24:17,170
model was big and complicated you know

00:24:15,820 --> 00:24:19,740
this saves a whole bunch of pearl

00:24:17,170 --> 00:24:19,740
calculations

00:24:26,860 --> 00:24:31,419
so the next thing we can do is we can

00:24:29,120 --> 00:24:33,649
waste some of that into a display list

00:24:31,419 --> 00:24:35,029
OpenGL has this concept you know because

00:24:33,649 --> 00:24:37,700
it would be really really slow if you

00:24:35,029 --> 00:24:42,139
had to feed every vertex over the you

00:24:37,700 --> 00:24:43,940
know the mm AGP you know over the the

00:24:42,139 --> 00:24:47,840
system busses over to the graphics card

00:24:43,940 --> 00:24:50,539
for every single frame so even the old

00:24:47,840 --> 00:24:51,860
OpenGL API was smart enough to know that

00:24:50,539 --> 00:24:53,809
that would be a bad idea so they came up

00:24:51,860 --> 00:24:55,460
with a thing called display lists' when

00:24:53,809 --> 00:24:58,789
the idea is that you begin recording a

00:24:55,460 --> 00:25:01,070
display list mark out your geometry and

00:24:58,789 --> 00:25:02,929
then end the display list and from then

00:25:01,070 --> 00:25:04,909
on you can you have you have like a

00:25:02,929 --> 00:25:06,919
single integer and you can say replay

00:25:04,909 --> 00:25:10,009
this integer and it'll do all of those

00:25:06,919 --> 00:25:11,570
coordinates for you over again so I've

00:25:10,009 --> 00:25:14,240
taken the example here and split it out

00:25:11,570 --> 00:25:16,820
to where we generate the geometry first

00:25:14,240 --> 00:25:19,610
and then the main loop is just seeing

00:25:16,820 --> 00:25:25,129
clear reset the matrix rotate the matrix

00:25:19,610 --> 00:25:26,750
and then replay the list so this still

00:25:25,129 --> 00:25:28,789
isn't very friendly I mean you know it's

00:25:26,750 --> 00:25:32,570
better but you know we've got Perl here

00:25:28,789 --> 00:25:35,090
we can do better so let's Profi it so

00:25:32,570 --> 00:25:36,649
one of the first things I did is the

00:25:35,090 --> 00:25:39,409
display list is an allocated resource

00:25:36,649 --> 00:25:44,029
and recording the display lists it has a

00:25:39,409 --> 00:25:47,500
begin and an end action so you can wrap

00:25:44,029 --> 00:25:51,200
that up in a specialized function and

00:25:47,500 --> 00:25:53,120
yeah that's just a down and then GL

00:25:51,200 --> 00:25:54,409
began in GL end you know we're we're

00:25:53,120 --> 00:25:56,750
telling it that we're starting triangles

00:25:54,409 --> 00:25:57,950
and we're done always need to be a

00:25:56,750 --> 00:25:59,419
matched pair if you had like an

00:25:57,950 --> 00:26:01,100
exception in the middle of that it would

00:25:59,419 --> 00:26:03,470
be bad if they became you know your

00:26:01,100 --> 00:26:05,570
graphics would be all messed up so then

00:26:03,470 --> 00:26:10,190
and there's also a lot of awkward names

00:26:05,570 --> 00:26:11,629
and constants OpenGL was a C API and so

00:26:10,190 --> 00:26:14,000
they had to have everything you know

00:26:11,629 --> 00:26:16,159
stand at alone outside of a namespace

00:26:14,000 --> 00:26:18,559
and not conflict so everything starts

00:26:16,159 --> 00:26:20,299
with the letters GL and then they had to

00:26:18,559 --> 00:26:21,529
tell what kind of parameters you're

00:26:20,299 --> 00:26:22,759
feeding it whether you're using floats

00:26:21,529 --> 00:26:26,259
or doubles and so they ended up with

00:26:22,759 --> 00:26:28,789
those ugly suffixes on everything so

00:26:26,259 --> 00:26:29,659
here here's the part where we're

00:26:28,789 --> 00:26:33,740
recording the list

00:26:29,659 --> 00:26:35,450
so let's prole if I that by making a

00:26:33,740 --> 00:26:39,019
function named compiled list

00:26:35,450 --> 00:26:42,889
that takes a code ref and returns an

00:26:39,019 --> 00:26:45,980
object and so the object will allocate

00:26:42,889 --> 00:26:48,139
that OpenGL ID and then when you call

00:26:45,980 --> 00:26:51,200
the call method on the object it'll

00:26:48,139 --> 00:26:54,860
execute it all right and then let's do

00:26:51,200 --> 00:26:57,620
the begin and end so I made a function

00:26:54,860 --> 00:27:00,529
named triangles and it also takes a code

00:26:57,620 --> 00:27:02,330
graph and it calls GL begin triangles

00:27:00,529 --> 00:27:05,840
and then runs the code ref and then

00:27:02,330 --> 00:27:08,450
close GL end and then we can clean up

00:27:05,840 --> 00:27:10,279
those vertex commands by making a

00:27:08,450 --> 00:27:12,230
function named vertex that takes however

00:27:10,279 --> 00:27:13,970
arguments however many arguments you

00:27:12,230 --> 00:27:18,320
give it and substitute zero for the

00:27:13,970 --> 00:27:19,820
remainders all right and then so here's

00:27:18,320 --> 00:27:22,279
what the compile list function might

00:27:19,820 --> 00:27:25,159
look like you say you know list equals

00:27:22,279 --> 00:27:27,169
display list new and then this is a

00:27:25,159 --> 00:27:28,429
little confusing GL new list means begin

00:27:27,169 --> 00:27:31,130
recording it doesn't actually mean

00:27:28,429 --> 00:27:34,820
allocate but anyway so you say new list

00:27:31,130 --> 00:27:36,169
with the ID that you got from allocating

00:27:34,820 --> 00:27:38,179
an ID and then you tell it you want to

00:27:36,169 --> 00:27:41,000
compile and then you eval the code ref

00:27:38,179 --> 00:27:42,470
and then you end lists and then you die

00:27:41,000 --> 00:27:44,240
with you you know propagate the ipsa

00:27:42,470 --> 00:27:46,940
exception if anything happens in the

00:27:44,240 --> 00:27:49,220
middle of the curly braces and return

00:27:46,940 --> 00:27:54,529
the list when you're done and so here's

00:27:49,220 --> 00:27:59,720
what but it's still not very bright I

00:27:54,529 --> 00:28:02,840
guess well so anyway the triangles

00:27:59,720 --> 00:28:05,330
function would be a GL begin and then

00:28:02,840 --> 00:28:07,880
evaluate and then GL end and then throw

00:28:05,330 --> 00:28:09,860
the propagate the exception and then the

00:28:07,880 --> 00:28:12,500
vertex command would look like if you

00:28:09,860 --> 00:28:14,000
have four arguments called GL GL vertex

00:28:12,500 --> 00:28:15,470
for D if you have three arguments called

00:28:14,000 --> 00:28:17,330
GL vertex three D if you have two

00:28:15,470 --> 00:28:23,659
arguments called GL vertex 2d and else

00:28:17,330 --> 00:28:25,039
croak so now you go back to the second

00:28:23,659 --> 00:28:27,470
half where you're animating it and you

00:28:25,039 --> 00:28:29,809
have the angle from 0 to 3 from 1 to 360

00:28:27,470 --> 00:28:31,549
and you're clearing the buffer loading

00:28:29,809 --> 00:28:33,409
the identity matrix

00:28:31,549 --> 00:28:35,630
you know resetting the coordinate system

00:28:33,409 --> 00:28:39,919
I mean rotating it and then calling the

00:28:35,630 --> 00:28:42,950
list well we can clean this up so so one

00:28:39,919 --> 00:28:46,309
instead of resetting the matrix on every

00:28:42,950 --> 00:28:48,770
iteration you can save off a temporary

00:28:46,309 --> 00:28:52,820
copy and then restore it later

00:28:48,770 --> 00:28:55,070
oh oh so the first thing I did was

00:28:52,820 --> 00:28:57,860
clearing the buffer and swapping buffers

00:28:55,070 --> 00:28:59,900
I wrapped those into little convenience

00:28:57,860 --> 00:29:01,580
functions in my GLX module it also

00:28:59,900 --> 00:29:05,830
checks for errors and reports them in a

00:29:01,580 --> 00:29:05,830
human readable way rather than integers

00:29:05,980 --> 00:29:10,220
so now the part where you're loading the

00:29:08,660 --> 00:29:12,260
identity and rotating you can replace

00:29:10,220 --> 00:29:16,070
that with the function I wrote called

00:29:12,260 --> 00:29:17,660
local matrix so it basically saves off

00:29:16,070 --> 00:29:19,460
the state of the coordinate system then

00:29:17,660 --> 00:29:23,140
rotates it then renders your geometry

00:29:19,460 --> 00:29:23,140
and then resets it to what it was before

00:29:23,800 --> 00:29:29,480
so here's what Oh and and there was one

00:29:26,990 --> 00:29:31,670
other change there I said rotate Z by

00:29:29,480 --> 00:29:33,860
the angle instead of rotate angle around

00:29:31,670 --> 00:29:36,740
a specific vector because I thought this

00:29:33,860 --> 00:29:38,060
was more convenient so here's what the

00:29:36,740 --> 00:29:39,860
rotate function would look like if you

00:29:38,060 --> 00:29:42,920
give it four arguments it calls GL

00:29:39,860 --> 00:29:45,440
rotate the normal way if the else if the

00:29:42,920 --> 00:29:47,630
first argument is X then we rotate by

00:29:45,440 --> 00:29:49,820
the second argument around the x axis

00:29:47,630 --> 00:29:51,530
and if it's Y then we rotate the second

00:29:49,820 --> 00:29:53,420
argument around the y axis and else the

00:29:51,530 --> 00:29:54,620
z axes and else we croak that the

00:29:53,420 --> 00:29:58,070
arguments didn't make any sense

00:29:54,620 --> 00:30:00,410
and then the local matrix function calls

00:29:58,070 --> 00:30:04,460
GL push matrix it evaluates the code ref

00:30:00,410 --> 00:30:08,050
GL pop matrix and propagate the error so

00:30:04,460 --> 00:30:10,820
now what you have this this is this is

00:30:08,050 --> 00:30:12,830
basically the API that I wanted for

00:30:10,820 --> 00:30:14,540
working on the dashboard software you

00:30:12,830 --> 00:30:17,000
know everything is kind of simple and

00:30:14,540 --> 00:30:18,980
Perla fide and it takes care of errors

00:30:17,000 --> 00:30:21,350
and you know make sure that begins and

00:30:18,980 --> 00:30:23,990
ends match and the pushes and pops match

00:30:21,350 --> 00:30:25,790
and things like that and so I wrote

00:30:23,990 --> 00:30:27,500
rewrote a whole bunch of the dashboard

00:30:25,790 --> 00:30:34,750
software using a bunch of these

00:30:27,500 --> 00:30:37,040
convenient you know sugar methods and I

00:30:34,750 --> 00:30:38,570
could have put this at a better spot in

00:30:37,040 --> 00:30:40,870
the slides I guess oh well anyway so

00:30:38,570 --> 00:30:43,790
here's an example of rendering the

00:30:40,870 --> 00:30:45,260
speedometer tick marks so I'm

00:30:43,790 --> 00:30:49,550
specifically talking about those green

00:30:45,260 --> 00:30:51,500
mug marks in the arc and so the code

00:30:49,550 --> 00:30:54,410
that I wrote to draw those looks like

00:30:51,500 --> 00:30:55,970
this I started out with local matrix

00:30:54,410 --> 00:30:57,140
because I'm going to be changing around

00:30:55,970 --> 00:30:59,930
the coordinate system and I don't want

00:30:57,140 --> 00:31:02,750
those effects to stay and then I load

00:30:59,930 --> 00:31:06,919
some local attributes on this is my

00:31:02,750 --> 00:31:11,450
my speedometer object and then I start

00:31:06,919 --> 00:31:14,120
incrementing by the gauge tick interval

00:31:11,450 --> 00:31:15,590
and so then I'm I am doing my own sine

00:31:14,120 --> 00:31:16,940
and cosine here I didn't need to do that

00:31:15,590 --> 00:31:19,850
I could have just rotated the coordinate

00:31:16,940 --> 00:31:21,380
system which is actually what my demo

00:31:19,850 --> 00:31:23,960
here into a second is going to do and

00:31:21,380 --> 00:31:26,960
then I ran if it's an even number if

00:31:23,960 --> 00:31:31,340
it's an odd number tick mark then I also

00:31:26,960 --> 00:31:35,419
display the current value as a you know

00:31:31,340 --> 00:31:38,570
text string and then I do another local

00:31:35,419 --> 00:31:41,000
matrix then I rotate the coordinate

00:31:38,570 --> 00:31:43,010
system to where the tick mark is angled

00:31:41,000 --> 00:31:46,880
you know away from the speedometer

00:31:43,010 --> 00:31:48,860
needle and then I render a small polygon

00:31:46,880 --> 00:31:50,000
because that's actually the one way that

00:31:48,860 --> 00:31:51,500
you can get feathered edges really

00:31:50,000 --> 00:31:53,270
easily is you just use a polygon that

00:31:51,500 --> 00:31:58,100
has feathered edges and then you render

00:31:53,270 --> 00:32:04,000
it as a square on the screen so I'm

00:31:58,100 --> 00:32:04,000
rendering the rect 16x16 32 as a

00:32:04,600 --> 00:32:09,350
centered on the current origin of the

00:32:07,460 --> 00:32:12,320
coordinate system with given width and a

00:32:09,350 --> 00:32:15,590
given height so I finished doing all

00:32:12,320 --> 00:32:18,370
this you know rewriting and yeah there

00:32:15,590 --> 00:32:20,030
it goes so there's an example of

00:32:18,370 --> 00:32:21,559
rotating the coordinate system

00:32:20,030 --> 00:32:23,360
translating the coordinate system

00:32:21,559 --> 00:32:24,799
plotting four points rotating the

00:32:23,360 --> 00:32:26,870
coordinate system translating coordinate

00:32:24,799 --> 00:32:28,370
system plotting four points and that's

00:32:26,870 --> 00:32:31,190
the pop matrix that takes you back to

00:32:28,370 --> 00:32:33,590
your origin and then so you pop matrix

00:32:31,190 --> 00:32:35,539
push matrix rotate translate plat for

00:32:33,590 --> 00:32:39,650
points and so this is how you draw

00:32:35,539 --> 00:32:40,730
graphics with the old OpenGL API or you

00:32:39,650 --> 00:32:42,740
know one of the several ways that you

00:32:40,730 --> 00:32:44,600
can do it this is the easy way the way

00:32:42,740 --> 00:32:46,520
that you can quickly sit down and just

00:32:44,600 --> 00:32:49,360
slap stuff together like this that I

00:32:46,520 --> 00:32:49,360
wrote in one hour

00:32:50,860 --> 00:32:59,299
so rapid prototyping for the win

00:32:54,850 --> 00:33:01,100
but wait the speed got worse when I when

00:32:59,299 --> 00:33:03,380
I had this written in C++ it was running

00:33:01,100 --> 00:33:05,600
pretty quick and then I converted it all

00:33:03,380 --> 00:33:08,480
using all of those sugar functions that

00:33:05,600 --> 00:33:11,299
I wrote and I actually noticed the you

00:33:08,480 --> 00:33:16,640
know the speed drop a bit so what about

00:33:11,299 --> 00:33:18,440
in line so here the one of my questions

00:33:16,640 --> 00:33:20,090
was you know I heard that there's like

00:33:18,440 --> 00:33:23,270
some overhead when you want to call in

00:33:20,090 --> 00:33:25,070
line you know what what you know and so

00:33:23,270 --> 00:33:26,540
I wanted to know how how big of a

00:33:25,070 --> 00:33:29,150
function does it have to be before it's

00:33:26,540 --> 00:33:30,950
worth putting it into in line so there

00:33:29,150 --> 00:33:35,390
you see an example where I have a

00:33:30,950 --> 00:33:36,920
function named foo underscore C takes

00:33:35,390 --> 00:33:39,140
one argument multiplies it by ten and

00:33:36,920 --> 00:33:41,060
returns it and then another function

00:33:39,140 --> 00:33:45,050
named bar C which takes no arguments and

00:33:41,060 --> 00:33:47,300
returns nothing and then I made the same

00:33:45,050 --> 00:33:50,080
thing in Perl I well I did it twice in

00:33:47,300 --> 00:33:52,340
there's two food the first foo in Perl

00:33:50,080 --> 00:33:54,380
shifts it into a local variable then

00:33:52,340 --> 00:33:55,820
multiplies by ten and returns it the

00:33:54,380 --> 00:33:57,470
second one is how you might write it if

00:33:55,820 --> 00:33:58,850
you're trying to be extremely minimal so

00:33:57,470 --> 00:34:01,270
instead of using the local variable you

00:33:58,850 --> 00:34:04,580
just grab dollar sign underscore

00:34:01,270 --> 00:34:06,050
dollar sign underscore zero multiply

00:34:04,580 --> 00:34:08,090
that by ten and assume that it gets

00:34:06,050 --> 00:34:11,870
returned and then the last one is a

00:34:08,090 --> 00:34:16,700
function named bar Perl that takes no

00:34:11,870 --> 00:34:18,800
parameters and returns nothing and so

00:34:16,700 --> 00:34:20,690
then I decided to benchmark them and see

00:34:18,800 --> 00:34:23,860
which one came out fastest so here we do

00:34:20,690 --> 00:34:26,030
40 million iterations of each of them

00:34:23,860 --> 00:34:27,830
because that's like even on my laptop

00:34:26,030 --> 00:34:29,600
you know it requires that men need to

00:34:27,830 --> 00:34:32,480
get a decent result and it turns out

00:34:29,600 --> 00:34:34,310
that C is faster in every case it is

00:34:32,480 --> 00:34:36,710
faster to give an argument to C and

00:34:34,310 --> 00:34:38,780
return an argument from C than it is to

00:34:36,710 --> 00:34:41,960
call a Perl sub that has no arguments

00:34:38,780 --> 00:34:44,149
and no return and that now this is a

00:34:41,960 --> 00:34:46,250
micro benchmark micro benchmarks are not

00:34:44,149 --> 00:34:48,290
always super accurate they they can get

00:34:46,250 --> 00:34:50,630
heavily optimized by the C compiler and

00:34:48,290 --> 00:34:53,659
do strange things but the takeaway I

00:34:50,630 --> 00:34:58,870
took from it was that there is really no

00:34:53,659 --> 00:34:58,870
function too small to push into inline C

00:34:58,990 --> 00:35:04,760
you will always come out ahead if you

00:35:01,700 --> 00:35:06,350
move it into inline C so that was kind

00:35:04,760 --> 00:35:07,760
of encouraging and so I went in and I

00:35:06,350 --> 00:35:11,600
started rewriting all of my little sugar

00:35:07,760 --> 00:35:13,460
functions in inline C and so here's

00:35:11,600 --> 00:35:14,720
here's the vertex function where it says

00:35:13,460 --> 00:35:16,550
you know do we have four arguments three

00:35:14,720 --> 00:35:18,560
arguments two arguments or whatever and

00:35:16,550 --> 00:35:20,840
here's what it looks like in inline see

00:35:18,560 --> 00:35:23,120
if you go read but at the end the man

00:35:20,840 --> 00:35:24,530
page or not well you know you can read

00:35:23,120 --> 00:35:26,840
it as a man page if you go read the

00:35:24,530 --> 00:35:28,790
documentation for inline colon colon C

00:35:26,840 --> 00:35:30,410
it'll tell you about these macros called

00:35:28,790 --> 00:35:34,400
inline stack var

00:35:30,410 --> 00:35:39,230
in line stack items in line stack item

00:35:34,400 --> 00:35:40,700
and in line stack void and these in

00:35:39,230 --> 00:35:42,290
particular you'll notice that in the

00:35:40,700 --> 00:35:45,560
Declaration of that see function I have

00:35:42,290 --> 00:35:47,840
a dot dot dot if this was actually see

00:35:45,560 --> 00:35:49,670
the C compiler would expect to have like

00:35:47,840 --> 00:35:50,990
other arguments written on to the stack

00:35:49,670 --> 00:35:52,280
and it would do awkward things and

00:35:50,990 --> 00:35:57,710
possibly crash if you get the argument

00:35:52,280 --> 00:35:59,720
on in Perl in line C the dot dot dot is

00:35:57,710 --> 00:36:01,970
actually removed by the inline C module

00:35:59,720 --> 00:36:03,650
and you're telling the inline C module

00:36:01,970 --> 00:36:07,100
that you want to use pearls argument

00:36:03,650 --> 00:36:08,870
stack so in this case I have that dot

00:36:07,100 --> 00:36:10,940
dot dot there and then I declare my

00:36:08,870 --> 00:36:12,740
inline stack bars and then I switch

00:36:10,940 --> 00:36:15,770
based on the number of inline stack

00:36:12,740 --> 00:36:20,630
items and if it's 4 then I run GL vertex

00:36:15,770 --> 00:36:21,590
for D with X Y X Y I declared up top

00:36:20,630 --> 00:36:23,150
just because they're never going to

00:36:21,590 --> 00:36:26,150
change but the other two arguments if

00:36:23,150 --> 00:36:29,540
you want to unpack additional things s V

00:36:26,150 --> 00:36:32,090
and V numerical value I don't know is

00:36:29,540 --> 00:36:36,700
how you take a scalar value and convert

00:36:32,090 --> 00:36:39,920
it to basically a double for CD use so

00:36:36,700 --> 00:36:41,750
there you go that's how I unpack the

00:36:39,920 --> 00:36:44,660
additional items might be on the Perl

00:36:41,750 --> 00:36:48,710
stack and pass them into a C function

00:36:44,660 --> 00:36:52,280
and interestingly croak exists in the C

00:36:48,710 --> 00:36:54,710
API and it does pretty much what you

00:36:52,280 --> 00:36:56,090
expect it to but the neat the other neat

00:36:54,710 --> 00:36:58,970
thing about having croak and the C API

00:36:56,090 --> 00:37:00,740
is that it's you know using if you've

00:36:58,970 --> 00:37:02,750
ever done C and wished that you had

00:37:00,740 --> 00:37:05,900
exceptions there's this thing called

00:37:02,750 --> 00:37:08,390
long jump and it's basically unusable

00:37:05,900 --> 00:37:10,210
without a framework to help you allocate

00:37:08,390 --> 00:37:12,980
your resources and free your resources

00:37:10,210 --> 00:37:15,950
and so I had never actually used long

00:37:12,980 --> 00:37:19,550
jump ever having even done a relatively

00:37:15,950 --> 00:37:20,900
large amount of C well in Perl pearl is

00:37:19,550 --> 00:37:23,690
that framework that helps you manage

00:37:20,900 --> 00:37:25,280
your resources in C that's what it does

00:37:23,690 --> 00:37:28,040
that that's like almost the entire point

00:37:25,280 --> 00:37:29,930
of the Perl internal API and so you can

00:37:28,040 --> 00:37:32,270
croak right out of the middle of a C

00:37:29,930 --> 00:37:33,590
function and Perl will take care of you

00:37:32,270 --> 00:37:35,750
know any cleanup as long as you've been

00:37:33,590 --> 00:37:39,920
allocating your resources on unit with

00:37:35,750 --> 00:37:41,510
the Perl API so that's kind of cool and

00:37:39,920 --> 00:37:43,130
then let's take a look at the rotate

00:37:41,510 --> 00:37:44,000
function so this is another one that has

00:37:43,130 --> 00:37:46,280
a variable number

00:37:44,000 --> 00:37:49,990
of arguments but this time the first

00:37:46,280 --> 00:37:54,530
argument could be a letter or a number

00:37:49,990 --> 00:37:56,390
so to see the inline C for this one you

00:37:54,530 --> 00:37:57,680
say if there's four arguments then you

00:37:56,390 --> 00:38:00,830
know do the same thing we just did for

00:37:57,680 --> 00:38:05,120
that vertex man else if there are two

00:38:00,830 --> 00:38:07,610
arguments and the fruit that's the word

00:38:05,120 --> 00:38:14,450
this is SVP okay flag that should say

00:38:07,610 --> 00:38:17,510
SVP okay art zero anyway the okay macros

00:38:14,450 --> 00:38:20,830
in the Perl API test whether a scaler is

00:38:17,510 --> 00:38:22,940
a kind of a thing or whether it's been

00:38:20,830 --> 00:38:24,380
certified to be a kind of a thing

00:38:22,940 --> 00:38:26,030
because you can always try and coerce it

00:38:24,380 --> 00:38:29,150
on the fly but anyway in this case P

00:38:26,030 --> 00:38:33,140
okay means can it is it known to be a

00:38:29,150 --> 00:38:36,220
valid pointer to a character string and

00:38:33,140 --> 00:38:38,480
Perl API is pretty messed up but anyway

00:38:36,220 --> 00:38:40,220
you can you can find examples of this

00:38:38,480 --> 00:38:42,590
stuff and you know it's it's not too

00:38:40,220 --> 00:38:43,970
hard to learn especially you can just

00:38:42,590 --> 00:38:47,480
pull examples right out of my inline

00:38:43,970 --> 00:38:49,970
mutt or my OpenGL sandbox module it's a

00:38:47,480 --> 00:38:51,470
good I think example of you know common

00:38:49,970 --> 00:38:55,790
recipes that you might want to use for

00:38:51,470 --> 00:39:02,120
inline C and so you know if that's true

00:38:55,790 --> 00:39:04,880
then it's okay it extracts the the the C

00:39:02,120 --> 00:39:07,040
style character string from the first

00:39:04,880 --> 00:39:08,780
argument and switches on the first

00:39:07,040 --> 00:39:11,600
character of that character string and

00:39:08,780 --> 00:39:13,940
if it's X if it's Y if it's Z and so on

00:39:11,600 --> 00:39:15,170
and this is going to be a whole lot more

00:39:13,940 --> 00:39:16,880
efficient than doing the same thing in

00:39:15,170 --> 00:39:20,240
Perl because in Perl it'll actually you

00:39:16,880 --> 00:39:21,590
know do a string length or a hump on the

00:39:20,240 --> 00:39:23,690
entire string and it'll have to go

00:39:21,590 --> 00:39:26,240
through multiple op codes and all that

00:39:23,690 --> 00:39:28,340
stuff where this C code is basically

00:39:26,240 --> 00:39:30,350
going to is probably going to run about

00:39:28,340 --> 00:39:32,750
as fast as calling a single function in

00:39:30,350 --> 00:39:34,130
Perl you know never mind the contents of

00:39:32,750 --> 00:39:35,360
that single function in probably you

00:39:34,130 --> 00:39:36,890
know this is it's just going to blast

00:39:35,360 --> 00:39:39,020
right through the C and get straight

00:39:36,890 --> 00:39:41,330
into the OpenGL call which could take

00:39:39,020 --> 00:39:46,010
you know it's it most of the run time

00:39:41,330 --> 00:39:48,920
probably so so now we now we have a hard

00:39:46,010 --> 00:39:50,480
one so we have a triangles which accepts

00:39:48,920 --> 00:39:53,060
a code ref and then it's going to call

00:39:50,480 --> 00:39:56,300
GL begin execute the code graph GL end

00:39:53,060 --> 00:39:57,870
and then throw an exception so let's see

00:39:56,300 --> 00:40:01,590
what this one looks like in inline

00:39:57,870 --> 00:40:05,790
see how about that the API use exactly

00:40:01,590 --> 00:40:09,020
the same so the the Perl API has a

00:40:05,790 --> 00:40:11,700
function called call underscore SV and

00:40:09,020 --> 00:40:13,470
SV is scalar value again I don't know if

00:40:11,700 --> 00:40:16,230
I clarified that so I declared the

00:40:13,470 --> 00:40:18,240
function to take a scalar value and then

00:40:16,230 --> 00:40:20,970
I passed that scalar value to call SV

00:40:18,240 --> 00:40:24,270
and it even has a flag that you can pass

00:40:20,970 --> 00:40:27,150
so I give it a rake on text and I gave

00:40:24,270 --> 00:40:29,430
it the flag G underscore eval which

00:40:27,150 --> 00:40:31,470
means that it's going to eval that code

00:40:29,430 --> 00:40:35,430
instead of letting exceptions fly out of

00:40:31,470 --> 00:40:38,730
it and so then the last line if SV true

00:40:35,430 --> 00:40:40,290
error SV croak it with null and that's

00:40:38,730 --> 00:40:42,660
kind of weird but basically that means

00:40:40,290 --> 00:40:49,470
we throw the error if one was already

00:40:42,660 --> 00:40:51,150
thrown I thought this would be funny if

00:40:49,470 --> 00:40:56,850
the Perl API had called it dollar sign

00:40:51,150 --> 00:40:59,730
at instead of error SV all right so then

00:40:56,850 --> 00:41:02,490
one of the big reasons why I wanted to

00:40:59,730 --> 00:41:04,560
use the old OpenGL API in the first

00:41:02,490 --> 00:41:06,330
place you know aside from just ease of

00:41:04,560 --> 00:41:09,810
use is that there's this cool font

00:41:06,330 --> 00:41:12,600
library called FT GL and this is this

00:41:09,810 --> 00:41:14,850
was written in like I don't know 2005 or

00:41:12,600 --> 00:41:18,120
something it's on SourceForge you can go

00:41:14,850 --> 00:41:20,220
look at its history but it takes true

00:41:18,120 --> 00:41:23,880
type fonts and renders them into

00:41:20,220 --> 00:41:25,680
textures or renders them as 3d geometry

00:41:23,880 --> 00:41:26,970
or renders them in a bunch of different

00:41:25,680 --> 00:41:28,980
ways you can choose like seven different

00:41:26,970 --> 00:41:30,300
ways to take a true type font and

00:41:28,980 --> 00:41:33,240
convert it into some kind of OpenGL

00:41:30,300 --> 00:41:36,600
resource and so I wanted to use this but

00:41:33,240 --> 00:41:39,480
it is it is pure opengl 1.0 you know no

00:41:36,600 --> 00:41:41,700
shader no fancy anything but it saves

00:41:39,480 --> 00:41:44,880
it's it's a it's one of the best written

00:41:41,700 --> 00:41:46,590
api's I have ever seen it is it has just

00:41:44,880 --> 00:41:50,610
done that well and so I didn't want to

00:41:46,590 --> 00:41:57,180
have to reinvent that and so in line CPP

00:41:50,610 --> 00:41:58,830
lets you wrap C++ classes now that the

00:41:57,180 --> 00:42:01,350
problem though is that I wasn't able to

00:41:58,830 --> 00:42:03,420
get in line CPP to go look at somebody

00:42:01,350 --> 00:42:05,700
else's header file they wanted to look

00:42:03,420 --> 00:42:08,550
at the specific code I gave it not

00:42:05,700 --> 00:42:10,740
somebody else's code so what I did

00:42:08,550 --> 00:42:14,040
instead of trying to like

00:42:10,740 --> 00:42:15,570
in the FT font you know header files and

00:42:14,040 --> 00:42:16,980
stuff and paste him into my code I

00:42:15,570 --> 00:42:20,240
decided to just write a wrapper around

00:42:16,980 --> 00:42:23,730
it so I wrote class FT font wrapper and

00:42:20,240 --> 00:42:26,580
it's internal storage is a single SV of

00:42:23,730 --> 00:42:28,800
the memory mapped font file and then an

00:42:26,580 --> 00:42:32,220
F key font which is from that F T GL

00:42:28,800 --> 00:42:36,720
library and so in the constructor I pass

00:42:32,220 --> 00:42:40,770
it the memory maps of font data and then

00:42:36,720 --> 00:42:44,010
a string telling it which C++ class to

00:42:40,770 --> 00:42:45,900
allocate I'm going to skip over that

00:42:44,010 --> 00:42:49,110
constructor and then the bottom half of

00:42:45,900 --> 00:42:52,980
the class you know the public portion is

00:42:49,110 --> 00:42:55,770
exposing various details of the FT GL

00:42:52,980 --> 00:42:59,040
font class so I gave them slightly more

00:42:55,770 --> 00:43:01,710
pearl ish names so ascender is the

00:42:59,040 --> 00:43:03,150
amount above the font you know the fonts

00:43:01,710 --> 00:43:05,670
have a baseline and then there's an

00:43:03,150 --> 00:43:07,140
ascender above the baseline which tells

00:43:05,670 --> 00:43:09,450
you the top of the font and a descender

00:43:07,140 --> 00:43:11,340
below the baseline which tells you the

00:43:09,450 --> 00:43:13,590
the glyph you know how far glyphs hang

00:43:11,340 --> 00:43:16,470
down and then a recommended line height

00:43:13,590 --> 00:43:18,859
for you know how to correctly space them

00:43:16,470 --> 00:43:21,690
to where they looks correct with the fun

00:43:18,859 --> 00:43:23,400
ft GL also lets you specify the face

00:43:21,690 --> 00:43:24,840
size so that you can control kind of the

00:43:23,400 --> 00:43:28,650
resolution that the font gets rendered

00:43:24,840 --> 00:43:30,440
at if you're using 3d extruded fonts it

00:43:28,650 --> 00:43:32,760
lets you set the depth than the outset

00:43:30,440 --> 00:43:33,900
and then it lets you decide whether or

00:43:32,760 --> 00:43:37,770
not you want to wrap everything with

00:43:33,900 --> 00:43:40,020
display lists' and so I exposed each of

00:43:37,770 --> 00:43:43,260
those attributes and then the real meat

00:43:40,020 --> 00:43:45,510
of the FT GL library is the advanced

00:43:43,260 --> 00:43:47,369
method which you give it a string of

00:43:45,510 --> 00:43:51,390
text and it tells you how many font

00:43:47,369 --> 00:43:53,310
units that wide that string is and so

00:43:51,390 --> 00:43:55,710
then you can use that math to you know

00:43:53,310 --> 00:43:57,720
wrap text or do intelligent things like

00:43:55,710 --> 00:44:00,330
centering or stuff and then there's a

00:43:57,720 --> 00:44:02,280
render method where you give it a string

00:44:00,330 --> 00:44:06,119
of text and it renders it at the current

00:44:02,280 --> 00:44:07,619
origin counting sideways well that's

00:44:06,119 --> 00:44:08,850
nice but I also wanted to make it a

00:44:07,619 --> 00:44:10,680
little more polish so you'll notice that

00:44:08,850 --> 00:44:13,109
I stuck a dot dot dot on the end of the

00:44:10,680 --> 00:44:18,060
renderer there and added some of my own

00:44:13,109 --> 00:44:21,180
features now on top of that though

00:44:18,060 --> 00:44:24,760
you'll if you try to wrap right things

00:44:21,180 --> 00:44:26,800
in C++ and wrapped them with inline CPP

00:44:24,760 --> 00:44:28,660
you'll find that there are certain

00:44:26,800 --> 00:44:30,160
things that get a lot harder like if you

00:44:28,660 --> 00:44:33,070
wanted to just store arbitrary

00:44:30,160 --> 00:44:34,810
attributes on your font object you have

00:44:33,070 --> 00:44:37,030
to keep going back to that you know see

00:44:34,810 --> 00:44:38,380
class and like adding additional getters

00:44:37,030 --> 00:44:40,330
and setters and that would be kind of

00:44:38,380 --> 00:44:43,780
annoying so I actually wrapped it with

00:44:40,330 --> 00:44:46,620
mu I've wrapped the wrapper with mu so

00:44:43,780 --> 00:44:48,640
you can specify you know normal mu

00:44:46,620 --> 00:44:51,610
attributes you can extend it like a mu

00:44:48,640 --> 00:44:54,220
object and then you see where ftg l

00:44:51,610 --> 00:44:56,140
underscore wrapper handles face size

00:44:54,220 --> 00:44:59,560
asunder descender line height in advance

00:44:56,140 --> 00:45:01,990
and so that that's a mu feature that

00:44:59,560 --> 00:45:04,780
lets you it's also a moose feature that

00:45:01,990 --> 00:45:06,610
lets you you know expose methods of a

00:45:04,780 --> 00:45:10,630
sub object as if they were methods of

00:45:06,610 --> 00:45:11,920
the parent object so that that tiny

00:45:10,630 --> 00:45:19,120
speed hit there but it you know I

00:45:11,920 --> 00:45:21,040
figured it was worth it and so this is

00:45:19,120 --> 00:45:23,500
the end API that I wanted I wanted to

00:45:21,040 --> 00:45:27,850
say font render hello world at

00:45:23,500 --> 00:45:29,770
coordinates x and y of 2 and x align its

00:45:27,850 --> 00:45:32,140
hat you know centered on the x

00:45:29,770 --> 00:45:33,580
coordinates and y align it with the y

00:45:32,140 --> 00:45:36,100
coordinate at the top of the text

00:45:33,580 --> 00:45:37,300
instead of the bottom and mono spaced it

00:45:36,100 --> 00:45:39,460
to where every character is the same

00:45:37,300 --> 00:45:42,130
width even if the original font wasn't

00:45:39,460 --> 00:45:47,440
set up that way scale it to 172 height

00:45:42,130 --> 00:45:50,320
and just actually you know stretch the

00:45:47,440 --> 00:45:54,310
thing to where it's exactly 4.7 opengl

00:45:50,320 --> 00:45:56,860
units wide and so I wrote a render

00:45:54,310 --> 00:45:58,660
method that does all of those you know

00:45:56,860 --> 00:46:03,610
all the math required for those and I

00:45:58,660 --> 00:46:06,790
was like that's a lot of math so let's

00:46:03,610 --> 00:46:10,120
push that into you know C++ as well and

00:46:06,790 --> 00:46:13,000
so here you have example that all kind

00:46:10,120 --> 00:46:14,650
of gloss over its checking the arguments

00:46:13,000 --> 00:46:16,300
just like the previous examples did and

00:46:14,650 --> 00:46:18,940
then it gets to the part where it's

00:46:16,300 --> 00:46:20,260
iterating a list so you know how most of

00:46:18,940 --> 00:46:22,960
the times you would Peck things into a

00:46:20,260 --> 00:46:24,250
hash and then pass the hash well that's

00:46:22,960 --> 00:46:26,170
slow because you have to allocate a hash

00:46:24,250 --> 00:46:27,670
and then do a bunch of calculations on

00:46:26,170 --> 00:46:28,930
the keys to load them into the hash so

00:46:27,670 --> 00:46:31,090
it's really just better if you just pass

00:46:28,930 --> 00:46:34,600
a series of key value parameters as a

00:46:31,090 --> 00:46:36,400
list to the function and so in this

00:46:34,600 --> 00:46:38,109
example you'll actually kind of

00:46:36,400 --> 00:46:40,180
recognize this if you've written C

00:46:38,109 --> 00:46:42,039
this is you know you're kind of like

00:46:40,180 --> 00:46:44,230
your options processing you just process

00:46:42,039 --> 00:46:46,259
the list of options but in this time in

00:46:44,230 --> 00:46:48,460
this case they're all keys and values so

00:46:46,259 --> 00:46:52,480
just below the for loop there you see

00:46:48,460 --> 00:46:54,489
where I say key equals s vp v no end of

00:46:52,480 --> 00:46:55,089
the current item and then value is the

00:46:54,489 --> 00:46:57,400
one after that

00:46:55,089 --> 00:47:00,309
sv okay is how you check if a thing is

00:46:57,400 --> 00:47:02,410
defined or not so if it's undef then i

00:47:00,309 --> 00:47:04,329
skip it and then i start switching based

00:47:02,410 --> 00:47:06,039
on the character and so i can pick up

00:47:04,329 --> 00:47:07,630
arguments like x and y and blah blah

00:47:06,039 --> 00:47:09,940
blah blah and if none of them are

00:47:07,630 --> 00:47:14,739
matched then i croak just like the

00:47:09,940 --> 00:47:16,420
previous examples so here's the thing in

00:47:14,739 --> 00:47:20,230
action this is out of one of my test

00:47:16,420 --> 00:47:24,390
cases for the opengl module or opengl

00:47:20,230 --> 00:47:24,390
sandbox module and it does this

00:47:29,610 --> 00:47:38,970
so side-effects of inline it compiles

00:47:36,600 --> 00:47:40,410
into a user ratable directory it'll

00:47:38,970 --> 00:47:41,970
either pick your home directory or the

00:47:40,410 --> 00:47:43,350
temp directory or somewhere but it'll

00:47:41,970 --> 00:47:48,690
it'll always pick a directory and

00:47:43,350 --> 00:47:50,400
compile things to there it compares the

00:47:48,690 --> 00:47:53,210
hash of your seat code on startup to see

00:47:50,400 --> 00:47:55,410
whether it actually needs to recompile

00:47:53,210 --> 00:47:57,030
but it also means that everywhere you

00:47:55,410 --> 00:47:59,700
use this module you're going to need to

00:47:57,030 --> 00:48:02,550
see compiler so what you probably want

00:47:59,700 --> 00:48:05,760
to do yeah well so comparing in line

00:48:02,550 --> 00:48:07,680
with XS both generate an Esso file XS

00:48:05,760 --> 00:48:12,330
requires a lot of awkward tooling in

00:48:07,680 --> 00:48:13,560
line requires a startup check so XS is

00:48:12,330 --> 00:48:16,020
kind of better for your installed

00:48:13,560 --> 00:48:18,390
packages and but the in line overhead

00:48:16,020 --> 00:48:19,560
isn't too bad and in line has you know

00:48:18,390 --> 00:48:23,280
the obvious benefits when you're

00:48:19,560 --> 00:48:25,310
prototyping packaging in line for Sipan

00:48:23,280 --> 00:48:27,570
you should check out in line make maker

00:48:25,310 --> 00:48:29,010
it tells you the details there but if

00:48:27,570 --> 00:48:31,710
you're using just Zilla that would

00:48:29,010 --> 00:48:33,900
gotten Rock awkward there's no plugin

00:48:31,710 --> 00:48:38,990
yet but I came up with a workaround and

00:48:33,900 --> 00:48:41,250
it's in the OpenGL sandbox a code

00:48:38,990 --> 00:48:43,400
there's there's the workaround I came up

00:48:41,250 --> 00:48:46,890
with I'll let you read it and get

00:48:43,400 --> 00:48:48,810
there's the ini with the details that

00:48:46,890 --> 00:48:50,400
are needed to make that thing work part

00:48:48,810 --> 00:48:52,650
of it is that you don't want to have a

00:48:50,400 --> 00:48:54,420
version on your module when you're

00:48:52,650 --> 00:48:56,760
prototyping but you do want to have a

00:48:54,420 --> 00:48:59,160
version when you ship it to Sipan and by

00:48:56,760 --> 00:49:00,960
having that version there the inline

00:48:59,160 --> 00:49:03,000
make maker will figure out that it wants

00:49:00,960 --> 00:49:05,300
to compile the Esso into the system

00:49:03,000 --> 00:49:07,110
directory rather than into your local

00:49:05,300 --> 00:49:11,610
directory there's more to it than that

00:49:07,110 --> 00:49:14,880
but anyway so there there's the inline

00:49:11,610 --> 00:49:16,230
statement that that I'm actually using

00:49:14,880 --> 00:49:18,900
in one of my modules is kind of

00:49:16,230 --> 00:49:21,000
complicated but I take you know

00:49:18,900 --> 00:49:23,760
underscore underscore capital file is

00:49:21,000 --> 00:49:25,140
the name of your Perl the current file

00:49:23,760 --> 00:49:27,510
being processed by the Perl interpreter

00:49:25,140 --> 00:49:29,400
and so I run that through array X to

00:49:27,510 --> 00:49:33,900
swap the extension C with the extraction

00:49:29,400 --> 00:49:35,490
or swap pm4 dot C so I can have a dot C

00:49:33,900 --> 00:49:38,280
file in the same directory as my dot

00:49:35,490 --> 00:49:39,540
p.m. file and inline just goes and pulls

00:49:38,280 --> 00:49:40,440
up that file which is really nice

00:49:39,540 --> 00:49:42,630
because then I get the syntax

00:49:40,440 --> 00:49:43,260
highlighting and then I declare the

00:49:42,630 --> 00:49:45,150
version if

00:49:43,260 --> 00:49:47,970
it's being installed as a you know

00:49:45,150 --> 00:49:49,920
official module then and there's the

00:49:47,970 --> 00:49:51,930
ugly stuff that a you know 4c where you

00:49:49,920 --> 00:49:53,850
have to specify include paths for the C

00:49:51,930 --> 00:49:55,620
compiler and which libs to link and

00:49:53,850 --> 00:49:58,440
stuff like that well that probably needs

00:49:55,620 --> 00:49:59,640
enhanced in order to work on people's

00:49:58,440 --> 00:50:03,600
systems other than my own

00:49:59,640 --> 00:50:05,490
so patches welcome so these are the

00:50:03,600 --> 00:50:07,200
modules I have kind of produced as a

00:50:05,490 --> 00:50:10,140
result of the DeLorean car project

00:50:07,200 --> 00:50:11,970
there's I took over maintainer ship of X

00:50:10,140 --> 00:50:14,820
Lib added a whole bunch of stuff there

00:50:11,970 --> 00:50:16,710
the wrote the GL x module and then I my

00:50:14,820 --> 00:50:19,800
st. opengl sandbox module is divided

00:50:16,710 --> 00:50:21,180
into three pieces one is the the stuff

00:50:19,800 --> 00:50:23,910
that doesn't depend on any specific

00:50:21,180 --> 00:50:25,740
version of OpenGL v1 is everything that

00:50:23,910 --> 00:50:29,070
depends on the old you know deprecated

00:50:25,740 --> 00:50:30,780
version of API and v1f tgl font is

00:50:29,070 --> 00:50:32,700
everything that you know basically the

00:50:30,780 --> 00:50:34,080
wrapper around the font and that way you

00:50:32,700 --> 00:50:35,550
should be able to make use of most of

00:50:34,080 --> 00:50:39,600
this regardless of whether you want to

00:50:35,550 --> 00:50:40,920
install all of the dependencies related

00:50:39,600 --> 00:50:42,810
modules that you might look at are the

00:50:40,920 --> 00:50:44,940
OpenGL module if there's OpenGL modern

00:50:42,810 --> 00:50:46,500
which you know the author is suggesting

00:50:44,940 --> 00:50:48,300
that everybody switched to that one he's

00:50:46,500 --> 00:50:50,700
eventually going to have OpenGL modern

00:50:48,300 --> 00:50:53,280
be the implementation of the old OpenGL

00:50:50,700 --> 00:50:54,810
module but my stuff works with both of

00:50:53,280 --> 00:50:56,760
them in the meantime

00:50:54,810 --> 00:50:59,460
then there's the inline module which is

00:50:56,760 --> 00:51:02,040
separate from inline : c and inline :

00:50:59,460 --> 00:51:04,430
CPP so reading the documentation for

00:51:02,040 --> 00:51:08,210
each of those three modules is relevant

00:51:04,430 --> 00:51:11,570
yeah there we go

00:51:08,210 --> 00:51:11,570
any questions

00:51:14,589 --> 00:51:23,519
all right that's it

00:51:17,760 --> 00:51:23,519

YouTube URL: https://www.youtube.com/watch?v=FtaBVVm5IBc


