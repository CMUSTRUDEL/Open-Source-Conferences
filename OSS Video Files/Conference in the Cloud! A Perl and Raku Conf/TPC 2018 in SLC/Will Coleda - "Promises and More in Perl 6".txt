Title: Will Coleda - "Promises and More in Perl 6"
Publication date: 2018-06-20
Playlist: TPC 2018 in SLC
Description: 
	An introduction to the asynchronous and parallel programming support available in Perl 6. These tools are helpful whether you’re writing large applications or small scripts for system administration tasks.

We’ll cover the basic language components, how to combine them, and end with an exploration of the CPAN modules that build on these foundations.
Captions: 
	00:00:00,000 --> 00:00:08,250
all right it's it's time yes all right

00:00:06,290 --> 00:00:13,889
all right we're gonna get started

00:00:08,250 --> 00:00:16,560
everybody so the title of this talk is

00:00:13,889 --> 00:00:17,970
promises and more in Perl 6 I really

00:00:16,560 --> 00:00:21,300
wanted to be able to call it the promise

00:00:17,970 --> 00:00:23,570
of Perl 6 but that was just too it was

00:00:21,300 --> 00:00:27,300
too over the top so I hope you'll

00:00:23,570 --> 00:00:28,949
forgive just a little bit about me my

00:00:27,300 --> 00:00:34,980
contact yes

00:00:28,949 --> 00:00:39,300
louder let me how's that all right thank

00:00:34,980 --> 00:00:41,280
you that sounds very loud to me so my

00:00:39,300 --> 00:00:45,690
background I've been working with a Perl

00:00:41,280 --> 00:00:50,039
6 project for almost as long as Bruce I

00:00:45,690 --> 00:00:53,039
think so over a decade I've worked on

00:00:50,039 --> 00:01:01,050
various compilers for other languages

00:00:53,039 --> 00:01:05,189
even back in the parrot day though this

00:01:01,050 --> 00:01:07,920
is not an auspicious start so I've also

00:01:05,189 --> 00:01:10,020
worked on documentation build system a

00:01:07,920 --> 00:01:14,360
bunch of other things including some

00:01:10,020 --> 00:01:16,860
actual ruku dough Perl 6 code itself

00:01:14,360 --> 00:01:18,689
which as Bruce pointed out the only

00:01:16,860 --> 00:01:20,280
reason I'd be able to do that is because

00:01:18,689 --> 00:01:22,860
the fact that Perl 6 is written in Perl

00:01:20,280 --> 00:01:25,770
6 it lets it lowers the bar enough that

00:01:22,860 --> 00:01:28,860
I can work on it which is a great

00:01:25,770 --> 00:01:30,329
feeling for me I'm also in the TPF

00:01:28,860 --> 00:01:34,259
community on the grants committee

00:01:30,329 --> 00:01:35,700
secretary and for my day job and I only

00:01:34,259 --> 00:01:37,259
put this down here because it seems

00:01:35,700 --> 00:01:38,820
weird to me and kind of in Congress the

00:01:37,259 --> 00:01:41,490
other things I'm a tax director of one

00:01:38,820 --> 00:01:46,320
of the big four accounting firms I'm an

00:01:41,490 --> 00:01:49,549
IT and apparently this work laptop does

00:01:46,320 --> 00:01:49,549
not want to stay open

00:01:57,280 --> 00:02:02,640
let's see

00:02:00,540 --> 00:02:04,110
well this will certainly help me bump

00:02:02,640 --> 00:02:05,010
this out to 50 minutes so I'm very

00:02:04,110 --> 00:02:14,100
excited about that

00:02:05,010 --> 00:02:26,820
oh I'm sure work has it down further

00:02:14,100 --> 00:02:28,470
than that the size has changed ah this

00:02:26,820 --> 00:02:35,340
is ridiculous okay

00:02:28,470 --> 00:02:40,410
one moment please all right we'll leave

00:02:35,340 --> 00:02:42,330
my notes aside so that's that no this is

00:02:40,410 --> 00:02:43,830
gonna be an introductory talk about some

00:02:42,330 --> 00:02:46,560
of the ways that Perl 6 can help you

00:02:43,830 --> 00:02:50,280
work a certain crystal a synchronously

00:02:46,560 --> 00:02:53,209
or concurrently as Bruce mentioned in

00:02:50,280 --> 00:02:56,730
the previous talk if you were here

00:02:53,209 --> 00:02:58,200
only recently much like him have I been

00:02:56,730 --> 00:03:00,209
able to separate what those differences

00:02:58,200 --> 00:03:01,380
are so this really is gonna be an intro

00:03:00,209 --> 00:03:06,239
level talk it's gonna be a little more

00:03:01,380 --> 00:03:08,880
detailed as far as promises and the

00:03:06,239 --> 00:03:12,180
other classes go but we're not gonna get

00:03:08,880 --> 00:03:13,170
into too much detail so one of the one

00:03:12,180 --> 00:03:15,989
of the first things I think that

00:03:13,170 --> 00:03:18,870
everybody expects to be threaded and to

00:03:15,989 --> 00:03:23,000
work asynchronously are junctions these

00:03:18,870 --> 00:03:25,140
were inspired by Damian's work in Perl 5

00:03:23,000 --> 00:03:25,739
and they actually the feature that they

00:03:25,140 --> 00:03:27,690
use is called

00:03:25,739 --> 00:03:29,910
Auto threading so when you reference a

00:03:27,690 --> 00:03:31,920
Junction like that checking to see if a

00:03:29,910 --> 00:03:35,190
variable has any of those three values

00:03:31,920 --> 00:03:37,680
you might expect that the compiler might

00:03:35,190 --> 00:03:40,050
maybe not further loose this short but

00:03:37,680 --> 00:03:45,360
might run that work in another thread

00:03:40,050 --> 00:03:46,440
and then lock your screen so but even

00:03:45,360 --> 00:03:49,800
though the feature is called Auto

00:03:46,440 --> 00:03:52,800
threading it's not really threaded it's

00:03:49,800 --> 00:03:56,459
the the compiler is free to do that but

00:03:52,800 --> 00:03:59,459
right now the compiler is just making a

00:03:56,459 --> 00:04:01,790
nice conditional statement so it's just

00:03:59,459 --> 00:04:01,790
a trick

00:04:04,710 --> 00:04:17,910
yep yeah that might be a thing also the

00:04:13,870 --> 00:04:20,430
touch ID is giving me trouble as well

00:04:17,910 --> 00:04:24,460
this would be a great time by the way

00:04:20,430 --> 00:04:29,230
for the laptop to die so let's let's

00:04:24,460 --> 00:04:30,700
hope that doesn't happen I'm sorry it's

00:04:29,230 --> 00:04:31,720
on Google Drive so yeah I could add code

00:04:30,700 --> 00:04:39,640
to absolutely do this from another

00:04:31,720 --> 00:04:41,170
another laptop honestly I wonder there

00:04:39,640 --> 00:04:42,880
was some water here I don't wanna throw

00:04:41,170 --> 00:04:49,900
it Bruce under the bus but I wonder if

00:04:42,880 --> 00:04:51,640
something might be shorting out all

00:04:49,900 --> 00:04:55,360
right we're gonna do a rear into a hard

00:04:51,640 --> 00:05:02,980
reboot okay so to keep talking while

00:04:55,360 --> 00:05:05,370
this is coming up let's see but we're

00:05:02,980 --> 00:05:05,370
almost there

00:05:12,150 --> 00:05:22,979
lovely sure right there there's right

00:05:18,510 --> 00:05:27,110
there yeah alright I do apologize

00:05:22,979 --> 00:05:27,110
everyone thank you

00:05:36,540 --> 00:05:43,960
so now you can guess which company I

00:05:38,650 --> 00:05:50,320
eventually for I have to they've got me

00:05:43,960 --> 00:05:56,590
already so I do wish I had a hard copy

00:05:50,320 --> 00:05:58,090
in front of me so to do this from memory

00:05:56,590 --> 00:06:00,310
the next the next thing I wanted to talk

00:05:58,090 --> 00:06:05,080
about were threads when you're dealing

00:06:00,310 --> 00:06:06,130
with running work concurrently in other

00:06:05,080 --> 00:06:09,310
language you might create your own

00:06:06,130 --> 00:06:11,350
thread manage its runtime set up some

00:06:09,310 --> 00:06:12,960
code to run on it and then wait for it

00:06:11,350 --> 00:06:15,190
to be done

00:06:12,960 --> 00:06:18,370
jonathan has referred to threads

00:06:15,190 --> 00:06:21,700
Jonathon Worthington as the assembly

00:06:18,370 --> 00:06:23,650
language of concurrency and that's too

00:06:21,700 --> 00:06:26,250
low-level for an intro talk so we're not

00:06:23,650 --> 00:06:33,610
actually going to cover threads at all I

00:06:26,250 --> 00:06:35,320
do want to I do want any laptop I do

00:06:33,610 --> 00:06:37,030
want to mention that threads in all of

00:06:35,320 --> 00:06:38,560
the other classes that I'm going to talk

00:06:37,030 --> 00:06:41,770
about here are if you go to the docs

00:06:38,560 --> 00:06:43,090
website Doc's dot Perl 6 org thank you I

00:06:41,770 --> 00:06:45,900
don't know why they have to ask me this

00:06:43,090 --> 00:06:50,070
twice every time it's very efficient I

00:06:45,900 --> 00:06:50,070
might actually have to click on this one

00:06:53,730 --> 00:06:58,000
well unfortunately they're there

00:06:56,710 --> 00:07:01,720
lockdown I think Bruce is the only one

00:06:58,000 --> 00:07:06,600
that has the URL right now oh it's all

00:07:01,720 --> 00:07:06,600
right we're we're back we got there

00:07:11,010 --> 00:07:19,030
intro Junction's threads so alright we

00:07:15,550 --> 00:07:20,620
caught up so instead of manually doing

00:07:19,030 --> 00:07:21,850
all the concurrency work ourselves and

00:07:20,620 --> 00:07:25,350
managing a lifetime of all this we're

00:07:21,850 --> 00:07:29,320
gonna let Perl 6 do the hard work for us

00:07:25,350 --> 00:07:30,730
and one of the things that I'm gonna do

00:07:29,320 --> 00:07:33,340
in the talk there's there's some syntax

00:07:30,730 --> 00:07:34,600
in here which is just gratuitous and

00:07:33,340 --> 00:07:36,820
part of that is to get you excited about

00:07:34,600 --> 00:07:40,390
Perl 6 so there's some stuff in here

00:07:36,820 --> 00:07:42,160
that is not strictly necessary for

00:07:40,390 --> 00:07:45,100
dealing with concurrency but it's in

00:07:42,160 --> 00:07:50,860
here and we'll go through it so this

00:07:45,100 --> 00:07:52,330
first section of code up here this is

00:07:50,860 --> 00:07:55,270
going to take all the numbers up to 10

00:07:52,330 --> 00:07:56,800
to the fifth run it through map we're

00:07:55,270 --> 00:07:58,510
gonna find out if that number is prime

00:07:56,800 --> 00:08:00,250
now this is going to return a boolean

00:07:58,510 --> 00:08:03,300
and we're gonna turn that into an

00:08:00,250 --> 00:08:05,290
integer 0 1 and then take the sum so

00:08:03,300 --> 00:08:07,330
this basically just counts all the

00:08:05,290 --> 00:08:11,610
number of prime numbers in that range

00:08:07,330 --> 00:08:14,470
and this takes about 20 seconds if we

00:08:11,610 --> 00:08:18,730
instead of going directly to the map if

00:08:14,470 --> 00:08:20,470
we put a race in here this takes this

00:08:18,730 --> 00:08:22,900
sequence of numbers over here and

00:08:20,470 --> 00:08:25,330
instead of returning a regular sequence

00:08:22,900 --> 00:08:26,800
that we would map over this sequence can

00:08:25,330 --> 00:08:30,850
run in parallel and the compiler sets

00:08:26,800 --> 00:08:33,400
that up for you it deals with batching

00:08:30,850 --> 00:08:37,840
the number of threats that are there one

00:08:33,400 --> 00:08:39,280
of the things that I will repeat many

00:08:37,840 --> 00:08:40,540
times don't worry about it the scheduler

00:08:39,280 --> 00:08:43,380
will take care of that you don't have to

00:08:40,540 --> 00:08:46,840
manage how many threads or how much work

00:08:43,380 --> 00:08:47,980
so just by adding this race in here it's

00:08:46,840 --> 00:08:53,400
going to run it over multiple threads

00:08:47,980 --> 00:08:53,400
and it cut the time in a third yes

00:08:58,430 --> 00:09:05,970
yes this act yes this actually is this

00:09:04,470 --> 00:09:07,190
is the first example that's why I wanted

00:09:05,970 --> 00:09:09,660
to start with the junctions which are

00:09:07,190 --> 00:09:14,370
sneaking into lie but this this actually

00:09:09,660 --> 00:09:15,779
is doing things in parallel there's

00:09:14,370 --> 00:09:17,699
there's always improvements that can be

00:09:15,779 --> 00:09:19,949
made there was a question in the last

00:09:17,699 --> 00:09:21,990
talk about speed and one of the things

00:09:19,949 --> 00:09:23,610
that can be done is to improve some of

00:09:21,990 --> 00:09:26,720
the parallelization options as well so

00:09:23,610 --> 00:09:30,720
it's a good question so one thing about

00:09:26,720 --> 00:09:32,639
one thing about race is when you take

00:09:30,720 --> 00:09:35,160
that sequence of numbers it doesn't care

00:09:32,639 --> 00:09:36,690
what the order is so if you just want

00:09:35,160 --> 00:09:38,250
the result as fast as possible you don't

00:09:36,690 --> 00:09:39,720
have to worry about it you'll you'll get

00:09:38,250 --> 00:09:41,399
you'll start getting results as soon as

00:09:39,720 --> 00:09:43,459
possible since I'm doing a sum here

00:09:41,399 --> 00:09:48,680
doesn't matter

00:09:43,459 --> 00:09:50,819
so here's a similar one with hyper now

00:09:48,680 --> 00:09:52,709
the clever folks in the audience may

00:09:50,819 --> 00:09:53,790
notice that I'm also just doing a sum at

00:09:52,709 --> 00:09:56,250
the end and there's really no need to

00:09:53,790 --> 00:09:58,860
have the result order of the results

00:09:56,250 --> 00:10:01,170
preserved because I'm throwing them all

00:09:58,860 --> 00:10:02,250
away and adding them together but at 3

00:10:01,170 --> 00:10:03,839
in the morning it was very hard for me

00:10:02,250 --> 00:10:07,620
to find a sample where order didn't

00:10:03,839 --> 00:10:10,019
matter so just enjoy this one a little

00:10:07,620 --> 00:10:11,760
note about the syntax here we kind of

00:10:10,019 --> 00:10:14,160
glossed over this on the last page this

00:10:11,760 --> 00:10:17,880
this exponent works so that's ten to the

00:10:14,160 --> 00:10:21,600
fifth we have a lambda here so this is

00:10:17,880 --> 00:10:23,269
basically a function signature so this

00:10:21,600 --> 00:10:25,290
may look familiar this is actually a

00:10:23,269 --> 00:10:27,990
series that converges on negative one

00:10:25,290 --> 00:10:29,130
and if you actually print out the result

00:10:27,990 --> 00:10:30,600
of this you get a number that is very

00:10:29,130 --> 00:10:34,079
close to negative one that's a rational

00:10:30,600 --> 00:10:35,850
but you can see again it depends on the

00:10:34,079 --> 00:10:38,790
kind of work you're doing here but just

00:10:35,850 --> 00:10:43,279
adding some default threading here is

00:10:38,790 --> 00:10:45,089
going to get you a speed advantage so

00:10:43,279 --> 00:10:46,470
and this is how you can tell that it

00:10:45,089 --> 00:10:49,740
actually works because these knobs do

00:10:46,470 --> 00:10:51,810
things whether you're running hyper and

00:10:49,740 --> 00:10:54,689
and care about the order or race and

00:10:51,810 --> 00:10:57,389
don't both of them take some named

00:10:54,689 --> 00:10:59,759
parameters you can either batch the

00:10:57,389 --> 00:11:01,290
number of items that you want to work on

00:10:59,759 --> 00:11:03,900
at a time or you can say this is the

00:11:01,290 --> 00:11:06,820
degree of parallelization that I want

00:11:03,900 --> 00:11:08,680
so it gives you some sort of lever that

00:11:06,820 --> 00:11:10,090
you can control I would recommend if

00:11:08,680 --> 00:11:12,280
you're trying to do anything like this

00:11:10,090 --> 00:11:16,420
run it first and then that'll give you

00:11:12,280 --> 00:11:18,640
an idea which way you want to tune these

00:11:16,420 --> 00:11:20,530
parameters there's no right answer for

00:11:18,640 --> 00:11:24,280
every procedure it's going to depend on

00:11:20,530 --> 00:11:27,340
the work that you're running and adding

00:11:24,280 --> 00:11:30,910
this large batch size here shaved

00:11:27,340 --> 00:11:34,870
another second off the time so all right

00:11:30,910 --> 00:11:36,070
so this we I talked briefly about

00:11:34,870 --> 00:11:37,960
threads before and how that's too

00:11:36,070 --> 00:11:42,070
low-level for what we want promised is

00:11:37,960 --> 00:11:43,210
really the first object where this is

00:11:42,070 --> 00:11:46,290
that I think the right level of control

00:11:43,210 --> 00:11:49,020
for what you want to do so promises are

00:11:46,290 --> 00:11:52,420
chunks of work they're blocks of code

00:11:49,020 --> 00:11:54,400
you can plan to run them once they're

00:11:52,420 --> 00:11:57,100
done running the promise is either kept

00:11:54,400 --> 00:12:00,910
it worked or the promise is broken there

00:11:57,100 --> 00:12:02,500
was an exception somewhere the scheduler

00:12:00,910 --> 00:12:04,120
is controlling which threads these are

00:12:02,500 --> 00:12:11,410
run on you don't you don't have to worry

00:12:04,120 --> 00:12:12,940
about it it's fine one second so the

00:12:11,410 --> 00:12:15,910
code here you can see we're explicitly

00:12:12,940 --> 00:12:17,230
creating a promise and we're gonna start

00:12:15,910 --> 00:12:19,660
running the code and all the code is

00:12:17,230 --> 00:12:23,140
doing is saying hello so at that point

00:12:19,660 --> 00:12:25,330
this is a planned promise the next thing

00:12:23,140 --> 00:12:26,910
we do is call a method on that promise

00:12:25,330 --> 00:12:28,870
and say we want to wait till it's done

00:12:26,910 --> 00:12:30,280
this doesn't give us the result or

00:12:28,870 --> 00:12:32,080
anything but the status of the promise

00:12:30,280 --> 00:12:34,150
will be kept at that point and then when

00:12:32,080 --> 00:12:36,670
we explicitly ask at forward status we

00:12:34,150 --> 00:12:37,900
get kept so we know that it worked and

00:12:36,670 --> 00:12:42,010
this when you run this it will print out

00:12:37,900 --> 00:12:44,260
hello so that was a successful promise

00:12:42,010 --> 00:12:48,040
here's one that just dies and you can

00:12:44,260 --> 00:12:49,510
see we're using some language sugar here

00:12:48,040 --> 00:12:51,250
so instead of explicitly creating a

00:12:49,510 --> 00:12:53,290
promise object there's a start keyword

00:12:51,250 --> 00:12:56,740
that creates a promise that's the block

00:12:53,290 --> 00:12:59,410
that it's going to run we've switched

00:12:56,740 --> 00:13:02,770
the syntax on the await there's an

00:12:59,410 --> 00:13:04,690
actual await sub that can take a single

00:13:02,770 --> 00:13:07,780
promise or a list of promises and wait

00:13:04,690 --> 00:13:10,540
for all of them and we ask this task

00:13:07,780 --> 00:13:12,250
what its status was it's broken and once

00:13:10,540 --> 00:13:15,760
we know that it's broken we can ask well

00:13:12,250 --> 00:13:16,810
why did you break and if we ask this we

00:13:15,760 --> 00:13:19,750
get actually two

00:13:16,810 --> 00:13:21,760
pieces of information we're in the code

00:13:19,750 --> 00:13:24,550
were you waiting for this to happen and

00:13:21,760 --> 00:13:28,900
then also what was the actual exception

00:13:24,550 --> 00:13:30,340
so you can see line one where it says

00:13:28,900 --> 00:13:34,720
the exception was that's where the dye

00:13:30,340 --> 00:13:35,950
is and where we awaited was line two so

00:13:34,720 --> 00:13:37,150
you get both of those pieces of

00:13:35,950 --> 00:13:38,170
information obviously in that small

00:13:37,150 --> 00:13:39,580
snippet of code you're gonna be able to

00:13:38,170 --> 00:13:53,020
figure that out but if you're using

00:13:39,580 --> 00:13:56,050
modules you'll get both ends yes well

00:13:53,020 --> 00:13:58,720
it's it's an actual it's an actual block

00:13:56,050 --> 00:14:00,460
it's not like a string eval but yes so

00:13:58,720 --> 00:14:02,380
you're you're you're running this the

00:14:00,460 --> 00:14:03,310
the interesting part I guess is that you

00:14:02,380 --> 00:14:04,990
don't know what thread it's getting

00:14:03,310 --> 00:14:06,160
running so it could be if it's small it

00:14:04,990 --> 00:14:07,750
might be running your main thread if

00:14:06,160 --> 00:14:08,860
it's a large chunk of work or you're

00:14:07,750 --> 00:14:09,970
doing a bunch of other things it could

00:14:08,860 --> 00:14:17,800
be running in another thread you don't

00:14:09,970 --> 00:14:19,300
have to worry about it also by the way

00:14:17,800 --> 00:14:21,310
Larry's here so if I say anything wrong

00:14:19,300 --> 00:14:24,030
please correct me which I know you will

00:14:21,310 --> 00:14:24,030
so thank you

00:14:27,260 --> 00:14:32,090
so this this slide gets us into some of

00:14:30,350 --> 00:14:35,540
the reasons I'm of the examples of why

00:14:32,090 --> 00:14:38,480
promises are better than threads so you

00:14:35,540 --> 00:14:40,640
can chain the promises together so we

00:14:38,480 --> 00:14:43,040
have a sample here where we create a new

00:14:40,640 --> 00:14:45,490
promise and what it does is sleep for

00:14:43,040 --> 00:14:49,160
two seconds and then return a value

00:14:45,490 --> 00:14:51,080
there is a ven method on a promise so

00:14:49,160 --> 00:14:54,530
what this says is once we're done with

00:14:51,080 --> 00:14:58,040
the promise then say the result and the

00:14:54,530 --> 00:14:59,780
syntax here dot result whenever you see

00:14:58,040 --> 00:15:02,870
a bear method call like this in purl 6

00:14:59,780 --> 00:15:06,710
is acting on the the topic the dollar

00:15:02,870 --> 00:15:09,620
underscore so the default value when

00:15:06,710 --> 00:15:14,390
you're in this block is is the promise

00:15:09,620 --> 00:15:16,970
so we're calling a result on that ok so

00:15:14,390 --> 00:15:18,710
when this promise is kept it's going to

00:15:16,970 --> 00:15:21,410
say 42 because that's the number that

00:15:18,710 --> 00:15:23,030
the block returned as soon as we declare

00:15:21,410 --> 00:15:24,500
that that's what we want to happen we

00:15:23,030 --> 00:15:25,970
then immediately say what is the status

00:15:24,500 --> 00:15:29,270
of this promise and if you're running

00:15:25,970 --> 00:15:30,860
this in the interactive command line it

00:15:29,270 --> 00:15:31,760
might actually be kept at that point cuz

00:15:30,860 --> 00:15:33,380
you only wait for two seconds to be

00:15:31,760 --> 00:15:34,430
running this in a script it's going to

00:15:33,380 --> 00:15:36,610
say that it's planned we haven't

00:15:34,430 --> 00:15:39,500
actually started any of this work yet

00:15:36,610 --> 00:15:43,100
there's another method on promise called

00:15:39,500 --> 00:15:44,990
result this not only awaits for the

00:15:43,100 --> 00:15:47,030
promise to complete but then it also

00:15:44,990 --> 00:15:48,410
gives you the result back so and we're

00:15:47,030 --> 00:15:49,640
just throwing it away here so I actually

00:15:48,410 --> 00:15:52,130
could have used a way then it would have

00:15:49,640 --> 00:15:54,650
been fine and then at the end what was

00:15:52,130 --> 00:15:57,050
the status of the promise so with what

00:15:54,650 --> 00:15:59,300
this outputs when you run it it's going

00:15:57,050 --> 00:16:01,160
to say planned because that happens as

00:15:59,300 --> 00:16:04,130
soon as we construct everything it's

00:16:01,160 --> 00:16:06,500
then going to say 42 because that's what

00:16:04,130 --> 00:16:09,770
the asynchronous code did and then at

00:16:06,500 --> 00:16:12,860
the end it'll say kept so this lets you

00:16:09,770 --> 00:16:14,600
take discrete chunks of work and if one

00:16:12,860 --> 00:16:22,010
depends on another you can use then to

00:16:14,600 --> 00:16:25,700
chain those promises also have timers so

00:16:22,010 --> 00:16:28,430
this first one here what it's trying to

00:16:25,700 --> 00:16:32,060
do and I know it says it's wrong it's

00:16:28,430 --> 00:16:33,560
trying to wait two seconds and then say

00:16:32,060 --> 00:16:34,820
that number so this is very similar what

00:16:33,560 --> 00:16:36,710
we did before where we have the sleep

00:16:34,820 --> 00:16:37,360
but this is letting the promise to do

00:16:36,710 --> 00:16:38,890
that way

00:16:37,360 --> 00:16:41,680
for us so you don't have to explicitly

00:16:38,890 --> 00:16:42,820
sleep the reason that is wrong is

00:16:41,680 --> 00:16:44,500
because what happens when you run that

00:16:42,820 --> 00:16:45,910
code is it says okay in two seconds do

00:16:44,500 --> 00:16:47,380
this and then you reach the end of the

00:16:45,910 --> 00:16:48,640
program and everything stops and it

00:16:47,380 --> 00:16:51,839
never actually executes that there's

00:16:48,640 --> 00:16:53,440
nothing to by default that keeps the

00:16:51,839 --> 00:16:58,390
interpreter around while that's

00:16:53,440 --> 00:17:02,820
happening and thank you for the 20% less

00:16:58,390 --> 00:17:05,589
wrong quote so what that does we create

00:17:02,820 --> 00:17:07,209
promise and you'll see I'm probably used

00:17:05,589 --> 00:17:08,620
for different variable names so far for

00:17:07,209 --> 00:17:13,809
the name of the promise I apologize that

00:17:08,620 --> 00:17:16,929
trailer should be one so we do the exact

00:17:13,809 --> 00:17:20,439
same thing and then we say wait for the

00:17:16,929 --> 00:17:22,990
result alternatively instead of a timer

00:17:20,439 --> 00:17:24,970
that kicks off in X seconds you can use

00:17:22,990 --> 00:17:27,010
at like if there was a specific time

00:17:24,970 --> 00:17:28,089
that you wanted to run this on and of

00:17:27,010 --> 00:17:29,919
course this is now a terrible example

00:17:28,089 --> 00:17:34,410
because I'm just doing it in two seconds

00:17:29,919 --> 00:17:34,410
from now so these both do the same thing

00:17:34,830 --> 00:17:38,770
in addition to setting a timer you can

00:17:37,330 --> 00:17:40,480
also do a timeout

00:17:38,770 --> 00:17:44,380
so if you have a what a long-running

00:17:40,480 --> 00:17:45,429
piece of code and you don't if it

00:17:44,380 --> 00:17:47,710
doesn't finish in five seconds you don't

00:17:45,429 --> 00:17:50,410
care so this gives you a way to set a

00:17:47,710 --> 00:17:52,390
timer and also the actual interesting

00:17:50,410 --> 00:17:55,330
code that you're working on and here

00:17:52,390 --> 00:17:59,230
there's just two timers whichever one

00:17:55,330 --> 00:18:00,880
finishes first the promise any of that

00:17:59,230 --> 00:18:02,919
actually returns a promise that just

00:18:00,880 --> 00:18:05,260
waits for the first thing to come back

00:18:02,919 --> 00:18:08,710
as soon as some promises kept or broken

00:18:05,260 --> 00:18:13,059
the total promise is set so what this

00:18:08,710 --> 00:18:15,100
does when you run it is set up two

00:18:13,059 --> 00:18:17,290
timers the first one runs in about three

00:18:15,100 --> 00:18:18,910
seconds and then says PI and then the

00:18:17,290 --> 00:18:21,669
second one runs in about six seconds and

00:18:18,910 --> 00:18:25,510
asks about tau so when you run this it

00:18:21,669 --> 00:18:26,650
prints pi wins and then it exits one

00:18:25,510 --> 00:18:28,690
thing that's important to know though

00:18:26,650 --> 00:18:30,280
just like in the previous slide that

00:18:28,690 --> 00:18:32,440
other that other promise is still out

00:18:30,280 --> 00:18:34,299
there so if you put in an explicit loop

00:18:32,440 --> 00:18:37,000
at the end here both of those will print

00:18:34,299 --> 00:18:39,970
out because that original the the second

00:18:37,000 --> 00:18:41,770
promise still gets kept so and there's

00:18:39,970 --> 00:18:43,690
it's important to note there's three

00:18:41,770 --> 00:18:45,669
promises here the the two individual

00:18:43,690 --> 00:18:48,310
ones and then the combined one so this

00:18:45,669 --> 00:19:11,620
is just another way to combine promises

00:18:48,310 --> 00:19:13,900
yeah sure that is an excellent question

00:19:11,620 --> 00:19:15,130
and I knew anticipated that and I was

00:19:13,900 --> 00:19:17,910
unable to find an answer to it when I

00:19:15,130 --> 00:19:17,910
was doing that research

00:19:18,870 --> 00:19:24,730
thank you it it absolutely seems like a

00:19:23,380 --> 00:19:27,780
reasonable request and I'm sure that we

00:19:24,730 --> 00:19:27,780
will we will get there

00:19:39,730 --> 00:19:52,100
yeah lovely well thankfully we have

00:19:50,090 --> 00:19:55,130
multiple backends so if the JVM is not

00:19:52,100 --> 00:20:00,110
your speed we have our own VM where

00:19:55,130 --> 00:20:01,430
hopefully we can do that yes so and if

00:20:00,110 --> 00:20:02,720
you don't care if there's no side

00:20:01,430 --> 00:20:05,150
effects it doesn't I mean you're using

00:20:02,720 --> 00:20:14,750
up more computing power but you'll get

00:20:05,150 --> 00:20:16,370
the right answer so yep so so all of the

00:20:14,750 --> 00:20:17,840
samples that I've shown so far so far

00:20:16,370 --> 00:20:19,880
with promises have been code that you're

00:20:17,840 --> 00:20:21,680
running inside your own Perl 6 program

00:20:19,880 --> 00:20:23,120
it could be a module it could be just an

00:20:21,680 --> 00:20:25,970
inline sub that you have there but it's

00:20:23,120 --> 00:20:29,740
all in the process there's a built-in

00:20:25,970 --> 00:20:33,280
class this is this is shipped with rikuo

00:20:29,740 --> 00:20:35,930
to let you work with external processes

00:20:33,280 --> 00:20:39,410
so here this is a fully functional

00:20:35,930 --> 00:20:43,520
program you could run this on your

00:20:39,410 --> 00:20:46,370
command line and this introduces a

00:20:43,520 --> 00:20:49,160
little bit more syntax Perl 6 has a main

00:20:46,370 --> 00:20:51,380
sub so if that exists that's what's

00:20:49,160 --> 00:20:53,150
going to get run first and the arguments

00:20:51,380 --> 00:20:55,040
that you define for main are your

00:20:53,150 --> 00:20:57,050
command line arguments so this defines a

00:20:55,040 --> 00:20:59,060
program that takes a string that's a

00:20:57,050 --> 00:21:00,230
file name and if you try to run it and

00:20:59,060 --> 00:21:01,790
don't pass it anything you'll get a

00:21:00,230 --> 00:21:04,160
default usage statement that will tell

00:21:01,790 --> 00:21:08,180
you that so the first thing we do here

00:21:04,160 --> 00:21:10,400
is create a new proc async object we

00:21:08,180 --> 00:21:12,950
pass it the name of the Perl executable

00:21:10,400 --> 00:21:14,690
that we ourselves are using we give it

00:21:12,950 --> 00:21:17,570
the dock option and we pass in that file

00:21:14,690 --> 00:21:18,890
name so this sets up a command it

00:21:17,570 --> 00:21:24,230
doesn't necessarily start running it

00:21:18,890 --> 00:21:26,540
right now and the next two lines are

00:21:24,230 --> 00:21:28,550
going to be capturing the output so we

00:21:26,540 --> 00:21:31,490
take that async object there's a

00:21:28,550 --> 00:21:33,080
standard out method on it and we get

00:21:31,490 --> 00:21:34,370
that attribute and say we want to put a

00:21:33,080 --> 00:21:35,930
tap on this we'll talk more about a

00:21:34,370 --> 00:21:38,480
little more about taps later but

00:21:35,930 --> 00:21:41,540
basically this says that whenever input

00:21:38,480 --> 00:21:44,150
is output is coming to our process we

00:21:41,540 --> 00:21:45,590
get that into this little lambda here we

00:21:44,150 --> 00:21:47,360
take that string and add it to the

00:21:45,590 --> 00:21:49,070
output and then we wait for this to

00:21:47,360 --> 00:21:50,429
finish so we basically turn this async

00:21:49,070 --> 00:21:52,139
process here

00:21:50,429 --> 00:21:53,909
into a blocking process it's gonna run

00:21:52,139 --> 00:21:55,710
the command finish get all the output

00:21:53,909 --> 00:21:59,549
and then that'll be an output and then

00:21:55,710 --> 00:22:00,749
we just print it so this is a snippet

00:21:59,549 --> 00:22:03,539
that's very similar to stuff in the Perl

00:22:00,749 --> 00:22:07,169
6 documentation project that we use for

00:22:03,539 --> 00:22:09,259
testing we actually run the the doc

00:22:07,169 --> 00:22:11,970
option which processes the pod and gets

00:22:09,259 --> 00:22:18,330
gets us the raw text and then we can do

00:22:11,970 --> 00:22:20,490
tests based on that raw text so this is

00:22:18,330 --> 00:22:21,960
a little more this is a little closer to

00:22:20,490 --> 00:22:23,730
what's actually in the file so rather

00:22:21,960 --> 00:22:25,499
than working on a single file we go

00:22:23,730 --> 00:22:28,799
through the file list and then for every

00:22:25,499 --> 00:22:32,610
file run this block and again we set up

00:22:28,799 --> 00:22:33,509
the command there's a output hash this

00:22:32,610 --> 00:22:36,779
time because we will be running this

00:22:33,509 --> 00:22:39,960
over multiple files we keep a job list

00:22:36,779 --> 00:22:41,909
and we just we start the job that

00:22:39,960 --> 00:22:43,379
returns a promise we put the promise in

00:22:41,909 --> 00:22:47,659
our array just so that we can keep track

00:22:43,379 --> 00:22:51,179
of it we have a very simplistic

00:22:47,659 --> 00:22:56,549
mechanism here that says if though if we

00:22:51,179 --> 00:22:58,919
have as many jobs as in the queue that's

00:22:56,549 --> 00:23:00,269
I think the default here is 4 so we run

00:22:58,919 --> 00:23:01,980
four jobs when we try to run the fifth

00:23:00,269 --> 00:23:02,970
job we say well we don't want to put

00:23:01,980 --> 00:23:04,289
anything more in the queue well let's

00:23:02,970 --> 00:23:07,649
get one of these results and do

00:23:04,289 --> 00:23:12,059
something with it so this pulls that

00:23:07,649 --> 00:23:14,039
first promise off the list and then

00:23:12,059 --> 00:23:16,649
waits for it to finish and then once

00:23:14,039 --> 00:23:17,909
it's done we pass that result into our

00:23:16,649 --> 00:23:19,110
function that actually does the test

00:23:17,909 --> 00:23:22,019
that we care about like if we're

00:23:19,110 --> 00:23:24,960
checking for duplicate words or two dots

00:23:22,019 --> 00:23:26,820
instead of one dot and I just want to

00:23:24,960 --> 00:23:28,409
point out here that this is kind of a

00:23:26,820 --> 00:23:29,070
naive choice we'll see a better way to

00:23:28,409 --> 00:23:32,309
do this later

00:23:29,070 --> 00:23:33,869
with a module but this this doesn't care

00:23:32,309 --> 00:23:35,279
how long individual things take to run

00:23:33,869 --> 00:23:36,450
so if the first one on the list is the

00:23:35,279 --> 00:23:38,460
slowest one that we're going to wait

00:23:36,450 --> 00:23:40,080
until that finishes we're two three and

00:23:38,460 --> 00:23:41,669
four might already be done so if you

00:23:40,080 --> 00:23:45,240
don't care about the order you can do a

00:23:41,669 --> 00:23:47,759
better job of managing your time but

00:23:45,240 --> 00:23:50,190
this this gets a at least some

00:23:47,759 --> 00:23:55,759
parallelism in the process so makes all

00:23:50,190 --> 00:23:59,700
the tests run faster ok another built in

00:23:55,759 --> 00:24:00,869
in pro six is a supply so the promises

00:23:59,700 --> 00:24:02,490
that we talked about that's a way for us

00:24:00,869 --> 00:24:03,230
to do deal with our code asynchronously

00:24:02,490 --> 00:24:05,480
we want to run

00:24:03,230 --> 00:24:08,090
and we don't we'll catch up with it

00:24:05,480 --> 00:24:10,790
later when it's finished this gives us a

00:24:08,090 --> 00:24:13,280
way to have asynchronous data and we

00:24:10,790 --> 00:24:16,400
want to react to that data we just have

00:24:13,280 --> 00:24:18,440
some simple examples here data coming in

00:24:16,400 --> 00:24:20,840
over a network if you're writing a GUI

00:24:18,440 --> 00:24:24,049
you can write an event handler using

00:24:20,840 --> 00:24:27,799
these supplies just like with promises

00:24:24,049 --> 00:24:31,750
you can create a supply of pings that

00:24:27,799 --> 00:24:36,380
come out every so many seconds so yes

00:24:31,750 --> 00:24:37,669
halfway all right so there's so there's

00:24:36,380 --> 00:24:38,809
a lot of different things you can do

00:24:37,669 --> 00:24:39,740
with supplies this is an intro talk

00:24:38,809 --> 00:24:40,940
we're just going to cover some of the

00:24:39,740 --> 00:24:42,380
real basic stuff that you can generate

00:24:40,940 --> 00:24:44,030
from inside your program but it gives

00:24:42,380 --> 00:24:48,200
you a feel for how to interact with the

00:24:44,030 --> 00:24:52,580
supplies that is a great ringtone David

00:24:48,200 --> 00:24:54,950
it's alright so the first one we're

00:24:52,580 --> 00:24:57,770
gonna do is just on the supply object

00:24:54,950 --> 00:24:59,720
will call in Java who we call the we

00:24:57,770 --> 00:25:02,960
would call that a class method will

00:24:59,720 --> 00:25:05,480
create an interval that hit kick

00:25:02,960 --> 00:25:06,740
something off every second just like

00:25:05,480 --> 00:25:08,600
with the promises this doesn't actually

00:25:06,740 --> 00:25:10,250
do anything this creates a supply the

00:25:08,600 --> 00:25:12,620
events are ready to go but we're not

00:25:10,250 --> 00:25:14,750
doing anything with it so we use we can

00:25:12,620 --> 00:25:17,929
use this tap syntax again that we saw in

00:25:14,750 --> 00:25:20,299
proc async and what this does in this

00:25:17,929 --> 00:25:22,549
example is is nothing we set everything

00:25:20,299 --> 00:25:23,720
up and again the program exits so that

00:25:22,549 --> 00:25:26,630
that's a common theme with these samples

00:25:23,720 --> 00:25:27,980
here so what we really want to do is set

00:25:26,630 --> 00:25:31,190
that up and we'll just sleep for 10

00:25:27,980 --> 00:25:33,440
seconds now the supply is generating the

00:25:31,190 --> 00:25:35,210
events the tap is getting the events we

00:25:33,440 --> 00:25:38,470
we have a sleep so we just hang around

00:25:35,210 --> 00:25:38,470
for 10 seconds and then we stop

00:25:41,950 --> 00:25:45,890
it's it's just a dumb number so when you

00:25:44,330 --> 00:25:48,409
start an interval the first ones 1 the

00:25:45,890 --> 00:25:50,330
second ones - it's just a way to get a

00:25:48,409 --> 00:25:52,610
trigger that something happens so if you

00:25:50,330 --> 00:25:54,730
need to wake up every so often to check

00:25:52,610 --> 00:25:59,990
something that you actually care about

00:25:54,730 --> 00:26:01,460
that gives you a way to do that this is

00:25:59,990 --> 00:26:02,840
just a chance to show that you can

00:26:01,460 --> 00:26:04,610
actually have the literal 1/3 in the

00:26:02,840 --> 00:26:07,730
code I apologize

00:26:04,610 --> 00:26:09,110
so this waits 3 seconds and then 3 times

00:26:07,730 --> 00:26:10,850
a second generates this event so it's

00:26:09,110 --> 00:26:15,530
very similar what we saw before and

00:26:10,850 --> 00:26:17,059
again you still get 1 2 3 all right so

00:26:15,530 --> 00:26:19,460
this this syntax where you have the

00:26:17,059 --> 00:26:21,950
method call in the block all in line can

00:26:19,460 --> 00:26:23,990
start getting a little verbose so there

00:26:21,950 --> 00:26:27,230
is some built in syntax that gives you a

00:26:23,990 --> 00:26:31,340
way to have a little easier to read

00:26:27,230 --> 00:26:32,840
version so this has the same supply that

00:26:31,340 --> 00:26:35,360
we saw in the last slide so after 3

00:26:32,840 --> 00:26:39,250
seconds start generating events 3 times

00:26:35,360 --> 00:26:41,780
a second the block inside the whenever

00:26:39,250 --> 00:26:43,360
is where the tap goes so the way you

00:26:41,780 --> 00:26:46,190
would read this is say I want to react

00:26:43,360 --> 00:26:48,140
whenever this supply does something and

00:26:46,190 --> 00:26:49,760
here's what I want to do you can have

00:26:48,140 --> 00:26:50,780
multiple whenever blocks in here so if

00:26:49,760 --> 00:26:53,840
you want to react to different things

00:26:50,780 --> 00:26:57,080
this is basically in other languages

00:26:53,840 --> 00:26:58,820
this might be your event though so and

00:26:57,080 --> 00:27:00,380
one thing about this all of the other

00:26:58,820 --> 00:27:01,760
examples we've seen so far

00:27:00,380 --> 00:27:03,320
this wouldn't do anything because it

00:27:01,760 --> 00:27:05,240
just falls off the end the react is

00:27:03,320 --> 00:27:07,520
actually an event loop so this this

00:27:05,240 --> 00:27:09,260
stays in place so this will actually run

00:27:07,520 --> 00:27:12,020
forever and just keep printing out

00:27:09,260 --> 00:27:14,750
numbers so if you want to stop it

00:27:12,020 --> 00:27:18,650
there's another syntax another keyword

00:27:14,750 --> 00:27:22,100
for you done and this says that I I am

00:27:18,650 --> 00:27:25,690
done reacting and this has like a 90%

00:27:22,100 --> 00:27:32,480
chance of continuing and then we'll

00:27:25,690 --> 00:27:34,340
decide so that was an interval supply

00:27:32,480 --> 00:27:38,210
you can also here a fixed list of things

00:27:34,340 --> 00:27:41,600
you can take a supply from that so we

00:27:38,210 --> 00:27:44,000
get a quick list of crimes it's not very

00:27:41,600 --> 00:27:49,630
long ever anything up to a thousand

00:27:44,000 --> 00:27:49,630
and this actually runs through that list

00:27:50,020 --> 00:27:55,580
in the supply it generates an event for

00:27:53,000 --> 00:27:57,320
each one of those prime numbers prints

00:27:55,580 --> 00:28:00,320
them out because that's our tap method

00:27:57,320 --> 00:28:02,660
there but then when it's done the supply

00:28:00,320 --> 00:28:04,340
is done and this finishes so the supply

00:28:02,660 --> 00:28:06,620
Indic signals that there's nothing else

00:28:04,340 --> 00:28:08,630
coming and then you're done

00:28:06,620 --> 00:28:11,320
so you can use that too if you're

00:28:08,630 --> 00:28:13,580
building your own supply so you can make

00:28:11,320 --> 00:28:15,530
you can build in the end condition there

00:28:13,580 --> 00:28:21,910
or you can have ones that just go on

00:28:15,530 --> 00:28:25,220
forever how are we doing on time not bad

00:28:21,910 --> 00:28:26,990
so you can think of the events coming

00:28:25,220 --> 00:28:28,430
from the supply is kind of a list we saw

00:28:26,990 --> 00:28:31,490
the sequence before and race and hyper

00:28:28,430 --> 00:28:33,170
where it's a special kind of sequence so

00:28:31,490 --> 00:28:35,210
since this is basically just a list

00:28:33,170 --> 00:28:36,890
that's happening over time there are a

00:28:35,210 --> 00:28:39,440
bunch of list related methods on the

00:28:36,890 --> 00:28:41,060
supply that you can use so the sample

00:28:39,440 --> 00:28:42,500
that we have here we do that same thing

00:28:41,060 --> 00:28:44,390
where we get the list of primes we set

00:28:42,500 --> 00:28:45,890
up a separate supply and then in our

00:28:44,390 --> 00:28:48,230
react block we say okay

00:28:45,890 --> 00:28:49,750
I want all the events but let's grep out

00:28:48,230 --> 00:28:52,190
the ones where the value ends with a 7

00:28:49,750 --> 00:28:53,630
so you can use grep map you can

00:28:52,190 --> 00:28:56,480
transform those data values into

00:28:53,630 --> 00:28:58,760
something else and you can listen to

00:28:56,480 --> 00:29:04,980
those transform supplies rather than the

00:28:58,760 --> 00:29:14,490
original one yes

00:29:04,980 --> 00:29:20,290
I think they all have to be done yeah

00:29:14,490 --> 00:29:24,130
and so we talked a little bit here about

00:29:20,290 --> 00:29:25,420
chaining the supplies you can also for

00:29:24,130 --> 00:29:28,630
example if you wanted to be able to read

00:29:25,420 --> 00:29:30,730
both of those Prime events that we had

00:29:28,630 --> 00:29:31,840
you could have a tap on both of them you

00:29:30,730 --> 00:29:35,110
could react to the original you could

00:29:31,840 --> 00:29:37,990
react to the the new chained one and

00:29:35,110 --> 00:29:42,880
each listener gets all of the events so

00:29:37,990 --> 00:29:44,680
it's a it's like a broadcast and all the

00:29:42,880 --> 00:29:47,500
ones we've seen so far are on-demand you

00:29:44,680 --> 00:29:49,890
generate the events the events stay

00:29:47,500 --> 00:29:52,060
there until somebody taps them and

00:29:49,890 --> 00:29:54,640
correct me if I'm wrong but was tap

00:29:52,060 --> 00:29:57,750
intended to be like tap like a beer like

00:29:54,640 --> 00:30:01,930
you're tapping a keg okay thank you

00:29:57,750 --> 00:30:03,490
the you can also create live supplies

00:30:01,930 --> 00:30:05,020
there's a supplier class that lets you

00:30:03,490 --> 00:30:07,840
get a little fancier we're not gonna

00:30:05,020 --> 00:30:10,390
cover that in this talk but with those

00:30:07,840 --> 00:30:13,330
the supplies are law say if you're not

00:30:10,390 --> 00:30:14,440
listening the event is gone so there's

00:30:13,330 --> 00:30:15,400
certain types of data where that makes

00:30:14,440 --> 00:30:17,010
sense there's certain types of data

00:30:15,400 --> 00:30:19,510
where you want to get every single event

00:30:17,010 --> 00:30:21,250
but if it's if it's a GUI and you're

00:30:19,510 --> 00:30:23,860
behind processing maybe you don't care

00:30:21,250 --> 00:30:27,190
where the mouse was five seconds ago so

00:30:23,860 --> 00:30:29,080
and just as with the on-demand ones the

00:30:27,190 --> 00:30:33,040
live ones can also be consumed in

00:30:29,080 --> 00:30:34,960
multiple places so for example if you

00:30:33,040 --> 00:30:36,250
wanted to by default you're just running

00:30:34,960 --> 00:30:38,230
the business logic whenever an event

00:30:36,250 --> 00:30:41,070
happens you could also attach a logger

00:30:38,230 --> 00:30:41,070
yes

00:30:46,840 --> 00:30:53,330
for the for the live ones note because

00:30:50,600 --> 00:30:55,160
you if you have a tap in place that will

00:30:53,330 --> 00:30:57,920
you should get both of those events it's

00:30:55,160 --> 00:31:01,340
if you haven't attached yet that's where

00:30:57,920 --> 00:31:04,190
the issue was but I'm glad you mentioned

00:31:01,340 --> 00:31:07,850
queue so the the last primitive that we

00:31:04,190 --> 00:31:09,740
have is a channel it's kind of similar

00:31:07,850 --> 00:31:13,850
to a supply bus but it acts more like a

00:31:09,740 --> 00:31:15,350
first-in first-out message queue and you

00:31:13,850 --> 00:31:16,640
can still have multiple things attached

00:31:15,350 --> 00:31:17,810
to this but instead of the events going

00:31:16,640 --> 00:31:22,040
to everybody who ever gets the event

00:31:17,810 --> 00:31:25,100
they win so and this is set up to work

00:31:22,040 --> 00:31:26,360
transparently over those start blocks

00:31:25,100 --> 00:31:29,210
that we saw so they could be running on

00:31:26,360 --> 00:31:33,040
different threads I have a quick sample

00:31:29,210 --> 00:31:36,110
here this is I have a project at work

00:31:33,040 --> 00:31:38,360
where we have people who love Excel and

00:31:36,110 --> 00:31:41,390
they like large large Excel files so we

00:31:38,360 --> 00:31:43,550
have the ability to generate a dump of a

00:31:41,390 --> 00:31:45,080
database they get an excel file out of

00:31:43,550 --> 00:31:46,580
it this could take tens of minutes

00:31:45,080 --> 00:31:49,400
because some of these queries are just

00:31:46,580 --> 00:31:50,960
horrible so we have this process set up

00:31:49,400 --> 00:31:52,760
and unfortunately for me it's not in Pro

00:31:50,960 --> 00:31:55,100
six where we have a message queue

00:31:52,760 --> 00:31:56,600
somebody says I want this job it gets

00:31:55,100 --> 00:31:57,920
into the queue we have workers that work

00:31:56,600 --> 00:32:00,170
on it and we get the result back so I

00:31:57,920 --> 00:32:02,330
have a very dumbed down version of that

00:32:00,170 --> 00:32:05,210
to show you here so we set up a new

00:32:02,330 --> 00:32:07,130
channel I want you to imagine that this

00:32:05,210 --> 00:32:09,260
came in over a REST API call and I'm not

00:32:07,130 --> 00:32:10,700
just hard coding the sequel here and

00:32:09,260 --> 00:32:15,500
especially not this weak sequel I

00:32:10,700 --> 00:32:18,380
apologize so we we take that channel and

00:32:15,500 --> 00:32:20,300
we send it this packet of data

00:32:18,380 --> 00:32:22,640
so hopefully the thing that is listening

00:32:20,300 --> 00:32:25,460
will know what to do with that and

00:32:22,640 --> 00:32:29,510
that's on the side that is generating

00:32:25,460 --> 00:32:32,750
the jobs and kind of analogous to what I

00:32:29,510 --> 00:32:36,890
have in my project this takes an array

00:32:32,750 --> 00:32:39,650
of workers it says give me run this

00:32:36,890 --> 00:32:43,160
block eight times so it's pushing eight

00:32:39,650 --> 00:32:45,470
of these start blocks onto the worker

00:32:43,160 --> 00:32:47,630
this start block is just going to loop

00:32:45,470 --> 00:32:49,990
forever the first thing it does is say

00:32:47,630 --> 00:32:51,680
give me the first item off the channel

00:32:49,990 --> 00:32:53,420
so we're gonna have eight of these

00:32:51,680 --> 00:32:55,340
simultaneously only one of those workers

00:32:53,420 --> 00:32:56,790
will get that first event and the others

00:32:55,340 --> 00:32:59,810
will sit there and they won't be

00:32:56,790 --> 00:33:02,760
yup CPU so this gives you a way to have

00:32:59,810 --> 00:33:04,620
any number we'll take advantage of as

00:33:02,760 --> 00:33:06,030
much CPU as you have to get a bunch of

00:33:04,620 --> 00:33:07,350
workers in place that are that are

00:33:06,030 --> 00:33:09,210
commonly sitting there until there is

00:33:07,350 --> 00:33:10,890
something to do and then once you have

00:33:09,210 --> 00:33:14,280
that data packet you can do whatever you

00:33:10,890 --> 00:33:16,020
want with it and then at the end here I

00:33:14,280 --> 00:33:21,360
was too lazy to do the react so I just

00:33:16,020 --> 00:33:23,310
threw a loop at the end so all right how

00:33:21,360 --> 00:33:25,170
much time okay

00:33:23,310 --> 00:33:27,090
so there's that's that's a lot of the

00:33:25,170 --> 00:33:29,340
built-ins there's some more stuff out

00:33:27,090 --> 00:33:32,400
there and again if you go to Docs Pro

00:33:29,340 --> 00:33:33,750
six org there's any of the classes that

00:33:32,400 --> 00:33:35,820
you find it'll list all of the methods

00:33:33,750 --> 00:33:38,760
and you can play around there's a bunch

00:33:35,820 --> 00:33:41,520
of modules in the ecosystem that I think

00:33:38,760 --> 00:33:45,120
are good examples that show you how you

00:33:41,520 --> 00:33:47,940
can build on top of those a a simple one

00:33:45,120 --> 00:33:50,700
is manifesto and I'm just going to show

00:33:47,940 --> 00:33:52,800
you the code here this is Jonathan

00:33:50,700 --> 00:33:56,220
Stowe's project so here's some sample

00:33:52,800 --> 00:33:59,490
code using his library and will briefly

00:33:56,220 --> 00:34:02,750
glance at the code in his library excuse

00:33:59,490 --> 00:34:07,440
me so we create a new manifesto object

00:34:02,750 --> 00:34:09,810
this this syntax here basically it's

00:34:07,440 --> 00:34:11,490
saying take the take zero to nine put

00:34:09,810 --> 00:34:14,610
them in a random order and then for each

00:34:11,490 --> 00:34:17,520
of them create a promise that is going

00:34:14,610 --> 00:34:20,010
to sleep for about that many seconds and

00:34:17,520 --> 00:34:21,510
then return that value and it takes all

00:34:20,010 --> 00:34:24,149
of these promises and adds them into the

00:34:21,510 --> 00:34:25,530
manifesto so if you have a bunch of

00:34:24,149 --> 00:34:26,820
things that are going to this is going

00:34:25,530 --> 00:34:28,260
to wait one second and then return one

00:34:26,820 --> 00:34:29,879
this is going to wait three seconds and

00:34:28,260 --> 00:34:32,850
return three this this is a sleep sort

00:34:29,879 --> 00:34:35,220
that's what this is so we we take that

00:34:32,850 --> 00:34:37,290
manifesto we create a new channel and we

00:34:35,220 --> 00:34:38,100
say we put in our react lock and here

00:34:37,290 --> 00:34:41,190
you can see there's actually two

00:34:38,100 --> 00:34:45,330
whenever's whenever the manifesto does

00:34:41,190 --> 00:34:47,940
something get the value and then send

00:34:45,330 --> 00:34:49,649
that value to the channel and whenever

00:34:47,940 --> 00:34:52,020
the manifesto is empty close the channel

00:34:49,649 --> 00:34:53,820
and we're done and then the last thing

00:34:52,020 --> 00:34:55,200
we do is say channel dot list so the

00:34:53,820 --> 00:34:56,879
list is a method that says give me all

00:34:55,200 --> 00:34:59,700
the values of the channel once it's done

00:34:56,879 --> 00:35:02,100
so what this actually prints out is the

00:34:59,700 --> 00:35:04,380
number zero through nine and order going

00:35:02,100 --> 00:35:05,490
through a bunch of stuff that you would

00:35:04,380 --> 00:35:07,890
never do if you actually wanted to do

00:35:05,490 --> 00:35:09,720
that sort but this is a good example of

00:35:07,890 --> 00:35:11,430
how you can compose the built-ins

00:35:09,720 --> 00:35:14,700
promises and channels and supplies into

00:35:11,430 --> 00:35:16,740
something that is it's a lot more

00:35:14,700 --> 00:35:23,820
powerful and if we just look at his code

00:35:16,740 --> 00:35:26,160
briefly here this is on github so most

00:35:23,820 --> 00:35:29,640
of this is pod this is this is the

00:35:26,160 --> 00:35:32,460
manifesto class and it's about what 30

00:35:29,640 --> 00:35:34,740
lines there's not a lot going on here

00:35:32,460 --> 00:35:37,619
so being able to get some pretty

00:35:34,740 --> 00:35:41,580
powerful functionality using that one of

00:35:37,619 --> 00:35:43,980
the other modules I'm not gonna bother

00:35:41,580 --> 00:35:47,130
going back into full-screen mode is proc

00:35:43,980 --> 00:35:49,619
queue and this is by suffix the

00:35:47,130 --> 00:35:51,270
description on his his project is queue

00:35:49,619 --> 00:35:53,250
up and run a herd of procs we looked at

00:35:51,270 --> 00:35:56,010
a proc async before so this is a nice

00:35:53,250 --> 00:36:00,210
front-end to that I actually use this in

00:35:56,010 --> 00:36:04,220
a DevOps capacity at work again live

00:36:00,210 --> 00:36:06,510
production code and here's some samples

00:36:04,220 --> 00:36:09,090
what proc queue does is you give it a

00:36:06,510 --> 00:36:11,010
list of jobs and these jobs are it's

00:36:09,090 --> 00:36:12,480
it's though they look just like this

00:36:11,010 --> 00:36:16,140
it's an array that you would pass to

00:36:12,480 --> 00:36:17,580
proc async so I want to do an SSH I want

00:36:16,140 --> 00:36:20,400
to go to a particular host and I want to

00:36:17,580 --> 00:36:22,770
run this very specific curl command so

00:36:20,400 --> 00:36:23,970
this is a poor-man's network check I

00:36:22,770 --> 00:36:24,869
just wanna make sure I can make a TCP

00:36:23,970 --> 00:36:26,490
connection to something it doesn't

00:36:24,869 --> 00:36:27,810
actually have to be HTTP I just wanna

00:36:26,490 --> 00:36:29,400
make sure I can connect can I connect to

00:36:27,810 --> 00:36:31,950
the database connect enter to the SMTP

00:36:29,400 --> 00:36:34,500
server we have a lot of servers that we

00:36:31,950 --> 00:36:35,730
deploy and the initial deploy is not

00:36:34,500 --> 00:36:37,170
under our control so we have to do a lot

00:36:35,730 --> 00:36:39,619
of QA to make sure that these things

00:36:37,170 --> 00:36:42,000
actually are connecting to what we can

00:36:39,619 --> 00:36:44,400
so we keep we keep track of that list of

00:36:42,000 --> 00:36:47,460
jobs I could have a hundred jobs here we

00:36:44,400 --> 00:36:48,930
keep a list of descriptions so that I

00:36:47,460 --> 00:36:51,119
don't have to parse out from the job

00:36:48,930 --> 00:36:54,660
what host did I connect to I can just

00:36:51,119 --> 00:36:58,080
pass that information in and here's a

00:36:54,660 --> 00:36:59,790
sample using his module I didn't

00:36:58,080 --> 00:37:01,200
actually do the import this so this is

00:36:59,790 --> 00:37:04,020
not a fully functioning piece of code

00:37:01,200 --> 00:37:05,070
but we take his praça Q command we give

00:37:04,020 --> 00:37:08,580
it the list of jobs that we put together

00:37:05,070 --> 00:37:10,080
we give it the list of tags we say what

00:37:08,580 --> 00:37:11,310
batch we want to run it in so if I if

00:37:10,080 --> 00:37:13,140
I'm connecting to a hundred host I might

00:37:11,310 --> 00:37:15,480
want to do ten at a time and I don't

00:37:13,140 --> 00:37:16,859
have to write that naive code that we

00:37:15,480 --> 00:37:19,800
saw before this handles all of that

00:37:16,859 --> 00:37:22,589
behind the scenes there's a timeout so I

00:37:19,800 --> 00:37:24,509
can we have some machines where the path

00:37:22,589 --> 00:37:26,279
word gets changed on us for some reason

00:37:24,509 --> 00:37:27,960
or there's a network connection even

00:37:26,279 --> 00:37:30,329
getting to the box to do the to get to

00:37:27,960 --> 00:37:32,670
the server on the test so this timeout

00:37:30,329 --> 00:37:36,180
will tell me could I even run this

00:37:32,670 --> 00:37:37,410
command and then we say we want to merge

00:37:36,180 --> 00:37:41,849
standard in and standard out cuz I don't

00:37:37,410 --> 00:37:43,680
care about that oops and here we have

00:37:41,849 --> 00:37:46,079
another react react block so whenever

00:37:43,680 --> 00:37:50,519
this proc you does something if it was

00:37:46,079 --> 00:37:52,769
killed then I use my test methods here

00:37:50,519 --> 00:37:56,700
and I say that the test that tests timed

00:37:52,769 --> 00:37:59,670
out if the test completed I check the

00:37:56,700 --> 00:38:00,989
output I cheat and look at the curled

00:37:59,670 --> 00:38:02,670
output and say did it did I get a

00:38:00,989 --> 00:38:05,369
connected message I did okay then it

00:38:02,670 --> 00:38:07,499
connected so this this gives me a test I

00:38:05,369 --> 00:38:09,660
can run I get tap output I can easily

00:38:07,499 --> 00:38:12,690
say oh this this one test to this one

00:38:09,660 --> 00:38:14,609
service on this machine failed and then

00:38:12,690 --> 00:38:17,660
I have to go find our legacy support

00:38:14,609 --> 00:38:22,019
team and get that fixed

00:38:17,660 --> 00:38:24,569
alright so that's all of the different

00:38:22,019 --> 00:38:25,710
things that I wanted to show you I will

00:38:24,569 --> 00:38:27,509
try to make these slides available

00:38:25,710 --> 00:38:29,880
there's a bunch of resources that I used

00:38:27,509 --> 00:38:30,960
to help dig up this information that

00:38:29,880 --> 00:38:35,190
will be invaluable to you if you want to

00:38:30,960 --> 00:38:38,460
learn more about these there's in the

00:38:35,190 --> 00:38:39,749
last talk Wendy brought up a book and I

00:38:38,460 --> 00:38:41,910
should have coordinated that so she did

00:38:39,749 --> 00:38:48,660
that this is for sale out there it's a

00:38:41,910 --> 00:38:50,150
Perl 6 deep dive I should have told you

00:38:48,660 --> 00:38:52,200
ahead of time you could have stocked up

00:38:50,150 --> 00:38:54,089
but anyway this this is a really good

00:38:52,200 --> 00:38:56,339
book it doesn't just have stuff about

00:38:54,089 --> 00:38:57,960
asynchrony it's it's a good introduction

00:38:56,339 --> 00:39:01,049
to Perl 6 and it gets into the guts it

00:38:57,960 --> 00:39:05,099
says yes there you go yeah I have I also

00:39:01,049 --> 00:39:05,759
I have a copy in my bag as well so there

00:39:05,099 --> 00:39:07,979
we go

00:39:05,759 --> 00:39:10,469
I don't I do - here thank you I don't I

00:39:07,979 --> 00:39:13,140
don't get a kickback unfortunately Bruce

00:39:10,469 --> 00:39:16,289
also in his slide mentioned Jonathan's

00:39:13,140 --> 00:39:18,599
talks Johnathan Weddington has is the

00:39:16,289 --> 00:39:20,579
driver I think of a lot of this a lot of

00:39:18,599 --> 00:39:21,960
the asynchrony and the concurrency he's

00:39:20,579 --> 00:39:23,219
got a really good handle on it if you've

00:39:21,960 --> 00:39:25,619
ever seen one of his presentations

00:39:23,219 --> 00:39:27,869
they're very amazing you can you can

00:39:25,619 --> 00:39:30,539
follow along there with all of the

00:39:27,869 --> 00:39:31,799
slides if you if you need help with a

00:39:30,539 --> 00:39:34,020
question if you're just experimenting

00:39:31,799 --> 00:39:35,520
come join us on IRC

00:39:34,020 --> 00:39:39,510
we're usually very friendly I think

00:39:35,520 --> 00:39:40,010
that's true yeah except when you're

00:39:39,510 --> 00:39:44,070
there

00:39:40,010 --> 00:39:45,090
troublemaker there's been a huge push

00:39:44,070 --> 00:39:47,970
lately to get people to go on

00:39:45,090 --> 00:39:49,170
stackoverflow so you there's gonna be a

00:39:47,970 --> 00:39:50,730
lot of good questions and answers there

00:39:49,170 --> 00:39:51,810
and that's a good place to ask the

00:39:50,730 --> 00:39:54,060
questions we have a lot of core people

00:39:51,810 --> 00:39:56,780
who are monitoring all the Pearl six

00:39:54,060 --> 00:39:58,950
questions there I linked to the the two

00:39:56,780 --> 00:40:00,869
project the two modules that I talked

00:39:58,950 --> 00:40:02,010
about I talked about Doc's and the last

00:40:00,869 --> 00:40:03,360
thing which I don't I don't really have

00:40:02,010 --> 00:40:05,340
time to get to into this talk

00:40:03,360 --> 00:40:08,190
unfortunately is something else that

00:40:05,340 --> 00:40:11,880
Jonathan's involved in crow with the

00:40:08,190 --> 00:40:16,470
very clever URL micro services and

00:40:11,880 --> 00:40:20,400
that's a web bunch of modules for web

00:40:16,470 --> 00:40:21,570
development and they very much take

00:40:20,400 --> 00:40:24,450
advantage of all of the asynchronous

00:40:21,570 --> 00:40:25,890
work that you can do in Perl 6 and they

00:40:24,450 --> 00:40:28,350
expose that to you in a way that you can

00:40:25,890 --> 00:40:29,850
still use all of the the primitives and

00:40:28,350 --> 00:40:32,190
and syntax that I showed you to interact

00:40:29,850 --> 00:40:34,260
with that so I'm actually super excited

00:40:32,190 --> 00:40:35,730
about working with that I just haven't

00:40:34,260 --> 00:40:40,109
had time to get to a project up with it

00:40:35,730 --> 00:40:42,660
yet so I'll you know how that goes yes

00:40:40,109 --> 00:40:43,859
oh there we go so if you want to find

00:40:42,660 --> 00:40:45,900
out more about Jonathan and the work he

00:40:43,859 --> 00:40:49,170
does there's a bunch of brochures here

00:40:45,900 --> 00:40:50,940
up front crow is one of them there's a

00:40:49,170 --> 00:40:55,050
Perl 6 IDE that his company is working

00:40:50,940 --> 00:40:57,990
on which is in a early access subscriber

00:40:55,050 --> 00:41:00,869
beta it's very pretty

00:40:57,990 --> 00:41:02,850
it's very functional so if you want to

00:41:00,869 --> 00:41:04,800
look if you want to experiment more with

00:41:02,850 --> 00:41:06,990
Perl 6 maybe that's maybe that's the

00:41:04,800 --> 00:41:11,760
thing for you if you like IDs all right

00:41:06,990 --> 00:41:13,920
I don't know 10 minutes how can we have

00:41:11,760 --> 00:41:18,920
10 minutes left I'm done so this is a

00:41:13,920 --> 00:41:26,760
this is a great spot for QA I'm sorry I

00:41:18,920 --> 00:41:28,320
did it's all the anxiety so I only it's

00:41:26,760 --> 00:41:32,850
very effective

00:41:28,320 --> 00:41:34,230
I would be in so much trouble if this

00:41:32,850 --> 00:41:39,930
work computer died so I'm very glad that

00:41:34,230 --> 00:41:41,900
didn't happen so yeah does anybody have

00:41:39,930 --> 00:42:17,070
any questions

00:41:41,900 --> 00:42:19,640
yeah well nothing in Perl 6 is

00:42:17,070 --> 00:42:19,640
disgusting

00:42:19,860 --> 00:42:30,140
I I'm trying to think how that would

00:42:23,400 --> 00:42:32,790
work so each each promise has its own

00:42:30,140 --> 00:42:35,730
status so you can you can look at the

00:42:32,790 --> 00:42:38,160
cause inside a particular one so if you

00:42:35,730 --> 00:42:40,590
have you know promise 1 then promise -

00:42:38,160 --> 00:42:41,880
then promise 3 when you get to a point

00:42:40,590 --> 00:42:43,710
where it's broken you should at that

00:42:41,880 --> 00:42:46,220
point be able to say show me the cause

00:42:43,710 --> 00:42:49,620
that the error that got me here that's

00:42:46,220 --> 00:42:50,850
that thing I showed earlier on where it

00:42:49,620 --> 00:42:54,980
shows you where you were waiting and

00:42:50,850 --> 00:42:54,980
then what was the actual root cause I

00:42:56,420 --> 00:43:01,820
think I think what you have to do is is

00:43:00,000 --> 00:43:04,650
keep track I think if you're if you're

00:43:01,820 --> 00:43:07,790
that's actually a good question I will

00:43:04,650 --> 00:43:07,790
do some research and get back to you

00:43:23,650 --> 00:43:27,900
right you should be able to look at the

00:43:25,420 --> 00:43:27,900
staff face

00:44:02,890 --> 00:44:12,410
and that's I think that's a good example

00:44:09,770 --> 00:44:13,730
of like that the reason those are in

00:44:12,410 --> 00:44:15,920
there has nothing to do with promises

00:44:13,730 --> 00:44:17,420
but the fact that that we had that nice

00:44:15,920 --> 00:44:18,980
design decision makes a little cleaner

00:44:17,420 --> 00:44:20,240
thank you for making me look good

00:44:18,980 --> 00:44:22,720
learning alright there's another

00:44:20,240 --> 00:44:22,720
question over here

00:44:40,160 --> 00:44:45,420
yep and there are I think there are some

00:44:42,600 --> 00:44:48,000
modules in the six ecosystem that take

00:44:45,420 --> 00:44:50,850
advantage of that so I would I would

00:44:48,000 --> 00:44:52,200
start there first but even if it's a if

00:44:50,850 --> 00:44:54,150
it's a message broker that we don't have

00:44:52,200 --> 00:44:57,450
a front end for yes you should be able

00:44:54,150 --> 00:45:00,600
to use those primitives to deal with the

00:44:57,450 --> 00:45:02,700
the library calls directly with that and

00:45:00,600 --> 00:45:10,350
then wrap a supplier or a channel around

00:45:02,700 --> 00:45:12,030
that absolutely any other questions all

00:45:10,350 --> 00:45:14,870
right thank you all for the time I

00:45:12,030 --> 00:45:14,870
really appreciate it

00:45:27,089 --> 00:45:29,150

YouTube URL: https://www.youtube.com/watch?v=moaGidO3eA4


