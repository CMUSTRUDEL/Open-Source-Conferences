Title: Chad Granum - "Better testing with Test2-Suite"
Publication date: 2018-06-20
Playlist: TPC 2018 in SLC
Description: 
	This session will go over the tools of Test2 and Test2::Suite, how they compare to Test::More and similar tools. After this session you should be ready to take full advantage of Test2 for better/faster testing.
Captions: 
	00:00:00,989 --> 00:00:04,830
my slides do not get any bigger so if

00:00:03,389 --> 00:00:07,890
you're having trouble seeing them you

00:00:04,830 --> 00:00:12,000
can follow along you can follow along a

00:00:07,890 --> 00:00:14,580
test - more github do slash test -

00:00:12,000 --> 00:00:16,440
manual - manual

00:00:14,580 --> 00:00:18,210
yeah these slides don't get bigger they

00:00:16,440 --> 00:00:20,730
were made for a an easier to see

00:00:18,210 --> 00:00:24,920
projector screen unfortunately anyway

00:00:20,730 --> 00:00:28,289
I'm Chad random a C Panhandle Exodus and

00:00:24,920 --> 00:00:31,769
I maintained test 2 - simple test

00:00:28,289 --> 00:00:33,960
builder all that good stuff there I've

00:00:31,769 --> 00:00:36,780
been doing that for a few years it's a

00:00:33,960 --> 00:00:38,640
question what is test to test use the

00:00:36,780 --> 00:00:41,370
new framework that replaces test builder

00:00:38,640 --> 00:00:43,260
this was done because test builder was

00:00:41,370 --> 00:00:45,600
really showing its age it had had many

00:00:43,260 --> 00:00:48,989
years without any significant overhauls

00:00:45,600 --> 00:00:51,180
or changes and a lot of things were

00:00:48,989 --> 00:00:52,530
being built to hack around it the

00:00:51,180 --> 00:00:54,239
obvious question from that is what's

00:00:52,530 --> 00:00:57,510
gonna happen with test builder test

00:00:54,239 --> 00:00:59,250
builder for the past two years or so has

00:00:57,510 --> 00:01:01,890
actually just been a compatibility

00:00:59,250 --> 00:01:04,140
wrapper on top of test two so if you

00:01:01,890 --> 00:01:06,090
have a modern install of test simple

00:01:04,140 --> 00:01:08,909
you've been using test to whether you

00:01:06,090 --> 00:01:10,799
knew it or not so let's look at some

00:01:08,909 --> 00:01:13,340
benchmarks these are about two years old

00:01:10,799 --> 00:01:17,159
I did not have a chance to revamp these

00:01:13,340 --> 00:01:20,460
they've probably improved but if you

00:01:17,159 --> 00:01:22,500
look at load times using test two does

00:01:20,460 --> 00:01:24,000
take longer to load than using test

00:01:22,500 --> 00:01:27,360
builder test builder would load and

00:01:24,000 --> 00:01:29,970
point 0 10 and with test 2 you get point

00:01:27,360 --> 00:01:31,740
zero two seven which is about three

00:01:29,970 --> 00:01:34,259
times longer so test two does have a

00:01:31,740 --> 00:01:36,090
longer load time but then you come down

00:01:34,259 --> 00:01:38,490
here and you look at the actual runtime

00:01:36,090 --> 00:01:40,409
performance and test two absolutely

00:01:38,490 --> 00:01:44,369
blows test builder away so the legacy

00:01:40,409 --> 00:01:46,829
test builder to run 100,000 okay's 3.8

00:01:44,369 --> 00:01:48,840
seconds test builder on top of test two

00:01:46,829 --> 00:01:51,329
it's a little bit faster three point

00:01:48,840 --> 00:01:53,549
three seconds if you do just test two

00:01:51,329 --> 00:01:55,350
without actually loading test builder

00:01:53,549 --> 00:01:58,799
that drops down to two point three

00:01:55,350 --> 00:02:01,409
seconds then IPC performance is improved

00:01:58,799 --> 00:02:04,469
as well with test builder you could only

00:02:01,409 --> 00:02:06,270
do threads for IPC running 10,000 or

00:02:04,469 --> 00:02:08,310
100,000 okay's even if you're not

00:02:06,270 --> 00:02:10,890
actually using threads would take longer

00:02:08,310 --> 00:02:13,380
at five point three seconds with test

00:02:10,890 --> 00:02:16,220
builder I mean sorry Ted

00:02:13,380 --> 00:02:19,860
builder on top of test to using IPC it's

00:02:16,220 --> 00:02:22,170
less of a slowdown only 4.2 seconds if

00:02:19,860 --> 00:02:24,330
you use just test 2 without test builder

00:02:22,170 --> 00:02:26,190
and the IPC you're still outperforming

00:02:24,330 --> 00:02:29,580
the original test builder without the

00:02:26,190 --> 00:02:32,940
idea that had IPC loaded or even without

00:02:29,580 --> 00:02:40,980
my PC loaded so test 2 has a much better

00:02:32,940 --> 00:02:43,050
runtime performance and you do so yes if

00:02:40,980 --> 00:02:45,480
you have a test suite where each file

00:02:43,050 --> 00:02:47,340
takes a long time to run test 2 is going

00:02:45,480 --> 00:02:49,080
to be much faster if you have a large

00:02:47,340 --> 00:02:52,500
test suite where each file goes really

00:02:49,080 --> 00:02:54,900
quick test 2 will be slower but it tends

00:02:52,500 --> 00:02:56,520
to balance out like the Pearl 5 test

00:02:54,900 --> 00:03:01,410
suite itself takes about the same amount

00:02:56,520 --> 00:03:03,150
of time so this talk is for all levels

00:03:01,410 --> 00:03:05,460
so I'm going to actually start off with

00:03:03,150 --> 00:03:06,990
a basic testing tutorial using test 2

00:03:05,460 --> 00:03:09,270
but then we're gonna get on to some more

00:03:06,990 --> 00:03:11,190
advanced things before I begin how many

00:03:09,270 --> 00:03:14,700
people in here have used testing tools

00:03:11,190 --> 00:03:19,230
like test more ok pretty much everyone

00:03:14,700 --> 00:03:20,820
who here has used test 2 directly it's

00:03:19,230 --> 00:03:23,250
still quite a few but not everybody ok

00:03:20,820 --> 00:03:26,940
so this tutorial is a bootstrap into

00:03:23,250 --> 00:03:28,980
testing using test 2 first the

00:03:26,940 --> 00:03:30,750
boilerplate if you're starting a test

00:03:28,980 --> 00:03:33,360
with test 2 instead of using test more

00:03:30,750 --> 00:03:36,300
or any of those you just use test 2 : :

00:03:33,360 --> 00:03:38,160
V 0 this is a testing bundle that is my

00:03:36,300 --> 00:03:40,470
recommendation for what you should use

00:03:38,160 --> 00:03:42,120
for testing and as more people are

00:03:40,470 --> 00:03:43,530
involved in test two this won't just be

00:03:42,120 --> 00:03:47,400
my recommendation it'll be the

00:03:43,530 --> 00:03:49,260
communities so it loads several things

00:03:47,400 --> 00:03:51,810
which I'll be showing on other slides

00:03:49,260 --> 00:03:53,880
it's the first thing with testing is

00:03:51,810 --> 00:03:55,350
that you need a plan and a plan is

00:03:53,880 --> 00:03:58,860
important because it ensures all test

00:03:55,350 --> 00:04:02,130
runs or all tests run one of the big

00:03:58,860 --> 00:04:04,470
issues that plans solve is sometimes you

00:04:02,130 --> 00:04:07,050
might call a function that will exit 0

00:04:04,470 --> 00:04:08,520
and your harness will go it exited 0

00:04:07,050 --> 00:04:11,190
it's all good even though the rest of

00:04:08,520 --> 00:04:13,350
your tests haven't actually run and that

00:04:11,190 --> 00:04:16,020
is the situation a plan is intended to

00:04:13,350 --> 00:04:19,290
prevent there's a couple of ways to plan

00:04:16,020 --> 00:04:21,359
there's the old style that tests more

00:04:19,290 --> 00:04:22,800
used to recommend where you just give a

00:04:21,359 --> 00:04:25,110
static number and say this is how many

00:04:22,800 --> 00:04:25,950
tests are going to run in test 2 that's

00:04:25,110 --> 00:04:29,640
done with the

00:04:25,950 --> 00:04:33,030
plan function as opposed to an import

00:04:29,640 --> 00:04:36,330
argument there's a lot of reasons for

00:04:33,030 --> 00:04:38,580
that it's it's a bit easier but planning

00:04:36,330 --> 00:04:40,050
by typing at a static number is annoying

00:04:38,580 --> 00:04:42,000
you have to maintain that number every

00:04:40,050 --> 00:04:44,490
time you change your test file and if

00:04:42,000 --> 00:04:46,710
your tests are somehow a random number

00:04:44,490 --> 00:04:48,240
of tests because of various data you

00:04:46,710 --> 00:04:52,290
might not even know what your expected

00:04:48,240 --> 00:04:53,820
tests are so come to fix that while back

00:04:52,290 --> 00:04:55,650
test simple introduced to the done

00:04:53,820 --> 00:04:57,360
testing function which you call at the

00:04:55,650 --> 00:05:00,120
end of your tests and it will output the

00:04:57,360 --> 00:05:01,860
plan at the very end and if something

00:05:00,120 --> 00:05:04,110
exits early you'll never hit it the plan

00:05:01,860 --> 00:05:05,640
will never be output and it still solves

00:05:04,110 --> 00:05:09,150
the problem to let you know you did not

00:05:05,640 --> 00:05:11,250
run all your tests another way to plan

00:05:09,150 --> 00:05:12,960
is to say hey I can't actually run this

00:05:11,250 --> 00:05:14,490
test right now such as if your test

00:05:12,960 --> 00:05:17,250
won't run on Windows you can do this a

00:05:14,490 --> 00:05:18,930
first example here where you just skip

00:05:17,250 --> 00:05:21,840
all the tests if you're running on

00:05:18,930 --> 00:05:22,920
Windows or if you're really crazy you

00:05:21,840 --> 00:05:25,020
can have a test that can't run on

00:05:22,920 --> 00:05:27,420
Tuesdays so you can skip all if today

00:05:25,020 --> 00:05:31,760
happens to be a Tuesday I don't

00:05:27,420 --> 00:05:31,760
recommend that that that's code smell

00:05:33,230 --> 00:05:39,690
there we go so assertions

00:05:38,490 --> 00:05:41,820
if you're writing tests you're gonna

00:05:39,690 --> 00:05:44,940
wanna write assertions the most basic

00:05:41,820 --> 00:05:46,230
assertion tool is okay I'm pretty sure

00:05:44,940 --> 00:05:47,850
everyone in this room already knows how

00:05:46,230 --> 00:05:49,680
this works but you give it a boolean

00:05:47,850 --> 00:05:53,940
value and a name and it's either pass or

00:05:49,680 --> 00:05:55,380
fail moving on comparisons so everyone

00:05:53,940 --> 00:05:57,120
who's used test more is also familiar

00:05:55,380 --> 00:06:02,010
with is where you can do a string

00:05:57,120 --> 00:06:03,870
compare with tests to is has now been or

00:06:02,010 --> 00:06:06,720
start is deeply has now been replaced by

00:06:03,870 --> 00:06:09,150
is as well so you only call is you don't

00:06:06,720 --> 00:06:10,650
call as deeply you can pass it deep data

00:06:09,150 --> 00:06:13,020
structures like that we're comparing two

00:06:10,650 --> 00:06:15,540
arrays you can go even deeper and just

00:06:13,020 --> 00:06:18,300
compare two data structures infinitely

00:06:15,540 --> 00:06:20,850
deep and overloading is handled by

00:06:18,300 --> 00:06:22,980
having the right hand-side to determine

00:06:20,850 --> 00:06:24,510
what type of comparison will be used so

00:06:22,980 --> 00:06:26,970
in this case we've passed in an object

00:06:24,510 --> 00:06:29,640
as what we got and a string is what we

00:06:26,970 --> 00:06:31,290
want so what's gonna happen is under the

00:06:29,640 --> 00:06:32,700
hood it's gonna use a string compare

00:06:31,290 --> 00:06:34,380
which means if overloading was done

00:06:32,700 --> 00:06:35,940
properly this will just work if it

00:06:34,380 --> 00:06:38,039
wasn't you're gonna get a string compare

00:06:35,940 --> 00:06:42,840
against the objects memory address

00:06:38,039 --> 00:06:44,160
which hopefully will be an error so yeah

00:06:42,840 --> 00:06:45,900
right hand side defining what the

00:06:44,160 --> 00:06:48,300
comparison will be solves a lot of the

00:06:45,900 --> 00:06:54,870
problems that initially required is and

00:06:48,300 --> 00:06:57,479
is deeply to be separate it doesn't

00:06:54,870 --> 00:06:59,460
it'll be for scalars it always uses

00:06:57,479 --> 00:07:01,139
string compare unless you ask it for a

00:06:59,460 --> 00:07:03,120
numerical compare trying to guess

00:07:01,139 --> 00:07:07,500
between a string or a number is just

00:07:03,120 --> 00:07:11,039
batshit crazy and pearl so like is also

00:07:07,500 --> 00:07:13,139
now a deep comparison tool so you can do

00:07:11,039 --> 00:07:14,789
your standard like and string and a

00:07:13,139 --> 00:07:17,370
regular expression works just like you'd

00:07:14,789 --> 00:07:20,099
expect you can also do a like on a deep

00:07:17,370 --> 00:07:22,470
structure a like comparison is different

00:07:20,099 --> 00:07:25,740
than an is comparison in that it is

00:07:22,470 --> 00:07:27,990
relaxed it'll only care about the things

00:07:25,740 --> 00:07:29,669
you ask it to care about so if you do a

00:07:27,990 --> 00:07:31,710
deep comparison of an array with four

00:07:29,669 --> 00:07:33,479
items in an array of two items it'll

00:07:31,710 --> 00:07:34,979
only check the two items it gave you and

00:07:33,479 --> 00:07:36,389
it won't care that there's extra items

00:07:34,979 --> 00:07:39,270
in there

00:07:36,389 --> 00:07:41,849
you can also deeply embed regular

00:07:39,270 --> 00:07:43,620
expressions in your comparison and it'll

00:07:41,849 --> 00:07:48,750
just automatically treat those as hey I

00:07:43,620 --> 00:07:51,479
need to match against this and yeah and

00:07:48,750 --> 00:07:55,380
once again right hand side defines what

00:07:51,479 --> 00:07:58,020
type of comparison it'll be there's a

00:07:55,380 --> 00:08:01,470
DSL that will help you to define these

00:07:58,020 --> 00:08:03,360
checks and provides extra benefit of

00:08:01,470 --> 00:08:05,039
giving you the line number of the actual

00:08:03,360 --> 00:08:07,169
element in your deep structure that

00:08:05,039 --> 00:08:09,479
failed so for instance here we've got

00:08:07,169 --> 00:08:11,340
what we're checking again or you know

00:08:09,479 --> 00:08:13,229
what we received and want to check we're

00:08:11,340 --> 00:08:14,880
saying hey first item should be an

00:08:13,229 --> 00:08:17,400
excerpt this is an array first item

00:08:14,880 --> 00:08:19,979
should be X second Y third is a hash

00:08:17,400 --> 00:08:22,409
it's got the field foo it's got yikes

00:08:19,979 --> 00:08:24,270
in this case DNA means does not exist so

00:08:22,409 --> 00:08:27,389
we're checking that the field yikes does

00:08:24,270 --> 00:08:29,610
not exist and then end to say hey there

00:08:27,389 --> 00:08:30,599
are no other fields in this hash I we

00:08:29,610 --> 00:08:31,949
could do the same at the end of the

00:08:30,599 --> 00:08:34,560
array and say no more fields in this

00:08:31,949 --> 00:08:38,430
array but we're using an is comparison

00:08:34,560 --> 00:08:41,279
so the end is implicit so and obviously

00:08:38,430 --> 00:08:44,250
this is going to fail absolutely nothing

00:08:41,279 --> 00:08:46,230
in our array here matches our check this

00:08:44,250 --> 00:08:49,200
is the Diagnostics you get when you use

00:08:46,230 --> 00:08:51,240
this it tells us that we got an array so

00:08:49,200 --> 00:08:53,010
that expectation was met

00:08:51,240 --> 00:08:56,160
that within that array the first item

00:08:53,010 --> 00:08:58,620
did not match a is not X and it tells us

00:08:56,160 --> 00:09:00,899
what operation it used it tried to use

00:08:58,620 --> 00:09:03,690
the string equality operation same with

00:09:00,899 --> 00:09:06,510
B not being Y we did find a hash so that

00:09:03,690 --> 00:09:09,810
expectation was met but then the things

00:09:06,510 --> 00:09:12,089
inside just bit didn't work out and we

00:09:09,810 --> 00:09:14,399
get the line numbers on which these

00:09:12,089 --> 00:09:16,110
checks were defined so you don't have to

00:09:14,399 --> 00:09:19,940
go and figure out where in your deeply

00:09:16,110 --> 00:09:23,339
nested structure those definitions were

00:09:19,940 --> 00:09:25,470
this right here is the big thing with

00:09:23,339 --> 00:09:32,490
test two these Diagnostics let me tell

00:09:25,470 --> 00:09:34,020
you thank you so to do works a bit

00:09:32,490 --> 00:09:36,000
differently than it did with test more

00:09:34,020 --> 00:09:37,160
you don't have to localize a global

00:09:36,000 --> 00:09:39,660
variable anymore

00:09:37,160 --> 00:09:42,149
so there's if there's two ways to do it

00:09:39,660 --> 00:09:44,190
there's the new style where you call the

00:09:42,149 --> 00:09:46,290
to do function with your reason and pass

00:09:44,190 --> 00:09:47,970
in a subroutine and then anything inside

00:09:46,290 --> 00:09:51,240
that subroutine falls under the scope of

00:09:47,970 --> 00:09:52,890
the to do obviously that does inject a

00:09:51,240 --> 00:09:55,500
new stack frame so if you're testing

00:09:52,890 --> 00:09:57,329
deep exceptions or warnings that might

00:09:55,500 --> 00:10:00,540
cause issues so there's still legacy

00:09:57,329 --> 00:10:02,820
style to do where you just create your

00:10:00,540 --> 00:10:05,459
own variable not a look not a global one

00:10:02,820 --> 00:10:07,890
and assign the return of to do without

00:10:05,459 --> 00:10:10,320
passing it a sub ref and then that to do

00:10:07,890 --> 00:10:12,450
will remain in effect until that

00:10:10,320 --> 00:10:14,700
variable is destroyed once it's garbage

00:10:12,450 --> 00:10:16,680
collected the to do state ends so it

00:10:14,700 --> 00:10:19,079
works a lot like the local to do from

00:10:16,680 --> 00:10:23,760
test more except it's not super crazy

00:10:19,079 --> 00:10:25,529
magical with global variables so if

00:10:23,760 --> 00:10:27,300
you're using test two you're gonna need

00:10:25,529 --> 00:10:30,570
to list your dependencies in your build

00:10:27,300 --> 00:10:31,500
tools it's very important that you list

00:10:30,570 --> 00:10:34,740
them properly

00:10:31,500 --> 00:10:38,459
you don't want to just list the basic

00:10:34,740 --> 00:10:40,440
tests to module or test to suite which

00:10:38,459 --> 00:10:43,260
is where most of these tools live what

00:10:40,440 --> 00:10:47,420
you should actually list is which bundle

00:10:43,260 --> 00:10:50,910
you are using in our case test 2 : : v-0

00:10:47,420 --> 00:10:52,079
that way if we later want to upgrade and

00:10:50,910 --> 00:10:55,410
make some changes because something

00:10:52,079 --> 00:10:58,410
wasn't right we'll release test 2 : : v1

00:10:55,410 --> 00:11:00,000
you new test you'd start using v1 but

00:10:58,410 --> 00:11:01,470
your old tests won't break from the

00:11:00,000 --> 00:11:03,779
incompatibility because they're still

00:11:01,470 --> 00:11:05,100
using v-0 and if at some point we want

00:11:03,779 --> 00:11:07,110
to split those distribution

00:11:05,100 --> 00:11:09,420
having required the correct version

00:11:07,110 --> 00:11:11,970
means it will be transparent to you that

00:11:09,420 --> 00:11:15,390
those are now separate distributions so

00:11:11,970 --> 00:11:17,070
for the Dilla the correct the wrong way

00:11:15,390 --> 00:11:18,990
would be to list test to suite the

00:11:17,070 --> 00:11:21,660
correct way would be to list test to

00:11:18,990 --> 00:11:23,670
suite v-0 make maker it's very similar

00:11:21,660 --> 00:11:27,870
here's the wrong way and here's the

00:11:23,670 --> 00:11:28,920
correct way so now what next is what

00:11:27,870 --> 00:11:31,170
we're going to go to this is also

00:11:28,920 --> 00:11:32,790
available online as a self a taught

00:11:31,170 --> 00:11:35,220
thing which is why the what's next is

00:11:32,790 --> 00:11:38,790
here so I'm just gonna skip that so

00:11:35,220 --> 00:11:40,470
tools test to define several namespaces

00:11:38,790 --> 00:11:43,470
the primary one you're gonna be working

00:11:40,470 --> 00:11:45,720
with is test two tools and things that

00:11:43,470 --> 00:11:47,610
live underneath that tool is any

00:11:45,720 --> 00:11:50,220
function that produces testing events

00:11:47,610 --> 00:11:52,080
and events are generated whenever you

00:11:50,220 --> 00:11:55,200
make assertions that a plan produce

00:11:52,080 --> 00:11:56,670
diagnostics anything like that and they

00:11:55,200 --> 00:11:59,340
like I already said they live in the

00:11:56,670 --> 00:12:02,940
test to tools namespace basic set of

00:11:59,340 --> 00:12:04,740
tools are your typical okay diag to do

00:12:02,940 --> 00:12:07,080
plan all the things we've covered

00:12:04,740 --> 00:12:08,580
there's also pass and fail which tests

00:12:07,080 --> 00:12:10,770
to had though many people didn't use

00:12:08,580 --> 00:12:12,270
them and they work just like I've gone

00:12:10,770 --> 00:12:15,060
over in the previous slides pretty

00:12:12,270 --> 00:12:17,580
simple there there are also tools for

00:12:15,060 --> 00:12:20,910
classes some of these you'll be familiar

00:12:17,580 --> 00:12:23,850
with except they have changed in test

00:12:20,910 --> 00:12:26,540
more is it okay and can okay looked like

00:12:23,850 --> 00:12:30,840
they were used the same but they weren't

00:12:26,540 --> 00:12:32,940
is ax okay would take for its first

00:12:30,840 --> 00:12:33,420
argument something to check its second

00:12:32,940 --> 00:12:35,160
argument

00:12:33,420 --> 00:12:36,900
something to check against and then the

00:12:35,160 --> 00:12:39,330
third argument was an alternate name for

00:12:36,900 --> 00:12:41,430
the first it was not a second class to

00:12:39,330 --> 00:12:45,570
check if you've ever done that you have

00:12:41,430 --> 00:12:46,920
bugs in your test suite can okay was

00:12:45,570 --> 00:12:47,310
totally different even though it looked

00:12:46,920 --> 00:12:49,860
the same

00:12:47,310 --> 00:12:51,990
it took something to check and then a

00:12:49,860 --> 00:12:54,390
whole list of things to check that it

00:12:51,990 --> 00:12:56,370
could do so they didn't match at all in

00:12:54,390 --> 00:12:58,680
test two they have the exact same

00:12:56,370 --> 00:13:00,480
signature so you don't make it make that

00:12:58,680 --> 00:13:02,430
mistake first ones the thing to check

00:13:00,480 --> 00:13:04,500
and all other arguments are the thing to

00:13:02,430 --> 00:13:06,300
check against though recently there was

00:13:04,500 --> 00:13:08,130
a pull request so there's a new behavior

00:13:06,300 --> 00:13:10,260
where if the second argument is an array

00:13:08,130 --> 00:13:12,270
it will use that as a list of things to

00:13:10,260 --> 00:13:15,240
check and then the third argument is

00:13:12,270 --> 00:13:17,740
your test name which is a much requested

00:13:15,240 --> 00:13:22,450
feature that's pretty good

00:13:17,740 --> 00:13:25,600
new comparisons we'll get to later I

00:13:22,450 --> 00:13:27,970
have moved that slide so test two tools

00:13:25,600 --> 00:13:30,190
defer this is one that you almost never

00:13:27,970 --> 00:13:32,740
need but when you need it you really

00:13:30,190 --> 00:13:35,200
need it this happens if you are making

00:13:32,740 --> 00:13:37,750
your own test two tools that you want to

00:13:35,200 --> 00:13:39,970
test or plugins maybe that you want to

00:13:37,750 --> 00:13:42,070
test and so you need to verify some

00:13:39,970 --> 00:13:43,300
behavior before test two is actually

00:13:42,070 --> 00:13:45,990
even loaded

00:13:43,300 --> 00:13:48,550
test two tools defer lets you define

00:13:45,990 --> 00:13:50,170
some tests that will happen and when you

00:13:48,550 --> 00:13:52,330
do it will capture all those arguments

00:13:50,170 --> 00:13:54,820
but it won't actually run any tests to

00:13:52,330 --> 00:13:58,090
logic yet then later on after you've

00:13:54,820 --> 00:13:59,560
loaded test two you run do death and it

00:13:58,090 --> 00:14:01,330
will actually make all those comparisons

00:13:59,560 --> 00:14:04,750
happen against the arguments it

00:14:01,330 --> 00:14:07,810
previously captured most of you I'll

00:14:04,750 --> 00:14:15,850
probably never need this but it's useful

00:14:07,810 --> 00:14:20,050
when you do encoding what was that just

00:14:15,850 --> 00:14:21,730
something I picked so encoding if any of

00:14:20,050 --> 00:14:24,430
you have ever tried to change the

00:14:21,730 --> 00:14:27,580
encoding when using test more you know

00:14:24,430 --> 00:14:30,580
that it is a royal pain in the ass you

00:14:27,580 --> 00:14:32,170
have to modify your global file handles

00:14:30,580 --> 00:14:34,270
you have to modify the global handles

00:14:32,170 --> 00:14:36,580
that test to conveniently copied for you

00:14:34,270 --> 00:14:38,830
in advance and you have to do it all

00:14:36,580 --> 00:14:42,280
through a bunch of roundabout tests a

00:14:38,830 --> 00:14:44,230
simple way tour test more ways and it

00:14:42,280 --> 00:14:45,670
quickly becomes a nightmare especially

00:14:44,230 --> 00:14:47,290
if you then go into sub tests where they

00:14:45,670 --> 00:14:50,650
might have completely different file

00:14:47,290 --> 00:14:53,440
handles with test two this is simple you

00:14:50,650 --> 00:14:55,870
load test to tools encoding set encoding

00:14:53,440 --> 00:14:58,680
and give it your encoding and it'll work

00:14:55,870 --> 00:15:01,270
and everything will have that encoding

00:14:58,680 --> 00:15:05,410
it was very hard in test builder let me

00:15:01,270 --> 00:15:07,330
tell you exceptions so test tool has a

00:15:05,410 --> 00:15:09,850
tool similar to what test fatal provides

00:15:07,330 --> 00:15:12,820
except it does a lot less for you that

00:15:09,850 --> 00:15:15,370
is by design so if anyone here has used

00:15:12,820 --> 00:15:18,190
test exception you know that it can

00:15:15,370 --> 00:15:20,620
accidentally match against a stack trace

00:15:18,190 --> 00:15:22,990
because your arguments to the test tool

00:15:20,620 --> 00:15:25,270
itself will be in the stack trace there

00:15:22,990 --> 00:15:27,100
is a lot of magic put in place to try

00:15:25,270 --> 00:15:29,020
and prevent that but that magic

00:15:27,100 --> 00:15:31,180
sometimes causes its own errors such as

00:15:29,020 --> 00:15:33,850
a bizarre copy of array at

00:15:31,180 --> 00:15:35,590
online you didn't even know existed so

00:15:33,850 --> 00:15:37,090
the new standard is to use something

00:15:35,590 --> 00:15:39,280
that will capture the exception and

00:15:37,090 --> 00:15:41,770
return it and then test against that

00:15:39,280 --> 00:15:44,320
returned exception it's slightly more

00:15:41,770 --> 00:15:46,450
verbose but it is a lot safer

00:15:44,320 --> 00:15:48,250
there's also lives which just you know

00:15:46,450 --> 00:15:49,830
returns true if you didn't throw an

00:15:48,250 --> 00:15:52,540
exception

00:15:49,830 --> 00:15:56,170
you can test exports this is a new tool

00:15:52,540 --> 00:15:58,240
that was not in test test more you can

00:15:56,170 --> 00:15:59,770
type import it okay and then a list of

00:15:58,240 --> 00:16:01,810
things and it'll verify that those were

00:15:59,770 --> 00:16:04,470
imported into your namespace which means

00:16:01,810 --> 00:16:06,400
it checks that they are defined and

00:16:04,470 --> 00:16:07,810
that's pretty much it checks that

00:16:06,400 --> 00:16:10,030
they're defined in the current namespace

00:16:07,810 --> 00:16:12,370
this is not inheritance though if you're

00:16:10,030 --> 00:16:14,290
a subclass of another class it will not

00:16:12,370 --> 00:16:15,850
check if the parent class can do it so

00:16:14,290 --> 00:16:17,650
you have to actually have them in your

00:16:15,850 --> 00:16:19,300
namespace for it to work there's also

00:16:17,650 --> 00:16:22,780
not imported ok if you want to make sure

00:16:19,300 --> 00:16:25,180
they're not in your namespace checking

00:16:22,780 --> 00:16:27,520
references there's a few new tools

00:16:25,180 --> 00:16:29,770
there's ref ok which verifies something

00:16:27,520 --> 00:16:31,450
as a reference you can also pass it a

00:16:29,770 --> 00:16:33,370
second and third argument to say hey

00:16:31,450 --> 00:16:37,060
make sure this is a ref and that it's an

00:16:33,370 --> 00:16:39,490
array R if you can also do ref is to

00:16:37,060 --> 00:16:43,750
check that two refs are pointing at the

00:16:39,490 --> 00:16:45,220
same thing then ref is not is the

00:16:43,750 --> 00:16:47,860
opposite make sure these are not the

00:16:45,220 --> 00:16:49,960
same ref that's important because of the

00:16:47,860 --> 00:16:51,490
changes to is where you can't just give

00:16:49,960 --> 00:16:53,620
it the same ref twice because it'll do a

00:16:51,490 --> 00:16:57,550
deep comparison instead of a check that

00:16:53,620 --> 00:17:00,010
they're the same memory address subtests

00:16:57,550 --> 00:17:02,710
there's a new way for sub tests to work

00:17:00,010 --> 00:17:05,740
the default now is a buffered sub test

00:17:02,710 --> 00:17:07,840
which will not produce any output until

00:17:05,740 --> 00:17:10,570
the sub test is done and it looks like

00:17:07,840 --> 00:17:12,880
this it's got these brackets and the

00:17:10,570 --> 00:17:14,800
primary assertion comes first this is

00:17:12,880 --> 00:17:16,630
done because there is concurrency in

00:17:14,800 --> 00:17:19,030
test two you might be running multiple

00:17:16,630 --> 00:17:20,770
sub tests at once and when that happens

00:17:19,030 --> 00:17:23,170
you don't want their output to be all

00:17:20,770 --> 00:17:25,810
MUX together so buffered sub tests solve

00:17:23,170 --> 00:17:28,030
that problem you can still use the old

00:17:25,810 --> 00:17:30,430
style which is now called streamed using

00:17:28,030 --> 00:17:33,190
sub test streamed and that will output

00:17:30,430 --> 00:17:35,710
the traditional sub test output test

00:17:33,190 --> 00:17:38,560
more if you're using that will still

00:17:35,710 --> 00:17:39,790
default to the old-style sub test for

00:17:38,560 --> 00:17:41,690
compatibility

00:17:39,790 --> 00:17:43,130
warnings there's tools to help you

00:17:41,690 --> 00:17:44,600
capture warnings it's similar to the

00:17:43,130 --> 00:17:46,160
dyes except there's more of them there's

00:17:44,600 --> 00:17:48,590
warns which just returns how many

00:17:46,160 --> 00:17:51,260
warnings you got no warnings to make

00:17:48,590 --> 00:17:54,020
sure code didn't warn warning to capture

00:17:51,260 --> 00:17:56,720
the actual single warning or warnings to

00:17:54,020 --> 00:17:58,640
capture all the warnings it's a bunch of

00:17:56,720 --> 00:18:01,250
tools that are quite handy when you

00:17:58,640 --> 00:18:02,930
actually need them any questions about

00:18:01,250 --> 00:18:08,320
any of these tools before I move on to

00:18:02,930 --> 00:18:11,540
compare cool so test 2 tools compare is

00:18:08,320 --> 00:18:14,030
where all that really nice stuff you saw

00:18:11,540 --> 00:18:17,420
a couple slides back is defined with all

00:18:14,030 --> 00:18:19,400
the good diagnostics and it provides

00:18:17,420 --> 00:18:22,070
quite a few tools there's is there's

00:18:19,400 --> 00:18:23,390
like there's isn't and unlike and then

00:18:22,070 --> 00:18:24,950
there's a bunch of helpers match

00:18:23,390 --> 00:18:27,890
mismatched validator I'm going to get

00:18:24,950 --> 00:18:29,330
into all these in later slides and we've

00:18:27,890 --> 00:18:33,080
already covered how to use this I'm

00:18:29,330 --> 00:18:34,430
gonna move on so simple state checks you

00:18:33,080 --> 00:18:35,930
can check that something is true

00:18:34,430 --> 00:18:38,120
something is false

00:18:35,930 --> 00:18:40,610
something is defined something does not

00:18:38,120 --> 00:18:43,730
exist or something as false or doesn't

00:18:40,610 --> 00:18:46,460
exist you don't care that really that's

00:18:43,730 --> 00:18:48,560
really helpful when you when you really

00:18:46,460 --> 00:18:51,470
don't care you you want this field to be

00:18:48,560 --> 00:18:53,330
false or not exist you don't care which

00:18:51,470 --> 00:18:55,070
so just false or does not exist you

00:18:53,330 --> 00:18:57,560
don't have to modify it to make sure

00:18:55,070 --> 00:18:59,270
it's the right version of false because

00:18:57,560 --> 00:19:03,640
pearl has a lot of falses and a lot of

00:18:59,270 --> 00:19:06,860
throughs so you got true/false doesn't

00:19:03,640 --> 00:19:07,550
yeah that should be e I think yeah

00:19:06,860 --> 00:19:09,620
whatever

00:19:07,550 --> 00:19:12,860
moving on sorry I've got a cold and my

00:19:09,620 --> 00:19:15,350
head's a little foggy right now so you

00:19:12,860 --> 00:19:17,540
have you can do directed checks to

00:19:15,350 --> 00:19:19,310
actually have deeper control so normally

00:19:17,540 --> 00:19:21,470
you'd use like to use a regular

00:19:19,310 --> 00:19:23,810
expression on your right hand side but

00:19:21,470 --> 00:19:26,450
if you really want one in a stricter

00:19:23,810 --> 00:19:29,930
checked such as is you can do is Fuu

00:19:26,450 --> 00:19:31,610
match against a reg X or mismatch if you

00:19:29,930 --> 00:19:33,770
don't want it to match that reg X and

00:19:31,610 --> 00:19:35,870
someone earlier asked about checking

00:19:33,770 --> 00:19:38,120
whether it's numerical or string it

00:19:35,870 --> 00:19:39,770
defaults to a string compare for sanity

00:19:38,120 --> 00:19:43,280
but if you really want to check it

00:19:39,770 --> 00:19:44,690
numerical value you new is 1200 verify

00:19:43,280 --> 00:19:47,360
it's the number 12 it's just going to

00:19:44,690 --> 00:19:49,160
use a numeric comparison so those will

00:19:47,360 --> 00:19:51,230
be equal even though the decimals are

00:19:49,160 --> 00:19:53,180
different so you can do a numeric check

00:19:51,230 --> 00:19:55,130
but you have to be explicit about it

00:19:53,180 --> 00:19:58,510
you can also be explicit about a string

00:19:55,130 --> 00:20:00,980
check but that's usually redundant and

00:19:58,510 --> 00:20:02,840
you can also check that something nested

00:20:00,980 --> 00:20:08,270
in a structure is the exact ref you're

00:20:02,840 --> 00:20:10,220
looking for you can do custom validators

00:20:08,270 --> 00:20:11,870
they're complicated I want to simplify

00:20:10,220 --> 00:20:14,120
them so I'm not going to spend a lot of

00:20:11,870 --> 00:20:16,640
time here but it lets you create your

00:20:14,120 --> 00:20:19,700
own version of say exists or does not

00:20:16,640 --> 00:20:25,100
exist or is this an object I think it

00:20:19,700 --> 00:20:29,150
should be sets is Apple in the set pair

00:20:25,100 --> 00:20:32,300
apple or orange yes it is there's also

00:20:29,150 --> 00:20:35,120
not in set make sure that Apple is not

00:20:32,300 --> 00:20:38,300
in this set I've checked it out that the

00:20:35,120 --> 00:20:40,160
value matches all of the checks so Apple

00:20:38,300 --> 00:20:41,810
has two peas so it matches that red X

00:20:40,160 --> 00:20:44,360
and it has an A so it matches that red X

00:20:41,810 --> 00:20:48,350
this lets you do some really complex

00:20:44,360 --> 00:20:49,790
checks on a single line there array

00:20:48,350 --> 00:20:52,220
checks I've already shown you one

00:20:49,790 --> 00:20:53,960
example of this you define an array if a

00:20:52,220 --> 00:20:56,120
code block and you give it each item and

00:20:53,960 --> 00:20:59,920
then and when you're done if you want it

00:20:56,120 --> 00:21:04,730
to end is implicit with is checks it is

00:20:59,920 --> 00:21:06,770
but it is not with like checks so that's

00:21:04,730 --> 00:21:10,490
a little complicated but once you figure

00:21:06,770 --> 00:21:12,680
it out it's really useful then you can

00:21:10,490 --> 00:21:15,620
also specify a specific index so here

00:21:12,680 --> 00:21:18,740
we're saying item 0 should be flu item

00:21:15,620 --> 00:21:21,200
two should match this reg X or 0 & 1 and

00:21:18,740 --> 00:21:22,910
then item 3 we're skipping item 2 we

00:21:21,200 --> 00:21:26,660
just don't care about item 2 but item

00:21:22,910 --> 00:21:29,180
free should be bet then here's a

00:21:26,660 --> 00:21:33,350
Diagnostics to show just how much detail

00:21:29,180 --> 00:21:36,380
you get when that fails hash is very

00:21:33,350 --> 00:21:38,750
similar except to use field instead of

00:21:36,380 --> 00:21:42,500
item and it takes a key and a value pair

00:21:38,750 --> 00:21:46,040
and once again really nice Diagnostics

00:21:42,500 --> 00:21:48,890
here meta checks is a prime really

00:21:46,040 --> 00:21:50,360
useful to you can do meta a data about

00:21:48,890 --> 00:21:52,820
the thing check that the property is

00:21:50,360 --> 00:21:54,920
that it is blessed to this class that it

00:21:52,820 --> 00:21:57,200
has this ref type that it is of this

00:21:54,920 --> 00:21:58,970
size so if it's an array it's the size

00:21:57,200 --> 00:22:01,640
of the array if it's a hash it's how

00:21:58,970 --> 00:22:03,170
many keys are in the hash this is a

00:22:01,640 --> 00:22:04,550
reference to the thing again so you

00:22:03,170 --> 00:22:06,419
could nest this again and do another

00:22:04,550 --> 00:22:11,580
meta check or an object check or a hat

00:22:06,419 --> 00:22:12,929
check then object checks very similar

00:22:11,580 --> 00:22:14,759
we're passing in a blessed thing we got

00:22:12,929 --> 00:22:17,249
the object with an object check you can

00:22:14,759 --> 00:22:19,049
use meta properties such as prop you can

00:22:17,249 --> 00:22:20,519
use field if it's a hash reference or

00:22:19,049 --> 00:22:23,039
you can use item if you've blessed an

00:22:20,519 --> 00:22:25,080
array reference or you can even call a

00:22:23,039 --> 00:22:27,090
specific method against the object and

00:22:25,080 --> 00:22:29,460
check the result or pass in an anonymous

00:22:27,090 --> 00:22:30,600
sub to call against the object which is

00:22:29,460 --> 00:22:32,070
what you might want to do if you've got

00:22:30,600 --> 00:22:34,379
a method that you want to check that

00:22:32,070 --> 00:22:38,340
returns a list so you can wrap it in an

00:22:34,379 --> 00:22:51,119
array any questions about the comparison

00:22:38,340 --> 00:22:52,379
tools yes so there's it's not on my

00:22:51,119 --> 00:22:54,480
slides because it's fairly new but

00:22:52,379 --> 00:22:56,279
someone gave me a pull request that's

00:22:54,480 --> 00:22:59,369
been merged for a few months now that

00:22:56,279 --> 00:23:00,509
has the bag check as well it's like an

00:22:59,369 --> 00:23:02,639
array check where you don't care about

00:23:00,509 --> 00:23:05,759
the order it has some of the same flaws

00:23:02,639 --> 00:23:07,710
that test deeps bag did apparently so

00:23:05,759 --> 00:23:09,899
those some of those need to be fixed but

00:23:07,710 --> 00:23:12,659
they have not yet but for most cases it

00:23:09,899 --> 00:23:16,799
will work any other questions about

00:23:12,659 --> 00:23:20,669
comparisons okay moving right along to

00:23:16,799 --> 00:23:22,830
plugins so with test builder everything

00:23:20,669 --> 00:23:25,109
basically got under the test namespace

00:23:22,830 --> 00:23:28,289
so you'd have tests deep test exception

00:23:25,109 --> 00:23:30,149
tests warnings tests - we noticed that

00:23:28,289 --> 00:23:33,119
there's actually a few different

00:23:30,149 --> 00:23:36,299
categories of testing tools there are

00:23:33,119 --> 00:23:37,919
testing modules there's the tools like I

00:23:36,299 --> 00:23:40,649
just showed you but sometimes there's

00:23:37,919 --> 00:23:43,019
things that affect behavior for those we

00:23:40,649 --> 00:23:45,090
have plugins and tests - so you got

00:23:43,019 --> 00:23:46,769
tests to plug in and then what your

00:23:45,090 --> 00:23:48,359
plug-in does so I'm going to give you a

00:23:46,769 --> 00:23:51,480
couple examples of plugins that come

00:23:48,359 --> 00:23:53,609
with tests - sweet bail on fail this is

00:23:51,480 --> 00:23:56,369
one of the most requested features for

00:23:53,609 --> 00:23:58,529
years with test builder and it could not

00:23:56,369 --> 00:24:00,539
be implemented with test builder what

00:23:58,529 --> 00:24:03,029
this is is as soon as the first

00:24:00,539 --> 00:24:06,960
assertion fails you bail out so that all

00:24:03,029 --> 00:24:08,940
testing stops that was difficult with

00:24:06,960 --> 00:24:11,820
test builder because your Diagnostics

00:24:08,940 --> 00:24:13,559
were a separate call from your assertion

00:24:11,820 --> 00:24:15,629
so if you bailed right after the

00:24:13,559 --> 00:24:18,450
assertion failed you wouldn't see any of

00:24:15,629 --> 00:24:19,980
your Diagnostics which is really awful

00:24:18,450 --> 00:24:21,720
there are a few hacks to try

00:24:19,980 --> 00:24:23,370
and fix that such as waiting until the

00:24:21,720 --> 00:24:25,049
next assertion but then you might have

00:24:23,370 --> 00:24:29,340
already gone too far in run code you

00:24:25,049 --> 00:24:30,990
didn't want run test two has a concept

00:24:29,340 --> 00:24:34,710
of context which I'll get to later that

00:24:30,990 --> 00:24:36,120
makes bail on fail possible die on fail

00:24:34,710 --> 00:24:37,590
same thing but you die instead of

00:24:36,120 --> 00:24:40,410
bailout which means your other tests

00:24:37,590 --> 00:24:41,850
will still run exit summary is something

00:24:40,410 --> 00:24:45,419
that's loaded by default when you use

00:24:41,850 --> 00:24:48,059
v-0 it basically puts your Diagnostics

00:24:45,419 --> 00:24:50,429
at the end of the test s r and this is

00:24:48,059 --> 00:24:54,000
one of my favorites this one will seed

00:24:50,429 --> 00:24:56,250
Rand with today's date before anything

00:24:54,000 --> 00:24:59,429
else is done so that on any given day

00:24:56,250 --> 00:25:02,280
your random behavior is reproducible and

00:24:59,429 --> 00:25:04,290
predictable but from day to day today it

00:25:02,280 --> 00:25:07,049
will change so you still get the test

00:25:04,290 --> 00:25:09,600
that you're not depending on the random

00:25:07,049 --> 00:25:11,370
seed and it will also whenever there's a

00:25:09,600 --> 00:25:12,870
failure it will output what seed was

00:25:11,370 --> 00:25:14,880
used so if you're going and looking at a

00:25:12,870 --> 00:25:16,620
log from a few days back you can see

00:25:14,880 --> 00:25:18,600
what seed was used and you can reproduce

00:25:16,620 --> 00:25:20,850
that test with the environment variable

00:25:18,600 --> 00:25:23,070
this is something sworn and I actually

00:25:20,850 --> 00:25:27,929
cooked up together back with the fennec

00:25:23,070 --> 00:25:30,270
project utf-8 this is just if you know

00:25:27,929 --> 00:25:32,880
you want to use utf-8 just use this

00:25:30,270 --> 00:25:34,919
utf-8 plug-in tests to plug in utf-8 and

00:25:32,880 --> 00:25:36,950
it'll just make everything utf-8 and you

00:25:34,919 --> 00:25:41,190
don't have to think about it anymore

00:25:36,950 --> 00:25:43,710
lots of things become utf-8 question

00:25:41,190 --> 00:25:48,830
about the plugins okay

00:25:43,710 --> 00:25:51,630
there's also tests to require bla and

00:25:48,830 --> 00:25:54,419
these are things where you want to skip

00:25:51,630 --> 00:25:56,669
a test if a requirement isn't met most

00:25:54,419 --> 00:25:58,380
common one author testing so if you've

00:25:56,669 --> 00:26:01,110
got a test that you really only want to

00:25:58,380 --> 00:26:03,179
have run when your author attest then

00:26:01,110 --> 00:26:04,559
you just use this in that test and it

00:26:03,179 --> 00:26:06,510
will only run when the officer testing

00:26:04,559 --> 00:26:09,390
variable is set there's a more generic

00:26:06,510 --> 00:26:10,890
version that lets you do any environment

00:26:09,390 --> 00:26:13,919
variable you specify for the same

00:26:10,890 --> 00:26:15,540
behavior now we get to something that

00:26:13,919 --> 00:26:17,299
will really save you time that you

00:26:15,540 --> 00:26:20,700
didn't even know you needed to spend

00:26:17,299 --> 00:26:22,980
this test to require fork will make your

00:26:20,700 --> 00:26:25,950
tests skip if your system cannot fork

00:26:22,980 --> 00:26:27,929
now you think well why is that it's own

00:26:25,950 --> 00:26:30,030
module because if you actually want to

00:26:27,929 --> 00:26:33,390
check if your system can fork this is

00:26:30,030 --> 00:26:33,990
the logic you need that is a lot of

00:26:33,390 --> 00:26:36,360
logic and

00:26:33,990 --> 00:26:38,190
if you don't put that in there it will

00:26:36,360 --> 00:26:43,710
bite you someday on some systems

00:26:38,190 --> 00:26:46,230
somewhere yes that took a long time to

00:26:43,710 --> 00:26:48,809
get right real fork is the same thing

00:26:46,230 --> 00:26:50,490
except it will also skip if your fork is

00:26:48,809 --> 00:26:54,420
pseudo fork like if you're running on

00:26:50,490 --> 00:26:57,020
Windows require module you know skip

00:26:54,420 --> 00:26:59,870
this test if this module isn't installed

00:26:57,020 --> 00:27:02,850
skip if it's the wrong version of Perl

00:26:59,870 --> 00:27:04,800
skip if this month Perl doesn't support

00:27:02,850 --> 00:27:07,110
threads and once again to get that right

00:27:04,800 --> 00:27:09,380
it's actually quite hard you can't just

00:27:07,110 --> 00:27:13,050
require threads and hope for the best

00:27:09,380 --> 00:27:15,770
this even catches bugs and GCC versions

00:27:13,050 --> 00:27:19,380
that cause threads to seg fault

00:27:15,770 --> 00:27:20,370
questions about the require modules good

00:27:19,380 --> 00:27:23,429
we can move on

00:27:20,370 --> 00:27:25,980
mocking test to sweet also comes with

00:27:23,429 --> 00:27:29,070
some mocking libraries that are based

00:27:25,980 --> 00:27:33,870
largely on mock quick which is something

00:27:29,070 --> 00:27:36,720
else I'd wrote written previously so let

00:27:33,870 --> 00:27:38,730
me go back mock quick has a different

00:27:36,720 --> 00:27:40,740
approach to mocking in that when you do

00:27:38,730 --> 00:27:43,080
mock you get an object that then

00:27:40,740 --> 00:27:45,000
controls that lock once that object goes

00:27:43,080 --> 00:27:46,740
out of scope all your mocking is

00:27:45,000 --> 00:27:48,600
destroyed so you don't have to worry

00:27:46,740 --> 00:27:50,940
about your mocking accidentally leaking

00:27:48,600 --> 00:27:53,940
somewhere else if you do a mock with

00:27:50,940 --> 00:27:56,179
test to mock it will clean itself up

00:27:53,940 --> 00:27:59,010
when you are done with it

00:27:56,179 --> 00:28:00,660
so the control object is what gives you

00:27:59,010 --> 00:28:02,220
the handle to that mocking it also lets

00:28:00,660 --> 00:28:03,900
you change the mocking partway through

00:28:02,220 --> 00:28:05,820
and it is what's responsible for

00:28:03,900 --> 00:28:09,120
cleaning up when you are done so how do

00:28:05,820 --> 00:28:12,210
you use it do you capture the control

00:28:09,120 --> 00:28:15,059
object from creating a new test to mock

00:28:12,210 --> 00:28:16,679
instance now don't look too hard at this

00:28:15,059 --> 00:28:18,450
because there's actually sugar I'm going

00:28:16,679 --> 00:28:20,730
to show you that really abstract most of

00:28:18,450 --> 00:28:22,080
this away you tell it what class what

00:28:20,730 --> 00:28:24,210
you want to override what methods you

00:28:22,080 --> 00:28:26,280
want to add then you can override or

00:28:24,210 --> 00:28:28,290
restore more you can reset something

00:28:26,280 --> 00:28:31,350
back to its original and then you can

00:28:28,290 --> 00:28:33,720
reset it all when you're done so tools

00:28:31,350 --> 00:28:35,520
there's test two tools mock which

00:28:33,720 --> 00:28:39,030
provides that sugar I mentioned it gives

00:28:35,520 --> 00:28:40,679
you the mock tool the mocked tool mock

00:28:39,030 --> 00:28:43,800
class and mock object if you want to be

00:28:40,679 --> 00:28:45,900
really explicit mock can do everything

00:28:43,800 --> 00:28:46,970
but these other three are there if you

00:28:45,900 --> 00:28:49,280
really really

00:28:46,970 --> 00:28:51,500
to be clear what you're doing so you

00:28:49,280 --> 00:28:54,470
want to mock a class capture the control

00:28:51,500 --> 00:28:56,090
mock some package add these methods

00:28:54,470 --> 00:28:57,860
override these methods and this can be a

00:28:56,090 --> 00:29:00,289
hash rat for an array ref doesn't matter

00:28:57,860 --> 00:29:02,780
and when you call them it calls the

00:29:00,289 --> 00:29:05,240
mocked once again return control and

00:29:02,780 --> 00:29:08,210
you're done at the explicit form would

00:29:05,240 --> 00:29:10,190
be to either mock space class and then

00:29:08,210 --> 00:29:12,409
the class or mock underscore class using

00:29:10,190 --> 00:29:15,020
that tool I went a little overboard on

00:29:12,409 --> 00:29:17,120
the sugar they're objects you can mock

00:29:15,020 --> 00:29:19,220
an object without actually defining a

00:29:17,120 --> 00:29:21,740
class for it it will be produced for you

00:29:19,220 --> 00:29:24,230
on the fly so you can say my object mock

00:29:21,740 --> 00:29:26,510
here's the hash that I want you to bless

00:29:24,230 --> 00:29:28,840
and here's the method I want you to add

00:29:26,510 --> 00:29:31,190
for it and you can just use that object

00:29:28,840 --> 00:29:37,220
created all their package stuff for you

00:29:31,190 --> 00:29:40,880
is there a question yeah don't use test

00:29:37,220 --> 00:29:44,090
class sorry I've got a thing against

00:29:40,880 --> 00:29:46,010
test class it I mean if you're using

00:29:44,090 --> 00:29:48,260
test class with a modern test simple it

00:29:46,010 --> 00:29:49,940
will all work and some of these tools

00:29:48,260 --> 00:29:52,309
will still work if you import them into

00:29:49,940 --> 00:29:56,530
a test class test but I'm not verifying

00:29:52,309 --> 00:29:59,860
that they're all enter compatible maybe

00:29:56,530 --> 00:29:59,860
other question

00:30:03,679 --> 00:30:07,950
No

00:30:05,700 --> 00:30:09,990
so but there are some things like if

00:30:07,950 --> 00:30:12,270
you're mocking a class and you call

00:30:09,990 --> 00:30:13,920
override and the class doesn't have

00:30:12,270 --> 00:30:15,420
something to override it'll tell you

00:30:13,920 --> 00:30:17,070
that was an error or if you go to add

00:30:15,420 --> 00:30:19,200
and it already has it defined

00:30:17,070 --> 00:30:20,640
it'll be an error because you don't want

00:30:19,200 --> 00:30:22,080
to try to add something that's already

00:30:20,640 --> 00:30:24,320
there or override something that's not

00:30:22,080 --> 00:30:26,730
there so that will throw an exception

00:30:24,320 --> 00:30:28,200
but if the class isn't loaded it's

00:30:26,730 --> 00:30:30,179
assuming you want to define it and

00:30:28,200 --> 00:30:32,400
prevent it from being loaded and then

00:30:30,179 --> 00:30:35,880
once your control is destroyed it will

00:30:32,400 --> 00:30:38,960
restore your percent in so that you can

00:30:35,880 --> 00:30:38,960
then load the real one

00:30:46,780 --> 00:30:51,790
yes yes and it also keeps it as a stack

00:30:50,140 --> 00:30:54,660
so you can also pop that stack and go

00:30:51,790 --> 00:30:54,660
back to previous ones

00:30:55,380 --> 00:30:59,830
if you mock something that's not loaded

00:30:58,450 --> 00:31:01,960
it will prevent you from loading the

00:30:59,830 --> 00:31:03,430
real one until you've destroyed your

00:31:01,960 --> 00:31:08,620
control object at which point the real

00:31:03,430 --> 00:31:11,470
one can load again other questions okay

00:31:08,620 --> 00:31:15,040
now we're moving on to my favorite set

00:31:11,470 --> 00:31:16,410
of tools spec this is based heavily on

00:31:15,040 --> 00:31:18,730
Ruby's r-spec

00:31:16,410 --> 00:31:20,050
which I've never actually used directly

00:31:18,730 --> 00:31:22,420
because I've never used Ruby but I

00:31:20,050 --> 00:31:24,160
really liked what I read about it's

00:31:22,420 --> 00:31:27,550
essentially a very advanced form of

00:31:24,160 --> 00:31:30,460
subtests it's declarative it's got some

00:31:27,550 --> 00:31:33,370
good concurrency set up so let's take a

00:31:30,460 --> 00:31:36,010
look at some so you use test2 tool spec

00:31:33,370 --> 00:31:38,460
and your main keyword here is tests so

00:31:36,010 --> 00:31:43,210
tests foo we're defining a sub test and

00:31:38,460 --> 00:31:44,920
it passes a bar also pass tests bad this

00:31:43,210 --> 00:31:47,680
one's going to fail so we're marking it

00:31:44,920 --> 00:31:49,840
as to do by giving it this a hash of

00:31:47,680 --> 00:31:52,050
params before giving it the sub to run

00:31:49,840 --> 00:31:54,190
so this will fail but it'll be to do

00:31:52,050 --> 00:31:56,260
then you can also do the same thing with

00:31:54,190 --> 00:31:57,670
skip say hey we're skipping this because

00:31:56,260 --> 00:31:59,830
we don't want to wipe our hard drive and

00:31:57,670 --> 00:32:02,230
it will skip that it will not actually

00:31:59,830 --> 00:32:04,050
run that test block so it is safe though

00:32:02,230 --> 00:32:06,870
I don't recommend you test it too hard

00:32:04,050 --> 00:32:11,740
then done testing when you're done and

00:32:06,870 --> 00:32:13,960
yes so in this case though unlike

00:32:11,740 --> 00:32:16,570
regular sub tests these don't run as

00:32:13,960 --> 00:32:18,670
they're encountered they get queued as

00:32:16,570 --> 00:32:20,770
they're encountered and then when you

00:32:18,670 --> 00:32:23,140
hit done testing before it outputs the

00:32:20,770 --> 00:32:27,100
plan then it will run them and it will

00:32:23,140 --> 00:32:28,450
run them in a random order you can you

00:32:27,100 --> 00:32:30,010
can change that behavior you can tell it

00:32:28,450 --> 00:32:32,350
not to do random but I don't recommend

00:32:30,010 --> 00:32:33,880
you do that so params there's a few

00:32:32,350 --> 00:32:35,500
params you can pass into these test

00:32:33,880 --> 00:32:37,120
blocks flat which means it won't

00:32:35,500 --> 00:32:40,210
actually render as a substance they'll

00:32:37,120 --> 00:32:43,000
all render in line to do skip we covered

00:32:40,210 --> 00:32:46,090
I so this one's one of my favorites it

00:32:43,000 --> 00:32:48,010
means isolate this sub test which means

00:32:46,090 --> 00:32:50,620
on a system that supports true forking

00:32:48,010 --> 00:32:52,660
it will fork before running that sub

00:32:50,620 --> 00:32:54,310
test and then exit when it's done so

00:32:52,660 --> 00:32:56,860
that nothing you do in that sub test

00:32:54,310 --> 00:32:58,540
will affect the parent process on a

00:32:56,860 --> 00:33:00,280
system that only has threading it will

00:32:58,540 --> 00:33:01,840
do threat use threading to accomplish

00:33:00,280 --> 00:33:03,700
this

00:33:01,840 --> 00:33:05,650
though I think you have to ask for that

00:33:03,700 --> 00:33:09,340
now because it was just too buggy pearl

00:33:05,650 --> 00:33:11,920
threads you know async is not quite the

00:33:09,340 --> 00:33:14,140
same async means this one can be run in

00:33:11,920 --> 00:33:16,810
parallel with others so you could fork

00:33:14,140 --> 00:33:18,850
to run it but you don't have to and you

00:33:16,810 --> 00:33:21,480
can control how many concurrent tests

00:33:18,850 --> 00:33:24,700
you have running within the test itself

00:33:21,480 --> 00:33:27,880
so if you mark 3 is async they might all

00:33:24,700 --> 00:33:30,130
run and run concurrently and you can

00:33:27,880 --> 00:33:35,140
combine any of these you can put ISO and

00:33:30,130 --> 00:33:37,900
async together it's all handy describe I

00:33:35,140 --> 00:33:40,360
describe lets you group these test

00:33:37,900 --> 00:33:41,920
blocks so let's describe color will test

00:33:40,360 --> 00:33:43,900
red green and blue will describe size

00:33:41,920 --> 00:33:45,640
and test small medium and large and we

00:33:43,900 --> 00:33:48,310
can even nest describes under describes

00:33:45,640 --> 00:33:50,230
why is this useful because you can

00:33:48,310 --> 00:33:53,560
attach more behavior to these groups

00:33:50,230 --> 00:33:55,420
before all run the sub that means it'll

00:33:53,560 --> 00:33:58,000
be run once before it runs all the test

00:33:55,420 --> 00:34:00,010
blocks before each this means it'll be

00:33:58,000 --> 00:34:02,220
run before each test run so it'll be run

00:34:00,010 --> 00:34:05,080
multiple times once per test block

00:34:02,220 --> 00:34:07,540
anything outside of a described also

00:34:05,080 --> 00:34:09,520
applies inside that describe but

00:34:07,540 --> 00:34:11,200
something inside a describe only applies

00:34:09,520 --> 00:34:15,370
to that one and deeper it doesn't apply

00:34:11,200 --> 00:34:17,740
to the rest of the file so this before

00:34:15,370 --> 00:34:20,710
each will run before red green and blue

00:34:17,740 --> 00:34:22,360
as well this before each but this before

00:34:20,710 --> 00:34:25,750
each here will not apply to this one

00:34:22,360 --> 00:34:27,010
down here complicates stuff I'm not

00:34:25,750 --> 00:34:27,820
gonna spend too much time on it because

00:34:27,010 --> 00:34:31,030
we do have limited time

00:34:27,820 --> 00:34:32,290
there's also after all and after each to

00:34:31,030 --> 00:34:34,360
run at the end of the test blocks

00:34:32,290 --> 00:34:36,160
there's a round if you want to wrap

00:34:34,360 --> 00:34:38,020
something around such as localizing an

00:34:36,160 --> 00:34:40,179
environment variable that works kind of

00:34:38,020 --> 00:34:44,380
like mooses you get to thing and then

00:34:40,179 --> 00:34:46,179
you want to continue cases this lets you

00:34:44,380 --> 00:34:50,260
multiply how many tests you are running

00:34:46,179 --> 00:34:52,360
quite complicated so in this describe

00:34:50,260 --> 00:34:55,090
we've got color validator we've got a

00:34:52,360 --> 00:34:58,630
case where C is red C is green and C is

00:34:55,090 --> 00:35:01,090
blue then we've got these two tests what

00:34:58,630 --> 00:35:03,370
will happen is it'll run red to set C

00:35:01,090 --> 00:35:05,770
then run both tests then it'll run green

00:35:03,370 --> 00:35:08,500
to set C to green and then run both to

00:35:05,770 --> 00:35:10,090
us so ultimately this becomes six tests

00:35:08,500 --> 00:35:11,830
instead of the two that you see there

00:35:10,090 --> 00:35:14,490
because it's running for each case

00:35:11,830 --> 00:35:17,890
here's what the output looks

00:35:14,490 --> 00:35:19,720
yeah yeah I think that's about mmm I

00:35:17,890 --> 00:35:22,960
think it skipped some I should update

00:35:19,720 --> 00:35:24,970
this slide case mods you can even modify

00:35:22,960 --> 00:35:27,250
the cases you can have a before case in

00:35:24,970 --> 00:35:30,880
after case to modify all your cases I've

00:35:27,250 --> 00:35:32,700
not actually had a use for this mocking

00:35:30,880 --> 00:35:35,620
the mocking tools I showed you before

00:35:32,700 --> 00:35:37,360
work even better under spec because if

00:35:35,620 --> 00:35:39,460
you just put a mock in to describe it

00:35:37,360 --> 00:35:41,110
will automatically become a before each

00:35:39,460 --> 00:35:43,210
and you don't have to capture the

00:35:41,110 --> 00:35:45,730
control object if you put it inside a

00:35:43,210 --> 00:35:47,260
test block once again it'll just apply

00:35:45,730 --> 00:35:49,210
to that test block you don't need to

00:35:47,260 --> 00:35:50,650
capture the control object it'll just

00:35:49,210 --> 00:35:52,900
work though if you did capture the

00:35:50,650 --> 00:35:55,260
control object ago okay he wants control

00:35:52,900 --> 00:35:57,910
this so I'm not going to do that magic

00:35:55,260 --> 00:35:59,680
if you try to do it without capturing

00:35:57,910 --> 00:36:01,150
the control object outside of this it

00:35:59,680 --> 00:36:05,100
will explode and say hey that doesn't

00:36:01,150 --> 00:36:05,100
work so it's pretty safe

00:36:14,170 --> 00:36:18,250
there there are some shortcuts to not

00:36:16,720 --> 00:36:20,440
have to do that but that is the usual

00:36:18,250 --> 00:36:23,910
way I don't actually remember what the

00:36:20,440 --> 00:36:23,910
shortcuts are because I don't use them I

00:36:31,380 --> 00:36:37,660
yes that so yes if you need more than

00:36:34,540 --> 00:36:42,460
one set of cases you would use different

00:36:37,660 --> 00:36:44,560
levels of describe so there is a devil

00:36:42,460 --> 00:36:47,650
declare plug-in I wrote for this that

00:36:44,560 --> 00:36:49,900
makes this all a lot easier you can do

00:36:47,650 --> 00:36:52,210
if you if you load test to plug-in spec

00:36:49,900 --> 00:36:53,890
declare then you can define your

00:36:52,210 --> 00:36:55,570
describe block and test blocks as though

00:36:53,890 --> 00:36:57,310
they were subroutines you do not need

00:36:55,570 --> 00:36:58,840
the sub keyword you do not need the

00:36:57,310 --> 00:37:01,990
extra commas and you do not need the

00:36:58,840 --> 00:37:03,820
semicolon at the end of the blocks it

00:37:01,990 --> 00:37:05,380
just looks like you're defining any kind

00:37:03,820 --> 00:37:08,110
of sub but instead sub keyword its

00:37:05,380 --> 00:37:10,660
describe or tests or whatever else I

00:37:08,110 --> 00:37:12,670
have used this in production at two

00:37:10,660 --> 00:37:17,350
companies including where I work now zip

00:37:12,670 --> 00:37:19,840
recruiter we're hiring so it's very well

00:37:17,350 --> 00:37:22,270
tested it does not seem to introduce any

00:37:19,840 --> 00:37:24,310
weird syntax errors or any of the weird

00:37:22,270 --> 00:37:26,320
things that year you might be used to

00:37:24,310 --> 00:37:30,100
using likes a source filters or other

00:37:26,320 --> 00:37:32,110
terrifying things like that any

00:37:30,100 --> 00:37:35,490
questions about spec before I move on

00:37:32,110 --> 00:37:37,990
please use this please use this is good

00:37:35,490 --> 00:37:39,610
bundles so there's a couple bundles that

00:37:37,990 --> 00:37:40,720
come with test to suite and I want to

00:37:39,610 --> 00:37:43,930
see how I'm doing on time here real

00:37:40,720 --> 00:37:48,130
quick that would help if I knew what

00:37:43,930 --> 00:37:51,190
time we ended so twelve minutes okay so

00:37:48,130 --> 00:37:54,160
there's the main bundle test to v-0

00:37:51,190 --> 00:37:57,730
which has it will load strict in

00:37:54,160 --> 00:38:00,430
warnings for you it'll load utf-8 for

00:37:57,730 --> 00:38:04,330
you you can turn those off loads s R and

00:38:00,430 --> 00:38:06,700
once again the utf-8 I never covered

00:38:04,330 --> 00:38:09,160
this so skip that test you tools target

00:38:06,700 --> 00:38:13,720
pretty cool go look up the docs exit

00:38:09,160 --> 00:38:14,950
summary let's test to API and why do I

00:38:13,720 --> 00:38:16,870
have slides that cover that I should

00:38:14,950 --> 00:38:20,380
anyway moving on bunch of other things

00:38:16,870 --> 00:38:23,530
it loads here I'm missing some slides I

00:38:20,380 --> 00:38:26,110
apologize for that test to bundle more

00:38:23,530 --> 00:38:27,790
this one is kind of a compatibility step

00:38:26,110 --> 00:38:29,590
if you want to mostly switch to

00:38:27,790 --> 00:38:31,360
test-tube but your heart's not all the

00:38:29,590 --> 00:38:33,430
way in it you can switch to test-tube

00:38:31,360 --> 00:38:35,140
bundle more there's still a few things

00:38:33,430 --> 00:38:37,930
you have to change but there's a lot

00:38:35,140 --> 00:38:39,520
less like is is alias too is deeply the

00:38:37,930 --> 00:38:43,150
regular is is still just a string

00:38:39,520 --> 00:38:44,590
compare but there are a few things that

00:38:43,150 --> 00:38:45,820
are changed and the differences are

00:38:44,590 --> 00:38:47,890
listed here I'm not going to go through

00:38:45,820 --> 00:38:50,260
them and then there's test tube bundles

00:38:47,890 --> 00:38:52,420
simple if you are really not interested

00:38:50,260 --> 00:38:54,730
in doing anything modern which lets you

00:38:52,420 --> 00:38:57,130
replace tests too simple to replace

00:38:54,730 --> 00:38:58,210
tests simple as simple was so simple

00:38:57,130 --> 00:39:03,820
there's actually nothing you have to

00:38:58,210 --> 00:39:06,190
change context objects this is the magic

00:39:03,820 --> 00:39:09,100
under the hood that makes tests to able

00:39:06,190 --> 00:39:11,230
to do things like bail on fail it's the

00:39:09,100 --> 00:39:12,670
primary interface when you're writing a

00:39:11,230 --> 00:39:14,260
test tool so this is getting to more

00:39:12,670 --> 00:39:15,910
advanced thing any of you here who write

00:39:14,260 --> 00:39:19,750
test tools this is what you want to pay

00:39:15,910 --> 00:39:21,460
attention to so the the context object

00:39:19,750 --> 00:39:23,170
is responsible for tracking the file

00:39:21,460 --> 00:39:24,580
name the line number and any other

00:39:23,170 --> 00:39:26,980
metadata that you're gonna want as

00:39:24,580 --> 00:39:30,640
Diagnostics and it is your primary way

00:39:26,980 --> 00:39:33,040
to generate the testing events usage you

00:39:30,640 --> 00:39:35,770
import the context function from test to

00:39:33,040 --> 00:39:37,930
API create your so we're just

00:39:35,770 --> 00:39:40,210
reimplemented okay here my okay

00:39:37,930 --> 00:39:42,670
takes the bull name whatever you acquire

00:39:40,210 --> 00:39:45,220
your context object and you guard it

00:39:42,670 --> 00:39:47,890
like it is your child you can call

00:39:45,220 --> 00:39:49,540
methods to create events so here we're

00:39:47,890 --> 00:39:52,090
calling okay with the boolean that

00:39:49,540 --> 00:39:54,070
generates the event and then when you

00:39:52,090 --> 00:39:55,540
are done you want to clean up that

00:39:54,070 --> 00:39:57,700
doesn't just mean let this fall out of

00:39:55,540 --> 00:39:59,950
scope you need to explicitly call

00:39:57,700 --> 00:40:02,230
release when you are done that is

00:39:59,950 --> 00:40:04,030
because this is where the bail on fail

00:40:02,230 --> 00:40:05,860
logic or the die on fail logic will

00:40:04,030 --> 00:40:07,450
happen we can't just have that happen in

00:40:05,860 --> 00:40:10,330
a destructor because you can't actually

00:40:07,450 --> 00:40:12,940
throw an exception from a destructor so

00:40:10,330 --> 00:40:15,130
the die on fail required us to have an

00:40:12,940 --> 00:40:16,780
explicit release but all test tools are

00:40:15,130 --> 00:40:18,760
gonna test two tools are gonna have this

00:40:16,780 --> 00:40:20,410
because it's been required from the very

00:40:18,760 --> 00:40:23,350
beginning it's not some hack that was

00:40:20,410 --> 00:40:24,910
added on after the fact so you know that

00:40:23,350 --> 00:40:27,460
all your tools if they're test you are

00:40:24,910 --> 00:40:29,890
gonna have this and test two will yell

00:40:27,460 --> 00:40:31,710
at you very very loudly if you do not

00:40:29,890 --> 00:40:34,030
call release and it gets to a destructor

00:40:31,710 --> 00:40:36,450
any return the bull to be compatible

00:40:34,030 --> 00:40:38,160
with okay rules

00:40:36,450 --> 00:40:40,440
these are the 10 commandments of a

00:40:38,160 --> 00:40:42,359
context object get it as early as

00:40:40,440 --> 00:40:45,720
possible release it as late as possible

00:40:42,359 --> 00:40:48,660
do not forget to release it each sub

00:40:45,720 --> 00:40:52,950
should get its own you should not pass

00:40:48,660 --> 00:40:54,720
context around do not cash or store the

00:40:52,950 --> 00:40:58,410
context to use later though you can

00:40:54,720 --> 00:41:00,810
clone it and store the clone do not

00:40:58,410 --> 00:41:03,869
share the context there's a theme here a

00:41:00,810 --> 00:41:05,790
suit it assumes it is obtained within a

00:41:03,869 --> 00:41:07,290
sub not at the package scope so if you

00:41:05,790 --> 00:41:10,920
actually needed at the package scope

00:41:07,290 --> 00:41:13,920
there is a hack to do that do not alter

00:41:10,920 --> 00:41:16,470
the context internals and do not monkey

00:41:13,920 --> 00:41:20,310
patch the context no support if you

00:41:16,470 --> 00:41:20,910
monkey to patch the context make a pull

00:41:20,310 --> 00:41:24,950
request

00:41:20,910 --> 00:41:28,140
I like features all added if it's same

00:41:24,950 --> 00:41:29,700
events so you shouldn't actually use

00:41:28,140 --> 00:41:31,530
what was on the last slide to generate

00:41:29,700 --> 00:41:33,810
ok anymore because I recently revamped

00:41:31,530 --> 00:41:37,650
the event system initially every type of

00:41:33,810 --> 00:41:39,750
event event or every type of thing you'd

00:41:37,650 --> 00:41:42,180
want to express with test2 had a custom

00:41:39,750 --> 00:41:43,890
event type and it was actually kind of a

00:41:42,180 --> 00:41:45,540
pain in the ass sometimes you wanted

00:41:43,890 --> 00:41:47,730
multiple or an event to do multiple

00:41:45,540 --> 00:41:49,890
things so now these are the ones you

00:41:47,730 --> 00:41:52,380
should do if you just want to do a pass

00:41:49,890 --> 00:41:54,450
call pass or pass and release if you

00:41:52,380 --> 00:41:56,520
want to combine those steps and it will

00:41:54,450 --> 00:41:58,560
generate an optimal pass object that

00:41:56,520 --> 00:42:01,140
knows it's a pass and will skip most of

00:41:58,560 --> 00:42:03,690
the logic making it significantly faster

00:42:01,140 --> 00:42:07,170
than using the legacy ok style objects

00:42:03,690 --> 00:42:10,050
fail same idea it's an optimized fail as

00:42:07,170 --> 00:42:12,119
though that were important then any

00:42:10,050 --> 00:42:15,210
other type of event is going to have

00:42:12,119 --> 00:42:17,160
custom data and those that custom data

00:42:15,210 --> 00:42:19,800
is called facets which we'll cover in a

00:42:17,160 --> 00:42:22,470
another slide here shortly but here

00:42:19,800 --> 00:42:24,300
you'd send send a v2 that's second style

00:42:22,470 --> 00:42:27,089
of events and give it the facets you

00:42:24,300 --> 00:42:28,500
want legacy events are all these please

00:42:27,089 --> 00:42:31,740
don't use them anymore but here's what

00:42:28,500 --> 00:42:33,329
they look like facets I'm pretty sure

00:42:31,740 --> 00:42:36,119
I'm almost out of time here so I'm going

00:42:33,329 --> 00:42:36,599
to buzz right through these and not in

00:42:36,119 --> 00:42:39,510
order

00:42:36,599 --> 00:42:41,310
the assert facet is if you've got an OK

00:42:39,510 --> 00:42:42,569
and you want to make an assertion give

00:42:41,310 --> 00:42:44,609
it the name of the assertion whether or

00:42:42,569 --> 00:42:47,650
not it passed whether or not you want

00:42:44,609 --> 00:42:50,200
any debugging automatically output

00:42:47,650 --> 00:42:51,790
then there's amnesty this is how things

00:42:50,200 --> 00:42:53,980
like to do and skip are defined if

00:42:51,790 --> 00:42:56,980
you've got an amnesty facet on your

00:42:53,980 --> 00:42:58,870
event that also has an assert then if it

00:42:56,980 --> 00:43:00,880
fails it won't actually count as a

00:42:58,870 --> 00:43:02,460
failure that is how to do is done except

00:43:00,880 --> 00:43:04,720
it's generic you can create your own

00:43:02,460 --> 00:43:08,920
forms of amnesty it doesn't have to be

00:43:04,720 --> 00:43:10,930
to do or skip C control gives you a lot

00:43:08,920 --> 00:43:12,990
of things you can do like bail out is

00:43:10,930 --> 00:43:17,440
implemented by telling it to terminate

00:43:12,990 --> 00:43:19,750
and be global parent is used by subtests

00:43:17,440 --> 00:43:21,760
nothing on GD details there's plan facet

00:43:19,750 --> 00:43:23,920
so you could actually have a single

00:43:21,760 --> 00:43:26,440
event that has a plan and assertion some

00:43:23,920 --> 00:43:29,620
amnesty and tells it to exit zero all

00:43:26,440 --> 00:43:31,510
that good stuff trace every event should

00:43:29,620 --> 00:43:33,190
have one of these there are some cases

00:43:31,510 --> 00:43:35,680
where it doesn't but it should this

00:43:33,190 --> 00:43:37,810
tells you what stack you know like what

00:43:35,680 --> 00:43:39,580
package what file what line what sub

00:43:37,810 --> 00:43:41,590
were used to generate the event what

00:43:39,580 --> 00:43:43,330
process idea came from what thread idea

00:43:41,590 --> 00:43:46,510
it came from what context idea it came

00:43:43,330 --> 00:43:48,220
from what hub idea it came from whether

00:43:46,510 --> 00:43:50,110
or not it's nested in a sub test whether

00:43:48,220 --> 00:43:51,760
or not it's a buffered sub test this is

00:43:50,110 --> 00:43:54,240
really where all your Diagnostics should

00:43:51,760 --> 00:43:56,920
come from or a lot of them anyway and

00:43:54,240 --> 00:43:59,470
let's see info was how things like

00:43:56,920 --> 00:44:01,540
diagnosed dye eggs and notes and similar

00:43:59,470 --> 00:44:04,120
are done and most of the rest things you

00:44:01,540 --> 00:44:05,800
really don't need too much detail oh I

00:44:04,120 --> 00:44:08,830
actually have five minutes okay maybe I

00:44:05,800 --> 00:44:10,390
will go into a few of these no I've got

00:44:08,830 --> 00:44:10,990
a better idea I'm gonna pitch my talk

00:44:10,390 --> 00:44:13,120
tomorrow

00:44:10,990 --> 00:44:16,270
so you have now seen the rich

00:44:13,120 --> 00:44:18,790
capabilities of test two a lot of these

00:44:16,270 --> 00:44:21,100
competitive abilities especially like

00:44:18,790 --> 00:44:23,980
these traces and all this metadata that

00:44:21,100 --> 00:44:25,510
each events have is totally lost if you

00:44:23,980 --> 00:44:28,600
are using prove and it all gets boiled

00:44:25,510 --> 00:44:31,960
down to tap tap the law seus test format

00:44:28,600 --> 00:44:33,370
ever created there is something new and

00:44:31,960 --> 00:44:35,770
I'm going to be talking about it

00:44:33,370 --> 00:44:38,680
tomorrow test to harness also known as

00:44:35,770 --> 00:44:40,930
yes it is a new test harness that also

00:44:38,680 --> 00:44:43,270
includes the ability to preload your

00:44:40,930 --> 00:44:45,820
framework or your modules before running

00:44:43,270 --> 00:44:47,950
the tests to give you an idea the moose

00:44:45,820 --> 00:44:51,460
test suite on this laptop takes a minute

00:44:47,950 --> 00:44:54,330
and 45 seconds takes 42 seconds under

00:44:51,460 --> 00:44:56,710
test to harness when I preload moose

00:44:54,330 --> 00:44:58,180
there are lots of other features it's

00:44:56,710 --> 00:44:59,930
under active development still a little

00:44:58,180 --> 00:45:01,940
bit experimental

00:44:59,930 --> 00:45:04,670
but come to my talk tomorrow if you

00:45:01,940 --> 00:45:07,640
really want to speed up your test you're

00:45:04,670 --> 00:45:11,720
testing zip recruiter our test suite on

00:45:07,640 --> 00:45:17,540
our sandbox four and a half hours with

00:45:11,720 --> 00:45:20,000
yes one and a half hours and cPanel has

00:45:17,540 --> 00:45:23,480
a similar thing where their test suite

00:45:20,000 --> 00:45:25,070
ran for an hour takes ten minutes so

00:45:23,480 --> 00:45:26,960
come to my talk tomorrow if you want to

00:45:25,070 --> 00:45:29,330
see a test harness that actually puts

00:45:26,960 --> 00:45:31,580
everything test two offers all the way

00:45:29,330 --> 00:45:33,680
through beginning to end without at a

00:45:31,580 --> 00:45:37,490
player getting rid of all the important

00:45:33,680 --> 00:45:39,800
stuff in the middle and if you really

00:45:37,490 --> 00:45:42,230
care about converting old tests there's

00:45:39,800 --> 00:45:43,820
the slides on converting I neither have

00:45:42,230 --> 00:45:45,470
the time nor the energy to go over these

00:45:43,820 --> 00:45:49,340
today but I'm going to go back here

00:45:45,470 --> 00:45:51,500
where the link to my talk is so that you

00:45:49,340 --> 00:45:53,300
can go and look at it yourself and with

00:45:51,500 --> 00:45:57,580
that I am going to step down unless

00:45:53,300 --> 00:45:57,580
there are further questions yes

00:46:02,680 --> 00:46:07,810
[Music]

00:46:05,040 --> 00:46:10,420
they are randomized unless you ask it

00:46:07,810 --> 00:46:13,360
not to randomize things yes but keep in

00:46:10,420 --> 00:46:16,000
mind that usually will also load the s

00:46:13,360 --> 00:46:17,800
Rand so on any given day it should be

00:46:16,000 --> 00:46:19,540
consistent every time you run it but

00:46:17,800 --> 00:46:26,110
from day to day today it will be

00:46:19,540 --> 00:46:41,680
randomized order yes I the convert one

00:46:26,110 --> 00:46:43,390
yeah okay other questions yes so it does

00:46:41,680 --> 00:46:46,840
actually check and see how wide your

00:46:43,390 --> 00:46:52,440
screen is and it will only go as wide as

00:46:46,840 --> 00:47:01,030
it can and it will wrap within the cells

00:46:52,440 --> 00:47:03,100
yes but it will wrap okay so that is

00:47:01,030 --> 00:47:05,800
worth going into it will wrap as I said

00:47:03,100 --> 00:47:07,690
but I also will make it so that it is

00:47:05,800 --> 00:47:09,700
explicit when there is a new line if

00:47:07,690 --> 00:47:11,830
your Diagnostics include data as a new

00:47:09,700 --> 00:47:19,870
line in it it'll do the backslash n

00:47:11,830 --> 00:47:21,820
before adding a new line come to my talk

00:47:19,870 --> 00:47:34,320
tomorrow and yes I think you're going to

00:47:21,820 --> 00:47:37,030
be quite happy no I can't promise that

00:47:34,320 --> 00:47:39,850
but I am gay okay if you consider a

00:47:37,030 --> 00:47:42,040
prize being a way to get a complete test

00:47:39,850 --> 00:47:44,020
log of every single event that was run

00:47:42,040 --> 00:47:45,610
in its original form and inspect it with

00:47:44,020 --> 00:47:49,200
the graphical tool if you consider that

00:47:45,610 --> 00:47:49,200
a prize come to my talk tomorrow

00:47:49,740 --> 00:47:56,350
any other questions okay I am going to

00:47:54,580 --> 00:47:59,510
step down thank you

00:47:56,350 --> 00:47:59,510
[Applause]

00:48:01,029 --> 00:48:03,089

YouTube URL: https://www.youtube.com/watch?v=b2xIfBdcqb0


