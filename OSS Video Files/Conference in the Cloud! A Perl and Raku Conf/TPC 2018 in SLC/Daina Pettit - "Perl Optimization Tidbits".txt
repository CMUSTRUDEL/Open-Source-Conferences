Title: Daina Pettit - "Perl Optimization Tidbits"
Publication date: 2018-06-20
Playlist: TPC 2018 in SLC
Description: 
	Have you ever wondered how much difference Perl coding styles make to performance? Perl has lots of ways to do the same thing, and some are more readable/maintainable, but are slower or consume more memory…or is it the other way around?

We’ll look at Perl syntax and see what performs better or worse and why. Maybe your favorite syntax is an awesome efficient race horse, maybe it’s a pig, or maybe it makes no difference. Come see your dreams shattered, hopes dashed, or realize how awesome your syntax choices really are!
Captions: 
	00:00:00,170 --> 00:00:05,430
welcome to Pearl optimization tidbits my

00:00:03,899 --> 00:00:08,670
name is dana pettit i currently work for

00:00:05,430 --> 00:00:10,650
a zip recruiter and there's a couple

00:00:08,670 --> 00:00:13,620
email addresses i have and yes my name

00:00:10,650 --> 00:00:15,240
is looks like diana but it's pronounced

00:00:13,620 --> 00:00:21,600
dana if you chopped off the last day

00:00:15,240 --> 00:00:22,980
then everybody would say dane so Dana so

00:00:21,600 --> 00:00:25,529
what we're gonna do here this is

00:00:22,980 --> 00:00:27,869
actually if if you attended open West

00:00:25,529 --> 00:00:31,980
they had a version early version of this

00:00:27,869 --> 00:00:35,579
talk in 2017 I don't know that anybody

00:00:31,980 --> 00:00:37,969
here attended ads so we won't have to

00:00:35,579 --> 00:00:41,160
worry about repeating very much here so

00:00:37,969 --> 00:00:43,410
the purpose of this is that we're going

00:00:41,160 --> 00:00:46,920
to look at performance differences of

00:00:43,410 --> 00:00:48,840
equivalent code you know Perl has this

00:00:46,920 --> 00:00:51,480
Tim towie thing there is more than one

00:00:48,840 --> 00:00:53,760
way to do it and so I'm gonna look at

00:00:51,480 --> 00:00:55,260
the various ways we have to do certain

00:00:53,760 --> 00:00:58,109
things and whether it makes a difference

00:00:55,260 --> 00:01:00,899
or not we're gonna look and see if

00:00:58,109 --> 00:01:04,799
something is faster or if it's has a

00:01:00,899 --> 00:01:08,070
smaller footprint and in the end does it

00:01:04,799 --> 00:01:10,229
actually make any difference so some of

00:01:08,070 --> 00:01:13,080
the considerations that about why we

00:01:10,229 --> 00:01:15,299
would bother with doing one version of a

00:01:13,080 --> 00:01:17,340
line of code over another is readability

00:01:15,299 --> 00:01:18,960
or maintainability those are usually big

00:01:17,340 --> 00:01:21,180
issues because it costs us a lot of

00:01:18,960 --> 00:01:25,439
money and for somebody to sit there and

00:01:21,180 --> 00:01:30,689
figure things out and we're gonna focus

00:01:25,439 --> 00:01:34,950
primarily on language constructs so

00:01:30,689 --> 00:01:37,350
things like does a post increment a post

00:01:34,950 --> 00:01:41,610
Auto increment like dollar X plus plus

00:01:37,350 --> 00:01:45,090
is that any better or any different than

00:01:41,610 --> 00:01:50,100
a pre auto increment where you have a

00:01:45,090 --> 00:01:52,350
plus plus dollar X we'll talk about a

00:01:50,100 --> 00:01:56,479
few algorithmic tweaks which tend to

00:01:52,350 --> 00:02:03,990
have a bigger performance gain or loss

00:01:56,479 --> 00:02:05,790
but we're gonna not focus on that so the

00:02:03,990 --> 00:02:07,229
Assumption here is that choices matter

00:02:05,790 --> 00:02:10,550
it'll make it that it might actually

00:02:07,229 --> 00:02:10,550
make a difference here

00:02:13,590 --> 00:02:17,799
we're assuming that the testing tools

00:02:16,180 --> 00:02:19,390
we're going to use are going to give us

00:02:17,799 --> 00:02:23,430
good enough answers to tell the

00:02:19,390 --> 00:02:25,720
difference between various lines of code

00:02:23,430 --> 00:02:28,120
because of some of the variation in

00:02:25,720 --> 00:02:29,980
performance of different processors and

00:02:28,120 --> 00:02:32,920
systems and so on we're going to really

00:02:29,980 --> 00:02:36,730
just focus on the difference not the

00:02:32,920 --> 00:02:38,890
absolute value of the say this is three

00:02:36,730 --> 00:02:40,060
micro seconds slower than that it's

00:02:38,890 --> 00:02:42,310
going to say oh this may be three

00:02:40,060 --> 00:02:44,620
percent faster that sort of thing or

00:02:42,310 --> 00:02:51,010
this is 20 percent faster or twice as

00:02:44,620 --> 00:02:56,260
fast so what I use for testing I use a

00:02:51,010 --> 00:02:59,500
couple different systems if both had

00:02:56,260 --> 00:03:02,680
various versions of Perl 522 I know if

00:02:59,500 --> 00:03:04,540
you're using Perl 5 26 or 528 you might

00:03:02,680 --> 00:03:05,980
have some performance enhancements in

00:03:04,540 --> 00:03:07,569
those there were some significant

00:03:05,980 --> 00:03:10,060
optimizations that took place in those

00:03:07,569 --> 00:03:15,609
but is there anybody that is actually

00:03:10,060 --> 00:03:18,220
using 526 or 528 in production Oh a few

00:03:15,609 --> 00:03:20,380
people good for you

00:03:18,220 --> 00:03:22,900
a lot of people are trapped in an older

00:03:20,380 --> 00:03:24,879
version and can't get past like five

00:03:22,900 --> 00:03:28,319
Tanners has anybody stuck on five ten

00:03:24,879 --> 00:03:33,910
still that is good news

00:03:28,319 --> 00:03:36,760
anybody stuck below 518 I'm sorry but

00:03:33,910 --> 00:03:38,290
it's okay that's a a lot of us has end

00:03:36,760 --> 00:03:39,459
up in that situation it's because

00:03:38,290 --> 00:03:41,199
there's other dependents the

00:03:39,459 --> 00:03:44,500
dependencies that will break things and

00:03:41,199 --> 00:03:45,940
it just is a problem so a lot of these

00:03:44,500 --> 00:03:50,590
numbers will be comparable for all of

00:03:45,940 --> 00:03:57,190
you we measured our performance using in

00:03:50,590 --> 00:03:59,230
NYT Prof and time and the interesting

00:03:57,190 --> 00:04:02,019
thing is we found some deficiencies that

00:03:59,230 --> 00:04:06,639
will point out and the measuring of code

00:04:02,019 --> 00:04:08,560
execution code so the way we did this is

00:04:06,639 --> 00:04:11,799
we try to write lines of code as simple

00:04:08,560 --> 00:04:14,049
as possible use as few external things

00:04:11,799 --> 00:04:17,169
as we possibly could we executed the

00:04:14,049 --> 00:04:19,180
lines of code millions of times and then

00:04:17,169 --> 00:04:22,300
we looked at the results in the profiler

00:04:19,180 --> 00:04:23,290
and then we look for problems is you

00:04:22,300 --> 00:04:26,200
know if you switch

00:04:23,290 --> 00:04:27,670
Order of statements is a change if you

00:04:26,200 --> 00:04:31,390
add another type of statement in front

00:04:27,670 --> 00:04:33,880
of it does it change so there's a bunch

00:04:31,390 --> 00:04:37,030
of adjustment since have we that I had

00:04:33,880 --> 00:04:41,880
to do to to verify that the results were

00:04:37,030 --> 00:04:47,170
actually meaningful so let's look at an

00:04:41,880 --> 00:04:48,940
example so we have a check checking a

00:04:47,170 --> 00:04:51,730
post increment in a pre increment

00:04:48,940 --> 00:04:55,540
against each other running it through a

00:04:51,730 --> 00:04:57,640
loop a million times now this isn't

00:04:55,540 --> 00:04:59,830
exactly what I did but this I trimmed it

00:04:57,640 --> 00:05:01,150
down so it fit on the slide because

00:04:59,830 --> 00:05:02,410
there were some it turns out there's

00:05:01,150 --> 00:05:04,630
some problems they had to deal with

00:05:02,410 --> 00:05:08,230
which I'll talk about a little later so

00:05:04,630 --> 00:05:10,150
if we look in NYT Prof we get some

00:05:08,230 --> 00:05:11,710
numbers here for those two lines of code

00:05:10,150 --> 00:05:17,080
we can then have something we can

00:05:11,710 --> 00:05:19,660
compare this is not the final result of

00:05:17,080 --> 00:05:23,560
this but this is this is the idea of the

00:05:19,660 --> 00:05:25,570
way we did the analysis so let's look at

00:05:23,560 --> 00:05:28,660
case number one auto increment or

00:05:25,570 --> 00:05:31,000
decrement with the pre and post what we

00:05:28,660 --> 00:05:32,860
ended up is we have a the plus plus on

00:05:31,000 --> 00:05:35,680
either side we have a minus minus on

00:05:32,860 --> 00:05:37,090
either side and then we did strings and

00:05:35,680 --> 00:05:38,950
so a lot of you may not know that you

00:05:37,090 --> 00:05:42,540
can actually auto increment a string and

00:05:38,950 --> 00:05:46,720
sometimes that makes no sense whatsoever

00:05:42,540 --> 00:05:48,190
but it can if you have a a G and you

00:05:46,720 --> 00:05:49,750
want turned it into an H you can

00:05:48,190 --> 00:05:54,190
actually do a plus plus on and it'll

00:05:49,750 --> 00:05:55,660
turn it into an H so there is some use

00:05:54,190 --> 00:06:00,310
for that some call for that but not a

00:05:55,660 --> 00:06:03,330
lot so we came up with is that the pre

00:06:00,310 --> 00:06:08,320
increment is actually slightly faster

00:06:03,330 --> 00:06:11,710
and in decrements the pre-decrement is

00:06:08,320 --> 00:06:14,620
slightly faster and where we're doing

00:06:11,710 --> 00:06:17,080
the increment on strings the post

00:06:14,620 --> 00:06:21,070
increment is twice as fast as the pre

00:06:17,080 --> 00:06:22,990
increment which is kind of the opposite

00:06:21,070 --> 00:06:25,930
of what you might think and the

00:06:22,990 --> 00:06:27,940
interesting thing is that the alphabetic

00:06:25,930 --> 00:06:31,060
or the string increments or decrements

00:06:27,940 --> 00:06:32,830
are twice as slow as the numeric ones

00:06:31,060 --> 00:06:33,370
and we expect that because it has to

00:06:32,830 --> 00:06:36,180
figure out

00:06:33,370 --> 00:06:37,990
what character it is and modify that

00:06:36,180 --> 00:06:40,449
does that makes it a little bit of a

00:06:37,990 --> 00:06:42,850
problem so this this one is actually

00:06:40,449 --> 00:06:44,860
surprising to me because I expected that

00:06:42,850 --> 00:06:46,720
it would be the post-increment that

00:06:44,860 --> 00:06:52,150
would be faster but it's the pre

00:06:46,720 --> 00:06:53,979
increments is faster just slightly and I

00:06:52,150 --> 00:06:59,639
think most instances of code people use

00:06:53,979 --> 00:07:02,590
the post increment in pro best practices

00:06:59,639 --> 00:07:05,590
Damion suggested you always putting in

00:07:02,590 --> 00:07:08,919
XMS on the end of it all your regular

00:07:05,590 --> 00:07:12,850
expression as your options or your

00:07:08,919 --> 00:07:15,850
switches and I disagreed with that if

00:07:12,850 --> 00:07:17,620
you can look at my talk on pearls worst

00:07:15,850 --> 00:07:19,900
best practices and I consider this one

00:07:17,620 --> 00:07:22,300
of the worst practice practices and I

00:07:19,900 --> 00:07:23,020
demonstrated that it was actually a bad

00:07:22,300 --> 00:07:25,710
idea

00:07:23,020 --> 00:07:29,020
because it turns out it actually has a

00:07:25,710 --> 00:07:33,010
3% hit when you throw those on there

00:07:29,020 --> 00:07:34,900
it's not free and it also the but the

00:07:33,010 --> 00:07:37,030
biggest hit on that particular thing is

00:07:34,900 --> 00:07:39,070
that it takes you longer to read that

00:07:37,030 --> 00:07:41,710
code because you're thinking now why is

00:07:39,070 --> 00:07:47,740
the X on there and why is the S on there

00:07:41,710 --> 00:07:51,190
and why is the M on there so I do not

00:07:47,740 --> 00:07:55,330
recommend using that case three a four

00:07:51,190 --> 00:07:59,740
versus a 4h four and 4h are supposed to

00:07:55,330 --> 00:08:03,940
be synonyms and are they really the

00:07:59,740 --> 00:08:06,250
answer is probably the the performance

00:08:03,940 --> 00:08:09,160
is actually really close a 4h might be

00:08:06,250 --> 00:08:13,229
slightly faster but it's not enough to

00:08:09,160 --> 00:08:15,970
actually say it is faster definitively

00:08:13,229 --> 00:08:17,410
now let's make a little bit of a change

00:08:15,970 --> 00:08:21,550
on that let's throw in a looping

00:08:17,410 --> 00:08:24,250
variable so we have a my amide variable

00:08:21,550 --> 00:08:29,530
as our looping variable does that make a

00:08:24,250 --> 00:08:31,750
difference again the speed is nearly

00:08:29,530 --> 00:08:33,370
identical there's less than one percent

00:08:31,750 --> 00:08:34,959
difference so it's probably within a

00:08:33,370 --> 00:08:36,120
margin of error so we wouldn't worry

00:08:34,959 --> 00:08:40,810
about that

00:08:36,120 --> 00:08:44,380
let's compare case five for vs. for each

00:08:40,810 --> 00:08:46,780
versus a map because there's a lot of

00:08:44,380 --> 00:08:49,050
things you can do with any one of them

00:08:46,780 --> 00:08:55,590
that's this

00:08:49,050 --> 00:08:58,480
and it turns out the map is 30% slower

00:08:55,590 --> 00:09:06,910
anybody have a reason why they think it

00:08:58,480 --> 00:09:08,320
might be slower what's that it's it's

00:09:06,910 --> 00:09:11,470
actually constructing something to

00:09:08,320 --> 00:09:13,660
return that's that's exactly right it's

00:09:11,470 --> 00:09:15,400
slower because it's not intended to be

00:09:13,660 --> 00:09:19,540
used it's in the same way

00:09:15,400 --> 00:09:25,000
max map is best for creating lists a4h

00:09:19,540 --> 00:09:27,040
is best for modifying existing lists so

00:09:25,000 --> 00:09:28,480
the the map has is actually building

00:09:27,040 --> 00:09:30,250
something if you call map and avoid

00:09:28,480 --> 00:09:34,330
context meaning you're not catching what

00:09:30,250 --> 00:09:36,820
it's returning then it it has to build

00:09:34,330 --> 00:09:38,710
that now I believe that the map yet at

00:09:36,820 --> 00:09:41,580
one point recognizes when it's in a void

00:09:38,710 --> 00:09:50,680
context and does not create the list

00:09:41,580 --> 00:09:53,680
yes Sawyer in this case know that I've

00:09:50,680 --> 00:09:56,680
just ended under the block

00:09:53,680 --> 00:09:58,300
again this in Perl best practices he

00:09:56,680 --> 00:10:00,520
recommends always using the block but I

00:09:58,300 --> 00:10:08,170
think that's a good another good test

00:10:00,520 --> 00:10:10,480
that I could do good question how about

00:10:08,170 --> 00:10:12,580
a what I like to call a verbal not

00:10:10,480 --> 00:10:15,370
versus the logical nod they're both

00:10:12,580 --> 00:10:18,880
logical nots but one's a lower

00:10:15,370 --> 00:10:21,730
precedence n ot is lower precedence than

00:10:18,880 --> 00:10:27,030
the exclamation point you'd think they'd

00:10:21,730 --> 00:10:27,030
be similar they are

00:10:28,459 --> 00:10:37,649
let's look at Anne's the verbal and

00:10:31,230 --> 00:10:45,269
versus the symbolic and twenty percent

00:10:37,649 --> 00:10:47,610
slower than the verbal and there's a lot

00:10:45,269 --> 00:10:49,199
of cases where we use and these logical

00:10:47,610 --> 00:10:51,870
ends where these are completely

00:10:49,199 --> 00:10:53,120
interchangeable a lot of places say

00:10:51,870 --> 00:10:56,670
there's some places where they are not

00:10:53,120 --> 00:10:58,709
it's because of the precedence issue so

00:10:56,670 --> 00:11:06,449
just be aware that the verbal and is a

00:10:58,709 --> 00:11:15,569
little bit faster how about an or again

00:11:06,449 --> 00:11:17,670
the verbal or is faster and it turns out

00:11:15,569 --> 00:11:21,300
that the or is actually twice as fast as

00:11:17,670 --> 00:11:22,800
an and now it's hard to compare some of

00:11:21,300 --> 00:11:26,629
these things because you have you have

00:11:22,800 --> 00:11:26,629
to make sure the cases are equivalent

00:11:26,959 --> 00:11:37,559
case nine string interpolation is their

00:11:32,370 --> 00:11:40,620
difference this is surprising a double

00:11:37,559 --> 00:11:45,990
quoted string is actually faster than

00:11:40,620 --> 00:11:47,850
doing a straight assignment this one was

00:11:45,990 --> 00:11:53,430
I've been puzzled about this one why is

00:11:47,850 --> 00:12:01,290
this the case and I don't know as well

00:11:53,430 --> 00:12:06,199
as curious things yes this is 522 maybe

00:12:01,290 --> 00:12:06,199
they fixed this in five 26 or 28

00:12:07,730 --> 00:12:12,480
comparing double quoted versus single

00:12:10,139 --> 00:12:17,250
quoted strings with no interpolation

00:12:12,480 --> 00:12:19,069
going on inside the strings the double

00:12:17,250 --> 00:12:23,189
quoted string is almost always

00:12:19,069 --> 00:12:24,990
significantly faster so if you have a

00:12:23,189 --> 00:12:25,980
choice between using single and double

00:12:24,990 --> 00:12:26,819
quotes you might want to use double

00:12:25,980 --> 00:12:28,470
quotes all the time

00:12:26,819 --> 00:12:31,319
I know there's a philosophy that you

00:12:28,470 --> 00:12:32,550
always use double or always use single

00:12:31,319 --> 00:12:35,880
quotes unless you know you have

00:12:32,550 --> 00:12:37,920
interpolation going on or you only use

00:12:35,880 --> 00:12:40,649
that the alternate is that you only use

00:12:37,920 --> 00:12:41,580
single quoted strings when you know you

00:12:40,649 --> 00:12:44,490
do not want

00:12:41,580 --> 00:12:45,930
to interpolate so this would suggest

00:12:44,490 --> 00:12:48,800
that we would always want to use the

00:12:45,930 --> 00:12:51,170
double quoted strings

00:12:48,800 --> 00:12:53,460
now here's kind of an interesting one

00:12:51,170 --> 00:12:54,990
where we take a string where we're

00:12:53,460 --> 00:12:56,670
constructing something in the string

00:12:54,990 --> 00:13:00,300
with interpolation going on and we're

00:12:56,670 --> 00:13:03,210
using the curly braces to set off the

00:13:00,300 --> 00:13:07,790
name of the variable we're going to be

00:13:03,210 --> 00:13:13,200
interpolating I would think that the

00:13:07,790 --> 00:13:16,250
curly brace form would be slower but it

00:13:13,200 --> 00:13:16,250
turns out it's faster

00:13:26,560 --> 00:13:31,449
there's some of these things that don't

00:13:28,930 --> 00:13:33,579
make sense but that's the way they are

00:13:31,449 --> 00:13:36,129
that's with the way the tests showed now

00:13:33,579 --> 00:13:37,569
I I did a lot of isolation of this and I

00:13:36,129 --> 00:13:38,860
put statements around them so I was

00:13:37,569 --> 00:13:42,759
making sure it wasn't doing any sort of

00:13:38,860 --> 00:13:45,999
caching to make sure that it was as

00:13:42,759 --> 00:13:47,230
clean as I could get but there's some of

00:13:45,999 --> 00:13:49,439
these that are like this that I just

00:13:47,230 --> 00:13:51,819
scratched my head and I go I can't I

00:13:49,439 --> 00:13:55,769
can't figure out why but it seems to be

00:13:51,819 --> 00:13:55,769
that this is the way it is

00:14:03,540 --> 00:14:10,750
forty-two subdirector there's

00:14:07,269 --> 00:14:13,410
several oh and it actually does uses

00:14:10,750 --> 00:14:13,410
cash

00:14:40,950 --> 00:15:02,350
that's a good idea

00:14:42,750 --> 00:15:06,700
further research yeah huh so interesting

00:15:02,350 --> 00:15:08,620
stuff so using string concatenated

00:15:06,700 --> 00:15:13,410
operator do something similar to create

00:15:08,620 --> 00:15:17,290
a string that has a dollar Y in it and

00:15:13,410 --> 00:15:18,790
if we put the interpolation or if put

00:15:17,290 --> 00:15:20,440
the variable on the left side of the

00:15:18,790 --> 00:15:25,540
concatenate is it faster than having it

00:15:20,440 --> 00:15:27,640
on the right and it turns out having it

00:15:25,540 --> 00:15:29,940
on the left is actually significantly

00:15:27,640 --> 00:15:29,940
faster

00:15:37,960 --> 00:15:42,050
that's actually a good question

00:15:40,190 --> 00:15:45,290
and I don't know the answer to that I

00:15:42,050 --> 00:15:48,680
don't know if it's true for all values

00:15:45,290 --> 00:15:50,990
of why I did find some things

00:15:48,680 --> 00:15:53,030
interesting is that in modifying some

00:15:50,990 --> 00:15:54,560
things that seemed external to the

00:15:53,030 --> 00:15:57,050
problem or should have been a minor part

00:15:54,560 --> 00:15:59,300
of the of the test case ended up having

00:15:57,050 --> 00:16:01,460
a significant part a significant

00:15:59,300 --> 00:16:03,890
significant impact on the performance

00:16:01,460 --> 00:16:05,600
and I'll talk about some of those later

00:16:03,890 --> 00:16:14,360
that I found that most of them it didn't

00:16:05,600 --> 00:16:17,120
may seem to make any difference let's

00:16:14,360 --> 00:16:21,230
look at scope so if we just create a

00:16:17,120 --> 00:16:25,610
scope for nothing more than just doing

00:16:21,230 --> 00:16:29,600
scope it turns out it has a significant

00:16:25,610 --> 00:16:35,270
hit and we would expect that we would

00:16:29,600 --> 00:16:42,890
expect to hit for doing scope if we're

00:16:35,270 --> 00:16:47,690
doing scope and we have am i involved it

00:16:42,890 --> 00:16:48,980
actually is a little bit better instead

00:16:47,690 --> 00:16:53,600
of three hundred percent it's two

00:16:48,980 --> 00:16:56,990
hundred percent if we use local with

00:16:53,600 --> 00:17:01,850
scope is it any different it turns out

00:16:56,990 --> 00:17:04,579
it is it's about twenty percent so it's

00:17:01,850 --> 00:17:07,089
a lot better so my is actually kind of

00:17:04,579 --> 00:17:07,089
expensive

00:17:10,620 --> 00:17:16,199
but in the case of here for comparing

00:17:13,980 --> 00:17:21,329
the local cost of 20 percent more than

00:17:16,199 --> 00:17:28,559
the my a case 16 we're gonna met we mask

00:17:21,329 --> 00:17:32,400
an existing my declaration so we have

00:17:28,559 --> 00:17:35,790
two different dollar X's two different

00:17:32,400 --> 00:17:38,460
X's what does that do it turns out

00:17:35,790 --> 00:17:43,530
masking a variable with the my it cost

00:17:38,460 --> 00:17:44,910
us about fifteen percent I'm not sure

00:17:43,530 --> 00:17:46,170
why we would do that all the time but

00:17:44,910 --> 00:17:52,050
sometimes we need to do that

00:17:46,170 --> 00:17:55,860
yes question this is where you're

00:17:52,050 --> 00:18:01,590
creating a separate variable that masks

00:17:55,860 --> 00:18:03,900
one that's added the outside scope the

00:18:01,590 --> 00:18:06,360
alternate case would be not having the

00:18:03,900 --> 00:18:09,990
my in there at all or having a different

00:18:06,360 --> 00:18:11,850
variable so if we've said my Y that

00:18:09,990 --> 00:18:19,320
would it would be fifteen percent more

00:18:11,850 --> 00:18:20,940
expensive to do my X we have a lot of

00:18:19,320 --> 00:18:23,100
different ways we can get subroutine

00:18:20,940 --> 00:18:24,900
arguments we can get it through a shift

00:18:23,100 --> 00:18:27,330
we can get it through directly accessing

00:18:24,900 --> 00:18:31,740
the parameter variable the add

00:18:27,330 --> 00:18:34,230
underscore variable array or by doing an

00:18:31,740 --> 00:18:40,740
assignment directly out of that as a

00:18:34,230 --> 00:18:43,050
group in in before doing the analysis on

00:18:40,740 --> 00:18:45,440
this I was guessing that the shift was

00:18:43,050 --> 00:18:52,140
the most expensive because it requires a

00:18:45,440 --> 00:18:55,910
separate call it turns out the array

00:18:52,140 --> 00:18:58,559
assignment is the slowest the direct

00:18:55,910 --> 00:19:02,610
indexing into the array the parameter

00:18:58,559 --> 00:19:08,190
array element is the fastest and shift

00:19:02,610 --> 00:19:10,530
actually isn't that expensive so that's

00:19:08,190 --> 00:19:12,150
actually a good news because I see a lot

00:19:10,530 --> 00:19:13,830
of code I see shifts all over the place

00:19:12,150 --> 00:19:15,240
and I was worrying hey is this

00:19:13,830 --> 00:19:17,390
performance hit turns out it's not that

00:19:15,240 --> 00:19:17,390
bad

00:19:17,750 --> 00:19:23,060
this look at alternate control

00:19:20,150 --> 00:19:24,500
structures some people like these some

00:19:23,060 --> 00:19:27,820
people hate them some people didn't know

00:19:24,500 --> 00:19:32,270
you could do this so you have an if or

00:19:27,820 --> 00:19:36,290
you use an and they both have a scope

00:19:32,270 --> 00:19:38,510
that's created with the code block but

00:19:36,290 --> 00:19:43,720
is yours these results are exactly the

00:19:38,510 --> 00:19:48,950
same and when we ran the analysis on it

00:19:43,720 --> 00:19:53,480
identical performance so you don't need

00:19:48,950 --> 00:20:01,280
to use the end form for performance

00:19:53,480 --> 00:20:03,970
purposes in if is just as good why would

00:20:01,280 --> 00:20:03,970
you use one over another

00:20:04,910 --> 00:20:11,540
[Music]

00:20:06,850 --> 00:20:14,300
you know I yeah and there's there's some

00:20:11,540 --> 00:20:18,230
instances where you you may want to use

00:20:14,300 --> 00:20:21,200
one over the other so the if for where

00:20:18,230 --> 00:20:22,600
the if is the only thing there then yeah

00:20:21,200 --> 00:20:25,490
that's probably the most readable

00:20:22,600 --> 00:20:28,070
however I there was a project I worked

00:20:25,490 --> 00:20:32,210
on for one company where they were

00:20:28,070 --> 00:20:34,340
generating they were creating a big long

00:20:32,210 --> 00:20:36,800
string it was essentially going to be a

00:20:34,340 --> 00:20:38,690
big buffer that we needed to pass to a

00:20:36,800 --> 00:20:41,510
program that was going to generate a PDF

00:20:38,690 --> 00:20:42,470
from it and so it had to be a big long

00:20:41,510 --> 00:20:44,570
string so we're doing lots of

00:20:42,470 --> 00:20:47,180
concatenation of things onto a single

00:20:44,570 --> 00:20:49,220
string and with and what we ended up

00:20:47,180 --> 00:20:51,140
doing is basically saying if it's this

00:20:49,220 --> 00:20:52,580
case then we concatenate this on if

00:20:51,140 --> 00:20:53,960
there's a souther case then we won't do

00:20:52,580 --> 00:20:58,970
this other one and it would have been

00:20:53,960 --> 00:21:01,340
really ugly to have if-elsif and using

00:20:58,970 --> 00:21:03,980
the and form and then ever having

00:21:01,340 --> 00:21:07,670
everything lying up in nice columns was

00:21:03,980 --> 00:21:09,320
really clean it really worked well but

00:21:07,670 --> 00:21:11,840
weakness because we had hundreds of

00:21:09,320 --> 00:21:13,310
these lines all in a row and having

00:21:11,840 --> 00:21:16,550
hundreds of ifs in a row would have been

00:21:13,310 --> 00:21:17,690
too just a nightmare to maintain so it

00:21:16,550 --> 00:21:19,070
actually worked out really clean so

00:21:17,690 --> 00:21:20,990
there are reasons why you might want to

00:21:19,070 --> 00:21:22,790
go one way or another but most of time I

00:21:20,990 --> 00:21:25,420
think people would just use it if we

00:21:22,790 --> 00:21:25,420
have a question over here

00:21:31,150 --> 00:21:33,750
yeah

00:21:39,710 --> 00:21:48,240
yeah so you so it ends up it's the same

00:21:42,690 --> 00:21:51,390
thing underneath yeah if we look at an

00:21:48,240 --> 00:21:59,150
alternate of something like that with

00:21:51,390 --> 00:21:59,150
where we have the eltz case it turns out

00:22:00,559 --> 00:22:06,440
that the do form is actually 40% faster

00:22:11,879 --> 00:22:16,679
I'm not sure I recommend that form for

00:22:14,609 --> 00:22:24,839
readability but it's interesting that

00:22:16,679 --> 00:22:26,729
it's there's a bit of a hit there in

00:22:24,839 --> 00:22:28,979
this case I did not and maybe I should

00:22:26,729 --> 00:22:33,929
have because that in the earlier testing

00:22:28,979 --> 00:22:42,089
it appeared to be a big difference that

00:22:33,929 --> 00:22:43,559
maybe another route to go and likewise

00:22:42,089 --> 00:22:45,569
where why would you do one over the

00:22:43,559 --> 00:22:47,729
other and it really boils down to what

00:22:45,569 --> 00:22:49,499
do you need you have there may be a case

00:22:47,729 --> 00:22:51,389
where it looks good to do at things in

00:22:49,499 --> 00:22:53,369
Nice columns there might be a case where

00:22:51,389 --> 00:22:54,959
you just an if/else makes a lot more

00:22:53,369 --> 00:23:03,179
sense and I think most cases you just

00:22:54,959 --> 00:23:06,079
want to else case 20 do you want to use

00:23:03,179 --> 00:23:06,079
a return or not

00:23:09,750 --> 00:23:17,830
it turns out using a an explicit return

00:23:13,930 --> 00:23:18,280
is actually a little bit slower not a

00:23:17,830 --> 00:23:30,030
lot

00:23:18,280 --> 00:23:30,030
yes Sawyer yes so

00:23:36,970 --> 00:23:43,450
so let's look at printing a list so we

00:23:39,640 --> 00:23:46,720
do a call to a print statement giving it

00:23:43,450 --> 00:23:48,070
a list of things to print or doing

00:23:46,720 --> 00:23:49,720
separate print statements we would

00:23:48,070 --> 00:23:50,830
expect the print multiple print

00:23:49,720 --> 00:23:54,030
statements to take a little longer

00:23:50,830 --> 00:23:57,550
because you're doing two separate calls

00:23:54,030 --> 00:24:05,080
printing a list is actually faster than

00:23:57,550 --> 00:24:08,320
doing them separately however if we do a

00:24:05,080 --> 00:24:11,880
print where the join is that faster than

00:24:08,320 --> 00:24:16,210
using a print and using the dollar comma

00:24:11,880 --> 00:24:23,860
list separator and letting print insert

00:24:16,210 --> 00:24:27,910
that - turns out using join is slightly

00:24:23,860 --> 00:24:30,100
faster but it wasn't really consistent

00:24:27,910 --> 00:24:33,690
in the testing I did so it wasn't enough

00:24:30,100 --> 00:24:33,690
to say yet always use join

00:24:40,430 --> 00:24:49,230
case 23 array vs. hash speed so this

00:24:47,280 --> 00:24:51,330
this is kindness comparing a little bit

00:24:49,230 --> 00:24:53,820
of apples and oranges here because you

00:24:51,330 --> 00:24:55,350
usually don't index the same way because

00:24:53,820 --> 00:25:00,120
it's two different 1 indexes by an

00:24:55,350 --> 00:25:02,220
integer one that indexes by a string but

00:25:00,120 --> 00:25:04,260
if we were to compare them giving him

00:25:02,220 --> 00:25:06,390
the same tortes type of thing to index

00:25:04,260 --> 00:25:09,510
with like an integer or an integer

00:25:06,390 --> 00:25:11,610
string which would be faster it turns

00:25:09,510 --> 00:25:13,890
and I've always been told oh hashes are

00:25:11,610 --> 00:25:16,620
really fast that's why we use hashes so

00:25:13,890 --> 00:25:20,790
much they're just so fast it turns out

00:25:16,620 --> 00:25:22,650
hashes are actually slower then indexing

00:25:20,790 --> 00:25:26,850
into a hash is slower than indexing into

00:25:22,650 --> 00:25:30,050
an array so if you have a choice the

00:25:26,850 --> 00:25:30,050
matters you might want to use an array

00:25:38,370 --> 00:25:50,730
yeah we tried to simplify the cases in

00:25:48,779 --> 00:25:53,039
the I'd have to go look up the test case

00:25:50,730 --> 00:25:54,690
again I I think it wasn't a big number

00:25:53,039 --> 00:25:59,039
it was a small number like a single

00:25:54,690 --> 00:26:01,020
digit so so in that case we're looking

00:25:59,039 --> 00:26:03,539
more at the overhead of what it takes to

00:26:01,020 --> 00:26:09,659
access the hash rather than computing

00:26:03,539 --> 00:26:11,570
the the index so should we use strict or

00:26:09,659 --> 00:26:13,620
not does it matter

00:26:11,570 --> 00:26:15,419
and of course everybody says all you got

00:26:13,620 --> 00:26:19,980
to use strict got to use strict and you

00:26:15,419 --> 00:26:21,659
probably do but if if you really don't

00:26:19,980 --> 00:26:22,860
need to and you need to squeeze the last

00:26:21,659 --> 00:26:28,409
bit of performance does it make any

00:26:22,860 --> 00:26:30,270
difference well it turns out that my

00:26:28,409 --> 00:26:35,039
statements are slow so if you don't use

00:26:30,270 --> 00:26:37,440
strict and you don't use my it less

00:26:35,039 --> 00:26:44,100
actually be faster and it's about twice

00:26:37,440 --> 00:26:47,520
as slow so there there could be a good

00:26:44,100 --> 00:26:48,510
reason to not actually use strict if you

00:26:47,520 --> 00:26:51,750
really need to squeeze out some

00:26:48,510 --> 00:26:54,149
performance here and what it was

00:26:51,750 --> 00:26:56,820
interesting is that almost any access of

00:26:54,149 --> 00:26:59,720
am ID variable was slower than accessing

00:26:56,820 --> 00:26:59,720
one that was not

00:27:03,690 --> 00:27:07,720
occasionally you run into somebody who

00:27:05,590 --> 00:27:10,929
use it what I call an inside-out 4-h

00:27:07,720 --> 00:27:14,770
where there's a single statement that's

00:27:10,929 --> 00:27:16,510
terminated with a for each and it's it's

00:27:14,770 --> 00:27:18,250
essentially the same thing as a as a

00:27:16,510 --> 00:27:20,799
regular for each but it's got the single

00:27:18,250 --> 00:27:26,169
statement on the outside and the

00:27:20,799 --> 00:27:29,140
difference it turns out is that the

00:27:26,169 --> 00:27:31,059
standard form with the code block the

00:27:29,140 --> 00:27:37,980
three line form that we have here is 50%

00:27:31,059 --> 00:27:39,640
slower anybody have a reason why scope

00:27:37,980 --> 00:27:43,570
that's right

00:27:39,640 --> 00:27:48,070
it is scope it has to create the scope

00:27:43,570 --> 00:27:50,530
for that for each so although I think

00:27:48,070 --> 00:27:53,770
the inside out form is kind of ugly and

00:27:50,530 --> 00:27:55,510
it's not as nice for reading it it

00:27:53,770 --> 00:27:57,960
actually does help you if you don't need

00:27:55,510 --> 00:27:57,960
the scope

00:28:01,430 --> 00:28:05,020
to a billion it would be

00:28:07,200 --> 00:28:13,680
that's a good question and I don't

00:28:10,240 --> 00:28:17,440
recall the answer to that one

00:28:13,680 --> 00:28:19,270
it matters per iteration yeah it turns

00:28:17,440 --> 00:28:26,140
out there's some funny things we'll talk

00:28:19,270 --> 00:28:28,060
about about in C if a 4h isn't just as

00:28:26,140 --> 00:28:29,500
clean as it looks on the page because

00:28:28,060 --> 00:28:30,910
there's more stuff that goes on when

00:28:29,500 --> 00:28:32,830
you're going into it and then when you

00:28:30,910 --> 00:28:34,570
get to the end of the loop and that

00:28:32,830 --> 00:28:40,510
stuff has to be handled which you don't

00:28:34,570 --> 00:28:43,510
have in the inside-out form let's look

00:28:40,510 --> 00:28:47,220
at ternary operator alternatives I have

00:28:43,510 --> 00:28:50,830
three here and some of these are kind of

00:28:47,220 --> 00:28:53,680
obtuse I don't know that anybody who has

00:28:50,830 --> 00:28:56,230
seen these that much but they're out

00:28:53,680 --> 00:28:58,240
there I've I actually stole this code

00:28:56,230 --> 00:29:01,750
from somebody and it was some production

00:28:58,240 --> 00:29:04,990
code so it actually does exist so

00:29:01,750 --> 00:29:08,800
there's three different forms the idea

00:29:04,990 --> 00:29:11,500
is that if if our X is equal to Y you

00:29:08,800 --> 00:29:14,050
knows that's a string equality test then

00:29:11,500 --> 00:29:19,150
we want W to contain Z if it otherwise

00:29:14,050 --> 00:29:21,310
we want it to have an empty string so

00:29:19,150 --> 00:29:24,100
the if-else form is pretty obvious how

00:29:21,310 --> 00:29:29,250
that works the ternary you should all be

00:29:24,100 --> 00:29:32,350
familiar with that the last one is just

00:29:29,250 --> 00:29:34,390
it's say it's looking at that double

00:29:32,350 --> 00:29:39,040
ampersand evaluating the left-hand side

00:29:34,390 --> 00:29:41,500
of it first as a boolean test there and

00:29:39,040 --> 00:29:43,690
then if that's true then it goes and

00:29:41,500 --> 00:29:46,540
does the right hand side which evaluates

00:29:43,690 --> 00:29:48,730
the Z which then assigns the z to the W

00:29:46,540 --> 00:29:50,860
but if it doesn't it's false then the

00:29:48,730 --> 00:29:52,930
value is going to be an empty string

00:29:50,860 --> 00:30:00,130
which then assigns to W so these are

00:29:52,930 --> 00:30:02,560
equivalent so it turns out the the if is

00:30:00,130 --> 00:30:07,900
slowest and we would expect that due to

00:30:02,560 --> 00:30:10,000
scoping the ternary is usually fastest

00:30:07,900 --> 00:30:13,420
but the biggest difference has to do

00:30:10,000 --> 00:30:15,720
with how complex our conditional is so

00:30:13,420 --> 00:30:18,100
if we make our conditional more complex

00:30:15,720 --> 00:30:21,400
then it may turn out that the ternary

00:30:18,100 --> 00:30:25,100
form is actually slow

00:30:21,400 --> 00:30:35,990
but the bottom two are pretty close it

00:30:25,100 --> 00:30:37,850
turns out let's look at indirection so

00:30:35,990 --> 00:30:40,970
if we have it were indexing into a hash

00:30:37,850 --> 00:30:43,220
or we have a hash ref that we index into

00:30:40,970 --> 00:30:45,800
how much performance hit is do we have

00:30:43,220 --> 00:30:52,690
with that in this one level of

00:30:45,800 --> 00:30:55,670
indirection and it turns out that

00:30:52,690 --> 00:30:58,250
indirection is only slightly slower it's

00:30:55,670 --> 00:30:59,930
almost imperceptible in the measuring I

00:30:58,250 --> 00:31:02,720
did there was really very little

00:30:59,930 --> 00:31:04,910
difference but in any measurement there

00:31:02,720 --> 00:31:07,330
was a slight difference that indirection

00:31:04,910 --> 00:31:10,460
does cost something but it's very small

00:31:07,330 --> 00:31:12,740
however if you have multiple in

00:31:10,460 --> 00:31:19,670
directions or if a statement within an

00:31:12,740 --> 00:31:21,200
index to the hash is is complex then it

00:31:19,670 --> 00:31:23,480
starts getting ugly and actually it can

00:31:21,200 --> 00:31:25,520
be quite slow I had a case where there

00:31:23,480 --> 00:31:29,900
was there were three endure levels of

00:31:25,520 --> 00:31:34,880
indirection and it took about five times

00:31:29,900 --> 00:31:37,210
as long which was puzzling to me that it

00:31:34,880 --> 00:31:40,370
it was it kind of ballooned like that

00:31:37,210 --> 00:31:42,410
also there's a difference when you're

00:31:40,370 --> 00:31:46,300
using indirection if you have if you're

00:31:42,410 --> 00:31:49,010
accessing a value using that indirection

00:31:46,300 --> 00:31:51,110
then that's pretty fast but if you're

00:31:49,010 --> 00:31:56,380
setting a value using indirection it's

00:31:51,110 --> 00:31:56,380
slower significantly slower

00:31:59,070 --> 00:32:07,830
should we have warnings should we turn

00:32:02,760 --> 00:32:11,730
on warnings of course we should but does

00:32:07,830 --> 00:32:14,220
it cost us anything it turns out there

00:32:11,730 --> 00:32:17,430
is a slight slowdown if we turn warnings

00:32:14,220 --> 00:32:22,490
on and we have a slightly larger memory

00:32:17,430 --> 00:32:26,540
footprint but it's not enough that

00:32:22,490 --> 00:33:12,030
anybody should care it's pretty minor

00:32:26,540 --> 00:33:15,660
yes yeah and and I don't want to quite

00:33:12,030 --> 00:33:17,430
jump ahead to the conclusion but yeah

00:33:15,660 --> 00:33:19,320
this is Perl after the optimization

00:33:17,430 --> 00:33:20,970
tidbits so it's just little tiny things

00:33:19,320 --> 00:33:23,850
that if you combine them the best of

00:33:20,970 --> 00:33:26,070
them all together maybe you'll get a you

00:33:23,850 --> 00:33:29,730
know like a three percent improvement in

00:33:26,070 --> 00:33:32,040
your run time most time it doesn't

00:33:29,730 --> 00:33:37,910
matter there's an excellent talk that

00:33:32,040 --> 00:33:42,170
was given by Tim bunts at Orlando in

00:33:37,910 --> 00:33:44,370
2014 I think this one was and about

00:33:42,170 --> 00:33:48,180
optimization and profiling and he talked

00:33:44,370 --> 00:33:50,340
about its NYT prof and he emphasized

00:33:48,180 --> 00:33:53,070
again and again in his talk

00:33:50,340 --> 00:33:56,340
do not optimize do to not do not

00:33:53,070 --> 00:33:58,380
optimize but if you do here's how you

00:33:56,340 --> 00:34:02,070
can figure out how to do it but don't do

00:33:58,380 --> 00:34:04,350
it and I agree most the time you don't

00:34:02,070 --> 00:34:07,820
need to worry about this this this talk

00:34:04,350 --> 00:34:10,110
is is my mostly for interest curiosity

00:34:07,820 --> 00:34:11,909
does it really make any difference what

00:34:10,110 --> 00:34:15,960
you do

00:34:11,909 --> 00:34:18,509
so um it's it's nice to know that things

00:34:15,960 --> 00:34:21,659
are not a big hit or that it doesn't

00:34:18,509 --> 00:34:25,079
matter let's continue and we're actually

00:34:21,659 --> 00:34:28,710
almost to that point here so should we

00:34:25,079 --> 00:34:30,240
come in our code of course we should

00:34:28,710 --> 00:34:32,879
come in our code but how much of a hit

00:34:30,240 --> 00:34:35,220
is it to actually comment our code so I

00:34:32,879 --> 00:34:38,940
ran a case where I had a hundred

00:34:35,220 --> 00:34:45,809
thousand lines of comments and then a

00:34:38,940 --> 00:34:48,299
couple lines of code and it turns out

00:34:45,809 --> 00:34:52,079
even with that huge amount of kind

00:34:48,299 --> 00:34:54,299
amount of comments it the the difference

00:34:52,079 --> 00:34:58,109
was almost unmeasurable it was

00:34:54,299 --> 00:35:00,779
measurable but it was so small that it

00:34:58,109 --> 00:35:04,140
was it made it because I always thought

00:35:00,779 --> 00:35:07,140
comments would be if you had 5,000 lines

00:35:04,140 --> 00:35:08,819
of comments and a 10,000 line file that

00:35:07,140 --> 00:35:10,740
it would make some difference it turns

00:35:08,819 --> 00:35:17,450
out it's almost no difference at all the

00:35:10,740 --> 00:35:22,519
comments are clearly worth doing case 30

00:35:17,450 --> 00:35:24,930
they're not not they're not macho yes

00:35:22,519 --> 00:35:27,119
although I do know the case this is not

00:35:24,930 --> 00:35:29,309
a perl programming case I do have worked

00:35:27,119 --> 00:35:33,089
with a guy who had he had actually

00:35:29,309 --> 00:35:35,670
10,000 lines of code to about 30 lines

00:35:33,089 --> 00:35:38,190
of code or so 10,000 lines of comments

00:35:35,670 --> 00:35:41,220
to 30 lines of code it was written in

00:35:38,190 --> 00:35:42,660
Ada and he had written a tool to strip

00:35:41,220 --> 00:35:45,720
comments out so you could actually see

00:35:42,660 --> 00:35:48,029
the code and I thought that was kind of

00:35:45,720 --> 00:35:49,799
serious overkill but just be aware

00:35:48,029 --> 00:35:52,170
comments don't hurt you about that much

00:35:49,799 --> 00:35:54,539
at all let's look at doing a split

00:35:52,170 --> 00:35:56,130
versus a regular expression now there's

00:35:54,539 --> 00:35:57,599
a lot of variables in here because if

00:35:56,130 --> 00:35:59,460
your regular expression gets complicated

00:35:57,599 --> 00:36:01,859
it's going to probably hit both the

00:35:59,460 --> 00:36:05,250
split and your your regular expression

00:36:01,859 --> 00:36:07,079
by itself so if we compare these two and

00:36:05,250 --> 00:36:08,339
I'm not showing a particular regular

00:36:07,079 --> 00:36:10,200
expression in here I'm just kind of

00:36:08,339 --> 00:36:11,730
leaving that blank you have to do

00:36:10,200 --> 00:36:13,049
captures in there and all that sort of

00:36:11,730 --> 00:36:15,809
thing

00:36:13,049 --> 00:36:18,029
it turns out if you do that that the

00:36:15,809 --> 00:36:22,559
regular expression is actually faster

00:36:18,029 --> 00:36:26,450
and then if you use M and G regular

00:36:22,559 --> 00:36:30,960
expression suffixes it's even faster

00:36:26,450 --> 00:36:33,420
so split is very handy it's nice to read

00:36:30,960 --> 00:36:36,450
it's very maintainable regular

00:36:33,420 --> 00:36:37,769
expressions are harder but you do get

00:36:36,450 --> 00:36:42,299
better performance out of the regular

00:36:37,769 --> 00:36:44,809
expressions now one of the algorithmic

00:36:42,299 --> 00:36:47,940
solutions is to do slurping instead of

00:36:44,809 --> 00:36:52,619
reading record bait or doing record

00:36:47,940 --> 00:36:55,079
based input what this does is it

00:36:52,619 --> 00:36:57,479
minimizes our disk cache so instead of

00:36:55,079 --> 00:36:58,769
hitting the disk therefore every time we

00:36:57,479 --> 00:37:02,549
want to do a read or hitting our disk

00:36:58,769 --> 00:37:04,829
cache we only hit it once if you have

00:37:02,549 --> 00:37:07,619
small amount of data you're reading like

00:37:04,829 --> 00:37:08,789
a file of a hundred or even a thousand

00:37:07,619 --> 00:37:10,619
lines it probably won't make any

00:37:08,789 --> 00:37:12,299
difference but if you have a two

00:37:10,619 --> 00:37:15,420
gigabyte file that you're processing

00:37:12,299 --> 00:37:17,369
it's a log file it could make a big

00:37:15,420 --> 00:37:19,769
difference but you need to make sure you

00:37:17,369 --> 00:37:24,479
don't overflow your RAM and I'm going to

00:37:19,769 --> 00:37:27,569
swap I had a guy knew who he had every

00:37:24,479 --> 00:37:30,719
day had to process two gig of log files

00:37:27,569 --> 00:37:31,380
and he was reading them a record at a

00:37:30,719 --> 00:37:37,140
time

00:37:31,380 --> 00:37:42,440
and it took about an hour for it to

00:37:37,140 --> 00:37:47,009
process that two gig he switched it to

00:37:42,440 --> 00:37:50,190
doing a slurp so he'd slurp that whole

00:37:47,009 --> 00:37:53,279
file into RAM and then he would process

00:37:50,190 --> 00:37:56,579
it in RAM and it knocked it down to

00:37:53,279 --> 00:38:00,059
about a minute so it can make a huge

00:37:56,579 --> 00:38:02,749
difference but with small files you

00:38:00,059 --> 00:38:02,749
won't be able to tell

00:38:10,279 --> 00:38:17,880
yeah so he said that if you use pearl IO

00:38:13,440 --> 00:38:20,059
reads it in 8k chunks so you manure

00:38:17,880 --> 00:38:22,049
performance there as well

00:38:20,059 --> 00:38:27,029
now let's talk about some of the

00:38:22,049 --> 00:38:29,609
weaknesses in testing NYT Prof tends to

00:38:27,029 --> 00:38:31,259
over allocate time to the last statement

00:38:29,609 --> 00:38:32,759
in a block and that's because there's

00:38:31,259 --> 00:38:34,019
stuff that needs to wrap up at the end

00:38:32,759 --> 00:38:36,869
of the block and instead of just

00:38:34,019 --> 00:38:39,989
attaching it to the closing brace it

00:38:36,869 --> 00:38:43,109
attaches it to the last statement in the

00:38:39,989 --> 00:38:45,239
block no matter what it is so that's a

00:38:43,109 --> 00:38:46,589
problem so I had to make sure I had

00:38:45,239 --> 00:38:49,499
dummy statements that were doing

00:38:46,589 --> 00:38:53,549
anything then I was testing as the last

00:38:49,499 --> 00:38:55,769
statement in a code block there's

00:38:53,549 --> 00:39:05,130
probably some other funny things about

00:38:55,769 --> 00:39:07,170
NYT prof it's my daughter there's

00:39:05,130 --> 00:39:08,969
probably some other funny things in NYT

00:39:07,170 --> 00:39:13,380
prof that we don't know about the little

00:39:08,969 --> 00:39:15,150
quirks so that's a little thing that

00:39:13,380 --> 00:39:19,640
might be a problem also there are some

00:39:15,150 --> 00:39:19,640
invisible internal pearl optimizations

00:39:20,059 --> 00:39:28,349
statement order actually does matter and

00:39:24,710 --> 00:39:34,319
it's hard to quantify the actual value

00:39:28,349 --> 00:39:36,329
of each line and then of course the

00:39:34,319 --> 00:39:37,680
recent releases are probably have some

00:39:36,329 --> 00:39:40,799
optimizations in there that will

00:39:37,680 --> 00:39:45,950
invalidate some of this data but the

00:39:40,799 --> 00:39:45,950
summary is most this doesn't matter

00:39:49,040 --> 00:39:54,510
the things that we learned from this is

00:39:51,600 --> 00:39:57,720
that scoping actually do cost us

00:39:54,510 --> 00:40:00,090
something so that we shouldn't use

00:39:57,720 --> 00:40:01,590
unnecessary scope most of us don't so

00:40:00,090 --> 00:40:03,990
that wouldn't be an issue but beware

00:40:01,590 --> 00:40:05,550
that scoping does cost and that we

00:40:03,990 --> 00:40:08,040
really should focus on the human cost

00:40:05,550 --> 00:40:09,720
that's the real expensive part of what

00:40:08,040 --> 00:40:12,660
we do and that's our maintenance and

00:40:09,720 --> 00:40:13,470
readability in almost all cases nothing

00:40:12,660 --> 00:40:16,980
else matters

00:40:13,470 --> 00:40:18,930
and the biggest optimizations gains

00:40:16,980 --> 00:40:20,670
we're gonna get isn't due to picking a

00:40:18,930 --> 00:40:21,750
poster and increment versus a pre

00:40:20,670 --> 00:40:24,480
increment it's going to be an

00:40:21,750 --> 00:40:26,970
algorithmic change those are where the

00:40:24,480 --> 00:40:28,530
big performance gains are however if you

00:40:26,970 --> 00:40:31,380
really do need to optimize and you've

00:40:28,530 --> 00:40:35,730
tweaked absolutely everything else this

00:40:31,380 --> 00:40:37,620
gives you some informed choices if you

00:40:35,730 --> 00:40:40,260
want further information you can go to

00:40:37,620 --> 00:40:44,160
the Pearl dock stuff for NYT proof

00:40:40,260 --> 00:40:45,990
benchmark you can also look look at sort

00:40:44,160 --> 00:40:47,790
at some optimizations of sorting

00:40:45,990 --> 00:40:49,260
algorithms I have a presentation at the

00:40:47,790 --> 00:40:51,140
May 2014

00:40:49,260 --> 00:40:53,250
open west that's available on YouTube

00:40:51,140 --> 00:40:59,010
streamlining and simplifying your Perl

00:40:53,250 --> 00:41:03,800
code using map grep and sort do we have

00:40:59,010 --> 00:41:03,800
any comments or questions yes

00:41:14,849 --> 00:41:19,059
you know what I agree and I've been

00:41:17,349 --> 00:41:21,700
telling people that for years because

00:41:19,059 --> 00:41:23,470
every time I looked at a thing something

00:41:21,700 --> 00:41:25,869
that some code that I felt needed to be

00:41:23,470 --> 00:41:28,000
optimized I would say oh it's got to be

00:41:25,869 --> 00:41:30,819
in the i/o or it's got to be in this or

00:41:28,000 --> 00:41:34,089
that and then when I actually profile it

00:41:30,819 --> 00:41:37,380
I find out it's somewhere else and it's

00:41:34,089 --> 00:41:37,380
usually not where expected

00:41:54,760 --> 00:41:59,510
yeah and there's a great straight

00:41:57,530 --> 00:42:02,030
statement that's attributed to lots of

00:41:59,510 --> 00:42:04,100
different people Tony Hoare or Donald

00:42:02,030 --> 00:42:06,170
Knuth go figure I don't know which who

00:42:04,100 --> 00:42:09,620
actually said it but it was premature

00:42:06,170 --> 00:42:26,120
optimization is the root of all evil and

00:42:09,620 --> 00:42:28,550
I've there's there's lots of variables

00:42:26,120 --> 00:42:30,290
in there that you will mess things up

00:42:28,550 --> 00:42:33,310
and change the whole thing is very

00:42:30,290 --> 00:42:33,310
dynamic yes

00:42:44,180 --> 00:42:48,550
bridge examination of a bench market so

00:42:46,370 --> 00:42:52,390
I think masters would be less beautiful

00:42:48,550 --> 00:42:56,140
but that's fine if the

00:42:52,390 --> 00:42:57,700
before they light but it turns out maybe

00:42:56,140 --> 00:42:59,920
somewhere else in your codebase it's

00:42:57,700 --> 00:43:02,589
used at IKEA introducing these millions

00:42:59,920 --> 00:43:04,720
of times then you'll see it when your

00:43:02,589 --> 00:43:07,359
profile a larger application but when

00:43:04,720 --> 00:43:09,750
you're looking at the profiling part of

00:43:07,359 --> 00:43:12,190
that routine or that smaller molecule

00:43:09,750 --> 00:43:14,490
radar so that's the other that's the

00:43:12,190 --> 00:43:17,380
other thing that can surprise people is

00:43:14,490 --> 00:43:19,539
the author of the code may not always

00:43:17,380 --> 00:43:21,279
understand the use cases especially when

00:43:19,539 --> 00:43:23,970
they come two or three years down the

00:43:21,279 --> 00:43:23,970
road in the future

00:43:24,640 --> 00:43:27,780
profiling could

00:43:28,960 --> 00:43:33,020
exactly exactly

00:43:30,800 --> 00:43:35,030
so profiling really is key if you if you

00:43:33,020 --> 00:43:54,230
need to optimize there's there's no way

00:43:35,030 --> 00:43:56,600
around that yes yes yes in in that case

00:43:54,230 --> 00:43:58,609
I did not check for doing shift shift

00:43:56,600 --> 00:44:01,550
shift

00:43:58,609 --> 00:44:03,560
in those cases I mean my preference has

00:44:01,550 --> 00:44:06,320
always been to grab them all as a list

00:44:03,560 --> 00:44:09,230
and just have a list on the left hand

00:44:06,320 --> 00:44:11,240
side that's that's got the variables

00:44:09,230 --> 00:44:12,770
mine they all have the name I'm not

00:44:11,240 --> 00:44:17,030
pulling them off in some sort of array

00:44:12,770 --> 00:44:18,320
that way it's real clean and that was

00:44:17,030 --> 00:44:19,310
also because I thought I was

00:44:18,320 --> 00:44:21,530
uncomfortable to shift I'm not

00:44:19,310 --> 00:44:22,730
uncomfortable to shift anymore but there

00:44:21,530 --> 00:44:26,690
is something a little bit uncomfortable

00:44:22,730 --> 00:44:31,040
about shift is it operates on different

00:44:26,690 --> 00:44:34,550
things depending on its context so

00:44:31,040 --> 00:44:38,740
that's could be a little problem it will

00:44:34,550 --> 00:44:38,740
go to the you want

00:45:02,120 --> 00:45:05,330
therefore beach

00:45:21,529 --> 00:45:27,869
yeah it's it's benchmarking is actually

00:45:24,660 --> 00:45:30,299
really tough because there's so much

00:45:27,869 --> 00:45:33,630
external stuff that can affect it I mean

00:45:30,299 --> 00:45:35,190
if if you have other I mean if it's a

00:45:33,630 --> 00:45:37,349
multi-user system and somebody decides

00:45:35,190 --> 00:45:38,670
to log on while you're benchmarking yeah

00:45:37,349 --> 00:45:47,960
good luck with that because you just got

00:45:38,670 --> 00:45:47,960
swapped out yeah

00:45:53,650 --> 00:46:01,620
and that's how I do all my benchmark

00:45:58,620 --> 00:46:01,620
Sawyer

00:46:07,770 --> 00:46:11,870
they become a DJ

00:46:25,180 --> 00:46:35,910
and it's called pre bench dumb bench

00:46:29,700 --> 00:46:35,910
okay okay

00:46:46,590 --> 00:46:58,320
yeah it's it's it's not as dumb yes

00:47:03,650 --> 00:47:14,600
so 52018 I've added some things like if

00:47:08,540 --> 00:47:19,880
you were it's very dated so I can a in a

00:47:14,600 --> 00:47:27,640
P have two bits different so a B and a C

00:47:19,880 --> 00:47:27,640
only have the letters sure

00:47:40,730 --> 00:47:53,309
yeah you're right there's a lot of the

00:47:51,420 --> 00:47:54,750
tests that are very data dependent and

00:47:53,309 --> 00:47:57,839
it's and it's hard to know without

00:47:54,750 --> 00:47:59,329
actually inspecting the code underneath

00:47:57,839 --> 00:48:02,039
to see you exactly what's going on

00:47:59,329 --> 00:48:04,289
because I ran into funny cases like that

00:48:02,039 --> 00:48:05,970
regular why is this acting so strange I

00:48:04,289 --> 00:48:08,809
changes one thing and all sudden it's

00:48:05,970 --> 00:48:08,809
balloons

00:48:28,780 --> 00:49:05,280
and yeah that's it's interesting sure

00:49:07,080 --> 00:49:13,240
well that's it we're out of time

00:49:09,880 --> 00:49:15,940
I want to thank Larry for Perl to begin

00:49:13,240 --> 00:49:17,140
with and Bluehost who I did some of the

00:49:15,940 --> 00:49:19,690
research under and zip recruiter who

00:49:17,140 --> 00:49:21,670
allowed me to continue that and of

00:49:19,690 --> 00:49:24,820
course Tim bunts for NYT prof which is

00:49:21,670 --> 00:49:26,940
kind of a fun tool and very useful thank

00:49:24,820 --> 00:49:26,940

YouTube URL: https://www.youtube.com/watch?v=bSd8FwdIALY


