Title: Steven Lembark - "Having a Meta-Adventure: Metadata-driven testing of Advent "
Publication date: 2018-06-21
Playlist: TPC 2018 in SLC
Description: 
	The MadMongers decided to write Adventure in Perl as an exercise in parsing and data-driven code. Then they had to test itâ€¦ Writing tests for all of the ghosties and tolls, weapons and toys would have left them all typing forever. Using metadata-driven testing and a sacred bottle of Perl we generated thousands of tests just by rubbing our magic keyboards! This talk describes the basics of metadata-driven testing, how Object::Exercise uses the data, and how to look at defining tests with data.
Captions: 
	00:00:00,000 --> 00:00:06,569
how many people here actually have to

00:00:02,490 --> 00:00:08,250
benchmark things you actually people

00:00:06,569 --> 00:00:10,139
scream at you things are too slow you

00:00:08,250 --> 00:00:13,139
got to figure out guess what I'm going

00:00:10,139 --> 00:00:15,630
to be talking about are a couple of

00:00:13,139 --> 00:00:17,640
things you can do just to stay sane

00:00:15,630 --> 00:00:20,160
getting them done now the first thing is

00:00:17,640 --> 00:00:22,769
there are two kinds of benchmarks one

00:00:20,160 --> 00:00:25,980
has to do with timing which usually in

00:00:22,769 --> 00:00:28,349
the lies in damn wise Department you

00:00:25,980 --> 00:00:30,630
know ours is two times faster we've all

00:00:28,349 --> 00:00:33,149
seen those you can always hack a

00:00:30,630 --> 00:00:35,070
benchmark to be as stupid as you want it

00:00:33,149 --> 00:00:37,559
to be what I'm trying to here show you

00:00:35,070 --> 00:00:38,910
how to avoid doing some of that the

00:00:37,559 --> 00:00:40,800
other kind of benchmarks we all get into

00:00:38,910 --> 00:00:43,140
our functionality does something

00:00:40,800 --> 00:00:44,430
actually accomplish a thing and I'm not

00:00:43,140 --> 00:00:46,020
going to talk about that today

00:00:44,430 --> 00:00:49,050
tomorrow I'll get into some of that with

00:00:46,020 --> 00:00:50,670
testing but today I'm just really going

00:00:49,050 --> 00:00:52,340
to talk about time the interesting about

00:00:50,670 --> 00:00:54,600
is that performance and functionality

00:00:52,340 --> 00:00:56,100
you get different things out of them

00:00:54,600 --> 00:00:57,750
they have different needs but a lot of

00:00:56,100 --> 00:00:59,579
the requirements is simple you have to

00:00:57,750 --> 00:01:03,629
break things into atomic tests you have

00:00:59,579 --> 00:01:05,339
to isolate what you're doing so you can

00:01:03,629 --> 00:01:07,860
use what I'm talking about here for some

00:01:05,339 --> 00:01:10,080
functionality the first thing to

00:01:07,860 --> 00:01:12,270
remember about benchmark is none of

00:01:10,080 --> 00:01:15,509
these run in isolation anything you do

00:01:12,270 --> 00:01:17,159
with code runs on a computer if you're

00:01:15,509 --> 00:01:19,320
running in a virtual machine if you're

00:01:17,159 --> 00:01:20,909
running on a heavily loaded machine if

00:01:19,320 --> 00:01:22,950
nobody's watching the test and you don't

00:01:20,909 --> 00:01:26,759
realize that a cat sat on the keyboard

00:01:22,950 --> 00:01:29,430
in there you can get all kinds of

00:01:26,759 --> 00:01:31,470
problems with these so make sure your

00:01:29,430 --> 00:01:35,070
environment is stable that's the first

00:01:31,470 --> 00:01:39,630
thing to do the simplest one people here

00:01:35,070 --> 00:01:41,369
use time okay that may be all you need

00:01:39,630 --> 00:01:43,439
if you type time here you know whatever

00:01:41,369 --> 00:01:45,060
your thing is and hit return and it

00:01:43,439 --> 00:01:47,159
takes a tenth of a second and you say

00:01:45,060 --> 00:01:51,570
gee why do you think it's slow you may

00:01:47,159 --> 00:01:52,920
be done a lot of times people don't pay

00:01:51,570 --> 00:01:54,689
attention they think everything should

00:01:52,920 --> 00:01:57,990
be faster and they just complain who

00:01:54,689 --> 00:02:00,630
knows but time can be useful for a lot

00:01:57,990 --> 00:02:02,790
of things a lot more than people use it

00:02:00,630 --> 00:02:05,360
for the most important thing with time

00:02:02,790 --> 00:02:07,920
is run it at different times of the day

00:02:05,360 --> 00:02:09,869
run something multiple times and get an

00:02:07,920 --> 00:02:11,160
average if you run something once you've

00:02:09,869 --> 00:02:13,590
got no idea how long it takes

00:02:11,160 --> 00:02:15,960
to go we've all heard the Pearl is too

00:02:13,590 --> 00:02:17,790
slow kind of things there's one talk I

00:02:15,960 --> 00:02:21,570
have on lies damned lies and benchmarks

00:02:17,790 --> 00:02:23,820
that compares pearl and use doing

00:02:21,570 --> 00:02:25,680
something with shell you find for

00:02:23,820 --> 00:02:27,810
example people type ls' and that's a

00:02:25,680 --> 00:02:30,840
pearl with a glob and pearl takes longer

00:02:27,810 --> 00:02:33,030
well yeah because the LS is a special

00:02:30,840 --> 00:02:34,890
purpose if you want to find things by

00:02:33,030 --> 00:02:36,480
the time you're done piping ten stages

00:02:34,890 --> 00:02:39,720
of something it does take longer than

00:02:36,480 --> 00:02:41,220
pearl so I can't compare maybe what

00:02:39,720 --> 00:02:43,170
you're doing by running something with

00:02:41,220 --> 00:02:44,640
pearl running through the shell type

00:02:43,170 --> 00:02:47,040
something shebang and see if you get a

00:02:44,640 --> 00:02:48,600
difference in time in the startup maybe

00:02:47,040 --> 00:02:51,680
your environment just takes a long time

00:02:48,600 --> 00:02:54,540
below things into core get a baseline

00:02:51,680 --> 00:02:56,220
this is a nice baseline if bash and

00:02:54,540 --> 00:02:58,410
pearl take the same time to start up

00:02:56,220 --> 00:03:01,200
then at least you know that's not your

00:02:58,410 --> 00:03:03,180
immediate problem what is that baseline

00:03:01,200 --> 00:03:04,740
tell us that you know five busy

00:03:03,180 --> 00:03:08,460
millionths of a second Opterons you're

00:03:04,740 --> 00:03:11,730
fast I know basically it really if those

00:03:08,460 --> 00:03:15,450
were significantly different figure it

00:03:11,730 --> 00:03:18,030
out for example a lot of systems back in

00:03:15,450 --> 00:03:20,640
the day booted off of NFS mounted

00:03:18,030 --> 00:03:23,220
platforms you might find that being bash

00:03:20,640 --> 00:03:25,380
was on a local drive and pearl was

00:03:23,220 --> 00:03:28,020
mounted through NFS over a wide area

00:03:25,380 --> 00:03:30,690
network over a 2400 baud modem with

00:03:28,020 --> 00:03:33,330
point-to-point pearl isn't gonna run as

00:03:30,690 --> 00:03:37,350
fast make sure that you've got something

00:03:33,330 --> 00:03:38,730
consistent as a baseline a couple things

00:03:37,350 --> 00:03:42,360
you can do to control overhead I'll talk

00:03:38,730 --> 00:03:44,220
about front tempo FS is a great thing if

00:03:42,360 --> 00:03:45,750
you're gonna write temporary data if

00:03:44,220 --> 00:03:47,880
you're gonna start up if you're gonna

00:03:45,750 --> 00:03:50,100
read files stick the whole thing on temp

00:03:47,880 --> 00:03:54,830
FS and save yourself from things like

00:03:50,100 --> 00:03:56,730
disk overhead sands heavily use networks

00:03:54,830 --> 00:03:58,410
heavily use disk drives

00:03:56,730 --> 00:04:00,060
does anyone here really want to be

00:03:58,410 --> 00:04:03,170
competing with a data Lake when you're

00:04:00,060 --> 00:04:05,370
trying to read your files probably not

00:04:03,170 --> 00:04:07,020
obviously keeping the system load to a

00:04:05,370 --> 00:04:09,090
minimum if you're using a virtual

00:04:07,020 --> 00:04:11,760
machine that may be hard to do but at

00:04:09,090 --> 00:04:13,620
least look at it you may be able if

00:04:11,760 --> 00:04:15,390
you're doing benchmarks to have somebody

00:04:13,620 --> 00:04:17,850
up the priority on your virtual machine

00:04:15,390 --> 00:04:20,160
you may be able to find either a bare

00:04:17,850 --> 00:04:22,840
metal or a real time virtual machine to

00:04:20,160 --> 00:04:24,550
run the test on if you can do that

00:04:22,840 --> 00:04:26,350
I'll talk a little bit more about it

00:04:24,550 --> 00:04:29,080
later if a task set can be a big help

00:04:26,350 --> 00:04:31,840
for this also by Isis by associating

00:04:29,080 --> 00:04:34,720
what you're doing with one core and that

00:04:31,840 --> 00:04:37,960
can improve your cashing it can save you

00:04:34,720 --> 00:04:39,490
on scheduling also and you know a lot of

00:04:37,960 --> 00:04:43,540
the cons are you know how long does

00:04:39,490 --> 00:04:45,490
something take and it depends you may be

00:04:43,540 --> 00:04:48,310
timing something that does a lot of

00:04:45,490 --> 00:04:50,830
Disgaea at that point what you're really

00:04:48,310 --> 00:04:52,930
timing is how effective is the disk IO

00:04:50,830 --> 00:04:55,870
in my computer how effective is the

00:04:52,930 --> 00:04:57,430
driver am I using virtual drivers a lot

00:04:55,870 --> 00:04:59,860
of people don't realize if you have a

00:04:57,430 --> 00:05:01,600
virtual machine and you install a kernel

00:04:59,860 --> 00:05:04,590
that's not virtual machine aware you're

00:05:01,600 --> 00:05:07,810
using fake drivers for everything well

00:05:04,590 --> 00:05:09,280
make sure that the kernel is designed to

00:05:07,810 --> 00:05:10,900
run in the environment it's running in

00:05:09,280 --> 00:05:13,630
or you don't know what your timing you

00:05:10,900 --> 00:05:15,970
may be timing bad drivers not your own

00:05:13,630 --> 00:05:20,620
code and then at a certain point it make

00:05:15,970 --> 00:05:23,020
it hard to tell that so time for

00:05:20,620 --> 00:05:25,660
hardware time for software time for IO

00:05:23,020 --> 00:05:28,180
try and separate them do things that

00:05:25,660 --> 00:05:31,630
manipulate each of those and you can

00:05:28,180 --> 00:05:34,450
compare the times for them realistic

00:05:31,630 --> 00:05:36,039
tests are hard to write because you have

00:05:34,450 --> 00:05:40,030
to isolate each of the things you're

00:05:36,039 --> 00:05:43,450
doing so one thing is use benchmark

00:05:40,030 --> 00:05:45,430
module people use that a couple okay

00:05:43,450 --> 00:05:48,190
this will do most of what you need it to

00:05:45,430 --> 00:05:51,220
it will do it better than time use the

00:05:48,190 --> 00:05:52,810
high res wall clock option just about

00:05:51,220 --> 00:05:55,150
everyone has access to the high

00:05:52,810 --> 00:05:56,860
resolution wall clock and timing things

00:05:55,150 --> 00:05:59,200
to the nearest second may not help you

00:05:56,860 --> 00:06:01,990
very much unless you're timing something

00:05:59,200 --> 00:06:03,460
that takes overnight I've seen a lot of

00:06:01,990 --> 00:06:04,990
people they have the all these great

00:06:03,460 --> 00:06:06,880
benchmarks that forgot to use high res

00:06:04,990 --> 00:06:11,770
and everything got rounded up to there a

00:06:06,880 --> 00:06:14,760
second test atomic units of code that's

00:06:11,770 --> 00:06:17,590
another thing if if you think about it

00:06:14,760 --> 00:06:20,320
the way you write tests is a lot of the

00:06:17,590 --> 00:06:21,850
same way you write benchmarks you want

00:06:20,320 --> 00:06:24,639
it you want to see how long does one

00:06:21,850 --> 00:06:27,729
thing take another thing take if you're

00:06:24,639 --> 00:06:29,800
gonna if you're have code that might run

00:06:27,729 --> 00:06:31,479
in variable environments test your

00:06:29,800 --> 00:06:32,950
exception handling you might find

00:06:31,479 --> 00:06:35,349
everything runs just fine until

00:06:32,950 --> 00:06:36,160
something fails and then it takes 75

00:06:35,349 --> 00:06:38,560
seconds to this

00:06:36,160 --> 00:06:41,260
cover that in DNS for a help file isn't

00:06:38,560 --> 00:06:42,580
available even end-to-end testing if

00:06:41,260 --> 00:06:45,220
you've got to finish an end-to-end test

00:06:42,580 --> 00:06:46,510
great but test the pieces of it along

00:06:45,220 --> 00:06:48,250
the way to try and identify the

00:06:46,510 --> 00:06:51,910
bottlenecks if you're running a virtual

00:06:48,250 --> 00:06:55,900
machine people here understand time

00:06:51,910 --> 00:06:58,900
slicing what you'll find is if you time

00:06:55,900 --> 00:07:01,210
things inside of Perl you're not gonna

00:06:58,900 --> 00:07:02,950
know about stolen time you're not going

00:07:01,210 --> 00:07:04,990
to know about the time that your virtual

00:07:02,950 --> 00:07:09,250
machine didn't have access to the CPU

00:07:04,990 --> 00:07:10,960
the time in the OS level probably does

00:07:09,250 --> 00:07:12,640
have access to that because the kernel

00:07:10,960 --> 00:07:16,390
does a better job of keeping track of

00:07:12,640 --> 00:07:19,090
that the so what you may find is that

00:07:16,390 --> 00:07:21,820
your wall clock time versus the system

00:07:19,090 --> 00:07:24,460
time maybe it wide variance depending on

00:07:21,820 --> 00:07:27,490
how loaded the server is if you do a

00:07:24,460 --> 00:07:30,310
time this and I do a million copies of

00:07:27,490 --> 00:07:32,200
just an empty subroutine I should be

00:07:30,310 --> 00:07:34,420
able to watch that run or it may be 10

00:07:32,200 --> 00:07:36,430
million 100 million but I should be able

00:07:34,420 --> 00:07:40,510
to watch it run at a hundred percent of

00:07:36,430 --> 00:07:41,980
the CPU on one core uninterrupted if I

00:07:40,510 --> 00:07:44,860
do something like this and I'm running

00:07:41,980 --> 00:07:46,780
at 50 percent of the CPU don't waste

00:07:44,860 --> 00:07:48,970
your time find out why you're not

00:07:46,780 --> 00:07:51,190
chewing up a core right there you might

00:07:48,970 --> 00:07:55,510
have a heavily loaded system it might be

00:07:51,190 --> 00:07:57,820
that your job was nice whatever it is

00:07:55,510 --> 00:08:00,460
find out because until you can run

00:07:57,820 --> 00:08:05,140
something unfettered you're not

00:08:00,460 --> 00:08:06,550
benchmarking it so for example you know

00:08:05,140 --> 00:08:08,710
I ran this thing just now on this

00:08:06,550 --> 00:08:10,600
notebook and running a million

00:08:08,710 --> 00:08:12,730
iterations wasn't even a I got a

00:08:10,600 --> 00:08:14,710
negative execution time so even with

00:08:12,730 --> 00:08:17,500
high res wall clock I couldn't tell

00:08:14,710 --> 00:08:20,410
that's a good sign that nothing's

00:08:17,500 --> 00:08:22,650
interfering with me if I run a million

00:08:20,410 --> 00:08:26,140
of those things and it takes 15 seconds

00:08:22,650 --> 00:08:28,240
you got a problem again solve that I

00:08:26,140 --> 00:08:29,919
know so many places where people have

00:08:28,240 --> 00:08:31,390
said oh we knew what the system wasn't

00:08:29,919 --> 00:08:33,900
running right but we ran the benchmark

00:08:31,390 --> 00:08:36,900
anyway we just don't waste your time

00:08:33,900 --> 00:08:39,820
come up with benchmarks that progress

00:08:36,900 --> 00:08:42,760
test something small to something larger

00:08:39,820 --> 00:08:45,970
if one test if one of these benchmarks

00:08:42,760 --> 00:08:47,620
gives you something wacky stop fix it

00:08:45,970 --> 00:08:51,010
find out what's wrong until you have a

00:08:47,620 --> 00:08:53,350
working baseline

00:08:51,010 --> 00:08:55,120
another thing you can do both of these

00:08:53,350 --> 00:08:59,890
are easy to put into they're just a

00:08:55,120 --> 00:09:03,100
pearl - Uihlein open dev no a million

00:08:59,890 --> 00:09:06,400
times if you can't do that a million

00:09:03,100 --> 00:09:10,300
times quickly find out why again that's

00:09:06,400 --> 00:09:12,850
a classic sign of that is with Linux if

00:09:10,300 --> 00:09:18,010
you're running something in Xen or

00:09:12,850 --> 00:09:19,720
VMware and you the person who installed

00:09:18,010 --> 00:09:22,750
the kernel didn't know that they have to

00:09:19,720 --> 00:09:26,140
install a hypervisor or where kernel

00:09:22,750 --> 00:09:28,030
you're using fake drivers which means

00:09:26,140 --> 00:09:29,560
every time you poke what you think is a

00:09:28,030 --> 00:09:31,930
disk drive you're going into software

00:09:29,560 --> 00:09:34,000
that emulates the disk drive so you're

00:09:31,930 --> 00:09:36,700
really not testing your code you're

00:09:34,000 --> 00:09:40,960
testing how slow the fake drivers are if

00:09:36,700 --> 00:09:43,870
you run something in QA mu it is slower

00:09:40,960 --> 00:09:45,700
than frozen molasses because of all the

00:09:43,870 --> 00:09:48,040
emulation of the CPU level and the

00:09:45,700 --> 00:09:49,570
device driver levels don't benchmark

00:09:48,040 --> 00:09:52,300
things ins unless you're really running

00:09:49,570 --> 00:09:53,710
at day to day ins in QEMU at that point

00:09:52,300 --> 00:09:55,390
that may be the appropriate benchmark

00:09:53,710 --> 00:09:57,790
but at least establish a baseline that

00:09:55,390 --> 00:10:00,870
says to people look this is how long it

00:09:57,790 --> 00:10:03,490
takes the CPU to run don't blame my coat

00:10:00,870 --> 00:10:05,080
without this bet without these baselines

00:10:03,490 --> 00:10:07,240
you're toast because you've got no way

00:10:05,080 --> 00:10:10,170
to prove what's going on when you're

00:10:07,240 --> 00:10:12,310
running a benchmark nice a copy of top

00:10:10,170 --> 00:10:14,410
top will tell you a few things it'll

00:10:12,310 --> 00:10:17,410
tell you how many jobs are in the run

00:10:14,410 --> 00:10:20,650
queue if you've got a 5 you know an

00:10:17,410 --> 00:10:23,290
eight CPU machine and you got 45 jobs in

00:10:20,650 --> 00:10:25,000
the run queue you got a problem because

00:10:23,290 --> 00:10:29,260
you're not gonna get enough scheduled

00:10:25,000 --> 00:10:32,710
time notice if your process is jumping

00:10:29,260 --> 00:10:35,110
between cores you've if you go on to top

00:10:32,710 --> 00:10:37,000
you can see which core you were running

00:10:35,110 --> 00:10:40,120
on last it's one of the options you can

00:10:37,000 --> 00:10:42,790
put that where you can see it if you if

00:10:40,120 --> 00:10:44,620
that number keeps changing then you're

00:10:42,790 --> 00:10:46,870
really testing whether or not your l1

00:10:44,620 --> 00:10:48,280
and l2 cache Association is effective

00:10:46,870 --> 00:10:52,780
you're not testing whether your code

00:10:48,280 --> 00:10:54,790
runs well if you're if you fork or if

00:10:52,780 --> 00:10:56,800
you thread notice how many threads

00:10:54,790 --> 00:11:00,010
you've got if something accidentally

00:10:56,800 --> 00:11:01,080
creates 800 threads on an eight-core

00:11:00,010 --> 00:11:02,850
system

00:11:01,080 --> 00:11:04,560
you've got property you can't bench

00:11:02,850 --> 00:11:08,100
market at that point find out why you're

00:11:04,560 --> 00:11:10,350
creating 800 processes if you look in

00:11:08,100 --> 00:11:13,230
top you'll notice one column for I await

00:11:10,350 --> 00:11:16,800
on a well-regulated machine that should

00:11:13,230 --> 00:11:18,029
always be zero in a modern system with

00:11:16,800 --> 00:11:20,459
the amount of memory that these things

00:11:18,029 --> 00:11:21,930
have you should never really see i/o

00:11:20,459 --> 00:11:23,579
eight unless you're in the middle of the

00:11:21,930 --> 00:11:26,310
backups or someone is running the query

00:11:23,579 --> 00:11:27,600
from hell on a database server but in

00:11:26,310 --> 00:11:29,130
both of those cases you don't to be

00:11:27,600 --> 00:11:30,990
testing anything because the kernel

00:11:29,130 --> 00:11:32,850
itself is blocked it's doing its in

00:11:30,990 --> 00:11:35,790
kernel land it's not out user land where

00:11:32,850 --> 00:11:37,350
it can test your code you want to runs

00:11:35,790 --> 00:11:39,360
even if you're running something that

00:11:37,350 --> 00:11:40,920
does i/o you don't want to see a lot of

00:11:39,360 --> 00:11:42,600
very high i/o weight because all you're

00:11:40,920 --> 00:11:45,149
proving is that your code blocks very

00:11:42,600 --> 00:11:47,100
effectively and tempo FS helps on that

00:11:45,149 --> 00:11:49,470
if you run yours if you're doing a lot

00:11:47,100 --> 00:11:54,060
of i/o you're testing ETL code if you're

00:11:49,470 --> 00:11:56,490
benchmarking a backup utility then do it

00:11:54,060 --> 00:11:58,790
on tempo FS with test data and that at

00:11:56,490 --> 00:12:01,769
least takes a lot of that IO out of it

00:11:58,790 --> 00:12:04,860
compare the times you get with a

00:12:01,769 --> 00:12:06,720
baseline on temp FS to a baseline on a

00:12:04,860 --> 00:12:08,790
real disk drive I scuzzy whatever you're

00:12:06,720 --> 00:12:09,600
using and then you can say well don't

00:12:08,790 --> 00:12:11,399
blame my code

00:12:09,600 --> 00:12:14,100
get me a faster network connection from

00:12:11,399 --> 00:12:15,839
I I scuzzy I know a place they they were

00:12:14,100 --> 00:12:17,970
complaining their backups took all night

00:12:15,839 --> 00:12:19,470
they were really really mad at this

00:12:17,970 --> 00:12:21,510
database vendor for so long the slow

00:12:19,470 --> 00:12:25,380
equipment and we found out they were

00:12:21,510 --> 00:12:28,399
using 10 Meg Ethernet for I scuzzy guess

00:12:25,380 --> 00:12:31,680
what didn't work very well

00:12:28,399 --> 00:12:34,110
latency was eating them well find that

00:12:31,680 --> 00:12:36,810
kind of thing out before you run an

00:12:34,110 --> 00:12:38,520
end-to-end benchmark because once you're

00:12:36,810 --> 00:12:40,350
up in your code and you've tested it in

00:12:38,520 --> 00:12:43,399
you can't test that lower-level stuff

00:12:40,350 --> 00:12:46,199
you really can't see what's going on a

00:12:43,399 --> 00:12:49,140
couple of red flags to look for IO IO

00:12:46,199 --> 00:12:50,670
wait times during your benchmark even if

00:12:49,140 --> 00:12:53,339
your benchmarking something that does

00:12:50,670 --> 00:12:55,410
i/o if you've got really high i/o find

00:12:53,339 --> 00:12:56,940
out why and solve that is you'll never

00:12:55,410 --> 00:12:59,579
get any decent performance of its high

00:12:56,940 --> 00:13:01,170
if the runnable jobs again is a lot

00:12:59,579 --> 00:13:03,029
higher than the number of cores you

00:13:01,170 --> 00:13:05,850
either have available or are on the

00:13:03,029 --> 00:13:09,390
machine even if you've got a if you've

00:13:05,850 --> 00:13:11,459
got a virtual machine that has 4 cores

00:13:09,390 --> 00:13:13,860
assigned to it you don't know that there

00:13:11,459 --> 00:13:14,579
are actually 4 cores available when that

00:13:13,860 --> 00:13:17,699
virtual machine

00:13:14,579 --> 00:13:20,429
running so if you have the tasks

00:13:17,699 --> 00:13:21,779
approaching the number of cores you've

00:13:20,429 --> 00:13:25,649
got problems because you're going to be

00:13:21,779 --> 00:13:27,269
the kernel itself can be limited on the

00:13:25,649 --> 00:13:29,999
number of cores it has access to and

00:13:27,269 --> 00:13:31,410
your kernel may be sliced out of the CPU

00:13:29,999 --> 00:13:34,259
is this making sense the way I'm saying

00:13:31,410 --> 00:13:37,769
it to people I'm getting some nods and

00:13:34,259 --> 00:13:40,829
some not the problem is that with a

00:13:37,769 --> 00:13:43,199
virtual machine I can tell VMware or Xen

00:13:40,829 --> 00:13:45,829
or one of these things I want to give

00:13:43,199 --> 00:13:49,189
eight cores to this virtual machine that

00:13:45,829 --> 00:13:51,779
isn't a promise it's an upper limit if

00:13:49,189 --> 00:13:55,350
there are fourteen virtual machines

00:13:51,779 --> 00:13:57,839
running and each and they're all in

00:13:55,350 --> 00:13:59,970
contention you might only have one core

00:13:57,839 --> 00:14:01,529
right now if there are three jobs

00:13:59,970 --> 00:14:03,509
running in your virtual machine and

00:14:01,529 --> 00:14:06,600
there's one core available you're

00:14:03,509 --> 00:14:08,480
getting time sliced you can run top the

00:14:06,600 --> 00:14:11,759
top is going to show you X number of

00:14:08,480 --> 00:14:14,790
available CPUs but a bunch of them are

00:14:11,759 --> 00:14:16,829
fake you can't access them because some

00:14:14,790 --> 00:14:20,279
other virtual machine you can't see is

00:14:16,829 --> 00:14:22,829
using them up so again watch for these

00:14:20,279 --> 00:14:24,749
red flags if you see a change in the

00:14:22,829 --> 00:14:26,639
amount of swap used you've got a problem

00:14:24,749 --> 00:14:27,540
you don't want to be swapping while

00:14:26,639 --> 00:14:31,019
you're running and I'll show you a way

00:14:27,540 --> 00:14:33,470
to avoid that task set on Linux yeah I

00:14:31,019 --> 00:14:36,059
can task set myself to a single core

00:14:33,470 --> 00:14:38,309
that will keep my l1 and l2 cache

00:14:36,059 --> 00:14:41,309
association high it'll keep me running a

00:14:38,309 --> 00:14:43,860
lot faster again if it saves me from

00:14:41,309 --> 00:14:46,230
testing whether the vendor implemented

00:14:43,860 --> 00:14:48,480
their caching mechanism effectively I'm

00:14:46,230 --> 00:14:51,809
testing my code if you're gonna be

00:14:48,480 --> 00:14:54,569
forking do a test you can do a range of

00:14:51,809 --> 00:14:58,129
CPUs try to pick one that are on the

00:14:54,569 --> 00:15:00,239
same court don't dance between CPUs

00:14:58,129 --> 00:15:02,449
especially if you're on an AMD system

00:15:00,239 --> 00:15:05,069
where you're using non-volatile the the

00:15:02,449 --> 00:15:07,019
Numa because you're gonna have to copy

00:15:05,069 --> 00:15:08,069
things between memory banks just to get

00:15:07,019 --> 00:15:09,480
to them you're gonna have to talk to

00:15:08,069 --> 00:15:10,199
other things to get to the memory bank

00:15:09,480 --> 00:15:12,269
you started from

00:15:10,199 --> 00:15:16,649
isolate yourself to at least a single

00:15:12,269 --> 00:15:20,459
CPU and hopefully one court this is a

00:15:16,649 --> 00:15:22,079
cute trick if you're going to run

00:15:20,459 --> 00:15:25,319
something that uses a non-trivial amount

00:15:22,079 --> 00:15:28,410
of memory don't be in contention with

00:15:25,319 --> 00:15:31,410
other processes the way to do that

00:15:28,410 --> 00:15:35,220
create an array that is so big you get

00:15:31,410 --> 00:15:39,270
swamped and then exit force everything

00:15:35,220 --> 00:15:40,950
that isn't running out of court then run

00:15:39,270 --> 00:15:42,540
your test and you'll have as much memory

00:15:40,950 --> 00:15:44,490
as there is for as long as it takes them

00:15:42,540 --> 00:15:46,350
to get mad and come back into memory a

00:15:44,490 --> 00:15:48,270
lot of people may be unhappy with you

00:15:46,350 --> 00:15:52,530
for 30 seconds but at least you'll get a

00:15:48,270 --> 00:15:54,120
decent benchmark this is the various

00:15:52,530 --> 00:15:55,980
versions of this memory hog you keep

00:15:54,120 --> 00:15:58,200
pushing stuff on until you collapse you

00:15:55,980 --> 00:16:00,900
do whatever but to have something that

00:15:58,200 --> 00:16:07,620
swallows all of physical memory and then

00:16:00,900 --> 00:16:10,080
croaks benchmark has a baseline built

00:16:07,620 --> 00:16:12,600
into it that it uses don't trust it use

00:16:10,080 --> 00:16:14,940
your own get your own benchmark and see

00:16:12,600 --> 00:16:17,580
it because you want to be able to see

00:16:14,940 --> 00:16:19,710
how it varies over time again keep these

00:16:17,580 --> 00:16:24,140
benchmarks running if you've got decent

00:16:19,710 --> 00:16:26,670
unit tests run a time on each year tests

00:16:24,140 --> 00:16:28,890
that can give you an idea whether one

00:16:26,670 --> 00:16:33,300
piece of your code takes bloody well

00:16:28,890 --> 00:16:35,880
forever to start up just do a time on if

00:16:33,300 --> 00:16:40,400
you notice when you run prove you'll get

00:16:35,880 --> 00:16:42,980
timings use the timings from prove put

00:16:40,400 --> 00:16:45,330
benchmark into some of your dotty files

00:16:42,980 --> 00:16:47,310
but make sure that you know what the

00:16:45,330 --> 00:16:49,110
inch each individual piece looks like

00:16:47,310 --> 00:16:52,740
again that it gives you some idea what's

00:16:49,110 --> 00:16:56,100
going on you can do time stir and time

00:16:52,740 --> 00:16:58,260
diff with the benchmark module it's a

00:16:56,100 --> 00:17:03,960
good way to find out how long things

00:16:58,260 --> 00:17:06,949
take progressively time high-rez the the

00:17:03,960 --> 00:17:09,300
object exercise has anyone ever use that

00:17:06,949 --> 00:17:11,730
it's a thing I've written that will it

00:17:09,300 --> 00:17:14,130
allows you to use metadata to drive your

00:17:11,730 --> 00:17:16,770
tests one of the options built into it

00:17:14,130 --> 00:17:18,900
is benchmark if you use that it will

00:17:16,770 --> 00:17:21,449
store a high res time before and after

00:17:18,900 --> 00:17:23,189
whatever you ask it to gets run the neat

00:17:21,449 --> 00:17:24,959
thing about is you can design a long

00:17:23,189 --> 00:17:26,189
progressive test you can create

00:17:24,959 --> 00:17:27,720
something in the database create

00:17:26,189 --> 00:17:29,700
something else in the database do

00:17:27,720 --> 00:17:32,550
everything in stages and get the timings

00:17:29,700 --> 00:17:34,590
for each stage that helps you tell for

00:17:32,550 --> 00:17:36,810
example if you've got one grossly

00:17:34,590 --> 00:17:39,150
imbalanced index in a database and

00:17:36,810 --> 00:17:40,360
people are screaming that they they hit

00:17:39,150 --> 00:17:42,100
return and it takes a lunch

00:17:40,360 --> 00:17:44,110
to get something on the screen you can

00:17:42,100 --> 00:17:46,540
start running individual queries and see

00:17:44,110 --> 00:17:48,460
how bloody long they take you can

00:17:46,540 --> 00:17:52,650
isolate the problem down to a specific

00:17:48,460 --> 00:17:52,650
query or a specific chunk of your code

00:17:53,250 --> 00:18:00,250
adding benchmark to your shabang code

00:17:55,690 --> 00:18:01,120
and time will help you with end-to-end

00:18:00,250 --> 00:18:02,950
tests

00:18:01,120 --> 00:18:04,510
I can take my shebang I can put a

00:18:02,950 --> 00:18:06,010
benchmark at the top of benchmark at the

00:18:04,510 --> 00:18:09,640
bottom and just dump out the time when

00:18:06,010 --> 00:18:11,080
I'm finished the problem that of course

00:18:09,640 --> 00:18:12,790
is then you end up seeing it every time

00:18:11,080 --> 00:18:16,570
you run something but that may be what

00:18:12,790 --> 00:18:19,620
you need also take time to account for

00:18:16,570 --> 00:18:22,090
people if you're testing a web back-end

00:18:19,620 --> 00:18:26,350
the time it takes somebody to type like

00:18:22,090 --> 00:18:28,720
this is gonna be a lot slower so you may

00:18:26,350 --> 00:18:32,380
have to do something like this in the

00:18:28,720 --> 00:18:34,480
backend put the times that you get and

00:18:32,380 --> 00:18:36,460
receive things log the time that you do

00:18:34,480 --> 00:18:38,559
for each thing not for how long you ran

00:18:36,460 --> 00:18:40,510
to do a full end-to-end test but how

00:18:38,559 --> 00:18:42,850
long did you send did it take you to

00:18:40,510 --> 00:18:44,350
assemble the replies the good thing

00:18:42,850 --> 00:18:45,850
about this is it subtracts out all the

00:18:44,350 --> 00:18:48,610
network latency and all the human

00:18:45,850 --> 00:18:51,220
latency in clicking the ok button dump

00:18:48,610 --> 00:18:52,720
these out at the end put them in a file

00:18:51,220 --> 00:18:55,360
dump them at as Yam will do it of

00:18:52,720 --> 00:18:57,480
however you like but this will allow you

00:18:55,360 --> 00:18:59,890
to track how long you're taking

00:18:57,480 --> 00:19:04,630
subtracting out what happens after you

00:18:59,890 --> 00:19:07,360
get rid of the packets so I the summary

00:19:04,630 --> 00:19:10,230
is benchmarks do not have to be damn

00:19:07,360 --> 00:19:13,990
wise you can write benchmarks that

00:19:10,230 --> 00:19:15,460
actually track what you're doing most of

00:19:13,990 --> 00:19:17,380
the problems with them that I've seen

00:19:15,460 --> 00:19:21,240
are people not controlling their

00:19:17,380 --> 00:19:25,150
environment not establishing a valid

00:19:21,240 --> 00:19:26,980
baseline for what they're doing run run

00:19:25,150 --> 00:19:29,260
incremental tests that go further and

00:19:26,980 --> 00:19:33,040
further into the code to isolate the

00:19:29,260 --> 00:19:35,049
problems use the high res wall clock you

00:19:33,040 --> 00:19:36,850
know almost all any modern system is

00:19:35,049 --> 00:19:40,299
going to have access to a high res clock

00:19:36,850 --> 00:19:43,929
and if you watch the system verify your

00:19:40,299 --> 00:19:45,820
isolation proc info and G on Linux will

00:19:43,929 --> 00:19:47,830
do go a long way you can look for high

00:19:45,820 --> 00:19:49,120
interrupt counts you can look for lots

00:19:47,830 --> 00:19:50,620
of

00:19:49,120 --> 00:19:52,900
synchronous swapping while you're

00:19:50,620 --> 00:19:54,700
running all of those things indicate the

00:19:52,900 --> 00:19:55,150
Colonel's getting overloaded and your

00:19:54,700 --> 00:19:57,040
knee

00:19:55,150 --> 00:19:58,330
we're not benchmarking your code we're

00:19:57,040 --> 00:20:00,360
benchmarking how well the colonel

00:19:58,330 --> 00:20:03,910
responds to the load being placed on it

00:20:00,360 --> 00:20:05,890
use tasks set that will save all

00:20:03,910 --> 00:20:08,140
actually if you're doing anything that

00:20:05,890 --> 00:20:11,020
depends on time use task set anyway

00:20:08,140 --> 00:20:13,660
because it'll run faster and then tempo

00:20:11,020 --> 00:20:15,700
FS you can see mount for some of the

00:20:13,660 --> 00:20:18,370
options with that you can mount a temp

00:20:15,700 --> 00:20:22,030
FS copy your data into it and run out of

00:20:18,370 --> 00:20:24,610
there and that will save you again from

00:20:22,030 --> 00:20:27,760
testing whether or not the kernel vendor

00:20:24,610 --> 00:20:29,230
implemented their drivers properly it'll

00:20:27,760 --> 00:20:31,059
it'll save you from testing whether your

00:20:29,230 --> 00:20:33,640
I scuzzy is set to the network to use

00:20:31,059 --> 00:20:38,440
the network effectively and those things

00:20:33,640 --> 00:20:40,120
really will help a lot any questions in

00:20:38,440 --> 00:20:43,299
every one of the heartbeat raise your

00:20:40,120 --> 00:20:45,700
hand okay sorry people are at least

00:20:43,299 --> 00:20:47,049
partly awake that's the problem we going

00:20:45,700 --> 00:20:48,040
after lunch you know the people in the

00:20:47,049 --> 00:20:50,860
morning it's like you've had enough

00:20:48,040 --> 00:20:53,260
coffee that you're paying attention did

00:20:50,860 --> 00:20:56,230
this make sense to people didn't what

00:20:53,260 --> 00:20:59,799
did this seem helpful I'm getting some

00:20:56,230 --> 00:21:01,510
nods okay I was asked to make really

00:20:59,799 --> 00:21:04,510
really really certain I finished on time

00:21:01,510 --> 00:21:07,179
so I tried to go quickly I anyone have

00:21:04,510 --> 00:21:11,559
any questions or any horror stories from

00:21:07,179 --> 00:21:14,140
your own benchmarks well people when

00:21:11,559 --> 00:21:15,730
you're when people here are running do

00:21:14,140 --> 00:21:18,220
most people here run with virtual

00:21:15,730 --> 00:21:24,610
machines or you actually have bare metal

00:21:18,220 --> 00:21:25,840
to do your benchmarks on both how many

00:21:24,610 --> 00:21:27,760
times have you had to benchmark

00:21:25,840 --> 00:21:31,020
something where you were running on a

00:21:27,760 --> 00:21:33,130
virtual machine people have to do that

00:21:31,020 --> 00:21:35,020
so you're benchmarking stuff that might

00:21:33,130 --> 00:21:36,429
run on Amazon and you're benchmarking on

00:21:35,020 --> 00:21:39,910
something that runs the basement maybe

00:21:36,429 --> 00:21:44,140
with VMware do you have any access at

00:21:39,910 --> 00:21:47,230
all to the control information from the

00:21:44,140 --> 00:21:48,610
actual hypervisor things that would tell

00:21:47,230 --> 00:21:51,160
you for example whether your virtual

00:21:48,610 --> 00:21:54,690
machine is high priority or how much

00:21:51,160 --> 00:21:54,690
time how much time was stolen from it

00:21:59,730 --> 00:22:07,510
yeah if you have access to that that can

00:22:03,490 --> 00:22:09,340
go a long way I had people screaming mad

00:22:07,510 --> 00:22:10,900
at me that the code I have ran too

00:22:09,340 --> 00:22:12,880
slowly and we found out that I was

00:22:10,900 --> 00:22:15,880
getting like 15 percent of the available

00:22:12,880 --> 00:22:18,070
CPU well you know don't blame me but

00:22:15,880 --> 00:22:20,260
that's a lot of it is is make sure that

00:22:18,070 --> 00:22:22,510
you know what your environment looks

00:22:20,260 --> 00:22:25,660
like because otherwise you have no idea

00:22:22,510 --> 00:22:27,160
what you're really testing what you're

00:22:25,660 --> 00:22:30,250
trying to benchmark whether it's your

00:22:27,160 --> 00:22:31,990
code or what lives under it like I said

00:22:30,250 --> 00:22:35,170
the things like the disk hog like tasks

00:22:31,990 --> 00:22:37,390
set using high res wall clock can go a

00:22:35,170 --> 00:22:40,920
long way toward towards getting the

00:22:37,390 --> 00:22:40,920
effective benchmarks done yeah

00:22:52,160 --> 00:22:54,760
we have

00:22:56,270 --> 00:22:59,270
okay

00:23:09,309 --> 00:23:23,900
okay it gives you a decent baseline to

00:23:13,280 --> 00:23:28,070
start from that's a good one that's a

00:23:23,900 --> 00:23:29,720
good way to start if would you be

00:23:28,070 --> 00:23:33,650
willing to get me is there a link that

00:23:29,720 --> 00:23:35,120
describes the the the caching and the

00:23:33,650 --> 00:23:36,740
Val grind cuz I can put that in here

00:23:35,120 --> 00:23:39,980
before I stick it on the wiki so people

00:23:36,740 --> 00:23:43,150
can see how to find it yeah afterwards

00:23:39,980 --> 00:23:43,150
if I can find that that'll be neat

00:23:43,280 --> 00:23:46,410
[Music]

00:23:48,220 --> 00:23:51,670

YouTube URL: https://www.youtube.com/watch?v=znks21RqR_Y


