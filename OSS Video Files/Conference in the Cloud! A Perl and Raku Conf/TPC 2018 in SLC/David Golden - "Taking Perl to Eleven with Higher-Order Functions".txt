Title: David Golden - "Taking Perl to Eleven with Higher-Order Functions"
Publication date: 2018-06-19
Playlist: TPC 2018 in SLC
Description: 
	Sometimes, you just need your Perl to go one higher. This talk will teach you how to use functions that return functions for powerful, succinct solutions to some repetitive coding problems. Along the way, you’ll see concrete examples using higher-order Perl to generate declarative, structured “fake” data for testing.
Captions: 
	00:00:04,160 --> 00:00:08,050
[Applause]

00:00:04,640 --> 00:00:08,050
[Music]

00:00:08,170 --> 00:00:11,379
Jeff gave you specific permission to do

00:00:10,549 --> 00:00:13,610
that

00:00:11,379 --> 00:00:17,210
all right everybody if I could get your

00:00:13,610 --> 00:00:19,130
attention please thank you very much

00:00:17,210 --> 00:00:20,449
everyone for coming my name is David

00:00:19,130 --> 00:00:23,330
some of you know me some of you don't

00:00:20,449 --> 00:00:24,679
I'm a staff engineer at MongoDB and I

00:00:23,330 --> 00:00:27,019
thought it'd be refreshing to not give a

00:00:24,679 --> 00:00:28,779
talk about MongoDB this year so instead

00:00:27,019 --> 00:00:31,640
I decided I would give a talk about

00:00:28,779 --> 00:00:35,000
higher order programming so this talk is

00:00:31,640 --> 00:00:37,250
about taking Perl 211 which is a

00:00:35,000 --> 00:00:39,770
reference as many of you know to a movie

00:00:37,250 --> 00:00:40,969
spinal tap where the lead guitarist is

00:00:39,770 --> 00:00:42,379
being interviewed and talking about how

00:00:40,969 --> 00:00:43,550
you know sometimes when they just need

00:00:42,379 --> 00:00:48,109
that extra push you know what they do

00:00:43,550 --> 00:00:50,780
their amps go up to 11 it's one hire and

00:00:48,109 --> 00:00:55,070
the whole idea of hire kind of seemed

00:00:50,780 --> 00:00:57,410
appropriate because I was very inspired

00:00:55,070 --> 00:00:59,030
years ago by this book by Marc Dominus

00:00:57,410 --> 00:01:00,890
called higher-order pearl which is all

00:00:59,030 --> 00:01:03,230
about how to do higher order programming

00:01:00,890 --> 00:01:05,750
in Perl higher order programming is the

00:01:03,230 --> 00:01:09,770
idea of functions that create functions

00:01:05,750 --> 00:01:14,030
and so for me I have found that higher

00:01:09,770 --> 00:01:15,560
order programming is my going up to 11

00:01:14,030 --> 00:01:17,510
when I need to get an extra little push

00:01:15,560 --> 00:01:20,990
higher-order programming is often the

00:01:17,510 --> 00:01:24,200
answer now before I get into the meat of

00:01:20,990 --> 00:01:26,540
the talk I want to ask please don't ask

00:01:24,200 --> 00:01:27,860
questions during the talk until you see

00:01:26,540 --> 00:01:29,240
this symbol so I'll have a special

00:01:27,860 --> 00:01:30,500
symbol at several points where I'll stop

00:01:29,240 --> 00:01:32,960
and give a chance for people to ask

00:01:30,500 --> 00:01:34,430
questions and make sure that everyone is

00:01:32,960 --> 00:01:37,040
following along so are there any

00:01:34,430 --> 00:01:39,530
questions before I continue all right

00:01:37,040 --> 00:01:40,610
what a good audience so first I'm going

00:01:39,530 --> 00:01:41,720
to start off with some building blocks

00:01:40,610 --> 00:01:43,640
that'll lay the groundwork for

00:01:41,720 --> 00:01:45,230
higher-order programming and this might

00:01:43,640 --> 00:01:46,370
be familiar to some of you but I'm on a

00:01:45,230 --> 00:01:48,890
sort of level set so that we're all

00:01:46,370 --> 00:01:50,960
starting off on the same page the first

00:01:48,890 --> 00:01:52,370
building block is anonymous functions

00:01:50,960 --> 00:01:54,260
how many people know what an anonymous

00:01:52,370 --> 00:01:55,940
function is in Perl okay most the

00:01:54,260 --> 00:01:57,260
audience so we won't spend a lot of time

00:01:55,940 --> 00:02:00,800
though so the idea is that you have a

00:01:57,260 --> 00:02:02,240
function which is a does not have a name

00:02:00,800 --> 00:02:04,190
but is assigned to a variable it's a

00:02:02,240 --> 00:02:05,630
code reference and you get a value out

00:02:04,190 --> 00:02:07,130
of that function by dereferencing it

00:02:05,630 --> 00:02:09,640
with the arrow and the parentheses and

00:02:07,130 --> 00:02:12,609
so a lot of this talk will be using

00:02:09,640 --> 00:02:14,930
anonymous functions anonymous functions

00:02:12,609 --> 00:02:17,150
let us do things like this we can create

00:02:14,930 --> 00:02:19,010
a function which is a joiner in here

00:02:17,150 --> 00:02:20,329
an anonymous function that joins its

00:02:19,010 --> 00:02:21,890
argument with a space and we get a

00:02:20,329 --> 00:02:24,349
string by calling that function with

00:02:21,890 --> 00:02:27,079
some list of words the second building

00:02:24,349 --> 00:02:29,150
block is scope we work in Perl we have a

00:02:27,079 --> 00:02:30,530
lot of appreciation for scope and the

00:02:29,150 --> 00:02:31,640
scope that's important here is the

00:02:30,530 --> 00:02:32,870
notion that you could have a variable

00:02:31,640 --> 00:02:34,819
outside of function that can be

00:02:32,870 --> 00:02:36,140
referenced from inside the function so

00:02:34,819 --> 00:02:38,420
here we can put the separator as a

00:02:36,140 --> 00:02:40,340
variable outside of the function and we

00:02:38,420 --> 00:02:43,129
can still have a function that uses that

00:02:40,340 --> 00:02:47,030
variable inside it the third building

00:02:43,129 --> 00:02:49,519
block is closure and closure is the

00:02:47,030 --> 00:02:51,500
technique that really takes scope and

00:02:49,519 --> 00:02:53,720
anonymous functions and lets you do

00:02:51,500 --> 00:02:55,129
higher-order programming so if we go

00:02:53,720 --> 00:02:56,900
back to this idea of having a variable

00:02:55,129 --> 00:03:00,049
separator outside of the joining

00:02:56,900 --> 00:03:01,819
function we can take this concept and

00:03:00,049 --> 00:03:04,069
wrap the entire thing up into another

00:03:01,819 --> 00:03:06,650
function so we have a function joiner

00:03:04,069 --> 00:03:09,230
maker which takes as an argument a

00:03:06,650 --> 00:03:11,599
separator a lexical variable and then we

00:03:09,230 --> 00:03:13,189
have a subroutine that uses that lexical

00:03:11,599 --> 00:03:14,959
variable an anonymous subroutine which

00:03:13,189 --> 00:03:16,370
uses that and is returned so this is a

00:03:14,959 --> 00:03:18,980
function that takes an argument and

00:03:16,370 --> 00:03:20,840
returns a function that utilizes that

00:03:18,980 --> 00:03:22,730
argument as part of it now if you

00:03:20,840 --> 00:03:24,079
haven't been done this sort of thing

00:03:22,730 --> 00:03:25,699
before you might be thinking well what's

00:03:24,079 --> 00:03:26,930
happening to separator when that goes on

00:03:25,699 --> 00:03:29,870
right well what happens when that

00:03:26,930 --> 00:03:31,639
function goes out of scope right so we

00:03:29,870 --> 00:03:32,959
take a separator as an argument and what

00:03:31,639 --> 00:03:34,069
normally sounds like an object and

00:03:32,959 --> 00:03:34,819
that's the only reference at the end of

00:03:34,069 --> 00:03:37,250
that function you think well maybe

00:03:34,819 --> 00:03:38,870
that's gonna go out of scope well an

00:03:37,250 --> 00:03:40,819
anonymous function in this case we say

00:03:38,870 --> 00:03:42,500
closes over the lexical variable and

00:03:40,819 --> 00:03:44,180
that keeps it alive so there is actually

00:03:42,500 --> 00:03:46,129
inside the Perl interpreter a reference

00:03:44,180 --> 00:03:47,840
to that thing that was passed in and it

00:03:46,129 --> 00:03:50,750
has kept alive because it is referenced

00:03:47,840 --> 00:03:52,400
in that anonymous function so in this

00:03:50,750 --> 00:03:53,989
case we get separated passed in

00:03:52,400 --> 00:03:56,780
separator lives inside the function and

00:03:53,989 --> 00:03:58,430
will live on forever so once we have the

00:03:56,780 --> 00:04:00,620
idea of closure we can start doing

00:03:58,430 --> 00:04:03,019
things like this given a list of words

00:04:00,620 --> 00:04:05,000
we can now create a number of different

00:04:03,019 --> 00:04:07,040
ways of mutating words we can create a

00:04:05,000 --> 00:04:10,129
spacer by calling join our maker with a

00:04:07,040 --> 00:04:11,959
space character we can create - sure by

00:04:10,129 --> 00:04:14,030
calling join our maker with a dash or a

00:04:11,959 --> 00:04:15,019
Bangor same thing with a bang sign and

00:04:14,030 --> 00:04:17,000
then when we call each of those

00:04:15,019 --> 00:04:19,310
functions we get different output able

00:04:17,000 --> 00:04:21,739
space bakery - bigger able bang vector

00:04:19,310 --> 00:04:23,510
so we've taken that function joiner

00:04:21,739 --> 00:04:25,969
maker and now it gives us very different

00:04:23,510 --> 00:04:27,469
kinds of behavior based on what we pass

00:04:25,969 --> 00:04:29,570
in to it and what we get out of it so

00:04:27,469 --> 00:04:30,320
let me stop there any questions before I

00:04:29,570 --> 00:04:31,370
go on cuz

00:04:30,320 --> 00:04:33,580
the fundamentals if you don't follow

00:04:31,370 --> 00:04:36,830
closure you get him in trouble questions

00:04:33,580 --> 00:04:39,380
great so now we're ready to talk about

00:04:36,830 --> 00:04:40,760
higher order program which as I said is

00:04:39,380 --> 00:04:42,920
the idea of functions creating functions

00:04:40,760 --> 00:04:44,750
which we saw one example of but we're

00:04:42,920 --> 00:04:47,090
gonna take this and go a lot further

00:04:44,750 --> 00:04:49,790
with it so one of the things you can do

00:04:47,090 --> 00:04:51,680
with higher order programming is develop

00:04:49,790 --> 00:04:54,320
abstract rules for generating arbitrary

00:04:51,680 --> 00:04:57,380
data and so why would you want to do

00:04:54,320 --> 00:04:59,900
that well one example and one that I

00:04:57,380 --> 00:05:01,820
found myself needing a lot is I need to

00:04:59,900 --> 00:05:03,740
some sort of load testing right I'm

00:05:01,820 --> 00:05:05,540
trying to like see like hey is this

00:05:03,740 --> 00:05:08,360
thing that a break if I like just pile

00:05:05,540 --> 00:05:11,030
on a lot of stuff but when I pile on

00:05:08,360 --> 00:05:13,370
that stuff right I really want lots of

00:05:11,030 --> 00:05:14,660
similar but slightly different things so

00:05:13,370 --> 00:05:16,580
let's think about something - like

00:05:14,660 --> 00:05:18,170
compression right if you're gonna do

00:05:16,580 --> 00:05:20,330
some sort of compression do you want to

00:05:18,170 --> 00:05:22,610
just pile on a very very long line of

00:05:20,330 --> 00:05:24,410
a's forever and ever now that's said

00:05:22,610 --> 00:05:26,330
what you need randomized data you need

00:05:24,410 --> 00:05:27,800
data that's different in order to really

00:05:26,330 --> 00:05:29,840
sort of test out your algorithm same

00:05:27,800 --> 00:05:31,220
thing with people who do like fuzz

00:05:29,840 --> 00:05:33,800
testing or things like that you want

00:05:31,220 --> 00:05:35,150
permutations of your data in order to be

00:05:33,800 --> 00:05:36,980
able to explore the space that you want

00:05:35,150 --> 00:05:39,740
so we want lots of similar but slightly

00:05:36,980 --> 00:05:42,110
different things so we'll get there but

00:05:39,740 --> 00:05:44,630
for now we're gonna start off with some

00:05:42,110 --> 00:05:46,820
simple generators so let's think for a

00:05:44,630 --> 00:05:48,650
moment about what if we just want to

00:05:46,820 --> 00:05:49,970
generate an array of integers just give

00:05:48,650 --> 00:05:51,320
me an array of random integers right

00:05:49,970 --> 00:05:52,910
very straightforward

00:05:51,320 --> 00:05:54,440
here's an example of something we could

00:05:52,910 --> 00:05:57,470
do let's seven want to get a hundred

00:05:54,440 --> 00:05:59,180
random integers from zero to 255 we can

00:05:57,470 --> 00:06:01,640
write a function for it make int array

00:05:59,180 --> 00:06:04,220
so we'll take an array we'll push on a

00:06:01,640 --> 00:06:05,420
bunch of randomly determined values onto

00:06:04,220 --> 00:06:06,950
that array and then we'll return a

00:06:05,420 --> 00:06:09,170
reference to it very very simple very

00:06:06,950 --> 00:06:11,690
straightforward now some of you might be

00:06:09,170 --> 00:06:13,400
thinking as I would looking at this if

00:06:11,690 --> 00:06:15,320
there's a lot of constants in there

00:06:13,400 --> 00:06:17,630
constants as we knows programmers are

00:06:15,320 --> 00:06:19,880
bad we want to have things that are

00:06:17,630 --> 00:06:21,530
parameter eyes'll so in this case we

00:06:19,880 --> 00:06:24,770
start off with a hundred random integers

00:06:21,530 --> 00:06:26,330
from zero to 255 and those the constants

00:06:24,770 --> 00:06:28,880
well we'd really like to make that more

00:06:26,330 --> 00:06:31,430
generic we'd like to have some number

00:06:28,880 --> 00:06:33,500
and random integers from zero to X so we

00:06:31,430 --> 00:06:36,620
can modify this as we do to take

00:06:33,500 --> 00:06:38,780
arguments and an X and we do the same

00:06:36,620 --> 00:06:41,660
thing but now we are using those

00:06:38,780 --> 00:06:41,889
parameters to return an array of random

00:06:41,660 --> 00:06:44,620
and

00:06:41,889 --> 00:06:45,610
which is great okay probably the way we

00:06:44,620 --> 00:06:47,020
would have written this in the first

00:06:45,610 --> 00:06:49,810
place if we weren't giving talks about

00:06:47,020 --> 00:06:51,460
it so now what if we want to generate an

00:06:49,810 --> 00:06:53,020
array of discrete choices so let's

00:06:51,460 --> 00:06:54,310
imagine we have a list of names we want

00:06:53,020 --> 00:06:56,460
to be able to create an array that just

00:06:54,310 --> 00:06:59,199
picks some names out of a hat and

00:06:56,460 --> 00:07:01,509
populates the list so we got n strings

00:06:59,199 --> 00:07:02,409
drawn from a discrete set so now we can

00:07:01,509 --> 00:07:04,629
write another one of these functions

00:07:02,409 --> 00:07:06,099
make discrete array we take n however

00:07:04,629 --> 00:07:09,849
many we want in the array we take the

00:07:06,099 --> 00:07:12,069
list of choices for the array calculate

00:07:09,849 --> 00:07:14,379
the size and we do the same thing we get

00:07:12,069 --> 00:07:15,759
an array we push a random value onto it

00:07:14,379 --> 00:07:17,620
now we're gonna pick something off of

00:07:15,759 --> 00:07:20,349
that list at random and stick it on that

00:07:17,620 --> 00:07:22,750
array and return it so we might use it

00:07:20,349 --> 00:07:24,279
like this so we're gonna make it a sweet

00:07:22,750 --> 00:07:26,080
array we want a hundred things drawn

00:07:24,279 --> 00:07:29,020
from a list of names Larry Wald II mean

00:07:26,080 --> 00:07:30,460
Conroy ricotta Cygnus Sawyer X this is

00:07:29,020 --> 00:07:33,490
my reference to Sara X there you go I

00:07:30,460 --> 00:07:35,139
change this just for you special but now

00:07:33,490 --> 00:07:37,060
some of you might be thinking okay well

00:07:35,139 --> 00:07:38,529
that's fine but do I have to repeat that

00:07:37,060 --> 00:07:39,879
for every kind of array I need if I need

00:07:38,529 --> 00:07:41,919
lots of different kinds of rigs do I

00:07:39,879 --> 00:07:42,729
have to go and write one of those arrays

00:07:41,919 --> 00:07:44,469
for everything

00:07:42,729 --> 00:07:45,789
no we're programmers we don't like

00:07:44,469 --> 00:07:48,940
having to repeat ourselves if we don't

00:07:45,789 --> 00:07:50,770
want to we're lazy right so no we don't

00:07:48,940 --> 00:07:52,289
want to just make the same thing copy

00:07:50,770 --> 00:07:54,909
and paste over and over and over again

00:07:52,289 --> 00:07:58,860
we want to generalize the whole idea of

00:07:54,909 --> 00:08:00,849
array generation and we can do that with

00:07:58,860 --> 00:08:02,860
Hydra programming and anonymous

00:08:00,849 --> 00:08:04,509
functions so now let's make this more

00:08:02,860 --> 00:08:06,190
generic n elements provided by its

00:08:04,509 --> 00:08:08,979
function so now we have a make array

00:08:06,190 --> 00:08:10,689
function which takes dollar n in dollar

00:08:08,979 --> 00:08:12,400
app where dollar F is a function that

00:08:10,689 --> 00:08:14,229
produces a value that we want to stick

00:08:12,400 --> 00:08:16,960
into the Iraq now we you the same thing

00:08:14,229 --> 00:08:19,509
create the array go over it one two

00:08:16,960 --> 00:08:20,949
dollar and and call F a number of times

00:08:19,509 --> 00:08:22,300
to grab the eyes of a function stick

00:08:20,949 --> 00:08:25,330
them on with your very straightforward

00:08:22,300 --> 00:08:27,270
and to keep my future slides briefer I'm

00:08:25,330 --> 00:08:30,099
going to abbreviate this like like this

00:08:27,270 --> 00:08:33,370
anonymous array map the function from 1

00:08:30,099 --> 00:08:35,890
to N and so we could think about our

00:08:33,370 --> 00:08:38,649
first task 100 random integers from 0 to

00:08:35,890 --> 00:08:40,719
255 is now just this make array 100

00:08:38,649 --> 00:08:43,690
things where you get the things from

00:08:40,719 --> 00:08:46,240
this anonymous function that just

00:08:43,690 --> 00:08:47,800
produces a random number and likewise we

00:08:46,240 --> 00:08:50,319
can do the same thing for that initial

00:08:47,800 --> 00:08:51,819
example of 100 discrete choices given a

00:08:50,319 --> 00:08:53,319
list in some size now we're going to

00:08:51,819 --> 00:08:54,360
make an array and we just pass in the

00:08:53,319 --> 00:08:56,549
function

00:08:54,360 --> 00:08:59,459
anonymous function to pick random way

00:08:56,549 --> 00:09:01,529
out of that list but again you might be

00:08:59,459 --> 00:09:03,329
out there thinking okay but you got

00:09:01,529 --> 00:09:05,220
those constants back in there right and

00:09:03,329 --> 00:09:07,319
now you're this sub doctor you got a sub

00:09:05,220 --> 00:09:08,910
body and that's kind of picky right as

00:09:07,319 --> 00:09:10,199
programmers we don't like anonymous

00:09:08,910 --> 00:09:11,819
functions are great but do we really

00:09:10,199 --> 00:09:14,040
like looking at them all the time not

00:09:11,819 --> 00:09:17,939
exactly so now it's time to go one

00:09:14,040 --> 00:09:19,259
higher now you want to generalize the

00:09:17,939 --> 00:09:22,679
very notion of a value generating

00:09:19,259 --> 00:09:25,170
function so we'll start off there with

00:09:22,679 --> 00:09:28,139
an int maker so now we have a function

00:09:25,170 --> 00:09:30,209
that we take a minimum and a maximum we

00:09:28,139 --> 00:09:33,600
calculate a range from that and we

00:09:30,209 --> 00:09:35,759
return an anonymous function that

00:09:33,600 --> 00:09:37,290
produces a value from that range right

00:09:35,759 --> 00:09:39,059
so if the example on the bottom kind of

00:09:37,290 --> 00:09:41,519
lays out how that works if we want a

00:09:39,059 --> 00:09:44,339
random integer between 3 and 6 we get a

00:09:41,519 --> 00:09:46,350
function from our int maker with the

00:09:44,339 --> 00:09:48,569
arguments 3 and 6 and then we call it

00:09:46,350 --> 00:09:50,220
and we get some value out and maybe in

00:09:48,569 --> 00:09:52,439
this case it's 4 right so we've taken

00:09:50,220 --> 00:09:54,209
the whole idea of give me some sort of

00:09:52,439 --> 00:09:56,009
integer thing from some minute and some

00:09:54,209 --> 00:09:57,569
minimum to some maximum and we've

00:09:56,009 --> 00:09:59,189
wrapped that up in a generator function

00:09:57,569 --> 00:10:02,639
that produces the anonymous subroutine

00:09:59,189 --> 00:10:03,360
that we need likewise we do the exact

00:10:02,639 --> 00:10:04,769
same thing

00:10:03,360 --> 00:10:06,959
picking out of a list so now we can

00:10:04,769 --> 00:10:08,610
create a pick maker where we take a list

00:10:06,959 --> 00:10:10,529
we calculate the size now within the

00:10:08,610 --> 00:10:12,779
function and we return the anonymous

00:10:10,529 --> 00:10:15,480
function that provides a choice out of

00:10:12,779 --> 00:10:17,339
that list so we can create F as a pick

00:10:15,480 --> 00:10:19,439
maker with a list of names call that and

00:10:17,339 --> 00:10:20,459
get Larry out of it and of course if we

00:10:19,439 --> 00:10:22,079
want a different set of name we just

00:10:20,459 --> 00:10:24,179
call pick maker over and over again with

00:10:22,079 --> 00:10:26,399
different lists of stuff and now we have

00:10:24,179 --> 00:10:30,959
a very generic way to pick something out

00:10:26,399 --> 00:10:33,869
of a list so that is higher order value

00:10:30,959 --> 00:10:37,110
generation and in that way we can let

00:10:33,869 --> 00:10:38,730
the generators replace the anonymous

00:10:37,110 --> 00:10:40,829
functions so if we go back to some of

00:10:38,730 --> 00:10:43,799
these examples we had a hundred random

00:10:40,829 --> 00:10:46,230
integers and we had this maker a 100 sub

00:10:43,799 --> 00:10:49,169
dot same thing with discrete choices

00:10:46,230 --> 00:10:51,059
make array of 100 sub dot now we can

00:10:49,169 --> 00:10:53,999
create it replace with a generator right

00:10:51,059 --> 00:10:56,220
so int maker replaces the anonymous

00:10:53,999 --> 00:10:58,949
subroutine pick maker replaces the pick

00:10:56,220 --> 00:11:00,449
out of the list this is much more simple

00:10:58,949 --> 00:11:01,739
to read it's much more expressive of

00:11:00,449 --> 00:11:04,110
your intent you're not getting bogged

00:11:01,739 --> 00:11:06,499
down in sort of mechanics of how it's

00:11:04,110 --> 00:11:06,499
happening

00:11:06,640 --> 00:11:16,030
so I would Jenn like we all pretty and

00:11:12,040 --> 00:11:17,560
read this very easily but this is a much

00:11:16,030 --> 00:11:18,880
better way to do it right much simpler

00:11:17,560 --> 00:11:21,100
so let me stop there because these are

00:11:18,880 --> 00:11:22,240
sort of like this whole idea of taking

00:11:21,100 --> 00:11:23,440
the something that you would do with an

00:11:22,240 --> 00:11:25,120
anonymous function and replace it with a

00:11:23,440 --> 00:11:26,890
generator is sort of core to what's

00:11:25,120 --> 00:11:28,450
going to come next so let me stop here

00:11:26,890 --> 00:11:31,660
and see if there are any questions about

00:11:28,450 --> 00:11:32,800
what I present it no everyone's

00:11:31,660 --> 00:11:33,580
following along really great maybe

00:11:32,800 --> 00:11:35,080
you've already done higher-order

00:11:33,580 --> 00:11:37,560
programming before and this is all

00:11:35,080 --> 00:11:40,630
redundant material so let's keep going

00:11:37,560 --> 00:11:42,070
so we have higher order value generators

00:11:40,630 --> 00:11:44,710
we have int makers we have picked makers

00:11:42,070 --> 00:11:46,150
that's all straightforward but why

00:11:44,710 --> 00:11:48,010
there's no reason for us to stop there

00:11:46,150 --> 00:11:50,140
right if you think about what we were

00:11:48,010 --> 00:11:52,450
doing we had a function to generate an

00:11:50,140 --> 00:11:56,140
array well why don't we do higher-order

00:11:52,450 --> 00:11:58,060
array generation so we had this function

00:11:56,140 --> 00:12:01,450
make array where we take N and s when we

00:11:58,060 --> 00:12:03,460
return an anonymous function and if you

00:12:01,450 --> 00:12:05,380
follow along with a little Damien Conroy

00:12:03,460 --> 00:12:09,070
style animation we just shift this thing

00:12:05,380 --> 00:12:10,090
over and pops and stuff around it and

00:12:09,070 --> 00:12:12,370
all of a sudden now we have an array

00:12:10,090 --> 00:12:15,520
maker still takes n still takes F and

00:12:12,370 --> 00:12:17,710
now returns a function which generates

00:12:15,520 --> 00:12:20,860
an anonymous array from the N in the F

00:12:17,710 --> 00:12:22,420
that you've passed in so the old way we

00:12:20,860 --> 00:12:24,910
would do things would be like this if we

00:12:22,420 --> 00:12:27,970
want array we'd say some reference r is

00:12:24,910 --> 00:12:31,090
make array 100 int maker but the new way

00:12:27,970 --> 00:12:33,280
higher-order way is to get a function

00:12:31,090 --> 00:12:34,660
from the array maker that knows how to

00:12:33,280 --> 00:12:38,650
do that and then we just call that

00:12:34,660 --> 00:12:40,450
function and that might seem like you

00:12:38,650 --> 00:12:42,250
know excessive why would you go did this

00:12:40,450 --> 00:12:43,510
extra step of like constructor thing and

00:12:42,250 --> 00:12:45,730
then call the thing one you just want

00:12:43,510 --> 00:12:47,590
the original thing well it lets us do

00:12:45,730 --> 00:12:49,810
something a little bit different a

00:12:47,590 --> 00:12:51,850
little bit special we can do this what

00:12:49,810 --> 00:12:54,400
if we want an array of an array of

00:12:51,850 --> 00:12:56,470
integers well we can get a function from

00:12:54,400 --> 00:12:59,140
our array maker which gives us a hundred

00:12:56,470 --> 00:13:02,290
arrays where every element of the array

00:12:59,140 --> 00:13:05,800
is itself an array with a hundred

00:13:02,290 --> 00:13:07,930
elements of integers from 0 to 255 and

00:13:05,800 --> 00:13:09,100
then again to actually generate that you

00:13:07,930 --> 00:13:10,480
call the function and it just sort of

00:13:09,100 --> 00:13:13,690
rolls down through and the whole thing

00:13:10,480 --> 00:13:15,790
gets generated or you just keep going as

00:13:13,690 --> 00:13:17,650
deep as you need to go maybe we want an

00:13:15,790 --> 00:13:18,510
array and of array of an array maybe

00:13:17,650 --> 00:13:21,570
like

00:13:18,510 --> 00:13:23,220
by a hundred matrix of RGB values so now

00:13:21,570 --> 00:13:24,630
we have an array maker with a hundred of

00:13:23,220 --> 00:13:26,040
an array maker of a hundred of a ray

00:13:24,630 --> 00:13:28,440
maker of three things of integers from

00:13:26,040 --> 00:13:29,880
zero to 255 and so all these little

00:13:28,440 --> 00:13:31,200
building blocks not very much code at

00:13:29,880 --> 00:13:34,350
all has now built up to something that

00:13:31,200 --> 00:13:36,420
lets us express data structures very

00:13:34,350 --> 00:13:37,740
naturally very powerfully and you can

00:13:36,420 --> 00:13:40,230
sort of see exactly what's happening I'm

00:13:37,740 --> 00:13:41,460
getting an array maker that has an array

00:13:40,230 --> 00:13:43,560
maker hazard array makrand you know

00:13:41,460 --> 00:13:55,680
what's going on and it's very very short

00:13:43,560 --> 00:13:57,900
very very expressive so next what if you

00:13:55,680 --> 00:14:00,680
wanted an array of random size all the

00:13:57,900 --> 00:14:03,240
examples have had a fixed size 100 or 3

00:14:00,680 --> 00:14:05,940
so we were really talking about now is

00:14:03,240 --> 00:14:07,140
generalizing n right and we could do

00:14:05,940 --> 00:14:08,250
that the exact same way instead of

00:14:07,140 --> 00:14:09,810
having a constant we could have a

00:14:08,250 --> 00:14:11,730
function that produces a value and that

00:14:09,810 --> 00:14:13,410
might look something like this so we got

00:14:11,730 --> 00:14:14,610
an array an array of integers so we're

00:14:13,410 --> 00:14:16,350
gonna replace those hundreds with

00:14:14,610 --> 00:14:18,480
anonymous functions that return the

00:14:16,350 --> 00:14:20,040
value 100 and do the same thing all the

00:14:18,480 --> 00:14:21,330
way through and so we can just instead

00:14:20,040 --> 00:14:25,260
of having constant we can have functions

00:14:21,330 --> 00:14:26,550
and that's kind of icky right it's also

00:14:25,260 --> 00:14:28,170
kind of icky to sort of wrap up

00:14:26,550 --> 00:14:30,060
constants with functions that seems sort

00:14:28,170 --> 00:14:34,230
of ridiculous well there's a nice

00:14:30,060 --> 00:14:36,930
elegant way around that and it's with a

00:14:34,230 --> 00:14:39,900
transformation helper function so here's

00:14:36,930 --> 00:14:41,850
a function I call it underscore X just

00:14:39,900 --> 00:14:43,920
for brevity and as a very simple thing

00:14:41,850 --> 00:14:46,830
it takes something in as an argument and

00:14:43,920 --> 00:14:49,650
if that thing is a code reference it

00:14:46,830 --> 00:14:50,730
executes sit and returns the value but

00:14:49,650 --> 00:14:52,260
if it's not a code reference it just

00:14:50,730 --> 00:14:55,410
what passes through the value unchanged

00:14:52,260 --> 00:14:58,980
and so with that we can modify the array

00:14:55,410 --> 00:15:00,920
maker and wrap dollar F in dollar n in

00:14:58,980 --> 00:15:03,360
the transformation helper function that

00:15:00,920 --> 00:15:06,510
lets us have one function with a whole

00:15:03,360 --> 00:15:08,040
bunch of different outcomes so for

00:15:06,510 --> 00:15:10,200
instance if we want to have as we

00:15:08,040 --> 00:15:12,300
started off a constant size array with a

00:15:10,200 --> 00:15:13,860
constant value we can use array maker

00:15:12,300 --> 00:15:17,400
dollar and dollar V and we'd get an

00:15:13,860 --> 00:15:20,760
array of n items all of which are

00:15:17,400 --> 00:15:23,940
whatever was in dollar V or if we want a

00:15:20,760 --> 00:15:25,590
constant size random value array we'd

00:15:23,940 --> 00:15:27,230
use a ray maker with n and a pick maker

00:15:25,590 --> 00:15:30,530
exactly as we had before

00:15:27,230 --> 00:15:32,660
but now we want random size and random

00:15:30,530 --> 00:15:34,070
values we just replaced that dollar end

00:15:32,660 --> 00:15:35,930
with another one of these generators int

00:15:34,070 --> 00:15:37,670
maker and when a rain maker calls it

00:15:35,930 --> 00:15:39,200
notices that the value you gave for

00:15:37,670 --> 00:15:40,490
dollar head is in fact a function to

00:15:39,200 --> 00:15:42,740
produce a value and it will get that

00:15:40,490 --> 00:15:46,010
value and use that for the size of the

00:15:42,740 --> 00:15:48,590
array so this this dollar F would give

00:15:46,010 --> 00:15:51,080
us from three to six things picked out

00:15:48,590 --> 00:15:52,520
of a list and of course we could Ness it

00:15:51,080 --> 00:15:54,620
in exactly the same way we composed it

00:15:52,520 --> 00:15:56,210
before so if you want to have an array

00:15:54,620 --> 00:15:57,500
with three to six array each of which

00:15:56,210 --> 00:15:59,660
have ten to twenty things out of your

00:15:57,500 --> 00:16:02,720
list you just compose these things in a

00:15:59,660 --> 00:16:04,430
very sort of natural express surprise so

00:16:02,720 --> 00:16:06,500
now it was gone to you higher-order

00:16:04,430 --> 00:16:07,790
array generation let me stop there and

00:16:06,500 --> 00:16:11,780
see if people have any questions about

00:16:07,790 --> 00:16:13,460
what I've shared so far nope everybody's

00:16:11,780 --> 00:16:17,740
not in long I see Andrews sort of

00:16:13,460 --> 00:16:17,740
wiggling his head nodding his head okay

00:16:17,920 --> 00:16:25,520
alright so I wrote a module for C pen

00:16:23,360 --> 00:16:28,100
called data fake data fake takes all of

00:16:25,520 --> 00:16:29,480
these ideas and kind of blows them out a

00:16:28,100 --> 00:16:30,950
number of directions and provides a lot

00:16:29,480 --> 00:16:33,230
of generator functions that are you very

00:16:30,950 --> 00:16:35,960
useful for generating different kinds of

00:16:33,230 --> 00:16:37,460
random information so let's imagine for

00:16:35,960 --> 00:16:39,320
instance we have a goal of creating a

00:16:37,460 --> 00:16:42,050
lot of fake superhero records we have a

00:16:39,320 --> 00:16:43,850
superhero processing application we need

00:16:42,050 --> 00:16:46,580
lots of fake superheroes to put through

00:16:43,850 --> 00:16:48,290
our superhero application and for the

00:16:46,580 --> 00:16:49,640
sake of today's presentation I'm gonna

00:16:48,290 --> 00:16:52,310
use the tick how many people know the

00:16:49,640 --> 00:16:55,190
tick all right many people don't take

00:16:52,310 --> 00:16:58,100
spoon ok excellent so we described the

00:16:55,190 --> 00:16:58,700
tick so the tick has a name tick has a

00:16:58,100 --> 00:17:01,310
battlecry

00:16:58,700 --> 00:17:03,440
spoon let's imagine some other data that

00:17:01,310 --> 00:17:04,280
the tick might have so we have the tick

00:17:03,440 --> 00:17:06,410
as a name

00:17:04,280 --> 00:17:07,850
battlecry spoon birthday I don't know

00:17:06,410 --> 00:17:09,260
what the ticks birthday is in Canon

00:17:07,850 --> 00:17:11,300
maybe somebody does since I just put my

00:17:09,260 --> 00:17:13,490
birthday on and the tick has a bunch of

00:17:11,300 --> 00:17:14,930
friends ok and so this is a way of

00:17:13,490 --> 00:17:15,860
describing the tick in a very in a

00:17:14,930 --> 00:17:19,190
little data structure

00:17:15,860 --> 00:17:20,390
well data fake lets you express higher

00:17:19,190 --> 00:17:23,000
order structured data

00:17:20,390 --> 00:17:24,170
alright the idea is to take that kind of

00:17:23,000 --> 00:17:26,150
data structure that you had about the

00:17:24,170 --> 00:17:28,960
tick that you want and express it in a

00:17:26,150 --> 00:17:30,680
way where you can generate it

00:17:28,960 --> 00:17:32,750
programmatically in a very simple way

00:17:30,680 --> 00:17:34,190
and it looks a little bit like this and

00:17:32,750 --> 00:17:35,330
I'll walk through the pieces of it but

00:17:34,190 --> 00:17:37,640
the thing that I want you to notice

00:17:35,330 --> 00:17:39,620
about this is it it's declarative

00:17:37,640 --> 00:17:40,160
right it's not an algorithmic loop over

00:17:39,620 --> 00:17:41,900
this loop over

00:17:40,160 --> 00:17:43,520
that loop over the rest the data

00:17:41,900 --> 00:17:44,720
structure looks a lot like what we

00:17:43,520 --> 00:17:47,540
wanted so we start off with a data

00:17:44,720 --> 00:17:49,370
structure the like on the top name

00:17:47,540 --> 00:17:52,700
battlecry birthday and Friends and down

00:17:49,370 --> 00:17:54,860
below we can express name battlecry

00:17:52,700 --> 00:17:58,040
birthday and friends very much the same

00:17:54,860 --> 00:18:01,520
way but now instead of values we have

00:17:58,040 --> 00:18:03,320
generator functions so within data fake

00:18:01,520 --> 00:18:05,450
there's a plug-in called core that

00:18:03,320 --> 00:18:07,130
provides a lot of this sort of building

00:18:05,450 --> 00:18:09,020
blocks that you would expect like hashes

00:18:07,130 --> 00:18:11,270
and arrays and and integers and the rest

00:18:09,020 --> 00:18:13,310
of that so your hero Factory in this

00:18:11,270 --> 00:18:16,310
case is a fake hash and the fake hash

00:18:13,310 --> 00:18:18,170
that you pass in becomes the template to

00:18:16,310 --> 00:18:20,690
generate any number of things that

00:18:18,170 --> 00:18:23,810
follow the same pattern there's a names

00:18:20,690 --> 00:18:26,540
plug in the names plug-in provides a way

00:18:23,810 --> 00:18:28,160
of getting different names at different

00:18:26,540 --> 00:18:32,630
types full names short names of the rest

00:18:28,160 --> 00:18:34,550
of that and this is used to sort of fill

00:18:32,630 --> 00:18:36,530
in some sort of random name battlecry

00:18:34,550 --> 00:18:38,420
comes from a text plug-in tech can

00:18:36,530 --> 00:18:39,710
provide sentences here parametrize with

00:18:38,420 --> 00:18:43,190
one we want only one sentence and this

00:18:39,710 --> 00:18:45,530
is all sort of pseudo latin gobbledygook

00:18:43,190 --> 00:18:46,880
I forget which module on C peni I use as

00:18:45,530 --> 00:18:48,620
a dependency to sort of grab all that

00:18:46,880 --> 00:18:50,390
but you can say I want to fake sentence

00:18:48,620 --> 00:18:51,650
I want a paragraph I want you know

00:18:50,390 --> 00:18:53,090
several paragraphs you can sort of build

00:18:51,650 --> 00:18:55,760
this up however you want here we're just

00:18:53,090 --> 00:18:58,400
going to take one sentence a birthday

00:18:55,760 --> 00:19:00,200
which is in this case a past date time

00:18:58,400 --> 00:19:02,660
the dates plug-in lets you also specify

00:19:00,200 --> 00:19:04,910
future date time if you want date in the

00:19:02,660 --> 00:19:06,140
future when is the next appointment with

00:19:04,910 --> 00:19:08,060
the dentist and what's going to create a

00:19:06,140 --> 00:19:09,350
future a future date and there's a

00:19:08,060 --> 00:19:12,830
number of different formats you can use

00:19:09,350 --> 00:19:14,810
to sort of generate those as well and

00:19:12,830 --> 00:19:16,670
then friends is one another one of these

00:19:14,810 --> 00:19:18,320
sort of composed things using things

00:19:16,670 --> 00:19:20,900
from both core names we want friends is

00:19:18,320 --> 00:19:23,870
going to be a fake array with from two

00:19:20,900 --> 00:19:27,110
to four items drawn from each of which

00:19:23,870 --> 00:19:29,180
would be another fake name and of course

00:19:27,110 --> 00:19:31,220
because this is all higher-order

00:19:29,180 --> 00:19:32,690
programming even though data fake

00:19:31,220 --> 00:19:34,580
provides a lot of plugins if you have

00:19:32,690 --> 00:19:35,930
some specialized thing that you want

00:19:34,580 --> 00:19:37,550
that's different of course just write a

00:19:35,930 --> 00:19:40,520
generator function and drop it and it

00:19:37,550 --> 00:19:43,670
just works so let's take a look at some

00:19:40,520 --> 00:19:45,650
of the sample output so here's a result

00:19:43,670 --> 00:19:48,530
of our hero factory named Angel Dion

00:19:45,650 --> 00:19:50,180
rush a battle cry in Latin a birthday

00:19:48,530 --> 00:19:51,250
sometime in the past very young

00:19:50,180 --> 00:19:54,370
superhero

00:19:51,250 --> 00:19:56,140
relative to me anyway and a number of

00:19:54,370 --> 00:19:57,909
friends all of which randomly generated

00:19:56,140 --> 00:20:01,330
in this case the fake name is like a

00:19:57,909 --> 00:20:04,140
first middle last kind of pattern we

00:20:01,330 --> 00:20:06,120
might have weighed Stetson Johnson or

00:20:04,140 --> 00:20:09,400
Alison al Monroe

00:20:06,120 --> 00:20:12,039
so this achieves our goal we have lots

00:20:09,400 --> 00:20:13,870
of similar but slightly different things

00:20:12,039 --> 00:20:16,000
all expressed at a very simple

00:20:13,870 --> 00:20:17,770
declarative fashion all which easy to

00:20:16,000 --> 00:20:18,940
extend because it all builds on

00:20:17,770 --> 00:20:22,090
higher-order programming

00:20:18,940 --> 00:20:24,640
so to recap of what I've gone over today

00:20:22,090 --> 00:20:26,890
we have the idea of closures being

00:20:24,640 --> 00:20:28,570
anonymous on funds of state the idea of

00:20:26,890 --> 00:20:31,330
higher-order programming being functions

00:20:28,570 --> 00:20:32,590
that are generating functions and array

00:20:31,330 --> 00:20:34,090
gender I showed an example of array

00:20:32,590 --> 00:20:36,490
generation as a way of generalizing

00:20:34,090 --> 00:20:38,590
behavior and I talked a little little

00:20:36,490 --> 00:20:40,690
bit about data fake for declarative

00:20:38,590 --> 00:20:42,520
structured data so with that as a

00:20:40,690 --> 00:20:46,520
background I encourage all of you to

00:20:42,520 --> 00:20:50,010
take your Perl to 11 thank you very much

00:20:46,520 --> 00:20:50,010
[Applause]

00:20:51,720 --> 00:20:55,740
so either I've all put you to sleep or

00:20:54,210 --> 00:20:57,659
you all think it's perfect or you there

00:20:55,740 --> 00:20:59,700
are some questions out there any actual

00:20:57,659 --> 00:21:01,169
questions about higher order programming

00:20:59,700 --> 00:21:02,399
data fake any of the sort of stuff I

00:21:01,169 --> 00:21:03,509
talked about this is all like familiar

00:21:02,399 --> 00:21:06,500
or is this kind of new and interesting

00:21:03,509 --> 00:21:06,500
yes

00:21:17,850 --> 00:21:23,880
I mean so the thing about so the

00:21:21,450 --> 00:21:25,710
question was is there a benefit to being

00:21:23,880 --> 00:21:27,809
lazy so rather than trying to eagerly

00:21:25,710 --> 00:21:29,280
generate things is it beneficial to sort

00:21:27,809 --> 00:21:31,289
of delay into the last possible minute

00:21:29,280 --> 00:21:32,940
to generate things the powder my shared

00:21:31,289 --> 00:21:35,220
sort of delays things very much to the

00:21:32,940 --> 00:21:39,570
to the end and I think that that sort of

00:21:35,220 --> 00:21:41,370
is the most generalizable behavior what

00:21:39,570 --> 00:21:42,900
also isn't I didn't show here is a sort

00:21:41,370 --> 00:21:45,240
of optionality right you might be like

00:21:42,900 --> 00:21:47,370
well in this case maybe I want an energy

00:21:45,240 --> 00:21:48,600
or or maybe I want a name right so that

00:21:47,370 --> 00:21:51,750
sort of is a pick that has to happen

00:21:48,600 --> 00:21:53,070
kind of at the last minute so I think

00:21:51,750 --> 00:21:55,220
that sort of there's a benefit to being

00:21:53,070 --> 00:21:58,610
as lazy as possible

00:21:55,220 --> 00:21:58,610
other questions

00:22:26,440 --> 00:22:32,210
when the direction

00:22:29,590 --> 00:22:33,590
so the collect the question I'm gonna

00:22:32,210 --> 00:22:35,780
see if I can summarize the questions the

00:22:33,590 --> 00:22:38,570
question was or a sort of a statement

00:22:35,780 --> 00:22:41,540
followed by this is that he's very

00:22:38,570 --> 00:22:43,010
familiar with the idea of having like an

00:22:41,540 --> 00:22:44,660
infinite sequence of stuff and you sort

00:22:43,010 --> 00:22:47,840
of take some number of that of those

00:22:44,660 --> 00:22:49,040
things and then transform them and how

00:22:47,840 --> 00:22:50,570
does that compare to sort of what I did

00:22:49,040 --> 00:22:52,790
or why did I choose to do it this way

00:22:50,570 --> 00:22:55,220
versus that way some of this comes back

00:22:52,790 --> 00:22:58,910
to I think the idea that pearl is is

00:22:55,220 --> 00:23:00,680
lazy but not as lazy as Perl 6 and other

00:22:58,910 --> 00:23:02,030
land other purely functional languages

00:23:00,680 --> 00:23:04,340
that are very good at the notion of

00:23:02,030 --> 00:23:07,940
infinite lists of things don't have to

00:23:04,340 --> 00:23:09,380
be computed upfront and so and much of

00:23:07,940 --> 00:23:10,850
the time I've sort of thought about it

00:23:09,380 --> 00:23:12,050
more top-down of like well what does I

00:23:10,850 --> 00:23:14,000
want a data structure that looks like

00:23:12,050 --> 00:23:15,740
this I want this and this and this and I

00:23:14,000 --> 00:23:17,690
know pretty much how many things I want

00:23:15,740 --> 00:23:19,670
and so I thought probably kind of oh the

00:23:17,690 --> 00:23:21,140
only sort of infinite sequence I need is

00:23:19,670 --> 00:23:24,200
the infinite sequence of the random

00:23:21,140 --> 00:23:26,240
number generator in Perl dubious as it

00:23:24,200 --> 00:23:27,410
is compared to good rent but it's enough

00:23:26,240 --> 00:23:28,820
for a sort of creating fake data so

00:23:27,410 --> 00:23:32,150
essentially given a random sequence

00:23:28,820 --> 00:23:35,360
event of integers I can pull things out

00:23:32,150 --> 00:23:39,500
at random and that sort of enough other

00:23:35,360 --> 00:23:40,420
questions all right thanks very much for

00:23:39,500 --> 00:23:44,179
listening

00:23:40,420 --> 00:23:44,179

YouTube URL: https://www.youtube.com/watch?v=USF4BHMFKbg


