Title: Nicolas R. - "Learning XS by example"
Publication date: 2018-06-20
Playlist: TPC 2018 in SLC
Description: 
	Where / how / why to start writing XS, using XS::Logger like as an example
Captions: 
	00:00:00,000 --> 00:00:03,389
morning everyone thanks from being there

00:00:02,730 --> 00:00:06,690
so early

00:00:03,389 --> 00:00:10,170
so this torque is about running excess

00:00:06,690 --> 00:00:13,110
by example but before we start how many

00:00:10,170 --> 00:00:16,340
among you already played or created

00:00:13,110 --> 00:00:20,730
their own excess module in this room

00:00:16,340 --> 00:00:23,070
okay perfect so for this torque is many

00:00:20,730 --> 00:00:25,439
targeting people who are never created

00:00:23,070 --> 00:00:27,750
in excess modules but on the other side

00:00:25,439 --> 00:00:29,550
for the one who like alpha the audience

00:00:27,750 --> 00:00:32,460
from what I can see we already work with

00:00:29,550 --> 00:00:35,250
excess this is going probably to provide

00:00:32,460 --> 00:00:38,010
you some tools on some trick to that you

00:00:35,250 --> 00:00:39,840
could use with your excess modules so

00:00:38,010 --> 00:00:43,440
first of all I'm Nicolas and you can

00:00:39,840 --> 00:00:45,210
find me online at to make where you

00:00:43,440 --> 00:00:50,820
could find also the slides for this

00:00:45,210 --> 00:00:53,969
torque so why by example because excess

00:00:50,820 --> 00:00:58,469
is odd it's art to learn on a ivory

00:00:53,969 --> 00:01:00,930
think that examples on digging directly

00:00:58,469 --> 00:01:02,910
into the code gives you the best way to

00:01:00,930 --> 00:01:04,530
understand it you need to play with it

00:01:02,910 --> 00:01:06,960
you need to do mistake to learn with it

00:01:04,530 --> 00:01:09,780
on that why we're going through examples

00:01:06,960 --> 00:01:11,909
there's no documentation online on the

00:01:09,780 --> 00:01:14,850
excess exist some are good but it's

00:01:11,909 --> 00:01:17,460
pretty hard to find content to know

00:01:14,850 --> 00:01:20,580
where to start and the goal of this work

00:01:17,460 --> 00:01:23,850
is let's try to do it together

00:01:20,580 --> 00:01:27,030
using a toy example which means that I'm

00:01:23,850 --> 00:01:29,040
going to show you in that torch a module

00:01:27,030 --> 00:01:31,680
that I use for the purpose of that torch

00:01:29,040 --> 00:01:34,950
it's not designed to be used in

00:01:31,680 --> 00:01:39,229
production it's just there as a toy so

00:01:34,950 --> 00:01:42,780
we could play with it so why excess

00:01:39,229 --> 00:01:46,829
excess it's a blue like it's a glue

00:01:42,780 --> 00:01:50,100
that's going in fact to make the

00:01:46,829 --> 00:01:52,770
transition between your C program or any

00:01:50,100 --> 00:01:56,219
existing C library on your pal code

00:01:52,770 --> 00:01:58,380
that's one main reason to use excess if

00:01:56,219 --> 00:02:00,570
you have a C library somewhere and you

00:01:58,380 --> 00:02:02,159
want to use it and you do not want to

00:02:00,570 --> 00:02:05,100
record everything you just want to use

00:02:02,159 --> 00:02:09,179
it so excess is the perfect case of

00:02:05,100 --> 00:02:11,980
usage for that purpose but in other case

00:02:09,179 --> 00:02:15,970
you also want to make your code faster

00:02:11,980 --> 00:02:18,099
you also want to to optimize some very

00:02:15,970 --> 00:02:20,620
specific function on you could consider

00:02:18,099 --> 00:02:22,959
excess there are many other solution and

00:02:20,620 --> 00:02:26,709
your priority all about in ninety but

00:02:22,959 --> 00:02:30,489
excess is one of them so excess zone for

00:02:26,709 --> 00:02:32,830
external parts of routines and another

00:02:30,489 --> 00:02:34,420
advantage of using excess is that your

00:02:32,830 --> 00:02:37,569
memory will be shared among your

00:02:34,420 --> 00:02:39,120
processes there so this is also win on

00:02:37,569 --> 00:02:43,380
memory on speed on memory

00:02:39,120 --> 00:02:46,930
so in this talks you will see some code

00:02:43,380 --> 00:02:48,519
probably too much good as some of them I

00:02:46,930 --> 00:02:52,150
realized that the screen is pretty too

00:02:48,519 --> 00:02:54,819
small so if you do not get their links

00:02:52,150 --> 00:02:58,329
to get the slides you can still find

00:02:54,819 --> 00:03:01,569
them online and on my atomic link if

00:02:58,329 --> 00:03:03,459
it's too small on your too far so the

00:03:01,569 --> 00:03:06,940
very first thing to start accessor at

00:03:03,459 --> 00:03:10,599
least for me is pair itself on the best

00:03:06,940 --> 00:03:13,180
way to know how pair works is probably

00:03:10,599 --> 00:03:16,470
to go and check peril itself on mainly

00:03:13,180 --> 00:03:19,620
there the H file inside the PAL

00:03:16,470 --> 00:03:25,209
repository this is where I'll define the

00:03:19,620 --> 00:03:29,410
C macro on all of these C natural are

00:03:25,209 --> 00:03:33,400
there to make your life easier to play

00:03:29,410 --> 00:03:36,100
with the internals so to access the to

00:03:33,400 --> 00:03:39,069
create the the pair internal plantation

00:03:36,100 --> 00:03:43,359
of one scalar on also to access one of

00:03:39,069 --> 00:03:45,310
this slot so doing excess from it's a

00:03:43,359 --> 00:03:48,639
lot of going backward and forward

00:03:45,310 --> 00:03:51,310
between the pair source code on my

00:03:48,639 --> 00:03:54,040
excess code and this is some of them but

00:03:51,310 --> 00:03:54,700
you might choose more so don't be shy on

00:03:54,040 --> 00:03:58,630
go on

00:03:54,700 --> 00:04:00,400
check the H files so let's start to

00:03:58,630 --> 00:04:02,709
start one excess module the very first

00:04:00,400 --> 00:04:05,500
thing we need to do is probably create a

00:04:02,709 --> 00:04:07,359
parallel module so in that case the

00:04:05,500 --> 00:04:07,750
parent module and creating is just XS

00:04:07,359 --> 00:04:10,269
Ruger

00:04:07,750 --> 00:04:12,549
ok I'm using it straight on warnings and

00:04:10,269 --> 00:04:15,430
I'm using excess loaders I set a version

00:04:12,549 --> 00:04:16,930
number and I just ask excess loader to

00:04:15,430 --> 00:04:21,849
load my

00:04:16,930 --> 00:04:23,710
compiled excess code okay there are

00:04:21,849 --> 00:04:25,510
still some a bowl of place there we can

00:04:23,710 --> 00:04:29,140
make it a little shorter

00:04:25,510 --> 00:04:31,060
by simply using this because the event

00:04:29,140 --> 00:04:33,160
of version is kind of even if it's good

00:04:31,060 --> 00:04:34,540
to have it scan it's optional and you

00:04:33,160 --> 00:04:36,130
could simply use on those corners core

00:04:34,540 --> 00:04:38,230
package to get your package name space

00:04:36,130 --> 00:04:43,600
so you could use this everywhere and you

00:04:38,230 --> 00:04:45,340
could use your excess code so now that

00:04:43,600 --> 00:04:48,580
we have the PM file let's have a look at

00:04:45,340 --> 00:04:52,680
the excess file structure the first

00:04:48,580 --> 00:04:55,980
thing is where you should save that file

00:04:52,680 --> 00:04:59,050
technically that's why should go in your

00:04:55,980 --> 00:05:02,580
destroyed directory leave a slash in

00:04:59,050 --> 00:05:05,650
that case that will be live slash logo /

00:05:02,580 --> 00:05:08,890
no lip / look at that success and if you

00:05:05,650 --> 00:05:10,690
have a certain module now leave such

00:05:08,890 --> 00:05:13,630
excess let's locate that excess in that

00:05:10,690 --> 00:05:16,150
model in that case but you can also save

00:05:13,630 --> 00:05:17,680
it at the root of your directory and it

00:05:16,150 --> 00:05:21,790
would be perfectly fine because it will

00:05:17,680 --> 00:05:25,990
fall back to get it so the excess source

00:05:21,790 --> 00:05:29,200
code is divided in three part to many

00:05:25,990 --> 00:05:31,870
two parts the first one is three parts

00:05:29,200 --> 00:05:35,110
the first part is the headers the second

00:05:31,870 --> 00:05:38,620
is the C code itself on the third part

00:05:35,110 --> 00:05:40,360
is your excess code so here what I want

00:05:38,620 --> 00:05:43,060
to use is trying to use the flag to know

00:05:40,360 --> 00:05:44,560
that my excess code was loaded so that's

00:05:43,060 --> 00:05:45,040
why I use a define this is totally

00:05:44,560 --> 00:05:47,680
optional

00:05:45,040 --> 00:05:50,320
then I include peril itself the three

00:05:47,680 --> 00:05:53,080
main H file that will load symbols on

00:05:50,320 --> 00:05:55,030
the PL API okay and then you could

00:05:53,080 --> 00:05:57,460
that's where we have external dot H

00:05:55,030 --> 00:05:59,650
payload H except dot H that's what we

00:05:57,460 --> 00:06:04,030
try out to do exits and then you could

00:05:59,650 --> 00:06:06,430
loot load any C library and that's where

00:06:04,030 --> 00:06:11,050
it goes but you could also provide your

00:06:06,430 --> 00:06:13,450
own you own H dot file okay and then you

00:06:11,050 --> 00:06:15,760
can start excess so you are going to

00:06:13,450 --> 00:06:17,740
define your module namespace by

00:06:15,760 --> 00:06:19,900
replacing the current by underscore by

00:06:17,740 --> 00:06:21,460
convention and you set your package name

00:06:19,900 --> 00:06:23,800
space on the prefix is absolutely

00:06:21,460 --> 00:06:27,100
optional I try to use it one more

00:06:23,800 --> 00:06:29,680
because it makes it all so clear which

00:06:27,100 --> 00:06:31,210
means that all my function will start by

00:06:29,680 --> 00:06:32,620
that prefix in that case all the

00:06:31,210 --> 00:06:35,550
function will start with X log

00:06:32,620 --> 00:06:37,440
underscore which means in the name space

00:06:35,550 --> 00:06:40,710
exists log

00:06:37,440 --> 00:06:44,130
the function some will map to its log

00:06:40,710 --> 00:06:46,410
underscore some okay so if you have a

00:06:44,130 --> 00:06:49,500
look at that function in that year it

00:06:46,410 --> 00:06:51,150
takes two argument a and B and for a and

00:06:49,500 --> 00:06:53,270
B what we are going to do we are going

00:06:51,150 --> 00:06:56,520
to access to the integral slot of the

00:06:53,270 --> 00:06:59,460
scale value and we're going to do the

00:06:56,520 --> 00:07:01,170
sum in C which is absolutely useless you

00:06:59,460 --> 00:07:02,900
are not going to make any optimization

00:07:01,170 --> 00:07:07,320
doing this and then we are going to

00:07:02,900 --> 00:07:11,990
create a new SV with that value in that

00:07:07,320 --> 00:07:15,540
integral this is just for example there

00:07:11,990 --> 00:07:21,240
so this is your very first excess

00:07:15,540 --> 00:07:23,510
function so now that we have the PM file

00:07:21,240 --> 00:07:26,700
we have the excess file we need

00:07:23,510 --> 00:07:30,840
something to build them most of the

00:07:26,700 --> 00:07:33,540
distro will use excuted mapmaker on that

00:07:30,840 --> 00:07:36,090
watch I just want to do there so that

00:07:33,540 --> 00:07:38,130
will improve then you couldn't make on

00:07:36,090 --> 00:07:41,610
the make test making style it will

00:07:38,130 --> 00:07:45,600
compile your f---ing in billable but I

00:07:41,610 --> 00:07:47,490
also want to switch to this year and

00:07:45,600 --> 00:07:50,100
this is the minimal this year

00:07:47,490 --> 00:07:52,680
configuration I could find and to do

00:07:50,100 --> 00:07:55,140
excess you can probably move it because

00:07:52,680 --> 00:07:58,470
ad basics involve a lot of things you

00:07:55,140 --> 00:07:59,850
can't really make it shorter but what I

00:07:58,470 --> 00:08:01,830
just want to use a cheap and file to

00:07:59,850 --> 00:08:04,170
this all my distro which much more

00:08:01,830 --> 00:08:06,900
easier so then using this you could use

00:08:04,170 --> 00:08:11,480
a DC test digi build on this video

00:08:06,900 --> 00:08:11,480
release or so this is very very useful

00:08:11,630 --> 00:08:18,570
so our previous example was providing a

00:08:16,200 --> 00:08:20,970
sum so we want to just check that the

00:08:18,570 --> 00:08:25,320
sum is working in that case we're just

00:08:20,970 --> 00:08:28,980
going to do a threesome one with two

00:08:25,320 --> 00:08:31,320
integrals value and one with two strings

00:08:28,980 --> 00:08:33,180
and one with one string on one integral

00:08:31,320 --> 00:08:37,770
just to check that our C function is

00:08:33,180 --> 00:08:40,500
working yeah so I'm cheating there you

00:08:37,770 --> 00:08:44,910
cannot see anything but it's passing and

00:08:40,500 --> 00:08:46,980
I I won't make make tests on the I also

00:08:44,910 --> 00:08:49,080
run it manually using prove on if you

00:08:46,980 --> 00:08:53,760
use proof you need to use the

00:08:49,080 --> 00:09:00,140
be BL argument to specify the believe

00:08:53,760 --> 00:09:05,460
directory from the lib so let's start

00:09:00,140 --> 00:09:08,130
now part of this torque is also I'll

00:09:05,460 --> 00:09:11,760
show you how we could create a lot a

00:09:08,130 --> 00:09:16,290
model and an object in excess with

00:09:11,760 --> 00:09:19,440
accessors on play with it so many in C

00:09:16,290 --> 00:09:21,030
you have strut on enim so let's use both

00:09:19,440 --> 00:09:24,030
of them you are welcome to create a

00:09:21,030 --> 00:09:26,940
stretch to save or Logar information

00:09:24,030 --> 00:09:28,910
with some information store like e are

00:09:26,940 --> 00:09:31,800
we going to use color would it be

00:09:28,910 --> 00:09:35,610
printing debugging information what your

00:09:31,800 --> 00:09:38,490
PID we started creating that logger used

00:09:35,610 --> 00:09:41,100
for destroying it where is the file

00:09:38,490 --> 00:09:42,630
where we should log information on what

00:09:41,100 --> 00:09:44,940
kind of level it is so this is what

00:09:42,630 --> 00:09:47,610
contains the throat on for the level we

00:09:44,940 --> 00:09:49,140
are going to use one enumeration because

00:09:47,610 --> 00:09:51,120
it makes the code easier to read we

00:09:49,140 --> 00:09:52,560
could also use simply integral but that

00:09:51,120 --> 00:09:54,390
makes the code much more easier to read

00:09:52,560 --> 00:09:57,960
on if later we need to remove one or

00:09:54,390 --> 00:10:00,930
other ones would be easier so this is my

00:09:57,960 --> 00:10:03,930
H file that I will use all the all

00:10:00,930 --> 00:10:07,350
during the story so now that we have

00:10:03,930 --> 00:10:12,900
that structure we want a new constructor

00:10:07,350 --> 00:10:15,780
we want to create a logger so the new

00:10:12,900 --> 00:10:17,880
function is prefixed with s log

00:10:15,780 --> 00:10:20,370
underscore the same as the other because

00:10:17,880 --> 00:10:22,470
I'm using prefix I could remove it on

00:10:20,370 --> 00:10:25,590
the removed or the prefix there I'm

00:10:22,470 --> 00:10:27,720
going to say that my function is going

00:10:25,590 --> 00:10:31,710
to use a pointer on an ilogger

00:10:27,720 --> 00:10:34,980
structure that we just saw I'm going to

00:10:31,710 --> 00:10:37,410
also use one as V that's going to be the

00:10:34,980 --> 00:10:40,320
one that I'm going to return I'm going

00:10:37,410 --> 00:10:44,030
to return a pointer on that SV mainly so

00:10:40,320 --> 00:10:46,680
the first then the first line is new

00:10:44,030 --> 00:10:50,670
existing else than Malik we've

00:10:46,680 --> 00:10:54,750
initialized it to zero in parallel so I

00:10:50,670 --> 00:10:58,010
am creating am I looking a pointer to my

00:10:54,750 --> 00:11:01,080
logger the size of my loggers root of

00:10:58,010 --> 00:11:02,019
one one element the one is stands for

00:11:01,080 --> 00:11:03,279
one element if you know the

00:11:02,019 --> 00:11:04,959
you need more than one you are going to

00:11:03,279 --> 00:11:07,929
use more than one the size of my lager

00:11:04,959 --> 00:11:11,170
multiplied by one so you are my locking

00:11:07,929 --> 00:11:14,290
your lager point content on other

00:11:11,170 --> 00:11:16,420
pointer pointing to it then what you are

00:11:14,290 --> 00:11:17,829
going to return to pair is not the fruit

00:11:16,420 --> 00:11:19,989
itself pair will not be able to

00:11:17,829 --> 00:11:23,139
understand it what you need to return to

00:11:19,989 --> 00:11:26,049
pair is a pointer that points to that

00:11:23,139 --> 00:11:29,249
structure we all need to be aware that

00:11:26,049 --> 00:11:31,239
that point your point use something so

00:11:29,249 --> 00:11:32,980
you are what you're going to do you're

00:11:31,239 --> 00:11:37,809
going to create one RV which is a

00:11:32,980 --> 00:11:40,600
reference on that that RV is going then

00:11:37,809 --> 00:11:43,959
to contain the memory address what that

00:11:40,600 --> 00:11:46,449
watch is PTR to IV we are converting the

00:11:43,959 --> 00:11:49,959
pointer at one integral value and store

00:11:46,449 --> 00:11:54,939
it inside the IV's lot of the object

00:11:49,959 --> 00:11:58,360
where your reference points to because

00:11:54,939 --> 00:12:01,420
previously you got nu SVR V which create

00:11:58,360 --> 00:12:03,790
a ref which upgrade G is via red value

00:12:01,420 --> 00:12:06,040
to an RV and at the same time is to H 1

00:12:03,790 --> 00:12:08,199
sv that point to it on its return new g

00:12:06,040 --> 00:12:11,350
sv where the reference point to so herbs

00:12:08,199 --> 00:12:16,959
is where we are pointing to and we just

00:12:11,350 --> 00:12:19,389
want that memory address there so the

00:12:16,959 --> 00:12:23,769
what we can see from there it's a lot of

00:12:19,389 --> 00:12:26,649
boilerplate to convert the pointer of

00:12:23,769 --> 00:12:28,689
one struct to something we could pass to

00:12:26,649 --> 00:12:32,049
pair under the reverse would be the same

00:12:28,689 --> 00:12:34,209
once we will have that as V we will net

00:12:32,049 --> 00:12:36,009
you need to access that RV then access

00:12:34,209 --> 00:12:38,079
to that IV and then convert it to the

00:12:36,009 --> 00:12:42,009
pointer on cast it so it's a lot of

00:12:38,079 --> 00:12:44,529
boilerplate on of course pair comes with

00:12:42,009 --> 00:12:48,549
some very on the solution to solve this

00:12:44,529 --> 00:12:50,439
problem and this is name type map so

00:12:48,549 --> 00:12:55,299
most of the time you will find type map

00:12:50,439 --> 00:13:00,220
inside a file in a name type map in your

00:12:55,299 --> 00:13:01,889
district and the type map just say just

00:13:00,220 --> 00:13:05,649
say the

00:13:01,889 --> 00:13:08,559
what need to be converted to what in my

00:13:05,649 --> 00:13:10,720
case in our case we are the reference

00:13:08,559 --> 00:13:13,119
pointing towards throat so we're going

00:13:10,720 --> 00:13:15,280
to use the cheap each year of this is

00:13:13,119 --> 00:13:17,500
exactly what it is designed for

00:13:15,280 --> 00:13:19,330
there are probably 20 of option you

00:13:17,500 --> 00:13:22,060
could use instead of TPT rugs on the

00:13:19,330 --> 00:13:24,850
right and we're going to say that my

00:13:22,060 --> 00:13:27,400
logger point on it won't need to cover

00:13:24,850 --> 00:13:29,260
2gp garage on the excess arugula to a

00:13:27,400 --> 00:13:31,180
picture of the good thing is you could

00:13:29,260 --> 00:13:32,710
use type map in line in your excess code

00:13:31,180 --> 00:13:34,440
that's what I'm doing on the right so

00:13:32,710 --> 00:13:38,140
you can also put it on the same slide

00:13:34,440 --> 00:13:40,570
and it's only to have it there and then

00:13:38,140 --> 00:13:42,910
our function on the left become the one

00:13:40,570 --> 00:13:45,700
on the right which mean that instead of

00:13:42,910 --> 00:13:47,890
saying I'm going to return 1 sv pointer

00:13:45,700 --> 00:13:50,530
I'm just going to say I'm going to

00:13:47,890 --> 00:13:52,930
return one excess sugar on the type map

00:13:50,530 --> 00:13:58,750
we know we know had to convert that

00:13:52,930 --> 00:14:01,330
excess ruger to we know how to convert

00:13:58,750 --> 00:14:04,980
the the pointer to an object to a excess

00:14:01,330 --> 00:14:07,840
sugar due to the two type map lines on

00:14:04,980 --> 00:14:10,420
same thing when we will get it we could

00:14:07,840 --> 00:14:14,110
now say to prototype to prototype

00:14:10,420 --> 00:14:18,430
function now with excess lager or my

00:14:14,110 --> 00:14:20,530
lager instead of instead of a 1 sv and

00:14:18,430 --> 00:14:24,810
that would avoid us all this boilerplate

00:14:20,530 --> 00:14:28,030
of accessing the reference pointing but

00:14:24,810 --> 00:14:33,820
this is just optional that just makes

00:14:28,030 --> 00:14:36,310
your code shorter and easier to play so

00:14:33,820 --> 00:14:39,070
now that we have the constructor we need

00:14:36,310 --> 00:14:41,920
the destroy because you are my locking

00:14:39,070 --> 00:14:43,900
this memory address using new exhibit

00:14:41,920 --> 00:14:48,460
you are also responsible you are in

00:14:43,900 --> 00:14:51,850
charge to free that memory my destroy

00:14:48,460 --> 00:14:54,370
function is prefixed with X log and just

00:14:51,850 --> 00:14:59,589
say okay I'm going to free the memory if

00:14:54,370 --> 00:15:04,210
the if the the if they did not exist so

00:14:59,589 --> 00:15:07,150
that that all right after further so now

00:15:04,210 --> 00:15:10,510
we have a new on we have a destroy let's

00:15:07,150 --> 00:15:12,850
try to test them so the easiest thing

00:15:10,510 --> 00:15:16,870
will be to create a new object check

00:15:12,850 --> 00:15:19,900
that it's blessed on for the description

00:15:16,870 --> 00:15:21,820
by forcing G and F there on see that how

00:15:19,900 --> 00:15:23,230
it behaves on you need to be very

00:15:21,820 --> 00:15:24,670
careful because depending on the

00:15:23,230 --> 00:15:27,130
operating system of the compiler you're

00:15:24,670 --> 00:15:28,460
going to use you might you might have

00:15:27,130 --> 00:15:31,520
set forth on Sam or not

00:15:28,460 --> 00:15:33,680
if you have it incorrectly like for Mac

00:15:31,520 --> 00:15:36,590
OS compiling on Mac os10

00:15:33,680 --> 00:15:43,820
might I'd a lot of bugs comparing to

00:15:36,590 --> 00:15:45,500
compile on some Linux system there so

00:15:43,820 --> 00:15:47,690
okay so we have a constructor but now

00:15:45,500 --> 00:15:49,850
how we could pass some arguments to our

00:15:47,690 --> 00:15:52,880
constructor because new is fine but I

00:15:49,850 --> 00:15:56,410
would like to add some arguments so I'm

00:15:52,880 --> 00:15:59,690
going to cheat there because rather than

00:15:56,410 --> 00:16:03,620
passing argument one by one like a list

00:15:59,690 --> 00:16:08,540
I will pass a reference to an array to a

00:16:03,620 --> 00:16:11,960
rush sorry to rush and our goal here is

00:16:08,540 --> 00:16:14,240
to feed the street element to set them

00:16:11,960 --> 00:16:15,620
to different value so whatever this is

00:16:14,240 --> 00:16:19,430
what we want to do we want to create a

00:16:15,620 --> 00:16:22,820
new object so we want access er to get

00:16:19,430 --> 00:16:24,080
the value what is the value of us color

00:16:22,820 --> 00:16:26,780
what is the value of quiet in your

00:16:24,080 --> 00:16:30,890
throat but we also want to be able to

00:16:26,780 --> 00:16:33,050
set them at construction time so we're

00:16:30,890 --> 00:16:34,700
going to see probably we're going to see

00:16:33,050 --> 00:16:38,090
access or first because it's so much

00:16:34,700 --> 00:16:42,140
easier and then we will see how we could

00:16:38,090 --> 00:16:45,170
deal with a new where I pass a reference

00:16:42,140 --> 00:16:47,650
on an edge there so the access arose are

00:16:45,170 --> 00:16:50,000
pretty easy now that we have the type

00:16:47,650 --> 00:16:55,610
map they are not using the type map

00:16:50,000 --> 00:16:59,060
there might fine no no they are using

00:16:55,610 --> 00:17:01,370
type map the are using time so first

00:16:59,060 --> 00:17:03,020
access always get PID so we got self

00:17:01,370 --> 00:17:05,690
which is an excess rocker so we know is

00:17:03,020 --> 00:17:07,940
type map that how to get that throat

00:17:05,690 --> 00:17:10,700
that pointer to the struct and then we

00:17:07,940 --> 00:17:14,600
are through itself there and we just

00:17:10,700 --> 00:17:16,990
access to the PID slot to the PID slot

00:17:14,600 --> 00:17:21,080
inside the throat which is a sea

00:17:16,990 --> 00:17:25,400
integral and then we convert it to 1s v

00:17:21,080 --> 00:17:27,140
IV which you 1s v where the integral

00:17:25,400 --> 00:17:29,570
slot is filled with this and we return

00:17:27,140 --> 00:17:31,550
it to pal that's how we access the PID

00:17:29,570 --> 00:17:34,430
on same thing with the color even if the

00:17:31,550 --> 00:17:36,890
CRO is a boolean is the same thing so we

00:17:34,430 --> 00:17:39,800
can see that these two accesses for

00:17:36,890 --> 00:17:41,750
example have a lot in common on we would

00:17:39,800 --> 00:17:42,530
like to reduce this and there is a way

00:17:41,750 --> 00:17:46,810
to do this or so

00:17:42,530 --> 00:17:50,510
in excess this is what's named aliases

00:17:46,810 --> 00:17:53,660
this is how you could set it so you set

00:17:50,510 --> 00:17:58,220
like none of the actual function that

00:17:53,660 --> 00:18:00,230
you could also cool so Gators on my

00:17:58,220 --> 00:18:02,660
ideas will be get the ID you school or

00:18:00,230 --> 00:18:03,950
get level and get quiet because they are

00:18:02,660 --> 00:18:06,820
doing the same thing they are with

00:18:03,950 --> 00:18:09,800
trading data from the struct

00:18:06,820 --> 00:18:13,640
then what you would have is a special

00:18:09,800 --> 00:18:15,620
value name is like index and that will

00:18:13,640 --> 00:18:18,350
match the protocol value on the right

00:18:15,620 --> 00:18:20,900
one two three four and then you can do a

00:18:18,350 --> 00:18:23,450
switch say okay when is get the IDH will

00:18:20,900 --> 00:18:26,150
be one so i will access the PID slot

00:18:23,450 --> 00:18:29,330
when it's the u.s. code will go to the

00:18:26,150 --> 00:18:31,700
second one on so on and so on on in case

00:18:29,330 --> 00:18:35,030
i'm using something which is not defined

00:18:31,700 --> 00:18:38,540
there i'm going just which on on the

00:18:35,030 --> 00:18:40,490
undef that are you are using is a sweet

00:18:38,540 --> 00:18:42,290
emoji for this so then all your

00:18:40,490 --> 00:18:45,170
accessories could be in a very on g

00:18:42,290 --> 00:18:49,690
function and not going to porridge a lot

00:18:45,170 --> 00:18:54,260
of your code so now let's go back to new

00:18:49,690 --> 00:18:56,930
so new is taking an optional argument

00:18:54,260 --> 00:19:00,680
that in my case i'm using a reference to

00:18:56,930 --> 00:19:03,850
a hash so i'm using dot dot dot the C

00:19:00,680 --> 00:19:09,700
syntax saying okay optional argument on

00:19:03,850 --> 00:19:14,300
in excess rather than using the V a

00:19:09,700 --> 00:19:17,240
function family you are you can use

00:19:14,300 --> 00:19:19,340
items for that special variable coming

00:19:17,240 --> 00:19:21,970
from XS that will tell you how many

00:19:19,340 --> 00:19:24,920
items are passed to your function call

00:19:21,970 --> 00:19:27,170
so in my case if we have one if we're

00:19:24,920 --> 00:19:33,070
Mada than than one because the first one

00:19:27,170 --> 00:19:35,420
is your package name space oh yeah then

00:19:33,070 --> 00:19:38,030
what we are going to do we are going to

00:19:35,420 --> 00:19:40,160
fetch the for the second element

00:19:38,030 --> 00:19:41,960
sg1 we're going to fetch the second

00:19:40,160 --> 00:19:44,930
element from the stack because the first

00:19:41,960 --> 00:19:46,970
will be a zero position and that second

00:19:44,930 --> 00:19:50,240
element of the stash we ought to be a

00:19:46,970 --> 00:19:51,800
pointer to 1 sv on what we are doing we

00:19:50,240 --> 00:19:53,510
are checking that that pointer is

00:19:51,800 --> 00:19:57,080
pointing to

00:19:53,510 --> 00:20:00,290
reference of her ash its type should be

00:19:57,080 --> 00:20:02,660
pv h v and if that the k then okay we

00:20:00,290 --> 00:20:06,830
say okay we have some options defined

00:20:02,660 --> 00:20:11,090
coming from the peril call cool on now

00:20:06,830 --> 00:20:13,490
we could check this this options so that

00:20:11,090 --> 00:20:16,130
the first first blocks with i if items

00:20:13,490 --> 00:20:18,560
written on one then we set the default

00:20:16,130 --> 00:20:21,170
value you will notice that only set the

00:20:18,560 --> 00:20:23,840
default value for use color to one why

00:20:21,170 --> 00:20:26,120
because we are using new eggsy on the

00:20:23,840 --> 00:20:28,760
system for 0 which mean that everything

00:20:26,120 --> 00:20:30,800
is initialized to 0 by default so i only

00:20:28,760 --> 00:20:34,910
need to initialize value different than

00:20:30,800 --> 00:20:37,130
0 that's cool and then if ops is defined

00:20:34,910 --> 00:20:40,700
which if like if I've got one argument

00:20:37,130 --> 00:20:43,310
I'm going to check if that ash has some

00:20:40,700 --> 00:20:47,050
of the key I'm expecting and to fetch

00:20:43,310 --> 00:20:51,500
this key in peril you are going to use

00:20:47,050 --> 00:20:54,920
HV fetch where you pass your pointer to

00:20:51,500 --> 00:20:56,690
your ash your key on there is a third

00:20:54,920 --> 00:20:59,330
argument which is optional which means

00:20:56,690 --> 00:21:02,450
do you want to create it if it does not

00:20:59,330 --> 00:21:04,580
exist in my case I say force because I

00:21:02,450 --> 00:21:08,300
if it does not exist you have no reason

00:21:04,580 --> 00:21:10,880
to create it then if there is something

00:21:08,300 --> 00:21:14,450
defined for that slot I've got a pointer

00:21:10,880 --> 00:21:17,180
on one SV but what s V P stands for and

00:21:14,450 --> 00:21:20,690
then I can check if it looks valid for

00:21:17,180 --> 00:21:23,330
example in case of color expect boolean

00:21:20,690 --> 00:21:26,600
but many I'm just going to check if it's

00:21:23,330 --> 00:21:28,430
one integer there and then if it's

00:21:26,600 --> 00:21:31,190
defined I'm going to cast it to boolean

00:21:28,430 --> 00:21:34,610
and save it inside my throat and then

00:21:31,190 --> 00:21:37,700
same thing with the level so that would

00:21:34,610 --> 00:21:40,820
under a new with an optional argument

00:21:37,700 --> 00:21:45,010
ash with anything you want inside that

00:21:40,820 --> 00:21:51,140
ash do that you could fetch from there

00:21:45,010 --> 00:21:53,690
and then sort through your throat so

00:21:51,140 --> 00:21:56,270
we're going now to check that it's

00:21:53,690 --> 00:21:59,150
working so what we could do now we can

00:21:56,270 --> 00:22:02,240
create a new object we can use the

00:21:59,150 --> 00:22:04,880
accessor check the default value so get

00:22:02,240 --> 00:22:06,980
pids set by 0 by default because it's

00:22:04,880 --> 00:22:07,280
coming from the murat user i set to 1

00:22:06,980 --> 00:22:10,190
because

00:22:07,280 --> 00:22:12,590
like that the specialized case I treated

00:22:10,190 --> 00:22:14,270
and then I check the description then

00:22:12,590 --> 00:22:17,750
and now I check that if I created a new

00:22:14,270 --> 00:22:18,620
object with a color now this time set to

00:22:17,750 --> 00:22:21,980
false

00:22:18,620 --> 00:22:24,650
it's come back as force on so on and so

00:22:21,980 --> 00:22:26,060
on and then I can also try to play with

00:22:24,650 --> 00:22:31,010
different values on check that they are

00:22:26,060 --> 00:22:33,830
not conflicting that's good so that now

00:22:31,010 --> 00:22:36,380
we are accessors who have new we could

00:22:33,830 --> 00:22:38,180
also use setters so the same way we are

00:22:36,380 --> 00:22:41,030
going to use aliases because setters

00:22:38,180 --> 00:22:43,130
will all looks like the same and we are

00:22:41,030 --> 00:22:45,320
going to call them set level set quiet

00:22:43,130 --> 00:22:48,160
for example so you could change your

00:22:45,320 --> 00:22:53,330
debug level at runtime or you could also

00:22:48,160 --> 00:22:54,950
mute it when you want the thing you are

00:22:53,330 --> 00:22:56,600
going to do you are going to in that

00:22:54,950 --> 00:23:01,850
case there is no optional argument you

00:22:56,600 --> 00:23:05,320
just have you just have a value for a

00:23:01,850 --> 00:23:08,120
function you only have the first one is

00:23:05,320 --> 00:23:10,430
yourself your object on the pointer to

00:23:08,120 --> 00:23:12,470
yourself in fact on the the the second

00:23:10,430 --> 00:23:14,390
is your value so you just check which

00:23:12,470 --> 00:23:17,360
one you are calling with the IX coming

00:23:14,390 --> 00:23:18,860
from XS and if you are in the set level

00:23:17,360 --> 00:23:21,410
function then you are getting it on your

00:23:18,860 --> 00:23:23,450
stirring in level and if you are on the

00:23:21,410 --> 00:23:26,510
second case you are going to pay it and

00:23:23,450 --> 00:23:29,210
then if you buy any case you come there

00:23:26,510 --> 00:23:31,820
with any other value than one on two

00:23:29,210 --> 00:23:34,760
then you can just broke that will call

00:23:31,820 --> 00:23:37,580
back throw it back to to pair with some

00:23:34,760 --> 00:23:43,730
natural you could work on under in

00:23:37,580 --> 00:23:46,330
excess okay so another so we saw that we

00:23:43,730 --> 00:23:51,140
have an enumeration for the arm

00:23:46,330 --> 00:23:54,470
debugging levels but we also would like

00:23:51,140 --> 00:23:58,280
to provide our user to use these levers

00:23:54,470 --> 00:24:02,120
inside their pal code on of course we

00:23:58,280 --> 00:24:08,950
could copy/paste it but I don't like

00:24:02,120 --> 00:24:13,190
that idea is not good for Madness and we

00:24:08,950 --> 00:24:17,120
we would like a way for our user a door

00:24:13,190 --> 00:24:20,330
to set the default level a door to use

00:24:17,120 --> 00:24:24,350
one of them so how we could how could we

00:24:20,330 --> 00:24:27,620
do this mainly there is INXS there's a

00:24:24,350 --> 00:24:29,960
boot function on what I'm going to do is

00:24:27,620 --> 00:24:32,870
at boot time so which men when the

00:24:29,960 --> 00:24:34,850
excess file is loaded and the compiled

00:24:32,870 --> 00:24:37,730
excess file is loaded we are going to

00:24:34,850 --> 00:24:40,790
define some constant there and this

00:24:37,730 --> 00:24:45,830
constant will exactly match the value of

00:24:40,790 --> 00:24:48,110
what's defining the H file so you could

00:24:45,830 --> 00:24:50,780
see there the very first constant I'm so

00:24:48,110 --> 00:24:53,690
first I'm getting the stache name excess

00:24:50,780 --> 00:24:55,460
lager and I say true which mean created

00:24:53,690 --> 00:24:57,560
that case if it missing no problem you

00:24:55,460 --> 00:24:59,870
can create it the ten is just the length

00:24:57,560 --> 00:25:02,150
of the the key that case the excess

00:24:59,870 --> 00:25:04,130
sugar so it will go through the excess -

00:25:02,150 --> 00:25:06,050
then access to the lager - from excess

00:25:04,130 --> 00:25:08,390
and gave me a pointer to that stash

00:25:06,050 --> 00:25:09,920
which is nothing else than ash this is

00:25:08,390 --> 00:25:11,990
where our straw or your amount for your

00:25:09,920 --> 00:25:13,610
package name and then I'm going just to

00:25:11,990 --> 00:25:18,650
store something in the very first value

00:25:13,610 --> 00:25:20,030
I store is loaded which means adjuster

00:25:18,650 --> 00:25:23,690
check that check that my modular is

00:25:20,030 --> 00:25:25,220
loaded by eight totally useless but and

00:25:23,690 --> 00:25:28,220
then I'm going to have all this constant

00:25:25,220 --> 00:25:31,970
function debug log level info log level

00:25:28,220 --> 00:25:35,750
that will exactly match what the engine

00:25:31,970 --> 00:25:38,480
is by creating one new SV on filling the

00:25:35,750 --> 00:25:42,380
IV slot which mean then later impeller

00:25:38,480 --> 00:25:44,360
pure code I could use the syntax like

00:25:42,380 --> 00:25:51,290
describe the width of three last line on

00:25:44,360 --> 00:25:53,530
this our constant C V so now we go to

00:25:51,290 --> 00:25:59,510
match that's good

00:25:53,530 --> 00:26:03,560
the next thing is the file where to log

00:25:59,510 --> 00:26:08,810
I what also C to be the reference on

00:26:03,560 --> 00:26:11,150
define where we should log content but I

00:26:08,810 --> 00:26:13,640
also want to provide user the ability to

00:26:11,150 --> 00:26:16,520
provide their own files in one or two

00:26:13,640 --> 00:26:20,900
ways either they could provide their log

00:26:16,520 --> 00:26:23,630
your file by setting a global value

00:26:20,900 --> 00:26:25,910
inside their like excess flow path I say

00:26:23,630 --> 00:26:27,980
oh this is what I want to block or they

00:26:25,910 --> 00:26:29,470
could also maybe provide it at

00:26:27,980 --> 00:26:32,179
construction later

00:26:29,470 --> 00:26:36,110
so in that case

00:26:32,179 --> 00:26:37,940
what we are going to do at st. where

00:26:36,110 --> 00:26:40,309
we're still doing it at boot time at

00:26:37,940 --> 00:26:44,330
boot time who are going to create path

00:26:40,309 --> 00:26:47,570
file inside the XS Ruger package only if

00:26:44,330 --> 00:26:50,480
it's not defined in fact only if there

00:26:47,570 --> 00:26:51,740
is no strength for it that's why we are

00:26:50,480 --> 00:26:53,480
using SVP ok

00:26:51,740 --> 00:26:55,220
because for example maybe the user has

00:26:53,480 --> 00:26:57,740
defined one list there are one function

00:26:55,220 --> 00:27:00,950
by mistake so we are just interested

00:26:57,740 --> 00:27:04,039
about exit updating the the string of

00:27:00,950 --> 00:27:06,499
path file so in that case what we are

00:27:04,039 --> 00:27:11,119
going to do we are going to make it kind

00:27:06,499 --> 00:27:12,529
of run increasing its its ref count to

00:27:11,119 --> 00:27:16,960
make sure that not going to be destroyed

00:27:12,529 --> 00:27:21,340
on our back and we are just setting and

00:27:16,960 --> 00:27:26,289
the value to the default one which above

00:27:21,340 --> 00:27:31,190
okay but then later the user as it's a

00:27:26,289 --> 00:27:33,230
pair in scalar value the user is totally

00:27:31,190 --> 00:27:35,600
free to update that value at any time

00:27:33,230 --> 00:27:39,049
you will not update of course the static

00:27:35,600 --> 00:27:42,129
constancy but you will update the the

00:27:39,049 --> 00:27:45,980
scalar value in pair and then you could

00:27:42,129 --> 00:27:47,659
even set it add in a begin block which

00:27:45,980 --> 00:27:50,029
is optional we could set it after adding

00:27:47,659 --> 00:27:52,909
loaded your excess sugar you should not

00:27:50,029 --> 00:27:54,590
do it there's a protection but it is

00:27:52,909 --> 00:28:02,779
better to blow this excess program then

00:27:54,590 --> 00:28:05,389
after set it okay so we also want the

00:28:02,779 --> 00:28:09,289
ability to provide up wait for the user

00:28:05,389 --> 00:28:13,249
to set the path when they're creating an

00:28:09,289 --> 00:28:17,110
object so same thing we are going back

00:28:13,249 --> 00:28:22,909
to new on inside the new function we are

00:28:17,110 --> 00:28:25,249
going to to check if the file path is

00:28:22,909 --> 00:28:28,220
set or not and if it not set we are

00:28:25,249 --> 00:28:32,049
going to use at that time the value

00:28:28,220 --> 00:28:35,149
which is defined in path file this as

00:28:32,049 --> 00:28:37,999
probably one problem is that if I

00:28:35,149 --> 00:28:41,059
created me an object and then change the

00:28:37,999 --> 00:28:43,159
value before starting logging it will

00:28:41,059 --> 00:28:44,940
not choose the updated value it will

00:28:43,159 --> 00:28:49,050
freeze the value that was there

00:28:44,940 --> 00:28:50,930
before and we could fix that behavior in

00:28:49,050 --> 00:28:56,150
the next slide

00:28:50,930 --> 00:29:02,060
by making it lazy in kind of one way

00:28:56,150 --> 00:29:05,460
so for this we will only request the

00:29:02,060 --> 00:29:07,590
what is the file path when we are going

00:29:05,460 --> 00:29:08,910
to blog for the very first time and when

00:29:07,590 --> 00:29:11,880
we are going to load for the very first

00:29:08,910 --> 00:29:14,880
time we are going then to ask is there

00:29:11,880 --> 00:29:19,800
any value already stored in my strut my

00:29:14,880 --> 00:29:22,740
C struct and if there is none then I

00:29:19,800 --> 00:29:25,770
will check what should I use should I

00:29:22,740 --> 00:29:27,900
use the excess lager or worst case I

00:29:25,770 --> 00:29:31,230
will fall back to the default C value

00:29:27,900 --> 00:29:34,590
there so then you will have a you will

00:29:31,230 --> 00:29:36,150
use the second you start logging even if

00:29:34,590 --> 00:29:38,250
you change the value of path file you

00:29:36,150 --> 00:29:43,320
would still log to what was set for that

00:29:38,250 --> 00:29:47,220
logger this is a honor of course you

00:29:43,320 --> 00:29:51,420
need one accessor so just add one alias

00:29:47,220 --> 00:29:54,840
to the list on one switch to the one

00:29:51,420 --> 00:29:58,440
case to the switch cool so the basic

00:29:54,840 --> 00:29:59,970
loggers Itron some time to like Mirada

00:29:58,440 --> 00:30:02,910
although most for loggers want to like

00:29:59,970 --> 00:30:05,490
more than one way to use it and i think

00:30:02,910 --> 00:30:08,430
it's a very good case for example you

00:30:05,490 --> 00:30:10,220
either want the quick on easy way the

00:30:08,430 --> 00:30:12,630
one-liner where you don't want to

00:30:10,220 --> 00:30:14,850
initialize one object you just want to

00:30:12,630 --> 00:30:17,250
say hey I just want to log in full every

00:30:14,850 --> 00:30:19,500
one error or whatever that's what I

00:30:17,250 --> 00:30:20,940
provide them on the second way is that

00:30:19,500 --> 00:30:24,120
you have a custom logger you are to

00:30:20,940 --> 00:30:26,070
operating with you and you want them to

00:30:24,120 --> 00:30:29,360
use the specification which are

00:30:26,070 --> 00:30:32,820
different at the default on use this

00:30:29,360 --> 00:30:36,240
method call okay on the other thing I

00:30:32,820 --> 00:30:39,030
want to be like is I want to like like s

00:30:36,240 --> 00:30:43,530
printf syntax where you could pass

00:30:39,030 --> 00:30:45,120
optional argument behind and I know that

00:30:43,530 --> 00:30:47,550
most of the case I'm going to use that I

00:30:45,120 --> 00:30:49,920
I will not need unlimited there are

00:30:47,550 --> 00:30:51,270
argument behind so I'm just limiting for

00:30:49,920 --> 00:30:53,580
the purpose of that torque I'm just

00:30:51,270 --> 00:30:56,070
limiting it to ten arguments so for a

00:30:53,580 --> 00:30:57,989
number a number of for songi with the

00:30:56,070 --> 00:31:00,049
with the integral behind we'll just use

00:30:57,989 --> 00:31:03,809
s printf to convert that number

00:31:00,049 --> 00:31:06,149
correctly to two integral so I I like to

00:31:03,809 --> 00:31:08,850
maintain these two syntax but that means

00:31:06,149 --> 00:31:10,769
that our logger function need to be

00:31:08,850 --> 00:31:12,299
aware of these two and we see that all

00:31:10,769 --> 00:31:14,159
these longer function the only thing

00:31:12,299 --> 00:31:17,429
they are doing they are printing that

00:31:14,159 --> 00:31:19,759
what they're pointing to one of the two

00:31:17,429 --> 00:31:22,580
the file or even thirty to one file

00:31:19,759 --> 00:31:26,249
descriptor but they are they are very

00:31:22,580 --> 00:31:27,509
diluted in common so for this purpose

00:31:26,249 --> 00:31:30,840
what we are going to do we are also

00:31:27,509 --> 00:31:32,549
going to use aliases on the only thing

00:31:30,840 --> 00:31:36,979
we are going to do there we're going to

00:31:32,549 --> 00:31:40,889
set what is the level we want to blog

00:31:36,979 --> 00:31:43,349
okay I've got one extra information I

00:31:40,889 --> 00:31:49,739
think we can sit there okay that the

00:31:43,349 --> 00:31:51,989
same bigger order so except so this is

00:31:49,739 --> 00:31:53,970
our loggers function this is where they

00:31:51,989 --> 00:31:56,159
are all defined and I've got one extra

00:31:53,970 --> 00:31:58,830
flag that I defined the one that should

00:31:56,159 --> 00:31:59,460
die because logging on dying is two

00:31:58,830 --> 00:32:02,159
different things

00:31:59,460 --> 00:32:04,169
some of them like for example if your

00:32:02,159 --> 00:32:06,389
logger is disabled should not lock

00:32:04,169 --> 00:32:12,119
nothing and it should just should still

00:32:06,389 --> 00:32:16,919
live so we have one helper to manage all

00:32:12,119 --> 00:32:19,249
this function to lock so now how we are

00:32:16,919 --> 00:32:22,409
dealing with method or function code

00:32:19,249 --> 00:32:25,559
very what very easy we're going to check

00:32:22,409 --> 00:32:29,489
what is on our stack so in this case I'm

00:32:25,559 --> 00:32:31,139
not choosing self cool now I'm using dot

00:32:29,489 --> 00:32:33,499
directly because I have no idea what's

00:32:31,139 --> 00:32:38,539
the first argument is the first argument

00:32:33,499 --> 00:32:42,559
my object or is the first argument one

00:32:38,539 --> 00:32:45,029
argument fodder for the logger function

00:32:42,559 --> 00:32:47,820
so the first argument on the stack is

00:32:45,029 --> 00:32:49,979
hg0 so I'm just going to check in that

00:32:47,820 --> 00:32:51,929
case and that's the only place I'm not

00:32:49,979 --> 00:32:55,229
using type map where I'm going to check

00:32:51,929 --> 00:32:57,599
if that pointer points to one reference

00:32:55,229 --> 00:33:00,149
and if that's reference point to one

00:32:57,599 --> 00:33:01,470
object because when Iraq when your

00:33:00,149 --> 00:33:04,889
reference point to an object I've not

00:33:01,470 --> 00:33:08,369
mentioned but there is a flag as the

00:33:04,889 --> 00:33:09,029
object which is set to one on so if that

00:33:08,369 --> 00:33:11,459
the case

00:33:09,029 --> 00:33:13,259
I'm just getting my lager and I know

00:33:11,459 --> 00:33:15,299
that and I will said that my argument

00:33:13,259 --> 00:33:17,399
start at position 1 and by default they

00:33:15,299 --> 00:33:21,509
we start at position 0 so then I could

00:33:17,399 --> 00:33:25,309
deal with the argument so there then the

00:33:21,509 --> 00:33:29,009
concept of the lager once we will have

00:33:25,309 --> 00:33:32,279
this will be to open a file under

00:33:29,009 --> 00:33:43,379
acquire or lock on stick to the and undo

00:33:32,279 --> 00:33:45,839
the print ok so I came with a lager

00:33:43,379 --> 00:33:47,849
format you just need to have one I know

00:33:45,839 --> 00:33:50,339
it would be pray only to be able to

00:33:47,849 --> 00:33:52,289
customize it but I tried to use several

00:33:50,339 --> 00:33:56,069
on multiple time zones so I think it's

00:33:52,289 --> 00:33:59,099
good also to added the time zone to the

00:33:56,069 --> 00:34:02,789
to the day time the level of the lager

00:33:59,099 --> 00:34:03,989
or the PID the origin on the message ok

00:34:02,789 --> 00:34:06,779
we're going to see how to do this on

00:34:03,989 --> 00:34:09,690
also by the way also like Kalos so

00:34:06,779 --> 00:34:11,460
there's a way to have color so color

00:34:09,690 --> 00:34:14,309
same way it's very easy I will list I

00:34:11,460 --> 00:34:19,349
will use a 1 num2 this the colors and i

00:34:14,309 --> 00:34:22,159
will use the last slot - yeah um so i am

00:34:19,349 --> 00:34:26,129
using an indium to list the list many of

00:34:22,159 --> 00:34:28,190
string to list the color on the on the

00:34:26,129 --> 00:34:32,250
special character to disable the color

00:34:28,190 --> 00:34:34,649
route just the regular color code so

00:34:32,250 --> 00:34:37,109
then 20 in colors will be very easy if

00:34:34,649 --> 00:34:38,669
the color are disabled I'm not using

00:34:37,109 --> 00:34:41,069
them at just watching the log level name

00:34:38,669 --> 00:34:44,129
using F quint F in that case I'm not

00:34:41,069 --> 00:34:46,769
using the C layer the para layer sorry

00:34:44,129 --> 00:34:48,980
I'm using the C layer directly on if the

00:34:46,769 --> 00:34:52,289
logger are enabled then I just got the

00:34:48,980 --> 00:34:54,389
color level code on the end of it and I

00:34:52,289 --> 00:34:55,919
derived that level inside these two

00:34:54,389 --> 00:34:58,349
color blocks and that will display macro

00:34:55,919 --> 00:35:00,960
block so we just sort there in five

00:34:58,349 --> 00:35:04,500
lines out to display the information the

00:35:00,960 --> 00:35:05,849
level in name with color on it now we

00:35:04,500 --> 00:35:07,740
are going to check about the time stamp

00:35:05,849 --> 00:35:10,559
time stamp will be pretty easy you will

00:35:07,740 --> 00:35:15,960
use time dot H that provides you a time

00:35:10,559 --> 00:35:18,269
structure you as you will know the size

00:35:15,960 --> 00:35:20,609
of your time stop it's very only to use

00:35:18,269 --> 00:35:22,180
a buffer which we allocate the memory so

00:35:20,609 --> 00:35:24,369
you don't need to worry about

00:35:22,180 --> 00:35:26,020
Malaka come Freder so I'm going to use

00:35:24,369 --> 00:35:31,380
that buffer and side that buffer I'm

00:35:26,020 --> 00:35:35,980
going to store the time stop coming

00:35:31,380 --> 00:35:39,730
after a calling or look at a time system

00:35:35,980 --> 00:35:42,150
call then I will print it on while I

00:35:39,730 --> 00:35:44,410
appointed I will at the same time add

00:35:42,150 --> 00:35:46,809
timezone on check if the timezone is

00:35:44,410 --> 00:35:48,550
positive or negative on that will add

00:35:46,809 --> 00:35:53,680
the timestamp at the beginning of the

00:35:48,550 --> 00:35:57,640
logger so the PID for the PID we have a

00:35:53,680 --> 00:36:01,390
standard function get PID that will

00:35:57,640 --> 00:36:03,550
return you a PID so you just need to say

00:36:01,390 --> 00:36:09,220
called get PID on that mo finger than

00:36:03,550 --> 00:36:12,160
int behind it so the interesting one now

00:36:09,220 --> 00:36:14,890
is the program name the program name in

00:36:12,160 --> 00:36:18,609
pairs there are 0 ok in initial you

00:36:14,890 --> 00:36:21,670
could access it to come online in C it

00:36:18,609 --> 00:36:25,809
will be r v0 so the lazy way to access

00:36:21,670 --> 00:36:31,329
it into INXS will be to ask what is

00:36:25,809 --> 00:36:36,160
beyond the scale of value name 0 then

00:36:31,329 --> 00:36:38,829
check if it does value contain a string

00:36:36,160 --> 00:36:40,390
and if it does not contain a swings

00:36:38,829 --> 00:36:44,430
container when integral upgraded to a

00:36:40,390 --> 00:36:46,930
string at the same time and then get

00:36:44,430 --> 00:36:49,720
just get the string without its length

00:36:46,930 --> 00:36:52,540
what is VPP Nolan does there so we got a

00:36:49,720 --> 00:36:54,790
pointer to a car okay point order and we

00:36:52,540 --> 00:36:59,530
could print it directly this is how

00:36:54,790 --> 00:37:02,650
we're going to get the roster order okay

00:36:59,530 --> 00:37:06,450
and then the message as I mentioned I

00:37:02,650 --> 00:37:09,549
like the ability to provide like earth

00:37:06,450 --> 00:37:12,819
winter format on our optional argument

00:37:09,549 --> 00:37:18,069
behind so this is how I'm going to deal

00:37:12,819 --> 00:37:25,890
with this there so inside a search

00:37:18,069 --> 00:37:25,890
function that we also okay

00:37:26,809 --> 00:37:37,259
this is not there okay that code is kind

00:37:32,279 --> 00:37:41,190
of very ugly so what we are going to do

00:37:37,259 --> 00:37:43,200
we are going to loop so we yeah remember

00:37:41,190 --> 00:37:46,049
out there we start we store where our

00:37:43,200 --> 00:37:47,849
arguments start at so either position

00:37:46,049 --> 00:37:49,890
they're all position one then what we're

00:37:47,849 --> 00:37:51,779
going to do we are going to loop for all

00:37:49,890 --> 00:37:54,900
the items in our item pass to the

00:37:51,779 --> 00:37:56,519
function uncheck what type they are on

00:37:54,900 --> 00:37:58,799
depending on the type they are we are

00:37:56,519 --> 00:38:00,749
going to store them inside the struct

00:37:58,799 --> 00:38:03,930
that will because we want to do a

00:38:00,749 --> 00:38:07,559
sillier odorous story-tell integral

00:38:03,930 --> 00:38:09,839
double or or care pointer and then we

00:38:07,559 --> 00:38:13,650
will pass these values to our printf

00:38:09,839 --> 00:38:15,900
macro so that thing is just looping on

00:38:13,650 --> 00:38:17,970
we're limiting it to ten so that's why

00:38:15,900 --> 00:38:21,779
you are limiting up to 11 with the first

00:38:17,970 --> 00:38:24,650
that could be there um then we were

00:38:21,779 --> 00:38:25,859
going to just throw them in in your list

00:38:24,650 --> 00:38:30,920
Jihad's

00:38:25,859 --> 00:38:30,920
is a list of this argument there

00:38:39,810 --> 00:38:47,940
okay and then for printing it what I'm

00:38:43,980 --> 00:38:51,750
going to do I'm going to use some macro

00:38:47,940 --> 00:38:55,350
some see macro because depending if you

00:38:51,750 --> 00:39:00,420
have optional argument or none you will

00:38:55,350 --> 00:39:04,980
need to use the VF print F or the F puts

00:39:00,420 --> 00:39:06,630
so this macro are there to manage on

00:39:04,980 --> 00:39:08,880
inside the print function when we're

00:39:06,630 --> 00:39:11,730
going to do the do log we are going to

00:39:08,880 --> 00:39:14,250
pass all logger the level the format's

00:39:11,730 --> 00:39:16,530
which is the first string and the number

00:39:14,250 --> 00:39:18,090
of arguments we have behind and then the

00:39:16,530 --> 00:39:21,120
the list of arguments we've just

00:39:18,090 --> 00:39:28,130
processed so we could then print printed

00:39:21,120 --> 00:39:31,140
there then we have that line complete

00:39:28,130 --> 00:39:33,560
you can go further and there is a very

00:39:31,140 --> 00:39:36,900
very nice article about how to start

00:39:33,560 --> 00:39:41,160
excess code from David Ferrer online and

00:39:36,900 --> 00:39:42,990
pretty recent article I would suggest

00:39:41,160 --> 00:39:46,020
also to check the type map you have a

00:39:42,990 --> 00:39:49,560
lot of type map option and from me one

00:39:46,020 --> 00:39:53,460
very good way to keep learning XS is use

00:39:49,560 --> 00:39:56,520
grep Metis upon to see how other XS

00:39:53,460 --> 00:39:59,370
module are using some specific XS

00:39:56,520 --> 00:40:00,810
function in that context and try to find

00:39:59,370 --> 00:40:04,590
what the pattern was the current pattern

00:40:00,810 --> 00:40:06,390
and then from there I could you could

00:40:04,590 --> 00:40:07,580
could find a way to to serve your

00:40:06,390 --> 00:40:11,070
problem

00:40:07,580 --> 00:40:13,200
so this torque is over you could find

00:40:11,070 --> 00:40:22,440
the slides online and I don't know if

00:40:13,200 --> 00:40:26,250
you have any question but oh by the way

00:40:22,440 --> 00:40:28,260
the XS Ruger module the source code is

00:40:26,250 --> 00:40:29,700
available on github if you want to play

00:40:28,260 --> 00:40:30,810
with it if you want to steal some

00:40:29,700 --> 00:40:32,640
something from it

00:40:30,810 --> 00:40:36,660
you could find it because it's reference

00:40:32,640 --> 00:40:38,250
on Sipan and it's easy to jump to the

00:40:36,660 --> 00:40:40,170
github repo there are several branches

00:40:38,250 --> 00:40:42,360
where I can see the evolution and you

00:40:40,170 --> 00:40:48,370
could yeah you could also get the source

00:40:42,360 --> 00:40:54,679
code variation not yeah thanks

00:40:48,370 --> 00:40:54,679
[Applause]

00:40:55,200 --> 00:40:57,260

YouTube URL: https://www.youtube.com/watch?v=4rrcICCfxco


