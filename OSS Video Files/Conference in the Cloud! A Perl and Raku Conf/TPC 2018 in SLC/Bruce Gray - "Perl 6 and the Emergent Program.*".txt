Title: Bruce Gray - "Perl 6 and the Emergent Program.*"
Publication date: 2018-06-20
Playlist: TPC 2018 in SLC
Description: 
	Like vegetables snuck in to a meatloaf, Perl 6 makes tasty a few very advanced CompSci tools, via clever syntax that masks the complex and dangles the shiny.
Captions: 
	00:00:01,490 --> 00:00:13,019
okay fast housekeeping and preface and

00:00:06,560 --> 00:00:14,670
please conversations there I try to make

00:00:13,019 --> 00:00:16,230
the slides worth downloading and I

00:00:14,670 --> 00:00:19,230
welcome emails with constructive

00:00:16,230 --> 00:00:20,520
critiques or stop me in the hall there

00:00:19,230 --> 00:00:24,289
are sections I'm going to be going

00:00:20,520 --> 00:00:27,660
through fast because the points not

00:00:24,289 --> 00:00:30,119
pearl six in that slide the point is the

00:00:27,660 --> 00:00:33,149
effect it had and you may really really

00:00:30,119 --> 00:00:37,590
want to know more about that slide so

00:00:33,149 --> 00:00:40,890
really download the slides you can try

00:00:37,590 --> 00:00:43,649
my code for yourself now or later

00:00:40,890 --> 00:00:48,960
there's even two different live coding

00:00:43,649 --> 00:00:51,000
sites my voice tends to weaken and I

00:00:48,960 --> 00:00:53,850
want you to easily hear me even in the

00:00:51,000 --> 00:00:58,739
back so if I lose volume somebody please

00:00:53,850 --> 00:01:00,780
signal me today I'm focusing on small

00:00:58,739 --> 00:01:04,229
pieces of pearl six for reasons it will

00:01:00,780 --> 00:01:07,320
come clear if this talk is your only

00:01:04,229 --> 00:01:09,930
exposure to pearl six at the very end

00:01:07,320 --> 00:01:12,240
there are some recommended videos that

00:01:09,930 --> 00:01:14,490
will give you a much better overview of

00:01:12,240 --> 00:01:21,780
some way cool features that I don't have

00:01:14,490 --> 00:01:24,869
time to go into I have a formal Q&A at a

00:01:21,780 --> 00:01:28,259
2/3 point about nine thirty two just

00:01:24,869 --> 00:01:29,240
before my last section I will take quick

00:01:28,259 --> 00:01:34,920
questions throughout

00:01:29,240 --> 00:01:39,299
but like single sentence questions I am

00:01:34,920 --> 00:01:42,720
Bruce gray butyl online I've worked over

00:01:39,299 --> 00:01:45,180
a decade in an on pearl six

00:01:42,720 --> 00:01:48,570
I wrote a Perl 5 to Perl 6 translator

00:01:45,180 --> 00:01:51,030
write lots of code for Perl 6 on rosetta

00:01:48,570 --> 00:01:56,399
code they're a great language comparison

00:01:51,030 --> 00:01:59,130
site and I've given talks on Perl 6 on C

00:01:56,399 --> 00:02:01,770
what is improved why things have changed

00:01:59,130 --> 00:02:04,320
what things have changed what has not

00:02:01,770 --> 00:02:07,020
changed how Perl 6 changed me and

00:02:04,320 --> 00:02:09,390
several other people have covered the

00:02:07,020 --> 00:02:11,819
vast array of new features today I'm

00:02:09,390 --> 00:02:12,620
focusing on parts of the design that

00:02:11,819 --> 00:02:17,920
have had

00:02:12,620 --> 00:02:17,920
can order effects or emergent behavior

00:02:20,230 --> 00:02:29,450
so that's the blurb on the website for

00:02:23,480 --> 00:02:34,340
this talk it seems a bit disjoint from

00:02:29,450 --> 00:02:40,370
the actual title the title of this talk

00:02:34,340 --> 00:02:45,019
does not end in a dot it ends in dot

00:02:40,370 --> 00:02:49,390
star which is reg x4 followed by

00:02:45,019 --> 00:02:52,760
anything or nothing could be programmed

00:02:49,390 --> 00:02:54,560
as in the way Perl 6 multi-paradigm

00:02:52,760 --> 00:02:57,530
design encourages exploratory

00:02:54,560 --> 00:03:02,290
programming if you explore your problem

00:02:57,530 --> 00:03:02,290
space and evolve your actual code or

00:03:02,530 --> 00:03:09,440
programmer like how the design helps

00:03:06,200 --> 00:03:12,260
with self-education or programming

00:03:09,440 --> 00:03:13,579
language like how the design has emerged

00:03:12,260 --> 00:03:17,889
from as various principles and

00:03:13,579 --> 00:03:23,209
influences it could be all of the above

00:03:17,889 --> 00:03:25,609
not in 45 minutes so that's the

00:03:23,209 --> 00:03:30,049
preference let's start with random

00:03:25,609 --> 00:03:36,250
numbers excuse me the source of many

00:03:30,049 --> 00:03:36,250
bugs and not a few war stories

00:03:39,610 --> 00:03:48,860
I'm mostly I'm not gonna explain my

00:03:41,960 --> 00:03:51,860
references but that one's xkcd random

00:03:48,860 --> 00:03:53,210
numbers it's hairy stuff really do you

00:03:51,860 --> 00:03:56,600
want selection with replacement

00:03:53,210 --> 00:04:00,890
selection without replacement does your

00:03:56,600 --> 00:04:02,270
language have a Rand keyword that gives

00:04:00,890 --> 00:04:08,570
you a floating point between zero and

00:04:02,270 --> 00:04:11,530
almost 100 or a random function where

00:04:08,570 --> 00:04:14,720
Rand of a thousand would turn return one

00:04:11,530 --> 00:04:17,720
between one and a thousand or is it

00:04:14,720 --> 00:04:24,490
between zero and a thousand or is

00:04:17,720 --> 00:04:27,950
between 0 and 999 is it floating-point

00:04:24,490 --> 00:04:35,600
if so should you truncate it around it

00:04:27,950 --> 00:04:39,520
oh you didn't round it did you now you

00:04:35,600 --> 00:04:39,520
have a bias against your end points

00:04:41,140 --> 00:04:52,120
wasn't it obvious to truncate it no no

00:04:47,200 --> 00:04:54,850
it's not it's a lot to worry about

00:04:52,120 --> 00:04:59,380
getting randomness right

00:04:54,850 --> 00:04:59,380
it's no wonder some people outsource it

00:05:00,670 --> 00:05:08,870
so in your in your language of choice

00:05:05,200 --> 00:05:11,300
how would you generate a random four

00:05:08,870 --> 00:05:11,930
digit number and when I ask you a

00:05:11,300 --> 00:05:13,640
question

00:05:11,930 --> 00:05:15,320
I'm not looking for hands I just want

00:05:13,640 --> 00:05:19,460
you to you know solve it mentally in

00:05:15,320 --> 00:05:23,330
your head so you have something to

00:05:19,460 --> 00:05:24,330
compare to the next material so take 10

00:05:23,330 --> 00:05:27,370
seconds

00:05:24,330 --> 00:05:27,370
[Music]

00:05:34,930 --> 00:05:40,780
so here are two ways to write it wrong

00:05:37,389 --> 00:05:42,910
in Perl five they both give you leading

00:05:40,780 --> 00:05:45,220
zeros by the way the answer the question

00:05:42,910 --> 00:05:47,680
before is you can use rammed by itself

00:05:45,220 --> 00:05:50,080
and it defaults to one or you can use R

00:05:47,680 --> 00:05:53,710
and as a function and it's between zero

00:05:50,080 --> 00:05:58,389
and whatever almost to whatever you said

00:05:53,710 --> 00:06:05,110
as argument that's the correct answer

00:05:58,389 --> 00:06:07,270
that's not too hard to reach but if you

00:06:05,110 --> 00:06:10,270
came across that line of code with no

00:06:07,270 --> 00:06:19,180
comments could you tell what the intent

00:06:10,270 --> 00:06:23,229
was Perl 6 provides a roll method on

00:06:19,180 --> 00:06:28,599
lists and ranges it has random selection

00:06:23,229 --> 00:06:31,000
not random number generation so are you

00:06:28,599 --> 00:06:41,830
more likely to know what that line

00:06:31,000 --> 00:06:45,370
intended if you saw it bare there's a

00:06:41,830 --> 00:06:47,560
little of that in throughout here it's

00:06:45,370 --> 00:06:54,669
like yeah this is better oh but only if

00:06:47,560 --> 00:06:56,229
you already know Perl 6 then role can

00:06:54,669 --> 00:07:00,699
take an argument if you're rolling

00:06:56,229 --> 00:07:05,470
multiple times so if we're rolling up a

00:07:00,699 --> 00:07:09,820
new Dungeons & Dragons character you do

00:07:05,470 --> 00:07:12,280
recognize these attributes right lots of

00:07:09,820 --> 00:07:13,900
nods for YouTube I'll say strength

00:07:12,280 --> 00:07:18,639
intelligence wisdom dexterity

00:07:13,900 --> 00:07:24,130
Constitution charisma the classics so

00:07:18,639 --> 00:07:27,250
you're using six sided dice we will loop

00:07:24,130 --> 00:07:30,630
through the attributes printing the

00:07:27,250 --> 00:07:30,630
stats for each one

00:07:34,449 --> 00:07:45,210
to get the stat randomly select an

00:07:38,830 --> 00:07:50,379
element from the six sides three times

00:07:45,210 --> 00:07:55,210
and add them together but that's

00:07:50,379 --> 00:08:00,279
old-school a kind Dungeon Master would

00:07:55,210 --> 00:08:04,680
take the best three out of five roles so

00:08:00,279 --> 00:08:09,460
you roll five times sort it

00:08:04,680 --> 00:08:17,710
descending numerically take the first

00:08:09,460 --> 00:08:19,330
three elements and add them together now

00:08:17,710 --> 00:08:22,779
I grab that if you don't know Perl 6

00:08:19,330 --> 00:08:28,830
that codes a head-scratcher but if you

00:08:22,779 --> 00:08:28,830
do know Perl 6 it is very clear

00:08:36,100 --> 00:08:42,290
last bit of random you want to pick door

00:08:40,640 --> 00:08:46,070
prizes for your parole mongers meeting

00:08:42,290 --> 00:08:49,400
you're giving away flux dr. who Batman

00:08:46,070 --> 00:08:53,380
Cthulhu and make Cthulhu part of the

00:08:49,400 --> 00:08:57,320
password once is a bad idea

00:08:53,380 --> 00:08:59,420
so in your language of choice select

00:08:57,320 --> 00:09:03,070
three winners from some list of

00:08:59,420 --> 00:09:03,070
attendees go

00:09:12,320 --> 00:09:20,710
I won't show you my code but I'll tell

00:09:16,490 --> 00:09:27,260
you I didn't code to prevent duplicates

00:09:20,710 --> 00:09:30,190
did you code to prevent duplicates larry

00:09:27,260 --> 00:09:32,300
has becae we've been doing up till now

00:09:30,190 --> 00:09:33,920
selection with replacement this is

00:09:32,300 --> 00:09:38,290
selection without replacement it's a

00:09:33,920 --> 00:09:38,290
different world in probability theory

00:09:38,350 --> 00:09:47,030
it's the difference between rolling dice

00:09:40,490 --> 00:09:47,900
and picking cards from a deck it's not

00:09:47,030 --> 00:09:51,760
straightforward

00:09:47,900 --> 00:09:54,230
procedurally to prevent do duplicates

00:09:51,760 --> 00:09:56,750
and it's not too bad you can just roll

00:09:54,230 --> 00:09:58,310
like before and keep re rolling whenever

00:09:56,750 --> 00:10:01,970
you detected duplicate until you've

00:09:58,310 --> 00:10:04,820
selected enough winners that's more code

00:10:01,970 --> 00:10:10,520
than I want for such a simple thing that

00:10:04,820 --> 00:10:14,900
I'm doing and I know there is a

00:10:10,520 --> 00:10:20,240
potential bug there we'll just ignore it

00:10:14,900 --> 00:10:22,730
an easier way would be to act like all

00:10:20,240 --> 00:10:28,000
your attendees are a deck and shuffle

00:10:22,730 --> 00:10:28,000
the deck and deal the first three cards

00:10:32,070 --> 00:10:40,780
that's much better still pro/5 shorter

00:10:36,630 --> 00:10:44,200
but 0.2 to get the first three awkward

00:10:40,780 --> 00:10:47,200
and I had to load a module to import

00:10:44,200 --> 00:10:55,300
shuffle it does come with your Pearl

00:10:47,200 --> 00:10:57,280
though pearl six gives you the pick

00:10:55,300 --> 00:11:02,790
method it's like role but without

00:10:57,280 --> 00:11:04,780
replacement cards instead of dice

00:11:02,790 --> 00:11:07,170
now it's short enough to use in a

00:11:04,780 --> 00:11:07,170
one-liner

00:11:18,180 --> 00:11:25,050
I actually did that at meeting Alice

00:11:21,750 --> 00:11:27,839
wasn't there so what did they do

00:11:25,050 --> 00:11:30,870
oh sorry they for those of you who don't

00:11:27,839 --> 00:11:33,830
already know our the language design

00:11:30,870 --> 00:11:33,830
team

00:11:36,750 --> 00:11:42,089
Larry Wallace says he has multiple

00:11:38,490 --> 00:11:44,850
personalities disorder the design team

00:11:42,089 --> 00:11:47,100
Larry wall and similar deep brains like

00:11:44,850 --> 00:11:52,560
Allison Randall Damien Conway we

00:11:47,100 --> 00:11:54,270
collectively called them at Larry so

00:11:52,560 --> 00:11:57,570
what do they do they took a look at the

00:11:54,270 --> 00:12:00,779
math and computer science field took the

00:11:57,570 --> 00:12:03,000
feedback of many years and users and

00:12:00,779 --> 00:12:06,180
teachers and trainers and looked at the

00:12:03,000 --> 00:12:09,020
most common use cases through a filter

00:12:06,180 --> 00:12:13,020
of pain points and common mistakes

00:12:09,020 --> 00:12:15,300
sources of bugs they tore off a chunk of

00:12:13,020 --> 00:12:23,690
the computer science and packaged it

00:12:15,300 --> 00:12:23,690
neatly for us pick and roll

00:12:25,210 --> 00:12:35,410
so that's Oh are you actually confirming

00:12:33,730 --> 00:12:36,280
that you did intend it when you pick

00:12:35,410 --> 00:12:40,210
those two names

00:12:36,280 --> 00:12:43,330
oh sure once you saw it but it's not

00:12:40,210 --> 00:12:45,550
like you designed for the pun that that

00:12:43,330 --> 00:12:50,920
would be a bridge too far it's a retro

00:12:45,550 --> 00:12:53,170
pun okay Larry that that does forget so

00:12:50,920 --> 00:12:55,450
as the start of the story here the

00:12:53,170 --> 00:12:56,830
intended effect is less coding work you

00:12:55,450 --> 00:12:59,320
know something that's common now we've

00:12:56,830 --> 00:13:02,830
got a quick short way to do it but the

00:12:59,320 --> 00:13:06,070
secondary effects reduced real-world

00:13:02,830 --> 00:13:07,990
errors slightly improved code quality

00:13:06,070 --> 00:13:11,320
because we're lower lowering the

00:13:07,990 --> 00:13:13,090
cognitive load on the programmer and you

00:13:11,320 --> 00:13:16,680
have a reduced need for math and

00:13:13,090 --> 00:13:19,270
computer science training a little bit

00:13:16,680 --> 00:13:22,780
so average programmer can write better

00:13:19,270 --> 00:13:29,950
code faster a little bit but that's just

00:13:22,780 --> 00:13:34,500
a little piece of the language yeah we

00:13:29,950 --> 00:13:42,130
better speed up go with something easier

00:13:34,500 --> 00:13:43,480
regular expressions really easy I think

00:13:42,130 --> 00:13:49,300
all professional programmers should

00:13:43,480 --> 00:13:51,670
learn reg X's eventually if only so you

00:13:49,300 --> 00:13:53,860
can say things like find the link to

00:13:51,670 --> 00:13:57,960
that site that started with a F and

00:13:53,860 --> 00:13:57,960
ended in dot org that I put in my notes

00:14:00,510 --> 00:14:07,000
many Perl coders first use reg X's when

00:14:04,360 --> 00:14:10,080
they need to trim whitespace I want to

00:14:07,000 --> 00:14:10,080
look up it all a little more

00:14:14,860 --> 00:14:18,190
that's a fact

00:14:26,690 --> 00:14:30,350
that is the right answer

00:14:30,650 --> 00:14:40,320
but it is not the first step on a path

00:14:34,830 --> 00:14:44,960
to regex knowledge it's too big a leap

00:14:40,320 --> 00:14:44,960
to be a first step on any path that

00:14:45,860 --> 00:14:51,480
leads to a lot of cargo coltan in this

00:14:48,840 --> 00:14:54,420
area people who don't understand what

00:14:51,480 --> 00:15:01,440
they just wrote or more likely just copy

00:14:54,420 --> 00:15:02,580
and paste it it was two statements why

00:15:01,440 --> 00:15:11,100
not one statement this looks like a

00:15:02,580 --> 00:15:15,390
reasonable alternative right Larry

00:15:11,100 --> 00:15:18,150
thinks it's not reasonable I gave this

00:15:15,390 --> 00:15:26,670
talk a week ago people in crowd found

00:15:18,150 --> 00:15:28,530
two bugs but it's so simple you start at

00:15:26,670 --> 00:15:30,690
the beginning you skip the whitespace

00:15:28,530 --> 00:15:32,970
you capture everything you skip the

00:15:30,690 --> 00:15:34,050
whitespace you end at the end and then

00:15:32,970 --> 00:15:38,580
you replace the whole thing with what

00:15:34,050 --> 00:15:48,990
was captured there are four different

00:15:38,580 --> 00:15:54,510
bugs in that statement yeah yep embedded

00:15:48,990 --> 00:15:55,710
new line and they're the the really

00:15:54,510 --> 00:16:00,570
subtle one is if you have multiple

00:15:55,710 --> 00:16:04,710
spaces at the end you won't trigger on

00:16:00,570 --> 00:16:07,110
single single space and having a space

00:16:04,710 --> 00:16:09,360
at one end but not the other will make

00:16:07,110 --> 00:16:15,950
it not trigger so those are the four

00:16:09,360 --> 00:16:15,950
errors yes yeah

00:16:16,000 --> 00:16:22,580
yes because you know if you have ABC new

00:16:19,880 --> 00:16:25,270
line one two three because it came in

00:16:22,580 --> 00:16:28,430
from a web form now if that does happen

00:16:25,270 --> 00:16:31,550
then it won't do what you intended it

00:16:28,430 --> 00:16:33,350
won't recognize the embedded in with the

00:16:31,550 --> 00:16:34,810
dot and it'll just won't rip any white

00:16:33,350 --> 00:16:39,190
space at all

00:16:34,810 --> 00:16:45,710
so regex is a very sharp scalpel and

00:16:39,190 --> 00:16:50,240
many many coders cut themselves that

00:16:45,710 --> 00:16:51,920
looks reasonable too well let me say it

00:16:50,240 --> 00:16:54,850
the way I would say you know best

00:16:51,920 --> 00:17:01,060
practices /x separate regex

00:16:54,850 --> 00:17:04,760
that looks reasonable nope

00:17:01,060 --> 00:17:08,630
needed that slash s because of that

00:17:04,760 --> 00:17:14,540
embedded newline case there's almost

00:17:08,630 --> 00:17:18,650
best practices Perl 6 adds three methods

00:17:14,540 --> 00:17:23,300
on strings dot trim leading dot trim

00:17:18,650 --> 00:17:28,870
trailing dot trim which does both it's

00:17:23,300 --> 00:17:30,950
simple it's readable it's bulletproof

00:17:28,870 --> 00:17:37,160
and you don't have to care how the

00:17:30,950 --> 00:17:38,960
language does it behind the scenes the

00:17:37,160 --> 00:17:45,650
other place coders encounter regex

00:17:38,960 --> 00:17:48,890
too early is substring search that is

00:17:45,650 --> 00:17:51,140
hard to read and the coder has to

00:17:48,890 --> 00:17:54,800
remember all the rules for special

00:17:51,140 --> 00:17:59,929
characters if they forget to back whack

00:17:54,800 --> 00:18:01,820
the dot in mp3 then that dot just means

00:17:59,929 --> 00:18:04,210
any character which is not what you

00:18:01,820 --> 00:18:04,210
meant

00:18:07,170 --> 00:18:14,500
Perl 6 adds methods starts with ends

00:18:11,530 --> 00:18:19,900
width and contains and they take plane

00:18:14,500 --> 00:18:22,450
fixed strings like f grep the old dredge

00:18:19,900 --> 00:18:29,950
X is still work but the new methods are

00:18:22,450 --> 00:18:32,740
so much cleaner so the primary effect

00:18:29,950 --> 00:18:34,960
it's easier to use and read the

00:18:32,740 --> 00:18:38,020
secondary effect you don't have to learn

00:18:34,960 --> 00:18:39,730
reg X's too early in your path as a

00:18:38,020 --> 00:18:44,980
programmer and that's important

00:18:39,730 --> 00:18:48,490
oh wait I have a note from David Adler

00:18:44,980 --> 00:18:51,370
DHA has reviewed all my references in

00:18:48,490 --> 00:18:59,770
humor he affirmed that it was all funny

00:18:51,370 --> 00:19:02,170
although he did not laugh ok well if you

00:18:59,770 --> 00:19:03,310
are using reg X's they are so much

00:19:02,170 --> 00:19:06,010
better if Perl 6

00:19:03,310 --> 00:19:10,120
we've improved them so much they extend

00:19:06,010 --> 00:19:13,510
up into full parsing understandable

00:19:10,120 --> 00:19:21,400
parsing they call this unification of

00:19:13,510 --> 00:19:24,790
regex and parsers grammars now p5 best

00:19:21,400 --> 00:19:26,500
practice named captures look for it in

00:19:24,790 --> 00:19:28,990
the doc if you're not familiar with it

00:19:26,500 --> 00:19:33,010
you should all be using it for anything

00:19:28,990 --> 00:19:39,430
longer than that much they're great but

00:19:33,010 --> 00:19:45,010
they don't scale and I so date year

00:19:39,430 --> 00:19:47,040
month date with dashes in between if you

00:19:45,010 --> 00:19:49,630
write it like that you've got a reusable

00:19:47,040 --> 00:19:52,620
regular expression you can drop dollar

00:19:49,630 --> 00:19:55,720
iso date in another regular expression

00:19:52,620 --> 00:20:00,790
but if that regular expression needs to

00:19:55,720 --> 00:20:03,310
iso dates then all the captured

00:20:00,790 --> 00:20:04,360
variables clobber you know I can't

00:20:03,310 --> 00:20:05,140
remember if you get the first one you

00:20:04,360 --> 00:20:06,580
get the second one but you definitely

00:20:05,140 --> 00:20:09,000
don't get both of them and you wanted

00:20:06,580 --> 00:20:09,000
both of them

00:20:12,120 --> 00:20:19,150
so let's take as an example a reading

00:20:15,280 --> 00:20:21,730
log start date end date and the title of

00:20:19,150 --> 00:20:28,630
the book that you were reading with the

00:20:21,730 --> 00:20:31,180
white space separating like that so we

00:20:28,630 --> 00:20:35,050
need a grammar to reflect that and if

00:20:31,180 --> 00:20:38,170
it's good then we can just do this I

00:20:35,050 --> 00:20:42,310
haven't shown the grammar yet but we've

00:20:38,170 --> 00:20:45,850
got a line of text from the log you tell

00:20:42,310 --> 00:20:50,410
the grammar to parse the line and if it

00:20:45,850 --> 00:20:56,500
succeeds then in dollar / you can get to

00:20:50,410 --> 00:20:59,080
the pieces that were captured it

00:20:56,500 --> 00:21:02,650
contains the dollar / contains all the

00:20:59,080 --> 00:21:06,070
matches and sub matches that's the

00:21:02,650 --> 00:21:10,210
grammar to do it better than the regex

00:21:06,070 --> 00:21:11,710
that was in your head I'm glossing over

00:21:10,210 --> 00:21:14,710
the lots of syntax you don't know yet

00:21:11,710 --> 00:21:18,540
like the code blocks to say this can pet

00:21:14,710 --> 00:21:21,520
this can has to pass or fail for the

00:21:18,540 --> 00:21:23,530
month the month has to not just be two

00:21:21,520 --> 00:21:26,740
digits it has to be two digits that are

00:21:23,530 --> 00:21:29,620
between 1 and 12 but even if you don't

00:21:26,740 --> 00:21:38,470
understand the syntax you can admire the

00:21:29,620 --> 00:21:41,380
very clean definition Jeff Goff will be

00:21:38,470 --> 00:21:44,110
going into depth about Perl 6 reg X's

00:21:41,380 --> 00:21:49,450
and grammars his talk is next - next in

00:21:44,110 --> 00:21:52,360
this room at 11:10 but I need to show

00:21:49,450 --> 00:21:55,570
you the capture object so we have in

00:21:52,360 --> 00:22:00,580
Perl 6 grammar tracer and grammar

00:21:55,570 --> 00:22:04,330
debugger the tracer shows me the whole

00:22:00,580 --> 00:22:06,550
tree of capture objects which work the

00:22:04,330 --> 00:22:09,670
way you treat them it's almost magical

00:22:06,550 --> 00:22:13,930
if you treat if I treat the start date

00:22:09,670 --> 00:22:16,870
as a string it gives me 2010 - OH - - 28

00:22:13,930 --> 00:22:20,580
if I treat it as a hash I can drill down

00:22:16,870 --> 00:22:20,580
to get just the day part

00:22:26,250 --> 00:22:34,410
ah windy as a shameless plug for a book

00:22:32,280 --> 00:22:40,470
specifically on parsing with Perl 6 reg

00:22:34,410 --> 00:22:42,330
X's and grammars by Moore it's so

00:22:40,470 --> 00:22:43,830
grammars they have object structure that

00:22:42,330 --> 00:22:47,910
can they can even automatically build

00:22:43,830 --> 00:22:51,660
parse trees for you the state of the art

00:22:47,910 --> 00:22:54,590
has truly been advanced here so much so

00:22:51,660 --> 00:22:57,810
that Perl 6 is mostly written in Perl 6

00:22:54,590 --> 00:23:00,390
that's not as a stunt it's not an

00:22:57,810 --> 00:23:05,430
alternate implementation like pythons

00:23:00,390 --> 00:23:08,190
brilliant pie pie I'm talking about the

00:23:05,430 --> 00:23:11,790
making implementation of Perl 6 is

00:23:08,190 --> 00:23:16,320
written in itself it makes it easy to

00:23:11,790 --> 00:23:19,890
get and keep volunteers in Perl 5 you

00:23:16,320 --> 00:23:23,070
want to hack on Perl you go down into C

00:23:19,890 --> 00:23:32,220
in Perl 6 you want to hack on Perl 6 you

00:23:23,070 --> 00:23:35,070
go down into Perl sinks but parsing for

00:23:32,220 --> 00:23:41,790
me personally is serious deep computer

00:23:35,070 --> 00:23:50,490
science like all that to me those aren't

00:23:41,790 --> 00:23:52,710
buzzwords those are trigger words when

00:23:50,490 --> 00:23:56,400
your input matches your parser you get a

00:23:52,710 --> 00:23:59,310
nice parse tree of your input if it

00:23:56,400 --> 00:24:02,430
fails to match parsers don't give you

00:23:59,310 --> 00:24:05,820
good partial info so that pup your

00:24:02,430 --> 00:24:11,250
compilers cannot offer good error

00:24:05,820 --> 00:24:14,550
messages so Perl 5 simple math that

00:24:11,250 --> 00:24:19,470
works fine oh this time I left out the

00:24:14,550 --> 00:24:24,960
asterisk what do I get a simple generic

00:24:19,470 --> 00:24:29,190
syntax error at least it points you to

00:24:24,960 --> 00:24:31,440
the point of failure but it's less than

00:24:29,190 --> 00:24:35,340
what hope for when you're seeking help

00:24:31,440 --> 00:24:36,960
you were making mistakes and that's too

00:24:35,340 --> 00:24:39,539
simple for Perl 6

00:24:36,960 --> 00:24:42,250
let's do palindromes

00:24:39,539 --> 00:24:43,270
in the first hundred numbers how many of

00:24:42,250 --> 00:24:44,549
them are the same if you wrote them

00:24:43,270 --> 00:24:54,640
backwards

00:24:44,549 --> 00:24:57,090
that's a one-liner in Perl 6 now the

00:24:54,640 --> 00:25:04,559
parens around the carrot 100 are

00:24:57,090 --> 00:25:04,559
required what if I forgot them

00:25:14,200 --> 00:25:23,870
that is the kind of help I want when I

00:25:17,390 --> 00:25:27,620
screw up also that the green in red on

00:25:23,870 --> 00:25:30,830
the last line there I didn't colorize

00:25:27,620 --> 00:25:36,590
that or add the little pointer pearl six

00:25:30,830 --> 00:25:38,300
color eise's its errors the dev team has

00:25:36,590 --> 00:25:45,440
a ticket category for error messages

00:25:38,300 --> 00:25:47,260
that need work LT a less than awesome if

00:25:45,440 --> 00:25:50,930
an error message is less than awesome

00:25:47,260 --> 00:25:52,640
someone needs to make it awesome they

00:25:50,930 --> 00:25:57,710
take it seriously and that benefits

00:25:52,640 --> 00:26:00,650
every user and it's pearl pearls new

00:25:57,710 --> 00:26:12,050
parser that gives us enough information

00:26:00,650 --> 00:26:13,460
to do that floating point slower the

00:26:12,050 --> 00:26:17,120
question was has the speed compared to

00:26:13,460 --> 00:26:20,750
pearl five where the the parser is coded

00:26:17,120 --> 00:26:24,380
hard coded in C and is rather inflexible

00:26:20,750 --> 00:26:26,930
pearl sixes syntax Pro sixes parser is

00:26:24,380 --> 00:26:31,610
slower at least right now we've got good

00:26:26,930 --> 00:26:35,320
people working on it but it enables a

00:26:31,610 --> 00:26:37,970
lot you can modify the syntax you can

00:26:35,320 --> 00:26:41,420
there are hooks there where if you want

00:26:37,970 --> 00:26:44,570
you can make a sub syntax lexically

00:26:41,420 --> 00:26:48,830
scoped in your program to say you know

00:26:44,570 --> 00:26:52,190
use Perl 6 with SQL and within that

00:26:48,830 --> 00:26:54,950
block you've got SQL and not as

00:26:52,190 --> 00:26:56,660
something that gets handed off to the

00:26:54,950 --> 00:27:00,110
engine like in DB I but something that

00:26:56,660 --> 00:27:02,180
the compiler understands I can write

00:27:00,110 --> 00:27:05,210
that haven't but I could write that as a

00:27:02,180 --> 00:27:09,560
module and he would actually modify the

00:27:05,210 --> 00:27:13,190
Perl 6 syntax at runtime but only an

00:27:09,560 --> 00:27:14,690
eleska scope but that's as much as I

00:27:13,190 --> 00:27:17,140
could say about that right now on to

00:27:14,690 --> 00:27:17,140
floating point

00:27:20,040 --> 00:27:31,810
I've kept my equipment out of my spill

00:27:22,660 --> 00:27:35,080
zone so there was a famous paper written

00:27:31,810 --> 00:27:37,570
long ago of the very few simple things

00:27:35,080 --> 00:27:48,610
you needed to know to get floating point

00:27:37,570 --> 00:27:51,250
right 44 pages it's not so simple on

00:27:48,610 --> 00:27:56,520
stackoverflow about floating-point

00:27:51,250 --> 00:28:01,300
issues they have so many questions so

00:27:56,520 --> 00:28:08,910
tell me in math that's a true statement

00:28:01,300 --> 00:28:14,260
right so what should that print in Ruby

00:28:08,910 --> 00:28:19,420
as I said what should it print given

00:28:14,260 --> 00:28:20,920
that syntax and that that's the not

00:28:19,420 --> 00:28:24,160
trying area what's a called operator

00:28:20,920 --> 00:28:26,710
ternary operator so if if what's on the

00:28:24,160 --> 00:28:28,060
left of the question is true then what's

00:28:26,710 --> 00:28:29,830
on the right of the question prints

00:28:28,060 --> 00:28:32,830
otherwise what's on the right of the

00:28:29,830 --> 00:28:35,920
colon prints so yes it should print yes

00:28:32,830 --> 00:28:38,230
and it says no we've been bitten by a

00:28:35,920 --> 00:28:41,230
floating-point bug that this part is

00:28:38,230 --> 00:28:42,610
from a talk by Curtis pod a Perl monk

00:28:41,230 --> 00:28:46,360
notice Ovid

00:28:42,610 --> 00:28:50,800
beloved to us all the Perl 5 has the

00:28:46,360 --> 00:28:56,950
same problem so does Python and Perl 6

00:28:50,800 --> 00:29:01,480
doesn't how I last time I gave this talk

00:28:56,950 --> 00:29:06,330
somebody from the audience said binary

00:29:01,480 --> 00:29:06,330
coded decimal which is a good answer

00:29:06,520 --> 00:29:13,330
but that's not pro 6 does it by storing

00:29:10,810 --> 00:29:16,180
0.3 as a float not as a floating-point

00:29:13,330 --> 00:29:20,260
number but as two integers top and

00:29:16,180 --> 00:29:22,570
bottom of a fraction in Haskell that

00:29:20,260 --> 00:29:26,590
would call that a rational type we call

00:29:22,570 --> 00:29:29,279
it we call them rats and if you have

00:29:26,590 --> 00:29:31,899
oversized ones you can have big rats

00:29:29,279 --> 00:29:37,840
so pearl six does integer integer

00:29:31,899 --> 00:29:38,889
arithmetic you know the fast kind on top

00:29:37,840 --> 00:29:40,570
and bottom of their ATS

00:29:38,889 --> 00:29:43,029
and all it converts them to floating

00:29:40,570 --> 00:29:47,830
points if the size of the top or bottom

00:29:43,029 --> 00:29:50,679
would cause performance problems and yes

00:29:47,830 --> 00:29:58,950
you read that method right that is the

00:29:50,679 --> 00:29:58,950
nude method as in numerator denominator

00:30:00,330 --> 00:30:06,999
ovid gives hour-long talks on the ways

00:30:03,580 --> 00:30:08,889
this feature reduces errors and

00:30:06,999 --> 00:30:11,080
simplifies business programming there's

00:30:08,889 --> 00:30:25,360
no more round off problems and no more

00:30:11,080 --> 00:30:29,440
equality failures well the question is

00:30:25,360 --> 00:30:32,169
has the speed compare certainly the

00:30:29,440 --> 00:30:35,919
speed is faster with built-in

00:30:32,169 --> 00:30:38,639
floating-point but then again the

00:30:35,919 --> 00:30:38,639
answers are wrong

00:30:42,260 --> 00:30:54,450
yes you can force floating-point and and

00:30:45,990 --> 00:30:57,090
yes it is slower but it's yes but for

00:30:54,450 --> 00:31:00,540
those you don't always need all the

00:30:57,090 --> 00:31:02,880
speed Larry said yeah and you don't

00:31:00,540 --> 00:31:05,400
always know and where do you want all

00:31:02,880 --> 00:31:11,730
the people who aren't steeped in the

00:31:05,400 --> 00:31:11,940
math to default to right so what do they

00:31:11,730 --> 00:31:14,670
do

00:31:11,940 --> 00:31:17,760
I mean you got a good point it is slower

00:31:14,670 --> 00:31:22,650
and if you care then you need to make it

00:31:17,760 --> 00:31:25,020
be in floating-point but this is okay

00:31:22,650 --> 00:31:27,120
look what do they do they took they dug

00:31:25,020 --> 00:31:30,000
around and got an idea that actually was

00:31:27,120 --> 00:31:32,520
considered and rejected by Python they

00:31:30,000 --> 00:31:34,680
found a real-world pivot point between

00:31:32,520 --> 00:31:38,400
behaving perfectly and performing well

00:31:34,680 --> 00:31:42,320
and they packaged it in a way and this

00:31:38,400 --> 00:31:45,270
is key it's invisible to casual coders

00:31:42,320 --> 00:31:47,280
floating point errors vanish we again

00:31:45,270 --> 00:31:49,110
need less need for math computer science

00:31:47,280 --> 00:31:50,880
training which doesn't mean you have

00:31:49,110 --> 00:31:52,350
less educated coders it means you get

00:31:50,880 --> 00:31:55,560
better code out of the coders you've got

00:31:52,350 --> 00:31:57,990
let me let me emphasize if you say zero

00:31:55,560 --> 00:32:00,870
point three anywhere in your program in

00:31:57,990 --> 00:32:03,090
Perl 6 it does not make that a floating

00:32:00,870 --> 00:32:05,670
point number it makes that three over

00:32:03,090 --> 00:32:08,160
ten internally and if I had not told you

00:32:05,670 --> 00:32:11,750
that explicitly you could work for a

00:32:08,160 --> 00:32:19,890
year in the language and never know it

00:32:11,750 --> 00:32:25,460
your program just works correctly no

00:32:19,890 --> 00:32:25,460
well no no

00:32:26,210 --> 00:32:32,519
right it stores it in fact if you ask

00:32:30,539 --> 00:32:39,389
that variable what type are you

00:32:32,519 --> 00:32:41,960
it says it's a wrapped okay got it

00:32:39,389 --> 00:32:44,159
I actually do have to speed up here

00:32:41,960 --> 00:32:46,139
parallel processing I did not ride

00:32:44,159 --> 00:32:51,269
examples of multi-threaded code because

00:32:46,139 --> 00:32:54,980
I I lost my masochism bills it's not

00:32:51,269 --> 00:32:57,840
actually that hard to write

00:32:54,980 --> 00:33:02,009
multi-threaded code if you don't mind

00:32:57,840 --> 00:33:06,919
getting the wrong answer or and if you

00:33:02,009 --> 00:33:06,919
don't mind debugging monstrosities I

00:33:09,710 --> 00:33:22,289
think this captures the general feel of

00:33:13,950 --> 00:33:25,529
debugging threads but it's terribly hard

00:33:22,289 --> 00:33:26,519
to write it to be fast and correct so

00:33:25,529 --> 00:33:29,609
very quickly

00:33:26,519 --> 00:33:30,779
imagine that those two rows instead of

00:33:29,609 --> 00:33:33,929
three elements each they had a million

00:33:30,779 --> 00:33:36,450
elements each how can I write row add to

00:33:33,929 --> 00:33:38,789
return a million element result where

00:33:36,450 --> 00:33:43,109
the first one is by plus three the

00:33:38,789 --> 00:33:47,399
second one is 220 plus 2 so on so we're

00:33:43,109 --> 00:33:49,350
going to start sequentially inside the

00:33:47,399 --> 00:33:51,659
arrays will be called a and B we check

00:33:49,350 --> 00:33:54,299
they're the same size clear result array

00:33:51,659 --> 00:33:58,200
walk through the index is I for each I

00:33:54,299 --> 00:33:59,879
get that the I fell iment of a and B and

00:33:58,200 --> 00:34:01,889
add them together push it on to the

00:33:59,879 --> 00:34:07,950
results at the end and return it that

00:34:01,889 --> 00:34:10,440
serial code now when you're generating a

00:34:07,950 --> 00:34:14,339
list from a list that's usually a map so

00:34:10,440 --> 00:34:16,799
this is a shorter clearer version and I

00:34:14,339 --> 00:34:20,159
don't even need a separate result array

00:34:16,799 --> 00:34:25,619
I just returned directly that's still

00:34:20,159 --> 00:34:28,829
serial a range of 0 to the end of an

00:34:25,619 --> 00:34:32,220
array is you can get it with the dot

00:34:28,829 --> 00:34:34,710
keys method so I've changed this to O

00:34:32,220 --> 00:34:36,510
method call form that's still serial by

00:34:34,710 --> 00:34:37,470
the way that works in Perl 5 - you can

00:34:36,510 --> 00:34:39,149
say keys

00:34:37,470 --> 00:34:45,599
an array and it will give you zero

00:34:39,149 --> 00:34:52,079
through the end element perl' six has a

00:34:45,599 --> 00:34:55,889
zip in fix meta operator you write Z and

00:34:52,079 --> 00:34:59,900
an operator like + and it will zip the

00:34:55,889 --> 00:35:04,740
arrays together adding them as it goes

00:34:59,900 --> 00:35:12,390
so short so clear don't you know pearl

00:35:04,740 --> 00:35:17,339
six still serial pearl six has high /

00:35:12,390 --> 00:35:20,369
meta operators this is hyper + and it is

00:35:17,339 --> 00:35:23,339
in parallel that's the version using the

00:35:20,369 --> 00:35:24,300
Unicode quotes you can use angle

00:35:23,339 --> 00:35:26,940
brackets instead if you don't like

00:35:24,300 --> 00:35:30,200
unicode we do have ascii equivalents for

00:35:26,940 --> 00:35:32,430
all the cool new unicode operators I

00:35:30,200 --> 00:35:35,930
removed the size check because they

00:35:32,430 --> 00:35:39,240
don't need it we say that it quotes the

00:35:35,930 --> 00:35:41,609
direction of no we say the hyper is like

00:35:39,240 --> 00:35:46,530
a magic wand and it matters which way

00:35:41,609 --> 00:35:49,589
you pointed so when I point when they're

00:35:46,530 --> 00:35:51,240
pointing in I'm guaranteeing the

00:35:49,589 --> 00:35:53,010
compiler I don't need any magic on

00:35:51,240 --> 00:35:55,260
either side those are both the same

00:35:53,010 --> 00:35:57,540
sizes if I pointed them in either

00:35:55,260 --> 00:36:02,150
direction the compiler would watch for a

00:35:57,540 --> 00:36:02,150
size difference and adjust it at runtime

00:36:04,020 --> 00:36:17,770
and that's very useful if if you're

00:36:11,920 --> 00:36:20,230
scaling so that example if n is 3 then

00:36:17,770 --> 00:36:22,810
it'll be everything in 8 times 3 in

00:36:20,230 --> 00:36:26,760
parallel the most interesting thing

00:36:22,810 --> 00:36:31,770
about this is that hyper does not

00:36:26,760 --> 00:36:31,770
instruct the compiler to multi thread

00:36:32,430 --> 00:36:42,360
they tell the compiler and they tell the

00:36:36,100 --> 00:36:42,360
reader that it is safe to multi thread

00:36:42,540 --> 00:36:49,710
that there are no side effects there are

00:36:46,060 --> 00:36:52,420
no dependencies on order of operation

00:36:49,710 --> 00:36:53,740
when you need to thread and it's

00:36:52,420 --> 00:36:56,080
something bigger than operator we do

00:36:53,740 --> 00:36:58,060
have threading methods that integrate

00:36:56,080 --> 00:36:59,980
very well with the rest of the base

00:36:58,060 --> 00:37:01,330
design that with the rest of the

00:36:59,980 --> 00:37:04,510
language and it's part of the base

00:37:01,330 --> 00:37:06,820
design will colita will go into depth

00:37:04,510 --> 00:37:10,330
about perl 6 concurrency his talk is

00:37:06,820 --> 00:37:12,370
next in this room so what do they do

00:37:10,330 --> 00:37:16,360
they took the scariest part of modern

00:37:12,370 --> 00:37:17,860
coding to me and extracted it and

00:37:16,360 --> 00:37:26,730
repackage it into a feature that any

00:37:17,860 --> 00:37:26,730
coder can use with the ease questions

00:37:32,500 --> 00:37:38,850
I have learned to give everybody a

00:37:34,420 --> 00:37:38,850
minute to get their question together

00:37:46,220 --> 00:37:48,940
yes sir

00:37:52,790 --> 00:37:58,980
what is the extent of the magic that the

00:37:55,080 --> 00:38:01,410
hyper meta operators will perform well

00:37:58,980 --> 00:38:02,880
since you asked actually there's a

00:38:01,410 --> 00:38:06,950
different there is another difference

00:38:02,880 --> 00:38:10,140
between zipping and and and using hyper

00:38:06,950 --> 00:38:13,280
zipping is little is strictly one level

00:38:10,140 --> 00:38:15,810
hyper hyper will descend down into

00:38:13,280 --> 00:38:17,790
children and sub children if you've got

00:38:15,810 --> 00:38:20,100
that kind of structure and do

00:38:17,790 --> 00:38:25,200
multiplication or whatever all the way

00:38:20,100 --> 00:38:27,300
down so if you've got 3d matrix then

00:38:25,200 --> 00:38:37,800
yeah it it does the whole thing

00:38:27,300 --> 00:38:39,570
potentially in parallel yes that that

00:38:37,800 --> 00:38:41,940
that question came up at the last time I

00:38:39,570 --> 00:38:44,600
gave the talk what happens if the if the

00:38:41,940 --> 00:38:47,580
two don't match

00:38:44,600 --> 00:38:55,980
it doesn't actually extend it acts like

00:38:47,580 --> 00:38:57,450
it extended the list is pearl six

00:38:55,980 --> 00:38:59,850
backwards compatible with pearl five

00:38:57,450 --> 00:39:04,700
also a question that I got no

00:38:59,850 --> 00:39:07,950
deliberately so but you know we've got

00:39:04,700 --> 00:39:11,670
we've got SAVs for that wound it's part

00:39:07,950 --> 00:39:14,280
of the point you know pearl up through

00:39:11,670 --> 00:39:18,210
five has done more than any language

00:39:14,280 --> 00:39:20,190
I've ever seen to provide backwards

00:39:18,210 --> 00:39:21,900
compatibility very strongly and it's

00:39:20,190 --> 00:39:25,410
just crazy the extent that they go to

00:39:21,900 --> 00:39:27,300
and and that's valuable but that got in

00:39:25,410 --> 00:39:30,150
the way of the evolution of the language

00:39:27,300 --> 00:39:34,830
so the the rationale was we're gonna

00:39:30,150 --> 00:39:37,590
have one break we're gonna one time make

00:39:34,830 --> 00:39:39,150
a jump that we're not going to pay

00:39:37,590 --> 00:39:40,560
attention to backwards compatibility we

00:39:39,150 --> 00:39:42,510
won't change something just for the sake

00:39:40,560 --> 00:39:44,490
of changing it we want pearl to stay

00:39:42,510 --> 00:39:48,450
pearl and still feel pearl we're not

00:39:44,490 --> 00:39:49,740
going to get rid of sigils but we have

00:39:48,450 --> 00:39:53,190
this one break and we use that

00:39:49,740 --> 00:39:55,980
opportunity to design something that you

00:39:53,190 --> 00:39:59,110
never have to have that break again you

00:39:55,980 --> 00:40:01,540
look at all the ways that having

00:39:59,110 --> 00:40:05,110
rigid backwards-compatibility in the old

00:40:01,540 --> 00:40:07,950
design prevented progress and you design

00:40:05,110 --> 00:40:11,140
around that so it won't prevent progress

00:40:07,950 --> 00:40:14,020
pearl six is designed to be the last

00:40:11,140 --> 00:40:17,110
pearl so there will never be a need for

00:40:14,020 --> 00:40:24,330
pearl seven because it as we said about

00:40:17,110 --> 00:40:28,360
the parser it is so very evolvable and

00:40:24,330 --> 00:40:32,680
as I said I brought a translator five to

00:40:28,360 --> 00:40:36,190
six Liz gave a course in how to run Perl

00:40:32,680 --> 00:40:40,690
five modules in Perl 6 but you can't

00:40:36,190 --> 00:40:43,270
just plop a bunch of Perl 5 code into a

00:40:40,690 --> 00:40:45,130
Perl 6 program right now that might come

00:40:43,270 --> 00:40:47,280
but I don't know if anybody's working on

00:40:45,130 --> 00:40:52,210
it right now

00:40:47,280 --> 00:40:56,100
pardon yes in line Perl 5 but I think

00:40:52,210 --> 00:40:56,100
that that's limited to modules right now

00:40:57,420 --> 00:41:06,210
Liz says yes yes sir

00:41:10,650 --> 00:41:16,270
is there a way to preserve the rational

00:41:13,990 --> 00:41:20,200
behavior if you don't care about

00:41:16,270 --> 00:41:20,590
performance yes you use big rats oh I'm

00:41:20,200 --> 00:41:30,190
sorry

00:41:20,590 --> 00:41:33,130
use fat wrap the only the only

00:41:30,190 --> 00:41:37,030
difference is normal rats limit the

00:41:33,130 --> 00:41:40,000
denominator to 64 bits and we have a

00:41:37,030 --> 00:41:43,180
very high speed but a greatest common

00:41:40,000 --> 00:41:46,120
denominator so reduction algorithm so

00:41:43,180 --> 00:41:48,670
it's just like nothing all right I'm

00:41:46,120 --> 00:41:51,810
gonna go on to the next section I would

00:41:48,670 --> 00:41:51,810
love to have questions later

00:41:52,090 --> 00:41:57,310
this is after my formal QA because I am

00:41:55,540 --> 00:42:02,880
not qualified to answer questions on it

00:41:57,310 --> 00:42:05,980
I barely know that concurrency

00:42:02,880 --> 00:42:09,760
asynchrony and parallelism are distinct

00:42:05,980 --> 00:42:12,790
concepts and I learned everything that I

00:42:09,760 --> 00:42:14,560
know about that from reading Jonathan's

00:42:12,790 --> 00:42:17,020
slide decks he's got some great

00:42:14,560 --> 00:42:19,120
presentations on this and he's the

00:42:17,020 --> 00:42:24,460
primary well he's the driving force

00:42:19,120 --> 00:42:27,370
behind the work on this so without

00:42:24,460 --> 00:42:29,890
getting into too much detail of code to

00:42:27,370 --> 00:42:31,620
stress test because I was getting a bug

00:42:29,890 --> 00:42:38,160
in in something that's playing with I

00:42:31,620 --> 00:42:41,680
wrote this insane threaded edition where

00:42:38,160 --> 00:42:44,710
so I've got a CH it's got 16 elements I

00:42:41,680 --> 00:42:47,200
keep doubling and doubling it twelve

00:42:44,710 --> 00:42:49,360
times to make there a huge I can

00:42:47,200 --> 00:42:51,340
optionally adjust it so it's not even

00:42:49,360 --> 00:42:53,800
power of tubes that changes the dynamics

00:42:51,340 --> 00:42:56,440
and I pass it to you my evil parallel ad

00:42:53,800 --> 00:42:58,060
and if it's wrong before what it comes

00:42:56,440 --> 00:43:00,910
out with is different than it yells at

00:42:58,060 --> 00:43:05,040
me but it doesn't yell at me because

00:43:00,910 --> 00:43:08,350
it's not wrong what is evil parallel ad

00:43:05,040 --> 00:43:12,190
it it takes the first two and adds them

00:43:08,350 --> 00:43:13,510
together spawning a thread to do it and

00:43:12,190 --> 00:43:14,860
then it takes the next two and adds them

00:43:13,510 --> 00:43:19,690
together spawning a threat to do it so

00:43:14,860 --> 00:43:21,040
all these threads go into an array which

00:43:19,690 --> 00:43:23,140
is half the size of the original and

00:43:21,040 --> 00:43:28,480
then all those

00:43:23,140 --> 00:43:29,769
get looped and so on and so forth but

00:43:28,480 --> 00:43:32,039
the threads don't have to complete

00:43:29,769 --> 00:43:34,210
before the next execution and they don't

00:43:32,039 --> 00:43:36,190
so you'd have whatever whatever your

00:43:34,210 --> 00:43:40,539
maximum number of threads are okay to

00:43:36,190 --> 00:43:42,970
run this we'll run it and I but I don't

00:43:40,539 --> 00:43:44,440
have a way to see I mean I can I can see

00:43:42,970 --> 00:43:49,269
that it's supposed to be six before but

00:43:44,440 --> 00:43:53,640
I don't have a atomic atomic max

00:43:49,269 --> 00:43:56,999
operator we do have atomic increment but

00:43:53,640 --> 00:44:01,749
just by wall clock timing I'm getting

00:43:56,999 --> 00:44:02,859
10,000 threads a second so that's that

00:44:01,749 --> 00:44:06,069
ought to be the thread over here because

00:44:02,859 --> 00:44:08,950
this operation of Plus is dead simple so

00:44:06,069 --> 00:44:10,900
that tells me that if your operation is

00:44:08,950 --> 00:44:12,730
more expensive than one ten thousandth

00:44:10,900 --> 00:44:15,099
of a second whatever the thing is that

00:44:12,730 --> 00:44:16,569
you want to do that as long as it

00:44:15,099 --> 00:44:19,359
doesn't have dependencies and you know

00:44:16,569 --> 00:44:23,109
order of operation this ought to provide

00:44:19,359 --> 00:44:26,410
a speed-up but that's not my point I

00:44:23,109 --> 00:44:29,410
mean yeah that's fun to play with my

00:44:26,410 --> 00:44:33,849
point is concurrency has been brought

00:44:29,410 --> 00:44:37,450
down to a point where I can learn it by

00:44:33,849 --> 00:44:40,509
exploring by playing it was up at a

00:44:37,450 --> 00:44:42,970
level where I would never try to do it

00:44:40,509 --> 00:44:51,630
at all without a formal class on the

00:44:42,970 --> 00:44:51,630
topic how much time do I have

00:44:51,990 --> 00:45:04,020
five minutes so I often end on this

00:45:01,110 --> 00:45:07,710
slide encouraging you all to play with

00:45:04,020 --> 00:45:13,500
pearl six it is brilliant and it is fun

00:45:07,710 --> 00:45:17,490
I often end on that slide since it shows

00:45:13,500 --> 00:45:27,570
off our family daredevil util one point

00:45:17,490 --> 00:45:31,860
one point three but today my secret

00:45:27,570 --> 00:45:35,869
extra point my fooly cooly you won't get

00:45:31,860 --> 00:45:35,869
it really unless you watch it back again

00:45:36,140 --> 00:45:47,540
yeah Clarice has been there my point is

00:45:42,240 --> 00:45:52,950
that the pro six design is extraordinary

00:45:47,540 --> 00:45:57,830
the pearl six design process produced

00:45:52,950 --> 00:46:01,740
that extraordinary design that process

00:45:57,830 --> 00:46:06,000
gets knocked it gets disrespected

00:46:01,740 --> 00:46:07,380
because it took over a decade to do that

00:46:06,000 --> 00:46:11,700
actually matches the law of system

00:46:07,380 --> 00:46:14,970
delivery yeah we thought it was going to

00:46:11,700 --> 00:46:18,380
take six months to two years so twelve

00:46:14,970 --> 00:46:18,380
years is actually right on target

00:46:19,670 --> 00:46:23,820
especially with reimagining the VM

00:46:22,050 --> 00:46:29,390
shifting to lazy list I didn't even

00:46:23,820 --> 00:46:32,850
touch on lazy lists and all volunteers

00:46:29,390 --> 00:46:36,830
but just look at all the deliberate

00:46:32,850 --> 00:46:40,550
inputs and processes into that

00:46:36,830 --> 00:46:40,550
development and design

00:46:48,390 --> 00:46:51,720
part of the reason his well thought out

00:46:50,010 --> 00:46:53,760
is because so much time has put in to

00:46:51,720 --> 00:46:55,620
thinking about it part of the reason it

00:46:53,760 --> 00:47:00,570
was so well thought out as it had input

00:46:55,620 --> 00:47:03,300
from a lot of people that had smart

00:47:00,570 --> 00:47:06,120
things to say about it and part the

00:47:03,300 --> 00:47:08,760
input was everybody that's been using it

00:47:06,120 --> 00:47:11,930
because it's a well-established well use

00:47:08,760 --> 00:47:11,930
heavily used language

00:47:19,210 --> 00:47:25,450
oops

00:47:21,550 --> 00:47:27,280
so of course I think pearl sex is great

00:47:25,450 --> 00:47:30,210
to code in I've said it for years please

00:47:27,280 --> 00:47:34,330
do try it I'll help you if you need it

00:47:30,210 --> 00:47:39,090
but today I assert that other languages

00:47:34,330 --> 00:47:44,050
should be stealing parts of this design

00:47:39,090 --> 00:47:46,870
and I further assert that language

00:47:44,050 --> 00:47:50,200
designers and system designers should

00:47:46,870 --> 00:47:54,130
not dismiss the process that led to this

00:47:50,200 --> 00:47:57,250
design the design is too good for such a

00:47:54,130 --> 00:48:02,700
dismissal instead look at how to

00:47:57,250 --> 00:48:07,870
duplicate our process take these inputs

00:48:02,700 --> 00:48:13,930
take the time necessary just you know

00:48:07,870 --> 00:48:18,220
figure out how to do it faster that's my

00:48:13,930 --> 00:48:19,260
time I'm thrilled to see you all thank

00:48:18,220 --> 00:48:22,359
you

00:48:19,260 --> 00:48:22,359
[Applause]

00:48:25,000 --> 00:48:29,110
[Applause]

00:48:34,240 --> 00:48:36,300

YouTube URL: https://www.youtube.com/watch?v=DJCp6k1ts3g


