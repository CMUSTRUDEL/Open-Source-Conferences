Title: David Oswald - "Abstraction, Encapsulation, Polymorphism, and Inheritance"
Publication date: 2018-06-20
Playlist: TPC 2018 in SLC
Description: 
	We will discuss what are commonly known to be the four pillars of Object Oriented Programming, but that really are so much more than just pillars of OOP — They’re strategies for solving hard problems elegantly.
Captions: 
	00:00:00,000 --> 00:00:03,689
this is a discussion that's kind of an

00:00:01,680 --> 00:00:05,790
entry level for object-oriented

00:00:03,689 --> 00:00:10,260
programming we like to do some beginner

00:00:05,790 --> 00:00:13,170
level talks at at yap c and so if if

00:00:10,260 --> 00:00:15,750
this is if object-oriented programming

00:00:13,170 --> 00:00:17,430
is all that you do then you know there

00:00:15,750 --> 00:00:20,250
are there are other great talks to see

00:00:17,430 --> 00:00:25,140
as well but if you want to stay and

00:00:20,250 --> 00:00:29,189
enjoy some of this then please do my

00:00:25,140 --> 00:00:32,570
name is Dave Oswald and I enjoy Perl

00:00:29,189 --> 00:00:35,880
that's one of the it was back in the

00:00:32,570 --> 00:00:38,579
mid-90s I had been programming in C and

00:00:35,880 --> 00:00:41,520
in C++ and then I picked up a Perl book

00:00:38,579 --> 00:00:43,170
and and suddenly everything changed for

00:00:41,520 --> 00:00:46,170
me and how I looked at programming and

00:00:43,170 --> 00:00:49,590
so I'm a Perl enthusiam fizzy estai I

00:00:46,170 --> 00:00:52,410
also participated in community activist

00:00:49,590 --> 00:00:54,989
II in the past I was an organizer in

00:00:52,410 --> 00:00:57,719
previous years for this conference and

00:00:54,989 --> 00:01:02,340
for Open West and I organized the salt

00:00:57,719 --> 00:01:04,379
lake pearl mongers I'm I'm a software

00:01:02,340 --> 00:01:05,760
engineer at endurance international

00:01:04,379 --> 00:01:07,530
group so I want to thank endurance for

00:01:05,760 --> 00:01:09,000
letting me be here today we're the

00:01:07,530 --> 00:01:11,220
company that owns Bluehost and there's a

00:01:09,000 --> 00:01:13,680
few familiar faces in the room here so

00:01:11,220 --> 00:01:16,770
thanks for coming out and supporting us

00:01:13,680 --> 00:01:19,350
as well so so our goal today is to learn

00:01:16,770 --> 00:01:21,930
some simple thought processes that are

00:01:19,350 --> 00:01:26,520
useful to programmers and see how that

00:01:21,930 --> 00:01:28,409
they can be applied to our work and in

00:01:26,520 --> 00:01:29,909
specific relating to object-oriented

00:01:28,409 --> 00:01:33,689
programming so the first thing I wanted

00:01:29,909 --> 00:01:35,420
to talk about is encapsulation anybody

00:01:33,689 --> 00:01:38,579
familiar with this start with this

00:01:35,420 --> 00:01:40,170
concept okay so encapsulation to

00:01:38,579 --> 00:01:41,939
completely enclose but before we talk

00:01:40,170 --> 00:01:46,710
about encapsulation I'd like to talk

00:01:41,939 --> 00:01:47,909
about substitution so I had a note here

00:01:46,710 --> 00:01:50,579
on how to pronounce these characters

00:01:47,909 --> 00:01:52,259
let's say Phi and feet so where Phi and

00:01:50,579 --> 00:01:53,159
fie represent formulas is that what

00:01:52,259 --> 00:01:54,899
those are I don't know what they're I

00:01:53,159 --> 00:01:57,329
can't write what they're fine figure

00:01:54,899 --> 00:02:00,450
represent formulas Phi is a substitution

00:01:57,329 --> 00:02:02,610
instance of fee if and only if the Phi

00:02:00,450 --> 00:02:05,430
may be obtained from fee by substituting

00:02:02,610 --> 00:02:06,930
formulas for symbols in fee replacing

00:02:05,430 --> 00:02:08,879
each occurrence of the same symbol by an

00:02:06,930 --> 00:02:10,920
occurrence of a formula so that's that's

00:02:08,879 --> 00:02:12,620
a pretty complex explanation and it

00:02:10,920 --> 00:02:15,950
comes from Wikipedia

00:02:12,620 --> 00:02:18,340
if that's the way that cs101 is taught

00:02:15,950 --> 00:02:20,720
then we're all in trouble

00:02:18,340 --> 00:02:22,580
so let's talk a little bit more in depth

00:02:20,720 --> 00:02:24,709
about what substitution really is and

00:02:22,580 --> 00:02:26,180
this is the more detailed explanation is

00:02:24,709 --> 00:02:29,840
to put something in place of another

00:02:26,180 --> 00:02:33,590
thing and so let's consider the example

00:02:29,840 --> 00:02:36,110
of a factorial and and so we tend to use

00:02:33,590 --> 00:02:38,750
over here I'm gonna use my laser we tend

00:02:36,110 --> 00:02:41,209
to use and with an exclamation point to

00:02:38,750 --> 00:02:43,040
represent factorial right but what is

00:02:41,209 --> 00:02:45,319
factorial really well it's this it's

00:02:43,040 --> 00:02:47,989
suggest advance it's this algorithm

00:02:45,319 --> 00:02:49,910
right here and that's a mathematical

00:02:47,989 --> 00:02:53,630
representation of the algorithm it's not

00:02:49,910 --> 00:02:56,000
a code representation so or we can look

00:02:53,630 --> 00:02:57,230
at the representation a different way

00:02:56,000 --> 00:02:59,030
where we're going to take an and

00:02:57,230 --> 00:03:01,489
multiply it by n minus 1 and multiply it

00:02:59,030 --> 00:03:06,079
by n minus 2 and so forth until we get

00:03:01,489 --> 00:03:08,540
to one and so butBut because it's really

00:03:06,079 --> 00:03:11,420
hard to reason about formulas that have

00:03:08,540 --> 00:03:13,129
all of this in them we tend to use just

00:03:11,420 --> 00:03:15,769
this and so we will tend to say 2

00:03:13,129 --> 00:03:18,739
factorial plus 3 factorial instead of

00:03:15,769 --> 00:03:21,290
saying 2 times 2 minus 1 plus 3 times 3

00:03:18,739 --> 00:03:24,709
minus 1 times 3 minus 2 because that's

00:03:21,290 --> 00:03:26,209
just too too laborious right and too

00:03:24,709 --> 00:03:28,549
hard to reason about and if we did that

00:03:26,209 --> 00:03:30,079
for every type of formula then we'd end

00:03:28,549 --> 00:03:31,790
up with a big mess as we're trying to

00:03:30,079 --> 00:03:34,970
solve problems and this is just in the

00:03:31,790 --> 00:03:37,220
realm of mathematics so we we like to

00:03:34,970 --> 00:03:39,380
represent things in simple ways we take

00:03:37,220 --> 00:03:42,669
the complex concepts and represent them

00:03:39,380 --> 00:03:44,630
into more simple ways so we can say that

00:03:42,669 --> 00:03:47,389
another way to look at it is that n

00:03:44,630 --> 00:03:50,389
factorial is n times the factorial of n

00:03:47,389 --> 00:03:52,700
minus 1 and and so then now we're

00:03:50,389 --> 00:03:54,319
getting recursive so let's move away

00:03:52,700 --> 00:03:55,910
from factorial for a minute and talk

00:03:54,319 --> 00:03:59,720
about something else that's really

00:03:55,910 --> 00:04:01,639
important in life and that's goats and

00:03:59,720 --> 00:04:03,650
so goats are made up of a lot of

00:04:01,639 --> 00:04:05,090
different parts and farmers don't tend

00:04:03,650 --> 00:04:06,530
to have to think about all of the parts

00:04:05,090 --> 00:04:08,450
all of the time and if they did then

00:04:06,530 --> 00:04:11,230
they'd have trouble dealing with their

00:04:08,450 --> 00:04:13,609
flock of goats because goats tend to be

00:04:11,230 --> 00:04:15,200
they tend to be curious and they tend to

00:04:13,609 --> 00:04:17,359
be trouble seekers and they end up in

00:04:15,200 --> 00:04:18,739
crazy situations and they like to eat

00:04:17,359 --> 00:04:21,320
your clothing and all that sort of thing

00:04:18,739 --> 00:04:23,690
and so it's really hard to keep track of

00:04:21,320 --> 00:04:25,440
all of the things about a goat when

00:04:23,690 --> 00:04:28,980
you're when you're dealing with

00:04:25,440 --> 00:04:31,050
goat himself just the goats personality

00:04:28,980 --> 00:04:33,720
and who the goat is and so this is where

00:04:31,050 --> 00:04:35,820
we get back to the idea of and so we

00:04:33,720 --> 00:04:38,190
substitute all of these difficult things

00:04:35,820 --> 00:04:40,020
about a goat just in the term goat this

00:04:38,190 --> 00:04:41,820
is our substitution we and when I say

00:04:40,020 --> 00:04:43,170
goat thing you're all thinking well the

00:04:41,820 --> 00:04:45,420
thing that the petting zoo that eats my

00:04:43,170 --> 00:04:47,070
clothes and and and that has little

00:04:45,420 --> 00:04:49,590
horns and and all that sort of thing so

00:04:47,070 --> 00:04:52,050
we use substitution to kind of gloss

00:04:49,590 --> 00:04:53,760
over all of the details so this takes us

00:04:52,050 --> 00:04:55,730
back to encapsulation which is to

00:04:53,760 --> 00:04:59,250
completely enclose and so let's

00:04:55,730 --> 00:05:00,780
encapsulate our factorial and this is

00:04:59,250 --> 00:05:02,970
scheme because I happen to like how

00:05:00,780 --> 00:05:06,000
factorials are represented in scheme but

00:05:02,970 --> 00:05:07,380
we're at a Perl conference so and I

00:05:06,000 --> 00:05:11,100
think was Larry that said that scheme

00:05:07,380 --> 00:05:13,830
has all of the was it all of the visual

00:05:11,100 --> 00:05:17,100
appeal of fingernail clippings or

00:05:13,830 --> 00:05:18,360
something like that so yeah yeah oatmeal

00:05:17,100 --> 00:05:19,860
with fingernail clippings in it so I

00:05:18,360 --> 00:05:21,210
guess I should have had a oatmeal slide

00:05:19,860 --> 00:05:29,790
up there so we'll look at the purl one

00:05:21,210 --> 00:05:31,530
which is much better oh really that's

00:05:29,790 --> 00:05:32,640
great so we're gonna look at the

00:05:31,530 --> 00:05:34,260
factorial here and we've done a

00:05:32,640 --> 00:05:37,050
recursive version of the factorial which

00:05:34,260 --> 00:05:39,420
is to say that that we are going to take

00:05:37,050 --> 00:05:41,010
X and multiply it by X minus one and

00:05:39,420 --> 00:05:42,390
then and then in the end on the right

00:05:41,010 --> 00:05:44,850
over here we just when we want to use

00:05:42,390 --> 00:05:46,590
our factorial we just say factorial five

00:05:44,850 --> 00:05:49,110
for example and it's going to print out

00:05:46,590 --> 00:05:52,020
120 so this is a really easy way of

00:05:49,110 --> 00:05:54,750
encapsulating behavior we encapsulate

00:05:52,020 --> 00:05:55,980
behavior and subroutines essentially in

00:05:54,750 --> 00:05:57,510
Perl

00:05:55,980 --> 00:05:59,790
there are other things that we can

00:05:57,510 --> 00:06:02,690
encapsulate we might encapsulate pie as

00:05:59,790 --> 00:06:05,490
just a variable we might encapsulate

00:06:02,690 --> 00:06:07,169
primary colors red yellow blue giving

00:06:05,490 --> 00:06:10,100
them a label of primary colors so in

00:06:07,169 --> 00:06:13,200
Perl that might look like my pi equals

00:06:10,100 --> 00:06:15,150
3.14159265 for and might we might say my

00:06:13,200 --> 00:06:18,510
primary colors as an array equals quote

00:06:15,150 --> 00:06:20,880
word red yellow and blue so these are

00:06:18,510 --> 00:06:24,090
just ways that we use substitution to

00:06:20,880 --> 00:06:25,680
encapsulate to encapsulate ideas and

00:06:24,090 --> 00:06:27,270
concepts so they don't have to keep

00:06:25,680 --> 00:06:29,040
thinking about them let's look at a

00:06:27,270 --> 00:06:32,400
little bit more complex

00:06:29,040 --> 00:06:36,100
encapsulation so this is a flight

00:06:32,400 --> 00:06:38,950
recorder and a flight recorder does

00:06:36,100 --> 00:06:41,080
it really does one thing it keeps a

00:06:38,950 --> 00:06:42,760
history of everything that's going on

00:06:41,080 --> 00:06:45,940
right it keeps a history of all the

00:06:42,760 --> 00:06:49,930
things and so I imagine that inside it's

00:06:45,940 --> 00:06:51,310
fairly complex and we hope that we

00:06:49,930 --> 00:06:52,990
almost never have to deal with that

00:06:51,310 --> 00:06:55,450
complexity we just hope that it's going

00:06:52,990 --> 00:06:57,100
to collect all the things and keep and

00:06:55,450 --> 00:07:00,010
keep a record of them keep a history of

00:06:57,100 --> 00:07:01,990
them and so what this flight recorder is

00:07:00,010 --> 00:07:05,770
doing is actually it's encapsulating or

00:07:01,990 --> 00:07:07,890
completely enclosing both state which is

00:07:05,770 --> 00:07:10,960
data information history and

00:07:07,890 --> 00:07:13,300
encapsulating functionality or behavior

00:07:10,960 --> 00:07:14,470
and the behavior that's encapsulating is

00:07:13,300 --> 00:07:17,260
it's going to be recording everything

00:07:14,470 --> 00:07:21,940
that's going on during the flight that's

00:07:17,260 --> 00:07:23,890
a that's worth recording so we're going

00:07:21,940 --> 00:07:25,420
to completely encapsulate and enclose

00:07:23,890 --> 00:07:25,810
state and behavior and why would we do

00:07:25,420 --> 00:07:28,120
this

00:07:25,810 --> 00:07:28,990
any thoughts I'm willing to this isn't

00:07:28,120 --> 00:07:33,610
one of those socks where there's no

00:07:28,990 --> 00:07:35,050
interaction and allowed so well one

00:07:33,610 --> 00:07:38,550
reason that we would want to completely

00:07:35,050 --> 00:07:40,900
encapsulate state and behavior is that

00:07:38,550 --> 00:07:43,210
when you're coming in for a landing on

00:07:40,900 --> 00:07:44,650
the approach just about the last thing

00:07:43,210 --> 00:07:47,530
that you want your pilot to be worried

00:07:44,650 --> 00:07:50,080
about is what's going on inside that box

00:07:47,530 --> 00:07:52,390
what's going on inside the encapsulated

00:07:50,080 --> 00:07:54,190
device because if they have to spend too

00:07:52,390 --> 00:07:56,560
much time thinking about the aircraft

00:07:54,190 --> 00:07:58,240
interface board and the memory interface

00:07:56,560 --> 00:08:00,790
cable and the height temperature

00:07:58,240 --> 00:08:03,460
insulation there's a there's a high

00:08:00,790 --> 00:08:05,140
amount of cognitive load associated with

00:08:03,460 --> 00:08:07,330
all of that and they're a little bit

00:08:05,140 --> 00:08:08,920
busy at the moment trying to land a

00:08:07,330 --> 00:08:10,390
plane and they've got some instruments

00:08:08,920 --> 00:08:11,620
nowadays this may be not as busy as it

00:08:10,390 --> 00:08:14,710
used to be I don't know I don't fly

00:08:11,620 --> 00:08:15,940
planes so so we don't really want them

00:08:14,710 --> 00:08:17,380
thinking about what's going on inside

00:08:15,940 --> 00:08:20,170
the plane or else they'll end up going

00:08:17,380 --> 00:08:21,730
off the runway and that cannot happen

00:08:20,170 --> 00:08:28,210
and when that happens then you break

00:08:21,730 --> 00:08:32,620
encapsulation so let's get back to goats

00:08:28,210 --> 00:08:34,750
for just a minute what's that yeah here

00:08:32,620 --> 00:08:36,880
we are back to goats because why not

00:08:34,750 --> 00:08:39,870
so goats have all these different parts

00:08:36,880 --> 00:08:43,750
and this is maybe only a butcher's

00:08:39,870 --> 00:08:45,550
concept of a goat and a farmers concept

00:08:43,750 --> 00:08:47,110
of a goat might be more along the lines

00:08:45,550 --> 00:08:48,180
of that it's small livestock and has

00:08:47,110 --> 00:08:49,980
horns and hor

00:08:48,180 --> 00:08:51,870
pupils and eats almost anything and is

00:08:49,980 --> 00:08:53,820
curious and that it's a trouble seeker

00:08:51,870 --> 00:08:55,950
and then there are you know the

00:08:53,820 --> 00:08:57,360
Internet's concepts of goats and this is

00:08:55,950 --> 00:09:00,029
really kind of what we want to deal with

00:08:57,360 --> 00:09:02,130
is just the just the overall concept of

00:09:00,029 --> 00:09:03,839
a goat we want to get rid of all of the

00:09:02,130 --> 00:09:05,700
detail and think of just the nice goat

00:09:03,839 --> 00:09:07,760
out there having a great time and being

00:09:05,700 --> 00:09:10,860
essentially a mischievous goat

00:09:07,760 --> 00:09:13,620
so this is where abstraction comes in an

00:09:10,860 --> 00:09:16,860
abstraction is the process of removing

00:09:13,620 --> 00:09:19,470
physical spatial or temporal details or

00:09:16,860 --> 00:09:21,839
attributes in the study of objects or

00:09:19,470 --> 00:09:24,959
systems in order to more closely attend

00:09:21,839 --> 00:09:26,970
to other details of interest it is also

00:09:24,959 --> 00:09:28,860
very similar in nature to the process of

00:09:26,970 --> 00:09:32,640
generalization so this is from Wikipedia

00:09:28,860 --> 00:09:33,680
again so this means now we have another

00:09:32,640 --> 00:09:37,880
problem we need to discuss

00:09:33,680 --> 00:09:40,410
generalization what is generalization

00:09:37,880 --> 00:09:41,880
broadening of application to encompass a

00:09:40,410 --> 00:09:43,350
larger domain of objects of the same

00:09:41,880 --> 00:09:45,149
same or different type again from

00:09:43,350 --> 00:09:46,470
Wikipedia none of this makes a whole lot

00:09:45,149 --> 00:09:49,250
of sense when you just look at it the

00:09:46,470 --> 00:09:52,260
words so let's talk about generalization

00:09:49,250 --> 00:09:54,630
anybody familiar with what this is gent

00:09:52,260 --> 00:09:58,350
dremel tool right this is a generalized

00:09:54,630 --> 00:10:00,180
tool sort of for some for some types of

00:09:58,350 --> 00:10:01,830
tasks like I've got a dremel a dremel

00:10:00,180 --> 00:10:03,750
tool it always seems like it's a great

00:10:01,830 --> 00:10:05,370
thing to have like I really need to have

00:10:03,750 --> 00:10:06,930
that dremel tool and yet I can't really

00:10:05,370 --> 00:10:09,180
ever find any applications where I

00:10:06,930 --> 00:10:10,170
actually need to use it so it mostly

00:10:09,180 --> 00:10:12,240
just sits but anyway it's a very

00:10:10,170 --> 00:10:14,790
generalized tool but what does it do

00:10:12,240 --> 00:10:17,070
what does journal tool do it spins a bit

00:10:14,790 --> 00:10:18,810
really fast and it has a handgrip that's

00:10:17,070 --> 00:10:21,029
what it does it does just those two

00:10:18,810 --> 00:10:21,690
things it spins a bit really fast and it

00:10:21,029 --> 00:10:24,660
has a handgrip

00:10:21,690 --> 00:10:28,440
but it but it can have its application

00:10:24,660 --> 00:10:33,240
broadened by specializing it with its

00:10:28,440 --> 00:10:34,800
range of tips right so this is a drum

00:10:33,240 --> 00:10:36,959
generalized tool and this is not a very

00:10:34,800 --> 00:10:38,370
generalized tool here this one will do

00:10:36,959 --> 00:10:42,180
one thing and one thing only and that's

00:10:38,370 --> 00:10:46,680
to put holes in I guess wood in the

00:10:42,180 --> 00:10:48,839
1800s so dremel tool is a generalized

00:10:46,680 --> 00:10:50,670
tool but we're going to talk more about

00:10:48,839 --> 00:10:52,610
the dremel tool in a little while but

00:10:50,670 --> 00:10:54,870
first let's talk about the lowly hash

00:10:52,610 --> 00:10:57,750
we're all familiar with hashes we use

00:10:54,870 --> 00:11:00,180
them every day in Perl and that they're

00:10:57,750 --> 00:11:01,500
part of what make made Perl great thirty

00:11:00,180 --> 00:11:04,080
years ago and they're part of

00:11:01,500 --> 00:11:08,000
making other languages great nowadays as

00:11:04,080 --> 00:11:11,250
well so in pearl we would say my hash

00:11:08,000 --> 00:11:13,470
equals and then fou 42 and bar 84 and

00:11:11,250 --> 00:11:15,960
then we can say hash fou and get our 42

00:11:13,470 --> 00:11:18,360
back so it's an index thing and on the

00:11:15,960 --> 00:11:20,760
on the on the front side we as

00:11:18,360 --> 00:11:22,590
programmers are glad to just only deal

00:11:20,760 --> 00:11:24,300
with that that's very simple we can

00:11:22,590 --> 00:11:28,050
think about it we're indexing into a

00:11:24,300 --> 00:11:29,940
hash by selecting its element foo and we

00:11:28,050 --> 00:11:33,660
can we can use hashes for all kinds of

00:11:29,940 --> 00:11:35,820
useful things but under the hood hashes

00:11:33,660 --> 00:11:37,980
are actually kind of complicated the way

00:11:35,820 --> 00:11:40,290
a hash has to work is that you start

00:11:37,980 --> 00:11:42,180
with your keys and the keys go through a

00:11:40,290 --> 00:11:44,010
hashing algorithm that decide which

00:11:42,180 --> 00:11:45,870
bucket they're going to go in and then

00:11:44,010 --> 00:11:48,330
anytime you have a bucket collision then

00:11:45,870 --> 00:11:49,620
you have a linked list and and that's

00:11:48,330 --> 00:11:52,260
why you don't want your buckets to get

00:11:49,620 --> 00:11:53,610
too huge because eventually you end up

00:11:52,260 --> 00:11:56,520
in a little bit of a linear search here

00:11:53,610 --> 00:11:57,690
through your linked list it turns out

00:11:56,520 --> 00:12:01,410
that because we don't have to think

00:11:57,690 --> 00:12:03,690
about it we can in in more CS terms we

00:12:01,410 --> 00:12:07,020
can say that hash lookups occur in

00:12:03,690 --> 00:12:09,450
constant time in amortized constant time

00:12:07,020 --> 00:12:10,560
and hashing starts happen in amortized

00:12:09,450 --> 00:12:12,839
constant time and we're able to

00:12:10,560 --> 00:12:15,810
generalize about the concept of a hash

00:12:12,839 --> 00:12:16,470
even though inside they're really

00:12:15,810 --> 00:12:19,020
complex

00:12:16,470 --> 00:12:20,850
Perls hash consists of a whole bunch of

00:12:19,020 --> 00:12:22,980
different little pieces in little parts

00:12:20,850 --> 00:12:24,300
to make to make this whole thing work so

00:12:22,980 --> 00:12:27,330
that we can have something simple like

00:12:24,300 --> 00:12:28,980
this on the front so a hash encapsulate

00:12:27,330 --> 00:12:30,450
a whole bunch of craziness and a whole

00:12:28,980 --> 00:12:32,550
bunch of stuff that we never want to

00:12:30,450 --> 00:12:34,680
think about unless unless you like

00:12:32,550 --> 00:12:36,150
dealing with pearl guts which is

00:12:34,680 --> 00:12:37,710
sometimes fun but usually not when

00:12:36,150 --> 00:12:41,850
you're trying to optimize for getting

00:12:37,710 --> 00:12:43,770
work done so the hash API really is

00:12:41,850 --> 00:12:46,320
doing very few things if you think of

00:12:43,770 --> 00:12:47,670
what the hash API is just only one layer

00:12:46,320 --> 00:12:50,430
under the hood instead of all the way in

00:12:47,670 --> 00:12:52,830
the guts a hash API has a constructor

00:12:50,430 --> 00:12:54,810
and it has a store and a fetch and a

00:12:52,830 --> 00:12:57,900
first key and a next key which is used

00:12:54,810 --> 00:12:59,670
for things like this and keys and it

00:12:57,900 --> 00:13:02,190
hasn't exists and a delete and a clear

00:12:59,670 --> 00:13:03,600
and a scalar and scalars like the most

00:13:02,190 --> 00:13:05,100
useless part although I think I guess

00:13:03,600 --> 00:13:07,920
it's become more useful in recent

00:13:05,100 --> 00:13:09,540
versions of Perl but each of these

00:13:07,920 --> 00:13:12,600
things each of these concepts are

00:13:09,540 --> 00:13:13,900
represented in our space as Perl

00:13:12,600 --> 00:13:16,000
developers as

00:13:13,900 --> 00:13:19,060
for example the constructor my hash

00:13:16,000 --> 00:13:22,000
equals whatever a store would be to

00:13:19,060 --> 00:13:24,790
insert a key a fetch would be to find

00:13:22,000 --> 00:13:28,360
the value in a key each is used is each

00:13:24,790 --> 00:13:30,370
makes use of first and next key exists

00:13:28,360 --> 00:13:33,790
passes straight through as a function

00:13:30,370 --> 00:13:37,060
into or as an operator into Perl delete

00:13:33,790 --> 00:13:39,160
is an operator in Perl clear is

00:13:37,060 --> 00:13:41,380
essentially assigning an empty list and

00:13:39,160 --> 00:13:43,180
scalar is again kind of that useless

00:13:41,380 --> 00:13:46,270
thing where we just find out if it has

00:13:43,180 --> 00:13:48,400
keys or not essentially that's about all

00:13:46,270 --> 00:13:50,350
it's useful but but the this fairly

00:13:48,400 --> 00:13:53,020
simple interface that we use every day

00:13:50,350 --> 00:13:54,790
of our of our jobs is really under the

00:13:53,020 --> 00:13:56,700
hood doing all this crazy stuff that we

00:13:54,790 --> 00:13:59,680
don't have to think about and this is a

00:13:56,700 --> 00:14:02,589
perfect example of a nice useful

00:13:59,680 --> 00:14:05,790
abstraction that there is a result of

00:14:02,589 --> 00:14:09,610
encapsulating a bunch of both data and

00:14:05,790 --> 00:14:11,380
behavior so a perl hash is an object

00:14:09,610 --> 00:14:13,960
abstraction encapsulating data and

00:14:11,380 --> 00:14:15,940
behavior and removing unnecessary detail

00:14:13,960 --> 00:14:18,339
from the interface which allows us to

00:14:15,940 --> 00:14:20,410
concentrate on solving higher-level

00:14:18,339 --> 00:14:25,660
problems like finding unique things

00:14:20,410 --> 00:14:28,360
easily right so an abstraction is an

00:14:25,660 --> 00:14:30,190
emphasis on an idea qualities and

00:14:28,360 --> 00:14:33,010
properties rather than the particulars

00:14:30,190 --> 00:14:35,110
so it's a suppression of detail so in

00:14:33,010 --> 00:14:36,970
the case of a goat it's an emphasis on

00:14:35,110 --> 00:14:40,200
the idea or the qualities or the

00:14:36,970 --> 00:14:44,170
properties rather than the particulars

00:14:40,200 --> 00:14:45,940
so there is a famous quote that I think

00:14:44,170 --> 00:14:47,440
that I really like that says all

00:14:45,940 --> 00:14:49,450
problems in computer science can be

00:14:47,440 --> 00:14:51,790
solved by another layer layer of

00:14:49,450 --> 00:14:53,110
indirection or abstraction and that's

00:14:51,790 --> 00:14:54,880
kind of what we're seeing I'm gonna go

00:14:53,110 --> 00:14:56,680
back little right here is we're seeing a

00:14:54,880 --> 00:14:59,589
problem in computer science finding

00:14:56,680 --> 00:15:01,000
unique things being solved by a couple

00:14:59,589 --> 00:15:03,280
layers of abstraction or indirection

00:15:01,000 --> 00:15:04,810
here we have a seam hash and we have

00:15:03,280 --> 00:15:06,550
grep and now we've got an anonymous

00:15:04,810 --> 00:15:10,420
subroutine these are all layers of

00:15:06,550 --> 00:15:13,740
indirection or layers of abstraction any

00:15:10,420 --> 00:15:13,740
questions everybody with me here

00:15:16,550 --> 00:15:22,620
so now now let's talk about

00:15:20,970 --> 00:15:24,899
object-oriented programming a little bit

00:15:22,620 --> 00:15:26,970
here and the world is seen by an

00:15:24,899 --> 00:15:28,589
object-oriented program er all these

00:15:26,970 --> 00:15:30,660
different little things you try we can

00:15:28,589 --> 00:15:32,310
start thinking of the world in terms of

00:15:30,660 --> 00:15:34,230
objects then used or when you start

00:15:32,310 --> 00:15:36,000
learning about object-oriented

00:15:34,230 --> 00:15:39,000
programming you start seeing objects in

00:15:36,000 --> 00:15:40,680
everything and you start you know it's

00:15:39,000 --> 00:15:42,480
your new it's your new hammer just like

00:15:40,680 --> 00:15:45,660
when you first learn regular expressions

00:15:42,480 --> 00:15:47,100
that becomes your your new hammer so but

00:15:45,660 --> 00:15:49,009
the concepts that are basic to

00:15:47,100 --> 00:15:51,930
object-oriented programming are classes

00:15:49,009 --> 00:15:54,480
in a class is just a specification of

00:15:51,930 --> 00:15:58,620
attributes which which can be considered

00:15:54,480 --> 00:16:01,139
State and methods which can be

00:15:58,620 --> 00:16:03,089
considered behavior so a class is just a

00:16:01,139 --> 00:16:07,500
name that stands for a specification of

00:16:03,089 --> 00:16:11,069
State and behaviors and then objects are

00:16:07,500 --> 00:16:17,490
just instances of classes so a goat

00:16:11,069 --> 00:16:20,100
might be a class whereas the I don't

00:16:17,490 --> 00:16:21,839
have any goats but my neighbor's goat my

00:16:20,100 --> 00:16:25,250
neighbor's goat named chops might

00:16:21,839 --> 00:16:28,680
actually be an instance of a goat right

00:16:25,250 --> 00:16:30,329
okay so classes are specifications of

00:16:28,680 --> 00:16:32,550
data state objects or instances

00:16:30,329 --> 00:16:34,620
attributes are the characteristics of an

00:16:32,550 --> 00:16:40,529
object and methods are things that an

00:16:34,620 --> 00:16:42,540
object can do so I've promised not to

00:16:40,529 --> 00:16:44,490
use animals in my talk and now I'm gonna

00:16:42,540 --> 00:16:46,170
use animals because they actually I was

00:16:44,490 --> 00:16:47,760
talking with Randal the other night at

00:16:46,170 --> 00:16:49,050
the arrivals dinner and said I'm not

00:16:47,760 --> 00:16:50,279
gonna use animals and he said why not

00:16:49,050 --> 00:16:52,290
they actually worked pretty good for

00:16:50,279 --> 00:16:54,660
this and he's right and so I'm gonna use

00:16:52,290 --> 00:16:56,370
animals I went back and changed a few

00:16:54,660 --> 00:16:58,110
slides and so we're gonna talk about the

00:16:56,370 --> 00:16:59,970
concept of an animal is a living

00:16:58,110 --> 00:17:02,670
organism it's multicellular it feeds on

00:16:59,970 --> 00:17:04,290
organic matter it has specialized sense

00:17:02,670 --> 00:17:07,079
organs it has a nervous system in

00:17:04,290 --> 00:17:09,510
response to stimuli that's kind of the

00:17:07,079 --> 00:17:10,980
basic I guess definition of an animal

00:17:09,510 --> 00:17:12,929
there's probably additional things we

00:17:10,980 --> 00:17:14,669
can layer in there so there are types of

00:17:12,929 --> 00:17:17,220
animals there's mammals and reptiles and

00:17:14,669 --> 00:17:19,260
birds and fish and and then in the

00:17:17,220 --> 00:17:21,390
mammals we have dogs and dogs inherit

00:17:19,260 --> 00:17:24,030
all of the inherit of or have all of the

00:17:21,390 --> 00:17:27,720
characteristics of mammals so a dog is a

00:17:24,030 --> 00:17:29,630
mammal and a mammal is an animal good

00:17:27,720 --> 00:17:32,790
with all this

00:17:29,630 --> 00:17:35,400
so this takes us to inheritance and

00:17:32,790 --> 00:17:37,410
inheritance really can be expressed like

00:17:35,400 --> 00:17:39,810
here's an example of inheritance a

00:17:37,410 --> 00:17:42,090
vehicle can be a wheeled vehicle or a

00:17:39,810 --> 00:17:43,920
sailboat and will be a vehicle can be a

00:17:42,090 --> 00:17:48,300
bike or it can be a car and it can be a

00:17:43,920 --> 00:17:50,460
car can be a sedan or a coupe so we can

00:17:48,300 --> 00:17:51,260
talk about sandy which is used to be my

00:17:50,460 --> 00:17:55,470
dog

00:17:51,260 --> 00:17:59,310
and so sandy is a mammal and she's a dog

00:17:55,470 --> 00:18:02,970
and she so a dog is an instant and then

00:17:59,310 --> 00:18:05,040
sandy my dog is an instance of dogs in

00:18:02,970 --> 00:18:07,380
general and my dog has a name and her

00:18:05,040 --> 00:18:09,000
name is sandy and she has a breed she's

00:18:07,380 --> 00:18:12,450
a golden retriever and she has a

00:18:09,000 --> 00:18:13,950
personality and she's a female and she

00:18:12,450 --> 00:18:16,770
responds to a set of commands

00:18:13,950 --> 00:18:18,450
occasionally and she has a date of birth

00:18:16,770 --> 00:18:20,430
and walks and eats and drinks and poops

00:18:18,450 --> 00:18:21,930
and sees and sleeps in place and barks

00:18:20,430 --> 00:18:23,910
and sniffs all the things the dogs do

00:18:21,930 --> 00:18:25,860
because she's an instance of a dog and

00:18:23,910 --> 00:18:27,270
so how does sandy relate to

00:18:25,860 --> 00:18:29,520
object-oriented programming while a dog

00:18:27,270 --> 00:18:31,680
is a type of thing and so a dog is a

00:18:29,520 --> 00:18:34,740
class and an instance of a dog is an

00:18:31,680 --> 00:18:37,050
object in that class and so Ana dog has

00:18:34,740 --> 00:18:39,170
attributes it has state it can be awake

00:18:37,050 --> 00:18:44,190
it can be asleep happy sad hungry

00:18:39,170 --> 00:18:45,540
mischievous and a dog has behaviors they

00:18:44,190 --> 00:18:49,130
can wag their tail when they're happy

00:18:45,540 --> 00:18:52,200
and they can eat and drink and so on so

00:18:49,130 --> 00:18:53,730
so if we look at sandy as an object as

00:18:52,200 --> 00:18:55,800
an instance of dog class then her

00:18:53,730 --> 00:18:58,050
attributes are specific to her instance

00:18:55,800 --> 00:19:01,170
of dogdom and her actions and methods

00:18:58,050 --> 00:19:03,710
act upon that act upon her art and art

00:19:01,170 --> 00:19:08,220
or are done by her

00:19:03,710 --> 00:19:09,450
so in inheritance the class dog inherits

00:19:08,220 --> 00:19:11,340
many of its traits from mammals and

00:19:09,450 --> 00:19:14,850
mammals inherit many of their traits

00:19:11,340 --> 00:19:18,570
from animals and so as sandy relates to

00:19:14,850 --> 00:19:20,940
all of this she is we might consider an

00:19:18,570 --> 00:19:22,620
animal as a base class or technically an

00:19:20,940 --> 00:19:24,210
abstract base class because you can't

00:19:22,620 --> 00:19:27,150
just be an animal and not anything else

00:19:24,210 --> 00:19:28,620
not some type of animal and a mammal

00:19:27,150 --> 00:19:30,450
might be an abstract class that inherits

00:19:28,620 --> 00:19:32,310
from an animal and when I say abstract I

00:19:30,450 --> 00:19:34,260
mean you can't really instantiate just a

00:19:32,310 --> 00:19:36,300
mammal it has to be a type of mammal and

00:19:34,260 --> 00:19:37,890
a dog is a class that inherits from

00:19:36,300 --> 00:19:40,550
mammal and sandy is an object of

00:19:37,890 --> 00:19:43,820
instantiation of the dog class

00:19:40,550 --> 00:19:47,780
so why do we use classes and objects any

00:19:43,820 --> 00:19:50,300
thoughts we've been talking about a

00:19:47,780 --> 00:19:54,320
little bit so to encrypt encapsulate

00:19:50,300 --> 00:19:55,970
complexity and by encapsulating

00:19:54,320 --> 00:19:59,150
complexity we carry around data and

00:19:55,970 --> 00:20:00,950
characteristics and capabilities state

00:19:59,150 --> 00:20:02,930
which beat which will be data and

00:20:00,950 --> 00:20:05,120
attributes behavior are bundled together

00:20:02,930 --> 00:20:08,630
and this scales well into larger

00:20:05,120 --> 00:20:10,640
applications by taking small units of

00:20:08,630 --> 00:20:13,130
encapsulation we can make larger greater

00:20:10,640 --> 00:20:15,910
things without having to think about all

00:20:13,130 --> 00:20:18,290
the small details

00:20:15,910 --> 00:20:20,450
objects and classes facilitate code

00:20:18,290 --> 00:20:22,280
reuse when we inherit when when when

00:20:20,450 --> 00:20:23,780
sandy inherits the characteristics of

00:20:22,280 --> 00:20:25,610
dogs and dogs inherit the

00:20:23,780 --> 00:20:27,200
characteristics of mammals we don't have

00:20:25,610 --> 00:20:30,470
to create mammals and mammals and

00:20:27,200 --> 00:20:33,350
animals every time we create a dog and

00:20:30,470 --> 00:20:36,170
also we have less pollution of our heads

00:20:33,350 --> 00:20:39,020
less cognitive load then bear functions

00:20:36,170 --> 00:20:40,610
and data structures would be in the sea

00:20:39,020 --> 00:20:42,320
world before we really were thinking in

00:20:40,610 --> 00:20:44,390
terms of objects you'd have all this

00:20:42,320 --> 00:20:46,580
data and all these methods and and

00:20:44,390 --> 00:20:48,530
functions and subroutines that could be

00:20:46,580 --> 00:20:49,670
called on our data and it was always a

00:20:48,530 --> 00:20:51,500
big mess trying to keep track of

00:20:49,670 --> 00:20:53,180
everything unless you were clever and

00:20:51,500 --> 00:20:54,890
started passing around handles to

00:20:53,180 --> 00:21:00,710
represent objects or pointers represent

00:20:54,890 --> 00:21:03,650
objects so we want to have less less

00:21:00,710 --> 00:21:07,160
pollution less less cognitive load

00:21:03,650 --> 00:21:11,360
so let's look now at pearls raw object

00:21:07,160 --> 00:21:14,060
system and I have to warn you because

00:21:11,360 --> 00:21:16,520
pearls are pearls raw object system is

00:21:14,060 --> 00:21:18,740
minimal it's highly flexible it's led to

00:21:16,520 --> 00:21:21,950
many modern layers which we like to use

00:21:18,740 --> 00:21:24,350
nowadays instead of pearls traditional

00:21:21,950 --> 00:21:25,850
object system and so brace yourselves

00:21:24,350 --> 00:21:27,830
for the next slide unless you're already

00:21:25,850 --> 00:21:31,250
with me 100% of the way which everybody

00:21:27,830 --> 00:21:33,200
in here probably is but here is a pearls

00:21:31,250 --> 00:21:35,120
object system and pros object system you

00:21:33,200 --> 00:21:37,280
have to take it and create a constructor

00:21:35,120 --> 00:21:40,550
and new is not any special in any way

00:21:37,280 --> 00:21:43,580
other than just by convention in a pack

00:21:40,550 --> 00:21:46,190
in a class like dbi we would use connect

00:21:43,580 --> 00:21:49,970
instead of new and then we essentially

00:21:46,190 --> 00:21:51,090
bless a class which is just a name or

00:21:49,970 --> 00:21:57,060
bless a

00:21:51,090 --> 00:21:59,220
a hash ref into a class right and then

00:21:57,060 --> 00:22:00,810
we have methods that we can call on it

00:21:59,220 --> 00:22:02,910
and so we can say integer new with a

00:22:00,810 --> 00:22:04,920
value of 128 and we can print that value

00:22:02,910 --> 00:22:06,900
so that's pearls object system in a

00:22:04,920 --> 00:22:10,050
nutshell now let's look at it using

00:22:06,900 --> 00:22:11,670
moose with moose we don't have to worry

00:22:10,050 --> 00:22:12,860
about creating a constructor that comes

00:22:11,670 --> 00:22:16,140
to us for free

00:22:12,860 --> 00:22:18,210
moose is available on Sipan and there

00:22:16,140 --> 00:22:20,340
are other versions similar to moose like

00:22:18,210 --> 00:22:22,200
Moo which I happen to also like in use

00:22:20,340 --> 00:22:24,420
and with moose we're going to say has

00:22:22,200 --> 00:22:26,460
value we're gonna for our package

00:22:24,420 --> 00:22:28,830
integer has value our value is read-only

00:22:26,460 --> 00:22:31,020
when we instantiate our integer right

00:22:28,830 --> 00:22:33,240
here we're gonna say integer new pass a

00:22:31,020 --> 00:22:35,190
value of 128 and if we want to get that

00:22:33,240 --> 00:22:38,160
value back we can ask for it and it'll

00:22:35,190 --> 00:22:40,050
print 128 for us there so to the

00:22:38,160 --> 00:22:44,640
end-user there's no difference between

00:22:40,050 --> 00:22:46,590
ammu class and a typical I was about you

00:22:44,640 --> 00:22:47,760
know I was at open west and I had my

00:22:46,590 --> 00:22:49,230
laser pointer I was using it for the

00:22:47,760 --> 00:22:50,280
first time any time somebody raised

00:22:49,230 --> 00:22:51,930
their hand I would blind him with the

00:22:50,280 --> 00:23:00,240
laser so I have to remind myself not to

00:22:51,930 --> 00:23:02,510
do that yes that is enforced in as much

00:23:00,240 --> 00:23:05,420
as if I were to pass a value in

00:23:02,510 --> 00:23:10,200
parenthesis to my value to my value

00:23:05,420 --> 00:23:11,910
method there right over here we would we

00:23:10,200 --> 00:23:14,490
would have an error it wouldn't it

00:23:11,910 --> 00:23:16,550
wouldn't do it wouldn't change the value

00:23:14,490 --> 00:23:19,980
so yeah for moose that is read that is

00:23:16,550 --> 00:23:22,530
enforced yeah any other questions I

00:23:19,980 --> 00:23:28,860
promise not to blind anybody if I

00:23:22,530 --> 00:23:30,510
remember not to okay so the the benefit

00:23:28,860 --> 00:23:31,980
to moose really is that the people who

00:23:30,510 --> 00:23:33,540
use the moose based solution get to go

00:23:31,980 --> 00:23:36,690
home at 5:30 and those of us that are

00:23:33,540 --> 00:23:38,880
unfortunate enough to be writing legacy

00:23:36,690 --> 00:23:40,350
style Perl objects or you know going

00:23:38,880 --> 00:23:44,850
home at 9:30 at night instead because

00:23:40,350 --> 00:23:47,250
it's more work to do all that so you can

00:23:44,850 --> 00:23:49,410
see we get essentially all of this and a

00:23:47,250 --> 00:23:51,810
lot more when we just do this little bit

00:23:49,410 --> 00:23:55,250
using moose so examples today are for

00:23:51,810 --> 00:23:55,250
the most part going to be in moose

00:23:57,750 --> 00:24:03,000
we can create behaviors as well so not

00:24:00,660 --> 00:24:04,890
everything has to be an attribute you

00:24:03,000 --> 00:24:08,100
can also have behaviors and our behavior

00:24:04,890 --> 00:24:10,440
here is going to be speak and so we have

00:24:08,100 --> 00:24:13,260
an attribute vocalization vocalization

00:24:10,440 --> 00:24:15,930
is going to contain a string and our

00:24:13,260 --> 00:24:18,660
string will just be hello world and our

00:24:15,930 --> 00:24:20,280
are at our our behavior is going to be

00:24:18,660 --> 00:24:25,820
speaking and speaking is just going to

00:24:20,280 --> 00:24:25,820
be printing our vocalization very simple

00:24:25,880 --> 00:24:30,930
so animals they can speak in by some

00:24:29,520 --> 00:24:33,060
definitions of speak and they have

00:24:30,930 --> 00:24:34,590
dietary preferences and they have blood

00:24:33,060 --> 00:24:36,240
type whether it's warm or cold and that

00:24:34,590 --> 00:24:37,980
sort of thing and so an animal based

00:24:36,240 --> 00:24:40,350
class might look at this might look like

00:24:37,980 --> 00:24:43,770
this packaged animal use moose has a

00:24:40,350 --> 00:24:46,980
diet which could be carnivorous or

00:24:43,770 --> 00:24:49,230
omnivorous has a blood type which could

00:24:46,980 --> 00:24:51,930
be mammal or reptilian cold or warm

00:24:49,230 --> 00:24:54,990
something like that has vocalization has

00:24:51,930 --> 00:24:58,950
a date of birth by some definitions of

00:24:54,990 --> 00:25:00,450
birth I guess right has a name and then

00:24:58,950 --> 00:25:04,080
will say it has a behavior which can

00:25:00,450 --> 00:25:06,120
speak and the behavior is to is to is to

00:25:04,080 --> 00:25:09,510
say its vocalization whatever that might

00:25:06,120 --> 00:25:12,500
be and an animal that might be able to

00:25:09,510 --> 00:25:15,990
in some way present happily however a

00:25:12,500 --> 00:25:18,270
basic simple basic animal has no concept

00:25:15,990 --> 00:25:20,340
of what presenting happily might be and

00:25:18,270 --> 00:25:21,990
so we're going to say that if somebody

00:25:20,340 --> 00:25:24,240
tries to instantiate an animal based

00:25:21,990 --> 00:25:25,530
class and they call present happily

00:25:24,240 --> 00:25:28,140
we're going to just go ahead and die

00:25:25,530 --> 00:25:31,590
because nobody's told us how a general

00:25:28,140 --> 00:25:33,810
animal presents happily not animals not

00:25:31,590 --> 00:25:35,610
all animals wag their tail or smile

00:25:33,810 --> 00:25:39,030
I don't know how sea anenome is present

00:25:35,610 --> 00:25:41,280
happily for example so let's move on

00:25:39,030 --> 00:25:42,600
from this for a little bit so a dog is a

00:25:41,280 --> 00:25:44,640
warm-blooded type of animal that

00:25:42,600 --> 00:25:46,980
vocalizes with a bark and is omnivorous

00:25:44,640 --> 00:25:49,020
and presents happily by wagging its tail

00:25:46,980 --> 00:25:52,170
and so let's go ahead and create that

00:25:49,020 --> 00:25:54,750
we're gonna say that our dog has a blood

00:25:52,170 --> 00:25:59,010
type of warm and now we are overriding

00:25:54,750 --> 00:26:00,870
the blood type right here by presenting

00:25:59,010 --> 00:26:04,380
by providing our own blood type in our

00:26:00,870 --> 00:26:05,880
as we extend the animal based class we

00:26:04,380 --> 00:26:07,710
also going to override our diet and

00:26:05,880 --> 00:26:10,230
override our vocalization and we're

00:26:07,710 --> 00:26:11,520
going to provide a wagtail method and

00:26:10,230 --> 00:26:13,620
the wagtail met

00:26:11,520 --> 00:26:16,110
that is going to be called by our

00:26:13,620 --> 00:26:18,120
presents happily so now we have a way of

00:26:16,110 --> 00:26:19,860
presenting happily and we have a

00:26:18,120 --> 00:26:23,280
generalized way of presenting happily

00:26:19,860 --> 00:26:26,150
that hopefully all animals can define

00:26:23,280 --> 00:26:29,640
their own version of presenting happily

00:26:26,150 --> 00:26:33,630
so we're using inheritance and we are

00:26:29,640 --> 00:26:35,190
overriding our base class with a present

00:26:33,630 --> 00:26:39,030
happily that calls out to our own

00:26:35,190 --> 00:26:42,270
internal version of happy of happy

00:26:39,030 --> 00:26:45,150
moments so if we're going to wheel to

00:26:42,270 --> 00:26:48,660
have a happy sandy object we're going to

00:26:45,150 --> 00:26:50,910
instantiate our dog sandy date of birth

00:26:48,660 --> 00:26:52,530
2003 this is why I said sandy oh that's

00:26:50,910 --> 00:26:55,980
why I've occasionally used her name in

00:26:52,530 --> 00:26:58,350
past tense she wagged her tail she

00:26:55,980 --> 00:27:00,300
speaks she barks bark is the same as

00:26:58,350 --> 00:27:02,100
speaking except that we like to use

00:27:00,300 --> 00:27:04,560
speak because we can apply speak across

00:27:02,100 --> 00:27:07,770
all types of animals whereas bark would

00:27:04,560 --> 00:27:09,630
be specific only to dogs and we'll get

00:27:07,770 --> 00:27:11,580
to that again in a minute she has a name

00:27:09,630 --> 00:27:12,870
and she can present happily by wagging

00:27:11,580 --> 00:27:14,910
her tail so we're not going to really

00:27:12,870 --> 00:27:16,290
call wagtail too much we're gonna say

00:27:14,910 --> 00:27:19,560
present happily because that's a more

00:27:16,290 --> 00:27:23,310
generalized approach to discussing how

00:27:19,560 --> 00:27:25,830
animals behave we can we can request her

00:27:23,310 --> 00:27:28,500
name we can request we can say that she

00:27:25,830 --> 00:27:31,440
eats like an omnivore like a Carnot

00:27:28,500 --> 00:27:33,150
carnivore and that she vocalizes by

00:27:31,440 --> 00:27:36,750
saying bow-wow or whatever is that we

00:27:33,150 --> 00:27:42,750
said that she does and that she is a ref

00:27:36,750 --> 00:27:45,180
pet which would be a dog so we can

00:27:42,750 --> 00:27:47,250
simplify inheritance a little bit we can

00:27:45,180 --> 00:27:49,860
say packaged food use mousse has value

00:27:47,250 --> 00:27:53,660
it the value is read-only and we can say

00:27:49,860 --> 00:27:56,610
food printable which extends foo and

00:27:53,660 --> 00:27:58,260
printable has a word and it has an

00:27:56,610 --> 00:28:00,180
output and the output can output our

00:27:58,260 --> 00:28:02,340
word and it can output our value and so

00:28:00,180 --> 00:28:06,000
here we're extending the foo based class

00:28:02,340 --> 00:28:07,350
by using by adding some behavior and

00:28:06,000 --> 00:28:09,720
this is one of the fundamental

00:28:07,350 --> 00:28:11,550
fundamental concepts of inheritance is

00:28:09,720 --> 00:28:13,010
that we are able to extend our base

00:28:11,550 --> 00:28:15,860
classes and provide additional

00:28:13,010 --> 00:28:19,590
functionality and provide additional

00:28:15,860 --> 00:28:21,300
state let's talk for a moment about

00:28:19,590 --> 00:28:23,490
roles because once we start going down

00:28:21,300 --> 00:28:25,260
the path of extending by providing

00:28:23,490 --> 00:28:27,240
additional features

00:28:25,260 --> 00:28:29,700
might want to be talking about roles in

00:28:27,240 --> 00:28:32,400
inheritance we say that inheritance

00:28:29,700 --> 00:28:33,960
represents an is a relationship and it

00:28:32,400 --> 00:28:36,060
is a relationship it's really to say

00:28:33,960 --> 00:28:38,160
easy to say that a dog is an animal and

00:28:36,060 --> 00:28:40,170
that if all animals can present happily

00:28:38,160 --> 00:28:41,910
dogs present happily by wagging their

00:28:40,170 --> 00:28:43,500
tails but we can call the present

00:28:41,910 --> 00:28:45,780
happily method if we're going to add

00:28:43,500 --> 00:28:51,480
additional behavior we want to usually

00:28:45,780 --> 00:28:53,330
use a does relationship dogs do go out

00:28:51,480 --> 00:28:57,390
in the yard and dig holes in the lung

00:28:53,330 --> 00:28:58,950
for example and so we might have a do go

00:28:57,390 --> 00:29:00,480
out we might have a roll go out in the

00:28:58,950 --> 00:29:05,160
yard and dig holes in the lawn all right

00:29:00,480 --> 00:29:07,080
so let's look at an animal role we're

00:29:05,160 --> 00:29:08,340
gonna say that we're gonna say use moose

00:29:07,080 --> 00:29:10,620
roll and we're gonna say that this

00:29:08,340 --> 00:29:12,330
requires diet and requires blood and

00:29:10,620 --> 00:29:14,490
requires vocalizations so our animal

00:29:12,330 --> 00:29:16,290
role requires that these attributes be

00:29:14,490 --> 00:29:19,260
implemented by the thing that implements

00:29:16,290 --> 00:29:21,570
the role by the by the thing that uses

00:29:19,260 --> 00:29:22,830
the role or consumes the role we're

00:29:21,570 --> 00:29:24,870
going to say that it has a date of birth

00:29:22,830 --> 00:29:27,120
and it has a name and that it has the

00:29:24,870 --> 00:29:30,570
behavior of speaking of vocalization and

00:29:27,120 --> 00:29:33,240
so to use the animal role we're going to

00:29:30,570 --> 00:29:34,800
create a package dog and the package dog

00:29:33,240 --> 00:29:37,260
is going to implement our blood type

00:29:34,800 --> 00:29:39,090
which was required it's going to

00:29:37,260 --> 00:29:41,760
implement our diet which was required

00:29:39,090 --> 00:29:43,380
right here so I guess it wasn't that and

00:29:41,760 --> 00:29:46,680
it's going to implement our vocalization

00:29:43,380 --> 00:29:48,840
and it's going to implement some of the

00:29:46,680 --> 00:29:50,640
behaviors that are specific to a dog and

00:29:48,840 --> 00:29:54,090
it's going to do that with the animal

00:29:50,640 --> 00:29:59,430
based class or with the animal role

00:29:54,090 --> 00:30:00,990
sorry so my dog sandy with an animal

00:29:59,430 --> 00:30:02,400
role we're going to instantiate sandy

00:30:00,990 --> 00:30:04,290
and she works pretty much exactly the

00:30:02,400 --> 00:30:06,120
same way as through inheritance but

00:30:04,290 --> 00:30:08,580
conceptually to somebody who's extending

00:30:06,120 --> 00:30:10,440
and working with the animal it's much

00:30:08,580 --> 00:30:13,470
easier in many cases when you're adding

00:30:10,440 --> 00:30:14,940
behavior to look at roles so roles

00:30:13,470 --> 00:30:16,800
versus inheritance not everything we

00:30:14,940 --> 00:30:20,520
model fits in a simple pattern of this

00:30:16,800 --> 00:30:23,250
is a that many things fit that this does

00:30:20,520 --> 00:30:27,330
that or this has that attribute as

00:30:23,250 --> 00:30:29,310
opposed to this inherits from so if you

00:30:27,330 --> 00:30:31,410
look at me for example I inherit from

00:30:29,310 --> 00:30:33,780
humans but I also inherit from programs

00:30:31,410 --> 00:30:35,520
programmers and I also inherit from my

00:30:33,780 --> 00:30:37,049
father and my mother and that gets to be

00:30:35,520 --> 00:30:39,059
kind of complicated I'm kind of calm

00:30:37,049 --> 00:30:43,019
flex but if you look in terms of roles

00:30:39,059 --> 00:30:46,230
instead I do human behavior sometimes I

00:30:43,019 --> 00:30:48,119
do programming I do fatherhood and

00:30:46,230 --> 00:30:51,149
that's conceptually simpler to reason

00:30:48,119 --> 00:30:55,590
about often and so we many times prefer

00:30:51,149 --> 00:30:58,619
using roles when the roles are more are

00:30:55,590 --> 00:31:00,029
not trivial or when they are when there

00:30:58,619 --> 00:31:01,649
are more than one role that needs to be

00:31:00,029 --> 00:31:04,739
composed into something rather than

00:31:01,649 --> 00:31:07,080
using multiple inheritance so let's go

00:31:04,739 --> 00:31:10,230
back to our dremel tool again because

00:31:07,080 --> 00:31:12,809
this is kind of a fun example for me the

00:31:10,230 --> 00:31:14,369
dremel tool does only one thing and the

00:31:12,809 --> 00:31:16,230
one thing it does it does very well it

00:31:14,369 --> 00:31:17,789
just spins a bit and it spins that bit

00:31:16,230 --> 00:31:21,210
superfast anywhere from I don't know

00:31:17,789 --> 00:31:24,600
3,500 rpms up to 35,000 rpms depending

00:31:21,210 --> 00:31:29,059
on what your what your what you set it

00:31:24,600 --> 00:31:31,710
to right there with its with its mutator

00:31:29,059 --> 00:31:33,259
but it accepts a whole bunch of bits and

00:31:31,710 --> 00:31:37,139
so here's where we get to talk about

00:31:33,259 --> 00:31:38,639
polymorphism and polymorphism two

00:31:37,139 --> 00:31:40,559
objects of different classes can be

00:31:38,639 --> 00:31:42,480
treated as though they're the same type

00:31:40,559 --> 00:31:44,970
of object if they provide a common

00:31:42,480 --> 00:31:49,559
interface and so in this little picture

00:31:44,970 --> 00:31:51,869
here what is my polymorphic thing the

00:31:49,559 --> 00:31:53,909
drill actually the bits are the poem

00:31:51,869 --> 00:31:57,389
Orphic thing because all of them have

00:31:53,909 --> 00:32:00,059
the same user interface right they all

00:31:57,389 --> 00:32:03,029
have the same little thing that plugs

00:32:00,059 --> 00:32:06,210
into my generalized tool of the dremel

00:32:03,029 --> 00:32:07,950
tool so two objects that inherit from a

00:32:06,210 --> 00:32:11,429
common ancestor typically share the

00:32:07,950 --> 00:32:14,249
features of that common ancestor so duck

00:32:11,429 --> 00:32:16,649
typing is a form of polymorphism and we

00:32:14,249 --> 00:32:18,090
use duck typing a lot in Perl if it can

00:32:16,649 --> 00:32:19,529
quack like a duck it's sufficiently duck

00:32:18,090 --> 00:32:22,379
like to be considered and treated as a

00:32:19,529 --> 00:32:24,090
duck so we're going to go back to

00:32:22,379 --> 00:32:25,799
animals again because I promised never

00:32:24,090 --> 00:32:28,019
to talk about animals in my talk and

00:32:25,799 --> 00:32:30,960
that's all I've been doing we're gonna

00:32:28,019 --> 00:32:34,080
say a cat uses moose because which is

00:32:30,960 --> 00:32:36,269
kind of ironic but anyway uh has has

00:32:34,080 --> 00:32:38,100
blood type and it has a diet has a

00:32:36,269 --> 00:32:40,470
vocalization and it's vocalization is

00:32:38,100 --> 00:32:41,669
represented by purring and so with

00:32:40,470 --> 00:32:45,269
animal we're going to consume the

00:32:41,669 --> 00:32:48,480
animals role now we're going to look dog

00:32:45,269 --> 00:32:51,710
Xand cats both have animal traits

00:32:48,480 --> 00:32:54,450
and so let's treat dogs and cats as

00:32:51,710 --> 00:32:56,910
polymorphisms of the same animal instant

00:32:54,450 --> 00:33:01,370
of the same animal base and so I can say

00:32:56,910 --> 00:33:05,460
dog new name sandy and date of birth mm

00:33:01,370 --> 00:33:07,020
SEO to 2002-2003 and I can say cat new

00:33:05,460 --> 00:33:08,370
name mojo and date of birth unknown

00:33:07,020 --> 00:33:13,530
because that was my neighbor's cat back

00:33:08,370 --> 00:33:15,030
in 2003 and so neighborhood pets we have

00:33:13,530 --> 00:33:17,130
a dog and we have a neighborhood and we

00:33:15,030 --> 00:33:19,590
have a neighbor cat and so now for each

00:33:17,130 --> 00:33:22,740
neighborhood pet we're going to print

00:33:19,590 --> 00:33:25,770
the name sandy and mojo and we're going

00:33:22,740 --> 00:33:27,750
to ask the pet to speak and the dog will

00:33:25,770 --> 00:33:30,240
bark and the cat will meow we're

00:33:27,750 --> 00:33:32,850
treating both both pets the exact same

00:33:30,240 --> 00:33:35,429
way we're treating both just by calling

00:33:32,850 --> 00:33:38,910
their what's your name what are you I'm

00:33:35,429 --> 00:33:41,309
a I'm a dog or I'm a cat and go ahead

00:33:38,910 --> 00:33:43,620
and speak to me and because we've used

00:33:41,309 --> 00:33:46,290
polymorphism we've been able to just

00:33:43,620 --> 00:33:47,610
abstract away the differences the

00:33:46,290 --> 00:33:49,860
difference is between these two animals

00:33:47,610 --> 00:33:51,990
and deal only with those common sets of

00:33:49,860 --> 00:33:54,630
features that we want to deal with that

00:33:51,990 --> 00:34:02,160
are simple that they share in common any

00:33:54,630 --> 00:34:06,900
questions thoughts yes so here to here

00:34:02,160 --> 00:34:11,490
in my cat class I would say that I would

00:34:06,900 --> 00:34:12,929
create a method a an attribute per and

00:34:11,490 --> 00:34:18,109
then I would create and then I would

00:34:12,929 --> 00:34:18,109
override speak to make speak be culper

00:34:18,889 --> 00:34:24,179
yeah I probably left something I would

00:34:21,419 --> 00:34:25,169
see so yeah I should be overwriting yeah

00:34:24,179 --> 00:34:27,230
you're right about that thank you I

00:34:25,169 --> 00:34:32,629
should be overriding speak here as well

00:34:27,230 --> 00:34:32,629
so thank you that makes sense

00:34:41,730 --> 00:34:49,570
right so my pet class should be defining

00:34:47,139 --> 00:34:53,280
speak to use the vocalization that we

00:34:49,570 --> 00:34:57,820
want it to be using that make sense yeah

00:34:53,280 --> 00:35:04,599
yeah probably ought to be speak right

00:34:57,820 --> 00:35:05,890
anyway so thanks thanks yeah so they

00:35:04,599 --> 00:35:08,020
both have animal traits we're treating

00:35:05,890 --> 00:35:10,510
them both exactly is the same thing

00:35:08,020 --> 00:35:12,250
they're both just pets and we can assume

00:35:10,510 --> 00:35:15,540
that pets have names and the pets have

00:35:12,250 --> 00:35:19,630
their manner of vocalization or speaking

00:35:15,540 --> 00:35:23,170
so polymorpha polymorphism through

00:35:19,630 --> 00:35:26,109
inheritance our package animal defines a

00:35:23,170 --> 00:35:28,390
sub speak as a basically in its base

00:35:26,109 --> 00:35:30,460
class but it's going to die if we were

00:35:28,390 --> 00:35:33,099
to call speak because animals in general

00:35:30,460 --> 00:35:36,010
don't have a general version of speaking

00:35:33,099 --> 00:35:38,020
within our in our dog class we're going

00:35:36,010 --> 00:35:43,300
to define us speak and in our cat class

00:35:38,020 --> 00:35:44,740
we're going to define a meow we can

00:35:43,300 --> 00:35:48,910
treat them both as the same once we've

00:35:44,740 --> 00:35:50,260
instantiated them so in use again here's

00:35:48,910 --> 00:35:52,869
another way we can use them we've got a

00:35:50,260 --> 00:35:54,490
dog okay we're going to name a dog a cat

00:35:52,869 --> 00:35:57,040
a dog and a cat and we're going to

00:35:54,490 --> 00:35:58,000
instantiate our dog and cat into animal

00:35:57,040 --> 00:36:02,530
and then we're going to speak

00:35:58,000 --> 00:36:04,270
for each animal so using and using

00:36:02,530 --> 00:36:07,050
polymorphism we're able to treat many

00:36:04,270 --> 00:36:09,760
objects as essentially equivalently

00:36:07,050 --> 00:36:11,830
duck-like enough to use them the same

00:36:09,760 --> 00:36:13,570
way and this turns out to be very useful

00:36:11,830 --> 00:36:15,640
in our business we have lots of

00:36:13,570 --> 00:36:17,440
different types of servers it's nice to

00:36:15,640 --> 00:36:19,450
just be able to say to ask the server

00:36:17,440 --> 00:36:21,070
what's your IP address for example and

00:36:19,450 --> 00:36:23,680
not have to worry about whether my

00:36:21,070 --> 00:36:25,180
server is a CentOS server or whether

00:36:23,680 --> 00:36:27,099
it's some other server we deal with that

00:36:25,180 --> 00:36:31,960
at a different layer of ins of

00:36:27,099 --> 00:36:33,160
abstraction so in the dremel tool we're

00:36:31,960 --> 00:36:35,230
going to do this we're going to

00:36:33,160 --> 00:36:37,630
instantiate our dremel tool and we're

00:36:35,230 --> 00:36:39,369
going to pass into it a bit field and

00:36:37,630 --> 00:36:41,380
this is not a bit filled in the comp in

00:36:39,369 --> 00:36:43,510
the computer's computer version this is

00:36:41,380 --> 00:36:46,730
what type of bit and our bit is going to

00:36:43,510 --> 00:36:50,150
be a dremel bit of sub class cutting

00:36:46,730 --> 00:36:54,140
the cutting bit has a diameter of 1

00:36:50,150 --> 00:36:55,849
centimeter reasonable enough and we're

00:36:54,140 --> 00:36:57,320
gonna set our dremel tool to a rotation

00:36:55,849 --> 00:36:59,210
speed of 8,000

00:36:57,320 --> 00:37:00,589
here's another dremel tool we're gonna

00:36:59,210 --> 00:37:02,329
new up another dremel tool this one has

00:37:00,589 --> 00:37:05,420
a dremel bit of sub type drilling and

00:37:02,329 --> 00:37:07,970
this one has a centimeter a diameter of

00:37:05,420 --> 00:37:10,460
0.05 and a depth of 0.3 and a rotation

00:37:07,970 --> 00:37:12,260
of speed of 4500 when we go to use these

00:37:10,460 --> 00:37:14,089
we both use them the same way we hold

00:37:12,260 --> 00:37:15,890
the tool in our left or right hand

00:37:14,089 --> 00:37:17,869
depending on which version of

00:37:15,890 --> 00:37:20,570
abstraction which version of human we

00:37:17,869 --> 00:37:22,040
are and we're going to spin it at the

00:37:20,570 --> 00:37:24,079
speed that it was started up at there

00:37:22,040 --> 00:37:26,270
are 4,500 or 8,000 and we're going to

00:37:24,079 --> 00:37:29,990
use the tool they both work the same way

00:37:26,270 --> 00:37:31,670
just and and it's the same exact tool

00:37:29,990 --> 00:37:34,550
that's being passed in different

00:37:31,670 --> 00:37:39,020
subclasses of the bit so the bit is the

00:37:34,550 --> 00:37:42,859
polymorphic piece here so here's our

00:37:39,020 --> 00:37:44,950
dremel class which is read writable

00:37:42,859 --> 00:37:47,660
because we can change bits and it is a

00:37:44,950 --> 00:37:49,849
dremel we're going to make sure that

00:37:47,660 --> 00:37:51,680
it's getting passed in a dremel bit of

00:37:49,849 --> 00:37:54,310
some sort we're gonna ask that the thing

00:37:51,680 --> 00:37:56,420
that's being passed in to our bit is

00:37:54,310 --> 00:37:57,349
there's a dremel bit and we're gonna

00:37:56,420 --> 00:38:00,680
have to be able to set the rotation

00:37:57,349 --> 00:38:02,589
speed and so a dremel tool accepts a bit

00:38:00,680 --> 00:38:04,790
bit types inherit from Dremel bit

00:38:02,589 --> 00:38:07,099
subclasses include cutting polishing

00:38:04,790 --> 00:38:08,630
grinding and drilling bit attributes

00:38:07,099 --> 00:38:10,910
could include thickness death depth

00:38:08,630 --> 00:38:12,740
rough roughness etc but the single

00:38:10,910 --> 00:38:14,990
dremel tool doesn't care what tip it's

00:38:12,740 --> 00:38:17,180
been given so long as the tip is it has

00:38:14,990 --> 00:38:20,240
the expected attributes and behaviors

00:38:17,180 --> 00:38:22,369
the attributes being it has the piece

00:38:20,240 --> 00:38:28,730
that can be inserted correctly right and

00:38:22,369 --> 00:38:30,980
it can spin so polymorphism is the is

00:38:28,730 --> 00:38:33,800
the provision of a single interface to

00:38:30,980 --> 00:38:35,930
entities of different types the

00:38:33,800 --> 00:38:37,550
polymorphic type is one whose operations

00:38:35,930 --> 00:38:38,150
can be also applied to objects of some

00:38:37,550 --> 00:38:40,790
other time

00:38:38,150 --> 00:38:42,940
just another example we have an array

00:38:40,790 --> 00:38:47,270
we're gonna create an array that

00:38:42,940 --> 00:38:48,980
contains a b and c we're gonna cane or

00:38:47,270 --> 00:38:52,579
we're gonna create an 8 a linked list

00:38:48,980 --> 00:38:56,180
that contains a b or c both of those can

00:38:52,579 --> 00:38:57,890
implement a push back both the array and

00:38:56,180 --> 00:38:59,150
the list can implement a push back in

00:38:57,890 --> 00:39:00,200
other words you can add something to the

00:38:59,150 --> 00:39:01,880
end of a linked list

00:39:00,200 --> 00:39:05,530
and you can add something to the end of

00:39:01,880 --> 00:39:09,020
a Perl array for example or a C++ vector

00:39:05,530 --> 00:39:11,060
both of them can implement an at the

00:39:09,020 --> 00:39:12,200
implementation of at for an array is

00:39:11,060 --> 00:39:14,329
much more efficient than the

00:39:12,200 --> 00:39:16,010
implementation of at for a list because

00:39:14,329 --> 00:39:18,200
the list needs to start the beginning

00:39:16,010 --> 00:39:20,210
and work its way through but we can

00:39:18,200 --> 00:39:22,910
essentially treat them both the same way

00:39:20,210 --> 00:39:27,170
they're both they're polymorphic types

00:39:22,910 --> 00:39:31,790
essentially and we see this a lot in C++

00:39:27,170 --> 00:39:33,740
with the container classes so polymorph

00:39:31,790 --> 00:39:37,190
in poly morphism is a means towards

00:39:33,740 --> 00:39:39,890
toward generalization and the dremel

00:39:37,190 --> 00:39:42,980
tool was my example of it generalized

00:39:39,890 --> 00:39:46,880
tool encapsulation is a bundling of

00:39:42,980 --> 00:39:48,920
behavior and state an abstraction is the

00:39:46,880 --> 00:39:50,930
elimination of complexity for the

00:39:48,920 --> 00:39:54,050
consumer for me for the people using our

00:39:50,930 --> 00:39:55,640
classes by encapsulating detail and

00:39:54,050 --> 00:39:59,869
exposing an interface that should wipe

00:39:55,640 --> 00:40:01,400
away cognitive load this can run this

00:39:59,869 --> 00:40:02,839
can get us into trouble and we'll talk

00:40:01,400 --> 00:40:05,660
about that in a moment here two

00:40:02,839 --> 00:40:07,369
inheritance is to specialize a more

00:40:05,660 --> 00:40:09,770
general type by encapsulating more

00:40:07,369 --> 00:40:11,690
specific attributes and behaviors and to

00:40:09,770 --> 00:40:14,089
factor out common behaviors and

00:40:11,690 --> 00:40:17,270
attributes into parents that children

00:40:14,089 --> 00:40:19,190
may inherit from and poly Hort

00:40:17,270 --> 00:40:21,410
polymorphism is leveraging a common

00:40:19,190 --> 00:40:23,119
interface or common portions of an

00:40:21,410 --> 00:40:24,859
interface so that surrounding code

00:40:23,119 --> 00:40:27,020
doesn't have to care about what specific

00:40:24,859 --> 00:40:29,930
types are being implemented in my world

00:40:27,020 --> 00:40:32,810
if I ever have to say if server type

00:40:29,930 --> 00:40:35,030
equals CentOS for example or a server

00:40:32,810 --> 00:40:36,619
type equals shared then I have code

00:40:35,030 --> 00:40:39,680
smell because that should be

00:40:36,619 --> 00:40:43,460
encapsulated into my server classes or

00:40:39,680 --> 00:40:44,869
my server subclasses for example so we

00:40:43,460 --> 00:40:46,220
we mentioned this quote earlier all

00:40:44,869 --> 00:40:47,450
problems in computer science can be

00:40:46,220 --> 00:40:50,569
solved by another level of indirection

00:40:47,450 --> 00:40:52,160
or abstraction but there's a follow up

00:40:50,569 --> 00:40:53,150
to that which is the except for the

00:40:52,160 --> 00:40:55,310
problem of too many layers of

00:40:53,150 --> 00:40:56,900
indirection or abstraction has anybody

00:40:55,310 --> 00:40:59,780
ever here used Microsoft foundation

00:40:56,900 --> 00:41:02,270
classes and I think yes a few people

00:40:59,780 --> 00:41:04,579
have too many layers of indirection and

00:41:02,270 --> 00:41:06,079
abstraction you have no idea where

00:41:04,579 --> 00:41:08,089
you're inheriting this little portion of

00:41:06,079 --> 00:41:09,710
your widget from where that attribute

00:41:08,089 --> 00:41:11,990
came from so if you ever looking in

00:41:09,710 --> 00:41:13,849
documentation for what you need for how

00:41:11,990 --> 00:41:15,979
you need to wield this little part this

00:41:13,849 --> 00:41:17,390
attribute that you or this little thing

00:41:15,979 --> 00:41:19,249
that you've inherited you might find

00:41:17,390 --> 00:41:20,779
yourself looking back six layers and

00:41:19,249 --> 00:41:23,059
having to branch out through different

00:41:20,779 --> 00:41:24,920
layers of of multiple inheritance as

00:41:23,059 --> 00:41:26,479
well and so you can really get yourself

00:41:24,920 --> 00:41:29,239
into trouble with too many layers of

00:41:26,479 --> 00:41:30,619
indirection and abstraction and I'll get

00:41:29,239 --> 00:41:32,930
to that again in just a moment deep

00:41:30,619 --> 00:41:34,819
inheritance with layered on attributes

00:41:32,930 --> 00:41:37,699
and layered on behaviors requires the

00:41:34,819 --> 00:41:40,219
consumer to know too much about our

00:41:37,699 --> 00:41:42,140
class and we see this unfortunately I

00:41:40,219 --> 00:41:43,489
think anybody with a legacy codebase

00:41:42,140 --> 00:41:45,349
sees this throughout their codebase

00:41:43,489 --> 00:41:46,880
where one little thing gets layered on

00:41:45,349 --> 00:41:48,559
here and one little thing gets layered

00:41:46,880 --> 00:41:51,469
on there and pretty soon you have this

00:41:48,559 --> 00:41:53,690
big just ball of mud that is a god

00:41:51,469 --> 00:41:55,910
object that carries around all kinds of

00:41:53,690 --> 00:41:57,469
state and all kinds of attributes and

00:41:55,910 --> 00:41:58,969
and this one might be a little bit

00:41:57,469 --> 00:42:00,949
different from that one in some ways and

00:41:58,969 --> 00:42:02,989
suddenly we have if server type equals

00:42:00,949 --> 00:42:04,279
this and if that equals that and you and

00:42:02,989 --> 00:42:06,170
you get code smell and you get

00:42:04,279 --> 00:42:08,059
complexity and it becomes very hard to

00:42:06,170 --> 00:42:11,479
manipulate that type of a code base so

00:42:08,059 --> 00:42:13,219
god objects carry around vast amounts of

00:42:11,479 --> 00:42:14,509
state vast numbers of features they

00:42:13,219 --> 00:42:17,569
don't do just one thing and one thing

00:42:14,509 --> 00:42:19,549
well they do lots of things they inherit

00:42:17,569 --> 00:42:21,589
from many parent classes they have many

00:42:19,549 --> 00:42:24,949
complex and possibly changing attributes

00:42:21,589 --> 00:42:26,690
and this to me was kind of epitomized

00:42:24,949 --> 00:42:28,309
into Microsoft foundation classes and I

00:42:26,690 --> 00:42:30,140
you know let's not use the word

00:42:28,309 --> 00:42:33,380
Microsoft let's just say foundation

00:42:30,140 --> 00:42:35,209
classes of a legacy code base right

00:42:33,380 --> 00:42:36,739
because our code base and many other Co

00:42:35,209 --> 00:42:41,779
vases are guilty of the same types of

00:42:36,739 --> 00:42:45,289
things so we should strive to limit

00:42:41,779 --> 00:42:47,089
layered in state and favor composing in

00:42:45,289 --> 00:42:49,999
roles rather than inheriting from multi

00:42:47,089 --> 00:42:52,400
for many layers of multiple parents and

00:42:49,999 --> 00:42:54,799
we should be wary of inheritance of

00:42:52,400 --> 00:42:56,839
thick classes with lots of state and

00:42:54,799 --> 00:42:59,180
lots of behavior just when we need to

00:42:56,839 --> 00:43:02,869
obtain small s small aspects of state

00:42:59,180 --> 00:43:04,640
and behavior we should do our best at

00:43:02,869 --> 00:43:07,069
any point in time as we're dealing with

00:43:04,640 --> 00:43:10,069
complicated classes to try to simplify

00:43:07,069 --> 00:43:14,569
the interface that are consumers of our

00:43:10,069 --> 00:43:16,219
classes are using because any situation

00:43:14,569 --> 00:43:19,309
where you're having to say if the type

00:43:16,219 --> 00:43:21,140
is this or if or where you have to dig

00:43:19,309 --> 00:43:23,089
through multiple layers in documentation

00:43:21,140 --> 00:43:25,430
to find where an attribute comes from

00:43:23,089 --> 00:43:27,410
that's code smell and that's in elegant

00:43:25,430 --> 00:43:29,650
creation of abstractions

00:43:27,410 --> 00:43:32,030
you know a pearl hash is such an elegant

00:43:29,650 --> 00:43:34,430
abstraction but there are so many in

00:43:32,030 --> 00:43:37,700
elegant abstractions that we see in our

00:43:34,430 --> 00:43:39,470
in our daily work lives so we should

00:43:37,700 --> 00:43:41,390
strive to keep our classes simple and to

00:43:39,470 --> 00:43:43,280
keep our attributes minimal to keep our

00:43:41,390 --> 00:43:45,799
state changes minimal make our objects

00:43:43,280 --> 00:43:47,930
as immutable as possible keep your

00:43:45,799 --> 00:43:49,430
behaviors predictable keep our layers

00:43:47,930 --> 00:43:52,220
simple and carefully planner

00:43:49,430 --> 00:43:55,190
abstractions easily said hard to do

00:43:52,220 --> 00:43:58,369
right thank you

00:43:55,190 --> 00:44:00,020
there's there are there are design

00:43:58,369 --> 00:44:01,789
patterns and guidelines that we can do

00:44:00,020 --> 00:44:02,900
research on and I encourage people at

00:44:01,789 --> 00:44:05,180
the end of the talk we'll provide some

00:44:02,900 --> 00:44:07,420
resources for further discussion and

00:44:05,180 --> 00:44:09,920
learning but we should always be

00:44:07,420 --> 00:44:12,559
considering the notion of single purpose

00:44:09,920 --> 00:44:14,990
and single responsibility when we create

00:44:12,559 --> 00:44:17,950
classes and instantiate objects of those

00:44:14,990 --> 00:44:20,930
classes and we should always opt for

00:44:17,950 --> 00:44:23,119
classes being open to extension but

00:44:20,930 --> 00:44:26,119
closed for modification so easy to

00:44:23,119 --> 00:44:30,859
subclass or easy to compose with but

00:44:26,119 --> 00:44:32,390
hard but closed to actually modifying by

00:44:30,859 --> 00:44:34,220
adding additional attributes or you end

00:44:32,390 --> 00:44:36,020
up getting just these big oh I need to

00:44:34,220 --> 00:44:39,260
add a feature and so you start adding a

00:44:36,020 --> 00:44:40,369
feature in just the most the the easiest

00:44:39,260 --> 00:44:41,960
place to get it done in turning your

00:44:40,369 --> 00:44:45,140
sprint but maybe not the easiest place

00:44:41,960 --> 00:44:48,170
to maintain six months down the road or

00:44:45,140 --> 00:44:50,270
six years down the road so the resources

00:44:48,170 --> 00:44:52,160
that I wanted to point out you can

00:44:50,270 --> 00:44:54,220
actually learn a lot from per lobs which

00:44:52,160 --> 00:44:56,539
is in the Perl documentation

00:44:54,220 --> 00:44:58,250
intermediate Perl I really like this

00:44:56,539 --> 00:45:01,160
book I first got that book back when it

00:44:58,250 --> 00:45:03,079
was called Perl objects references and

00:45:01,160 --> 00:45:04,910
something else yeah the first version

00:45:03,079 --> 00:45:07,450
and it's and it's changed a little as

00:45:04,910 --> 00:45:10,099
it's gone into more recent versions

00:45:07,450 --> 00:45:12,490
intermediate Perl is a great book modern

00:45:10,099 --> 00:45:15,589
Perl from chromatic is also fantastic

00:45:12,490 --> 00:45:19,789
for going through the dog and cat

00:45:15,589 --> 00:45:21,619
discussions but also looking at at the

00:45:19,789 --> 00:45:24,980
Moose way of doing things the Moo way of

00:45:21,619 --> 00:45:26,510
doing things look up solid on Wikipedia

00:45:24,980 --> 00:45:29,589
and then read some of the references

00:45:26,510 --> 00:45:34,299
that that leads to you single purpose

00:45:29,589 --> 00:45:37,220
open to open to sub classing essentially

00:45:34,299 --> 00:45:39,020
with scoff substitution and so on anyway

00:45:37,220 --> 00:45:40,420
that's a great resource to look at and

00:45:39,020 --> 00:45:42,700
do some study on

00:45:40,420 --> 00:45:44,380
and then also eventually you're going to

00:45:42,700 --> 00:45:45,809
want to look at this book design

00:45:44,380 --> 00:45:48,609
patterns elements of reusable

00:45:45,809 --> 00:45:51,160
object-oriented software that's a book

00:45:48,609 --> 00:45:54,059
that really discusses in depth pearl or

00:45:51,160 --> 00:45:56,680
I'm sorry object design patterns now

00:45:54,059 --> 00:45:57,999
pearl provides a lot of the design

00:45:56,680 --> 00:46:01,210
patterns to us for free

00:45:57,999 --> 00:46:03,489
but it's really worthwhile to get to

00:46:01,210 --> 00:46:04,869
know what the design patterns are and to

00:46:03,489 --> 00:46:06,789
learn what they are so that we can know

00:46:04,869 --> 00:46:09,220
so we can recognize them as we're using

00:46:06,789 --> 00:46:11,710
them recognize code that uses them and

00:46:09,220 --> 00:46:12,670
start creating code that that leverages

00:46:11,710 --> 00:46:15,339
them to our advantage

00:46:12,670 --> 00:46:18,579
in creating nice abstractions and nice

00:46:15,339 --> 00:46:19,900
encapsulate encapsulations so anything

00:46:18,579 --> 00:46:24,960
anyway that's everything I have prepared

00:46:19,900 --> 00:46:24,960
for today are there any questions yes

00:46:25,380 --> 00:46:41,440
[Music]

00:46:26,519 --> 00:46:44,440
yeah so class a class is just a string

00:46:41,440 --> 00:46:48,039
essentially and the string could have

00:46:44,440 --> 00:46:50,140
been for example class : : I mean foo :

00:46:48,039 --> 00:46:52,150
: bar but you still would use the arrow

00:46:50,140 --> 00:46:53,650
operator when you call your constructor

00:46:52,150 --> 00:46:55,180
because the arrow operator makes it so

00:46:53,650 --> 00:46:57,460
that the thing on the left hand side

00:46:55,180 --> 00:46:59,829
that string gets passed in as the first

00:46:57,460 --> 00:47:03,099
argument to your constructor the first

00:46:59,829 --> 00:47:05,619
argument would be is expected by

00:47:03,099 --> 00:47:07,299
convention to be the class name and so

00:47:05,619 --> 00:47:10,930
when you instantiate your object and

00:47:07,299 --> 00:47:13,119
call an internally a bles is called the

00:47:10,930 --> 00:47:15,430
the bless' would be passed that class so

00:47:13,119 --> 00:47:20,019
that you're blessing your objects

00:47:15,430 --> 00:47:21,220
attribute storage yeah that's right you

00:47:20,019 --> 00:47:24,910
lose the class name and the ability for

00:47:21,220 --> 00:47:27,630
for inheritance to work easily yeah so a

00:47:24,910 --> 00:47:27,630
good question yes

00:47:28,340 --> 00:47:43,910
yeah yeah that's yeah in C++ you'd call

00:47:41,390 --> 00:47:45,920
that a virtual class and other languages

00:47:43,910 --> 00:48:00,110
would be an abstract based class but

00:47:45,920 --> 00:48:01,640
that's the idea right and so in Perl you

00:48:00,110 --> 00:48:03,830
could achieve that if you're using the

00:48:01,640 --> 00:48:05,090
the historical old version of writing

00:48:03,830 --> 00:48:08,330
your own constructors you could let your

00:48:05,090 --> 00:48:10,400
constructor die in a moose world I

00:48:08,330 --> 00:48:12,470
suppose you could make Bill dogs die or

00:48:10,400 --> 00:48:14,360
build die which is which which are

00:48:12,470 --> 00:48:18,560
methods that are called around the

00:48:14,360 --> 00:48:22,100
constructor yes yeah that's right yeah

00:48:18,560 --> 00:48:24,040
rolls to a roll to two distinct 'm to

00:48:22,100 --> 00:48:27,640
enforce that this is a pure virtual or a

00:48:24,040 --> 00:48:31,120
abstract base class yeah thank you so

00:48:27,640 --> 00:48:31,120
does that answer your question

00:48:43,190 --> 00:48:47,930
so in roles you can say requires but not

00:48:46,550 --> 00:48:49,850
actually implement the thing that you're

00:48:47,930 --> 00:48:51,830
requiring and then you will have a death

00:48:49,850 --> 00:48:54,320
if it's not implemented in the subclass

00:48:51,830 --> 00:48:56,780
or in the in the class that that

00:48:54,320 --> 00:49:00,260
composes in the role does that answer it

00:48:56,780 --> 00:49:02,840
yes yeah look at that look at the

00:49:00,260 --> 00:49:07,100
requires in for example moose role or

00:49:02,840 --> 00:49:10,190
Moo role either one of those yeah thanks

00:49:07,100 --> 00:49:19,310
any other questions all right thanks for

00:49:10,190 --> 00:49:21,470
coming today you're right this

00:49:19,310 --> 00:49:25,690
microphone started out way up by my lips

00:49:21,470 --> 00:49:25,690

YouTube URL: https://www.youtube.com/watch?v=rPRjsuNicyo


