Title: Brian Duggan - "Extending Perl 6 Command Line Argument Parsing using Metaprogramming"
Publication date: 2017-06-22
Playlist: TPC 2017 in DC
Description: 
	Perl 6 has amazing built-in features for writing command-line utilities. But sometimes even those aren't enough. In this talk, we push it further to allow features such as subcommands, command-specific help and interleaved positional and named arguments. We use metaprogramming to look up dispatch tables for multi-candidates, scrutinize signatures, and query POD declarator blocks. We show how integration with command line argument parsing is a practical application of Perl 6's rich meta-object protocol.


Brian has been an open source software author for over 20 years. His interests include math, chess, linked data, and writing code in Perl 5 and 6.
Captions: 
	00:00:00,000 --> 00:00:04,980
and there's an important point before

00:00:02,909 --> 00:00:07,290
this talk that there are actually two

00:00:04,980 --> 00:00:10,410
people at this conference with the name

00:00:07,290 --> 00:00:11,519
spelled the same way there's and there's

00:00:10,410 --> 00:00:13,860
the other one right there having coffee

00:00:11,519 --> 00:00:16,529
this is Brian Dugan's and I am Brian

00:00:13,860 --> 00:00:23,000
Duggan so I believe we have al amorphic

00:00:16,529 --> 00:00:26,279
names okay so this talk is about

00:00:23,000 --> 00:00:27,990
command-line argument parsing extending

00:00:26,279 --> 00:00:29,670
Perl 6 command-line argument parsing

00:00:27,990 --> 00:00:33,030
using meta programming so despite the

00:00:29,670 --> 00:00:36,390
title this is actually based on my

00:00:33,030 --> 00:00:39,390
experience using Perl 6 in production so

00:00:36,390 --> 00:00:40,980
I'm going to go through not the

00:00:39,390 --> 00:00:43,710
production code but a lot of the

00:00:40,980 --> 00:00:48,890
building blocks that I used building out

00:00:43,710 --> 00:00:48,890
a command line application in production

00:00:48,920 --> 00:00:54,840
so I work at a company called prompt

00:00:52,770 --> 00:00:57,600
works I'd like to thank them for sending

00:00:54,840 --> 00:01:03,719
me here we're based in Philadelphia and

00:00:57,600 --> 00:01:06,110
we are a software consultancy ok so I'm

00:01:03,719 --> 00:01:09,750
going to divide this talk into two parts

00:01:06,110 --> 00:01:11,970
the first one will be about the built in

00:01:09,750 --> 00:01:13,650
command line parsing functionality

00:01:11,970 --> 00:01:16,320
command line argument parsing

00:01:13,650 --> 00:01:18,000
functionality in Perl 6 and then the

00:01:16,320 --> 00:01:20,759
second part is going to be extending

00:01:18,000 --> 00:01:22,729
that using metaprogramming by which I

00:01:20,759 --> 00:01:25,250
mean dealing with functions and

00:01:22,729 --> 00:01:29,280
subroutines and signatures as

00:01:25,250 --> 00:01:35,850
first-class objects and getting some

00:01:29,280 --> 00:01:38,390
information about them ok ok so let's

00:01:35,850 --> 00:01:41,250
talk about command-line argument parsing

00:01:38,390 --> 00:01:43,860
there probably been many talks about

00:01:41,250 --> 00:01:45,810
command-line argument parsing and you

00:01:43,860 --> 00:01:48,450
have all probably done it at some point

00:01:45,810 --> 00:01:50,729
how many people have written things that

00:01:48,450 --> 00:01:54,780
use command-line arguments how many

00:01:50,729 --> 00:01:58,530
people have liked using get offed or the

00:01:54,780 --> 00:02:01,860
equivalent ok some people like it for me

00:01:58,530 --> 00:02:03,570
I've often struggled with using get opt

00:02:01,860 --> 00:02:06,030
I've always found that it seems like

00:02:03,570 --> 00:02:08,220
it's harder than it should be now this

00:02:06,030 --> 00:02:10,470
has been sort of I did a little google

00:02:08,220 --> 00:02:12,500
search and this is kind of what it looks

00:02:10,470 --> 00:02:14,360
like from afar when I think of

00:02:12,500 --> 00:02:17,180
and argument parsing you know you've got

00:02:14,360 --> 00:02:18,950
this huge specification of stuff and you

00:02:17,180 --> 00:02:20,840
have to sort of figure out you know what

00:02:18,950 --> 00:02:22,070
they type and how you're going to parse

00:02:20,840 --> 00:02:23,930
it and how you're going to map it to

00:02:22,070 --> 00:02:29,420
what you're doing and I've always felt

00:02:23,930 --> 00:02:32,720
you know it shouldn't be so hard and I

00:02:29,420 --> 00:02:35,060
guess one of the reasons that I felt

00:02:32,720 --> 00:02:37,720
that way so here's an example anybody

00:02:35,060 --> 00:02:39,830
recognized what this is

00:02:37,720 --> 00:02:41,870
graphics magic right so here's an

00:02:39,830 --> 00:02:44,810
example image magic this now graphics

00:02:41,870 --> 00:02:49,340
magic so this is an example of doing a

00:02:44,810 --> 00:02:51,860
transformation of an image and you can

00:02:49,340 --> 00:02:55,220
see there are a bunch of command line

00:02:51,860 --> 00:02:57,320
options we're doing a resize and this is

00:02:55,220 --> 00:03:01,760
actually one of the examples from the

00:02:57,320 --> 00:03:05,450
man page and it's a little bit terse and

00:03:01,760 --> 00:03:06,950
you can imagine parsing it would be kind

00:03:05,450 --> 00:03:09,830
of tricky but you would set up some sort

00:03:06,950 --> 00:03:11,090
of specification but at the end of the

00:03:09,830 --> 00:03:12,320
day you know when you're running

00:03:11,090 --> 00:03:13,400
something from the command line it's

00:03:12,320 --> 00:03:15,920
kind of like you're calling a function

00:03:13,400 --> 00:03:17,959
right and the thing on the bottom to me

00:03:15,920 --> 00:03:20,000
makes a lot more sense because you can

00:03:17,959 --> 00:03:23,150
see like okay these are the arguments

00:03:20,000 --> 00:03:26,209
I'm sending to the function and use

00:03:23,150 --> 00:03:28,130
those values so it would be nice if

00:03:26,209 --> 00:03:31,310
there's a way to get straight from the

00:03:28,130 --> 00:03:33,019
command line to a function call the only

00:03:31,310 --> 00:03:35,420
thing that makes it different is that

00:03:33,019 --> 00:03:39,230
your function calls have to have a lot

00:03:35,420 --> 00:03:41,450
of semantics like you need positional or

00:03:39,230 --> 00:03:43,280
named commit parameters for it because

00:03:41,450 --> 00:03:45,110
on the command line sometimes you have

00:03:43,280 --> 00:03:47,750
things that are positional sometimes you

00:03:45,110 --> 00:03:50,870
have options which are you know start

00:03:47,750 --> 00:03:53,030
with a - you may need some optional or

00:03:50,870 --> 00:03:55,160
some required parameters you may also

00:03:53,030 --> 00:03:56,570
need support for types for instance some

00:03:55,160 --> 00:04:00,820
of the options that come in are boolean

00:03:56,570 --> 00:04:03,200
some are not short and long names

00:04:00,820 --> 00:04:05,540
documentation so these kinds of things

00:04:03,200 --> 00:04:09,130
are in argument parsing libraries and

00:04:05,540 --> 00:04:11,900
it's why we use them so that we can turn

00:04:09,130 --> 00:04:14,120
stuff on the command line into function

00:04:11,900 --> 00:04:17,720
call but the good thing is that in for

00:04:14,120 --> 00:04:19,989
all six the subroutines support all the

00:04:17,720 --> 00:04:24,800
things that were on the previous slide

00:04:19,989 --> 00:04:27,740
so along with that Pro six also

00:04:24,800 --> 00:04:29,629
takes subroutine arguments and turns

00:04:27,740 --> 00:04:33,340
them into function calls to a special

00:04:29,629 --> 00:04:35,659
function that's called me in all caps so

00:04:33,340 --> 00:04:39,710
I'm going to go through a few examples

00:04:35,659 --> 00:04:42,590
of how it does this and the examples I'm

00:04:39,710 --> 00:04:45,590
going to look at are the ones that I

00:04:42,590 --> 00:04:47,930
just described so some examples of how

00:04:45,590 --> 00:04:51,770
positional versus named parameters get

00:04:47,930 --> 00:04:55,759
handled required parameters examples of

00:04:51,770 --> 00:04:57,380
types defaults and then aliases

00:04:55,759 --> 00:04:59,630
constraints we'll see how multiple

00:04:57,380 --> 00:05:02,509
dispatch comes to play and how the

00:04:59,630 --> 00:05:04,539
documentation is even can be taken from

00:05:02,509 --> 00:05:08,840
the subroutines and put into

00:05:04,539 --> 00:05:11,750
command-line documentation okay so first

00:05:08,840 --> 00:05:13,130
of all how many people have just how

00:05:11,750 --> 00:05:16,819
many people have written a program in

00:05:13,130 --> 00:05:19,389
Perl six at all okay how many how many

00:05:16,819 --> 00:05:22,039
people have used Pro six in production

00:05:19,389 --> 00:05:24,650
okay how many people have used the

00:05:22,039 --> 00:05:26,840
command-line argument stuff in Perl six

00:05:24,650 --> 00:05:29,120
for parsing it okay so for a lot of

00:05:26,840 --> 00:05:31,430
people here this will be review because

00:05:29,120 --> 00:05:33,400
you've used some of these features and

00:05:31,430 --> 00:05:37,310
then hopefully the second part will be

00:05:33,400 --> 00:05:41,029
somewhat new okay so first of all with

00:05:37,310 --> 00:05:44,090
no argument parsing you can always use

00:05:41,029 --> 00:05:47,000
this dynamic array at Star args which

00:05:44,090 --> 00:05:48,740
has the stuff that came in split on

00:05:47,000 --> 00:05:52,639
white space and you can parse it however

00:05:48,740 --> 00:05:55,340
you want to but as soon as you make a

00:05:52,639 --> 00:05:58,099
subroutine called main then instantly

00:05:55,340 --> 00:06:01,219
you get argument parsing so now if we

00:05:58,099 --> 00:06:04,639
have a if we have a program called greet

00:06:01,219 --> 00:06:07,460
and we run it and then we add an

00:06:04,639 --> 00:06:10,759
argument like - - help which does not

00:06:07,460 --> 00:06:15,590
match the arguments that go into main we

00:06:10,759 --> 00:06:18,020
get a usage message so in fact you get

00:06:15,590 --> 00:06:20,690
this usage message no matter what

00:06:18,020 --> 00:06:24,380
arguments you give it if they don't

00:06:20,690 --> 00:06:25,880
match what's in me there's actually

00:06:24,380 --> 00:06:27,860
something a little bit different about

00:06:25,880 --> 00:06:35,899
help and the other ones anybody know

00:06:27,860 --> 00:06:39,580
what it is so this look what's that well

00:06:35,899 --> 00:06:39,580
they both generate a usage message

00:06:40,180 --> 00:06:46,690
they actually both go to usage the own

00:06:43,610 --> 00:06:46,690
there's one difference

00:06:47,420 --> 00:06:53,240
I don't know that exit could but it

00:06:50,600 --> 00:06:55,040
could be but I do know that when you use

00:06:53,240 --> 00:06:56,930
- - health it's subject to standard out

00:06:55,040 --> 00:07:01,160
instead of standard error so I just

00:06:56,930 --> 00:07:03,200
learned that this morning but otherwise

00:07:01,160 --> 00:07:05,510
there's nothing special about health as

00:07:03,200 --> 00:07:08,840
long as you can't match what's coming in

00:07:05,510 --> 00:07:14,720
to Maine it'll run your it'll give you

00:07:08,840 --> 00:07:17,540
the usage okay so positional versus

00:07:14,720 --> 00:07:20,600
named parameters so the one on the top

00:07:17,540 --> 00:07:22,430
is positional and then to have a named

00:07:20,600 --> 00:07:26,150
parameter of pro six you put a colon in

00:07:22,430 --> 00:07:29,300
front of it and this automatically turns

00:07:26,150 --> 00:07:38,990
an argument with dashes into a named

00:07:29,300 --> 00:07:41,240
argument to mean okay so the so these

00:07:38,990 --> 00:07:43,010
two these two command-line invitations

00:07:41,240 --> 00:07:44,780
are similar to calling Maine one with a

00:07:43,010 --> 00:07:50,080
positional argument and one with a named

00:07:44,780 --> 00:07:52,520
argument you can indicate required

00:07:50,080 --> 00:07:54,920
parameters also there are two ways of

00:07:52,520 --> 00:07:56,480
doing that one is by saying is require

00:07:54,920 --> 00:08:02,620
the others by adding an exclamation

00:07:56,480 --> 00:08:06,170
point and you can see that it sort of

00:08:02,620 --> 00:08:07,610
fixes up the usage message using the

00:08:06,170 --> 00:08:09,830
standard convention like there are no

00:08:07,610 --> 00:08:17,540
brackets around the argument indicating

00:08:09,830 --> 00:08:20,210
that it's mandatory you can also you

00:08:17,540 --> 00:08:22,310
know one of the cool things one of the

00:08:20,210 --> 00:08:24,980
big things in 406 is that it's gradually

00:08:22,310 --> 00:08:29,150
typed so if you want to give types to

00:08:24,980 --> 00:08:32,719
the arguments of your function you can

00:08:29,150 --> 00:08:36,830
specify them so if we give our arguments

00:08:32,719 --> 00:08:38,930
a string and a boolean type then you can

00:08:36,830 --> 00:08:40,520
sort of see that the usage message that

00:08:38,930 --> 00:08:42,710
gets generated automatically says oh

00:08:40,520 --> 00:08:44,420
this one takes a string and the other

00:08:42,710 --> 00:08:46,870
one that's a boolean is a flag that's

00:08:44,420 --> 00:08:48,950
either on or off there's a way to

00:08:46,870 --> 00:08:52,100
specifically so if you admit it then

00:08:48,950 --> 00:08:54,560
it's false if you put it there it's

00:08:52,100 --> 00:09:00,790
you can explicitly say it's false - by

00:08:54,560 --> 00:09:03,680
putting a slash after the dashes but

00:09:00,790 --> 00:09:10,550
about the types make their way into the

00:09:03,680 --> 00:09:14,770
main subroutine similarly if you have

00:09:10,550 --> 00:09:17,780
defaults you can put those in your

00:09:14,770 --> 00:09:19,310
declaration of main it's pretty

00:09:17,780 --> 00:09:23,870
straightforward you use an equal sign

00:09:19,310 --> 00:09:26,240
and now instead of having to require a

00:09:23,870 --> 00:09:29,210
parameter you can if you run this with

00:09:26,240 --> 00:09:35,480
no parameters then it'll default to the

00:09:29,210 --> 00:09:38,530
value one thing you might notice is that

00:09:35,480 --> 00:09:42,050
the default usage that's generated

00:09:38,530 --> 00:09:43,460
doesn't have your default value so in

00:09:42,050 --> 00:09:49,280
part 2 I'm going to talk a little bit

00:09:43,460 --> 00:09:51,140
about how you can change that also

00:09:49,280 --> 00:09:54,230
convenient as short names and long names

00:09:51,140 --> 00:09:58,130
so what's kind of cool here is that when

00:09:54,230 --> 00:09:59,660
you use this syntax or you use a colon

00:09:58,130 --> 00:10:02,330
and a short name and you put parentheses

00:09:59,660 --> 00:10:03,710
around your argument so this is not just

00:10:02,330 --> 00:10:05,690
something that works for the

00:10:03,710 --> 00:10:07,550
command-line you you're familiar with it

00:10:05,690 --> 00:10:10,010
from command-line parsing but it works

00:10:07,550 --> 00:10:12,410
at the function level so now if somebody

00:10:10,010 --> 00:10:14,570
calls your function they can send

00:10:12,410 --> 00:10:17,060
different aliases for the same incoming

00:10:14,570 --> 00:10:19,460
parameter so it's also sort of a nice

00:10:17,060 --> 00:10:20,810
way of providing you know compatibility

00:10:19,460 --> 00:10:23,720
if you're making a library and you want

00:10:20,810 --> 00:10:28,550
to have various options first names for

00:10:23,720 --> 00:10:31,250
the same option constraints are also

00:10:28,550 --> 00:10:35,230
possible the where clause add the

00:10:31,250 --> 00:10:37,250
constraints here's an example of

00:10:35,230 --> 00:10:39,470
ensuring that a particular argument

00:10:37,250 --> 00:10:42,260
matches a regular expression so we're

00:10:39,470 --> 00:10:46,160
saying you know greet only somebody

00:10:42,260 --> 00:10:47,960
whose name has a lowercase if a case is

00:10:46,160 --> 00:10:52,070
dedicate we do a case insensitive match

00:10:47,960 --> 00:10:54,920
for Bob or Robert so if we do Roberto

00:10:52,070 --> 00:10:56,750
that includes the string Robert so that

00:10:54,920 --> 00:10:58,570
passes the type constraint or not the

00:10:56,750 --> 00:11:01,910
type constraints the check constraint

00:10:58,570 --> 00:11:05,410
and if we don't we say greet Jo we get

00:11:01,910 --> 00:11:05,410
our uses our usage message

00:11:07,810 --> 00:11:16,030
a nice thing about constraints is that

00:11:11,140 --> 00:11:18,040
if you have several different if you

00:11:16,030 --> 00:11:20,650
have several different functions with

00:11:18,040 --> 00:11:23,620
non-overlapping constraints then you can

00:11:20,650 --> 00:11:28,810
instead use a multi method or a multi

00:11:23,620 --> 00:11:32,230
sub in this case and pro-sex provides

00:11:28,810 --> 00:11:34,690
multiple dispatch so here if we have one

00:11:32,230 --> 00:11:37,330
main which takes bob is the first

00:11:34,690 --> 00:11:39,910
argument one that takes alice then the

00:11:37,330 --> 00:11:42,430
usage actually figures out that there's

00:11:39,910 --> 00:11:45,040
two different there's two different ways

00:11:42,430 --> 00:11:48,160
to call this program one with Bob and

00:11:45,040 --> 00:11:49,570
one with Alice and when you send Bob you

00:11:48,160 --> 00:11:59,110
get the first one when you send Alice

00:11:49,570 --> 00:12:02,950
you get the second one and then finally

00:11:59,110 --> 00:12:06,540
we have documentation so not only is

00:12:02,950 --> 00:12:08,770
there pod-like in pro/5 but even

00:12:06,540 --> 00:12:15,070
comments that begin with a number sign

00:12:08,770 --> 00:12:18,760
can can be used as what's known as

00:12:15,070 --> 00:12:23,440
decorator pod so these by it by putting

00:12:18,760 --> 00:12:26,110
a vertical bar after your pound sign it

00:12:23,440 --> 00:12:29,470
just says attach this comment to

00:12:26,110 --> 00:12:32,410
whatever is coming next and when you

00:12:29,470 --> 00:12:34,210
have an equal sign next to your number

00:12:32,410 --> 00:12:36,280
sign that means attach this

00:12:34,210 --> 00:12:40,510
documentation to whatever came before it

00:12:36,280 --> 00:12:44,160
so in this example we've got this multi

00:12:40,510 --> 00:12:46,780
main and the first thing we do is we say

00:12:44,160 --> 00:12:50,140
this comment is say hello to somebody

00:12:46,780 --> 00:12:52,600
and it's attached to this mean and then

00:12:50,140 --> 00:12:54,490
the argument here which is a required

00:12:52,600 --> 00:12:57,220
parameter name also has a comment

00:12:54,490 --> 00:13:00,670
attached to it and the comment is the

00:12:57,220 --> 00:13:02,350
person to be greeted so then the usage

00:13:00,670 --> 00:13:05,050
intelligently sort of looks through this

00:13:02,350 --> 00:13:06,400
and says okay well this comment is

00:13:05,050 --> 00:13:08,200
attached to this main so I'm going to

00:13:06,400 --> 00:13:11,020
print that out as the documentation and

00:13:08,200 --> 00:13:12,850
then also I see you have this comment

00:13:11,020 --> 00:13:14,470
attached to this argument so I'm going

00:13:12,850 --> 00:13:16,850
to print that as a documentation for the

00:13:14,470 --> 00:13:19,070
argument so

00:13:16,850 --> 00:13:24,050
you get a lot of stuff built in already

00:13:19,070 --> 00:13:27,170
for your metaprogramming it's never

00:13:24,050 --> 00:13:28,640
enough which brings us to part two but

00:13:27,170 --> 00:13:30,710
one extra little thing here on the

00:13:28,640 --> 00:13:33,320
bottom I did notice while using this is

00:13:30,710 --> 00:13:36,800
for introduction is that by default you

00:13:33,320 --> 00:13:38,990
have to put all of the named arguments

00:13:36,800 --> 00:13:40,700
at the end and the positional wants at

00:13:38,990 --> 00:13:42,590
the beginning but there's a little flag

00:13:40,700 --> 00:13:44,140
in ruku doe you can set to change that

00:13:42,590 --> 00:13:45,860
so you can sort of intermix your

00:13:44,140 --> 00:13:48,970
positional arguments in your names

00:13:45,860 --> 00:13:51,200
command arguments on the command line

00:13:48,970 --> 00:13:53,000
and that's called main allow named

00:13:51,200 --> 00:13:56,450
anywhere and you set that to true in

00:13:53,000 --> 00:13:58,010
your program ok so moving on

00:13:56,450 --> 00:13:59,900
metaprogramming so what if it's not

00:13:58,010 --> 00:14:02,930
enough and you want to do some extra

00:13:59,900 --> 00:14:04,820
stuff all right what else could we

00:14:02,930 --> 00:14:06,860
possibly want we have so much already

00:14:04,820 --> 00:14:09,920
with our command line argument parsing

00:14:06,860 --> 00:14:12,350
so well you know let's look at something

00:14:09,920 --> 00:14:14,690
like yet it's got sub commands it's got

00:14:12,350 --> 00:14:18,440
help for the individual sub commands

00:14:14,690 --> 00:14:19,610
it's got all kinds of crazy stuff so I'm

00:14:18,440 --> 00:14:21,890
going to go through a suit a few

00:14:19,610 --> 00:14:24,620
examples of extending the built-in stuff

00:14:21,890 --> 00:14:26,390
to support subcommands options for your

00:14:24,620 --> 00:14:27,760
sub commands displaying the defaults

00:14:26,390 --> 00:14:31,150
which is one of the things that I said

00:14:27,760 --> 00:14:33,620
doesn't happen with the built-in stuff

00:14:31,150 --> 00:14:35,090
displaying the constraints and then you

00:14:33,620 --> 00:14:36,470
know finally as the code base gets

00:14:35,090 --> 00:14:38,570
bigger you may want to break it out and

00:14:36,470 --> 00:14:46,280
not have all your mains in one place and

00:14:38,570 --> 00:14:48,470
maybe even add some testing okay so the

00:14:46,280 --> 00:14:53,000
way we're going to do this is with the

00:14:48,470 --> 00:14:54,880
pro six metamodel okay so we're going to

00:14:53,000 --> 00:15:00,020
be exploring essentially the way that

00:14:54,880 --> 00:15:02,150
the built-in the built-in dispatcher and

00:15:00,020 --> 00:15:04,340
the growth in usage function works by

00:15:02,150 --> 00:15:06,110
introspecting the different types the

00:15:04,340 --> 00:15:07,490
subs the signatures the parameters

00:15:06,110 --> 00:15:09,530
constraints the types and the

00:15:07,490 --> 00:15:13,160
introspection method the introspection

00:15:09,530 --> 00:15:15,470
methods which are like always remind me

00:15:13,160 --> 00:15:19,010
of like the who's on first routine we

00:15:15,470 --> 00:15:21,740
have why what who and how and these are

00:15:19,010 --> 00:15:25,490
all methods that are available to call

00:15:21,740 --> 00:15:28,319
on any object and they will tell you

00:15:25,490 --> 00:15:31,269
something about the object

00:15:28,319 --> 00:15:35,559
so for instance we'll start with showing

00:15:31,269 --> 00:15:37,509
the defaults so here's our sub main and

00:15:35,559 --> 00:15:40,629
then we're going to generate our own

00:15:37,509 --> 00:15:43,599
usage just by declaring a function

00:15:40,629 --> 00:15:45,669
called usage and if we look at an for

00:15:43,599 --> 00:15:47,099
Stan main we can call a method called

00:15:45,669 --> 00:15:50,470
signature on it

00:15:47,099 --> 00:15:53,559
signature returns a signature object the

00:15:50,470 --> 00:15:58,479
signature object has a method called

00:15:53,559 --> 00:16:01,149
params and each of the params has a

00:15:58,479 --> 00:16:03,099
method called default and a method

00:16:01,149 --> 00:16:07,049
called name which tell you something

00:16:03,099 --> 00:16:12,069
about the parameters that are declared

00:16:07,049 --> 00:16:14,649
for me okay so in this case so I'm just

00:16:12,069 --> 00:16:18,009
going to go through that one more time

00:16:14,649 --> 00:16:21,279
okay so ampersand main is an object of

00:16:18,009 --> 00:16:24,189
type sub and then you could look at the

00:16:21,279 --> 00:16:28,299
documentation for this in Docs dot 406

00:16:24,189 --> 00:16:29,979
org slash type slash sub and you'll see

00:16:28,299 --> 00:16:34,239
all of the different methods you can

00:16:29,979 --> 00:16:37,359
call on sub one of the methods is

00:16:34,239 --> 00:16:41,739
signature which gives you an object of

00:16:37,359 --> 00:16:43,720
type signature and that has a method

00:16:41,739 --> 00:16:47,699
called params which returns a list of

00:16:43,720 --> 00:16:49,779
things with the type parameter and

00:16:47,699 --> 00:16:52,199
parameter has a method called default

00:16:49,779 --> 00:16:54,999
which returns something called a block

00:16:52,199 --> 00:16:58,089
because the defaults can actually be

00:16:54,999 --> 00:17:02,519
generated at runtime and then you can

00:16:58,089 --> 00:17:05,230
call the block and see the default so

00:17:02,519 --> 00:17:08,649
that's how in the previous slide we were

00:17:05,230 --> 00:17:10,629
able to we have dollar default with two

00:17:08,649 --> 00:17:13,870
parentheses which means call this block

00:17:10,629 --> 00:17:17,649
and we get the name dollar name and we

00:17:13,870 --> 00:17:19,720
get Bob as the default so these are sort

00:17:17,649 --> 00:17:21,939
of the building blocks for how you can

00:17:19,720 --> 00:17:25,750
make your own usage that's more

00:17:21,939 --> 00:17:27,759
sophisticated than the built in one okay

00:17:25,750 --> 00:17:32,340
so what about constraints it's very much

00:17:27,759 --> 00:17:34,450
the same thing which is that a signature

00:17:32,340 --> 00:17:38,120
parameter has another method called

00:17:34,450 --> 00:17:44,630
constraints and

00:17:38,120 --> 00:17:46,779
for constraints the constraint can sort

00:17:44,630 --> 00:17:51,080
of be anything right so in this case our

00:17:46,779 --> 00:17:53,330
constraint by calling karat name we are

00:17:51,080 --> 00:17:56,240
finding out that this is a regular

00:17:53,330 --> 00:17:57,620
expression now if you're wondering what

00:17:56,240 --> 00:17:59,840
that carrot name is I'll show you in a

00:17:57,620 --> 00:18:03,020
second and then dollar C is actually

00:17:59,840 --> 00:18:05,720
printing out the regular expression okay

00:18:03,020 --> 00:18:08,330
so carrot name that I'm calling on

00:18:05,720 --> 00:18:12,470
dollar C to figure out what it is is

00:18:08,330 --> 00:18:14,440
shorthand for dollar C ow

00:18:12,470 --> 00:18:17,690
remember I was talking about the

00:18:14,440 --> 00:18:19,730
different introspection methods and how

00:18:17,690 --> 00:18:22,730
gives you the higher-order workings of

00:18:19,730 --> 00:18:27,409
something and then till you say dollar

00:18:22,730 --> 00:18:33,770
see da name so there's a shorthand for

00:18:27,409 --> 00:18:35,419
that which is dot carrot name there

00:18:33,770 --> 00:18:37,520
similarly a what which would return a

00:18:35,419 --> 00:18:41,419
type object and then calling the gist

00:18:37,520 --> 00:18:44,090
gives you the string off' ocation or a

00:18:41,419 --> 00:18:50,390
human readable version of the regular

00:18:44,090 --> 00:18:52,580
expression okay so what about the type

00:18:50,390 --> 00:18:54,049
so the same thing we have a parameter of

00:18:52,580 --> 00:18:56,299
the parameter has a method called type

00:18:54,049 --> 00:18:59,870
so we can use that to print out the type

00:18:56,299 --> 00:19:01,970
of things it's a little trickier if

00:18:59,870 --> 00:19:04,340
there's a constant like we had in our

00:19:01,970 --> 00:19:06,940
examples where you have sub main and

00:19:04,340 --> 00:19:10,490
then there's just a string called Bob

00:19:06,940 --> 00:19:14,890
because in this case what's generated as

00:19:10,490 --> 00:19:17,659
a junction just how they talk in itself

00:19:14,890 --> 00:19:19,370
but the good thing is to figure out what

00:19:17,659 --> 00:19:21,380
the value of the junction is you could

00:19:19,370 --> 00:19:22,940
always just stringify it using Perl and

00:19:21,380 --> 00:19:28,909
then parse that which is kind of what

00:19:22,940 --> 00:19:37,039
I'm doing here sorry which is what I'm

00:19:28,909 --> 00:19:41,809
doing here so you can sort of use this

00:19:37,039 --> 00:19:44,330
trick for your sub commands so if you

00:19:41,809 --> 00:19:45,919
have a multi dispatch main and you've

00:19:44,330 --> 00:19:50,720
got a bunch of different constants that

00:19:45,919 --> 00:19:51,890
are your sub commands basically you can

00:19:50,720 --> 00:19:55,220
call ampersand main

00:19:51,890 --> 00:19:56,720
candidates so the sub also has a method

00:19:55,220 --> 00:19:58,580
called candidates which tells you all

00:19:56,720 --> 00:20:01,250
the different candidates that a multi

00:19:58,580 --> 00:20:06,590
might use each of those is also a sub

00:20:01,250 --> 00:20:08,900
and you can find what the first argument

00:20:06,590 --> 00:20:14,750
is the first constraint is for those

00:20:08,900 --> 00:20:16,670
subs and then you can also call that why

00:20:14,750 --> 00:20:18,560
in order to figure out what the

00:20:16,670 --> 00:20:26,680
documentation is and print that out

00:20:18,560 --> 00:20:29,540
yourself - okay so here we see another

00:20:26,680 --> 00:20:32,000
implementation of the original usage

00:20:29,540 --> 00:20:33,710
what with the additional advantage that

00:20:32,000 --> 00:20:35,750
we can show our defaults we can show our

00:20:33,710 --> 00:20:38,240
constraints and also we can have

00:20:35,750 --> 00:20:44,510
different arguments for different sub

00:20:38,240 --> 00:20:47,300
commands okay so a couple more things so

00:20:44,510 --> 00:20:49,190
after your project grows you may have a

00:20:47,300 --> 00:20:50,480
lot of mains and you may think oh I

00:20:49,190 --> 00:20:52,880
don't want to have all these mains in

00:20:50,480 --> 00:20:54,320
one file it's hard to maintain so can I

00:20:52,880 --> 00:20:55,700
just have some sort of a directory

00:20:54,320 --> 00:20:58,790
structure that looks like this where I

00:20:55,700 --> 00:21:02,750
have a left PM and Bob PM and then maybe

00:20:58,790 --> 00:21:04,640
I have my main program next to it and

00:21:02,750 --> 00:21:06,230
actually the first step to doing that

00:21:04,640 --> 00:21:08,930
you could just take your mains put them

00:21:06,230 --> 00:21:11,150
in those dot VM files and label them as

00:21:08,930 --> 00:21:15,490
is export and you've broken up your file

00:21:11,150 --> 00:21:15,490
and everything continues to work fine I

00:21:16,840 --> 00:21:23,200
guess dot is still in ink with pro six

00:21:20,200 --> 00:21:27,830
so you can just use those and and

00:21:23,200 --> 00:21:29,630
everything works fine but that may get a

00:21:27,830 --> 00:21:31,520
little bit cumbersome and then you may

00:21:29,630 --> 00:21:33,800
decide well actually especially if I

00:21:31,520 --> 00:21:35,300
want to do testing maybe I'll just call

00:21:33,800 --> 00:21:39,650
them something else instead of calling a

00:21:35,300 --> 00:21:43,240
main and then export those into my main

00:21:39,650 --> 00:21:45,830
program and then just let the dispatcher

00:21:43,240 --> 00:21:47,990
do its work from within my program

00:21:45,830 --> 00:21:51,320
instead of dispatching to all the

00:21:47,990 --> 00:21:53,780
different means and so then you can sort

00:21:51,320 --> 00:21:55,850
of change the signature of main to slurp

00:21:53,780 --> 00:21:57,200
in all of your positional arguments and

00:21:55,850 --> 00:22:00,020
all of your command-line arguments and

00:21:57,200 --> 00:22:01,670
then pass those along and it'll call the

00:22:00,020 --> 00:22:03,350
right command so you can sort of

00:22:01,670 --> 00:22:06,790
continue to use the same design pattern

00:22:03,350 --> 00:22:06,790
even if you're not using

00:22:07,169 --> 00:22:13,860
and this is handy if you want to test

00:22:10,830 --> 00:22:15,360
your command line program because you

00:22:13,860 --> 00:22:18,210
can sort of pull each of these in and

00:22:15,360 --> 00:22:19,799
then you can take your ampersand command

00:22:18,210 --> 00:22:21,720
you can introspect it make sure the

00:22:19,799 --> 00:22:25,799
documentation is right and you can

00:22:21,720 --> 00:22:30,840
simulate runs and have some nice testing

00:22:25,799 --> 00:22:33,030
for your command line application so in

00:22:30,840 --> 00:22:35,690
summary there's a lot of built in good

00:22:33,030 --> 00:22:39,000
stuff with Perl six command line parsing

00:22:35,690 --> 00:22:40,860
and not only is it good for putting

00:22:39,000 --> 00:22:43,169
something together but if you find that

00:22:40,860 --> 00:22:44,820
your project starts growing you can also

00:22:43,169 --> 00:22:47,309
continue to sort of build on it and

00:22:44,820 --> 00:22:51,179
refactor it and the same design patterns

00:22:47,309 --> 00:22:53,130
continue to work and you can use it as a

00:22:51,179 --> 00:23:02,340
starting point for a bigger command-line

00:22:53,130 --> 00:23:03,990
application thank you I think it's

00:23:02,340 --> 00:23:06,679
lunchtime right now I don't know if I

00:23:03,990 --> 00:23:06,679

YouTube URL: https://www.youtube.com/watch?v=D16wa-gnFwE


