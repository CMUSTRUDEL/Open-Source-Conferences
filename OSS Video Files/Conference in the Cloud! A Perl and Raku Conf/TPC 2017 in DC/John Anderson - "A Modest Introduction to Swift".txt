Title: John Anderson - "A Modest Introduction to Swift"
Publication date: 2017-06-23
Playlist: TPC 2017 in DC
Description: 
	Swift was originally released in 2014, and Open Sourced by Apple in late 2015. The Open Source release generated an explosion of community interest and support, resulting in ports to other platforms and significant language changes. Swift version 3, which reflects the results of much of this work, was released in September of 2016, bringing with it some significant refinements to the core language and a new package manager.

Swift is a multi-paradigm language, supporting imperative, functional, and object-oriented programming styles. The language is strongly typed but has extensive support for type inference and substantial tooling available in XCode to identify and in some cases automatically fix common programming errors. Swift uses a memory management strategy called automatic reference counting (ARC), freeing programmers from the tedium of manually managing memory allocation. This combination of strong typing, maximal type inference, automatic reference counting (ARC), and excellent tooling results in an experience that can be described as "the Macintosh of programming languages".

This talk will present some of the history of the development of Swift with emphasis on how the Open Source release of the language kick-started activity, review the basic syntax of Swift (with comparisons to similar languages that attendees may be more familiar with), and describe what tools are available to help learn the language, including XCode, the Swift REPL available from XCode, and the new Swift Playgrounds for iPad that debuted with Swift 3 and iOS10. After attending this talk, an attendee with no previous Swift experience will understand exactly why they should be excited about this relatively new programming language and be up to date on exactly what they need to do to dive into Swift coding for themselves.


John is the VP of Technology for Infinity Interactive, a virtual IT consultancy. When he's not maintaining Perl modules or tweaking his Emacs config, he likes to play around with new languages like Swift and write about himself in the third person.
Captions: 
	00:00:01,970 --> 00:00:05,630
[Applause]

00:00:05,930 --> 00:00:13,349
from that people Oh welcome to a modest

00:00:10,650 --> 00:00:15,780
introduction to Swift it is open source

00:00:13,349 --> 00:00:17,640
um so I apologize for the title those

00:00:15,780 --> 00:00:20,100
are my two Swift puns I have those out

00:00:17,640 --> 00:00:24,510
of the way we're going to move on so hi

00:00:20,100 --> 00:00:27,480
I'm John I go by Gene Hackman online my

00:00:24,510 --> 00:00:31,769
day job I'm the technology for infinity

00:00:27,480 --> 00:00:34,559
interactive I identify with Perl I'm not

00:00:31,769 --> 00:00:37,500
ashamed and I'm a polygon encoder

00:00:34,559 --> 00:00:38,969
so what's polyglot ism so if you think

00:00:37,500 --> 00:00:42,239
that you're one programming language is

00:00:38,969 --> 00:00:44,070
like the best thing ever you're doing

00:00:42,239 --> 00:00:45,660
life wrong right different programming

00:00:44,070 --> 00:00:49,379
languages are good for different things

00:00:45,660 --> 00:00:50,820
so be poly gonna be stupid the last time

00:00:49,379 --> 00:00:52,860
I gave this talk it took about an hour

00:00:50,820 --> 00:00:54,210
and fifteen minutes which was fine that

00:00:52,860 --> 00:00:55,710
time because there was nobody in the

00:00:54,210 --> 00:00:57,090
slot after me but that's not the case

00:00:55,710 --> 00:00:59,730
today so I'm going to talk pretty fast

00:00:57,090 --> 00:01:02,489
and move pretty fast all right

00:00:59,730 --> 00:01:05,580
so Swift what is Swift introduced in

00:01:02,489 --> 00:01:07,470
2014 by Apple as a replacement for

00:01:05,580 --> 00:01:11,520
objective-c they released it as open

00:01:07,470 --> 00:01:13,650
source at version 2.2 last year they

00:01:11,520 --> 00:01:16,670
just released version 3.1 in March and

00:01:13,650 --> 00:01:19,259
version 4 is coming real soon

00:01:16,670 --> 00:01:22,890
originally for Macintosh only now

00:01:19,259 --> 00:01:24,930
available on Linux you can well for

00:01:22,890 --> 00:01:29,729
Linux basically they shipped binaries

00:01:24,930 --> 00:01:31,770
that work on a bun to those binaries

00:01:29,729 --> 00:01:33,869
also work on debian if you poked at them

00:01:31,770 --> 00:01:35,189
a little bit they release the source you

00:01:33,869 --> 00:01:36,990
don't want to try to build it because it

00:01:35,189 --> 00:01:40,229
builds LLVM as part of the build and

00:01:36,990 --> 00:01:42,659
holy crap so just spin up in a bun to VM

00:01:40,229 --> 00:01:44,700
it works fine Android is in the works

00:01:42,659 --> 00:01:46,470
they got a pull request actually at one

00:01:44,700 --> 00:01:49,350
point not too long after open sourcing

00:01:46,470 --> 00:01:51,689
it which then ended up getting merged so

00:01:49,350 --> 00:01:54,000
androids done there is a Windows version

00:01:51,689 --> 00:01:55,710
I've never used it so I can't tell you

00:01:54,000 --> 00:01:58,860
how well it works or doesn't but it is

00:01:55,710 --> 00:02:01,799
theoretically out there and then it

00:01:58,860 --> 00:02:04,590
originally targeted Mac OS iOS watch OS

00:02:01,799 --> 00:02:07,350
and TV OS just sort of apples different

00:02:04,590 --> 00:02:09,750
platforms with the expanded platform

00:02:07,350 --> 00:02:11,340
support and the fact that it is using

00:02:09,750 --> 00:02:12,750
LLVM on the back end

00:02:11,340 --> 00:02:15,030
all you would really need is something

00:02:12,750 --> 00:02:16,860
that can turn an LLVM ast into

00:02:15,030 --> 00:02:18,870
JavaScript and then you could write

00:02:16,860 --> 00:02:21,330
Swift on the server and the client then

00:02:18,870 --> 00:02:26,040
have sort of your node like single

00:02:21,330 --> 00:02:29,310
language stack so what's it like this is

00:02:26,040 --> 00:02:34,260
my dog Sammy Sammy suffers from resting

00:02:29,310 --> 00:02:35,700
stone-faced but so first a brief

00:02:34,260 --> 00:02:38,190
digression before we get into stirrups

00:02:35,700 --> 00:02:41,400
how many people use Mac OS or iOS in the

00:02:38,190 --> 00:02:42,959
audience so a lot almost eighty ninety

00:02:41,400 --> 00:02:46,440
percent how many people have developed

00:02:42,959 --> 00:02:47,940
for Mac OS or iOS fewer people maybe

00:02:46,440 --> 00:02:49,500
fifteen twenty percent of the audience

00:02:47,940 --> 00:02:51,390
okay so the dirty little secret of

00:02:49,500 --> 00:02:52,920
developing for Apple and I'm just going

00:02:51,390 --> 00:02:55,470
to steal this from a book called in the

00:02:52,920 --> 00:02:57,780
beginning was was the command-line by

00:02:55,470 --> 00:03:00,299
Neal Stephenson he says during the late

00:02:57,780 --> 00:03:01,860
1980s and early 1990s I spent a lot of

00:03:00,299 --> 00:03:03,329
time programming Macintosh's and

00:03:01,860 --> 00:03:04,709
eventually decided to fork over several

00:03:03,329 --> 00:03:06,180
hundred dollars for an Apple product

00:03:04,709 --> 00:03:09,900
called the Macintosh programmers

00:03:06,180 --> 00:03:11,310
workshop or MP w MP WI competitors but

00:03:09,900 --> 00:03:12,840
it was unquestionably the premier

00:03:11,310 --> 00:03:14,760
software development system for the Mac

00:03:12,840 --> 00:03:16,859
it was what Apple's own engineers used

00:03:14,760 --> 00:03:18,840
to write Macintosh code given that Mac

00:03:16,859 --> 00:03:20,549
OS was far more technologically advanced

00:03:18,840 --> 00:03:22,620
at the time than its competition and

00:03:20,549 --> 00:03:24,660
that Linux did not even exist yet and

00:03:22,620 --> 00:03:26,819
given this was the actual program used

00:03:24,660 --> 00:03:29,190
by Apple's world-class team of creative

00:03:26,819 --> 00:03:30,870
engineers I had high expectations it

00:03:29,190 --> 00:03:32,670
arrived on a stack of floppy disks about

00:03:30,870 --> 00:03:34,109
a foot high and so there were plenty of

00:03:32,670 --> 00:03:35,940
time for my excitement to bill during

00:03:34,109 --> 00:03:38,250
the endless installation process the

00:03:35,940 --> 00:03:39,510
first time I launched mpw I was probably

00:03:38,250 --> 00:03:41,760
expecting some kind of touchy-feely

00:03:39,510 --> 00:03:43,859
multimedia showcase and said it was

00:03:41,760 --> 00:03:46,200
austere almost to the point of being

00:03:43,859 --> 00:03:48,299
intimidating so who's ever run in PW

00:03:46,200 --> 00:03:49,950
anybody like when you start it up gets

00:03:48,299 --> 00:03:52,380
literally just like a black and white

00:03:49,950 --> 00:03:54,810
terminal interface it's ugly as crap but

00:03:52,380 --> 00:03:56,280
it was really hard to use so developing

00:03:54,810 --> 00:03:59,489
for the Macintosh has always kind of

00:03:56,280 --> 00:04:01,470
sucked frankly the original system

00:03:59,489 --> 00:04:02,819
language for Macintosh was Pascal and

00:04:01,470 --> 00:04:04,889
even when they switched to C they

00:04:02,819 --> 00:04:06,450
carried those conventions into the C

00:04:04,889 --> 00:04:09,720
api's you had all these weird

00:04:06,450 --> 00:04:10,859
Pascal based naming conventions they had

00:04:09,720 --> 00:04:12,959
to give UN to use a thing called a

00:04:10,859 --> 00:04:14,790
handle who knows what a handle is so

00:04:12,959 --> 00:04:16,560
instead of like being able to use a

00:04:14,790 --> 00:04:17,760
pointer there sometimes would move their

00:04:16,560 --> 00:04:19,590
memory around so you had to use like

00:04:17,760 --> 00:04:21,410
pointers to pointers that were stored in

00:04:19,590 --> 00:04:22,250
a different location it was crap

00:04:21,410 --> 00:04:24,740
and then they replace it with

00:04:22,250 --> 00:04:26,660
objective-c which frankly is a syntax

00:04:24,740 --> 00:04:29,990
that not even objective C's mother likes

00:04:26,660 --> 00:04:32,360
all that much so I here I'm here to give

00:04:29,990 --> 00:04:34,370
you good news though Swift is the

00:04:32,360 --> 00:04:38,450
Macintosh of Apple programming languages

00:04:34,370 --> 00:04:39,830
it's actually very nice but much like

00:04:38,450 --> 00:04:41,990
the Macintosh there are things that you

00:04:39,830 --> 00:04:43,370
just can't do so you know they used to

00:04:41,990 --> 00:04:45,290
describe the Mac as the computer for the

00:04:43,370 --> 00:04:47,330
rest of us but it's also been described

00:04:45,290 --> 00:04:47,600
as a luxury car with the hood welded

00:04:47,330 --> 00:04:50,270
shut

00:04:47,600 --> 00:04:51,560
so there are things you cannot get you

00:04:50,270 --> 00:04:53,300
don't get to manage your own memory

00:04:51,560 --> 00:04:55,040
everything is reference counted if you

00:04:53,300 --> 00:04:58,430
want to manage your memory the rest

00:04:55,040 --> 00:05:00,380
people are down the block so let's talk

00:04:58,430 --> 00:05:02,570
about sort of syntax we're just going to

00:05:00,380 --> 00:05:04,040
do a very rapid overview of most of the

00:05:02,570 --> 00:05:06,260
language for the remainder of the talk

00:05:04,040 --> 00:05:09,040
so it supports comments uses double

00:05:06,260 --> 00:05:12,560
slashes it also supports C style

00:05:09,040 --> 00:05:15,140
multi-line comments fairly standard it

00:05:12,560 --> 00:05:17,090
supports nested comments which you've

00:05:15,140 --> 00:05:18,650
ever tried to comment out a big block of

00:05:17,090 --> 00:05:21,110
stuff with a comment inside of it you

00:05:18,650 --> 00:05:22,990
will appreciate it's got documentation

00:05:21,110 --> 00:05:25,340
comments those these three slashes and

00:05:22,990 --> 00:05:28,340
it comes with variables like most

00:05:25,340 --> 00:05:30,530
programming languages do so Swift is

00:05:28,340 --> 00:05:32,840
strongly typed but it also does sort of

00:05:30,530 --> 00:05:35,120
maximal type inference so this is a

00:05:32,840 --> 00:05:36,320
variable Swift is going to figure out

00:05:35,120 --> 00:05:37,700
that that's an integer because you're

00:05:36,320 --> 00:05:39,740
assigning an integer to it you don't

00:05:37,700 --> 00:05:41,090
have to tell it that or if you want to

00:05:39,740 --> 00:05:44,060
make an integer and not give it a

00:05:41,090 --> 00:05:46,430
default value you can say this variable

00:05:44,060 --> 00:05:50,360
bar is an int this is how you do a

00:05:46,430 --> 00:05:53,120
string and if we do this this other

00:05:50,360 --> 00:05:55,160
keyword let let introduces in a mutable

00:05:53,120 --> 00:05:56,900
variable here so if we say let bar

00:05:55,160 --> 00:05:58,340
equals 1 and then try to modify it that

00:05:56,900 --> 00:06:00,350
red should actually be on the next line

00:05:58,340 --> 00:06:03,320
that will give you a compile time error

00:06:00,350 --> 00:06:05,360
if you can't modify bar and the Swift

00:06:03,320 --> 00:06:07,130
documentation actually encourages you to

00:06:05,360 --> 00:06:12,740
use immutable variables whenever

00:06:07,130 --> 00:06:16,010
possible so yay good on them if you do

00:06:12,740 --> 00:06:17,900
that that's also a compile time error

00:06:16,010 --> 00:06:20,500
because you haven't provided an

00:06:17,900 --> 00:06:23,930
initialization value switch can't figure

00:06:20,500 --> 00:06:25,820
bar is and so it won't let you do that

00:06:23,930 --> 00:06:29,240
you can't have an uninitialized untyped

00:06:25,820 --> 00:06:31,910
variable you also even if you said let

00:06:29,240 --> 00:06:34,130
bar colon int you wouldn't be able to do

00:06:31,910 --> 00:06:35,840
anything with bar until you assigned a

00:06:34,130 --> 00:06:37,340
value to it you cannot use an

00:06:35,840 --> 00:06:41,950
uninitialized variable for anything

00:06:37,340 --> 00:06:44,930
that's also a compile fun manner yay

00:06:41,950 --> 00:06:46,490
all right so operators Swift has your

00:06:44,930 --> 00:06:48,229
sort of standard set of operators so if

00:06:46,490 --> 00:06:50,180
we define an immutable variable N and

00:06:48,229 --> 00:06:52,490
set it to the value of 1 we can check

00:06:50,180 --> 00:06:53,840
and see if n is greater than 1 so you

00:06:52,490 --> 00:06:54,770
don't have to put parentheses around

00:06:53,840 --> 00:06:56,840
conditionals

00:06:54,770 --> 00:06:58,039
it's very nice syntax you do get you

00:06:56,840 --> 00:06:59,600
know your standard kind of code block

00:06:58,039 --> 00:07:04,700
thing which in this case won't execute

00:06:59,600 --> 00:07:06,530
because it is not greater than 1 this is

00:07:04,700 --> 00:07:09,680
how you define an array so that's an

00:07:06,530 --> 00:07:10,910
array literal on the right there now

00:07:09,680 --> 00:07:12,560
we're going to define a counter variable

00:07:10,910 --> 00:07:14,690
and then we're going to loop over the

00:07:12,560 --> 00:07:16,880
array so this syntax should look very

00:07:14,690 --> 00:07:18,740
familiar to Perl programmers we're just

00:07:16,880 --> 00:07:23,120
going to add up that some at the end

00:07:18,740 --> 00:07:25,550
some will be 10 the flow control

00:07:23,120 --> 00:07:27,950
operators is an index operator this will

00:07:25,550 --> 00:07:30,280
give you all of the values between 1 and

00:07:27,950 --> 00:07:32,870
10 there's a slightly different one that

00:07:30,280 --> 00:07:34,490
doesn't give you the terminal value so

00:07:32,870 --> 00:07:37,390
that will only run nine times that will

00:07:34,490 --> 00:07:37,390
count up one through nine

00:07:39,910 --> 00:07:43,820
you also get while loop so here we're

00:07:42,410 --> 00:07:46,280
making a variable 5 and we're going to

00:07:43,820 --> 00:07:48,620
count down this is an older slide so

00:07:46,280 --> 00:07:50,500
they actually in Swift 3 removed the

00:07:48,620 --> 00:07:55,250
increment and decrement operators

00:07:50,500 --> 00:07:56,450
whether we have fans of that so you

00:07:55,250 --> 00:08:00,140
actually have to spell this like this

00:07:56,450 --> 00:08:01,850
now minus equal 1 and then it's just a

00:08:00,140 --> 00:08:05,690
standard while loop right it's going to

00:08:01,850 --> 00:08:08,120
run five times slightly different form

00:08:05,690 --> 00:08:11,000
this is what in Perl we would call do

00:08:08,120 --> 00:08:12,650
while they call repeat while and the

00:08:11,000 --> 00:08:15,740
same thing the the increment operator

00:08:12,650 --> 00:08:20,180
doesn't exist anymore so you just repeat

00:08:15,740 --> 00:08:23,840
while and then it counts up switch also

00:08:20,180 --> 00:08:25,640
has case statements so you introduce

00:08:23,840 --> 00:08:27,590
those with switch you're going to switch

00:08:25,640 --> 00:08:30,229
on a particular variable and then you

00:08:27,590 --> 00:08:32,900
just list out the various cases so here

00:08:30,229 --> 00:08:34,610
we're looking for 0 or 2 and we're

00:08:32,900 --> 00:08:36,200
matching against an integer variable so

00:08:34,610 --> 00:08:38,540
the things in the case statements need

00:08:36,200 --> 00:08:40,669
to be an integer Swift does not fall

00:08:38,540 --> 00:08:42,290
through by default you don't have to put

00:08:40,669 --> 00:08:44,990
a break at the end of your case

00:08:42,290 --> 00:08:47,020
yay you can fall through but you have to

00:08:44,990 --> 00:08:50,540
explicitly say I want to fall through

00:08:47,020 --> 00:08:52,580
and you are also required to your switch

00:08:50,540 --> 00:08:54,410
state switch statements are required to

00:08:52,580 --> 00:08:56,570
be exhaustive so you need to cover all

00:08:54,410 --> 00:08:58,130
possible cases which means that in this

00:08:56,570 --> 00:08:59,000
case if you're switching on integers

00:08:58,130 --> 00:09:01,040
you're going to want to provide a

00:08:59,000 --> 00:09:02,360
default because listing out all of the

00:09:01,040 --> 00:09:07,280
possible integers will take you a long

00:09:02,360 --> 00:09:10,070
time we'll see some examples there there

00:09:07,280 --> 00:09:11,750
are non exhaustive switch statements so

00:09:10,070 --> 00:09:13,370
you can also switch on strings here

00:09:11,750 --> 00:09:15,620
we're looking for cases who in case bar

00:09:13,370 --> 00:09:20,000
and again we have to provide a default

00:09:15,620 --> 00:09:21,980
because it's not exhaustive you can also

00:09:20,000 --> 00:09:25,100
switch on more complex variable so this

00:09:21,980 --> 00:09:26,150
is what sort called a tuple or tuple if

00:09:25,100 --> 00:09:27,890
you're one of the people who like to

00:09:26,150 --> 00:09:30,440
pronounce it that way and this is just a

00:09:27,890 --> 00:09:33,800
collection of variables the closest pro

00:09:30,440 --> 00:09:35,630
analogue would just be an array and this

00:09:33,800 --> 00:09:38,270
is actually in this particular example

00:09:35,630 --> 00:09:40,340
this is a legal well no it's not I could

00:09:38,270 --> 00:09:43,670
go back so then we're going to switch on

00:09:40,340 --> 00:09:46,520
that and we need to match both places in

00:09:43,670 --> 00:09:48,290
that tupple we can use this underscore

00:09:46,520 --> 00:09:51,680
here which means I don't care what that

00:09:48,290 --> 00:09:52,970
value is at that position I'm just

00:09:51,680 --> 00:09:54,290
looking at the first variable but

00:09:52,970 --> 00:09:55,880
because you're matching on something

00:09:54,290 --> 00:09:57,440
with two elements you have to account

00:09:55,880 --> 00:10:00,950
for both of those in your in your case

00:09:57,440 --> 00:10:03,680
statements I just shown that underscore

00:10:00,950 --> 00:10:05,720
and then here is an example of doing

00:10:03,680 --> 00:10:07,730
what's called a destructuring bind as

00:10:05,720 --> 00:10:09,920
part of the case so what is going to

00:10:07,730 --> 00:10:11,690
happen here is we've got this couple

00:10:09,920 --> 00:10:13,220
we're going to be switching on that

00:10:11,690 --> 00:10:14,810
tupple we're going to look at the values

00:10:13,220 --> 00:10:16,160
and the it's not going to match two and

00:10:14,810 --> 00:10:17,930
three so we're going to fall through to

00:10:16,160 --> 00:10:20,300
this case and what we're going to do is

00:10:17,930 --> 00:10:22,280
assign one and two to the first and

00:10:20,300 --> 00:10:25,130
second position in the tupple and then

00:10:22,280 --> 00:10:26,620
we can use them in the block here this

00:10:25,130 --> 00:10:29,630
is how swift does string interpolation

00:10:26,620 --> 00:10:32,120
variable interpolation and strings we

00:10:29,630 --> 00:10:33,650
don't need a default case here because

00:10:32,120 --> 00:10:35,780
this case where we're just matching the

00:10:33,650 --> 00:10:37,610
two elements will always match something

00:10:35,780 --> 00:10:40,300
if you're binding against two elements

00:10:37,610 --> 00:10:40,300
Uppal yeah in the back

00:10:41,260 --> 00:10:46,400
yes yes and I'll show an example that a

00:10:44,630 --> 00:10:48,140
minute

00:10:46,400 --> 00:10:50,390
so strings this is how you make a

00:10:48,140 --> 00:10:52,040
literal string strings have methods on

00:10:50,390 --> 00:10:54,680
them so this is how you check to see if

00:10:52,040 --> 00:10:57,170
a string has something in it

00:10:54,680 --> 00:11:00,050
string support concatenation using the

00:10:57,170 --> 00:11:02,350
plus operator not my favorite feature in

00:11:00,050 --> 00:11:07,580
a language but yeah question

00:11:02,350 --> 00:11:10,520
no Swifton is very strongly typed as I

00:11:07,580 --> 00:11:13,250
mentioned so here we have typing so here

00:11:10,520 --> 00:11:15,710
foo isn't Swift can infer that because

00:11:13,250 --> 00:11:18,350
you've assigned in into it that's how

00:11:15,710 --> 00:11:20,660
you do an uninitialized as I said before

00:11:18,350 --> 00:11:23,120
you can also spell it that way you're

00:11:20,660 --> 00:11:25,100
assigning to the in class and that runs

00:11:23,120 --> 00:11:27,170
a constructor for you and this is

00:11:25,100 --> 00:11:31,520
keyword is how you check the type of

00:11:27,170 --> 00:11:34,760
something you can do some casting so if

00:11:31,520 --> 00:11:36,290
we make through an int and then we cast

00:11:34,760 --> 00:11:39,320
it to a string it'll turn into the

00:11:36,290 --> 00:11:42,830
string containing the character 1 you

00:11:39,320 --> 00:11:45,020
can do sort of optional casting

00:11:42,830 --> 00:11:46,580
basically using the as question mark

00:11:45,020 --> 00:11:49,070
operator and that's going to return an

00:11:46,580 --> 00:11:50,660
optionally type thing if it is a string

00:11:49,070 --> 00:11:52,790
and I'll talk about optional types in a

00:11:50,660 --> 00:11:55,040
minute you can also use this imperative

00:11:52,790 --> 00:11:57,020
form with the exclamation point in this

00:11:55,040 --> 00:11:59,210
case if string --is-- thing can't be

00:11:57,020 --> 00:12:02,030
cast to a string that will give you a

00:11:59,210 --> 00:12:03,290
runtime exception okay so it's not

00:12:02,030 --> 00:12:05,210
something that you generally want to do

00:12:03,290 --> 00:12:08,090
unless you're really sure furnish thing

00:12:05,210 --> 00:12:10,520
is actually castable to a string so

00:12:08,090 --> 00:12:14,600
what's an optional type so it doesn't

00:12:10,520 --> 00:12:18,290
have the notion of null this time give

00:12:14,600 --> 00:12:20,000
us I love thanks you use optional types

00:12:18,290 --> 00:12:22,100
when a variable may not have the value

00:12:20,000 --> 00:12:24,020
so this is how you define an int that

00:12:22,100 --> 00:12:26,060
might not have a value you just put a

00:12:24,020 --> 00:12:27,980
question mark after the type that's how

00:12:26,060 --> 00:12:30,200
you define an optional type and then

00:12:27,980 --> 00:12:33,530
before you use that you need to check

00:12:30,200 --> 00:12:35,420
and see whether it is equal to nil nil

00:12:33,530 --> 00:12:37,850
is what's in an optional type when it

00:12:35,420 --> 00:12:40,890
doesn't have a value so if bar is not

00:12:37,850 --> 00:12:43,890
equal to nil then it has a value

00:12:40,890 --> 00:12:45,960
and you can unwrap it and use it it's

00:12:43,890 --> 00:12:47,610
called unwrapping where you access the

00:12:45,960 --> 00:12:49,320
value that's inside the optionally type

00:12:47,610 --> 00:12:52,940
value and you do that by putting an

00:12:49,320 --> 00:12:56,100
exclamation point after the variable if

00:12:52,940 --> 00:12:58,560
you try to unwrap a nil value with this

00:12:56,100 --> 00:13:01,080
it's a runtime exception so these are

00:12:58,560 --> 00:13:02,640
just a couple of they're very few areas

00:13:01,080 --> 00:13:04,170
where you get runtime exceptions as

00:13:02,640 --> 00:13:06,450
opposed to compile time errors and

00:13:04,170 --> 00:13:08,870
unwrapping a nil value in trying to use

00:13:06,450 --> 00:13:13,380
it will cause your program to blow up

00:13:08,870 --> 00:13:15,930
there is a construct called let we're

00:13:13,380 --> 00:13:17,040
basically so you end up unwrapping these

00:13:15,930 --> 00:13:18,480
optional values all the time

00:13:17,040 --> 00:13:20,580
particularly if you're programming

00:13:18,480 --> 00:13:22,860
against objective-c EAP is because

00:13:20,580 --> 00:13:24,900
Objective C API is tended to return null

00:13:22,860 --> 00:13:26,910
for a bunch of things and when you're

00:13:24,900 --> 00:13:29,100
working with them and Swift they return

00:13:26,910 --> 00:13:31,290
optional types instead you're unwrapping

00:13:29,100 --> 00:13:34,350
the stuff fairly frequently so they have

00:13:31,290 --> 00:13:35,610
this construct if let-through equals bar

00:13:34,350 --> 00:13:41,070
bar

00:13:35,610 --> 00:13:43,590
let me type integer so if if bar has a

00:13:41,070 --> 00:13:46,650
value in it it will be assigned to foo

00:13:43,590 --> 00:13:47,850
and the block will run otherwise you're

00:13:46,650 --> 00:13:49,500
going to be down here in this else block

00:13:47,850 --> 00:13:53,430
and if you are in that else block it

00:13:49,500 --> 00:13:57,120
means that bar was nil right who has the

00:13:53,430 --> 00:14:00,780
unwrap value now you can also spell that

00:13:57,120 --> 00:14:02,790
if var foo and then inside the block foo

00:14:00,780 --> 00:14:04,890
will be mutable otherwise if you're

00:14:02,790 --> 00:14:06,720
using if let it's unwrapped into an

00:14:04,890 --> 00:14:10,560
unreadable variable which is the

00:14:06,720 --> 00:14:12,120
question somebody at write yet you all

00:14:10,560 --> 00:14:15,420
right so foo is no mutable in the block

00:14:12,120 --> 00:14:20,220
and we can add one to it so different

00:14:15,420 --> 00:14:21,900
types of variables so we talked about

00:14:20,220 --> 00:14:24,330
tuples this is a two element tuple

00:14:21,900 --> 00:14:26,850
containing a string and an integer you

00:14:24,330 --> 00:14:28,830
can access those via a dot and an

00:14:26,850 --> 00:14:31,890
indexing position so that will pull out

00:14:28,830 --> 00:14:33,690
the the string foo you can also use

00:14:31,890 --> 00:14:35,610
labels for those positions in the tuple

00:14:33,690 --> 00:14:37,710
so this point it becomes somewhat

00:14:35,610 --> 00:14:39,300
similar to a hash in Perl terms and then

00:14:37,710 --> 00:14:42,390
you can just index into them with the

00:14:39,300 --> 00:14:44,550
name so it also has a raise so this is

00:14:42,390 --> 00:14:47,640
what an array literal looks like this is

00:14:44,550 --> 00:14:49,080
how you declare an empty uninitialized

00:14:47,640 --> 00:14:52,290
array this would be an array of strings

00:14:49,080 --> 00:14:54,420
you can mix and match those or at least

00:14:52,290 --> 00:14:56,910
you used to be able to in Swift 2.2 if

00:14:54,420 --> 00:14:59,580
you try to do this in swift 3 it will

00:14:56,910 --> 00:15:01,470
 at you because it really wants you

00:14:59,580 --> 00:15:03,720
to one it doesn't want you to do this

00:15:01,470 --> 00:15:07,170
because what you're going to have to do

00:15:03,720 --> 00:15:09,090
is go back to the base type which is

00:15:07,170 --> 00:15:13,230
spelled in E so you actually have to

00:15:09,090 --> 00:15:14,640
declare that array like this you have to

00:15:13,230 --> 00:15:16,980
say that I'm going to have a grab-bag of

00:15:14,640 --> 00:15:20,190
stuff and they really don't want you to

00:15:16,980 --> 00:15:22,620
do that it's considered bad practice

00:15:20,190 --> 00:15:24,540
so if has dictionaries which are also

00:15:22,620 --> 00:15:25,590
sort of similar to hashes and pearls so

00:15:24,540 --> 00:15:29,100
this is how we would declare a

00:15:25,590 --> 00:15:31,680
dictionary called capital city states it

00:15:29,100 --> 00:15:34,340
will have this type of string mapped to

00:15:31,680 --> 00:15:37,410
string that's how you type a dictionary

00:15:34,340 --> 00:15:39,840
if we try to make a dictionary like this

00:15:37,410 --> 00:15:42,450
in Swift 3 that will actually give you

00:15:39,840 --> 00:15:44,220
an error because the values are not a

00:15:42,450 --> 00:15:46,770
consistent type you would have to go

00:15:44,220 --> 00:15:50,030
through and actually explicitly annotate

00:15:46,770 --> 00:15:54,720
this as a string map to any dictionary

00:15:50,030 --> 00:15:56,100
otherwise it's compiled type error and

00:15:54,720 --> 00:16:00,390
so that is this is what that would look

00:15:56,100 --> 00:16:02,070
like don't do this so it has a variable

00:16:00,390 --> 00:16:04,200
type called sets which is just a

00:16:02,070 --> 00:16:06,330
collection of things that work basically

00:16:04,200 --> 00:16:08,640
like mathematical sets so here where you

00:16:06,330 --> 00:16:11,870
declare a set and you actually have to

00:16:08,640 --> 00:16:14,040
specifically type things as sets a set a

00:16:11,870 --> 00:16:16,590
variable type will never be inferred

00:16:14,040 --> 00:16:18,300
because you use an array literal for the

00:16:16,590 --> 00:16:19,800
assignment if you don't say this is a

00:16:18,300 --> 00:16:23,460
set it's going to infer that it's an

00:16:19,800 --> 00:16:26,070
array but if we have so we have dog in

00:16:23,460 --> 00:16:27,600
here twice but sets only contain things

00:16:26,070 --> 00:16:29,940
or don't contain things so if we look at

00:16:27,600 --> 00:16:32,160
the size of that set it's going to

00:16:29,940 --> 00:16:34,850
return 3 because there's only three

00:16:32,160 --> 00:16:34,850
unique things

00:16:36,329 --> 00:16:43,779
all right functions so this is how you

00:16:40,239 --> 00:16:46,449
do a fifth this is called AAB example

00:16:43,779 --> 00:16:48,039
and it just prints out hello Perl and if

00:16:46,449 --> 00:16:49,809
you run it you call it like this with

00:16:48,039 --> 00:16:52,269
the parentheses and that will print out

00:16:49,809 --> 00:16:55,149
hello Perl this is a function that takes

00:16:52,269 --> 00:16:58,119
an argument all parameters have to have

00:16:55,149 --> 00:17:00,519
a name and a type so here we're going to

00:16:58,119 --> 00:17:02,769
take a string argument and we're going

00:17:00,519 --> 00:17:04,750
to return just the hello string and

00:17:02,769 --> 00:17:06,309
interpolate that variable in it so if we

00:17:04,750 --> 00:17:08,649
called it like this it would print out

00:17:06,309 --> 00:17:09,789
hello the Perl conference and now I'm

00:17:08,649 --> 00:17:13,360
going to step through those slides of

00:17:09,789 --> 00:17:15,159
highlighting this is how you have a

00:17:13,360 --> 00:17:16,990
string that returns a value you say

00:17:15,159 --> 00:17:18,819
arrow and the type of the value that's

00:17:16,990 --> 00:17:23,110
going to be returned you can return

00:17:18,819 --> 00:17:24,639
multiple values as a tupple then then

00:17:23,110 --> 00:17:26,319
that just does the same thing as before

00:17:24,639 --> 00:17:29,309
but instead of printing the string it's

00:17:26,319 --> 00:17:29,309
returning the string

00:17:33,150 --> 00:17:37,290
here is how you have provided the fault

00:17:35,670 --> 00:17:39,660
value for an argument

00:17:37,290 --> 00:17:44,400
so you just include that after the type

00:17:39,660 --> 00:17:46,110
information and then if you call the you

00:17:44,400 --> 00:17:47,580
can call it with a value and it'll get

00:17:46,110 --> 00:17:49,950
used otherwise you can call it without

00:17:47,580 --> 00:17:52,470
the value and it will use the default so

00:17:49,950 --> 00:17:54,690
none of this is probably all that

00:17:52,470 --> 00:17:57,090
terribly surprising to anybody it's just

00:17:54,690 --> 00:18:03,660
nice it pretty much works like you would

00:17:57,090 --> 00:18:05,670
expect you can also use different names

00:18:03,660 --> 00:18:08,220
for the parameters here and in this case

00:18:05,670 --> 00:18:10,710
the first value is how you call the

00:18:08,220 --> 00:18:12,300
function the second name is what that

00:18:10,710 --> 00:18:15,330
value gets assigned to inside the

00:18:12,300 --> 00:18:18,000
function so you can see here we're using

00:18:15,330 --> 00:18:20,400
them in the interpolated string but when

00:18:18,000 --> 00:18:28,020
we call the function we're actually

00:18:20,400 --> 00:18:30,690
providing it as whoo right so you can

00:18:28,020 --> 00:18:33,120
also use the underscore here as the

00:18:30,690 --> 00:18:35,100
public name and in that case you don't

00:18:33,120 --> 00:18:37,320
provide a parameter name for it so if we

00:18:35,100 --> 00:18:39,060
call this function like this it'll use

00:18:37,320 --> 00:18:41,190
the default value for the second

00:18:39,060 --> 00:18:43,530
parameter if we call it like this and

00:18:41,190 --> 00:18:44,940
specify who which is the internal name

00:18:43,530 --> 00:18:47,340
that's actually a compile-time error

00:18:44,940 --> 00:18:50,430
because there is no function with that

00:18:47,340 --> 00:18:51,780
signature the parameter names are

00:18:50,430 --> 00:18:54,480
actually considered to be part of the

00:18:51,780 --> 00:18:55,890
function signature the way you do multi

00:18:54,480 --> 00:18:58,110
methods and Swift is you have different

00:18:55,890 --> 00:19:00,240
parameter lists and the same function

00:18:58,110 --> 00:19:01,380
name because again the function names

00:19:00,240 --> 00:19:02,340
are part of the signature or the

00:19:01,380 --> 00:19:04,170
parameter names are part of the

00:19:02,340 --> 00:19:05,610
signature so you would actually have to

00:19:04,170 --> 00:19:07,790
call this function like this and not

00:19:05,610 --> 00:19:11,670
include a parameter for that second a

00:19:07,790 --> 00:19:14,290
parameter name for the second parameter

00:19:11,670 --> 00:19:18,520
this was one of the bigger warts in my

00:19:14,290 --> 00:19:20,260
opinion in Swift 2.2 was the parameter

00:19:18,520 --> 00:19:22,240
calling conventions around the functions

00:19:20,260 --> 00:19:24,429
were really weird you never included a

00:19:22,240 --> 00:19:26,740
first parameter except sometimes you did

00:19:24,429 --> 00:19:28,179
and you always had to include the

00:19:26,740 --> 00:19:30,130
subsequent parameters except when you

00:19:28,179 --> 00:19:32,950
didn't and it didn't make a whole lot of

00:19:30,130 --> 00:19:34,300
sense it still doesn't make a tremendous

00:19:32,950 --> 00:19:36,040
amount of sense because you always have

00:19:34,300 --> 00:19:37,540
to provide the parameters in the order

00:19:36,040 --> 00:19:39,280
they are given in the function signature

00:19:37,540 --> 00:19:42,190
despite the fact that they all have

00:19:39,280 --> 00:19:45,850
names you cannot call this function is

00:19:42,190 --> 00:19:47,290
of example something what because that's

00:19:45,850 --> 00:19:48,640
not the order that the parameters are

00:19:47,290 --> 00:19:50,860
given in the function signature they

00:19:48,640 --> 00:19:52,450
always have to be in that order despite

00:19:50,860 --> 00:19:54,460
the fact that you would think it could

00:19:52,450 --> 00:19:57,580
figure it out but that's just not a

00:19:54,460 --> 00:20:00,250
language words you can also have very

00:19:57,580 --> 00:20:02,050
eidetic functions where you put a dot

00:20:00,250 --> 00:20:03,790
dot dot after your type and so you're

00:20:02,050 --> 00:20:05,590
going to pass multiple integers to this

00:20:03,790 --> 00:20:09,240
function and internally it's going to

00:20:05,590 --> 00:20:09,240
receive them as an array of industries

00:20:10,230 --> 00:20:14,710
functions are first class citizens as

00:20:12,550 --> 00:20:17,260
you would expect from a modern

00:20:14,710 --> 00:20:18,850
programming language and sort of

00:20:17,260 --> 00:20:21,990
supports something called closures which

00:20:18,850 --> 00:20:24,880
don't exactly work like pro closures

00:20:21,990 --> 00:20:27,400
don't be fooled by the name this is a

00:20:24,880 --> 00:20:30,580
closure here so we're passing a function

00:20:27,400 --> 00:20:32,650
to the sorted method of an array to tell

00:20:30,580 --> 00:20:34,510
it how to sort itself and the way a

00:20:32,650 --> 00:20:37,420
closure works is you start out with the

00:20:34,510 --> 00:20:38,830
type signature of the function and then

00:20:37,420 --> 00:20:41,830
you have the word in and then you have

00:20:38,830 --> 00:20:45,010
the actual code so what we're doing here

00:20:41,830 --> 00:20:46,900
is saying am I'm going to give you a

00:20:45,010 --> 00:20:49,240
function that takes two integers in one

00:20:46,900 --> 00:20:51,400
and n 2 and returns a boolean and then

00:20:49,240 --> 00:20:54,179
the code is going to execute this

00:20:51,400 --> 00:20:56,080
comparison and return it so greater than

00:20:54,179 --> 00:20:58,350
comparison operator is going to return a

00:20:56,080 --> 00:20:58,350
bool

00:20:58,990 --> 00:21:07,010
all right cool going please ask so

00:21:03,970 --> 00:21:10,760
that's already the functions function

00:21:07,010 --> 00:21:13,549
signature for sorted okay this this

00:21:10,760 --> 00:21:16,760
should say sorted the sorted method on

00:21:13,549 --> 00:21:19,640
an array is defined to take a single

00:21:16,760 --> 00:21:21,890
parameter called by it takes a function

00:21:19,640 --> 00:21:25,130
that takes two integers and returns a

00:21:21,890 --> 00:21:27,320
bool so this information here in red the

00:21:25,130 --> 00:21:28,970
compiler already knows and if you try to

00:21:27,320 --> 00:21:30,980
pass it a function that took three

00:21:28,970 --> 00:21:34,000
integers and returned an integer it

00:21:30,980 --> 00:21:37,400
wouldn't compile right because this

00:21:34,000 --> 00:21:39,169
sorted function has a by parameter that

00:21:37,400 --> 00:21:41,179
takes a function that takes two integers

00:21:39,169 --> 00:21:42,740
and returns a bool so you don't actually

00:21:41,179 --> 00:21:45,530
need its helps with this it already

00:21:42,740 --> 00:21:47,450
knows it so you don't have to you can

00:21:45,530 --> 00:21:48,559
actually call that code like this where

00:21:47,450 --> 00:21:52,669
you're just giving the two parameters

00:21:48,559 --> 00:21:57,200
and then the function to execute right

00:21:52,669 --> 00:21:59,419
so that's nice you also if you don't

00:21:57,200 --> 00:22:01,039
name the parameters the parameters get

00:21:59,419 --> 00:22:02,720
named positionally in a way that will be

00:22:01,039 --> 00:22:05,600
very familiar to Perl programmers it

00:22:02,720 --> 00:22:08,600
uses dollar zero dollar one dollar two

00:22:05,600 --> 00:22:10,340
for the first second and so on so you

00:22:08,600 --> 00:22:12,380
can actually spell that function like

00:22:10,340 --> 00:22:15,620
this where you don't give it a parameter

00:22:12,380 --> 00:22:17,480
list you just say return the first

00:22:15,620 --> 00:22:19,039
argument greater than the second

00:22:17,480 --> 00:22:25,809
argument metals that'll still return a

00:22:19,039 --> 00:22:29,390
bool probably yeah okay thank you

00:22:25,809 --> 00:22:34,280
you win the prize there's a free soda in

00:22:29,390 --> 00:22:36,320
the back just for you you also don't

00:22:34,280 --> 00:22:37,820
need to specify the return because Swift

00:22:36,320 --> 00:22:39,980
always returns the value of the last

00:22:37,820 --> 00:22:41,870
expression in the function so you can

00:22:39,980 --> 00:22:43,490
actually spell that like that and when

00:22:41,870 --> 00:22:44,690
you get the closure down that much you

00:22:43,490 --> 00:22:47,570
also don't need to include the

00:22:44,690 --> 00:22:49,870
parentheses on the sorted function call

00:22:47,570 --> 00:22:55,000
or the parameter name

00:22:49,870 --> 00:22:59,710
so code does exactly the same thing as

00:22:55,000 --> 00:23:01,029
that code this is a little confusing

00:22:59,710 --> 00:23:02,289
when you first start programming it

00:23:01,029 --> 00:23:04,059
because they teach you to do it like

00:23:02,289 --> 00:23:06,250
this and then you see code that does

00:23:04,059 --> 00:23:11,010
that and you're like what the hell is

00:23:06,250 --> 00:23:13,090
going on so but it is nice so if is also

00:23:11,010 --> 00:23:14,710
object-oriented out-of-the-box so you

00:23:13,090 --> 00:23:17,110
can define a class this is a class

00:23:14,710 --> 00:23:19,120
called dog that will compile and work

00:23:17,110 --> 00:23:21,640
that's a perfectly legal class classes

00:23:19,120 --> 00:23:25,779
also defined types so that will define a

00:23:21,640 --> 00:23:28,330
type called dog this is how you do

00:23:25,779 --> 00:23:30,159
properties which in Perl we usually call

00:23:28,330 --> 00:23:32,020
attributes so here we're going to have a

00:23:30,159 --> 00:23:33,429
variable name and we're going to have a

00:23:32,020 --> 00:23:36,490
noise that the dog makes that's

00:23:33,429 --> 00:23:38,110
immutable called woof they're just

00:23:36,490 --> 00:23:41,649
variable declarations inside the class

00:23:38,110 --> 00:23:43,330
this won't actually compile because what

00:23:41,649 --> 00:23:45,730
you have here is an uninitialized

00:23:43,330 --> 00:23:47,260
variable so swift will at you and

00:23:45,730 --> 00:23:48,399
say you have an uninitialized variable

00:23:47,260 --> 00:23:50,620
and you don't have a constructor

00:23:48,399 --> 00:23:53,890
function to set the value of it yet

00:23:50,620 --> 00:23:56,200
dummy and this is what the error message

00:23:53,890 --> 00:23:58,450
actually looks like so one way to work

00:23:56,200 --> 00:24:00,490
around that is to make the property

00:23:58,450 --> 00:24:02,710
optionally types by putting a question

00:24:00,490 --> 00:24:04,510
mark after it so then you would anytime

00:24:02,710 --> 00:24:06,039
you try to access the dog name you would

00:24:04,510 --> 00:24:08,140
need to unwrap it because it's an

00:24:06,039 --> 00:24:11,320
optionally typed attribute at that point

00:24:08,140 --> 00:24:13,659
or you can define an initializer which

00:24:11,320 --> 00:24:15,940
Swift spells in it and we make that take

00:24:13,659 --> 00:24:19,059
a name and then we set the name of

00:24:15,940 --> 00:24:21,730
ourselves to name and now we can go back

00:24:19,059 --> 00:24:23,890
to having that be a non optional type

00:24:21,730 --> 00:24:25,480
because in order to make a dog we have

00:24:23,890 --> 00:24:28,260
to give it a name which is good because

00:24:25,480 --> 00:24:32,830
dog should have names so there's that

00:24:28,260 --> 00:24:34,809
inside the inside the class code you

00:24:32,830 --> 00:24:36,820
normally don't need to say self if

00:24:34,809 --> 00:24:38,620
you're trying to modify an attribute you

00:24:36,820 --> 00:24:40,390
can normally just give the name of the

00:24:38,620 --> 00:24:42,309
attribute you don't have to say self dot

00:24:40,390 --> 00:24:45,159
attribute name but in this case because

00:24:42,309 --> 00:24:47,260
the variable in the function signature

00:24:45,159 --> 00:24:49,299
the property is called name we have to

00:24:47,260 --> 00:24:50,980
say self dot name here to distinguish it

00:24:49,299 --> 00:24:54,360
from the argument that was passed in if

00:24:50,980 --> 00:24:54,360
we called that something else

00:24:55,030 --> 00:25:00,010
nom for example we could just say name

00:24:57,610 --> 00:25:02,020
equals nom and it would figure out that

00:25:00,010 --> 00:25:04,060
we reciting to the name property of the

00:25:02,020 --> 00:25:07,780
object that the method is being called

00:25:04,060 --> 00:25:09,730
on so it also supports the initializers

00:25:07,780 --> 00:25:11,350
these are called the-- so any kind of

00:25:09,730 --> 00:25:12,610
cleanup code that you needed to do if

00:25:11,350 --> 00:25:14,170
you needed to hang up a database

00:25:12,610 --> 00:25:18,340
connection or whatever you could put in

00:25:14,170 --> 00:25:19,930
their swift also supports methods and

00:25:18,340 --> 00:25:22,660
those are just functions that are

00:25:19,930 --> 00:25:25,810
defined inside the class they'll have

00:25:22,660 --> 00:25:27,280
access to self so here we just have a

00:25:25,810 --> 00:25:28,930
function signature for something called

00:25:27,280 --> 00:25:30,970
speak that returns a string and we're

00:25:28,930 --> 00:25:35,380
going to return the value of self noise

00:25:30,970 --> 00:25:36,880
which is a string so using objects looks

00:25:35,380 --> 00:25:39,130
like this this is how you make a dog

00:25:36,880 --> 00:25:40,120
object we have to give it a name so

00:25:39,130 --> 00:25:42,190
we're going to have a variable called

00:25:40,120 --> 00:25:44,410
Sammy that's an immutable variable of

00:25:42,190 --> 00:25:46,000
type dog with a name Sammy

00:25:44,410 --> 00:25:49,540
because that happens to be by dog's name

00:25:46,000 --> 00:25:52,960
and then if we checked with is Sammy is

00:25:49,540 --> 00:25:56,320
a dog if we print Sammy name it'll print

00:25:52,960 --> 00:25:59,740
out Sammy if we print Sammy speak it

00:25:56,320 --> 00:26:01,510
will print wolf and we can change him if

00:25:59,740 --> 00:26:04,390
we want to because the name attribute

00:26:01,510 --> 00:26:06,310
was defined as a bar so it's mutable so

00:26:04,390 --> 00:26:08,620
we can just assign to it and it will

00:26:06,310 --> 00:26:11,440
change the name although I'm not

00:26:08,620 --> 00:26:14,410
changing Sammy's name you can also do

00:26:11,440 --> 00:26:17,110
computed properties so if you have a

00:26:14,410 --> 00:26:20,860
property you can put a block on it and

00:26:17,110 --> 00:26:23,020
then have get and set basically sub

00:26:20,860 --> 00:26:25,150
blocks inside there and that will be

00:26:23,020 --> 00:26:26,980
code that runs when you try to get the

00:26:25,150 --> 00:26:29,500
variable so this is computing a value

00:26:26,980 --> 00:26:31,320
for the dog's age by subtracting the

00:26:29,500 --> 00:26:34,480
dog's birth year from the current year

00:26:31,320 --> 00:26:37,090
you can also have a setter that will be

00:26:34,480 --> 00:26:40,720
passed the new value so if you assign to

00:26:37,090 --> 00:26:42,730
age this function gets called and it

00:26:40,720 --> 00:26:44,560
gets passed something as called new

00:26:42,730 --> 00:26:47,830
value that's the value that you're

00:26:44,560 --> 00:26:49,690
trying to set so this is actually

00:26:47,830 --> 00:26:51,340
horrible don't do this like this is the

00:26:49,690 --> 00:26:54,160
worst kind of date handling code

00:26:51,340 --> 00:26:56,350
possibly ever so just don't look too

00:26:54,160 --> 00:26:58,300
much at that example you can also if you

00:26:56,350 --> 00:26:59,680
want provide a name for the variable

00:26:58,300 --> 00:27:01,240
that you're going to be passed in if you

00:26:59,680 --> 00:27:02,710
don't like calling things new value and

00:27:01,240 --> 00:27:04,810
in that case you you know here if we

00:27:02,710 --> 00:27:05,330
call it age then we use a H down here

00:27:04,810 --> 00:27:07,610
instead of you

00:27:05,330 --> 00:27:11,330
value and again this is horrible don't

00:27:07,610 --> 00:27:13,280
do this there are a couple of other

00:27:11,330 --> 00:27:14,840
things you can put in there and that

00:27:13,280 --> 00:27:18,350
didn't fit on the previous slide so in

00:27:14,840 --> 00:27:21,110
addition to get and set there are others

00:27:18,350 --> 00:27:23,300
called will set and did set those happen

00:27:21,110 --> 00:27:27,950
immediately prior to the value being set

00:27:23,300 --> 00:27:28,910
and after the value being set so those

00:27:27,950 --> 00:27:35,930
are useful

00:27:28,910 --> 00:27:38,180
all right so inheritance this is how we

00:27:35,930 --> 00:27:39,950
say that so if we define a base class

00:27:38,180 --> 00:27:41,990
animal this is how we say that dog

00:27:39,950 --> 00:27:47,990
inherits from animal we just say : and

00:27:41,990 --> 00:27:49,970
then the type and then if we fill out

00:27:47,990 --> 00:27:51,170
these two classes a little bit so we're

00:27:49,970 --> 00:27:52,670
going to have animals are going to have

00:27:51,170 --> 00:27:54,740
a name they're going to have an

00:27:52,670 --> 00:27:57,770
initializer that sets the name and then

00:27:54,740 --> 00:28:00,800
here down in dog if we want to override

00:27:57,770 --> 00:28:02,870
a function in a child class we have to

00:28:00,800 --> 00:28:05,270
annotate that function with the override

00:28:02,870 --> 00:28:08,930
keyword so here we're saying yeah we're

00:28:05,270 --> 00:28:10,790
overriding the initializer super is a

00:28:08,930 --> 00:28:12,470
way to call things in the parent class

00:28:10,790 --> 00:28:15,710
so here we're just calling the parent

00:28:12,470 --> 00:28:22,280
initializer with the same value at the

00:28:15,710 --> 00:28:23,930
name value that override is not just for

00:28:22,280 --> 00:28:25,940
initializers if you want to override any

00:28:23,930 --> 00:28:27,170
function in your child class that's

00:28:25,940 --> 00:28:28,940
defined in the parent class you

00:28:27,170 --> 00:28:31,190
specifically have to say override and

00:28:28,940 --> 00:28:33,230
what this prevents is sometimes if you

00:28:31,190 --> 00:28:34,840
have a very complicated object hierarchy

00:28:33,230 --> 00:28:37,640
which I'm sure none of us have never

00:28:34,840 --> 00:28:43,190
accidentally set up you can occasionally

00:28:37,640 --> 00:28:44,269
override function so if you try to

00:28:43,190 --> 00:28:45,589
accidentally

00:28:44,269 --> 00:28:47,059
write something swittel complaining

00:28:45,589 --> 00:28:49,320
which they know you need to be explicit

00:28:47,059 --> 00:28:50,880
about this you can't happen

00:28:49,320 --> 00:28:53,169
[Music]

00:28:50,880 --> 00:28:54,580
Swift also supports a couple of other

00:28:53,169 --> 00:28:57,490
value types that are sort of like

00:28:54,580 --> 00:28:58,809
objects called struts and enumeration so

00:28:57,490 --> 00:29:00,190
this is how you would define a struct

00:28:58,809 --> 00:29:02,440
that looks very much like a clouds

00:29:00,190 --> 00:29:05,679
because the structured you can have

00:29:02,440 --> 00:29:07,750
attributes you can have an initializer

00:29:05,679 --> 00:29:10,090
here we're setting up our two attributes

00:29:07,750 --> 00:29:12,220
initializer and you can have methods

00:29:10,090 --> 00:29:13,510
which I get are just functions that are

00:29:12,220 --> 00:29:16,480
by method the big difference between

00:29:13,510 --> 00:29:19,240
classes and structs is struts are passed

00:29:16,480 --> 00:29:22,000
by value objects are passed by reference

00:29:19,240 --> 00:29:24,400
so if you pass a function and object and

00:29:22,000 --> 00:29:25,870
it modifies the object the object itself

00:29:24,400 --> 00:29:27,280
is being modified if you pass the

00:29:25,870 --> 00:29:30,070
function a strut it's just getting

00:29:27,280 --> 00:29:34,390
copying the data the original calling

00:29:30,070 --> 00:29:35,799
code that data so that's the primary use

00:29:34,390 --> 00:29:37,720
difference between classes and structs

00:29:35,799 --> 00:29:42,010
they otherwise support pretty much all

00:29:37,720 --> 00:29:43,480
of the tactics and features two thousand

00:29:42,010 --> 00:29:46,390
New Marais shion's which if you've done

00:29:43,480 --> 00:29:48,220
an AC or C++ Java programming you may be

00:29:46,390 --> 00:29:50,470
familiar with use the keyword enum and

00:29:48,220 --> 00:29:54,650
then case to define your specific

00:29:50,470 --> 00:29:59,450
enumerations you know in case

00:29:54,650 --> 00:30:02,570
unlike C or Java this code there is no

00:29:59,450 --> 00:30:05,330
underlying value TPC is not is not

00:30:02,570 --> 00:30:07,010
stored as a 0 or a 1 somewhere the thing

00:30:05,330 --> 00:30:10,850
that is actually stored is the name of

00:30:07,010 --> 00:30:13,669
the case TPC so we can check that here

00:30:10,850 --> 00:30:17,179
we can make a ver the define it as CPC

00:30:13,669 --> 00:30:19,220
and now the type enumerations also

00:30:17,179 --> 00:30:22,909
define types so the type of this

00:30:19,220 --> 00:30:24,470
variable comp is open source columns so

00:30:22,909 --> 00:30:26,539
you can use that as function signatures

00:30:24,470 --> 00:30:28,820
you can say this function takes a

00:30:26,539 --> 00:30:31,659
variable of open source type and you let

00:30:28,820 --> 00:30:33,950
the pass one of these two values to it

00:30:31,659 --> 00:30:37,309
so it's a constraint set of enumerated

00:30:33,950 --> 00:30:39,320
values I said the underlying value you

00:30:37,309 --> 00:30:41,779
can make it have an underlying value by

00:30:39,320 --> 00:30:43,820
providing a type in the Aneke in the

00:30:41,779 --> 00:30:46,789
enum statement and then providing an

00:30:43,820 --> 00:30:50,510
initial default so by setting that to 1

00:30:46,789 --> 00:30:52,700
then after this case yeah C will have a

00:30:50,510 --> 00:30:56,260
value of 2 and you can get at that

00:30:52,700 --> 00:30:59,390
underlying that raw value method on

00:30:56,260 --> 00:31:04,100
variables so this is sometimes useful to

00:30:59,390 --> 00:31:05,690
do you can have on enumeration so here

00:31:04,100 --> 00:31:06,890
we have a describe function that just

00:31:05,690 --> 00:31:09,710
prints out different stuff and we're

00:31:06,890 --> 00:31:11,809
using case a switch statement here to

00:31:09,710 --> 00:31:14,330
switch on self and then depending on

00:31:11,809 --> 00:31:19,190
which one of the two cases we print out

00:31:14,330 --> 00:31:20,510
different things this is a case where

00:31:19,190 --> 00:31:23,000
you don't need to provide a default

00:31:20,510 --> 00:31:24,440
because there are only two possible

00:31:23,000 --> 00:31:25,940
values that can happen in the switch

00:31:24,440 --> 00:31:30,890
statement cuz there are only two values

00:31:25,940 --> 00:31:33,789
in the UNAM right so we'll just call

00:31:30,890 --> 00:31:38,779
that and it'll print out whatever you

00:31:33,789 --> 00:31:42,140
can also put forget what they call these

00:31:38,779 --> 00:31:43,789
attributes on enum values so here we're

00:31:42,140 --> 00:31:48,710
defining an enumeration then it has two

00:31:43,789 --> 00:31:50,690
cases tpc and Yassi tpc has a string

00:31:48,710 --> 00:31:53,960
value associated with it so anytime you

00:31:50,690 --> 00:31:55,610
try to make at TPC this enum you're also

00:31:53,960 --> 00:31:58,039
going to need to provide a string and

00:31:55,610 --> 00:32:00,289
that string then becomes associated with

00:31:58,039 --> 00:32:03,230
that particular instance of this

00:32:00,289 --> 00:32:06,220
enumeration but different ones can have

00:32:03,230 --> 00:32:08,049
different values so

00:32:06,220 --> 00:32:09,879
well it's used a lot in the surf

00:32:08,049 --> 00:32:12,279
documentation for this is you may be

00:32:09,879 --> 00:32:15,639
making a game space game if you're in

00:32:12,279 --> 00:32:18,309
this room before and you may have a list

00:32:15,639 --> 00:32:19,929
of weapons and one of the kit you might

00:32:18,309 --> 00:32:21,580
model that as an enum and so whether

00:32:19,929 --> 00:32:23,559
your cases would be like laser pistol

00:32:21,580 --> 00:32:25,600
the attribute you could have associated

00:32:23,559 --> 00:32:28,629
with individual laser pistols would be

00:32:25,600 --> 00:32:30,600
the power or how much damage one of them

00:32:28,629 --> 00:32:33,490
does and so that might vary by Kate by

00:32:30,600 --> 00:32:34,509
specific instance of the case but then

00:32:33,490 --> 00:32:36,940
you would still be able to write code

00:32:34,509 --> 00:32:40,480
that switched on weapon and do a

00:32:36,940 --> 00:32:44,049
specific thing for lasers you can also

00:32:40,480 --> 00:32:45,730
do when you do those switches you can do

00:32:44,049 --> 00:32:48,610
a destructor and bind and pull that

00:32:45,730 --> 00:32:51,970
value back out as part of the case

00:32:48,610 --> 00:32:54,970
statement so you can get access to that

00:32:51,970 --> 00:32:58,389
again so here we're going to make an

00:32:54,970 --> 00:33:00,669
open-source CPC we're going to give it a

00:32:58,389 --> 00:33:04,720
value you can use that value in the

00:33:00,669 --> 00:33:06,899
description and as I said we can

00:33:04,720 --> 00:33:09,330
actually have different cases different

00:33:06,899 --> 00:33:11,769
variables that are the same underlying

00:33:09,330 --> 00:33:17,350
case that have different values

00:33:11,769 --> 00:33:18,970
associated with them so it also supports

00:33:17,350 --> 00:33:21,070
something called protocols which in perl

00:33:18,970 --> 00:33:23,169
we like to call rolls basically the same

00:33:21,070 --> 00:33:25,870
thing it's a way to define an interface

00:33:23,169 --> 00:33:28,960
almost so here we have a protocol called

00:33:25,870 --> 00:33:32,230
time in order to be a talk required to

00:33:28,960 --> 00:33:35,529
implement a variable or sorry a noise

00:33:32,230 --> 00:33:38,919
attribute it's a string it's gettable

00:33:35,529 --> 00:33:41,419
and then a function that returns us

00:33:38,919 --> 00:33:43,969
takes no arguments and returns a string

00:33:41,419 --> 00:33:48,709
so if we look at how you would actually

00:33:43,969 --> 00:33:52,249
use these so of protocol also defined

00:33:48,709 --> 00:33:55,219
types so we can say that the class is a

00:33:52,249 --> 00:33:57,979
talker and in order for that to compile

00:33:55,219 --> 00:33:59,749
and dog needs to have an attribute

00:33:57,979 --> 00:34:02,419
called noise that's a string which it

00:33:59,749 --> 00:34:05,779
does and it needs to have an initializer

00:34:02,419 --> 00:34:08,089
for that and then it support a talk

00:34:05,779 --> 00:34:11,450
function that takes no arguments and

00:34:08,089 --> 00:34:13,429
returns a string which dog does and then

00:34:11,450 --> 00:34:15,470
we also have added here a string mute

00:34:13,429 --> 00:34:18,109
strictly so that I can show off this

00:34:15,470 --> 00:34:19,579
mutating keyword so you can say in the

00:34:18,109 --> 00:34:21,440
protocol that you actually have to

00:34:19,579 --> 00:34:23,389
specifically annotate a function that's

00:34:21,440 --> 00:34:25,279
going to change a value of an attribute

00:34:23,389 --> 00:34:29,809
you have to say this is a mutating

00:34:25,279 --> 00:34:31,279
function and here mute is a mutated

00:34:29,809 --> 00:34:34,460
function because it's changing the value

00:34:31,279 --> 00:34:36,109
of an attribute and again this is taking

00:34:34,460 --> 00:34:39,280
mistakes where you're accidentally

00:34:36,109 --> 00:34:42,190
changing data that shouldn't be changed

00:34:39,280 --> 00:34:44,440
as I said protocol to find types so if

00:34:42,190 --> 00:34:46,870
we have a talker protocol we defined

00:34:44,440 --> 00:34:52,090
dogs as talkers and then we also have a

00:34:46,870 --> 00:34:56,860
fish class if Sammy is a talker which

00:34:52,090 --> 00:34:59,470
she is she barks like crazy and then we

00:34:56,860 --> 00:35:02,980
initialize Sammy as a dog that will work

00:34:59,470 --> 00:35:05,110
because dog does talker if we tried to

00:35:02,980 --> 00:35:07,600
make Sammy a fish that won't work

00:35:05,110 --> 00:35:09,010
because Sammy is defined as a talker and

00:35:07,600 --> 00:35:12,400
fish doesn't do talker

00:35:09,010 --> 00:35:15,580
okay so again strongly typed language

00:35:12,400 --> 00:35:17,800
all sort of stuff you would expect the

00:35:15,580 --> 00:35:20,320
one other thing that's really really

00:35:17,800 --> 00:35:25,720
nice is that the language itself is

00:35:20,320 --> 00:35:29,320
basically I'm almost done the language

00:35:25,720 --> 00:35:32,920
itself is extensible so you can write

00:35:29,320 --> 00:35:35,050
extensions that modify built-in types so

00:35:32,920 --> 00:35:38,560
what we have here is an extension to the

00:35:35,050 --> 00:35:40,750
int type that adds a function to ents

00:35:38,560 --> 00:35:44,290
called squared that just returns the

00:35:40,750 --> 00:35:47,160
value of the end times itself so if we

00:35:44,290 --> 00:35:49,300
run this code and then we declare

00:35:47,160 --> 00:35:51,580
suddenly there's a squared method on

00:35:49,300 --> 00:35:53,770
that integer that is running this code

00:35:51,580 --> 00:35:56,080
that we wrote you can basically open up

00:35:53,770 --> 00:35:59,710
the type classes that ship with the

00:35:56,080 --> 00:36:02,800
language and add your own methods this

00:35:59,710 --> 00:36:04,840
is good and bad I actually in a little

00:36:02,800 --> 00:36:06,730
program I wrote recently had to open up

00:36:04,840 --> 00:36:08,830
the string class and add reg axis

00:36:06,730 --> 00:36:10,210
because the regulates is Rebecca this is

00:36:08,830 --> 00:36:12,790
a completely separate class and there's

00:36:10,210 --> 00:36:13,960
no direct mapping to strings but I was

00:36:12,790 --> 00:36:15,910
able to write an extension that

00:36:13,960 --> 00:36:19,660
basically just added ray X methods to

00:36:15,910 --> 00:36:22,900
strings so it was unfortunate that I had

00:36:19,660 --> 00:36:29,250
to but it was good that I could and then

00:36:22,900 --> 00:36:33,250
these methods chain handling real quick

00:36:29,250 --> 00:36:36,280
so in order you need to have an error

00:36:33,250 --> 00:36:40,000
type and what people typically do define

00:36:36,280 --> 00:36:43,090
in a neumann terror cases and they will

00:36:40,000 --> 00:36:45,520
just make that inherit the error type so

00:36:43,090 --> 00:36:47,470
here you also have to explicitly

00:36:45,520 --> 00:36:49,360
annotate functions that might throw

00:36:47,470 --> 00:36:50,590
exceptions so this is a function called

00:36:49,360 --> 00:36:54,130
give a talk that

00:36:50,590 --> 00:36:55,660
an exception possibly and if the talk is

00:36:54,130 --> 00:37:00,010
boring we're going to throw an exception

00:36:55,660 --> 00:37:03,280
called talk errors too boring then the

00:37:00,010 --> 00:37:05,650
call this code is you use a do catch

00:37:03,280 --> 00:37:06,760
block so you say do and then you have

00:37:05,650 --> 00:37:09,130
the code that might throw an exception

00:37:06,760 --> 00:37:11,170
and then the code that's going to run if

00:37:09,130 --> 00:37:13,240
you catch the exception and the error

00:37:11,170 --> 00:37:16,870
that is thrown will be passed to this

00:37:13,240 --> 00:37:19,150
block as error you also need to put the

00:37:16,870 --> 00:37:20,890
keyword try in front of the function

00:37:19,150 --> 00:37:22,240
that might possibly throw in exceptions

00:37:20,890 --> 00:37:23,890
again that makes it easy to see where

00:37:22,240 --> 00:37:28,030
the exception might be coming from and

00:37:23,890 --> 00:37:31,300
then again you catch this is error you

00:37:28,030 --> 00:37:33,640
can also have multiple catch blocks that

00:37:31,300 --> 00:37:37,180
effectively work like case statements on

00:37:33,640 --> 00:37:40,000
the error type so here we're checking to

00:37:37,180 --> 00:37:42,760
see was the talk to you on and actually

00:37:40,000 --> 00:37:46,210
it's not going to be too long here we're

00:37:42,760 --> 00:37:47,890
doing a descend on the error if where we

00:37:46,210 --> 00:37:49,000
you know it wasn't too long so we're

00:37:47,890 --> 00:37:51,610
actually going to pull out the type of

00:37:49,000 --> 00:37:53,890
error and print it out and then we have

00:37:51,610 --> 00:37:55,120
a default catch statement that's just

00:37:53,890 --> 00:37:59,320
going to catch in here and print it out

00:37:55,120 --> 00:38:00,670
we could catch and give a parameter name

00:37:59,320 --> 00:38:02,470
here and then it would go into that

00:38:00,670 --> 00:38:06,700
variable name instead of error errors

00:38:02,470 --> 00:38:08,970
just the default name that's used I'm

00:38:06,700 --> 00:38:08,970
sorry

00:38:10,650 --> 00:38:17,300
if some other code through something

00:38:14,250 --> 00:38:17,300
that wasn't a talk error

00:38:19,610 --> 00:38:23,870
you can instead of just saying try you

00:38:22,070 --> 00:38:25,400
can say try question mark and then if

00:38:23,870 --> 00:38:29,120
there's an exception it will be silently

00:38:25,400 --> 00:38:31,280
discarded and the value here will end up

00:38:29,120 --> 00:38:33,170
being held which means that the type of

00:38:31,280 --> 00:38:35,330
this thing is actually inferred as an

00:38:33,170 --> 00:38:39,370
optionally types version of whatever

00:38:35,330 --> 00:38:39,370
that function is defined to return a

00:38:39,970 --> 00:38:47,360
string question mark go also has a

00:38:45,470 --> 00:38:51,050
keyword called the fur which if you've

00:38:47,360 --> 00:38:52,550
ever yak sorry yes yeah you always have

00:38:51,050 --> 00:38:56,780
to unwrap optional types before you use

00:38:52,550 --> 00:38:59,270
it go also has a keyword called the fur

00:38:56,780 --> 00:39:01,580
which you've if you've ever sry Swift

00:38:59,270 --> 00:39:04,400
how to defer which if you've ever used

00:39:01,580 --> 00:39:06,800
go you will recognize this await us

00:39:04,400 --> 00:39:08,540
basically scheduled code to run later at

00:39:06,800 --> 00:39:11,840
the end of the enclosing block that it's

00:39:08,540 --> 00:39:14,000
defined inside this is probably one of

00:39:11,840 --> 00:39:15,500
my favorite features in go so it's

00:39:14,000 --> 00:39:17,360
pretty cool that since with basically

00:39:15,500 --> 00:39:19,430
you just say the fur and then anything

00:39:17,360 --> 00:39:21,650
that's inside this block is actually

00:39:19,430 --> 00:39:22,910
going to run down here after all this

00:39:21,650 --> 00:39:27,980
other stuff that I'm not showing you

00:39:22,910 --> 00:39:31,040
goes if you have a Mac you can download

00:39:27,980 --> 00:39:33,590
Xcode for free it will take a while so

00:39:31,040 --> 00:39:34,940
maybe start that and then go to bed and

00:39:33,590 --> 00:39:36,980
it'll be there in the morning

00:39:34,940 --> 00:39:39,080
but it does shift for free and recent

00:39:36,980 --> 00:39:41,030
versions of Xcode include include this

00:39:39,080 --> 00:39:43,880
cool feature called workspaces which is

00:39:41,030 --> 00:39:46,700
basically an inline level with a few

00:39:43,880 --> 00:39:48,560
other nifty introspection features at

00:39:46,700 --> 00:39:50,270
one point I used to do a live demo here

00:39:48,560 --> 00:39:51,950
but it made the talk way too long so

00:39:50,270 --> 00:39:56,060
we're not going to do that but if you

00:39:51,950 --> 00:39:58,550
have Xcode under the window menu you can

00:39:56,060 --> 00:40:00,080
go here to documentation and API

00:39:58,550 --> 00:40:02,270
reference and it will download the

00:40:00,080 --> 00:40:04,400
documentation for you and included in

00:40:02,270 --> 00:40:07,100
that documentation is a playground

00:40:04,400 --> 00:40:08,870
called Swift a swift tour so one of the

00:40:07,100 --> 00:40:10,490
great things about these playgrounds is

00:40:08,870 --> 00:40:12,320
it basically works like a jupiter

00:40:10,490 --> 00:40:16,010
notebook and that you can have imbedded

00:40:12,320 --> 00:40:17,300
documentation and code and when you open

00:40:16,010 --> 00:40:19,040
up this playground you get like

00:40:17,300 --> 00:40:22,070
basically an overview of how the

00:40:19,040 --> 00:40:23,840
language works you can edit this print

00:40:22,070 --> 00:40:25,430
hello world you can change that code and

00:40:23,840 --> 00:40:27,230
you can put any legal swift code in

00:40:25,430 --> 00:40:29,300
there and when it runs it prints out the

00:40:27,230 --> 00:40:30,650
results over here or if you have a

00:40:29,300 --> 00:40:31,660
compile time error it will tell you

00:40:30,650 --> 00:40:33,430
right there in line

00:40:31,660 --> 00:40:35,589
this is a compile-time error this is

00:40:33,430 --> 00:40:38,109
really awesome for learning languages

00:40:35,589 --> 00:40:39,400
playing around with new features because

00:40:38,109 --> 00:40:41,799
you can just it's basically like a

00:40:39,400 --> 00:40:44,500
repple which is not something you see

00:40:41,799 --> 00:40:46,089
for a compiled language there's also a

00:40:44,500 --> 00:40:47,530
version that runs on iPads I haven't

00:40:46,089 --> 00:40:50,130
played with that yet again you can

00:40:47,530 --> 00:40:52,720
download that for free

00:40:50,130 --> 00:40:54,910
developer.apple.com slash swift is where

00:40:52,720 --> 00:40:56,619
all the Swift resources are if you go

00:40:54,910 --> 00:40:58,839
there right now they are pushing to a

00:40:56,619 --> 00:41:00,369
for really hard and Xcode 9

00:40:58,839 --> 00:41:02,140
I wouldn't recommend installing those

00:41:00,369 --> 00:41:06,130
unless you don't depend on Xcode for

00:41:02,140 --> 00:41:07,990
your job if you're more of a book type

00:41:06,130 --> 00:41:10,210
learner there's a really great a Riley

00:41:07,990 --> 00:41:13,660
book called learning Swift that has been

00:41:10,210 --> 00:41:14,770
updated for Swift 3 so I highly

00:41:13,660 --> 00:41:18,039
recommend this book if you're a book

00:41:14,770 --> 00:41:19,869
type learner and finally thanks to the

00:41:18,039 --> 00:41:23,799
organizers for picking the talk thanks

00:41:19,869 --> 00:41:26,710
to you for coming to the talk thanks to

00:41:23,799 --> 00:41:28,869
my employer for paying me to write the

00:41:26,710 --> 00:41:30,789
talk and sending me here so that I can

00:41:28,869 --> 00:41:32,559
tell you that we also do consulting

00:41:30,789 --> 00:41:36,339
stuff and I'd love to talk to you if you

00:41:32,559 --> 00:41:41,760
have any needs and I have what like 4

00:41:36,339 --> 00:41:41,760
minutes to take questions ok questions

00:41:45,089 --> 00:41:55,539
over can protocol support tations of

00:41:53,920 --> 00:41:56,319
functions I don't think so I would

00:41:55,539 --> 00:41:57,880
actually have to look at the

00:41:56,319 --> 00:41:59,140
documentation though I think you're only

00:41:57,880 --> 00:42:03,930
allowed to provide a function signature

00:41:59,140 --> 00:42:03,930
hold well

00:42:12,680 --> 00:42:18,920
does the swift core library have file

00:42:15,140 --> 00:42:20,510
i/o features I think it does but again I

00:42:18,920 --> 00:42:23,890
have to go look at the documentation I

00:42:20,510 --> 00:42:23,890
did which I don't have memorized

00:42:33,630 --> 00:42:37,740
doing regular expressions and Swift is

00:42:35,670 --> 00:42:43,369
not super great either

00:42:37,740 --> 00:42:43,369
it's kind of Java not in a good way

00:42:48,230 --> 00:42:52,280
do structural clauses have default

00:42:50,240 --> 00:42:58,700
initializers yes you you get a default

00:42:52,280 --> 00:43:02,170
initializer for not for classes but for

00:42:58,700 --> 00:43:02,170
structs yeah

00:43:06,330 --> 00:43:10,400
is the Oh cake because

00:43:16,720 --> 00:43:22,510
so the question is what is the scoping

00:43:19,810 --> 00:43:25,460
of defer and Swifton is it block scoped

00:43:22,510 --> 00:43:33,189
or function scope denial

00:43:25,460 --> 00:43:33,189
[Music]

00:43:39,070 --> 00:43:47,890
our extensions theirs they're basically

00:43:43,060 --> 00:43:50,920
project coke I don't know how that works

00:43:47,890 --> 00:43:52,720
if you're linking in a library that also

00:43:50,920 --> 00:43:54,460
defines an extension of the same name

00:43:52,720 --> 00:43:56,590
although I would imagine that big red

00:43:54,460 --> 00:43:59,530
things show up on your screen at some

00:43:56,590 --> 00:44:00,070
boy because they if that would be able

00:43:59,530 --> 00:44:05,400
to link

00:44:00,070 --> 00:44:05,400
I don't think Larry

00:44:07,480 --> 00:44:13,640
of them

00:44:09,930 --> 00:44:13,640
they are compiled m-type yeah

00:44:15,600 --> 00:44:21,400
you just later yeah okay I'm going to

00:44:19,030 --> 00:44:28,420
here and like PLT and I'm like down here

00:44:21,400 --> 00:44:43,330
so I and I jug or the actual path

00:44:28,420 --> 00:44:45,010
without vision like what oh yeah thank

00:44:43,330 --> 00:44:46,990
you a very appetizing very nice job with

00:44:45,010 --> 00:45:06,100
documentation as long as you're going to

00:44:46,990 --> 00:45:09,550
fly into the iBooks just ecosystem hi

00:45:06,100 --> 00:45:12,040
this isn't me right so I did mention

00:45:09,550 --> 00:45:16,260
that you can get on the iPad and iPhone

00:45:12,040 --> 00:45:16,260
version of playgrounds that runs locally

00:45:19,080 --> 00:45:26,170
what if I used Swift for I've used it to

00:45:22,270 --> 00:45:27,430
write this talk I actually wrote the

00:45:26,170 --> 00:45:30,580
thing that I needed the regular

00:45:27,430 --> 00:45:33,580
expression class for is this is very

00:45:30,580 --> 00:45:37,600
nerdy I have in my office hundred

00:45:33,580 --> 00:45:39,880
Douglass power lines that are supposed

00:45:37,600 --> 00:45:42,400
to automatically open and close on an

00:45:39,880 --> 00:45:43,720
alarm and sometimes they don't open on

00:45:42,400 --> 00:45:44,980
the alarm and then I come out to my

00:45:43,720 --> 00:45:47,080
office in the morning to work and I'm

00:45:44,980 --> 00:45:49,510
annoyed and I have to get my phone out

00:45:47,080 --> 00:45:52,570
and then click like 27 times to run the

00:45:49,510 --> 00:45:56,050
routine that opens to the slide it turns

00:45:52,570 --> 00:45:58,450
out like many iota C sort of things if

00:45:56,050 --> 00:45:59,830
you if you got philips hue lights they

00:45:58,450 --> 00:46:01,330
have what they call a hub which is a

00:45:59,830 --> 00:46:04,090
little hardware box that you have to

00:46:01,330 --> 00:46:04,980
plug directly wired internet into your

00:46:04,090 --> 00:46:08,339
router

00:46:04,980 --> 00:46:14,220
100 Douglass hub blender program that

00:46:08,339 --> 00:46:16,410
listens on HTTP not HTTP HTTP it

00:46:14,220 --> 00:46:19,829
requires absolutely no authentication

00:46:16,410 --> 00:46:23,880
I really recommend these blind is what

00:46:19,829 --> 00:46:26,040
I'm trying to say but there's actually a

00:46:23,880 --> 00:46:29,040
go library that brad fitzpatrick food

00:46:26,040 --> 00:46:30,599
some of you old people may remember row

00:46:29,040 --> 00:46:31,770
for controlling his hundred Douglass

00:46:30,599 --> 00:46:34,230
wine so is the able T is completely

00:46:31,770 --> 00:46:35,700
undocumented I was able to get the

00:46:34,230 --> 00:46:37,260
necessary end points out of there so I

00:46:35,700 --> 00:46:42,660
wrote a little switch program that I can

00:46:37,260 --> 00:46:45,560
run from my Mac to open my blinds when

00:46:42,660 --> 00:46:48,540
they don't open automatically Express

00:46:45,560 --> 00:46:51,750
yes

00:46:48,540 --> 00:46:54,900
and here's why because this data the

00:46:51,750 --> 00:46:58,370
data that gets returned comes back as an

00:46:54,900 --> 00:47:01,580
Jason it's a long story

00:46:58,370 --> 00:47:05,910
yeah as I needed a regular expression

00:47:01,580 --> 00:47:07,320
look I'm a pro programmer like I said at

00:47:05,910 --> 00:47:09,090
the very beginning identify with the

00:47:07,320 --> 00:47:11,220
curl like don't put at least one regular

00:47:09,090 --> 00:47:14,690
expression in a program like at least

00:47:11,220 --> 00:47:17,960
once a month I start to get to achieve

00:47:14,690 --> 00:47:20,130
right I think how are we doing on time

00:47:17,960 --> 00:47:26,040
okay I got about three minutes yes sir

00:47:20,130 --> 00:47:28,830
messing with air handling which is sort

00:47:26,040 --> 00:47:31,710
of more oh man there's our fault which

00:47:28,830 --> 00:47:33,750
is more idiomatic exceptions or optional

00:47:31,710 --> 00:47:37,230
types you end up using optional types a

00:47:33,750 --> 00:47:39,330
lot when you use the Swift version of

00:47:37,230 --> 00:47:43,170
Objective C API is because those API is

00:47:39,330 --> 00:47:45,870
returned no values a lot on error and so

00:47:43,170 --> 00:47:48,870
those get turned into optional types so

00:47:45,870 --> 00:47:50,400
if you're doing any kind of actual Mac

00:47:48,870 --> 00:47:52,650
or iOS programming you're getting

00:47:50,400 --> 00:47:55,050
abusing those all the time I think

00:47:52,650 --> 00:47:56,880
people do use exception that gets into a

00:47:55,050 --> 00:47:58,320
sort of a philosophical question of when

00:47:56,880 --> 00:48:00,240
it's appropriate these exceptions and I

00:47:58,320 --> 00:48:03,950
don't know if there's a strong idiomatic

00:48:00,240 --> 00:48:03,950
consensus about that I

00:48:18,470 --> 00:48:24,720
how deep does copy 5 value works far as

00:48:22,440 --> 00:48:28,370
I know it goes all the way down but I

00:48:24,720 --> 00:48:28,370
haven't like tried to test it

00:48:29,150 --> 00:48:40,110
yes you know do I know how easy it is to

00:48:37,890 --> 00:48:42,780
integrate your Swift with regular C um

00:48:40,110 --> 00:48:57,930
no no I'm sorry I haven't looked at that

00:48:42,780 --> 00:49:00,300
hell if yet my it probably will work

00:48:57,930 --> 00:49:05,010
that I have no idea what sort of hidden

00:49:00,300 --> 00:49:11,550
landmines are waiting you and last

00:49:05,010 --> 00:49:13,320
question does it come in rose gold it

00:49:11,550 --> 00:49:15,530
comes in all the flavors of the rainbow

00:49:13,320 --> 00:49:15,530
baby

00:49:21,339 --> 00:49:25,839
I will put these slides online at some

00:49:24,339 --> 00:49:27,849
point when I get around to exporting

00:49:25,839 --> 00:49:29,739
them and I'll tweet it when I do so if

00:49:27,849 --> 00:49:33,539
you're interested Jean hack on Twitter

00:49:29,739 --> 00:49:33,539

YouTube URL: https://www.youtube.com/watch?v=n-st1-DpKHI


