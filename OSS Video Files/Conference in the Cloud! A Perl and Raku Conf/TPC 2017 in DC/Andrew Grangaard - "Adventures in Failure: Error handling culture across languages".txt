Title: Andrew Grangaard - "Adventures in Failure: Error handling culture across languages"
Publication date: 2017-06-22
Playlist: TPC 2017 in DC
Description: 
	Modern programming languages have a wide spectrum of error handling methods and related cultural expectations.

I'll lead you on a brief tour of various error handling patterns and paradigms and their strengths and failings. As a polyglot dabbler, I've done just enough with each of these languages to have formed cranky opinions.

By the end, we'll have new patterns to apply to our perl code (be in perl5 or perl6).

Compare and contrast:

C inspired return values in C, perl5 and go
Java vs Python exceptions
Erlang: "let it crash" approach,
Rust: Failure vs Panic
monadic: Rust Option and Haskell Maybe.
pattern matching
whatever it is that perl6 does ;)

Perl-loving polyglot Engineer. I fix things. Former Electrical Engineer, now I write software. la.pm.org nerd-herder for a decade. I've used perl for forever (I remember grumpily updating perl4 code for perl5 semantics). After a 6 year python diversion I'm back writing perl at ZipRecruiter.
Captions: 
	00:00:00,000 --> 00:00:04,410
I'm super pumped to be here there's

00:00:02,970 --> 00:00:07,799
nothing to do with the caffeine I've

00:00:04,410 --> 00:00:09,210
jumped all morning hi everybody I'm

00:00:07,799 --> 00:00:11,480
Andrew

00:00:09,210 --> 00:00:14,759
you may recognize me from my

00:00:11,480 --> 00:00:15,540
announcements yesterday and today and

00:00:14,759 --> 00:00:17,550
tomorrow

00:00:15,540 --> 00:00:20,880
I run Los Angeles pro mongers you're all

00:00:17,550 --> 00:00:23,340
invited come on over we're friendlier on

00:00:20,880 --> 00:00:25,500
the slightly smaller group than all this

00:00:23,340 --> 00:00:29,640
um is on right we're good

00:00:25,500 --> 00:00:32,390
no I should be closer excellent and you

00:00:29,640 --> 00:00:36,390
wanted to think all right we're good and

00:00:32,390 --> 00:00:40,920
we are off so my talk today adventures

00:00:36,390 --> 00:00:42,570
and failures it's a server a perusal of

00:00:40,920 --> 00:00:47,399
error handling and exception handling

00:00:42,570 --> 00:00:49,530
across languages a few of them are down

00:00:47,399 --> 00:00:52,520
here at the bottom lots of pretty icons

00:00:49,530 --> 00:00:55,500
which is a way more fun to make slides

00:00:52,520 --> 00:00:58,440
and my title I might as well give a

00:00:55,500 --> 00:01:03,239
shout out to MC 900-foot any names he

00:00:58,440 --> 00:01:04,739
fans and I like to quote him out of

00:01:03,239 --> 00:01:09,659
context because it works better for my

00:01:04,739 --> 00:01:13,020
talk making a change is difficult but I

00:01:09,659 --> 00:01:14,570
got a try to get out of my rut and you

00:01:13,020 --> 00:01:16,740
know don't let fear hold you back

00:01:14,570 --> 00:01:18,600
don't let heavy-drinking hold you back

00:01:16,740 --> 00:01:22,530
you know don't just look at these airs

00:01:18,600 --> 00:01:33,420
instead let's list our sir so let's

00:01:22,530 --> 00:01:34,950
start with our our ancestor C so C is

00:01:33,420 --> 00:01:37,650
sort of the original foot gun there's

00:01:34,950 --> 00:01:39,509
lots of chances to do error handling

00:01:37,650 --> 00:01:43,200
because there's lots of ways to make

00:01:39,509 --> 00:01:45,960
mistakes specifically since you are

00:01:43,200 --> 00:01:47,460
allocating your own memory and having to

00:01:45,960 --> 00:01:49,770
handle your own memory that's a whole

00:01:47,460 --> 00:01:52,890
class of errors that you then have to

00:01:49,770 --> 00:01:54,630
look and check for and in the seal and

00:01:52,890 --> 00:01:58,140
there's no exceptions there's just

00:01:54,630 --> 00:02:00,479
errors so when you get an error first

00:01:58,140 --> 00:02:02,250
you have to notice and then you have to

00:02:00,479 --> 00:02:03,479
do something about it well you don't

00:02:02,250 --> 00:02:07,200
have to do something about it but you

00:02:03,479 --> 00:02:08,580
really should now part of these are

00:02:07,200 --> 00:02:10,470
actually kind of tied together because

00:02:08,580 --> 00:02:12,629
one you have errors from your Malick's

00:02:10,470 --> 00:02:13,280
but two because you are in charge of

00:02:12,629 --> 00:02:17,300
your memory

00:02:13,280 --> 00:02:19,370
then the stack only gives you one return

00:02:17,300 --> 00:02:20,540
value and so there's a question when you

00:02:19,370 --> 00:02:22,670
call a function does it return the

00:02:20,540 --> 00:02:26,569
status of the function or the value of

00:02:22,670 --> 00:02:30,020
the function and most see has gone with

00:02:26,569 --> 00:02:32,510
the returning the value actually

00:02:30,020 --> 00:02:34,370
returning an error code sometimes

00:02:32,510 --> 00:02:36,010
co-mingled where it's a positive and

00:02:34,370 --> 00:02:42,050
it's good and negative it's bad or

00:02:36,010 --> 00:02:44,150
here's the thing or it's no yeah and and

00:02:42,050 --> 00:02:47,570
part of that comes from you know you are

00:02:44,150 --> 00:02:49,370
handling your own memory and so cleaning

00:02:47,570 --> 00:02:51,230
up your own memory is the thing you have

00:02:49,370 --> 00:02:55,130
to do and so the error handling is very

00:02:51,230 --> 00:02:56,840
important here's a neat little example I

00:02:55,130 --> 00:02:59,000
found of some error checking you know

00:02:56,840 --> 00:03:02,450
kind of what it looks like here we have

00:02:59,000 --> 00:03:04,040
a stack allocated string and a malloc

00:03:02,450 --> 00:03:08,060
allocated straining and you have to

00:03:04,040 --> 00:03:09,620
check okay was I able to malloc was I

00:03:08,060 --> 00:03:11,810
able to get memory from the computer

00:03:09,620 --> 00:03:14,150
like this is the level we're at and no

00:03:11,810 --> 00:03:16,970
no no I couldn't okay I better I better

00:03:14,150 --> 00:03:19,640
just throw an error so this is some

00:03:16,970 --> 00:03:21,500
error tracking code I found online can

00:03:19,640 --> 00:03:25,370
you see the errors because there are

00:03:21,500 --> 00:03:27,799
several that are not caught so we do

00:03:25,370 --> 00:03:29,269
some since as you know the malloc we're

00:03:27,799 --> 00:03:31,790
checking them out so that's the good

00:03:29,269 --> 00:03:34,310
example but we're also string copying

00:03:31,790 --> 00:03:35,930
into a string and not really checking

00:03:34,310 --> 00:03:38,690
whether or not that worked and if we

00:03:35,930 --> 00:03:40,299
were bounded and that's even outside of

00:03:38,690 --> 00:03:42,799
the scope of this but I just love that

00:03:40,299 --> 00:03:46,790
this this is from someone's how to check

00:03:42,799 --> 00:03:51,650
errors in C talk and they miss that

00:03:46,790 --> 00:03:55,160
and so because C and UNIX environment

00:03:51,650 --> 00:03:58,250
we're mostly in and POSIX are all

00:03:55,160 --> 00:04:00,829
interconnected so or your system calls

00:03:58,250 --> 00:04:03,530
you've got error numbers so if the

00:04:00,829 --> 00:04:09,400
system call failed then you have a valid

00:04:03,530 --> 00:04:11,510
thing in error but it's only valid for

00:04:09,400 --> 00:04:14,480
little brief period of time so it's

00:04:11,510 --> 00:04:17,870
valid only if your thing failed and only

00:04:14,480 --> 00:04:19,430
right then because it's a global and it

00:04:17,870 --> 00:04:21,289
could get reset by the next thing so if

00:04:19,430 --> 00:04:23,300
you actually check it wrong you could

00:04:21,289 --> 00:04:24,389
overwrite the value of the error before

00:04:23,300 --> 00:04:28,930
you check the error

00:04:24,389 --> 00:04:31,960
again click on is a great talk on this I

00:04:28,930 --> 00:04:33,600
found while doing all this research from

00:04:31,960 --> 00:04:36,220
the software engineering Institute

00:04:33,600 --> 00:04:38,730
working with cert on you know how to get

00:04:36,220 --> 00:04:42,040
beyond air dam air no handling and see

00:04:38,730 --> 00:04:45,610
but what I like is that it connects to a

00:04:42,040 --> 00:04:49,030
couple of certain cert is where these

00:04:45,610 --> 00:04:50,530
errors are so common that like these are

00:04:49,030 --> 00:04:52,750
things you have to explicitly go and

00:04:50,530 --> 00:04:53,980
check and when you're doing security

00:04:52,750 --> 00:04:55,510
audits you need to go make sure that

00:04:53,980 --> 00:04:57,910
these are all handled because we miss

00:04:55,510 --> 00:05:01,110
them so often so for instance detected

00:04:57,910 --> 00:05:02,380
handle POSIX library errors this is a

00:05:01,110 --> 00:05:06,550
mp18

00:05:02,380 --> 00:05:09,100
and one recurring bug similarly detect

00:05:06,550 --> 00:05:15,160
and handle standard library errors also

00:05:09,100 --> 00:05:17,560
ap eighteen and one bug and when it

00:05:15,160 --> 00:05:20,080
comes to how you handle you can seen and

00:05:17,560 --> 00:05:22,150
a little bit c++ c plus plus is just one

00:05:20,080 --> 00:05:25,450
little corner of this you have to decide

00:05:22,150 --> 00:05:28,660
can I handle this error should I check

00:05:25,450 --> 00:05:32,020
it and and how much error checking you

00:05:28,660 --> 00:05:34,840
want to do and actually if we looked at

00:05:32,020 --> 00:05:37,750
that one see example or as well look at

00:05:34,840 --> 00:05:40,090
the one here it gets a lot of people

00:05:37,750 --> 00:05:41,410
think it's messy right you make a call

00:05:40,090 --> 00:05:43,690
and you have to check the cowl and they

00:05:41,410 --> 00:05:45,970
have to call the error number and so the

00:05:43,690 --> 00:05:50,770
question is what have we learned since

00:05:45,970 --> 00:05:52,390
then to make it better so in C error

00:05:50,770 --> 00:05:54,850
handling really depends on the program

00:05:52,390 --> 00:05:57,520
and we have found that programmers are

00:05:54,850 --> 00:06:00,880
humans most of the time it turns out and

00:05:57,520 --> 00:06:03,310
are thus very fallible and we forget to

00:06:00,880 --> 00:06:06,100
do things and so we'd like our languages

00:06:03,310 --> 00:06:08,020
to make it either automate this away or

00:06:06,100 --> 00:06:12,220
make it easier to do the good thing than

00:06:08,020 --> 00:06:14,680
the bad thing so one that we didn't even

00:06:12,220 --> 00:06:17,080
make it to this list sort of a prefix as

00:06:14,680 --> 00:06:19,570
we move so C was a high level language

00:06:17,080 --> 00:06:22,300
compared to assembly and now all of our

00:06:19,570 --> 00:06:26,260
languages are high compared to C mainly

00:06:22,300 --> 00:06:28,660
because we get memory allocation handled

00:06:26,260 --> 00:06:31,690
for us which makes it easier to unwind

00:06:28,660 --> 00:06:34,030
some of these mistakes allows you to be

00:06:31,690 --> 00:06:35,689
throwing exceptions or doing different

00:06:34,030 --> 00:06:38,449
error classes

00:06:35,689 --> 00:06:41,509
so some of the different approaches that

00:06:38,449 --> 00:06:43,729
have come out we've got Erlang would

00:06:41,509 --> 00:06:48,159
just let it crash just code the happy

00:06:43,729 --> 00:06:49,539
path in kind of mind-blowing to try that

00:06:48,159 --> 00:06:52,460
exceptions

00:06:49,539 --> 00:06:54,080
we're totally common now but when Java

00:06:52,460 --> 00:06:55,370
was like we're going all exceptions that

00:06:54,080 --> 00:06:57,800
was new that was exciting

00:06:55,370 --> 00:06:59,539
C++ they're still fighting about it so

00:06:57,800 --> 00:07:01,669
that's kind of neat

00:06:59,539 --> 00:07:06,759
go takes a different approach where they

00:07:01,669 --> 00:07:09,139
require you to check the error and they

00:07:06,759 --> 00:07:11,900
nag you in the compiler at the compile

00:07:09,139 --> 00:07:14,240
phase if you haven't and then the

00:07:11,900 --> 00:07:19,539
functional languages have mostly tried

00:07:14,240 --> 00:07:22,219
to askew the error handling and go with

00:07:19,539 --> 00:07:23,810
functional error types where you have

00:07:22,219 --> 00:07:26,529
one return value that's either the thing

00:07:23,810 --> 00:07:29,569
or the error or the thing or the nun

00:07:26,529 --> 00:07:31,399
partially because they don't have null

00:07:29,569 --> 00:07:34,129
values because that was another huge

00:07:31,399 --> 00:07:36,680
issue with C is you have all these nulls

00:07:34,129 --> 00:07:39,229
you dereference them boom so let's try

00:07:36,680 --> 00:07:42,229
and stop some of the boom and then

00:07:39,229 --> 00:07:45,740
static checking I know we're not big on

00:07:42,229 --> 00:07:47,659
static checking but it does get rid of a

00:07:45,740 --> 00:07:49,789
whole class of bugs doesn't get rid of

00:07:47,659 --> 00:07:52,999
all bugs but the question is what are

00:07:49,789 --> 00:07:56,209
the trade-offs and JavaScript is doing a

00:07:52,999 --> 00:07:57,439
lot of continuation call back style we

00:07:56,209 --> 00:08:00,529
won't actually get into that one but

00:07:57,439 --> 00:08:02,270
it's interesting as an aside of a

00:08:00,529 --> 00:08:04,310
different way to handle the error

00:08:02,270 --> 00:08:07,029
checking flow control because question

00:08:04,310 --> 00:08:11,870
is how do you keep your code pretty and

00:08:07,029 --> 00:08:15,139
correct and check the errors and for me

00:08:11,870 --> 00:08:15,589
this all came two years back I was at

00:08:15,139 --> 00:08:18,560
OSCON

00:08:15,589 --> 00:08:20,990
and I did a half-day a tutorial on rust

00:08:18,560 --> 00:08:23,509
and then a half day on Erlang and their

00:08:20,990 --> 00:08:27,560
models were so different that Maybach

00:08:23,509 --> 00:08:31,879
Rain kind of melded sure well melted

00:08:27,560 --> 00:08:34,339
melded it's kind of kind of both and so

00:08:31,879 --> 00:08:38,060
that became this as a lightning talk of

00:08:34,339 --> 00:08:41,269
just these two being compared because in

00:08:38,060 --> 00:08:45,579
the Erlang model in specifically Erlang

00:08:41,269 --> 00:08:45,579
OTP you let it crash and

00:08:46,140 --> 00:08:49,680
it's it's kind of weird to just the

00:08:48,300 --> 00:08:52,230
other just let it crash but what does

00:08:49,680 --> 00:08:53,940
that mean what what is the environment

00:08:52,230 --> 00:08:57,150
giving for you so the environment gives

00:08:53,940 --> 00:08:59,220
away for one it's an actor model so

00:08:57,150 --> 00:09:01,860
you're just passing messages around so

00:08:59,220 --> 00:09:04,230
if I send a message over here and this

00:09:01,860 --> 00:09:06,770
dies it's not going to corrupt my stack

00:09:04,230 --> 00:09:09,990
and my memory and my process space

00:09:06,770 --> 00:09:12,150
necessarily it may be that it's act of

00:09:09,990 --> 00:09:14,610
crashing affects me and it may be that

00:09:12,150 --> 00:09:17,130
it doesn't and I as the programmer to

00:09:14,610 --> 00:09:19,200
determine if this one crashes I want

00:09:17,130 --> 00:09:20,700
this one to die too if this one crashes

00:09:19,200 --> 00:09:24,090
I wanted to just start again and try new

00:09:20,700 --> 00:09:25,770
messages and so when you look at her

00:09:24,090 --> 00:09:28,050
lane code it's all just a happy path

00:09:25,770 --> 00:09:30,570
it's like I got this message how to

00:09:28,050 --> 00:09:33,380
match it do this thing and if you get a

00:09:30,570 --> 00:09:36,740
message it doesn't match you just die

00:09:33,380 --> 00:09:41,070
but the VM handles lots of little

00:09:36,740 --> 00:09:42,780
processes for you and you end up with

00:09:41,070 --> 00:09:45,200
this super Abaza model which is really

00:09:42,780 --> 00:09:47,550
actually pretty fascinating we're in

00:09:45,200 --> 00:09:49,530
because it's messages and you end up

00:09:47,550 --> 00:09:54,420
with a message passing you can watch

00:09:49,530 --> 00:09:56,220
from from one pool of processes you can

00:09:54,420 --> 00:09:57,750
have a supervisor and then that

00:09:56,220 --> 00:09:59,250
supervisors can be supervised by someone

00:09:57,750 --> 00:10:01,890
else and you have different strategies

00:09:59,250 --> 00:10:03,870
so hey if one of the kids dies that

00:10:01,890 --> 00:10:05,460
that's okay start another one a whole

00:10:03,870 --> 00:10:07,470
bunch of them die maybe something's

00:10:05,460 --> 00:10:10,740
wrong and I should kill the whole class

00:10:07,470 --> 00:10:12,470
and send it up the line and it sort of

00:10:10,740 --> 00:10:15,330
ends up being like exceptions and it

00:10:12,470 --> 00:10:17,190
really if you squint your eyes you see

00:10:15,330 --> 00:10:20,670
how we are going towards this exact

00:10:17,190 --> 00:10:22,410
model in our micro-services case of we

00:10:20,670 --> 00:10:23,850
have all these distributed processes and

00:10:22,410 --> 00:10:25,590
we're going to send things and we're

00:10:23,850 --> 00:10:30,300
going to monitor are they up and we

00:10:25,590 --> 00:10:34,230
restart them and what is nice from their

00:10:30,300 --> 00:10:35,580
model is that you remove that code into

00:10:34,230 --> 00:10:38,190
two places you have the business code

00:10:35,580 --> 00:10:39,360
hey what do I want to happen and then

00:10:38,190 --> 00:10:42,150
you have the higher-level business code

00:10:39,360 --> 00:10:45,360
of how do I handle mistakes and they're

00:10:42,150 --> 00:10:48,060
separate and they have four strategies

00:10:45,360 --> 00:10:51,960
one for all one for one rest for one

00:10:48,060 --> 00:10:54,090
simple one for one so that as your

00:10:51,960 --> 00:10:57,660
children die you have different ways to

00:10:54,090 --> 00:10:59,550
restart them all and again that's on an

00:10:57,660 --> 00:11:02,940
actor/model which now

00:10:59,550 --> 00:11:06,570
popular in say akka and some other

00:11:02,940 --> 00:11:09,810
places vertex is not really actor it's

00:11:06,570 --> 00:11:11,880
events but events and message models are

00:11:09,810 --> 00:11:16,050
getting very popular and we should play

00:11:11,880 --> 00:11:19,500
with them and then rust has failures

00:11:16,050 --> 00:11:21,240
versus panics and so a failure is an

00:11:19,500 --> 00:11:26,130
error like an exception that could be

00:11:21,240 --> 00:11:27,269
handled and a panic is now we don't know

00:11:26,130 --> 00:11:30,690
how to deal with this we're just going

00:11:27,269 --> 00:11:32,250
explode and you can't catch a panic well

00:11:30,690 --> 00:11:33,660
actually they just decided that maybe

00:11:32,250 --> 00:11:36,839
you can catch a panic and so

00:11:33,660 --> 00:11:38,610
one-point-nine added controlled

00:11:36,839 --> 00:11:41,209
unwinding wherein you can say oh it's

00:11:38,610 --> 00:11:43,110
panicking but I know how to fix that

00:11:41,209 --> 00:11:44,910
like why would you need that way you

00:11:43,110 --> 00:11:47,959
want it if you're embedding in another

00:11:44,910 --> 00:11:52,740
system and you don't want to fail up and

00:11:47,959 --> 00:11:55,380
also its function language partially and

00:11:52,740 --> 00:11:58,200
so it goes with the functional model of

00:11:55,380 --> 00:12:01,410
a lot of pattern matching so that you

00:11:58,200 --> 00:12:05,190
have valid cases and in here we have an

00:12:01,410 --> 00:12:08,310
example of this last case where you have

00:12:05,190 --> 00:12:10,380
to have a complete so your pattern match

00:12:08,310 --> 00:12:11,700
has to match all available patterns so

00:12:10,380 --> 00:12:14,279
you can't have one that just falls off

00:12:11,700 --> 00:12:16,970
the else chain in this case we have one

00:12:14,279 --> 00:12:20,250
that says as I the programmer I know

00:12:16,970 --> 00:12:21,660
that yeah I'm getting a float but it can

00:12:20,250 --> 00:12:22,260
only be in these values so if I get

00:12:21,660 --> 00:12:24,029
something else

00:12:22,260 --> 00:12:26,490
yeah you should explode but you have to

00:12:24,029 --> 00:12:32,970
explicitly say here's my else case

00:12:26,490 --> 00:12:34,640
explode but what they mostly do is what

00:12:32,970 --> 00:12:37,320
we saw yesterday in the Swift talk of

00:12:34,640 --> 00:12:39,510
sort of optional types so you have a

00:12:37,320 --> 00:12:42,600
thing that either contains the value you

00:12:39,510 --> 00:12:43,370
want or contains an error or contains

00:12:42,600 --> 00:12:47,510
than none

00:12:43,370 --> 00:12:49,860
depending on if it's a option or maybe

00:12:47,510 --> 00:12:53,699
most of the functional programs do this

00:12:49,860 --> 00:12:55,170
so when you get back something from a

00:12:53,699 --> 00:12:57,540
function that could fail like your

00:12:55,170 --> 00:12:59,070
string parser that would be expected

00:12:57,540 --> 00:13:04,769
that sometimes it might get bit bad data

00:12:59,070 --> 00:13:06,839
and you need to handle that it hands you

00:13:04,769 --> 00:13:09,930
back not a string but an option of an

00:13:06,839 --> 00:13:11,640
optional string so then you actually

00:13:09,930 --> 00:13:13,350
have to physically take a step in the

00:13:11,640 --> 00:13:15,990
the pile step to say

00:13:13,350 --> 00:13:18,120
unwrap this or pattern match this to

00:13:15,990 --> 00:13:19,710
give me the thing inside so that again

00:13:18,120 --> 00:13:24,030
you have to explicitly say what you're

00:13:19,710 --> 00:13:27,000
going to do in the error case and they

00:13:24,030 --> 00:13:31,380
mostly don't have exceptions they kind

00:13:27,000 --> 00:13:34,740
of do but they kind of choose and what

00:13:31,380 --> 00:13:38,640
are exceptions yeah so Java is the

00:13:34,740 --> 00:13:41,670
poster boy for exceptions and they are

00:13:38,640 --> 00:13:43,890
the only ones that do forced checking of

00:13:41,670 --> 00:13:46,980
your exceptions so the exception is

00:13:43,890 --> 00:13:50,130
actually part of the type signature for

00:13:46,980 --> 00:13:51,800
a method so if you want to call this a

00:13:50,130 --> 00:13:54,660
function that could throw an exception

00:13:51,800 --> 00:13:56,250
you have to either handle that exception

00:13:54,660 --> 00:14:00,150
or declare that you're going to pass it

00:13:56,250 --> 00:14:01,650
up to your caller although this leads to

00:14:00,150 --> 00:14:04,230
a slight controversy because there is a

00:14:01,650 --> 00:14:06,690
class of unchecked ones runtime

00:14:04,230 --> 00:14:08,340
exceptions because you can't really know

00:14:06,690 --> 00:14:10,620
what's going to happen that's the

00:14:08,340 --> 00:14:11,340
problem with these exception models you

00:14:10,620 --> 00:14:14,070
think you know what's going to happen

00:14:11,340 --> 00:14:15,420
but then you know maybe your RAM is

00:14:14,070 --> 00:14:20,580
missing somebody pulled it out like

00:14:15,420 --> 00:14:23,550
you're not expecting that good example

00:14:20,580 --> 00:14:25,170
good example so you've got runtime

00:14:23,550 --> 00:14:26,820
exceptions and so you can declare your

00:14:25,170 --> 00:14:28,950
exceptions as run types so that you

00:14:26,820 --> 00:14:31,430
don't have to put them in your type

00:14:28,950 --> 00:14:37,110
signature and this is like really bad

00:14:31,430 --> 00:14:39,930
and yet really easy so it's kind of a

00:14:37,110 --> 00:14:41,340
dirty little how to get around the

00:14:39,930 --> 00:14:43,770
unchecked exceptions but on the other

00:14:41,340 --> 00:14:46,020
side you've got Python in there

00:14:43,770 --> 00:14:49,230
exceptions where you only declare them

00:14:46,020 --> 00:14:50,820
maybe in your documentation and so then

00:14:49,230 --> 00:14:56,430
you have to watch your code for when it

00:14:50,820 --> 00:14:58,890
fails and it can be very frustrating

00:14:56,430 --> 00:15:01,230
this Python programmer when you have

00:14:58,890 --> 00:15:03,450
some code that fails occasionally that

00:15:01,230 --> 00:15:04,770
you didn't see in testing and you didn't

00:15:03,450 --> 00:15:06,180
you don't actually know what exceptions

00:15:04,770 --> 00:15:08,340
being pass because then you have to

00:15:06,180 --> 00:15:10,500
simulate it to get to figure out what

00:15:08,340 --> 00:15:12,630
the exception is or you dig into the

00:15:10,500 --> 00:15:17,210
code to find it because it's often not

00:15:12,630 --> 00:15:20,760
declared and but that part of that is

00:15:17,210 --> 00:15:23,430
they are this is from the the Python

00:15:20,760 --> 00:15:25,379
glossary they look at most of the other

00:15:23,430 --> 00:15:27,449
languages as look before you leap

00:15:25,379 --> 00:15:29,729
definitely the c-style check do I have

00:15:27,449 --> 00:15:31,829
an int before I call this function boom

00:15:29,729 --> 00:15:37,289
and they're like a easier task

00:15:31,829 --> 00:15:39,779
permission so try it see if it fails so

00:15:37,289 --> 00:15:44,209
this this mostly works it can lead to

00:15:39,779 --> 00:15:46,829
some strange things where exceptions are

00:15:44,209 --> 00:15:49,289
flow control they're just kind of hidden

00:15:46,829 --> 00:15:51,479
flow control and sometimes it gets used

00:15:49,289 --> 00:15:53,819
as non hidden flow control so a lot of

00:15:51,479 --> 00:15:55,439
web frameworks for instance you throw an

00:15:53,819 --> 00:15:58,769
exception to say that I'm handling this

00:15:55,439 --> 00:16:00,599
or that I okay make sense you're like oh

00:15:58,769 --> 00:16:02,369
I want to throw 503 sure throw an

00:16:00,599 --> 00:16:04,949
exception that gets handled the top

00:16:02,369 --> 00:16:08,149
layer we also say throw it 200 - say I'm

00:16:04,949 --> 00:16:11,519
done handling this request and that's

00:16:08,149 --> 00:16:13,709
that is not exceptional that is normal

00:16:11,519 --> 00:16:16,909
flow control and should probably be done

00:16:13,709 --> 00:16:20,009
some other way but the easier ask for

00:16:16,909 --> 00:16:22,169
easier to ask permission people have an

00:16:20,009 --> 00:16:23,429
advantage in that they claim well you

00:16:22,169 --> 00:16:25,109
can't know everything that's going to go

00:16:23,429 --> 00:16:27,149
wrong so no matter how defensively

00:16:25,109 --> 00:16:31,399
you're programming something weird is

00:16:27,149 --> 00:16:34,199
going to happen I agree that you should

00:16:31,399 --> 00:16:35,549
you know consider that but if there are

00:16:34,199 --> 00:16:37,559
cases you know will happen you should

00:16:35,549 --> 00:16:40,679
handle them and then make leave

00:16:37,559 --> 00:16:44,699
exceptions for your exceptional cases a

00:16:40,679 --> 00:16:47,669
neat thing with exception handling in

00:16:44,699 --> 00:16:50,399
all languages basically but ours is that

00:16:47,669 --> 00:16:53,519
you are throwing an excellent an

00:16:50,399 --> 00:16:56,029
exception type or object instead of a

00:16:53,519 --> 00:17:00,629
string and we we can throw exceptions

00:16:56,029 --> 00:17:03,089
string objects in pro/5 but we it is

00:17:00,629 --> 00:17:05,009
more rare and what's nice about that is

00:17:03,089 --> 00:17:07,409
then you can do some sort of pattern

00:17:05,009 --> 00:17:09,089
matching on the exceptions you say oh I

00:17:07,409 --> 00:17:10,949
got this kind of exception do this like

00:17:09,089 --> 00:17:13,529
ID this kind do that and it's very clear

00:17:10,949 --> 00:17:17,009
in the except map in here so in this

00:17:13,529 --> 00:17:19,559
example if some other error exception

00:17:17,009 --> 00:17:21,600
other than value errors raised its going

00:17:19,559 --> 00:17:24,750
to go up the chain and somebody else is

00:17:21,600 --> 00:17:27,089
going to have to handle that but if

00:17:24,750 --> 00:17:29,220
somebody you know if you ask someone for

00:17:27,089 --> 00:17:30,240
a number and you're getting user input

00:17:29,220 --> 00:17:32,629
you don't know what you're going to get

00:17:30,240 --> 00:17:35,639
and if it couldn't become an int then

00:17:32,629 --> 00:17:38,340
maybe that's maybe you should throw an

00:17:35,639 --> 00:17:39,040
exception or maybe you can see if it

00:17:38,340 --> 00:17:41,950
kind of looks like

00:17:39,040 --> 00:17:44,650
and just accept it and I feel that's

00:17:41,950 --> 00:17:46,480
what we more often do is we're very

00:17:44,650 --> 00:17:48,940
permissive in what we accept and

00:17:46,480 --> 00:17:51,250
somewhat conservative and what we emit

00:17:48,940 --> 00:17:54,280
and that leads to a whole different

00:17:51,250 --> 00:17:57,360
class of bugs because you don't know

00:17:54,280 --> 00:18:00,700
exactly what is valid and what is not

00:17:57,360 --> 00:18:04,150
C++ added exceptions but they're not

00:18:00,700 --> 00:18:05,560
really sure if they like them and at

00:18:04,150 --> 00:18:08,440
least I have the discussion of well if

00:18:05,560 --> 00:18:10,120
it's low to low level thing that I can

00:18:08,440 --> 00:18:11,710
handle I should should look at the error

00:18:10,120 --> 00:18:14,650
numbers and I should maybe pass that

00:18:11,710 --> 00:18:16,120
back and if it's a bigger thing it's a

00:18:14,650 --> 00:18:19,930
structural thing than I should thrown

00:18:16,120 --> 00:18:22,470
exception but then there's a lot of

00:18:19,930 --> 00:18:25,270
people you know a little friend Joel

00:18:22,470 --> 00:18:27,460
Joel and software is one of the many

00:18:25,270 --> 00:18:30,190
quoted names of the I really hate them

00:18:27,460 --> 00:18:31,960
they're just go twos they are confusing

00:18:30,190 --> 00:18:37,030
you look at code you don't really know

00:18:31,960 --> 00:18:43,180
what it's going to do I that's a little

00:18:37,030 --> 00:18:45,640
extreme and go so one of the changes go

00:18:43,180 --> 00:18:47,680
we went with was hey let's have multiple

00:18:45,640 --> 00:18:50,830
return values and force one of them to

00:18:47,680 --> 00:18:53,290
be an error and so all of your functions

00:18:50,830 --> 00:18:56,290
look like hey I'm going to call this

00:18:53,290 --> 00:18:58,270
function I've got the value I expect and

00:18:56,290 --> 00:19:01,270
I'm going to put in that and I'm going

00:18:58,270 --> 00:19:02,800
to expect an error potentially and then

00:19:01,270 --> 00:19:05,890
you check to see is that error nil and

00:19:02,800 --> 00:19:07,360
if that error is not know then there was

00:19:05,890 --> 00:19:11,020
an error and so you should do something

00:19:07,360 --> 00:19:12,400
about it and then many people will

00:19:11,020 --> 00:19:14,140
rightfully look at this and say well

00:19:12,400 --> 00:19:15,430
that's basically what C was doing and

00:19:14,140 --> 00:19:18,390
that was messy and we didn't like that

00:19:15,430 --> 00:19:21,660
and they counter but it's very clear and

00:19:18,390 --> 00:19:24,490
we force you to check it because if you

00:19:21,660 --> 00:19:27,250
don't get that error value and you don't

00:19:24,490 --> 00:19:28,510
check it then you have a hey you've got

00:19:27,250 --> 00:19:31,110
an error value and didn't check it

00:19:28,510 --> 00:19:34,290
exception at compile time

00:19:31,110 --> 00:19:38,710
so they force you to write correct code

00:19:34,290 --> 00:19:41,530
with a little bit of carrot and a whole

00:19:38,710 --> 00:19:43,150
lot of stick and here's like hey you

00:19:41,530 --> 00:19:44,470
were writing C it was it almost worked

00:19:43,150 --> 00:19:48,910
we might as well just figure out how to

00:19:44,470 --> 00:19:51,400
make it work so we have automatic auto

00:19:48,910 --> 00:19:53,560
Beck memory allocation so you don't have

00:19:51,400 --> 00:19:55,490
to do nearly as much cleanup

00:19:53,560 --> 00:19:57,050
but you still end up with stuff that

00:19:55,490 --> 00:20:00,770
looks like what we had and see with some

00:19:57,050 --> 00:20:02,450
structured go twos and check so it's

00:20:00,770 --> 00:20:06,170
harder to see the happy path but it's

00:20:02,450 --> 00:20:08,840
also clear because it's item check it

00:20:06,170 --> 00:20:10,340
item check it Adam check it a little

00:20:08,840 --> 00:20:13,370
Messier if you have to do cleanup and

00:20:10,340 --> 00:20:16,490
you keep track of what cleanup to do but

00:20:13,370 --> 00:20:18,020
very effective they're happy with it for

00:20:16,490 --> 00:20:20,720
me this is one of the things that made

00:20:18,020 --> 00:20:23,360
me look at go and say well I don't feel

00:20:20,720 --> 00:20:25,850
comfortable I don't like it at a sort of

00:20:23,360 --> 00:20:28,370
physical reaction I need to go back and

00:20:25,850 --> 00:20:35,270
revisit go and see if that's like a real

00:20:28,370 --> 00:20:36,890
thing or just my initial whereas you

00:20:35,270 --> 00:20:38,830
know I looked at pattern matching in

00:20:36,890 --> 00:20:41,420
rust on psychos it's so pretty I love it

00:20:38,830 --> 00:20:46,280
and so what can we do a little bit to

00:20:41,420 --> 00:20:49,100
improve our profiles so one so right we

00:20:46,280 --> 00:20:51,410
we've got the error-checking variant of

00:20:49,100 --> 00:20:52,670
a lot of our things stretch or anything

00:20:51,410 --> 00:20:56,270
where we're interacting with the system

00:20:52,670 --> 00:20:59,360
we have to explicitly check one of our

00:20:56,270 --> 00:21:02,270
air about variables and we get to do

00:20:59,360 --> 00:21:03,740
crazy things like on system it's got the

00:21:02,270 --> 00:21:08,390
upper bits and the lower bits and you do

00:21:03,740 --> 00:21:10,370
some bit manipulate how many people have

00:21:08,390 --> 00:21:13,250
written something to call system and

00:21:10,370 --> 00:21:14,780
like do that for them and then but then

00:21:13,250 --> 00:21:18,640
there was a bug in that and so they're

00:21:14,780 --> 00:21:21,170
returning it wrong and they yeah okay

00:21:18,640 --> 00:21:23,540
but it's there but it's not required and

00:21:21,170 --> 00:21:26,720
you can forget to do it so there's a

00:21:23,540 --> 00:21:28,640
couple ways around that oh well first a

00:21:26,720 --> 00:21:31,790
digression into the air variables right

00:21:28,640 --> 00:21:35,420
we have four of them as you get further

00:21:31,790 --> 00:21:38,210
away from C towards your own program you

00:21:35,420 --> 00:21:44,020
know nobody really uses what is it

00:21:38,210 --> 00:21:48,880
control e because it's a duplicate but

00:21:44,020 --> 00:21:53,090
we've got this lovely five line example

00:21:48,880 --> 00:21:55,640
managers could set all four because it's

00:21:53,090 --> 00:21:58,640
a string D Val that's opening a file and

00:21:55,640 --> 00:22:00,500
it's doing a system and so checking that

00:21:58,640 --> 00:22:02,960
is exciting you'll note that they don't

00:22:00,500 --> 00:22:04,820
bother to actually happy I mean the

00:22:02,960 --> 00:22:05,389
outer eval exception code is not

00:22:04,820 --> 00:22:09,019
actually

00:22:05,389 --> 00:22:14,119
that we have some checks inside so yeah

00:22:09,019 --> 00:22:15,950
at bang control II and question mark for

00:22:14,119 --> 00:22:18,950
what happened and what happened and what

00:22:15,950 --> 00:22:22,999
happened so it's easier to remember but

00:22:18,950 --> 00:22:25,159
we don't have built-in exceptions but we

00:22:22,999 --> 00:22:27,169
have died and we have eval and so you

00:22:25,159 --> 00:22:31,070
can use eval to catch dies and send

00:22:27,169 --> 00:22:34,759
messages around don't don't do this this

00:22:31,070 --> 00:22:38,679
is the hard way you could bring in try

00:22:34,759 --> 00:22:42,709
tiny and this is a much prettier way and

00:22:38,679 --> 00:22:44,659
now instead of it being in dollar ad

00:22:42,709 --> 00:22:45,919
it's in dollar underscore because that's

00:22:44,659 --> 00:22:49,539
more consistent and that's what you

00:22:45,919 --> 00:22:52,940
expect and so that's pretty hot but as

00:22:49,539 --> 00:22:53,269
pointed out to me by my colleague over

00:22:52,940 --> 00:22:56,419
there

00:22:53,269 --> 00:22:58,429
syntax keyword try came out last just

00:22:56,419 --> 00:23:01,459
last year right it's new it's the new

00:22:58,429 --> 00:23:05,629
hotness because look no semicolon at the

00:23:01,459 --> 00:23:07,999
end that's that's a real block and not

00:23:05,629 --> 00:23:10,309
just a thing looking to be like a block

00:23:07,999 --> 00:23:14,679
and so you should probably go use syntax

00:23:10,309 --> 00:23:22,399
keyword try to go try your exceptions

00:23:14,679 --> 00:23:24,739
and they are back in unlike try tiny

00:23:22,399 --> 00:23:28,070
which put them in underscore now they're

00:23:24,739 --> 00:23:29,179
in so it you can't just switch directly

00:23:28,070 --> 00:23:31,479
between them physically it where the

00:23:29,179 --> 00:23:34,429
semicolons and go back to checking

00:23:31,479 --> 00:23:37,249
dollar hat but it's the new hotness and

00:23:34,429 --> 00:23:40,940
you might want to get in on that and

00:23:37,249 --> 00:23:42,229
another way and again we have our own

00:23:40,940 --> 00:23:44,629
discussion on whether or not this is the

00:23:42,229 --> 00:23:47,749
way to go but Auto die can take a lot of

00:23:44,629 --> 00:23:49,729
your manual error checking and say let's

00:23:47,749 --> 00:23:52,249
let's just turn those into exceptions as

00:23:49,729 --> 00:23:54,859
well and so now you don't have to do

00:23:52,249 --> 00:23:57,349
open file or die you just open file and

00:23:54,859 --> 00:24:01,039
alter an exception and then you can do a

00:23:57,349 --> 00:24:02,719
pretty try-catch block around that so

00:24:01,039 --> 00:24:03,859
options that you have and that thing you

00:24:02,719 --> 00:24:06,289
have to do is you should probably do

00:24:03,859 --> 00:24:09,589
this but this is a lot easier than

00:24:06,289 --> 00:24:13,819
checking that you have done an or die or

00:24:09,589 --> 00:24:17,619
a system check on all of your calls that

00:24:13,819 --> 00:24:17,619
could return an error instead of a

00:24:19,039 --> 00:24:25,950
and then purl six not content to do

00:24:23,100 --> 00:24:28,200
everything all the time has decided that

00:24:25,950 --> 00:24:29,490
yes you can catch exceptions and yes

00:24:28,200 --> 00:24:32,750
their syntax will be a little bit

00:24:29,490 --> 00:24:35,340
different so it's an all caps catch

00:24:32,750 --> 00:24:39,600
which will catch any exceptions in that

00:24:35,340 --> 00:24:40,980
in that scope so right that dye happens

00:24:39,600 --> 00:24:45,330
before this catch but it's in the same

00:24:40,980 --> 00:24:46,860
scope so we're going to catch that but

00:24:45,330 --> 00:24:50,090
then once you catch it you exit the

00:24:46,860 --> 00:24:54,570
current scope so it's a little different

00:24:50,090 --> 00:24:55,890
and you and there is a try this one

00:24:54,570 --> 00:24:59,659
didn't have a tries you don't

00:24:55,890 --> 00:25:02,399
necessarily have to try Yoda Yoda proves

00:24:59,659 --> 00:25:06,000
you but you can try and that gives you a

00:25:02,399 --> 00:25:08,190
scope and an implicit catch I haven't

00:25:06,000 --> 00:25:10,020
played with any of this but doing the

00:25:08,190 --> 00:25:13,640
research for this was super fascinating

00:25:10,020 --> 00:25:15,510
especially because we add a continuation

00:25:13,640 --> 00:25:16,980
so you can say yeah that was an

00:25:15,510 --> 00:25:21,450
exception but I don't really think so so

00:25:16,980 --> 00:25:24,870
go back to the code and continue yeah

00:25:21,450 --> 00:25:26,789
that's that's the thing I have no idea

00:25:24,870 --> 00:25:31,649
do you have any pro Sixers in the house

00:25:26,789 --> 00:25:33,840
who have tried exceptions and not

00:25:31,649 --> 00:25:36,929
resuming them so this slide is mostly

00:25:33,840 --> 00:25:38,520
about how to throw an exception so and

00:25:36,929 --> 00:25:40,320
exceptions are objects now which is

00:25:38,520 --> 00:25:45,779
awesome because then you can do patterns

00:25:40,320 --> 00:25:49,049
on them but you can now resume which is

00:25:45,779 --> 00:25:52,380
weird to me so does anybody used resume

00:25:49,049 --> 00:25:54,330
our pro six are in the back no I would

00:25:52,380 --> 00:25:57,990
love that someone explained to me when

00:25:54,330 --> 00:25:59,789
you know that it's safe to tell some

00:25:57,990 --> 00:26:03,690
exception throwing code that it's okay

00:25:59,789 --> 00:26:05,460
to resume and so at the questions at the

00:26:03,690 --> 00:26:09,360
end I would love to hear about that hey

00:26:05,460 --> 00:26:11,220
it's questions again so I did and then I

00:26:09,360 --> 00:26:12,929
was like questions which means answers

00:26:11,220 --> 00:26:19,820
and I have two hands and I would love to

00:26:12,929 --> 00:26:19,820
hear from the purple there mm-hmm

00:26:36,550 --> 00:26:43,850
so for the slide for the people online

00:26:39,350 --> 00:26:47,150
that was in Pro 5 sometimes in character

00:26:43,850 --> 00:26:50,540
code transitions you'll see a multiple

00:26:47,150 --> 00:26:52,010
try because you need to do it multiple

00:26:50,540 --> 00:26:58,250
times to actually get to a place that

00:26:52,010 --> 00:27:27,830
works so that kind of excellent the

00:26:58,250 --> 00:27:30,980
Conway awesome so uh Damien excuse me

00:27:27,830 --> 00:27:33,320
the Damien has commented that one of the

00:27:30,980 --> 00:27:35,620
reasons we added resume was maybe your

00:27:33,320 --> 00:27:39,980
exception handler can fix the problem so

00:27:35,620 --> 00:27:42,080
you tried to read from a disk that's not

00:27:39,980 --> 00:27:43,400
mounted and it can maybe go mount it and

00:27:42,080 --> 00:27:44,930
then you can continue from that point

00:27:43,400 --> 00:27:47,840
rather than having to start your whole

00:27:44,930 --> 00:27:49,280
function over again which when you put

00:27:47,840 --> 00:27:54,500
it that way sounds awesome and why

00:27:49,280 --> 00:27:57,860
doesn't everybody else do it and because

00:27:54,500 --> 00:28:00,620
of time and more on the slide prep times

00:27:57,860 --> 00:28:03,830
and in the talk time I didn't really get

00:28:00,620 --> 00:28:06,050
to the JavaScript continuations which

00:28:03,830 --> 00:28:09,530
were kind of an interesting topic from

00:28:06,050 --> 00:28:14,510
when I tried this talk last month at LA

00:28:09,530 --> 00:28:16,070
p.m. to go literally p.m. in that their

00:28:14,510 --> 00:28:19,790
continuation style and their training

00:28:16,070 --> 00:28:21,830
style says no we don't we don't want to

00:28:19,790 --> 00:28:24,470
give back a result value we want to give

00:28:21,830 --> 00:28:27,410
back the result and then let you keep

00:28:24,470 --> 00:28:29,390
doing stuff with the result and to make

00:28:27,410 --> 00:28:32,240
that work you either need to be throwing

00:28:29,390 --> 00:28:38,060
some exceptions or you do what they're

00:28:32,240 --> 00:28:39,320
doing in their sort of multi-threaded

00:28:38,060 --> 00:28:41,780
well okay excuse me

00:28:39,320 --> 00:28:44,330
their concern concurrency model wherein

00:28:41,780 --> 00:28:47,620
you pass a continuation of when this

00:28:44,330 --> 00:28:50,290
happens then go do this then go do that

00:28:47,620 --> 00:28:52,390
using there and then

00:28:50,290 --> 00:28:55,960
and that is sort of a way to do the air

00:28:52,390 --> 00:28:57,820
handling such that it's clear that

00:28:55,960 --> 00:29:02,350
you're doing this and then that and then

00:28:57,820 --> 00:29:04,690
that but a 10 line continuation chain is

00:29:02,350 --> 00:29:06,940
not any clearer than these other ways so

00:29:04,690 --> 00:29:09,100
what I mostly want to tell you is that

00:29:06,940 --> 00:29:12,580
we can catch our errors and we should

00:29:09,100 --> 00:29:14,050
and we document them and hopefully

00:29:12,580 --> 00:29:16,240
you'll get some ideas from what other

00:29:14,050 --> 00:29:17,830
languages are doing and yet at the same

00:29:16,240 --> 00:29:19,890
time not feel like you're missing out

00:29:17,830 --> 00:29:22,420
because you can do most of what they can

00:29:19,890 --> 00:29:25,840
any much time do I have

00:29:22,420 --> 00:29:27,520
curious like two minutes okay cool so

00:29:25,840 --> 00:29:44,200
I'll take some more questions if we have

00:29:27,520 --> 00:29:44,700
any let's say oh you in the back the

00:29:44,200 --> 00:29:46,500
question

00:29:44,700 --> 00:29:49,730
how do I feel about exception objects

00:29:46,500 --> 00:29:54,090
versus plain die for pro/5 exceptions

00:29:49,730 --> 00:29:56,250
I'm obviously a big fan because I I

00:29:54,090 --> 00:29:59,400
think that one you have more information

00:29:56,250 --> 00:30:02,330
and - it's programmatically easier to

00:29:59,400 --> 00:30:05,940
work with because your exception object

00:30:02,330 --> 00:30:07,530
can have that string for instance and

00:30:05,940 --> 00:30:10,800
then it can have other information so

00:30:07,530 --> 00:30:12,300
you can change the string and maybe you

00:30:10,800 --> 00:30:15,120
need to reword it and it needs to be

00:30:12,300 --> 00:30:17,160
clear and you can actually change that

00:30:15,120 --> 00:30:22,350
and not break all the consumers of your

00:30:17,160 --> 00:30:28,310
library also doing matches on what is

00:30:22,350 --> 00:30:30,690
this object using like is a-- is a

00:30:28,310 --> 00:30:32,370
personally a preferred way to strings

00:30:30,690 --> 00:30:36,180
because otherwise we're doing string

00:30:32,370 --> 00:30:38,820
manipulation which is Vicki that said

00:30:36,180 --> 00:30:39,930
it's not nearly as nice as a language

00:30:38,820 --> 00:30:41,610
that has a built in with pattern

00:30:39,930 --> 00:30:46,220
matching I mean unless you're doing some

00:30:41,610 --> 00:30:50,340
sort of case on the type but I feel like

00:30:46,220 --> 00:30:53,700
moving forward to exception objects at

00:30:50,340 --> 00:30:55,440
all would be a win and then we can worry

00:30:53,700 --> 00:30:56,900
about if oh there's too many different

00:30:55,440 --> 00:30:58,620
types of classes and it's hard to match

00:30:56,900 --> 00:31:00,750
because right now we have too many

00:30:58,620 --> 00:31:03,810
different strings and I know we love

00:31:00,750 --> 00:31:10,130
strings love reg axes reg X's in your

00:31:03,810 --> 00:31:12,360
exception handler to me anti-pattern X

00:31:10,130 --> 00:31:18,390
see what do I have left in my bonus

00:31:12,360 --> 00:31:20,910
slides um so a bonus slide on Haskell so

00:31:18,390 --> 00:31:24,150
they take the same approach with a

00:31:20,910 --> 00:31:28,370
monadic either and mostly because they

00:31:24,150 --> 00:31:32,730
like to use the word magnetic but a

00:31:28,370 --> 00:31:39,720
really exciting insight to the change

00:31:32,730 --> 00:31:41,190
that they made is only accept excusing

00:31:39,720 --> 00:31:44,340
exceptions are only coming out of code

00:31:41,190 --> 00:31:48,210
the deal with the outside world that are

00:31:44,340 --> 00:31:50,370
impure they love to be pure course in a

00:31:48,210 --> 00:31:51,420
pure world young do anything so at some

00:31:50,370 --> 00:31:54,390
point you have to interact with the user

00:31:51,420 --> 00:31:55,530
or the system and once you declare that

00:31:54,390 --> 00:31:57,180
you're going to interact with the system

00:31:55,530 --> 00:31:59,570
now you can start throwing some

00:31:57,180 --> 00:31:59,570
exception

00:31:59,950 --> 00:32:05,570
but if you are not interacting with with

00:32:03,410 --> 00:32:12,470
the user then you're expected to hand

00:32:05,570 --> 00:32:17,780
back a an optional type which they call

00:32:12,470 --> 00:32:26,600
what either maybe wear which contains

00:32:17,780 --> 00:32:28,850
either the value o or the air and but

00:32:26,600 --> 00:32:31,370
the idea of splitting up between that

00:32:28,850 --> 00:32:35,540
line of okay these are truly exceptional

00:32:31,370 --> 00:32:37,360
things they're outside of my world so

00:32:35,540 --> 00:32:40,550
I'm dealing with the outside world

00:32:37,360 --> 00:32:42,910
versus internal things which I should be

00:32:40,550 --> 00:32:45,200
able to fix and we can we can use that

00:32:42,910 --> 00:32:49,490
when you're writing your libraries like

00:32:45,200 --> 00:32:51,500
okay is this did the air did the user

00:32:49,490 --> 00:32:55,100
give me some bad input maybe I can fix

00:32:51,500 --> 00:32:59,030
it maybe I can't versus the database is

00:32:55,100 --> 00:33:00,290
down I should just probably explode but

00:32:59,030 --> 00:33:01,700
if there are things that you can handle

00:33:00,290 --> 00:33:05,090
and you can handle cleanly you should do

00:33:01,700 --> 00:33:06,620
that but sometimes you don't know how to

00:33:05,090 --> 00:33:08,240
handle it and that's where exceptions

00:33:06,620 --> 00:33:12,440
are more useful you can pass them back

00:33:08,240 --> 00:33:14,630
to the user or one level of application

00:33:12,440 --> 00:33:17,240
up to say hey we can't really do this

00:33:14,630 --> 00:33:18,260
thing what should we do now and as well

00:33:17,240 --> 00:33:21,140
I very officer you don't necessarily

00:33:18,260 --> 00:33:26,630
know the right the right way to handle

00:33:21,140 --> 00:33:29,630
airs that are at that level another neat

00:33:26,630 --> 00:33:30,710
thing with Haskell and I don't think I'm

00:33:29,630 --> 00:33:33,160
sure some of the other functional ones

00:33:30,710 --> 00:33:37,730
have this so once you have one of these

00:33:33,160 --> 00:33:42,170
either types you can apply functions to

00:33:37,730 --> 00:33:45,470
it that unwrap it apply to the inside

00:33:42,170 --> 00:33:47,060
and rewrap it and so you can say do this

00:33:45,470 --> 00:33:48,500
thing and this thing and this thing and

00:33:47,060 --> 00:33:50,570
this thing and once you've chained them

00:33:48,500 --> 00:33:52,790
all together if any of those gives an

00:33:50,570 --> 00:33:56,720
error they just pass that error through

00:33:52,790 --> 00:34:01,280
because each of these applicant error

00:33:56,720 --> 00:34:03,200
functors each one recognizes oh I was

00:34:01,280 --> 00:34:04,640
handed an error so I'll just Pat I don't

00:34:03,200 --> 00:34:06,920
do anything as a short circuit to error

00:34:04,640 --> 00:34:09,250
but if I got a good value I'll do the

00:34:06,920 --> 00:34:10,909
next chain I mean so this makes the

00:34:09,250 --> 00:34:14,259
reasoning of the

00:34:10,909 --> 00:34:17,230
we passed much clearer so I'm like it

00:34:14,259 --> 00:34:21,109
I've written about this much Haskell but

00:34:17,230 --> 00:34:24,980
I was paid well okay I did it while I

00:34:21,109 --> 00:34:28,190
was getting paid so that's sort of the

00:34:24,980 --> 00:34:30,259
sort of counts because are we use a

00:34:28,190 --> 00:34:33,769
Haskell based wiki at work and I wrote a

00:34:30,259 --> 00:34:43,639
plug-in wrote I copied and pasted most

00:34:33,769 --> 00:34:45,440
of up like in the back the question was

00:34:43,639 --> 00:34:46,940
do I know a regular meetup in the Los

00:34:45,440 --> 00:34:48,409
Angeles area where I could discuss this

00:34:46,940 --> 00:34:51,220
sort of thing now that's interesting I

00:34:48,409 --> 00:34:53,269
do know a really good one in New York

00:34:51,220 --> 00:34:54,799
but if you are in Los Angeles I do

00:34:53,269 --> 00:34:56,990
recommend the Los Angeles Pro monitors

00:34:54,799 --> 00:34:59,630
follow us on the Twitter's we're not

00:34:56,990 --> 00:35:04,549
actually on the Twitter's but hashtag LA

00:34:59,630 --> 00:35:08,359
p.m. and we are on LA p.m. org on a

00:35:04,549 --> 00:35:11,420
about to be destroyed we still use

00:35:08,359 --> 00:35:14,509
WebDAV on the hosted PM org so anybody

00:35:11,420 --> 00:35:16,250
anybody use that we got our please

00:35:14,509 --> 00:35:19,880
discontinue using this message last

00:35:16,250 --> 00:35:24,680
month so we might be on meetups and who

00:35:19,880 --> 00:35:31,099
knows yes and with that I will say thank

00:35:24,680 --> 00:35:33,289
you page 200 there's another question

00:35:31,099 --> 00:35:36,319
from the front are there any other any

00:35:33,289 --> 00:35:38,180
awesome boots out there and the zipper

00:35:36,319 --> 00:35:39,259
cruder plant in the front row says have

00:35:38,180 --> 00:35:40,609
been working at the booth and it's

00:35:39,259 --> 00:35:43,359
awesome you should come out and get a

00:35:40,609 --> 00:35:49,460
shirt they're very pretty like an 8-bit

00:35:43,359 --> 00:35:52,460
velociraptor alright so historically my

00:35:49,460 --> 00:35:55,150
talks have gone way way way over time so

00:35:52,460 --> 00:35:58,549
I cut a bunch of slides and talk fast so

00:35:55,150 --> 00:35:59,990
hopefully now you'll be able to oh by

00:35:58,549 --> 00:36:04,960
the way that is a shirt I'll look at

00:35:59,990 --> 00:36:04,960
that shirt pretty distraction and I'm at

00:36:06,110 --> 00:36:12,090
yeah how many of you do do use I'm

00:36:10,950 --> 00:36:15,660
curious on some of these things so Auto

00:36:12,090 --> 00:36:20,160
die in your sort of personal code in

00:36:15,660 --> 00:36:26,190
your work ah would tell me more

00:36:20,160 --> 00:36:30,630
use fatal sort of the same thing oh you

00:36:26,190 --> 00:36:32,760
say don't open that sounds good we and

00:36:30,630 --> 00:36:34,050
if we made all calls to open died that

00:36:32,760 --> 00:36:35,090
would be even better right because then

00:36:34,050 --> 00:36:41,460
we'd be done

00:36:35,090 --> 00:36:44,490
okay which is an interesting one with C

00:36:41,460 --> 00:36:46,410
C++ you have assertions and you're like

00:36:44,490 --> 00:36:48,000
oh I'm going to assert that people gave

00:36:46,410 --> 00:36:50,520
me a value that's not null and this and

00:36:48,000 --> 00:36:53,550
that but then in production let's get

00:36:50,520 --> 00:36:55,890
turned off so not a useful way to do

00:36:53,550 --> 00:37:04,260
Erik checking I saw hand

00:36:55,890 --> 00:37:06,450
I don't currently I would like to find

00:37:04,260 --> 00:37:08,460
one that I like but I died the question

00:37:06,450 --> 00:37:11,640
was to have a preferred error object

00:37:08,460 --> 00:37:13,140
system for profiles and there's a

00:37:11,640 --> 00:37:14,270
another question in the back row which

00:37:13,140 --> 00:37:20,010
might be related

00:37:14,270 --> 00:37:27,360
yes throwable yes throwables good I will

00:37:20,010 --> 00:37:30,840
agree with you on that throwable all

00:37:27,360 --> 00:37:32,720
righty dudes so fun so uh and then how

00:37:30,840 --> 00:37:36,420
many of you are still catching air like

00:37:32,720 --> 00:37:46,380
what do you use try catch evals ignore

00:37:36,420 --> 00:37:47,880
dies anybody a vow a vow have you looked

00:37:46,380 --> 00:37:52,260
at what you have to do for eval manually

00:37:47,880 --> 00:37:54,420
no okay you should probably not just

00:37:52,260 --> 00:37:57,720
ignore them

00:37:54,420 --> 00:37:59,460
I mean it you could do it it's what you

00:37:57,720 --> 00:38:01,950
know Python programmers like to do right

00:37:59,460 --> 00:38:04,100
oh you hit control-c boom here's a stack

00:38:01,950 --> 00:38:04,100
trace

00:38:05,400 --> 00:38:12,680
and I'm a also a Python programmer so I

00:38:08,670 --> 00:38:16,890
can say that global die handlers um whoo

00:38:12,680 --> 00:38:18,120
yeah that is that is the thing so if you

00:38:16,890 --> 00:38:21,740
use a global diet and lair

00:38:18,120 --> 00:38:24,510
you can catch and do some cleanups but

00:38:21,740 --> 00:38:29,490
unless I'm wrong here that's really hard

00:38:24,510 --> 00:38:30,900
to continue operating right maybe not

00:38:29,490 --> 00:38:32,280
I'm having a discussion with the void

00:38:30,900 --> 00:38:35,720
over there so I'm not sure who who

00:38:32,280 --> 00:38:35,720
shouted that out that was you all right

00:38:39,830 --> 00:38:44,460
so a problem with global handlers is

00:38:43,170 --> 00:38:45,750
that they'll get called for all of your

00:38:44,460 --> 00:38:48,840
exceptions even the ones that you've

00:38:45,750 --> 00:38:51,420
already caught another problem with

00:38:48,840 --> 00:38:53,940
those is anytime you're doing handlers

00:38:51,420 --> 00:38:57,390
and then you have him there stepping on

00:38:53,940 --> 00:38:58,590
each other and nevermind I'm I'm not

00:38:57,390 --> 00:39:01,170
going to go into handlers they're

00:38:58,590 --> 00:39:06,210
wonderful they're your friend don't use

00:39:01,170 --> 00:39:08,610
them okay another one I wanted to add in

00:39:06,210 --> 00:39:11,130
in my my bonus material but I don't

00:39:08,610 --> 00:39:14,190
recall it was but let's just look at the

00:39:11,130 --> 00:39:17,840
beauty that is the lamed up haskell go

00:39:14,190 --> 00:39:20,340
back off of that one feel free to and

00:39:17,840 --> 00:39:23,990
chat me your other questions follow me

00:39:20,340 --> 00:39:23,990
on the twits i have a purple one yes

00:39:24,980 --> 00:39:31,920
do I have anything to say about failures

00:39:27,210 --> 00:39:33,570
and pro six failure singular and that

00:39:31,920 --> 00:39:39,060
kind of leads into my answer which is no

00:39:33,570 --> 00:39:42,480
I don't my pro six knowledge is at best

00:39:39,060 --> 00:39:46,230
rusty which means pretty much out of

00:39:42,480 --> 00:39:48,810
sync since while I want to get back into

00:39:46,230 --> 00:39:53,550
playing with some pro six my last one

00:39:48,810 --> 00:39:56,310
was at a tio p.m. meetup actually but

00:39:53,550 --> 00:39:58,020
that was some years ago we did get the

00:39:56,310 --> 00:40:00,150
thousand oaks released named after us

00:39:58,020 --> 00:40:02,160
because we tried to write pro six so

00:40:00,150 --> 00:40:05,660
that was me but the last time I wrote it

00:40:02,160 --> 00:40:05,660
we were spending most of our time

00:40:05,690 --> 00:40:12,750
implementing actual interfaces to the

00:40:10,710 --> 00:40:14,910
world rather than writing our code so I

00:40:12,750 --> 00:40:19,310
have no idea but do you have an opinion

00:40:14,910 --> 00:40:19,310
on sorry after my long rambling story

00:40:23,760 --> 00:40:26,839
[Music]

00:40:27,650 --> 00:40:33,450
all right but I'm all in favor of

00:40:31,380 --> 00:40:36,090
getting our exceptions and our other

00:40:33,450 --> 00:40:39,210
error-handling clean and documented and

00:40:36,090 --> 00:40:42,330
happy because then we're happy and I

00:40:39,210 --> 00:40:46,230
want you so sure you I want you happy

00:40:42,330 --> 00:40:48,680
okay miss Graham is sad all the time and

00:40:46,230 --> 00:40:50,400
I want him to be happy

00:40:48,680 --> 00:40:59,010
thank you all

00:40:50,400 --> 00:40:59,010

YouTube URL: https://www.youtube.com/watch?v=VbObDEH-jKY


