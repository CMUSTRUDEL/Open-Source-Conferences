Title: Bulk88 - "Writing XS in Plain C":
Publication date: 2017-06-23
Playlist: TPC 2017 in DC
Description: 
	Even if you learned C in a classroom at some point, Perl's "XS" API for writing perl subs in something purported to be C but is really a cat on a tablet with caps lock on. In this talk I will show how difficult it is to write subs in plain C. This talk will make XS seem like a cakewalk.

Bulk88 has been working with Perl for 14 years. He is a frequent contributor to Perl 5 Porters, with a particular interest in optimization and Win32 support. While he loves Perl, he's also happy being close to bare metal, including both ARM and x86 assembly programming.
Captions: 
	00:00:00,030 --> 00:00:11,519
oh I hope our technical difficulty lays

00:00:08,429 --> 00:00:16,020
well sorry for that welcome to writing

00:00:11,519 --> 00:00:19,109
excess in planes see my name this talk

00:00:16,020 --> 00:00:27,150
was inspired by an idea suggested to me

00:00:19,109 --> 00:00:29,490
by Stefan this talk was inspired by an

00:00:27,150 --> 00:00:31,500
idea that was given to me by Stefan

00:00:29,490 --> 00:00:36,480
Muller the code samples for this talk

00:00:31,500 --> 00:00:37,440
are on github my name is bulk 88 I have

00:00:36,480 --> 00:00:39,450
a pause ID

00:00:37,440 --> 00:00:42,680
I mostly contribute and I'm seen in the

00:00:39,450 --> 00:00:45,420
Perl community on the p5p mailing list I

00:00:42,680 --> 00:00:48,780
use Perl on Windows and I do a lot of

00:00:45,420 --> 00:00:52,680
Perl Windows C coding and Perl internals

00:00:48,780 --> 00:00:55,379
coding this talk is advanced it assumes

00:00:52,680 --> 00:00:59,129
you have some C knowledge and at least

00:00:55,379 --> 00:01:01,820
once tried to code in excess or you went

00:00:59,129 --> 00:01:05,489
to Nicholas ours internals talk today

00:01:01,820 --> 00:01:08,400
the Perl interpreter is written in c 89

00:01:05,489 --> 00:01:10,590
it's a large pile of machine code it is

00:01:08,400 --> 00:01:13,020
memory unsafe the perl interpreter is

00:01:10,590 --> 00:01:15,689
not written in java and it doesn't do

00:01:13,020 --> 00:01:18,090
JIT internally there's basically one way

00:01:15,689 --> 00:01:20,580
to escape the perl interpreter you can

00:01:18,090 --> 00:01:24,090
use JSON RPC and sockets to a daemon

00:01:20,580 --> 00:01:26,100
written in C no I'm kidding there's two

00:01:24,090 --> 00:01:29,220
ways to escape the pure Perl language

00:01:26,100 --> 00:01:33,659
the first one is X subs and the second

00:01:29,220 --> 00:01:36,630
is by using op tree keywords um

00:01:33,659 --> 00:01:39,299
X ups can be patched at runtime by

00:01:36,630 --> 00:01:42,030
swapping the subroutines basically a tin

00:01:39,299 --> 00:01:45,570
type globs keywords are permanently

00:01:42,030 --> 00:01:47,060
baked into their call callers and cannot

00:01:45,570 --> 00:01:49,860
be monkey patched at runtime

00:01:47,060 --> 00:01:52,259
perl is also kind of fast so sometimes

00:01:49,860 --> 00:01:56,219
you have to use C for speed and

00:01:52,259 --> 00:02:00,149
performance reasons excess code is

00:01:56,219 --> 00:02:03,180
converted to C code by a tool called

00:02:00,149 --> 00:02:05,490
X sub P P which is a currently as a

00:02:03,180 --> 00:02:07,920
wrapper around X details par success

00:02:05,490 --> 00:02:09,959
although originally X sub P P was a

00:02:07,920 --> 00:02:11,970
standalone tool and was not a module

00:02:09,959 --> 00:02:15,120
that could be reused

00:02:11,970 --> 00:02:18,660
X sub P P is really old it's from 1993

00:02:15,120 --> 00:02:20,850
from Perl 5 alpha 4 it's a source code

00:02:18,660 --> 00:02:24,030
derivative of a tool called tusks or

00:02:20,850 --> 00:02:29,340
type map user subs that was in Perl 5

00:02:24,030 --> 00:02:31,860
alpha 3 in 1993 pus is even has even an

00:02:29,340 --> 00:02:35,060
older predecessor called must for make

00:02:31,860 --> 00:02:38,100
user subs which is from peril 3 from

00:02:35,060 --> 00:02:42,150
1990 so this is X sub P P is very

00:02:38,100 --> 00:02:44,040
ancient or in its codebase mas was

00:02:42,150 --> 00:02:47,990
originally invented by Larry well

00:02:44,040 --> 00:02:51,570
probably to link to the curses library

00:02:47,990 --> 00:02:54,660
it's that old to understand why the XS

00:02:51,570 --> 00:02:57,150
syntax just is so confusing compared to

00:02:54,660 --> 00:03:00,209
modern see you have to understand that

00:02:57,150 --> 00:03:04,050
excess excess was invented during the

00:03:00,209 --> 00:03:07,170
era of K and RC not c89 because it's

00:03:04,050 --> 00:03:09,390
that old and it was one year old when it

00:03:07,170 --> 00:03:12,870
was invented so c89 was a newest thing

00:03:09,390 --> 00:03:15,300
on the block also XS is considered to be

00:03:12,870 --> 00:03:20,250
macro soup and the Perl capi

00:03:15,300 --> 00:03:22,739
is macro soup there are benefits of

00:03:20,250 --> 00:03:25,320
using XS first trying to manually write

00:03:22,739 --> 00:03:28,709
the C code you get portability across

00:03:25,320 --> 00:03:31,340
multiple Perl versions and releases p5p

00:03:28,709 --> 00:03:34,350
can optimize the macros and be a

00:03:31,340 --> 00:03:36,660
background implementation of the Perl

00:03:34,350 --> 00:03:40,350
API and you still have source code

00:03:36,660 --> 00:03:47,489
compatibility p5p switches the fact the

00:03:40,350 --> 00:03:50,489
implementation of the macros but don't

00:03:47,489 --> 00:03:52,380
go whining to p5p that your code was

00:03:50,489 --> 00:03:54,750
broken if you try using anything in this

00:03:52,380 --> 00:03:57,780
talk because this is all internal stuff

00:03:54,750 --> 00:04:00,959
this isn't a public API of Perl my

00:03:57,780 --> 00:04:02,940
examples are from 522 the they problem

00:04:00,959 --> 00:04:04,920
the code samples later on probably still

00:04:02,940 --> 00:04:07,530
work but there's absolutely no

00:04:04,920 --> 00:04:13,320
guarantees they work because P 5 P is

00:04:07,530 --> 00:04:16,680
not the public API of XS how to make X

00:04:13,320 --> 00:04:19,590
subs appear in the Perl language it's a

00:04:16,680 --> 00:04:22,049
little complicated of your p.m. file

00:04:19,590 --> 00:04:25,380
called XS loader or Dino loader they're

00:04:22,049 --> 00:04:25,780
almost identical internally XS loader

00:04:25,380 --> 00:04:29,470
then

00:04:25,780 --> 00:04:31,540
calls in the diagram the blue boxes are

00:04:29,470 --> 00:04:36,340
subroutines written in pure pearl and

00:04:31,540 --> 00:04:39,580
yellow is written in X s and C code so

00:04:36,340 --> 00:04:43,300
excess loader calls BL load file which

00:04:39,580 --> 00:04:46,060
is a permanently compiled in X sub in

00:04:43,300 --> 00:04:48,730
the Perl interpreter it comes that way

00:04:46,060 --> 00:04:51,610
out of the box the yellowed file calls

00:04:48,730 --> 00:04:54,610
your OS to load a shared library into

00:04:51,610 --> 00:04:56,560
your process the OS shared library

00:04:54,610 --> 00:04:59,290
loader will return the library pointer

00:04:56,560 --> 00:05:01,480
back to DLL file the L load file then

00:04:59,290 --> 00:05:05,410
makes this library pointer appear in

00:05:01,480 --> 00:05:09,190
pure Perl or in the Perl language the

00:05:05,410 --> 00:05:11,530
next access loader takes your takes the

00:05:09,190 --> 00:05:13,750
module name it prefixes food and

00:05:11,530 --> 00:05:16,510
replaces all colons with underscores

00:05:13,750 --> 00:05:18,880
make a C symbol name out of your package

00:05:16,510 --> 00:05:22,060
it then again calls the OS shared

00:05:18,880 --> 00:05:24,160
library loader will be l it calls the l

00:05:22,060 --> 00:05:26,200
find symbol dl find symbol then calls

00:05:24,160 --> 00:05:28,479
the shared library loader again and

00:05:26,200 --> 00:05:32,890
looks up the c symbol in your shared

00:05:28,479 --> 00:05:37,440
library that implements the boot exome

00:05:32,890 --> 00:05:37,440
or the main X sub of your shared library

00:05:37,560 --> 00:05:44,770
X sub P P typically of the COBIT it

00:05:42,010 --> 00:05:47,710
generates it keeps all the X sub except

00:05:44,770 --> 00:05:50,320
the boot X sub as static functions and

00:05:47,710 --> 00:05:53,500
they are as to not pollute the global

00:05:50,320 --> 00:05:55,840
symbol table inside the process which on

00:05:53,500 --> 00:05:58,930
Windows is a dll export table or on

00:05:55,840 --> 00:06:03,610
Linux is the procedure linkage table and

00:05:58,930 --> 00:06:06,669
global offset cases so the boot X sub is

00:06:03,610 --> 00:06:08,560
the only X is the only C function that

00:06:06,669 --> 00:06:11,650
your shared library has to make

00:06:08,560 --> 00:06:15,340
externally visible to the rest of the

00:06:11,650 --> 00:06:17,770
sea world inside your process once the

00:06:15,340 --> 00:06:20,380
XS once excess loader gets the C

00:06:17,770 --> 00:06:23,830
function pointer of your X sub it will

00:06:20,380 --> 00:06:28,390
call GL install X sub DL install X sub

00:06:23,830 --> 00:06:30,250
takes a takes the name of your sub

00:06:28,390 --> 00:06:32,530
routine that you want it creates a pipe

00:06:30,250 --> 00:06:34,870
and then takes the C function form of

00:06:32,530 --> 00:06:37,750
your X sub it then creates a type Bob

00:06:34,870 --> 00:06:39,400
and then creates a pearl subroutine

00:06:37,750 --> 00:06:42,340
inside of that type

00:06:39,400 --> 00:06:45,310
and now your ex sub is has appeared in

00:06:42,340 --> 00:06:50,350
the Perl language and you can call it

00:06:45,310 --> 00:06:52,840
your after your ex sub is appears in the

00:06:50,350 --> 00:06:55,210
Perl language your ex sub is called and

00:06:52,840 --> 00:06:56,590
this is the first time your C code you

00:06:55,210 --> 00:07:00,910
get control inside the Perl interpreter

00:06:56,590 --> 00:07:03,400
or Perl process from a see aspect almost

00:07:00,910 --> 00:07:06,580
all boot X subs will repeatedly call new

00:07:03,400 --> 00:07:09,190
XS registering additional X sub in the

00:07:06,580 --> 00:07:12,490
process the blue text sub can also in a

00:07:09,190 --> 00:07:16,419
often sometimes initializes like global

00:07:12,490 --> 00:07:18,400
sea variables that other X lobs in the

00:07:16,419 --> 00:07:21,789
shared library are going to reference at

00:07:18,400 --> 00:07:24,039
some point once your boot X sub returns

00:07:21,789 --> 00:07:26,520
control back to X's loader XS loader

00:07:24,039 --> 00:07:32,320
immediately just returns back to your

00:07:26,520 --> 00:07:35,620
pm5 every single pearl x sub on a free

00:07:32,320 --> 00:07:37,750
level must have this prototype now I

00:07:35,620 --> 00:07:40,060
said I don't want to show macro soup to

00:07:37,750 --> 00:07:42,009
all of you but there is one macro I I

00:07:40,060 --> 00:07:46,389
will be using for the rest of all code

00:07:42,009 --> 00:07:49,300
samples which is the PTH X macro all X

00:07:46,389 --> 00:07:52,090
subs take the P th x argument which is a

00:07:49,300 --> 00:07:54,479
Perl engine pointer and they drop out

00:07:52,090 --> 00:07:57,190
the first argument if it's an unread in

00:07:54,479 --> 00:08:00,580
though to keep things sane and not have

00:07:57,190 --> 00:08:03,310
a pile of if F the PTH X macro I

00:08:00,580 --> 00:08:06,430
included in all slides it does not exist

00:08:03,310 --> 00:08:09,490
on unthreaded Perl both threaded and

00:08:06,430 --> 00:08:12,060
unthreaded pearls will take a cv pointer

00:08:09,490 --> 00:08:15,190
as the second argument and this is the

00:08:12,060 --> 00:08:17,320
subroutine on the cur on the sea side of

00:08:15,190 --> 00:08:22,630
the pearl engine that represents a sub

00:08:17,320 --> 00:08:25,150
on the sea side this is the layout of

00:08:22,630 --> 00:08:27,880
that PD pointer that is the second

00:08:25,150 --> 00:08:29,849
argument to your X sub I

00:08:27,880 --> 00:08:32,320
I've colored some interest some

00:08:29,849 --> 00:08:34,150
interesting fields here the green fields

00:08:32,320 --> 00:08:37,300
you interact with as an access

00:08:34,150 --> 00:08:39,580
programmer the right field all the red

00:08:37,300 --> 00:08:43,060
members in the sea we struck you are

00:08:39,580 --> 00:08:45,040
only meaning to pure Perl subroutines

00:08:43,060 --> 00:08:47,620
they have no meaning to an expert Winx

00:08:45,040 --> 00:08:48,080
zone the yellow stuff you may use some

00:08:47,620 --> 00:08:52,040
time

00:08:48,080 --> 00:08:54,800
as in Texas program up here we have the

00:08:52,040 --> 00:08:57,769
C function pointer that is the X up and

00:08:54,800 --> 00:09:00,410
purl you write the C function pointer

00:08:57,769 --> 00:09:06,110
that will this is what you compiled up

00:09:00,410 --> 00:09:09,200
here the green CVX thumb pointer there's

00:09:06,110 --> 00:09:11,180
also a second member in the CV stroke

00:09:09,200 --> 00:09:12,890
that's quite interesting to an XS

00:09:11,180 --> 00:09:16,399
programmer which is called the any

00:09:12,890 --> 00:09:19,310
member this is an unused void pointer by

00:09:16,399 --> 00:09:21,410
the Perl engine and it is useful for

00:09:19,310 --> 00:09:24,829
making like closure X subs or putting

00:09:21,410 --> 00:09:27,110
c++ object pointers in here the any

00:09:24,829 --> 00:09:29,450
member does not have any backing storage

00:09:27,110 --> 00:09:31,790
or ownership or reference counting or

00:09:29,450 --> 00:09:33,740
any way to free it so you need to store

00:09:31,790 --> 00:09:36,769
some sort of other reference to this

00:09:33,740 --> 00:09:39,740
void pointer elsewhere in your API most

00:09:36,769 --> 00:09:42,320
access programmers will use the linked

00:09:39,740 --> 00:09:46,100
list of magic and a free destructor

00:09:42,320 --> 00:09:48,980
inside the inside your magic bean table

00:09:46,100 --> 00:09:51,200
in order to free the void pointer or

00:09:48,980 --> 00:09:54,440
which would probably be a C++ object

00:09:51,200 --> 00:09:57,070
pointer that's bound to your exercise to

00:09:54,440 --> 00:09:57,070
your XS

00:10:05,810 --> 00:10:11,400
the pearl SEC has a couple design

00:10:08,930 --> 00:10:14,010
requirements to implement it's the way

00:10:11,400 --> 00:10:17,400
it is implemented in sea pearl has no

00:10:14,010 --> 00:10:19,980
strict prototyping so every single

00:10:17,400 --> 00:10:22,650
subroutine on a sea level is of our art

00:10:19,980 --> 00:10:25,620
and can take 0 to infinity arguments

00:10:22,650 --> 00:10:28,410
incoming and it can also return 0 to

00:10:25,620 --> 00:10:31,260
infinity arguments return the water a

00:10:28,410 --> 00:10:34,170
information impure pearl is passed

00:10:31,260 --> 00:10:37,080
around on a sea level but it's widely

00:10:34,170 --> 00:10:39,380
read by most X ups and most pure Pro

00:10:37,080 --> 00:10:43,200
code to never use moderation

00:10:39,380 --> 00:10:45,780
also the pearl stack must implement call

00:10:43,200 --> 00:10:47,970
frames and nesting because you know this

00:10:45,780 --> 00:10:50,670
is basis this is fairly not basic and we

00:10:47,970 --> 00:10:55,470
don't use go to score switch function

00:10:50,670 --> 00:10:57,660
called add underscore also has to be

00:10:55,470 --> 00:11:00,330
switched around at underscore in pure

00:10:57,660 --> 00:11:04,020
pearl is actually a view or a window

00:11:00,330 --> 00:11:06,000
into a much larger array and a local is

00:11:04,020 --> 00:11:09,300
done behind the scenes when you do a

00:11:06,000 --> 00:11:12,090
subroutine call and pearl to move the

00:11:09,300 --> 00:11:15,270
window of where ad underscore is viewing

00:11:12,090 --> 00:11:18,120
into the pearl that in some rare cases

00:11:15,270 --> 00:11:19,680
at underscore may also be completely

00:11:18,120 --> 00:11:22,500
detached from the pearl stack

00:11:19,680 --> 00:11:26,070
temporarily and then reattach to the

00:11:22,500 --> 00:11:28,860
pearl set this is for like some very

00:11:26,070 --> 00:11:30,690
rare cases of pure pearl code at

00:11:28,860 --> 00:11:34,320
underscore will be attached from the

00:11:30,690 --> 00:11:36,840
pearl effect also the pearl fact has to

00:11:34,320 --> 00:11:39,810
be reallocated at any time because it

00:11:36,840 --> 00:11:42,030
can grow and Rehab it can be reallocated

00:11:39,810 --> 00:11:45,600
and that means you can't keep that many

00:11:42,030 --> 00:11:47,250
pointers direct pointers into it in your

00:11:45,600 --> 00:11:48,660
data structures and memory structures

00:11:47,250 --> 00:11:50,530
because they may get swapped out from

00:11:48,660 --> 00:11:54,050
underneath

00:11:50,530 --> 00:11:57,590
also at underscore can grow very very

00:11:54,050 --> 00:12:00,110
big up to 128 terabytes on Linux if you

00:11:57,590 --> 00:12:06,350
want there probably nobody wants a very

00:12:00,110 --> 00:12:08,900
big at underscore on the Perl stack all

00:12:06,350 --> 00:12:10,910
of your incoming arguments also become

00:12:08,900 --> 00:12:13,880
your outgoing arguments to your caller

00:12:10,910 --> 00:12:16,700
you cannot store random pieces of data

00:12:13,880 --> 00:12:18,530
on the Perl stack everything can it has

00:12:16,700 --> 00:12:21,820
to either be a null pointer or a

00:12:18,530 --> 00:12:24,710
reference counted curl data structure

00:12:21,820 --> 00:12:27,470
you can't store a random data on there

00:12:24,710 --> 00:12:29,300
also context again is an artificial

00:12:27,470 --> 00:12:31,220
concept on the pearls that instantly the

00:12:29,300 --> 00:12:35,330
number of arguments coming in or coming

00:12:31,220 --> 00:12:37,460
out of that subroutine and the water

00:12:35,330 --> 00:12:40,430
information is available throughout the

00:12:37,460 --> 00:12:45,170
function calls it affects the stack and

00:12:40,430 --> 00:12:48,830
some other how the perl stack is

00:12:45,170 --> 00:12:50,810
designed the perl stack is stored in a

00:12:48,830 --> 00:12:52,940
perl global variable the start of it is

00:12:50,810 --> 00:12:57,290
stored in a global variable called PL

00:12:52,940 --> 00:13:02,240
mark stack sorry it's stored in PL stack

00:12:57,290 --> 00:13:04,940
base and when you Oh X subs and all pure

00:13:02,240 --> 00:13:07,880
Pro subs heavily interact with the curls

00:13:04,940 --> 00:13:09,500
back and the mark status in order to

00:13:07,880 --> 00:13:11,630
know where their section of the perl

00:13:09,500 --> 00:13:14,120
stack starts and where their incoming

00:13:11,630 --> 00:13:19,310
arguments are under outgoing arguments

00:13:14,120 --> 00:13:21,170
are in order to know where your section

00:13:19,310 --> 00:13:24,170
of the perl stack starts not your

00:13:21,170 --> 00:13:26,510
callers section which is private but

00:13:24,170 --> 00:13:30,590
your section you have to look on the

00:13:26,510 --> 00:13:33,320
marks back under mark stack PTR and in

00:13:30,590 --> 00:13:36,350
this diagram the red fields are memories

00:13:33,320 --> 00:13:38,810
had touched invalid for you the yellow

00:13:36,350 --> 00:13:42,560
fields are shared between you and either

00:13:38,810 --> 00:13:45,200
your caller or your colleague and the

00:13:42,560 --> 00:13:48,140
green fields are technically private to

00:13:45,200 --> 00:13:51,500
you but you have to read the mark stack

00:13:48,140 --> 00:13:54,230
PTR and get the I 32 which is an index

00:13:51,500 --> 00:13:58,490
into the perl stack off of the mark

00:13:54,230 --> 00:14:00,440
stack you then combine you add the index

00:13:58,490 --> 00:14:01,889
to PL stack based doing pointer

00:14:00,440 --> 00:14:04,369
arithmetic

00:14:01,889 --> 00:14:07,109
compute an absolute pointer into the

00:14:04,369 --> 00:14:10,589
pearl stack this is now called the mark

00:14:07,109 --> 00:14:14,249
pointer and the mark pointer is referred

00:14:10,589 --> 00:14:16,559
in a lot of X sub P P generated code but

00:14:14,249 --> 00:14:24,929
the memory that is underneath the mark

00:14:16,559 --> 00:14:27,089
pointer is never your memory question in

00:14:24,929 --> 00:14:29,999
technique the memory slots along is a

00:14:27,089 --> 00:14:34,230
collar but it's uninitialized for your

00:14:29,999 --> 00:14:37,859
purpose as a subroutine finally we have

00:14:34,230 --> 00:14:42,329
PL stack SP which is an absolute address

00:14:37,859 --> 00:14:44,699
into the Perl stack and if pearl facas P

00:14:42,329 --> 00:14:47,009
is equal to the mark pointer you can see

00:14:44,699 --> 00:14:49,290
0 incoming elements and therefore

00:14:47,009 --> 00:14:53,369
there's nothing to read underneath PL

00:14:49,290 --> 00:14:55,709
stack SP if PL stack SP is ahead of the

00:14:53,369 --> 00:15:02,220
mark pointer then you got incoming

00:14:55,709 --> 00:15:04,619
elements theoretically and X up could be

00:15:02,220 --> 00:15:08,369
also allocate some more pearl stacks a

00:15:04,619 --> 00:15:11,100
green zone and have a private a pile of

00:15:08,369 --> 00:15:13,110
scalars and three pointers that they're

00:15:11,100 --> 00:15:15,600
completely invisible to the caller and

00:15:13,110 --> 00:15:18,480
callee but everyone just uses see autos

00:15:15,600 --> 00:15:21,089
and regular t bars to store every

00:15:18,480 --> 00:15:25,019
pointers in access code is really no

00:15:21,089 --> 00:15:27,869
point of using the pro fact the store

00:15:25,019 --> 00:15:30,949
scalar local and then finally on the

00:15:27,869 --> 00:15:33,569
right side the second block of yellow

00:15:30,949 --> 00:15:35,790
entries on the Pearl stack it would be

00:15:33,569 --> 00:15:38,549
your outgoing argument if your

00:15:35,790 --> 00:15:40,290
colleagues if an X sub is calling back

00:15:38,549 --> 00:15:43,249
into the Pearl engine or is calling

00:15:40,290 --> 00:15:43,249
another pro supper

00:15:48,170 --> 00:15:54,120
you also have to remember whenever you

00:15:51,300 --> 00:15:55,860
read or write to the pro stack yes to

00:15:54,120 --> 00:15:57,240
bounce checks so you don't run off the

00:15:55,860 --> 00:16:00,180
end of it or you're not reading

00:15:57,240 --> 00:16:03,450
uninitialized bases like on the purl

00:16:00,180 --> 00:16:06,060
stack because if you go some cases if

00:16:03,450 --> 00:16:06,930
you if you take a CD bugger and you

00:16:06,060 --> 00:16:08,670
sometimes dump

00:16:06,930 --> 00:16:10,080
even the piece of pearl stacks before

00:16:08,670 --> 00:16:12,270
you you may find completely

00:16:10,080 --> 00:16:14,400
uninitialized pointers in there there's

00:16:12,270 --> 00:16:16,740
no guarantee the red zones people ever

00:16:14,400 --> 00:16:19,110
even have valid data even if there's no

00:16:16,740 --> 00:16:21,240
required your collar is supposed to keep

00:16:19,110 --> 00:16:22,350
valid FC pointers on the pro stack but

00:16:21,240 --> 00:16:24,090
sometimes I've noticed the Perl

00:16:22,350 --> 00:16:26,370
interpreter just puts garbage on there

00:16:24,090 --> 00:16:30,050
or it just allocates up a chunk of

00:16:26,370 --> 00:16:33,600
probes that can never fill then anything

00:16:30,050 --> 00:16:36,870
the smallest X sub two can possibly

00:16:33,600 --> 00:16:39,360
write in green C is the ball every X sub

00:16:36,870 --> 00:16:42,540
has only one API contracts obligation

00:16:39,360 --> 00:16:45,780
which is increase the mark stack pointer

00:16:42,540 --> 00:16:48,630
to wipe that index a slot that it

00:16:45,780 --> 00:16:50,730
received in this is the most possible X

00:16:48,630 --> 00:16:53,640
sub you can write in plain C without

00:16:50,730 --> 00:16:55,860
crashing the Perl interpreter all it

00:16:53,640 --> 00:16:57,780
does is return at underscore to the

00:16:55,860 --> 00:16:59,610
college because the incoming arguments

00:16:57,780 --> 00:17:06,180
also become your outgoing arguments if

00:16:59,610 --> 00:17:08,430
you don't um how to now let's do

00:17:06,180 --> 00:17:10,800
something a little more complicated of

00:17:08,430 --> 00:17:13,350
an active website a more complicated X

00:17:10,800 --> 00:17:17,310
up in plain or counting the number of

00:17:13,350 --> 00:17:19,199
items in add underscores every single X

00:17:17,310 --> 00:17:21,900
sub is going to generally have the

00:17:19,199 --> 00:17:25,920
following for a couple of Prolog as a

00:17:21,900 --> 00:17:28,890
start we first read PL Zacks SP or the

00:17:25,920 --> 00:17:32,430
global stack pointer into a seat Auto we

00:17:28,890 --> 00:17:34,890
then have to read our I 32 index into

00:17:32,430 --> 00:17:37,680
the mark set into the Perl stack read

00:17:34,890 --> 00:17:40,560
our index off the mark stack we then

00:17:37,680 --> 00:17:43,110
compute the mark pointer by adding the

00:17:40,560 --> 00:17:47,670
index to the start of the Perl stack and

00:17:43,110 --> 00:17:50,610
then by subtracting our local F stack

00:17:47,670 --> 00:17:52,050
pointer from mark pointer we and this is

00:17:50,610 --> 00:17:53,490
again pointer arithmetic so it's

00:17:52,050 --> 00:17:55,470
actually a divided by four divided by

00:17:53,490 --> 00:17:55,929
eight using pointer arithmetic by the

00:17:55,470 --> 00:17:59,289
sea

00:17:55,929 --> 00:18:01,869
standard we can compute the number of

00:17:59,289 --> 00:18:04,840
items re received and then we have our

00:18:01,869 --> 00:18:09,090
API contract obligation of removing one

00:18:04,840 --> 00:18:09,090
flawed off the mark off the mark stack

00:18:12,389 --> 00:18:17,889
now we have to create to return the

00:18:15,369 --> 00:18:20,139
number of AD underscore to return

00:18:17,889 --> 00:18:24,730
account back to our caller we have to

00:18:20,139 --> 00:18:27,340
create a new pearl scalar down here now

00:18:24,730 --> 00:18:29,889
if you the pearl stack does not own any

00:18:27,340 --> 00:18:31,929
reference counted scalars on it or

00:18:29,889 --> 00:18:34,629
hashes or arrays nothing on the Perl

00:18:31,929 --> 00:18:36,639
stack is owned by the Perl sec some

00:18:34,629 --> 00:18:39,549
other data structure in your process

00:18:36,639 --> 00:18:42,789
must have ownership of every pointer on

00:18:39,549 --> 00:18:45,759
the pearls back if you don't know what

00:18:42,789 --> 00:18:47,830
is to post it own a scalar that's on the

00:18:45,759 --> 00:18:50,230
Perl stack you can put it on the mortal

00:18:47,830 --> 00:18:52,299
stack which is a temporary stack that

00:18:50,230 --> 00:18:54,639
own various scalars and they're

00:18:52,299 --> 00:18:58,539
generally freed at the next semicolon or

00:18:54,639 --> 00:19:00,399
closing curly we then after we've

00:18:58,539 --> 00:19:02,379
created our new scalar they were going

00:19:00,399 --> 00:19:03,999
to return to our caller and we make sure

00:19:02,379 --> 00:19:07,230
we don't think it because it's mortal

00:19:03,999 --> 00:19:11,049
mortal eyes so we then set it to the

00:19:07,230 --> 00:19:13,690
item count that we computed earlier now

00:19:11,049 --> 00:19:16,450
we have to because we kind of gotten 0

00:19:13,690 --> 00:19:19,990
to infinity items we have to wipe all of

00:19:16,450 --> 00:19:22,690
our incoming arguments by assigning mark

00:19:19,990 --> 00:19:25,059
to SP so when mark is equal to SP

00:19:22,690 --> 00:19:28,509
there's 0 incoming arguments or outgoing

00:19:25,059 --> 00:19:30,669
arguments we then have to balance check

00:19:28,509 --> 00:19:32,259
the pearl stack because if we were

00:19:30,669 --> 00:19:34,480
called with zero arguments we can

00:19:32,259 --> 00:19:35,950
overflow by returning one argument when

00:19:34,480 --> 00:19:39,820
we really have nothing on the Pearl

00:19:35,950 --> 00:19:41,289
Factory empty and we were at the end of

00:19:39,820 --> 00:19:43,360
the memory allocation limit so we

00:19:41,289 --> 00:19:45,399
bounced check the size of the Pearl

00:19:43,360 --> 00:19:46,450
stack and we reallocate the pearl stag

00:19:45,399 --> 00:19:49,450
if it's too small

00:19:46,450 --> 00:19:51,340
we then advance the stack pointer by one

00:19:49,450 --> 00:19:53,259
because remember if mark is equal to SP

00:19:51,340 --> 00:19:55,059
is an invalid memory address as their

00:19:53,259 --> 00:19:57,999
colors address that's not our memory

00:19:55,059 --> 00:20:00,460
slot so advanced SP by one we write the

00:19:57,999 --> 00:20:03,730
new SP pointer to the Pearl stack and

00:20:00,460 --> 00:20:06,070
then we update the global copy of the

00:20:03,730 --> 00:20:06,720
stack pointer store caller knows how

00:20:06,070 --> 00:20:09,240
many argue

00:20:06,720 --> 00:20:16,289
since we returned and then we return

00:20:09,240 --> 00:20:16,919
back to the purlins how to print a

00:20:16,289 --> 00:20:19,230
scaler

00:20:16,919 --> 00:20:21,870
again we have the exact same curl log

00:20:19,230 --> 00:20:24,240
you saw earlier this is the reason you

00:20:21,870 --> 00:20:25,799
use X sub P P and you use all the macros

00:20:24,240 --> 00:20:28,350
is because nobody wants to write five

00:20:25,799 --> 00:20:33,480
statements every single time for every

00:20:28,350 --> 00:20:36,059
single X oh um again we have to back up

00:20:33,480 --> 00:20:38,640
our mark stack delete one slice this

00:20:36,059 --> 00:20:40,559
time we check the item count if we don't

00:20:38,640 --> 00:20:42,960
have the right number of items that we

00:20:40,559 --> 00:20:45,330
have to dot fatally die again you never

00:20:42,960 --> 00:20:47,820
know in the next sub how many incoming

00:20:45,330 --> 00:20:50,400
arguments dot there's no enforcement

00:20:47,820 --> 00:20:53,450
everything as far as so you always have

00:20:50,400 --> 00:20:56,640
to check how many becoming arguments yet

00:20:53,450 --> 00:20:59,610
because we know we got one item we can

00:20:56,640 --> 00:21:02,039
basically read FP and just absolutely

00:20:59,610 --> 00:21:07,320
dereference it and reads a scalar

00:21:02,039 --> 00:21:09,690
pointer off the pearls back then we have

00:21:07,320 --> 00:21:12,419
to check if our scalar internally is a

00:21:09,690 --> 00:21:14,370
string or not if it's a string we can

00:21:12,419 --> 00:21:17,190
directly read it otherwise we have to

00:21:14,370 --> 00:21:20,010
call a casting function which is f V - P

00:21:17,190 --> 00:21:23,070
V Flags again this is a macro in

00:21:20,010 --> 00:21:26,850
official API but here I expanded it so

00:21:23,070 --> 00:21:29,760
you kind of understand internals of the

00:21:26,850 --> 00:21:31,740
macro and finally we call printf to

00:21:29,760 --> 00:21:34,799
print the char pointer that we pulled

00:21:31,740 --> 00:21:36,990
out a scalar now because earlier we

00:21:34,799 --> 00:21:40,260
checked the items count we can safely

00:21:36,990 --> 00:21:43,380
lower the stack pointer by one slot and

00:21:40,260 --> 00:21:47,669
then we copy the local stack pointer

00:21:43,380 --> 00:21:51,950
back to the global so that we we are

00:21:47,669 --> 00:21:55,080
returning an empty list to our caller

00:21:51,950 --> 00:21:56,700
well the reason I can safely back up SP

00:21:55,080 --> 00:21:59,100
is again we check the items account

00:21:56,700 --> 00:22:02,340
earlier so you don't need to check twice

00:21:59,100 --> 00:22:03,750
where SP is you just can absolutely do a

00:22:02,340 --> 00:22:07,070
minus 1 and you know it's going to work

00:22:03,750 --> 00:22:07,070
because we checked earlier that we have

00:22:07,809 --> 00:22:14,140
summing a list in a loop should be

00:22:10,720 --> 00:22:17,440
iterating over an incoming list in our X

00:22:14,140 --> 00:22:21,700
sub again we have to have this prologue

00:22:17,440 --> 00:22:24,039
at start and but this time we back up a

00:22:21,700 --> 00:22:26,610
stack pointer by the number of items

00:22:24,039 --> 00:22:31,029
again this point arithmetic items is in

00:22:26,610 --> 00:22:32,529
erase lot while SP is a absolute pointer

00:22:31,029 --> 00:22:35,919
but due to the magic of point arithmetic

00:22:32,529 --> 00:22:42,070
and see there's automatic like divide by

00:22:35,919 --> 00:22:48,190
4 or times 4 or divided by 8 40 we loop

00:22:42,070 --> 00:22:51,580
over the incoming list and but there's a

00:22:48,190 --> 00:22:53,799
you'll notice that SP doesn't +1 going

00:22:51,580 --> 00:22:56,620
on and that's because when we backed up

00:22:53,799 --> 00:22:59,110
the SP by the number of items SP

00:22:56,620 --> 00:23:01,090
actually is equal to mark and Mark is an

00:22:59,110 --> 00:23:03,309
invalid memory address so when we be

00:23:01,090 --> 00:23:07,270
reference the stack pointer we're always

00:23:03,309 --> 00:23:10,570
doing plus 1 because of the way the mark

00:23:07,270 --> 00:23:12,460
stack the mark pointer never is a valid

00:23:10,570 --> 00:23:15,940
memory address so 0 is always basically

00:23:12,460 --> 00:23:18,669
invalid and we just do a plus 1 to

00:23:15,940 --> 00:23:20,380
recall now remember for the summing the

00:23:18,669 --> 00:23:22,630
list we could have gotten again 0

00:23:20,380 --> 00:23:25,840
incoming arguments so this board was may

00:23:22,630 --> 00:23:29,110
never even run similar to the chart of

00:23:25,840 --> 00:23:31,240
the string example earlier you similar

00:23:29,110 --> 00:23:33,429
to the string example earlier we have to

00:23:31,240 --> 00:23:35,950
check the flags for each scalar if it's

00:23:33,429 --> 00:23:38,710
a double we can directly read the double

00:23:35,950 --> 00:23:42,070
value out of the scalar otherwise we

00:23:38,710 --> 00:23:45,669
have to call the casting function again

00:23:42,070 --> 00:23:48,370
and because we could have gotten again

00:23:45,669 --> 00:23:50,710
an empty incoming list we have to grow

00:23:48,370 --> 00:23:52,419
the pearls back to bounce check the

00:23:50,710 --> 00:23:55,510
Pearl stack to make sure we can return

00:23:52,419 --> 00:23:57,669
one element we then create a new Pearl

00:23:55,510 --> 00:24:00,039
scalar in this case instead of calling

00:23:57,669 --> 00:24:02,500
us we new mortal eye

00:24:00,039 --> 00:24:07,179
mortal eyes or add the mortal flag and

00:24:02,500 --> 00:24:09,970
the background the Pearl background

00:24:07,179 --> 00:24:12,070
checking whatever by calling SV to

00:24:09,970 --> 00:24:14,799
immortal which takes an existing scalar

00:24:12,070 --> 00:24:17,950
pointer and then marks it for proper

00:24:14,799 --> 00:24:23,470
destruction based on the behavior cement

00:24:17,950 --> 00:24:31,020
the mortal stack we then is this sound

00:24:23,470 --> 00:24:33,820
actually okay we then assign the scalar

00:24:31,020 --> 00:24:35,890
sv pointer to the pearl stack and we

00:24:33,820 --> 00:24:38,170
copy our local pearl stack back to the

00:24:35,890 --> 00:24:42,570
global pearl stack and then we return

00:24:38,170 --> 00:24:42,570
back control back to the pearl engine

00:24:42,750 --> 00:24:48,880
earlier I conceptually showed a bhoot X

00:24:45,820 --> 00:24:50,950
sub with the yellow and blue diagram but

00:24:48,880 --> 00:24:54,070
this is how an X sub is actually written

00:24:50,950 --> 00:24:57,070
in plane see that we have the small

00:24:54,070 --> 00:24:59,290
prototype sorry the small Prolog at the

00:24:57,070 --> 00:25:01,540
start we have to back up the mark stack

00:24:59,290 --> 00:25:04,060
again which is our contra API contract

00:25:01,540 --> 00:25:07,150
obligation by assigning mark to the

00:25:04,060 --> 00:25:09,000
global SP we wipe all incoming arguments

00:25:07,150 --> 00:25:12,280
returning an empty list to our caller

00:25:09,000 --> 00:25:14,440
just as in the diagram earlier new XS is

00:25:12,280 --> 00:25:17,080
just called repeatedly with a string

00:25:14,440 --> 00:25:19,690
name of the subroutine we want to

00:25:17,080 --> 00:25:21,730
register and it's pointer as the second

00:25:19,690 --> 00:25:23,500
argument and the third argument is the

00:25:21,730 --> 00:25:26,890
source code file name for things like

00:25:23,500 --> 00:25:28,870
warnings although the warning system is

00:25:26,890 --> 00:25:32,440
not actually smart enough to return dot

00:25:28,870 --> 00:25:34,660
seeds for most warnings it'll just

00:25:32,440 --> 00:25:38,110
return the last pair Perl line you ran

00:25:34,660 --> 00:25:43,210
which is a for performance reasons p5p

00:25:38,110 --> 00:25:46,270
has never wanted to try to have warnings

00:25:43,210 --> 00:25:49,560
return errors from dot c files and line

00:25:46,270 --> 00:25:52,120
numbers inside c files instead it just

00:25:49,560 --> 00:25:55,660
accidentally does the record tells you

00:25:52,120 --> 00:25:57,070
the last pure proline Ram it's sometimes

00:25:55,660 --> 00:25:59,560
confusing for debugging because you

00:25:57,070 --> 00:26:01,330
think you're the fault is on a pair /

00:25:59,560 --> 00:26:03,220
alignments actually inside an X abut

00:26:01,330 --> 00:26:05,530
without a Seabee bugger you can't tell

00:26:03,220 --> 00:26:08,170
whether it's from an X sub or from a

00:26:05,530 --> 00:26:16,200
peer pearl subroutine for the warning or

00:26:08,170 --> 00:26:16,200
the fatal die message how are we on time

00:26:21,690 --> 00:26:31,070
oh great we have time now for some

00:26:27,630 --> 00:26:35,220
really crazy stuff

00:26:31,070 --> 00:26:38,760
y'all get ill get crazier this is a pure

00:26:35,220 --> 00:26:41,490
Perl version of the following plane C

00:26:38,760 --> 00:26:45,150
access code I'll explain later on for

00:26:41,490 --> 00:26:47,340
how an X sub can call an X sub without

00:26:45,150 --> 00:26:49,860
ever going through the Perl engine so

00:26:47,340 --> 00:26:52,890
it's a C font it's a C X sub calling a

00:26:49,860 --> 00:26:57,900
CX sub without any help from Perl and no

00:26:52,890 --> 00:27:00,450
Perl machine code is involved here we

00:26:57,900 --> 00:27:02,640
have a typical Prolog every single X sub

00:27:00,450 --> 00:27:10,890
has this Prolog and we back up mark

00:27:02,640 --> 00:27:13,470
stack in order to call a child X sub we

00:27:10,890 --> 00:27:17,060
have to create our own mac mark stack

00:27:13,470 --> 00:27:21,030
entry so we have to bounce check and

00:27:17,060 --> 00:27:24,210
advance the mark stack pointer then we

00:27:21,030 --> 00:27:27,510
have to compute the start of the next

00:27:24,210 --> 00:27:32,370
are outgoing section of Perl stack and

00:27:27,510 --> 00:27:35,070
that's done by taking SP you create that

00:27:32,370 --> 00:27:38,070
index number again you then assign the

00:27:35,070 --> 00:27:40,770
index to the global put it on the global

00:27:38,070 --> 00:27:42,960
marks tack then we have to grow the Perl

00:27:40,770 --> 00:27:46,560
stack because we have to create outgoing

00:27:42,960 --> 00:27:48,900
elements the suburbs is this X sub

00:27:46,560 --> 00:27:51,030
simply copies the incoming arguments and

00:27:48,900 --> 00:27:55,680
repeatedly sends them to Colley's as

00:27:51,030 --> 00:27:58,770
outgoing arguments now remember that all

00:27:55,680 --> 00:28:01,710
outgoing arguments become your incoming

00:27:58,770 --> 00:28:04,290
arguments from your child calls so every

00:28:01,710 --> 00:28:06,960
time you send arguments out to a child

00:28:04,290 --> 00:28:08,580
call when you are when controllers

00:28:06,960 --> 00:28:11,880
return back to you your outgoing

00:28:08,580 --> 00:28:15,210
arguments were wiped so to push the same

00:28:11,880 --> 00:28:17,160
list or the to multiple child calls you

00:28:15,210 --> 00:28:20,100
have to keep putting it back on the Perl

00:28:17,160 --> 00:28:23,250
stack after every child call because the

00:28:20,100 --> 00:28:25,290
outgo the outgoing section of Perl stack

00:28:23,250 --> 00:28:27,510
is basically either onion is either

00:28:25,290 --> 00:28:30,870
uninitialized memory or the returned

00:28:27,510 --> 00:28:33,870
list from your child call so we do a mem

00:28:30,870 --> 00:28:35,130
copy taking our incoming seg section of

00:28:33,870 --> 00:28:37,860
Perl stack

00:28:35,130 --> 00:28:42,990
and we copy it to our outgoing section

00:28:37,860 --> 00:28:46,920
of of pearl stack we then advance the

00:28:42,990 --> 00:28:49,020
pearl stack pointer ahead of the start

00:28:46,920 --> 00:28:54,300
of the outgoing section of pearl stacks

00:28:49,020 --> 00:28:56,070
now in order to call a X sub we have to

00:28:54,300 --> 00:29:00,540
get the CV pointer that's associated

00:28:56,070 --> 00:29:03,450
with that C symbol so we call Pearl get

00:29:00,540 --> 00:29:06,660
CBN which does the lookup in the symbol

00:29:03,450 --> 00:29:09,990
table AAB symbol - tree of Pearl and

00:29:06,660 --> 00:29:14,520
gets the CV pointer associated with that

00:29:09,990 --> 00:29:18,570
see X sub function we then can directly

00:29:14,520 --> 00:29:22,070
call that X sub although this is a plain

00:29:18,570 --> 00:29:24,600
C - C call even though the CD pointer is

00:29:22,070 --> 00:29:26,910
required as a second argument in the my

00:29:24,600 --> 00:29:28,680
count argue in the my count art which is

00:29:26,910 --> 00:29:32,190
a C function it's in the same shared

00:29:28,680 --> 00:29:34,950
library but yeah we have to get that C V

00:29:32,190 --> 00:29:36,660
pointer a lot of X a lot of X subs never

00:29:34,950 --> 00:29:39,060
look at the second argument but don't

00:29:36,660 --> 00:29:40,770
assume that the second argument won't be

00:29:39,060 --> 00:29:45,110
dereference for let's say that any

00:29:40,770 --> 00:29:47,460
example or for iterating rules of

00:29:45,110 --> 00:29:49,620
usually the any example is going to

00:29:47,460 --> 00:29:51,630
crash if you put C if you the second

00:29:49,620 --> 00:29:55,080
argument instead of being the proper C V

00:29:51,630 --> 00:29:56,670
pointer it's no any X sub that uses the

00:29:55,080 --> 00:29:59,160
any member is going to crash when it B

00:29:56,670 --> 00:30:00,990
references it's a CV pointer which would

00:29:59,160 --> 00:30:03,240
we know so that's a bit of a hack some

00:30:00,990 --> 00:30:06,380
Perl code passes no that's a bad thing

00:30:03,240 --> 00:30:11,130
to do please pass the real C V pointer

00:30:06,380 --> 00:30:13,860
after we call the child X sub we have to

00:30:11,130 --> 00:30:15,840
again fetch from global SPL status be

00:30:13,860 --> 00:30:21,110
the global stack pointer reassign it to

00:30:15,840 --> 00:30:24,450
our local SP and then based on the saved

00:30:21,110 --> 00:30:26,760
index earlier we can compute how many

00:30:24,450 --> 00:30:29,280
arguments we got if we also we didn't

00:30:26,760 --> 00:30:32,400
get one argument from counting the

00:30:29,280 --> 00:30:35,670
number from this list count X sub we got

00:30:32,400 --> 00:30:39,300
only if we didn't get one item in this

00:30:35,670 --> 00:30:42,840
context we fatally error we then can aft

00:30:39,300 --> 00:30:46,200
always check we got one one element

00:30:42,840 --> 00:30:48,730
return from our X sub we can read SP

00:30:46,200 --> 00:30:51,550
directly and get the count

00:30:48,730 --> 00:30:54,490
yes we which is at the bottom we can we

00:30:51,550 --> 00:30:57,690
then back up SP by one to wipe the one

00:30:54,490 --> 00:31:01,210
element that we got from our child color

00:30:57,690 --> 00:31:03,700
now we have to call again now because we

00:31:01,210 --> 00:31:06,790
are ready to put one to push the mark

00:31:03,700 --> 00:31:09,040
pointer on we can just again assign me

00:31:06,790 --> 00:31:10,630
put the index number back on marks back

00:31:09,040 --> 00:31:12,220
and we don't need to balance check the

00:31:10,630 --> 00:31:14,920
mark stack because the marks back and

00:31:12,220 --> 00:31:16,780
the pro stack will never shrink during a

00:31:14,920 --> 00:31:18,370
child call they can only get bigger or

00:31:16,780 --> 00:31:23,230
get reallocated they'll never shrink

00:31:18,370 --> 00:31:25,780
backwards we have to again recompute the

00:31:23,230 --> 00:31:28,030
mark pointer because we don't know if

00:31:25,780 --> 00:31:30,850
our child call reallocated the curls

00:31:28,030 --> 00:31:32,890
back we then again copy our incoming

00:31:30,850 --> 00:31:35,020
section of Pearl stack the outgoing

00:31:32,890 --> 00:31:37,270
section of pro stack with a mem copy

00:31:35,020 --> 00:31:39,610
because every single child call wipes

00:31:37,270 --> 00:31:41,950
all the arguments that you send it

00:31:39,610 --> 00:31:43,690
because the same exact zone that is used

00:31:41,950 --> 00:31:46,180
for outgoing argument disease for

00:31:43,690 --> 00:31:49,510
incoming arguments or returned arguments

00:31:46,180 --> 00:31:54,850
again we have to get the CV pointer and

00:31:49,510 --> 00:31:58,510
we directly call a DX up with the it's

00:31:54,850 --> 00:32:00,670
CV pointer we again have to fetch PL

00:31:58,510 --> 00:32:03,400
stack as we have to again read the

00:32:00,670 --> 00:32:07,150
global stack pointer recompute how many

00:32:03,400 --> 00:32:10,150
items we got if the sum if we didn't get

00:32:07,150 --> 00:32:14,110
one item we can never trust any X up or

00:32:10,150 --> 00:32:15,970
any subroutine to return a certain

00:32:14,110 --> 00:32:19,420
number of items in Perl you just get on

00:32:15,970 --> 00:32:21,910
depth but in C you will crash in excess

00:32:19,420 --> 00:32:25,390
if you try to be reference and there was

00:32:21,910 --> 00:32:28,390
warned enough elements returns again we

00:32:25,390 --> 00:32:30,400
read SP pointer directly reading getting

00:32:28,390 --> 00:32:32,890
the ESPY pointer off the pro stack and

00:32:30,400 --> 00:32:37,930
then we back up the SP pointer by one

00:32:32,890 --> 00:32:40,510
wiping one hard finally once we have

00:32:37,930 --> 00:32:44,400
gotten our 2f feeds from our - child

00:32:40,510 --> 00:32:47,650
called we can create a third scalar of

00:32:44,400 --> 00:32:49,360
the count and the sum of our incoming

00:32:47,650 --> 00:32:51,850
list that we were passing to our child

00:32:49,360 --> 00:32:54,880
calls we immortalize it again to make

00:32:51,850 --> 00:32:57,190
sure we're not leaking a scalar and

00:32:54,880 --> 00:32:59,190
finally to print the scalar we just

00:32:57,190 --> 00:33:01,350
created we have to again

00:32:59,190 --> 00:33:04,590
but the index on the mark stack advance

00:33:01,350 --> 00:33:09,180
the mark stack advance the stack point

00:33:04,590 --> 00:33:11,940
events the stack pointer to three at one

00:33:09,180 --> 00:33:14,250
outgoing element we write our new scalar

00:33:11,940 --> 00:33:15,990
FV pointer to the probe stack and then

00:33:14,250 --> 00:33:18,450
we put the local probe deck on the

00:33:15,990 --> 00:33:21,920
global curl stack again we get the CB

00:33:18,450 --> 00:33:25,110
pointer and directly call the X sub of

00:33:21,920 --> 00:33:27,360
directly through the c2c without going

00:33:25,110 --> 00:33:31,470
to curl or the call s we call in the

00:33:27,360 --> 00:33:35,400
Perl API again we have to recompute mark

00:33:31,470 --> 00:33:39,020
because pls back pay the most if you try

00:33:35,400 --> 00:33:42,360
to use SP or mark after any other

00:33:39,020 --> 00:33:45,180
subroutine calls you will crash and it's

00:33:42,360 --> 00:33:48,030
a common problem on p5c and with deep

00:33:45,180 --> 00:33:50,250
encode of where you use failed as local

00:33:48,030 --> 00:33:53,640
SPS and scale local mark pointers and

00:33:50,250 --> 00:33:55,530
after doing a call to a child subroutine

00:33:53,640 --> 00:33:57,240
we never refresh those pointers from

00:33:55,530 --> 00:33:59,400
global storage or from the global

00:33:57,240 --> 00:34:02,430
interpreter variables and then we use

00:33:59,400 --> 00:34:05,910
after free air and it or use after real

00:34:02,430 --> 00:34:08,400
realloc air and you prompt fresh in

00:34:05,910 --> 00:34:11,300
order to return an empty list again we

00:34:08,400 --> 00:34:14,190
assign march to the global FP we return

00:34:11,300 --> 00:34:25,520
and we've returned an empty list to our

00:34:14,190 --> 00:34:25,520
callers questions go ahead

00:34:29,909 --> 00:34:34,169
if you actually do this in production

00:34:32,339 --> 00:34:37,760
writing all this code by hand you should

00:34:34,169 --> 00:34:37,760
be fired for wasting your boss's money

00:34:38,089 --> 00:34:46,770
is it significantly faster to write

00:34:43,290 --> 00:34:49,379
excess code in plain Seavers using X sub

00:34:46,770 --> 00:34:52,560
P P and the template system and the

00:34:49,379 --> 00:34:56,129
answer is clearly no use X sub P P and

00:34:52,560 --> 00:34:58,380
swig and whatever other tools you want

00:34:56,129 --> 00:35:01,140
this is like the worst possible way to

00:34:58,380 --> 00:35:03,450
write it's the worst possible way to

00:35:01,140 --> 00:35:05,280
write an excess extension short of

00:35:03,450 --> 00:35:13,200
flicking light switches on your pdp-11

00:35:05,280 --> 00:35:17,670
and machine code what's your budget for

00:35:13,200 --> 00:35:21,470
your software project any other

00:35:17,670 --> 00:35:21,470
questions go ahead

00:35:35,150 --> 00:35:41,059
call sv is capable of running off three

00:35:38,150 --> 00:35:43,190
pure Perl code if you call and X sub

00:35:41,059 --> 00:35:44,869
directly from an X sub it's a C to C

00:35:43,190 --> 00:35:47,359
function call and it's absolutely

00:35:44,869 --> 00:35:50,300
impossible to run a peer Perl subroutine

00:35:47,359 --> 00:35:52,099
or monkey Patchett by doing an eval and

00:35:50,300 --> 00:35:54,380
just swapping out the subroutine at

00:35:52,099 --> 00:35:56,180
runtime you can't do that if you if it's

00:35:54,380 --> 00:35:58,849
permanently wired function pointer to

00:35:56,180 --> 00:36:01,700
function pointer so call this V will

00:35:58,849 --> 00:36:05,119
either call the another X sub or it will

00:36:01,700 --> 00:36:07,640
call the keyword Optra it will an

00:36:05,119 --> 00:36:12,309
Austria brute een annual again look

00:36:07,640 --> 00:36:12,309
through the pearl stash glob tree

00:36:32,790 --> 00:36:41,170
the question is can you look in the CV

00:36:35,970 --> 00:36:42,910
directly and extract the X sub C

00:36:41,170 --> 00:36:46,420
function pointer and call that directly

00:36:42,910 --> 00:36:49,870
the answer is yes there is a set of Perl

00:36:46,420 --> 00:36:52,810
macros called multi call which is faster

00:36:49,870 --> 00:36:55,900
than using call SV and it attempts to

00:36:52,810 --> 00:36:57,910
look at the flags of CV and determine if

00:36:55,900 --> 00:37:00,610
it's true if it's X sub based or whether

00:36:57,910 --> 00:37:04,030
it's pure Perl based and it offers less

00:37:00,610 --> 00:37:06,760
overhead than call SV it's called multi

00:37:04,030 --> 00:37:11,590
call and it's a complex set of header

00:37:06,760 --> 00:37:14,170
files and more macro soup but it creates

00:37:11,590 --> 00:37:16,360
a call frame directly and C without

00:37:14,170 --> 00:37:20,470
using C function pointers in the Perl

00:37:16,360 --> 00:37:20,860
engine if it is off tree based or pure

00:37:20,470 --> 00:37:22,870
Perl

00:37:20,860 --> 00:37:25,000
you clearly have to call back into the

00:37:22,870 --> 00:37:27,330
pro engine but it's called multi call if

00:37:25,000 --> 00:37:32,770
you want to Google it

00:37:27,330 --> 00:37:36,510
any other questions well thank you for

00:37:32,770 --> 00:37:36,510
me dividing by zero your brain

00:37:37,120 --> 00:37:43,179

YouTube URL: https://www.youtube.com/watch?v=EKqCAo0O63I


