Title: Joel Berger - "Variables, Scoping, and Namespaces"
Publication date: 2017-06-21
Playlist: TPC 2017 in DC
Description: 
	Searching for a deeper understanding of variables, scoping, lexicals, packages, and the "my", "our", and "local" keywords.
Captions: 
	00:00:00,000 --> 00:00:05,089
particularly like giving a talk sitting

00:00:02,129 --> 00:00:08,580
down so I'm going to see how this works

00:00:05,089 --> 00:00:10,170
my name is Joel Berger I'm very happy to

00:00:08,580 --> 00:00:13,200
see a bit of a crowd here I know I'm up

00:00:10,170 --> 00:00:14,610
against Damien but you know Damien doing

00:00:13,200 --> 00:00:16,500
them so many people aren't so interested

00:00:14,610 --> 00:00:19,560
in that and I see at least a few people

00:00:16,500 --> 00:00:22,590
here who I'm like like like Mickey it's

00:00:19,560 --> 00:00:28,769
it's these are variables like my first

00:00:22,590 --> 00:00:30,869
slide if like this is a variable okay

00:00:28,769 --> 00:00:32,070
well thank you for coming up maybe

00:00:30,869 --> 00:00:33,540
you'll get something out of it but this

00:00:32,070 --> 00:00:35,790
really is a beginner's talk so if you

00:00:33,540 --> 00:00:39,180
would rather go see Damien or

00:00:35,790 --> 00:00:42,540
there's a talk on PDL yeah I'm not

00:00:39,180 --> 00:00:46,350
trying to kick people out but this is a

00:00:42,540 --> 00:00:48,719
beginner's talk so you know you can have

00:00:46,350 --> 00:00:50,280
fun with it if you like to get started I

00:00:48,719 --> 00:00:53,820
want to thank of course my employer

00:00:50,280 --> 00:00:56,879
server central for sending me here we do

00:00:53,820 --> 00:00:57,960
hosting from clouds a bare-metal so if

00:00:56,879 --> 00:00:59,609
you're interested in that kind of stuff

00:00:57,960 --> 00:01:01,649
you can come talk to me later or go to

00:00:59,609 --> 00:01:05,640
our website sure we'd be happy to talk

00:01:01,649 --> 00:01:07,020
to you I always like to give a meta

00:01:05,640 --> 00:01:09,630
slide at the beginning of my talks

00:01:07,020 --> 00:01:11,549
because you know things on the internet

00:01:09,630 --> 00:01:14,939
lasts forever but the content might not

00:01:11,549 --> 00:01:17,759
always so I first gave this talk about

00:01:14,939 --> 00:01:20,640
was that six months ago and I've just

00:01:17,759 --> 00:01:22,920
updated it for this conference here

00:01:20,640 --> 00:01:26,759
you're welcome to follow along the talk

00:01:22,920 --> 00:01:28,409
is on my github at slash presentation

00:01:26,759 --> 00:01:29,759
namespaces in fact I'm actually running

00:01:28,409 --> 00:01:34,380
it off of this because it was just

00:01:29,759 --> 00:01:41,009
easier today the source is located also

00:01:34,380 --> 00:01:43,759
on my github disclaimer this talk does

00:01:41,009 --> 00:01:49,500
not always use strict and warnings Oh

00:01:43,759 --> 00:01:50,909
gasps ooh part of the reason is because

00:01:49,500 --> 00:01:55,920
I'll be teaching you a little bit why

00:01:50,909 --> 00:01:57,360
you want to use strict but we're to get

00:01:55,920 --> 00:01:59,340
there we have to start without them and

00:01:57,360 --> 00:02:01,350
so be a little careful with some of

00:01:59,340 --> 00:02:03,000
these early bits of code but I'll be

00:02:01,350 --> 00:02:08,009
happy to teach you why you want to do

00:02:03,000 --> 00:02:10,520
this and as I said before this is really

00:02:08,009 --> 00:02:13,140
intended for people who have used Perl

00:02:10,520 --> 00:02:13,860
maybe even not that much certainly not

00:02:13,140 --> 00:02:18,090
Doug 2d

00:02:13,860 --> 00:02:20,670
and you've written libraries maybe but

00:02:18,090 --> 00:02:22,860
mostly scripts you one-offs you know

00:02:20,670 --> 00:02:24,450
some DevOps and gotten some stuff done

00:02:22,860 --> 00:02:26,250
with curls very good at but you were

00:02:24,450 --> 00:02:29,310
never quite sure why do you use things

00:02:26,250 --> 00:02:33,060
like our and local and some of the more

00:02:29,310 --> 00:02:36,540
I shouldn't say esoteric it's like

00:02:33,060 --> 00:02:39,660
different versions of the variable

00:02:36,540 --> 00:02:43,140
declaration I could even probably say I

00:02:39,660 --> 00:02:45,420
was this person I self-taught myself

00:02:43,140 --> 00:02:48,960
Perl as part of during my PhD research

00:02:45,420 --> 00:02:51,180
in physics and so you just you Co always

00:02:48,960 --> 00:02:52,770
use mine okay great so always use mine

00:02:51,180 --> 00:02:54,090
that's great and does most of what you

00:02:52,770 --> 00:02:55,830
want then every now and again they're

00:02:54,090 --> 00:02:57,510
like we'll use our and you're like well

00:02:55,830 --> 00:03:02,100
what's our what's you and you're

00:02:57,510 --> 00:03:06,650
declaring a variable but that's my we're

00:03:02,100 --> 00:03:08,760
going to get there so this is a variable

00:03:06,650 --> 00:03:10,350
we're going to talk about the variable

00:03:08,760 --> 00:03:11,850
kitten we'll be talking about some

00:03:10,350 --> 00:03:14,220
kitten instead of putting some slides

00:03:11,850 --> 00:03:18,120
about kitten but you know you've seen

00:03:14,220 --> 00:03:21,150
kittens and a variable is a place to put

00:03:18,120 --> 00:03:26,519
some stuff so this kitten is called

00:03:21,150 --> 00:03:29,880
buttons and as important as what

00:03:26,519 --> 00:03:32,820
variable holds are some other things

00:03:29,880 --> 00:03:34,560
like how do you find the variable you

00:03:32,820 --> 00:03:37,050
know its name first of all is an easy

00:03:34,560 --> 00:03:38,880
thing we'll talk about some things

00:03:37,050 --> 00:03:41,220
called packages and symbols here in a

00:03:38,880 --> 00:03:43,950
little bit but they're how you how you

00:03:41,220 --> 00:03:47,760
tell your code to talk to this variable

00:03:43,950 --> 00:03:49,320
and also importantly what code can see

00:03:47,760 --> 00:03:50,370
it what is the scope of this variable

00:03:49,320 --> 00:03:51,180
and if you don't know what that word is

00:03:50,370 --> 00:03:56,430
that's fine

00:03:51,180 --> 00:03:58,709
we're going to get there - at one point

00:03:56,430 --> 00:04:02,220
I was on Stack Overflow completely

00:03:58,709 --> 00:04:05,190
confused by this and Tom Kristensen T

00:04:02,220 --> 00:04:06,930
Christ of you know long time pearl Fame

00:04:05,190 --> 00:04:08,970
gave me a great quote that I'm going to

00:04:06,930 --> 00:04:15,450
give you in two parts the first part is

00:04:08,970 --> 00:04:17,430
packages are for finding things so let's

00:04:15,450 --> 00:04:19,500
talk about collisions so you're writing

00:04:17,430 --> 00:04:22,169
a script and your script has a few

00:04:19,500 --> 00:04:24,210
function and at some point you want to

00:04:22,169 --> 00:04:27,250
name something and so you've got that

00:04:24,210 --> 00:04:29,890
person name and name is Joel

00:04:27,250 --> 00:04:32,890
that's me and then later you want to

00:04:29,890 --> 00:04:34,810
print the name so print name with a new

00:04:32,890 --> 00:04:36,280
line because we're not doing any kind of

00:04:34,810 --> 00:04:39,790
declarations we got we don't have to say

00:04:36,280 --> 00:04:42,070
yet and somewhere else you're going to

00:04:39,790 --> 00:04:44,470
set your kittens name well we're going

00:04:42,070 --> 00:04:47,800
to use name again because you know we're

00:04:44,470 --> 00:04:50,350
writing quickly and doesn't matter well

00:04:47,800 --> 00:04:53,110
if your program runs like that person

00:04:50,350 --> 00:04:56,200
name and then set kitten name and then

00:04:53,110 --> 00:05:04,030
print person name suddenly my name is

00:04:56,200 --> 00:05:07,410
button and this is not what you mean so

00:05:04,030 --> 00:05:10,990
naively what we might want to do is

00:05:07,410 --> 00:05:13,630
prefix all of our variables person

00:05:10,990 --> 00:05:18,160
underscore name or kitten underscore

00:05:13,630 --> 00:05:22,060
name and this works it separates out the

00:05:18,160 --> 00:05:24,640
confusion you know you're never going to

00:05:22,060 --> 00:05:27,250
accidentally set person name to Joel as

00:05:24,640 --> 00:05:29,320
a kitten buttons and the other way

00:05:27,250 --> 00:05:34,360
around but your variable names start

00:05:29,320 --> 00:05:36,640
getting kind of long and this is where

00:05:34,360 --> 00:05:38,700
we can get to a concept of namespaces it

00:05:36,640 --> 00:05:42,340
doesn't look that much different

00:05:38,700 --> 00:05:44,140
rather than having person underscore

00:05:42,340 --> 00:05:45,400
name we're just going to tweak it a

00:05:44,140 --> 00:05:47,710
little bit and we're going to call it

00:05:45,400 --> 00:05:50,320
capital person actually capital doesn't

00:05:47,710 --> 00:05:53,890
matter it's just convention and colon

00:05:50,320 --> 00:05:55,690
colon name and we're going to do the

00:05:53,890 --> 00:05:58,810
same for kitten and we're going to refer

00:05:55,690 --> 00:06:02,560
to them all the time by those names the

00:05:58,810 --> 00:06:06,370
same as having underscores the you know

00:06:02,560 --> 00:06:08,950
the name itself is disambiguated so why

00:06:06,370 --> 00:06:10,870
is that better Oh before we get to why

00:06:08,950 --> 00:06:12,190
is that better turns out you can

00:06:10,870 --> 00:06:15,580
actually do the same thing for your

00:06:12,190 --> 00:06:17,620
functions why do I want to do set person

00:06:15,580 --> 00:06:21,790
name one activity person that name and

00:06:17,620 --> 00:06:24,700
kitten that name we've kind of the same

00:06:21,790 --> 00:06:29,979
way we had the underscores prefixes now

00:06:24,700 --> 00:06:31,990
we've got namespace pre-crisis so why is

00:06:29,979 --> 00:06:36,190
this better than just having underscore

00:06:31,990 --> 00:06:39,470
prefixes well for the biggest reason

00:06:36,190 --> 00:06:42,350
being that Perl understands these

00:06:39,470 --> 00:06:46,400
and because pearl understands these we

00:06:42,350 --> 00:06:50,420
have shortcuts so we can declare package

00:06:46,400 --> 00:06:52,250
person and now under this package

00:06:50,420 --> 00:06:55,100
everything is assumed to be in the

00:06:52,250 --> 00:06:57,410
package person which is exactly the same

00:06:55,100 --> 00:06:59,030
as declaring them fully qualified which

00:06:57,410 --> 00:07:03,830
is how you talk about with the double

00:06:59,030 --> 00:07:08,570
colons so this is person : : set name

00:07:03,830 --> 00:07:14,420
and person : : name and when we print

00:07:08,570 --> 00:07:17,120
them out you get the same things you see

00:07:14,420 --> 00:07:19,940
here at the end and now explicitly bring

00:07:17,120 --> 00:07:22,100
us back to package main and we do this

00:07:19,940 --> 00:07:24,260
because just for consistency with the

00:07:22,100 --> 00:07:26,090
earlier example if you don't tell it

00:07:24,260 --> 00:07:28,970
which package you're in the package

00:07:26,090 --> 00:07:29,570
you're in is main so just to be

00:07:28,970 --> 00:07:31,160
consistent

00:07:29,570 --> 00:07:38,540
I've brought us back explicitly to

00:07:31,160 --> 00:07:41,870
package me these package variables are

00:07:38,540 --> 00:07:44,690
still global and we can still refer to

00:07:41,870 --> 00:07:48,200
them by their fully qualified name other

00:07:44,690 --> 00:07:53,720
places in the script it works just fine

00:07:48,200 --> 00:07:56,479
so here i've declared person and a name

00:07:53,720 --> 00:07:59,600
of Joel and a kitten whose name is

00:07:56,479 --> 00:08:02,090
buttons but back in package main we can

00:07:59,600 --> 00:08:09,380
still talk about person name and kitten

00:08:02,090 --> 00:08:12,169
name and get what you expect just a

00:08:09,380 --> 00:08:15,880
brief aside this is how most of the

00:08:12,169 --> 00:08:20,090
internals of Perl name their thing

00:08:15,880 --> 00:08:22,820
there's a giant hash of all of the

00:08:20,090 --> 00:08:25,250
symbols so person is a symbol name is a

00:08:22,820 --> 00:08:27,800
symbol and we make a hash of these and

00:08:25,250 --> 00:08:30,229
the hash is called

00:08:27,800 --> 00:08:33,890
colon colon just to be confusing because

00:08:30,229 --> 00:08:35,960
why not if you'd like to you can run

00:08:33,890 --> 00:08:37,969
these on your own you can use data

00:08:35,960 --> 00:08:43,720
dumper which is useful for dumping data

00:08:37,969 --> 00:08:46,600
structures and we can dump the top-level

00:08:43,720 --> 00:08:51,320
stash so hash of all the symbol table

00:08:46,600 --> 00:08:52,850
and you'll see all of the symbols that

00:08:51,320 --> 00:08:54,079
pearl knows about and

00:08:52,850 --> 00:08:56,329
it's going to be a lot there's a lot of

00:08:54,079 --> 00:08:58,970
stuff you don't care about so you can

00:08:56,329 --> 00:09:00,740
instead because I've already loaded data

00:08:58,970 --> 00:09:03,079
dumper I can just talk about data

00:09:00,740 --> 00:09:04,339
dumpers symbol table and data dumper is

00:09:03,079 --> 00:09:06,620
actually kind of interesting because it

00:09:04,339 --> 00:09:08,449
uses some of these global variables to

00:09:06,620 --> 00:09:10,339
set how it behaves things like its

00:09:08,449 --> 00:09:12,620
indentation level and things like that

00:09:10,339 --> 00:09:17,630
so that's an interesting example run

00:09:12,620 --> 00:09:18,680
those if you'd like and see how the

00:09:17,630 --> 00:09:21,560
internal data structures were

00:09:18,680 --> 00:09:23,269
represented this includes the functions

00:09:21,560 --> 00:09:25,459
in those packages too so you'll see

00:09:23,269 --> 00:09:26,899
you'll start to see how some of that

00:09:25,459 --> 00:09:29,029
internal stuff works if you look at

00:09:26,899 --> 00:09:30,470
those not going to talk about that too

00:09:29,029 --> 00:09:35,240
much but just so you know that it's

00:09:30,470 --> 00:09:37,639
internally a big hash so now that we can

00:09:35,240 --> 00:09:41,509
find things there's the problem of maybe

00:09:37,639 --> 00:09:43,130
being too able to find things and you

00:09:41,509 --> 00:09:45,259
might want to have some of your data be

00:09:43,130 --> 00:09:49,190
sort of private from the rest of your

00:09:45,259 --> 00:09:52,069
running process so again if I have

00:09:49,190 --> 00:09:53,800
person and person Joel and kitten

00:09:52,069 --> 00:09:56,750
buttons

00:09:53,800 --> 00:09:59,329
perhaps my coworker Doug Doug Bell of

00:09:56,750 --> 00:10:01,250
pre-action deep and testers Fame he

00:09:59,329 --> 00:10:06,019
might come and try to steal my kitten

00:10:01,250 --> 00:10:08,720
the jerk and so in some other part of

00:10:06,019 --> 00:10:11,050
the code he comes and says well if I

00:10:08,720 --> 00:10:16,459
just set person : call a name - Doug

00:10:11,050 --> 00:10:19,610
suddenly he owns buttons and you prove

00:10:16,459 --> 00:10:25,130
it by printing it out now how can you

00:10:19,610 --> 00:10:26,540
prevent that from happening let's take

00:10:25,130 --> 00:10:28,610
an aside and do a more concrete example

00:10:26,540 --> 00:10:32,660
because normally that's not what you're

00:10:28,610 --> 00:10:35,240
actually doing in this example we have a

00:10:32,660 --> 00:10:36,889
for loop over some items hi hello and

00:10:35,240 --> 00:10:41,509
hippo if you like the British coupling

00:10:36,889 --> 00:10:42,860
you know what that is we make a function

00:10:41,509 --> 00:10:44,600
called upper it's a pretty stupid

00:10:42,860 --> 00:10:45,889
function because pearl already has you

00:10:44,600 --> 00:10:48,949
see and in fact that's how it's

00:10:45,889 --> 00:10:50,959
implemented but you'll notice I'm for

00:10:48,949 --> 00:10:55,250
looping with my iterating item called

00:10:50,959 --> 00:10:58,730
item and so we set item to first high

00:10:55,250 --> 00:11:02,449
and then we capitalize it store it in

00:10:58,730 --> 00:11:06,830
upper and we try to print item becomes

00:11:02,449 --> 00:11:11,240
upper but down here we also use item

00:11:06,830 --> 00:11:14,810
as our iterating our as our sort of

00:11:11,240 --> 00:11:17,680
incoming variable and then we return it

00:11:14,810 --> 00:11:20,600
and because these use the same variable

00:11:17,680 --> 00:11:24,410
accidentally you know these might be

00:11:20,600 --> 00:11:26,180
separated by many lines of code suddenly

00:11:24,410 --> 00:11:27,350
you have Capital high becomes high well

00:11:26,180 --> 00:11:33,770
that's not at all what you wanted you

00:11:27,350 --> 00:11:35,720
wanted the lowercase and this is where

00:11:33,770 --> 00:11:40,790
we come to our good old friend the

00:11:35,720 --> 00:11:42,350
lexical so lexical z' and I'm only using

00:11:40,790 --> 00:11:44,960
lexical zon item because I didn't want

00:11:42,350 --> 00:11:50,840
to change very much you could of course

00:11:44,960 --> 00:11:53,240
use it for at items and for a dollar

00:11:50,840 --> 00:11:56,960
upper we're just talking about it on my

00:11:53,240 --> 00:12:00,200
here on item so by declaring my in this

00:11:56,960 --> 00:12:02,750
scope and my here now these are two

00:12:00,200 --> 00:12:05,480
different variables and they do not talk

00:12:02,750 --> 00:12:08,180
to each other in fact they can't even be

00:12:05,480 --> 00:12:11,660
seen by each other we'll talk a little

00:12:08,180 --> 00:12:13,640
bit more about that but for here to

00:12:11,660 --> 00:12:15,830
clear as a block we'll top up left and

00:12:13,640 --> 00:12:21,230
second upper declares a block in so

00:12:15,830 --> 00:12:23,630
these mais are found into those scopes

00:12:21,230 --> 00:12:25,430
and can only be seen there so now the

00:12:23,630 --> 00:12:32,810
code behaves as we expect I becomes

00:12:25,430 --> 00:12:35,180
Capitol high-low cetera so let's talk a

00:12:32,810 --> 00:12:38,600
little bit about lexical lexical prevent

00:12:35,180 --> 00:12:41,350
clobbering and overwriting of other

00:12:38,600 --> 00:12:44,240
variable content throughout the program

00:12:41,350 --> 00:12:47,750
whether that over writing would be

00:12:44,240 --> 00:12:49,130
intentional or accidental so you know if

00:12:47,750 --> 00:12:50,720
you had some malicious code getting

00:12:49,130 --> 00:12:52,460
loaded in your library it wouldn't be

00:12:50,720 --> 00:12:54,860
able to you know save steal your kitten

00:12:52,460 --> 00:12:57,290
or probably more likely just

00:12:54,860 --> 00:12:59,300
accidentally you don't want to reuse an

00:12:57,290 --> 00:13:01,910
iterating variable or something along

00:12:59,300 --> 00:13:06,500
those lines it can't even read that code

00:13:01,910 --> 00:13:08,570
let alone write it but importantly it's

00:13:06,500 --> 00:13:10,310
not bound to any namespace all that

00:13:08,570 --> 00:13:12,740
stuff we just talked about the symbol

00:13:10,310 --> 00:13:15,170
table hash fully-qualified names with

00:13:12,740 --> 00:13:17,270
colon colon mine doesn't talk about

00:13:15,170 --> 00:13:19,730
those at all it has no concept of what

00:13:17,270 --> 00:13:23,139
that is

00:13:19,730 --> 00:13:25,549
they're not in the stash in any sense

00:13:23,139 --> 00:13:30,290
rather than being this - they're bound

00:13:25,549 --> 00:13:32,689
to a scope as I said before to go back

00:13:30,290 --> 00:13:36,799
to it this is that original quote from

00:13:32,689 --> 00:13:39,109
from Tom completed out today packages

00:13:36,799 --> 00:13:41,600
are for finding things and scopes are

00:13:39,109 --> 00:13:43,999
for hiding things and when you kind of

00:13:41,600 --> 00:13:45,739
internalize that that mindset you start

00:13:43,999 --> 00:13:48,079
to understand some of these but we'll

00:13:45,739 --> 00:13:51,949
get to how that really works in a second

00:13:48,079 --> 00:13:55,639
here let's go back and prevent that kit

00:13:51,949 --> 00:13:58,819
and theft so I have my package person

00:13:55,639 --> 00:14:02,959
and my name but now you'll notice that I

00:13:58,819 --> 00:14:06,499
have name with a my and now we've got a

00:14:02,959 --> 00:14:10,899
function name which is person : : name

00:14:06,499 --> 00:14:13,639
function and it returns the lexical my a

00:14:10,899 --> 00:14:18,410
lexical main which are declared with

00:14:13,639 --> 00:14:21,769
mine and the same for kitten and now

00:14:18,410 --> 00:14:24,410
down here when we do that same thing of

00:14:21,769 --> 00:14:27,109
printing out who owns buttons

00:14:24,410 --> 00:14:28,910
there's nothing Doug could have done no

00:14:27,109 --> 00:14:32,779
code he could write outside of these

00:14:28,910 --> 00:14:35,539
scopes that would allow him to put his

00:14:32,779 --> 00:14:36,980
name there well there is but not some

00:14:35,539 --> 00:14:39,139
variables and we're home check there

00:14:36,980 --> 00:14:42,489
it's purl of course there's plenty of

00:14:39,139 --> 00:14:45,439
ways to do crazy things but not accident

00:14:42,489 --> 00:14:49,100
that making enough sense if people still

00:14:45,439 --> 00:14:52,549
follow along so I didn't really tell you

00:14:49,100 --> 00:14:56,449
what a scope is the scope is a block we

00:14:52,549 --> 00:14:58,249
declare it with curly braces and most of

00:14:56,449 --> 00:15:01,480
the places in Perl where you have a set

00:14:58,249 --> 00:15:05,359
of curly braces that is actually a block

00:15:01,480 --> 00:15:10,489
declaring a function an if block a while

00:15:05,359 --> 00:15:15,319
of four those are all blocks one that

00:15:10,489 --> 00:15:17,989
isn't there and there one like the do do

00:15:15,319 --> 00:15:20,089
block is a block feels like there's one

00:15:17,989 --> 00:15:22,160
that isn't but for the most part anytime

00:15:20,089 --> 00:15:24,039
you see a pair of Curly's even just an

00:15:22,160 --> 00:15:26,809
empty one you can make empty braces oh

00:15:24,039 --> 00:15:29,659
hash constructor of course is not that's

00:15:26,809 --> 00:15:31,920
what I was trying to think of is not a

00:15:29,659 --> 00:15:37,600
block

00:15:31,920 --> 00:15:40,060
or the outer scope of a block is the

00:15:37,600 --> 00:15:41,770
file that it's declared in so this is

00:15:40,060 --> 00:15:44,440
slightly different than a package right

00:15:41,770 --> 00:15:46,570
packages often are the start of a file

00:15:44,440 --> 00:15:48,550
but you can still talk about that

00:15:46,570 --> 00:15:49,780
package even if you've got several

00:15:48,550 --> 00:15:52,330
different libraries loaded from

00:15:49,780 --> 00:15:54,730
different files for a lexical the file

00:15:52,330 --> 00:15:58,930
is the scope if you don't have it inside

00:15:54,730 --> 00:16:00,400
of another block which is especially

00:15:58,930 --> 00:16:01,710
handy when you're writing your libraries

00:16:00,400 --> 00:16:04,540
right you don't have to worry about

00:16:01,710 --> 00:16:13,090
cross-pollination of these variables you

00:16:04,540 --> 00:16:15,190
know it's just in that file now

00:16:13,090 --> 00:16:18,700
interestingly the package key word

00:16:15,190 --> 00:16:22,180
itself is lexically scoped so it cares

00:16:18,700 --> 00:16:23,590
where these braces are which means we go

00:16:22,180 --> 00:16:27,460
back to that same example that we had

00:16:23,590 --> 00:16:30,520
before this package main declaration

00:16:27,460 --> 00:16:33,400
here isn't actually necessary because we

00:16:30,520 --> 00:16:35,410
enter a brace we say we're in package

00:16:33,400 --> 00:16:37,150
person and then we actually fall doubt

00:16:35,410 --> 00:16:41,890
back out of the package at the end

00:16:37,150 --> 00:16:43,180
raised here so for this one line here

00:16:41,890 --> 00:16:45,910
where nothing happens we're back in

00:16:43,180 --> 00:16:50,680
package main and the same thing happens

00:16:45,910 --> 00:16:52,870
at the end of the second race so we can

00:16:50,680 --> 00:16:59,800
remove that line if you want not

00:16:52,870 --> 00:17:02,800
necessary person name own kitten name so

00:16:59,800 --> 00:17:05,339
should I use Global's or lexical should

00:17:02,800 --> 00:17:07,569
you use those fully qualified names

00:17:05,339 --> 00:17:10,270
which are accessible from other places

00:17:07,569 --> 00:17:12,819
or should you not well you should

00:17:10,270 --> 00:17:15,100
default to lexical and this is why in

00:17:12,819 --> 00:17:16,959
most of the Perl learning and same for

00:17:15,100 --> 00:17:19,630
me I came through everyone just kind of

00:17:16,959 --> 00:17:24,010
says oh you should always use my because

00:17:19,630 --> 00:17:26,829
mostly you should there are a few rare

00:17:24,010 --> 00:17:28,870
cases where you really do want Global's

00:17:26,829 --> 00:17:30,700
but you're going to know those when you

00:17:28,870 --> 00:17:33,970
get there for the most part you should

00:17:30,700 --> 00:17:35,380
always use lexical z' they're safer as

00:17:33,970 --> 00:17:37,720
we've talked about already they're

00:17:35,380 --> 00:17:39,400
actually faster and actually if you

00:17:37,720 --> 00:17:42,730
think if you go back through the history

00:17:39,400 --> 00:17:44,770
of perl lexical is weren't added for the

00:17:42,730 --> 00:17:46,990
safety that we've just

00:17:44,770 --> 00:17:49,240
about here they were added for the speed

00:17:46,990 --> 00:17:50,770
hash lookup is really slow and if you're

00:17:49,240 --> 00:17:53,860
talking about maybe several levels of

00:17:50,770 --> 00:17:56,679
hash lookups right you're in package : :

00:17:53,860 --> 00:17:58,120
some other package : : each one of those

00:17:56,679 --> 00:18:00,460
is the hash lookup and it takes a long

00:17:58,120 --> 00:18:02,559
time lexical is being found to those

00:18:00,460 --> 00:18:04,990
scopes the interpreter has that variable

00:18:02,559 --> 00:18:08,440
right at hand right away so they're much

00:18:04,990 --> 00:18:12,160
faster you only want to use Global's for

00:18:08,440 --> 00:18:16,300
truly global behavior sometimes system

00:18:12,160 --> 00:18:18,309
resources or functional behavior from

00:18:16,300 --> 00:18:19,300
non object or dn't libraries have to do

00:18:18,309 --> 00:18:20,740
this because they have no better way

00:18:19,300 --> 00:18:22,960
that's what I was talking about with

00:18:20,740 --> 00:18:27,940
data dumper where you can use it to say

00:18:22,960 --> 00:18:30,850
data dumper pls format my dumped objects

00:18:27,940 --> 00:18:34,660
into certain indentation levels or

00:18:30,850 --> 00:18:36,820
certain hair joiners and things like

00:18:34,660 --> 00:18:38,350
that if none of that makes any sense to

00:18:36,820 --> 00:18:40,179
you you don't have to worry about it but

00:18:38,350 --> 00:18:45,820
that's the few places you'll see these

00:18:40,179 --> 00:18:48,970
kind of Global's alright well now if

00:18:45,820 --> 00:18:50,650
lexical czar better than Gorbals why

00:18:48,970 --> 00:18:53,020
aren't we using those by defaults in

00:18:50,650 --> 00:18:55,360
Perl why if I don't say my do I get a

00:18:53,020 --> 00:18:57,340
global if I should be using a lexical

00:18:55,360 --> 00:18:59,800
well they should be

00:18:57,340 --> 00:19:02,470
but because Perl loves backwards

00:18:59,800 --> 00:19:07,120
compatibility compatibility they can't

00:19:02,470 --> 00:19:11,679
be so this is we don't want to break old

00:19:07,120 --> 00:19:13,809
code so we make you turn it on at the

00:19:11,679 --> 00:19:15,220
beginning of your code which I still

00:19:13,809 --> 00:19:18,250
personally disagree with but it's the

00:19:15,220 --> 00:19:20,800
best we got so now and that's part of

00:19:18,250 --> 00:19:24,760
what you strict does you strict doesn't

00:19:20,800 --> 00:19:26,110
let you declare global accidentally much

00:19:24,760 --> 00:19:27,340
in the way if you did you know I don't

00:19:26,110 --> 00:19:29,380
know if any of you are in web

00:19:27,340 --> 00:19:33,040
development JavaScript has that same

00:19:29,380 --> 00:19:37,410
exact problem if you don't say var you

00:19:33,040 --> 00:19:39,550
know variable name you get a global and

00:19:37,410 --> 00:19:40,750
actually they implement it exactly the

00:19:39,550 --> 00:19:45,760
same fixed you have to tell it you

00:19:40,750 --> 00:19:49,000
strict actually it's not all of strict

00:19:45,760 --> 00:19:51,790
strict VARs is the one that gives you

00:19:49,000 --> 00:19:54,929
this behavior but you want all of the

00:19:51,790 --> 00:19:57,160
strict behaviors so just use strict and

00:19:54,929 --> 00:19:58,540
now from this point the rest of the talk

00:19:57,160 --> 00:20:00,070
is strip safe

00:19:58,540 --> 00:20:01,510
I'm not going to write them because I

00:20:00,070 --> 00:20:05,800
only have so much space on the slides

00:20:01,510 --> 00:20:09,220
but these are all run under straight now

00:20:05,800 --> 00:20:10,960
that I've enabled strict how do you

00:20:09,220 --> 00:20:13,230
still talk about Global's well you can

00:20:10,960 --> 00:20:16,060
always use these fully qualified names

00:20:13,230 --> 00:20:18,700
so kitten : : name will always talk

00:20:16,060 --> 00:20:22,780
about the global variable name inside

00:20:18,700 --> 00:20:25,810
the kitten namespace or you can use the

00:20:22,780 --> 00:20:28,120
our keyword so if I declare packaged

00:20:25,810 --> 00:20:31,140
kitten and then rather than my name I

00:20:28,120 --> 00:20:38,680
say our name what you've actually got is

00:20:31,140 --> 00:20:41,920
kitten : : name and it's a little more

00:20:38,680 --> 00:20:44,920
complex than that what you actually get

00:20:41,920 --> 00:20:47,500
is a lexical alias to the package

00:20:44,920 --> 00:20:52,300
variable alright now we're getting a

00:20:47,500 --> 00:20:55,510
little confusing so if we say kittens

00:20:52,300 --> 00:20:58,480
names button an owner's name is Joel

00:20:55,510 --> 00:21:00,940
those are now safely stashed into or

00:20:58,480 --> 00:21:04,030
safely hidden inside of this braces as

00:21:00,940 --> 00:21:06,460
we talked about before but maybe we want

00:21:04,030 --> 00:21:08,920
to have something accessible from the

00:21:06,460 --> 00:21:11,560
outside maybe we want to have the

00:21:08,920 --> 00:21:13,870
ability for a temporary caretaker to be

00:21:11,560 --> 00:21:17,160
assigned and it will default to me the

00:21:13,870 --> 00:21:20,560
owner and now we can print out info

00:21:17,160 --> 00:21:26,080
owner owns name but it's cared for by

00:21:20,560 --> 00:21:27,850
the caretaker and if we don't send

00:21:26,080 --> 00:21:30,700
anything it's Joel alone but and cared

00:21:27,850 --> 00:21:32,380
for by Joel but from the outside we can

00:21:30,700 --> 00:21:35,800
let Doug come in and take care of the

00:21:32,380 --> 00:21:38,130
kit in the feed life and you will now

00:21:35,800 --> 00:21:42,090
see how that works

00:21:38,130 --> 00:21:42,090
does that make sense yes

00:21:50,990 --> 00:21:59,090
all right so this is a good question so

00:21:54,130 --> 00:22:00,830
in this case you know this my you're

00:21:59,090 --> 00:22:05,870
saying like can I talk to this my

00:22:00,830 --> 00:22:09,140
outside of there the mind it should

00:22:05,870 --> 00:22:11,480
recall only cares about these races it

00:22:09,140 --> 00:22:15,049
has nothing to do with the stashes

00:22:11,480 --> 00:22:18,190
nothing to do with the package so if you

00:22:15,049 --> 00:22:21,860
tried to assign to name from out here

00:22:18,190 --> 00:22:23,570
you would get an error because name

00:22:21,860 --> 00:22:25,100
hasn't been declared outside of here and

00:22:23,570 --> 00:22:28,669
strict prevents you from talking about

00:22:25,100 --> 00:22:32,419
name if you didn't have strict on and

00:22:28,669 --> 00:22:34,929
you talked about dollar name here you

00:22:32,419 --> 00:22:40,130
would be talking about main : : name and

00:22:34,929 --> 00:22:43,159
not a kitten : : name and if you tried

00:22:40,130 --> 00:22:44,990
to do kitten : : name that's a global

00:22:43,159 --> 00:22:47,899
variable which isn't talked about up

00:22:44,990 --> 00:22:50,870
here you could set it certainly but

00:22:47,899 --> 00:22:52,490
nothing else talks to it so you would

00:22:50,870 --> 00:22:56,080
set a variable that nothing ever looks

00:22:52,490 --> 00:22:56,080
at does that make sense

00:22:57,190 --> 00:23:10,039
right yes because that never looks at

00:23:04,399 --> 00:23:12,350
that variable it's harmless yes yes you

00:23:10,039 --> 00:23:14,090
can you can push a little bit of data

00:23:12,350 --> 00:23:16,039
into it from someplace else and read it

00:23:14,090 --> 00:23:17,390
from someplace else in some sense it's

00:23:16,039 --> 00:23:19,309
just another variable to the Perl

00:23:17,390 --> 00:23:22,630
interpreter it's kind of weird that you

00:23:19,309 --> 00:23:25,220
put it in someone else's name space but

00:23:22,630 --> 00:23:27,020
and again this is the reason why it's

00:23:25,220 --> 00:23:29,000
more important to always talk about your

00:23:27,020 --> 00:23:32,090
variables that you care about care about

00:23:29,000 --> 00:23:33,409
as my because now you've prevented

00:23:32,090 --> 00:23:36,380
anyone from doing that even if they do

00:23:33,409 --> 00:23:38,919
that it doesn't hurt you does a very

00:23:36,380 --> 00:23:38,919
good question

00:23:39,549 --> 00:23:46,190
now back to what I was saying before

00:23:42,049 --> 00:23:49,100
about it being a lexical alias now what

00:23:46,190 --> 00:23:52,429
say we start our package here outside of

00:23:49,100 --> 00:23:54,169
the scope with kitten and I have to

00:23:52,429 --> 00:23:57,140
compensate for that by putting package

00:23:54,169 --> 00:24:01,490
main back down here so we exit the

00:23:57,140 --> 00:24:04,970
kitten namespace we have the same my

00:24:01,490 --> 00:24:10,520
name and my owner but we've now made

00:24:04,970 --> 00:24:12,860
declaration of our caretaker here and we

00:24:10,520 --> 00:24:19,340
assign caretaker the same way defaults

00:24:12,860 --> 00:24:23,210
to me this variable caretaker here still

00:24:19,340 --> 00:24:26,659
in the same lexical scope still refers

00:24:23,210 --> 00:24:29,080
to package kitten now this is the

00:24:26,659 --> 00:24:32,659
behavior you don't need to know ever

00:24:29,080 --> 00:24:36,230
like if this confuses you just never

00:24:32,659 --> 00:24:39,409
behave like this but but it's good to

00:24:36,230 --> 00:24:42,860
note to mention that this behavior is

00:24:39,409 --> 00:24:46,730
lexical it has nothing to do with the

00:24:42,860 --> 00:24:49,730
package just like my our declares the

00:24:46,730 --> 00:24:53,440
scope of the variable to be lexical even

00:24:49,730 --> 00:24:55,669
though it refers to the package global

00:24:53,440 --> 00:25:02,270
you're not going to get that the first

00:24:55,669 --> 00:25:04,880
time through it's okay this caretaker is

00:25:02,270 --> 00:25:09,080
still kitten : : caretaker

00:25:04,880 --> 00:25:13,130
this is kitten : : caretaker and this is

00:25:09,080 --> 00:25:16,909
kitten : : caretaker but once you would

00:25:13,130 --> 00:25:19,370
leave this scope then that alias goes

00:25:16,909 --> 00:25:22,970
away so if there are braces around this

00:25:19,370 --> 00:25:26,720
whole block then outside of that the

00:25:22,970 --> 00:25:30,890
caretaker alias would go away this is

00:25:26,720 --> 00:25:32,870
maybe the hardest concept in this talk

00:25:30,890 --> 00:25:34,640
and it really is okay if you don't

00:25:32,870 --> 00:25:35,650
understand it just know that that's

00:25:34,640 --> 00:25:39,650
possible

00:25:35,650 --> 00:25:44,870
halfway I'm able even a little past

00:25:39,650 --> 00:25:48,919
halfway already okay so an important

00:25:44,870 --> 00:25:51,950
thing about Global's is that you be nice

00:25:48,919 --> 00:25:54,289
about them often if people have given

00:25:51,950 --> 00:25:58,700
you a global interface to your library

00:25:54,289 --> 00:26:01,070
like data dump or does for example you

00:25:58,700 --> 00:26:03,260
want to set the variable to what you

00:26:01,070 --> 00:26:05,360
need it to be while you're using it but

00:26:03,260 --> 00:26:08,270
you can be polite and set it back when

00:26:05,360 --> 00:26:12,770
you're done the only problem with that

00:26:08,270 --> 00:26:15,169
is being done is an interesting concept

00:26:12,770 --> 00:26:16,940
in a programming world right you can

00:26:15,169 --> 00:26:17,970
know it sometimes if you're in a small

00:26:16,940 --> 00:26:22,770
function or

00:26:17,970 --> 00:26:25,620
small script but are you going to

00:26:22,770 --> 00:26:27,750
remember to unset it you have to store

00:26:25,620 --> 00:26:30,690
the value that it currently has an unset

00:26:27,750 --> 00:26:34,260
it later it can be a little more of a

00:26:30,690 --> 00:26:36,440
task than you'd like this be so we have

00:26:34,260 --> 00:26:40,680
one more keyword here called local and

00:26:36,440 --> 00:26:43,400
local lets you set a global variable but

00:26:40,680 --> 00:26:46,320
only inside of your current scope and

00:26:43,400 --> 00:26:52,790
interestingly all of the scopes that

00:26:46,320 --> 00:26:57,840
that contains so once again with my king

00:26:52,790 --> 00:27:04,290
like sliding so we have again our

00:26:57,840 --> 00:27:07,860
caretaker defaults to me and now Doug is

00:27:04,290 --> 00:27:12,810
only going to help me care take a kit of

00:27:07,860 --> 00:27:16,500
a button inside of this block here so

00:27:12,810 --> 00:27:19,620
local to this block the caretaker will

00:27:16,500 --> 00:27:24,590
be Doug and when we print out that

00:27:19,620 --> 00:27:29,370
information we see those helping me out

00:27:24,590 --> 00:27:32,190
but by the magic of this variable you'll

00:27:29,370 --> 00:27:36,780
see so if this was my if I set my

00:27:32,190 --> 00:27:45,510
caretaker is Doug it wouldn't propagate

00:27:36,780 --> 00:27:49,290
into the function kitten info right so

00:27:45,510 --> 00:27:53,310
the lexical behavior would prevent the

00:27:49,290 --> 00:27:56,310
the inside of this function from seeing

00:27:53,310 --> 00:27:58,020
it local is what's called dynamic

00:27:56,310 --> 00:27:59,310
scoping and you don't have to remember

00:27:58,020 --> 00:28:03,510
that name if you don't want to either

00:27:59,310 --> 00:28:05,610
but what it really kind of means is the

00:28:03,510 --> 00:28:07,980
Global's will behave like you want them

00:28:05,610 --> 00:28:10,890
to in this scope and then they will

00:28:07,980 --> 00:28:14,460
reset themselves when you're done kind

00:28:10,890 --> 00:28:16,230
of almost as if by magic and Grahm yes I

00:28:14,460 --> 00:28:21,270
know it's not by magic so you don't have

00:28:16,230 --> 00:28:24,600
to tell but mostly by magic you can just

00:28:21,270 --> 00:28:26,580
set the variable here use it as you

00:28:24,600 --> 00:28:30,330
would call functions that refer to it

00:28:26,580 --> 00:28:31,770
and when you're done with that scope it

00:28:30,330 --> 00:28:34,350
will go away again

00:28:31,770 --> 00:28:40,380
so again here I am again the kittens

00:28:34,350 --> 00:28:42,740
caretaker an example of this is one of

00:28:40,380 --> 00:28:46,230
my favorite of pearls magical Global's

00:28:42,740 --> 00:28:48,660
dollar double quote which if you don't

00:28:46,230 --> 00:28:51,990
know about is fine it's just kind of a

00:28:48,660 --> 00:28:54,480
fun little thing dollar double quote has

00:28:51,990 --> 00:28:56,940
the interesting behavior of if you put

00:28:54,480 --> 00:28:59,280
in two already know how pearl behaves if

00:28:56,940 --> 00:29:00,990
you put a variable you know a single

00:28:59,280 --> 00:29:04,230
scalar variable into a double quoted

00:29:00,990 --> 00:29:06,420
string you just get its value well what

00:29:04,230 --> 00:29:08,760
if you wanted to interpolate an array

00:29:06,420 --> 00:29:11,010
into a double quoted string you can do

00:29:08,760 --> 00:29:13,500
it and here I'm just using ad underscore

00:29:11,010 --> 00:29:15,800
the functions argument and I'm putting

00:29:13,500 --> 00:29:20,370
it straight into a double quoted string

00:29:15,800 --> 00:29:23,850
with a thing I'm calling babies well

00:29:20,370 --> 00:29:26,340
what is pearl going to do by default and

00:29:23,850 --> 00:29:29,850
you don't have to know this by default

00:29:26,340 --> 00:29:31,920
pearl joins them with a space alright

00:29:29,850 --> 00:29:34,080
well that's interesting but you know

00:29:31,920 --> 00:29:36,750
maybe that's not what I need and in fact

00:29:34,080 --> 00:29:40,080
I would like my items to be joined with

00:29:36,750 --> 00:29:42,690
a comma so you can set dollar double

00:29:40,080 --> 00:29:44,690
quote equalled comma and when I say

00:29:42,690 --> 00:29:47,760
these parsley sage rosemary and thyme

00:29:44,690 --> 00:29:52,560
what I get is parsley comma stage comma

00:29:47,760 --> 00:29:55,290
rosemary Colin time now maybe your

00:29:52,560 --> 00:29:56,940
script so let's say this is some script

00:29:55,290 --> 00:29:59,790
you've written and you control most of

00:29:56,940 --> 00:30:02,370
the code and you can say to yourself boy

00:29:59,790 --> 00:30:04,110
I really like this behavior I want to

00:30:02,370 --> 00:30:07,920
use it everywhere so you set it globally

00:30:04,110 --> 00:30:09,600
here but now some time later you come up

00:30:07,920 --> 00:30:11,280
and you go you know I really like that

00:30:09,600 --> 00:30:13,710
behavior but for this little bit of code

00:30:11,280 --> 00:30:17,760
I really need it to be placed separated

00:30:13,710 --> 00:30:20,280
instead of the comma separated well

00:30:17,760 --> 00:30:24,620
inside of a scope you can set local

00:30:20,280 --> 00:30:28,230
dollar double quote equal type save ease

00:30:24,620 --> 00:30:31,140
the cows sheep and goats are separated

00:30:28,230 --> 00:30:33,360
by pipes and then once you've fallen out

00:30:31,140 --> 00:30:36,090
of the scope it immediately goes back to

00:30:33,360 --> 00:30:39,030
being comma separated again for planes

00:30:36,090 --> 00:30:40,770
trains and automobiles and this is

00:30:39,030 --> 00:30:43,410
really handy because you can get the

00:30:40,770 --> 00:30:44,659
behavior you want without screwing up

00:30:43,410 --> 00:30:47,749
people

00:30:44,659 --> 00:30:49,519
that are already have already written

00:30:47,749 --> 00:30:51,259
their code or other libraries that use

00:30:49,519 --> 00:30:54,889
their code differently as long as you're

00:30:51,259 --> 00:30:57,669
careful and you use this local key does

00:30:54,889 --> 00:30:57,669
that make sense to everyone

00:31:00,249 --> 00:31:06,889
now of course local only works on these

00:31:04,309 --> 00:31:11,659
global variables right if I set my

00:31:06,889 --> 00:31:14,599
dollar X I try to say local dollar X you

00:31:11,659 --> 00:31:17,749
get an error because what you're really

00:31:14,599 --> 00:31:22,129
manipulating is this global stash of

00:31:17,749 --> 00:31:24,529
variables you'll notice I left this dot

00:31:22,129 --> 00:31:26,259
dot dot here right so that's not the

00:31:24,529 --> 00:31:30,289
whole story

00:31:26,259 --> 00:31:31,700
interestingly and you don't need to

00:31:30,289 --> 00:31:34,460
remember this either if you don't want

00:31:31,700 --> 00:31:36,289
to it also works on data structure

00:31:34,460 --> 00:31:37,909
element even if the data structure

00:31:36,289 --> 00:31:45,229
itself is let it go

00:31:37,909 --> 00:31:48,470
so my data a $2 X is 12 local data X is

00:31:45,229 --> 00:31:51,200
50 what local really knows how to work

00:31:48,470 --> 00:31:54,889
on is data structures so it works on the

00:31:51,200 --> 00:31:56,960
data structure of the Perl symbol table

00:31:54,889 --> 00:32:00,649
hash you can also use it on your own

00:31:56,960 --> 00:32:03,109
hashes or your own arrays I don't really

00:32:00,649 --> 00:32:04,639
recommend using this unless you really

00:32:03,109 --> 00:32:07,039
know what you're doing and why but it

00:32:04,639 --> 00:32:11,479
can be really nice in the rare cases

00:32:07,039 --> 00:32:14,090
that you need it may be the usual

00:32:11,479 --> 00:32:16,849
example I would give of this is in Moe

00:32:14,090 --> 00:32:18,799
delicious you start an event loop and

00:32:16,849 --> 00:32:20,929
you want it to know for sure that the

00:32:18,799 --> 00:32:22,700
event loop is running if you have other

00:32:20,929 --> 00:32:25,309
code somewhere else that might check is

00:32:22,700 --> 00:32:29,419
my event loop running and so we actually

00:32:25,309 --> 00:32:33,470
Lex it locally poked in a variable into

00:32:29,419 --> 00:32:35,090
the object the IO loop that the loop is

00:32:33,470 --> 00:32:36,979
running and we have a method that you

00:32:35,090 --> 00:32:39,470
can call says is it running and it says

00:32:36,979 --> 00:32:43,970
yes I'm running what that's checking is

00:32:39,470 --> 00:32:46,279
a localized a bit of data on the IO loop

00:32:43,970 --> 00:32:48,080
object and that's because then we can

00:32:46,279 --> 00:32:49,729
know for absolutely sure that while

00:32:48,080 --> 00:32:53,059
you're in the loop it's just a little

00:32:49,729 --> 00:32:55,129
while loop you can know for sure that

00:32:53,059 --> 00:32:56,570
it's running and then anything that

00:32:55,129 --> 00:32:58,160
prevents it from running anything that

00:32:56,570 --> 00:33:00,530
will fall out of that loop

00:32:58,160 --> 00:33:04,130
the local goes away and it's no longer

00:33:00,530 --> 00:33:07,600
running so exceptions things like that

00:33:04,130 --> 00:33:07,600
that might throw you out of that loop

00:33:07,870 --> 00:33:11,419
but for the most part you don't need to

00:33:10,039 --> 00:33:13,970
know that yet just know that it is

00:33:11,419 --> 00:33:18,530
possible and look it up again later if

00:33:13,970 --> 00:33:20,570
you need to and as I alluded to you can

00:33:18,530 --> 00:33:22,160
also use local to manipulate the symbol

00:33:20,570 --> 00:33:25,039
table hash now I didn't talk about this

00:33:22,160 --> 00:33:28,130
star but just trust me when I say that's

00:33:25,039 --> 00:33:30,530
manipulating the symbol table hash so

00:33:28,130 --> 00:33:34,159
you might imagine you have some database

00:33:30,530 --> 00:33:36,950
class you know some model layer in your

00:33:34,159 --> 00:33:40,610
web app so my app database and you've

00:33:36,950 --> 00:33:42,350
got a run query method and later on

00:33:40,610 --> 00:33:44,570
you're writing a test and you don't want

00:33:42,350 --> 00:33:46,280
to connect out to the database because

00:33:44,570 --> 00:33:48,320
this is the unit test so you shouldn't

00:33:46,280 --> 00:33:51,620
refer to your database in the unit test

00:33:48,320 --> 00:33:55,490
the pure unit test so you might be able

00:33:51,620 --> 00:33:58,700
to set in your test script and you know

00:33:55,490 --> 00:34:01,280
for now just believe that star is going

00:33:58,700 --> 00:34:04,039
to replace this entry in the symbol

00:34:01,280 --> 00:34:08,000
table hash for the for the function

00:34:04,039 --> 00:34:10,100
there my app database run query which of

00:34:08,000 --> 00:34:11,990
course I have database run query as I

00:34:10,100 --> 00:34:15,710
said before is the fully qualified name

00:34:11,990 --> 00:34:18,320
here we're going to locally set this to

00:34:15,710 --> 00:34:20,600
return us some known result we can then

00:34:18,320 --> 00:34:22,669
run our code we know what the result

00:34:20,600 --> 00:34:25,550
that it got from the fake database query

00:34:22,669 --> 00:34:27,200
and we can test that we've got the code

00:34:25,550 --> 00:34:30,950
around the database query you know you

00:34:27,200 --> 00:34:32,690
maybe you check to see that the result

00:34:30,950 --> 00:34:34,520
you got from the database you munge it

00:34:32,690 --> 00:34:36,169
in some way and maybe you make a string

00:34:34,520 --> 00:34:37,820
out of it instead of a hash ref or

00:34:36,169 --> 00:34:39,470
whatever you do to that resultant got

00:34:37,820 --> 00:34:41,869
from the database you can check the

00:34:39,470 --> 00:34:45,950
result is right after all your other

00:34:41,869 --> 00:34:47,659
manipulations but it doesn't affect

00:34:45,950 --> 00:34:50,899
other code around there it's just in

00:34:47,659 --> 00:34:52,520
your Testament you can have of course

00:34:50,899 --> 00:34:55,820
also use it for some evil monkey

00:34:52,520 --> 00:35:00,890
patching but maybe you shouldn't

00:34:55,820 --> 00:35:02,330
something like you might set an external

00:35:00,890 --> 00:35:05,420
function just for the scope of your

00:35:02,330 --> 00:35:08,450
function that wants to wrap it there are

00:35:05,420 --> 00:35:10,220
better ways to do this but you can do

00:35:08,450 --> 00:35:11,480
this if you want and if you want to be

00:35:10,220 --> 00:35:13,280
evil enough

00:35:11,480 --> 00:35:19,220
if people see you doing this they will

00:35:13,280 --> 00:35:20,300
be mad at you so don't because of course

00:35:19,220 --> 00:35:22,060
with great power comes great

00:35:20,300 --> 00:35:25,850
responsibility

00:35:22,060 --> 00:35:28,280
so in summary as we said before packages

00:35:25,850 --> 00:35:31,340
are for finding things include you know

00:35:28,280 --> 00:35:33,290
packages set global variables you can

00:35:31,340 --> 00:35:35,840
control them with namespaces and package

00:35:33,290 --> 00:35:38,810
keyword and we refer to them with the

00:35:35,840 --> 00:35:42,530
our constructor which builds that

00:35:38,810 --> 00:35:46,040
lexical alias or I should have put or

00:35:42,530 --> 00:35:48,740
the fully qualified name scopes are for

00:35:46,040 --> 00:35:51,260
hiding things they have a lexical scope

00:35:48,740 --> 00:35:55,280
they're bound to blocks we declare them

00:35:51,260 --> 00:35:57,230
with mine so at this point I'll take

00:35:55,280 --> 00:36:04,270
some questions any questions that people

00:35:57,230 --> 00:36:04,270
have no I've confused yet okay

00:36:10,360 --> 00:36:28,990
right sure no can't be done I don't

00:36:25,930 --> 00:36:31,540
think it can be done I mean no no sane

00:36:28,990 --> 00:36:33,460
way to do that I can think of maybe some

00:36:31,540 --> 00:36:34,960
really really insane ways but they

00:36:33,460 --> 00:36:41,890
involve going down into the sea layer

00:36:34,960 --> 00:36:44,440
and you don't want to do that yes so

00:36:41,890 --> 00:36:47,410
this is why I say even lexical aren't

00:36:44,440 --> 00:36:49,360
totally safe there are sea level ways to

00:36:47,410 --> 00:36:51,370
get into the Perl interpreter and say

00:36:49,360 --> 00:36:53,110
all right I see that you've got a scope

00:36:51,370 --> 00:36:55,150
here please tell me the things that you

00:36:53,110 --> 00:36:59,710
have in the scope yes you can

00:36:55,150 --> 00:37:03,730
Perl is very unsafe from a type safety

00:36:59,710 --> 00:37:06,940
standpoint but other than truly evil

00:37:03,730 --> 00:37:12,160
hacking like using pad walker lexical

00:37:06,940 --> 00:37:23,200
czar pretty well contained I don't say

00:37:12,160 --> 00:37:27,480
you there are there are two or three of

00:37:23,200 --> 00:37:27,480
them aren't there uh Graham

00:37:46,099 --> 00:37:52,339
but I don't recommend you do that in the

00:37:48,470 --> 00:37:53,569
course of normal action no the most I

00:37:52,339 --> 00:37:55,279
would do that is if there's some really

00:37:53,569 --> 00:37:56,930
horrible debugging that you need to get

00:37:55,279 --> 00:37:58,460
into and for some reason you just

00:37:56,930 --> 00:38:01,700
literally can't put a print statement

00:37:58,460 --> 00:38:06,979
into it somewhere but try to do it that

00:38:01,700 --> 00:38:10,999
way if you can anyone else do I have a

00:38:06,979 --> 00:38:15,410
couple more minutes or I what's what was

00:38:10,999 --> 00:38:18,170
my time all right

00:38:15,410 --> 00:38:19,549
I have just a couple more because I

00:38:18,170 --> 00:38:20,869
wasn't sure exactly how long this was

00:38:19,549 --> 00:38:23,779
going to go and I wanted to get through

00:38:20,869 --> 00:38:26,210
those first there is one more key word

00:38:23,779 --> 00:38:29,259
for making variables and it came in in

00:38:26,210 --> 00:38:31,789
Perl 510 and that's the state keyword

00:38:29,259 --> 00:38:34,549
all right so what's the state keyword

00:38:31,789 --> 00:38:36,890
well it doesn't have any new behavior

00:38:34,549 --> 00:38:40,970
all the behavior that it has you already

00:38:36,890 --> 00:38:45,650
know let's make a function with a

00:38:40,970 --> 00:38:48,049
counter my count equals zero and we're

00:38:45,650 --> 00:38:49,940
going to every time we run the count the

00:38:48,049 --> 00:38:53,630
say count we're going to say how many

00:38:49,940 --> 00:38:54,910
times say count has run now that code

00:38:53,630 --> 00:38:57,410
going to actually work

00:38:54,910 --> 00:39:00,619
no this code doesn't work because every

00:38:57,410 --> 00:39:02,869
time you start it you set count to zero

00:39:00,619 --> 00:39:05,359
so every time it runs it's going to say

00:39:02,869 --> 00:39:08,390
well we've run this one time that's not

00:39:05,359 --> 00:39:11,049
what you want all right well let's put

00:39:08,390 --> 00:39:13,849
the counter outside of the function so

00:39:11,049 --> 00:39:16,549
this function has been called I times

00:39:13,849 --> 00:39:21,410
and you know we're incrementing it here

00:39:16,549 --> 00:39:23,299
so will this function work yeah except

00:39:21,410 --> 00:39:26,059
if someone else increments your variable

00:39:23,299 --> 00:39:28,789
and now you know it it works but it's

00:39:26,059 --> 00:39:33,410
unreliable okay

00:39:28,789 --> 00:39:36,380
great so now we wrap it in a block so

00:39:33,410 --> 00:39:40,700
we've got a lexically scoped counter

00:39:36,380 --> 00:39:45,950
variable here and only my function can

00:39:40,700 --> 00:39:48,289
see it so does this now work yeah but

00:39:45,950 --> 00:39:51,349
it's a lot to type I want to type that

00:39:48,289 --> 00:39:53,239
every time I you know have my personal

00:39:51,349 --> 00:39:54,710
idiosyncrasies like I like having my

00:39:53,239 --> 00:39:58,219
functions declared on the left side of

00:39:54,710 --> 00:39:59,750
the page now these are indented Oh CDs

00:39:58,219 --> 00:40:02,330
are fighting each other

00:39:59,750 --> 00:40:05,750
and that's what the state keyword does

00:40:02,330 --> 00:40:08,210
the state keyword builds an outer scope

00:40:05,750 --> 00:40:11,150
around your function that it declares

00:40:08,210 --> 00:40:15,140
your variable in and it only runs the

00:40:11,150 --> 00:40:21,470
initializer the first time so if you

00:40:15,140 --> 00:40:24,980
think of it as this it is literally the

00:40:21,470 --> 00:40:27,230
same thing and even a few weirdness is

00:40:24,980 --> 00:40:28,550
that that might cause they are literally

00:40:27,230 --> 00:40:32,090
the same thing I want to tell you what

00:40:28,550 --> 00:40:38,810
those are they this code is exactly that

00:40:32,090 --> 00:40:41,240
code that makes sense so that one is new

00:40:38,810 --> 00:40:44,170
as of 510 or 510 one I can't remember

00:40:41,240 --> 00:40:49,550
exactly which you have to use feature

00:40:44,170 --> 00:40:51,260
state or you know use parole 510 or

00:40:49,550 --> 00:40:53,660
something at the top of your script to

00:40:51,260 --> 00:40:54,950
get that because the name you know

00:40:53,660 --> 00:40:56,180
people were worried that the state name

00:40:54,950 --> 00:40:59,030
gotcha

00:40:56,180 --> 00:41:00,170
it would be our to use and they didn't

00:40:59,030 --> 00:41:04,339
want to break you so you have to enable

00:41:00,170 --> 00:41:05,960
that feature lets in pearl since 510 mo

00:41:04,339 --> 00:41:08,240
delicious enabled if I default for you

00:41:05,960 --> 00:41:10,010
if you're already using mojo I don't

00:41:08,240 --> 00:41:14,540
think any of the other ones declare by

00:41:10,010 --> 00:41:17,950
default for you who a move sir probably

00:41:14,540 --> 00:41:17,950
most of you are using five Tannehill

00:41:20,680 --> 00:41:25,730
that's not really a change it's just a

00:41:23,619 --> 00:41:28,130
declarations you don't have to add the

00:41:25,730 --> 00:41:31,190
scope there for yourself but it is just

00:41:28,130 --> 00:41:35,930
am I in the outer scope of the function

00:41:31,190 --> 00:41:39,080
so I wouldn't call it a change I guess

00:41:35,930 --> 00:41:44,810
as far as like scoping utility yeah

00:41:39,080 --> 00:41:46,010
probably I don't know does anyone else

00:41:44,810 --> 00:41:48,530
have a comment on that

00:41:46,010 --> 00:41:50,830
I can't think of any other major scope

00:41:48,530 --> 00:41:50,830
in chain

00:41:52,369 --> 00:42:01,880
ah that's a good question I think there

00:41:57,740 --> 00:42:04,220
is an oddity about declaring ashes state

00:42:01,880 --> 00:42:05,450
hash is weird or something I don't know

00:42:04,220 --> 00:42:07,910
it'll warn you if there's a problem

00:42:05,450 --> 00:42:13,299
there the back of my mind I seem to

00:42:07,910 --> 00:42:13,299
recall there being some odd thing if

00:42:15,220 --> 00:42:19,569
well yeah I mean that the keyword is

00:42:17,420 --> 00:42:25,069
supposed to trigger that in your mind of

00:42:19,569 --> 00:42:27,519
of that's what it look behaving like it

00:42:25,069 --> 00:42:30,440
will keep the value between college

00:42:27,519 --> 00:42:32,509
right that's that's the important

00:42:30,440 --> 00:42:34,579
behavior is that the initializer here

00:42:32,509 --> 00:42:37,519
won't be called again now if you set

00:42:34,579 --> 00:42:39,349
count if your next line said you know if

00:42:37,519 --> 00:42:42,440
it's so state count equals one and the

00:42:39,349 --> 00:42:43,910
next lines that count equal to that will

00:42:42,440 --> 00:42:46,609
be run every time it's only this

00:42:43,910 --> 00:42:49,849
initializer line that gets excluded on

00:42:46,609 --> 00:42:52,640
subsequent runs so be sure you have that

00:42:49,849 --> 00:42:54,950
in your mind that one line is the line

00:42:52,640 --> 00:42:59,089
that is considered to be in the

00:42:54,950 --> 00:43:02,390
enclosing scope and that's all I've got

00:42:59,089 --> 00:43:12,079
so hopefully you've learned something

00:43:02,390 --> 00:43:13,609
and again the slides are on my github I

00:43:12,079 --> 00:43:15,380
don't want you to memorize any of what

00:43:13,609 --> 00:43:18,519
you've seen as long as you know that you

00:43:15,380 --> 00:43:18,519

YouTube URL: https://www.youtube.com/watch?v=-DWHROn2Tz0


