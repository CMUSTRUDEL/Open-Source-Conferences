Title: Bruce Gray - "Your Perl 5 Brain, on Perl 6"
Publication date: 2017-06-22
Playlist: TPC 2017 in DC
Description: 
	In which I detail the Perl 6 elements that have most changed my Perl 5 coding, and share the Perl 5 techniques I have adopted.


I eat, sleep, live, and breathe Perl!

Consultant and Contract Programmer Frequent PerlMongers speaker Dedicated Shakespeare theater-goer Armchair Mathematician Author of Blue_Tiger, a tool for modernizing Perl.

36 years coding 22 years Perl 16 years Married 15 YAPCs 7 Hackathons 3 PerlWhirls Perl interests: Refactoring, Perl Idioms / Micropatterns, RosettaCode, and Perl 6.
Captions: 
	00:00:02,899 --> 00:00:14,599
okay I have 235 pardon yes

00:00:11,639 --> 00:00:18,390
if anybody can't hear me at any point

00:00:14,599 --> 00:00:21,090
please let me know I work at home and my

00:00:18,390 --> 00:00:24,050
volume level keeps dropping so I want

00:00:21,090 --> 00:00:24,050
everybody to hear me

00:00:32,130 --> 00:00:37,800
this is Perl 6 changes to my profile

00:00:44,640 --> 00:00:57,820
yes yes I

00:00:48,180 --> 00:01:03,129
Irie factored exactly please do grab a

00:00:57,820 --> 00:01:08,530
copy of the slides ok I am Bruce gray

00:01:03,129 --> 00:01:11,729
util online UTI L and I am a member of

00:01:08,530 --> 00:01:14,890
Matt trout's hallway plus plus group

00:01:11,729 --> 00:01:16,090
which means that I'm generally always

00:01:14,890 --> 00:01:19,930
interrupts 'fl I'm talking to somebody

00:01:16,090 --> 00:01:21,790
else just step into the conversation we

00:01:19,930 --> 00:01:23,200
want to be hospitable the hallway track

00:01:21,790 --> 00:01:25,570
is the most important track at these

00:01:23,200 --> 00:01:27,070
conferences I want all your questions

00:01:25,570 --> 00:01:30,400
about the stuff that I'm going to cover

00:01:27,070 --> 00:01:33,880
here either here or in the hallway or an

00:01:30,400 --> 00:01:38,050
email but I am going to hold till till

00:01:33,880 --> 00:01:40,860
the end of the talk for questions I do a

00:01:38,050 --> 00:01:45,250
lot of work on Perl 6 on rosetta code

00:01:40,860 --> 00:01:49,840
and in the last six months I've been

00:01:45,250 --> 00:01:55,900
active on code fights arcade in Perl 5

00:01:49,840 --> 00:01:58,330
mode really to prep for this talk I've

00:01:55,900 --> 00:02:00,880
written a Perl 5 to Perl 6 translator

00:01:58,330 --> 00:02:06,490
called blue tiger doctor 4 is also

00:02:00,880 --> 00:02:11,440
written one is Jeff are you here ok well

00:02:06,490 --> 00:02:13,360
they're they're both real good and most

00:02:11,440 --> 00:02:16,659
importantly to this talk for maybe two

00:02:13,360 --> 00:02:18,610
years at least once a week I have

00:02:16,659 --> 00:02:21,280
written at least something in Perl 5 and

00:02:18,610 --> 00:02:22,720
at least something in Perl 6 and I've

00:02:21,280 --> 00:02:24,220
noticed that the Perl 6 work has

00:02:22,720 --> 00:02:26,290
affected my Perl 5 thinking and I

00:02:24,220 --> 00:02:28,540
thought you might be interested in how

00:02:26,290 --> 00:02:31,689
it affects me and possibly how it might

00:02:28,540 --> 00:02:34,930
affect you and I'll cover a little bit

00:02:31,689 --> 00:02:39,310
of the Perl 6 stuff just to whet your

00:02:34,930 --> 00:02:42,980
appetite first the little things will

00:02:39,310 --> 00:02:46,099
get out of way quickly I am addicted to

00:02:42,980 --> 00:02:48,470
a which is built into coal six I cringe

00:02:46,099 --> 00:02:53,959
when I see a trailer new lying symbol in

00:02:48,470 --> 00:02:55,849
a string path so now in Perl 5 is my

00:02:53,959 --> 00:02:57,769
standard prologue or if I'm an

00:02:55,849 --> 00:03:01,790
environment that supports it

00:02:57,769 --> 00:03:04,700
modern Perl if you say use five point

00:03:01,790 --> 00:03:08,209
zero one zero you will get say and a

00:03:04,700 --> 00:03:10,640
couple of other great things qw i used

00:03:08,209 --> 00:03:14,090
to strongly advocate that the proper

00:03:10,640 --> 00:03:16,549
form of quote words is qw open paren

00:03:14,090 --> 00:03:19,370
whatever closed paren and unfortunately

00:03:16,549 --> 00:03:22,099
in perl 6 there is magic involved

00:03:19,370 --> 00:03:23,599
there's if you're using parentheses with

00:03:22,099 --> 00:03:25,190
something immediately to the left it

00:03:23,599 --> 00:03:27,290
means a function call it always means a

00:03:25,190 --> 00:03:31,010
function call it will try and call that

00:03:27,290 --> 00:03:33,640
whatever function is named QW so it's

00:03:31,010 --> 00:03:37,430
the worst possible choice in Perl 6 and

00:03:33,640 --> 00:03:40,760
in Perl 6 you used quote words a lot

00:03:37,430 --> 00:03:43,640
more and they have a shortcut Fortin pro

00:03:40,760 --> 00:03:50,239
6 that's just angle brackets so I have

00:03:43,640 --> 00:03:55,130
started using QW angle brackets as it as

00:03:50,239 --> 00:03:58,040
I do their floor and ceiling are both

00:03:55,130 --> 00:04:01,459
numeric methods they're built into Perl

00:03:58,040 --> 00:04:03,349
6 and I have the bad habit of sort of

00:04:01,459 --> 00:04:05,720
you know writings a little math on the

00:04:03,349 --> 00:04:10,880
fly and I broke that so I always use

00:04:05,720 --> 00:04:13,849
POSIX whenever I need C LeFleur if I was

00:04:10,880 --> 00:04:15,680
not already sold on loose Perl 6 would

00:04:13,849 --> 00:04:17,479
seal the deal they're very similar

00:04:15,680 --> 00:04:19,099
object models everybody who's doing

00:04:17,479 --> 00:04:23,930
hello in profile should be using noose

00:04:19,099 --> 00:04:29,630
the tough line are the three coercion

00:04:23,930 --> 00:04:34,490
operators in Perl 6 that coerces to

00:04:29,630 --> 00:04:37,669
boolean to numeric and to string we

00:04:34,490 --> 00:04:40,970
don't have those operators in Perl 5 but

00:04:37,669 --> 00:04:43,699
we have equivalent idioms which is

00:04:40,970 --> 00:04:45,050
bang-bang which if you haven't seen it

00:04:43,699 --> 00:04:48,080
you just think about it for a second

00:04:45,050 --> 00:04:51,500
not not will force anything on the on

00:04:48,080 --> 00:04:54,800
the side to be boolean context it has to

00:04:51,500 --> 00:04:57,069
and it will have a seg truth value

00:04:54,800 --> 00:04:59,720
zero plus will force numeric and

00:04:57,069 --> 00:05:03,680
catenate into an empty string will force

00:04:59,720 --> 00:05:10,520
string more on that later so those are

00:05:03,680 --> 00:05:13,849
the trivial changes Perl 6 has a method

00:05:10,520 --> 00:05:16,610
called dot end on arrays you say

00:05:13,849 --> 00:05:21,199
whatever array dot end it will give you

00:05:16,610 --> 00:05:24,490
the the index of the last element of the

00:05:21,199 --> 00:05:30,770
array what you would expect

00:05:24,490 --> 00:05:34,789
so in Perl 6 I could do this go from 0

00:05:30,770 --> 00:05:42,710
to whatever the end point is looping

00:05:34,789 --> 00:05:45,860
over the customers array in Perl 5 the

00:05:42,710 --> 00:05:49,090
equivalent to dot end is dollar up to

00:05:45,860 --> 00:05:52,550
Thorpe which I don't know anymore to say

00:05:49,090 --> 00:05:56,419
hash tag will hash mean something in

00:05:52,550 --> 00:05:58,819
Perl get out anyway the pound sign no no

00:05:56,419 --> 00:06:01,729
now we've got Europeans involved pound

00:05:58,819 --> 00:06:04,310
means something anyway a tooth or dollar

00:06:01,729 --> 00:06:09,020
sign dr. Thorpe that is how you say the

00:06:04,310 --> 00:06:15,800
last element number of customers that is

00:06:09,020 --> 00:06:18,409
the syntax for that I told you I was

00:06:15,800 --> 00:06:20,690
active on code fights in the arcade I've

00:06:18,409 --> 00:06:24,110
looked at pretty much every Perl

00:06:20,690 --> 00:06:26,210
solution to every Perl problem that I

00:06:24,110 --> 00:06:28,310
have solved which is closer to 200 now

00:06:26,210 --> 00:06:31,490
and I can tell you that I am the only

00:06:28,310 --> 00:06:33,740
person on code fights that uses that

00:06:31,490 --> 00:06:35,930
syntax even though that's exactly what

00:06:33,740 --> 00:06:41,389
is for everybody else

00:06:35,930 --> 00:06:45,349
they do that which gives you the right

00:06:41,389 --> 00:06:48,219
answer but it is conceptually wrong the

00:06:45,349 --> 00:06:51,409
number of elements in the array minus 1

00:06:48,219 --> 00:06:53,779
and if you arts if you get into Perl 6

00:06:51,409 --> 00:06:56,150
when we have shaped arrays that don't

00:06:53,779 --> 00:06:57,560
necessarily have to have the same start

00:06:56,150 --> 00:06:59,090
point end point that's going to throw

00:06:57,560 --> 00:07:02,419
you and it's just wrong

00:06:59,090 --> 00:07:05,980
even though it works and it's right so

00:07:02,419 --> 00:07:08,800
it bugs me and in Perl 6

00:07:05,980 --> 00:07:12,460
we have this thing I call it cat ears

00:07:08,800 --> 00:07:14,830
where you can put the arrows on either

00:07:12,460 --> 00:07:18,550
side of a range operator and it means

00:07:14,830 --> 00:07:22,420
omit the range point I'm very spoiled by

00:07:18,550 --> 00:07:24,970
this in Perl in Perl 6 I miss it in Perl

00:07:22,420 --> 00:07:28,290
5 and it makes me even more sensitive to

00:07:24,970 --> 00:07:32,080
this issue of number of elements minus 1

00:07:28,290 --> 00:07:36,940
so for example in Perl 6 I could do this

00:07:32,080 --> 00:07:40,690
and it would give me B through Y now I

00:07:36,940 --> 00:07:42,880
could just put B and Y up there as the

00:07:40,690 --> 00:07:45,100
constants but that's not relevant to

00:07:42,880 --> 00:07:47,470
what I'm trying to solve there I don't

00:07:45,100 --> 00:07:50,560
want B through why I want the whole

00:07:47,470 --> 00:07:54,520
alphabet and minus the endpoints that's

00:07:50,560 --> 00:07:57,070
what this says if I said B dot why I'd

00:07:54,520 --> 00:07:58,660
be invoking magic constants that aren't

00:07:57,070 --> 00:08:00,430
actually relevant to what I'm trying to

00:07:58,660 --> 00:08:02,610
accomplish they just coincidentally

00:08:00,430 --> 00:08:05,230
coincide

00:08:02,610 --> 00:08:07,180
maybe that's nitpicking but when you

00:08:05,230 --> 00:08:09,430
actually start using it and you can say

00:08:07,180 --> 00:08:14,800
what you mean versus what you almost

00:08:09,430 --> 00:08:18,280
mean it really feels different so also

00:08:14,800 --> 00:08:20,730
in Perl 6 if I wasn't going from A to Z

00:08:18,280 --> 00:08:23,260
minus 10 points but is going from

00:08:20,730 --> 00:08:26,200
covering a whole array except for the

00:08:23,260 --> 00:08:31,120
endpoints I go from 0 to end - the end

00:08:26,200 --> 00:08:33,220
point that's what the cat ears do and in

00:08:31,120 --> 00:08:36,040
Perl 5 if I wanted to do the same thing

00:08:33,220 --> 00:08:41,740
I would write it this way from 0 plus 1

00:08:36,040 --> 00:08:43,770
to the end of the array minus 1 if you

00:08:41,740 --> 00:08:48,370
don't know the dollar out tooth or

00:08:43,770 --> 00:08:52,210
syntax like everybody on code fights you

00:08:48,370 --> 00:08:53,650
end up writing that which will make your

00:08:52,210 --> 00:08:58,120
maintenance program or hunt you down

00:08:53,650 --> 00:09:02,470
someday why are you subtracting 2 you're

00:08:58,120 --> 00:09:06,190
not you're subtracting 1 and 1 and as a

00:09:02,470 --> 00:09:08,290
side note that third line I gave this

00:09:06,190 --> 00:09:11,620
talk at the Atlanta Pro mongers and they

00:09:08,290 --> 00:09:13,900
push back hard on that they said if I

00:09:11,620 --> 00:09:16,840
ever saw that in my code base I would

00:09:13,900 --> 00:09:19,660
look for what the programmer was smoking

00:09:16,840 --> 00:09:21,400
you do not embed 0 plus 1

00:09:19,660 --> 00:09:23,920
so I'm taking that under consideration

00:09:21,400 --> 00:09:27,580
but I actually would ride it as that

00:09:23,920 --> 00:09:35,410
third line myself just who's

00:09:27,580 --> 00:09:37,090
uncomfortable with that it's fine yep we

00:09:35,410 --> 00:09:40,140
care about the people we care about the

00:09:37,090 --> 00:09:44,200
people yeah

00:09:40,140 --> 00:09:46,840
okay so in that first pearl six example

00:09:44,200 --> 00:09:51,790
I wouldn't actually write it like that I

00:09:46,840 --> 00:09:54,430
wouldn't go from zero to the end point I

00:09:51,790 --> 00:09:59,140
would use the new method that we've got

00:09:54,430 --> 00:10:03,360
dot keys okay just like a key in pro

00:09:59,140 --> 00:10:07,120
five you have keys on hash keys ash name

00:10:03,360 --> 00:10:08,950
well we have that for arrays in Perl 5

00:10:07,120 --> 00:10:16,420
so I would write it like that

00:10:08,950 --> 00:10:20,770
actually there's even short away and I

00:10:16,420 --> 00:10:23,110
wish I could do it in Perl 5 so that's

00:10:20,770 --> 00:10:25,420
the right way in yellow and the way I

00:10:23,110 --> 00:10:27,630
don't like in red but the way I would

00:10:25,420 --> 00:10:31,020
really love to do it at the end there

00:10:27,630 --> 00:10:31,020
wouldn't that be better

00:10:32,760 --> 00:10:48,660
well you can actually do that in Perl 5

00:10:36,340 --> 00:10:51,910
but it's like what 524 526 am i no 512 0

00:10:48,660 --> 00:10:55,300
7 years ago I found this out last month

00:10:51,910 --> 00:10:59,530
that this works you don't even have to

00:10:55,300 --> 00:11:01,420
say you know use 5 no it just works it's

00:10:59,530 --> 00:11:04,330
not my fault that I missed it it was

00:11:01,420 --> 00:11:09,490
left out of the release Delta for 5.12

00:11:04,330 --> 00:11:14,950
and it wasn't documented until 10 months

00:11:09,490 --> 00:11:16,750
so I should have known we all should

00:11:14,950 --> 00:11:19,380
have known I mean everybody reads Perl

00:11:16,750 --> 00:11:19,380
Delta right

00:11:22,810 --> 00:11:33,170
yeah yeah so I'm not joking if you are

00:11:30,649 --> 00:11:35,180
not using keys when you need array

00:11:33,170 --> 00:11:42,350
indexes you should start this is just a

00:11:35,180 --> 00:11:43,970
no-brainer it's better coding no it's

00:11:42,350 --> 00:11:46,730
just the keys it doesn't give you the

00:11:43,970 --> 00:11:49,670
values it's just like if you've got

00:11:46,730 --> 00:11:52,430
three elements it'll be zero one two and

00:11:49,670 --> 00:11:55,220
you have to look up the you have to

00:11:52,430 --> 00:11:58,040
index into the array if you want to do

00:11:55,220 --> 00:12:02,899
better than that you have to see me

00:11:58,040 --> 00:12:04,370
later but there are reasons to do it and

00:12:02,899 --> 00:12:09,250
to not do it which is why didn't make a

00:12:04,370 --> 00:12:11,920
slide here okay so dollar octothorpe

00:12:09,250 --> 00:12:18,589
keys everybody got it

00:12:11,920 --> 00:12:21,170
moving on types and print six design has

00:12:18,589 --> 00:12:25,130
a lot to do with types and something

00:12:21,170 --> 00:12:27,860
called arity from the programmer

00:12:25,130 --> 00:12:32,149
perspective types are completely

00:12:27,860 --> 00:12:33,680
optional and are gradual in perl 6 so

00:12:32,149 --> 00:12:37,459
you can choose to use them and you can

00:12:33,680 --> 00:12:39,380
add them in gradually from the Perl 6

00:12:37,459 --> 00:12:42,410
view of it like the compilers view of it

00:12:39,380 --> 00:12:44,779
types are pervasive everything has it

00:12:42,410 --> 00:12:47,660
tight if you say dollar foo equals 42

00:12:44,779 --> 00:12:53,899
and you ask what is the type of dollar

00:12:47,660 --> 00:12:57,139
foo it will tell you it's an int so

00:12:53,899 --> 00:13:04,459
simple as that I can write this in Perl

00:12:57,139 --> 00:13:07,010
6 with no times or I can specify types

00:13:04,459 --> 00:13:11,839
for some or all of the variables that I

00:13:07,010 --> 00:13:15,670
declare or in my parameter list that - -

00:13:11,839 --> 00:13:23,450
bool is the return type of that

00:13:15,670 --> 00:13:26,720
subroutine what I have found is that

00:13:23,450 --> 00:13:32,480
I most often use it in my if I'm like

00:13:26,720 --> 00:13:37,070
translating Java into Perl 6 I don't use

00:13:32,480 --> 00:13:41,960
it much if I'm not except at the

00:13:37,070 --> 00:13:44,780
boundaries the edges your intrigue your

00:13:41,960 --> 00:13:47,600
exit what's essentially your API that's

00:13:44,780 --> 00:13:50,300
a great place to have error checking and

00:13:47,600 --> 00:13:52,240
automatic documentation it's not just

00:13:50,300 --> 00:13:57,680
it'll catch it if you try and pass that

00:13:52,240 --> 00:14:00,140
2.5 as the year somebody reading the

00:13:57,680 --> 00:14:01,790
code it's crystal clear what that's

00:14:00,140 --> 00:14:05,530
supposed to take and what it's going to

00:14:01,790 --> 00:14:09,790
return catches a lot of errors

00:14:05,530 --> 00:14:13,430
well back in Perl 5 I've found that a

00:14:09,790 --> 00:14:17,390
lot of those errors you can especially

00:14:13,430 --> 00:14:20,870
the important thing of you are silently

00:14:17,390 --> 00:14:28,400
ignoring any extra argument that your

00:14:20,870 --> 00:14:31,940
subroutines being given you can you can

00:14:28,400 --> 00:14:33,500
catch a lot of that just by checking the

00:14:31,940 --> 00:14:36,140
number of arguments and that will also

00:14:33,500 --> 00:14:38,180
catch a lot of times when you're

00:14:36,140 --> 00:14:44,110
expecting an array ref and you get an

00:14:38,180 --> 00:14:46,310
array or vice versa so that dye line

00:14:44,110 --> 00:14:51,400
that's the way to do it just check for

00:14:46,310 --> 00:14:51,400
how many things are in at underscore

00:14:52,450 --> 00:14:58,010
arity is the computer science word for a

00:14:55,550 --> 00:14:59,690
number of parameters that a subroutine

00:14:58,010 --> 00:15:05,300
supposed to get and you can introspect

00:14:59,690 --> 00:15:06,710
that in perl 6 you can ask the the

00:15:05,300 --> 00:15:11,180
subroutine object

00:15:06,710 --> 00:15:16,640
what is your era t-that died line is is

00:15:11,180 --> 00:15:20,320
in my fingers now it's automatic you can

00:15:16,640 --> 00:15:26,140
also accommodate multiple parameters

00:15:20,320 --> 00:15:26,140
optional parameters 0 parameters

00:15:26,930 --> 00:15:33,120
if you want to do more if you need to be

00:15:31,379 --> 00:15:35,220
checking types of things you're going to

00:15:33,120 --> 00:15:37,829
have to use something a little heavier

00:15:35,220 --> 00:15:39,269
I used to use params validate I still

00:15:37,829 --> 00:15:41,519
will on occasion there are some

00:15:39,269 --> 00:15:44,670
enhancements and extensions to that pram

00:15:41,519 --> 00:15:47,639
util is also very very popular if you

00:15:44,670 --> 00:15:50,180
have a shift style of passing parameters

00:15:47,639 --> 00:15:52,139
or absorbing aaalac arguments and

00:15:50,180 --> 00:15:54,389
subroutine signatures will not give you

00:15:52,139 --> 00:15:59,910
the types but it will let you do the

00:15:54,389 --> 00:16:03,720
stuff in line and as far as returning a

00:15:59,910 --> 00:16:07,050
type I often coerce the return type

00:16:03,720 --> 00:16:10,740
because I can't say - - arrow bool in

00:16:07,050 --> 00:16:12,269
Perl 5 but I can say return bangbang

00:16:10,740 --> 00:16:15,990
error code and that keeps me from

00:16:12,269 --> 00:16:17,879
leaking information my API says I'm

00:16:15,990 --> 00:16:21,980
going to return true or false from this

00:16:17,879 --> 00:16:25,370
function whether it succeeded or failed

00:16:21,980 --> 00:16:28,230
but internally I'm doing that by

00:16:25,370 --> 00:16:30,509
checking the error code for whether it's

00:16:28,230 --> 00:16:33,019
0 or not if I just said return error

00:16:30,509 --> 00:16:36,329
code I'm actually leaking information

00:16:33,019 --> 00:16:39,240
from the internals of my of my

00:16:36,329 --> 00:16:41,519
subroutine that people will start

00:16:39,240 --> 00:16:44,519
relying on whenever you leak outside

00:16:41,519 --> 00:16:46,709
your API somebody will start using that

00:16:44,519 --> 00:16:48,990
information improperly and then when you

00:16:46,709 --> 00:16:51,329
refactor or rejigged

00:16:48,990 --> 00:16:53,579
your subroutine and you're no longer

00:16:51,329 --> 00:16:55,769
leaking that information you will get

00:16:53,579 --> 00:16:58,680
massive complaints and they'll be very

00:16:55,769 --> 00:17:00,720
incensed and it's one of the Murphy's

00:16:58,680 --> 00:17:06,539
laws is guaranteed to happen if you leak

00:17:00,720 --> 00:17:08,880
out of your API so I recommend always

00:17:06,539 --> 00:17:14,189
checking arity and consider using

00:17:08,880 --> 00:17:18,480
coercion for your your return types I've

00:17:14,189 --> 00:17:21,630
started doing it okay functional I'm

00:17:18,480 --> 00:17:24,089
going to trip up here a little bit pro

00:17:21,630 --> 00:17:26,339
six incorporates a lot of ideas from

00:17:24,089 --> 00:17:29,280
functional style of coding what I found

00:17:26,339 --> 00:17:30,990
is I cannot speak well about what

00:17:29,280 --> 00:17:34,169
functional is so if you don't know

00:17:30,990 --> 00:17:37,080
already you should ask somebody else or

00:17:34,169 --> 00:17:38,370
you should look it up in Wikipedia

00:17:37,080 --> 00:17:40,440
because

00:17:38,370 --> 00:17:44,070
as when I try and talk about it I

00:17:40,440 --> 00:17:45,660
dislike I know Abigail for years I tried

00:17:44,070 --> 00:17:48,720
to introduce Abigail to somebody a

00:17:45,660 --> 00:17:50,700
couple years ago and I was saying things

00:17:48,720 --> 00:17:54,660
that just weren't true Abigail was dead

00:17:50,700 --> 00:17:58,530
you there no no now you're thinking it

00:17:54,660 --> 00:18:00,720
Illya no it's a bank like oh my god

00:17:58,530 --> 00:18:02,280
that's really how I am but I'm talking

00:18:00,720 --> 00:18:05,870
about functional I really do know this

00:18:02,280 --> 00:18:08,970
stuff I really can't talk about it but

00:18:05,870 --> 00:18:11,910
like Haskell that's the best I can do is

00:18:08,970 --> 00:18:15,690
by example in Haskell constants aren't

00:18:11,910 --> 00:18:19,550
variables don't yeah that's how I talk

00:18:15,690 --> 00:18:19,550
about it let's let me just stick to

00:18:19,850 --> 00:18:26,400
don't reuse variables you want to reduce

00:18:23,330 --> 00:18:28,530
mutability you want to so the less you

00:18:26,400 --> 00:18:30,330
can change state the easier it is to

00:18:28,530 --> 00:18:38,309
think about coding it's easier for the

00:18:30,330 --> 00:18:42,360
compiler to and when there are concepts

00:18:38,309 --> 00:18:46,950
that can be generalized you create a

00:18:42,360 --> 00:18:50,490
subroutine that allows you to pass in

00:18:46,950 --> 00:18:52,350
first the specification of the

00:18:50,490 --> 00:18:55,050
generalization like grep

00:18:52,350 --> 00:18:57,210
grep is a general idea give me the

00:18:55,050 --> 00:18:59,610
things that match a certain criteria the

00:18:57,210 --> 00:19:01,740
first thing you pass degraph is a code

00:18:59,610 --> 00:19:04,080
block that tells you what the criteria

00:19:01,740 --> 00:19:09,740
is this is a functional concept map and

00:19:04,080 --> 00:19:14,790
grep come out of the functional world so

00:19:09,740 --> 00:19:18,830
in this code example costs array and

00:19:14,790 --> 00:19:21,780
markups array or parallel arrays okay

00:19:18,830 --> 00:19:25,070
take 30 seconds to try and understand

00:19:21,780 --> 00:19:25,070
this code maybe spot a bug

00:19:26,090 --> 00:19:31,570
oh please

00:19:56,170 --> 00:19:59,170
okay

00:20:00,950 --> 00:20:11,870
that's one that's just the bug and note

00:20:06,740 --> 00:20:13,940
that either you saw that bug or at least

00:20:11,870 --> 00:20:17,600
you had to read through the line to try

00:20:13,940 --> 00:20:19,760
and find the bug or you've realized you

00:20:17,600 --> 00:20:22,330
should have read through the line to

00:20:19,760 --> 00:20:22,330
find the bug

00:20:22,660 --> 00:20:27,800
let's move past the parameter handling

00:20:25,010 --> 00:20:30,470
start stuff at the beginning there and

00:20:27,800 --> 00:20:32,120
just focus on the important stuff

00:20:30,470 --> 00:20:43,640
what are we returning the max and the

00:20:32,120 --> 00:20:45,350
min of it's the maximum of the cost

00:20:43,640 --> 00:20:48,770
after it's marked up so we'll call that

00:20:45,350 --> 00:20:51,920
the price so the maximum of the price is

00:20:48,770 --> 00:20:54,260
the minimum of the costs the total of

00:20:51,920 --> 00:20:56,030
the prices and an array of the prices

00:20:54,260 --> 00:21:01,120
and that's not a bug that's how that's

00:20:56,030 --> 00:21:01,120
designed that's what the caller's want

00:21:06,100 --> 00:21:12,740
reading the code you would either think

00:21:09,560 --> 00:21:15,910
there's a bug there or it would take you

00:21:12,740 --> 00:21:21,350
a while to figure out what I just said

00:21:15,910 --> 00:21:23,800
hopefully it's documented part of the

00:21:21,350 --> 00:21:26,840
problem is that cost is being reused

00:21:23,800 --> 00:21:27,880
after the original value is no longer

00:21:26,840 --> 00:21:31,370
needed

00:21:27,880 --> 00:21:34,870
now I come I came up in see where you

00:21:31,370 --> 00:21:37,280
don't waste a perfectly good variable

00:21:34,870 --> 00:21:47,900
but this is a wasted opportunity for

00:21:37,280 --> 00:21:50,740
clarity if we make price a variable now

00:21:47,900 --> 00:21:55,550
cost does not mutate within the loop and

00:21:50,740 --> 00:22:00,740
extracting what we want to extract from

00:21:55,550 --> 00:22:04,040
the loop is much much easier so this is

00:22:00,740 --> 00:22:09,590
what I get after I extract max min some

00:22:04,040 --> 00:22:13,930
are all part of list util and now you

00:22:09,590 --> 00:22:16,130
can clearly see that cost and markup are

00:22:13,930 --> 00:22:21,800
parallel arrays because we're handling

00:22:16,130 --> 00:22:24,440
them in the same line and if you look

00:22:21,800 --> 00:22:26,870
look closely you'll see that that for

00:22:24,440 --> 00:22:30,190
loop has been reduced to something that

00:22:26,870 --> 00:22:30,190
we can think of as a map

00:22:33,240 --> 00:22:38,669
that's a ton better than the original

00:22:35,640 --> 00:22:41,190
code except some of you might be

00:22:38,669 --> 00:22:43,490
thinking but this version is so

00:22:41,190 --> 00:22:45,840
inefficient

00:22:43,490 --> 00:22:52,260
this version passes through the data

00:22:45,840 --> 00:22:57,840
four times right the original for loop

00:22:52,260 --> 00:23:00,350
is so much faster but as is famously

00:22:57,840 --> 00:23:00,350
shouted

00:23:05,450 --> 00:23:10,890
but it is faster for the programmer and

00:23:08,330 --> 00:23:14,670
it's a lot faster for the maintenance

00:23:10,890 --> 00:23:17,880
programmer someday to understand that's

00:23:14,670 --> 00:23:22,380
the more important perspective but if

00:23:17,880 --> 00:23:26,310
you are efficiency conscious maybe you

00:23:22,380 --> 00:23:29,100
really have huge amount of data the

00:23:26,310 --> 00:23:33,090
shorter version is probably faster

00:23:29,100 --> 00:23:38,030
because list util is written in excess

00:23:33,090 --> 00:23:40,170
and it ships with your version of Perl

00:23:38,030 --> 00:23:43,140
so it's already there

00:23:40,170 --> 00:23:44,670
there's no excuse to not use that even

00:23:43,140 --> 00:23:47,460
if you're in an environment where you

00:23:44,670 --> 00:23:52,680
don't use Sipan modules it comes with

00:23:47,460 --> 00:23:56,880
Perl now if you think I skipped some

00:23:52,680 --> 00:23:58,110
steps in my refactoring I once would

00:23:56,880 --> 00:23:59,760
have thought the same thing but it

00:23:58,110 --> 00:24:04,110
really is the way I think I did that

00:23:59,760 --> 00:24:06,540
jump all in one one big leap in my head

00:24:04,110 --> 00:24:11,280
here's a clip peek at some of the Perl 6

00:24:06,540 --> 00:24:14,460
that shaped that mindset this is how I

00:24:11,280 --> 00:24:18,150
would have written that in Perl 6 okay

00:24:14,460 --> 00:24:20,370
passing in two arrays you can do that in

00:24:18,150 --> 00:24:23,850
Perl 6 you don't have to pass in array

00:24:20,370 --> 00:24:24,840
refs that keep arrays distinct I checked

00:24:23,850 --> 00:24:31,200
to make sure that they're the same size

00:24:24,840 --> 00:24:32,910
I'm using the Z operator to give me one

00:24:31,200 --> 00:24:34,530
from cost one from markup second from

00:24:32,910 --> 00:24:38,580
cause second from markup third from cost

00:24:34,530 --> 00:24:40,590
third from markup and then by using $2

00:24:38,580 --> 00:24:42,780
carat variables that are called

00:24:40,590 --> 00:24:44,580
placeholder variables inside the map I

00:24:42,780 --> 00:24:48,330
automatically turn the map into

00:24:44,580 --> 00:24:51,390
expecting two things at a time it maps

00:24:48,330 --> 00:24:53,400
into an array of prices and it's that

00:24:51,390 --> 00:24:55,410
last line is the same except I don't

00:24:53,400 --> 00:24:57,930
have to return with a backslash on

00:24:55,410 --> 00:25:01,290
prices I can just return the array it

00:24:57,930 --> 00:25:03,620
will keep it intact well I wouldn't

00:25:01,290 --> 00:25:08,630
really write it like that I use the

00:25:03,620 --> 00:25:13,190
method forms of maximum sum

00:25:08,630 --> 00:25:19,390
well the Z can you can put an operator

00:25:13,190 --> 00:25:24,140
with the Z so I just do that really well

00:25:19,390 --> 00:25:26,810
if I use Hyper with the arrows pointing

00:25:24,140 --> 00:25:28,490
inward that guarantees that the sizes of

00:25:26,810 --> 00:25:30,290
the two things on either side will be

00:25:28,490 --> 00:25:31,850
the same and it will Gayle at me if it's

00:25:30,290 --> 00:25:33,650
not so I can take away that die if

00:25:31,850 --> 00:25:37,690
they're not the same size that's how I'd

00:25:33,650 --> 00:25:37,690
write it but that that's another show

00:25:44,230 --> 00:25:50,210
that's my summary of functional

00:25:47,360 --> 00:25:55,850
programming so far as it applies to Perl

00:25:50,210 --> 00:26:01,490
5 and this talk but not done new code

00:25:55,850 --> 00:26:05,330
example this subroutine takes no

00:26:01,490 --> 00:26:09,050
parameters this Perl 5 it scans the

00:26:05,330 --> 00:26:18,260
global customer array to try and find

00:26:09,050 --> 00:26:21,650
out are any of them profitable now let's

00:26:18,260 --> 00:26:25,400
focus on the important parts we've got a

00:26:21,650 --> 00:26:28,340
flag variable called found we loop

00:26:25,400 --> 00:26:30,020
through we set it to true if we find

00:26:28,340 --> 00:26:33,770
what we're looking for and then we

00:26:30,020 --> 00:26:35,510
return the state of a found and it

00:26:33,770 --> 00:26:37,040
always goes through every customer

00:26:35,510 --> 00:26:42,230
that's not efficient what if the very

00:26:37,040 --> 00:26:44,780
first customers was profitable I mean if

00:26:42,230 --> 00:26:48,110
I was going to do it that way I might as

00:26:44,780 --> 00:26:52,310
well write it like that that first

00:26:48,110 --> 00:26:53,660
version is just a long form of grep so I

00:26:52,310 --> 00:26:55,520
might as well write it as grep now the

00:26:53,660 --> 00:26:58,340
bang-bang well I already covered that

00:26:55,520 --> 00:27:02,930
remember you might not know that in

00:26:58,340 --> 00:27:05,120
scalar context grep doesn't return all

00:27:02,930 --> 00:27:06,860
the things that's found it returns to

00:27:05,120 --> 00:27:09,110
the count of the things that found so

00:27:06,860 --> 00:27:12,130
I'm looking for did it return 0 or did

00:27:09,110 --> 00:27:12,130
it return more than 0

00:27:19,400 --> 00:27:26,110
since we're in a subroutine whoops

00:27:34,679 --> 00:27:41,410
okay so we can do better than that we

00:27:38,350 --> 00:27:43,720
can have an early return so if we found

00:27:41,410 --> 00:27:47,140
what we're looking for we will not only

00:27:43,720 --> 00:27:51,010
set the flag we will hit last and jump

00:27:47,140 --> 00:27:55,150
out of the loop much more efficient

00:27:51,010 --> 00:27:57,390
little more code since this is in a

00:27:55,150 --> 00:28:05,200
subroutine we can actually refactor it

00:27:57,390 --> 00:28:10,059
with return not much better efficiency

00:28:05,200 --> 00:28:12,429
but certainly more concise but both of

00:28:10,059 --> 00:28:16,750
those forms I watch for those now all

00:28:12,429 --> 00:28:19,030
the time that that last form and the

00:28:16,750 --> 00:28:22,059
return the early return form they're

00:28:19,030 --> 00:28:23,650
both just the long form like we had a

00:28:22,059 --> 00:28:26,500
long form of grep before these are the

00:28:23,650 --> 00:28:32,620
long form of first-first is a functional

00:28:26,500 --> 00:28:34,990
concept and in Perl 5 it is also part of

00:28:32,620 --> 00:28:39,580
list util you have it on your with your

00:28:34,990 --> 00:28:41,980
Perl and like grep or map you give it a

00:28:39,580 --> 00:28:43,780
code block of what you're looking for I

00:28:41,980 --> 00:28:47,260
guess like grant give it a code block

00:28:43,780 --> 00:28:52,120
what you're looking for and it will

00:28:47,260 --> 00:28:54,460
return the first one that it found now I

00:28:52,120 --> 00:28:56,410
have the habit of putting defined in

00:28:54,460 --> 00:28:58,120
front of it because sometimes I'm not

00:28:56,410 --> 00:29:00,340
looking through customers sometimes I'm

00:28:58,120 --> 00:29:02,650
looking through numbers and if that

00:29:00,340 --> 00:29:05,890
number was zero then even though it

00:29:02,650 --> 00:29:07,300
found it it would return the zero so if

00:29:05,890 --> 00:29:09,520
it doesn't find anything it gives

00:29:07,300 --> 00:29:12,670
undef and I'm checking whether or not it

00:29:09,520 --> 00:29:15,070
was defined so when I say defined first

00:29:12,670 --> 00:29:17,320
that means did it find it or not did it

00:29:15,070 --> 00:29:20,580
find it anywhere or not but just a habit

00:29:17,320 --> 00:29:20,580
but I think it's a good one

00:29:23,870 --> 00:29:29,860
in case you're thinking this is esoteric

00:29:25,730 --> 00:29:31,310
in the first 180 of my code fight

00:29:29,860 --> 00:29:37,400
solutions

00:29:31,310 --> 00:29:41,060
I used first 30 times so 1/5 of the time

00:29:37,400 --> 00:29:45,380
that's enough for me to to put it on

00:29:41,060 --> 00:29:51,350
y'all's radar I'm using it more and more

00:29:45,380 --> 00:29:53,270
in day to day programming I've known

00:29:51,350 --> 00:29:55,250
about it in Perl 6 for a long time but I

00:29:53,270 --> 00:30:04,640
only recently found out that it was so

00:29:55,250 --> 00:30:06,470
easy to get to in Perl 5 and this is the

00:30:04,640 --> 00:30:13,550
Perl 6 version with all the syntax

00:30:06,470 --> 00:30:15,530
shortcuts to confuse to thrill you take

00:30:13,550 --> 00:30:17,690
nothing go through the customers look

00:30:15,530 --> 00:30:22,390
for the first and that's a shortcut to

00:30:17,690 --> 00:30:25,550
making a code block if you put a star in

00:30:22,390 --> 00:30:29,540
particular places it means make this

00:30:25,550 --> 00:30:31,790
code walk around me and turn the star

00:30:29,540 --> 00:30:36,110
into a essentially a dollar underscore

00:30:31,790 --> 00:30:38,740
and the question mark versus boolean

00:30:36,110 --> 00:30:38,740
context

00:30:40,510 --> 00:30:44,410
so that's last two first

00:30:50,160 --> 00:30:53,060
questions

00:30:57,260 --> 00:30:59,350
I

00:31:02,580 --> 00:31:17,760
there's also reduced generalized Jessie

00:31:14,480 --> 00:31:24,090
set my 15-minute mark you have a

00:31:17,760 --> 00:31:28,070
question okay hold on let for the people

00:31:24,090 --> 00:31:31,980
at home the first comment was reduce is

00:31:28,070 --> 00:31:35,070
in list util and it's the generalized

00:31:31,980 --> 00:31:37,380
foot well it's a more abstract thing

00:31:35,070 --> 00:31:39,390
that can be used to implement a number

00:31:37,380 --> 00:31:42,840
of things including some and min and Max

00:31:39,390 --> 00:31:45,360
and to the functional people they're all

00:31:42,840 --> 00:31:46,350
the same thing under the hood and purl 6

00:31:45,360 --> 00:31:48,060
does that a little bit - there's a

00:31:46,350 --> 00:31:52,320
generalised reduce operator where you

00:31:48,060 --> 00:31:54,300
can just put a square brackets with a

00:31:52,320 --> 00:31:57,330
operator in it and becomes a reduction

00:31:54,300 --> 00:32:00,990
operator but we also have reduce as a as

00:31:57,330 --> 00:32:06,270
a function as a subroutine in both

00:32:00,990 --> 00:32:07,320
you're saying about any and all what do

00:32:06,270 --> 00:32:10,580
you want to say anything particular

00:32:07,320 --> 00:32:10,580
about them besides highlighting them

00:32:13,940 --> 00:32:18,420
that's a really good point he says

00:32:15,870 --> 00:32:21,630
defined first strikes me as the same

00:32:18,420 --> 00:32:26,370
thing as using any and yes I use any and

00:32:21,630 --> 00:32:30,810
all a good bit in Perl 6

00:32:26,370 --> 00:32:34,230
I have not adopted the habits but ease

00:32:30,810 --> 00:32:36,840
them in Perl 5 partly because the

00:32:34,230 --> 00:32:42,930
version of Lists util that is on code

00:32:36,840 --> 00:32:44,550
fights does not have them but and I

00:32:42,930 --> 00:32:46,620
didn't didn't mention them here because

00:32:44,550 --> 00:32:48,030
I think of them as a little more

00:32:46,620 --> 00:32:50,430
advanced but you are completely right

00:32:48,030 --> 00:32:54,200
they should be equivalent and in Perl 6

00:32:50,430 --> 00:32:54,200
you would probably say that instead

00:32:54,620 --> 00:33:00,330
does any short-circuit yes well in Perl

00:32:58,410 --> 00:33:01,530
6 I don't know about 4 or 5 I don't know

00:33:00,330 --> 00:33:07,590
why you would ride it otherwise in

00:33:01,530 --> 00:33:11,309
profile because the one in quantum

00:33:07,590 --> 00:33:24,200
superpositions does not test original

00:33:11,309 --> 00:33:27,809
version of any ok that there are

00:33:24,200 --> 00:33:30,720
numerous cousins which unfortunately are

00:33:27,809 --> 00:33:33,240
all over the place list some utila lists

00:33:30,720 --> 00:33:35,790
more utilities to list most util list

00:33:33,240 --> 00:33:38,010
all utils and they're worth looking at

00:33:35,790 --> 00:33:40,559
just so you know what you should not be

00:33:38,010 --> 00:33:41,970
reinventing the wheel on but I work in

00:33:40,559 --> 00:33:44,960
environments that are kind of all over

00:33:41,970 --> 00:33:48,510
the place and I can't always rely on

00:33:44,960 --> 00:33:50,820
being able to use the various stuff but

00:33:48,510 --> 00:33:56,510
there's great stuff there you really

00:33:50,820 --> 00:33:56,510
should see it for yourself what else

00:33:56,720 --> 00:34:26,110
yes sir I missed something in the last

00:34:21,620 --> 00:34:26,110
three words Sun either yours or comment

00:34:26,260 --> 00:34:33,950
yes

00:34:27,530 --> 00:34:45,760
and then I understand now what was the

00:34:33,950 --> 00:34:49,760
joke yes absolutely so for the camera

00:34:45,760 --> 00:34:52,190
he's making the comparison of I made

00:34:49,760 --> 00:34:55,070
reference to the dollar octothorpe it's

00:34:52,190 --> 00:34:56,930
what you mean versus what is true but

00:34:55,070 --> 00:34:59,240
isn't you're not actually saying what

00:34:56,930 --> 00:35:03,080
you mean which is so valuable in Perl 6

00:34:59,240 --> 00:35:06,070
to me and comparing that to defund first

00:35:03,080 --> 00:35:09,980
versus any and that's completely right

00:35:06,070 --> 00:35:11,510
that's the best argument unless unless

00:35:09,980 --> 00:35:14,600
there was something terrible

00:35:11,510 --> 00:35:16,520
performance-wise with any which there

00:35:14,600 --> 00:35:18,200
may have been early on with the the

00:35:16,520 --> 00:35:20,360
early version of junctures I can't

00:35:18,200 --> 00:35:23,060
remember Junction sorry not junctures

00:35:20,360 --> 00:35:31,280
what is that early version of Johnson

00:35:23,060 --> 00:35:32,890
junctions but the yes it that's

00:35:31,280 --> 00:35:35,330
absolutely right

00:35:32,890 --> 00:35:37,610
for those of you haven't seen it and I

00:35:35,330 --> 00:35:38,270
apologize I would normally do this on a

00:35:37,610 --> 00:35:40,070
laptop

00:35:38,270 --> 00:35:42,380
the graphics are shorted out on it so I

00:35:40,070 --> 00:35:48,010
can't freely type to show you but you

00:35:42,380 --> 00:35:52,850
can say if in pro six if foo equals five

00:35:48,010 --> 00:35:54,970
vertical bar six that's a juncture that

00:35:52,850 --> 00:35:57,800
I'm going to keep doing that a junction

00:35:54,970 --> 00:36:01,880
meaning the same thing as if through

00:35:57,800 --> 00:36:06,630
equals five or through equals six so

00:36:01,880 --> 00:36:11,849
it's it's a miniature version of

00:36:06,630 --> 00:36:14,490
Annie but it certainly makes for tight

00:36:11,849 --> 00:36:18,630
easy to read code you once you know what

00:36:14,490 --> 00:36:23,269
the vertical bar means what else can we

00:36:18,630 --> 00:36:23,269
stop about 406 in general or Perl 5

00:36:28,349 --> 00:36:35,230
would I still be running Perl 5 if I

00:36:32,200 --> 00:36:41,140
weren't being paid for it yes for

00:36:35,230 --> 00:36:44,920
performance reasons yeah that I cut this

00:36:41,140 --> 00:36:48,369
from my opening but in case it is

00:36:44,920 --> 00:36:52,510
helpful to you I write I'm a contract

00:36:48,369 --> 00:36:56,339
programmer and I do not deliver Perl 6

00:36:52,510 --> 00:37:00,069
code to clients there are several issues

00:36:56,339 --> 00:37:01,839
the biggest one is bus factor if I

00:37:00,069 --> 00:37:04,660
deliver something tomorrow and I get hit

00:37:01,839 --> 00:37:06,760
by a bus the next day I cannot know that

00:37:04,660 --> 00:37:11,349
my client can find another Perl 6

00:37:06,760 --> 00:37:16,660
programmer the nearest one is Tom he's

00:37:11,349 --> 00:37:21,490
four hours away and he's retired so so

00:37:16,660 --> 00:37:26,099
there is that but I do write for clients

00:37:21,490 --> 00:37:28,299
in Perl 6 either the easy stuff or the

00:37:26,099 --> 00:37:31,529
complicated stuff stuff in the middle I

00:37:28,299 --> 00:37:33,970
just it's Perl 5 and when I'm done I

00:37:31,529 --> 00:37:35,680
translate it back into Perl 5 and

00:37:33,970 --> 00:37:39,940
deliver it to the client now what is

00:37:35,680 --> 00:37:43,180
done mean done means I've completely

00:37:39,940 --> 00:37:46,900
finished the algorithm or the the code

00:37:43,180 --> 00:37:48,910
that I'm working on or I need something

00:37:46,900 --> 00:37:53,980
that's in Perl 5 that I don't have in

00:37:48,910 --> 00:37:57,010
Perl 6 which is less every day or I need

00:37:53,980 --> 00:38:01,779
to be running across a large data set

00:37:57,010 --> 00:38:04,299
and I was using a restricted subset to

00:38:01,779 --> 00:38:06,130
make Perl 6 run fast enough and I need

00:38:04,299 --> 00:38:08,529
to be running on all the data now so

00:38:06,130 --> 00:38:13,630
it's time to switch to Perl 5 that

00:38:08,529 --> 00:38:18,789
happens often but the reason why I do

00:38:13,630 --> 00:38:22,319
this why it's fair to my my business

00:38:18,789 --> 00:38:26,859
partners my clients is because Perl 6 is

00:38:22,319 --> 00:38:30,849
faster to write in Perl 6 is easier to

00:38:26,859 --> 00:38:35,670
think in it's a better language what

00:38:30,849 --> 00:38:38,650
would you expect I had lunch with the

00:38:35,670 --> 00:38:41,410
the authors of Python in a nutshell at

00:38:38,650 --> 00:38:42,790
OSCON well it was

00:38:41,410 --> 00:38:44,110
on table so it was everybody there but

00:38:42,790 --> 00:38:46,720
they were the ones who were mostly

00:38:44,110 --> 00:38:49,060
engaging me and I was picking their

00:38:46,720 --> 00:38:50,830
brains on there two to three and three

00:38:49,060 --> 00:38:56,050
to two Python to Python three

00:38:50,830 --> 00:38:59,920
translation tools and and backwards -

00:38:56,050 --> 00:39:01,690
and their general issues that their

00:38:59,920 --> 00:39:04,390
community has had with having two

00:39:01,690 --> 00:39:08,050
different versions of Python and they

00:39:04,390 --> 00:39:13,470
were very helpful in talking about that

00:39:08,050 --> 00:39:13,470
and I don't know where I was going with

00:39:16,590 --> 00:39:25,510
yeah yes and there's their statement in

00:39:22,210 --> 00:39:26,470
the middle of something was you know he

00:39:25,510 --> 00:39:28,570
was giving me an example

00:39:26,470 --> 00:39:30,310
thank you all for reminding me where I

00:39:28,570 --> 00:39:32,050
was give me an example of some code that

00:39:30,310 --> 00:39:34,540
was in Python - that will never be

00:39:32,050 --> 00:39:37,510
translated because it was so heavily

00:39:34,540 --> 00:39:43,450
optimized for the idiosyncrasies of

00:39:37,510 --> 00:39:45,130
Python - and everything else they want

00:39:43,450 --> 00:39:48,520
to write in Python 3 and they said

00:39:45,130 --> 00:39:50,620
because it's a better language you know

00:39:48,520 --> 00:39:53,680
that that was a bald-faced statement by

00:39:50,620 --> 00:39:58,120
community experts that made me see that

00:39:53,680 --> 00:40:01,210
this is not not a unique perspective I

00:39:58,120 --> 00:40:04,510
know that we we talked about Perl 5 or 6

00:40:01,210 --> 00:40:06,970
as sister languages and they are and

00:40:04,510 --> 00:40:11,970
Perl 5 is never going away the code base

00:40:06,970 --> 00:40:17,620
is too enormous but if you get to choose

00:40:11,970 --> 00:40:19,900
Perl 6 is better to work in modulo you

00:40:17,620 --> 00:40:22,960
know some modules and some performance

00:40:19,900 --> 00:40:25,360
and the things that we're all working to

00:40:22,960 --> 00:40:30,030
make better just the bear language it's

00:40:25,360 --> 00:40:30,030
better to work in what else

00:40:31,340 --> 00:40:36,370
I've been given the 10-minute warning

00:40:36,430 --> 00:40:59,980
yes sir so the question is we all know

00:40:56,510 --> 00:41:03,740
that we keep backporting ideas concepts

00:40:59,980 --> 00:41:08,150
features from Perl 6 into pro 5 Perl 5

00:41:03,740 --> 00:41:11,030
has its own stream of developments is

00:41:08,150 --> 00:41:13,040
anything making it from Pro 5 to Perl 6

00:41:11,030 --> 00:41:14,240
I'm not aware of them but there are

00:41:13,040 --> 00:41:17,360
people in the audience who would know

00:41:14,240 --> 00:41:19,820
better than me so can anybody respond to

00:41:17,360 --> 00:41:25,490
that even to say no there definitely

00:41:19,820 --> 00:41:26,270
aren't any Larry wall is giving me a

00:41:25,490 --> 00:41:34,180
shrug

00:41:26,270 --> 00:41:34,180
I really can't think of any

00:41:55,820 --> 00:42:00,720
okay Larry wall is telling us that there

00:41:59,339 --> 00:42:05,390
is something in the object

00:42:00,720 --> 00:42:12,599
initialization world that moose is build

00:42:05,390 --> 00:42:16,230
does what does better than Perl fixes

00:42:12,599 --> 00:42:20,339
build we've had to add the tweak sub

00:42:16,230 --> 00:42:22,200
method in Perl 6 to to catch up so to

00:42:20,339 --> 00:42:25,339
speak to get the right functionality

00:42:22,200 --> 00:42:29,640
there and I only found out about tweak a

00:42:25,339 --> 00:42:32,849
couple of days ago so I can't speak to

00:42:29,640 --> 00:42:35,700
that but I'm glad to know that it is

00:42:32,849 --> 00:42:37,260
working both ways and that we we haven't

00:42:35,700 --> 00:42:40,500
got everything right but when we

00:42:37,260 --> 00:42:43,470
declared 6 point C we're committed to

00:42:40,500 --> 00:42:46,020
that and yeah we can't we can't fix

00:42:43,470 --> 00:42:50,400
things after that point but if we can't

00:42:46,020 --> 00:42:52,910
fix them we will find a way did that

00:42:50,400 --> 00:42:52,910
answer your question

00:42:56,260 --> 00:43:05,530
yes sir you say that Perl 5 is faster

00:43:02,220 --> 00:43:13,140
executing than Perl 6 Perl 6 is

00:43:05,530 --> 00:43:13,140
certainly set up in the past whatever

00:43:14,190 --> 00:43:23,369
the question is Perl 6 is getting ever

00:43:20,980 --> 00:43:26,800
faster will let ever catch up to Perl 5

00:43:23,369 --> 00:43:27,310
well let me branch that in some ways it

00:43:26,800 --> 00:43:30,130
already

00:43:27,310 --> 00:43:31,810
is faster than Perl 5 if you if you are

00:43:30,130 --> 00:43:34,690
putting so many modules like you're

00:43:31,810 --> 00:43:37,600
using loose and you're using all the

00:43:34,690 --> 00:43:39,790
things that you would need to make

00:43:37,600 --> 00:43:42,160
profile do two things that Perl 6 does I

00:43:39,790 --> 00:43:44,950
think some of the benchmarks show that

00:43:42,160 --> 00:43:46,840
we're already beating them but that you

00:43:44,950 --> 00:43:49,900
know that's sort of a cop-out but it's

00:43:46,840 --> 00:43:51,520
interesting point that the part of the

00:43:49,900 --> 00:43:54,790
reason Perl 5 is so fast as it's not

00:43:51,520 --> 00:44:00,030
doing as much as Perl 6 is but to your

00:43:54,790 --> 00:44:04,600
actual question I don't see why not

00:44:00,030 --> 00:44:10,750
the things that there are a lot of

00:44:04,600 --> 00:44:13,900
places where Perl 6 as a design can be

00:44:10,750 --> 00:44:16,200
you know conceptually there are places

00:44:13,900 --> 00:44:19,930
where it can be better you say my int

00:44:16,200 --> 00:44:22,000
foo equals 42 then the compiler can know

00:44:19,930 --> 00:44:25,030
from there on you're not going to put a

00:44:22,000 --> 00:44:27,160
string into food it's going to be an int

00:44:25,030 --> 00:44:29,080
from then on although it is mutable and

00:44:27,160 --> 00:44:31,560
it should be able to optimize around

00:44:29,080 --> 00:44:33,790
that especially when you're declaring

00:44:31,560 --> 00:44:37,980
classes you know this is of a certain

00:44:33,790 --> 00:44:41,440
class we should be able to do a faster

00:44:37,980 --> 00:44:43,720
dispatching and they're just tons of

00:44:41,440 --> 00:44:47,920
things like that but that doesn't mean

00:44:43,720 --> 00:44:49,930
that they are right now also there's a

00:44:47,920 --> 00:44:54,720
whole lot of that has been done and is

00:44:49,930 --> 00:44:58,810
being done with parallelization and

00:44:54,720 --> 00:45:03,069
asynchrony that have enormous potential

00:44:58,810 --> 00:45:04,959
but right now are not the complex

00:45:03,069 --> 00:45:06,849
I talked about the hyper operator hyper

00:45:04,959 --> 00:45:13,239
among other things thank you sir

00:45:06,849 --> 00:45:14,859
means like hyper x ray on either side it

00:45:13,239 --> 00:45:16,779
can multiply them in any order it wants

00:45:14,859 --> 00:45:18,670
to and it can create threads the

00:45:16,779 --> 00:45:20,140
compiler can create threads and do them

00:45:18,670 --> 00:45:22,420
all in parallel that's part of what

00:45:20,140 --> 00:45:24,369
hyper means is I promise you compiler

00:45:22,420 --> 00:45:28,119
that if you don't do this in order it's

00:45:24,369 --> 00:45:30,430
not going to screw me up lots of

00:45:28,119 --> 00:45:36,069
potential data right now does it do it

00:45:30,430 --> 00:45:40,180
it doesn't do it right now okay there

00:45:36,069 --> 00:45:42,160
may be a experimental branch I know one

00:45:40,180 --> 00:45:45,089
of the funny things I think is whenever

00:45:42,160 --> 00:45:47,979
it is something like that where we say

00:45:45,089 --> 00:45:52,059
this feature means it can happen out of

00:45:47,979 --> 00:45:54,309
order if it's not being run on parallel

00:45:52,059 --> 00:45:56,650
threads we deliberately have an

00:45:54,309 --> 00:45:59,109
algorithm where we make sure it runs in

00:45:56,650 --> 00:46:02,589
a single thread a single processor out

00:45:59,109 --> 00:46:03,849
of order so that one day when you've

00:46:02,589 --> 00:46:05,890
been developing on a single processor

00:46:03,849 --> 00:46:07,959
machine and you take it to a multiple

00:46:05,890 --> 00:46:08,799
processor machine you won't get bitten

00:46:07,959 --> 00:46:10,509
by bugs

00:46:08,799 --> 00:46:14,259
the way you do in what every other

00:46:10,509 --> 00:46:18,849
language right now it's great great

00:46:14,259 --> 00:46:22,979
piece of twisted mess did that answer

00:46:18,849 --> 00:46:26,130
your question were past five minutes

00:46:22,979 --> 00:46:26,130
anything else

00:46:29,660 --> 00:46:38,119
thank you

00:46:31,650 --> 00:46:38,119

YouTube URL: https://www.youtube.com/watch?v=EUXclZ_d0DQ


