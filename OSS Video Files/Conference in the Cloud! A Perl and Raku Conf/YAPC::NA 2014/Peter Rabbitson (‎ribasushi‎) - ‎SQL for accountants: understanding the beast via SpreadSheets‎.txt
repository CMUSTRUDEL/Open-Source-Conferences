Title: Peter Rabbitson (‎ribasushi‎) - ‎SQL for accountants: understanding the beast via SpreadSheets‎
Publication date: 2014-06-26
Playlist: YAPC::NA 2014
Description: 
	In order to enjoy this talk you do not need to know Perl, nor SQL, nor do you need to be an accountant.

This is a basic-to-advanced crash-course in SQL syntax and concepts. We will cover most of the road from speaking basic CRUD SQL, through joins, resultsets and subqueries all the way to weirdness like relational division. All of this will happen without looking at any perl code (yes, this is not a DBIx::Class talk :)

Even if you are a seasoned SQL veteran some of the presented techniques will no doubt surprise you, or at least make you roll your eyes.
Captions: 
	00:00:03,040 --> 00:00:05,100
you

00:00:18,560 --> 00:00:26,150
ah so good morning it's excellent based

00:00:24,560 --> 00:00:34,790
on that may of you today because how

00:00:26,150 --> 00:00:36,949
this point here people so I see I deal

00:00:34,790 --> 00:00:40,430
with you x plus most of the time and

00:00:36,949 --> 00:00:42,710
it's ecosystem more or less like sequel

00:00:40,430 --> 00:00:46,030
abstract and scotland's later and things

00:00:42,710 --> 00:00:50,180
like that and today I wanted to give

00:00:46,030 --> 00:00:52,909
talk about like very very basic SQL for

00:00:50,180 --> 00:00:54,470
people who do not you know feel entirely

00:00:52,909 --> 00:00:57,530
comfortable with it and stuff like that

00:00:54,470 --> 00:00:59,960
how many peer actually are comfortable

00:00:57,530 --> 00:01:08,360
with joins for example and stuff like

00:00:59,960 --> 00:01:09,920
that what are you doing here okay data

00:01:08,360 --> 00:01:11,990
promises talk is this store this

00:01:09,920 --> 00:01:16,759
relatively cursed the first times I gave

00:01:11,990 --> 00:01:18,860
it it basically my slides kind of cut

00:01:16,759 --> 00:01:22,100
off in the middle of of my HTML and

00:01:18,860 --> 00:01:24,579
stuff and since then I redid them

00:01:22,100 --> 00:01:27,530
entirely and this morning while i was

00:01:24,579 --> 00:01:31,880
tricking stuff here and there my battery

00:01:27,530 --> 00:01:33,560
went out and I Iran XFS on my laptop and

00:01:31,880 --> 00:01:37,130
exercise does not like when the power

00:01:33,560 --> 00:01:39,170
goes out so we'll improvise a little bit

00:01:37,130 --> 00:01:41,060
I have about two thirds of my slides and

00:01:39,170 --> 00:01:44,240
the most interesting ones are missing so

00:01:41,060 --> 00:01:45,590
when we get there we'll see you know how

00:01:44,240 --> 00:01:46,939
we're on time and stuff like that so

00:01:45,590 --> 00:01:50,299
maybe this resignation will be cut short

00:01:46,939 --> 00:01:53,450
unfortunately but you know ah let's

00:01:50,299 --> 00:01:56,420
begin so escrow for accountants under

00:01:53,450 --> 00:02:01,969
saying the Beast via via spreadsheets ah

00:01:56,420 --> 00:02:07,729
i lose myself oh no and tim is here come

00:02:01,969 --> 00:02:09,709
on in yes oh yeah see I put that in the

00:02:07,729 --> 00:02:12,020
air before it crashed and took the rest

00:02:09,709 --> 00:02:14,860
of the slides with it yeah how cool is

00:02:12,020 --> 00:02:14,860
that is misspelled

00:02:16,670 --> 00:02:26,700
it isn't you suck right so let's go

00:02:23,670 --> 00:02:29,460
structured query language ah it is old

00:02:26,700 --> 00:02:32,820
and you know not very popular these days

00:02:29,460 --> 00:02:34,830
because old is how hipsters call

00:02:32,820 --> 00:02:39,240
everything this useful and just works

00:02:34,830 --> 00:02:41,460
and it is heavily standardized its

00:02:39,240 --> 00:02:45,350
behavior absolutely the same on any you

00:02:41,460 --> 00:02:50,070
know our DBMS that you run it on not and

00:02:45,350 --> 00:02:54,750
it is more less hateful basically it is

00:02:50,070 --> 00:03:02,780
a very expressive language in very in in

00:02:54,750 --> 00:03:04,860
a very limited set of keywords and it's

00:03:02,780 --> 00:03:08,010
because of this expression is it allows

00:03:04,860 --> 00:03:11,880
you to make mistakes relatively simply

00:03:08,010 --> 00:03:15,150
and debugging it is pretty just hard

00:03:11,880 --> 00:03:18,990
because our DBMS are not very useful and

00:03:15,150 --> 00:03:21,330
giving you the correct you know reports

00:03:18,990 --> 00:03:23,850
on where you missed out on something

00:03:21,330 --> 00:03:28,980
like this but as I said it's very very

00:03:23,850 --> 00:03:31,290
very powerful so um I disclaimer there

00:03:28,980 --> 00:03:34,260
is a bunch of basically is only one

00:03:31,290 --> 00:03:39,720
table work with and there will be some

00:03:34,260 --> 00:03:41,460
basic SQL this will be shown and there

00:03:39,720 --> 00:03:43,290
are at least four things that the first

00:03:41,460 --> 00:03:44,790
slide will violate right out of bed so

00:03:43,290 --> 00:03:47,310
if you do this kind of stuff in your

00:03:44,790 --> 00:03:52,610
production your managers will most

00:03:47,310 --> 00:03:57,990
likely beat you up with a reason so

00:03:52,610 --> 00:04:02,780
let's go we have self called create

00:03:57,990 --> 00:04:06,030
basically to make tables and to define

00:04:02,780 --> 00:04:09,300
what it more or less is just a

00:04:06,030 --> 00:04:11,400
spreadsheet because all SQL deals with

00:04:09,300 --> 00:04:13,470
it deals with two dimensional data so

00:04:11,400 --> 00:04:15,870
you can think of it as this you know

00:04:13,470 --> 00:04:17,850
complicated thing with drawings and with

00:04:15,870 --> 00:04:19,200
indexation stuff like that or you can

00:04:17,850 --> 00:04:22,410
just say you know what it's just a

00:04:19,200 --> 00:04:24,600
collection of Excel spreadsheets in a

00:04:22,410 --> 00:04:26,220
workbook so to speak and we are going to

00:04:24,600 --> 00:04:27,620
you know look at it and query it back

00:04:26,220 --> 00:04:29,660
and forth and stuff like that

00:04:27,620 --> 00:04:30,949
so for instance here we're going to

00:04:29,660 --> 00:04:34,610
declare what we are going to work with

00:04:30,949 --> 00:04:37,449
uh we create a spreadsheet or a table

00:04:34,610 --> 00:04:41,360
the wave calls in SQL host company and

00:04:37,449 --> 00:04:43,660
if he has three columns and the columns

00:04:41,360 --> 00:04:45,680
will kind of always be there because

00:04:43,660 --> 00:04:47,150
just like a normal spreadsheet you

00:04:45,680 --> 00:04:49,699
normally have your columns fixed and

00:04:47,150 --> 00:04:53,510
then you add or remove roles depending

00:04:49,699 --> 00:04:56,560
on how your data goes in and out so it

00:04:53,510 --> 00:04:59,690
has the first time is called employee ah

00:04:56,560 --> 00:05:01,010
it can take up to 50 characters the

00:04:59,690 --> 00:05:04,550
second one is called Department same

00:05:01,010 --> 00:05:06,440
thing and experience supposed to how

00:05:04,550 --> 00:05:10,850
many years did the person work in this

00:05:06,440 --> 00:05:15,770
company and an empty table will look

00:05:10,850 --> 00:05:18,889
like this or an expression so you also

00:05:15,770 --> 00:05:20,449
can in pretty much any database and this

00:05:18,889 --> 00:05:22,550
one of the very few things that is more

00:05:20,449 --> 00:05:24,620
or less standardized in almost any

00:05:22,550 --> 00:05:26,780
database you can eat with this command a

00:05:24,620 --> 00:05:28,460
show create table and the name of the

00:05:26,780 --> 00:05:31,610
table and he will get something very

00:05:28,460 --> 00:05:34,220
similar to this which defines how the

00:05:31,610 --> 00:05:38,930
table can be recreated and what it

00:05:34,220 --> 00:05:45,380
contains so uh let's do some data in our

00:05:38,930 --> 00:05:48,320
sample company we have three missing

00:05:45,380 --> 00:05:50,389
departments ah the Java one is the best

00:05:48,320 --> 00:05:52,700
one and it has you know some

00:05:50,389 --> 00:05:55,729
inexperienced people and some pretty

00:05:52,700 --> 00:05:58,760
experienced people and we have a.net

00:05:55,729 --> 00:06:01,780
departments and we have a pull the

00:05:58,760 --> 00:06:10,340
button with Christmas to all these

00:06:01,780 --> 00:06:15,199
employees and the finish names so how do

00:06:10,340 --> 00:06:18,080
we update in SQL our spreadsheet we use

00:06:15,199 --> 00:06:20,599
command called insert and then some

00:06:18,080 --> 00:06:23,330
syntax is actually pretty simple I we

00:06:20,599 --> 00:06:28,690
say insert into where which spread

00:06:23,330 --> 00:06:31,280
so company which columns are we going to

00:06:28,690 --> 00:06:33,169
populate because you can have columns

00:06:31,280 --> 00:06:36,080
without you know you can have empty

00:06:33,169 --> 00:06:37,909
cells and then we say which values we're

00:06:36,080 --> 00:06:39,980
gonna we're going to put in there so if

00:06:37,909 --> 00:06:46,350
we execute the stuff on top

00:06:39,980 --> 00:06:50,330
we're going to insert this into the

00:06:46,350 --> 00:06:53,190
database and it's exactly what we

00:06:50,330 --> 00:06:55,770
specialize on that depending on how your

00:06:53,190 --> 00:06:58,500
table is created it might allow you to

00:06:55,770 --> 00:07:00,450
for example drop the experience and it

00:06:58,500 --> 00:07:03,030
will insert the zero and so on or it

00:07:00,450 --> 00:07:05,610
might allow you to even drop the

00:07:03,030 --> 00:07:07,980
department and if it doesn't allow you

00:07:05,610 --> 00:07:09,690
to do that and you don't specify them in

00:07:07,980 --> 00:07:11,250
the values it will draw an exception and

00:07:09,690 --> 00:07:13,260
say you know such and such constraint

00:07:11,250 --> 00:07:15,180
violated and stuff like that but again

00:07:13,260 --> 00:07:17,820
this is very dependent on how your

00:07:15,180 --> 00:07:22,370
current database and tables are set up

00:07:17,820 --> 00:07:26,910
so we're not going to delve into that so

00:07:22,370 --> 00:07:31,110
before we go further we need to talk a

00:07:26,910 --> 00:07:33,630
little bit about how in SQL we express a

00:07:31,110 --> 00:07:37,110
condition so a condition more or less is

00:07:33,630 --> 00:07:39,419
like a bunch of gifs in you know in any

00:07:37,110 --> 00:07:42,090
programming language and it consists of

00:07:39,419 --> 00:07:44,640
simple building blocks are normally with

00:07:42,090 --> 00:07:50,400
the left and right operand so just like

00:07:44,640 --> 00:07:53,580
a equals B we have the regular Dragic

00:07:50,400 --> 00:07:56,520
comparison operator so equals larger

00:07:53,580 --> 00:08:01,320
than smaller than that not equal we have

00:07:56,520 --> 00:08:04,979
something like the pearls equivalent of

00:08:01,320 --> 00:08:07,610
index so which is called light in SQL so

00:08:04,979 --> 00:08:11,190
it's like a limited regular expression

00:08:07,610 --> 00:08:15,090
and we can combine those building blocks

00:08:11,190 --> 00:08:18,840
with the usual and or not operators the

00:08:15,090 --> 00:08:21,990
usual logic and we can use parentheses

00:08:18,840 --> 00:08:27,539
to denote our blogs and where and how

00:08:21,990 --> 00:08:29,580
things are how to define precedence what

00:08:27,539 --> 00:08:31,860
is ended with what and so on and so

00:08:29,580 --> 00:08:33,589
forth and the result is just like you

00:08:31,860 --> 00:08:36,539
know in any program language we can

00:08:33,589 --> 00:08:41,969
build up arbitrary complex conditions so

00:08:36,539 --> 00:08:46,890
for example this is a simple condition

00:08:41,969 --> 00:08:51,440
of a equals B so we take the column

00:08:46,890 --> 00:08:55,010
employee and you check if

00:08:51,440 --> 00:08:58,640
it equals Java boss and we satisfied for

00:08:55,010 --> 00:09:02,500
only rose in the spreadsheet which

00:08:58,640 --> 00:09:04,520
satisfy this condition this is the

00:09:02,500 --> 00:09:07,640
limited regular expression I was talking

00:09:04,520 --> 00:09:15,340
about everything that ends in boss will

00:09:07,640 --> 00:09:17,840
match this is how logic works so we have

00:09:15,340 --> 00:09:19,520
one condition which needs to be

00:09:17,840 --> 00:09:20,810
satisfied and now the tanginess also

00:09:19,520 --> 00:09:23,390
needs to be satisfied so this will

00:09:20,810 --> 00:09:28,460
select all the bosses that are not java

00:09:23,390 --> 00:09:33,050
heads and this shows precedence so we

00:09:28,460 --> 00:09:34,910
have one condition end it with it like

00:09:33,050 --> 00:09:39,800
that condition or this condition pretty

00:09:34,910 --> 00:09:41,480
basic stuff how we remove rows from a

00:09:39,800 --> 00:09:43,190
spreadsheet we use the delete command

00:09:41,480 --> 00:09:50,300
the document is different from the

00:09:43,190 --> 00:09:52,160
insert in terms of how the name of the

00:09:50,300 --> 00:09:55,040
table specified so in answer to head

00:09:52,160 --> 00:09:58,520
insert into company here we have delete

00:09:55,040 --> 00:10:00,440
from company and we can add any kind of

00:09:58,520 --> 00:10:02,480
condition on the end just like we

00:10:00,440 --> 00:10:03,830
specified in the previous slide if we

00:10:02,480 --> 00:10:05,480
don't specify conditions we just say

00:10:03,830 --> 00:10:07,610
delete from company it will just blow

00:10:05,480 --> 00:10:10,730
away the entire spreadsheet and it will

00:10:07,610 --> 00:10:13,910
keep the table in place but it will be

00:10:10,730 --> 00:10:16,040
empty at then so if we execute this

00:10:13,910 --> 00:10:21,500
command what's going to happen is it is

00:10:16,040 --> 00:10:24,500
going to match these two rows right if

00:10:21,500 --> 00:10:25,850
you match these two rows because those

00:10:24,500 --> 00:10:29,870
are lonely two guys with experience

00:10:25,850 --> 00:10:31,970
season two years and it will block them

00:10:29,870 --> 00:10:35,780
way so we're downsizing we're finding

00:10:31,970 --> 00:10:40,910
our anger youngest employees and the

00:10:35,780 --> 00:10:42,620
result will look like that what else can

00:10:40,910 --> 00:10:46,490
we do well we sometimes want to update

00:10:42,620 --> 00:10:50,360
stuff in our table or spreadsheet so

00:10:46,490 --> 00:10:53,120
again the syntax is in the standardized

00:10:50,360 --> 00:10:55,250
language different for update you only

00:10:53,120 --> 00:10:59,780
specify the name of the things you don't

00:10:55,250 --> 00:11:02,960
say update from or update into you say

00:10:59,780 --> 00:11:04,200
update company then you have the

00:11:02,960 --> 00:11:08,490
operators set

00:11:04,200 --> 00:11:13,830
which might take one or multiple columns

00:11:08,490 --> 00:11:16,020
and you say what we said each column to

00:11:13,830 --> 00:11:18,300
now we normally don't want to update

00:11:16,020 --> 00:11:23,460
entire columns we want to update cells

00:11:18,300 --> 00:11:27,030
so not only we want to say what are we

00:11:23,460 --> 00:11:30,030
going to update vertically employee but

00:11:27,030 --> 00:11:31,950
we want to horizontally select which

00:11:30,030 --> 00:11:33,570
employee of all we're going to update

00:11:31,950 --> 00:11:38,850
this how we're going to update the cell

00:11:33,570 --> 00:11:43,980
so what's going to happen here is we are

00:11:38,850 --> 00:11:47,850
going to find the current employee with

00:11:43,980 --> 00:11:50,480
a pearl boss right there and it finds

00:11:47,850 --> 00:11:53,670
the row and then it looks ok which one

00:11:50,480 --> 00:11:57,240
which columns do I need to set in this

00:11:53,670 --> 00:12:01,140
role it's just employee if we'll do that

00:11:57,240 --> 00:12:08,720
and the result will look like this so

00:12:01,140 --> 00:12:13,260
now our boss is called a lot order and I

00:12:08,720 --> 00:12:15,990
mentioned that we might want to update

00:12:13,260 --> 00:12:17,880
the entire table soon you know at times

00:12:15,990 --> 00:12:20,670
but we don't really want to put the same

00:12:17,880 --> 00:12:22,800
value everywhere this just you know most

00:12:20,670 --> 00:12:24,120
of them doesn't doesn't make sense but

00:12:22,800 --> 00:12:26,760
we can do stuff like this we can

00:12:24,120 --> 00:12:30,350
actually use expressions in our update

00:12:26,760 --> 00:12:34,800
syntax so what's going to happen here is

00:12:30,350 --> 00:12:36,150
we're going to match everything because

00:12:34,800 --> 00:12:37,620
there is no condition there is nowhere

00:12:36,150 --> 00:12:40,650
so we're just going to update the entire

00:12:37,620 --> 00:12:45,470
company table but what's going to happen

00:12:40,650 --> 00:12:51,390
is for every cell that we selected here

00:12:45,470 --> 00:12:53,790
this expression experience plus 1 will

00:12:51,390 --> 00:12:57,480
be evaluated separately individually so

00:12:53,790 --> 00:12:59,790
experienced 9 will get a 1 added to it

00:12:57,480 --> 00:13:01,560
and will be sold back experience 5 will

00:12:59,790 --> 00:13:04,860
be will have one added to it from the

00:13:01,560 --> 00:13:08,520
store back and so on so the result will

00:13:04,860 --> 00:13:10,650
be this is basically an increment and

00:13:08,520 --> 00:13:12,780
what's interesting is that in most

00:13:10,650 --> 00:13:15,210
databases this particular operation will

00:13:12,780 --> 00:13:16,570
be atomic as well so it will either have

00:13:15,210 --> 00:13:18,790
an almost heaven

00:13:16,570 --> 00:13:20,620
do not have to worry about locking

00:13:18,790 --> 00:13:22,900
cannot have to worry about transactions

00:13:20,620 --> 00:13:25,890
you don't have to you know you just do

00:13:22,900 --> 00:13:29,680
it and it will take care of everything

00:13:25,890 --> 00:13:32,470
right so those are our data manipulation

00:13:29,680 --> 00:13:35,230
we showed how to insert stuff how to

00:13:32,470 --> 00:13:37,480
delete stuff and how to update stuff but

00:13:35,230 --> 00:13:38,890
it is this not the interesting part of

00:13:37,480 --> 00:13:41,230
you know because you're storing stuff is

00:13:38,890 --> 00:13:43,090
not you know the strength of relational

00:13:41,230 --> 00:13:46,900
database what we're going to lose now

00:13:43,090 --> 00:13:50,950
what we're going to look at now is oops

00:13:46,900 --> 00:13:54,820
sorry how to retrieve stuff from the

00:13:50,950 --> 00:13:57,310
database and the basic syntax for

00:13:54,820 --> 00:14:00,130
selectors is just that select something

00:13:57,310 --> 00:14:04,090
from something that's simple so for

00:14:00,130 --> 00:14:07,330
instance put into that and we're going

00:14:04,090 --> 00:14:09,130
to get back exactly what we had in the

00:14:07,330 --> 00:14:12,970
database we're going to get the entire

00:14:09,130 --> 00:14:16,390
spreadsheet more or less right a star in

00:14:12,970 --> 00:14:19,540
again in all databases are the notes

00:14:16,390 --> 00:14:23,650
every single column that is in the

00:14:19,540 --> 00:14:25,270
engine now of course we can say this we

00:14:23,650 --> 00:14:29,260
don't want all comes won't just a

00:14:25,270 --> 00:14:30,640
particular set of them this will work we

00:14:29,260 --> 00:14:36,010
just say select this column and this

00:14:30,640 --> 00:14:42,430
column from this table and it turns what

00:14:36,010 --> 00:14:44,680
we see now we're going to talk a little

00:14:42,430 --> 00:14:48,570
bit about aggregate functions what are

00:14:44,680 --> 00:14:51,550
aggregates unction it's when you want to

00:14:48,570 --> 00:14:54,820
run just like in Excel when you want to

00:14:51,550 --> 00:14:56,800
run a function over several rows in a

00:14:54,820 --> 00:14:59,730
particular column so for example you can

00:14:56,800 --> 00:15:02,080
count how many rolls there are in your

00:14:59,730 --> 00:15:05,530
spreadsheet or in your set whatever or

00:15:02,080 --> 00:15:07,060
you can get an average of a set of

00:15:05,530 --> 00:15:09,430
values or you can get a minimum or

00:15:07,060 --> 00:15:11,410
maximum and those are pretty much the

00:15:09,430 --> 00:15:13,720
only ones that are more or less standard

00:15:11,410 --> 00:15:16,960
across the entire landscape everything

00:15:13,720 --> 00:15:20,140
else you might be able to use it you

00:15:16,960 --> 00:15:21,190
might not it depends on your vendor what

00:15:20,140 --> 00:15:24,460
it is

00:15:21,190 --> 00:15:28,600
so for instance if we use the max

00:15:24,460 --> 00:15:32,290
function it is going to return this one

00:15:28,600 --> 00:15:37,000
a result it will again be in the form of

00:15:32,290 --> 00:15:38,470
a spreadsheet but what is going to f is

00:15:37,000 --> 00:15:41,320
going to have only one column and only

00:15:38,470 --> 00:15:44,700
one row because we asked for a single

00:15:41,320 --> 00:15:47,380
result you we basically said give me the

00:15:44,700 --> 00:15:50,650
highest experience in the entire company

00:15:47,380 --> 00:15:55,060
and the planet and if you notice are

00:15:50,650 --> 00:15:56,770
here on the top the column name is Max

00:15:55,060 --> 00:16:00,370
experience now why is that because we

00:15:56,770 --> 00:16:03,310
asked for a function but we didn't name

00:16:00,370 --> 00:16:04,960
its output and the database will

00:16:03,310 --> 00:16:07,650
normally just say well this what we

00:16:04,960 --> 00:16:12,310
asked me for this is how it's cold and

00:16:07,650 --> 00:16:14,530
if we want to change them there is a

00:16:12,310 --> 00:16:18,250
standard keyboard called s which is an

00:16:14,530 --> 00:16:20,920
alias order on assignment or however you

00:16:18,250 --> 00:16:26,760
want to think about it the very same

00:16:20,920 --> 00:16:30,220
query will return the result in such a

00:16:26,760 --> 00:16:32,980
manner so now your column actually has a

00:16:30,220 --> 00:16:35,950
reasonable name now this usually will

00:16:32,980 --> 00:16:38,020
not be important because as a programmer

00:16:35,950 --> 00:16:39,670
you know exactly what you asked for so

00:16:38,020 --> 00:16:41,080
you know what the first colonists is

00:16:39,670 --> 00:16:44,730
coming back and while the second column

00:16:41,080 --> 00:16:47,290
is and so on and so forth so this name

00:16:44,730 --> 00:16:48,730
looks like extra information that just

00:16:47,290 --> 00:16:51,220
there to you know to make things look

00:16:48,730 --> 00:16:56,770
nice however further than the Rose it

00:16:51,220 --> 00:17:00,220
will become important now we talked

00:16:56,770 --> 00:17:02,380
about aggregate functions you know like

00:17:00,220 --> 00:17:07,329
maximum minimum so forth and so on and

00:17:02,380 --> 00:17:13,150
so forth but what if we want to identify

00:17:07,329 --> 00:17:16,209
groups in our data and they return the

00:17:13,150 --> 00:17:18,400
name of those groups the basic syntax

00:17:16,209 --> 00:17:21,520
looks kinda like this will save me

00:17:18,400 --> 00:17:23,949
something from something and then we

00:17:21,520 --> 00:17:28,750
group by particular criteria the

00:17:23,949 --> 00:17:30,280
criteria is just a set of values this

00:17:28,750 --> 00:17:33,060
varies might come from a column this

00:17:30,280 --> 00:17:34,540
varies might come from a function or

00:17:33,060 --> 00:17:39,430
anything

00:17:34,540 --> 00:17:42,090
an example from the very same companies

00:17:39,430 --> 00:17:44,500
we that we used we're going to get a

00:17:42,090 --> 00:17:46,810
department column and what's going to

00:17:44,500 --> 00:17:50,830
happen after that is we are going to ask

00:17:46,810 --> 00:17:54,760
to group by that by the variance count

00:17:50,830 --> 00:17:58,240
and we're going to get this result so if

00:17:54,760 --> 00:18:01,410
you look at the data we have here what

00:17:58,240 --> 00:18:03,790
happens is we got the department column

00:18:01,410 --> 00:18:07,450
but every single duplicate got

00:18:03,790 --> 00:18:16,090
compressed into just single value so we

00:18:07,450 --> 00:18:23,050
got three values back now cooking guess

00:18:16,090 --> 00:18:24,490
what will this return we're asking for

00:18:23,050 --> 00:18:28,350
two counts we're asking for department

00:18:24,490 --> 00:18:34,210
and for experience so just like before

00:18:28,350 --> 00:18:36,100
we have three distinct departments and

00:18:34,210 --> 00:18:41,040
we have experienced all over the all

00:18:36,100 --> 00:18:46,810
over the map and then we say six again

00:18:41,040 --> 00:18:48,550
yes it will be three rows and what can't

00:18:46,810 --> 00:18:53,500
experience will get them for each of

00:18:48,550 --> 00:18:56,820
them precisely precisely in fact most

00:18:53,500 --> 00:18:59,650
databases will not let you run this

00:18:56,820 --> 00:19:04,240
query SSD say now because what's going

00:18:59,650 --> 00:19:07,990
to happen is the engine will look at

00:19:04,240 --> 00:19:12,330
this data it will throw this way because

00:19:07,990 --> 00:19:16,570
we're not asking for it it will start

00:19:12,330 --> 00:19:20,710
collapsing for example this set into a

00:19:16,570 --> 00:19:23,050
single into a single entity and we'll go

00:19:20,710 --> 00:19:24,460
well those are values that I have no way

00:19:23,050 --> 00:19:26,380
of reconciling I don't know if the

00:19:24,460 --> 00:19:31,750
person wanted the smallest one the

00:19:26,380 --> 00:19:34,120
average one the highest one so on masc

00:19:31,750 --> 00:19:37,840
sequel I'd this will just give you a

00:19:34,120 --> 00:19:39,490
random answer back depending on

00:19:37,840 --> 00:19:41,020
insertion order depending on the phase

00:19:39,490 --> 00:19:43,300
of the moon depending on a lot of other

00:19:41,020 --> 00:19:47,340
things you will get something but it

00:19:43,300 --> 00:19:49,539
will not be able to expect and postgres

00:19:47,340 --> 00:19:55,059
Microsoft SQL Server Oracle will just

00:19:49,539 --> 00:19:57,159
say depending on the on the language in

00:19:55,059 --> 00:20:01,870
August using a random aggregate function

00:19:57,159 --> 00:20:04,929
well yes but there is no such function

00:20:01,870 --> 00:20:08,679
as random for for a calm selector

00:20:04,929 --> 00:20:12,299
professionally yeah so I guess see for

00:20:08,679 --> 00:20:15,399
some people it's a feature exactly so

00:20:12,299 --> 00:20:16,990
this will not work because as I said it

00:20:15,399 --> 00:20:24,700
will not be able to collapse those

00:20:16,990 --> 00:20:27,789
values something definitive and another

00:20:24,700 --> 00:20:30,970
thing you would want to do with this you

00:20:27,789 --> 00:20:34,210
know set is ordered because while it

00:20:30,970 --> 00:20:36,010
seems logical that you know you insert

00:20:34,210 --> 00:20:37,840
your data one after another so you write

00:20:36,010 --> 00:20:40,240
the first row at the second or third row

00:20:37,840 --> 00:20:42,070
it would be coming out in the same order

00:20:40,240 --> 00:20:46,690
but this section not guaranteed in

00:20:42,070 --> 00:20:49,269
almost any database including things

00:20:46,690 --> 00:20:51,580
like you know like simple single user

00:20:49,269 --> 00:20:53,830
database like circulate even there if

00:20:51,580 --> 00:20:55,960
you insert one two three four you're not

00:20:53,830 --> 00:20:57,880
guarantee that you're going to get one

00:20:55,960 --> 00:21:00,220
two three four in the same order back so

00:20:57,880 --> 00:21:03,090
if you care about your order you have to

00:21:00,220 --> 00:21:07,570
specify and the criteria are the same as

00:21:03,090 --> 00:21:11,679
order by so sorry ass good-bye so it is

00:21:07,570 --> 00:21:16,720
a column an expression or a mix day off

00:21:11,679 --> 00:21:20,200
and this how it looks when you order by

00:21:16,720 --> 00:21:24,580
experience so we get our employees but

00:21:20,200 --> 00:21:26,409
they are ordered by numerical values and

00:21:24,580 --> 00:21:29,889
a little same thing pretty much about

00:21:26,409 --> 00:21:33,580
any database is that order by will work

00:21:29,889 --> 00:21:36,700
balls for alphanumeric and numeric

00:21:33,580 --> 00:21:41,130
values the same it also applies for

00:21:36,700 --> 00:21:43,299
greater or smaller and it applies for

00:21:41,130 --> 00:21:46,659
pretty much anything that has to deal

00:21:43,299 --> 00:21:48,159
with with order you can not care just

00:21:46,659 --> 00:21:50,260
like important more or less you cannot

00:21:48,159 --> 00:21:52,720
care whether this numeric value or

00:21:50,260 --> 00:21:54,780
whether this thing value and will do the

00:21:52,720 --> 00:21:58,200
right thing

00:21:54,780 --> 00:22:04,440
so hmm let's put everything into it

00:21:58,200 --> 00:22:07,920
short so far together we have this query

00:22:04,440 --> 00:22:10,410
we have a selector that has a single

00:22:07,920 --> 00:22:12,990
column and then it has an aggregate

00:22:10,410 --> 00:22:18,480
function or a different column if names

00:22:12,990 --> 00:22:22,530
it we have a condition everybody with

00:22:18,480 --> 00:22:25,740
experience less than nine we have a

00:22:22,530 --> 00:22:30,080
group so we're going to compress some of

00:22:25,740 --> 00:22:34,770
the rows and then we're going to order

00:22:30,080 --> 00:22:37,760
by another aggregate which we set it

00:22:34,770 --> 00:22:41,820
higher up but this time we're going to

00:22:37,760 --> 00:22:45,600
turn it round so by default order by

00:22:41,820 --> 00:22:47,220
orders ascend agree with desk it will

00:22:45,600 --> 00:22:55,010
order everything the other way round

00:22:47,220 --> 00:23:00,560
this will return what we expect so first

00:22:55,010 --> 00:23:03,030
the condition is executed entire table

00:23:00,560 --> 00:23:04,380
this role is thrown way and this roster

00:23:03,030 --> 00:23:10,730
on way because they don't satisfy the

00:23:04,380 --> 00:23:14,280
experiences as a night then we get to

00:23:10,730 --> 00:23:18,090
collapsing the set that we got to

00:23:14,280 --> 00:23:20,070
something so we have we're left with two

00:23:18,090 --> 00:23:24,930
rows in the java department and two rows

00:23:20,070 --> 00:23:30,300
in the.net department and then given

00:23:24,930 --> 00:23:32,670
those sets subsets of data we are

00:23:30,300 --> 00:23:36,030
running the max experience function on

00:23:32,670 --> 00:23:38,010
them and then we are ordering by the

00:23:36,030 --> 00:23:44,810
value of this function as well and this

00:23:38,010 --> 00:23:46,740
what we get paid simple sauce so far now

00:23:44,810 --> 00:23:50,580
sorry

00:23:46,740 --> 00:23:54,360
to recap how all of this works and this

00:23:50,580 --> 00:23:55,710
is important in terms of when you build

00:23:54,360 --> 00:23:58,110
complex queries you always have to

00:23:55,710 --> 00:23:59,940
remember that this is the order it

00:23:58,110 --> 00:24:01,590
varies from time to time but this is

00:23:59,940 --> 00:24:05,160
general door them in which your query

00:24:01,590 --> 00:24:08,010
will execute so always your condition

00:24:05,160 --> 00:24:09,960
will fire first it will be in a sense of

00:24:08,010 --> 00:24:13,679
horizontal filter it will throw rolls

00:24:09,960 --> 00:24:17,190
out this way and then it will collapse

00:24:13,679 --> 00:24:20,280
the horizontally which means that if we

00:24:17,190 --> 00:24:23,280
have the same values it will compress

00:24:20,280 --> 00:24:25,710
them down to a single subset then who

00:24:23,280 --> 00:24:27,690
order them and only then it will see

00:24:25,710 --> 00:24:29,970
what it actually wants to vertically

00:24:27,690 --> 00:24:34,740
select in terms of column slices out of

00:24:29,970 --> 00:24:37,530
this data and at this point if you

00:24:34,740 --> 00:24:39,720
decide to select stuff that could not be

00:24:37,530 --> 00:24:41,580
collapsed by the group by that you

00:24:39,720 --> 00:24:43,679
specified if you specified one at this

00:24:41,580 --> 00:24:45,540
point you will get an exception but

00:24:43,679 --> 00:24:53,700
other than that everything else will

00:24:45,540 --> 00:24:57,870
work the way you expect and there is

00:24:53,700 --> 00:25:00,210
another piece of extra sugar so to speak

00:24:57,870 --> 00:25:05,040
which is called having and what it does

00:25:00,210 --> 00:25:07,170
is after all of this is taking hear of

00:25:05,040 --> 00:25:13,440
it basically takes an extra where

00:25:07,170 --> 00:25:15,690
condition over here and what it will do

00:25:13,440 --> 00:25:17,490
is it will after everything is collapse

00:25:15,690 --> 00:25:19,200
and after everything is ordered and

00:25:17,490 --> 00:25:20,970
everything is selected down to the

00:25:19,200 --> 00:25:23,970
columns and rows that you wanted it

00:25:20,970 --> 00:25:27,150
wouldn't an extra condition on top of

00:25:23,970 --> 00:25:30,809
that normally this is not very useful

00:25:27,150 --> 00:25:32,820
and I was going to show you later on but

00:25:30,809 --> 00:25:36,540
this slight burn so we'll see what when

00:25:32,820 --> 00:25:41,250
we get the rotor gondal and and here I'm

00:25:36,540 --> 00:25:44,520
put adding limits which is a lie because

00:25:41,250 --> 00:25:47,010
pretty much limits will work only on two

00:25:44,520 --> 00:25:48,929
databases of the entire landscape the

00:25:47,010 --> 00:25:51,570
dailies and because we'll definitely

00:25:48,929 --> 00:25:53,250
have time we'll look into what other

00:25:51,570 --> 00:25:56,820
limit dialects are out there in the

00:25:53,250 --> 00:25:58,190
world and how it's actually how bad can

00:25:56,820 --> 00:26:02,840
it do

00:25:58,190 --> 00:26:09,470
so is another quiz what does this select

00:26:02,840 --> 00:26:16,759
given our know here is our data set what

00:26:09,470 --> 00:26:27,100
does this have done okay everything

00:26:16,759 --> 00:26:27,100
meaning what no it turns 42 how

00:26:33,610 --> 00:26:40,970
precisely precisely this is what it is

00:26:38,480 --> 00:26:43,250
going to return it is going to give 42

00:26:40,970 --> 00:26:44,899
on the tab and who can just just like

00:26:43,250 --> 00:26:47,600
everything else as wise qualify the

00:26:44,899 --> 00:26:50,720
score name because we did not give it an

00:26:47,600 --> 00:26:52,610
alias so to call the code the column 42

00:26:50,720 --> 00:26:55,070
as we've been forced to look for every

00:26:52,610 --> 00:26:57,409
single row because as you saw earlier

00:26:55,070 --> 00:27:01,159
what's going to happen is I get the

00:26:57,409 --> 00:27:03,950
source we apply this which doesn't exist

00:27:01,159 --> 00:27:06,019
in our case we apply this resent exists

00:27:03,950 --> 00:27:09,970
in our case there is no order and then

00:27:06,019 --> 00:27:13,070
goes and says okay i'm going to select

00:27:09,970 --> 00:27:16,389
those columns there are no cons we

00:27:13,070 --> 00:27:19,970
specify we just say select me this a

00:27:16,389 --> 00:27:22,250
constant 42 but the amount of rose is

00:27:19,970 --> 00:27:25,070
still seven that's why we actually get

00:27:22,250 --> 00:27:28,220
seven photos back and this consistent on

00:27:25,070 --> 00:27:30,529
Christmas every database now this is a

00:27:28,220 --> 00:27:34,029
constant right well that's not very

00:27:30,529 --> 00:27:36,710
useful what if we want to do an

00:27:34,029 --> 00:27:39,169
expression in there how else work and

00:27:36,710 --> 00:27:43,820
actually does work so what we do here is

00:27:39,169 --> 00:27:49,250
we select an actual column and we select

00:27:43,820 --> 00:27:53,659
a function account now if you go back to

00:27:49,250 --> 00:27:56,600
how things work this stuff is executed

00:27:53,659 --> 00:28:01,779
before your selector that's was very

00:27:56,600 --> 00:28:01,779
important so what's going to happen is

00:28:02,890 --> 00:28:10,900
we get our set of data there is no

00:28:07,730 --> 00:28:15,260
condition so we don't do anything then

00:28:10,900 --> 00:28:18,320
we collapse by the partner java the head

00:28:15,260 --> 00:28:21,830
pull then we go back and see what did we

00:28:18,320 --> 00:28:24,200
select from this set that we are holding

00:28:21,830 --> 00:28:26,630
right now so we selected the department

00:28:24,200 --> 00:28:30,650
which already collapsed so there is no

00:28:26,630 --> 00:28:32,030
ambiguity so we can give that back there

00:28:30,650 --> 00:28:36,020
is a count function and this count

00:28:32,030 --> 00:28:40,040
function is going to run across every

00:28:36,020 --> 00:28:41,450
little subset in this group by so what

00:28:40,040 --> 00:28:44,510
we're going to get is we're going to get

00:28:41,450 --> 00:28:46,730
how many developers on the Java how many

00:28:44,510 --> 00:28:54,680
are dead how many are under pull and

00:28:46,730 --> 00:28:56,360
then hmm the last selector here is going

00:28:54,680 --> 00:29:02,030
to be evaluated again for every single

00:28:56,360 --> 00:29:05,060
row but it does not really refer to the

00:29:02,030 --> 00:29:07,580
role in any way it is based to just a

00:29:05,060 --> 00:29:10,280
select count from company so it's going

00:29:07,580 --> 00:29:14,600
to be is for every single row it will

00:29:10,280 --> 00:29:17,000
evaluate to the very same constant more

00:29:14,600 --> 00:29:20,330
or less of how many rows totally are

00:29:17,000 --> 00:29:26,570
there in this set and this what we're

00:29:20,330 --> 00:29:29,660
going to quit to get back now hmm let's

00:29:26,570 --> 00:29:35,270
say we want to get even crazier and we

00:29:29,660 --> 00:29:38,500
want to see how many distinct counts of

00:29:35,270 --> 00:29:41,690
subgroups are there in our database no

00:29:38,500 --> 00:29:46,430
nothing better to do so what we can do

00:29:41,690 --> 00:29:50,030
is we can take more or less this query

00:29:46,430 --> 00:29:56,570
which has one source and has one

00:29:50,030 --> 00:29:59,810
selection and shove it into a source for

00:29:56,570 --> 00:30:03,620
another query so what happens here is

00:29:59,810 --> 00:30:07,100
this again going back to our little

00:30:03,620 --> 00:30:09,020
table we first have the source and then

00:30:07,100 --> 00:30:11,270
we apply all the other stuff well in

00:30:09,020 --> 00:30:16,980
this case

00:30:11,270 --> 00:30:18,750
oops in this case we first need to find

00:30:16,980 --> 00:30:20,520
the source which is from and there is an

00:30:18,750 --> 00:30:22,860
expression here so we're first going to

00:30:20,520 --> 00:30:28,440
consider this expression which will be

00:30:22,860 --> 00:30:31,050
account of every individual Department

00:30:28,440 --> 00:30:33,480
content so in our case will be two two

00:30:31,050 --> 00:30:38,790
and three and then what we're going to

00:30:33,480 --> 00:30:42,510
do we are going to make another query on

00:30:38,790 --> 00:30:44,850
top of this set which is kind of doesn't

00:30:42,510 --> 00:30:48,150
exist anywhere but it is a virtual table

00:30:44,850 --> 00:30:52,110
with one column called CNT and this is

00:30:48,150 --> 00:30:55,110
where the actual aliasing becomes very

00:30:52,110 --> 00:30:56,700
important because on up there on the

00:30:55,110 --> 00:30:58,260
first select you have to refer to what

00:30:56,700 --> 00:30:59,700
you're picking out of this result set

00:30:58,260 --> 00:31:02,070
that does not exist anywhere it's not a

00:30:59,700 --> 00:31:03,750
table it's not you know it's not nothing

00:31:02,070 --> 00:31:05,730
it's just something in memory at this

00:31:03,750 --> 00:31:08,940
point and this how we're going to pull

00:31:05,730 --> 00:31:11,100
out the Condit winter season and then

00:31:08,940 --> 00:31:14,280
again we're going to group by CNT so the

00:31:11,100 --> 00:31:21,390
two two and three will fall down to two

00:31:14,280 --> 00:31:23,820
and three and this works down to more or

00:31:21,390 --> 00:31:26,970
less limited complexity now it will get

00:31:23,820 --> 00:31:31,440
slower with with every single wrap and

00:31:26,970 --> 00:31:33,670
every single extra permutation order

00:31:31,440 --> 00:31:36,500
extra

00:31:33,670 --> 00:31:38,690
collapse or extra condition that you put

00:31:36,500 --> 00:31:40,460
in but in general if you're if you're

00:31:38,690 --> 00:31:43,250
not doing you know on the order of

00:31:40,460 --> 00:31:45,920
hundreds of thousands of rows you are

00:31:43,250 --> 00:31:49,340
actually pretty safe to do this kind of

00:31:45,920 --> 00:31:51,140
more complicated reporting kind of

00:31:49,340 --> 00:31:54,740
queries on your that and it will

00:31:51,140 --> 00:31:56,570
normally perform recently but from

00:31:54,740 --> 00:31:59,290
reasonably I mean you will get your

00:31:56,570 --> 00:32:02,270
answer in under the second muscle thing

00:31:59,290 --> 00:32:07,940
no matter how much stuff you stick on

00:32:02,270 --> 00:32:11,950
top and remember when I said that there

00:32:07,940 --> 00:32:14,210
is no standardized limit for databases

00:32:11,950 --> 00:32:17,780
there are some databases that don't have

00:32:14,210 --> 00:32:20,630
any kind of a keyword to limit the

00:32:17,780 --> 00:32:25,250
result set whatsoever in these cases we

00:32:20,630 --> 00:32:26,840
use this this is a monster query which

00:32:25,250 --> 00:32:29,810
actually software efficient whatsoever

00:32:26,840 --> 00:32:33,110
but it will work universally on any

00:32:29,810 --> 00:32:37,190
single database so let's take this apart

00:32:33,110 --> 00:32:40,670
hmm we have our initial result set which

00:32:37,190 --> 00:32:45,140
is the one we want we based want to get

00:32:40,670 --> 00:32:47,780
every single column out for company but

00:32:45,140 --> 00:32:56,150
we want to limit it to just the top two

00:32:47,780 --> 00:33:01,000
rows now how we can do that we have to

00:32:56,150 --> 00:33:04,790
first of all a figure out somehow how to

00:33:01,000 --> 00:33:07,370
limit not limit how to order what the

00:33:04,790 --> 00:33:09,260
first two rows actually are so we need

00:33:07,370 --> 00:33:11,810
some kind of criteria the criteria in

00:33:09,260 --> 00:33:14,510
this case is employing so the employee

00:33:11,810 --> 00:33:17,600
is the name of the employees unique hmm

00:33:14,510 --> 00:33:21,980
and we can always order the result set

00:33:17,600 --> 00:33:26,840
by it so what we're going to do is we're

00:33:21,980 --> 00:33:32,840
going to get our source look at it and

00:33:26,840 --> 00:33:35,120
for every single role in it do a

00:33:32,840 --> 00:33:37,670
horizontal filter which is aware now

00:33:35,120 --> 00:33:40,460
this way is an expression on its own in

00:33:37,670 --> 00:33:43,090
this fashion will be evaluated for every

00:33:40,460 --> 00:33:43,090
single

00:33:43,559 --> 00:33:50,309
for every single row one by one so it's

00:33:48,899 --> 00:33:52,610
going to happen is is going to get the

00:33:50,309 --> 00:34:04,610
first row and you're going to see what

00:33:52,610 --> 00:34:07,799
is the count of employees that are

00:34:04,610 --> 00:34:09,300
smaller than you so for the first row it

00:34:07,799 --> 00:34:14,490
will actually return a zero there will

00:34:09,300 --> 00:34:20,819
be no employee in this table that will

00:34:14,490 --> 00:34:23,129
be before you so our selector here is

00:34:20,819 --> 00:34:32,849
the basically we get everything from the

00:34:23,129 --> 00:34:36,240
company where hope so brother will get

00:34:32,849 --> 00:34:40,460
everything from the from the table where

00:34:36,240 --> 00:34:43,109
there is nobody else in front of us so

00:34:40,460 --> 00:34:44,819
we will get all the count of all the

00:34:43,109 --> 00:34:46,829
employees that are in front of us so for

00:34:44,819 --> 00:34:48,659
the first one the camp will be zero for

00:34:46,829 --> 00:34:50,129
the second one the count will be 1 for

00:34:48,659 --> 00:34:53,970
the third one that comes will be 2 and

00:34:50,129 --> 00:34:55,859
so on and then we say for every single

00:34:53,970 --> 00:34:59,339
row where this expression is between 0

00:34:55,859 --> 00:35:04,280
and 1 go ahead and return the stuff and

00:34:59,339 --> 00:35:04,280
who will actually get the two rows back

00:35:05,150 --> 00:35:10,160
right see

00:35:14,860 --> 00:35:23,680
all right this is this is where my slide

00:35:18,730 --> 00:35:33,160
deck ends and we have them where we're

00:35:23,680 --> 00:35:40,540
renting is short what we could do is I

00:35:33,160 --> 00:35:43,900
can show you different limit dialects as

00:35:40,540 --> 00:35:46,960
their infinite by DiBiase or we can move

00:35:43,900 --> 00:35:49,140
to questions or if you're entirely bored

00:35:46,960 --> 00:35:54,610
of this talk we can go and get coffee

00:35:49,140 --> 00:36:02,140
I'm really sorry this deck went down yes

00:35:54,610 --> 00:36:05,590
go ahead wait to force having to be able

00:36:02,140 --> 00:36:08,170
to consider a condition that is not

00:36:05,590 --> 00:36:10,090
already selected like is there any way

00:36:08,170 --> 00:36:12,460
to apply a second like I have an act

00:36:10,090 --> 00:36:15,550
like a second where where you want to be

00:36:12,460 --> 00:36:22,610
so you're talking about

00:36:15,550 --> 00:36:27,050
where were we so in this set you're

00:36:22,610 --> 00:36:29,810
asking whether you can you have yes

00:36:27,050 --> 00:36:33,560
which will be another another weird well

00:36:29,810 --> 00:36:37,910
it's another well here ok any question

00:36:33,560 --> 00:36:44,140
is so is there any way to like do can

00:36:37,910 --> 00:36:44,140
give you a having with a the sub query

00:36:44,680 --> 00:36:48,530
language like in other words you haven't

00:36:46,610 --> 00:36:53,930
selected it but you want to apply the

00:36:48,530 --> 00:36:58,580
condition the condition of what you um

00:36:53,930 --> 00:37:01,460
so when you do a having you can only act

00:36:58,580 --> 00:37:04,430
on stuff you've already selected well

00:37:01,460 --> 00:37:06,740
yes because this is what it sees we are

00:37:04,430 --> 00:37:08,360
already here so we basically did our

00:37:06,740 --> 00:37:10,880
collapse which is our order with it our

00:37:08,360 --> 00:37:14,750
vertical selection you can of course

00:37:10,880 --> 00:37:16,430
select extra stuff but this will be the

00:37:14,750 --> 00:37:23,510
same it will kind of mackay the same

00:37:16,430 --> 00:37:24,950
like like this you just want you want to

00:37:23,510 --> 00:37:28,160
select something just for the purpose of

00:37:24,950 --> 00:37:30,230
flying condition to it with having ah

00:37:28,160 --> 00:37:34,700
well then what you're going to do is

00:37:30,230 --> 00:37:38,510
this you're going to wrap an extra query

00:37:34,700 --> 00:37:45,020
and get your selection vertical

00:37:38,510 --> 00:37:47,180
selection down even further you're going

00:37:45,020 --> 00:37:49,370
to put your entire set that you have

00:37:47,180 --> 00:37:51,170
with the extra columns that you have to

00:37:49,370 --> 00:37:54,290
select for whatever reason you know for

00:37:51,170 --> 00:37:55,790
your order or for your for your

00:37:54,290 --> 00:37:59,240
comparison condition or something like

00:37:55,790 --> 00:38:01,100
this and then what you're going to do is

00:37:59,240 --> 00:38:04,550
you're going to get this entire

00:38:01,100 --> 00:38:07,640
expression and select less stuff to

00:38:04,550 --> 00:38:09,110
throw the extra stuff away in fact in

00:38:07,640 --> 00:38:11,170
one of the limit Daleks we have to do

00:38:09,110 --> 00:38:13,370
that we have to write a rap an extra

00:38:11,170 --> 00:38:16,340
selector just to throw the stuff away

00:38:13,370 --> 00:38:21,080
which we just use to order things before

00:38:16,340 --> 00:38:25,099
we say okay this way we cut our set this

00:38:21,080 --> 00:38:27,270
hour limit does this make sense

00:38:25,099 --> 00:38:30,210
yeah it's harder to get back to that

00:38:27,270 --> 00:38:33,089
point because I had this problem trying

00:38:30,210 --> 00:38:36,540
to do crazy DP I see things and I would

00:38:33,089 --> 00:38:39,809
have to battle between where or in

00:38:36,540 --> 00:38:44,490
having I don't think I had the

00:38:39,809 --> 00:38:46,140
opportunity right but but this is this

00:38:44,490 --> 00:38:48,329
is basically universe a way to do what

00:38:46,140 --> 00:38:52,020
you're asking if you have too many too

00:38:48,329 --> 00:38:54,599
many things in your set as you know as a

00:38:52,020 --> 00:38:56,520
vertical set you just wrap it in another

00:38:54,599 --> 00:38:59,250
query and this part is actually pretty

00:38:56,520 --> 00:39:04,020
performance now on MySQL this might

00:38:59,250 --> 00:39:07,319
become a problem and you know my school

00:39:04,020 --> 00:39:08,880
even though it is not the best

00:39:07,319 --> 00:39:11,069
engineered database it is the most

00:39:08,880 --> 00:39:30,180
prevalent database I mean it's easy it's

00:39:11,069 --> 00:39:32,609
kind of HP after that it will see it

00:39:30,180 --> 00:39:37,440
here it will not sit out here it will

00:39:32,609 --> 00:39:41,760
see it then it will only see it on this

00:39:37,440 --> 00:39:45,950
side it will only see a hammock here

00:39:41,760 --> 00:39:50,940
will only see what you selected here

00:39:45,950 --> 00:39:52,980
because having is applied again having

00:39:50,940 --> 00:39:56,099
this applied here your vertical filter

00:39:52,980 --> 00:39:59,339
idea but then you have no hope at that

00:39:56,099 --> 00:40:02,010
point of having a fast query it's just

00:39:59,339 --> 00:40:03,390
gonna be a brute force yes that's why

00:40:02,010 --> 00:40:06,390
that that's why you try not to use

00:40:03,390 --> 00:40:11,369
having in general you pretty much

00:40:06,390 --> 00:40:13,790
answered your own question any other

00:40:11,369 --> 00:40:13,790
questions

00:40:14,740 --> 00:40:21,400
do we want to look at the various limit

00:40:17,890 --> 00:40:27,150
Alex that exists in the world all right

00:40:21,400 --> 00:40:27,150
this is that all right yeah they're so

00:40:29,880 --> 00:40:39,910
all right so limits again our selector

00:40:37,300 --> 00:40:42,970
and at the end the limit is normally

00:40:39,910 --> 00:40:44,560
applied after the after everything after

00:40:42,970 --> 00:40:47,800
the vertical selector after everything

00:40:44,560 --> 00:40:51,280
is the last thing that runs this is what

00:40:47,800 --> 00:40:52,900
I showed you kinda in the in the

00:40:51,280 --> 00:40:56,380
slightest of pseudo you know this kind

00:40:52,900 --> 00:41:00,700
of stuff exists this is only understood

00:40:56,380 --> 00:41:05,619
you know clean simple understandable

00:41:00,700 --> 00:41:07,060
syntax limit by that many and offset by

00:41:05,619 --> 00:41:08,980
that many so for example if you want to

00:41:07,060 --> 00:41:11,320
skip the first three and you want to get

00:41:08,980 --> 00:41:13,590
the next five you will say limit 5

00:41:11,320 --> 00:41:15,640
offset three simple straightforward

00:41:13,590 --> 00:41:21,760
support only by two database in the

00:41:15,640 --> 00:41:26,320
world nothing else will run outta my

00:41:21,760 --> 00:41:27,490
scalp a little different unfortunately

00:41:26,320 --> 00:41:29,290
the fusion is different that you cannot

00:41:27,490 --> 00:41:32,859
use the top one you have to drop off set

00:41:29,290 --> 00:41:35,380
and you have to reverse them and if you

00:41:32,859 --> 00:41:37,690
don't have an offset if this thing is

00:41:35,380 --> 00:41:40,359
zero you can drop it so if you say limit

00:41:37,690 --> 00:41:41,920
5 it behaves like a top one but if you

00:41:40,359 --> 00:41:50,220
have no set you have to use a different

00:41:41,920 --> 00:41:53,830
syntax MySQL PostgreSQL I'd fine Oracle

00:41:50,220 --> 00:41:58,170
sorry microsoft SQL server and db2 and

00:41:53,830 --> 00:42:02,400
in general this is the ansi standard

00:41:58,170 --> 00:42:06,280
limit of sub dialect so this is actually

00:42:02,400 --> 00:42:11,200
part of the standard that supposed every

00:42:06,280 --> 00:42:14,050
rd emesis needs to be able to understand

00:42:11,200 --> 00:42:17,560
it's not understood by nothing besides

00:42:14,050 --> 00:42:19,780
those two database when ottoman talking

00:42:17,560 --> 00:42:22,600
about microsoft SQL server in general

00:42:19,780 --> 00:42:25,000
rules of max max of SQL server 2005 or

00:42:22,600 --> 00:42:26,589
later they will run with that so how

00:42:25,000 --> 00:42:30,609
does this work

00:42:26,589 --> 00:42:34,150
and this actually is exactly your

00:42:30,609 --> 00:42:36,130
question what we have we have to put our

00:42:34,150 --> 00:42:40,390
original select in the very very

00:42:36,130 --> 00:42:43,109
beginning and then we say select

00:42:40,390 --> 00:42:47,739
everything from that but in addition

00:42:43,109 --> 00:42:50,920
give me a magic function which is

00:42:47,739 --> 00:42:53,380
basically a number from starting from

00:42:50,920 --> 00:42:56,650
zero and going to 0 1 2 3 4 5 for every

00:42:53,380 --> 00:43:00,039
row it's kind of like the moon the crazy

00:42:56,650 --> 00:43:03,400
think with the correct where that I

00:43:00,039 --> 00:43:05,019
showed you earlier but this is built

00:43:03,400 --> 00:43:09,549
into the database and supposed is more

00:43:05,019 --> 00:43:13,829
performant so what we do is we get the

00:43:09,549 --> 00:43:19,150
number for every row in the in this set

00:43:13,829 --> 00:43:24,069
we give it an alias and then we say get

00:43:19,150 --> 00:43:26,079
me again everything without this number

00:43:24,069 --> 00:43:27,880
that we just prepare because the user

00:43:26,079 --> 00:43:29,380
didn't ask for it the usual asked for

00:43:27,880 --> 00:43:34,239
five columns they didn't ask for an

00:43:29,380 --> 00:43:36,249
extra like dangling 0 1 2 3 4 5 set of

00:43:34,239 --> 00:43:41,559
numbers so what we need to do is we need

00:43:36,249 --> 00:43:42,819
to generate this number then make

00:43:41,559 --> 00:43:45,369
another sector so it can be thrown away

00:43:42,819 --> 00:43:50,559
but before the strong way there will be

00:43:45,369 --> 00:43:54,039
a horizontal filter which will check and

00:43:50,559 --> 00:43:59,609
return only the rows which are between

00:43:54,039 --> 00:44:02,950
our offset and our limit in terms of

00:43:59,609 --> 00:44:07,049
indexes so that's how that works it's

00:44:02,950 --> 00:44:11,229
not as bad but we offer the down

00:44:07,049 --> 00:44:12,969
skipper's skip first is a variation of

00:44:11,229 --> 00:44:17,140
the limit it's something that's only

00:44:12,969 --> 00:44:20,880
supported by informants again just

00:44:17,140 --> 00:44:23,170
syntax and another interesting thing

00:44:20,880 --> 00:44:25,269
instead of having the stuff at the end

00:44:23,170 --> 00:44:27,489
of the query here we have the stuff at

00:44:25,269 --> 00:44:30,490
the beginning of the query so if we are

00:44:27,489 --> 00:44:33,620
dealing with a bound

00:44:30,490 --> 00:44:35,360
bound parameters in DB I which you need

00:44:33,620 --> 00:44:37,690
to make sure that we put them in the

00:44:35,360 --> 00:44:44,300
right place of the of the entire

00:44:37,690 --> 00:44:50,690
execution first skip is for fire button

00:44:44,300 --> 00:44:55,570
interbase can spot the difference select

00:44:50,690 --> 00:44:57,590
skip offset select first skip off sir

00:44:55,570 --> 00:44:59,180
justjust service agreement or that there

00:44:57,590 --> 00:45:01,430
is absolutely no difference whatsoever

00:44:59,180 --> 00:45:03,740
but you have to detect whether your

00:45:01,430 --> 00:45:05,840
database is that and that and neither of

00:45:03,740 --> 00:45:09,740
them will understand the other side go

00:45:05,840 --> 00:45:16,460
figure rownum Oracle and this one's a

00:45:09,740 --> 00:45:19,690
fun one so this is kinda like wrong

00:45:16,460 --> 00:45:24,470
number or over so again a magic function

00:45:19,690 --> 00:45:28,820
that we select and then we throw it away

00:45:24,470 --> 00:45:30,380
and then we do that now why don't we do

00:45:28,820 --> 00:45:34,220
the between thing and the between think

00:45:30,380 --> 00:45:38,720
is shown here now this is how we do it

00:45:34,220 --> 00:45:40,820
in wrong number or and it's pretty but

00:45:38,720 --> 00:45:45,350
it's stay forward but why do we have to

00:45:40,820 --> 00:45:50,210
do that because on Oracle this will be

00:45:45,350 --> 00:45:52,700
about five times slower than this well

00:45:50,210 --> 00:45:56,000
then you ask why don't we just do this

00:45:52,700 --> 00:45:58,270
all the time because what happens here

00:45:56,000 --> 00:45:58,270
is that

00:46:01,530 --> 00:46:08,980
we asked for the index ones here so

00:46:06,130 --> 00:46:12,760
basically we say get me this set of rows

00:46:08,980 --> 00:46:16,120
and give it an index from 0 up for every

00:46:12,760 --> 00:46:22,230
row and then because of because of the

00:46:16,120 --> 00:46:22,230
Oracle optimizer we say compare it to

00:46:22,380 --> 00:46:32,220
the function again what's going to

00:46:28,360 --> 00:46:35,290
happen here is if the set is an ordered

00:46:32,220 --> 00:46:37,120
by something else if basically this set

00:46:35,290 --> 00:46:41,230
right here is not ordered stabling

00:46:37,120 --> 00:46:43,600
Oracle will return in the same statement

00:46:41,230 --> 00:46:45,520
on the close of disc function once and

00:46:43,600 --> 00:46:50,500
twice if we return completely different

00:46:45,520 --> 00:46:52,450
results so the first sub query will be

00:46:50,500 --> 00:46:56,020
ordered one way it will be limited and

00:46:52,450 --> 00:46:59,020
then what it terms after that will be

00:46:56,020 --> 00:47:01,620
completely mixed up for no apparent

00:46:59,020 --> 00:47:04,690
reason and we're going to apply our

00:47:01,620 --> 00:47:07,030
bottom limiter to a completely different

00:47:04,690 --> 00:47:09,910
set and we're going to get back garbage

00:47:07,030 --> 00:47:13,270
so that's why we actually have in the

00:47:09,910 --> 00:47:15,880
basic safety we have to detect if this

00:47:13,270 --> 00:47:19,120
piece in here has a stable order based

00:47:15,880 --> 00:47:22,870
on metadata and decide which one of the

00:47:19,120 --> 00:47:26,680
two we're going to use welcome to

00:47:22,870 --> 00:47:29,940
standards and when there is no offset

00:47:26,680 --> 00:47:32,680
it's easy because there is no way for

00:47:29,940 --> 00:47:35,770
this value to happen we are always going

00:47:32,680 --> 00:47:40,150
to run run them once and that's how that

00:47:35,770 --> 00:47:41,950
works so that's Oracle that's another

00:47:40,150 --> 00:47:44,200
interesting one now you remember

00:47:41,950 --> 00:47:47,500
microsoft SQL server over two thousand

00:47:44,200 --> 00:47:50,200
five supported something that ugly

00:47:47,500 --> 00:47:55,890
abilities works now this thing is a

00:47:50,200 --> 00:47:59,860
variation of is a variation of this

00:47:55,890 --> 00:48:02,770
except it can only say give me the first

00:47:59,860 --> 00:48:09,670
that many of a set it does not have a

00:48:02,770 --> 00:48:13,180
way to support or to express an offset

00:48:09,670 --> 00:48:16,150
so what do we have to do we have to get

00:48:13,180 --> 00:48:19,000
our original pudding we have to get

00:48:16,150 --> 00:48:22,750
everything from the zero from the zeroth

00:48:19,000 --> 00:48:28,059
row all the way to the limit plus offset

00:48:22,750 --> 00:48:33,609
cutoff point then we have to reorder it

00:48:28,059 --> 00:48:36,910
the reverse way and cut it from the

00:48:33,609 --> 00:48:38,619
other side but the user asks for a

00:48:36,910 --> 00:48:41,140
specific order so we have to reorder it

00:48:38,619 --> 00:48:43,930
back the way it came and then attempt to

00:48:41,140 --> 00:48:47,589
use it that's why we have select top

00:48:43,930 --> 00:48:51,760
limit pulse offset then ordered this

00:48:47,589 --> 00:48:57,760
thing in Reverse then cut off to the

00:48:51,760 --> 00:49:03,099
limit order it again and return the

00:48:57,760 --> 00:49:05,890
final set that's microsoft SQL server on

00:49:03,099 --> 00:49:10,540
the 2005 now does anybody see a problem

00:49:05,890 --> 00:49:14,380
with that besides it being slow and not

00:49:10,540 --> 00:49:19,109
very efficient like any anything crazy

00:49:14,380 --> 00:49:24,400
flag okay okay the problem is that

00:49:19,109 --> 00:49:35,950
imagine if we have 5 rows total and also

00:49:24,400 --> 00:49:40,270
asked for is offset to limit for what's

00:49:35,950 --> 00:49:43,059
going to happen is we get here also to

00:49:40,270 --> 00:49:49,210
limit for means six rows so actually get

00:49:43,059 --> 00:49:51,849
the whole set we reverse it we assume

00:49:49,210 --> 00:49:54,609
that we already have it half cut as many

00:49:51,849 --> 00:49:58,180
as we needed but we didn't because the

00:49:54,609 --> 00:50:01,000
set that we asked for is smaller than

00:49:58,180 --> 00:50:03,280
the offset + limit that we requested so

00:50:01,000 --> 00:50:06,040
basically we're requesting it's like

00:50:03,280 --> 00:50:07,540
asking for supplies of an array that is

00:50:06,040 --> 00:50:09,280
smaller than the spice were asking for

00:50:07,540 --> 00:50:12,069
in Perl it will just you know say okay

00:50:09,280 --> 00:50:13,390
this array disarray is too short so I'm

00:50:12,069 --> 00:50:16,119
just not going to give you anything no

00:50:13,390 --> 00:50:19,809
in the case of my soft SQL server what

00:50:16,119 --> 00:50:21,579
you're going to get is rose from the

00:50:19,809 --> 00:50:23,260
previous page like completely unrelated

00:50:21,579 --> 00:50:26,590
rows because there is no way

00:50:23,260 --> 00:50:28,450
by doing this reversal to know whether

00:50:26,590 --> 00:50:33,600
you need to stop somewhere whether

00:50:28,450 --> 00:50:36,190
you're set is actually complete or it's

00:50:33,600 --> 00:50:39,310
half of the second page after the first

00:50:36,190 --> 00:50:42,400
page kind of thing and all we can do is

00:50:39,310 --> 00:50:46,560
just warn about it because there is just

00:50:42,400 --> 00:50:51,190
physically no way to detect that well

00:50:46,560 --> 00:50:53,050
either that or you know here are

00:50:51,190 --> 00:50:54,850
billable billable hours and you know we

00:50:53,050 --> 00:50:58,300
can fix your application of different

00:50:54,850 --> 00:51:01,920
weight kind of thing so how does this

00:50:58,300 --> 00:51:06,760
stuff relate to cross that's

00:51:01,920 --> 00:51:09,160
accomplished well a cursor will not help

00:51:06,760 --> 00:51:13,030
you with pages a cursor is just a way

00:51:09,160 --> 00:51:15,160
for a relational database or you know

00:51:13,030 --> 00:51:18,100
any kind of engineer you know not just a

00:51:15,160 --> 00:51:19,930
demon Adam EMS you know any kind

00:51:18,100 --> 00:51:24,580
of noise quell any kind of really

00:51:19,930 --> 00:51:27,850
network-based thingy will we are

00:51:24,580 --> 00:51:32,500
obtained cool any network basting it

00:51:27,850 --> 00:51:34,300
will basically give you a way to kinda

00:51:32,500 --> 00:51:37,000
synchronously ask for more results so

00:51:34,300 --> 00:51:38,740
while while they travel on the wire you

00:51:37,000 --> 00:51:40,860
can do something with the first set so

00:51:38,740 --> 00:51:44,380
that's what the cursor is but the cursor

00:51:40,860 --> 00:51:47,890
relates to one set so you cannot just

00:51:44,380 --> 00:51:50,680
say okay check me this cursor into you

00:51:47,890 --> 00:51:54,910
know into sets or something like that

00:51:50,680 --> 00:51:57,370
and actually we are done already discuss

00:51:54,910 --> 00:52:00,280
this one and that's the insanity we have

00:51:57,370 --> 00:52:01,900
to deal with so I guess we're out of

00:52:00,280 --> 00:52:04,590
time thank you very much and sorry for

00:52:01,900 --> 00:52:04,590
the bus presentation

00:52:05,740 --> 00:52:07,800
you

00:52:15,990 --> 00:52:18,050

YouTube URL: https://www.youtube.com/watch?v=63_MGcsXEzs


