Title: Nick Patch (‎patch‎) - Unicode Beyond Just Characters: Localization with the CLDR
Publication date: 2014-06-23
Playlist: YAPC::NA 2014
Description: 
	Unicode is much more than just characters. The Unicode Consortium defines open standards for collating, parsing, and formatting data in much of the world's languages. The Common Locale Data Repository (CLDR) is the largest standard repository of locale data along with specifications for its use and is a powerful resource for software localization. Unicode CLDR is quickly becoming the de facto locale standard with widespread use among companies including Google, Apple, and IBM; projects ranging from Linux distributions to Wikipedia; and increasing support in many programming languages.

This talk will provide an introduction to software localization with the CLDR, highlight several CLDR-based CPAN projects, demonstrate how Shutterstock uses and contributes to them, and discuss the remaining work for the Perl community to provide first-class CLDR support.
Captions: 
	00:00:07,880 --> 00:00:14,690
cldr on so first off I work at

00:00:12,179 --> 00:00:16,440
Shutterstock I in New York on the

00:00:14,690 --> 00:00:18,840
international team where we

00:00:16,440 --> 00:00:21,750
internationalize and localize our web

00:00:18,840 --> 00:00:23,760
applications and services as well as I

00:00:21,750 --> 00:00:25,350
do a lot with multilingual search as I

00:00:23,760 --> 00:00:30,330
was mentioning earlier at lightning

00:00:25,350 --> 00:00:34,050
talks with sorry my computer went to

00:00:30,330 --> 00:00:35,520
sleep so as I was mentioning earlier I

00:00:34,050 --> 00:00:38,719
with the lightning talks and the

00:00:35,520 --> 00:00:38,719
multilingual stemming

00:00:39,559 --> 00:00:47,100
and I've talked a lot at Yap see in the

00:00:42,719 --> 00:00:52,500
past about Unicode and I characters and

00:00:47,100 --> 00:00:55,729
most people know of Dave well my my

00:00:52,500 --> 00:00:55,729
lunch no where is everyone

00:01:01,189 --> 00:01:06,060
thank you so most people think when they

00:01:04,649 --> 00:01:07,590
think of Unicode they think of

00:01:06,060 --> 00:01:09,810
characters and they think of things you

00:01:07,590 --> 00:01:13,200
can do with characters but there's a lot

00:01:09,810 --> 00:01:16,380
more to Unicode than just characters so

00:01:13,200 --> 00:01:18,259
yeah characters characters all sorts of

00:01:16,380 --> 00:01:21,780
characters from all sorts of languages

00:01:18,259 --> 00:01:23,340
Egyptian hieroglyphs all sorts of things

00:01:21,780 --> 00:01:27,869
I don't even know what they mean

00:01:23,340 --> 00:01:29,789
I owe my emoji isn't showing up but yeah

00:01:27,869 --> 00:01:33,030
everyone there's a lot of hype over

00:01:29,789 --> 00:01:34,530
emoji these days and then you know

00:01:33,030 --> 00:01:36,179
people think about things you can do

00:01:34,530 --> 00:01:38,850
with characters as well

00:01:36,179 --> 00:01:40,979
like I'm normalization here we're

00:01:38,850 --> 00:01:44,940
normalizing this form of G to that form

00:01:40,979 --> 00:01:46,769
of G and this Arabic character into that

00:01:44,940 --> 00:01:49,259
other one which is multiple code points

00:01:46,769 --> 00:01:50,700
I there's a lot of things that the

00:01:49,259 --> 00:01:54,899
Unicode specifications

00:01:50,700 --> 00:02:00,810
I say how to handle characters but and

00:01:54,899 --> 00:02:03,330
awesome Perl does Unicode great I've

00:02:00,810 --> 00:02:06,330
talked about a lot of this I in the past

00:02:03,330 --> 00:02:09,119
that unit Perl has the best Unicode

00:02:06,330 --> 00:02:09,750
support in the core out of any language

00:02:09,119 --> 00:02:12,360
out there

00:02:09,750 --> 00:02:16,409
I excellent for regular expressions

00:02:12,360 --> 00:02:18,810
excellent for handling grapheme clusters

00:02:16,409 --> 00:02:21,360
and a lot of things that you just can't

00:02:18,810 --> 00:02:24,330
do in many languages I would say

00:02:21,360 --> 00:02:27,569
matching on Unicode character properties

00:02:24,330 --> 00:02:29,730
any Unicode character property I in

00:02:27,569 --> 00:02:33,930
regular in the core regular expression

00:02:29,730 --> 00:02:36,390
engine I'm but today I'm going to talk

00:02:33,930 --> 00:02:38,640
about the cldr which is more than just

00:02:36,390 --> 00:02:41,849
characters the cldr

00:02:38,640 --> 00:02:44,849
is either the common locale data

00:02:41,849 --> 00:02:48,650
repository and this is like say

00:02:44,849 --> 00:02:51,310
traditional unix locale data on steroids

00:02:48,650 --> 00:02:54,230
it is a massive amount of data and

00:02:51,310 --> 00:02:56,180
standards for how to work with this data

00:02:54,230 --> 00:03:03,019
for all different languages all

00:02:56,180 --> 00:03:07,790
different locales on and let me take a

00:03:03,019 --> 00:03:09,980
step back I make a differentiation here

00:03:07,790 --> 00:03:14,590
between internationalization and

00:03:09,980 --> 00:03:17,500
localization so internationalization is

00:03:14,590 --> 00:03:20,750
building software building applications

00:03:17,500 --> 00:03:24,519
that can support multiple languages

00:03:20,750 --> 00:03:28,269
multiple locales multiple countries and

00:03:24,519 --> 00:03:32,239
localization is actually AI

00:03:28,269 --> 00:03:34,659
localizing for specific locales so for

00:03:32,239 --> 00:03:37,310
example I could write a web application

00:03:34,659 --> 00:03:39,260
that support that could potentially

00:03:37,310 --> 00:03:40,819
support any language in different

00:03:39,260 --> 00:03:43,639
translations and different formatting

00:03:40,819 --> 00:03:45,709
and just apply it in English well I do

00:03:43,639 --> 00:03:48,889
have an internationalized application

00:03:45,709 --> 00:03:53,120
even if say US English is my only locale

00:03:48,889 --> 00:03:55,040
I or I could have a static website that

00:03:53,120 --> 00:03:59,169
I have translated into five different

00:03:55,040 --> 00:04:01,669
language languages well those are all

00:03:59,169 --> 00:04:03,139
localized versions of that website but

00:04:01,669 --> 00:04:05,720
that is not an internationalized

00:04:03,139 --> 00:04:08,030
application I so internationalization

00:04:05,720 --> 00:04:10,370
and localization go hand-in-hand

00:04:08,030 --> 00:04:13,579
first you internationalize your software

00:04:10,370 --> 00:04:15,769
and then as you need to you localize it

00:04:13,579 --> 00:04:18,919
in two different locales a look how

00:04:15,769 --> 00:04:22,490
commonly you could just I perceive a

00:04:18,919 --> 00:04:24,979
locale as a language but sometimes it is

00:04:22,490 --> 00:04:28,630
a set of different things like a

00:04:24,979 --> 00:04:31,190
language and a country because different

00:04:28,630 --> 00:04:32,750
countries use different languages in the

00:04:31,190 --> 00:04:38,270
same language in different ways such as

00:04:32,750 --> 00:04:42,020
I French Canadian French and a French

00:04:38,270 --> 00:04:45,080
from France even the script can change I

00:04:42,020 --> 00:04:47,320
and you have some countries using a

00:04:45,080 --> 00:04:49,970
different script for the same language

00:04:47,320 --> 00:04:52,870
take I've simplified Chinese and

00:04:49,970 --> 00:04:52,870
traditional Chinese

00:04:53,930 --> 00:04:59,970
and at Shutterstock we support 20

00:04:57,750 --> 00:05:06,090
different languages including Korean

00:04:59,970 --> 00:05:08,520
time Japanese Chinese I a lot of

00:05:06,090 --> 00:05:11,639
northern European languages Hungarian

00:05:08,520 --> 00:05:14,460
Turkish and we have to deal with all

00:05:11,639 --> 00:05:17,280
sorts of locale data for this I and

00:05:14,460 --> 00:05:19,800
that's where the Unicode cldr comes into

00:05:17,280 --> 00:05:21,930
play because it makes it so we don't

00:05:19,800 --> 00:05:25,199
have to do as much research we don't

00:05:21,930 --> 00:05:27,360
have to I find out specifically how each

00:05:25,199 --> 00:05:28,949
thing should be formatted in these

00:05:27,360 --> 00:05:31,770
different languages and these different

00:05:28,949 --> 00:05:34,050
countries instead we can just follow the

00:05:31,770 --> 00:05:35,370
standard and we've been implementing a

00:05:34,050 --> 00:05:38,250
lot of open source software and

00:05:35,370 --> 00:05:39,110
releasing it to Sipan to help with using

00:05:38,250 --> 00:05:41,759
the cldr

00:05:39,110 --> 00:05:44,340
because the CLG arm it's really just

00:05:41,759 --> 00:05:48,539
this two things one you've got this

00:05:44,340 --> 00:05:53,189
massive set of data it's all XML data in

00:05:48,539 --> 00:05:54,779
a specific format called ldml and then

00:05:53,189 --> 00:05:55,889
there's the specification to go along

00:05:54,779 --> 00:05:58,319
with it which is a very dense

00:05:55,889 --> 00:06:03,419
specification saying exactly how you use

00:05:58,319 --> 00:06:06,300
this data on some for some people they

00:06:03,419 --> 00:06:08,009
might want to use say a sea pan library

00:06:06,300 --> 00:06:09,930
that implements parts of the

00:06:08,009 --> 00:06:11,669
specification and supplies the data for

00:06:09,930 --> 00:06:13,650
it other people it's completely

00:06:11,669 --> 00:06:16,229
legitimate even if there is a library

00:06:13,650 --> 00:06:18,629
available not to use it and just take

00:06:16,229 --> 00:06:23,940
the pieces of data that you need such as

00:06:18,629 --> 00:06:26,819
on say with my IO prompts well you could

00:06:23,940 --> 00:06:29,310
have an IO prompt where you type Y or n

00:06:26,819 --> 00:06:32,930
for yes or no well obviously that's

00:06:29,310 --> 00:06:35,909
that's English and if we're going to

00:06:32,930 --> 00:06:39,659
supply say an internationalized IO

00:06:35,909 --> 00:06:44,150
prompt I and use the cldr locale data

00:06:39,659 --> 00:06:47,009
with it cldr provides i yes-and-no

00:06:44,150 --> 00:06:49,680
translated into all different languages

00:06:47,009 --> 00:06:52,319
as well as the individual letter that

00:06:49,680 --> 00:06:55,979
you would use for it I so in that case

00:06:52,319 --> 00:07:00,990
you might not want a large module as a

00:06:55,979 --> 00:07:01,420
dependency with say 75 Meg's of locale

00:07:00,990 --> 00:07:03,940
data

00:07:01,420 --> 00:07:06,190
and instead just pick the small pieces

00:07:03,940 --> 00:07:07,660
of data straight from the XML and use it

00:07:06,190 --> 00:07:10,090
from there so that's that would be a

00:07:07,660 --> 00:07:14,640
legitimate use case or even using a

00:07:10,090 --> 00:07:17,410
module that supplies the data and then I

00:07:14,640 --> 00:07:19,350
putting it directly into your

00:07:17,410 --> 00:07:22,990
application or module instead of

00:07:19,350 --> 00:07:23,950
requiring a much larger other module so

00:07:22,990 --> 00:07:25,840
there are a lot of different ways that

00:07:23,950 --> 00:07:31,390
you can use the cldr

00:07:25,840 --> 00:07:34,120
oh and the most traditional way that's

00:07:31,390 --> 00:07:37,510
been around a while on Sipan is this

00:07:34,120 --> 00:07:41,500
module called locales I it's a pretty

00:07:37,510 --> 00:07:46,270
simple module and you just first you

00:07:41,500 --> 00:07:48,220
instantiate your locales object I using

00:07:46,270 --> 00:07:52,570
a locale which can be just a language

00:07:48,220 --> 00:07:56,770
like fr for French or it could be fr -

00:07:52,570 --> 00:07:59,530
CA for Canadian French then it provides

00:07:56,770 --> 00:08:03,520
a bunch of different methods to retrieve

00:07:59,530 --> 00:08:05,800
locale data now with this module it's

00:08:03,520 --> 00:08:09,070
pretty minimalistic a lot of it is just

00:08:05,800 --> 00:08:12,160
I here is the data I want and here is

00:08:09,070 --> 00:08:15,790
what I'm receiving I'm but the cldr

00:08:12,160 --> 00:08:17,650
specification actually has a lot about

00:08:15,790 --> 00:08:19,000
how you format data and it doesn't

00:08:17,650 --> 00:08:21,610
provide much of that so I'm going to get

00:08:19,000 --> 00:08:27,010
into that next but here's an example of

00:08:21,610 --> 00:08:30,670
just requesting the language name of en

00:08:27,010 --> 00:08:32,770
for English in the French locale and

00:08:30,670 --> 00:08:36,700
there you've got English and French and

00:08:32,770 --> 00:08:40,210
here we're requesting the territory name

00:08:36,700 --> 00:08:42,450
for us and that's United States in

00:08:40,210 --> 00:08:42,450
French

00:08:44,150 --> 00:08:50,870
now I shudder stock we sell things we

00:08:47,330 --> 00:08:53,240
sell these subscriptions for stock

00:08:50,870 --> 00:08:55,190
photography and other stock medium so we

00:08:53,240 --> 00:08:57,170
have a lot of prices that we have to

00:08:55,190 --> 00:08:59,029
deal with and we have it in all

00:08:57,170 --> 00:09:02,810
different languages and all different

00:08:59,029 --> 00:09:06,470
currencies I these display formats can

00:09:02,810 --> 00:09:08,600
vary drastically from different language

00:09:06,470 --> 00:09:10,970
language and also from different country

00:09:08,600 --> 00:09:13,520
to country I this is one of the more

00:09:10,970 --> 00:09:15,890
important bio parts to not just use

00:09:13,520 --> 00:09:17,690
language but to use a full locale that

00:09:15,890 --> 00:09:20,120
includes a language and a country

00:09:17,690 --> 00:09:21,620
because some countries would expect

00:09:20,120 --> 00:09:23,390
certain currencies to be displayed

00:09:21,620 --> 00:09:27,020
certain ways and other ones different

00:09:23,390 --> 00:09:31,130
ways so here for example what we've just

00:09:27,020 --> 00:09:35,300
got our English pricing page in u.s.

00:09:31,130 --> 00:09:37,850
dollars and here was still that US

00:09:35,300 --> 00:09:41,089
dollars just for for these examples but

00:09:37,850 --> 00:09:43,330
I Italian and you can see that we've

00:09:41,089 --> 00:09:49,400
switched over to periods for your

00:09:43,330 --> 00:09:53,020
grouping separator and and that's you

00:09:49,400 --> 00:09:56,839
know the US dollar sign at the end there

00:09:53,020 --> 00:09:59,360
then a Russian here where we have a

00:09:56,839 --> 00:10:02,980
space a non-breaking space as our

00:09:59,360 --> 00:10:02,980
thousands grouping separator

00:10:03,600 --> 00:10:09,720
and here what am I even looking at

00:10:11,350 --> 00:10:17,480
yeah I think this is Norwegian I some

00:10:14,860 --> 00:10:20,960
here I guess it would be more natural

00:10:17,480 --> 00:10:23,750
just to say us deep let's take a look at

00:10:20,960 --> 00:10:26,510
how we powered this because I there was

00:10:23,750 --> 00:10:28,880
nothing implementing this section of the

00:10:26,510 --> 00:10:32,750
cldr specification on Sipan so we I

00:10:28,880 --> 00:10:36,050
built CLD our number and with CLD our

00:10:32,750 --> 00:10:38,300
number first you instantiate your CLD

00:10:36,050 --> 00:10:41,720
our number I object

00:10:38,300 --> 00:10:45,490
and you pass in your look how I we're

00:10:41,720 --> 00:10:45,490
starting off with es for Spanish

00:10:47,020 --> 00:10:54,760
now we're requesting a decimal formatter

00:10:50,470 --> 00:11:01,860
just for you know decimal numbers and I

00:10:54,760 --> 00:11:04,209
formatting I 1234 0.5 which in Spanish I

00:11:01,860 --> 00:11:07,330
this is what you'd receive for the

00:11:04,209 --> 00:11:09,730
default Spanish locale with a space for

00:11:07,330 --> 00:11:11,970
your thousand separator and a comma for

00:11:09,730 --> 00:11:15,430
your decimal separator

00:11:11,970 --> 00:11:17,380
but in Mexican Spanish they actually do

00:11:15,430 --> 00:11:19,360
it like we would expect in English so

00:11:17,380 --> 00:11:23,380
that's why it's important where if you

00:11:19,360 --> 00:11:25,720
are supporting Spanish in Mexico I or in

00:11:23,380 --> 00:11:29,350
many other Latin American Spanish

00:11:25,720 --> 00:11:32,410
locales you it's so important to also

00:11:29,350 --> 00:11:34,600
specify the country in there because I

00:11:32,410 --> 00:11:37,000
it just would not be a natural

00:11:34,600 --> 00:11:40,200
experience for someone from Mexico

00:11:37,000 --> 00:11:40,200
viewing these numbers

00:11:40,740 --> 00:11:45,960
here's Arabic by Arabic uses a

00:11:44,310 --> 00:11:48,900
completely different numbering system

00:11:45,960 --> 00:11:52,580
it's still a decimal number system but

00:11:48,900 --> 00:11:52,580
completely different characters and

00:11:53,990 --> 00:11:59,760
actually the thousand separator I

00:11:56,250 --> 00:12:03,360
believe isn't always well it's not

00:11:59,760 --> 00:12:06,060
always used in in our numbers either our

00:12:03,360 --> 00:12:08,160
Western Arabic numerals I

00:12:06,060 --> 00:12:10,080
but in these Eastern Arabic numerals

00:12:08,160 --> 00:12:12,510
it's a even a little less common so you

00:12:10,080 --> 00:12:16,080
could this is very customizable you

00:12:12,510 --> 00:12:23,640
could turn that off for example by I by

00:12:16,080 --> 00:12:26,580
unsetting your grouping assign now we

00:12:23,640 --> 00:12:29,010
get into Bengali and things get a little

00:12:26,580 --> 00:12:31,730
different it's not really a thousand

00:12:29,010 --> 00:12:34,860
separator it's a a grouping separator

00:12:31,730 --> 00:12:38,160
because in Bengali and a lot of Indian

00:12:34,860 --> 00:12:40,770
languages the first group is three

00:12:38,160 --> 00:12:43,410
digits and then each group after that is

00:12:40,770 --> 00:12:46,160
two digits so you keep on going it's

00:12:43,410 --> 00:12:50,580
three two two two and so on

00:12:46,160 --> 00:12:52,500
this even supports well yeah this

00:12:50,580 --> 00:12:55,640
supports setting a primary grouping

00:12:52,500 --> 00:12:59,420
separate or primary grouping digits and

00:12:55,640 --> 00:12:59,420
secondary grouping digits

00:13:01,520 --> 00:13:07,740
then we've got a percent for matter I

00:13:04,380 --> 00:13:10,530
hear we're requesting a Turkish percent

00:13:07,740 --> 00:13:12,960
for matter because percents a lot of

00:13:10,530 --> 00:13:14,910
people don't realize this percents can I

00:13:12,960 --> 00:13:19,320
be displayed in completely different

00:13:14,910 --> 00:13:22,380
formats for different locales so we want

00:13:19,320 --> 00:13:24,840
5% we pass in point zero five and in

00:13:22,380 --> 00:13:27,450
Turkish they flip the order of the

00:13:24,840 --> 00:13:32,400
number and the % they put the % to the

00:13:27,450 --> 00:13:34,950
left of the number and in Arabic this is

00:13:32,400 --> 00:13:38,600
slightly different % altogether that's

00:13:34,950 --> 00:13:38,600
that's a different character entirely

00:13:38,690 --> 00:13:44,940
and it French both the little closer to

00:13:42,870 --> 00:13:47,100
English but we put a space in there and

00:13:44,940 --> 00:13:48,480
generally in any of these formats when

00:13:47,100 --> 00:13:51,180
you see a space it'll be a non-breaking

00:13:48,480 --> 00:13:54,180
space just because you don't want those

00:13:51,180 --> 00:13:54,630
two parts wrapping one above and one

00:13:54,180 --> 00:13:56,400
below

00:13:54,630 --> 00:14:01,200
you always want them to remain together

00:13:56,400 --> 00:14:03,560
I and this is a little lesser used but

00:14:01,200 --> 00:14:07,020
there's even like a per mil formatter I

00:14:03,560 --> 00:14:09,320
so in that supported in many locales

00:14:07,020 --> 00:14:09,320
here

00:14:10,180 --> 00:14:13,960
so let's get on to the currency for

00:14:12,550 --> 00:14:16,870
matter that I was showing you before in

00:14:13,960 --> 00:14:20,680
those screenshots here we're requesting

00:14:16,870 --> 00:14:23,800
one for English in USD it's very

00:14:20,680 --> 00:14:26,920
important you specify the currency when

00:14:23,800 --> 00:14:28,750
you are formatting I see because if you

00:14:26,920 --> 00:14:31,500
don't I mean what does this number mean

00:14:28,750 --> 00:14:34,210
the number doesn't have any

00:14:31,500 --> 00:14:40,060
representation without both a numeric

00:14:34,210 --> 00:14:41,620
value and a currency because you can't

00:14:40,060 --> 00:14:44,020
just like take something that was

00:14:41,620 --> 00:14:46,930
expected to be in US dollars and then

00:14:44,020 --> 00:14:48,340
format it with Japanese yen without

00:14:46,930 --> 00:14:50,230
doing a conversion first and this does

00:14:48,340 --> 00:14:55,210
not convert numbers this just formats

00:14:50,230 --> 00:15:00,930
numbers so let's format 999 very popular

00:14:55,210 --> 00:15:06,250
price and as you'd expect I we receive

00:15:00,930 --> 00:15:12,520
dollar 999 i when you say just the en

00:15:06,250 --> 00:15:17,860
locale it defaults to I thinking in US

00:15:12,520 --> 00:15:22,090
English but now we specify Canadian

00:15:17,860 --> 00:15:24,670
English en CA and by the way this is the

00:15:22,090 --> 00:15:26,500
locales how you specify them it's case

00:15:24,670 --> 00:15:28,950
insensitive you can use an underscore or

00:15:26,500 --> 00:15:32,410
a dash you commonly see either one used

00:15:28,950 --> 00:15:35,380
so Canadian English and now it's a

00:15:32,410 --> 00:15:36,580
formatting it as US dollar sign because

00:15:35,380 --> 00:15:39,910
you need to differentiate it from

00:15:36,580 --> 00:15:44,170
Canadian dollars and here we've got

00:15:39,910 --> 00:15:47,080
Canadian French but as soon as we switch

00:15:44,170 --> 00:15:49,300
our currency code to see ID for Canadian

00:15:47,080 --> 00:15:52,390
dollars well it gets rid of the US there

00:15:49,300 --> 00:15:54,910
because if you were formatting a dollar

00:15:52,390 --> 00:15:58,650
amount in Canadian French you'd really

00:15:54,910 --> 00:15:58,650
expect it to be a Canadian dollars

00:15:59,240 --> 00:16:05,210
and here's not Bengali again where we're

00:16:01,680 --> 00:16:10,080
setting the currency to Indian rupees

00:16:05,210 --> 00:16:12,330
for yep I and and you see this I you

00:16:10,080 --> 00:16:15,480
know three to two grouping there with I

00:16:12,330 --> 00:16:17,130
the local currency sign most people

00:16:15,480 --> 00:16:22,710
aren't even familiar with that back

00:16:17,130 --> 00:16:26,340
currency sign so let's see how we might

00:16:22,710 --> 00:16:28,050
use these by in translations because if

00:16:26,340 --> 00:16:31,590
you're localizing a site you need a lot

00:16:28,050 --> 00:16:34,950
more than just formatting your numbers

00:16:31,590 --> 00:16:37,320
and prices in different ways in fact the

00:16:34,950 --> 00:16:38,760
main reason I'm so interested in the CLD

00:16:37,320 --> 00:16:41,700
are here is because most people they

00:16:38,760 --> 00:16:44,490
start off with translations but I often

00:16:41,700 --> 00:16:47,340
times you don't see nicely localized

00:16:44,490 --> 00:16:51,000
formats and dates and times and numbers

00:16:47,340 --> 00:16:53,790
and prices so I here let's get into some

00:16:51,000 --> 00:16:56,960
translations where the cldr doesn't have

00:16:53,790 --> 00:16:59,190
anything to do with just random

00:16:56,960 --> 00:17:02,580
translations of text it's only very

00:16:59,190 --> 00:17:04,650
specific locale data I'm what I'm

00:17:02,580 --> 00:17:08,490
showing you here this translate function

00:17:04,650 --> 00:17:10,410
I that isn't anything specific it's just

00:17:08,490 --> 00:17:13,170
for the sake of example you might be

00:17:10,410 --> 00:17:15,630
using get text or make text or an

00:17:13,170 --> 00:17:19,050
in-house translation system but here

00:17:15,630 --> 00:17:21,150
what we're doing is we're calling our

00:17:19,050 --> 00:17:24,480
function for our translation system and

00:17:21,150 --> 00:17:30,960
passing in a string with placeholder

00:17:24,480 --> 00:17:35,040
values some blank to blank of blank what

00:17:30,960 --> 00:17:39,660
we want to see here is a same one

00:17:35,040 --> 00:17:42,030
through 25 of 1500 so then for our

00:17:39,660 --> 00:17:47,700
placeholders we're passing in these

00:17:42,030 --> 00:17:49,500
formatted values for 125 and 1,500 and

00:17:47,700 --> 00:17:54,740
then we got the expected results in

00:17:49,500 --> 00:17:57,140
English 1 225 of 1,500 on

00:17:54,740 --> 00:18:01,059
but there's a shortcut for this because

00:17:57,140 --> 00:18:04,490
I see LD our number supports ranges and

00:18:01,059 --> 00:18:06,590
if you call the range method with two

00:18:04,490 --> 00:18:08,000
different numbers a lower value and a

00:18:06,590 --> 00:18:10,309
higher value although it doesn't really

00:18:08,000 --> 00:18:13,640
matter you can send whatever you want

00:18:10,309 --> 00:18:16,520
it's going to do cldr formatting for

00:18:13,640 --> 00:18:19,940
this because it's the cldr provides a

00:18:16,520 --> 00:18:22,130
range characters and what side each of

00:18:19,940 --> 00:18:24,320
the numbers should be on them so we're

00:18:22,130 --> 00:18:27,500
now we now just have two placeholders

00:18:24,320 --> 00:18:30,920
one for our formatted range and one for

00:18:27,500 --> 00:18:34,160
our formatted total so if we change this

00:18:30,920 --> 00:18:39,920
to Japanese for example the range

00:18:34,160 --> 00:18:43,370
character is the full width tilde and

00:18:39,920 --> 00:18:45,290
there are this very customizable I you

00:18:43,370 --> 00:18:48,590
can change the numbering system here

00:18:45,290 --> 00:18:50,390
we're changing it to full width I or

00:18:48,590 --> 00:18:53,660
it's specified as full wide in the

00:18:50,390 --> 00:18:58,280
standard I end now instead of instead of

00:18:53,660 --> 00:19:01,910
the default which is the ASCII i western

00:18:58,280 --> 00:19:04,670
digits for Japanese we'll get the full

00:19:01,910 --> 00:19:07,630
width once both of them are valid but

00:19:04,670 --> 00:19:10,429
it's just up to what you want to use and

00:19:07,630 --> 00:19:14,420
there's another way to specify that even

00:19:10,429 --> 00:19:19,190
in the locale code itself this is an

00:19:14,420 --> 00:19:24,830
extension to the bcp 47 I language tags

00:19:19,190 --> 00:19:27,350
where at the end you specify - you -

00:19:24,830 --> 00:19:30,290
which says everything after this is the

00:19:27,350 --> 00:19:33,020
Unicode extended language codes and then

00:19:30,290 --> 00:19:34,940
you have key value pairs and U stands

00:19:33,020 --> 00:19:37,990
for numbering system and then full wide

00:19:34,940 --> 00:19:37,990
is the numbering system

00:19:41,260 --> 00:19:47,470
now I'm well I guess first of any

00:19:45,100 --> 00:19:54,240
questions about my formatting numbers

00:19:47,470 --> 00:19:54,240
and prices okay

00:19:54,760 --> 00:20:01,630
so that is actually be translated from

00:19:58,040 --> 00:20:01,630
the your translation system

00:20:04,250 --> 00:20:13,640
yes the word of I guess a special case

00:20:09,100 --> 00:20:16,789
yeah well I would so the word of is not

00:20:13,640 --> 00:20:22,789
translated I that's not part of the cldr

00:20:16,789 --> 00:20:25,510
when we say I'm this of that that is I

00:20:22,789 --> 00:20:28,010
in this example being handled by

00:20:25,510 --> 00:20:30,650
whatever your translation system is and

00:20:28,010 --> 00:20:40,010
by ever what your translators I have

00:20:30,650 --> 00:20:41,510
supplied I'm so the position could be

00:20:40,010 --> 00:20:46,159
reversed so that's what's important

00:20:41,510 --> 00:20:47,809
about that then say we have this I these

00:20:46,159 --> 00:20:50,539
placeholder bra use where it's

00:20:47,809 --> 00:20:51,830
placeholder of placeholder well your

00:20:50,539 --> 00:20:53,120
translators they could potentially

00:20:51,830 --> 00:20:55,490
provide it

00:20:53,120 --> 00:20:57,830
you know placeholder to some other

00:20:55,490 --> 00:21:00,830
characters placeholder one depending on

00:20:57,830 --> 00:21:02,960
the language I personally think that it

00:21:00,830 --> 00:21:05,120
would be great if the CLD are fully

00:21:02,960 --> 00:21:07,909
supported this example because it's such

00:21:05,120 --> 00:21:11,120
a common use case in user interfaces and

00:21:07,909 --> 00:21:13,490
search results and such so I that's

00:21:11,120 --> 00:21:15,080
something that wouldn't that would

00:21:13,490 --> 00:21:16,220
potentially be possible in the future

00:21:15,080 --> 00:21:19,580
with the cldr

00:21:16,220 --> 00:21:22,669
and i i've recently joined the unicode

00:21:19,580 --> 00:21:25,820
consortium and I plan on getting more

00:21:22,669 --> 00:21:29,659
involved with the cldr

00:21:25,820 --> 00:21:32,169
i committee some I that's something I'd

00:21:29,659 --> 00:21:32,169
love to bring up

00:21:32,980 --> 00:21:39,590
you horrible

00:21:35,030 --> 00:21:42,830
four seconds that the transition zone I

00:21:39,590 --> 00:21:44,780
you know I haven't looked into ordinals

00:21:42,830 --> 00:21:46,220
with it someone recently learned about

00:21:44,780 --> 00:21:48,680
saw the Eastern European ones that are

00:21:46,220 --> 00:21:50,270
different for 1213 verses two and three

00:21:48,680 --> 00:21:52,580
so yes so the question is about

00:21:50,270 --> 00:21:56,060
formatting I ordinal numbers and

00:21:52,580 --> 00:21:58,250
although I've used the lingua number

00:21:56,060 --> 00:22:00,650
modules on Sipan I haven't looked into

00:21:58,250 --> 00:22:03,830
that as far as the cldr goes and the CLG

00:22:00,650 --> 00:22:05,510
are it's a massive massive speck and

00:22:03,830 --> 00:22:08,090
amount of data and we're not going to

00:22:05,510 --> 00:22:10,070
nearly cover all of it today but this

00:22:08,090 --> 00:22:11,480
you know gives you a taste for what's

00:22:10,070 --> 00:22:14,510
available and especially what's

00:22:11,480 --> 00:22:18,110
available on Sipan right now and what's

00:22:14,510 --> 00:22:20,720
being worked on on CPM so Unicode

00:22:18,110 --> 00:22:23,950
collate locale this is actually a module

00:22:20,720 --> 00:22:26,360
that is in I bundled with a core Perl

00:22:23,950 --> 00:22:32,000
Unicode collate has been bundled with

00:22:26,360 --> 00:22:34,940
Perl for forever now at least since 5/8

00:22:32,000 --> 00:22:37,490
and I think it was in 514 that eunuch

00:22:34,940 --> 00:22:41,570
aid Unicode collate locale was also

00:22:37,490 --> 00:22:45,470
added him I and this provides localized

00:22:41,570 --> 00:22:49,820
collation which covers sorting and

00:22:45,470 --> 00:22:53,270
comparison of strings and values because

00:22:49,820 --> 00:22:55,130
this sort order can change and what

00:22:53,270 --> 00:22:56,360
character is in front of what character

00:22:55,130 --> 00:22:58,460
or what string is in front of what

00:22:56,360 --> 00:23:01,180
string will change depending on your

00:22:58,460 --> 00:23:01,180
language

00:23:02,260 --> 00:23:06,450
and with this is pretty simple we

00:23:04,390 --> 00:23:09,720
instantiate a Unicode collate locale

00:23:06,450 --> 00:23:14,920
object here we're using a PL for polish

00:23:09,720 --> 00:23:18,220
and then just I sorting a list and

00:23:14,920 --> 00:23:24,130
returning our sorted list I it also has

00:23:18,220 --> 00:23:26,170
I EQ for equality and less LT for less

00:23:24,130 --> 00:23:28,870
than GT for greater than in a bunch of

00:23:26,170 --> 00:23:34,120
different methods that you would want

00:23:28,870 --> 00:23:37,300
for localized comparison I and just for

00:23:34,120 --> 00:23:39,940
an example they're same your i/o with an

00:23:37,300 --> 00:23:44,170
umlaut or a whom let's specifically

00:23:39,940 --> 00:23:47,830
German but Oh with diuresis that would

00:23:44,170 --> 00:23:49,480
sometimes come after an O that would

00:23:47,830 --> 00:23:51,520
sometimes come at the end of the

00:23:49,480 --> 00:23:54,310
alphabet after Z and that would

00:23:51,520 --> 00:23:57,010
sometimes be treated as Oh II and be

00:23:54,310 --> 00:23:58,660
equivalent to OE so it can just bury

00:23:57,010 --> 00:24:00,790
depending on if we're talking about

00:23:58,660 --> 00:24:06,810
German or one of the northern European

00:24:00,790 --> 00:24:08,760
languages or even variants of German and

00:24:06,810 --> 00:24:12,490
date/time

00:24:08,760 --> 00:24:18,610
who here is use date time okay almost

00:24:12,490 --> 00:24:22,630
everyone who here has used the cldr

00:24:18,610 --> 00:24:26,950
based formatting in date time okay we've

00:24:22,630 --> 00:24:29,620
got one for two people I'm some a lot of

00:24:26,950 --> 00:24:33,430
people when they format and specify it

00:24:29,620 --> 00:24:36,490
like a format syntax with it are using

00:24:33,430 --> 00:24:40,540
the more traditional formatting syntax

00:24:36,490 --> 00:24:43,900
but I see LDR also defines its own one

00:24:40,540 --> 00:24:46,690
eye and that's applied in there I don't

00:24:43,900 --> 00:24:49,480
have a lot of use for a different

00:24:46,690 --> 00:24:54,730
formatting syntax what I have used for

00:24:49,480 --> 00:24:58,180
is predefined formats for I different

00:24:54,730 --> 00:25:02,230
types of values say you want a full

00:24:58,180 --> 00:25:05,200
length at a date time then the cldr

00:25:02,230 --> 00:25:08,170
defines exactly what the format syntax

00:25:05,200 --> 00:25:11,110
is for your full length date time it may

00:25:08,170 --> 00:25:12,880
be you know why why why why for the year

00:25:11,110 --> 00:25:15,170
and so on and so forth but it's a whole

00:25:12,880 --> 00:25:18,260
string that's a full form

00:25:15,170 --> 00:25:21,440
I then say you want a narrow width date

00:25:18,260 --> 00:25:23,900
time for use in mobile devices it has

00:25:21,440 --> 00:25:26,240
that as well where it leaves off quite a

00:25:23,900 --> 00:25:31,040
bit a lot of information and it may be

00:25:26,240 --> 00:25:34,600
entirely a numeric or abbreviated well

00:25:31,040 --> 00:25:38,390
date time doesn't support these I

00:25:34,600 --> 00:25:41,420
predefined by full formats instead it

00:25:38,390 --> 00:25:44,030
just knows how to parse them and provide

00:25:41,420 --> 00:25:46,520
your formatted date time using that

00:25:44,030 --> 00:25:51,040
syntax all right but that's where date

00:25:46,520 --> 00:25:55,870
time locale comes in because it's a

00:25:51,040 --> 00:25:58,940
Sipan module that is that provides these

00:25:55,870 --> 00:26:01,880
predefined formats for say your full

00:25:58,940 --> 00:26:05,960
length format of dates and times and

00:26:01,880 --> 00:26:08,270
date times and ranges of dates and so on

00:26:05,960 --> 00:26:11,900
and so forth as well as your standard

00:26:08,270 --> 00:26:13,970
format your short format and your narrow

00:26:11,900 --> 00:26:18,110
format where narrow can even be

00:26:13,970 --> 00:26:21,800
ambiguous in that say I in English tea

00:26:18,110 --> 00:26:24,530
is for Tuesday and T is for Thursday but

00:26:21,800 --> 00:26:26,810
it's sort of known because you're using

00:26:24,530 --> 00:26:28,720
it in a way where if each one is

00:26:26,810 --> 00:26:31,250
available and you've got a very small

00:26:28,720 --> 00:26:33,530
device in front of you so anyway there's

00:26:31,250 --> 00:26:35,870
a lot of locale data for all of these

00:26:33,530 --> 00:26:38,860
different formats in the latest version

00:26:35,870 --> 00:26:44,060
of the CLT our number 25 just the core

00:26:38,860 --> 00:26:46,670
XML data was 76 Meg's and that's why

00:26:44,060 --> 00:26:49,370
I've been implementing individual

00:26:46,670 --> 00:26:52,580
modules like cldr number instead of

00:26:49,370 --> 00:26:56,690
focusing on one large monolithic module

00:26:52,580 --> 00:26:59,660
I'm but there are other projects on

00:26:56,690 --> 00:27:03,660
going out there which I'll show you so

00:26:59,660 --> 00:27:06,660
here's an example with date time where

00:27:03,660 --> 00:27:14,380
first we're instantiating our date/time

00:27:06,660 --> 00:27:16,900
object using our japanese locale and you

00:27:14,380 --> 00:27:19,780
set the locale attribute what that

00:27:16,900 --> 00:27:24,100
actually does is that instantiates a

00:27:19,780 --> 00:27:26,050
date/time locale object and then your

00:27:24,100 --> 00:27:29,650
locale attribute it doesn't just have

00:27:26,050 --> 00:27:34,030
your j a string it has a japanese locale

00:27:29,650 --> 00:27:37,800
object i'm so then I'm calling the

00:27:34,030 --> 00:27:40,690
date-time format full method from the

00:27:37,800 --> 00:27:43,960
date/time locale object stored in the

00:27:40,690 --> 00:27:48,400
locale attribute passing it to format

00:27:43,960 --> 00:27:52,080
cldr which is core date/time and then it

00:27:48,400 --> 00:27:57,190
provides this formatted full-length

00:27:52,080 --> 00:27:59,380
Japanese date/time now one thing I have

00:27:57,190 --> 00:28:02,350
to say though about date time and date

00:27:59,380 --> 00:28:04,990
time locale is that this hasn't been

00:28:02,350 --> 00:28:08,200
updated for recent versions of the cldr

00:28:04,990 --> 00:28:10,540
its date/time locale is about five years

00:28:08,200 --> 00:28:14,500
behind right now and that's really just

00:28:10,540 --> 00:28:16,240
because it well I need someone to I work

00:28:14,500 --> 00:28:18,550
on it and implement these features the

00:28:16,240 --> 00:28:20,559
local the cldr can change a lot in

00:28:18,550 --> 00:28:23,380
between major versions and it can be

00:28:20,559 --> 00:28:26,200
very cumbersome to update modules to

00:28:23,380 --> 00:28:30,250
support those so one project that I'm

00:28:26,200 --> 00:28:34,960
taking on is updating date time and date

00:28:30,250 --> 00:28:37,090
time locale - I support cldr version 25

00:28:34,960 --> 00:28:40,020
and it's a pretty big project if anyone

00:28:37,090 --> 00:28:44,760
else wants to get involved with it i I

00:28:40,020 --> 00:28:44,760
I'd be happy to have help with that

00:28:45,850 --> 00:28:55,940
I'm and as far as certify single

00:28:51,529 --> 00:28:58,570
implementations of the whole cldr speck

00:28:55,940 --> 00:29:03,730
goes there's another project ongoing I

00:28:58,570 --> 00:29:07,549
by a British Perl hacker John Emery

00:29:03,730 --> 00:29:09,200
called locale cldr and the first release

00:29:07,549 --> 00:29:12,230
to Sipan was actually just a few months

00:29:09,200 --> 00:29:16,669
ago I and this project attempts to just

00:29:12,230 --> 00:29:20,390
implement everything it originally was

00:29:16,669 --> 00:29:23,029
released with Perl 5:18 requirements I

00:29:20,390 --> 00:29:25,520
using experimental features which meant

00:29:23,029 --> 00:29:27,620
that well I'm using systems a lot older

00:29:25,520 --> 00:29:30,740
than that I'm using 516 for example and

00:29:27,620 --> 00:29:33,980
I'm even still using 5/8 systems I just

00:29:30,740 --> 00:29:37,370
because well I have to I in certain

00:29:33,980 --> 00:29:40,309
environments so that meant I couldn't

00:29:37,370 --> 00:29:43,220
really use this software but I'm very

00:29:40,309 --> 00:29:46,100
excited about it because it has a lot of

00:29:43,220 --> 00:29:48,440
functionality implemented and in one of

00:29:46,100 --> 00:29:51,700
the recent releases it bumped the

00:29:48,440 --> 00:29:55,850
required Perl version down to Perl 5 10

00:29:51,700 --> 00:29:58,130
except for I'm the text transformation

00:29:55,850 --> 00:30:03,140
which is using the new experimental

00:29:58,130 --> 00:30:05,630
feature I like única or the extended

00:30:03,140 --> 00:30:08,210
character classes in regular expressions

00:30:05,630 --> 00:30:10,940
so you do have to have pro 518 for that

00:30:08,210 --> 00:30:13,549
otherwise pro 510 but as I said I'm

00:30:10,940 --> 00:30:15,919
still using some 5/8 systems as well so

00:30:13,549 --> 00:30:19,399
i i'm trying to help out with this

00:30:15,919 --> 00:30:21,500
project where i can but it it's mainly

00:30:19,399 --> 00:30:25,600
i'm something that i think this one

00:30:21,500 --> 00:30:28,250
developer over in the UK is working on

00:30:25,600 --> 00:30:32,360
the the project that I started up is a

00:30:28,250 --> 00:30:36,200
Perl CLD arm which is I you can check

00:30:32,360 --> 00:30:38,630
out Perl cldr on Twitter I and Perl -

00:30:36,200 --> 00:30:41,929
cldr on github there's our website pearl

00:30:38,630 --> 00:30:44,299
- TLD our github bio where we have all

00:30:41,929 --> 00:30:47,390
the projects that I've been working on

00:30:44,299 --> 00:30:50,120
recently I'm some of the ongoing things

00:30:47,390 --> 00:30:52,490
or ones that are planned arm as I

00:30:50,120 --> 00:30:56,950
mentioned date time date time locale

00:30:52,490 --> 00:30:58,359
there's cldr transform this is for I

00:30:56,950 --> 00:31:01,580
transforming

00:30:58,359 --> 00:31:04,219
transliterating transcribing different

00:31:01,580 --> 00:31:07,669
writing systems from one to another it

00:31:04,219 --> 00:31:11,409
could be from I'm here to Ghana to

00:31:07,669 --> 00:31:16,879
katakana from katakana hiragana from I

00:31:11,409 --> 00:31:20,239
even just like full unicode Latin to

00:31:16,879 --> 00:31:23,479
asking and the cldr defines all of these

00:31:20,239 --> 00:31:25,749
ways to transform text so I what I

00:31:23,479 --> 00:31:29,119
really want to have is a lightweight

00:31:25,749 --> 00:31:31,149
individual module to do this because I

00:31:29,119 --> 00:31:33,019
want to use it in more lightweight

00:31:31,149 --> 00:31:35,029
applications and services where I don't

00:31:33,019 --> 00:31:37,070
even need anymore locale data I don't

00:31:35,029 --> 00:31:40,820
need a format dates or times or anything

00:31:37,070 --> 00:31:43,279
like that I and then another related

00:31:40,820 --> 00:31:44,839
module that I've started up and both of

00:31:43,279 --> 00:31:47,419
these I've got some code for already

00:31:44,839 --> 00:31:51,159
functionality working in it is a CLG are

00:31:47,419 --> 00:31:54,049
segments for a text segmentation

00:31:51,159 --> 00:31:59,539
localized text segmentation specifically

00:31:54,049 --> 00:32:01,639
some I'm segmenting into tokens on

00:31:59,539 --> 00:32:04,489
different levels say on the character

00:32:01,639 --> 00:32:07,309
level because some languages consider

00:32:04,489 --> 00:32:09,979
say CH to be one character in the

00:32:07,309 --> 00:32:13,129
language so if you want to split on

00:32:09,979 --> 00:32:15,710
characters while doing a localized split

00:32:13,129 --> 00:32:16,999
and in some cases you might have CH as a

00:32:15,710 --> 00:32:21,070
single character that you're splitting

00:32:16,999 --> 00:32:24,589
on AI then there is also a word

00:32:21,070 --> 00:32:28,909
segmentation so determining algorithm

00:32:24,589 --> 00:32:32,839
algorithmically what is a word and that

00:32:28,909 --> 00:32:35,029
is very important for I'm doing search

00:32:32,839 --> 00:32:37,399
because say we're indexing text and we

00:32:35,029 --> 00:32:40,700
want to break on each of our words and

00:32:37,399 --> 00:32:44,229
index them and then also search on each

00:32:40,700 --> 00:32:48,630
of those words then there's also a line

00:32:44,229 --> 00:32:52,920
segmentation and sentence segmentation

00:32:48,630 --> 00:32:55,710
I'm one other module is I'd like to get

00:32:52,920 --> 00:33:00,330
a standalone module out there to handle

00:32:55,710 --> 00:33:02,730
just the local codes alone to parse a

00:33:00,330 --> 00:33:05,550
local code and provide all of the

00:33:02,730 --> 00:33:08,310
information so your language your

00:33:05,550 --> 00:33:11,490
optional script your optional country

00:33:08,310 --> 00:33:13,320
and then all of the Unicode extended key

00:33:11,490 --> 00:33:15,090
value pairs like your numbering system

00:33:13,320 --> 00:33:16,740
your coloring the earring system are you

00:33:15,090 --> 00:33:19,380
using the Buddhist calendar and so on

00:33:16,740 --> 00:33:21,750
and so forth and then other modules

00:33:19,380 --> 00:33:24,990
including these ones including CLD our

00:33:21,750 --> 00:33:27,720
number would just require that to parse

00:33:24,990 --> 00:33:29,340
their locale codes and not have to have

00:33:27,720 --> 00:33:32,040
all of this logic that they currently

00:33:29,340 --> 00:33:38,580
have for parsing locale codes and using

00:33:32,040 --> 00:33:40,320
that data and one thing I get on to

00:33:38,580 --> 00:33:41,970
questions is I want to mention what

00:33:40,320 --> 00:33:44,820
other language communities are up to

00:33:41,970 --> 00:33:47,610
with the CLD are some the best

00:33:44,820 --> 00:33:48,660
implementation of the cldr is ICU

00:33:47,610 --> 00:33:52,530
that's the internationalization

00:33:48,660 --> 00:33:55,370
components for unicode i it has a c

00:33:52,530 --> 00:33:59,760
version and a java version i'm

00:33:55,370 --> 00:34:02,550
unfortunately though there is no I C

00:33:59,760 --> 00:34:05,460
route or there's no wrapper for ICU for

00:34:02,550 --> 00:34:08,010
C I I would love to see this in Perl I

00:34:05,460 --> 00:34:11,580
know a lot of people are some people who

00:34:08,010 --> 00:34:14,790
are into Unicode and Perl aren't a big

00:34:11,580 --> 00:34:17,940
fan of ICU because it works on utf-16

00:34:14,790 --> 00:34:22,040
natively instead of utf-8 so you would

00:34:17,940 --> 00:34:24,659
have to convert from utf-8 to utf-16 and

00:34:22,040 --> 00:34:26,550
back again of course a wrapper could do

00:34:24,659 --> 00:34:27,270
that but you know it's extra conversions

00:34:26,550 --> 00:34:30,060
going on there

00:34:27,270 --> 00:34:31,740
I think if someone wanted to take on

00:34:30,060 --> 00:34:33,179
that project I know someone did about a

00:34:31,740 --> 00:34:35,580
decade ago and it hasn't been updated

00:34:33,179 --> 00:34:37,230
since so and it wasn't ever on Sipan if

00:34:35,580 --> 00:34:39,990
someone wants to take on that project

00:34:37,230 --> 00:34:43,050
here's a C and XS programmer that would

00:34:39,990 --> 00:34:45,389
be the most valuable thing to have even

00:34:43,050 --> 00:34:49,310
though I think there's still a lot of

00:34:45,389 --> 00:34:51,750
value in small pure Perl based I

00:34:49,310 --> 00:34:55,290
implement a shion's of just individual

00:34:51,750 --> 00:34:58,700
portions of the CLD arm on

00:34:55,290 --> 00:35:03,210
then some languages like Python and PHP

00:34:58,700 --> 00:35:05,850
they provide wrappers for the ICU for C

00:35:03,210 --> 00:35:08,340
so for example with PHP there's the

00:35:05,850 --> 00:35:13,260
International module which is core as of

00:35:08,340 --> 00:35:14,550
perl PHP 5.3 and if you're a PHP

00:35:13,260 --> 00:35:16,170
programmer that's actually pretty

00:35:14,550 --> 00:35:18,750
exciting because you've got sort of the

00:35:16,170 --> 00:35:21,810
a lot of the cldr at your fingertips

00:35:18,750 --> 00:35:25,620
just by installing the language I'm and

00:35:21,810 --> 00:35:27,750
you know Perl is the best language with

00:35:25,620 --> 00:35:29,640
Unicode support out there it's not the

00:35:27,750 --> 00:35:31,020
best language with cldr support out

00:35:29,640 --> 00:35:33,060
there and I think this is one of the

00:35:31,020 --> 00:35:36,470
most important areas for the Perl

00:35:33,060 --> 00:35:38,910
community to improve on so we can write

00:35:36,470 --> 00:35:41,100
internationalized web applications that

00:35:38,910 --> 00:35:42,390
supports all of the world's locales that

00:35:41,100 --> 00:35:45,630
are defined by the cldr

00:35:42,390 --> 00:35:48,660
I'm some languages like Ruby and

00:35:45,630 --> 00:35:50,850
JavaScript have attempted to do one

00:35:48,660 --> 00:35:54,000
large implementation of the cldr

00:35:50,850 --> 00:35:56,960
so Twitter cldr is what you would use on

00:35:54,000 --> 00:36:00,180
Ruby or JavaScript including if it was a

00:35:56,960 --> 00:36:04,410
straight-up JavaScript or with node and

00:36:00,180 --> 00:36:08,550
I that is all maintained by Twitter

00:36:04,410 --> 00:36:11,910
developers and it has a lot of great

00:36:08,550 --> 00:36:16,230
functionality in it it supports a more

00:36:11,910 --> 00:36:18,660
limited set of locale codes most of them

00:36:16,230 --> 00:36:23,100
are just on the language level and not

00:36:18,660 --> 00:36:25,440
on the language and country level which

00:36:23,100 --> 00:36:29,190
is sort of limiting when it comes to I

00:36:25,440 --> 00:36:33,410
formatting say currencies I even just

00:36:29,190 --> 00:36:37,200
numbers in Mexican Spanish versus I

00:36:33,410 --> 00:36:38,760
peninsular Spanish but there's a I mean

00:36:37,200 --> 00:36:40,260
this is an exciting time for the cldr

00:36:38,760 --> 00:36:43,500
because many of these projects are

00:36:40,260 --> 00:36:45,300
pretty new and are becoming larger

00:36:43,500 --> 00:36:47,100
projects and I look forward to you know

00:36:45,300 --> 00:36:52,770
working more with the Perl community I

00:36:47,100 --> 00:36:55,280
the Perl cldr on Twitter and github I to

00:36:52,770 --> 00:36:57,870
implement a lot more of the cldr

00:36:55,280 --> 00:37:00,260
specification and locale data so any

00:36:57,870 --> 00:37:00,260
questions

00:37:01,600 --> 00:37:06,590
I'm enter the code that you talk about

00:37:04,550 --> 00:37:07,940
is generated from that XML

00:37:06,590 --> 00:37:10,400
do you like parse it when you make the

00:37:07,940 --> 00:37:13,490
module yes so with CLD our number what I

00:37:10,400 --> 00:37:17,800
do is I wrote a script to parse the XML

00:37:13,490 --> 00:37:21,770
and to generate just purl modules for it

00:37:17,800 --> 00:37:25,330
and I with look how cldr

00:37:21,770 --> 00:37:25,330
that's what they're doing as well

00:37:26,980 --> 00:37:29,460
a song

00:37:29,770 --> 00:37:34,960
so there is a JSON version on they the

00:37:33,910 --> 00:37:38,230
cldr

00:37:34,960 --> 00:37:42,040
official releases do not have JSON data

00:37:38,230 --> 00:37:45,010
but there was so much a desire to work

00:37:42,040 --> 00:37:46,660
with JSON instead of XML I because so

00:37:45,010 --> 00:37:49,540
many languages that's just what they do

00:37:46,660 --> 00:37:53,470
nowadays that's the default I like data

00:37:49,540 --> 00:37:56,830
interchange format and there is an

00:37:53,470 --> 00:37:59,740
official tool to convert the XML to JSON

00:37:56,830 --> 00:38:02,350
not the whole data set you specify with

00:37:59,740 --> 00:38:04,360
the tool what you want and then you just

00:38:02,350 --> 00:38:06,490
dump out this JSON files with what you

00:38:04,360 --> 00:38:10,650
want that's what they used with some of

00:38:06,490 --> 00:38:13,960
these projects I'm the tool is a little

00:38:10,650 --> 00:38:15,850
hard to use actually but I I know

00:38:13,960 --> 00:38:18,280
they're working on making it more user

00:38:15,850 --> 00:38:21,550
friendly I with the Ruby project for

00:38:18,280 --> 00:38:24,670
example they I will convert it to Gamal

00:38:21,550 --> 00:38:30,000
and they distribute the look hal data is

00:38:24,670 --> 00:38:30,000
Gamelin yes

00:38:33,029 --> 00:38:38,230
all language and

00:38:34,960 --> 00:38:40,180
territory combinations for example the

00:38:38,230 --> 00:38:41,100
company I work for has house in the

00:38:40,180 --> 00:38:43,470
Netherlands

00:38:41,100 --> 00:38:46,560
of what all the interfacing their own

00:38:43,470 --> 00:38:49,500
language but for international boots

00:38:46,560 --> 00:38:54,050
they want all the numbers in the US

00:38:49,500 --> 00:38:54,050
floor mats well

00:38:55,240 --> 00:39:01,780
some first off one thing about the

00:38:58,450 --> 00:39:04,119
locale code parsing is that you do not

00:39:01,780 --> 00:39:07,330
have to sum I would say with cldr number

00:39:04,119 --> 00:39:10,359
you don't have to supply a locale code

00:39:07,330 --> 00:39:19,960
that is defined in the data you could

00:39:10,359 --> 00:39:23,230
say on a r4 Arabic - us and there

00:39:19,960 --> 00:39:26,680
there's no like American Arabic locale

00:39:23,230 --> 00:39:32,020
data to find but that just means that it

00:39:26,680 --> 00:39:37,089
will fall back to Arabic the which uses

00:39:32,020 --> 00:39:39,790
I think just the modern Arabic and the

00:39:37,089 --> 00:39:43,359
fallback system takes into account the

00:39:39,790 --> 00:39:49,390
specified language and script and

00:39:43,359 --> 00:39:51,940
country I'm then the defaults formats

00:39:49,390 --> 00:39:54,250
you don't have to use them as is say

00:39:51,940 --> 00:39:58,330
with CLD our number there are methods so

00:39:54,250 --> 00:40:00,880
you can further tweak them to your needs

00:39:58,330 --> 00:40:02,680
say you don't want the grouping

00:40:00,880 --> 00:40:05,800
separator well you could remove that or

00:40:02,680 --> 00:40:08,770
say you want to I only use the grouping

00:40:05,800 --> 00:40:11,230
separator when you have more than four

00:40:08,770 --> 00:40:12,940
digits because the Chicago Manual of

00:40:11,230 --> 00:40:14,770
style says don't use a grouping

00:40:12,940 --> 00:40:16,869
separator if you have four digits but

00:40:14,770 --> 00:40:19,960
use it if you have five or more well you

00:40:16,869 --> 00:40:22,300
could say write a wrapper around it that

00:40:19,960 --> 00:40:27,180
does that additional logic for you and

00:40:22,300 --> 00:40:27,180
calls the defined methods in cldr number

00:40:27,640 --> 00:40:30,660
anything else

00:40:31,180 --> 00:40:34,380

YouTube URL: https://www.youtube.com/watch?v=DcPpUnlENAs


