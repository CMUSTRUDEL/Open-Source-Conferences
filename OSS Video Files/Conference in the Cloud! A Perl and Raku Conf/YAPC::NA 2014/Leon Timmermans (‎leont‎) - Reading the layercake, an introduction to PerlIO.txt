Title: Leon Timmermans (‎leont‎) - Reading the layercake, an introduction to PerlIO
Publication date: 2014-06-23
Playlist: YAPC::NA 2014
Description: 
	PerlIO is a part of perl every perl programmer uses, from newbie to Larry himself. Yet still it's something that's rarely given proper attention.

In talk will try to give an overview of the obvious and not so obvious cases.
Captions: 
	00:00:01,190 --> 00:00:07,200
hello everyone I'm here to tell you

00:00:04,319 --> 00:00:10,380
something about proly oh let's start

00:00:07,200 --> 00:00:13,920
with the history pralaya was a new

00:00:10,380 --> 00:00:18,660
feature in Pro 58 which is nowadays 12

00:00:13,920 --> 00:00:20,340
years ago it was quite the essential

00:00:18,660 --> 00:00:24,420
reason for why it was introduced with

00:00:20,340 --> 00:00:29,220
Unicode I'll get back to that in my neck

00:00:24,420 --> 00:00:33,120
and an in the next slide birlea was

00:00:29,220 --> 00:00:36,210
designed by nicking simons you may have

00:00:33,120 --> 00:00:41,000
heard of him he's mainly known for TK he

00:00:36,210 --> 00:00:46,579
also was the original author of encode

00:00:41,000 --> 00:00:46,579
sadly he died a couple of years ago

00:00:46,610 --> 00:00:51,180
which was really really oh I haven't

00:00:49,410 --> 00:00:54,719
known him personally but I'm told he was

00:00:51,180 --> 00:00:56,850
a really great guy and the other problem

00:00:54,719 --> 00:01:01,850
of this was that Pro Leo had a bus

00:00:56,850 --> 00:01:04,260
number of one essentially after he died

00:01:01,850 --> 00:01:06,000
there was no one who maintained it for a

00:01:04,260 --> 00:01:08,310
couple of years until like four or five

00:01:06,000 --> 00:01:10,950
years later I came along and was like

00:01:08,310 --> 00:01:18,420
why aren't these books getting fixed

00:01:10,950 --> 00:01:21,509
I'll fix them myself yeah so Unicode pro

00:01:18,420 --> 00:01:24,540
56 was marketing compatible with Unicode

00:01:21,509 --> 00:01:30,150
it has this nice textin which basically

00:01:24,540 --> 00:01:33,479
says we need to write / leo it supported

00:01:30,150 --> 00:01:36,000
Unicode somewhat ish but if you actually

00:01:33,479 --> 00:01:40,890
tried using it you would write code like

00:01:36,000 --> 00:01:43,140
this apparently or at least this is the

00:01:40,890 --> 00:01:48,329
code that I found from those times

00:01:43,140 --> 00:01:50,579
encode p.m. didn't exist this is and

00:01:48,329 --> 00:01:52,170
this is utf-8 you don't really want to

00:01:50,579 --> 00:01:57,600
know what you had to do for other

00:01:52,170 --> 00:01:59,640
encodings so instead we're using proly

00:01:57,600 --> 00:02:02,369
oh it's just this you basically declared

00:01:59,640 --> 00:02:04,500
this encoding and then the system will

00:02:02,369 --> 00:02:07,770
take care of it for you and this is

00:02:04,500 --> 00:02:09,869
really really great and to be honest

00:02:07,770 --> 00:02:12,730
this is really really essential for

00:02:09,869 --> 00:02:17,000
dealing with unicode

00:02:12,730 --> 00:02:19,850
any in an end user friendly way I mean

00:02:17,000 --> 00:02:22,810
you can use encode specific explicitly

00:02:19,850 --> 00:02:25,190
but how often do people really do that

00:02:22,810 --> 00:02:27,530
most of the time they do this because

00:02:25,190 --> 00:02:33,530
the aisle there is the interface to the

00:02:27,530 --> 00:02:38,360
outside world so what is how does

00:02:33,530 --> 00:02:41,270
pralaya work for Ally o is a stack you

00:02:38,360 --> 00:02:43,280
should think of its working with a stack

00:02:41,270 --> 00:02:48,260
of layers you should think of this as

00:02:43,280 --> 00:02:51,080
every every layer is an object every

00:02:48,260 --> 00:02:53,510
object has a next attribute to the next

00:02:51,080 --> 00:02:57,200
layer until you hit the bottom where

00:02:53,510 --> 00:03:02,090
next is undef that's essentially the

00:02:57,200 --> 00:03:05,960
model and in pearl and pearl you're only

00:03:02,090 --> 00:03:08,840
interacting with the topmost layer the

00:03:05,960 --> 00:03:12,890
rest exists and there's some ability to

00:03:08,840 --> 00:03:14,630
introspect it but unless you're doing

00:03:12,890 --> 00:03:17,060
that explicitly you're just looking at

00:03:14,630 --> 00:03:18,830
the topmost layer and you can add layers

00:03:17,060 --> 00:03:21,650
to the top or remove them from the top

00:03:18,830 --> 00:03:24,680
and if you do really scary stuff you can

00:03:21,650 --> 00:03:26,690
even add add them in the middle or

00:03:24,680 --> 00:03:30,080
remove them but usually it's really a

00:03:26,690 --> 00:03:32,570
topmost thing and the default stack it's

00:03:30,080 --> 00:03:35,660
not very this resolution it doesn't help

00:03:32,570 --> 00:03:38,390
with you I go default layer is the

00:03:35,660 --> 00:03:45,860
default layers are eunuchs and pearl I

00:03:38,390 --> 00:03:52,820
oh if you explicitly if you say like use

00:03:45,860 --> 00:03:56,720
open nothing them open my fool call on

00:03:52,820 --> 00:04:01,010
Raw but it does it adds the raw on top

00:03:56,720 --> 00:04:06,350
of this and then the raw those funny

00:04:01,010 --> 00:04:09,410
things will get back to that later but

00:04:06,350 --> 00:04:12,050
this is important to realize them it's

00:04:09,410 --> 00:04:16,600
its really stacking everything on top of

00:04:12,050 --> 00:04:16,600
each other to get additional behaviors

00:04:16,810 --> 00:04:26,150
the base layer almost always is unix

00:04:22,450 --> 00:04:29,630
unix is really a layer that stays very

00:04:26,150 --> 00:04:31,490
very close the typical unix io semantics

00:04:29,630 --> 00:04:34,310
essentially what says read and says

00:04:31,490 --> 00:04:37,160
right do except that it's using a

00:04:34,310 --> 00:04:38,690
descriptor instead of a file handle the

00:04:37,160 --> 00:04:41,690
scripture is nothing more than a number

00:04:38,690 --> 00:04:45,500
that the colonel associates with that

00:04:41,690 --> 00:04:47,660
handle this is the thing that's doing

00:04:45,500 --> 00:04:53,060
the actual I owe everything pretty much

00:04:47,660 --> 00:04:55,820
everything else is just transforming

00:04:53,060 --> 00:04:58,190
data or buffering data or something

00:04:55,820 --> 00:05:02,600
other something else fancy but not

00:04:58,190 --> 00:05:05,750
actually doing I on there's another base

00:05:02,600 --> 00:05:10,610
layer called win32 and fortunately it's

00:05:05,750 --> 00:05:12,800
hopelessly broken I mean it works

00:05:10,610 --> 00:05:16,160
perfectly fine until you start using

00:05:12,800 --> 00:05:20,300
threads and since fork is using threads

00:05:16,160 --> 00:05:22,580
on Windows that means that in when you

00:05:20,300 --> 00:05:27,130
build a pearl using this then the test

00:05:22,580 --> 00:05:30,650
harness will feel very very very early

00:05:27,130 --> 00:05:33,110
i'm hoping to get this fixed with some

00:05:30,650 --> 00:05:37,580
help because it it could be nice to have

00:05:33,110 --> 00:05:44,539
but no one is using this and then get

00:05:37,580 --> 00:05:47,949
the buffering the pearl io layer is

00:05:44,539 --> 00:05:51,020
really really poorly named because if

00:05:47,949 --> 00:05:55,780
you c colon pearl I oh you would never

00:05:51,020 --> 00:06:02,810
ever guess what the hell it does right

00:05:55,780 --> 00:06:05,870
okay um buffering buffering is very very

00:06:02,810 --> 00:06:08,780
useful for a lot of things that IAM pro

00:06:05,870 --> 00:06:12,260
you do a lot in particular line based I

00:06:08,780 --> 00:06:15,580
oh but also any kind of translation any

00:06:12,260 --> 00:06:19,669
kind of encoding pretty much any kind of

00:06:15,580 --> 00:06:21,199
post-processing you want buffering the

00:06:19,669 --> 00:06:24,199
only thing you don't you want to use it

00:06:21,199 --> 00:06:26,570
for is binary file slurping which is why

00:06:24,199 --> 00:06:29,150
like file slurp is doing having some

00:06:26,570 --> 00:06:32,919
crazy hacks on the inside just basically

00:06:29,150 --> 00:06:36,169
to avoid the entire buffering layer for

00:06:32,919 --> 00:06:38,330
relatively small well like ten twenty

00:06:36,169 --> 00:06:41,460
percent speed increase

00:06:38,330 --> 00:06:47,390
that's worth using like 200 lines of

00:06:41,460 --> 00:06:50,070
code so yes why why do we want buffering

00:06:47,390 --> 00:06:52,350
without buffering this is how you would

00:06:50,070 --> 00:06:56,010
use red line essentially get one

00:06:52,350 --> 00:06:59,490
character see if see if you now have a

00:06:56,010 --> 00:07:01,560
string that ends with your chosen new

00:06:59,490 --> 00:07:04,170
line if you do return that string

00:07:01,560 --> 00:07:06,780
otherwise get another character get

00:07:04,170 --> 00:07:12,150
another character get another character

00:07:06,780 --> 00:07:18,060
etc this is very much correct and very

00:07:12,150 --> 00:07:21,960
much inefficient this is a highly

00:07:18,060 --> 00:07:24,690
simplified and slightly buggy version of

00:07:21,960 --> 00:07:27,240
how you would do it using buffering what

00:07:24,690 --> 00:07:29,730
you do is you peek in the you peek into

00:07:27,240 --> 00:07:34,410
the buffer of the aisle layer you're

00:07:29,730 --> 00:07:37,740
looking for that that new line separator

00:07:34,410 --> 00:07:39,780
if you find it great let's return

00:07:37,740 --> 00:07:41,910
everything and up until that point if

00:07:39,780 --> 00:07:49,590
you don't get everything into your

00:07:41,910 --> 00:07:51,930
collector refreshed buffer try again the

00:07:49,590 --> 00:07:56,190
actual speed increase by doing this is

00:07:51,930 --> 00:07:58,950
is a factor a few hundreds this is this

00:07:56,190 --> 00:08:06,420
is not a minor optimization this is very

00:07:58,950 --> 00:08:10,880
very important unfortunately this code

00:08:06,420 --> 00:08:14,340
is uniquely optimized in pro core and

00:08:10,880 --> 00:08:17,540
when I say uniquely optimized I mean

00:08:14,340 --> 00:08:22,200
it's about a hundred and fifty lines and

00:08:17,540 --> 00:08:32,330
in 150 lines it contains six go to stew

00:08:22,200 --> 00:08:35,250
for labels it's it is very optimized and

00:08:32,330 --> 00:08:39,240
for something I want to do I kind of

00:08:35,250 --> 00:08:43,290
need to be factored that you can guess

00:08:39,240 --> 00:08:50,700
what I think of this not really it's

00:08:43,290 --> 00:08:53,310
it's really that bad so yes essentially

00:08:50,700 --> 00:08:55,790
colon polio is nothing more than boring

00:08:53,310 --> 00:09:00,690
buffering without any kind of

00:08:55,790 --> 00:09:03,420
manipulation of the data this is the

00:09:00,690 --> 00:09:08,760
default on UNIX because UNIX is a same

00:09:03,420 --> 00:09:12,570
operating system then of course there's

00:09:08,760 --> 00:09:18,050
windows which does the carriage return

00:09:12,570 --> 00:09:20,670
line feed does anyone here know why

00:09:18,050 --> 00:09:35,280
Windows is using carriage return line

00:09:20,670 --> 00:09:37,590
feed yes this is for what the original

00:09:35,280 --> 00:09:40,980
reason for windows for doing this is

00:09:37,590 --> 00:09:44,040
because like physical printing terminals

00:09:40,980 --> 00:09:50,030
on CPM like an operating system from

00:09:44,040 --> 00:09:52,800
like 30 35 years ago required this and

00:09:50,030 --> 00:09:55,140
they never got rid of this and now all

00:09:52,800 --> 00:09:59,450
text files and everything terminal

00:09:55,140 --> 00:09:59,450
related is using carriage return newline

00:10:01,700 --> 00:10:09,900
yeah so we have a crl I've layer that is

00:10:07,350 --> 00:10:12,090
doing nothing more than just getting rid

00:10:09,900 --> 00:10:14,670
of old carriage returns before new lines

00:10:12,090 --> 00:10:20,850
on reading and vice versa 7 writing just

00:10:14,670 --> 00:10:25,620
adding them back in except that this is

00:10:20,850 --> 00:10:27,180
implemented very confusingly if you if

00:10:25,620 --> 00:10:29,310
you have a handle and you introspect it

00:10:27,180 --> 00:10:31,860
and you see a CR LF layer you cannot

00:10:29,310 --> 00:10:34,350
assume this is happening because it has

00:10:31,860 --> 00:10:36,960
a flag it can be turned on and off it's

00:10:34,350 --> 00:10:40,700
it's functioning as buffering layer and

00:10:36,960 --> 00:10:43,740
as it transformation layer which is

00:10:40,700 --> 00:10:47,730
extremely confusing when you actually

00:10:43,740 --> 00:10:52,560
want one to know is this raw or not you

00:10:47,730 --> 00:10:56,570
cannot tell from the outside at least

00:10:52,560 --> 00:10:56,570
not without a little C programming

00:11:00,230 --> 00:11:06,330
scalar which is fading basically the

00:11:03,450 --> 00:11:10,290
other base layer that people use this is

00:11:06,330 --> 00:11:15,690
what you when you open like you say open

00:11:10,290 --> 00:11:18,420
my foo angle brackets and then /

00:11:15,690 --> 00:11:23,010
variable you open like fake file handle

00:11:18,420 --> 00:11:29,130
to us to a scalar this is really useful

00:11:23,010 --> 00:11:30,660
and notoriously buggy because it's

00:11:29,130 --> 00:11:33,660
actually speaking and poking into the

00:11:30,660 --> 00:11:37,800
scalar and I've seen some very funny

00:11:33,660 --> 00:11:47,640
bugs here it this it usually works but

00:11:37,800 --> 00:11:50,100
this is worse it's it's very useful it's

00:11:47,640 --> 00:11:54,420
one of those pearl 58 features that's

00:11:50,100 --> 00:11:58,170
real that it's really helpful but I

00:11:54,420 --> 00:11:59,940
really hate implementation that's

00:11:58,170 --> 00:12:04,500
something I'm saying a lot when it comes

00:11:59,940 --> 00:12:07,260
to proly oh that's not me and then

00:12:04,500 --> 00:12:13,770
there's utf-8 and bites did I mention I

00:12:07,260 --> 00:12:16,740
hate them no utf-8 and bite impro as

00:12:13,770 --> 00:12:21,149
some of you may know on scalars there's

00:12:16,740 --> 00:12:24,420
a flag is this string is it Latin one or

00:12:21,149 --> 00:12:28,920
is it utf-8 this is generally considered

00:12:24,420 --> 00:12:32,490
a bad idea guess what pro Leo does it

00:12:28,920 --> 00:12:36,029
has a flag that says the input from this

00:12:32,490 --> 00:12:38,670
handle is Latin one or the input from

00:12:36,029 --> 00:12:44,430
the set or output or this handle is

00:12:38,670 --> 00:12:47,510
utf-8 so when you when you open a file

00:12:44,430 --> 00:12:50,790
with colon utf-8 you're saying I'm

00:12:47,510 --> 00:12:59,519
promising this is utf-8 you don't have

00:12:50,790 --> 00:13:02,279
to check there actually has been at some

00:12:59,519 --> 00:13:04,230
it might have been DEFCON or one of

00:13:02,279 --> 00:13:07,879
those big hacker conference there has

00:13:04,230 --> 00:13:10,980
been a concept exploit of

00:13:07,879 --> 00:13:12,629
getting insecure utf8 in and then

00:13:10,980 --> 00:13:14,190
horribly confusing the regular

00:13:12,629 --> 00:13:17,610
expression engine and then it will

00:13:14,190 --> 00:13:26,339
accept data that it shouldn't accept and

00:13:17,610 --> 00:13:28,560
then you can have exploits so that

00:13:26,339 --> 00:13:30,660
that's one of the more important things

00:13:28,560 --> 00:13:33,779
to remember in this presentation don't

00:13:30,660 --> 00:13:43,050
use colon utf-8 for inputs unless you

00:13:33,779 --> 00:13:47,209
really trust the file hmm yes I'll get

00:13:43,050 --> 00:13:47,209
back to that and get to that in a moment

00:13:47,600 --> 00:13:51,959
the other confusing thing here is that

00:13:49,860 --> 00:13:54,180
if you use get layers it will tell you

00:13:51,959 --> 00:13:58,259
there's a utf-8 layer even though

00:13:54,180 --> 00:14:02,459
there's not it's just a flag I have no

00:13:58,259 --> 00:14:05,970
idea why what you should use instead is

00:14:02,459 --> 00:14:08,370
encoding encoding is actually a full

00:14:05,970 --> 00:14:12,269
layer that's essentially taking input

00:14:08,370 --> 00:14:16,050
from the layer beneath it using code

00:14:12,269 --> 00:14:18,839
p.m. to encode that to code that from

00:14:16,050 --> 00:14:22,949
whatever it was to utf-8 and then pass

00:14:18,839 --> 00:14:25,380
that on which is actually a fairly

00:14:22,949 --> 00:14:28,759
sensible thing to do even if it's not

00:14:25,380 --> 00:14:28,759
the fastest thing to do

00:14:37,610 --> 00:14:43,800
this does lead to some interesting

00:14:39,720 --> 00:14:45,990
issues there had their I was at some

00:14:43,800 --> 00:14:47,940
point one of those long-standing bugs I

00:14:45,990 --> 00:14:53,250
mentioned previously was related to

00:14:47,940 --> 00:14:55,880
encoding and CR LF like I said you have

00:14:53,250 --> 00:15:02,850
to think of pearl I Oh as a stack and

00:14:55,880 --> 00:15:05,630
that means the order matters and Sierra

00:15:02,850 --> 00:15:07,440
left translation and utf-8 are

00:15:05,630 --> 00:15:09,870
compatible with each other because

00:15:07,440 --> 00:15:13,830
they're both essentially a ski

00:15:09,870 --> 00:15:18,480
compatible however encoding that are not

00:15:13,830 --> 00:15:21,000
like you like youth you have 16 hit hit

00:15:18,480 --> 00:15:25,610
issues because what happens is that crl

00:15:21,000 --> 00:15:28,560
f is a perfectly valid bunch of bytes in

00:15:25,610 --> 00:15:34,170
utf-16 that does not mean carriage

00:15:28,560 --> 00:15:38,370
return line feed I think that if it's an

00:15:34,170 --> 00:15:42,360
alliance crl f is some kind of chinese

00:15:38,370 --> 00:15:44,400
character i forgot which one but it's an

00:15:42,360 --> 00:15:46,650
existent and perfectly valid chinese

00:15:44,400 --> 00:15:48,720
character that gets turned that turns

00:15:46,650 --> 00:15:56,520
the rest of the stream into invalids

00:15:48,720 --> 00:15:59,460
utf-16 until the next CEO rlf an

00:15:56,520 --> 00:16:03,540
unaligned it can happen in like a few

00:15:59,460 --> 00:16:05,910
thousand ways I to be honest I don't

00:16:03,540 --> 00:16:10,020
understand why people combine these two

00:16:05,910 --> 00:16:12,800
things I really really do not but

00:16:10,020 --> 00:16:17,540
apparently in the windows world there is

00:16:12,800 --> 00:16:20,520
some kind of convention to do this and

00:16:17,540 --> 00:16:22,140
you have to really realize you have to

00:16:20,520 --> 00:16:24,630
know you have to do it in the right

00:16:22,140 --> 00:16:27,090
order and you have to first disable the

00:16:24,630 --> 00:16:31,590
CR LF using raw then put the encoding

00:16:27,090 --> 00:16:36,720
and then put the CR LF and any other

00:16:31,590 --> 00:16:39,720
order is just is just broken worse yet

00:16:36,720 --> 00:16:42,480
in older person versions of pearl this

00:16:39,720 --> 00:16:43,830
wouldn't even do the right thing on bin

00:16:42,480 --> 00:16:46,910
mode it will do the right thing and open

00:16:43,830 --> 00:16:46,910
but not on bin mode

00:16:47,470 --> 00:16:56,830
uniquely special another fun one is

00:16:52,900 --> 00:17:00,770
encoding mbytes because like i said

00:16:56,830 --> 00:17:04,360
encoding converts anything into utf-8

00:17:00,770 --> 00:17:07,790
and then it will claim this is utf-8

00:17:04,360 --> 00:17:09,680
however if you if you if you say if you

00:17:07,790 --> 00:17:11,570
add the bytes layer you're saying I'm

00:17:09,680 --> 00:17:17,900
promising this layer is returning

00:17:11,570 --> 00:17:19,730
latin-1 so what happens on input is it

00:17:17,900 --> 00:17:22,250
gets converted and then interpreted is

00:17:19,730 --> 00:17:25,459
the wrong thing but that's not half as

00:17:22,250 --> 00:17:28,250
horrible as on output you have valid

00:17:25,459 --> 00:17:31,550
utf-8 it gets converted to Latin one it

00:17:28,250 --> 00:17:35,930
gets interpreted at utf-8 and then

00:17:31,550 --> 00:17:43,250
convert it to whatever this is just

00:17:35,930 --> 00:17:47,240
incomprehensible no Chewbacca like I

00:17:43,250 --> 00:17:49,550
said utf-8 and bites are evil do not use

00:17:47,240 --> 00:17:53,780
it unless you're really really sure of

00:17:49,550 --> 00:17:56,540
what you're doing in this particular

00:17:53,780 --> 00:18:00,950
case what the user would have wanted is

00:17:56,540 --> 00:18:03,920
pop pop is a rarely used but really

00:18:00,950 --> 00:18:08,570
really simple layer that just pops off

00:18:03,920 --> 00:18:10,430
the topmost layer it's one of the

00:18:08,570 --> 00:18:12,590
ironies of the parallel interface is

00:18:10,430 --> 00:18:22,670
that you have to push a pop layer to pop

00:18:12,590 --> 00:18:24,820
it off great and and finally there's raw

00:18:22,670 --> 00:18:28,070
which is the other sensible thing

00:18:24,820 --> 00:18:30,980
because on encoding it will pop it will

00:18:28,070 --> 00:18:33,410
pop off the layer if it's done on most

00:18:30,980 --> 00:18:37,310
other layers it will just turn off utf-8

00:18:33,410 --> 00:18:39,850
and on CR LF it's kind of weird because

00:18:37,310 --> 00:18:43,720
why would you have cross-platform

00:18:39,850 --> 00:18:43,720
consistency who needs that

00:18:45,919 --> 00:18:51,539
again it will turn off the flag and

00:18:48,299 --> 00:18:53,809
windows except that on linux on unix its

00:18:51,539 --> 00:18:56,970
decides well you probably are using a

00:18:53,809 --> 00:18:58,650
pearl i layer underneath so i can just

00:18:56,970 --> 00:19:01,530
pop it off entirely because you still

00:18:58,650 --> 00:19:03,179
have some kind of buffering and windows

00:19:01,530 --> 00:19:08,580
it doesn't because you kind of always

00:19:03,179 --> 00:19:10,770
want some kind of buffering another

00:19:08,580 --> 00:19:13,770
important thing to realize about pearl I

00:19:10,770 --> 00:19:16,230
oh it's open-ended I've just the layers

00:19:13,770 --> 00:19:20,130
I've listed are like the building layers

00:19:16,230 --> 00:19:22,320
that come with pearl but there are

00:19:20,130 --> 00:19:24,780
zillion other things some of them useful

00:19:22,320 --> 00:19:27,659
some of them last useful that you can do

00:19:24,780 --> 00:19:31,289
with it pralaya vayas is a well-known

00:19:27,659 --> 00:19:34,080
one that allows you to write for liar

00:19:31,289 --> 00:19:36,350
layers in pure Pro which means you can

00:19:34,080 --> 00:19:40,590
do like really interesting things

00:19:36,350 --> 00:19:42,450
transformations I've seen someone to

00:19:40,590 --> 00:19:45,750
like bioinformatic will stuff in a pro

00:19:42,450 --> 00:19:49,010
Lyle violator I don't think I think

00:19:45,750 --> 00:19:52,470
that's for adjustment but it's possible

00:19:49,010 --> 00:19:54,390
I'll gzip is another obvious one you can

00:19:52,470 --> 00:19:56,970
just add the GZ player and then pretend

00:19:54,390 --> 00:19:58,260
it's an ordinary file when we even

00:19:56,970 --> 00:20:01,500
though you know it has just been

00:19:58,260 --> 00:20:03,990
unzipped or zip and then there's like

00:20:01,500 --> 00:20:06,510
HTTP which is a cute little module of

00:20:03,990 --> 00:20:09,630
mine that's essentially doing HTTP

00:20:06,510 --> 00:20:11,940
request and then pushing a scalar layer

00:20:09,630 --> 00:20:17,990
and just pretending that everything is

00:20:11,940 --> 00:20:17,990
magical it's an ugly hag but it works

00:20:18,049 --> 00:20:21,809
and I think there should be more

00:20:19,799 --> 00:20:24,000
interesting layers I think like on

00:20:21,809 --> 00:20:26,429
Krypto and on the ssl there could be a

00:20:24,000 --> 00:20:28,049
lot more there are a lot more

00:20:26,429 --> 00:20:32,909
possibilities but no one has ever

00:20:28,049 --> 00:20:37,429
written them and I think I'm out of time

00:20:32,909 --> 00:20:37,429
so I'm going to stop here any questions

00:20:45,400 --> 00:20:51,740
it's not that hard it's basically you

00:20:49,070 --> 00:20:54,280
have to overwrite like them you mainly

00:20:51,740 --> 00:21:00,590
have to override a method that's just

00:20:54,280 --> 00:21:04,310
mucking around with the data it's it it

00:21:00,590 --> 00:21:16,400
that should not be very hard any other

00:21:04,310 --> 00:21:18,620
questions hmm I can't hear you yes I

00:21:16,400 --> 00:21:22,210
have to I have the plan to fix a lot of

00:21:18,620 --> 00:21:22,210
that stuff but that's a lot of work

00:21:31,840 --> 00:21:38,180
closer to one and a half the 2 i'd say

00:21:34,940 --> 00:21:41,480
but but the thing is Nicholas Clarke is

00:21:38,180 --> 00:21:44,690
a very busy man so he could do a lot of

00:21:41,480 --> 00:21:46,990
stuff he doesn't have the time thank you

00:21:44,690 --> 00:21:46,990

YouTube URL: https://www.youtube.com/watch?v=ybTFXG9HWUk


