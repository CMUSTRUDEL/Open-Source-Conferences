Title: Andrew Rodland (‎hobbs‎) - ‎Parsing Made Easyish‎
Publication date: 2014-06-24
Playlist: YAPC::NA 2014
Description: 
	An introduction to Marpa, a parsing library for Perl, and some of the cool ways that it can simplify relatively complicated parsing tasks. Includes a little bit of history and covers improvements made since a previous version of this talk in January 2013.
Captions: 
	00:00:00,000 --> 00:00:05,970
this is parsing made kind of sorta

00:00:02,159 --> 00:00:07,890
easyish using marpa this is the slides

00:00:05,970 --> 00:00:10,769
URL for anybody who's interested in it

00:00:07,890 --> 00:00:12,570
it's also on act and I'm going to start

00:00:10,769 --> 00:00:14,940
with a little bit of an apology I was a

00:00:12,570 --> 00:00:16,830
last minute fill-in on the schedule here

00:00:14,940 --> 00:00:21,000
and so I have written these slides

00:00:16,830 --> 00:00:30,779
mostly but not practice them so we'll

00:00:21,000 --> 00:00:32,489
see how that goes so this is my

00:00:30,779 --> 00:00:35,160
information just if you're not sure if

00:00:32,489 --> 00:00:37,290
you've seen this guy around I'm on IRC

00:00:35,160 --> 00:00:39,690
is Hobbs I'm a roblin and a bunch of

00:00:37,290 --> 00:00:41,910
other places I work for shutterstock

00:00:39,690 --> 00:00:47,850
we're hiring you've probably heard that

00:00:41,910 --> 00:00:50,670
a few times um so just uh for anybody

00:00:47,850 --> 00:00:52,520
anybody in here who's not really sure

00:00:50,670 --> 00:00:55,949
like what is the subject of parsing

00:00:52,520 --> 00:00:57,989
basically if you're taking if you're

00:00:55,949 --> 00:01:00,989
taking data from somewhere it could be

00:00:57,989 --> 00:01:03,870
binary could be textual and you are

00:01:00,989 --> 00:01:05,880
getting information out of it into some

00:01:03,870 --> 00:01:09,750
kind of structured format then you're

00:01:05,880 --> 00:01:12,780
doing parsing and traditionally parsing

00:01:09,750 --> 00:01:16,320
is broken up into phases the first phase

00:01:12,780 --> 00:01:18,750
is called lexing or scanning or

00:01:16,320 --> 00:01:20,729
tokenizing where you look at your

00:01:18,750 --> 00:01:23,430
information and you break it down into

00:01:20,729 --> 00:01:26,340
chunks and you identify what kind of

00:01:23,430 --> 00:01:29,790
thing is this is a number is it an

00:01:26,340 --> 00:01:33,360
operator is a variable is it something

00:01:29,790 --> 00:01:36,509
or other um and then and then parsing

00:01:33,360 --> 00:01:38,340
takes those tokens and it strings them

00:01:36,509 --> 00:01:42,509
together according to some kind of rules

00:01:38,340 --> 00:01:45,390
some kind of grammars and then more

00:01:42,509 --> 00:01:48,329
often than not you end up with a parse

00:01:45,390 --> 00:01:50,640
tree as a result of that and then you

00:01:48,329 --> 00:01:53,549
can take that tree of information and

00:01:50,640 --> 00:01:57,689
you can do something do something more

00:01:53,549 --> 00:02:01,979
useful with it um some of the tools that

00:01:57,689 --> 00:02:03,630
we use in Perl for parsing regular

00:02:01,979 --> 00:02:07,229
expressions Pearl has a great regular

00:02:03,630 --> 00:02:09,470
expression facility so you can you can

00:02:07,229 --> 00:02:13,710
build your own um there's a pattern em

00:02:09,470 --> 00:02:16,140
etc / GC which lets you check

00:02:13,710 --> 00:02:17,850
a given point in my input like check a

00:02:16,140 --> 00:02:19,740
whole bunch of regular expressions do

00:02:17,850 --> 00:02:21,090
any of them match yes if I found one

00:02:19,740 --> 00:02:23,430
that matches great i'm going to go ahead

00:02:21,090 --> 00:02:26,250
and do something if not I'm going to try

00:02:23,430 --> 00:02:29,400
some other ones and that's such a cool

00:02:26,250 --> 00:02:34,230
pattern that Paul Evans created a module

00:02:29,400 --> 00:02:36,810
called parser mgc from the mgc which is

00:02:34,230 --> 00:02:38,700
basically a very simple kind of

00:02:36,810 --> 00:02:41,460
recursive descent parser just built

00:02:38,700 --> 00:02:45,330
around that pattern and and combining

00:02:41,460 --> 00:02:49,620
them together um there's yap which is

00:02:45,330 --> 00:02:51,630
more or less a pearl port of yak which

00:02:49,620 --> 00:02:55,410
is probably better known today in its

00:02:51,630 --> 00:02:58,860
canoe form of bison parse wreck descent

00:02:55,410 --> 00:03:02,250
is a Damien Conway module that is very

00:02:58,860 --> 00:03:05,550
flexible for doing parsing and regex

00:03:02,250 --> 00:03:09,300
grammars is basically a newer and

00:03:05,550 --> 00:03:11,820
scarier version of parse rectus and also

00:03:09,300 --> 00:03:16,890
by Damian that does its work completely

00:03:11,820 --> 00:03:21,500
within the regex engine in Perl 5 12 and

00:03:16,890 --> 00:03:25,470
up I believe and then there's Martha

00:03:21,500 --> 00:03:28,500
Martha is relatively new first version

00:03:25,470 --> 00:03:31,740
was in 2011 and it continues to be

00:03:28,500 --> 00:03:34,050
actively developed to this day and it

00:03:31,740 --> 00:03:38,880
uses a parsing algorithm called the

00:03:34,050 --> 00:03:42,990
early algorithm which is not relatively

00:03:38,880 --> 00:03:46,800
unknown um but early is pretty cool it

00:03:42,990 --> 00:03:48,900
can handle every grammar in the universe

00:03:46,800 --> 00:03:52,140
it doesn't have restrictions like you

00:03:48,900 --> 00:03:54,630
know this this only handles ll grammars

00:03:52,140 --> 00:03:56,630
or cannot handle left recursion or all

00:03:54,630 --> 00:04:02,370
kinds of things that you have insert in

00:03:56,630 --> 00:04:05,280
certain types of parsers um and it

00:04:02,370 --> 00:04:07,320
supports advanced things like modifying

00:04:05,280 --> 00:04:09,420
your grammar at runtime so if you have

00:04:07,320 --> 00:04:13,140
if you have something where like you

00:04:09,420 --> 00:04:14,550
want to for instance you know you're

00:04:13,140 --> 00:04:16,950
parsing a programming language and you

00:04:14,550 --> 00:04:18,989
define a subroutine and then you want to

00:04:16,950 --> 00:04:21,690
recognize that as a special kind of

00:04:18,989 --> 00:04:24,150
thing in the future you can do that it

00:04:21,690 --> 00:04:26,639
can it can report errors pretty

00:04:24,150 --> 00:04:29,099
accurately it's fast it's

00:04:26,639 --> 00:04:32,370
in in C and then the Pearl library is a

00:04:29,099 --> 00:04:35,400
wrapper around the C library and the

00:04:32,370 --> 00:04:38,969
early the early algorithm itself parses

00:04:35,400 --> 00:04:41,270
I forget what the exact class of

00:04:38,969 --> 00:04:44,219
languages is but Jeffrey always says

00:04:41,270 --> 00:04:47,340
every language that you've used in every

00:04:44,219 --> 00:04:49,289
practical parser it will parse in

00:04:47,340 --> 00:04:50,939
basically linear time with the length of

00:04:49,289 --> 00:04:54,060
the input which means that it doesn't

00:04:50,939 --> 00:04:57,029
have it doesn't have like a major

00:04:54,060 --> 00:05:01,800
explosion with backtracking and it does

00:04:57,029 --> 00:05:04,770
other cool stuff as as a warning for the

00:05:01,800 --> 00:05:10,590
rest of this material i am not i'm not a

00:05:04,770 --> 00:05:13,830
PhD in parse ology and i am not i'm not

00:05:10,590 --> 00:05:15,509
actually a primary market developer i

00:05:13,830 --> 00:05:19,169
don't know everything that there is to

00:05:15,509 --> 00:05:22,439
know about it I'm kind of evangelizing

00:05:19,169 --> 00:05:24,270
here that's from the Greek for a bringer

00:05:22,439 --> 00:05:26,159
of good news I think Marcus some pretty

00:05:24,270 --> 00:05:30,539
pretty good news and I want some more

00:05:26,159 --> 00:05:33,960
people to get involved with it um so

00:05:30,539 --> 00:05:36,060
this is this is just to get in front of

00:05:33,960 --> 00:05:38,400
you sort of an example of how you can

00:05:36,060 --> 00:05:42,990
how you can parse something with marpa

00:05:38,400 --> 00:05:45,360
and so it's it's declaring a grammar if

00:05:42,990 --> 00:05:47,939
you look in the section that says source

00:05:45,360 --> 00:05:50,189
the the first couple lines they're just

00:05:47,939 --> 00:05:52,289
they're just setting up some some

00:05:50,189 --> 00:05:54,569
defaults we don't need to go into detail

00:05:52,289 --> 00:05:56,300
about that and then we're parsing like a

00:05:54,569 --> 00:05:59,490
very simple kind of mathematical

00:05:56,300 --> 00:06:01,949
expression where we have multiply divide

00:05:59,490 --> 00:06:04,949
add subtract parentheses for grouping

00:06:01,949 --> 00:06:08,129
and numbers are basically just sequences

00:06:04,949 --> 00:06:11,460
of digits um and so we're saying an

00:06:08,129 --> 00:06:14,129
expression is a number or it's a

00:06:11,460 --> 00:06:16,439
parenthesized expression or it's a

00:06:14,129 --> 00:06:19,259
multiplication or a division or in

00:06:16,439 --> 00:06:20,879
addition or a subtraction and the

00:06:19,259 --> 00:06:23,370
different bars for separating

00:06:20,879 --> 00:06:25,740
alternatives if you have a single bar

00:06:23,370 --> 00:06:28,229
between two alternatives than they are

00:06:25,740 --> 00:06:29,819
at equal precedence and if you have two

00:06:28,229 --> 00:06:33,180
bars between then it drops down a

00:06:29,819 --> 00:06:35,639
precedence level so it does it does

00:06:33,180 --> 00:06:39,910
precedence parsing for you kind of in a

00:06:35,639 --> 00:06:42,160
built-in way um and so expression is a

00:06:39,910 --> 00:06:45,400
colon colon equals rule which means it's

00:06:42,160 --> 00:06:47,440
a grammar rule down below number and

00:06:45,400 --> 00:06:49,540
white space are defined with it tilde

00:06:47,440 --> 00:06:52,420
which means that their token rules and

00:06:49,540 --> 00:06:54,640
so we're saying that a number is one or

00:06:52,420 --> 00:06:56,020
more digit characters because I didn't

00:06:54,640 --> 00:06:58,450
want to write something more complicated

00:06:56,020 --> 00:07:02,200
white spaces one or more space

00:06:58,450 --> 00:07:04,900
characters and colon discard is is a

00:07:02,200 --> 00:07:08,590
magical rule that says between tokens we

00:07:04,900 --> 00:07:10,780
will ignore any sequence of whatever

00:07:08,590 --> 00:07:12,340
matches colon discard which is white

00:07:10,780 --> 00:07:16,600
space so we're saying white space is

00:07:12,340 --> 00:07:20,520
free between tokens and bless package

00:07:16,600 --> 00:07:25,120
here you see every rule has bless

00:07:20,520 --> 00:07:28,630
attached to it while all but one and so

00:07:25,120 --> 00:07:30,490
this is this is and we're using default

00:07:28,630 --> 00:07:32,710
action values which means it's just

00:07:30,490 --> 00:07:35,320
going to take the sub rules that it

00:07:32,710 --> 00:07:37,390
finds within each rule it's going to

00:07:35,320 --> 00:07:40,420
collect them into an array reference and

00:07:37,390 --> 00:07:42,580
then it's going to bless that array

00:07:40,420 --> 00:07:47,110
reference so you get a sort of a parse

00:07:42,580 --> 00:07:49,930
tree out of the box um and this is some

00:07:47,110 --> 00:07:51,910
driver code for that grammar that I just

00:07:49,930 --> 00:07:53,800
defined and we're going to do a simple

00:07:51,910 --> 00:07:57,190
thing we're going to say while we have

00:07:53,800 --> 00:08:00,120
lines to read initialize a recognizer

00:07:57,190 --> 00:08:04,690
ours for recognizer G is for grammar

00:08:00,120 --> 00:08:08,470
with that grammar feed it some input get

00:08:04,690 --> 00:08:11,110
a value out of it if the value comes

00:08:08,470 --> 00:08:14,500
back as not defined that means there was

00:08:11,110 --> 00:08:16,150
a parse error in the real world we could

00:08:14,500 --> 00:08:18,010
display a much more useful error but I'm

00:08:16,150 --> 00:08:22,810
trying to make the code fit onto a slide

00:08:18,010 --> 00:08:25,360
and if if we do get something back then

00:08:22,810 --> 00:08:34,630
we're going to use data printer to print

00:08:25,360 --> 00:08:36,690
it out and I'm going to press the wrong

00:08:34,630 --> 00:08:36,690
button

00:08:40,190 --> 00:08:46,910
my apologies are I'm going to run some

00:08:44,250 --> 00:08:46,910
code

00:08:54,790 --> 00:09:01,279
so we're just going to use data printer

00:08:57,949 --> 00:09:04,670
to to print out what's returned here and

00:09:01,279 --> 00:09:06,560
so you see i typed in i typed in two

00:09:04,670 --> 00:09:08,990
numbers and they got blessed into number

00:09:06,560 --> 00:09:11,180
objects and then the addition expression

00:09:08,990 --> 00:09:14,779
that contains them gets lest into an

00:09:11,180 --> 00:09:18,290
addition object if i do 1 plus 2 times 3

00:09:14,779 --> 00:09:21,829
then i get an addition which contains a

00:09:18,290 --> 00:09:25,519
number in a multiplication if i do 1 x 2

00:09:21,829 --> 00:09:27,470
+ 3 then i still get an addition that

00:09:25,519 --> 00:09:31,420
contains a multiplication but everything

00:09:27,470 --> 00:09:31,420
precedence worked in the appropriate way

00:09:32,050 --> 00:09:45,470
to do this too there we go so with a

00:09:43,550 --> 00:09:47,569
parse tree and with blessed objects well

00:09:45,470 --> 00:09:50,600
we have objects we can give behavior to

00:09:47,569 --> 00:09:52,850
objects so suppose we take all of those

00:09:50,600 --> 00:09:55,699
classes and we define on each of them a

00:09:52,850 --> 00:09:59,120
method called evaluate a number just

00:09:55,699 --> 00:10:01,009
evaluates by nullifying a multiplication

00:09:59,120 --> 00:10:03,170
evaluates by multiplying its two

00:10:01,009 --> 00:10:06,170
children and addition evaluates by

00:10:03,170 --> 00:10:10,790
adding its two children etc so those are

00:10:06,170 --> 00:10:13,819
all of the things that we have and so

00:10:10,790 --> 00:10:19,149
now instead of using data printer what

00:10:13,819 --> 00:10:19,149
if we just call a evaluate on each thing

00:10:20,079 --> 00:10:24,579
why are you being a little bit finicky

00:10:29,250 --> 00:10:42,300
there we go what a surprise that's and

00:10:38,730 --> 00:10:44,730
that's almost complete code if you if

00:10:42,300 --> 00:10:47,220
you look at this basically almost yeah

00:10:44,730 --> 00:10:49,500
every line of this was on a slide so

00:10:47,220 --> 00:10:51,870
it's a relatively relatively compact

00:10:49,500 --> 00:10:54,630
program that's about what it takes to

00:10:51,870 --> 00:10:56,840
get up to speed with Marco with a simple

00:10:54,630 --> 00:10:56,840
grammar

00:11:06,680 --> 00:11:14,100
um so that's with a grammar we gave our

00:11:11,940 --> 00:11:15,990
default rule in action of values which

00:11:14,100 --> 00:11:21,420
just says for everything produce an

00:11:15,990 --> 00:11:24,740
array ref you can also use use custom

00:11:21,420 --> 00:11:27,390
actions to derive things as you parse

00:11:24,740 --> 00:11:30,570
which means the thing you produce is not

00:11:27,390 --> 00:11:32,910
even necessarily a parse tree in action

00:11:30,570 --> 00:11:34,530
can modify a data structure so that you

00:11:32,910 --> 00:11:36,690
can build something up in an external

00:11:34,530 --> 00:11:39,480
data structure as you go or keep track

00:11:36,690 --> 00:11:42,690
of things that you're parsing and

00:11:39,480 --> 00:11:44,880
actions can modify the grammar as I

00:11:42,690 --> 00:11:48,930
mentioned before and one cool thing is

00:11:44,880 --> 00:11:51,960
that actions are run when you call that

00:11:48,930 --> 00:11:55,430
value method on the recognizer they're

00:11:51,960 --> 00:11:57,810
not actually run during parsing

00:11:55,430 --> 00:11:59,400
something that I've seen especially in

00:11:57,810 --> 00:12:01,790
some of the recursive descent parsers

00:11:59,400 --> 00:12:04,320
out there is that if you define actions

00:12:01,790 --> 00:12:06,120
they'll get cold and then it'll say oh

00:12:04,320 --> 00:12:07,530
no that's a you know it'll backtrack

00:12:06,120 --> 00:12:09,120
it'll say that's not something I want to

00:12:07,530 --> 00:12:11,160
do and your actions get run over and

00:12:09,120 --> 00:12:14,220
over again and if they're expensive then

00:12:11,160 --> 00:12:16,650
that makes parsing really kind of

00:12:14,220 --> 00:12:18,540
painfully slow so marpa does something

00:12:16,650 --> 00:12:21,390
more clever it just keeps track of where

00:12:18,540 --> 00:12:24,480
it found all of the information and then

00:12:21,390 --> 00:12:26,430
and then it's when you call values it

00:12:24,480 --> 00:12:29,070
knows what parse it actually wants and

00:12:26,430 --> 00:12:33,720
then it derives it runs your actions

00:12:29,070 --> 00:12:36,120
based on that and so here's here's an

00:12:33,720 --> 00:12:39,210
example where I'm going to use actions

00:12:36,120 --> 00:12:41,430
just to just as a quick way of extending

00:12:39,210 --> 00:12:43,320
the parser a little bit are in a

00:12:41,430 --> 00:12:47,010
redefined number instead of being a

00:12:43,320 --> 00:12:50,190
token it's going to be a rule that can

00:12:47,010 --> 00:12:53,190
either be a hex number or a decimal

00:12:50,190 --> 00:12:54,480
number i use excuse me i use two bars

00:12:53,190 --> 00:12:57,150
there I could use one that's a little

00:12:54,480 --> 00:13:00,870
typo and a decimal number is still a

00:12:57,150 --> 00:13:04,320
sequence of digits a hex number is 0 X

00:13:00,870 --> 00:13:11,810
followed by hex digits hex digits is one

00:13:04,320 --> 00:13:11,810
or more of hex digits and if we do that

00:13:26,300 --> 00:13:33,890
um so now yeah am I looking at the right

00:13:30,290 --> 00:13:44,020
one yeah okay so now i have 1 plus 16

00:13:33,890 --> 00:13:48,590
even though i wrote oh x 10 there we go

00:13:44,020 --> 00:13:51,320
um and so the thing the thing that I

00:13:48,590 --> 00:13:56,030
think is coolest about Martha is that

00:13:51,320 --> 00:13:59,590
using the early algorithm as I said it's

00:13:56,030 --> 00:14:03,200
it never backtracks it does sort of a

00:13:59,590 --> 00:14:05,420
time-space trade-off and so what it does

00:14:03,200 --> 00:14:07,760
is if there's multiple possibilities in

00:14:05,420 --> 00:14:11,210
a parse it will keep track of all of

00:14:07,760 --> 00:14:14,060
them in parallel if a parse is possible

00:14:11,210 --> 00:14:16,280
at this point it's kept alive if it runs

00:14:14,060 --> 00:14:17,690
into an error that there's you know

00:14:16,280 --> 00:14:21,020
there's no state that it can possibly

00:14:17,690 --> 00:14:23,120
move into then it's thrown away if we've

00:14:21,020 --> 00:14:25,280
thrown away all of our possible parses

00:14:23,120 --> 00:14:28,310
then obviously we have a parse error at

00:14:25,280 --> 00:14:32,000
this point um and the algorithm also

00:14:28,310 --> 00:14:34,460
allows you to ask the parser among all

00:14:32,000 --> 00:14:37,870
of the possible parses at this point in

00:14:34,460 --> 00:14:40,910
the input what tokens could occur next

00:14:37,870 --> 00:14:43,040
and one of the things one of the things

00:14:40,910 --> 00:14:46,160
that you can do with that is something

00:14:43,040 --> 00:14:48,410
that Jeffrey calls the ruby slippers if

00:14:46,160 --> 00:14:52,760
anybody has ever looked at the html5

00:14:48,410 --> 00:14:56,780
spec it basically explicitly asks for

00:14:52,760 --> 00:14:58,610
this kind of thing html5 has or HTML in

00:14:56,780 --> 00:15:00,800
general has all of these rules it's a

00:14:58,610 --> 00:15:04,400
very it's a language where a lot of

00:15:00,800 --> 00:15:06,710
things can be left implicit if you if

00:15:04,400 --> 00:15:08,810
you try to put a tag inside of another

00:15:06,710 --> 00:15:11,570
tag that it's not allowed to be inside

00:15:08,810 --> 00:15:14,140
then the spec says we'll pretend that

00:15:11,570 --> 00:15:16,700
you saw a closing tag for the tag that

00:15:14,140 --> 00:15:18,710
that this is not allowed to be inside or

00:15:16,700 --> 00:15:23,270
the entire stack of tags up to that

00:15:18,710 --> 00:15:26,420
point and and using using Martha's

00:15:23,270 --> 00:15:28,550
ability to to define what is expected

00:15:26,420 --> 00:15:30,680
next you could actually define that like

00:15:28,550 --> 00:15:33,380
you could define rules for block tags in

00:15:30,680 --> 00:15:37,580
line tags whatever kind of things HTML

00:15:33,380 --> 00:15:39,230
requires of you and if you see um you

00:15:37,580 --> 00:15:41,420
know a

00:15:39,230 --> 00:15:43,310
is expected and this is not what's

00:15:41,420 --> 00:15:45,830
coming up next but I know how to get

00:15:43,310 --> 00:15:47,990
into that state then you can inject some

00:15:45,830 --> 00:15:51,340
some tokens into the parser to make that

00:15:47,990 --> 00:15:53,960
happen there is actually an example on

00:15:51,340 --> 00:15:59,420
Jeffrey's blog ocean of awareness of

00:15:53,960 --> 00:16:02,810
doing exactly that um so that's that's

00:15:59,420 --> 00:16:05,720
sort of the end of my intro kind of

00:16:02,810 --> 00:16:08,870
crash course section and the second part

00:16:05,720 --> 00:16:11,150
is a little bit more more storytime

00:16:08,870 --> 00:16:17,030
about some recent Marfa development and

00:16:11,150 --> 00:16:20,480
about me um I like parsing things i like

00:16:17,030 --> 00:16:24,590
making computers do useful things and i

00:16:20,480 --> 00:16:27,590
have always had a fear of lectures when

00:16:24,590 --> 00:16:29,660
i when I've looked into any of the any

00:16:27,590 --> 00:16:31,850
of the really heavy duty parsers and

00:16:29,660 --> 00:16:34,460
they want you to tokenize stuff up front

00:16:31,850 --> 00:16:37,060
and make an upfront decision about what

00:16:34,460 --> 00:16:40,790
is this thing that we're looking at

00:16:37,060 --> 00:16:42,980
because it's hard without without the

00:16:40,790 --> 00:16:45,050
context that the parser provides how is

00:16:42,980 --> 00:16:48,880
the tokenizer supposed to figure out

00:16:45,050 --> 00:16:50,960
what a thing is and the answer is

00:16:48,880 --> 00:16:57,620
sometimes you do some really scary

00:16:50,960 --> 00:16:59,510
things as as pearl does um I can't think

00:16:57,620 --> 00:17:03,650
I can't think of it off the top of my

00:16:59,510 --> 00:17:06,110
head but for example like use use module

00:17:03,650 --> 00:17:08,660
version I think does some does some

00:17:06,110 --> 00:17:10,610
interesting things to actually pretend

00:17:08,660 --> 00:17:12,380
pretend that it saw some completely

00:17:10,610 --> 00:17:14,240
different code than what you wrote it

00:17:12,380 --> 00:17:16,250
look goes backwards and erases what it

00:17:14,240 --> 00:17:19,610
could and did some completely different

00:17:16,250 --> 00:17:22,580
things but there are there options out

00:17:19,610 --> 00:17:29,260
there parce rectus and red X grammars

00:17:22,580 --> 00:17:29,260
parser mgc among them that um okay yes

00:17:29,890 --> 00:17:35,990
that that don't that don't make you do

00:17:33,140 --> 00:17:38,450
that um and the ones that I've listed

00:17:35,990 --> 00:17:41,840
there are all are all recursive descent

00:17:38,450 --> 00:17:43,780
parsers I believe peg X is not but

00:17:41,840 --> 00:17:46,220
recursive descent implies backtracking

00:17:43,780 --> 00:17:48,090
backtracking implies if you don't write

00:17:46,220 --> 00:17:51,480
things carefully than things can

00:17:48,090 --> 00:17:54,179
really slow because you just have you

00:17:51,480 --> 00:17:56,940
know possibilities of combinations with

00:17:54,179 --> 00:17:58,110
in combinations um it's it's something

00:17:56,940 --> 00:18:02,309
that you see in the pearl regular

00:17:58,110 --> 00:18:04,470
expression engine as well if you if you

00:18:02,309 --> 00:18:13,320
uncarrier regular expression it can

00:18:04,470 --> 00:18:15,750
backtrack forever um but with so i was i

00:18:13,320 --> 00:18:18,630
think my speaker notes disappeared which

00:18:15,750 --> 00:18:22,260
is unfortunate but i was i was reading

00:18:18,630 --> 00:18:28,880
about Martha in an early stage and I had

00:18:22,260 --> 00:18:33,390
an idea which is it has okay I are these

00:18:28,880 --> 00:18:36,659
okay what I wanted to do was delete this

00:18:33,390 --> 00:18:41,789
slide or something I really apologize

00:18:36,659 --> 00:18:43,830
for this but martha martha has this kind

00:18:41,789 --> 00:18:45,600
of speculative parsing ability or the

00:18:43,830 --> 00:18:47,610
ability to keep multiple balls in the

00:18:45,600 --> 00:18:51,960
air at the same time and you can feed it

00:18:47,610 --> 00:18:55,200
multiple tokens at a single point so if

00:18:51,960 --> 00:18:57,690
you if you match all of them and you and

00:18:55,200 --> 00:19:00,120
you give them all of them to the parser

00:18:57,690 --> 00:19:03,480
as alternatives then it can resolve it

00:19:00,120 --> 00:19:06,690
at a higher level so at the time when i

00:19:03,480 --> 00:19:09,210
came into into marpa which was when

00:19:06,690 --> 00:19:11,880
market access was the thing marpa are

00:19:09,210 --> 00:19:14,669
too had just come out this was the this

00:19:11,880 --> 00:19:16,890
was the way that you drove it it didn't

00:19:14,669 --> 00:19:19,260
come with a lexer of its own you were

00:19:16,890 --> 00:19:21,179
just expected to provide one so I've

00:19:19,260 --> 00:19:24,230
kind of abstracted it as this dollar

00:19:21,179 --> 00:19:27,270
lexer next token thing get some get some

00:19:24,230 --> 00:19:29,580
token from the input pass it to the

00:19:27,270 --> 00:19:31,350
parser if the parser accepts it then

00:19:29,580 --> 00:19:34,169
good if it rejects it then do something

00:19:31,350 --> 00:19:37,289
about the error at the end of input then

00:19:34,169 --> 00:19:38,970
request a value from the parser if it if

00:19:37,289 --> 00:19:40,380
it gives you something then great if it

00:19:38,970 --> 00:19:43,409
didn't and you must have had a parse

00:19:40,380 --> 00:19:45,419
error at the end of course um and this

00:19:43,409 --> 00:19:49,260
is this is a fairly standard way to

00:19:45,419 --> 00:19:51,809
drive a parser but I was looking I was

00:19:49,260 --> 00:19:54,240
looking at these features that were

00:19:51,809 --> 00:19:56,850
available and I said what if you what if

00:19:54,240 --> 00:20:00,460
you move over the input one character at

00:19:56,850 --> 00:20:03,790
a time and you

00:20:00,460 --> 00:20:08,050
and you do this crazy thing which is to

00:20:03,790 --> 00:20:10,660
say advance advance one character asked

00:20:08,050 --> 00:20:14,410
the parser if any tokens could possibly

00:20:10,660 --> 00:20:18,160
start at this position if so then ask

00:20:14,410 --> 00:20:21,820
ask a lexer do any of them start here if

00:20:18,160 --> 00:20:23,800
so then pass them whatever set of them

00:20:21,820 --> 00:20:25,990
there are two the parser as alternatives

00:20:23,800 --> 00:20:27,340
if nothing's expected to start your then

00:20:25,990 --> 00:20:29,950
we just move on to the next character

00:20:27,340 --> 00:20:31,840
when we reach the end of input we do the

00:20:29,950 --> 00:20:35,670
same thing ask the parser for a value

00:20:31,840 --> 00:20:38,200
see if we had a successful parse um and

00:20:35,670 --> 00:20:41,350
so I said I was trying to eliminate the

00:20:38,200 --> 00:20:44,230
lexer and I didn't didn't did I um but

00:20:41,350 --> 00:20:46,210
it's uh it doesn't have to make up its

00:20:44,230 --> 00:20:48,720
mind all it has to do is answer the

00:20:46,210 --> 00:20:51,550
question does the thing start at a place

00:20:48,720 --> 00:20:53,920
because all of the all of the context

00:20:51,550 --> 00:20:57,280
juggling is done at a higher level by

00:20:53,920 --> 00:21:00,430
the grammar and you had you can entirely

00:20:57,280 --> 00:21:03,180
do away with things like like the

00:21:00,430 --> 00:21:07,870
longest token rule this is basically the

00:21:03,180 --> 00:21:11,110
maximum ambiguity brute force a lexer

00:21:07,870 --> 00:21:14,230
and this code sample is honestly printed

00:21:11,110 --> 00:21:17,890
too small to to go over but if you if

00:21:14,230 --> 00:21:19,810
you care to look at it in the slides I

00:21:17,890 --> 00:21:22,450
did post a slide URL at the beginning

00:21:19,810 --> 00:21:25,450
but basically this this implements what

00:21:22,450 --> 00:21:28,180
I just said using using regular

00:21:25,450 --> 00:21:32,860
expressions if you give it a table like

00:21:28,180 --> 00:21:36,730
this then um then it will output tokens

00:21:32,860 --> 00:21:39,310
for the kind of thing that you want and

00:21:36,730 --> 00:21:41,260
I had another I had another crazy idea

00:21:39,310 --> 00:21:44,020
because I was I've been on and off

00:21:41,260 --> 00:21:46,120
working on a project a project that no

00:21:44,020 --> 00:21:50,470
longer has any steam behind it but there

00:21:46,120 --> 00:21:54,640
is a project to turn tap test anything

00:21:50,470 --> 00:21:57,400
protocol into an Internet RFC there's a

00:21:54,640 --> 00:21:59,230
draft it's not been accepted it's not

00:21:57,400 --> 00:22:02,620
really been edited in a few years but I

00:21:59,230 --> 00:22:07,270
started this project a while ago and I

00:22:02,620 --> 00:22:08,890
maintain basically a parser that is not

00:22:07,270 --> 00:22:12,220
meant for a real production use but is

00:22:08,890 --> 00:22:13,330
derived from the RFC draft as a

00:22:12,220 --> 00:22:16,240
reference implement

00:22:13,330 --> 00:22:18,010
patient and every now and then I try to

00:22:16,240 --> 00:22:20,050
rewrite it using different parser

00:22:18,010 --> 00:22:23,740
technology to teach myself that kind of

00:22:20,050 --> 00:22:28,840
parser um and so I wanted to implement

00:22:23,740 --> 00:22:30,490
that using using marpa and I was trying

00:22:28,840 --> 00:22:34,420
to figure out the best way to do it and

00:22:30,490 --> 00:22:40,000
I had a crazy idea which is tap is a

00:22:34,420 --> 00:22:42,490
line based format and um it has this

00:22:40,000 --> 00:22:45,400
interesting feature called junk lines

00:22:42,490 --> 00:22:47,170
which is that if I see a line and it

00:22:45,400 --> 00:22:49,870
makes sense as tap then I'm going to

00:22:47,170 --> 00:22:52,090
interpret it as tap but if I see a line

00:22:49,870 --> 00:22:54,010
and it doesn't make sense as tap then

00:22:52,090 --> 00:22:56,350
I'm going to assume that the test

00:22:54,010 --> 00:22:58,420
harness just prints other random crap on

00:22:56,350 --> 00:23:01,630
to standard out and I'm going to ignore

00:22:58,420 --> 00:23:04,390
it and that's kind of hard to do with

00:23:01,630 --> 00:23:07,540
with the conventional parser that parses

00:23:04,390 --> 00:23:10,210
as a document so i created a parser that

00:23:07,540 --> 00:23:13,600
would just parse one line of tap and

00:23:10,210 --> 00:23:18,610
output an object for that that would say

00:23:13,600 --> 00:23:20,980
this is a this is a plan this is a test

00:23:18,610 --> 00:23:24,250
result this is a comment this is

00:23:20,980 --> 00:23:28,030
whatever and then I realized well hey

00:23:24,250 --> 00:23:31,210
isn't the the format that that marpa

00:23:28,030 --> 00:23:33,460
takes tokens in as input is an array

00:23:31,210 --> 00:23:35,710
reference it doesn't even mind whether

00:23:33,460 --> 00:23:37,840
it's an object or not so you can pass in

00:23:35,710 --> 00:23:40,660
what you like which means that I pass

00:23:37,840 --> 00:23:43,420
the output of my line parser into the

00:23:40,660 --> 00:23:46,420
document parser which says expect a plan

00:23:43,420 --> 00:23:53,260
expect test results expect you know

00:23:46,420 --> 00:23:55,270
whatever and that works um and like I

00:23:53,260 --> 00:23:58,390
said it makes it makes that junk line

00:23:55,270 --> 00:24:00,070
behavior easy and it also gives you

00:23:58,390 --> 00:24:04,810
error reporting because instead of

00:24:00,070 --> 00:24:07,300
reporting errors that uh that are based

00:24:04,810 --> 00:24:09,730
on the tokens within a line it can

00:24:07,300 --> 00:24:12,250
report errors that says I expected a

00:24:09,730 --> 00:24:14,590
plan or I expected either a result or a

00:24:12,250 --> 00:24:16,630
comment here but you gave me a plan

00:24:14,590 --> 00:24:18,610
because but I don't expect the plan

00:24:16,630 --> 00:24:20,950
because I already have one and so you

00:24:18,610 --> 00:24:26,410
can you can actually be more user

00:24:20,950 --> 00:24:29,590
helpful with that um and so I

00:24:26,410 --> 00:24:32,710
ro I wrote a blog post about that and

00:24:29,590 --> 00:24:36,400
mentioned it on the Martha mailing list

00:24:32,710 --> 00:24:40,630
and it sparked a discussion and what it

00:24:36,400 --> 00:24:42,910
led to was a the current interface to

00:24:40,630 --> 00:24:46,240
the current recommended interface to

00:24:42,910 --> 00:24:48,910
marpa which is Martha r2 scanless which

00:24:46,240 --> 00:24:50,710
actually uses two grammars under the

00:24:48,910 --> 00:24:53,400
hood the stuff that you saw before with

00:24:50,710 --> 00:24:57,220
the colon colon equals grammar rules

00:24:53,400 --> 00:25:00,250
runs in 1 parser and the stuff with the

00:24:57,220 --> 00:25:03,220
tilde token rules runs in another parser

00:25:00,250 --> 00:25:06,250
and the output of the one feeds the

00:25:03,220 --> 00:25:07,630
other that actually this this is what

00:25:06,250 --> 00:25:11,140
brought it together and allowed you to

00:25:07,630 --> 00:25:16,840
define them both within within a single

00:25:11,140 --> 00:25:21,640
grammar definition um and I got ahead of

00:25:16,840 --> 00:25:25,650
my slides a little bit again um and so

00:25:21,640 --> 00:25:29,140
that's that's that um and recently

00:25:25,650 --> 00:25:32,520
recently was added a feature called el

00:25:29,140 --> 00:25:36,340
ATM longest acceptable tokens match um

00:25:32,520 --> 00:25:38,140
so Martha's Marquez lexer is not the

00:25:36,340 --> 00:25:40,450
brute force one that I showed off before

00:25:38,140 --> 00:25:48,190
to be honest mine is a little bit crazy

00:25:40,450 --> 00:25:52,060
um um well no but I mean the algorithm

00:25:48,190 --> 00:25:54,700
behind it um yeah it could be it could

00:25:52,060 --> 00:25:57,640
actually be wrapped up I even suggested

00:25:54,700 --> 00:26:00,490
well what if you take L ATM and you make

00:25:57,640 --> 00:26:02,770
it a ATM all acceptable tokens match and

00:26:00,490 --> 00:26:07,990
give it give it the same interface but

00:26:02,770 --> 00:26:09,820
use my my algorithm yeah and the answer

00:26:07,990 --> 00:26:11,860
was yeah we could we could do that but

00:26:09,820 --> 00:26:14,710
it would make it really really easy to

00:26:11,860 --> 00:26:17,620
to write grammars that would make the

00:26:14,710 --> 00:26:19,300
number of parser states explode you're

00:26:17,620 --> 00:26:21,220
not going to have infinite backtracking

00:26:19,300 --> 00:26:26,680
but you might use infinite memory and

00:26:21,220 --> 00:26:30,940
that's not so good either um I'm so

00:26:26,680 --> 00:26:33,280
acceptable is a token that the grammar

00:26:30,940 --> 00:26:35,530
expects at this point in the input so

00:26:33,280 --> 00:26:38,850
it's going it's going back to that early

00:26:35,530 --> 00:26:42,030
introspection and so it says

00:26:38,850 --> 00:26:44,250
among the set among the set of tokens

00:26:42,030 --> 00:26:47,390
that are acceptable to the grammar at

00:26:44,250 --> 00:26:51,690
this point try matching all of them and

00:26:47,390 --> 00:26:54,060
of the ones that do match here um take

00:26:51,690 --> 00:26:56,070
the longest one that matches if there's

00:26:54,060 --> 00:26:58,320
a tie for longest then it will still

00:26:56,070 --> 00:27:00,780
present them both to both as

00:26:58,320 --> 00:27:04,230
alternatives to the grammar and this

00:27:00,780 --> 00:27:07,890
works almost as well as what I presented

00:27:04,230 --> 00:27:10,230
without being completely crazy um having

00:27:07,890 --> 00:27:13,470
having some kind of some kind of a

00:27:10,230 --> 00:27:15,510
longest match rule does doesn't sure

00:27:13,470 --> 00:27:22,320
that your parser is much more likely to

00:27:15,510 --> 00:27:24,690
move forward um and that's the end of

00:27:22,320 --> 00:27:28,860
the materials that I presented this

00:27:24,690 --> 00:27:30,980
slide links to some of the marpa

00:27:28,860 --> 00:27:34,440
community which I would encourage you to

00:27:30,980 --> 00:27:36,600
join if you're interested marpa parser

00:27:34,440 --> 00:27:39,840
is a mailing list on google google

00:27:36,600 --> 00:27:42,360
groups jeffrey Kegler the lead developer

00:27:39,840 --> 00:27:44,810
has a blog ocean of awareness where he

00:27:42,360 --> 00:27:47,220
posts interesting things about marpa

00:27:44,810 --> 00:27:49,680
another fellow whose name i forgot to

00:27:47,220 --> 00:27:53,090
write down is working on something

00:27:49,680 --> 00:27:58,040
called the marpa papers which contains

00:27:53,090 --> 00:28:00,540
some some user documentation and

00:27:58,040 --> 00:28:02,880
introduction and tutorial is the word

00:28:00,540 --> 00:28:06,660
that I'm looking for that is that is not

00:28:02,880 --> 00:28:10,500
in the pod as well as some technical

00:28:06,660 --> 00:28:15,540
explanations and there is an IRC channel

00:28:10,500 --> 00:28:17,820
on freenode pound marpa and i have run a

00:28:15,540 --> 00:28:20,130
fair bit amount under times if there's

00:28:17,820 --> 00:28:21,780
any questions or discussions that we'd

00:28:20,130 --> 00:28:28,280
like to have them definitely open to

00:28:21,780 --> 00:28:28,280
that did I talk too fast

00:28:31,790 --> 00:28:42,320
yes that time you are something like

00:28:37,320 --> 00:28:47,220
what were you what were you something um

00:28:42,320 --> 00:28:50,220
let's see config config files that's

00:28:47,220 --> 00:28:52,590
well that's kind of a crazy example

00:28:50,220 --> 00:28:54,510
because by now every config file format

00:28:52,590 --> 00:28:57,420
you want somebody somebody has probably

00:28:54,510 --> 00:28:59,850
already written the parser for but I

00:28:57,420 --> 00:29:01,650
I've done it on my own in the past four

00:28:59,850 --> 00:29:03,750
different different kinds of config

00:29:01,650 --> 00:29:05,670
files if you want to read something that

00:29:03,750 --> 00:29:07,740
looks like an apache config file or a

00:29:05,670 --> 00:29:11,070
bind config file or all of these formats

00:29:07,740 --> 00:29:14,190
that people have imagined um I've

00:29:11,070 --> 00:29:17,690
written one to read weather reports

00:29:14,190 --> 00:29:20,280
there's a standard standard computer

00:29:17,690 --> 00:29:22,860
format for weather reports that come

00:29:20,280 --> 00:29:27,810
from airports called met are and I've

00:29:22,860 --> 00:29:29,250
written a parser for that um plenty of

00:29:27,810 --> 00:29:31,170
things but I'm not very good at coming

00:29:29,250 --> 00:29:34,110
up with examples off that's off the top

00:29:31,170 --> 00:29:36,240
of my head but any any time you have and

00:29:34,110 --> 00:29:38,850
I mean like a JSON parser again

00:29:36,240 --> 00:29:41,100
somebody's already done that for you in

00:29:38,850 --> 00:29:43,230
every language you probably ever want to

00:29:41,100 --> 00:29:46,260
use but somebody had to write that and

00:29:43,230 --> 00:29:50,820
somebody had to do it using a using some

00:29:46,260 --> 00:29:54,180
kind of parser technology gamal p.m. the

00:29:50,820 --> 00:29:57,960
pure pearl version is is an

00:29:54,180 --> 00:30:00,870
agglomeration of those M etc GC regular

00:29:57,960 --> 00:30:03,120
expressions written by engi don't look

00:30:00,870 --> 00:30:10,040
too closely if you value your sanity but

00:30:03,120 --> 00:30:10,040
it does work anything else

00:30:10,730 --> 00:30:15,260
alright well thank you very much for

00:30:13,050 --> 00:30:15,260

YouTube URL: https://www.youtube.com/watch?v=XaScLywH2CI


