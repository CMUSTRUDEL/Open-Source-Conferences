Title: Augustina Ragwitz (‎auggy‎) - ‎Perl Out Of Order: Why Timeout Today What You Can Return Tomorrow‎
Publication date: 2014-06-24
Playlist: YAPC::NA 2014
Description: 
	So you've built a fancy web application with a fancy database back end, but now that people are using it you've got a few features timing out... and making for angry end users. In a normal procedural program, each task is done when the other finishes. Another option is to hand off the hard work to something else and give your user a status rather than a timeout! This talk will introduce asynchronous programming and the worker queue pattern. I will also provide a simple, reusable example for passing a long running SQL query off to a worker queue using RabbitMQ and AnyEvent::RabbitMQ.
Captions: 
	00:00:00,000 --> 00:00:06,299
so I currently work for shutterstock in

00:00:03,030 --> 00:00:08,099
New York City and we are hiring so we're

00:00:06,299 --> 00:00:10,170
also hiring remote so if you're

00:00:08,099 --> 00:00:12,360
interested several of us are here of you

00:00:10,170 --> 00:00:14,880
know you can come and talk to me and I

00:00:12,360 --> 00:00:18,060
can tell you about how great it is I'm

00:00:14,880 --> 00:00:22,710
on Pearl IRC as Auggie and on freenode

00:00:18,060 --> 00:00:23,910
as pork and I'm also on Twitter so those

00:00:22,710 --> 00:00:28,529
are all great ways for you to get in

00:00:23,910 --> 00:00:31,710
touch with me and also email sooo what

00:00:28,529 --> 00:00:33,270
we will cover so this talk isn't going

00:00:31,710 --> 00:00:34,710
to be an in-depth asynchronous

00:00:33,270 --> 00:00:36,420
programming it's not going to tell you

00:00:34,710 --> 00:00:38,969
about the inner workings of any event

00:00:36,420 --> 00:00:40,980
and you know some of the things they're

00:00:38,969 --> 00:00:44,219
really it's going to be enough for you

00:00:40,980 --> 00:00:46,020
to do asynchronous HTTP requests and to

00:00:44,219 --> 00:00:49,020
be able to interface with any event

00:00:46,020 --> 00:00:51,480
RabbitMQ and to understand the language

00:00:49,020 --> 00:00:53,780
that any event uses and hopefully to be

00:00:51,480 --> 00:00:56,250
able to apply that to other asynchronous

00:00:53,780 --> 00:00:59,100
libraries weather and pearl or even in

00:00:56,250 --> 00:01:01,920
nodejs the other thing that will cover

00:00:59,100 --> 00:01:03,379
is the worker q pattern using rabbitmq

00:01:01,920 --> 00:01:06,540
and again this will be a very high level

00:01:03,379 --> 00:01:08,720
thing I have sample code which i'll have

00:01:06,540 --> 00:01:11,820
the link up here it's not public yet

00:01:08,720 --> 00:01:13,200
because I've been working on slides and

00:01:11,820 --> 00:01:15,840
I want to do some code cleanup but it

00:01:13,200 --> 00:01:17,759
does run so in it'll give you some

00:01:15,840 --> 00:01:19,770
examples of these things applied in a

00:01:17,759 --> 00:01:21,180
little application a mojo light a web

00:01:19,770 --> 00:01:23,040
app that you can download and run on

00:01:21,180 --> 00:01:25,290
your computer so you can play with these

00:01:23,040 --> 00:01:27,509
things a little bit more and a bonus

00:01:25,290 --> 00:01:30,299
side effect of this talk how to identify

00:01:27,509 --> 00:01:32,369
if this technology is the right solution

00:01:30,299 --> 00:01:34,020
for your problem and so this is I'm

00:01:32,369 --> 00:01:36,119
going to get on a soapbox for a moment

00:01:34,020 --> 00:01:39,150
because I find in the world of you know

00:01:36,119 --> 00:01:41,280
a sink and worker queue and you know

00:01:39,150 --> 00:01:43,770
like scalability you know people like to

00:01:41,280 --> 00:01:46,200
throw buzz words around it's really

00:01:43,770 --> 00:01:48,360
really really important even when you're

00:01:46,200 --> 00:01:49,890
evaluating these technologies that you

00:01:48,360 --> 00:01:51,540
have a clear idea of what the problem

00:01:49,890 --> 00:01:53,460
you're trying to solve is and to

00:01:51,540 --> 00:01:55,170
understand if these solutions are

00:01:53,460 --> 00:01:58,170
actually going to solve that problem for

00:01:55,170 --> 00:02:00,060
you rather than trying to find a problem

00:01:58,170 --> 00:02:02,070
or make your problem fit into a cool

00:02:00,060 --> 00:02:04,439
solution and I just see this a lot of

00:02:02,070 --> 00:02:06,570
places I work a lot of people I've

00:02:04,439 --> 00:02:09,399
worked with you know you get it's like

00:02:06,570 --> 00:02:11,110
ooh shiny I want to use this

00:02:09,399 --> 00:02:12,970
but we don't really have a use case for

00:02:11,110 --> 00:02:15,159
it so I'll just make this thing fit into

00:02:12,970 --> 00:02:17,590
the use case and then you end up over

00:02:15,159 --> 00:02:20,010
complicating things so our sample

00:02:17,590 --> 00:02:24,220
application is a very simple report

00:02:20,010 --> 00:02:26,290
we'll call it the TPS report and what's

00:02:24,220 --> 00:02:28,000
happening let's say we have a small

00:02:26,290 --> 00:02:30,159
company of about a hundred people and

00:02:28,000 --> 00:02:31,900
once a month everybody wants to get the

00:02:30,159 --> 00:02:35,620
sales data and they go to hit the report

00:02:31,900 --> 00:02:37,090
all at the same time and some you know

00:02:35,620 --> 00:02:38,560
we'll say twenty-five percent of the

00:02:37,090 --> 00:02:40,359
users are not able to download the

00:02:38,560 --> 00:02:42,250
report they're just getting timeouts so

00:02:40,359 --> 00:02:44,409
then they're starting to hit the website

00:02:42,250 --> 00:02:47,470
more and this is just an internal

00:02:44,409 --> 00:02:48,819
website with no external users and then

00:02:47,470 --> 00:02:50,769
when they're doing that then we see

00:02:48,819 --> 00:02:52,810
website latency reported for all users

00:02:50,769 --> 00:02:55,510
so this is like a high-level problem

00:02:52,810 --> 00:02:56,859
description the next thing that you want

00:02:55,510 --> 00:02:58,989
to do after you have a sense of your

00:02:56,859 --> 00:03:01,569
high level problem is to identify the

00:02:58,989 --> 00:03:02,920
cause and clarify the the problem with

00:03:01,569 --> 00:03:06,099
numbers so if you're not collecting

00:03:02,920 --> 00:03:08,139
metrics on your website performance then

00:03:06,099 --> 00:03:10,780
you definitely want to start and that's

00:03:08,139 --> 00:03:13,329
how you can quantify your problems so

00:03:10,780 --> 00:03:16,150
some ways that you can do that you can

00:03:13,329 --> 00:03:17,470
check your logs for error conditions and

00:03:16,150 --> 00:03:19,150
see if you can get some statistical

00:03:17,470 --> 00:03:22,030
analysis from that what percentage of

00:03:19,150 --> 00:03:24,909
requests end up with certain error

00:03:22,030 --> 00:03:27,040
states you can also collect metrics

00:03:24,909 --> 00:03:28,629
which is I think the easiest thing to do

00:03:27,040 --> 00:03:30,909
and I've done this plenty of times has

00:03:28,629 --> 00:03:32,889
just put timing calls so you just do a

00:03:30,909 --> 00:03:34,419
pearl timestamp and then after you make

00:03:32,889 --> 00:03:36,519
a request you just take the difference

00:03:34,419 --> 00:03:38,769
between that time stamp in the current

00:03:36,519 --> 00:03:40,959
time and that just tells you you know

00:03:38,769 --> 00:03:43,810
how much time elapsed between those two

00:03:40,959 --> 00:03:45,879
numbers you can log that you can you

00:03:43,810 --> 00:03:48,220
know push it to STATS d you can use

00:03:45,879 --> 00:03:49,629
something like log lee or log aggregator

00:03:48,220 --> 00:03:51,040
there's a lot of cool things you can do

00:03:49,629 --> 00:03:53,949
but what's important is that you start

00:03:51,040 --> 00:03:55,479
capturing that data the other thing that

00:03:53,949 --> 00:03:57,940
you'll want to check is if you're using

00:03:55,479 --> 00:04:00,879
a database check the long-running query

00:03:57,940 --> 00:04:02,440
log postgres has this my sequel has this

00:04:00,879 --> 00:04:05,560
see what queries are taking the most

00:04:02,440 --> 00:04:07,479
time sometimes rather than looking at a

00:04:05,560 --> 00:04:09,519
complex architecture like a worker q

00:04:07,479 --> 00:04:12,280
pattern just cleaning up your sequel and

00:04:09,519 --> 00:04:14,650
you know doing some explain and analysis

00:04:12,280 --> 00:04:16,630
on your sequel can often fix whatever

00:04:14,650 --> 00:04:18,940
latency problems that you're having or

00:04:16,630 --> 00:04:20,680
will allow you to diagnose so that you

00:04:18,940 --> 00:04:21,150
can fix whatever latency problems that

00:04:20,680 --> 00:04:24,490
you're have

00:04:21,150 --> 00:04:26,260
now finally reproduce it in a staging

00:04:24,490 --> 00:04:28,510
environment if you can if you can mimic

00:04:26,260 --> 00:04:30,520
the load that way you can guarantee that

00:04:28,510 --> 00:04:32,620
this is absolutely the cause of the

00:04:30,520 --> 00:04:34,630
problem and so you know you can really

00:04:32,620 --> 00:04:36,940
pitch for needing to move to potentially

00:04:34,630 --> 00:04:40,000
more complex architecture with more

00:04:36,940 --> 00:04:43,090
administrative overhead so examples the

00:04:40,000 --> 00:04:45,130
TPS report database query is taking you

00:04:43,090 --> 00:04:47,820
know two minutes to run you know that's

00:04:45,130 --> 00:04:52,060
ridiculous that's just you know too long

00:04:47,820 --> 00:04:54,460
request to http services for you know

00:04:52,060 --> 00:04:56,800
data from certain api's that we need for

00:04:54,460 --> 00:04:57,940
our report are averaging one second so

00:04:56,800 --> 00:04:59,620
these are things that are more

00:04:57,940 --> 00:05:01,360
quantified problem statements that you

00:04:59,620 --> 00:05:03,670
can definitely solve and you know you've

00:05:01,360 --> 00:05:05,680
successfully solved them because you

00:05:03,670 --> 00:05:07,990
have metrics now with your solution that

00:05:05,680 --> 00:05:09,520
show that you've gotten the time down so

00:05:07,990 --> 00:05:10,540
this is just kind of a preface this is

00:05:09,520 --> 00:05:13,300
something that you should always think

00:05:10,540 --> 00:05:15,790
about before using rabbitmq before

00:05:13,300 --> 00:05:17,350
moving to an asynchronous solution you

00:05:15,790 --> 00:05:18,790
because there is overhead and so you

00:05:17,350 --> 00:05:22,600
want to make sure that these solutions

00:05:18,790 --> 00:05:24,670
are going to solve your problem so you

00:05:22,600 --> 00:05:26,560
know once you've proposed your solution

00:05:24,670 --> 00:05:29,110
or you propose your solution based on

00:05:26,560 --> 00:05:30,610
data and facts so in this case our

00:05:29,110 --> 00:05:33,340
solution is that we want to move to an

00:05:30,610 --> 00:05:36,460
asynchronous model so that we can get

00:05:33,340 --> 00:05:38,830
our HTTP request time down and we want

00:05:36,460 --> 00:05:40,950
to move to work or queue system because

00:05:38,830 --> 00:05:43,210
timeouts are poor user experience and

00:05:40,950 --> 00:05:45,790
having the reports being a worker queue

00:05:43,210 --> 00:05:47,440
will prevent those users from having

00:05:45,790 --> 00:05:49,690
that timeout they'll just have to wait

00:05:47,440 --> 00:05:51,460
until their report is done later but

00:05:49,690 --> 00:05:55,150
they won't have you know this terrible

00:05:51,460 --> 00:05:57,640
time out experience ok so our current

00:05:55,150 --> 00:05:59,500
architecture we have a mojolicious light

00:05:57,640 --> 00:06:01,480
app that generates we'll call it the TPS

00:05:59,500 --> 00:06:04,240
report so this makes calls to to

00:06:01,480 --> 00:06:06,460
external services to collect data and

00:06:04,240 --> 00:06:09,310
then this will make a complex call to

00:06:06,460 --> 00:06:10,780
the database ok pretty simple in our

00:06:09,310 --> 00:06:13,180
proposed architecture is that we're

00:06:10,780 --> 00:06:15,310
going to instead move to a worker queue

00:06:13,180 --> 00:06:17,860
system and so like I said this involves

00:06:15,310 --> 00:06:19,990
some systems overhead you know another

00:06:17,860 --> 00:06:21,670
option here instead of moving to a

00:06:19,990 --> 00:06:23,710
worker queue again look at ways that you

00:06:21,670 --> 00:06:25,990
can improve your database performance

00:06:23,710 --> 00:06:28,960
for instance maybe consider having a

00:06:25,990 --> 00:06:31,180
less a less normalized table structure

00:06:28,960 --> 00:06:32,590
so if you're making a lot of joins you

00:06:31,180 --> 00:06:33,689
might consider flattening that out a

00:06:32,590 --> 00:06:35,279
little bit that'll

00:06:33,689 --> 00:06:37,589
prove some of your query times again

00:06:35,279 --> 00:06:39,779
think about other options before moving

00:06:37,589 --> 00:06:41,519
to to something like a worker queue

00:06:39,779 --> 00:06:43,169
system because it does have overhead it

00:06:41,519 --> 00:06:47,069
is another piece of software that you

00:06:43,169 --> 00:06:47,909
now have to maintain so you know so

00:06:47,069 --> 00:06:49,709
anyways there's a lot of different

00:06:47,909 --> 00:06:51,989
things you can do but what we're going

00:06:49,709 --> 00:06:55,110
to do just so you can see it is move

00:06:51,989 --> 00:06:57,599
report processing to a queue and make

00:06:55,110 --> 00:06:59,969
all HTTP requests at the same time now

00:06:57,599 --> 00:07:01,409
this is the repo or like I said right

00:06:59,969 --> 00:07:03,089
now it's private because I want to do

00:07:01,409 --> 00:07:04,739
some code cleanup before I release it to

00:07:03,089 --> 00:07:06,479
the public so that you don't have all my

00:07:04,739 --> 00:07:08,009
garbage dump er statements all over the

00:07:06,479 --> 00:07:12,209
place while I was trying to debug things

00:07:08,009 --> 00:07:13,469
last night and I'll get into what I was

00:07:12,209 --> 00:07:16,439
trying to debug it's actually pretty

00:07:13,469 --> 00:07:18,749
cool and and very useful so anyways this

00:07:16,439 --> 00:07:21,529
should be up in a few days and are

00:07:18,749 --> 00:07:24,449
available for consumption and it'll have

00:07:21,529 --> 00:07:26,159
three different directories in it I have

00:07:24,449 --> 00:07:27,419
pretty good documentation on how to set

00:07:26,159 --> 00:07:29,369
it up so you can run the different

00:07:27,419 --> 00:07:30,479
versions of the application and you can

00:07:29,369 --> 00:07:33,689
see the difference in the performance

00:07:30,479 --> 00:07:35,399
and you can see the difference in in the

00:07:33,689 --> 00:07:36,959
architecture and the architectural

00:07:35,399 --> 00:07:39,329
decisions that had to be made to go from

00:07:36,959 --> 00:07:41,399
one to the other okay so first

00:07:39,329 --> 00:07:43,949
improvement we're going to kick off the

00:07:41,399 --> 00:07:46,529
HTTP requests at the same time so

00:07:43,949 --> 00:07:49,979
currently you're probably all familiar

00:07:46,529 --> 00:07:52,319
with lwp this is how you make lwp

00:07:49,979 --> 00:07:54,449
request you set up a user agent you make

00:07:52,319 --> 00:07:56,189
your request you get your URL and you

00:07:54,449 --> 00:07:58,589
get your content this is great like if

00:07:56,189 --> 00:08:01,169
you're just calling one but let's say

00:07:58,589 --> 00:08:04,009
that we have a database query and let's

00:08:01,169 --> 00:08:07,069
say that we we need to make two calls

00:08:04,009 --> 00:08:09,539
for our database and then each one takes

00:08:07,069 --> 00:08:12,149
you know three milliseconds to return

00:08:09,539 --> 00:08:15,239
because this is a you know not the

00:08:12,149 --> 00:08:17,579
fastest API but not the slowest and you

00:08:15,239 --> 00:08:20,129
know in each report now is going to

00:08:17,579 --> 00:08:22,289
return say a hundred rows of data so for

00:08:20,129 --> 00:08:24,899
each 100 rows of data we have to make

00:08:22,289 --> 00:08:27,089
two calls to an external HTTP service

00:08:24,899 --> 00:08:29,669
because this is happening one at a time

00:08:27,089 --> 00:08:32,759
and lwp is what we would call blocking

00:08:29,669 --> 00:08:34,620
so literally it does one it waits for

00:08:32,759 --> 00:08:36,000
the response and then it does the next

00:08:34,620 --> 00:08:37,649
one on the list it waits for the

00:08:36,000 --> 00:08:39,479
response once it gets the response then

00:08:37,649 --> 00:08:42,149
it can progress through the loop so you

00:08:39,479 --> 00:08:43,889
have literally like if we've got ten

00:08:42,149 --> 00:08:44,970
URLs and each one takes three

00:08:43,889 --> 00:08:47,100
milliseconds

00:08:44,970 --> 00:08:48,990
this will be 30 milliseconds and you can

00:08:47,100 --> 00:08:50,699
see how this is just going to increase

00:08:48,990 --> 00:08:52,589
and the amount of time that it takes to

00:08:50,699 --> 00:08:54,750
process all of these it holds it

00:08:52,589 --> 00:08:56,730
processing out when any any one of them

00:08:54,750 --> 00:08:58,379
say its timing out or say it's just

00:08:56,730 --> 00:09:01,050
taking a really long time it's going to

00:08:58,379 --> 00:09:06,930
back up processing all of the other ones

00:09:01,050 --> 00:09:08,490
so let's try using a any event HTTP to

00:09:06,930 --> 00:09:10,709
get some performance improvement or

00:09:08,490 --> 00:09:12,029
performance improvements on this so I'm

00:09:10,709 --> 00:09:13,019
just showing you the code of what this

00:09:12,029 --> 00:09:15,300
looks like we're going to walk through

00:09:13,019 --> 00:09:17,579
this in a moment but I want to explain

00:09:15,300 --> 00:09:19,740
the principle of why we want to move to

00:09:17,579 --> 00:09:21,300
an asynchronous solution what happens is

00:09:19,740 --> 00:09:23,819
each request is going to happen at the

00:09:21,300 --> 00:09:25,560
same time so if a request takes three

00:09:23,819 --> 00:09:27,930
milliseconds of each request takes three

00:09:25,560 --> 00:09:30,569
milliseconds the total time for all of

00:09:27,930 --> 00:09:32,220
our URL requests if we're doing 300

00:09:30,569 --> 00:09:34,319
should be three milliseconds because

00:09:32,220 --> 00:09:36,600
they all happen simultaneously give or

00:09:34,319 --> 00:09:39,240
take you know other factors but in an

00:09:36,600 --> 00:09:41,519
ideal world duh so what happens if one

00:09:39,240 --> 00:09:43,740
request takes one second then our result

00:09:41,519 --> 00:09:45,629
will all come in one second because it

00:09:43,740 --> 00:09:47,009
doesn't return until all of the requests

00:09:45,629 --> 00:09:48,569
are complete but since they're all

00:09:47,009 --> 00:09:51,480
happening at the same time we don't have

00:09:48,569 --> 00:09:53,009
that back to back you know where it's I

00:09:51,480 --> 00:09:54,329
can't think of the word but where it's

00:09:53,009 --> 00:09:56,970
building on top of itself like a

00:09:54,329 --> 00:09:58,620
snowball so it only takes as long as the

00:09:56,970 --> 00:10:01,139
longest request so this is this is an

00:09:58,620 --> 00:10:03,240
advantage so what is it what does

00:10:01,139 --> 00:10:05,459
asynchronous mean well we all know the

00:10:03,240 --> 00:10:08,790
dictionary definition you know things

00:10:05,459 --> 00:10:10,019
happening at the same time I like to

00:10:08,790 --> 00:10:11,759
think of asynchronous code as

00:10:10,019 --> 00:10:13,709
event-driven it's also referred to this

00:10:11,759 --> 00:10:17,790
if you've done any UI programming

00:10:13,709 --> 00:10:19,470
there's the notion of listeners you you

00:10:17,790 --> 00:10:21,059
know for instance you have a button the

00:10:19,470 --> 00:10:23,399
button registers with some kind of an

00:10:21,059 --> 00:10:24,660
event and this event loop just loops and

00:10:23,399 --> 00:10:27,059
loops and loops and it just kind of

00:10:24,660 --> 00:10:28,529
listens for when somebody clicks the

00:10:27,059 --> 00:10:30,480
button and so with asynchronous

00:10:28,529 --> 00:10:32,309
programming we're applying this to the

00:10:30,480 --> 00:10:34,110
backend and now we're saying that we

00:10:32,309 --> 00:10:36,420
have an event loop we have an event that

00:10:34,110 --> 00:10:38,399
we want to listen to and once this event

00:10:36,420 --> 00:10:42,319
happens we want we want the result from

00:10:38,399 --> 00:10:45,240
that event is pretty much in a nutshell

00:10:42,319 --> 00:10:47,009
so basically a code is pushed to an

00:10:45,240 --> 00:10:49,230
event queue that will fire after all the

00:10:47,009 --> 00:10:51,470
other code executes the event loop

00:10:49,230 --> 00:10:53,730
itself is a queue of callback functions

00:10:51,470 --> 00:10:55,829
they're basically just functions that

00:10:53,730 --> 00:10:56,980
you're passing in when you call your

00:10:55,829 --> 00:10:58,690
asynchronous

00:10:56,980 --> 00:11:02,079
when you're calling your for your

00:10:58,690 --> 00:11:04,240
specific asynchronous activity when an

00:11:02,079 --> 00:11:05,920
async function executes the callback

00:11:04,240 --> 00:11:07,959
function is then pushed into the event

00:11:05,920 --> 00:11:10,300
queue so you just things don't happen

00:11:07,959 --> 00:11:11,829
this is why I called this talk pearl out

00:11:10,300 --> 00:11:13,389
of order because things don't happen in

00:11:11,829 --> 00:11:15,339
the order that you may expect them they

00:11:13,389 --> 00:11:17,199
happen when they can happen and so

00:11:15,339 --> 00:11:20,380
instead of saying I want X to happen and

00:11:17,199 --> 00:11:21,910
then why to happen in Z to happen your

00:11:20,380 --> 00:11:24,070
relationship with the event loop is

00:11:21,910 --> 00:11:25,810
pretty much like hey when you can I

00:11:24,070 --> 00:11:27,579
would like this to happen and then I

00:11:25,810 --> 00:11:31,600
would like the result though once that

00:11:27,579 --> 00:11:33,130
thing has happened so the result will be

00:11:31,600 --> 00:11:34,899
returned in the background and then the

00:11:33,130 --> 00:11:37,329
rest of your application proceeds ahead

00:11:34,899 --> 00:11:39,579
using a placeholder for the results so

00:11:37,329 --> 00:11:42,250
instead of when you initialize a

00:11:39,579 --> 00:11:43,930
variable for instance it's sort of a

00:11:42,250 --> 00:11:46,269
promise actually it's not sort of it is

00:11:43,930 --> 00:11:47,949
a promise like it's a placeholder for a

00:11:46,269 --> 00:11:49,300
value in the future and so then you can

00:11:47,949 --> 00:11:51,399
do other things that are not dependent

00:11:49,300 --> 00:11:52,870
on that particular value and then at the

00:11:51,399 --> 00:11:55,779
point where you absolutely need to get

00:11:52,870 --> 00:11:58,240
the value back from your HTTP requests

00:11:55,779 --> 00:11:59,560
in this instance then it becomes

00:11:58,240 --> 00:12:01,120
blocking and you're like okay now

00:11:59,560 --> 00:12:04,690
everything stop until this stuff is

00:12:01,120 --> 00:12:06,279
finished in a nutshell so basic formula

00:12:04,690 --> 00:12:08,620
for a sink you have an event loop you

00:12:06,279 --> 00:12:10,389
have some kind of a listener that says

00:12:08,620 --> 00:12:12,100
I'm interested in a certain event and

00:12:10,389 --> 00:12:17,440
then you have callbacks that trigger

00:12:12,100 --> 00:12:20,110
when that event happens so any event is

00:12:17,440 --> 00:12:23,410
an abstraction layer on top of event

00:12:20,110 --> 00:12:25,029
loops the I'm going to go through

00:12:23,410 --> 00:12:27,010
specifically any event because it uses

00:12:25,029 --> 00:12:28,600
some function names and has some

00:12:27,010 --> 00:12:30,819
terminology that's a little bit unique

00:12:28,600 --> 00:12:32,440
and for me it was pretty confusing when

00:12:30,819 --> 00:12:34,510
I first started using it because it was

00:12:32,440 --> 00:12:36,130
different from what I had been used to

00:12:34,510 --> 00:12:38,529
with other things but when you start

00:12:36,130 --> 00:12:39,870
understanding the workflow in the

00:12:38,529 --> 00:12:43,360
language of asynchronous programming

00:12:39,870 --> 00:12:45,490
then you get a sense of what this isn't

00:12:43,360 --> 00:12:46,779
so you can apply it to other things so

00:12:45,490 --> 00:12:49,380
the first one that you might have seen

00:12:46,779 --> 00:12:52,779
is a function called conv are a

00:12:49,380 --> 00:12:55,269
condition variable is basically a

00:12:52,779 --> 00:12:57,670
potential value that may or may not be

00:12:55,269 --> 00:13:00,130
available right away this is how you

00:12:57,670 --> 00:13:02,410
interface with your event loop so you'll

00:13:00,130 --> 00:13:04,300
call functions on conv are in order to

00:13:02,410 --> 00:13:05,980
register your interest in different

00:13:04,300 --> 00:13:07,699
things in the event loop and in order to

00:13:05,980 --> 00:13:09,769
register that you want

00:13:07,699 --> 00:13:14,059
the result back this does not actually

00:13:09,769 --> 00:13:15,709
have a value until it's ready so if you

00:13:14,059 --> 00:13:17,329
were to try to see what the value of it

00:13:15,709 --> 00:13:19,189
was you would see it's like in any event

00:13:17,329 --> 00:13:20,839
conv are instance but you wouldn't

00:13:19,189 --> 00:13:24,589
actually see that it has anything in it

00:13:20,839 --> 00:13:27,079
until you call the until you've said

00:13:24,589 --> 00:13:32,929
that okay this is the point where I want

00:13:27,079 --> 00:13:34,100
it to be ready the next method that we

00:13:32,929 --> 00:13:35,899
care about and again we'll do a Code

00:13:34,100 --> 00:13:39,649
walkthrough so you see how all these

00:13:35,899 --> 00:13:42,499
things go together but so send indicates

00:13:39,649 --> 00:13:44,299
that one event is complete by setting

00:13:42,499 --> 00:13:46,339
the conv are is ready in the case of

00:13:44,299 --> 00:13:47,899
multiple requests you can bind a call

00:13:46,339 --> 00:13:50,239
back to send which is what I'll show an

00:13:47,899 --> 00:13:52,759
example of so that way when it's ready

00:13:50,239 --> 00:13:54,319
you can store values retrieved and that

00:13:52,759 --> 00:13:56,480
way you can have the Conn Vargo of

00:13:54,319 --> 00:13:58,579
multiple times so you're not just like

00:13:56,480 --> 00:14:00,290
going once and then returning but you

00:13:58,579 --> 00:14:05,290
can say you know any time this is ready

00:14:00,290 --> 00:14:07,939
I want you know I want this value so

00:14:05,290 --> 00:14:10,249
that's pretty useful and then finally

00:14:07,939 --> 00:14:12,079
receive this is the point where this is

00:14:10,249 --> 00:14:13,910
think of this as the blocking point and

00:14:12,079 --> 00:14:15,439
this is important because this has to do

00:14:13,910 --> 00:14:17,509
with the issue that i was having last

00:14:15,439 --> 00:14:19,519
night when i was debugging some of my

00:14:17,509 --> 00:14:21,319
sample code but receive is blocking like

00:14:19,519 --> 00:14:23,389
when you when you call receive you're

00:14:21,319 --> 00:14:26,269
basically saying I need the value now I

00:14:23,389 --> 00:14:28,160
need you to fulfill the promise you know

00:14:26,269 --> 00:14:29,809
that I that you that you made earlier

00:14:28,160 --> 00:14:32,839
that you're going to return me a value

00:14:29,809 --> 00:14:35,029
so at this point all of the requests I

00:14:32,839 --> 00:14:37,189
need you no need to complete and I need

00:14:35,029 --> 00:14:42,589
this data in order to proceed in my

00:14:37,189 --> 00:14:44,779
application so there's another cool

00:14:42,589 --> 00:14:46,459
thing there's some syntactic sugar that

00:14:44,779 --> 00:14:51,319
you can use in any event called begin

00:14:46,459 --> 00:14:53,539
and end begin an end are a way to excuse

00:14:51,319 --> 00:14:56,989
me if you have multiple requests that

00:14:53,539 --> 00:14:58,669
you want to run you basically you know

00:14:56,989 --> 00:15:00,199
set that look I have a bunch of things

00:14:58,669 --> 00:15:02,689
that I want to run and I only want you

00:15:00,199 --> 00:15:05,869
to be ready when when all of them have

00:15:02,689 --> 00:15:08,209
run so there's in any event it basically

00:15:05,869 --> 00:15:11,029
increments that creates an event loop

00:15:08,209 --> 00:15:13,970
counter and anytime you make a begin a

00:15:11,029 --> 00:15:15,649
statement it increments that counter and

00:15:13,970 --> 00:15:16,320
it will anytime you make an end

00:15:15,649 --> 00:15:18,000
decrement

00:15:16,320 --> 00:15:20,010
that counter so it will only be ready

00:15:18,000 --> 00:15:21,540
once that counter is zero and you can

00:15:20,010 --> 00:15:24,660
nest these you can have multiple layers

00:15:21,540 --> 00:15:27,030
of them it's basically for instance in

00:15:24,660 --> 00:15:29,670
our case we're making multiple HTTP

00:15:27,030 --> 00:15:33,000
requests we don't want our conv are to

00:15:29,670 --> 00:15:34,620
return until it's you know until every

00:15:33,000 --> 00:15:38,100
single one is complete and so the way

00:15:34,620 --> 00:15:41,070
any event tracks that is is with begin

00:15:38,100 --> 00:15:43,440
and end now optionally you could set up

00:15:41,070 --> 00:15:45,030
some kind of an array where you create a

00:15:43,440 --> 00:15:47,070
conv are each time it loops through the

00:15:45,030 --> 00:15:48,960
array and that would give you the same

00:15:47,070 --> 00:15:51,210
thing it's just a little prettier and a

00:15:48,960 --> 00:15:53,310
little cleaner if you use begin and end

00:15:51,210 --> 00:15:55,620
and again all of this if you look at the

00:15:53,310 --> 00:15:58,860
any event of the main any event

00:15:55,620 --> 00:16:01,350
documentation there's an outline and in

00:15:58,860 --> 00:16:03,060
the documentation itself can be a little

00:16:01,350 --> 00:16:05,250
confusing it can be a little misleading

00:16:03,060 --> 00:16:07,770
but you once like hopefully with the

00:16:05,250 --> 00:16:10,410
explanations I've given you when you and

00:16:07,770 --> 00:16:12,720
after the Code walkthrough it'll make a

00:16:10,410 --> 00:16:14,130
little more sense when you actually try

00:16:12,720 --> 00:16:16,850
to apply this someone you actually try

00:16:14,130 --> 00:16:20,130
to use it so all that being said

00:16:16,850 --> 00:16:22,800
hopefully I didn't like go in one ear

00:16:20,130 --> 00:16:24,000
and out the other we'll do a

00:16:22,800 --> 00:16:27,450
walk-through so you can actually see

00:16:24,000 --> 00:16:29,190
what all of this looks like so the first

00:16:27,450 --> 00:16:30,810
thing you want to do when writing any

00:16:29,190 --> 00:16:33,630
event code and again I've got sample

00:16:30,810 --> 00:16:35,280
code on github and you can look through

00:16:33,630 --> 00:16:37,320
and play with this and this is pretty

00:16:35,280 --> 00:16:40,560
similar to sample code that's in any

00:16:37,320 --> 00:16:42,150
event docs but the first thing you want

00:16:40,560 --> 00:16:44,370
to do is initialize your conditional

00:16:42,150 --> 00:16:46,020
variable and remember at this point this

00:16:44,370 --> 00:16:47,520
thing doesn't actually have a value

00:16:46,020 --> 00:16:49,380
you've got to call some other things on

00:16:47,520 --> 00:16:52,260
it but here we're just saying okay you

00:16:49,380 --> 00:16:54,150
know I i want i want this i'm going to

00:16:52,260 --> 00:16:56,100
want something from it you're setting up

00:16:54,150 --> 00:17:00,270
the promise you're creating the

00:16:56,100 --> 00:17:02,310
placeholder the second thing that I like

00:17:00,270 --> 00:17:04,709
to do is I like to declare my receive

00:17:02,310 --> 00:17:06,510
function or the receive call of the

00:17:04,709 --> 00:17:08,339
endpoint like what do I want to return

00:17:06,510 --> 00:17:10,110
at the ready state with asynchronous

00:17:08,339 --> 00:17:11,520
programming it's a little weird because

00:17:10,110 --> 00:17:14,070
you start kind of having to think

00:17:11,520 --> 00:17:16,230
backwards about what you want to have

00:17:14,070 --> 00:17:17,490
happen so normally in programming you

00:17:16,230 --> 00:17:18,630
think okay why I'm going to start with

00:17:17,490 --> 00:17:19,920
the first thing and then I want to do

00:17:18,630 --> 00:17:21,449
the second thing and then I want to do

00:17:19,920 --> 00:17:22,740
this third thing with asynchronous

00:17:21,449 --> 00:17:25,680
programming you want to think in terms

00:17:22,740 --> 00:17:27,930
of end results so what what's my

00:17:25,680 --> 00:17:28,730
expected end point and then work

00:17:27,930 --> 00:17:31,490
backwards

00:17:28,730 --> 00:17:33,890
they're so in this case we want that

00:17:31,490 --> 00:17:36,200
receive value so we're putting that here

00:17:33,890 --> 00:17:37,790
on the bottom so this is the point and

00:17:36,200 --> 00:17:39,559
actually this is really interesting this

00:17:37,790 --> 00:17:42,470
sample code that I'm showing you the

00:17:39,559 --> 00:17:45,440
idea is here I decided I had a little

00:17:42,470 --> 00:17:47,720
library and so I decided to put my HTTP

00:17:45,440 --> 00:17:49,610
requests into a function within that

00:17:47,720 --> 00:17:51,740
library so it's actually obscured from

00:17:49,610 --> 00:17:55,190
the person calling it this is really bad

00:17:51,740 --> 00:17:57,140
and I'll explain later like why that's

00:17:55,190 --> 00:17:59,360
really bad but I thought I would go

00:17:57,140 --> 00:18:01,610
ahead and leave it just because like the

00:17:59,360 --> 00:18:03,559
the code is going to be the same more or

00:18:01,610 --> 00:18:06,679
less no matter where you use it but also

00:18:03,559 --> 00:18:08,720
to really make the point of like why

00:18:06,679 --> 00:18:11,570
it's really bad and will show later but

00:18:08,720 --> 00:18:13,549
in general the CV received you want that

00:18:11,570 --> 00:18:16,070
to be outside in any logic if you're

00:18:13,549 --> 00:18:18,260
defining any kind of a subroutine or any

00:18:16,070 --> 00:18:20,270
kind of a method within a library you

00:18:18,260 --> 00:18:23,140
generally want the the person calling it

00:18:20,270 --> 00:18:26,059
calling your library to set up their own

00:18:23,140 --> 00:18:28,370
CV and to kind of and to have their own

00:18:26,059 --> 00:18:29,840
control over the event loop but again

00:18:28,370 --> 00:18:32,240
like I said we'll get into this this is

00:18:29,840 --> 00:18:34,370
just let's walk through this and get an

00:18:32,240 --> 00:18:38,630
idea of how to essentially do HTTP

00:18:34,370 --> 00:18:41,270
requests synchronously okay so remember

00:18:38,630 --> 00:18:43,669
earlier I talked a bit about the begin

00:18:41,270 --> 00:18:45,890
block so what we're saying here is that

00:18:43,669 --> 00:18:47,630
we want to define when we want to call

00:18:45,890 --> 00:18:49,549
the send event so that we can capture

00:18:47,630 --> 00:18:53,590
our result because what we want our

00:18:49,549 --> 00:18:57,380
result is going to be a hash rough of

00:18:53,590 --> 00:19:00,230
you know of our URLs and so we want to

00:18:57,380 --> 00:19:02,150
cap for that but and then it's all yeah

00:19:00,230 --> 00:19:06,470
we want to get a hash rough sorry I'm

00:19:02,150 --> 00:19:08,210
looking at my code what was already but

00:19:06,470 --> 00:19:10,790
we want to get a hash rough of our of

00:19:08,210 --> 00:19:12,890
our URLs of the data that we've gotten a

00:19:10,790 --> 00:19:15,559
you know from whatever our external API

00:19:12,890 --> 00:19:18,590
is were so we need that data we need to

00:19:15,559 --> 00:19:21,890
return it the way to return it is is to

00:19:18,590 --> 00:19:24,770
bind it to your art to ask for it with

00:19:21,890 --> 00:19:31,370
the call back or with the call back down

00:19:24,770 --> 00:19:33,440
through that sub sorry with send so when

00:19:31,370 --> 00:19:35,210
registering callbacks with any event you

00:19:33,440 --> 00:19:36,950
can pretty much always count on

00:19:35,210 --> 00:19:39,559
the conv are being passed as an argument

00:19:36,950 --> 00:19:41,870
so the reason that we're doing the shift

00:19:39,559 --> 00:19:42,770
of you know you guys know pearls so you

00:19:41,870 --> 00:19:44,240
know it's happening there we're

00:19:42,770 --> 00:19:46,220
basically grabbing the first argument

00:19:44,240 --> 00:19:48,529
that's going to be passed in whenever

00:19:46,220 --> 00:19:51,110
that callback is called and we're

00:19:48,529 --> 00:19:52,610
passing and then we're calling and that

00:19:51,110 --> 00:19:58,010
will be a conv are and then we're

00:19:52,610 --> 00:19:59,270
calling send on it and so yeah so we're

00:19:58,010 --> 00:20:01,820
pretty much just calling the conv are

00:19:59,270 --> 00:20:03,740
from the arguments passed in and yeah

00:20:01,820 --> 00:20:05,539
calling send on it note that we're

00:20:03,740 --> 00:20:07,880
calling this from within begin this is

00:20:05,539 --> 00:20:10,429
important we're using begin because we

00:20:07,880 --> 00:20:14,029
have a list of URLs and we only want the

00:20:10,429 --> 00:20:16,399
conv are to be ready when all of the URL

00:20:14,029 --> 00:20:18,020
data has been fetched so basically in

00:20:16,399 --> 00:20:20,779
English what we're saying with this line

00:20:18,020 --> 00:20:23,419
is once all the URLs are fetched set the

00:20:20,779 --> 00:20:26,049
converter ready and return our resulting

00:20:23,419 --> 00:20:26,049
data structure

00:20:28,039 --> 00:20:33,859
okay so next thing we want to go ahead

00:20:31,970 --> 00:20:36,080
and set up our end so we've declared her

00:20:33,859 --> 00:20:38,899
begin let's now set our end so that we

00:20:36,080 --> 00:20:41,179
decrement our event loop 20 or decrement

00:20:38,899 --> 00:20:43,700
our event loop counter 20 and so this

00:20:41,179 --> 00:20:47,720
also ensures that that send will get

00:20:43,700 --> 00:20:50,239
called if our loop has no data in it in

00:20:47,720 --> 00:20:52,100
the wild condition that we would loop

00:20:50,239 --> 00:20:54,169
forever without this additional end here

00:20:52,100 --> 00:20:55,940
because we do have an end being called

00:20:54,169 --> 00:20:57,200
within our callback but it's really

00:20:55,940 --> 00:20:59,359
important that you have it at the end

00:20:57,200 --> 00:21:00,799
there so this absolutely ensures at the

00:20:59,359 --> 00:21:04,970
Sun that we registered within that

00:21:00,799 --> 00:21:07,279
initial begin gets called so finally

00:21:04,970 --> 00:21:11,029
here's the part where we make the call

00:21:07,279 --> 00:21:13,129
to HTTP request this is the any event

00:21:11,029 --> 00:21:16,009
HTTP method that's used to retrieve the

00:21:13,129 --> 00:21:17,539
URLs when you make this call it means

00:21:16,009 --> 00:21:19,759
that you want the request to be made

00:21:17,539 --> 00:21:21,919
when possible you're not saying okay I

00:21:19,759 --> 00:21:24,349
expect this this you know particular

00:21:21,919 --> 00:21:26,239
time whatever all you're doing is saying

00:21:24,349 --> 00:21:30,739
to the event loop like hey when you have

00:21:26,239 --> 00:21:33,649
a chance i would like you to you know to

00:21:30,739 --> 00:21:35,840
do this to run this code what this does

00:21:33,649 --> 00:21:37,879
is registers anaya watcher and it tells

00:21:35,840 --> 00:21:40,849
the event loop that we're interested in

00:21:37,879 --> 00:21:42,769
this particular i/o event so when the

00:21:40,849 --> 00:21:44,809
request finishes we want to do the

00:21:42,769 --> 00:21:46,879
callback so we have a sub there that

00:21:44,809 --> 00:21:49,789
says it's going to get back as its

00:21:46,879 --> 00:21:53,029
arguments content and headers so then we

00:21:49,789 --> 00:21:56,419
want to capture the content save it into

00:21:53,029 --> 00:21:58,340
our data structure and then and then

00:21:56,419 --> 00:22:00,769
undef the request to show that we're no

00:21:58,340 --> 00:22:02,629
longer interested in this and then call

00:22:00,769 --> 00:22:05,960
our end so that we decrement our event

00:22:02,629 --> 00:22:08,179
loop counter 20 so what happens is this

00:22:05,960 --> 00:22:10,249
actual method HTTP request doesn't

00:22:08,179 --> 00:22:12,259
actually do anything in terms of

00:22:10,249 --> 00:22:14,239
processing it'll return right away but

00:22:12,259 --> 00:22:16,639
it tells the loop to call that

00:22:14,239 --> 00:22:18,440
subroutine whenever possible so

00:22:16,639 --> 00:22:20,269
basically to do the HTTP request and

00:22:18,440 --> 00:22:22,519
then we want that data so when that

00:22:20,269 --> 00:22:23,979
chunk of code runs it's important to

00:22:22,519 --> 00:22:26,629
know that the event loop is not actually

00:22:23,979 --> 00:22:28,369
in control because that subroutine is

00:22:26,629 --> 00:22:31,309
what's actually got control so the event

00:22:28,369 --> 00:22:32,869
loop says okay I got the request this is

00:22:31,309 --> 00:22:34,099
the event that we were interested in I'm

00:22:32,869 --> 00:22:35,570
going to you know I'm going to pass

00:22:34,099 --> 00:22:38,690
control over to run this chunk of code

00:22:35,570 --> 00:22:40,190
and then return the result so like I

00:22:38,690 --> 00:22:40,760
said this is a little confusing and so

00:22:40,190 --> 00:22:42,890
that's why

00:22:40,760 --> 00:22:44,420
I have the sample code it i'll have that

00:22:42,890 --> 00:22:47,120
up in a couple days for you to play with

00:22:44,420 --> 00:22:51,920
so you can see what's happening when

00:22:47,120 --> 00:22:53,870
things are happening and finally yeah we

00:22:51,920 --> 00:22:56,000
end up the request because we want to

00:22:53,870 --> 00:23:00,080
unregister our interest in this

00:22:56,000 --> 00:23:02,690
particular event and the inner begin and

00:23:00,080 --> 00:23:04,610
end define what the individual requests

00:23:02,690 --> 00:23:07,580
that we want to track in each loop are

00:23:04,610 --> 00:23:10,040
so for each begin like I said the loop

00:23:07,580 --> 00:23:12,170
will increment a counter for each end it

00:23:10,040 --> 00:23:15,200
decrements and once the counter is at

00:23:12,170 --> 00:23:16,940
zero then we're telling any event to set

00:23:15,200 --> 00:23:19,310
the convert already so that means that

00:23:16,940 --> 00:23:22,010
our promise can be fulfilled for the

00:23:19,310 --> 00:23:23,510
data that we want so again I know some

00:23:22,010 --> 00:23:24,800
of the stuff it may sound and I don't

00:23:23,510 --> 00:23:26,600
have really good pictures and i'm just

00:23:24,800 --> 00:23:28,130
showing code but i just want to say

00:23:26,600 --> 00:23:30,170
you've got to play with it it's really

00:23:28,130 --> 00:23:31,910
weird and until you've actually played

00:23:30,170 --> 00:23:34,100
with it and run it yourself and seen

00:23:31,910 --> 00:23:36,590
what's happening it's not it's not

00:23:34,100 --> 00:23:37,700
something that's not an easy thing to

00:23:36,590 --> 00:23:39,500
wrap your head around it's just

00:23:37,700 --> 00:23:42,800
something that you know that you've just

00:23:39,500 --> 00:23:44,060
got to run and and break and wonder why

00:23:42,800 --> 00:23:47,510
it's running forever and you're not

00:23:44,060 --> 00:23:50,780
getting your your results when you make

00:23:47,510 --> 00:23:52,730
a mistake um so uh asynchronous

00:23:50,780 --> 00:23:56,150
programming when should you use it you

00:23:52,730 --> 00:23:57,560
should use it when you you have you

00:23:56,150 --> 00:23:59,360
don't care about the order that things

00:23:57,560 --> 00:24:02,150
happen and you have to do a whole bunch

00:23:59,360 --> 00:24:03,350
of things at the same time one thing to

00:24:02,150 --> 00:24:06,740
note about asynchronous programming

00:24:03,350 --> 00:24:08,390
before you consider going that way is

00:24:06,740 --> 00:24:10,220
that it can be hard to read and it's

00:24:08,390 --> 00:24:12,500
really hard to maintain in this example

00:24:10,220 --> 00:24:14,210
we only had like I think one call back

00:24:12,500 --> 00:24:16,370
in there but i'll show you later on when

00:24:14,210 --> 00:24:18,800
we start interacting with RabbitMQ we're

00:24:16,370 --> 00:24:20,810
going to have like three four five you

00:24:18,800 --> 00:24:22,160
know nested callbacks in our code that

00:24:20,810 --> 00:24:24,230
we're having to jump through and deal

00:24:22,160 --> 00:24:26,780
with and that can be a real pain to

00:24:24,230 --> 00:24:28,520
maintain there is a learning curve and

00:24:26,780 --> 00:24:31,490
so there are things there are some

00:24:28,520 --> 00:24:33,350
really great modules out their promises

00:24:31,490 --> 00:24:35,600
is a really good one and I think there's

00:24:33,350 --> 00:24:37,850
some futures that can make that readable

00:24:35,600 --> 00:24:39,260
and make it easier to use you can also

00:24:37,850 --> 00:24:42,620
just do simple things like named

00:24:39,260 --> 00:24:44,300
callbacks you know there's there's a lot

00:24:42,620 --> 00:24:48,290
of different techniques out there for

00:24:44,300 --> 00:24:50,450
managing the so-called callback hell but

00:24:48,290 --> 00:24:52,160
just be aware that there is a bit of

00:24:50,450 --> 00:24:54,230
overhead so always use metrics

00:24:52,160 --> 00:24:57,020
again going back to my initial soapbox

00:24:54,230 --> 00:24:59,030
point use metrics to determine if this

00:24:57,020 --> 00:25:00,950
really buys you anything so set it up in

00:24:59,030 --> 00:25:03,620
a staging environment you know run your

00:25:00,950 --> 00:25:05,330
tests and then see compare the numbers

00:25:03,620 --> 00:25:08,600
and if it buys you something if it's a

00:25:05,330 --> 00:25:12,470
really big game than it may be worth you

00:25:08,600 --> 00:25:16,040
know taking it on have something as

00:25:12,470 --> 00:25:19,070
something to do to improve things okay

00:25:16,040 --> 00:25:20,900
so and I'll take questions at the end so

00:25:19,070 --> 00:25:25,130
I know this is like I said I know this

00:25:20,900 --> 00:25:26,930
stuff is crazy so the second improvement

00:25:25,130 --> 00:25:29,120
that we want to make and part of why I

00:25:26,930 --> 00:25:30,590
introduced some of the any event stuff

00:25:29,120 --> 00:25:34,280
is because we are using any event

00:25:30,590 --> 00:25:36,050
RabbitMQ to talk to RabbitMQ so so that

00:25:34,280 --> 00:25:38,000
way you can kind of understand like what

00:25:36,050 --> 00:25:40,100
some of those variables mean as we're

00:25:38,000 --> 00:25:41,540
looking at that connection logic so the

00:25:40,100 --> 00:25:44,300
second improvement is we'll go ahead and

00:25:41,540 --> 00:25:46,220
create a work queue this can also be

00:25:44,300 --> 00:25:48,890
referred to as the publisher subscriber

00:25:46,220 --> 00:25:50,350
model the idea is that you push the work

00:25:48,890 --> 00:25:53,330
off so if you have a web application

00:25:50,350 --> 00:25:55,580
that needs to do some work you push that

00:25:53,330 --> 00:25:57,890
work off to a worker script and so you

00:25:55,580 --> 00:25:59,720
say you you create essentially a ticket

00:25:57,890 --> 00:26:02,720
in some kind of a message or a ticket

00:25:59,720 --> 00:26:05,510
like a message something you know you

00:26:02,720 --> 00:26:07,220
think of like people working you know if

00:26:05,510 --> 00:26:08,630
you've ever worked i T or any kind of

00:26:07,220 --> 00:26:10,970
customer support you get tickets

00:26:08,630 --> 00:26:12,350
customer calls and makes a complaint you

00:26:10,970 --> 00:26:14,300
get a ticket and then somebody

00:26:12,350 --> 00:26:16,520
eventually picks it up does the work and

00:26:14,300 --> 00:26:17,510
marks the ticket is done and so

00:26:16,520 --> 00:26:18,770
essentially that's what we're

00:26:17,510 --> 00:26:20,420
implementing you have your web

00:26:18,770 --> 00:26:22,850
application pushing something off to a

00:26:20,420 --> 00:26:24,830
queue you have a worker script that you

00:26:22,850 --> 00:26:27,110
might have running say via cron job and

00:26:24,830 --> 00:26:29,930
that worker script then checks the queue

00:26:27,110 --> 00:26:32,360
for any jobs that need to be done does

00:26:29,930 --> 00:26:34,400
the work and post the results somewhere

00:26:32,360 --> 00:26:36,350
which then your web application can

00:26:34,400 --> 00:26:38,510
consume that's a very specific example

00:26:36,350 --> 00:26:42,020
but worker cues can be used for a

00:26:38,510 --> 00:26:45,010
variety of problems so what what kinds

00:26:42,020 --> 00:26:45,010
of things are they good for

00:26:48,830 --> 00:26:52,340
but since I Wi-Fi

00:26:52,470 --> 00:26:54,470
I

00:27:56,890 --> 00:28:00,030
I guess

00:28:00,710 --> 00:28:08,779
uh so in this example there are a few

00:28:07,100 --> 00:28:11,419
different options you have if you want

00:28:08,779 --> 00:28:13,720
to use a worker q pattern I happen to

00:28:11,419 --> 00:28:16,880
views RabbitMQ and I like it all right

00:28:13,720 --> 00:28:18,590
there's also Redis recue where you can

00:28:16,880 --> 00:28:20,270
use Redis there's a pearl library called

00:28:18,590 --> 00:28:22,130
Redis freak you that lets you treat

00:28:20,270 --> 00:28:24,380
Redis is a queue you can also just use a

00:28:22,130 --> 00:28:26,179
table in a database I mean really all

00:28:24,380 --> 00:28:29,059
you want is is something that's going to

00:28:26,179 --> 00:28:31,279
store messages I like RabbitMQ because

00:28:29,059 --> 00:28:34,159
it's basically made for that it's mean

00:28:31,279 --> 00:28:36,230
for message passing and there's no order

00:28:34,159 --> 00:28:38,899
guaranteed to the messages so it's not

00:28:36,230 --> 00:28:40,399
necessarily a first-in-first-out and I

00:28:38,899 --> 00:28:43,669
think that it does a pretty good job of

00:28:40,399 --> 00:28:45,169
message management so like if you have

00:28:43,669 --> 00:28:47,630
like say you have a cron job and you

00:28:45,169 --> 00:28:48,980
have a worker that's stuck processing

00:28:47,630 --> 00:28:50,480
some job and it's been doing it for a

00:28:48,980 --> 00:28:52,580
long time and then the next one kicks

00:28:50,480 --> 00:28:54,169
off its not going to pick up the same

00:28:52,580 --> 00:28:57,590
message rabbitmq is pretty good at

00:28:54,169 --> 00:28:58,850
managing who's gotten what so you know

00:28:57,590 --> 00:29:00,649
so that's something and you can also

00:28:58,850 --> 00:29:03,350
configure it to do some pretty fancy

00:29:00,649 --> 00:29:04,760
forwarding of messages throughout Q so

00:29:03,350 --> 00:29:06,919
I'm not going to go into all of that but

00:29:04,760 --> 00:29:08,480
i would i would recommend that you check

00:29:06,919 --> 00:29:10,070
out the rabbit and cue docs if you think

00:29:08,480 --> 00:29:12,110
this sounds like something that that

00:29:10,070 --> 00:29:14,809
could work for a problem that you might

00:29:12,110 --> 00:29:16,700
be having ok so here's a big question

00:29:14,809 --> 00:29:18,020
what does asynchronous programming have

00:29:16,700 --> 00:29:19,429
to do with ravyn mq what are these

00:29:18,020 --> 00:29:23,330
things why are these even in the same

00:29:19,429 --> 00:29:25,340
talk well rabbitmq has a special wave of

00:29:23,330 --> 00:29:27,559
requiring connections sokka's

00:29:25,340 --> 00:29:29,840
traditionally are blocking in that the

00:29:27,559 --> 00:29:31,730
actual connection attempt will block

00:29:29,840 --> 00:29:34,850
until the connection is available any of

00:29:31,730 --> 00:29:36,140
you that have done socket i/o and had

00:29:34,850 --> 00:29:38,090
time outs as everything freezes

00:29:36,140 --> 00:29:42,020
everything locks until this thing

00:29:38,090 --> 00:29:45,980
returns so RabbitMQ is a little bit

00:29:42,020 --> 00:29:49,570
different in Perl we typically use any

00:29:45,980 --> 00:29:51,770
event RabbitMQ to talk to RabbitMQ but

00:29:49,570 --> 00:29:53,270
there I know that there are a few other

00:29:51,770 --> 00:29:55,429
options out there just this is the one

00:29:53,270 --> 00:29:58,730
that I've used in the one I've seen most

00:29:55,429 --> 00:30:00,620
often but any time like you need to wait

00:29:58,730 --> 00:30:02,779
say for HTTP requests you need to

00:30:00,620 --> 00:30:04,580
respond to error messages you want to be

00:30:02,779 --> 00:30:06,470
able to manage this in a timely manner

00:30:04,580 --> 00:30:09,049
and you don't want to be stuck waiting

00:30:06,470 --> 00:30:11,779
on a socket connection in addition to

00:30:09,049 --> 00:30:13,230
that rabbitmq does expect a little bit

00:30:11,779 --> 00:30:15,750
more from its listeners so

00:30:13,230 --> 00:30:18,990
here's the caveat if you're using a web

00:30:15,750 --> 00:30:20,660
application that's blocking a typical

00:30:18,990 --> 00:30:23,040
web application only gets control

00:30:20,660 --> 00:30:25,860
whenever it receives a request whenever

00:30:23,040 --> 00:30:27,960
somebody says okay I want / foo then you

00:30:25,860 --> 00:30:30,750
know the web the web application says oh

00:30:27,960 --> 00:30:33,210
oh oh okay let me give you that rabbitmq

00:30:30,750 --> 00:30:34,980
on the other hand when it makes a

00:30:33,210 --> 00:30:37,169
connection it has listeners and

00:30:34,980 --> 00:30:39,210
publishers registered with it and it'll

00:30:37,169 --> 00:30:40,919
send a little ping called a heartbeat

00:30:39,210 --> 00:30:42,540
and it needs to make sure there's

00:30:40,919 --> 00:30:44,580
something to respond to it on the other

00:30:42,540 --> 00:30:48,090
side otherwise it'll stop sending

00:30:44,580 --> 00:30:49,320
messages so basically you have to have

00:30:48,090 --> 00:30:51,600
something that can listen to the

00:30:49,320 --> 00:30:54,870
heartbeats and respond you need an event

00:30:51,600 --> 00:30:56,429
loop basically if you can't you can't do

00:30:54,870 --> 00:30:59,010
that easily in a blocking framework

00:30:56,429 --> 00:31:00,510
because you are only in control when you

00:30:59,010 --> 00:31:02,910
get a request so what will happen is

00:31:00,510 --> 00:31:04,530
rabbitmq will hang up on you so unless

00:31:02,910 --> 00:31:08,910
you want to hang up and reconnect every

00:31:04,530 --> 00:31:10,230
single time you send a message then you

00:31:08,910 --> 00:31:12,780
could potentially run into some problems

00:31:10,230 --> 00:31:15,270
there so mojolicious fortunately has a

00:31:12,780 --> 00:31:18,600
mojo i/o loop that will handle multiple

00:31:15,270 --> 00:31:22,830
reactor backends dancer I was just

00:31:18,600 --> 00:31:25,980
speaking with yannick has a has a

00:31:22,830 --> 00:31:28,230
plug-in is that right a plug-in yeah has

00:31:25,980 --> 00:31:30,299
a plug-in that a little dancer one

00:31:28,230 --> 00:31:31,919
that'll help with some asynchronous

00:31:30,299 --> 00:31:34,530
stuff and I'm not sure about dance or

00:31:31,919 --> 00:31:35,850
two you know so other things that's

00:31:34,530 --> 00:31:38,040
that's a big question that you want to

00:31:35,850 --> 00:31:40,049
ask with your web framework how does it

00:31:38,040 --> 00:31:42,330
handle i/o loops does it have an

00:31:40,049 --> 00:31:43,559
asynchronous i/o loop how does it you

00:31:42,330 --> 00:31:44,970
know how does it work with these kinds

00:31:43,559 --> 00:31:47,549
of things so that that's an important

00:31:44,970 --> 00:31:52,260
question to know before you decide to

00:31:47,549 --> 00:31:53,520
use something like RabbitMQ so basically

00:31:52,260 --> 00:31:55,799
the publisher needs to create a

00:31:53,520 --> 00:31:57,570
connection with the RabbitMQ server when

00:31:55,799 --> 00:31:59,490
the connection is established an

00:31:57,570 --> 00:32:00,900
exchange is created and then the

00:31:59,490 --> 00:32:02,940
exchange handles all the incoming

00:32:00,900 --> 00:32:04,980
updates and redistributes them to the

00:32:02,940 --> 00:32:06,660
available queues so when an exchange is

00:32:04,980 --> 00:32:09,299
created that means messages can be sent

00:32:06,660 --> 00:32:11,970
which is this is the the am q ya a QP

00:32:09,299 --> 00:32:13,530
protocol that RabbitMQ uses and this is

00:32:11,970 --> 00:32:15,510
just you know one particular way of

00:32:13,530 --> 00:32:16,679
implementing this so essentially if you

00:32:15,510 --> 00:32:18,809
don't remember anything else just

00:32:16,679 --> 00:32:20,549
remember if you don't have a response to

00:32:18,809 --> 00:32:22,020
the heartbeat you're not going to have a

00:32:20,549 --> 00:32:22,790
rabid mq connection and you're going to

00:32:22,020 --> 00:32:25,070
have

00:32:22,790 --> 00:32:27,020
tivity issues in your application so

00:32:25,070 --> 00:32:30,320
this is why we're setting up an

00:32:27,020 --> 00:32:33,620
asynchronous connection to RabbitMQ so

00:32:30,320 --> 00:32:35,990
step one well we want to replace the

00:32:33,620 --> 00:32:39,830
original work section with pushing a

00:32:35,990 --> 00:32:41,120
message to RabbitMQ so again there's a

00:32:39,830 --> 00:32:43,160
lot of stuff here you need to think

00:32:41,120 --> 00:32:45,260
about how you want to record do you want

00:32:43,160 --> 00:32:47,750
to keep a record of the queue data do

00:32:45,260 --> 00:32:49,490
you need to recreate the queue you know

00:32:47,750 --> 00:32:51,200
anything you push to RabbitMQ like how

00:32:49,490 --> 00:32:53,540
important are these messages or is it

00:32:51,200 --> 00:32:54,740
okay if they get lost with ravyn mq

00:32:53,540 --> 00:32:56,510
you're typically not going to get any

00:32:54,740 --> 00:32:59,390
persistence there are some options too

00:32:56,510 --> 00:33:00,800
but just think of it as like you know if

00:32:59,390 --> 00:33:02,090
it's really important you probably want

00:33:00,800 --> 00:33:04,190
to have some kind of a record somewhere

00:33:02,090 --> 00:33:06,410
or maybe you want to use something a

00:33:04,190 --> 00:33:08,180
little different for your queueing but

00:33:06,410 --> 00:33:09,260
if all you're doing is like things that

00:33:08,180 --> 00:33:12,050
can be forgotten like in the case of

00:33:09,260 --> 00:33:13,700
these report generation requests you

00:33:12,050 --> 00:33:15,530
know maybe the even in the sample

00:33:13,700 --> 00:33:17,540
application the user has a list of their

00:33:15,530 --> 00:33:19,670
report requests if something happens and

00:33:17,540 --> 00:33:21,730
something gets lost it'll just the

00:33:19,670 --> 00:33:23,660
report will never update and so then

00:33:21,730 --> 00:33:25,220
excuse me so then you might want a

00:33:23,660 --> 00:33:26,510
mechanism for that in this case they

00:33:25,220 --> 00:33:28,010
would just call you and say hey why

00:33:26,510 --> 00:33:29,600
didn't my report ever run oh just

00:33:28,010 --> 00:33:33,830
resubmit it you know and then we'll

00:33:29,600 --> 00:33:34,940
we'll figure it out so our first thing

00:33:33,830 --> 00:33:36,290
that we're going to do this code

00:33:34,940 --> 00:33:40,040
probably looks a little familiar because

00:33:36,290 --> 00:33:42,500
we have our conv our and then we set we

00:33:40,040 --> 00:33:44,660
set up our RabbitMQ connection these are

00:33:42,500 --> 00:33:46,880
basically the default values when you

00:33:44,660 --> 00:33:49,910
install RabbitMQ initially and that's

00:33:46,880 --> 00:33:52,340
what's being used in the sample app so

00:33:49,910 --> 00:33:55,850
here we're registering that we want so

00:33:52,340 --> 00:33:57,650
we're setting up our connection and then

00:33:55,850 --> 00:34:00,230
here's where so open channel is pretty

00:33:57,650 --> 00:34:02,450
similar to our HTTP requests oh you know

00:34:00,230 --> 00:34:04,190
we're making our function call and we're

00:34:02,450 --> 00:34:05,810
saying and now in this you'll see

00:34:04,190 --> 00:34:07,460
something a little different if you've

00:34:05,810 --> 00:34:08,960
done any node this looks a little

00:34:07,460 --> 00:34:11,150
different a little bit like that where

00:34:08,960 --> 00:34:13,669
you say on success this is what I want

00:34:11,150 --> 00:34:16,370
in the sample code and in the on the

00:34:13,669 --> 00:34:18,470
module any event RabbitMQ there's also

00:34:16,370 --> 00:34:20,750
conditions for on failure so that you

00:34:18,470 --> 00:34:22,250
can handle different events that might

00:34:20,750 --> 00:34:25,040
happen depending on what happens with

00:34:22,250 --> 00:34:27,080
your with your connection but here we're

00:34:25,040 --> 00:34:29,660
going to declare Q we're saying i want

00:34:27,080 --> 00:34:31,410
the reports queue and then we publish

00:34:29,660 --> 00:34:33,690
our body you know

00:34:31,410 --> 00:34:36,360
up our our header because we want to use

00:34:33,690 --> 00:34:38,220
JSON we set it to the body and then our

00:34:36,360 --> 00:34:40,590
routing key there is actually the name

00:34:38,220 --> 00:34:43,530
of the queue so we set that up we

00:34:40,590 --> 00:34:45,300
publish it and and then we call our send

00:34:43,530 --> 00:34:47,490
event so when we call that sent event

00:34:45,300 --> 00:34:50,010
remember that says okay this is our

00:34:47,490 --> 00:34:51,660
ready state so once this has been posted

00:34:50,010 --> 00:34:54,030
to the channel or once this has been

00:34:51,660 --> 00:34:56,370
published to the queue we're done and so

00:34:54,030 --> 00:34:57,990
then I want I want the conver to return

00:34:56,370 --> 00:34:59,970
we don't actually want anything back

00:34:57,990 --> 00:35:02,490
from the conv are so in this case it's

00:34:59,970 --> 00:35:04,230
you know it's pretty straightforward but

00:35:02,490 --> 00:35:06,210
that's so that's how to read that code

00:35:04,230 --> 00:35:09,240
if anything just think of okay there's a

00:35:06,210 --> 00:35:10,650
conv are there's some kind of a function

00:35:09,240 --> 00:35:12,300
call their this open channel that's

00:35:10,650 --> 00:35:16,020
registering our interest in that event

00:35:12,300 --> 00:35:19,020
and send is saying now we're done so

00:35:16,020 --> 00:35:22,740
step two we need to move the work to a

00:35:19,020 --> 00:35:24,660
worker script so a few again a few terms

00:35:22,740 --> 00:35:27,390
to look for here and again you can look

00:35:24,660 --> 00:35:29,250
at the any event RabbitMQ stuff to get

00:35:27,390 --> 00:35:30,720
more information but these are some of

00:35:29,250 --> 00:35:32,670
the key things here again our method

00:35:30,720 --> 00:35:35,070
instead of so we have our open channel

00:35:32,670 --> 00:35:36,720
and we're here we're using it onto a

00:35:35,070 --> 00:35:38,940
callback bound to a non success

00:35:36,720 --> 00:35:41,490
condition as before and so in this case

00:35:38,940 --> 00:35:43,530
we want to consume the message and so

00:35:41,490 --> 00:35:46,260
that's in our rabbonim in any event

00:35:43,530 --> 00:35:49,170
RabbitMQ that's the word for give me the

00:35:46,260 --> 00:35:50,880
message and this is how this is an

00:35:49,170 --> 00:35:54,510
example of how you would get the content

00:35:50,880 --> 00:35:56,940
from the message the message is passed

00:35:54,510 --> 00:35:59,550
in to the call back as the first

00:35:56,940 --> 00:36:01,950
argument as there and so then that's how

00:35:59,550 --> 00:36:05,100
you get that data so you get the payload

00:36:01,950 --> 00:36:07,110
from the message the channel ack that's

00:36:05,100 --> 00:36:08,730
that's just telling RabbitMQ that we

00:36:07,110 --> 00:36:10,440
received the message so don't let

00:36:08,730 --> 00:36:16,880
anybody else process this one ever

00:36:10,440 --> 00:36:19,650
because we're done we've done it so

00:36:16,880 --> 00:36:21,510
let's see oh so this is so this is the

00:36:19,650 --> 00:36:23,970
code that I originally wrote so remember

00:36:21,510 --> 00:36:26,070
that here I'm calling this report

00:36:23,970 --> 00:36:28,770
builder build rapport thing now in build

00:36:26,070 --> 00:36:31,920
rapport we're doing this at HTTP of the

00:36:28,770 --> 00:36:34,500
asynchronous HTTP requests okay that's

00:36:31,920 --> 00:36:36,780
pretty cool so we're doing this work

00:36:34,500 --> 00:36:38,370
with RabbitMQ we've got you know an

00:36:36,780 --> 00:36:39,870
asynchronous thing going on here we've

00:36:38,370 --> 00:36:41,340
got an event that we're interested in

00:36:39,870 --> 00:36:42,119
and then we've got something else going

00:36:41,340 --> 00:36:45,960
on further

00:36:42,119 --> 00:36:52,079
in the library stack we're calling these

00:36:45,960 --> 00:36:53,940
URLs so these URLs this is just showing

00:36:52,079 --> 00:36:57,930
so sub build rapport makes a call to

00:36:53,940 --> 00:37:00,059
this get data from URLs and then here at

00:36:57,930 --> 00:37:02,670
the bottom we've got this receive events

00:37:00,059 --> 00:37:04,890
so what happens if we actually run this

00:37:02,670 --> 00:37:08,369
code in this state you get this

00:37:04,890 --> 00:37:12,749
wonderful eros telling us that within

00:37:08,369 --> 00:37:15,089
our within our with inner functionality

00:37:12,749 --> 00:37:16,799
we have a recursive block or because

00:37:15,089 --> 00:37:19,819
receive blocks so we've a blocking

00:37:16,799 --> 00:37:23,249
condition we're trying to tell our the

00:37:19,819 --> 00:37:24,930
event loop like you know stop here I

00:37:23,249 --> 00:37:26,519
need this right now and event loops just

00:37:24,930 --> 00:37:28,019
don't I mean it just doesn't work though

00:37:26,519 --> 00:37:29,819
that whole process just doesn't work

00:37:28,019 --> 00:37:31,019
that way so this is why it's really

00:37:29,819 --> 00:37:32,819
important when you're doing these

00:37:31,019 --> 00:37:34,799
libraries that you need to move things

00:37:32,819 --> 00:37:36,869
up to the top level the way you move

00:37:34,799 --> 00:37:41,730
things up to the top level is that you

00:37:36,869 --> 00:37:43,079
use callbacks not CV you only use CV at

00:37:41,730 --> 00:37:45,900
the highest level so this was a mistake

00:37:43,079 --> 00:37:48,749
in the previous library design there's

00:37:45,900 --> 00:37:51,059
something else so you fix that but then

00:37:48,749 --> 00:37:52,440
you've got to use callbacks because here

00:37:51,059 --> 00:37:54,930
you see how we're passing and we're

00:37:52,440 --> 00:37:56,880
getting this HTTP data result and then

00:37:54,930 --> 00:37:58,230
we say get data from the URL so after

00:37:56,880 --> 00:38:00,779
our request is done we want that

00:37:58,230 --> 00:38:03,269
resulting data structure the problem is

00:38:00,779 --> 00:38:06,559
is that HTTP data isn't going to get

00:38:03,269 --> 00:38:09,299
back the data structure that we expect

00:38:06,559 --> 00:38:11,069
anything that depends on any sort of

00:38:09,299 --> 00:38:14,309
return value actually needs to go into a

00:38:11,069 --> 00:38:15,569
call back so that's why callbacks when

00:38:14,309 --> 00:38:17,190
you start getting into asynchronous

00:38:15,569 --> 00:38:18,930
programming you start seeing all these

00:38:17,190 --> 00:38:21,239
nestings of callbacks especially as you

00:38:18,930 --> 00:38:23,549
get more abstracted functionality so how

00:38:21,239 --> 00:38:25,200
would we change this well the first

00:38:23,549 --> 00:38:27,299
thing that we would want to do is in our

00:38:25,200 --> 00:38:29,730
library in our subroutine where we're

00:38:27,299 --> 00:38:31,529
calling the report builder we want to

00:38:29,730 --> 00:38:33,420
change our get data from URLs because

00:38:31,529 --> 00:38:36,749
remember this is where we're doing the

00:38:33,420 --> 00:38:39,509
the work to call to get our stuff from

00:38:36,749 --> 00:38:41,700
these external api's so we want to move

00:38:39,509 --> 00:38:43,920
all the stuff that we're doing after

00:38:41,700 --> 00:38:45,779
that call with HTTP data and anything

00:38:43,920 --> 00:38:48,539
that depends on that into a subroutine

00:38:45,779 --> 00:38:49,829
and so will do stuff so we'll do all of

00:38:48,539 --> 00:38:53,339
our stuff in there

00:38:49,829 --> 00:38:54,959
instead of instead of relying on that as

00:38:53,339 --> 00:38:58,079
a return value and then doing it in the

00:38:54,959 --> 00:39:01,019
more procedural manner we also want to

00:38:58,079 --> 00:39:03,269
replace that receive that we had at the

00:39:01,019 --> 00:39:05,940
bottom in our original function and we

00:39:03,269 --> 00:39:08,729
want to make a call to the CB function

00:39:05,940 --> 00:39:11,549
so whenever it completes and something

00:39:08,729 --> 00:39:14,219
is sent to the CV when our conv are is

00:39:11,549 --> 00:39:16,170
ready the CB function of the CV

00:39:14,219 --> 00:39:19,170
basically calls a function as soon as it

00:39:16,170 --> 00:39:21,329
completes so as soon as we hit send this

00:39:19,170 --> 00:39:23,910
callback function is going to trigger I

00:39:21,329 --> 00:39:29,130
know this is you like I said this is a

00:39:23,910 --> 00:39:32,779
little bit crazy so finally so let me

00:39:29,130 --> 00:39:35,329
see yeah that's Pro anyways so

00:39:32,779 --> 00:39:40,319
essentially I'll have sample code up

00:39:35,329 --> 00:39:41,849
that covers this on on github so you can

00:39:40,319 --> 00:39:44,069
actually see it in action you can play

00:39:41,849 --> 00:39:46,680
with it you can try to break things and

00:39:44,069 --> 00:39:48,509
I think that'll be pretty helpful I hope

00:39:46,680 --> 00:39:49,920
it'll be pretty helpful so in a nutshell

00:39:48,509 --> 00:39:52,680
I know this was like a lot of

00:39:49,920 --> 00:39:54,209
information and I know it was you know

00:39:52,680 --> 00:39:56,339
asynchronous programming I'm just gonna

00:39:54,209 --> 00:39:59,130
end and say it's not easy and there's no

00:39:56,339 --> 00:40:00,509
easy way I think to explain it and so my

00:39:59,130 --> 00:40:04,410
approach has really just been let's take

00:40:00,509 --> 00:40:06,989
some real life examples let's try you

00:40:04,410 --> 00:40:08,519
know let's let's just let's just see

00:40:06,989 --> 00:40:11,729
what happens when you actually try to do

00:40:08,519 --> 00:40:13,890
things in the wild and I wanted to

00:40:11,729 --> 00:40:17,999
actually show really quick before I take

00:40:13,890 --> 00:40:21,180
questions what the sample looks like let

00:40:17,999 --> 00:40:23,069
me see if I can I normally use xmonad

00:40:21,180 --> 00:40:25,380
and I've been trying out ubuntu unity

00:40:23,069 --> 00:40:28,380
and i don't know how i feel about it but

00:40:25,380 --> 00:40:31,199
here's our here's our sample report this

00:40:28,380 --> 00:40:32,430
is a lovely helpful report name you know

00:40:31,199 --> 00:40:34,259
but here we're getting you know we'll

00:40:32,430 --> 00:40:35,519
say it's a it's a weather api that's

00:40:34,259 --> 00:40:40,499
getting some weather we're getting a

00:40:35,519 --> 00:40:43,469
random image and then and then here's

00:40:40,499 --> 00:40:45,180
the the repo that'll be available as

00:40:43,469 --> 00:40:46,589
soon as i do some code cleanup on it and

00:40:45,180 --> 00:40:49,650
clean up the commit history so it's

00:40:46,589 --> 00:40:52,559
actually useful but uh just really quick

00:40:49,650 --> 00:40:54,749
it'll have three folders here the

00:40:52,559 --> 00:40:57,779
original version which is the one that

00:40:54,749 --> 00:40:59,519
takes a long time the blocking one we

00:40:57,779 --> 00:41:01,559
have our async version which is the

00:40:59,519 --> 00:41:02,760
actually kind of bad library

00:41:01,559 --> 00:41:04,650
implementation so you

00:41:02,760 --> 00:41:07,050
play around with that and understand why

00:41:04,650 --> 00:41:09,570
it's bad but also see some of the

00:41:07,050 --> 00:41:13,140
benefits of switching some simultaneous

00:41:09,570 --> 00:41:15,360
HTTP requests and then our worker q

00:41:13,140 --> 00:41:17,850
example and so that you can actually see

00:41:15,360 --> 00:41:19,680
like what happens a when you have to

00:41:17,850 --> 00:41:22,020
make like nested asynchronous requests

00:41:19,680 --> 00:41:24,750
but then also have some sample code that

00:41:22,020 --> 00:41:27,180
you can use for talking to RabbitMQ so

00:41:24,750 --> 00:41:28,740
that's it and I'm happy to take

00:41:27,180 --> 00:41:33,750
questions I may or may not be able to

00:41:28,740 --> 00:41:36,650
answer them yes where you get your

00:41:33,750 --> 00:41:39,180
pictures and people with carrots burgers

00:41:36,650 --> 00:41:43,380
well I work for shutterstock which is a

00:41:39,180 --> 00:41:45,330
stock photography company and so just so

00:41:43,380 --> 00:41:47,850
you know I with the sample code there

00:41:45,330 --> 00:41:50,190
are some images these are only for use

00:41:47,850 --> 00:41:51,750
with the sample code they're not to be

00:41:50,190 --> 00:41:54,030
redistributed because they are licensed

00:41:51,750 --> 00:41:55,920
stock photography images so that's the

00:41:54,030 --> 00:41:57,630
disclaimer it'll be up there but I think

00:41:55,920 --> 00:42:01,380
they're so to such cool images I'm gonna

00:41:57,630 --> 00:42:03,780
gonna flip back to that there's all

00:42:01,380 --> 00:42:06,200
kinds of cool stuff up there anyways yes

00:42:03,780 --> 00:42:06,200
right there

00:42:07,029 --> 00:42:13,339
thank you is that happening after all

00:42:10,819 --> 00:42:17,180
your HD kinky requests have finished or

00:42:13,339 --> 00:42:19,789
every beautiful um right so it actually

00:42:17,180 --> 00:42:22,579
happens I believe after maybe somebody

00:42:19,789 --> 00:42:24,799
else can can clarify if I'm wrong but I

00:42:22,579 --> 00:42:27,380
believe it happens after so you may call

00:42:24,799 --> 00:42:29,410
your HTTP requests and then you've

00:42:27,380 --> 00:42:32,299
registered that send event outside of

00:42:29,410 --> 00:42:34,999
outside of the HTTP requests that weight

00:42:32,299 --> 00:42:38,619
the act for the RabbitMQ yes yeah it

00:42:34,999 --> 00:42:38,619
happens after everything else is done

00:42:41,300 --> 00:42:47,970
no not with RabbitMQ and so with

00:42:45,570 --> 00:42:50,340
RabbitMQ it basically it'll reserve the

00:42:47,970 --> 00:42:53,030
message and registry q does the same

00:42:50,340 --> 00:42:56,580
thing when a worker picks up a message

00:42:53,030 --> 00:42:58,680
it's because it with a with RabbitMQ it

00:42:56,580 --> 00:43:00,210
uses that publisher subscribe model so

00:42:58,680 --> 00:43:01,530
when a worker picks up a message it

00:43:00,210 --> 00:43:03,990
knows that a worker has picked up a

00:43:01,530 --> 00:43:07,530
message so it'll reserve it for a short

00:43:03,990 --> 00:43:09,720
period of time until until later and i

00:43:07,530 --> 00:43:11,220
recommend even in your error conditions

00:43:09,720 --> 00:43:13,680
like if something fails with processing

00:43:11,220 --> 00:43:15,660
the message i recommend that you go

00:43:13,680 --> 00:43:17,340
ahead and a kit because you don't want

00:43:15,660 --> 00:43:19,800
to have the same message being picked up

00:43:17,340 --> 00:43:21,480
a whole bunch and like you know dirtying

00:43:19,800 --> 00:43:23,880
up your logs i think it's better to pick

00:43:21,480 --> 00:43:26,880
up a dirty message or a fault something

00:43:23,880 --> 00:43:28,770
that's aired and then and then just lose

00:43:26,880 --> 00:43:30,900
it like basically log i wasn't able to

00:43:28,770 --> 00:43:33,360
do this here's the data and then just

00:43:30,900 --> 00:43:34,770
dump it from the queue so that way you

00:43:33,360 --> 00:43:36,500
know when the user assuming you have

00:43:34,770 --> 00:43:38,340
some other process that's monitoring

00:43:36,500 --> 00:43:39,720
comes to you and is like hey what

00:43:38,340 --> 00:43:41,910
happened to my report then you can look

00:43:39,720 --> 00:43:46,580
at logs and see what happened without it

00:43:41,910 --> 00:43:46,580
backing up everything else yes

00:43:47,890 --> 00:43:54,039
first table can you crossing any supper

00:43:50,980 --> 00:43:57,039
to Nicole back in there yes what is that

00:43:54,039 --> 00:43:58,990
I executed is that executes it when you

00:43:57,039 --> 00:44:02,710
that takes the condition variable is

00:43:58,990 --> 00:44:05,470
zero yeah so that's actually executed

00:44:02,710 --> 00:44:07,450
when the condition variable is ready so

00:44:05,470 --> 00:44:09,609
and it's ready when like if we're using

00:44:07,450 --> 00:44:11,680
that begin in n block whatever that

00:44:09,609 --> 00:44:14,619
counter is in the event loop when that

00:44:11,680 --> 00:44:18,400
hits zero that's telling that's telling

00:44:14,619 --> 00:44:20,529
it yes so if you call that multiple

00:44:18,400 --> 00:44:23,619
times is your incrementing they will be

00:44:20,529 --> 00:44:27,940
five when you're when you receive it

00:44:23,619 --> 00:44:30,010
read the same the room ends I'm sorry so

00:44:27,940 --> 00:44:31,750
if you were cool but multiple you'll

00:44:30,010 --> 00:44:34,800
prolly be get more time yeah ours

00:44:31,750 --> 00:44:38,040
multiple separate texts about each time

00:44:34,800 --> 00:44:41,490
yes it right aprendiendo spoiler

00:44:38,040 --> 00:44:43,410
actually it's just the last caution to

00:44:41,490 --> 00:44:45,420
that some people ok so it's the last

00:44:43,410 --> 00:44:47,310
time you that when you said be getting

00:44:45,420 --> 00:44:49,950
last syllable of all of them are

00:44:47,310 --> 00:44:52,560
completed when I have good 0 then the

00:44:49,950 --> 00:44:54,910
last pot luck

00:44:52,560 --> 00:44:56,560
yeah sorry that was I should have been

00:44:54,910 --> 00:44:58,090
more clear about that in the slide but

00:44:56,560 --> 00:44:59,950
yeah you only register it with the first

00:44:58,090 --> 00:45:01,660
begin because that's your ultimate ready

00:44:59,950 --> 00:45:03,880
state like that's where you're like this

00:45:01,660 --> 00:45:09,040
is the end this is really no I mean this

00:45:03,880 --> 00:45:11,140
is really when we're ready Lutz how am i

00:45:09,040 --> 00:45:12,760
doing on time it looks like i have about

00:45:11,140 --> 00:45:14,830
four minutes does anybody else have any

00:45:12,760 --> 00:45:16,990
questions so any what we say is doing

00:45:14,830 --> 00:45:19,500
the work simultaneously is it like

00:45:16,990 --> 00:45:22,000
wedding in simultaneously or is it

00:45:19,500 --> 00:45:23,620
that's a good question does anybody who

00:45:22,000 --> 00:45:25,060
knows the guts of any event like for me

00:45:23,620 --> 00:45:27,100
I just know like I don't know it just it

00:45:25,060 --> 00:45:29,980
has this event lay up in it does things

00:45:27,100 --> 00:45:33,820
I see you some extra stuff your single

00:45:29,980 --> 00:45:37,930
friend just six what it's those holes

00:45:33,820 --> 00:45:40,240
it's still single for Islam yeah I walk

00:45:37,930 --> 00:45:42,799
waiting for all the responses right

00:45:40,240 --> 00:45:45,349
schedules

00:45:42,799 --> 00:45:47,209
yeah so right so it's yet it's

00:45:45,349 --> 00:45:49,009
scheduling things that's sending off the

00:45:47,209 --> 00:45:50,089
requests and then it's kind of like if

00:45:49,009 --> 00:45:52,719
you think of like when you click a mouse

00:45:50,089 --> 00:45:56,059
button like you just have a listener

00:45:52,719 --> 00:45:58,069
running on the button and the UI and so

00:45:56,059 --> 00:45:59,660
it's just listening specifically for

00:45:58,069 --> 00:46:01,039
that response for that one particular

00:45:59,660 --> 00:46:02,900
event so in this case it's specifically

00:46:01,039 --> 00:46:04,640
listening for that I owe event to have

00:46:02,900 --> 00:46:06,049
some some data come back this is

00:46:04,640 --> 00:46:09,319
confusing like this GUI is usually

00:46:06,049 --> 00:46:11,179
involve I dread right oh yeah example in

00:46:09,319 --> 00:46:14,539
that brings in the integer multi Smith

00:46:11,179 --> 00:46:17,209
great for the home yeah at the point

00:46:14,539 --> 00:46:19,009
where if you have broken out and she

00:46:17,209 --> 00:46:26,049
like to work here they'll get also can

00:46:19,009 --> 00:46:26,049
promise many yeah

00:46:27,750 --> 00:46:32,040
alright well thank you so much and again

00:46:30,150 --> 00:46:33,750
feel free to email me or if you think of

00:46:32,040 --> 00:46:36,330
any questions or like I said I'll send

00:46:33,750 --> 00:46:39,090
something out to the apps emailing list

00:46:36,330 --> 00:46:41,970
when in posts i guess in the IRC channel

00:46:39,090 --> 00:46:43,440
when i've got the code published but

00:46:41,970 --> 00:46:46,710
like i said i know this stuff is

00:46:43,440 --> 00:46:48,990
confusing I for me like recently I like

00:46:46,710 --> 00:46:50,460
learn how to use it and felt I should do

00:46:48,990 --> 00:46:53,310
a talk about it so that I can explain

00:46:50,460 --> 00:46:54,390
why so and I was hoping thank you that

00:46:53,310 --> 00:46:55,860
there are people in the audience that

00:46:54,390 --> 00:46:58,590
understand the why a little better than

00:46:55,860 --> 00:47:00,030
I do so but I was hoping like as a

00:46:58,590 --> 00:47:04,110
person that's had to navigate this

00:47:00,030 --> 00:47:05,640
landscape that maybe having to explain

00:47:04,110 --> 00:47:08,070
it to you from that perspective might

00:47:05,640 --> 00:47:12,810
might be a little more helpful so feel

00:47:08,070 --> 00:47:16,160
free to return tomorrow thank you

00:47:12,810 --> 00:47:16,160

YouTube URL: https://www.youtube.com/watch?v=VYBLCvMu_pA


