Title: Graham Ollis (‎plicease‎) - Foreign Function Interface (FFI): Never Need to Write XS Again
Publication date: 2014-06-23
Playlist: YAPC::NA 2014
Description: 
	Foreign Function Interface (FFI) is a popular method of implementing extensions that rely on C libraries in languages such as Ruby, Python and Java. FFI has not hit the big time in Perl, but it has some advantages over Perl's historical extension language XS. Migrating parts of CPAN from XS to FFI may ease the transition to alternative Perl implementations or Perl 6. In this talk I will compare and contrast the two techniques in the context of Perl today, using as an example the work that I did implementing FFI bindings for libarchive with FFI::Raw (Archive::Libarchive::FFI). I will focus on work I did creating and using infrastructure that should be applicable to many FFI projects. I will also discuss the development of the Alien::Libarchive module to make available libarchive to the FFI bindings that I wrote. I will make suggestions as to how Alien infrastructure could be improved to better work with FFI projects.
Captions: 
	00:00:00,000 --> 00:00:05,040
hi there I'm I'm going to talk to you

00:00:02,460 --> 00:00:07,859
today about pearl and FF I and my

00:00:05,040 --> 00:00:12,269
adventures in this in this interesting

00:00:07,859 --> 00:00:13,950
world that I've discovered most of you

00:00:12,269 --> 00:00:15,540
probably don't know who I am I'm my name

00:00:13,950 --> 00:00:18,300
is Graham Alice I've been a pro

00:00:15,540 --> 00:00:20,730
programmer for about 20 years but most

00:00:18,300 --> 00:00:25,170
of the time has been spent on dark pan

00:00:20,730 --> 00:00:27,480
projects and two years ago I I i joined

00:00:25,170 --> 00:00:30,619
DC p.m. and I started putting some stuff

00:00:27,480 --> 00:00:36,780
on on Sipan so I've been more

00:00:30,619 --> 00:00:39,000
contributory and I work for adding it on

00:00:36,780 --> 00:00:42,239
a NASA contract to provide computing

00:00:39,000 --> 00:00:44,309
resources to earth scientists and in the

00:00:42,239 --> 00:00:47,730
team inside my company we work almost

00:00:44,309 --> 00:00:50,460
exclusively on pearl we have our own

00:00:47,730 --> 00:00:54,809
government mandated acronyms the sips

00:00:50,460 --> 00:00:57,329
and the ACPs it's a small team and they

00:00:54,809 --> 00:00:59,460
see the value in pearl and Yap see so

00:00:57,329 --> 00:01:02,969
they kindly sent me here to talk to you

00:00:59,460 --> 00:01:04,350
today in my spare time I enjoy

00:01:02,969 --> 00:01:06,750
connecting things that don't really

00:01:04,350 --> 00:01:10,200
normally go together and i happen to be

00:01:06,750 --> 00:01:12,720
Australian so my favorite animal is of

00:01:10,200 --> 00:01:15,420
course the platypus since it is an

00:01:12,720 --> 00:01:18,270
aquatic mammal that has a duckbill it

00:01:15,420 --> 00:01:21,540
lays eggs and as I've been reminded

00:01:18,270 --> 00:01:27,180
recently is poisonous as apparently all

00:01:21,540 --> 00:01:28,530
Australian animals and I and I love

00:01:27,180 --> 00:01:31,020
pearl actually more or less for the same

00:01:28,530 --> 00:01:33,329
reasons it's kind of a it's an odd and I

00:01:31,020 --> 00:01:41,350
model this

00:01:33,329 --> 00:01:45,729
sorry it could be could be so fi what's

00:01:41,350 --> 00:01:56,140
that as it I have a mic I don't know if

00:01:45,729 --> 00:01:57,880
it's is the mic is the mic not on I i'll

00:01:56,140 --> 00:02:02,350
just have to talk loudly can everybody

00:01:57,880 --> 00:02:04,509
hear what I'm saying ok so so what's FF

00:02:02,350 --> 00:02:05,920
I as it turns out it's a great way to

00:02:04,509 --> 00:02:09,720
connect things that don't normally go

00:02:05,920 --> 00:02:11,830
together according to the lib ffi

00:02:09,720 --> 00:02:14,739
project it's a foreign function

00:02:11,830 --> 00:02:16,480
interface is the popular name for the

00:02:14,739 --> 00:02:18,190
interface that allows code written in

00:02:16,480 --> 00:02:20,980
one language to call code written in

00:02:18,190 --> 00:02:22,599
another language and the image that of

00:02:20,980 --> 00:02:25,440
course you're supposed to come to mind

00:02:22,599 --> 00:02:30,160
is putting a duckbill onto an adorable

00:02:25,440 --> 00:02:32,140
aquatic mammal in practice ffi and i'm

00:02:30,160 --> 00:02:34,170
going to use this terminology usually

00:02:32,140 --> 00:02:38,620
refers to specifically the bindings of

00:02:34,170 --> 00:02:42,180
to lib ffi from a scripting or virtual

00:02:38,620 --> 00:02:45,180
machine platform like Python Ruby Java

00:02:42,180 --> 00:02:49,630
and now you can do it from pearl as well

00:02:45,180 --> 00:02:52,000
in Perl 5 we already have an FFI and

00:02:49,630 --> 00:02:53,680
that's called excess the way it works is

00:02:52,000 --> 00:02:55,690
that you start with some excess code

00:02:53,680 --> 00:02:58,359
which is sort of it's kind of a

00:02:55,690 --> 00:03:02,470
Frankenstein's monster of sea and the c

00:02:58,359 --> 00:03:05,500
preprocessor and the guts of pearl which

00:03:02,470 --> 00:03:09,400
they call an api and this gets compiled

00:03:05,500 --> 00:03:12,459
using X sub P P into plain c code which

00:03:09,400 --> 00:03:15,040
then gets compiled and linked with other

00:03:12,459 --> 00:03:17,319
C files optionally and libraries into a

00:03:15,040 --> 00:03:20,519
dynamic library which can then be called

00:03:17,319 --> 00:03:22,540
from perl using the Dinah loader so

00:03:20,519 --> 00:03:26,950
hopefully you're at least somewhat

00:03:22,540 --> 00:03:29,739
similar with that access is primarily

00:03:26,950 --> 00:03:32,079
useful for three things I think when I

00:03:29,739 --> 00:03:33,940
was thinking about this firstly it's

00:03:32,079 --> 00:03:35,950
useful for creating bindings to existing

00:03:33,940 --> 00:03:40,629
libraries usually written in either C or

00:03:35,950 --> 00:03:43,730
C++ or optimizing parts of your program

00:03:40,629 --> 00:03:45,950
that need to be especially fast or small

00:03:43,730 --> 00:03:48,500
and it's also useful for extending the

00:03:45,950 --> 00:03:52,519
pearl language itself so you can add use

00:03:48,500 --> 00:03:54,379
it to add keywords and the elephant in

00:03:52,519 --> 00:03:56,150
the room is of course that excess is

00:03:54,379 --> 00:03:58,700
really necessary for most of what's on

00:03:56,150 --> 00:04:00,590
tpad because most of what's on Sipan

00:03:58,700 --> 00:04:04,940
depends either directly earning director

00:04:00,590 --> 00:04:08,000
Leon excess modules and it has a number

00:04:04,940 --> 00:04:09,799
of limitations is tied sort of

00:04:08,000 --> 00:04:14,060
inexorably to the current implementation

00:04:09,799 --> 00:04:17,810
of Perl 5 I don't think it's especially

00:04:14,060 --> 00:04:19,970
easy or intuitive to to learn there is

00:04:17,810 --> 00:04:22,039
take a look at the man pages I mean I

00:04:19,970 --> 00:04:25,789
think they've done a valiant effort but

00:04:22,039 --> 00:04:27,590
it is a tricky subject it has its own

00:04:25,789 --> 00:04:31,430
sort of repertoire of what I think is

00:04:27,590 --> 00:04:34,190
not especially pearl ish terminology so

00:04:31,430 --> 00:04:37,970
even coming from a strong pro background

00:04:34,190 --> 00:04:43,100
it is challenging to to understand and

00:04:37,970 --> 00:04:45,169
learn it also as I said uses the c

00:04:43,100 --> 00:04:49,669
preprocessor a lot which has a lot of

00:04:45,169 --> 00:04:54,610
caveats associated with it there is it

00:04:49,669 --> 00:04:58,820
is kind of an API only sort of its

00:04:54,610 --> 00:05:05,150
documentation is a little bit spotty in

00:04:58,820 --> 00:05:06,979
places and I think importantly the

00:05:05,150 --> 00:05:09,800
interfaces the innards change from time

00:05:06,979 --> 00:05:14,240
to time and you know for good reasons we

00:05:09,800 --> 00:05:16,880
want to improve the pearl core but that

00:05:14,240 --> 00:05:19,820
is can be painful for excess authors at

00:05:16,880 --> 00:05:24,889
the same time so FF I on the other hand

00:05:19,820 --> 00:05:27,680
has a number of advantages first of all

00:05:24,889 --> 00:05:30,800
no c compiler is required once the FI

00:05:27,680 --> 00:05:32,270
extension is installed i personally

00:05:30,800 --> 00:05:34,849
think it's a little bit easier to

00:05:32,270 --> 00:05:39,380
develop for and i'll just be showing

00:05:34,849 --> 00:05:41,419
some examples of that I think

00:05:39,380 --> 00:05:44,139
demonstrate that you don't need to know

00:05:41,419 --> 00:05:47,419
anything about excess or the pearl guts

00:05:44,139 --> 00:05:50,419
and so you're also it's also more

00:05:47,419 --> 00:05:52,460
resistant to changes changes in the in

00:05:50,419 --> 00:05:56,210
the port and the guts of pearl don't

00:05:52,460 --> 00:05:59,270
affect ffi extensions directly

00:05:56,210 --> 00:06:00,650
I think I'll show talked about this a

00:05:59,270 --> 00:06:04,789
little bit later but it's potentially

00:06:00,650 --> 00:06:07,610
much more portable the build process for

00:06:04,789 --> 00:06:10,669
a simple ffi module that just provides

00:06:07,610 --> 00:06:12,680
providing just just provides bindings to

00:06:10,669 --> 00:06:14,870
an existing system library is much

00:06:12,680 --> 00:06:16,819
simpler because you don't have to do

00:06:14,870 --> 00:06:19,910
anything special in the install step

00:06:16,819 --> 00:06:22,940
right you can just grab the dynamic

00:06:19,910 --> 00:06:28,789
library and call to it directly using in

00:06:22,940 --> 00:06:31,940
this case ffi raw so I'm going to be

00:06:28,789 --> 00:06:34,610
focusing on to fi distributions that I

00:06:31,940 --> 00:06:37,639
used but I did not write myself one of

00:06:34,610 --> 00:06:40,880
them is FF I raw and the other is FF I

00:06:37,639 --> 00:06:44,479
sweet there's also another module

00:06:40,880 --> 00:06:47,960
another mature ffion Sipan called win32

00:06:44,479 --> 00:06:50,990
API and I don't personally use it

00:06:47,960 --> 00:06:53,330
because I have stuff that needs to work

00:06:50,990 --> 00:06:55,460
everywhere not just on Windows but it

00:06:53,330 --> 00:06:57,979
does have some advantages over ffi raw

00:06:55,460 --> 00:07:00,380
and sweet and I think especially in

00:06:57,979 --> 00:07:03,470
terms of its windows specific features

00:07:00,380 --> 00:07:07,460
so if you are working in that area it's

00:07:03,470 --> 00:07:10,370
definitely you want to check it out this

00:07:07,460 --> 00:07:12,979
is what f if I rot oh there's a typo

00:07:10,370 --> 00:07:15,650
there that should be used fi raw sorry

00:07:12,979 --> 00:07:18,740
this is basically what ffi raw looks

00:07:15,650 --> 00:07:20,479
like as you can see you define a

00:07:18,740 --> 00:07:22,909
function by giving the name of the

00:07:20,479 --> 00:07:28,099
library and the name of the function and

00:07:22,909 --> 00:07:33,530
its return returnvalue and argument

00:07:28,099 --> 00:07:36,710
types and in this case I'm using the

00:07:33,530 --> 00:07:39,530
standard C library on linux and i'm

00:07:36,710 --> 00:07:42,949
grabbing the put s function which allows

00:07:39,530 --> 00:07:46,639
me to print stuff to standard output so

00:07:42,949 --> 00:07:49,099
a lot simpler i think then the what the

00:07:46,639 --> 00:07:50,509
equivalent accessible this is right in

00:07:49,099 --> 00:07:54,469
your perl code you wouldn't don't even

00:07:50,509 --> 00:07:56,539
need a separate file to implement it the

00:07:54,469 --> 00:07:58,310
other ffi raw accepted a patch from me

00:07:56,539 --> 00:08:00,110
which allows you to use undef as the

00:07:58,310 --> 00:08:03,169
library name in order to search the

00:08:00,110 --> 00:08:05,150
current process for symbols so and this

00:08:03,169 --> 00:08:06,620
is handy because Lib C is called

00:08:05,150 --> 00:08:07,760
something on just about every platform

00:08:06,620 --> 00:08:10,520
even

00:08:07,760 --> 00:08:15,860
unix it's not called the same thing so

00:08:10,520 --> 00:08:19,760
now so that's that was cool dollar put s

00:08:15,860 --> 00:08:22,130
here is an FFI raw object but it can

00:08:19,760 --> 00:08:25,760
also be used like a code reference

00:08:22,130 --> 00:08:27,710
thanks to overloading it's still an

00:08:25,760 --> 00:08:29,980
object so there are some places where

00:08:27,710 --> 00:08:32,479
you can't use it as a code reference

00:08:29,980 --> 00:08:36,800
depending on how it's used so you just

00:08:32,479 --> 00:08:38,060
be aware and use with caution of the FFI

00:08:36,800 --> 00:08:41,690
interfaces that I'm going to show you

00:08:38,060 --> 00:08:44,060
today this is the most mature and it can

00:08:41,690 --> 00:08:46,280
be used to write Sipan modules today

00:08:44,060 --> 00:08:49,990
because it works and on most on almost

00:08:46,280 --> 00:08:49,990
all the platforms that you'd want it to

00:08:50,530 --> 00:08:58,520
sorry the int the return value so yeah I

00:08:55,400 --> 00:09:00,050
guess to be explicit so the first

00:08:58,520 --> 00:09:03,260
argument is the library the second

00:09:00,050 --> 00:09:07,370
argument is the name the third argument

00:09:03,260 --> 00:09:09,740
is the return type and then all the rest

00:09:07,370 --> 00:09:12,290
are the argument types so in this case I

00:09:09,740 --> 00:09:15,670
just have one but you could have as many

00:09:12,290 --> 00:09:21,140
as you want it are there any other

00:09:15,670 --> 00:09:24,740
computing things so ffi suite is a ruby

00:09:21,140 --> 00:09:27,290
ffi inspired interface that is built

00:09:24,740 --> 00:09:29,870
over ffi raw and this it has the same

00:09:27,290 --> 00:09:32,750
capabilities but instead of working with

00:09:29,870 --> 00:09:34,670
an object you get a real code reference

00:09:32,750 --> 00:09:37,330
installed into your package for you so

00:09:34,670 --> 00:09:41,030
it's it looks a little bit more like a

00:09:37,330 --> 00:09:43,640
regular pearl interface it's not on

00:09:41,030 --> 00:09:46,750
Sipan at the moment but i'm hoping we

00:09:43,640 --> 00:09:46,750
can get there soon

00:09:49,800 --> 00:09:55,019
they're other a couple other F if I

00:09:51,920 --> 00:09:58,950
excuse me foi projects out there to be

00:09:55,019 --> 00:10:00,810
aware of or maybe be aware of one is C

00:09:58,950 --> 00:10:02,790
types which I think it showed some

00:10:00,810 --> 00:10:05,970
promise at some point but I don't think

00:10:02,790 --> 00:10:07,589
it's being actively developed and it's

00:10:05,970 --> 00:10:11,760
certainly not on C pants so it's not

00:10:07,589 --> 00:10:17,370
useful today to write modules on Sipan

00:10:11,760 --> 00:10:22,320
like FF I raw is not see Pat so f fi no

00:10:17,370 --> 00:10:25,709
suffix uses ffff call instead of lib ffi

00:10:22,320 --> 00:10:29,640
it's not maintained and neither is FF I

00:10:25,709 --> 00:10:35,310
call and also it's GPL so it may not be

00:10:29,640 --> 00:10:37,230
a license that you're looking for so I

00:10:35,310 --> 00:10:39,540
wanted to write something real using FF

00:10:37,230 --> 00:10:42,510
I raw and pearl to see if i could find

00:10:39,540 --> 00:10:44,130
holes in the implementation and to come

00:10:42,510 --> 00:10:46,649
up with ideas that might improve it I

00:10:44,130 --> 00:10:48,990
picked lib archive which turned out to

00:10:46,649 --> 00:10:50,490
be a pretty good library to target as it

00:10:48,990 --> 00:10:54,380
turned out for a lot of reasons most of

00:10:50,490 --> 00:10:56,850
which I wasn't aware of going in

00:10:54,380 --> 00:10:59,279
basically though it's similar it's the

00:10:56,850 --> 00:11:01,709
tar implementation for freebsd and it

00:10:59,279 --> 00:11:05,640
has like a number of pretty cool

00:11:01,709 --> 00:11:08,160
features it will detect read and write

00:11:05,640 --> 00:11:10,350
most popular formats automatically and

00:11:08,160 --> 00:11:12,810
it handles all kinds of compression it's

00:11:10,350 --> 00:11:15,089
a pretty neat library what's interesting

00:11:12,810 --> 00:11:18,329
in the context of FF I of course is that

00:11:15,089 --> 00:11:21,420
it's implemented in C so we can use FF I

00:11:18,329 --> 00:11:23,399
or excess to write bindings for it it's

00:11:21,420 --> 00:11:26,100
also object oriented so it sort of lends

00:11:23,399 --> 00:11:30,360
itself well to a scripting language like

00:11:26,100 --> 00:11:32,339
pearl here's a short program to give you

00:11:30,360 --> 00:11:35,550
an idea of what I mean this program

00:11:32,339 --> 00:11:37,260
opens an archive of any formats that

00:11:35,550 --> 00:11:43,199
supported by lib archive and it prints

00:11:37,260 --> 00:11:45,420
the members to standard output and its

00:11:43,199 --> 00:11:48,089
object oriented in the sense that it

00:11:45,420 --> 00:11:50,279
makes the use of opaque pointers the

00:11:48,089 --> 00:11:52,920
Constructors RC functions that return

00:11:50,279 --> 00:11:54,750
the opaque pointer and then you can pass

00:11:52,920 --> 00:11:57,209
that pointer back in as the first

00:11:54,750 --> 00:12:00,560
argument to functions which are in fact

00:11:57,209 --> 00:12:00,560
basically method calls

00:12:02,790 --> 00:12:10,020
that makes sense so I wrote archive lib

00:12:07,600 --> 00:12:13,000
archive ffi this is my pearl

00:12:10,020 --> 00:12:15,550
distribution on Sipan to be

00:12:13,000 --> 00:12:18,490
comprehensive so that it shows that ffi

00:12:15,550 --> 00:12:22,360
raw can be used to implement a large API

00:12:18,490 --> 00:12:23,580
and Lib archive has I can't remember

00:12:22,360 --> 00:12:28,360
lace like three or four hundred

00:12:23,580 --> 00:12:29,890
functions so it's a lot and I only sort

00:12:28,360 --> 00:12:32,730
of punch it on the last like four or

00:12:29,890 --> 00:12:35,110
five and I decided they were either not

00:12:32,730 --> 00:12:38,529
really didn't make sense in pearl or

00:12:35,110 --> 00:12:42,100
we're just too much work so it was it's

00:12:38,529 --> 00:12:47,320
fairly comprehensive it's built using FF

00:12:42,100 --> 00:12:50,200
I raw and FF I sweet lib archive and my

00:12:47,320 --> 00:12:52,660
bindings provide a customized IO

00:12:50,200 --> 00:12:57,040
interface you can give it functions to

00:12:52,660 --> 00:12:59,700
perform the actual I oh so say you want

00:12:57,040 --> 00:13:02,350
to write directly to a network or a

00:12:59,700 --> 00:13:03,820
database instead of a file you can do

00:13:02,350 --> 00:13:06,280
that using this interface and this was

00:13:03,820 --> 00:13:08,680
useful because it exercised the part of

00:13:06,280 --> 00:13:11,620
FF I raw that allows you to create a

00:13:08,680 --> 00:13:17,920
closure and call back into Perl code

00:13:11,620 --> 00:13:20,820
from see my bindings also provide the

00:13:17,920 --> 00:13:23,530
all the latest functions in lib archive

00:13:20,820 --> 00:13:26,430
so then each version seems to provide

00:13:23,530 --> 00:13:28,420
new features and at the same time as

00:13:26,430 --> 00:13:30,220
supporting fewer features if you're

00:13:28,420 --> 00:13:33,430
using an older version of lib barca your

00:13:30,220 --> 00:13:36,010
system comes with an older version the

00:13:33,430 --> 00:13:38,290
vast majority of the functions provided

00:13:36,010 --> 00:13:42,100
by archive lib archive fo fire defined

00:13:38,290 --> 00:13:44,560
in this way and simple declarations to

00:13:42,100 --> 00:13:47,980
attach the functions so these creates

00:13:44,560 --> 00:13:50,350
the sub graphs that you can basically

00:13:47,980 --> 00:13:53,800
just subroutines in the archive lib

00:13:50,350 --> 00:13:57,760
archive fi namespace and here i'm using

00:13:53,800 --> 00:13:59,320
a wrapper around attached function

00:13:57,760 --> 00:14:02,320
called underscore attached function

00:13:59,320 --> 00:14:04,180
because ffi sweet usually throws an

00:14:02,320 --> 00:14:06,459
exception if the symbol isn't found and

00:14:04,180 --> 00:14:08,740
as I said I didn't want I wanted to

00:14:06,459 --> 00:14:13,230
support everything was there but not die

00:14:08,740 --> 00:14:13,230
if there's stuff missing

00:14:18,490 --> 00:14:25,700
so a number of lib archive functions

00:14:22,430 --> 00:14:28,730
take buffers as arguments so either as

00:14:25,700 --> 00:14:32,300
input or output buffer is just a pointer

00:14:28,730 --> 00:14:35,000
to a region of memory and a size for

00:14:32,300 --> 00:14:37,490
that region the sea version of this

00:14:35,000 --> 00:14:39,320
function archive read data for example

00:14:37,490 --> 00:14:40,880
takes an archive object as its first

00:14:39,320 --> 00:14:43,640
argument followed by a pointer and a

00:14:40,880 --> 00:14:46,100
size pair which defines the buffer I

00:14:43,640 --> 00:14:47,510
wrote the Pearl version instead to take

00:14:46,100 --> 00:14:50,899
an archive object as the first argument

00:14:47,510 --> 00:14:52,940
and a scalar where the data was to be

00:14:50,899 --> 00:14:54,950
written to as the second argument so

00:14:52,940 --> 00:14:58,370
it's it's the obvious thing that makes

00:14:54,950 --> 00:15:00,529
sense you know in Perl land I thought I

00:14:58,370 --> 00:15:04,820
suite provides this wrapper interface so

00:15:00,529 --> 00:15:08,690
that so the first argument is the code

00:15:04,820 --> 00:15:10,910
reference to the real c function and and

00:15:08,690 --> 00:15:15,019
this function gets called you know in

00:15:10,910 --> 00:15:21,470
between so that it looks normal looks

00:15:15,019 --> 00:15:24,410
like a regular pearl function so here

00:15:21,470 --> 00:15:27,410
i'm creating a call back so this is i'm

00:15:24,410 --> 00:15:31,790
using FF I so this is this allows you to

00:15:27,410 --> 00:15:34,730
call call back into pearl space from the

00:15:31,790 --> 00:15:36,410
C code and I'm using FF I raw in this

00:15:34,730 --> 00:15:40,430
case because sweet doesn't provide the

00:15:36,410 --> 00:15:44,890
interface yet this uses again a similar

00:15:40,430 --> 00:15:49,839
sort of wrapper pattern where instead of

00:15:44,890 --> 00:15:49,839
it translates a see buffer into a scalar

00:15:50,350 --> 00:15:54,199
and this is the function that allows you

00:15:52,730 --> 00:15:56,500
to install that callback and again it

00:15:54,199 --> 00:15:58,640
uses the regular attached function

00:15:56,500 --> 00:16:04,880
method and a wrapper around it in order

00:15:58,640 --> 00:16:06,890
to sort of get everything to work so to

00:16:04,880 --> 00:16:08,930
go back to the original lib archive

00:16:06,890 --> 00:16:10,610
example that I showed you here's the

00:16:08,930 --> 00:16:13,269
Pearl version and it should look it

00:16:10,610 --> 00:16:17,390
looks almost this it looks very similar

00:16:13,269 --> 00:16:19,740
and it does kind of the same thing

00:16:17,390 --> 00:16:23,120
exactly

00:16:19,740 --> 00:16:27,270
and here is a slightly different one

00:16:23,120 --> 00:16:28,950
that uses the callback interface so in

00:16:27,270 --> 00:16:31,080
this case I'm just I am still just

00:16:28,950 --> 00:16:33,150
reading from a file but you could stick

00:16:31,080 --> 00:16:34,800
whatever you want it in there it could

00:16:33,150 --> 00:16:36,690
be you know you could write you could

00:16:34,800 --> 00:16:43,710
read from a database or from the network

00:16:36,690 --> 00:16:46,110
or anything you could come up with so

00:16:43,710 --> 00:16:47,520
integers are mostly interviews and

00:16:46,110 --> 00:16:49,350
pointers mostly what I showed you so far

00:16:47,520 --> 00:16:52,230
and they're pretty simple but what about

00:16:49,350 --> 00:16:54,900
structures lib archive uses mostly

00:16:52,230 --> 00:16:56,430
opaque pointers as I mentioned in a

00:16:54,900 --> 00:16:58,020
couple places though it does reuse

00:16:56,430 --> 00:17:00,240
system structures in order to

00:16:58,020 --> 00:17:03,330
communicate with the calling library and

00:17:00,240 --> 00:17:06,090
calling code like this archive entry

00:17:03,330 --> 00:17:07,650
stat function it works just like the

00:17:06,090 --> 00:17:09,180
system stat except for instead of

00:17:07,650 --> 00:17:11,010
returning statistics on a file in the

00:17:09,180 --> 00:17:15,060
file system it returns statistics on a

00:17:11,010 --> 00:17:17,240
file in archive member so you might be

00:17:15,060 --> 00:17:24,420
wondering like how I implemented that

00:17:17,240 --> 00:17:31,350
anybody got any ideas no sorry so no I

00:17:24,420 --> 00:17:34,350
cheated sorry I know I cheated yeah

00:17:31,350 --> 00:17:35,970
exactly so I cheated I so live archive

00:17:34,350 --> 00:17:38,040
provides you an interface to all those

00:17:35,970 --> 00:17:41,070
statistics members separately so i

00:17:38,040 --> 00:17:44,870
called them one at a time i grew up as

00:17:41,070 --> 00:17:48,570
list and i send them back so now i have

00:17:44,870 --> 00:17:53,130
you know it involves more calls in to

00:17:48,570 --> 00:17:54,780
see but i have a archive entry stat

00:17:53,130 --> 00:17:57,330
function that works just like the

00:17:54,780 --> 00:17:59,340
built-in pearl stat except for instead

00:17:57,330 --> 00:18:02,400
of operating on a file in the file

00:17:59,340 --> 00:18:05,730
system it returns the statistics of a

00:18:02,400 --> 00:18:08,520
member of the archive but you can

00:18:05,730 --> 00:18:10,920
interface with structs using FF I and

00:18:08,520 --> 00:18:13,710
here's some example C code that comes

00:18:10,920 --> 00:18:16,650
with F of I raw we have a struct with an

00:18:13,710 --> 00:18:20,120
integer and a string and a function that

00:18:16,650 --> 00:18:23,310
prints the string if the integer is 42

00:18:20,120 --> 00:18:26,700
it's not the most brilliant algorithm

00:18:23,310 --> 00:18:28,800
but it'll show the example you can use

00:18:26,700 --> 00:18:31,440
the built pearl built-in pack function

00:18:28,800 --> 00:18:32,400
to create a pointer object that can then

00:18:31,440 --> 00:18:35,810
be passed into

00:18:32,400 --> 00:18:38,190
any ffi function that takes a pointer

00:18:35,810 --> 00:18:41,490
I'm not especially crazy about this

00:18:38,190 --> 00:18:44,040
interface first of all you have to

00:18:41,490 --> 00:18:46,140
create you know another scalar in order

00:18:44,040 --> 00:18:51,840
to just pass it in and and another thing

00:18:46,140 --> 00:18:54,810
is that pack and unpack are complicated

00:18:51,840 --> 00:18:57,180
beasts which are can be very useful that

00:18:54,810 --> 00:19:01,190
they're also like I say they can be

00:18:57,180 --> 00:19:01,190
difficult error prone for the unawares

00:19:01,400 --> 00:19:11,930
this is kind of what they do in Ruby

00:19:03,990 --> 00:19:15,240
land you define a class that define that

00:19:11,930 --> 00:19:19,590
derives from FF I struct then you give

00:19:15,240 --> 00:19:21,720
it a layout and then you can use it just

00:19:19,590 --> 00:19:23,370
like a regular Ruby object you can

00:19:21,720 --> 00:19:26,070
assign values to it you can get values

00:19:23,370 --> 00:19:30,480
from it but when you pass it into an FFI

00:19:26,070 --> 00:19:32,070
function it will understand what to do

00:19:30,480 --> 00:19:36,240
you treat it as a pointer and pass it to

00:19:32,070 --> 00:19:38,130
the c code if you used in line struct

00:19:36,240 --> 00:19:40,620
before you might see some similarities

00:19:38,130 --> 00:19:41,940
and i actually been meaning to check

00:19:40,620 --> 00:19:43,170
this out but i think it'd be an

00:19:41,940 --> 00:19:46,650
interesting experiment to get in line

00:19:43,170 --> 00:19:49,320
struck to work with ffi raw so an

00:19:46,650 --> 00:19:51,870
exercise for the those that are

00:19:49,320 --> 00:19:55,080
interested back to our particular

00:19:51,870 --> 00:19:57,960
example though one thing I wanted to

00:19:55,080 --> 00:20:00,720
mention this is the direction that we're

00:19:57,960 --> 00:20:03,360
thinking about going with FF I sweet but

00:20:00,720 --> 00:20:07,590
it's just an idea not an actual

00:20:03,360 --> 00:20:09,630
implementation yet a particular problem

00:20:07,590 --> 00:20:11,310
though the stat structure is not that

00:20:09,630 --> 00:20:14,700
easy to implement using either of these

00:20:11,310 --> 00:20:18,830
two methods have you ever seen the Linux

00:20:14,700 --> 00:20:22,260
version of stat it's a little bit crazy

00:20:18,830 --> 00:20:24,480
this is just one implementation and now

00:20:22,260 --> 00:20:32,730
imagine you have to support bsd solaris

00:20:24,480 --> 00:20:35,370
hp-ux or what have you yeah it's not fun

00:20:32,730 --> 00:20:39,080
this is the reason why i punted if

00:20:35,370 --> 00:20:41,760
you're wondering I decided that I didn't

00:20:39,080 --> 00:20:44,549
one possible solution that I came up

00:20:41,760 --> 00:20:50,700
with is to define to create your own

00:20:44,549 --> 00:20:52,830
interface to see structure from C and

00:20:50,700 --> 00:20:56,760
then call the interface from Pearl using

00:20:52,830 --> 00:20:59,220
FF I for example here's a partial

00:20:56,760 --> 00:21:01,710
implementation of stat using an opaque

00:20:59,220 --> 00:21:05,280
pointer object system so much of what

00:21:01,710 --> 00:21:07,919
lib archive uses for its objects so this

00:21:05,280 --> 00:21:15,690
was kind of inspired by what I'd already

00:21:07,919 --> 00:21:18,690
the how I'd been using lib archive and

00:21:15,690 --> 00:21:22,169
this is the FFI sweet bindings for that

00:21:18,690 --> 00:21:27,600
interface and it it looks very similar

00:21:22,169 --> 00:21:36,270
to it should look very similar to what I

00:21:27,600 --> 00:21:40,200
was doing with live archive and this is

00:21:36,270 --> 00:21:42,600
just an example of how I use to test it

00:21:40,200 --> 00:21:45,900
and so you can see how it's used so it

00:21:42,600 --> 00:21:47,970
works it looks just like a regular pearl

00:21:45,900 --> 00:21:50,280
class you can instantiate it you can get

00:21:47,970 --> 00:21:52,740
access members you know but it's really

00:21:50,280 --> 00:21:57,679
kind of see it's really a the stat

00:21:52,740 --> 00:22:00,419
structure underneath the hood and the

00:21:57,679 --> 00:22:02,730
advantage here is that at no point did I

00:22:00,419 --> 00:22:06,600
have to specify the layout of the stat

00:22:02,730 --> 00:22:09,240
structure because the c compiler handled

00:22:06,600 --> 00:22:13,470
it for me kind of at the cost of some

00:22:09,240 --> 00:22:16,850
complexity during the install step so in

00:22:13,470 --> 00:22:19,530
order to do this i wrote a module called

00:22:16,850 --> 00:22:23,490
module built ffi to make this thing a

00:22:19,530 --> 00:22:26,640
little bit easier basically you can

00:22:23,490 --> 00:22:31,620
throw some c code into a folder called

00:22:26,640 --> 00:22:33,750
ffi inside your distribution and it will

00:22:31,620 --> 00:22:37,919
build it and make it available for you

00:22:33,750 --> 00:22:42,299
so that you can call it from your perl

00:22:37,919 --> 00:22:44,669
code using FF I raw and although i'm

00:22:42,299 --> 00:22:47,110
using this example for creating

00:22:44,669 --> 00:22:49,990
interface to see structure

00:22:47,110 --> 00:22:53,280
you could do the same thing to create to

00:22:49,990 --> 00:22:56,799
write code right parts of your program

00:22:53,280 --> 00:22:59,440
that need to be fast or small or

00:22:56,799 --> 00:23:00,850
whatever and you may remember from the

00:22:59,440 --> 00:23:04,179
beginning this is one of the things that

00:23:00,850 --> 00:23:06,100
I said was useful about excess this

00:23:04,179 --> 00:23:09,910
isn't just another tool in your tool

00:23:06,100 --> 00:23:13,390
belt now you can use so this is the same

00:23:09,910 --> 00:23:15,640
diagram that I showed you earlier for

00:23:13,390 --> 00:23:17,740
excess and how it compares and I just

00:23:15,640 --> 00:23:22,500
wanted to compare it to the equivalent

00:23:17,740 --> 00:23:25,919
module built ffi sort of interface so

00:23:22,500 --> 00:23:31,030
the Installer compiles the C code

00:23:25,919 --> 00:23:35,140
directly into a dll or s 0 a dynamic

00:23:31,030 --> 00:23:37,870
library and now you can call it from

00:23:35,140 --> 00:23:40,740
your pro code using FF I raw instead of

00:23:37,870 --> 00:23:40,740
using the Dino loader

00:23:48,940 --> 00:23:53,290
so the second thing that I want to sort

00:23:51,190 --> 00:23:56,320
of talk about was how you get how you

00:23:53,290 --> 00:23:59,140
get these libraries I kind of feel as

00:23:56,320 --> 00:24:00,730
you ought to be able to use something

00:23:59,140 --> 00:24:04,990
like this library that I've written

00:24:00,730 --> 00:24:06,930
archive lib archive ffi without in but

00:24:04,990 --> 00:24:09,190
by simply just installing it from Sipan

00:24:06,930 --> 00:24:11,710
without having to read the documentation

00:24:09,190 --> 00:24:13,030
really closely to find out all the

00:24:11,710 --> 00:24:15,370
different libraries that you need to

00:24:13,030 --> 00:24:17,320
install or maybe you have to download

00:24:15,370 --> 00:24:20,110
the source code to something and put it

00:24:17,320 --> 00:24:21,550
into adjacent folder or maybe there's an

00:24:20,110 --> 00:24:24,280
environment variable you need to set

00:24:21,550 --> 00:24:25,780
somewhere or something like that I think

00:24:24,280 --> 00:24:28,990
this should stuff should just like kind

00:24:25,780 --> 00:24:31,210
of work out of Sipan otherwise you know

00:24:28,990 --> 00:24:33,550
your library is not going to be used as

00:24:31,210 --> 00:24:35,440
a prerequisite for anything because

00:24:33,550 --> 00:24:37,300
people are going to be worried about all

00:24:35,440 --> 00:24:40,770
the hoops that you're their users have

00:24:37,300 --> 00:24:45,820
to jump through so this sounds like a

00:24:40,770 --> 00:24:47,760
job for an alien module right so alien

00:24:45,820 --> 00:24:50,200
is this thing it was invented back in

00:24:47,760 --> 00:24:54,460
2003 I guess so it's not a new concept

00:24:50,200 --> 00:24:57,370
or idea by Archer Bergman and it

00:24:54,460 --> 00:25:00,540
basically a documentation only dot p.m.

00:24:57,370 --> 00:25:03,040
file so a sort of statement to the world

00:25:00,540 --> 00:25:05,200
which says that the alien namespace

00:25:03,040 --> 00:25:07,330
should be used to define Sipan

00:25:05,200 --> 00:25:12,190
prerequisites for things that are not

00:25:07,330 --> 00:25:14,130
native to see pan so like see libraries

00:25:12,190 --> 00:25:18,460
like things like lib archive basically

00:25:14,130 --> 00:25:23,950
the idea being that you install alien

00:25:18,460 --> 00:25:27,610
foo and then as part of its installation

00:25:23,950 --> 00:25:30,160
it either finds the system library the

00:25:27,610 --> 00:25:33,760
system lib foo for you if it happens to

00:25:30,160 --> 00:25:36,970
be installed or if it's not download the

00:25:33,760 --> 00:25:41,890
source code for it build it and then

00:25:36,970 --> 00:25:47,040
make it available to you no later Sipan

00:25:41,890 --> 00:25:47,040
modules like foo excess or foo ffi

00:25:47,770 --> 00:25:54,160
so the main problem with alien I think

00:25:51,400 --> 00:25:58,780
is that there wasn't any sort of

00:25:54,160 --> 00:26:01,030
framework or standard or really even any

00:25:58,780 --> 00:26:04,750
common-sense suggestions about how they

00:26:01,030 --> 00:26:08,220
should be implemented so each one kind

00:26:04,750 --> 00:26:12,430
of has its own quirks and its own style

00:26:08,220 --> 00:26:14,560
which is good we should all try

00:26:12,430 --> 00:26:20,860
different things and but then choose the

00:26:14,560 --> 00:26:22,840
ones that are good so alien base was

00:26:20,860 --> 00:26:24,910
supposed to address some of this it's

00:26:22,840 --> 00:26:27,580
kind of a generic implementation of

00:26:24,910 --> 00:26:30,700
alien that you can use as a base class

00:26:27,580 --> 00:26:33,250
for creating alien modules and my first

00:26:30,700 --> 00:26:36,640
implementation of alien lib archive

00:26:33,250 --> 00:26:39,910
which is what I use to which what alien

00:26:36,640 --> 00:26:42,910
sorry what archive lib archive FF I uses

00:26:39,910 --> 00:26:44,950
to find the lib archive library so my

00:26:42,910 --> 00:26:48,010
first implementation was built using

00:26:44,950 --> 00:26:51,210
alien base and basically the

00:26:48,010 --> 00:26:56,560
architecture is split into two parts

00:26:51,210 --> 00:26:59,380
there's a build-up PL file that uses

00:26:56,560 --> 00:27:02,530
module build sub class called alien base

00:26:59,380 --> 00:27:05,770
module build and it's really good at

00:27:02,530 --> 00:27:08,380
kind of one thing which is building or

00:27:05,770 --> 00:27:10,960
finding and built and or building new

00:27:08,380 --> 00:27:16,390
style packages that provide a package

00:27:10,960 --> 00:27:18,370
config PC file and the second part is an

00:27:16,390 --> 00:27:21,250
alien base subclass that gives the

00:27:18,370 --> 00:27:23,380
calling module or calling code the sea

00:27:21,250 --> 00:27:26,800
flags and the libs that it needs to

00:27:23,380 --> 00:27:28,690
compile and Link against and this was

00:27:26,800 --> 00:27:31,570
like a huge improvement from like what

00:27:28,690 --> 00:27:33,760
was there before but unfortunately I had

00:27:31,570 --> 00:27:35,800
had to do a lot of sub classing in order

00:27:33,760 --> 00:27:38,050
to get this to work in order to work

00:27:35,800 --> 00:27:45,610
around some of them it's calm features

00:27:38,050 --> 00:27:47,230
of alien base so in I recently rewrote

00:27:45,610 --> 00:27:51,000
it using a slightly different

00:27:47,230 --> 00:27:54,580
architecture and removing the alien base

00:27:51,000 --> 00:27:57,580
prerequisite because I also kind of feel

00:27:54,580 --> 00:27:59,800
like the some of the problems with alien

00:27:57,580 --> 00:28:01,180
base are sort of architectural so the

00:27:59,800 --> 00:28:04,510
alternative that I came up with

00:28:01,180 --> 00:28:08,160
was to extract the library sort of

00:28:04,510 --> 00:28:11,980
detection and building logic from the

00:28:08,160 --> 00:28:14,830
from the module build class so that it

00:28:11,980 --> 00:28:17,080
could be used in other contexts the

00:28:14,830 --> 00:28:18,640
other departure that I made it from the

00:28:17,080 --> 00:28:21,190
older version of alien lab archive was

00:28:18,640 --> 00:28:22,990
that I provided an explicit interface

00:28:21,190 --> 00:28:25,480
for finding the dynamic libraries so

00:28:22,990 --> 00:28:29,020
alien base was really designed to make

00:28:25,480 --> 00:28:30,730
excess modules and I sort of said well I

00:28:29,020 --> 00:28:33,250
can kind of use that for FF I but this

00:28:30,730 --> 00:28:40,120
was sort of like specifically provides

00:28:33,250 --> 00:28:41,830
that capability for me so the older

00:28:40,120 --> 00:28:43,710
version kind of does something weird

00:28:41,830 --> 00:28:46,150
with dinah loader that it uses to find

00:28:43,710 --> 00:28:47,320
libraries and that works most of the

00:28:46,150 --> 00:28:49,360
time but I discovered there were some

00:28:47,320 --> 00:28:50,860
corner cases so just having an explicit

00:28:49,360 --> 00:28:56,530
interface that does exactly this one

00:28:50,860 --> 00:28:58,030
thing for me was great so now I have

00:28:56,530 --> 00:29:00,490
this different architecture where I have

00:28:58,030 --> 00:29:07,720
two distributions I have an installer

00:29:00,490 --> 00:29:10,030
and the alien alien lib archive and

00:29:07,720 --> 00:29:12,040
there are two in addition to the FFI

00:29:10,030 --> 00:29:14,700
modules that I've written there's there

00:29:12,040 --> 00:29:18,550
are two XS modules actually that use

00:29:14,700 --> 00:29:20,860
alien lab archive one is archival of

00:29:18,550 --> 00:29:23,020
archive excess which provides more or

00:29:20,860 --> 00:29:25,420
less the same interface as archive lib

00:29:23,020 --> 00:29:29,260
archive ffi except for its users excess

00:29:25,420 --> 00:29:31,240
so might seem a little strange that I

00:29:29,260 --> 00:29:33,700
did that but to me it was kind of like a

00:29:31,240 --> 00:29:36,010
useful exercise to see where you know

00:29:33,700 --> 00:29:38,470
ffi raw was good and where excess still

00:29:36,010 --> 00:29:42,190
had some you know capability that was

00:29:38,470 --> 00:29:45,430
useful the other is archived AR lib

00:29:42,190 --> 00:29:47,650
archive which can be used to read static

00:29:45,430 --> 00:29:49,390
libraries it sort of uses a very minimal

00:29:47,650 --> 00:29:53,320
set of the capabilities that are in lib

00:29:49,390 --> 00:29:55,680
archive and it actually is used by FF I

00:29:53,320 --> 00:30:01,290
sweet to find dynamic libraries on

00:29:55,680 --> 00:30:01,290
windows so it's kind of a niche case

00:30:02,070 --> 00:30:15,159
is there anything else so so and then

00:30:11,490 --> 00:30:18,010
now archive lib archive FF I can use the

00:30:15,159 --> 00:30:19,390
Installer directly to find the system

00:30:18,010 --> 00:30:23,230
lib archive if it happens to be

00:30:19,390 --> 00:30:24,730
installed and if not at in as part of

00:30:23,230 --> 00:30:27,309
the install step it says by the way

00:30:24,730 --> 00:30:31,029
please install alien lib archive as a

00:30:27,309 --> 00:30:32,950
prerequisite and it uses that you might

00:30:31,029 --> 00:30:35,710
ask me that why would I do that why not

00:30:32,950 --> 00:30:38,440
just use limpiar the alien live archive

00:30:35,710 --> 00:30:41,409
all the time well alien lib archive

00:30:38,440 --> 00:30:44,830
requires a compiler because it actually

00:30:41,409 --> 00:30:48,270
tests the library with a compiler to

00:30:44,830 --> 00:30:51,070
make sure it works and in this way and

00:30:48,270 --> 00:30:52,809
alien lip and the installer actually

00:30:51,070 --> 00:30:55,270
knows enough to be able to test instead

00:30:52,809 --> 00:31:02,409
of using a compiler with FF I so it

00:30:55,270 --> 00:31:04,179
tests exactly what I need to know so

00:31:02,409 --> 00:31:06,549
it's so if you can get away with using

00:31:04,179 --> 00:31:10,179
the Installer it's lighter weight and

00:31:06,549 --> 00:31:12,250
it's better on the other Island like the

00:31:10,179 --> 00:31:14,380
excess modules i wrote it makes sense

00:31:12,250 --> 00:31:16,720
for them to use the alien lab archive

00:31:14,380 --> 00:31:22,419
directly because they're going to need a

00:31:16,720 --> 00:31:25,240
compiler anyway so this architecture is

00:31:22,419 --> 00:31:28,029
kind of this isn't how i'm using it but

00:31:25,240 --> 00:31:30,940
this can be handy in another couple of

00:31:28,029 --> 00:31:33,070
other ways so suppose you have a module

00:31:30,940 --> 00:31:35,380
that requires a specific version of lib

00:31:33,070 --> 00:31:39,850
archives so say you need a recent one

00:31:35,380 --> 00:31:42,520
like version 3.1 so what you can do is

00:31:39,850 --> 00:31:45,220
you can say first use alien lib archive

00:31:42,520 --> 00:31:47,610
that use the installer detect the system

00:31:45,220 --> 00:31:50,470
as see if it meets your needs and

00:31:47,610 --> 00:31:52,720
actually it also if the user has already

00:31:50,470 --> 00:31:58,419
installed alien art lib archive it'll

00:31:52,720 --> 00:32:01,720
use that as a as a backup and otherwise

00:31:58,419 --> 00:32:03,220
it will download and install it'll

00:32:01,720 --> 00:32:06,210
download and build lib archive that you

00:32:03,220 --> 00:32:06,210
can then link against

00:32:08,900 --> 00:32:13,320
so and so like I said you this you can

00:32:11,700 --> 00:32:14,580
use for a newer version or if say you

00:32:13,320 --> 00:32:18,660
need a slightly older version that will

00:32:14,580 --> 00:32:22,530
work too you can also use the detection

00:32:18,660 --> 00:32:28,500
logic to use lib archive as an optional

00:32:22,530 --> 00:32:31,050
prerequisite so say you have you have a

00:32:28,500 --> 00:32:35,340
distribution that might use lib archive

00:32:31,050 --> 00:32:37,100
but it's not necessary simply make you

00:32:35,340 --> 00:32:39,330
know the Installer a prerequisite and

00:32:37,100 --> 00:32:41,760
you can see if it's available in the

00:32:39,330 --> 00:32:44,010
system or if the user happens to have

00:32:41,760 --> 00:32:49,080
chosen to install alien lib archive it

00:32:44,010 --> 00:32:51,360
will use that but it won't ever choke if

00:32:49,080 --> 00:32:55,280
if live archive isn't isn't there or

00:32:51,360 --> 00:32:55,280
maybe isn't supported by your platform

00:32:57,440 --> 00:33:02,250
the other frustration i had with alien

00:32:59,790 --> 00:33:06,320
base is that it makes dynamic libraries

00:33:02,250 --> 00:33:06,320
from most of the packages that it builds

00:33:09,350 --> 00:33:14,910
so the your excess module actually

00:33:13,020 --> 00:33:17,010
builds a dynamic library which is then

00:33:14,910 --> 00:33:21,000
called by the dynamic dyna loader so if

00:33:17,010 --> 00:33:22,890
you're using an alien base distribution

00:33:21,000 --> 00:33:26,610
if you're using alien base basically

00:33:22,890 --> 00:33:33,120
your excess dynamic library is depending

00:33:26,610 --> 00:33:38,690
on this lib food s 0 which is lives in

00:33:33,120 --> 00:33:43,580
the the alien modules share directory

00:33:38,690 --> 00:33:43,580
this turns out to be really fragile

00:33:43,700 --> 00:33:49,500
because if you install a system library

00:33:47,250 --> 00:33:52,410
is a system version of lib foo it'll

00:33:49,500 --> 00:33:54,630
actually break alien alien foo if you

00:33:52,410 --> 00:33:58,200
upgrade alien foo after installing foo

00:33:54,630 --> 00:34:00,600
XS that can also break and really the

00:33:58,200 --> 00:34:04,830
solution is to use static libraries to

00:34:00,600 --> 00:34:07,350
build your excess dynamic library but

00:34:04,830 --> 00:34:14,429
keep the dynamic libraries around for FF

00:34:07,350 --> 00:34:16,380
I but when you have both static and

00:34:14,429 --> 00:34:19,740
dynamic libraries in the same folder and

00:34:16,380 --> 00:34:20,460
same directory GC uses GCC uses the

00:34:19,740 --> 00:34:22,109
dynamic one

00:34:20,460 --> 00:34:23,669
by the default that's why alien that's

00:34:22,109 --> 00:34:29,490
basically why alien base does the same

00:34:23,669 --> 00:34:33,690
thing excuse me so and and and getting

00:34:29,490 --> 00:34:35,280
the appropriate linker flags to get to

00:34:33,690 --> 00:34:39,740
the cadet that get this to work is

00:34:35,280 --> 00:34:39,740
really tricky so what I did instead was

00:34:39,859 --> 00:34:44,730
just to move the dynamic libraries into

00:34:42,780 --> 00:34:47,159
a different folder so I keep I keep the

00:34:44,730 --> 00:34:49,409
esso and the dll files in a directory i

00:34:47,159 --> 00:34:52,290
called it dll just like for lack of a

00:34:49,409 --> 00:34:54,780
better term and now the excess modules

00:34:52,290 --> 00:34:56,940
will simply use the the static libraries

00:34:54,780 --> 00:35:01,560
and i can still grab the dynamic

00:34:56,940 --> 00:35:05,640
libraries for my ffi modules another

00:35:01,560 --> 00:35:09,780
challenge that I had was the auto conf

00:35:05,640 --> 00:35:13,880
centric approach was caused me some

00:35:09,780 --> 00:35:17,070
difficulty in Windows basically you need

00:35:13,880 --> 00:35:20,099
something called em sis it's sort of a

00:35:17,070 --> 00:35:22,530
minimal janu system or minimal kind of

00:35:20,099 --> 00:35:24,420
UNIX canoe I don't know whatever it

00:35:22,530 --> 00:35:26,490
provides sort of a lightweight shell

00:35:24,420 --> 00:35:31,020
environment for Windows enough to run

00:35:26,490 --> 00:35:32,760
auto cough and it's not normally there

00:35:31,020 --> 00:35:34,440
in Windows it's not even there it's not

00:35:32,760 --> 00:35:36,630
even part of strawberry perl so you

00:35:34,440 --> 00:35:38,550
can't really sort of depend on it so

00:35:36,630 --> 00:35:43,500
what i did was i wrote alien emphasis

00:35:38,550 --> 00:35:47,940
which allows you to run configure and

00:35:43,500 --> 00:35:50,820
it's also a no-op in unix so it solved

00:35:47,940 --> 00:35:53,520
that problem for me package config was

00:35:50,820 --> 00:35:57,030
also an issue so it's not native or even

00:35:53,520 --> 00:36:00,390
widely available under windows and in

00:35:57,030 --> 00:36:02,160
fact often if unless you explicitly

00:36:00,390 --> 00:36:05,220
install it's not available it's sort of

00:36:02,160 --> 00:36:07,470
a development package which is tricky if

00:36:05,220 --> 00:36:09,450
you're doing ffi stuff because the whole

00:36:07,470 --> 00:36:11,160
idea of f of i is not to need a compiler

00:36:09,450 --> 00:36:16,080
and if you have to do then install the

00:36:11,160 --> 00:36:18,839
development stuff it's sort of screws

00:36:16,080 --> 00:36:21,140
things up so what I did was I actually

00:36:18,839 --> 00:36:23,970
adopted a pearl there was an existing

00:36:21,140 --> 00:36:28,410
implementation of package config written

00:36:23,970 --> 00:36:30,599
in pure pearl and I the developer wasn't

00:36:28,410 --> 00:36:31,550
doing a lot with it so I kind of adopted

00:36:30,599 --> 00:36:33,680
it and

00:36:31,550 --> 00:36:35,420
it was actually pretty good module it

00:36:33,680 --> 00:36:37,820
just needed a few tweaks it didn't work

00:36:35,420 --> 00:36:40,220
on windows yet it does now in fact now

00:36:37,820 --> 00:36:43,190
it pretty much works everywhere at least

00:36:40,220 --> 00:36:44,660
that's what see pen testers tells me I'm

00:36:43,190 --> 00:36:49,880
actually going to be talking about this

00:36:44,660 --> 00:36:52,670
as as a lightning talk tomorrow so the

00:36:49,880 --> 00:36:54,620
future the road ahead I think this

00:36:52,670 --> 00:36:57,500
picture by the way because those flying

00:36:54,620 --> 00:37:04,190
car things kind of reminded me of yes a

00:36:57,500 --> 00:37:06,470
platypus I'm working on my own lib ffi

00:37:04,190 --> 00:37:09,710
bindings based on my experience

00:37:06,470 --> 00:37:12,590
implementing archive lib archive ffi and

00:37:09,710 --> 00:37:14,540
why not call it FF I platypus some of

00:37:12,590 --> 00:37:17,300
this is working but all of it is very

00:37:14,540 --> 00:37:19,850
much experimental and subject to change

00:37:17,300 --> 00:37:21,140
and I don't know I may not even have

00:37:19,850 --> 00:37:22,580
time to do it I know it's just kind of

00:37:21,140 --> 00:37:24,220
interesting for me at some ideas that

00:37:22,580 --> 00:37:27,620
I'm sort of putting into an actual

00:37:24,220 --> 00:37:29,120
library but it is just addition to the

00:37:27,620 --> 00:37:31,160
stuff that you can do already with FF I

00:37:29,120 --> 00:37:33,500
raw I'd like to make it much simpler to

00:37:31,160 --> 00:37:35,570
do operations with pointers on with

00:37:33,500 --> 00:37:38,450
basic types like integers so and I think

00:37:35,570 --> 00:37:41,270
that sort of the metaphor for this or

00:37:38,450 --> 00:37:46,190
the the conceptual way to do this is to

00:37:41,270 --> 00:37:47,990
use references so for a function that

00:37:46,190 --> 00:37:50,150
takes a pointer to an integer and see

00:37:47,990 --> 00:37:53,780
you ought to be able to pass a reference

00:37:50,150 --> 00:37:55,880
to an integer in Perl and the FFI layer

00:37:53,780 --> 00:37:58,820
whatever it is you know if it's ffi raw

00:37:55,880 --> 00:38:00,470
or if it's platypus or if it's if I

00:37:58,820 --> 00:38:06,350
sweet should be able to kind of just

00:38:00,470 --> 00:38:08,240
rock that and handle it for you the

00:38:06,350 --> 00:38:10,700
other thing that I think would be really

00:38:08,240 --> 00:38:13,010
useful is that the wrapper interface

00:38:10,700 --> 00:38:14,600
that I showed you that ffi sweet uses is

00:38:13,010 --> 00:38:17,270
really powerful i'm going to used it a

00:38:14,600 --> 00:38:21,440
lot when I was implementing archive live

00:38:17,270 --> 00:38:25,490
archive ffi but I also found that I was

00:38:21,440 --> 00:38:27,410
repeating myself like a lot and I think

00:38:25,490 --> 00:38:29,120
that instead of attaching the wrapper to

00:38:27,410 --> 00:38:31,820
the function if you attach it to the

00:38:29,120 --> 00:38:33,740
type then you can implement it just once

00:38:31,820 --> 00:38:36,470
and then every time you need to pass in

00:38:33,740 --> 00:38:39,290
that type 2 a.c function it'll use that

00:38:36,470 --> 00:38:42,050
particular wrapper that you need so if

00:38:39,290 --> 00:38:43,700
you and if you used excess before you

00:38:42,050 --> 00:38:44,790
should be probably thinking about type

00:38:43,700 --> 00:38:47,190
maps because it's a

00:38:44,790 --> 00:38:51,890
it's a similar idea basically sort of a

00:38:47,190 --> 00:38:51,890
recipe to translate from Pearl to see

00:38:58,270 --> 00:39:02,770
so portability was something that I

00:39:00,280 --> 00:39:04,600
mentioned earlier and I think this is an

00:39:02,770 --> 00:39:06,910
idea that we can borrow a good idea that

00:39:04,600 --> 00:39:09,790
we can borrow from the Ruby folks here's

00:39:06,910 --> 00:39:12,520
a diagram that I borrowed from or stole

00:39:09,790 --> 00:39:15,130
from Jeremy hi gardener he did a similar

00:39:12,520 --> 00:39:18,550
talk for the Ruby folks like a number of

00:39:15,130 --> 00:39:21,420
years ago basically in Ruby they have

00:39:18,550 --> 00:39:24,100
multiple implementations right there's

00:39:21,420 --> 00:39:26,080
JRuby which is in Java there's the

00:39:24,100 --> 00:39:28,930
original see implementation there's

00:39:26,080 --> 00:39:31,240
something called Rubinius i'm not i'm

00:39:28,930 --> 00:39:34,360
not a ruby expert but basically the idea

00:39:31,240 --> 00:39:37,900
is that you can implement your extension

00:39:34,360 --> 00:39:41,230
your fi in for one of these particular

00:39:37,900 --> 00:39:43,060
versions of Ruby but expect them to work

00:39:41,230 --> 00:39:44,530
in the other ones and then and and

00:39:43,060 --> 00:39:49,030
obviously there are different advantages

00:39:44,530 --> 00:39:50,500
to using each one so one of the

00:39:49,030 --> 00:39:53,890
challenges for a future implementation

00:39:50,500 --> 00:39:56,130
of pearl or you know maybe Perl 6 I

00:39:53,890 --> 00:39:59,440
don't know is that large swathes of

00:39:56,130 --> 00:40:00,970
useful Sipan depend on excess and they

00:39:59,440 --> 00:40:04,060
just won't be they'll need to be

00:40:00,970 --> 00:40:06,460
rewritten or something equivalent if

00:40:04,060 --> 00:40:09,160
each implementation had a standard ffi

00:40:06,460 --> 00:40:11,680
interface porting extensions between

00:40:09,160 --> 00:40:14,410
those different implementations would be

00:40:11,680 --> 00:40:16,390
a lot easier and actually the idea that

00:40:14,410 --> 00:40:18,610
I have is if the interface could be

00:40:16,390 --> 00:40:21,490
reduced to something some sort of data

00:40:18,610 --> 00:40:24,010
structure like a something in yama or

00:40:21,490 --> 00:40:26,860
JSON maybe then it would be even easier

00:40:24,010 --> 00:40:28,390
like so the syntax for perl 6 is going

00:40:26,860 --> 00:40:31,630
to be significantly different from Pearl

00:40:28,390 --> 00:40:35,290
5 so if your interface is defined in

00:40:31,630 --> 00:40:36,880
some sort of data structure than you can

00:40:35,290 --> 00:40:44,290
say here it is and it should just work

00:40:36,880 --> 00:40:46,720
maybe we'll see so at the beginning of

00:40:44,290 --> 00:40:49,600
my talk I showed you the things that I

00:40:46,720 --> 00:40:53,650
thought that excess was good for how

00:40:49,600 --> 00:40:55,120
does that compare to FF I I've shown you

00:40:53,650 --> 00:40:57,220
that you can write bindings for an

00:40:55,120 --> 00:41:00,910
existing library written in another

00:40:57,220 --> 00:41:06,250
language and I archive lib archive ffi

00:41:00,910 --> 00:41:07,730
is just one example I've shown you that

00:41:06,250 --> 00:41:12,830
you can write a

00:41:07,730 --> 00:41:17,030
parts of your program using FF I that

00:41:12,830 --> 00:41:18,619
need to be fast or small one thing it

00:41:17,030 --> 00:41:20,630
isn't especially good at is extending

00:41:18,619 --> 00:41:22,520
the Pearl language itself and I think

00:41:20,630 --> 00:41:26,000
obviously this is an area where excess

00:41:22,520 --> 00:41:28,609
shines because it is basically the guts

00:41:26,000 --> 00:41:30,950
of pearl exposed for anybody to tinker

00:41:28,609 --> 00:41:33,050
with and I think that's a good thing I

00:41:30,950 --> 00:41:38,320
think that actually is something that is

00:41:33,050 --> 00:41:41,750
really good for and is go I don't know

00:41:38,320 --> 00:41:45,260
other things that maybe are challenges

00:41:41,750 --> 00:41:49,300
or limitations is support for esoteric

00:41:45,260 --> 00:41:51,109
platforms like you know VMs or plan 9

00:41:49,300 --> 00:41:54,170
they're probably never going to work

00:41:51,109 --> 00:41:58,880
with lib ffi and probably not with FF I

00:41:54,170 --> 00:42:02,300
raw either I did do a quite a bit of

00:41:58,880 --> 00:42:05,660
work to make sure that FF I raw works on

00:42:02,300 --> 00:42:10,160
windows though and cygwin using both GCC

00:42:05,660 --> 00:42:11,600
and visual c++ so you know not working

00:42:10,160 --> 00:42:16,250
on windows is not excuse that you can

00:42:11,600 --> 00:42:19,100
use the other thing that fi stuff

00:42:16,250 --> 00:42:22,070
doesn't do is it doesn't catch errors

00:42:19,100 --> 00:42:24,380
that your C compiler normally would so

00:42:22,070 --> 00:42:27,440
something like using the wrong argument

00:42:24,380 --> 00:42:31,160
types or return types won't flag an

00:42:27,440 --> 00:42:34,070
error but so you kind of just you need

00:42:31,160 --> 00:42:36,440
to do a lot of checking the testing but

00:42:34,070 --> 00:42:38,300
I'm going to since this is my talk I'm

00:42:36,440 --> 00:42:39,320
allowed to classify things as I want i'm

00:42:38,300 --> 00:42:42,940
going to give this a check mark because

00:42:39,320 --> 00:42:42,940
you should be doing testing

00:42:51,680 --> 00:43:01,280
Sipan and github and the author the

00:42:58,730 --> 00:43:03,890
maintainer Alessandro is very actually

00:43:01,280 --> 00:43:06,470
has been very good about being

00:43:03,890 --> 00:43:09,339
accessible accepting pull requests that

00:43:06,470 --> 00:43:12,890
i made to support weird platforms and

00:43:09,339 --> 00:43:14,240
and that kind of thing and he's also

00:43:12,890 --> 00:43:15,800
actually fixed a couple bugs that i

00:43:14,240 --> 00:43:21,349
found but weren't wasn't able to figure

00:43:15,800 --> 00:43:23,359
out if I sweet is this thing it lives on

00:43:21,349 --> 00:43:26,839
github at the moment hopefully we can

00:43:23,359 --> 00:43:33,410
get it moving and the primary authors

00:43:26,839 --> 00:43:36,230
are Meredith Howard and myself I also

00:43:33,410 --> 00:43:40,490
wrote some I put some rpms together for

00:43:36,230 --> 00:43:41,900
recent fedoras on OBS if you want to try

00:43:40,490 --> 00:43:48,140
it out without compiling I don't know

00:43:41,900 --> 00:43:51,230
just it aside but that's it my name is

00:43:48,140 --> 00:43:57,079
Graham Wallace like i said i am on Sipan

00:43:51,230 --> 00:43:58,880
and github and twitter and email and i'm

00:43:57,079 --> 00:44:00,500
really interested in this stuff so if

00:43:58,880 --> 00:44:02,809
you are to you know maybe we can

00:44:00,500 --> 00:44:12,369
collaborate or if you have suggestions

00:44:02,809 --> 00:44:15,369
whatever are there any questions no

00:44:12,369 --> 00:44:15,369
question

00:44:18,049 --> 00:44:30,690
so I didn't do any benchmarking per se

00:44:26,720 --> 00:44:35,339
the stuff that I that I used it for was

00:44:30,690 --> 00:44:37,200
fast enough for me it is so f fi raw

00:44:35,339 --> 00:44:39,299
itself is written in excess right so

00:44:37,200 --> 00:44:43,890
there is going to be so you are going

00:44:39,299 --> 00:44:44,999
through excess anyway and it it's there

00:44:43,890 --> 00:44:46,049
may be actually be things that can be

00:44:44,999 --> 00:44:52,680
improved they're actually to make it

00:44:46,049 --> 00:44:55,259
faster but so more of the idea is to

00:44:52,680 --> 00:44:57,569
make these things easier and then we can

00:44:55,259 --> 00:45:06,479
work on you know making it faster too I

00:44:57,569 --> 00:45:08,910
guess but like is it so the the archive

00:45:06,479 --> 00:45:10,799
Lubell archive ffi so i actually use

00:45:08,910 --> 00:45:14,729
this at work if we have an application

00:45:10,799 --> 00:45:16,950
that you can download files that the

00:45:14,729 --> 00:45:19,410
scientists produce in a tar and into an

00:45:16,950 --> 00:45:21,869
entire file and we used to be using a

00:45:19,410 --> 00:45:25,619
pure pearl implementation and i switched

00:45:21,869 --> 00:45:29,849
to this ffi version and it was it was

00:45:25,619 --> 00:45:34,140
noticeably faster it was about twice as

00:45:29,849 --> 00:45:38,849
fast just measuring the the download

00:45:34,140 --> 00:45:40,619
speeds and but the nice the cool thing

00:45:38,849 --> 00:45:42,960
about was the old version only supported

00:45:40,619 --> 00:45:45,690
tar and this version supports like any

00:45:42,960 --> 00:45:50,809
of the format's that the Vark I've does

00:45:45,690 --> 00:45:50,809
so yes

00:45:53,670 --> 00:45:59,790
no I don't think so no so I didn't I

00:45:57,100 --> 00:46:18,700
didn't exercise that aspect of it

00:45:59,790 --> 00:46:24,100
anything else yes well they were both a

00:46:18,700 --> 00:46:27,400
bit challenging because I was kind of

00:46:24,100 --> 00:46:32,020
working on improving the FFI interface

00:46:27,400 --> 00:46:38,260
as I was working on it so i would say

00:46:32,020 --> 00:46:39,820
that overall i think that as the FFI raw

00:46:38,260 --> 00:46:41,620
on FF I sweet evolve I think they'll

00:46:39,820 --> 00:46:42,820
become much easier I think they're

00:46:41,620 --> 00:46:45,390
already much easier than they were when

00:46:42,820 --> 00:46:48,850
I sort of first started working on them

00:46:45,390 --> 00:46:52,960
XS is definitely challenging because I

00:46:48,850 --> 00:46:55,270
would sort of look at the the man pages

00:46:52,960 --> 00:46:59,370
like the pearl guts and pearl API and

00:46:55,270 --> 00:47:04,150
sort of just hit my head on the table

00:46:59,370 --> 00:47:08,770
but so like I say I think I think the

00:47:04,150 --> 00:47:11,580
FFI interface is easier but then again

00:47:08,770 --> 00:47:13,780
there are some things that that that are

00:47:11,580 --> 00:47:15,430
just because you're in the guts of pearl

00:47:13,780 --> 00:47:20,610
you can do things that you can do that

00:47:15,430 --> 00:47:20,610
you can't do from ffi yes

00:47:21,880 --> 00:47:26,829
more dangers and when we modify those

00:47:29,950 --> 00:47:34,290
pack goes into a scalar and then

00:47:39,890 --> 00:47:44,790
yeah so the way it's written the way

00:47:43,290 --> 00:47:47,550
it's right now you'd probably have to

00:47:44,790 --> 00:47:50,430
use the rapper interface so you'd yeah

00:47:47,550 --> 00:47:53,280
you pack it into a sea thing and a

00:47:50,430 --> 00:47:55,410
packet use pack pass it into the

00:47:53,280 --> 00:47:58,050
function and then it would do its thing

00:47:55,410 --> 00:48:00,180
and then you get back the pointer and

00:47:58,050 --> 00:48:04,380
you could you could unpack it at that

00:48:00,180 --> 00:48:07,140
point so why that's something that I

00:48:04,380 --> 00:48:08,940
think that should be a little bit easier

00:48:07,140 --> 00:48:10,140
right i think that like the the

00:48:08,940 --> 00:48:13,200
interface that i was talking about using

00:48:10,140 --> 00:48:14,880
references like my example was just a

00:48:13,200 --> 00:48:16,560
reference to an integer but you could

00:48:14,880 --> 00:48:22,770
have like an array reference that got

00:48:16,560 --> 00:48:25,680
translated in the FFI layer into like i

00:48:22,770 --> 00:48:27,300
say so assuming you have the the type is

00:48:25,680 --> 00:48:33,920
annotated correctly i think you could do

00:48:27,300 --> 00:48:33,920
it easier anyone else

00:48:38,200 --> 00:48:51,700

YouTube URL: https://www.youtube.com/watch?v=cY-yqQ_nmtw


