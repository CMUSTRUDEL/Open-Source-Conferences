Title: Scott Walters (‎scrottie‎) - Programming the Atari 2600 "Video Computer System"
Publication date: 2014-06-23
Playlist: YAPC::NA 2014
Description: 
	This talk drops virtually all abstraction and shows how to program the simple 8 bit processor and custom designed video hardware in the Atari 2600 "VCS". Users familiar with high level languages might find this an interesting introduction to how CPUs actually work.
Famous for its blocky graphics and simplistic games, the 2600 was the second programmable home video game system, introduced in 1977. Graphics are generated on the fly, pixel by pixel, at 60 frames per second by setting up various bits of hardware logic and orchestrating them using the CPU. Controlling logic to display graphics is part of the challenge and creative process of creating a 2600 game.
The 2600 demoscene and homebrew game scene are alive and well. Modern 2600 games push the hardware far beyond what was possible and benefit from original chip schematics, near perfect emulator/debuggers, documentation of graphics techniques, carts with active logic and RAM on them, and a fundamentally open source, collaborative development model.
We'll learn how to program the MOS Technologies 6502 processor (later used in the C=64, Apple ][, NES, and many other systems but fundamentally the same as modern CPUs), control the Atari TIA video hardware, and then we'll do some shaded realtime 3D graphics.
Captions: 
	00:00:17,869 --> 00:00:24,260
thank you for coming I'm Scot Walters

00:00:20,010 --> 00:00:26,820
karate this is the the 2600 junior like

00:00:24,260 --> 00:00:28,890
15 years after they started making it

00:00:26,820 --> 00:00:31,199
they they made this little small thing

00:00:28,890 --> 00:00:33,360
so we're selling it for $50 so how many

00:00:31,199 --> 00:00:36,000
of you had an Atari 2600 I mean growing

00:00:33,360 --> 00:00:37,949
up awesome okay I think there's a

00:00:36,000 --> 00:00:40,770
there's a sample bias here and I think

00:00:37,949 --> 00:00:43,530
we got some selection bias now thank you

00:00:40,770 --> 00:00:45,089
for coming so people this thing is

00:00:43,530 --> 00:00:48,330
famous for its graphics and not in a

00:00:45,089 --> 00:00:50,220
good way so I kind of I want to I want

00:00:48,330 --> 00:00:51,870
to get a handle on what people think is

00:00:50,220 --> 00:00:53,820
actually in this what's happening here

00:00:51,870 --> 00:00:57,559
so how much memory does this thing have

00:00:53,820 --> 00:00:57,559
who thinks it has more than a megabyte

00:00:57,830 --> 00:01:03,299
okay what about what about 128 K who

00:01:02,339 --> 00:01:08,070
thinks it has more than hundred

00:01:03,299 --> 00:01:10,860
twenty-eight K 1 K more than 1k okay we

00:01:08,070 --> 00:01:12,299
got a few takers for that those of you

00:01:10,860 --> 00:01:20,720
who think it has less than 1k how much

00:01:12,299 --> 00:01:26,880
memory do you think this thing has 512

00:01:20,720 --> 00:01:28,860
any other guesses 128 we have a winner

00:01:26,880 --> 00:01:30,920
ladies and gentleman has 128 bytes of

00:01:28,860 --> 00:01:30,920
memory

00:01:31,930 --> 00:01:37,060
so the the memory is actually on a

00:01:34,299 --> 00:01:39,920
off-the-shelf part the it's called the

00:01:37,060 --> 00:01:41,690
PIAA the hardware interface that

00:01:39,920 --> 00:01:45,740
connects to the switches also has a

00:01:41,690 --> 00:01:49,450
hardware timer on it and it has and it

00:01:45,740 --> 00:01:52,009
has memory baked-in static memory so

00:01:49,450 --> 00:01:53,479
right this was the first computer that I

00:01:52,009 --> 00:01:55,009
had actually not this exact model but

00:01:53,479 --> 00:01:57,229
Atari is 8-bit home computers they came

00:01:55,009 --> 00:02:00,140
well after the 2600 they they inherited

00:01:57,229 --> 00:02:02,750
some of the hardware so by my exposure

00:02:00,140 --> 00:02:04,369
was was kind of this this Atari thing

00:02:02,750 --> 00:02:10,850
and I was always curious about the 2600

00:02:04,369 --> 00:02:12,170
after that later got a 130 XE so the

00:02:10,850 --> 00:02:13,760
books back in the day that I'm learning

00:02:12,170 --> 00:02:16,970
from there they're really trippy they

00:02:13,760 --> 00:02:18,920
look like this and does that make you

00:02:16,970 --> 00:02:24,019
want to learn to program be a superhero

00:02:18,920 --> 00:02:25,640
and that at yeah maybe anyway so I also

00:02:24,019 --> 00:02:27,170
had a head Amiga later and it turned out

00:02:25,640 --> 00:02:29,750
by some some coincidence the same guy

00:02:27,170 --> 00:02:31,550
g-minor designed I was with the chief

00:02:29,750 --> 00:02:35,450
designer for the chips and all of these

00:02:31,550 --> 00:02:36,920
machines starting with the 2600 epyck

00:02:35,450 --> 00:02:40,130
computer in the Amiga and then I went

00:02:36,920 --> 00:02:42,410
straight to Linux and skipped Windows so

00:02:40,130 --> 00:02:44,480
there's a huge there's this was at our

00:02:42,410 --> 00:02:46,549
ease first first commercial product pong

00:02:44,480 --> 00:02:47,870
they put in arcades and then they

00:02:46,549 --> 00:02:49,250
started selling them at home this was a

00:02:47,870 --> 00:02:51,260
huge deal at the time people were really

00:02:49,250 --> 00:02:52,549
excited about that and then they they

00:02:51,260 --> 00:02:58,070
started selling the VCS and they're

00:02:52,549 --> 00:03:00,859
really excited about that too the the

00:02:58,070 --> 00:03:03,200
pong unit was not a computer they they

00:03:00,859 --> 00:03:04,910
built it out of 74,000 series or

00:03:03,200 --> 00:03:07,489
something like that logic so little NAND

00:03:04,910 --> 00:03:09,140
gates and latches and inverters and

00:03:07,489 --> 00:03:11,000
buffers and stuff like that so there's

00:03:09,140 --> 00:03:12,170
no processor in it so all it did was

00:03:11,000 --> 00:03:13,609
play pong and there's a whole bunch of

00:03:12,170 --> 00:03:15,680
clones that did nothing but play pong

00:03:13,609 --> 00:03:18,290
and then they kept making machines like

00:03:15,680 --> 00:03:19,790
this for the arcade and then eventually

00:03:18,290 --> 00:03:21,620
they decided they wanted to be in a home

00:03:19,790 --> 00:03:23,180
but they couldn't just bring all the the

00:03:21,620 --> 00:03:24,680
logic in so they they had to make

00:03:23,180 --> 00:03:28,640
something flexible enough to play these

00:03:24,680 --> 00:03:32,299
that that had well they had to put a

00:03:28,640 --> 00:03:34,310
computer in it so uh Mario first

00:03:32,299 --> 00:03:35,690
appeared on this but not in Mario

00:03:34,310 --> 00:03:37,970
Brothers he first appeared in Donkey

00:03:35,690 --> 00:03:39,290
Kong for those of you who who aren't

00:03:37,970 --> 00:03:41,620
familiar there's there's some history

00:03:39,290 --> 00:03:41,620
here

00:03:42,300 --> 00:03:48,430
so this thing the Atari 2600 came out

00:03:46,960 --> 00:03:49,450
the same year the original ones were way

00:03:48,430 --> 00:03:52,390
bigger than this one the original one

00:03:49,450 --> 00:03:55,090
came out in 1975 and that was the same

00:03:52,390 --> 00:03:56,290
year that the Apple 2 came out Atari

00:03:55,090 --> 00:03:57,520
wanted to introduce a tuner dollar

00:03:56,290 --> 00:03:59,770
system which is eight hundred seventy

00:03:57,520 --> 00:04:05,740
dollars in today's today's money had to

00:03:59,770 --> 00:04:07,750
play all their acade hits and this this

00:04:05,740 --> 00:04:09,190
thing came onto the the market costing

00:04:07,750 --> 00:04:11,590
thirteen hundred dollars without a disc

00:04:09,190 --> 00:04:12,850
Romana tur and I had 4k memory so

00:04:11,590 --> 00:04:15,940
they're trying to make something that

00:04:12,850 --> 00:04:18,750
costs a sixth of what less than a sixth

00:04:15,940 --> 00:04:18,750
of what this thing does

00:04:19,590 --> 00:04:25,060
and the this is what they are up against

00:04:23,290 --> 00:04:34,230
this is what what they're competing with

00:04:25,060 --> 00:04:36,880
graphics for so the if the 2600 is bad

00:04:34,230 --> 00:04:38,500
it costs the six as much as this machine

00:04:36,880 --> 00:04:40,510
and things aren't terrible shades of

00:04:38,500 --> 00:04:49,000
green and red and they're not flickering

00:04:40,510 --> 00:04:51,070
quite that bad usually I want to kind of

00:04:49,000 --> 00:04:58,060
build an appreciation for for what they

00:04:51,070 --> 00:05:00,550
did here so the the design of the Atari

00:04:58,060 --> 00:05:06,280
2600 is intimately designed intimately

00:05:00,550 --> 00:05:11,710
tied to the design of the CRT you have

00:05:06,280 --> 00:05:14,560
192 scan lines a picture display on your

00:05:11,710 --> 00:05:17,890
home NTSC cathode ray tube television

00:05:14,560 --> 00:05:20,680
brought NTSC broadcast standard national

00:05:17,890 --> 00:05:22,360
television and something something so

00:05:20,680 --> 00:05:24,040
this is what I've got transmitted over

00:05:22,360 --> 00:05:27,010
the air on in your rabbit ears picked up

00:05:24,040 --> 00:05:29,770
so you had 192 lines of actual picture

00:05:27,010 --> 00:05:30,760
this is the picture here right there you

00:05:29,770 --> 00:05:38,140
had a hundred eighty two lines of

00:05:30,760 --> 00:05:40,410
picture that were across two four I'm

00:05:38,140 --> 00:05:40,410
sorry

00:05:40,430 --> 00:05:48,920
now it's 240 resolution that's that's

00:05:44,580 --> 00:05:52,790
clock cycles so 2 for 240 pixels across

00:05:48,920 --> 00:06:09,090
192 scan lines huh

00:05:52,790 --> 00:06:10,230
so that's it so you're trying to you're

00:06:09,090 --> 00:06:12,960
trying to trying to build something

00:06:10,230 --> 00:06:16,410
cheaper than the the the the Apple 2 so

00:06:12,960 --> 00:06:18,420
what what do you do how how can you make

00:06:16,410 --> 00:06:20,720
advice cheaper what's the general

00:06:18,420 --> 00:06:25,650
strategy for doing that

00:06:20,720 --> 00:06:29,130
you move logic to software come back to

00:06:25,650 --> 00:06:41,700
that in a minute here the the processor

00:06:29,130 --> 00:06:45,750
has when you're when you're writing code

00:06:41,700 --> 00:06:47,160
for this thing losing a losing a little

00:06:45,750 --> 00:06:49,410
bit here there's some store a

00:06:47,160 --> 00:06:51,270
instructions this is what it looks like

00:06:49,410 --> 00:06:53,430
in code to write to a hardware register

00:06:51,270 --> 00:06:55,020
that's what it looks like to to write to

00:06:53,430 --> 00:06:56,700
a memory location it's the exact same

00:06:55,020 --> 00:06:58,740
instruction just writing to different

00:06:56,700 --> 00:07:01,890
addresses this is the color palette or

00:06:58,740 --> 00:07:05,210
the thing you have 128 colors these are

00:07:01,890 --> 00:07:07,830
the features that the video hardware has

00:07:05,210 --> 00:07:09,750
you can tell the processor to wait until

00:07:07,830 --> 00:07:11,220
the scanline is at the beginning the the

00:07:09,750 --> 00:07:12,840
process to tell the thing to make the

00:07:11,220 --> 00:07:14,910
processor wait until the scanline is at

00:07:12,840 --> 00:07:17,100
the very beginning of a scanline or the

00:07:14,910 --> 00:07:20,480
the beam so the cap that would great

00:07:17,100 --> 00:07:23,160
tube you have this you have this

00:07:20,480 --> 00:07:25,200
electron gun think it's aimed by magnets

00:07:23,160 --> 00:07:27,240
so it's drawing one dot at a time and

00:07:25,200 --> 00:07:30,510
scanning left to right left to right top

00:07:27,240 --> 00:07:33,390
to bottom so when the cathode rays to

00:07:30,510 --> 00:07:35,340
the starting the scanline the wait sink

00:07:33,390 --> 00:07:42,570
will release the processor and let it

00:07:35,340 --> 00:07:44,460
run again be blank the processor sends

00:07:42,570 --> 00:07:46,560
signal to the the the television

00:07:44,460 --> 00:07:48,540
hardware by way of them by way of this

00:07:46,560 --> 00:07:50,169
memory address to a tell the processor

00:07:48,540 --> 00:07:52,029
to start moving the beam from the bottom

00:07:50,169 --> 00:07:54,849
back up to the top again that's done in

00:07:52,029 --> 00:07:59,310
software you have to control this so you

00:07:54,849 --> 00:07:59,310
have to enable vertical blank during

00:08:01,710 --> 00:08:10,090
when you hit here for 437 lines you're

00:08:08,050 --> 00:08:11,349
you're telling the processor to move

00:08:10,090 --> 00:08:13,090
start moving the scan line back to the

00:08:11,349 --> 00:08:20,860
top of the screen or the the CV

00:08:13,090 --> 00:08:24,819
otherwise I won't do it itself your you

00:08:20,860 --> 00:08:27,339
have playfield registers 0 1 2 3 PF 0

00:08:24,819 --> 00:08:30,789
only has four bits in it PF 1 has 8 bits

00:08:27,339 --> 00:08:32,620
PF 2 so the the left side of your screen

00:08:30,789 --> 00:08:35,050
and the right side of your screen each

00:08:32,620 --> 00:08:36,639
have 20 bits of playfield data this is

00:08:35,050 --> 00:08:40,930
the background that gets drawn when you

00:08:36,639 --> 00:08:42,610
see a game so the left side of the

00:08:40,930 --> 00:08:43,810
screen is either mirrored or repeated on

00:08:42,610 --> 00:08:45,880
the right-hand side of the screen so you

00:08:43,810 --> 00:08:47,740
get either the same data again or else

00:08:45,880 --> 00:08:49,389
you get the mirror image of it and the

00:08:47,740 --> 00:08:51,269
processor rights to these registers

00:08:49,389 --> 00:08:56,110
every scanline that it wants to change

00:08:51,269 --> 00:08:59,500
what appears on that scanline so you've

00:08:56,110 --> 00:09:02,470
got 76 machine cycles and you can spend

00:08:59,500 --> 00:09:05,890
of updating the background registers you

00:09:02,470 --> 00:09:08,079
can change the size of the ball you've

00:09:05,890 --> 00:09:10,959
got 3 different kinds of objects you

00:09:08,079 --> 00:09:12,579
have player 2 player objects which are

00:09:10,959 --> 00:09:13,839
movable 8 bit wide things that you can

00:09:12,579 --> 00:09:16,149
change the position of on the scanline

00:09:13,839 --> 00:09:18,519
you've got 40 20 bits of background data

00:09:16,149 --> 00:09:19,990
that mirror and repeat you have 3 1 bit

00:09:18,519 --> 00:09:23,560
wide objects you've got a missile and a

00:09:19,990 --> 00:09:27,220
ball or two missiles and a ball you can

00:09:23,560 --> 00:09:29,470
repeat the players you can have three

00:09:27,220 --> 00:09:31,810
players for a kind of Space Invaders

00:09:29,470 --> 00:09:33,970
thing you can make them quad size or

00:09:31,810 --> 00:09:40,720
double size you can have two players

00:09:33,970 --> 00:09:42,790
spaced out you don't get to tell it

00:09:40,720 --> 00:09:46,209
where to draw the player at the point

00:09:42,790 --> 00:09:47,380
where the processor the the scanline is

00:09:46,209 --> 00:09:50,500
that the place where you want the

00:09:47,380 --> 00:09:52,360
processor to be the processor saves to

00:09:50,500 --> 00:09:56,170
that memory location there and it moves

00:09:52,360 --> 00:09:57,610
the player there so you have to the

00:09:56,170 --> 00:09:58,870
theme of this is you have to count the

00:09:57,610 --> 00:10:00,699
number of cycles you have to know how

00:09:58,870 --> 00:10:02,120
long each instruction takes and where

00:10:00,699 --> 00:10:07,580
exactly where the electron

00:10:02,120 --> 00:10:10,779
at that point there's a way to move the

00:10:07,580 --> 00:10:13,520
players relative where they are up to

00:10:10,779 --> 00:10:15,820
seven or eight places left or right

00:10:13,520 --> 00:10:15,820
where they are

00:10:20,860 --> 00:10:24,830
which is which is that you store how

00:10:23,630 --> 00:10:29,960
much you want to move the players and

00:10:24,830 --> 00:10:31,580
you bank another memory address you can

00:10:29,960 --> 00:10:35,420
enable/disable the graphics you can

00:10:31,580 --> 00:10:37,430
store video data for the players you

00:10:35,420 --> 00:10:40,250
have 8 bits for two different movable

00:10:37,430 --> 00:10:44,000
objects you have you can just set the

00:10:40,250 --> 00:10:47,750
play field to repeat or mirror you can

00:10:44,000 --> 00:10:50,930
delay the graphics updating in the

00:10:47,750 --> 00:10:52,130
players you can change colors of the two

00:10:50,930 --> 00:10:54,860
different players individually the

00:10:52,130 --> 00:10:57,020
background and the foreground and you

00:10:54,860 --> 00:10:58,910
have two Audio registers now given all

00:10:57,020 --> 00:11:00,650
of that what was involved in making this

00:10:58,910 --> 00:11:02,510
right here what what registers do they

00:11:00,650 --> 00:11:03,650
have to use what's going on here what

00:11:02,510 --> 00:11:06,770
does the processor spending its time

00:11:03,650 --> 00:11:13,850
doing do I have any volunteers to to

00:11:06,770 --> 00:11:15,440
reverse-engineer this so what's some of

00:11:13,850 --> 00:11:17,810
the registers that are being used here

00:11:15,440 --> 00:11:22,720
this is a this is the pack and this is

00:11:17,810 --> 00:11:22,720
the the tank combat game user

00:11:27,079 --> 00:11:31,110
actually it's using a feature where them

00:11:29,249 --> 00:11:33,119
it's drawing that using the background

00:11:31,110 --> 00:11:35,339
pattern data but you can set them to

00:11:33,119 --> 00:11:36,660
match the players on the left side would

00:11:35,339 --> 00:11:39,199
be player one and the right side will be

00:11:36,660 --> 00:11:41,999
player two but thank you excellent guess

00:11:39,199 --> 00:11:44,429
so this is this is the 20 bits

00:11:41,999 --> 00:11:46,079
background data right here that's

00:11:44,429 --> 00:11:48,660
mirrored from one side to the other side

00:11:46,079 --> 00:11:50,069
every scanline they update the

00:11:48,660 --> 00:11:51,480
background data or maybe every eight

00:11:50,069 --> 00:11:54,839
scan lines they update the background

00:11:51,480 --> 00:11:56,569
data at this point here they tell it to

00:11:54,839 --> 00:11:58,860
start drawing the the first player

00:11:56,569 --> 00:12:00,480
probably before the screens started

00:11:58,860 --> 00:12:03,239
drawing now this remember this is as the

00:12:00,480 --> 00:12:06,029
scan lines going left to right and top

00:12:03,239 --> 00:12:07,889
to bottom the processor is updating

00:12:06,029 --> 00:12:10,829
these registers in real time 60 times a

00:12:07,889 --> 00:12:13,739
second so here they they started loading

00:12:10,829 --> 00:12:15,660
different data each each couple of scan

00:12:13,739 --> 00:12:16,980
lines into this player here they said

00:12:15,660 --> 00:12:18,809
I'm doing the same thing for this one

00:12:16,980 --> 00:12:20,279
they probably checked every scan line

00:12:18,809 --> 00:12:21,749
rather they needed to store data in

00:12:20,279 --> 00:12:24,329
there and then when they get to the

00:12:21,749 --> 00:12:26,309
bottom there's a bit of a reprieve the

00:12:24,329 --> 00:12:32,639
thing can think and do some game logic

00:12:26,309 --> 00:12:34,110
for about 30% of the time I'm going to

00:12:32,639 --> 00:12:40,379
show some more games here and see if we

00:12:34,110 --> 00:12:48,199
can get some theories on exactly what's

00:12:40,379 --> 00:12:48,199
going on so you don't have any favorites

00:12:50,270 --> 00:12:59,640
look at Solaris is good space invaders

00:12:54,920 --> 00:13:06,060
Donkey Kong shouts actually like Indiana

00:12:59,640 --> 00:13:07,620
Jones let's see if this works

00:13:06,060 --> 00:13:11,460
see this is what I do at home of my

00:13:07,620 --> 00:13:18,420
father I've just gotta got a monitor and

00:13:11,460 --> 00:13:32,070
I just plugged the the 2600 into it care

00:13:18,420 --> 00:13:34,080
of this thing so the the particular

00:13:32,070 --> 00:13:36,660
processor in the 2600 says stop me at

00:13:34,080 --> 00:13:38,340
any point you have any questions it's a

00:13:36,660 --> 00:13:39,630
65 or 70 so it's a version of this DC if

00:13:38,340 --> 00:13:40,920
I have a 2 that has most of the address

00:13:39,630 --> 00:13:43,170
line or a lot of the address lines cut

00:13:40,920 --> 00:13:45,810
off so I can address 4k or ek of memory

00:13:43,170 --> 00:13:47,990
totally the carts usually have 4k on

00:13:45,810 --> 00:13:47,990
them

00:14:08,110 --> 00:14:11,930
yeah I think I'll give us a minute if I

00:14:10,790 --> 00:14:19,700
can't get it to work I'll just have to

00:14:11,930 --> 00:14:22,430
give up I lugged this thing a long way

00:14:19,700 --> 00:14:23,900
to to plug this in all right I think I

00:14:22,430 --> 00:14:25,460
think I got to give up and just go on

00:14:23,900 --> 00:14:27,650
emulation I apologize

00:14:25,460 --> 00:14:30,340
try again if I have time left over in

00:14:27,650 --> 00:14:30,340
the unlikely event

00:14:41,700 --> 00:14:44,700
emulator

00:14:53,440 --> 00:15:01,420
what do they have to do to get this

00:14:55,900 --> 00:15:03,340
thing to work what's going on here now

00:15:01,420 --> 00:15:04,570
we've got two we've got two sprites and

00:15:03,340 --> 00:15:07,480
we can change the color on them every

00:15:04,570 --> 00:15:09,580
line and we can change the pattern data

00:15:07,480 --> 00:15:11,080
on them every line they're both probably

00:15:09,580 --> 00:15:12,310
on that scanline but what's going on

00:15:11,080 --> 00:15:16,630
here we've got a lot more than two

00:15:12,310 --> 00:15:18,790
sprites these two yes

00:15:16,630 --> 00:15:20,710
yeah it's sharing one between there so

00:15:18,790 --> 00:15:22,570
it can multiplex some you can have at

00:15:20,710 --> 00:15:25,120
least two more if you update hard

00:15:22,570 --> 00:15:27,220
registers and reposition them but at any

00:15:25,120 --> 00:15:28,480
given scanline you can have two if you

00:15:27,220 --> 00:15:31,050
have enough cycles to update all the

00:15:28,480 --> 00:15:31,050
registers

00:15:41,110 --> 00:15:47,300
so the 6502 is also used in bender the

00:15:45,130 --> 00:15:51,440
terminator Android it was used in the

00:15:47,300 --> 00:15:53,210
Apple - the Commodore 64 all sorts of

00:15:51,440 --> 00:15:58,280
all sorts of things have this in it the

00:15:53,210 --> 00:16:00,260
Atari 8-bit home computers this is this

00:15:58,280 --> 00:16:03,500
is combat right here disassembled and

00:16:00,260 --> 00:16:06,290
graphed this is what 6502 assembly looks

00:16:03,500 --> 00:16:07,970
like if you zoom way way out so this

00:16:06,290 --> 00:16:09,380
stuff here they D compiled into

00:16:07,970 --> 00:16:11,810
instructions are too small to see but

00:16:09,380 --> 00:16:14,450
where it's where there's graphics 8-bit

00:16:11,810 --> 00:16:18,500
graphic in there they they have it

00:16:14,450 --> 00:16:22,250
decoded as graphic I don't even know

00:16:18,500 --> 00:16:24,400
what that is I that effect should not be

00:16:22,250 --> 00:16:24,400
on

00:16:35,810 --> 00:16:39,870
okay so this is the this is the syntax

00:16:38,010 --> 00:16:41,280
of 6502 assembly so if you want to

00:16:39,870 --> 00:16:43,080
program the processor anything and you

00:16:41,280 --> 00:16:45,150
do otherwise you wouldn't be here

00:16:43,080 --> 00:16:46,860
the syntax for the language is label

00:16:45,150 --> 00:16:49,050
starts in the in the first column and

00:16:46,860 --> 00:16:51,690
then the three-letter opcode name and

00:16:49,050 --> 00:16:54,090
then any operands to it commas or

00:16:51,690 --> 00:16:57,510
semicolons indicate a comment and then

00:16:54,090 --> 00:16:59,340
comments after the semicolon so here's

00:16:57,510 --> 00:17:00,690
the add with carry instruction there's

00:16:59,340 --> 00:17:04,110
not an ADD without care instructions

00:17:00,690 --> 00:17:05,250
they name the one add instruction ABC so

00:17:04,110 --> 00:17:06,420
there's a few different flavors of this

00:17:05,250 --> 00:17:08,310
the first one is you're adding an

00:17:06,420 --> 00:17:11,070
immediate value whatever is in the

00:17:08,310 --> 00:17:14,970
accumulator the a register you add one

00:17:11,070 --> 00:17:16,740
to it the pound sign means that you're

00:17:14,970 --> 00:17:18,030
just adding that number otherwise you're

00:17:16,740 --> 00:17:22,980
adding to a memory address whatever

00:17:18,030 --> 00:17:24,870
values and the memory address 99 the

00:17:22,980 --> 00:17:27,839
extra register can be used to index it

00:17:24,870 --> 00:17:31,080
so you add X to 99 and then add to

00:17:27,839 --> 00:17:33,180
whatever's in that memory location now

00:17:31,080 --> 00:17:35,310
the 6502 is it has a special feature

00:17:33,180 --> 00:17:37,830
that's really useful for the atari 2600

00:17:35,310 --> 00:17:40,650
because all the hardware registers are

00:17:37,830 --> 00:17:45,600
in the first 256 bytes of memory and the

00:17:40,650 --> 00:17:47,250
first addressable by one byte so there's

00:17:45,600 --> 00:17:48,900
an addressing mode that lets you address

00:17:47,250 --> 00:17:50,160
things with only one byte that are

00:17:48,900 --> 00:17:52,290
addressable in the first byte of memory

00:17:50,160 --> 00:17:54,420
so all of the all of the RAM and all the

00:17:52,290 --> 00:17:57,180
hardware registers except for the in uh

00:17:54,420 --> 00:17:58,830
the i/o stuff you can address with one

00:17:57,180 --> 00:18:01,110
byte of memory so you have one byte for

00:17:58,830 --> 00:18:03,810
the add instruction and then one byte

00:18:01,110 --> 00:18:06,030
for which memory address which is 99 so

00:18:03,810 --> 00:18:08,400
this is two bytes right here this is

00:18:06,030 --> 00:18:11,190
three bytes in your program that's also

00:18:08,400 --> 00:18:13,260
three bytes this adds X to a 16-bit

00:18:11,190 --> 00:18:15,300
number goes to that memory address as

00:18:13,260 --> 00:18:16,890
forever there this is indirect it looks

00:18:15,300 --> 00:18:20,190
and it computes the memory address which

00:18:16,890 --> 00:18:22,800
is the memory address FML hit just and

00:18:20,190 --> 00:18:24,570
then goes out to that address and this

00:18:22,800 --> 00:18:27,420
stuff is really handy for doing tables

00:18:24,570 --> 00:18:30,300
stuff usually you just use the first 99

00:18:27,420 --> 00:18:32,280
comma X and you just have a table of 256

00:18:30,300 --> 00:18:33,600
oh so this is all of the instructions

00:18:32,280 --> 00:18:36,180
and the seats you have a 2 processor

00:18:33,600 --> 00:18:37,920
you've got break which gives it a

00:18:36,180 --> 00:18:40,410
non-maskable interrupt which jumps

00:18:37,920 --> 00:18:41,940
through an interrupt vector and calls an

00:18:40,410 --> 00:18:44,100
operating system which does not exist in

00:18:41,940 --> 00:18:45,480
this thing you can branch if the last

00:18:44,100 --> 00:18:47,309
operation resulted in a pile

00:18:45,480 --> 00:18:50,429
number you can jump to a subroutine this

00:18:47,309 --> 00:18:52,080
thing has a stack - you can jump to a

00:18:50,429 --> 00:18:53,549
subroutine and it pushes the address to

00:18:52,080 --> 00:18:55,380
a stack you have to save your own

00:18:53,549 --> 00:18:57,780
registers you can branch if the last

00:18:55,380 --> 00:18:59,520
computation resulted a negative number

00:18:57,780 --> 00:19:01,830
you can return from an interrupt which

00:18:59,520 --> 00:19:03,390
is break is an interrupt this thing

00:19:01,830 --> 00:19:05,429
doesn't have interrupt logic hooked up

00:19:03,390 --> 00:19:07,200
so you can't use that the real 6502 does

00:19:05,429 --> 00:19:09,330
6507 strip that off you can return from

00:19:07,200 --> 00:19:11,549
a subroutine the code that I'm gonna

00:19:09,330 --> 00:19:12,780
show you here doesn't use any

00:19:11,549 --> 00:19:15,630
subroutines because I can't spare the

00:19:12,780 --> 00:19:18,150
memory I'm overflow flag is set Kari is

00:19:15,630 --> 00:19:19,559
clear you can branch all the instruction

00:19:18,150 --> 00:19:20,910
start with B or branches you can load

00:19:19,559 --> 00:19:22,919
data into the wire register you have

00:19:20,910 --> 00:19:26,190
three registers why register X register

00:19:22,919 --> 00:19:27,960
a register the x and y registers all you

00:19:26,190 --> 00:19:29,880
can do is increment D increment them and

00:19:27,960 --> 00:19:31,860
save them and compare them to other

00:19:29,880 --> 00:19:34,110
numbers and use them as indexes on other

00:19:31,860 --> 00:19:35,520
loads stores and additions otherwise you

00:19:34,110 --> 00:19:38,250
really only have one register the a

00:19:35,520 --> 00:19:40,429
register you can compare a value you can

00:19:38,250 --> 00:19:42,990
branch if the last operation is nonzero

00:19:40,429 --> 00:19:45,330
you can compare X to something you can

00:19:42,990 --> 00:19:47,429
branch if the last operation was equal

00:19:45,330 --> 00:19:51,419
you can do bitwise tests on something

00:19:47,429 --> 00:19:53,460
store Y load Y in different different

00:19:51,419 --> 00:19:57,150
addressing modes kind of index by X you

00:19:53,460 --> 00:19:58,799
can push the processor flags and then

00:19:57,150 --> 00:20:00,559
pull them again you can clear different

00:19:58,799 --> 00:20:03,120
flags such as the carry flag and

00:20:00,559 --> 00:20:05,100
interrupt flag you can transfer data

00:20:03,120 --> 00:20:06,720
between different registers as long as

00:20:05,100 --> 00:20:09,090
you're transferring it through the the a

00:20:06,720 --> 00:20:13,110
register you can increment and decrement

00:20:09,090 --> 00:20:16,500
Y shift values left and right jump to

00:20:13,110 --> 00:20:21,650
different locations you can do exclusive

00:20:16,500 --> 00:20:23,880
or and and or logic operations subtract

00:20:21,650 --> 00:20:27,210
or bit shifting stuff and that's the

00:20:23,880 --> 00:20:29,880
only things you can do this is this is

00:20:27,210 --> 00:20:31,320
what the processor does so but there's

00:20:29,880 --> 00:20:34,530
also some legal instructions that kind

00:20:31,320 --> 00:20:35,820
of happened because some it's wired up

00:20:34,530 --> 00:20:37,590
so that when it sees different bit

00:20:35,820 --> 00:20:39,120
patterns coming in it enables the

00:20:37,590 --> 00:20:40,440
different bits of logic and stuff like

00:20:39,120 --> 00:20:41,400
that so all of these things are two

00:20:40,440 --> 00:20:44,460
different things happening at the same

00:20:41,400 --> 00:20:45,840
time and people creating games for this

00:20:44,460 --> 00:20:50,340
thing will use these in strategic

00:20:45,840 --> 00:20:51,840
locations such as date format the

00:20:50,340 --> 00:20:53,640
contents of a memory location and the

00:20:51,840 --> 00:20:56,480
compare the results with the a register

00:20:53,640 --> 00:21:00,260
that's fantastic load to address or to

00:20:56,480 --> 00:21:02,240
registers at the same time completely

00:21:00,260 --> 00:21:03,140
they didn't even put these in the manual

00:21:02,240 --> 00:21:05,270
so um

00:21:03,140 --> 00:21:09,200
TI a processor this is what joust in the

00:21:05,270 --> 00:21:11,780
arcade look like this is a what someone

00:21:09,200 --> 00:21:15,140
made a game called joust pong when you

00:21:11,780 --> 00:21:17,390
flap up and down and I was I loved joust

00:21:15,140 --> 00:21:19,760
as a kid he little paddles are flapping

00:21:17,390 --> 00:21:24,669
you can can demonstrate at the the end

00:21:19,760 --> 00:21:27,230
here I get out of slide software so I

00:21:24,669 --> 00:21:29,270
love jealous as echidnas I was always

00:21:27,230 --> 00:21:32,030
inspired by it and I had this idea for

00:21:29,270 --> 00:21:34,070
the Atari 2600 you you can't really do

00:21:32,030 --> 00:21:35,809
very much 3d stuff because you need a

00:21:34,070 --> 00:21:37,640
frame buffer to do that and then you

00:21:35,809 --> 00:21:39,110
have to buy an Apple 2 or something

00:21:37,640 --> 00:21:42,799
really expensive like that which no one

00:21:39,110 --> 00:21:44,480
can afford but what if you use the 128

00:21:42,799 --> 00:21:46,549
bytes of memory as a sort of primitive

00:21:44,480 --> 00:21:52,370
frame buffer obviously you know you

00:21:46,549 --> 00:21:54,380
can't you can't really have very much

00:21:52,370 --> 00:21:55,940
resolution in fact you only have Y

00:21:54,380 --> 00:21:58,400
resolution here's someone made floppy

00:21:55,940 --> 00:22:03,220
the bird for the for the Atari 2600 I

00:21:58,400 --> 00:22:05,360
was I also found this inspirational so I

00:22:03,220 --> 00:22:09,250
started calling this the floor is made

00:22:05,360 --> 00:22:13,059
of lava but I haven't added the lava yet

00:22:09,250 --> 00:22:13,059
hey let's look at some games

00:22:17,140 --> 00:22:27,370
I know there's a I think there's a

00:22:24,880 --> 00:22:28,930
two-player mode button oh and it engages

00:22:27,370 --> 00:22:33,070
automatically that's brilliant

00:22:28,930 --> 00:22:34,480
so using two players three player I

00:22:33,070 --> 00:22:37,510
don't know how they're doing that I

00:22:34,480 --> 00:22:40,600
think Stella has a the 2600 emulator has

00:22:37,510 --> 00:22:54,810
a mode where it's a smooths over the

00:22:40,600 --> 00:22:54,810
flicker for you yes

00:23:07,890 --> 00:23:12,060
people also write demos for it just to

00:23:10,740 --> 00:23:21,750
try and show off what they can do with

00:23:12,060 --> 00:23:23,160
the hardware yeah yeah well I mean you

00:23:21,750 --> 00:23:24,600
have to update stuff constantly so it's

00:23:23,160 --> 00:23:28,080
not like you can take your time updating

00:23:24,600 --> 00:23:30,240
it so yeah it's just trying to trying to

00:23:28,080 --> 00:23:49,170
push the thing to us and limit what's

00:23:30,240 --> 00:23:51,150
just stuff like that so oh yeah I should

00:23:49,170 --> 00:23:53,720
I should show you my my stupid game that

00:23:51,150 --> 00:23:53,720
I've been working on

00:24:01,840 --> 00:24:05,180
cuz we're gonna look at a lot of code

00:24:03,680 --> 00:24:09,830
that's the enemy bird he's kind of ugly

00:24:05,180 --> 00:24:11,780
he'll follow us around though so I've

00:24:09,830 --> 00:24:15,440
got these these platforms all the data

00:24:11,780 --> 00:24:18,800
is just on the Y data I'm using about

00:24:15,440 --> 00:24:21,500
hundred bytes of the total memory to

00:24:18,800 --> 00:24:23,240
draw a frame buffer about what color the

00:24:21,500 --> 00:24:24,800
platform is and how wide it is you'll

00:24:23,240 --> 00:24:28,580
never have one piece of platform drawn

00:24:24,800 --> 00:24:31,580
in front of another one because it's

00:24:28,580 --> 00:24:33,020
it'll always be occluded when you go off

00:24:31,580 --> 00:24:35,930
the end of the level it comes back

00:24:33,020 --> 00:24:37,610
around again the thing spends all of the

00:24:35,930 --> 00:24:39,380
time where it's not actually drawing the

00:24:37,610 --> 00:24:44,720
platforms trying to trying to do some

00:24:39,380 --> 00:24:47,600
math don't walk you through that here so

00:24:44,720 --> 00:24:50,360
you can all learn 6502 assembly

00:24:47,600 --> 00:24:52,520
programming you can land on the

00:24:50,360 --> 00:24:54,110
platforms you can bounce off of them you

00:24:52,520 --> 00:24:56,900
can fail to land on them you can hit

00:24:54,110 --> 00:24:58,130
your head on them does I've been serious

00:24:56,900 --> 00:25:00,140
a long time does that make any visual

00:24:58,130 --> 00:25:02,630
sense anyone can you know is there any

00:25:00,140 --> 00:25:04,040
concept of what's going on there how

00:25:02,630 --> 00:25:12,110
does it looked like a music

00:25:04,040 --> 00:25:13,250
visualization thing yeah I would be I

00:25:12,110 --> 00:25:16,190
would be jousting if I have encoded that

00:25:13,250 --> 00:25:17,450
yet so the the first thing that you have

00:25:16,190 --> 00:25:18,650
to do when you implement a game is you

00:25:17,450 --> 00:25:20,210
need to have smooth moment and you can't

00:25:18,650 --> 00:25:21,800
be jumping like Mario really go straight

00:25:20,210 --> 00:25:23,810
up or you go straight on an angle I mean

00:25:21,800 --> 00:25:26,540
the the Atari Mario they fix that for

00:25:23,810 --> 00:25:28,940
the Nintendo so on they have 8-bit sign

00:25:26,540 --> 00:25:31,430
data for speed for Z and Y you have low

00:25:28,940 --> 00:25:32,750
bytes they're basically the fraction and

00:25:31,430 --> 00:25:35,870
decimal part of the number then you have

00:25:32,750 --> 00:25:39,590
whole ones so every frame I add the

00:25:35,870 --> 00:25:41,900
8-bit signed speed into the 8-bit spine

00:25:39,590 --> 00:25:45,020
glow and if it carries and then either

00:25:41,900 --> 00:25:47,210
subtract one or add from playersí same

00:25:45,020 --> 00:25:48,620
thing with Y so I'm moving in two

00:25:47,210 --> 00:25:55,100
dimensions here forward and up and down

00:25:48,620 --> 00:25:57,610
and let me just fix that so you know

00:25:55,100 --> 00:25:57,610
last minute

00:25:59,660 --> 00:26:15,300
last-minute changes to the slides are

00:26:01,920 --> 00:26:16,890
never a good idea it's a terrible font -

00:26:15,300 --> 00:26:18,780
it doesn't even matter if you can you

00:26:16,890 --> 00:26:21,990
can read this but loading the players

00:26:18,780 --> 00:26:24,000
speed branching - - momentum one which

00:26:21,990 --> 00:26:25,530
is here um if it's a negative value this

00:26:24,000 --> 00:26:29,220
handles a negative case that handles the

00:26:25,530 --> 00:26:31,740
positive case clear carry add with carry

00:26:29,220 --> 00:26:33,390
the player's low indexed by X because

00:26:31,740 --> 00:26:34,800
this loops over out the two movable

00:26:33,390 --> 00:26:36,810
objects which is you and the one other

00:26:34,800 --> 00:26:38,490
enemy burn every enemy bird that you add

00:26:36,810 --> 00:26:40,050
takes six bytes of memory which takes

00:26:38,490 --> 00:26:44,250
six lines away from the frame buffer

00:26:40,050 --> 00:26:47,460
display if overflows clear and then it

00:26:44,250 --> 00:26:49,560
exits otherwise it adds one to the

00:26:47,460 --> 00:26:51,120
players X and then it jumps down here

00:26:49,560 --> 00:26:53,040
that's the same thing but it subtracts

00:26:51,120 --> 00:26:54,750
one if it if it overflows the other

00:26:53,040 --> 00:26:58,010
direction so that's that's my

00:26:54,750 --> 00:26:58,010
implementation of momentum

00:27:15,740 --> 00:27:23,360
slightly more readable font so this is a

00:27:18,419 --> 00:27:27,659
this is 3d rotation basically you take

00:27:23,360 --> 00:27:29,399
you take a point in in Cartesian space

00:27:27,659 --> 00:27:31,919
XY coordinates and you convert it to

00:27:29,399 --> 00:27:37,169
polar space and then you convert it back

00:27:31,919 --> 00:27:39,360
again so the 6502 processor does not do

00:27:37,169 --> 00:27:41,039
multiplication the code to do

00:27:39,360 --> 00:27:42,539
multiplication would fill up the screen

00:27:41,039 --> 00:27:46,380
and be worse the last thing that I

00:27:42,539 --> 00:27:48,299
showed you cosine and cosine was at

00:27:46,380 --> 00:27:49,950
listed among the operations when I was

00:27:48,299 --> 00:27:52,230
when I was going through all the

00:27:49,950 --> 00:27:53,940
operations was that in there did anyone

00:27:52,230 --> 00:27:55,860
happen to catch that so I don't do that

00:27:53,940 --> 00:27:57,929
this is a this is the perspective

00:27:55,860 --> 00:28:04,679
function I don't I don't do that either

00:27:57,929 --> 00:28:06,059
I have I have three three main functions

00:28:04,679 --> 00:28:07,830
here and they're not really functions

00:28:06,059 --> 00:28:09,510
because there it's just inline code

00:28:07,830 --> 00:28:10,889
there's no there's no subroutine calls

00:28:09,510 --> 00:28:12,659
and return because that would use two

00:28:10,889 --> 00:28:13,799
bytes a stack memory and I can't spare

00:28:12,659 --> 00:28:16,230
that because I want every byte that I

00:28:13,799 --> 00:28:19,559
can for my stupid frame buffers so I'm

00:28:16,230 --> 00:28:23,429
computing an arc tangent and hypotenuse

00:28:19,559 --> 00:28:27,090
and I'm plotting it on the screen but

00:28:23,429 --> 00:28:28,980
the tables remember the the load

00:28:27,090 --> 00:28:30,960
instruction that indexes by another

00:28:28,980 --> 00:28:32,970
register everything's in tables I

00:28:30,960 --> 00:28:35,039
computed the tables with pearl this is

00:28:32,970 --> 00:28:38,159
pearl use number one this is what the

00:28:35,039 --> 00:28:42,299
table looks like our tangent is adjusted

00:28:38,159 --> 00:28:44,429
by rather than using 360 degrees or

00:28:42,299 --> 00:28:46,080
radians or something like that it's

00:28:44,429 --> 00:28:50,159
restricted to the players view so it's

00:28:46,080 --> 00:28:53,279
just oh and it's it's busted since it's

00:28:50,159 --> 00:28:54,809
a ratio of two different numbers one of

00:28:53,279 --> 00:28:56,250
them goes one direction that goes in the

00:28:54,809 --> 00:28:58,139
other direction this is the high four

00:28:56,250 --> 00:28:59,010
bits that goes this way and the low four

00:28:58,139 --> 00:29:03,409
bits that go that way

00:28:59,010 --> 00:29:06,029
so I take the I take the Delta between

00:29:03,409 --> 00:29:08,549
how far away the the enemy is and how

00:29:06,029 --> 00:29:10,669
much he is up and down take the absolute

00:29:08,549 --> 00:29:13,110
value of those adjust negatives later

00:29:10,669 --> 00:29:14,610
and then make that into one byte and

00:29:13,110 --> 00:29:16,019
then I adjust the address the entire

00:29:14,610 --> 00:29:17,909
table with one byte and then boom

00:29:16,019 --> 00:29:19,679
instantly three cycles later I have the

00:29:17,909 --> 00:29:21,149
arctangent so why should you do a bunch

00:29:19,679 --> 00:29:25,250
of a bunch of math when you can just

00:29:21,149 --> 00:29:25,250
index a table this is

00:29:26,570 --> 00:29:35,550
this is the code that does that it

00:29:29,010 --> 00:29:39,300
combines things together yeah so this is

00:29:35,550 --> 00:29:42,660
on github this is the this is use of

00:29:39,300 --> 00:29:44,640
pearl number two now who thinks it's fun

00:29:42,660 --> 00:29:45,960
to debug 6502 assembly or who thinks

00:29:44,640 --> 00:29:51,930
that sounds like a lot of fun

00:29:45,960 --> 00:29:58,770
I agree but why found really fun was

00:29:51,930 --> 00:30:01,520
acme 6502 first you load the binaries in

00:29:58,770 --> 00:30:04,290
which I just showed you a newbies been

00:30:01,520 --> 00:30:06,810
using the CPU load from after I create

00:30:04,290 --> 00:30:09,740
my CPU object if Acme as you travel to

00:30:06,810 --> 00:30:13,650
new and then I run it with this callback

00:30:09,740 --> 00:30:16,560
every time I get the callback I look at

00:30:13,650 --> 00:30:19,110
my and I have the symbols module that

00:30:16,560 --> 00:30:21,330
parses the assembler output the

00:30:19,110 --> 00:30:23,940
assembler listing from when you assemble

00:30:21,330 --> 00:30:26,820
the the code you you compile it from the

00:30:23,940 --> 00:30:28,410
text into the actual binary in the

00:30:26,820 --> 00:30:29,940
simplest onblur format it tells you the

00:30:28,410 --> 00:30:32,760
memory address of everything that you've

00:30:29,940 --> 00:30:34,320
declared so I parse that and I have an

00:30:32,760 --> 00:30:37,590
object that knows where everything is

00:30:34,320 --> 00:30:39,360
and then when the process or the where

00:30:37,590 --> 00:30:40,860
the processor makes it to the program

00:30:39,360 --> 00:30:42,330
counter in the processor which is a

00:30:40,860 --> 00:30:44,460
current instruction that's executing

00:30:42,330 --> 00:30:50,550
hits where I want it to and then I use

00:30:44,460 --> 00:30:54,960
Pat Walker to go into Acme's X me 6500

00:30:50,550 --> 00:30:56,970
twos internal variable IC and set it to

00:30:54,960 --> 00:30:58,710
0 so it doesn't iterate anymore and

00:30:56,970 --> 00:31:00,390
stops iteration and exits back out I

00:30:58,710 --> 00:31:04,230
could have done that would die too but I

00:31:00,390 --> 00:31:06,960
did it that way and then I pick out of

00:31:04,230 --> 00:31:09,420
memory the view address wherever that is

00:31:06,960 --> 00:31:11,910
I compute the size of you view is my

00:31:09,420 --> 00:31:16,920
little frame buffer of things and then I

00:31:11,910 --> 00:31:19,080
can run tests like I can write into the

00:31:16,920 --> 00:31:23,580
current platform and the last line that

00:31:19,080 --> 00:31:25,530
it rendered I'm using FF as negative the

00:31:23,580 --> 00:31:27,720
expected width of the platform I can

00:31:25,530 --> 00:31:30,630
compute using the perspective table on

00:31:27,720 --> 00:31:32,310
the expected color I can read data for

00:31:30,630 --> 00:31:34,890
level 0 and find out what the color is

00:31:32,310 --> 00:31:36,640
supposed to be for level 0 I can

00:31:34,890 --> 00:31:40,000
position the player somewhere

00:31:36,640 --> 00:31:42,790
I can check that the line is blank run

00:31:40,000 --> 00:31:45,550
the CPU and then I access memory again

00:31:42,790 --> 00:31:47,830
use CPU read 8 to read 8 bits of data

00:31:45,550 --> 00:31:49,660
and make sure that the line the upper 3

00:31:47,830 --> 00:31:52,180
bits of every of all of my frame buffer

00:31:49,660 --> 00:31:53,860
data tells the color to draw the lower 5

00:31:52,180 --> 00:31:55,990
bits as the width of the line to draw

00:31:53,860 --> 00:31:57,880
there so all of that beautiful flying

00:31:55,990 --> 00:31:59,710
around and that gorgeous 3d universe is

00:31:57,880 --> 00:32:03,900
just each line eight bits of data a

00:31:59,710 --> 00:32:10,450
platform width and platform color so

00:32:03,900 --> 00:32:12,640
enemy enemy bird is enemy bird is the

00:32:10,450 --> 00:32:15,130
hypotenuse of this right triangle away

00:32:12,640 --> 00:32:23,880
from the distance of up and down and

00:32:15,130 --> 00:32:23,880
distance left's and right does it matter

00:32:25,170 --> 00:32:31,990
more unit tests just making sure that I

00:32:29,760 --> 00:32:34,840
render a line I have no idea what's

00:32:31,990 --> 00:32:39,760
going on so yeah I can tell it to render

00:32:34,840 --> 00:32:41,080
a line and then I set with the deltas

00:32:39,760 --> 00:32:46,420
and I make sure that the value that

00:32:41,080 --> 00:32:54,660
comes back out from computing yeah

00:32:46,420 --> 00:32:58,270
nobody'll I can't read this can you 1 1

00:32:54,660 --> 00:33:00,280
so when you're when you're drawing

00:32:58,270 --> 00:33:02,380
things left to right on the screen you

00:33:00,280 --> 00:33:04,090
you can't you the processor runs

00:33:02,380 --> 00:33:06,340
everything so you can't just run

00:33:04,090 --> 00:33:08,350
functions so you have to constantly

00:33:06,340 --> 00:33:10,540
check that you don't need to be doing

00:33:08,350 --> 00:33:12,100
something and in this case you have 64

00:33:10,540 --> 00:33:14,560
cycles between that when you're using

00:33:12,100 --> 00:33:16,720
one of the built-in timers so this is my

00:33:14,560 --> 00:33:18,760
drawing code there's two different

00:33:16,720 --> 00:33:22,270
versions I haven't unrolled going up and

00:33:18,760 --> 00:33:24,520
going down I can load the data that's

00:33:22,270 --> 00:33:26,260
currently in the frame buffer pull off

00:33:24,520 --> 00:33:28,120
the bottom 5 bits make sure that what

00:33:26,260 --> 00:33:32,440
I'm drawing is wider than that if not I

00:33:28,120 --> 00:33:33,730
skip it otherwise I stuff the new data

00:33:32,440 --> 00:33:36,730
back in there the color and the new

00:33:33,730 --> 00:33:39,400
width and then before I do anything else

00:33:36,730 --> 00:33:41,950
I load the hardware timer make sure that

00:33:39,400 --> 00:33:44,110
it's not 0 if it is 0 and then I have

00:33:41,950 --> 00:33:45,970
this macro here the the assembler lets

00:33:44,110 --> 00:33:47,640
you reuse pieces of code and just stuff

00:33:45,970 --> 00:33:50,490
them go straight in just macro

00:33:47,640 --> 00:33:52,860
engine so I handled vertical sink logic

00:33:50,490 --> 00:33:56,730
inline in this loop and then branch back

00:33:52,860 --> 00:33:59,220
up to the top there's three different

00:33:56,730 --> 00:34:01,410
times I get to set the timer so that's

00:33:59,220 --> 00:34:03,030
tedious having to having to make sure

00:34:01,410 --> 00:34:05,520
that you're not running out of time all

00:34:03,030 --> 00:34:18,030
the time so obviously what you want to

00:34:05,520 --> 00:34:20,360
do so obviously what you want to do is

00:34:18,030 --> 00:34:20,360
right

00:34:32,090 --> 00:34:41,150
that's right unit tests so I have a

00:34:39,020 --> 00:34:43,730
table of how long each instruction takes

00:34:41,150 --> 00:34:46,040
and in my call back from Acme says if I

00:34:43,730 --> 00:34:47,780
went to CPU I can keep a tally and I can

00:34:46,040 --> 00:34:49,700
return the tally so I know how much CPU

00:34:47,780 --> 00:34:51,290
time I have available so I can write

00:34:49,700 --> 00:34:54,770
unit tests for my cc well code to code

00:34:51,290 --> 00:34:56,480
code make sure I don't go over if the

00:34:54,770 --> 00:34:58,280
number of cycles used is less than

00:34:56,480 --> 00:35:02,690
available the test passes and everyone's

00:34:58,280 --> 00:35:04,310
happy but unfortunately one of the

00:35:02,690 --> 00:35:06,710
limitations of Acme cpa-52 is it just

00:35:04,310 --> 00:35:08,510
provides Ram it doesn't provide Hardware

00:35:06,710 --> 00:35:10,490
doesn't have support for hardware

00:35:08,510 --> 00:35:12,260
emulation hooks so sorry I've mapped i/o

00:35:10,490 --> 00:35:17,030
is is out of the question if someone

00:35:12,260 --> 00:35:20,390
fixes it so I'm here we have package

00:35:17,030 --> 00:35:22,340
registered Tim 64 T which is the 64

00:35:20,390 --> 00:35:24,920
clock timer every time CC for clocks

00:35:22,340 --> 00:35:30,230
pass it counts down Wanek you can start

00:35:24,920 --> 00:35:35,350
it up to 255 and it goes down so we've

00:35:30,230 --> 00:35:38,210
got this global variable here cycles and

00:35:35,350 --> 00:35:41,060
in the the cpu callback I continue to

00:35:38,210 --> 00:35:44,060
increment that so I have this

00:35:41,060 --> 00:35:47,960
implementation of a tied scaler when you

00:35:44,060 --> 00:35:49,940
store a value to it the 60/40 it sets

00:35:47,960 --> 00:35:52,550
that many cycles left when you read int

00:35:49,940 --> 00:35:54,890
I am which tells you how many chunks of

00:35:52,550 --> 00:35:56,750
64 cycles you have left computes that it

00:35:54,890 --> 00:35:58,820
returns it and then I just tie those

00:35:56,750 --> 00:36:01,250
into acting to see if I have a to s

00:35:58,820 --> 00:36:04,220
object in the memory array at the

00:36:01,250 --> 00:36:07,040
location according to the assembler

00:36:04,220 --> 00:36:09,290
listing that's supposed to be at provide

00:36:07,040 --> 00:36:13,280
that class name if you're not familiar

00:36:09,290 --> 00:36:15,680
with pearls tied interface that lets you

00:36:13,280 --> 00:36:17,300
I'm run logic when you read from a

00:36:15,680 --> 00:36:20,570
variable or write from a variable in

00:36:17,300 --> 00:36:25,280
Acme 6502 s memory spaces just implement

00:36:20,570 --> 00:36:27,820
it as an array of scalars and then I can

00:36:25,280 --> 00:36:31,840
write a unit test that

00:36:27,820 --> 00:36:35,830
I can write a unit test that makes sure

00:36:31,840 --> 00:36:37,330
that I did not run out of time and I ran

00:36:35,830 --> 00:36:44,650
out of time I'm gonna run out of

00:36:37,330 --> 00:36:50,050
something okay in this case they ran out

00:36:44,650 --> 00:36:52,600
of a that address so this is the the

00:36:50,050 --> 00:36:57,550
display Colonel when when we're in this

00:36:52,600 --> 00:36:58,990
box that looks like right here we're

00:36:57,550 --> 00:37:00,640
actually drawing there's some time

00:36:58,990 --> 00:37:02,730
before the scan line gets to the visible

00:37:00,640 --> 00:37:06,100
picture area and then it goes back again

00:37:02,730 --> 00:37:10,510
and then there's time where it's not

00:37:06,100 --> 00:37:13,810
drawing so you have to count cycles then

00:37:10,510 --> 00:37:19,390
too so I know I know I need to burn

00:37:13,810 --> 00:37:21,490
exactly 76 cycles so you have to add up

00:37:19,390 --> 00:37:26,560
all of your instructions this is what it

00:37:21,490 --> 00:37:31,690
winds up looking like I update the color

00:37:26,560 --> 00:37:32,980
of the foreground I load from a table of

00:37:31,690 --> 00:37:36,070
background colors stored in the

00:37:32,980 --> 00:37:38,410
background I do a look-up on the three

00:37:36,070 --> 00:37:39,850
different registers are from three

00:37:38,410 --> 00:37:42,220
different tables that give me data for

00:37:39,850 --> 00:37:43,600
the three different registers for the

00:37:42,220 --> 00:37:48,580
background pattern data that gets

00:37:43,600 --> 00:37:50,260
reflected I figure out which scan I load

00:37:48,580 --> 00:37:53,920
the scan line into the wide register

00:37:50,260 --> 00:37:55,480
load both an X with my frame buffer so

00:37:53,920 --> 00:37:59,290
get the current line of frame buffer for

00:37:55,480 --> 00:38:02,080
that get the platform color given that I

00:37:59,290 --> 00:38:03,490
use the entire eight bits of data I just

00:38:02,080 --> 00:38:05,890
have replicated stuff in there that

00:38:03,490 --> 00:38:07,960
tells me what color the the platform is

00:38:05,890 --> 00:38:09,310
supposed to be there's a special color

00:38:07,960 --> 00:38:11,050
that indicates that I need to draw the

00:38:09,310 --> 00:38:12,040
enemy sprite I go off and do that in

00:38:11,050 --> 00:38:14,890
different direction if that's what

00:38:12,040 --> 00:38:25,210
happens otherwise I pick off the bottom

00:38:14,890 --> 00:38:28,690
five bits use a fetch the scan line add

00:38:25,210 --> 00:38:29,950
in whatever sky I actually have some no

00:38:28,690 --> 00:38:31,720
op instruction so I can waste some time

00:38:29,950 --> 00:38:34,320
ding from at the scan line if it's still

00:38:31,720 --> 00:38:38,740
positive I go back and do it again so

00:38:34,320 --> 00:38:41,560
the idea is you you don't want to update

00:38:38,740 --> 00:38:43,480
any registers both the pictures being

00:38:41,560 --> 00:38:46,060
unless you wanted to change at that

00:38:43,480 --> 00:38:48,280
point if you update it halfway through

00:38:46,060 --> 00:38:49,780
it being drawn you'll flicker so I

00:38:48,280 --> 00:38:53,260
update most of the registers before

00:38:49,780 --> 00:38:54,580
stuffs being drawn and then compute what

00:38:53,260 --> 00:38:59,980
it's going to be and save away our

00:38:54,580 --> 00:39:08,200
registers in the in the meantime here's

00:38:59,980 --> 00:39:10,390
some now every year a couple of homebrew

00:39:08,200 --> 00:39:12,160
comes out and people have done just some

00:39:10,390 --> 00:39:14,710
really amazing things with the Atari

00:39:12,160 --> 00:39:17,230
2600 and this is one of the things that

00:39:14,710 --> 00:39:19,900
someone did it's some so when you have a

00:39:17,230 --> 00:39:23,440
processor and it's running program out

00:39:19,900 --> 00:39:25,180
of ROM the the general operation is it

00:39:23,440 --> 00:39:26,620
fetches the next byte of instruction and

00:39:25,180 --> 00:39:29,500
if the instruction tells it to fetch

00:39:26,620 --> 00:39:32,110
memory from the ROM it reads it from the

00:39:29,500 --> 00:39:33,340
ROM and then it maybe reads another

00:39:32,110 --> 00:39:36,850
instruction that tells it to store

00:39:33,340 --> 00:39:39,880
somewhere so some very clever chap had

00:39:36,850 --> 00:39:43,030
the idea that when the processor is

00:39:39,880 --> 00:39:47,050
storing zeros on the boss to some

00:39:43,030 --> 00:39:49,390
certain address you don't necessarily

00:39:47,050 --> 00:39:52,900
have to have ROM in your ROM you can

00:39:49,390 --> 00:39:55,210
have logic that manipulates the bus so

00:39:52,900 --> 00:39:56,380
you have your 6502 which is doing its to

00:39:55,210 --> 00:39:58,330
see if I have a two thing but you also

00:39:56,380 --> 00:39:59,410
have another processor some other

00:39:58,330 --> 00:40:01,210
hardware and actually this goes back to

00:39:59,410 --> 00:40:05,020
pitfall pitfall had a simple version of

00:40:01,210 --> 00:40:06,670
this in it so why your your thing is

00:40:05,020 --> 00:40:07,990
sitting here making reads and writes to

00:40:06,670 --> 00:40:09,880
memory this thing is interfering with a

00:40:07,990 --> 00:40:12,220
bus and it's stuffing different data on

00:40:09,880 --> 00:40:13,960
the bus if you're just doing a load 0

00:40:12,220 --> 00:40:15,490
you can pull from tables or you can

00:40:13,960 --> 00:40:17,620
compute different values or it can

00:40:15,490 --> 00:40:20,290
whatever it's thing has an ARM processor

00:40:17,620 --> 00:40:21,580
in it so you can double the amount of

00:40:20,290 --> 00:40:23,820
stuff that you're able to get on one

00:40:21,580 --> 00:40:23,820
line

00:40:30,990 --> 00:40:38,110
the yeah I think I've think I've got

00:40:36,490 --> 00:40:42,990
some somewhere how am i doing on time

00:40:38,110 --> 00:40:42,990
here awesome Wow

00:41:01,420 --> 00:41:04,809
that's actually

00:41:31,070 --> 00:41:34,070
yeah

00:41:52,910 --> 00:41:57,630
so that's that's pushing data through

00:41:55,320 --> 00:42:00,120
the Atari 2600 bus twice as fast as it

00:41:57,630 --> 00:42:02,070
was just the 6502 loading from ROM if it

00:42:00,120 --> 00:42:05,340
loads zero and just saves two different

00:42:02,070 --> 00:42:07,080
addresses and this cartridge magically

00:42:05,340 --> 00:42:09,750
stuffs the correct data on the bus to

00:42:07,080 --> 00:42:12,990
update the registers rather than doing a

00:42:09,750 --> 00:42:14,550
six cycle load and a three cycle load

00:42:12,990 --> 00:42:16,800
and a three cycle store you just keep

00:42:14,550 --> 00:42:18,000
doing a three cycle store over again you

00:42:16,800 --> 00:42:20,010
just have to store to the correct

00:42:18,000 --> 00:42:21,900
address and then boom the right data

00:42:20,010 --> 00:42:24,530
magically appears out of nowhere and

00:42:21,900 --> 00:42:24,530
goes to that address

00:42:50,339 --> 00:42:56,519
so I'll leave you guys one last thing if

00:42:54,209 --> 00:43:00,079
I can find it really should have been a

00:42:56,519 --> 00:43:00,079
slide since I have a little extra time

00:43:17,220 --> 00:43:21,850
deal with me it was supposed to be a

00:43:19,090 --> 00:43:23,050
reference to counting your cycles and

00:43:21,850 --> 00:43:25,230
trying to figure out exactly what you

00:43:23,050 --> 00:43:25,230
had

00:43:41,549 --> 00:43:47,659
yeah it's a 52% somberly and 38% pearl

00:43:48,229 --> 00:43:56,489
I'll show you my my unit tests here

00:43:51,659 --> 00:43:58,169
there's a lot of them so I'm sure you

00:43:56,489 --> 00:44:00,569
guys thought that this is what I was

00:43:58,169 --> 00:44:05,459
gonna present here just reporting pearl

00:44:00,569 --> 00:44:09,659
to the the 2600 I mean you know you want

00:44:05,459 --> 00:44:18,390
that right and it would be kind of cool

00:44:09,659 --> 00:44:21,029
right so like if we have um my J equals

00:44:18,390 --> 00:44:24,390
0 for I equals 1 to 10 my k equals not

00:44:21,029 --> 00:44:27,149
IJ plus equals okay and then you'd be

00:44:24,390 --> 00:44:29,699
able to like turn that into 6502

00:44:27,149 --> 00:44:33,169
assembly or you load a sword and zero

00:44:29,699 --> 00:44:35,309
load once to get an i increment i load i

00:44:33,169 --> 00:44:37,859
know i'm not gonna write something that

00:44:35,309 --> 00:44:41,279
translates pearl des 65 to assembly

00:44:37,859 --> 00:44:43,019
that's crazy so if anyone wants to kick

00:44:41,279 --> 00:44:46,889
starter this ola I'll finish it and I'll

00:44:43,019 --> 00:44:48,749
start implementing Rex's and maybe some

00:44:46,889 --> 00:44:48,959
file i/o I'm not sure how that would

00:44:48,749 --> 00:44:52,289
work

00:44:48,959 --> 00:44:54,089
I'm so one cool NIT the joystick ports

00:44:52,289 --> 00:44:59,399
are bidirectionally and set rather

00:44:54,089 --> 00:45:01,469
data's coming in or coming out it's also

00:44:59,399 --> 00:45:03,029
the first CD system they are they sold

00:45:01,469 --> 00:45:06,599
this thing at loaded games from tapes

00:45:03,029 --> 00:45:08,729
but then they then they released they

00:45:06,599 --> 00:45:12,829
resolved them on a CD so maybe that

00:45:08,729 --> 00:45:15,449
makes it the world's first CD system so

00:45:12,829 --> 00:45:25,999
is there anything that can be clarified

00:45:15,449 --> 00:45:25,999
from that user Oh three minutes anyone

00:45:27,670 --> 00:45:53,870
the notes on the slide oh yeah I just

00:45:35,020 --> 00:46:00,800
yeah I just you roam on there besides

00:45:53,870 --> 00:46:03,530
the besides the pro Pilar yeah of course

00:46:00,800 --> 00:46:06,530
well obviously I mean most people

00:46:03,530 --> 00:46:09,170
program the thing in the most people

00:46:06,530 --> 00:46:10,430
program the thing in basic why are you

00:46:09,170 --> 00:46:25,330
guys sitting through an assembly class

00:46:10,430 --> 00:46:25,330
oh yeah so um well

00:46:33,430 --> 00:46:57,920
if you wanted to write portal and it

00:46:36,380 --> 00:47:02,140
might listen to like VI that's a pretty

00:46:57,920 --> 00:47:02,140
standard X term so yeah someone made a

00:47:03,730 --> 00:47:10,460
someone made a a beta a little basic

00:47:06,440 --> 00:47:13,339
interpret compiler that lets you draw

00:47:10,460 --> 00:47:15,319
the play fields out and use if levels

00:47:13,339 --> 00:47:18,579
greater than four and stuff like that so

00:47:15,319 --> 00:47:18,579
if someone totally

00:47:48,819 --> 00:47:59,990
thank you you're a little bit illicit

00:47:57,289 --> 00:48:01,700
here alright well thank you for thank

00:47:59,990 --> 00:48:02,900
you for enduring an extremely hurried

00:48:01,700 --> 00:48:04,640
introduction to assembly language

00:48:02,900 --> 00:48:06,230
program they included me rattling off

00:48:04,640 --> 00:48:08,380
the names of instructions as quickly as

00:48:06,230 --> 00:48:08,380

YouTube URL: https://www.youtube.com/watch?v=Ulcq0pVlQ1c


