Title: Daina Pettit - Streamlining and simplifying your Perl code using Map, Grep, and Sort
Publication date: 2014-06-23
Playlist: YAPC::NA 2014
Description: 
	Map, Grep, and Sort are powerful Perl built-in functions that can simplify your code and improve performance.

New Perl users often skip learning about these three functions because they are considered an advanced topic and may not use them to their full advantage when they do use them. Experienced Perl users exploit these functions in amazing ways, but often the result is a confusing mess of unreadable and thus unmaintainable code. Refactoring existing code into these functions where appropriate can significantly improve the quality of the code *and* improve performance as well.

This talk will present how to take advantage of these powerful functions and have the resulting code understandable.
Captions: 
	00:00:02,510 --> 00:00:08,429
ok it's 5 o'clock time for this session

00:00:05,370 --> 00:00:13,590
to start welcome everyone my name is

00:00:08,429 --> 00:00:15,059
Dana Pettit I work for Bluehost we're

00:00:13,590 --> 00:00:17,789
gonna be covering streamlining and

00:00:15,059 --> 00:00:20,550
simplifying your Perl code using map

00:00:17,789 --> 00:00:22,439
grep and sort this is normally a bit

00:00:20,550 --> 00:00:23,699
longer presentation than we have here so

00:00:22,439 --> 00:00:24,240
I'm going to be shortening things up a

00:00:23,699 --> 00:00:25,980
little bit

00:00:24,240 --> 00:00:27,900
so if we feel a little rushed that's

00:00:25,980 --> 00:00:30,949
normal but if you have questions please

00:00:27,900 --> 00:00:34,200
raise your hand and I'll cover things

00:00:30,949 --> 00:00:36,030
here at Yap see we actually see this

00:00:34,200 --> 00:00:38,520
statement coming true from Larry wall

00:00:36,030 --> 00:00:42,690
that we sometimes seem to be kind of a

00:00:38,520 --> 00:00:44,070
perl cult let's go ahead and see what

00:00:42,690 --> 00:00:44,789
we're going to be talking about we're

00:00:44,070 --> 00:00:45,930
gonna talk about some of the

00:00:44,789 --> 00:00:47,640
prerequisites what you need to know

00:00:45,930 --> 00:00:49,800
before you'll understand the

00:00:47,640 --> 00:00:51,600
presentation if you don't understand

00:00:49,800 --> 00:00:53,430
those things you're gonna be missing out

00:00:51,600 --> 00:00:56,280
on some of the material we're gonna go

00:00:53,430 --> 00:00:58,710
out what Map grep and sword are we're

00:00:56,280 --> 00:01:01,920
gonna show how do you use map how did

00:00:58,710 --> 00:01:03,660
you use grep how to use sort and then if

00:01:01,920 --> 00:01:05,610
we have some time we'll go into

00:01:03,660 --> 00:01:08,729
combining them and doing some fun things

00:01:05,610 --> 00:01:12,840
like some optimized sorts with like the

00:01:08,729 --> 00:01:13,950
schwartzie and transform and so on so

00:01:12,840 --> 00:01:16,409
here's the prerequisite so if you

00:01:13,950 --> 00:01:20,009
understand all this Perl code you'll be

00:01:16,409 --> 00:01:22,439
fine so things like initializing an

00:01:20,009 --> 00:01:25,170
array indexing into a single element of

00:01:22,439 --> 00:01:30,900
the array indexing into a single element

00:01:25,170 --> 00:01:34,170
of a hash using split using a for each

00:01:30,900 --> 00:01:36,060
and notice that we have a default on for

00:01:34,170 --> 00:01:39,799
each that we don't specify what we're

00:01:36,060 --> 00:01:39,799
printing so it prints dollar underscore

00:01:40,549 --> 00:01:47,610
using the ternary operator the question

00:01:44,130 --> 00:01:52,530
mark : if you understand that we're good

00:01:47,610 --> 00:01:55,619
and using the verdict to double vertical

00:01:52,530 --> 00:01:57,420
bars which is an or with an equal so

00:01:55,619 --> 00:02:01,979
it's the same as dollar C equals dollar

00:01:57,420 --> 00:02:04,079
Z or empty string if you understand that

00:02:01,979 --> 00:02:05,549
you're good so map grep and sort or

00:02:04,079 --> 00:02:09,989
merely iterator functions that allow us

00:02:05,549 --> 00:02:11,940
to operate on lists the syntax is

00:02:09,989 --> 00:02:13,520
actually very similar for them map

00:02:11,940 --> 00:02:17,450
performs an action on

00:02:13,520 --> 00:02:21,320
element grep tests each element and sort

00:02:17,450 --> 00:02:23,330
reorders the elements so here's the

00:02:21,320 --> 00:02:25,670
general syntax freeze and they see how

00:02:23,330 --> 00:02:27,050
very similar they look there's a little

00:02:25,670 --> 00:02:28,610
difference here when we get to sort and

00:02:27,050 --> 00:02:30,110
we'll talk about that when get into sort

00:02:28,610 --> 00:02:31,790
but the basic idea is they look very

00:02:30,110 --> 00:02:34,100
similar that's why we've grouped them

00:02:31,790 --> 00:02:36,220
together in this hour or this these

00:02:34,100 --> 00:02:38,480
twenty minutes

00:02:36,220 --> 00:02:42,170
so the general form is that we use a

00:02:38,480 --> 00:02:45,920
code block on most of these so code

00:02:42,170 --> 00:02:48,200
block is just the two curly braces with

00:02:45,920 --> 00:02:51,350
some code in there some Perl code that

00:02:48,200 --> 00:02:56,060
tells map and grep and sort how to do

00:02:51,350 --> 00:02:59,300
things damian conway recommends always

00:02:56,060 --> 00:03:01,520
using a block with map and sort will see

00:02:59,300 --> 00:03:02,930
examples of using it and not using it

00:03:01,520 --> 00:03:05,030
and there are some reasons why you would

00:03:02,930 --> 00:03:07,520
want to use it and there's reasons why

00:03:05,030 --> 00:03:10,190
you would not want to use it there is a

00:03:07,520 --> 00:03:12,860
slight penalty for using a block form

00:03:10,190 --> 00:03:15,860
and that is because it has it gives you

00:03:12,860 --> 00:03:17,300
some extra scoping so perl has to set

00:03:15,860 --> 00:03:18,710
that up so if you're having if you want

00:03:17,300 --> 00:03:21,740
to just shave a little bit of time off

00:03:18,710 --> 00:03:26,990
of your your perl code you can remove

00:03:21,740 --> 00:03:29,060
the block and the reason why Damien

00:03:26,990 --> 00:03:32,740
suggests using the block is because it

00:03:29,060 --> 00:03:36,170
helps you from keep from stumbling and

00:03:32,740 --> 00:03:38,000
accidentally having your syntax wrong

00:03:36,170 --> 00:03:40,610
and if you have played with this much

00:03:38,000 --> 00:03:44,390
you will have run into that problem so

00:03:40,610 --> 00:03:45,980
let's dig into map map is kind of like a

00:03:44,390 --> 00:03:47,570
for each if you understand a for each

00:03:45,980 --> 00:03:48,770
you set for each as goes through a list

00:03:47,570 --> 00:03:51,950
and then you do something for each

00:03:48,770 --> 00:03:54,050
element of the list so here we have an

00:03:51,950 --> 00:03:55,370
example of a simple for each that we're

00:03:54,050 --> 00:03:57,950
going to show you how a map would do the

00:03:55,370 --> 00:04:00,200
same exact same thing with us a map

00:03:57,950 --> 00:04:03,530
syntax so here we have you see which

00:04:00,200 --> 00:04:06,050
takes a string up cases it forces it all

00:04:03,530 --> 00:04:08,720
that per case so we see up case line and

00:04:06,050 --> 00:04:09,590
then put that back into line so we're

00:04:08,720 --> 00:04:11,209
going through when we were taking that

00:04:09,590 --> 00:04:14,540
array and face it basically forcing

00:04:11,209 --> 00:04:18,109
everything to uppercase so to do that

00:04:14,540 --> 00:04:21,260
with map all we have to do is say lines

00:04:18,109 --> 00:04:22,960
equals map upper case and give it the

00:04:21,260 --> 00:04:26,390
list

00:04:22,960 --> 00:04:28,280
so they'll simpler than a 4h here we're

00:04:26,390 --> 00:04:29,480
using it without the block notation so

00:04:28,280 --> 00:04:33,350
it'll be a little bit more efficient

00:04:29,480 --> 00:04:42,430
there's an alternate form using the

00:04:33,350 --> 00:04:42,430
block those are all equivalent lines

00:04:46,150 --> 00:04:53,740
now one thing that's interesting is we

00:04:48,250 --> 00:04:54,970
have this map you see outlines we can

00:04:53,740 --> 00:04:57,370
get a for each that actually does the

00:04:54,970 --> 00:05:01,900
same thing that's what we call an inside

00:04:57,370 --> 00:05:05,380
out for each in this form some of you

00:05:01,900 --> 00:05:07,120
may have not seen this before its

00:05:05,380 --> 00:05:09,250
equivalent to the map because what we're

00:05:07,120 --> 00:05:12,870
doing is they're saying for each element

00:05:09,250 --> 00:05:15,280
in the at lines array do the uppercase

00:05:12,870 --> 00:05:17,169
assigning it to dollar underscore and

00:05:15,280 --> 00:05:22,419
it'll use what is in dollar underscore

00:05:17,169 --> 00:05:25,539
two up case I'm not a big fan of the

00:05:22,419 --> 00:05:27,520
inside out because reading it it looks a

00:05:25,539 --> 00:05:29,320
little funny and you're reading through

00:05:27,520 --> 00:05:31,990
Ewing okay dollars to underscore equals

00:05:29,320 --> 00:05:35,410
up case what and then you go up there

00:05:31,990 --> 00:05:37,000
doing the inside out for each but it has

00:05:35,410 --> 00:05:46,539
some efficiencies it's actually faster

00:05:37,000 --> 00:05:48,639
than the map so here's the normal right

00:05:46,539 --> 00:05:50,560
side out for each that does the exact

00:05:48,639 --> 00:05:52,389
same thing but it's a little bit slower

00:05:50,560 --> 00:05:54,970
than the inside out version because we

00:05:52,389 --> 00:05:57,960
have to introduce that code block that

00:05:54,970 --> 00:05:57,960
gives us some scoping

00:06:10,540 --> 00:06:15,430
so you're saying a looping variable here

00:06:18,190 --> 00:06:23,000
if you're adding a looping variable

00:06:20,600 --> 00:06:26,240
you're actually just replacing what's in

00:06:23,000 --> 00:06:28,220
the default dollar underscore I I'm not

00:06:26,240 --> 00:06:30,170
sure the performance difference between

00:06:28,220 --> 00:06:32,780
using that and dollar underscore it's

00:06:30,170 --> 00:06:35,660
that's something I haven't tested it's

00:06:32,780 --> 00:06:39,800
fairly easy to do there's a lot of ways

00:06:35,660 --> 00:06:42,080
to check that but the the inside out

00:06:39,800 --> 00:06:48,920
form is the fastest of these three three

00:06:42,080 --> 00:06:52,040
versions it's generally accepted that

00:06:48,920 --> 00:06:52,730
map is is really best at creating new

00:06:52,040 --> 00:06:55,610
lists

00:06:52,730 --> 00:07:01,550
whereas 4-h is best for transforming a

00:06:55,610 --> 00:07:03,050
list but you can use them either way so

00:07:01,550 --> 00:07:04,550
just be aware that you have that option

00:07:03,050 --> 00:07:06,500
to go either way but generally speaking

00:07:04,550 --> 00:07:10,870
map will be best for creating new list

00:07:06,500 --> 00:07:10,870
for each is best for transforming a list

00:07:11,440 --> 00:07:16,970
now an example of using a map where you

00:07:14,420 --> 00:07:18,470
might have thought of using a 4h before

00:07:16,970 --> 00:07:21,110
is where you're doing something like

00:07:18,470 --> 00:07:24,260
this where you're dumping out individual

00:07:21,110 --> 00:07:26,240
paired elements of a hash you've

00:07:24,260 --> 00:07:27,650
probably seen this syntax before where

00:07:26,240 --> 00:07:30,440
you loop through and print out the hash

00:07:27,650 --> 00:07:33,220
key and value you can do the exact same

00:07:30,440 --> 00:07:33,220
thing in a map

00:07:37,920 --> 00:07:42,080
you can also do it inside out

00:07:46,300 --> 00:07:52,220
generally map in void context like this

00:07:50,210 --> 00:07:53,360
is kind of frowned upon because what

00:07:52,220 --> 00:07:55,040
you're doing is you're creating a list

00:07:53,360 --> 00:08:02,810
and that you're not then you're not

00:07:55,040 --> 00:08:05,840
using it now one of the little gotchas

00:08:02,810 --> 00:08:11,540
with map is that the the code block in

00:08:05,840 --> 00:08:15,560
map evaluates in list context so if you

00:08:11,540 --> 00:08:17,990
do a call like this to local time local

00:08:15,560 --> 00:08:21,110
time returns a nice pretty string with

00:08:17,990 --> 00:08:23,270
the date in it the date and time if you

00:08:21,110 --> 00:08:25,220
call it in scalar context but if you

00:08:23,270 --> 00:08:29,210
call it in list context it returns an

00:08:25,220 --> 00:08:30,280
array of numbers that correspond to the

00:08:29,210 --> 00:08:35,960
current date and time

00:08:30,280 --> 00:08:38,570
and because map evaluates the block in

00:08:35,960 --> 00:08:41,510
in list context you're going to get a

00:08:38,570 --> 00:08:43,280
bunch of numbers and so your dates array

00:08:41,510 --> 00:08:43,969
is going to be probably not what you

00:08:43,280 --> 00:08:47,630
intended

00:08:43,969 --> 00:08:52,430
Damien Conway recommends always using

00:08:47,630 --> 00:08:58,730
scalar in your map expressions so you do

00:08:52,430 --> 00:09:03,890
it like this however there are times

00:08:58,730 --> 00:09:05,390
where you want that list context so if

00:09:03,890 --> 00:09:08,240
we say if we're trying to get all the

00:09:05,390 --> 00:09:10,640
words out of a bunch of strings like we

00:09:08,240 --> 00:09:12,410
slurp us a file in to an array and then

00:09:10,640 --> 00:09:13,850
we want to get all the words there we're

00:09:12,410 --> 00:09:16,730
gonna be splitting them and then just

00:09:13,850 --> 00:09:19,160
putting them to an array if we use a

00:09:16,730 --> 00:09:22,490
scalar on that we're not going to get

00:09:19,160 --> 00:09:24,440
what we expect because a scalar is going

00:09:22,490 --> 00:09:27,260
to give us the number of elements not

00:09:24,440 --> 00:09:29,780
the actual elements so in that case we

00:09:27,260 --> 00:09:32,920
actually want to drop the scalar and let

00:09:29,780 --> 00:09:32,920
it be in list context

00:09:36,500 --> 00:09:44,010
some of you may have worked with other

00:09:38,610 --> 00:09:46,460
people's map code and seen a plus on the

00:09:44,010 --> 00:09:49,590
code block and go what is going on here

00:09:46,460 --> 00:09:51,570
well map can get confused if it doesn't

00:09:49,590 --> 00:09:53,670
know what it is whether it's a partial

00:09:51,570 --> 00:09:56,460
hash that you're giving it or if it's

00:09:53,670 --> 00:09:58,920
your if you're actually giving it a code

00:09:56,460 --> 00:10:00,900
block so you can force it to recognize

00:09:58,920 --> 00:10:02,580
that as a hash by putting the plus on

00:10:00,900 --> 00:10:04,050
there so that's what that's all about

00:10:02,580 --> 00:10:05,730
and this is something you can play with

00:10:04,050 --> 00:10:08,779
you can add a plus and take out the plus

00:10:05,730 --> 00:10:11,180
out and see what difference it makes

00:10:08,779 --> 00:10:13,680
just something to watch out for here

00:10:11,180 --> 00:10:15,420
reiterating the map and avoid context

00:10:13,680 --> 00:10:20,130
might give you some problems that's one

00:10:15,420 --> 00:10:24,570
thing to watch out for here we're we

00:10:20,130 --> 00:10:26,460
show you creating a hash using a map so

00:10:24,570 --> 00:10:29,430
here we have our list of files we

00:10:26,460 --> 00:10:31,380
perform the minus M file operator on it

00:10:29,430 --> 00:10:34,800
getting the current or the age of the

00:10:31,380 --> 00:10:39,080
file and we create a hash called age of

00:10:34,800 --> 00:10:39,080
that the key is the name of the file

00:10:41,930 --> 00:10:51,720
here's a 4h that does the same thing and

00:10:47,360 --> 00:10:53,430
an inside out for each where four is

00:10:51,720 --> 00:10:55,080
actually a synonym for for each so we

00:10:53,430 --> 00:10:56,820
could actually say four instead of four

00:10:55,080 --> 00:11:01,400
each and it'd be the same if you really

00:10:56,820 --> 00:11:01,400
want to be concise you can use the four

00:11:02,910 --> 00:11:08,370
if you want to skip an element in a map

00:11:05,670 --> 00:11:11,220
so you're essentially dropping elements

00:11:08,370 --> 00:11:14,570
in the list you can do that by having

00:11:11,220 --> 00:11:19,320
the code block evaluate to an empty list

00:11:14,570 --> 00:11:21,780
so here if our element is less than 10

00:11:19,320 --> 00:11:23,820
then we'll use that element otherwise we

00:11:21,780 --> 00:11:27,600
use empty lists that will actually drop

00:11:23,820 --> 00:11:35,160
those elements that is actually the same

00:11:27,600 --> 00:11:37,470
as grep so this map in this grep are the

00:11:35,160 --> 00:11:39,960
same thing all grep does is it evaluates

00:11:37,470 --> 00:11:43,500
this expression in the curly braces and

00:11:39,960 --> 00:11:50,190
says all the expressions where that's

00:11:43,500 --> 00:11:51,870
true it will return that element so

00:11:50,190 --> 00:11:59,160
we'll get only the numbers that are less

00:11:51,870 --> 00:12:01,080
than 10 in the in the ones array and

00:11:59,160 --> 00:12:03,720
only explained boolean scalar context

00:12:01,080 --> 00:12:06,090
grep is expecting in that curly brace

00:12:03,720 --> 00:12:07,920
thing something to evaluate kind of like

00:12:06,090 --> 00:12:09,870
a boolean a true/false type thing but

00:12:07,920 --> 00:12:12,270
there's five things that pearl considers

00:12:09,870 --> 00:12:16,590
false and everything else is considered

00:12:12,270 --> 00:12:19,350
true so for example so the things that

00:12:16,590 --> 00:12:21,930
are false are 0 the strings that has a

00:12:19,350 --> 00:12:25,440
single 0 character in it the floating

00:12:21,930 --> 00:12:28,020
point exactly 0 point 0 and empty string

00:12:25,440 --> 00:12:30,630
or undef all those are considered false

00:12:28,020 --> 00:12:37,800
everything else is considered true so if

00:12:30,630 --> 00:12:43,260
0 is false if 400 is true if -1 is true

00:12:37,800 --> 00:12:44,970
if the string false is true because it's

00:12:43,260 --> 00:12:49,470
not one of those 5 values of boolean

00:12:44,970 --> 00:12:54,690
false if double 0 in a string is true if

00:12:49,470 --> 00:12:59,580
we undefined in dollar X then it son

00:12:54,690 --> 00:13:01,410
deft it's false so when we look at grep

00:12:59,580 --> 00:13:03,390
it's looking for those five values of

00:13:01,410 --> 00:13:05,700
boolean false to evaluate and with

00:13:03,390 --> 00:13:07,590
that's boolean scalar context if it

00:13:05,700 --> 00:13:09,870
finds those it's false it'll drop out

00:13:07,590 --> 00:13:13,320
the element that evaluates to that

00:13:09,870 --> 00:13:15,210
otherwise it retains the element so if

00:13:13,320 --> 00:13:16,350
it's less than 10 that'll give us the

00:13:15,210 --> 00:13:19,200
ones

00:13:16,350 --> 00:13:21,840
here we're getting the directories here

00:13:19,200 --> 00:13:24,030
we're getting the unique items in the

00:13:21,840 --> 00:13:25,290
list is it number different ways we

00:13:24,030 --> 00:13:27,030
could do that this is just one of them

00:13:25,290 --> 00:13:30,150
here we're looking for the strings that

00:13:27,030 --> 00:13:34,110
contain the word error either an

00:13:30,150 --> 00:13:37,110
uppercase or lowercase here we're

00:13:34,110 --> 00:13:39,540
getting everything as long as it has a

00:13:37,110 --> 00:13:46,530
true value so we will drop out things

00:13:39,540 --> 00:13:48,930
like zero an empty string now in a few

00:13:46,530 --> 00:13:52,710
minutes we have left we need to talk

00:13:48,930 --> 00:13:53,750
about sort sort can be called in three

00:13:52,710 --> 00:13:56,130
different ways

00:13:53,750 --> 00:13:57,960
we can call it with no comparison

00:13:56,130 --> 00:14:00,720
directive which it'll use the default

00:13:57,960 --> 00:14:04,380
comparison we can use a subroutine to

00:14:00,720 --> 00:14:08,160
tell us how to compare or we can give it

00:14:04,380 --> 00:14:12,210
a code block these are the three forms

00:14:08,160 --> 00:14:15,930
that we have what sort does is it takes

00:14:12,210 --> 00:14:17,760
the list and it compares any two items

00:14:15,930 --> 00:14:20,160
in the list and it needs to know how do

00:14:17,760 --> 00:14:23,220
i order these if we don't tell it how to

00:14:20,160 --> 00:14:25,170
order them it will sort by dolt in ASCII

00:14:23,220 --> 00:14:27,930
collating sequence sequence or Unicode

00:14:25,170 --> 00:14:30,450
collating sequence if we give it a

00:14:27,930 --> 00:14:32,340
subroutine it'll take those two elements

00:14:30,450 --> 00:14:35,160
and give it to our subroutine our

00:14:32,340 --> 00:14:36,720
subroutine returns a value that it's

00:14:35,160 --> 00:14:39,540
going to say whether that's an order or

00:14:36,720 --> 00:14:42,810
not or our code block can do the same

00:14:39,540 --> 00:14:45,510
thing now subroutines are rarely used I

00:14:42,810 --> 00:14:47,010
think in 20 programming Perl I've never

00:14:45,510 --> 00:14:52,140
seen anybody to use the subroutine

00:14:47,010 --> 00:14:58,320
approach everybody uses code block what

00:14:52,140 --> 00:15:02,400
sort is expecting is as a 1 a 0 or a

00:14:58,320 --> 00:15:07,290
minus 1 to tell whether things are in

00:15:02,400 --> 00:15:12,030
order the same or out of order the

00:15:07,290 --> 00:15:13,650
compare operator CMP for Strings and the

00:15:12,030 --> 00:15:16,860
numeric ones we sometimes call the

00:15:13,650 --> 00:15:20,190
spaceship operator the less than equals

00:15:16,860 --> 00:15:22,020
then greater than those tell us whether

00:15:20,190 --> 00:15:25,140
they're those naturally returned a minus

00:15:22,020 --> 00:15:26,910
1 to 0 or a 1 so we very is very

00:15:25,140 --> 00:15:28,200
convenient for us to use those and

00:15:26,910 --> 00:15:29,550
you'll often see those but you don't

00:15:28,200 --> 00:15:33,089
have to

00:15:29,550 --> 00:15:35,160
in a sort code block there's two

00:15:33,089 --> 00:15:36,899
Global's dollar a and dollar B which

00:15:35,160 --> 00:15:39,959
Larry wall is defined to be the ones

00:15:36,899 --> 00:15:42,209
that we use to hold the any two values

00:15:39,959 --> 00:15:43,920
that were to compare so what we need to

00:15:42,209 --> 00:15:48,299
do is compare dollar a and dollar B in

00:15:43,920 --> 00:15:51,899
our code block and return either a -1 0

00:15:48,299 --> 00:15:57,389
or a 1 to tell whether we are in order

00:15:51,899 --> 00:15:59,879
the same or out of order so some

00:15:57,389 --> 00:16:03,209
examples of sorting the the default sort

00:15:59,879 --> 00:16:06,600
very easy if you want to do a numeric

00:16:03,209 --> 00:16:09,239
sort the default is string wise so this

00:16:06,600 --> 00:16:15,749
would be a numeric sort dollar a compare

00:16:09,239 --> 00:16:17,999
numeric compared with dollar B the

00:16:15,749 --> 00:16:22,739
default is actually the same as doing

00:16:17,999 --> 00:16:25,529
dollar a CMP dollar B that's just the

00:16:22,739 --> 00:16:27,540
default if we want to reverse the sort

00:16:25,529 --> 00:16:29,790
so instead of ascending order we do it

00:16:27,540 --> 00:16:31,290
in descending order we can actually just

00:16:29,790 --> 00:16:33,749
reverse the a and the B because it'll

00:16:31,290 --> 00:16:36,230
return a minus 1 instead of a 1 or a 1

00:16:33,749 --> 00:16:38,999
instead of a minus 1 0 will be the same

00:16:36,230 --> 00:16:42,449
so that will reverse them or we can use

00:16:38,999 --> 00:16:46,069
the reverse function sort we'll order

00:16:42,449 --> 00:16:48,509
them and then reverse just reverses them

00:16:46,069 --> 00:16:50,189
the reverse is generally preferred

00:16:48,509 --> 00:16:52,110
because it's obvious what you're doing

00:16:50,189 --> 00:16:54,389
because not all Perl program programmers

00:16:52,110 --> 00:16:58,860
understand the a dollar a and dollar B

00:16:54,389 --> 00:17:00,389
syntax reverse will make your code a

00:16:58,860 --> 00:17:01,559
little bit easier to read however there

00:17:00,389 --> 00:17:05,100
is a penalty because you have the

00:17:01,559 --> 00:17:06,809
overhead of a reverse call so that cost

00:17:05,100 --> 00:17:08,639
you a little bit more if you actually

00:17:06,809 --> 00:17:11,069
want to do a subroutine which is rarely

00:17:08,639 --> 00:17:14,010
done here's how you actually do it you

00:17:11,069 --> 00:17:15,899
create the subroutine using the

00:17:14,010 --> 00:17:17,159
comparison between the a and the B here

00:17:15,899 --> 00:17:18,809
we're doing it we're forcing everything

00:17:17,159 --> 00:17:20,610
to uppercase and then comparing the

00:17:18,809 --> 00:17:23,819
uppercase versions so it'll sort

00:17:20,610 --> 00:17:25,829
regardless of case we create a reference

00:17:23,819 --> 00:17:28,049
to that subroutine and we give that

00:17:25,829 --> 00:17:31,320
reference to sort to actually do the

00:17:28,049 --> 00:17:35,659
sort you can also use anonymous

00:17:31,320 --> 00:17:35,659
subroutines you cannot use recursion

00:17:36,830 --> 00:17:44,340
anything we can get to through a and B

00:17:40,200 --> 00:17:46,980
we can sort on a and B are just

00:17:44,340 --> 00:17:49,080
connections to something we can sort so

00:17:46,980 --> 00:17:50,879
for example if a and B are strings that

00:17:49,080 --> 00:17:53,879
we need to split and we want to get the

00:17:50,879 --> 00:17:56,039
fifth field or element five we can

00:17:53,879 --> 00:17:59,549
actually do that we can say split inside

00:17:56,039 --> 00:18:02,100
of our code block and splitting a and

00:17:59,549 --> 00:18:03,360
getting an array splitting be getting an

00:18:02,100 --> 00:18:06,419
array and then compare the fifth

00:18:03,360 --> 00:18:17,639
elements anything you can get to through

00:18:06,419 --> 00:18:20,999
a and B you can sort on one a sort the

00:18:17,639 --> 00:18:24,179
keys of a hash we can do it this way if

00:18:20,999 --> 00:18:28,409
we want to sort a hash itself by the

00:18:24,179 --> 00:18:32,779
value instead of by the keys C we can

00:18:28,409 --> 00:18:35,129
get to that value through a and B

00:18:32,779 --> 00:18:39,299
anything you could get to through a and

00:18:35,129 --> 00:18:41,940
B you can sort on so here's an example

00:18:39,299 --> 00:18:44,549
of sorting strings that are dates where

00:18:41,940 --> 00:18:47,549
we have to split up the dates into month

00:18:44,549 --> 00:18:49,259
days and years each version and a and B

00:18:47,549 --> 00:18:55,379
a version of those and then comparing

00:18:49,259 --> 00:18:58,619
the years and then using an or so that

00:18:55,379 --> 00:19:01,049
if the if the B if the years are equal

00:18:58,619 --> 00:19:03,090
then it'll be a zero on this or so then

00:19:01,049 --> 00:19:04,499
we'll go to the next one because it had

00:19:03,090 --> 00:19:06,419
it doesn't know yet if this whole thing

00:19:04,499 --> 00:19:08,490
is true or false it can still be true or

00:19:06,419 --> 00:19:10,470
false so it'll go to the next one

00:19:08,490 --> 00:19:12,690
compare the months if it knows the

00:19:10,470 --> 00:19:15,389
months what order it is then it'll drop

00:19:12,690 --> 00:19:15,899
out at that point so we can chain these

00:19:15,389 --> 00:19:18,690
ORS

00:19:15,899 --> 00:19:21,690
- this is do this as much as we want now

00:19:18,690 --> 00:19:25,549
I'm about out of time so let me skip

00:19:21,690 --> 00:19:29,820
past all the optimization stuff here and

00:19:25,549 --> 00:19:33,779
tell you that right here we have further

00:19:29,820 --> 00:19:36,960
options utilities here that you can do

00:19:33,779 --> 00:19:38,220
there we go list utilities more

00:19:36,960 --> 00:19:40,289
utilities there's a lot of stuff out

00:19:38,220 --> 00:19:42,990
there to do sorting and there's a lot of

00:19:40,289 --> 00:19:48,600
optimizations available there's the

00:19:42,990 --> 00:19:49,830
short term transform there's the orcish

00:19:48,600 --> 00:19:55,379
maneuver

00:19:49,830 --> 00:19:57,600
there's the Gutman Rossler a lot of fun

00:19:55,379 --> 00:19:59,190
stuff that's it for the presentation

00:19:57,600 --> 00:20:02,929
thank you if you want to stick around

00:19:59,190 --> 00:20:02,929

YouTube URL: https://www.youtube.com/watch?v=qU-Yxn5hdzM


