Title: Jesse Luehrs (‎doy‎) - Introduction to Rust
Publication date: 2014-06-23
Playlist: YAPC::NA 2014
Description: 
	Rust is a new programming language being developed by Mozilla for low level and systems programming tasks. Its goal is to be a replacement for C or C++ in a lot of the environments that they are currently used in (including embedded systems), while providing much stronger memory safety and concurrency guarantees, as well as other modern programming language features.

This talk will go over the basics of programming in Rust, touching on the major features that make it interesting. Knowledge of C or C++ will be helpful, although not necessary.
Captions: 
	00:01:02,780 --> 00:01:17,369
Roberge testing testing okay so I'm I'm

00:01:14,880 --> 00:01:20,909
Jessie lures I'm from with interactive

00:01:17,369 --> 00:01:24,930
infinity interactive and i'm giving a

00:01:20,909 --> 00:01:27,090
this talk is about rust rust is a new

00:01:24,930 --> 00:01:29,070
systems language being developed by by

00:01:27,090 --> 00:01:30,780
mozilla research it's still in

00:01:29,070 --> 00:01:34,080
development but they're planning on

00:01:30,780 --> 00:01:38,100
having a initial stable release later

00:01:34,080 --> 00:01:39,360
this year this talk they've made a bunch

00:01:38,100 --> 00:01:42,179
of development releases over the past

00:01:39,360 --> 00:01:45,450
year or two this talk is actually going

00:01:42,179 --> 00:01:47,070
to be based on the current state of

00:01:45,450 --> 00:01:49,470
masters they've been making a lot of

00:01:47,070 --> 00:01:51,720
there's still been a lot of changes and

00:01:49,470 --> 00:01:53,910
so if you're if you're running on the

00:01:51,720 --> 00:01:56,820
latest development really see these the

00:01:53,910 --> 00:02:01,290
examples might not work but that's

00:01:56,820 --> 00:02:03,090
that's just why this arrests goal is to

00:02:01,290 --> 00:02:04,950
provide an alternative for projects

00:02:03,090 --> 00:02:10,950
which would otherwise be written in C or

00:02:04,950 --> 00:02:12,900
C++ the problem with C based languages

00:02:10,950 --> 00:02:15,120
is that they're very difficult to use

00:02:12,900 --> 00:02:17,100
correctly as your project gets larger

00:02:15,120 --> 00:02:19,019
it's very easily that easy to

00:02:17,100 --> 00:02:22,019
accidentally writes code that causes

00:02:19,019 --> 00:02:25,680
segfaults accessing memory that doesn't

00:02:22,019 --> 00:02:27,660
exist memory corruption data races that

00:02:25,680 --> 00:02:29,400
sort of thing there's not really any

00:02:27,660 --> 00:02:31,890
protection in the language for those

00:02:29,400 --> 00:02:33,769
kind of issues and these are very

00:02:31,890 --> 00:02:37,500
important because they can cause

00:02:33,769 --> 00:02:40,049
security issues data loss and things

00:02:37,500 --> 00:02:43,019
along those lines the reason that people

00:02:40,049 --> 00:02:44,760
still use C++ is because it gives you a

00:02:43,019 --> 00:02:46,760
lot of control over the code that you

00:02:44,760 --> 00:02:49,260
write it allows you to write code that

00:02:46,760 --> 00:02:50,970
wouldn't be possible in other languages

00:02:49,260 --> 00:02:53,280
like you can't there's not really a way

00:02:50,970 --> 00:02:56,130
to write say like an interrupt handler

00:02:53,280 --> 00:02:57,450
in pure pearl like that that's not you

00:02:56,130 --> 00:03:00,329
need something that can actually access

00:02:57,450 --> 00:03:03,930
the underlying hardware it also allows

00:03:00,329 --> 00:03:07,440
you to write a very efficient code like

00:03:03,930 --> 00:03:09,870
if you're in computation heavy code

00:03:07,440 --> 00:03:12,860
in C++ can make it several orders of

00:03:09,870 --> 00:03:15,930
magnitude faster and that's why a lot of

00:03:12,860 --> 00:03:18,740
there's a lot of excess modules on Sipan

00:03:15,930 --> 00:03:23,310
that did with the purpose of speeding up

00:03:18,740 --> 00:03:24,740
performance critical code and in in the

00:03:23,310 --> 00:03:27,270
Pearl community we often talk about

00:03:24,740 --> 00:03:28,320
premature optimization how getting that

00:03:27,270 --> 00:03:29,580
last ten to fifteen percent of

00:03:28,320 --> 00:03:33,330
performance out of a piece of code

00:03:29,580 --> 00:03:35,820
usually isn't worth it that's really a

00:03:33,330 --> 00:03:37,980
factor of the kinds of applications that

00:03:35,820 --> 00:03:39,240
we write we can ignore a lot of those

00:03:37,980 --> 00:03:41,580
kind of things because of how

00:03:39,240 --> 00:03:44,100
insignificant they are compared to the

00:03:41,580 --> 00:03:46,110
time that takes say the OS to read data

00:03:44,100 --> 00:03:47,670
from disk score to pull data from a

00:03:46,110 --> 00:03:50,130
database but when you're actually

00:03:47,670 --> 00:03:52,110
writing like a disk controller or the

00:03:50,130 --> 00:03:54,270
actual database itself that that ten to

00:03:52,110 --> 00:03:56,190
fifteen percent does actually matter and

00:03:54,270 --> 00:03:59,400
so that's the kind of applications that

00:03:56,190 --> 00:04:01,830
rust is is trying the target and so rest

00:03:59,400 --> 00:04:03,570
the rest goal is to provide that same

00:04:01,830 --> 00:04:05,670
level of control that you get from C++

00:04:03,570 --> 00:04:08,220
while removing as many of the dangerous

00:04:05,670 --> 00:04:10,530
sharp edges as possible its philosophy

00:04:08,220 --> 00:04:12,660
is based on the idea of zero cost

00:04:10,530 --> 00:04:15,120
abstractions one of the main benefits

00:04:12,660 --> 00:04:18,720
writing a C++ is that it's very easy to

00:04:15,120 --> 00:04:21,630
see given it an example of C++ code how

00:04:18,720 --> 00:04:26,850
it actually maps to the how it's

00:04:21,630 --> 00:04:28,350
actually be executed basically and for

00:04:26,850 --> 00:04:30,600
us to really be a replacement it needs

00:04:28,350 --> 00:04:32,130
to actually it needs to retain that it

00:04:30,600 --> 00:04:35,190
means you can't like it's not going to

00:04:32,130 --> 00:04:39,630
have things like mandatory garbage

00:04:35,190 --> 00:04:41,700
collection mandatory boxing of variables

00:04:39,630 --> 00:04:44,460
where every every variable needs to be

00:04:41,700 --> 00:04:47,100
allocating a certain way really just no

00:04:44,460 --> 00:04:48,600
actual runtime at all like it'll have it

00:04:47,100 --> 00:04:50,220
have a standard library but it's not

00:04:48,600 --> 00:04:52,710
actually required in a lot in much the

00:04:50,220 --> 00:04:54,030
same way in C or C++ you don't actually

00:04:52,710 --> 00:04:58,080
have to have the standard library

00:04:54,030 --> 00:05:00,540
available to be able to run code rest

00:04:58,080 --> 00:05:02,700
has the ability to do these things to

00:05:00,540 --> 00:05:03,930
provide box variables to provide

00:05:02,700 --> 00:05:09,300
reference counting and garbage

00:05:03,930 --> 00:05:12,930
collection but they're all optional and

00:05:09,300 --> 00:05:15,120
in and so for most code you don't you

00:05:12,930 --> 00:05:16,590
don't have to actually use them if it's

00:05:15,120 --> 00:05:18,860
actually not appropriate for what you're

00:05:16,590 --> 00:05:18,860
doing

00:05:18,900 --> 00:05:25,979
and even for new abstractions that

00:05:21,840 --> 00:05:27,509
introduces things like closures um it's

00:05:25,979 --> 00:05:29,310
built on enough of a foundation where

00:05:27,509 --> 00:05:31,350
those can be inlined away so that the

00:05:29,310 --> 00:05:33,570
code you actually and that actually ends

00:05:31,350 --> 00:05:35,160
up being generated doesn't need to be

00:05:33,570 --> 00:05:37,410
any slower than the code that you would

00:05:35,160 --> 00:05:45,270
write with normal pointer manipulation

00:05:37,410 --> 00:05:48,240
in C so basically the the compiler can

00:05:45,270 --> 00:05:49,770
do all these checks at compile time to

00:05:48,240 --> 00:05:51,630
eliminate things like null pointer

00:05:49,770 --> 00:05:55,680
accesses and memory corruption and data

00:05:51,630 --> 00:05:57,720
races ideally without adding any actual

00:05:55,680 --> 00:06:02,720
overhead that the check should all be

00:05:57,720 --> 00:06:05,160
able to be that compile time sometimes

00:06:02,720 --> 00:06:08,310
avoiding those kind of issues isn't

00:06:05,160 --> 00:06:12,139
always possible rust like you still have

00:06:08,310 --> 00:06:14,849
to be able to access the the underlying

00:06:12,139 --> 00:06:17,099
hardware you still like rust is self

00:06:14,849 --> 00:06:19,070
hosting the compiler is written in rust

00:06:17,099 --> 00:06:21,570
and so you need to be able to access

00:06:19,070 --> 00:06:22,910
needs to be able to write the primitives

00:06:21,570 --> 00:06:27,870
that they're necessary for that to work

00:06:22,910 --> 00:06:29,729
and also all the compiler is only ever

00:06:27,870 --> 00:06:31,410
going to be so smart and sometimes you

00:06:29,729 --> 00:06:33,740
kind of have to tell the compiler just

00:06:31,410 --> 00:06:35,880
trust me what I'm doing is actually ok

00:06:33,740 --> 00:06:40,979
in order to make code that actually

00:06:35,880 --> 00:06:43,800
works well and runs quickly when so rust

00:06:40,979 --> 00:06:45,720
also provides a way to bypass those

00:06:43,800 --> 00:06:50,039
safety checks in in certain limited

00:06:45,720 --> 00:06:57,000
scopes in order to in order to

00:06:50,039 --> 00:06:59,490
accommodate those kind of needs so a

00:06:57,000 --> 00:07:01,289
common question at this point is why why

00:06:59,490 --> 00:07:03,330
is this why is this required a new

00:07:01,289 --> 00:07:05,340
language like can't you just write like

00:07:03,330 --> 00:07:07,620
couldn't couldn't just be like modified

00:07:05,340 --> 00:07:11,150
from C++ like it gets something that

00:07:07,620 --> 00:07:15,060
that actually accomplishes this and did

00:07:11,150 --> 00:07:17,669
the answer here is is that doing this

00:07:15,060 --> 00:07:19,169
into in a way that that was actually

00:07:17,669 --> 00:07:22,670
that actually accomplishes all the

00:07:19,169 --> 00:07:25,250
safety goals that rust is targeting

00:07:22,670 --> 00:07:27,110
no C++ programs in existence no

00:07:25,250 --> 00:07:28,760
nontrivial C++ programs in existence

00:07:27,110 --> 00:07:30,860
would compile under those kind of

00:07:28,760 --> 00:07:34,610
restrictions you need to be able to

00:07:30,860 --> 00:07:37,430
annotate the code with reasons why this

00:07:34,610 --> 00:07:40,850
is safe basically and at that point

00:07:37,430 --> 00:07:42,290
you're already basically you're on your

00:07:40,850 --> 00:07:46,240
way to a new language at that point

00:07:42,290 --> 00:07:49,130
anyway investors is based it's based on

00:07:46,240 --> 00:07:52,070
llvm which is the same back-end that the

00:07:49,130 --> 00:07:54,170
client compiler uses so it's not like

00:07:52,070 --> 00:07:56,560
it's starting from scratch either most

00:07:54,170 --> 00:07:58,940
of the optimizations that llvm provides

00:07:56,560 --> 00:08:02,110
that you get when you're using client

00:07:58,940 --> 00:08:05,360
which is the defaults compiler on OS 10

00:08:02,110 --> 00:08:06,890
those optimizations are mostly done on

00:08:05,360 --> 00:08:09,110
the back end after the language has been

00:08:06,890 --> 00:08:11,410
parsed so it rest can share in all of

00:08:09,110 --> 00:08:13,700
that work that's been done so it's a

00:08:11,410 --> 00:08:19,130
it's not it's not throwing away a lot

00:08:13,700 --> 00:08:21,770
all that work another another question

00:08:19,130 --> 00:08:25,160
is why is Mozilla in particular doing

00:08:21,770 --> 00:08:27,440
this and so the reason behind this is

00:08:25,160 --> 00:08:29,060
that there are a lot of issues a lot of

00:08:27,440 --> 00:08:33,350
areas that are still performance

00:08:29,060 --> 00:08:36,410
critical and these days browsers are

00:08:33,350 --> 00:08:37,550
really one of them if you if you really

00:08:36,410 --> 00:08:42,140
kind of stand back and squint a little

00:08:37,550 --> 00:08:45,830
bit browsers are kind of becoming an OS

00:08:42,140 --> 00:08:47,720
level kind of abstraction you have all

00:08:45,830 --> 00:08:49,550
this untrusted code that you're running

00:08:47,720 --> 00:08:53,330
all the time that needs to be safely

00:08:49,550 --> 00:08:54,680
sandboxed it needs to run quickly and

00:08:53,330 --> 00:08:58,760
that's that be able to access things

00:08:54,680 --> 00:09:00,860
like OpenGL and microphones and all

00:08:58,760 --> 00:09:05,360
those kind of hardware and so you

00:09:00,860 --> 00:09:09,080
basically you run through a lot of the

00:09:05,360 --> 00:09:11,900
same issues there and and at the moment

00:09:09,080 --> 00:09:15,740
Firefox is around eight million lines of

00:09:11,900 --> 00:09:18,020
C++ code and you pretty much can't write

00:09:15,740 --> 00:09:20,360
eight million lines of C++ code without

00:09:18,020 --> 00:09:22,550
there being some serious security issues

00:09:20,360 --> 00:09:26,780
in there somewhere or data corruption or

00:09:22,550 --> 00:09:28,820
things like that and to cut these kinds

00:09:26,780 --> 00:09:30,730
of bugs that's the memory corruption and

00:09:28,820 --> 00:09:32,779
and

00:09:30,730 --> 00:09:34,459
concurrency data races kind of things

00:09:32,779 --> 00:09:37,160
are the kinds of bugs that you can't

00:09:34,459 --> 00:09:40,689
really write tests for because they only

00:09:37,160 --> 00:09:40,689
show up in very specific circumstances

00:09:40,839 --> 00:09:44,209
these are the kind of things that you

00:09:42,499 --> 00:09:46,610
really need to be able to verify at

00:09:44,209 --> 00:09:52,699
compile time that to make sure that this

00:09:46,610 --> 00:09:55,610
is actually not possible to happen so

00:09:52,699 --> 00:09:58,610
with that in mind Mozilla is developing

00:09:55,610 --> 00:10:00,439
rust in order to that there at the same

00:09:58,610 --> 00:10:05,300
time working on a new browser engine

00:10:00,439 --> 00:10:07,100
called servo which is using rust

00:10:05,300 --> 00:10:09,559
stronger safety guarantees and the

00:10:07,100 --> 00:10:13,040
stronger parallelism support that rust

00:10:09,559 --> 00:10:17,420
also includes to kind of work on the

00:10:13,040 --> 00:10:19,939
next generation of browser engines it's

00:10:17,420 --> 00:10:23,509
it's also still a work in progress but

00:10:19,939 --> 00:10:26,209
they also are hoping to have not not

00:10:23,509 --> 00:10:28,399
really not necessarily a browser for the

00:10:26,209 --> 00:10:33,829
public to use but a something that's

00:10:28,399 --> 00:10:37,759
actually usable like a proof of concept

00:10:33,829 --> 00:10:39,290
basically by the end of the year it are

00:10:37,759 --> 00:10:42,319
it are the rendering engine already

00:10:39,290 --> 00:10:43,759
passes acid too and it does a lot of a

00:10:42,319 --> 00:10:47,449
lot of parallelism and that sort of

00:10:43,759 --> 00:10:52,930
thing so that's kind of weird where this

00:10:47,449 --> 00:10:56,809
is going so so for the language itself

00:10:52,930 --> 00:11:01,459
rust is rest has syntax based on kind of

00:10:56,809 --> 00:11:06,430
c and ml it's this is this is a hello

00:11:01,459 --> 00:11:10,129
world declare functions with FN their

00:11:06,430 --> 00:11:13,879
main is the entry point entry points of

00:11:10,129 --> 00:11:18,019
the program and print line is how you do

00:11:13,879 --> 00:11:21,949
is basically the same as printf there's

00:11:18,019 --> 00:11:23,629
there some differences but here is a

00:11:21,949 --> 00:11:26,540
more complicated example this is

00:11:23,629 --> 00:11:30,050
actually from the main the main page of

00:11:26,540 --> 00:11:34,480
the rust website you can see variables

00:11:30,050 --> 00:11:36,949
being declared with let variables are

00:11:34,480 --> 00:11:38,029
they have to be initialized at the point

00:11:36,949 --> 00:11:40,459
of declaration you can't have

00:11:38,029 --> 00:11:42,540
uninitialized variables there immutable

00:11:40,459 --> 00:11:45,270
by default you can see underneath there

00:11:42,540 --> 00:11:47,690
mute is declaring a mutable variable we

00:11:45,270 --> 00:11:50,130
have to actually declare that iteration

00:11:47,690 --> 00:11:54,210
through a for loop there's also while

00:11:50,130 --> 00:11:57,120
loops in this example you have the

00:11:54,210 --> 00:11:59,580
charge method on the string program

00:11:57,120 --> 00:12:02,930
which returns an iterator which iterates

00:11:59,580 --> 00:12:02,930
through all the characters in the string

00:12:03,080 --> 00:12:13,110
characters are four byte unicode code

00:12:06,270 --> 00:12:14,250
points strings are utf-8 another another

00:12:13,110 --> 00:12:17,570
minor thing you might want you might

00:12:14,250 --> 00:12:19,950
know is that for loops and as well

00:12:17,570 --> 00:12:23,000
conditionals and while loops don't

00:12:19,950 --> 00:12:26,970
require parenthesis similar to Perl 6

00:12:23,000 --> 00:12:32,160
that's just a syntax thing rest also has

00:12:26,970 --> 00:12:34,140
pattern matching like oh camel you can

00:12:32,160 --> 00:12:39,570
match on arbitrary data structures this

00:12:34,140 --> 00:12:40,800
one is just matching on a character but

00:12:39,570 --> 00:12:42,750
you can match on arbitrary data

00:12:40,800 --> 00:12:45,000
structures the compiler actually

00:12:42,750 --> 00:12:46,980
verifies that you're your match is

00:12:45,000 --> 00:12:52,560
exhaustive so that you can actually have

00:12:46,980 --> 00:12:54,660
to handle every case explicitly and so

00:12:52,560 --> 00:12:57,240
that that provides more guarantees that

00:12:54,660 --> 00:12:59,760
you're not like especially refactoring

00:12:57,240 --> 00:13:00,570
if you're matching against say an enum

00:12:59,760 --> 00:13:02,160
and you want to make sure that you're

00:13:00,570 --> 00:13:05,910
actually covering everything if it

00:13:02,160 --> 00:13:07,950
changes and finally you can see a more

00:13:05,910 --> 00:13:10,140
complicated example of print line at the

00:13:07,950 --> 00:13:14,460
end here this syntax for this is

00:13:10,140 --> 00:13:17,820
actually based on Python the the curly

00:13:14,460 --> 00:13:20,280
braces there the empty braces basically

00:13:17,820 --> 00:13:23,580
mean to just print out the the variable

00:13:20,280 --> 00:13:29,040
that that's given um however it should

00:13:23,580 --> 00:13:32,580
default to be printed out you can also

00:13:29,040 --> 00:13:35,460
have arguments in there too like like

00:13:32,580 --> 00:13:39,300
printf has to print in different ways

00:13:35,460 --> 00:13:42,690
you can also have arguments to reorder

00:13:39,300 --> 00:13:46,290
the the arguments for things like

00:13:42,690 --> 00:13:48,920
internationalisation if the the order

00:13:46,290 --> 00:13:48,920
needs to be different

00:13:49,460 --> 00:13:56,720
so as I mentioned the for loop is based

00:13:52,980 --> 00:13:59,010
on iterators and so you can also

00:13:56,720 --> 00:14:01,020
iterators are nice in that they don't

00:13:59,010 --> 00:14:02,930
require any extra allocation and also in

00:14:01,020 --> 00:14:07,170
that they're very easy to chain together

00:14:02,930 --> 00:14:09,210
so here instead of having the final case

00:14:07,170 --> 00:14:12,210
of the match statements the catch-all

00:14:09,210 --> 00:14:13,710
kind of default case instead of having

00:14:12,210 --> 00:14:17,250
to do nothing here I'm having it

00:14:13,710 --> 00:14:19,080
actually fail in the and then instead in

00:14:17,250 --> 00:14:23,190
the actual iteration I'm filtering out

00:14:19,080 --> 00:14:28,230
all the spaces instead and you can see

00:14:23,190 --> 00:14:35,190
this it's it's it's still it calculates

00:14:28,230 --> 00:14:37,730
the value here on another thing to note

00:14:35,190 --> 00:14:41,580
here is that the filter method takes

00:14:37,730 --> 00:14:44,760
closure as an argument closer syntax is

00:14:41,580 --> 00:14:47,520
based on Ruby Ruby's block syntax this

00:14:44,760 --> 00:14:51,180
closure takes the character in turn and

00:14:47,520 --> 00:14:54,270
you can do you just filter it out it's

00:14:51,180 --> 00:14:57,600
basically like grep the ampersand there

00:14:54,270 --> 00:15:01,410
is a pointer thing that we'll get into

00:14:57,600 --> 00:15:02,490
in a little bit you can also also note

00:15:01,410 --> 00:15:05,220
that the closure doesn't actually

00:15:02,490 --> 00:15:07,800
require return statement just like in

00:15:05,220 --> 00:15:14,610
Perl the return statement at the end of

00:15:07,800 --> 00:15:23,250
a any function is optional and yeah

00:15:14,610 --> 00:15:27,690
that's a that's that so in addition to

00:15:23,250 --> 00:15:30,210
basic types like in jerz floating point

00:15:27,690 --> 00:15:32,130
values arrays things like that rust can

00:15:30,210 --> 00:15:38,480
also build more complicated data

00:15:32,130 --> 00:15:38,480
structures using struts and

00:15:39,850 --> 00:15:46,760
so this right here is declaring a point

00:15:43,100 --> 00:15:53,930
a point struct it has X&Y they're both

00:15:46,760 --> 00:15:56,960
integers and you can print it out you

00:15:53,930 --> 00:16:01,580
print out the x and the y components and

00:15:56,960 --> 00:16:04,430
that's what you get structs are required

00:16:01,580 --> 00:16:06,830
to be allocate or initialized just like

00:16:04,430 --> 00:16:11,180
all other all other variables you can't

00:16:06,830 --> 00:16:14,870
have initialized data the structs are

00:16:11,180 --> 00:16:16,820
also entirely memory compatible with c

00:16:14,870 --> 00:16:19,400
so you can pass them back and forth

00:16:16,820 --> 00:16:21,020
between c and rust that's one of the big

00:16:19,400 --> 00:16:25,430
things that rust is trying to do is be

00:16:21,020 --> 00:16:26,680
as compatible with with C as possible in

00:16:25,430 --> 00:16:28,850
order to be able to interoperate with

00:16:26,680 --> 00:16:29,990
existing libraries and that sort of

00:16:28,850 --> 00:16:36,650
things you don't you don't have to

00:16:29,990 --> 00:16:40,400
convert all at once rust also has enum

00:16:36,650 --> 00:16:42,800
types basically just a list of potential

00:16:40,400 --> 00:16:50,660
values that the type can hold just like

00:16:42,800 --> 00:16:54,140
see like here you have a coloring them

00:16:50,660 --> 00:17:00,190
which has red green and blue as

00:16:54,140 --> 00:17:00,190
potential colors you could use and here

00:17:03,230 --> 00:17:10,500
if you declare a variable with the value

00:17:07,559 --> 00:17:12,600
of red you can print out if you do a

00:17:10,500 --> 00:17:14,939
pattern match on it rusts like i said

00:17:12,600 --> 00:17:16,679
guarantees that the pattern match has to

00:17:14,939 --> 00:17:19,010
be exhaustive it has to cover all of the

00:17:16,679 --> 00:17:23,790
possible values that the type would have

00:17:19,010 --> 00:17:27,750
if you have say if you don't cover one

00:17:23,790 --> 00:17:31,200
of them you get a compiler error here

00:17:27,750 --> 00:17:33,480
you can see it says non exhaustive

00:17:31,200 --> 00:17:36,929
pattern you didn't cover blue it tells

00:17:33,480 --> 00:17:40,340
you what you're missing this is it's

00:17:36,929 --> 00:17:40,340
useful when you're doing things like

00:17:41,510 --> 00:17:47,600
refactoring just to make sure you don't

00:17:43,260 --> 00:17:47,600
miss anything and if you have an extra

00:17:47,840 --> 00:17:55,770
if you have an extra case you can see

00:17:50,760 --> 00:17:57,360
it's it's saying let's expect it a color

00:17:55,770 --> 00:17:58,800
but it found an integer you have some

00:17:57,360 --> 00:18:00,000
random other thing in the match case

00:17:58,800 --> 00:18:04,920
that just tells you that you're doing

00:18:00,000 --> 00:18:06,480
something wrong there the nice thing

00:18:04,920 --> 00:18:09,450
about rusting them's though is that

00:18:06,480 --> 00:18:11,580
they're actually if you're familiar with

00:18:09,450 --> 00:18:14,070
algebraic data types from things like

00:18:11,580 --> 00:18:17,250
Haskell or okay I'm Allah things like

00:18:14,070 --> 00:18:20,580
that um you can you can have you can

00:18:17,250 --> 00:18:23,640
attach data to the enum values so here i

00:18:20,580 --> 00:18:30,270
added a custom color type which takes

00:18:23,640 --> 00:18:32,370
three values three integers and here you

00:18:30,270 --> 00:18:34,740
can print here i have the match

00:18:32,370 --> 00:18:41,100
statement now includes the custom color

00:18:34,740 --> 00:18:43,700
and prints out the values for the color

00:18:41,100 --> 00:18:45,870
and then red green and blue are

00:18:43,700 --> 00:18:50,100
hard-coded in there and so you can see

00:18:45,870 --> 00:18:52,640
how that those kind of things are also

00:18:50,100 --> 00:18:52,640
handled

00:18:57,440 --> 00:19:03,360
you can see how in the match statement

00:19:00,120 --> 00:19:05,010
here when you have when you have any

00:19:03,360 --> 00:19:07,830
value that that includes data like this

00:19:05,010 --> 00:19:10,200
it's actually binding the values to the

00:19:07,830 --> 00:19:13,409
r g and b variables it's creating the

00:19:10,200 --> 00:19:14,909
variables called this is a called

00:19:13,409 --> 00:19:18,779
destructuring bind if you're familiar

00:19:14,909 --> 00:19:21,289
with the concept and you can you can use

00:19:18,779 --> 00:19:26,100
that both in match statements and in

00:19:21,289 --> 00:19:28,370
variable declarations the rest standard

00:19:26,100 --> 00:19:31,590
library includes a lot of useful

00:19:28,370 --> 00:19:34,980
examples of items it has an option type

00:19:31,590 --> 00:19:36,600
which looks like this that's pretty that

00:19:34,980 --> 00:19:38,850
should be pretty familiar if you've used

00:19:36,600 --> 00:19:40,950
things like scholar or Haskell or okay

00:19:38,850 --> 00:19:46,140
I'm all that sort of thing basically

00:19:40,950 --> 00:19:48,049
just dumb allows you to have a variable

00:19:46,140 --> 00:19:51,029
that might have value or it might not

00:19:48,049 --> 00:19:54,870
basically instead instead of like in

00:19:51,029 --> 00:19:56,490
Perl you have undef in in rust

00:19:54,870 --> 00:19:58,470
everything has to be defined but if you

00:19:56,490 --> 00:20:00,690
need something that might have not a

00:19:58,470 --> 00:20:02,399
value of probably over that might mean

00:20:00,690 --> 00:20:03,570
you can use the option type instead and

00:20:02,399 --> 00:20:07,770
this will make sure that you actually

00:20:03,570 --> 00:20:09,919
handle the case of it potentially being

00:20:07,770 --> 00:20:15,360
not defined rather than just having

00:20:09,919 --> 00:20:19,049
random things happen this is also a good

00:20:15,360 --> 00:20:22,250
example of rest support for generics you

00:20:19,049 --> 00:20:26,190
can see the option type has a type a

00:20:22,250 --> 00:20:30,120
type parameter their tea and you can see

00:20:26,190 --> 00:20:35,760
that the the sum the sum variant of the

00:20:30,120 --> 00:20:37,850
enum takes a an argument of type T and

00:20:35,760 --> 00:20:41,299
so you can use options for any data type

00:20:37,850 --> 00:20:41,299
that's what that means

00:20:45,630 --> 00:20:50,740
and so as you can see from these

00:20:48,970 --> 00:20:54,130
examples I've been giving rust is also

00:20:50,740 --> 00:20:55,510
capable of type inference you pretty

00:20:54,130 --> 00:20:57,250
much never have to actually declare the

00:20:55,510 --> 00:21:02,010
type of variables that you that you need

00:20:57,250 --> 00:21:05,950
to find it doesn't do type inference for

00:21:02,010 --> 00:21:10,660
function signatures and that's pretty

00:21:05,950 --> 00:21:14,590
much because they want to make sure that

00:21:10,660 --> 00:21:17,170
for actual API actual public API that

00:21:14,590 --> 00:21:18,940
you are explicit about that so that you

00:21:17,170 --> 00:21:21,429
make sure that your public API doesn't

00:21:18,940 --> 00:21:23,440
actually accidentally change by you just

00:21:21,429 --> 00:21:31,000
changing some something that adjusts the

00:21:23,440 --> 00:21:33,670
type signature so in addition to the

00:21:31,000 --> 00:21:34,960
basic built-in types like integers and

00:21:33,670 --> 00:21:37,480
floating-point values and things like

00:21:34,960 --> 00:21:41,650
that rust also has a standard library

00:21:37,480 --> 00:21:44,230
with a bunch of useful types here's an

00:21:41,650 --> 00:21:47,140
example of a vector which is basically

00:21:44,230 --> 00:21:49,210
the same it's it's it's approximately

00:21:47,140 --> 00:21:51,730
equivalent to vectors in c++ if you're

00:21:49,210 --> 00:21:56,230
familiar with that it's just a list of

00:21:51,730 --> 00:21:58,150
values that you can potentially it's

00:21:56,230 --> 00:22:02,100
potentially global so you can add new

00:21:58,150 --> 00:22:05,350
things to it here declaring an initial

00:22:02,100 --> 00:22:07,600
vector with 6 8 and 22 and pushing

00:22:05,350 --> 00:22:10,110
another number on to it and you can

00:22:07,600 --> 00:22:13,120
print out the length and you print out

00:22:10,110 --> 00:22:15,360
you can iterate over the values print

00:22:13,120 --> 00:22:15,360
them out

00:22:21,500 --> 00:22:33,990
see here you prints out the the length

00:22:26,460 --> 00:22:35,700
and the values there's also strings you

00:22:33,990 --> 00:22:38,840
can you can modify them and print out

00:22:35,700 --> 00:22:41,100
they also have methods like that

00:22:38,840 --> 00:22:45,480
something to note is that both of these

00:22:41,100 --> 00:22:47,910
examples use special initialization for

00:22:45,480 --> 00:22:51,870
the variables here you have string from

00:22:47,910 --> 00:22:56,030
stir and then from in the vector example

00:22:51,870 --> 00:23:00,210
you have the special Veck back row there

00:22:56,030 --> 00:23:03,420
that's because the default the basic

00:23:00,210 --> 00:23:09,240
type of the upside a string literal

00:23:03,420 --> 00:23:11,910
there or a or an array in rust is is a

00:23:09,240 --> 00:23:13,650
fixed size and so if you want something

00:23:11,910 --> 00:23:16,110
that's capable of growing needs to be

00:23:13,650 --> 00:23:20,970
able to allocate memory elsewhere and

00:23:16,110 --> 00:23:24,420
this is just how you declare a variable

00:23:20,970 --> 00:23:27,770
with that's uh of the type that's

00:23:24,420 --> 00:23:27,770
capable of growing basically

00:23:32,070 --> 00:23:39,040
another thing that you can see here is

00:23:35,050 --> 00:23:42,010
that I'm calling I'm calling methods on

00:23:39,040 --> 00:23:45,520
these variables rest allows you to

00:23:42,010 --> 00:23:48,730
define methods by defining

00:23:45,520 --> 00:23:49,990
implementations of a type so here we

00:23:48,730 --> 00:23:53,559
have the point example that I showed you

00:23:49,990 --> 00:23:56,530
earlier and here i define a an

00:23:53,559 --> 00:23:58,900
implementation imple the keyword

00:23:56,530 --> 00:24:00,850
implementation of the points i define a

00:23:58,900 --> 00:24:03,670
couple of methods on it here the you can

00:24:00,850 --> 00:24:05,830
see the the new the new function there

00:24:03,670 --> 00:24:08,670
is a static function because it doesn't

00:24:05,830 --> 00:24:12,040
have a self parameter the x and y

00:24:08,670 --> 00:24:14,220
methods are actually instance methods

00:24:12,040 --> 00:24:21,190
because they do take a self parameter

00:24:14,220 --> 00:24:23,530
and that you could then you can create a

00:24:21,190 --> 00:24:25,480
new points by calling the point new

00:24:23,530 --> 00:24:29,380
function and then print out the

00:24:25,480 --> 00:24:32,770
different values by calling those those

00:24:29,380 --> 00:24:38,670
methods i just created and that works

00:24:32,770 --> 00:24:38,670
the same way as as the original one did

00:24:40,740 --> 00:24:48,250
these methods are all using static

00:24:43,720 --> 00:24:51,730
dispatch dynamic dispatch is possible in

00:24:48,250 --> 00:24:54,610
rust it does exist but it's a bit more

00:24:51,730 --> 00:24:59,220
complicated and not really in the scope

00:24:54,610 --> 00:24:59,220
of this talk but if you need it is there

00:24:59,340 --> 00:25:04,870
one final aspect to the type system is

00:25:01,960 --> 00:25:07,960
that rush does have traits pretty

00:25:04,870 --> 00:25:10,930
similar to traits in other languages you

00:25:07,960 --> 00:25:13,780
declare a traits your trade area at the

00:25:10,930 --> 00:25:18,190
top which defines that it requires you

00:25:13,780 --> 00:25:19,770
to implement a function called area and

00:25:18,190 --> 00:25:22,240
so you can just you can implement

00:25:19,770 --> 00:25:24,060
implement area for the rectangle strike

00:25:22,240 --> 00:25:28,120
to implement area for the circle struct

00:25:24,060 --> 00:25:31,180
the different implementations there and

00:25:28,120 --> 00:25:33,160
then you can just calculate the area in

00:25:31,180 --> 00:25:36,370
generic way I'm seeing the print area

00:25:33,160 --> 00:25:40,780
function the other thing you do with

00:25:36,370 --> 00:25:43,180
traits is use them as bounds on generic

00:25:40,780 --> 00:25:46,630
types and so here the print area

00:25:43,180 --> 00:25:49,270
function takes any type T as long as it

00:25:46,630 --> 00:25:50,800
implements the area trait and since

00:25:49,270 --> 00:25:52,540
instance you know that influence the

00:25:50,800 --> 00:25:54,790
area trade now you can call the area

00:25:52,540 --> 00:25:58,060
method on it when you're when you're

00:25:54,790 --> 00:26:00,880
printing out the are you printing out

00:25:58,060 --> 00:26:02,440
the area and use and it just prints out

00:26:00,880 --> 00:26:07,720
the area of a circle and an area of a

00:26:02,440 --> 00:26:16,030
rectangle and then you can see what the

00:26:07,720 --> 00:26:19,590
values are traits are also used by the

00:26:16,030 --> 00:26:23,110
the language and the standard library to

00:26:19,590 --> 00:26:27,760
represent this different properties of

00:26:23,110 --> 00:26:31,030
types there's an there's a trait for

00:26:27,760 --> 00:26:34,300
being able to convert into a string

00:26:31,030 --> 00:26:39,910
their trade for being able to test for

00:26:34,300 --> 00:26:41,920
equality there's a trade for most other

00:26:39,910 --> 00:26:44,860
opera operator overloading kind of

00:26:41,920 --> 00:26:46,120
things but those are all handled through

00:26:44,860 --> 00:26:48,370
traits and so you can implement your

00:26:46,120 --> 00:26:49,950
these these specific traits on your new

00:26:48,370 --> 00:26:54,330
types

00:26:49,950 --> 00:26:56,159
you create on so this isn't the details

00:26:54,330 --> 00:26:58,860
of this example here aren't really

00:26:56,159 --> 00:27:02,970
important but this is just showing that

00:26:58,860 --> 00:27:06,330
I can implement the show trait and then

00:27:02,970 --> 00:27:07,769
once I do that the empty curly braces in

00:27:06,330 --> 00:27:09,750
print line can just print out an

00:27:07,769 --> 00:27:14,340
instance of other points on its own

00:27:09,750 --> 00:27:23,909
without having to handle the components

00:27:14,340 --> 00:27:30,059
separately so something that has come up

00:27:23,909 --> 00:27:36,950
a couple times here is the ampersand in

00:27:30,059 --> 00:27:39,240
front of the types this is rust has a

00:27:36,950 --> 00:27:40,649
couple different types of pointers you

00:27:39,240 --> 00:27:41,789
might have heard that that rust has a

00:27:40,649 --> 00:27:43,260
lot of different kind of pointers and

00:27:41,789 --> 00:27:46,110
it's really confusing and everything

00:27:43,260 --> 00:27:47,760
they've done a lot of work in the past

00:27:46,110 --> 00:27:53,370
couple months to really simplify that

00:27:47,760 --> 00:27:56,190
it's really not that bad right now in

00:27:53,370 --> 00:27:58,950
general most of the values that you'll

00:27:56,190 --> 00:28:04,049
be dealing with are just values they

00:27:58,950 --> 00:28:10,289
allocated on the stack so that they do

00:28:04,049 --> 00:28:11,700
not they don't they don't have pointers

00:28:10,289 --> 00:28:15,779
at all you're dealing with the value

00:28:11,700 --> 00:28:17,760
itself and this is this is true for both

00:28:15,779 --> 00:28:19,559
built-in data structures like majors and

00:28:17,760 --> 00:28:21,210
also for more complicated data

00:28:19,559 --> 00:28:24,990
structures like structs and enums and

00:28:21,210 --> 00:28:27,029
that sort of thing and this is good

00:28:24,990 --> 00:28:29,250
because it's really fast but it also has

00:28:27,029 --> 00:28:33,960
limitations in that it requires a lot of

00:28:29,250 --> 00:28:35,880
copying because allocating values on the

00:28:33,960 --> 00:28:37,860
staff like this is that these values are

00:28:35,880 --> 00:28:40,980
only valid within the function that

00:28:37,860 --> 00:28:42,169
they're declared in you can't you can't

00:28:40,980 --> 00:28:44,100
if you if you want to call a function

00:28:42,169 --> 00:28:45,570
with one of those values you have to

00:28:44,100 --> 00:28:46,980
copy it into the function if you want to

00:28:45,570 --> 00:28:49,980
return it you have to copy back and

00:28:46,980 --> 00:28:53,090
there's not normally a problem for small

00:28:49,980 --> 00:28:55,830
data like integers but for bigger data

00:28:53,090 --> 00:28:58,399
doing all that copying is not always a

00:28:55,830 --> 00:28:58,399
great idea

00:29:00,269 --> 00:29:08,230
so and this is why you end up passing

00:29:04,120 --> 00:29:09,640
pointers around so in in rust the type

00:29:08,230 --> 00:29:11,080
of kind of pointer that you'll probably

00:29:09,640 --> 00:29:13,929
running it too most often it's called a

00:29:11,080 --> 00:29:17,260
borrowed pointer what this does is it

00:29:13,929 --> 00:29:19,990
takes a variable that you've declared

00:29:17,260 --> 00:29:21,880
the compiler verifies that when you take

00:29:19,990 --> 00:29:24,549
this borrowed pointer the the pointer

00:29:21,880 --> 00:29:28,480
itself cannot live any longer than the

00:29:24,549 --> 00:29:31,960
variable itself lives if you try and do

00:29:28,480 --> 00:29:34,840
that you'll get a compile-time error and

00:29:31,960 --> 00:29:37,450
so this this this solves the problem

00:29:34,840 --> 00:29:42,340
that you n to instance c and c++ like

00:29:37,450 --> 00:29:44,139
here you declare a variable and then

00:29:42,340 --> 00:29:46,980
return on a stack and you've turned a

00:29:44,139 --> 00:29:50,919
pointer to it the issue here is that

00:29:46,980 --> 00:29:54,909
once once the function foo returns that

00:29:50,919 --> 00:29:56,649
pointer gets deallocated and it no

00:29:54,909 --> 00:29:58,570
longer points to anything meaningful and

00:29:56,649 --> 00:30:02,559
so this is this is a this is a little

00:29:58,570 --> 00:30:04,929
compile just fine in C++ and it'll just

00:30:02,559 --> 00:30:08,500
cause nonsense or seg faults or probably

00:30:04,929 --> 00:30:12,940
that's like false but but just give you

00:30:08,500 --> 00:30:15,159
bad data at runtime so if you try and do

00:30:12,940 --> 00:30:16,630
the same thing in rust here where you

00:30:15,159 --> 00:30:22,289
clear a variable on the stack and you're

00:30:16,630 --> 00:30:22,289
trying to point to it you actually get

00:30:24,630 --> 00:30:31,050
you actually get a compile-time error

00:30:27,650 --> 00:30:33,630
where it says right here variable X does

00:30:31,050 --> 00:30:35,070
not live long enough because it only

00:30:33,630 --> 00:30:36,000
lives through for the scope of that

00:30:35,070 --> 00:30:38,070
function and then you're trying to

00:30:36,000 --> 00:30:47,340
return a pointer to it that will live

00:30:38,070 --> 00:30:48,720
longer than that so in order to to deal

00:30:47,340 --> 00:30:50,070
with the situation like this where you

00:30:48,720 --> 00:30:56,280
actually need something to live longer

00:30:50,070 --> 00:30:57,960
than that there's another kind of you

00:30:56,280 --> 00:31:00,660
basically need to allocate a new chunk

00:30:57,960 --> 00:31:04,220
of memory that will live long enough in

00:31:00,660 --> 00:31:07,890
order to do this rest will allow you to

00:31:04,220 --> 00:31:11,430
explicitly they call it box variables

00:31:07,890 --> 00:31:15,960
which is just allocate a new chunk of

00:31:11,430 --> 00:31:18,990
memory for the variable and then use the

00:31:15,960 --> 00:31:22,920
data in it so here we have the function

00:31:18,990 --> 00:31:24,990
is now returning a boxed integer and you

00:31:22,920 --> 00:31:27,900
declare the third box variables by just

00:31:24,990 --> 00:31:32,970
the box keyword and you can return this

00:31:27,900 --> 00:31:37,290
and this and then return the pointer

00:31:32,970 --> 00:31:38,520
dereference it and this works fine here

00:31:37,290 --> 00:31:44,900
it just prints out the value in that

00:31:38,520 --> 00:31:48,540
that works fine this is not usually how

00:31:44,900 --> 00:31:50,580
ok so this something that you also

00:31:48,540 --> 00:31:52,170
should notice is that there's no action

00:31:50,580 --> 00:31:54,920
there's no explicit deallocation code

00:31:52,170 --> 00:31:57,600
here this isn't actually leaking memory

00:31:54,920 --> 00:32:04,610
the compiler can actually trace through

00:31:57,600 --> 00:32:06,840
the the code and figure out where the

00:32:04,610 --> 00:32:08,730
day is no longer being used and

00:32:06,840 --> 00:32:12,150
automatically inserts the appropriate

00:32:08,730 --> 00:32:14,250
allocation code without requiring

00:32:12,150 --> 00:32:18,170
anything like a garbage collector or

00:32:14,250 --> 00:32:18,170
something to kind of clean up after it

00:32:20,050 --> 00:32:25,700
the way that does this is through a

00:32:23,120 --> 00:32:29,840
concept called ownership and this

00:32:25,700 --> 00:32:33,560
basically means that only one variable

00:32:29,840 --> 00:32:38,150
can be can be holding that that pointer

00:32:33,560 --> 00:32:40,070
at any given time so if you if you try

00:32:38,150 --> 00:32:42,530
and if you try and declare a boxed

00:32:40,070 --> 00:32:51,920
pointer here and then you try to assign

00:32:42,530 --> 00:32:55,100
it to two different variables oops here

00:32:51,920 --> 00:32:57,770
you get um you can error because you're

00:32:55,100 --> 00:33:01,430
trying to use the Move value after you

00:32:57,770 --> 00:33:02,750
after it's already been moved so it when

00:33:01,430 --> 00:33:06,050
you when you're when you're going to do

00:33:02,750 --> 00:33:08,150
an assignment from a boxed variable it

00:33:06,050 --> 00:33:11,180
doesn't actually copy anything it does

00:33:08,150 --> 00:33:16,160
what's called a move and what that means

00:33:11,180 --> 00:33:19,790
is that all you're doing is changing

00:33:16,160 --> 00:33:26,270
which variable can be used to refer to

00:33:19,790 --> 00:33:28,190
the same memory and so if you try if you

00:33:26,270 --> 00:33:29,810
try and do that twice like once you get

00:33:28,190 --> 00:33:34,220
to the line that you're trying to assign

00:33:29,810 --> 00:33:35,720
to Z there x is no longer valid variable

00:33:34,220 --> 00:33:38,860
to use at that point and so you get a

00:33:35,720 --> 00:33:41,720
compiler error and with this restriction

00:33:38,860 --> 00:33:44,600
the compiler can't can easily check and

00:33:41,720 --> 00:33:48,040
see where the variable is no longer

00:33:44,600 --> 00:33:52,060
being used and insert the appropriate

00:33:48,040 --> 00:33:52,060
code to free the memory

00:33:53,630 --> 00:34:01,790
so box variables aren't usually used in

00:33:57,200 --> 00:34:03,290
this kind of a in this kind of code it's

00:34:01,790 --> 00:34:05,480
not usually necessary what they actually

00:34:03,290 --> 00:34:10,490
more useful for is in building data

00:34:05,480 --> 00:34:12,649
structures so if you for example are

00:34:10,490 --> 00:34:16,720
trying to create a list data structure

00:34:12,649 --> 00:34:16,720
like this this actually doesn't work

00:34:17,409 --> 00:34:23,120
because this is a the type is referring

00:34:21,530 --> 00:34:24,710
to itself it's a recursive type and so

00:34:23,120 --> 00:34:26,870
it doesn't actually know how big the

00:34:24,710 --> 00:34:29,570
type has to be because the type contains

00:34:26,870 --> 00:34:32,330
itself and so you can see the error

00:34:29,570 --> 00:34:34,190
message here says that you should it's

00:34:32,330 --> 00:34:35,750
an illegal recursive enum type and you

00:34:34,190 --> 00:34:37,790
should wrap the inner value in a box in

00:34:35,750 --> 00:34:39,740
order to make it representable and since

00:34:37,790 --> 00:34:41,419
since since boxes are always the same

00:34:39,740 --> 00:34:43,820
size they're just they're just a pointer

00:34:41,419 --> 00:34:46,669
it can figure out how big the type needs

00:34:43,820 --> 00:34:49,429
to be and then everything works and so

00:34:46,669 --> 00:34:51,290
you can see here I changed it to a boxed

00:34:49,429 --> 00:35:01,330
the pointer it at the at the end there

00:34:51,290 --> 00:35:01,330
and then this will run fine this

00:35:02,500 --> 00:35:09,160
this also shows an example of a special

00:35:06,400 --> 00:35:11,200
format for print line which works

00:35:09,160 --> 00:35:14,800
basically the st. along the same lines

00:35:11,200 --> 00:35:17,740
as data dumper it uses reflection to

00:35:14,800 --> 00:35:21,760
actually go through the data type that

00:35:17,740 --> 00:35:23,380
doesn't actually have any to string or

00:35:21,760 --> 00:35:26,020
anything like that defined for it just

00:35:23,380 --> 00:35:27,430
any arbitrary data type and goes through

00:35:26,020 --> 00:35:29,350
and figures out just some way to

00:35:27,430 --> 00:35:38,770
represents that you can it's referred

00:35:29,350 --> 00:35:40,660
for debugging mostly and there's so than

00:35:38,770 --> 00:35:42,960
bard pointers and box pointers there's

00:35:40,660 --> 00:35:45,640
also unsafe pointers or raw pointers

00:35:42,960 --> 00:35:47,950
which are pretty much only used for

00:35:45,640 --> 00:35:49,300
interoperability with C and you can

00:35:47,950 --> 00:35:51,940
pretty much ignore their existence

00:35:49,300 --> 00:35:53,890
they're not unless you're writing like C

00:35:51,940 --> 00:35:59,770
bindings they're not they're not used in

00:35:53,890 --> 00:36:03,760
normal rest code something to note here

00:35:59,770 --> 00:36:06,280
is that when you're when you're using

00:36:03,760 --> 00:36:08,710
borrowed and box point and box values

00:36:06,280 --> 00:36:10,300
and things like that the pointers always

00:36:08,710 --> 00:36:13,140
have to be initialized rest doesn't

00:36:10,300 --> 00:36:16,300
actually have the concept of null I

00:36:13,140 --> 00:36:21,550
can't create a null null pointer like

00:36:16,300 --> 00:36:23,560
this you can if you need if you need

00:36:21,550 --> 00:36:26,950
like a pointer that might or might not

00:36:23,560 --> 00:36:28,840
exist you can use the option type and

00:36:26,950 --> 00:36:32,050
rust actually that the compiler actually

00:36:28,840 --> 00:36:36,970
knows that pointers can't be null and

00:36:32,050 --> 00:36:40,480
that the option type has like one extra

00:36:36,970 --> 00:36:43,750
value that doesn't that that isn't a

00:36:40,480 --> 00:36:46,900
valid value about pointer value and so

00:36:43,750 --> 00:36:48,970
it can optimize optional pointers down

00:36:46,900 --> 00:36:50,470
to just a normal normal pointer in terms

00:36:48,970 --> 00:36:53,290
of the code that code that's generators

00:36:50,470 --> 00:36:55,020
this is one another example of the zero

00:36:53,290 --> 00:36:57,700
cost abstractions that was talking about

00:36:55,020 --> 00:37:01,120
you don't you don't actually need to use

00:36:57,700 --> 00:37:03,430
any more memory to represent pointers

00:37:01,120 --> 00:37:07,020
even even though you're using like an

00:37:03,430 --> 00:37:07,020
option in that sense

00:37:07,380 --> 00:37:13,600
one last thing that I wanted to talk

00:37:10,450 --> 00:37:20,010
about is that rust has a lot of effort

00:37:13,600 --> 00:37:20,010
into concurrency West concurrency is

00:37:20,160 --> 00:37:27,880
based on on tasks which can be it

00:37:25,660 --> 00:37:31,200
defaults to using it defaults to having

00:37:27,880 --> 00:37:34,300
tasks that are that map one to one with

00:37:31,200 --> 00:37:37,480
os-level threads but they also have an

00:37:34,300 --> 00:37:42,730
m2n scheduler if you if you need that as

00:37:37,480 --> 00:37:45,850
well the the rest compiler actually uses

00:37:42,730 --> 00:37:47,920
the same kind of ownership semantics

00:37:45,850 --> 00:37:52,630
that I was talking about that uses to

00:37:47,920 --> 00:37:54,700
ensure memory safety in order to ensure

00:37:52,630 --> 00:37:56,680
that there are no data races when

00:37:54,700 --> 00:38:03,100
accessing this the same memory for

00:37:56,680 --> 00:38:14,260
multiple tasks so the basic idea behind

00:38:03,100 --> 00:38:16,510
that is that rest the all day races are

00:38:14,260 --> 00:38:18,460
caused by data that's both mutable and

00:38:16,510 --> 00:38:21,370
alias will at the same time meaning that

00:38:18,460 --> 00:38:24,730
it can be modified and multiple things

00:38:21,370 --> 00:38:26,590
can be modifying at once so any memory

00:38:24,730 --> 00:38:29,260
that's shared between tasks has to

00:38:26,590 --> 00:38:31,210
either be entirely immutable or the task

00:38:29,260 --> 00:38:32,650
or the task that's modifying it has to

00:38:31,210 --> 00:38:34,780
be the only one that's capable of

00:38:32,650 --> 00:38:42,580
modifying at that point and so here's an

00:38:34,780 --> 00:38:45,550
example of a program that spawns spawns

00:38:42,580 --> 00:38:49,390
a new task does something that takes a

00:38:45,550 --> 00:38:52,840
lot of time in the task and in the main

00:38:49,390 --> 00:38:58,150
task it then waits for results and then

00:38:52,840 --> 00:39:01,030
prints it out you can see here the the

00:38:58,150 --> 00:39:04,960
channel the channel function here just

00:39:01,030 --> 00:39:06,730
sets up a basic communication channel

00:39:04,960 --> 00:39:09,730
it's it's basically equivalent to the

00:39:06,730 --> 00:39:12,310
pipe keyword and pearl except it's it's

00:39:09,730 --> 00:39:16,210
an internal thing it's not actually

00:39:12,310 --> 00:39:19,870
using OS little pipes I don't think it

00:39:16,210 --> 00:39:23,730
might be and then spawn spawns a new

00:39:19,870 --> 00:39:27,670
task the proc here is a special keyword

00:39:23,730 --> 00:39:30,930
it's a special type of closure normally

00:39:27,670 --> 00:39:33,370
when a closure in rest closes over

00:39:30,930 --> 00:39:34,990
variables in the environment it takes

00:39:33,370 --> 00:39:38,200
borrowed pointers to the things it

00:39:34,990 --> 00:39:39,880
closes over proc takes owned pointers to

00:39:38,200 --> 00:39:44,200
the things that closes over and so after

00:39:39,880 --> 00:39:46,570
after it closes over variables it takes

00:39:44,200 --> 00:39:48,820
only pointers to mutable things that

00:39:46,570 --> 00:39:53,620
closes over and so once it closes over

00:39:48,820 --> 00:39:55,930
variables you can no longer access it in

00:39:53,620 --> 00:39:58,870
the in the main thread and so here the

00:39:55,930 --> 00:40:00,940
proc is closing over the right the right

00:39:58,870 --> 00:40:03,370
end of the pipe and so if you try to

00:40:00,940 --> 00:40:06,250
write to if you try to access the right

00:40:03,370 --> 00:40:08,260
the right the writer into the pipe the

00:40:06,250 --> 00:40:10,090
channel in the main thread you get a

00:40:08,260 --> 00:40:11,320
compiler error because only one thing to

00:40:10,090 --> 00:40:13,480
be writing at the same time and the same

00:40:11,320 --> 00:40:15,040
thing here the main presence trying to

00:40:13,480 --> 00:40:15,690
read from the pipe and if you try to

00:40:15,040 --> 00:40:17,550
read from

00:40:15,690 --> 00:40:18,990
the image in the subject or any other

00:40:17,550 --> 00:40:21,030
subject that you that you spawned in

00:40:18,990 --> 00:40:22,650
this way you get an you get an error and

00:40:21,030 --> 00:40:24,420
so you know the only one thing can be

00:40:22,650 --> 00:40:27,750
writing and reading from the pipe at

00:40:24,420 --> 00:40:33,569
once you can also see that the it is

00:40:27,750 --> 00:40:34,950
closing over the m and n variables but

00:40:33,569 --> 00:40:36,900
that's okay because they're just

00:40:34,950 --> 00:40:39,569
immutable data and so you can use them

00:40:36,900 --> 00:40:43,020
both in the in the main task down here

00:40:39,569 --> 00:40:43,950
and in the in the subtask up there and

00:40:43,020 --> 00:40:45,180
that's and that's fine because that's

00:40:43,950 --> 00:40:46,140
just a mean little data and that's not

00:40:45,180 --> 00:40:50,400
actually that actually going to cause a

00:40:46,140 --> 00:40:53,339
problem and so you can see this running

00:40:50,400 --> 00:40:59,630
here it calculates and then prints out

00:40:53,339 --> 00:41:02,670
the value and so that that's kind of

00:40:59,630 --> 00:41:06,480
most of the main features that rest has

00:41:02,670 --> 00:41:09,000
rust also has has other things like it

00:41:06,480 --> 00:41:11,940
has name spacing in a module system has

00:41:09,000 --> 00:41:13,800
privacy controls it has integrated

00:41:11,940 --> 00:41:15,839
testing and benchmarks which are pretty

00:41:13,800 --> 00:41:17,550
cool you can have you can write your

00:41:15,839 --> 00:41:19,560
tests in line with your code and have

00:41:17,550 --> 00:41:22,589
them executed by the compiler with the

00:41:19,560 --> 00:41:27,000
special flags the compiler itself has a

00:41:22,589 --> 00:41:29,220
lot of they call lint checks which are

00:41:27,000 --> 00:41:31,290
basically extra warnings that you can

00:41:29,220 --> 00:41:35,339
add you can make them individually into

00:41:31,290 --> 00:41:40,849
errors or ignored or whatever for things

00:41:35,339 --> 00:41:43,140
from basic like style issues to

00:41:40,849 --> 00:41:44,099
disabling large parts of the language

00:41:43,140 --> 00:41:46,910
that you might want to ensure that

00:41:44,099 --> 00:41:48,599
you're probably doesn't use like

00:41:46,910 --> 00:41:52,710
allocation if you're writing like a

00:41:48,599 --> 00:41:56,160
embedded system things like that the

00:41:52,710 --> 00:42:00,240
entire run time like I said can can be

00:41:56,160 --> 00:42:02,430
left out or re implemented in a more in

00:42:00,240 --> 00:42:05,460
a simpler way or to support being run on

00:42:02,430 --> 00:42:07,589
on systems we're getting the entire

00:42:05,460 --> 00:42:10,050
runtime up and running isn't always

00:42:07,589 --> 00:42:13,140
possible there's already existing

00:42:10,050 --> 00:42:14,790
projects that can run that to run to

00:42:13,140 --> 00:42:17,040
write a colonel in route like an

00:42:14,790 --> 00:42:19,470
operating system kernel and rust and to

00:42:17,040 --> 00:42:21,180
run rushed on Rusko down like an arduino

00:42:19,470 --> 00:42:24,810
things like that and that's that's

00:42:21,180 --> 00:42:25,960
already that's already working rust has

00:42:24,810 --> 00:42:28,660
macro

00:42:25,960 --> 00:42:33,400
powerful macro system available to use

00:42:28,660 --> 00:42:35,619
your space code to use your code it's

00:42:33,400 --> 00:42:38,950
it's powerful enough to implement a lot

00:42:35,619 --> 00:42:40,810
of really useful things but anything you

00:42:38,950 --> 00:42:47,740
see here like the that ends with an

00:42:40,810 --> 00:42:50,349
exclamation mark is a macro and it bends

00:42:47,740 --> 00:42:52,660
it that all macros always show up in

00:42:50,349 --> 00:42:55,420
this form where it's an identifier and !

00:42:52,660 --> 00:42:58,150
and then balanced parentheses of some

00:42:55,420 --> 00:43:00,609
kind so external tools still are still

00:42:58,150 --> 00:43:05,650
able to parse the overall code which is

00:43:00,609 --> 00:43:08,260
a useful property to have and the

00:43:05,650 --> 00:43:12,400
language itself is also very flexible on

00:43:08,260 --> 00:43:15,280
its own most of the language features

00:43:12,400 --> 00:43:17,260
are employed via normal rust functions

00:43:15,280 --> 00:43:19,210
either through traits like I mentioned

00:43:17,260 --> 00:43:24,820
earlier for things like operator

00:43:19,210 --> 00:43:27,849
overloading on custom types or via they

00:43:24,820 --> 00:43:30,430
call language items for low-level

00:43:27,849 --> 00:43:35,230
operations like allocating memory and

00:43:30,430 --> 00:43:37,900
and handling failure that and that sort

00:43:35,230 --> 00:43:41,440
of thing and so it's it's very flexible

00:43:37,900 --> 00:43:45,630
you can win however you really need to

00:43:41,440 --> 00:43:50,560
get it to run wherever it needs to run

00:43:45,630 --> 00:43:53,890
so if you're interested in learning more

00:43:50,560 --> 00:43:57,280
about rust here's a bunch of useful

00:43:53,890 --> 00:43:59,339
websites a good start for the language

00:43:57,280 --> 00:44:04,330
there's a tutorial on the rest website

00:43:59,339 --> 00:44:06,220
there's also a rust in 30 minutes kind

00:44:04,330 --> 00:44:08,470
of an overview of the basic concepts

00:44:06,220 --> 00:44:14,970
I'll just just get a an idea of what the

00:44:08,470 --> 00:44:19,150
languages like they have and a web-based

00:44:14,970 --> 00:44:23,710
repple on plate at rest langa org and

00:44:19,150 --> 00:44:27,390
rust by example has a lot of rest by

00:44:23,710 --> 00:44:27,390
example there has a lot of useful

00:44:28,059 --> 00:44:31,959
examples that you can run in the repple

00:44:30,430 --> 00:44:34,029
to see how different parts of language

00:44:31,959 --> 00:44:35,709
work if you're interested in getting

00:44:34,029 --> 00:44:37,930
into russ development it's developed

00:44:35,709 --> 00:44:40,630
entirely openly it's very welcoming of

00:44:37,930 --> 00:44:43,269
new contributors discussion happens on

00:44:40,630 --> 00:44:47,019
IRC on the rest channel on the most on

00:44:43,269 --> 00:44:52,660
Mozilla's IRC network there's a rust dev

00:44:47,019 --> 00:44:54,519
mailing list and Mozilla the the rust

00:44:52,660 --> 00:44:58,749
team in Mozilla research has all their

00:44:54,519 --> 00:45:00,160
meetings openly every week sort for

00:44:58,749 --> 00:45:02,499
making actual decisions about where the

00:45:00,160 --> 00:45:07,390
language is going for keeping up with

00:45:02,499 --> 00:45:11,949
the language itself there's blog that

00:45:07,390 --> 00:45:15,269
octane that net is has a it has a series

00:45:11,949 --> 00:45:18,009
of this week and rust posts which just

00:45:15,269 --> 00:45:20,380
keeps keeps you updated on things that

00:45:18,009 --> 00:45:23,439
might have changed in the past week it's

00:45:20,380 --> 00:45:26,109
still that that's kind of slowing down

00:45:23,439 --> 00:45:28,359
these days but there's there still are

00:45:26,109 --> 00:45:29,769
things that are changing and so that's a

00:45:28,359 --> 00:45:32,189
good way to keep up with that if you're

00:45:29,769 --> 00:45:39,699
not actually following the community

00:45:32,189 --> 00:45:42,299
regularly and and this this last step in

00:45:39,699 --> 00:45:46,959
terms of getting involved in development

00:45:42,299 --> 00:45:49,359
the github wiki has a whole list of

00:45:46,959 --> 00:45:51,449
things to know about when you're when

00:45:49,359 --> 00:45:54,309
you're getting involved rust has a

00:45:51,449 --> 00:45:58,179
community standards of conduct that is

00:45:54,309 --> 00:46:00,670
very well enforced by the rust team and

00:45:58,179 --> 00:46:04,089
that in my experience has made the the

00:46:00,670 --> 00:46:06,729
rust community one of the most friendly

00:46:04,089 --> 00:46:12,009
and pleasant programming communities

00:46:06,729 --> 00:46:13,569
I've seen and so if anything here

00:46:12,009 --> 00:46:17,709
sounded interesting to you I highly

00:46:13,569 --> 00:46:22,140
recommend getting involved yeah any

00:46:17,709 --> 00:46:22,140
questions yeah

00:46:27,330 --> 00:46:35,760
yep did not push about the function yeah

00:46:32,630 --> 00:46:37,200
how is it returning the value and I see

00:46:35,760 --> 00:46:39,540
it declares it or return to you wait

00:46:37,200 --> 00:46:41,700
yeah so it's saying the same as in same

00:46:39,540 --> 00:46:44,100
as in Perl everything oh you don't

00:46:41,700 --> 00:46:47,040
actually have to return yeah yeah and

00:46:44,100 --> 00:46:49,380
and rest is also an expression based

00:46:47,040 --> 00:46:51,810
language so every all the control

00:46:49,380 --> 00:46:55,230
structures are also expressions and so

00:46:51,810 --> 00:47:00,300
the match this returns whatever it yeah

00:46:55,230 --> 00:47:04,050
yeah yeah yeah yeah features too close

00:47:00,300 --> 00:47:06,590
to this role um so yeah they're they're

00:47:04,050 --> 00:47:09,150
actually they're pretty close to moose

00:47:06,590 --> 00:47:10,950
roles ish I mean they're they're they're

00:47:09,150 --> 00:47:12,180
more than there are more than interfaces

00:47:10,950 --> 00:47:15,230
in that you can do things like have

00:47:12,180 --> 00:47:17,070
default implementations um you can't I

00:47:15,230 --> 00:47:19,560
don't believe you can have data

00:47:17,070 --> 00:47:20,430
associated with them but yeah they're

00:47:19,560 --> 00:47:31,040
kind they're kind of halfway in between

00:47:20,430 --> 00:47:31,040
yeah anything else alright thanks

00:47:33,490 --> 00:47:35,520

YouTube URL: https://www.youtube.com/watch?v=5EFCMaEbgX4


