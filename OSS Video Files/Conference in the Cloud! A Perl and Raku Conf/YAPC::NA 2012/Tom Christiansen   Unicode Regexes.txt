Title: Tom Christiansen   Unicode Regexes
Publication date: 2013-08-20
Playlist: YAPC::NA 2012
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:09,030
 is slow it's one-thirty so we'll

00:00:03,270 --> 00:00:12,509
get started if you guys get a headache

00:00:09,030 --> 00:00:14,490
looking at the flickering screen pull in

00:00:12,509 --> 00:00:23,369
the slides from that URL if you want to

00:00:14,490 --> 00:00:27,660
look at them on your own laptop is yes

00:00:23,369 --> 00:00:33,300
it's problem can I fix that there's

00:00:27,660 --> 00:00:36,300
something against all the URL all that's

00:00:33,300 --> 00:00:42,719
in there are trading up rolla column /

00:00:36,300 --> 00:01:01,829
all caps yep cya pc 2012 2012 / all

00:00:42,719 --> 00:01:18,390
lowercase u PR dot HTML that's probably

00:01:01,829 --> 00:01:20,310
not even any easier to see he's

00:01:18,390 --> 00:01:23,540
rearranged the page and look at it we

00:01:20,310 --> 00:01:23,540
looked at what it is now

00:01:41,689 --> 00:01:47,250
if you don't have I mean if you don't

00:01:44,280 --> 00:01:49,680
have as long as you have the I've done a

00:01:47,250 --> 00:01:53,490
thing a bad thing in this presentation

00:01:49,680 --> 00:01:58,170
because the font that i'm using if I

00:01:53,490 --> 00:02:03,630
don't so HTML sucks for anything like

00:01:58,170 --> 00:02:07,080
typography you know this so the font I'm

00:02:03,630 --> 00:02:12,209
using has you're supposed to

00:02:07,080 --> 00:02:15,209
automatically select the the ligatures

00:02:12,209 --> 00:02:17,130
and the font and if you use InDesign or

00:02:15,209 --> 00:02:20,370
anything reasonable it will do that you

00:02:17,130 --> 00:02:24,840
don't have to mess with it but hTML is

00:02:20,370 --> 00:02:28,250
done so you get letters that collide and

00:02:24,840 --> 00:02:32,160
look bad so I manually selected the

00:02:28,250 --> 00:02:34,019
stupid unicorn legacy ligatures so that

00:02:32,160 --> 00:02:35,190
it does the right thing in the font but

00:02:34,019 --> 00:02:39,450
if you don't have a father's legacy

00:02:35,190 --> 00:02:41,160
ligatures now you screwed again so okay

00:02:39,450 --> 00:02:43,950
so what are we going to talk about we

00:02:41,160 --> 00:02:47,880
will be talking mostly about pattern

00:02:43,950 --> 00:02:57,299
matching ah in Perl and how it relates

00:02:47,880 --> 00:03:04,350
to unicode um there is no next talk I'm

00:02:57,299 --> 00:03:05,940
going I first gave this a toss con last

00:03:04,350 --> 00:03:09,030
year and i've updated a little bit but

00:03:05,940 --> 00:03:12,750
there is no next time we are not going

00:03:09,030 --> 00:03:14,640
to talk about we're only going to do

00:03:12,750 --> 00:03:16,590
really simple regular expressions here

00:03:14,640 --> 00:03:22,290
we're not going to do fancy stuff like

00:03:16,590 --> 00:03:25,109
that one that's a regular expression

00:03:22,290 --> 00:03:30,810
that decides whether you are looking at

00:03:25,109 --> 00:03:33,510
a reducible fraction like 12 / 48 is

00:03:30,810 --> 00:03:36,420
reducible to one-quarter right that that

00:03:33,510 --> 00:03:40,519
pattern decides that we won't be doing

00:03:36,420 --> 00:03:40,519
any fun things like that in this class a

00:03:41,329 --> 00:03:47,630
little bit of setup when you're working

00:03:44,760 --> 00:03:47,630
with unicode

00:03:50,980 --> 00:04:00,230
at the top of your program you're going

00:03:55,520 --> 00:04:04,430
to want to say use utf-8 say that the

00:04:00,230 --> 00:04:10,430
program literals are actually encoded in

00:04:04,430 --> 00:04:13,400
utf-8 um and I strongly suggest that you

00:04:10,430 --> 00:04:17,299
always say what version of Perl that you

00:04:13,400 --> 00:04:21,340
have written that the code you have just

00:04:17,299 --> 00:04:25,460
written is known to run correctly on um

00:04:21,340 --> 00:04:27,320
so you know do a pro dash V see what

00:04:25,460 --> 00:04:30,110
you're writing and put it use that

00:04:27,320 --> 00:04:34,370
version so the next time when somebody

00:04:30,110 --> 00:04:39,950
comes along they'll not be quite so

00:04:34,370 --> 00:04:43,760
surprised there is a char names pragma

00:04:39,950 --> 00:04:48,410
that we don't need to use starting in

00:04:43,760 --> 00:04:53,930
five got 16 if you are content with use

00:04:48,410 --> 00:04:56,960
char games full and short and that's so

00:04:53,930 --> 00:05:04,220
that your back / capital n works with

00:04:56,960 --> 00:05:10,490
unicode names to deal with encoded input

00:05:04,220 --> 00:05:16,160
and output you can put a use open pragma

00:05:10,490 --> 00:05:18,800
in your program be warned that use auto

00:05:16,160 --> 00:05:26,210
die and use open do not play well

00:05:18,800 --> 00:05:33,500
together I forget the exact failure mode

00:05:26,210 --> 00:05:35,750
but it's just not usable I think it he

00:05:33,500 --> 00:05:37,190
you either you only get one of the two

00:05:35,750 --> 00:05:42,020
things and doesn't matter the order you

00:05:37,190 --> 00:05:43,550
put them in I think you do stick the

00:05:42,020 --> 00:05:47,419
auto die but you no longer get an

00:05:43,550 --> 00:05:49,310
encoding layer which is of no use and

00:05:47,419 --> 00:05:54,080
the other one the other directions don't

00:05:49,310 --> 00:05:56,419
much use other another thing you can do

00:05:54,080 --> 00:06:00,010
there is a unit pearl Unicode

00:05:56,419 --> 00:06:01,670
environment variable that if you set it

00:06:00,010 --> 00:06:06,380
will all

00:06:01,670 --> 00:06:12,340
matically with an A capitulate means

00:06:06,380 --> 00:06:16,370
automatically code your RV as utf-8

00:06:12,340 --> 00:06:23,210
capital S is the same as saying use open

00:06:16,370 --> 00:06:26,390
call in utf-8 colon STD and they often

00:06:23,210 --> 00:06:29,180
forgotten her a little-known aspect of

00:06:26,390 --> 00:06:34,970
use open that when you say use open it

00:06:29,180 --> 00:06:37,550
also affects your back tech stuff that

00:06:34,970 --> 00:06:49,580
will also be automatically decoded as

00:06:37,550 --> 00:06:51,110
utf-8 so here's a little sample of the

00:06:49,580 --> 00:06:53,840
kind of setup you would do if you're

00:06:51,110 --> 00:06:57,230
doing a simple UNIX filter program read

00:06:53,840 --> 00:06:59,750
from standard en or RV other thing comes

00:06:57,230 --> 00:07:03,920
in do something with it send it back out

00:06:59,750 --> 00:07:09,620
again as we'll discuss in just a couple

00:07:03,920 --> 00:07:13,490
seconds you can have strings that are

00:07:09,620 --> 00:07:16,160
not binary identical but are considered

00:07:13,490 --> 00:07:19,850
canonically equivalent is what it's

00:07:16,160 --> 00:07:24,650
called in Unicode so in order not to go

00:07:19,850 --> 00:07:28,880
nuts ah oui you should kick a

00:07:24,650 --> 00:07:33,470
normalization form and I good reasons to

00:07:28,880 --> 00:07:36,800
jest NFD the G pick one and when it

00:07:33,470 --> 00:07:39,830
comes in no matter always normalize it

00:07:36,800 --> 00:07:41,570
to one particular normalization form is

00:07:39,830 --> 00:07:43,820
otherwise you aren't going to be able to

00:07:41,570 --> 00:07:46,670
write regular expressions or you won't

00:07:43,820 --> 00:07:50,390
want to if you don't know the

00:07:46,670 --> 00:07:59,140
normalization because more things

00:07:50,390 --> 00:07:59,140
support NFC browsers fonts blah blah um

00:07:59,170 --> 00:08:05,600
it's probably a good idea to put it into

00:08:01,640 --> 00:08:09,560
NFC on the way out yes it takes time to

00:08:05,600 --> 00:08:11,210
do this but if you if it didn't matter

00:08:09,560 --> 00:08:13,780
whether it's correct I can make it as

00:08:11,210 --> 00:08:13,780
fast as you want

00:08:14,360 --> 00:08:24,469
it's not that slow oh let's make this

00:08:18,770 --> 00:08:26,330
easier to read I can write obviously I

00:08:24,469 --> 00:08:34,760
didn't develop the slides this really

00:08:26,330 --> 00:08:43,610
solution I just did oh well alright so

00:08:34,760 --> 00:08:46,130
in Unicode a user visible character may

00:08:43,610 --> 00:08:53,540
occupy several different code points

00:08:46,130 --> 00:08:56,450
mirek characters so for example this guy

00:08:53,540 --> 00:09:01,820
right here which is an old with the

00:08:56,450 --> 00:09:05,350
tilde stacked on top of it with a macron

00:09:01,820 --> 00:09:08,600
a straight line stacked on top of that

00:09:05,350 --> 00:09:15,320
and it's one user visible character it's

00:09:08,600 --> 00:09:18,860
got three different pieces so how that

00:09:15,320 --> 00:09:21,410
comes into your program can vary a great

00:09:18,860 --> 00:09:28,160
deal it might come in as a single code

00:09:21,410 --> 00:09:32,920
point on to 2d then you don't get one it

00:09:28,160 --> 00:09:36,529
might come in is three code points it

00:09:32,920 --> 00:09:42,170
might even come in as to code points

00:09:36,529 --> 00:09:44,779
because hex f5 is a precomposed Oh with

00:09:42,170 --> 00:09:50,690
Attila and then three or four means add

00:09:44,779 --> 00:09:54,110
the map wrong whereas 6f is the 03 03 is

00:09:50,690 --> 00:09:58,310
at the tilde 304 is at the metron so you

00:09:54,110 --> 00:09:59,870
might have one two or three code points

00:09:58,310 --> 00:10:06,380
coming in but it's just one user

00:09:59,870 --> 00:10:09,290
character on graphing if you don't

00:10:06,380 --> 00:10:13,250
normalize you need to figure out a way

00:10:09,290 --> 00:10:15,860
of matching any of those cuz dot in the

00:10:13,250 --> 00:10:21,110
regular expression library will only

00:10:15,860 --> 00:10:24,459
match a single code point we have a

00:10:21,110 --> 00:10:27,329
special escape called backside capital X

00:10:24,459 --> 00:10:32,369
which is specifically made

00:10:27,329 --> 00:10:35,429
for this sort of situation so back slash

00:10:32,369 --> 00:10:42,660
X would match any of those three

00:10:35,429 --> 00:10:47,480
versions that same glyph so backslash

00:10:42,660 --> 00:10:53,959
x-men matches a graphene cluster which

00:10:47,480 --> 00:10:58,429
for the most part means a base character

00:10:53,959 --> 00:11:06,329
with any number including zero

00:10:58,429 --> 00:11:09,299
diacritics added to it originally we

00:11:06,329 --> 00:11:13,739
used a definition for a graphene which

00:11:09,299 --> 00:11:17,549
was that little incantation there which

00:11:13,739 --> 00:11:20,999
says a non combining mark followed by

00:11:17,549 --> 00:11:24,239
any number of combining marks do not use

00:11:20,999 --> 00:11:28,139
that because you get nonsense things

00:11:24,239 --> 00:11:30,449
going on for example that technically

00:11:28,139 --> 00:11:34,189
matches a line feed followed by a

00:11:30,449 --> 00:11:36,509
combining tilde which is nonsense

00:11:34,189 --> 00:11:42,299
whereas backslash Jax knows better than

00:11:36,509 --> 00:11:46,470
to do silly things like that so these

00:11:42,299 --> 00:11:50,509
normalization functions are in the

00:11:46,470 --> 00:11:53,730
standard library Unicode normalized and

00:11:50,509 --> 00:11:56,959
if so if you just say use Unicode

00:11:53,730 --> 00:12:02,660
normalize you'll get n fdn NFC there are

00:11:56,959 --> 00:12:06,779
another pair of functions so NFD is

00:12:02,660 --> 00:12:09,119
canonical decomposition and thurs NFC

00:12:06,779 --> 00:12:14,869
except NFC is then followed by canonical

00:12:09,119 --> 00:12:18,089
composition the K in these two functions

00:12:14,869 --> 00:12:19,919
sends for compatibility and I don't know

00:12:18,089 --> 00:12:22,230
what language it's in but they already

00:12:19,919 --> 00:12:28,759
use C so they had to use another letter

00:12:22,230 --> 00:12:34,230
and the compatibility decompositions aw

00:12:28,759 --> 00:12:35,939
take care of things like the three the

00:12:34,230 --> 00:12:37,679
code point that means three quarters

00:12:35,939 --> 00:12:40,750
when you do a compatibility

00:12:37,679 --> 00:12:45,430
decomposition on it you get free

00:12:40,750 --> 00:12:48,670
then a slash then a four if you have

00:12:45,430 --> 00:12:50,440
super scripts or subscripts those get

00:12:48,670 --> 00:12:56,380
flattened by out to your baseline

00:12:50,440 --> 00:13:00,040
character so for the most part you can

00:12:56,380 --> 00:13:04,900
trade back and forth between MS CFD you

00:13:00,040 --> 00:13:10,210
won't lose any information please don't

00:13:04,900 --> 00:13:14,800
bring up Singleton's but with the

00:13:10,210 --> 00:13:18,670
compatibility forms you do because if

00:13:14,800 --> 00:13:25,480
you flatten out 20 with superscript th

00:13:18,670 --> 00:13:27,370
into 20 th you can't after you've done

00:13:25,480 --> 00:13:29,350
Katy you can't do Casey and it put the

00:13:27,370 --> 00:13:32,110
back with the superscripts again it

00:13:29,350 --> 00:13:34,450
wouldn't know to do that so there are

00:13:32,110 --> 00:13:37,830
times that the compatibility things are

00:13:34,450 --> 00:13:42,880
useful in general they are useful for

00:13:37,830 --> 00:13:46,600
searching so that you don't have to be

00:13:42,880 --> 00:13:48,940
sensitive to which version of something

00:13:46,600 --> 00:13:50,500
is in there just be aware that it does

00:13:48,940 --> 00:13:54,490
lose information and you won't be able

00:13:50,500 --> 00:14:01,060
to get it back again Python when it

00:13:54,490 --> 00:14:04,060
reads in a Python source that's much to

00:14:01,060 --> 00:14:09,190
be utf-8 encoded they send everything

00:14:04,060 --> 00:14:11,080
through nfk sea pearl does none of that

00:14:09,190 --> 00:14:13,740
when you say you TIA when you say use

00:14:11,080 --> 00:14:17,530
utf-8 you can put yuna coating your

00:14:13,740 --> 00:14:22,960
utf-8 unicode in your script or your

00:14:17,530 --> 00:14:25,270
module or whatever nope no normalization

00:14:22,960 --> 00:14:28,360
is enforced so it's up to you to be

00:14:25,270 --> 00:14:30,610
smart enough to be consistent because

00:14:28,360 --> 00:14:38,650
otherwise things won't be the same

00:14:30,610 --> 00:14:47,860
between files yes yes yes that's what it

00:14:38,650 --> 00:14:51,820
means yeah so baby didn't burn the same

00:14:47,860 --> 00:14:55,030
no they were mostly the same of

00:14:51,820 --> 00:14:57,610
just the economically equivalent in

00:14:55,030 --> 00:15:07,260
their names and pearl does not respect

00:14:57,610 --> 00:15:07,260
canonical equivalents should it probably

00:15:08,400 --> 00:15:15,210
so if you're in bi you say colon a

00:15:16,440 --> 00:15:22,570
percent pipe NFD you know we'll run the

00:15:20,230 --> 00:15:24,880
whole thing from zone or NFC you just

00:15:22,570 --> 00:15:26,470
pick one but would it show everyone you

00:15:24,880 --> 00:15:30,550
pick you have to do the same about your

00:15:26,470 --> 00:15:38,680
products because you think of the

00:15:30,550 --> 00:15:42,480
symmetry files won't be right one reason

00:15:38,680 --> 00:15:42,480
you might not want to do that is because

00:15:44,040 --> 00:15:50,950
in a regular expression you might want

00:15:46,870 --> 00:15:54,640
to match something that is only the NFD

00:15:50,950 --> 00:15:57,190
form or only the NFC Forum so if you are

00:15:54,640 --> 00:16:01,710
if it automatically did that you

00:15:57,190 --> 00:16:01,710
wouldn't you would be unhappy there oh

00:16:02,010 --> 00:16:06,910
yeah so the funny math letters that

00:16:05,410 --> 00:16:14,760
you're not supposed to use for regular

00:16:06,910 --> 00:16:14,760
text turn into regular trash okay so

00:16:15,420 --> 00:16:29,740
here's an example of at least one crappy

00:16:22,510 --> 00:16:33,100
may be civil so the glyph that you're

00:16:29,740 --> 00:16:37,110
looking at it in the glyph column is

00:16:33,100 --> 00:16:38,980
what's on your screen and as you see

00:16:37,110 --> 00:16:41,230
there's just no difference between

00:16:38,980 --> 00:16:45,940
wanting to you cannot look at it in

00:16:41,230 --> 00:16:55,870
though the difference um now what about

00:16:45,940 --> 00:17:00,490
the rest of them Oh 3 and okay you got

00:16:55,870 --> 00:17:04,089
it stand really close before if I have

00:17:00,490 --> 00:17:05,270
the map right on top 5 and 6 have the

00:17:04,089 --> 00:17:10,130
tilde on top

00:17:05,270 --> 00:17:13,220
and that actually those are different so

00:17:10,130 --> 00:17:18,610
we owe three sets of graphene's here

00:17:13,220 --> 00:17:20,959
this one these three and these two and

00:17:18,610 --> 00:17:23,120
both of these are canonical equivalent

00:17:20,959 --> 00:17:24,980
to each other all three of these are

00:17:23,120 --> 00:17:26,959
canonically equivalent to each other and

00:17:24,980 --> 00:17:36,110
both of those are canonical equivalent

00:17:26,959 --> 00:17:39,230
to each other and check marks tell you

00:17:36,110 --> 00:17:44,900
whether some weather as written these

00:17:39,230 --> 00:17:46,520
literals are in either an FDR NFC the

00:17:44,900 --> 00:17:50,420
interesting one perhaps is this one

00:17:46,520 --> 00:17:54,110
which is in neither so don't you can get

00:17:50,420 --> 00:17:57,050
perfectly legal glyphs that are not

00:17:54,110 --> 00:18:01,400
normalized but that's not a

00:17:57,050 --> 00:18:03,380
normalization board and the amount of

00:18:01,400 --> 00:18:10,400
number core point these can take up very

00:18:03,380 --> 00:18:12,710
soon one and three how do you know how

00:18:10,400 --> 00:18:23,840
would you write a regular expression to

00:18:12,710 --> 00:18:27,230
match any of three four five so let's

00:18:23,840 --> 00:18:29,990
say you get everything you read in you

00:18:27,230 --> 00:18:34,180
enforce the NFD on if you did that then

00:18:29,990 --> 00:18:37,220
number one and two will show up as two

00:18:34,180 --> 00:18:40,130
three four five they'll all show up as

00:18:37,220 --> 00:18:48,200
five and six and seven they'll all show

00:18:40,130 --> 00:18:49,760
up itself is six and yes the number for

00:18:48,200 --> 00:18:54,340
the middle one is is in neither

00:18:49,760 --> 00:18:56,540
normalization put just always normalize

00:18:54,340 --> 00:19:00,830
so how do you write reg ex is to match

00:18:56,540 --> 00:19:08,570
these things well that here's the easy

00:19:00,830 --> 00:19:12,790
one okay carrot-o which of those seven

00:19:08,570 --> 00:19:12,790
are matched by carrot-o

00:19:15,320 --> 00:19:22,590
there's a there's no there's no there's

00:19:18,480 --> 00:19:28,920
no you wouldn't get any of those guys

00:19:22,590 --> 00:19:31,830
that's why you always put into NFD on

00:19:28,920 --> 00:19:35,760
the way in so to match a graphing which

00:19:31,830 --> 00:19:40,200
is an old base letter with any combining

00:19:35,760 --> 00:19:44,090
marks know if you haven't done a

00:19:40,200 --> 00:19:44,090
decomposition on it I'm going to do that

00:19:44,720 --> 00:19:53,660
before you want to always decompose the

00:19:47,040 --> 00:19:57,000
other way as you can match things mmm Oh

00:19:53,660 --> 00:20:00,240
with the combining tilde well that we'll

00:19:57,000 --> 00:20:01,650
get the first five but we'll miss six

00:20:00,240 --> 00:20:07,350
and seven now this is very interesting

00:20:01,650 --> 00:20:09,120
because these bottom two you might think

00:20:07,350 --> 00:20:13,230
that those are always with combining

00:20:09,120 --> 00:20:23,990
Tilda's and macros and they are except

00:20:13,230 --> 00:20:27,540
um when they're canonically decomposed

00:20:23,990 --> 00:20:30,300
you've got first do then the macron then

00:20:27,540 --> 00:20:36,810
the tilde all these canonical things

00:20:30,300 --> 00:20:38,940
will reorder your diacritics and if

00:20:36,810 --> 00:20:41,310
they're this if they go on the same

00:20:38,940 --> 00:20:45,990
place on the letter so all the ones that

00:20:41,310 --> 00:20:47,910
go on top do not they don't get reorder

00:20:45,990 --> 00:20:51,600
so if you say first a macro and then a

00:20:47,910 --> 00:20:53,360
chisel versus first to tilt and then a

00:20:51,600 --> 00:20:57,720
macro those are two different graphemes

00:20:53,360 --> 00:21:00,030
but if you said I want 2 tilde and I

00:20:57,720 --> 00:21:01,470
want ASA deal underneath well that

00:21:00,030 --> 00:21:04,320
attaches at the bottom versus one

00:21:01,470 --> 00:21:07,610
attaching at the top now it doesn't now

00:21:04,320 --> 00:21:10,320
somebody could give those to you and

00:21:07,610 --> 00:21:12,690
they'd specify the marks in different

00:21:10,320 --> 00:21:16,170
orders when you canonicalize it it will

00:21:12,690 --> 00:21:19,590
order them the combining marks because

00:21:16,170 --> 00:21:21,950
they're in different classes but if they

00:21:19,590 --> 00:21:25,920
go on the same place on the letter it

00:21:21,950 --> 00:21:28,650
does matter what order the code points

00:21:25,920 --> 00:21:29,970
current because you

00:21:28,650 --> 00:21:33,350
the way it's supposed to be laid out if

00:21:29,970 --> 00:21:33,350
they're supposed to stack up differently

00:21:34,250 --> 00:21:46,260
so this says find me something starts

00:21:42,570 --> 00:21:49,620
with an o that might have some combining

00:21:46,260 --> 00:21:55,070
marks i don't know but does have what's

00:21:49,620 --> 00:21:59,210
back / x I don't know how that happened

00:21:55,070 --> 00:21:59,210
those should be back sighs capital ends

00:21:59,270 --> 00:22:05,220
backslash capital and combining tilde so

00:22:02,280 --> 00:22:08,280
that way you don't care if there are

00:22:05,220 --> 00:22:13,980
other marks between your tilde and your

00:22:08,280 --> 00:22:24,660
base character again this this is just a

00:22:13,980 --> 00:22:26,790
stab it gets hard after this like it

00:22:24,660 --> 00:22:29,280
probably shouldn't have said combining

00:22:26,790 --> 00:22:34,860
mark I probably should have said

00:22:29,280 --> 00:22:41,400
graphing extend this is so much easier

00:22:34,860 --> 00:22:46,910
to write back / p.m. then back / p curly

00:22:41,400 --> 00:22:53,160
brace grapheme underscore extend but I

00:22:46,910 --> 00:22:55,410
so always can always decompose on the

00:22:53,160 --> 00:23:00,870
way in or you won't even be able to do

00:22:55,410 --> 00:23:06,060
these things why are you doing this

00:23:00,870 --> 00:23:10,200
because you want to match in my earlier

00:23:06,060 --> 00:23:14,930
talk I had an example of looking for the

00:23:10,200 --> 00:23:18,540
word cannon CA and 0 n in English text

00:23:14,930 --> 00:23:20,400
there's also a word Canyon spelled that

00:23:18,540 --> 00:23:24,390
with why but in the original Spanish way

00:23:20,400 --> 00:23:28,820
with the tilde I have family who live in

00:23:24,390 --> 00:23:33,450
Canyon City caller Colorado and to the

00:23:28,820 --> 00:23:40,419
great frustration of Washington DC in

00:23:33,450 --> 00:23:42,220
Colorado we spell that with tilde so the

00:23:40,419 --> 00:23:44,289
reason you need to know how to do this

00:23:42,220 --> 00:23:48,279
one reason is you're trying to match

00:23:44,289 --> 00:23:52,059
things with or without accents maybe you

00:23:48,279 --> 00:23:54,399
would want to do that maybe you know a

00:23:52,059 --> 00:23:57,100
Renee who spells her name with an accent

00:23:54,399 --> 00:23:59,499
on hurry and you know another Renee who

00:23:57,100 --> 00:24:02,109
doesn't and you you don't know how

00:23:59,499 --> 00:24:04,720
somebody entered it so you want to match

00:24:02,109 --> 00:24:09,549
either way so you want to be accent

00:24:04,720 --> 00:24:11,529
tolerant so to do that you need to first

00:24:09,549 --> 00:24:13,749
decompose it so it's not an E with an

00:24:11,529 --> 00:24:15,850
accent it's an e with combining asset

00:24:13,749 --> 00:24:18,850
accent so now you can say yes I really

00:24:15,850 --> 00:24:22,119
might have to e and then you can apply a

00:24:18,850 --> 00:24:24,669
? operator a maybe operate on your reg

00:24:22,119 --> 00:24:31,090
ex say maybe I'd like an accent for

00:24:24,669 --> 00:24:32,739
example well that will get tedious if

00:24:31,090 --> 00:24:37,409
you start having to do all this stuff

00:24:32,739 --> 00:24:37,409
all the time although you can do that

00:24:38,669 --> 00:24:47,080
another way to do accent insensitive

00:24:42,669 --> 00:24:48,909
matching now I'm using the word match in

00:24:47,080 --> 00:24:55,299
a loose way but i'm not using loose in a

00:24:48,909 --> 00:24:57,970
loose way the unicode collate module

00:24:55,299 --> 00:25:01,889
which in other talks i talk about more

00:24:57,970 --> 00:25:06,309
don't do too much in this one has some

00:25:01,889 --> 00:25:13,119
stringy functions in it so it has an

00:25:06,309 --> 00:25:16,359
index method that works like pearls

00:25:13,119 --> 00:25:20,320
index function so it looks for a

00:25:16,359 --> 00:25:23,289
substring within a string the thing

00:25:20,320 --> 00:25:27,690
about the collator objects is when you

00:25:23,289 --> 00:25:32,109
instantiate when you call a constructor

00:25:27,690 --> 00:25:35,230
you can specify how to do comparisons

00:25:32,109 --> 00:25:38,169
and this incantation where i set the

00:25:35,230 --> 00:25:43,840
level of one and the normalization to

00:25:38,169 --> 00:25:48,849
undeath only applies the primary

00:25:43,840 --> 00:25:52,559
strength comparison in this multi-level

00:25:48,849 --> 00:25:52,559
on sort

00:25:52,940 --> 00:26:00,330
the uca the unit collation algorithm is

00:25:56,060 --> 00:26:02,820
a multi-level search so if the first

00:26:00,330 --> 00:26:04,890
level is the same then it checks the

00:26:02,820 --> 00:26:06,540
second second to say at six-thirty and

00:26:04,890 --> 00:26:09,960
you can actually have as many as you

00:26:06,540 --> 00:26:12,840
want there um I saying stop at level 1

00:26:09,960 --> 00:26:15,540
it says only check that say they are the

00:26:12,840 --> 00:26:19,470
same letter so primary strength is the

00:26:15,540 --> 00:26:23,670
same letter secondary strength means and

00:26:19,470 --> 00:26:25,860
they have the same accent marks so if

00:26:23,670 --> 00:26:26,910
you set the level only 21 we only care

00:26:25,860 --> 00:26:29,160
about letters it doesn't matter which

00:26:26,910 --> 00:26:32,430
accent marks you've got used so down

00:26:29,160 --> 00:26:37,380
here with Gabriel Garcia Marquez who's

00:26:32,430 --> 00:26:40,680
got a nexus it's going to kill dog he's

00:26:37,380 --> 00:26:46,920
got a stress mark on the the Garcia and

00:26:40,680 --> 00:26:54,030
on the modern so I'm looking for code so

00:26:46,920 --> 00:26:58,020
level three is taste sensitivity so if

00:26:54,030 --> 00:26:59,910
you only do level one you don't that

00:26:58,020 --> 00:27:01,410
checks if it's the same letter you

00:26:59,910 --> 00:27:05,850
haven't gotten to level three which is

00:27:01,410 --> 00:27:08,400
jumping whether the cases say so level

00:27:05,850 --> 00:27:11,100
one is accent insensitive and case

00:27:08,400 --> 00:27:13,320
insensitive and no you do not get to

00:27:11,100 --> 00:27:16,680
have case sensitive but actions

00:27:13,320 --> 00:27:19,320
insensitive because it it's just that

00:27:16,680 --> 00:27:21,720
way so I'm looking for all calf ma are

00:27:19,320 --> 00:27:25,740
in governor got their markets and it

00:27:21,720 --> 00:27:29,610
find em a accent are so your it's not a

00:27:25,740 --> 00:27:31,680
red X search is just an index search but

00:27:29,610 --> 00:27:43,440
it is accent insensitive without

00:27:31,680 --> 00:27:47,460
destroying your original text the

00:27:43,440 --> 00:27:50,340
Unicode collate locale module the only

00:27:47,460 --> 00:27:54,270
difference is the constructor accepts an

00:27:50,340 --> 00:27:58,230
additional argument which is one of I

00:27:54,270 --> 00:28:03,000
don't know 37 or so different possible

00:27:58,230 --> 00:28:05,720
locales one of the weirdness there so

00:28:03,000 --> 00:28:05,720
there's a

00:28:06,300 --> 00:28:13,530
de is German yes did I use the S back

00:28:09,960 --> 00:28:19,830
here I hope no I didn't go there is

00:28:13,530 --> 00:28:23,450
Spanish there's also es underscore

00:28:19,830 --> 00:28:25,530
double underscore traditional so that

00:28:23,450 --> 00:28:28,440
joke a lot thing comes out to Cologne

00:28:25,530 --> 00:28:30,180
instead of the other way around German

00:28:28,440 --> 00:28:35,850
also has its own special one and in

00:28:30,180 --> 00:28:40,260
German phone book so in German if you

00:28:35,850 --> 00:28:44,400
can't find your own law you can write

00:28:40,260 --> 00:28:45,690
the letter e after the letter so when

00:28:44,400 --> 00:28:48,780
somebody looks something up in a phone

00:28:45,690 --> 00:28:52,290
book they shouldn't have to know whether

00:28:48,780 --> 00:28:53,910
it's thing or with an a with a dr SS

00:28:52,290 --> 00:29:05,430
with a new mob or whether somebody wrote

00:28:53,910 --> 00:29:09,660
at AE so here I'm looking for MW m uess

00:29:05,430 --> 00:29:14,420
in this string and under German

00:29:09,660 --> 00:29:16,920
phonebook rules it found a presumably 30

00:29:14,420 --> 00:29:18,930
collator the collator comparisons don't

00:29:16,920 --> 00:29:22,200
care about normalization they do the

00:29:18,930 --> 00:29:24,180
right thing no matter what but let's

00:29:22,200 --> 00:29:28,110
just say that's NFC it would be three

00:29:24,180 --> 00:29:34,760
code points so I look for a capital M

00:29:28,110 --> 00:29:38,820
uess and it found a mule out las llaves

00:29:34,760 --> 00:29:42,090
so you can this is another way of doing

00:29:38,820 --> 00:29:48,990
matching it's not reg ex is it is more

00:29:42,090 --> 00:29:50,550
locale friendly not all so you can

00:29:48,990 --> 00:29:52,650
specify locales that it doesn't actually

00:29:50,550 --> 00:29:54,420
make a difference with like there's no

00:29:52,650 --> 00:29:57,860
difference between the en locale in the

00:29:54,420 --> 00:29:57,860
default collation

00:30:02,710 --> 00:30:08,990
it's going to avoid talking anymore

00:30:05,090 --> 00:30:13,580
about coalition stuff so pearls red x's

00:30:08,990 --> 00:30:14,870
are set up they were typically you know

00:30:13,580 --> 00:30:18,170
they're taken from grep and Sam

00:30:14,870 --> 00:30:21,890
originally and you guys are already

00:30:18,170 --> 00:30:23,870
aware that that means that when you

00:30:21,890 --> 00:30:25,220
apply them to multi-line strings to a

00:30:23,870 --> 00:30:27,140
string that's got new lines in it

00:30:25,220 --> 00:30:32,390
sometimes stuff doesn't work quite the

00:30:27,140 --> 00:30:36,290
way you want it to so for example the

00:30:32,390 --> 00:30:41,210
dot you would think it means match any

00:30:36,290 --> 00:30:46,000
one thing except it doesn't normally dot

00:30:41,210 --> 00:30:46,000
matches anything that's not a new line

00:30:48,190 --> 00:30:53,210
we have a new escape that means backside

00:30:51,350 --> 00:30:55,190
backslash capital n which is another way

00:30:53,210 --> 00:30:58,150
of saying not to new lengths inspector

00:30:55,190 --> 00:31:04,220
Shannon's New London cap n is not merely

00:30:58,150 --> 00:31:08,540
are now you can use a /s on your pattern

00:31:04,220 --> 00:31:14,090
so dot also matches a line feed but you

00:31:08,540 --> 00:31:18,140
cannot do though is do anything that

00:31:14,090 --> 00:31:22,580
will cause doc to match or fail to match

00:31:18,140 --> 00:31:26,060
a Unicode line break sequence Unicode

00:31:22,580 --> 00:31:29,590
has other line great characters than

00:31:26,060 --> 00:31:32,300
just lightly character counts a

00:31:29,590 --> 00:31:34,310
caricature and the line scene comes as a

00:31:32,300 --> 00:31:37,010
single graphing which is a minor it

00:31:34,310 --> 00:31:45,220
grabbing and there are others control

00:31:37,010 --> 00:31:50,120
help funky um the backslash little D

00:31:45,220 --> 00:31:52,880
escape is a new Rec X thing which has

00:31:50,120 --> 00:31:57,650
match any single code point not a

00:31:52,880 --> 00:31:59,840
graphing with the Unicode vertical space

00:31:57,650 --> 00:32:03,440
property and the capital version is

00:31:59,840 --> 00:32:05,900
something that doesn't happen so

00:32:03,440 --> 00:32:08,270
backslash capital v is anything that

00:32:05,900 --> 00:32:10,720
does not have the vertical space

00:32:08,270 --> 00:32:10,720
property

00:32:14,029 --> 00:32:24,990
um backslash capital apps would match

00:32:21,000 --> 00:32:26,909
any graphing which includes those but if

00:32:24,990 --> 00:32:33,419
you used to dot and you've got unicode

00:32:26,909 --> 00:32:36,720
line breaks things get weird we have a

00:32:33,419 --> 00:32:39,150
backslash capital R which it was put in

00:32:36,720 --> 00:32:42,090
to deal with this bachelors capital are

00:32:39,150 --> 00:32:44,940
always matches a Unicode line break

00:32:42,090 --> 00:32:51,120
graphy not necessarily a cook one Soto

00:32:44,940 --> 00:32:53,070
mattress character lengthy care oh so

00:32:51,120 --> 00:32:57,990
back sighs capital R is the same as

00:32:53,070 --> 00:32:59,850
saying accurate ran a line feed or else

00:32:57,990 --> 00:33:05,940
something with the vertical space

00:32:59,850 --> 00:33:12,149
problem in specific as a six dot one it

00:33:05,940 --> 00:33:14,520
matches all those things so okay we've

00:33:12,149 --> 00:33:17,970
got a way to match unicord line breaks

00:33:14,520 --> 00:33:20,760
investor capital R well that makes you

00:33:17,970 --> 00:33:25,260
start rewriting simple things like food

00:33:20,760 --> 00:33:27,570
dollar to be fool maybe a backslash are

00:33:25,260 --> 00:33:31,320
at the end of the string and that's just

00:33:27,570 --> 00:33:37,620
ugly if you think that's ugly think

00:33:31,320 --> 00:33:40,140
about carrot foo um carrot foo /em means

00:33:37,620 --> 00:33:43,799
find a foo either the beginning of the

00:33:40,140 --> 00:33:45,929
string or anywhere immediately following

00:33:43,799 --> 00:33:51,299
a live feed well how do you make it

00:33:45,929 --> 00:33:53,429
immediately following a line drink you

00:33:51,299 --> 00:33:59,779
can't use backslash are and a look

00:33:53,429 --> 00:34:03,960
behind because it's variable width so

00:33:59,779 --> 00:34:06,659
you say it's either to start the string

00:34:03,960 --> 00:34:09,690
behind me or it's a vertical web space

00:34:06,659 --> 00:34:14,310
behind me and then it's a food that's

00:34:09,690 --> 00:34:17,220
ridiculous so this is what I do yes its

00:34:14,310 --> 00:34:19,200
destructive but life's too short so i

00:34:17,220 --> 00:34:21,540
just changed all the Unicode line breaks

00:34:19,200 --> 00:34:23,869
graphemes into new lines that i just

00:34:21,540 --> 00:34:23,869
keep on going

00:34:24,300 --> 00:34:29,919
I wish there were an input filter that

00:34:27,790 --> 00:34:35,050
did this yes you could write one but

00:34:29,919 --> 00:34:41,050
there's no line discipline is that what

00:34:35,050 --> 00:34:43,540
you'd call it anymore what an i/o what

00:34:41,050 --> 00:34:46,030
layer and I that's right isn't it it's

00:34:43,540 --> 00:34:47,620
there's um no I Oh layer that

00:34:46,030 --> 00:34:48,850
automatically does these things for you

00:34:47,620 --> 00:34:52,679
there's no I owe a layer that

00:34:48,850 --> 00:34:52,679
automatically does normalization for you

00:34:53,760 --> 00:35:02,050
what why not well actually I have a

00:34:59,320 --> 00:35:08,110
module that does this but it doesn't use

00:35:02,050 --> 00:35:11,290
i/o layers so I just use that um if you

00:35:08,110 --> 00:35:14,650
read the whole file in you could split

00:35:11,290 --> 00:35:16,390
online unicode line break sequences I I

00:35:14,650 --> 00:35:18,670
just hate the whole character in line

00:35:16,390 --> 00:35:20,680
big pair of thing so just convert them

00:35:18,670 --> 00:35:26,280
all into single line new lines and it's

00:35:20,680 --> 00:35:31,090
a lot easier um case-insensitive

00:35:26,280 --> 00:35:36,640
matching is a remarkably non-obvious

00:35:31,090 --> 00:35:42,120
thing in Unicode first of all unicode

00:35:36,640 --> 00:35:48,090
has decided that it calls things letters

00:35:42,120 --> 00:35:53,190
that Caesar never would so for example

00:35:48,090 --> 00:35:59,020
the Chinese idea grams Chinese writing

00:35:53,190 --> 00:36:04,930
are considered letters by unicode um and

00:35:59,020 --> 00:36:10,240
so can anybody read either of those yeah

00:36:04,930 --> 00:36:11,740
okay here yes I'm that's Tokyo but

00:36:10,240 --> 00:36:18,430
that's emoji Becky which means you

00:36:11,740 --> 00:36:20,560
screwed up your encoding there are

00:36:18,430 --> 00:36:22,870
things that have their letters that

00:36:20,560 --> 00:36:30,130
don't have case there are things that

00:36:22,870 --> 00:36:33,340
have case that are not letters you you

00:36:30,130 --> 00:36:36,420
have cased letters that you can apply a

00:36:33,340 --> 00:36:39,750
case map to and it doesn't change it

00:36:36,420 --> 00:36:41,730
so they're like sticky no they're lower

00:36:39,750 --> 00:36:45,950
casing they're determined to stay that

00:36:41,730 --> 00:36:45,950
way even if you call uppercase on them

00:36:46,700 --> 00:37:00,000
the superscripts and subscripts um small

00:36:54,180 --> 00:37:01,560
caps except for small cap are which does

00:37:00,000 --> 00:37:07,200
have an uppercase map but none of the

00:37:01,560 --> 00:37:09,060
others do the most important thing

00:37:07,200 --> 00:37:11,760
though is that there are no round-trip

00:37:09,060 --> 00:37:16,710
guarantees in ascii there's a round-trip

00:37:11,760 --> 00:37:19,380
guarantee if I have something if I say

00:37:16,710 --> 00:37:22,860
whatever you are now you are lowercase

00:37:19,380 --> 00:37:24,570
oh now your upper case you can go back

00:37:22,860 --> 00:37:26,340
and forth you'll get back the same thing

00:37:24,570 --> 00:37:28,200
that you use to have five uppercase

00:37:26,340 --> 00:37:30,600
letter turn it to lowercase tryn

00:37:28,200 --> 00:37:34,590
uppercase again I get the same one back

00:37:30,600 --> 00:37:37,380
again um this is just not true in

00:37:34,590 --> 00:37:43,380
unicode I mean it's not guaranteed there

00:37:37,380 --> 00:37:46,710
are cases where it is not true umm qais

00:37:43,380 --> 00:37:49,410
maps are made change in length the

00:37:46,710 --> 00:37:50,970
uppercase version of the string may be

00:37:49,410 --> 00:37:56,580
more code points than the lowercase

00:37:50,970 --> 00:37:58,950
version of the string why oh because so

00:37:56,580 --> 00:38:01,020
the lower case we had a precomposed he

00:37:58,950 --> 00:38:02,820
with an accent but for our case we don't

00:38:01,020 --> 00:38:05,130
have a capital e with an accent so that

00:38:02,820 --> 00:38:07,580
when we split up into a combining

00:38:05,130 --> 00:38:10,560
characters stuff like that and worse

00:38:07,580 --> 00:38:13,890
there's no case there's no guarantee of

00:38:10,560 --> 00:38:30,990
length across being the same cost pace

00:38:13,890 --> 00:38:35,870
now no the sharp else is a single code

00:38:30,990 --> 00:38:39,030
point hex DF I hate that I know that um

00:38:35,870 --> 00:38:41,430
when you uppercase it it's to cap assets

00:38:39,030 --> 00:38:48,880
and you lower case that you get to lark

00:38:41,430 --> 00:38:52,630
a census yeah examples

00:38:48,880 --> 00:39:01,780
oh I I've got hey we're coming to that

00:38:52,630 --> 00:39:05,740
one yes so ah Greek has modern Greek is

00:39:01,780 --> 00:39:11,550
not so bad clap Polly Tana Creek has

00:39:05,740 --> 00:39:16,420
lots of marks all over the place um so

00:39:11,550 --> 00:39:19,630
this thing which has got a that's an

00:39:16,420 --> 00:39:21,480
alpha with a rough breathing mark and an

00:39:19,630 --> 00:39:25,500
iota subscript that's a little I

00:39:21,480 --> 00:39:30,160
underneath the Alpha high or something

00:39:25,500 --> 00:39:31,750
well when you upper case that that

00:39:30,160 --> 00:39:38,590
little combining mark turned into

00:39:31,750 --> 00:39:40,200
capital iota and so which means a change

00:39:38,590 --> 00:39:44,710
from a combining mark to a letter

00:39:40,200 --> 00:39:48,730
strange ah so another surprise about

00:39:44,710 --> 00:39:51,010
unicode is that there are three cases

00:39:48,730 --> 00:39:53,860
and for case-knives there are three

00:39:51,010 --> 00:39:55,120
cases not just chicken there's a lower

00:39:53,860 --> 00:39:57,130
case in an upper case and there's a

00:39:55,120 --> 00:40:00,460
title case which sometimes makes a

00:39:57,130 --> 00:40:02,770
difference there is a title case letter

00:40:00,460 --> 00:40:06,730
which is a capital L foe with the rough

00:40:02,770 --> 00:40:08,740
breathing mark and an iota subscript you

00:40:06,730 --> 00:40:11,530
would not you you would only use it if

00:40:08,740 --> 00:40:13,810
you are in mixed case text so title case

00:40:11,530 --> 00:40:16,710
means the first letter is capital

00:40:13,810 --> 00:40:16,710
everything else is lowercase

00:40:24,530 --> 00:40:31,910
if there were a unicode code point that

00:40:27,170 --> 00:40:35,060
were a th and you know you were using it

00:40:31,910 --> 00:40:39,050
for thomas or the river river towns if

00:40:35,060 --> 00:40:40,910
you wanted it in a headline you would

00:40:39,050 --> 00:40:50,020
need the title case version so we're a

00:40:40,910 --> 00:40:50,020
big t in a little H another surprise ah

00:40:50,410 --> 00:40:58,100
oui unico try very hard and almost

00:40:54,590 --> 00:41:00,530
succeeded in making case not be affected

00:40:58,100 --> 00:41:02,330
by your locale settings or not need to

00:41:00,530 --> 00:41:07,670
be affected by your locale settings i

00:41:02,330 --> 00:41:14,240
should say there is an exception with

00:41:07,670 --> 00:41:17,390
the Turkic languages we will see that as

00:41:14,240 --> 00:41:21,260
we go along but for the most part case

00:41:17,390 --> 00:41:23,810
doesn't care what language it's in all

00:41:21,260 --> 00:41:26,270
right so case-insensitive matching

00:41:23,810 --> 00:41:29,330
happened to me say / I we need to a / I

00:41:26,270 --> 00:41:37,430
any of these should match any of the

00:41:29,330 --> 00:41:41,990
other ones um and now at long last I

00:41:37,430 --> 00:41:43,850
believe it actually does but you

00:41:41,990 --> 00:41:46,340
wouldn't want to write your all these or

00:41:43,850 --> 00:41:49,280
expressions in your reg ex to match all

00:41:46,340 --> 00:41:57,080
possible upper lower or title case forms

00:41:49,280 --> 00:42:00,500
so that's why we have a / I it certainly

00:41:57,080 --> 00:42:05,300
works in five dot 14 except for a very

00:42:00,500 --> 00:42:10,280
couple very small yeah there's a couple

00:42:05,300 --> 00:42:13,220
of bugs I yeah but I think there's only

00:42:10,280 --> 00:42:15,800
one or two left in 16 then okay known

00:42:13,220 --> 00:42:33,860
bugs so who knows how many unknown books

00:42:15,800 --> 00:42:37,820
there are in version so if you matched

00:42:33,860 --> 00:42:40,610
um if you wanted to match SS case and

00:42:37,820 --> 00:42:43,760
sensitively that should match an S set a

00:42:40,610 --> 00:42:47,150
sharp s right what happens if you say

00:42:43,760 --> 00:42:53,980
print asks closed paren print s close

00:42:47,150 --> 00:42:53,980
print / I and you feed it a sharp ass

00:42:54,280 --> 00:42:59,810
what does dollar one and got you whole

00:42:56,530 --> 00:43:01,610
we have a problem if you don't put the

00:42:59,810 --> 00:43:03,410
brackets in it actually will work fine

00:43:01,610 --> 00:43:06,080
if you put the brackets in it changes

00:43:03,410 --> 00:43:09,230
what it matches and I'm sorry but I

00:43:06,080 --> 00:43:18,320
don't know I don't know the right

00:43:09,230 --> 00:43:21,740
solution um único technically just finds

00:43:18,320 --> 00:43:25,340
two kinds of case folding one that case

00:43:21,740 --> 00:43:26,750
mapping one that happens on a character

00:43:25,340 --> 00:43:29,060
by character basis and one that makes

00:43:26,750 --> 00:43:32,240
sense for full strings character by

00:43:29,060 --> 00:43:34,040
character that means if you apply a case

00:43:32,240 --> 00:43:35,780
map to a code point you are guaranteed

00:43:34,040 --> 00:43:41,990
you get a code kind of exactly the same

00:43:35,780 --> 00:43:44,860
like that this is actually not very it's

00:43:41,990 --> 00:43:47,630
useful only to computer programmers not

00:43:44,860 --> 00:43:50,330
people working with human languages you

00:43:47,630 --> 00:43:53,240
get much you get better results when you

00:43:50,330 --> 00:44:01,460
have the string versions of the of the

00:43:53,240 --> 00:44:03,520
mappings um pearl supports the the oh we

00:44:01,460 --> 00:44:10,520
might change our length version of this

00:44:03,520 --> 00:44:15,380
called full case um these are simple so

00:44:10,520 --> 00:44:17,740
post with a the archaic wang s or post

00:44:15,380 --> 00:44:20,900
without those are case-insensitive

00:44:17,740 --> 00:44:24,470
matches of each other networks even with

00:44:20,900 --> 00:44:29,140
simple capable with a full case folding

00:44:24,470 --> 00:44:29,140
it means that our sharp s can match a SS

00:44:31,470 --> 00:44:39,369
the short stories if you say / I modulo

00:44:37,029 --> 00:44:43,240
bugs it will just work you don't have to

00:44:39,369 --> 00:44:46,869
think about this there used to be a lot

00:44:43,240 --> 00:44:50,589
more bugs 58 i wouldn't try full case

00:44:46,869 --> 00:44:52,539
mapping at all you spelled oh yeah the

00:44:50,589 --> 00:44:54,670
folk at that you see functions generally

00:44:52,539 --> 00:45:00,250
work except for the unicode bug but the

00:44:54,670 --> 00:45:04,390
/i i have no promises on so when you're

00:45:00,250 --> 00:45:06,809
doing a reg ex substitute we say you

00:45:04,390 --> 00:45:09,099
know match something and replace it by

00:45:06,809 --> 00:45:10,690
the right-hand side is a double quarter

00:45:09,099 --> 00:45:16,089
it's great it's an interpol industry and

00:45:10,690 --> 00:45:20,380
in that you can put on these old VI

00:45:16,089 --> 00:45:21,760
escapes I know people millions of people

00:45:20,380 --> 00:45:26,920
use the eye and don't realize these work

00:45:21,760 --> 00:45:29,589
here um back / l is lower case the next

00:45:26,920 --> 00:45:31,750
character backslash capital L is lower

00:45:29,589 --> 00:45:36,670
case all the next characters until the

00:45:31,750 --> 00:45:38,640
backslash eat um backslash capital u

00:45:36,670 --> 00:45:43,510
means capitalize all the rest of them

00:45:38,640 --> 00:45:47,410
back / little you title cases the next

00:45:43,510 --> 00:45:50,140
code point and these actually compile

00:45:47,410 --> 00:45:52,869
into calls to the LC you see first or

00:45:50,140 --> 00:45:57,819
eise emotions or LC first in that case

00:45:52,869 --> 00:46:01,359
sorry in five dot 16 we have a way of

00:45:57,819 --> 00:46:08,250
doing that for fold case full cases like

00:46:01,359 --> 00:46:10,960
lower case with a some some changes and

00:46:08,250 --> 00:46:15,250
fourth case is what is used when you say

00:46:10,960 --> 00:46:17,829
/ I so if you wanted you could use back

00:46:15,250 --> 00:46:23,520
sighs capital F to get the full case map

00:46:17,829 --> 00:46:26,200
of something or the FC function if

00:46:23,520 --> 00:46:29,079
you're now running five dot 16 and

00:46:26,200 --> 00:46:30,789
really almost Onias you can get the FC

00:46:29,079 --> 00:46:33,069
function from the unicode case fold

00:46:30,789 --> 00:46:35,859
module you don't get the backslash

00:46:33,069 --> 00:46:39,089
capital F escape because I search

00:46:35,859 --> 00:46:39,089
filters would be going too far

00:46:39,640 --> 00:46:52,780
ah you say / I only the pattern part is

00:46:49,240 --> 00:46:58,060
subject to pace Foley / I doesn't apply

00:46:52,780 --> 00:47:02,050
to the right-hand side you laugh but

00:46:58,060 --> 00:47:05,230
some people think it should okay so uh

00:47:02,050 --> 00:47:10,690
this is another part of that we can't

00:47:05,230 --> 00:47:13,120
fix this problem so if you say Massa

00:47:10,690 --> 00:47:16,870
with a sharp s it does match Massa

00:47:13,120 --> 00:47:20,560
without with the regular esas but what

00:47:16,870 --> 00:47:23,890
do you do here Massa with a sharp ass

00:47:20,560 --> 00:47:26,560
and then just mas you're not done yet if

00:47:23,890 --> 00:47:30,960
I'd have a code point we don't match

00:47:26,560 --> 00:47:38,800
half code points and that's kind of an

00:47:30,960 --> 00:47:42,580
unsolvable problem right well there's a

00:47:38,800 --> 00:47:45,490
workaround is you can force it into cap

00:47:42,580 --> 00:47:48,820
uppercase and then your possible partial

00:47:45,490 --> 00:47:51,940
match it's not pretty takes extra space

00:47:48,820 --> 00:48:00,040
and time but I don't know how to solve

00:47:51,940 --> 00:48:02,770
the middle one ah finally full case

00:48:00,040 --> 00:48:07,080
folding is suspended I mean turned off

00:48:02,770 --> 00:48:09,640
in when you're doing a character class

00:48:07,080 --> 00:48:15,400
that you've started with circumflex to

00:48:09,640 --> 00:48:17,590
inverted and the reasons for that a way

00:48:15,400 --> 00:48:21,580
too complicated get into here but it

00:48:17,590 --> 00:48:27,030
leads to paradoxes so actually turned

00:48:21,580 --> 00:48:30,820
off purl does not have locale sensitive

00:48:27,030 --> 00:48:33,270
case folding or case mapping built into

00:48:30,820 --> 00:48:37,150
it this applied automatically for you

00:48:33,270 --> 00:48:41,080
what does that mean it means that if you

00:48:37,150 --> 00:48:45,340
have Sisyphus and put it all in

00:48:41,080 --> 00:48:47,710
lowercase you get the wrong Sigma at the

00:48:45,340 --> 00:48:50,070
end it doesn't know about that kind of

00:48:47,710 --> 00:48:50,070
Sigma

00:48:50,299 --> 00:48:55,099
oh and here's the other locale thing

00:48:51,859 --> 00:49:00,619
besides the signals ah the Turkish I

00:48:55,099 --> 00:49:01,880
problem they have a different rule for

00:49:00,619 --> 00:49:06,349
what happens when you upper and lower

00:49:01,880 --> 00:49:07,789
case eyes there is a module and you

00:49:06,349 --> 00:49:11,660
can't I can't even see the bottom line

00:49:07,789 --> 00:49:14,029
of that sorry they didn't warn me about

00:49:11,660 --> 00:49:17,660
the resolution um there's a unicode

00:49:14,029 --> 00:49:20,719
casing module which has examples of how

00:49:17,660 --> 00:49:23,449
to address these and lets the animatic

00:49:20,719 --> 00:49:25,249
slides not a long ways for the young and

00:49:23,449 --> 00:49:29,329
i have examples at the very end of these

00:49:25,249 --> 00:49:32,749
materials of using that particular thing

00:49:29,329 --> 00:49:37,459
but i hope you don't have to deal with

00:49:32,749 --> 00:49:49,749
it so i can say ok when you're doing

00:49:37,459 --> 00:49:49,749
pattern matching with yes Carl paradoxes

00:49:51,130 --> 00:50:28,969
fewer american turkey has its own rules

00:50:25,339 --> 00:50:42,769
for capitalization let's go that freak

00:50:28,969 --> 00:50:46,459
viral sigma english i'm old enough to

00:50:42,769 --> 00:50:47,989
see driving people would do it

00:50:46,459 --> 00:50:51,589
differently a team would look like this

00:50:47,989 --> 00:50:54,349
again that's just the glyph difference

00:50:51,589 --> 00:50:58,579
really shouldn't get care but because of

00:50:54,349 --> 00:51:01,480
the greek typewriters and then following

00:50:58,579 --> 00:51:04,040
green typewriters the two

00:51:01,480 --> 00:51:05,810
Dave two different characters and so

00:51:04,040 --> 00:51:08,570
unicode had to happen to different

00:51:05,810 --> 00:51:10,930
charities and so now really when you

00:51:08,570 --> 00:51:14,180
should use a cigarette on input

00:51:10,930 --> 00:51:16,369
converted into the marble middle and on

00:51:14,180 --> 00:51:20,060
output when it's a canary end of award

00:51:16,369 --> 00:51:23,090
converted back to the party but you or

00:51:20,060 --> 00:51:26,119
you could have it a browser do that for

00:51:23,090 --> 00:51:27,800
example yeah and it would sure and the

00:51:26,119 --> 00:51:30,290
computer program should have to know

00:51:27,800 --> 00:51:34,540
that there is two different signals but

00:51:30,290 --> 00:51:34,540
because of historical reasons there are

00:51:35,050 --> 00:51:41,020
the back of angry you are too yeah the

00:51:38,330 --> 00:51:46,360
backwards compatibility police are rabid

00:51:41,020 --> 00:51:52,340
yes you need to quickly see more texture

00:51:46,360 --> 00:51:54,230
I've been doing it dude nothing I know

00:51:52,340 --> 00:51:57,680
it works for me when I'm not plugged

00:51:54,230 --> 00:52:00,680
into this system I don't understand

00:51:57,680 --> 00:52:09,830
that's just a safari type thing I know I

00:52:00,680 --> 00:52:12,619
know you have a minimum font size see

00:52:09,830 --> 00:52:16,730
that see that see that it's grayed out

00:52:12,619 --> 00:52:22,750
it won't let me do it isn't that a

00:52:16,730 --> 00:52:22,750
bummer what if you can't change it

00:52:28,540 --> 00:52:35,240
do you really want to i guess i can can

00:52:32,000 --> 00:52:46,460
you read that I doubt it I just so you

00:52:35,240 --> 00:52:48,980
could do it okay their character class

00:52:46,460 --> 00:52:51,710
shortcuts bachelors w back sighs chief

00:52:48,980 --> 00:52:56,660
xss back says be these and their

00:52:51,710 --> 00:52:59,720
compliments these work on unicode so

00:52:56,660 --> 00:53:04,100
backstitch w is an elfin um under

00:52:59,720 --> 00:53:09,680
generally there are lots of there are

00:53:04,100 --> 00:53:11,650
several underscores there are surprising

00:53:09,680 --> 00:53:17,140
number of digits and they're an

00:53:11,650 --> 00:53:20,330
astonishing number of letters in unicode

00:53:17,140 --> 00:53:21,670
so you say back /w you match over a

00:53:20,330 --> 00:53:28,850
hundred thousand different code points

00:53:21,670 --> 00:53:30,950
pas possible code ones um even backslash

00:53:28,850 --> 00:53:33,860
d matches four hundred and twenty

00:53:30,950 --> 00:53:37,030
different code points as of six level

00:53:33,860 --> 00:53:39,020
i'm going to change this next one ah

00:53:37,030 --> 00:53:42,310
backslash asked there are a bunch of

00:53:39,020 --> 00:53:42,310
different unicode whitespace things

00:53:42,700 --> 00:53:49,430
question yes does pearl prehistory which

00:53:46,250 --> 00:53:51,500
is consisting of digits but not latin or

00:53:49,430 --> 00:53:55,700
not these are our usual digits as an

00:53:51,500 --> 00:53:58,970
actual number is it that I you know

00:53:55,700 --> 00:54:02,870
that's an issue now I don't like the

00:53:58,970 --> 00:54:05,020
texel only part i'm going to have to go

00:54:02,870 --> 00:54:05,020
back

00:54:12,339 --> 00:54:19,599
yeah so what does what does matching a

00:54:15,109 --> 00:54:19,599
number do if it's not regular digits

00:54:22,750 --> 00:54:34,700
what's that that is matched by backslash

00:54:27,800 --> 00:54:36,710
d ah a pug of bamboo or the child bamboo

00:54:34,700 --> 00:54:38,569
or a pile of red dragons is not matched

00:54:36,710 --> 00:54:41,300
by backslash t and probably isn't worth

00:54:38,569 --> 00:54:45,079
anything or this child isn't but these

00:54:41,300 --> 00:54:47,390
other ones that these actually have

00:54:45,079 --> 00:54:49,520
numerical values in but they're not

00:54:47,390 --> 00:54:52,520
fidget thank God but backslash key will

00:54:49,520 --> 00:54:56,180
match these guys down here which means

00:54:52,520 --> 00:54:58,700
you have an issue means that your back /

00:54:56,180 --> 00:55:02,059
g plus can match things that if you turn

00:54:58,700 --> 00:55:07,010
around and try to use this number it

00:55:02,059 --> 00:55:10,010
will work so what do you do about that

00:55:07,010 --> 00:55:12,740
you right out you can do it Abigail

00:55:10,010 --> 00:55:19,599
dozen be religious about writing 0 dash

00:55:12,740 --> 00:55:22,460
nine because that's all he wants you can

00:55:19,599 --> 00:55:24,680
if you believe that writing POSIX digit

00:55:22,460 --> 00:55:34,670
is more obvious to the reader than 0

00:55:24,680 --> 00:55:39,640
dash nine that you may write that there

00:55:34,670 --> 00:55:42,740
is a new switch as of five dot 14 um

00:55:39,640 --> 00:55:48,859
that says give me the ASCII sense of

00:55:42,740 --> 00:55:51,440
that backslash t or you can just take

00:55:48,859 --> 00:55:58,160
whatever you get and then run it through

00:55:51,440 --> 00:56:01,460
that function and that's all so new to

00:55:58,160 --> 00:56:04,970
514 so for example here's a different i

00:56:01,460 --> 00:56:07,730
got a digit a bigger so that will match

00:56:04,970 --> 00:56:11,690
there if you try to say it's got a

00:56:07,730 --> 00:56:16,280
numeric value % d pearl doesn't know how

00:56:11,690 --> 00:56:21,290
to convert those so you to convert a

00:56:16,280 --> 00:56:22,060
non-ascii digit straight into the base

00:56:21,290 --> 00:56:24,250
00:56:22,060 --> 00:56:25,540
not based in you know to be converted

00:56:24,250 --> 00:56:32,980
into a number you can run it through

00:56:25,540 --> 00:56:36,130
there that works it works on digit

00:56:32,980 --> 00:56:40,000
strings base 10 digits it works on

00:56:36,130 --> 00:56:45,940
single code points that have a numeric

00:56:40,000 --> 00:56:49,030
sense so Roman numeral Ken that is

00:56:45,940 --> 00:56:51,060
numerically 10 Roman numeral seven is

00:56:49,030 --> 00:56:57,070
numerically seven thought if you had

00:56:51,060 --> 00:57:01,030
xvii it's not 17 only the base 10 things

00:56:57,070 --> 00:57:03,310
are converted into as though they were

00:57:01,030 --> 00:57:08,560
based ten other than that it's care it's

00:57:03,310 --> 00:57:11,020
code point by code point but if you just

00:57:08,560 --> 00:57:12,850
do them one at a time so Mac anything

00:57:11,020 --> 00:57:15,250
with the numeric value anyone code point

00:57:12,850 --> 00:57:20,290
with numeric value it will convert give

00:57:15,250 --> 00:57:23,220
you those answers know your boundaries

00:57:20,290 --> 00:57:23,220
oh yes

00:57:29,460 --> 00:57:34,780
there may be three people in this room

00:57:32,079 --> 00:57:40,210
or know what these do and I'm not sure

00:57:34,780 --> 00:57:42,250
if I'm one of them people are remarkably

00:57:40,210 --> 00:57:48,520
confused over what backslash be actually

00:57:42,250 --> 00:57:51,880
matches it doesn't match anything it

00:57:48,520 --> 00:57:58,119
turns out it's just an assertion it's a

00:57:51,880 --> 00:58:04,000
zero with assertion these two are

00:57:58,119 --> 00:58:07,630
equivalent I'll do the easier one says

00:58:04,000 --> 00:58:11,589
if there's a foundry is just like if

00:58:07,630 --> 00:58:15,430
there is a word character behind me then

00:58:11,589 --> 00:58:19,660
there must not be one in front of me or

00:58:15,430 --> 00:58:22,900
else if this part is false there must be

00:58:19,660 --> 00:58:27,250
one in front of me this might be easier

00:58:22,900 --> 00:58:29,650
to read in this format which is if

00:58:27,250 --> 00:58:31,210
there's one behind me there must be one

00:58:29,650 --> 00:58:33,099
in front of me or if there's not one

00:58:31,210 --> 00:58:39,940
behind me there ma must be run in front

00:58:33,099 --> 00:58:42,280
of me those are the same um except what

00:58:39,940 --> 00:58:44,109
people really think backslash be means

00:58:42,280 --> 00:58:47,800
is if the edge of the string or next to

00:58:44,109 --> 00:58:50,349
white space that's it's so common that's

00:58:47,800 --> 00:58:52,210
what people think it is you can write

00:58:50,349 --> 00:58:58,180
that yourself although it gets annoying

00:58:52,210 --> 00:59:01,900
because of the negative the look behind

00:58:58,180 --> 00:59:06,819
can't be variable with so if a space

00:59:01,900 --> 00:59:08,650
boundary on the Left says either pretend

00:59:06,819 --> 00:59:12,369
I said backslash capital a there sorry

00:59:08,650 --> 00:59:16,869
either the start of the string or there

00:59:12,369 --> 00:59:18,760
is unicode right space behind me but

00:59:16,869 --> 00:59:21,280
that's only an edge on the left an edge

00:59:18,760 --> 00:59:22,930
on the other side is at the end of the

00:59:21,280 --> 00:59:24,760
string or there's Unicode right space

00:59:22,930 --> 00:59:27,400
that's usually what people mean by

00:59:24,760 --> 00:59:29,680
backslash be back / b is defined in

00:59:27,400 --> 00:59:35,020
terms of bacchus RSW taxes w defined in

00:59:29,680 --> 00:59:37,000
terms of 100 2787 different points may

00:59:35,020 --> 00:59:40,200
not it may match more or less than what

00:59:37,000 --> 00:59:40,200
you want to match

00:59:44,180 --> 00:59:49,860
unicode has its own idea about text

00:59:46,740 --> 00:59:52,610
boundaries that is not related to

00:59:49,860 --> 00:59:56,690
whether it's a word character or not

00:59:52,610 --> 01:00:00,830
pearls back /b does not work that way

00:59:56,690 --> 01:00:03,720
there is a module that implements the

01:00:00,830 --> 01:00:09,900
particular Unicode document standard

01:00:03,720 --> 01:00:11,700
that says how that should work I don't

01:00:09,900 --> 01:00:16,770
use unicode line break much i have used

01:00:11,700 --> 01:00:19,620
it i do use use GCS string more often

01:00:16,770 --> 01:00:21,930
because it that means graphene cluster

01:00:19,620 --> 01:00:24,570
string of examples of it who knows

01:00:21,930 --> 01:00:28,680
probably not somebody because this is

01:00:24,570 --> 01:00:32,400
the reg ex talk Harold you know I don't

01:00:28,680 --> 01:00:37,650
want to talk about these all right so if

01:00:32,400 --> 01:00:39,750
you said use V dot 14 then pearl is

01:00:37,650 --> 01:00:44,070
going to try to map it thinks

01:00:39,750 --> 01:00:48,380
everything's unica if you haven't said

01:00:44,070 --> 01:00:48,380
that it has all these weird rules that

01:00:49,310 --> 01:00:55,560
no one no one can tell you what they are

01:00:53,640 --> 01:00:57,870
without having a source code that the

01:00:55,560 --> 01:01:03,150
keep looking at is there explaining

01:00:57,870 --> 01:01:06,210
what's going on I know I probably can

01:01:03,150 --> 01:01:15,690
too but not if I'm tired it's it's

01:01:06,210 --> 01:01:18,900
tricky stuff right so /a means only use

01:01:15,690 --> 01:01:28,110
a ski rules and / ee needs really i miss

01:01:18,900 --> 01:01:30,560
it the first time don't use the double

01:01:28,110 --> 01:01:36,180
option that /d that's the old default

01:01:30,560 --> 01:01:39,870
stands for stupid or dumb or dodgy or oh

01:01:36,180 --> 01:01:43,080
it depends we don't know / humans always

01:01:39,870 --> 01:01:46,290
treat things as Unicode that's the

01:01:43,080 --> 01:01:48,720
default under use vida 514 actually used

01:01:46,290 --> 01:01:52,260
veet 512 except it doesn't work there

01:01:48,720 --> 01:01:54,050
but if you say use the 512 and you're

01:01:52,260 --> 01:01:58,970
using 514 it will work

01:01:54,050 --> 01:02:02,300
a single a needs use a ski rules however

01:01:58,970 --> 01:02:08,180
it still uses unicode case holding / I /

01:02:02,300 --> 01:02:09,800
double-a says no so how many possible

01:02:08,180 --> 01:02:15,350
letters this a to z match

01:02:09,800 --> 01:02:19,550
case-insensitive lee 26 times two is 52

01:02:15,350 --> 01:02:22,810
right if that's the answer you're

01:02:19,550 --> 01:02:28,130
looking for you should be using double a

01:02:22,810 --> 01:02:30,380
there is no triple a um because under a

01:02:28,130 --> 01:02:38,650
single a it matches 54 code points not

01:02:30,380 --> 01:02:42,680
52 these are probably best used on a

01:02:38,650 --> 01:02:46,700
spur scope basis so under fired up 14 ER

01:02:42,680 --> 01:02:53,960
or above you can specify the red X flags

01:02:46,700 --> 01:02:56,720
on a per block / scope basis so you

01:02:53,960 --> 01:03:00,980
could say and Damian likes to say use re

01:02:56,720 --> 01:03:03,560
/ MSX that means all his reg ex is our

01:03:00,980 --> 01:03:08,380
MSX without him having to write it every

01:03:03,560 --> 01:03:08,380
time he thinks that's a cool feature um

01:03:10,480 --> 01:03:20,240
Abigail have you said use already / 08

01:03:13,040 --> 01:03:22,520
before or double a rather know the only

01:03:20,240 --> 01:03:30,970
use was our videos already here are you

01:03:22,520 --> 01:03:34,490
people yeah so internally there are

01:03:30,970 --> 01:03:37,810
different tweaks for the character class

01:03:34,490 --> 01:03:44,620
so the only thing that these change are

01:03:37,810 --> 01:03:48,140
the best /w type things if you say

01:03:44,620 --> 01:03:51,250
backstretch p strip people's great

01:03:48,140 --> 01:03:55,430
that's a change ok so the old-style

01:03:51,250 --> 01:03:57,770
character classes and the way pace

01:03:55,430 --> 01:04:06,520
insensitive matching is done whether you

01:03:57,770 --> 01:04:06,520
get the Unicode you want it to act

01:04:06,930 --> 01:04:16,800
you might just say you re double-a and

01:04:10,420 --> 01:04:16,800
it lacks like it always used to in 18min

01:04:25,260 --> 01:04:32,740
unico properties are cool um there's a

01:04:29,920 --> 01:04:36,070
red X escape to get at them so backslash

01:04:32,740 --> 01:04:38,830
p says match any code point with the

01:04:36,070 --> 01:04:42,190
property in the curly braces utica

01:04:38,830 --> 01:04:47,790
properties have a name and the value so

01:04:42,190 --> 01:04:47,790
they're pairs like script equals Greek

01:04:48,840 --> 01:04:54,280
Pearl has a bunch of shortcuts so you

01:04:52,450 --> 01:04:56,650
don't have to use the two partners you

01:04:54,280 --> 01:04:59,680
can just say property Greek and it

01:04:56,650 --> 01:05:05,200
actually means property script equals

01:04:59,680 --> 01:05:10,320
Greek for example the most commonly used

01:05:05,200 --> 01:05:15,190
ones probably are the general categories

01:05:10,320 --> 01:05:21,640
every code point belongs to exactly one

01:05:15,190 --> 01:05:24,070
general category um and this is a fixed

01:05:21,640 --> 01:05:27,490
set there will never be new general

01:05:24,070 --> 01:05:29,200
categories um you could have a switch

01:05:27,490 --> 01:05:31,540
statement that said if it's a letter

01:05:29,200 --> 01:05:36,460
else if it's a mark else's that's

01:05:31,540 --> 01:05:38,350
numbers of the one letter general

01:05:36,460 --> 01:05:44,110
categories do not need curly braces

01:05:38,350 --> 01:05:47,110
everybody else does so the one letter

01:05:44,110 --> 01:05:48,910
ones are actually like wild cards that

01:05:47,110 --> 01:05:51,460
mean all the two-letter properties

01:05:48,910 --> 01:05:54,100
beginning with that letter so property

01:05:51,460 --> 01:05:58,050
letter means it's an uppercase or a

01:05:54,100 --> 01:06:01,660
lowercase oops upper lower title

01:05:58,050 --> 01:06:06,820
modifier letter other letter orange glad

01:06:01,660 --> 01:06:11,350
we don't have to write that so instead

01:06:06,820 --> 01:06:13,240
of getting too nervous about the way

01:06:11,350 --> 01:06:17,020
back /w works about our ass or something

01:06:13,240 --> 01:06:17,390
at the cost of one more level you can

01:06:17,020 --> 01:06:20,810
get

01:06:17,390 --> 01:06:24,170
or precision about what kind of things

01:06:20,810 --> 01:06:28,630
are matching so give me a letter give me

01:06:24,170 --> 01:06:28,630
a number give me a white space etc

01:06:29,290 --> 01:06:39,920
subject separators system so yes all

01:06:35,930 --> 01:06:48,340
unico properties are two are a key equal

01:06:39,920 --> 01:06:53,420
value there are a bunch of shortcuts um

01:06:48,340 --> 01:06:55,130
how do you find out what property is a

01:06:53,420 --> 01:06:57,440
code blowing hands how do you find out

01:06:55,130 --> 01:07:03,370
all the Unicode properties there's a man

01:06:57,440 --> 01:07:08,750
page pearl unit props that lists all the

01:07:03,370 --> 01:07:11,210
properties that pearl recognizes it

01:07:08,750 --> 01:07:14,360
doesn't list each code point in what all

01:07:11,210 --> 01:07:19,730
its properties are that's a different

01:07:14,360 --> 01:07:22,640
problem for that I wrote a program so

01:07:19,730 --> 01:07:26,690
this computes the intersection of kate

01:07:22,640 --> 01:07:28,370
code points with the case property code

01:07:26,690 --> 01:07:33,590
points with the number property so these

01:07:28,370 --> 01:07:38,360
are case letters and you can get this

01:07:33,590 --> 01:07:50,540
from that URL or it's in a cpanel bundle

01:07:38,360 --> 01:07:53,330
call code double colon tus SLP so I do

01:07:50,540 --> 01:07:54,860
this to an inspect you know what

01:07:53,330 --> 01:07:58,340
possible code points are matched by

01:07:54,860 --> 01:08:01,310
those properties I have another program

01:07:58,340 --> 01:08:06,530
there which says given a code point what

01:08:01,310 --> 01:08:08,480
are all of its properties and so that's

01:08:06,530 --> 01:08:10,790
the answer that question how do you find

01:08:08,480 --> 01:08:13,790
out all the all the properties of the

01:08:10,790 --> 01:08:15,920
different of a particular code point you

01:08:13,790 --> 01:08:19,330
run through all possible properties in

01:08:15,920 --> 01:08:19,330
tests that's all I'm doing

01:08:21,980 --> 01:08:26,310
you know Carl I'm really looking forward

01:08:24,450 --> 01:08:28,880
to never having to explain this part

01:08:26,310 --> 01:08:31,920
again because as soon as we can do

01:08:28,880 --> 01:08:37,049
character class set operations we don't

01:08:31,920 --> 01:08:41,069
have to think about this okay so you can

01:08:37,049 --> 01:08:49,680
define your own properties in pearl

01:08:41,069 --> 01:08:51,870
Rex's all so what i've done here is i've

01:08:49,680 --> 01:08:54,870
created a subroutine called is volatile

01:08:51,870 --> 01:08:58,920
and here's one called disconsolate and

01:08:54,870 --> 01:09:01,740
all once i find these i can use

01:08:58,920 --> 01:09:08,970
bachelors p is bowel or backslash p is

01:09:01,740 --> 01:09:13,710
Thompson way this works is the function

01:09:08,970 --> 01:09:17,430
is expected to return a string which is

01:09:13,710 --> 01:09:21,509
new line terminated one code point or

01:09:17,430 --> 01:09:29,310
line or a tab separated pair of color

01:09:21,509 --> 01:09:40,170
points for a range and it should start

01:09:29,310 --> 01:09:42,509
with the word is he in there soon again

01:09:40,170 --> 01:09:47,339
any on sir that's what the documentation

01:09:42,509 --> 01:09:52,740
says breakfast it's not through it was

01:09:47,339 --> 01:09:55,110
broken recently we are using the same

01:09:52,740 --> 01:10:02,820
word in st. different words the same

01:09:55,110 --> 01:10:08,270
time yes and so has Danny and he was

01:10:02,820 --> 01:10:08,270
very he was saddened by this fix

01:10:14,940 --> 01:10:22,290
but they're not case sensitive did you

01:10:18,660 --> 01:10:30,980
know that have you ever tried backslash

01:10:22,290 --> 01:10:30,980
p little l it works just fine but these

01:10:39,199 --> 01:10:44,070
right with user-defined ones the rules

01:10:41,520 --> 01:10:45,900
are different so property names in the

01:10:44,070 --> 01:10:49,770
Unicode properties backside peterlee

01:10:45,900 --> 01:10:55,530
brace whatever goes in there a case and

01:10:49,770 --> 01:11:01,739
white space are ignored and dashes no

01:10:55,530 --> 01:11:08,400
hyper- Vegas but not here these have to

01:11:01,739 --> 01:11:11,570
be exactly one interesting thing you can

01:11:08,400 --> 01:11:16,830
do with this do I explain this yes is

01:11:11,570 --> 01:11:20,340
you can do set operations so here is an

01:11:16,830 --> 01:11:25,170
is reco roller and is reka Roman I

01:11:20,340 --> 01:11:28,380
defined to be all the Latin script and

01:11:25,170 --> 01:11:30,900
all the Greek script good points so you

01:11:28,380 --> 01:11:35,790
acting added red there's also an

01:11:30,900 --> 01:11:37,380
intersection with negative then we are

01:11:35,790 --> 01:11:41,400
working to come up with a better way of

01:11:37,380 --> 01:11:46,080
specifying the citizens hand on your own

01:11:41,400 --> 01:11:51,360
beautiful properties use set set

01:11:46,080 --> 01:11:53,430
operation combining the classes you

01:11:51,360 --> 01:11:56,390
can't do this you have to write stuff

01:11:53,430 --> 01:12:01,980
like this all the time drive me nuts so

01:11:56,390 --> 01:12:04,770
here to the ratings that says it's all

01:12:01,980 --> 01:12:08,900
the code point is a Latin or Greek or a

01:12:04,770 --> 01:12:08,900
common or an inherited

01:12:09,889 --> 01:12:25,010
we will not want to write that very

01:12:11,749 --> 01:12:28,789
often okay good i have 45 minutes left

01:12:25,010 --> 01:12:31,010
to complain so the rest of the talk is

01:12:28,789 --> 01:12:35,780
just complained about things that will

01:12:31,010 --> 01:12:40,639
drive you nuts so we we picked up a lot

01:12:35,780 --> 01:12:42,709
of habits in ascii land that are

01:12:40,639 --> 01:12:44,719
difficult break when we come to unicode

01:12:42,709 --> 01:12:49,399
but if we don't break them we will do

01:12:44,719 --> 01:12:52,880
things incorrectly so have you ever seen

01:12:49,399 --> 01:12:59,829
code that does that settee our top says

01:12:52,880 --> 01:13:03,199
translate octo characters 0 2 127

01:12:59,829 --> 01:13:06,499
characters 128 stupid 25 what does that

01:13:03,199 --> 01:13:07,729
duke turns of the hide it well I asked

01:13:06,499 --> 01:13:14,269
you don't care if you don't need how

01:13:07,729 --> 01:13:18,530
they don't want to do that anymore

01:13:14,269 --> 01:13:21,409
doesn't so we use those have a cure use

01:13:18,530 --> 01:13:27,260
everything turns out that pearl actually

01:13:21,409 --> 01:13:30,499
uses more characters miracles here so

01:13:27,260 --> 01:13:34,300
the Unicode range so so to convert the

01:13:30,499 --> 01:13:37,550
ass II approach to the Unicode coach

01:13:34,300 --> 01:13:40,880
instead of gate at TR you can't do that

01:13:37,550 --> 01:13:43,880
TL so take all the Unicode range and

01:13:40,880 --> 01:13:48,409
move them all the way up to really big

01:13:43,880 --> 01:13:50,179
hug partners have you wanted it well if

01:13:48,409 --> 01:13:52,010
you've ever done the first one you'll

01:13:50,179 --> 01:13:54,079
know why you might wanna do it you might

01:13:52,010 --> 01:13:57,939
like mark things is having the process

01:13:54,079 --> 01:14:00,769
so they never match yet probably's

01:13:57,939 --> 01:14:06,800
non-unicode code points is there not

01:14:00,769 --> 01:14:11,389
legal here going so conformant processes

01:14:06,800 --> 01:14:13,639
will not respect them you can't even

01:14:11,389 --> 01:14:15,769
call them a utf-8 according to the

01:14:13,639 --> 01:14:18,469
universe back pearl does you need that

01:14:15,769 --> 01:14:23,179
so cooperating pearl processes it's fine

01:14:18,469 --> 01:14:25,969
you do this on other read statutes

01:14:23,179 --> 01:14:27,769
I mentioned the specialist w matches

01:14:25,969 --> 01:14:37,729
over a hundred thousand things you can

01:14:27,769 --> 01:14:40,249
use / pay or two of them I have so many

01:14:37,729 --> 01:14:44,019
times C code that thinks it can convert

01:14:40,249 --> 01:14:50,869
to a ski by simply removing accent marks

01:14:44,019 --> 01:14:54,860
on this I had a question about Earth

01:14:50,869 --> 01:14:57,229
yeah like unicode I believe unicode also

01:14:54,860 --> 01:14:59,269
provides a section that says it can be

01:14:57,229 --> 01:15:06,139
user-defined know is that inside or

01:14:59,269 --> 01:15:07,550
outside the question is what doesn't you

01:15:06,139 --> 01:15:10,280
know Cody has something about you should

01:15:07,550 --> 01:15:15,949
find something yes it does um there are

01:15:10,280 --> 01:15:18,469
private use area curve points that our

01:15:15,949 --> 01:15:21,860
coach of various uses Apple uses one of

01:15:18,469 --> 01:15:23,239
them furs logo but there's some Eastern

01:15:21,860 --> 01:15:24,979
languages there's always been a

01:15:23,239 --> 01:15:27,590
tradition and there are going systems of

01:15:24,979 --> 01:15:32,260
being able to just use things from

01:15:27,590 --> 01:15:39,229
whatever you want you notice how parties

01:15:32,260 --> 01:15:42,050
those are all under 11 big thousand yeah

01:15:39,229 --> 01:15:49,749
so they are within the Utica range there

01:15:42,050 --> 01:15:49,749
to find a cover so they don't get things

01:15:51,999 --> 01:15:58,249
cancer stripping sugar accent marks does

01:15:55,969 --> 01:16:00,590
not mean you get a ski in return what if

01:15:58,249 --> 01:16:05,659
you had a sharp ass there's no accent

01:16:00,590 --> 01:16:08,179
mark on Charlotte's um you're easy

01:16:05,659 --> 01:16:13,840
unicode property called diet critic it's

01:16:08,179 --> 01:16:16,070
not quite the same as the mark property

01:16:13,840 --> 01:16:20,900
there are a few things that one has it

01:16:16,070 --> 01:16:23,050
the other does and vice versa ah let's

01:16:20,900 --> 01:16:23,050
see

01:16:25,730 --> 01:16:31,940
a if come a code point has the mark

01:16:28,970 --> 01:16:35,660
property then it it's print with is 0

01:16:31,940 --> 01:16:37,460
right well no not always what if I say a

01:16:35,660 --> 01:16:42,920
combining tilde it's on the same

01:16:37,460 --> 01:16:44,540
character yes in that case if there is a

01:16:42,920 --> 01:16:45,800
letter before that but if there's a new

01:16:44,540 --> 01:16:50,210
line before that what are you supposed

01:16:45,800 --> 01:16:53,120
to do mm-hmm also there are spacing

01:16:50,210 --> 01:16:55,400
marks there you think of combining

01:16:53,120 --> 01:16:56,690
viruses non-spicy marks in there are

01:16:55,400 --> 01:17:02,530
Eastern languages where there are

01:16:56,690 --> 01:17:02,530
actually marks that take up print width

01:17:04,900 --> 01:17:09,280
there are all these degenerate cases

01:17:09,880 --> 01:17:15,140
there is no limit to the number of

01:17:12,520 --> 01:17:24,620
combining characters you can stack on

01:17:15,140 --> 01:17:32,110
top of a base character there is there's

01:17:24,620 --> 01:17:39,170
some UTS a Unicode auxiliary document

01:17:32,110 --> 01:17:43,610
that gives suggestions for normalization

01:17:39,170 --> 01:17:46,100
of names and stuff not not NFD but like

01:17:43,610 --> 01:17:49,400
eunuch then you know how to use unicode

01:17:46,100 --> 01:17:54,680
like in domain names of like that and

01:17:49,400 --> 01:17:57,739
again they give them suggestions to that

01:17:54,680 --> 01:18:00,170
you probably it was easy 14 or 28

01:17:57,739 --> 01:18:05,570
combining characters probably is enough

01:18:00,170 --> 01:18:07,370
for this very limited application but in

01:18:05,570 --> 01:18:17,630
general there is no limit to how many

01:18:07,370 --> 01:18:19,340
combine your back / x can contain more

01:18:17,630 --> 01:18:23,180
than one coat point and get none of them

01:18:19,340 --> 01:18:27,500
are marks the obvious example is

01:18:23,180 --> 01:18:34,130
character in line feet there are

01:18:27,500 --> 01:18:36,190
actually others um you have Matt there

01:18:34,130 --> 01:18:39,020
are math characters you can't see

01:18:36,190 --> 01:18:47,420
there's invisible x invisible

01:18:39,020 --> 01:18:51,200
plus there's only the first kind of

01:18:47,420 --> 01:18:55,880
Utica property support supported unicode

01:18:51,200 --> 01:19:00,790
blocks only not unicode scripts these

01:18:55,880 --> 01:19:04,010
are different things so the greek block

01:19:00,790 --> 01:19:05,780
has things in it that are Greek

01:19:04,010 --> 01:19:10,430
characters that are from the Greek

01:19:05,780 --> 01:19:14,240
script it also has things that are used

01:19:10,430 --> 01:19:17,630
in common with other scripts so they are

01:19:14,240 --> 01:19:22,160
not technically of of the Greek script

01:19:17,630 --> 01:19:23,390
type they are script type other and also

01:19:22,160 --> 01:19:25,790
there are many blocks that have

01:19:23,390 --> 01:19:29,960
unassigned code points in them in a room

01:19:25,790 --> 01:19:31,880
for expansion we may find some ancient

01:19:29,960 --> 01:19:39,380
etruscan manuscript and have to add

01:19:31,880 --> 01:19:43,150
letters to it ascii has a different idea

01:19:39,380 --> 01:19:47,960
of what punctuation is the unicorn has

01:19:43,150 --> 01:19:51,470
and if you use the in a red X if you use

01:19:47,960 --> 01:19:54,380
bracket colon poked colon bracket so you

01:19:51,470 --> 01:20:00,410
say give me the POSIX punctuation

01:19:54,380 --> 01:20:06,100
property it matches the Unicode

01:20:00,410 --> 01:20:10,540
punctuation and ascii symbols so POSIX

01:20:06,100 --> 01:20:10,540
punctuation includes a ski symbols

01:20:13,150 --> 01:20:22,700
there's no rule out character in E with

01:20:16,130 --> 01:20:26,540
a dr seuss there are all kinds of

01:20:22,700 --> 01:20:33,050
different dashes and hyphens um in

01:20:26,540 --> 01:20:36,860
unicode the most commonly used non ascii

01:20:33,050 --> 01:20:40,070
code point in this huge collection that

01:20:36,860 --> 01:20:43,150
I examined which is a the PubMed open

01:20:40,070 --> 01:20:49,719
access collection the most commonly used

01:20:43,150 --> 01:20:55,749
not as a good point was an n dash top

01:20:49,719 --> 01:21:04,749
or n dash not a hex a zero non non

01:20:55,749 --> 01:21:11,499
breaking space plus minus we thought is

01:21:04,749 --> 01:21:14,320
all punctuation essentially so instead

01:21:11,499 --> 01:21:16,119
of using a minus to match a minus you

01:21:14,320 --> 01:21:17,530
probably ought to say match something

01:21:16,119 --> 01:21:19,900
with the dash property because who knows

01:21:17,530 --> 01:21:25,179
how they encoded it which one they used

01:21:19,900 --> 01:21:31,929
oh this is even more complaints more

01:21:25,179 --> 01:21:34,719
gotchas so every time you open food out

01:21:31,929 --> 01:21:41,590
text and do not specify an encoding you

01:21:34,719 --> 01:21:45,130
have created a problem there's no such

01:21:41,590 --> 01:21:47,469
thing as a plain text file in your all

01:21:45,130 --> 01:21:50,289
there is is text files in some encoding

01:21:47,469 --> 01:21:55,179
because I promise you every text file

01:21:50,289 --> 01:21:57,219
has an encoding well why should I have

01:21:55,179 --> 01:22:02,829
to specify it should just be a default

01:21:57,219 --> 01:22:05,139
one you can establish the default and

01:22:02,829 --> 01:22:08,920
say use open and setting so you know

01:22:05,139 --> 01:22:11,409
what the revolvers but you can't reach

01:22:08,920 --> 01:22:21,969
you can't read it if you don't know what

01:22:11,409 --> 01:22:29,949
fits you got I hate platform-specific

01:22:21,969 --> 01:22:35,110
encodings least on Wikipedia pages it

01:22:29,949 --> 01:22:38,349
turns out that it takes more space to

01:22:35,110 --> 01:22:42,059
encode things in utf-16 than utf-8 even

01:22:38,349 --> 01:22:47,519
Chinese or Japanese why would that be

01:22:42,059 --> 01:22:47,519
because it's an HTML HTML isn't asking

01:22:47,999 --> 01:22:56,199
if you properly utf-8 right no no I'm

01:22:53,979 --> 01:22:59,139
saying if you can so there's this idea

01:22:56,199 --> 01:23:01,239
that oh if it's japanese text if you use

01:22:59,139 --> 01:23:03,460
utf-16 it will be smaller than if you

01:23:01,239 --> 01:23:05,380
use the utf-8

01:23:03,460 --> 01:23:10,810
not in a web page because web page has

01:23:05,380 --> 01:23:13,390
so much markup and that's an ask curl

01:23:10,810 --> 01:23:17,489
doesn't actually use utf-8 internally it

01:23:13,390 --> 01:23:24,420
uses this hybrid thing Larry made that

01:23:17,489 --> 01:23:26,739
it's not quite utf-8 what should you

01:23:24,420 --> 01:23:32,739
what happens when there's an encoding

01:23:26,739 --> 01:23:36,940
error usually nothing always nothing

01:23:32,739 --> 01:23:39,880
good but usually nothing at all which if

01:23:36,940 --> 01:23:41,500
you analyze the logic you will realize

01:23:39,880 --> 01:23:52,680
I've said that doing nothing at all is

01:23:41,500 --> 01:23:57,040
not a good thing um I say use utf-8 i

01:23:52,680 --> 01:24:01,239
use they use open with the right utf-8

01:23:57,040 --> 01:24:04,900
mumble and then I say use warnings fatal

01:24:01,239 --> 01:24:09,370
utf-8 I want to know about encoding

01:24:04,900 --> 01:24:11,800
errors um I want to know about them so

01:24:09,370 --> 01:24:16,680
intensely that I want to be shot dead if

01:24:11,800 --> 01:24:19,570
I don't trap the exception yes I do

01:24:16,680 --> 01:24:21,100
recommendation for a tool to say if

01:24:19,570 --> 01:24:23,320
you're just given a file and you don't

01:24:21,100 --> 01:24:29,520
know that's encoding too scared to try

01:24:23,320 --> 01:24:29,520
to get to or mon Dieu

01:24:30,360 --> 01:24:38,909
um I have Angie recommendations the ones

01:24:35,730 --> 01:24:41,670
out there don't work I wrote one that

01:24:38,909 --> 01:24:46,980
work I wrote one that is ninety-eight

01:24:41,670 --> 01:24:50,760
percent accurate on the corpus it was

01:24:46,980 --> 01:24:52,560
trained on but it should be right or at

01:24:50,760 --> 01:24:58,409
least I can narrow it down and say which

01:24:52,560 --> 01:25:01,170
is not work okay between utf-8 utf-16

01:24:58,409 --> 01:25:06,659
utf-32 I think that one you can figure

01:25:01,170 --> 01:25:11,820
out I'm the new um the problem is the

01:25:06,659 --> 01:25:19,350
8-bit encodings and there is no right

01:25:11,820 --> 01:25:22,050
answer that does not use machine

01:25:19,350 --> 01:25:23,850
learning intelligence and I put the

01:25:22,050 --> 01:25:27,210
module out there that does this and I

01:25:23,850 --> 01:25:30,750
have spaced its name sensitive anyway I

01:25:27,210 --> 01:25:35,820
trained it on a several immense corporal

01:25:30,750 --> 01:25:38,820
of English language text so it knows

01:25:35,820 --> 01:25:43,260
about the distribution of code points in

01:25:38,820 --> 01:25:46,619
English and it just it just scores your

01:25:43,260 --> 01:25:48,989
text according to well here's its core

01:25:46,619 --> 01:25:51,570
iphigin macro and here's its scored and

01:25:48,989 --> 01:25:53,610
CB 1250 score this and then whichever

01:25:51,570 --> 01:25:56,850
one comes up on top is its best guess

01:25:53,610 --> 01:26:00,630
and again its ninety-eight percent

01:25:56,850 --> 01:26:02,100
accurate on English tax but if you're

01:26:00,630 --> 01:26:06,989
getting stuff inside an English it's

01:26:02,100 --> 01:26:10,139
crap and I forget the same yep encode

01:26:06,989 --> 01:26:11,580
guests educated and if like an elf

01:26:10,139 --> 01:26:13,020
release because I don't I didn't

01:26:11,580 --> 01:26:17,639
document it does work and it passes

01:26:13,020 --> 01:26:20,699
tests but it's not documented it's a

01:26:17,639 --> 01:26:24,810
hard it's an insoluble problem in the

01:26:20,699 --> 01:26:27,619
general case it can be addressed if you

01:26:24,810 --> 01:26:30,949
have a small enough to nickname like

01:26:27,619 --> 01:26:30,949
just English

01:26:33,610 --> 01:26:37,519
because otherwise basically you have to

01:26:35,719 --> 01:26:39,619
determine what the text actually says

01:26:37,519 --> 01:26:41,510
like how you know if it's Icelandic

01:26:39,619 --> 01:26:43,309
first you know you do know it's an

01:26:41,510 --> 01:26:45,710
Icelandic so you can't use isolating I

01:26:43,309 --> 01:26:47,840
are just pulled the Atlantic and you

01:26:45,710 --> 01:26:50,570
have basically depend on the texts and

01:26:47,840 --> 01:26:53,829
read it and understand the distribution

01:26:50,570 --> 01:26:59,719
in every language on the planet which is

01:26:53,829 --> 01:27:01,519
oh no Google thinks they can do it but

01:26:59,719 --> 01:27:07,010
they have access to a larger corpus that

01:27:01,519 --> 01:27:12,280
I do um yes good point there are code

01:27:07,010 --> 01:27:12,280
points above unicode other silly things

01:27:12,579 --> 01:27:17,599
you cannot set dollar / to be something

01:27:16,429 --> 01:27:20,630
that works for you to code correctly

01:27:17,599 --> 01:27:24,739
because dollar / is a literal it's not a

01:27:20,630 --> 01:27:28,340
red X so you can't set it back / kappa

01:27:24,739 --> 01:27:29,960
is better scram power is not an escape

01:27:28,340 --> 01:27:32,059
that means a particular character it's a

01:27:29,960 --> 01:27:33,949
set of characters it's more than 7

01:27:32,059 --> 01:27:36,499
characters is either a two-character

01:27:33,949 --> 01:27:40,340
graphing or it's one of the center here

01:27:36,499 --> 01:27:44,239
so you can't sit down / can't do road

01:27:40,340 --> 01:27:47,329
tripping on casing because right the

01:27:44,239 --> 01:27:49,429
sigmas that if you uppercase a middle

01:27:47,329 --> 01:27:52,400
sigma or final sigma you both you get a

01:27:49,429 --> 01:27:55,219
capital Sigma but if you lower case that

01:27:52,400 --> 01:28:01,579
you it doesn't know which one we give

01:27:55,219 --> 01:28:04,729
you back um not every lowercase code

01:28:01,579 --> 01:28:09,409
point has a corresponding uppercase one

01:28:04,729 --> 01:28:12,400
or vice versa to go with it Carol I

01:28:09,409 --> 01:28:15,889
think they actually changed this in 62 I

01:28:12,400 --> 01:28:18,559
think they change these in maybes el

01:28:15,889 --> 01:28:20,840
amor l 00 or something oh no they

01:28:18,559 --> 01:28:22,969
already know it said they are LM problem

01:28:20,840 --> 01:28:29,329
is they were also marked other lower

01:28:22,969 --> 01:28:32,869
case yeah so these things are cased

01:28:29,329 --> 01:28:37,369
letters in the case map to themselves no

01:28:32,869 --> 01:28:40,269
matter what case map use if you say back

01:28:37,369 --> 01:28:40,269
p lower

01:28:41,240 --> 01:28:46,580
that Matt that does not match lowercase

01:28:44,600 --> 01:28:48,410
letters I mean it does not lower case

01:28:46,580 --> 01:28:52,700
letters but it matches more than that so

01:28:48,410 --> 01:28:55,580
back p lower is the this is a Huffman

01:28:52,700 --> 01:28:58,160
encoding win so the short thing is the

01:28:55,580 --> 01:28:59,870
thing you usually want to use it turns

01:28:58,160 --> 01:29:01,700
out that lower case letter is not the

01:28:59,870 --> 01:29:08,720
thing we usually want to use you want to

01:29:01,700 --> 01:29:12,590
use lowercase more anti-patterns right

01:29:08,720 --> 01:29:14,690
so don't assume so changing the case can

01:29:12,590 --> 01:29:18,620
change the length of the string this is

01:29:14,690 --> 01:29:24,290
a little unit chars um invocation that

01:29:18,620 --> 01:29:27,350
finds things that change ah other broken

01:29:24,290 --> 01:29:32,180
stuff there's more than two cases three

01:29:27,350 --> 01:29:41,300
cases in unicode there are non letters

01:29:32,180 --> 01:29:45,890
that have case hey there case there are

01:29:41,300 --> 01:29:48,310
case things that don't change case and

01:29:45,890 --> 01:29:52,700
this is that this is the anointing

01:29:48,310 --> 01:29:55,010
there's some kinds of locale issues if

01:29:52,700 --> 01:29:57,860
you're in Turkey or grease that you may

01:29:55,010 --> 01:30:06,820
want to think about with casing that is

01:29:57,860 --> 01:30:14,720
not covered by default lithuania choo I

01:30:06,820 --> 01:30:16,720
didn't know that what's it do it's

01:30:14,720 --> 01:30:20,020
complicated who would have guessed

01:30:16,720 --> 01:30:24,400
you're not talking about the legacy

01:30:20,020 --> 01:30:33,950
title case stuff are you ok I was

01:30:24,400 --> 01:30:38,450
different rules ok sure small caps are

01:30:33,950 --> 01:30:41,290
in lower case a small small capital a is

01:30:38,450 --> 01:30:41,290
a lowercase letter

01:30:43,330 --> 01:31:16,930
its name is small capital latin small

01:30:46,600 --> 01:31:19,320
capital this is the easiest way to find

01:31:16,930 --> 01:31:23,650
out all the code points for a particular

01:31:19,320 --> 01:31:25,900
so you know char's property dash will

01:31:23,650 --> 01:31:38,860
tell us that there are bunches of them

01:31:25,900 --> 01:31:40,540
ah yes this is only reg ex talk not

01:31:38,860 --> 01:31:42,690
general unicode if it will general you

01:31:40,540 --> 01:31:49,960
cannot talk to you about print columns

01:31:42,690 --> 01:31:52,500
in Asian character with them cjk often

01:31:49,960 --> 01:31:54,700
you've got white characters and

01:31:52,500 --> 01:31:58,990
sometimes you've got sometimes white

01:31:54,700 --> 01:32:03,040
characters either just a east asian with

01:31:58,990 --> 01:32:06,040
it equals ambiguous where it depends on

01:32:03,040 --> 01:32:14,650
what it's around because they'll use at

01:32:06,040 --> 01:32:16,930
values our symbols but when it's our SAS

01:32:14,650 --> 01:32:19,810
key symbols or regular symbols in the

01:32:16,930 --> 01:32:21,460
middle of wide text those symbols need

01:32:19,810 --> 01:32:24,100
to be wide too so it takes up the same

01:32:21,460 --> 01:32:28,960
number pretty cold that's it's not good

01:32:24,100 --> 01:32:32,680
problem and unicode GCS straightened

01:32:28,960 --> 01:32:36,600
rests that let's never assume that

01:32:32,680 --> 01:32:38,800
characters that look alike are like move

01:32:36,600 --> 01:32:42,430
never assume that characters that do not

01:32:38,800 --> 01:32:45,190
look alike don't act the same so unless

01:32:42,430 --> 01:32:47,890
the two there's no limit to the number

01:32:45,190 --> 01:32:50,970
of characters and back / x 0 back side

01:32:47,890 --> 01:32:53,440
shacks can start with a combining work

01:32:50,970 --> 01:32:58,350
the file might start with combining mark

01:32:53,440 --> 01:32:58,350
what are you do are the limelight

01:33:05,140 --> 01:33:19,520
what's hacks for apps nobody know is it

01:33:17,810 --> 01:33:25,820
a character wasn't that something that

01:33:19,520 --> 01:33:36,890
was only appears in like utf-16 that's a

01:33:25,820 --> 01:33:39,890
different problem it is an unassigned

01:33:36,890 --> 01:33:42,050
non character code point it is not legal

01:33:39,890 --> 01:33:46,970
for open interchange but it is it is a

01:33:42,050 --> 01:33:53,990
unicode code point it has no name you're

01:33:46,970 --> 01:34:03,070
thinking of the utf-8 byte order markers

01:33:53,990 --> 01:34:06,680
bombs you know that's not sticking up

01:34:03,070 --> 01:34:10,120
there that's a byte order mark in the

01:34:06,680 --> 01:34:12,320
wrong order surrogates those are like

01:34:10,120 --> 01:34:14,960
see you're not supposed to find these in

01:34:12,320 --> 01:34:18,710
ut fnh streams if you find them in a

01:34:14,960 --> 01:34:23,150
utf-8 stream it is not a legal utf-8

01:34:18,710 --> 01:34:27,730
stream most of the there are a lot of

01:34:23,150 --> 01:34:31,970
those out there it's called csce su8

01:34:27,730 --> 01:34:35,690
where they take AA something above the

01:34:31,970 --> 01:34:39,440
basic multilingual plane so it takes

01:34:35,690 --> 01:34:42,740
more than four hex digits right and they

01:34:39,440 --> 01:34:44,840
split it into the to utf-8 16 surrogates

01:34:42,740 --> 01:34:48,710
and then they encode both of those as

01:34:44,840 --> 01:35:01,220
utf-8 this is not legal utf-8 it happens

01:34:48,710 --> 01:35:04,190
a lot though that's oh did you say use

01:35:01,220 --> 01:35:09,190
warnings failed utf-8 then yes it does

01:35:04,190 --> 01:35:09,190
did you forget to say that no I'm sorry

01:35:31,490 --> 01:35:35,300
what's the right to do

01:36:43,469 --> 01:36:54,059
sorry um no way there are so many slide

01:36:51,599 --> 01:36:57,329
back I think I was complaining a lot oh

01:36:54,059 --> 01:37:03,690
so this is the CZ weight problem well

01:36:57,329 --> 01:37:06,090
let's see oh yeah look at this 12 is

01:37:03,690 --> 01:37:09,769
less than 3 45 is less than six seven

01:37:06,090 --> 01:37:13,499
eight nine that's a literal string if

01:37:09,769 --> 01:37:19,170
you print it out sometimes it doesn't

01:37:13,499 --> 01:37:25,199
look like that that's a right to left

01:37:19,170 --> 01:37:29,119
and bedding and now my 12 less than 3 45

01:37:25,199 --> 01:37:37,260
is a 345 is greater than 12 which is

01:37:29,119 --> 01:37:39,329
still true you'll note um and then

01:37:37,260 --> 01:37:43,800
there's right to left over low override

01:37:39,329 --> 01:37:46,800
which does something different again so

01:37:43,800 --> 01:37:50,999
your literal strings so bi-directional

01:37:46,800 --> 01:37:53,940
text has weird stuff going with it yes

01:37:50,999 --> 01:37:57,690
the answer about their use utf-8 stuff

01:37:53,940 --> 01:37:59,159
what does it circus the codes being

01:37:57,690 --> 01:38:01,710
worked on for you get your reading your

01:37:59,159 --> 01:38:04,139
utf-8 you guys stricken there it's got

01:38:01,710 --> 01:38:05,639
options so when you open that file you

01:38:04,139 --> 01:38:09,360
can tell it the sands is not pretty

01:38:05,639 --> 01:38:11,099
satisfying anyway you can tell it I want

01:38:09,360 --> 01:38:13,019
I want to read a file with utf-8 and

01:38:11,099 --> 01:38:15,059
then you can turn on loose or strict

01:38:13,019 --> 01:38:17,999
which either allow their disallows

01:38:15,059 --> 01:38:21,389
individually surrogates non Pericles and

01:38:17,999 --> 01:38:24,630
montrose storms but my inspection Dakota

01:38:21,389 --> 01:38:26,519
with the default values they combine but

01:38:24,630 --> 01:38:28,820
but it lets you take what you think the

01:38:26,519 --> 01:38:28,820
right things

01:38:31,219 --> 01:38:41,429
I'm just looking for interesting thing

01:38:34,099 --> 01:38:43,499
oh don't do ranges don't do square

01:38:41,429 --> 01:38:46,019
bracket so I advise another square

01:38:43,499 --> 01:38:50,760
bracket character classes where you say

01:38:46,019 --> 01:38:53,010
like ASG don't do pick some random you

01:38:50,760 --> 01:38:54,989
Coco point dash some other random you

01:38:53,010 --> 01:39:01,109
Coco point and think you can get

01:38:54,989 --> 01:39:05,639
anything saying at me right so people

01:39:01,109 --> 01:39:07,799
will write a capital a dash little Z in

01:39:05,639 --> 01:39:09,889
square brackets and they say well that

01:39:07,799 --> 01:39:15,059
will get all the upper and lowercase

01:39:09,889 --> 01:39:16,379
ascii letters and yeah Sarah will also

01:39:15,059 --> 01:39:24,089
get six other things that are

01:39:16,379 --> 01:39:27,659
punctuation or so you know there are 24

01:39:24,089 --> 01:39:29,819
letters in the rebuilt bit so I say

01:39:27,659 --> 01:39:36,749
alpha dash omega how many letters do I

01:39:29,819 --> 01:39:39,809
get didn't I just tell you there are 24

01:39:36,749 --> 01:39:41,519
letters and alpha and omega that's

01:39:39,809 --> 01:39:45,149
beginning again right so there should be

01:39:41,519 --> 01:39:47,219
24 so it's just not the way it's laid up

01:39:45,149 --> 01:39:54,959
and those are the easy ones you want to

01:39:47,219 --> 01:40:04,439
see Cyrillic yeah I don't know it saying

01:39:54,959 --> 01:40:05,669
oh it probably does you can do that but

01:40:04,439 --> 01:40:08,159
you're missing the good points that are

01:40:05,669 --> 01:40:12,959
used on creating properly that's that's

01:40:08,159 --> 01:40:16,679
a problem yes yeah there are many

01:40:12,959 --> 01:40:19,649
variants on silica you're probably it

01:40:16,679 --> 01:40:21,780
probably works for Russian yeah well

01:40:19,649 --> 01:40:24,109
there's more things that you select in

01:40:21,780 --> 01:40:24,109
Russian

01:40:27,239 --> 01:40:32,360
they when you took Russian there was no

01:40:29,880 --> 01:40:38,849
such place as the Ukraine there was

01:40:32,360 --> 01:40:40,800
another pace of the Soviet Union oh yes

01:40:38,849 --> 01:40:42,900
I was just complained too much you know

01:40:40,800 --> 01:40:44,489
so what I wanted to do is there's a

01:40:42,900 --> 01:40:48,320
couple of other things that aren't reg

01:40:44,489 --> 01:40:56,190
ex related but they are unicode things

01:40:48,320 --> 01:40:59,610
and i can't i make this thing yes

01:40:56,190 --> 01:41:02,280
question we're here yes please I've been

01:40:59,610 --> 01:41:05,219
purity I didn't hear any mention of say

01:41:02,280 --> 01:41:08,519
nf-kb for example I wondered if you

01:41:05,219 --> 01:41:15,869
wanted to do sort of fuzzy matching like

01:41:08,519 --> 01:41:17,999
whether pulling things at the nf-kb okay

01:41:15,869 --> 01:41:22,199
I only missed a few minutes oh that was

01:41:17,999 --> 01:41:28,070
very beginning of the top it may make

01:41:22,199 --> 01:41:32,130
sense geez compatibility composition um

01:41:28,070 --> 01:41:42,210
specialist rich okay so you didn't

01:41:32,130 --> 01:41:47,480
mention okay don't you need this adobe

01:41:42,210 --> 01:41:47,480
really and climate on the set our old

01:41:52,510 --> 01:41:59,510
otherwise how do you search for

01:41:54,020 --> 01:42:03,590
something with small cats exactly it's

01:41:59,510 --> 01:42:05,030
not funny so I actually get cin proposed

01:42:03,590 --> 01:42:07,790
to different parks and this is another

01:42:05,030 --> 01:42:13,130
talk I did get this is Ozma and here I

01:42:07,790 --> 01:42:15,560
talked about and there there's a URL for

01:42:13,130 --> 01:42:27,710
this talk if you wanted that is from Oz

01:42:15,560 --> 01:42:35,810
con to 11 I wanted to go to some of the

01:42:27,710 --> 01:42:37,910
cool stuff is so here I explain it a

01:42:35,810 --> 01:42:39,830
little bit more clearly how why you

01:42:37,910 --> 01:42:41,930
should start your programs in certain

01:42:39,830 --> 01:42:46,070
ways where you want to deal with unicode

01:42:41,930 --> 01:42:49,070
can you see that yet yeah okay so first

01:42:46,070 --> 01:42:53,510
you want to say i would say at least use

01:42:49,070 --> 01:42:55,970
512 if not 5 dal 14 things start to get

01:42:53,510 --> 01:42:58,430
saying buy them then you declare the

01:42:55,970 --> 01:43:03,800
source unit is utf-8 which means you say

01:42:58,430 --> 01:43:12,440
use utf-8 ah turn strict turn on

01:43:03,800 --> 01:43:16,850
warnings and turn on fatal utf-8 you may

01:43:12,440 --> 01:43:20,240
want to turn off certain kinds of sub

01:43:16,850 --> 01:43:23,410
warnings so in five dot 14 the utf-8

01:43:20,240 --> 01:43:26,440
morning class has three subclasses

01:43:23,410 --> 01:43:30,050
called non char surrogate and

01:43:26,440 --> 01:43:34,970
non-unicode do i explain what those each

01:43:30,050 --> 01:43:38,600
are no great so non character there are

01:43:34,970 --> 01:43:41,120
66 unicode code points that are never

01:43:38,600 --> 01:43:44,360
that are specifically called non

01:43:41,120 --> 01:43:48,200
character cool points like ffff you will

01:43:44,360 --> 01:43:50,240
get a warning if you encounter them in

01:43:48,200 --> 01:43:53,720
utf-8 stream and of course if your fatal

01:43:50,240 --> 01:43:58,250
izing those that will kill you so you

01:43:53,720 --> 01:43:59,900
might say i want you know fatal things

01:43:58,250 --> 01:44:02,690
with utf8 because I've got encoding

01:43:59,900 --> 01:44:05,180
errors or something but if i get a non

01:44:02,690 --> 01:44:05,630
character code point maybe i want to let

01:44:05,180 --> 01:44:08,840
that

01:44:05,630 --> 01:44:12,230
slip by so you could say no warnings

01:44:08,840 --> 01:44:16,120
down charm surrogates should not be in

01:44:12,230 --> 01:44:24,770
utf-8 dream so that one is on by default

01:44:16,120 --> 01:44:26,900
non-unicode means above x10 FFM so

01:44:24,770 --> 01:44:34,300
sometimes you'll turn want to turn some

01:44:26,900 --> 01:44:36,679
of those declare a default encoding

01:44:34,300 --> 01:44:43,699
that's for the whole program now it's

01:44:36,679 --> 01:44:47,090
not just um commscope that's what I mean

01:44:43,699 --> 01:44:49,630
use open is the Turk current scope it is

01:44:47,090 --> 01:44:52,760
lexically scoped right I think that

01:44:49,630 --> 01:44:56,360
opens for it the current scope but CS

01:44:52,760 --> 01:44:59,840
this for a third screw right so if you

01:44:56,360 --> 01:45:02,210
say pearl dash capital CS or set in the

01:44:59,840 --> 01:45:04,100
pro unicode so the environment variable

01:45:02,210 --> 01:45:09,710
internal employees are for the whole

01:45:04,100 --> 01:45:12,290
program but use open is scoped um i also

01:45:09,710 --> 01:45:15,969
put a use char names and everything now

01:45:12,290 --> 01:45:19,639
get this is weird even with use open or

01:45:15,969 --> 01:45:23,179
you're her 0 uter code variable or pearl

01:45:19,639 --> 01:45:26,449
dash capital CS none of those do

01:45:23,179 --> 01:45:34,670
anything to data so if you want utf-8 in

01:45:26,449 --> 01:45:36,800
your data you have to on big motive what

01:45:34,670 --> 01:45:40,130
does that all together look like looks

01:45:36,800 --> 01:45:42,320
like this don't take the palm bang line

01:45:40,130 --> 01:45:45,679
too seriously replace it with whatever

01:45:42,320 --> 01:45:47,179
you guys need to do from your system so

01:45:45,679 --> 01:45:49,639
if you're going to write a unicorn

01:45:47,179 --> 01:45:52,429
program you might want to put this kind

01:45:49,639 --> 01:45:57,889
of thing at the top of it have a

01:45:52,429 --> 01:46:03,730
standard template under five dot 16 you

01:45:57,889 --> 01:46:11,210
get full and short chartings for free

01:46:03,730 --> 01:46:13,030
yes that's right I test my return

01:46:11,210 --> 01:46:15,350
pellets

01:46:13,030 --> 01:46:18,560
it's true should have mentioned that

01:46:15,350 --> 01:46:25,940
again use open and use all value not

01:46:18,560 --> 01:46:33,440
play well together which one would you

01:46:25,940 --> 01:46:34,880
rather have I asked why we did it was

01:46:33,440 --> 01:46:42,710
suggested to me that that cannot be

01:46:34,880 --> 01:46:45,890
fixed I don't know why some other things

01:46:42,710 --> 01:46:49,100
you'll often want our use unicode

01:46:45,890 --> 01:46:53,450
normalize pullen n FD and NFC maybe the

01:46:49,100 --> 01:46:55,750
other two ah sometimes you'll need

01:46:53,450 --> 01:46:58,340
encode and decode but not very often

01:46:55,750 --> 01:47:03,560
usually you should set the encoding on

01:46:58,340 --> 01:47:07,070
the stream if you need to call and Cody

01:47:03,560 --> 01:47:08,720
coat on particular pieces of data I mean

01:47:07,070 --> 01:47:11,420
sometimes this happens like with dbm

01:47:08,720 --> 01:47:13,490
files or database files it comes to you

01:47:11,420 --> 01:47:15,950
and coding you have to decode it but if

01:47:13,490 --> 01:47:17,690
it's stream and the stream is all the

01:47:15,950 --> 01:47:20,630
same encoding just set it once and for

01:47:17,690 --> 01:47:22,310
all on that street don't manually encode

01:47:20,630 --> 01:47:24,320
and decode every Pete's the same way

01:47:22,310 --> 01:47:27,970
because if you never forget to do one of

01:47:24,320 --> 01:47:27,970
them right then it will be right

01:47:33,909 --> 01:47:41,270
what's this last line floor why did I

01:47:36,440 --> 01:47:43,580
put that in my standard template it's

01:47:41,270 --> 01:47:50,960
connected to the pager this connected to

01:47:43,580 --> 01:47:53,420
the pager that's right if you are in

01:47:50,960 --> 01:47:55,310
fact if you are using auto die of course

01:47:53,420 --> 01:48:00,130
that doesn't work open then that would

01:47:55,310 --> 01:48:03,260
catch other things too like you cook you

01:48:00,130 --> 01:48:07,780
that's annoying with the pager because

01:48:03,260 --> 01:48:07,780
you'll get the pipe clothes failure oh

01:48:09,250 --> 01:48:17,530
look at this have you ever tried saying

01:48:14,960 --> 01:48:22,310
use warnings fatal all in your program

01:48:17,530 --> 01:48:28,070
doesn't work very well well okay have

01:48:22,310 --> 01:48:30,199
you ever had a compile-time warning it

01:48:28,070 --> 01:48:32,210
will kill your compiler not only does it

01:48:30,199 --> 01:48:35,210
kill the compiler you'll never know why

01:48:32,210 --> 01:48:39,590
because it causes a cascade of errors

01:48:35,210 --> 01:48:42,590
and so you really can't do fatal board

01:48:39,590 --> 01:48:45,469
as a compiler must now it messes things

01:48:42,590 --> 01:48:46,820
up does the compiler is set up if it's

01:48:45,469 --> 01:48:49,310
going to give you a warning instead of

01:48:46,820 --> 01:48:51,500
an error it wants to ignore it and you

01:48:49,310 --> 01:48:53,389
will not learn what really caused it

01:48:51,500 --> 01:48:55,369
because the first one may not be the one

01:48:53,389 --> 01:49:01,610
we need to see the first morning is one

01:48:55,369 --> 01:49:04,760
that kills so you can set up set up a

01:49:01,610 --> 01:49:10,909
cig die handler to do a stack back-trace

01:49:04,760 --> 01:49:14,750
at runtime and you know with warnings

01:49:10,909 --> 01:49:17,750
too now that fate Eliza's warnings at

01:49:14,750 --> 01:49:19,480
runtime is civic compile Tony I wish

01:49:17,750 --> 01:49:23,030
there were a way to say use warnings

01:49:19,480 --> 01:49:25,369
deferred or something to wait until the

01:49:23,030 --> 01:49:30,460
unit check is the has done until it's

01:49:25,369 --> 01:49:30,460
done compiling and this is a workaround

01:49:31,330 --> 01:49:38,239
dollar here it is all right so this and

01:49:36,139 --> 01:49:41,090
this is what I do with my normal little

01:49:38,239 --> 01:49:44,090
unix filters so I say if I didn't get

01:49:41,090 --> 01:49:46,310
any arguments and standard n is the

01:49:44,090 --> 01:49:48,290
terminal and standard error is

01:49:46,310 --> 01:49:52,460
then remind the guy that he's supposed

01:49:48,290 --> 01:49:54,250
to be typing and then i do my filter

01:49:52,460 --> 01:49:56,540
thing when i do the filter I normalize

01:49:54,250 --> 01:49:58,390
to decomposition on the way in I

01:49:56,540 --> 01:50:01,580
normalized composition all the way out

01:49:58,390 --> 01:50:03,710
so if you get get this version of the

01:50:01,580 --> 01:50:06,080
sliding pull these and this just kind of

01:50:03,710 --> 01:50:09,610
a template that I keep sitting around

01:50:06,080 --> 01:50:18,320
when I want to write a a unicode aware

01:50:09,610 --> 01:50:20,270
filter are just plugging this time this

01:50:18,320 --> 01:50:24,170
is from the pearl run man page it tells

01:50:20,270 --> 01:50:27,430
you what your pearl a Unicode

01:50:24,170 --> 01:50:29,840
environment variable can be set to I

01:50:27,430 --> 01:50:31,400
think I'm the only one who ever uses

01:50:29,840 --> 01:50:35,060
this I don't think other people uses I

01:50:31,400 --> 01:50:39,080
run with mine set to si in my login

01:50:35,060 --> 01:50:42,440
script I export pro unicode equals SI

01:50:39,080 --> 01:50:47,990
don't use the D you'll be very sad if

01:50:42,440 --> 01:50:54,850
you say SI d then you have now set the

01:50:47,990 --> 01:50:59,090
default encoding on disk files um and

01:50:54,850 --> 01:51:00,740
Perl code that xpro grams see if a

01:50:59,090 --> 01:51:02,720
windows programmer wouldn't have screwed

01:51:00,740 --> 01:51:05,870
this up is he's used to having big load

01:51:02,720 --> 01:51:08,420
things but the UNIX programmers expect

01:51:05,870 --> 01:51:10,430
in that if he doesn't mark the encoding

01:51:08,420 --> 01:51:14,210
it's a binary file you can get fights

01:51:10,430 --> 01:51:17,720
that if you set the D flag and he'll

01:51:14,210 --> 01:51:22,040
screw that up we tried that once it

01:51:17,720 --> 01:51:25,370
doesn't work yes that was up the easy

01:51:22,040 --> 01:51:26,690
stuff and there were 14 I won't do it

01:51:25,370 --> 01:51:29,120
there were 40 more slides in that

01:51:26,690 --> 01:51:34,070
talking that's all hard stuff you could

01:51:29,120 --> 01:51:35,780
but we don't do char names pragma I like

01:51:34,070 --> 01:51:39,230
the chardonnays treadmill because I want

01:51:35,780 --> 01:51:44,720
to use backslash n next nice capital n

01:51:39,230 --> 01:51:48,590
so you can name the character I almost

01:51:44,720 --> 01:51:53,090
never use the script names i usually use

01:51:48,590 --> 01:51:55,660
fuller short but you can say give me all

01:51:53,090 --> 01:51:58,640
the Cyrillic and Greek names and then

01:51:55,660 --> 01:51:59,600
you can just say backslash n Sigma you

01:51:58,640 --> 01:52:05,630
don't have to say

01:51:59,600 --> 01:52:08,810
Greek capital letter whatever you can

01:52:05,630 --> 01:52:10,520
make your own Charming's so not only can

01:52:08,810 --> 01:52:15,800
you make your own properties for right

01:52:10,520 --> 01:52:19,130
answers you can make your own care named

01:52:15,800 --> 01:52:25,580
characters and the reason this is useful

01:52:19,130 --> 01:52:27,140
is because well for one thing it might

01:52:25,580 --> 01:52:30,560
be too long to type but for an other

01:52:27,140 --> 01:52:32,360
thing that's important there are

01:52:30,560 --> 01:52:37,030
characters that have no names the

01:52:32,360 --> 01:52:37,030
private use characters have no names um

01:52:37,120 --> 01:52:41,540
if you do not name your characters now

01:52:40,130 --> 01:52:44,840
you've got magic numbers in your code

01:52:41,540 --> 01:52:47,360
that that makes it hard to maintain so

01:52:44,840 --> 01:52:51,410
one of the ones I've use is on the apple

01:52:47,360 --> 01:52:56,260
logo so use Charming's with an alias of

01:52:51,410 --> 01:53:06,560
apple logo goes to or whatever it is Oh

01:52:56,260 --> 01:53:08,360
something f8 FF so it's nice to invent

01:53:06,560 --> 01:53:11,000
your own names for properties in

01:53:08,360 --> 01:53:14,240
character in fact you can actually turn

01:53:11,000 --> 01:53:16,520
out your whole your own private you

01:53:14,240 --> 01:53:18,500
Syria block and just define properties

01:53:16,520 --> 01:53:20,930
and everything for it and character

01:53:18,500 --> 01:53:23,690
names I did that with the proposed

01:53:20,930 --> 01:53:25,670
tangle our block for tokina the defined

01:53:23,690 --> 01:53:29,060
tegra properties and character many

01:53:25,670 --> 01:53:33,320
plates forks bar almost it doesn't play

01:53:29,060 --> 01:53:35,210
nicely with back /w right so it doesn't

01:53:33,320 --> 01:53:38,780
it's a private use Carolyn it doesn't

01:53:35,210 --> 01:53:41,150
suddenly become also an alphabetic just

01:53:38,780 --> 01:53:44,720
because you've done these games that's

01:53:41,150 --> 01:53:51,590
okay I'll just at the end of my time any

01:53:44,720 --> 01:53:53,540
questions yes one comment earlier in

01:53:51,590 --> 01:53:56,960
your you mentioned that we buy your

01:53:53,540 --> 01:54:00,680
cocoa late if you want to ignore your

01:53:56,960 --> 01:54:03,290
diagrams I used level one but have to

01:54:00,680 --> 01:54:06,920
ignore pace as well what I wanted yes

01:54:03,290 --> 01:54:10,580
there's the attribute I ignore level to

01:54:06,920 --> 01:54:11,000
that you can I've set to true value and

01:54:10,580 --> 01:54:13,100
it

01:54:11,000 --> 01:54:18,200
that you can use whatever level you'd

01:54:13,100 --> 01:54:20,750
like elevate is this you thank you they

01:54:18,200 --> 01:54:22,760
keep adding new things to the that's not

01:54:20,750 --> 01:54:29,150
right anymore duh this is the list of

01:54:22,760 --> 01:54:31,700
your call later Artemis and I just

01:54:29,150 --> 01:54:34,460
worked out that I get up I'll think baby

01:54:31,700 --> 01:54:39,230
Adam of Newark you could we do I know

01:54:34,460 --> 01:54:43,870
that so you've been able to ignore

01:54:39,230 --> 01:54:46,910
accents but still have case right

01:54:43,870 --> 01:54:57,770
obviously something they needed it's a

01:54:46,910 --> 01:55:03,320
public nor underscore going to yep there

01:54:57,770 --> 01:55:05,330
it is if it's a new one I have to send

01:55:03,320 --> 01:55:10,850
you out so other people can can come in

01:55:05,330 --> 01:55:12,110
here sorry so you get the easy good yes

01:55:10,850 --> 01:55:14,360
you can get the thing I thought you

01:55:12,110 --> 01:55:18,770
could not get because you used it up

01:55:14,360 --> 01:55:20,870
table yet it again these this particular

01:55:18,770 --> 01:55:26,330
this other slide set is at a different

01:55:20,870 --> 01:55:31,750
place this second set was from Oz con

01:55:26,330 --> 01:55:31,750

YouTube URL: https://www.youtube.com/watch?v=74Ls6CmJJSE


