Title: Martin Holste   Perl for Big Data
Publication date: 2013-08-20
Playlist: YAPC::NA 2012
Description: 
	
Captions: 
	00:00:03,859 --> 00:00:13,860
okay according to my ntp server it's

00:00:06,690 --> 00:00:15,929
1530 so I guess I'll get started so this

00:00:13,860 --> 00:00:17,850
talk is pearl for big data and if

00:00:15,929 --> 00:00:20,070
there's anything you find controversial

00:00:17,850 --> 00:00:22,920
in it by all means speak up and we'll

00:00:20,070 --> 00:00:24,810
make it a forum will try to keep it as

00:00:22,920 --> 00:00:26,609
structured as possible but there may be

00:00:24,810 --> 00:00:29,189
some things that I'm sure that your

00:00:26,609 --> 00:00:31,349
personal experience doesn't reflect so

00:00:29,189 --> 00:00:33,270
I'm interested in those experiences as

00:00:31,349 --> 00:00:34,829
well it's probably easier if we say

00:00:33,270 --> 00:00:36,390
those to the end but I'm just giving you

00:00:34,829 --> 00:00:38,850
an upfront disclaimer there's probably

00:00:36,390 --> 00:00:39,540
stuff in here that may find you might

00:00:38,850 --> 00:00:41,399
find out at least a little

00:00:39,540 --> 00:00:43,770
counterintuitive and I'd be happy to

00:00:41,399 --> 00:00:46,110
explain how I arrived that conclusion

00:00:43,770 --> 00:00:50,250
and I only know what is correct as that

00:00:46,110 --> 00:00:52,350
so by all means let me know a little bit

00:00:50,250 --> 00:00:54,390
about me has you can find me on twitter

00:00:52,350 --> 00:00:56,190
if you have any follow-up questions it's

00:00:54,390 --> 00:00:59,129
also gmail if you have any email

00:00:56,190 --> 00:01:02,100
questions most of the stuff on else i

00:00:59,129 --> 00:01:04,439
put up on my blog and I need to point

00:01:02,100 --> 00:01:07,290
out that my my day job is security and

00:01:04,439 --> 00:01:09,210
it's sort of programming as a function

00:01:07,290 --> 00:01:10,590
of security so I'm very intimidated at

00:01:09,210 --> 00:01:12,270
this conference because I've given a

00:01:10,590 --> 00:01:14,130
couple of Elsa talks but they've all

00:01:12,270 --> 00:01:16,229
been to security people and I've never

00:01:14,130 --> 00:01:19,080
given one to people who program much

00:01:16,229 --> 00:01:20,490
much better than I do so well I

00:01:19,080 --> 00:01:21,840
shouldn't say it like that but that

00:01:20,490 --> 00:01:23,549
where where I'm sure that almost

00:01:21,840 --> 00:01:27,140
everyone at the conference program is

00:01:23,549 --> 00:01:27,140
better than I do I'll put it that way

00:01:28,880 --> 00:01:35,659
can you read there at the bottom

00:01:30,560 --> 00:01:35,659
excellence again the fine

00:01:38,790 --> 00:01:42,490
I'm not so concerned with a joke I just

00:01:41,200 --> 00:01:47,770
want to make sure the font is going to

00:01:42,490 --> 00:01:49,960
be appropriate later on okay so the

00:01:47,770 --> 00:01:52,420
first big question is what is big data

00:01:49,960 --> 00:01:55,570
if you are a vendor big data is anything

00:01:52,420 --> 00:01:58,690
I can sell you it's definitely a

00:01:55,570 --> 00:02:01,060
buzzword so these are the some of the

00:01:58,690 --> 00:02:04,120
things that come to my mind when we're

00:02:01,060 --> 00:02:06,160
talking about Big Data your basic

00:02:04,120 --> 00:02:07,390
procedures don't work that's kind of

00:02:06,160 --> 00:02:09,310
when you know that you're in a new

00:02:07,390 --> 00:02:10,540
league because all the things that

00:02:09,310 --> 00:02:13,090
people tell you to do or that you read

00:02:10,540 --> 00:02:15,430
about or that is sort of level one stuff

00:02:13,090 --> 00:02:17,380
is not working anymore specifically you

00:02:15,430 --> 00:02:19,870
cannot do insert or select those two

00:02:17,380 --> 00:02:21,610
things if they work on your data set

00:02:19,870 --> 00:02:24,160
then I don't think you have big data

00:02:21,610 --> 00:02:27,780
that if you can perform that function

00:02:24,160 --> 00:02:30,820
then you're you're in a different league

00:02:27,780 --> 00:02:33,520
so along with that that means that you

00:02:30,820 --> 00:02:34,780
cannot just say for each record period

00:02:33,520 --> 00:02:36,790
you can't just say I'm going to iterate

00:02:34,780 --> 00:02:39,670
over my entire data set and expect to

00:02:36,790 --> 00:02:43,060
finish and the important caveat there is

00:02:39,670 --> 00:02:45,850
that the incoming data is growing faster

00:02:43,060 --> 00:02:47,290
than the amount that you can query so

00:02:45,850 --> 00:02:49,420
sure if you get enough time and enough

00:02:47,290 --> 00:02:52,150
disk anybody can iterate the question is

00:02:49,420 --> 00:02:53,800
can you iterate in the time it takes for

00:02:52,150 --> 00:02:55,959
new data to arrive and i think that's

00:02:53,800 --> 00:03:00,340
another key factor that separates big

00:02:55,959 --> 00:03:01,989
data from less than big data and you

00:03:00,340 --> 00:03:04,209
can't control how much you're getting so

00:03:01,989 --> 00:03:06,280
you can't just specify well business

00:03:04,209 --> 00:03:11,500
send me less data it that's not your

00:03:06,280 --> 00:03:13,480
option so when I have people that are

00:03:11,500 --> 00:03:15,220
going to contribute data into our giant

00:03:13,480 --> 00:03:18,130
data set is that okay well do I need to

00:03:15,220 --> 00:03:19,840
let you know that it's coming no it's

00:03:18,130 --> 00:03:24,940
fine just just send it will find out

00:03:19,840 --> 00:03:27,400
later so that's kind of when I found out

00:03:24,940 --> 00:03:29,650
that we were not being able to use a lot

00:03:27,400 --> 00:03:32,170
of the stuff normal people use so that

00:03:29,650 --> 00:03:35,760
this is a snapshot from today on one

00:03:32,170 --> 00:03:39,519
server can anybody read that in the back

00:03:35,760 --> 00:03:42,340
that's right that was from today that

00:03:39,519 --> 00:03:44,109
that compasses well I'll have the stats

00:03:42,340 --> 00:03:47,019
at the end but about a week's worth and

00:03:44,109 --> 00:03:48,620
that's on one server so that you will

00:03:47,019 --> 00:03:49,909
not be able to select on that

00:03:48,620 --> 00:03:54,470
and hope for it to finish within a

00:03:49,909 --> 00:03:56,720
couple of weeks so I mention that I'm

00:03:54,470 --> 00:04:00,260
security so what we're doing is a lot of

00:03:56,720 --> 00:04:02,540
data analysis on security stuff but why

00:04:00,260 --> 00:04:04,159
you can throw a big terms like data

00:04:02,540 --> 00:04:06,560
modeling and other things like that what

00:04:04,159 --> 00:04:08,239
it's more about what happened when into

00:04:06,560 --> 00:04:10,610
what and or sorry what happened when

00:04:08,239 --> 00:04:12,110
where and then you're trying to put all

00:04:10,610 --> 00:04:14,690
that together with analysis to find out

00:04:12,110 --> 00:04:16,400
why so these are the same questions that

00:04:14,690 --> 00:04:18,620
most of our ops people have so there's a

00:04:16,400 --> 00:04:20,000
really nice dovetail between the things

00:04:18,620 --> 00:04:21,350
that we need to find out insecurity and

00:04:20,000 --> 00:04:23,120
the things that everybody else in the

00:04:21,350 --> 00:04:25,430
organization needs to know even up

00:04:23,120 --> 00:04:26,389
through the business where they're just

00:04:25,430 --> 00:04:28,010
trying to figure out okay how many

00:04:26,389 --> 00:04:30,680
people visited a website that kind of

00:04:28,010 --> 00:04:31,970
stuff it's all the same question you go

00:04:30,680 --> 00:04:33,770
through a huge amount of data and then

00:04:31,970 --> 00:04:38,120
come up with an answer in an ad hoc

00:04:33,770 --> 00:04:39,590
fashion so we originally looked at

00:04:38,120 --> 00:04:41,800
splunk and found out what almost

00:04:39,590 --> 00:04:45,169
everyone else did it's really expensive

00:04:41,800 --> 00:04:47,180
we're like what it does but for us it B

00:04:45,169 --> 00:04:48,710
is somewhere in the realm of a million

00:04:47,180 --> 00:04:53,330
bucks a year so I figured I deserve a

00:04:48,710 --> 00:04:54,740
raise anyway so that's that's sort of

00:04:53,330 --> 00:04:57,889
the inspiration but we do a lot of

00:04:54,740 --> 00:04:59,150
things that splunk does not and I'm

00:04:57,889 --> 00:05:01,639
going to say it again it's free so

00:04:59,150 --> 00:05:03,289
actually if you go on the ELSA page

00:05:01,639 --> 00:05:04,460
which i'll have up in a bit you could

00:05:03,289 --> 00:05:05,990
probably have it up and running by the

00:05:04,460 --> 00:05:08,660
time the talk is done but I don't want

00:05:05,990 --> 00:05:11,900
the stuff to get the link to get flooded

00:05:08,660 --> 00:05:14,090
so because it installs packages and

00:05:11,900 --> 00:05:15,560
stuff but it is an analysis framework

00:05:14,090 --> 00:05:18,560
and the big thing we were looking for

00:05:15,560 --> 00:05:20,660
Google fast searches the searches should

00:05:18,560 --> 00:05:22,430
be fast enough where you can just on a

00:05:20,660 --> 00:05:23,720
whim ask something you don't have to

00:05:22,430 --> 00:05:26,020
weigh whether it's worth it or not

00:05:23,720 --> 00:05:28,430
because I want my security analysts just

00:05:26,020 --> 00:05:30,770
guessing because sometimes you have to

00:05:28,430 --> 00:05:32,419
go hunting for bad things so that it

00:05:30,770 --> 00:05:33,919
should be coming back in a second or two

00:05:32,419 --> 00:05:38,660
if it's longer than that then it's too

00:05:33,919 --> 00:05:40,880
long and again keep the scale in mind so

00:05:38,660 --> 00:05:42,740
the first challenge we had when dealing

00:05:40,880 --> 00:05:46,490
with our input was that's going to be

00:05:42,740 --> 00:05:48,740
syslog and as I was at Toms talk earlier

00:05:46,490 --> 00:05:49,930
and he had an excellent talk on log

00:05:48,740 --> 00:05:52,910
stash and this will actually kind of

00:05:49,930 --> 00:05:55,820
play off of that a little bit especially

00:05:52,910 --> 00:05:59,360
at the end but Tom hates this log and he

00:05:55,820 --> 00:06:00,860
well should it was not my choice but

00:05:59,360 --> 00:06:02,419
that's what router spit out that's what

00:06:00,860 --> 00:06:04,099
firewall spit out and that's what server

00:06:02,419 --> 00:06:06,530
spit out so that's what we have to deal

00:06:04,099 --> 00:06:10,130
with along the way I kind of found out

00:06:06,530 --> 00:06:11,719
how we can make it useful Tom's big

00:06:10,130 --> 00:06:14,659
complaint was that you only get three

00:06:11,719 --> 00:06:17,599
fields message priority and severity and

00:06:14,659 --> 00:06:19,180
that is true but you have to kind of

00:06:17,599 --> 00:06:22,340
carve out your own fields and that's

00:06:19,180 --> 00:06:24,169
long lines what we did but you can't use

00:06:22,340 --> 00:06:26,060
reg ex to do it at the scale regular

00:06:24,169 --> 00:06:28,099
expressions will not work and that's

00:06:26,060 --> 00:06:29,810
another important line in the sand

00:06:28,099 --> 00:06:33,680
between this and pretty much all the

00:06:29,810 --> 00:06:35,960
other solutions so the first step that

00:06:33,680 --> 00:06:39,560
we found was that we needed something

00:06:35,960 --> 00:06:41,000
called syslog-ng it's it's a it's a

00:06:39,560 --> 00:06:42,320
different project than rsyslog but it's

00:06:41,000 --> 00:06:44,840
kind of the other big open source

00:06:42,320 --> 00:06:47,690
slogger they also have a premie edition

00:06:44,840 --> 00:06:49,130
which has other stuff in it and the big

00:06:47,690 --> 00:06:51,529
thing here is the pattern DB which

00:06:49,130 --> 00:06:53,630
actually does some aho Korsak style

00:06:51,529 --> 00:06:55,250
pattern matching and that gets you out

00:06:53,630 --> 00:06:57,200
of regular expression land and that made

00:06:55,250 --> 00:06:58,849
it actually fast enough to get hundred

00:06:57,200 --> 00:07:01,099
thousand messages per second completely

00:06:58,849 --> 00:07:03,950
parsed and that was the first kind of

00:07:01,099 --> 00:07:05,659
research breakthrough for us so the

00:07:03,950 --> 00:07:07,880
second part is okay great we parsed all

00:07:05,659 --> 00:07:10,460
the syslog into usable fields now how do

00:07:07,880 --> 00:07:11,900
we insert it what i have found and this

00:07:10,460 --> 00:07:14,300
is kind of controversial i would really

00:07:11,900 --> 00:07:16,700
like to hear if anybody has gotten an

00:07:14,300 --> 00:07:18,889
actual sequel insert even with multiple

00:07:16,700 --> 00:07:21,830
value statements to go more than five

00:07:18,889 --> 00:07:25,279
six seven thousand per second I was not

00:07:21,830 --> 00:07:26,719
able to do it on any platform I think

00:07:25,279 --> 00:07:28,700
you can do it in bursts but I've never

00:07:26,719 --> 00:07:31,099
seen it sustained at over five or six

00:07:28,700 --> 00:07:32,690
thousand per second so if if anybody

00:07:31,099 --> 00:07:34,940
does by all means come up afterwards and

00:07:32,690 --> 00:07:38,659
let me know how you did it if you're

00:07:34,940 --> 00:07:42,979
using SSDs that is cheating but I would

00:07:38,659 --> 00:07:44,900
still like to know if you succeeded so

00:07:42,979 --> 00:07:46,340
the big kicker then was that we needed

00:07:44,900 --> 00:07:47,719
to use low data pretty much all

00:07:46,340 --> 00:07:50,510
databases have a flavor of this

00:07:47,719 --> 00:07:51,770
reasoning MySQL little data means that

00:07:50,510 --> 00:07:53,150
you're doing it in batches but you're

00:07:51,770 --> 00:07:56,740
going to get pretty much any rate you

00:07:53,150 --> 00:07:59,180
need so this was sort of the next big

00:07:56,740 --> 00:08:01,099
delimiter here was that a demarcation

00:07:59,180 --> 00:08:02,750
we're going to be doing everything in

00:08:01,099 --> 00:08:04,789
batches from there on the architectures

00:08:02,750 --> 00:08:05,780
batch dependent and that ended up being

00:08:04,789 --> 00:08:11,270
the

00:08:05,780 --> 00:08:13,160
big difference maker so after we got the

00:08:11,270 --> 00:08:16,040
stuff into the database we needed it

00:08:13,160 --> 00:08:17,480
indexed and if you try to put indexes on

00:08:16,040 --> 00:08:19,160
the columns ahead of time and do a load

00:08:17,480 --> 00:08:21,050
data that won't work either that's too

00:08:19,160 --> 00:08:23,330
slow the load date only goes that fast

00:08:21,050 --> 00:08:25,850
if you have just a primary key maybe one

00:08:23,330 --> 00:08:27,169
other key any other keys and you're

00:08:25,850 --> 00:08:31,400
waiting around for the indexes to

00:08:27,169 --> 00:08:33,440
populate so I tried a ton of stuff I

00:08:31,400 --> 00:08:35,930
learned and threw away so many

00:08:33,440 --> 00:08:37,760
technologies in in trying this project

00:08:35,930 --> 00:08:40,159
out the first one was a special storage

00:08:37,760 --> 00:08:44,750
engine uses fractal indexes which sounds

00:08:40,159 --> 00:08:47,210
awesome and I couldn't get it to work

00:08:44,750 --> 00:08:48,710
right and it cost money so that meant

00:08:47,210 --> 00:08:51,860
there was paperwork involved which meant

00:08:48,710 --> 00:08:54,440
there was a whole other red tape parade

00:08:51,860 --> 00:08:56,270
there so we decided to look at some

00:08:54,440 --> 00:08:57,800
other stuff each base is the big one

00:08:56,270 --> 00:09:00,920
that everyone looks at first that is

00:08:57,800 --> 00:09:02,720
super slow comparatively mago DB looked

00:09:00,920 --> 00:09:04,190
awesome until I found out that you have

00:09:02,720 --> 00:09:05,839
to wait long enough for stuff to not be

00:09:04,190 --> 00:09:08,270
in RAM anymore and then it slows down

00:09:05,839 --> 00:09:11,120
significantly otherwise it was looking

00:09:08,270 --> 00:09:12,830
really promising couch TV is not fast at

00:09:11,120 --> 00:09:14,030
all does versioning all kinds of other

00:09:12,830 --> 00:09:16,520
stuff it's just not built for this

00:09:14,030 --> 00:09:18,290
Cassandra Cassandra and Tokyo cabinet

00:09:16,520 --> 00:09:19,640
were strong contenders they were a

00:09:18,290 --> 00:09:22,130
little bit weird and they were still too

00:09:19,640 --> 00:09:24,080
slow I mean weird that you had to kind

00:09:22,130 --> 00:09:25,850
of learn any new framework protocols

00:09:24,080 --> 00:09:28,480
everything and then of course we've seen

00:09:25,850 --> 00:09:31,670
it was the the big contender that's what

00:09:28,480 --> 00:09:33,890
solar is based on elasticsearch these

00:09:31,670 --> 00:09:35,690
two and those are close but there's

00:09:33,890 --> 00:09:37,220
about an order of magnitude slower than

00:09:35,690 --> 00:09:39,410
what we came up with and that is

00:09:37,220 --> 00:09:40,670
extremely significant for a lot of folks

00:09:39,410 --> 00:09:44,060
though that's good enough and so that's

00:09:40,670 --> 00:09:46,610
why they're so popular so we ended up

00:09:44,060 --> 00:09:49,040
with is finks this currently powers

00:09:46,610 --> 00:09:50,330
craigslist last i heard so we start of

00:09:49,040 --> 00:09:53,060
that knowing it's going to work for

00:09:50,330 --> 00:09:55,640
somebody and it's completely GPL which

00:09:53,060 --> 00:09:57,890
is awesome has really good support even

00:09:55,640 --> 00:10:02,480
though most of the contributors are

00:09:57,890 --> 00:10:05,320
Russian they speak excellent English and

00:10:02,480 --> 00:10:07,640
they do they've done a lot of it's very

00:10:05,320 --> 00:10:09,740
the project has a lot of activity on it

00:10:07,640 --> 00:10:11,390
and this thing will index a hundred

00:10:09,740 --> 00:10:13,010
thousand rows per second the roads that

00:10:11,390 --> 00:10:16,040
i'm talking about have a average of

00:10:13,010 --> 00:10:18,810
about 300 bytes so not tiny but not huge

00:10:16,040 --> 00:10:20,970
but i have never seen anything index

00:10:18,810 --> 00:10:25,200
100,000 per second period and this is

00:10:20,970 --> 00:10:26,400
full-text indexing this is nothing even

00:10:25,200 --> 00:10:28,529
comes close we're talking orders of

00:10:26,400 --> 00:10:30,090
magnitude here but a goat works in

00:10:28,529 --> 00:10:33,270
batches so that fits with our load data

00:10:30,090 --> 00:10:34,980
infile stuff and it uses database

00:10:33,270 --> 00:10:36,870
handles to read from it doesn't have to

00:10:34,980 --> 00:10:39,150
be Maya skill Sphinx actually read from

00:10:36,870 --> 00:10:40,529
pretty much anything including XML if

00:10:39,150 --> 00:10:42,779
you want to pipe it in but that you

00:10:40,529 --> 00:10:45,390
don't get the speed then has a very rich

00:10:42,779 --> 00:10:47,580
query syntax and it has group by in this

00:10:45,390 --> 00:10:50,730
ended up being huge I gave a talk at our

00:10:47,580 --> 00:10:52,380
local mad mongers sorry I forgot to

00:10:50,730 --> 00:10:54,750
mention that the first slide I'm local

00:10:52,380 --> 00:10:59,880
from Madison so we're we're host to you

00:10:54,750 --> 00:11:01,740
guys this time and and as far as I'm

00:10:59,880 --> 00:11:03,720
concerned JT Smith the organizer is a

00:11:01,740 --> 00:11:06,210
God among men and he's mobilized an

00:11:03,720 --> 00:11:09,510
amazing force here so I big shout out to

00:11:06,210 --> 00:11:12,390
him so I gave a talk a couple months ago

00:11:09,510 --> 00:11:15,480
on just using Sphinx as an overlay on

00:11:12,390 --> 00:11:18,060
existing apps and we found between 100

00:11:15,480 --> 00:11:19,770
and 1000 times improvement on standard

00:11:18,060 --> 00:11:22,170
databases including a group bias

00:11:19,770 --> 00:11:23,640
especially when joins are necessary so

00:11:22,170 --> 00:11:25,080
it's pretty interesting and it's really

00:11:23,640 --> 00:11:27,300
easy to just kind of start playing with

00:11:25,080 --> 00:11:29,490
so I encourage you to give things to

00:11:27,300 --> 00:11:31,950
look if nothing else the other thing is

00:11:29,490 --> 00:11:34,740
that it takes a advantage of multi

00:11:31,950 --> 00:11:37,380
threads so you can paralyze a query

00:11:34,740 --> 00:11:39,720
within the same server or transparently

00:11:37,380 --> 00:11:41,010
against other servers and that ends up

00:11:39,720 --> 00:11:44,790
being really really helpful if you have

00:11:41,010 --> 00:11:47,089
for more course it linearly progresses

00:11:44,790 --> 00:11:50,370
so this was our basic blueprint

00:11:47,089 --> 00:11:52,140
syslog-ng goes to mysql through VLO data

00:11:50,370 --> 00:11:54,420
and file sphinx slurps that out in

00:11:52,140 --> 00:11:55,860
batches and then now we just have the

00:11:54,420 --> 00:11:59,460
trivial task of putting a web front end

00:11:55,860 --> 00:12:01,020
on that so I immediately used pearl to

00:11:59,460 --> 00:12:03,959
glue everything together and that was

00:12:01,020 --> 00:12:05,280
for some people not so apparent I guess

00:12:03,959 --> 00:12:06,390
if you're starting from scratch you

00:12:05,280 --> 00:12:07,890
might look at something like thinking

00:12:06,390 --> 00:12:09,420
sphinx with ruby or some other things

00:12:07,890 --> 00:12:11,370
but when you're dealing with stuff this

00:12:09,420 --> 00:12:13,950
big pretty much no framework will fit it

00:12:11,370 --> 00:12:16,110
and that's sort of another key takeaway

00:12:13,950 --> 00:12:18,660
here is that when you get this big all

00:12:16,110 --> 00:12:21,810
the normal one size fits all stuff this

00:12:18,660 --> 00:12:25,380
is too big for that size so in the one

00:12:21,810 --> 00:12:28,230
point oh we tried PO middleware with CGI

00:12:25,380 --> 00:12:29,820
application dispatch this was just

00:12:28,230 --> 00:12:31,860
before i started with coming

00:12:29,820 --> 00:12:35,780
too mad muggers and then I learned about

00:12:31,860 --> 00:12:37,800
plaque and that changed everything so I

00:12:35,780 --> 00:12:41,070
really encourage you to use black if

00:12:37,800 --> 00:12:43,530
you're not already so in two point oh I

00:12:41,070 --> 00:12:45,630
rewrote that mess to become something

00:12:43,530 --> 00:12:49,080
much nicer and the big thing here was it

00:12:45,630 --> 00:12:52,650
took out the middle where it Greta made

00:12:49,080 --> 00:12:55,020
things much more simple so do want to

00:12:52,650 --> 00:12:56,700
emphasize why I chose pearl though for

00:12:55,020 --> 00:12:58,380
the for the i/o bound workloads there

00:12:56,700 --> 00:12:59,280
wasn't a huge difference between seeing

00:12:58,380 --> 00:13:00,840
pearl because they're all basically

00:12:59,280 --> 00:13:03,660
system calls anyway it's read/write

00:13:00,840 --> 00:13:06,570
select and pearl is designed from the

00:13:03,660 --> 00:13:11,580
ground up to be glue it's it does it's

00:13:06,570 --> 00:13:12,990
so tuned for playing with other binaries

00:13:11,580 --> 00:13:15,150
that you have to deal with like saying

00:13:12,990 --> 00:13:17,690
spike mysql all that stuff and then of

00:13:15,150 --> 00:13:19,710
course see fancy fancy band is the vast

00:13:17,690 --> 00:13:21,990
modules available made it a no-brainer

00:13:19,710 --> 00:13:23,940
to know that down the down the road

00:13:21,990 --> 00:13:26,970
whenever I'd hook anything else in I

00:13:23,940 --> 00:13:28,440
just grabbed a module off the sea pan so

00:13:26,970 --> 00:13:30,930
off the bat I just want to give a shout

00:13:28,440 --> 00:13:32,940
out to these modules a lot of you known

00:13:30,930 --> 00:13:34,920
about all of these but a couple of those

00:13:32,940 --> 00:13:37,620
are weird search query parsers a really

00:13:34,920 --> 00:13:39,360
nice module for allowing your queries to

00:13:37,620 --> 00:13:41,340
use Google syntax and then giving you

00:13:39,360 --> 00:13:44,670
something programmatic to use and then

00:13:41,340 --> 00:13:45,840
thick JSON is jt's module actually and

00:13:44,670 --> 00:13:47,790
he turned me on to that and what's nice

00:13:45,840 --> 00:13:50,520
about it versus something like animal is

00:13:47,790 --> 00:13:51,780
you can write it back out its if you

00:13:50,520 --> 00:13:54,390
have another program that will read in

00:13:51,780 --> 00:13:55,920
JSON just fine you can argue the animals

00:13:54,390 --> 00:13:58,140
just as good but I've really enjoyed

00:13:55,920 --> 00:14:00,300
using config JSON especially with the

00:13:58,140 --> 00:14:01,500
query syntax if you check out the main

00:14:00,300 --> 00:14:04,440
page you'll see what I mean it's kind of

00:14:01,500 --> 00:14:06,990
a refreshing take on a config file and

00:14:04,440 --> 00:14:08,520
of course thi and log for pearl which

00:14:06,990 --> 00:14:12,750
everyone I'm sure already uses but are

00:14:08,520 --> 00:14:13,710
amazing so as I said big data means

00:14:12,750 --> 00:14:14,970
you're not going to get any help from

00:14:13,710 --> 00:14:16,260
traditional stuff you're pretty much

00:14:14,970 --> 00:14:18,330
going it alone because everything else

00:14:16,260 --> 00:14:19,920
is too slow most people would just say

00:14:18,330 --> 00:14:21,960
well throw a thousand servers I didn't

00:14:19,920 --> 00:14:24,300
be done or I'll buy some amazon time and

00:14:21,960 --> 00:14:26,130
that was not an option for us we have a

00:14:24,300 --> 00:14:30,210
close to zero dollar budget on this so

00:14:26,130 --> 00:14:31,560
we had to invent so that's why I

00:14:30,210 --> 00:14:34,860
couldn't use something like divx class

00:14:31,560 --> 00:14:36,840
and why I couldn't use the nice sphinx

00:14:34,860 --> 00:14:38,640
search module built in because i was

00:14:36,840 --> 00:14:41,850
going to do some weird stuff with sphinx

00:14:38,640 --> 00:14:43,050
to get this to scale so what I ended up

00:14:41,850 --> 00:14:45,870
doing is

00:14:43,050 --> 00:14:48,600
combining any event with the brand-new

00:14:45,870 --> 00:14:50,310
mysqli sync file descriptor that Rob if

00:14:48,600 --> 00:14:52,050
you see him in the hallway to give him a

00:14:50,310 --> 00:14:54,180
hug or something because this is a

00:14:52,050 --> 00:14:58,560
really awesome addition it lets you

00:14:54,180 --> 00:15:01,170
attach any the any event stuff directly

00:14:58,560 --> 00:15:05,100
to the handle that Maya skills database

00:15:01,170 --> 00:15:09,089
driver uses and then you can get much

00:15:05,100 --> 00:15:10,649
more in depth with the the out of the

00:15:09,089 --> 00:15:12,329
events unfold I'll give you a code

00:15:10,649 --> 00:15:13,980
example in just a little bit but the

00:15:12,329 --> 00:15:15,540
overview is that I want to query

00:15:13,980 --> 00:15:16,920
multiple hosts and parallels that's

00:15:15,540 --> 00:15:20,160
where any event comes in right away and

00:15:16,920 --> 00:15:21,959
then under that we need to query Sphinx

00:15:20,160 --> 00:15:23,910
to get the document IDs that match our

00:15:21,959 --> 00:15:26,940
query and then you have go to mysql to

00:15:23,910 --> 00:15:28,140
get the actual document and that's the

00:15:26,940 --> 00:15:29,370
big difference between sphinx and

00:15:28,140 --> 00:15:32,130
leucine the scene just gives you the

00:15:29,370 --> 00:15:33,990
whole record back and that is handy but

00:15:32,130 --> 00:15:35,459
you get a hundred x improvement if you

00:15:33,990 --> 00:15:38,190
do it the Sphinx way the other nice

00:15:35,459 --> 00:15:40,950
thing is if it's like a covering index

00:15:38,190 --> 00:15:42,209
and your your query returns the the row

00:15:40,950 --> 00:15:43,890
that you need it anyway you don't go to

00:15:42,209 --> 00:15:45,870
mysql at all for that and that comes

00:15:43,890 --> 00:15:47,730
into play with a lot of the analytics so

00:15:45,870 --> 00:15:49,339
the basic code looks something like this

00:15:47,730 --> 00:15:53,160
and can you guys read that in the back

00:15:49,339 --> 00:15:54,510
okay good so for each node start your

00:15:53,160 --> 00:15:56,310
condition variable and this isn't

00:15:54,510 --> 00:15:58,620
exactly this obviously pseudocode here

00:15:56,310 --> 00:16:01,649
but the idea is that we have to nest

00:15:58,620 --> 00:16:03,510
this async query here so this the Sphinx

00:16:01,649 --> 00:16:06,720
variable here is the Sphinx database

00:16:03,510 --> 00:16:09,510
handle which is just a DVD mysql data

00:16:06,720 --> 00:16:11,279
handle and so is the one below it so

00:16:09,510 --> 00:16:14,490
once you've made your sphincter and get

00:16:11,279 --> 00:16:15,930
your result then that it's not really

00:16:14,490 --> 00:16:18,000
sub-process being kind of think of it

00:16:15,930 --> 00:16:20,370
like that should go and get the actual

00:16:18,000 --> 00:16:22,170
doc ids and then mark that your complete

00:16:20,370 --> 00:16:24,839
and then when everybody's done return

00:16:22,170 --> 00:16:26,430
the results and so that general pattern

00:16:24,839 --> 00:16:29,760
there is really really helpful for

00:16:26,430 --> 00:16:32,430
having to do dependent queries across n

00:16:29,760 --> 00:16:34,050
number of nodes so any query that works

00:16:32,430 --> 00:16:35,940
against one node will pretty much scale

00:16:34,050 --> 00:16:39,120
out to one or two thousand hosts because

00:16:35,940 --> 00:16:41,190
they're all just making a sequel query

00:16:39,120 --> 00:16:43,290
like that and it's really pretty easy to

00:16:41,190 --> 00:16:44,610
do some MySQL proxies so you could

00:16:43,290 --> 00:16:46,050
definitely throw those up if you ended

00:16:44,610 --> 00:16:49,589
up with more than a couple thousand host

00:16:46,050 --> 00:16:51,449
so this can really scale infinitely and

00:16:49,589 --> 00:16:52,860
the other nice thing about this is

00:16:51,449 --> 00:16:54,300
everything is very simple you're just

00:16:52,860 --> 00:16:56,100
dealing with database handles the entire

00:16:54,300 --> 00:16:57,899
time there's no replication

00:16:56,100 --> 00:17:00,089
there's nothing to worry about there's

00:16:57,899 --> 00:17:02,160
no moving parts and anytime you can just

00:17:00,089 --> 00:17:03,720
log on to a host and you know use the

00:17:02,160 --> 00:17:05,789
MySQL client like you're used to and

00:17:03,720 --> 00:17:07,890
have a look at the data you know just to

00:17:05,789 --> 00:17:10,079
get a feel for what's actually there I'm

00:17:07,890 --> 00:17:11,819
say like I said you can't query all of

00:17:10,079 --> 00:17:13,949
it we can at least do some spot checking

00:17:11,819 --> 00:17:15,449
stuff like that there's nothing that at

00:17:13,949 --> 00:17:16,799
no point can you not lift up the hood

00:17:15,449 --> 00:17:24,030
and that's very important when you're

00:17:16,799 --> 00:17:25,679
dealing with stuff this big i will give

00:17:24,030 --> 00:17:27,720
another shout out to mod module

00:17:25,679 --> 00:17:29,429
pluggable and of course moose these make

00:17:27,720 --> 00:17:31,110
writing the plugins really handy i'll

00:17:29,429 --> 00:17:33,179
show you some examples of plugins we

00:17:31,110 --> 00:17:34,740
have just a little bit but the big thing

00:17:33,179 --> 00:17:36,780
i wanted to get out of this from the

00:17:34,740 --> 00:17:39,210
open sourcing was to get some plugins

00:17:36,780 --> 00:17:41,490
back and that's been really great so far

00:17:39,210 --> 00:17:44,070
we've gotten not just parsers but ideas

00:17:41,490 --> 00:17:45,570
for plugins and in some code from the

00:17:44,070 --> 00:17:47,159
community and so I encourage you if

00:17:45,570 --> 00:17:50,669
you're interested at all join the

00:17:47,159 --> 00:17:51,630
mailing list and and hop on so I don't

00:17:50,669 --> 00:17:53,039
expect you to be able to read that I

00:17:51,630 --> 00:17:55,289
just want you to get sort of a feel for

00:17:53,039 --> 00:17:56,970
what it looks like so there's a query

00:17:55,289 --> 00:17:58,650
bar at the top it's just the basic form

00:17:56,970 --> 00:18:01,320
field you can think of that as your

00:17:58,650 --> 00:18:03,900
google query there and then there's a

00:18:01,320 --> 00:18:05,789
date and time for the start and end if

00:18:03,900 --> 00:18:07,289
you're interested in that and then there

00:18:05,789 --> 00:18:09,539
are some buttons to specify what fields

00:18:07,289 --> 00:18:10,740
you're looking for but the idea is that

00:18:09,539 --> 00:18:12,390
you should just be able to type in

00:18:10,740 --> 00:18:17,000
anything and get some results back

00:18:12,390 --> 00:18:19,980
quickly the things here at the top are

00:18:17,000 --> 00:18:21,030
those our field drill downs so if you

00:18:19,980 --> 00:18:23,159
click any one of those it will do

00:18:21,030 --> 00:18:25,620
analytics on just that field and all

00:18:23,159 --> 00:18:30,929
this completes in can't really read that

00:18:25,620 --> 00:18:36,980
but fourteen hundred milliseconds and

00:18:30,929 --> 00:18:40,620
that was over 12 billion records I think

00:18:36,980 --> 00:18:43,320
and then so if you do a drill down it

00:18:40,620 --> 00:18:45,030
looks something like this this was I

00:18:43,320 --> 00:18:46,470
want to redo the graphs at some point

00:18:45,030 --> 00:18:47,640
this is an open flash chart which I

00:18:46,470 --> 00:18:49,500
really like because it lets you do

00:18:47,640 --> 00:18:51,900
interactive stuff but it's not very

00:18:49,500 --> 00:18:53,940
pretty so someday I'll come back to the

00:18:51,900 --> 00:18:55,470
graphs but the idea is you just click on

00:18:53,940 --> 00:18:57,360
what you see and then in a second or two

00:18:55,470 --> 00:19:01,799
you have complete drill down over the

00:18:57,360 --> 00:19:03,960
entire data set so the plugins we have

00:19:01,799 --> 00:19:06,870
right now for authentication which is a

00:19:03,960 --> 00:19:09,059
big deal on this because we have a multi

00:19:06,870 --> 00:19:09,970
tendency model when you're doing that

00:19:09,059 --> 00:19:12,130
query not only

00:19:09,970 --> 00:19:13,450
you query the the data but the

00:19:12,130 --> 00:19:15,310
authentication is going to throw extra

00:19:13,450 --> 00:19:18,100
filters on there to make sure that the

00:19:15,310 --> 00:19:20,530
users authorized to get that data so we

00:19:18,100 --> 00:19:23,980
have authentication authorization for

00:19:20,530 --> 00:19:25,780
ldap local via Pam there's also a way to

00:19:23,980 --> 00:19:28,270
just hook you in any database there so

00:19:25,780 --> 00:19:32,350
you can specify the query in the the DSN

00:19:28,270 --> 00:19:34,090
and then for export CSV HTML PDF XLS and

00:19:32,350 --> 00:19:36,250
then i just added KML a little bit ago

00:19:34,090 --> 00:19:37,870
which is kind of fun for the suits so

00:19:36,250 --> 00:19:39,130
you can click there and then export that

00:19:37,870 --> 00:19:43,810
to Google Earth and then it looks like

00:19:39,130 --> 00:19:45,850
we've done a lot of work because if you

00:19:43,810 --> 00:19:48,940
show them text then it doesn't look like

00:19:45,850 --> 00:19:51,100
we've done a lot of work apparently so

00:19:48,940 --> 00:19:53,950
the transforms are another big part of

00:19:51,100 --> 00:19:55,150
this and this was I guess you could say

00:19:53,950 --> 00:19:59,200
originally just come from the UNIX world

00:19:55,150 --> 00:20:02,170
but I did see it in Splunk the sub

00:19:59,200 --> 00:20:04,900
searches are pipes to either transform

00:20:02,170 --> 00:20:07,810
or a sub search so at the bottom hearing

00:20:04,900 --> 00:20:10,630
to transform example one and give it our

00:20:07,810 --> 00:20:12,670
guard or you can do know args and those

00:20:10,630 --> 00:20:14,470
do a number of things that can be first

00:20:12,670 --> 00:20:16,660
of all a sequel query against any other

00:20:14,470 --> 00:20:18,100
database just like the auth it can take

00:20:16,660 --> 00:20:19,750
the fields in there and then farm that

00:20:18,100 --> 00:20:21,220
out to something like your cmdb or

00:20:19,750 --> 00:20:23,170
anywhere else you just give it the query

00:20:21,220 --> 00:20:24,970
in the DSN in which field it should use

00:20:23,170 --> 00:20:28,840
in what parameter and they'll figure it

00:20:24,970 --> 00:20:31,660
out and who is geoip passive DNS this is

00:20:28,840 --> 00:20:33,550
more security stuff but they be very

00:20:31,660 --> 00:20:36,310
helpful and then sub searches will cover

00:20:33,550 --> 00:20:38,020
here so you can chain them together and

00:20:36,310 --> 00:20:40,930
this is where you get into the real

00:20:38,020 --> 00:20:42,700
analytics so let's say that there's an

00:20:40,930 --> 00:20:45,070
IDs alert for something just called

00:20:42,700 --> 00:20:46,960
sequel injection and i want to say okay

00:20:45,070 --> 00:20:48,460
find me all the unique source IPS and

00:20:46,960 --> 00:20:51,190
then for each one of those source IPS

00:20:48,460 --> 00:20:52,390
find where they had a status code of 500

00:20:51,190 --> 00:20:54,250
so we're going to try to find a sequel

00:20:52,390 --> 00:20:56,650
injection so the first query is the

00:20:54,250 --> 00:20:58,420
simple find the key word for sequel

00:20:56,650 --> 00:21:00,760
injection and then pull out the field

00:20:58,420 --> 00:21:03,130
for source IP and do analytics on that

00:21:00,760 --> 00:21:06,280
then for each unique one pass that in as

00:21:03,130 --> 00:21:08,410
an or term for the second query and it

00:21:06,280 --> 00:21:13,210
will recursively do a query have I lost

00:21:08,410 --> 00:21:17,470
anyone with that ok so at the bottom

00:21:13,210 --> 00:21:19,470
here when we put this way so this this

00:21:17,470 --> 00:21:21,720
is one query and then

00:21:19,470 --> 00:21:27,750
results of this query end up looking

00:21:21,720 --> 00:21:29,580
like this so in the back up to this so

00:21:27,750 --> 00:21:31,559
on the left there you have the table and

00:21:29,580 --> 00:21:33,059
it's like each one of those when you do

00:21:31,559 --> 00:21:34,679
a group by you get sort of a vertical

00:21:33,059 --> 00:21:36,720
listing and if you want to think about

00:21:34,679 --> 00:21:38,610
taking that vertical listing you get

00:21:36,720 --> 00:21:41,039
from the first query and sort of making

00:21:38,610 --> 00:21:42,630
it horizontal as a query for the second

00:21:41,039 --> 00:21:44,760
query I don't know if that makes more

00:21:42,630 --> 00:21:47,610
sense but the idea is that you're going

00:21:44,760 --> 00:21:49,110
to find where something is in both so

00:21:47,610 --> 00:21:52,830
for all the stuff that matched the first

00:21:49,110 --> 00:21:56,179
query run those as being included in the

00:21:52,830 --> 00:21:58,940
second one I guess like a union or

00:21:56,179 --> 00:22:00,809
subselect would be the sequel equivalent

00:21:58,940 --> 00:22:02,580
I'll be happy to explain it more

00:22:00,809 --> 00:22:03,809
afterwards but I got to kind of keep

00:22:02,580 --> 00:22:05,370
moving as hoping that'd be a little more

00:22:03,809 --> 00:22:08,549
clear but maybe we'll come back to that

00:22:05,370 --> 00:22:09,750
for questions so then there's also

00:22:08,549 --> 00:22:12,690
connectors and these are more like

00:22:09,750 --> 00:22:15,120
endpoints so you can submit data to

00:22:12,690 --> 00:22:18,450
other systems they go on is email for

00:22:15,120 --> 00:22:19,890
alerts that's just a given so if if you

00:22:18,450 --> 00:22:21,750
have a query that's helpful you just

00:22:19,890 --> 00:22:24,620
click alert and then it will email you

00:22:21,750 --> 00:22:27,090
whenever that query matches any new data

00:22:24,620 --> 00:22:30,120
now we also have some other security

00:22:27,090 --> 00:22:33,659
stuff like uploading stuff to sand boxes

00:22:30,120 --> 00:22:35,700
so that would be taking data that's in a

00:22:33,659 --> 00:22:37,710
log and then uploading it to a generic

00:22:35,700 --> 00:22:39,600
web service elsewhere you want to think

00:22:37,710 --> 00:22:41,640
about it that way I have another project

00:22:39,600 --> 00:22:43,679
for network traffic collection and we

00:22:41,640 --> 00:22:45,630
have integration with that to save take

00:22:43,679 --> 00:22:47,520
all the IP fields out of this vlog and

00:22:45,630 --> 00:22:50,010
then go grab the actual traffic for

00:22:47,520 --> 00:22:52,980
those and that happens in like less than

00:22:50,010 --> 00:22:54,960
a second blacklist submission so these

00:22:52,980 --> 00:22:58,470
IPS were naughty two clicks and now

00:22:54,960 --> 00:23:01,919
they're on the blacklist and then it can

00:22:58,470 --> 00:23:04,559
also be any of these connectors can be

00:23:01,919 --> 00:23:06,330
the trigger event for a scheduled search

00:23:04,559 --> 00:23:08,730
or alert so you could say instead of

00:23:06,330 --> 00:23:10,650
emailing me every minute i want this

00:23:08,730 --> 00:23:11,789
query to be sent to a blacklist or

00:23:10,650 --> 00:23:14,250
something like that or you could say

00:23:11,789 --> 00:23:17,520
i'll send that to a trouble ticket queue

00:23:14,250 --> 00:23:19,200
or whatever okay so let's talk about

00:23:17,520 --> 00:23:22,620
MapReduce a little bit who's actually

00:23:19,200 --> 00:23:24,090
done any MapReduce all right awesome so

00:23:22,620 --> 00:23:26,700
we have number of people that's good

00:23:24,090 --> 00:23:30,030
because I'm at the hope as much with the

00:23:26,700 --> 00:23:31,680
sub search stuff so in in my mind and

00:23:30,030 --> 00:23:33,390
this is open to debate this is not

00:23:31,680 --> 00:23:35,130
academic answer here but to me a

00:23:33,390 --> 00:23:38,130
practical answer for what MapReduce is

00:23:35,130 --> 00:23:40,530
this map is query as in find this stuff

00:23:38,130 --> 00:23:43,440
and then reduce is ok let's aggregator

00:23:40,530 --> 00:23:44,550
to run some analytics on it and I'm sure

00:23:43,440 --> 00:23:47,340
that is not the correct scientific

00:23:44,550 --> 00:23:50,070
answer but that is how we have used it

00:23:47,340 --> 00:23:52,950
thus far in our case specifically that

00:23:50,070 --> 00:23:55,440
means run a plug-in or several

00:23:52,950 --> 00:23:57,210
transforms on it and then maybe even

00:23:55,440 --> 00:23:59,700
have to do some recursive query on each

00:23:57,210 --> 00:24:01,050
one of those pieces of data so that's

00:23:59,700 --> 00:24:03,990
the closest that we get to actually

00:24:01,050 --> 00:24:07,110
iterating over the whole set but it's

00:24:03,990 --> 00:24:09,030
more like take your query that goes over

00:24:07,110 --> 00:24:10,980
the entire set and then of that small

00:24:09,030 --> 00:24:12,660
handful of things you're getting back or

00:24:10,980 --> 00:24:13,800
sometimes it's not that small but we

00:24:12,660 --> 00:24:15,210
call it a couple hundred thousand

00:24:13,800 --> 00:24:17,490
something like that for each one of

00:24:15,210 --> 00:24:20,970
those things perform this extra query so

00:24:17,490 --> 00:24:23,700
maybe an example would be find any 500

00:24:20,970 --> 00:24:25,410
errors and then go query the changelog

00:24:23,700 --> 00:24:30,060
system to see who made a change on that

00:24:25,410 --> 00:24:31,440
server something like that and just give

00:24:30,060 --> 00:24:33,990
you an idea of what the code would look

00:24:31,440 --> 00:24:35,340
like so you make your first query and

00:24:33,990 --> 00:24:39,480
then for each record return by that

00:24:35,340 --> 00:24:41,430
query do some plug-in so either find any

00:24:39,480 --> 00:24:43,590
failed logins give the page rank for

00:24:41,430 --> 00:24:45,740
that site count post for that forum

00:24:43,590 --> 00:24:47,970
whatever the point is you have

00:24:45,740 --> 00:24:50,010
efficiently found a subset of the

00:24:47,970 --> 00:24:51,240
original giant amount of records and now

00:24:50,010 --> 00:24:54,960
you're going to take an action on each

00:24:51,240 --> 00:24:57,380
one of those things all right so I was

00:24:54,960 --> 00:25:00,720
kind of antagonistic in my description

00:24:57,380 --> 00:25:03,180
big read quite a bit about Hadoop and

00:25:00,720 --> 00:25:04,530
played with it played with it enough to

00:25:03,180 --> 00:25:06,960
kind of understand the differences

00:25:04,530 --> 00:25:09,180
though I suspect it will be a bit

00:25:06,960 --> 00:25:10,920
controversial but I can definitely tell

00:25:09,180 --> 00:25:13,980
you the HBase is a lot slower for both

00:25:10,920 --> 00:25:15,270
the indexing acquiring to me HDFS is

00:25:13,980 --> 00:25:17,010
complicated for setting up the

00:25:15,270 --> 00:25:18,120
distributed file system it's come a long

00:25:17,010 --> 00:25:20,070
way in the last year I will definitely

00:25:18,120 --> 00:25:21,840
say that when i first started else it

00:25:20,070 --> 00:25:24,450
was much harder to get the Hadoop stuff

00:25:21,840 --> 00:25:28,200
running but i still hate java with a

00:25:24,450 --> 00:25:30,750
passion for just basic ops so that's

00:25:28,200 --> 00:25:32,790
kind of kind of why I shied away from it

00:25:30,750 --> 00:25:34,950
and but it is really is a monolithic

00:25:32,790 --> 00:25:36,930
monolithic framework I don't think they

00:25:34,950 --> 00:25:38,820
will argue with that part of it you kind

00:25:36,930 --> 00:25:40,650
of to do it their way and what I have

00:25:38,820 --> 00:25:42,120
found for most of the forum posts is if

00:25:40,650 --> 00:25:43,740
you run into problems throw more servers

00:25:42,120 --> 00:25:46,559
at it seems to be the attitude

00:25:43,740 --> 00:25:50,340
and we really don't have that that

00:25:46,559 --> 00:25:53,100
luxury so we expect about 100x

00:25:50,340 --> 00:25:54,990
performance penalty from poop this is

00:25:53,100 --> 00:25:58,170
this is extremely controversial and I

00:25:54,990 --> 00:26:00,809
take this from there was a post on the

00:25:58,170 --> 00:26:04,200
right network they run the registration

00:26:00,809 --> 00:26:06,690
for Europe and they took 100 Gig packet

00:26:04,200 --> 00:26:08,730
capture file and used Hadoop to analyze

00:26:06,690 --> 00:26:10,170
it all and when they came back with

00:26:08,730 --> 00:26:12,360
their stats I thought well we do

00:26:10,170 --> 00:26:14,580
analysis like that all the time on one

00:26:12,360 --> 00:26:17,910
server and it takes 100 of the amount of

00:26:14,580 --> 00:26:19,020
time and it was really silly so I don't

00:26:17,910 --> 00:26:20,760
know if they weren't as efficient as

00:26:19,020 --> 00:26:22,530
they could have been or our stuff is

00:26:20,760 --> 00:26:24,780
more efficient or what but that's where

00:26:22,530 --> 00:26:26,370
I'm coming from on that so you could

00:26:24,780 --> 00:26:28,410
take a guess 100x with the grain of salt

00:26:26,370 --> 00:26:30,210
but I've definitely seen that case and

00:26:28,410 --> 00:26:33,210
know firsthand it should not have taken

00:26:30,210 --> 00:26:35,429
nearly as long as they said it took on a

00:26:33,210 --> 00:26:41,220
thousand servers I think they used for a

00:26:35,429 --> 00:26:42,750
hundred gig things so at ya so for our

00:26:41,220 --> 00:26:45,120
stats to give you an idea where we're

00:26:42,750 --> 00:26:46,860
coming from so everything is full text

00:26:45,120 --> 00:26:48,179
index plus a bunch of attributes on top

00:26:46,860 --> 00:26:50,580
of that which we r we get our analytics

00:26:48,179 --> 00:26:52,860
and we have billions on each know that

00:26:50,580 --> 00:26:54,570
really varies on our our load but each

00:26:52,860 --> 00:26:57,660
node has between 10 and 20 billion

00:26:54,570 --> 00:26:59,580
records now per day we have more than a

00:26:57,660 --> 00:27:01,260
billion logs that need to be completely

00:26:59,580 --> 00:27:03,570
parsed and full-text index that come

00:27:01,260 --> 00:27:04,980
through each day and we have at the same

00:27:03,570 --> 00:27:06,900
time dozens of customers with their own

00:27:04,980 --> 00:27:08,700
custom queries so we can't really

00:27:06,900 --> 00:27:10,559
predict how many queries are going to be

00:27:08,700 --> 00:27:12,600
run against that data as it comes in and

00:27:10,559 --> 00:27:15,030
most queries finish in about 100

00:27:12,600 --> 00:27:17,070
milliseconds if the initial table data

00:27:15,030 --> 00:27:20,040
is cached which after your second query

00:27:17,070 --> 00:27:21,690
it is and I do want to emphasize that

00:27:20,040 --> 00:27:23,670
all new logs as they come in in their

00:27:21,690 --> 00:27:25,800
batch they have every available alert

00:27:23,670 --> 00:27:27,630
and everything else run against them so

00:27:25,800 --> 00:27:32,820
you have to actually iterate through

00:27:27,630 --> 00:27:35,070
every record now I do have a couple of

00:27:32,820 --> 00:27:37,410
new features that i'll probably be

00:27:35,070 --> 00:27:39,690
committing next week I might do a little

00:27:37,410 --> 00:27:41,340
demo here if we have time this is

00:27:39,690 --> 00:27:44,250
probably more interesting to a lot of

00:27:41,340 --> 00:27:46,800
you to get away from the batches I think

00:27:44,250 --> 00:27:49,290
I have it now where we can do real-time

00:27:46,800 --> 00:27:51,150
indexing so no more waiting around for

00:27:49,290 --> 00:27:54,179
the batch we do one minute batches which

00:27:51,150 --> 00:27:55,770
has been good enough thus far but for

00:27:54,179 --> 00:27:57,180
lower volumes that gets pretty annoying

00:27:55,770 --> 00:27:59,100
so if you only have a few records

00:27:57,180 --> 00:28:01,500
tickling in every minute or two that's

00:27:59,100 --> 00:28:04,590
pretty handy and it also opens the door

00:28:01,500 --> 00:28:06,720
to different kinds of input so if i get

00:28:04,590 --> 00:28:07,980
to the demo here looks like we're doing

00:28:06,720 --> 00:28:09,330
pretty good on time actually so yeah

00:28:07,980 --> 00:28:10,980
well we get to the second and it's going

00:28:09,330 --> 00:28:13,560
to take Tom's message passing framework

00:28:10,980 --> 00:28:15,930
from his talk and I think I got that

00:28:13,560 --> 00:28:23,370
work in this afternoon so we can show

00:28:15,930 --> 00:28:29,640
how to get basic hashes inserted so that

00:28:23,370 --> 00:28:32,010
those are the two links and any

00:28:29,640 --> 00:28:43,770
questions before we try the ill-advised

00:28:32,010 --> 00:28:47,970
live demo ok so for ops what we have on

00:28:43,770 --> 00:28:50,400
the front is a load with it oh sorry yes

00:28:47,970 --> 00:28:53,550
so your question was and how many

00:28:50,400 --> 00:28:56,030
servers do we have in redundancy Sarah I

00:28:53,550 --> 00:28:56,030
guess I right

00:29:06,050 --> 00:29:09,930
if the cert right now if the server is

00:29:08,370 --> 00:29:12,990
down it does not intelligently failover

00:29:09,930 --> 00:29:14,550
I that'll be really easy to put in

00:29:12,990 --> 00:29:16,530
because it'll just say I just have to

00:29:14,550 --> 00:29:18,450
add a call back to the MySQL connect and

00:29:16,530 --> 00:29:21,600
then it'll say flip over to the

00:29:18,450 --> 00:29:22,770
alternate server so that's coming the

00:29:21,600 --> 00:29:25,860
servers are pretty much never down

00:29:22,770 --> 00:29:29,520
because we only have two I mentioned

00:29:25,860 --> 00:29:30,780
that all this is on two servers so at

00:29:29,520 --> 00:29:32,340
the moment that has a meneses area what

00:29:30,780 --> 00:29:33,690
we do for fault tolerance though which

00:29:32,340 --> 00:29:35,550
is kind of the immediate question

00:29:33,690 --> 00:29:38,250
because we have had servers die and what

00:29:35,550 --> 00:29:40,680
we do is all the logs come into a

00:29:38,250 --> 00:29:42,720
virtual IP address that load balances

00:29:40,680 --> 00:29:44,670
round-robin on two servers and then

00:29:42,720 --> 00:29:47,460
those two servers before it goes into

00:29:44,670 --> 00:29:49,830
any indexing syslog kind of waterfall it

00:29:47,460 --> 00:29:51,660
down to two dev servers so we just copy

00:29:49,830 --> 00:29:53,490
the data and that's kind of a theme I've

00:29:51,660 --> 00:29:56,490
heard repeated today for for the big

00:29:53,490 --> 00:29:59,040
data talks is instead of trying to get

00:29:56,490 --> 00:30:01,860
replication on the backside to work to

00:29:59,040 --> 00:30:03,870
just copy the data to two places because

00:30:01,860 --> 00:30:06,480
the which you'll find if when you get to

00:30:03,870 --> 00:30:08,280
data this size is that there is no such

00:30:06,480 --> 00:30:09,840
thing as disaster recovery because the

00:30:08,280 --> 00:30:11,640
amount of time it takes to restore is

00:30:09,840 --> 00:30:13,590
longer than the amount of time that it

00:30:11,640 --> 00:30:15,570
takes to get new logs for the same same

00:30:13,590 --> 00:30:18,210
time period so what we do then is

00:30:15,570 --> 00:30:19,830
promote a dev server into production but

00:30:18,210 --> 00:30:21,350
right now there's no auto failover but

00:30:19,830 --> 00:30:23,550
that's a pretty simple feature to add

00:30:21,350 --> 00:30:25,650
it's on the drawing board but I haven't

00:30:23,550 --> 00:30:29,730
got to that yet have a good question

00:30:25,650 --> 00:30:33,540
yeah oh sorry well you don't a blank

00:30:29,730 --> 00:30:38,450
question thing ok there's links for your

00:30:33,540 --> 00:30:38,450
viewing pleasure i thing else for do the

00:30:39,080 --> 00:30:44,130
when we started on it and we've really

00:30:42,180 --> 00:30:45,360
seen very little difference between the

00:30:44,130 --> 00:30:48,840
what we started with and what we have

00:30:45,360 --> 00:30:51,900
now we initially had to service of four

00:30:48,840 --> 00:30:55,680
total cores than logical than a hyper

00:30:51,900 --> 00:30:57,060
threaded and four gig of ram and that

00:30:55,680 --> 00:30:58,920
handled the same workload as the

00:30:57,060 --> 00:31:02,790
server's we have now which are pretty

00:30:58,920 --> 00:31:05,640
beefy dell boxes there so they have 10

00:31:02,790 --> 00:31:08,130
terabytes usable on them and 140

00:31:05,640 --> 00:31:10,290
something gigs of ram but the key thing

00:31:08,130 --> 00:31:12,870
with Sphinx is that it does not really

00:31:10,290 --> 00:31:15,780
use ram the way we have it set up we

00:31:12,870 --> 00:31:17,280
kind of I did a bunch of gymnastics on

00:31:15,780 --> 00:31:20,160
the back end to make

00:31:17,280 --> 00:31:21,960
that we could scale the indexes without

00:31:20,160 --> 00:31:24,720
having to consume ram for each new

00:31:21,960 --> 00:31:27,060
record so there is there's that sort of

00:31:24,720 --> 00:31:28,290
pseudo memory leak going on now that

00:31:27,060 --> 00:31:30,360
there are a couple of caveats and

00:31:28,290 --> 00:31:32,340
introduces and so we sort of work around

00:31:30,360 --> 00:31:35,010
that by having a temporary and a

00:31:32,340 --> 00:31:36,930
permanent index schema so when logs

00:31:35,010 --> 00:31:38,970
first come in there are no caveats and

00:31:36,930 --> 00:31:40,530
then in our set up that gives you about

00:31:38,970 --> 00:31:42,210
a half hour for where you can run any

00:31:40,530 --> 00:31:44,160
kind of query on those and what I mean

00:31:42,210 --> 00:31:46,680
by that is attribute only queries the

00:31:44,160 --> 00:31:48,000
stuff that's not eating a keyword stuff

00:31:46,680 --> 00:31:50,430
that you would normally only filter on

00:31:48,000 --> 00:31:52,800
and normally instincts that's if you

00:31:50,430 --> 00:31:54,150
have not that many records and just a

00:31:52,800 --> 00:31:56,400
little bit of RAM then that's the way

00:31:54,150 --> 00:31:57,870
all of them are in our case we want to

00:31:56,400 --> 00:32:00,120
make sure that we could grow without

00:31:57,870 --> 00:32:02,670
having to be constrained by Ram and so

00:32:00,120 --> 00:32:04,800
you have to give up the no keyword

00:32:02,670 --> 00:32:06,240
queries for that but that means we can

00:32:04,800 --> 00:32:09,210
say that you can run the whole thing on

00:32:06,240 --> 00:32:12,030
like 500 mega if you need to each record

00:32:09,210 --> 00:32:14,780
does not add to ram so that's not a disk

00:32:12,030 --> 00:32:18,330
space is your only limiting factor a

00:32:14,780 --> 00:32:22,910
good question though anybody else where

00:32:18,330 --> 00:32:22,910
we find out if this works yeah

00:32:26,970 --> 00:32:38,960
I know it's just writing the MySQL right

00:32:39,289 --> 00:32:45,900
if you need it I mean it the files are

00:32:43,799 --> 00:32:47,460
large enough that they don't really ever

00:32:45,900 --> 00:32:49,590
fit in that like when we started on the

00:32:47,460 --> 00:32:51,450
four gig stuff the files themselves are

00:32:49,590 --> 00:32:54,840
well over four gigs so I mean it's all

00:32:51,450 --> 00:32:56,909
disk disk bound I oh yeah i mean the

00:32:54,840 --> 00:32:59,909
buffers can't help that's why if you run

00:32:56,909 --> 00:33:01,710
a similar query right after the they'll

00:32:59,909 --> 00:33:03,900
come back in like 70 milliseconds

00:33:01,710 --> 00:33:05,340
because you're hitting cash on all kinds

00:33:03,900 --> 00:33:07,860
of stuff but most queries finished about

00:33:05,340 --> 00:33:09,179
a second so you're kind of lucky when

00:33:07,860 --> 00:33:18,870
you get cash but we certainly do not

00:33:09,179 --> 00:33:24,919
depend on cash okay oh yeah let's see we

00:33:18,870 --> 00:33:28,289
do 200 megabytes per minute per node

00:33:24,919 --> 00:33:32,669
it's about um about a million logs a

00:33:28,289 --> 00:33:39,720
minute about a billing day so 400

00:33:32,669 --> 00:33:41,370
megabytes x 8 sets 320 megabits so but

00:33:39,720 --> 00:33:44,520
the files that we load in for a minute

00:33:41,370 --> 00:33:46,049
are about 200 Meg on each server and we

00:33:44,520 --> 00:33:48,840
expect that to grow significantly work

00:33:46,049 --> 00:33:51,030
that's about oh the basic rates about

00:33:48,840 --> 00:33:52,860
15,000 messages per second it's probably

00:33:51,030 --> 00:33:55,230
much more helpful stat and then we

00:33:52,860 --> 00:33:57,299
expect that to grow I think our high

00:33:55,230 --> 00:33:58,590
water mark is going to be or not the

00:33:57,299 --> 00:34:01,289
high-water mark but the limits probably

00:33:58,590 --> 00:34:02,940
about somewhere between 25 and 30

00:34:01,289 --> 00:34:07,530
thousand messages per second per node

00:34:02,940 --> 00:34:10,109
that's where this the consolidating part

00:34:07,530 --> 00:34:12,270
of the indexes that's about the high

00:34:10,109 --> 00:34:14,220
sustained rate but the initial batches

00:34:12,270 --> 00:34:16,859
go at about a hundred thousand and

00:34:14,220 --> 00:34:18,629
really if you threw a little bit more at

00:34:16,859 --> 00:34:20,639
that or if you were willing to say we're

00:34:18,629 --> 00:34:21,869
going to use some ram as opposed to know

00:34:20,639 --> 00:34:25,879
Ram then you could definitely do a

00:34:21,869 --> 00:34:25,879
hundred thousand per second all the time

00:34:26,599 --> 00:34:29,599
okay

00:34:31,409 --> 00:34:34,409
alright

00:34:35,760 --> 00:34:43,760
yeah slides will be posted all right

00:34:47,630 --> 00:34:56,300
okay read their come on all right let's

00:34:56,870 --> 00:35:01,310
increase the font size dramatic win here

00:35:25,000 --> 00:35:28,530
not everything except this

00:35:34,280 --> 00:35:51,120
that is the particle collector in

00:35:40,140 --> 00:35:53,670
Switzerland yeah All Right see if this

00:35:51,120 --> 00:35:59,360
is big enough people even think I us all

00:35:53,670 --> 00:35:59,360
right a little better more one higher

00:36:01,670 --> 00:36:06,710
it's actually went faster and thoughts

00:36:03,600 --> 00:36:06,710
we had just a wee bit of time here

00:36:36,970 --> 00:36:40,320
all right we'll try 30

00:36:45,730 --> 00:36:53,760
okay how's that okay good enough all

00:36:50,260 --> 00:36:53,760
right so give you an idea

00:37:07,240 --> 00:37:10,420
and I don't know if you guys had

00:37:08,770 --> 00:37:13,570
problems with wireless disconnecting on

00:37:10,420 --> 00:37:15,940
you quite a bit today it seems like

00:37:13,570 --> 00:37:18,220
there's a rogue AP out there because the

00:37:15,940 --> 00:37:21,369
mac address does not match a cisco MAC

00:37:18,220 --> 00:37:23,800
address so if anyone's d8 something

00:37:21,369 --> 00:37:31,080
something something please stop doing

00:37:23,800 --> 00:37:31,080
that all right let's uh

00:37:53,610 --> 00:37:56,980
then come up in 10 sec I'll just show

00:37:55,780 --> 00:37:59,080
you the code for the message passing

00:37:56,980 --> 00:38:01,480
stuff because the screen shots before

00:37:59,080 --> 00:38:02,980
pretty much explain what's going on but

00:38:01,480 --> 00:38:05,470
the main idea is that you can take

00:38:02,980 --> 00:38:07,180
instead of syslog any basic hash from

00:38:05,470 --> 00:38:09,160
the whole message passing framework from

00:38:07,180 --> 00:38:10,840
Tom and then instead of the

00:38:09,160 --> 00:38:12,250
elasticsearch back end that he has in

00:38:10,840 --> 00:38:16,870
all of his slides he would just replace

00:38:12,250 --> 00:38:22,230
that with the ELSA back end so let's

00:38:16,870 --> 00:38:22,230
look at that cuz this is not connecting

00:38:31,450 --> 00:38:35,250
alright like

00:38:39,500 --> 00:38:50,350
anybody read that at all now yeah

00:39:16,310 --> 00:39:18,850
and

00:39:51,369 --> 00:39:54,029
me

00:40:03,630 --> 00:40:07,190
area is look there

00:40:08,660 --> 00:40:17,210
can take me three hours put it back but

00:40:10,549 --> 00:40:21,549
all right okay keep everyone on edge all

00:40:17,210 --> 00:40:24,470
right so this was just trying to take

00:40:21,549 --> 00:40:28,280
Wireshark here which is a packet capture

00:40:24,470 --> 00:40:29,960
tool and take any connection grab a few

00:40:28,280 --> 00:40:34,359
fields out of that and then encoded as a

00:40:29,960 --> 00:40:34,359
hash that's that's what the script does

00:40:42,970 --> 00:40:46,890
and try to the

00:40:51,369 --> 00:41:01,319
so now sending packets to localhost oh

00:41:01,559 --> 00:41:05,069
all right let's connected

00:41:08,700 --> 00:41:12,920
hey wireless connected again all right

00:41:46,710 --> 00:41:57,200
there we go okay so that's what gets

00:41:48,599 --> 00:41:57,200
generated so now if I actually put it in

00:42:01,520 --> 00:42:06,720
all right so can you read that at the

00:42:04,260 --> 00:42:08,369
bottom as a big enough now so if you

00:42:06,720 --> 00:42:09,540
look at Tom slides from his talk earlier

00:42:08,369 --> 00:42:11,760
today it's basically the same deal

00:42:09,540 --> 00:42:14,339
except I swapped out standard out with

00:42:11,760 --> 00:42:16,830
Elsa here and on one of those links on

00:42:14,339 --> 00:42:18,869
my slides is the github to grab this

00:42:16,830 --> 00:42:20,910
from and what it's going to do is say

00:42:18,869 --> 00:42:25,670
okay tell me where your else's stuff is

00:42:20,910 --> 00:42:25,670
and then I will send it to Elsa so now

00:42:26,150 --> 00:42:30,660
you shouldn't see anything now because

00:42:28,170 --> 00:42:34,500
now it's being piped to from standard in

00:42:30,660 --> 00:42:36,930
into message passing and few of these

00:42:34,500 --> 00:42:38,760
like some of the UDP protocol I'm not

00:42:36,930 --> 00:42:40,530
parsing out so you get uninitialized

00:42:38,760 --> 00:42:43,640
stuff I didn't this is just the demo so

00:42:40,530 --> 00:42:50,849
you bother with in it and then

00:42:43,640 --> 00:42:54,450
theoretically oh yeah so now ok let's

00:42:50,849 --> 00:42:58,380
stir up the front end so now we're going

00:42:54,450 --> 00:43:01,609
to start the the plaque web front-end so

00:42:58,380 --> 00:43:01,609
just listen on port 5000

00:43:05,999 --> 00:43:15,269
all right now in theory there we go yeah

00:43:10,919 --> 00:43:21,149
a data that alright so that was grouping

00:43:15,269 --> 00:43:23,099
by something dest IP but in general if

00:43:21,149 --> 00:43:24,959
you just ask for a class this is what I

00:43:23,099 --> 00:43:27,479
was talking about filter only queries so

00:43:24,959 --> 00:43:29,369
I said give me a firewall connection in

00:43:27,479 --> 00:43:32,639
class which would be your basic network

00:43:29,369 --> 00:43:34,379
connection class of logs and in the

00:43:32,639 --> 00:43:36,149
temporary indexes you can do that where

00:43:34,379 --> 00:43:40,169
you just say I want to attribute but in

00:43:36,149 --> 00:43:41,579
the full scheme of data to the trade-off

00:43:40,169 --> 00:43:43,289
for not using any ram is that you have

00:43:41,579 --> 00:43:47,039
to specify a keyword like an IP address

00:43:43,289 --> 00:43:48,449
or something in any case the we have the

00:43:47,039 --> 00:43:50,579
list of fields up here that you can

00:43:48,449 --> 00:43:52,439
drill down on like the desk IP and then

00:43:50,579 --> 00:43:54,959
each field is spelled out right here so

00:43:52,439 --> 00:43:57,869
if I want to drill down on just this IP

00:43:54,959 --> 00:44:04,399
address I click that it adds to the

00:43:57,869 --> 00:44:07,379
query and I say I already did it awesome

00:44:04,399 --> 00:44:08,399
you realize I did it so the 192 mil sex

00:44:07,379 --> 00:44:10,289
now it's not very impressed because

00:44:08,399 --> 00:44:12,419
there's hardly any logs in there but the

00:44:10,289 --> 00:44:14,069
point is that you'll get about this

00:44:12,419 --> 00:44:16,079
performance whether you have 20 billion

00:44:14,069 --> 00:44:22,169
logs or whether you have 20 logs and

00:44:16,079 --> 00:44:24,439
that's what i mean by big data so yeah

00:44:22,169 --> 00:44:24,439
oh

00:44:31,660 --> 00:44:38,900
alright so it's great yep so we have

00:44:36,350 --> 00:44:41,180
here are the longitude and latitude of

00:44:38,900 --> 00:44:44,500
our IP address here so if you want to

00:44:41,180 --> 00:44:48,260
know where you are and then we would say

00:44:44,500 --> 00:44:53,180
export results how do we want to export

00:44:48,260 --> 00:44:57,470
it please give me Google Earth and we

00:44:53,180 --> 00:45:00,560
have a KML file and I think the first

00:44:57,470 --> 00:45:02,300
time I open this I opened in G edit so

00:45:00,560 --> 00:45:04,490
we'll see if the file association is

00:45:02,300 --> 00:45:06,050
correct oh it free cookie or something

00:45:04,490 --> 00:45:10,430
anybody can help me fix the file

00:45:06,050 --> 00:45:17,900
association in a boon to 11 10 cuz I can

00:45:10,430 --> 00:45:20,300
which is embarrassing so fact but that's

00:45:17,900 --> 00:45:23,260
not going to work oh yeah hey hey nose

00:45:20,300 --> 00:45:23,260
again don't run the screen

00:45:44,240 --> 00:45:51,820
and said it was opening no it's not so

00:45:48,890 --> 00:45:51,820
I'll just open it manually here

00:45:57,809 --> 00:46:02,819
okay so if you have your file

00:46:00,479 --> 00:46:15,499
associations set up correctly that would

00:46:02,819 --> 00:46:15,499
just happen as it stands to do down

00:46:18,900 --> 00:46:32,849
quit kidding so the first part of the

00:46:31,260 --> 00:46:45,539
demo works but Google doesn't let me

00:46:32,849 --> 00:46:48,740
open a file as that is thanks now I

00:46:45,539 --> 00:46:48,740
shouldn't matter now it's flat file

00:46:53,740 --> 00:47:00,850
there's someone here worked for Google

00:46:58,960 --> 00:47:07,290
and they're like trying to prevent this

00:47:00,850 --> 00:47:07,290
from I sense a conspiracy theory right

00:47:11,820 --> 00:47:28,060
yeah there we go and see if anyone think

00:47:16,119 --> 00:47:30,119
you could just open a file like that all

00:47:28,060 --> 00:47:30,119
right

00:47:35,850 --> 00:47:52,110
no process phone nope hmm

00:47:55,450 --> 00:47:59,880
let's you don't make me a sandwich oh

00:48:04,710 --> 00:48:16,360
well I will be submitting that one all

00:48:08,650 --> 00:48:17,800
right epic fail all right but you saw it

00:48:16,360 --> 00:48:20,530
was KML you saw the latitude and

00:48:17,800 --> 00:48:25,690
longitude so that's not my fault I got

00:48:20,530 --> 00:48:26,980
you latitude and longitude suit but that

00:48:25,690 --> 00:48:32,700
does bring up a good point with the

00:48:26,980 --> 00:48:35,050
transform so you can see haha you can

00:48:32,700 --> 00:48:37,060
throw pretty much everyone on there so

00:48:35,050 --> 00:48:39,100
if I want to do who is that each

00:48:37,060 --> 00:48:42,940
transform will add on more fields and

00:48:39,100 --> 00:48:45,250
then you can do like if I wanted to take

00:48:42,940 --> 00:48:48,190
the sum of all the latitude numbers I

00:48:45,250 --> 00:48:54,010
could just type it to some here let's

00:48:48,190 --> 00:48:56,500
see dns TV maybe something like that so

00:48:54,010 --> 00:48:59,590
for this so the transforms mean for each

00:48:56,500 --> 00:49:01,750
record go through and apply this thing

00:48:59,590 --> 00:49:04,300
that might add fields on to it it will

00:49:01,750 --> 00:49:05,650
also using CH I check to see if it's

00:49:04,300 --> 00:49:07,360
already done that so you get cached

00:49:05,650 --> 00:49:09,940
result which is really helpful if it's a

00:49:07,360 --> 00:49:12,460
slow external web service or a slow

00:49:09,940 --> 00:49:14,080
internal web service for that matter and

00:49:12,460 --> 00:49:18,220
then each one of these fields has its

00:49:14,080 --> 00:49:20,260
own unique drill down right there so so

00:49:18,220 --> 00:49:24,190
Dean STD is awesome because it will tell

00:49:20,260 --> 00:49:26,860
me we participate in the program which

00:49:24,190 --> 00:49:29,050
is free for nonprofits and it's

00:49:26,860 --> 00:49:31,030
basically a reverse lookup for stuff

00:49:29,050 --> 00:49:33,670
that you've never looked up before so if

00:49:31,030 --> 00:49:35,500
anyone that participates has ever seen

00:49:33,670 --> 00:49:37,750
that host name for that IP address it

00:49:35,500 --> 00:49:40,030
will tell you so this particular IP

00:49:37,750 --> 00:49:43,090
address has been all of these different

00:49:40,030 --> 00:49:45,490
host names and then we can do a filter

00:49:43,090 --> 00:49:47,110
on that as another transform so this

00:49:45,490 --> 00:49:52,450
would be something like a having clause

00:49:47,110 --> 00:49:58,000
and sequel so we would say I only want

00:49:52,450 --> 00:49:59,830
to see stuff where any of the fields

00:49:58,000 --> 00:50:02,800
this is they're both regular expression

00:49:59,830 --> 00:50:05,980
for the field and far cow whatever that

00:50:02,800 --> 00:50:08,110
is so then it will take those results

00:50:05,980 --> 00:50:09,170
and just give you back the then this is

00:50:08,110 --> 00:50:11,270
again this is not part

00:50:09,170 --> 00:50:13,460
the big data part of it that's filtering

00:50:11,270 --> 00:50:14,720
the the final results which is pretty

00:50:13,460 --> 00:50:18,859
handy when you're trying to do reports

00:50:14,720 --> 00:50:21,109
that kind of stuff yeah thanks for

00:50:18,859 --> 00:50:22,579
actually ask you to do that because the

00:50:21,109 --> 00:50:26,540
yeah transformers a lot easier to

00:50:22,579 --> 00:50:28,430
explain that way Oh sub searching so we

00:50:26,540 --> 00:50:32,510
I don't think that was very clear before

00:50:28,430 --> 00:50:34,280
so the sub search requires that you're

00:50:32,510 --> 00:50:37,839
doing some sort of aggregation so we'll

00:50:34,280 --> 00:50:40,849
say I want to group by source IP and

00:50:37,839 --> 00:50:42,440
then so for each one of those source IP

00:50:40,849 --> 00:50:47,150
s what do we want to do with it and i

00:50:42,440 --> 00:50:50,750
would say find anything where com bytes

00:50:47,150 --> 00:50:52,640
is greater than one so that would be a

00:50:50,750 --> 00:51:00,109
conversation that had more than one bite

00:50:52,640 --> 00:51:03,530
something like that and nobody did so

00:51:00,109 --> 00:51:05,780
without the i don't think it was parsed

00:51:03,530 --> 00:51:08,630
because in my demo I didn't actually

00:51:05,780 --> 00:51:11,359
parse con bites out of the it wasn't a

00:51:08,630 --> 00:51:13,220
field we're recording but here so the

00:51:11,359 --> 00:51:15,020
group by does this it does the the

00:51:13,220 --> 00:51:21,290
graphing sort of part of the aggregation

00:51:15,020 --> 00:51:23,869
and then alright so you could say how

00:51:21,290 --> 00:51:26,390
about only want to know where that

00:51:23,869 --> 00:51:28,849
random string is involved as well so I

00:51:26,390 --> 00:51:32,450
would say all this stuff as an aura

00:51:28,849 --> 00:51:34,339
Clause plus and literal plus here means

00:51:32,450 --> 00:51:36,049
and and I don't think actually Google

00:51:34,339 --> 00:51:37,430
uses that is there some text anymore if

00:51:36,049 --> 00:51:39,109
they stop doing that with Google+ I

00:51:37,430 --> 00:51:41,329
think if these quotes now but back in

00:51:39,109 --> 00:51:44,660
the day used to be a plus sign meant the

00:51:41,329 --> 00:51:48,109
page must include that and so now it

00:51:44,660 --> 00:51:52,430
would be to query to queries ran the

00:51:48,109 --> 00:51:54,109
first query finds all of the far all

00:51:52,430 --> 00:51:56,359
connection ends that match this IP

00:51:54,109 --> 00:51:59,589
address and then the second one is where

00:51:56,359 --> 00:52:03,880
there's the second IP address involved

00:51:59,589 --> 00:52:05,990
and then there's the ante pagination etc

00:52:03,880 --> 00:52:10,099
okay now are there any questions about

00:52:05,990 --> 00:52:12,410
that part okay exhausted all questions

00:52:10,099 --> 00:52:16,660
please feel free to see me after the

00:52:12,410 --> 00:52:20,420
talk or later the conference 8-1 yeah

00:52:16,660 --> 00:52:22,730
star who is the we you're referring to

00:52:20,420 --> 00:52:38,619
another group if you just take the

00:52:22,730 --> 00:52:43,520
organization on the public sector yes

00:52:38,619 --> 00:52:47,089
that answers the question yeah I'll just

00:52:43,520 --> 00:52:49,420
leave it at that for now all right well

00:52:47,089 --> 00:52:49,420

YouTube URL: https://www.youtube.com/watch?v=U8Ax2S0mxz4


