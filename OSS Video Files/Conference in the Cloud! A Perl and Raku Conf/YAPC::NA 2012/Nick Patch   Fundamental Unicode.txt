Title: Nick Patch   Fundamental Unicode
Publication date: 2013-08-20
Playlist: YAPC::NA 2012
Description: 
	
Captions: 
	00:00:03,500 --> 00:00:12,540
ok so I'm Nick patch and I have been

00:00:08,010 --> 00:00:14,210
working a lot with I unicode various

00:00:12,540 --> 00:00:16,650
character encodings and

00:00:14,210 --> 00:00:19,789
internationalization over the last few

00:00:16,650 --> 00:00:22,170
years both working on projects to

00:00:19,789 --> 00:00:26,970
internationalize web applications as

00:00:22,170 --> 00:00:29,490
well as I convert detect and convert

00:00:26,970 --> 00:00:33,300
multiple different unknown character

00:00:29,490 --> 00:00:35,430
encodings to utf-8 and through that I've

00:00:33,300 --> 00:00:38,309
gained a lot of knowledge on Unicode and

00:00:35,430 --> 00:00:43,170
a lot of wrangling and I also realized

00:00:38,309 --> 00:00:47,129
that I a lot most people don't know

00:00:43,170 --> 00:00:48,629
enough about Unicode I which I didn't at

00:00:47,129 --> 00:00:50,879
one point and I really like to sort of

00:00:48,629 --> 00:00:54,360
share some of what I've learned here I

00:00:50,879 --> 00:00:56,879
right now I'm actually working with

00:00:54,360 --> 00:01:00,750
shutterstock on the international team

00:00:56,879 --> 00:01:04,199
and as I'm sure you'll hear multiple

00:01:00,750 --> 00:01:06,540
times throughout the conference we're

00:01:04,199 --> 00:01:09,600
hiring I so get in touch if you're

00:01:06,540 --> 00:01:15,060
interested I were in New York City

00:01:09,600 --> 00:01:17,340
anyway so what was a character I eat is

00:01:15,060 --> 00:01:19,680
the smallest component of written

00:01:17,340 --> 00:01:22,100
language that has semantic value and

00:01:19,680 --> 00:01:25,860
refers to an abstract manner shape as

00:01:22,100 --> 00:01:27,240
opposed to a specific shape I at least

00:01:25,860 --> 00:01:31,799
that's what the Unicode consortium

00:01:27,240 --> 00:01:35,250
defines it as and that so for example a

00:01:31,799 --> 00:01:37,829
glyph is a visual representation of

00:01:35,250 --> 00:01:40,170
characters and fonts are collections of

00:01:37,829 --> 00:01:42,600
glyphs there can be multiple different

00:01:40,170 --> 00:01:46,320
glyphs for any character now you've got

00:01:42,600 --> 00:01:48,780
I'm a in times new roman a and Arial

00:01:46,320 --> 00:01:50,430
bold italic and so forth those are all

00:01:48,780 --> 00:01:52,229
glyphs and we're not here to talk about

00:01:50,430 --> 00:01:55,049
glyphs we're talking about characters

00:01:52,229 --> 00:01:58,200
which have individual meaning per

00:01:55,049 --> 00:02:00,060
character as opposed to a universal

00:01:58,200 --> 00:02:02,219
glyph for them since it can vary

00:02:00,060 --> 00:02:05,460
considerably and still mean the same

00:02:02,219 --> 00:02:07,200
thing to people so let's just quickly go

00:02:05,460 --> 00:02:08,729
over some examples of characters you

00:02:07,200 --> 00:02:12,420
know you've got your letters both in

00:02:08,729 --> 00:02:17,239
English and various other languages

00:02:12,420 --> 00:02:20,670
you've let your numbers punctuation

00:02:17,239 --> 00:02:22,290
symbols you know there's some standard

00:02:20,670 --> 00:02:24,780
business symbols that people always

00:02:22,290 --> 00:02:26,670
consider as characters here then some

00:02:24,780 --> 00:02:30,239
things that are pushing it a little like

00:02:26,670 --> 00:02:33,810
like the pile of poo which was released

00:02:30,239 --> 00:02:36,600
in Unicode six-point oh but really yes

00:02:33,810 --> 00:02:39,060
that one although I I don't know if it's

00:02:36,600 --> 00:02:41,760
defined with the stink lines or not that

00:02:39,060 --> 00:02:43,590
might be part of the glyph I you could

00:02:41,760 --> 00:02:45,569
potentially include little flies that

00:02:43,590 --> 00:02:47,370
would be part of the glyph anyway I am

00:02:45,569 --> 00:02:49,980
the reason that's included as a

00:02:47,370 --> 00:02:51,989
character is because the Unicode

00:02:49,980 --> 00:02:55,620
consortium considers anything that you

00:02:51,989 --> 00:02:58,500
use in line with characters so emoticons

00:02:55,620 --> 00:03:02,280
and such you use them in line flowing

00:02:58,500 --> 00:03:04,440
with your text I as opposed to a you

00:03:02,280 --> 00:03:06,600
know right justifying them with text

00:03:04,440 --> 00:03:10,799
around them so that's they consider that

00:03:06,600 --> 00:03:12,780
to be a character as well and also there

00:03:10,799 --> 00:03:14,670
are various control characters which

00:03:12,780 --> 00:03:16,859
that's also sort of stretching it as far

00:03:14,670 --> 00:03:20,220
as the traditional sense of characters

00:03:16,859 --> 00:03:22,799
but you know carriage return no breaking

00:03:20,220 --> 00:03:25,200
space a combined and graphene joiner

00:03:22,799 --> 00:03:28,200
right to left mark we'll talk about some

00:03:25,200 --> 00:03:31,290
of these a little later but I some of

00:03:28,200 --> 00:03:34,620
these aren't really Oh characters they

00:03:31,290 --> 00:03:38,100
they control how characters work but for

00:03:34,620 --> 00:03:39,690
I as far as Unicode goes well we'll

00:03:38,100 --> 00:03:41,760
consider these characters as well even

00:03:39,690 --> 00:03:43,920
though some of them are non printing or

00:03:41,760 --> 00:03:46,380
just affect the way that others print I

00:03:43,920 --> 00:03:50,600
mean even if you look at morse code

00:03:46,380 --> 00:03:50,600
they've got control characters as well

00:03:50,989 --> 00:03:58,739
so there's a lot of confusion over the

00:03:55,230 --> 00:04:01,220
term character set I people use it to me

00:03:58,739 --> 00:04:04,200
and character code character encoding

00:04:01,220 --> 00:04:05,819
character repertoire and there's good

00:04:04,200 --> 00:04:07,290
reason for the confusion that's because

00:04:05,819 --> 00:04:09,180
their standards all over the place that

00:04:07,290 --> 00:04:12,900
use all different terms and there's no

00:04:09,180 --> 00:04:17,130
unified usage of terms I'll list some

00:04:12,900 --> 00:04:21,060
that I like to use consistently and make

00:04:17,130 --> 00:04:25,500
a lot of sense I let's see if there's

00:04:21,060 --> 00:04:26,290
character code I'm which is just a

00:04:25,500 --> 00:04:29,590
defined

00:04:26,290 --> 00:04:33,520
mapping of characters to numbers I each

00:04:29,590 --> 00:04:37,800
value in a character code is called a

00:04:33,520 --> 00:04:40,450
code point so here I the majority of the

00:04:37,800 --> 00:04:44,410
character codes that you'll use in

00:04:40,450 --> 00:04:48,960
computing I actually have the same code

00:04:44,410 --> 00:04:54,070
points for a B and C and you do a basic

00:04:48,960 --> 00:04:56,620
alphanumerics and much of asking yes yes

00:04:54,070 --> 00:05:02,800
I will announce at the end where they'll

00:04:56,620 --> 00:05:07,780
live post it I'm so the code point for

00:05:02,800 --> 00:05:10,660
uppercase B for example is 42 then a

00:05:07,780 --> 00:05:13,210
character encoding is an algorithm to

00:05:10,660 --> 00:05:15,010
convert code points to a digital form

00:05:13,210 --> 00:05:19,570
for ease of transmitting or storing data

00:05:15,010 --> 00:05:25,600
I so here i'm just showing the binary

00:05:19,570 --> 00:05:30,010
form of these code points and there's

00:05:25,600 --> 00:05:32,320
nothing inherently attaching a code

00:05:30,010 --> 00:05:36,520
point as part of a character code to a

00:05:32,320 --> 00:05:37,960
character encoding then a character

00:05:36,520 --> 00:05:41,800
repertoire it's a less technical term

00:05:37,960 --> 00:05:43,630
it's just a defined set of supported

00:05:41,800 --> 00:05:45,700
characters a lot of people say character

00:05:43,630 --> 00:05:47,950
set for this as well just because it's a

00:05:45,700 --> 00:05:49,810
set of characters but really I character

00:05:47,950 --> 00:05:53,890
repertoire is a good term for it because

00:05:49,810 --> 00:05:55,600
I there are a lot of different things

00:05:53,890 --> 00:05:59,530
that have character repertoire character

00:05:55,600 --> 00:06:01,330
codes do your keyboard does I natural

00:05:59,530 --> 00:06:08,110
languages each have their own character

00:06:01,330 --> 00:06:12,040
repertoire so 11 character I code and

00:06:08,110 --> 00:06:15,400
encoding that we know and love is asking

00:06:12,040 --> 00:06:19,120
I it is both a character code and a

00:06:15,400 --> 00:06:23,320
character encoding that is it has 128

00:06:19,120 --> 00:06:25,300
code points and then I you know

00:06:23,320 --> 00:06:29,980
character encoding defined for all of

00:06:25,300 --> 00:06:33,190
those I it's a 7 bits each I although in

00:06:29,980 --> 00:06:36,580
modern usage we take up 8 bits but it

00:06:33,190 --> 00:06:39,300
only uses a seven of them are ignoring

00:06:36,580 --> 00:06:39,300
the high bet

00:06:39,409 --> 00:06:50,419
then there's the Latin one or iso 8859-1

00:06:44,409 --> 00:06:53,539
extension to ascii I that has 256 code

00:06:50,419 --> 00:06:55,099
points I doubling I how many are

00:06:53,539 --> 00:06:57,949
available because you have the full

00:06:55,099 --> 00:07:01,209
eight bits including the high bit for

00:06:57,949 --> 00:07:07,809
use I and then there are so a lot of

00:07:01,209 --> 00:07:11,239
other I 8-bit encoding I iso 8859 1

00:07:07,809 --> 00:07:13,729
through 15 it the reason we need

00:07:11,239 --> 00:07:18,619
multiple ones is because if you want to

00:07:13,729 --> 00:07:21,169
store each character in eight bits I and

00:07:18,619 --> 00:07:22,849
just have individually 8-bit per

00:07:21,169 --> 00:07:25,099
character well you can't store all of

00:07:22,849 --> 00:07:26,959
the world's languages characters out

00:07:25,099 --> 00:07:30,559
there so you need to have one for you

00:07:26,959 --> 00:07:35,559
know various Eastern European languages

00:07:30,559 --> 00:07:39,199
one for thai and so forth and that is

00:07:35,559 --> 00:07:43,039
unfortunately you can't use two

00:07:39,199 --> 00:07:45,199
different encoding 'he's in the same

00:07:43,039 --> 00:07:47,569
document without some way of defining

00:07:45,199 --> 00:07:50,059
okay now i'm using this encoding which

00:07:47,569 --> 00:07:54,099
people don't generally do like an email

00:07:50,059 --> 00:07:57,079
or web pages you choose one encoding I

00:07:54,099 --> 00:08:01,490
that's why Unicode came around cuz we're

00:07:57,079 --> 00:08:03,619
increasingly seeing a lot of multiple

00:08:01,490 --> 00:08:05,089
languages in international documents and

00:08:03,619 --> 00:08:06,800
such are just quotes from different

00:08:05,089 --> 00:08:10,639
languages and you want to be able to use

00:08:06,800 --> 00:08:14,179
them I all in individual documents as

00:08:10,639 --> 00:08:19,519
well as have a variety of different

00:08:14,179 --> 00:08:22,939
support for working with a text from

00:08:19,519 --> 00:08:26,719
different languages so Unicode is a

00:08:22,939 --> 00:08:30,679
character code it itself is not a

00:08:26,719 --> 00:08:33,589
character encoding it defines I over a

00:08:30,679 --> 00:08:36,769
million code points I well it has that

00:08:33,589 --> 00:08:39,469
many available i defined we only have a

00:08:36,769 --> 00:08:43,939
little over a hundred ten thousand but

00:08:39,469 --> 00:08:46,129
it grows with new releases as needed 6.1

00:08:43,939 --> 00:08:47,689
was released recently 6.2 will be

00:08:46,129 --> 00:08:49,399
released later in the year but that's

00:08:47,689 --> 00:08:50,959
only adding an individual character

00:08:49,399 --> 00:08:53,030
sometimes they're smaller releases some

00:08:50,959 --> 00:08:55,430
times larger so anyway there

00:08:53,030 --> 00:08:59,320
are multiple encoding associated with

00:08:55,430 --> 00:09:03,920
Unicode I the three standard ones are

00:08:59,320 --> 00:09:10,900
utf-8 utf-16 and UTF third eight utf-32

00:09:03,920 --> 00:09:14,900
I utf-8 being a variable by encoding I

00:09:10,900 --> 00:09:17,360
you don't have an individual length for

00:09:14,900 --> 00:09:21,710
every single code point instead it

00:09:17,360 --> 00:09:25,930
ranges a 1 through 4 bytes 0 1 2 3 or 4

00:09:21,710 --> 00:09:29,750
bytes per character I'm this oftentimes

00:09:25,930 --> 00:09:34,010
can pack the most data into the smallest

00:09:29,750 --> 00:09:36,170
space I but it also is a little harder

00:09:34,010 --> 00:09:40,010
on computing because you can never just

00:09:36,170 --> 00:09:42,980
jump to a random point in a string and

00:09:40,010 --> 00:09:50,210
know what character you're at without

00:09:42,980 --> 00:09:52,370
scanning all of the data before it now

00:09:50,210 --> 00:09:55,940
it's defined at that originally it was

00:09:52,370 --> 00:09:58,580
defined up to six I but when it was

00:09:55,940 --> 00:10:02,660
merged with a universal character set in

00:09:58,580 --> 00:10:08,000
the mid-90s I it was standardized add up

00:10:02,660 --> 00:10:17,060
to four I so then utf-16 is either two

00:10:08,000 --> 00:10:27,920
or four bites yes yeah you would have to

00:10:17,060 --> 00:10:31,420
read everything before it I'm yeah you

00:10:27,920 --> 00:10:31,420
really have to count from the beginning

00:10:37,390 --> 00:10:43,580
that's a good point I'm if you yes if

00:10:41,240 --> 00:10:49,390
you did start somewhere in a string I

00:10:43,580 --> 00:10:52,820
you know I based on I'm the order of

00:10:49,390 --> 00:10:55,070
multi-byte characters you know where the

00:10:52,820 --> 00:10:57,020
boundaries are so you may not be able to

00:10:55,070 --> 00:10:59,290
count where you are but at least you

00:10:57,020 --> 00:11:03,400
know that you're not corrupting data I

00:10:59,290 --> 00:11:06,740
if you actually look at it I'm then

00:11:03,400 --> 00:11:09,470
utf-32 is consistently

00:11:06,740 --> 00:11:13,580
four bytes each so utf-8 is the most

00:11:09,470 --> 00:11:17,510
popular I encoding around now it has

00:11:13,580 --> 00:11:20,740
been since 2007 it is the standard and

00:11:17,510 --> 00:11:24,740
default for many Internet protocols and

00:11:20,740 --> 00:11:29,899
I'm it's by default it's what I'd

00:11:24,740 --> 00:11:31,970
recommend using I utf-32 really isn't

00:11:29,899 --> 00:11:34,670
seen publicly it's more of something you

00:11:31,970 --> 00:11:37,420
see internally for when you do want that

00:11:34,670 --> 00:11:39,260
you know consistent 4 bytes per

00:11:37,420 --> 00:11:46,880
character of course you need more space

00:11:39,260 --> 00:11:48,560
for that so a code point I here I

00:11:46,880 --> 00:11:51,800
represent for three different code

00:11:48,560 --> 00:11:56,060
points first a glyph representing that

00:11:51,800 --> 00:11:59,180
code point then I the code point value

00:11:56,060 --> 00:12:03,380
which in the unicode standard is you

00:11:59,180 --> 00:12:05,480
plus the four or more digits if it's

00:12:03,380 --> 00:12:07,550
less than four you pad it with zeros and

00:12:05,480 --> 00:12:10,010
that's just a standard way to represent

00:12:07,550 --> 00:12:13,399
that character and then there's a

00:12:10,010 --> 00:12:17,120
standard name I it's I generally given

00:12:13,399 --> 00:12:20,240
in all caps and it never changes I you

00:12:17,120 --> 00:12:21,950
can if you're referring to a character

00:12:20,240 --> 00:12:25,450
there are a lot of inconsistent ways

00:12:21,950 --> 00:12:27,980
that people I refer two characters

00:12:25,450 --> 00:12:30,950
considering that Unicode is a standard

00:12:27,980 --> 00:12:34,570
that covers pretty much any character

00:12:30,950 --> 00:12:37,310
you're going to want to use a way to

00:12:34,570 --> 00:12:40,130
unambiguously refer to characters like

00:12:37,310 --> 00:12:43,399
in documents and such is by giving the

00:12:40,130 --> 00:12:46,190
Unicode name plus the Unicode code point

00:12:43,399 --> 00:12:47,360
in the U plus form because you know

00:12:46,190 --> 00:12:49,070
that's standardized and then you don't

00:12:47,360 --> 00:12:55,000
need a reference you know this is a

00:12:49,070 --> 00:12:55,000
unicode code point yes

00:13:07,300 --> 00:13:17,620
that's a very good point thank you and

00:13:10,230 --> 00:13:19,000
it and I please feel free to call out if

00:13:17,620 --> 00:13:20,320
you see any issues because I want to

00:13:19,000 --> 00:13:21,880
make sure everyone's getting the most

00:13:20,320 --> 00:13:35,100
accurate information and I can update

00:13:21,880 --> 00:13:37,779
the slides in the future if needed so on

00:13:35,100 --> 00:13:40,930
some code points have precomposed

00:13:37,779 --> 00:13:42,610
diacritics diacritics being the you know

00:13:40,930 --> 00:13:48,760
squiggly characters and funny marks

00:13:42,610 --> 00:13:52,570
around I characters I like here we have

00:13:48,760 --> 00:13:54,640
a latin small letter o with dr ases

00:13:52,570 --> 00:13:57,730
otherwise known as umlaut in German I

00:13:54,640 --> 00:14:01,420
and Mac run which is the line above it

00:13:57,730 --> 00:14:04,360
I'm in this case we have an individual

00:14:01,420 --> 00:14:06,190
code point 02 to be I with the name

00:14:04,360 --> 00:14:10,510
latin small letter o with dr SS and

00:14:06,190 --> 00:14:14,110
macaron I for this code point I but in

00:14:10,510 --> 00:14:17,350
not in every case so for example if you

00:14:14,110 --> 00:14:20,440
wanted n with dr SS say you were

00:14:17,350 --> 00:14:22,390
spelling spinal tap well that's not in

00:14:20,440 --> 00:14:24,850
any of the world languages so the

00:14:22,390 --> 00:14:28,540
Unicode consortium did not take spinal

00:14:24,850 --> 00:14:32,470
tap into a favor when I defining their

00:14:28,540 --> 00:14:35,470
character repertoire I and they came up

00:14:32,470 --> 00:14:38,380
with a solution for combining characters

00:14:35,470 --> 00:14:41,560
where you have a base character just a

00:14:38,380 --> 00:14:43,779
regular character followed by one or

00:14:41,560 --> 00:14:48,010
more combining characters there's

00:14:43,779 --> 00:14:50,230
actually no limit to it and I the this

00:14:48,010 --> 00:14:52,990
is multiple code points such as latin

00:14:50,230 --> 00:14:58,750
small letter n i followed by combining

00:14:52,990 --> 00:15:01,630
dr SS and it creates a graphene cluster

00:14:58,750 --> 00:15:04,000
an extended graphing cluster commonly in

00:15:01,630 --> 00:15:07,480
the pearl world you will hear this

00:15:04,000 --> 00:15:09,180
referred to simply as a graph iam I a

00:15:07,480 --> 00:15:11,610
lot of people how

00:15:09,180 --> 00:15:13,140
a Unicode folks have a problem with that

00:15:11,610 --> 00:15:14,580
because it technically means something

00:15:13,140 --> 00:15:17,910
different but you'll see grapheme

00:15:14,580 --> 00:15:24,360
everywhere in the pearl world I to mean

00:15:17,910 --> 00:15:29,030
extended graphene cluster I'm it's just

00:15:24,360 --> 00:15:33,930
it's slightly different I'm but there

00:15:29,030 --> 00:15:36,000
there along the same lines I but in the

00:15:33,930 --> 00:15:40,050
pearl world there's no changing the fact

00:15:36,000 --> 00:15:43,260
that we use graphing I if the term

00:15:40,050 --> 00:15:47,060
grapheme has a different meaning than

00:15:43,260 --> 00:15:47,060
extended graphene cluster I

00:15:58,470 --> 00:16:04,170
right a extended graphing cluster

00:16:01,350 --> 00:16:09,270
replaced the traditional graphene

00:16:04,170 --> 00:16:12,720
cluster so anyway I'm here we have an

00:16:09,270 --> 00:16:16,020
example of three different I grapheme

00:16:12,720 --> 00:16:18,900
clusters I one of them is just a single

00:16:16,020 --> 00:16:26,100
code point it's a which I got right this

00:16:18,900 --> 00:16:29,040
time right then I'm the next one here is

00:16:26,100 --> 00:16:31,140
I you know n follow followed by

00:16:29,040 --> 00:16:34,320
combining the RSS followed by combining

00:16:31,140 --> 00:16:35,730
what it was like a lower circle I had

00:16:34,320 --> 00:16:39,210
another technical term and another is

00:16:35,730 --> 00:16:41,700
actually I see our LF because that's

00:16:39,210 --> 00:16:43,950
really just a you know a control

00:16:41,700 --> 00:16:49,230
character even though it's to code

00:16:43,950 --> 00:17:00,360
points okay so let's jump into some

00:16:49,230 --> 00:17:03,720
pearl see you hanging so I'm first off

00:17:00,360 --> 00:17:08,370
let's just show I have a few different

00:17:03,720 --> 00:17:14,000
ways to I represent I non-ascii

00:17:08,370 --> 00:17:17,160
characters in as pearl a literal I

00:17:14,000 --> 00:17:20,340
constants here we want to have jalapeno

00:17:17,160 --> 00:17:24,150
so we're going to the traditional route

00:17:20,340 --> 00:17:29,000
of doing our escape sequence back / x

00:17:24,150 --> 00:17:32,850
and then the hex value with optional I

00:17:29,000 --> 00:17:40,470
braces if it's only a two character I X

00:17:32,850 --> 00:17:42,690
valium then in Perl 5 12 it introduced a

00:17:40,470 --> 00:17:46,650
way where you can actually put the

00:17:42,690 --> 00:17:49,380
official unicode code point syntax in

00:17:46,650 --> 00:17:53,520
there it has a little more meaning I

00:17:49,380 --> 00:17:54,840
then just a hex value there but of

00:17:53,520 --> 00:17:58,680
course it's a little longer so a

00:17:54,840 --> 00:18:03,410
backslash uppercase n followed by the

00:17:58,680 --> 00:18:03,410
value I in braces

00:18:09,789 --> 00:18:17,509
well I'm getting in touch our names now

00:18:12,740 --> 00:18:22,249
I and if you use the turnings module I

00:18:17,509 --> 00:18:26,809
am here we're using the the full flag so

00:18:22,249 --> 00:18:30,950
we can use the full unicode names i am

00:18:26,809 --> 00:18:33,259
now with backslash I uppercase and we

00:18:30,950 --> 00:18:36,620
can pass the Unicode names yeah it's a

00:18:33,259 --> 00:18:39,200
lot longer but it really tells whoever's

00:18:36,620 --> 00:18:41,720
using the code in the future exactly

00:18:39,200 --> 00:18:47,690
what it is without having to look it up

00:18:41,720 --> 00:18:51,619
I'm and then if you use utf-8 you can

00:18:47,690 --> 00:18:53,809
just put your utf-8 data directly in

00:18:51,619 --> 00:18:57,470
your file and this is also a nice

00:18:53,809 --> 00:18:59,179
solution when I see with jalapeno I mean

00:18:57,470 --> 00:19:04,759
we know what that is the end with the

00:18:59,179 --> 00:19:07,730
NEA and the upside down I bang I that

00:19:04,759 --> 00:19:10,129
that can oftentimes tell the most at

00:19:07,730 --> 00:19:14,029
first glance but there are other times

00:19:10,129 --> 00:19:17,570
when say you might have combining a code

00:19:14,029 --> 00:19:20,749
points that I you can't see visually and

00:19:17,570 --> 00:19:25,639
you want to emphasize the fact that this

00:19:20,749 --> 00:19:28,879
is a separate code point and in your pod

00:19:25,639 --> 00:19:33,169
I if you're going to use non-ascii

00:19:28,879 --> 00:19:35,679
characters in a utf-8 I you just say

00:19:33,169 --> 00:19:38,679
encoding utf-8 at the top of your pod

00:19:35,679 --> 00:19:38,679
yes

00:19:46,800 --> 00:19:55,540
well I I'm telling you you have to I'm

00:19:53,560 --> 00:20:01,240
route if i'm reviewing your code i'm

00:19:55,540 --> 00:20:03,670
saying you have to yeah i mean because

00:20:01,240 --> 00:20:07,570
the thing is that I we're going to get

00:20:03,670 --> 00:20:10,600
into the unicode bug I a little later

00:20:07,570 --> 00:20:14,320
but it could it's ambiguous here is this

00:20:10,600 --> 00:20:17,370
Latin one is this utf-8 traditionally in

00:20:14,320 --> 00:20:17,370
Perl it would be Latin one

00:20:29,960 --> 00:20:45,000
by default so what we're saying here is

00:20:41,670 --> 00:21:01,410
that our source code is encoded as utf-8

00:20:45,000 --> 00:21:12,870
say say you're I'm yep we'll get into

00:21:01,410 --> 00:21:14,429
that right so for example all the

00:21:12,870 --> 00:21:17,610
examples that I showed up until this

00:21:14,429 --> 00:21:20,880
this could be an ASCII well it could

00:21:17,610 --> 00:21:24,390
even be I in any encoding that I

00:21:20,880 --> 00:21:26,670
supports the ASCII subset but I once we

00:21:24,390 --> 00:21:30,929
get into this last example on this slide

00:21:26,670 --> 00:21:40,350
I we are saying that our source code is

00:21:30,929 --> 00:21:44,010
in utf-8 as well as this pod so in

00:21:40,350 --> 00:21:47,660
general the flow of your application

00:21:44,010 --> 00:21:53,070
assuming that you have utf-8 input and

00:21:47,660 --> 00:21:56,900
utf-8 output is I you have your utf-8

00:21:53,070 --> 00:22:00,210
encoded input you decode it to a pearl

00:21:56,900 --> 00:22:06,240
internal string which is a Unicode

00:22:00,210 --> 00:22:11,130
string you encode it and then you output

00:22:06,240 --> 00:22:13,650
a utf-8 encoded output of course you may

00:22:11,130 --> 00:22:15,900
have some different input or output just

00:22:13,650 --> 00:22:17,850
replace by whatever your encoding is for

00:22:15,900 --> 00:22:20,190
your input or desired output here but

00:22:17,850 --> 00:22:27,929
this is the general flow is that you

00:22:20,190 --> 00:22:32,150
decode on input you encode on output so

00:22:27,929 --> 00:22:32,150
too I when we're opening yes

00:22:37,909 --> 00:22:43,619
I'm trying to point out if it differs by

00:22:40,950 --> 00:22:45,299
version it's hard because I in some is

00:22:43,619 --> 00:22:51,330
because there's been a lot of progress

00:22:45,299 --> 00:22:56,220
in a Unicode and utf-8 support over like

00:22:51,330 --> 00:23:01,320
every version 5.8 and since and I really

00:22:56,220 --> 00:23:06,029
I recommend using Perl 5 12 or greater

00:23:01,320 --> 00:23:08,999
if possible I but oftentimes were stuck

00:23:06,029 --> 00:23:10,590
with 58 in many situations you know

00:23:08,999 --> 00:23:13,559
depending on our work environment or

00:23:10,590 --> 00:23:15,590
server environment and such I so I'm not

00:23:13,559 --> 00:23:17,820
keeping this talk to any specific

00:23:15,590 --> 00:23:25,830
version of Perl and trying to point out

00:23:17,820 --> 00:23:30,350
where it differs so when we're opening a

00:23:25,830 --> 00:23:35,759
file handle for reading here using the

00:23:30,350 --> 00:23:39,330
less than sign for reading input I'm if

00:23:35,759 --> 00:23:41,730
you put colon encoding I and then

00:23:39,330 --> 00:23:45,029
specify what encoding it can be anything

00:23:41,730 --> 00:23:50,369
you want but i'm using utf-8 for all of

00:23:45,029 --> 00:23:54,919
our examples I'm you will I decode all

00:23:50,369 --> 00:23:59,279
of your input from that file handle and

00:23:54,919 --> 00:24:01,409
for output I you do the same thing you

00:23:59,279 --> 00:24:06,929
can optionally add even like spaces

00:24:01,409 --> 00:24:09,059
between your specifying the input or the

00:24:06,929 --> 00:24:14,700
reader right mode and that colon there

00:24:09,059 --> 00:24:17,389
if you want it to be more readable this

00:24:14,700 --> 00:24:17,389
works in 58

00:24:19,220 --> 00:24:25,140
but here's bin mode I even you already

00:24:22,950 --> 00:24:27,600
have a file handle open so say you're

00:24:25,140 --> 00:24:30,179
working with code where you can't go and

00:24:27,600 --> 00:24:32,820
change oh the initial opening of that

00:24:30,179 --> 00:24:34,620
file handle you can call bin mode on it

00:24:32,820 --> 00:24:38,460
passing your file handle as the first

00:24:34,620 --> 00:24:40,710
argument and then I doing the same colon

00:24:38,460 --> 00:24:43,409
and coding syntax for the second

00:24:40,710 --> 00:24:46,470
argument as a string I'm and then for

00:24:43,409 --> 00:24:50,929
any of the standard in standard out

00:24:46,470 --> 00:24:50,929
standard error you can do the same thing

00:24:51,889 --> 00:25:02,789
now you can specify I at the top of your

00:24:56,820 --> 00:25:06,090
file too I open all file handles I using

00:25:02,789 --> 00:25:09,299
utf-8 so in this example we're using the

00:25:06,090 --> 00:25:13,380
open pragma and specifying that our

00:25:09,299 --> 00:25:16,260
input and output of our file handles is

00:25:13,380 --> 00:25:18,690
going to be in utf-8 I and it will just

00:25:16,260 --> 00:25:22,019
do the implicit decoding and encoding

00:25:18,690 --> 00:25:24,630
for us this example here does not handle

00:25:22,019 --> 00:25:27,809
standard in a standard ad in standard

00:25:24,630 --> 00:25:30,870
error because this is how you do it also

00:25:27,809 --> 00:25:36,830
passed the standard flag I and it will

00:25:30,870 --> 00:25:41,250
handle those file handles as well and

00:25:36,830 --> 00:25:44,669
there's a Sipan module utf-8 all which

00:25:41,250 --> 00:25:48,240
will I do I quite a bit behind the

00:25:44,669 --> 00:25:50,909
scenes for you I it's doing the I you

00:25:48,240 --> 00:25:56,549
know use open encoding utf-8 standard

00:25:50,909 --> 00:25:59,990
I'm and also use utf-8 to specify that

00:25:56,549 --> 00:26:03,120
your source code is in utf-8 I'm and

00:25:59,990 --> 00:26:04,320
some other things as well it's handy but

00:26:03,120 --> 00:26:06,929
you should make sure to read the

00:26:04,320 --> 00:26:09,570
documentation and know what it's doing

00:26:06,929 --> 00:26:12,510
for us because it's not there is no you

00:26:09,570 --> 00:26:16,559
know one shot solution for everything I

00:26:12,510 --> 00:26:18,539
use it a lot on you know one-liners as

00:26:16,559 --> 00:26:21,149
well just because it's a simple way for

00:26:18,539 --> 00:26:27,029
me not to do all sorts of like dash

00:26:21,149 --> 00:26:29,250
uppercase M on my one-liners then for

00:26:27,029 --> 00:26:31,770
those cases where I you know there's a

00:26:29,250 --> 00:26:32,519
lot of times where our input and output

00:26:31,770 --> 00:26:37,999
is

00:26:32,519 --> 00:26:42,869
via file handles I so you can explicitly

00:26:37,999 --> 00:26:47,519
decode and encode your values I by using

00:26:42,869 --> 00:26:49,349
the encode module and I you've got your

00:26:47,519 --> 00:26:51,929
decode and encode functions where the

00:26:49,349 --> 00:26:55,889
first value is the name of your encoding

00:26:51,929 --> 00:26:57,299
utf-8 in our example I'm a little later

00:26:55,889 --> 00:27:00,690
on we'll get into the differences

00:26:57,299 --> 00:27:05,459
between a UT f dash 8 and utf-8 for

00:27:00,690 --> 00:27:07,979
those wondering and you know there are a

00:27:05,459 --> 00:27:10,889
lot of different frameworks we're

00:27:07,979 --> 00:27:13,559
working with you know catalyst CGI and

00:27:10,889 --> 00:27:18,299
so forth many of them provide options

00:27:13,559 --> 00:27:23,039
for their own implicit encoding and

00:27:18,299 --> 00:27:27,029
decoding say for example ooh parameters

00:27:23,039 --> 00:27:28,409
passed on through URLs and such I but

00:27:27,029 --> 00:27:35,759
you'll have to reference the

00:27:28,409 --> 00:27:39,359
documentation for those so one issue

00:27:35,759 --> 00:27:42,769
that comes up is string length because

00:27:39,359 --> 00:27:47,579
you can't just use the traditional

00:27:42,769 --> 00:27:50,659
length for every purpose here on in the

00:27:47,579 --> 00:27:53,429
next few examples we're going to use a

00:27:50,659 --> 00:27:55,459
string that is just a the graphing

00:27:53,429 --> 00:27:58,729
cluster Cyrillic small letter you

00:27:55,459 --> 00:28:02,700
followed by combining acute accent I

00:27:58,729 --> 00:28:05,219
there is no precomposed code point for

00:28:02,700 --> 00:28:08,009
this but it's commonly used in Russian

00:28:05,219 --> 00:28:13,889
dictionaries I have to show the emphasis

00:28:08,009 --> 00:28:19,109
on the Cyrillic small letter U so say we

00:28:13,889 --> 00:28:23,219
have I this graphing cluster encoded as

00:28:19,109 --> 00:28:26,249
utf-8 and we pass it to length well

00:28:23,219 --> 00:28:31,409
we're going to receive for back because

00:28:26,249 --> 00:28:39,239
I'm those two code points I are double

00:28:31,409 --> 00:28:42,629
byte encoded in utf-8 now let's decode

00:28:39,239 --> 00:28:45,179
that from utf-8 to a pearl internal

00:28:42,629 --> 00:28:46,260
string and pass it to length well now we

00:28:45,179 --> 00:28:48,750
were getting too

00:28:46,260 --> 00:28:52,350
because we're calling it on a Unicode

00:28:48,750 --> 00:28:59,610
string as opposed to I just in encoded

00:28:52,350 --> 00:29:02,220
series of bytes well what if you want to

00:28:59,610 --> 00:29:06,000
look at this on what the user considers

00:29:02,220 --> 00:29:10,800
a character because when a user looks at

00:29:06,000 --> 00:29:14,940
a word that has I combining code points

00:29:10,800 --> 00:29:16,290
I they won't consider it multiple

00:29:14,940 --> 00:29:18,900
characters that will consider it one

00:29:16,290 --> 00:29:21,300
character so we want to count that as an

00:29:18,900 --> 00:29:23,220
individual character I will let's see

00:29:21,300 --> 00:29:24,900
how we do that on one line like we're

00:29:23,220 --> 00:29:27,720
doing these others on one line now gets

00:29:24,900 --> 00:29:29,790
a little more complicated here on but it

00:29:27,720 --> 00:29:33,180
gives us one let's take a look at that a

00:29:29,790 --> 00:29:40,520
little closer there is the backslash

00:29:33,180 --> 00:29:43,500
uppercase X I'm reg ex a character and

00:29:40,520 --> 00:29:47,250
it has been around for a while now I

00:29:43,500 --> 00:29:51,990
think since Pearl 58 actually but it has

00:29:47,250 --> 00:29:55,320
I sort of improved a lot over I several

00:29:51,990 --> 00:29:57,380
releases and I'm unfortunately up until

00:29:55,320 --> 00:29:59,550
I think pearl 512 you won't get

00:29:57,380 --> 00:30:01,560
consistent results with it but it's a

00:29:59,550 --> 00:30:05,810
very good character to know about

00:30:01,560 --> 00:30:13,200
because if I matches individual I

00:30:05,810 --> 00:30:16,020
graphene clusters and here I were using

00:30:13,200 --> 00:30:22,230
I forgot I've got a laser pointer on

00:30:16,020 --> 00:30:28,320
this thing I we're using the g mode I to

00:30:22,230 --> 00:30:32,570
I globally search I and putting it in

00:30:28,320 --> 00:30:34,890
list context I and then back into I

00:30:32,570 --> 00:30:36,870
scale our context in this little messy

00:30:34,890 --> 00:30:39,840
not very readable here but we are

00:30:36,870 --> 00:30:42,180
getting I are counting that we have one

00:30:39,840 --> 00:30:44,130
graphene cluster so let's look at

00:30:42,180 --> 00:30:46,440
another way it also gets tricky because

00:30:44,130 --> 00:30:49,110
what if you then put it into a list

00:30:46,440 --> 00:30:50,670
contacts like you want to print or say

00:30:49,110 --> 00:30:51,780
that out you'd have to explicitly put it

00:30:50,670 --> 00:30:53,850
in scalar conduct so I wouldn't

00:30:51,780 --> 00:30:55,710
recommend doing it like that here's a

00:30:53,850 --> 00:30:58,919
little better way you know it's more

00:30:55,710 --> 00:31:02,399
readable I am really just loop

00:30:58,919 --> 00:31:06,239
through I the this reg accent counting

00:31:02,399 --> 00:31:11,850
each iteration and then you can use your

00:31:06,239 --> 00:31:14,600
I incremented number look there are some

00:31:11,850 --> 00:31:19,590
other ways that aren't part of a core

00:31:14,600 --> 00:31:23,100
pearl here we but i use unicode a GC

00:31:19,590 --> 00:31:25,350
string which is unicode you see string

00:31:23,100 --> 00:31:29,279
is very nice module it stands for

00:31:25,350 --> 00:31:34,619
graphene cluster string and I here we

00:31:29,279 --> 00:31:39,049
are instantiated passing our string to

00:31:34,619 --> 00:31:41,429
it now remember that this should be a

00:31:39,049 --> 00:31:44,359
pearl internal strength there shouldn't

00:31:41,429 --> 00:31:47,340
be an encoded series of bytes I

00:31:44,359 --> 00:31:49,470
generally what we want to be working on

00:31:47,340 --> 00:31:53,190
our pearl internal strength throughout

00:31:49,470 --> 00:31:55,499
our body of code I because we decode on

00:31:53,190 --> 00:31:57,809
input and code on output everything

00:31:55,499 --> 00:32:00,119
we're doing within our code base that's

00:31:57,809 --> 00:32:04,769
in between that is on pearl internal

00:32:00,119 --> 00:32:09,330
strings and then we're calling the

00:32:04,769 --> 00:32:10,999
length a method and getting one back for

00:32:09,330 --> 00:32:13,619
this example we've been working on I

00:32:10,999 --> 00:32:16,980
here's another module it's Unicode you

00:32:13,619 --> 00:32:19,499
till I in a warning it's my module I so

00:32:16,980 --> 00:32:24,210
it's still a work in progress but I use

00:32:19,499 --> 00:32:28,639
it a lot I'm and it provides the graph

00:32:24,210 --> 00:32:28,639
length function I'm

00:32:33,630 --> 00:32:53,670
so any questions on the on the topic so

00:32:38,020 --> 00:32:58,300
far Rick so I'm which one are you so I'm

00:32:53,670 --> 00:33:16,420
0 with characters as far as a graphing

00:32:58,300 --> 00:33:36,880
clusters gum yep I think I'm well length

00:33:16,420 --> 00:33:40,180
cap no I'm not in this talk because

00:33:36,880 --> 00:33:41,710
there's so much that I we can talk about

00:33:40,180 --> 00:33:42,910
unicode we could have a unicode

00:33:41,710 --> 00:33:45,790
conference in fact there is one it's

00:33:42,910 --> 00:33:50,290
three days as well I and tom kristensen

00:33:45,790 --> 00:33:53,080
is going to be giving a unicode reg axes

00:33:50,290 --> 00:33:57,010
talk tomorrow i think that's two hours

00:33:53,080 --> 00:33:58,420
I'm so double the time more than double

00:33:57,010 --> 00:34:00,850
the time than I have and it's just for

00:33:58,420 --> 00:34:03,550
reg axes I'm looking forward to it I I

00:34:00,850 --> 00:34:05,230
hope to see many of you there so I'm not

00:34:03,550 --> 00:34:08,340
going to go deep into reg axes because

00:34:05,230 --> 00:34:08,340
he's covering that

00:34:55,640 --> 00:35:02,380
so the for those who can't hear the

00:34:58,340 --> 00:35:05,930
discussion is about you know various I

00:35:02,380 --> 00:35:09,220
eastern and non-latin based languages

00:35:05,930 --> 00:35:14,510
that do various forms of character

00:35:09,220 --> 00:35:16,490
stacking I and in I we really have to go

00:35:14,510 --> 00:35:19,730
in a case-by-case basis to look at it

00:35:16,490 --> 00:35:22,100
but generally I these are individual

00:35:19,730 --> 00:35:24,440
graphemes when you combine characters

00:35:22,100 --> 00:35:27,680
together I that are stacked on top of

00:35:24,440 --> 00:35:32,960
each other or have diacritics on under

00:35:27,680 --> 00:35:36,650
out or either side of them so let's get

00:35:32,960 --> 00:35:39,230
into collation I collation is a standard

00:35:36,650 --> 00:35:47,060
ordering of strings for comparison and

00:35:39,230 --> 00:35:49,790
sorting I'm in so there are a lot of

00:35:47,060 --> 00:35:54,440
different collation I standards out

00:35:49,790 --> 00:35:57,200
there I'm uses of collation are you know

00:35:54,440 --> 00:35:59,450
sorting I your various comparison

00:35:57,200 --> 00:36:03,230
operators like compare greater than less

00:35:59,450 --> 00:36:07,610
than I you know string equals now in

00:36:03,230 --> 00:36:11,600
Perl its built-in collation is just

00:36:07,610 --> 00:36:14,690
based on code points which means very

00:36:11,600 --> 00:36:17,630
little in a natural language point of

00:36:14,690 --> 00:36:21,800
view because code points aren't ordered

00:36:17,630 --> 00:36:24,050
in any way I other than you know with a

00:36:21,800 --> 00:36:26,270
to z in order but they aren't ordered in

00:36:24,050 --> 00:36:28,220
any way to do with natural language it's

00:36:26,270 --> 00:36:31,060
just here we need more characters will

00:36:28,220 --> 00:36:34,910
assign them another code point I'm the

00:36:31,060 --> 00:36:37,640
only thing with pearls default collation

00:36:34,910 --> 00:36:40,640
the only thing it's really good for is

00:36:37,640 --> 00:36:45,470
having a standard sort order that will

00:36:40,640 --> 00:36:49,700
be the same every time but say we've got

00:36:45,470 --> 00:36:54,890
these words here we've got a Apfel with

00:36:49,700 --> 00:36:58,460
a you know or a with guerra says I say

00:36:54,890 --> 00:37:02,330
we use the default I pearl sort for this

00:36:58,460 --> 00:37:05,630
we're not going to get an order that

00:37:02,330 --> 00:37:08,270
would be very useful here in fact we

00:37:05,630 --> 00:37:09,140
provided it in our ideal orders start

00:37:08,270 --> 00:37:11,180
out with and it

00:37:09,140 --> 00:37:13,640
just reversed it for us essentially and

00:37:11,180 --> 00:37:16,670
that's because I you know in in this

00:37:13,640 --> 00:37:18,579
example we're not taking case into

00:37:16,670 --> 00:37:20,480
consideration so considering that

00:37:18,579 --> 00:37:23,900
different cases are different code

00:37:20,480 --> 00:37:26,900
points I we have our upper case I first

00:37:23,900 --> 00:37:38,569
then our lower case and then our various

00:37:26,900 --> 00:37:43,579
non-ascii characters yes yes yep so

00:37:38,569 --> 00:37:48,950
we'll get into normal forms next now the

00:37:43,579 --> 00:37:53,660
traditional a pearl way of dealing with

00:37:48,950 --> 00:37:58,130
this is to pass a block to sort I'm and

00:37:53,660 --> 00:38:01,069
then I take your value a and value B I

00:37:58,130 --> 00:38:02,839
in either lowercase or uppercase both of

00:38:01,069 --> 00:38:05,599
them well that helps out a little bit at

00:38:02,839 --> 00:38:07,160
least as ursus doesn't come after durian

00:38:05,599 --> 00:38:10,789
in our example but still that doesn't

00:38:07,160 --> 00:38:14,029
help out with our non-ascii characters

00:38:10,789 --> 00:38:16,099
here and even even when we're just

00:38:14,029 --> 00:38:19,339
talking about ASCII characters it

00:38:16,099 --> 00:38:21,769
doesn't necessarily make sense as far as

00:38:19,339 --> 00:38:25,970
where the various punctuation and such I

00:38:21,769 --> 00:38:30,890
is organized I'm now I'd like to point

00:38:25,970 --> 00:38:35,000
out that I'm pearl 516 has a new FC

00:38:30,890 --> 00:38:37,880
function for full case as well as if you

00:38:35,000 --> 00:38:39,799
don't have the privilege of using 516

00:38:37,880 --> 00:38:44,089
which I imagine very few of us do at

00:38:39,799 --> 00:38:45,799
work there's the Unicode fold case

00:38:44,089 --> 00:38:49,490
module in Sipan that will provide the

00:38:45,799 --> 00:38:52,099
function for you anyway I I'd say from

00:38:49,490 --> 00:38:56,150
this point forward it is the preferred

00:38:52,099 --> 00:39:00,849
way I to do this last example instead of

00:38:56,150 --> 00:39:06,140
LC or FC use FC because there are

00:39:00,849 --> 00:39:09,980
characters like I'm the German sharp s

00:39:06,140 --> 00:39:14,180
that when capitalized are uppercase s

00:39:09,980 --> 00:39:16,670
uppercase s and I that doesn't represent

00:39:14,180 --> 00:39:20,390
very well for comparison so FC will

00:39:16,670 --> 00:39:22,789
handle that well so anyway I let's get

00:39:20,390 --> 00:39:25,789
into the Unicode collation Elgar

00:39:22,789 --> 00:39:32,289
which is a part of the unicode standard

00:39:25,789 --> 00:39:35,630
and it is a very smart way of I

00:39:32,289 --> 00:39:48,229
providing collation based on the world's

00:39:35,630 --> 00:39:50,660
languages so the my slides okay so sorry

00:39:48,229 --> 00:39:54,589
there's an error on the side slide

00:39:50,660 --> 00:39:58,689
ignore colon colon locale on the slide

00:39:54,589 --> 00:40:03,349
so anyway if you use the Unicode collate

00:39:58,689 --> 00:40:07,309
module I'm instantiate instantiate your

00:40:03,349 --> 00:40:12,589
Co later I it provides a variety of

00:40:07,309 --> 00:40:15,469
methods based on the pearl core

00:40:12,589 --> 00:40:17,239
functions but we'll use the Unicode

00:40:15,469 --> 00:40:19,309
collation algorithm so here we're

00:40:17,239 --> 00:40:23,119
calling the sort method and passing a

00:40:19,309 --> 00:40:26,269
list to it and we get a result that we'd

00:40:23,119 --> 00:40:31,159
like here I with the a with the RSS

00:40:26,269 --> 00:40:34,640
coming first and I it has methods for

00:40:31,159 --> 00:40:36,140
all of the examples I showed earlier as

00:40:34,640 --> 00:40:37,939
well as the ones that I haven't showed

00:40:36,140 --> 00:40:41,509
that are included in Perl core here sort

00:40:37,939 --> 00:40:48,039
compare a string greater than string

00:40:41,509 --> 00:40:52,669
equality because sometimes the collation

00:40:48,039 --> 00:40:55,579
values for comparing two characters that

00:40:52,669 --> 00:41:04,099
are two different code points can be

00:40:55,579 --> 00:41:07,209
equals now the uca although it has a

00:41:04,099 --> 00:41:09,589
default collation algorithm which is a

00:41:07,209 --> 00:41:12,169
I'd said the default one you should use

00:41:09,589 --> 00:41:14,779
if you don't know what to do otherwise

00:41:12,169 --> 00:41:17,329
it's very smart and it and if you've got

00:41:14,779 --> 00:41:19,249
mixed data from multiple different

00:41:17,329 --> 00:41:21,890
languages really that's the way to go

00:41:19,249 --> 00:41:25,699
now if you're using it take a look at

00:41:21,890 --> 00:41:27,859
the pearl talk I because there are a lot

00:41:25,699 --> 00:41:30,249
of options just had to it it's highly

00:41:27,859 --> 00:41:30,249
configurable

00:41:33,060 --> 00:41:40,630
so I LC is unicode aware but I it is not

00:41:38,890 --> 00:41:43,930
good for comparison when you're taking

00:41:40,630 --> 00:41:46,180
two strings to compare a full case

00:41:43,930 --> 00:41:52,270
folding provided by FC is the ideal way

00:41:46,180 --> 00:41:54,970
to go so say we want a Polish coalition

00:41:52,270 --> 00:41:57,820
which I you know the default you see a

00:41:54,970 --> 00:41:59,800
algorithm isn't going to provide

00:41:57,820 --> 00:42:02,670
collation for every single language

00:41:59,800 --> 00:42:06,340
exactly how they do in the country I

00:42:02,670 --> 00:42:08,980
that uses that language so if you use

00:42:06,340 --> 00:42:12,450
unicode collate locale really using

00:42:08,980 --> 00:42:17,070
double colon locale this time I and

00:42:12,450 --> 00:42:20,380
provide I the I either the length

00:42:17,070 --> 00:42:23,130
two-digit language code or a locale

00:42:20,380 --> 00:42:26,650
based on the language code underscore a

00:42:23,130 --> 00:42:31,510
country code I if it's one of the

00:42:26,650 --> 00:42:34,210
available I locales it will I provide

00:42:31,510 --> 00:42:36,550
collation tailored specifically to that

00:42:34,210 --> 00:42:44,590
language or that language at that

00:42:36,550 --> 00:42:48,400
country and I yes that's a very good

00:42:44,590 --> 00:42:54,490
point I Unicode collate locale and then

00:42:48,400 --> 00:43:03,790
Unicode collate locale new now we'll get

00:42:54,490 --> 00:43:05,860
it a normalization yes right so Germans

00:43:03,790 --> 00:43:07,540
a good example there because the

00:43:05,860 --> 00:43:09,910
dictionary ordering of German is

00:43:07,540 --> 00:43:15,880
different than the phone book ordering

00:43:09,910 --> 00:43:17,050
of German I'm so with I the dr SS or we

00:43:15,880 --> 00:43:19,270
can call it umlaut here because we

00:43:17,050 --> 00:43:26,050
actually are talking about German I am

00:43:19,270 --> 00:43:28,900
with the site Oh umlaut I'm that is I

00:43:26,050 --> 00:43:33,550
generally considered to be equivalent to

00:43:28,900 --> 00:43:38,110
OE and I should be collated as if it was

00:43:33,550 --> 00:43:42,430
Oh a but it differs in phonebook usage

00:43:38,110 --> 00:43:44,250
so there's actually a de for german i

00:43:42,430 --> 00:43:47,730
underscore

00:43:44,250 --> 00:43:49,920
book I locale and there's some there's

00:43:47,730 --> 00:44:01,280
several specialized ones available I

00:43:49,920 --> 00:44:06,210
with the uca so unicode provides for I

00:44:01,280 --> 00:44:09,480
normalization forms I the most important

00:44:06,210 --> 00:44:11,580
ones to know about our NFD which is

00:44:09,480 --> 00:44:13,740
normalization form canonical

00:44:11,580 --> 00:44:17,570
decomposition and I apologize it's it's

00:44:13,740 --> 00:44:21,660
a mouthful I am i'll just refer to NFD

00:44:17,570 --> 00:44:28,020
then there's NFC I normalization form

00:44:21,660 --> 00:44:30,950
canonical composition so I'm the reason

00:44:28,020 --> 00:44:35,870
we have these normalization forms is

00:44:30,950 --> 00:44:40,280
because I mentioned I how you can have

00:44:35,870 --> 00:44:45,120
combining code points say you had I'm

00:44:40,280 --> 00:44:49,260
your precomposed code point for a with

00:44:45,120 --> 00:44:52,890
DSS you could also have a followed by

00:44:49,260 --> 00:44:54,780
combining the arss and we would want to

00:44:52,890 --> 00:44:56,490
consider those to be the same thing as

00:44:54,780 --> 00:44:58,980
far as collation goes you know

00:44:56,490 --> 00:45:02,760
comparison that should be the same thing

00:44:58,980 --> 00:45:05,100
I'm well normalization will put them in

00:45:02,760 --> 00:45:10,140
the same form consistently you could

00:45:05,100 --> 00:45:13,860
also have a series of combining code

00:45:10,140 --> 00:45:17,040
points I and some of them may not

00:45:13,860 --> 00:45:19,590
compose onto I may not have precomposed

00:45:17,040 --> 00:45:22,680
forms on to your base character but you

00:45:19,590 --> 00:45:25,410
want to them to be in a consistent order

00:45:22,680 --> 00:45:30,630
I'm well normalization is the way to go

00:45:25,410 --> 00:45:33,960
so I o NF d for decomposition will make

00:45:30,630 --> 00:45:36,990
it in I break it out into the longest

00:45:33,960 --> 00:45:39,270
form possible so if you have your

00:45:36,990 --> 00:45:41,640
precomposed a with dr says it will break

00:45:39,270 --> 00:45:45,590
that up into two code points a followed

00:45:41,640 --> 00:45:50,430
by combining guerra says I whereas the

00:45:45,590 --> 00:45:54,150
NFC canonical composition will first run

00:45:50,430 --> 00:45:57,670
NFD it will decompose it into your

00:45:54,150 --> 00:46:08,049
standard decomposed form and then

00:45:57,670 --> 00:46:12,400
it will recompose it yes NFC is the is

00:46:08,049 --> 00:46:20,910
short shortest NFD is longest but FD is

00:46:12,400 --> 00:46:25,420
always run in order to get to NFC so I

00:46:20,910 --> 00:46:28,480
NFD can be helpful on input I generally

00:46:25,420 --> 00:46:31,990
just standardizing on input is a good

00:46:28,480 --> 00:46:33,700
idea there isn't any like one where this

00:46:31,990 --> 00:46:37,150
is what you need to use it's all on a

00:46:33,700 --> 00:46:40,240
case-by-case basis but NFD I can be

00:46:37,150 --> 00:46:43,809
helpful I input because then say you

00:46:40,240 --> 00:46:50,200
could use a reg ex matroix against your

00:46:43,809 --> 00:46:56,829
string where you I want to say find I'm

00:46:50,200 --> 00:46:59,530
o followed by 0 in any of its forms well

00:46:56,829 --> 00:47:02,190
then when you have d you're a decomposed

00:46:59,530 --> 00:47:05,470
string you will always have your

00:47:02,190 --> 00:47:08,380
individual code point 4 0 chi 0 followed

00:47:05,470 --> 00:47:12,190
by your combining code points so you

00:47:08,380 --> 00:47:15,970
could do a positive look ahead 40 in

00:47:12,190 --> 00:47:19,720
your reg ex followed by some say

00:47:15,970 --> 00:47:23,559
backslash uppercase X and that will

00:47:19,720 --> 00:47:26,980
match any graphene cluster that is based

00:47:23,559 --> 00:47:30,930
on oh I'm if you don't need to do stuff

00:47:26,980 --> 00:47:34,809
like that feel free to use I NFC on

00:47:30,930 --> 00:47:36,460
input now for output NFC is especially

00:47:34,809 --> 00:47:39,130
recommended there are various protocols

00:47:36,460 --> 00:47:42,910
that recommend that you use NFC on

00:47:39,130 --> 00:47:45,010
output I their reasons our one it takes

00:47:42,910 --> 00:47:46,839
up less space but to it has the best

00:47:45,010 --> 00:47:49,569
support in applications you want to make

00:47:46,839 --> 00:47:50,829
sure your web browsers and and email

00:47:49,569 --> 00:47:53,680
clients and such can support the

00:47:50,829 --> 00:47:56,589
characters and well most applications

00:47:53,680 --> 00:47:58,240
don't have full unicode support or even

00:47:56,589 --> 00:48:00,670
very much of the unicode support that

00:47:58,240 --> 00:48:04,660
was introduced in the last decade I so

00:48:00,670 --> 00:48:07,210
your best bet for working along on many

00:48:04,660 --> 00:48:11,530
different devices and browsers is to

00:48:07,210 --> 00:48:13,600
output composed this is

00:48:11,530 --> 00:48:16,570
still done on your pearl internal

00:48:13,600 --> 00:48:18,520
strength so any NFD and I've see any

00:48:16,570 --> 00:48:23,710
normalization you're doing after you

00:48:18,520 --> 00:48:27,990
decode before you encode here is the

00:48:23,710 --> 00:48:32,110
order I so utf-8 encoded input decode it

00:48:27,990 --> 00:48:35,260
normalize it I then you're working with

00:48:32,110 --> 00:48:37,420
your perl code I normalize it in the

00:48:35,260 --> 00:48:40,960
form you want to output encode it and

00:48:37,420 --> 00:48:44,050
then you've got your I utf8 encode it

00:48:40,960 --> 00:48:46,180
out put it not everyone needs to work

00:48:44,050 --> 00:48:49,890
with normalization but when you do it

00:48:46,180 --> 00:48:58,660
can be very useful for the cases that I

00:48:49,890 --> 00:49:00,850
said yes I've thought about that and I

00:48:58,660 --> 00:49:05,740
haven't seen anything like that but I

00:49:00,850 --> 00:49:09,880
it's a great idea for a module so it's

00:49:05,740 --> 00:49:11,710
if you can do a mode for a you know

00:49:09,880 --> 00:49:15,370
opening a file handle where you

00:49:11,710 --> 00:49:16,660
automatically normalize I and I haven't

00:49:15,370 --> 00:49:18,280
seen anything that does that I haven't

00:49:16,660 --> 00:49:19,480
seen any modules would that do that I've

00:49:18,280 --> 00:49:23,190
thought about it I think it's a great

00:49:19,480 --> 00:49:23,190
idea if anyone wants to work on that

00:49:28,050 --> 00:49:31,600
yeah it would be nice to have an option

00:49:30,130 --> 00:49:35,050
even if it's I mean not necessarily

00:49:31,600 --> 00:49:36,550
built in but a Sipan module so anyway

00:49:35,050 --> 00:49:37,600
I'm going to I'm going to finish up my

00:49:36,550 --> 00:49:42,520
slides because we're running out of time

00:49:37,600 --> 00:49:44,380
here and then get on to questions I I

00:49:42,520 --> 00:49:47,710
only have a few side left by the way I

00:49:44,380 --> 00:49:51,490
owe some I unicode semantics I by

00:49:47,710 --> 00:49:53,500
default unfortunately I strings and reg

00:49:51,490 --> 00:49:54,460
axes are not guaranteed to use unicode

00:49:53,500 --> 00:49:57,220
semantics and that's because

00:49:54,460 --> 00:50:01,210
traditionally latin one was the default

00:49:57,220 --> 00:50:02,880
not utf-8 I'm and this is known as the

00:50:01,210 --> 00:50:06,190
Unicode bug because you can have

00:50:02,880 --> 00:50:08,590
inconsistent results I there are a few

00:50:06,190 --> 00:50:11,110
ways to fix that one of them is calling

00:50:08,590 --> 00:50:12,820
utf-8 upgrade you can call it multiple

00:50:11,110 --> 00:50:14,560
times and it's not going to like do

00:50:12,820 --> 00:50:16,900
multiple upgrades that will break your

00:50:14,560 --> 00:50:19,660
data but it will make sure that your

00:50:16,900 --> 00:50:24,040
pearl internal string is using Unicode

00:50:19,660 --> 00:50:25,329
semantics so for example when you've got

00:50:24,040 --> 00:50:27,579
unicode semantics

00:50:25,329 --> 00:50:29,410
back /w will treat it as Unicode it

00:50:27,579 --> 00:50:33,309
won't just match ask it will match all

00:50:29,410 --> 00:50:36,219
Unicode alphanumerics as well I Unicode

00:50:33,309 --> 00:50:37,869
digits for backslash d that might not be

00:50:36,219 --> 00:50:40,749
what you want so you might want to be

00:50:37,869 --> 00:50:48,690
more explicit and use a character class

00:50:40,749 --> 00:50:51,549
0 through 9 when you use a pearl 512

00:50:48,690 --> 00:50:53,650
that will make sure that all of your

00:50:51,549 --> 00:50:57,489
strings are using Unicode semantics I'm

00:50:53,650 --> 00:50:59,979
and the feature for from the feature

00:50:57,489 --> 00:51:02,079
pragma Unicode strings is provided as a

00:50:59,979 --> 00:51:03,789
512 if you don't want to use all the

00:51:02,079 --> 00:51:07,989
features of 512 but you can only use

00:51:03,789 --> 00:51:10,809
this 512 and later then I mentioned I

00:51:07,989 --> 00:51:14,289
was going to get into uppercase UTF dash

00:51:10,809 --> 00:51:17,079
8 verses the lowercase utf-8 without a

00:51:14,289 --> 00:51:19,930
dash I this is a confusing issue you see

00:51:17,079 --> 00:51:22,269
a lot of people using both of these but

00:51:19,930 --> 00:51:26,759
they're different I both of them are

00:51:22,269 --> 00:51:30,579
implementations of utf-8 I the lowercase

00:51:26,759 --> 00:51:34,989
utf-8 I without a dash is very lenient

00:51:30,579 --> 00:51:38,259
it will allow errors in your utf-8 data

00:51:34,989 --> 00:51:41,759
where you will have incorrect I Unicode

00:51:38,259 --> 00:51:47,160
data in your pearl internal string I'm

00:51:41,759 --> 00:51:52,029
whereas uppercase utf-8 is a strict

00:51:47,160 --> 00:51:55,059
interpretation of utf-8 and it will not

00:51:52,029 --> 00:51:57,729
allow a you know invalid Unicode data

00:51:55,059 --> 00:52:00,190
and said it will warn and it will

00:51:57,729 --> 00:52:03,969
replace that with you know valid

00:52:00,190 --> 00:52:06,459
placeholders just beware that it will

00:52:03,969 --> 00:52:08,529
change your data when you encode I mean

00:52:06,459 --> 00:52:12,400
when you decode and then encode using

00:52:08,529 --> 00:52:14,469
uppercase UTF shape and you have invalid

00:52:12,400 --> 00:52:15,670
data I it will change it and you won't

00:52:14,469 --> 00:52:18,999
have the same output in the end I

00:52:15,670 --> 00:52:24,009
generally recommend uppercase utf-8

00:52:18,999 --> 00:52:29,900
though and that's what I use yes what's

00:52:24,009 --> 00:52:32,160
that oh this is a pearl thing

00:52:29,900 --> 00:52:35,519
this is just for like encoding and

00:52:32,160 --> 00:52:38,400
decoding in Perl anywhere that you would

00:52:35,519 --> 00:52:42,690
list your encoding whether it's at the

00:52:38,400 --> 00:52:45,479
top of your pod or anywhere not use

00:52:42,690 --> 00:52:47,099
because the UTA lowercase u TF it in

00:52:45,479 --> 00:52:50,609
there a lot of confusion here lowercase

00:52:47,099 --> 00:52:53,160
utf-8 pragma is a named pragma I feel

00:52:50,609 --> 00:52:55,289
free to use that you know use utf-8 all

00:52:53,160 --> 00:53:07,859
lowercase no dashes that's fine that's a

00:52:55,289 --> 00:53:09,900
named pragma I'm not sure about that so

00:53:07,859 --> 00:53:13,349
the question is is there a way to

00:53:09,900 --> 00:53:15,450
specify if your pearl source code is

00:53:13,349 --> 00:53:18,479
treated as if it was you know uppercase

00:53:15,450 --> 00:53:26,359
utf-8 or lower gates utf-8 I imagine

00:53:18,479 --> 00:53:26,359
it's UTA you lowercase utf-8 but yeah

00:53:26,869 --> 00:53:38,449
but I mean you could have it in a string

00:53:32,569 --> 00:53:38,449
you know in a constant so anyway I'm

00:53:40,309 --> 00:54:01,529
anywhere that I hear examples of where

00:53:43,079 --> 00:54:04,199
you could use either form yeah that's

00:54:01,529 --> 00:54:10,920
that's a good point you can change how I

00:54:04,199 --> 00:54:14,009
you're strict a utf-8 works I so instead

00:54:10,920 --> 00:54:16,769
of doing warnings you can I you can

00:54:14,009 --> 00:54:19,259
specify that it's fatal or there are

00:54:16,769 --> 00:54:21,269
other ways that you can specify what

00:54:19,259 --> 00:54:24,029
it's replaced with but that's a little

00:54:21,269 --> 00:54:26,069
more than we have time for here i'm

00:54:24,029 --> 00:54:34,380
going to post the slides on twitter and

00:54:26,069 --> 00:54:37,109
on my website any questions excellent

00:54:34,380 --> 00:54:39,479
yeah i'll be here for the rest of the

00:54:37,109 --> 00:54:40,829
week so feel free to come and find me

00:54:39,479 --> 00:54:41,680
with any questions i do you have

00:54:40,829 --> 00:54:44,829
something

00:54:41,680 --> 00:54:48,869
to comment about when you use that NFC

00:54:44,829 --> 00:54:48,869
and nmd that's an example where the

00:54:54,869 --> 00:55:09,819
eight Unicode kool-aid or unicode GC

00:54:57,760 --> 00:55:12,329
string yeah utf-8 all yep okay well

00:55:09,819 --> 00:55:12,329

YouTube URL: https://www.youtube.com/watch?v=iaoAXozGGHA


