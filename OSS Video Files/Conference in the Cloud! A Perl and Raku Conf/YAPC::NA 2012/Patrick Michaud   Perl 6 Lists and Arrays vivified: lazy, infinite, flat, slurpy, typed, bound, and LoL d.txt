Title: Patrick Michaud   Perl 6 Lists and Arrays vivified: lazy, infinite, flat, slurpy, typed, bound, and LoL d
Publication date: 2013-08-20
Playlist: YAPC::NA 2012
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:05,009
so already well I have that it's 331 so

00:00:02,879 --> 00:00:06,930
I will go ahead and start my name is

00:00:05,009 --> 00:00:10,230
Patrick me show and I'm the leader of

00:00:06,930 --> 00:00:12,030
the recruiter Perl 6 project and have

00:00:10,230 --> 00:00:16,350
been working on it for more years than I

00:00:12,030 --> 00:00:18,420
care to name and my talk today is on

00:00:16,350 --> 00:00:19,770
Perl 6 lists and arrays and kind of

00:00:18,420 --> 00:00:21,660
describing how they work in the things

00:00:19,770 --> 00:00:23,279
we've learned in going through and

00:00:21,660 --> 00:00:24,779
implementing them as I go through the

00:00:23,279 --> 00:00:26,430
talk if you have questions feel free to

00:00:24,779 --> 00:00:29,160
raise your hand or shout them out at me

00:00:26,430 --> 00:00:33,960
I will handle them in line as best I can

00:00:29,160 --> 00:00:36,270
and try and do that because the this

00:00:33,960 --> 00:00:37,920
talk is it's got a lot of information in

00:00:36,270 --> 00:00:39,930
it but I'm not quite certain of the

00:00:37,920 --> 00:00:42,239
order of presentation yet so I'll be

00:00:39,930 --> 00:00:44,160
figuring that out as we go this of

00:00:42,239 --> 00:00:50,070
course is our wonderful Perl 6 logo hi

00:00:44,160 --> 00:00:51,120
camellia alrighty so what are we going

00:00:50,070 --> 00:00:53,010
to be covering I'm just doing their

00:00:51,120 --> 00:00:55,530
listen race today hashes is from a

00:00:53,010 --> 00:00:56,699
previous version of this talk of course

00:00:55,530 --> 00:00:59,039
as you know if you've been programming

00:00:56,699 --> 00:01:00,600
pearl for any length of time lists are

00:00:59,039 --> 00:01:02,820
just a fundamental part of being pearl

00:01:00,600 --> 00:01:03,899
ish in fact one of the things that I

00:01:02,820 --> 00:01:05,420
liked about pearl when I first

00:01:03,899 --> 00:01:08,220
encountered it is that it had good

00:01:05,420 --> 00:01:10,350
support for lists as a basic data type

00:01:08,220 --> 00:01:12,990
much better than all the other languages

00:01:10,350 --> 00:01:14,640
i was being chained to at the time there

00:01:12,990 --> 00:01:16,830
are some significant changes in Perl 6

00:01:14,640 --> 00:01:19,049
over pro/5 so first of all lists in Perl

00:01:16,830 --> 00:01:21,420
6 are lazy they can be infinite in

00:01:19,049 --> 00:01:25,680
length and we have some new list context

00:01:21,420 --> 00:01:26,970
that are being used in various places so

00:01:25,680 --> 00:01:30,270
I'll be going through some of those

00:01:26,970 --> 00:01:33,329
today whatever I don't get to today will

00:01:30,270 --> 00:01:35,490
be in my talk I'm giving tomorrow so I'm

00:01:33,329 --> 00:01:37,200
going to go at whatever speed seems

00:01:35,490 --> 00:01:39,420
appropriate for the stuff I think I have

00:01:37,200 --> 00:01:43,350
more than 40 40 or 50 minutes worth of

00:01:39,420 --> 00:01:44,790
material so if you have something that

00:01:43,350 --> 00:01:46,020
doesn't make sense to you or that you

00:01:44,790 --> 00:01:47,520
have a question about that you'd like to

00:01:46,020 --> 00:01:49,500
learn more about you can tell me about

00:01:47,520 --> 00:01:51,299
it either in the question section of

00:01:49,500 --> 00:01:53,430
this talk or between now and tomorrow

00:01:51,299 --> 00:01:54,630
and I'll cover it in tomorrow's talk but

00:01:53,430 --> 00:01:59,399
that'll be at one-thirty tomorrow in the

00:01:54,630 --> 00:02:02,009
same room so first of all about lists in

00:01:59,399 --> 00:02:04,979
Perl 6 I have lots of experience with

00:02:02,009 --> 00:02:08,849
perl 6 lists and arrays and of course

00:02:04,979 --> 00:02:10,440
experience the the standard line that i

00:02:08,849 --> 00:02:11,160
have about experience is good judgment

00:02:10,440 --> 00:02:12,270
comes from experience

00:02:11,160 --> 00:02:15,720
anson experience comes from bad

00:02:12,270 --> 00:02:18,030
judgement I have lots of experience and

00:02:15,720 --> 00:02:20,640
I have lots of bad experience with lists

00:02:18,030 --> 00:02:22,110
and arrays Ricou dough itself has gone

00:02:20,640 --> 00:02:24,510
through at least five separate

00:02:22,110 --> 00:02:28,320
implementations of lists and arrays in

00:02:24,510 --> 00:02:29,400
its multi-year lifetime and the reason

00:02:28,320 --> 00:02:31,380
is is because we would do an

00:02:29,400 --> 00:02:33,090
implementation and we would put it in

00:02:31,380 --> 00:02:35,220
and then we would discover oh that

00:02:33,090 --> 00:02:37,230
doesn't really work well we'll have to

00:02:35,220 --> 00:02:39,450
go back and fix it and unfortunately as

00:02:37,230 --> 00:02:41,340
I said since lists are so fundamental to

00:02:39,450 --> 00:02:43,320
being pearl ish changing the list

00:02:41,340 --> 00:02:44,910
implementation usually necessitated

00:02:43,320 --> 00:02:47,460
ripping out large parts of recruited ode

00:02:44,910 --> 00:02:50,640
starting over so it's been a pain I'm

00:02:47,460 --> 00:02:53,670
hoping there won't be a six I'm fearful

00:02:50,640 --> 00:02:55,860
that their will there have been many

00:02:53,670 --> 00:02:57,990
many synopsis changes now the synopses

00:02:55,860 --> 00:03:00,170
in Perl 6 are kind of the specification

00:02:57,990 --> 00:03:03,060
documents that the plan for perl 6 and

00:03:00,170 --> 00:03:05,280
the parts that deal with lists have

00:03:03,060 --> 00:03:08,280
changed almost as much as the parts

00:03:05,280 --> 00:03:09,960
dealing with reg axis so it's gone

00:03:08,280 --> 00:03:11,250
through several major reef actors that

00:03:09,960 --> 00:03:15,810
of course the implementations have to

00:03:11,250 --> 00:03:17,130
keep up with so the list specifications

00:03:15,810 --> 00:03:18,780
if you go and look at them and want to

00:03:17,130 --> 00:03:20,010
learn all about lists then you can go

00:03:18,780 --> 00:03:21,600
look at the synopses and it says

00:03:20,010 --> 00:03:23,670
synopses seven and eight describe lists

00:03:21,600 --> 00:03:27,060
and iterators and currently is today

00:03:23,670 --> 00:03:28,530
they are wrong they are very wrong if

00:03:27,060 --> 00:03:30,900
you read them you will be completely

00:03:28,530 --> 00:03:33,120
confused so don't read them I mean

00:03:30,900 --> 00:03:35,459
really don't do it you've been warned

00:03:33,120 --> 00:03:38,250
don't go read them because it will throw

00:03:35,459 --> 00:03:40,230
you off the version that is out there

00:03:38,250 --> 00:03:43,200
was written about four or five years ago

00:03:40,230 --> 00:03:45,120
and it was drafted before some of the

00:03:43,200 --> 00:03:47,760
very fundamental pieces of even the

00:03:45,120 --> 00:03:49,739
syntax were set in stone and so it gets

00:03:47,760 --> 00:03:52,050
those wrong I'm working on the rewrite

00:03:49,739 --> 00:03:55,380
I'm been working on the rewrite for

00:03:52,050 --> 00:03:56,610
about 15 months now and based on some

00:03:55,380 --> 00:03:58,050
work I did this last month I actually

00:03:56,610 --> 00:03:59,370
think I'll be able to get much farther

00:03:58,050 --> 00:04:01,709
along in it over the next couple of

00:03:59,370 --> 00:04:04,110
months so you can see it so this talk

00:04:01,709 --> 00:04:06,090
understood provides the most current

00:04:04,110 --> 00:04:08,670
understanding of the spec as it will be

00:04:06,090 --> 00:04:10,739
when it's written so it's definitely not

00:04:08,670 --> 00:04:12,510
written on what you'll find there so

00:04:10,739 --> 00:04:14,130
some basics this is some basic Perl 6

00:04:12,510 --> 00:04:17,520
stuff for people who are not familiar

00:04:14,130 --> 00:04:19,530
with pearl 6i arrays if you want to

00:04:17,520 --> 00:04:20,820
create in a way of words then you can

00:04:19,530 --> 00:04:23,340
just declare the array and give it a

00:04:20,820 --> 00:04:24,600
list the sharp angle brackets there

00:04:23,340 --> 00:04:26,940
that's the same as q

00:04:24,600 --> 00:04:29,460
w and pearl five so it just gives you

00:04:26,940 --> 00:04:31,800
all of the words of strings separated by

00:04:29,460 --> 00:04:35,190
white space so this gives us a nice list

00:04:31,800 --> 00:04:36,810
of five words if you're wondering why I

00:04:35,190 --> 00:04:39,060
chose fruit all my computers are named

00:04:36,810 --> 00:04:42,210
after fruits so this is my list of

00:04:39,060 --> 00:04:43,950
machines that I have at the house so

00:04:42,210 --> 00:04:45,480
simply say words and it will give you

00:04:43,950 --> 00:04:48,390
print out the list of words that's in

00:04:45,480 --> 00:04:49,650
the array and just like in Perl 5 you

00:04:48,390 --> 00:04:51,060
can index into the array to get a

00:04:49,650 --> 00:04:52,950
specific element so if i want the

00:04:51,060 --> 00:04:55,260
element at index 2 I just put brackets

00:04:52,950 --> 00:04:56,820
to after it and put it out one thing to

00:04:55,260 --> 00:04:59,040
note that it's different from Pearl 5 is

00:04:56,820 --> 00:05:01,200
that the sigil doesn't change that is

00:04:59,040 --> 00:05:02,970
the sigil goes along with the variable

00:05:01,200 --> 00:05:05,700
name and not with the type of thing that

00:05:02,970 --> 00:05:07,020
you're trying to return so now if you

00:05:05,700 --> 00:05:11,550
say at words that's the name of the

00:05:07,020 --> 00:05:13,470
variable and it stays consistent you can

00:05:11,550 --> 00:05:14,640
do slicing same as in Perl 5 so if I

00:05:13,470 --> 00:05:16,530
just want to get the even-numbered out

00:05:14,640 --> 00:05:18,030
elements out of this array then you just

00:05:16,530 --> 00:05:19,710
give a list of indices that you want to

00:05:18,030 --> 00:05:24,920
grab and it will go and grab them

00:05:19,710 --> 00:05:24,920
individually like that I'm sorry what

00:05:25,370 --> 00:05:34,850
yes correct I'll fix that after the talk

00:05:31,580 --> 00:05:37,350
okay for doing operations on the arrays

00:05:34,850 --> 00:05:38,820
most of the functional forms that are

00:05:37,350 --> 00:05:40,380
used to from pearl five are still there

00:05:38,820 --> 00:05:42,090
so if I want to know how many elements

00:05:40,380 --> 00:05:43,920
are they in the array I can just do

00:05:42,090 --> 00:05:45,300
Elam's in the name of the array and say

00:05:43,920 --> 00:05:46,800
it and it tells me there's five elements

00:05:45,300 --> 00:05:48,390
if I want to pop an element from an

00:05:46,800 --> 00:05:50,700
array I can do that with the pop keyword

00:05:48,390 --> 00:05:53,580
or the pop function and put it into a

00:05:50,700 --> 00:05:55,140
variable generally when I'm writing and

00:05:53,580 --> 00:05:58,350
working with arrays i prefer the method

00:05:55,140 --> 00:05:59,790
call form now in which you put Elam's so

00:05:58,350 --> 00:06:01,410
that means invoke this method on this

00:05:59,790 --> 00:06:03,300
particular object and that gives me the

00:06:01,410 --> 00:06:06,750
same sort of result I find that the

00:06:03,300 --> 00:06:08,520
method call form fits it binds tighter

00:06:06,750 --> 00:06:10,470
than the function call form and so it

00:06:08,520 --> 00:06:11,700
reads better to me but whatever you're

00:06:10,470 --> 00:06:16,050
used to using there's more than one way

00:06:11,700 --> 00:06:19,190
to use it no to do it yes you could do

00:06:16,050 --> 00:06:19,190
at words now LMK say

00:06:19,990 --> 00:06:25,840
I here's some more example so push does

00:06:23,830 --> 00:06:27,730
what you expect it to do there's a

00:06:25,840 --> 00:06:30,370
variety of ways that you can do map so

00:06:27,730 --> 00:06:31,780
you can do the map functional form where

00:06:30,370 --> 00:06:33,910
you pass a block note the comet is

00:06:31,780 --> 00:06:36,040
required that's a little bit different

00:06:33,910 --> 00:06:38,050
and then the array or you can do the

00:06:36,040 --> 00:06:40,150
method forum where you pass the block as

00:06:38,050 --> 00:06:41,350
an argument or you can do the indirect

00:06:40,150 --> 00:06:42,700
form where you pass the block is an

00:06:41,350 --> 00:06:49,060
argument like that or that's the list

00:06:42,700 --> 00:06:52,900
form and so on I'm sorry what oh is it

00:06:49,060 --> 00:06:56,590
one recruiter still has it Oh rakuten

00:06:52,900 --> 00:07:05,860
still has it what is it now or is there

00:06:56,590 --> 00:07:09,250
just no function okay okay I I missed

00:07:05,860 --> 00:07:11,830
that apparently all of us did Larry file

00:07:09,250 --> 00:07:16,240
an email to rakuyo dash bug at Pearl dot

00:07:11,830 --> 00:07:18,810
org so you can also do sort and you can

00:07:16,240 --> 00:07:21,820
do the method form of that as well

00:07:18,810 --> 00:07:24,640
arrays as most everything else that you

00:07:21,820 --> 00:07:26,500
encounter perl 6 are objects and objects

00:07:24,640 --> 00:07:28,810
can be held in scalar variables in pro 5

00:07:26,500 --> 00:07:31,360
of course we call them references in

00:07:28,810 --> 00:07:32,980
Perl 6 there are still references but we

00:07:31,360 --> 00:07:34,900
really hide the fact that their

00:07:32,980 --> 00:07:36,970
references in a lot of ways so you don't

00:07:34,900 --> 00:07:39,160
ever have to think about do I have a

00:07:36,970 --> 00:07:40,930
reference or do I have the object Perl 6

00:07:39,160 --> 00:07:43,660
kind of knows what you're wanting to do

00:07:40,930 --> 00:07:45,400
so here I'm creating an array and I'm

00:07:43,660 --> 00:07:47,290
story storing it a scalar variable

00:07:45,400 --> 00:07:48,790
dollar sign words and if I ask words

00:07:47,290 --> 00:07:50,920
what are you it tells me it's an array

00:07:48,790 --> 00:07:53,200
now a pro 5 person would say oh no

00:07:50,920 --> 00:07:54,580
that's a reference but the fact that

00:07:53,200 --> 00:07:56,350
it's a reference or just the straight

00:07:54,580 --> 00:07:57,640
object doesn't really matter much in

00:07:56,350 --> 00:07:59,170
fact you'll note I didn't have to do

00:07:57,640 --> 00:08:00,940
reference it I didn't have to use an

00:07:59,170 --> 00:08:02,320
arrow or anything like that just the dot

00:08:00,940 --> 00:08:04,660
is sufficient whether it's a reference

00:08:02,320 --> 00:08:06,850
to an object or the object itself the

00:08:04,660 --> 00:08:10,870
dot is sufficient to get your method to

00:08:06,850 --> 00:08:13,360
where you want it to go here's more

00:08:10,870 --> 00:08:14,710
examples just using that same concept so

00:08:13,360 --> 00:08:16,330
if you want a subscript you just do the

00:08:14,710 --> 00:08:18,160
subscript don't need an arrow or

00:08:16,330 --> 00:08:19,540
anything like that if you want to do a

00:08:18,160 --> 00:08:20,770
slice you just do the slice if you want

00:08:19,540 --> 00:08:23,410
to know how many elements there are you

00:08:20,770 --> 00:08:25,270
just do the thing so a lot of the the

00:08:23,410 --> 00:08:26,770
referencing syntax that pro/5 had in

00:08:25,270 --> 00:08:31,230
place you just don't ever have to deal

00:08:26,770 --> 00:08:31,230
with in Perl 6 yes

00:08:38,750 --> 00:08:43,879
the at sigil will put certain

00:08:41,519 --> 00:08:47,399
constraints on what it can be bound to

00:08:43,879 --> 00:08:48,839
and some people like to be able to use

00:08:47,399 --> 00:08:51,269
the at signal to indicate something's

00:08:48,839 --> 00:08:53,879
plural versus singular so you know but

00:08:51,269 --> 00:08:55,500
but if you wanted to completely do your

00:08:53,879 --> 00:08:56,970
program using only the dollar sign is

00:08:55,500 --> 00:09:07,189
the sigil because you really like PHP

00:08:56,970 --> 00:09:09,089
you can do it yes that has to do with

00:09:07,189 --> 00:09:11,670
I'm actually going to cover that in a

00:09:09,089 --> 00:09:21,870
bit yes it will it does control

00:09:11,670 --> 00:09:23,819
flattening as well would be a list

00:09:21,870 --> 00:09:29,339
assignment right and it would do a copy

00:09:23,819 --> 00:09:31,110
and I'm covering that a bit later too so

00:09:29,339 --> 00:09:34,110
there's no special referencing syntax

00:09:31,110 --> 00:09:36,300
needed and that is in fact here's an

00:09:34,110 --> 00:09:38,519
example of that so here I have an array

00:09:36,300 --> 00:09:40,350
and I'm going to do my dollar sign x

00:09:38,519 --> 00:09:42,300
equals words so now X is referencing

00:09:40,350 --> 00:09:44,129
that array and if you manipulate the

00:09:42,300 --> 00:09:46,709
array you are manipulating the thing

00:09:44,129 --> 00:09:48,660
that X references so if I add a word two

00:09:46,709 --> 00:09:50,069
words and then ask X how many elements

00:09:48,660 --> 00:09:52,709
do you have because it's referencing

00:09:50,069 --> 00:09:57,889
that same thing then we'll come back

00:09:52,709 --> 00:10:01,170
with six okay so list interpolation in

00:09:57,889 --> 00:10:03,420
general non scalars interpolate or

00:10:01,170 --> 00:10:05,759
flatten into lists and scalars do not

00:10:03,420 --> 00:10:07,170
that's kind of the general rule that I

00:10:05,759 --> 00:10:10,680
keep in mind when trying to keep all of

00:10:07,170 --> 00:10:12,930
this straight so here I have an array a

00:10:10,680 --> 00:10:15,509
B&B and they both have numbers and AFC

00:10:12,930 --> 00:10:19,589
which is an array reference and so as

00:10:15,509 --> 00:10:22,589
Randall just asked if if I say a comma B

00:10:19,589 --> 00:10:25,589
and put it into one this flattens out so

00:10:22,589 --> 00:10:29,279
that the array one here ends up with six

00:10:25,589 --> 00:10:31,879
elements 1 2 3 10 20 30 on the next line

00:10:29,279 --> 00:10:35,309
where I have to and I put in a B and C

00:10:31,879 --> 00:10:38,519
the dollar sign there is your clue that

00:10:35,309 --> 00:10:41,100
won't flatten it's a scalar so even

00:10:38,519 --> 00:10:42,660
though a B and C are all arrays the

00:10:41,100 --> 00:10:43,830
dollar sign in front of the sea prevents

00:10:42,660 --> 00:10:46,080
it from flattening

00:10:43,830 --> 00:10:48,390
into the things so the resulting array

00:10:46,080 --> 00:10:52,200
at sign two ends up with seven elements

00:10:48,390 --> 00:10:54,090
1 2 3 10 20 30 and an array that array

00:10:52,200 --> 00:10:56,610
containing three elements 100 200 and

00:10:54,090 --> 00:10:59,070
300 so the dollar sign is your key to

00:10:56,610 --> 00:11:03,000
know if something flattens or if it

00:10:59,070 --> 00:11:05,160
doesn't so if I asked for the element at

00:11:03,000 --> 00:11:08,430
index 0 I get one if I asked for the

00:11:05,160 --> 00:11:10,230
element in dec six I get the tent 100

00:11:08,430 --> 00:11:14,130
200 300 because that element is an array

00:11:10,230 --> 00:11:18,440
which then stringify like so for say or

00:11:14,130 --> 00:11:20,760
justifies which we won't cover here um

00:11:18,440 --> 00:11:23,640
scalar arrays don't interpolate and

00:11:20,760 --> 00:11:26,370
that's true for almost all functions so

00:11:23,640 --> 00:11:27,900
here I have at sine X and it has three

00:11:26,370 --> 00:11:30,450
elements then I say dollar sign why it's

00:11:27,900 --> 00:11:32,040
a reference to at sine X and so if I ask

00:11:30,450 --> 00:11:34,230
how many elements it has it's going to

00:11:32,040 --> 00:11:35,850
say three and if I loop over all of the

00:11:34,230 --> 00:11:37,440
elements of X then they'll flatten out

00:11:35,850 --> 00:11:39,840
and each one will be treated one at a

00:11:37,440 --> 00:11:41,940
time so that's why I'm getting loop one

00:11:39,840 --> 00:11:43,950
loop to loop 3 because each iteration

00:11:41,940 --> 00:11:45,540
through this loop I'm getting an element

00:11:43,950 --> 00:11:48,210
from X concatenated with loot or

00:11:45,540 --> 00:11:51,120
printing it out but if I used dollar

00:11:48,210 --> 00:11:52,860
sign y which is actually a reference to

00:11:51,120 --> 00:11:55,140
X but it's got a dollar sign there that

00:11:52,860 --> 00:11:58,530
means it doesn't flattened out and so

00:11:55,140 --> 00:12:00,930
the for loop oops yeah that's ok so the

00:11:58,530 --> 00:12:03,360
for loop says there's only one thing

00:12:00,930 --> 00:12:05,220
there it won't automatically flatten lie

00:12:03,360 --> 00:12:06,900
out for you because that's a scalar

00:12:05,220 --> 00:12:09,570
variable and scalars don't flatten and

00:12:06,900 --> 00:12:12,330
so this loop would be executed one time

00:12:09,570 --> 00:12:14,250
and at one time it would have dollar

00:12:12,330 --> 00:12:16,530
sign underscore the topic set to dollar

00:12:14,250 --> 00:12:17,970
sign y which is the whole array so it

00:12:16,530 --> 00:12:19,560
would stringify that whole array giving

00:12:17,970 --> 00:12:21,110
us one two three put loop in front of it

00:12:19,560 --> 00:12:23,370
and that's what would you befriended out

00:12:21,110 --> 00:12:24,960
so now the question becomes well how do

00:12:23,370 --> 00:12:28,290
I get it to flatten out if it's in a

00:12:24,960 --> 00:12:30,360
scalar and you can use an @ sign or dot

00:12:28,290 --> 00:12:32,130
list to get the list form of an object

00:12:30,360 --> 00:12:33,480
and this is true for all of the

00:12:32,130 --> 00:12:36,930
different objects that may happen to

00:12:33,480 --> 00:12:39,090
exist so this is going back to my

00:12:36,930 --> 00:12:40,860
earlier example where I set an array to

00:12:39,090 --> 00:12:43,020
a B and dollar signs see so it ends up

00:12:40,860 --> 00:12:45,960
with seven elements but if I put that

00:12:43,020 --> 00:12:48,180
list that's telling this object I want a

00:12:45,960 --> 00:12:50,730
flattening form of yourself I want you

00:12:48,180 --> 00:12:53,700
in a list form that will flatten and so

00:12:50,730 --> 00:12:55,620
the dot list here causes this array to

00:12:53,700 --> 00:12:56,940
flatten the same way that a and B do and

00:12:55,620 --> 00:12:58,620
thus this

00:12:56,940 --> 00:12:59,940
a gets nine elements because it's been

00:12:58,620 --> 00:13:03,750
flattened in instead of keeping the

00:12:59,940 --> 00:13:05,250
scalar array as opposed to dot list if

00:13:03,750 --> 00:13:07,500
you prefer to put an @ sign in front

00:13:05,250 --> 00:13:10,560
it's a cast saying I'm casting this

00:13:07,500 --> 00:13:12,240
thing into a list and so if you just put

00:13:10,560 --> 00:13:13,860
the the bear scalar there it's only

00:13:12,240 --> 00:13:15,420
going to do one iteration but if you

00:13:13,860 --> 00:13:17,610
cast it into a list first then it's

00:13:15,420 --> 00:13:20,990
going to flatten it out and iterate over

00:13:17,610 --> 00:13:20,990
all of the elements yes

00:13:33,400 --> 00:13:38,920
it's a method on the list it's a method

00:13:35,620 --> 00:13:41,230
on the list and we don't really have

00:13:38,920 --> 00:13:44,830
scalar and lists on texts like we did in

00:13:41,230 --> 00:13:46,420
Perl 5 so there's not really I mean we

00:13:44,830 --> 00:13:50,370
have the context but they have a

00:13:46,420 --> 00:13:53,020
different sort of flavor to them because

00:13:50,370 --> 00:13:55,870
because of multi methods the thing being

00:13:53,020 --> 00:13:59,350
called can't know what contexts it was

00:13:55,870 --> 00:14:01,060
in and it gets really it gets really

00:13:59,350 --> 00:14:02,710
bizarre from there i may add that to

00:14:01,060 --> 00:14:07,420
tomorrow's talk that's a really good

00:14:02,710 --> 00:14:09,850
topic yes the friends are optional on

00:14:07,420 --> 00:14:12,280
that at some ads they're not optional

00:14:09,850 --> 00:14:18,280
wait I thought that the one that it's

00:14:12,280 --> 00:14:24,910
optional on where they're optional which

00:14:18,280 --> 00:14:29,890
which okay okay I can never remember the

00:14:24,910 --> 00:14:37,300
spec keeps flipping okay this is going

00:14:29,890 --> 00:14:38,710
to work all the time so if you want to

00:14:37,300 --> 00:14:41,230
go the other way if you want to force

00:14:38,710 --> 00:14:42,820
something do not flatten then you put a

00:14:41,230 --> 00:14:44,830
dollar sign in front to make it into a

00:14:42,820 --> 00:14:47,590
scalar or you can do item which is the

00:14:44,830 --> 00:14:48,910
method form so again starting from the

00:14:47,590 --> 00:14:50,560
example I had before we have an array

00:14:48,910 --> 00:14:52,450
and I'm taking a and B and they flatten

00:14:50,560 --> 00:14:54,310
into place if you scalar eyes them by

00:14:52,450 --> 00:14:56,200
putting the dollar sign in front then

00:14:54,310 --> 00:14:59,170
that forces them to be scalar arrays and

00:14:56,200 --> 00:15:00,940
they don't flatten and so this array at

00:14:59,170 --> 00:15:02,590
sign two ends up with two elements the

00:15:00,940 --> 00:15:04,420
first element is an array containing one

00:15:02,590 --> 00:15:06,940
two and three second element is an array

00:15:04,420 --> 00:15:09,910
containing 10 20 and 30 and if you ask

00:15:06,940 --> 00:15:12,700
pearl pearl is our generic data dumper

00:15:09,910 --> 00:15:14,560
then you would see that at sign to is an

00:15:12,700 --> 00:15:23,250
array consisting of two elements that

00:15:14,560 --> 00:15:25,090
are both themselves arrays okay okay and

00:15:23,250 --> 00:15:30,070
recruit Oh probably doesn't implement

00:15:25,090 --> 00:15:35,740
that yet does it that's what I'm sorry

00:15:30,070 --> 00:15:39,750
oh ok I think he's actually meaning

00:15:35,740 --> 00:15:39,750
since 2012 05

00:15:41,420 --> 00:15:46,890
if you wanted to do that item I didn't

00:15:45,630 --> 00:15:48,870
give an example of that but any of these

00:15:46,890 --> 00:15:54,930
arrays and like here you could do a sign

00:15:48,870 --> 00:15:57,630
a item I know that gives you a the array

00:15:54,930 --> 00:16:04,170
in a scalar is a scalar as opposed to a

00:15:57,630 --> 00:16:06,180
flattening object without yeah except

00:16:04,170 --> 00:16:10,010
the backslash actually creates what we

00:16:06,180 --> 00:16:17,760
call a capture that's tomorrow's talk

00:16:10,010 --> 00:16:22,190
okay any other questions on those before

00:16:17,760 --> 00:16:24,960
I go on to laziness okay so lazy lists

00:16:22,190 --> 00:16:27,120
so laziness is one of the three virtues

00:16:24,960 --> 00:16:29,820
of a programmer and this is my

00:16:27,120 --> 00:16:31,440
experience with laziness in Perl 6 so

00:16:29,820 --> 00:16:33,090
laziness is the quality that makes you

00:16:31,440 --> 00:16:35,400
go to great effort to reduce overall

00:16:33,090 --> 00:16:37,700
energy expenditure and I cannot tell you

00:16:35,400 --> 00:16:42,080
how much great effort I've gone through

00:16:37,700 --> 00:16:44,700
trying to get laziness in the Perl 6

00:16:42,080 --> 00:16:47,130
impatience is the anger you feel when

00:16:44,700 --> 00:16:48,660
the computer is being lazy my impatient

00:16:47,130 --> 00:16:50,700
has always come because the computer is

00:16:48,660 --> 00:16:54,510
not being lazy like the spec says it's

00:16:50,700 --> 00:16:56,940
supposed to be I'm just frustrated when

00:16:54,510 --> 00:16:59,580
it's not being lazy and we've got a

00:16:56,940 --> 00:17:02,550
current bug in recruit Oh where things

00:16:59,580 --> 00:17:03,960
are not being lazy enough hubris

00:17:02,550 --> 00:17:06,120
excessive pride the sort of thing that

00:17:03,960 --> 00:17:09,870
Zeus apps before and I've been many

00:17:06,120 --> 00:17:11,550
times by Perl 6 laziness so I figure it

00:17:09,870 --> 00:17:14,190
just you know the definition just fits

00:17:11,550 --> 00:17:16,740
right in there pro 5 lists of course are

00:17:14,190 --> 00:17:17,910
eager so here's a naive in other words

00:17:16,740 --> 00:17:18,930
if you read this program you're going to

00:17:17,910 --> 00:17:21,900
say that's not going to work and yes

00:17:18,930 --> 00:17:23,760
that's the point to print a line

00:17:21,900 --> 00:17:26,580
following the first blank line in a file

00:17:23,760 --> 00:17:28,500
so this is Perl 5 code and what the

00:17:26,580 --> 00:17:30,030
programmer is in tempting to do is to

00:17:28,500 --> 00:17:32,400
read all the lines from this file handle

00:17:30,030 --> 00:17:34,140
until they find a blank line and then

00:17:32,400 --> 00:17:35,790
read the next line in print it and then

00:17:34,140 --> 00:17:40,800
they close the file handle what's wrong

00:17:35,790 --> 00:17:43,080
with this program this part is going to

00:17:40,800 --> 00:17:44,400
slurp the entire file before it ever

00:17:43,080 --> 00:17:45,870
iterates

00:17:44,400 --> 00:17:47,490
right or it might do it as an

00:17:45,870 --> 00:17:51,740
optimization but the semantics are such

00:17:47,490 --> 00:17:54,180
that this slurps the entire file and

00:17:51,740 --> 00:17:57,180
thus by the time you get to hear there's

00:17:54,180 --> 00:17:58,890
nothing left to read because you read

00:17:57,180 --> 00:18:00,270
all of the lines by this point you just

00:17:58,890 --> 00:18:01,320
happen to stop iterating when you found

00:18:00,270 --> 00:18:03,680
a blank one but they were all gone

00:18:01,320 --> 00:18:08,730
they'd been tossed away by that point

00:18:03,680 --> 00:18:10,740
12-6 lists are lazy so here's the Perl 6

00:18:08,730 --> 00:18:14,940
version now with lazy list being there

00:18:10,740 --> 00:18:17,160
so we will open the file and then the

00:18:14,940 --> 00:18:19,830
commander read files from the file

00:18:17,160 --> 00:18:21,150
handle one at a time this dot lines so

00:18:19,830 --> 00:18:23,730
from this file handle give me all the

00:18:21,150 --> 00:18:25,560
lines one at a time and exit the loop if

00:18:23,730 --> 00:18:27,840
we reach one that is completely blank

00:18:25,560 --> 00:18:29,640
and because this is lazy it does what

00:18:27,840 --> 00:18:32,010
you expect it to do it gets a line

00:18:29,640 --> 00:18:33,480
execute the block gets another line

00:18:32,010 --> 00:18:36,090
execute the block and it keeps doing

00:18:33,480 --> 00:18:39,390
that until we either execute the last

00:18:36,090 --> 00:18:41,370
because we found a blank line or because

00:18:39,390 --> 00:18:43,440
we ran out of files and lines in the

00:18:41,370 --> 00:18:47,520
file then at that point we say get the

00:18:43,440 --> 00:18:49,410
next line and we say it this probably

00:18:47,520 --> 00:18:51,150
doesn't handle the case very well where

00:18:49,410 --> 00:18:52,230
you reach the end of file here well it

00:18:51,150 --> 00:18:56,520
handles it well enough it throws an

00:18:52,230 --> 00:18:58,680
exception but it would but the point is

00:18:56,520 --> 00:19:00,420
this is this is a lazy loop and so these

00:18:58,680 --> 00:19:04,010
are only processed as they are needed

00:19:00,420 --> 00:19:04,010
instead of all at once at the beginning

00:19:05,150 --> 00:19:09,780
so here's an example of laziness in

00:19:07,530 --> 00:19:12,210
action when I wrote this line laziness

00:19:09,780 --> 00:19:13,980
and action don't seem to go together so

00:19:12,210 --> 00:19:19,380
I decided that it really need to be

00:19:13,980 --> 00:19:22,790
laziness in action all right all righty

00:19:19,380 --> 00:19:28,200
I promise I don't have any more of those

00:19:22,790 --> 00:19:29,670
so here is my list of words and what I'm

00:19:28,200 --> 00:19:31,290
going to do is I'm going to execute this

00:19:29,670 --> 00:19:32,880
block on that list of words you see

00:19:31,290 --> 00:19:35,310
first not existing but we'll fix that

00:19:32,880 --> 00:19:37,140
later so we're going to map this

00:19:35,310 --> 00:19:39,420
particular block over words and then put

00:19:37,140 --> 00:19:41,160
it in this thing and so this is going to

00:19:39,420 --> 00:19:42,930
then say hello and this is going to say

00:19:41,160 --> 00:19:45,300
the second element now if you are

00:19:42,930 --> 00:19:46,620
thinking about it in Perl 5 mode what

00:19:45,300 --> 00:19:48,300
you're thinking of is I'm going to

00:19:46,620 --> 00:19:50,880
execute this map on all these words and

00:19:48,300 --> 00:19:52,920
I get a list and then I will store the

00:19:50,880 --> 00:19:55,940
result in upwards and so what you would

00:19:52,920 --> 00:19:57,950
expect to see is

00:19:55,940 --> 00:20:01,009
as we go through the five times on this

00:19:57,950 --> 00:20:05,330
list then the word hello and then the

00:20:01,009 --> 00:20:07,460
word that's the index to with the first

00:20:05,330 --> 00:20:09,379
with the letter converted out to

00:20:07,460 --> 00:20:13,309
uppercase that's what you would kind of

00:20:09,379 --> 00:20:15,379
expect but map is lazy and so what you

00:20:13,309 --> 00:20:17,539
likely are going to get is going to be

00:20:15,379 --> 00:20:19,070
something like this all this does is to

00:20:17,539 --> 00:20:23,090
set up the map but it doesn't actually

00:20:19,070 --> 00:20:25,460
do anything yet it sets up the array and

00:20:23,090 --> 00:20:27,080
the block but you haven't actually asked

00:20:25,460 --> 00:20:29,000
for any of the results you've just asked

00:20:27,080 --> 00:20:31,279
for a reference to it so it doesn't ever

00:20:29,000 --> 00:20:33,110
execute this block so then we go say

00:20:31,279 --> 00:20:36,200
hello then we ask for the second one

00:20:33,110 --> 00:20:38,269
I'll get your question Jessica so then

00:20:36,200 --> 00:20:40,940
we ask for the second one so we go

00:20:38,269 --> 00:20:43,669
through and process elements 0 1 and 2

00:20:40,940 --> 00:20:45,500
and then that's all we ask for so it

00:20:43,669 --> 00:20:53,450
stops at that particular point and gives

00:20:45,500 --> 00:20:56,960
me the answer your question it's a it's

00:20:53,450 --> 00:20:58,940
a list and the list is lazy inside of

00:20:56,960 --> 00:21:09,139
that list there's an iterator but it's

00:20:58,940 --> 00:21:10,220
hidden from you because yes it it's

00:21:09,139 --> 00:21:12,440
going to look like a list actually

00:21:10,220 --> 00:21:17,500
there's a list type and if you say what

00:21:12,440 --> 00:21:20,059
are you it's good sam a list yeah and

00:21:17,500 --> 00:21:21,590
for most things you're just going to say

00:21:20,059 --> 00:21:23,690
oh that looks sort of like on a list and

00:21:21,590 --> 00:21:25,419
the fact that it's lazy unless you do

00:21:23,690 --> 00:21:30,080
something funny to try and tease it out

00:21:25,419 --> 00:21:32,210
you're not ever going to see it so this

00:21:30,080 --> 00:21:34,190
slide probably answers a lot of that

00:21:32,210 --> 00:21:36,230
which is internally let's have two parts

00:21:34,190 --> 00:21:38,090
so every list we have two parts we have

00:21:36,230 --> 00:21:40,490
a reified part these are the parts that

00:21:38,090 --> 00:21:42,529
we've already gone through iterated

00:21:40,490 --> 00:21:44,779
discovered calculated whatever you want

00:21:42,529 --> 00:21:46,820
to say these are the parts that we found

00:21:44,779 --> 00:21:48,950
the answers for and then there's a

00:21:46,820 --> 00:21:51,500
generator part and the generator part is

00:21:48,950 --> 00:21:53,480
like a closure code that tell us how to

00:21:51,500 --> 00:22:01,670
get to the next element from what we've

00:21:53,480 --> 00:22:03,110
already produced yes it's this slide yes

00:22:01,670 --> 00:22:04,970
I mean you still want to have the

00:22:03,110 --> 00:22:06,650
concepts and be able to make use of it

00:22:04,970 --> 00:22:08,030
but yeah a lot of the things that are in

00:22:06,650 --> 00:22:11,450
higher order parole are built in the

00:22:08,030 --> 00:22:14,150
pearl six so here's a range example now

00:22:11,450 --> 00:22:16,760
ranges aren't lists they're their own

00:22:14,150 --> 00:22:19,430
type but it will show how the iteration

00:22:16,760 --> 00:22:21,650
process works so here I'm going to set

00:22:19,430 --> 00:22:23,420
dollar sign are to be arranged and if I

00:22:21,650 --> 00:22:26,150
ask dollar sign are what are you it says

00:22:23,420 --> 00:22:27,950
I'm a range now the key operation for

00:22:26,150 --> 00:22:29,780
iterators is an operation called reify

00:22:27,950 --> 00:22:32,450
which basically says give me so many

00:22:29,780 --> 00:22:34,910
elements so if i take that range and i

00:22:32,450 --> 00:22:37,160
say real 55 elements and then show me

00:22:34,910 --> 00:22:39,110
what you got back what this range

00:22:37,160 --> 00:22:40,760
actually does is it says okay you want

00:22:39,110 --> 00:22:42,980
five elements from this particular range

00:22:40,760 --> 00:22:44,870
now reification actually is going to

00:22:42,980 --> 00:22:47,150
give you the whole thing but the last

00:22:44,870 --> 00:22:49,280
part can be lazy so it gives me five

00:22:47,150 --> 00:22:51,560
elements from the range 100 hundred 100

00:22:49,280 --> 00:22:54,410
200 300 + 4 and that says and here's the

00:22:51,560 --> 00:22:57,250
rest and so that's what actually gets

00:22:54,410 --> 00:22:59,810
returned from that particular element

00:22:57,250 --> 00:23:01,940
the lazy list managed the generation of

00:22:59,810 --> 00:23:03,530
elements on demand and we can go a

00:23:01,940 --> 00:23:04,700
little bit further than that so this is

00:23:03,530 --> 00:23:07,190
the same as what I had up there before

00:23:04,700 --> 00:23:09,200
so when after we get to the 104 if we

00:23:07,190 --> 00:23:12,670
say we need more elements we just ask

00:23:09,200 --> 00:23:14,720
this range at the end give me more so

00:23:12,670 --> 00:23:18,590
oops that's not what I was going to do

00:23:14,720 --> 00:23:20,210
oh well that's fine we'll see you here

00:23:18,590 --> 00:23:22,610
in a second so what this is actually

00:23:20,210 --> 00:23:25,280
saying is that since they're lazy we can

00:23:22,610 --> 00:23:26,720
now have infinite lists because we can

00:23:25,280 --> 00:23:28,550
actually postponed generation of the

00:23:26,720 --> 00:23:30,680
parts to when we actually need them so

00:23:28,550 --> 00:23:32,330
here's a list going from 100 to 200 we

00:23:30,680 --> 00:23:33,620
can actually take that and change this

00:23:32,330 --> 00:23:36,350
to be arranged that goes from 100 to

00:23:33,620 --> 00:23:40,550
infinity if we ask that range give me

00:23:36,350 --> 00:23:45,020
five elements it says no problem 101 101

00:23:40,550 --> 00:23:47,270
100 200 300 4 and the rest of them then

00:23:45,020 --> 00:23:49,430
if I go and say well on this one I need

00:23:47,270 --> 00:23:51,110
more elements i can say i want 3 more

00:23:49,430 --> 00:23:54,650
elements it comes back and says okay 100

00:23:51,110 --> 00:23:55,360
500 600 7 and the rest what happens if

00:23:54,650 --> 00:24:03,990
you ask

00:23:55,360 --> 00:24:03,990
delavan yeah it throws an exception I

00:24:05,280 --> 00:24:20,350
think I think how can I do that though

00:24:11,170 --> 00:24:22,809
uh let's see 100 no no because if I ask

00:24:20,350 --> 00:24:26,020
how long it is right it's smart it knows

00:24:22,809 --> 00:24:45,280
it knows how long it is that's not a

00:24:26,020 --> 00:24:49,750
problem yeah that's technically wrong by

00:24:45,280 --> 00:24:51,309
Perl 6 but it throws an exception it's

00:24:49,750 --> 00:24:56,740
the wrong exception but it throws an

00:24:51,309 --> 00:24:58,030
exception and out if I have time in this

00:24:56,740 --> 00:25:00,190
talk and if not then enter mouse talk

00:24:58,030 --> 00:25:03,610
I'll tell you why that's it I could be

00:25:00,190 --> 00:25:05,590
able to figure that out okay so since a

00:25:03,610 --> 00:25:08,710
list can be infinite or a race can be

00:25:05,590 --> 00:25:10,450
infinite as well so if you do I at sign

00:25:08,710 --> 00:25:11,740
a is 100 to infinity and ask for the

00:25:10,450 --> 00:25:14,350
tenth element it comes back and tells

00:25:11,740 --> 00:25:16,059
you 110 now what it actually does when

00:25:14,350 --> 00:25:19,570
you ask for the Telex element is it

00:25:16,059 --> 00:25:22,450
fills in element 0 1 2 3 4 5 6 7 8 9 and

00:25:19,570 --> 00:25:23,860
index 10 and then it just saves the rest

00:25:22,450 --> 00:25:27,760
and says whenever you ask for more

00:25:23,860 --> 00:25:30,429
elements later I'll go generate them so

00:25:27,760 --> 00:25:32,440
then if I ask later I want elements 15

00:25:30,429 --> 00:25:34,150
through 20 it comes back and gives me 15

00:25:32,440 --> 00:25:36,429
through 20 so at that point it says okay

00:25:34,150 --> 00:25:38,110
I need 11 12 13 14 all the way up to 20

00:25:36,429 --> 00:25:41,740
generates them and then comes back with

00:25:38,110 --> 00:25:44,919
the result you can still do shift and

00:25:41,740 --> 00:25:47,350
unch if that array and it just remembers

00:25:44,919 --> 00:25:48,580
that the infinite part is at the end so

00:25:47,350 --> 00:25:50,020
if you shift things off you're moving

00:25:48,580 --> 00:25:51,580
the infinite part towards the front and

00:25:50,020 --> 00:25:55,290
if you don't shift your moving it back

00:25:51,580 --> 00:25:55,290
but you can still do that

00:25:57,970 --> 00:26:06,710
no but you can push on to one it's

00:26:02,210 --> 00:26:08,749
called plan that it's called plan so yes

00:26:06,710 --> 00:26:12,649
so you can add something there now you

00:26:08,749 --> 00:26:14,659
may never actually get to that part but

00:26:12,649 --> 00:26:16,220
there are some lists there are some

00:26:14,659 --> 00:26:18,139
lists that may may or may not be

00:26:16,220 --> 00:26:19,909
infinite and so sometimes it makes sense

00:26:18,139 --> 00:26:32,179
to put something after a maybe infinite

00:26:19,909 --> 00:26:34,249
list it won't actually as it's

00:26:32,179 --> 00:26:36,039
implemented now what in theory one can

00:26:34,249 --> 00:26:39,919
maybe make that work I'm not going there

00:26:36,039 --> 00:26:44,409
that's that's like version 6.1 well so

00:26:39,919 --> 00:26:46,850
it'll be ready sometime in 2050 so uh

00:26:44,409 --> 00:26:49,179
okay so here's it a Fibonacci example

00:26:46,850 --> 00:26:51,289
right now this is the sequence operator

00:26:49,179 --> 00:26:52,850
other talks have talked about this but

00:26:51,289 --> 00:26:55,220
basically we're creating a list

00:26:52,850 --> 00:26:56,539
consisting of 11 the previous two

00:26:55,220 --> 00:27:02,059
elements added together all the way up

00:26:56,539 --> 00:27:03,950
to infinity that's Fibonacci right so it

00:27:02,059 --> 00:27:06,049
actually comes back and it says it when

00:27:03,950 --> 00:27:08,269
it I was doing this in the interactive

00:27:06,049 --> 00:27:10,369
mode so when it came back it said okay

00:27:08,269 --> 00:27:11,899
so the elements I see so far are 1 1 2 3

00:27:10,369 --> 00:27:15,919
and this is going to take a long time so

00:27:11,899 --> 00:27:18,799
dot um so then when I asked for a 10

00:27:15,919 --> 00:27:21,109
what happens is it fills out all of the

00:27:18,799 --> 00:27:22,609
elements following this generator up to

00:27:21,109 --> 00:27:25,609
element 10 and click back and says 89

00:27:22,609 --> 00:27:26,899
then if I go back and say I want element

00:27:25,609 --> 00:27:28,399
number three that's this one right there

00:27:26,899 --> 00:27:30,049
it comes back three now to get the three

00:27:28,399 --> 00:27:31,669
it just looks it up I don't have to

00:27:30,049 --> 00:27:34,220
calculate anything cuz it already knew

00:27:31,669 --> 00:27:35,509
that one I could say give me all the

00:27:34,220 --> 00:27:36,830
elements up to eight and it just prints

00:27:35,509 --> 00:27:38,389
them out it already knew all those

00:27:36,830 --> 00:27:40,759
because I had already generated up to 10

00:27:38,389 --> 00:27:42,859
if I asked for element 12 then it says

00:27:40,759 --> 00:27:45,109
okay I need 11 and 12 and calculates

00:27:42,859 --> 00:27:49,159
those and do that basically memoization

00:27:45,109 --> 00:27:50,389
for Fibonacci this way is built in right

00:27:49,159 --> 00:27:51,409
because every time you ask for an

00:27:50,389 --> 00:27:54,109
element's getting stored in the array

00:27:51,409 --> 00:27:56,419
now you could go muck with the elements

00:27:54,109 --> 00:27:58,159
in the array and you'd be changing the

00:27:56,419 --> 00:27:59,720
array but the generator part would

00:27:58,159 --> 00:28:03,230
continue to generate the things that you

00:27:59,720 --> 00:28:04,789
expect it to so this is really handy for

00:28:03,230 --> 00:28:06,649
doing infinite lists a lot of times in

00:28:04,789 --> 00:28:09,019
Perl 6 will just say I know I need a

00:28:06,649 --> 00:28:10,530
list from 1 to something so we just put

00:28:09,019 --> 00:28:21,090
the star there and we let laziness

00:28:10,530 --> 00:28:27,600
take care of the rest yes i calculate

00:28:21,090 --> 00:28:33,270
everything like it calculates 10 so it

00:28:27,600 --> 00:28:42,180
can replace it yes so it calculates 10

00:28:33,270 --> 00:28:50,490
so you can replace it as yes but your

00:28:42,180 --> 00:28:52,740
butt but you would have anyway the yeah

00:28:50,490 --> 00:28:53,700
yeah if you ask for element 1 million

00:28:52,740 --> 00:28:55,770
then you're going to fill out 2

00:28:53,700 --> 00:28:57,720
1,000,000 the point being you occur you

00:28:55,770 --> 00:28:59,580
deferred that cost until you actually

00:28:57,720 --> 00:29:08,520
needed it as opposed to incurring it up

00:28:59,580 --> 00:29:09,960
front so a note about that Elam's since

00:29:08,520 --> 00:29:12,750
we were talking about infant stuff like

00:29:09,960 --> 00:29:16,620
that that elephants is decidedly not

00:29:12,750 --> 00:29:18,510
lazy okay it tends to make things non

00:29:16,620 --> 00:29:19,590
lazy because when you say to a list I

00:29:18,510 --> 00:29:22,350
want to know how many elements you have

00:29:19,590 --> 00:29:24,120
and it's got a lazy part it's got to go

00:29:22,350 --> 00:29:26,160
find out how many elements it has by

00:29:24,120 --> 00:29:28,440
generating all of the lazy part until it

00:29:26,160 --> 00:29:31,860
can either determine one that I its

00:29:28,440 --> 00:29:34,380
infinite or two until it get reaches the

00:29:31,860 --> 00:29:39,750
end of that lazy list or three you run

00:29:34,380 --> 00:29:42,240
out of memory so a lot of people on will

00:29:39,750 --> 00:29:44,250
lose Elam's in on a race it's just a

00:29:42,240 --> 00:29:46,020
habit that you know that comes from

00:29:44,250 --> 00:29:48,720
profiling and stuff and that includes

00:29:46,020 --> 00:29:50,700
using the unary plus on it because if

00:29:48,720 --> 00:29:52,020
you do plus an array in Perl then that

00:29:50,700 --> 00:29:56,730
says the number of elements in the array

00:29:52,020 --> 00:30:01,200
in Perl 6 in pro 5 this is always it 0

00:29:56,730 --> 00:30:02,910
plus of 0 plus I in pro 5 I actually

00:30:01,200 --> 00:30:08,640
think of 0 plus as a unary prefix

00:30:02,910 --> 00:30:12,870
operator so it means Numa Phi so so if

00:30:08,640 --> 00:30:14,610
you do words and here and then I've

00:30:12,870 --> 00:30:17,430
created this lazy map again like I did

00:30:14,610 --> 00:30:18,810
before where it's not actually executing

00:30:17,430 --> 00:30:20,580
this until you actually do something and

00:30:18,810 --> 00:30:21,789
I say hello and then I asked for how

00:30:20,580 --> 00:30:23,799
many elements are in this

00:30:21,789 --> 00:30:25,090
then it actually has to go generate all

00:30:23,799 --> 00:30:27,519
the elements to tell me how many there

00:30:25,090 --> 00:30:38,440
are and so it kind of destroys laziness

00:30:27,519 --> 00:30:40,299
I have a question here you still get the

00:30:38,440 --> 00:30:49,239
Fibonacci answer not the one in the

00:30:40,299 --> 00:30:54,999
array it's expected if it's what you

00:30:49,239 --> 00:30:57,820
expected there there used to be a clause

00:30:54,999 --> 00:31:00,070
in the synopses that if you find

00:30:57,820 --> 00:31:03,220
yourself relying on a certain lazy

00:31:00,070 --> 00:31:05,769
behavior then it's kind of not specified

00:31:03,220 --> 00:31:17,229
so some things like that may or may not

00:31:05,769 --> 00:31:19,179
be specified so yeah so you want to

00:31:17,229 --> 00:31:21,879
avoid doing things like this detective

00:31:19,179 --> 00:31:24,070
an array is empty doing plus a or zero

00:31:21,879 --> 00:31:25,450
plus a you don't do that because you'll

00:31:24,070 --> 00:31:28,090
find out it's not empty but you've also

00:31:25,450 --> 00:31:29,200
reified the whole thing if you just want

00:31:28,090 --> 00:31:31,690
to find out if an array is not empty

00:31:29,200 --> 00:31:33,639
then just put it in a boolean context so

00:31:31,690 --> 00:31:35,970
in Perl 6 to check for a boolean you put

00:31:33,639 --> 00:31:37,960
a question mark in front and that is

00:31:35,970 --> 00:31:41,019
asking you know are you true or false

00:31:37,960 --> 00:31:43,239
and this we can do lazily if we have at

00:31:41,019 --> 00:31:45,909
least one element then it's not empty

00:31:43,239 --> 00:31:48,220
and thus it's true and so this actually

00:31:45,909 --> 00:31:50,529
said this is actually asking the array

00:31:48,220 --> 00:31:52,570
do you have at least one element if so

00:31:50,529 --> 00:31:53,440
then it returns true and you don't even

00:31:52,570 --> 00:31:54,849
have to have the question mark there

00:31:53,440 --> 00:31:57,669
because the if is already putting this

00:31:54,849 --> 00:31:59,440
in a boolean context so if you just say

00:31:57,669 --> 00:32:02,999
it naturally without trying to cast it

00:31:59,440 --> 00:32:02,999
then it works out just fine

00:32:03,450 --> 00:32:08,409
it would reapply one element basically

00:32:06,610 --> 00:32:11,260
it says give me one element if you're

00:32:08,409 --> 00:32:18,549
successful it's true if not then you're

00:32:11,260 --> 00:32:20,769
not that's especially true for Ray

00:32:18,549 --> 00:32:23,049
parameters and subs when people were

00:32:20,769 --> 00:32:25,990
contributing core functions into the

00:32:23,049 --> 00:32:29,409
parole into the Perl 6 core into bruh

00:32:25,990 --> 00:32:31,269
kudos core library a lot of times they

00:32:29,409 --> 00:32:32,890
would do things like the inner an array

00:32:31,269 --> 00:32:34,690
as a parameter and the first thing they

00:32:32,890 --> 00:32:37,750
do is ask how many elements it had and

00:32:34,690 --> 00:32:39,070
that like destroyed any laziness that

00:32:37,750 --> 00:32:40,750
the array that was passed in might have

00:32:39,070 --> 00:32:42,370
had so you have to kind of think you

00:32:40,750 --> 00:32:44,950
know is there another way that I can

00:32:42,370 --> 00:32:46,960
figure out what my bounds are without

00:32:44,950 --> 00:32:48,519
having to ask for the number of elements

00:32:46,960 --> 00:32:52,690
and it often becomes much more natural

00:32:48,519 --> 00:32:54,519
to do it that way one thing is there's

00:32:52,690 --> 00:32:55,720
if you want to get indices because a lot

00:32:54,519 --> 00:32:57,100
of times what we want to do is we want

00:32:55,720 --> 00:32:58,600
to be able to say I have these elements

00:32:57,100 --> 00:33:01,480
of the array but I also want to have the

00:32:58,600 --> 00:33:04,110
numbers of their indices 0 1 2 3 4 5

00:33:01,480 --> 00:33:06,399
then you can use the dot kV method and

00:33:04,110 --> 00:33:08,110
this says give me the elements of this

00:33:06,399 --> 00:33:10,720
array or list or whatever it happens to

00:33:08,110 --> 00:33:12,070
be as a pair of values the first one

00:33:10,720 --> 00:33:14,289
being the index the second one being the

00:33:12,070 --> 00:33:18,070
value itself so this is going to give me

00:33:14,289 --> 00:33:19,690
0 orange one line to cherry 3 banana and

00:33:18,070 --> 00:33:21,220
I grab those two at a time the first one

00:33:19,690 --> 00:33:25,960
in decay and the second one in 2v and

00:33:21,220 --> 00:33:28,090
then I just print them out it is a lazy

00:33:25,960 --> 00:33:30,730
in the spec it is currently not lazy and

00:33:28,090 --> 00:33:33,880
recruit oh because of a bug because

00:33:30,730 --> 00:33:39,490
because it's really hard to make things

00:33:33,880 --> 00:33:41,590
like it so I'm that bug will be actually

00:33:39,490 --> 00:33:45,100
fixed before the next release because

00:33:41,590 --> 00:33:47,169
there's my mind that's a big book ok so

00:33:45,100 --> 00:33:49,929
the opposite of laziness is called

00:33:47,169 --> 00:33:52,389
eagerness and so you can ask a list to

00:33:49,929 --> 00:33:54,760
reify itself completely or at least as

00:33:52,389 --> 00:33:57,789
much as it can by simply saying be eager

00:33:54,760 --> 00:34:00,159
so here i have my lazy list that i

00:33:57,789 --> 00:34:01,389
created and then i just say eager and so

00:34:00,159 --> 00:34:04,179
it's going to go generate as many

00:34:01,389 --> 00:34:05,440
elements as it can eagerly before doing

00:34:04,179 --> 00:34:07,090
anything else and then we get the actual

00:34:05,440 --> 00:34:09,169
hello so you can see we get the loop

00:34:07,090 --> 00:34:13,099
there

00:34:09,169 --> 00:34:20,720
I it will stop at the detection of the

00:34:13,099 --> 00:34:22,819
infinity so that it so that it not the

00:34:20,720 --> 00:34:31,869
lists have a way of knowing if their

00:34:22,819 --> 00:34:31,869
infinite if they're explicitly in yeah

00:34:33,639 --> 00:34:42,919
depending on how you define depending on

00:34:36,290 --> 00:34:44,780
how you define the endpoint that says

00:34:42,919 --> 00:34:51,950
that says treat it like an infinite list

00:34:44,780 --> 00:34:53,720
so it would stop early it goes and

00:34:51,950 --> 00:34:55,549
generates as much as it can till it gets

00:34:53,720 --> 00:34:57,710
to the infinite part sometimes you

00:34:55,549 --> 00:34:59,390
discover infinity in a list where it

00:34:57,710 --> 00:35:01,430
wasn't at the beginning but as you do

00:34:59,390 --> 00:35:03,940
processing you discover it and so it

00:35:01,430 --> 00:35:03,940
would stop there

00:35:14,660 --> 00:35:22,410
it's gone I know it's in the spec but

00:35:18,690 --> 00:35:25,140
that's what yeah it's in the spec but we

00:35:22,410 --> 00:35:28,190
we that was that was an early attempt to

00:35:25,140 --> 00:35:30,900
fix like implementation number two and

00:35:28,190 --> 00:35:32,250
that begat implementation number three

00:35:30,900 --> 00:35:35,100
or four which no longer had an e

00:35:32,250 --> 00:35:36,540
operator but I got tired of worrying

00:35:35,100 --> 00:35:37,770
about trying to make the spec match an

00:35:36,540 --> 00:35:45,119
implementation till we had one that

00:35:37,770 --> 00:35:46,770
actually worked list assignment so item

00:35:45,119 --> 00:35:48,450
assignment is when you have an equal

00:35:46,770 --> 00:35:51,119
sign with a scalar on the left-hand side

00:35:48,450 --> 00:35:53,700
list assignment is when you have a equal

00:35:51,119 --> 00:35:56,430
sign with anything else so list

00:35:53,700 --> 00:35:58,410
assignment is eager by default which

00:35:56,430 --> 00:36:01,050
means that if you do an assignment to a

00:35:58,410 --> 00:36:02,700
list it's going to treat the list

00:36:01,050 --> 00:36:04,320
eagerly it's going to try and reify as

00:36:02,700 --> 00:36:06,810
much as it can as part of the assignment

00:36:04,320 --> 00:36:09,390
if you have a scalar then it doesn't

00:36:06,810 --> 00:36:12,420
it's not eager by default so that's why

00:36:09,390 --> 00:36:14,670
this one here when I say upwards and do

00:36:12,420 --> 00:36:15,930
this map that's lazily evaluated and

00:36:14,670 --> 00:36:17,490
that's the example that I've been using

00:36:15,930 --> 00:36:18,900
throughout most of this presentation but

00:36:17,490 --> 00:36:20,790
if I were to take that same map and

00:36:18,900 --> 00:36:22,950
assign it to an array that would happen

00:36:20,790 --> 00:36:24,780
eagerly because it would go ahead and

00:36:22,950 --> 00:36:29,990
try and fill out all of the elements of

00:36:24,780 --> 00:36:29,990
the array as part of this assignment

00:36:32,119 --> 00:36:37,650
sync context and yes it avoids action at

00:36:35,490 --> 00:36:39,630
a distance effects because when you do

00:36:37,650 --> 00:36:41,070
an assignment to an array most people

00:36:39,630 --> 00:36:42,450
expect that you're getting the values of

00:36:41,070 --> 00:36:45,150
the right hand side and sticking them

00:36:42,450 --> 00:36:46,950
the array you what you're not expecting

00:36:45,150 --> 00:36:48,500
is that you have a generator that's

00:36:46,950 --> 00:36:50,700
going to look up the value of a variable

00:36:48,500 --> 00:36:52,800
sometime in the future when you asked

00:36:50,700 --> 00:36:53,790
for it and if that variable changed in

00:36:52,800 --> 00:36:56,270
the interim then you get a different

00:36:53,790 --> 00:37:00,780
result that's just very counterintuitive

00:36:56,270 --> 00:37:03,320
so ray assignments are eagerly evaluated

00:37:00,780 --> 00:37:03,320
yes

00:37:29,460 --> 00:37:33,000
and and if you hand back when you sit

00:37:31,349 --> 00:37:34,830
when it sends back a list it's almost

00:37:33,000 --> 00:37:36,000
always going to be lazy and then what's

00:37:34,830 --> 00:37:37,920
going to determine if it's eager or not

00:37:36,000 --> 00:37:39,390
is what you do with that list next if

00:37:37,920 --> 00:37:41,339
you put it if you assign it to Taylor

00:37:39,390 --> 00:37:42,480
it's going to stay lazy if you assign it

00:37:41,339 --> 00:37:58,710
to an array it's going to be eagerly

00:37:42,480 --> 00:38:00,720
evaluated to fill out the array far that

00:37:58,710 --> 00:38:10,170
you are going to change it therefore we

00:38:00,720 --> 00:38:12,780
better fill it in now pull modify things

00:38:10,170 --> 00:38:15,260
on the block highlighting kind of

00:38:12,780 --> 00:38:15,260
amazing

00:38:21,660 --> 00:38:29,869
and and here's the degree of finesse we

00:38:24,089 --> 00:38:33,030
have so we have levels of laziness and

00:38:29,869 --> 00:38:35,220
so we have strictly lazy which means

00:38:33,030 --> 00:38:36,839
don't do anything in advance until

00:38:35,220 --> 00:38:38,670
you're absolutely have to do a

00:38:36,839 --> 00:38:42,059
postponement as long as you can we have

00:38:38,670 --> 00:38:43,680
mostly lazy which is you you get the

00:38:42,059 --> 00:38:45,059
values if it's easy to do but if you

00:38:43,680 --> 00:38:48,000
have to do any work then put it off till

00:38:45,059 --> 00:38:49,380
later we have mostly easy eager which is

00:38:48,000 --> 00:38:51,869
you get all the easy ones that you can

00:38:49,380 --> 00:38:53,099
handle the parts that you know or finite

00:38:51,869 --> 00:38:54,569
but if you get to something that might

00:38:53,099 --> 00:38:57,599
not be finite then you postpone until

00:38:54,569 --> 00:38:59,130
later and strictly eager which is where

00:38:57,599 --> 00:39:01,049
you get all of the items that you can if

00:38:59,130 --> 00:39:02,309
you can somehow know that that's going

00:39:01,049 --> 00:39:03,720
to cause you to work forever and ever

00:39:02,309 --> 00:39:05,130
and ever in a situation where you don't

00:39:03,720 --> 00:39:07,980
want to be working for ever and ever and

00:39:05,130 --> 00:39:11,390
ever then you can fail otherwise just go

00:39:07,980 --> 00:39:11,390
along and eat it for tons of memory

00:39:11,900 --> 00:39:15,450
laziness as we've been discussing

00:39:13,619 --> 00:39:17,460
introduces a lot of action in the

00:39:15,450 --> 00:39:19,440
distance effects and so our design is to

00:39:17,460 --> 00:39:22,020
minimize them there were lots of false

00:39:19,440 --> 00:39:23,940
starts until summer 2010 so we hide

00:39:22,020 --> 00:39:25,289
iterating you throw away information and

00:39:23,940 --> 00:39:27,420
you end up losing data that you don't

00:39:25,289 --> 00:39:28,380
expect to you try keeping everything but

00:39:27,420 --> 00:39:30,990
that's bad if you're trying to do a

00:39:28,380 --> 00:39:32,400
pipeline type of thing if your pipe is

00:39:30,990 --> 00:39:33,720
actually keeping all the data that

00:39:32,400 --> 00:39:35,369
you've already processed then you're

00:39:33,720 --> 00:39:37,980
just eating up memory that you throw

00:39:35,369 --> 00:39:39,359
away in one gulp at the end so the key

00:39:37,980 --> 00:39:41,819
insight that came through lots of

00:39:39,359 --> 00:39:43,829
discussions in summer 2010 is that our

00:39:41,819 --> 00:39:46,500
lists can be mutable but our iterators

00:39:43,829 --> 00:39:48,059
are immutable that is they don't change

00:39:46,500 --> 00:39:50,339
now how do you do that because by

00:39:48,059 --> 00:39:53,609
definition an iterator is changing and

00:39:50,339 --> 00:39:55,799
so we'll come back to that here in a

00:39:53,609 --> 00:39:58,980
second and yes I should have time to get

00:39:55,799 --> 00:40:00,539
to it ok so what is a list we've been

00:39:58,980 --> 00:40:02,369
talking about a raise because most

00:40:00,539 --> 00:40:03,510
people dealing with Perl 5 are

00:40:02,369 --> 00:40:05,700
comfortable with arrays and know what

00:40:03,510 --> 00:40:07,920
they do a list is kind of the superclass

00:40:05,700 --> 00:40:09,779
of an array it's just any sequence of

00:40:07,920 --> 00:40:11,490
objects they're mutable lists are

00:40:09,779 --> 00:40:13,020
mutable in the sense that you can add

00:40:11,490 --> 00:40:14,579
something to the beginning of a list and

00:40:13,020 --> 00:40:16,500
you can add take something from the end

00:40:14,579 --> 00:40:17,880
you can shift you can insert you can

00:40:16,500 --> 00:40:21,720
splice you can do all these things for

00:40:17,880 --> 00:40:23,460
the list but it's the list itself that

00:40:21,720 --> 00:40:25,500
changes the things that are in the list

00:40:23,460 --> 00:40:27,240
can be either mutable or immutable so

00:40:25,500 --> 00:40:28,740
you can have a list of constants you can

00:40:27,240 --> 00:40:31,440
add new constants to the list you can

00:40:28,740 --> 00:40:33,180
take them off on you can add non

00:40:31,440 --> 00:40:34,650
constants to it but you can't manipulate

00:40:33,180 --> 00:40:37,290
the individual constants

00:40:34,650 --> 00:40:38,760
so list is the class in Perl 6 the

00:40:37,290 --> 00:40:40,650
handles laziness reification in

00:40:38,760 --> 00:40:43,050
iteration so it's the thing that has the

00:40:40,650 --> 00:40:45,270
reified part in the generator part if

00:40:43,050 --> 00:40:46,890
you call a function like map grap if you

00:40:45,270 --> 00:40:49,110
do a gather take anything where you're

00:40:46,890 --> 00:40:50,340
expecting back a list then you're going

00:40:49,110 --> 00:40:54,450
to get a list object that's going to

00:40:50,340 --> 00:40:56,940
hide all the iterator details for you so

00:40:54,450 --> 00:40:58,830
an array is a subclass of lists and the

00:40:56,940 --> 00:41:01,440
thing that distinguishes array from list

00:40:58,830 --> 00:41:03,750
is that array is explicitly a list of

00:41:01,440 --> 00:41:06,960
scalar containers it's a list of mutable

00:41:03,750 --> 00:41:08,610
things right and so here's kind of an

00:41:06,960 --> 00:41:11,640
example for that here I have dollar sign

00:41:08,610 --> 00:41:13,020
fruit and I'll give it the value of

00:41:11,640 --> 00:41:15,180
apple and i'll create an array with the

00:41:13,020 --> 00:41:17,700
values 0 1 and the value of fruit and

00:41:15,180 --> 00:41:20,400
because it's eager what happens is this

00:41:17,700 --> 00:41:22,050
array gets three elements 0 1 and fruit

00:41:20,400 --> 00:41:24,600
so if we assign cherry to the one in

00:41:22,050 --> 00:41:26,780
index 2 and then ask what happened to

00:41:24,600 --> 00:41:30,230
fruit what should happen to fruit I

00:41:26,780 --> 00:41:32,610
heard nothing anybody else won't agree

00:41:30,230 --> 00:41:35,610
Larry agrees I agree that's correct

00:41:32,610 --> 00:41:37,050
right this is what we would expect from

00:41:35,610 --> 00:41:39,930
pearl five and we're trying to preserve

00:41:37,050 --> 00:41:41,820
that Fay havior so the fact that we put

00:41:39,930 --> 00:41:43,530
the value of fruit into the array we put

00:41:41,820 --> 00:41:46,500
the value here we didn't actually put

00:41:43,530 --> 00:41:47,760
the variable into the array okay so it

00:41:46,500 --> 00:41:50,220
comes back it says it's still an apple

00:41:47,760 --> 00:41:51,750
and same thing for array refs so here

00:41:50,220 --> 00:41:53,610
I've got an array ref I've created an

00:41:51,750 --> 00:41:55,860
array and hear what I'm getting is the

00:41:53,610 --> 00:41:59,250
value of fruit not the variable fruit

00:41:55,860 --> 00:42:03,560
itself and so it's still there a list is

00:41:59,250 --> 00:42:05,820
different a list is not a sequence of

00:42:03,560 --> 00:42:07,620
scalar containers it's a sequence of

00:42:05,820 --> 00:42:10,410
objects which can be containers or not

00:42:07,620 --> 00:42:12,450
so if I have a list and I say okay I

00:42:10,410 --> 00:42:14,190
want to create a list from 0 1 and fruit

00:42:12,450 --> 00:42:15,840
and I changed the second element of this

00:42:14,190 --> 00:42:19,290
loop out of this list I'm actually

00:42:15,840 --> 00:42:22,290
changing fruit because the list contains

00:42:19,290 --> 00:42:23,820
fruit itself the variable and so if I

00:42:22,290 --> 00:42:25,260
actually say what's the value of fruit

00:42:23,820 --> 00:42:26,880
I'll discover that I did change it

00:42:25,260 --> 00:42:29,220
that's really kind of the distinction

00:42:26,880 --> 00:42:33,720
between list an array Larry looks

00:42:29,220 --> 00:42:35,940
perplexed um the app yes the app is what

00:42:33,720 --> 00:42:37,140
makes it a list if the out weren't there

00:42:35,940 --> 00:42:40,140
would be something called a parcel which

00:42:37,140 --> 00:42:41,580
is coming up oh so if you tried to

00:42:40,140 --> 00:42:42,990
assign to the zero element of list

00:42:41,580 --> 00:42:44,440
you're actually trying to assign to this

00:42:42,990 --> 00:42:46,839
constant zero and you'll get an error

00:42:44,440 --> 00:42:48,849
oops that should we can now sign 20 but

00:42:46,839 --> 00:42:52,440
you can actually assign to it because

00:42:48,849 --> 00:42:55,270
it's not a container it's a it's a value

00:42:52,440 --> 00:42:56,920
okay flattening list sometimes we want

00:42:55,270 --> 00:42:58,839
to group things based on context so

00:42:56,920 --> 00:43:01,140
here's a couple of examples so a is an

00:42:58,839 --> 00:43:04,390
array of 5 and 6 B is an array

00:43:01,140 --> 00:43:06,250
consisting of one two three four all of

00:43:04,390 --> 00:43:09,160
the elements of a and seven so how many

00:43:06,250 --> 00:43:14,920
elements as begets think pearl five here

00:43:09,160 --> 00:43:19,750
what would the answer be it would be

00:43:14,920 --> 00:43:22,089
seven right because this flattened okay

00:43:19,750 --> 00:43:24,670
so it would be seven the result of B

00:43:22,089 --> 00:43:27,310
would be one two three four five six and

00:43:24,670 --> 00:43:28,990
seven it flattens out now if those were

00:43:27,310 --> 00:43:31,839
brackets of course that those r square

00:43:28,990 --> 00:43:34,150
brackets would be something else already

00:43:31,839 --> 00:43:36,490
so here's another one so now I'm going

00:43:34,150 --> 00:43:39,640
to call a subroutine and I'm going to

00:43:36,490 --> 00:43:43,240
pass it one two three four the values of

00:43:39,640 --> 00:43:44,560
a and 7 in Perl 6 so the question is

00:43:43,240 --> 00:43:46,690
going to be how many arguments are

00:43:44,560 --> 00:43:58,810
passed to that subroutine and the answer

00:43:46,690 --> 00:44:00,160
is yeah Larry yes no it doesn't how many

00:43:58,810 --> 00:44:02,890
arguments are passed I'm not saying what

00:44:00,160 --> 00:44:06,250
happens when they receive okay not yet

00:44:02,890 --> 00:44:07,720
anyway for four things what we get is we

00:44:06,250 --> 00:44:12,280
get this thing with four things in it

00:44:07,720 --> 00:44:14,890
are passed to my cell all right a 12

00:44:12,280 --> 00:44:16,540
yeah a parcel actually it turns out in a

00:44:14,890 --> 00:44:18,520
seven and we'll talk about parcels in a

00:44:16,540 --> 00:44:22,329
second all right so the answer is for

00:44:18,520 --> 00:44:23,740
this thing has for um Robert E so here

00:44:22,329 --> 00:44:25,869
we see we have the same syntax here

00:44:23,740 --> 00:44:28,300
sometimes we want the groupings to just

00:44:25,869 --> 00:44:29,680
flat now sometimes we want to preserve

00:44:28,300 --> 00:44:31,329
the groupings as they were written by

00:44:29,680 --> 00:44:34,089
the programmer so to handle that we have

00:44:31,329 --> 00:44:35,829
these things called parcels right so

00:44:34,089 --> 00:44:39,010
parcels represent syntactic groups of

00:44:35,829 --> 00:44:41,319
objects so here i have a parcel this

00:44:39,010 --> 00:44:43,510
whole thing this parcel has five things

00:44:41,319 --> 00:44:46,020
in it it has an integer and integer

00:44:43,510 --> 00:44:48,170
another parcel with two things in it a

00:44:46,020 --> 00:44:52,430
fraction and hash

00:44:48,170 --> 00:44:54,049
okay parcels are unique that they can

00:44:52,430 --> 00:44:56,089
flatten in some contexts and they

00:44:54,049 --> 00:44:58,760
itemize in others it depends on how you

00:44:56,089 --> 00:45:01,069
use them as to what the answer will be

00:44:58,760 --> 00:45:02,420
the name originally for parcel came from

00:45:01,069 --> 00:45:04,670
Paris ethical cells we want to get rid

00:45:02,420 --> 00:45:06,920
of that name or that meanings of the

00:45:04,670 --> 00:45:13,190
name of this might change but I don't

00:45:06,920 --> 00:45:20,240
know I can't ever remember what tuples

00:45:13,190 --> 00:45:27,230
are so yeah yeah I believe so I've made

00:45:20,240 --> 00:45:28,730
that analogy before yeah yeah yeah

00:45:27,230 --> 00:45:30,530
you're gonna have named argument there

00:45:28,730 --> 00:45:31,970
so the parcels themselves are immutable

00:45:30,530 --> 00:45:33,799
you can't push or pop to them but the

00:45:31,970 --> 00:45:36,230
elements the things in the parcel can be

00:45:33,799 --> 00:45:38,030
mutable so and despite the name

00:45:36,230 --> 00:45:39,740
everybody looked at this and says aha

00:45:38,030 --> 00:45:41,480
it's the parents that create a parcel

00:45:39,740 --> 00:45:43,760
and that's not correct it's the commas

00:45:41,480 --> 00:45:47,480
that create the parcel the parents are

00:45:43,760 --> 00:45:49,220
just there for grouping okay so except

00:45:47,480 --> 00:45:51,829
if you have an empty parcel parents do

00:45:49,220 --> 00:45:55,280
create an empty parcel do thats Miller

00:45:51,829 --> 00:45:58,010
time most list operations cause parcels

00:45:55,280 --> 00:46:01,609
to flatten so if I have an array and

00:45:58,010 --> 00:46:03,829
another array here and I go through and

00:46:01,609 --> 00:46:06,500
I ask how many elements are in this

00:46:03,829 --> 00:46:08,119
parcel of parcels it goes through them

00:46:06,500 --> 00:46:10,010
flattens everything out to give me seven

00:46:08,119 --> 00:46:12,559
if I asked for the fifth element it goes

00:46:10,010 --> 00:46:17,089
through and figures it out by saying

00:46:12,559 --> 00:46:19,400
this is 0 1 2 3 4 5 that's the element

00:46:17,089 --> 00:46:21,349
at index 5 and give me that once and

00:46:19,400 --> 00:46:22,819
they normally flatten out if you want to

00:46:21,349 --> 00:46:24,950
make it explicit that you're flattening

00:46:22,819 --> 00:46:28,640
then you can say flatten and that causes

00:46:24,950 --> 00:46:31,760
parcels and intermediate flattening

00:46:28,640 --> 00:46:35,000
structures to flatten out there is a

00:46:31,760 --> 00:46:36,589
list of Lists operation that says don't

00:46:35,000 --> 00:46:40,190
flatten them out I want to make them

00:46:36,589 --> 00:46:41,990
like solid like items and so if you do

00:46:40,190 --> 00:46:43,819
something to say give me a list of lists

00:46:41,990 --> 00:46:45,140
and ask how many things do I have it's

00:46:43,819 --> 00:46:47,119
going to say to your going to have one

00:46:45,140 --> 00:46:49,920
parcel here and another parcel here

00:46:47,119 --> 00:47:01,710
would be the two elements be

00:46:49,920 --> 00:47:03,869
yes top flat does dot loll that wall is

00:47:01,710 --> 00:47:06,960
only one level deep right or is it yeah

00:47:03,869 --> 00:47:09,480
if they work they work they did not work

00:47:06,960 --> 00:47:15,420
in 20 12 05 they work in the release

00:47:09,480 --> 00:47:17,910
that's coming out on Tuesday there's

00:47:15,420 --> 00:47:19,260
also a special value called nil and it

00:47:17,910 --> 00:47:21,569
represents nothingness it's an empty

00:47:19,260 --> 00:47:23,280
parcel in this context if you use it

00:47:21,569 --> 00:47:26,369
like an item in a scalar context then it

00:47:23,280 --> 00:47:28,589
gives you an undefined value so if you

00:47:26,369 --> 00:47:30,510
say just return then you get back this

00:47:28,589 --> 00:47:32,280
thing called nil which means if you call

00:47:30,510 --> 00:47:34,049
this function in this context it would

00:47:32,280 --> 00:47:36,059
be like there's no element there an

00:47:34,049 --> 00:47:37,410
empty list if you call it a scalar

00:47:36,059 --> 00:47:42,540
context you're going to get an undefined

00:47:37,410 --> 00:47:45,480
value parameter passing with lists I

00:47:42,540 --> 00:47:46,890
have two minutes left if there's

00:47:45,480 --> 00:47:49,880
anything that I really really wanted to

00:47:46,890 --> 00:47:52,710
cover I think I can get through these ok

00:47:49,880 --> 00:47:54,990
pro/5 subs have a single parameter list

00:47:52,710 --> 00:47:57,809
it's at sign underscore Perl 6 has

00:47:54,990 --> 00:47:59,099
signatures and so the parameters in the

00:47:57,809 --> 00:48:01,680
signature bound to the arguments of the

00:47:59,099 --> 00:48:03,420
call so here we have a function called a

00:48:01,680 --> 00:48:06,960
subroutine belt shout them and it takes

00:48:03,420 --> 00:48:08,760
a single argument at sign words and so

00:48:06,960 --> 00:48:10,710
if we call that particular sub routine

00:48:08,760 --> 00:48:12,960
and pass it an array it will work out

00:48:10,710 --> 00:48:15,119
just fine because you can mind that if I

00:48:12,960 --> 00:48:16,049
pass it a pair of elements here this is

00:48:15,119 --> 00:48:18,450
going to actually throw an exception

00:48:16,049 --> 00:48:25,079
because i'm passing two arguments to a

00:48:18,450 --> 00:48:30,660
subroutine that expects one I'm sorry

00:48:25,079 --> 00:48:32,640
which one dollar sign w oh oh yeah it

00:48:30,660 --> 00:48:38,099
should be under score sorry

00:48:32,640 --> 00:48:39,630
you see still exists right Larry yeah

00:48:38,099 --> 00:48:41,010
that should be there should be unjust

00:48:39,630 --> 00:48:43,380
dollar sign underscore I better go fix

00:48:41,010 --> 00:48:45,180
that so this one we are called we called

00:48:43,380 --> 00:48:47,880
the we call the function with two

00:48:45,180 --> 00:48:49,769
arguments and therefore it could match

00:48:47,880 --> 00:48:51,329
but if I parenthesis this then I'm

00:48:49,769 --> 00:48:55,940
calling this function with a single

00:48:51,329 --> 00:48:55,940
parcel and therefore it's able to work

00:48:56,119 --> 00:49:02,309
next one by default arguments bind 121

00:49:00,900 --> 00:49:04,019
without flattening the number of things

00:49:02,309 --> 00:49:05,519
you put in signature that's the number

00:49:04,019 --> 00:49:08,309
of things that you put in your argument

00:49:05,519 --> 00:49:10,710
list so if i say dollar sign x dollar

00:49:08,309 --> 00:49:12,539
sign y dollar sign Z and I call foo it

00:49:10,710 --> 00:49:13,710
needs to have three arguments if I pass

00:49:12,539 --> 00:49:15,390
it an array that has three elements

00:49:13,710 --> 00:49:17,849
that's not good enough because last

00:49:15,390 --> 00:49:19,589
words is a single thing so it would say

00:49:17,849 --> 00:49:21,900
I don't have anything for y and z those

00:49:19,589 --> 00:49:24,839
required parameters aren't there if you

00:49:21,900 --> 00:49:27,450
need to flatten an array or a list into

00:49:24,839 --> 00:49:30,029
an argument list then use the prefix the

00:49:27,450 --> 00:49:32,309
pipe to flatten it so now this takes the

00:49:30,029 --> 00:49:34,619
elements of this particular array and

00:49:32,309 --> 00:49:35,940
the first element would go to the first

00:49:34,619 --> 00:49:42,660
argument the second moment to the next

00:49:35,940 --> 00:49:45,240
argument and so on down the list no

00:49:42,660 --> 00:49:51,750
because the dot loll would still be a

00:49:45,240 --> 00:49:54,720
single list containing three things dot

00:49:51,750 --> 00:49:56,609
flat would give you a single list right

00:49:54,720 --> 00:49:59,369
interpolating into an argument list is

00:49:56,609 --> 00:50:04,349
the prefix thing that's this thing to do

00:49:59,369 --> 00:50:06,660
it the positional role I'm going to skip

00:50:04,349 --> 00:50:08,700
positional role so how do you get the

00:50:06,660 --> 00:50:10,259
other behavior where you can get as many

00:50:08,700 --> 00:50:12,150
arguments as you want into a single

00:50:10,259 --> 00:50:14,190
array and the way to do that is called

00:50:12,150 --> 00:50:16,829
slurpees and you mark a slurpee with a

00:50:14,190 --> 00:50:18,329
leading asterisk and that means take all

00:50:16,829 --> 00:50:19,589
the remaining arguments whatever you

00:50:18,329 --> 00:50:21,180
haven't already captured in the

00:50:19,589 --> 00:50:24,359
signature and put them into a single

00:50:21,180 --> 00:50:26,069
list so this is going to take all of the

00:50:24,359 --> 00:50:28,170
arguments that you pass to shout them

00:50:26,069 --> 00:50:32,490
and stick it in the array outside words

00:50:28,170 --> 00:50:34,800
so more or less

00:50:32,490 --> 00:50:36,270
so here if I do this it takes three

00:50:34,800 --> 00:50:37,500
arguments those i'll end up in this list

00:50:36,270 --> 00:50:40,080
if i send it one argument that's fine

00:50:37,500 --> 00:50:42,390
too I send it no arguments it's fine ok

00:50:40,080 --> 00:50:44,640
now the slurpee parameter this is both

00:50:42,390 --> 00:50:46,140
lazy and flattening so if you send it a

00:50:44,640 --> 00:50:50,070
thing of parcels it's going to flatten

00:50:46,140 --> 00:50:53,460
them out as you as it goes along the

00:50:50,070 --> 00:50:54,840
list of Lists parameters are when you

00:50:53,460 --> 00:50:56,220
have things that you want to pass in

00:50:54,840 --> 00:50:57,750
that our list but you don't want them to

00:50:56,220 --> 00:51:00,240
flatten out like a slurpee would do and

00:50:57,750 --> 00:51:03,510
that's marked with two stars on the

00:51:00,240 --> 00:51:05,550
parameter so here's a slurpee right it's

00:51:03,510 --> 00:51:07,380
got one star and so here i'm going to

00:51:05,550 --> 00:51:08,910
pass i'm going to call ABC with three

00:51:07,380 --> 00:51:11,340
arguments a parcel a parcel and an

00:51:08,910 --> 00:51:12,869
integer and because of this the single

00:51:11,340 --> 00:51:14,490
star it's going to flatten out one two

00:51:12,869 --> 00:51:16,770
three four five it's going to say them

00:51:14,490 --> 00:51:18,690
all one at a time but if I put two stars

00:51:16,770 --> 00:51:21,210
there that means i have a list of lists

00:51:18,690 --> 00:51:23,100
and so it's going to preserve the

00:51:21,210 --> 00:51:24,570
partial nature so this is going to end

00:51:23,100 --> 00:51:25,980
up with three arguments and it keeps

00:51:24,570 --> 00:51:29,160
track of the fact that it has three

00:51:25,980 --> 00:51:31,140
arguments so if you need to pass lists

00:51:29,160 --> 00:51:32,610
as things and you don't know how many

00:51:31,140 --> 00:51:34,410
lists you're passing at the ER you're

00:51:32,610 --> 00:51:40,230
receiving at the outset you can use the

00:51:34,410 --> 00:51:42,810
list of lists argument yes which is

00:51:40,230 --> 00:51:44,880
opposite from the original perl 6

00:51:42,810 --> 00:51:46,770
specifications where the two stars where

00:51:44,880 --> 00:51:50,190
the steamroller operated the flattened

00:51:46,770 --> 00:51:56,310
until the cows came home but yes this

00:51:50,190 --> 00:52:03,720
means flat unless it just this is the

00:51:56,310 --> 00:52:06,720
way that worked out yeah alrighty I know

00:52:03,720 --> 00:52:08,730
my time is up so I have lots of stuff

00:52:06,720 --> 00:52:10,020
which will go in tomorrow's talk but I

00:52:08,730 --> 00:52:15,390
will take a couple of minutes for any

00:52:10,020 --> 00:52:17,550
less minute questions my talk tomorrow

00:52:15,390 --> 00:52:19,200
is in this room at one-thirty I will

00:52:17,550 --> 00:52:20,730
pick up from here I will include some of

00:52:19,200 --> 00:52:24,050
the things that were discussed here and

00:52:20,730 --> 00:52:24,050
we should have a good time yes and back

00:52:50,299 --> 00:52:55,499
so the the question was just just to

00:52:53,909 --> 00:52:59,159
repeat the question first to make sure I

00:52:55,499 --> 00:53:01,199
got it right and for others is um pro 5

00:52:59,159 --> 00:53:02,759
there's often already difficulty with

00:53:01,199 --> 00:53:04,229
the rate and scalar context and here

00:53:02,759 --> 00:53:06,479
we've added flattening and lists of

00:53:04,229 --> 00:53:09,959
lists and a bunch of other contexts that

00:53:06,479 --> 00:53:12,419
can make it more confusing so far based

00:53:09,959 --> 00:53:15,239
on what I've seen from comments on

00:53:12,419 --> 00:53:18,689
people on the channel yes it can make it

00:53:15,239 --> 00:53:20,759
a bit more confusing I think part of

00:53:18,689 --> 00:53:22,859
that is people coming in from a pearl 5

00:53:20,759 --> 00:53:25,199
background and it doesn't really matter

00:53:22,859 --> 00:53:26,699
their problem space so they have a few

00:53:25,199 --> 00:53:29,729
things that they're trying to make it

00:53:26,699 --> 00:53:31,289
fit into a environment they already know

00:53:29,729 --> 00:53:34,519
and the fits not perfect and that's

00:53:31,289 --> 00:53:37,529
confusing part of it is that there is

00:53:34,519 --> 00:53:40,439
just you know a lot more to have to deal

00:53:37,529 --> 00:53:43,469
with and but I don't think it's

00:53:40,439 --> 00:53:45,149
intractable I think that when we

00:53:43,469 --> 00:53:46,889
understand the problem those of us

00:53:45,149 --> 00:53:48,239
designing and working with perl 6 a bit

00:53:46,889 --> 00:53:50,549
better will come up with better

00:53:48,239 --> 00:53:52,619
explanations than what I've given today

00:53:50,549 --> 00:53:54,929
or what we're doing that will make it

00:53:52,619 --> 00:53:57,299
clearer there are a few simple rules

00:53:54,929 --> 00:53:58,469
that that are guidelines that really

00:53:57,299 --> 00:54:01,439
helped like if you see a dollar sign

00:53:58,469 --> 00:54:03,089
it's not kind of flattened you know that

00:54:01,439 --> 00:54:04,649
means scalar it's not going to flatten

00:54:03,089 --> 00:54:07,409
in that particular context if you see a

00:54:04,649 --> 00:54:09,539
leading at it is going to flatten and so

00:54:07,409 --> 00:54:11,759
it'll do that if it's grouped in a

00:54:09,539 --> 00:54:13,559
parcel it means that the the flattening

00:54:11,759 --> 00:54:16,139
decisions being deferred to something

00:54:13,559 --> 00:54:17,479
outside to try and figure out so you can

00:54:16,139 --> 00:54:19,709
get some rules of thumb and they're very

00:54:17,479 --> 00:54:22,319
consistent we just don't know the right

00:54:19,709 --> 00:54:26,699
wording for those rules of thumb Doug

00:54:22,319 --> 00:54:28,199
enough no but I know we do need to work

00:54:26,699 --> 00:54:29,909
on that particular part I do know that

00:54:28,199 --> 00:54:32,659
this is this causes problems for people

00:54:29,909 --> 00:54:32,659
yes upfront

00:54:34,240 --> 00:54:40,240
it for complex and simpler I your simple

00:54:37,869 --> 00:54:42,760
things are much simpler have all this

00:54:40,240 --> 00:54:47,500
referencing and dereferencing a lot of

00:54:42,760 --> 00:54:52,290
code perl 6 it is more complex you need

00:54:47,500 --> 00:54:54,940
to know for paper also simpler you um

00:54:52,290 --> 00:54:56,530
that's a very very good point that yes

00:54:54,940 --> 00:54:58,210
the simpler things are much simpler much

00:54:56,530 --> 00:54:59,500
more straightforward the last thing I'll

00:54:58,210 --> 00:55:01,450
do and then I know I'm Way over time so

00:54:59,500 --> 00:55:03,369
I'm going to stop is that part of the

00:55:01,450 --> 00:55:06,160
confusion that we see has been because

00:55:03,369 --> 00:55:07,869
of a changing spec and because of an

00:55:06,160 --> 00:55:09,610
implementation whether it's recruit 0 or

00:55:07,869 --> 00:55:12,250
whatever else that doesn't match the

00:55:09,610 --> 00:55:13,750
documentation or that doesn't match even

00:55:12,250 --> 00:55:17,860
what we understand to be the spec that

00:55:13,750 --> 00:55:19,420
has bugs and so it we're getting those

00:55:17,860 --> 00:55:20,619
cleaned up really really quick because I

00:55:19,420 --> 00:55:22,720
mentioned some of the big bugs are going

00:55:20,619 --> 00:55:24,190
to be done even this week and have been

00:55:22,720 --> 00:55:27,990
fixed in the last couple of weeks and so

00:55:24,190 --> 00:55:31,350
we'll know better by this time next year

00:55:27,990 --> 00:55:31,350

YouTube URL: https://www.youtube.com/watch?v=mrfK1dtyD14


