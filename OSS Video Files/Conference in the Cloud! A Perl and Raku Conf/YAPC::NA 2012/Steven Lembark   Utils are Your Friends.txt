Title: Steven Lembark   Utils are Your Friends
Publication date: 2013-08-20
Playlist: YAPC::NA 2012
Description: 
	
Captions: 
	00:00:01,010 --> 00:00:05,310
somebody just every time I say let's

00:00:03,689 --> 00:00:07,560
just start somebody crawls in okay I

00:00:05,310 --> 00:00:08,760
want to pretend it's nine o'clock quick

00:00:07,560 --> 00:00:11,280
show events how many people have

00:00:08,760 --> 00:00:18,750
actually used scalar utils list utils

00:00:11,280 --> 00:00:21,660
more utils a lot of people okay I gotta

00:00:18,750 --> 00:00:24,990
remember with you stay so anyway these

00:00:21,660 --> 00:00:26,130
things scalar and lists utils started

00:00:24,990 --> 00:00:29,220
this whole thing out they were some of

00:00:26,130 --> 00:00:33,350
the first X sproc set modules ever

00:00:29,220 --> 00:00:39,719
written by the famed profit of bar in

00:00:33,350 --> 00:00:42,680
1997 in 500 503 when the stuff was just

00:00:39,719 --> 00:00:46,680
barely stable enough to stay up and

00:00:42,680 --> 00:00:48,480
what's interesting about these is when

00:00:46,680 --> 00:00:50,280
when pro/5 started evidence is great we

00:00:48,480 --> 00:00:52,620
got this new / oh we had references we

00:00:50,280 --> 00:00:54,390
get this and that and there were still

00:00:52,620 --> 00:00:56,850
things people didn't it's the other

00:00:54,390 --> 00:00:57,840
people always want one more thing so

00:00:56,850 --> 00:01:00,930
there were a number of features that

00:00:57,840 --> 00:01:04,199
weren't in perl and grand bar sat down

00:01:00,930 --> 00:01:07,140
and found some really nice elegant ways

00:01:04,199 --> 00:01:11,700
to implement what people needed at the

00:01:07,140 --> 00:01:14,520
time later on list more utils basically

00:01:11,700 --> 00:01:16,049
added a kitchen sink of pretty much

00:01:14,520 --> 00:01:21,780
anything you'd ever want to do with an

00:01:16,049 --> 00:01:23,400
index to the to the list family and as I

00:01:21,780 --> 00:01:25,560
point out here the people here for the

00:01:23,400 --> 00:01:29,549
old line that someone has Larry wall

00:01:25,560 --> 00:01:33,049
what's the sound pearl found of a wall

00:01:29,549 --> 00:01:35,430
you're not banging your head against

00:01:33,049 --> 00:01:38,640
penalty is in Sipan in general these

00:01:35,430 --> 00:01:41,250
utilities are a great example of you

00:01:38,640 --> 00:01:44,240
know lazy Wheelz the this is a week have

00:01:41,250 --> 00:01:46,710
to reinvent to get where we're going and

00:01:44,240 --> 00:01:54,000
they allow you to really focus on what

00:01:46,710 --> 00:01:56,729
you're doing not the guts of pearl so in

00:01:54,000 --> 00:01:58,619
it more recent versions of parole 510 we

00:01:56,729 --> 00:02:00,509
had smart matching there are the things

00:01:58,619 --> 00:02:02,369
people say of it one of the first

00:02:00,509 --> 00:02:04,590
comparisons to of the smart match

00:02:02,369 --> 00:02:07,590
operator was comparing the amount of

00:02:04,590 --> 00:02:10,080
time it took first or a smart match to

00:02:07,590 --> 00:02:11,640
detect things in Google's at Ovid you

00:02:10,080 --> 00:02:13,230
know smart matches are faster we can do

00:02:11,640 --> 00:02:16,769
away with first

00:02:13,230 --> 00:02:18,510
they were wrong because there there's

00:02:16,769 --> 00:02:21,140
some neat things that first still does

00:02:18,510 --> 00:02:24,360
that you can't get out of a smart match

00:02:21,140 --> 00:02:27,480
so the other interesting thing is a lot

00:02:24,360 --> 00:02:34,080
of these utilities work very nicely with

00:02:27,480 --> 00:02:35,670
the newer features in Perl and that's

00:02:34,080 --> 00:02:37,709
kind of a testament to how well pearl

00:02:35,670 --> 00:02:40,860
works because the stuff that was written

00:02:37,709 --> 00:02:42,840
a long time ago now is still perfectly

00:02:40,860 --> 00:02:45,239
relevant the guts of pearl have been

00:02:42,840 --> 00:02:49,980
maintained well enough that these things

00:02:45,239 --> 00:02:51,329
can still function so starting with

00:02:49,980 --> 00:02:54,230
scalar utils this gives you

00:02:51,329 --> 00:02:57,810
introspection for scalars no surprise

00:02:54,230 --> 00:03:00,629
the the kind of questions you can ask

00:02:57,810 --> 00:03:03,629
your is a filehandle open these can be

00:03:00,629 --> 00:03:06,299
used on sockets file handles terminals

00:03:03,629 --> 00:03:09,390
did your terminal session vanish you can

00:03:06,299 --> 00:03:10,859
check a lot of things about a scalar

00:03:09,390 --> 00:03:14,910
including its address whether it's

00:03:10,859 --> 00:03:17,489
blessed these are all things that you

00:03:14,910 --> 00:03:19,849
you want to look for but pearl can't

00:03:17,489 --> 00:03:22,169
tell you easily you can figure them out

00:03:19,849 --> 00:03:26,329
but it's not worth figuring them out

00:03:22,169 --> 00:03:28,560
because if they're much faster here so

00:03:26,329 --> 00:03:32,120
everyone here has seen the output of ref

00:03:28,560 --> 00:03:38,910
right and a string of fide reference

00:03:32,120 --> 00:03:41,190
what is the e spring ified objects give

00:03:38,910 --> 00:03:43,200
you a lot of information they tell you

00:03:41,190 --> 00:03:45,269
everything about an object and that's

00:03:43,200 --> 00:03:46,889
the problem you don't want to know

00:03:45,269 --> 00:03:48,450
everything about something you want to

00:03:46,889 --> 00:03:49,680
know its address you want to know

00:03:48,450 --> 00:03:51,900
whether it's blessed you want to know

00:03:49,680 --> 00:03:54,180
its base type without having to parse a

00:03:51,900 --> 00:03:57,180
bunch of string to find out what's

00:03:54,180 --> 00:03:59,250
inside so these are a great example of

00:03:57,180 --> 00:04:03,629
less is more you get only what you need

00:03:59,250 --> 00:04:05,819
and only what you ask for so you've seen

00:04:03,629 --> 00:04:08,849
string a fight with the fubar array and

00:04:05,819 --> 00:04:10,709
an address if I if you want to know what

00:04:08,849 --> 00:04:12,810
what package something's blessed into

00:04:10,709 --> 00:04:15,239
you can reg ex off the name equals on

00:04:12,810 --> 00:04:20,039
the front but do you really want to do

00:04:15,239 --> 00:04:24,419
that every time so the first one is

00:04:20,039 --> 00:04:25,950
blessed and if anyone knows where this

00:04:24,419 --> 00:04:27,470
came from it there's an interesting

00:04:25,950 --> 00:04:30,690
history but

00:04:27,470 --> 00:04:33,449
bless returns a class or enough nothing

00:04:30,690 --> 00:04:35,699
more so this is how you check whether

00:04:33,449 --> 00:04:38,790
you're dealing with an object it allows

00:04:35,699 --> 00:04:44,460
you to generate you can test a lot of

00:04:38,790 --> 00:04:47,699
times because in Perl you can dispatch

00:04:44,460 --> 00:04:49,880
into a subroutine without an object if

00:04:47,699 --> 00:04:52,350
there are places where you've got

00:04:49,880 --> 00:04:55,080
generic interfaces that people might

00:04:52,350 --> 00:04:56,520
test the wrong way or you're writing

00:04:55,080 --> 00:05:00,540
your own internal testicles anyone here

00:04:56,520 --> 00:05:03,540
for the testing workshop yeah these are

00:05:00,540 --> 00:05:05,130
great for the question em you know it

00:05:03,540 --> 00:05:09,930
did the person come here through the

00:05:05,130 --> 00:05:11,580
right channel if I've got a test and the

00:05:09,930 --> 00:05:14,940
test says is the thing I get back from

00:05:11,580 --> 00:05:16,800
New and object because you can't imagine

00:05:14,940 --> 00:05:18,120
how many times people forgot to bless

00:05:16,800 --> 00:05:21,240
something on the way out of a

00:05:18,120 --> 00:05:25,620
constructor this allows you to check

00:05:21,240 --> 00:05:28,350
that you can also this is a method

00:05:25,620 --> 00:05:31,470
people say that this is for cloning it's

00:05:28,350 --> 00:05:35,479
not what it allows you to do is use one

00:05:31,470 --> 00:05:39,419
object as a prototype for another object

00:05:35,479 --> 00:05:41,760
which is great if you're in a situation

00:05:39,419 --> 00:05:45,810
where you're you're making a generic

00:05:41,760 --> 00:05:47,430
factory class and you have an object you

00:05:45,810 --> 00:05:48,780
don't know what type it is because

00:05:47,430 --> 00:05:50,610
you're a factory it's not your job to

00:05:48,780 --> 00:05:53,310
know what type it is you just want to

00:05:50,610 --> 00:05:55,800
make more of them so if you bless it

00:05:53,310 --> 00:05:58,200
into blessed dollar proto or the

00:05:55,800 --> 00:06:00,120
prototype someone can pass can call

00:05:58,200 --> 00:06:02,780
object of type that I know what it is

00:06:00,120 --> 00:06:07,110
points to new and there's no harm

00:06:02,780 --> 00:06:09,510
otherwise if you just bless it into the

00:06:07,110 --> 00:06:12,000
first item on the stack what you're

00:06:09,510 --> 00:06:14,729
going to bless it into is a class named

00:06:12,000 --> 00:06:18,120
array 0x8 you know which is probably not

00:06:14,729 --> 00:06:19,800
what you wanted to do another great

00:06:18,120 --> 00:06:22,410
thing is if you're doing if you're

00:06:19,800 --> 00:06:24,690
writing tests check whether the thing is

00:06:22,410 --> 00:06:26,910
blessed before you validate whether it

00:06:24,690 --> 00:06:28,889
can do a method because calling can on a

00:06:26,910 --> 00:06:31,260
simple scalar is an error not a very

00:06:28,889 --> 00:06:33,330
good test your test itself is going to

00:06:31,260 --> 00:06:38,219
blow up rather than telling you I can't

00:06:33,330 --> 00:06:40,770
do this the other problem is that ref

00:06:38,219 --> 00:06:44,419
doesn't if you use ref by itself you

00:06:40,770 --> 00:06:47,990
won't get the base type of a blessed

00:06:44,419 --> 00:06:51,090
reference you'll get its package name if

00:06:47,990 --> 00:06:52,950
your pay if you're parsing or processing

00:06:51,090 --> 00:06:55,610
general structures you have to walk down

00:06:52,950 --> 00:06:58,550
a hash or an array tree or something

00:06:55,610 --> 00:07:01,460
using ref isn't going to tell you how to

00:06:58,550 --> 00:07:03,990
walk in to the next level of structure

00:07:01,460 --> 00:07:08,700
so if you're writing something that does

00:07:03,990 --> 00:07:12,180
generic comparisons again that compare

00:07:08,700 --> 00:07:13,409
deeply in the test deep module it has to

00:07:12,180 --> 00:07:15,330
use this because it doesn't know what

00:07:13,409 --> 00:07:16,979
it's going to be passed so you can use

00:07:15,330 --> 00:07:19,289
rough type to say is the next thing I'm

00:07:16,979 --> 00:07:21,539
looking at an array is it a hash what

00:07:19,289 --> 00:07:23,370
these work beautifully with switches

00:07:21,539 --> 00:07:25,680
whether or not you like switches and

00:07:23,370 --> 00:07:28,650
smart matches it really does this is it

00:07:25,680 --> 00:07:30,419
this is a case of weather where the the

00:07:28,650 --> 00:07:31,979
return is simple enough that smart

00:07:30,419 --> 00:07:34,070
matching does the right thing the

00:07:31,979 --> 00:07:37,260
switches work beautifully with us and

00:07:34,070 --> 00:07:39,780
you can deal with data at that point

00:07:37,260 --> 00:07:44,000
this is also really nice if you're

00:07:39,780 --> 00:07:46,830
dealing with XML simple which isn't and

00:07:44,000 --> 00:07:50,010
it is anyone here to deal with XML

00:07:46,830 --> 00:07:52,380
simple you do you always get exactly the

00:07:50,010 --> 00:07:55,469
structure you expect out of XML simple

00:07:52,380 --> 00:07:57,599
the first time maybe not well at least

00:07:55,469 --> 00:08:00,090
this way you can tell what you're

00:07:57,599 --> 00:08:02,820
getting as you walk down it this is

00:08:00,090 --> 00:08:05,969
great for validating the return

00:08:02,820 --> 00:08:09,330
structure is an XML simple this is also

00:08:05,969 --> 00:08:12,289
great if you're passing a lot of data

00:08:09,330 --> 00:08:14,669
around with XML and you you have

00:08:12,289 --> 00:08:16,830
different edge cases that you want to

00:08:14,669 --> 00:08:18,960
make sure the people upstream did the

00:08:16,830 --> 00:08:21,779
proper thing with the defaults for XML

00:08:18,960 --> 00:08:24,180
simple you can write tests with generic

00:08:21,779 --> 00:08:27,570
data things and say if I go to this key

00:08:24,180 --> 00:08:29,010
is it an array ref if not blow up

00:08:27,570 --> 00:08:31,979
because the person didn't do it right

00:08:29,010 --> 00:08:33,539
sorry I can't parse this on the other

00:08:31,979 --> 00:08:35,940
side if you're getting this kind of

00:08:33,539 --> 00:08:38,400
generic data and has anyone ever had

00:08:35,940 --> 00:08:42,329
clients who change the data without

00:08:38,400 --> 00:08:45,150
telling us yeah and maybe they blew up

00:08:42,329 --> 00:08:47,339
XML simple in the process maybe they

00:08:45,150 --> 00:08:49,079
miss type their tags who knows but I can

00:08:47,339 --> 00:08:49,410
go through I can validate this stuff

00:08:49,079 --> 00:08:51,540
when I

00:08:49,410 --> 00:08:53,550
processing the data this is pretty

00:08:51,540 --> 00:08:57,319
declarative you anyone who looks at this

00:08:53,550 --> 00:08:57,319
can can pretty much tell what it is ah

00:08:57,800 --> 00:09:04,649
smart matching a lot of times you'll

00:09:02,850 --> 00:09:08,329
want to add you want to use smart

00:09:04,649 --> 00:09:12,149
matching but rather not we agree with it

00:09:08,329 --> 00:09:15,060
if you're going to use an object I'll in

00:09:12,149 --> 00:09:18,720
a smart match it has to have an

00:09:15,060 --> 00:09:20,910
overloaded smart match operator which

00:09:18,720 --> 00:09:26,250
makes a little bit sin speaking because

00:09:20,910 --> 00:09:29,759
the things like the the long integers

00:09:26,250 --> 00:09:31,589
which are stored as hashes if you smart

00:09:29,759 --> 00:09:34,170
match an integer to a long int you'd

00:09:31,589 --> 00:09:35,639
expect an integer comparison without the

00:09:34,170 --> 00:09:40,500
overload what you're doing is comparing

00:09:35,639 --> 00:09:42,269
an integer to the keys of a hash so the

00:09:40,500 --> 00:09:44,759
overloading helps but when you're

00:09:42,269 --> 00:09:47,519
testing people occasionally forget to

00:09:44,759 --> 00:09:51,029
overload things so this allows you

00:09:47,519 --> 00:09:52,470
double tilde quoted if all your objects

00:09:51,029 --> 00:09:54,540
are supposed to have quoted overloading

00:09:52,470 --> 00:09:57,209
or if you need it if you check for

00:09:54,540 --> 00:10:00,660
blessed before you check for can you

00:09:57,209 --> 00:10:04,310
your own test won't blow up by

00:10:00,660 --> 00:10:06,569
accidentally calling can on a non-object

00:10:04,310 --> 00:10:10,230
also works with version or any other

00:10:06,569 --> 00:10:11,699
validation for methods inside out

00:10:10,230 --> 00:10:15,029
classes do people understand what these

00:10:11,699 --> 00:10:16,829
are people seeing these things the first

00:10:15,029 --> 00:10:18,389
place they were used actually was dbi

00:10:16,829 --> 00:10:21,060
Tim Bunce invented this notion

00:10:18,389 --> 00:10:27,569
everywhere everyone ever looked at a DB

00:10:21,060 --> 00:10:28,709
I object what is it an empty hash you if

00:10:27,569 --> 00:10:30,959
you do and if you're in the Pearl

00:10:28,709 --> 00:10:33,569
debugger and you do an ex of dollar dbh

00:10:30,959 --> 00:10:38,309
or a statement handle all you will ever

00:10:33,569 --> 00:10:40,769
see is an empty hash and people used to

00:10:38,309 --> 00:10:43,170
freak out you like try to display it and

00:10:40,769 --> 00:10:44,970
you'd never see anything no matter what

00:10:43,170 --> 00:10:49,050
you store it it you'd never see anything

00:10:44,970 --> 00:10:53,100
it's a tied hash what he does is he

00:10:49,050 --> 00:10:55,589
takes the address of the variable and he

00:10:53,100 --> 00:10:58,079
uses that as a key into another hash to

00:10:55,589 --> 00:11:01,189
store his private data so you can't play

00:10:58,079 --> 00:11:01,189
with it only he can

00:11:01,590 --> 00:11:07,290
so if you take a spring ified ref the

00:11:04,080 --> 00:11:11,790
original way of writing these before ref

00:11:07,290 --> 00:11:14,730
adder was you'd put the the object into

00:11:11,790 --> 00:11:16,440
the hash which gives you a string of

00:11:14,730 --> 00:11:19,380
fight object which contains the address

00:11:16,440 --> 00:11:20,970
so it's unique the problem is if you

00:11:19,380 --> 00:11:24,480
accidentally do that before you've

00:11:20,970 --> 00:11:26,520
blessed the object you can't access it

00:11:24,480 --> 00:11:30,800
again because now the string ified

00:11:26,520 --> 00:11:33,030
version of it has got the key but

00:11:30,800 --> 00:11:35,700
blessing if you create a generic object

00:11:33,030 --> 00:11:37,860
and you pass it to up a constructor

00:11:35,700 --> 00:11:40,440
chain and something rebe les's it you'll

00:11:37,860 --> 00:11:42,030
also lose the data because the thing in

00:11:40,440 --> 00:11:47,520
front of the equals sign the package

00:11:42,030 --> 00:11:51,270
name will change so this didn't work too

00:11:47,520 --> 00:11:53,990
well until you use rough adder because

00:11:51,270 --> 00:11:57,450
then all you're using is the 0x mumble

00:11:53,990 --> 00:12:00,330
that's unique and it can't change over

00:11:57,450 --> 00:12:03,320
the life cycle of the variable now you

00:12:00,330 --> 00:12:05,490
can store whatever data you want to and

00:12:03,320 --> 00:12:09,000
associate it with an object for that

00:12:05,490 --> 00:12:13,170
objects lifetime now this isn't it this

00:12:09,000 --> 00:12:15,360
is the simplest version without a lot of

00:12:13,170 --> 00:12:17,850
extra testing for an inside-out class

00:12:15,360 --> 00:12:19,280
you can store anything you want to and

00:12:17,850 --> 00:12:23,490
it doesn't have to be a blessed

00:12:19,280 --> 00:12:25,860
reference if you are if you get egged

00:12:23,490 --> 00:12:28,950
Atta from XML simple and it's simply

00:12:25,860 --> 00:12:31,620
data and as you're parsing it you want

00:12:28,950 --> 00:12:34,050
to store something outside of it that

00:12:31,620 --> 00:12:35,790
stores validations there's extra stuff

00:12:34,050 --> 00:12:38,160
that you pulled out of the database for

00:12:35,790 --> 00:12:41,100
that portion of it you can take any

00:12:38,160 --> 00:12:43,860
reference you like and store whatever

00:12:41,100 --> 00:12:46,260
you want to about it using ref adder and

00:12:43,860 --> 00:12:50,370
you'll be safe as long as that thing

00:12:46,260 --> 00:12:54,840
exists the catch is down here in destroy

00:12:50,370 --> 00:12:57,360
land because this data is outside of the

00:12:54,840 --> 00:13:01,440
object you have to make sure to clean it

00:12:57,360 --> 00:13:03,480
out yourself and that's why the destroy

00:13:01,440 --> 00:13:05,040
uses this with the ref adder because

00:13:03,480 --> 00:13:06,300
otherwise you're going to have a memory

00:13:05,040 --> 00:13:08,070
leak because you're going to be saving

00:13:06,300 --> 00:13:10,920
things about everything and it won't go

00:13:08,070 --> 00:13:12,960
away when you things go out of scope but

00:13:10,920 --> 00:13:15,070
this also saved people from having to

00:13:12,960 --> 00:13:16,930
tie all the variables

00:13:15,070 --> 00:13:19,510
because you can do a lot of the same

00:13:16,930 --> 00:13:24,310
stuff with a tide variable but this is

00:13:19,510 --> 00:13:26,050
it's a lot simpler this way another

00:13:24,310 --> 00:13:28,450
thing you get in scalar references is

00:13:26,050 --> 00:13:30,040
the ability to weaken a reference to

00:13:28,450 --> 00:13:31,630
people here you've seen how pearl

00:13:30,040 --> 00:13:33,610
manages variables with reference

00:13:31,630 --> 00:13:37,030
counting does reference counting makes

00:13:33,610 --> 00:13:40,630
sense to not a lot of hands what happens

00:13:37,030 --> 00:13:43,510
is in Perl when you create something it

00:13:40,630 --> 00:13:45,490
exists just because you're such a nice

00:13:43,510 --> 00:13:49,690
person I'll give you a reference count

00:13:45,490 --> 00:13:52,030
of one for anything you create lexical

00:13:49,690 --> 00:13:54,220
variables you create it with a my at the

00:13:52,030 --> 00:13:56,530
end of whatever block it's in if nothing

00:13:54,220 --> 00:13:58,870
else is using that variable the

00:13:56,530 --> 00:14:02,590
reference count goes to zero the storage

00:13:58,870 --> 00:14:05,080
is returned to the heap if I take

00:14:02,590 --> 00:14:08,110
something and stores let's say I push it

00:14:05,080 --> 00:14:09,820
onto an array the array has a reference

00:14:08,110 --> 00:14:12,460
the variable has a reference reference

00:14:09,820 --> 00:14:14,260
count goes to 2 the my portion of it

00:14:12,460 --> 00:14:16,210
goes out of scope and you've got an

00:14:14,260 --> 00:14:18,850
anonymous thing on an array but it still

00:14:16,210 --> 00:14:22,600
has a reference count of one reference

00:14:18,850 --> 00:14:23,920
counting is simple it's fast a lot of

00:14:22,600 --> 00:14:26,200
people don't like it for garbage

00:14:23,920 --> 00:14:30,570
collection for one reason though it's

00:14:26,200 --> 00:14:34,720
possible to have a self-referencing item

00:14:30,570 --> 00:14:38,380
so here's an example the first 1i phi

00:14:34,720 --> 00:14:41,080
set dollar a to backslash dollar a the

00:14:38,380 --> 00:14:44,020
the reference to dollar a ups the

00:14:41,080 --> 00:14:47,460
reference count of a because it's stored

00:14:44,020 --> 00:14:50,140
in a AAA exists and it refers to itself

00:14:47,460 --> 00:14:53,500
reference count of two if a goes out of

00:14:50,140 --> 00:14:56,380
scope it still has a reference cattle

00:14:53,500 --> 00:14:58,210
one because it's storing itself that is

00:14:56,380 --> 00:15:00,220
a memory leak that's probably an error

00:14:58,210 --> 00:15:02,980
the line below it though I do a lot of

00:15:00,220 --> 00:15:06,910
work with linked lists a doubly linked

00:15:02,980 --> 00:15:09,580
list or a circular linked list will

00:15:06,910 --> 00:15:11,950
never go out of scope because something

00:15:09,580 --> 00:15:14,020
always refers to something the reference

00:15:11,950 --> 00:15:16,480
counts are always one and pearl will

00:15:14,020 --> 00:15:19,510
never clear out the variables is this

00:15:16,480 --> 00:15:21,070
making sense to anybody well here's a

00:15:19,510 --> 00:15:23,670
solution to it we saw this yesterday and

00:15:21,070 --> 00:15:28,150
one of the lightning talks with weaken

00:15:23,670 --> 00:15:29,380
what I can say is let me create a

00:15:28,150 --> 00:15:33,079
reference

00:15:29,380 --> 00:15:36,290
that doesn't keep the variable alive it

00:15:33,079 --> 00:15:38,810
I decrement the reference count so this

00:15:36,290 --> 00:15:42,800
reference won't keep the variable alive

00:15:38,810 --> 00:15:46,430
it's a just a bucket that remembers

00:15:42,800 --> 00:15:47,870
where something came from so if you use

00:15:46,430 --> 00:15:50,449
to the UNIX file system it's like a

00:15:47,870 --> 00:15:53,300
symbolic link I can have a symbolic link

00:15:50,449 --> 00:15:55,490
to no place the symlink won't keep a

00:15:53,300 --> 00:15:57,949
file alive on the file system it just

00:15:55,490 --> 00:16:00,829
tells me where to go to find it same

00:15:57,949 --> 00:16:04,519
thing here if I weaken the back link and

00:16:00,829 --> 00:16:07,670
then store the backlink in a variable

00:16:04,519 --> 00:16:11,300
the reference count on dollar a on the

00:16:07,670 --> 00:16:14,089
second line is one a will go out of

00:16:11,300 --> 00:16:15,589
scope I can clean up my linked list if I

00:16:14,089 --> 00:16:19,940
delete a node out of the list it'll go

00:16:15,589 --> 00:16:21,769
away nicely I can still find it because

00:16:19,940 --> 00:16:24,560
I can still go into a eight points to

00:16:21,769 --> 00:16:26,720
one all the time but if a is gone at a

00:16:24,560 --> 00:16:29,360
scope and I have a another pointer to

00:16:26,720 --> 00:16:32,269
something and I walk down it that that

00:16:29,360 --> 00:16:34,279
backlink will be undef if the variable a

00:16:32,269 --> 00:16:39,949
is gone out of scope or whatever holds

00:16:34,279 --> 00:16:43,130
it alive is going out of scope you can't

00:16:39,949 --> 00:16:45,350
find the reference count but you there

00:16:43,130 --> 00:16:48,769
isn't is week which allows you to check

00:16:45,350 --> 00:16:50,120
if a reference is weak and if it's not

00:16:48,769 --> 00:16:52,579
as weak you know that the reference

00:16:50,120 --> 00:16:53,959
count is at least that many if you

00:16:52,579 --> 00:16:56,779
wanted to find the reference count you'd

00:16:53,959 --> 00:16:58,430
have to play around in excess generally

00:16:56,779 --> 00:17:01,339
you don't really care what the reference

00:16:58,430 --> 00:17:04,339
count is you just care that the the

00:17:01,339 --> 00:17:12,110
thing is alive it one or more is is good

00:17:04,339 --> 00:17:14,500
enough it's unless you were unless

00:17:12,110 --> 00:17:17,929
you're dealing in Perl guts itself and

00:17:14,500 --> 00:17:20,750
questioning whether to return something

00:17:17,929 --> 00:17:23,600
to the heap what you what you'd want to

00:17:20,750 --> 00:17:26,299
check is let's say you're writing a test

00:17:23,600 --> 00:17:28,539
and you want to check whether or not the

00:17:26,299 --> 00:17:31,250
references you've got to something are

00:17:28,539 --> 00:17:32,539
going to keep it alive accidentally

00:17:31,250 --> 00:17:35,690
because you've had problems with memory

00:17:32,539 --> 00:17:38,559
leaks there is a function called is weak

00:17:35,690 --> 00:17:41,059
that's provided by scalar utils and

00:17:38,559 --> 00:17:42,200
you'd walk down all the references that

00:17:41,059 --> 00:17:43,880
you know you

00:17:42,200 --> 00:17:46,510
to something and you check that they're

00:17:43,880 --> 00:17:50,360
all week so that there's only one light

00:17:46,510 --> 00:17:52,700
11 not is weak copy so in a linked list

00:17:50,360 --> 00:17:55,700
you check the the-- the link going

00:17:52,700 --> 00:17:58,669
forward is is a strong link and you

00:17:55,700 --> 00:18:00,500
check that the link inside the thing is

00:17:58,669 --> 00:18:09,370
weak and if you've done that you've done

00:18:00,500 --> 00:18:09,370
everything you can it is

00:18:18,320 --> 00:18:26,840
you can't it's the way reference is this

00:18:23,330 --> 00:18:28,669
doesn't see you don't have pointers it

00:18:26,840 --> 00:18:34,159
have references they're going to be

00:18:28,669 --> 00:18:36,740
counted another thing most people have

00:18:34,159 --> 00:18:41,230
seen we've all done this once check for

00:18:36,740 --> 00:18:44,960
a number right up backslash de dÃ³lar

00:18:41,230 --> 00:18:47,090
realize that is a bad idea for for a

00:18:44,960 --> 00:18:49,549
number of reasons one is it's slow even

00:18:47,090 --> 00:18:53,440
with the newest reg ex engine red x's

00:18:49,549 --> 00:18:56,389
are not that fast the other thing is

00:18:53,440 --> 00:18:59,659
digits are fine but then you have 0 e 0

00:18:56,389 --> 00:19:04,220
which is a number between exponents

00:18:59,659 --> 00:19:06,139
octal hex point you know right a reg has

00:19:04,220 --> 00:19:08,720
anyone ever seen the reg ex for all the

00:19:06,139 --> 00:19:12,740
numbers it's in the the regular

00:19:08,720 --> 00:19:15,259
expressions book it wraps three times on

00:19:12,740 --> 00:19:20,450
the page between floating and double and

00:19:15,259 --> 00:19:21,980
int and NX and exponents and binary

00:19:20,450 --> 00:19:23,929
don't forget binary so you got little

00:19:21,980 --> 00:19:26,299
letters that you gotta do man what a

00:19:23,929 --> 00:19:27,950
mess because then if it's if you know

00:19:26,299 --> 00:19:32,269
its binary you've got to only check four

00:19:27,950 --> 00:19:34,399
zeros and ones Pearl has a function

00:19:32,269 --> 00:19:40,820
inside of itself called looks like

00:19:34,399 --> 00:19:43,309
number guess what it does and it's got

00:19:40,820 --> 00:19:46,250
all of this this this is what pearl uses

00:19:43,309 --> 00:19:48,889
itself when you when you want to print

00:19:46,250 --> 00:19:51,559
something and it has to be nullified or

00:19:48,889 --> 00:19:54,529
if you're doing arithmetic and Pearl has

00:19:51,559 --> 00:19:57,289
to decide whether or not it the next set

00:19:54,529 --> 00:19:59,870
of characters should be treated

00:19:57,289 --> 00:20:03,019
numerically pearl knows if it looks like

00:19:59,870 --> 00:20:05,899
a number this taps right into it it is

00:20:03,019 --> 00:20:09,940
fast and it knows everything about

00:20:05,899 --> 00:20:15,529
numbers that pearl knows about numbers

00:20:09,940 --> 00:20:19,000
so you can have you know the simplest

00:20:15,529 --> 00:20:19,000
cases you get an F block hmm

00:20:23,580 --> 00:20:37,509
if here yeah well there's the whole

00:20:33,610 --> 00:20:42,159
issue also of zero but true which is a

00:20:37,509 --> 00:20:45,039
number so zero but true will fail the

00:20:42,159 --> 00:20:47,710
backslash detest but it will be treated

00:20:45,039 --> 00:20:49,779
numerically by pearl so if you really

00:20:47,710 --> 00:20:51,970
want to check whether or not the next

00:20:49,779 --> 00:20:54,070
thing you're looking at is something

00:20:51,970 --> 00:20:56,470
that pearl will treat in the opcodes

00:20:54,070 --> 00:20:58,359
like a number use looks like number and

00:20:56,470 --> 00:21:00,340
you'll always get it right and if the

00:20:58,359 --> 00:21:02,710
Pearl standard evolves you're not going

00:21:00,340 --> 00:21:03,639
to be changing the reg ex in 85 places

00:21:02,710 --> 00:21:09,720
you're just going to get it right the

00:21:03,639 --> 00:21:12,100
first time another thing you can get and

00:21:09,720 --> 00:21:15,940
I haven't gone through all of the mins

00:21:12,100 --> 00:21:17,679
but enlist handling if you look at

00:21:15,940 --> 00:21:18,909
something on the list and it looks like

00:21:17,679 --> 00:21:22,090
a number you're probably going to

00:21:18,909 --> 00:21:24,940
compute the minimum differently than if

00:21:22,090 --> 00:21:26,379
it were a string you're going to want to

00:21:24,940 --> 00:21:28,960
use a numeric sort instead of an

00:21:26,379 --> 00:21:33,850
alphabetic sort you can now do that with

00:21:28,960 --> 00:21:36,340
one line um if you're trying to input

00:21:33,850 --> 00:21:39,509
something you think is numeric validate

00:21:36,340 --> 00:21:42,820
the user input you know either it is

00:21:39,509 --> 00:21:44,919
looks like a number or it's not a number

00:21:42,820 --> 00:21:46,480
the other great thing about this if

00:21:44,919 --> 00:21:47,799
you've got to read the reg ex from hell

00:21:46,480 --> 00:21:49,629
and decide what it does and you're

00:21:47,799 --> 00:21:50,980
looking at somebody else's code and they

00:21:49,629 --> 00:21:53,200
wrote the reg ex differently from you

00:21:50,980 --> 00:21:56,889
might you be wrong about whether it

00:21:53,200 --> 00:21:59,710
works I would if you see the phrase

00:21:56,889 --> 00:22:03,340
looks like number do you kind of think

00:21:59,710 --> 00:22:04,840
what it does it's pretty declarative you

00:22:03,340 --> 00:22:06,249
can understand what you're looking at

00:22:04,840 --> 00:22:11,049
and there's something to be said for

00:22:06,249 --> 00:22:14,279
that another thing we get into I don't

00:22:11,049 --> 00:22:17,559
like prototypes but for people who do

00:22:14,279 --> 00:22:22,470
one of the downsides and pearl is you

00:22:17,559 --> 00:22:25,509
cannot prototype an anonymous subroutine

00:22:22,470 --> 00:22:27,700
because there's no declaration to

00:22:25,509 --> 00:22:31,480
prototype it with there's no place to

00:22:27,700 --> 00:22:33,159
put the dollars and at signs so one of

00:22:31,480 --> 00:22:36,609
the things you get in the scalar you too

00:22:33,159 --> 00:22:38,710
cells are is set prototype one use for

00:22:36,609 --> 00:22:42,039
that is if you want to create an

00:22:38,710 --> 00:22:45,609
anonymous subroutine that handles a

00:22:42,039 --> 00:22:47,229
block properly you've all seen map grep

00:22:45,609 --> 00:22:49,539
the rest of these things where you just

00:22:47,229 --> 00:22:53,139
have curly braces that do something and

00:22:49,539 --> 00:22:56,440
then you've got the arguments to do that

00:22:53,139 --> 00:22:58,179
you require a prototype because it has

00:22:56,440 --> 00:23:00,909
to know that that block is should be

00:22:58,179 --> 00:23:05,349
treated like a scalar and not executed

00:23:00,909 --> 00:23:08,229
to get a result so if you want to return

00:23:05,349 --> 00:23:10,269
closures if you want a factory for

00:23:08,229 --> 00:23:14,799
handlers in methods which can be a

00:23:10,269 --> 00:23:17,289
really handy thing to have then this is

00:23:14,799 --> 00:23:18,820
the way to add the prototypes after

00:23:17,289 --> 00:23:21,970
you've constructed the anonymous

00:23:18,820 --> 00:23:24,759
subroutine there are times when i use

00:23:21,970 --> 00:23:27,639
blessed subroutines and I pass the

00:23:24,759 --> 00:23:29,259
object around and the object knows how

00:23:27,639 --> 00:23:31,659
to tell when it's supposed to be

00:23:29,259 --> 00:23:37,389
executed and you can have an object that

00:23:31,659 --> 00:23:42,039
takes a block and execute it another use

00:23:37,389 --> 00:23:45,190
for this is you can have misguided cases

00:23:42,039 --> 00:23:46,599
where people prototype a subroutine with

00:23:45,190 --> 00:23:48,879
dollar dollar because they think they

00:23:46,599 --> 00:23:51,009
want two items and now you can never

00:23:48,879 --> 00:23:53,200
call it by just passing arguments down

00:23:51,009 --> 00:23:55,479
with add underscore you can't do a go-to

00:23:53,200 --> 00:23:59,259
ampersand because what's on the stack is

00:23:55,479 --> 00:24:01,809
an array and it wants two scalars so

00:23:59,259 --> 00:24:04,479
this allows you to unset the prototype

00:24:01,809 --> 00:24:06,700
if you're wrapping something if you want

00:24:04,479 --> 00:24:09,399
to overload somebody's method and

00:24:06,700 --> 00:24:12,749
they're driving you nuts because their

00:24:09,399 --> 00:24:15,700
prototype breaks the way you call it

00:24:12,749 --> 00:24:19,210
this is no method dodge that but if

00:24:15,700 --> 00:24:21,970
you've got a subroutine that this will

00:24:19,210 --> 00:24:24,849
allow you to wrap somebody else's thing

00:24:21,970 --> 00:24:33,639
with a saner or appropriate subroutine

00:24:24,849 --> 00:24:36,009
for your environment I you'd know well I

00:24:33,639 --> 00:24:39,789
shouldn't say that I've never tried to

00:24:36,009 --> 00:24:41,409
do this encore global anything but it

00:24:39,789 --> 00:24:44,799
should work I mean it's the same data

00:24:41,409 --> 00:24:46,930
structure what you have to do is is

00:24:44,799 --> 00:24:49,590
there are actually still

00:24:46,930 --> 00:24:54,640
some core global thingies that have

00:24:49,590 --> 00:24:58,180
dollar dollar prototypes and you can't

00:24:54,640 --> 00:25:00,820
call them with a thing of at underscore

00:24:58,180 --> 00:25:02,230
and just have them do the right thing so

00:25:00,820 --> 00:25:04,090
yeah I think this actually might allow

00:25:02,230 --> 00:25:06,100
you to it the very worse what you'd have

00:25:04,090 --> 00:25:07,870
to do is strip out core global something

00:25:06,100 --> 00:25:10,000
stick your own subroutine into it that's

00:25:07,870 --> 00:25:11,890
got you know at is the prototype and

00:25:10,000 --> 00:25:17,830
then use that to call the the inner

00:25:11,890 --> 00:25:20,020
thing bipolar variables yes we have

00:25:17,830 --> 00:25:24,130
psychologically challenged variables in

00:25:20,020 --> 00:25:26,110
Perl the one of the things you want to

00:25:24,130 --> 00:25:29,950
do in the classic example of this is a

00:25:26,110 --> 00:25:32,560
disco Graham this cog programs walk down

00:25:29,950 --> 00:25:35,410
the file system and ask which things

00:25:32,560 --> 00:25:36,940
take up space and sometimes you want to

00:25:35,410 --> 00:25:39,940
print it out as a number sometimes you

00:25:36,940 --> 00:25:42,310
want to print it out as a string so a

00:25:39,940 --> 00:25:44,620
dual ver does that for you you create it

00:25:42,310 --> 00:25:47,980
with a number and a string if you use it

00:25:44,620 --> 00:25:50,080
in anything numeric you get the number

00:25:47,980 --> 00:25:51,820
value out of it if you use it for

00:25:50,080 --> 00:25:54,490
anything stringy you get the string

00:25:51,820 --> 00:25:57,460
value out of it you could do this in

00:25:54,490 --> 00:26:00,420
pearl with overloading but the nice

00:25:57,460 --> 00:26:02,950
thing is that this is a lot faster and

00:26:00,420 --> 00:26:05,860
because it's encapsulated in excess

00:26:02,950 --> 00:26:08,980
there are very very few ways for anyone

00:26:05,860 --> 00:26:10,630
to screw up your dual there where if you

00:26:08,980 --> 00:26:12,010
used a plain object somebody could

00:26:10,630 --> 00:26:17,350
actually try to reach into it and play

00:26:12,010 --> 00:26:20,440
around with the thing oh the example

00:26:17,350 --> 00:26:23,320
here let's say I've got a bunch of usage

00:26:20,440 --> 00:26:26,830
and strings and I want to sort things by

00:26:23,320 --> 00:26:28,600
number and then print them show me all

00:26:26,830 --> 00:26:29,950
show me all the portions of the file

00:26:28,600 --> 00:26:33,610
system that are more than eighty percent

00:26:29,950 --> 00:26:35,920
full I can have one thing in file fine

00:26:33,610 --> 00:26:38,770
that creates dual there's for usage and

00:26:35,920 --> 00:26:41,700
name of thing I can select them with a

00:26:38,770 --> 00:26:45,400
greater than and print out the names

00:26:41,700 --> 00:26:47,590
that's what this does but I don't have

00:26:45,400 --> 00:26:49,390
to have all the if blocks and points to

00:26:47,590 --> 00:26:52,050
zero and points to one in the rest of it

00:26:49,390 --> 00:26:57,040
I just have a nice encapsulated object

00:26:52,050 --> 00:26:59,410
that does the right thing they're all so

00:26:57,040 --> 00:27:00,550
nice if you're dealing with process

00:26:59,410 --> 00:27:02,080
tables

00:27:00,550 --> 00:27:04,450
you can have the process ID in the name

00:27:02,080 --> 00:27:08,020
of the command and just encapsulate that

00:27:04,450 --> 00:27:10,390
in one thing they're nice if you there

00:27:08,020 --> 00:27:12,430
are times when you end up storing things

00:27:10,390 --> 00:27:15,580
in hashes because you want to keep track

00:27:12,430 --> 00:27:17,110
of a name and a value and hash points to

00:27:15,580 --> 00:27:19,980
value just seems like the easiest way

00:27:17,110 --> 00:27:22,450
but hashes are horribly inefficient and

00:27:19,980 --> 00:27:24,010
you find if you have an array of dual

00:27:22,450 --> 00:27:27,090
layers you can usually get the same

00:27:24,010 --> 00:27:31,020
thing done in fact in Perl 6 hashes are

00:27:27,090 --> 00:27:33,490
lists of pairings this is the the an

00:27:31,020 --> 00:27:39,970
example of an underlying pairing that

00:27:33,490 --> 00:27:42,150
you can store that way anyway there are

00:27:39,970 --> 00:27:46,090
a few things open handle is kind of nice

00:27:42,150 --> 00:27:47,590
it anyone here deal with sockets anyone

00:27:46,090 --> 00:27:52,060
ever had a socket that was closed when

00:27:47,590 --> 00:27:55,390
he tried to read on it check it'll tell

00:27:52,060 --> 00:27:57,130
you you'll know now it's also nice if

00:27:55,390 --> 00:27:58,690
you're dealing with input from terminals

00:27:57,130 --> 00:28:05,070
anyone have a terminal that went away

00:27:58,690 --> 00:28:10,810
write a nice simple you know is open

00:28:05,070 --> 00:28:14,710
there's v-string if you have something

00:28:10,810 --> 00:28:16,390
like v5 point 16 whatever you have to

00:28:14,710 --> 00:28:17,950
treat v strings separately in some

00:28:16,390 --> 00:28:19,780
contexts they don't really behave

00:28:17,950 --> 00:28:22,120
numerically all the time you can check

00:28:19,780 --> 00:28:24,480
if something is a V string which is

00:28:22,120 --> 00:28:26,770
really neat when you're writing tests

00:28:24,480 --> 00:28:28,540
regression tests or utility tests for

00:28:26,770 --> 00:28:30,880
your own modules you can validate

00:28:28,540 --> 00:28:32,560
whether the version is av string and

00:28:30,880 --> 00:28:33,520
whack the guys that don't use them

00:28:32,560 --> 00:28:35,500
because they are a much better way

00:28:33,520 --> 00:28:39,490
nowadays tainted you'll never guess what

00:28:35,500 --> 00:28:42,490
that tells you but it's really nice

00:28:39,490 --> 00:28:45,910
again even if you don't use tainted in

00:28:42,490 --> 00:28:47,950
your code it is wonderful in tests did

00:28:45,910 --> 00:28:52,240
all the nice people who read the input

00:28:47,950 --> 00:28:55,000
untainted properly this is also neat

00:28:52,240 --> 00:28:56,650
that you can do tainted checks a lot of

00:28:55,000 --> 00:28:58,420
times it's good if you put your sanity

00:28:56,650 --> 00:29:00,640
checks into one place so that you can

00:28:58,420 --> 00:29:04,420
maintain them outside of the bulk of

00:29:00,640 --> 00:29:07,480
your code at that point you can have the

00:29:04,420 --> 00:29:09,600
thing that does the untainted validate

00:29:07,480 --> 00:29:14,200
whether it's getting tainted data and

00:29:09,600 --> 00:29:15,790
fail if the data coming in is untainted

00:29:14,200 --> 00:29:21,100
because it may screw up your internal

00:29:15,790 --> 00:29:22,870
tank chest um is read only checks for

00:29:21,100 --> 00:29:25,780
read-only values you can create those in

00:29:22,870 --> 00:29:28,390
Perl their constants or if you assign a

00:29:25,780 --> 00:29:31,270
reference to a constant to a glob you

00:29:28,390 --> 00:29:32,590
can install a constant PI whatever you

00:29:31,270 --> 00:29:34,900
don't want to try and modify those

00:29:32,590 --> 00:29:37,960
because you'll blow up again these are

00:29:34,900 --> 00:29:40,300
really nice for tests you can have a

00:29:37,960 --> 00:29:42,130
test that checks for is read-only on

00:29:40,300 --> 00:29:43,930
what you thought was an array of

00:29:42,130 --> 00:29:45,280
constants that you're passing around to

00:29:43,930 --> 00:29:49,120
different things that aren't supposed to

00:29:45,280 --> 00:29:52,540
modify them managing lists lists you

00:29:49,120 --> 00:29:55,210
till this most of these are obvious i'm

00:29:52,540 --> 00:29:57,130
not going to describe min max min string

00:29:55,210 --> 00:29:59,200
you can kind of figure out what they

00:29:57,130 --> 00:30:03,060
have some can anyone not figure out what

00:29:59,200 --> 00:30:05,590
some does fine we're done with that one

00:30:03,060 --> 00:30:07,660
minster and maxtor do what you expect

00:30:05,590 --> 00:30:10,870
their stringy compare instead of using a

00:30:07,660 --> 00:30:15,610
less than greater than they use a LT GT

00:30:10,870 --> 00:30:19,600
to find the minimum string shuffle

00:30:15,610 --> 00:30:22,630
randomizes a list the other way to do

00:30:19,600 --> 00:30:25,450
this is to assign things to a hash and

00:30:22,630 --> 00:30:27,790
take the keys back out that is slow it

00:30:25,450 --> 00:30:29,860
is bulky and it's error prone because

00:30:27,790 --> 00:30:32,320
the keys will come back in deterministic

00:30:29,860 --> 00:30:33,970
ways there are times for security when

00:30:32,320 --> 00:30:36,970
you can't put things in the same order

00:30:33,970 --> 00:30:39,370
every time or for testing if you want to

00:30:36,970 --> 00:30:41,710
test that people validate things without

00:30:39,370 --> 00:30:47,590
just taking them blindly by order you

00:30:41,710 --> 00:30:49,870
can shuffle them and it's very fast yes

00:30:47,590 --> 00:30:55,180
well it's pseudo-random nothing on the

00:30:49,870 --> 00:30:57,580
machine is truly random yes again you

00:30:55,180 --> 00:30:59,980
could do this yourself by doing a sort

00:30:57,580 --> 00:31:01,690
by and pairing the thing with a random

00:30:59,980 --> 00:31:03,970
numbers sorting it and then spitting it

00:31:01,690 --> 00:31:07,510
out but it will be a lot faster using

00:31:03,970 --> 00:31:08,710
shuffle now the remainder what I'll show

00:31:07,510 --> 00:31:10,570
you these things they could be written

00:31:08,710 --> 00:31:12,790
in pure / all there there's none of

00:31:10,570 --> 00:31:16,630
these you can't do with dollar a in

00:31:12,790 --> 00:31:20,560
dollar be or whatever first thing is

00:31:16,630 --> 00:31:23,770
speed they are fast excess is quick but

00:31:20,560 --> 00:31:26,200
another thing to the interfaces for what

00:31:23,770 --> 00:31:29,020
I'll show you they just work getting the

00:31:26,200 --> 00:31:30,760
the prototypes and the variables and

00:31:29,020 --> 00:31:34,060
making sure there are no external side

00:31:30,760 --> 00:31:35,770
effects is not easy to do you can do it

00:31:34,060 --> 00:31:38,350
but you're going to waste a lot of time

00:31:35,770 --> 00:31:40,060
on something that's very fast and

00:31:38,350 --> 00:31:41,920
already done for you the other great

00:31:40,060 --> 00:31:44,980
thing about excess is it encapsulates

00:31:41,920 --> 00:31:47,890
the data you're not going to

00:31:44,980 --> 00:31:50,950
accidentally have side effects where

00:31:47,890 --> 00:31:52,990
people reach into your code or or play

00:31:50,950 --> 00:31:55,390
around with what's in it because they

00:31:52,990 --> 00:31:57,010
can't they can't easily anyone that can

00:31:55,390 --> 00:31:58,960
screw around with the guts of these

00:31:57,010 --> 00:32:00,550
things is writing their own excess and

00:31:58,960 --> 00:32:02,680
you can't stop them they'll use they'll

00:32:00,550 --> 00:32:06,130
use pad Walker and get on the inside

00:32:02,680 --> 00:32:08,320
anyway but for the 99 percent of it this

00:32:06,130 --> 00:32:12,070
is a really good way to make sure that

00:32:08,320 --> 00:32:13,990
things just work the other thing is

00:32:12,070 --> 00:32:15,910
there's really good documentation for

00:32:13,990 --> 00:32:18,850
these things does it anywhere really

00:32:15,910 --> 00:32:20,410
enjoy writing pod I mean you just can't

00:32:18,850 --> 00:32:22,960
wait to get up in the morning and put

00:32:20,410 --> 00:32:24,790
little equal signs and do a like it you

00:32:22,960 --> 00:32:29,230
guys forget about it the rest of us

00:32:24,790 --> 00:32:31,870
these are documented already why spend

00:32:29,230 --> 00:32:33,310
your life describing how to compute this

00:32:31,870 --> 00:32:35,650
stuff when someone else is already

00:32:33,310 --> 00:32:38,860
written really good instructions with

00:32:35,650 --> 00:32:40,390
examples that work people forget about

00:32:38,860 --> 00:32:42,450
that yeah I could do all this in pure

00:32:40,390 --> 00:32:46,240
Pro but they don't have to document it

00:32:42,450 --> 00:32:48,220
you're not we're programmers pot is a

00:32:46,240 --> 00:32:50,080
very good thing but if there's that much

00:32:48,220 --> 00:32:52,120
less documentation you have to write

00:32:50,080 --> 00:32:58,270
because someone's done it really really

00:32:52,120 --> 00:33:01,170
well go to seep in anyway oh oops I

00:32:58,270 --> 00:33:04,360
slipped aside first thing why bother

00:33:01,170 --> 00:33:09,010
oops I lost the slide acting is a really

00:33:04,360 --> 00:33:16,240
good pun on there oh damn second thing

00:33:09,010 --> 00:33:20,860
is first anyway first thing my father

00:33:16,240 --> 00:33:28,380
the second thing up well first I'm sorry

00:33:20,860 --> 00:33:28,380
about that but it's like at home anyway

00:33:28,860 --> 00:33:35,890
what first looks a lot like grep it

00:33:33,220 --> 00:33:38,860
takes it there's a you have grep with a

00:33:35,890 --> 00:33:40,760
block and a dollar underscore and for

00:33:38,860 --> 00:33:44,360
every place the block returns

00:33:40,760 --> 00:33:47,780
true you get the original value of what

00:33:44,360 --> 00:33:49,970
was fed into the block unlike map which

00:33:47,780 --> 00:33:51,470
will you get the modified value all you

00:33:49,970 --> 00:33:54,200
get are things that made the block

00:33:51,470 --> 00:33:57,590
turned true the difference between 1st

00:33:54,200 --> 00:34:01,430
and grep two important differences first

00:33:57,590 --> 00:34:05,000
returns a scalar and it stops after the

00:34:01,430 --> 00:34:06,560
first time it finds something so if you

00:34:05,000 --> 00:34:08,810
grep something the classic thing is you

00:34:06,560 --> 00:34:11,570
do a grep and you assign a variable and

00:34:08,810 --> 00:34:12,470
/ ends to the list but after you've done

00:34:11,570 --> 00:34:14,389
the assignment you're going to keep

00:34:12,470 --> 00:34:16,040
processing the list if the list isn't

00:34:14,389 --> 00:34:17,780
trivial you're going to waste a lot of

00:34:16,040 --> 00:34:20,840
time processing a lot of stuff you will

00:34:17,780 --> 00:34:22,100
never use and pearl doesn't know that

00:34:20,840 --> 00:34:27,169
you don't want to use it so it keeps

00:34:22,100 --> 00:34:29,179
going so first is faster it's also

00:34:27,169 --> 00:34:31,520
syntactically easier because if you

00:34:29,179 --> 00:34:33,169
leave the / ends off of the variable you

00:34:31,520 --> 00:34:34,880
don't get a count of the number of the

00:34:33,169 --> 00:34:38,030
things that matched you get the first

00:34:34,880 --> 00:34:41,570
item and there's something to be said

00:34:38,030 --> 00:34:43,490
for simpler syntax now one of the things

00:34:41,570 --> 00:34:46,100
that happen when smart matches came out

00:34:43,490 --> 00:34:47,929
is they can be faster than first at

00:34:46,100 --> 00:34:49,909
finding whether something is true one of

00:34:47,929 --> 00:34:56,149
the things used for first is is this

00:34:49,909 --> 00:34:58,220
scalar on a list obvious use of it so

00:34:56,149 --> 00:35:00,290
people compared first to smart matches

00:34:58,220 --> 00:35:02,800
at us smart matches are faster than

00:35:00,290 --> 00:35:05,060
first we don't need first any more wrong

00:35:02,800 --> 00:35:08,210
smart matches whether you like them or

00:35:05,060 --> 00:35:13,100
not return a boolean the most you can

00:35:08,210 --> 00:35:17,710
get out is quote quote or one first will

00:35:13,100 --> 00:35:17,710
actually give you the value that matched

00:35:18,130 --> 00:35:26,120
so that I can use the value for

00:35:20,900 --> 00:35:28,730
something else so being now we get to

00:35:26,120 --> 00:35:30,230
this thing a lot of times for the the

00:35:28,730 --> 00:35:31,940
smart metro operator that o is great

00:35:30,230 --> 00:35:34,610
because they do it can do generic

00:35:31,940 --> 00:35:37,130
matching whether it gets confusing or

00:35:34,610 --> 00:35:40,730
not you know pearl always gives you

00:35:37,130 --> 00:35:42,620
enough rope to shoot yourself so you

00:35:40,730 --> 00:35:47,830
know smart matches are one more case if

00:35:42,620 --> 00:35:47,830
you want simplicity you see by

00:35:48,200 --> 00:35:55,700
the the one thing you get a lot of times

00:35:50,750 --> 00:35:58,010
is well let's see smart matching is

00:35:55,700 --> 00:36:00,050
declarative so let's say one of the

00:35:58,010 --> 00:36:02,690
classic things we've all written is a

00:36:00,050 --> 00:36:05,570
command-line checker did you give me

00:36:02,690 --> 00:36:08,480
mutually exclusive items on the command

00:36:05,570 --> 00:36:10,099
line and you've seen the if this and

00:36:08,480 --> 00:36:11,960
that if this in this if this is

00:36:10,099 --> 00:36:13,670
something else and then you have to

00:36:11,960 --> 00:36:15,290
modify the command line and you blow the

00:36:13,670 --> 00:36:17,119
if block because you forgot to add one

00:36:15,290 --> 00:36:19,730
into the if block or you typo the if

00:36:17,119 --> 00:36:22,130
block or you drop something out this

00:36:19,730 --> 00:36:24,349
will check for everything in one step

00:36:22,130 --> 00:36:26,210
because you can say look here are the

00:36:24,349 --> 00:36:30,290
things that if I find them together

00:36:26,210 --> 00:36:33,859
we've blown it so the first time I find

00:36:30,290 --> 00:36:36,500
one of these pairings or triples or

00:36:33,859 --> 00:36:39,970
quadruples you don't care that all exist

00:36:36,500 --> 00:36:44,270
in the in the argument hash it's botched

00:36:39,970 --> 00:36:49,040
stop right out what the person blue and

00:36:44,270 --> 00:36:51,589
die we're done count the curly braces or

00:36:49,040 --> 00:36:53,359
not it's what six lines of code and it's

00:36:51,589 --> 00:36:55,819
declarative I can put these combinations

00:36:53,359 --> 00:36:57,920
outside the program in a flat file of

00:36:55,819 --> 00:37:00,260
bad options and people don't have to

00:36:57,920 --> 00:37:03,849
muck around in the code to change what

00:37:00,260 --> 00:37:08,569
we consider mutually exclusive switches

00:37:03,849 --> 00:37:11,180
so you can do a lot of things with smart

00:37:08,569 --> 00:37:13,160
match and and the the first operator

00:37:11,180 --> 00:37:18,560
that are really fast and do what you

00:37:13,160 --> 00:37:19,609
need um earning scalar I would I should

00:37:18,560 --> 00:37:23,800
I got to go faster because I've been

00:37:19,609 --> 00:37:26,599
running out one thing I use a lot people

00:37:23,800 --> 00:37:29,960
they will ask questions did I see a

00:37:26,599 --> 00:37:32,240
value by looking for hash keys that is

00:37:29,960 --> 00:37:34,369
slow you have to convert the thing to a

00:37:32,240 --> 00:37:35,630
hash key after new merrifield and then

00:37:34,369 --> 00:37:38,119
you're walking down a list anyway to

00:37:35,630 --> 00:37:40,160
dealing with collision chains for

00:37:38,119 --> 00:37:41,930
moderately set for really really huge

00:37:40,160 --> 00:37:45,410
lists where it's all collision chain

00:37:41,930 --> 00:37:47,869
city anyway or really small lists we're

00:37:45,410 --> 00:37:51,230
computing the hash key values is

00:37:47,869 --> 00:37:55,490
expensive you might find that first on

00:37:51,230 --> 00:37:57,800
an array is faster than hash lookups so

00:37:55,490 --> 00:38:01,819
if the only thing you're asking is have

00:37:57,800 --> 00:38:04,009
I seen this value in this session

00:38:01,819 --> 00:38:10,910
first on an array may actually be faster

00:38:04,009 --> 00:38:13,849
than doing hash lookups on everything if

00:38:10,910 --> 00:38:17,059
you have if you have lists of reg axis I

00:38:13,849 --> 00:38:22,910
can find the first regular expression

00:38:17,059 --> 00:38:25,519
that matched my data very quickly that

00:38:22,910 --> 00:38:28,910
allows me to without a lot of if logic I

00:38:25,519 --> 00:38:32,420
can validate did I get a usable line on

00:38:28,910 --> 00:38:36,559
the input I can say first of things that

00:38:32,420 --> 00:38:38,359
match usable input or die I can iterate

00:38:36,559 --> 00:38:40,459
lists of objects and find the first

00:38:38,359 --> 00:38:43,130
object that knows how to handle the data

00:38:40,459 --> 00:38:46,069
in Perl 6 this is kind of cute because

00:38:43,130 --> 00:38:48,410
you are even in pro 5 brian foy wrote a

00:38:46,069 --> 00:38:50,390
really good article on how to use the

00:38:48,410 --> 00:38:53,089
named captures to parse fairly

00:38:50,390 --> 00:38:54,979
complicated data within the reg ex well

00:38:53,089 --> 00:38:59,680
I can say find me the first reg ex that

00:38:54,979 --> 00:38:59,680
successfully parses the data and stop

00:39:02,259 --> 00:39:11,209
what's cute about this too is my found

00:39:08,690 --> 00:39:12,410
is yeah so if I have a bunch of known

00:39:11,209 --> 00:39:16,039
structures again this is great for

00:39:12,410 --> 00:39:18,589
validating xml simple if i think i'm

00:39:16,039 --> 00:39:20,239
supposed to get at least this many keys

00:39:18,589 --> 00:39:23,690
depending on what kind of data that i

00:39:20,239 --> 00:39:26,209
read and i have an array that has a ray

00:39:23,690 --> 00:39:28,910
rafts with the minimum number of keys it

00:39:26,209 --> 00:39:31,369
takes to make a well-formed record i can

00:39:28,910 --> 00:39:34,339
say walk down it and find me the first

00:39:31,369 --> 00:39:37,940
collection of keys that make me believe

00:39:34,339 --> 00:39:43,299
I've got enough data to process know if

00:39:37,940 --> 00:39:45,709
logic now another cute thing you can do

00:39:43,299 --> 00:39:49,009
and this will be the last thing I show

00:39:45,709 --> 00:39:50,539
on first time but the a lot of times

00:39:49,009 --> 00:39:52,579
you'll have something where you want to

00:39:50,539 --> 00:39:56,299
segregate data based on a regular

00:39:52,579 --> 00:39:57,979
expression or a subroutine execution not

00:39:56,299 --> 00:40:00,079
a fair ones but you you're getting a

00:39:57,979 --> 00:40:02,779
whole lot of log entries you want to

00:40:00,079 --> 00:40:05,269
either discard them or put or bucket

00:40:02,779 --> 00:40:08,329
them by which service or bucket them by

00:40:05,269 --> 00:40:11,839
you know what time of day bucket them by

00:40:08,329 --> 00:40:13,699
whether they were errors or not if I

00:40:11,839 --> 00:40:15,440
have a bunch of regular expressions I

00:40:13,699 --> 00:40:17,750
can take the reference a

00:40:15,440 --> 00:40:20,240
rest of the regular expression and use

00:40:17,750 --> 00:40:23,300
that to store data that i got from that

00:40:20,240 --> 00:40:26,359
expression so i can have a list of

00:40:23,300 --> 00:40:29,930
filters for each line of input i find

00:40:26,359 --> 00:40:32,900
the first filter that matches this row

00:40:29,930 --> 00:40:37,760
and stop at that point I can use the

00:40:32,900 --> 00:40:40,640
reference address to store the date to

00:40:37,760 --> 00:40:45,560
get data out of it or I can even push on

00:40:40,640 --> 00:40:48,560
to a list based on the ref adder and I

00:40:45,560 --> 00:40:50,060
can segregate all my records based on

00:40:48,560 --> 00:40:53,270
the regular expression with know if

00:40:50,060 --> 00:40:55,819
logic I find it i use it I go on to the

00:40:53,270 --> 00:40:57,349
next record it's a lot less code and

00:40:55,819 --> 00:40:58,550
then you don't have the if logic is

00:40:57,349 --> 00:41:00,050
usually where you end up typing

00:40:58,550 --> 00:41:08,240
something that blows the whole thing up

00:41:00,050 --> 00:41:11,180
ah again you can use the same idea I can

00:41:08,240 --> 00:41:13,880
find the first thing that matches if I

00:41:11,180 --> 00:41:17,060
have an inside-out structure I can have

00:41:13,880 --> 00:41:19,520
anonymous subroutines keyed to the

00:41:17,060 --> 00:41:21,079
regular expression I can use the ref

00:41:19,520 --> 00:41:23,150
adder the expression to find a writ to

00:41:21,079 --> 00:41:24,500
find the handler I can dispatch the

00:41:23,150 --> 00:41:28,880
handler if the regular expression

00:41:24,500 --> 00:41:32,569
matches reduce minimum maximum that can

00:41:28,880 --> 00:41:34,849
all be done in terms of reduce what it

00:41:32,569 --> 00:41:38,329
does is it takes a and B do your first

00:41:34,849 --> 00:41:41,359
two items compares them the result goes

00:41:38,329 --> 00:41:44,599
ended in a and then it gets the next

00:41:41,359 --> 00:41:48,020
item so this shows you what men and min

00:41:44,599 --> 00:41:50,930
and Max are just reduces with

00:41:48,020 --> 00:41:53,270
pre-assigned blocks if you want to get

00:41:50,930 --> 00:41:55,849
the sum of x squared you can take zero

00:41:53,270 --> 00:42:00,140
and a list and it's you add in the

00:41:55,849 --> 00:42:03,079
square the next number so there this is

00:42:00,140 --> 00:42:05,560
actually really nice for moving averages

00:42:03,079 --> 00:42:07,970
even because you can push it onto a list

00:42:05,560 --> 00:42:10,940
there's a lot you can do in there but

00:42:07,970 --> 00:42:12,589
again this is this is something that if

00:42:10,940 --> 00:42:16,130
you take the time to read up on it and

00:42:12,589 --> 00:42:18,500
the pods got good examples it works the

00:42:16,130 --> 00:42:20,510
last thing is there's list more utils

00:42:18,500 --> 00:42:23,960
now that I've shown you all of this no

00:42:20,510 --> 00:42:27,440
that's not all of it anytime you find

00:42:23,960 --> 00:42:29,029
that you're thinking about playing with

00:42:27,440 --> 00:42:30,799
array indexes and adding

00:42:29,029 --> 00:42:32,929
under them to do something don't bother

00:42:30,799 --> 00:42:37,309
it's probably in here this is a perfect

00:42:32,929 --> 00:42:39,890
example of a kitchen sink these are the

00:42:37,309 --> 00:42:42,109
mean you can find it you can find all of

00:42:39,890 --> 00:42:44,029
something any of something if none of

00:42:42,109 --> 00:42:46,549
them if you can say if none of the

00:42:44,029 --> 00:42:49,369
things on this list match what the block

00:42:46,549 --> 00:42:51,559
returns if any one of them does if not

00:42:49,369 --> 00:42:54,709
all of them you can ask if the thing is

00:42:51,559 --> 00:42:59,299
true for I've just I'll show you a few

00:42:54,709 --> 00:43:01,400
of these that I use first we gone over

00:42:59,299 --> 00:43:05,900
that a lot ever want to find the last

00:43:01,400 --> 00:43:07,549
thing that matches I did something may

00:43:05,900 --> 00:43:09,169
have to deal with find me the last piece

00:43:07,549 --> 00:43:10,759
of input that was valid if you're trying

00:43:09,169 --> 00:43:13,249
to validate a whole record or something

00:43:10,759 --> 00:43:15,589
well that requires reversing the list if

00:43:13,249 --> 00:43:18,109
you use first accept that list more

00:43:15,589 --> 00:43:20,119
utils is you last it will compare

00:43:18,109 --> 00:43:21,859
everything it'll find which it'll

00:43:20,119 --> 00:43:24,709
remember the last thing that matched and

00:43:21,859 --> 00:43:26,539
it will give you the last one you can

00:43:24,709 --> 00:43:30,349
get the first index you can get the last

00:43:26,539 --> 00:43:33,529
index and that those will give you the

00:43:30,349 --> 00:43:36,229
eye on the GV the index number of the

00:43:33,529 --> 00:43:43,130
item on the array that did the match

00:43:36,229 --> 00:43:45,619
before and after arm do slicing based on

00:43:43,130 --> 00:43:47,839
first index to get you an item that

00:43:45,619 --> 00:43:51,049
happened before the first time something

00:43:47,839 --> 00:43:55,189
matched so if you have an error you can

00:43:51,049 --> 00:44:01,609
find the last good piece of input these

00:43:55,189 --> 00:44:06,169
are also nice and testing there's an any

00:44:01,609 --> 00:44:09,349
operator first the difference between

00:44:06,169 --> 00:44:12,739
first and any is that first gives you

00:44:09,349 --> 00:44:15,349
the value put into the block that left

00:44:12,739 --> 00:44:20,059
the block true any gives you the result

00:44:15,349 --> 00:44:22,309
of the block that was true so first

00:44:20,059 --> 00:44:24,319
we'll tell you the first item on a list

00:44:22,309 --> 00:44:28,599
that was defined any will give you the

00:44:24,319 --> 00:44:28,599
value of defined that was on the list

00:44:35,330 --> 00:44:40,760
if that's one way to do it if any of

00:44:38,360 --> 00:44:42,680
these is true but again there are times

00:44:40,760 --> 00:44:45,440
when what you want is a more map ish

00:44:42,680 --> 00:44:49,010
behavior where you want to see what was

00:44:45,440 --> 00:44:51,350
the value that made the block true so

00:44:49,010 --> 00:44:53,420
any any is like an aborting version of

00:44:51,350 --> 00:44:55,760
map the first time the map outputs a

00:44:53,420 --> 00:44:58,460
true value you get the true value so if

00:44:55,760 --> 00:45:00,290
you're running a subroutine and you want

00:44:58,460 --> 00:45:02,360
to see show me the first thing that the

00:45:00,290 --> 00:45:05,510
subroutine was true for you'll get the

00:45:02,360 --> 00:45:06,590
value but a lot of times it depends what

00:45:05,510 --> 00:45:08,690
you're using it for it but you can get

00:45:06,590 --> 00:45:10,310
either way because you got mapped this

00:45:08,690 --> 00:45:11,870
is pearl there's more than one way to do

00:45:10,310 --> 00:45:15,740
it and this will give you all the ways

00:45:11,870 --> 00:45:17,300
there are unique was one thing that was

00:45:15,740 --> 00:45:18,950
left out everybody why not eat well you

00:45:17,300 --> 00:45:21,110
put things into a hash you can get the

00:45:18,950 --> 00:45:24,080
unique out but unique is interesting

00:45:21,110 --> 00:45:25,490
because it preserves order every time it

00:45:24,080 --> 00:45:27,350
sees something it just keeps skipping

00:45:25,490 --> 00:45:29,780
the rest of them so it doesn't sort your

00:45:27,350 --> 00:45:32,750
data if you want to find a unique list

00:45:29,780 --> 00:45:34,340
of error messages and you want to keep

00:45:32,750 --> 00:45:35,990
the error messages pretty much in their

00:45:34,340 --> 00:45:38,330
original order because you're trying to

00:45:35,990 --> 00:45:40,880
find where in a log did the or do the

00:45:38,330 --> 00:45:42,920
errors happen where their warnings first

00:45:40,880 --> 00:45:44,600
where they're not warnings first you can

00:45:42,920 --> 00:45:50,180
unique fi them and see oh yeah there

00:45:44,600 --> 00:45:54,190
were no warnings before this error then

00:45:50,180 --> 00:45:57,020
doing this in pure pearl is slow

00:45:54,190 --> 00:45:58,850
relative locations there insert after an

00:45:57,020 --> 00:46:02,200
insert before insert after is really

00:45:58,850 --> 00:46:06,100
neat if you are trying to segment data

00:46:02,200 --> 00:46:08,540
because you can find the first thing if

00:46:06,100 --> 00:46:11,030
you find the first thing that matches

00:46:08,540 --> 00:46:12,650
whatever you're doing and you want to

00:46:11,030 --> 00:46:16,570
say ok I found this I now know where the

00:46:12,650 --> 00:46:19,490
end of a block and my data is insert the

00:46:16,570 --> 00:46:22,850
insert after will find your thing and

00:46:19,490 --> 00:46:26,810
then put a value after it if that made

00:46:22,850 --> 00:46:30,470
any sense insert before does kind of

00:46:26,810 --> 00:46:32,480
what you think it would map one of the

00:46:30,470 --> 00:46:34,100
downsides to map and grip and sort

00:46:32,480 --> 00:46:36,080
people don't realize if you modify

00:46:34,100 --> 00:46:39,830
dollar a and B in a sort you will be

00:46:36,080 --> 00:46:44,120
mucking around with your input data what

00:46:39,830 --> 00:46:46,880
the apply function does is it's like map

00:46:44,120 --> 00:46:48,430
but it localizes dollar underscore so

00:46:46,880 --> 00:46:51,230
that it doesn't affect

00:46:48,430 --> 00:46:52,520
so you're dealing with the values on

00:46:51,230 --> 00:46:54,290
your list you are not dealing with

00:46:52,520 --> 00:46:57,920
references to them it's a little bit

00:46:54,290 --> 00:46:59,750
slower because it copies things but for

00:46:57,920 --> 00:47:02,390
for a lot of cases people who've I know

00:46:59,750 --> 00:47:05,090
you know people you uppercase whatever

00:47:02,390 --> 00:47:07,580
it is your reg exit to compare it a

00:47:05,090 --> 00:47:09,500
certain way and oh yeah I've just

00:47:07,580 --> 00:47:11,510
modified all my input you may want that

00:47:09,500 --> 00:47:14,990
but usually you don't so apply doesn't

00:47:11,510 --> 00:47:21,110
have side effects merging lists you can

00:47:14,990 --> 00:47:25,250
get pairwise you can get in at a time so

00:47:21,110 --> 00:47:28,010
you can get things out of this where if

00:47:25,250 --> 00:47:29,840
you have two lists and you want to get

00:47:28,010 --> 00:47:31,100
the first item on each list and then the

00:47:29,840 --> 00:47:33,680
second item on ease because you're

00:47:31,100 --> 00:47:35,390
comparing the two lists in pure pearl

00:47:33,680 --> 00:47:37,610
you either have to use indexes which is

00:47:35,390 --> 00:47:40,550
slow or you have to destroy the list by

00:47:37,610 --> 00:47:44,330
shipping things off or you can use

00:47:40,550 --> 00:47:47,270
pairwise which given to list returns an

00:47:44,330 --> 00:47:48,650
iterator and each time you call the

00:47:47,270 --> 00:47:50,300
iterator it gives you the next two

00:47:48,650 --> 00:47:52,160
things on a list and because it's

00:47:50,300 --> 00:47:57,680
written in C it can have pointers so it

00:47:52,160 --> 00:48:00,830
just advances them um there's also lets

00:47:57,680 --> 00:48:03,200
Eve another thing because these use

00:48:00,830 --> 00:48:07,370
prototypes in order to pass two arrays

00:48:03,200 --> 00:48:09,830
in and note and keep them separate you

00:48:07,370 --> 00:48:12,020
have to use prototypes to convert the at

00:48:09,830 --> 00:48:14,510
signs basically to backslash at signs

00:48:12,020 --> 00:48:17,450
when it's red you have to use arrays

00:48:14,510 --> 00:48:20,600
with these if you use array reps you're

00:48:17,450 --> 00:48:22,520
going to blow it up you can iterate

00:48:20,600 --> 00:48:25,220
separate lists you can get each thing

00:48:22,520 --> 00:48:27,500
out of an array so if you give a list of

00:48:25,220 --> 00:48:29,030
arrays however long it is you'll get

00:48:27,500 --> 00:48:30,590
that one thing that each time you call

00:48:29,030 --> 00:48:32,360
it gives you the next thing on each each

00:48:30,590 --> 00:48:36,020
list or undef if there's nothing left

00:48:32,360 --> 00:48:38,150
there so yeah there's a lot of stuff

00:48:36,020 --> 00:48:39,710
we've all done with indexes that you

00:48:38,150 --> 00:48:41,480
know diz do the index run outta to do

00:48:39,710 --> 00:48:46,670
this do they do it's all done in one

00:48:41,480 --> 00:48:49,670
step no it'll go it'll give you an if

00:48:46,670 --> 00:48:52,930
you give it a raise a B and C on the way

00:48:49,670 --> 00:48:54,880
in each time you call this you will get

00:48:52,930 --> 00:48:57,069
penises I get the zeroth item on each

00:48:54,880 --> 00:48:59,650
it's doing a vertical slice through all

00:48:57,069 --> 00:49:01,559
three arrays which again it's really

00:48:59,650 --> 00:49:04,540
nice for processing log files for

00:49:01,559 --> 00:49:06,700
comparative data for a lot of stuff you

00:49:04,540 --> 00:49:09,220
might if you want to use piddle just to

00:49:06,700 --> 00:49:12,880
walk down a bunch of multiplies you you

00:49:09,220 --> 00:49:14,740
could use this last two things our pot

00:49:12,880 --> 00:49:17,619
is your friend these have got lots of

00:49:14,740 --> 00:49:19,510
documentation in it and there are

00:49:17,619 --> 00:49:22,540
examples of how to use them why to use

00:49:19,510 --> 00:49:24,190
them list more utils take the time to

00:49:22,540 --> 00:49:26,200
read through the pod because there's

00:49:24,190 --> 00:49:28,200
there's more in here than that anyone's

00:49:26,200 --> 00:49:31,329
going to stay awake with me describing

00:49:28,200 --> 00:49:33,160
so the real short of it that is these

00:49:31,329 --> 00:49:35,710
and a lot of like them on cpat have been

00:49:33,160 --> 00:49:38,500
around for a long time it's a good thing

00:49:35,710 --> 00:49:40,480
about pearl this excess code which

00:49:38,500 --> 00:49:42,690
really deals with the guts of Pearl has

00:49:40,480 --> 00:49:45,730
been around this long and it still works

00:49:42,690 --> 00:49:47,710
that's pretty good these guys haven't

00:49:45,730 --> 00:49:49,359
torn their hair out maintaining it a lot

00:49:47,710 --> 00:49:51,970
of people complained all pearl doesn't

00:49:49,359 --> 00:49:54,190
do this it hasn't evolved fast enough

00:49:51,970 --> 00:49:56,140
but the guts of pearl have managed to

00:49:54,190 --> 00:49:59,109
keep all the stuff in cPanel live for

00:49:56,140 --> 00:50:03,160
this long the stuff isn't moldy it's

00:49:59,109 --> 00:50:04,690
still relevant so smart matches are

00:50:03,160 --> 00:50:06,190
really nice with first they're really

00:50:04,690 --> 00:50:12,730
nice with a lot of these lists operators

00:50:06,190 --> 00:50:15,670
and any time you think about doing index

00:50:12,730 --> 00:50:17,920
math don't you probably can do it easier

00:50:15,670 --> 00:50:21,790
with these and faster and with a lot

00:50:17,920 --> 00:50:23,650
less code so yeah the truly lazy wheel

00:50:21,790 --> 00:50:28,240
is the one we don't have to reinvent

00:50:23,650 --> 00:50:31,230
every time you do something now is it is

00:50:28,240 --> 00:50:31,230

YouTube URL: https://www.youtube.com/watch?v=FhqQIWmIwp0


