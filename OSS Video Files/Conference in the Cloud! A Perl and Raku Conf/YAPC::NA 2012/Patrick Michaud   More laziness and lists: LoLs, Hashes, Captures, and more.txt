Title: Patrick Michaud   More laziness and lists: LoLs, Hashes, Captures, and more
Publication date: 2013-08-20
Playlist: YAPC::NA 2012
Description: 
	
Captions: 
	00:00:00,620 --> 00:00:06,299
so all right it's after one 30 so I'm

00:00:04,350 --> 00:00:08,010
going to go ahead and start I'm pleased

00:00:06,299 --> 00:00:10,620
that the number of people who are here I

00:00:08,010 --> 00:00:15,630
hope I'm not going to be too technical

00:00:10,620 --> 00:00:17,430
but but I think you'll enjoy it and if

00:00:15,630 --> 00:00:19,949
you have questions as I give the top

00:00:17,430 --> 00:00:21,240
then please feel free to to ask as we

00:00:19,949 --> 00:00:25,320
did yesterday if you attended

00:00:21,240 --> 00:00:27,930
yesterday's talk we get my controller

00:00:25,320 --> 00:00:29,340
here working so this talk is more

00:00:27,930 --> 00:00:30,779
laziness and list it's kind of a

00:00:29,340 --> 00:00:34,469
follow-on to the talk I gave yesterday

00:00:30,779 --> 00:00:36,809
and I'm coming up with alternate titles

00:00:34,469 --> 00:00:41,280
for this and so far the best one i have

00:00:36,809 --> 00:00:43,649
is Perl 6 list the the the good the ugly

00:00:41,280 --> 00:00:45,360
and the I'm trying to figure out what to

00:00:43,649 --> 00:00:50,340
put in after ugly but has to do

00:00:45,360 --> 00:00:52,140
something with insanity so and I thought

00:00:50,340 --> 00:00:55,020
about just leaving a whatever star but I

00:00:52,140 --> 00:00:56,579
wasn't going to necessarily do that so

00:00:55,020 --> 00:00:59,820
first of all I'll start with an

00:00:56,579 --> 00:01:01,680
introduction and recap in yesterday's

00:00:59,820 --> 00:01:05,189
talk i focused on lists and arrays we're

00:01:01,680 --> 00:01:07,799
going to do more that today but at some

00:01:05,189 --> 00:01:09,960
of the more deeper details we covered

00:01:07,799 --> 00:01:12,299
list interpolation basics some basics

00:01:09,960 --> 00:01:14,939
about infinite lists talked about how

00:01:12,299 --> 00:01:17,700
arrays work parcels slurping lists and

00:01:14,939 --> 00:01:19,350
lists of lists this talk covers more of

00:01:17,700 --> 00:01:21,960
the internal details of the Perl 6

00:01:19,350 --> 00:01:23,820
aggregates so this talk covers it

00:01:21,960 --> 00:01:25,229
ervil's and iterators a little bit of

00:01:23,820 --> 00:01:27,390
hash basics and if there's time

00:01:25,229 --> 00:01:29,430
permitting I'll go into a little bit

00:01:27,390 --> 00:01:32,790
about captures but I'm somehow doubtful

00:01:29,430 --> 00:01:35,100
that i'll get that far so we'll see cuz

00:01:32,790 --> 00:01:37,409
there's I already know there's like 40

00:01:35,100 --> 00:01:41,220
slides in this presentation so it's

00:01:37,409 --> 00:01:44,159
going to be hard to do in 40 minutes so

00:01:41,220 --> 00:01:46,170
a more view from last time if you go and

00:01:44,159 --> 00:01:49,680
read the synopsis which are the current

00:01:46,170 --> 00:01:51,030
Perl 6 language design documents and you

00:01:49,680 --> 00:01:53,070
read what they have to say about lists

00:01:51,030 --> 00:01:54,750
they're very out of date so don't trust

00:01:53,070 --> 00:01:56,399
anything you read there if you have a

00:01:54,750 --> 00:01:59,100
question you can email me ask on the

00:01:56,399 --> 00:02:02,579
channel variety of things until I get

00:01:59,100 --> 00:02:05,210
what is now in these presentations into

00:02:02,579 --> 00:02:05,210
the synopses

00:02:05,400 --> 00:02:10,390
yes yes you may it you probably can't

00:02:08,800 --> 00:02:12,100
see it but there's a URL at the bottom

00:02:10,390 --> 00:02:16,450
I'm going to add the talk URL to the

00:02:12,100 --> 00:02:18,900
page on the gap see schedule so that

00:02:16,450 --> 00:02:22,660
you'll be able to get to the slides

00:02:18,900 --> 00:02:30,780
right here I'll give you just a couple

00:02:22,660 --> 00:02:35,770
minutes here there that's the URL for

00:02:30,780 --> 00:02:40,990
the slides as they existed 20 minutes

00:02:35,770 --> 00:02:43,030
ago I made a couple of changes here so

00:02:40,990 --> 00:02:44,590
the current synopses are out of date so

00:02:43,030 --> 00:02:46,870
you can't really trust what they have to

00:02:44,590 --> 00:02:48,910
say we have these things called lists

00:02:46,870 --> 00:02:51,220
they are mutable sequences of objects

00:02:48,910 --> 00:02:52,780
and it's the sequence that's mutable not

00:02:51,220 --> 00:02:56,320
necessarily the objects they can be

00:02:52,780 --> 00:02:58,270
beautiful or immutable lists are lazy in

00:02:56,320 --> 00:03:00,370
Perl 6 and what that means is they have

00:02:58,270 --> 00:03:01,900
a reified part or the part that we've

00:03:00,370 --> 00:03:03,460
already figured out and they have a

00:03:01,900 --> 00:03:08,350
generator part which is the part we have

00:03:03,460 --> 00:03:09,910
yet to figure out reification is what we

00:03:08,350 --> 00:03:12,550
call the process of creating new

00:03:09,910 --> 00:03:14,650
elements when they're needed so if we

00:03:12,550 --> 00:03:17,140
have a list that has ten elements and we

00:03:14,650 --> 00:03:19,900
ask for element number 15 then it goes

00:03:17,140 --> 00:03:22,209
to the generator part to get elements 11

00:03:19,900 --> 00:03:24,580
through 15 so that it can return it and

00:03:22,209 --> 00:03:27,880
that's what we mean by on demand or done

00:03:24,580 --> 00:03:29,650
lazy lazily list in Perl 6 can be

00:03:27,880 --> 00:03:31,510
infinite it's possible to create lists

00:03:29,650 --> 00:03:33,280
that have an infinite number of elements

00:03:31,510 --> 00:03:37,330
and the laziness is what allows us to do

00:03:33,280 --> 00:03:39,100
that that it's conceptually infinite but

00:03:37,330 --> 00:03:41,950
we don't eat up space for things until

00:03:39,100 --> 00:03:43,570
we actually ask them arrays are a

00:03:41,950 --> 00:03:45,430
special type of list there a list of

00:03:43,570 --> 00:03:47,380
scalar containers the things you put

00:03:45,430 --> 00:03:48,580
into an array our copies of values as

00:03:47,380 --> 00:03:50,620
opposed to being the values themselves

00:03:48,580 --> 00:03:52,420
and if you do any sort of list

00:03:50,620 --> 00:03:54,370
assignment and Perl 6 it's done eagerly

00:03:52,420 --> 00:03:59,320
it kind of gets rid of laziness if

00:03:54,370 --> 00:04:00,340
you're assigning to a list I in

00:03:59,320 --> 00:04:02,200
yesterday's talk i talked about

00:04:00,340 --> 00:04:04,840
flattening a non flattening contacts

00:04:02,200 --> 00:04:06,880
flattening context will take parcels and

00:04:04,840 --> 00:04:09,730
interpolate them into the list so that

00:04:06,880 --> 00:04:11,500
it acts like what Perl 5 did if you had

00:04:09,730 --> 00:04:13,959
things in parentheses tended to flatten

00:04:11,500 --> 00:04:15,430
them out there's also a list context

00:04:13,959 --> 00:04:17,950
that will take anything and give you its

00:04:15,430 --> 00:04:18,760
list representation there's an item

00:04:17,950 --> 00:04:20,650
context

00:04:18,760 --> 00:04:22,540
prevents things from being flattened or

00:04:20,650 --> 00:04:25,090
interpolated and there's a list of Lists

00:04:22,540 --> 00:04:27,100
context that's why LOL stands for that

00:04:25,090 --> 00:04:30,220
will take parcels and turn them into

00:04:27,100 --> 00:04:33,220
items that don't flatten and we have

00:04:30,220 --> 00:04:34,510
ways in subroutines to be able to say

00:04:33,220 --> 00:04:36,550
that we want a list of arguments

00:04:34,510 --> 00:04:39,370
flattened or that we want a list of

00:04:36,550 --> 00:04:41,650
arguments not flattened and so those are

00:04:39,370 --> 00:04:43,720
the slurpee with a single star and the

00:04:41,650 --> 00:04:45,490
list of Lists with double stars to be

00:04:43,720 --> 00:04:47,560
able do that so before I go on any

00:04:45,490 --> 00:05:08,610
questions anything somebody wants me to

00:04:47,560 --> 00:05:11,020
cover real quick no yes yes yes and

00:05:08,610 --> 00:05:13,630
that's actually needs to be fixed even

00:05:11,020 --> 00:05:18,130
further so the question is if you do

00:05:13,630 --> 00:05:19,450
something like this dot INF then what

00:05:18,130 --> 00:05:22,300
you get back is it did the

00:05:19,450 --> 00:05:25,390
initialization there so we've created J

00:05:22,300 --> 00:05:28,090
which is a infinite array consisting of

00:05:25,390 --> 00:05:30,550
the values 1 through infinity and when

00:05:28,090 --> 00:05:32,620
the interactive mode went to display the

00:05:30,550 --> 00:05:35,290
value that came back it went to display

00:05:32,620 --> 00:05:38,170
it earlier versions of Kakuta would just

00:05:35,290 --> 00:05:40,360
put dot dot dot no they didn't they

00:05:38,170 --> 00:05:42,850
didn't go forever but they would just

00:05:40,360 --> 00:05:47,200
put dot so you had no idea what you got

00:05:42,850 --> 00:05:49,420
so when the printer part gets to the

00:05:47,200 --> 00:05:51,520
point of saying oh I have an infinite

00:05:49,420 --> 00:05:53,860
list what it currently does is it says

00:05:51,520 --> 00:05:55,600
make sure i have about four elements of

00:05:53,860 --> 00:05:57,310
that list to display before displaying

00:05:55,600 --> 00:05:59,020
the dot dot dot so at least you have

00:05:57,310 --> 00:06:02,470
some idea of the sequence that you're

00:05:59,020 --> 00:06:04,720
getting I'm going to want to change that

00:06:02,470 --> 00:06:07,960
so that it displays all of the values

00:06:04,720 --> 00:06:09,280
that already knows about and then do

00:06:07,960 --> 00:06:11,410
that and if there aren't enough of those

00:06:09,280 --> 00:06:12,970
then extended it it did some weird

00:06:11,410 --> 00:06:14,980
things for me as I was preparing a slide

00:06:12,970 --> 00:06:18,040
yesterday so I know there's a bug there

00:06:14,980 --> 00:06:19,660
it needs to be fixed but yes it it tries

00:06:18,040 --> 00:06:26,190
to give you an idea of what your

00:06:19,660 --> 00:06:29,050
infinite sequence is at that point yes

00:06:26,190 --> 00:06:32,240
one of the things about laziness and we

00:06:29,050 --> 00:06:35,070
mentioned it yesterday is that on

00:06:32,240 --> 00:06:37,440
by default you don't have an awful lot

00:06:35,070 --> 00:06:40,500
of control over it we're probably going

00:06:37,440 --> 00:06:43,050
to you know you can't easily say don't

00:06:40,500 --> 00:06:44,669
evaluate this you know something can go

00:06:43,050 --> 00:06:46,470
and ask for something and be able to do

00:06:44,669 --> 00:06:48,210
that there will probably be some

00:06:46,470 --> 00:06:49,889
constructs added that will let you say

00:06:48,210 --> 00:06:51,060
this needs to be really lazy and I

00:06:49,889 --> 00:06:52,740
really don't want you to do things

00:06:51,060 --> 00:06:59,970
unless you have to but we haven't

00:06:52,740 --> 00:07:02,820
defined at Ron window all right oh and

00:06:59,970 --> 00:07:05,849
then parcels parcels represent syntactic

00:07:02,820 --> 00:07:08,120
groups of objects so here we have two

00:07:05,849 --> 00:07:11,849
parcels we have one parcel containing

00:07:08,120 --> 00:07:14,490
hello and a the array a we have another

00:07:11,849 --> 00:07:17,039
parcel containing one to that parcel

00:07:14,490 --> 00:07:19,650
fraction five eighths and a half percent

00:07:17,039 --> 00:07:22,860
H ok and they flattened in some contexts

00:07:19,650 --> 00:07:24,180
and they itemize and others one of the

00:07:22,860 --> 00:07:25,530
things that I just wanted to repeat

00:07:24,180 --> 00:07:28,680
because we'll see it from time to time

00:07:25,530 --> 00:07:30,800
in this talk is that it's the comma that

00:07:28,680 --> 00:07:33,900
constructs a parcel and not the parents

00:07:30,800 --> 00:07:35,639
right so if you say parenthesis X Y Z

00:07:33,900 --> 00:07:37,500
close parenthesis a lot of people say oh

00:07:35,639 --> 00:07:39,210
that's a parcel containing XYZ and

00:07:37,500 --> 00:07:41,370
that's not what it is the prayers are

00:07:39,210 --> 00:07:43,860
just for grouping just like if I said

00:07:41,370 --> 00:07:46,490
parenthesis 2+3 close parenthesis that's

00:07:43,860 --> 00:07:49,680
a 5 it's not a parcel containing a five

00:07:46,490 --> 00:07:52,500
right um so it's the comma that creates

00:07:49,680 --> 00:07:54,210
a parcel if you need a parcel with just

00:07:52,500 --> 00:07:56,099
one item you use a trailing comma and

00:07:54,210 --> 00:07:59,130
that gives you a parcel with just one

00:07:56,099 --> 00:08:00,990
item the exception to that rule is that

00:07:59,130 --> 00:08:02,340
an empty parcel can be created by just

00:08:00,990 --> 00:08:08,280
doing two parents that gives you an

00:08:02,340 --> 00:08:10,370
empty parcel so I'm sorry that this last

00:08:08,280 --> 00:08:16,530
one

00:08:10,370 --> 00:08:18,000
more than the last one I not only that

00:08:16,530 --> 00:08:19,710
you can't actually you can make it a

00:08:18,000 --> 00:08:23,819
parcel but you're constantly packing and

00:08:19,710 --> 00:08:25,470
unpacking them then yeah so yeah so it's

00:08:23,819 --> 00:08:28,110
much easier if it's just not a parcel

00:08:25,470 --> 00:08:33,390
like if I'm doing a math formula where I

00:08:28,110 --> 00:08:35,039
say 3 plus perrin a times for I don't

00:08:33,390 --> 00:08:39,539
want it to become a parcel just because

00:08:35,039 --> 00:08:41,370
I put the parens there and then we have

00:08:39,539 --> 00:08:43,740
to have a leading comma thing and stuff

00:08:41,370 --> 00:08:47,160
like it this doesn't occur that often so

00:08:43,740 --> 00:08:49,370
it's it's bad that we have the exception

00:08:47,160 --> 00:08:53,970
we haven't figured out how to fix it yet

00:08:49,370 --> 00:08:56,010
talk to that guy I just implement what

00:08:53,970 --> 00:09:00,470
he says to do and tell him when he what

00:08:56,010 --> 00:09:03,060
he says to do is nuts but so already and

00:09:00,470 --> 00:09:05,149
then try and implement it anyway and say

00:09:03,060 --> 00:09:08,160
oh well that wasn't so nuts after all um

00:09:05,149 --> 00:09:11,550
so most list operations will flatten

00:09:08,160 --> 00:09:12,990
parcels so here I have an array with two

00:09:11,550 --> 00:09:16,829
elements two and three another array

00:09:12,990 --> 00:09:18,930
with two strings F and G and if i were

00:09:16,829 --> 00:09:21,029
to put these inside of parcels and ask

00:09:18,930 --> 00:09:24,390
for how many elements it is then it

00:09:21,029 --> 00:09:25,529
flattens it out like pearl would and if

00:09:24,390 --> 00:09:27,149
i asked for the fifth one I'm going to

00:09:25,529 --> 00:09:30,329
get the fifth one after flattening and

00:09:27,149 --> 00:09:31,709
not before actually now I think about it

00:09:30,329 --> 00:09:35,779
I don't know where this occurred that's

00:09:31,709 --> 00:09:41,940
a bug in recruit oh I believe so let me

00:09:35,779 --> 00:09:46,200
know I they could do that my B equals F

00:09:41,940 --> 00:09:48,959
G since I have the person who makes

00:09:46,200 --> 00:09:50,790
these decisions here is a captive

00:09:48,959 --> 00:09:59,320
audience

00:09:50,790 --> 00:10:02,890
you okay well it this this will be real

00:09:59,320 --> 00:10:08,649
quick so Larry do you agree with the

00:10:02,890 --> 00:10:09,940
slide that that should be seven that

00:10:08,649 --> 00:10:12,339
these should flatten out to give me

00:10:09,940 --> 00:10:15,360
seven elements and not the Elam because

00:10:12,339 --> 00:10:15,360
there's two things in the parcel

00:10:18,540 --> 00:10:24,430
operations on parcels flatten so so

00:10:22,300 --> 00:10:26,770
great so recruit Oh has that wrong Peter

00:10:24,430 --> 00:10:30,070
right so my slide is right recruiters

00:10:26,770 --> 00:10:33,580
wrong I I don't know when that bug

00:10:30,070 --> 00:10:34,810
entered but it will leave and it will

00:10:33,580 --> 00:10:37,480
leave by next Tuesday when the next

00:10:34,810 --> 00:10:38,950
release is what's interesting is

00:10:37,480 --> 00:10:41,940
apparently we don't have a spec test for

00:10:38,950 --> 00:10:45,010
it that bugs me we don't have a

00:10:41,940 --> 00:10:47,980
regression test for that so I just

00:10:45,010 --> 00:10:49,390
noticed that last week all right so if

00:10:47,980 --> 00:10:51,640
you need to explicitly flattened you can

00:10:49,390 --> 00:10:53,890
do that flat if you want to keep the

00:10:51,640 --> 00:10:55,390
parcels so they don't flatten then you

00:10:53,890 --> 00:10:57,430
can ask for a list of lists than they

00:10:55,390 --> 00:10:59,200
won't flatten so we can bring go from

00:10:57,430 --> 00:11:02,140
there all right so iteration and

00:10:59,200 --> 00:11:04,230
laziness so this is the part where we're

00:11:02,140 --> 00:11:07,029
going to get into the guts of how

00:11:04,230 --> 00:11:09,040
iteration and laziness actually work in

00:11:07,029 --> 00:11:11,170
recruit oh and some of the reasons why

00:11:09,040 --> 00:11:16,690
we had to get there parts of it are

00:11:11,170 --> 00:11:18,490
scary and pretty you know there there's

00:11:16,690 --> 00:11:20,440
a lot of details that goes into it in

00:11:18,490 --> 00:11:22,240
getting to this point I've gone through

00:11:20,440 --> 00:11:24,490
at least five different implementations

00:11:22,240 --> 00:11:26,380
that i know of each one was thrown out

00:11:24,490 --> 00:11:28,180
because it was obviously wrong which

00:11:26,380 --> 00:11:30,370
meant we had to change the spec which

00:11:28,180 --> 00:11:31,959
begat a new implementation which we

00:11:30,370 --> 00:11:33,790
discovered was wrong in other ways and

00:11:31,959 --> 00:11:37,660
so forth i have some examples of why

00:11:33,790 --> 00:11:40,480
that occurred so the key feature for

00:11:37,660 --> 00:11:42,850
iteration is iterators is to note that

00:11:40,480 --> 00:11:44,680
laziness can introduce many action at a

00:11:42,850 --> 00:11:46,540
distance effects and I'm going to show a

00:11:44,680 --> 00:11:49,540
couple of examples here so we had a lot

00:11:46,540 --> 00:11:51,640
of false starts one of them is that when

00:11:49,540 --> 00:11:53,079
implementing iterators you can either do

00:11:51,640 --> 00:11:54,760
things like iterate and throw away the

00:11:53,079 --> 00:11:57,550
things you've already iterated like a

00:11:54,760 --> 00:11:59,079
pipeline filter and that results data

00:11:57,550 --> 00:12:00,790
loss in the distance or you can keep

00:11:59,079 --> 00:12:02,020
everything but if you're trying to do

00:12:00,790 --> 00:12:03,610
something like a pipeline and you're

00:12:02,020 --> 00:12:06,160
processing a million elements

00:12:03,610 --> 00:12:07,300
you don't want to keep the first 900,000

00:12:06,160 --> 00:12:08,500
as you're working on the nine hundred

00:12:07,300 --> 00:12:10,630
thousand and one if you're actually

00:12:08,500 --> 00:12:12,360
doing it like a filter or pipeline so

00:12:10,630 --> 00:12:15,160
it's bad for pipelines and memory usage

00:12:12,360 --> 00:12:16,870
so the key insight that was developed is

00:12:15,160 --> 00:12:19,300
that our lists are mutable and our

00:12:16,870 --> 00:12:20,589
iterators act immutable and by that

00:12:19,300 --> 00:12:22,300
means is that once they come up with

00:12:20,589 --> 00:12:25,720
values they don't ever change their idea

00:12:22,300 --> 00:12:27,370
of what those values were okay so i'm

00:12:25,720 --> 00:12:30,760
going to open a block here with a no

00:12:27,370 --> 00:12:32,649
worries pragma which means that for the

00:12:30,760 --> 00:12:34,060
next few slides if it doesn't make any

00:12:32,649 --> 00:12:36,399
sense to you or you don't really know

00:12:34,060 --> 00:12:39,070
what's going on don't worry about it all

00:12:36,399 --> 00:12:40,420
right so there's there's a open block

00:12:39,070 --> 00:12:44,200
and we'll be in this so here's the basic

00:12:40,420 --> 00:12:46,000
challenge of iterators so one of the

00:12:44,200 --> 00:12:48,190
goals and one of the exercises that I

00:12:46,000 --> 00:12:50,140
would do on the channel is to say let's

00:12:48,190 --> 00:12:52,089
write a function like the map function

00:12:50,140 --> 00:12:53,470
that is going to process all of the

00:12:52,089 --> 00:12:56,649
elements of a list and apply a block to

00:12:53,470 --> 00:12:58,750
it okay so map generally acts like a

00:12:56,649 --> 00:13:00,880
filter in a pipeline so here's a naive

00:12:58,750 --> 00:13:02,649
implementation all right so in this

00:13:00,880 --> 00:13:05,620
implementation we have this subroutine

00:13:02,649 --> 00:13:07,300
called my map and we'll take a list as

00:13:05,620 --> 00:13:09,519
an argument the block is an argument and

00:13:07,300 --> 00:13:12,250
then we're going to count through the

00:13:09,519 --> 00:13:16,240
elements of the list as we go through it

00:13:12,250 --> 00:13:17,500
and as we go through each index then up

00:13:16,240 --> 00:13:21,190
to the number of elements in the list

00:13:17,500 --> 00:13:22,600
then will process the element from the

00:13:21,190 --> 00:13:23,920
list through the block and put it on the

00:13:22,600 --> 00:13:26,290
results and when we're done we'll return

00:13:23,920 --> 00:13:27,640
the results right there's a couple of

00:13:26,290 --> 00:13:30,459
things to note about this implementation

00:13:27,640 --> 00:13:32,829
first of all it's eager it's not lazy

00:13:30,459 --> 00:13:34,990
because map is going to process all of

00:13:32,829 --> 00:13:36,550
the elements before it returns all right

00:13:34,990 --> 00:13:38,140
and that's okay it's irrelevant to the

00:13:36,550 --> 00:13:39,820
point that i'm going to make but i did

00:13:38,140 --> 00:13:41,140
want to note it it's also eager because

00:13:39,820 --> 00:13:43,149
you a for how many elements are in the

00:13:41,140 --> 00:13:44,350
list so once you ask a list how many

00:13:43,149 --> 00:13:46,060
elements do you have it's going to go

00:13:44,350 --> 00:13:50,350
start generating them all so it can find

00:13:46,060 --> 00:13:51,490
out how many there are so that's one

00:13:50,350 --> 00:13:53,470
thing to note about this particular

00:13:51,490 --> 00:13:55,390
function another question that often

00:13:53,470 --> 00:13:56,890
comes up as they say well if you're

00:13:55,390 --> 00:13:58,660
doing a while loop here why not just put

00:13:56,890 --> 00:14:01,000
a for loop there to iterate through the

00:13:58,660 --> 00:14:02,800
elements and not do it with the while

00:14:01,000 --> 00:14:05,589
loop and left for take care of it well

00:14:02,800 --> 00:14:08,500
the answer is is that in Perl 6 map and

00:14:05,589 --> 00:14:09,820
for the same thing so you can't use

00:14:08,500 --> 00:14:12,250
forward to do it because that's what

00:14:09,820 --> 00:14:14,500
you're trying to implement all right and

00:14:12,250 --> 00:14:17,890
so just as a side note to this in pro 6

00:14:14,500 --> 00:14:19,600
if you say for list block where you're

00:14:17,890 --> 00:14:22,690
saying apply this block to all of the

00:14:19,600 --> 00:14:24,880
elements of list that's exactly the same

00:14:22,690 --> 00:14:28,329
at least in ruku toe as if you wrote

00:14:24,880 --> 00:14:30,190
this so make a parcel out of a list or

00:14:28,329 --> 00:14:32,380
make a particle containing the list and

00:14:30,190 --> 00:14:34,569
apply this block to every element of

00:14:32,380 --> 00:14:39,819
that particular list they are exactly

00:14:34,569 --> 00:14:41,560
the same ah because of good question so

00:14:39,819 --> 00:14:46,390
why does it have to be a parcel and the

00:14:41,560 --> 00:14:51,899
answer is because of this situation so

00:14:46,390 --> 00:14:54,040
if I have to tone my x equals something

00:14:51,899 --> 00:14:57,550
whatever it may happen to be and I say

00:14:54,040 --> 00:15:00,399
for dollar sign X lock how many

00:14:57,550 --> 00:15:03,790
iterations will that do it will do one

00:15:00,399 --> 00:15:06,480
and so the equivalent map because the

00:15:03,790 --> 00:15:10,480
it's a scalar so it won't flatten so

00:15:06,480 --> 00:15:13,029
therefore it's like that by putting it

00:15:10,480 --> 00:15:15,970
in the parcel it doesn't flatten if I

00:15:13,029 --> 00:15:18,550
left it without the parcel then what I'm

00:15:15,970 --> 00:15:20,230
actually doing is mapping on X that's

00:15:18,550 --> 00:15:23,019
self and if it's a list that's applying

00:15:20,230 --> 00:15:25,449
map directly to the list so that's in

00:15:23,019 --> 00:15:34,750
question that's the no worries pragma is

00:15:25,449 --> 00:15:42,579
still in effect yes it is the one for

00:15:34,750 --> 00:15:44,920
list yeah if you if you have if you have

00:15:42,579 --> 00:15:46,149
this situation there's a very good

00:15:44,920 --> 00:15:48,519
question so the question is if you have

00:15:46,149 --> 00:15:50,620
an array and you want it to flatten

00:15:48,519 --> 00:15:54,519
through a map can you do it and the

00:15:50,620 --> 00:15:56,860
answer is yes so if i have my x equals 1

00:15:54,519 --> 00:15:59,050
10 like so so that creates an array and

00:15:56,860 --> 00:16:04,930
it's in a scalar variable and if i want

00:15:59,050 --> 00:16:07,269
to do something to that like print out

00:16:04,930 --> 00:16:09,790
each element that will map over all of

00:16:07,269 --> 00:16:12,910
the elements of X because what I'm

00:16:09,790 --> 00:16:15,190
actually invoking it on is the array

00:16:12,910 --> 00:16:16,959
itself and the fact that it's a inner

00:16:15,190 --> 00:16:19,260
scalar is lost by the time you send the

00:16:16,959 --> 00:16:19,260
message

00:16:24,350 --> 00:16:28,800
yeah but it wouldn't matter there but

00:16:26,730 --> 00:16:30,720
the compiler doesn't figure that out you

00:16:28,800 --> 00:16:34,230
probably could to save the creation of

00:16:30,720 --> 00:16:36,120
the parcel yeah I wanted I wanted

00:16:34,230 --> 00:16:37,620
whatever I put inside the parents to

00:16:36,120 --> 00:16:40,230
exactly match their so if that was a

00:16:37,620 --> 00:16:45,480
dollar sign variable then I would need

00:16:40,230 --> 00:16:49,050
to come and make it a partial yes yeah

00:16:45,480 --> 00:16:51,180
and and if you actually go and look at

00:16:49,050 --> 00:16:53,100
the code that generates the for list

00:16:51,180 --> 00:16:57,350
you'll see that it actually creates a

00:16:53,100 --> 00:16:57,350
parcel calls map on it is actually

00:17:11,179 --> 00:17:21,240
everything that we so far we've so

00:17:19,650 --> 00:17:22,650
Larry's point is that we can make it

00:17:21,240 --> 00:17:24,720
into the functional form as well as a

00:17:22,650 --> 00:17:28,590
list where we're it's a list that's

00:17:24,720 --> 00:17:30,450
passed as a slurpee and I mean then

00:17:28,590 --> 00:17:33,840
you're actually creating an extra level

00:17:30,450 --> 00:17:35,910
of indirection for the slurpee that

00:17:33,840 --> 00:17:38,490
you're shifting off your processing the

00:17:35,910 --> 00:17:39,870
slurpee so all of your elements that

00:17:38,490 --> 00:17:41,520
you're going through have to go through

00:17:39,870 --> 00:17:43,350
this Slurpee because it's lazy and

00:17:41,520 --> 00:17:45,150
flattening and a variety things like

00:17:43,350 --> 00:17:48,600
that so you're adding an extra level of

00:17:45,150 --> 00:17:50,610
indirection and also in general we've

00:17:48,600 --> 00:17:52,799
tended to try to make our functions rely

00:17:50,610 --> 00:17:58,679
on our methods not our methods rely on

00:17:52,799 --> 00:18:02,010
our functions right so okay still no

00:17:58,679 --> 00:18:03,630
worries on if you've decided that this

00:18:02,010 --> 00:18:16,520
talk is not for you and you leave I'm

00:18:03,630 --> 00:18:21,780
not offended so that's why alrighty um

00:18:16,520 --> 00:18:23,460
so a map and for equivalent okay so this

00:18:21,780 --> 00:18:25,110
is the version that we just saw saw

00:18:23,460 --> 00:18:26,490
where we're using an index variable to

00:18:25,110 --> 00:18:28,950
account for all the elements let's try a

00:18:26,490 --> 00:18:31,200
different one oh let's look at what

00:18:28,950 --> 00:18:33,120
happens in this particular case and why

00:18:31,200 --> 00:18:34,890
it can be problematic so I have a

00:18:33,120 --> 00:18:36,480
filehandle here and I'm going to read

00:18:34,890 --> 00:18:38,760
all the lines from the file handle and

00:18:36,480 --> 00:18:40,380
that's going to occur lazily and I'm

00:18:38,760 --> 00:18:42,720
applied this block to all of the lines

00:18:40,380 --> 00:18:45,390
that i read from that particular file so

00:18:42,720 --> 00:18:46,679
when we're inside of this this function

00:18:45,390 --> 00:18:47,850
here and we're doing that the first

00:18:46,679 --> 00:18:49,799
thing we do is ask for the number of

00:18:47,850 --> 00:18:52,169
elements so we go in we get all the

00:18:49,799 --> 00:18:54,690
lines of the file into this array call

00:18:52,169 --> 00:18:56,880
that list and if that file was a million

00:18:54,690 --> 00:18:58,500
lines long we just filled out list with

00:18:56,880 --> 00:19:00,570
a million elements before we process to

00:18:58,500 --> 00:19:02,809
any of them and now we're going to start

00:19:00,570 --> 00:19:05,299
processing them and as we process them

00:19:02,809 --> 00:19:08,820
what happens to them they stay around

00:19:05,299 --> 00:19:10,440
right we're not throwing them away so

00:19:08,820 --> 00:19:12,179
the problem is is that list ends up

00:19:10,440 --> 00:19:13,890
holding all the lines and it's not

00:19:12,179 --> 00:19:15,900
acting like a pipeline filter normally

00:19:13,890 --> 00:19:17,970
if we think of like a unix pipeline we

00:19:15,900 --> 00:19:20,250
process something do something to it and

00:19:17,970 --> 00:19:22,169
we throw it away and that's really what

00:19:20,250 --> 00:19:24,120
we want map and for to kind of act like

00:19:22,169 --> 00:19:25,020
we don't want them to keep everything

00:19:24,120 --> 00:19:26,130
that they

00:19:25,020 --> 00:19:29,910
assess around when they're done with

00:19:26,130 --> 00:19:32,490
them so let's try and fix that let's try

00:19:29,910 --> 00:19:33,990
doing a shift instead of going through

00:19:32,490 --> 00:19:35,640
all of them so that as we process them

00:19:33,990 --> 00:19:38,790
weird actually take into them off of

00:19:35,640 --> 00:19:40,260
list and do it that way so for this

00:19:38,790 --> 00:19:41,610
particular function will take our list

00:19:40,260 --> 00:19:44,340
that we want to do the block we want to

00:19:41,610 --> 00:19:46,260
apply and will as long as there are more

00:19:44,340 --> 00:19:48,720
elements in the list we're going to

00:19:46,260 --> 00:19:51,210
shift the next element off the list send

00:19:48,720 --> 00:19:52,950
it to the block and push the results of

00:19:51,210 --> 00:19:55,770
that on to our result list and return it

00:19:52,950 --> 00:19:58,850
so now when we process all of the lines

00:19:55,770 --> 00:20:01,170
of this file as we read in the lines

00:19:58,850 --> 00:20:03,090
which is what will happen when we test

00:20:01,170 --> 00:20:05,400
to see if there's any more we will ship

00:20:03,090 --> 00:20:07,440
them off and push on the result so now

00:20:05,400 --> 00:20:13,350
it's acting like a pipeline that make

00:20:07,440 --> 00:20:18,290
sense any questions but so the lines are

00:20:13,350 --> 00:20:20,610
discarded but now what about this form

00:20:18,290 --> 00:20:24,330
okay so this is the same version I had

00:20:20,610 --> 00:20:25,860
with the shift so I'm going to say get

00:20:24,330 --> 00:20:27,450
all the lines of the file in lines and

00:20:25,860 --> 00:20:30,500
now I want to process this block on all

00:20:27,450 --> 00:20:32,970
those lines what happens to that array

00:20:30,500 --> 00:20:35,550
you actually shift off all the elements

00:20:32,970 --> 00:20:37,650
of that array as you're going through

00:20:35,550 --> 00:20:41,370
and doing it so when you get out of this

00:20:37,650 --> 00:20:43,530
now this array is empty because it

00:20:41,370 --> 00:20:46,530
shifted them all off and that is

00:20:43,530 --> 00:20:48,420
probably not what the programmer

00:20:46,530 --> 00:20:51,930
expected certainly not if they're a Perl

00:20:48,420 --> 00:20:53,610
5 program all right so we have that

00:20:51,930 --> 00:20:55,890
particular situation so this one's not

00:20:53,610 --> 00:21:00,180
going to work so we have this kind of

00:20:55,890 --> 00:21:01,410
contradiction between sometimes we're

00:21:00,180 --> 00:21:03,030
going to go through all the elements and

00:21:01,410 --> 00:21:05,190
we want to keep them around because

00:21:03,030 --> 00:21:05,880
they're bound somewhere and sometimes

00:21:05,190 --> 00:21:06,990
we're going to go through all the

00:21:05,880 --> 00:21:08,520
elements and we don't want them dizzy

00:21:06,990 --> 00:21:11,580
kept around because they're not bound

00:21:08,520 --> 00:21:13,260
and so it's kind of this bound versus

00:21:11,580 --> 00:21:14,820
unbound thing if it's been bound to a

00:21:13,260 --> 00:21:15,960
variable somewhere we want to keep it

00:21:14,820 --> 00:21:19,410
but if it hasn't we want it to be

00:21:15,960 --> 00:21:20,940
discarded as we process it and you know

00:21:19,410 --> 00:21:23,430
you can do things like well let's make a

00:21:20,940 --> 00:21:25,350
copy before we process it that kind of

00:21:23,430 --> 00:21:26,820
gets you know away from what we're

00:21:25,350 --> 00:21:28,170
trying to do which is to not eat up lots

00:21:26,820 --> 00:21:30,660
of memory and doing this and things like

00:21:28,170 --> 00:21:32,250
that okay so now we've reached the end

00:21:30,660 --> 00:21:33,900
of our no worries block if you didn't

00:21:32,250 --> 00:21:35,820
understand all of that don't worry about

00:21:33,900 --> 00:21:37,990
it after this part you can panic all you

00:21:35,820 --> 00:21:40,820
want all right

00:21:37,990 --> 00:21:42,919
so the implementation requirements that

00:21:40,820 --> 00:21:45,440
we have for perl 6 is listed iterator

00:21:42,919 --> 00:21:47,360
model is that lists and iterators must

00:21:45,440 --> 00:21:50,450
be able to handle varying degrees of

00:21:47,360 --> 00:21:52,240
laziness and eagerness varying degrees

00:21:50,450 --> 00:21:53,960
of finiteness and infinite list

00:21:52,240 --> 00:21:55,429
sometimes we have things that

00:21:53,960 --> 00:21:58,309
interpolate and sometimes they don't

00:21:55,429 --> 00:21:59,690
interpolate sometimes they flatten and

00:21:58,309 --> 00:22:01,700
sometimes we want to preserve the

00:21:59,690 --> 00:22:03,679
structures sometimes the lists are bound

00:22:01,700 --> 00:22:05,539
and they're unbound and sometimes we are

00:22:03,679 --> 00:22:07,460
aliasing two elements where we want our

00:22:05,539 --> 00:22:09,350
list to actually refer to the original

00:22:07,460 --> 00:22:13,250
element and sometimes we want them to be

00:22:09,350 --> 00:22:14,570
copied oh and by the way this is the

00:22:13,250 --> 00:22:16,100
programmer shouldn't be burdened with

00:22:14,570 --> 00:22:18,350
any of the details of knowing what's

00:22:16,100 --> 00:22:20,179
going on here it all happens generally

00:22:18,350 --> 00:22:21,919
dynamically so you're limited in terms

00:22:20,179 --> 00:22:23,570
of the static analysis you can do and

00:22:21,919 --> 00:22:32,539
because it's a core feature of Perl 6

00:22:23,570 --> 00:22:35,840
all of this has to be really fast this

00:22:32,539 --> 00:22:38,269
is why we had five different things this

00:22:35,840 --> 00:22:41,539
is how I often looked when we discovered

00:22:38,269 --> 00:22:45,200
something that wouldn't work by the way

00:22:41,539 --> 00:22:47,690
just for the record I blame this guy if

00:22:45,200 --> 00:22:50,269
that wasn't obvious already after all

00:22:47,690 --> 00:22:53,539
pearl philosophy is simply to torment

00:22:50,269 --> 00:22:59,980
the implementers that would be me on

00:22:53,539 --> 00:22:59,980
behalf of the user I love that quote

00:23:02,559 --> 00:23:08,299
well it has always been pearl philosophy

00:23:05,419 --> 00:23:10,909
that has always been pearl philosophy

00:23:08,299 --> 00:23:13,159
and I mean going back to my early days

00:23:10,909 --> 00:23:14,899
of pearl for what I really liked is the

00:23:13,159 --> 00:23:16,429
fact that I was no longer tormented by

00:23:14,899 --> 00:23:19,309
the things that all the other languages

00:23:16,429 --> 00:23:21,080
tormented me to do so that was there so

00:23:19,309 --> 00:23:23,389
the solution that we came up with

00:23:21,080 --> 00:23:24,679
finally after many failed designs is

00:23:23,389 --> 00:23:25,730
what we call immutable iterators and

00:23:24,679 --> 00:23:27,710
that's what I'm going to be talking

00:23:25,730 --> 00:23:30,980
about iterators are like cursors and

00:23:27,710 --> 00:23:34,820
they act like cursors so here are base

00:23:30,980 --> 00:23:37,250
classes um we have iterable these are

00:23:34,820 --> 00:23:38,600
things that can be iterated so they're

00:23:37,250 --> 00:23:40,100
objects that can produce an iterator

00:23:38,600 --> 00:23:41,539
when you need them to they have an

00:23:40,100 --> 00:23:44,059
iterator method that does that and

00:23:41,539 --> 00:23:46,370
iterable tend to interpolate enlist

00:23:44,059 --> 00:23:49,039
contexts unless they're in a container

00:23:46,370 --> 00:23:50,630
that says don't interpolate all right so

00:23:49,039 --> 00:23:52,430
examples of iterable zin

00:23:50,630 --> 00:23:58,400
who lists the Rays list of lists and so

00:23:52,430 --> 00:24:00,320
on file handle is not iterable but if

00:23:58,400 --> 00:24:03,560
you ask a filehandle for its lines

00:24:00,320 --> 00:24:06,020
that's a list which is iterable all

00:24:03,560 --> 00:24:07,940
right so file handle file and files was

00:24:06,020 --> 00:24:10,850
one of the weird things early versions

00:24:07,940 --> 00:24:12,740
of the Perl 6 specification really had

00:24:10,850 --> 00:24:16,100
trouble with iterators flattening and

00:24:12,740 --> 00:24:17,750
all this kind of stuff and what the

00:24:16,100 --> 00:24:19,790
whole goal of what I'm describing and

00:24:17,750 --> 00:24:31,340
that we came up with is your iterators

00:24:19,790 --> 00:24:32,690
are really hidden it thats and that's

00:24:31,340 --> 00:24:36,020
what will happen that's what does happen

00:24:32,690 --> 00:24:37,460
okay the the versions of map that were

00:24:36,020 --> 00:24:39,530
there weren't to demonstrate how we

00:24:37,460 --> 00:24:43,000
solved laziness they were to demonstrate

00:24:39,530 --> 00:24:45,290
the fact that bound and unbound okay

00:24:43,000 --> 00:24:46,910
alrighty so these are the other ones I

00:24:45,290 --> 00:24:49,010
should have put in here hash is an

00:24:46,910 --> 00:24:51,050
iterable also you can iterate over a

00:24:49,010 --> 00:24:52,610
hash and you get a list of pairs and

00:24:51,050 --> 00:24:54,230
there's a few others but I need to

00:24:52,610 --> 00:24:55,850
update my slide for that then we have

00:24:54,230 --> 00:24:57,020
the iterator base class it's an abstract

00:24:55,850 --> 00:24:59,180
both of these are really abstract

00:24:57,020 --> 00:25:02,420
classes that we expect you not to use

00:24:59,180 --> 00:25:04,610
them directly on the it inherits from

00:25:02,420 --> 00:25:07,460
iterable so every iterator is itself

00:25:04,610 --> 00:25:08,990
iterable because the key thing that

00:25:07,460 --> 00:25:11,330
makes something iterable is that it can

00:25:08,990 --> 00:25:12,740
return an iterator so an iterator when

00:25:11,330 --> 00:25:15,170
it's asked for an iterator just says

00:25:12,740 --> 00:25:17,180
self just returns itself and there you

00:25:15,170 --> 00:25:19,220
go these are the objects that perform

00:25:17,180 --> 00:25:20,750
the iteration their main method is

00:25:19,220 --> 00:25:21,710
something called reify that produces

00:25:20,750 --> 00:25:25,190
values and we're going to walk through

00:25:21,710 --> 00:25:27,980
that here and usually iterators are

00:25:25,190 --> 00:25:30,380
wrapped by some sort of a list so for

00:25:27,980 --> 00:25:31,820
example a filehandle if you're reading

00:25:30,380 --> 00:25:33,170
from a file there's an iterator down

00:25:31,820 --> 00:25:35,270
there that's doing all the work but what

00:25:33,170 --> 00:25:36,770
you see is a list of lines and you can

00:25:35,270 --> 00:25:38,900
treat it like a list of loans to do

00:25:36,770 --> 00:25:40,460
things with three of the common

00:25:38,900 --> 00:25:42,380
iterators our list diretor to iterate

00:25:40,460 --> 00:25:44,270
elements of list a map iterator which

00:25:42,380 --> 00:25:45,590
applies a block to list this is the part

00:25:44,270 --> 00:25:48,740
that handles laziness and block

00:25:45,590 --> 00:25:51,170
application there's a construct in Perl

00:25:48,740 --> 00:25:54,980
6 called gather take which allows you to

00:25:51,170 --> 00:25:57,140
start a subroutine and then it will only

00:25:54,980 --> 00:25:59,720
produce values that get returns in a

00:25:57,140 --> 00:26:01,310
sequence when you listen take and that

00:25:59,720 --> 00:26:03,050
happens lazily so there's a gather

00:26:01,310 --> 00:26:04,299
iterator for that and we're going to

00:26:03,050 --> 00:26:06,440
look at a couple of examples

00:26:04,299 --> 00:26:08,840
to look at it from a hierarchy

00:26:06,440 --> 00:26:10,460
perspective at the top of the hierarchy

00:26:08,840 --> 00:26:13,100
there's actually another class above

00:26:10,460 --> 00:26:16,460
this but start with any any as our base

00:26:13,100 --> 00:26:18,140
class for um for most common objects

00:26:16,460 --> 00:26:21,140
it's kind of the standard undefined type

00:26:18,140 --> 00:26:22,700
and has the methods that all the

00:26:21,140 --> 00:26:25,340
different objects are there's a subclass

00:26:22,700 --> 00:26:27,620
of that called cool which is common

00:26:25,340 --> 00:26:31,130
object oriented library or something

00:26:27,620 --> 00:26:33,350
like that it's basically the these are

00:26:31,130 --> 00:26:35,480
the this is the class of objects that

00:26:33,350 --> 00:26:38,480
tend to like to act like other so string

00:26:35,480 --> 00:26:40,909
and int and list since you can use a

00:26:38,480 --> 00:26:42,470
list like a number it's in cool since

00:26:40,909 --> 00:26:43,640
you can use a string like a number it's

00:26:42,470 --> 00:26:45,230
in cool and that's the thing that

00:26:43,640 --> 00:26:47,120
handles that breathing provides Taylor

00:26:45,230 --> 00:26:49,370
yeah profile scalars that's a good way

00:26:47,120 --> 00:26:51,200
of doing then there's iterable which is

00:26:49,370 --> 00:26:53,630
from cool and the iterable zor things

00:26:51,200 --> 00:26:55,730
like list which includes array and lists

00:26:53,630 --> 00:26:57,169
of lists and so forth and then the

00:26:55,730 --> 00:26:58,490
iterator subclass of that and then we

00:26:57,169 --> 00:27:00,230
have the various types of generators if

00:26:58,490 --> 00:27:03,740
you're wondering about that one I have a

00:27:00,230 --> 00:27:06,169
set of slides on it a little bit okay so

00:27:03,740 --> 00:27:08,870
for an iterator the key method is the

00:27:06,169 --> 00:27:10,370
reify method and you pass it a thing

00:27:08,870 --> 00:27:13,520
that says how many elements do you need

00:27:10,370 --> 00:27:16,580
so you could do an iterator where you

00:27:13,520 --> 00:27:18,080
always get one element at a time but if

00:27:16,580 --> 00:27:19,480
you do that at a method call level that

00:27:18,080 --> 00:27:22,520
means every time you want to get one

00:27:19,480 --> 00:27:24,320
element you're going and fetching one

00:27:22,520 --> 00:27:25,340
element and if you're need a thousand of

00:27:24,320 --> 00:27:27,169
them you're going to do a thousand

00:27:25,340 --> 00:27:29,539
method calls just to do it so it's

00:27:27,169 --> 00:27:32,210
parameterised that you can request I

00:27:29,539 --> 00:27:33,830
need a thousand elements and that way it

00:27:32,210 --> 00:27:35,390
cannot process them quickly and return

00:27:33,830 --> 00:27:37,070
you a thousand elements in a single

00:27:35,390 --> 00:27:39,530
method call instead of having to do a

00:27:37,070 --> 00:27:41,059
bunch of them to make that happen when

00:27:39,530 --> 00:27:43,039
you call reify what you get back is a

00:27:41,059 --> 00:27:45,440
parcel of all the reified values that

00:27:43,039 --> 00:27:47,720
the iterator produced and the iterator

00:27:45,440 --> 00:27:49,970
puts in that parcel any subsequent

00:27:47,720 --> 00:27:53,419
iterators that will be needed to

00:27:49,970 --> 00:27:55,820
continue getting more elements it's

00:27:53,419 --> 00:27:58,970
going to be a chain and will illustrate

00:27:55,820 --> 00:28:00,770
that in a second if you request dollar a

00:27:58,970 --> 00:28:03,559
certain number of elements an iterator

00:28:00,770 --> 00:28:05,960
is allowed to go fewer or greater than

00:28:03,559 --> 00:28:08,090
what you request in other words the the

00:28:05,960 --> 00:28:10,039
iterator kind of controls you say I want

00:28:08,090 --> 00:28:11,059
a thousand elements but if it says I'm

00:28:10,039 --> 00:28:13,549
going to go ahead and produce two

00:28:11,059 --> 00:28:15,169
thousand it can choose to do that now it

00:28:13,549 --> 00:28:16,550
depends on what it's iterating as to

00:28:15,169 --> 00:28:19,370
whether it will or not but

00:28:16,550 --> 00:28:20,990
it's allowed to work ahead if that if it

00:28:19,370 --> 00:28:23,510
thinks that that will be more optimal in

00:28:20,990 --> 00:28:28,670
the long run yeah like standard in

00:28:23,510 --> 00:28:30,680
buffering it will return all 2,000 okay

00:28:28,670 --> 00:28:32,090
but list normally you're not dealing

00:28:30,680 --> 00:28:34,370
with these lists already knows how to

00:28:32,090 --> 00:28:38,060
deal with that okay you can you can

00:28:34,370 --> 00:28:40,160
specify special values oh I turned off

00:28:38,060 --> 00:28:42,170
my pointer you can specify a special

00:28:40,160 --> 00:28:43,730
values in the thing like star the

00:28:42,170 --> 00:28:46,310
whatever star means give me whatever

00:28:43,730 --> 00:28:47,540
which basically tells an iterator go get

00:28:46,310 --> 00:28:50,060
me some more elements I don't care how

00:28:47,540 --> 00:28:51,440
many it's got to be at least one but get

00:28:50,060 --> 00:28:53,300
me some elements whatever you think is

00:28:51,440 --> 00:28:54,740
appropriate and given back to me and you

00:28:53,300 --> 00:28:56,960
can do in which says give me everything

00:28:54,740 --> 00:29:02,060
you have left or signal to me somehow

00:28:56,960 --> 00:29:03,500
that that would be silly um in general

00:29:02,060 --> 00:29:06,350
most programmers don't have to interact

00:29:03,500 --> 00:29:08,000
directly with iterator the one of the

00:29:06,350 --> 00:29:10,340
earlier versions of rokudo would tend to

00:29:08,000 --> 00:29:12,380
return iterators that people programmers

00:29:10,340 --> 00:29:14,510
could see and it caused no end of

00:29:12,380 --> 00:29:16,420
problems because people couldn't

00:29:14,510 --> 00:29:18,680
understand so we really want that hidden

00:29:16,420 --> 00:29:23,210
so they're usually managed internally

00:29:18,680 --> 00:29:24,620
inside of list objects um the key point

00:29:23,210 --> 00:29:27,170
about when we talk about immutable

00:29:24,620 --> 00:29:29,060
iterators if you have an iterator it's

00:29:27,170 --> 00:29:30,830
got some lazy things that has left to

00:29:29,060 --> 00:29:33,500
generate and you ask it to reify

00:29:30,830 --> 00:29:35,960
something it does it and it suddenly

00:29:33,500 --> 00:29:38,780
becomes immutable at that point it will

00:29:35,960 --> 00:29:40,070
not change from that point on it's kind

00:29:38,780 --> 00:29:41,420
of like if you think of it in terms of

00:29:40,070 --> 00:29:43,850
physics is like you collapsed a wave

00:29:41,420 --> 00:29:46,070
right you're stuck in that universe for

00:29:43,850 --> 00:29:48,980
that particular iterator what it does is

00:29:46,070 --> 00:29:50,420
it returns the same parcel values so

00:29:48,980 --> 00:29:52,700
it's going to generate some values and

00:29:50,420 --> 00:29:54,490
if you ask it to reify again it's going

00:29:52,700 --> 00:29:56,900
to give you the same thing it did before

00:29:54,490 --> 00:29:58,760
but one of the things that gives you is

00:29:56,900 --> 00:30:01,670
a handle to the next iterator in the

00:29:58,760 --> 00:30:04,820
sequence which will be responsible for

00:30:01,670 --> 00:30:06,890
getting more values later so further to

00:30:04,820 --> 00:30:08,510
this generation is handled by iterators

00:30:06,890 --> 00:30:10,010
in the return parcel it's kind of like a

00:30:08,510 --> 00:30:12,980
linked list with head and tail portions

00:30:10,010 --> 00:30:14,150
or lisps corridor model like so that

00:30:12,980 --> 00:30:16,520
what you're doing is you're basically

00:30:14,150 --> 00:30:18,380
saying you know give me this part make

00:30:16,520 --> 00:30:20,330
that fixed forever and the iterator

00:30:18,380 --> 00:30:24,830
defers any other generation to another

00:30:20,330 --> 00:30:26,960
iterator usually the same type so the

00:30:24,830 --> 00:30:28,640
generic pattern for implementing and

00:30:26,960 --> 00:30:29,309
iterators reify method look something

00:30:28,640 --> 00:30:31,529
like this

00:30:29,309 --> 00:30:34,259
you define your iterator its subclass

00:30:31,529 --> 00:30:36,600
from iterator it has a reified attribute

00:30:34,259 --> 00:30:38,970
that you're going to fill in when the

00:30:36,600 --> 00:30:40,950
iterator is asked to reify something you

00:30:38,970 --> 00:30:44,580
check to see if you already did so if

00:30:40,950 --> 00:30:46,950
you didn't do so than you do so by

00:30:44,580 --> 00:30:50,429
generating your n elements and you bind

00:30:46,950 --> 00:30:54,090
this Hemmeter to whatever you generated

00:30:50,429 --> 00:30:55,649
an ax and a follow-on iterator if one is

00:30:54,090 --> 00:30:57,090
needed and then when you're done you

00:30:55,649 --> 00:30:59,070
returned it so the first time you call

00:30:57,090 --> 00:31:01,499
you're going to go through the unless

00:30:59,070 --> 00:31:03,029
portion and generate some elements every

00:31:01,499 --> 00:31:06,119
subsequent call you're going to return

00:31:03,029 --> 00:31:07,860
what you did before no matter what n is

00:31:06,119 --> 00:31:10,080
no matter what it is it's kind of like I

00:31:07,860 --> 00:31:11,549
already did this I'm stuck on you know

00:31:10,080 --> 00:31:13,889
this is what you get if you want more

00:31:11,549 --> 00:31:16,799
then you need to go follow the iterator

00:31:13,889 --> 00:31:18,779
I gave back to you and ask them so you

00:31:16,799 --> 00:31:20,940
end up with this chain of iterators as

00:31:18,779 --> 00:31:23,129
you go reifying elements with each one

00:31:20,940 --> 00:31:25,350
pointing to the next one now the nice

00:31:23,129 --> 00:31:27,090
thing about that is if you think back to

00:31:25,350 --> 00:31:28,980
our buffering example where we're

00:31:27,090 --> 00:31:31,019
accidentally buffering them if I go and

00:31:28,980 --> 00:31:32,879
ask an iterator for a certain number of

00:31:31,019 --> 00:31:35,070
elements and I get through all of them I

00:31:32,879 --> 00:31:37,169
get to the next elevator and I go asking

00:31:35,070 --> 00:31:39,480
for the elements and I lose the last

00:31:37,169 --> 00:31:41,999
reference to the first iterator that was

00:31:39,480 --> 00:31:44,519
there it's garbage collected but if

00:31:41,999 --> 00:31:46,169
anything else has a reference to that

00:31:44,519 --> 00:31:47,399
iterator those elements are still

00:31:46,169 --> 00:31:51,240
waiting there to be picked up by

00:31:47,399 --> 00:31:53,100
whatever else it was before okay so we

00:31:51,240 --> 00:31:55,830
get to use garbage collection and the

00:31:53,100 --> 00:31:58,049
built in fact of following references to

00:31:55,830 --> 00:31:59,730
manage when it's safe to lose the

00:31:58,049 --> 00:32:04,769
elements the binding problem kind of

00:31:59,730 --> 00:32:08,159
goes away at that particular point so

00:32:04,769 --> 00:32:10,049
the list inter-class handles most of the

00:32:08,159 --> 00:32:12,360
iteration and reification task for lists

00:32:10,049 --> 00:32:15,929
this is the nasty one here we can go and

00:32:12,360 --> 00:32:20,340
look at it real quick I can put the no

00:32:15,929 --> 00:32:23,399
worries pragma back in but some panic is

00:32:20,340 --> 00:32:27,389
sometimes good source core list itter

00:32:23,399 --> 00:32:32,610
p.m. ok so the iterator is written in

00:32:27,389 --> 00:32:34,289
perl 6 and in fact all of the core

00:32:32,610 --> 00:32:35,999
libraries are written in perl 6 there

00:32:34,289 --> 00:32:37,980
are a few places where for efficiency

00:32:35,999 --> 00:32:39,940
reasons we do things with some

00:32:37,980 --> 00:32:41,350
lower-level special op codes

00:32:39,940 --> 00:32:47,259
and you can see those by things that

00:32:41,350 --> 00:32:51,360
begin with n QP or PIR but the the code

00:32:47,259 --> 00:32:54,100
there for doing reify is that long and

00:32:51,360 --> 00:32:58,740
this is by far the most complex iterator

00:32:54,100 --> 00:33:01,690
that that we have so what it does is it

00:32:58,740 --> 00:33:04,179
handles lazy generation of values it

00:33:01,690 --> 00:33:05,919
handles if you're iterating over a list

00:33:04,179 --> 00:33:07,779
and it's got other iterable zin the

00:33:05,919 --> 00:33:10,809
middle of it the listed or is the thing

00:33:07,779 --> 00:33:12,279
that does the interpolation and the way

00:33:10,809 --> 00:33:14,320
that it does that is it's going along

00:33:12,279 --> 00:33:16,419
doing its generating and it comes across

00:33:14,320 --> 00:33:17,950
an element that's an iterable and it

00:33:16,419 --> 00:33:19,389
says oh I'm supposed to interpolate at

00:33:17,950 --> 00:33:22,330
this point because it's an iterable and

00:33:19,389 --> 00:33:25,539
so it asks the iterable for its iterator

00:33:22,330 --> 00:33:27,940
and it asks that iterator to do a reify

00:33:25,539 --> 00:33:29,529
of some elements and whatever it gets

00:33:27,940 --> 00:33:31,179
back in the parcel it just splices in

00:33:29,529 --> 00:33:33,039
place and then keeps going start

00:33:31,179 --> 00:33:35,470
processing those so it just does a lot

00:33:33,039 --> 00:33:37,090
of splicing and so as you're iterating a

00:33:35,470 --> 00:33:39,190
lot of intermediate objects all of a

00:33:37,090 --> 00:33:41,830
sudden start disappearing because you're

00:33:39,190 --> 00:33:45,070
you're taking and replacing the large

00:33:41,830 --> 00:33:47,529
aggregate with the elements that it was

00:33:45,070 --> 00:33:49,840
aggregating as you're as you're doing

00:33:47,529 --> 00:33:51,549
you're flattening intervals will also

00:33:49,840 --> 00:33:53,350
flatten parcels if you're a flattening

00:33:51,549 --> 00:33:55,840
sort of thing there's a special value

00:33:53,350 --> 00:33:57,879
called nil which if found in a list is

00:33:55,840 --> 00:34:00,669
simply means nothing it doesn't generate

00:33:57,879 --> 00:34:02,649
anything so it removes those and it also

00:34:00,669 --> 00:34:04,690
handles the eagerness and infinity

00:34:02,649 --> 00:34:07,480
constraints and here's kind of the

00:34:04,690 --> 00:34:09,669
process that it goes through to to

00:34:07,480 --> 00:34:12,520
handle reification we have a special

00:34:09,669 --> 00:34:14,260
low-level array called rest so this is a

00:34:12,520 --> 00:34:16,929
low-level array at the level of our

00:34:14,260 --> 00:34:18,970
virtual machine it's not a Perl 6 array

00:34:16,929 --> 00:34:22,089
that is lazy and everything like that

00:34:18,970 --> 00:34:23,649
this is a this is literally just a an

00:34:22,089 --> 00:34:25,060
array that we can grow and resize but

00:34:23,649 --> 00:34:28,270
doesn't have laziness or any of the

00:34:25,060 --> 00:34:30,220
other features so we start shifting

00:34:28,270 --> 00:34:32,470
things from there we start building a

00:34:30,220 --> 00:34:33,909
parcel of things that aren't being

00:34:32,470 --> 00:34:35,710
interpolated and aren't being processed

00:34:33,909 --> 00:34:39,280
the things we are going to return back

00:34:35,710 --> 00:34:41,560
on the list dinner as it produces this

00:34:39,280 --> 00:34:44,679
parcel it also has a link to a parent

00:34:41,560 --> 00:34:46,750
container where it can say I produced

00:34:44,679 --> 00:34:48,040
these things in your response you told

00:34:46,750 --> 00:34:50,440
me I'm supposed to tell you when it

00:34:48,040 --> 00:34:52,000
happened and so you can go store them

00:34:50,440 --> 00:34:54,220
and so it does a call back

00:34:52,000 --> 00:34:56,500
do that and that's what allows a list

00:34:54,220 --> 00:35:00,010
which is the thing holding the list

00:34:56,500 --> 00:35:01,870
iterator to put the newly reified

00:35:00,010 --> 00:35:05,860
elements into its list of reified

00:35:01,870 --> 00:35:07,960
elements okay then we create a new list

00:35:05,860 --> 00:35:10,390
iterator to handle whatever other lazy

00:35:07,960 --> 00:35:11,620
part is is still left to be done and we

00:35:10,390 --> 00:35:16,390
return it to the collar and we're done

00:35:11,620 --> 00:35:18,490
and that's how it works so the list

00:35:16,390 --> 00:35:19,870
class a list object has a low-level

00:35:18,490 --> 00:35:22,360
array of things that have already been

00:35:19,870 --> 00:35:26,590
reified it has a listed or chain for

00:35:22,360 --> 00:35:28,930
anything that hasn't yet been reified

00:35:26,590 --> 00:35:30,790
that it's still being done lazy this is

00:35:28,930 --> 00:35:32,590
the class that implements shift push pop

00:35:30,790 --> 00:35:35,710
on shift all of the things that you

00:35:32,590 --> 00:35:37,480
would do to a sequence of items so it's

00:35:35,710 --> 00:35:39,010
the list is mutable you can add things

00:35:37,480 --> 00:35:40,750
to the beginning take things off the end

00:35:39,010 --> 00:35:42,400
you can specially put splice in there

00:35:40,750 --> 00:35:45,010
you can splice in the middle you can

00:35:42,400 --> 00:35:48,250
index for a specific location things

00:35:45,010 --> 00:35:50,980
like that and the key thing is that a

00:35:48,250 --> 00:35:52,510
list when it's managing this listed or

00:35:50,980 --> 00:35:53,800
chain it's the thing that gets the

00:35:52,510 --> 00:35:55,240
callbacks whenever new values are

00:35:53,800 --> 00:35:59,140
generated so it knows I'm supposed to

00:35:55,240 --> 00:36:00,790
put them as being reified there is a

00:35:59,140 --> 00:36:02,740
special method I noticed this was asked

00:36:00,790 --> 00:36:05,050
several times yesterday on IRC and a few

00:36:02,740 --> 00:36:07,780
things what if you want to know how much

00:36:05,050 --> 00:36:10,030
has been reified you can ask a list how

00:36:07,780 --> 00:36:11,740
many elements it has but it goes and

00:36:10,030 --> 00:36:13,060
generates all the elements what if you

00:36:11,740 --> 00:36:15,370
just want to know well how many have you

00:36:13,060 --> 00:36:20,560
got already and there's a gimmie method

00:36:15,370 --> 00:36:23,080
for that and the Gimme method is a way

00:36:20,560 --> 00:36:25,810
to tell a list make sure that you've

00:36:23,080 --> 00:36:29,500
worked ahead at least to this point give

00:36:25,810 --> 00:36:30,610
me at least this many elements and we

00:36:29,500 --> 00:36:35,500
couldn't come up with a better name than

00:36:30,610 --> 00:36:37,390
gimme so it's stuck so when you call

00:36:35,500 --> 00:36:38,980
gimme on a list it ensures that at least

00:36:37,390 --> 00:36:41,860
n elements of a list have been reified

00:36:38,980 --> 00:36:43,480
so it looks at that number and if it's

00:36:41,860 --> 00:36:45,760
already reified that many it just says

00:36:43,480 --> 00:36:48,520
okay i'm done if it hasn't done that

00:36:45,760 --> 00:36:50,440
then it tells its list iterator i need

00:36:48,520 --> 00:36:52,180
this many more elements and it goes

00:36:50,440 --> 00:36:53,710
through and follows the chain of listed

00:36:52,180 --> 00:36:54,760
Raiders and manages them until it has

00:36:53,710 --> 00:36:56,980
enough elements at which point it

00:36:54,760 --> 00:36:58,270
returns and the last thing that does is

00:36:56,980 --> 00:37:01,420
it says how many are actually been

00:36:58,270 --> 00:37:03,760
reified so that you know that answers

00:37:01,420 --> 00:37:05,000
the question that the callers want to

00:37:03,760 --> 00:37:07,550
know which is how many of you all

00:37:05,000 --> 00:37:08,930
he got so here's an example I've created

00:37:07,550 --> 00:37:11,720
an infinite list of the Fibonacci

00:37:08,930 --> 00:37:14,510
sequence um if I asked for the eighth

00:37:11,720 --> 00:37:16,010
that element at index eight in the array

00:37:14,510 --> 00:37:19,130
then it comes back and says it's number

00:37:16,010 --> 00:37:21,830
34 so if i ask that array how many have

00:37:19,130 --> 00:37:23,000
you generated and i give it zero which

00:37:21,830 --> 00:37:25,520
means i don't want you to generate any

00:37:23,000 --> 00:37:27,500
more right because you already have zero

00:37:25,520 --> 00:37:28,550
so just tell me how many you've already

00:37:27,500 --> 00:37:30,560
got i'll come back and we'll say nine

00:37:28,550 --> 00:37:34,850
and the reason it says nine its index is

00:37:30,560 --> 00:37:38,060
0 through 80 1 2 3 4 5 6 7 8 so 8 is the

00:37:34,850 --> 00:37:40,070
one to index 8 is the 9th element then i

00:37:38,060 --> 00:37:42,170
can tell a go ahead and give me 50

00:37:40,070 --> 00:37:45,170
elements so that actually generates all

00:37:42,170 --> 00:37:49,550
the indices from 0 to 49 fills it in and

00:37:45,170 --> 00:37:52,940
now anytime I ask for an element prior

00:37:49,550 --> 00:37:54,470
to index 50 I'll get it back almost

00:37:52,940 --> 00:37:55,760
immediately there's no generation that

00:37:54,470 --> 00:37:57,380
has to take place it's already been

00:37:55,760 --> 00:37:59,720
memorized it's already been recorded in

00:37:57,380 --> 00:38:01,280
the array and so it's very very fast so

00:37:59,720 --> 00:38:03,830
if I know that I'm going to be doing a

00:38:01,280 --> 00:38:05,690
lot of lookups at later elements I can

00:38:03,830 --> 00:38:08,660
tell the list compute a bunch of these

00:38:05,690 --> 00:38:10,580
right now really fast so that my later

00:38:08,660 --> 00:38:12,620
lookups will be quicker instead of

00:38:10,580 --> 00:38:15,110
having it going like generate one and

00:38:12,620 --> 00:38:16,880
then I'll come back and ask for the next

00:38:15,110 --> 00:38:19,250
one so as to go and generate another one

00:38:16,880 --> 00:38:21,380
and do it slowly you can you can tell it

00:38:19,250 --> 00:38:26,780
to precash a bunch of values and then

00:38:21,380 --> 00:38:28,580
use them directly yes lots of things

00:38:26,780 --> 00:38:29,960
about your you're reducing the number of

00:38:28,580 --> 00:38:37,100
method calls you're doing all sorts of

00:38:29,960 --> 00:38:39,950
stuff because they return different

00:38:37,100 --> 00:38:42,080
things I'm sorry the question is why not

00:38:39,950 --> 00:38:44,450
just call it reify because if i call

00:38:42,080 --> 00:38:47,150
reify on an iterator it gives me back

00:38:44,450 --> 00:38:48,740
the things that were reified if i call

00:38:47,150 --> 00:38:52,280
gimme on a list it tells me how many

00:38:48,740 --> 00:38:54,260
have already been reified so since they

00:38:52,280 --> 00:38:57,950
do two different things they should have

00:38:54,260 --> 00:39:00,460
different names and in this case they're

00:38:57,950 --> 00:39:00,460
really different

00:39:00,600 --> 00:39:06,250
the map inter-class handles map and for

00:39:03,250 --> 00:39:09,280
so it takes a list that it manages

00:39:06,250 --> 00:39:11,020
another lista diretor to work with and

00:39:09,280 --> 00:39:12,970
iterates over that list and every time

00:39:11,020 --> 00:39:16,810
it gets elements from the list that

00:39:12,970 --> 00:39:19,840
applies block to it now unlike Perl 5 I

00:39:16,810 --> 00:39:22,660
don't know unlike any way in Perl 6 the

00:39:19,840 --> 00:39:24,070
block can have multiple arguments the

00:39:22,660 --> 00:39:25,960
signature of the block can actually have

00:39:24,070 --> 00:39:28,750
two three however many arguments you

00:39:25,960 --> 00:39:31,060
want and the map iterator will look at

00:39:28,750 --> 00:39:32,920
the signature of the block to figure out

00:39:31,060 --> 00:39:35,260
how many things it needs to get to the

00:39:32,920 --> 00:39:38,520
list to send to the block and that's

00:39:35,260 --> 00:39:42,670
what enables this sort of stuff to work

00:39:38,520 --> 00:39:45,400
let's suppose that so that's how we can

00:39:42,670 --> 00:39:49,360
do something like this for lists

00:39:45,400 --> 00:39:52,800
pointing to a B do something that grabs

00:39:49,360 --> 00:39:55,090
elements out of lists two at a time

00:39:52,800 --> 00:39:56,470
right so it'll grab one element from

00:39:55,090 --> 00:39:57,670
list and put it in dollar sign a and

00:39:56,470 --> 00:39:59,110
another element and list and put it in

00:39:57,670 --> 00:40:01,960
dollar ciebie and invoke the block now

00:39:59,110 --> 00:40:03,220
the key point to notice thing or to

00:40:01,960 --> 00:40:04,720
understanding how that works if you're

00:40:03,220 --> 00:40:06,700
not familiar with perl 6 is to note that

00:40:04,720 --> 00:40:10,780
the part beginning with the arrow is the

00:40:06,700 --> 00:40:13,510
block the arrow initiates a signature

00:40:10,780 --> 00:40:17,800
for the block it's called a pointy sub

00:40:13,510 --> 00:40:19,690
and so as a pointy sub the for command

00:40:17,800 --> 00:40:28,060
which is really just a map so this is

00:40:19,690 --> 00:40:30,760
the same as doing this right it's the

00:40:28,060 --> 00:40:34,450
same as doing that map looks at the

00:40:30,760 --> 00:40:37,030
block it says I need two values of the

00:40:34,450 --> 00:40:40,030
block so it goes and grabs from the list

00:40:37,030 --> 00:40:47,520
items two at a time and then passes them

00:40:40,030 --> 00:40:55,420
to the block I they would be flattened

00:40:47,520 --> 00:40:59,230
that's that not with map there's another

00:40:55,420 --> 00:41:00,820
function for that call tree so in that

00:40:59,230 --> 00:41:04,650
case it would probably be something like

00:41:00,820 --> 00:41:07,030
list tree and you give it the block and

00:41:04,650 --> 00:41:10,300
or you would convert it to a list of

00:41:07,030 --> 00:41:12,450
lists and then map that so you would

00:41:10,300 --> 00:41:17,890
also you could also do it for list dot

00:41:12,450 --> 00:41:18,940
lol like that by converting it to a list

00:41:17,890 --> 00:41:20,740
of lists you're preventing them from

00:41:18,940 --> 00:41:22,330
flattening so the partials would become

00:41:20,740 --> 00:41:26,250
elements that would then be passed a and

00:41:22,330 --> 00:41:34,780
B yes it gets confusing it will be

00:41:26,250 --> 00:41:37,810
understood well someday right yeah

00:41:34,780 --> 00:41:39,310
original versions of Riku doe had map

00:41:37,810 --> 00:41:42,099
where it could handle flattening and non

00:41:39,310 --> 00:41:44,230
flattening behaviors and it turns out

00:41:42,099 --> 00:41:46,540
that having always be flattening makes a

00:41:44,230 --> 00:41:49,510
lot of things faster and simpler and the

00:41:46,540 --> 00:41:54,060
dot lol is to handle the rarer cases

00:41:49,510 --> 00:41:54,060
where you don't want that to happen um

00:41:54,180 --> 00:41:58,570
the map inter-class also is the thing

00:41:56,560 --> 00:42:00,670
that handles the the control flow from

00:41:58,570 --> 00:42:03,130
things like nextlast and redo it's also

00:42:00,670 --> 00:42:05,560
the thing that that causes the first

00:42:03,130 --> 00:42:07,630
next and last phasers to be invoked if

00:42:05,560 --> 00:42:12,430
you don't know what a phaser is watch

00:42:07,630 --> 00:42:14,290
more Star Trek a phaser is a block that

00:42:12,430 --> 00:42:16,890
is executed when you change from one

00:42:14,290 --> 00:42:20,619
phase of execution to another so a first

00:42:16,890 --> 00:42:22,869
phaser is a block that gets executed the

00:42:20,619 --> 00:42:26,320
first time you enter a block as part of

00:42:22,869 --> 00:42:29,050
an iteration a last phaser is a block

00:42:26,320 --> 00:42:31,240
that gets executed the last time you you

00:42:29,050 --> 00:42:34,960
exit that block and there won't be any

00:42:31,240 --> 00:42:37,300
more iterations next is a block that is

00:42:34,960 --> 00:42:40,030
executed at the end of each uttering

00:42:37,300 --> 00:42:43,030
iterations like continue it yes like

00:42:40,030 --> 00:42:44,940
continue in profile and so it internally

00:42:43,030 --> 00:42:48,520
manages a listener chain to handle that

00:42:44,940 --> 00:42:50,470
range is a very interesting case ok so i

00:42:48,520 --> 00:42:52,930
noticed that range is there and people

00:42:50,470 --> 00:42:54,280
will say why is it an integrator why

00:42:52,930 --> 00:42:55,839
would you consider range to be an

00:42:54,280 --> 00:42:58,210
iterator and not just an iterable or

00:42:55,839 --> 00:43:00,700
list this valve from a variety of things

00:42:58,210 --> 00:43:03,849
the early implementations of range had a

00:43:00,700 --> 00:43:05,320
separate range iterator class so you had

00:43:03,849 --> 00:43:06,940
a range which represented a range of

00:43:05,320 --> 00:43:08,470
numbers and then there was a class of

00:43:06,940 --> 00:43:11,170
object that handled the iteration over

00:43:08,470 --> 00:43:13,180
those but there was a ton of coupling

00:43:11,170 --> 00:43:15,730
between range and range it ER where

00:43:13,180 --> 00:43:17,680
ranges had to know a lot about what rain

00:43:15,730 --> 00:43:19,630
jitters did and rain jitters were always

00:43:17,680 --> 00:43:21,160
looking back into the range to figure

00:43:19,630 --> 00:43:22,450
out the start point and end point or

00:43:21,160 --> 00:43:24,790
they had to make copies of them and all

00:43:22,450 --> 00:43:26,770
sorts of things so I discovered

00:43:24,790 --> 00:43:28,750
something I said wait a minute range

00:43:26,770 --> 00:43:30,250
objects objects are immutable at least

00:43:28,750 --> 00:43:36,609
after the respect change that caused

00:43:30,250 --> 00:43:38,380
them to be hmm and and so a range is

00:43:36,609 --> 00:43:41,200
always going to return the same sequence

00:43:38,380 --> 00:43:42,790
of values right if you ask it for a list

00:43:41,200 --> 00:43:43,930
of values you can't change the range

00:43:42,790 --> 00:43:46,660
itself it's always going to give the

00:43:43,930 --> 00:43:49,270
same sequence so the reify method for

00:43:46,660 --> 00:43:50,650
range can easily compute return values

00:43:49,270 --> 00:43:52,180
and the range needed to continue the

00:43:50,650 --> 00:43:54,400
sequence so if I have a range going from

00:43:52,180 --> 00:43:56,440
0 to 10 and I say give me five elements

00:43:54,400 --> 00:43:59,260
it gives me the first five elements 0 1

00:43:56,440 --> 00:44:01,540
2 3 4 5 4 that's the five elements and

00:43:59,260 --> 00:44:03,400
then what I need in order to continue

00:44:01,540 --> 00:44:06,040
the sequence that's just another range

00:44:03,400 --> 00:44:09,070
it's another immutable range to be able

00:44:06,040 --> 00:44:12,040
to do that so I don't actually need

00:44:09,070 --> 00:44:13,630
another class to do that and if I were

00:44:12,040 --> 00:44:15,040
to ask this range to give me another

00:44:13,630 --> 00:44:19,740
five elements it comes back and gives me

00:44:15,040 --> 00:44:25,060
five six seven eight nine and ten so um

00:44:19,740 --> 00:44:27,130
having range I'm sorry right yeah the

00:44:25,060 --> 00:44:29,260
range reification it's allowed to do

00:44:27,130 --> 00:44:31,359
more or less and it's actually smart

00:44:29,260 --> 00:44:34,210
enough to know it's smart enough to know

00:44:31,359 --> 00:44:39,910
that doing ten ten is silly so it just

00:44:34,210 --> 00:44:42,040
didn't so having range handle its own

00:44:39,910 --> 00:44:44,410
reification is much cleaner it knows its

00:44:42,040 --> 00:44:46,930
endpoints right it knows all of its

00:44:44,410 --> 00:44:48,310
stuff so I as I was doing it with range

00:44:46,930 --> 00:44:51,640
hitter I finally imma stick to reify

00:44:48,310 --> 00:44:53,560
method in range and if you go through

00:44:51,640 --> 00:44:55,630
and look at the things since range has

00:44:53,560 --> 00:44:58,660
an it reify things with reifies are

00:44:55,630 --> 00:45:01,060
naturally iterators and so that's where

00:44:58,660 --> 00:45:02,920
i put it in the class hard hierarchy if

00:45:01,060 --> 00:45:06,040
you ask a range for iterator it just

00:45:02,920 --> 00:45:09,310
returns itself that's all it er aters do

00:45:06,040 --> 00:45:12,430
or if I'm sorry as all and if iterable

00:45:09,310 --> 00:45:14,890
it would just return self I might decide

00:45:12,430 --> 00:45:16,510
range really fits to be more as an

00:45:14,890 --> 00:45:18,070
iterable for some other reason than

00:45:16,510 --> 00:45:19,720
iterator it would still work the same

00:45:18,070 --> 00:45:21,760
except you know just changes the class

00:45:19,720 --> 00:45:24,460
harder key but since it has a real fly

00:45:21,760 --> 00:45:29,050
and iterators have reify i stuck it

00:45:24,460 --> 00:45:33,640
there and everything seems to work ok

00:45:29,050 --> 00:45:42,820
yes ok any questions on those I promise

00:45:33,640 --> 00:45:45,610
that's the end of it er a terse yes the

00:45:42,820 --> 00:45:49,510
range doesn't change from 0 to 10 to 5

00:45:45,610 --> 00:45:52,860
to 10 it gives you 0 1 2 3 4 and a new

00:45:49,510 --> 00:45:55,120
range of 5 to 10 like most iterators do

00:45:52,860 --> 00:45:57,760
iterators don't change what they know

00:45:55,120 --> 00:46:05,110
they generate a new iterator of the same

00:45:57,760 --> 00:46:08,760
type that handles the rest yes that's

00:46:05,110 --> 00:46:08,760
another range it's another range

00:46:17,180 --> 00:46:22,820
yes yep that's exactly what it does yes

00:46:29,360 --> 00:46:37,970
for range it does for integer ranges and

00:46:34,160 --> 00:46:41,900
numeric ranges if you say like I want

00:46:37,970 --> 00:46:44,330
from one to infinity and then you go and

00:46:41,900 --> 00:46:46,760
start requesting elements for it it does

00:46:44,330 --> 00:46:48,140
like a thousand at a time you know it

00:46:46,760 --> 00:46:49,970
make starts to make the tray off

00:46:48,140 --> 00:46:52,070
trade-offs there to say I'm going to

00:46:49,970 --> 00:46:54,890
really look ahead to be able to to do

00:46:52,070 --> 00:46:57,230
that and also we've gone ahead and

00:46:54,890 --> 00:46:59,690
optimized those that particular case

00:46:57,230 --> 00:47:02,120
because numeric ranges are so common but

00:46:59,690 --> 00:47:04,490
it actually does it at low level object

00:47:02,120 --> 00:47:07,490
code and not in Perl 6 code because it's

00:47:04,490 --> 00:47:10,070
common it makes it really really fast so

00:47:07,490 --> 00:47:22,880
that's an optimization we've done any

00:47:10,070 --> 00:47:26,660
others yes exactly alrighty so I'm

00:47:22,880 --> 00:47:28,190
handling infinity so iterable objects

00:47:26,660 --> 00:47:30,620
have an infinite method that report

00:47:28,190 --> 00:47:33,560
finiteness is the thing that's iterable

00:47:30,620 --> 00:47:36,320
finite or infinite right and there are

00:47:33,560 --> 00:47:38,870
three possible answers true is I'm

00:47:36,320 --> 00:47:41,420
infinite and I know it false is on

00:47:38,870 --> 00:47:42,980
finite and I know it and knew which is

00:47:41,420 --> 00:47:46,640
another type in Perl 6 is actually the

00:47:42,980 --> 00:47:48,590
parent of any says I don't know I might

00:47:46,640 --> 00:47:50,780
be finite I might be infinite I haven't

00:47:48,590 --> 00:47:59,860
figured that out yet but when I figured

00:47:50,780 --> 00:48:02,210
out I'll report differently all right so

00:47:59,860 --> 00:48:04,040
these are the three possible values now

00:48:02,210 --> 00:48:05,990
all three of them are really needed for

00:48:04,040 --> 00:48:07,970
good reasoning so if I have a range from

00:48:05,990 --> 00:48:10,040
0 to 5 and si are you infinite it comes

00:48:07,970 --> 00:48:12,200
back and says false we know that to be

00:48:10,040 --> 00:48:13,460
finite because the endpoint is finite

00:48:12,200 --> 00:48:15,560
there's a finite number of elements

00:48:13,460 --> 00:48:17,330
there and it can detect that if i say i

00:48:15,560 --> 00:48:19,010
want to range from 0 to infinity and I

00:48:17,330 --> 00:48:20,600
ask if that range is infinite it comes

00:48:19,010 --> 00:48:23,330
back it says true my endpoint is

00:48:20,600 --> 00:48:25,460
infinity so I know that if you ask me to

00:48:23,330 --> 00:48:28,280
I'll generate enough elements for you

00:48:25,460 --> 00:48:31,310
until you get tired of asking right so

00:48:28,280 --> 00:48:33,500
those are pretty easy cases if I have a

00:48:31,310 --> 00:48:36,290
sequence this is the Fibonacci sequence

00:48:33,500 --> 00:48:37,970
again and i say i want the numbers 11

00:48:36,290 --> 00:48:39,130
the previous two numbers added together

00:48:37,970 --> 00:48:40,750
all the way up to

00:48:39,130 --> 00:48:43,120
infinity and ask if it's infinite it

00:48:40,750 --> 00:48:45,580
will come back and we'll say true and it

00:48:43,120 --> 00:48:47,230
will say true because of this star here

00:48:45,580 --> 00:48:49,330
that the programmer put there if you put

00:48:47,230 --> 00:48:51,850
a star at the end that implies infinity

00:48:49,330 --> 00:48:54,670
and the the sequence operator can

00:48:51,850 --> 00:48:56,770
determine that but if you say 11 star

00:48:54,670 --> 00:48:58,660
plus for up to 10 the way the sequence

00:48:56,770 --> 00:49:03,790
operator works is that it stops when you

00:48:58,660 --> 00:49:07,150
reach this point exactly as one tonight

00:49:03,790 --> 00:49:09,430
it's not and the thing is the sequence

00:49:07,150 --> 00:49:11,500
operator can't know that because this is

00:49:09,430 --> 00:49:13,120
an arbitrary generator as far as its

00:49:11,500 --> 00:49:15,880
concerned it's a block so the sequence

00:49:13,120 --> 00:49:18,430
operator can't know that you're going to

00:49:15,880 --> 00:49:20,080
reach an end because it doesn't know it

00:49:18,430 --> 00:49:21,760
can't introspect to figure out what your

00:49:20,080 --> 00:49:23,410
computing and it doesn't know that that

00:49:21,760 --> 00:49:33,220
sequence since its arbitrary would ever

00:49:23,410 --> 00:49:37,660
absolutely match that value exactly so

00:49:33,220 --> 00:49:39,190
therefore perspective right so um and

00:49:37,660 --> 00:49:40,540
actually if you were to sig the sequence

00:49:39,190 --> 00:49:43,000
it would actually not stop at 2n it

00:49:40,540 --> 00:49:46,440
would go to 11 and then the other ones

00:49:43,000 --> 00:49:48,550
that are 13 I guess it's the next one so

00:49:46,440 --> 00:49:56,800
it didn't really work I have a question

00:49:48,550 --> 00:49:59,260
here mu isn't undef there are many

00:49:56,800 --> 00:50:01,420
values of undef in the perl 6 world it's

00:49:59,260 --> 00:50:10,420
a type object and new is the most

00:50:01,420 --> 00:50:11,920
undefined it will continue on forever

00:50:10,420 --> 00:50:20,860
because you will never match that

00:50:11,920 --> 00:50:23,500
endpoint ok yes here it's not actually

00:50:20,860 --> 00:50:29,260
using equals using smart match you can

00:50:23,500 --> 00:50:31,240
put things other than values there yeah

00:50:29,260 --> 00:50:32,590
it's using smart match and I don't want

00:50:31,240 --> 00:50:34,510
to get too far down that so I'll be glad

00:50:32,590 --> 00:50:36,040
to answer that here I know I know I'm

00:50:34,510 --> 00:50:38,050
like out of time I'm going to take two

00:50:36,040 --> 00:50:40,540
more minutes so just just to finish

00:50:38,050 --> 00:50:43,590
infinity so if you have a list and you

00:50:40,540 --> 00:50:43,590
ask if it's infinite

00:50:45,910 --> 00:50:50,660
it lists delegates infinite to its

00:50:48,890 --> 00:50:52,400
listed raider by the way infinity

00:50:50,660 --> 00:50:56,960
explains why it's taking so long for us

00:50:52,400 --> 00:50:58,640
to build Perl 6 so if you have a list

00:50:56,960 --> 00:51:00,500
you asked if its infinite just ask it's

00:50:58,640 --> 00:51:02,210
listed a writer a list iterator to

00:51:00,500 --> 00:51:03,590
determine infinity just looks at the

00:51:02,210 --> 00:51:06,050
next thing and the sequence that it

00:51:03,590 --> 00:51:08,570
hasn't processed yet and asks it are you

00:51:06,050 --> 00:51:10,340
infinite or not and if the thing comes

00:51:08,570 --> 00:51:12,470
back and says false then the listed or

00:51:10,340 --> 00:51:15,560
aider says new because the other things

00:51:12,470 --> 00:51:17,210
might be in a fit infinite if it comes

00:51:15,560 --> 00:51:18,620
back says true it knows that it's

00:51:17,210 --> 00:51:21,470
infinite because the first thing said it

00:51:18,620 --> 00:51:24,530
did we could scan ahead for those I'd

00:51:21,470 --> 00:51:27,050
implemented that yet and when you're

00:51:24,530 --> 00:51:29,240
reifying a list on it and you're doing

00:51:27,050 --> 00:51:31,880
it eagerly it stops when it finds an

00:51:29,240 --> 00:51:33,440
iterable that says I'm infinite if the

00:51:31,880 --> 00:51:36,170
iterable doesn't say I'm definitely in

00:51:33,440 --> 00:51:39,770
infinite it keeps going just in case it

00:51:36,170 --> 00:51:43,300
finds one so the other thing that's

00:51:39,770 --> 00:51:47,540
interesting is that Matt blocks um don't

00:51:43,300 --> 00:51:49,730
always return you so mapping even if you

00:51:47,540 --> 00:51:52,280
are mapping over a known infinite or

00:51:49,730 --> 00:51:54,170
known finite thing the process of

00:51:52,280 --> 00:51:55,520
mapping currently always changes that

00:51:54,170 --> 00:51:58,040
tomb you that it doesn't know because

00:51:55,520 --> 00:52:00,140
the block could change what happens an

00:51:58,040 --> 00:52:02,630
infinite list could end because of a

00:52:00,140 --> 00:52:05,930
last a finite list could go forever

00:52:02,630 --> 00:52:09,530
because of a bunch of reduce and so new

00:52:05,930 --> 00:52:12,290
kind of map mapping always reports you

00:52:09,530 --> 00:52:13,880
for that and we might change this as we

00:52:12,290 --> 00:52:19,520
do some experimentation but that's the

00:52:13,880 --> 00:52:24,650
safe choice for now it causes the list

00:52:19,520 --> 00:52:27,440
to not exit gather infinite also reports

00:52:24,650 --> 00:52:29,720
new for similar reasons we're working on

00:52:27,440 --> 00:52:31,400
a syntax to explicitly indicate infinity

00:52:29,720 --> 00:52:33,230
so if you have a gather statement and

00:52:31,400 --> 00:52:34,850
you want it to be treated as infinite

00:52:33,230 --> 00:52:36,620
then you can put a comma star there and

00:52:34,850 --> 00:52:37,610
do that that's not implemented yet and

00:52:36,620 --> 00:52:40,220
there's still some details to be worked

00:52:37,610 --> 00:52:42,860
out I wanted to do slicing but I'll have

00:52:40,220 --> 00:52:46,790
to do that another time and a bunch of

00:52:42,860 --> 00:52:48,110
other things here so so come to my third

00:52:46,790 --> 00:52:50,320
talk which will be at next year's lat

00:52:48,110 --> 00:52:54,500
yep see

00:52:50,320 --> 00:52:58,520
um or you know I might even do my third

00:52:54,500 --> 00:53:01,609
target yes Europe come there um yeah it

00:52:58,520 --> 00:53:03,500
was lightning time so summary there's

00:53:01,609 --> 00:53:06,820
lots of considerations doing list is

00:53:03,500 --> 00:53:09,140
hard and these are the reasons why

00:53:06,820 --> 00:53:10,730
figuring out the immutable iterators was

00:53:09,140 --> 00:53:12,020
the key to doing it here are some of the

00:53:10,730 --> 00:53:13,190
key roles I don't have time for

00:53:12,020 --> 00:53:14,510
questions so meet me in the hallway

00:53:13,190 --> 00:53:17,859
track I'm free for the rest of the

00:53:14,510 --> 00:53:17,859

YouTube URL: https://www.youtube.com/watch?v=4W6KTsRup0s


