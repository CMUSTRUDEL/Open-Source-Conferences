Title: Ricardo Signes   Whats New in Perl
Publication date: 2013-08-20
Playlist: YAPC::NA 2012
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:13,019
I didn't work at all hey let's talk

00:00:07,980 --> 00:00:14,820
mostly me hi everybody it's a it's 330

00:00:13,019 --> 00:00:16,260
it's 130 right I should be talking I'm

00:00:14,820 --> 00:00:19,680
not I'm not shutting you up prematurely

00:00:16,260 --> 00:00:23,820
I think so i'm gonna be talking about

00:00:19,680 --> 00:00:25,980
pearl five and what's new in it I have

00:00:23,820 --> 00:00:29,390
given talks like this for the last

00:00:25,980 --> 00:00:32,640
couple years the first one I did was a

00:00:29,390 --> 00:00:36,329
pro 5 10 for people who are not totally

00:00:32,640 --> 00:00:39,870
insane and the premise was pro 5 pro 5

00:00:36,329 --> 00:00:44,070
10 was huge it's just huge number of new

00:00:39,870 --> 00:00:46,170
behaviors and many of them were really

00:00:44,070 --> 00:00:49,649
really cool and useful and many of them

00:00:46,170 --> 00:00:51,059
were cool and seemed useful on and many

00:00:49,649 --> 00:00:52,289
of them you wouldn't know what they have

00:00:51,059 --> 00:00:53,820
to do with you know they're just like

00:00:52,289 --> 00:00:56,280
these crazy esoteric things that you're

00:00:53,820 --> 00:00:58,140
going to use maybe it once in a blue

00:00:56,280 --> 00:01:00,090
moon and if you try to read the whole

00:00:58,140 --> 00:01:01,649
documentation of what's going on you're

00:01:00,090 --> 00:01:03,149
going to get lost and you're getting it

00:01:01,649 --> 00:01:04,860
hung up trying to figure out what this

00:01:03,149 --> 00:01:06,150
explanation is telling you about a

00:01:04,860 --> 00:01:08,310
feature you're never going to use so i

00:01:06,150 --> 00:01:11,430
just wanted to talk about the features

00:01:08,310 --> 00:01:14,310
that i thought most programmers should

00:01:11,430 --> 00:01:15,540
and would use a day to day so i did the

00:01:14,310 --> 00:01:17,580
talk again the next year and i talked

00:01:15,540 --> 00:01:19,500
about pro 5 12 for everyday use same

00:01:17,580 --> 00:01:24,030
same thing same same kind of changes and

00:01:19,500 --> 00:01:27,689
then again 45 14 and i started to work

00:01:24,030 --> 00:01:30,060
before submission period about on Perl 5

00:01:27,689 --> 00:01:31,650
16 for the working programmer and it's

00:01:30,060 --> 00:01:33,509
the same idea like what are the changes

00:01:31,650 --> 00:01:36,810
in 516 that you really want to know

00:01:33,509 --> 00:01:39,900
about and I was kind of perversely

00:01:36,810 --> 00:01:44,399
pleased to find out that there weren't

00:01:39,900 --> 00:01:48,000
that many of them 516 has scads of

00:01:44,399 --> 00:01:52,049
changes and almost entirely improvements

00:01:48,000 --> 00:01:54,270
but many of them are our bug fixes their

00:01:52,049 --> 00:01:56,040
changes to edge behavior their

00:01:54,270 --> 00:01:57,600
improvements that are really great that

00:01:56,040 --> 00:01:59,250
they're there but most people aren't

00:01:57,600 --> 00:02:00,810
going to care they're not going to

00:01:59,250 --> 00:02:02,850
affect their daily lives except for

00:02:00,810 --> 00:02:04,409
occasionally making some stupid thing

00:02:02,850 --> 00:02:06,420
not happen that they probably never

00:02:04,409 --> 00:02:09,149
noticed before and I didn't have enough

00:02:06,420 --> 00:02:11,700
material to talk about 5 16 and I hate

00:02:09,149 --> 00:02:13,290
20 minutes slots I don't like doing them

00:02:11,700 --> 00:02:13,620
so I said I'm just going to do the whole

00:02:13,290 --> 00:02:15,209
thing

00:02:13,620 --> 00:02:18,299
which I still think makes a lot of sense

00:02:15,209 --> 00:02:19,860
because how many people here first of

00:02:18,299 --> 00:02:22,620
all how many people here use pearl at

00:02:19,860 --> 00:02:24,360
work like to do your job right so almost

00:02:22,620 --> 00:02:30,299
everybody and how many of you day-to-day

00:02:24,360 --> 00:02:32,489
are using 58 yeah all right it's doodles

00:02:30,299 --> 00:02:36,000
of stuff and how many people are using a

00:02:32,489 --> 00:02:38,069
5 10 right so there's a lot of stuff

00:02:36,000 --> 00:02:39,599
that you're not getting to use and maybe

00:02:38,069 --> 00:02:40,980
you already know about it and all you

00:02:39,599 --> 00:02:42,810
want to do is hear me talk about the

00:02:40,980 --> 00:02:44,579
features and tell you like the glowing

00:02:42,810 --> 00:02:46,590
terms and the warm feelings they give me

00:02:44,579 --> 00:02:49,200
and you'll you'll get to have that but

00:02:46,590 --> 00:02:50,970
if you're using 58 or 5 10 and you

00:02:49,200 --> 00:02:53,879
haven't gotten to see all the cool

00:02:50,970 --> 00:02:56,730
reasons that you should be running 516 I

00:02:53,879 --> 00:03:01,040
want to get into that not just 16 but

00:02:56,730 --> 00:03:03,510
also 14 12 10 and in some cases 589

00:03:01,040 --> 00:03:07,079
anybody here running 589 in production

00:03:03,510 --> 00:03:09,930
yeah 1155 8 9 ends up getting a couple

00:03:07,079 --> 00:03:15,120
features from 510 put back into it for

00:03:09,930 --> 00:03:16,440
cuz um okay um the first thing I want to

00:03:15,120 --> 00:03:21,870
talk about and I'm not going to go into

00:03:16,440 --> 00:03:24,389
this in depth is we've added lexical

00:03:21,870 --> 00:03:25,739
semantics and the name alone is kind of

00:03:24,389 --> 00:03:27,060
nasty what this really means is

00:03:25,739 --> 00:03:31,109
something we've been working on for a

00:03:27,060 --> 00:03:33,870
while the feature bundles where we add

00:03:31,109 --> 00:03:36,690
new features that only work if you've

00:03:33,870 --> 00:03:38,430
said you want to use them really popular

00:03:36,690 --> 00:03:41,370
one and I'm going to spoil slides that

00:03:38,430 --> 00:03:44,609
are coming up later we've got a routine

00:03:41,370 --> 00:03:48,030
called say say string prints it out and

00:03:44,609 --> 00:03:49,849
it prints a new line great but we we

00:03:48,030 --> 00:03:53,220
were nervous about just clobbering

00:03:49,849 --> 00:03:55,769
people's existing say routines so what

00:03:53,220 --> 00:03:58,440
we did is we said you have to say that

00:03:55,769 --> 00:04:03,389
you want say and the way you do that is

00:03:58,440 --> 00:04:06,030
by saying use feature say and we had a

00:04:03,389 --> 00:04:08,250
bunch of these and we finally decided if

00:04:06,030 --> 00:04:09,480
you say that you want version 5 10 we're

00:04:08,250 --> 00:04:11,970
going to give you all the features at 5

00:04:09,480 --> 00:04:17,160
10 introduced and the same in 512 and so

00:04:11,970 --> 00:04:20,930
on and in 516 we have sort of nailed

00:04:17,160 --> 00:04:23,789
down what it means what the scope is and

00:04:20,930 --> 00:04:25,440
the import of this is not that you need

00:04:23,789 --> 00:04:27,520
to understand most of this stuff I think

00:04:25,440 --> 00:04:30,009
most people will find it straightforward

00:04:27,520 --> 00:04:31,150
and if you don't please tell me tom is

00:04:30,009 --> 00:04:32,289
hiding his hands I think because he

00:04:31,150 --> 00:04:36,310
doesn't find a straightforward and he

00:04:32,289 --> 00:04:38,560
hates it look well all i'm going is to

00:04:36,310 --> 00:04:41,259
say that some of the things that we're

00:04:38,560 --> 00:04:44,530
going to see here you need to say use

00:04:41,259 --> 00:04:47,590
five 16-0 you need to say use 5 14 0 and

00:04:44,530 --> 00:04:48,940
i'm not going to get into this what I'm

00:04:47,590 --> 00:04:50,379
going to say to solve the whole thing

00:04:48,940 --> 00:04:52,840
because I'm just trying to cover the

00:04:50,379 --> 00:04:55,090
things you want to get the job done is

00:04:52,840 --> 00:04:57,370
that when you are using a version of

00:04:55,090 --> 00:04:59,229
Perl you should specify the version that

00:04:57,370 --> 00:05:00,759
you need and that you are expecting at

00:04:59,229 --> 00:05:06,099
the top of your program you should say

00:05:00,759 --> 00:05:07,930
use 5 12 0 use 5 16 0 this is telling

00:05:06,099 --> 00:05:09,880
pearl this is the version i'm expecting

00:05:07,930 --> 00:05:14,050
please try to behave as much like it as

00:05:09,880 --> 00:05:18,759
you can ok now i'm really going to talk

00:05:14,050 --> 00:05:21,310
about cool new features and this is one

00:05:18,759 --> 00:05:24,370
of my top 3 features in the last couple

00:05:21,310 --> 00:05:27,840
years say you have a piece of code like

00:05:24,370 --> 00:05:30,099
this all right you've got a string and

00:05:27,840 --> 00:05:33,310
when you run the program you get this

00:05:30,099 --> 00:05:36,610
error message all right use of

00:05:33,310 --> 00:05:39,940
uninitialized value in concatenation ok

00:05:36,610 --> 00:05:42,039
well which one and especially if you

00:05:39,940 --> 00:05:43,719
know one of them is an empty string so

00:05:42,039 --> 00:05:47,440
you look at the output you don't know

00:05:43,719 --> 00:05:50,259
what the heck happened as of 5 10 you

00:05:47,440 --> 00:05:57,130
get that I mean you know it's a little

00:05:50,259 --> 00:05:58,900
thing but he's little um only when you

00:05:57,130 --> 00:06:00,639
use an interpolating string yeah yeah if

00:05:58,900 --> 00:06:01,930
you um if you use if you use a non

00:06:00,639 --> 00:06:03,789
interpolating string it's going to have

00:06:01,930 --> 00:06:07,060
no warning at all which is that behavior

00:06:03,789 --> 00:06:08,620
goes back quite a ways um this is you

00:06:07,060 --> 00:06:10,090
know it's a nice little change but these

00:06:08,620 --> 00:06:11,770
little changes I think we're going to

00:06:10,090 --> 00:06:12,909
see throughout the talk these are the

00:06:11,770 --> 00:06:14,380
changes that really make the

00:06:12,909 --> 00:06:15,969
improvements a lot of the bigger stuff

00:06:14,380 --> 00:06:17,409
you know you don't know what to do it

00:06:15,969 --> 00:06:19,120
you know how to make heads or tails some

00:06:17,409 --> 00:06:20,500
of these big changes and we have yet to

00:06:19,120 --> 00:06:22,330
figure out whether they're awesome or

00:06:20,500 --> 00:06:27,789
terrible this is just straight up

00:06:22,330 --> 00:06:29,229
awesome state variables so even some

00:06:27,789 --> 00:06:32,500
code and you've got some kind of global

00:06:29,229 --> 00:06:34,449
variable and you want to protect that

00:06:32,500 --> 00:06:37,509
variable you don't want anybody screw

00:06:34,449 --> 00:06:39,370
around with how many lines are left so

00:06:37,509 --> 00:06:41,790
the obvious thing to do here is make it

00:06:39,370 --> 00:06:44,400
lexical all right now you've

00:06:41,790 --> 00:06:47,700
greatly reduce the scope in which this

00:06:44,400 --> 00:06:49,410
variable is visible but the problem is

00:06:47,700 --> 00:06:50,640
right somebody writes a subroutine under

00:06:49,410 --> 00:06:52,830
that one they can still see your

00:06:50,640 --> 00:06:54,660
variable they can watch it they know

00:06:52,830 --> 00:06:56,700
what it's doing they can change it and

00:06:54,660 --> 00:06:58,590
you got to keep it safe right you want

00:06:56,700 --> 00:07:01,170
you don't want your variables changing

00:06:58,590 --> 00:07:03,000
mutable state is the enemy in your

00:07:01,170 --> 00:07:06,090
program so what do you wrap it in this

00:07:03,000 --> 00:07:08,400
and this breaks one of my cardinal rules

00:07:06,090 --> 00:07:10,400
which is thou shalt not start a

00:07:08,400 --> 00:07:13,800
subroutine outside of column zero

00:07:10,400 --> 00:07:15,540
because when you grep you grew up your

00:07:13,800 --> 00:07:19,290
name subroutines with you know carrot

00:07:15,540 --> 00:07:22,890
sub it it's just how it works so pro 5

00:07:19,290 --> 00:07:25,470
10 also gives you this guy state

00:07:22,890 --> 00:07:26,910
variables that state variable it's going

00:07:25,470 --> 00:07:29,100
to keep its value through in vacations

00:07:26,910 --> 00:07:33,060
it's like it's like one of the static

00:07:29,100 --> 00:07:34,920
variables and see um you've you in many

00:07:33,060 --> 00:07:36,540
ways built a closure here without having

00:07:34,920 --> 00:07:38,580
to go through the nonsense of adding

00:07:36,540 --> 00:07:40,080
extra braces and saying my and keeping

00:07:38,580 --> 00:07:41,760
keeping track of why you've done that

00:07:40,080 --> 00:07:43,290
it's very clear why you've done it

00:07:41,760 --> 00:07:46,140
you've made a state variable it holds

00:07:43,290 --> 00:07:48,090
its state really nice stuff and by the

00:07:46,140 --> 00:07:49,830
way if my explanations don't make any

00:07:48,090 --> 00:07:51,150
sense or you don't understand what I'm

00:07:49,830 --> 00:07:52,230
going on about please just wave your

00:07:51,150 --> 00:07:53,040
hand and tell me because I know I'm

00:07:52,230 --> 00:07:54,630
going through a lot of this stuff

00:07:53,040 --> 00:08:04,160
quickly because there's a lot of stuff

00:07:54,630 --> 00:08:06,510
to go through no state and state is

00:08:04,160 --> 00:08:09,510
implicitly my it makes a lexical

00:08:06,510 --> 00:08:12,060
variable that retains its state so state

00:08:09,510 --> 00:08:17,000
is lexical and of course there's no need

00:08:12,060 --> 00:08:19,650
for our state because they're shared

00:08:17,000 --> 00:08:24,840
okay another really really nice little

00:08:19,650 --> 00:08:27,360
change so we've got some code and it

00:08:24,840 --> 00:08:30,360
does this all right I've written this

00:08:27,360 --> 00:08:33,419
code a million zillion times but the

00:08:30,360 --> 00:08:36,510
problem is some things are free right

00:08:33,419 --> 00:08:37,979
some things have a cost of zero I'm

00:08:36,510 --> 00:08:40,500
sorry sometimes we're giving things away

00:08:37,979 --> 00:08:42,060
for free so amount is zero but now we

00:08:40,500 --> 00:08:43,710
can't give it away for free because 0 is

00:08:42,060 --> 00:08:47,010
false so you put the cost in there and

00:08:43,710 --> 00:08:52,010
so we end up writing this guy with the

00:08:47,010 --> 00:08:52,010
check that it's defined but

00:08:53,250 --> 00:08:59,860
well that was weird sorry we want to

00:08:56,020 --> 00:09:02,230
check this guy's defined well in 5-10 we

00:08:59,860 --> 00:09:04,839
let you take that operator and kind of

00:09:02,230 --> 00:09:14,440
say I don't really mean true I mean

00:09:04,839 --> 00:09:18,339
defined so any place yes okay the the

00:09:14,440 --> 00:09:21,070
this operator acts just like for very

00:09:18,339 --> 00:09:23,410
very large values of just like that

00:09:21,070 --> 00:09:25,779
Turner II right what we're saying is the

00:09:23,410 --> 00:09:28,150
thing to find if so it otherwise the

00:09:25,779 --> 00:09:29,770
other thing now here I've got a composed

00:09:28,150 --> 00:09:31,720
operator right we're saying assigned to

00:09:29,770 --> 00:09:33,820
the thing on the left unless it's

00:09:31,720 --> 00:09:37,570
already defined even if it's a false

00:09:33,820 --> 00:09:40,180
defined value from all the people I

00:09:37,570 --> 00:09:42,640
talked to who use 5 10 and later in

00:09:40,180 --> 00:09:46,350
production this is the most cited thing

00:09:42,640 --> 00:09:49,510
people like in the new pearl yeah it's

00:09:46,350 --> 00:09:52,060
it's a goofy little change but it you

00:09:49,510 --> 00:09:59,410
can use it for all kinds of stuff there

00:09:52,060 --> 00:10:00,730
was a question so the question was are

00:09:59,410 --> 00:10:04,060
there are we going to extend this to

00:10:00,730 --> 00:10:09,010
have operators or behavior for existence

00:10:04,060 --> 00:10:12,089
or length no there was talk there was

00:10:09,010 --> 00:10:14,890
actually talk of an exists or operator

00:10:12,089 --> 00:10:18,160
and the basic decision was you don't

00:10:14,890 --> 00:10:20,770
need it enough to be worth the increased

00:10:18,160 --> 00:10:22,870
complexity of reading the code I have

00:10:20,770 --> 00:10:24,760
not seen anyone talk about a length 'ish

00:10:22,870 --> 00:10:26,080
version of it but there are some

00:10:24,760 --> 00:10:29,230
improvements to length that I'll talk

00:10:26,080 --> 00:10:33,060
about later that make it a least a

00:10:29,230 --> 00:10:38,740
little less needed or less wanted okay

00:10:33,060 --> 00:10:44,650
right so instead of writing this guy you

00:10:38,740 --> 00:10:46,420
could write this great say I already

00:10:44,650 --> 00:10:47,529
talked about say I spoiled this section

00:10:46,420 --> 00:10:49,690
but I'm going to go over it again cuz

00:10:47,529 --> 00:10:52,690
say is pretty great say is a new

00:10:49,690 --> 00:10:55,450
built-in and it's just like print but

00:10:52,690 --> 00:11:00,130
attacks on a new line so you used to do

00:10:55,450 --> 00:11:02,410
print this print that print these and

00:11:00,130 --> 00:11:04,840
now you can save you know four

00:11:02,410 --> 00:11:08,050
characters save six characters

00:11:04,840 --> 00:11:10,900
nine characters which is you know it

00:11:08,050 --> 00:11:12,340
adds up and beyond that it it makes

00:11:10,900 --> 00:11:14,530
things simpler to read by getting rid of

00:11:12,340 --> 00:11:16,390
these double quotes worrying about the

00:11:14,530 --> 00:11:18,220
the the syntax highlighting and whether

00:11:16,390 --> 00:11:20,710
things are going to look right which I I

00:11:18,220 --> 00:11:22,750
obsess about making making all the

00:11:20,710 --> 00:11:24,850
colors right my editor it makes your

00:11:22,750 --> 00:11:26,410
code just a little easier to use at the

00:11:24,850 --> 00:11:29,470
beginning when 510 was coming out I

00:11:26,410 --> 00:11:33,520
thought this was dumb I thought it was

00:11:29,470 --> 00:11:35,170
fluff I didn't see the value I'm still

00:11:33,520 --> 00:11:38,530
may be on the fence but I will say I use

00:11:35,170 --> 00:11:48,210
it all the time I you say like a crazy

00:11:38,530 --> 00:11:50,710
person yes question hey it's is it

00:11:48,210 --> 00:11:52,330
Thomas saying that it is a literal new

00:11:50,710 --> 00:11:54,070
line which is interesting because they'd

00:11:52,330 --> 00:11:56,080
behave the instructions if you have this

00:11:54,070 --> 00:11:57,790
is getting off topic the instructions if

00:11:56,080 --> 00:11:59,680
you have a tide filehandle are to use

00:11:57,790 --> 00:12:02,620
dollar / the output records the output

00:11:59,680 --> 00:12:04,450
the line separator well that's that's

00:12:02,620 --> 00:12:06,580
terrible and maybe we'll consider that a

00:12:04,450 --> 00:12:08,410
bug and you should file a bug and we'll

00:12:06,580 --> 00:12:09,960
discuss it on the list but not now

00:12:08,410 --> 00:12:14,260
because I've got a lot of slides left

00:12:09,960 --> 00:12:17,680
okay oh yes so if you want to write this

00:12:14,260 --> 00:12:19,780
the time i use say the most is when i'm

00:12:17,680 --> 00:12:21,250
writing one-liners right i don't know

00:12:19,780 --> 00:12:23,860
about you but the way I used to always

00:12:21,250 --> 00:12:27,010
write my run one-liners was with pearl

00:12:23,860 --> 00:12:29,140
dash Ellie all right stick on extra new

00:12:27,010 --> 00:12:33,520
line when you print and then evaluate my

00:12:29,140 --> 00:12:36,700
code you don't need that l if you have

00:12:33,520 --> 00:12:41,980
say but you don't have say unless you

00:12:36,700 --> 00:12:47,170
use feature say but instead of saying

00:12:41,980 --> 00:12:49,720
pearl e you can say pearl II and the

00:12:47,170 --> 00:12:53,440
capital guy says I want you to evaluate

00:12:49,720 --> 00:12:54,820
this with as many features as you got or

00:12:53,440 --> 00:12:57,310
basically all the features in the

00:12:54,820 --> 00:12:58,900
current version of Perl so you know over

00:12:57,310 --> 00:13:01,330
time the definition of what that is

00:12:58,900 --> 00:13:02,680
going to do can change but this is at

00:13:01,330 --> 00:13:03,850
least in my mind pearl is for writing

00:13:02,680 --> 00:13:06,390
one-liners you know you're not writing

00:13:03,850 --> 00:13:13,210
this code to stand the test of the ages

00:13:06,390 --> 00:13:14,320
so okay okay moving on recursion I can't

00:13:13,210 --> 00:13:16,390
talk about computer programming without

00:13:14,320 --> 00:13:25,810
talking about recursion

00:13:16,390 --> 00:13:27,940
oh I'm not taking that um and and of

00:13:25,810 --> 00:13:29,890
course the example I have to use is is

00:13:27,940 --> 00:13:32,800
factorial because I don't know how to do

00:13:29,890 --> 00:13:35,410
any other recursion and the way it works

00:13:32,800 --> 00:13:37,630
is we've written a subroutine called

00:13:35,410 --> 00:13:39,550
fact which gives us factorial and I it's

00:13:37,630 --> 00:13:42,670
a it's a lousy factorial but let's let's

00:13:39,550 --> 00:13:44,980
pretend it's good and it's going to call

00:13:42,670 --> 00:13:49,210
itself right if the input wasn't one

00:13:44,980 --> 00:13:52,270
then return the input x itself minus one

00:13:49,210 --> 00:13:55,270
and it can do that because it knows its

00:13:52,270 --> 00:13:59,320
name right everybody can see it is this

00:13:55,270 --> 00:14:01,510
clear to everybody okay but I don't want

00:13:59,320 --> 00:14:04,390
to make a name subroutine I want to call

00:14:01,510 --> 00:14:05,620
back or I want a private electrical

00:14:04,390 --> 00:14:07,270
subroutine that I can just kind of use

00:14:05,620 --> 00:14:09,460
briefly and throw away this doesn't need

00:14:07,270 --> 00:14:12,130
to live forever so it's easy right i

00:14:09,460 --> 00:14:15,730
write this instead of saying sub fact i

00:14:12,130 --> 00:14:20,220
say my fact equals this sub and then it

00:14:15,730 --> 00:14:24,280
calls itself but it doesn't work right

00:14:20,220 --> 00:14:25,840
because dollar fact isn't available when

00:14:24,280 --> 00:14:27,430
this lost line of code is evaluated

00:14:25,840 --> 00:14:29,530
dollar fact hasn't sprung into existence

00:14:27,430 --> 00:14:30,880
yet so it's going to get there and it's

00:14:29,530 --> 00:14:32,230
going to say well i don't know what this

00:14:30,880 --> 00:14:34,900
dollar fact thing is that you're talking

00:14:32,230 --> 00:14:36,760
about like there's no snow variable and

00:14:34,900 --> 00:14:39,580
it's going to fail to compile but that's

00:14:36,760 --> 00:14:41,110
okay because you could write this first

00:14:39,580 --> 00:14:42,760
i'll make the variable then i'll assign

00:14:41,110 --> 00:14:45,550
to it and it will be able to refer to

00:14:42,760 --> 00:14:49,630
itself but the problem is you've built a

00:14:45,550 --> 00:14:51,010
closure over itself and that by

00:14:49,630 --> 00:14:52,810
referring to itself means you're never

00:14:51,010 --> 00:14:54,220
going to get rid of the subroutine it's

00:14:52,810 --> 00:14:55,630
going to live in memory forever but

00:14:54,220 --> 00:14:58,560
that's okay because you can fix it just

00:14:55,630 --> 00:14:58,560
with this simple code

00:15:00,230 --> 00:15:07,079
and unless you're on debian it will

00:15:03,750 --> 00:15:10,649
probably work um no I'm kidding I love w

00:15:07,079 --> 00:15:12,360
um well this has been fixed by a feature

00:15:10,649 --> 00:15:16,079
that which i thought was surprising in

00:15:12,360 --> 00:15:19,680
its contentiousness if you use 516 you

00:15:16,079 --> 00:15:22,709
get this guy just like just like under

00:15:19,680 --> 00:15:24,050
under package or under under line it

00:15:22,709 --> 00:15:26,730
gives you the currently executing

00:15:24,050 --> 00:15:28,290
subroutine so you can write this just

00:15:26,730 --> 00:15:29,790
the way you wanted to you don't even

00:15:28,290 --> 00:15:33,750
need a name for the thing you could you

00:15:29,790 --> 00:15:35,850
need a variable to store it in a lexical

00:15:33,750 --> 00:15:37,889
variable like that you could pass around

00:15:35,850 --> 00:15:39,180
completely anonymously and it will

00:15:37,889 --> 00:15:41,850
properly be able to call itself

00:15:39,180 --> 00:15:44,610
recursively dollar dollar sub are under

00:15:41,850 --> 00:15:46,380
under sub under under evaluates to a

00:15:44,610 --> 00:15:50,610
reference to the currently executing sub

00:15:46,380 --> 00:15:51,779
which is killer useful time time time

00:15:50,610 --> 00:15:56,550
will tell but I think this is my

00:15:51,779 --> 00:16:04,620
favorite new thing in 516 how do you

00:15:56,550 --> 00:16:05,550
memorize that um I think you can but ask

00:16:04,620 --> 00:16:09,810
me later when I have more time to think

00:16:05,550 --> 00:16:25,440
about it that's a good question um file

00:16:09,810 --> 00:16:27,000
handles state variable yes yes no the

00:16:25,440 --> 00:16:29,279
cult caller won't do it for you because

00:16:27,000 --> 00:16:30,930
caller there I I think caller there's

00:16:29,279 --> 00:16:36,089
going to be string something like anon

00:16:30,930 --> 00:16:37,260
because yeah it's not it's going to be a

00:16:36,089 --> 00:16:39,029
string that can't resolve to anything

00:16:37,260 --> 00:16:40,980
caller caller doesn't have that

00:16:39,029 --> 00:16:42,449
information and one of the points of

00:16:40,980 --> 00:16:45,660
contention was this information belongs

00:16:42,449 --> 00:16:48,630
in caller but the caller routine already

00:16:45,660 --> 00:16:53,010
returns a list of I think 92 elements um

00:16:48,630 --> 00:16:55,290
and you know adding mores no it's like I

00:16:53,010 --> 00:16:57,560
think it's 14 or 10 it's it's too many

00:16:55,290 --> 00:16:57,560
um

00:17:01,730 --> 00:17:06,690
maybe yeah they're they're better their

00:17:04,680 --> 00:17:11,250
places to improve on this but this is

00:17:06,690 --> 00:17:17,280
already pretty sweet anybody else oh yes

00:17:11,250 --> 00:17:21,030
in the back yes it's true we don't have

00:17:17,280 --> 00:17:22,620
to do you think so that'd be nice we

00:17:21,030 --> 00:17:24,390
don't have tell Kyle so the comment was

00:17:22,620 --> 00:17:26,310
we don't have tail call optimization yet

00:17:24,390 --> 00:17:30,090
telco optimization is something we don't

00:17:26,310 --> 00:17:32,520
have in the core anywhere in Perl and it

00:17:30,090 --> 00:17:34,050
would be nice to have I got to say I'll

00:17:32,520 --> 00:17:35,820
believe it when I see it but I also very

00:17:34,050 --> 00:17:37,710
eager to see it so we'll see what

00:17:35,820 --> 00:17:43,170
happens ok next up I want to talk about

00:17:37,710 --> 00:17:47,270
file handles um 510 brings into the core

00:17:43,170 --> 00:17:50,400
auto die auto die is some good stuff

00:17:47,270 --> 00:17:52,770
auto guys like fatal if you don't know

00:17:50,400 --> 00:17:54,660
what fatal is it means more or less that

00:17:52,770 --> 00:17:56,810
when you do file operations or some

00:17:54,660 --> 00:17:59,520
other operations that would normally

00:17:56,810 --> 00:18:01,200
return a false value to tell you

00:17:59,520 --> 00:18:03,060
something didn't work it will die

00:18:01,200 --> 00:18:04,560
instead I'm simplifying but this is the

00:18:03,060 --> 00:18:06,980
most common way to use it so you'd say

00:18:04,560 --> 00:18:10,170
something like please open this file and

00:18:06,980 --> 00:18:10,980
and it would return false but now it's

00:18:10,170 --> 00:18:16,260
going to it's going to throw an

00:18:10,980 --> 00:18:17,880
exception so normally this is what

00:18:16,260 --> 00:18:19,380
people normally right they open

00:18:17,880 --> 00:18:22,740
something they read from and they close

00:18:19,380 --> 00:18:25,190
it what they should write has been this

00:18:22,740 --> 00:18:28,140
I open it and if you couldn't open it

00:18:25,190 --> 00:18:30,900
die right you can't just keep going and

00:18:28,140 --> 00:18:35,010
then read from it and when you're done

00:18:30,900 --> 00:18:37,440
close it and I'm opening this to write

00:18:35,010 --> 00:18:38,790
to and then i'm reading from it this is

00:18:37,440 --> 00:18:41,180
this is not what people should usually

00:18:38,790 --> 00:18:41,180
right

00:18:41,649 --> 00:18:48,320
yeah yes right if I if keynote supported

00:18:45,289 --> 00:18:49,549
pearl warnings but but you get the point

00:18:48,320 --> 00:18:50,809
right this should be this should be I

00:18:49,549 --> 00:18:52,940
should be writing to it there and then

00:18:50,809 --> 00:18:54,409
we close it and we should say if you

00:18:52,940 --> 00:18:57,919
couldn't close it died because the

00:18:54,409 --> 00:19:01,549
outputs not safely written out well with

00:18:57,919 --> 00:19:03,919
auto died tada you get rid of those and

00:19:01,549 --> 00:19:07,190
they are implicit there's an implicit or

00:19:03,919 --> 00:19:08,299
die on open there's an implicit only

00:19:07,190 --> 00:19:10,369
here I had to throw in some extra stuff

00:19:08,299 --> 00:19:13,669
there's you know we can say no auto die

00:19:10,369 --> 00:19:15,440
and then remove directory which normally

00:19:13,669 --> 00:19:18,529
would have returned false or true still

00:19:15,440 --> 00:19:21,169
will we don't actually need it in this

00:19:18,529 --> 00:19:23,929
case but but we can turn off auto die

00:19:21,169 --> 00:19:25,039
lexically which is which is really

00:19:23,929 --> 00:19:27,019
really nice we can also turn on

00:19:25,039 --> 00:19:28,729
lexically so we can just say right here

00:19:27,019 --> 00:19:31,070
I know that I'm going to do a bunch of

00:19:28,729 --> 00:19:32,539
stuff that could fail just just auto die

00:19:31,070 --> 00:19:34,879
right here everywhere else i know that

00:19:32,539 --> 00:19:36,589
i've done the correct thing there are

00:19:34,879 --> 00:19:38,809
two problems with auto died and i got to

00:19:36,589 --> 00:19:41,589
say they're pretty big ones the first

00:19:38,809 --> 00:19:44,029
one is auto die does not affect print

00:19:41,589 --> 00:19:48,200
basically because print is very special

00:19:44,029 --> 00:19:49,609
now can print fail um yeah it actually

00:19:48,200 --> 00:19:51,889
can it's pretty rare and you'll usually

00:19:49,609 --> 00:19:56,179
catch it later but print can fail but

00:19:51,889 --> 00:19:59,149
that's not the biggest problem okay

00:19:56,179 --> 00:20:00,619
we'll talk about it um Tom said we'd

00:19:59,149 --> 00:20:01,849
always catch it later and Tom's probably

00:20:00,619 --> 00:20:05,959
right he's usually right when I'm when

00:20:01,849 --> 00:20:08,659
I'm wrong but uh you have to close file

00:20:05,959 --> 00:20:11,269
handles explicitly this is like this is

00:20:08,659 --> 00:20:13,309
huge because one of the awesomest things

00:20:11,269 --> 00:20:14,659
about lexical file handles is that you

00:20:13,309 --> 00:20:17,959
don't have to worry about closing them

00:20:14,659 --> 00:20:19,669
except you really really do because when

00:20:17,959 --> 00:20:21,979
they close automatically when they're

00:20:19,669 --> 00:20:24,399
garbage collected they don't throw an

00:20:21,979 --> 00:20:26,869
exception so you always have to remember

00:20:24,399 --> 00:20:29,059
close it you don't have to say close or

00:20:26,869 --> 00:20:35,509
die with auto die but you do have to say

00:20:29,059 --> 00:20:37,609
closing later in 514 we get cool stuff

00:20:35,509 --> 00:20:43,570
with IO file all right so if you used to

00:20:37,609 --> 00:20:46,570
write this i'm going to open stuff and

00:20:43,570 --> 00:20:46,570
unbelievable

00:20:47,770 --> 00:20:51,620
I'd like to I'd like to take a moment to

00:20:50,030 --> 00:20:54,919
point out that my job with pearl is

00:20:51,620 --> 00:20:56,660
primarily administrative I don't

00:20:54,919 --> 00:21:00,590
actually write the code you guys are

00:20:56,660 --> 00:21:02,360
running um so for those of you who are

00:21:00,590 --> 00:21:03,620
who are totally bewildered I've opened

00:21:02,360 --> 00:21:11,809
it for reading now and now i'm printing

00:21:03,620 --> 00:21:16,900
to it um anyway um yes great um so this

00:21:11,809 --> 00:21:22,580
this hey this should fail right um in

00:21:16,900 --> 00:21:25,910
5-10 we got Auto died in 514 it we could

00:21:22,580 --> 00:21:28,429
also say this right i'm going to use io

00:21:25,910 --> 00:21:31,669
file and then when i open my file handle

00:21:28,429 --> 00:21:34,190
I can call methods on it I really like

00:21:31,669 --> 00:21:36,610
this I like it because it gets rid of

00:21:34,190 --> 00:21:39,620
the so called indirect object notation

00:21:36,610 --> 00:21:41,510
all right when you say print file handle

00:21:39,620 --> 00:21:44,600
stuff it's the same thing as saying

00:21:41,510 --> 00:21:46,400
filehandle arrow print stuff and I like

00:21:44,600 --> 00:21:47,540
things to look say me say me not

00:21:46,400 --> 00:21:48,740
everybody has to agree right there's

00:21:47,540 --> 00:21:52,490
there's reasons to do it reasons to not

00:21:48,740 --> 00:21:54,890
like it but I like it and in 514 you can

00:21:52,490 --> 00:21:57,380
get rid of that use io file and these

00:21:54,890 --> 00:21:59,059
methods will work automatically so you

00:21:57,380 --> 00:22:00,950
open your file handles and you can treat

00:21:59,059 --> 00:22:03,740
them like objects or more importantly

00:22:00,950 --> 00:22:05,540
you can write code that just expects to

00:22:03,740 --> 00:22:07,700
get past something that acts like a

00:22:05,540 --> 00:22:10,520
handle and it will work even if you pass

00:22:07,700 --> 00:22:16,160
in a plain old open file handle the

00:22:10,520 --> 00:22:19,820
problem is auto die which let you get

00:22:16,160 --> 00:22:23,179
rid of that is not going to let you get

00:22:19,820 --> 00:22:25,429
rid of that because auto die of X close

00:22:23,179 --> 00:22:27,500
like when you say closed file handle

00:22:25,429 --> 00:22:31,490
when you say filehandle arrow close auto

00:22:27,500 --> 00:22:33,230
dies not kicking in there so you need to

00:22:31,490 --> 00:22:34,549
mix or you need to pick you need to pick

00:22:33,230 --> 00:22:37,340
whether you want auto die or whether you

00:22:34,549 --> 00:22:38,990
want to treat stuff like handles that's

00:22:37,340 --> 00:22:43,390
all I have to say about file handles so

00:22:38,990 --> 00:22:43,390
questions before I move on Chris

00:22:46,470 --> 00:22:53,289
could you write auto die hints to make

00:22:49,149 --> 00:22:54,700
that work i think so i think that some

00:22:53,289 --> 00:22:57,249
things need to change and how we're

00:22:54,700 --> 00:22:58,749
doing some of the stuff in general but

00:22:57,249 --> 00:23:00,220
yeah i think it could probably be made

00:22:58,749 --> 00:23:09,730
to work with auto die and paul is here

00:23:00,220 --> 00:23:12,129
at Paul might have nate's Larry that's

00:23:09,730 --> 00:23:13,539
interesting so Larry says the way that

00:23:12,129 --> 00:23:16,419
you would do this in Perl 6 is you would

00:23:13,539 --> 00:23:18,159
return an unknown exception but if you

00:23:16,419 --> 00:23:19,539
were in void context it would be fatal

00:23:18,159 --> 00:23:23,019
and that's that's basically what use

00:23:19,539 --> 00:23:27,269
fatal and use auto die did but yeah

00:23:23,019 --> 00:23:33,879
that's a generic pearl sex behavior yeah

00:23:27,269 --> 00:23:35,860
that's nice um no but there's you

00:23:33,879 --> 00:23:38,879
there's used carp always Randall there

00:23:35,860 --> 00:23:38,879
is no auto croak

00:23:48,180 --> 00:23:58,660
which one other one armed er yeah yeah

00:23:55,410 --> 00:24:03,280
yeah i gotta say my slide coat my coat

00:23:58,660 --> 00:24:07,210
slide is code slide okay we got to keep

00:24:03,280 --> 00:24:09,160
moving gotta keep moving package blocks

00:24:07,210 --> 00:24:11,920
these are pretty cool so this is how

00:24:09,160 --> 00:24:13,930
people right packages now I've got a

00:24:11,920 --> 00:24:17,680
package and it's got a version and it's

00:24:13,930 --> 00:24:20,410
got some code in it ray in 514 it became

00:24:17,680 --> 00:24:22,840
possible to say this I've got a package

00:24:20,410 --> 00:24:25,900
with the version and then everything

00:24:22,840 --> 00:24:27,610
goes inside of this block so you instead

00:24:25,900 --> 00:24:30,550
of having to put a bare block around

00:24:27,610 --> 00:24:32,980
your package the package names the block

00:24:30,550 --> 00:24:34,090
which I like except that we go back to

00:24:32,980 --> 00:24:36,460
that rule that I talked about earlier

00:24:34,090 --> 00:24:40,720
about where you can start subroutines it

00:24:36,460 --> 00:24:41,950
makes me really cranky um and the place

00:24:40,720 --> 00:24:44,080
where this is useful is when you're

00:24:41,950 --> 00:24:46,180
declaring packages inside of other

00:24:44,080 --> 00:24:48,130
packages that's the place I find it most

00:24:46,180 --> 00:24:50,530
useful and we don't do that a lot in

00:24:48,130 --> 00:24:52,000
Perl but the great thing about this is

00:24:50,530 --> 00:24:55,110
the thing that makes me really happy is

00:24:52,000 --> 00:24:58,270
that that one two three four there is

00:24:55,110 --> 00:25:00,940
validated right you can put any garbage

00:24:58,270 --> 00:25:03,490
you want into our dollar version right

00:25:00,940 --> 00:25:06,910
you can say our dollar version equals my

00:25:03,490 --> 00:25:09,070
mom is a lovely woman um and it works

00:25:06,910 --> 00:25:10,690
you know like your code will run until

00:25:09,070 --> 00:25:13,810
something tries to treat it like a

00:25:10,690 --> 00:25:16,720
version and everything explodes if you

00:25:13,810 --> 00:25:18,160
try doing that with this syntax that is

00:25:16,720 --> 00:25:20,230
a compile-time error says dude that's

00:25:18,160 --> 00:25:23,380
not a version man just make it a version

00:25:20,230 --> 00:25:25,330
but but you don't have to use the thing

00:25:23,380 --> 00:25:27,610
that I don't like maybe you like this

00:25:25,330 --> 00:25:28,840
and if you like it that's cool but if

00:25:27,610 --> 00:25:32,130
you're like me and you don't like this

00:25:28,840 --> 00:25:34,840
in denton asst you can still say this

00:25:32,130 --> 00:25:36,970
i'm declaring my package here's its

00:25:34,840 --> 00:25:38,350
version and then acts just like the old

00:25:36,970 --> 00:25:40,480
package but gets you the validated

00:25:38,350 --> 00:25:42,580
version number which i really really

00:25:40,480 --> 00:25:44,290
like doing pause has some bugs

00:25:42,580 --> 00:25:47,170
recognizing this now but they've just

00:25:44,290 --> 00:25:49,390
started affecting me and i have on pause

00:25:47,170 --> 00:25:52,710
sometimes so hopefully I'll get to fix

00:25:49,390 --> 00:25:52,710
it yes

00:25:57,450 --> 00:26:01,240
it's right if you're using de Silla to

00:25:59,800 --> 00:26:03,370
set up your packages and you're using

00:26:01,240 --> 00:26:04,990
its most common way to declare your

00:26:03,370 --> 00:26:08,530
variables it is pre validating it for

00:26:04,990 --> 00:26:09,910
you but I but I use stuff outside to

00:26:08,530 --> 00:26:12,760
distill attuned I'm very happy to have

00:26:09,910 --> 00:26:16,030
this overloading there is this is my one

00:26:12,760 --> 00:26:19,420
slot and overloading overloading is both

00:26:16,030 --> 00:26:23,260
fantastic and horrible and in 516 it's

00:26:19,420 --> 00:26:26,230
even more we get some new overloads you

00:26:23,260 --> 00:26:27,820
can overload objects for file tests so

00:26:26,230 --> 00:26:29,710
you can say if someone asks whether I'm

00:26:27,820 --> 00:26:33,730
a regular file if someone asks whether I

00:26:29,710 --> 00:26:36,400
what my size is you can give answers you

00:26:33,730 --> 00:26:37,750
can overload QR which means if someone

00:26:36,400 --> 00:26:41,670
tries to use me like a regular

00:26:37,750 --> 00:26:44,410
expression this is how you should behave

00:26:41,670 --> 00:26:46,780
there's a new pragma called no

00:26:44,410 --> 00:26:48,940
overloading which lets you say in a

00:26:46,780 --> 00:26:51,520
lexical scope please don't overload

00:26:48,940 --> 00:26:55,150
right if objects in here would be

00:26:51,520 --> 00:26:58,450
affected by overloading don't um you

00:26:55,150 --> 00:27:00,970
should use this rarely very rarely but

00:26:58,450 --> 00:27:04,480
when you need to use it holy cow is it

00:27:00,970 --> 00:27:06,670
useful and how long that pic is to get

00:27:04,480 --> 00:27:09,160
this right if you tried declare in an

00:27:06,670 --> 00:27:11,860
overload on your package that doesn't

00:27:09,160 --> 00:27:14,860
exist all right like you try overloading

00:27:11,860 --> 00:27:18,540
the ? operator it'll tell you it's going

00:27:14,860 --> 00:27:22,360
to say dude there's no ? operator fix it

00:27:18,540 --> 00:27:24,820
so we just added that ok that's it for

00:27:22,360 --> 00:27:25,780
overloading so those are all the cool

00:27:24,820 --> 00:27:30,040
new features and now I want to talk

00:27:25,780 --> 00:27:39,190
about some other new features um smart

00:27:30,040 --> 00:27:42,280
match yay um I I'm ok so smart match was

00:27:39,190 --> 00:27:44,680
supposed to let you say if X matches why

00:27:42,280 --> 00:27:46,030
and for any kind of X and any kind of

00:27:44,680 --> 00:27:49,060
why it would give you an answer that

00:27:46,030 --> 00:27:50,320
made sense the problem is there's just

00:27:49,060 --> 00:27:51,910
not always an answer that makes sense

00:27:50,320 --> 00:27:54,250
and if there's an answer that that might

00:27:51,910 --> 00:27:56,830
make sense it's very often not the

00:27:54,250 --> 00:27:59,230
answer everyone expects it's an answer

00:27:56,830 --> 00:28:02,320
it's like this joke is really funny as

00:27:59,230 --> 00:28:03,970
after I explain it to you um it's an

00:28:02,320 --> 00:28:05,620
answer that could make sense yet it's

00:28:03,970 --> 00:28:06,880
one possible answer so it became very

00:28:05,620 --> 00:28:09,730
surprising and what made

00:28:06,880 --> 00:28:12,610
even more surprising is that right here

00:28:09,730 --> 00:28:15,940
if Y all the matching is determined by

00:28:12,610 --> 00:28:17,950
the right-hand side mostly and if Y was

00:28:15,940 --> 00:28:20,470
a literal you'd have a pretty good idea

00:28:17,950 --> 00:28:23,470
of what's going to happen but if you

00:28:20,470 --> 00:28:25,960
don't know what x and y are there's 23

00:28:23,470 --> 00:28:27,160
possible behaviors right how that's

00:28:25,960 --> 00:28:30,340
going to work and some of those

00:28:27,160 --> 00:28:32,500
behaviors re dispatch recursively so

00:28:30,340 --> 00:28:34,450
like you've got two inputs what's going

00:28:32,500 --> 00:28:36,220
to happen and like no you're not going

00:28:34,450 --> 00:28:38,860
to remember them you're not you're not

00:28:36,220 --> 00:28:40,450
going to remove these all do so the

00:28:38,860 --> 00:28:42,310
smart mashup behavior has become

00:28:40,450 --> 00:28:44,920
problematic and we've changed its

00:28:42,310 --> 00:28:46,300
behavior at least two and maybe three

00:28:44,920 --> 00:28:48,400
times since was introduced because we

00:28:46,300 --> 00:28:51,640
just keep finding stuff that doesn't

00:28:48,400 --> 00:28:54,910
make sense it's it's a bad feature I

00:28:51,640 --> 00:28:58,660
think it can be redeemed by cutting out

00:28:54,910 --> 00:29:00,790
large portions of its cortex but but my

00:28:58,660 --> 00:29:02,980
advice here is don't use it don't use it

00:29:00,790 --> 00:29:05,440
right now also it gave us a switch

00:29:02,980 --> 00:29:07,360
statement right after all these years

00:29:05,440 --> 00:29:12,490
pearl got a switch statement you really

00:29:07,360 --> 00:29:16,650
shouldn't use it it's two reasons sorry

00:29:12,490 --> 00:29:21,250
it can be fine with literals except um

00:29:16,650 --> 00:29:24,100
yeah except except the problem the the

00:29:21,250 --> 00:29:26,770
the main problem with literals is people

00:29:24,100 --> 00:29:28,690
are surprised by the behavior of numbers

00:29:26,770 --> 00:29:30,520
and strings together because people

00:29:28,690 --> 00:29:32,050
people some people say obviously it

00:29:30,520 --> 00:29:33,280
should be string wise equality and some

00:29:32,050 --> 00:29:37,780
people say obviously it should be

00:29:33,280 --> 00:29:39,490
numeric equality and um container

00:29:37,780 --> 00:29:42,790
literals become a problem because you

00:29:39,490 --> 00:29:45,730
have to remember what the containers do

00:29:42,790 --> 00:29:48,340
simple scalars simple scalars as your

00:29:45,730 --> 00:29:49,690
when clauses are okay you're not really

00:29:48,340 --> 00:29:55,450
getting that much from all of its power

00:29:49,690 --> 00:29:58,930
then also given given is like for its a

00:29:55,450 --> 00:30:01,840
four for the switch and it's going to

00:29:58,930 --> 00:30:03,280
put dollar X into the topic but not the

00:30:01,840 --> 00:30:04,900
normal topic you're used to it puts it

00:30:03,280 --> 00:30:06,820
into a lexical topic my dollar

00:30:04,900 --> 00:30:08,710
underscore and then if you write any

00:30:06,820 --> 00:30:11,170
subroutines like these guys that are

00:30:08,710 --> 00:30:12,730
going to close over the topic they'll

00:30:11,170 --> 00:30:15,580
now closed over the topic you don't

00:30:12,730 --> 00:30:19,540
close over the topic if you write the

00:30:15,580 --> 00:30:20,620
subroutine in in normal pearl land that

00:30:19,540 --> 00:30:23,260
dollar underscore would

00:30:20,620 --> 00:30:25,630
a global variable dollar underscore but

00:30:23,260 --> 00:30:28,180
if you've got a lexical topic in place

00:30:25,630 --> 00:30:30,820
you've just made a closure and it's

00:30:28,180 --> 00:30:32,680
going to look at a the lexical dollar

00:30:30,820 --> 00:30:34,120
underscore which is not the exception

00:30:32,680 --> 00:30:40,000
that you'd expect from this try block

00:30:34,120 --> 00:30:43,600
and this ah I guess in scanners um this

00:30:40,000 --> 00:30:44,860
it's it's it's a really it'sit's oh

00:30:43,600 --> 00:30:46,450
please don't use this again this is

00:30:44,860 --> 00:30:48,550
another feature that maybe can be saved

00:30:46,450 --> 00:30:51,070
I don't think the feature is a bad idea

00:30:48,550 --> 00:30:52,540
I think that it's got a number of severe

00:30:51,070 --> 00:30:55,720
implementation problems but until

00:30:52,540 --> 00:30:57,970
they're fixed just say no each array I

00:30:55,720 --> 00:31:01,900
like this guy to I like it a lot it lets

00:30:57,970 --> 00:31:04,179
you say for my index value equals each

00:31:01,900 --> 00:31:06,610
array or wild well not not for so lets

00:31:04,179 --> 00:31:09,790
you do just like you'd say each hash you

00:31:06,610 --> 00:31:10,870
can say each array I like that the

00:31:09,790 --> 00:31:13,210
problem is it suffers from the same

00:31:10,870 --> 00:31:15,010
problem as each hash which is the

00:31:13,210 --> 00:31:17,800
iterator is in an inconvenient place if

00:31:15,010 --> 00:31:20,110
you don't know what this means I got to

00:31:17,800 --> 00:31:21,280
not talk about it but the short answer

00:31:20,110 --> 00:31:25,179
is you shouldn't have been using each

00:31:21,280 --> 00:31:29,740
hash either um okay we got this guy to

00:31:25,179 --> 00:31:32,590
push dollar array ref a list so the idea

00:31:29,740 --> 00:31:35,530
was you could push on to an array

00:31:32,590 --> 00:31:37,929
reference you could splice an array

00:31:35,530 --> 00:31:42,670
reference this is called the auto drf

00:31:37,929 --> 00:31:44,500
behavior because it'll automatically

00:31:42,670 --> 00:31:46,150
dereference these things by figuring out

00:31:44,500 --> 00:31:48,370
what it should be now it's not really

00:31:46,150 --> 00:31:50,740
called the auto drf behavior it's called

00:31:48,370 --> 00:31:53,200
either the auto drf feature or the auto

00:31:50,740 --> 00:31:56,590
drf bug depending on to whom you're

00:31:53,200 --> 00:31:59,170
speaking there's a lot to be said for

00:31:56,590 --> 00:32:01,450
like the ugliness this feature can get

00:31:59,170 --> 00:32:02,800
rid of but there's also stuff to be said

00:32:01,450 --> 00:32:04,420
about different kinds of ugliness that

00:32:02,800 --> 00:32:06,760
it introduces and the future of this

00:32:04,420 --> 00:32:11,290
feature is unclear so I suggest not

00:32:06,760 --> 00:32:14,290
relying on it okay bug fixes the why

00:32:11,290 --> 00:32:17,950
2038 bug has been fixed uh yeah which is

00:32:14,290 --> 00:32:21,700
great um whoa Mike screen just went

00:32:17,950 --> 00:32:24,730
crazy on it used to be that to two

00:32:21,700 --> 00:32:26,170
30-second minus one was a January

00:32:24,730 --> 00:32:32,950
eighteen twenty thirty eight and one

00:32:26,170 --> 00:32:34,269
second later oops was 1901 and now it's

00:32:32,950 --> 00:32:38,349
not now it's actually one

00:32:34,269 --> 00:32:40,209
later this this bug mattered to me last

00:32:38,349 --> 00:32:42,369
week when somebody wanted to pay for PO

00:32:40,209 --> 00:32:44,739
box of his 50 years in advance you know

00:32:42,369 --> 00:32:47,109
and the old billing system couldn't do

00:32:44,739 --> 00:32:51,459
it the new building system can because

00:32:47,109 --> 00:32:55,320
of this fix fantastic um dollar at right

00:32:51,459 --> 00:32:58,059
so everybody uses try tiny right right

00:32:55,320 --> 00:33:00,219
good but this actually makes changes to

00:32:58,059 --> 00:33:05,080
dollar at make try tiny also more

00:33:00,219 --> 00:33:09,729
reliable because okay so first way to

00:33:05,080 --> 00:33:11,709
talk about eval eval is really bad I use

00:33:09,729 --> 00:33:13,839
evil all the time mostly use try tiny

00:33:11,709 --> 00:33:17,049
but it's got this problem in it that

00:33:13,839 --> 00:33:18,789
used to plague me and the problem is

00:33:17,049 --> 00:33:21,820
let's walk through this code we've got a

00:33:18,789 --> 00:33:24,789
package package X and whenever an object

00:33:21,820 --> 00:33:26,769
of X is destroyed it evals something

00:33:24,789 --> 00:33:28,320
here Z value nothing but we can just

00:33:26,769 --> 00:33:30,459
pretend whatever we want is in there and

00:33:28,320 --> 00:33:34,419
then we've got an object of that class

00:33:30,459 --> 00:33:36,249
and we do some stuff with it which here

00:33:34,419 --> 00:33:38,079
is nothing and then there's a fatal

00:33:36,249 --> 00:33:40,450
exception like something really bad

00:33:38,079 --> 00:33:42,099
happens and we leave that exit block and

00:33:40,450 --> 00:33:45,549
what are we expecting to see we're

00:33:42,099 --> 00:33:49,659
expecting to see error death but it's

00:33:45,549 --> 00:33:53,049
not what we see we see no error because

00:33:49,659 --> 00:33:56,109
the eval in the destroy method clobbered

00:33:53,049 --> 00:33:58,539
dollar app now out of curiosity who here

00:33:56,109 --> 00:34:00,700
has been bitten by this bug that's

00:33:58,539 --> 00:34:02,589
that's a bunch of people and I'm going

00:34:00,700 --> 00:34:03,609
to I'm going to be a jerk and suggest

00:34:02,589 --> 00:34:05,639
that some of you've been bitten by this

00:34:03,609 --> 00:34:07,570
buggy you don't even know it yeah it's

00:34:05,639 --> 00:34:09,129
sometimes in a row and then it worked

00:34:07,570 --> 00:34:12,700
again I don't know what happened this

00:34:09,129 --> 00:34:14,260
I've spent literally several full work

00:34:12,700 --> 00:34:17,859
days tracking things down to turned out

00:34:14,260 --> 00:34:21,279
to be this bug brutal bug and in 514

00:34:17,859 --> 00:34:26,169
it's gone and 514 you get the exception

00:34:21,279 --> 00:34:27,789
I it's that's great okay this is another

00:34:26,169 --> 00:34:32,169
little one this is a really nice one

00:34:27,789 --> 00:34:34,480
though who here knows dollar hat X Chris

00:34:32,169 --> 00:34:36,480
yeah okay so this is maybe a less

00:34:34,480 --> 00:34:38,919
commonly used feature dollar hat X

00:34:36,480 --> 00:34:41,409
contains the name of your perl

00:34:38,919 --> 00:34:43,119
interpreter right so very often it's

00:34:41,409 --> 00:34:44,559
going to be pearl depending on how you

00:34:43,119 --> 00:34:47,770
ran the program it might be user

00:34:44,559 --> 00:34:50,530
vinpearl on a bunch of platforms now

00:34:47,770 --> 00:34:53,500
we use the operating systems process

00:34:50,530 --> 00:34:56,110
table and we can tell you the actual

00:34:53,500 --> 00:34:59,080
path to the binary that's being run um

00:34:56,110 --> 00:35:00,430
which is really nice when you need to to

00:34:59,080 --> 00:35:02,710
pay attention to this and you don't want

00:35:00,430 --> 00:35:04,600
to jump through hoops using fine bin and

00:35:02,710 --> 00:35:06,430
in trying to inspect the process table

00:35:04,600 --> 00:35:09,160
yourself it stinks this just takes care

00:35:06,430 --> 00:35:11,440
of it it works I think it definitely

00:35:09,160 --> 00:35:15,610
works in Solaris and Mac OS and I think

00:35:11,440 --> 00:35:17,530
it works on BS DS yes Chris Chris is

00:35:15,610 --> 00:35:19,000
going to look into it meanwhile we're

00:35:17,530 --> 00:35:28,090
going to soldier on we've got 15 minutes

00:35:19,000 --> 00:35:33,670
left yeah good question I don't think it

00:35:28,090 --> 00:35:35,500
has uh I don't that's awesome I didn't

00:35:33,670 --> 00:35:39,370
help at all I thought maybe I could dim

00:35:35,500 --> 00:35:40,780
the lights yeah I'm sorry if something

00:35:39,370 --> 00:35:45,760
is unclear holler and I will read it

00:35:40,780 --> 00:35:48,640
aloud Chris yes wonderful works on so

00:35:45,760 --> 00:35:53,410
the dollar hat X is improved on freebsd

00:35:48,640 --> 00:35:56,710
ok moving on strings on I use strings a

00:35:53,410 --> 00:35:59,200
lot in perl i don't know about you pearl

00:35:56,710 --> 00:36:00,490
is pearl is good at unicode pearls

00:35:59,200 --> 00:36:03,010
actually really good at unicode and

00:36:00,490 --> 00:36:07,290
pulse 516 is better than any previous

00:36:03,010 --> 00:36:11,200
pearl first of all we got unicode 6.1

00:36:07,290 --> 00:36:14,920
which is a lot of characters took a

00:36:11,200 --> 00:36:17,650
whole lot of characters and you can get

00:36:14,920 --> 00:36:19,210
every character property from them now

00:36:17,650 --> 00:36:21,180
this is an everyday pro for everyone but

00:36:19,210 --> 00:36:24,460
for those of you who have to deal with

00:36:21,180 --> 00:36:25,690
with text and unicode text and really

00:36:24,460 --> 00:36:29,110
figuring out what the heck is going on

00:36:25,690 --> 00:36:32,560
with it this is really useful stuff also

00:36:29,110 --> 00:36:34,840
a dollar back x if you have to deal with

00:36:32,560 --> 00:36:37,090
this these are graphemes it makes a lot

00:36:34,840 --> 00:36:39,070
more sense graphene's are composed

00:36:37,090 --> 00:36:40,690
characters if you don't know what they

00:36:39,070 --> 00:36:41,830
are you don't care if you do know what

00:36:40,690 --> 00:36:47,920
they are you're probably already smiling

00:36:41,830 --> 00:36:52,030
um the unicode bug unicode bugs a really

00:36:47,920 --> 00:36:53,500
nice bug um and the bug is well it

00:36:52,030 --> 00:36:55,000
wasn't originally a but originally this

00:36:53,500 --> 00:36:58,090
thing was a feature and the idea was if

00:36:55,000 --> 00:37:00,520
you have a string and you try let's say

00:36:58,090 --> 00:37:01,100
matching a regex against it whether it's

00:37:00,520 --> 00:37:05,230
treated

00:37:01,100 --> 00:37:10,100
as bites or as characters as text

00:37:05,230 --> 00:37:11,930
depended on stuff like a bunch of

00:37:10,100 --> 00:37:13,280
conditions kind of put together and they

00:37:11,930 --> 00:37:15,650
all kind of seemed like they make sense

00:37:13,280 --> 00:37:17,090
but it's it's on it can seem

00:37:15,650 --> 00:37:22,730
unpredictable when you're just trying to

00:37:17,090 --> 00:37:25,700
do your job and the fix in 5 12 14 and

00:37:22,730 --> 00:37:29,150
16 over and over has been to let you say

00:37:25,700 --> 00:37:31,520
when i try to do strings stuff its

00:37:29,150 --> 00:37:34,280
character strings don't care about

00:37:31,520 --> 00:37:36,560
whether everything in it is under code

00:37:34,280 --> 00:37:40,820
point 255 don't care where it comes from

00:37:36,560 --> 00:37:42,860
just treat it like text again this this

00:37:40,820 --> 00:37:44,660
bug can cause really really stupid nasty

00:37:42,860 --> 00:37:46,430
behaviors especially because it's

00:37:44,660 --> 00:37:47,480
affected by I oh right you're getting

00:37:46,430 --> 00:37:48,710
input from somewhere how do you

00:37:47,480 --> 00:37:53,720
reproduce the bug well you get the same

00:37:48,710 --> 00:37:58,220
input good luck if you say use feature

00:37:53,720 --> 00:37:59,630
Unicode strings or use 512 I think

00:37:58,220 --> 00:38:02,660
everything everything that we know about

00:37:59,630 --> 00:38:05,660
will now treat your strings like text

00:38:02,660 --> 00:38:07,310
like character text solving innumerable

00:38:05,660 --> 00:38:11,570
bugs or probably numerable bugs that I

00:38:07,310 --> 00:38:14,420
haven't counted more stringy stuff eval

00:38:11,570 --> 00:38:17,330
so when you say eval string are you eval

00:38:14,420 --> 00:38:21,410
in a sequence of octets or are you see

00:38:17,330 --> 00:38:23,300
valine txt now the first answer is well

00:38:21,410 --> 00:38:24,830
they're the same thing in Perl but it

00:38:23,300 --> 00:38:27,260
matters because what if somewhere in

00:38:24,830 --> 00:38:28,730
there you've got use utf-8 right does

00:38:27,260 --> 00:38:31,250
that mean you should take the the stuff

00:38:28,730 --> 00:38:33,680
that's in the array of code points in

00:38:31,250 --> 00:38:35,720
dollar string and treat it like utf-8

00:38:33,680 --> 00:38:38,180
now or does it just mean that it was pre

00:38:35,720 --> 00:38:42,320
decoded and it's okay you can ignore the

00:38:38,180 --> 00:38:46,820
use each yet it it's totally totally

00:38:42,320 --> 00:38:49,580
nutty so in new pearl you get eat al

00:38:46,820 --> 00:38:52,520
bytes saying I've got a string please

00:38:49,580 --> 00:38:54,110
treat it like octets and evaluate it so

00:38:52,520 --> 00:38:55,520
you can load something from disk not

00:38:54,110 --> 00:38:58,010
worrying about its encoding yourself

00:38:55,520 --> 00:39:00,110
load the load the bites from disk and

00:38:58,010 --> 00:39:01,190
tell pearl treat this like you would

00:39:00,110 --> 00:39:04,670
have treated it if you would opened it

00:39:01,190 --> 00:39:06,800
yourself and you get Unicode eval where

00:39:04,670 --> 00:39:08,860
you say i've read this from disk I dealt

00:39:06,800 --> 00:39:11,780
with the encoding this is a string

00:39:08,860 --> 00:39:15,160
evaluate that so you can specifically

00:39:11,780 --> 00:39:15,160
say which behavior you want

00:39:15,830 --> 00:39:24,510
did I I think I probably said them

00:39:18,090 --> 00:39:27,570
backwards I'm sorry a unicode eval this

00:39:24,510 --> 00:39:30,240
is a very unclear slide unicode eval is

00:39:27,570 --> 00:39:33,180
a feature so if you use featured unicode

00:39:30,240 --> 00:39:35,520
eval eval expects strings and if you

00:39:33,180 --> 00:39:38,430
want bite semantics you say eval bytes

00:39:35,520 --> 00:39:39,630
fit yeah thank you for asking I didn't

00:39:38,430 --> 00:39:46,350
repeat the question but the answer makes

00:39:39,630 --> 00:39:47,700
it obvious right ok questions okay so I

00:39:46,350 --> 00:39:51,180
talked about some of my other favorite

00:39:47,700 --> 00:39:52,050
features I think my favorite 512 ISM as

00:39:51,180 --> 00:39:56,070
relates to something that came up

00:39:52,050 --> 00:40:01,080
earlier which is length if you ran this

00:39:56,070 --> 00:40:04,880
code in old pearl and that hash entry

00:40:01,080 --> 00:40:09,030
was undefined you would get a warning

00:40:04,880 --> 00:40:11,040
because length on undefined issues this

00:40:09,030 --> 00:40:12,119
morning that's just how it goes also

00:40:11,040 --> 00:40:16,860
it's too many lines in your program

00:40:12,119 --> 00:40:19,770
please cut it down in 512 you get no

00:40:16,860 --> 00:40:22,859
warning because length on undefined

00:40:19,770 --> 00:40:24,330
returns undefined you're still going to

00:40:22,859 --> 00:40:26,730
get a warning if you try using it like a

00:40:24,330 --> 00:40:28,560
number because using undefined as a

00:40:26,730 --> 00:40:30,720
number as a warning but the idea that

00:40:28,560 --> 00:40:33,150
that length has to return a number is

00:40:30,720 --> 00:40:34,140
gone and this deals the whole bunch of

00:40:33,150 --> 00:40:37,080
times when you would have said if

00:40:34,140 --> 00:40:40,020
defined X and length x you can get rid

00:40:37,080 --> 00:40:42,810
of that first part it's it's just a nice

00:40:40,020 --> 00:40:50,130
change right lot less it's a significant

00:40:42,810 --> 00:40:55,380
amount of code I don't write it does

00:40:50,130 --> 00:40:58,290
whatever it did before um yeah like that

00:40:55,380 --> 00:41:02,430
ok um we get a new a new escape dude

00:40:58,290 --> 00:41:05,970
back / 04 octal strings all right so i

00:41:02,430 --> 00:41:08,040
really love pearl the reason we want

00:41:05,970 --> 00:41:10,410
this is because if you tried saying that

00:41:08,040 --> 00:41:13,650
the old way you'd get some garbage like

00:41:10,410 --> 00:41:16,170
that because your octal escape could

00:41:13,650 --> 00:41:17,190
only be three digits long in fact I

00:41:16,170 --> 00:41:18,540
think it's even worse than that I've

00:41:17,190 --> 00:41:20,310
already forgotten the old behavior

00:41:18,540 --> 00:41:21,960
except that I danced some grave a little

00:41:20,310 --> 00:41:23,940
bit and now I always use back I to use

00:41:21,960 --> 00:41:26,810
backslash i use back sauce x okay let's

00:41:23,940 --> 00:41:31,130
face it but if you need octal you can do

00:41:26,810 --> 00:41:33,980
really nicely now okay yeah this guy

00:41:31,130 --> 00:41:39,350
also does something crazy and stupid we

00:41:33,980 --> 00:41:43,400
also lets us fix this problem this is

00:41:39,350 --> 00:41:45,290
not a real regex from work I admit I

00:41:43,400 --> 00:41:47,270
made this up but like what does this

00:41:45,290 --> 00:41:49,070
thing do yeah if you sit down and think

00:41:47,270 --> 00:41:51,410
about it and you know you can solve this

00:41:49,070 --> 00:41:53,690
but boy it stinks and if you don't know

00:41:51,410 --> 00:41:56,120
what stinks what stinks is sometimes

00:41:53,690 --> 00:41:58,640
those backslash numbers mean octal

00:41:56,120 --> 00:42:00,470
character sometimes they mean a capture

00:41:58,640 --> 00:42:01,490
group and sometimes they mean throw an

00:42:00,470 --> 00:42:05,270
exception because I don't know what to

00:42:01,490 --> 00:42:11,270
do I don't know man but if he was here

00:42:05,270 --> 00:42:15,470
today so what we get in new pearl is

00:42:11,270 --> 00:42:17,720
this backslash 0 if you want octo back /

00:42:15,470 --> 00:42:19,070
g if you want to capture group those

00:42:17,720 --> 00:42:23,300
captured groups work with negatives too

00:42:19,070 --> 00:42:25,130
it's pretty sweet um okay keep going so

00:42:23,300 --> 00:42:27,070
unicode 61 you get this whole bunch of

00:42:25,130 --> 00:42:31,160
characters it gets us like this guy and

00:42:27,070 --> 00:42:32,690
astronomy and massages and little birds

00:42:31,160 --> 00:42:36,200
and they're kind of looking around

00:42:32,690 --> 00:42:40,069
another and that's a dinner and it was

00:42:36,200 --> 00:42:43,369
really good so

00:42:40,069 --> 00:42:46,640
very very valuable features I actually

00:42:43,369 --> 00:42:49,910
use this everyday if you follow me on

00:42:46,640 --> 00:42:51,109
Twitter you know that already um but we

00:42:49,910 --> 00:42:55,759
get this now this is actually really

00:42:51,109 --> 00:42:58,579
nice um backslash big n for getting

00:42:55,759 --> 00:43:01,190
named unicode characters loads all the

00:42:58,579 --> 00:43:03,319
character names when it needs to so you

00:43:01,190 --> 00:43:04,999
can just you can just use it I never

00:43:03,319 --> 00:43:06,079
need to stop and run my program and see

00:43:04,999 --> 00:43:07,869
that it failed because it doesn't know

00:43:06,079 --> 00:43:10,849
the character name of heavy black heart

00:43:07,869 --> 00:43:14,599
and it'll load this now it'll slow to

00:43:10,849 --> 00:43:15,979
automatically the work also there's a

00:43:14,599 --> 00:43:17,769
there's a typo here because this is

00:43:15,979 --> 00:43:23,059
supposed to say I love Queens right and

00:43:17,769 --> 00:43:27,799
I have forgotten the Queen's um okay

00:43:23,059 --> 00:43:31,549
case folding so everyone here i am sure

00:43:27,799 --> 00:43:34,519
has written this take two strings and

00:43:31,549 --> 00:43:36,349
compare them without respect to case but

00:43:34,519 --> 00:43:38,199
that's not what this really says that

00:43:36,349 --> 00:43:41,269
says convert them both to lowercase and

00:43:38,199 --> 00:43:45,319
that's different than without respect to

00:43:41,269 --> 00:43:47,469
case not in english um in not in the

00:43:45,319 --> 00:43:50,390
english that you learn in primary school

00:43:47,469 --> 00:43:52,579
what you really want to do is fold case

00:43:50,390 --> 00:43:56,089
and if you can't see i've replaced the

00:43:52,579 --> 00:43:58,819
LCS with FCS to give you an example of

00:43:56,089 --> 00:44:03,499
why this matters right that's a sigma

00:43:58,819 --> 00:44:05,769
and that's a sigma and that's a sigma

00:44:03,499 --> 00:44:09,289
lower case Sigma is lower case Sigma

00:44:05,769 --> 00:44:12,469
upper case Sigma is is uppercase Sigma

00:44:09,289 --> 00:44:15,829
lower case Sigma are folded k Sigma is a

00:44:12,469 --> 00:44:17,569
different lower case Sigma whoa it's

00:44:15,829 --> 00:44:19,489
because the one the left is only used

00:44:17,569 --> 00:44:20,660
when you're at the end of a word but if

00:44:19,489 --> 00:44:22,880
you want to compare these things that

00:44:20,660 --> 00:44:24,469
respect to case you got to squish them

00:44:22,880 --> 00:44:27,319
down even further than lower case you

00:44:24,469 --> 00:44:29,329
gotta squish them down to fold case and

00:44:27,319 --> 00:44:31,099
this happens in other languages too

00:44:29,329 --> 00:44:35,749
right here's here's cinnamon some German

00:44:31,099 --> 00:44:39,319
um okay also be at back /l right or we

00:44:35,749 --> 00:44:40,640
have back / l great little guy for

00:44:39,319 --> 00:44:43,729
saying you want a lowercase everything

00:44:40,640 --> 00:44:45,079
that comes after you and back /f now

00:44:43,729 --> 00:44:48,170
let's you fold case everything that

00:44:45,079 --> 00:44:50,719
comes after you it's useful okay I'm

00:44:48,170 --> 00:44:52,530
going to keep going I'm long on slides

00:44:50,719 --> 00:44:55,760
in short on time so I'm going to go

00:44:52,530 --> 00:44:59,310
even faster unless somebody says stop

00:44:55,760 --> 00:45:03,990
okay we get name captures name captures

00:44:59,310 --> 00:45:06,420
our great on and yes finally catching up

00:45:03,990 --> 00:45:08,490
with dotnet so we've got a really really

00:45:06,420 --> 00:45:11,340
stupid file format and it looks like

00:45:08,490 --> 00:45:14,820
this section colon property equals value

00:45:11,340 --> 00:45:17,940
and we used to write this guy she's okay

00:45:14,820 --> 00:45:20,250
um it's not it's not that bad I mean the

00:45:17,940 --> 00:45:22,260
bad stuff is it is not it is not the

00:45:20,250 --> 00:45:23,130
capture groups but you can imagine what

00:45:22,260 --> 00:45:24,960
this looks like when we're actually

00:45:23,130 --> 00:45:26,190
parsing something bigger big and

00:45:24,960 --> 00:45:28,830
complicated it's a nightmare to remember

00:45:26,190 --> 00:45:30,570
how many here how many else here like

00:45:28,830 --> 00:45:31,710
finds themself using their fingers to

00:45:30,570 --> 00:45:33,420
count the bananas and figure out what

00:45:31,710 --> 00:45:37,830
capture group they're on yeah right is

00:45:33,420 --> 00:45:39,900
the left parenthesis now you say this

00:45:37,830 --> 00:45:41,400
the thing I'm capturing here is the

00:45:39,900 --> 00:45:42,780
section the thing I'm capturing here is

00:45:41,400 --> 00:45:44,850
the name the thing I'm capturing here is

00:45:42,780 --> 00:45:48,660
the value and then later you pull them

00:45:44,850 --> 00:45:53,730
out of percent-plus which stores the

00:45:48,660 --> 00:45:56,070
named captures really really useful ok

00:45:53,730 --> 00:45:58,050
this is I'm glad I got to this because

00:45:56,070 --> 00:46:02,460
this is probably my single favorite

00:45:58,050 --> 00:46:03,990
change in the last couple releases more

00:46:02,460 --> 00:46:07,710
so than that that undeath thing that I

00:46:03,990 --> 00:46:10,200
was lying about earlier um everybody

00:46:07,710 --> 00:46:13,080
probably understands this at some string

00:46:10,200 --> 00:46:14,850
and then you know hack off part of it

00:46:13,080 --> 00:46:19,980
I'm hack off everything after the first

00:46:14,850 --> 00:46:23,370
dot fine but these things should combine

00:46:19,980 --> 00:46:25,880
and so people write this I'll write this

00:46:23,370 --> 00:46:29,610
all the time but it doesn't work um

00:46:25,880 --> 00:46:32,760
because there's a precedence issue you

00:46:29,610 --> 00:46:35,550
need to do this and I got to say like

00:46:32,760 --> 00:46:37,680
explaining this having to add those

00:46:35,550 --> 00:46:40,440
parentheses parentheses takes it from

00:46:37,680 --> 00:46:41,790
simple obvious feature to slightly weird

00:46:40,440 --> 00:46:47,070
incantation why do I need those

00:46:41,790 --> 00:46:50,910
parentheses again um in 514 you get the

00:46:47,070 --> 00:46:54,290
Armada fire and our says don't modify

00:46:50,910 --> 00:46:58,470
the result in place return the new value

00:46:54,290 --> 00:47:02,730
this is awesome yeah

00:46:58,470 --> 00:47:04,260
and like for example this guy right we

00:47:02,730 --> 00:47:05,400
want short names and we're going to the

00:47:04,260 --> 00:47:08,040
short name is by mapping the

00:47:05,400 --> 00:47:11,220
substitution over the long names okay

00:47:08,040 --> 00:47:14,520
well the problem is s up the s operator

00:47:11,220 --> 00:47:16,260
returns whether it did anything so now

00:47:14,520 --> 00:47:18,060
short names is going to be like true and

00:47:16,260 --> 00:47:20,430
false values which is not useful so

00:47:18,060 --> 00:47:22,070
that's okay you do this all right do the

00:47:20,430 --> 00:47:26,160
substitution and then return the topic

00:47:22,070 --> 00:47:28,320
but but but but now you've altered long

00:47:26,160 --> 00:47:30,990
names like why didn't you just use for

00:47:28,320 --> 00:47:33,119
okay that's cool we'll do this ok we're

00:47:30,990 --> 00:47:35,849
going to copy it and we're going to fix

00:47:33,119 --> 00:47:42,690
that and return that well in 514 you can

00:47:35,849 --> 00:47:44,670
just say this um yeah it's huge okay

00:47:42,690 --> 00:47:53,310
there's a bunch of other regex modifiers

00:47:44,670 --> 00:47:54,780
um I got five minutes all right so so

00:47:53,310 --> 00:47:57,380
here we're trying to do some some

00:47:54,780 --> 00:48:00,390
theoretical matching first question is

00:47:57,380 --> 00:48:06,300
does a I think it's a Molly Allah digit

00:48:00,390 --> 00:48:09,150
5 does that match digit does an f match

00:48:06,300 --> 00:48:13,910
word character f is an old English

00:48:09,150 --> 00:48:18,890
letter which i sorely miss does the FF

00:48:13,910 --> 00:48:24,150
ligature match FF the two characters

00:48:18,890 --> 00:48:27,780
case-insensitive lee and does that

00:48:24,150 --> 00:48:30,170
ligature have the letter property I'm

00:48:27,780 --> 00:48:32,339
missing a backslash before that p um

00:48:30,170 --> 00:48:37,260
that's the only error in these slides so

00:48:32,339 --> 00:48:41,670
give me a break so the current behavior

00:48:37,260 --> 00:48:44,849
if you say use 516 is things act like

00:48:41,670 --> 00:48:47,849
they have the /u modifier use unicode

00:48:44,849 --> 00:48:51,420
meanings and in that case yes a Molly

00:48:47,849 --> 00:48:53,280
all digit is a digit Old English

00:48:51,420 --> 00:48:57,030
character an old English letter is a

00:48:53,280 --> 00:49:01,130
word character a ligature does match its

00:48:57,030 --> 00:49:05,190
component letters if you case fold it

00:49:01,130 --> 00:49:07,950
but that's not what people expect right

00:49:05,190 --> 00:49:11,710
well that's not what many people expect

00:49:07,950 --> 00:49:13,180
it's what linguists expect and I don't I

00:49:11,710 --> 00:49:19,329
don't really think linguists have any

00:49:13,180 --> 00:49:21,549
place in Perl um so a says I want a ski

00:49:19,329 --> 00:49:24,789
ish semantics and that means backslash d

00:49:21,549 --> 00:49:27,039
matches ascii digits back w matches ass

00:49:24,789 --> 00:49:29,650
keyword characters but that ligature

00:49:27,039 --> 00:49:32,049
thing is still going to match right and

00:49:29,650 --> 00:49:33,789
this can confuse you if depending on

00:49:32,049 --> 00:49:38,380
what you're trying to match so then you

00:49:33,789 --> 00:49:40,029
can say 'no no really asking um but that

00:49:38,380 --> 00:49:43,059
letter thing the property is still going

00:49:40,029 --> 00:49:47,700
to match who knows which of these is the

00:49:43,059 --> 00:49:50,440
default in in pro 58 anyone have a guess

00:49:47,700 --> 00:49:52,720
none none of these is the default the

00:49:50,440 --> 00:49:54,279
actual default behavior is that you will

00:49:52,720 --> 00:49:56,999
get behavior based on the eaching

00:49:54,279 --> 00:49:59,799
reading at the time of the string Nash

00:49:56,999 --> 00:50:04,180
it's it's really it's really kooky

00:49:59,799 --> 00:50:05,950
there's also back / l or /l which says

00:50:04,180 --> 00:50:09,309
use your locale settings just don't do

00:50:05,950 --> 00:50:10,569
it just don't um but how do you make

00:50:09,309 --> 00:50:12,460
this guy go away how do you make that

00:50:10,569 --> 00:50:14,680
that property letter I don't want to

00:50:12,460 --> 00:50:16,420
allow any non ascii character to match

00:50:14,680 --> 00:50:18,609
everything in this string has to be a

00:50:16,420 --> 00:50:20,200
ski it's very easy what you do is you

00:50:18,609 --> 00:50:22,599
say throw an exception if there's

00:50:20,200 --> 00:50:25,480
something that isn't a ski and then

00:50:22,599 --> 00:50:27,220
match the string right we're doing

00:50:25,480 --> 00:50:31,180
character semantics ligatures or

00:50:27,220 --> 00:50:32,920
characters deal with it ok some of this

00:50:31,180 --> 00:50:35,019
means the string ification of reg axis

00:50:32,920 --> 00:50:37,690
has changed right now we get that

00:50:35,019 --> 00:50:39,279
question hat you thing oh man I'm so out

00:50:37,690 --> 00:50:40,539
of time I'm going to fly through this

00:50:39,279 --> 00:50:41,559
and if you want to get up and leave go

00:50:40,539 --> 00:50:49,720
for it but I want to go through my other

00:50:41,559 --> 00:50:51,670
slides um what was talking here ok ok so

00:50:49,720 --> 00:50:53,019
study if you know what study is studies

00:50:51,670 --> 00:50:56,079
old behavior was to make your code

00:50:53,019 --> 00:50:58,180
slower and wrong studies newbie

00:50:56,079 --> 00:51:03,789
studies new behavior is to do nothing

00:50:58,180 --> 00:51:06,279
except for look pretty we have some new

00:51:03,789 --> 00:51:09,190
stuff in the core like JSON Jason's in

00:51:06,279 --> 00:51:11,920
the core ray um we got rid of some stuff

00:51:09,190 --> 00:51:13,209
like switch and all the old pro for

00:51:11,920 --> 00:51:15,219
libraries they're still on the sea pan

00:51:13,209 --> 00:51:17,799
they're still there it's cool but

00:51:15,219 --> 00:51:18,999
they're not the core anymore um we no

00:51:17,799 --> 00:51:24,880
longer allow you to pretend that you're

00:51:18,999 --> 00:51:26,469
writing Pascal we require that you put /

00:51:24,880 --> 00:51:28,839
ends here this is actually a there's no

00:51:26,469 --> 00:51:30,489
joke this is for real um you have to

00:51:28,839 --> 00:51:33,369
accept I would never cancel my season

00:51:30,489 --> 00:51:34,869
pass to Smallville um you now need to

00:51:33,369 --> 00:51:36,279
put / ends there for a long time you

00:51:34,869 --> 00:51:38,769
didn't but that was allowed because of a

00:51:36,279 --> 00:51:41,380
goofy parser heck that's all the stuff

00:51:38,769 --> 00:51:44,289
that got removed oh except for this you

00:51:41,380 --> 00:51:47,950
used to be able to say this right match

00:51:44,289 --> 00:51:50,499
foo /sand like what's what's the end

00:51:47,950 --> 00:51:55,719
modifier there it's not it's actually s

00:51:50,499 --> 00:51:57,069
and bar who needs white space that's

00:51:55,719 --> 00:52:01,599
gonna that's going to become fatal in

00:51:57,069 --> 00:52:02,859
518 a dollar left bracket isn't dollar

00:52:01,599 --> 00:52:08,229
left bracket that's so that you can say

00:52:02,859 --> 00:52:11,979
the first element of an array is one no

00:52:08,229 --> 00:52:14,369
um yes this is this is the warning I

00:52:11,979 --> 00:52:14,369
proposed

00:52:21,069 --> 00:52:26,390
we're getting rid of this um this has

00:52:24,530 --> 00:52:28,040
caused some consternation the issue is

00:52:26,390 --> 00:52:30,170
there's never been a really good

00:52:28,040 --> 00:52:34,099
definition of what defined at array

00:52:30,170 --> 00:52:35,329
means and people have used it to think

00:52:34,099 --> 00:52:37,609
that it means other things and it does

00:52:35,329 --> 00:52:39,440
so now it's issuing a warning and I'm

00:52:37,609 --> 00:52:43,540
hoping we can get rid of it and when we

00:52:39,440 --> 00:52:46,250
do that some of the very few nits in the

00:52:43,540 --> 00:52:48,290
forward slash forward slash defined or

00:52:46,250 --> 00:52:51,079
operator will go away but this is very

00:52:48,290 --> 00:52:53,660
speculative that's it okay all my slides

00:52:51,079 --> 00:52:54,829
I can take any questions and I will say

00:52:53,660 --> 00:52:57,010
that if you want to know what's going to

00:52:54,829 --> 00:52:58,910
happen the future of pearl maybe

00:52:57,010 --> 00:52:59,869
depending on how accurate my crystal

00:52:58,910 --> 00:53:02,569
ball is i'll be talking about that

00:52:59,869 --> 00:53:04,750
tomorrow any questions no thank you very

00:53:02,569 --> 00:53:04,750

YouTube URL: https://www.youtube.com/watch?v=5FvNoTo7Kfo


