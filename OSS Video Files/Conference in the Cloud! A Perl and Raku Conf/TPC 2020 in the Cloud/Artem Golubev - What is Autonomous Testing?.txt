Title: Artem Golubev - What is Autonomous Testing?
Publication date: 2020-06-24
Playlist: TPC 2020 in the Cloud
Description: 
	Classification of types of autonomous testing: - Types of functionality recognition/code generation + Discovery/rules-based + Pattern-recognition-based + Combinatorial-based - Types of testing: + Regression + Discovery

How do different types of systems under test affect tests support? What types of autonomous tests are one-off and what types are supportable.

Will walk through use cases for each type and when they are applicable. Talk about cases where all of them are not applicable. How autonomous testing can be integrated into CI/CD. Where integration to CD is possible and where it is not possible.

Youâ€™ll see different examples in practice.
Captions: 
	00:00:00,080 --> 00:00:05,120
you can do so thanks everyone for

00:00:03,520 --> 00:00:06,560
joining us today for that conference in

00:00:05,120 --> 00:00:07,600
the cloud for the pen and dracula

00:00:06,560 --> 00:00:09,200
community

00:00:07,600 --> 00:00:12,080
this is my pleasure to introduce you

00:00:09,200 --> 00:00:13,200
artem golub co-founder and ceo of test

00:00:12,080 --> 00:00:15,120
trigger

00:00:13,200 --> 00:00:16,880
which can help you improve test coverage

00:00:15,120 --> 00:00:17,680
by reducing the amount of manual testing

00:00:16,880 --> 00:00:20,160
at the same time

00:00:17,680 --> 00:00:22,000
and rtm 20 minutes talk is about

00:00:20,160 --> 00:00:26,000
autonomous testing

00:00:22,000 --> 00:00:26,000
so your turn you have the mic

00:00:26,640 --> 00:00:33,520
great hi everyone and i'm excited

00:00:30,000 --> 00:00:36,640
uh to be here and uh talk to you

00:00:33,520 --> 00:00:38,399
about oh what is autonomous testing how

00:00:36,640 --> 00:00:41,440
can you do that

00:00:38,399 --> 00:00:44,160
and uh i will walk you through

00:00:41,440 --> 00:00:45,920
uh different challenges we which we had

00:00:44,160 --> 00:00:49,520
seen with testing

00:00:45,920 --> 00:00:51,920
that in my career and uh

00:00:49,520 --> 00:00:53,280
different approaches of autonomous

00:00:51,920 --> 00:00:55,440
testing

00:00:53,280 --> 00:00:56,640
how would you do it if you were to do it

00:00:55,440 --> 00:00:59,920
yourself

00:00:56,640 --> 00:01:03,120
and what's available out there

00:00:59,920 --> 00:01:07,280
all right so currently what are

00:01:03,120 --> 00:01:09,680
the most prevalent ways to to test your

00:01:07,280 --> 00:01:10,320
web or mobile application if you were to

00:01:09,680 --> 00:01:13,680
write one

00:01:10,320 --> 00:01:17,520
so you can write automation testing

00:01:13,680 --> 00:01:18,880
uh using selenium desk affair or

00:01:17,520 --> 00:01:22,400
something like that

00:01:18,880 --> 00:01:25,520
you can use one of plentiful record and

00:01:22,400 --> 00:01:28,720
play tools to create tests or you can do

00:01:25,520 --> 00:01:32,159
uh some manual testing

00:01:28,720 --> 00:01:35,119
and uh

00:01:32,159 --> 00:01:36,479
would why this in the first place uh 60

00:01:35,119 --> 00:01:40,400
billion dollars lost

00:01:36,479 --> 00:01:43,200
in years due to box alone and overall a

00:01:40,400 --> 00:01:45,280
lack of reputation you can have churn of

00:01:43,200 --> 00:01:48,560
customers

00:01:45,280 --> 00:01:52,560
uh just because of the bugs

00:01:48,560 --> 00:01:56,159
so let's talk about uh test automation

00:01:52,560 --> 00:01:57,920
and why is it a problem i would assume

00:01:56,159 --> 00:02:01,840
that everyone

00:01:57,920 --> 00:02:04,399
believes that test needs to be automated

00:02:01,840 --> 00:02:05,920
uh if not you just be talking about how

00:02:04,399 --> 00:02:08,800
quickly you can retest

00:02:05,920 --> 00:02:10,000
your software if there is a new version

00:02:08,800 --> 00:02:12,400
if you just one person

00:02:10,000 --> 00:02:13,840
raising your own software is probably

00:02:12,400 --> 00:02:16,400
not worth it

00:02:13,840 --> 00:02:18,080
but if you have at least two people or

00:02:16,400 --> 00:02:21,599
more clearly

00:02:18,080 --> 00:02:24,640
you would want to do some automation

00:02:21,599 --> 00:02:27,120
and uh

00:02:24,640 --> 00:02:27,920
clearly you would want to automate your

00:02:27,120 --> 00:02:31,120
testing

00:02:27,920 --> 00:02:32,160
and specifically ui testing so well uh

00:02:31,120 --> 00:02:34,840
there are

00:02:32,160 --> 00:02:36,000
three as you know uh all number of three

00:02:34,840 --> 00:02:39,440
different

00:02:36,000 --> 00:02:41,440
uh types of tests uh you could do

00:02:39,440 --> 00:02:44,319
whereas unit tests

00:02:41,440 --> 00:02:45,599
and plentiful framework and very big

00:02:44,319 --> 00:02:48,080
believers that

00:02:45,599 --> 00:02:48,959
everyone should do unit tests for their

00:02:48,080 --> 00:02:52,480
code

00:02:48,959 --> 00:02:56,959
then there are tests

00:02:52,480 --> 00:03:00,159
uh integration tests again

00:02:56,959 --> 00:03:01,360
people will do those and i will talk

00:03:00,159 --> 00:03:05,080
today about

00:03:01,360 --> 00:03:06,480
end-to-end tests because we believe that

00:03:05,080 --> 00:03:09,519
[Music]

00:03:06,480 --> 00:03:14,159
end-to-end tests are

00:03:09,519 --> 00:03:17,680
the ones which brings the most value

00:03:14,159 --> 00:03:21,840
i if you can do them right

00:03:17,680 --> 00:03:25,519
right we all know of multiple challenges

00:03:21,840 --> 00:03:29,680
with end-to-end tests uh such as

00:03:25,519 --> 00:03:31,280
for example uh salesforce have built

00:03:29,680 --> 00:03:32,879
more than one million functional

00:03:31,280 --> 00:03:36,000
end-to-end tests

00:03:32,879 --> 00:03:36,879
and up to 80 percent of our tests are

00:03:36,000 --> 00:03:39,120
failing due

00:03:36,879 --> 00:03:40,959
close to release the release several

00:03:39,120 --> 00:03:45,840
times a year

00:03:40,959 --> 00:03:48,959
uh which is my bungling um

00:03:45,840 --> 00:03:49,519
test by the way by our estimation costed

00:03:48,959 --> 00:03:53,200
them

00:03:49,519 --> 00:03:56,000
about one thousand dollars to build

00:03:53,200 --> 00:03:57,360
so uh this is a super super expensive

00:03:56,000 --> 00:04:00,879
way to have a

00:03:57,360 --> 00:04:04,319
uh and uh tesco or chamber

00:04:00,879 --> 00:04:06,560
uh in general uh it's actually not an

00:04:04,319 --> 00:04:08,640
exception it's more like a rule because

00:04:06,560 --> 00:04:09,680
statistically speaking what we have seen

00:04:08,640 --> 00:04:12,879
is that

00:04:09,680 --> 00:04:16,000
uh for selenium tests anywhere between

00:04:12,879 --> 00:04:17,680
uh three and eight percent of all tests

00:04:16,000 --> 00:04:20,880
will always fail

00:04:17,680 --> 00:04:21,600
uh which might be okay if you do run uh

00:04:20,880 --> 00:04:25,440
manually

00:04:21,600 --> 00:04:29,440
however if you want to do

00:04:25,440 --> 00:04:31,600
just automation and use it as a sigma 4

00:04:29,440 --> 00:04:33,840
in your ci cd that's a big bummer

00:04:31,600 --> 00:04:36,560
because ucm4 will always be

00:04:33,840 --> 00:04:38,880
red and will not allow to deploy

00:04:36,560 --> 00:04:38,880
anything

00:04:39,440 --> 00:04:43,759
that's still probably not the largest

00:04:43,120 --> 00:04:47,360
issue

00:04:43,759 --> 00:04:47,360
with uh the

00:04:47,520 --> 00:04:51,600
test automation the largest probably

00:04:50,160 --> 00:04:55,199
being

00:04:51,600 --> 00:04:57,919
uh test maintenance

00:04:55,199 --> 00:04:59,440
again we estimate that you spend two and

00:04:57,919 --> 00:05:02,400
a half times

00:04:59,440 --> 00:05:03,919
uh more effort on test maintenance on

00:05:02,400 --> 00:05:08,000
every test compared to

00:05:03,919 --> 00:05:11,520
test creation uh and in general

00:05:08,000 --> 00:05:14,479
uh is just a ginormous

00:05:11,520 --> 00:05:15,600
uh drain of resources think about it why

00:05:14,479 --> 00:05:17,680
would you

00:05:15,600 --> 00:05:20,080
maintain your tests and spend a lot of

00:05:17,680 --> 00:05:23,199
time just maintaining tests if

00:05:20,080 --> 00:05:24,240
uh because the whole goal of them is

00:05:23,199 --> 00:05:27,199
very big

00:05:24,240 --> 00:05:27,199
we're running and

00:05:28,400 --> 00:05:32,080
and basically providing value

00:05:32,400 --> 00:05:39,520
and finally and this is related

00:05:36,320 --> 00:05:43,520
to the talk uh the third issue

00:05:39,520 --> 00:05:47,199
is uh well basically

00:05:43,520 --> 00:05:50,560
test creation where is the statistics

00:05:47,199 --> 00:05:54,160
that are only around

00:05:50,560 --> 00:05:55,440
30 percent of all documented end-to-end

00:05:54,160 --> 00:05:59,440
tests

00:05:55,440 --> 00:06:01,919
are automated today in 2020

00:05:59,440 --> 00:06:04,000
which is mind-boggling and i've

00:06:01,919 --> 00:06:07,440
monitored this number over the years

00:06:04,000 --> 00:06:10,960
and does not seem to change much

00:06:07,440 --> 00:06:14,400
so overall that what it tells me is that

00:06:10,960 --> 00:06:20,479
it's actually pretty hard to

00:06:14,400 --> 00:06:24,400
create automation in the first place

00:06:20,479 --> 00:06:27,280
and uh and manual testing of course

00:06:24,400 --> 00:06:28,160
uh is just you would think it would be

00:06:27,280 --> 00:06:30,800
much different

00:06:28,160 --> 00:06:31,680
and better but it's not really uh

00:06:30,800 --> 00:06:34,160
because

00:06:31,680 --> 00:06:36,319
the problem there is you would need to

00:06:34,160 --> 00:06:40,160
document those if you were to

00:06:36,319 --> 00:06:43,280
use third party to

00:06:40,160 --> 00:06:45,759
basically do your testing for you then

00:06:43,280 --> 00:06:47,120
your tests should be thoroughly

00:06:45,759 --> 00:06:50,400
documented

00:06:47,120 --> 00:06:51,840
is voice basically almost i exactly as

00:06:50,400 --> 00:06:53,599
software programming

00:06:51,840 --> 00:06:55,840
but you're just writing a document

00:06:53,599 --> 00:06:57,440
explaining what needs to be done

00:06:55,840 --> 00:06:59,599
and of course this approach doesn't

00:06:57,440 --> 00:07:00,840
always even work anyway so you would

00:06:59,599 --> 00:07:03,759
probably

00:07:00,840 --> 00:07:06,720
test manually locally

00:07:03,759 --> 00:07:06,720
training your

00:07:08,560 --> 00:07:17,280
people to on how to use your application

00:07:13,360 --> 00:07:19,440
and that's just expensive and slow

00:07:17,280 --> 00:07:21,199
process in general

00:07:19,440 --> 00:07:23,199
uh and of course if you need to quickly

00:07:21,199 --> 00:07:26,080
redeploy blocker in production you kind

00:07:23,199 --> 00:07:26,080
of are out of luck

00:07:26,160 --> 00:07:32,960
and talk about that so uh

00:07:30,240 --> 00:07:33,680
yeah there is a plug-and-play out there

00:07:32,960 --> 00:07:37,039
and

00:07:33,680 --> 00:07:40,000
uh uh well somebody

00:07:37,039 --> 00:07:41,440
it does not completely solve the problem

00:07:40,000 --> 00:07:44,639
uh somebody would need to

00:07:41,440 --> 00:07:45,120
create those tests in the first place uh

00:07:44,639 --> 00:07:46,960
which

00:07:45,120 --> 00:07:49,360
might be a little bit more effort than

00:07:46,960 --> 00:07:52,879
you you would think and then

00:07:49,360 --> 00:07:56,080
uh supporting those is a

00:07:52,879 --> 00:07:58,560
double nightmare because um any changes

00:07:56,080 --> 00:08:00,800
to your application

00:07:58,560 --> 00:08:02,960
build basically through a various tests

00:08:00,800 --> 00:08:05,360
and your only

00:08:02,960 --> 00:08:07,199
solution to that would be record

00:08:05,360 --> 00:08:11,440
everything from scratch

00:08:07,199 --> 00:08:14,240
which is my book ring and of course

00:08:11,440 --> 00:08:16,960
most of the tools are not stable there

00:08:14,240 --> 00:08:16,960
are exceptions

00:08:18,080 --> 00:08:24,639
okay so

00:08:21,360 --> 00:08:27,919
now let's talk about the fun stuff

00:08:24,639 --> 00:08:31,199
on how how

00:08:27,919 --> 00:08:35,039
would we do uh

00:08:31,199 --> 00:08:37,839
how would you do autonomous testing

00:08:35,039 --> 00:08:37,839
right let's say

00:08:38,560 --> 00:08:46,720
you want to cover your application

00:08:42,399 --> 00:08:50,160
we have tests uh what are possible

00:08:46,720 --> 00:08:50,160
ways to do that

00:08:51,040 --> 00:08:57,120
uh and uh like any challenge on its own

00:08:54,080 --> 00:09:00,959
uh uh let me walk you through

00:08:57,120 --> 00:09:01,760
uh uh and basically converge it to a

00:09:00,959 --> 00:09:05,279
different

00:09:01,760 --> 00:09:06,399
problem uh all together uh let's think

00:09:05,279 --> 00:09:09,519
of

00:09:06,399 --> 00:09:11,200
of uh testing and all possible things

00:09:09,519 --> 00:09:13,760
which you can do very step by step and

00:09:11,200 --> 00:09:16,320
they'll figure out

00:09:13,760 --> 00:09:17,680
what we should test in the first place

00:09:16,320 --> 00:09:20,800
so the question is

00:09:17,680 --> 00:09:21,760
can we do a test take questions more or

00:09:20,800 --> 00:09:25,279
should it test

00:09:21,760 --> 00:09:28,160
if you think about any application

00:09:25,279 --> 00:09:29,200
uh like thinking a little bit longer

00:09:28,160 --> 00:09:32,640
you'll realize

00:09:29,200 --> 00:09:34,000
that there are actually trillions and

00:09:32,640 --> 00:09:37,440
quadrillions different

00:09:34,000 --> 00:09:39,360
ways how you can test your application

00:09:37,440 --> 00:09:41,519
different flows

00:09:39,360 --> 00:09:44,080
uh not that's just how you can test it

00:09:41,519 --> 00:09:46,399
but what i'm talking about is different

00:09:44,080 --> 00:09:48,240
end-to-end scenarios on your application

00:09:46,399 --> 00:09:51,519
there are trillions of them

00:09:48,240 --> 00:09:54,880
so they literally uh uh

00:09:51,519 --> 00:09:58,880
think of it this way it's just a simple

00:09:54,880 --> 00:10:02,720
uh example of why it is so huge

00:09:58,880 --> 00:10:06,320
so every time you get to uh

00:10:02,720 --> 00:10:08,160
to a screen uh like not only

00:10:06,320 --> 00:10:09,920
a number of possibilities what you can

00:10:08,160 --> 00:10:12,160
do on that screen

00:10:09,920 --> 00:10:13,839
is equal to a number of different

00:10:12,160 --> 00:10:14,640
actions like links and buttons on the

00:10:13,839 --> 00:10:17,600
screen

00:10:14,640 --> 00:10:20,160
it's actually also multiplied by 2 in a

00:10:17,600 --> 00:10:23,920
factor of number of inputs

00:10:20,160 --> 00:10:26,880
on every screen if you were to test

00:10:23,920 --> 00:10:27,279
positive and negative inputs just even

00:10:26,880 --> 00:10:30,240
one

00:10:27,279 --> 00:10:31,279
negative input for every input you have

00:10:30,240 --> 00:10:34,240
on the screen

00:10:31,279 --> 00:10:35,519
so it explodes just very very very

00:10:34,240 --> 00:10:38,560
quickly

00:10:35,519 --> 00:10:40,480
uh for web application you can have

00:10:38,560 --> 00:10:42,320
three lanes of different ways to test

00:10:40,480 --> 00:10:42,959
application mobile applications a little

00:10:42,320 --> 00:10:45,200
bit

00:10:42,959 --> 00:10:47,440
more simple we have we might have in

00:10:45,200 --> 00:10:49,680
certain cases more limited

00:10:47,440 --> 00:10:50,959
uh functionality and more limited

00:10:49,680 --> 00:10:53,680
therefore

00:10:50,959 --> 00:10:54,640
a number of overall flows which your

00:10:53,680 --> 00:10:57,279
application your

00:10:54,640 --> 00:10:58,839
user could go through although they they

00:10:57,279 --> 00:11:01,680
could still be

00:10:58,839 --> 00:11:04,240
ginormous uh just think about it

00:11:01,680 --> 00:11:06,560
one example well just purely from

00:11:04,240 --> 00:11:10,079
mathematical perspective

00:11:06,560 --> 00:11:10,399
uh how a system could or somebody could

00:11:10,079 --> 00:11:14,079
go

00:11:10,399 --> 00:11:18,320
through your application just even on

00:11:14,079 --> 00:11:21,200
uh on sign in screen

00:11:18,320 --> 00:11:23,600
a user can fill out inputs and then

00:11:21,200 --> 00:11:27,839
instead of clicking sign in button

00:11:23,600 --> 00:11:31,519
here as a user could click

00:11:27,839 --> 00:11:35,360
the password sign up stuff like that

00:11:31,519 --> 00:11:37,440
and uh

00:11:35,360 --> 00:11:39,920
like if you think about it and calculate

00:11:37,440 --> 00:11:42,959
number of different

00:11:39,920 --> 00:11:43,839
flows which user can perform on your

00:11:42,959 --> 00:11:47,839
application

00:11:43,839 --> 00:11:50,800
the number is just huge now therefore

00:11:47,839 --> 00:11:52,480
then you're thinking about autonomous

00:11:50,800 --> 00:11:54,320
testing you shouldn't think about hey

00:11:52,480 --> 00:11:57,519
how do we generate tests

00:11:54,320 --> 00:11:58,920
it's it's a question about how do we

00:11:57,519 --> 00:12:02,880
select

00:11:58,920 --> 00:12:06,639
automatically what needs to be tested

00:12:02,880 --> 00:12:10,320
on your application that is

00:12:06,639 --> 00:12:10,800
what uh autonomous testing challenges

00:12:10,320 --> 00:12:13,600
about

00:12:10,800 --> 00:12:15,440
so in order to test your application the

00:12:13,600 --> 00:12:19,040
system should be able to go

00:12:15,440 --> 00:12:21,600
through your application and

00:12:19,040 --> 00:12:23,680
and then in order to test those so

00:12:21,600 --> 00:12:24,079
number one challenge is like how does it

00:12:23,680 --> 00:12:27,279
go

00:12:24,079 --> 00:12:30,880
through the puffs which brings the most

00:12:27,279 --> 00:12:32,880
value to users

00:12:30,880 --> 00:12:34,959
so you don't you can't test everything

00:12:32,880 --> 00:12:38,160
it would be trillions of combinations

00:12:34,959 --> 00:12:40,399
dreams and trend flows you can't

00:12:38,160 --> 00:12:42,560
therefore you should the system should

00:12:40,399 --> 00:12:46,399
be able to choose

00:12:42,560 --> 00:12:49,680
what's important enough to be tested

00:12:46,399 --> 00:12:52,800
and uh let's say you want to do it

00:12:49,680 --> 00:12:54,800
uh like uh

00:12:52,800 --> 00:12:56,079
might be a good idea in your application

00:12:54,800 --> 00:12:58,399
depending how it's built

00:12:56,079 --> 00:12:59,600
you could build it yourself i'll just uh

00:12:58,399 --> 00:13:03,680
give away

00:12:59,600 --> 00:13:06,639
the ideas on uh what's possible

00:13:03,680 --> 00:13:07,920
uh there are two ways uh that i'm

00:13:06,639 --> 00:13:11,760
familiar with

00:13:07,920 --> 00:13:15,279
on how to build uh and to end test which

00:13:11,760 --> 00:13:18,639
might bring at least some degree

00:13:15,279 --> 00:13:21,040
of a proper selection of the end time

00:13:18,639 --> 00:13:24,560
flows which needs to be tested

00:13:21,040 --> 00:13:27,920
and those are a

00:13:24,560 --> 00:13:32,440
kind of a crawler-based uh test

00:13:27,920 --> 00:13:36,079
generation uh or

00:13:32,440 --> 00:13:39,199
analytics-based test generation

00:13:36,079 --> 00:13:41,839
uh let me walk you through

00:13:39,199 --> 00:13:42,800
uh first the crawler-based generation so

00:13:41,839 --> 00:13:46,839
basically

00:13:42,800 --> 00:13:49,600
uh your uh

00:13:46,839 --> 00:13:52,800
uh basically your idea

00:13:49,600 --> 00:13:54,800
is to make sure that you go through

00:13:52,800 --> 00:13:56,079
like all the functionality which you

00:13:54,800 --> 00:14:01,680
need to build

00:13:56,079 --> 00:14:06,959
or to test and uh cover it with tests

00:14:01,680 --> 00:14:06,959
and some chats

00:14:07,279 --> 00:14:14,079
i slides are not stuck uh i'm

00:14:10,880 --> 00:14:15,760
just not advancing them so uh what to

00:14:14,079 --> 00:14:19,839
test is what i'm talking about

00:14:15,760 --> 00:14:19,839
in here so everything's fine

00:14:20,560 --> 00:14:28,079
okay so it's just a big big big topic

00:14:24,000 --> 00:14:31,440
yeah so another

00:14:28,079 --> 00:14:34,399
interesting um

00:14:31,440 --> 00:14:34,880
interesting way of doing that is uh of

00:14:34,399 --> 00:14:37,920
course

00:14:34,880 --> 00:14:38,320
you uh all control your application if

00:14:37,920 --> 00:14:42,720
you

00:14:38,320 --> 00:14:44,399
are uh

00:14:42,720 --> 00:14:46,720
like you're part of the team which

00:14:44,399 --> 00:14:50,480
builds the application

00:14:46,720 --> 00:14:53,920
uh then you kind of know

00:14:50,480 --> 00:14:58,320
what what is it about right

00:14:53,920 --> 00:15:01,600
so in theory uh you could uh

00:14:58,320 --> 00:15:04,560
build uh a

00:15:01,600 --> 00:15:06,800
a kind of finite automata representation

00:15:04,560 --> 00:15:09,920
of oh yeah how your application work

00:15:06,800 --> 00:15:13,279
and then generate tests uh

00:15:09,920 --> 00:15:17,040
going through possible states

00:15:13,279 --> 00:15:19,760
uh in order to just cover everything

00:15:17,040 --> 00:15:21,519
uh that's actually a dining dollar and i

00:15:19,760 --> 00:15:24,800
did work with the person

00:15:21,519 --> 00:15:27,440
who did just that uh

00:15:24,800 --> 00:15:28,320
like he is uh absolutely uh epic

00:15:27,440 --> 00:15:31,759
gentleman

00:15:28,320 --> 00:15:35,120
um and uh yeah he

00:15:31,759 --> 00:15:38,639
graduated from mit and got hired

00:15:35,120 --> 00:15:41,680
uh by microsoft uh to to do

00:15:38,639 --> 00:15:45,680
uh to do testing and

00:15:41,680 --> 00:15:46,480
uh like at that time it was a task to

00:15:45,680 --> 00:15:49,199
test

00:15:46,480 --> 00:15:50,880
macra assembler if people remember still

00:15:49,199 --> 00:15:54,240
a bad thing

00:15:50,880 --> 00:15:56,320
which microsoft had i'm not sure i don't

00:15:54,240 --> 00:16:01,360
know if you still have it

00:15:56,320 --> 00:16:04,399
um and uh like he was tasked to

00:16:01,360 --> 00:16:07,440
basically test it

00:16:04,399 --> 00:16:10,160
and write some automation tests and he

00:16:07,440 --> 00:16:11,279
approached it very creatively he

00:16:10,160 --> 00:16:14,639
literally did

00:16:11,279 --> 00:16:19,600
write create a finite automata of

00:16:14,639 --> 00:16:23,360
uh how compiler works

00:16:19,600 --> 00:16:26,000
and generated thousands of tests

00:16:23,360 --> 00:16:27,759
run them and found a lot of and a lot of

00:16:26,000 --> 00:16:29,759
bugs

00:16:27,759 --> 00:16:31,199
very creative approaches so literally

00:16:29,759 --> 00:16:33,120
people did that

00:16:31,199 --> 00:16:35,040
tens of years ago it's nothing new in

00:16:33,120 --> 00:16:37,920
here

00:16:35,040 --> 00:16:39,920
so that uh that's the way to do it for a

00:16:37,920 --> 00:16:41,360
more simple application and by the way

00:16:39,920 --> 00:16:43,199
uh you might

00:16:41,360 --> 00:16:44,720
we might do it on your own it's not that

00:16:43,199 --> 00:16:46,079
a big deal if your application is simple

00:16:44,720 --> 00:16:50,720
and simple enough

00:16:46,079 --> 00:16:53,920
uh although uh uh he tried to do it uh

00:16:50,720 --> 00:16:54,240
later in the company we worked together

00:16:53,920 --> 00:16:56,800
and

00:16:54,240 --> 00:16:58,079
this approach unfortunately did not work

00:16:56,800 --> 00:17:01,120
i wish

00:16:58,079 --> 00:17:04,319
uh and the problem was that just

00:17:01,120 --> 00:17:08,319
finite automata itself would be so

00:17:04,319 --> 00:17:09,199
gigantic it's not only will not be a

00:17:08,319 --> 00:17:12,880
planar

00:17:09,199 --> 00:17:16,799
graph which you can put

00:17:12,880 --> 00:17:19,919
comfortably enough a draw on the plane

00:17:16,799 --> 00:17:23,360
is just would be impossible to

00:17:19,919 --> 00:17:26,480
uh to manage and understand uh

00:17:23,360 --> 00:17:28,000
because of its ginormous size and

00:17:26,480 --> 00:17:30,840
complexity

00:17:28,000 --> 00:17:33,360
so unfortunately that that just didn't

00:17:30,840 --> 00:17:36,240
work

00:17:33,360 --> 00:17:39,840
but again or depending on complexity of

00:17:36,240 --> 00:17:43,520
this application might or might not work

00:17:39,840 --> 00:17:47,520
and uh so how would you do that

00:17:43,520 --> 00:17:51,520
then so you want to still

00:17:47,520 --> 00:17:54,559
build uh test cases

00:17:51,520 --> 00:17:56,880
based on something which is important

00:17:54,559 --> 00:17:59,360
uh but do it a little bit more

00:17:56,880 --> 00:18:03,039
automatically

00:17:59,360 --> 00:18:06,160
ah and uh another

00:18:03,039 --> 00:18:09,039
idea and which is uh

00:18:06,160 --> 00:18:11,520
mentioned in here is to try to figure

00:18:09,039 --> 00:18:15,600
out a set of rules

00:18:11,520 --> 00:18:18,640
uh which would guide

00:18:15,600 --> 00:18:20,559
your test

00:18:18,640 --> 00:18:23,520
building or generation of your test

00:18:20,559 --> 00:18:27,039
cases through your application

00:18:23,520 --> 00:18:29,039
and this way you can build

00:18:27,039 --> 00:18:31,280
application especially if you pair it

00:18:29,039 --> 00:18:36,480
with crawler

00:18:31,280 --> 00:18:40,960
that might actually result in a good

00:18:36,480 --> 00:18:42,640
uh results so we actually have seen good

00:18:40,960 --> 00:18:46,320
results came out of it

00:18:42,640 --> 00:18:49,760
you'd be surprised but just one rule

00:18:46,320 --> 00:18:55,039
which nudged a system to go through

00:18:49,760 --> 00:18:58,160
uh first non trivial sign up steps

00:18:55,039 --> 00:19:02,160
were able to generate around

00:18:58,160 --> 00:19:04,960
400 functional end-to-end tests

00:19:02,160 --> 00:19:06,480
like vast majority of which were

00:19:04,960 --> 00:19:09,440
meaningful

00:19:06,480 --> 00:19:10,880
for some mobile applications so this

00:19:09,440 --> 00:19:13,280
approach does work for the

00:19:10,880 --> 00:19:14,000
mobile application and the number of

00:19:13,280 --> 00:19:17,440
rules

00:19:14,000 --> 00:19:21,200
you might need to create is

00:19:17,440 --> 00:19:23,520
is small compared to number of tests you

00:19:21,200 --> 00:19:25,919
will end up with

00:19:23,520 --> 00:19:28,320
so this is one vehicle it is basically

00:19:25,919 --> 00:19:31,919
kind of uh

00:19:28,320 --> 00:19:35,039
old same old nothing new rule-based

00:19:31,919 --> 00:19:39,120
uh crawler or

00:19:35,039 --> 00:19:41,919
in general uh something rule based right

00:19:39,120 --> 00:19:44,240
we also interrupt i need to uh we need

00:19:41,919 --> 00:19:47,520
to terminate in about one minute okay

00:19:44,240 --> 00:19:50,000
yeah and then finally uh

00:19:47,520 --> 00:19:51,200
uh the second way of doing that is based

00:19:50,000 --> 00:19:53,679
on analytics

00:19:51,200 --> 00:19:55,280
you governing a lot of analytics think

00:19:53,679 --> 00:19:58,720
about it

00:19:55,280 --> 00:20:03,280
like everyone i'm pretty sure have

00:19:58,720 --> 00:20:05,679
google analytics on their websites

00:20:03,280 --> 00:20:07,039
and you could use analytics data to

00:20:05,679 --> 00:20:09,760
figure out

00:20:07,039 --> 00:20:11,919
what are most frequently used end-to-end

00:20:09,760 --> 00:20:15,039
flows on your application

00:20:11,919 --> 00:20:16,720
and build entertainment test cases based

00:20:15,039 --> 00:20:20,960
on that

00:20:16,720 --> 00:20:25,440
so and on that i'm over time i apologize

00:20:20,960 --> 00:20:28,240
uh i this is how you could build

00:20:25,440 --> 00:20:29,840
your own autonomous test or generate

00:20:28,240 --> 00:20:33,440
test autonomously

00:20:29,840 --> 00:20:36,159
or uh sorry for

00:20:33,440 --> 00:20:37,679
shameless plugin here uh you could use

00:20:36,159 --> 00:20:41,600
test trigger which will

00:20:37,679 --> 00:20:44,960
it will do any obvious volume

00:20:41,600 --> 00:20:48,159
and on that uh

00:20:44,960 --> 00:20:51,200
uh like i would love to finish

00:20:48,159 --> 00:20:52,559
and thank you so much for bringing me

00:20:51,200 --> 00:20:56,799
about time

00:20:52,559 --> 00:20:56,799

YouTube URL: https://www.youtube.com/watch?v=CBkxgrFh0JI


