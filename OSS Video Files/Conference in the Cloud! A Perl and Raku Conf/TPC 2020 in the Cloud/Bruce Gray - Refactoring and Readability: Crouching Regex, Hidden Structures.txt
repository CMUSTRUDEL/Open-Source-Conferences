Title: Bruce Gray - Refactoring and Readability: Crouching Regex, Hidden Structures
Publication date: 2020-06-24
Playlist: TPC 2020 in the Cloud
Description: 
	https://speakerdeck.com/util

Under-embraced: Regexps, Deep data structures, Trees.
They all seem hard to learn, and hard to read, with minimal benefit.
They actually make code _more_ readable.
Usually :^)
This is their intro, via refactoring instead of examples, with clear on-ramps, and how to tell when they are worth learning.
Captions: 
	00:00:00,120 --> 00:00:04,729
questions there

00:00:02,159 --> 00:00:04,729
okay

00:00:06,230 --> 00:00:08,290
you

00:00:09,110 --> 00:00:11,170
you

00:00:11,640 --> 00:00:19,009
hi I am Bruce gray Yuto online I've been

00:00:17,040 --> 00:00:22,110
an open source about twenty five years I

00:00:19,009 --> 00:00:25,439
code mostly in Perl 5 and riku but I

00:00:22,110 --> 00:00:27,960
like all the dynamic languages this talk

00:00:25,439 --> 00:00:30,300
has examples in only Perl 5 in Riku

00:00:27,960 --> 00:00:32,040
because oz Khan didn't accept it but the

00:00:30,300 --> 00:00:37,489
content really does apply to all

00:00:32,040 --> 00:00:42,150
languages this is the incomplete talk

00:00:37,489 --> 00:00:44,000
based on incomplete research but it is

00:00:42,150 --> 00:00:48,839
intended to be two different things

00:00:44,000 --> 00:00:51,180
depending on how you squint at it on the

00:00:48,839 --> 00:00:52,879
one hand it's an introduction to

00:00:51,180 --> 00:00:54,720
programming techniques that

00:00:52,879 --> 00:00:59,190
counter-intuitively

00:00:54,720 --> 00:01:03,750
increase readability these three

00:00:59,190 --> 00:01:06,060
techniques just a taste of each one how

00:01:03,750 --> 00:01:08,670
to tell if they're worthwhile for you to

00:01:06,060 --> 00:01:10,470
learn and on-ramps if you decide to

00:01:08,670 --> 00:01:14,250
learn

00:01:10,470 --> 00:01:16,440
oh there's a small but cool fourth part

00:01:14,250 --> 00:01:18,590
after the Q&A it's only a minute and a

00:01:16,440 --> 00:01:18,590
half

00:01:18,780 --> 00:01:24,370
this talk is also supposed to be an

00:01:21,700 --> 00:01:26,440
experiment in using refactoring instead

00:01:24,370 --> 00:01:28,780
of examples to introduce you to three

00:01:26,440 --> 00:01:31,570
topics to try and adapt to their

00:01:28,780 --> 00:01:34,050
sinkhole nature that has made them under

00:01:31,570 --> 00:01:34,050
embraced

00:01:34,570 --> 00:01:41,420
last year I did a talk on refactoring

00:01:38,180 --> 00:01:44,090
and readability and how what we think of

00:01:41,420 --> 00:01:47,870
as maintainability can be addressed by

00:01:44,090 --> 00:01:52,220
focusing on just readability

00:01:47,870 --> 00:01:55,850
those bold ones are all readability

00:01:52,220 --> 00:01:59,240
since then I found these sinkholes where

00:01:55,850 --> 00:02:01,550
coders are not learning techniques that

00:01:59,240 --> 00:02:05,150
could replace convoluted code with

00:02:01,550 --> 00:02:07,520
readable concise code because at first

00:02:05,150 --> 00:02:09,740
and second glance it looks less readable

00:02:07,520 --> 00:02:14,000
to you because you haven't learned it

00:02:09,740 --> 00:02:16,970
yet it looks less readable and you don't

00:02:14,000 --> 00:02:19,590
see a critical need so you don't spend

00:02:16,970 --> 00:02:22,709
the time to learn

00:02:19,590 --> 00:02:25,730
it's the opposite of ooh you've got to

00:02:22,709 --> 00:02:25,730
try this cool new thing

00:02:26,209 --> 00:02:32,840
famously

00:02:28,400 --> 00:02:35,480
regular expressions or regex these get a

00:02:32,840 --> 00:02:38,000
bad rap partly because they are so

00:02:35,480 --> 00:02:40,730
associated with pearl but mostly because

00:02:38,000 --> 00:02:43,939
they used to look like line noise they

00:02:40,730 --> 00:02:46,340
are not pearl specific they are

00:02:43,939 --> 00:02:48,739
supported by so many tools and languages

00:02:46,340 --> 00:02:54,290
your editor probably has support for

00:02:48,739 --> 00:02:58,129
regex searching release range X is in

00:02:54,290 --> 00:03:00,400
your cheeseburger this is the famous

00:02:58,129 --> 00:03:00,400
quote

00:03:00,990 --> 00:03:12,690
how many years ago also they're

00:03:09,570 --> 00:03:15,450
immediately confusing because they look

00:03:12,690 --> 00:03:17,190
too similar to the dot star syntax that

00:03:15,450 --> 00:03:21,360
we use to specify files on the command

00:03:17,190 --> 00:03:24,450
line that dot dot star syntax is called

00:03:21,360 --> 00:03:27,180
globbing by the way key symbols have

00:03:24,450 --> 00:03:34,860
very different meanings in globs forces

00:03:27,180 --> 00:03:38,430
regex I will be using AK in these

00:03:34,860 --> 00:03:41,100
examples instead of grep I recommend you

00:03:38,430 --> 00:03:43,650
use any of these grep replacements they

00:03:41,100 --> 00:03:49,560
are faster smarter about repo structure

00:03:43,650 --> 00:03:54,230
and understand the full regex syntax so

00:03:49,560 --> 00:03:57,240
I had 700 screenshots

00:03:54,230 --> 00:03:59,010
from zoom business meetings they go to

00:03:57,240 --> 00:04:01,470
my desktop and on a Mac they

00:03:59,010 --> 00:04:04,520
automatically go to the desktop and I

00:04:01,470 --> 00:04:07,230
periodically sweep them into folders and

00:04:04,520 --> 00:04:10,400
I wanted to know if I swept anything

00:04:07,230 --> 00:04:10,400
else in with them

00:04:10,870 --> 00:04:15,480
I took one of those file names

00:04:16,150 --> 00:04:21,579
and started changing it into a regex

00:04:20,169 --> 00:04:24,460
the digits in the date and time will

00:04:21,579 --> 00:04:28,919
vary so I'll need to tell it to look for

00:04:24,460 --> 00:04:28,919
any digits there like any digits

00:04:29,820 --> 00:04:37,710
and the dots have special meaning in a

00:04:33,300 --> 00:04:39,240
regex they mean any character so I'll

00:04:37,710 --> 00:04:43,520
have to change them into literal dot

00:04:39,240 --> 00:04:43,520
somehow here we go

00:04:46,150 --> 00:04:52,790
notice that i backpacked the dot to

00:04:49,910 --> 00:04:56,080
change it from meaning any character to

00:04:52,790 --> 00:04:56,080
just mean a literal period

00:04:58,330 --> 00:05:05,090
and I will add a dollar sign at the end

00:05:02,080 --> 00:05:07,960
that is an anchor which means this must

00:05:05,090 --> 00:05:07,960
be the end of the string

00:05:11,390 --> 00:05:18,020
so that is my command the find will list

00:05:14,840 --> 00:05:21,080
the files the AK will filter that list

00:05:18,020 --> 00:05:22,939
based on my reg ex

00:05:21,080 --> 00:05:25,300
I should be will invert the filter to

00:05:22,939 --> 00:05:27,530
show me what doesn't match the regex and

00:05:25,300 --> 00:05:33,310
the quotes will keep the shell from

00:05:27,530 --> 00:05:33,310
messing where it oughtn't I rabbit

00:05:34,159 --> 00:05:46,509
Oh some screenshots were in 2019 but I

00:05:40,159 --> 00:05:46,509
had left 20/20 hard-coded so I'll fix it

00:05:46,770 --> 00:05:51,460
like that

00:05:48,830 --> 00:05:51,460
and run it again

00:05:55,589 --> 00:06:00,270
some were in the morning

00:06:00,370 --> 00:06:09,030
I had left the PM hard-coded so I need

00:06:03,910 --> 00:06:09,030
the P in PM to be a or P

00:06:09,460 --> 00:06:12,600
this time for sure

00:06:13,210 --> 00:06:20,949
oh yeah ours can have two digits but I'm

00:06:17,470 --> 00:06:24,250
only allowing for a one digit hour let

00:06:20,949 --> 00:06:27,810
me quantify wait another room let me

00:06:24,250 --> 00:06:32,190
resize okay quantify that our to be

00:06:27,810 --> 00:06:32,190
between one and two digits

00:06:33,360 --> 00:06:39,849
that everything I don't know but there's

00:06:36,990 --> 00:06:45,749
good enough yesterday

00:06:39,849 --> 00:06:45,749
those are all my Mis file files

00:06:45,889 --> 00:06:54,759
so I do not now have two problems I have

00:06:51,560 --> 00:06:54,759
a solved problem

00:06:59,400 --> 00:07:01,460
you

00:07:04,400 --> 00:07:06,460
you

00:07:07,969 --> 00:07:10,029
you

00:07:11,700 --> 00:07:13,760
you

00:07:16,670 --> 00:07:18,730
you

00:07:21,340 --> 00:07:26,500
you

00:07:23,230 --> 00:07:28,840
there are great resources online that

00:07:26,500 --> 00:07:32,410
work for most most languages reg X's

00:07:28,840 --> 00:07:36,370
like a site to explain a regex

00:07:32,410 --> 00:07:38,800
or show what artists match or even show

00:07:36,370 --> 00:07:43,440
you a step-by-step diagram a state

00:07:38,800 --> 00:07:43,440
diagram of what it will try to match

00:07:43,940 --> 00:07:51,500
now this was not really refactoring more

00:07:48,500 --> 00:07:53,660
exploratory programming this is an

00:07:51,500 --> 00:07:57,140
important tool not just for data munging

00:07:53,660 --> 00:08:00,800
but because what regex is a micro

00:07:57,140 --> 00:08:01,220
language you can use it to extract bits

00:08:00,800 --> 00:08:03,730
of data

00:08:01,220 --> 00:08:08,630
sure but you can also use it to describe

00:08:03,730 --> 00:08:10,880
what your data looks like and have your

00:08:08,630 --> 00:08:14,740
program warned you if your data does not

00:08:10,880 --> 00:08:14,740
match that description in the future

00:08:15,830 --> 00:08:24,330
navigation extraction exploration and

00:08:19,020 --> 00:08:26,820
validation quickly without regex

00:08:24,330 --> 00:08:28,110
to navigate and extract exactly that

00:08:26,820 --> 00:08:34,250
part of the URL

00:08:28,110 --> 00:08:34,250
I need this Perl 5 code

00:08:37,780 --> 00:08:42,719
with regex I need only this

00:08:47,640 --> 00:08:54,130
silent failures and wrong answers are

00:08:50,140 --> 00:08:57,370
not okay in our programs using regex for

00:08:54,130 --> 00:09:02,820
parsing helps you prevent that regex

00:08:57,370 --> 00:09:07,310
helps you understand your data

00:09:02,820 --> 00:09:11,510
for example parsing the find LS command

00:09:07,310 --> 00:09:11,510
this LS flag on find

00:09:12,010 --> 00:09:18,100
which some systems that's the only thing

00:09:14,350 --> 00:09:19,960
I can run and it's not good new find so

00:09:18,100 --> 00:09:22,780
you may be thinking this is a space

00:09:19,960 --> 00:09:26,380
separated format just split on white

00:09:22,780 --> 00:09:33,810
space there's no need for regex

00:09:26,380 --> 00:09:33,810
ok let's do that simple

00:09:33,960 --> 00:09:46,660
wait bylanes can contain spaces this one

00:09:41,560 --> 00:09:49,260
has two double spaces so we put a limit

00:09:46,660 --> 00:09:49,260
on the split

00:09:50,000 --> 00:09:54,980
first number the inode sometimes has

00:09:52,670 --> 00:09:58,790
spaces in front of it that throws off

00:09:54,980 --> 00:10:01,370
every field so we could split to an

00:09:58,790 --> 00:10:03,660
array throw away the first field if it's

00:10:01,370 --> 00:10:06,360
empty and then assign

00:10:03,660 --> 00:10:09,450
no we can't do that we only split nine

00:10:06,360 --> 00:10:11,250
fields so path will be empty so instead

00:10:09,450 --> 00:10:16,680
we have to Reese

00:10:11,250 --> 00:10:17,970
let good grief let's just trim the

00:10:16,680 --> 00:10:19,930
leading like space and go back to a

00:10:17,970 --> 00:10:23,200
plane split

00:10:19,930 --> 00:10:27,339
but we're not done parsing the

00:10:23,200 --> 00:10:32,910
next-to-last field mod time it contains

00:10:27,339 --> 00:10:32,910
hours and minutes only for newish files

00:10:33,170 --> 00:10:38,089
older files get the modification year

00:10:35,709 --> 00:10:41,000
which I'd never really noticed until

00:10:38,089 --> 00:10:46,390
doing this part

00:10:41,000 --> 00:10:46,390
so we need code to handle that

00:10:48,190 --> 00:10:54,810
so that's not awful but it's more than

00:10:51,460 --> 00:10:54,810
the simple split we thought would work

00:10:54,910 --> 00:11:03,550
and it actually uses regex twice and it

00:11:00,040 --> 00:11:08,520
breaks again when the source system

00:11:03,550 --> 00:11:08,520
allows spaces in the group name

00:11:10,470 --> 00:11:17,490
but put such horrors out of your mind

00:11:13,690 --> 00:11:17,490
what would the regex look like

00:11:19,120 --> 00:11:25,629
this is the first of two regex I use for

00:11:21,910 --> 00:11:30,660
the parsing it parses just the

00:11:25,629 --> 00:11:30,660
modification month day and year or time

00:11:31,970 --> 00:11:34,929
the complex

00:11:35,600 --> 00:11:44,940
for the year or time we describe the

00:11:39,520 --> 00:11:48,750
time is our : minutes

00:11:44,940 --> 00:11:53,910
the year as any four digits preceded by

00:11:48,750 --> 00:11:56,790
a space and we say that the data can be

00:11:53,910 --> 00:11:59,560
either of those two with a parenthesis

00:11:56,790 --> 00:12:02,590
and vertical bar

00:11:59,560 --> 00:12:06,240
and the regex engine just figures out

00:12:02,590 --> 00:12:06,240
what it needs to do there

00:12:06,740 --> 00:12:13,630
I build up the main regex with a

00:12:09,620 --> 00:12:13,630
reference to that prior regex

00:12:15,130 --> 00:12:21,880
and with named captures instead of

00:12:19,510 --> 00:12:25,330
referring to size as the one two three

00:12:21,880 --> 00:12:31,440
four five six seventh capture I can

00:12:25,330 --> 00:12:31,440
refer to it as size and use it like this

00:12:36,070 --> 00:12:43,920
now this is all quite readable

00:12:41,139 --> 00:12:43,920
it is

00:12:44,190 --> 00:12:48,709
but only once you've learned regex

00:12:49,600 --> 00:12:55,240
I made a rate conversion of this

00:12:53,260 --> 00:12:57,520
even better

00:12:55,240 --> 00:13:01,240
by the way these reject solutions

00:12:57,520 --> 00:13:05,260
whether R a coup or Perl 5 but they also

00:13:01,240 --> 00:13:09,010
break like the earlier code did the

00:13:05,260 --> 00:13:11,350
split code they break on the files from

00:13:09,010 --> 00:13:13,240
the evil system with the spaces in the

00:13:11,350 --> 00:13:18,330
group name

00:13:13,240 --> 00:13:21,000
but it's easy to make regex fail loudly

00:13:18,330 --> 00:13:22,650
the version that split on space if

00:13:21,000 --> 00:13:24,690
you're asking questions involving file

00:13:22,650 --> 00:13:26,800
size you are just going to get wrong

00:13:24,690 --> 00:13:29,230
answers

00:13:26,800 --> 00:13:33,700
it's failures are hard to detect and

00:13:29,230 --> 00:13:37,500
hard to debug with with regex pearl can

00:13:33,700 --> 00:13:37,500
pinpoint the failure for you

00:13:41,769 --> 00:13:47,929
by the way I had finished writing this

00:13:44,599 --> 00:13:50,239
presentation and was adding images like

00:13:47,929 --> 00:13:53,660
the famous book that covers regex in so

00:13:50,239 --> 00:13:58,629
many languages I had had it for years

00:13:53,660 --> 00:13:58,629
and never noticed this

00:14:01,370 --> 00:14:09,470
regex will be frustrating much like when

00:14:06,240 --> 00:14:09,470
you first learn to program

00:14:09,900 --> 00:14:14,550
I hope this refactoring by replacement

00:14:12,210 --> 00:14:17,760
will help you decide if regex are worth

00:14:14,550 --> 00:14:20,120
your time here are some good starting

00:14:17,760 --> 00:14:20,120
points

00:14:20,130 --> 00:14:22,190
you

00:14:25,940 --> 00:14:34,589
next section multi-dimensional data

00:14:31,470 --> 00:14:39,740
structures also called nested or

00:14:34,589 --> 00:14:39,740
multi-level or deep data structures

00:14:41,720 --> 00:14:46,200
now simple data structures you should

00:14:44,279 --> 00:14:48,960
already be familiar with arrays it

00:14:46,200 --> 00:14:53,070
hashes your language may have different

00:14:48,960 --> 00:14:57,750
names or specialized forms but really

00:14:53,070 --> 00:15:01,589
it's just these two array versus hash

00:14:57,750 --> 00:15:06,959
ordered versus unordered indexed by

00:15:01,589 --> 00:15:09,420
position vs. indexed by key when the

00:15:06,959 --> 00:15:13,110
values in those arrays are hashes the

00:15:09,420 --> 00:15:16,470
values are just numbers or strings then

00:15:13,110 --> 00:15:18,269
they're simple or single dimensional

00:15:16,470 --> 00:15:21,420
but the values could instead be whole

00:15:18,269 --> 00:15:25,350
other anonymous free-floating hashes or

00:15:21,420 --> 00:15:28,009
arrays in Perl we might talk about an

00:15:25,350 --> 00:15:28,009
eight-oh a

00:15:28,089 --> 00:15:31,319
array of arrays

00:15:32,149 --> 00:15:35,930
I showed this slide 10 years ago to the

00:15:34,430 --> 00:15:41,110
Atlantic Pro Mongoose it was in a

00:15:35,930 --> 00:15:41,110
different talk they read that last line

00:15:41,880 --> 00:15:45,020
I got some pushback

00:15:50,900 --> 00:15:56,820
so I came up with this for a four-level

00:15:54,900 --> 00:15:59,110
array of hashes of hashes of arrays

00:15:56,820 --> 00:16:04,290
example

00:15:59,110 --> 00:16:10,180
a hospital has multiple numbered floors

00:16:04,290 --> 00:16:13,640
each with multiple wards per floor with

00:16:10,180 --> 00:16:15,830
multiple nurses reward

00:16:13,640 --> 00:16:19,940
the list of patients in room number

00:16:15,830 --> 00:16:22,130
order so if my wife Sarah was working on

00:16:19,940 --> 00:16:23,810
the Med surg unit on the third floor and

00:16:22,130 --> 00:16:28,900
I wanted to know the fifth patient she

00:16:23,810 --> 00:16:28,900
would see I can directly jump to them

00:16:29,730 --> 00:16:35,830
now I don't want to start that deep so

00:16:33,310 --> 00:16:41,190
we'll play with the simplest of the data

00:16:35,830 --> 00:16:41,190
structure code smells parallel arrays

00:16:42,560 --> 00:16:49,350
if I have a file of tab-separated name

00:16:46,200 --> 00:16:53,190
address city and I'm writing code to

00:16:49,350 --> 00:16:54,990
load and munch those records then I have

00:16:53,190 --> 00:16:57,380
options for how to store that data in my

00:16:54,990 --> 00:16:57,380
program

00:16:57,890 --> 00:17:03,650
if we have read the data in two parallel

00:17:00,990 --> 00:17:03,650
arrays

00:17:08,730 --> 00:17:14,020
sorry about that

00:17:11,310 --> 00:17:17,260
if we read the data into parallel arrays

00:17:14,020 --> 00:17:19,720
so that all the names are in one array

00:17:17,260 --> 00:17:21,340
variable all the addresses are in a

00:17:19,720 --> 00:17:25,930
different array variable in the cities

00:17:21,340 --> 00:17:29,770
likewise then just accessing the data

00:17:25,930 --> 00:17:31,779
it's not too bad in readability but it

00:17:29,770 --> 00:17:34,440
is error-prone

00:17:31,779 --> 00:17:36,729
you add a field to your program and

00:17:34,440 --> 00:17:39,340
somewhere in all the places you

00:17:36,729 --> 00:17:42,239
reference it you'll forget to add that

00:17:39,340 --> 00:17:42,239
array to the code

00:17:43,350 --> 00:17:50,120
it would still be readable if we were

00:17:46,260 --> 00:17:50,120
deleting all the Herman's

00:17:51,800 --> 00:17:55,180
but a bit scarier

00:17:55,320 --> 00:17:59,870
the arrays are all out of sync during

00:17:57,540 --> 00:18:03,830
the deletion

00:17:59,870 --> 00:18:06,350
and back in sync at the end hopefully no

00:18:03,830 --> 00:18:09,320
one will add debugging code in between

00:18:06,350 --> 00:18:12,100
two of those splices and get confused by

00:18:09,320 --> 00:18:12,100
misaligned data

00:18:12,920 --> 00:18:17,470
certainly no one would call a function

00:18:14,990 --> 00:18:17,470
right

00:18:18,909 --> 00:18:24,309
I wouldn't actually ride it like that

00:18:20,759 --> 00:18:27,179
too easy to forget the reverse and skip

00:18:24,309 --> 00:18:27,179
over a hermit

00:18:28,179 --> 00:18:30,869
I might write this

00:18:31,870 --> 00:18:34,770
better to me

00:18:34,900 --> 00:18:42,220
functional style so her mileage may vary

00:18:37,980 --> 00:18:44,370
by the way that does work keep getting

00:18:42,220 --> 00:18:48,350
questions about it

00:18:44,370 --> 00:18:48,350
work since Pearl 5.12

00:18:51,160 --> 00:19:00,200
okay what if instead of the parallel

00:18:54,740 --> 00:19:03,050
arrays we used an array of hashes so

00:19:00,200 --> 00:19:05,360
instead of a name array we have a name

00:19:03,050 --> 00:19:10,460
key

00:19:05,360 --> 00:19:14,200
in each hash and so on then our Herman

00:19:10,460 --> 00:19:16,710
squashing code goes from this

00:19:14,200 --> 00:19:16,710
to this

00:19:21,040 --> 00:19:27,440
concise lists to read more readable and

00:19:25,250 --> 00:19:29,030
a lot less that the maintenance

00:19:27,440 --> 00:19:30,990
programmer can get wrong at 2:00 in the

00:19:29,030 --> 00:19:34,620
morning

00:19:30,990 --> 00:19:38,929
imagine if it was 30 fields this gets

00:19:34,620 --> 00:19:38,929
huge this stays the same size

00:19:40,809 --> 00:19:46,769
spoiled by Riku where I don't have to

00:19:43,659 --> 00:19:46,769
repeat the name of the array

00:19:47,690 --> 00:19:54,639
I have seen code that would join all the

00:19:51,799 --> 00:19:57,799
fields back together filter based on the

00:19:54,639 --> 00:20:02,470
entire joint line and then break the

00:19:57,799 --> 00:20:02,470
back part because of parallel erase

00:20:02,490 --> 00:20:07,960
if you do that it would remove people

00:20:05,159 --> 00:20:11,600
from the city of Hermon to

00:20:07,960 --> 00:20:13,549
it's a bad code smell

00:20:11,600 --> 00:20:17,299
and to keep being coded because of lack

00:20:13,549 --> 00:20:19,360
of comfort with arrays of hashes

00:20:17,299 --> 00:20:19,360
you

00:20:24,900 --> 00:20:26,960
you

00:20:27,450 --> 00:20:36,090
let's quickly go to levels deeper with a

00:20:31,290 --> 00:20:38,550
completely made-up example if you were

00:20:36,090 --> 00:20:41,400
chaotically rereading the Harry Potter

00:20:38,550 --> 00:20:44,490
books and the best of their fan of

00:20:41,400 --> 00:20:46,740
fiction you might jot down a happy

00:20:44,490 --> 00:20:50,780
little note every time a character had a

00:20:46,740 --> 00:20:50,780
crowning moment of Awesome

00:20:51,820 --> 00:20:58,840
if you were flitting from story to story

00:20:54,249 --> 00:21:03,119
like a hummingbird with a DD your notes

00:20:58,840 --> 00:21:03,119
might look like this

00:21:04,290 --> 00:21:06,350
you

00:21:09,279 --> 00:21:14,360
hairy's internal critic promptly awarded

00:21:12,110 --> 00:21:17,090
him the all-time award for the worst

00:21:14,360 --> 00:21:20,630
acting in the history of ever okay some

00:21:17,090 --> 00:21:22,710
of them are more funny than awesome

00:21:20,630 --> 00:21:25,460
anyway

00:21:22,710 --> 00:21:28,909
want to make a summary one line per

00:21:25,460 --> 00:21:32,640
crowning moment of Awesome but clustered

00:21:28,909 --> 00:21:35,870
by book and by character it would look

00:21:32,640 --> 00:21:35,870
like this

00:21:39,179 --> 00:21:45,299
so input format is multiple lines per

00:21:43,120 --> 00:21:45,299
moment

00:21:45,840 --> 00:21:52,940
and output format is one line for a

00:21:50,640 --> 00:21:52,940
moment

00:21:54,440 --> 00:22:01,740
please take 15 seconds to think about

00:21:57,540 --> 00:22:04,580
either how you would solve this or where

00:22:01,740 --> 00:22:04,580
you would even start

00:22:05,080 --> 00:22:07,140
you

00:22:10,200 --> 00:22:12,260
you

00:22:19,170 --> 00:22:27,429
two days ago I described by

00:22:22,530 --> 00:22:29,379
all this to my wife and she said first

00:22:27,429 --> 00:22:32,750
I've never heard of a crowning moment of

00:22:29,379 --> 00:22:37,630
Awesome that's great

00:22:32,750 --> 00:22:37,630
and second this sounds like a database

00:22:37,740 --> 00:22:43,020
and she's right it is vaguely shaped

00:22:40,590 --> 00:22:45,929
like a database

00:22:43,020 --> 00:22:48,310
if you've written sequel this might have

00:22:45,929 --> 00:22:52,000
come to mind

00:22:48,310 --> 00:22:54,820
I have seen parole code that writes the

00:22:52,000 --> 00:22:56,890
data to sequel light not for future use

00:22:54,820 --> 00:22:59,040
but just to run a group in calculation

00:22:56,890 --> 00:23:02,520
on it and get the result

00:22:59,040 --> 00:23:04,410
it's like writing out a flat file and

00:23:02,520 --> 00:23:05,970
calling the system sort because you

00:23:04,410 --> 00:23:08,400
don't know how to use pearls build

00:23:05,970 --> 00:23:10,300
insulin

00:23:08,400 --> 00:23:13,390
now there are several reasons

00:23:10,300 --> 00:23:16,730
the database is a bad fit this time that

00:23:13,390 --> 00:23:19,460
the main reason is you don't need to

00:23:16,730 --> 00:23:24,380
said the summary should be by book by

00:23:19,460 --> 00:23:27,410
character so that's a hash of hashes the

00:23:24,380 --> 00:23:31,400
rest of the data are lists that need to

00:23:27,410 --> 00:23:34,970
be kept in order that means hash of

00:23:31,400 --> 00:23:37,700
hashes of arrays of arrays so this is

00:23:34,970 --> 00:23:41,140
easily solved in any language that has

00:23:37,700 --> 00:23:41,140
dynamic hashes and arrays

00:23:41,590 --> 00:23:46,020
which i think is all the dynamic

00:23:43,600 --> 00:23:46,020
languages

00:23:47,960 --> 00:23:54,520
now this this is a shorthand to describe

00:23:51,889 --> 00:23:56,930
such a structure

00:23:54,520 --> 00:23:58,730
when you are crafting deep data

00:23:56,930 --> 00:24:00,820
structures ad hoc so that they only

00:23:58,730 --> 00:24:05,100
exist in a lifetime of your program

00:24:00,820 --> 00:24:06,600
please put such a line in a comment

00:24:05,100 --> 00:24:09,419
you will have to thanks for your

00:24:06,600 --> 00:24:11,630
maintenance program who is probably also

00:24:09,419 --> 00:24:11,630
you

00:24:13,720 --> 00:24:19,450
now I will show you working code but

00:24:17,529 --> 00:24:22,360
it'll be quick because this is an intro

00:24:19,450 --> 00:24:25,210
not a tutorial but first I want you to

00:24:22,360 --> 00:24:28,509
know I'm not trying to sell you on this

00:24:25,210 --> 00:24:29,980
exact solution if you write tons of

00:24:28,509 --> 00:24:32,139
sequel and very little pearl

00:24:29,980 --> 00:24:34,080
maybe you should lean on your most

00:24:32,139 --> 00:24:36,809
familiar tool

00:24:34,080 --> 00:24:39,570
maybe it's Excel

00:24:36,809 --> 00:24:42,320
I am suggesting that you become fluent

00:24:39,570 --> 00:24:45,649
in solving this kind of problem

00:24:42,320 --> 00:24:48,500
flew it like you see it and you know

00:24:45,649 --> 00:24:52,690
exactly how to solve it because that

00:24:48,500 --> 00:24:52,690
fluency will change your perceptions

00:24:54,179 --> 00:24:59,279
it's kind of it's the kind of change

00:24:56,159 --> 00:25:02,549
that lets you level up to shift away

00:24:59,279 --> 00:25:05,789
from being a report writer or priest of

00:25:02,549 --> 00:25:09,710
the machine and towards being a partner

00:25:05,789 --> 00:25:09,710
with your IT consumers

00:25:10,710 --> 00:25:15,280
the fundamental question is always what

00:25:12,870 --> 00:25:19,000
should we be doing

00:25:15,280 --> 00:25:22,710
don't always know what to ask next you

00:25:19,000 --> 00:25:22,710
can help shape those questions

00:25:23,270 --> 00:25:29,360
okay that covers the thinking half of

00:25:26,670 --> 00:25:29,360
data structures

00:25:30,590 --> 00:25:35,030
the other half the trouble is syntax

00:25:35,730 --> 00:25:39,880
and

00:25:37,030 --> 00:25:41,500
five signals change based on usage you

00:25:39,880 --> 00:25:43,180
have to wrap it in central braces when

00:25:41,500 --> 00:25:45,520
you mean the whole hash of the whole

00:25:43,180 --> 00:25:47,980
array instead of one element it's not

00:25:45,520 --> 00:25:53,370
easy to learn it's downright hard to

00:25:47,980 --> 00:25:53,370
remember the old syntax is a speed bump

00:25:54,020 --> 00:26:00,620
four years ago Perl 5 added improved

00:25:57,080 --> 00:26:03,520
syntax use it unless you have to support

00:26:00,620 --> 00:26:03,520
older pearls

00:26:04,280 --> 00:26:09,770
Raik who has a much more consistent

00:26:07,170 --> 00:26:09,770
syntax

00:26:10,640 --> 00:26:15,679
in any of the three or in any of other

00:26:13,340 --> 00:26:18,520
dynamic languages I find the results to

00:26:15,679 --> 00:26:24,160
be well worth the trouble

00:26:18,520 --> 00:26:26,520
I cut my other inspirational speech here

00:26:24,160 --> 00:26:26,520
for time

00:26:27,360 --> 00:26:30,890
here are the starting points

00:26:31,149 --> 00:26:33,210
you

00:26:34,410 --> 00:26:36,470
you

00:26:37,600 --> 00:26:48,970
that brings us to trees wait a minute is

00:26:46,000 --> 00:26:51,720
this a separate section when a tree is a

00:26:48,970 --> 00:26:54,180
deep data structure

00:26:51,720 --> 00:26:58,740
well all the data structures we saw

00:26:54,180 --> 00:27:02,060
earlier were dynamic in content but had

00:26:58,740 --> 00:27:02,060
fixed shape

00:27:02,370 --> 00:27:07,170
a hash of hashes of arrays of arrays and

00:27:05,100 --> 00:27:09,480
that second level is always a hash no

00:27:07,170 --> 00:27:11,370
matter what data was fed yet they won't

00:27:09,480 --> 00:27:14,130
be an array there because we didn't code

00:27:11,370 --> 00:27:17,160
to create one you could it's more

00:27:14,130 --> 00:27:23,640
complex but the shape is determined by

00:27:17,160 --> 00:27:28,580
your code we coded for fixed shape with

00:27:23,640 --> 00:27:28,580
trees the data will change the shape

00:27:30,480 --> 00:27:37,419
I'm putting on my computer science II

00:27:33,070 --> 00:27:39,549
hat for this one slide need typical

00:27:37,419 --> 00:27:41,679
characteristics of trees instead of

00:27:39,549 --> 00:27:44,559
hashes in arrays everything is a node

00:27:41,679 --> 00:27:47,590
which is an object pointing to and

00:27:44,559 --> 00:27:49,240
containing other objects those

00:27:47,590 --> 00:27:52,360
containments and pointers all have

00:27:49,240 --> 00:27:55,419
Direction not just we are related that

00:27:52,360 --> 00:27:59,610
would be undirected I am his father he

00:27:55,419 --> 00:28:02,830
is my son that's Direction hierarchy a

00:27:59,610 --> 00:28:05,500
parent can have zero one or many

00:28:02,830 --> 00:28:07,740
children here in the tree you can only

00:28:05,500 --> 00:28:11,580
have one parent

00:28:07,740 --> 00:28:14,250
order I was born first my brother was

00:28:11,580 --> 00:28:17,620
born second there is a ordering even two

00:28:14,250 --> 00:28:20,720
nodes at the same level of hierarchy

00:28:17,620 --> 00:28:23,200
navigation each object has methods you

00:28:20,720 --> 00:28:26,779
can call to get its parent its siblings

00:28:23,200 --> 00:28:28,890
children and its own properties which we

00:28:26,779 --> 00:28:32,870
call attributes

00:28:28,890 --> 00:28:35,539
that's horrible it's demotivational too

00:28:32,870 --> 00:28:38,230
abstract

00:28:35,539 --> 00:28:42,299
trees are really simple

00:28:38,230 --> 00:28:46,200
you might do unsympathetic

00:28:42,299 --> 00:28:49,799
here's a familiar point of reference

00:28:46,200 --> 00:28:49,799
simple HTML

00:28:54,740 --> 00:28:57,789
can we agree

00:28:58,460 --> 00:29:03,550
that this is the same as this

00:29:06,590 --> 00:29:11,510
all we've done is change the white space

00:29:08,480 --> 00:29:14,200
to get to better show what is inside a

00:29:11,510 --> 00:29:14,200
pair of tags

00:29:14,510 --> 00:29:20,240
can we agree that this is the same as

00:29:17,550 --> 00:29:20,240
this

00:29:22,150 --> 00:29:27,040
you can't feed it into a browser anymore

00:29:24,280 --> 00:29:29,620
but you can recreate the first or second

00:29:27,040 --> 00:29:31,980
one from the third so they contain the

00:29:29,620 --> 00:29:31,980
same information

00:29:32,679 --> 00:29:36,659
it's just like Python style

00:29:38,020 --> 00:29:42,610
this also contains the same information

00:29:42,970 --> 00:29:49,919
a ski drawing of the tree tree that the

00:29:46,270 --> 00:29:49,919
HTML was in the first place

00:29:52,190 --> 00:29:57,540
pretty

00:29:53,920 --> 00:30:03,170
it would still be the same information

00:29:57,540 --> 00:30:03,170
this mental transform is a second hurdle

00:30:03,350 --> 00:30:10,539
first hurdle is the computer science

00:30:06,919 --> 00:30:10,539
nature of a lot of the literature

00:30:12,100 --> 00:30:19,570
scariness the alienness of thinking that

00:30:16,960 --> 00:30:21,700
these are the same thing that goes away

00:30:19,570 --> 00:30:22,869
with practice let's handle some real

00:30:21,700 --> 00:30:27,519
HTML

00:30:22,869 --> 00:30:34,559
I am currently quarantined in a quiet

00:30:27,519 --> 00:30:34,559
neighborhood in Alabama in the summer

00:30:38,310 --> 00:30:44,450
when it gets windy I want to know so I

00:30:41,790 --> 00:30:44,450
can go play outside

00:30:46,130 --> 00:30:53,840
from The Weather Underground I just need

00:30:51,020 --> 00:30:56,560
this

00:30:53,840 --> 00:30:56,560
let's spit

00:30:56,740 --> 00:31:00,480
so first thing I will

00:31:01,080 --> 00:31:08,610
what do we do first thing grab a copy so

00:31:06,900 --> 00:31:11,690
we don't hammer their server while we're

00:31:08,610 --> 00:31:11,690
figuring out the parsing

00:31:12,510 --> 00:31:21,650
okay the HTML for just this part of the

00:31:16,410 --> 00:31:21,650
page after I tidied it is this

00:31:22,700 --> 00:31:26,019
which is not perfect

00:31:26,450 --> 00:31:33,470
but hopefully that won't matter I just

00:31:31,100 --> 00:31:36,220
need all the text elements in this div

00:31:33,470 --> 00:31:39,450
block the div block that has class

00:31:36,220 --> 00:31:41,789
condition wind

00:31:39,450 --> 00:31:45,990
I think that everyone who first faces

00:31:41,789 --> 00:31:49,980
HTML or XML if they know regex they try

00:31:45,990 --> 00:31:52,220
regex even though we say everywhere to

00:31:49,980 --> 00:31:57,049
not do that

00:31:52,220 --> 00:31:59,990
so let's do that and without deep

00:31:57,049 --> 00:32:02,240
wizardry we cannot just say go to the

00:31:59,990 --> 00:32:05,690
clothes dip that matches the condition

00:32:02,240 --> 00:32:09,140
win div because your regex one given tag

00:32:05,690 --> 00:32:11,650
is just like any other div in tag so we

00:32:09,140 --> 00:32:11,650
have to cheat

00:32:13,220 --> 00:32:19,390
we count the number of closing div tags

00:32:16,190 --> 00:32:19,390
to find the endpoint

00:32:20,050 --> 00:32:25,330
our solution is instantly very fragile

00:32:22,750 --> 00:32:28,230
it'll break if they even clean up those

00:32:25,330 --> 00:32:28,230
empty div tags

00:32:34,130 --> 00:32:39,090
we throw away everything that is not

00:32:36,570 --> 00:32:43,220
between the target div tag and the sixth

00:32:39,090 --> 00:32:43,220
closed div tag after it

00:32:43,850 --> 00:32:47,309
you

00:32:45,850 --> 00:32:51,179
it's a pause for every

00:32:47,309 --> 00:32:55,490
shudder that regex has some challenging

00:32:51,179 --> 00:32:55,490
subtleties in it it's not beginner level

00:32:56,020 --> 00:33:04,190
change every tag to a space cleanup

00:32:59,870 --> 00:33:07,610
non-breaking spaces squash series of

00:33:04,190 --> 00:33:12,560
spaces into single spaces trim leading

00:33:07,610 --> 00:33:14,920
and trailing whitespace and output the

00:33:12,560 --> 00:33:14,920
result

00:33:15,010 --> 00:33:23,100
it works but it's fragile and hard to

00:33:19,300 --> 00:33:23,100
write it took me 20 minutes

00:33:23,629 --> 00:33:31,360
the rekha version is nicer

00:33:27,640 --> 00:33:33,760
it's just as fragile because regex is

00:33:31,360 --> 00:33:37,800
the wrong tool

00:33:33,760 --> 00:33:37,800
you should at least use a parser

00:33:38,600 --> 00:33:45,789
good parsers I like this one it presents

00:33:41,029 --> 00:33:45,789
the HTML as a stream of tokens

00:33:46,650 --> 00:33:53,880
this weirdly formatted but totally valid

00:33:50,070 --> 00:33:56,210
HTML tok parser will iterate over its

00:33:53,880 --> 00:34:01,130
tokens

00:33:56,210 --> 00:34:05,240
that is all one token even spread out

00:34:01,130 --> 00:34:09,520
among lines it's a start tag

00:34:05,240 --> 00:34:12,669
all that text is a single text toke

00:34:09,520 --> 00:34:15,700
token is in tag so three tokens the

00:34:12,669 --> 00:34:17,880
parcel will normalize them for us as we

00:34:15,700 --> 00:34:17,880
go

00:34:19,370 --> 00:34:26,270
this is all set up and tracking code the

00:34:23,010 --> 00:34:26,270
important stuffs on the next slide

00:34:28,760 --> 00:34:33,950
but I won't go into this next slide

00:34:31,049 --> 00:34:36,059
because right after I perfected it I

00:34:33,950 --> 00:34:40,879
realized it would be shorter and faster

00:34:36,059 --> 00:34:40,879
to do it with two loops

00:34:40,899 --> 00:34:42,960
you

00:34:42,990 --> 00:34:50,599
in the first loop we loop through the

00:34:46,470 --> 00:34:54,720
tokens and when we see a start of a give

00:34:50,599 --> 00:34:57,580
that has a class that condition wind we

00:34:54,720 --> 00:34:59,890
need the loop

00:34:57,580 --> 00:35:02,260
so the second loop will start at that

00:34:59,890 --> 00:35:08,440
point like all the tokens before that

00:35:02,260 --> 00:35:13,540
had never existed then on each start tag

00:35:08,440 --> 00:35:18,190
we count up a level on each in tag we

00:35:13,540 --> 00:35:22,020
count down a level and leave the loop if

00:35:18,190 --> 00:35:24,080
we drop below the level we started

00:35:22,020 --> 00:35:24,080
you

00:35:24,420 --> 00:35:29,390
in the meantime scoop up all the text

00:35:26,910 --> 00:35:29,390
tokens

00:35:33,270 --> 00:35:38,610
motely as fragile as a regex version and

00:35:35,610 --> 00:35:40,590
it's even faster but I think your

00:35:38,610 --> 00:35:45,410
maintenance programmer will need this to

00:35:40,590 --> 00:35:48,240
be documented heavily documented and

00:35:45,410 --> 00:35:51,710
have the docks to the tow parcel module

00:35:48,240 --> 00:35:51,710
in hand to work on this

00:35:54,460 --> 00:36:01,440
what if instead of treating this is a

00:35:57,350 --> 00:36:05,790
string of tokens we treat it as a tree

00:36:01,440 --> 00:36:09,599
we can use the HTML tree builder module

00:36:05,790 --> 00:36:12,200
and yes there is an XML tree builder

00:36:09,599 --> 00:36:12,200
module too

00:36:13,350 --> 00:36:21,930
we create a new tree from the HTML in

00:36:17,920 --> 00:36:21,930
the file view from file

00:36:22,260 --> 00:36:27,589
he builds the whole tree in memory in

00:36:24,930 --> 00:36:27,589
that one statement

00:36:27,660 --> 00:36:34,430
to get the wind sub-tree

00:36:31,850 --> 00:36:37,010
we ask the tree to look through all its

00:36:34,430 --> 00:36:40,840
descendants and give us the first node

00:36:37,010 --> 00:36:43,700
that it comes to that is a div tag and

00:36:40,840 --> 00:36:45,940
has a class that starts with condition

00:36:43,700 --> 00:36:45,940
wind

00:36:46,390 --> 00:36:54,250
from that and that wind subtree we can

00:36:51,279 --> 00:36:56,980
ask it for the text of all its

00:36:54,250 --> 00:36:58,940
descendants all run together the space

00:36:56,980 --> 00:37:03,970
between

00:36:58,940 --> 00:37:03,970
while also fixing the non-breaking space

00:37:04,190 --> 00:37:13,640
and that's all

00:37:08,790 --> 00:37:13,640
we only needed two requests of the tree

00:37:16,619 --> 00:37:22,930
trees are only scary in the same way

00:37:19,330 --> 00:37:24,330
sorting is scary in college when you

00:37:22,930 --> 00:37:27,280
have to write your own implementation

00:37:24,330 --> 00:37:31,660
it's hard to get it right and it's hell

00:37:27,280 --> 00:37:34,510
to debug but in the real world you call

00:37:31,660 --> 00:37:40,010
someone else's implementation and just

00:37:34,510 --> 00:37:44,180
feed it your code the specific behavior

00:37:40,010 --> 00:37:48,500
the downside is speed the regex was 11

00:37:44,180 --> 00:37:51,220
times as fast the tope parser is 55

00:37:48,500 --> 00:37:53,320
times faster than this

00:37:51,220 --> 00:37:55,670
but this runs in a quarter of a second

00:37:53,320 --> 00:37:58,100
so I don't care

00:37:55,670 --> 00:38:01,270
this one took much less time to write

00:37:58,100 --> 00:38:03,740
and it's easy to read and maintain

00:38:01,270 --> 00:38:06,310
optimized for programmer time not

00:38:03,740 --> 00:38:06,310
machine time

00:38:12,210 --> 00:38:21,299
just like patterns and navigation

00:38:16,910 --> 00:38:23,970
navigating a string can get huge like

00:38:21,299 --> 00:38:26,160
the slide I showed you earlier in reg

00:38:23,970 --> 00:38:29,730
exa here's what you have to do to get

00:38:26,160 --> 00:38:32,819
this part of the URL got huge reg X is a

00:38:29,730 --> 00:38:34,440
micro language that does that it's

00:38:32,819 --> 00:38:37,630
optimized for that it's built for them

00:38:34,440 --> 00:38:39,770
designed for it that's the word

00:38:37,630 --> 00:38:41,750
so I want you to know that if you're

00:38:39,770 --> 00:38:43,670
writing a lot of intricate tree

00:38:41,750 --> 00:38:46,840
navigating code the stuff we were just

00:38:43,670 --> 00:38:50,660
doing there's a micro language for that

00:38:46,840 --> 00:38:54,620
called XPath it's not a perl thing it's

00:38:50,660 --> 00:38:57,110
widely supported and similarly for

00:38:54,620 --> 00:39:00,290
navigating complex JSON if your code

00:38:57,110 --> 00:39:03,260
gets too unwieldy you can abbreviate it

00:39:00,290 --> 00:39:08,180
using the micro language either the

00:39:03,260 --> 00:39:12,830
external utility JQ JSON query it's a

00:39:08,180 --> 00:39:15,320
great tool or the module JSON path JSON

00:39:12,830 --> 00:39:18,550
paths also as a standard it's newer but

00:39:15,320 --> 00:39:18,550
lots of languages supported

00:39:20,270 --> 00:39:24,980
you don't really have to scrape the

00:39:22,040 --> 00:39:32,510
Weather Underground weather gov has a

00:39:24,980 --> 00:39:35,230
real API now before the awesome ending

00:39:32,510 --> 00:39:35,230
questions do you have

00:39:35,900 --> 00:39:37,960
you

00:39:42,529 --> 00:39:52,229
we have seven minutes for Q&A and I'm

00:39:47,519 --> 00:39:54,900
not sure okay see ya Ben has a question

00:39:52,229 --> 00:39:56,309
yeah just do a real brief and as you

00:39:54,900 --> 00:39:59,029
went over the regex is just looking at

00:39:56,309 --> 00:40:02,999
some of the modifiers there are yummy

00:39:59,029 --> 00:40:07,279
recommendations insights general musings

00:40:02,999 --> 00:40:10,859
on the use of thing particular modifiers

00:40:07,279 --> 00:40:12,779
yes I just

00:40:10,859 --> 00:40:16,229
ever since the book came out I've been

00:40:12,779 --> 00:40:20,420
following the pro best practices best

00:40:16,229 --> 00:40:24,719
practices from Damian's book and

00:40:20,420 --> 00:40:28,680
basically put MSX on everything in fact

00:40:24,719 --> 00:40:31,559
there's even I think a module or a

00:40:28,680 --> 00:40:32,339
pragma to automatically turn that on for

00:40:31,559 --> 00:40:35,880
every regex

00:40:32,339 --> 00:40:38,930
in lexically in your code because it

00:40:35,880 --> 00:40:42,450
takes the stuff that's confusing or

00:40:38,930 --> 00:40:44,160
inconsistent and about what whether doc

00:40:42,450 --> 00:40:46,619
means any character or any character

00:40:44,160 --> 00:40:49,890
button you lied and what the beginning

00:40:46,619 --> 00:40:52,999
and into lines mean and straitens now I

00:40:49,890 --> 00:40:56,789
may have missed using backslash a and

00:40:52,999 --> 00:41:00,479
backslash Z instead of carrot and dollar

00:40:56,789 --> 00:41:02,819
sign in that example but that that's my

00:41:00,479 --> 00:41:07,039
always my go-to unless it's just like

00:41:02,819 --> 00:41:12,319
you know five character regex it's MSX

00:41:07,039 --> 00:41:12,319
thank you what else

00:41:14,250 --> 00:41:16,310
you

00:41:24,460 --> 00:41:31,510
from Damien on presentation one time one

00:41:26,950 --> 00:41:34,089
thing he stressed is don't ask what

00:41:31,510 --> 00:41:36,940
questions do you have and then pause ten

00:41:34,089 --> 00:41:39,040
seconds and say okay bye people need

00:41:36,940 --> 00:41:42,190
time to get their heads around whatever

00:41:39,040 --> 00:41:46,260
you've just crammed in there so I don't

00:41:42,190 --> 00:41:46,260
mind waiting for you to form questions

00:41:55,320 --> 00:42:06,540
uh wait of my life okay so maybe this is

00:42:03,390 --> 00:42:11,010
a bit of a silly question but thinking

00:42:06,540 --> 00:42:14,160
about trees like if you say you had to

00:42:11,010 --> 00:42:17,040
implement a tree just using like basic

00:42:14,160 --> 00:42:18,900
Perl data structures what do you think

00:42:17,040 --> 00:42:22,440
would be the best way to do that

00:42:18,900 --> 00:42:24,390
I assume probably like some like level

00:42:22,440 --> 00:42:27,720
of nested hash references or something

00:42:24,390 --> 00:42:29,460
but or would that just be a sign that

00:42:27,720 --> 00:42:31,980
you need to pick a different language if

00:42:29,460 --> 00:42:32,850
you find yourself doing that no no not

00:42:31,980 --> 00:42:37,950
at all

00:42:32,850 --> 00:42:44,610
I find that my go-to module is called

00:42:37,950 --> 00:42:46,470
tree : d AG underscore node a dag is a

00:42:44,610 --> 00:42:49,890
there's a thing it's directed at a

00:42:46,470 --> 00:42:52,020
cyclical graph the computer scientist

00:42:49,890 --> 00:42:53,910
but it's it's just a general-purpose

00:42:52,020 --> 00:42:57,000
most of the stuff you want to do with

00:42:53,910 --> 00:42:59,310
the tree it has built in every node is a

00:42:57,000 --> 00:43:03,780
object so you're not having to to worry

00:42:59,310 --> 00:43:05,520
about the shape in your code you can let

00:43:03,780 --> 00:43:08,360
your data dictate the shape and it

00:43:05,520 --> 00:43:10,770
provides all the all the navigation

00:43:08,360 --> 00:43:13,680
stuff that you need and I believe that

00:43:10,770 --> 00:43:17,850
there's an extension to it for tree

00:43:13,680 --> 00:43:20,010
Cowen's d'agneau Cohen's XPath if you

00:43:17,850 --> 00:43:25,110
want you know rapid navigation through

00:43:20,010 --> 00:43:28,380
it but it's every language has a general

00:43:25,110 --> 00:43:31,980
purpose tree strut tree module that I

00:43:28,380 --> 00:43:34,260
know up and I would always go with that

00:43:31,980 --> 00:43:36,800
if I knew that the data was going to be

00:43:34,260 --> 00:43:36,800
in a tree

00:43:37,140 --> 00:43:46,529
having said that if you really really

00:43:39,599 --> 00:43:50,399
really want to do this without objects

00:43:46,529 --> 00:43:52,529
and using primitive using ash -

00:43:50,399 --> 00:43:55,799
summarize very is that kind of thing

00:43:52,529 --> 00:44:00,479
there's data Walker and a couple of

00:43:55,799 --> 00:44:05,369
other maybe D paths or modules that lets

00:44:00,479 --> 00:44:08,239
you specify without a fixed form how to

00:44:05,369 --> 00:44:10,739
navigate your data so you know like

00:44:08,239 --> 00:44:13,829
instead of having three places that you

00:44:10,739 --> 00:44:18,179
have to put a key a key in a a key it'll

00:44:13,829 --> 00:44:21,269
say from the current place you are make

00:44:18,179 --> 00:44:22,919
this action and so you're if you're

00:44:21,269 --> 00:44:26,059
trying to do it the hard way it will

00:44:22,919 --> 00:44:26,059
make it a little easier

00:44:27,279 --> 00:44:32,999
probably all I have time to go into on

00:44:29,289 --> 00:44:35,199
this did that help yeah I did thank you

00:44:32,999 --> 00:44:40,689
welcome could I know who's speaking

00:44:35,199 --> 00:44:44,349
please I'm Cameron Doakes thank you I I

00:44:40,689 --> 00:44:46,959
don't quite know how to navigate what

00:44:44,349 --> 00:44:51,249
I'm looking at it looks like we've got

00:44:46,959 --> 00:44:53,429
another question from Ben Kaufman go

00:44:51,249 --> 00:44:53,429
ahead

00:44:54,240 --> 00:45:11,460
looks like you may be its hand - enough

00:45:06,330 --> 00:45:14,760
and I said - a stun you was there you go

00:45:11,460 --> 00:45:17,100
I'm sorry muted no I think you addressed

00:45:14,760 --> 00:45:19,740
Island with the question camera and

00:45:17,100 --> 00:45:22,740
asked just looking at you know you're

00:45:19,740 --> 00:45:25,650
using HTML tree builder and look down

00:45:22,740 --> 00:45:27,450
method which was not it's not documented

00:45:25,650 --> 00:45:29,730
directly in that in other words you'd

00:45:27,450 --> 00:45:32,880
follow the reference to HTML tree and

00:45:29,730 --> 00:45:35,880
then from there to HTML tree or what's

00:45:32,880 --> 00:45:39,320
the it was a little bit of a find to get

00:45:35,880 --> 00:45:42,300
to that particular method yeah and

00:45:39,320 --> 00:45:47,160
that's unfortunate there there is a sort

00:45:42,300 --> 00:45:49,710
of overarching HTML - tree document that

00:45:47,160 --> 00:45:51,630
describes HTML element and tree builder

00:45:49,710 --> 00:45:53,430
and all that it ought to be in tree

00:45:51,630 --> 00:45:56,280
builder because that's where you're

00:45:53,430 --> 00:45:57,990
looking for it please go ahead no it was

00:45:56,280 --> 00:45:59,400
just you you touched on some other

00:45:57,990 --> 00:46:01,110
modules there which was I think just

00:45:59,400 --> 00:46:03,410
really kind of where I was going so I

00:46:01,110 --> 00:46:09,750
don't have anything more on that then

00:46:03,410 --> 00:46:11,840
score yeah they already answered and my

00:46:09,750 --> 00:46:15,210
wife says it's time for the bonus part

00:46:11,840 --> 00:46:19,160
so I'd love to see your questions on

00:46:15,210 --> 00:46:19,160
email or in chat

00:46:22,060 --> 00:46:24,660
whoa

00:46:28,330 --> 00:46:30,390
you

00:46:32,470 --> 00:46:42,070
there it is hmm here's the bonus once

00:46:40,330 --> 00:46:44,320
you have a firm grasp on these three

00:46:42,070 --> 00:46:48,090
tools you are standing at the doorstep

00:46:44,320 --> 00:46:51,220
of a new world called static analysis

00:46:48,090 --> 00:46:53,500
the modern code analyzers linters

00:46:51,220 --> 00:46:56,830
critiques on code quality like pro

00:46:53,500 --> 00:47:00,610
critic and security scanners these all

00:46:56,830 --> 00:47:02,920
work by static analysis the three

00:47:00,610 --> 00:47:04,810
techniques we just covered plus the

00:47:02,920 --> 00:47:06,130
documentation for your languages parser

00:47:04,810 --> 00:47:10,210
toolkit PPI

00:47:06,130 --> 00:47:12,070
for plural bets that's what it takes to

00:47:10,210 --> 00:47:15,790
be able to contribute to these projects

00:47:12,070 --> 00:47:18,340
or to write rule sets your own rule sets

00:47:15,790 --> 00:47:21,640
so these work better for your team's

00:47:18,340 --> 00:47:26,920
codebase we need more of these kinds of

00:47:21,640 --> 00:47:28,660
tools and finally if you get that far I

00:47:26,920 --> 00:47:31,210
hope you'll take the next step in your

00:47:28,660 --> 00:47:35,260
language as I'm trying to do in Perl and

00:47:31,210 --> 00:47:39,160
write programs to automatically refactor

00:47:35,260 --> 00:47:41,530
and rewrite code something that takes

00:47:39,160 --> 00:47:43,990
your Perl 5 programming produces code

00:47:41,530 --> 00:47:45,730
that's mostly converted to Riku with the

00:47:43,990 --> 00:47:49,750
report of what a human needs to decide

00:47:45,730 --> 00:47:53,920
on or that gives you even better Perl 5

00:47:49,750 --> 00:47:57,060
a moderniser and I tell you whatever

00:47:53,920 --> 00:48:01,510
tool converts your Perl 5 code to purl 8

00:47:57,060 --> 00:48:03,220
Sawyer mentioned that after Perl 7 I bet

00:48:01,510 --> 00:48:05,430
that tool will be driven by static

00:48:03,220 --> 00:48:05,430

YouTube URL: https://www.youtube.com/watch?v=wZZtrtoTjt4


