Title: Damian Conway - Keynote: A Simple Matter Of Programming
Publication date: 2020-06-26
Playlist: TPC 2020 in the Cloud
Description: 
	There are already great IDEs for both Perl (Padre) and Raku (Comma).
They're both designed to help you write software faster
...by providing a range of syntax-based coding tools.
More importantly, they can both help you rewrite software better
...by supplying a set of language-aware refactoring mechanisms.

There's only one problem: neither of them is Vim
(or Emacs or «your editor-of-addiction here»).

In this talk I'll introduce a new set of modules, designed to
make it easy to add syntax-driven Perl source refactoring
and other useful code transformations to any modern text editor,
or any other scriptable application.

Along the way, we'll explore the horrors of Perl's scoping rules,
navigate the labyrinth of Perl's many argument passing conventions,
and descend briefly into the whirling maelstrom that is
generalized semiautonomous contextual API inference.

We'll also look ahead to examine how I'm planning to implement
the same set of code manipulation tools for Raku, and see why
that's going to be at least two or three times as challenging
...but also an order of magnitude easier.
Captions: 
	00:00:00,030 --> 00:00:05,930
okay so one of the few disadvantages of

00:00:04,049 --> 00:00:11,219
being an international supervillain is

00:00:05,930 --> 00:00:13,889
that I I kind of Li live in a black hole

00:00:11,219 --> 00:00:16,080
of communication I have literally no

00:00:13,889 --> 00:00:19,439
cell coverage where I live and at the

00:00:16,080 --> 00:00:25,830
end of a four kilometer long DSL line so

00:00:19,439 --> 00:00:28,590
my my upload speed is about 800 kilobits

00:00:25,830 --> 00:00:30,240
per second which is not really enough I

00:00:28,590 --> 00:00:32,669
don't know what you're seeing and why

00:00:30,240 --> 00:00:35,670
you're the video but if I do this it's

00:00:32,669 --> 00:00:38,190
probably not going to look real good so

00:00:35,670 --> 00:00:39,989
what we decided was that I would pre

00:00:38,190 --> 00:00:42,390
record the actual talk that I want to

00:00:39,989 --> 00:00:44,430
give so that you would actually be able

00:00:42,390 --> 00:00:48,809
to see it and where we're broadcasting

00:00:44,430 --> 00:00:52,079
it from Todd's Batcave which has much

00:00:48,809 --> 00:00:54,210
better connectivity than mine so without

00:00:52,079 --> 00:00:58,020
further ado we won't waste any more time

00:00:54,210 --> 00:01:00,649
I'll get Todd to run the video and then

00:00:58,020 --> 00:01:03,570
I will be back live after the

00:01:00,649 --> 00:01:09,090
presentation to take any questions that

00:01:03,570 --> 00:01:10,860
you might have g'day today I'd like to

00:01:09,090 --> 00:01:13,830
talk to you about a simple matter of

00:01:10,860 --> 00:01:22,290
programming but of course that comes

00:01:13,830 --> 00:01:24,590
with the usual caveat and the project

00:01:22,290 --> 00:01:27,479
that I'm going to discuss today

00:01:24,590 --> 00:01:30,150
originates from the consideration of the

00:01:27,479 --> 00:01:36,530
three perl virtues which is most of you

00:01:30,150 --> 00:01:41,700
will know laziness impatience and hubris

00:01:36,530 --> 00:01:44,009
so laziness is the idea that things are

00:01:41,700 --> 00:01:47,399
very often more difficult than we really

00:01:44,009 --> 00:01:50,280
want them to be why couldn't this thing

00:01:47,399 --> 00:01:52,710
that I want to do be easier and that

00:01:50,280 --> 00:01:54,780
naturally leads to a kind of impatience

00:01:52,710 --> 00:01:57,210
because if I want it to be easier I

00:01:54,780 --> 00:02:00,060
really want it to be easier right now

00:01:57,210 --> 00:02:03,630
and unless there happens to be something

00:02:00,060 --> 00:02:06,750
on Sipan that makes that easier then in

00:02:03,630 --> 00:02:09,929
the Perl universe that further leads to

00:02:06,750 --> 00:02:12,209
cuprous and hubris is the idea of well

00:02:09,929 --> 00:02:13,630
no one else has done this but how hard

00:02:12,209 --> 00:02:20,200
could it really be

00:02:13,630 --> 00:02:23,080
maybe I can do this instead and the

00:02:20,200 --> 00:02:26,500
problem with that last question is that

00:02:23,080 --> 00:02:31,840
the answer is often very except when

00:02:26,500 --> 00:02:33,870
it's very very very but what I want to

00:02:31,840 --> 00:02:38,080
talk to you about it today is not just

00:02:33,870 --> 00:02:40,420
motivated by those three virtues because

00:02:38,080 --> 00:02:44,380
there's a fourth virtue or rather a

00:02:40,420 --> 00:02:46,830
zeroth virtue and I think the zeroth

00:02:44,380 --> 00:02:49,750
virtue is something that very frequently

00:02:46,830 --> 00:02:52,720
motivates me to pursue the other three

00:02:49,750 --> 00:02:56,830
to create new tools and new techniques

00:02:52,720 --> 00:03:02,140
for Perle and that 0th virtue is the

00:02:56,830 --> 00:03:04,030
virtue of envy so frequently I'll look

00:03:02,140 --> 00:03:06,550
at another language and I'll say well

00:03:04,030 --> 00:03:09,460
they have some really wonderful toys

00:03:06,550 --> 00:03:11,740
they have some amazing features amazing

00:03:09,460 --> 00:03:14,170
tools built into the language and

00:03:11,740 --> 00:03:18,700
whether that language is Haskell or

00:03:14,170 --> 00:03:21,130
Julia or rocku the problem is it's not

00:03:18,700 --> 00:03:24,720
perl and i don't have those features

00:03:21,130 --> 00:03:28,420
available to me directly in perl and

00:03:24,720 --> 00:03:30,250
that makes me sad because it means that

00:03:28,420 --> 00:03:32,800
I have to write whatever I'm going to

00:03:30,250 --> 00:03:36,070
write in Perl in a way that's harder

00:03:32,800 --> 00:03:37,840
than it needs to be and that's slower to

00:03:36,070 --> 00:03:41,140
develop than it needs to be and may be

00:03:37,840 --> 00:03:44,170
slower to execute as well and ultimately

00:03:41,140 --> 00:03:49,690
maybe it's also uglier than it could be

00:03:44,170 --> 00:03:52,030
otherwise but it's not just in the of

00:03:49,690 --> 00:03:53,860
other programming languages that drives

00:03:52,030 --> 00:03:56,830
some of the projects that I've been

00:03:53,860 --> 00:04:00,420
working on recently there's also another

00:03:56,830 --> 00:04:02,920
kind of envy and that is the envy of the

00:04:00,420 --> 00:04:06,310
development environment in which people

00:04:02,920 --> 00:04:08,920
get to use these languages and it might

00:04:06,310 --> 00:04:12,910
be that I look at environments like the

00:04:08,920 --> 00:04:15,010
s code or Eclipse or comma and I say

00:04:12,910 --> 00:04:17,170
well they have features that I don't

00:04:15,010 --> 00:04:23,410
have in my development environment which

00:04:17,170 --> 00:04:26,050
is vim and that makes me even more

00:04:23,410 --> 00:04:27,220
unhappy because not only am i writing

00:04:26,050 --> 00:04:30,310
things

00:04:27,220 --> 00:04:35,850
slow ugly way but I also have to code

00:04:30,310 --> 00:04:37,810
them using a hard slow ugly environment

00:04:35,850 --> 00:04:42,940
so what I want to talk to you about

00:04:37,810 --> 00:04:47,500
today is a story of applying those Perl

00:04:42,940 --> 00:04:50,530
virtues how Envy leads on to laziness

00:04:47,500 --> 00:04:53,200
which leads on to impatience which then

00:04:50,530 --> 00:04:57,790
gets completely overwhelmed by my own

00:04:53,200 --> 00:05:02,140
hubris and the story that I want to tell

00:04:57,790 --> 00:05:04,600
you starts with this guy for those of

00:05:02,140 --> 00:05:05,800
you who don't know who this is this is

00:05:04,600 --> 00:05:09,700
Curtis Poe

00:05:05,800 --> 00:05:12,610
better known as overt except in this

00:05:09,700 --> 00:05:17,410
story he's not this particular meme he's

00:05:12,610 --> 00:05:19,780
the other meme he's sad overed and the

00:05:17,410 --> 00:05:22,840
reason he said is that he's reporting a

00:05:19,780 --> 00:05:25,780
bug in a vim plugin that I built for

00:05:22,840 --> 00:05:28,960
people who want to use vim to edit Perl

00:05:25,780 --> 00:05:33,880
and that plug-in is called tract pearl

00:05:28,960 --> 00:05:37,450
VARs and what tract pearl VARs does is

00:05:33,880 --> 00:05:40,240
this it allows you as you move around

00:05:37,450 --> 00:05:43,990
your Perl code and you put the cursor

00:05:40,240 --> 00:05:46,330
over any kind of variable to see

00:05:43,990 --> 00:05:49,150
everywhere in the code where that

00:05:46,330 --> 00:05:51,190
variables being used and even if that

00:05:49,150 --> 00:05:53,770
variable is actually spelled a little

00:05:51,190 --> 00:05:56,050
differently for example with a different

00:05:53,770 --> 00:06:00,910
signal because of the way pearls syntax

00:05:56,050 --> 00:06:03,520
works this plugin allows you to see

00:06:00,910 --> 00:06:06,820
where that is being used and the same

00:06:03,520 --> 00:06:10,180
for hashes and problem with this plug-in

00:06:06,820 --> 00:06:14,260
is that it doesn't actually work very

00:06:10,180 --> 00:06:16,540
well for scalars now you're saying well

00:06:14,260 --> 00:06:21,090
it's highlighting all of those scalars

00:06:16,540 --> 00:06:24,370
yeah but they aren't all the same scalar

00:06:21,090 --> 00:06:26,560
for example this scalar is completely

00:06:24,370 --> 00:06:29,710
separate it's the parameter of a

00:06:26,560 --> 00:06:31,990
subroutine and this scalar is completely

00:06:29,710 --> 00:06:35,020
separate it's the iterator of a for loop

00:06:31,990 --> 00:06:37,090
and this one is explicitly declared to

00:06:35,020 --> 00:06:39,250
be a different scalar and yet

00:06:37,090 --> 00:06:43,919
ever I put the cursor on any of those

00:06:39,250 --> 00:06:43,919
all of them get highlighted

00:06:44,669 --> 00:06:52,270
so that's painful to me because it's not

00:06:49,570 --> 00:06:56,200
actually doing the job that I built that

00:06:52,270 --> 00:07:02,470
plug-in to do it's not actually helping

00:06:56,200 --> 00:07:03,850
me understand my Perl code visually so

00:07:02,470 --> 00:07:08,169
it's painful that the plug-in doesn't

00:07:03,850 --> 00:07:10,960
understand Perl scoping rules but it's

00:07:08,169 --> 00:07:12,850
not terribly surprising because in fact

00:07:10,960 --> 00:07:16,930
most humans don't understand Perl

00:07:12,850 --> 00:07:18,790
scoping rules either if we look at a

00:07:16,930 --> 00:07:20,680
simplified version of the code that I

00:07:18,790 --> 00:07:22,600
just showed you and we look at the

00:07:20,680 --> 00:07:26,229
various declarations that are going on

00:07:22,600 --> 00:07:30,250
here we get a sense of just how weird

00:07:26,229 --> 00:07:33,100
Perls scoping rules actually are so when

00:07:30,250 --> 00:07:35,590
this variable is declared then it goes

00:07:33,100 --> 00:07:37,210
into scope and the scope in which it

00:07:35,590 --> 00:07:42,880
exists is from the point where it's

00:07:37,210 --> 00:07:46,270
declared to the end of the surrounding

00:07:42,880 --> 00:07:49,750
block except that it's not declared

00:07:46,270 --> 00:07:52,240
until the end of the statement in which

00:07:49,750 --> 00:07:55,690
is declared so you get this kind of gap

00:07:52,240 --> 00:07:58,990
in the scope immediately after the

00:07:55,690 --> 00:08:01,030
declaration and the same thing happens

00:07:58,990 --> 00:08:03,640
in a for loop when I declare the

00:08:01,030 --> 00:08:07,900
iterator variable of a for loop its

00:08:03,640 --> 00:08:10,479
scope only starts inside the block so

00:08:07,900 --> 00:08:13,419
once again there's this little gap where

00:08:10,479 --> 00:08:16,090
the previous scope is still in effect

00:08:13,419 --> 00:08:18,639
and the same thing if I declared a

00:08:16,090 --> 00:08:21,370
variable inside an if statement which I

00:08:18,639 --> 00:08:25,360
can certainly do in Perl and once again

00:08:21,370 --> 00:08:29,740
it only becomes active in the block of

00:08:25,360 --> 00:08:33,070
the actual if statement and so we end up

00:08:29,740 --> 00:08:36,459
with these little indentations in the

00:08:33,070 --> 00:08:39,010
scope in the two-dimensional sense which

00:08:36,459 --> 00:08:41,979
makes it really hard to write code that

00:08:39,010 --> 00:08:43,930
understands how the scope works because

00:08:41,979 --> 00:08:46,810
any tool that is going to try and

00:08:43,930 --> 00:08:49,089
understand this is not seeing this code

00:08:46,810 --> 00:08:50,480
as a two-dimensional structure but

00:08:49,089 --> 00:08:52,310
simply as a

00:08:50,480 --> 00:08:54,560
dimensional string of characters

00:08:52,310 --> 00:08:56,450
representing the source code so if we

00:08:54,560 --> 00:08:58,970
turn that into a one-dimensional

00:08:56,450 --> 00:09:02,360
structure it looks something like this

00:08:58,970 --> 00:09:06,500
and you can start to see just how weird

00:09:02,360 --> 00:09:09,530
the scoping actually is we seem to go in

00:09:06,500 --> 00:09:11,840
and out and back in and back out of the

00:09:09,530 --> 00:09:15,050
scope it's almost like it's this random

00:09:11,840 --> 00:09:16,760
type of Morse code effect and I think if

00:09:15,050 --> 00:09:20,030
it were Morse code it would be basically

00:09:16,760 --> 00:09:28,640
telling me there is no way you can teach

00:09:20,030 --> 00:09:30,440
them how to understand this so the fact

00:09:28,640 --> 00:09:33,130
that the vim plugin doesn't understand

00:09:30,440 --> 00:09:36,530
the perl scoping rules is probably

00:09:33,130 --> 00:09:39,050
understandable and it's also in very

00:09:36,530 --> 00:09:41,300
good company there are plenty of other

00:09:39,050 --> 00:09:44,000
tools that people use for editing them

00:09:41,300 --> 00:09:50,330
that don't really understand the scope

00:09:44,000 --> 00:09:53,900
of vim variables either for example if

00:09:50,330 --> 00:09:59,210
we looked at the same code in Eclipse

00:09:53,900 --> 00:10:01,130
and we selected a variable then we

00:09:59,210 --> 00:10:03,920
discover it thinks they're all the same

00:10:01,130 --> 00:10:07,670
variable except for some reason it

00:10:03,920 --> 00:10:09,620
thinks that this particular instance of

00:10:07,670 --> 00:10:11,960
it the parameter of the subroutine is

00:10:09,620 --> 00:10:14,240
not the same variable in fact I suspect

00:10:11,960 --> 00:10:18,620
it's not understanding that it's a

00:10:14,240 --> 00:10:22,520
variable at all and things are no better

00:10:18,620 --> 00:10:25,310
if we look at visual studio so once

00:10:22,520 --> 00:10:27,350
again if I select the variable it just

00:10:25,310 --> 00:10:29,060
selects all of them it really doesn't

00:10:27,350 --> 00:10:31,970
understand the differences and it

00:10:29,060 --> 00:10:35,000
doesn't understand that this example

00:10:31,970 --> 00:10:40,520
here isn't in fact the same variable at

00:10:35,000 --> 00:10:42,440
all and so that's very frustrating now

00:10:40,520 --> 00:10:45,700
when I'm coding in rakuyo

00:10:42,440 --> 00:10:49,220
I have a very much better time of things

00:10:45,700 --> 00:10:53,570
for a start because we're cudos idea of

00:10:49,220 --> 00:10:55,880
scope is a little bit simpler so here's

00:10:53,570 --> 00:11:00,710
that code in Perl and here's the

00:10:55,880 --> 00:11:03,870
equivalent code in ruku and in rocku as

00:11:00,710 --> 00:11:06,330
soon as I declare a variable that very

00:11:03,870 --> 00:11:09,690
is in scope and in scope until the end

00:11:06,330 --> 00:11:13,140
of its block and as soon as I declare

00:11:09,690 --> 00:11:16,170
the parameter of a pointy block or of a

00:11:13,140 --> 00:11:19,230
subroutine then that variable is in

00:11:16,170 --> 00:11:21,750
scope to the end of the associated block

00:11:19,230 --> 00:11:23,520
that it's a parameter of and the same

00:11:21,750 --> 00:11:26,520
thing occurs if you're doing it in an if

00:11:23,520 --> 00:11:30,990
statement because the syntax is uniform

00:11:26,520 --> 00:11:33,960
in those cases as well so if I flatten

00:11:30,990 --> 00:11:36,600
this out into a linear sequence then I

00:11:33,960 --> 00:11:38,520
can see that it's very much simpler that

00:11:36,600 --> 00:11:42,210
you have this simple progression into

00:11:38,520 --> 00:11:47,400
and out of scopes which is easy enough

00:11:42,210 --> 00:11:48,990
to track with a simple stack the other

00:11:47,400 --> 00:11:51,810
reason that recruiters have a better

00:11:48,990 --> 00:12:00,930
time is because they have an idea that

00:11:51,810 --> 00:12:03,779
actually understands their language so

00:12:00,930 --> 00:12:06,570
the common ide when i highlight a

00:12:03,779 --> 00:12:09,300
variable actually understands the scope

00:12:06,570 --> 00:12:12,839
of that variable and is therefore able

00:12:09,300 --> 00:12:16,010
to highlight and show me only those

00:12:12,839 --> 00:12:19,680
instances of the variable which belong

00:12:16,010 --> 00:12:22,260
in that scope and that makes it very

00:12:19,680 --> 00:12:25,380
much clearer to me what's going on and

00:12:22,260 --> 00:12:28,920
what I'm to do and more importantly than

00:12:25,380 --> 00:12:31,410
just that all of the tools that comma

00:12:28,920 --> 00:12:36,029
provides to you in terms of refactoring

00:12:31,410 --> 00:12:38,100
work in exactly the same way so for

00:12:36,029 --> 00:12:40,620
example if I decided the data is not a

00:12:38,100 --> 00:12:44,540
great name for a variable and I said

00:12:40,620 --> 00:12:47,670
look I'd like to rename that variable

00:12:44,540 --> 00:12:50,910
then it immediately knows all of the

00:12:47,670 --> 00:12:53,970
ones that it wants to rename and as soon

00:12:50,910 --> 00:12:58,140
as I start renaming it to information it

00:12:53,970 --> 00:13:02,970
renames all of them consistently and

00:12:58,140 --> 00:13:07,350
that's very very handy in addition to

00:13:02,970 --> 00:13:12,260
that people using rocku in comma get all

00:13:07,350 --> 00:13:14,280
sorts of other lovely toys for example

00:13:12,260 --> 00:13:17,670
you'll notice that there are multiple

00:13:14,280 --> 00:13:20,940
instances where I'm calling that

00:13:17,670 --> 00:13:24,480
Charm method on this data variable and I

00:13:20,940 --> 00:13:26,640
might like to optimize this by just

00:13:24,480 --> 00:13:29,340
calling that once and throwing it into a

00:13:26,640 --> 00:13:31,530
variable so I can do that very easily I

00:13:29,340 --> 00:13:33,930
can say look I'd like to extract this to

00:13:31,530 --> 00:13:35,550
a variable and it immediately tells me

00:13:33,930 --> 00:13:37,530
look you've got two instances of this

00:13:35,550 --> 00:13:39,180
and you say to me well hang on a minute

00:13:37,530 --> 00:13:42,380
there's more than two instances there I

00:13:39,180 --> 00:13:45,660
can see four or five of instances there

00:13:42,380 --> 00:13:47,520
however those two instances are the only

00:13:45,660 --> 00:13:50,130
two that are actually using that

00:13:47,520 --> 00:13:51,810
variable the other instances are using

00:13:50,130 --> 00:13:54,780
other variables that happen to be the

00:13:51,810 --> 00:13:57,290
same name so if I select both of those

00:13:54,780 --> 00:14:03,840
then it's going to just allow me to

00:13:57,290 --> 00:14:06,540
change the name of this like so and what

00:14:03,840 --> 00:14:11,190
it's done is it's replaced the two

00:14:06,540 --> 00:14:13,110
instances there with a variable which

00:14:11,190 --> 00:14:16,680
it's initializing to that particular

00:14:13,110 --> 00:14:19,560
value and that's pretty cool and of

00:14:16,680 --> 00:14:27,510
course if I did that in an outer scope

00:14:19,560 --> 00:14:32,790
with exactly the same thing then again

00:14:27,510 --> 00:14:34,830
it finds two instances but there are

00:14:32,790 --> 00:14:38,280
different two instances so it does the

00:14:34,830 --> 00:14:43,050
right thing based on the scoping that it

00:14:38,280 --> 00:14:45,930
finds but of course you can't always

00:14:43,050 --> 00:14:48,390
just refactor something out into a

00:14:45,930 --> 00:14:51,210
variable if I'd like to refactor that

00:14:48,390 --> 00:14:53,940
out into the variable it would say the

00:14:51,210 --> 00:14:58,280
thing once but then it wouldn't say it

00:14:53,940 --> 00:15:01,140
every time that I access the variable so

00:14:58,280 --> 00:15:03,110
comma will also allow you to strap

00:15:01,140 --> 00:15:10,650
extract something out into a subroutine

00:15:03,110 --> 00:15:12,570
at whatever scope is appropriate and

00:15:10,650 --> 00:15:15,810
we'll do something like this it will

00:15:12,570 --> 00:15:17,970
create a local subroutine which simply

00:15:15,810 --> 00:15:19,740
does the operation and then you could go

00:15:17,970 --> 00:15:25,800
to every other place and install

00:15:19,740 --> 00:15:28,320
datalink there as well or more

00:15:25,800 --> 00:15:32,690
interestingly you could say I want to

00:15:28,320 --> 00:15:32,690
factor that out into a subroutine

00:15:34,160 --> 00:15:39,540
but I want to actually pass the

00:15:37,109 --> 00:15:41,910
parameter in separately I don't want to

00:15:39,540 --> 00:15:46,769
use it as like a closure over the

00:15:41,910 --> 00:15:48,869
parameter I want to simply that and now

00:15:46,769 --> 00:15:51,149
the subroutine that you get has an

00:15:48,869 --> 00:15:53,279
argument and that argument is passed in

00:15:51,149 --> 00:15:56,249
and then I could use that same thing in

00:15:53,279 --> 00:15:57,749
all of the places where I say data chars

00:15:56,249 --> 00:16:03,569
and I could just say data length

00:15:57,749 --> 00:16:06,119
whatever so comma is great if you're

00:16:03,569 --> 00:16:09,419
using raku which I do about half the

00:16:06,119 --> 00:16:12,059
time but when I'm using Perl I still

00:16:09,419 --> 00:16:14,369
have to use vim and not just because

00:16:12,059 --> 00:16:17,009
comma doesn't really handle Perl very

00:16:14,369 --> 00:16:20,459
well but more because I've been using

00:16:17,009 --> 00:16:22,739
them for about four decades now and I'm

00:16:20,459 --> 00:16:27,569
just a lot stupider when I'm not using

00:16:22,739 --> 00:16:30,779
it so I have this Envy my chosen

00:16:27,569 --> 00:16:34,679
environment of vim doesn't have all the

00:16:30,779 --> 00:16:37,519
cool toys and all the built-in syntactic

00:16:34,679 --> 00:16:42,199
knowledge that an other environment has

00:16:37,519 --> 00:16:45,480
and I wanted to do so I want my

00:16:42,199 --> 00:16:49,249
experience of coding in them to be as

00:16:45,480 --> 00:16:54,720
easy as my experience of coding in comma

00:16:49,249 --> 00:16:58,379
and I want that absolutely now so from

00:16:54,720 --> 00:17:02,279
those three initial virtues comes a vast

00:16:58,379 --> 00:17:05,490
amount of hubris how hard could it be to

00:17:02,279 --> 00:17:08,490
teach pearls entire syntax to vim and

00:17:05,490 --> 00:17:11,669
how hard could it be to also teach him

00:17:08,490 --> 00:17:17,880
all those lovely IDE features that I

00:17:11,669 --> 00:17:24,659
find in comma and so that's what I did

00:17:17,880 --> 00:17:32,290
I taught them how to understand the

00:17:24,659 --> 00:17:36,460
scoping of Perl variables so as I move

00:17:32,290 --> 00:17:44,890
and you see it only highlights the

00:17:36,460 --> 00:17:46,830
variables in their own scope and it

00:17:44,890 --> 00:17:53,650
understands the difference between

00:17:46,830 --> 00:17:57,820
arrays and hashes and it knows the scope

00:17:53,650 --> 00:18:00,280
of each particular variable and that

00:17:57,820 --> 00:18:02,680
then becomes vastly more useful to me

00:18:00,280 --> 00:18:05,230
because it helps me understand when I'm

00:18:02,680 --> 00:18:09,610
making mistakes about variables and

00:18:05,230 --> 00:18:12,370
their scoping but I wanted this

00:18:09,610 --> 00:18:15,430
environment to be able to do a lot more

00:18:12,370 --> 00:18:17,440
than that for start it would be great if

00:18:15,430 --> 00:18:20,560
I could get some kind of visual

00:18:17,440 --> 00:18:24,120
indication of what the actual scope of

00:18:20,560 --> 00:18:26,470
these variables is so in other

00:18:24,120 --> 00:18:29,110
environments you often have things they

00:18:26,470 --> 00:18:31,540
call scope bars where when you highlight

00:18:29,110 --> 00:18:35,550
a variable it shows you exactly where

00:18:31,540 --> 00:18:43,150
that variable is valid so I wanted that

00:18:35,550 --> 00:18:52,540
also in vim and I can have that all I

00:18:43,150 --> 00:18:59,860
have to do is set up an appropriate

00:18:52,540 --> 00:19:05,320
highlighting group for scope bars and

00:18:59,860 --> 00:19:13,150
whenever I am on a variable it shows me

00:19:05,320 --> 00:19:17,590
the scope and the scopes are color coded

00:19:13,150 --> 00:19:20,670
so that small scope variables get a nice

00:19:17,590 --> 00:19:22,750
cool blue color and variables with

00:19:20,670 --> 00:19:23,200
scopes that are getting kind of too

00:19:22,750 --> 00:19:31,929
large

00:19:23,200 --> 00:19:34,389
get color coded in red and the

00:19:31,929 --> 00:19:37,210
the thing I did was to solve the problem

00:19:34,389 --> 00:19:41,580
that Ovid was reporting with the track

00:19:37,210 --> 00:19:46,240
pearl VARs plugin and that is when I do

00:19:41,580 --> 00:19:49,090
detect a variable like this I would like

00:19:46,240 --> 00:19:52,899
to also be able to see other variables

00:19:49,090 --> 00:19:55,929
of similar names that are not that

00:19:52,899 --> 00:19:58,570
variable at the moment I don't see them

00:19:55,929 --> 00:20:00,159
because they're not highlighted but I

00:19:58,570 --> 00:20:02,529
would like them to be highlighted in

00:20:00,159 --> 00:20:06,309
such a way that says these are not the

00:20:02,529 --> 00:20:09,460
same so what I want to do here is I want

00:20:06,309 --> 00:20:11,200
to be able to detect and highlight what

00:20:09,460 --> 00:20:14,830
I'm going to call tomograms

00:20:11,200 --> 00:20:17,590
and that is variable names that are

00:20:14,830 --> 00:20:20,909
spelt the same but mean something

00:20:17,590 --> 00:20:29,139
different so I added another

00:20:20,909 --> 00:20:31,929
highlighting group tomograms and if you

00:20:29,139 --> 00:20:34,570
set that to something interesting then

00:20:31,929 --> 00:20:39,179
every time you highlight a variable all

00:20:34,570 --> 00:20:41,440
the other variables in the same scope

00:20:39,179 --> 00:20:43,809
which have the same name

00:20:41,440 --> 00:20:47,110
get highlighted in that alternative

00:20:43,809 --> 00:20:48,850
highlighting so you can see variables

00:20:47,110 --> 00:20:50,289
that you might confuse with the

00:20:48,850 --> 00:20:52,389
variables that you're using and

00:20:50,289 --> 00:20:56,169
hopefully that encourages you not to

00:20:52,389 --> 00:20:58,779
call every single variable data and of

00:20:56,169 --> 00:21:01,210
course once I have the idea of being

00:20:58,779 --> 00:21:03,669
able to analyze the whole code and find

00:21:01,210 --> 00:21:05,830
other kinds of problems then there are

00:21:03,669 --> 00:21:08,789
all sorts of problems that I'd like this

00:21:05,830 --> 00:21:12,519
also to be detecting for me

00:21:08,789 --> 00:21:15,490
for example many years ago good friend

00:21:12,519 --> 00:21:17,919
of mine told me a horror story about

00:21:15,490 --> 00:21:21,129
developing software for fly-by-wire

00:21:17,919 --> 00:21:23,320
systems for aircrafts where they had a

00:21:21,129 --> 00:21:26,019
persistent bug that was causing their

00:21:23,320 --> 00:21:28,840
virtual simulations to crash repeatedly

00:21:26,019 --> 00:21:31,720
and it all came down eventually to the

00:21:28,840 --> 00:21:34,240
fact that they had two variables one of

00:21:31,720 --> 00:21:37,149
which was called attitude and the other

00:21:34,240 --> 00:21:39,820
which was called altitude and those two

00:21:37,149 --> 00:21:42,730
variables were being used in the same

00:21:39,820 --> 00:21:44,619
scope and people's brains were just not

00:21:42,730 --> 00:21:45,960
picking that they were not the same

00:21:44,619 --> 00:21:49,090
variable

00:21:45,960 --> 00:21:51,490
so I thought to myself there are lots of

00:21:49,090 --> 00:21:53,950
cases where that happens especially if

00:21:51,490 --> 00:21:58,570
your team is half based in the US and

00:21:53,950 --> 00:22:01,780
half based in Britain for example so I

00:21:58,570 --> 00:22:05,560
thought why couldn't this environment

00:22:01,780 --> 00:22:11,650
also highlight variable names that were

00:22:05,560 --> 00:22:14,230
likely to be confused for example if I

00:22:11,650 --> 00:22:16,780
have a variable called attitude then any

00:22:14,230 --> 00:22:19,030
variable called altitude is likely to be

00:22:16,780 --> 00:22:23,830
confusing so I'd like that to be

00:22:19,030 --> 00:22:24,540
highlighted for me as this is not the

00:22:23,830 --> 00:22:27,340
same thing

00:22:24,540 --> 00:22:29,710
likewise where there are regional

00:22:27,340 --> 00:22:32,440
differences in spelling I would like

00:22:29,710 --> 00:22:34,540
those differences in spelling to also be

00:22:32,440 --> 00:22:36,970
highlighted for me so that I can easily

00:22:34,540 --> 00:22:41,770
pick up the kind of bugs that can be

00:22:36,970 --> 00:22:44,530
very hard to track down otherwise now

00:22:41,770 --> 00:22:47,050
interestingly I want it to be reasonably

00:22:44,530 --> 00:22:49,420
smart so I want it to be able to tell me

00:22:47,050 --> 00:22:51,700
look you've got altitude and attitude

00:22:49,420 --> 00:22:53,530
here but you've also had a very called

00:22:51,700 --> 00:22:56,500
aptitude and you'll notice that it's not

00:22:53,530 --> 00:22:59,920
in fact highlighting aptitude so this is

00:22:56,500 --> 00:23:02,320
not just about the number of characters

00:22:59,920 --> 00:23:04,510
of difference between the two variables

00:23:02,320 --> 00:23:07,420
it's about psychologically are you

00:23:04,510 --> 00:23:09,880
likely to confuse these two and for

00:23:07,420 --> 00:23:13,330
reasons of the structure of the letters

00:23:09,880 --> 00:23:16,630
of those three words altitude and

00:23:13,330 --> 00:23:19,960
attitude are likely to be mistaken for

00:23:16,630 --> 00:23:23,370
each other but aptitude probably not so

00:23:19,960 --> 00:23:30,180
much the other thing that I decided was

00:23:23,370 --> 00:23:30,180
if you've got two separate variables

00:23:30,270 --> 00:23:35,200
that are very similar but are in

00:23:32,800 --> 00:23:37,750
completely different scopes then there's

00:23:35,200 --> 00:23:40,090
no need to highlight the likely

00:23:37,750 --> 00:23:42,220
confusion because the compiler is not

00:23:40,090 --> 00:23:46,690
going to allow you to put the wrong

00:23:42,220 --> 00:23:48,700
variable in the wrong scope on the other

00:23:46,690 --> 00:23:51,670
hand if they're actually in the same

00:23:48,700 --> 00:23:55,530
scope then we do want to highlight the

00:23:51,670 --> 00:23:55,530
potential for confusion there

00:24:02,120 --> 00:24:06,990
yet another kind of analysis that I'd

00:24:04,860 --> 00:24:09,720
wanted my environment to be able to do

00:24:06,990 --> 00:24:12,270
or is to detect when people would

00:24:09,720 --> 00:24:15,510
basically choosing poor names for

00:24:12,270 --> 00:24:17,490
variables so this is the problem that I

00:24:15,510 --> 00:24:19,770
encounter quite often when I'm teaching

00:24:17,490 --> 00:24:22,680
program and particularly software

00:24:19,770 --> 00:24:27,290
development techniques and that is when

00:24:22,680 --> 00:24:32,490
people write code they choose names like

00:24:27,290 --> 00:24:35,550
record or item count or data set which

00:24:32,490 --> 00:24:38,730
tell me absolutely nothing about what

00:24:35,550 --> 00:24:39,860
this variables for what it's doing how

00:24:38,730 --> 00:24:43,290
its contributing to the overall

00:24:39,860 --> 00:24:45,420
algorithm they're just bad generic kinds

00:24:43,290 --> 00:24:48,300
of names so I thought it would be really

00:24:45,420 --> 00:24:51,210
cool if my environment could pick me up

00:24:48,300 --> 00:24:56,100
when I was using these kinds of bad

00:24:51,210 --> 00:24:59,300
generic names so I arranged yet another

00:24:56,100 --> 00:25:10,530
kind of analysis which again is optional

00:24:59,300 --> 00:25:13,290
where you can set a highlight group for

00:25:10,530 --> 00:25:17,460
caki grams and kilograms is a made-up

00:25:13,290 --> 00:25:20,010
word meaning crappy names and so if I

00:25:17,460 --> 00:25:23,070
set some kind of highlighting

00:25:20,010 --> 00:25:26,790
specifically for that then we see all of

00:25:23,070 --> 00:25:31,500
the really poor names in this example

00:25:26,790 --> 00:25:33,480
get highlighted and of course if we're

00:25:31,500 --> 00:25:35,850
highlighting those really poor names

00:25:33,480 --> 00:25:37,380
we're hoping that someone will go in and

00:25:35,850 --> 00:25:40,350
change them but of course it's

00:25:37,380 --> 00:25:41,880
frustrating to want to go in and change

00:25:40,350 --> 00:25:44,220
this thing and then have to change it

00:25:41,880 --> 00:25:46,800
all through the code so this brings us

00:25:44,220 --> 00:25:50,100
on to the idea of adding these standard

00:25:46,800 --> 00:25:53,460
IDE features into them as well so I'd

00:25:50,100 --> 00:25:56,490
like for example to be able to rename

00:25:53,460 --> 00:25:59,970
this variable everywhere in its own

00:25:56,490 --> 00:26:02,700
scope so naturally that's exactly what I

00:25:59,970 --> 00:26:05,790
added whenever you have the cursor over

00:26:02,700 --> 00:26:09,270
a variable you can just say rename that

00:26:05,790 --> 00:26:10,890
variable and give it a new name let's

00:26:09,270 --> 00:26:16,230
try and find

00:26:10,890 --> 00:26:18,180
info and then it will rename it

00:26:16,230 --> 00:26:20,130
everywhere and even though it's a hash

00:26:18,180 --> 00:26:22,710
with a percentage sign it will also

00:26:20,130 --> 00:26:24,420
detect the usage of that hash which we

00:26:22,710 --> 00:26:27,060
might have a dollar sign or an out sign

00:26:24,420 --> 00:26:29,640
instead and correctly change that and if

00:26:27,060 --> 00:26:31,530
we step off that now we'll see that it's

00:26:29,640 --> 00:26:35,310
no longer a Kappa gram because it's

00:26:31,530 --> 00:26:37,620
presumably specific enough for us to

00:26:35,310 --> 00:26:39,720
understand what's going on here and so

00:26:37,620 --> 00:26:42,150
we could do the same thing with item

00:26:39,720 --> 00:26:44,430
count or in particular data set data

00:26:42,150 --> 00:26:46,980
sets just a terrible name so I could say

00:26:44,430 --> 00:26:51,210
well instead of data set then it's going

00:26:46,980 --> 00:26:56,720
to be client records and it will change

00:26:51,210 --> 00:27:00,440
that and again it's no longer a category

00:26:56,720 --> 00:27:04,140
so once we've started on the idea of

00:27:00,440 --> 00:27:09,210
adding these IDE features to them it's

00:27:04,140 --> 00:27:11,910
very hard to stop so I wanted to be able

00:27:09,210 --> 00:27:13,530
to do all that clever refactoring stuff

00:27:11,910 --> 00:27:17,850
that I showed you a little bit earlier

00:27:13,530 --> 00:27:24,210
in kama for example if I go down here

00:27:17,850 --> 00:27:26,940
and I have the length of some kind of

00:27:24,210 --> 00:27:29,670
data I'd like to be able to host that

00:27:26,940 --> 00:27:32,250
out into a variable and I'd like it to

00:27:29,670 --> 00:27:34,500
be able to say okay I found all of these

00:27:32,250 --> 00:27:37,020
instances now you'll notice that there

00:27:34,500 --> 00:27:39,810
are in fact three three or four more

00:27:37,020 --> 00:27:42,330
instances of length of data but it

00:27:39,810 --> 00:27:45,420
hasn't selected those because the data

00:27:42,330 --> 00:27:48,030
variable inside those expressions isn't

00:27:45,420 --> 00:27:51,240
the same variable so you can't hice them

00:27:48,030 --> 00:27:53,640
out into the same variable you'll notice

00:27:51,240 --> 00:27:55,830
also that it's tried to make up a name

00:27:53,640 --> 00:27:58,860
for it based on what it's found in the

00:27:55,830 --> 00:28:01,680
source code I might prefer to have data

00:27:58,860 --> 00:28:04,170
Len like I was using before and then it

00:28:01,680 --> 00:28:08,640
does this it puts a lexical variable in

00:28:04,170 --> 00:28:10,650
there which is initialized with the

00:28:08,640 --> 00:28:13,950
value of the expression and then it

00:28:10,650 --> 00:28:16,260
replaces the expression everywhere where

00:28:13,950 --> 00:28:22,080
that variable is correctly in the Skog

00:28:16,260 --> 00:28:23,330
and of course if I tried to do the same

00:28:22,080 --> 00:28:29,330
thing

00:28:23,330 --> 00:28:31,250
here then we see that it heists it right

00:28:29,330 --> 00:28:34,190
up to the top of its scope replaces

00:28:31,250 --> 00:28:37,430
everything in the same scope but still

00:28:34,190 --> 00:28:40,550
leaves these other instances of length

00:28:37,430 --> 00:28:43,790
of data a lot now hoisting out into a

00:28:40,550 --> 00:28:46,100
variable is cool but it's not always the

00:28:43,790 --> 00:28:48,920
right solution and it's not the right

00:28:46,100 --> 00:28:51,410
solution in the case where we want to do

00:28:48,920 --> 00:28:58,400
something like this if I refactor this

00:28:51,410 --> 00:29:01,610
out into a variable then the problem is

00:28:58,400 --> 00:29:03,530
it's going to do that say only once when

00:29:01,610 --> 00:29:05,810
it initializes the variable and then

00:29:03,530 --> 00:29:08,240
just put in the variable into the code

00:29:05,810 --> 00:29:08,510
is not going to make it say that every

00:29:08,240 --> 00:29:11,570
time

00:29:08,510 --> 00:29:13,700
so hoisting to a variable is not always

00:29:11,570 --> 00:29:15,920
the right solution what we really want

00:29:13,700 --> 00:29:18,560
to be able to do is to hoist this to

00:29:15,920 --> 00:29:20,360
some kind of subroutine and the easiest

00:29:18,560 --> 00:29:22,370
way of doing this in the cleanest way of

00:29:20,360 --> 00:29:24,980
doing this in modern Perl would be to

00:29:22,370 --> 00:29:27,590
say I'd like to hoist this out into a

00:29:24,980 --> 00:29:30,980
little closure and what I'd like to do

00:29:27,590 --> 00:29:34,550
is I'd like it to insert a very small

00:29:30,980 --> 00:29:39,680
lexically scoped subroutine that does

00:29:34,550 --> 00:29:42,830
that piece of code now of course that

00:29:39,680 --> 00:29:45,290
variable is just the same variable there

00:29:42,830 --> 00:29:47,600
because this is a lexical subroutine so

00:29:45,290 --> 00:29:51,800
it can be a closure over that variable

00:29:47,600 --> 00:29:54,440
and now the two calls to say length data

00:29:51,800 --> 00:29:57,020
do exactly the right thing and you'll

00:29:54,440 --> 00:29:59,570
notice that all of the other potential

00:29:57,020 --> 00:30:03,230
calls haven't been changed because once

00:29:59,570 --> 00:30:05,060
again it knows the scope of the

00:30:03,230 --> 00:30:08,300
variables that are involved in the

00:30:05,060 --> 00:30:12,320
operation that it's refactoring and it

00:30:08,300 --> 00:30:14,360
knows when to leave things alone so

00:30:12,320 --> 00:30:16,730
that's fairly cool but you might say to

00:30:14,360 --> 00:30:19,910
me yeah but the problem is that only

00:30:16,730 --> 00:30:22,940
works in later versions of Perl if I'm

00:30:19,910 --> 00:30:24,350
actually using a really early version of

00:30:22,940 --> 00:30:26,930
Perl still and there are people that

00:30:24,350 --> 00:30:31,880
have to do that then I've got a problem

00:30:26,930 --> 00:30:34,010
so if I want to refactor that into a

00:30:31,880 --> 00:30:36,770
lexical subroutine that's not going to

00:30:34,010 --> 00:30:41,120
work because Perl 514 didn't have like

00:30:36,770 --> 00:30:43,730
to call subroutines well once again the

00:30:41,120 --> 00:30:49,010
module is smart enough to know that and

00:30:43,730 --> 00:30:51,230
to do the right thing so if I say that I

00:30:49,010 --> 00:30:53,210
want to hoist those out you'll see now

00:30:51,230 --> 00:30:55,070
what it does is something a little bit

00:30:53,210 --> 00:30:57,020
different it creates an anonymous

00:30:55,070 --> 00:30:59,000
subroutine that can act as a closure

00:30:57,020 --> 00:31:01,550
over that variable and then it just

00:30:59,000 --> 00:31:07,190
assigns it to another lexical variable

00:31:01,550 --> 00:31:10,030
and then when I want to call it it uses

00:31:07,190 --> 00:31:18,830
the variable and does a dereferenced

00:31:10,030 --> 00:31:21,200
subroutine call through that but

00:31:18,830 --> 00:31:22,940
sometimes even a closure isn't the right

00:31:21,200 --> 00:31:25,760
thing to do because we've got a lot of

00:31:22,940 --> 00:31:28,580
places where we say lengths of data and

00:31:25,760 --> 00:31:32,510
it's not always the same data so what

00:31:28,580 --> 00:31:33,530
we'd also like to be able to do is to

00:31:32,510 --> 00:31:37,250
say well okay

00:31:33,530 --> 00:31:39,320
find every instance of that and turn it

00:31:37,250 --> 00:31:42,380
into a subroutine that can replace all

00:31:39,320 --> 00:31:44,330
of these say lengths of data and of

00:31:42,380 --> 00:31:47,300
course to do that we're going to have to

00:31:44,330 --> 00:31:50,240
pass the data variable into the

00:31:47,300 --> 00:31:51,710
subroutine as an argument because it's

00:31:50,240 --> 00:31:54,770
going to be a different variable in

00:31:51,710 --> 00:31:57,350
different scopes so I can say I want to

00:31:54,770 --> 00:32:04,040
refactor that out to something let's

00:31:57,350 --> 00:32:06,500
call it data length and it does this so

00:32:04,040 --> 00:32:08,900
every instance of say data there has

00:32:06,500 --> 00:32:11,770
been replaced with a call to some

00:32:08,900 --> 00:32:16,970
function called data length passing in

00:32:11,770 --> 00:32:21,730
the argument as a parameter and then we

00:32:16,970 --> 00:32:21,730
can simply install that subroutine

00:32:22,840 --> 00:32:27,190
wherever we find it appropriate

00:32:31,280 --> 00:32:38,840
and this technique is fairly smart

00:32:35,330 --> 00:32:41,870
because it understands the scoping of

00:32:38,840 --> 00:32:45,380
different variables so for example if I

00:32:41,870 --> 00:32:54,680
said I'd like to refactor this entire

00:32:45,380 --> 00:32:58,280
thing into a subroutine then now it

00:32:54,680 --> 00:33:01,850
knows that it needs to pass the array

00:32:58,280 --> 00:33:06,200
and the hash version of data into the

00:33:01,850 --> 00:33:12,140
subroutine and indeed it installs those

00:33:06,200 --> 00:33:20,180
and changes every use of those inside

00:33:12,140 --> 00:33:23,240
the subroutine but things can get

00:33:20,180 --> 00:33:27,110
trickier than that for a start suppose

00:33:23,240 --> 00:33:29,390
that I wanted to refactor this whole

00:33:27,110 --> 00:33:31,100
component into a single subroutine call

00:33:29,390 --> 00:33:33,770
well that's a little bit tricky because

00:33:31,100 --> 00:33:35,900
if I refactor out the Declaration of the

00:33:33,770 --> 00:33:38,420
variable then the code immediately

00:33:35,900 --> 00:33:41,420
afterwards that uses that variable isn't

00:33:38,420 --> 00:33:48,170
going to work correctly anymore so the

00:33:41,420 --> 00:33:50,840
modules smart enough to understand that

00:33:48,170 --> 00:33:52,730
because it understands scoping and what

00:33:50,840 --> 00:33:55,700
it does instead is it declares that

00:33:52,730 --> 00:33:59,390
variable as one of the arguments to the

00:33:55,700 --> 00:34:02,000
subroutine so that it's still available

00:33:59,390 --> 00:34:04,130
in the outer scope and what does the

00:34:02,000 --> 00:34:07,280
subroutine actually look like it now

00:34:04,130 --> 00:34:09,290
passes in a third reference here which

00:34:07,280 --> 00:34:16,909
it can simply use to assign in the

00:34:09,290 --> 00:34:21,310
normal way on the other hand if I wanted

00:34:16,909 --> 00:34:24,320
to refactor the entire assignment and

00:34:21,310 --> 00:34:27,100
every use of the variable that's been

00:34:24,320 --> 00:34:27,100
declared there

00:34:36,330 --> 00:34:43,220
then it doesn't bother with hoisting the

00:34:40,050 --> 00:34:48,380
variable back out into the argument list

00:34:43,220 --> 00:34:55,170
because it's detected that the variable

00:34:48,380 --> 00:34:57,510
is only used in this scope and therefore

00:34:55,170 --> 00:35:04,200
it doesn't need to pass it in or pass it

00:34:57,510 --> 00:35:06,390
back out either finally it has good

00:35:04,200 --> 00:35:09,510
understanding of the actual structure of

00:35:06,390 --> 00:35:13,110
Perl so that if you try and get it to

00:35:09,510 --> 00:35:16,440
refactor something that isn't valid code

00:35:13,110 --> 00:35:25,470
it just says no can't do it doesn't make

00:35:16,440 --> 00:35:27,780
any sense the modules called code art it

00:35:25,470 --> 00:35:30,330
stands for analysis refactoring and

00:35:27,780 --> 00:35:33,480
tracking and yes I did consider calling

00:35:30,330 --> 00:35:36,630
it dar or rat instead but I think parts

00:35:33,480 --> 00:35:40,050
kind of more hopeful and the point here

00:35:36,630 --> 00:35:41,880
is this is not just for vim I tried to

00:35:40,050 --> 00:35:44,280
write it in such a way that it would be

00:35:41,880 --> 00:35:48,210
easy to plug in to any kind of

00:35:44,280 --> 00:35:52,140
scriptable editor he simply write a few

00:35:48,210 --> 00:35:53,940
small pieces of Perl and get those

00:35:52,140 --> 00:35:58,020
called remotely from within the editor

00:35:53,940 --> 00:35:59,940
and possibly asynchronously and then

00:35:58,020 --> 00:36:01,710
those small pieces of Perl just reading

00:35:59,940 --> 00:36:06,090
the contents of the buffer from standard

00:36:01,710 --> 00:36:08,550
in do the processing necessary take the

00:36:06,090 --> 00:36:10,530
data structure that is produced convert

00:36:08,550 --> 00:36:13,110
it to a native data structure and print

00:36:10,530 --> 00:36:14,850
it to standard out and then the editor

00:36:13,110 --> 00:36:16,860
reads that back in and does whatever it

00:36:14,850 --> 00:36:17,850
likes with it that's exactly what I did

00:36:16,860 --> 00:36:22,970
for them

00:36:17,850 --> 00:36:26,970
I wrote a small module code art API vim

00:36:22,970 --> 00:36:30,960
that reads in the buffer contents from

00:36:26,970 --> 00:36:33,090
standard in then calls the appropriate

00:36:30,960 --> 00:36:36,900
subroutine from the main code art module

00:36:33,090 --> 00:36:40,170
and then converts the resulting hash

00:36:36,900 --> 00:36:43,440
into a film script dictionary and prints

00:36:40,170 --> 00:36:46,110
that out and then for all of the other

00:36:43,440 --> 00:36:48,620
facilities that the code art module

00:36:46,110 --> 00:36:49,980
provides there are pretty much identical

00:36:48,620 --> 00:36:55,260
function

00:36:49,980 --> 00:36:58,260
that do the same sort of thing and then

00:36:55,260 --> 00:37:01,589
back in the editor I wrote a very small

00:36:58,260 --> 00:37:04,589
amount of script to hook that into the

00:37:01,589 --> 00:37:07,920
editor itself so I find the position

00:37:04,589 --> 00:37:09,270
that I am in the buffer I work out what

00:37:07,920 --> 00:37:11,069
do I want to do here well I want to

00:37:09,270 --> 00:37:13,770
classify the variable that's under the

00:37:11,069 --> 00:37:18,890
cursor at the moment so then I make a

00:37:13,770 --> 00:37:23,220
small pearl call saying load the module

00:37:18,890 --> 00:37:25,050
execute the request pass in as standard

00:37:23,220 --> 00:37:27,690
input the entire contents of the buffer

00:37:25,050 --> 00:37:30,270
and then the system command in vim

00:37:27,690 --> 00:37:35,480
script actually returns the output of

00:37:30,270 --> 00:37:39,150
that command which I then evaluate as a

00:37:35,480 --> 00:37:41,040
regular vim script dictionary and once I

00:37:39,150 --> 00:37:42,990
have that information then I can do

00:37:41,040 --> 00:37:47,670
whatever I want to do with that

00:37:42,990 --> 00:37:49,559
information or in many cases in the vim

00:37:47,670 --> 00:37:52,290
version of this I'm going to do it

00:37:49,559 --> 00:37:54,690
a synchronously instead so I start an

00:37:52,290 --> 00:37:58,319
asynchronous job call exactly the same

00:37:54,690 --> 00:38:02,309
Perl function passing it the buffer as

00:37:58,319 --> 00:38:05,490
that standard in and saying and when you

00:38:02,309 --> 00:38:07,829
get standard Outback call this handler

00:38:05,490 --> 00:38:10,920
function and the handler function just

00:38:07,829 --> 00:38:15,630
evaluates what it gets back and does

00:38:10,920 --> 00:38:17,520
something with it so you're probably

00:38:15,630 --> 00:38:22,470
wondering well how does the module

00:38:17,520 --> 00:38:26,609
itself work and the answer not very

00:38:22,470 --> 00:38:29,730
surprisingly is via a giant regular

00:38:26,609 --> 00:38:31,500
expression that I wrote and if we pull

00:38:29,730 --> 00:38:33,930
back and have a look at that regular

00:38:31,500 --> 00:38:38,160
expression we'll see that it in fact

00:38:33,930 --> 00:38:40,819
it's nearly 350 lines long so what am i

00:38:38,160 --> 00:38:48,720
doing in that regular expression that

00:38:40,819 --> 00:38:52,230
requires that much code well what I'm

00:38:48,720 --> 00:38:55,410
doing is I'm pausing the entire Perl

00:38:52,230 --> 00:38:59,130
document but in doing so I'm maintaining

00:38:55,410 --> 00:39:02,849
a stack of scope descriptors into which

00:38:59,130 --> 00:39:03,510
I assign information about each of the

00:39:02,849 --> 00:39:07,380
variable

00:39:03,510 --> 00:39:10,860
that are declared or used in each scope

00:39:07,380 --> 00:39:12,990
that I encounter within the document and

00:39:10,860 --> 00:39:16,740
what they look like are just little

00:39:12,990 --> 00:39:21,600
pieces of code to be executed as undoing

00:39:16,740 --> 00:39:24,660
my parsing so to put a scope all I do is

00:39:21,600 --> 00:39:27,090
create a new hash that represents the

00:39:24,660 --> 00:39:29,370
new scope and then push it onto this

00:39:27,090 --> 00:39:31,470
stack that I'm maintaining in a package

00:39:29,370 --> 00:39:33,840
variable and I'm using a package

00:39:31,470 --> 00:39:36,960
variable here because lexical variables

00:39:33,840 --> 00:39:39,300
in Perl don't always play nicely inside

00:39:36,960 --> 00:39:40,860
regular expressions so what's going to

00:39:39,300 --> 00:39:43,230
go into that description of the new

00:39:40,860 --> 00:39:47,310
scope well for a start I'm going to copy

00:39:43,230 --> 00:39:49,110
from the previous scope all of the IDs

00:39:47,310 --> 00:39:50,550
and make them the IDS of this scope

00:39:49,110 --> 00:39:52,890
because that's the way lexical scoping

00:39:50,550 --> 00:39:54,600
works when you go into a lexical scope

00:39:52,890 --> 00:39:57,660
you get a copy of all the existing

00:39:54,600 --> 00:40:00,510
variables from that out of scope and I'm

00:39:57,660 --> 00:40:02,100
also going to provide the possibility

00:40:00,510 --> 00:40:04,500
that there are going to be new

00:40:02,100 --> 00:40:06,900
declarations in this scope so I'm going

00:40:04,500 --> 00:40:09,300
to have a slot whereby I can install

00:40:06,900 --> 00:40:10,920
these new declarations but of course

00:40:09,300 --> 00:40:13,590
initially there won't be any of them and

00:40:10,920 --> 00:40:15,390
then when I get to the end of any

00:40:13,590 --> 00:40:18,090
particular scope I'm obviously just

00:40:15,390 --> 00:40:21,210
going to pop the stack to take me back

00:40:18,090 --> 00:40:24,540
to the previous level I'm going to

00:40:21,210 --> 00:40:26,490
record where I was in the actual source

00:40:24,540 --> 00:40:29,580
code my position in the source code

00:40:26,490 --> 00:40:32,700
stream so that I know where the end of

00:40:29,580 --> 00:40:35,730
scope is for each scope and then for

00:40:32,700 --> 00:40:38,730
each of the variables that were in this

00:40:35,730 --> 00:40:41,370
old scope that I just popped I'm going

00:40:38,730 --> 00:40:44,580
to make their endoscope the the current

00:40:41,370 --> 00:40:47,550
endoscope so as I come out of a scope

00:40:44,580 --> 00:40:49,500
I'm going to track in each variable that

00:40:47,550 --> 00:40:54,840
was declared in it that this was the end

00:40:49,500 --> 00:40:55,330
of that variables scope and then the

00:40:54,840 --> 00:40:58,630
rest

00:40:55,330 --> 00:41:00,990
subroutine is all about pausing the

00:40:58,630 --> 00:41:04,930
various components of a Perl program

00:41:00,990 --> 00:41:08,020
while tracking the declaration and use

00:41:04,930 --> 00:41:11,830
of variables in the various scopes where

00:41:08,020 --> 00:41:14,740
they may appear the first thing that I

00:41:11,830 --> 00:41:17,620
actually do is not related to scope it's

00:41:14,740 --> 00:41:20,590
about finding which version of Perl this

00:41:17,620 --> 00:41:22,750
code thinks it is so I need to parse any

00:41:20,590 --> 00:41:26,100
use statement that I encountered and in

00:41:22,750 --> 00:41:30,640
particular any use version statement and

00:41:26,100 --> 00:41:31,900
save that information as the version

00:41:30,640 --> 00:41:33,670
that we're going to use for the whole

00:41:31,900 --> 00:41:36,400
thing and this is the way that the

00:41:33,670 --> 00:41:38,380
module knows how to build subroutines

00:41:36,400 --> 00:41:40,360
does it build them the new way or does

00:41:38,380 --> 00:41:42,610
it build them the old way how do i

00:41:40,360 --> 00:41:45,430
refactor closures the new way or the old

00:41:42,610 --> 00:41:48,030
way it's all based on which version of

00:41:45,430 --> 00:41:50,860
Perl you've said that this code requires

00:41:48,030 --> 00:41:55,990
so I store that away whenever I

00:41:50,860 --> 00:41:58,030
encounter a used version but mostly what

00:41:55,990 --> 00:42:01,120
I'm going to be doing is pausing a

00:41:58,030 --> 00:42:03,400
series of blocks of code and every time

00:42:01,120 --> 00:42:06,700
I pass a block of code I'm going to push

00:42:03,400 --> 00:42:08,860
a new scope onto the stack then pass the

00:42:06,700 --> 00:42:10,750
block of code in the exact standard way

00:42:08,860 --> 00:42:13,050
that it would be pars any other time and

00:42:10,750 --> 00:42:17,830
then having done that I'm going to pop

00:42:13,050 --> 00:42:18,660
that new stack frame off as I'm done

00:42:17,830 --> 00:42:21,970
with it

00:42:18,660 --> 00:42:24,910
but in addition I have to cater for the

00:42:21,970 --> 00:42:27,040
possibility that I won't successfully

00:42:24,910 --> 00:42:29,290
pars a block at this point it might turn

00:42:27,040 --> 00:42:31,450
out to be an anonymous hash instead so I

00:42:29,290 --> 00:42:34,510
need to make sure that I keep the stack

00:42:31,450 --> 00:42:36,940
consistent so if I fail to pass that

00:42:34,510 --> 00:42:39,070
block I have to make sure I revert the

00:42:36,940 --> 00:42:41,350
stack on that failure because I'm always

00:42:39,070 --> 00:42:43,600
going to push up onto the stack but if I

00:42:41,350 --> 00:42:46,030
fail to pass the block then this pop

00:42:43,600 --> 00:42:47,800
stack is not going to operate at all so

00:42:46,030 --> 00:42:51,760
I need something that pops the stack for

00:42:47,800 --> 00:42:53,560
me in that failure case and of course I

00:42:51,760 --> 00:42:56,650
need the same thing for any location

00:42:53,560 --> 00:42:58,780
where I might encounter variables so if

00:42:56,650 --> 00:43:01,600
I'm inside an anonymous hash that I need

00:42:58,780 --> 00:43:04,710
to add a scope around that and take the

00:43:01,600 --> 00:43:04,710
scope off afterwards

00:43:05,000 --> 00:43:09,980
now earlier I mentioned the variables in

00:43:08,000 --> 00:43:11,480
Perl or unusual in that they don't come

00:43:09,980 --> 00:43:14,060
into existence when they're declared

00:43:11,480 --> 00:43:16,030
they come into existence at the end of

00:43:14,060 --> 00:43:18,320
the statement where they were declared

00:43:16,030 --> 00:43:20,420
so that means that I need to be a bit

00:43:18,320 --> 00:43:22,400
careful when I'm pausing Perl statements

00:43:20,420 --> 00:43:25,460
I still need to pass the statement in

00:43:22,400 --> 00:43:27,590
exactly the normal way but after I

00:43:25,460 --> 00:43:30,340
finished parsing the statement is the

00:43:27,590 --> 00:43:32,090
point where I should install any new

00:43:30,340 --> 00:43:35,359
declarations that occurred in that

00:43:32,090 --> 00:43:37,070
statement into the current scope they

00:43:35,359 --> 00:43:39,020
shouldn't be installed as soon as

00:43:37,070 --> 00:43:40,880
they're encountered they should only be

00:43:39,020 --> 00:43:44,630
installed after the statement is

00:43:40,880 --> 00:43:47,270
complete and of course once again if I

00:43:44,630 --> 00:43:49,790
fail to pass a statement for some reason

00:43:47,270 --> 00:43:51,619
then I need to be sure that I'm clearing

00:43:49,790 --> 00:43:56,450
out those declarations

00:43:51,619 --> 00:43:58,099
that may be partial but not complete and

00:43:56,450 --> 00:44:01,220
what does it look like to install those

00:43:58,099 --> 00:44:03,680
declarations well all I do is I go

00:44:01,220 --> 00:44:05,750
through the list of declarations that

00:44:03,680 --> 00:44:08,359
have been added to this current scope

00:44:05,750 --> 00:44:12,020
and for each of them installed their ID

00:44:08,359 --> 00:44:14,540
as the ID for this variable named

00:44:12,020 --> 00:44:16,670
whatever it's been named and then I take

00:44:14,540 --> 00:44:19,160
all the other information that I got

00:44:16,670 --> 00:44:22,580
about it it's declared or at sigil its

00:44:19,160 --> 00:44:25,160
name its description and I store them in

00:44:22,580 --> 00:44:27,170
a table that I'm building up of variable

00:44:25,160 --> 00:44:32,839
information about these various

00:44:27,170 --> 00:44:35,300
components and finally I add to my other

00:44:32,839 --> 00:44:37,970
table which is where were the various

00:44:35,300 --> 00:44:39,950
variables used the information that this

00:44:37,970 --> 00:44:42,380
variable has not been used anywhere yet

00:44:39,950 --> 00:44:43,550
eventually I'll populate this hash but

00:44:42,380 --> 00:44:46,070
at the moment it hasn't been used

00:44:43,550 --> 00:44:47,750
anywhere and having installed all those

00:44:46,070 --> 00:44:51,200
declarations which I found in the

00:44:47,750 --> 00:44:53,420
previous statement then I reset the list

00:44:51,200 --> 00:44:55,099
of declarations to nothing cause I want

00:44:53,420 --> 00:44:57,950
to install them a second time they've

00:44:55,099 --> 00:45:00,050
already been dealt with and likewise if

00:44:57,950 --> 00:45:01,430
I'm clearing a pending declaration that

00:45:00,050 --> 00:45:03,500
I'm not going to do any of that

00:45:01,430 --> 00:45:05,540
installation I'm simply going to clear

00:45:03,500 --> 00:45:12,260
them out because apparently they weren't

00:45:05,540 --> 00:45:15,140
correct and then for

00:45:12,260 --> 00:45:18,290
kind of construct that has the potential

00:45:15,140 --> 00:45:21,110
for declaring or using variables I need

00:45:18,290 --> 00:45:23,360
to track those variables in that

00:45:21,110 --> 00:45:24,920
construct using the similar sort of

00:45:23,360 --> 00:45:27,620
technique the block is the simplest

00:45:24,920 --> 00:45:30,380
example but control blocks are a little

00:45:27,620 --> 00:45:32,240
bit more syntactically sophisticated so

00:45:30,380 --> 00:45:34,640
once again I'm going to always push a

00:45:32,240 --> 00:45:37,010
new scope on anytime I'm considering

00:45:34,640 --> 00:45:39,050
some kind of control block and then I'm

00:45:37,010 --> 00:45:42,110
going to pass the keyword in this case

00:45:39,050 --> 00:45:44,480
if or unless but I'm not going to

00:45:42,110 --> 00:45:48,260
install the declarations that might

00:45:44,480 --> 00:45:50,390
occur inside the parentheses list so the

00:45:48,260 --> 00:45:53,510
parentheses list might have declarations

00:45:50,390 --> 00:45:56,360
but it might also refer to variables

00:45:53,510 --> 00:45:58,100
that are from the outer scope remember

00:45:56,360 --> 00:45:59,990
the declarations that might occur in the

00:45:58,100 --> 00:46:02,540
parentheses list don't actually come

00:45:59,990 --> 00:46:05,120
into effect until we get to the block so

00:46:02,540 --> 00:46:08,780
we pass that parentheses list as if it

00:46:05,120 --> 00:46:11,810
were in the outer scope and then we

00:46:08,780 --> 00:46:13,940
install the declarations just before we

00:46:11,810 --> 00:46:16,580
go into the block we go into the block

00:46:13,940 --> 00:46:17,870
match the block and then we pop the

00:46:16,580 --> 00:46:20,000
scope that we pushed at the very

00:46:17,870 --> 00:46:21,650
beginning of the process and of course

00:46:20,000 --> 00:46:23,660
having done that successfully for an

00:46:21,650 --> 00:46:25,820
if-then what might also be an else--if

00:46:23,660 --> 00:46:30,560
which will require exactly the same

00:46:25,820 --> 00:46:33,170
sequence of operations same thing for a

00:46:30,560 --> 00:46:35,090
for loop we have a for loop then

00:46:33,170 --> 00:46:37,760
immediately after the for loops keyword

00:46:35,090 --> 00:46:39,860
we have to allow for declarations

00:46:37,760 --> 00:46:41,870
because that's the syntax you say for

00:46:39,860 --> 00:46:44,780
you say either name of the iterator and

00:46:41,870 --> 00:46:48,260
the name of that iterator might have a

00:46:44,780 --> 00:46:50,570
explicit declara de on it or it might be

00:46:48,260 --> 00:46:52,790
implicitly declared but in either case

00:46:50,570 --> 00:46:53,530
we need to record it as the declaration

00:46:52,790 --> 00:46:56,630
of a variable

00:46:53,530 --> 00:46:59,150
so once we've been through that part of

00:46:56,630 --> 00:47:02,680
the code we can then say okay I'm going

00:46:59,150 --> 00:47:05,060
to record the fact that I had this

00:47:02,680 --> 00:47:07,040
declaration in that point and I'm going

00:47:05,060 --> 00:47:09,680
to stop allowing declarations at that

00:47:07,040 --> 00:47:12,740
point because I'm not yet in its actual

00:47:09,680 --> 00:47:15,460
scope so I have this subroutine that

00:47:12,740 --> 00:47:17,900
just says okay I can turn on and off

00:47:15,460 --> 00:47:22,840
declarations by setting a flag in the

00:47:17,900 --> 00:47:25,640
current scope or I can at the end of

00:47:22,840 --> 00:47:27,019
those declarations I can recall the

00:47:25,640 --> 00:47:28,910
that I had a declaration without

00:47:27,019 --> 00:47:32,990
actually installing it so I'm going to

00:47:28,910 --> 00:47:37,339
say for each declaration that has been

00:47:32,990 --> 00:47:40,220
found in the current scope unpack all

00:47:37,339 --> 00:47:44,089
the information about it and record that

00:47:40,220 --> 00:47:49,069
information but don't yet put it into

00:47:44,089 --> 00:47:51,589
the stack frame and the reason I can't

00:47:49,069 --> 00:47:53,839
you put it into the stack frame is that

00:47:51,589 --> 00:47:56,599
in a full loop or any other kind of loop

00:47:53,839 --> 00:47:58,849
I still have the parentheses list to

00:47:56,599 --> 00:48:02,180
follow and that parentheses list as we

00:47:58,849 --> 00:48:05,000
saw earlier isn't in the scope of the

00:48:02,180 --> 00:48:08,630
iterator variable so I have to pass that

00:48:05,000 --> 00:48:11,480
as if it were in the outer scope before

00:48:08,630 --> 00:48:14,059
I try and install any variables and the

00:48:11,480 --> 00:48:16,970
same thing is true for a while or an

00:48:14,059 --> 00:48:19,579
until as soon as you've seen the keyword

00:48:16,970 --> 00:48:21,980
then you can have declarations in the

00:48:19,579 --> 00:48:24,319
parentheses list but you want to record

00:48:21,980 --> 00:48:26,359
those declarations and not install them

00:48:24,319 --> 00:48:29,390
until the parentheses list is finished

00:48:26,359 --> 00:48:31,009
and then for either kind of loop once

00:48:29,390 --> 00:48:33,829
we've finished going through the

00:48:31,009 --> 00:48:36,769
parentheses then and only then we can

00:48:33,829 --> 00:48:45,010
install those declarations before

00:48:36,769 --> 00:48:47,050
passing the block it's very

00:48:45,010 --> 00:48:49,900
for subroutine declarations we push a

00:48:47,050 --> 00:48:51,790
scope around it we parse the keywords

00:48:49,900 --> 00:48:54,940
which can sometimes not have the keyword

00:48:51,790 --> 00:48:56,950
sub in front of them and then we say

00:48:54,940 --> 00:48:59,110
okay after that we've got a spot where

00:48:56,950 --> 00:49:01,420
we could have a parameter list which is

00:48:59,110 --> 00:49:04,120
an implicit set of declarations so we

00:49:01,420 --> 00:49:07,330
allow declarations in that point we pass

00:49:04,120 --> 00:49:10,510
the parameter list we record the

00:49:07,330 --> 00:49:13,120
declarations we pass anything else that

00:49:10,510 --> 00:49:14,830
might be before the block and then just

00:49:13,120 --> 00:49:18,090
before the block we install those

00:49:14,830 --> 00:49:21,160
declarations pause the block again and

00:49:18,090 --> 00:49:22,870
then pop the scope or if we fail at some

00:49:21,160 --> 00:49:25,420
point we revert the scope to keep the

00:49:22,870 --> 00:49:29,440
stack consistent same for non immersive

00:49:25,420 --> 00:49:33,340
routines for variable declarations we

00:49:29,440 --> 00:49:35,920
match the declara de at that point we're

00:49:33,340 --> 00:49:38,470
allowed to have a declaration so we look

00:49:35,920 --> 00:49:40,330
for some kind of Perl l value and we

00:49:38,470 --> 00:49:43,060
can't just put a variable at this point

00:49:40,330 --> 00:49:44,650
because a variable declaration can

00:49:43,060 --> 00:49:47,410
sometimes have parentheses around it

00:49:44,650 --> 00:49:49,090
it's quite complicated but once we found

00:49:47,410 --> 00:49:51,700
all the variables that are being

00:49:49,090 --> 00:49:54,040
declared by this declara de we record

00:49:51,700 --> 00:49:56,560
them and then disallow the declarations

00:49:54,040 --> 00:49:58,390
and what is their l value look like well

00:49:56,560 --> 00:50:02,340
it's the thing that's actually finally

00:49:58,390 --> 00:50:05,710
going to start saving variables for us

00:50:02,340 --> 00:50:08,500
so it might just be a sigil followed by

00:50:05,710 --> 00:50:10,480
an identifier or it might be a list of

00:50:08,500 --> 00:50:13,690
comma-separated sigils followed by

00:50:10,480 --> 00:50:17,070
identifiers and however i find the

00:50:13,690 --> 00:50:21,430
variable i then save that variable and

00:50:17,070 --> 00:50:24,100
likewise for simple our value uses of it

00:50:21,430 --> 00:50:26,680
for for uses of a scalar or an array or

00:50:24,100 --> 00:50:29,620
a hash i just pass it in the standard

00:50:26,680 --> 00:50:32,140
sort of way and then save the variable

00:50:29,620 --> 00:50:34,990
into the current stack frame for the

00:50:32,140 --> 00:50:37,240
scope and what does that mean well when

00:50:34,990 --> 00:50:39,520
I'm saving a variable I have to put it

00:50:37,240 --> 00:50:41,920
in one of two places if it's the

00:50:39,520 --> 00:50:44,020
Declaration of the variable I needed in

00:50:41,920 --> 00:50:46,180
one place if it's a use of the variable

00:50:44,020 --> 00:50:47,880
I need somewhere else so the first thing

00:50:46,180 --> 00:50:51,640
we do is we extract the information

00:50:47,880 --> 00:50:54,610
namely the name and the location of the

00:50:51,640 --> 00:50:57,540
variable that we just passed correctly

00:50:54,610 --> 00:50:58,970
and if we are in a context that allows

00:50:57,540 --> 00:51:01,400
declaration

00:50:58,970 --> 00:51:02,660
then we take that information and shove

00:51:01,400 --> 00:51:06,140
it straight into the list of

00:51:02,660 --> 00:51:10,190
declarations for the bottom stack frame

00:51:06,140 --> 00:51:12,230
of the scope on the other hand if we're

00:51:10,190 --> 00:51:14,420
not somewhere that allows declarations

00:51:12,230 --> 00:51:16,400
then this must best be a simple usage of

00:51:14,420 --> 00:51:18,920
the variable so we have a quite a lot of

00:51:16,400 --> 00:51:20,450
code here that normalize with the

00:51:18,920 --> 00:51:23,119
variable back to its name because the

00:51:20,450 --> 00:51:25,220
variable might be an array lookup or a

00:51:23,119 --> 00:51:27,700
hash lookup and it might have a dollar

00:51:25,220 --> 00:51:31,749
sign sigil instead of its true sigil of

00:51:27,700 --> 00:51:35,239
at sign or percentage so we need to

00:51:31,749 --> 00:51:39,200
normalize it back to that standard

00:51:35,239 --> 00:51:43,630
format before we record its usage within

00:51:39,200 --> 00:51:43,630
this scope at this location

00:51:43,749 --> 00:51:49,880
so once we've gone through and saved

00:51:46,519 --> 00:51:52,029
every variable then we can install the

00:51:49,880 --> 00:51:55,579
declarations that we have encountered

00:51:52,029 --> 00:51:57,739
into each scope maintaining the scope by

00:51:55,579 --> 00:52:01,489
pushing and popping all the way up and

00:51:57,739 --> 00:52:04,700
down and then everything else that

00:52:01,489 --> 00:52:07,460
parses the Perl code here is provided by

00:52:04,700 --> 00:52:09,499
PBR grammar it does all of the hard work

00:52:07,460 --> 00:52:14,119
for us it's another two thousand lines

00:52:09,499 --> 00:52:17,660
of regex doing that work for us and once

00:52:14,119 --> 00:52:20,869
we have that long complicated regular

00:52:17,660 --> 00:52:23,599
expression that is able to track the

00:52:20,869 --> 00:52:26,829
Declaration and use of variables for us

00:52:23,599 --> 00:52:30,650
then writing the actual subroutine that

00:52:26,829 --> 00:52:34,549
classifies variables for us really is

00:52:30,650 --> 00:52:37,579
quite simple we set up the stack and the

00:52:34,549 --> 00:52:40,759
various tables as localized package

00:52:37,579 --> 00:52:43,609
variables we then pass the source code

00:52:40,759 --> 00:52:45,619
with that reg X and you'll notice that

00:52:43,609 --> 00:52:47,720
I've used the O flag here for one of the

00:52:45,619 --> 00:52:50,650
very few times in my pearl career I

00:52:47,720 --> 00:52:53,779
found that here the O flag actually

00:52:50,650 --> 00:52:55,670
causes the regex to run about 400

00:52:53,779 --> 00:52:58,400
percent faster so it was definitely

00:52:55,670 --> 00:53:01,130
worth doing and having passed the source

00:52:58,400 --> 00:53:04,489
code and extracted all that information

00:53:01,130 --> 00:53:07,130
into those tables then we can go through

00:53:04,489 --> 00:53:09,859
the table and for each variable that we

00:53:07,130 --> 00:53:11,810
encountered we can augment it with extra

00:53:09,859 --> 00:53:13,730
information so we can check

00:53:11,810 --> 00:53:16,370
it's one of the built-in pearl variables

00:53:13,730 --> 00:53:19,940
and add in description and aliases for

00:53:16,370 --> 00:53:22,100
those variables we can find out whether

00:53:19,940 --> 00:53:24,890
it's one of these bad words because I've

00:53:22,100 --> 00:53:26,810
written a pattern that does that and if

00:53:24,890 --> 00:53:28,700
it is we can mark it as being an

00:53:26,810 --> 00:53:30,530
inappropriate name for something and

00:53:28,700 --> 00:53:32,330
then we can go through and look for all

00:53:30,530 --> 00:53:35,300
the variables that have either exactly

00:53:32,330 --> 00:53:38,300
the same name or a very similar name and

00:53:35,300 --> 00:53:41,030
record those as well and finally we can

00:53:38,300 --> 00:53:43,760
get some sense of how large the scope is

00:53:41,030 --> 00:53:46,700
so I can color code my scope bars simply

00:53:43,760 --> 00:53:48,200
by saying well subtract the place where

00:53:46,700 --> 00:53:49,910
it's declared from the place where it

00:53:48,200 --> 00:53:51,800
goes out of scope and divide that by the

00:53:49,910 --> 00:53:53,630
total length of the source and then we

00:53:51,800 --> 00:53:56,440
get a value between 0 and 1 that

00:53:53,630 --> 00:54:01,010
indicates how much of the source code is

00:53:56,440 --> 00:54:04,040
this variable in scope for and having

00:54:01,010 --> 00:54:09,530
taken all that information I then just

00:54:04,040 --> 00:54:12,680
return it in one big hash and that big

00:54:09,530 --> 00:54:14,450
hash really is a very big hash because

00:54:12,680 --> 00:54:17,000
there are a lot of variables and each of

00:54:14,450 --> 00:54:19,040
them has a lot of information so if we

00:54:17,000 --> 00:54:21,200
zoom in and have a look at that

00:54:19,040 --> 00:54:24,170
information the first thing we see is

00:54:21,200 --> 00:54:27,620
yes it's telling me ah this code claimed

00:54:24,170 --> 00:54:30,590
that it required version 530 so I can

00:54:27,620 --> 00:54:33,140
use that later on to choose the right

00:54:30,590 --> 00:54:35,960
way to implement refactoring but the

00:54:33,140 --> 00:54:39,470
vast majority of this data structure is

00:54:35,960 --> 00:54:42,380
just a table of all the variables that

00:54:39,470 --> 00:54:45,560
were encountered in the source code each

00:54:42,380 --> 00:54:47,870
of them is indexed by their position in

00:54:45,560 --> 00:54:50,600
the source code and each of them

00:54:47,870 --> 00:54:54,560
provides all of that information that I

00:54:50,600 --> 00:54:57,770
managed to extract or analyze within the

00:54:54,560 --> 00:54:59,720
regex or within the subroutine so for

00:54:57,770 --> 00:55:02,300
example all information about the name

00:54:59,720 --> 00:55:04,970
and description of the variable

00:55:02,300 --> 00:55:08,690
information about what kind of variable

00:55:04,970 --> 00:55:10,760
it is and what scope it exists in the

00:55:08,690 --> 00:55:14,570
analysis information does it have a bad

00:55:10,760 --> 00:55:17,360
name is it built in and of course a

00:55:14,570 --> 00:55:20,590
complete list of every location where

00:55:17,360 --> 00:55:20,590
the variable is used

00:55:23,950 --> 00:55:29,770
and then the rest of the module uses all

00:55:27,400 --> 00:55:33,579
of that information extracted by that

00:55:29,770 --> 00:55:35,920
one subroutine to implement the lexical

00:55:33,579 --> 00:55:37,750
hoisting of expressions or the

00:55:35,920 --> 00:55:41,460
refactoring into sub routines or

00:55:37,750 --> 00:55:43,990
closures or the code quality analysis or

00:55:41,460 --> 00:55:47,320
simply to track individual variables

00:55:43,990 --> 00:55:49,540
when you put the cursor over them so

00:55:47,320 --> 00:55:52,180
that's the code art module it's

00:55:49,540 --> 00:55:55,240
available now on Sipan and even if you

00:55:52,180 --> 00:55:57,250
never want to use vim to edit Perl it's

00:55:55,240 --> 00:56:01,890
worth having a look at the source code

00:55:57,250 --> 00:56:04,839
of that to see how it does this thing

00:56:01,890 --> 00:56:06,730
now I'm not saying that it's perfect in

00:56:04,839 --> 00:56:08,560
fact it's still pretty much alpha

00:56:06,730 --> 00:56:11,470
there's still a lot of things that I

00:56:08,560 --> 00:56:14,200
want to add to it the refactoring that

00:56:11,470 --> 00:56:16,780
it does is fairly smart but it could be

00:56:14,200 --> 00:56:18,579
smarter it doesn't for example

00:56:16,780 --> 00:56:20,950
understand the scoping of dollar

00:56:18,579 --> 00:56:23,859
underscore properly and I need to get it

00:56:20,950 --> 00:56:25,390
to do that right I also wanted to

00:56:23,859 --> 00:56:27,520
understand the scoping of subroutines

00:56:25,390 --> 00:56:29,530
not just lexical subroutines

00:56:27,520 --> 00:56:31,480
but package subroutines as well and I

00:56:29,530 --> 00:56:34,060
need to understand that scoping because

00:56:31,480 --> 00:56:37,210
I want to be able to rename subroutines

00:56:34,060 --> 00:56:39,700
just as easily in their lexical or

00:56:37,210 --> 00:56:41,829
package scope and I want to be able to

00:56:39,700 --> 00:56:43,270
do the opposite of refactoring in that I

00:56:41,829 --> 00:56:46,420
want to be able to take a subroutine

00:56:43,270 --> 00:56:51,310
call and inline the actual subroutine

00:56:46,420 --> 00:56:53,200
code in place of that call I also want

00:56:51,310 --> 00:56:56,260
to be able to say okay here's a

00:56:53,200 --> 00:56:58,900
subroutine I want to add a parameter to

00:56:56,260 --> 00:57:01,810
it or remove a parameter from it or just

00:56:58,900 --> 00:57:05,050
change the name or the order of one or

00:57:01,810 --> 00:57:07,000
more parameters and I'd like that then

00:57:05,050 --> 00:57:09,160
to be able to go through the rest of the

00:57:07,000 --> 00:57:11,650
code and find all the calls and

00:57:09,160 --> 00:57:15,490
rearrange their argument lists in the

00:57:11,650 --> 00:57:20,040
same kind of way and I want all of those

00:57:15,490 --> 00:57:23,980
features integrated right into them and

00:57:20,040 --> 00:57:27,339
not just for Perl I'd also like to be

00:57:23,980 --> 00:57:32,290
able to do that for our cout code that

00:57:27,339 --> 00:57:34,780
I'm editing in vim and I think writing

00:57:32,290 --> 00:57:37,730
the rocku version of code art is going

00:57:34,780 --> 00:57:39,410
to be a really interesting exercise

00:57:37,730 --> 00:57:42,680
I think it's going to be at least three

00:57:39,410 --> 00:57:44,510
times harder because rocku as a language

00:57:42,680 --> 00:57:48,050
is at least three times bigger than

00:57:44,510 --> 00:57:50,150
Pearl but I also think it's probably

00:57:48,050 --> 00:57:53,020
going to be about three times easier

00:57:50,150 --> 00:57:56,359
than writing code art for Pearl was

00:57:53,020 --> 00:57:59,150
simply because Roku has proper grammars

00:57:56,359 --> 00:58:03,310
I'm not going to have to write large

00:57:59,150 --> 00:58:06,230
regular expressions with weird kind of

00:58:03,310 --> 00:58:08,570
call-outs in them to interrupt the

00:58:06,230 --> 00:58:11,450
parsing of the whole document and do

00:58:08,570 --> 00:58:14,030
something with it I can just pass a raku

00:58:11,450 --> 00:58:16,280
document directly to a grammar and have

00:58:14,030 --> 00:58:19,490
it return a data structure that

00:58:16,280 --> 00:58:21,740
represents the entire scope and usage of

00:58:19,490 --> 00:58:24,230
variables and the reason I can do that

00:58:21,740 --> 00:58:26,660
is that Raikou already has one grammar

00:58:24,230 --> 00:58:29,030
built into it and that's its own grammar

00:58:26,660 --> 00:58:31,369
the raku grammar so I can just hook

00:58:29,030 --> 00:58:34,340
straight into that and immediately get

00:58:31,369 --> 00:58:36,950
back an entire pass tree for any source

00:58:34,340 --> 00:58:38,180
code that I send it and finally the

00:58:36,950 --> 00:58:41,990
reason I think it's going to be easier

00:58:38,180 --> 00:58:44,650
is frankly Rocko's grammar is quite a

00:58:41,990 --> 00:58:47,000
bit saner than the perl grammar and

00:58:44,650 --> 00:58:50,090
quite a bit more regular so it's going

00:58:47,000 --> 00:58:53,000
to be easier to walk through that pass

00:58:50,090 --> 00:58:55,850
tree and detect the various components

00:58:53,000 --> 00:58:58,700
that I want to rename or refactor or

00:58:55,850 --> 00:59:00,560
even just highlight so I'm really

00:58:58,700 --> 00:59:04,300
looking forward to building the raku

00:59:00,560 --> 00:59:07,960
version of this module because after all

00:59:04,300 --> 00:59:07,960
now how could it be

00:59:17,940 --> 00:59:29,310
and we're back live I hope you enjoyed

00:59:21,810 --> 00:59:32,520
that or at least survived that and are

00:59:29,310 --> 00:59:35,010
there any questions some hard questions

00:59:32,520 --> 00:59:38,400
for me Todd could you possibly do that

00:59:35,010 --> 00:59:40,800
for me sure I think I'm going to start

00:59:38,400 --> 00:59:46,069
with the audience would like to thank

00:59:40,800 --> 00:59:46,069
Ovid for causing all of this to happen

00:59:46,520 --> 00:59:54,900
I think I need to change some settings

00:59:51,869 --> 00:59:57,210
hold on one second okay okay I'm gonna

00:59:54,900 --> 00:59:58,770
allow you guys to unmute yourself but

00:59:57,210 --> 01:00:19,770
we're still going to go with raised

00:59:58,770 --> 01:00:24,480
hands thank you appreciate your

01:00:19,770 --> 01:00:28,950
appreciation so I think the first

01:00:24,480 --> 01:00:33,180
question is from Santiago yeah so I was

01:00:28,950 --> 01:00:35,760
I was writing this in to chat I wonder

01:00:33,180 --> 01:00:39,390
what is the performance impact of all of

01:00:35,760 --> 01:00:43,349
this on a model that is a hundred or a

01:00:39,390 --> 01:00:46,079
thousand chosen offline lines long since

01:00:43,349 --> 01:00:48,329
I'm not so first with beams on how

01:00:46,079 --> 01:00:51,150
extensions work I guess it parses the

01:00:48,329 --> 01:00:54,510
whole document and then otherwise how

01:00:51,150 --> 01:00:55,980
can you boys do some stuff yeah it

01:00:54,510 --> 01:00:58,770
absolutely has to pass the whole

01:00:55,980 --> 01:01:01,680
document in every case because it needs

01:00:58,770 --> 01:01:05,760
to know which variables are in and out

01:01:01,680 --> 01:01:08,099
of scope but more more than just that it

01:01:05,760 --> 01:01:10,020
also needs to know the context of what

01:01:08,099 --> 01:01:12,180
you're actually refactoring a lot of the

01:01:10,020 --> 01:01:15,300
smartness that it has in refactoring is

01:01:12,180 --> 01:01:18,119
it looks ahead and looks behind so that

01:01:15,300 --> 01:01:22,619
it can see what context you're doing

01:01:18,119 --> 01:01:27,240
this in for example if you have a series

01:01:22,619 --> 01:01:30,119
of map correct map sort it cetera in a

01:01:27,240 --> 01:01:31,750
functional style of pearl coding if you

01:01:30,119 --> 01:01:34,480
pull the middle bit out it

01:01:31,750 --> 01:01:37,390
refactor it in such a way that it still

01:01:34,480 --> 01:01:39,850
passes the remaining arguments in as

01:01:37,390 --> 01:01:44,560
well so it's got to pass the whole

01:01:39,850 --> 01:01:46,750
document every time that's why I'm

01:01:44,560 --> 01:01:50,860
working on making it as asynchronous as

01:01:46,750 --> 01:01:53,680
possible for code that's hundreds of

01:01:50,860 --> 01:01:56,350
lines long it's still perfectly fine for

01:01:53,680 --> 01:01:59,980
code that's thousands of lines long it

01:01:56,350 --> 01:02:02,710
starts getting a little bit slow so I

01:01:59,980 --> 01:02:04,960
want to improve that and just this

01:02:02,710 --> 01:02:06,630
morning I got up early so I'd be ready

01:02:04,960 --> 01:02:12,490
for the talk and I had an idea and

01:02:06,630 --> 01:02:15,760
started recoding the module already so

01:02:12,490 --> 01:02:17,050
that more of it becomes asynchronous one

01:02:15,760 --> 01:02:19,420
of the things you may have noticed is

01:02:17,050 --> 01:02:24,390
there's a slight delay when you put the

01:02:19,420 --> 01:02:26,770
cursor onto a variable before in fact it

01:02:24,390 --> 01:02:28,870
highlights that variable and usually

01:02:26,770 --> 01:02:32,290
information about it now part of that

01:02:28,870 --> 01:02:34,210
delay is just me not wanting them to be

01:02:32,290 --> 01:02:36,430
constantly sending off these Perl

01:02:34,210 --> 01:02:38,590
requests so I deliberately delay it a

01:02:36,430 --> 01:02:41,350
little bit but what I'd like to be able

01:02:38,590 --> 01:02:43,150
to do is to hook into the analytics that

01:02:41,350 --> 01:02:45,400
it does for all the other stuff like the

01:02:43,150 --> 01:02:46,270
Hama grams and the caki grams and the

01:02:45,400 --> 01:02:49,180
peregrines

01:02:46,270 --> 01:02:51,070
and because I've already got the

01:02:49,180 --> 01:02:53,530
information about all the variables in

01:02:51,070 --> 01:02:55,840
that information that's coming back to

01:02:53,530 --> 01:02:58,600
the overall analysis so this morning I

01:02:55,840 --> 01:03:01,750
changed it so that now as soon as you go

01:02:58,600 --> 01:03:03,490
on to a variable it immediately just

01:03:01,750 --> 01:03:07,090
looks up the information that it already

01:03:03,490 --> 01:03:09,130
has and returns that at once so that's

01:03:07,090 --> 01:03:11,520
going to solve some of the problem the

01:03:09,130 --> 01:03:16,180
only time now that it's going to have to

01:03:11,520 --> 01:03:19,000
re-evaluate re pars and restructure is

01:03:16,180 --> 01:03:20,740
when you actually change the code so I

01:03:19,000 --> 01:03:22,660
think that's going to deal with a lot of

01:03:20,740 --> 01:03:24,280
the problems the other issue here is

01:03:22,660 --> 01:03:26,880
that the very much depends on which

01:03:24,280 --> 01:03:29,830
version of Perl you're running under and

01:03:26,880 --> 01:03:32,410
sadly the more recent the version of

01:03:29,830 --> 01:03:37,210
Perl the slower the regex engine

01:03:32,410 --> 01:03:43,360
actually runs so the when I run this

01:03:37,210 --> 01:03:45,820
under Perl 516 and Perl 518 then the

01:03:43,360 --> 01:03:47,320
timing tests that I do

01:03:45,820 --> 01:03:51,220
they're quite a few of them take about

01:03:47,320 --> 01:03:54,580
four seconds when I run it under 522 and

01:03:51,220 --> 01:03:56,650
later they take about 20 seconds so it's

01:03:54,580 --> 01:04:00,490
going to depend on which version of Perl

01:03:56,650 --> 01:04:02,380
you're using to actually do this but

01:04:00,490 --> 01:04:04,180
everything I've been working on here has

01:04:02,380 --> 01:04:06,040
been trying to make this faster and

01:04:04,180 --> 01:04:09,760
surprisingly because it's really just

01:04:06,040 --> 01:04:12,310
doing a single regex match followed by a

01:04:09,760 --> 01:04:14,650
little bit of processing it's not as

01:04:12,310 --> 01:04:19,330
slow as you might expect except when the

01:04:14,650 --> 01:04:24,010
source code gets extremely large so I'm

01:04:19,330 --> 01:04:25,930
using it in real code in my other

01:04:24,010 --> 01:04:28,870
modules I'm using it for highlighting

01:04:25,930 --> 01:04:31,960
and for analysis and so forth and in

01:04:28,870 --> 01:04:33,280
most cases I find it fairly reasonable

01:04:31,960 --> 01:04:35,380
the one that it doesn't work very well

01:04:33,280 --> 01:04:37,780
for well there are two the first one it

01:04:35,380 --> 01:04:41,020
doesn't work very well for is the code

01:04:37,780 --> 01:04:42,820
art module because every time you change

01:04:41,020 --> 01:04:45,310
the source code it breaks the entire

01:04:42,820 --> 01:04:47,710
system and the other one it doesn't work

01:04:45,310 --> 01:04:51,010
very well for is PPR because PPR is

01:04:47,710 --> 01:04:53,050
itself just one huge regular expression

01:04:51,010 --> 01:04:54,670
so there's a kind of a recursive problem

01:04:53,050 --> 01:04:56,800
there but as long as you're not editing

01:04:54,670 --> 01:04:59,020
those two it's going to be reasonable

01:04:56,800 --> 01:05:01,030
this talk this question answer session

01:04:59,020 --> 01:05:02,680
is going to go like forever because

01:05:01,030 --> 01:05:10,650
whenever I answer a question it's

01:05:02,680 --> 01:05:10,650
another talk sorry okay thanks Alvin oh

01:05:13,020 --> 01:05:19,630
can you hear me

01:05:14,620 --> 01:05:21,750
yes I can't hear you okay so first of

01:05:19,630 --> 01:05:24,670
all I want to apologize to everyone for

01:05:21,750 --> 01:05:27,760
the butterfly effect of me asking a

01:05:24,670 --> 01:05:31,900
simple question and Damien providing a

01:05:27,760 --> 01:05:35,560
complete answer so that's a little bit

01:05:31,900 --> 01:05:39,040
awkward there this might be jumping the

01:05:35,560 --> 01:05:41,170
gun I'm not sure I don't know it's just

01:05:39,040 --> 01:05:43,150
discussed but one of the things that

01:05:41,170 --> 01:05:45,880
Sawyer is working on was use Perl

01:05:43,150 --> 01:05:49,000
standard which is not something that is

01:05:45,880 --> 01:05:53,320
intended to be enforced upon anyone but

01:05:49,000 --> 01:05:57,310
it is a a small subset of the Perl

01:05:53,320 --> 01:05:59,500
language which is mostly what everyone

01:05:57,310 --> 01:06:02,170
does there's nothing new

01:05:59,500 --> 01:06:05,490
about it it just removes a few tiny

01:06:02,170 --> 01:06:08,710
things the big one being here docks that

01:06:05,490 --> 01:06:11,770
if you remove those things that you have

01:06:08,710 --> 01:06:14,290
a subset of pearl that is almost

01:06:11,770 --> 01:06:17,020
entirely everything that we use with

01:06:14,290 --> 01:06:20,440
pearls but could be partially be enough

01:06:17,020 --> 01:06:25,420
grammar and as a result the work that

01:06:20,440 --> 01:06:27,310
gabion does could be applied to pro/5

01:06:25,420 --> 01:06:29,860
today in a much more performant manner

01:06:27,310 --> 01:06:32,650
in a much more interesting manner that

01:06:29,860 --> 01:06:36,700
gives us power that we have never had

01:06:32,650 --> 01:06:38,830
today so a lot of what he is working

01:06:36,700 --> 01:06:43,390
around today is in fact the programmer

01:06:38,830 --> 01:06:45,850
is fairly freewheeling and it's very

01:06:43,390 --> 01:06:48,910
difficult to deal with but if use

01:06:45,850 --> 01:06:52,090
features standard gets adopted more

01:06:48,910 --> 01:06:54,180
widely it's not that it takes anything

01:06:52,090 --> 01:06:57,550
away from you because you don't have to

01:06:54,180 --> 01:06:59,770
follow that but the documentation for

01:06:57,550 --> 01:07:01,750
Pearl will follow those standard

01:06:59,770 --> 01:07:05,590
features it will follow features that

01:07:01,750 --> 01:07:07,870
follow a BNF grammar that is very easy

01:07:05,590 --> 01:07:10,540
to understand very used to parse very

01:07:07,870 --> 01:07:13,750
easy for a human to read and understand

01:07:10,540 --> 01:07:15,820
and will make it much much easier and

01:07:13,750 --> 01:07:19,510
faster for gaming it's work to be

01:07:15,820 --> 01:07:21,850
applied in editor tools so we have today

01:07:19,510 --> 01:07:26,260
which means it's not just BIM it's also

01:07:21,850 --> 01:07:28,750
Emacs it's also you know I still

01:07:26,260 --> 01:07:29,920
remember one of my one of my bosses when

01:07:28,750 --> 01:07:33,850
I worked for booking.com

01:07:29,920 --> 01:07:37,450
was using what's that editor for Java

01:07:33,850 --> 01:07:38,590
that's used all the time I'm struggling

01:07:37,450 --> 01:07:41,290
grew up with the name and I can't

01:07:38,590 --> 01:07:43,630
remember it now but basically it was dog

01:07:41,290 --> 01:07:45,370
slow when he when ever wanted to try

01:07:43,630 --> 01:07:51,210
anything because of the difficulty of

01:07:45,370 --> 01:07:59,290
parsing from so I first of all Damien

01:07:51,210 --> 01:08:02,980
holy what you did was amazing but

01:07:59,290 --> 01:08:04,930
if people are willing to accept a few

01:08:02,980 --> 01:08:07,390
minor modifications look for a language

01:08:04,930 --> 01:08:10,540
and won't make it tremendously easy to

01:08:07,390 --> 01:08:12,940
do what you've done and so all of us

01:08:10,540 --> 01:08:17,130
will have an easier way of being

01:08:12,940 --> 01:08:17,130
on board that I really afford to that

01:08:17,230 --> 01:08:25,900
well I reviewed sorry it's guacamole

01:08:23,380 --> 01:08:27,220
talk this morning when I got up I didn't

01:08:25,900 --> 01:08:30,960
watch it live because it was on at like

01:08:27,220 --> 01:08:34,210
4 a.m. for me and that's just too early

01:08:30,960 --> 01:08:37,090
it's awesome work there too I'm sure

01:08:34,210 --> 01:08:39,850
that because the plaza is marpa based

01:08:37,090 --> 01:08:43,600
it's going to be much faster and I agree

01:08:39,850 --> 01:08:45,850
if you are willing to work within the

01:08:43,600 --> 01:08:48,790
limitations and if you can you have a

01:08:45,850 --> 01:08:51,130
code base that isn't littered with tens

01:08:48,790 --> 01:08:53,410
of thousands of lines of Perl code that

01:08:51,130 --> 01:08:57,130
has features that standard Perl just

01:08:53,410 --> 01:09:00,000
won't pass then yeah absolutely and I it

01:08:57,130 --> 01:09:03,400
would be great to look at can we hook

01:09:00,000 --> 01:09:05,970
some of that pausing technology into

01:09:03,400 --> 01:09:08,050
this to handle those cases and

01:09:05,970 --> 01:09:10,420
presumably we could because it could

01:09:08,050 --> 01:09:12,490
first try to pass it using the standard

01:09:10,420 --> 01:09:14,590
Perl parser and if that fails it could

01:09:12,490 --> 01:09:16,330
just fall back on the full Perl powers

01:09:14,590 --> 01:09:19,780
so then you might get the best of both

01:09:16,330 --> 01:09:21,520
worlds but my view was I've got a lot of

01:09:19,780 --> 01:09:24,010
old code a lot of people have got a lot

01:09:21,520 --> 01:09:26,680
of old code and that old code has things

01:09:24,010 --> 01:09:30,520
that standard Perl will never and should

01:09:26,680 --> 01:09:35,530
never handle and yet why should those

01:09:30,520 --> 01:09:37,450
people be disenfranchised from using

01:09:35,530 --> 01:09:40,240
these kinds of tools and you know I

01:09:37,450 --> 01:09:44,200
write these things predominantly for

01:09:40,240 --> 01:09:45,730
myself and my code goes back to decades

01:09:44,200 --> 01:09:47,860
and it's got a lot of stuff that I'm

01:09:45,730 --> 01:09:50,320
never going to port it to a standard

01:09:47,860 --> 01:09:52,630
Perl implementation so I wanted to be

01:09:50,320 --> 01:09:54,790
possible everywhere and I actually don't

01:09:52,630 --> 01:09:57,580
think the performance is too terrible at

01:09:54,790 --> 01:10:00,160
the moment one of the the next things

01:09:57,580 --> 01:10:04,630
that I've got on my list is to change

01:10:00,160 --> 01:10:07,720
PPR so that it doesn't just pass full

01:10:04,630 --> 01:10:13,270
Perl but it also returns a proper syntax

01:10:07,720 --> 01:10:17,140
tree so kind of cross it with my regex

01:10:13,270 --> 01:10:22,390
grammars module so that you get back a

01:10:17,140 --> 01:10:26,230
very much a go komali like abstract

01:10:22,390 --> 01:10:29,290
syntax tree with proper no no

01:10:26,230 --> 01:10:31,030
patient's on every node and with good

01:10:29,290 --> 01:10:34,570
detail which you don't always get from

01:10:31,030 --> 01:10:36,880
PPI but which still runs reasonably fast

01:10:34,570 --> 01:10:39,610
because it's mostly regex based and

01:10:36,880 --> 01:10:41,200
you've basically today seeing the

01:10:39,610 --> 01:10:45,700
approach that I'll be taking with that

01:10:41,200 --> 01:10:47,140
that if I'm going to make people able to

01:10:45,700 --> 01:10:50,830
return a syntax tree then I'm going to

01:10:47,140 --> 01:10:54,010
have to retain maintain a stack that I

01:10:50,830 --> 01:10:56,290
build the syntax tree out of and the

01:10:54,010 --> 01:10:58,390
techniques that I've shown in today's

01:10:56,290 --> 01:10:59,440
keynote would be the techniques that I

01:10:58,390 --> 01:11:01,540
would use for that as well

01:10:59,440 --> 01:11:04,930
now it'll never be as fast as a map of

01:11:01,540 --> 01:11:09,520
based one but on the other hand if you

01:11:04,930 --> 01:11:12,510
do have any hair docks it handles them

01:11:09,520 --> 01:11:12,510
correctly

01:11:16,530 --> 01:11:25,960
hey next up is Carl hi a couple couple

01:11:23,290 --> 01:11:31,180
things it would be good if you could

01:11:25,960 --> 01:11:37,570
bisect that slowdown in later pearls to

01:11:31,180 --> 01:11:40,180
see what series of commits caused this

01:11:37,570 --> 01:11:43,090
that would be helpful so we could try to

01:11:40,180 --> 01:11:48,489
fix it also the other thing about

01:11:43,090 --> 01:11:53,140
performance was we changed the behavior

01:11:48,489 --> 01:11:55,480
of the old modifier at some point in the

01:11:53,140 --> 01:12:00,130
twenty series so that it should be

01:11:55,480 --> 01:12:02,739
irrelevant to later pearls sure but I'm

01:12:00,130 --> 01:12:06,190
I'm trying to support pearl 16 onwards

01:12:02,739 --> 01:12:09,700
yeah so I wanted to make sure that that

01:12:06,190 --> 01:12:11,650
four hundred percent slowdown wasn't in

01:12:09,700 --> 01:12:13,239
really modern pearls that we actually

01:12:11,650 --> 01:12:16,690
had fixed that or that you had found

01:12:13,239 --> 01:12:18,250
about okay so I mean that's interesting

01:12:16,690 --> 01:12:23,500
that's something I hadn't considered but

01:12:18,250 --> 01:12:26,230
it's interesting that at the kind of 518

01:12:23,500 --> 01:12:28,750
five twenty disconnect which is where

01:12:26,230 --> 01:12:30,580
the most of the changes started coming

01:12:28,750 --> 01:12:33,460
into the regex engine as I understand it

01:12:30,580 --> 01:12:36,190
that's where this slows down so maybe

01:12:33,460 --> 01:12:38,500
that flag is not helping those later

01:12:36,190 --> 01:12:40,180
versions but I think that there are

01:12:38,500 --> 01:12:42,280
other issues

01:12:40,180 --> 01:12:46,210
with the later versions of the regex

01:12:42,280 --> 01:12:48,600
engine in particular the fact that they

01:12:46,210 --> 01:12:51,280
now correctly handle lexical scoping and

01:12:48,600 --> 01:12:53,140
I think that injected some slowdown as

01:12:51,280 --> 01:12:55,360
well and I'd certainly be interested in

01:12:53,140 --> 01:12:58,480
someone bisecting the performance of

01:12:55,360 --> 01:13:01,420
those things but I have an extremely

01:12:58,480 --> 01:13:04,590
strict rule which is I never get

01:13:01,420 --> 01:13:07,210
involved in the implementation and

01:13:04,590 --> 01:13:09,820
that's not just for my benefit that's

01:13:07,210 --> 01:13:13,780
for the benefit of the entire pill

01:13:09,820 --> 01:13:17,830
community so if someone wants me to send

01:13:13,780 --> 01:13:20,020
examples of Reg X's that run to four or

01:13:17,830 --> 01:13:20,410
five times slower I'm very happy to do

01:13:20,020 --> 01:13:24,640
that

01:13:20,410 --> 01:13:29,860
but I'm not prepared to do the the you

01:13:24,640 --> 01:13:34,180
know abdominal surgery so I'm Perl

01:13:29,860 --> 01:13:35,830
itself sent unto me khw at Sipan okay

01:13:34,180 --> 01:13:37,720
can i I'm not gonna be able to remember

01:13:35,830 --> 01:13:39,580
that because I'm in presentation mode

01:13:37,720 --> 01:13:41,110
can you just email me at damien at

01:13:39,580 --> 01:13:42,430
conway org and we'll get into

01:13:41,110 --> 01:13:46,540
conversation that way

01:13:42,430 --> 01:13:52,720
all right great thanks Carl okay next up

01:13:46,540 --> 01:13:54,250
is Andrew hi there two quick ones what

01:13:52,720 --> 01:13:56,260
was the length where you're like oh if

01:13:54,250 --> 01:13:56,800
it's so long it gets kind of unbearably

01:13:56,260 --> 01:13:58,510
slow

01:13:56,800 --> 01:14:01,750
I'm sure it's longer than anything I'm

01:13:58,510 --> 01:14:04,090
typing and - how much did you actually

01:14:01,750 --> 01:14:06,390
can do on the vim side or is it mostly

01:14:04,090 --> 01:14:08,380
just handled I mean for this

01:14:06,390 --> 01:14:15,600
highlighting part obviously you have

01:14:08,380 --> 01:14:15,600
your hooks for the restructure okay so

01:14:16,860 --> 01:14:21,730
it's not so much the length of the code

01:14:20,260 --> 01:14:24,130
that the critical issue it's the

01:14:21,730 --> 01:14:26,980
complexity of it the lexical complexity

01:14:24,130 --> 01:14:30,580
of it and that sheer number of variables

01:14:26,980 --> 01:14:34,450
that it uses and does it do the things

01:14:30,580 --> 01:14:36,700
that PPR takes a while to parse but on

01:14:34,450 --> 01:14:40,740
anything up to about a thousand lines

01:14:36,700 --> 01:14:44,110
I'm not noticing significant slowdowns

01:14:40,740 --> 01:14:47,410
above about a thousand lines it seems to

01:14:44,110 --> 01:14:49,450
get a bit part the second question how

01:14:47,410 --> 01:14:50,950
much is going on the fin side well

01:14:49,450 --> 01:14:53,409
there's a whole other talk on what's

01:14:50,950 --> 01:14:55,570
going on on the vim side

01:14:53,409 --> 01:14:57,789
but that wouldn't be an appropriate talk

01:14:55,570 --> 01:14:59,590
for at least half of this audience so I

01:14:57,789 --> 01:15:02,079
didn't delve into any more than that

01:14:59,590 --> 01:15:06,039
just brief touch that I had the plug-in

01:15:02,079 --> 01:15:08,400
itself is it's pretty long for a vim

01:15:06,039 --> 01:15:10,989
plug-in and it's fairly complicated too

01:15:08,400 --> 01:15:14,050
because I want the API to be very clean

01:15:10,989 --> 01:15:16,510
I didn't I showed you what I could doing

01:15:14,050 --> 01:15:19,959
them but I didn't show you how easy the

01:15:16,510 --> 01:15:22,360
API made it and my goal was it should be

01:15:19,959 --> 01:15:25,150
easier to do this in vim than it is to

01:15:22,360 --> 01:15:27,159
currently do it in comma for rocket and

01:15:25,150 --> 01:15:29,559
I think in most cases I seem to have

01:15:27,159 --> 01:15:32,469
achieved that but that did require quite

01:15:29,559 --> 01:15:39,310
a bit of vim scripting I'm not entirely

01:15:32,469 --> 01:15:42,589
sure what how many lines of code the

01:15:39,310 --> 01:15:42,589
[Music]

01:15:43,800 --> 01:15:57,789
just a second the the vim play is only

01:15:53,159 --> 01:16:01,539
734 lines long so it's it's not all that

01:15:57,789 --> 01:16:05,979
complicated and actually I'll sneak one

01:16:01,539 --> 01:16:08,919
more in locals and where you realize

01:16:05,979 --> 01:16:11,590
something before you go somewhere else

01:16:08,919 --> 01:16:15,610
handled not handled it pauses it

01:16:11,590 --> 01:16:17,650
correctly but it doesn't highlight those

01:16:15,610 --> 01:16:19,329
any differently because a localized

01:16:17,650 --> 01:16:22,269
version of the variable is technically

01:16:19,329 --> 01:16:24,760
still the same variable and I must admit

01:16:22,269 --> 01:16:28,929
I went back and forth on that should I

01:16:24,760 --> 01:16:31,419
in fact represent them as being

01:16:28,929 --> 01:16:33,489
different or should I represent them as

01:16:31,419 --> 01:16:35,739
being the same and I could argue it

01:16:33,489 --> 01:16:38,409
either way and if people have an opinion

01:16:35,739 --> 01:16:41,229
on that I'm very happy to get feedback

01:16:38,409 --> 01:16:45,939
on it it it doesn't do that at the

01:16:41,229 --> 01:16:48,429
moment it would be fairly trivial to do

01:16:45,939 --> 01:16:50,619
so because it's just another kind of

01:16:48,429 --> 01:16:52,989
declarative at the point where I saw

01:16:50,619 --> 01:16:56,949
that declaration I would just insert

01:16:52,989 --> 01:16:59,760
another declaration it's probably a 5

01:16:56,949 --> 01:17:03,519
minute change if that's what people

01:16:59,760 --> 01:17:05,499
think they prefer I don't think about

01:17:03,519 --> 01:17:06,910
them that way but other people might

01:17:05,499 --> 01:17:13,180
want to

01:17:06,910 --> 01:17:15,400
your flags all right yeah okay one last

01:17:13,180 --> 01:17:19,150
question David did you want to ask her

01:17:15,400 --> 01:17:20,860
you want me to ask and yeah I was just

01:17:19,150 --> 01:17:26,320
wondering if you've tested this in Pearl

01:17:20,860 --> 01:17:29,940
or I mean tested that in Eclipse sorry

01:17:26,320 --> 01:17:29,940
what do you mean tested this in Eclipse

01:17:30,000 --> 01:17:37,210
part of your talk involved how to use it

01:17:33,910 --> 01:17:38,650
with other editors and I'm just

01:17:37,210 --> 01:17:41,950
wondering if you've actually tried using

01:17:38,650 --> 01:17:44,500
it in Eclipse no I have not plugged it

01:17:41,950 --> 01:17:46,150
into any other editor I am frankly not

01:17:44,500 --> 01:17:49,780
interested in plugging it into any other

01:17:46,150 --> 01:17:51,940
editor myself the low-level tools that

01:17:49,780 --> 01:17:54,280
the module provides I believe will make

01:17:51,940 --> 01:17:57,120
it easy to do that because it made it

01:17:54,280 --> 01:18:02,350
easy to do it for them but I have

01:17:57,120 --> 01:18:05,800
literally zero interest in using eclipse

01:18:02,350 --> 01:18:08,170
or vs code for anything other than

01:18:05,800 --> 01:18:14,890
demonstrating how much better vim is

01:18:08,170 --> 01:18:16,660
than the clips or the ESCO okay and I

01:18:14,890 --> 01:18:20,650
think that's the last question Damian

01:18:16,660 --> 01:18:23,320
thank you so much for for this content

01:18:20,650 --> 01:18:26,170
or this talk and thank you so much for

01:18:23,320 --> 01:18:26,920
joining us and the QA we really

01:18:26,170 --> 01:18:30,520
appreciate it

01:18:26,920 --> 01:18:32,070
well thanks for inviting me and thanks

01:18:30,520 --> 01:18:35,590
everyone for sitting through that

01:18:32,070 --> 01:18:36,280
grueling 1 hour marathon enjoy the rest

01:18:35,590 --> 01:18:41,220
of the conference

01:18:36,280 --> 01:18:41,220

YouTube URL: https://www.youtube.com/watch?v=fVnmYzJfy5s


