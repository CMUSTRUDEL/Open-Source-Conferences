Title: Sawyer X - Guac!
Publication date: 2020-06-25
Playlist: TPC 2020 in the Cloud
Description: 
	I am going to present a fully static parser for Perl or a Good Enough subset of Perl.

It doesn't need runtime. It doesn't use regex. It doesn't use PPI. It doesn't require any custom code.
Captions: 
	00:00:00,060 --> 00:00:07,379
here's what it is okay so um I'm

00:00:05,430 --> 00:00:08,610
actually really excited because I get to

00:00:07,379 --> 00:00:10,679
present this thing that I've been

00:00:08,610 --> 00:00:11,130
working on with Duke NT for a very long

00:00:10,679 --> 00:00:15,030
time

00:00:11,130 --> 00:00:24,210
Vic NT is here as well we can do could

00:00:15,030 --> 00:00:26,130
you say hi so this is a share talk--i

00:00:24,210 --> 00:00:27,779
personally if you can t doesn't have he

00:00:26,130 --> 00:00:30,890
has a worse internet connection and I do

00:00:27,779 --> 00:00:34,110
so he he decided that he's gonna let me

00:00:30,890 --> 00:00:36,960
do all of this and as usual he will do

00:00:34,110 --> 00:00:38,700
the actual work Vic NT who was whoever's

00:00:36,960 --> 00:00:41,250
not familiar with him I really recommend

00:00:38,700 --> 00:00:45,360
seeing a talk in which he describes how

00:00:41,250 --> 00:00:47,010
he created basically he wrote XS for

00:00:45,360 --> 00:00:49,590
Perl but in rust so you could actually

00:00:47,010 --> 00:00:51,840
write access in rust and create bindings

00:00:49,590 --> 00:00:54,149
in rust for Perl it's really cool he's

00:00:51,840 --> 00:00:56,520
brilliant and and I'm I'm gonna try to

00:00:54,149 --> 00:00:58,590
thoroughly embarrass him

00:00:56,520 --> 00:01:01,230
welcome olya is something that we were

00:00:58,590 --> 00:01:02,969
working on for about I would say two

00:01:01,230 --> 00:01:06,030
months now and actually started roughly

00:01:02,969 --> 00:01:08,070
four years ago but now we've we've

00:01:06,030 --> 00:01:12,689
actually went back to it and finished it

00:01:08,070 --> 00:01:15,240
and it is a Perl parser toolkit so what

00:01:12,689 --> 00:01:17,040
does that mean I'm gonna cover what

00:01:15,240 --> 00:01:19,500
welcome olya is I'm gonna cover how it

00:01:17,040 --> 00:01:21,390
works I'm gonna cover what you could use

00:01:19,500 --> 00:01:25,229
it for and what tools are already

00:01:21,390 --> 00:01:26,970
available in it which you know before we

00:01:25,229 --> 00:01:29,610
do this though I think some bonding

00:01:26,970 --> 00:01:30,990
would be in order here I everyone's on

00:01:29,610 --> 00:01:33,090
mute so I'm not gonna hear you laugh but

00:01:30,990 --> 00:01:35,310
I imagine that maybe some some you know

00:01:33,090 --> 00:01:37,579
sometimes awkward stuff make us laugh so

00:01:35,310 --> 00:01:40,110
let's let's play with some awkward stuff

00:01:37,579 --> 00:01:41,850
does anyone know if this is a hash or a

00:01:40,110 --> 00:01:45,329
block this is a syntax for both a hash

00:01:41,850 --> 00:01:47,790
ref and a block in perl because it's the

00:01:45,329 --> 00:01:50,070
only statement and the last one he said

00:01:47,790 --> 00:01:52,560
it's a hash drive but what happens if I

00:01:50,070 --> 00:01:54,509
try to do two would the first one be a

00:01:52,560 --> 00:01:56,549
block and the second be a hash Rev or

00:01:54,509 --> 00:01:59,070
what happens if I didn't just put a

00:01:56,549 --> 00:02:01,770
comma no content or if I put a semicolon

00:01:59,070 --> 00:02:05,100
or did you know that you could do this

00:02:01,770 --> 00:02:07,920
you could actually use the the hash that

00:02:05,100 --> 00:02:09,899
the fish but that will work you can

00:02:07,920 --> 00:02:11,819
actually is as the limiter did you know

00:02:09,899 --> 00:02:13,410
you could use every character similar

00:02:11,819 --> 00:02:15,630
until recent

00:02:13,410 --> 00:02:18,990
you could actually use non-printable

00:02:15,630 --> 00:02:22,980
characters as delimiters - really really

00:02:18,990 --> 00:02:24,780
interesting and this map we want to say

00:02:22,980 --> 00:02:26,490
that there's an expression here and the

00:02:24,780 --> 00:02:29,370
expression is just like this key and

00:02:26,490 --> 00:02:32,010
value of a1 for each one of the foods

00:02:29,370 --> 00:02:33,830
but actually the foo is gonna go outside

00:02:32,010 --> 00:02:36,330
the map the map only has two arguments

00:02:33,830 --> 00:02:42,570
so there's all these things happening

00:02:36,330 --> 00:02:46,590
and now I want to cover some more

00:02:42,570 --> 00:02:48,180
awkwardness open is a key word but if

00:02:46,590 --> 00:02:50,310
you were to write a parser and you the

00:02:48,180 --> 00:02:52,410
functions could have parenthesis then

00:02:50,310 --> 00:02:54,270
open maybe it would be a subroutine as

00:02:52,410 --> 00:02:55,890
well if someone use parentheses with it

00:02:54,270 --> 00:02:57,650
because it really could use parentheses

00:02:55,890 --> 00:03:02,190
with keywords but you go so omit them

00:02:57,650 --> 00:03:03,630
omit them and then QW is is referred to

00:03:02,190 --> 00:03:06,540
as a queue like value it's a type of

00:03:03,630 --> 00:03:07,830
value but did you know that you could

00:03:06,540 --> 00:03:09,960
use parentheses you could use space

00:03:07,830 --> 00:03:12,870
suddenly now it's a subroutine as if

00:03:09,960 --> 00:03:15,300
looks like it some some more awkwardness

00:03:12,870 --> 00:03:18,360
you could write the foo but you could

00:03:15,300 --> 00:03:20,610
also write dollar hash foo and you could

00:03:18,360 --> 00:03:22,740
also write dollar after dollar foo and

00:03:20,610 --> 00:03:26,130
you can write dollar space food could

00:03:22,740 --> 00:03:28,500
you do this though you could could you

00:03:26,130 --> 00:03:31,050
do this maybe you could could you do

00:03:28,500 --> 00:03:33,390
this could you do this and we've been

00:03:31,050 --> 00:03:36,540
playing with parsers specifically for

00:03:33,390 --> 00:03:38,520
pro for a while now in some intensity

00:03:36,540 --> 00:03:42,239
and these are some of the use cases that

00:03:38,520 --> 00:03:44,130
I found pro bends over backwards to make

00:03:42,239 --> 00:03:46,560
some of this awkwardness actually work

00:03:44,130 --> 00:03:49,290
which is spectacular to say the least

00:03:46,560 --> 00:03:51,720
so some yet more awkwardness this in pro

00:03:49,290 --> 00:03:54,840
is a hash these two braces it's empty

00:03:51,720 --> 00:03:58,380
it's a hash but if I put a one there now

00:03:54,840 --> 00:04:00,750
it's a block now I could put one comma

00:03:58,380 --> 00:04:02,910
two there and then it's a hash again or

00:04:00,750 --> 00:04:07,290
I could just put a comma and then it's a

00:04:02,910 --> 00:04:10,400
hash unless the first word there is all

00:04:07,290 --> 00:04:13,980
in lowercase and now it's a block again

00:04:10,400 --> 00:04:15,830
unless the first character is uppercase

00:04:13,980 --> 00:04:18,000
because then it's back to being a hash

00:04:15,830 --> 00:04:21,060
unless the first character is lowercase

00:04:18,000 --> 00:04:22,770
but it starts with a Q then yeah okay

00:04:21,060 --> 00:04:26,250
okay then it's still a hash but then

00:04:22,770 --> 00:04:27,030
unless what maybe okay DOM is still a

00:04:26,250 --> 00:04:29,490
hash and then

00:04:27,030 --> 00:04:32,510
QQ actually has yet no that's a hash -

00:04:29,490 --> 00:04:35,790
unless it's QR then it's a block again

00:04:32,510 --> 00:04:39,300
okay that's kind of yeah some more

00:04:35,790 --> 00:04:42,480
awkwardness hash food that would that

00:04:39,300 --> 00:04:43,740
would work and hash foo with parentheses

00:04:42,480 --> 00:04:47,150
we work some people know that some

00:04:43,740 --> 00:04:49,890
people don't what happens if I do + foo

00:04:47,150 --> 00:04:51,360
Abigail is on mute but Abigail I imagine

00:04:49,890 --> 00:04:54,360
would know the answers through all of

00:04:51,360 --> 00:04:57,210
these + foo actually calls the function

00:04:54,360 --> 00:04:59,310
foo but - foo would you think would

00:04:57,210 --> 00:05:02,669
probably be similar isn't - who is

00:04:59,310 --> 00:05:05,010
actually going to be a string - foo what

00:05:02,669 --> 00:05:09,000
happens if I have foo written like this

00:05:05,010 --> 00:05:10,410
and in the line in and of itself it will

00:05:09,000 --> 00:05:12,300
call the function if you thought that

00:05:10,410 --> 00:05:15,330
this is the same as the first line it is

00:05:12,300 --> 00:05:19,560
not the way I found out is because I had

00:05:15,330 --> 00:05:20,220
a hash that had one Keane value and then

00:05:19,560 --> 00:05:23,880
another one

00:05:20,220 --> 00:05:27,260
the second key was caller this is in

00:05:23,880 --> 00:05:31,140
dancer code has an attribute caller and

00:05:27,260 --> 00:05:34,320
when tidying the code dropped the line

00:05:31,140 --> 00:05:37,860
and suddenly it's not being quoted

00:05:34,320 --> 00:05:38,520
anymore what else do we have do we have

00:05:37,860 --> 00:05:40,950
any more awkward

00:05:38,520 --> 00:05:43,110
oh yeah of course when you see this code

00:05:40,950 --> 00:05:44,580
this is interesting if you're writing a

00:05:43,110 --> 00:05:46,140
parser of your own if you see this code

00:05:44,580 --> 00:05:47,729
sub foo and a dollar

00:05:46,140 --> 00:05:50,340
you really don't know if it's a

00:05:47,729 --> 00:05:53,930
signature or it's a prototype and the

00:05:50,340 --> 00:05:59,340
answer as with many things in Perl is

00:05:53,930 --> 00:06:03,570
well it depends okay more awkwardness

00:05:59,340 --> 00:06:06,150
so dollar and then foo in these braces

00:06:03,570 --> 00:06:08,160
that work there's also this this will

00:06:06,150 --> 00:06:10,169
call the function the first one I

00:06:08,160 --> 00:06:12,180
actually call it the variable and then

00:06:10,169 --> 00:06:13,919
what happens if you have a function but

00:06:12,180 --> 00:06:17,370
it has an empty prototype that returns a

00:06:13,919 --> 00:06:19,320
key would you actually do dollar braces

00:06:17,370 --> 00:06:21,870
and then the string key or would he do

00:06:19,320 --> 00:06:26,610
dollar foo which one of these would

00:06:21,870 --> 00:06:28,350
happen so okay once we've seen all these

00:06:26,610 --> 00:06:31,919
different things that can happen in Perl

00:06:28,350 --> 00:06:34,620
and do happen I want to go back to what

00:06:31,919 --> 00:06:36,840
this talk is about so this talk is about

00:06:34,620 --> 00:06:39,930
guacamole we're gonna start with what

00:06:36,840 --> 00:06:40,810
guacamoles welcome only in a nutshell is

00:06:39,930 --> 00:06:42,790
a complete

00:06:40,810 --> 00:06:44,800
specification based unambiguous fully

00:06:42,790 --> 00:06:47,380
static parser and toolkit for standard

00:06:44,800 --> 00:06:48,940
Perl syntax which is a mouthful also you

00:06:47,380 --> 00:06:50,260
probably don't really know what I mean

00:06:48,940 --> 00:06:52,210
by standard Perl

00:06:50,260 --> 00:06:53,710
so I'm actually going to go back one

00:06:52,210 --> 00:06:56,200
step so this was one there's gonna be

00:06:53,710 --> 00:06:58,510
zero and we're going to talk about

00:06:56,200 --> 00:07:01,480
standard Perl so standard Pro was an

00:06:58,510 --> 00:07:03,850
idea that it came up with roughly four

00:07:01,480 --> 00:07:06,940
years ago we played with this concept of

00:07:03,850 --> 00:07:08,760
what would happen if we could make Perl

00:07:06,940 --> 00:07:11,200
unambiguous if we could provide a

00:07:08,760 --> 00:07:12,610
specification for the language that we

00:07:11,200 --> 00:07:15,310
just know what it means and there are no

00:07:12,610 --> 00:07:16,990
more it depends and we started writing

00:07:15,310 --> 00:07:19,450
down all these different things and we

00:07:16,990 --> 00:07:21,430
can't he was the person I worked with

00:07:19,450 --> 00:07:24,190
the most on this because he knows the

00:07:21,430 --> 00:07:27,490
parser he knows well he knows several

00:07:24,190 --> 00:07:29,020
different language parsers but he's also

00:07:27,490 --> 00:07:30,580
a brilliant person and we started

00:07:29,020 --> 00:07:34,060
writing down what are the different

00:07:30,580 --> 00:07:36,250
things that are problematic move forward

00:07:34,060 --> 00:07:38,830
for years I decided to pick this idea

00:07:36,250 --> 00:07:41,500
back and I started playing with flex and

00:07:38,830 --> 00:07:43,540
with bison and all these things and try

00:07:41,500 --> 00:07:45,130
to write them and I went back to a

00:07:43,540 --> 00:07:46,950
project which we started documenting

00:07:45,130 --> 00:07:49,750
these things the project was called

00:07:46,950 --> 00:07:53,020
re-imagined guacamole which was a joke

00:07:49,750 --> 00:07:54,580
and I looked at it and I found that

00:07:53,020 --> 00:07:56,770
weekend he actually wrote a bit of code

00:07:54,580 --> 00:07:58,810
and went into it further he actually

00:07:56,770 --> 00:08:01,150
wrote something that that tries to

00:07:58,810 --> 00:08:02,620
follow these rules so I thought this

00:08:01,150 --> 00:08:04,510
would be nice we should play with that

00:08:02,620 --> 00:08:06,520
to try and come up with these rules so

00:08:04,510 --> 00:08:09,240
we came up with standard per standard

00:08:06,520 --> 00:08:14,500
Perl is basically a syntax specification

00:08:09,240 --> 00:08:16,960
for pearls it is a working subset dummy

00:08:14,500 --> 00:08:20,020
is that any standard Pearlridge right is

00:08:16,960 --> 00:08:22,479
Perl it does not introduce new concepts

00:08:20,020 --> 00:08:23,979
it is a hundred percent unambiguous

00:08:22,479 --> 00:08:25,930
inconsistent which means that it will

00:08:23,979 --> 00:08:27,520
always produce the same results and it

00:08:25,930 --> 00:08:32,200
knows a hundred percent when each

00:08:27,520 --> 00:08:34,000
element is no confusion no maybes also

00:08:32,200 --> 00:08:37,419
it is fully static you're going to run

00:08:34,000 --> 00:08:40,390
any begin blocks nothing and it will

00:08:37,419 --> 00:08:42,219
parse the begin blocks as well it is

00:08:40,390 --> 00:08:44,770
easy to write easy to read which is

00:08:42,219 --> 00:08:47,650
really what I wanted with standard Perl

00:08:44,770 --> 00:08:49,660
as well the idea of having Pro that you

00:08:47,650 --> 00:08:51,700
could really understand and you won't

00:08:49,660 --> 00:08:52,930
have a lot of these it depends when you

00:08:51,700 --> 00:08:55,510
explain this to someone

00:08:52,930 --> 00:08:58,900
and when you think things that you teach

00:08:55,510 --> 00:09:02,380
I've been I taught pro for almost two

00:08:58,900 --> 00:09:05,080
years as a open course and it was

00:09:02,380 --> 00:09:08,190
difficult because every time we reach an

00:09:05,080 --> 00:09:11,710
explanation there were so many different

00:09:08,190 --> 00:09:14,260
disclaimers and we went into well except

00:09:11,710 --> 00:09:15,850
when in all these things and I wanted to

00:09:14,260 --> 00:09:18,220
be able to teach you simply because

00:09:15,850 --> 00:09:20,200
there was so much to the language it's

00:09:18,220 --> 00:09:22,270
just so much to explain and so many

00:09:20,200 --> 00:09:25,390
different in the sides and I also didn't

00:09:22,270 --> 00:09:27,700
know enough of it so I wanted a version

00:09:25,390 --> 00:09:28,810
of pro that I could teach I went in

00:09:27,700 --> 00:09:34,510
version probably it would be easy to

00:09:28,810 --> 00:09:36,700
learn easy to write a book for it so we

00:09:34,510 --> 00:09:38,560
ended up writing a BNF if you're not

00:09:36,700 --> 00:09:40,300
familiar with the BNF is basically a set

00:09:38,560 --> 00:09:43,450
of rules that are written in a

00:09:40,300 --> 00:09:45,730
standardized format and parsers can use

00:09:43,450 --> 00:09:52,090
BNF in order to write a lexer and parser

00:09:45,730 --> 00:09:54,220
so elements that they will take the the

00:09:52,090 --> 00:09:56,440
code they will basically decide what are

00:09:54,220 --> 00:10:00,580
the tokens in it what am i seen and then

00:09:56,440 --> 00:10:01,750
they would tell you what those elements

00:10:00,580 --> 00:10:05,500
are and how they're combined with each

00:10:01,750 --> 00:10:08,860
other so that's the PMF and then that

00:10:05,500 --> 00:10:10,600
allows writing parsers and once you have

00:10:08,860 --> 00:10:12,610
a PMF it's a specification it's an

00:10:10,600 --> 00:10:14,110
official thing so what you could do is

00:10:12,610 --> 00:10:15,700
you could write it in more than one

00:10:14,110 --> 00:10:18,490
language you could implement it in

00:10:15,700 --> 00:10:20,620
whatever language you want for example

00:10:18,490 --> 00:10:22,180
you could write a parser for Perl in

00:10:20,620 --> 00:10:25,090
Perl you Carrere pro surfer Perl in

00:10:22,180 --> 00:10:28,630
brach ooh-rah who specifically has a lot

00:10:25,090 --> 00:10:31,000
of parser specific bits available in the

00:10:28,630 --> 00:10:33,280
language itself which is amazing you

00:10:31,000 --> 00:10:35,230
could just use that so you can easily do

00:10:33,280 --> 00:10:37,540
this with pure or rocket without any

00:10:35,230 --> 00:10:39,430
specialized stuff you can do it with C

00:10:37,540 --> 00:10:40,690
in Java and go they could alright

00:10:39,430 --> 00:10:44,050
different Perl parsers

00:10:40,690 --> 00:10:46,660
because there's a specification and it

00:10:44,050 --> 00:10:49,210
makes the Perl tooling much simpler

00:10:46,660 --> 00:10:51,270
which is also I think it's a big pain

00:10:49,210 --> 00:10:53,530
point for us that the tooling in Perl is

00:10:51,270 --> 00:10:55,060
it's pretty good but it sounds good as

00:10:53,530 --> 00:10:58,120
we could make it if we had a

00:10:55,060 --> 00:11:01,180
standardized version now there's this

00:10:58,120 --> 00:11:03,130
famous sentence that says only pro can

00:11:01,180 --> 00:11:05,080
parse Perl and you can see that one of

00:11:03,130 --> 00:11:06,790
them is in mono space and lower case and

00:11:05,080 --> 00:11:08,740
one of them is upper case

00:11:06,790 --> 00:11:11,350
and if you're not familiar with this

00:11:08,740 --> 00:11:13,360
sentence by Tom crisis and the the

00:11:11,350 --> 00:11:15,490
sentence basically says that the the

00:11:13,360 --> 00:11:18,580
Pearl parser the interpreter that we use

00:11:15,490 --> 00:11:20,560
to run our code it is the only thing

00:11:18,580 --> 00:11:23,230
that can really parse and understand the

00:11:20,560 --> 00:11:24,820
Pearl language because there's so many

00:11:23,230 --> 00:11:26,170
edge cases to it there's so many

00:11:24,820 --> 00:11:28,240
different considerations you have to

00:11:26,170 --> 00:11:29,680
compile stuff and you have to run stuff

00:11:28,240 --> 00:11:32,200
and you have some arbitrary code

00:11:29,680 --> 00:11:34,150
sometimes and you have special lexing

00:11:32,200 --> 00:11:36,970
rules by the author and let's not even

00:11:34,150 --> 00:11:37,720
get to develop it Claire it's just it

00:11:36,970 --> 00:11:41,350
yeah

00:11:37,720 --> 00:11:43,480
so Tommy said you know that the the

00:11:41,350 --> 00:11:46,450
language itself can only be understood

00:11:43,480 --> 00:11:48,280
by the interpreter that we use to run it

00:11:46,450 --> 00:11:51,310
and that that really sucks because it

00:11:48,280 --> 00:11:53,320
means that nothing else could do it so

00:11:51,310 --> 00:11:55,300
here's an example this is this is a

00:11:53,320 --> 00:11:57,640
proof by Randall Schwartz Schwartz is

00:11:55,300 --> 00:12:02,200
what you don't see in the in the blob

00:11:57,640 --> 00:12:06,300
that's hiding it the idea is you have

00:12:02,200 --> 00:12:11,910
these two options sinus and time and

00:12:06,300 --> 00:12:14,950
they give you 1/25 the second 1/25 and

00:12:11,910 --> 00:12:16,390
one of these will die one of this these

00:12:14,950 --> 00:12:18,910
won't even though they're written

00:12:16,390 --> 00:12:20,590
exactly the same their reason if you're

00:12:18,910 --> 00:12:23,560
not familiar with them or with the proof

00:12:20,590 --> 00:12:31,540
by by randall is that the first one will

00:12:23,560 --> 00:12:32,950
see sin / 25 semicolon hash slash as is

00:12:31,540 --> 00:12:35,680
a statement there's actually only one

00:12:32,950 --> 00:12:37,420
argument the argument to the function is

00:12:35,680 --> 00:12:39,550
between two slashes it would actually

00:12:37,420 --> 00:12:42,660
run the two slashes that's the argument

00:12:39,550 --> 00:12:46,030
on the other hand time has no arguments

00:12:42,660 --> 00:12:49,120
so you call time it returns something

00:12:46,030 --> 00:12:52,030
and that will get divided by 25 so that

00:12:49,120 --> 00:12:55,360
gets executed separately so in the first

00:12:52,030 --> 00:12:57,910
example all of this gets executed as one

00:12:55,360 --> 00:13:00,070
function and arguments one argument

00:12:57,910 --> 00:13:03,460
within these slashes and then semicolon

00:13:00,070 --> 00:13:05,620
to die in the other case you will divide

00:13:03,460 --> 00:13:08,560
it by 25 it's done then the rest is a

00:13:05,620 --> 00:13:11,290
compliment now if we're to produce a

00:13:08,560 --> 00:13:14,500
generalized version of it it wouldn't

00:13:11,290 --> 00:13:15,610
look but there we go it would look like

00:13:14,500 --> 00:13:17,860
this this is perfect

00:13:15,610 --> 00:13:19,900
Randall Schwartz generalized is whatever

00:13:17,860 --> 00:13:20,560
you have there could be parsed

00:13:19,900 --> 00:13:22,540
separately and

00:13:20,560 --> 00:13:24,220
really depends on the rules the pro uses

00:13:22,540 --> 00:13:27,759
to do this and the rules will be written

00:13:24,220 --> 00:13:30,999
by a developer now this is an

00:13:27,759 --> 00:13:36,610
unambiguous variation if you wanted to

00:13:30,999 --> 00:13:39,370
make this unambiguous use parentheses if

00:13:36,610 --> 00:13:42,790
use parentheses you can clarify what

00:13:39,370 --> 00:13:46,209
happens the first one we just call with

00:13:42,790 --> 00:13:47,949
parentheses run slash 25 will be done

00:13:46,209 --> 00:13:49,899
and there's a comment the second one

00:13:47,949 --> 00:13:51,160
would have the parentheses there and you

00:13:49,899 --> 00:13:53,649
could really see that that is the

00:13:51,160 --> 00:13:55,480
argument and the rest will die so this

00:13:53,649 --> 00:13:56,860
this is one of the ways in which that we

00:13:55,480 --> 00:13:58,149
can actually just change the language a

00:13:56,860 --> 00:14:00,100
little bit it is part of the language

00:13:58,149 --> 00:14:03,279
still just enforce some patterns and

00:14:00,100 --> 00:14:04,899
then it would look good so the idea is a

00:14:03,279 --> 00:14:05,350
standard pro will make all of this pain

00:14:04,899 --> 00:14:09,910
go away

00:14:05,350 --> 00:14:11,319
and it does the there are a few things

00:14:09,910 --> 00:14:13,959
that we did with standard Pro first we

00:14:11,319 --> 00:14:16,389
removed a few things simple as that we

00:14:13,959 --> 00:14:18,279
changed how some things work not

00:14:16,389 --> 00:14:20,350
changing the Perl language itself but

00:14:18,279 --> 00:14:25,000
more of how we want it to be written and

00:14:20,350 --> 00:14:27,850
that's that was basically it so things

00:14:25,000 --> 00:14:29,829
be removed first autocoding I'm gonna

00:14:27,850 --> 00:14:31,540
get a lot of enemies from this that the

00:14:29,829 --> 00:14:34,089
before I begin I'm gonna say no one has

00:14:31,540 --> 00:14:36,579
to do this no one has to use this but

00:14:34,089 --> 00:14:38,980
you might get some benefits if you do so

00:14:36,579 --> 00:14:42,220
first of all autocoding is gone outer

00:14:38,980 --> 00:14:48,129
quoting is a mess not only are the rules

00:14:42,220 --> 00:14:50,649
for outer coating just I I don't I don't

00:14:48,129 --> 00:14:53,680
think English has a word for how crazy

00:14:50,649 --> 00:14:55,899
they are how difficult they are but in

00:14:53,680 --> 00:14:58,269
standard Perl if it's a string it is

00:14:55,899 --> 00:15:03,069
quoted that's it there are no other

00:14:58,269 --> 00:15:04,899
options it's a string it is quoting now

00:15:03,069 --> 00:15:06,670
other than their utter quoting we

00:15:04,899 --> 00:15:09,069
removed here dogs because you really

00:15:06,670 --> 00:15:10,240
your ducts are just too wild if you want

00:15:09,069 --> 00:15:12,819
to write a parser and you want to

00:15:10,240 --> 00:15:16,649
implement tear ducts for each here dark

00:15:12,819 --> 00:15:19,179
element you need a sub parser and it's

00:15:16,649 --> 00:15:20,769
and then you have to hear air ducts it

00:15:19,179 --> 00:15:22,809
the same on the same line I don't even

00:15:20,769 --> 00:15:24,220
want to get into that will you say get I

00:15:22,809 --> 00:15:27,009
remember one book that we got in Pro

00:15:24,220 --> 00:15:28,990
because someone was trying to do an evil

00:15:27,009 --> 00:15:32,000
on a command line with a here dog within

00:15:28,990 --> 00:15:34,490
a regex match execution and it was

00:15:32,000 --> 00:15:38,230
like this tower of why were you even

00:15:34,490 --> 00:15:41,090
trying to and they came up with an error

00:15:38,230 --> 00:15:42,820
in direct object notation some people

00:15:41,090 --> 00:15:46,190
like this recently someone posted

00:15:42,820 --> 00:15:48,200
something and how indirect object

00:15:46,190 --> 00:15:50,900
notation is so important and I

00:15:48,200 --> 00:15:53,480
wholeheartedly disagree I do not like

00:15:50,900 --> 00:15:56,510
indirect object object notation bear

00:15:53,480 --> 00:15:58,790
word file handles are also gone except

00:15:56,510 --> 00:16:01,070
well if you want to actually use them

00:15:58,790 --> 00:16:03,110
you could you could print and then use

00:16:01,070 --> 00:16:05,810
file handles this way by the way for a

00:16:03,110 --> 00:16:07,580
print and this these specific bear word

00:16:05,810 --> 00:16:09,920
handles are still supported so if you're

00:16:07,580 --> 00:16:11,840
gonna do print standard ants that are

00:16:09,920 --> 00:16:13,310
out prints that are in you probably

00:16:11,840 --> 00:16:14,960
wouldn't but prints that are out prints

00:16:13,310 --> 00:16:16,220
that are there all these will work I

00:16:14,960 --> 00:16:19,460
don't know how many people knew of art

00:16:16,220 --> 00:16:23,330
vrv out and no data probably so they

00:16:19,460 --> 00:16:26,420
still are accepted and obviously you

00:16:23,330 --> 00:16:28,280
could do a print and use braces for file

00:16:26,420 --> 00:16:31,370
handles that's also there because it's

00:16:28,280 --> 00:16:33,950
not a better word the underscore and you

00:16:31,370 --> 00:16:37,160
have concatenating file operators that's

00:16:33,950 --> 00:16:38,570
gone because really the underscore is

00:16:37,160 --> 00:16:41,930
only meaningful when there are the

00:16:38,570 --> 00:16:44,030
previous file operators so you really

00:16:41,930 --> 00:16:45,560
wouldn't know when you just saw an

00:16:44,030 --> 00:16:46,880
underscore but it is you have to

00:16:45,560 --> 00:16:49,070
understand the context in which you're

00:16:46,880 --> 00:16:52,820
in and then you turn into contextual

00:16:49,070 --> 00:16:54,910
parsers and those are so difficult given

00:16:52,820 --> 00:16:58,610
when default by just go on

00:16:54,910 --> 00:17:00,710
alright these are few like values these

00:16:58,610 --> 00:17:04,699
are things we changed so cute like

00:17:00,710 --> 00:17:08,660
values or things like these q QQ q WQ x

00:17:04,699 --> 00:17:11,540
q are the m4 matching the s4 search

00:17:08,660 --> 00:17:13,459
replace the TR and the y they are all

00:17:11,540 --> 00:17:16,939
considered q like values they are not

00:17:13,459 --> 00:17:19,160
functions they are values so first of

00:17:16,939 --> 00:17:22,490
all no nested the limiters if you want

00:17:19,160 --> 00:17:26,660
to write this you just need to escape

00:17:22,490 --> 00:17:28,490
them secondly I never appreciated the

00:17:26,660 --> 00:17:30,530
delimiter is improved there were way too

00:17:28,490 --> 00:17:32,930
many de limiters for these things we've

00:17:30,530 --> 00:17:34,250
limited it we can obviously open them up

00:17:32,930 --> 00:17:36,440
some more if there are additional

00:17:34,250 --> 00:17:37,970
characters that make sense to have but

00:17:36,440 --> 00:17:40,429
you know what there has to be a limit

00:17:37,970 --> 00:17:42,260
especially when you could use any other

00:17:40,429 --> 00:17:43,190
printable character as well if you just

00:17:42,260 --> 00:17:45,180
have a space

00:17:43,190 --> 00:17:49,230
so yeah that's gone the

00:17:45,180 --> 00:17:51,660
the comment symbol can also be used as

00:17:49,230 --> 00:17:54,270
the limiter that's no no no we're done

00:17:51,660 --> 00:17:56,370
that's it so I hate to do this but can

00:17:54,270 --> 00:17:58,380
you I'm just watching the chat and can

00:17:56,370 --> 00:17:59,040
you just clarify that you this is your

00:17:58,380 --> 00:18:03,710
project

00:17:59,040 --> 00:18:06,630
oh yeah yeah I'm sorry this is nothing I

00:18:03,710 --> 00:18:09,180
think people are seeing you as pumpkin

00:18:06,630 --> 00:18:11,030
and freaking oh yeah no this is a

00:18:09,180 --> 00:18:15,270
project that I've been working on for

00:18:11,030 --> 00:18:17,520
for me to enforce code that I like that

00:18:15,270 --> 00:18:19,440
is it it's also for you to enforce code

00:18:17,520 --> 00:18:21,120
that I like but it is not part of the

00:18:19,440 --> 00:18:24,000
language it is not going into language

00:18:21,120 --> 00:18:26,880
it is not going even near the language

00:18:24,000 --> 00:18:29,250
so I just thank you for that that

00:18:26,880 --> 00:18:32,910
request wow that was that would have

00:18:29,250 --> 00:18:36,900
been that would be tough there are also

00:18:32,910 --> 00:18:38,580
no spaces before the limiters so if you

00:18:36,900 --> 00:18:40,770
want to write something this Q value

00:18:38,580 --> 00:18:42,270
won't count it will not parse it it

00:18:40,770 --> 00:18:45,480
actually says I don't know what this is

00:18:42,270 --> 00:18:48,480
is then you have to have the delimiter

00:18:45,480 --> 00:18:51,600
close to the Q like beginning character

00:18:48,480 --> 00:18:53,610
and that is because the person needs to

00:18:51,600 --> 00:18:56,970
see this as a value and not get it

00:18:53,610 --> 00:19:01,950
confused with other things like brackets

00:18:56,970 --> 00:19:07,020
we stand in for example then there's Q

00:19:01,950 --> 00:19:10,200
with parentheses so I'm sorry this is

00:19:07,020 --> 00:19:12,960
actually backwards to this mistake the Q

00:19:10,200 --> 00:19:15,350
with space even with parentheses will

00:19:12,960 --> 00:19:18,920
also not work this is actually a mistake

00:19:15,350 --> 00:19:21,810
this should be correct this is incorrect

00:19:18,920 --> 00:19:23,820
because the idea is that this mistake is

00:19:21,810 --> 00:19:25,140
the same mistake as this as this it just

00:19:23,820 --> 00:19:26,760
has parentheses so you think it's a

00:19:25,140 --> 00:19:30,870
function it is not a function we just

00:19:26,760 --> 00:19:32,840
allow parentheses all right these are

00:19:30,870 --> 00:19:35,400
changes that we've done to subroutines

00:19:32,840 --> 00:19:38,610
only in the specification that we have

00:19:35,400 --> 00:19:41,370
not in the language so all the

00:19:38,610 --> 00:19:43,260
subroutines must use parentheses all

00:19:41,370 --> 00:19:48,240
subroutines no exceptions

00:19:43,260 --> 00:19:50,850
so fubar will not work foo parenthesis

00:19:48,240 --> 00:19:53,040
bar will work subroutines can have

00:19:50,850 --> 00:19:54,690
attributed signatures of course but all

00:19:53,040 --> 00:19:57,810
subroutine prototypes must be declared

00:19:54,690 --> 00:19:58,710
using an attribute so if you want to use

00:19:57,810 --> 00:20:01,080
prototypes

00:19:58,710 --> 00:20:03,090
you want standard pearl to be consistent

00:20:01,080 --> 00:20:04,860
with standard pearls this proposed

00:20:03,090 --> 00:20:07,169
specification that is not part of the

00:20:04,860 --> 00:20:10,260
language you would have to define the

00:20:07,169 --> 00:20:12,330
prototype this way and then the

00:20:10,260 --> 00:20:13,409
prototypes cannot change the parsing

00:20:12,330 --> 00:20:15,419
rules and this is something the people

00:20:13,409 --> 00:20:18,149
in Pearl really really really like but

00:20:15,419 --> 00:20:22,440
it is never easy to explain prototypes

00:20:18,149 --> 00:20:24,929
never so this does not work even though

00:20:22,440 --> 00:20:26,520
we really like it it's not actually good

00:20:24,929 --> 00:20:28,049
it's not readable for people are not

00:20:26,520 --> 00:20:30,539
familiar with prototypes and then you

00:20:28,049 --> 00:20:32,340
have to explain that a developer

00:20:30,539 --> 00:20:35,309
somewhere else has provided parsing

00:20:32,340 --> 00:20:37,980
rules for the code that you wrote yeah

00:20:35,309 --> 00:20:40,950
it's very weird so instead we're gonna

00:20:37,980 --> 00:20:43,350
write it this way I do want to say

00:20:40,950 --> 00:20:48,659
however if you think of things like mojo

00:20:43,350 --> 00:20:50,909
dancer mousse they have in a sense their

00:20:48,659 --> 00:20:52,799
own grammar or so we have an open issue

00:20:50,909 --> 00:20:56,970
we're working on introducing pluggable

00:20:52,799 --> 00:20:59,970
grammars so you could say I want this to

00:20:56,970 --> 00:21:02,250
be purl but I also want this to use the

00:20:59,970 --> 00:21:04,440
mousse grammar so it can understand that

00:21:02,250 --> 00:21:08,659
this is like mousse keywords and and how

00:21:04,440 --> 00:21:13,860
they behave all right some more changes

00:21:08,659 --> 00:21:15,450
right so this is class names so changes

00:21:13,860 --> 00:21:18,779
to class names the left of an error is

00:21:15,450 --> 00:21:22,320
oh is an invocation so this is a common

00:21:18,779 --> 00:21:24,809
mistake there's there's this actually is

00:21:22,320 --> 00:21:27,980
enforced with code after the fact but

00:21:24,809 --> 00:21:30,659
these that when you write foo aerobar

00:21:27,980 --> 00:21:33,659
theoretically it could be also function

00:21:30,659 --> 00:21:35,429
but really when you do that it's almost

00:21:33,659 --> 00:21:39,270
always incorrect it's almost always a

00:21:35,429 --> 00:21:40,529
mistake I have I imagine people have

00:21:39,270 --> 00:21:42,270
done this before but I have never

00:21:40,529 --> 00:21:45,350
actually witnessed someone write this

00:21:42,270 --> 00:21:51,630
and meaning to run a function called foo

00:21:45,350 --> 00:21:53,520
so instead the the this is not okay if

00:21:51,630 --> 00:21:55,470
there is a case that it detects that you

00:21:53,520 --> 00:21:59,299
had foo but you also define the function

00:21:55,470 --> 00:22:01,770
called foo it will give you an error

00:21:59,299 --> 00:22:03,720
namespaces cannot end with a double

00:22:01,770 --> 00:22:06,510
colon so this is one way to disambiguate

00:22:03,720 --> 00:22:08,700
it there are people who write this at

00:22:06,510 --> 00:22:11,850
the moment this is not supported I will

00:22:08,700 --> 00:22:14,100
say that we could support it I just

00:22:11,850 --> 00:22:15,990
and decided that this is like syntax

00:22:14,100 --> 00:22:18,419
that I would like people to write if

00:22:15,990 --> 00:22:20,370
people ask me what is clean pearl I

00:22:18,419 --> 00:22:23,130
don't know if I recommend this because I

00:22:20,370 --> 00:22:27,480
think it's a bit true sir but I don't

00:22:23,130 --> 00:22:29,730
kind of clunky it looks weird some

00:22:27,480 --> 00:22:31,230
changes to the referencing prefix that

00:22:29,730 --> 00:22:33,210
our first thing is is only supported

00:22:31,230 --> 00:22:35,610
with braces this is one thing that

00:22:33,210 --> 00:22:38,490
bothered me all the time I hated seeing

00:22:35,610 --> 00:22:41,580
code like this when I talk Perl I once

00:22:38,490 --> 00:22:43,049
showed dollar dollar foo and every time

00:22:41,580 --> 00:22:46,890
I showed it to people and I said okay

00:22:43,049 --> 00:22:49,289
this is less real well I remember at

00:22:46,890 --> 00:22:50,580
least once or twice someone who raised

00:22:49,289 --> 00:22:51,780
their hand and say well there's just one

00:22:50,580 --> 00:22:53,789
dollar what's the problem they'd even

00:22:51,780 --> 00:22:55,980
noticed there were two dollar signs so

00:22:53,789 --> 00:22:59,190
that's you can't do that just use braces

00:22:55,980 --> 00:23:00,440
or spot postfix the represent is of

00:22:59,190 --> 00:23:03,179
course support it

00:23:00,440 --> 00:23:06,740
this by the way will not work because F

00:23:03,179 --> 00:23:09,900
is a barre word so that will not succeed

00:23:06,740 --> 00:23:12,150
okay a one change to expressions which i

00:23:09,900 --> 00:23:14,909
think is important a map that attempts

00:23:12,150 --> 00:23:16,950
to return a pair must use parentheses so

00:23:14,909 --> 00:23:18,539
this will not work instead you can just

00:23:16,950 --> 00:23:23,100
use this and then it becomes an

00:23:18,539 --> 00:23:25,470
expression and that's great the plus

00:23:23,100 --> 00:23:28,440
with the parentheses that some people

00:23:25,470 --> 00:23:31,380
write I write a lot that's the words all

00:23:28,440 --> 00:23:33,059
right so now we've covered this idea of

00:23:31,380 --> 00:23:36,809
a specification that you could write it

00:23:33,059 --> 00:23:37,830
okay now the whole idea with that is to

00:23:36,809 --> 00:23:40,289
actually write something that could

00:23:37,830 --> 00:23:43,380
parse it if we had this so now that we

00:23:40,289 --> 00:23:45,720
sat down and we wrote a BNF that can

00:23:43,380 --> 00:23:47,990
deal with this we wrote a parser that

00:23:45,720 --> 00:23:51,090
could deal with this and that parser is

00:23:47,990 --> 00:23:52,770
called guacamole guacamole also includes

00:23:51,090 --> 00:23:55,470
additional tooling they'll show but this

00:23:52,770 --> 00:23:57,150
is the core of it so going back to what

00:23:55,470 --> 00:23:58,799
I said it was it is a complete

00:23:57,150 --> 00:24:00,929
specification based now you've seen the

00:23:58,799 --> 00:24:02,640
specification it is unambiguous it is

00:24:00,929 --> 00:24:05,340
fully static it does not need to run any

00:24:02,640 --> 00:24:08,010
begin blocks and it provides a toolkit

00:24:05,340 --> 00:24:09,780
if you write in what I just refer to a

00:24:08,010 --> 00:24:11,549
standard Perl so if you're right in it

00:24:09,780 --> 00:24:13,980
you get to use guacamole and if you

00:24:11,549 --> 00:24:16,110
don't that's okay Perl the interpreter

00:24:13,980 --> 00:24:19,200
will run it but what komali will say

00:24:16,110 --> 00:24:24,960
sorry I don't know this all right so how

00:24:19,200 --> 00:24:28,860
does it work the rundown we use

00:24:24,960 --> 00:24:31,140
to specify standard pearl P&F marpa uses

00:24:28,860 --> 00:24:34,170
the BNF to parse every pearl string it

00:24:31,140 --> 00:24:36,990
sees which must comply with this

00:24:34,170 --> 00:24:40,590
specification and welcome only using

00:24:36,990 --> 00:24:44,610
marker will return in ast which is an

00:24:40,590 --> 00:24:46,170
abstract syntax tree and you probably

00:24:44,610 --> 00:24:48,330
want to read email with smart but what

00:24:46,170 --> 00:24:50,430
are you talking about Jeffrey keg ler

00:24:48,330 --> 00:24:53,100
I'm sorry that you can't see the name

00:24:50,430 --> 00:24:56,430
Jeffrey kittler wrote Marfa he's written

00:24:53,100 --> 00:24:59,880
numerous articles on it it is excellent

00:24:56,430 --> 00:25:01,950
it's great I love it you can find first

00:24:59,880 --> 00:25:04,440
of all information here I really

00:25:01,950 --> 00:25:08,100
recommend it it is a parsing algorithm

00:25:04,440 --> 00:25:10,050
it's fast in linear time it will parse

00:25:08,100 --> 00:25:12,300
all the grammar classes that recursive

00:25:10,050 --> 00:25:14,850
descent parsers in the grammar class

00:25:12,300 --> 00:25:17,160
that the Yak family parses it can even

00:25:14,850 --> 00:25:19,370
parse an ambiguous grammar so we can

00:25:17,160 --> 00:25:21,960
parse things into more than one option

00:25:19,370 --> 00:25:23,880
so theoretically you could parse all of

00:25:21,960 --> 00:25:26,220
these cases and say it could be this it

00:25:23,880 --> 00:25:29,100
could be that but obviously that

00:25:26,220 --> 00:25:30,840
wouldn't be linear time it receives a

00:25:29,100 --> 00:25:33,390
specification BNF and applies that

00:25:30,840 --> 00:25:36,150
algorithm so it generates a parser from

00:25:33,390 --> 00:25:39,720
the BNF if you've used any other parts

00:25:36,150 --> 00:25:42,090
or it's difficult and with with marpa

00:25:39,720 --> 00:25:43,470
you can really write a full-fledged BNF

00:25:42,090 --> 00:25:46,320
and you get a full parser back in this

00:25:43,470 --> 00:25:47,940
it's great and you can customize every

00:25:46,320 --> 00:25:49,920
single bit of it so you can customize

00:25:47,940 --> 00:25:53,460
every node you can write a lot of code

00:25:49,920 --> 00:25:55,500
before after during you can even receive

00:25:53,460 --> 00:25:57,630
a response that it couldn't do something

00:25:55,500 --> 00:25:59,130
and it doesn't know what to do and then

00:25:57,630 --> 00:26:00,480
you can try to fix it and go oh you know

00:25:59,130 --> 00:26:02,610
what then you should do this and then

00:26:00,480 --> 00:26:04,320
you can iterative lis parse with the

00:26:02,610 --> 00:26:07,530
back and forth with the parser which is

00:26:04,320 --> 00:26:10,080
just amazing so it's it's great

00:26:07,530 --> 00:26:12,030
Jeffrey we reached out to him and we

00:26:10,080 --> 00:26:14,190
spoke to him and provided feedback he is

00:26:12,030 --> 00:26:15,420
he's very helpful if you're interested

00:26:14,190 --> 00:26:17,900
in mark ruther if you're interesting its

00:26:15,420 --> 00:26:22,130
development you could also donate to it

00:26:17,900 --> 00:26:25,230
alright so what does the ast look like

00:26:22,130 --> 00:26:27,450
this is a tool that we have to provide

00:26:25,230 --> 00:26:29,580
explanation we give it a string and then

00:26:27,450 --> 00:26:31,680
it gives us the ast now they see that we

00:26:29,580 --> 00:26:34,440
have provided it's a lot of data and

00:26:31,680 --> 00:26:36,720
we're gonna clean it up but at the

00:26:34,440 --> 00:26:38,370
moment this is what you're gonna get if

00:26:36,720 --> 00:26:40,110
you give it phoo

00:26:38,370 --> 00:26:42,540
equals 1 you're gonna get this entire

00:26:40,110 --> 00:26:45,059
thing there's quite a bit here I want to

00:26:42,540 --> 00:26:47,460
point out specifically the dollar or the

00:26:45,059 --> 00:26:49,830
food the equal and the 1 so these are

00:26:47,460 --> 00:26:51,420
the actual values that you were seeing

00:26:49,830 --> 00:26:54,510
in the input string without the

00:26:51,420 --> 00:26:56,820
whitespace now if I were to draw that

00:26:54,510 --> 00:26:59,160
AST that you just saw because it's

00:26:56,820 --> 00:27:02,490
actually a tree it's an abstract syntax

00:26:59,160 --> 00:27:04,920
tree you're it represents what we wrote

00:27:02,490 --> 00:27:07,230
so it serves with the program program

00:27:04,920 --> 00:27:08,640
has a statement sequence then within

00:27:07,230 --> 00:27:10,860
that sequence there is one statement

00:27:08,640 --> 00:27:15,210
which is an expression of assignment

00:27:10,860 --> 00:27:17,370
that is equal then on one side of it

00:27:15,210 --> 00:27:19,110
you'll have a value which is then it

00:27:17,370 --> 00:27:21,240
this is our specification so it's a

00:27:19,110 --> 00:27:24,420
value it's a non literal value it is a

00:27:21,240 --> 00:27:28,620
variable value and that is a variable

00:27:24,420 --> 00:27:31,320
and scalar and that is a dollar it also

00:27:28,620 --> 00:27:34,679
parts it to a variable identifier

00:27:31,320 --> 00:27:37,590
expression and that is food on the other

00:27:34,679 --> 00:27:41,550
side of the equal value it is a literal

00:27:37,590 --> 00:27:44,220
value and is a number and that would be

00:27:41,550 --> 00:27:47,250
equal to 1 and this is how you actually

00:27:44,220 --> 00:27:48,840
get this dollar foo equals 1 a generous

00:27:47,250 --> 00:27:49,950
this tree where there's an equal to top

00:27:48,840 --> 00:27:52,080
and then on one side of it there's

00:27:49,950 --> 00:27:54,210
dollar and no side of it there's one and

00:27:52,080 --> 00:27:56,280
you can actually walk that tree and what

00:27:54,210 --> 00:27:58,260
probe would do Perl generates something

00:27:56,280 --> 00:27:59,820
like this except row needs to run a

00:27:58,260 --> 00:28:02,160
bunch of stuff in order to determine

00:27:59,820 --> 00:28:05,670
what this really is and in some cases it

00:28:02,160 --> 00:28:06,690
determines some of it so probably

00:28:05,670 --> 00:28:08,309
generate this and then probe will

00:28:06,690 --> 00:28:09,450
basically walk this and say ok if I have

00:28:08,309 --> 00:28:12,270
an equal I have this and I have this

00:28:09,450 --> 00:28:14,990
then I'm gonna you know apply these and

00:28:12,270 --> 00:28:16,830
create some kind of C structure and

00:28:14,990 --> 00:28:18,750
these Bartz

00:28:16,830 --> 00:28:26,040
are called alexinnz the rest are called

00:28:18,750 --> 00:28:29,940
rules these are really delicious so what

00:28:26,040 --> 00:28:30,630
could you use welcome only 4 so things

00:28:29,940 --> 00:28:32,580
you could do with it

00:28:30,630 --> 00:28:35,100
first you could improve quality you

00:28:32,580 --> 00:28:36,780
could write and maintain all these code

00:28:35,100 --> 00:28:39,750
policy stuff like per critic you could

00:28:36,780 --> 00:28:42,840
do with guacamole you could spot

00:28:39,750 --> 00:28:45,360
duplications and refactor your code you

00:28:42,840 --> 00:28:47,760
could do some automatic rewriting which

00:28:45,360 --> 00:28:49,920
is really nice and of course you can

00:28:47,760 --> 00:28:52,200
transpile languages which i think is

00:28:49,920 --> 00:28:53,669
really nice so I'm gonna go into each

00:28:52,200 --> 00:28:58,289
separately we're gonna start with

00:28:53,669 --> 00:29:01,970
linting let me just make sure I'm on

00:28:58,289 --> 00:29:01,970
time yeah I'm doing good

00:29:02,000 --> 00:29:12,230
okay so linting pro critic is the de

00:29:07,470 --> 00:29:14,700
facto winter and uses ppi to parse Perl

00:29:12,230 --> 00:29:17,850
files this document so it does actually

00:29:14,700 --> 00:29:19,409
understand a tree structure it

00:29:17,850 --> 00:29:21,029
understands this document that says I

00:29:19,409 --> 00:29:22,740
have a whitespace character I have a

00:29:21,029 --> 00:29:28,139
string here and I think it's gonna be a

00:29:22,740 --> 00:29:31,529
word and in the things that's PPI itself

00:29:28,139 --> 00:29:33,419
is very vague and that's difficult it

00:29:31,529 --> 00:29:36,210
works really really really really hard

00:29:33,419 --> 00:29:38,190
to get to where it is I saw one full

00:29:36,210 --> 00:29:40,289
request that weak entity roads for PPI

00:29:38,190 --> 00:29:43,080
when we were writing policies that work

00:29:40,289 --> 00:29:46,440
because we work together and it was it

00:29:43,080 --> 00:29:47,880
was over my head and PPI obviously is

00:29:46,440 --> 00:29:49,889
not an AC it's not a tree it's just

00:29:47,880 --> 00:29:52,200
document so you need to walk through a

00:29:49,889 --> 00:29:55,769
document but there's no not much of a

00:29:52,200 --> 00:29:58,380
relationship between them now PPR is a

00:29:55,769 --> 00:30:00,299
different thing it's very very strong it

00:29:58,380 --> 00:30:03,269
was written by Damon Conway so it's

00:30:00,299 --> 00:30:05,250
obviously brilliant as the man is and it

00:30:03,269 --> 00:30:07,320
really really really is amazing so you

00:30:05,250 --> 00:30:09,929
should check that out of a per critic is

00:30:07,320 --> 00:30:11,880
based on PPI instead be Peretz pure is a

00:30:09,929 --> 00:30:17,340
pure pearl so all this specification

00:30:11,880 --> 00:30:20,159
done in like really vast intricate reg

00:30:17,340 --> 00:30:22,710
X's and it supports way more than

00:30:20,159 --> 00:30:27,659
welcome only supports FYI because it's

00:30:22,710 --> 00:30:29,789
it's Damien now linting instead of using

00:30:27,659 --> 00:30:32,429
PPI per critic could theoretically use

00:30:29,789 --> 00:30:34,950
welcome multi it helps implement more

00:30:32,429 --> 00:30:39,480
complicated policies and it is much

00:30:34,950 --> 00:30:41,399
easier to do that so the only problem of

00:30:39,480 --> 00:30:43,649
course is that it could only then work

00:30:41,399 --> 00:30:46,250
with things that are standard pearl but

00:30:43,649 --> 00:30:49,260
it will definitely be more accurate and

00:30:46,250 --> 00:30:50,789
ban syntax obviously doesn't parse so

00:30:49,260 --> 00:30:53,399
you don't need to work around it we have

00:30:50,789 --> 00:30:58,169
quite a few policies on pro critic for

00:30:53,399 --> 00:31:01,080
syntax that is an unprecedented ik

00:30:58,169 --> 00:31:02,850
things that that don't work or shouldn't

00:31:01,080 --> 00:31:04,790
work they're just bad code too badly

00:31:02,850 --> 00:31:06,500
written but probe will parse it

00:31:04,790 --> 00:31:08,840
we'll either understand it and do

00:31:06,500 --> 00:31:11,090
something or it will not understand and

00:31:08,840 --> 00:31:12,920
do something else but because this is a

00:31:11,090 --> 00:31:14,240
specification for correct code it

00:31:12,920 --> 00:31:16,880
doesn't mean that it's good code but it

00:31:14,240 --> 00:31:18,620
is correct code I don't even need these

00:31:16,880 --> 00:31:19,820
policies I was trying to rewrite some of

00:31:18,620 --> 00:31:22,150
them and I realized some of these I

00:31:19,820 --> 00:31:25,070
don't even need she's great chop those

00:31:22,150 --> 00:31:27,470
the correct syntax is fully identifiable

00:31:25,070 --> 00:31:31,910
in PPI it's very common to say this is a

00:31:27,470 --> 00:31:34,430
word oh that's very good but what is

00:31:31,910 --> 00:31:35,960
this what is this word so it doesn't

00:31:34,430 --> 00:31:38,930
really know in most cases elements are

00:31:35,960 --> 00:31:41,000
unambiguous with welcome Olli

00:31:38,930 --> 00:31:42,890
there is no maybe it's this thing maybe

00:31:41,000 --> 00:31:44,600
it's that thing and you don't need to

00:31:42,890 --> 00:31:46,430
account for different coding styles and

00:31:44,600 --> 00:31:49,130
spacing which is something that I have

00:31:46,430 --> 00:31:52,010
to continuously do because someone might

00:31:49,130 --> 00:31:55,790
have written in a really arcane pattern

00:31:52,010 --> 00:31:58,340
and they that's just they just did so

00:31:55,790 --> 00:32:00,500
now I have to account for that case this

00:31:58,340 --> 00:32:02,750
is an example of difficulties with PPI

00:32:00,500 --> 00:32:06,410
I'm getting the next sub so I'm checking

00:32:02,750 --> 00:32:07,850
if there is no next significant sibling

00:32:06,410 --> 00:32:10,310
which means I think has to jump over the

00:32:07,850 --> 00:32:11,960
spacing and but there isn't a next token

00:32:10,310 --> 00:32:13,460
that I need to exhaust the spaces which

00:32:11,960 --> 00:32:15,950
is like a copy-paste line that I have

00:32:13,460 --> 00:32:17,240
everywhere and then I need to move to

00:32:15,950 --> 00:32:19,910
the next okay and then it can continue

00:32:17,240 --> 00:32:21,740
from there this is a piece of code that

00:32:19,910 --> 00:32:24,830
I wrote it's not not that complicated to

00:32:21,740 --> 00:32:26,360
understand here as you can see is just

00:32:24,830 --> 00:32:28,550
like this thing a copy-paste all the

00:32:26,360 --> 00:32:33,230
time these are the comments that I have

00:32:28,550 --> 00:32:35,180
for it I this checks that you wrote for

00:32:33,230 --> 00:32:36,800
and then you wrote class and then you

00:32:35,180 --> 00:32:40,310
rewrote method and then you wrote foo

00:32:36,800 --> 00:32:42,680
and it needs to do all of this so it

00:32:40,310 --> 00:32:44,630
actually has to like I need the idea of

00:32:42,680 --> 00:32:46,040
this in in front of me because it is

00:32:44,630 --> 00:32:48,410
very hard for me to understand what this

00:32:46,040 --> 00:32:50,030
code is even meant to do because you

00:32:48,410 --> 00:32:52,040
would think this is a simple code of

00:32:50,030 --> 00:32:54,440
course you would remember no I wouldn't

00:32:52,040 --> 00:32:56,660
there's this code this code checks I

00:32:54,440 --> 00:33:01,280
don't I called it check if it's a symbol

00:32:56,660 --> 00:33:03,350
or a caste because it is PPI doesn't

00:33:01,280 --> 00:33:05,090
tell me which one it is and when he

00:33:03,350 --> 00:33:06,680
tries to it could get it wrong so

00:33:05,090 --> 00:33:08,480
actually had to wrote custom code and

00:33:06,680 --> 00:33:11,420
the custom code says take this argument

00:33:08,480 --> 00:33:14,540
if it's symbol and it begins with a

00:33:11,420 --> 00:33:17,380
percent or it is a caste but is

00:33:14,540 --> 00:33:19,510
definitely only a percent then

00:33:17,380 --> 00:33:21,610
okay then then continue working

00:33:19,510 --> 00:33:23,890
otherwise just stop then you need to get

00:33:21,610 --> 00:33:25,930
the next significant sibling because we

00:33:23,890 --> 00:33:29,890
might get a space then check if that is

00:33:25,930 --> 00:33:31,870
a cast and if the one after that is a

00:33:29,890 --> 00:33:34,840
block and if so then the one after that

00:33:31,870 --> 00:33:36,610
is the next significant then I need to

00:33:34,840 --> 00:33:38,290
check for more operators to check the

00:33:36,610 --> 00:33:42,880
next one as an OP and if so return

00:33:38,290 --> 00:33:44,770
otherwise yes I'm not sure how this

00:33:42,880 --> 00:33:46,870
works to be honest FC I'm just looking

00:33:44,770 --> 00:33:50,110
at this a little while ago I have no

00:33:46,870 --> 00:33:51,790
idea how this works okay more linting

00:33:50,110 --> 00:33:54,520
I'm gonna have to go even faster so

00:33:51,790 --> 00:33:55,270
there's no Oh someone maybe they're

00:33:54,520 --> 00:33:56,740
writing that one

00:33:55,270 --> 00:33:59,350
there's no Orion to figure out what this

00:33:56,740 --> 00:34:01,210
is this is the most common PPI token in

00:33:59,350 --> 00:34:04,540
almost every case you get this one and

00:34:01,210 --> 00:34:06,310
you don't know what it is did they write

00:34:04,540 --> 00:34:07,840
it was a distant X or was it that one

00:34:06,310 --> 00:34:10,300
maybe there's a space he said it could

00:34:07,840 --> 00:34:13,540
be a new line so okay let's put this is

00:34:10,300 --> 00:34:14,950
a duplication detection this is really

00:34:13,540 --> 00:34:17,620
really cool so I want to show them this

00:34:14,950 --> 00:34:20,200
idea with the guacamole with obviously

00:34:17,620 --> 00:34:21,370
the more power it will return a tree it

00:34:20,200 --> 00:34:23,560
will return like this all these

00:34:21,370 --> 00:34:25,629
operations and what it could do is I can

00:34:23,560 --> 00:34:27,129
also take some elements and fold them so

00:34:25,629 --> 00:34:29,020
I can basically say oh I'm seeing these

00:34:27,129 --> 00:34:31,450
I'm gonna check all these out and then

00:34:29,020 --> 00:34:33,610
eventually it can compare these trees of

00:34:31,450 --> 00:34:36,040
code and I know if they've the trees are

00:34:33,610 --> 00:34:37,899
correct it is a hard percent crowd so

00:34:36,040 --> 00:34:39,100
this is really nice and then you can

00:34:37,899 --> 00:34:41,409
detect trees that while they are

00:34:39,100 --> 00:34:43,510
different trees semantically they

00:34:41,409 --> 00:34:45,429
actually are the same idea they do the

00:34:43,510 --> 00:34:46,780
same thing and if you do that you can

00:34:45,429 --> 00:34:49,270
also detect the trees that are not

00:34:46,780 --> 00:34:50,679
optimized it's really also really cool

00:34:49,270 --> 00:34:53,379
and then you couldn't rewrite that using

00:34:50,679 --> 00:34:55,870
a different tree and write code instead

00:34:53,379 --> 00:34:59,350
that is optimized so this is an example

00:34:55,870 --> 00:35:02,860
of folding elements in the AST I'm using

00:34:59,350 --> 00:35:05,230
the tools explained one for items and

00:35:02,860 --> 00:35:07,720
I'm getting this nice output back it

00:35:05,230 --> 00:35:09,850
shows me all the elements in now this is

00:35:07,720 --> 00:35:12,490
an example I have been here it's under I

00:35:09,850 --> 00:35:14,740
renamed it correctly so now I'm trying

00:35:12,490 --> 00:35:16,690
to do one for items again and I'm

00:35:14,740 --> 00:35:18,220
getting a different one now if you know

00:35:16,690 --> 00:35:21,490
that the difference the difference

00:35:18,220 --> 00:35:23,020
really is is this there's parentheses

00:35:21,490 --> 00:35:24,280
here but it's significantly different

00:35:23,020 --> 00:35:26,710
trees because one generates an

00:35:24,280 --> 00:35:28,480
expression an additional expression and

00:35:26,710 --> 00:35:30,310
if I look for it I can actually find her

00:35:28,480 --> 00:35:31,250
right there there's a parental a

00:35:30,310 --> 00:35:33,950
parentheses

00:35:31,250 --> 00:35:36,560
expression which has a lexeme of a left

00:35:33,950 --> 00:35:40,970
paren then an expression value and then

00:35:36,560 --> 00:35:42,230
a right paren if I remove those and say

00:35:40,970 --> 00:35:43,760
well you know what those are the same

00:35:42,230 --> 00:35:45,710
having him not having is the same code

00:35:43,760 --> 00:35:46,970
and a folder I get this root zone and

00:35:45,710 --> 00:35:48,980
then obviously I have a value in on

00:35:46,970 --> 00:35:51,320
literal value not literal this is

00:35:48,980 --> 00:35:54,560
unnecessary so I can remove one of them

00:35:51,320 --> 00:35:59,570
and then I folded that and now these are

00:35:54,560 --> 00:36:02,360
equivalent which means that I could find

00:35:59,570 --> 00:36:05,330
this as a duplicate right this is really

00:36:02,360 --> 00:36:08,870
cool all right

00:36:05,330 --> 00:36:11,660
Oh Triss piling between languages I

00:36:08,870 --> 00:36:13,760
think is also really really nice so if

00:36:11,660 --> 00:36:15,530
you understand I'm actually having done

00:36:13,760 --> 00:36:17,960
this so it's this theory if you

00:36:15,530 --> 00:36:20,990
understand every operation and value in

00:36:17,960 --> 00:36:23,270
the code then you can rewrite it in a

00:36:20,990 --> 00:36:25,580
different language you can optimize it

00:36:23,270 --> 00:36:28,340
by replacing one tree with the other you

00:36:25,580 --> 00:36:31,970
can convert between languages so you can

00:36:28,340 --> 00:36:35,420
move Perl to see just rewrite it you can

00:36:31,970 --> 00:36:38,930
read it in C++ or and go in Java Ruby

00:36:35,420 --> 00:36:40,160
yeah or in Morocco now of course you

00:36:38,930 --> 00:36:41,810
might lose some of the strength of one

00:36:40,160 --> 00:36:43,820
language and another so if I were to

00:36:41,810 --> 00:36:46,160
read Rocko and try to output pearl I

00:36:43,820 --> 00:36:47,420
would actually have to for quite a few

00:36:46,160 --> 00:36:50,390
things I would have to put away more

00:36:47,420 --> 00:36:52,790
effort but if I were to convert Perl to

00:36:50,390 --> 00:36:56,450
rocku that will probably be easy because

00:36:52,790 --> 00:36:58,130
Rocko can express Perl fairly easily but

00:36:56,450 --> 00:37:01,690
then if I were to convert Perl to see

00:36:58,130 --> 00:37:01,690
I'll ever have to write a lot of C so

00:37:01,810 --> 00:37:10,190
LVM of course maybe convert JavaScript

00:37:07,120 --> 00:37:12,560
good to note here the wit-pro bahuka and

00:37:10,190 --> 00:37:14,290
you could find it in web pearls your Jew

00:37:12,560 --> 00:37:17,960
because that is already available and

00:37:14,290 --> 00:37:20,060
Ram also gave a talk about what was

00:37:17,960 --> 00:37:21,860
simply that you can fight right there so

00:37:20,060 --> 00:37:25,450
I really recommend checking his work and

00:37:21,860 --> 00:37:28,220
how his work automatic rewriting

00:37:25,450 --> 00:37:29,930
basically it simple you identify crappy

00:37:28,220 --> 00:37:31,940
countries and you rewrite it as good

00:37:29,930 --> 00:37:33,560
cook and that's it and that is equal to

00:37:31,940 --> 00:37:35,450
profit because that might be faster let

00:37:33,560 --> 00:37:38,090
me give you an example this is code that

00:37:35,450 --> 00:37:40,550
I have actually seen at work in more

00:37:38,090 --> 00:37:42,860
than one company ok we do it for each

00:37:40,550 --> 00:37:44,990
then we have tags that we're getting

00:37:42,860 --> 00:37:47,660
from the database where check

00:37:44,990 --> 00:37:49,970
if a person has these tats and if he

00:37:47,660 --> 00:37:54,619
does or she does we will do something

00:37:49,970 --> 00:37:56,839
about that so that specific line for the

00:37:54,619 --> 00:37:59,900
DB search is not using the person that

00:37:56,839 --> 00:38:02,810
we're iterating on this is an ID which

00:37:59,900 --> 00:38:04,400
means that it will run every time and if

00:38:02,810 --> 00:38:06,800
that search is heavy then we're running

00:38:04,400 --> 00:38:08,480
a ton of queries what we actually want

00:38:06,800 --> 00:38:11,810
is to pull out all the way up there and

00:38:08,480 --> 00:38:13,250
then just use that data so this is an

00:38:11,810 --> 00:38:17,109
example of something you could detect

00:38:13,250 --> 00:38:19,040
with trees more easily than with strings

00:38:17,109 --> 00:38:22,160
this is an example of something I

00:38:19,040 --> 00:38:23,750
actually had to write in PPI I actually

00:38:22,160 --> 00:38:26,270
wrote this it's available as refuge

00:38:23,750 --> 00:38:27,830
Hilary writer but it's a lot of work

00:38:26,270 --> 00:38:31,180
there's a lot of comments just to

00:38:27,830 --> 00:38:34,310
understand what I'm supposed to do there

00:38:31,180 --> 00:38:37,160
okay what else do we have

00:38:34,310 --> 00:38:40,820
so Vacanti and I have written a few

00:38:37,160 --> 00:38:45,800
development tools first other than the

00:38:40,820 --> 00:38:47,510
parser itself we wrote a parser the

00:38:45,800 --> 00:38:49,339
parser itself is a hundred percent like

00:38:47,510 --> 00:38:52,790
it is working you can pick it up you can

00:38:49,339 --> 00:38:54,560
try it it's on Sipan now we also wrote a

00:38:52,790 --> 00:38:56,540
pragma this is really cool

00:38:54,560 --> 00:38:59,960
if you go to Sipan you also have use

00:38:56,540 --> 00:39:01,910
standard i'm going to show that later we

00:38:59,960 --> 00:39:03,680
also wrote a linter so similar to per

00:39:01,910 --> 00:39:05,660
critic it's a minimum limitation and

00:39:03,680 --> 00:39:07,310
there's an example of a rewrite so it's

00:39:05,660 --> 00:39:09,440
kind of cool that you can use to also

00:39:07,310 --> 00:39:11,810
rewrite some stuff there's also a

00:39:09,440 --> 00:39:16,369
policies and examples you could play

00:39:11,810 --> 00:39:18,740
with those and there's a deep parser

00:39:16,369 --> 00:39:20,359
that is used for the rewriter so in

00:39:18,740 --> 00:39:22,190
basically the original version just took

00:39:20,359 --> 00:39:24,770
all of the luxans and just printed them

00:39:22,190 --> 00:39:28,040
out and then you would do that but we've

00:39:24,770 --> 00:39:31,550
improved it the parser allows you to

00:39:28,040 --> 00:39:34,099
tokenize and generate the AST so top

00:39:31,550 --> 00:39:37,310
marks for Vacanti rewriting it at least

00:39:34,099 --> 00:39:40,820
twice or three times after arrays the

00:39:37,310 --> 00:39:42,890
bug that I had no idea how to solve it

00:39:40,820 --> 00:39:45,050
helps enforce the standard using the

00:39:42,890 --> 00:39:47,599
problem so if you want your team or you

00:39:45,050 --> 00:39:49,970
want your code to be standardized and to

00:39:47,599 --> 00:39:51,500
always use this nice syntax you can use

00:39:49,970 --> 00:39:53,180
the pragma and it will make sure that

00:39:51,500 --> 00:39:55,130
you're always within that standard this

00:39:53,180 --> 00:39:58,060
pragma will not be going into court it

00:39:55,130 --> 00:40:00,190
is irrelevant to court

00:39:58,060 --> 00:40:02,890
there's a linter that allows you to

00:40:00,190 --> 00:40:04,510
maintain code quality and the parser

00:40:02,890 --> 00:40:07,750
along with the rewriter allowed us to

00:40:04,510 --> 00:40:08,890
semantically rewrite to cook here's an

00:40:07,750 --> 00:40:11,170
example of the parser

00:40:08,890 --> 00:40:15,220
you can just do welcome to parse you get

00:40:11,170 --> 00:40:17,290
an ast back you get the purser element

00:40:15,220 --> 00:40:19,810
so you basically get this element that

00:40:17,290 --> 00:40:22,000
has the column the length the line the

00:40:19,810 --> 00:40:24,400
name the start position and the type and

00:40:22,000 --> 00:40:27,610
all of the children so this is for every

00:40:24,400 --> 00:40:29,590
rule element you actually know which

00:40:27,610 --> 00:40:32,320
line the rule is on which column the

00:40:29,590 --> 00:40:34,330
rule is on how long the rule is what

00:40:32,320 --> 00:40:35,380
type of rule in it what is the name of

00:40:34,330 --> 00:40:38,920
that rule and all of the children

00:40:35,380 --> 00:40:42,040
related that rule and we have a lexeme

00:40:38,920 --> 00:40:44,380
that has a value and a type the name

00:40:42,040 --> 00:40:46,660
here does exist and it is empty so you

00:40:44,380 --> 00:40:48,190
wouldn't have to when you want to just

00:40:46,660 --> 00:40:51,070
compare names you wouldn't have to check

00:40:48,190 --> 00:40:53,290
whether it is a lexan or a rule first

00:40:51,070 --> 00:40:56,230
because I hated doing that so I added an

00:40:53,290 --> 00:40:58,870
empty name you standard the program is

00:40:56,230 --> 00:41:00,430
also on Sipan and if you turn on use

00:40:58,870 --> 00:41:01,690
standard it basically grabs all the code

00:41:00,430 --> 00:41:03,490
runs it through the parser and then

00:41:01,690 --> 00:41:05,800
tells you if there's a mistake let me

00:41:03,490 --> 00:41:08,740
give you an example my class new class

00:41:05,800 --> 00:41:10,600
is not supported under standard or but

00:41:08,740 --> 00:41:13,060
if you try to use the Perl interpreter

00:41:10,600 --> 00:41:15,850
with it and we're gonna use BD parse

00:41:13,060 --> 00:41:17,410
here to check it what it's gonna do is

00:41:15,850 --> 00:41:19,120
tell you this is class and then there's

00:41:17,410 --> 00:41:22,180
a string class calling you this is what

00:41:19,120 --> 00:41:25,020
I understand now if you were to add your

00:41:22,180 --> 00:41:27,880
standard now you're gonna have a problem

00:41:25,020 --> 00:41:30,250
because it's gonna say file does not

00:41:27,880 --> 00:41:31,240
pass standard Pro the parser says and

00:41:30,250 --> 00:41:33,280
there's like a bunch of stuff from the

00:41:31,240 --> 00:41:35,620
parser and he will also say I failed to

00:41:33,280 --> 00:41:38,380
parse past a certain point and then it

00:41:35,620 --> 00:41:40,150
gives you the rest of it so the stuff

00:41:38,380 --> 00:41:41,620
from the BD parse will still work it

00:41:40,150 --> 00:41:45,100
didn't actually break the program he

00:41:41,620 --> 00:41:46,900
didn't um exit it but he does tell you

00:41:45,100 --> 00:41:48,880
they didn't pass it just tell you what

00:41:46,900 --> 00:41:50,500
actually happened where it stopped what

00:41:48,880 --> 00:41:53,140
he expected which is super useful

00:41:50,500 --> 00:41:55,120
because you could say it got to new and

00:41:53,140 --> 00:41:57,100
then he had a problem and he will even

00:41:55,120 --> 00:41:59,830
say I actually after new expected one of

00:41:57,100 --> 00:42:02,590
the following things to happen so let's

00:41:59,830 --> 00:42:05,230
say we write it this way that will still

00:42:02,590 --> 00:42:07,540
our work and it will tell you hey no no

00:42:05,230 --> 00:42:10,540
I understand class I understand arrow I

00:42:07,540 --> 00:42:11,920
understand new but here I expect either

00:42:10,540 --> 00:42:13,690
a left parent

00:42:11,920 --> 00:42:15,460
and then probably arguments and right

00:42:13,690 --> 00:42:18,579
parenthesis or a packet separator

00:42:15,460 --> 00:42:22,450
because you can call new : : something

00:42:18,579 --> 00:42:24,940
else I mean if I add those suddenly this

00:42:22,450 --> 00:42:27,549
will work just fine what complaints no

00:42:24,940 --> 00:42:31,809
nothing this is an example of the linter

00:42:27,549 --> 00:42:33,579
it's a object-oriented structure just

00:42:31,809 --> 00:42:35,740
because I wanted to play with stuff like

00:42:33,579 --> 00:42:37,720
that so this syntax might change as it

00:42:35,740 --> 00:42:39,430
evolves but basically you'd linked okay

00:42:37,720 --> 00:42:42,460
link not okay you can have the policy

00:42:39,430 --> 00:42:43,089
and then prints out in tap okay or not

00:42:42,460 --> 00:42:46,410
okay

00:42:43,089 --> 00:42:49,450
whether it was able to understand or not

00:42:46,410 --> 00:42:51,250
this is example of the departure that

00:42:49,450 --> 00:42:53,980
you will have to use if you're writing a

00:42:51,250 --> 00:42:56,260
rewriter it is a form of reread or just

00:42:53,980 --> 00:42:58,059
a very clean one this is an example

00:42:56,260 --> 00:43:00,010
where we give it a deep part of the

00:42:58,059 --> 00:43:02,079
string and it has a lot of spaces in it

00:43:00,010 --> 00:43:04,540
and lack of spaces in it and what it

00:43:02,079 --> 00:43:06,700
does is just print it out really nicely

00:43:04,540 --> 00:43:10,210
you could be much smarter about this and

00:43:06,700 --> 00:43:13,900
say if there are if there is only one

00:43:10,210 --> 00:43:16,450
argument in the expression I'm gonna put

00:43:13,900 --> 00:43:18,760
the parentheses a bit closer if there is

00:43:16,450 --> 00:43:20,230
nothing within the braces I'm actually

00:43:18,760 --> 00:43:21,280
not gonna have a space there's like a

00:43:20,230 --> 00:43:25,000
bunch of stuff you could do like that

00:43:21,280 --> 00:43:27,339
and it's fairly easy to do them now I

00:43:25,000 --> 00:43:29,530
reach the end of the talk it's it was

00:43:27,339 --> 00:43:31,780
quite long quite exhausting quite fast

00:43:29,530 --> 00:43:33,880
but I owe a lot of things and we can

00:43:31,780 --> 00:43:36,609
Tio's a lot of things with me to all

00:43:33,880 --> 00:43:38,680
these people so my personal thanks first

00:43:36,609 --> 00:43:40,960
goes to Vic NT who's not able to talk

00:43:38,680 --> 00:43:42,250
because he put himself on mute and he

00:43:40,960 --> 00:43:44,020
would probably be too shy so I get a

00:43:42,250 --> 00:43:45,970
chance to say that it is incredible to

00:43:44,020 --> 00:43:49,240
work with this person he is brilliant

00:43:45,970 --> 00:43:51,099
and and I feel like I got to play with

00:43:49,240 --> 00:43:53,430
the thing that he created and then I get

00:43:51,099 --> 00:43:57,599
to talk about it but it really is his

00:43:53,430 --> 00:44:00,849
his abilities that that brought us here

00:43:57,599 --> 00:44:03,160
Damion Conway has been a tremendous help

00:44:00,849 --> 00:44:05,290
in spotting everything that could go

00:44:03,160 --> 00:44:07,890
wrong and going to great depth to

00:44:05,290 --> 00:44:10,869
explain to me why I don't understand and

00:44:07,890 --> 00:44:13,150
he's been very patient because I've had

00:44:10,869 --> 00:44:14,530
a lot of back and forth and oh but what

00:44:13,150 --> 00:44:17,710
if we were to do this or what if you

00:44:14,530 --> 00:44:19,359
were to do that and Damon's like no man

00:44:17,710 --> 00:44:19,950
no that's not good no that's not gonna

00:44:19,359 --> 00:44:22,420
happen

00:44:19,950 --> 00:44:24,250
Geoffrey Cutler has been very supportive

00:44:22,420 --> 00:44:25,160
is available as well and very helpful

00:44:24,250 --> 00:44:27,260
and and hoped

00:44:25,160 --> 00:44:28,940
understand quite a few more complicated

00:44:27,260 --> 00:44:31,280
patterns and how to avoid them and

00:44:28,940 --> 00:44:32,839
understand parsers better I will say

00:44:31,280 --> 00:44:34,160
that it was more sleep for me because

00:44:32,839 --> 00:44:36,619
Mackenzie does understand them

00:44:34,160 --> 00:44:39,140
Gonzaga thumb is is a colleague and a

00:44:36,619 --> 00:44:41,180
dear dear dear friend who also is very

00:44:39,140 --> 00:44:43,119
strong with this topic so he was able to

00:44:41,180 --> 00:44:46,970
enlighten us to quite a few things and

00:44:43,119 --> 00:44:49,099
tux was helpful by giving me a very

00:44:46,970 --> 00:44:51,559
large piece of code and saying try to

00:44:49,099 --> 00:44:53,089
see if it works and we spotted quite a

00:44:51,559 --> 00:44:55,250
few bugs with it so - thank you for

00:44:53,089 --> 00:44:57,170
always jumping in and saying I'll give

00:44:55,250 --> 00:44:59,299
you something to play with to see if

00:44:57,170 --> 00:45:02,630
your your thing will predict or not so

00:44:59,299 --> 00:45:05,960
that is for our talk thank you very much

00:45:02,630 --> 00:45:09,049
from both Vacanti and myself and that is

00:45:05,960 --> 00:45:10,789
the end thank you you can find standard

00:45:09,049 --> 00:45:12,170
on medicean you can find work emollient

00:45:10,789 --> 00:45:14,930
emergency vent and this github link

00:45:12,170 --> 00:45:16,520
should work within a few minutes after I

00:45:14,930 --> 00:45:19,700
finish the talk because it's currently

00:45:16,520 --> 00:45:27,260
named differently that is it I'm gonna

00:45:19,700 --> 00:45:33,140
do a stop on the share I think L Newkirk

00:45:27,260 --> 00:45:35,329
has a question so does anyone have any

00:45:33,140 --> 00:45:38,029
questions for either myself or Vic NT

00:45:35,329 --> 00:45:40,059
because he's on on the on the call as

00:45:38,029 --> 00:45:40,059
well

00:45:44,670 --> 00:45:50,040
I should actually open the participants

00:45:47,510 --> 00:45:55,010
and you could raise your handle I'll see

00:45:50,040 --> 00:45:57,809
it ok well I'll share because he's not

00:45:55,010 --> 00:46:01,440
his question was he wonders if guacamole

00:45:57,809 --> 00:46:04,730
parser ignores Todd and comments yes

00:46:01,440 --> 00:46:08,730
so specifically welcome only ignores it

00:46:04,730 --> 00:46:11,369
disregards spaces except where we forced

00:46:08,730 --> 00:46:13,559
it to recognize and not accept like with

00:46:11,369 --> 00:46:14,849
Q values if you do Q and then a space it

00:46:13,559 --> 00:46:17,400
will not disregard it it will actually

00:46:14,849 --> 00:46:20,970
break on purpose we do this with a few

00:46:17,400 --> 00:46:24,660
specific things but otherwise it ignores

00:46:20,970 --> 00:46:27,030
spaces it ignores comments and it

00:46:24,660 --> 00:46:29,160
ignores pod because pod is considered at

00:46:27,030 --> 00:46:31,680
least by me to be its own its own

00:46:29,160 --> 00:46:33,359
language and thus needs its own parser

00:46:31,680 --> 00:46:35,130
so just like probably basically you can

00:46:33,359 --> 00:46:37,200
over said you could write it in line at

00:46:35,130 --> 00:46:40,020
the end you could write the end you can

00:46:37,200 --> 00:46:43,440
read the data of those and it will just

00:46:40,020 --> 00:46:45,540
another one right it's really nice I see

00:46:43,440 --> 00:46:47,849
a question in chat is there any

00:46:45,540 --> 00:46:50,430
particular reason why the name guacamole

00:46:47,849 --> 00:46:52,589
was chosen it will be hard to Google

00:46:50,430 --> 00:46:58,680
given that there is Apache guacamole and

00:46:52,589 --> 00:47:01,650
normal guacamole right um yes it is not

00:46:58,680 --> 00:47:03,839
a good reason when we were playing with

00:47:01,650 --> 00:47:05,970
this idea about four years ago we were

00:47:03,839 --> 00:47:07,829
just trying to throw out like what kind

00:47:05,970 --> 00:47:11,700
of things are problematic for us if we

00:47:07,829 --> 00:47:14,430
wanted to to really um parse Pro with no

00:47:11,700 --> 00:47:16,799
ambiguity and we opened there I open the

00:47:14,430 --> 00:47:18,450
repo and get github just added this

00:47:16,799 --> 00:47:23,010
ability to kind of give you random names

00:47:18,450 --> 00:47:24,569
for repos to inspire creativity so i i

00:47:23,010 --> 00:47:26,220
picked a few and then it kind of tweaked

00:47:24,569 --> 00:47:28,559
it and it came up with reimagined

00:47:26,220 --> 00:47:30,780
guacamole because reimagined is like

00:47:28,559 --> 00:47:34,170
this really nice idea of rethinking it

00:47:30,780 --> 00:47:36,619
and then I like guacamole I am NOT

00:47:34,170 --> 00:47:39,809
adverse in any way to renaming it

00:47:36,619 --> 00:47:41,460
Vacanti and I the caddy I imagine is

00:47:39,809 --> 00:47:47,490
also quite open to whatever name we give

00:47:41,460 --> 00:47:49,589
it that makes sense so no strong no

00:47:47,490 --> 00:47:51,480
strong opinion there I do see that

00:47:49,589 --> 00:47:54,799
someone said that it is delicious and

00:47:51,480 --> 00:47:54,799
makes your code delicious so

00:47:57,560 --> 00:48:04,370
any any other questions

00:48:00,260 --> 00:48:09,800
oh I see someone asked about use

00:48:04,370 --> 00:48:13,490
constant foo 42 if you quote foo yes it

00:48:09,800 --> 00:48:16,190
will work but it will not recognize

00:48:13,490 --> 00:48:17,660
fruit from foo from that point on unless

00:48:16,190 --> 00:48:19,400
you use parentheses on it so if you want

00:48:17,660 --> 00:48:20,960
to use two constants you need to put

00:48:19,400 --> 00:48:22,370
parentheses on them which is personally

00:48:20,960 --> 00:48:27,620
what I do because like then I could

00:48:22,370 --> 00:48:29,720
avoid any conflicts with with constants

00:48:27,620 --> 00:48:36,050
and auto quoting in Perl and stuff like

00:48:29,720 --> 00:48:37,150
that and bear words obviously two people

00:48:36,050 --> 00:48:42,620
have their hands up

00:48:37,150 --> 00:48:46,400
William T okay

00:48:42,620 --> 00:48:49,610
yes William sorry I didn't I didn't see

00:48:46,400 --> 00:48:53,720
the symbol right William please yeah I

00:48:49,610 --> 00:48:56,090
was just curious with you standard would

00:48:53,720 --> 00:48:58,520
you leave that on in production running

00:48:56,090 --> 00:49:04,460
code how much sort of overhead does it

00:48:58,520 --> 00:49:04,910
add like on startup what not you found

00:49:04,460 --> 00:49:07,700
something

00:49:04,910 --> 00:49:08,930
yes currently it has more overhead than

00:49:07,700 --> 00:49:11,630
I would recommend to have in production

00:49:08,930 --> 00:49:14,060
code unless the code is being compiled

00:49:11,630 --> 00:49:16,400
and stored so for the code that I work

00:49:14,060 --> 00:49:22,730
on almost all of it gets uploaded to

00:49:16,400 --> 00:49:24,560
memory once every every a few times a

00:49:22,730 --> 00:49:27,890
day usually but that's it then it's up

00:49:24,560 --> 00:49:29,450
there so if I can just I pre load

00:49:27,890 --> 00:49:30,800
everything that I can and it just sits

00:49:29,450 --> 00:49:33,440
in memory and then I don't care if it

00:49:30,800 --> 00:49:36,590
took another two seconds but it is like

00:49:33,440 --> 00:49:40,070
it is like it can hit seconds in some

00:49:36,590 --> 00:49:42,710
cases so I want to look at how to parse

00:49:40,070 --> 00:49:44,510
it faster there are a lot of ways so

00:49:42,710 --> 00:49:47,360
we're gonna we're gonna optimize it at

00:49:44,510 --> 00:49:49,490
some point but one thing that we might

00:49:47,360 --> 00:49:51,140
do is maybe have a flag that says that

00:49:49,490 --> 00:49:54,880
only under development it runs you

00:49:51,140 --> 00:49:56,960
standard so that's that's an option

00:49:54,880 --> 00:49:58,880
similar to some of the testing stuff

00:49:56,960 --> 00:50:00,770
that Pro does any ideas you know that

00:49:58,880 --> 00:50:02,780
the github is there and please open it

00:50:00,770 --> 00:50:03,320
ticket I will rename it soon open a

00:50:02,780 --> 00:50:05,709
ticket and

00:50:03,320 --> 00:50:09,799
[Applause]

00:50:05,709 --> 00:50:11,179
I'll will review it we'll talk about it

00:50:09,799 --> 00:50:11,449
and find a good a good way to deal with

00:50:11,179 --> 00:50:17,719
it

00:50:11,449 --> 00:50:19,759
Rolf Lana yeah hi yeah sorry I have to

00:50:17,719 --> 00:50:21,619
apologize if it was us already because

00:50:19,759 --> 00:50:24,799
I'm catching up on YouTube

00:50:21,619 --> 00:50:27,289
you mentioned BD / BD parse is written

00:50:24,799 --> 00:50:34,429
in Perl and pass the OP tree did you

00:50:27,289 --> 00:50:38,059
consider using this yes BD parse

00:50:34,429 --> 00:50:40,159
requires compiling Perl which means they

00:50:38,059 --> 00:50:42,949
will run arbitrary code guacamole

00:50:40,159 --> 00:50:44,329
doesn't run any code zero okay

00:50:42,949 --> 00:50:47,509
other thing was because of the static

00:50:44,329 --> 00:50:49,639
part because we could it was also

00:50:47,509 --> 00:50:54,529
difficult it's also difficult to work

00:50:49,639 --> 00:50:57,889
with the B the whole B infrastructure

00:50:54,529 --> 00:50:59,989
the M the Oh infrastructure you get like

00:50:57,889 --> 00:51:01,759
a call back and it's if you look at the

00:50:59,989 --> 00:51:03,819
BT poor Scott it's it's difficult it's

00:51:01,759 --> 00:51:07,279
difficult and the me not that I know it

00:51:03,819 --> 00:51:09,079
you know what but maybe one could use if

00:51:07,279 --> 00:51:11,269
you're confident with running your code

00:51:09,079 --> 00:51:13,609
one could use BT parts to normalize the

00:51:11,269 --> 00:51:20,089
to you standard and then use your tool

00:51:13,609 --> 00:51:22,279
on the end yeah so yeah but then you to

00:51:20,089 --> 00:51:23,989
do that away as a BNF so you wouldn't

00:51:22,279 --> 00:51:27,079
have a standard so that doesn't fix it

00:51:23,989 --> 00:51:28,669
so even if I could do this it wouldn't

00:51:27,079 --> 00:51:31,519
really achieve the overall thing that I

00:51:28,669 --> 00:51:33,259
want cuz now a an ID written in Java I

00:51:31,519 --> 00:51:34,729
can say well I'm gonna take this pmf I'm

00:51:33,259 --> 00:51:37,069
gonna parse the code and then give

00:51:34,729 --> 00:51:38,299
better hints and better since I sigh and

00:51:37,069 --> 00:51:43,639
stuff like that I wouldn't do that with

00:51:38,299 --> 00:51:47,449
PD parts before Devon before I am I let

00:51:43,639 --> 00:51:51,619
you ask a question on the forum the the

00:51:47,449 --> 00:51:53,899
parser does not parse pod but it does

00:51:51,619 --> 00:51:58,130
not screw up the line numbers

00:51:53,899 --> 00:52:01,219
so both the line numbers and the columns

00:51:58,130 --> 00:52:03,499
are correct even though it just does not

00:52:01,219 --> 00:52:05,899
give you pod and says this is the pod

00:52:03,499 --> 00:52:08,769
that I found its sorry the part that you

00:52:05,899 --> 00:52:11,539
find is not part of the Perl syntax so

00:52:08,769 --> 00:52:16,429
you don't get it if you want get a pot

00:52:11,539 --> 00:52:18,559
extractor all right Devon yeah so how

00:52:16,429 --> 00:52:19,400
come you don't base this around PPR

00:52:18,559 --> 00:52:21,710
instead since

00:52:19,400 --> 00:52:23,119
regular expression based and I know that

00:52:21,710 --> 00:52:24,799
I'd be enough well maybe it could be

00:52:23,119 --> 00:52:26,539
converted to one but it does not parse

00:52:24,799 --> 00:52:28,039
the Perl code you know it doesn't

00:52:26,539 --> 00:52:30,109
actually execute any Perl code

00:52:28,039 --> 00:52:33,380
it's simply parsing it and supports a

00:52:30,109 --> 00:52:37,400
lot more of the syntax yes good point

00:52:33,380 --> 00:52:40,730
several reasons and so for the sake of

00:52:37,400 --> 00:52:42,740
argument PPR support two more things PPR

00:52:40,730 --> 00:52:49,130
is also static PPR is written by someone

00:52:42,740 --> 00:52:51,349
way smarter and and it is much much much

00:52:49,130 --> 00:52:53,869
faster at the moment now the reason I

00:52:51,349 --> 00:52:55,190
didn't want to use it is because first I

00:52:53,869 --> 00:52:56,930
wouldn't be able to generate this

00:52:55,190 --> 00:52:59,210
standard I could only generate like a

00:52:56,930 --> 00:53:00,680
really big regex it's not even using

00:52:59,210 --> 00:53:02,829
parse rectus and so it doesn't it

00:53:00,680 --> 00:53:05,089
doesn't have a standard it's basically

00:53:02,829 --> 00:53:07,700
the ability to parse it without a

00:53:05,089 --> 00:53:09,230
complicated regice secondly i wouldn't

00:53:07,700 --> 00:53:11,240
be able because of that to ported to

00:53:09,230 --> 00:53:14,660
other languages third i wouldn't be able

00:53:11,240 --> 00:53:16,910
to create a variation of Pro that is so

00:53:14,660 --> 00:53:18,589
unambiguous and clear and easy to

00:53:16,910 --> 00:53:21,170
explain to others and to teach and to

00:53:18,589 --> 00:53:23,119
learn so if I were to write a pro book

00:53:21,170 --> 00:53:25,760
or if I were to write documentation I

00:53:23,119 --> 00:53:27,200
would only match standard because I

00:53:25,760 --> 00:53:28,809
would want it to be the easiest to

00:53:27,200 --> 00:53:30,890
understand the easiest to follow

00:53:28,809 --> 00:53:32,690
basically if you write this you have

00:53:30,890 --> 00:53:34,220
less headache and that's one of the

00:53:32,690 --> 00:53:37,190
things that I wanted to do with with

00:53:34,220 --> 00:53:41,240
guacamole and Vacanti just likes doing

00:53:37,190 --> 00:53:43,779
stuff like implementing access and rust

00:53:41,240 --> 00:53:48,289
for example so because there's always

00:53:43,779 --> 00:53:51,609
let's do it why not I think we're out of

00:53:48,289 --> 00:53:51,609

YouTube URL: https://www.youtube.com/watch?v=sTEshbh2lYQ


