Title: Graham Ollis - Perl + WebAssembly
Publication date: 2020-06-24
Playlist: TPC 2020 in the Cloud
Description: 
	Let’s write Perl bindings in WebAssembly (Wasm)! You’ve heard of WebAssembly: a portable bytecode that facilitates the implementation of high-performance applications inside web pages, but it is also useful for writing fast sandboxed extensions in a number of programming languages, including Perl.

WebAssembly (Wasm) was developed as a fast, safe, portable bytecode that could be used by web browsers in situations where plain JavaScript is not appropriate. It can also be useful in server applications, where the sandboxed nature of the technology allows running code that might be untrusted or might misbehave in subtle ways. As the applications for this technology are growing, a number of languages are getting their own WebAssebly interfaces that allow them to write fast, safe and portable extensions in any of the growing list of languages that can target WebAssembly, including Rust, Go and C.

In this talk I will discuss the basics of using WebAssembly using Wasmtime, an open source WebAssembly run-time. I’ll be focusing on using it from Perl using Wasm::Wasmtime, but will also touch briefly on how easily you can use a WebAssembly extension compiled just once, in a number of different languages, like Python or Node.js. We will spend some time comparing and contrasting using WebAssembly with related technologies that cross the language barrier like XS and FFI. I’ll also discuss WebAssebly techniques and technologies that I hope will be useful in Perl in the near future. Future specifications like WebAssebly Interface Types that should make it easier for different languages to talk to each other using higher level types. There should also be time to talk about future technologies like Lucet, the WebAssebly native compiler, for even faster execution.
Captions: 
	00:00:01,909 --> 00:00:07,680
okay so thanks everyone for joining us

00:00:06,120 --> 00:00:10,080
today for that conference in the cloud

00:00:07,680 --> 00:00:11,519
for the pale on roku community this is

00:00:10,080 --> 00:00:14,040
my pleasure to introduce you Graham

00:00:11,519 --> 00:00:16,770
Holies which is a prominent Totoro in

00:00:14,040 --> 00:00:19,170
the pel community Graham is the daughter

00:00:16,770 --> 00:00:20,910
of many alien modules but also many more

00:00:19,170 --> 00:00:24,210
distribution including the model

00:00:20,910 --> 00:00:27,240
unpromising FFI two diagram is going to

00:00:24,210 --> 00:00:30,000
talk in this 50-minute session about

00:00:27,240 --> 00:00:34,350
parent webassembly so run you got the

00:00:30,000 --> 00:00:37,380
mic thank you so as as we introduced

00:00:34,350 --> 00:00:40,890
today i want to talk to you about Pearl

00:00:37,380 --> 00:00:43,469
and webassembly my name is Graham

00:00:40,890 --> 00:00:47,039
Wallace I'm a software engineer at

00:00:43,469 --> 00:00:51,329
fastly on the internet many people know

00:00:47,039 --> 00:00:54,620
me as Pisces so you can contact me that

00:00:51,329 --> 00:00:57,090
way if you have any questions later on

00:00:54,620 --> 00:01:00,930
in my spare time I work on the number of

00:00:57,090 --> 00:01:02,239
Perl related open-source projects there

00:01:00,930 --> 00:01:06,030
are two that you may have heard of

00:01:02,239 --> 00:01:08,220
possibly you have been used the first is

00:01:06,030 --> 00:01:10,549
the alien family of modules on the alien

00:01:08,220 --> 00:01:13,890
build banner these let you to declare

00:01:10,549 --> 00:01:17,909
external non Sipan dependencies for your

00:01:13,890 --> 00:01:19,979
pro projects and the platicas project

00:01:17,909 --> 00:01:22,680
which is an alternative foreign function

00:01:19,979 --> 00:01:24,540
interface for perl platypus has some

00:01:22,680 --> 00:01:26,810
advantages over frozen native form

00:01:24,540 --> 00:01:28,829
function interface known as excess

00:01:26,810 --> 00:01:31,229
especially when you're writing library

00:01:28,829 --> 00:01:33,150
bindings and do not need to extend the

00:01:31,229 --> 00:01:36,299
Perl language programming language

00:01:33,150 --> 00:01:38,040
itself and I'm going to talk a little

00:01:36,299 --> 00:01:40,290
bit about how to close in this talk

00:01:38,040 --> 00:01:45,540
because it is a related although

00:01:40,290 --> 00:01:46,950
different technology today though as I

00:01:45,540 --> 00:01:50,310
say I want to talk to you about web

00:01:46,950 --> 00:01:53,549
assembly or wasm for short it's a fast

00:01:50,310 --> 00:01:55,530
safe portable bytecode that can be used

00:01:53,549 --> 00:01:58,680
by web browsers in performance critical

00:01:55,530 --> 00:01:59,219
situations where javascript is not fast

00:01:58,680 --> 00:02:02,450
enough

00:01:59,219 --> 00:02:04,680
I think the one of the keys to

00:02:02,450 --> 00:02:06,890
webassembly success is that it works

00:02:04,680 --> 00:02:11,879
well with a number of existing

00:02:06,890 --> 00:02:13,860
technologies and tool chains for example

00:02:11,879 --> 00:02:16,110
in a traditional unix environment you

00:02:13,860 --> 00:02:18,270
use a C compiler like clanked compile C

00:02:16,110 --> 00:02:20,490
code into an object file which then can

00:02:18,270 --> 00:02:22,200
be linked into an executable or a

00:02:20,490 --> 00:02:24,920
library which you can run from the bash

00:02:22,200 --> 00:02:27,750
prompt or call from another program

00:02:24,920 --> 00:02:33,540
again for example you can call a dynamic

00:02:27,750 --> 00:02:36,330
library from Perl using platypus it

00:02:33,540 --> 00:02:38,400
turns out that modern clang also

00:02:36,330 --> 00:02:40,200
supports web assemblies our back-end so

00:02:38,400 --> 00:02:45,720
you can take the use the same sort of

00:02:40,200 --> 00:02:48,000
pipeline and instead link with the wasm

00:02:45,720 --> 00:02:51,390
linker and get at web assembler assembly

00:02:48,000 --> 00:02:53,880
binary file the same format is used for

00:02:51,390 --> 00:02:56,280
both programs and libraries a program is

00:02:53,880 --> 00:02:59,340
actually it's just a wesen file that

00:02:56,280 --> 00:03:01,680
happens to have a start function so we

00:02:59,340 --> 00:03:05,100
can run web assembly programs using a

00:03:01,680 --> 00:03:09,380
command-line runtime or we can call it

00:03:05,100 --> 00:03:13,950
using JavaScript inside of a web browser

00:03:09,380 --> 00:03:16,560
and the nice thing is you don't have to

00:03:13,950 --> 00:03:18,450
be a whiz at C either because there are

00:03:16,560 --> 00:03:21,090
some more modern languages like rust or

00:03:18,450 --> 00:03:23,549
NGO that are supported that support web

00:03:21,090 --> 00:03:26,160
assembly is a becket a lot of web

00:03:23,549 --> 00:03:28,260
assembly and the infrastructure used to

00:03:26,160 --> 00:03:30,900
build and run it are actually written in

00:03:28,260 --> 00:03:36,330
rust as it turns out so there's lots of

00:03:30,900 --> 00:03:38,580
interesting technology but why you're

00:03:36,330 --> 00:03:42,239
asking web assembly and not JavaScript

00:03:38,580 --> 00:03:44,430
well for CPU bound cast it's much faster

00:03:42,239 --> 00:03:46,799
and even approaches the speed of

00:03:44,430 --> 00:03:48,209
natively compiled code for another

00:03:46,799 --> 00:03:50,190
reason you can develop your web

00:03:48,209 --> 00:03:53,190
application in a mature compiled

00:03:50,190 --> 00:03:55,290
language like Gloucester see and you can

00:03:53,190 --> 00:03:56,489
exploit the knowledge that your

00:03:55,290 --> 00:03:59,910
developers might have in those

00:03:56,489 --> 00:04:02,610
technologies finally webassembly lets

00:03:59,910 --> 00:04:04,200
you sandbox part of your application so

00:04:02,610 --> 00:04:06,390
that it you won't accidentally or

00:04:04,200 --> 00:04:10,280
intentionally in the case of malicious

00:04:06,390 --> 00:04:10,280
intent take down the end user system

00:04:11,180 --> 00:04:16,290
also web assemblies for this reason

00:04:14,220 --> 00:04:19,290
actually are very easy to introspect

00:04:16,290 --> 00:04:22,470
since the web assembly runtime has to

00:04:19,290 --> 00:04:24,090
know a lot of detail about exactly what

00:04:22,470 --> 00:04:27,450
gets passed between the guest and the

00:04:24,090 --> 00:04:30,510
host it means that

00:04:27,450 --> 00:04:33,420
you can introspect and understand how

00:04:30,510 --> 00:04:39,360
the module works quite easily through

00:04:33,420 --> 00:04:48,330
api's I just want to show you a couple

00:04:39,360 --> 00:04:50,940
demos the first is a program that I

00:04:48,330 --> 00:04:54,510
wrote in the 90s

00:04:50,940 --> 00:04:57,180
it's a hex editor for dos I thought it

00:04:54,510 --> 00:04:58,890
was being pretty clever calling it hexed

00:04:57,180 --> 00:05:00,750
it turns out that everyone else was

00:04:58,890 --> 00:05:03,420
being exactly as clever and called it

00:05:00,750 --> 00:05:08,730
the exact same thing but we've got like

00:05:03,420 --> 00:05:10,860
a file browser here we can open her open

00:05:08,730 --> 00:05:13,820
ourselves we're hoping text with hexed

00:05:10,860 --> 00:05:15,570
and we can sort of scroll through

00:05:13,820 --> 00:05:18,840
horizontally at some point I thought

00:05:15,570 --> 00:05:21,150
this was like wasting a lot of real

00:05:18,840 --> 00:05:25,220
estate on the help so I came up with a

00:05:21,150 --> 00:05:28,740
different view mode which you can see in

00:05:25,220 --> 00:05:34,020
bits and hex and all kinds of things so

00:05:28,740 --> 00:05:37,320
yeah it was it was it was it was my

00:05:34,020 --> 00:05:40,350
thing that I did in the 90s this program

00:05:37,320 --> 00:05:44,310
was written in turbo Pascal which I

00:05:40,350 --> 00:05:46,410
loved back in the day it was exciting to

00:05:44,310 --> 00:05:48,840
learn this morning that were finally

00:05:46,410 --> 00:05:53,880
going to below surpass my beloved turbo

00:05:48,840 --> 00:05:57,960
Pascal as pearl makes its way to version

00:05:53,880 --> 00:06:01,350
8 eventually but anyway you get the idea

00:05:57,960 --> 00:06:06,330
on modern hardware disutility only works

00:06:01,350 --> 00:06:08,610
in an emulator like DOSBox and somebody

00:06:06,330 --> 00:06:11,300
has happily boarded ported DOSBox

00:06:08,610 --> 00:06:15,710
to web assembly and called it je estas

00:06:11,300 --> 00:06:19,680
appropriately enough it's version 6.2 to

00:06:15,710 --> 00:06:20,910
which most of you many of you may

00:06:19,680 --> 00:06:22,800
remember I don't know I think most

00:06:20,910 --> 00:06:25,740
programmers are probably old enough to

00:06:22,800 --> 00:06:27,950
remember that 62 was the last version of

00:06:25,740 --> 00:06:27,950
boss

00:06:30,949 --> 00:06:36,229
and originally I was going to use this

00:06:33,830 --> 00:06:38,180
example dust box to show you one of the

00:06:36,229 --> 00:06:40,840
games that I wrote in the night because

00:06:38,180 --> 00:06:43,069
that's usually what you use DOSBox for

00:06:40,840 --> 00:06:44,779
but to be honest it was a little

00:06:43,069 --> 00:06:46,939
unimpressive and I had trouble getting

00:06:44,779 --> 00:06:49,999
the sound to work right but you get the

00:06:46,939 --> 00:06:52,219
kind of the idea you can you know bring

00:06:49,999 --> 00:06:56,689
old things back to life with some of

00:06:52,219 --> 00:06:58,580
this technology and much better and more

00:06:56,689 --> 00:07:00,889
resource intensive games can be run in

00:06:58,580 --> 00:07:05,259
the browser using the same technology

00:07:00,889 --> 00:07:09,020
for example I saw a demo of doom 3

00:07:05,259 --> 00:07:11,150
accorded to webassembly that was running

00:07:09,020 --> 00:07:12,409
really well that's I know it's like 10

00:07:11,150 --> 00:07:15,229
years old now but that's pretty

00:07:12,409 --> 00:07:16,039
impressive 3d and sound for running in a

00:07:15,229 --> 00:07:24,349
browser tab

00:07:16,039 --> 00:07:27,110
oh it's closes window so the next demo I

00:07:24,349 --> 00:07:28,849
wanted to show you this one I can't take

00:07:27,110 --> 00:07:31,370
any credit for somebody else did this

00:07:28,849 --> 00:07:37,009
but I think it shows you some real-time

00:07:31,370 --> 00:07:42,159
capability please work yeah okay so

00:07:37,009 --> 00:07:47,210
we've got a this is using my camera and

00:07:42,159 --> 00:07:50,330
we can apply filters using webassembly

00:07:47,210 --> 00:07:52,039
to the picture and this is so this is

00:07:50,330 --> 00:07:53,300
all and since this is the camera and you

00:07:52,039 --> 00:07:56,449
can see that this is happening right now

00:07:53,300 --> 00:07:57,259
I can you can see that it's happening in

00:07:56,449 --> 00:08:00,949
real time

00:07:57,259 --> 00:08:03,710
and hopefully you can see this too /

00:08:00,949 --> 00:08:06,620
zoom but it's quite it's quite surprised

00:08:03,710 --> 00:08:14,960
it's it's pretty fast so it's a it's a

00:08:06,620 --> 00:08:17,289
pretty cool download with somebody next

00:08:14,960 --> 00:08:17,289
thing

00:08:20,990 --> 00:08:23,990
finally

00:08:31,830 --> 00:08:42,610
my buttons are getting a bit slow I'm

00:08:34,570 --> 00:08:45,340
sorry one example of okay let's try

00:08:42,610 --> 00:08:47,920
again one example of using web assembly

00:08:45,340 --> 00:08:49,510
in the browser is Perl itself the web

00:08:47,920 --> 00:08:51,670
Pro project has the goal of allowing

00:08:49,510 --> 00:08:54,430
developers to run Perl in the browser

00:08:51,670 --> 00:08:56,770
since pearl itself is a C program the

00:08:54,430 --> 00:08:58,780
web Pro project has ported Perl to a

00:08:56,770 --> 00:09:01,720
particular flavor of C used by the

00:08:58,780 --> 00:09:03,190
compiler in the browsers and they've

00:09:01,720 --> 00:09:04,840
added some hooks to make it work in the

00:09:03,190 --> 00:09:11,740
browser's environment and it useful kind

00:09:04,840 --> 00:09:15,490
of way so here's a demo we've got a pro

00:09:11,740 --> 00:09:17,200
program and we can run it and it prints

00:09:15,490 --> 00:09:21,250
out a message that is displayed in the

00:09:17,200 --> 00:09:24,510
text area to the right nice well it's

00:09:21,250 --> 00:09:29,080
pretty simple you can also call pearl

00:09:24,510 --> 00:09:31,420
from JavaScript so this program it

00:09:29,080 --> 00:09:35,440
evaluates a pro program which also

00:09:31,420 --> 00:09:38,860
prints a message so we run that and it

00:09:35,440 --> 00:09:42,670
prints the other message so but I think

00:09:38,860 --> 00:09:45,100
the useful thing about this is that it

00:09:42,670 --> 00:09:51,610
has full access to the document object

00:09:45,100 --> 00:09:54,190
model so we can actually query the the

00:09:51,610 --> 00:09:57,400
Dom for the document title for example

00:09:54,190 --> 00:10:02,530
and print that out instead so 400 plus

00:09:57,400 --> 00:10:08,110
web assembly that's the title of this

00:10:02,530 --> 00:10:10,300
talk web assembly can also be useful in

00:10:08,110 --> 00:10:11,770
server and command line applications

00:10:10,300 --> 00:10:14,340
where the sandbox nature of the

00:10:11,770 --> 00:10:18,640
technology allows running untrusted code

00:10:14,340 --> 00:10:19,690
that could misbehave this works and can

00:10:18,640 --> 00:10:20,710
be relatively safe

00:10:19,690 --> 00:10:26,260
assuming you set the appropriate

00:10:20,710 --> 00:10:29,680
resource limits for example it fastly

00:10:26,260 --> 00:10:31,750
which is a content delivery network we

00:10:29,680 --> 00:10:33,520
allow customers to provide their own web

00:10:31,750 --> 00:10:36,730
assembly applications that are run on

00:10:33,520 --> 00:10:39,640
our cache nodes this allows our

00:10:36,730 --> 00:10:41,350
customers to more quickly respond to

00:10:39,640 --> 00:10:43,480
their customers in some cases without

00:10:41,350 --> 00:10:44,850
having to go back to the backend servers

00:10:43,480 --> 00:10:49,000
all

00:10:44,850 --> 00:10:50,680
and since the code is run in a web

00:10:49,000 --> 00:10:52,390
assembly sandbox we don't have to worry

00:10:50,680 --> 00:10:56,230
about one of our customers taking down

00:10:52,390 --> 00:11:00,760
the code or accessing other customers

00:10:56,230 --> 00:11:02,890
data previously customers could use in

00:11:00,760 --> 00:11:05,440
fact still do use a domain-specific

00:11:02,890 --> 00:11:08,530
language called vcl to write their own

00:11:05,440 --> 00:11:11,590
custom logic at the edge but the ability

00:11:08,530 --> 00:11:16,390
to use a general-purpose programming

00:11:11,590 --> 00:11:18,370
language like C rust or go and their

00:11:16,390 --> 00:11:22,290
well-known tool chains gives our

00:11:18,370 --> 00:11:22,290
customers a lot more flexibility power

00:11:24,000 --> 00:11:30,580
and of course being a pro programmer I'm

00:11:28,960 --> 00:11:34,510
interested in using web assembly from

00:11:30,580 --> 00:11:37,710
Perl the same tools that can be used to

00:11:34,510 --> 00:11:41,290
create a web assembly binary for use in

00:11:37,710 --> 00:11:48,730
Perl can be used that we earlier used to

00:11:41,290 --> 00:11:49,450
build browser-based applications in the

00:11:48,730 --> 00:11:51,850
pursuit of this goal

00:11:49,450 --> 00:11:52,570
I've written some modules to allow me to

00:11:51,850 --> 00:11:55,570
do exactly that

00:11:52,570 --> 00:11:57,460
wazz and weisenheim is a low-level

00:11:55,570 --> 00:12:00,700
library that lets you introspect and

00:11:57,460 --> 00:12:03,280
call web assembly code it's sort of

00:12:00,700 --> 00:12:04,570
low-level bindings on something called

00:12:03,280 --> 00:12:06,300
wezen time which we'll talk about in a

00:12:04,570 --> 00:12:09,280
minute

00:12:06,300 --> 00:12:11,140
why's NPM is a higher-level interface

00:12:09,280 --> 00:12:13,120
that makes it easy to call between pearl

00:12:11,140 --> 00:12:15,700
and web assembly without having to know

00:12:13,120 --> 00:12:20,830
a lot about how web assembly works and

00:12:15,700 --> 00:12:22,960
finally plasm or pearl resin is a tool

00:12:20,830 --> 00:12:26,070
for poking around with and running

00:12:22,960 --> 00:12:26,070
webassembly binaries from

00:12:28,830 --> 00:12:34,140
why sometime as I say is a popular rust

00:12:31,680 --> 00:12:37,970
library that implements webassembly

00:12:34,140 --> 00:12:37,970
implements our webassembly runtime

00:12:38,390 --> 00:12:45,080
helpfully wasn't time it has a very

00:12:41,670 --> 00:12:47,610
friendly C API which means it can be

00:12:45,080 --> 00:12:50,870
pretty easily embedded in just about any

00:12:47,610 --> 00:12:50,870
modern programming language

00:12:51,500 --> 00:12:58,290
remember again from before that platypus

00:12:54,180 --> 00:13:00,660
is an empathizer pearl so I of course

00:12:58,290 --> 00:13:04,530
wrote glass and wasn't I'm using

00:13:00,660 --> 00:13:06,780
platypus and I just want to show you

00:13:04,530 --> 00:13:10,260
this diagram it's it shows the most

00:13:06,780 --> 00:13:14,250
important classes to understand how

00:13:10,260 --> 00:13:16,500
wedding time works the module objects on

00:13:14,250 --> 00:13:21,050
the left is a compiled in memory

00:13:16,500 --> 00:13:23,730
representation of a web assembly binary

00:13:21,050 --> 00:13:27,240
the module object can contain a number

00:13:23,730 --> 00:13:29,190
of name to func type mappings a func

00:13:27,240 --> 00:13:35,070
type is just a function signature

00:13:29,190 --> 00:13:36,570
basically so this tells me tells us what

00:13:35,070 --> 00:13:39,420
functions we can call and how to call

00:13:36,570 --> 00:13:40,770
them the module object also contains

00:13:39,420 --> 00:13:43,950
another useful object which is the

00:13:40,770 --> 00:13:46,650
memory type this tells us the maximum

00:13:43,950 --> 00:13:52,500
and minimum number of pages of memory

00:13:46,650 --> 00:13:54,810
that the web assembly requires the web

00:13:52,500 --> 00:13:57,990
assembly instance object can be created

00:13:54,810 --> 00:13:59,940
from a module object and this is what we

00:13:57,990 --> 00:14:01,860
use to actually call the function types

00:13:59,940 --> 00:14:07,650
which are the functions inside the web

00:14:01,860 --> 00:14:09,660
assembly and we also have the memory

00:14:07,650 --> 00:14:12,780
object which gives us a data pointer

00:14:09,660 --> 00:14:14,400
which is just a data pointer and a size

00:14:12,780 --> 00:14:18,150
to the memory you Pidgeon used by the

00:14:14,400 --> 00:14:22,140
web assembly module instance and it's

00:14:18,150 --> 00:14:25,320
important to maybe but hopefully obvious

00:14:22,140 --> 00:14:27,720
that although perl can access web

00:14:25,320 --> 00:14:30,960
assemblies memory the opposite isn't

00:14:27,720 --> 00:14:35,010
true webassembly can't peek out of its

00:14:30,960 --> 00:14:36,210
own memory region and that's for the

00:14:35,010 --> 00:14:40,590
sandbox in that we're talking about

00:14:36,210 --> 00:14:44,340
before wesen time also has a number

00:14:40,590 --> 00:14:47,010
utility functions web Tizen for example

00:14:44,340 --> 00:14:49,680
translates webassembly texts the textual

00:14:47,010 --> 00:14:52,440
representation into webassembly binary

00:14:49,680 --> 00:14:59,250
which is what you need to actually use

00:14:52,440 --> 00:15:00,900
with assembly and this little example

00:14:59,250 --> 00:15:02,940
here we're converting the simplest

00:15:00,900 --> 00:15:04,209
possible web assembly module one that

00:15:02,940 --> 00:15:06,879
doesn't do anything

00:15:04,209 --> 00:15:12,040
and doesn't have any memory into

00:15:06,879 --> 00:15:14,259
webassembly binary I'd also like to

00:15:12,040 --> 00:15:15,939
mention the present time linker which is

00:15:14,259 --> 00:15:18,069
a runtime linker that makes it easy for

00:15:15,939 --> 00:15:21,009
two or more webassembly modules to call

00:15:18,069 --> 00:15:24,040
each other I don't have any examples for

00:15:21,009 --> 00:15:26,079
that because it's a bit complicated but

00:15:24,040 --> 00:15:29,319
the higher level of as an PM interface

00:15:26,079 --> 00:15:36,610
uses this to offload much of its work of

00:15:29,319 --> 00:15:38,290
linking different modules together let's

00:15:36,610 --> 00:15:41,800
look at some call code that calls what

00:15:38,290 --> 00:15:43,269
was simply from Perl the web assembly

00:15:41,800 --> 00:15:46,240
text is passed into the module

00:15:43,269 --> 00:15:48,240
constructor under the covers back to

00:15:46,240 --> 00:15:51,279
Azen which we saw earlier is called

00:15:48,240 --> 00:15:53,170
passing the web assembly text is helpful

00:15:51,279 --> 00:15:55,230
in examples like this or when you're

00:15:53,170 --> 00:15:57,730
experimenting with web assembly in

00:15:55,230 --> 00:16:00,069
production you'd likely want to use web

00:15:57,730 --> 00:16:02,619
assembly binary here which you can pass

00:16:00,069 --> 00:16:06,850
in directly or pipe providing a file

00:16:02,619 --> 00:16:11,220
name this particular module has just one

00:16:06,850 --> 00:16:14,259
function it adds two images together and

00:16:11,220 --> 00:16:17,379
once we have the module object we can

00:16:14,259 --> 00:16:20,019
instantiate it by creating a web ascent

00:16:17,379 --> 00:16:24,399
an instance sorry wasn't I'm instance

00:16:20,019 --> 00:16:27,519
object we can parry the instance object

00:16:24,399 --> 00:16:29,379
to get the add function and now we can

00:16:27,519 --> 00:16:31,809
finally call it we passing the values 1

00:16:29,379 --> 00:16:38,529
2 & 3 is returned which is what you

00:16:31,809 --> 00:16:40,829
would expect and if you don't want to

00:16:38,529 --> 00:16:42,910
muck out around with func objects

00:16:40,829 --> 00:16:44,889
because if you're if you're building an

00:16:42,910 --> 00:16:46,509
interface that's not exactly the kind of

00:16:44,889 --> 00:16:51,850
thing that you want to give people to

00:16:46,509 --> 00:16:53,679
use then you can attach them and call

00:16:51,850 --> 00:16:56,259
them exactly like regular Perl

00:16:53,679 --> 00:16:58,629
subroutines so instead of calling the

00:16:56,259 --> 00:17:00,279
object we attach it we create a Perl

00:16:58,629 --> 00:17:02,259
subroutine and now we can use it and

00:17:00,279 --> 00:17:04,510
when you're using it you don't even have

00:17:02,259 --> 00:17:06,130
to know that it's webassembly

00:17:04,510 --> 00:17:12,760
it's anything other than just following

00:17:06,130 --> 00:17:16,299
the code so you can also call web

00:17:12,760 --> 00:17:18,100
assembly from Perl again we provide the

00:17:16,299 --> 00:17:21,220
web assembly text in line here

00:17:18,100 --> 00:17:24,970
this module has just two functions one

00:17:21,220 --> 00:17:27,669
is imported from Pearl called hello the

00:17:24,970 --> 00:17:31,539
other is exported from the module and

00:17:27,669 --> 00:17:38,049
called run next we create a wesen time

00:17:31,539 --> 00:17:40,210
func object for our pearl call bug when

00:17:38,049 --> 00:17:42,039
we instantiate sorry when we create the

00:17:40,210 --> 00:17:44,260
instance object this time we have to

00:17:42,039 --> 00:17:49,030
provide a callback in this case we have

00:17:44,260 --> 00:17:50,980
just one import but if you have more

00:17:49,030 --> 00:17:52,840
than one import you'd have to provide

00:17:50,980 --> 00:17:54,789
them in the same order that the declare

00:17:52,840 --> 00:17:59,350
it into the web assembly so the

00:17:54,789 --> 00:18:02,820
interface doesn't use the names it's

00:17:59,350 --> 00:18:02,820
just using the order of the inputs

00:18:03,450 --> 00:18:08,710
finally we can call the web assembly run

00:18:05,890 --> 00:18:12,309
function which calls back into Pearl

00:18:08,710 --> 00:18:13,960
space going to cut for the callback

00:18:12,309 --> 00:18:16,179
which then finally prints out hello

00:18:13,960 --> 00:18:20,190
world so now we can go both ways we can

00:18:16,179 --> 00:18:20,190
go from Pearl to as analyzing people

00:18:20,549 --> 00:18:26,710
that's sorry that's a lot of work and

00:18:24,280 --> 00:18:28,150
most the time you know you don't want or

00:18:26,710 --> 00:18:30,940
need to care about that level of

00:18:28,150 --> 00:18:34,390
introspection and that's what was in PM

00:18:30,940 --> 00:18:37,330
is for wise and PM doesn't expose the

00:18:34,390 --> 00:18:38,919
wesen type interface at all and that's

00:18:37,330 --> 00:18:41,169
an intentional design decision that i

00:18:38,919 --> 00:18:44,289
made just in case we decide to change

00:18:41,169 --> 00:18:46,690
the lower level implementation later it

00:18:44,289 --> 00:18:50,590
makes it much easier to do that at the

00:18:46,690 --> 00:18:54,669
moment I prefer the wasn't time to do

00:18:50,590 --> 00:18:56,140
this module but there are similar

00:18:54,669 --> 00:18:58,000
projects like asthma that might make

00:18:56,140 --> 00:18:59,250
sense down the line it might even make

00:18:58,000 --> 00:19:01,600
sense to support multiple

00:18:59,250 --> 00:19:07,360
implementations and decide at runtime

00:19:01,600 --> 00:19:10,440
which ones to use so in this example

00:19:07,360 --> 00:19:13,960
again provide the web assembly in line

00:19:10,440 --> 00:19:17,409
as text but you could provide a binary

00:19:13,960 --> 00:19:20,200
or an external file instead as a

00:19:17,409 --> 00:19:22,179
convenience we use the exporter option

00:19:20,200 --> 00:19:25,120
to have all the exported functions

00:19:22,179 --> 00:19:28,299
automatically thrown into the calling

00:19:25,120 --> 00:19:29,860
module we could also say okay here

00:19:28,299 --> 00:19:31,450
instead and have them imported on

00:19:29,860 --> 00:19:34,039
request

00:19:31,450 --> 00:19:37,549
under the covers the Pearl exporter

00:19:34,039 --> 00:19:40,489
module is used to do the actual work and

00:19:37,549 --> 00:19:43,059
I think this is a kind of a neat detail

00:19:40,489 --> 00:19:46,549
of you know wherever possible I tried to

00:19:43,059 --> 00:19:52,580
make wise and p.m. use existing pearl

00:19:46,549 --> 00:19:54,619
ish interfaces now we can use our math

00:19:52,580 --> 00:19:57,980
stuff module just like any other Perl

00:19:54,619 --> 00:20:00,950
module as a user you don't have to know

00:19:57,980 --> 00:20:03,289
or care what language binary format

00:20:00,950 --> 00:20:05,570
whatever is being used under the covers

00:20:03,289 --> 00:20:08,629
this could easily be an excess module

00:20:05,570 --> 00:20:12,759
could be densify would be pure Pro who

00:20:08,629 --> 00:20:12,759
knows just happens to be wet webassembly

00:20:14,350 --> 00:20:18,470
you can still call pearl from

00:20:16,999 --> 00:20:22,879
webassembly using the blossom p.m.

00:20:18,470 --> 00:20:25,279
interface here we just define a pearl

00:20:22,879 --> 00:20:28,309
subroutine this time we don't have to

00:20:25,279 --> 00:20:28,940
even wrap it in the funk object the

00:20:28,309 --> 00:20:31,609
webassembly

00:20:28,940 --> 00:20:32,330
asks to import hello from main the main

00:20:31,609 --> 00:20:34,009
package

00:20:32,330 --> 00:20:35,659
notice that the web assembly code

00:20:34,009 --> 00:20:37,249
doesn't need to know or care what

00:20:35,659 --> 00:20:43,009
language hello function is implemented

00:20:37,249 --> 00:20:44,509
in and finally we call the run the web

00:20:43,009 --> 00:20:46,100
assembly run function which calls the

00:20:44,509 --> 00:20:50,570
Pearl hub with subroutine which prints

00:20:46,100 --> 00:20:56,980
out our message and the magic happens by

00:20:50,570 --> 00:20:59,359
the use wiesen statement it exports the

00:20:56,980 --> 00:21:03,070
the exported functions from the web

00:20:59,359 --> 00:21:03,070
assembly into the calling package

00:21:04,989 --> 00:21:11,749
honestly though even this is like way

00:21:08,779 --> 00:21:15,549
too much work with wasm cloak we can

00:21:11,749 --> 00:21:19,399
reduce the boilerplate even further here

00:21:15,549 --> 00:21:23,149
oops here we write some webassembly

00:21:19,399 --> 00:21:24,799
texts into a text into a file that will

00:21:23,149 --> 00:21:28,820
implement our module and this is the

00:21:24,799 --> 00:21:31,159
same module that we saw before but with

00:21:28,820 --> 00:21:34,899
the right tools this could be see roster

00:21:31,159 --> 00:21:34,899
go it could be anything that's supported

00:21:35,409 --> 00:21:39,980
we use the wet to azzam command-line

00:21:37,909 --> 00:21:41,749
tool which is similar to the API that

00:21:39,980 --> 00:21:42,169
I've searched before but on the command

00:21:41,749 --> 00:21:44,659
line

00:21:42,169 --> 00:21:46,789
to convert the web assembly text into

00:21:44,659 --> 00:21:48,559
assembly binary and place it where you

00:21:46,789 --> 00:21:53,869
would normally expect to see a duck p.m.

00:21:48,559 --> 00:21:56,629
file if this work here for a module but

00:21:53,869 --> 00:21:59,450
we don't need the PM file because plasm

00:21:56,629 --> 00:22:01,759
book installs an at inc book to find the

00:21:59,450 --> 00:22:05,539
web assembly binary files and generates

00:22:01,759 --> 00:22:07,729
the necessary boilerplate for us and the

00:22:05,539 --> 00:22:10,009
nice thing here is now we can take this

00:22:07,729 --> 00:22:11,989
web assembly binary module and use it on

00:22:10,009 --> 00:22:14,629
any platform that's what is supported by

00:22:11,989 --> 00:22:17,599
Watson p.m. you no longer have to worry

00:22:14,629 --> 00:22:20,960
about you know weird compiler options on

00:22:17,599 --> 00:22:23,659
obscure dialects of UNIX compiled it

00:22:20,960 --> 00:22:26,090
once you can use it everywhere and you

00:22:23,659 --> 00:22:28,909
get some of the benefits of a pure Pro

00:22:26,090 --> 00:22:31,099
module in that respect but also some of

00:22:28,909 --> 00:22:38,269
the performance benefits of using excess

00:22:31,099 --> 00:22:41,929
or FFI in fact we can use this exact

00:22:38,269 --> 00:22:44,629
same binary web assembly file in other

00:22:41,929 --> 00:22:46,789
language as well Python has a wesen time

00:22:44,629 --> 00:22:48,769
loader interface but let's just use the

00:22:46,789 --> 00:22:53,929
exact same module from Python without

00:22:48,769 --> 00:22:55,659
recompiling anything can also do the

00:22:53,929 --> 00:22:58,970
same thing with nodejs

00:22:55,659 --> 00:23:00,859
since the Byzantine module class has all

00:22:58,970 --> 00:23:02,659
the information that we need to know in

00:23:00,859 --> 00:23:05,659
order to find and call at assembly

00:23:02,659 --> 00:23:08,989
functions inside the modules it should

00:23:05,659 --> 00:23:11,029
be easy to reuse this module in any

00:23:08,989 --> 00:23:13,929
language that has sufficiently advanced

00:23:11,029 --> 00:23:13,929
Byzantine bindings

00:23:18,240 --> 00:23:26,070
plasm or the pearl Wesson is a

00:23:21,490 --> 00:23:28,870
command-line tool for webassembly miners

00:23:26,070 --> 00:23:30,400
let's use this very simple C program

00:23:28,870 --> 00:23:32,350
that prints out a greeting and

00:23:30,400 --> 00:23:38,470
command-line arguments that are passed

00:23:32,350 --> 00:23:41,350
to it as an example we can compile the C

00:23:38,470 --> 00:23:44,470
into a web assembly binary and run it

00:23:41,350 --> 00:23:47,140
with plasm run and sub command it works

00:23:44,470 --> 00:23:49,120
exactly when you run it this way as if

00:23:47,140 --> 00:23:51,010
it were a native C program it prints out

00:23:49,120 --> 00:23:58,630
the message and for each argument we

00:23:51,010 --> 00:24:00,790
pass in it prints those out as well we

00:23:58,630 --> 00:24:02,770
can also use the plasm dump sub command

00:24:00,790 --> 00:24:09,040
to print out the interface of the web

00:24:02,770 --> 00:24:11,500
assembly binary so this is it looks like

00:24:09,040 --> 00:24:14,290
just a regular web assembly text but

00:24:11,500 --> 00:24:15,730
it's just the imports and the outputs it

00:24:14,290 --> 00:24:19,840
doesn't have the implementation of any

00:24:15,730 --> 00:24:24,400
of the functions so it's similar to

00:24:19,840 --> 00:24:25,960
looking at a header file from C as you

00:24:24,400 --> 00:24:27,610
might expect this there is a start

00:24:25,960 --> 00:24:30,880
function which is what makes this a

00:24:27,610 --> 00:24:33,370
program not just a library there's also

00:24:30,880 --> 00:24:35,049
a memory export so the host language can

00:24:33,370 --> 00:24:38,169
interact with web assemblies linear

00:24:35,049 --> 00:24:39,940
memory region this program also has a

00:24:38,169 --> 00:24:42,070
number of functions that look like they

00:24:39,940 --> 00:24:44,290
might work with the operating system in

00:24:42,070 --> 00:24:48,010
this case you'd be right

00:24:44,290 --> 00:24:50,200
prop exit/in implements exit

00:24:48,010 --> 00:24:52,570
functionality there are a couple of

00:24:50,200 --> 00:24:53,770
argument processing functions that lets

00:24:52,570 --> 00:24:57,070
the program get the command-line

00:24:53,770 --> 00:24:59,320
arguments and finally there are a number

00:24:57,070 --> 00:25:01,980
of functions with the FD prefix that do

00:24:59,320 --> 00:25:05,860
i oh

00:25:01,980 --> 00:25:08,080
as an aside if we have a less

00:25:05,860 --> 00:25:10,179
complicated program one that doesn't

00:25:08,080 --> 00:25:13,059
query the command line or do i oh

00:25:10,179 --> 00:25:15,610
for example we get a much shorter list

00:25:13,059 --> 00:25:18,610
of imports that's because webassembly

00:25:15,610 --> 00:25:20,830
only generates code interface code and

00:25:18,610 --> 00:25:23,470
interfaces for objects that get used by

00:25:20,830 --> 00:25:25,450
the module this is very helpful since

00:25:23,470 --> 00:25:27,070
you don't want to ship an entire Lachie

00:25:25,450 --> 00:25:28,510
with a web to a web browser

00:25:27,070 --> 00:25:31,159
if you're only just going to use bits

00:25:28,510 --> 00:25:33,330
and pieces of it

00:25:31,159 --> 00:25:37,200
all the suits of functions that we've

00:25:33,330 --> 00:25:40,200
been looking at are imported from a

00:25:37,200 --> 00:25:45,119
module called quasi snapshot preview 1

00:25:40,200 --> 00:25:47,429
and what's that well the web assembly

00:25:45,119 --> 00:25:54,499
system interface or huazi is a simple

00:25:47,429 --> 00:25:54,499
ABI an API designed by Mozilla excuse me

00:25:54,559 --> 00:26:00,659
huazi is portable to any platform pretty

00:25:57,330 --> 00:26:03,450
much it provides POSIX features like

00:26:00,659 --> 00:26:05,460
file i/o which can be configured for the

00:26:03,450 --> 00:26:09,960
security-conscious by the web assembly

00:26:05,460 --> 00:26:13,470
runtime so how do we do that from wesen

00:26:09,960 --> 00:26:16,129
time comes with a default y'see that can

00:26:13,470 --> 00:26:18,629
be configured or for your security needs

00:26:16,129 --> 00:26:21,539
wisent p.m. by default gives full access

00:26:18,629 --> 00:26:23,489
to the local system though I plan on

00:26:21,539 --> 00:26:25,349
adding an isolation option this will

00:26:23,489 --> 00:26:27,899
allow specific modules to be isolated

00:26:25,349 --> 00:26:32,159
from other web assembly modules from

00:26:27,899 --> 00:26:34,590
perl or from the operating system if

00:26:32,159 --> 00:26:37,379
you're using the lower-level plasm wezen

00:26:34,590 --> 00:26:39,330
time interface you can already grant

00:26:37,379 --> 00:26:42,690
specific access to specific resources

00:26:39,330 --> 00:26:46,710
when creating the wesen instance for

00:26:42,690 --> 00:26:49,379
example here we're using a hash to set

00:26:46,710 --> 00:26:52,710
the environment instead of using the

00:26:49,379 --> 00:26:54,869
system environment we can redirect the

00:26:52,710 --> 00:26:56,129
input and output strips sorry well in

00:26:54,869 --> 00:26:57,509
this case I'm doing the output strings

00:26:56,129 --> 00:27:02,820
but you can also redirect the input

00:26:57,509 --> 00:27:06,059
streams standard to files on disk you

00:27:02,820 --> 00:27:09,659
can map the guest root filesystem to a

00:27:06,059 --> 00:27:13,830
particular folder or directory on the

00:27:09,659 --> 00:27:15,779
host once we sort of built this

00:27:13,830 --> 00:27:17,789
configuration object we can create the

00:27:15,779 --> 00:27:26,249
inste y'see instance that can be used

00:27:17,789 --> 00:27:29,340
with the Levantine linker we could also

00:27:26,249 --> 00:27:31,830
implement huazhi in perl if we wanted to

00:27:29,340 --> 00:27:34,289
have a virtual file system backed by a

00:27:31,830 --> 00:27:36,529
network or if you wanted to pull

00:27:34,289 --> 00:27:38,820
command-line options from a database

00:27:36,529 --> 00:27:43,729
there are a lot of different

00:27:38,820 --> 00:27:43,729
possibilities if you if you do this

00:27:45,460 --> 00:27:53,269
so excess fi and wasm are all different

00:27:51,260 --> 00:27:58,970
types of foreign function interface each

00:27:53,269 --> 00:28:01,399
with their benefits and challenges XS is

00:27:58,970 --> 00:28:03,490
native to Pearl which means that it is

00:28:01,399 --> 00:28:06,860
available everywhere that Pearl is and

00:28:03,490 --> 00:28:10,970
is great at extending the Pearl

00:28:06,860 --> 00:28:12,740
programming language itself on sort of

00:28:10,970 --> 00:28:15,620
the less positive side it's a bit

00:28:12,740 --> 00:28:17,120
esoteric and quite a bit different from

00:28:15,620 --> 00:28:19,940
the way that most programming languages

00:28:17,120 --> 00:28:22,669
tend to be extended so once you've

00:28:19,940 --> 00:28:26,419
learned excess it's not really as

00:28:22,669 --> 00:28:28,549
applicable to other environments it can

00:28:26,419 --> 00:28:29,990
be extremely tedious to write pearl

00:28:28,549 --> 00:28:34,909
bindings for API certain lots of

00:28:29,990 --> 00:28:37,789
functions the full excess API if you can

00:28:34,909 --> 00:28:40,480
call it an API is quite complicated and

00:28:37,789 --> 00:28:43,519
it has a very steep learning curve and

00:28:40,480 --> 00:28:45,470
even experienced access programmers find

00:28:43,519 --> 00:28:50,510
that there are lots of sharp edges and

00:28:45,470 --> 00:28:53,990
conscious there's lots of documentation

00:28:50,510 --> 00:28:58,820
for access this for example is the XS

00:28:53,990 --> 00:29:00,889
pro man page everyone actually please

00:28:58,820 --> 00:29:07,730
read this I'll give you I'll give a few

00:29:00,889 --> 00:29:10,789
minutes okay everybody got that okay

00:29:07,730 --> 00:29:13,210
good after reading this and pearl guts

00:29:10,789 --> 00:29:17,799
and Perl API which are both even longer

00:29:13,210 --> 00:29:17,799
you're starting to be proficient in XS

00:29:22,830 --> 00:29:27,700
platypus platypus in contrast is

00:29:25,270 --> 00:29:29,650
available on all modern platforms

00:29:27,700 --> 00:29:32,170
probably any that you are likely to use

00:29:29,650 --> 00:29:34,330
in practice I know

00:29:32,170 --> 00:29:39,160
OpenVMS isn't supported for example I

00:29:34,330 --> 00:29:41,080
find that FFI bindings are fairly easy

00:29:39,160 --> 00:29:43,540
to port from one language to another I

00:29:41,080 --> 00:29:46,390
have frequently borrowed epified

00:29:43,540 --> 00:29:50,920
bindings from Ruby for use in Perl the

00:29:46,390 --> 00:29:51,900
Ruby folks really love FF I so that's

00:29:50,920 --> 00:29:54,880
cool

00:29:51,900 --> 00:29:56,620
waz 'm wizened time itself was heavily

00:29:54,880 --> 00:29:58,960
instant influenced by the already

00:29:56,620 --> 00:30:02,800
existing Python bindings for the same

00:29:58,960 --> 00:30:05,320
library unfortunately like XS it can be

00:30:02,800 --> 00:30:07,600
very tedious to write perl bindings for

00:30:05,320 --> 00:30:11,110
api's with lots of functions and

00:30:07,600 --> 00:30:13,180
although the goal of platypus of the

00:30:11,110 --> 00:30:14,650
Platypus project is to be language

00:30:13,180 --> 00:30:16,870
neutral as much as possible

00:30:14,650 --> 00:30:20,320
most libraries that you're likely direct

00:30:16,870 --> 00:30:24,190
bindings for have a C interface and C is

00:30:20,320 --> 00:30:25,990
honestly terrible at introspection this

00:30:24,190 --> 00:30:31,930
means that it's a challenge to automate

00:30:25,990 --> 00:30:34,210
bindings binding generators Lib clang

00:30:31,930 --> 00:30:35,950
which is an API to the clang parser

00:30:34,210 --> 00:30:39,070
could potentially reduce the tedium of

00:30:35,950 --> 00:30:41,200
writing FFI bindings by parsing a C

00:30:39,070 --> 00:30:46,960
header file for type and function

00:30:41,200 --> 00:30:48,730
declarations still mostly libraries are

00:30:46,960 --> 00:30:52,140
going to require at least some human

00:30:48,730 --> 00:30:54,430
intervention to implement correctly and

00:30:52,140 --> 00:30:57,310
let me give you a sense of why by

00:30:54,430 --> 00:30:58,840
looking at this phony header file so

00:30:57,310 --> 00:31:01,720
first of all constants are defined

00:30:58,840 --> 00:31:05,050
typically using the C preprocessor which

00:31:01,720 --> 00:31:07,360
means the compiler and Lim Lim plan for

00:31:05,050 --> 00:31:09,790
that matter don't even see them this

00:31:07,360 --> 00:31:11,740
means that if you want to introspect for

00:31:09,790 --> 00:31:13,720
constants you can't use lib playing

00:31:11,740 --> 00:31:17,080
instead you have to use another tool

00:31:13,720 --> 00:31:19,180
like the C preprocessor itself constants

00:31:17,080 --> 00:31:22,360
could also be defined using

00:31:19,180 --> 00:31:24,270
enums which would be possible using

00:31:22,360 --> 00:31:28,480
something like Lib clang but their other

00:31:24,270 --> 00:31:30,820
touches there now for a simple function

00:31:28,480 --> 00:31:32,880
that takes basic non pointer or non

00:31:30,820 --> 00:31:35,590
array types you're pretty much golden

00:31:32,880 --> 00:31:36,500
there aren't many ways that you can

00:31:35,590 --> 00:31:38,240
interpret

00:31:36,500 --> 00:31:41,750
this ad function there's not many ways

00:31:38,240 --> 00:31:44,570
could be called likewise this print

00:31:41,750 --> 00:31:47,450
string function is pretty clear a con

00:31:44,570 --> 00:31:48,620
star star is usually a null-terminated

00:31:47,450 --> 00:31:50,990
string

00:31:48,620 --> 00:31:53,179
although technically it could be a

00:31:50,990 --> 00:31:58,400
pointer to a single byte just there's no

00:31:53,179 --> 00:32:01,460
way to know with certainty this process

00:31:58,400 --> 00:32:04,280
list function obviously takes a strip

00:32:01,460 --> 00:32:06,710
out a list of structs and you can tell

00:32:04,280 --> 00:32:09,710
that from the name but if you're an

00:32:06,710 --> 00:32:14,830
automated tool you can't make that

00:32:09,710 --> 00:32:14,830
assumption because that's not obvious

00:32:16,090 --> 00:32:20,480
for wasn't I'm the good news is that

00:32:18,380 --> 00:32:23,240
most common CPUs and platforms are

00:32:20,480 --> 00:32:25,070
supported Intel and armed Linux Mac OS

00:32:23,240 --> 00:32:28,309
and Windows unfortunately if you're on

00:32:25,070 --> 00:32:31,940
32-bit and I don't think that many

00:32:28,309 --> 00:32:33,740
people still are or if you're on a less

00:32:31,940 --> 00:32:35,090
common operating system kind of out of

00:32:33,740 --> 00:32:37,070
luck at least for now

00:32:35,090 --> 00:32:43,730
these platforms may be supported in the

00:32:37,070 --> 00:32:46,400
future on the other hand modern

00:32:43,730 --> 00:32:48,740
languages are supported quite well for

00:32:46,400 --> 00:32:51,860
both hosts and guests another plus is

00:32:48,740 --> 00:32:53,870
that these languages have robust fairly

00:32:51,860 --> 00:32:55,580
mature tool chains and there are a lot

00:32:53,870 --> 00:33:02,900
of experienced developers out there who

00:32:55,580 --> 00:33:04,640
know how to exploit them as we showed

00:33:02,900 --> 00:33:07,460
with the Y Z interface webassembly

00:33:04,640 --> 00:33:09,530
can access the file system or at least

00:33:07,460 --> 00:33:11,840
some file system that might be

00:33:09,530 --> 00:33:13,460
virtualized it doesn't typically have

00:33:11,840 --> 00:33:17,200
direct access to the network at least

00:33:13,460 --> 00:33:19,520
not in the current implementations

00:33:17,200 --> 00:33:20,059
unless you provide those bindings

00:33:19,520 --> 00:33:22,700
himself

00:33:20,059 --> 00:33:23,570
this means that things like SQLite or

00:33:22,700 --> 00:33:26,090
imagemagick

00:33:23,570 --> 00:33:28,640
should be pretty easy to port to

00:33:26,090 --> 00:33:33,740
webassembly but something like lip pearl

00:33:28,640 --> 00:33:34,970
would be quite difficult the really

00:33:33,740 --> 00:33:36,559
great thing about webassembly

00:33:34,970 --> 00:33:39,500
is that the findings themselves are

00:33:36,559 --> 00:33:41,000
almost effortless I showed before that

00:33:39,500 --> 00:33:45,010
thanks to the securities that

00:33:41,000 --> 00:33:45,010
webassembly introspection is quite good

00:33:47,230 --> 00:33:53,210
unfortunately only basic numbers

00:33:50,300 --> 00:33:56,360
supported strings arrays and nested data

00:33:53,210 --> 00:33:58,720
types typically require peeking into web

00:33:56,360 --> 00:34:00,890
assemblies linear member region and

00:33:58,720 --> 00:34:02,450
having some knowledge of the way the

00:34:00,890 --> 00:34:05,630
guest language stores its data

00:34:02,450 --> 00:34:08,660
structures at least we do have access to

00:34:05,630 --> 00:34:11,420
the memory region though so I want to

00:34:08,660 --> 00:34:13,400
show you quickly it's possible here's an

00:34:11,420 --> 00:34:15,950
example of how you would write some

00:34:13,400 --> 00:34:19,880
bindings to a library that takes strings

00:34:15,950 --> 00:34:22,610
as input and output first we need to

00:34:19,880 --> 00:34:25,280
tell the C compiler which symbols should

00:34:22,610 --> 00:34:28,150
be exported using this peculiar

00:34:25,280 --> 00:34:28,150
incantation

00:34:28,240 --> 00:34:34,970
next we write a wrapper around malloc

00:34:31,429 --> 00:34:39,050
and free so that we can allocate and

00:34:34,970 --> 00:34:42,140
free memory from pro space now we can

00:34:39,050 --> 00:34:44,030
implement our actual function this is a

00:34:42,140 --> 00:34:46,640
function that takes a subject and

00:34:44,030 --> 00:34:48,670
returns agreement to that subject we

00:34:46,640 --> 00:34:52,580
compute the length of the output string

00:34:48,670 --> 00:34:55,450
allocate the memory create the greeting

00:34:52,580 --> 00:34:59,570
from a template using Sprint F and

00:34:55,450 --> 00:35:01,760
finally return it we're not even close

00:34:59,570 --> 00:35:04,780
to being done yet though there's still

00:35:01,760 --> 00:35:07,460
some Pro code that needs to be written

00:35:04,780 --> 00:35:09,590
this little incantation creates a

00:35:07,460 --> 00:35:11,480
function C string that converts a null

00:35:09,590 --> 00:35:14,210
terminated string which is what C uses

00:35:11,480 --> 00:35:20,900
to a Perl string and we'll need that in

00:35:14,210 --> 00:35:22,220
a minute we have to allocate space for

00:35:20,900 --> 00:35:25,580
the input string in the web web

00:35:22,220 --> 00:35:29,570
assemblies memory copy our Perl string

00:35:25,580 --> 00:35:31,640
into web assembly membrane call the web

00:35:29,570 --> 00:35:35,260
assembly greet function this returns an

00:35:31,640 --> 00:35:35,260
offset to our output function

00:35:39,830 --> 00:35:47,690
convert the offset convert the string in

00:35:44,390 --> 00:35:51,190
webassembly memory using the memory

00:35:47,690 --> 00:35:56,960
address and the offset to a Perl string

00:35:51,190 --> 00:35:58,010
D allocate the input and output strings

00:35:56,960 --> 00:36:00,800
in webassembly

00:35:58,010 --> 00:36:05,780
and finally we can return our Perl

00:36:00,800 --> 00:36:07,130
string and we can finally call our web

00:36:05,780 --> 00:36:12,110
assembly that works with strings from

00:36:07,130 --> 00:36:14,780
pro the next trick I want to show you is

00:36:12,110 --> 00:36:19,250
calling a pro so routine that takes a

00:36:14,780 --> 00:36:21,050
string from web assembly the thing that

00:36:19,250 --> 00:36:23,900
this callback needs to know is which

00:36:21,050 --> 00:36:25,610
memory region to read from since there

00:36:23,900 --> 00:36:28,460
could be multiple web assembly modules

00:36:25,610 --> 00:36:29,870
in your program this is exactly the sort

00:36:28,460 --> 00:36:31,640
of thing that you need to deal with by

00:36:29,870 --> 00:36:34,010
the way if you're writing a huazi

00:36:31,640 --> 00:36:36,680
implementation as I was describing

00:36:34,010 --> 00:36:38,480
earlier in Perl because a lot of the

00:36:36,680 --> 00:36:41,360
whys and functionality requires reading

00:36:38,480 --> 00:36:45,620
and writing from into the caller's

00:36:41,360 --> 00:36:47,360
memory region to get that contextual

00:36:45,620 --> 00:36:49,640
information we're going to import the

00:36:47,360 --> 00:36:51,350
wizened color memory function this is

00:36:49,640 --> 00:36:52,880
somewhat inspired by the pearl color

00:36:51,350 --> 00:36:55,700
function they both give us information

00:36:52,880 --> 00:37:02,330
about who is calling us in the current

00:36:55,700 --> 00:37:06,950
context next we write a function to

00:37:02,330 --> 00:37:09,050
print the Wesson string since we can

00:37:06,950 --> 00:37:12,500
only pass numbers we pass in a memory

00:37:09,050 --> 00:37:15,050
offset we call the wasm color function

00:37:12,500 --> 00:37:19,130
memory function which returns the memory

00:37:15,050 --> 00:37:21,290
region that we need if the sub sorry if

00:37:19,130 --> 00:37:25,210
the subroutine happens to be called from

00:37:21,290 --> 00:37:25,210
Perl by the way this will return undeath

00:37:31,730 --> 00:37:39,950
we can now convert the offset and the

00:37:35,810 --> 00:37:48,650
memory address to a Perl string and

00:37:39,950 --> 00:37:50,840
print it out from the web assembly side

00:37:48,650 --> 00:37:53,690
we import the print wagon string

00:37:50,840 --> 00:37:59,810
function from the main package using the

00:37:53,690 --> 00:38:01,640
appropriate function signature we use

00:37:59,810 --> 00:38:03,530
the web assembly data segment to store

00:38:01,640 --> 00:38:04,760
the string into alternatively if this

00:38:03,530 --> 00:38:07,730
were a C program this might be

00:38:04,760 --> 00:38:11,150
dynamically allocated but this for this

00:38:07,730 --> 00:38:13,880
example it makes it easy finally we can

00:38:11,150 --> 00:38:22,040
write our function which calls the PISA

00:38:13,880 --> 00:38:26,119
the pro subroutine so after dealing with

00:38:22,040 --> 00:38:27,800
numbers that working and and those

00:38:26,119 --> 00:38:29,390
working so easily the complexity of

00:38:27,800 --> 00:38:30,560
working with strains just kind of makes

00:38:29,390 --> 00:38:33,680
me want to cry a little bit

00:38:30,560 --> 00:38:35,359
especially in Perl you know where we're

00:38:33,680 --> 00:38:39,730
kind of you know working with strings is

00:38:35,359 --> 00:38:41,000
kind of our thing there is hope though

00:38:39,730 --> 00:38:43,130
webassembly

00:38:41,000 --> 00:38:45,710
interface types promise to address a lot

00:38:43,130 --> 00:38:48,260
of this interface types provide an extra

00:38:45,710 --> 00:38:50,510
layer inside webOS in the web assembly

00:38:48,260 --> 00:38:52,630
binary that tell the host how to

00:38:50,510 --> 00:38:55,790
translate complicated types like strings

00:38:52,630 --> 00:38:58,130
the current proposal converts things

00:38:55,790 --> 00:38:59,840
lazily and avoids copies where possible

00:38:58,130 --> 00:39:03,770
so it should be possible to implement

00:38:59,840 --> 00:39:06,440
this fairly efficiently in fact an

00:39:03,770 --> 00:39:07,970
earlier prototype of interface types was

00:39:06,440 --> 00:39:10,400
actually included in an earlier version

00:39:07,970 --> 00:39:13,040
of wasm type but they removed it because

00:39:10,400 --> 00:39:15,710
the implementation and the proposal were

00:39:13,040 --> 00:39:20,150
diverging and this this was

00:39:15,710 --> 00:39:22,940
disappointing to be sure but I think it

00:39:20,150 --> 00:39:24,890
was the good thing to do in the long run

00:39:22,940 --> 00:39:30,170
I think they'll be implementing it right

00:39:24,890 --> 00:39:32,660
rather than than quickly and all this

00:39:30,170 --> 00:39:34,880
works because most languages store

00:39:32,660 --> 00:39:38,060
strings in more or less the same way in

00:39:34,880 --> 00:39:41,600
linear memory objects can be stored as

00:39:38,060 --> 00:39:45,040
pointers array raised and structured

00:39:41,600 --> 00:39:45,040
data should also be fairly doable

00:39:45,059 --> 00:39:48,989
with interface types it should be

00:39:47,130 --> 00:39:51,749
possible to drop the explicit memory

00:39:48,989 --> 00:39:54,509
allocation wrappers and greet p.m. all

00:39:51,749 --> 00:39:57,119
together and go back to calling the web

00:39:54,509 --> 00:39:58,919
assembly from purl directly for at least

00:39:57,119 --> 00:40:01,669
directly from my perspective I don't

00:39:58,919 --> 00:40:08,609
have to worry that it's going through

00:40:01,669 --> 00:40:10,739
the hook interface another challenge the

00:40:08,609 --> 00:40:12,749
current implementation of my wedding

00:40:10,739 --> 00:40:14,459
time bindings is that the method used to

00:40:12,749 --> 00:40:16,709
call and attach webassembly these

00:40:14,459 --> 00:40:19,949
functions is probably somewhat

00:40:16,709 --> 00:40:27,449
suboptimal this is a hot spot that we

00:40:19,949 --> 00:40:30,359
could pretty easily make faster this is

00:40:27,449 --> 00:40:32,579
a hot spot we could make faster I think

00:40:30,359 --> 00:40:33,809
and I think we'd get a big benefit from

00:40:32,579 --> 00:40:38,939
it and I say this from experience

00:40:33,809 --> 00:40:41,400
working with FFI and Perl FFI raw for

00:40:38,939 --> 00:40:43,380
example was the only real apple pie game

00:40:41,400 --> 00:40:45,179
in town before platypus came along I

00:40:43,380 --> 00:40:47,339
know it pretty well because I wrote some

00:40:45,179 --> 00:40:50,519
live archive fun games using it in order

00:40:47,339 --> 00:40:53,339
to teach myself FFI to be honest and I

00:40:50,519 --> 00:40:57,630
also made a lot of PRS to epiphyte Raw

00:40:53,339 --> 00:40:59,400
based on my experience using it what I

00:40:57,630 --> 00:41:05,749
learned from that process I used when

00:40:59,400 --> 00:41:05,749
design platypus anyway FFI raw lets you

00:41:06,529 --> 00:41:11,189
construct an object for each see

00:41:08,579 --> 00:41:13,499
function that you want to call and then

00:41:11,189 --> 00:41:15,359
you can call the function using the

00:41:13,499 --> 00:41:18,209
objects comments if it seems okay right

00:41:15,359 --> 00:41:18,479
I mean seems like the obvious way to do

00:41:18,209 --> 00:41:20,759
it

00:41:18,479 --> 00:41:23,429
except method calls are relatively slow

00:41:20,759 --> 00:41:25,979
because at compile time we don't know

00:41:23,429 --> 00:41:28,439
what class the object belongs to and

00:41:25,979 --> 00:41:30,959
therefore which exact function needs to

00:41:28,439 --> 00:41:33,599
be executed we have to instead compute

00:41:30,959 --> 00:41:36,359
all that runtime which is kind of sad

00:41:33,599 --> 00:41:38,729
because you basically never need to

00:41:36,359 --> 00:41:42,900
subclass epiphyte wrong you're paying

00:41:38,729 --> 00:41:45,409
the penalty for all FFI functions for no

00:41:42,900 --> 00:41:45,409
reason

00:41:46,339 --> 00:41:52,769
flat list took a different approach to

00:41:50,309 --> 00:41:54,509
start with the main object represents

00:41:52,769 --> 00:41:56,819
the library that you're calling into and

00:41:54,509 --> 00:41:57,900
not the function typically only need to

00:41:56,819 --> 00:41:58,890
use it when you're building your

00:41:57,900 --> 00:42:00,809
interface

00:41:58,890 --> 00:42:04,950
when the overhead of mosaic method calls

00:42:00,809 --> 00:42:07,470
is fairly acceptable you still have the

00:42:04,950 --> 00:42:09,480
option of creating a function object the

00:42:07,470 --> 00:42:12,240
flexibility here comes at a performance

00:42:09,480 --> 00:42:14,640
cost but the killer feature of Platypus

00:42:12,240 --> 00:42:16,980
is that you can attach a function as an

00:42:14,640 --> 00:42:21,990
EXO and you get the performance which is

00:42:16,980 --> 00:42:23,789
fairly close to excess the key to all

00:42:21,990 --> 00:42:26,849
this working is the any corner which

00:42:23,789 --> 00:42:28,740
hangs off of an x-up normally this is no

00:42:26,849 --> 00:42:31,640
but we can put anything that we want

00:42:28,740 --> 00:42:34,559
there in the case of platypus

00:42:31,640 --> 00:42:36,089
we put the metadata that Lib FFI needs

00:42:34,559 --> 00:42:37,920
in order to make the underlying c

00:42:36,089 --> 00:42:40,500
function fall I didn't come up with his

00:42:37,920 --> 00:42:43,230
technique by the way bulk 88 showed me

00:42:40,500 --> 00:42:46,349
how to do this he was using the same

00:42:43,230 --> 00:42:50,190
technique in an FF I called win32 API

00:42:46,349 --> 00:42:52,589
I need to be able to use it do fi things

00:42:50,190 --> 00:42:58,559
on non Windows platforms though which is

00:42:52,589 --> 00:43:00,869
why we have platypus today what makes

00:42:58,559 --> 00:43:04,049
things sense here I think is to write in

00:43:00,869 --> 00:43:06,390
the case of wasm is to write some excess

00:43:04,049 --> 00:43:08,849
implementation to for the call and

00:43:06,390 --> 00:43:11,220
attach functionality of the func objects

00:43:08,849 --> 00:43:13,259
we can use the same any pointer

00:43:11,220 --> 00:43:14,069
technique to make attached functions

00:43:13,259 --> 00:43:17,009
quite fast

00:43:14,069 --> 00:43:19,319
there really isn't any benefit I think

00:43:17,009 --> 00:43:22,049
to rewriting the entire API in excess I

00:43:19,319 --> 00:43:26,640
think it probably just made it harder to

00:43:22,049 --> 00:43:28,559
maintain this is exactly what excess is

00:43:26,640 --> 00:43:31,140
good for though which is extending the

00:43:28,559 --> 00:43:33,119
Perl programming language itself the

00:43:31,140 --> 00:43:36,779
module should optionally be installed

00:43:33,119 --> 00:43:38,880
when a compiler isn't certain the module

00:43:36,779 --> 00:43:43,200
should be optionally installed when the

00:43:38,880 --> 00:43:45,029
compiler is available and we should fall

00:43:43,200 --> 00:43:51,000
back on the FFI implementation but it

00:43:45,029 --> 00:43:52,940
isn't another interesting piece of tech

00:43:51,000 --> 00:43:55,410
that I just want to mention is loose it

00:43:52,940 --> 00:43:58,259
it's a compiler that we developed

00:43:55,410 --> 00:44:00,390
in-house it fastly and it's now open

00:43:58,259 --> 00:44:04,380
sourced loose it is a native web

00:44:00,390 --> 00:44:06,329
assembly compiler and runtime lucid

00:44:04,380 --> 00:44:10,920
ahead of time compiles web assembly into

00:44:06,329 --> 00:44:12,990
native 64-bit Intel binaries for even

00:44:10,920 --> 00:44:15,670
better performance

00:44:12,990 --> 00:44:18,310
at the same time lucid binaries have the

00:44:15,670 --> 00:44:20,890
same sandbox safety as a regular

00:44:18,310 --> 00:44:23,560
webassembly one time so it's safe to run

00:44:20,890 --> 00:44:25,750
untrusted web assembly inside your

00:44:23,560 --> 00:44:30,820
application provided that you can figure

00:44:25,750 --> 00:44:31,990
out with the appropriate limits so this

00:44:30,820 --> 00:44:35,020
is the same diagram I've been showing

00:44:31,990 --> 00:44:37,660
this diagram a lot today except for now

00:44:35,020 --> 00:44:41,170
someone has to and it doesn't have to be

00:44:37,660 --> 00:44:44,500
you compile a program into web assembly

00:44:41,170 --> 00:44:46,840
and then once you get it you can convert

00:44:44,500 --> 00:44:50,950
it into a dynamic library using lucid

00:44:46,840 --> 00:44:53,800
the resulting dynamic library can be run

00:44:50,950 --> 00:44:56,980
using the loose at runtime or from

00:44:53,800 --> 00:44:58,450
another program programming language

00:44:56,980 --> 00:45:01,270
there aren't any Pro bindings for the

00:44:58,450 --> 00:45:03,820
any of this at the moment but this tech

00:45:01,270 --> 00:45:09,100
might be useful might have useful

00:45:03,820 --> 00:45:09,670
applications in the future so that's all

00:45:09,100 --> 00:45:11,380
I have for today

00:45:09,670 --> 00:45:13,750
if you're interested in web assembly you

00:45:11,380 --> 00:45:17,050
should definitely come join us on the

00:45:13,750 --> 00:45:20,200
IRC native channel or the Pearl wise and

00:45:17,050 --> 00:45:24,610
github organization I've discussed I

00:45:20,200 --> 00:45:26,830
think some areas where my web assembly

00:45:24,610 --> 00:45:28,300
modules have some limitations

00:45:26,830 --> 00:45:29,770
I think addressing some of those

00:45:28,300 --> 00:45:31,870
limitations could make interesting

00:45:29,770 --> 00:45:35,080
projects for those who are interested in

00:45:31,870 --> 00:45:38,170
the tech oh and I welcome collaborations

00:45:35,080 --> 00:45:40,660
to that end the native channel just as

00:45:38,170 --> 00:45:42,970
an aside is also a good place to discuss

00:45:40,660 --> 00:45:46,380
alien and platypus if those technologies

00:45:42,970 --> 00:45:51,090
sound interesting and with that I will

00:45:46,380 --> 00:45:51,090
say does anybody have any questions I

00:45:53,160 --> 00:45:57,670
cannot see any arrays on at this time

00:45:55,750 --> 00:46:03,750
itself question arise your own in zoom

00:45:57,670 --> 00:46:03,750
please Mike

00:46:04,170 --> 00:46:08,820
go right hello yeah

00:46:09,590 --> 00:46:17,690
yeah so I'm wondering you keep on

00:46:13,370 --> 00:46:20,990
mentioning fastly and I I'm wondering

00:46:17,690 --> 00:46:22,850
are you guys is this stuff that you guys

00:46:20,990 --> 00:46:25,460
are using in production already I know

00:46:22,850 --> 00:46:28,850
that there's a lot of there are a lot of

00:46:25,460 --> 00:46:30,590
competing ideas on the production

00:46:28,850 --> 00:46:33,380
readiness of webassembly

00:46:30,590 --> 00:46:34,640
and things like this at least in the

00:46:33,380 --> 00:46:38,030
circles that I've been around so I'm

00:46:34,640 --> 00:46:40,640
curious to know your your assessment of

00:46:38,030 --> 00:46:44,270
production readiness and you sing this

00:46:40,640 --> 00:46:46,160
stuff in the wild so we are using this

00:46:44,270 --> 00:46:47,840
this is a closed beta at the moment that

00:46:46,160 --> 00:46:53,750
some of our users are actually using

00:46:47,840 --> 00:46:56,660
this at the moment so the idea is to get

00:46:53,750 --> 00:46:58,040
this out fairly fairly quickly so you

00:46:56,660 --> 00:46:59,300
guys already have some of this in front

00:46:58,040 --> 00:47:02,710
of customers and they're looking at it

00:46:59,300 --> 00:47:10,370
already that's correct that's cool

00:47:02,710 --> 00:47:14,210
that's very exciting anybody else we

00:47:10,370 --> 00:47:15,860
have no question yeah I'll equip in this

00:47:14,210 --> 00:47:16,460
is a very tangential question but I'm

00:47:15,860 --> 00:47:19,070
just curious

00:47:16,460 --> 00:47:22,250
the syntax webassembly looked awfully

00:47:19,070 --> 00:47:26,450
let's fish was webassembly recently done

00:47:22,250 --> 00:47:28,730
by with Lisp type people uh it does look

00:47:26,450 --> 00:47:30,310
very list fish I'm actually but I I

00:47:28,730 --> 00:47:34,420
don't know I don't know the answer that

00:47:30,310 --> 00:47:34,420
but I didn't notice that as well

00:47:35,740 --> 00:47:39,300
thank you it was a nice talk I

00:47:37,270 --> 00:48:00,030
appreciate it thank you

00:47:39,300 --> 00:48:00,030
anybody else on the wall that was cool

00:48:03,150 --> 00:48:16,180
was there a question thank you I do not

00:48:12,700 --> 00:48:22,510
see any more question so I guess you can

00:48:16,180 --> 00:48:24,130
continue the discussion online oh that's

00:48:22,510 --> 00:48:29,349
good thank you everybody for attending

00:48:24,130 --> 00:48:30,460
and definitely let me know on the

00:48:29,349 --> 00:48:33,300
appropriate channels if you have

00:48:30,460 --> 00:48:37,560
questions or interested in there and

00:48:33,300 --> 00:48:42,250
what's the best road map to get started

00:48:37,560 --> 00:48:43,810
I mean I would I would install it and

00:48:42,250 --> 00:48:48,400
try running some programs look at the

00:48:43,810 --> 00:48:51,990
documentation show up on the IRC I try

00:48:48,400 --> 00:48:51,990

YouTube URL: https://www.youtube.com/watch?v=T_o51JnI11U


