Title: 2016 - ‎Introduction to Perl Testing‎ - David Oswald
Publication date: 2016-06-27
Playlist: YAPC::NA 2016
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:04,799
so welcome to introduction to testing

00:00:02,970 --> 00:00:07,049
which probably is about the worst though

00:00:04,799 --> 00:00:10,050
the lamest title that I've heard so far

00:00:07,049 --> 00:00:16,109
today yes he talks and I should have a

00:00:10,050 --> 00:00:19,410
much more creative a dif different title

00:00:16,109 --> 00:00:20,820
slides this one probably should that's

00:00:19,410 --> 00:00:23,880
what I think maybe is a little better

00:00:20,820 --> 00:00:26,279
than the old-fashioned until payment my

00:00:23,880 --> 00:00:30,689
name is Dave Oswalt and I work for

00:00:26,279 --> 00:00:32,340
bluehost American national group and I

00:00:30,689 --> 00:00:35,489
live in salt lake city and i work in

00:00:32,340 --> 00:00:37,920
orem utah i want to thank endurance

00:00:35,489 --> 00:00:40,320
really the leader for a week k months on

00:00:37,920 --> 00:00:42,420
saturday and that somebody's setting up

00:00:40,320 --> 00:00:44,610
for the conference and i'll be here to

00:00:42,420 --> 00:00:46,379
friday and vacation after that for the

00:00:44,610 --> 00:00:48,539
miller week so thanks to endurance and

00:00:46,379 --> 00:00:50,149
also a lot of think everybody in this

00:00:48,539 --> 00:00:54,030
room and the throw community at large

00:00:50,149 --> 00:00:57,360
for making the pro topper as possible

00:00:54,030 --> 00:00:59,430
making our careers possible it's i'm

00:00:57,360 --> 00:01:04,260
very much happy to be a part of all of

00:00:59,430 --> 00:01:05,970
this and i got as a previous oksana make

00:01:04,260 --> 00:01:07,650
my family also forget about me for a

00:01:05,970 --> 00:01:14,100
week they are probably thinking you for

00:01:07,650 --> 00:01:15,409
going ok so today's was earlier to learn

00:01:14,100 --> 00:01:16,969
how to write test

00:01:15,409 --> 00:01:18,530
how to write your chest if you've

00:01:16,969 --> 00:01:20,869
already written tons of unit tests that

00:01:18,530 --> 00:01:22,340
are testing everything quite well then

00:01:20,869 --> 00:01:24,200
this probably is not the top for you

00:01:22,340 --> 00:01:26,450
we're not going to get into deep issues

00:01:24,200 --> 00:01:28,250
of how to test the untestable and things

00:01:26,450 --> 00:01:30,289
like that we're going to talk about how

00:01:28,250 --> 00:01:33,109
to thank you to the test mentality and

00:01:30,289 --> 00:01:34,340
how to write simple tests so that's

00:01:33,109 --> 00:01:35,569
where you want to be then we're in the

00:01:34,340 --> 00:01:37,159
right room this is kind of like the

00:01:35,569 --> 00:01:39,380
first day of class at the University

00:01:37,159 --> 00:01:41,810
with Professor Cisco this is writing 101

00:01:39,380 --> 00:01:43,340
may be expected to be a math three up to

00:01:41,810 --> 00:01:45,349
this is the wrong room and somebody

00:01:43,340 --> 00:01:48,259
always gets up and speaks out so this is

00:01:45,349 --> 00:01:53,539
your opportunity or any point throughout

00:01:48,259 --> 00:01:55,640
no arguments happen so we're going to

00:01:53,539 --> 00:01:58,819
support a desk all just more we're going

00:01:55,640 --> 00:02:00,409
to learn how to prove our code then but

00:01:58,819 --> 00:02:03,379
also I like to kind of have fun on

00:02:00,409 --> 00:02:05,569
talking I I do these things because I

00:02:03,379 --> 00:02:07,579
enjoyed an have fun preparing and also

00:02:05,569 --> 00:02:10,069
have fun Gideon's so that's try to enjoy

00:02:07,579 --> 00:02:17,299
ourselves a little bit today but not too

00:02:10,069 --> 00:02:20,450
much fun okay so some resources that i

00:02:17,299 --> 00:02:23,269
consider valuable in learning about

00:02:20,450 --> 00:02:26,480
testing are the books intermediate pearl

00:02:23,269 --> 00:02:28,670
the book modern girl pearl testing a

00:02:26,480 --> 00:02:30,650
developer's know my chromatic is a very

00:02:28,670 --> 00:02:33,680
good resource and even the documentation

00:02:30,650 --> 00:02:38,510
for test war and the module for all good

00:02:33,680 --> 00:02:40,459
resources i think i was at a point about

00:02:38,510 --> 00:02:42,560
ten years ago where I kept hearing

00:02:40,459 --> 00:02:44,510
people talking about running tests and I

00:02:42,560 --> 00:02:47,750
had this big concept of what that really

00:02:44,510 --> 00:02:51,260
meant but it didn't but I haven't really

00:02:47,750 --> 00:02:53,480
deeply explored how that works and

00:02:51,260 --> 00:02:55,940
making a mental leap from I'm running

00:02:53,480 --> 00:02:57,319
this software to how do I write tests to

00:02:55,940 --> 00:02:59,569
make software working with something

00:02:57,319 --> 00:03:03,210
that was a little important to me a

00:02:59,569 --> 00:03:05,460
while back but once i have read

00:03:03,210 --> 00:03:09,090
these materials really all came together

00:03:05,460 --> 00:03:11,490
for me and so they're good resources so

00:03:09,090 --> 00:03:14,280
what is your testing for every unit of

00:03:11,490 --> 00:03:16,800
code we're going to write code the folks

00:03:14,280 --> 00:03:21,180
that code and verifies that the results

00:03:16,800 --> 00:03:23,880
will be expect we tested many edge cases

00:03:21,180 --> 00:03:25,940
and logic palaces we possibly can when

00:03:23,880 --> 00:03:30,090
writing your chest or at least we should

00:03:25,940 --> 00:03:35,100
after E and we this also means we have

00:03:30,090 --> 00:03:37,620
to write code that is testable I want to

00:03:35,100 --> 00:03:42,030
give an example of in Perl kind of color

00:03:37,620 --> 00:03:45,840
a hierarchy of files might work for you

00:03:42,030 --> 00:03:49,500
to test your might have up here over

00:03:45,840 --> 00:03:51,510
with some sort of scripting in the runs

00:03:49,500 --> 00:03:54,030
we might have a lip folder with the

00:03:51,510 --> 00:03:57,780
module that we would like to test and a

00:03:54,030 --> 00:03:59,310
lot of T folder with various programs in

00:03:57,780 --> 00:04:02,210
it we're going to rock various scripts

00:03:59,310 --> 00:04:04,620
run two run two run our tests so

00:04:02,210 --> 00:04:07,620
sometimes a little visual upfront kind

00:04:04,620 --> 00:04:10,560
of helps so we'll get to a point where

00:04:07,620 --> 00:04:14,100
our little test scripts here are going

00:04:10,560 --> 00:04:18,299
to run and test out our library or

00:04:14,100 --> 00:04:20,790
target there's no introductory to

00:04:18,299 --> 00:04:24,150
testing that to be given without bottom

00:04:20,790 --> 00:04:25,650
of just different driven development now

00:04:24,150 --> 00:04:29,760
I'm sure if you're already got juices

00:04:25,650 --> 00:04:32,040
test driven development but it's giddy

00:04:29,760 --> 00:04:34,670
about it either good great you guys

00:04:32,040 --> 00:04:34,670
should be here

00:04:34,680 --> 00:04:40,180
Chester development is starts with the

00:04:38,590 --> 00:04:44,350
concept that all code is guilty until

00:04:40,180 --> 00:04:47,260
proven innocent or I wrecked our phone

00:04:44,350 --> 00:04:49,540
delicious take on which is it's not a

00:04:47,260 --> 00:04:51,850
feature until there's tests you know

00:04:49,540 --> 00:04:54,820
captures how accepted until their tests

00:04:51,850 --> 00:04:57,610
in support of the patch no a new a new

00:04:54,820 --> 00:05:01,720
method is not part of malicious until

00:04:57,610 --> 00:05:03,340
there's a test testing that method the

00:05:01,720 --> 00:05:07,380
way test-driven development works is

00:05:03,340 --> 00:05:09,760
that initially write tests that fail and

00:05:07,380 --> 00:05:13,960
thank you right enough coach make the

00:05:09,760 --> 00:05:15,520
test pass and one suggests ask there

00:05:13,960 --> 00:05:18,280
could be factored your coat together the

00:05:15,520 --> 00:05:19,780
two prove its code call me I think it

00:05:18,280 --> 00:05:22,750
would be the process so you do this in

00:05:19,780 --> 00:05:25,510
small chunks small segments some of the

00:05:22,750 --> 00:05:29,050
things that I work on are relatively

00:05:25,510 --> 00:05:32,080
complex and have some terrible type

00:05:29,050 --> 00:05:34,090
coupling and so for me many times the

00:05:32,080 --> 00:05:34,600
only way the only opportunity that we

00:05:34,090 --> 00:05:37,420
have to

00:05:34,600 --> 00:05:39,670
or even actually touch the code that I'm

00:05:37,420 --> 00:05:41,950
writing is to write tests it can go

00:05:39,670 --> 00:05:44,500
through a whole line seen setup process

00:05:41,950 --> 00:05:46,870
and some really running tests for me is

00:05:44,500 --> 00:05:52,630
very much a part of be able to make any

00:05:46,870 --> 00:05:53,860
progress in what I'm working so to

00:05:52,630 --> 00:05:55,570
reiterate the steps we're going to write

00:05:53,860 --> 00:05:57,580
tests that will fail because the code

00:05:55,570 --> 00:05:59,650
doesn't yet exist as test-driven

00:05:57,580 --> 00:06:01,810
development then we will write the

00:05:59,650 --> 00:06:03,730
simplest skills practical however a

00:06:01,810 --> 00:06:05,770
little foresight is sometimes useful for

00:06:03,730 --> 00:06:08,170
example if we know in our tests that

00:06:05,770 --> 00:06:10,690
we're looking for to the others were

00:06:08,170 --> 00:06:12,010
writing a method called an 11 it doesn't

00:06:10,690 --> 00:06:14,890
do any good to actually write a method

00:06:12,010 --> 00:06:18,780
that just returns to go for site is

00:06:14,890 --> 00:06:21,400
useful in the copyright to pass our test

00:06:18,780 --> 00:06:24,520
and I finally we're going to verify that

00:06:21,400 --> 00:06:27,220
the test now passes and if it does pass

00:06:24,520 --> 00:06:28,780
them around another chest and then we're

00:06:27,220 --> 00:06:32,200
code to support that they've not the

00:06:28,780 --> 00:06:34,000
wolffish together and then we can

00:06:32,200 --> 00:06:36,670
refactor and improve the functionality

00:06:34,000 --> 00:06:39,280
improve the elegancy literally as we

00:06:36,670 --> 00:06:41,010
want to do and refactor the code one

00:06:39,280 --> 00:06:45,970
point that I like to make is that

00:06:41,010 --> 00:06:47,920
testing gives us the power to refactor a

00:06:45,970 --> 00:06:50,440
lot of times if they're not testify

00:06:47,920 --> 00:06:52,330
severe to hear afraid to even touch the

00:06:50,440 --> 00:06:53,449
code that you've written because how can

00:06:52,330 --> 00:06:55,009
you ever prove it

00:06:53,449 --> 00:06:57,439
to do what we expected to us to do a

00:06:55,009 --> 00:06:58,849
second time it worked the first time you

00:06:57,439 --> 00:07:00,559
almost feel like you have to replicate

00:06:58,849 --> 00:07:02,900
blood for blog everything you've done

00:07:00,559 --> 00:07:04,639
your original iteration with tests in

00:07:02,900 --> 00:07:08,089
place you have the freedom to refactor

00:07:04,639 --> 00:07:10,189
so gestures and development is a

00:07:08,089 --> 00:07:12,650
trade-off it's the slower way to write a

00:07:10,189 --> 00:07:14,240
HelloWorld so to speak it's maybe a

00:07:12,650 --> 00:07:15,830
slower way to arrive there are that

00:07:14,240 --> 00:07:19,839
article but it's the faster way to

00:07:15,830 --> 00:07:22,789
develop on trivial solutions I believe

00:07:19,839 --> 00:07:26,479
bugs are spotted and fixed as they occur

00:07:22,789 --> 00:07:27,560
we hope and you know Justin powers to

00:07:26,479 --> 00:07:30,860
make changes test-driven development

00:07:27,560 --> 00:07:38,479
leaves us with both code and airway

00:07:30,860 --> 00:07:39,800
regression tests only employs one thing

00:07:38,479 --> 00:07:42,139
that I should mention when I say blogs

00:07:39,800 --> 00:07:44,270
are spotted it fixed as they occur that

00:07:42,139 --> 00:07:46,310
is only as much as the developer in

00:07:44,270 --> 00:07:49,129
himself or myself doesn't have our

00:07:46,310 --> 00:07:52,159
blinders on so we are always we always

00:07:49,129 --> 00:07:52,520
have a certain set of blinders on it's

00:07:52,159 --> 00:07:55,370
worth

00:07:52,520 --> 00:07:56,660
come we write test because we expect

00:07:55,370 --> 00:07:59,349
well this is an assertion that we're

00:07:56,660 --> 00:08:02,659
making in the code for writing but we

00:07:59,349 --> 00:08:04,900
may not be thinking of everything and so

00:08:02,659 --> 00:08:07,039
I'm running my tests i'm running my code

00:08:04,900 --> 00:08:10,400
one of the things i didn't think about

00:08:07,039 --> 00:08:13,280
well so testing running tests up front

00:08:10,400 --> 00:08:17,060
is very helpful in making assertions

00:08:13,280 --> 00:08:18,650
that the code is working as i expect but

00:08:17,060 --> 00:08:20,060
it may not be all that helpful in making

00:08:18,650 --> 00:08:26,780
sure that the code is working as

00:08:20,060 --> 00:08:29,210
everybody else would expect as well so

00:08:26,780 --> 00:08:31,550
testing is easiest to accomplish what

00:08:29,210 --> 00:08:34,550
we're testing in small chunks for

00:08:31,550 --> 00:08:38,300
writing small chunks of testable code if

00:08:34,550 --> 00:08:40,310
you if you write the windows operating

00:08:38,300 --> 00:08:42,560
system and then try to write the tests

00:08:40,310 --> 00:08:45,890
to test the front end of it that's very

00:08:42,560 --> 00:08:48,320
hard right if you write small chunks of

00:08:45,890 --> 00:08:50,660
code and test those small chunks that's

00:08:48,320 --> 00:08:52,510
very easy to do so we tested code in

00:08:50,660 --> 00:08:55,100
small chunks one nice thing about

00:08:52,510 --> 00:08:57,649
writing our chest as we're writing our

00:08:55,100 --> 00:08:59,570
code is that it forces us to think in

00:08:57,649 --> 00:09:01,250
these smaller chunks and it tends to

00:08:59,570 --> 00:09:03,950
lead us to more generalized more

00:09:01,250 --> 00:09:07,959
generally useful solutions and to having

00:09:03,950 --> 00:09:07,959
simpler and easier to reason about code

00:09:08,350 --> 00:09:12,050
coatings volumes of functionality

00:09:10,610 --> 00:09:15,310
they're easier to reason about easier to

00:09:12,050 --> 00:09:17,510
test and heaps of steaming spaghetti

00:09:15,310 --> 00:09:19,290
factor complexity and the smaller

00:09:17,510 --> 00:09:23,550
subroutines so they can be just

00:09:19,290 --> 00:09:29,279
isolation and decoupled object from

00:09:23,550 --> 00:09:31,440
Turkey immigrations so the word about

00:09:29,279 --> 00:09:33,209
modular design not trivial applications

00:09:31,440 --> 00:09:36,600
should be should put as much work as

00:09:33,209 --> 00:09:38,850
possible into separate modules so if

00:09:36,600 --> 00:09:41,750
you're writing a crime and it's a

00:09:38,850 --> 00:09:44,160
non-trivial crime has to run on a system

00:09:41,750 --> 00:09:46,110
rather than putting all of the code in

00:09:44,160 --> 00:09:49,620
the application pilot of the crime file

00:09:46,110 --> 00:09:51,389
itself in the crumb script itself right

00:09:49,620 --> 00:09:54,480
a module that happens your business your

00:09:51,389 --> 00:09:56,550
business logic and then your Kron script

00:09:54,480 --> 00:09:58,829
can be simple wrapper around to have

00:09:56,550 --> 00:10:01,259
module and that enables you to test it's

00:09:58,829 --> 00:10:06,690
much easier to just the module then the

00:10:01,259 --> 00:10:08,190
runnable script itself so in this

00:10:06,690 --> 00:10:12,209
example that I have here the main

00:10:08,190 --> 00:10:15,000
application might be used my module will

00:10:12,209 --> 00:10:17,880
do it and then call do it and then die

00:10:15,000 --> 00:10:22,019
it if we don't get success and that's

00:10:17,880 --> 00:10:24,149
that might be our civil script and we

00:10:22,019 --> 00:10:27,209
really have a heart blue or suggesting

00:10:24,149 --> 00:10:34,139
that it's much easier to test the code

00:10:27,209 --> 00:10:37,199
my module so why do we want to write in

00:10:34,139 --> 00:10:40,649
small chunks of functionality and tested

00:10:37,199 --> 00:10:43,350
up the flight recorder is a good great

00:10:40,649 --> 00:10:45,959
example of black box it receives

00:10:43,350 --> 00:10:48,899
information in and upon request gives us

00:10:45,959 --> 00:10:51,360
information out and it's heavily well

00:10:48,899 --> 00:10:52,740
tested and we expect that it's going to

00:10:51,360 --> 00:10:55,019
work and we know that it's going to work

00:10:52,740 --> 00:10:55,850
another example that's a great example

00:10:55,019 --> 00:11:00,730
to be

00:10:55,850 --> 00:11:03,110
molarity is the Mars rover where I

00:11:00,730 --> 00:11:05,720
presume I don't work for NASA that I

00:11:03,110 --> 00:11:11,120
presume that every component of this was

00:11:05,720 --> 00:11:13,069
tested individually they have probably

00:11:11,120 --> 00:11:14,269
statistics on hello the wheels are going

00:11:13,069 --> 00:11:16,399
to where the tires are going to where

00:11:14,269 --> 00:11:17,660
they know how the camera is going to

00:11:16,399 --> 00:11:19,610
work and how the arms are going to work

00:11:17,660 --> 00:11:21,800
each of those units of functionality are

00:11:19,610 --> 00:11:23,779
tested in isolation before the great

00:11:21,800 --> 00:11:26,569
integration takes place putting together

00:11:23,779 --> 00:11:28,220
the rover and lunch in it because it

00:11:26,569 --> 00:11:30,800
just need you to test model or coating

00:11:28,220 --> 00:11:32,899
it's harder to test a great ball of

00:11:30,800 --> 00:11:36,170
spaghetti or rubber bands over

00:11:32,899 --> 00:11:37,970
everything and the real world

00:11:36,170 --> 00:11:41,209
unfortunately were presented with the

00:11:37,970 --> 00:11:43,550
great ball of rubber bands most of the

00:11:41,209 --> 00:11:46,250
code that i look at this is so tightly

00:11:43,550 --> 00:11:47,750
coupled with in hard test but as we're

00:11:46,250 --> 00:11:51,829
working we should maybe strive to

00:11:47,750 --> 00:11:55,819
improve that situation so we're going to

00:11:51,829 --> 00:11:59,149
look at a simple test framework we have

00:11:55,819 --> 00:12:01,160
an application directory and in that

00:11:59,149 --> 00:12:04,180
application directory we have for

00:12:01,160 --> 00:12:07,699
example an application sub backdrop PL

00:12:04,180 --> 00:12:10,189
and we're going to have a couple of

00:12:07,699 --> 00:12:16,699
libraries led by module if some other

00:12:10,189 --> 00:12:18,589
thing doesn't better and then in the t

00:12:16,699 --> 00:12:20,389
directory we're going to go ahead and

00:12:18,589 --> 00:12:20,769
put our justice scripts that are going

00:12:20,389 --> 00:12:23,649
to

00:12:20,769 --> 00:12:27,790
to keep the code that runs the tests are

00:12:23,649 --> 00:12:30,629
modules so here's an example of a simple

00:12:27,790 --> 00:12:30,629
application

00:12:34,080 --> 00:12:38,910
our simple application uses Fineman to

00:12:37,350 --> 00:12:40,290
know where the library is and he's a

00:12:38,910 --> 00:12:42,410
stricter mornings and it uses the

00:12:40,290 --> 00:12:48,480
modules in the main application code

00:12:42,410 --> 00:12:50,730
that we saw before similar to and again

00:12:48,480 --> 00:12:52,830
we're showing that we want to put most

00:12:50,730 --> 00:12:55,200
of the business logic and most of the

00:12:52,830 --> 00:12:59,010
difficult stuff we want to test into our

00:12:55,200 --> 00:13:00,600
modules in practice it's hard to blow

00:12:59,010 --> 00:13:03,240
the entire one time down tomorrow

00:13:00,600 --> 00:13:05,990
modular dependencies but as we strive to

00:13:03,240 --> 00:13:08,370
shift as much business logic as possible

00:13:05,990 --> 00:13:10,050
and keep package me as simple as

00:13:08,370 --> 00:13:12,180
possible it makes it easier to test the

00:13:10,050 --> 00:13:14,210
code but they are very small subroutines

00:13:12,180 --> 00:13:18,080
be easy tests and separate modules

00:13:14,210 --> 00:13:20,250
facilitate this testing so our examples

00:13:18,080 --> 00:13:22,410
our examples are going to differ a

00:13:20,250 --> 00:13:24,210
little bit from what I've just explained

00:13:22,410 --> 00:13:25,890
we're going to go ahead and throw the

00:13:24,210 --> 00:13:28,770
code we're testing right into our test

00:13:25,890 --> 00:13:30,300
scripts there are examples here because

00:13:28,770 --> 00:13:35,160
it makes it easier for me to show up on

00:13:30,300 --> 00:13:38,130
screen some of the basic tools for

00:13:35,160 --> 00:13:40,170
testing our test more is everybody here

00:13:38,130 --> 00:13:44,220
use just for is anything to use it some

00:13:40,170 --> 00:13:48,740
people okay test harness which executes

00:13:44,220 --> 00:13:52,890
sour chest sweets and Rhys consumes tap

00:13:48,740 --> 00:13:55,170
let's discuss what temp is just more is

00:13:52,890 --> 00:13:57,330
a framework that produces output as it

00:13:55,170 --> 00:13:59,730
runs our tests and the output that it

00:13:57,330 --> 00:14:04,710
produces a bunch is a bunch of OTAs are

00:13:59,730 --> 00:14:06,480
not 0 case if we call that tap output

00:14:04,710 --> 00:14:08,700
and it's a it's a regular outlet that

00:14:06,480 --> 00:14:11,300
can be easily parsed and test harness

00:14:08,700 --> 00:14:13,339
tardy kept parses that tap

00:14:11,300 --> 00:14:17,570
or jack stands for chest anything

00:14:13,339 --> 00:14:20,990
protocol just harnish processes that tap

00:14:17,570 --> 00:14:24,920
output and produces a summary of pass

00:14:20,990 --> 00:14:26,690
and fail for our justice to me and to

00:14:24,920 --> 00:14:30,350
run the test harness me is an

00:14:26,690 --> 00:14:33,110
application called proof and it's

00:14:30,350 --> 00:14:35,540
provided my chest harness in it it

00:14:33,110 --> 00:14:38,450
basically runs our test suite for us so

00:14:35,540 --> 00:14:40,790
it's look at simple set of tests in this

00:14:38,450 --> 00:14:44,750
example we're using chest war and we

00:14:40,790 --> 00:14:47,209
will implement the function divided we

00:14:44,750 --> 00:14:49,670
pass into the right dividend divisor and

00:14:47,209 --> 00:14:52,370
we return the dividend divided by the

00:14:49,670 --> 00:14:57,680
divisor you can see it's very complex

00:14:52,370 --> 00:15:02,300
code and then we're going to go ahead

00:14:57,680 --> 00:15:05,470
and test this code and we can justify

00:15:02,300 --> 00:15:12,459
simply asking questions is it okay to

00:15:05,470 --> 00:15:12,459
assert that dividing for like u equals 2

00:15:13,180 --> 00:15:18,620
and then we give our chest a thing even

00:15:15,790 --> 00:15:21,649
possible easily even positive integers

00:15:18,620 --> 00:15:24,140
we call this test then we ask is ok to

00:15:21,649 --> 00:15:27,260
divide negative 3 by 3 and get a

00:15:24,140 --> 00:15:31,339
negative one does that assertion come

00:15:27,260 --> 00:15:34,550
out ok so on the left you can see we

00:15:31,339 --> 00:15:38,240
have a swing we're going on the left

00:15:34,550 --> 00:15:41,420
here we have a boolean assertion and if

00:15:38,240 --> 00:15:43,459
that bully assertion is true that are ok

00:15:41,420 --> 00:15:49,129
that it is going to produce out

00:15:43,459 --> 00:15:51,800
that is true and we were testing

00:15:49,129 --> 00:15:54,079
floating point for example so now I i

00:15:51,800 --> 00:15:55,730
have created divided function and i said

00:15:54,079 --> 00:15:57,170
well what are they maybe the edge cases

00:15:55,730 --> 00:15:59,119
that i should check out in my division

00:15:57,170 --> 00:16:01,790
function well I want to make sure that

00:15:59,119 --> 00:16:04,339
even positive integers can be divided

00:16:01,790 --> 00:16:06,110
correctly I always see if negative and

00:16:04,339 --> 00:16:07,759
positive comes out correctly because as

00:16:06,110 --> 00:16:09,679
we know you have to make packet that

00:16:07,759 --> 00:16:12,829
consideration when you're doing long

00:16:09,679 --> 00:16:14,240
division and i Wasi of two negatives for

00:16:12,829 --> 00:16:16,040
ha correctly that's another edge case

00:16:14,240 --> 00:16:18,429
perhaps and then I want to see a

00:16:16,040 --> 00:16:21,740
floating point is handled correctly and

00:16:18,429 --> 00:16:24,199
so you know i have tested several

00:16:21,740 --> 00:16:25,999
assertions and those are the assertions

00:16:24,199 --> 00:16:28,759
based on my kind of knowledge of the

00:16:25,999 --> 00:16:31,129
problem domain of division assertions

00:16:28,759 --> 00:16:34,129
that I know must be must be true with my

00:16:31,129 --> 00:16:37,819
division is working when i run those

00:16:34,129 --> 00:16:40,790
tests just sweet on the left it's going

00:16:37,819 --> 00:16:42,529
to produce this output on the right okay

00:16:40,790 --> 00:16:43,440
one even if even buzzed avengers i'm

00:16:42,529 --> 00:16:45,420
going to okay

00:16:43,440 --> 00:16:56,340
okay for that's why you tell me they're

00:16:45,420 --> 00:16:58,980
back test 1 through 4 now let's let's

00:16:56,340 --> 00:17:00,840
change our test a little bit we're going

00:16:58,980 --> 00:17:05,100
to say the dividing sick negative six x

00:17:00,840 --> 00:17:07,350
negative 1 equals 5 which is a right we

00:17:05,100 --> 00:17:08,819
chased one of our tests a little bit and

00:17:07,350 --> 00:17:12,050
now you can see what fail looks like

00:17:08,819 --> 00:17:15,000
okay what okay to not okay three two

00:17:12,050 --> 00:17:18,230
negatives that test tail and tells me

00:17:15,000 --> 00:17:21,300
which lines within my chest script fail

00:17:18,230 --> 00:17:26,459
so I can find it easily and this is why

00:17:21,300 --> 00:17:29,520
i was also useful to give unique names

00:17:26,459 --> 00:17:32,220
to our tests because i can easily look

00:17:29,520 --> 00:17:33,990
and see about okay two negatives like a

00:17:32,220 --> 00:17:38,420
look at my coat on the left there and

00:17:33,990 --> 00:17:41,040
find out which the tests it was a fail

00:17:38,420 --> 00:17:45,960
so i might ask myself what should happen

00:17:41,040 --> 00:17:52,470
will be divided by 0 and i might decide

00:17:45,960 --> 00:17:54,360
well if we divide by zero then we should

00:17:52,470 --> 00:17:56,370
not get back at the find number we

00:17:54,360 --> 00:18:00,450
should get back on yet is what I like a

00:17:56,370 --> 00:18:03,630
certain this particular chest and so

00:18:00,450 --> 00:18:05,510
I've not want to fight by my function to

00:18:03,630 --> 00:18:08,090
return i'm def

00:18:05,510 --> 00:18:12,560
if the divisor is equal to zero and that

00:18:08,090 --> 00:18:14,120
will run our tests or maybe we can

00:18:12,560 --> 00:18:17,200
decide that the right thing to do is

00:18:14,120 --> 00:18:27,080
what everybody else does which is to

00:18:17,200 --> 00:18:31,160
which is to throw exception when we run

00:18:27,080 --> 00:18:33,230
the tests will get okay 1/0 there's two

00:18:31,160 --> 00:18:36,400
ways to run the tests one you can run

00:18:33,230 --> 00:18:39,980
girl and then execute your chest script

00:18:36,400 --> 00:18:42,320
or you can use proof and prove produces

00:18:39,980 --> 00:18:48,590
the tapout book which includes the pass

00:18:42,320 --> 00:18:55,070
and fail at the bottom so let's look at

00:18:48,590 --> 00:18:58,310
another way to test for exceptions here

00:18:55,070 --> 00:19:03,560
we're looking for a return value and

00:18:58,310 --> 00:19:06,800
we're evaluating divided 510 if Alice

00:19:03,560 --> 00:19:11,990
way to trap any exceptions and they're

00:19:06,800 --> 00:19:15,860
down at the bottom we have okay the

00:19:11,990 --> 00:19:20,390
exception is like this regular

00:19:15,860 --> 00:19:23,000
expression so now we're by using light

00:19:20,390 --> 00:19:27,200
we're comparing the exception that we

00:19:23,000 --> 00:19:30,410
got win this to an exception with the

00:19:27,200 --> 00:19:35,960
pattern recogn special pattern a legal

00:19:30,410 --> 00:19:40,630
division and when we run that then we

00:19:35,960 --> 00:19:40,630
get ok to exception is it legal division

00:19:41,890 --> 00:19:46,960
any questions so far we're going to come

00:19:44,180 --> 00:19:46,960
back and get all that

00:19:51,370 --> 00:19:57,020
so the first function the first test

00:19:55,340 --> 00:19:59,809
function that you saw me use was one

00:19:57,020 --> 00:20:02,870
held okay and two okay to test an

00:19:59,809 --> 00:20:05,240
expression and a name and the expression

00:20:02,870 --> 00:20:07,669
is evaluated for fully in truth and if

00:20:05,240 --> 00:20:11,230
it gets back brewing truth and your

00:20:07,669 --> 00:20:13,669
chest passes okay successful and if it

00:20:11,230 --> 00:20:18,559
evaluates to boolean false to your test

00:20:13,669 --> 00:20:19,970
fails okay not okay the test fail so

00:20:18,559 --> 00:20:24,980
there are a few more functions provided

00:20:19,970 --> 00:20:29,000
by chest more is isn't compared okay

00:20:24,980 --> 00:20:33,200
like unlink is deeply and a few others i

00:20:29,000 --> 00:20:38,480
love each of those so first let's look

00:20:33,200 --> 00:20:41,059
at strengths here i have a subroutine

00:20:38,480 --> 00:20:48,169
that alphabetize is the characters in a

00:20:41,059 --> 00:20:51,370
string and alphabetize us in a skier we

00:20:48,169 --> 00:20:53,360
should say now i'm going to test is I

00:20:51,370 --> 00:20:57,380
mean make my function called

00:20:53,360 --> 00:21:01,220
alphabetized ASDF is the response that I

00:20:57,380 --> 00:21:04,159
get back from a subroutine adfs which is

00:21:01,220 --> 00:21:06,380
the alphabetical order and if it is that

00:21:04,159 --> 00:21:08,059
my test will cast and we'll share up

00:21:06,380 --> 00:21:11,919
when i'm not going to get ok one

00:21:08,059 --> 00:21:11,919
alphabetized astr

00:21:16,519 --> 00:21:22,129
so the way you call each of these

00:21:19,249 --> 00:21:24,349
commonly used subroutines in touch more

00:21:22,129 --> 00:21:28,639
okay it's a boolean expression in a name

00:21:24,349 --> 00:21:31,129
is gets a target strength and I wanted

00:21:28,639 --> 00:21:33,519
strength or i guess the strength and

00:21:31,129 --> 00:21:37,879
we're testing against the control string

00:21:33,519 --> 00:21:40,099
against the one on stream isn't gives us

00:21:37,879 --> 00:21:42,709
the string that we want or the string

00:21:40,099 --> 00:21:45,679
that we are testing and make sure it is

00:21:42,709 --> 00:21:50,450
not the same as the string that we don't

00:21:45,679 --> 00:21:53,299
want to get like tests are streaming

00:21:50,450 --> 00:21:55,249
against a regular expression unlike

00:21:53,299 --> 00:22:01,099
tests that are string does not match a

00:21:55,249 --> 00:22:03,440
regular expression and cmp okay compare

00:22:01,099 --> 00:22:06,440
okay I'm not supposed to walk around

00:22:03,440 --> 00:22:10,659
because I go on camera but i guess i'll

00:22:06,440 --> 00:22:13,279
just point it my mouse cmp okay we test

00:22:10,659 --> 00:22:16,579
the return for our promoter is the

00:22:13,279 --> 00:22:19,459
protesting against something that we

00:22:16,579 --> 00:22:21,559
want and then we can provide relational

00:22:19,459 --> 00:22:26,599
operator in here less than greater than

00:22:21,559 --> 00:22:29,179
equal to naught equal to then the final

00:22:26,599 --> 00:22:31,609
one here is deeply is nice because it

00:22:29,179 --> 00:22:35,179
allows us to take an entire data

00:22:31,609 --> 00:22:38,479
structure and test it against a bunch of

00:22:35,179 --> 00:22:41,079
data structure deeply recursively and

00:22:38,479 --> 00:22:45,049
we'll look at that in just a minute here

00:22:41,079 --> 00:22:47,839
so we've already seen this one okay on

00:22:45,049 --> 00:22:49,789
the Left we have one plus one equals two

00:22:47,839 --> 00:22:52,519
this code is actually going to radically

00:22:49,789 --> 00:22:55,969
run our test it's going to test one plus

00:22:52,519 --> 00:22:56,620
one to see if it is equal to two and if

00:22:55,969 --> 00:23:01,150
it is

00:22:56,620 --> 00:23:04,170
it will print okay it is we're going to

00:23:01,150 --> 00:23:06,910
test the string against another strength

00:23:04,170 --> 00:23:09,970
with isn't again they're just a string

00:23:06,910 --> 00:23:12,760
against another string with like we're

00:23:09,970 --> 00:23:16,930
going to test a straight against a

00:23:12,760 --> 00:23:19,450
regular expression unlike again strength

00:23:16,930 --> 00:23:23,470
against the regular expression with

00:23:19,450 --> 00:23:25,540
compare okay we test available apps with

00:23:23,470 --> 00:23:27,430
the thing on the right using the

00:23:25,540 --> 00:23:32,320
operator that we have in quotes in the

00:23:27,430 --> 00:23:35,559
middle so on the Left we're going to

00:23:32,320 --> 00:23:37,120
compare one with to numerically here

00:23:35,559 --> 00:23:41,620
we're going to compare date with my

00:23:37,120 --> 00:23:45,929
brother dad using greater than and that

00:23:41,620 --> 00:23:50,590
will be asking that ago in comparison

00:23:45,929 --> 00:23:56,320
string less comparison this one's a lot

00:23:50,590 --> 00:23:58,420
of fun is deeply with is deeply at the

00:23:56,320 --> 00:24:01,260
top of here we're creating a structure

00:23:58,420 --> 00:24:03,760
the structure contains an array breath

00:24:01,260 --> 00:24:05,020
the first element of the array ref is a

00:24:03,760 --> 00:24:06,429
number of the second element of the

00:24:05,020 --> 00:24:08,620
array run there's another reference to

00:24:06,429 --> 00:24:11,410
the Ray that contains two elements and

00:24:08,620 --> 00:24:13,030
then the next element is another array

00:24:11,410 --> 00:24:13,650
that contains two elements and then

00:24:13,030 --> 00:24:16,890
finally

00:24:13,650 --> 00:24:21,520
we're going to say is my structure here

00:24:16,890 --> 00:24:22,930
equal to this structure and if so then

00:24:21,520 --> 00:24:26,110
we're OK in the structures met

00:24:22,930 --> 00:24:28,180
recursively so where is that useful to

00:24:26,110 --> 00:24:33,750
me it's useful when testing for example

00:24:28,180 --> 00:24:37,000
Jason decodes or ingest ingesting

00:24:33,750 --> 00:24:45,250
objects internal attributes and objects

00:24:37,000 --> 00:24:47,710
internal state ok here's an example

00:24:45,250 --> 00:24:49,990
using his deeply so my structure one two

00:24:47,710 --> 00:24:51,460
three four five and six is deeply when

00:24:49,990 --> 00:24:54,400
we run it says the structures met

00:24:51,460 --> 00:24:57,790
recursively one of the reasons that is

00:24:54,400 --> 00:25:00,370
deeply is so useful is that when it

00:24:57,790 --> 00:25:04,440
fails it tells you right birthday oh so

00:25:00,370 --> 00:25:07,810
here we asked if the four and the five

00:25:04,440 --> 00:25:10,390
and their point when a species the four

00:25:07,810 --> 00:25:14,110
and the five here I'm testing to see if

00:25:10,390 --> 00:25:18,640
those actually are five and for which

00:25:14,110 --> 00:25:21,580
they are up so that's going to fail when

00:25:18,640 --> 00:25:25,480
it fails it tells us that the structures

00:25:21,580 --> 00:25:29,500
began differing at this point and that

00:25:25,480 --> 00:25:34,960
we got before we get spectre-2 five so

00:25:29,500 --> 00:25:37,690
that's to be immensely useful this is

00:25:34,960 --> 00:25:41,020
also why we use is instead of okay

00:25:37,690 --> 00:25:43,810
because when it fails it tells you that

00:25:41,020 --> 00:25:46,450
expected the thing on the left I got

00:25:43,810 --> 00:25:46,909
some other thing what I wanted was the

00:25:46,450 --> 00:25:49,369
thing

00:25:46,909 --> 00:25:52,369
I chose you with his fails it shows you

00:25:49,369 --> 00:25:54,049
why affairs put okay tails although you

00:25:52,369 --> 00:25:58,039
can tell you is that you can't boolean

00:25:54,049 --> 00:26:00,019
false okay so now for modular approach

00:25:58,039 --> 00:26:01,759
of testing we're going to create a

00:26:00,019 --> 00:26:03,590
module called package my module it's

00:26:01,759 --> 00:26:05,749
going to use exporter it's going to

00:26:03,590 --> 00:26:09,499
export a method call a function called

00:26:05,749 --> 00:26:12,950
add and add just returns but it's two

00:26:09,499 --> 00:26:14,529
parameters added together and now we're

00:26:12,950 --> 00:26:16,369
going to write tests for our module

00:26:14,529 --> 00:26:21,499
we're going to put them in a script

00:26:16,369 --> 00:26:27,409
called t / 00 biological team and we're

00:26:21,499 --> 00:26:29,389
going to use test for you use test more

00:26:27,409 --> 00:26:31,989
we're going to use something a test for

00:26:29,389 --> 00:26:39,349
four legs that's called to use okay

00:26:31,989 --> 00:26:44,179
we're going to use okay Gus that's right

00:26:39,349 --> 00:26:47,179
use okay essentially reps use modulate

00:26:44,179 --> 00:26:49,609
the pearl dirt director to use it

00:26:47,179 --> 00:26:52,669
absolutely not probably an eval right

00:26:49,609 --> 00:26:55,190
and if it fails then it produces useful

00:26:52,669 --> 00:26:57,229
out the tap parts that can find so just

00:26:55,190 --> 00:27:00,559
to see if the module boats and then the

00:26:57,229 --> 00:27:04,609
next thing we're testing can okay so can

00:27:00,559 --> 00:27:08,119
my module that is why much we have a

00:27:04,609 --> 00:27:10,549
sucker TV tab now one module is also as

00:27:08,119 --> 00:27:13,429
we as we saw before is an exporter and

00:27:10,549 --> 00:27:15,200
it exports the method at into the colors

00:27:13,429 --> 00:27:18,889
namespace so we're going to do another

00:27:15,200 --> 00:27:22,789
cam tests can maybe add in other words

00:27:18,889 --> 00:27:25,909
did the module export its function as we

00:27:22,789 --> 00:27:28,489
expected it to and if so now we give you

00:27:25,909 --> 00:27:31,120
okay at one cup of one equals two and

00:27:28,489 --> 00:27:33,460
our two positive integers being added to

00:27:31,120 --> 00:27:40,180
work and then we're done be right done

00:27:33,460 --> 00:27:43,059
testing we run that if we run it with

00:27:40,180 --> 00:27:45,520
perl python i live and in this test

00:27:43,059 --> 00:27:47,860
script name and i'll tell us okay well i

00:27:45,520 --> 00:27:51,430
use my module succeeded so here's our

00:27:47,860 --> 00:27:53,740
cake succeeded okay to my module campus

00:27:51,430 --> 00:27:55,630
okay three my module came at i guess i

00:27:53,740 --> 00:27:58,870
have a fourth test a 50 found this site

00:27:55,630 --> 00:28:01,030
thanks sorry about that anyway if we use

00:27:58,870 --> 00:28:02,980
proof we're going to tell a proof life

00:28:01,030 --> 00:28:04,960
and l and i'll explain what that means

00:28:02,980 --> 00:28:08,830
in a moment and then it will tell us

00:28:04,960 --> 00:28:12,850
that the tests in this particular test

00:28:08,830 --> 00:28:15,940
script my model that team all past also

00:28:12,850 --> 00:28:17,920
successful one foil rammed it had three

00:28:15,940 --> 00:28:19,809
tests in it it took a certain number

00:28:17,920 --> 00:28:22,090
Warhawk seconds and all of anything in

00:28:19,809 --> 00:28:27,520
the end we got a big pass at the end now

00:28:22,090 --> 00:28:35,220
Marik success anybody let the I flag

00:28:27,520 --> 00:28:35,220
goes on Pearl paper night yes

00:28:38,450 --> 00:28:46,840
okay that's correct so they see if I

00:28:41,420 --> 00:28:46,840
have I don't have man i can show you

00:28:56,370 --> 00:29:03,059
so in this example we are in the

00:29:00,600 --> 00:29:04,620
directory testing one which has no

00:29:03,059 --> 00:29:08,610
significance is a meeting or anything

00:29:04,620 --> 00:29:12,180
our module for testing that resides in

00:29:08,610 --> 00:29:16,530
live live / food and our tests reside in

00:29:12,180 --> 00:29:20,670
T and so if I were to run tests from

00:29:16,530 --> 00:29:23,580
this from this path i would say i could

00:29:20,670 --> 00:29:26,670
say girl dish i live and it will look

00:29:23,580 --> 00:29:31,230
for the module that i'm running in the

00:29:26,670 --> 00:29:34,050
lib directory that's always coming on

00:29:31,230 --> 00:29:36,630
the right side we have proved improved

00:29:34,050 --> 00:29:39,390
is using Python tell which does the same

00:29:36,630 --> 00:29:49,620
thing as I live it's just a shorthand

00:29:39,390 --> 00:29:52,290
for I read okay so ingesting that logic

00:29:49,620 --> 00:29:54,210
we used to use okay we used can okay and

00:29:52,290 --> 00:29:58,530
we use proof to run the entire test

00:29:54,210 --> 00:30:01,830
suite proof it turns out as more command

00:29:58,530 --> 00:30:04,200
line switches than just happen L it also

00:30:01,830 --> 00:30:06,720
has head compete which I find very

00:30:04,200 --> 00:30:09,660
useful that produces for both output

00:30:06,720 --> 00:30:11,880
when you use hyphen be it will show you

00:30:09,660 --> 00:30:14,190
the output every single Chester bigger

00:30:11,880 --> 00:30:17,340
chest script right now they could be

00:30:14,190 --> 00:30:21,390
proved only shows yes my gesture to pass

00:30:17,340 --> 00:30:23,640
or fail if there is a failure that it

00:30:21,390 --> 00:30:24,080
will still dumb test fail even if

00:30:23,640 --> 00:30:28,909
you

00:30:24,080 --> 00:30:31,399
I can be proof hyphen being is useful

00:30:28,909 --> 00:30:34,399
for cpap module authors because it sells

00:30:31,399 --> 00:30:35,960
girl to look in the be live directory

00:30:34,399 --> 00:30:38,360
which is created when you run made

00:30:35,960 --> 00:30:43,130
because you're developing your seatback

00:30:38,360 --> 00:30:44,570
module like al is common for people that

00:30:43,130 --> 00:30:47,149
are not developing for seed matter that

00:30:44,570 --> 00:30:49,880
aren't usually make it just does pro to

00:30:47,149 --> 00:30:52,490
look in the wig that falls within your

00:30:49,880 --> 00:30:56,269
current working directory and prune life

00:30:52,490 --> 00:30:59,630
and Q is used by tools such as secant

00:30:56,269 --> 00:31:02,299
minus to suppress all output except for

00:30:59,630 --> 00:31:10,630
failures and computed produce only

00:31:02,299 --> 00:31:15,399
summary output are there any questions

00:31:10,630 --> 00:31:15,399
so far yes

00:31:15,890 --> 00:31:24,720
device the finding of my vampire talk

00:31:20,640 --> 00:31:27,570
about after second time alright this is

00:31:24,720 --> 00:31:29,010
a module their constant with corporal so

00:31:27,570 --> 00:31:31,350
question is what this fine going to do

00:31:29,010 --> 00:31:33,419
this is a modular come to the Corporal

00:31:31,350 --> 00:31:38,299
ships with every version of girl unless

00:31:33,419 --> 00:31:42,179
it's broken version and fine may give me

00:31:38,299 --> 00:31:44,820
provides certain variables heads up that

00:31:42,179 --> 00:31:46,710
tell me where the actual mixes

00:31:44,820 --> 00:31:51,120
executable script that I'm running

00:31:46,710 --> 00:31:55,380
resides red lips and so if I happen to

00:31:51,120 --> 00:31:58,620
know if I libraries for a particular

00:31:55,380 --> 00:32:01,890
script run a live within the scripts

00:31:58,620 --> 00:32:05,070
working directory / where that I might

00:32:01,890 --> 00:32:08,039
tell pearl to go ahead and use the

00:32:05,070 --> 00:32:10,409
library that can be found where my bid

00:32:08,039 --> 00:32:14,159
is back and point and then move forward

00:32:10,409 --> 00:32:17,520
into it so assuming that i have this

00:32:14,159 --> 00:32:20,580
directory structure where reader lives

00:32:17,520 --> 00:32:24,590
in bin that i would cooperate and

00:32:20,580 --> 00:32:29,250
signing block counter the second reader

00:32:24,590 --> 00:32:32,039
lives within bin find bin tells girl

00:32:29,250 --> 00:32:34,650
that it should look at reader here back

00:32:32,039 --> 00:32:37,380
up one move forward and then we'll

00:32:34,650 --> 00:32:40,409
forward into the into the lib directory

00:32:37,380 --> 00:32:43,020
to find the library so let's look at

00:32:40,409 --> 00:32:47,549
that again five min is using a variable

00:32:43,020 --> 00:32:51,120
called five min ban that represents over

00:32:47,549 --> 00:32:55,650
here a bid directory finding game is

00:32:51,120 --> 00:32:57,809
where my script is looking and then the

00:32:55,650 --> 00:32:59,820
dog doesn't back up one directory and

00:32:57,809 --> 00:33:04,080
then the lib joseph move forward wanting

00:32:59,820 --> 00:33:07,260
to live so it's basically with I'm

00:33:04,080 --> 00:33:08,610
telling Burrell where to find the

00:33:07,260 --> 00:33:12,030
libraries

00:33:08,610 --> 00:33:13,650
it's running as long as I go relat relat

00:33:12,030 --> 00:33:15,240
it to where the script lives where the

00:33:13,650 --> 00:33:16,679
libraries are going to be I can go ahead

00:33:15,240 --> 00:33:18,720
and put that in there girl deliver a

00:33:16,679 --> 00:33:25,110
hard time finding the libraries the

00:33:18,720 --> 00:33:30,150
script relies upon so then we run the

00:33:25,110 --> 00:33:32,790
tests ok so the tools we used were use

00:33:30,150 --> 00:33:36,049
ok which was the module and seasonal

00:33:32,790 --> 00:33:40,559
module can load without fearing klk and

00:33:36,049 --> 00:33:43,290
prove he's okay it turns out to be more

00:33:40,559 --> 00:33:44,940
useful than it really ought to be in a

00:33:43,290 --> 00:33:47,880
perfect world I would never forget to

00:33:44,940 --> 00:33:50,490
run perl hyphen c to testify module

00:33:47,880 --> 00:33:51,990
compiles before running my tests but in

00:33:50,490 --> 00:33:54,210
the real world i forget to do it all the

00:33:51,990 --> 00:33:55,860
time or i forget to put the light at the

00:33:54,210 --> 00:33:57,540
end of my module to make the multi

00:33:55,860 --> 00:33:59,669
return a true value there's always

00:33:57,540 --> 00:34:02,040
something that I'm forgetting so if i

00:33:59,669 --> 00:34:04,530
put use okay my test script that I

00:34:02,040 --> 00:34:07,320
automatically immediately I'm able to

00:34:04,530 --> 00:34:09,300
determine that by modular 20 test fail

00:34:07,320 --> 00:34:11,280
to look this is syntax error in

00:34:09,300 --> 00:34:14,090
somewhere or a strict violation

00:34:11,280 --> 00:34:17,100
something and I'm able to the proof

00:34:14,090 --> 00:34:22,470
command line switches now look at sub

00:34:17,100 --> 00:34:26,550
chests so when I'm ready chest I try to

00:34:22,470 --> 00:34:28,919
be very simple in a way around my chest

00:34:26,550 --> 00:34:31,139
so I don't like to get too clever if i'm

00:34:28,919 --> 00:34:32,370
testing six different things i will

00:34:31,139 --> 00:34:34,260
write six

00:34:32,370 --> 00:34:36,960
the test look quite similar to each

00:34:34,260 --> 00:34:39,780
other I don't try to get too complicated

00:34:36,960 --> 00:34:41,700
out how to run things and loops I want

00:34:39,780 --> 00:34:45,870
my chest to be very easy to look at and

00:34:41,700 --> 00:34:47,700
reason about so one way to make your

00:34:45,870 --> 00:34:50,060
chest easier to look at a reason about

00:34:47,700 --> 00:34:54,570
is to subdivide rejest into smaller

00:34:50,060 --> 00:34:58,980
subjects and test for advices ability

00:34:54,570 --> 00:35:03,030
with a method called sub test subject

00:34:58,980 --> 00:35:06,120
the test name multiplication is a

00:35:03,030 --> 00:35:10,800
subroutine inside of that subroutine it

00:35:06,120 --> 00:35:12,390
has two actual tests the rain run and

00:35:10,800 --> 00:35:16,560
then when the subroutine is done with it

00:35:12,390 --> 00:35:17,760
stool tests it calls done testing and

00:35:16,560 --> 00:35:19,880
now here we are outside of our

00:35:17,760 --> 00:35:23,070
subroutine we have some additional tests

00:35:19,880 --> 00:35:25,500
up here before down here below when we

00:35:23,070 --> 00:35:29,400
run we run the test script the first

00:35:25,500 --> 00:35:33,270
test runs here's us okay line and then

00:35:29,400 --> 00:35:38,460
the second test runs which is the

00:35:33,270 --> 00:35:42,330
subtest and that gives us okay one okay

00:35:38,460 --> 00:35:45,120
to these two okays and then we get a

00:35:42,330 --> 00:35:47,130
summary here our subject multiplication

00:35:45,120 --> 00:35:49,890
was all okay everything that happened

00:35:47,130 --> 00:35:53,580
inside this subroutine was ok now we'll

00:35:49,890 --> 00:35:56,550
go on to our third test down here so the

00:35:53,580 --> 00:35:59,100
first one up here counts as one test the

00:35:56,550 --> 00:36:01,980
second subroutine meerkats as one test

00:35:59,100 --> 00:36:05,070
that has two subtests within it one and

00:36:01,980 --> 00:36:08,380
two and then this work has a circular

00:36:05,070 --> 00:36:11,440
chest so sometimes remind us of each

00:36:08,380 --> 00:36:14,019
bringing our chests damn it into smaller

00:36:11,440 --> 00:36:18,009
components the test individual then you

00:36:14,019 --> 00:36:23,289
get into functionality any questions on

00:36:18,009 --> 00:36:32,680
subjects yes the indentation correct yes

00:36:23,289 --> 00:36:35,859
yeah so actually it is I'm going to walk

00:36:32,680 --> 00:36:39,880
over again so this is this is the first

00:36:35,859 --> 00:36:43,539
test up here these two are so Chester

00:36:39,880 --> 00:36:47,529
but they but these will roll up to be

00:36:43,539 --> 00:36:53,009
one top level test so that's what happen

00:36:47,529 --> 00:36:53,009
is it is alt enter again something sense

00:36:55,710 --> 00:37:03,029
some other useful tools diag note and

00:37:00,160 --> 00:37:10,539
explain has anybody used any of these

00:37:03,029 --> 00:37:11,980
yeah so let's start with them think we

00:37:10,539 --> 00:37:16,359
shouldn't use my description is saying

00:37:11,980 --> 00:37:18,490
as diana will serve a dining ok diet

00:37:16,359 --> 00:37:22,779
prints a diagnostic message that won't

00:37:18,490 --> 00:37:26,440
interfere with tap out so it's a little

00:37:22,779 --> 00:37:29,349
bit difficult to print something within

00:37:26,440 --> 00:37:31,960
your test scripts it's going to be

00:37:29,349 --> 00:37:33,819
consumed by a parser because all of

00:37:31,960 --> 00:37:37,690
anything you get print anything you

00:37:33,819 --> 00:37:39,970
print gets the chat parser is going to

00:37:37,690 --> 00:37:42,339
try to consume that hair type arson if

00:37:39,970 --> 00:37:44,200
you don't want something to get first by

00:37:42,339 --> 00:37:48,910
the temper so they can proceed route

00:37:44,200 --> 00:37:51,690
with a pound sign using Dayak does that

00:37:48,910 --> 00:37:52,960
for you automatically so it brings a

00:37:51,690 --> 00:37:55,780
diagnostic

00:37:52,960 --> 00:37:58,420
it won't interfere with test output so

00:37:55,780 --> 00:38:02,140
the messages have a downside companion

00:37:58,420 --> 00:38:04,540
to them note is the same as diet that is

00:38:02,140 --> 00:38:10,150
only see if the tests are run with a

00:38:04,540 --> 00:38:13,060
dash B for verbose mode so you should

00:38:10,150 --> 00:38:15,640
probably tend to favor note if you need

00:38:13,060 --> 00:38:17,910
to make if you need your jest to spew

00:38:15,640 --> 00:38:20,290
some output of some sort favorite note

00:38:17,910 --> 00:38:22,839
unless there's some critical information

00:38:20,290 --> 00:38:25,480
you need to get out even if you're not

00:38:22,839 --> 00:38:27,040
in verbose mode and then he's dying for

00:38:25,480 --> 00:38:31,650
critical information that people ought

00:38:27,040 --> 00:38:34,359
to have drink even in non verbose mode

00:38:31,650 --> 00:38:38,520
explaining is wonderful explain is like

00:38:34,359 --> 00:38:41,589
putting a note around data number

00:38:38,520 --> 00:38:44,230
essentially so it will dump your data

00:38:41,589 --> 00:38:46,839
structure no matter how many levels of

00:38:44,230 --> 00:38:49,480
complexity that structure has that it

00:38:46,839 --> 00:38:51,430
will put all of the output following

00:38:49,480 --> 00:38:53,290
pound signs so it will interfere with

00:38:51,430 --> 00:38:54,940
your cabinet but I find out a

00:38:53,290 --> 00:38:57,070
tremendously useful because as soon as

00:38:54,940 --> 00:39:00,339
is deeply fails the next thing I lots of

00:38:57,070 --> 00:39:02,650
you is explained by God structure to

00:39:00,339 --> 00:39:10,060
find out why it failed and so I guess

00:39:02,650 --> 00:39:15,250
explain a lot so here's some examples if

00:39:10,060 --> 00:39:17,770
we call by a one plus one equals gamma 1

00:39:15,250 --> 00:39:21,250
plus 1 then that's going to break down

00:39:17,770 --> 00:39:22,960
side one plus one equals two but would

00:39:21,250 --> 00:39:27,599
note it's going to bring the same thing

00:39:22,960 --> 00:39:27,599
but only in not only in verbose mode

00:39:30,510 --> 00:39:35,190
any questions on those ones it's very

00:39:33,180 --> 00:39:36,810
useful for your test a kind of comments

00:39:35,190 --> 00:39:38,850
this few up in type of time they don't

00:39:36,810 --> 00:39:41,010
week to keep track of where I am in the

00:39:38,850 --> 00:39:43,020
runtime of the script or what things

00:39:41,010 --> 00:39:50,940
they have this setup or damage mr. it's

00:39:43,020 --> 00:39:53,670
all right okay skip if I have a test

00:39:50,940 --> 00:39:57,150
that should only be run on windows or

00:39:53,670 --> 00:40:01,140
should only be run on Linux that I might

00:39:57,150 --> 00:40:04,610
put a skip block and I can make my skip

00:40:01,140 --> 00:40:06,900
walk skipped in a condition is true and

00:40:04,610 --> 00:40:09,330
if the condition is true then the

00:40:06,900 --> 00:40:13,100
following two tests okay one okay two

00:40:09,330 --> 00:40:16,140
are going to just be skipped altogether

00:40:13,100 --> 00:40:18,330
so if you're on if this doesn't make any

00:40:16,140 --> 00:40:21,990
sense on bsd but it does make sense some

00:40:18,330 --> 00:40:25,860
new annex then you put in a condition to

00:40:21,990 --> 00:40:28,260
skip condition and the sea horses

00:40:25,860 --> 00:40:30,870
because they're that because will steal

00:40:28,260 --> 00:40:35,130
it will spew into the tap out put it

00:40:30,870 --> 00:40:37,110
will say skipping to test because we're

00:40:35,130 --> 00:40:39,690
going to be put in in place of the

00:40:37,110 --> 00:40:42,330
actual work because there that's like

00:40:39,690 --> 00:40:47,580
the insert your name in certificates

00:40:42,330 --> 00:40:49,710
they're jealous so I would say skip and

00:40:47,580 --> 00:40:52,260
then I put in there can't run these

00:40:49,710 --> 00:40:55,220
tests on Windows common three tests and

00:40:52,260 --> 00:40:58,350
then if the condition is that were

00:40:55,220 --> 00:41:00,330
running under windows ok when you turn

00:40:58,350 --> 00:41:03,060
the tap off book would say skipping to

00:41:00,330 --> 00:41:07,980
jazz skipping three just can't go into

00:41:03,060 --> 00:41:09,600
these tests on Venus let's skip box on

00:41:07,980 --> 00:41:13,080
the right day we can talk about to you

00:41:09,600 --> 00:41:14,910
for a second if i have if i want to

00:41:13,080 --> 00:41:17,160
write test for a feature that has yet

00:41:14,910 --> 00:41:19,440
been implemented then I'm a parking with

00:41:17,160 --> 00:41:21,810
it to deal and I would set the local

00:41:19,440 --> 00:41:25,770
variable to do equals 2 equal to some

00:41:21,810 --> 00:41:30,030
description of why why we can't run this

00:41:25,770 --> 00:41:32,340
and then a condition so if this

00:41:30,030 --> 00:41:34,650
particular conditions man you could just

00:41:32,340 --> 00:41:36,720
say if 1,000,000 ed if she'd if you can

00:41:34,650 --> 00:41:37,980
make it as global to do always because

00:41:36,720 --> 00:41:43,080
we know what this one's never going to

00:41:37,980 --> 00:41:45,600
pass currently in that case if the if

00:41:43,080 --> 00:41:49,320
the following tests in this block of

00:41:45,600 --> 00:41:51,690
code here pass then we get a failure

00:41:49,320 --> 00:41:53,610
because we were not expecting in the

00:41:51,690 --> 00:41:56,430
past we get a drink though this is

00:41:53,610 --> 00:41:58,800
morning these these testy when expecting

00:41:56,430 --> 00:42:01,410
two paths of the cast right so now

00:41:58,800 --> 00:42:04,080
becomes illegal those test events or

00:42:01,410 --> 00:42:05,700
unexpected and it gives us through gives

00:42:04,080 --> 00:42:08,310
us big yellow output and I screen

00:42:05,700 --> 00:42:10,680
telling us what a notion to pass that

00:42:08,310 --> 00:42:13,020
they give yes but it's also a great

00:42:10,680 --> 00:42:15,000
reminder for me is I'm running my chests

00:42:13,020 --> 00:42:17,260
oh there was that feature in

00:42:15,000 --> 00:42:19,000
let's go ahead and make that a little

00:42:17,260 --> 00:42:21,370
bit of free time and then make sure to

00:42:19,000 --> 00:42:22,930
take those out of to do status and run

00:42:21,370 --> 00:42:28,900
my tests and I've already tested in

00:42:22,930 --> 00:42:30,640
place so tests that are skipping wii u

00:42:28,900 --> 00:42:32,530
suggests that article a different

00:42:30,640 --> 00:42:35,440
environment or test it should only run

00:42:32,530 --> 00:42:38,470
for a particular user just there only

00:42:35,440 --> 00:42:40,210
related to releasing code tests that

00:42:38,470 --> 00:42:42,880
he'll be right if you haven't done we've

00:42:40,210 --> 00:42:44,350
got a database available to you or if

00:42:42,880 --> 00:42:48,280
you have if you have network

00:42:44,350 --> 00:42:50,500
connectivity to do is protest that fail

00:42:48,280 --> 00:42:52,960
that relating bug fixes or tests for

00:42:50,500 --> 00:42:54,910
code that isn't yet implemented or

00:42:52,960 --> 00:43:05,910
chester should arouse suspicion if they

00:42:54,910 --> 00:43:05,910
unexpectedly passed yes

00:43:05,980 --> 00:43:16,790
outside so yeah if you skip as a top

00:43:15,140 --> 00:43:20,300
level thing instead of inside of a block

00:43:16,790 --> 00:43:24,349
skip is skip has lexical scoping sorry

00:43:20,300 --> 00:43:26,180
scope to the lexical scoping from the

00:43:24,349 --> 00:43:28,130
point that it's used on word certainly

00:43:26,180 --> 00:43:30,560
becomes after that would be skipped

00:43:28,130 --> 00:43:34,730
automatically and in fact that is quite

00:43:30,560 --> 00:43:38,750
common in release tests or developer

00:43:34,730 --> 00:43:42,020
jests for Sipan modules as an example I

00:43:38,750 --> 00:43:45,320
might want to as a c10 developer write a

00:43:42,020 --> 00:43:47,540
test that verifies bipod my final

00:43:45,320 --> 00:43:49,820
documentation documents all of the

00:43:47,540 --> 00:43:51,590
functions in my module but I might not

00:43:49,820 --> 00:43:54,140
want that test to run on every single

00:43:51,590 --> 00:43:56,150
users system it's installing on module

00:43:54,140 --> 00:43:58,790
and so level said an environment

00:43:56,150 --> 00:44:02,450
variable release others protesting and

00:43:58,790 --> 00:44:05,630
then I will test if and release testing

00:44:02,450 --> 00:44:07,640
exists then we'll go ahead then we'll go

00:44:05,630 --> 00:44:10,520
ahead and run any but then we'll skip

00:44:07,640 --> 00:44:18,160
along and you'll go ahead skip on my

00:44:10,520 --> 00:44:20,900
chest at that point okay so in summary

00:44:18,160 --> 00:44:22,190
testing saves you a lot of time and

00:44:20,900 --> 00:44:26,089
that's something you might have to sell

00:44:22,190 --> 00:44:28,250
your managers but fortunately I work

00:44:26,089 --> 00:44:29,930
environment where they one hundred

00:44:28,250 --> 00:44:31,339
percent support testing and

00:44:29,930 --> 00:44:33,440
unfortunately don't know how two percent

00:44:31,339 --> 00:44:35,570
do it but it's very easy for me to tell

00:44:33,440 --> 00:44:37,160
my boss this is going to take me three

00:44:35,570 --> 00:44:38,630
days on one of those days

00:44:37,160 --> 00:44:40,700
writing test before you even get started

00:44:38,630 --> 00:44:43,280
and half the time is going to be spent

00:44:40,700 --> 00:44:45,230
writing tests as i'm writing to go and

00:44:43,280 --> 00:44:46,460
he's totally okay with that because he

00:44:45,230 --> 00:44:48,680
knows that he's not going to have to

00:44:46,460 --> 00:44:52,900
revisit my story again once i turn it in

00:44:48,680 --> 00:44:55,369
once i once i submitted my code if I

00:44:52,900 --> 00:44:57,559
hopefully if I club all the potential

00:44:55,369 --> 00:44:59,359
problems that it's because just going to

00:44:57,559 --> 00:45:01,789
work in there are he would take the time

00:44:59,359 --> 00:45:03,380
to read tests so if i take looking they

00:45:01,789 --> 00:45:06,049
say to sell someone that's protecting

00:45:03,380 --> 00:45:07,609
Esther data develop this that in the

00:45:06,049 --> 00:45:12,380
long run it's going to say for weeks and

00:45:07,609 --> 00:45:14,660
weeks of debugging tests are easier to

00:45:12,380 --> 00:45:16,880
read logic modular code small units of

00:45:14,660 --> 00:45:18,890
functionality as you saw just examples

00:45:16,880 --> 00:45:20,690
that we have here it's very easy to

00:45:18,890 --> 00:45:23,599
justice subroutine it's very hard to

00:45:20,690 --> 00:45:28,400
test a grand and integration a big giant

00:45:23,599 --> 00:45:32,630
thing big ball of yarn just every logic

00:45:28,400 --> 00:45:34,849
cap maybe possibly can just the small

00:45:32,630 --> 00:45:36,349
parts in the bigger parts that use the

00:45:34,849 --> 00:45:39,109
small parts so this is something that we

00:45:36,349 --> 00:45:41,119
do a lot is I'll write a lot of little

00:45:39,109 --> 00:45:43,369
little units of functionality ultimate

00:45:41,119 --> 00:45:45,770
test for all of us and I'm a runaway

00:45:43,369 --> 00:45:46,070
code that uses those little minutes of

00:45:45,770 --> 00:45:47,750
fun

00:45:46,070 --> 00:45:50,030
shall we all right test with a bigger

00:45:47,750 --> 00:45:52,160
part of the code i know that if i get a

00:45:50,030 --> 00:45:53,510
failure in Saudi the little things it's

00:45:52,160 --> 00:45:55,310
in the vague integration because I've

00:45:53,510 --> 00:45:57,260
already tested all the little things so

00:45:55,310 --> 00:45:59,300
kind of work your way up incrementally

00:45:57,260 --> 00:46:01,390
from the low level stuff up to the

00:45:59,300 --> 00:46:04,790
higher level stuff testing as you go

00:46:01,390 --> 00:46:06,650
test education cases test fence posts

00:46:04,790 --> 00:46:09,350
test every assumption that you're making

00:46:06,650 --> 00:46:12,290
as we might come we're constantly making

00:46:09,350 --> 00:46:14,390
assumptions aren't we I assume that as I

00:46:12,290 --> 00:46:16,040
got this to this I'm going to get the

00:46:14,390 --> 00:46:18,380
sum of those two things well just that

00:46:16,040 --> 00:46:20,630
assumption right right test for every

00:46:18,380 --> 00:46:23,240
assumption of you make just the edge

00:46:20,630 --> 00:46:26,000
cases the fence posts the outliers what

00:46:23,240 --> 00:46:27,410
happens if like having two managers of

00:46:26,000 --> 00:46:29,450
one of the images happens to be the

00:46:27,410 --> 00:46:32,780
maximum manager for the four-way

00:46:29,450 --> 00:46:34,250
platform just that sort of thing and of

00:46:32,780 --> 00:46:36,860
course test the normal things the

00:46:34,250 --> 00:46:39,830
expected they use under expected

00:46:36,860 --> 00:46:41,420
operating conditions so now in a less

00:46:39,830 --> 00:46:46,070
governments that we have let's find some

00:46:41,420 --> 00:46:48,380
bucks we have sup I CSV and this is the

00:46:46,070 --> 00:46:50,570
CSP Park sir and it's really smart but

00:46:48,380 --> 00:46:52,850
it splits on comments comma separated

00:46:50,570 --> 00:46:55,580
value person okay and we're going to

00:46:52,850 --> 00:46:58,580
write suggest for it we're going to test

00:46:55,580 --> 00:47:02,120
the can't force a how to become a Sea

00:46:58,580 --> 00:47:04,190
into three separate elements that's a

00:47:02,120 --> 00:47:07,990
simple list going to parse a single

00:47:04,190 --> 00:47:10,550
element into a single field get it horse

00:47:07,990 --> 00:47:13,130
strings n numbers together with a comma

00:47:10,550 --> 00:47:16,910
separated yes again here's the last one

00:47:13,130 --> 00:47:20,150
can enforce cloak quoted constructs

00:47:16,910 --> 00:47:23,420
correctly well let's see what happens we

00:47:20,150 --> 00:47:25,520
write and some are so good but then

00:47:23,420 --> 00:47:28,670
somebody comes in about report says he

00:47:25,520 --> 00:47:32,000
returns a number of fields rather than

00:47:28,670 --> 00:47:33,600
the fields themselves someone reports

00:47:32,000 --> 00:47:35,820
the close to fail to escape

00:47:33,600 --> 00:47:38,400
with it failed to escape embedded

00:47:35,820 --> 00:47:40,500
comments so that's those are two strange

00:47:38,400 --> 00:47:43,890
reports let's add some tests to see what

00:47:40,500 --> 00:47:45,600
those are all about so we have is scalar

00:47:43,890 --> 00:47:49,320
by CSV so we're going to put in saver

00:47:45,600 --> 00:47:52,920
context is an a and that is deeply John

00:47:49,320 --> 00:47:55,740
comma dough as a single field comics79

00:47:52,920 --> 00:47:58,470
does that barse out to be a single field

00:47:55,740 --> 00:48:00,870
John Doe and get set behind which is

00:47:58,470 --> 00:48:03,030
what we both did it would do we run the

00:48:00,870 --> 00:48:05,220
tests well sure enough that blubber boy

00:48:03,030 --> 00:48:06,930
is correct we got some settings here we

00:48:05,220 --> 00:48:09,900
got a failure to be expected a another

00:48:06,930 --> 00:48:12,990
one and we got a failure here that we

00:48:09,900 --> 00:48:18,300
expected don't wanna comments that you

00:48:12,990 --> 00:48:20,220
stuck there so whenever I get a bug

00:48:18,300 --> 00:48:23,040
report from somebody I like to write

00:48:20,220 --> 00:48:25,020
tests around that report it worked when

00:48:23,040 --> 00:48:26,760
somebody tells me such as I've stopped

00:48:25,020 --> 00:48:29,340
working the first thing I think is

00:48:26,760 --> 00:48:34,350
helping to write a test two I sorry that

00:48:29,340 --> 00:48:36,120
that explanation that they gave me so

00:48:34,350 --> 00:48:38,040
here's a nice bug report we discovered

00:48:36,120 --> 00:48:40,650
such and such the second problem is that

00:48:38,040 --> 00:48:44,880
attached is a set of tests who's ever

00:48:40,650 --> 00:48:46,860
got the bug report to includes tests and

00:48:44,880 --> 00:48:50,820
you have perfect you live in a great

00:48:46,860 --> 00:48:52,800
world usually the bug report is supports

00:48:50,820 --> 00:48:56,190
it that when they got a customer that

00:48:52,800 --> 00:48:57,420
did such and such everything blew up and

00:48:56,190 --> 00:48:59,940
they give you some more digging

00:48:57,420 --> 00:49:02,340
investigating if you're committing a bug

00:48:59,940 --> 00:49:02,990
report for cpap module try to mix and

00:49:02,340 --> 00:49:04,400
Genesis

00:49:02,990 --> 00:49:07,460
opportunity a little fun writing

00:49:04,400 --> 00:49:09,070
suggests try to prove the assertion

00:49:07,460 --> 00:49:11,240
think you're making that there is above

00:49:09,070 --> 00:49:13,430
and even better if you're attached will

00:49:11,240 --> 00:49:15,260
catch the faces of you has ever gotten

00:49:13,430 --> 00:49:19,100
attached they've got a couple would

00:49:15,260 --> 00:49:21,230
nominate in fact tastic in this case if

00:49:19,100 --> 00:49:26,360
the patches is text CSV rather than

00:49:21,230 --> 00:49:30,320
throwing your own CSV ok so summer in

00:49:26,360 --> 00:49:33,340
the tools test for is a tap producing

00:49:30,320 --> 00:49:35,990
framework c10 has hundreds of other

00:49:33,340 --> 00:49:38,720
testing tools available that work with

00:49:35,990 --> 00:49:42,580
test more I like to explore see content

00:49:38,720 --> 00:49:45,410
distributions prove words all your tests

00:49:42,580 --> 00:49:47,780
let's see been explored the test

00:49:45,410 --> 00:49:50,060
namespace just pullin column a space

00:49:47,780 --> 00:49:52,610
you'll find things like just exception

00:49:50,060 --> 00:49:56,150
just warnings chest forward which just

00:49:52,610 --> 00:49:58,369
to seeing all your exes common technique

00:49:56,150 --> 00:50:00,980
which is another way of doing recursive

00:49:58,369 --> 00:50:02,450
data structure testing the less you pull

00:50:00,980 --> 00:50:05,510
up what what's of the f of the data

00:50:02,450 --> 00:50:07,760
structure test them and finalists we

00:50:05,510 --> 00:50:10,550
give us some resources again interview

00:50:07,760 --> 00:50:15,770
her alarm girl protesting and developers

00:50:10,550 --> 00:50:19,000
notebook the documentation for prove all

00:50:15,770 --> 00:50:19,000
this that's why

00:50:23,900 --> 00:50:25,960

YouTube URL: https://www.youtube.com/watch?v=JYGH6I6B6TM


