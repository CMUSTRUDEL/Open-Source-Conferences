Title: 2016 - Hashing a Tree: Glacier hashes, FP, and Perlâ€Ž - Steve Lembark
Publication date: 2016-06-27
Playlist: YAPC::NA 2016
Description: 
	
Captions: 
	00:00:01,770 --> 00:00:09,590
how many people will check how many

00:00:06,939 --> 00:00:12,280
people here

00:00:09,590 --> 00:00:14,910
pleasure

00:00:12,280 --> 00:00:14,910
services

00:00:26,210 --> 00:00:29,210
sunday

00:00:31,770 --> 00:00:36,050
this will be fun to show you how to do

00:00:33,750 --> 00:00:36,050
some things

00:00:38,140 --> 00:00:43,600
so in the beginning to a spaghetti code

00:00:40,210 --> 00:00:45,970
can we also for traffic go to

00:00:43,600 --> 00:00:50,590
disassembly that jumps back on itself

00:00:45,970 --> 00:00:54,280
and we've all had to deal with this

00:00:50,590 --> 00:00:56,410
stuff and it's a mess nobody likes so we

00:00:54,280 --> 00:00:58,420
did it objects that objects were

00:00:56,410 --> 00:01:02,710
supposed to solve all our problems they

00:00:58,420 --> 00:01:04,839
were good capsulation we had classes noa

00:01:02,710 --> 00:01:07,300
spaghetti objects there's something in

00:01:04,839 --> 00:01:09,280
you you know this extends these five

00:01:07,300 --> 00:01:13,060
classes and there's that's the entire

00:01:09,280 --> 00:01:15,399
documentation pearl excess and

00:01:13,060 --> 00:01:18,070
make it more than once we do not jump

00:01:15,399 --> 00:01:20,950
out with it all it tells you is this

00:01:18,070 --> 00:01:22,509
extends the axon okay great now I'm

00:01:20,950 --> 00:01:25,240
going to require fire each one of those

00:01:22,509 --> 00:01:27,429
to spend something the cancellation was

00:01:25,240 --> 00:01:29,350
supposed to make the day is saved and

00:01:27,429 --> 00:01:32,560
now you try to go into the encapsulated

00:01:29,350 --> 00:01:34,030
part of life and what do you find you

00:01:32,560 --> 00:01:35,979
don't know why this is something else

00:01:34,030 --> 00:01:39,690
calls something called something you've

00:01:35,979 --> 00:01:39,690
got 85 levels of self

00:01:59,920 --> 00:02:07,130
what I'm supposed to walk around with

00:02:01,790 --> 00:02:09,380
that yes please Oh God um am I now way

00:02:07,130 --> 00:02:14,420
too loud for everybody okay we're going

00:02:09,380 --> 00:02:17,000
to try one quick experiment here are you

00:02:14,420 --> 00:02:19,160
recording me back there perfect so it

00:02:17,000 --> 00:02:23,720
sits here I will do my best not to kill

00:02:19,160 --> 00:02:26,350
myself on the blank cable the basic idea

00:02:23,720 --> 00:02:28,520
in functional programming was if we have

00:02:26,350 --> 00:02:30,739
transparency instead of encapsulation

00:02:28,520 --> 00:02:33,320
let's expose everything let's make it so

00:02:30,739 --> 00:02:35,630
that you see what's going on that you

00:02:33,320 --> 00:02:38,900
can really understand it let's make also

00:02:35,630 --> 00:02:41,690
sure that the data is consistent to do

00:02:38,900 --> 00:02:43,459
that and a basic thing that really

00:02:41,690 --> 00:02:46,280
confuses people the first time they use

00:02:43,459 --> 00:02:49,910
FB it still trans minutes is all the

00:02:46,280 --> 00:02:52,310
data is constant so you establish

00:02:49,910 --> 00:02:55,450
something you don't modify things you

00:02:52,310 --> 00:02:55,450
make copies in return

00:03:00,750 --> 00:03:06,400
it's it's less overhead that you think

00:03:03,579 --> 00:03:08,319
but the constant data most of the time

00:03:06,400 --> 00:03:10,030
most of us fright things because you

00:03:08,319 --> 00:03:14,019
modify an object in a way you didn't

00:03:10,030 --> 00:03:17,230
expect transparent transforms for

00:03:14,019 --> 00:03:19,689
another one and the idea there is that

00:03:17,230 --> 00:03:21,519
instead of encapsulating everything and

00:03:19,689 --> 00:03:23,260
making it invisible to people let me

00:03:21,519 --> 00:03:25,680
show you what's going on you should be

00:03:23,260 --> 00:03:28,090
able to see what's happening and that

00:03:25,680 --> 00:03:29,500
makes it easier to test things is you've

00:03:28,090 --> 00:03:32,099
got an idea what you've done yourself

00:03:29,500 --> 00:03:34,659
but also reorganizes the code of it a

00:03:32,099 --> 00:03:37,359
lot of times you'll find that you make a

00:03:34,659 --> 00:03:41,799
call to a method and you provide no

00:03:37,359 --> 00:03:43,750
arguments to it and in objects that make

00:03:41,799 --> 00:03:45,220
sense because the objects encapsulate

00:03:43,750 --> 00:03:47,019
what's going to happen inside the method

00:03:45,220 --> 00:03:50,170
the problem is to make the call you've

00:03:47,019 --> 00:03:51,939
got really no idea what portion of the

00:03:50,170 --> 00:03:54,099
data inside of the object is going to be

00:03:51,939 --> 00:03:55,870
used inside the function it makes it

00:03:54,099 --> 00:03:57,370
really even if you can if you look

00:03:55,870 --> 00:04:00,609
inside the object you don't really know

00:03:57,370 --> 00:04:04,030
what's going to happen one thing that

00:04:00,609 --> 00:04:07,209
that a lot of times you'll see in in oh

00:04:04,030 --> 00:04:10,720
land and in any kind of spaghetti you

00:04:07,209 --> 00:04:12,910
get side effects you get you put

00:04:10,720 --> 00:04:15,489
something in and the object itself

00:04:12,910 --> 00:04:18,940
doesn't fully define what's going to

00:04:15,489 --> 00:04:20,199
happen inside there so you get something

00:04:18,940 --> 00:04:22,150
and you test it and you've got the

00:04:20,199 --> 00:04:24,070
object you have a mock object you've

00:04:22,150 --> 00:04:25,659
created you run the test you run the

00:04:24,070 --> 00:04:28,960
test three times we need three different

00:04:25,659 --> 00:04:33,300
ones that makes it really hard to test

00:04:28,960 --> 00:04:35,560
things so avoiding internal state

00:04:33,300 --> 00:04:38,860
basically says that if I look in a

00:04:35,560 --> 00:04:41,500
function what I give the function as its

00:04:38,860 --> 00:04:44,080
argument should completely define what

00:04:41,500 --> 00:04:49,750
comes out which is a big big help in

00:04:44,080 --> 00:04:51,669
testing so it doesn't work the the grain

00:04:49,750 --> 00:04:54,039
of salt here is if I write a time

00:04:51,669 --> 00:04:56,320
function and it returns the same value

00:04:54,039 --> 00:04:58,810
it isn't a very good time function

00:04:56,320 --> 00:05:01,419
random is a great example if i give you

00:04:58,810 --> 00:05:03,940
red line and it returns the same line

00:05:01,419 --> 00:05:04,830
every time you read you're probably not

00:05:03,940 --> 00:05:08,160
getting very good in

00:05:04,830 --> 00:05:10,410
what databases I probably don't want to

00:05:08,160 --> 00:05:14,220
return exactly the same data for every

00:05:10,410 --> 00:05:15,840
time I run a query so those things are

00:05:14,220 --> 00:05:16,830
very hard to do in functional

00:05:15,840 --> 00:05:19,770
programming one of the great things

00:05:16,830 --> 00:05:23,130
about pearl is you can mix the

00:05:19,770 --> 00:05:25,080
functional with the imperative so I can

00:05:23,130 --> 00:05:27,270
have things that are objects that are

00:05:25,080 --> 00:05:29,820
dbi is that deal with my fetching and

00:05:27,270 --> 00:05:31,470
have internal state and maintain side

00:05:29,820 --> 00:05:33,990
effects and encapsulate all the side

00:05:31,470 --> 00:05:35,580
effects of the database and I have to

00:05:33,990 --> 00:05:37,680
bang my head against it but I can go

00:05:35,580 --> 00:05:41,580
back to a functional approach where it

00:05:37,680 --> 00:05:44,670
makes sense one place it does work now

00:05:41,580 --> 00:05:47,670
the glacier service charges a penny per

00:05:44,670 --> 00:05:49,980
gigabyte per month for storage it is for

00:05:47,670 --> 00:05:52,890
cold storage of data you hope never to

00:05:49,980 --> 00:05:54,870
touch again old tax records back up so

00:05:52,890 --> 00:05:57,840
DNA sequences all the photographs you

00:05:54,870 --> 00:06:00,630
took your family whatever at ten bucks

00:05:57,840 --> 00:06:03,210
per terabyte with discount strata bites

00:06:00,630 --> 00:06:09,270
and petabytes and I mean numbers none of

00:06:03,210 --> 00:06:10,830
us knew it the it's cheap one of the

00:06:09,270 --> 00:06:12,540
interesting things they have those if

00:06:10,830 --> 00:06:14,820
you're uploading that much dative

00:06:12,540 --> 00:06:16,860
frequently you have to chunk it you do a

00:06:14,820 --> 00:06:18,810
parallel upload in you're not going to

00:06:16,860 --> 00:06:19,920
upload a terabyte and find it failing

00:06:18,810 --> 00:06:22,560
app you know at point nine nine

00:06:19,920 --> 00:06:24,900
terabytes and have to start over so they

00:06:22,560 --> 00:06:29,190
have a parallel low technique where you

00:06:24,900 --> 00:06:33,720
chunk the data into units of powers of

00:06:29,190 --> 00:06:36,240
two megabytes 248 16 Meg what they

00:06:33,720 --> 00:06:40,320
wanted was weighted digested to check

00:06:36,240 --> 00:06:42,840
some the data coming up so that you use

00:06:40,320 --> 00:06:45,270
the same algorithm no matter how you

00:06:42,840 --> 00:06:48,600
chunk it whether it's one big file or

00:06:45,270 --> 00:06:53,199
five thousand small chunks they give up

00:06:48,600 --> 00:06:56,540
this thing called a tree dash so

00:06:53,199 --> 00:06:59,780
yew tree hash things in units of one

00:06:56,540 --> 00:07:02,180
megabyte you compute an essence a 256 of

00:06:59,780 --> 00:07:04,669
each Meg of data and then you take the

00:07:02,180 --> 00:07:06,199
pairs of true of hashes and you hash

00:07:04,669 --> 00:07:09,820
them and you have the pairs of pairs of

00:07:06,199 --> 00:07:12,979
pairs until you get one data at the top

00:07:09,820 --> 00:07:15,410
so that one digest goes up the great

00:07:12,979 --> 00:07:18,169
thing about this is for every say eight

00:07:15,410 --> 00:07:21,500
Meg of upload I've got one partial tree

00:07:18,169 --> 00:07:23,990
hash that I can send up they compute it

00:07:21,500 --> 00:07:28,010
based on their megabytes they can verify

00:07:23,990 --> 00:07:30,289
each one of the the sha s and they can

00:07:28,010 --> 00:07:32,330
verify the total one same algorithm

00:07:30,289 --> 00:07:36,169
there's no extra data that has to get

00:07:32,330 --> 00:07:38,780
sent to them so this is an example from

00:07:36,169 --> 00:07:41,120
from their website now notice on the

00:07:38,780 --> 00:07:43,280
right hand side there you all we you

00:07:41,120 --> 00:07:45,830
know data isn't always a multiple at one

00:07:43,280 --> 00:07:48,889
megabyte or power to so what you're

00:07:45,830 --> 00:07:52,280
usually going to get is a bunch of one

00:07:48,889 --> 00:07:55,850
make units and then one runt chunk at

00:07:52,280 --> 00:07:57,979
the end the important thing about this

00:07:55,850 --> 00:07:59,450
to notice is that you do the pair's you

00:07:57,979 --> 00:08:01,580
do all the pair's it's not like a

00:07:59,450 --> 00:08:04,190
reduced where you do one of them and do

00:08:01,580 --> 00:08:06,370
the one with the next you do all of the

00:08:04,190 --> 00:08:09,320
pairs and then you go to all the pears

00:08:06,370 --> 00:08:12,500
notice that sha on the end doesn't get

00:08:09,320 --> 00:08:16,130
used until the the second iteration

00:08:12,500 --> 00:08:20,479
through when there's now an uneven

00:08:16,130 --> 00:08:22,580
number of units to pair up with so you

00:08:20,479 --> 00:08:27,110
have to you have to notice whether what

00:08:22,580 --> 00:08:29,270
you're doing lines up properly so this

00:08:27,110 --> 00:08:32,240
is the current net amazon tree hash

00:08:29,270 --> 00:08:34,550
module for computing us does anyone want

00:08:32,240 --> 00:08:39,650
to tell me what that does in less than

00:08:34,550 --> 00:08:40,880
10 minutes probably not it this is one

00:08:39,650 --> 00:08:42,740
of those cases where functional

00:08:40,880 --> 00:08:46,160
programming probably makes sense trees

00:08:42,740 --> 00:08:49,310
or recursive most of what you see in

00:08:46,160 --> 00:08:51,020
there is side effects and trying to keep

00:08:49,310 --> 00:08:53,200
track of what you've done the last

00:08:51,020 --> 00:08:56,150
iteration so you can add it through

00:08:53,200 --> 00:08:58,970
trees if I recurse on this I could

00:08:56,150 --> 00:09:02,240
probably use the stack for all of it

00:08:58,970 --> 00:09:06,500
so let's take a two step solution to

00:09:02,240 --> 00:09:09,290
this if I start by breaking my input

00:09:06,500 --> 00:09:13,209
into one mate chunks I can then reduce

00:09:09,290 --> 00:09:15,470
the SHA s and call myself each time and

00:09:13,209 --> 00:09:17,240
probably have less code because i'm not

00:09:15,470 --> 00:09:19,519
keeping track of all the district and I

00:09:17,240 --> 00:09:21,339
could use the recursion to do that so

00:09:19,519 --> 00:09:24,889
you end up with something like this and

00:09:21,339 --> 00:09:27,350
what this does is it reduce reduces all

00:09:24,889 --> 00:09:35,089
the pair's again this is different than

00:09:27,350 --> 00:09:36,620
the normal reduce in list utils because

00:09:35,089 --> 00:09:38,750
i'm not taking one of them and combining

00:09:36,620 --> 00:09:41,389
on the stack i do all of the pairs that

00:09:38,750 --> 00:09:43,189
are on the stack then i do all of the

00:09:41,389 --> 00:09:45,829
pairs appears so you have to recycle the

00:09:43,189 --> 00:09:49,660
stack each done what happens here if you

00:09:45,829 --> 00:09:52,790
look at it if there's one item I've done

00:09:49,660 --> 00:09:55,160
if otherwise I know how many things I've

00:09:52,790 --> 00:09:57,199
got to do is the number of pairs plus

00:09:55,160 --> 00:10:02,089
that possible odd number on the end that

00:09:57,199 --> 00:10:06,649
runt and I call reduce hash I take a map

00:10:02,089 --> 00:10:09,350
of if there's more than one item on the

00:10:06,649 --> 00:10:11,420
stack then I can do a pair of them

00:10:09,350 --> 00:10:13,279
otherwise I have to pass that item up

00:10:11,420 --> 00:10:16,850
the stack and reuse it until there's

00:10:13,279 --> 00:10:20,420
appeared to match it with and this works

00:10:16,850 --> 00:10:23,269
fine it does produce the right value but

00:10:20,420 --> 00:10:26,809
it doesn't work because it eats snack if

00:10:23,269 --> 00:10:30,800
I have several terabytes of data I might

00:10:26,809 --> 00:10:32,569
have a quarter million of these if I do

00:10:30,800 --> 00:10:37,790
a hundred and twenty eight thousand

00:10:32,569 --> 00:10:40,910
iterations of this you can't most of us

00:10:37,790 --> 00:10:43,850
don't have that much mariana regime so

00:10:40,910 --> 00:10:47,640
there's a better way now tail recursion

00:10:43,850 --> 00:10:49,830
or eliminating it our homework

00:10:47,640 --> 00:10:51,990
functional language of use skyla closure

00:10:49,830 --> 00:10:55,080
they all proba we've done this

00:10:51,990 --> 00:10:57,720
automatically and the trick is to take

00:10:55,080 --> 00:11:00,230
something like a fold which is a

00:10:57,720 --> 00:11:02,790
standard feature it's a scalable

00:11:00,230 --> 00:11:05,220
normally the idea is you take the left

00:11:02,790 --> 00:11:07,410
item the first item off the stack do

00:11:05,220 --> 00:11:09,510
something to it and if you call yourself

00:11:07,410 --> 00:11:11,790
with that first item in the remainder of

00:11:09,510 --> 00:11:13,980
the stack it magically recycles the

00:11:11,790 --> 00:11:16,170
stack so you don't create a new stack

00:11:13,980 --> 00:11:20,220
each time your recycling things and

00:11:16,170 --> 00:11:23,790
stacked shrinks so the trick is how do

00:11:20,220 --> 00:11:27,990
we do that in 405 and it turns out it's

00:11:23,790 --> 00:11:31,890
trivial assigned add underscoring bingo

00:11:27,990 --> 00:11:34,200
I've just recycled the stack the other

00:11:31,890 --> 00:11:37,410
thing is and this is from 516 has ever

00:11:34,200 --> 00:11:38,960
made it see the sub I don't the like

00:11:37,410 --> 00:11:42,570
package there's double underscore sup

00:11:38,960 --> 00:11:44,310
this is a neat thing because you'll

00:11:42,570 --> 00:11:46,890
notice this is that I'd only did it this

00:11:44,310 --> 00:11:51,180
way this one time to show it this is my

00:11:46,890 --> 00:11:55,200
dollar food I can now trivia leery curse

00:11:51,180 --> 00:11:57,690
on a lexical subroutine because sub is

00:11:55,200 --> 00:12:01,140
defined when it begins to define that

00:11:57,690 --> 00:12:03,750
entry point now infernal five it is

00:12:01,140 --> 00:12:05,610
trivial to write recursive routines

00:12:03,750 --> 00:12:07,920
without having to play games with

00:12:05,610 --> 00:12:11,310
parenthesis and ampersand in the rest of

00:12:07,920 --> 00:12:13,860
it so the real trick is here and this is

00:12:11,310 --> 00:12:17,700
just a general pattern if I a sign to

00:12:13,860 --> 00:12:22,590
add underscore and go to sub I recycled

00:12:17,700 --> 00:12:26,040
like stack the stack shrinks so now I

00:12:22,590 --> 00:12:27,660
can do this to reduce my hatch this

00:12:26,040 --> 00:12:29,900
one's just about the same as the last

00:12:27,660 --> 00:12:32,520
one except for the go to sub Athiya I

00:12:29,900 --> 00:12:34,560
assign add underscore and go back

00:12:32,520 --> 00:12:36,990
eventually I'm going to hit the point

00:12:34,560 --> 00:12:39,330
where adders underscore is greater than

00:12:36,990 --> 00:12:41,610
one anymore and by the way yes this

00:12:39,330 --> 00:12:44,820
intentionally does return and undef if

00:12:41,610 --> 00:12:46,040
you give it a single item so i compute

00:12:44,820 --> 00:12:50,360
the count

00:12:46,040 --> 00:12:52,459
map it I'm done the splice takes care of

00:12:50,360 --> 00:12:54,230
the fact that you know shrinks the stack

00:12:52,459 --> 00:12:59,870
if there's an odd number on the sack I'm

00:12:54,230 --> 00:13:02,389
finished the problem here is assigning

00:12:59,870 --> 00:13:06,259
to add underscore it makes most people's

00:13:02,389 --> 00:13:07,519
skin crawl go to is oh my god it's evil

00:13:06,259 --> 00:13:09,500
literally no that's what caused all the

00:13:07,519 --> 00:13:12,649
spaghetti in the first place right what

00:13:09,500 --> 00:13:14,540
we'd like to do is not have that show so

00:13:12,649 --> 00:13:19,579
the trick here is keyword declare is

00:13:14,540 --> 00:13:21,949
anyone use that before the it allows you

00:13:19,579 --> 00:13:24,829
to write in line compilers it's a type

00:13:21,949 --> 00:13:28,699
of source filter so this is the example

00:13:24,829 --> 00:13:30,440
of a tree fold I left and a rightful

00:13:28,699 --> 00:13:32,269
take things off either end of the stack

00:13:30,440 --> 00:13:35,120
at refold processes the whole stack of

00:13:32,269 --> 00:13:38,509
and recycles on itself which is what I

00:13:35,120 --> 00:13:40,730
have to do for this tree cash so if this

00:13:38,509 --> 00:13:42,560
is going to do here I'm going to find

00:13:40,730 --> 00:13:47,990
this tree fold keyword it takes a name

00:13:42,560 --> 00:13:49,970
and a block notice that this is

00:13:47,990 --> 00:13:52,130
generating source code it's not that I'm

00:13:49,970 --> 00:13:54,290
feeding back a subroutine reference this

00:13:52,130 --> 00:13:56,600
is in the closure this is actual pearl

00:13:54,290 --> 00:14:00,170
source code that I'm feeding back so I

00:13:56,600 --> 00:14:02,420
have the subroutine with a name you

00:14:00,170 --> 00:14:04,490
notice I have two backslash the ad

00:14:02,420 --> 00:14:07,730
underscores so that it's treated as text

00:14:04,490 --> 00:14:12,190
it's not expanded in line but if the end

00:14:07,730 --> 00:14:16,130
of course I set a dunder score to do

00:14:12,190 --> 00:14:18,470
whatever my new list generator is how

00:14:16,130 --> 00:14:23,089
that I go to the sub this is perfectly

00:14:18,470 --> 00:14:27,889
generic if I use this I now can take my

00:14:23,089 --> 00:14:30,310
tree fold and I replace all of the old

00:14:27,889 --> 00:14:32,930
boiler plate with something that simply

00:14:30,310 --> 00:14:35,600
generates a map of what has to be

00:14:32,930 --> 00:14:37,699
reassigned to add underscore although

00:14:35,600 --> 00:14:39,529
the logic for exiting all over

00:14:37,699 --> 00:14:43,250
reassigned the actual assignment to add

00:14:39,529 --> 00:14:47,689
underscore goes away so this block here

00:14:43,250 --> 00:14:48,480
is what went into the tree fold as as

00:14:47,689 --> 00:14:51,029
the

00:14:48,480 --> 00:14:53,880
the list operator the block of code so

00:14:51,029 --> 00:14:57,750
if you look here you see the new list

00:14:53,880 --> 00:15:02,579
operator is the braces after reduce

00:14:57,750 --> 00:15:04,350
action so now I don't have to there's

00:15:02,579 --> 00:15:05,610
nothing in here where I have to show

00:15:04,350 --> 00:15:08,130
someone that I'm assigned you to add

00:15:05,610 --> 00:15:09,959
underscore I don't have to show you that

00:15:08,130 --> 00:15:16,350
I'm going to sub it just became black

00:15:09,959 --> 00:15:18,540
magic but this isn't quite functional

00:15:16,350 --> 00:15:21,269
code just remember i said earlier on you

00:15:18,540 --> 00:15:25,860
want to have static data I can't modify

00:15:21,269 --> 00:15:29,190
it hacking the stack is not functional

00:15:25,860 --> 00:15:31,230
programming so it's fine but it isn't

00:15:29,190 --> 00:15:36,980
really hard to do I can take a last

00:15:31,230 --> 00:15:39,870
index and I just you know subtract one

00:15:36,980 --> 00:15:42,440
map it into a set of offsets and if

00:15:39,870 --> 00:15:45,360
there is something there on the stack

00:15:42,440 --> 00:15:49,339
sha two of them if there's nothing to

00:15:45,360 --> 00:15:49,339
out on the stack pass it up

00:15:50,910 --> 00:15:55,200
same tree full the assignment at

00:15:53,460 --> 00:16:01,380
underscore the go-to sub is dealt with

00:15:55,200 --> 00:16:03,900
for me by the keyword but I still have

00:16:01,380 --> 00:16:05,760
all of this add underscore I'm still

00:16:03,900 --> 00:16:08,130
defining the stack map to find the

00:16:05,760 --> 00:16:12,060
offsets anyone that does a tree fold is

00:16:08,130 --> 00:16:13,620
going to do roughly the same thing so

00:16:12,060 --> 00:16:15,750
what if I take some arguments what

00:16:13,620 --> 00:16:17,880
instead of having an underscore and that

00:16:15,750 --> 00:16:20,030
dollar underscore one and the rest of it

00:16:17,880 --> 00:16:22,410
you just define some lexical variables

00:16:20,030 --> 00:16:23,910
you could use your variables and then I

00:16:22,410 --> 00:16:29,370
know how much to take off the stack so

00:16:23,910 --> 00:16:32,310
what we've got here the ppi is people

00:16:29,370 --> 00:16:35,700
seen that before only well yeah you've

00:16:32,310 --> 00:16:39,270
seen everything the the basic rule is

00:16:35,700 --> 00:16:41,640
that only pearl can parse pearl so this

00:16:39,270 --> 00:16:44,940
is a pearl parser that actually turns a

00:16:41,640 --> 00:16:49,200
pearl execute the perl source into a

00:16:44,940 --> 00:16:50,730
fully broken down sourcetree this mess

00:16:49,200 --> 00:16:52,530
which no one's going to try and memorize

00:16:50,730 --> 00:16:54,870
basically if you look at the very top

00:16:52,530 --> 00:16:58,470
there's a comment this returns me a

00:16:54,870 --> 00:17:02,310
quoted list of variable names from your

00:16:58,470 --> 00:17:06,330
arguments but if I know how many

00:17:02,310 --> 00:17:09,390
arguments I can count them I can tell

00:17:06,330 --> 00:17:11,520
what the right offset is to be able to

00:17:09,390 --> 00:17:14,430
chop that many off the snack well now I

00:17:11,520 --> 00:17:17,070
can go through I can go in and generate

00:17:14,430 --> 00:17:20,820
a subroutine the same editor score

00:17:17,070 --> 00:17:25,740
either one I can look I can generate a

00:17:20,820 --> 00:17:29,480
last the cute thing is I can interpolate

00:17:25,740 --> 00:17:34,830
those lexical 'he's into the source code

00:17:29,480 --> 00:17:37,710
so we're dollar lexical is that is the

00:17:34,830 --> 00:17:40,260
foo and bar that I extracted as text

00:17:37,710 --> 00:17:43,650
from your argument list so i can take

00:17:40,260 --> 00:17:46,690
dollars where the stack up is all you

00:17:43,650 --> 00:17:49,919
have to pass me i'm doing all the rest

00:17:46,690 --> 00:17:54,610
so what's left of your snack operation

00:17:49,919 --> 00:17:57,250
let's see this will compute that same

00:17:54,610 --> 00:18:00,190
glacier has we saw at the beginning with

00:17:57,250 --> 00:18:02,980
all of the expansion all of the insanity

00:18:00,190 --> 00:18:07,870
all the side effects that whole page of

00:18:02,980 --> 00:18:10,690
code is now this and I would challenge

00:18:07,870 --> 00:18:13,360
even Damian Conway to come up with a

00:18:10,690 --> 00:18:15,519
better solution that is shorter or

00:18:13,360 --> 00:18:23,070
cleaner or more declarative than this

00:18:15,519 --> 00:18:30,509
one I said your job then do it I chef

00:18:23,070 --> 00:18:39,960
just hacked into his in here if i can

00:18:30,509 --> 00:18:43,059
get this right okay here it is in perl 6

00:18:39,960 --> 00:18:45,309
because you want to say it in perl 6 so

00:18:43,059 --> 00:18:49,480
in perl 6 this is by the way the entire

00:18:45,309 --> 00:18:52,450
code for the entire tree hash algorithm

00:18:49,480 --> 00:18:55,240
so we set up we have a subroutine that

00:18:52,450 --> 00:18:58,539
takes a tree hash and we pass it in some

00:18:55,240 --> 00:19:01,059
data and some kind of chunk size which

00:18:58,539 --> 00:19:02,889
we're going to default to one megabit

00:19:01,059 --> 00:19:07,120
and of course in Perl 6 you can just put

00:19:02,889 --> 00:19:08,799
the squared there I thought we don't

00:19:07,120 --> 00:19:10,960
take the data and then we have to break

00:19:08,799 --> 00:19:13,570
it up into the chunks and Perl 6 has a

00:19:10,960 --> 00:19:17,049
built-in that lets you do this so the

00:19:13,570 --> 00:19:19,690
comb built-in says give me some kind of

00:19:17,049 --> 00:19:22,840
regular expression and I will go through

00:19:19,690 --> 00:19:24,039
your string and find matches for that

00:19:22,840 --> 00:19:26,409
and then return you a list of the

00:19:24,039 --> 00:19:28,600
matches so it's almost exactly the

00:19:26,409 --> 00:19:30,190
opposite of split you know split goes

00:19:28,600 --> 00:19:32,049
through and finds the things that don't

00:19:30,190 --> 00:19:33,759
match well this goes through implies the

00:19:32,049 --> 00:19:36,879
thing that do match well I'm saying here

00:19:33,759 --> 00:19:40,419
is finally things are anything of size

00:19:36,879 --> 00:19:42,129
in up to chunk size so to find me the

00:19:40,419 --> 00:19:44,289
first chunk size and then the next chunk

00:19:42,129 --> 00:19:46,870
size and the next chunk size if there's

00:19:44,289 --> 00:19:49,019
a bit over at the end then the 12 chunk

00:19:46,870 --> 00:19:50,870
size will allow me to take that as well

00:19:49,019 --> 00:19:54,770
so from there

00:19:50,870 --> 00:19:57,920
get a list of all of the individual

00:19:54,770 --> 00:20:01,850
chunked components and then I just match

00:19:57,920 --> 00:20:03,650
are 256 over them and of course sha-256

00:20:01,850 --> 00:20:04,690
being a function I can just say map and

00:20:03,650 --> 00:20:07,430
here's the name of the function

00:20:04,690 --> 00:20:10,280
literally by give individual so that

00:20:07,430 --> 00:20:14,059
does the initial mapping of each of the

00:20:10,280 --> 00:20:16,340
chunks to char but then of course I have

00:20:14,059 --> 00:20:17,870
to reduce the hatch just like sleeping

00:20:16,340 --> 00:20:20,690
or showing as before I have to have that

00:20:17,870 --> 00:20:22,460
reduce hash functionality well the

00:20:20,690 --> 00:20:24,830
easiest way of doing that is to write a

00:20:22,460 --> 00:20:27,980
couple of different things that reduce a

00:20:24,830 --> 00:20:30,290
hash clearly you want to be able to

00:20:27,980 --> 00:20:34,670
reduce a hash when you've got multiple

00:20:30,290 --> 00:20:36,950
nodes given to you and the way that

00:20:34,670 --> 00:20:39,590
you'll do that is that you will really

00:20:36,950 --> 00:20:41,059
digest each of those know to re-share

00:20:39,590 --> 00:20:43,370
each of those nodes which I'll show you

00:20:41,059 --> 00:20:46,190
in a minute and then you'll just call

00:20:43,370 --> 00:20:48,050
reduce hash on it again that's that

00:20:46,190 --> 00:20:50,600
recursion again so I'm going to go

00:20:48,050 --> 00:20:52,520
through and re shower each of them and

00:20:50,600 --> 00:20:55,070
then I'm going to recursively do it

00:20:52,520 --> 00:20:56,900
again now that's going to reduce the

00:20:55,070 --> 00:20:59,240
number of nodes in every case because

00:20:56,900 --> 00:21:01,010
you're joining two together eventually

00:20:59,240 --> 00:21:03,230
you're going to get to the point where

00:21:01,010 --> 00:21:06,200
there's only one node in your list and

00:21:03,230 --> 00:21:08,450
then this special version of reduced

00:21:06,200 --> 00:21:11,630
hash will handle that and it will handle

00:21:08,450 --> 00:21:14,510
that pi just returning the node and that

00:21:11,630 --> 00:21:15,380
will terminate the recursion because

00:21:14,510 --> 00:21:18,559
you're going to be able to stop the

00:21:15,380 --> 00:21:20,300
recursion and I think this is a pretty

00:21:18,559 --> 00:21:23,000
neat way of doing that now the question

00:21:20,300 --> 00:21:28,700
is okay well how then do I go through

00:21:23,000 --> 00:21:31,670
and read I jest everything well i do is

00:21:28,700 --> 00:21:34,280
i say i'm going to Matt two things at

00:21:31,670 --> 00:21:36,770
our time remember I've got to take two

00:21:34,280 --> 00:21:38,990
things at a time now in Perl 5am athlon

00:21:36,770 --> 00:21:42,100
ii do one thing at a time which is why

00:21:38,990 --> 00:21:44,809
you have to go through all those sort of

00:21:42,100 --> 00:21:46,929
evolutions to make it happen in Perl 6

00:21:44,809 --> 00:21:49,220
your say now that takes two arguments

00:21:46,929 --> 00:21:50,929
but of course taking two arguments

00:21:49,220 --> 00:21:53,210
wouldn't be right if they happen to be

00:21:50,929 --> 00:21:54,559
an odd number of nodes because you'd end

00:21:53,210 --> 00:21:56,179
up with one and then the map will take

00:21:54,559 --> 00:21:59,600
no you said two arguments that's not two

00:21:56,179 --> 00:22:00,750
arguments die so what I do as I say k 2

00:21:59,600 --> 00:22:04,350
argument

00:22:00,750 --> 00:22:06,600
take one optional Matt through the whole

00:22:04,350 --> 00:22:09,360
list on those two arguments with the

00:22:06,600 --> 00:22:11,370
second one being optional if the second

00:22:09,360 --> 00:22:13,470
one is there this is the ternary

00:22:11,370 --> 00:22:15,690
operator in 46 the second one is there

00:22:13,470 --> 00:22:19,200
join the two things together and char

00:22:15,690 --> 00:22:21,410
256 them and if it's not there just

00:22:19,200 --> 00:22:23,460
return the a which must have been there

00:22:21,410 --> 00:22:25,380
so that's doing that thing in the

00:22:23,460 --> 00:22:27,540
original tree where if there aren't two

00:22:25,380 --> 00:22:32,120
then we just promote the individual one

00:22:27,540 --> 00:22:34,170
straight up without reshoring it and

00:22:32,120 --> 00:22:36,480
that's it that's the whole algorithm

00:22:34,170 --> 00:22:40,200
there but I will admit that that is not

00:22:36,480 --> 00:22:44,820
yet as clean simple as what Stephen

00:22:40,200 --> 00:22:47,370
showed you but I ain't done yet first

00:22:44,820 --> 00:22:49,560
thing we're to know is the same problem

00:22:47,370 --> 00:22:52,080
that Stephen had was that hang on a

00:22:49,560 --> 00:22:53,730
minute I'm doing a literal recursion

00:22:52,080 --> 00:22:55,500
here so at every stage I'm incurring

00:22:53,730 --> 00:22:58,950
another stack frame which means

00:22:55,500 --> 00:23:01,440
eventually I will run out of stack but

00:22:58,950 --> 00:23:04,170
of course in Perl 6 there's also a way

00:23:01,440 --> 00:23:08,700
of eliminating that tail recursion and

00:23:04,170 --> 00:23:13,620
it ain't a magical go to in Perl 6 the

00:23:08,700 --> 00:23:16,170
way you do that is with this there's a

00:23:13,620 --> 00:23:19,110
special built-in that just says hey do

00:23:16,170 --> 00:23:21,990
the same thing that you are with these

00:23:19,110 --> 00:23:24,360
arguments instead and that literally

00:23:21,990 --> 00:23:26,970
replaces the current stack frame with a

00:23:24,360 --> 00:23:30,140
cursive called the same thing but it's

00:23:26,970 --> 00:23:32,940
literal tail recursion elimination

00:23:30,140 --> 00:23:35,970
without scary and ugly things that you

00:23:32,940 --> 00:23:40,140
have to hide in a keyword so that's

00:23:35,970 --> 00:23:41,790
pretty cool but there are so other good

00:23:40,140 --> 00:23:44,990
things that we can do with this so we

00:23:41,790 --> 00:23:47,730
have these two different versions of

00:23:44,990 --> 00:23:49,020
reduced hash and I'd like to just in

00:23:47,730 --> 00:23:52,110
Versailles like to get rid of the ring

00:23:49,020 --> 00:23:55,680
digest thing so it turns out to be

00:23:52,110 --> 00:23:57,900
possible to do that even in fact get rid

00:23:55,680 --> 00:24:01,140
of all that stuff and rearrange the code

00:23:57,900 --> 00:24:02,610
a little bit and now we're doing exactly

00:24:01,140 --> 00:24:05,730
the same thing now we're just saying

00:24:02,610 --> 00:24:08,310
okay you've got multiple nodes then take

00:24:05,730 --> 00:24:11,220
the nodes and reach our them all

00:24:08,310 --> 00:24:12,710
together and then do the same thing

00:24:11,220 --> 00:24:15,600
again

00:24:12,710 --> 00:24:17,700
and if you already got one no then just

00:24:15,600 --> 00:24:19,920
return the night and now we're down to a

00:24:17,700 --> 00:24:21,990
very small amount of code oh by the way

00:24:19,920 --> 00:24:26,730
the important thing there is that same

00:24:21,990 --> 00:24:29,460
with doesn't recurse back to the multi

00:24:26,730 --> 00:24:32,010
with multiple nodes it tries to work out

00:24:29,460 --> 00:24:34,980
wet which of the two reduce hashes it

00:24:32,010 --> 00:24:37,290
should same with so this is something

00:24:34,980 --> 00:24:39,660
you can't do in Perl 5 because there is

00:24:37,290 --> 00:24:42,870
no multiple dispatch in Perl 5 but in

00:24:39,660 --> 00:24:46,429
Perl 6 it just does the right thing so I

00:24:42,870 --> 00:24:50,700
thought that was pretty close to cool

00:24:46,429 --> 00:24:54,419
but I wasn't happy still a secret of my

00:24:50,700 --> 00:24:58,440
success is I'm never happy it's like the

00:24:54,419 --> 00:25:00,150
Hulk you know I'm always unhappy so I

00:24:58,440 --> 00:25:03,929
thought I don't really need all that

00:25:00,150 --> 00:25:05,790
stuff it'd be a lot easier if I just had

00:25:03,929 --> 00:25:08,190
a tree folders well cuz I like Stevens

00:25:05,790 --> 00:25:09,840
tree fall it's kind of nice do I have to

00:25:08,190 --> 00:25:11,820
load a module and do all kinds of

00:25:09,840 --> 00:25:13,559
complicated stuff with strings to get it

00:25:11,820 --> 00:25:17,130
now of course I don't because this perl

00:25:13,559 --> 00:25:19,650
6 so in Perl steps i could just write a

00:25:17,130 --> 00:25:22,830
tree fold subroutine that look like this

00:25:19,650 --> 00:25:25,350
it would take a block of code to execute

00:25:22,830 --> 00:25:28,110
and the data that it's supposed to

00:25:25,350 --> 00:25:30,030
execute the code block on and it would

00:25:28,110 --> 00:25:32,580
say if there's enough data if there's

00:25:30,030 --> 00:25:36,059
more than one bit of data then I'm just

00:25:32,580 --> 00:25:40,950
going to map the block that I've given

00:25:36,059 --> 00:25:43,020
you over the data and then do the same

00:25:40,950 --> 00:25:46,020
thing with the block again so that's

00:25:43,020 --> 00:25:47,790
that same recursion but now i'm passing

00:25:46,020 --> 00:25:50,210
the block in in the same way that

00:25:47,790 --> 00:25:52,410
Stephen was passing it to the keyword

00:25:50,210 --> 00:25:54,960
and of course if there's only one item

00:25:52,410 --> 00:25:59,280
then I just returned the one item and

00:25:54,960 --> 00:26:04,650
I'm done so now i can say three fold

00:25:59,280 --> 00:26:06,419
this thing using these nodes and that's

00:26:04,650 --> 00:26:09,419
pretty cool but i realize i'm still not

00:26:06,419 --> 00:26:12,510
happy with that because i didn't want to

00:26:09,419 --> 00:26:14,370
have to say a and B to just know there's

00:26:12,510 --> 00:26:14,759
going to be a and bina to do the right

00:26:14,370 --> 00:26:17,279
thing

00:26:14,759 --> 00:26:21,149
automatically guess what in Perl 6 you

00:26:17,279 --> 00:26:24,899
can do that too so if you're six I could

00:26:21,149 --> 00:26:26,969
just write three fold shower of self

00:26:24,899 --> 00:26:30,719
declaring a sub declaring be I'm still

00:26:26,969 --> 00:26:33,389
giving that block two arguments but now

00:26:30,719 --> 00:26:36,359
i'm just not declaring them

00:26:33,389 --> 00:26:38,489
automatically so now i still need a

00:26:36,359 --> 00:26:40,320
truthful implementation but it leads to

00:26:38,489 --> 00:26:43,519
be a little bit more sophisticated and

00:26:40,320 --> 00:26:46,109
it needs to work like this in general

00:26:43,519 --> 00:26:48,809
three-fold is going to take a block and

00:26:46,109 --> 00:26:50,519
some data but if just the block an

00:26:48,809 --> 00:26:52,349
ordinary data it's just going to return

00:26:50,519 --> 00:26:54,899
the data if there's not enough data to

00:26:52,349 --> 00:26:57,599
beat refolding then we're finished tree

00:26:54,899 --> 00:26:59,940
folding now how will I know into there's

00:26:57,599 --> 00:27:03,839
enough data to beat refolding the second

00:26:59,940 --> 00:27:06,509
version says this is the version where

00:27:03,839 --> 00:27:09,839
the amount of data is greater than the

00:27:06,509 --> 00:27:13,319
arity of the block need to think about

00:27:09,839 --> 00:27:15,449
that a little bit yeah so the era d of

00:27:13,319 --> 00:27:19,679
the block is how many arguments does the

00:27:15,449 --> 00:27:22,199
block take and the Pearl section just

00:27:19,679 --> 00:27:26,369
ask any piece of code and the arguments

00:27:22,199 --> 00:27:31,259
do you take so I asked it and if the

00:27:26,369 --> 00:27:33,959
number of data is greater than or equal

00:27:31,259 --> 00:27:36,119
to the block arity then I can't refold

00:27:33,959 --> 00:27:39,539
because there's enough to end both the

00:27:36,119 --> 00:27:41,940
tree fold what do i do in that case in

00:27:39,539 --> 00:27:44,159
that case I have to work out where the

00:27:41,940 --> 00:27:46,019
last thing was just like Stephen had to

00:27:44,159 --> 00:27:47,639
because of course there might be more

00:27:46,019 --> 00:27:50,609
data but they might not be enough data

00:27:47,639 --> 00:27:53,339
to do three fold on everyone and I might

00:27:50,609 --> 00:27:55,440
have something left over the end what do

00:27:53,339 --> 00:27:58,139
i do I say okay the total amount of data

00:27:55,440 --> 00:27:59,579
minus the data more the block harrity

00:27:58,139 --> 00:28:01,739
because that the battle of the block

00:27:59,579 --> 00:28:05,249
arity is what's left over after the last

00:28:01,739 --> 00:28:07,559
one that's going to be my last index

00:28:05,249 --> 00:28:08,419
that I want to do this too so what am I

00:28:07,559 --> 00:28:11,869
going to do then

00:28:08,419 --> 00:28:16,399
say map the block over all the data up

00:28:11,869 --> 00:28:20,210
to but excluding the last index so that

00:28:16,399 --> 00:28:23,149
does mapping over sets of elements of

00:28:20,210 --> 00:28:25,119
say multiple of two or multiple of three

00:28:23,149 --> 00:28:30,169
or multiple of whatever for your blog

00:28:25,119 --> 00:28:32,539
and then for the rest of it from last to

00:28:30,169 --> 00:28:34,309
the end of the data set just put that on

00:28:32,539 --> 00:28:37,369
the end because that's what the tree

00:28:34,309 --> 00:28:41,239
fold see things says to do take blocks

00:28:37,369 --> 00:28:43,419
of in this case two and remap them and

00:28:41,239 --> 00:28:47,480
then just add the rest on at the end and

00:28:43,419 --> 00:28:53,539
then recurse but it would work for

00:28:47,480 --> 00:28:56,389
blocks of three as well thing I'm going

00:28:53,539 --> 00:28:59,869
to explain that in just a moment so the

00:28:56,389 --> 00:29:06,109
vertical bar and the tightness thank you

00:28:59,869 --> 00:29:09,799
for asking have the capacity to modify

00:29:06,109 --> 00:29:12,080
the way that lists are constructed the

00:29:09,799 --> 00:29:15,710
point is in Perl 6 every list is an

00:29:12,080 --> 00:29:18,200
object so if you say list comma list you

00:29:15,710 --> 00:29:20,539
get a list of two things which is a list

00:29:18,200 --> 00:29:21,529
of lists but sometimes we're still on

00:29:20,539 --> 00:29:23,419
flattening and that doesn't happen

00:29:21,529 --> 00:29:24,710
automatically in Perl 6 you want

00:29:23,419 --> 00:29:27,019
flattening you have to have something

00:29:24,710 --> 00:29:29,119
that makes it flattened and the vertical

00:29:27,019 --> 00:29:30,799
bar is one of the things in Perl 6 that

00:29:29,119 --> 00:29:33,230
will flatten this back down to a single

00:29:30,799 --> 00:29:34,940
is we want a platen back down to a

00:29:33,230 --> 00:29:39,559
single this because I'm about to

00:29:34,940 --> 00:29:41,090
rehearse with the block so this is doing

00:29:39,559 --> 00:29:44,600
the same thing now admittedly that's not

00:29:41,090 --> 00:29:46,489
nearly as straightforward as the last

00:29:44,600 --> 00:29:49,639
thing at Stephen showed but Stephen had

00:29:46,489 --> 00:29:53,840
a trick and Siemens trick was you take

00:29:49,639 --> 00:29:56,830
all of that and you put it into a module

00:29:53,840 --> 00:30:01,520
which i claim i'm allowed to do as well

00:29:56,830 --> 00:30:03,860
now the other thing is this module is as

00:30:01,520 --> 00:30:05,779
generika Stevens one if you had a block

00:30:03,860 --> 00:30:08,330
of that took three arguments this would

00:30:05,779 --> 00:30:10,190
treat fold three at a time or in at a

00:30:08,330 --> 00:30:12,440
time or one at a time although tree

00:30:10,190 --> 00:30:17,049
falling one at a time is not such a good

00:30:12,440 --> 00:30:19,850
idea so at this point I'm fairly close

00:30:17,049 --> 00:30:22,190
but then I observed well this is

00:30:19,850 --> 00:30:23,900
functional programming and here i have a

00:30:22,190 --> 00:30:26,000
function that i'm calling and all that

00:30:23,900 --> 00:30:28,010
function does is do something with its

00:30:26,000 --> 00:30:32,620
argument and in functional programming

00:30:28,010 --> 00:30:32,620
when that happens you can factor back in

00:30:34,000 --> 00:30:44,840
and that gentlemen I would argue is a

00:30:41,690 --> 00:30:48,260
simple or simpler than four or five

00:30:44,840 --> 00:30:51,649
version okay well that's all i have to

00:30:48,260 --> 00:30:55,370
say i didn't really want to drop it yeah

00:30:51,649 --> 00:31:02,210
whatever holla at this point return you

00:30:55,370 --> 00:31:06,799
to your regularly scheduled program so

00:31:02,210 --> 00:31:11,059
even in 405 you don't need scale up to

00:31:06,799 --> 00:31:13,070
do the kind of tale elimination you can

00:31:11,059 --> 00:31:15,320
even do it magically under the hood with

00:31:13,070 --> 00:31:18,710
the functions the other interesting

00:31:15,320 --> 00:31:22,549
thing about this and one of the usual

00:31:18,710 --> 00:31:25,159
objections to functional programming is

00:31:22,549 --> 00:31:30,679
that all of that copying seems like too

00:31:25,159 --> 00:31:33,230
much overhead well maybe the functional

00:31:30,679 --> 00:31:37,399
programming a lot of the times is easier

00:31:33,230 --> 00:31:38,809
to write it work most of us are used to

00:31:37,399 --> 00:31:40,400
doing it I mean unless you studied

00:31:38,809 --> 00:31:44,420
Elisabet college or something

00:31:40,400 --> 00:31:48,200
so it takes a little bit of getting used

00:31:44,420 --> 00:31:49,610
to the the optimization you know the

00:31:48,200 --> 00:31:52,510
case of the syntactic sugar with the

00:31:49,610 --> 00:31:57,830
keyboard isn't that hard to produce and

00:31:52,510 --> 00:32:00,260
I go a couple for it the real quick one

00:31:57,830 --> 00:32:05,200
is this is looking at the time it took

00:32:00,260 --> 00:32:08,840
on on machine I have to execute

00:32:05,200 --> 00:32:12,470
different numbers of excuse me of

00:32:08,840 --> 00:32:14,150
megabytes in a buffer split it apart if

00:32:12,470 --> 00:32:17,660
you look on slideshare there's a bunch

00:32:14,150 --> 00:32:22,310
of things you didn't see here but you'll

00:32:17,660 --> 00:32:25,130
notice the time it takes with a using

00:32:22,310 --> 00:32:27,770
the keyword to generate the code to

00:32:25,130 --> 00:32:30,410
split it apart it's actually more

00:32:27,770 --> 00:32:33,380
efficient in Perl because pearl does

00:32:30,410 --> 00:32:34,940
such a good job of stack handling that

00:32:33,380 --> 00:32:38,570
assigning lists putting them through

00:32:34,940 --> 00:32:43,010
math is faster than trying to do all the

00:32:38,570 --> 00:32:48,500
intimate stuff so it actually works

00:32:43,010 --> 00:32:51,710
rather nice one anyway any questions in

00:32:48,500 --> 00:32:55,120
the week everyone with a heartbeat raise

00:32:51,710 --> 00:32:55,120
your hand there we go

00:33:04,380 --> 00:33:09,550
well the 5 16 and up because of the

00:33:07,120 --> 00:33:12,670
devil underscores up there otherwise it

00:33:09,550 --> 00:33:17,490
the you have to do things with you know

00:33:12,670 --> 00:33:22,350
use bars and pre declaring it what not

00:33:17,490 --> 00:33:22,350
these problems rattled in a while

00:33:28,480 --> 00:33:35,090
the main difference there would be that

00:33:33,049 --> 00:33:40,840
you've got to have well if you want to

00:33:35,090 --> 00:33:40,840
add underscore equal I didn't like

00:33:41,649 --> 00:33:45,559
ultimately they're getting into the

00:33:43,909 --> 00:33:48,590
problem there that you've got her when

00:33:45,559 --> 00:33:50,629
do you want to exit the list if the pure

00:33:48,590 --> 00:33:55,100
functional approach because I can't

00:33:50,629 --> 00:33:58,789
modify the stack I i have only constant

00:33:55,100 --> 00:34:01,820
data you get into the situation that how

00:33:58,789 --> 00:34:04,850
would I know that I'm done if I'm not

00:34:01,820 --> 00:34:09,050
splicing the stack off I can't do while

00:34:04,850 --> 00:34:13,190
at underscore greater than the

00:34:09,050 --> 00:34:19,550
functional approach by reassigning the

00:34:13,190 --> 00:34:21,500
stack and going to you can you can see

00:34:19,550 --> 00:34:24,589
when you're done because I don't go to

00:34:21,500 --> 00:34:27,230
if you have a wild loop you think about

00:34:24,589 --> 00:34:30,829
it as a while the stack I've computed

00:34:27,230 --> 00:34:34,669
last I've iterated the thing I've still

00:34:30,829 --> 00:34:37,159
got the stack so you have to enter the

00:34:34,669 --> 00:34:38,929
thing to check the stack but if I'm not

00:34:37,159 --> 00:34:43,369
recursing I'm not coming back with a new

00:34:38,929 --> 00:34:45,559
stack there's nothing to chat the other

00:34:43,369 --> 00:34:47,149
thing is that actually it's physically

00:34:45,559 --> 00:34:49,760
less code for the same amount of work I

00:34:47,149 --> 00:34:55,040
mean you saw how much code it took to do

00:34:49,760 --> 00:34:57,819
that block the keyword by just saying do

00:34:55,040 --> 00:34:57,819
block

00:34:58,060 --> 00:35:03,110
it leaves you writing the very least

00:35:00,860 --> 00:35:04,610
amount of code that you have to if you

00:35:03,110 --> 00:35:06,340
look at it well it's a lot of slides

00:35:04,610 --> 00:35:08,600
back there but if you look at the the

00:35:06,340 --> 00:35:11,420
implementation if there's if there's a

00:35:08,600 --> 00:35:14,030
right value sha them otherwise just take

00:35:11,420 --> 00:35:17,750
a left one he I can't make it but short

00:35:14,030 --> 00:35:20,330
of that and or the tree fold that he had

00:35:17,750 --> 00:35:23,060
in Perl 6 all you're really doing is

00:35:20,330 --> 00:35:26,030
declaring tree fold a pair otherwise

00:35:23,060 --> 00:35:28,730
give me a value and that's that the idea

00:35:26,030 --> 00:35:32,420
is to try and reduce the co2 as much

00:35:28,730 --> 00:35:34,550
purely declarative as you can so that

00:35:32,420 --> 00:35:40,010
somebody looking at it can see what it's

00:35:34,550 --> 00:35:42,770
trying to do the other is very important

00:35:40,010 --> 00:35:45,650
that if you're doing in that pure

00:35:42,770 --> 00:35:50,450
functional style where you're not using

00:35:45,650 --> 00:35:53,840
these kinds of life politics local it's

00:35:50,450 --> 00:35:55,860
really really easy to refactor and that

00:35:53,840 --> 00:35:59,920
sometimes is

00:35:55,860 --> 00:36:03,950
that way but as soon as you start using

00:35:59,920 --> 00:36:07,610
any kind of conclude then that probably

00:36:03,950 --> 00:36:09,870
outside the loop which control the wild

00:36:07,610 --> 00:36:12,810
and as soon as you have a variable

00:36:09,870 --> 00:36:15,900
outside of Waterloo very hard factor

00:36:12,810 --> 00:36:19,560
that while loop out because it's kind of

00:36:15,900 --> 00:36:21,420
pull into the variable so what I've been

00:36:19,560 --> 00:36:25,230
finding all the functional protein I've

00:36:21,420 --> 00:36:27,240
been doing is that that thing where

00:36:25,230 --> 00:36:28,860
where I SAT there knows i hope and i

00:36:27,240 --> 00:36:31,470
realized i could just pack that is back

00:36:28,860 --> 00:36:33,620
in or camper now that's the best

00:36:31,470 --> 00:36:35,580
experience but I have all the time now

00:36:33,620 --> 00:36:37,350
look at some I guess I hope you know

00:36:35,580 --> 00:36:39,930
what I don't need this sub call we can

00:36:37,350 --> 00:36:43,650
factor this thing in the region i can

00:36:39,930 --> 00:36:47,340
factor in is because I've avoided those

00:36:43,650 --> 00:36:50,550
under parotid constructs the tie piece

00:36:47,340 --> 00:36:53,310
of code to its environment like the bar

00:36:50,550 --> 00:36:58,070
I think that's the significant value

00:36:53,310 --> 00:37:03,270
especially when punctual approaches 56

00:36:58,070 --> 00:37:04,950
seem to work about the obvious reason to

00:37:03,270 --> 00:37:07,950
do a little bit the problem is I

00:37:04,950 --> 00:37:10,290
expected to run faster frankly it

00:37:07,950 --> 00:37:12,810
doesn't quite statement I works first

00:37:10,290 --> 00:37:14,340
talking about this and here's a new york

00:37:12,810 --> 00:37:18,770
function up there yet here we can buy

00:37:14,340 --> 00:37:23,340
isopentenyl run quite a bit slow expand

00:37:18,770 --> 00:37:27,300
we do that again so the one mainly i

00:37:23,340 --> 00:37:29,200
think was that tree through a while but

00:37:27,300 --> 00:37:32,560
in terms of nights kind of bill

00:37:29,200 --> 00:37:43,900
and in the debug ability on climbing

00:37:32,560 --> 00:37:49,150
functional approaches we acted

00:37:43,900 --> 00:37:51,580
assignments not doing it already it

00:37:49,150 --> 00:37:54,430
drinkies all among sanguine to the

00:37:51,580 --> 00:37:56,560
deeper i think it's not actually doing

00:37:54,430 --> 00:37:59,950
the tiger very low national offices

00:37:56,560 --> 00:38:03,550
suppose i have changed i replaced in you

00:37:59,950 --> 00:38:05,890
reviewed 0 2 days ago and I haven't

00:38:03,550 --> 00:38:08,230
shaved after there was one thing to I

00:38:05,890 --> 00:38:11,470
mean one of the great things about the

00:38:08,230 --> 00:38:13,530
Perl 6 is that being written in perl 6

00:38:11,470 --> 00:38:16,210
it's actually pretty flexible so sunday

00:38:13,530 --> 00:38:18,730
David either brought up something about

00:38:16,210 --> 00:38:20,860
required taking a string so you both is

00:38:18,730 --> 00:38:23,650
wrong with something and lose actually

00:38:20,860 --> 00:38:28,300
got it into the code Monday morning by

00:38:23,650 --> 00:38:30,460
tonight so for most sane improvements in

00:38:28,300 --> 00:38:32,820
the language and the progress of it it's

00:38:30,460 --> 00:38:36,730
it's actually amazing how quickly work

00:38:32,820 --> 00:38:42,130
because the the actual compiler for perl

00:38:36,730 --> 00:38:44,670
6 of perl 6 not quite pearl things so it

00:38:42,130 --> 00:38:44,670
was that helpful

00:38:45,250 --> 00:38:51,430
if anyone actually cares about the rest

00:38:47,590 --> 00:38:52,690
I top you can grab it on SlideShare and

00:38:51,430 --> 00:38:54,970
it shows you actually there's another

00:38:52,690 --> 00:38:57,370
keyword for creating constants by

00:38:54,970 --> 00:38:59,590
greater value keyword and you can have a

00:38:57,370 --> 00:39:03,610
value for a variable value for a sub

00:38:59,590 --> 00:39:07,900
call and a lot of the mistakes most of

00:39:03,610 --> 00:39:10,960
us made in programing our whacking with

00:39:07,900 --> 00:39:12,400
something inside you didn't realize you

00:39:10,960 --> 00:39:15,280
didn't realize someone was modifying

00:39:12,400 --> 00:39:18,780
something so you can constitute I things

00:39:15,280 --> 00:39:18,780

YouTube URL: https://www.youtube.com/watch?v=7zHwNymO7BE


