Title: 2016 - Finding dead code, the quick and easy way, with Devel::QuickCoverâ€Ž - Gonzalo Diethelm
Publication date: 2016-06-27
Playlist: YAPC::NA 2016
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:09,860
thank you very much anyway everyone can

00:00:03,360 --> 00:00:13,730
hear me cool okay so develop could cover

00:00:09,860 --> 00:00:16,920
brief introduction about me unlike Damen

00:00:13,730 --> 00:00:21,090
Conway he clearly stated yesterday that

00:00:16,920 --> 00:00:23,910
he hates C and C++ I feel the other way

00:00:21,090 --> 00:00:26,970
so this is what I feel about lace and

00:00:23,910 --> 00:00:28,769
pearl pearl to me seems like a hacking

00:00:26,970 --> 00:00:32,940
language which is fine I'm not passing

00:00:28,769 --> 00:00:35,940
judgment but I am NOT a pair hacker so I

00:00:32,940 --> 00:00:39,980
I want to disclaim that I love C and

00:00:35,940 --> 00:00:42,710
love C++ and i also love lists so

00:00:39,980 --> 00:00:45,870
everything we're going to see today is

00:00:42,710 --> 00:00:48,059
probably not due to my level of

00:00:45,870 --> 00:00:51,239
knowledge of pearl but despite my

00:00:48,059 --> 00:00:53,430
knowledge of pearl I'm going to try to

00:00:51,239 --> 00:00:56,610
go a bit fast because i only have 20

00:00:53,430 --> 00:00:59,460
minutes so what exactly are we trying to

00:00:56,610 --> 00:01:02,550
achieve we would like for a given pair

00:00:59,460 --> 00:01:05,210
program to find the lines that were

00:01:02,550 --> 00:01:08,220
actually executed during run time and

00:01:05,210 --> 00:01:13,140
hopefully without any large impacts on

00:01:08,220 --> 00:01:15,869
cpu and memory so that's like one

00:01:13,140 --> 00:01:19,439
example of a type of program that we

00:01:15,869 --> 00:01:24,450
would like to work on its kind of

00:01:19,439 --> 00:01:27,540
contrived but if you look at the Swap my

00:01:24,450 --> 00:01:29,310
apps we have code that you may not

00:01:27,540 --> 00:01:34,590
always be executed because of the eaves

00:01:29,310 --> 00:01:36,210
and therefore the lines that are

00:01:34,590 --> 00:01:38,520
actually executed for that code will

00:01:36,210 --> 00:01:43,520
vary on every run depending on what

00:01:38,520 --> 00:01:46,680
parameters you give it and in some cases

00:01:43,520 --> 00:01:48,780
if your inputs for that program are

00:01:46,680 --> 00:01:51,649
always positive there will be land in

00:01:48,780 --> 00:01:55,950
there that will never be executed so the

00:01:51,649 --> 00:01:59,549
purpose of the role could cover is to

00:01:55,950 --> 00:02:01,409
point you to the lines that maybe never

00:01:59,549 --> 00:02:04,500
executed in your code base so that you

00:02:01,409 --> 00:02:08,390
can try to try to to delete or clean

00:02:04,500 --> 00:02:15,030
them up and get rid of that code

00:02:08,390 --> 00:02:17,370
so can we do this yes we can and have to

00:02:15,030 --> 00:02:21,510
get inspiration for how to arrive to the

00:02:17,370 --> 00:02:23,940
idea that we have implemented let's take

00:02:21,510 --> 00:02:26,670
a simplified version of the code so that

00:02:23,940 --> 00:02:31,320
still has at least one line that that

00:02:26,670 --> 00:02:33,690
may or may not be executed and we take a

00:02:31,320 --> 00:02:36,030
look at that program using parallel and

00:02:33,690 --> 00:02:39,870
mobile phone sex please raise your hand

00:02:36,030 --> 00:02:41,220
if you have no idea what that does okay

00:02:39,870 --> 00:02:45,980
so there are some people here who don't

00:02:41,220 --> 00:02:49,830
know that what that is if you run

00:02:45,980 --> 00:02:53,160
parallel mode concise with those options

00:02:49,830 --> 00:02:59,190
you get a dump of your program basically

00:02:53,160 --> 00:03:01,020
the 0 module gives you a dump of your

00:02:59,190 --> 00:03:03,510
code in several different formats and

00:03:01,020 --> 00:03:06,030
that's one of the format's you get where

00:03:03,510 --> 00:03:09,660
you see that's basically the OP tree for

00:03:06,030 --> 00:03:12,060
the program if you look carefully you

00:03:09,660 --> 00:03:14,010
will see that there are a couple of

00:03:12,060 --> 00:03:16,860
lines that have this next state thing

00:03:14,010 --> 00:03:20,910
and next to the next day thing you will

00:03:16,860 --> 00:03:23,459
see file names and lines of code in

00:03:20,910 --> 00:03:26,459
there so we have three lines with next

00:03:23,459 --> 00:03:28,260
day with lines four five and eight and

00:03:26,459 --> 00:03:31,530
if you look at the original program you

00:03:28,260 --> 00:03:34,470
will notice that those three lines are

00:03:31,530 --> 00:03:37,920
exactly the lines that are executed when

00:03:34,470 --> 00:03:39,959
you run the program almost almost

00:03:37,920 --> 00:03:42,290
because line six for that particular

00:03:39,959 --> 00:03:44,370
instance will also be executed but

00:03:42,290 --> 00:03:47,519
concise doesn't know that until you

00:03:44,370 --> 00:03:50,310
actually run the program but this seems

00:03:47,519 --> 00:03:54,330
like a good start right this seems like

00:03:50,310 --> 00:03:57,390
hmm so maybe with this information that

00:03:54,330 --> 00:03:58,890
i get from concise I kind of could get

00:03:57,390 --> 00:04:02,700
my hands on to the clients that are

00:03:58,890 --> 00:04:06,180
actually executed so a little

00:04:02,700 --> 00:04:08,220
introduction to the pearl up tree so a

00:04:06,180 --> 00:04:11,250
bit more detail of

00:04:08,220 --> 00:04:15,060
we were looking at right there for those

00:04:11,250 --> 00:04:17,400
of you who don't know when pearl

00:04:15,060 --> 00:04:21,540
compiles your program basically what it

00:04:17,400 --> 00:04:26,250
does is create a something close to a

00:04:21,540 --> 00:04:28,380
sin abstract syntax tree that represents

00:04:26,250 --> 00:04:32,250
the same instructions that you're going

00:04:28,380 --> 00:04:35,340
to run and then Pearl has a large

00:04:32,250 --> 00:04:38,370
dispatch table so for each of the ops in

00:04:35,340 --> 00:04:41,040
that tree that you see their pronouns

00:04:38,370 --> 00:04:43,880
have to go to the dispatch table and

00:04:41,040 --> 00:04:48,440
fill that particular node in the tree

00:04:43,880 --> 00:04:53,130
with that routine in the dispatch table

00:04:48,440 --> 00:04:55,260
if you look at the all the up codes in

00:04:53,130 --> 00:04:56,970
that ditch by dispatch table which is

00:04:55,260 --> 00:04:59,400
basically from by the way it's in the

00:04:56,970 --> 00:05:02,010
files of names that aging the probe

00:04:59,400 --> 00:05:04,890
distribution there's one of them called

00:05:02,010 --> 00:05:07,410
up next eight so pearl knows how to

00:05:04,890 --> 00:05:10,680
handle that up it has its own code to do

00:05:07,410 --> 00:05:12,000
it but what's interesting is that next

00:05:10,680 --> 00:05:14,040
day is the same thing that we were

00:05:12,000 --> 00:05:16,680
looking at with protein sites so what

00:05:14,040 --> 00:05:19,200
perricone size was showing us was that

00:05:16,680 --> 00:05:24,270
on those three lines we were using that

00:05:19,200 --> 00:05:27,300
up to generate the code so next eight

00:05:24,270 --> 00:05:30,630
the arm we have a dispatch table so

00:05:27,300 --> 00:05:32,550
maybe this is crazy enough and this

00:05:30,630 --> 00:05:35,910
could work we could try to hook into

00:05:32,550 --> 00:05:38,760
that and see what we get so that's

00:05:35,910 --> 00:05:42,450
exactly on the evil plan that i'm going

00:05:38,760 --> 00:05:46,800
to show to you so what do we do but

00:05:42,450 --> 00:05:49,050
what's this plan we created a new HS

00:05:46,800 --> 00:05:50,810
module and yes this has to be done at

00:05:49,050 --> 00:05:55,169
the sea level because this is very

00:05:50,810 --> 00:06:00,120
little and we will hook into that pearl

00:05:55,169 --> 00:06:04,169
dispatch table so that every time pearl

00:06:00,120 --> 00:06:05,820
uses the dispatched able to say and I

00:06:04,169 --> 00:06:08,850
have a next date here I'm going to take

00:06:05,820 --> 00:06:11,940
the routine associated to next state and

00:06:08,850 --> 00:06:15,470
put that in my note in the syntax tree

00:06:11,940 --> 00:06:17,970
we will actually put our own version of

00:06:15,470 --> 00:06:19,510
our routine that will do something else

00:06:17,970 --> 00:06:23,650
besides doing the

00:06:19,510 --> 00:06:27,520
new usual our next date hamler we will

00:06:23,650 --> 00:06:29,380
do our own stuff in there our own staff

00:06:27,520 --> 00:06:32,440
will be collecting the information that

00:06:29,380 --> 00:06:34,570
we saw that line being executed and then

00:06:32,440 --> 00:06:35,830
at the end when the program exits we

00:06:34,570 --> 00:06:39,790
will dump all that all of that

00:06:35,830 --> 00:06:45,370
information and we will profit hopefully

00:06:39,790 --> 00:06:46,930
so how do we start the data and it's

00:06:45,370 --> 00:06:49,270
funny that we still see those kinds of

00:06:46,930 --> 00:06:51,250
pictures in movies every time someone

00:06:49,270 --> 00:06:55,000
tries to convey to you who computers

00:06:51,250 --> 00:06:58,690
here so how do we store the data that we

00:06:55,000 --> 00:07:01,000
will gather basically what we have here

00:06:58,690 --> 00:07:04,590
is one bit of information per each file

00:07:01,000 --> 00:07:08,620
and line right so that's that's only one

00:07:04,590 --> 00:07:10,240
this is not code profiling where you

00:07:08,620 --> 00:07:12,250
don't really care about how many times

00:07:10,240 --> 00:07:15,940
we see a line we do care about whether

00:07:12,250 --> 00:07:18,280
we saw the line or we did there could be

00:07:15,940 --> 00:07:19,870
multiple files because we've our could

00:07:18,280 --> 00:07:21,790
use this or require sort of other

00:07:19,870 --> 00:07:26,020
modules we will have more than one file

00:07:21,790 --> 00:07:29,440
and of course pair each file we will

00:07:26,020 --> 00:07:32,080
have more than one line probably so in

00:07:29,440 --> 00:07:34,930
the end that points to having a hash of

00:07:32,080 --> 00:07:39,030
all the file names and for each of those

00:07:34,930 --> 00:07:41,380
files we will have a bit set we

00:07:39,030 --> 00:07:44,110
implemented in the most obvious way so

00:07:41,380 --> 00:07:46,360
what we're looking for is to quickly sit

00:07:44,110 --> 00:07:48,520
one of the bits in that pizza we don't

00:07:46,360 --> 00:07:52,900
really care about intersection or union

00:07:48,520 --> 00:07:55,000
or any other fancy its operations so we

00:07:52,900 --> 00:08:00,280
can actually really really use just one

00:07:55,000 --> 00:08:02,710
bit per line of code that we see so this

00:08:00,280 --> 00:08:07,260
could have a that's right it's obvious

00:08:02,710 --> 00:08:09,810
that if you do crazy in your

00:08:07,260 --> 00:08:13,690
interpreter as you're running the code

00:08:09,810 --> 00:08:16,660
that stuff could happen so what do we

00:08:13,690 --> 00:08:21,550
care for what what should we we be

00:08:16,660 --> 00:08:24,760
looking for beforehand extra CPU when we

00:08:21,550 --> 00:08:26,350
execute a lion extra memory also for all

00:08:24,760 --> 00:08:27,940
the coverage information and hopefully

00:08:26,350 --> 00:08:30,289
the computer will not go down in flames

00:08:27,940 --> 00:08:32,089
and we didn't I

00:08:30,289 --> 00:08:36,229
we know if this would happen or not so

00:08:32,089 --> 00:08:37,579
every time you metal with the Pearl

00:08:36,229 --> 00:08:46,000
internal so you know you don't know

00:08:37,579 --> 00:08:48,940
what's going to happen so demo time have

00:08:46,000 --> 00:08:52,670
fire extinguisher ready please because

00:08:48,940 --> 00:09:02,410
things could blow up so let me see if I

00:08:52,670 --> 00:09:02,410
can do this yeah okay

00:09:06,760 --> 00:09:14,400
why is it not going there it's refusing

00:09:12,130 --> 00:09:14,400
to go

00:09:16,470 --> 00:09:23,190
probably because of this whole screen

00:09:18,570 --> 00:09:28,040
and of course in sprite where what is it

00:09:23,190 --> 00:09:28,040
then green thing

00:09:38,620 --> 00:09:45,390
I don't see what I'm going up there

00:09:49,920 --> 00:10:05,369
MMH yeah doesn't do anything of course

00:10:01,169 --> 00:10:05,369
presentation now

00:10:14,510 --> 00:10:17,320
oh well

00:10:19,470 --> 00:10:34,899
I'm trying to move this terminal ah

00:10:23,949 --> 00:10:42,509
there we go Hey okay so let me clear

00:10:34,899 --> 00:10:48,990
that up so again so this is again the

00:10:42,509 --> 00:10:48,990
original looking at now and if Iran that

00:10:53,370 --> 00:11:04,689
so I am running that and we see that

00:11:01,829 --> 00:11:10,449
okay so absolute value is zero at zero

00:11:04,689 --> 00:11:18,209
bow and a minus four is four ok so the

00:11:10,449 --> 00:11:20,529
code runs and I don't have any any

00:11:18,209 --> 00:11:22,680
generate the files from developer cover

00:11:20,529 --> 00:11:25,990
so what I'm gonna do now is I'm going to

00:11:22,680 --> 00:11:29,439
change that line I don't have the fancy

00:11:25,990 --> 00:11:35,970
I like to stop you used I have to type

00:11:29,439 --> 00:11:35,970
this so I just

00:11:35,980 --> 00:11:46,090
I just use the file the module and we're

00:11:42,490 --> 00:11:52,150
going to rerun again with a positive

00:11:46,090 --> 00:11:58,420
power so 45 so still get the same file

00:11:52,150 --> 00:12:04,420
but now i also have data there i

00:11:58,420 --> 00:12:07,690
generated a new file and if I it's a

00:12:04,420 --> 00:12:14,040
JSON file something I just type it into

00:12:07,690 --> 00:12:19,150
JQ so we got some nice information here

00:12:14,040 --> 00:12:23,500
we have file apps at PL those who are

00:12:19,150 --> 00:12:25,360
the lines cover so six if all of those

00:12:23,500 --> 00:12:29,290
are in the main routine what's

00:12:25,360 --> 00:12:31,870
interesting here is that we ran line 21

00:12:29,290 --> 00:12:38,230
but didn't run line compliance 22 and 23

00:12:31,870 --> 00:12:41,070
because we gave it a positive bout if I

00:12:38,230 --> 00:12:41,070
gave it a zero

00:12:44,019 --> 00:12:51,339
I get a zero now of course I have to

00:12:48,459 --> 00:12:53,610
cover it files I'm to pick the right one

00:12:51,339 --> 00:12:53,610
here

00:12:59,720 --> 00:13:06,699
actually easier to surround this again

00:13:09,470 --> 00:13:16,520
and now we get lines 21 22 and 23 so it

00:13:13,430 --> 00:13:20,410
actually works it dynamically registers

00:13:16,520 --> 00:13:24,200
every line that was actually executed

00:13:20,410 --> 00:13:27,190
okay so let's see if I can go back to my

00:13:24,200 --> 00:13:27,190
presentation okay

00:13:35,589 --> 00:13:39,250
back to where we were

00:13:46,639 --> 00:13:54,720
so how am i doing one time five six okay

00:13:51,739 --> 00:13:57,119
I'm assuming you're gonna when I have

00:13:54,720 --> 00:13:58,410
some questions so how do we do this i'm

00:13:57,119 --> 00:14:02,009
going to sleep some slides at the end

00:13:58,410 --> 00:14:05,459
how do we build this contraption it's

00:14:02,009 --> 00:14:09,569
actually very little very few lines of c

00:14:05,459 --> 00:14:11,309
code we have an excess module that when

00:14:09,569 --> 00:14:13,589
you use it through the import function

00:14:11,309 --> 00:14:18,110
we end up calling this country here and

00:14:13,589 --> 00:14:21,449
what that function does is we take the

00:14:18,110 --> 00:14:23,939
object state member in the TL Kiki adder

00:14:21,449 --> 00:14:26,279
array which is the dispatch table at

00:14:23,939 --> 00:14:28,679
peril has for all the approach we store

00:14:26,279 --> 00:14:30,869
we remember the original value and we

00:14:28,679 --> 00:14:33,509
set a new value in the array which with

00:14:30,869 --> 00:14:39,350
our own function and that own function

00:14:33,509 --> 00:14:42,209
what that does is call the original here

00:14:39,350 --> 00:14:44,639
so we call the original and remember

00:14:42,209 --> 00:14:48,089
what that for original function gave us

00:14:44,639 --> 00:14:49,470
back that's a an improvement that I'm

00:14:48,089 --> 00:14:51,509
not going to cover this and running out

00:14:49,470 --> 00:14:54,299
of time and then once we have run the

00:14:51,509 --> 00:14:57,149
original we call our own function with

00:14:54,299 --> 00:14:59,819
those two arguments that is the current

00:14:57,149 --> 00:15:02,339
file that's been executed and there is a

00:14:59,819 --> 00:15:06,389
current line that's being executed and

00:15:02,339 --> 00:15:08,069
that's it there's more in this module of

00:15:06,389 --> 00:15:11,429
course are some improvements i'm gonna

00:15:08,069 --> 00:15:15,899
go i'm not going to go over so i'm going

00:15:11,429 --> 00:15:21,749
to get the evolution of this thing so

00:15:15,899 --> 00:15:24,660
double improvements and dog fooding this

00:15:21,749 --> 00:15:27,029
is actually more interesting i think do

00:15:24,660 --> 00:15:29,279
we actually use this yes we are using

00:15:27,029 --> 00:15:32,279
this in our in one of our web

00:15:29,279 --> 00:15:34,980
environments we see no impact at all

00:15:32,279 --> 00:15:38,459
this is in production in live code know

00:15:34,980 --> 00:15:40,169
if I Carolyn start at time we end up

00:15:38,459 --> 00:15:44,549
using about a hundred megabytes more

00:15:40,169 --> 00:15:48,660
memory than without the module um which

00:15:44,549 --> 00:15:51,809
is that to that memory cheap anyway and

00:15:48,660 --> 00:15:54,119
what we do is we generate all of those

00:15:51,809 --> 00:15:54,470
files many times over every time we have

00:15:54,119 --> 00:15:57,530
it

00:15:54,470 --> 00:15:59,150
on the page we get a new one or more of

00:15:57,530 --> 00:16:00,800
those files and we collect him and

00:15:59,150 --> 00:16:02,510
aggregate them and so what we end up

00:16:00,800 --> 00:16:05,240
with is like the union of all the

00:16:02,510 --> 00:16:07,070
coverage information that we gathered

00:16:05,240 --> 00:16:09,890
and from that way generate some reports

00:16:07,070 --> 00:16:13,060
originally we used the valve cover

00:16:09,890 --> 00:16:16,550
reports but now we have written how long

00:16:13,060 --> 00:16:18,850
that's one example of what you could do

00:16:16,550 --> 00:16:21,740
with this so in there we are seeing that

00:16:18,850 --> 00:16:24,350
the if branch is not being executed

00:16:21,740 --> 00:16:28,700
which is awesome because the if branches

00:16:24,350 --> 00:16:31,610
for EPS ed code and the else branch is

00:16:28,700 --> 00:16:33,740
for ASCII values so it would be a big

00:16:31,610 --> 00:16:35,900
surprise if we were seeing the branch

00:16:33,740 --> 00:16:39,280
being executive so that's another check

00:16:35,900 --> 00:16:42,890
that this actually works and that's it

00:16:39,280 --> 00:16:48,320
and of course I didn't implement this on

00:16:42,890 --> 00:16:52,060
all of myself there were a lot of people

00:16:48,320 --> 00:16:56,480
helping here mattia was the original

00:16:52,060 --> 00:16:59,480
creator of this crazy idea I just took

00:16:56,480 --> 00:17:02,600
it and run with it Sawyer helped me a

00:16:59,480 --> 00:17:05,420
lot he proud of me yeah go go go and do

00:17:02,600 --> 00:17:07,490
it stephen was also a lot of help we can

00:17:05,420 --> 00:17:09,050
t Stephen and we can t have provided

00:17:07,490 --> 00:17:11,150
some patches for those improvements I

00:17:09,050 --> 00:17:13,130
didn't have time to go over which are

00:17:11,150 --> 00:17:15,410
basically we end up using a bit more

00:17:13,130 --> 00:17:17,570
memory but we're also registering the

00:17:15,410 --> 00:17:19,820
compiler face where your line is being

00:17:17,570 --> 00:17:24,110
executed so that's interesting and

00:17:19,820 --> 00:17:27,460
p-type Ecolab is our internal group at

00:17:24,110 --> 00:17:31,000
booking where we do all this crazy

00:17:27,460 --> 00:17:34,700
so thanks to them for all their help

00:17:31,000 --> 00:17:38,740
this is in meta Sipan you can get it

00:17:34,700 --> 00:17:41,480
there the source code is in github and

00:17:38,740 --> 00:17:45,110
hrmm you do it that's actually our

00:17:41,480 --> 00:17:46,850
office putting a comma no actually no

00:17:45,110 --> 00:17:49,490
people write their bikes on that red

00:17:46,850 --> 00:17:51,740
thing but its chemical and we're always

00:17:49,490 --> 00:17:53,920
hiring people in answer thank you very

00:17:51,740 --> 00:17:53,920
much

00:17:58,800 --> 00:18:05,890
questions it's great how fast you run

00:18:03,640 --> 00:18:07,810
blend of limitations though is that it's

00:18:05,890 --> 00:18:10,480
only able to see that eight line was

00:18:07,810 --> 00:18:12,280
executed not necessarily which have on

00:18:10,480 --> 00:18:15,460
the line so if I have a complicated line

00:18:12,280 --> 00:18:17,230
I don't know right if you have a line

00:18:15,460 --> 00:18:19,990
that has like several statements

00:18:17,230 --> 00:18:24,130
separated by a semicolon you get one one

00:18:19,990 --> 00:18:26,470
bit of information is it is the module

00:18:24,130 --> 00:18:29,710
packed with some aggregation too and we

00:18:26,470 --> 00:18:34,330
already knew so many energy server one

00:18:29,710 --> 00:18:37,240
from so what's in it HAP is just this

00:18:34,330 --> 00:18:39,190
the exs module the reports and all the

00:18:37,240 --> 00:18:41,800
aggregation is internal tooling for us

00:18:39,190 --> 00:18:43,750
because it's kind of convoluted the way

00:18:41,800 --> 00:18:46,480
we ftp files from one side to the other

00:18:43,750 --> 00:18:49,510
and then we mix them together I'm I'm

00:18:46,480 --> 00:18:52,330
wrong actually the the distribution and

00:18:49,510 --> 00:18:54,790
github include segregation of files so

00:18:52,330 --> 00:18:56,200
yeah but it's I mean it's like 50 lines

00:18:54,790 --> 00:18:58,090
of code that you could actually write

00:18:56,200 --> 00:19:03,360
yourself this is all JSON files so all

00:18:58,090 --> 00:19:03,360
the the output is JSON files and one

00:19:06,110 --> 00:19:10,340
the cheap way to do it would be

00:19:18,630 --> 00:19:27,610
probably yes we were kind of blinded by

00:19:25,030 --> 00:19:29,799
the stupidity of yeah this seems cool

00:19:27,610 --> 00:19:37,870
let's do it and it actually works its

00:19:29,799 --> 00:19:42,309
own did you guys get any regular measure

00:19:37,870 --> 00:19:44,770
the overhead of this yeah as I mentioned

00:19:42,309 --> 00:19:48,400
there's no measure noticeable speed

00:19:44,770 --> 00:19:51,100
voice uh it also happens that we preload

00:19:48,400 --> 00:19:54,130
a lot of stuff at talking so we take the

00:19:51,100 --> 00:19:57,250
hit at the beginning and one of the

00:19:54,130 --> 00:19:58,900
improvements that we did was okay he's

00:19:57,250 --> 00:20:00,309
saying a matter of time so let me answer

00:19:58,900 --> 00:20:02,799
you percent one of the improvements with

00:20:00,309 --> 00:20:06,669
it is that after you have seen one line

00:20:02,799 --> 00:20:08,650
we restore the original opcode so that

00:20:06,669 --> 00:20:11,169
line will never go over our code paths

00:20:08,650 --> 00:20:14,740
again therefore it tends to converge

00:20:11,169 --> 00:20:17,169
very quickly to the final set of covered

00:20:14,740 --> 00:20:19,870
lines and then the only overhead you pay

00:20:17,169 --> 00:20:23,470
is for lines that you have not seen yet

00:20:19,870 --> 00:20:29,770
which are fewer than the original set of

00:20:23,470 --> 00:20:33,059
lines are you preload and is the boss so

00:20:29,770 --> 00:20:33,059

YouTube URL: https://www.youtube.com/watch?v=HLRkmvLerxI


