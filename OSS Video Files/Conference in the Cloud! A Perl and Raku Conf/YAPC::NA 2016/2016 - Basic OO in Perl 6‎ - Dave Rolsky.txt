Title: 2016 - Basic OO in Perl 6â€Ž - Dave Rolsky
Publication date: 2016-06-27
Playlist: YAPC::NA 2016
Description: 
	
Captions: 
	00:00:00,060 --> 00:00:07,440
get started all right hi everyone hey I

00:00:05,210 --> 00:00:09,750
hope you're awake after you know

00:00:07,440 --> 00:00:12,750
doughnuts and grits and you know other

00:00:09,750 --> 00:00:15,630
light food so my name is Dave Hall ski

00:00:12,750 --> 00:00:18,359
and I'm gonna be talking about basic

00:00:15,630 --> 00:00:21,840
object-oriented programming features in

00:00:18,359 --> 00:00:25,220
Perl 6 not programming Visual Basic and

00:00:21,840 --> 00:00:27,900
Perl 6 as Larry was so excited about but

00:00:25,220 --> 00:00:29,519
sorry Larry and you know it's not

00:00:27,900 --> 00:00:31,260
intimidating at all that I have you know

00:00:29,519 --> 00:00:33,180
the creator of the language with the

00:00:31,260 --> 00:00:35,280
leading implementers in the audience so

00:00:33,180 --> 00:00:37,410
I I may throw questions back to them

00:00:35,280 --> 00:00:39,090
because I'm not a Perl 6 expert I've

00:00:37,410 --> 00:00:42,870
just used it a bit and been

00:00:39,090 --> 00:00:44,460
experimenting and enjoying myself and I

00:00:42,870 --> 00:00:46,350
want to share some of the things I've

00:00:44,460 --> 00:00:47,750
learned with with all of you alright so

00:00:46,350 --> 00:00:49,980
let's get going

00:00:47,750 --> 00:00:51,989
so I'm going to assume for this talk

00:00:49,980 --> 00:00:53,789
that you're actually already familiar

00:00:51,989 --> 00:00:56,879
with some basic oo terminology because

00:00:53,789 --> 00:00:58,190
this isn't an intro to object-oriented

00:00:56,879 --> 00:01:00,210
programming

00:00:58,190 --> 00:01:02,190
session so if you're not promote with

00:01:00,210 --> 00:01:04,290
any of these terms this may be a little

00:01:02,190 --> 00:01:05,519
difficult to follow but if I were to

00:01:04,290 --> 00:01:07,500
explain all of these this would be a

00:01:05,519 --> 00:01:08,790
two-hour session instead of 50 minutes

00:01:07,500 --> 00:01:10,110
and we'd be here a really long time and

00:01:08,790 --> 00:01:11,400
you wouldn't get to eat lunch and you'll

00:01:10,110 --> 00:01:13,080
be really unhappy with me

00:01:11,400 --> 00:01:16,770
and I'm also going to assume that you

00:01:13,080 --> 00:01:18,540
can read basic Perl 6 syntax if I think

00:01:16,770 --> 00:01:21,630
maybe many of you were here for the

00:01:18,540 --> 00:01:23,580
prior session where Patrick was doing an

00:01:21,630 --> 00:01:25,170
intro to Perl 6 which hopefully will

00:01:23,580 --> 00:01:27,150
give you a sense of what Perl 6 syntax

00:01:25,170 --> 00:01:29,820
looked like I'm gonna explain the oo

00:01:27,150 --> 00:01:31,740
specific bits but I'm not gonna explain

00:01:29,820 --> 00:01:34,079
every little bit of Perl 6 syntax in

00:01:31,740 --> 00:01:34,700
these slides so with that said let's get

00:01:34,079 --> 00:01:37,020
going

00:01:34,700 --> 00:01:40,020
so one of the really nice things about

00:01:37,020 --> 00:01:42,780
Perl 6 compared to both Perl 5 is that

00:01:40,020 --> 00:01:45,119
Perl 6 is really oh oh all the way to

00:01:42,780 --> 00:01:47,700
the very core level so in this example

00:01:45,119 --> 00:01:50,670
here we can see that I'm assigning just

00:01:47,700 --> 00:01:52,710
a plain integer to dollar X and then I

00:01:50,670 --> 00:01:55,710
can call methods on it and if I ask what

00:01:52,710 --> 00:01:57,990
it is which is a built-in method in Perl

00:01:55,710 --> 00:02:00,540
6 which tells you the type of the object

00:01:57,990 --> 00:02:03,479
it says it's an int int is actually a

00:02:00,540 --> 00:02:04,890
class in Perl 6 which is really nice for

00:02:03,479 --> 00:02:07,079
all sorts of reasons some of which I'll

00:02:04,890 --> 00:02:10,500
try to touch on and it has other methods

00:02:07,079 --> 00:02:13,150
so we can call is prime and of course 42

00:02:10,500 --> 00:02:16,180
is not prime 42 3 is so after

00:02:13,150 --> 00:02:18,099
incremented it says true anyway so

00:02:16,180 --> 00:02:21,760
that's that's one nice thing about Perl

00:02:18,099 --> 00:02:23,739
600 so really everything's an object so

00:02:21,760 --> 00:02:26,110
we saw numbers everything else you could

00:02:23,739 --> 00:02:28,000
possibly imagine working with is an

00:02:26,110 --> 00:02:31,420
object including things like arrays and

00:02:28,000 --> 00:02:34,030
hashes and all of the built-in functions

00:02:31,420 --> 00:02:36,400
are also available as methods so you can

00:02:34,030 --> 00:02:38,709
call length as a method or defined and

00:02:36,400 --> 00:02:41,349
even things like hash and array lookups

00:02:38,709 --> 00:02:43,450
are actually methods under the hood and

00:02:41,349 --> 00:02:45,159
one of the other nice things about Perl

00:02:43,450 --> 00:02:46,510
6 is that much of it is written in Perl

00:02:45,159 --> 00:02:48,940
6 so if you want to see how it's

00:02:46,510 --> 00:02:51,849
implemented you can actually just go

00:02:48,940 --> 00:02:54,040
into the core code and read Perl 6 code

00:02:51,849 --> 00:02:56,170
or something called nqp which is still a

00:02:54,040 --> 00:02:57,700
lot like Perl 6 and get a sense of how

00:02:56,170 --> 00:03:00,129
it works which I don't know if you've

00:02:57,700 --> 00:03:01,599
ever tried to look at the Perl 5 core to

00:03:00,129 --> 00:03:05,220
figure out how something is implemented

00:03:01,599 --> 00:03:07,780
and then run away screaming the macros

00:03:05,220 --> 00:03:10,150
anyway so Perl 6 is much nicer in this

00:03:07,780 --> 00:03:11,620
respect you can a lot of it is just Perl

00:03:10,150 --> 00:03:12,609
6 code you open up and read it and

00:03:11,620 --> 00:03:15,430
you're like yeah this totally makes

00:03:12,609 --> 00:03:17,230
sense it's also made fixing bugs in it

00:03:15,430 --> 00:03:19,690
really nice I found a bug and I was able

00:03:17,230 --> 00:03:21,970
to patch it whereas with the pro 5 I

00:03:19,690 --> 00:03:24,699
mean I can write C but I don't enjoy it

00:03:21,970 --> 00:03:27,340
and fixing a bug in Perl 5 core is much

00:03:24,699 --> 00:03:29,560
harder all right so let's make a new

00:03:27,340 --> 00:03:31,720
class it's really simple in Perl 6 we

00:03:29,560 --> 00:03:34,120
just use the keyword class we're good

00:03:31,720 --> 00:03:36,819
class the name we put some curly braces

00:03:34,120 --> 00:03:38,230
now we have a class and in fact we can

00:03:36,819 --> 00:03:40,780
already do something with the class we

00:03:38,230 --> 00:03:43,090
can call new on the class name and we

00:03:40,780 --> 00:03:44,590
get back an object it's not a very

00:03:43,090 --> 00:03:46,180
interesting object because it doesn't

00:03:44,590 --> 00:03:48,099
have any attributes or methods but hey

00:03:46,180 --> 00:03:49,810
we made a class it's pretty exciting we

00:03:48,099 --> 00:03:53,949
can call dot what on it because that's

00:03:49,810 --> 00:03:55,900
provided by the kind of default parent

00:03:53,949 --> 00:04:00,159
class for all objects and it tells us

00:03:55,900 --> 00:04:02,620
it's a log pretty cool so we saw the

00:04:00,159 --> 00:04:04,000
class keyword declares a new class you

00:04:02,620 --> 00:04:04,419
can put the body of the class in curly

00:04:04,000 --> 00:04:07,659
braces

00:04:04,419 --> 00:04:09,790
there's also another form of writing

00:04:07,659 --> 00:04:12,489
packages where you can write unit class

00:04:09,790 --> 00:04:15,489
and then everything after that in the

00:04:12,489 --> 00:04:17,620
file is part of that package and a class

00:04:15,489 --> 00:04:19,959
is just a special type of module in Perl

00:04:17,620 --> 00:04:24,520
6 did you cover modules at all Patrick

00:04:19,959 --> 00:04:25,659
ok so basically anything that you can do

00:04:24,520 --> 00:04:26,590
with the module you can do with the

00:04:25,659 --> 00:04:29,080
class

00:04:26,590 --> 00:04:32,620
and so that's where the unit thing comes

00:04:29,080 --> 00:04:34,960
from and you can give it a version and

00:04:32,620 --> 00:04:36,790
there's just once you learn more about

00:04:34,960 --> 00:04:38,290
modules you realize you can all use it

00:04:36,790 --> 00:04:41,169
all for classes but I'm not going to

00:04:38,290 --> 00:04:43,870
cover all that so you can also apply

00:04:41,169 --> 00:04:46,270
these modifiers to a class so one of

00:04:43,870 --> 00:04:48,340
them you can write is and then a parent

00:04:46,270 --> 00:04:52,180
class so we can write class log class

00:04:48,340 --> 00:04:56,139
log lap loud is log and now log loud is

00:04:52,180 --> 00:04:58,389
a subclass of log we can make a new log

00:04:56,139 --> 00:04:59,770
object and then we can call is on it

00:04:58,389 --> 00:05:02,380
again that's one of those things that's

00:04:59,770 --> 00:05:04,240
built in and it returns true both for

00:05:02,380 --> 00:05:08,770
log loud and log so sub classing is

00:05:04,240 --> 00:05:11,950
really trivial one thing to note that's

00:05:08,770 --> 00:05:14,860
different in Perl 6 from Perl 5 is that

00:05:11,950 --> 00:05:16,900
when you write this it actually you need

00:05:14,860 --> 00:05:20,979
to have that class available now in Perl

00:05:16,900 --> 00:05:22,840
5 you can write that is a equals some

00:05:20,979 --> 00:05:24,729
string of garbage that does not actually

00:05:22,840 --> 00:05:27,340
match a class that is loaded or will

00:05:24,729 --> 00:05:29,200
ever be loaded and pro 5 is perfectly

00:05:27,340 --> 00:05:31,870
happy with that and at some point during

00:05:29,200 --> 00:05:33,850
runtime you may or may not get some sort

00:05:31,870 --> 00:05:37,330
of confusing error about this with Perl

00:05:33,850 --> 00:05:39,100
6 if I type out log where it wrote is

00:05:37,330 --> 00:05:41,140
log it's actually going to complain and

00:05:39,100 --> 00:05:42,910
say hey I don't know what this is it's

00:05:41,140 --> 00:05:46,570
another really nice feature about Perl 6

00:05:42,910 --> 00:05:48,970
is that classes are kind of first first

00:05:46,570 --> 00:05:52,330
class things in language they're not

00:05:48,970 --> 00:05:55,150
just strings and the language knows what

00:05:52,330 --> 00:05:57,720
classes exist and will complain if you

00:05:55,150 --> 00:06:01,660
try to give it something that does not

00:05:57,720 --> 00:06:03,840
so we saw calls to dot new in several

00:06:01,660 --> 00:06:05,800
places so that's the constructor and

00:06:03,840 --> 00:06:07,389
this is just created for you

00:06:05,800 --> 00:06:09,970
automatically when you could clear a

00:06:07,389 --> 00:06:12,070
class you get a constructor you can

00:06:09,970 --> 00:06:14,080
override it but most of the time you

00:06:12,070 --> 00:06:15,850
don't really want to the default

00:06:14,080 --> 00:06:18,460
constructor is pretty good instead you

00:06:15,850 --> 00:06:22,120
can use a method called build all

00:06:18,460 --> 00:06:25,210
capitals which lets you hook into the

00:06:22,120 --> 00:06:26,830
object construction process by the way

00:06:25,210 --> 00:06:29,979
one thing I forgot to mention how many

00:06:26,830 --> 00:06:32,110
of you use moves in Perl 5 ok we're

00:06:29,979 --> 00:06:34,060
quite a number of you so you might be

00:06:32,110 --> 00:06:37,060
thinking jeez some of this looks really

00:06:34,060 --> 00:06:39,370
familiar in fact a huge amount of what

00:06:37,060 --> 00:06:39,770
you know for moose is very very directly

00:06:39,370 --> 00:06:41,629
applicable to

00:06:39,770 --> 00:06:45,800
Boulder Perl 6 which is really nice

00:06:41,629 --> 00:06:48,319
mousse is Steven essentially backporting

00:06:45,800 --> 00:06:51,020
as much of the Perl 600 system as he

00:06:48,319 --> 00:06:53,990
could to Perl 5 some of the details work

00:06:51,020 --> 00:06:55,490
differently in mousse because it doesn't

00:06:53,990 --> 00:06:58,430
implement them it kind of the language

00:06:55,490 --> 00:07:00,349
keyword level so things like has for

00:06:58,430 --> 00:07:03,139
example or just an exported function

00:07:00,349 --> 00:07:05,319
whereas in Perl 6 it is a first-class

00:07:03,139 --> 00:07:07,009
keyword that's seen by the parser and

00:07:05,319 --> 00:07:09,319
handled at compile time

00:07:07,009 --> 00:07:11,780
but nonetheless a lot of like the basic

00:07:09,319 --> 00:07:14,300
idea is that you learn from moose also

00:07:11,780 --> 00:07:16,130
apply to Perl 6 so for example and moose

00:07:14,300 --> 00:07:19,250
there you can write build methods and do

00:07:16,130 --> 00:07:22,190
the same thing in Perl 6 so build is

00:07:19,250 --> 00:07:23,870
called after the object is created but

00:07:22,190 --> 00:07:28,580
before the caller sees it so it's kind

00:07:23,870 --> 00:07:30,889
of your chance to do something object

00:07:28,580 --> 00:07:32,449
construction time before the caller gets

00:07:30,889 --> 00:07:33,770
a chance to mess with the object so you

00:07:32,449 --> 00:07:35,539
do things like some sort of complex

00:07:33,770 --> 00:07:37,699
validation that maybe doesn't fit into

00:07:35,539 --> 00:07:39,919
tight constraints like you might want to

00:07:37,699 --> 00:07:42,500
say if one attribute is populated this

00:07:39,919 --> 00:07:44,930
other must be and if this you know F

00:07:42,500 --> 00:07:46,610
attribute a is not populated then B must

00:07:44,930 --> 00:07:48,590
also not be populated something like

00:07:46,610 --> 00:07:51,650
that you could do logging really

00:07:48,590 --> 00:07:53,840
anything else and the way it works is

00:07:51,650 --> 00:07:56,300
build is called in every class in your

00:07:53,840 --> 00:07:58,669
hierarchy starting with the most distant

00:07:56,300 --> 00:08:02,509
ancestor so like grandparent and then

00:07:58,669 --> 00:08:04,729
parent and then child and also show you

00:08:02,509 --> 00:08:06,830
how you can use build to set private

00:08:04,729 --> 00:08:10,190
attributes that are passed in you which

00:08:06,830 --> 00:08:11,509
is a handy feature see if somebody's

00:08:10,190 --> 00:08:13,699
scowling you're scowling why would you

00:08:11,509 --> 00:08:19,460
want to do that well I'll cover that

00:08:13,699 --> 00:08:21,020
later so here's an example of build a

00:08:19,460 --> 00:08:22,880
build is actually a special type of

00:08:21,020 --> 00:08:23,930
method called a sub method and I'll talk

00:08:22,880 --> 00:08:26,180
about that in a moment

00:08:23,930 --> 00:08:30,020
C right sub method capital build and

00:08:26,180 --> 00:08:32,029
then a very trivial example so you'll

00:08:30,020 --> 00:08:35,630
notice we called log new and then we say

00:08:32,029 --> 00:08:40,130
the log thing that we got the message

00:08:35,630 --> 00:08:43,250
from build happens before our code here

00:08:40,130 --> 00:08:44,600
so like I said build happens after the

00:08:43,250 --> 00:08:46,820
object is constructed but before the

00:08:44,600 --> 00:08:48,430
caller sees it by the way feel free to

00:08:46,820 --> 00:08:57,220
raise your hand if you have any question

00:08:48,430 --> 00:08:59,790
yes so he was asking if are their method

00:08:57,220 --> 00:09:04,210
modifiers like before after and around

00:08:59,790 --> 00:09:07,060
there is a module on the Perl 6 version

00:09:04,210 --> 00:09:09,430
module top pro org that implements those

00:09:07,060 --> 00:09:13,480
and there is something built in I think

00:09:09,430 --> 00:09:16,270
it's just rap that lets you do that but

00:09:13,480 --> 00:09:18,810
the module on the Pearl sex module site

00:09:16,270 --> 00:09:20,740
gives you kind of a nicer syntax for it

00:09:18,810 --> 00:09:24,130
lets you write it more like you do with

00:09:20,740 --> 00:09:25,660
most so yeah so this the the core

00:09:24,130 --> 00:09:30,610
functionality you need is already built

00:09:25,660 --> 00:09:32,080
into the language basically anything you

00:09:30,610 --> 00:09:34,149
can do in mousse you can probably do in

00:09:32,080 --> 00:09:37,180
Perl 6 and there's probably a nicer way

00:09:34,149 --> 00:09:38,950
to do it and for all six alright so

00:09:37,180 --> 00:09:40,750
another thing to note is that the build

00:09:38,950 --> 00:09:42,940
method sees all of the arguments that

00:09:40,750 --> 00:09:45,459
are passed to the constructor so when

00:09:42,940 --> 00:09:47,500
you call new and this is an example of

00:09:45,459 --> 00:09:51,310
how you can pass named arguments so

00:09:47,500 --> 00:09:53,950
colon named parens value and then this

00:09:51,310 --> 00:09:56,560
argument lists a colon says it's a named

00:09:53,950 --> 00:09:59,560
argument and then dollar says it's

00:09:56,560 --> 00:10:01,000
scalar so it's just assigned right here

00:09:59,560 --> 00:10:03,100
so we can just use dollar size and

00:10:01,000 --> 00:10:05,080
dollar name from our parameter list and

00:10:03,100 --> 00:10:07,420
so those things that are passed to the

00:10:05,080 --> 00:10:09,520
constructor you can see and build so

00:10:07,420 --> 00:10:10,720
that's another useful thing like again

00:10:09,520 --> 00:10:12,070
you could do some sort of parameter

00:10:10,720 --> 00:10:17,260
validation that doesn't fit and type

00:10:12,070 --> 00:10:19,000
constraints to do all sorts of stuff all

00:10:17,260 --> 00:10:20,500
right so we want to write some methods

00:10:19,000 --> 00:10:22,480
how we how do we do that it's really

00:10:20,500 --> 00:10:24,130
simple you just write method and then

00:10:22,480 --> 00:10:25,720
the name of the method and then you put

00:10:24,130 --> 00:10:28,120
the body in curly braces this looks a

00:10:25,720 --> 00:10:31,810
lot like you do it in Perl 5 except to

00:10:28,120 --> 00:10:33,670
use method instead of sub now methods

00:10:31,810 --> 00:10:35,260
all have access to the infant which is

00:10:33,670 --> 00:10:37,540
the thing that the method was called on

00:10:35,260 --> 00:10:40,089
the object of the class and it's in self

00:10:37,540 --> 00:10:42,220
not dollar self like we typically use in

00:10:40,089 --> 00:10:44,589
Perl five but it's actually assigned to

00:10:42,220 --> 00:10:46,600
just bearwear itself this is actually a

00:10:44,589 --> 00:10:49,360
variable and you can change the name if

00:10:46,600 --> 00:10:50,740
you want but I would discourage people

00:10:49,360 --> 00:10:52,660
from doing that the same way to

00:10:50,740 --> 00:10:54,279
discourage people from being all cute

00:10:52,660 --> 00:10:55,870
and clever in their perl 5 code and

00:10:54,279 --> 00:10:57,820
calling it dollar this your dollar beer

00:10:55,870 --> 00:10:59,260
dollar whatever cuz it's really annoying

00:10:57,820 --> 00:11:00,880
and ninety

00:10:59,260 --> 00:11:02,560
ninety ninety-five percent of the crowd

00:11:00,880 --> 00:11:03,520
in the world uses doll their self so

00:11:02,560 --> 00:11:05,770
unless you have a really good reason

00:11:03,520 --> 00:11:07,990
just leave it alone and use the self

00:11:05,770 --> 00:11:09,790
that pearl six gives you otherwise this

00:11:07,990 --> 00:11:12,330
is just like a regular subroutine except

00:11:09,790 --> 00:11:15,010
it participates in inheritance of course

00:11:12,330 --> 00:11:18,340
so again really simple to declare

00:11:15,010 --> 00:11:20,500
methods and pearl six so we can write

00:11:18,340 --> 00:11:22,000
Beth had log message again you can have

00:11:20,500 --> 00:11:23,470
that parameter list in this case it's

00:11:22,000 --> 00:11:26,890
positional parameters so there's no

00:11:23,470 --> 00:11:30,130
colon in front of dollar message and we

00:11:26,890 --> 00:11:34,210
call it log message we pass a message

00:11:30,130 --> 00:11:35,980
and it spits it out so one thing you

00:11:34,210 --> 00:11:36,970
might be wondering what's with this I

00:11:35,980 --> 00:11:39,580
don't know if Patrick showed any

00:11:36,970 --> 00:11:42,040
examples of this you can use dashes in

00:11:39,580 --> 00:11:44,530
method names class names other names

00:11:42,040 --> 00:11:45,850
just really nice I feel like maybe this

00:11:44,530 --> 00:11:48,960
is kind of becoming the standard of

00:11:45,850 --> 00:11:51,790
pearl sex for public API is is to use

00:11:48,960 --> 00:11:54,970
what is being called kebab case I was

00:11:51,790 --> 00:11:56,680
lobbying for a flying snake case but it

00:11:54,970 --> 00:11:58,240
hasn't quite caught on but feel free to

00:11:56,680 --> 00:11:59,620
use it as much as possible for the rest

00:11:58,240 --> 00:12:03,520
of the conference and see if you can

00:11:59,620 --> 00:12:06,100
make it catch on alright so by default

00:12:03,520 --> 00:12:08,080
any methods you declare our public even

00:12:06,100 --> 00:12:10,240
if it starts with an underscore so that

00:12:08,080 --> 00:12:12,460
that purl five convention does not apply

00:12:10,240 --> 00:12:14,590
in Perl six however you can have

00:12:12,460 --> 00:12:16,090
actually private methods if you name

00:12:14,590 --> 00:12:18,100
them starting with an exclamation mark

00:12:16,090 --> 00:12:22,600
or I'll say bang because that's quicker

00:12:18,100 --> 00:12:25,360
so if we have a method like this being

00:12:22,600 --> 00:12:28,450
private then it cannot be called outside

00:12:25,360 --> 00:12:29,920
of the class and the way we call it is a

00:12:28,450 --> 00:12:31,870
little different too so instead of using

00:12:29,920 --> 00:12:34,330
the dot operator we actually use bang

00:12:31,870 --> 00:12:37,420
just like this and that calls the

00:12:34,330 --> 00:12:39,040
private method so I think it's pretty

00:12:37,420 --> 00:12:40,330
clear and it's nice that it's built into

00:12:39,040 --> 00:12:41,740
the language and you don't have to just

00:12:40,330 --> 00:12:43,360
say don't call the things with it start

00:12:41,740 --> 00:12:49,120
with an underscore Perl six will

00:12:43,360 --> 00:12:50,950
actually enforce it for you all right

00:12:49,120 --> 00:12:52,390
you can also call methods on a class

00:12:50,950 --> 00:12:55,060
which actually we've seen a bunch of

00:12:52,390 --> 00:12:58,510
times so far when I've called log dot

00:12:55,060 --> 00:13:02,310
new so the way you can figure that out

00:12:58,510 --> 00:13:04,780
is looking at whether self is defined if

00:13:02,310 --> 00:13:08,350
if it's called as a class method what

00:13:04,780 --> 00:13:09,990
you get is the class itself as the first

00:13:08,350 --> 00:13:12,490
argument rather than an object and

00:13:09,990 --> 00:13:15,880
classes are just under

00:13:12,490 --> 00:13:18,130
find how to explain it classes are

00:13:15,880 --> 00:13:21,010
undefined instances of the class are

00:13:18,130 --> 00:13:23,920
defined so one of the things to also

00:13:21,010 --> 00:13:27,730
notice note in Perl 6 is that this class

00:13:23,920 --> 00:13:29,320
thing is a a first class part of the

00:13:27,730 --> 00:13:31,930
language again it's not a string you're

00:13:29,320 --> 00:13:34,000
not getting a string with the value log

00:13:31,930 --> 00:13:36,580
inside it like you would with Perl 5

00:13:34,000 --> 00:13:38,260
you're actually getting the class and

00:13:36,580 --> 00:13:40,540
there are methods that you can call on

00:13:38,260 --> 00:13:43,089
that and ways you can use it that are

00:13:40,540 --> 00:13:45,700
distinct from how you would use a string

00:13:43,089 --> 00:13:47,740
now if you want to symbolically

00:13:45,700 --> 00:13:49,209
reference a class by name with the

00:13:47,740 --> 00:13:51,220
string there of course ways to do this

00:13:49,209 --> 00:13:53,830
this is still Perl you can do whatever

00:13:51,220 --> 00:13:55,360
crazy stuff you want and you know

00:13:53,830 --> 00:13:57,670
sometimes that crazy stuff is really

00:13:55,360 --> 00:14:00,070
useful but you're not getting a string

00:13:57,670 --> 00:14:03,160
by default so when we call it this way

00:14:00,070 --> 00:14:05,410
we call it an object self is defined so

00:14:03,160 --> 00:14:07,360
we say colors object the second time

00:14:05,410 --> 00:14:10,240
we're calling on a class self is not

00:14:07,360 --> 00:14:12,550
defined and we get the class by the way

00:14:10,240 --> 00:14:15,670
this is the ternary operator in Perl 6

00:14:12,550 --> 00:14:17,170
in case you haven't seen that yet any

00:14:15,670 --> 00:14:19,240
questions so far all making sense

00:14:17,170 --> 00:14:23,100
totally following along you're like Perl

00:14:19,240 --> 00:14:23,100
600 is just the best that's a question

00:14:28,140 --> 00:14:32,800
so the question was is the paradigm to

00:14:30,940 --> 00:14:35,200
check yourself as defined and mix those

00:14:32,800 --> 00:14:38,709
two into the same method there's

00:14:35,200 --> 00:14:42,579
actually a way to through the parameter

00:14:38,709 --> 00:14:45,790
list specify that something can only be

00:14:42,579 --> 00:14:47,860
called as a class or object method and

00:14:45,790 --> 00:14:50,230
since Perl 6 also has multi methods you

00:14:47,860 --> 00:14:51,640
could have both versions I'm not going

00:14:50,230 --> 00:14:54,970
to show that because it's just getting a

00:14:51,640 --> 00:14:57,940
little farther along and the spectrum

00:14:54,970 --> 00:14:59,529
then we have time for today but yeah

00:14:57,940 --> 00:15:02,290
there's there's a really nice way to do

00:14:59,529 --> 00:15:03,550
this in the parameter list yeah yeah in

00:15:02,290 --> 00:15:06,100
fact if you look through the core code

00:15:03,550 --> 00:15:07,480
you'll see this being used a lot and

00:15:06,100 --> 00:15:09,850
actually this is just a really nice

00:15:07,480 --> 00:15:12,190
feature in general Perl 6 is that when

00:15:09,850 --> 00:15:14,440
you specify a type you can say that it

00:15:12,190 --> 00:15:17,709
must be a defined instance of that type

00:15:14,440 --> 00:15:19,630
so you write int colon D which says it

00:15:17,709 --> 00:15:21,970
must be an integer not the integer class

00:15:19,630 --> 00:15:23,120
but in actually defined integer it's

00:15:21,970 --> 00:15:27,769
really nice

00:15:23,120 --> 00:15:31,100
yes to take yes : d and calling you it's

00:15:27,769 --> 00:15:33,529
very very useful I love it alright so we

00:15:31,100 --> 00:15:35,600
see methods we also saw this sub method

00:15:33,529 --> 00:15:37,730
thing Jenna didn't explain yet I want to

00:15:35,600 --> 00:15:40,040
explain the little and we we of course

00:15:37,730 --> 00:15:41,629
have sub routines it's still purl you

00:15:40,040 --> 00:15:42,980
can still write imperative code just

00:15:41,629 --> 00:15:44,839
write a subroutine with sub so the

00:15:42,980 --> 00:15:46,339
difference is the sub routine is just a

00:15:44,839 --> 00:15:48,350
sub routine just like it works in pro 5

00:15:46,339 --> 00:15:49,579
there's no implicant and there's no

00:15:48,350 --> 00:15:51,709
inheritance okay

00:15:49,579 --> 00:15:54,230
a method is a special type of sub

00:15:51,709 --> 00:15:57,259
routine it has an implicit we saw it can

00:15:54,230 --> 00:15:59,870
either be the class itself or an object

00:15:57,259 --> 00:16:02,629
of that class or subclass of course and

00:15:59,870 --> 00:16:04,069
methods participate in inheritance so

00:16:02,629 --> 00:16:07,069
those are inherited and then there was a

00:16:04,069 --> 00:16:11,329
special sub method thing well that is a

00:16:07,069 --> 00:16:12,889
method that has an invocate again can be

00:16:11,329 --> 00:16:15,019
the object of the class but it does not

00:16:12,889 --> 00:16:16,939
participate in inheritance and for

00:16:15,019 --> 00:16:18,800
example with build you don't want that

00:16:16,939 --> 00:16:20,899
to participate inheritance in the

00:16:18,800 --> 00:16:23,029
inheritance because the idea is that

00:16:20,899 --> 00:16:24,980
every class in a hierarchy could provide

00:16:23,029 --> 00:16:27,249
its own build you want all of them to be

00:16:24,980 --> 00:16:29,420
callable and if it was participated

00:16:27,249 --> 00:16:31,730
participating in inheritance things

00:16:29,420 --> 00:16:33,980
could get very weird and confusing so

00:16:31,730 --> 00:16:37,240
these are three types of sub routines

00:16:33,980 --> 00:16:37,240
you can define yes question

00:16:38,559 --> 00:16:42,800
what happens if you put a sub in a class

00:16:41,029 --> 00:16:45,889
definition that works fine and you can

00:16:42,800 --> 00:16:47,809
call it as a sub and I believe as long

00:16:45,889 --> 00:16:51,139
as it's not private you could just call

00:16:47,809 --> 00:16:56,149
it externally with : :

00:16:51,139 --> 00:17:00,230
unless it's lexically scoped sorry what

00:16:56,149 --> 00:17:02,449
oh right okay yes you would have to

00:17:00,230 --> 00:17:10,600
declare it as our to make it available

00:17:02,449 --> 00:17:10,600
outside of the class yes

00:17:11,659 --> 00:17:15,029
right right

00:17:13,350 --> 00:17:16,769
so Patrick's like classes are package

00:17:15,029 --> 00:17:19,319
names so when you declare it with our

00:17:16,769 --> 00:17:22,669
when you declare our sub foo then it's

00:17:19,319 --> 00:17:25,259
just part of that package all right

00:17:22,669 --> 00:17:27,809
questioner no just rubbing your nose

00:17:25,259 --> 00:17:29,759
gotcha all right so we've seen several

00:17:27,809 --> 00:17:32,159
forms of method calls you know object

00:17:29,759 --> 00:17:34,710
method and also the the self variation

00:17:32,159 --> 00:17:36,269
again self is just a variable we saw a

00:17:34,710 --> 00:17:38,820
private method calls with self bang

00:17:36,269 --> 00:17:40,590
method and then inside a class we can

00:17:38,820 --> 00:17:43,259
shorten those so we can just use dollar

00:17:40,590 --> 00:17:46,799
instead of self if we want to

00:17:43,259 --> 00:17:49,649
so dollar dot dollar bang that works

00:17:46,799 --> 00:17:51,720
pearl six also has indirect object call

00:17:49,649 --> 00:17:53,909
syntax or sorry indirect method call

00:17:51,720 --> 00:17:56,129
syntax and unlike Pearl five this is not

00:17:53,909 --> 00:17:58,529
a huge disaster that when you use it

00:17:56,129 --> 00:18:00,179
causes the Perl interpreter to go crazy

00:17:58,529 --> 00:18:02,399
trying to figure out what you meant and

00:18:00,179 --> 00:18:04,679
might get it wrong depending on you know

00:18:02,399 --> 00:18:07,950
the phase of the moon in Perl six it's

00:18:04,679 --> 00:18:11,220
very unambiguous great method the infant

00:18:07,950 --> 00:18:13,049
colon and then the argument list and the

00:18:11,220 --> 00:18:15,899
parser knows exactly what you mean so

00:18:13,049 --> 00:18:17,489
it's safe to use you can also write you

00:18:15,899 --> 00:18:19,619
can just lit eliminate the indigent

00:18:17,489 --> 00:18:21,419
entirely in some cases you can write dot

00:18:19,619 --> 00:18:24,570
method and that would call the method on

00:18:21,419 --> 00:18:26,639
dollar underscore so inside this map I

00:18:24,570 --> 00:18:28,559
can write map dot length and it will

00:18:26,639 --> 00:18:31,320
call dot length on each of the elements

00:18:28,559 --> 00:18:32,909
of at strings and turn and the map of

00:18:31,320 --> 00:18:37,470
course returns the result of all that is

00:18:32,909 --> 00:18:39,210
a another array alright so how about

00:18:37,470 --> 00:18:41,369
attributes so this is something again

00:18:39,210 --> 00:18:44,249
you might have seen with mousse works

00:18:41,369 --> 00:18:46,710
very similarly but better in Perl six an

00:18:44,249 --> 00:18:49,289
attribute is just a chunk of data that

00:18:46,710 --> 00:18:52,559
is owned by an object and it's a

00:18:49,289 --> 00:18:54,720
variable of some sort so we declare them

00:18:52,559 --> 00:18:56,879
what has and so in this case we can

00:18:54,720 --> 00:18:59,279
write has dollar dot level and that says

00:18:56,879 --> 00:19:01,169
I have an attribute named level this

00:18:59,279 --> 00:19:04,739
attribute is actually public and I'll

00:19:01,169 --> 00:19:05,970
cover what that means in a second so

00:19:04,739 --> 00:19:08,279
there's a bunch of properties that

00:19:05,970 --> 00:19:09,899
attributes can have they can be required

00:19:08,279 --> 00:19:11,909
or not when you're constructing a new

00:19:09,899 --> 00:19:13,919
object no that says nothing about the

00:19:11,909 --> 00:19:16,139
type it just says that must be passed in

00:19:13,919 --> 00:19:18,450
the argument list if you have default

00:19:16,139 --> 00:19:20,519
values they can be read write or read

00:19:18,450 --> 00:19:21,420
only there can be public and private and

00:19:20,519 --> 00:19:23,250
you can also give

00:19:21,420 --> 00:19:25,020
types again if you're familiar with

00:19:23,250 --> 00:19:35,340
mousse all of those features exist in

00:19:25,020 --> 00:19:37,650
mousse as well yes I will show you how

00:19:35,340 --> 00:19:41,850
to access attributes as we go there's a

00:19:37,650 --> 00:19:56,310
question button oh can you write has

00:19:41,850 --> 00:19:58,590
self I don't think so right yeah you see

00:19:56,310 --> 00:20:00,360
I don't think you would ever could write

00:19:58,590 --> 00:20:03,810
has self dot level as an attribute

00:20:00,360 --> 00:20:07,580
declaration I don't think that's legit

00:20:03,810 --> 00:20:10,830
yes so self is a variable that is

00:20:07,580 --> 00:20:13,740
automatically created for you as part of

00:20:10,830 --> 00:20:23,370
in method definitions it's not available

00:20:13,740 --> 00:20:33,150
inside the class itself oh oh no I'm

00:20:23,370 --> 00:20:36,450
gonna explain what that is yeah it's you

00:20:33,150 --> 00:20:39,960
mean for the defaults yeah and I'll talk

00:20:36,450 --> 00:20:44,910
about how that works as well it's kind

00:20:39,960 --> 00:20:47,100
of a special bit of magic okay so public

00:20:44,910 --> 00:20:49,170
attributes have automatically created

00:20:47,100 --> 00:20:50,610
accessor methods which is what that

00:20:49,170 --> 00:20:53,400
question was getting at so when I write

00:20:50,610 --> 00:20:55,650
has dollar dot level Perl 6 under the

00:20:53,400 --> 00:20:57,900
hood gives me a level method that

00:20:55,650 --> 00:20:59,700
accesses the value of that attribute so

00:20:57,900 --> 00:21:02,130
there are actually two different things

00:20:59,700 --> 00:21:03,600
here dollar dot level and self-doubt

00:21:02,130 --> 00:21:04,770
level they look like they might be the

00:21:03,600 --> 00:21:07,920
same but they're actually different ones

00:21:04,770 --> 00:21:09,600
the accessor for the attribute the

00:21:07,920 --> 00:21:13,620
attribute itself because we wrote dollar

00:21:09,600 --> 00:21:15,870
dot is public so we can access it

00:21:13,620 --> 00:21:18,480
internally with self dot level we can

00:21:15,870 --> 00:21:20,550
also call that level method on an a log

00:21:18,480 --> 00:21:21,560
object that we make and it just works

00:21:20,550 --> 00:21:25,680
either way

00:21:21,560 --> 00:21:27,690
all right so actually boots can also be

00:21:25,680 --> 00:21:30,720
required and we do that by just writing

00:21:27,690 --> 00:21:32,820
is required and all that is saying is

00:21:30,720 --> 00:21:34,350
that when you call the constructor you

00:21:32,820 --> 00:21:37,409
to set that attribute and one thing I

00:21:34,350 --> 00:21:39,299
should mention is that by default the

00:21:37,409 --> 00:21:41,909
constructor is going to expect that you

00:21:39,299 --> 00:21:44,850
passed named arguments okay so and those

00:21:41,909 --> 00:21:46,529
names match the attribute names so we

00:21:44,850 --> 00:21:48,899
have dollar dot level that means it

00:21:46,529 --> 00:21:50,330
expects an attribute named level passed

00:21:48,899 --> 00:21:52,350
through the constructor if you want

00:21:50,330 --> 00:21:55,289
positional parameters there of course

00:21:52,350 --> 00:21:57,120
are ways to do that but by default you

00:21:55,289 --> 00:22:01,100
use named parameters because that is the

00:21:57,120 --> 00:22:03,240
way that deity and Larry intended and

00:22:01,100 --> 00:22:05,059
anyway it's the right way to go makes

00:22:03,240 --> 00:22:09,240
your club your code much more readable

00:22:05,059 --> 00:22:12,899
so log one does not require a level we

00:22:09,240 --> 00:22:14,399
pass it and we're all good log two does

00:22:12,899 --> 00:22:16,110
require a level when we pass it it's

00:22:14,399 --> 00:22:17,759
fine if we don't it'll tell you the

00:22:16,110 --> 00:22:19,679
attribute level is required but you did

00:22:17,759 --> 00:22:22,620
not provide a value you get a nice

00:22:19,679 --> 00:22:27,509
complaint now this of course is at

00:22:22,620 --> 00:22:30,539
runtime all right you can also have

00:22:27,509 --> 00:22:33,779
defaults so you do that by writing has

00:22:30,539 --> 00:22:35,309
attribute equals something and so in

00:22:33,779 --> 00:22:38,519
this case it's really simple just equals

00:22:35,309 --> 00:22:41,549
42 and if we don't set it when we pass

00:22:38,519 --> 00:22:43,649
the constructor and then we spit out the

00:22:41,549 --> 00:22:46,169
value the value is whatever was in our

00:22:43,649 --> 00:22:48,679
default if we do provide it then our

00:22:46,169 --> 00:22:50,789
value takes precedence over the default

00:22:48,679 --> 00:22:52,679
but you can also have more complex

00:22:50,789 --> 00:22:55,230
defaults so somebody was saying hey

00:22:52,679 --> 00:22:57,419
defaults can refer to self so what's

00:22:55,230 --> 00:23:01,769
going on it's actually a bit of magic so

00:22:57,419 --> 00:23:05,190
anything on this right side is not it

00:23:01,769 --> 00:23:06,929
fact of Lee it gets run each time that a

00:23:05,190 --> 00:23:08,580
new object is created and you need to

00:23:06,929 --> 00:23:11,399
access the default so it's all it's like

00:23:08,580 --> 00:23:14,009
a bit of code and it looks like it might

00:23:11,399 --> 00:23:15,809
be something that was executed in the

00:23:14,009 --> 00:23:18,539
scope of the class but in fact it is

00:23:15,809 --> 00:23:22,710
just parsed and then executed on a per

00:23:18,539 --> 00:23:24,330
constructor basis so we're gonna make

00:23:22,710 --> 00:23:26,820
level required in the double level

00:23:24,330 --> 00:23:29,669
defaults to self dot level times two and

00:23:26,820 --> 00:23:32,309
so if we only pass level then double

00:23:29,669 --> 00:23:34,769
level is calculated each time and I did

00:23:32,309 --> 00:23:36,690
it twice just to prove to you that it is

00:23:34,769 --> 00:23:39,029
in fact calculated each time you create

00:23:36,690 --> 00:23:41,149
a new object does that explain the

00:23:39,029 --> 00:23:43,950
question okay cool

00:23:41,149 --> 00:23:46,470
all right so we can also have read-only

00:23:43,950 --> 00:23:48,419
and rewrite now by default after

00:23:46,470 --> 00:23:49,679
be it's a read-only and this only

00:23:48,419 --> 00:23:51,900
applies to the code that lives outside

00:23:49,679 --> 00:23:53,970
the class inside the class you can

00:23:51,900 --> 00:23:56,580
always get at the underlying attribute

00:23:53,970 --> 00:23:58,260
but outside the class you just have this

00:23:56,580 --> 00:24:00,929
accessor method and by default that

00:23:58,260 --> 00:24:03,179
accessor method like log dot level is

00:24:00,929 --> 00:24:05,220
read-only you can't assign to it you

00:24:03,179 --> 00:24:06,929
can't pass any values to it of course if

00:24:05,220 --> 00:24:09,059
you're a terrible terrible person you

00:24:06,929 --> 00:24:11,669
can make your attributes readwrite and

00:24:09,059 --> 00:24:13,919
as I'm trying to say here I think that's

00:24:11,669 --> 00:24:15,780
maybe not such a great idea because

00:24:13,919 --> 00:24:18,179
mutable state is the root of all evil

00:24:15,780 --> 00:24:21,000
but sure let's see an example of what

00:24:18,179 --> 00:24:22,679
this looks like something happened to

00:24:21,000 --> 00:24:25,140
the code when they when I made the

00:24:22,679 --> 00:24:26,909
attribute readwrite actually by the way

00:24:25,140 --> 00:24:29,309
here's a really cool thing about Perl 6

00:24:26,909 --> 00:24:30,900
this code is totally executable I didn't

00:24:29,309 --> 00:24:33,659
like screw it up for the slides this is

00:24:30,900 --> 00:24:37,289
actually example code that's in the repo

00:24:33,659 --> 00:24:39,750
and I ran it to actually get this output

00:24:37,289 --> 00:24:41,730
so Perl 6 has really excellent Unicode

00:24:39,750 --> 00:24:45,299
support so you know if you want us all

00:24:41,730 --> 00:24:49,260
go all your code works great all right

00:24:45,299 --> 00:24:52,559
so good as I said by default attributes

00:24:49,260 --> 00:24:54,659
are read-only so when we have dollar dot

00:24:52,559 --> 00:24:58,980
safe we cannot assign to it but

00:24:54,659 --> 00:25:00,840
unspeakable horror is read right so we

00:24:58,980 --> 00:25:03,870
can set both of these in the constructor

00:25:00,840 --> 00:25:05,940
and then we can set unspeakable horror

00:25:03,870 --> 00:25:08,309
on the object that we get back so that's

00:25:05,940 --> 00:25:11,730
what readwrite means and then if we say

00:25:08,309 --> 00:25:14,159
unspeakable or then it prints out what

00:25:11,730 --> 00:25:17,730
we just sent it to but if I try to get

00:25:14,159 --> 00:25:21,360
set dot safe that is an equal sign it's

00:25:17,730 --> 00:25:24,059
just the zalgo text interfering we get

00:25:21,360 --> 00:25:26,460
an error cannot modify an immutable int

00:25:24,059 --> 00:25:28,770
and it's saying it because that's what

00:25:26,460 --> 00:25:33,360
we set it to here ok so that's really

00:25:28,770 --> 00:25:35,070
versus rewrite and Unicode fun all right

00:25:33,360 --> 00:25:36,480
you can also have private attributes now

00:25:35,070 --> 00:25:38,700
with a private attribute you don't get

00:25:36,480 --> 00:25:40,620
these accessor methods created and of

00:25:38,700 --> 00:25:42,450
course just like with with methods

00:25:40,620 --> 00:25:45,000
private is with the bank so we're as

00:25:42,450 --> 00:25:49,440
dollar bang level private attributes can

00:25:45,000 --> 00:25:51,809
have defaults and just like with public

00:25:49,440 --> 00:25:53,700
attributes and the internally we access

00:25:51,809 --> 00:25:55,860
it just by using this attribute access

00:25:53,700 --> 00:26:00,030
syntax which is dollar dot love dollar

00:25:55,860 --> 00:26:00,419
bang level so internally we can write

00:26:00,030 --> 00:26:02,489
blog

00:26:00,419 --> 00:26:03,929
nice a level and we can get it it in

00:26:02,489 --> 00:26:06,179
this method because we're inside the

00:26:03,929 --> 00:26:08,489
class but if we try to access it outside

00:26:06,179 --> 00:26:10,590
the class then we're gonna get an error

00:26:08,489 --> 00:26:12,869
method level not found for in beginning

00:26:10,590 --> 00:26:14,940
class log so again with public

00:26:12,869 --> 00:26:16,409
attributes what Pearl sex does is create

00:26:14,940 --> 00:26:18,269
the successor method for you

00:26:16,409 --> 00:26:20,369
with private attributes because you have

00:26:18,269 --> 00:26:23,359
no accessor method there is no way to

00:26:20,369 --> 00:26:26,129
get it the value outside of the class

00:26:23,359 --> 00:26:29,489
so I mentioned much earlier that you can

00:26:26,129 --> 00:26:32,220
use build to set private attributes with

00:26:29,489 --> 00:26:34,109
a constructor so this is a pattern that

00:26:32,220 --> 00:26:36,539
I at least find myself using alot with

00:26:34,109 --> 00:26:38,789
moose code and with some perl 6 code

00:26:36,539 --> 00:26:40,710
I've written where I want an attribute

00:26:38,789 --> 00:26:43,019
to be private but I want to be able to

00:26:40,710 --> 00:26:45,299
set it at the constructor time so I want

00:26:43,019 --> 00:26:46,529
call it a being able to pass it in but

00:26:45,299 --> 00:26:48,299
they don't really need to access it

00:26:46,529 --> 00:26:51,779
later so how do you do that

00:26:48,299 --> 00:26:55,940
so we declare our attributes and then in

00:26:51,779 --> 00:26:58,230
build we refer to our attributes by name

00:26:55,940 --> 00:27:00,480
these are named parameters because they

00:26:58,230 --> 00:27:03,419
have the colon and then we use the

00:27:00,480 --> 00:27:05,129
attribute access access syntax both for

00:27:03,419 --> 00:27:08,190
public and private attributes dollar

00:27:05,129 --> 00:27:09,989
bang and I haven't looked at exactly how

00:27:08,190 --> 00:27:12,389
this implement is implemented but what I

00:27:09,989 --> 00:27:14,129
imagine is happening is you're referring

00:27:12,389 --> 00:27:16,739
to those private attributes in the

00:27:14,129 --> 00:27:19,049
subroutine signature what Perl 6 does

00:27:16,739 --> 00:27:21,960
when you call the subroutine as it binds

00:27:19,049 --> 00:27:23,759
the variables referred to to the values

00:27:21,960 --> 00:27:26,070
that it was given and because these

00:27:23,759 --> 00:27:27,989
happen to be references to the

00:27:26,070 --> 00:27:29,700
attributes on the objects it all kind of

00:27:27,989 --> 00:27:32,039
just works we don't actually need a body

00:27:29,700 --> 00:27:36,119
in the sub was my guests at all correct

00:27:32,039 --> 00:27:38,999
I don't know close enough anyway it's a

00:27:36,119 --> 00:27:44,789
really nice feature just just works yes

00:27:38,999 --> 00:27:47,700
question so why am I using the name the

00:27:44,789 --> 00:27:49,799
bang and the name the the reference to

00:27:47,700 --> 00:27:51,840
dollar dot name because dollar got name

00:27:49,799 --> 00:27:53,669
is a public attribute if I want to set

00:27:51,840 --> 00:27:55,980
the value I have to refer to the

00:27:53,669 --> 00:27:58,049
attribute not the method in the

00:27:55,980 --> 00:27:58,739
subroutine signature does that make

00:27:58,049 --> 00:28:01,379
sense

00:27:58,739 --> 00:28:04,440
so to refer to it the attribute directly

00:28:01,379 --> 00:28:07,470
rather than the method the accessor

00:28:04,440 --> 00:28:10,669
method we can still use dollar bang even

00:28:07,470 --> 00:28:10,669
for public attributes

00:28:11,590 --> 00:28:16,269
it's it's a very subtle distinction that

00:28:13,659 --> 00:28:17,860
I think if you play with some code might

00:28:16,269 --> 00:28:18,549
become more clear but it's maybe hard

00:28:17,860 --> 00:28:26,590
for me explain

00:28:18,549 --> 00:28:28,240
but Patrick can explain it okay so what

00:28:26,590 --> 00:28:31,179
patrick said is attributes are always

00:28:28,240 --> 00:28:33,610
dollar bang that's the attribute syntax

00:28:31,179 --> 00:28:35,230
but if you use dollar dot when you

00:28:33,610 --> 00:28:38,370
declare the attribute you'll also get

00:28:35,230 --> 00:28:42,039
the accessor method to refer to it

00:28:38,370 --> 00:28:43,990
all right now so far all my examples of

00:28:42,039 --> 00:28:46,119
attributes have been scalars doesn't

00:28:43,990 --> 00:28:48,639
have to be that way we can use arrays we

00:28:46,119 --> 00:28:50,619
can use hashes and we can use that in

00:28:48,639 --> 00:28:53,049
the declaration second syntax so I can

00:28:50,619 --> 00:28:56,200
say has at bang messages and now I have

00:28:53,049 --> 00:28:57,909
an attribute that is an array and I can

00:28:56,200 --> 00:29:00,129
access them internally the same way so

00:28:57,909 --> 00:29:03,490
instead of dollar bang I use at bang I

00:29:00,129 --> 00:29:05,710
can push on to that array and then I can

00:29:03,490 --> 00:29:07,749
access it here and the spew method so

00:29:05,710 --> 00:29:09,789
every time I call log it's adding

00:29:07,749 --> 00:29:11,889
something to dollar bank messages when

00:29:09,789 --> 00:29:21,850
it calls phew it spits it out just works

00:29:11,889 --> 00:29:24,970
question so the question was within my

00:29:21,850 --> 00:29:26,619
methods I'm using the bang syntax as

00:29:24,970 --> 00:29:28,419
opposed to the dot syntax and is one

00:29:26,619 --> 00:29:30,639
preferred well in this case it's a

00:29:28,419 --> 00:29:32,950
private attribute so there is no

00:29:30,639 --> 00:29:35,080
accessor method I could not write self

00:29:32,950 --> 00:29:37,990
dot messages because it doesn't exist if

00:29:35,080 --> 00:29:40,389
it was a public attribute and it was

00:29:37,990 --> 00:29:42,850
read-only a readwrite I believe I could

00:29:40,389 --> 00:29:48,429
assign to it directly although in this

00:29:42,850 --> 00:29:50,200
case I'm gonna push I like to use yeah

00:29:48,429 --> 00:29:52,389
I'd like to refer to the attributes

00:29:50,200 --> 00:29:54,490
using the attribute syntax inside my

00:29:52,389 --> 00:29:56,649
classes with the theory that the

00:29:54,490 --> 00:30:00,580
accessor czar really for consumers of my

00:29:56,649 --> 00:30:03,369
classes all right and we can also have

00:30:00,580 --> 00:30:05,440
types on attributes really simple we

00:30:03,369 --> 00:30:07,480
were it has and then the type and then

00:30:05,440 --> 00:30:09,909
any other attribute declaration stuff we

00:30:07,480 --> 00:30:13,600
want could have required defaults all

00:30:09,909 --> 00:30:15,820
that good stuff and so that works as we

00:30:13,600 --> 00:30:18,369
would hope we pass levels 42

00:30:15,820 --> 00:30:20,049
everything's happy we pass a string and

00:30:18,369 --> 00:30:22,629
it says type check failed and assignment

00:30:20,049 --> 00:30:25,090
to level expected int but got stir it's

00:30:22,629 --> 00:30:25,360
great gradual typing you can type as

00:30:25,090 --> 00:30:28,330
much

00:30:25,360 --> 00:30:30,340
or as little as you want I like to put

00:30:28,330 --> 00:30:35,710
types on everything because I'm just I

00:30:30,340 --> 00:30:37,750
don't know a bit of a you know uptight

00:30:35,710 --> 00:30:39,340
programmer so I was looking for a word

00:30:37,750 --> 00:30:40,720
that wasn't you know at all offensive I

00:30:39,340 --> 00:30:42,340
think I'm tight is the good word for

00:30:40,720 --> 00:30:44,770
this so I like to put types on

00:30:42,340 --> 00:30:47,080
everything if you're one of those you

00:30:44,770 --> 00:30:48,760
know carefree hair blowing in the wind

00:30:47,080 --> 00:30:54,090
type programmers maybe you don't want to

00:30:48,760 --> 00:30:58,030
type stuff up to you all right so it's

00:30:54,090 --> 00:30:59,980
11:35 and I have till 11:50 okay so I

00:30:58,030 --> 00:31:01,540
have some more slides that I could go to

00:30:59,980 --> 00:31:03,160
but if people have like tons of

00:31:01,540 --> 00:31:06,190
questions maybe there would be a

00:31:03,160 --> 00:31:07,450
preference for that I'll take a few

00:31:06,190 --> 00:31:18,990
questions and then we'll see how it goes

00:31:07,450 --> 00:31:18,990
yeah in the back are you asking because

00:31:23,490 --> 00:31:27,280
you're asking classes questions about

00:31:25,870 --> 00:31:30,400
roles which are what the bonus slides

00:31:27,280 --> 00:31:39,700
are just do that do you have another

00:31:30,400 --> 00:31:40,150
question first how do you alright let's

00:31:39,700 --> 00:31:41,590
roll

00:31:40,150 --> 00:31:43,179
I couldn't just do the roll slides

00:31:41,590 --> 00:31:46,000
clearly that's what we need to talk

00:31:43,179 --> 00:31:47,919
about all right let's talk about rolls

00:31:46,000 --> 00:31:50,820
since I just got two questions that will

00:31:47,919 --> 00:31:53,169
be answered by rolls alright so roll is

00:31:50,820 --> 00:31:55,470
code that's consumed by one or more

00:31:53,169 --> 00:31:57,640
classes it's basically some shared code

00:31:55,470 --> 00:31:59,169
and it can be a bunch of things so it

00:31:57,640 --> 00:32:01,150
can be an interface definition which

00:31:59,169 --> 00:32:03,970
somebody was just asking about it can

00:32:01,150 --> 00:32:06,760
also contain a partial implementation of

00:32:03,970 --> 00:32:09,429
that interface working name a complete

00:32:06,760 --> 00:32:10,620
implementation and by implementation

00:32:09,429 --> 00:32:14,470
everything mean attributes and methods

00:32:10,620 --> 00:32:17,020
so rolls just like classes have a key

00:32:14,470 --> 00:32:19,179
word you'll be shocked to hear that the

00:32:17,020 --> 00:32:21,100
key word is roll instead of class so we

00:32:19,179 --> 00:32:22,660
write roll the name and then curly

00:32:21,100 --> 00:32:26,770
braces and we can put stuff in it like

00:32:22,660 --> 00:32:29,110
methods and attributes so and then to

00:32:26,770 --> 00:32:31,950
consumer roll we write class name does

00:32:29,110 --> 00:32:34,980
that that roll so class dog does logs

00:32:31,950 --> 00:32:38,200
this is the dr. Sears portion of the

00:32:34,980 --> 00:32:39,130
presentation and so when we create a new

00:32:38,200 --> 00:32:40,840
dog

00:32:39,130 --> 00:32:43,539
we get all the methods that were in logs

00:32:40,840 --> 00:32:46,390
because it consumes that role so we can

00:32:43,539 --> 00:32:48,520
write dot log pass it stuff and then dog

00:32:46,390 --> 00:32:53,110
bark we also get the method from inside

00:32:48,520 --> 00:32:54,970
class so as I said when a class consumes

00:32:53,110 --> 00:32:56,770
a role it gets everything from that role

00:32:54,970 --> 00:32:59,830
all the methods all the attributes and

00:32:56,770 --> 00:33:02,260
roles can also consume roles so if our

00:32:59,830 --> 00:33:07,059
logs were all consumed some other role

00:33:02,260 --> 00:33:08,620
called I don't know system logger or

00:33:07,059 --> 00:33:10,059
something like that then all the methods

00:33:08,620 --> 00:33:12,700
that were in the system larger role

00:33:10,059 --> 00:33:15,309
would also be provided to the class now

00:33:12,700 --> 00:33:16,690
if there's an a class can consume

00:33:15,309 --> 00:33:18,429
multiple roles and get all the stuff

00:33:16,690 --> 00:33:20,020
from all those roles in that case

00:33:18,429 --> 00:33:22,090
there's also some conflict checking

00:33:20,020 --> 00:33:24,190
because if you consume multiple roles

00:33:22,090 --> 00:33:25,450
and have methods of the same name that's

00:33:24,190 --> 00:33:28,840
a problem you got to figure out how to

00:33:25,450 --> 00:33:30,549
deal with that so roles can also require

00:33:28,840 --> 00:33:32,770
methods so this is a way that they can

00:33:30,549 --> 00:33:36,159
act as an incomplete definition or just

00:33:32,770 --> 00:33:37,840
an interface definition and it's really

00:33:36,159 --> 00:33:40,090
simple to do that we define the method

00:33:37,840 --> 00:33:42,190
with potentially an optional signature

00:33:40,090 --> 00:33:44,830
and then the body of the method is just

00:33:42,190 --> 00:33:49,679
dot dot dot or is it so yada yada yada

00:33:44,830 --> 00:33:53,799
and pro just yadda yadda yadda in perl 6

00:33:49,679 --> 00:33:56,860
ok I'm not drunk so I'm just high on

00:33:53,799 --> 00:33:58,779
life all right so he put that I got a

00:33:56,860 --> 00:34:00,549
Yatta Yatta in there and that becomes a

00:33:58,779 --> 00:34:02,470
required method now if our class

00:34:00,549 --> 00:34:04,840
consumes the role and does not implement

00:34:02,470 --> 00:34:07,450
the required method we get a nice error

00:34:04,840 --> 00:34:09,700
at compile time method luggable string

00:34:07,450 --> 00:34:12,099
must be implemented by dog because it is

00:34:09,700 --> 00:34:13,570
required by a role why does in the same

00:34:12,099 --> 00:34:15,129
what role it's required by I thought the

00:34:13,570 --> 00:34:16,990
error message was we're supposed to be

00:34:15,129 --> 00:34:17,440
awesome this is slightly less than

00:34:16,990 --> 00:34:20,500
awesome

00:34:17,440 --> 00:34:22,659
I mean it's reasonably awesome it's

00:34:20,500 --> 00:34:23,200
close to awesome anyway it's still

00:34:22,659 --> 00:34:26,280
pretty good

00:34:23,200 --> 00:34:26,280
yes question

00:34:30,290 --> 00:34:35,179
so the question was this doesn't have

00:34:32,270 --> 00:34:37,070
the parameter any parameters for the

00:34:35,179 --> 00:34:38,919
method that's required if it did would

00:34:37,070 --> 00:34:41,810
that be in forest yes methods are

00:34:38,919 --> 00:34:44,419
identified by name and parameters and in

00:34:41,810 --> 00:34:46,190
fact as I mentioned alluded to Perl has

00:34:44,419 --> 00:34:48,020
multi methods so you could even have

00:34:46,190 --> 00:34:49,220
multiple methods of the same name with

00:34:48,020 --> 00:34:51,280
different parameters that are all

00:34:49,220 --> 00:34:53,480
required by a role and that just works I

00:34:51,280 --> 00:34:55,340
think it just works there was one point

00:34:53,480 --> 00:34:56,630
there was a bug related to this it

00:34:55,340 --> 00:34:58,010
should just work it's definitely

00:34:56,630 --> 00:35:02,510
intended to work it's probably fixed by

00:34:58,010 --> 00:35:05,690
now all right so now why don't we

00:35:02,510 --> 00:35:08,000
implement that method so if we implement

00:35:05,690 --> 00:35:10,040
it then we won't have any problems and

00:35:08,000 --> 00:35:12,140
then if we call log self which comes

00:35:10,040 --> 00:35:12,980
from the role and expects this luggable

00:35:12,140 --> 00:35:15,110
string method

00:35:12,980 --> 00:35:17,780
well we implemented the lockable string

00:35:15,110 --> 00:35:19,760
method and it all just works so this is

00:35:17,780 --> 00:35:21,770
how roles can provide an interface

00:35:19,760 --> 00:35:24,110
definition but kind of force the class

00:35:21,770 --> 00:35:25,910
to implement some of that interface or

00:35:24,110 --> 00:35:28,190
all of it you could have a role that

00:35:25,910 --> 00:35:31,100
consisted entirely of required methods

00:35:28,190 --> 00:35:35,630
with actually no implementation of its

00:35:31,100 --> 00:35:38,090
own and that's perfectly fine too so

00:35:35,630 --> 00:35:40,430
rules just like classes can be used as

00:35:38,090 --> 00:35:42,770
types and you can use them anywhere you

00:35:40,430 --> 00:35:46,610
would reference a class in the type of

00:35:42,770 --> 00:35:49,550
digne Chur so you we saw before like has

00:35:46,610 --> 00:35:51,500
int dollar dot level well

00:35:49,550 --> 00:35:53,510
ant is a class name we could also use a

00:35:51,500 --> 00:35:58,670
roll name it says i just want an object

00:35:53,510 --> 00:36:01,190
which does this role so here's an

00:35:58,670 --> 00:36:02,810
example so we have our role logs that

00:36:01,190 --> 00:36:04,880
we've seen before our class dog which

00:36:02,810 --> 00:36:07,430
does logs and then we have a synonym

00:36:04,880 --> 00:36:09,470
subroutine and now we're typing the

00:36:07,430 --> 00:36:12,080
argument so we say we want something in

00:36:09,470 --> 00:36:14,000
dollar thing that does the logs role I

00:36:12,080 --> 00:36:15,770
don't care what class it is I just

00:36:14,000 --> 00:36:18,020
wanted to do the role the reason you do

00:36:15,770 --> 00:36:19,940
that is you just want something that has

00:36:18,020 --> 00:36:21,830
a particular method that you're gonna

00:36:19,940 --> 00:36:23,240
call in this case we want log self

00:36:21,830 --> 00:36:26,600
because we're gonna call it inside our

00:36:23,240 --> 00:36:28,970
subroutine so we've passed it a dog and

00:36:26,600 --> 00:36:32,420
it just does its thing it spits out

00:36:28,970 --> 00:36:34,040
whatever log self does and then we try

00:36:32,420 --> 00:36:35,300
calling it with dollar X which happens

00:36:34,040 --> 00:36:39,470
to contain an integer

00:36:35,300 --> 00:36:40,970
well integers do not do the logs roll so

00:36:39,470 --> 00:36:42,510
we're going to get type check failed and

00:36:40,970 --> 00:36:44,430
binding thing expected log

00:36:42,510 --> 00:36:48,390
but got an int and it actually tells you

00:36:44,430 --> 00:36:50,700
the value so again it's a very useful

00:36:48,390 --> 00:36:52,730
thing to have roles for these type

00:36:50,700 --> 00:36:55,380
signatures and in fact a lot of the core

00:36:52,730 --> 00:36:58,230
uses roles and you can reference core

00:36:55,380 --> 00:37:00,270
roles instead of core classes and many

00:36:58,230 --> 00:37:02,970
uses for example there is a straight row

00:37:00,270 --> 00:37:04,680
for things that act like strings that

00:37:02,970 --> 00:37:06,300
you can use if you just want something

00:37:04,680 --> 00:37:09,230
that implements that interface as

00:37:06,300 --> 00:37:13,590
opposed to it must be a concrete string

00:37:09,230 --> 00:37:15,330
so Perl six also has some features that

00:37:13,590 --> 00:37:17,010
I'm not going to really explain other

00:37:15,330 --> 00:37:19,470
than to say that they exist because

00:37:17,010 --> 00:37:21,630
they're really cool so there's all this

00:37:19,470 --> 00:37:24,630
meta stuff you can do which is basically

00:37:21,630 --> 00:37:26,760
means you can use Perl 6 to change how

00:37:24,630 --> 00:37:29,490
Perl 6 works and this applies to many

00:37:26,760 --> 00:37:32,340
aspects of Perl 6 but one thing you can

00:37:29,490 --> 00:37:35,010
do is change how the OO stuff works and

00:37:32,340 --> 00:37:39,060
this is a really simple example where

00:37:35,010 --> 00:37:42,180
for example we can apply a trait that we

00:37:39,060 --> 00:37:44,670
define here to a method and the trait is

00:37:42,180 --> 00:37:47,430
annoying and what happens is every time

00:37:44,670 --> 00:37:49,830
we call it this method there's a wrapper

00:37:47,430 --> 00:37:51,780
that we wrap the method with that the

00:37:49,830 --> 00:37:53,910
trait does and it wraps it and says

00:37:51,780 --> 00:37:56,190
thank you for calling method which would

00:37:53,910 --> 00:37:56,730
be pretty damn irritating so I say it's

00:37:56,190 --> 00:38:00,270
annoying

00:37:56,730 --> 00:38:01,920
so then we apply it with is annoying dog

00:38:00,270 --> 00:38:04,230
new bark and it says thank you for

00:38:01,920 --> 00:38:09,740
calling bark and then it actually gets

00:38:04,230 --> 00:38:14,310
to the method that we wrapped yes yes oh

00:38:09,740 --> 00:38:16,350
yeah sorry about that call same inside a

00:38:14,310 --> 00:38:18,420
wrapper just says call the method that

00:38:16,350 --> 00:38:19,710
I'm wrapping or if there were multiple

00:38:18,420 --> 00:38:23,880
wrappers that would call the next

00:38:19,710 --> 00:38:26,070
wrapper so this is one very very simple

00:38:23,880 --> 00:38:29,280
example of how you can use some meta

00:38:26,070 --> 00:38:31,080
type stuff to mess with how classes work

00:38:29,280 --> 00:38:32,940
but you can go way way further and I was

00:38:31,080 --> 00:38:34,770
going to try to show an example but like

00:38:32,940 --> 00:38:36,000
it's really hard to show an example that

00:38:34,770 --> 00:38:37,080
would fit on the slide because it ends

00:38:36,000 --> 00:38:40,740
up being a little complex but

00:38:37,080 --> 00:38:43,110
essentially you can do things like the

00:38:40,740 --> 00:38:45,810
way purl 600 works is there's this stage

00:38:43,110 --> 00:38:48,420
called composition where which is kind

00:38:45,810 --> 00:38:50,040
of putting the class together and it's

00:38:48,420 --> 00:38:51,300
where the attributes are applied and the

00:38:50,040 --> 00:38:53,370
methods are applied and the roles are

00:38:51,300 --> 00:38:56,520
applied and you can actually hook in

00:38:53,370 --> 00:38:57,930
to that and say when an attribute is

00:38:56,520 --> 00:39:00,330
applied I want you to do this other

00:38:57,930 --> 00:39:02,700
thing so for example if you wanted to

00:39:00,330 --> 00:39:05,400
create differently named accessor

00:39:02,700 --> 00:39:08,670
methods for your attributes you could

00:39:05,400 --> 00:39:10,920
hook into that composition stage and say

00:39:08,670 --> 00:39:13,620
okay don't use the default names use the

00:39:10,920 --> 00:39:15,450
names that I'm gonna come up with or you

00:39:13,620 --> 00:39:17,220
know I want you to create an extra set

00:39:15,450 --> 00:39:19,620
of methods to go with my attributes that

00:39:17,220 --> 00:39:21,030
do something else like maybe you want

00:39:19,620 --> 00:39:22,830
you have an integer

00:39:21,030 --> 00:39:24,330
attribute you wanted to create increment

00:39:22,830 --> 00:39:26,880
and decrement methods you could do that

00:39:24,330 --> 00:39:28,980
so a lot of really crazy powerful stuff

00:39:26,880 --> 00:39:30,960
you can do and if you've ever looked at

00:39:28,980 --> 00:39:32,790
some of what some of the Moose X modules

00:39:30,960 --> 00:39:34,890
do where they hook into mooses metal

00:39:32,790 --> 00:39:36,810
layer it's really the same type of thing

00:39:34,890 --> 00:39:39,420
but again this is all built into the

00:39:36,810 --> 00:39:41,730
language so it's really nice now that

00:39:39,420 --> 00:39:44,250
all said this is one area of the

00:39:41,730 --> 00:39:45,990
language which could use you know slight

00:39:44,250 --> 00:39:47,130
improvement to the documentation and by

00:39:45,990 --> 00:39:50,130
a slight improvement I mean

00:39:47,130 --> 00:39:52,470
documentation because as far as I can

00:39:50,130 --> 00:39:54,600
tell there isn't really any yet what you

00:39:52,470 --> 00:39:56,580
can't do and again one of the great

00:39:54,600 --> 00:39:58,560
things about Perl 6 being written Perl 6

00:39:56,580 --> 00:40:00,120
you can actually just go read the Perl 6

00:39:58,560 --> 00:40:02,310
code to see how this stuff works

00:40:00,120 --> 00:40:05,280
and because it's Perl 6 and not

00:40:02,310 --> 00:40:07,080
gobbledygook see full of macros that

00:40:05,280 --> 00:40:07,740
makes you what you know makes you go all

00:40:07,080 --> 00:40:10,500
Zhou go

00:40:07,740 --> 00:40:12,360
it's actually pretty easy to figure out

00:40:10,500 --> 00:40:14,430
ok pretty easy it's still pretty

00:40:12,360 --> 00:40:16,080
complicated but at least it's Perl 6 and

00:40:14,430 --> 00:40:17,130
it's a lot more amenable to just reading

00:40:16,080 --> 00:40:20,340
through it and see how it goes

00:40:17,130 --> 00:40:23,220
there are also modules on the modules

00:40:20,340 --> 00:40:25,020
Perl 6 or esight that do some of this

00:40:23,220 --> 00:40:25,980
stuff which is you know when I was

00:40:25,020 --> 00:40:28,050
trying to figure something out I'm just

00:40:25,980 --> 00:40:30,030
like yeah I'll just copy this chunk of

00:40:28,050 --> 00:40:31,860
code and then tweak it a little see how

00:40:30,030 --> 00:40:33,540
it works so you know there there is

00:40:31,860 --> 00:40:34,920
documentation of a sort but I do look

00:40:33,540 --> 00:40:39,510
forward to this all being fully

00:40:34,920 --> 00:40:40,860
documented in the future all right so

00:40:39,510 --> 00:40:45,980
yeah I kind of covered this out and you

00:40:40,860 --> 00:40:45,980
know meta can really do anything yeah

00:40:57,740 --> 00:41:05,270
so the question was as far as the type

00:41:00,690 --> 00:41:07,980
eroge goes are the attributes in a class

00:41:05,270 --> 00:41:11,130
kind of type to the top-level type yeah

00:41:07,980 --> 00:41:13,349
effectively so there's this top level I

00:41:11,130 --> 00:41:18,210
think the top level type is mu right

00:41:13,349 --> 00:41:20,310
okay so it's mu and everything that

00:41:18,210 --> 00:41:25,410
doesn't have a type is I think going to

00:41:20,310 --> 00:41:27,960
be the type signature is of that type

00:41:25,410 --> 00:41:30,240
like it'll accept anything but when you

00:41:27,960 --> 00:41:33,780
actually pass a value for the attribute

00:41:30,240 --> 00:41:35,760
like if you pass 42 but you know pearl

00:41:33,780 --> 00:41:37,320
knows that 42 is an integer so it's

00:41:35,760 --> 00:41:39,690
going to end up containing an integer

00:41:37,320 --> 00:41:42,330
but the type signature is effectively mu

00:41:39,690 --> 00:41:46,910
but I don't know if it actually does any

00:41:42,330 --> 00:41:46,910
sort of checking that something is mu

00:41:52,190 --> 00:41:56,580
okay okay so yeah there's two there's

00:41:55,109 --> 00:41:59,250
two different types of uses the default

00:41:56,580 --> 00:42:01,260
type for variables and attributes is mu

00:41:59,250 --> 00:42:02,970
and then for parameters that's any both

00:42:01,260 --> 00:42:05,660
of which I think will accept basically

00:42:02,970 --> 00:42:05,660
anything you Bassett

00:42:20,930 --> 00:42:24,360
okay so the question I'm gonna repeat

00:42:23,100 --> 00:42:27,300
everything just so it ends up in the

00:42:24,360 --> 00:42:29,730
video the question was is there a way to

00:42:27,300 --> 00:42:31,950
do deep comparison that's built into the

00:42:29,730 --> 00:42:43,110
language at the top level type and the

00:42:31,950 --> 00:42:45,450
answer was yes there's several different

00:42:43,110 --> 00:42:59,640
equality operators but I believe there

00:42:45,450 --> 00:43:00,870
isn't it what is eqv yes so the answer

00:42:59,640 --> 00:43:03,360
was there's a lot of different ways to

00:43:00,870 --> 00:43:05,250
test equivalence of object contents or

00:43:03,360 --> 00:43:08,460
reference or alias all that sort of

00:43:05,250 --> 00:43:10,080
stuff so yeah the answer generally I

00:43:08,460 --> 00:43:11,790
find with the answer apparel sexes is

00:43:10,080 --> 00:43:15,840
there a thing yes yes there's the thing

00:43:11,790 --> 00:43:22,560
inferences is there a kitchen sink

00:43:15,840 --> 00:43:26,070
there's - yes and there is in fact a

00:43:22,560 --> 00:43:29,100
sink there's a sink class or a roll

00:43:26,070 --> 00:43:40,950
can't remember what was the other next

00:43:29,100 --> 00:43:44,850
question index what here okay yeah this

00:43:40,950 --> 00:43:45,840
is just some references to Doc's and

00:43:44,850 --> 00:43:47,460
like I said there's not a lot of

00:43:45,840 --> 00:43:48,980
documentation about the meta stuff but

00:43:47,460 --> 00:43:52,700
you can just dig through it and really

00:43:48,980 --> 00:43:52,700
get a sense of how it works

00:44:00,089 --> 00:44:04,329
yeah so David suggested that if you want

00:44:02,530 --> 00:44:05,770
to get involved in Perl 6 great way to

00:44:04,329 --> 00:44:08,470
do that is to find something that's not

00:44:05,770 --> 00:44:10,660
documented yet and document it also I

00:44:08,470 --> 00:44:12,490
forgot to mention here that actually my

00:44:10,660 --> 00:44:14,260
favorite resource is just bugging people

00:44:12,490 --> 00:44:16,660
in the Perl 6 IRC channel saying hey how

00:44:14,260 --> 00:44:18,010
does this work there's no dogs and just

00:44:16,660 --> 00:44:23,230
wide a little line I hope that somebody

00:44:18,010 --> 00:44:24,640
will graciously help me but yes yes and

00:44:23,230 --> 00:44:26,680
it's busy yeah if you want to document

00:44:24,640 --> 00:44:28,150
something asking on IRC like how does

00:44:26,680 --> 00:44:29,349
this work getting somebody explained to

00:44:28,150 --> 00:44:40,900
you and then you write it up this really

00:44:29,349 --> 00:44:43,119
nice thing to do yeah yeah yeah no I see

00:44:40,900 --> 00:44:44,410
I I see lots of activity but there's

00:44:43,119 --> 00:44:47,380
still not as far as I know any

00:44:44,410 --> 00:44:53,020
meta-level dogs other questions we still

00:44:47,380 --> 00:44:55,960
have like one minute yes how about the

00:44:53,020 --> 00:44:59,109
nasty bits like it down okay questions

00:44:55,960 --> 00:45:01,240
generally end with a question mark again

00:44:59,109 --> 00:45:04,530
I suppose how is the question but that

00:45:01,240 --> 00:45:04,530
wasn't it okay what's the full question

00:45:12,160 --> 00:45:18,950
you can okay so there are ways to define

00:45:15,530 --> 00:45:20,810
coercion so the question is basically me

00:45:18,950 --> 00:45:22,700
rephrase the question which is how do

00:45:20,810 --> 00:45:25,040
you course things between different

00:45:22,700 --> 00:45:27,170
classes and a specific question is

00:45:25,040 --> 00:45:29,840
between a superclass in its child class

00:45:27,170 --> 00:45:33,050
so there are there are facilities for

00:45:29,840 --> 00:45:34,600
defining coercion x' and then for asking

00:45:33,050 --> 00:45:38,420
for something to be coerced in

00:45:34,600 --> 00:45:40,280
signatures and i see no reason you

00:45:38,420 --> 00:45:44,720
couldn't coerce from a parent class to a

00:45:40,280 --> 00:45:46,910
child class if you're insane that seems

00:45:44,720 --> 00:45:48,500
a little weird to want to do that since

00:45:46,910 --> 00:45:51,710
it in theory parent classes should not

00:45:48,500 --> 00:45:54,680
know about their children but you get

00:45:51,710 --> 00:45:57,290
I'm sure you could do it because again

00:45:54,680 --> 00:45:58,070
six you can there's the answer is

00:45:57,290 --> 00:46:03,320
generally yes

00:45:58,070 --> 00:46:04,750
other questions all right I will be here

00:46:03,320 --> 00:46:07,760
the rest of the conference although

00:46:04,750 --> 00:46:10,210
really the people to ask are sitting out

00:46:07,760 --> 00:46:12,230
in the audience Patrick Larry and

00:46:10,210 --> 00:46:13,550
they're very nice people and probably

00:46:12,230 --> 00:46:14,840
know a lot more about this stuff than I

00:46:13,550 --> 00:46:19,570
do but I'm still happy to try to answer

00:46:14,840 --> 00:46:19,570

YouTube URL: https://www.youtube.com/watch?v=7mkmZVIizFY


