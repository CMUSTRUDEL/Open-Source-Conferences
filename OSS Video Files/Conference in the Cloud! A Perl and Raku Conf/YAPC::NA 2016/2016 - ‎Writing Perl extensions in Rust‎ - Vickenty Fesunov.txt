Title: 2016 - ‎Writing Perl extensions in Rust‎ - Vickenty Fesunov
Publication date: 2016-06-27
Playlist: YAPC::NA 2016
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:06,150
right hello my name is vacanti fasten

00:00:04,259 --> 00:00:08,400
off and i right girl code for working

00:00:06,150 --> 00:00:11,130
calm if you haven't heard we're hiring

00:00:08,400 --> 00:00:14,040
so if you're in a market for a job come

00:00:11,130 --> 00:00:15,870
talk to us but this is not about my work

00:00:14,040 --> 00:00:18,210
in booking this is about something

00:00:15,870 --> 00:00:19,830
completely unrelated it's about this new

00:00:18,210 --> 00:00:24,900
shiny programming language called rust

00:00:19,830 --> 00:00:26,760
and how it can work with pearl so Perl

00:00:24,900 --> 00:00:30,029
interpreter itself is a written in seas

00:00:26,760 --> 00:00:32,489
probably know and naturally this makes

00:00:30,029 --> 00:00:35,340
it great choice writing pearl extensions

00:00:32,489 --> 00:00:36,660
as well see is a great language very

00:00:35,340 --> 00:00:39,239
powerful but with great power comes

00:00:36,660 --> 00:00:42,360
great responsibility where Pearl has

00:00:39,239 --> 00:00:44,969
runtime checks to make sure everything

00:00:42,360 --> 00:00:47,809
goes alright see just assumes programmer

00:00:44,969 --> 00:00:50,850
follows the rules and continues for

00:00:47,809 --> 00:00:53,820
example when see when you've the

00:00:50,850 --> 00:00:55,680
reference a value in pearl pearl checks

00:00:53,820 --> 00:00:58,920
that it is defined and points to a

00:00:55,680 --> 00:01:01,829
valuable variable and generates a

00:00:58,920 --> 00:01:03,750
runtime error if it don't see just c

00:01:01,829 --> 00:01:05,430
compiler just okay it will be fine when

00:01:03,750 --> 00:01:07,200
program runs if it doesn't well

00:01:05,430 --> 00:01:10,799
something happens but it doesn't tell

00:01:07,200 --> 00:01:13,380
you what and this is a lot of this stuff

00:01:10,799 --> 00:01:15,869
in excess as well so a lot of functions

00:01:13,380 --> 00:01:19,290
return null pointers the referencing a

00:01:15,869 --> 00:01:21,780
null pointer or passing it to a perl

00:01:19,290 --> 00:01:23,280
function is not good so programmers must

00:01:21,780 --> 00:01:27,119
be very diligent and check everything

00:01:23,280 --> 00:01:30,479
before using c doesn't have reference

00:01:27,119 --> 00:01:32,729
counting unlike pearl so programmers

00:01:30,479 --> 00:01:34,229
must be really diligent and drag every

00:01:32,729 --> 00:01:36,689
memory location they have a point or two

00:01:34,229 --> 00:01:40,020
and make sure it it is points to a valid

00:01:36,689 --> 00:01:42,270
location and there is no way around to

00:01:40,020 --> 00:01:45,390
check this at runtime actually duty have

00:01:42,270 --> 00:01:48,869
to be very careful about are you also

00:01:45,390 --> 00:01:51,060
have to track keep track of size of

00:01:48,869 --> 00:01:53,579
every memory allocation you have pointer

00:01:51,060 --> 00:01:55,320
to otherwise you risk writing past and

00:01:53,579 --> 00:01:58,079
the end of it and other writing

00:01:55,320 --> 00:01:59,490
something you don't expect and crashing

00:01:58,079 --> 00:02:02,219
the program five minutes later Bernie

00:01:59,490 --> 00:02:04,920
code finished running and there is a lot

00:02:02,219 --> 00:02:07,350
of loss of lots of these rules the list

00:02:04,920 --> 00:02:10,910
of these rules in the status language

00:02:07,350 --> 00:02:14,640
standard takes 15 pages it's a lot

00:02:10,910 --> 00:02:16,980
so I'm not trying to say let's see XS or

00:02:14,640 --> 00:02:19,260
coral itself is wrong or bad it just

00:02:16,980 --> 00:02:21,959
there is a lot to worry about in writing

00:02:19,260 --> 00:02:23,489
see and these bugs are not just crash

00:02:21,959 --> 00:02:26,910
your program sometimes they cause

00:02:23,489 --> 00:02:29,130
serious security vulnerabilities so we

00:02:26,910 --> 00:02:31,470
just have to be very very careful and

00:02:29,130 --> 00:02:32,940
pearl itself doesn't make things easier

00:02:31,470 --> 00:02:40,019
what does this function return what do

00:02:32,940 --> 00:02:42,180
you think yes it falls length but it

00:02:40,019 --> 00:02:47,370
returns index of the last element of the

00:02:42,180 --> 00:02:49,080
array Pearl has a reference counting but

00:02:47,370 --> 00:02:52,920
it doesn't count or account every

00:02:49,080 --> 00:02:56,970
pointer as a reference to be to be fast

00:02:52,920 --> 00:02:59,069
so C programmer must be careful and do

00:02:56,970 --> 00:03:03,450
different things to the same pointer in

00:02:59,069 --> 00:03:05,930
different situations Pearl has

00:03:03,450 --> 00:03:08,400
exceptions he doesn't so if you have

00:03:05,930 --> 00:03:10,230
objects that need to be explicitly

00:03:08,400 --> 00:03:12,690
released on the stack you have to guard

00:03:10,230 --> 00:03:15,959
them against exceptions in Pearl

00:03:12,690 --> 00:03:18,150
otherwise you lick them and all this

00:03:15,959 --> 00:03:20,010
like huge pile of small things you have

00:03:18,150 --> 00:03:22,980
to keep track of and they all there are

00:03:20,010 --> 00:03:26,130
dangerous and being careful is just not

00:03:22,980 --> 00:03:29,010
enough ok we have lives to have coffee

00:03:26,130 --> 00:03:31,410
shortages we have to be very very

00:03:29,010 --> 00:03:34,859
careful in that still leaves bugs and

00:03:31,410 --> 00:03:36,120
vulnerabilities and crap so rust is a

00:03:34,859 --> 00:03:38,040
new programming language this is

00:03:36,120 --> 00:03:44,810
basically built around idea that being

00:03:38,040 --> 00:03:47,850
careful is not enough it is a compiled

00:03:44,810 --> 00:03:50,549
statically typed language that is binary

00:03:47,850 --> 00:03:52,410
compatible with C so by necessitate must

00:03:50,549 --> 00:03:54,630
be able to do all the same things that

00:03:52,410 --> 00:03:57,060
secant it can do pointer arithmetic that

00:03:54,630 --> 00:03:59,370
can have structures can catch pointers

00:03:57,060 --> 00:04:01,260
between tape types and it can read and

00:03:59,370 --> 00:04:02,519
write arbitrary memory allocations this

00:04:01,260 --> 00:04:04,500
is something you cannot do import

00:04:02,519 --> 00:04:08,700
because pearl takes care of it for you

00:04:04,500 --> 00:04:10,739
for you but that is and see and unsafe

00:04:08,700 --> 00:04:12,480
code is very frequent in C program so

00:04:10,739 --> 00:04:13,889
you think it will in fact and type

00:04:12,480 --> 00:04:15,780
programs and there is no point in a

00:04:13,889 --> 00:04:18,389
different language so what rust has a

00:04:15,780 --> 00:04:20,310
lot of features to prevent this spread

00:04:18,389 --> 00:04:23,300
either to make unsafe code completely

00:04:20,310 --> 00:04:24,979
unnecessary or at least to contain and

00:04:23,300 --> 00:04:31,220
move it into some kind of safe

00:04:24,979 --> 00:04:33,590
abstraction so this is something not

00:04:31,220 --> 00:04:35,180
this is not a new idea actually the

00:04:33,590 --> 00:04:37,940
Pearl itself can be viewed as a safe

00:04:35,180 --> 00:04:40,270
abstraction around unsafe C code but

00:04:37,940 --> 00:04:44,590
with a different kind of guarantees that

00:04:40,270 --> 00:04:48,110
russ has and / Alex scpi also has that

00:04:44,590 --> 00:04:49,669
sv internally is is composed of

00:04:48,110 --> 00:04:52,460
different structures that are used in

00:04:49,669 --> 00:04:53,900
different situations but excessive me I

00:04:52,460 --> 00:04:55,310
handles that for you so you don't have

00:04:53,900 --> 00:04:56,659
to worry about it will do the right

00:04:55,310 --> 00:05:01,669
thing for you if you just stick to the

00:04:56,659 --> 00:05:03,289
API so this is idea that pearl excess

00:05:01,669 --> 00:05:06,680
packaging rasterize to do it tries to

00:05:03,289 --> 00:05:08,960
abstract away and save details of pearl

00:05:06,680 --> 00:05:13,280
accessing by behind like some kind of

00:05:08,960 --> 00:05:16,250
safe high level abstraction to end basic

00:05:13,280 --> 00:05:17,900
idea that are as programs whatever they

00:05:16,250 --> 00:05:19,580
do they may be completely wrong but they

00:05:17,900 --> 00:05:22,810
should not be able to corrupt Perl

00:05:19,580 --> 00:05:25,129
interpreter state across the interpreter

00:05:22,810 --> 00:05:27,560
so let's write some code and see how it

00:05:25,129 --> 00:05:29,889
goes things you see on the screen with

00:05:27,560 --> 00:05:32,960
bang at the end arrest macros they

00:05:29,889 --> 00:05:35,360
transform source code and excess macro

00:05:32,960 --> 00:05:37,400
takes care of low-level details of how

00:05:35,360 --> 00:05:40,039
actual binary function should look like

00:05:37,400 --> 00:05:43,669
it tailors it to the running pearl

00:05:40,039 --> 00:05:46,370
version it uses some kind of pearl

00:05:43,669 --> 00:05:49,819
syntax like pseudo pearl syntax to set

00:05:46,370 --> 00:05:51,409
things up excess return is the macro

00:05:49,819 --> 00:05:53,330
that takes a variable number of

00:05:51,409 --> 00:05:56,800
arguments pushes them to the stack and

00:05:53,330 --> 00:06:00,349
returns on all in one line all

00:05:56,800 --> 00:06:03,349
subroutines in rust excess except one

00:06:00,349 --> 00:06:05,120
argument context that is a window into

00:06:03,349 --> 00:06:07,909
the Perl interpreter itself and to the

00:06:05,120 --> 00:06:11,120
argument stack so from that stack we can

00:06:07,909 --> 00:06:12,680
pull the argument and SD fetch function

00:06:11,120 --> 00:06:15,620
will check if there are enough arguments

00:06:12,680 --> 00:06:18,830
on the stack and die because it has to

00:06:15,620 --> 00:06:20,900
and we but we also could check manual

00:06:18,830 --> 00:06:26,000
and return and die with more friend user

00:06:20,900 --> 00:06:28,039
friendly error message we try them to

00:06:26,000 --> 00:06:29,810
some elements of the race so we are

00:06:28,039 --> 00:06:31,940
argument as an array reference and we

00:06:29,810 --> 00:06:33,480
need to reference it before we can get

00:06:31,940 --> 00:06:37,530
to the elements

00:06:33,480 --> 00:06:41,400
but wait what this is wrong what if bar

00:06:37,530 --> 00:06:42,900
m is not an array reference so this

00:06:41,400 --> 00:06:46,320
program does not actually compile

00:06:42,900 --> 00:06:48,840
because the ref a veer returns something

00:06:46,320 --> 00:06:50,490
that is called option it is a

00:06:48,840 --> 00:06:52,560
replacement for now pointer and rust

00:06:50,490 --> 00:06:54,990
basically so it's but instead of being

00:06:52,560 --> 00:06:58,170
in band it wraps around the actual value

00:06:54,990 --> 00:07:00,720
and to get the value you have to unwrap

00:06:58,170 --> 00:07:04,020
it so you have to check if it's defined

00:07:00,720 --> 00:07:05,580
or not and it is not the value itself so

00:07:04,020 --> 00:07:10,700
you cannot use it as an array it's just

00:07:05,580 --> 00:07:14,130
an option there are many ways to do it

00:07:10,700 --> 00:07:16,860
one way is to use one of the many

00:07:14,130 --> 00:07:20,460
methods that provides and this is a rest

00:07:16,860 --> 00:07:23,100
equivalent to common pearl or die EDM so

00:07:20,460 --> 00:07:27,630
you just write if it's defined use it if

00:07:23,100 --> 00:07:31,320
it's not die next we need a counter to

00:07:27,630 --> 00:07:34,410
hold our values and a loop to go over

00:07:31,320 --> 00:07:36,420
the array element type annotations and

00:07:34,410 --> 00:07:38,250
rice are optional it can infer types of

00:07:36,420 --> 00:07:42,810
most variables automatically inside a

00:07:38,250 --> 00:07:45,360
function then we just pull elements from

00:07:42,810 --> 00:07:50,910
the array one by one and add them to the

00:07:45,360 --> 00:07:52,680
car to the accumulator now ad fetch

00:07:50,910 --> 00:07:55,140
function in c a-- can also return a null

00:07:52,680 --> 00:07:58,230
pointer so array a chin rest returns

00:07:55,140 --> 00:08:01,080
option as well here it just we just

00:07:58,230 --> 00:08:03,540
checked explicitly if it's defined so

00:08:01,080 --> 00:08:07,050
this can be read so this if statement

00:08:03,540 --> 00:08:11,730
can be read if defined my ex my item

00:08:07,050 --> 00:08:16,560
equals something then we just add it to

00:08:11,730 --> 00:08:19,880
the accumulator array fetch can also

00:08:16,560 --> 00:08:23,460
convert sv to a primitive type and

00:08:19,880 --> 00:08:26,640
because it happens exactly after we pull

00:08:23,460 --> 00:08:28,110
element from the rain we can do it

00:08:26,640 --> 00:08:31,920
without manipulating reference count

00:08:28,110 --> 00:08:33,570
over this week i forgot to mention that

00:08:31,920 --> 00:08:35,280
every sv that you have in a local

00:08:33,570 --> 00:08:37,280
variable in the rust has to be reference

00:08:35,280 --> 00:08:39,450
counted because otherwise it can go away

00:08:37,280 --> 00:08:44,120
by calling perl function on doing

00:08:39,450 --> 00:08:50,310
something and you have a memory purple

00:08:44,120 --> 00:08:52,500
so that's it this wouldn't be complete

00:08:50,310 --> 00:08:54,210
without benchmarks of course now when I

00:08:52,500 --> 00:08:55,830
was writing these benchmarks I expected

00:08:54,210 --> 00:08:58,290
to see the trust code would be slightly

00:08:55,830 --> 00:08:59,940
maybe maybe not slightly but slower than

00:08:58,290 --> 00:09:01,680
excess because it has to jump through

00:08:59,940 --> 00:09:04,430
more hoops and there are some

00:09:01,680 --> 00:09:07,560
inefficiencies inherent to the approach

00:09:04,430 --> 00:09:10,890
whatever I didn't expect to see is that

00:09:07,560 --> 00:09:13,710
it would be slower than Pearl itself so

00:09:10,890 --> 00:09:15,300
what's going on remember I said that she

00:09:13,710 --> 00:09:17,790
doesn't have exceptions and you have to

00:09:15,300 --> 00:09:20,220
check for them that's what i did in the

00:09:17,790 --> 00:09:22,050
back so there is a try-catch basically

00:09:20,220 --> 00:09:23,940
on every line of this program every call

00:09:22,050 --> 00:09:25,980
to pearl ecstasy bike and I so we can

00:09:23,940 --> 00:09:29,010
service so we have to check for

00:09:25,980 --> 00:09:31,620
exceptions to unwind through rust code

00:09:29,010 --> 00:09:33,600
and clean up the reference counts it has

00:09:31,620 --> 00:09:35,700
on the stack now this is not strictly

00:09:33,600 --> 00:09:37,470
required for memories a fitting leaks

00:09:35,700 --> 00:09:40,020
are bad but they're not they don't cause

00:09:37,470 --> 00:09:42,050
security vulnerabilities they just like

00:09:40,020 --> 00:09:45,780
we're program stops working at some put

00:09:42,050 --> 00:09:48,090
dudes bad but not that bad so maybe the

00:09:45,780 --> 00:09:49,740
there is more freedom in how to handle

00:09:48,090 --> 00:09:51,780
this but for now let's just disable them

00:09:49,740 --> 00:09:54,090
and see how it goes and it goes much

00:09:51,780 --> 00:09:56,250
better it's still slower than excess

00:09:54,090 --> 00:09:58,700
about two and half times but at least

00:09:56,250 --> 00:10:01,560
it's faster than Pearl and it's safe

00:09:58,700 --> 00:10:04,320
another benchmark I did is to compute

00:10:01,560 --> 00:10:06,570
greatest common divisor it doesn't use

00:10:04,320 --> 00:10:08,430
perl xse p is that much just gets two

00:10:06,570 --> 00:10:10,110
arguments from the stack does some

00:10:08,430 --> 00:10:14,280
simple math and a loop and returns an

00:10:10,110 --> 00:10:16,050
integer back and it works faster even so

00:10:14,280 --> 00:10:18,090
that doing computation native code out

00:10:16,050 --> 00:10:21,270
weights the horrible overhead of doing

00:10:18,090 --> 00:10:23,580
it in rust and without exception checks

00:10:21,270 --> 00:10:29,910
it's actually pretty decent and only

00:10:23,580 --> 00:10:32,400
slightly behind success so what we can

00:10:29,910 --> 00:10:36,420
learn from this it's possible it works

00:10:32,400 --> 00:10:38,190
it's not pretty maybe but it works it's

00:10:36,420 --> 00:10:40,680
safer there are no pointers in the

00:10:38,190 --> 00:10:45,300
program whatsoever we have all bases

00:10:40,680 --> 00:10:50,570
covered and it's lower well it was

00:10:45,300 --> 00:10:50,570
predictable so that's it any questions

00:10:55,770 --> 00:11:03,460
so what this program compiles down to a

00:11:00,100 --> 00:11:05,410
shared library just like access we it

00:11:03,460 --> 00:11:07,600
has the same binary interface that

00:11:05,410 --> 00:11:09,970
access library would have so girl can

00:11:07,600 --> 00:11:11,650
just load it with a dino loader it does

00:11:09,970 --> 00:11:14,260
it does know that it's written in rust

00:11:11,650 --> 00:11:15,900
and there is a small tool chain built

00:11:14,260 --> 00:11:18,820
around it so you can build the program

00:11:15,900 --> 00:11:21,370
using Perl tools it just dispatches to

00:11:18,820 --> 00:11:35,880
rust compiler instead and then puts the

00:11:21,370 --> 00:11:35,880
files in the right locations yes

00:11:40,450 --> 00:11:47,470
so it's quite actually simple arrest

00:11:43,420 --> 00:11:50,250
makers can match on the talking tree so

00:11:47,470 --> 00:11:54,610
it just expects a package and some

00:11:50,250 --> 00:11:57,340
identifiers and then it's a sub and name

00:11:54,610 --> 00:12:00,280
and context and then it just expect to

00:11:57,340 --> 00:12:13,870
see some code block so code block has

00:12:00,280 --> 00:12:15,340
just matched as rascal yes they to to

00:12:13,870 --> 00:12:16,990
build the module you need to compile a

00:12:15,340 --> 00:12:18,700
rest compiler installed and you need to

00:12:16,990 --> 00:12:22,060
access to internet to download the

00:12:18,700 --> 00:12:28,900
package but Tehran it you just need to

00:12:22,060 --> 00:12:33,870
the final binary yes yes exactly

00:12:28,900 --> 00:12:33,870
something I'll drug resistant yes

00:12:34,730 --> 00:12:39,410
residents old but if you had this in it

00:12:36,440 --> 00:12:41,740
look at demion RPF or patent the devil

00:12:39,410 --> 00:12:41,740
package

00:12:43,100 --> 00:12:55,230
yes exactly

00:12:46,110 --> 00:13:01,079
oh that do I think we have still have

00:12:55,230 --> 00:13:07,740
time so maybe back and do a demo let's

00:13:01,079 --> 00:13:10,110
see how there is a shelf so it and we're

00:13:07,740 --> 00:13:13,410
in the right direction where is Sam so

00:13:10,110 --> 00:13:18,170
we have a couple of files here we have a

00:13:13,410 --> 00:13:21,600
make file dot PL which is normal pearl

00:13:18,170 --> 00:13:23,730
build script we have a pearl package

00:13:21,600 --> 00:13:26,810
that just calls excess loader to load

00:13:23,730 --> 00:13:29,430
the package and we have the library so

00:13:26,810 --> 00:13:33,570
it's exactly the same code that i was

00:13:29,430 --> 00:13:35,820
showing before make file uses module

00:13:33,570 --> 00:13:38,250
install which has which I made a plug-in

00:13:35,820 --> 00:13:43,620
for to build actually risk out so we can

00:13:38,250 --> 00:13:48,480
just say make file and then we can

00:13:43,620 --> 00:13:51,260
follow the same path so downloads and

00:13:48,480 --> 00:13:51,260
build some stuff

00:13:53,900 --> 00:13:58,910
and it builds the program so it's boots

00:13:56,240 --> 00:14:02,360
the final binary into the location where

00:13:58,910 --> 00:14:18,450
pearl expects its to see to see it we

00:14:02,360 --> 00:14:21,120
can just it works

00:14:18,450 --> 00:14:23,640
so there is there isn't much gone from

00:14:21,120 --> 00:14:30,150
the user perspective with one more or

00:14:23,640 --> 00:14:32,270
less hidden all right thank you very

00:14:30,150 --> 00:14:32,270

YouTube URL: https://www.youtube.com/watch?v=GwS8eDOYz_U


