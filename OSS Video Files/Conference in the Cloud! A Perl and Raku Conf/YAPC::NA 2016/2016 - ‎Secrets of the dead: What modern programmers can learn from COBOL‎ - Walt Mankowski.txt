Title: 2016 - ‎Secrets of the dead: What modern programmers can learn from COBOL‎ - Walt Mankowski
Publication date: 2016-06-27
Playlist: YAPC::NA 2016
Description: 
	
Captions: 
	00:00:00,589 --> 00:00:05,520
so um once again I want to apologize

00:00:03,210 --> 00:00:08,130
I've kind of lost my voice sort of so I

00:00:05,520 --> 00:00:10,650
want to try to like very talking to this

00:00:08,130 --> 00:00:13,170
mic because normally I would be talking

00:00:10,650 --> 00:00:15,269
a little bit louder than this so um top

00:00:13,170 --> 00:00:16,859
top title of this talk is secrets of the

00:00:15,269 --> 00:00:19,080
Dead what modern programmers can learn

00:00:16,859 --> 00:00:20,760
from COBOL I already yes I think we've

00:00:19,080 --> 00:00:21,990
had some people quite a few people more

00:00:20,760 --> 00:00:24,750
than I was expecting who have actually

00:00:21,990 --> 00:00:26,640
used COBOL before so a little bit of

00:00:24,750 --> 00:00:28,980
history in case you're not familiar with

00:00:26,640 --> 00:00:32,880
it COBOL stands for common business

00:00:28,980 --> 00:00:37,320
oriented language that's created way way

00:00:32,880 --> 00:00:44,820
back in 1959 so it's about 55 years old

00:00:37,320 --> 00:00:47,010
ish maybe more than that I'm 57 and um

00:00:44,820 --> 00:00:49,020
you know if you ask anyone everyone

00:00:47,010 --> 00:00:51,750
thinks that it's this like dead language

00:00:49,020 --> 00:00:53,730
like no one programs in COBOL anymore

00:00:51,750 --> 00:00:56,039
but I mean it's it's really not true

00:00:53,730 --> 00:01:01,260
it's like it's like been rising from the

00:00:56,039 --> 00:01:02,820
dead and it just refuses to die I think

00:01:01,260 --> 00:01:04,229
there's some good reasons for that and

00:01:02,820 --> 00:01:05,430
people will say it's just there's so

00:01:04,229 --> 00:01:07,290
much code you can't get rid of it I

00:01:05,430 --> 00:01:09,960
think there are some some good things

00:01:07,290 --> 00:01:11,520
about about COBOL so there's some

00:01:09,960 --> 00:01:15,570
statistics I'm kind of surprising

00:01:11,520 --> 00:01:17,369
statistics like especially the bottom

00:01:15,570 --> 00:01:21,360
one that this is estimate there's five

00:01:17,369 --> 00:01:24,960
billion lines of new COBOL code written

00:01:21,360 --> 00:01:26,700
every year ninety percent of Fortune 500

00:01:24,960 --> 00:01:28,890
companies and you know all these

00:01:26,700 --> 00:01:30,390
business transactions and I think like

00:01:28,890 --> 00:01:32,040
in general what this is saying is that

00:01:30,390 --> 00:01:34,590
like Coble's it's not doing a lot of

00:01:32,040 --> 00:01:37,619
like the sexy front-end stuff but it's

00:01:34,590 --> 00:01:39,960
doing kind of the work a day like

00:01:37,619 --> 00:01:43,049
reporting and numerical behind the

00:01:39,960 --> 00:01:44,729
scenes like the the like business stuff

00:01:43,049 --> 00:01:46,890
the handling the money and warehousing

00:01:44,729 --> 00:01:50,430
and moving shipping containers around

00:01:46,890 --> 00:01:54,210
and and things like that big couples

00:01:50,430 --> 00:01:55,710
kind of a wordy language and I think

00:01:54,210 --> 00:01:58,170
part of this five billion lines it takes

00:01:55,710 --> 00:02:00,350
a lot of lines of code to do anything to

00:01:58,170 --> 00:02:05,850
be honest

00:02:00,350 --> 00:02:14,690
but yeah / 5 it'll be about 10 lines of

00:02:05,850 --> 00:02:19,440
six so so the one person who's most

00:02:14,690 --> 00:02:22,500
liked recognized with COBOL is this

00:02:19,440 --> 00:02:23,700
person is Grace Hopper I thought this

00:02:22,500 --> 00:02:25,230
quote which I thought was kind of

00:02:23,700 --> 00:02:25,920
interesting it says I'll read it down in

00:02:25,230 --> 00:02:27,630
case you can't read it

00:02:25,920 --> 00:02:29,250
humans are allergic to change they love

00:02:27,630 --> 00:02:30,840
to say we've always done it this way I

00:02:29,250 --> 00:02:32,280
try to fight that that's why I have a

00:02:30,840 --> 00:02:34,740
clock on my wall that runs counter

00:02:32,280 --> 00:02:37,680
clockwise I think it's kind of ironic

00:02:34,740 --> 00:02:39,450
given you know historically how then

00:02:37,680 --> 00:02:41,190
said a lot of COBOL code is and

00:02:39,450 --> 00:02:43,980
resistant to change that you would have

00:02:41,190 --> 00:02:45,870
said that of all people but whatever so

00:02:43,980 --> 00:02:48,239
it turns out that she had she did in

00:02:45,870 --> 00:02:50,550
fact play a part in it but COBOL was

00:02:48,239 --> 00:02:55,430
really designed by a committee including

00:02:50,550 --> 00:02:59,220
her and people from IBM and the DoD but

00:02:55,430 --> 00:03:01,200
it was like not really designed by ivory

00:02:59,220 --> 00:03:03,390
tower computer science professors in

00:03:01,200 --> 00:03:05,790
Grace Hopper was she had a PhD in math

00:03:03,390 --> 00:03:07,890
but she wasn't in like with von Neumann

00:03:05,790 --> 00:03:10,170
and like the people were doing doing

00:03:07,890 --> 00:03:11,489
Lisp and Fortran um in fact they didn't

00:03:10,170 --> 00:03:13,709
want it to be like that because they

00:03:11,489 --> 00:03:16,019
needed a language that could work like

00:03:13,709 --> 00:03:18,000
for things that DoD does besides missile

00:03:16,019 --> 00:03:20,549
trajectories things like personnel

00:03:18,000 --> 00:03:24,390
records and we like keeping track of the

00:03:20,549 --> 00:03:25,769
money to pay for everything and the

00:03:24,390 --> 00:03:28,980
existing languages like Fortran just

00:03:25,769 --> 00:03:30,720
weren't very good for that so some of

00:03:28,980 --> 00:03:32,310
the design goals involved having an

00:03:30,720 --> 00:03:35,660
English language syntax or English

00:03:32,310 --> 00:03:38,180
language syntax I'm sorry

00:03:35,660 --> 00:03:43,140
Carlo coltd in a large part certainly

00:03:38,180 --> 00:03:44,850
and and that it would be do business

00:03:43,140 --> 00:03:46,860
reporting as I said like reports and

00:03:44,850 --> 00:03:48,239
dealing with money and personnel and

00:03:46,860 --> 00:03:52,980
things like that

00:03:48,239 --> 00:03:54,570
and I'll say that while I myself in one

00:03:52,980 --> 00:03:57,209
of these ivory tower computer science

00:03:54,570 --> 00:03:59,040
people I worked as a COBOL programmer

00:03:57,209 --> 00:04:02,910
for about ten years at QVC back in the

00:03:59,040 --> 00:04:04,019
90s and you know we all know what I mean

00:04:02,910 --> 00:04:05,489
there's plenty of things that have been

00:04:04,019 --> 00:04:06,780
written bad about COBOL I thought I

00:04:05,489 --> 00:04:08,270
would take some time to talk about a few

00:04:06,780 --> 00:04:11,510
things that I thought we're good

00:04:08,270 --> 00:04:13,310
cobalt so what I have this picture of

00:04:11,510 --> 00:04:14,120
this Ferrari here partly because I

00:04:13,310 --> 00:04:16,150
thought it would be funny to have a

00:04:14,120 --> 00:04:20,570
picture of a Ferrari to talk about COBOL

00:04:16,150 --> 00:04:22,820
and also I mean there's engineering

00:04:20,570 --> 00:04:24,410
trade-offs in design of something like

00:04:22,820 --> 00:04:26,720
this I mean obviously Formula one cars

00:04:24,410 --> 00:04:29,150
have to go very very fast right they can

00:04:26,720 --> 00:04:32,510
go over well over 200 miles an hour but

00:04:29,150 --> 00:04:34,940
um they also have to corner really well

00:04:32,510 --> 00:04:36,740
- this is a famous turn at in Monaco

00:04:34,940 --> 00:04:38,390
where I think they have to go around

00:04:36,740 --> 00:04:39,890
this said about like they still can go

00:04:38,390 --> 00:04:43,010
around this at about 60 miles an hour

00:04:39,890 --> 00:04:44,690
believe it or not and in order the trade

00:04:43,010 --> 00:04:47,630
offs you have to make to go corner

00:04:44,690 --> 00:04:49,550
really fast and to go and to be able to

00:04:47,630 --> 00:04:51,410
corner like that and slow down and to go

00:04:49,550 --> 00:04:53,930
fast are kind of at odds with each other

00:04:51,410 --> 00:04:55,820
so there's always design trade-offs and

00:04:53,930 --> 00:04:58,100
like we understand those design

00:04:55,820 --> 00:05:00,260
trade-offs for Formula one cars and I

00:04:58,100 --> 00:05:02,510
think a lot of times we don't accept

00:05:00,260 --> 00:05:04,580
that there's design trade-offs that with

00:05:02,510 --> 00:05:07,160
things like COBOL are doing as opposed

00:05:04,580 --> 00:05:08,480
to what perl is trying to do and of

00:05:07,160 --> 00:05:10,730
course also we wouldn't want to drive a

00:05:08,480 --> 00:05:12,470
car like this I mean as cool as this car

00:05:10,730 --> 00:05:14,240
is we wouldn't want to have this as our

00:05:12,470 --> 00:05:17,060
regular day-to-day car if it doesn't

00:05:14,240 --> 00:05:22,880
have cup holders or like or a trunk or a

00:05:17,060 --> 00:05:24,830
roof or things like that right so it

00:05:22,880 --> 00:05:26,290
doesn't it does have an identification

00:05:24,830 --> 00:05:30,950
division

00:05:26,290 --> 00:05:33,530
it says how would I go here somewhere

00:05:30,950 --> 00:05:39,050
here it says that it is where the hell

00:05:33,530 --> 00:05:42,520
is it it has I believe that this is the

00:05:39,050 --> 00:05:42,520
Spanish the Spanish driver

00:05:46,230 --> 00:05:50,310
oh well it says Ferrari on it so let's

00:05:49,050 --> 00:05:53,060
just say that if there's a driver's name

00:05:50,310 --> 00:05:56,310
although I can't find it right now

00:05:53,060 --> 00:05:57,180
Alonso Alonso his name is on there

00:05:56,310 --> 00:05:59,810
somewhere

00:05:57,180 --> 00:06:01,800
so let's look let's look at some of this

00:05:59,810 --> 00:06:05,330
syntax was supposed to be English

00:06:01,800 --> 00:06:07,410
language so this is whole world in COBOL

00:06:05,330 --> 00:06:10,140
it cites a lot there

00:06:07,410 --> 00:06:16,980
there's the identification division up

00:06:10,140 --> 00:06:18,540
there at the top so COBOL programs are

00:06:16,980 --> 00:06:20,250
supposed to be this hat of this kind of

00:06:18,540 --> 00:06:22,380
hard hire real structure looks like a

00:06:20,250 --> 00:06:23,790
business or the military right so

00:06:22,380 --> 00:06:25,470
there's the program at the top the

00:06:23,790 --> 00:06:29,670
vendors various divisions and sections

00:06:25,470 --> 00:06:31,890
and paragraphs yada yada yada there are

00:06:29,670 --> 00:06:33,810
four possible divisions the

00:06:31,890 --> 00:06:36,240
identification division which basically

00:06:33,810 --> 00:06:37,740
says like it's only really used to give

00:06:36,240 --> 00:06:39,030
the name of the program but the in

00:06:37,740 --> 00:06:40,800
division we'll get back to the

00:06:39,030 --> 00:06:42,060
environment division I've never had to

00:06:40,800 --> 00:06:43,980
use anything with that at least for the

00:06:42,060 --> 00:06:45,300
version of COBOL I was using so what

00:06:43,980 --> 00:06:49,260
ignore that and that the procedure

00:06:45,300 --> 00:06:51,720
division is where the code is if you

00:06:49,260 --> 00:06:52,830
don't have anything to add a division if

00:06:51,720 --> 00:06:54,780
you don't have anything a division you

00:06:52,830 --> 00:06:58,610
can get rid of it so this is another

00:06:54,780 --> 00:06:58,610
hello world program to kind of trim down

00:06:59,780 --> 00:07:06,060
so that still seems kind of wordy just

00:07:03,810 --> 00:07:14,040
for a homo world but you know it's not

00:07:06,060 --> 00:07:16,320
as bad as it could be right the

00:07:14,040 --> 00:07:18,180
worthiness of COBOL I mean there are

00:07:16,320 --> 00:07:20,130
some other languages that that use that

00:07:18,180 --> 00:07:22,500
and I would argue that COBOL is wording

00:07:20,130 --> 00:07:24,480
in kind of the same way that oh I don't

00:07:22,500 --> 00:07:25,740
I don't have that okay I'll get back to

00:07:24,480 --> 00:07:28,500
that point so let's look at some other

00:07:25,740 --> 00:07:31,020
some other let's look at a few like how

00:07:28,500 --> 00:07:35,640
do you do things in COBOL so this is the

00:07:31,020 --> 00:07:39,510
equivalent of B equals a so you say move

00:07:35,640 --> 00:07:41,730
a to B if you want to add something you

00:07:39,510 --> 00:07:44,310
say it's something like add a to be

00:07:41,730 --> 00:07:46,740
giving C so that's gonna say C that's

00:07:44,310 --> 00:07:48,570
the equivalent of C equals a plus B very

00:07:46,740 --> 00:07:50,790
very wordy there is in fact to keep you

00:07:48,570 --> 00:07:53,280
safe but to avoid doing this but these

00:07:50,790 --> 00:07:54,960
are so pretty common if you don't have

00:07:53,280 --> 00:07:59,400
that giving you can just say add a to b

00:07:54,960 --> 00:08:00,120
that's like a plus equals you can add

00:07:59,400 --> 00:08:04,020
1/2 a that's

00:08:00,120 --> 00:08:06,690
plus plus write and subtract kind of

00:08:04,020 --> 00:08:09,210
works the same way multiply you want to

00:08:06,690 --> 00:08:15,570
get the remainder you say divide a by B

00:08:09,210 --> 00:08:18,210
giving si remainder are just this gives

00:08:15,570 --> 00:08:20,430
you about this is about 90% of what

00:08:18,210 --> 00:08:27,860
you'll see in the body of both COBOL

00:08:20,430 --> 00:08:31,430
programs yes r2 from and by

00:08:27,860 --> 00:08:31,430
interchangeable or do you have these

00:08:31,669 --> 00:08:35,190
it's pretty strict it has to be this

00:08:33,870 --> 00:08:36,500
format it sorry the question is let's

00:08:35,190 --> 00:08:38,729
have to say that or can you have other

00:08:36,500 --> 00:08:40,169
variations of English and the answer is

00:08:38,729 --> 00:08:42,240
no it has to be has to be that there's

00:08:40,169 --> 00:08:43,979
like there's an optional that's like

00:08:42,240 --> 00:08:45,330
yeah it's like a clause there's like the

00:08:43,979 --> 00:08:46,529
way the phrase has to be and some of

00:08:45,330 --> 00:08:54,029
them are option we'll assemble them are

00:08:46,529 --> 00:08:55,920
required yes and it's some of them are a

00:08:54,029 --> 00:08:57,510
little confusing actually I put the more

00:08:55,920 --> 00:09:02,900
straightforward ones up here to just

00:08:57,510 --> 00:09:05,880
kind of avoid any anything like that so

00:09:02,900 --> 00:09:07,800
so this is wordy I'll admit it's wordy

00:09:05,880 --> 00:09:10,080
and that's one reason why you end up

00:09:07,800 --> 00:09:13,320
with like five billion lines of COBOL

00:09:10,080 --> 00:09:17,100
every year but it's kind of weird in the

00:09:13,320 --> 00:09:18,810
same way that SQL is worried right and

00:09:17,100 --> 00:09:20,610
there's no there's no mathematical way

00:09:18,810 --> 00:09:22,020
to do this although there's a reason why

00:09:20,610 --> 00:09:25,580
there couldn't be this just that this is

00:09:22,020 --> 00:09:25,580
kind of what this the standard is

00:09:26,750 --> 00:09:30,839
anything I think there seems to be a

00:09:29,190 --> 00:09:33,330
trend at least in some languages to try

00:09:30,839 --> 00:09:36,450
to to try to have this sort of wordy the

00:09:33,330 --> 00:09:37,920
sort of COBOL which wordiness as well to

00:09:36,450 --> 00:09:40,709
kind of go back to the terseness of

00:09:37,920 --> 00:09:42,900
something like Perl to and I think the

00:09:40,709 --> 00:09:49,380
one example I'm I'm most familiar with

00:09:42,900 --> 00:09:51,270
is is cocoa and Objective C this is how

00:09:49,380 --> 00:09:53,250
you trim the white space from the

00:09:51,270 --> 00:09:58,800
beginning and end of a string in Cobalt

00:09:53,250 --> 00:10:01,320
it's in Objective C cocoa it's a lot of

00:09:58,800 --> 00:10:06,260
code this is this is about a five line

00:10:01,320 --> 00:10:08,370
regular expression in the in Perl and

00:10:06,260 --> 00:10:11,200
part of the reason that this is so

00:10:08,370 --> 00:10:13,180
complex is that

00:10:11,200 --> 00:10:14,620
if that parameters are all neat or

00:10:13,180 --> 00:10:18,790
everything except the first parameter is

00:10:14,620 --> 00:10:20,019
named right by the name of so basically

00:10:18,790 --> 00:10:22,480
you're taking this thing called a

00:10:20,019 --> 00:10:24,220
whitespace string which is a string of

00:10:22,480 --> 00:10:27,100
type and a string and you're calling the

00:10:24,220 --> 00:10:29,350
you're sending it the message string by

00:10:27,100 --> 00:10:31,510
trimming character set it characters in

00:10:29,350 --> 00:10:34,120
set and then the stuff comes after that

00:10:31,510 --> 00:10:37,570
is the set of a character set that yeah

00:10:34,120 --> 00:10:38,829
so this is a talk about that objective-c

00:10:37,570 --> 00:10:40,990
but that's kind of what it's doing but

00:10:38,829 --> 00:10:42,339
the fact that doesn't trim the newline

00:10:40,990 --> 00:10:47,560
characters from the end you have to do

00:10:42,339 --> 00:10:50,019
this to do that and I think but but

00:10:47,560 --> 00:10:51,459
Objective C programmers love this kind

00:10:50,019 --> 00:10:52,630
of stuff because they think like well

00:10:51,459 --> 00:10:56,800
you can look at this you know exactly

00:10:52,630 --> 00:11:00,790
what it's doing okay

00:10:56,800 --> 00:11:06,360
just keep moving on beginning so it's

00:11:00,790 --> 00:11:06,360
right you do get used to it yeah okay

00:11:06,510 --> 00:11:11,649
data division

00:11:09,360 --> 00:11:13,990
most of the stuff most of the verbs you

00:11:11,649 --> 00:11:15,160
end up end up going to saw a section of

00:11:13,990 --> 00:11:17,410
the data division called the working

00:11:15,160 --> 00:11:19,000
storage section and this is where most

00:11:17,410 --> 00:11:21,790
of your variables are going to go at

00:11:19,000 --> 00:11:23,800
least the system I used way let's put WS

00:11:21,790 --> 00:11:25,510
in front of them you can put dashes and

00:11:23,800 --> 00:11:27,640
inside variable names that's that's okay

00:11:25,510 --> 00:11:32,649
because you're not wasting them on

00:11:27,640 --> 00:11:36,820
something like subtraction right so so

00:11:32,649 --> 00:11:38,199
you can do that there and so these pick

00:11:36,820 --> 00:11:40,870
things are really the heart of the way

00:11:38,199 --> 00:11:44,470
the data that gets declared so the name

00:11:40,870 --> 00:11:46,660
is is a X means a cat means alpha then

00:11:44,470 --> 00:11:49,300
there are characters so name is going to

00:11:46,660 --> 00:11:51,940
be ten characters the ad just couldn't

00:11:49,300 --> 00:11:53,380
be two numbers and answer is going to be

00:11:51,940 --> 00:11:54,670
two numbers and it's being initialized

00:11:53,380 --> 00:11:56,440
to 42 so that's pretty straightforward

00:11:54,670 --> 00:11:59,430
looking at that once you got a use of

00:11:56,440 --> 00:12:01,420
the X's and nines what's going on

00:11:59,430 --> 00:12:08,829
because you see you've worked with these

00:12:01,420 --> 00:12:10,660
all day long so this is a way to do

00:12:08,829 --> 00:12:15,269
dates this is the way we did dates at

00:12:10,660 --> 00:12:15,269
QVC where

00:12:15,370 --> 00:12:22,490
exactly that's why I put this up here

00:12:17,540 --> 00:12:24,500
and that's why it was a problem so right

00:12:22,490 --> 00:12:28,040
so it's declaring month/day/year each of

00:12:24,500 --> 00:12:30,380
them are two characters and right this

00:12:28,040 --> 00:12:31,820
is exactly why the y2k issue was such a

00:12:30,380 --> 00:12:34,910
big deal

00:12:31,820 --> 00:12:36,529
but you can also I wanted to point out

00:12:34,910 --> 00:12:38,060
you can refer to things by anyone of

00:12:36,529 --> 00:12:40,279
what most of the subfields get higher

00:12:38,060 --> 00:12:41,930
numbers then you always start with a

00:12:40,279 --> 00:12:44,210
zero one and you put higher numbers to

00:12:41,930 --> 00:12:46,190
get things physical subfields and you

00:12:44,210 --> 00:12:49,300
can always refer to at any level so you

00:12:46,190 --> 00:12:55,370
can refer to WS D or the DD

00:12:49,300 --> 00:12:57,200
interchangeably but here's what a

00:12:55,370 --> 00:13:02,660
customer record might potentially look

00:12:57,200 --> 00:13:05,600
like and here are some examples of what

00:13:02,660 --> 00:13:07,730
that might look like and that this all

00:13:05,600 --> 00:13:09,820
those kind of those crazy characters are

00:13:07,730 --> 00:13:16,160
just indicating spaces between the

00:13:09,820 --> 00:13:17,450
fields and on the one hand right so you

00:13:16,160 --> 00:13:19,040
always have that things aren't going to

00:13:17,450 --> 00:13:20,870
get compress everything is exactly those

00:13:19,040 --> 00:13:24,290
sizes like all throughout COBOL that's

00:13:20,870 --> 00:13:25,970
very much the case and things get

00:13:24,290 --> 00:13:28,010
truncated like Gotham City has really

00:13:25,970 --> 00:13:28,910
got them sick because it would be 11

00:13:28,010 --> 00:13:33,709
characters they don't have ten

00:13:28,910 --> 00:13:35,120
characters to play with there but if

00:13:33,709 --> 00:13:36,890
these are what if this is what you're

00:13:35,120 --> 00:13:38,570
storing in your database in your files

00:13:36,890 --> 00:13:40,640
and reading the back out it's super easy

00:13:38,570 --> 00:13:42,200
to do that and it's it's actually pretty

00:13:40,640 --> 00:13:43,670
hard in almost every other language to

00:13:42,200 --> 00:13:45,740
deal with records that look like this

00:13:43,670 --> 00:13:48,770
but COBOL it's trivial because it's just

00:13:45,740 --> 00:13:50,720
kind of built to deal with that so why

00:13:48,770 --> 00:13:52,490
why are they doing this well I mean

00:13:50,720 --> 00:13:56,720
COBOL is created this is what a 3

00:13:52,490 --> 00:13:58,550
megabyte hard drive looked like so so

00:13:56,720 --> 00:14:00,920
swords were super expensive you really

00:13:58,550 --> 00:14:03,860
wanted to micro manage the storage and

00:14:00,920 --> 00:14:06,860
then I mean reports look like this - so

00:14:03,860 --> 00:14:09,020
reports were all fixed fixed fixed font

00:14:06,860 --> 00:14:10,339
and you only had so many characters

00:14:09,020 --> 00:14:11,810
where everything had to go so it was

00:14:10,339 --> 00:14:13,160
really important that the data fit

00:14:11,810 --> 00:14:15,290
inside the fields that you had declared

00:14:13,160 --> 00:14:17,630
for it because the reports would also be

00:14:15,290 --> 00:14:19,310
based on that and your your screens

00:14:17,630 --> 00:14:20,720
would also be based on that as well but

00:14:19,310 --> 00:14:23,420
the screens you didn't have

00:14:20,720 --> 00:14:26,860
proportionally spaced fonts on your 3270

00:14:23,420 --> 00:14:29,140
terminal ok

00:14:26,860 --> 00:14:31,600
to move on so I'm talking about some

00:14:29,140 --> 00:14:33,070
some business orientation stuff too so

00:14:31,600 --> 00:14:35,800
let's talk about numbers for instance

00:14:33,070 --> 00:14:38,350
for to start off with so let's say we

00:14:35,800 --> 00:14:39,910
have an odometer like a car odometer and

00:14:38,350 --> 00:14:42,420
that's gonna be a pick nine five that's

00:14:39,910 --> 00:14:46,150
what odometers always look like in cars

00:14:42,420 --> 00:14:47,710
just like if you have a number like if

00:14:46,150 --> 00:14:49,420
you have an integer number once you hit

00:14:47,710 --> 00:14:52,180
whatever the maximum like six five five

00:14:49,420 --> 00:14:55,480
three six or 3270 what would three to

00:14:52,180 --> 00:14:58,690
seven six five six six it wraps around

00:14:55,480 --> 00:15:00,550
to minus whatever and keeps going

00:14:58,690 --> 00:15:03,130
it works the same way for this just like

00:15:00,550 --> 00:15:06,190
a car odometer if you start with 0 0 0 0

00:15:03,130 --> 00:15:08,740
0 then 0 0 0 to 1 all the way up to 999

00:15:06,190 --> 00:15:15,010
99 you add one more to it you get zero

00:15:08,740 --> 00:15:17,400
zero zero zero zero again so ok so

00:15:15,010 --> 00:15:19,210
that's how that works

00:15:17,400 --> 00:15:20,500
it also works like this for a

00:15:19,210 --> 00:15:22,510
floating-point number so we all know

00:15:20,500 --> 00:15:24,310
that floating point sucks I have an

00:15:22,510 --> 00:15:25,660
example here which I'm going to skip you

00:15:24,310 --> 00:15:30,220
can look through this in my slides later

00:15:25,660 --> 00:15:32,170
on this is how you divide one by 10 in

00:15:30,220 --> 00:15:34,950
binary and it becomes a repeating number

00:15:32,170 --> 00:15:38,320
trust me on that

00:15:34,950 --> 00:15:40,150
so suppose and we wanted to have the

00:15:38,320 --> 00:15:41,530
old-time odometers didn't just have six

00:15:40,150 --> 00:15:43,090
digits they had the five digits a five

00:15:41,530 --> 00:15:45,100
digits and then the tenths of miles as

00:15:43,090 --> 00:15:49,210
well so we could do it like this that V

00:15:45,100 --> 00:15:50,620
means a virtual decimal point it's not

00:15:49,210 --> 00:15:52,720
going to be sorted internally internally

00:15:50,620 --> 00:15:55,240
it's so going to be six it's going to be

00:15:52,720 --> 00:15:57,670
six numbers then internally but the

00:15:55,240 --> 00:15:58,870
compiler knows that that final one is a

00:15:57,670 --> 00:16:00,100
decimal point when you go to print it

00:15:58,870 --> 00:16:02,160
out there's going to be a decimal point

00:16:00,100 --> 00:16:04,540
there that means so you can keep adding

00:16:02,160 --> 00:16:05,740
point one to a point one to it over and

00:16:04,540 --> 00:16:07,120
over again you're never gonna have any

00:16:05,740 --> 00:16:09,130
kind of roundoff errors because it's

00:16:07,120 --> 00:16:11,950
doing the Baths the arithmetic in

00:16:09,130 --> 00:16:15,100
decimal instead of in binary this is

00:16:11,950 --> 00:16:17,170
super useful because you can do things

00:16:15,100 --> 00:16:19,960
like this you can add you can have a

00:16:17,170 --> 00:16:22,120
price with two with cents and tax with

00:16:19,960 --> 00:16:23,770
tents and then you add the two of them

00:16:22,120 --> 00:16:24,880
up and you never can have any kind of

00:16:23,770 --> 00:16:26,740
roundoff error because it's always

00:16:24,880 --> 00:16:28,690
dealing with it in exactly those things

00:16:26,740 --> 00:16:31,600
it's super easy to understand as well

00:16:28,690 --> 00:16:33,160
because like lots of like intro program

00:16:31,600 --> 00:16:34,600
it's things that people always struggle

00:16:33,160 --> 00:16:36,400
with is like what the hell is going on

00:16:34,600 --> 00:16:37,900
with these crazy floating-point I Triple

00:16:36,400 --> 00:16:40,620
E floating point numbers so they don't

00:16:37,900 --> 00:16:40,620
have to worry about that

00:16:41,680 --> 00:16:47,890
do I want to skip I'm gonna skip over

00:16:43,450 --> 00:16:49,960
the BCD you can have to be you can score

00:16:47,890 --> 00:16:51,850
two digits inside one byte by just

00:16:49,960 --> 00:16:55,600
saying comp three that's all I was

00:16:51,850 --> 00:17:00,160
saying there so I think to kind of sum

00:16:55,600 --> 00:17:03,490
up I think that if pearls that if if

00:17:00,160 --> 00:17:05,140
pearls motto is Tim Tony that there's

00:17:03,490 --> 00:17:06,040
more than one way to do it I would say

00:17:05,140 --> 00:17:09,250
that cobol's

00:17:06,040 --> 00:17:10,510
motto might be WYSIWYG because like

00:17:09,250 --> 00:17:12,850
there's it there's not a lot of

00:17:10,510 --> 00:17:14,380
surprises in COBOL like you pretty much

00:17:12,850 --> 00:17:17,380
look at anything and it might be super

00:17:14,380 --> 00:17:18,820
verbose but there's not a lot of and it

00:17:17,380 --> 00:17:20,650
could it certainly lends itself to

00:17:18,820 --> 00:17:22,210
spaghetti code but it's always you can

00:17:20,650 --> 00:17:23,380
always look at it and kind of figure out

00:17:22,210 --> 00:17:27,880
very easily there's not gonna be

00:17:23,380 --> 00:17:29,410
surprises about floating points or other

00:17:27,880 --> 00:17:32,050
kinds of things like that I think that

00:17:29,410 --> 00:17:34,000
COBOL is kind of like the flux of

00:17:32,050 --> 00:17:36,070
programming languages because no matter

00:17:34,000 --> 00:17:37,810
how complicated it is the rules are

00:17:36,070 --> 00:17:40,840
always sort of laid out there for you

00:17:37,810 --> 00:17:46,690
and so you know at this point the rules

00:17:40,840 --> 00:17:48,100
are you draw for right so even though

00:17:46,690 --> 00:17:50,950
the rules might change a lot you always

00:17:48,100 --> 00:17:52,660
know what the rules are at any point

00:17:50,950 --> 00:17:56,440
there's not a lot of surprises in it so

00:17:52,660 --> 00:18:02,830
I think I have about a minute and a half

00:17:56,440 --> 00:18:12,550
left so I know this went super fast do

00:18:02,830 --> 00:18:15,250
you have any more questions I do think

00:18:12,550 --> 00:18:18,240
that for all the souls I do think and I

00:18:15,250 --> 00:18:21,490
know this from experience that that very

00:18:18,240 --> 00:18:22,630
super junior programmers who have not

00:18:21,490 --> 00:18:23,590
even had any kind of a background of

00:18:22,630 --> 00:18:27,550
programming at all have come from other

00:18:23,590 --> 00:18:30,640
careers can learn COBOL fairly easily so

00:18:27,550 --> 00:18:32,530
I would think that learning Perl

00:18:30,640 --> 00:18:34,690
learning Perl 5 certainly learning Perl

00:18:32,530 --> 00:18:36,520
6 that there's always going to be a

00:18:34,690 --> 00:18:38,140
question of am i doing this the best way

00:18:36,520 --> 00:18:40,060
is there some smarter way I could have

00:18:38,140 --> 00:18:42,900
been could be doing this and you never

00:18:40,060 --> 00:18:47,650
think that when you're writing a COBOL

00:18:42,900 --> 00:18:51,040
so so I think I think that when I was a

00:18:47,650 --> 00:18:52,760
COBOL programmer I didn't do the

00:18:51,040 --> 00:18:55,250
necessity worry about that stuff

00:18:52,760 --> 00:18:56,600
so it sort of focuses you more on the

00:18:55,250 --> 00:18:58,160
business rules that you have to deal

00:18:56,600 --> 00:19:00,140
with and you're not worried about

00:18:58,160 --> 00:19:02,090
because you really can't make the code

00:19:00,140 --> 00:19:04,070
the code work any better than it's going

00:19:02,090 --> 00:19:07,340
to work right I think there's something

00:19:04,070 --> 00:19:09,710
to be said for that honestly right so I

00:19:07,340 --> 00:19:11,420
don't know so we don't have to worry

00:19:09,710 --> 00:19:13,400
about yeah you don't have to worry about

00:19:11,420 --> 00:19:19,810
something there's not a COBOL critic

00:19:13,400 --> 00:19:22,340
like there is a purl critic right yes oh

00:19:19,810 --> 00:19:24,890
that's that's a convention were there

00:19:22,340 --> 00:19:29,110
was a logic convention in my shop where

00:19:24,890 --> 00:19:29,110
I worked it's not necessary at all Oh

00:19:29,240 --> 00:19:34,130
so I will say I will say that among the

00:19:32,030 --> 00:19:37,760
issues among the issues with COBOL is

00:19:34,130 --> 00:19:40,550
scoping issues then yeah it stays for

00:19:37,760 --> 00:19:42,860
working storage and they're basically

00:19:40,550 --> 00:19:44,300
you've got tons of tons of global

00:19:42,860 --> 00:19:47,450
variables it's like if you ever use

00:19:44,300 --> 00:19:50,690
basic and you have go subs or they sort

00:19:47,450 --> 00:19:57,490
of seem like subroutines but they're not

00:19:50,690 --> 00:19:57,490
they're more like fancy go twos yeah

00:19:59,620 --> 00:20:05,470
we're working storage versus parameters

00:20:03,290 --> 00:20:05,470
to a function

00:20:06,430 --> 00:20:10,490
yeah there's no lexical very but working

00:20:08,720 --> 00:20:14,630
storage is where pretty much everything

00:20:10,490 --> 00:20:16,540
is there or I think but we didn't have

00:20:14,630 --> 00:20:18,560
to deal with these or so I think maybe

00:20:16,540 --> 00:20:20,420
variables that are kind of becoming from

00:20:18,560 --> 00:20:23,390
files like a file mapping might be

00:20:20,420 --> 00:20:26,300
something different yeah output records

00:20:23,390 --> 00:20:28,130
or report records yeah everyone kind of

00:20:26,300 --> 00:20:30,140
weird tradition most people who work in

00:20:28,130 --> 00:20:32,180
COBOL are on mainframes and we worked on

00:20:30,140 --> 00:20:34,190
something called Stratos computers so we

00:20:32,180 --> 00:20:37,100
did all of our i/o using the system

00:20:34,190 --> 00:20:38,180
calls on our machine instead of doing at

00:20:37,100 --> 00:20:42,650
the mainframe way so we never had to

00:20:38,180 --> 00:20:43,490
worry about JCL or episode ik although

00:20:42,650 --> 00:20:46,910
sometimes we didn't have to worry about

00:20:43,490 --> 00:20:48,350
episodic because we had this we are when

00:20:46,910 --> 00:20:49,520
we finish placing orders they went to

00:20:48,350 --> 00:20:50,300
the mainframe and everything was in a

00:20:49,520 --> 00:20:53,260
Pacific and that would occasionally

00:20:50,300 --> 00:20:53,260
cause some problems

00:20:54,980 --> 00:20:58,970
yeah because I was running out of time

00:21:00,170 --> 00:21:06,330
really they never I thought that was a

00:21:04,650 --> 00:21:08,250
clever idea when I learned about them we

00:21:06,330 --> 00:21:10,050
have a couple of minutes so I think we

00:21:08,250 --> 00:21:11,520
have to if whoever is the next person

00:21:10,050 --> 00:21:12,870
coming in should certainly come in but

00:21:11,520 --> 00:21:15,140
I'll keep chatting here until they kick

00:21:12,870 --> 00:21:15,140

YouTube URL: https://www.youtube.com/watch?v=pHQfEGgI030


