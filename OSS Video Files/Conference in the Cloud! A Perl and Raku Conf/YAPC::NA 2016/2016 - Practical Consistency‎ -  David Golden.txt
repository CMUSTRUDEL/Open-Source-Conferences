Title: 2016 - Practical Consistencyâ€Ž -  David Golden
Publication date: 2016-06-27
Playlist: YAPC::NA 2016
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:03,659
um for those of you who don't know me

00:00:01,650 --> 00:00:04,080
I'm David golden I've been working on

00:00:03,659 --> 00:00:06,210
pearl

00:00:04,080 --> 00:00:07,980
particularly parts of the tool chain for

00:00:06,210 --> 00:00:10,110
a long time I think my most popular

00:00:07,980 --> 00:00:12,719
module these days is path tiny you may

00:00:10,110 --> 00:00:16,500
have used it and I'm currently a staff

00:00:12,719 --> 00:00:18,660
engineer at MongoDB this is as you may

00:00:16,500 --> 00:00:20,430
have seen during our a/b sync up the 9

00:00:18,660 --> 00:00:22,619
o'clock slot it's always kind of

00:00:20,430 --> 00:00:25,080
interesting slot I had like the first

00:00:22,619 --> 00:00:26,699
slot of today last year and like in the

00:00:25,080 --> 00:00:28,019
first like 15 minutes the number of

00:00:26,699 --> 00:00:29,369
people in the room increased by like 50

00:00:28,019 --> 00:00:33,210
percent cuz like all those sort of

00:00:29,369 --> 00:00:35,460
people drifted in so what I wanted to do

00:00:33,210 --> 00:00:36,719
just to kill a couple minutes but

00:00:35,460 --> 00:00:39,450
hopefully still add some valid everyone

00:00:36,719 --> 00:00:40,920
is I want to ask a couple questions of

00:00:39,450 --> 00:00:42,780
the audience particularly round what

00:00:40,920 --> 00:00:45,090
versions of well people are using

00:00:42,780 --> 00:00:46,559
there's a lot of debates go on in Perl

00:00:45,090 --> 00:00:47,969
tool chain circles about what versions

00:00:46,559 --> 00:00:49,670
of Perl do we have to support and I got

00:00:47,969 --> 00:00:52,739
into one of these recently at work even

00:00:49,670 --> 00:00:53,789
and I find it conferences are a great

00:00:52,739 --> 00:00:55,110
way to find out like what are people

00:00:53,789 --> 00:00:56,489
actually dealing with in the field so

00:00:55,110 --> 00:01:01,129
I'm sort of curious does anybody in the

00:00:56,489 --> 00:01:03,840
room using 5:6 in production Perl 5.6

00:01:01,129 --> 00:01:06,180
excellent great news I've never seen

00:01:03,840 --> 00:01:07,560
anybody still using 5.6 ever but I keep

00:01:06,180 --> 00:01:09,210
asking because I keep hearing that there

00:01:07,560 --> 00:01:10,830
might be these people out there how many

00:01:09,210 --> 00:01:15,470
people are using some version of 5/8 in

00:01:10,830 --> 00:01:19,590
production handful of people excuse me

00:01:15,470 --> 00:01:22,049
no I just I don't I don't think it's

00:01:19,590 --> 00:01:24,960
anybody's choice we all heard Rick's

00:01:22,049 --> 00:01:27,540
talk yesterday like 514 a guy but it's a

00:01:24,960 --> 00:01:33,299
510 in production ok a handful of people

00:01:27,540 --> 00:01:37,820
how about 512 slide 14 okay a lot of 514

00:01:33,299 --> 00:01:40,770
is 516 a couple of 518 520 or later

00:01:37,820 --> 00:01:42,570
all right so oh that's great news a lot

00:01:40,770 --> 00:01:43,829
of people are actually sort of like out

00:01:42,570 --> 00:01:46,320
there with a lot of the recent versions

00:01:43,829 --> 00:01:47,909
and I'm glad to see that particular has

00:01:46,320 --> 00:01:48,960
a tool chain man chatter hey Rick you

00:01:47,909 --> 00:01:50,159
just missed it I asked the room what

00:01:48,960 --> 00:01:53,100
versions they're using there are still a

00:01:50,159 --> 00:01:55,680
couple people on like 580 510 514 lots

00:01:53,100 --> 00:01:58,829
of people 518 520 lots of people you

00:01:55,680 --> 00:02:01,220
know five six I asked know five six and

00:01:58,829 --> 00:02:04,730
I asked

00:02:01,220 --> 00:02:07,040
I asked in the Baltimore DC Pro workshop

00:02:04,730 --> 00:02:08,960
no five-six there either so I want to

00:02:07,040 --> 00:02:10,520
try to prove as much as you can prove a

00:02:08,960 --> 00:02:12,170
negative at five six five six is

00:02:10,520 --> 00:02:13,580
actually not in use and so when somebody

00:02:12,170 --> 00:02:19,490
says can you please make this work on

00:02:13,580 --> 00:02:21,140
five six I can say no five six should be

00:02:19,490 --> 00:02:23,450
dead the tool chain doesn't support it

00:02:21,140 --> 00:02:26,570
but there are people who want things to

00:02:23,450 --> 00:02:28,250
work even back to five six okay the

00:02:26,570 --> 00:02:29,930
other obligatory note I just want to say

00:02:28,250 --> 00:02:32,810
of course I'm from MongoDB as all

00:02:29,930 --> 00:02:36,650
startups are we are hiring particularly

00:02:32,810 --> 00:02:38,930
we do a lot of work in C++ go and Java

00:02:36,650 --> 00:02:40,610
I'm on the drivers team where we have to

00:02:38,930 --> 00:02:42,080
have people who are experts in like ten

00:02:40,610 --> 00:02:43,790
different languages so my group actually

00:02:42,080 --> 00:02:44,720
is looking for polygons programmers

00:02:43,790 --> 00:02:46,880
people who can work across multiple

00:02:44,720 --> 00:02:49,760
languages and we also have a number of

00:02:46,880 --> 00:02:51,140
engineering positions pre-sales

00:02:49,760 --> 00:02:53,150
engineering and support engineering

00:02:51,140 --> 00:02:54,020
where it doesn't matter what languages

00:02:53,150 --> 00:02:56,180
you know you just need to be smart

00:02:54,020 --> 00:02:58,550
technical people who can help users

00:02:56,180 --> 00:03:00,080
customers figure out how to use the

00:02:58,550 --> 00:03:01,820
database better if you're all interested

00:03:00,080 --> 00:03:04,940
check out the website or find me during

00:03:01,820 --> 00:03:07,730
the break I'm happy to talk about it so

00:03:04,940 --> 00:03:08,900
now we've sort of a few more people like

00:03:07,730 --> 00:03:11,360
Rick you've drifted in so we'll get back

00:03:08,900 --> 00:03:12,860
to practical consistency understanding

00:03:11,360 --> 00:03:14,959
consistency is really essential for

00:03:12,860 --> 00:03:16,730
working with distributed systems and

00:03:14,959 --> 00:03:19,400
when I talk about practical what I mean

00:03:16,730 --> 00:03:21,230
is not sort of like jargon and theory

00:03:19,400 --> 00:03:23,900
and and academia I've read a lot of

00:03:21,230 --> 00:03:25,640
academic papers around distributed

00:03:23,900 --> 00:03:26,810
systems and consistency and they were

00:03:25,640 --> 00:03:28,130
real there to work through and the

00:03:26,810 --> 00:03:29,870
average programmer doesn't need to know

00:03:28,130 --> 00:03:32,830
all this stuff and so what I want to do

00:03:29,870 --> 00:03:35,060
today is give a number of practical

00:03:32,830 --> 00:03:36,200
questions ways of thinking about

00:03:35,060 --> 00:03:38,030
distributed systems that will help

00:03:36,200 --> 00:03:41,170
people I think in their day to day lives

00:03:38,030 --> 00:03:43,640
of programming against such systems so

00:03:41,170 --> 00:03:45,110
what is a distributed system little

00:03:43,640 --> 00:03:47,269
recap if people aren't familiar

00:03:45,110 --> 00:03:49,130
distributed system means that we have

00:03:47,269 --> 00:03:51,470
data processing spread over time and

00:03:49,130 --> 00:03:52,870
space which Einstein would sort of say

00:03:51,470 --> 00:03:55,959
is kind of the same

00:03:52,870 --> 00:03:57,220
and I'll give an example here of MongoDB

00:03:55,959 --> 00:03:58,930
and you'll notice there's a red arrow

00:03:57,220 --> 00:04:01,060
kind of up in the corner everywhere the

00:03:58,930 --> 00:04:03,700
MongoDB logo shows I'm giving an example

00:04:01,060 --> 00:04:04,989
that is MongoDB specific and so even if

00:04:03,700 --> 00:04:06,909
I don't call it out on a slot if you see

00:04:04,989 --> 00:04:08,769
that little logo that means this is a

00:04:06,909 --> 00:04:11,980
MongoDB example of how a distributed

00:04:08,769 --> 00:04:14,410
system might work this picture here will

00:04:11,980 --> 00:04:16,239
see variations of this throughout so

00:04:14,410 --> 00:04:19,630
I'll take a moment to sort of explain it

00:04:16,239 --> 00:04:21,330
MongoDB is a distributed database how

00:04:19,630 --> 00:04:24,550
many people are familiar with MongoDB

00:04:21,330 --> 00:04:26,800
alright fair number good so I don't have

00:04:24,550 --> 00:04:28,270
to do too much recap of MongoDB itself

00:04:26,800 --> 00:04:32,289
so Mamba DB as a distributed system

00:04:28,270 --> 00:04:35,110
works by having a client here the xkcd

00:04:32,289 --> 00:04:36,520
style black hat is the client can read

00:04:35,110 --> 00:04:39,190
and write to a node which is called a

00:04:36,520 --> 00:04:41,740
primary and that node synchronizes data

00:04:39,190 --> 00:04:43,479
out to other nodes near B and C which

00:04:41,740 --> 00:04:45,340
are called secondaries and the client

00:04:43,479 --> 00:04:46,600
can also get a read-only view can read

00:04:45,340 --> 00:04:48,940
from secondaries but can't write to

00:04:46,600 --> 00:04:50,949
secondary so this is a what's called

00:04:48,940 --> 00:04:52,810
like chained replication so things go to

00:04:50,949 --> 00:04:54,639
a leader rights go to a leader and then

00:04:52,810 --> 00:04:55,950
replication gets sort of follows out

00:04:54,639 --> 00:04:58,000
from the leader to other systems

00:04:55,950 --> 00:04:59,169
here's another system that's a

00:04:58,000 --> 00:05:00,160
distribution that a lot of people might

00:04:59,169 --> 00:05:03,250
be familiar with how many people have

00:05:00,160 --> 00:05:05,169
ever heard of memcache D almost every

00:05:03,250 --> 00:05:09,280
hand I think is on the people who didn't

00:05:05,169 --> 00:05:10,840
put their hands up her line or lazy so

00:05:09,280 --> 00:05:12,190
memcache D and a database is another

00:05:10,840 --> 00:05:13,960
form a distributed system and here the

00:05:12,190 --> 00:05:15,520
client reads and writes to both of them

00:05:13,960 --> 00:05:17,650
and we'll come back to sort of what the

00:05:15,520 --> 00:05:19,690
implications of that are later on here's

00:05:17,650 --> 00:05:22,419
another example of a distributed system

00:05:19,690 --> 00:05:23,740
at CD at CD is a distributed reliable

00:05:22,419 --> 00:05:25,599
key value store it's used for like

00:05:23,740 --> 00:05:27,370
synchronizing configuration across like

00:05:25,599 --> 00:05:29,320
docker clusters and things like that

00:05:27,370 --> 00:05:30,520
it works where the client can read or

00:05:29,320 --> 00:05:32,080
write to any node and the nodes

00:05:30,520 --> 00:05:33,970
synchronize all of that both amongst

00:05:32,080 --> 00:05:35,500
themselves and that has certain

00:05:33,970 --> 00:05:37,090
implications so there are lots of

00:05:35,500 --> 00:05:39,849
different ways of organizing a

00:05:37,090 --> 00:05:40,960
distributed system and the principles

00:05:39,849 --> 00:05:42,160
I'm going to talk about today apply to

00:05:40,960 --> 00:05:43,389
all of them and the questions that I

00:05:42,160 --> 00:05:45,250
asked that I'm gonna bring up apply to

00:05:43,389 --> 00:05:48,789
all of them and even though I give you

00:05:45,250 --> 00:05:49,570
MongoDB specific examples the examples

00:05:48,789 --> 00:05:51,099
are things that you can sort of

00:05:49,570 --> 00:05:53,349
translate into any system that you're

00:05:51,099 --> 00:05:54,789
working with so why do you use

00:05:53,349 --> 00:05:56,349
distributed systems well the number one

00:05:54,789 --> 00:05:58,870
reason is scale sometimes you just can't

00:05:56,349 --> 00:06:00,099
fit everything onto one box or it's too

00:05:58,870 --> 00:06:00,670
expensive to try to fit everything onto

00:06:00,099 --> 00:06:01,870
one box

00:06:00,670 --> 00:06:03,790
it's cheaper to spread things across a

00:06:01,870 --> 00:06:05,500
number of small boxes

00:06:03,790 --> 00:06:08,170
another reason is performance lots of

00:06:05,500 --> 00:06:09,970
things we do in this day and age with

00:06:08,170 --> 00:06:11,710
big data we could actually do it in

00:06:09,970 --> 00:06:13,420
parallel so you can sort of if you can

00:06:11,710 --> 00:06:16,000
spread the work across multiple boxes

00:06:13,420 --> 00:06:18,040
you can reduce the time you have to wait

00:06:16,000 --> 00:06:20,440
to freedom to get things done

00:06:18,040 --> 00:06:21,670
another reason is redundancy by having

00:06:20,440 --> 00:06:23,500
multiple copies of data in multiple

00:06:21,670 --> 00:06:25,510
systems and you're sort of protected if

00:06:23,500 --> 00:06:28,210
a node or a data center or something

00:06:25,510 --> 00:06:30,190
goes down because you have replicas that

00:06:28,210 --> 00:06:31,570
can take over and we'll focus mostly on

00:06:30,190 --> 00:06:33,250
this today because it's when you have

00:06:31,570 --> 00:06:34,660
copies of data in a distributed system

00:06:33,250 --> 00:06:38,050
that you kind of get into the most

00:06:34,660 --> 00:06:41,380
trouble so how do we break distributed

00:06:38,050 --> 00:06:43,690
systems one way is by races races

00:06:41,380 --> 00:06:45,400
there's a great David

00:06:43,690 --> 00:06:46,990
Oh did a great talk out today about file

00:06:45,400 --> 00:06:48,370
locking and how you can have races just

00:06:46,990 --> 00:06:49,360
to try to write two files and what do

00:06:48,370 --> 00:06:51,900
you do about it

00:06:49,360 --> 00:06:54,520
and dealing with races is a big part of

00:06:51,900 --> 00:06:56,260
figuring out how to make distribute

00:06:54,520 --> 00:06:58,030
systems work well so races are a problem

00:06:56,260 --> 00:06:59,560
the other problem is partitions when

00:06:58,030 --> 00:07:01,000
some nodes in a system where some

00:06:59,560 --> 00:07:03,160
clients can't see all the nodes or the

00:07:01,000 --> 00:07:04,900
nodes can't see each other this praise

00:07:03,160 --> 00:07:07,240
causes problems for distributed systems

00:07:04,900 --> 00:07:09,400
now how do we get things like races and

00:07:07,240 --> 00:07:11,800
partitions well particularly thinking

00:07:09,400 --> 00:07:14,650
about partitions a lot of reasons one is

00:07:11,800 --> 00:07:16,780
just a crash right a server crashes the

00:07:14,650 --> 00:07:19,270
program that you know database crashes

00:07:16,780 --> 00:07:21,760
these things happen and so a crash

00:07:19,270 --> 00:07:23,530
consider take a node offline in a packet

00:07:21,760 --> 00:07:25,180
loss essentially from an outside

00:07:23,530 --> 00:07:26,620
observers perspective it almost doesn't

00:07:25,180 --> 00:07:28,270
matter whether this whether the

00:07:26,620 --> 00:07:29,940
processes crashed the server has crashed

00:07:28,270 --> 00:07:31,300
or a backhoe has cut through the the

00:07:29,940 --> 00:07:33,130
network line

00:07:31,300 --> 00:07:34,450
like if you can't get packets back and

00:07:33,130 --> 00:07:37,840
forth essentially that node has gone to

00:07:34,450 --> 00:07:39,430
buy another interesting situation that

00:07:37,840 --> 00:07:43,270
people encounter is garbage collections

00:07:39,430 --> 00:07:44,620
so garbage collection might pause your

00:07:43,270 --> 00:07:46,480
application for a while and nothing

00:07:44,620 --> 00:07:48,490
happens and in that time of nothing

00:07:46,480 --> 00:07:49,660
happens maybe something was expecting

00:07:48,490 --> 00:07:50,860
something to happen elsewhere in the

00:07:49,660 --> 00:07:52,960
system and it looks like the node has

00:07:50,860 --> 00:07:54,490
gone away and even just processing

00:07:52,960 --> 00:07:56,650
swapping anything that sort of takes the

00:07:54,490 --> 00:07:59,320
process offline at a moment when it was

00:07:56,650 --> 00:08:00,700
needing to do something is a situation

00:07:59,320 --> 00:08:04,150
that can cause a race or look like a

00:08:00,700 --> 00:08:06,650
partition so I'm going to give an

00:08:04,150 --> 00:08:09,890
example using memcache D

00:08:06,650 --> 00:08:12,260
this is what I alluded to so memcache

00:08:09,890 --> 00:08:13,760
the kind of works like this like I've

00:08:12,260 --> 00:08:15,590
kind of a quick recap this is kind of

00:08:13,760 --> 00:08:17,960
the Wikipedia level how men cash B works

00:08:15,590 --> 00:08:20,090
so let's imagine black hat wants to

00:08:17,960 --> 00:08:23,390
write a value in for a particular key

00:08:20,090 --> 00:08:24,770
value a reads it back out of the

00:08:23,390 --> 00:08:26,120
database to make sure that like what

00:08:24,770 --> 00:08:27,980
they were stored this was now was there

00:08:26,120 --> 00:08:29,450
and then stores that value over men

00:08:27,980 --> 00:08:30,650
cached it's a great net I wrote it to

00:08:29,450 --> 00:08:31,970
the database I pulled it back to make

00:08:30,650 --> 00:08:33,050
sure that's what was in the database and

00:08:31,970 --> 00:08:35,870
now I've saved it off into the cache

00:08:33,050 --> 00:08:37,310
great now I have and then after that

00:08:35,870 --> 00:08:38,750
anytime I read I'm gonna check the cache

00:08:37,310 --> 00:08:40,160
first and I'd rather read from the cache

00:08:38,750 --> 00:08:41,720
that have to read from my database to

00:08:40,160 --> 00:08:44,630
keep the load off my database right this

00:08:41,720 --> 00:08:47,720
kind of Bob simple standard memcache B

00:08:44,630 --> 00:08:50,270
well how does that go wrong well I'm

00:08:47,720 --> 00:08:51,860
gonna rewind that to this point so black

00:08:50,270 --> 00:08:53,840
hat has written the value into the

00:08:51,860 --> 00:08:55,340
database has read it back and right at

00:08:53,840 --> 00:08:56,750
this point there's a garbage collection

00:08:55,340 --> 00:08:57,950
policy now here in Perl we don't worry

00:08:56,750 --> 00:08:59,330
about garbage collection pauses because

00:08:57,950 --> 00:09:00,890
we reference count instead of garbage

00:08:59,330 --> 00:09:02,420
collecting but you can imagine a process

00:09:00,890 --> 00:09:05,690
swap or something else that takes the

00:09:02,420 --> 00:09:06,170
system offline for a moment and at this

00:09:05,690 --> 00:09:08,510
point

00:09:06,170 --> 00:09:10,430
black hat stops and then white hat comes

00:09:08,510 --> 00:09:12,200
along and manages to go through the same

00:09:10,430 --> 00:09:13,970
process without interruption writes B

00:09:12,200 --> 00:09:15,470
into the database pulls it back down

00:09:13,970 --> 00:09:17,810
stores it up to memcache T and then

00:09:15,470 --> 00:09:19,070
black hat unpause it great I'm done I

00:09:17,810 --> 00:09:20,960
can finish doing what I'm doing them the

00:09:19,070 --> 00:09:23,240
next thing I have to do is store a into

00:09:20,960 --> 00:09:24,920
memcache D and now you're really screwed

00:09:23,240 --> 00:09:26,240
because now both black hat and white hat

00:09:24,920 --> 00:09:27,320
are always gonna go look at memcache B

00:09:26,240 --> 00:09:29,960
first they're always gonna look and find

00:09:27,320 --> 00:09:32,210
the value a even though B is over in the

00:09:29,960 --> 00:09:33,890
database and those of you have worked

00:09:32,210 --> 00:09:35,120
with this before I think oh yes but I

00:09:33,890 --> 00:09:36,500
have a timeout or I have a

00:09:35,120 --> 00:09:37,550
reconciliation processor yeah you have

00:09:36,500 --> 00:09:39,320
to a lot of other things you have to do

00:09:37,550 --> 00:09:41,960
to find that you have an inconsistency

00:09:39,320 --> 00:09:43,430
and fix it and this is why a database

00:09:41,960 --> 00:09:46,640
and memcache key is not a good

00:09:43,430 --> 00:09:48,080
distributive system at least it's not

00:09:46,640 --> 00:09:49,850
good from distributed systems theory

00:09:48,080 --> 00:09:51,350
perspective but as we all know lots of

00:09:49,850 --> 00:09:53,150
people do this so it's actually probably

00:09:51,350 --> 00:09:55,700
good enough there's a lot of cases where

00:09:53,150 --> 00:09:57,380
that's fine if you're writing data and

00:09:55,700 --> 00:09:58,190
it's immutable you're not going to have

00:09:57,380 --> 00:09:59,210
this problem because you're not

00:09:58,190 --> 00:10:00,350
colliding like there's a lot of

00:09:59,210 --> 00:10:02,210
situations when this is a perfectly

00:10:00,350 --> 00:10:03,350
acceptable thing to do but I want you to

00:10:02,210 --> 00:10:04,970
think about that principle of how the

00:10:03,350 --> 00:10:06,410
race suddenly winds up with different

00:10:04,970 --> 00:10:07,250
values of data that you're expecting to

00:10:06,410 --> 00:10:10,170
have the same

00:10:07,250 --> 00:10:14,370
so what makes for a good distributed

00:10:10,170 --> 00:10:16,560
system back in 1999 this guy Eric Brewer

00:10:14,370 --> 00:10:18,480
who's at Berkeley and man Google now I

00:10:16,560 --> 00:10:20,370
think came up with something called like

00:10:18,480 --> 00:10:21,150
the cat fear people have heard of the

00:10:20,370 --> 00:10:23,040
cat theorem

00:10:21,150 --> 00:10:25,680
fair number of people okay so the cap

00:10:23,040 --> 00:10:27,720
theorem CA P stands for consistency

00:10:25,680 --> 00:10:30,540
availability and partition tolerance and

00:10:27,720 --> 00:10:31,860
what what first theorem said was well

00:10:30,540 --> 00:10:33,590
you only get to pick two of these you

00:10:31,860 --> 00:10:35,970
only have two of these ever at a time

00:10:33,590 --> 00:10:38,520
and so if we think about consistency

00:10:35,970 --> 00:10:40,080
consistency is the idea that there

00:10:38,520 --> 00:10:41,430
appears to be a single copy of the data

00:10:40,080 --> 00:10:42,900
from an outside observer so even if we

00:10:41,430 --> 00:10:44,400
have multiple copies of the data spread

00:10:42,900 --> 00:10:46,620
around from the out clients perspective

00:10:44,400 --> 00:10:47,850
looking into the distributed system it

00:10:46,620 --> 00:10:50,160
only ever appears that there's one copy

00:10:47,850 --> 00:10:52,200
of the data and any modifications appear

00:10:50,160 --> 00:10:53,340
to happen atomically there are some

00:10:52,200 --> 00:10:55,050
weaker models people might have heard

00:10:53,340 --> 00:10:56,370
with the term eventual consistency and

00:10:55,050 --> 00:10:57,210
there's a strict consistency and as you

00:10:56,370 --> 00:10:59,460
get into the literature there's all

00:10:57,210 --> 00:11:00,540
different variations of consistency and

00:10:59,460 --> 00:11:01,560
it's one of the things that I find sort

00:11:00,540 --> 00:11:02,970
of problematic because it's actually

00:11:01,560 --> 00:11:06,230
hard to sort of figure out what all this

00:11:02,970 --> 00:11:08,340
actually means in practice so the other

00:11:06,230 --> 00:11:10,470
factor is availability so this means

00:11:08,340 --> 00:11:12,960
that a node failing either a crash

00:11:10,470 --> 00:11:14,610
garbage collection pause anything that

00:11:12,960 --> 00:11:15,960
takes a node offline doesn't prevent the

00:11:14,610 --> 00:11:18,480
surviving nodes from continuing to

00:11:15,960 --> 00:11:19,800
operate successfully and then partition

00:11:18,480 --> 00:11:21,900
tolerance partition tolerance means that

00:11:19,800 --> 00:11:24,480
the network can lose arbitrarily many

00:11:21,900 --> 00:11:27,090
messages from any node and everything

00:11:24,480 --> 00:11:28,590
else holds true and as anybody who's

00:11:27,090 --> 00:11:30,810
ever worked with real systems and the

00:11:28,590 --> 00:11:31,880
world knows we can't avoid partitions so

00:11:30,810 --> 00:11:35,280
you don't actually get a real choice

00:11:31,880 --> 00:11:36,930
between all the combinations brewer's

00:11:35,280 --> 00:11:38,400
that's really only get CP or ap you

00:11:36,930 --> 00:11:40,230
could have a system that is consistent

00:11:38,400 --> 00:11:42,030
in the face of partitions or you have a

00:11:40,230 --> 00:11:43,650
system which is available in this and in

00:11:42,030 --> 00:11:46,410
the sense of partitions so consistent

00:11:43,650 --> 00:11:48,920
means as long as everything is talking

00:11:46,410 --> 00:11:52,350
to each other everything's fine but if

00:11:48,920 --> 00:11:54,170
node goes away then everything stops and

00:11:52,350 --> 00:11:58,200
I can't do any more operations because

00:11:54,170 --> 00:12:00,690
the network is down an available system

00:11:58,200 --> 00:12:02,310
would say well sure a node is down but I

00:12:00,690 --> 00:12:03,450
can keep operating and yeah okay things

00:12:02,310 --> 00:12:04,680
aren't going to be consistent and we'll

00:12:03,450 --> 00:12:05,040
kind of figure out how to reconcile it

00:12:04,680 --> 00:12:06,180
later

00:12:05,040 --> 00:12:09,150
so that's kind of the choice that he

00:12:06,180 --> 00:12:10,710
kind of laid out and then about five

00:12:09,150 --> 00:12:11,970
years ago this guy Daniel Abadi came

00:12:10,710 --> 00:12:13,140
along and said you know this cap thing

00:12:11,970 --> 00:12:14,610
is kind of simplistic doesn't really

00:12:13,140 --> 00:12:15,089
capture what we really care about in the

00:12:14,610 --> 00:12:17,399
real world

00:12:15,089 --> 00:12:19,579
and so he said I made a couple of this

00:12:17,399 --> 00:12:21,719
new thing and I'm gonna call it PAC elf

00:12:19,579 --> 00:12:23,219
so let's flip around the cap and let's

00:12:21,719 --> 00:12:25,199
add some other stuff on it and PAC ELQ

00:12:23,219 --> 00:12:27,179
is trying to address the fact that while

00:12:25,199 --> 00:12:28,919
we think about partitions in an extreme

00:12:27,179 --> 00:12:30,629
case most the time we don't have a

00:12:28,919 --> 00:12:32,429
position so let's think about that so he

00:12:30,629 --> 00:12:33,659
says that we need to really need to

00:12:32,429 --> 00:12:36,839
think about distributed systems like

00:12:33,659 --> 00:12:38,099
this if there's our partition then we

00:12:36,839 --> 00:12:39,779
have to pick between availability and

00:12:38,099 --> 00:12:42,449
consistency so this kind of Brewers the

00:12:39,779 --> 00:12:44,449
theorem here but otherwise else we have

00:12:42,449 --> 00:12:46,439
to choose between low latency and

00:12:44,449 --> 00:12:48,029
consistency and so we're always kind of

00:12:46,439 --> 00:12:49,559
we have to think about the trade-offs we

00:12:48,029 --> 00:12:51,479
make under two different regimes one

00:12:49,559 --> 00:12:52,589
when things are going horribly wrong and

00:12:51,479 --> 00:12:54,929
the other when things are operating

00:12:52,589 --> 00:12:56,369
normally and if you kind of notice that

00:12:54,929 --> 00:12:57,509
consistencies in both places what

00:12:56,369 --> 00:12:59,549
changes is this question of availability

00:12:57,509 --> 00:13:01,169
and latency and so a lot of what I'll be

00:12:59,549 --> 00:13:02,549
talking about later on are some of these

00:13:01,169 --> 00:13:06,269
trade-offs between availability of

00:13:02,549 --> 00:13:08,459
latency in different systems personally

00:13:06,269 --> 00:13:10,609
I find even that to be still sort of

00:13:08,459 --> 00:13:12,449
simplistic and kind of ivory tower

00:13:10,609 --> 00:13:13,769
because it doesn't really sort of

00:13:12,449 --> 00:13:16,289
distinguish between the notions of like

00:13:13,769 --> 00:13:18,329
reads and writes which might give you

00:13:16,289 --> 00:13:21,389
different perspectives on this and I'll

00:13:18,329 --> 00:13:22,979
give a MongoDB example so on MongoDB you

00:13:21,389 --> 00:13:24,299
can have a replica set and you can have

00:13:22,979 --> 00:13:26,189
a partition and on one side of the

00:13:24,299 --> 00:13:27,899
partition if you have a odd number of

00:13:26,189 --> 00:13:28,919
nodes you have a majority of nodes on

00:13:27,899 --> 00:13:29,939
one side of the finish you know on the

00:13:28,919 --> 00:13:32,009
other side of the petition you'd have a

00:13:29,939 --> 00:13:34,229
minority of the nodes and on the

00:13:32,009 --> 00:13:36,869
majority side you can still a client can

00:13:34,229 --> 00:13:37,889
read and write and the writing looks

00:13:36,869 --> 00:13:39,929
consistent you don't sort you're not

00:13:37,889 --> 00:13:41,219
sort of aware that actually there's some

00:13:39,929 --> 00:13:43,769
minority partition that isn't getting

00:13:41,219 --> 00:13:45,809
those updates so to the outside observer

00:13:43,769 --> 00:13:48,509
it still looks consistent which maybe

00:13:45,809 --> 00:13:50,459
satisfies Brewers theorem I'm not so

00:13:48,509 --> 00:13:52,619
sure on the minority side you can't

00:13:50,459 --> 00:13:54,179
write you're not available so to try to

00:13:52,619 --> 00:13:55,259
preserve some sense of consistency you

00:13:54,179 --> 00:13:57,089
can't actually you're right you're not

00:13:55,259 --> 00:13:58,529
available but you can read stale data

00:13:57,089 --> 00:14:00,389
you are sort of available so when I look

00:13:58,529 --> 00:14:01,739
at this well it appears consistent even

00:14:00,389 --> 00:14:02,819
though it's not you're available you're

00:14:01,739 --> 00:14:03,299
not available ear available but you're

00:14:02,819 --> 00:14:06,119
stale

00:14:03,299 --> 00:14:09,449
does that fit into brewer a body's sort

00:14:06,119 --> 00:14:10,379
of frame of reference no so this is what

00:14:09,449 --> 00:14:12,119
I want to talk about practical

00:14:10,379 --> 00:14:13,589
consistency leaving all that theory

00:14:12,119 --> 00:14:14,950
behind which you will hear thrown around

00:14:13,589 --> 00:14:17,170
by people who want to have

00:14:14,950 --> 00:14:18,430
arguments on the Internet I like

00:14:17,170 --> 00:14:19,750
thinking about what are some practical

00:14:18,430 --> 00:14:25,300
questions that we should be considering

00:14:19,750 --> 00:14:26,860
instead so one of the most important is

00:14:25,300 --> 00:14:29,860
really around around rights do I know

00:14:26,860 --> 00:14:32,230
when a right is committed and how do I

00:14:29,860 --> 00:14:33,340
read only committed and or only current

00:14:32,230 --> 00:14:35,470
data there's kind of two critical

00:14:33,340 --> 00:14:38,680
questions we want to think about writes

00:14:35,470 --> 00:14:40,870
and reads and what's important and so

00:14:38,680 --> 00:14:45,370
thinking about rights now there's kind

00:14:40,870 --> 00:14:46,690
of three things so we have I want you to

00:14:45,370 --> 00:14:48,520
think about durability

00:14:46,690 --> 00:14:50,440
I'll explain these convergence and error

00:14:48,520 --> 00:14:53,230
recovery and I just want to take a

00:14:50,440 --> 00:14:55,870
little aside about durability so when

00:14:53,230 --> 00:14:57,430
people write databases historically like

00:14:55,870 --> 00:15:00,040
things are committed and durable when

00:14:57,430 --> 00:15:01,270
you've got the the operation written to

00:15:00,040 --> 00:15:03,040
a journal the journal has been

00:15:01,270 --> 00:15:04,870
successfully flushed to your hard drive

00:15:03,040 --> 00:15:06,010
and your hard drive hasn't lied to you

00:15:04,870 --> 00:15:08,350
about whether it's actually put it to

00:15:06,010 --> 00:15:10,180
the medium or not which is whole sort of

00:15:08,350 --> 00:15:11,950
interesting question itself in

00:15:10,180 --> 00:15:13,420
distributed systems land people think

00:15:11,950 --> 00:15:15,460
about things being durable or committed

00:15:13,420 --> 00:15:17,050
when you have a replicated copy in

00:15:15,460 --> 00:15:18,280
enough places that you'll survive the

00:15:17,050 --> 00:15:19,570
loss of certain notes so we're not

00:15:18,280 --> 00:15:20,860
terribly worried about whether things

00:15:19,570 --> 00:15:22,540
are actually fully flush your dish we're

00:15:20,860 --> 00:15:24,460
worried about have things gotten to

00:15:22,540 --> 00:15:27,790
enough places that nodes can can go away

00:15:24,460 --> 00:15:29,070
and never come back and and the data

00:15:27,790 --> 00:15:31,840
will still be there and this is I think

00:15:29,070 --> 00:15:33,820
partly in kind of the devops world

00:15:31,840 --> 00:15:36,370
there's been the shift in mentality from

00:15:33,820 --> 00:15:37,600
kind of servers as pets to servers as

00:15:36,370 --> 00:15:39,250
cattle if people have heard that

00:15:37,600 --> 00:15:41,050
expression servers the cattle so the

00:15:39,250 --> 00:15:42,190
idea is we're not as worried about a

00:15:41,050 --> 00:15:43,840
server going down and then we're gonna

00:15:42,190 --> 00:15:45,070
bring it back up and nurse it back to

00:15:43,840 --> 00:15:46,780
life and so we need to have all the data

00:15:45,070 --> 00:15:48,250
recovered it's like if the server goes

00:15:46,780 --> 00:15:49,810
down it's dead we're killing it we're

00:15:48,250 --> 00:15:52,180
gonna bring up another cloud node and

00:15:49,810 --> 00:15:54,400
and we'll continue from there and so the

00:15:52,180 --> 00:15:55,600
notion of whether something is journaled

00:15:54,400 --> 00:15:56,650
and durable on the disk is less

00:15:55,600 --> 00:15:57,880
important if you're thinking about just

00:15:56,650 --> 00:16:01,290
blowing away servers that die and

00:15:57,880 --> 00:16:03,310
bringing up new ones so how do we know

00:16:01,290 --> 00:16:05,550
when rights are occur but do we even

00:16:03,310 --> 00:16:07,750
know when rights are durable and a

00:16:05,550 --> 00:16:08,440
little bit we can talk about later like

00:16:07,750 --> 00:16:11,590
do we even care

00:16:08,440 --> 00:16:14,560
so I'll give another bongo to be example

00:16:11,590 --> 00:16:16,000
here so in MongoDB client writes to the

00:16:14,560 --> 00:16:18,250
primary node so we're gonna write the

00:16:16,000 --> 00:16:19,300
value of AE to the primary and the idea

00:16:18,250 --> 00:16:23,230
is that this is going to get replicated

00:16:19,300 --> 00:16:25,300
off to the other nodes once that value

00:16:23,230 --> 00:16:26,100
has reached a majority of nodes two out

00:16:25,300 --> 00:16:27,660
of the three in this

00:16:26,100 --> 00:16:30,000
then we consider this to be committed at

00:16:27,660 --> 00:16:31,589
this point even if the data doesn't make

00:16:30,000 --> 00:16:33,329
it to the other node when we think this

00:16:31,589 --> 00:16:35,759
is then this is sort of committed in the

00:16:33,329 --> 00:16:39,029
sense that it's not going to go away in

00:16:35,759 --> 00:16:40,649
the face of a node failure on the other

00:16:39,029 --> 00:16:42,060
hand what if there's our partition

00:16:40,649 --> 00:16:44,430
separating the primary away from the

00:16:42,060 --> 00:16:46,019
other nodes well at this point now even

00:16:44,430 --> 00:16:47,670
if you write the value B to the primary

00:16:46,019 --> 00:16:49,529
can't replicate it can't make it to the

00:16:47,670 --> 00:16:51,600
other other nodes and so the question is

00:16:49,529 --> 00:16:52,560
how do we know that that happens do we

00:16:51,600 --> 00:16:55,170
know that that happened

00:16:52,560 --> 00:16:57,600
so MongoDB has a feature called a write

00:16:55,170 --> 00:16:59,250
concern and you said it in the sort of

00:16:57,600 --> 00:17:01,819
connection options of your client like

00:16:59,250 --> 00:17:07,230
this assuming that you have used MongoDB

00:17:01,819 --> 00:17:09,449
above all this so w1 says hey server as

00:17:07,230 --> 00:17:11,309
soon as you got this like let me know

00:17:09,449 --> 00:17:12,600
about the other one that you should use

00:17:11,309 --> 00:17:14,850
and probably nothing in between its

00:17:12,600 --> 00:17:15,959
majority which says only tell me a write

00:17:14,850 --> 00:17:17,220
is committed when it's reached at

00:17:15,959 --> 00:17:20,250
majority of nodes and it looks kind of

00:17:17,220 --> 00:17:22,679
like this so with w1 you write the value

00:17:20,250 --> 00:17:24,839
de and as soon as a has it committed

00:17:22,679 --> 00:17:27,000
locally which does mean Journal than and

00:17:24,839 --> 00:17:30,330
all the rest of us says ok great ok I'm

00:17:27,000 --> 00:17:31,409
done you're right succeeded right so you

00:17:30,330 --> 00:17:33,600
know that at least you're right got to

00:17:31,409 --> 00:17:36,270
one server B if on the other hand you

00:17:33,600 --> 00:17:38,990
say W majority you do you're right and

00:17:36,270 --> 00:17:41,220
now you wait and while you're waiting

00:17:38,990 --> 00:17:43,169
the data starts replicating to other

00:17:41,220 --> 00:17:45,150
servers and when it has reached a

00:17:43,169 --> 00:17:47,250
majority and the primary finds out that

00:17:45,150 --> 00:17:48,900
it's racial majority it then tells you

00:17:47,250 --> 00:17:51,210
ok so now you have done your right but

00:17:48,900 --> 00:17:53,549
now you're blocked waiting so if you

00:17:51,210 --> 00:17:54,630
want to fire and forget because it's

00:17:53,549 --> 00:17:56,460
data maybe you don't care if it

00:17:54,630 --> 00:17:58,230
replicates or not you can use w1 if you

00:17:56,460 --> 00:18:00,539
really want to know that it got dirty

00:17:58,230 --> 00:18:01,740
became durable you can use W majority

00:18:00,539 --> 00:18:04,230
and you can wait so again there's always

00:18:01,740 --> 00:18:05,610
this trade-off between how reliable

00:18:04,230 --> 00:18:06,750
durable do you want it to be and how

00:18:05,610 --> 00:18:09,480
fast things are going to be and this is

00:18:06,750 --> 00:18:11,909
kind of a one of the key principles so

00:18:09,480 --> 00:18:14,220
that's about durability and then let's

00:18:11,909 --> 00:18:16,919
talk about this next question how will

00:18:14,220 --> 00:18:19,230
the system converge on recovery so let's

00:18:16,919 --> 00:18:20,669
go back to sort of our example where B

00:18:19,230 --> 00:18:23,390
has been written up to this primary

00:18:20,669 --> 00:18:25,590
that's a partition at a certain point

00:18:23,390 --> 00:18:26,610
through heartbeat Chuck's the old

00:18:25,590 --> 00:18:28,320
primary will notice that it's

00:18:26,610 --> 00:18:30,750
partitioned in equal stuck down I'm no

00:18:28,320 --> 00:18:32,960
longer a primary and a new primary will

00:18:30,750 --> 00:18:35,580
take over in this case it's note C and

00:18:32,960 --> 00:18:36,110
note C is the new primary and that means

00:18:35,580 --> 00:18:37,910
it notes

00:18:36,110 --> 00:18:40,910
take rights and so a client can write to

00:18:37,910 --> 00:18:42,470
see the right can replicate to be and

00:18:40,910 --> 00:18:44,330
now you have again out of the three

00:18:42,470 --> 00:18:47,360
nodes a majority have C so C is now a

00:18:44,330 --> 00:18:48,710
durable committed piece of data then

00:18:47,360 --> 00:18:50,720
let's imagine the partition goes away

00:18:48,710 --> 00:18:53,299
somebody found the loose Ethernet cable

00:18:50,720 --> 00:18:54,170
plugged it back in and no day is that

00:18:53,299 --> 00:18:58,429
invisible again

00:18:54,170 --> 00:19:00,530
well node B then heals itself by looking

00:18:58,429 --> 00:19:02,240
at what was its last point of common

00:19:00,530 --> 00:19:04,070
history with the other nodes with the

00:19:02,240 --> 00:19:06,110
primary and it throws away all bill

00:19:04,070 --> 00:19:08,390
dismisses B well that's not in the

00:19:06,110 --> 00:19:10,790
history so I got to throw that away and

00:19:08,390 --> 00:19:12,020
then it'll replicate C and bring itself

00:19:10,790 --> 00:19:14,510
back into consistency with the rest of

00:19:12,020 --> 00:19:16,100
the fossil so it converges with the

00:19:14,510 --> 00:19:18,919
other nodes after the partition is

00:19:16,100 --> 00:19:21,110
healed so that's the rollback approach

00:19:18,919 --> 00:19:23,059
to dealing with convergence other

00:19:21,110 --> 00:19:24,830
databases make different choices

00:19:23,059 --> 00:19:26,150
some of them use conflict records as

00:19:24,830 --> 00:19:27,860
well they'll just kind of keep the fact

00:19:26,150 --> 00:19:29,120
that B was written and C was written and

00:19:27,860 --> 00:19:31,280
they look the users sort of done well

00:19:29,120 --> 00:19:32,780
here you go there were two rights to

00:19:31,280 --> 00:19:34,640
this key at different times by different

00:19:32,780 --> 00:19:35,990
no do you figure out using your own

00:19:34,640 --> 00:19:40,660
business logic how you want to resolve

00:19:35,990 --> 00:19:40,660
them I forgot to turn off mine

00:19:41,390 --> 00:19:47,720
all right I'll be back there we go this

00:19:45,410 --> 00:19:49,010
is telling me to stop typing and rest my

00:19:47,720 --> 00:19:51,100
wrists and things which I don't really

00:19:49,010 --> 00:19:53,540
have to worry about here I thought maybe

00:19:51,100 --> 00:19:54,919
other types of databases use something

00:19:53,540 --> 00:19:56,840
and this is a little jargony called

00:19:54,919 --> 00:19:58,190
conflict free replicated data times and

00:19:56,840 --> 00:20:00,470
the idea is these are data types that

00:19:58,190 --> 00:20:02,000
fundamentally can merge themselves

00:20:00,470 --> 00:20:03,820
together following consistent

00:20:02,000 --> 00:20:05,919
predictable rules when you have

00:20:03,820 --> 00:20:08,750
different values written to different

00:20:05,919 --> 00:20:11,000
parts of the system and so an example

00:20:08,750 --> 00:20:13,280
that we like add to set so if what you

00:20:11,000 --> 00:20:15,230
had was a set or a bag and you were

00:20:13,280 --> 00:20:16,760
adding B to the bag and some other noted

00:20:15,230 --> 00:20:18,140
added C to the bag then when you put

00:20:16,760 --> 00:20:19,850
them back together you said well justice

00:20:18,140 --> 00:20:21,590
merges all together in the bag now holds

00:20:19,850 --> 00:20:23,720
B and C and so those are sort of data

00:20:21,590 --> 00:20:25,100
structures that have rules for

00:20:23,720 --> 00:20:26,960
combination different systems have

00:20:25,100 --> 00:20:28,160
different approaches to this and I asked

00:20:26,960 --> 00:20:29,780
the point to you is when you're using

00:20:28,160 --> 00:20:33,169
distributive system you need to know

00:20:29,780 --> 00:20:35,059
what the convergence rules are another

00:20:33,169 --> 00:20:36,890
thing to think about is what do we do

00:20:35,059 --> 00:20:38,990
with the right arrow so we go back to

00:20:36,890 --> 00:20:42,200
this sort of situation where we're doing

00:20:38,990 --> 00:20:45,140
aw majority right up to the primaries

00:20:42,200 --> 00:20:46,340
we're saying I only want to hear back if

00:20:45,140 --> 00:20:48,920
this has reached a majority

00:20:46,340 --> 00:20:50,870
the other nodes well one situation is

00:20:48,920 --> 00:20:52,760
you could just block forever on that but

00:20:50,870 --> 00:20:54,050
typically what happens is you have some

00:20:52,760 --> 00:20:55,070
sort of a timeout and when the timeout

00:20:54,050 --> 00:20:56,780
happens you get a message back saying

00:20:55,070 --> 00:20:59,450
error couldn't do it in the time you

00:20:56,780 --> 00:21:00,920
specified and then you have a situation

00:20:59,450 --> 00:21:03,110
where you know that your right has

00:21:00,920 --> 00:21:06,290
failed but now what do you do do you

00:21:03,110 --> 00:21:08,510
retry it do you ignore it and

00:21:06,290 --> 00:21:09,650
unfortunately like that's kind of it it

00:21:08,510 --> 00:21:10,850
kind of depends on what the date is and

00:21:09,650 --> 00:21:13,370
what your use case is if this is like

00:21:10,850 --> 00:21:14,480
sensor data or log data maybe you don't

00:21:13,370 --> 00:21:16,130
care you just throw it away and wait

00:21:14,480 --> 00:21:16,970
until some rights succeeded on the other

00:21:16,130 --> 00:21:19,220
hand maybe it something that really

00:21:16,970 --> 00:21:20,690
needs to live them so unfortunately the

00:21:19,220 --> 00:21:22,160
answer to this is it's

00:21:20,690 --> 00:21:24,500
application-specific or isn't even a

00:21:22,160 --> 00:21:25,940
MongoDB way of doing this and supply you

00:21:24,500 --> 00:21:27,170
get the message that it failed but then

00:21:25,940 --> 00:21:29,150
you have to apply your own business

00:21:27,170 --> 00:21:31,820
logic for your application to figure out

00:21:29,150 --> 00:21:34,490
what what do I do next so that's all

00:21:31,820 --> 00:21:38,270
about sort of rights let's think a

00:21:34,490 --> 00:21:40,610
little bit now about reads well you

00:21:38,270 --> 00:21:44,360
think about reads I'm going to refresh

00:21:40,610 --> 00:21:48,680
myself which I can't keep on the podium

00:21:44,360 --> 00:21:50,750
because it's tipped I will have a fatal

00:21:48,680 --> 00:21:53,630
accident alright so as we think about

00:21:50,750 --> 00:21:57,260
reads three things again to think about

00:21:53,630 --> 00:21:59,690
recency durability and Laith latency so

00:21:57,260 --> 00:22:01,550
recency is kind of how how old is the

00:21:59,690 --> 00:22:03,170
data when you read it stay on this

00:22:01,550 --> 00:22:05,110
durability we talked about latency is

00:22:03,170 --> 00:22:07,580
how long does it take to get an answer

00:22:05,110 --> 00:22:11,330
and so here are some of the questions we

00:22:07,580 --> 00:22:14,690
want to think about are there we go

00:22:11,330 --> 00:22:16,130
do we care if we read the latest right

00:22:14,690 --> 00:22:17,570
like is it do we have to get the

00:22:16,130 --> 00:22:18,710
absolute latest information or can we

00:22:17,570 --> 00:22:22,220
get some data that's lagging a little

00:22:18,710 --> 00:22:23,690
bit and that's kind of a stereo or do we

00:22:22,220 --> 00:22:25,040
care if the data we read rolls back in

00:22:23,690 --> 00:22:27,290
sort of traditional database terms this

00:22:25,040 --> 00:22:28,730
would be like a dirty beat so some data

00:22:27,290 --> 00:22:31,130
was written maybe it's not made it all

00:22:28,730 --> 00:22:33,080
the way out but maybe we want to read it

00:22:31,130 --> 00:22:33,590
do we care and so this leads to some

00:22:33,080 --> 00:22:35,390
trade-offs

00:22:33,590 --> 00:22:38,210
so the first trade-off to think about is

00:22:35,390 --> 00:22:39,920
recency for durability do we want to

00:22:38,210 --> 00:22:41,960
read before we fully replicated the data

00:22:39,920 --> 00:22:43,940
to the point where it's durable so that

00:22:41,960 --> 00:22:45,860
looks kind of like this so again we'll

00:22:43,940 --> 00:22:48,530
have blackhat writing B to the primer

00:22:45,860 --> 00:22:50,540
that's been partitioned the right can't

00:22:48,530 --> 00:22:51,980
replicate but maybe Whitehead comes

00:22:50,540 --> 00:22:53,660
along and wants to read from the primary

00:22:51,980 --> 00:22:55,910
then reads down that value B so this is

00:22:53,660 --> 00:22:56,230
a dirty reads so it's read data that we

00:22:55,910 --> 00:22:58,840
know

00:22:56,230 --> 00:23:00,640
from if other rights go to the primary

00:22:58,840 --> 00:23:02,650
be could get rolled back we could get

00:23:00,640 --> 00:23:04,840
thrown away but but white hat is ready

00:23:02,650 --> 00:23:07,900
now this would only happen in a narrow

00:23:04,840 --> 00:23:11,350
window because that my memory will

00:23:07,900 --> 00:23:12,790
notice that it has has been partitioned

00:23:11,350 --> 00:23:14,710
and will step down at some point but if

00:23:12,790 --> 00:23:17,380
if we have a race and white hat sneaks

00:23:14,710 --> 00:23:18,940
in and tries to write just before the

00:23:17,380 --> 00:23:20,740
primary notices it stepped down and can

00:23:18,940 --> 00:23:22,000
say yeah I'm reading for the primary I

00:23:20,740 --> 00:23:26,020
think this is the latest data but

00:23:22,000 --> 00:23:27,790
actually it's gonna be thrown away maybe

00:23:26,020 --> 00:23:29,559
that's okay different applications might

00:23:27,790 --> 00:23:32,530
have different views on this whether

00:23:29,559 --> 00:23:34,480
reading that kind of data is okay you

00:23:32,530 --> 00:23:37,210
know I think I think about all the times

00:23:34,480 --> 00:23:38,530
I'm on like some social network Twitter

00:23:37,210 --> 00:23:40,630
or Facebook whatever and you hit refresh

00:23:38,530 --> 00:23:43,090
and like some story or think that was

00:23:40,630 --> 00:23:44,440
there is now gone right now maybe that

00:23:43,090 --> 00:23:45,880
was an algorithmic change that like

00:23:44,440 --> 00:23:47,440
decided to like hide some story and show

00:23:45,880 --> 00:23:49,750
me some other story or maybe the data

00:23:47,440 --> 00:23:51,490
went away as a user I don't know and if

00:23:49,750 --> 00:23:52,840
my users have been trained to not really

00:23:51,490 --> 00:23:54,669
sort of care about things appearing and

00:23:52,840 --> 00:23:56,440
disappearing then maybe giving them a

00:23:54,669 --> 00:23:57,549
very fast answer is actually more

00:23:56,440 --> 00:23:59,230
important than giving them an answer

00:23:57,549 --> 00:23:59,770
that won't go away because it goes like

00:23:59,230 --> 00:24:01,870
oh whatever

00:23:59,770 --> 00:24:04,000
I guess that story got deep prioritize

00:24:01,870 --> 00:24:06,820
off my feet or whatever so applications

00:24:04,000 --> 00:24:09,280
can make these sorts of trade-offs in

00:24:06,820 --> 00:24:10,540
MongoDB you make this kind of trade-offs

00:24:09,280 --> 00:24:13,150
with another thing that was introduced

00:24:10,540 --> 00:24:14,700
in 3.2 call they read concern and so you

00:24:13,150 --> 00:24:17,890
have these read concerned levels and

00:24:14,700 --> 00:24:19,480
apologies for why the this is long

00:24:17,890 --> 00:24:21,700
instead of being are like the other ones

00:24:19,480 --> 00:24:24,309
W never mind

00:24:21,700 --> 00:24:26,650
catch me at the break but the idea of

00:24:24,309 --> 00:24:27,700
read concern level local is you're

00:24:26,650 --> 00:24:28,870
asking the server just tell me what

00:24:27,700 --> 00:24:30,490
you've got locally I don't really care

00:24:28,870 --> 00:24:32,980
about replication just give me whatever

00:24:30,490 --> 00:24:34,540
you've got and majority says I only want

00:24:32,980 --> 00:24:36,160
to hear back from you only give me data

00:24:34,540 --> 00:24:38,440
that has made it to a majority of nodes

00:24:36,160 --> 00:24:39,850
I want to make sure that things I'm

00:24:38,440 --> 00:24:41,940
reading have actually been committed and

00:24:39,850 --> 00:24:44,260
so it works kind of like this where

00:24:41,940 --> 00:24:45,880
let's assume that B has been written in

00:24:44,260 --> 00:24:48,010
is in the process of replicating and

00:24:45,880 --> 00:24:50,620
white hat does a read concern level

00:24:48,010 --> 00:24:52,360
majority read at this point the system

00:24:50,620 --> 00:24:53,710
sort of ignores the fact that B is there

00:24:52,360 --> 00:24:55,179
looks back to the last thing that

00:24:53,710 --> 00:24:56,860
actually made it out to all the nodes

00:24:55,179 --> 00:24:58,929
which is a and hands that back to white

00:24:56,860 --> 00:25:00,700
hat and you can kind of see from this

00:24:58,929 --> 00:25:02,860
that that means that even in this

00:25:00,700 --> 00:25:04,299
situation without a partition white hat

00:25:02,860 --> 00:25:06,020
is reading sedale data right it's like

00:25:04,299 --> 00:25:07,820
here's sort of its

00:25:06,020 --> 00:25:09,970
it's stale in the sense that it's not

00:25:07,820 --> 00:25:12,200
the latest right it is the latest

00:25:09,970 --> 00:25:13,430
committed value but it is essentially

00:25:12,200 --> 00:25:15,110
something that's lagging everything else

00:25:13,430 --> 00:25:16,400
so it's saying well I really want to

00:25:15,110 --> 00:25:17,840
have stuff that won't roll back and I'm

00:25:16,400 --> 00:25:21,350
willing to accept slightly old data in

00:25:17,840 --> 00:25:23,000
order to get back so another trade-off

00:25:21,350 --> 00:25:25,160
we can make and we're thinking about

00:25:23,000 --> 00:25:27,620
just trading off a recency for latency

00:25:25,160 --> 00:25:31,190
maybe I don't want the newest data

00:25:27,620 --> 00:25:32,570
because I want answers faster and so

00:25:31,190 --> 00:25:33,740
here when we talk about latency usually

00:25:32,570 --> 00:25:35,960
what people are thinking about is the

00:25:33,740 --> 00:25:37,730
round-trip time to work between the

00:25:35,960 --> 00:25:40,520
client and wherever the data lives in

00:25:37,730 --> 00:25:42,140
the system so now I'm gonna enhance the

00:25:40,520 --> 00:25:44,300
previous example by saying let's imagine

00:25:42,140 --> 00:25:48,020
that we have two different data centers

00:25:44,300 --> 00:25:50,000
green would be like us West Amazon blue

00:25:48,020 --> 00:25:52,670
would be us East Amazon we have the

00:25:50,000 --> 00:25:54,620
primary and a secondary in the West and

00:25:52,670 --> 00:25:57,680
we have a secondary in the east

00:25:54,620 --> 00:25:59,510
well white hat is also in the East and

00:25:57,680 --> 00:26:01,010
the white hat has a hundred millisecond

00:25:59,510 --> 00:26:02,330
round-trip time to the West or a 10

00:26:01,010 --> 00:26:05,030
millisecond round-trip time within its

00:26:02,330 --> 00:26:08,180
own data center maybe white hat actually

00:26:05,030 --> 00:26:09,560
wants results fast so we have something

00:26:08,180 --> 00:26:11,570
in Maumee to be called a read preference

00:26:09,560 --> 00:26:13,430
which essentially says do I want to read

00:26:11,570 --> 00:26:15,620
from the primary wherever it is which is

00:26:13,430 --> 00:26:18,380
the default like the primary could be in

00:26:15,620 --> 00:26:19,910
Tokyo and here we are in Orlando and

00:26:18,380 --> 00:26:21,650
we're gonna be reading from Tokyo and

00:26:19,910 --> 00:26:22,940
taking all that loud because that's

00:26:21,650 --> 00:26:24,740
where we're gonna read from by default

00:26:22,940 --> 00:26:26,150
is the primary but you can also say I

00:26:24,740 --> 00:26:28,520
want to be from the nearest node find

00:26:26,150 --> 00:26:30,680
the nearest node in network round-trip

00:26:28,520 --> 00:26:32,180
time terms may not be a physically

00:26:30,680 --> 00:26:34,100
nearest no but it's nearest and

00:26:32,180 --> 00:26:35,690
round-trip time terms or within the sort

00:26:34,100 --> 00:26:37,250
of sort of a window but that's another

00:26:35,690 --> 00:26:38,660
sort of detail that we don't need to get

00:26:37,250 --> 00:26:39,920
into the ideas I want to read from

00:26:38,660 --> 00:26:41,840
something close to me and when you

00:26:39,920 --> 00:26:43,400
decide to read from something close you

00:26:41,840 --> 00:26:46,010
get situations like this black hat

00:26:43,400 --> 00:26:48,790
writes B these starts replicating it

00:26:46,010 --> 00:26:51,050
makes it very quickly to node B in

00:26:48,790 --> 00:26:52,670
uswest but it's taking a while before it

00:26:51,050 --> 00:26:54,740
makes it all the way over to notes C and

00:26:52,670 --> 00:26:58,850
in that time white hat can come along

00:26:54,740 --> 00:27:01,070
and read a from the node that's in the

00:26:58,850 --> 00:27:04,220
in the West before B gets them so it's

00:27:01,070 --> 00:27:05,510
older data but it's takes ten

00:27:04,220 --> 00:27:06,649
milliseconds to get it instead of a

00:27:05,510 --> 00:27:09,119
hundred milliseconds to

00:27:06,649 --> 00:27:10,769
so this is another one set of trade off

00:27:09,119 --> 00:27:12,509
that applications can make different

00:27:10,769 --> 00:27:13,679
applications again may want to make

00:27:12,509 --> 00:27:15,359
different choices and whether it's

00:27:13,679 --> 00:27:17,850
MongoDB or any other system you should

00:27:15,359 --> 00:27:19,200
be thinking about where are these trade

00:27:17,850 --> 00:27:20,129
offs in the system that I'm using and

00:27:19,200 --> 00:27:22,950
what do I actually want for the

00:27:20,129 --> 00:27:26,940
application that I have now there's

00:27:22,950 --> 00:27:28,980
another gotcha that I'm gonna talk about

00:27:26,940 --> 00:27:31,259
and we talk about races there are races

00:27:28,980 --> 00:27:34,350
all over distributed system and one of

00:27:31,259 --> 00:27:36,090
the most critical and hard to deal with

00:27:34,350 --> 00:27:37,169
is a partitioned detection race so we

00:27:36,090 --> 00:27:38,279
talked about like data races of

00:27:37,169 --> 00:27:39,450
different clients trying to write well

00:27:38,279 --> 00:27:41,820
one of the other issues is just figuring

00:27:39,450 --> 00:27:42,869
out when does a partition happen and all

00:27:41,820 --> 00:27:43,950
the different nodes and all the

00:27:42,869 --> 00:27:45,539
different clients find out about

00:27:43,950 --> 00:27:47,700
partitions happening at different times

00:27:45,539 --> 00:27:50,190
and so depending on when exactly people

00:27:47,700 --> 00:27:52,859
detect the projection you get more kinds

00:27:50,190 --> 00:27:55,049
of races so again in MongoDB land you

00:27:52,859 --> 00:27:56,730
could have a situation we talked about

00:27:55,049 --> 00:27:59,460
before where partition happens between

00:27:56,730 --> 00:28:02,070
node a and the rest and for a brief

00:27:59,460 --> 00:28:04,429
moment of time no de hasn't stepped down

00:28:02,070 --> 00:28:06,749
I'm gonna call node a a lame-duck primer

00:28:04,429 --> 00:28:09,119
and node B is taken over as the new

00:28:06,749 --> 00:28:10,830
primary has just been elected black hat

00:28:09,119 --> 00:28:13,679
doesn't know about the new primary but

00:28:10,830 --> 00:28:16,830
white hat does and so you get this

00:28:13,679 --> 00:28:18,720
situation where white hat is very happy

00:28:16,830 --> 00:28:20,239
to write to the new primary and right

00:28:18,720 --> 00:28:22,980
after the thin write to the secondary

00:28:20,239 --> 00:28:24,720
black hat is reading some data from the

00:28:22,980 --> 00:28:26,639
old lame-duck primary before it stuffs

00:28:24,720 --> 00:28:28,830
down at this point black hat thing even

00:28:26,639 --> 00:28:30,690
if this is using you know I want

00:28:28,830 --> 00:28:31,739
majority of read concerned I want you

00:28:30,690 --> 00:28:32,909
know all those sort of things says I'm

00:28:31,739 --> 00:28:34,440
reading for the primary I think I'm

00:28:32,909 --> 00:28:36,600
getting the most the latest copy of the

00:28:34,440 --> 00:28:38,340
data I know is committed and all the

00:28:36,600 --> 00:28:39,989
rest of that but B is actually the

00:28:38,340 --> 00:28:41,759
latest data that's committed because

00:28:39,989 --> 00:28:43,769
it's made it to two nodes but black hat

00:28:41,759 --> 00:28:46,139
thinks that a is because it's reading

00:28:43,769 --> 00:28:48,059
from the steel primer so well what if

00:28:46,139 --> 00:28:50,970
that's not okay and when might that not

00:28:48,059 --> 00:28:54,299
be okay and what was your question

00:28:50,970 --> 00:28:55,830
money money money passwords they don't

00:28:54,299 --> 00:29:00,779
want other one I thought about right so

00:28:55,830 --> 00:29:02,999
like I changed my password and some

00:29:00,779 --> 00:29:07,289
other node is handling the log in from

00:29:02,999 --> 00:29:08,879
black hat hacker in Asia and I really

00:29:07,289 --> 00:29:10,409
want that node to be making sure that

00:29:08,879 --> 00:29:12,090
it's got my latest password and not the

00:29:10,409 --> 00:29:14,460
password that existed a millisecond ago

00:29:12,090 --> 00:29:15,570
that maybe is letting white hat login so

00:29:14,460 --> 00:29:16,619
I think like passwords are one of those

00:29:15,570 --> 00:29:17,370
thing can you kind of really do want to

00:29:16,619 --> 00:29:20,460
have the absolutely

00:29:17,370 --> 00:29:22,380
just value in the system and and so

00:29:20,460 --> 00:29:25,400
there's only what kind of one option for

00:29:22,380 --> 00:29:29,250
this and I call it the nuclear option

00:29:25,400 --> 00:29:31,140
and I put this out there because it is a

00:29:29,250 --> 00:29:32,460
very severe way to do it and essentially

00:29:31,140 --> 00:29:35,550
you have to do something in many systems

00:29:32,460 --> 00:29:37,200
called a quorum read the Senate did

00:29:35,550 --> 00:29:39,240
academic jargon but the idea is you have

00:29:37,200 --> 00:29:43,350
to go out to enough of the nodes to make

00:29:39,240 --> 00:29:46,860
sure that you actually have the latest

00:29:43,350 --> 00:29:48,570
value across enough of the nodes to know

00:29:46,860 --> 00:29:51,179
that that's actually the latest value

00:29:48,570 --> 00:29:52,320
and not a phantom latest value or you

00:29:51,179 --> 00:29:55,650
have to ask a node to do it on your

00:29:52,320 --> 00:29:57,000
behalf so it's sort of and it's very

00:29:55,650 --> 00:29:58,559
very expensive to go out to lots of

00:29:57,000 --> 00:30:02,190
places a check instead of going to one

00:29:58,559 --> 00:30:03,929
place one way to do this and kind of in

00:30:02,190 --> 00:30:07,580
the MongoDB world you have to sort of

00:30:03,929 --> 00:30:10,110
read via writing and so MongoDB offers a

00:30:07,580 --> 00:30:11,370
feature called find and update which is

00:30:10,110 --> 00:30:14,429
kind of like a compare and swap you

00:30:11,370 --> 00:30:16,410
could say find a document that matches a

00:30:14,429 --> 00:30:17,760
certain criteria and modify it in a

00:30:16,410 --> 00:30:20,100
certain way and you can either get that

00:30:17,760 --> 00:30:21,059
fuel unmodified one or the new modified

00:30:20,100 --> 00:30:24,600
one but essentially it's kind of like a

00:30:21,059 --> 00:30:26,429
compare and swap operation and you if

00:30:24,600 --> 00:30:27,870
you do this with W majority you won't

00:30:26,429 --> 00:30:30,210
get an answer back until that's made it

00:30:27,870 --> 00:30:31,380
to a majority of the nodes and at that

00:30:30,210 --> 00:30:33,390
point you know that whatever you're

00:30:31,380 --> 00:30:34,800
getting back was written to a primary

00:30:33,390 --> 00:30:36,960
node that could see the majority and

00:30:34,800 --> 00:30:38,250
what your actual modification is below

00:30:36,960 --> 00:30:39,750
find them on an update you kind of

00:30:38,250 --> 00:30:41,070
increment a dummy field here's some

00:30:39,750 --> 00:30:42,090
dummy field it's just a counter I'm just

00:30:41,070 --> 00:30:43,890
going to increment this every time I

00:30:42,090 --> 00:30:46,860
read it and essentially you've turned a

00:30:43,890 --> 00:30:48,360
reed into a write and as everybody knows

00:30:46,860 --> 00:30:50,160
from any other database work they've

00:30:48,360 --> 00:30:52,230
done writes are much more expensive than

00:30:50,160 --> 00:30:54,990
reads but when you actually need the

00:30:52,230 --> 00:30:57,510
nuclear option you can do it this way it

00:30:54,990 --> 00:30:59,040
is possible actually that in MongoDB 3.4

00:30:57,510 --> 00:31:00,330
coming out this fall they'll actually be

00:30:59,040 --> 00:31:01,620
a new read concerned level which will

00:31:00,330 --> 00:31:03,900
kind of do this automatically without

00:31:01,620 --> 00:31:05,400
needing to go through the find an update

00:31:03,900 --> 00:31:06,720
on the dummy increment process but it's

00:31:05,400 --> 00:31:10,890
still going to basically pay the cost of

00:31:06,720 --> 00:31:13,530
a write in order to do a read so some of

00:31:10,890 --> 00:31:15,450
the takeaways from this so I'm going to

00:31:13,530 --> 00:31:18,720
take away from this there we go clicker

00:31:15,450 --> 00:31:20,370
fail cap is simplistic you'll hear a lot

00:31:18,720 --> 00:31:21,929
of debates online if you go and read

00:31:20,370 --> 00:31:23,730
what people have to say online about

00:31:21,929 --> 00:31:26,220
tributed systems a lot of I cap this cap

00:31:23,730 --> 00:31:28,470
that this system is ca that RCP this

00:31:26,220 --> 00:31:29,669
system is a P blah blah blah I think

00:31:28,470 --> 00:31:30,899
that's very simplistic I think you

00:31:29,669 --> 00:31:31,980
should think it's simplistic and I think

00:31:30,899 --> 00:31:36,330
you should realize that reality is very

00:31:31,980 --> 00:31:38,549
complex very critically people's needs

00:31:36,330 --> 00:31:40,470
are application-specific like there is

00:31:38,549 --> 00:31:41,879
no one database or one system that's

00:31:40,470 --> 00:31:43,710
right for every application there's no

00:31:41,879 --> 00:31:45,119
one way to do your reads or do your

00:31:43,710 --> 00:31:49,799
rights that's right for every

00:31:45,119 --> 00:31:51,210
application if you are consuming logs if

00:31:49,799 --> 00:31:52,740
you lose a loved one or two maybe you

00:31:51,210 --> 00:31:53,820
don't care but maybe you need to

00:31:52,740 --> 00:31:54,929
actually just make sure you can keep up

00:31:53,820 --> 00:31:56,330
with the throughput of the log data

00:31:54,929 --> 00:31:59,190
coming through it we're sensor data

00:31:56,330 --> 00:32:00,570
other situations money passwords maybe

00:31:59,190 --> 00:32:02,039
you really do care that famous actually

00:32:00,570 --> 00:32:03,149
get changed when you think they're jams

00:32:02,039 --> 00:32:06,570
you need to know so you need to be able

00:32:03,149 --> 00:32:08,429
to know that the system you use can let

00:32:06,570 --> 00:32:09,360
you make those trade-offs that you need

00:32:08,429 --> 00:32:11,700
for your application

00:32:09,360 --> 00:32:12,990
when writing remember to think about

00:32:11,700 --> 00:32:15,240
durability how do you know when

00:32:12,990 --> 00:32:17,909
something is durable know how something

00:32:15,240 --> 00:32:20,789
is converging when a system recovers

00:32:17,909 --> 00:32:22,110
from a partition and how do you find

00:32:20,789 --> 00:32:25,440
about errors and how do you recover from

00:32:22,110 --> 00:32:26,549
them when you're reading think about the

00:32:25,440 --> 00:32:28,980
trade-offs between recency and

00:32:26,549 --> 00:32:31,499
durability you want recent data that

00:32:28,980 --> 00:32:33,029
might not might go away recency versus

00:32:31,499 --> 00:32:35,610
latency if you want recent data that

00:32:33,029 --> 00:32:37,710
gets the answer fast instead of having

00:32:35,610 --> 00:32:38,999
to wait around and think about the

00:32:37,710 --> 00:32:40,649
nuclear option when do you need the

00:32:38,999 --> 00:32:42,179
nuclear option be very and be very clear

00:32:40,649 --> 00:32:44,580
that you're paying a heavy costs and use

00:32:42,179 --> 00:32:47,159
it only when you need it

00:32:44,580 --> 00:32:49,139
that's sort of all the meat of practical

00:32:47,159 --> 00:32:51,450
consistency I hope that it gives you a

00:32:49,139 --> 00:32:52,710
better sense of what the issues are and

00:32:51,450 --> 00:32:54,649
what you should be looking for in any

00:32:52,710 --> 00:32:57,749
distributed system MongoDB or otherwise

00:32:54,649 --> 00:33:00,450
before I wrap up I have a favor I want

00:32:57,749 --> 00:33:04,320
to ask of everybody this is sort of

00:33:00,450 --> 00:33:06,600
somewhat personal so I among other

00:33:04,320 --> 00:33:10,049
things are the primary maintainer of the

00:33:06,600 --> 00:33:12,389
MongoDB Perl module and CPM and lots of

00:33:10,049 --> 00:33:14,340
and I work in this group of driver

00:33:12,389 --> 00:33:15,720
engineers that maintain the drivers roll

00:33:14,340 --> 00:33:16,860
it like ten different languages and

00:33:15,720 --> 00:33:18,629
they've constantly had these questions

00:33:16,860 --> 00:33:20,950
for management about like is this stuff

00:33:18,629 --> 00:33:22,630
getting used and some of the newer

00:33:20,950 --> 00:33:24,130
the Dominican systems give like download

00:33:22,630 --> 00:33:27,159
statistics of like how many things been

00:33:24,130 --> 00:33:28,720
downloaded from pythons repository etc

00:33:27,159 --> 00:33:30,340
well cpad being a wonderfully

00:33:28,720 --> 00:33:31,840
distributed system of itself of its own

00:33:30,340 --> 00:33:33,730
doesn't give you anything like that

00:33:31,840 --> 00:33:36,820
what's actually interesting is that this

00:33:33,730 --> 00:33:38,200
plus plus number on medicine pen has

00:33:36,820 --> 00:33:39,970
actually been a signal that management

00:33:38,200 --> 00:33:40,899
has looked at and said oh that's great

00:33:39,970 --> 00:33:43,120
that there's a lot of people actually

00:33:40,899 --> 00:33:45,760
grout and clicking plus plus so if you

00:33:43,120 --> 00:33:47,860
use MongoDB if you have any positive

00:33:45,760 --> 00:33:49,840
feelings about MongoDB whatsoever if you

00:33:47,860 --> 00:33:51,820
liked my talk please consider going out

00:33:49,840 --> 00:33:53,230
and getting a plus + on medicean and

00:33:51,820 --> 00:33:54,700
drive this number up so I can convince

00:33:53,230 --> 00:33:58,690
my bosses that the Perl community is

00:33:54,700 --> 00:34:01,090
actually interested in MongoDB if you

00:33:58,690 --> 00:34:03,610
haven't used MongoDB don't take Parsons

00:34:01,090 --> 00:34:05,559
in a sec if you have use MongoDB there

00:34:03,610 --> 00:34:07,570
is if you download the MongoDB driver

00:34:05,559 --> 00:34:09,429
there's MongoDB : : tutorial which kind

00:34:07,570 --> 00:34:12,179
of walks you through how to do some

00:34:09,429 --> 00:34:15,010
basic stuff and University MongoDB comm

00:34:12,179 --> 00:34:17,050
has a number of free courses there isn't

00:34:15,010 --> 00:34:18,369
a Perl specific one yet because I'm busy

00:34:17,050 --> 00:34:20,560
actually doing the work on the Perl

00:34:18,369 --> 00:34:21,849
driver but there's a Python course and

00:34:20,560 --> 00:34:24,940
you can almost translate the examples

00:34:21,849 --> 00:34:27,010
directly over for use with the

00:34:24,940 --> 00:34:29,290
programmer it's all free and so I

00:34:27,010 --> 00:34:31,089
encourage people to check it out now

00:34:29,290 --> 00:34:33,960
I'll take questions Steve you have a

00:34:31,089 --> 00:34:33,960
hand applause ah

00:34:35,299 --> 00:34:40,759
motive that mojolicious is number one

00:34:37,489 --> 00:34:42,409
and they were up around 280 maybe last I

00:34:40,759 --> 00:34:43,399
checked somebody with a computer on the

00:34:42,409 --> 00:34:46,489
internet can tell you know the high

00:34:43,399 --> 00:34:51,950
numbers are I think MongoDB is currently

00:34:46,489 --> 00:34:54,309
44 out of I would like it to not look

00:34:51,950 --> 00:34:57,049
like it has been totally engineered so

00:34:54,309 --> 00:34:57,529
if it suddenly gets to 400 that might be

00:34:57,049 --> 00:35:00,890
a problem

00:34:57,529 --> 00:35:07,940
if it goes from where it is up by 10 or

00:35:00,890 --> 00:35:09,470
12 that'd be great yeah exactly

00:35:07,940 --> 00:35:10,819
eventually it needs to be looked like it

00:35:09,470 --> 00:35:14,720
was consistently collected by lots of

00:35:10,819 --> 00:35:15,950
people yeah I did it last year and I

00:35:14,720 --> 00:35:17,720
tweet about it periodically and I get a

00:35:15,950 --> 00:35:19,069
little teacup and a little kick up you

00:35:17,720 --> 00:35:20,809
know it's real management looks for

00:35:19,069 --> 00:35:22,279
signals right and when you in the

00:35:20,809 --> 00:35:23,779
absence of anything else I can tell them

00:35:22,279 --> 00:35:26,690
I could say well hey we're you know

00:35:23,779 --> 00:35:29,839
number 44 out of a hundred on the c-pen

00:35:26,690 --> 00:35:31,309
medicean most clicked list does that say

00:35:29,839 --> 00:35:32,989
that the community really loves it or

00:35:31,309 --> 00:35:34,339
I'm just a good salesperson of getting

00:35:32,989 --> 00:35:36,700
people to click it I don't know but at

00:35:34,339 --> 00:35:38,900
the very least it will help me out and

00:35:36,700 --> 00:35:41,779
mommy-to-be has been a big supporter of

00:35:38,900 --> 00:35:44,180
Perl a lot of this sort of new no sequel

00:35:41,779 --> 00:35:46,719
databases they're happy to have put out

00:35:44,180 --> 00:35:49,249
drivers for Ruby and Python and Java

00:35:46,719 --> 00:35:52,400
very very few companies actually like

00:35:49,249 --> 00:35:54,170
internally develop and support Perl

00:35:52,400 --> 00:35:56,450
driver mommy-to-be does I'm very excited

00:35:54,170 --> 00:35:58,670
to be the person leading that effort so

00:35:56,450 --> 00:36:01,549
I definitely would love for the

00:35:58,670 --> 00:36:04,460
community to show mommy TB that this

00:36:01,549 --> 00:36:05,660
supports the mommy-to-be feels like it's

00:36:04,460 --> 00:36:08,049
a worthwhile investment to continue

00:36:05,660 --> 00:36:08,049
developing

00:36:09,780 --> 00:36:14,810
you know when Larry's when Larry gave

00:36:11,280 --> 00:36:17,670
his Craigslist talk was it last April he

00:36:14,810 --> 00:36:18,810
his talk saying it's coming out which

00:36:17,670 --> 00:36:20,880
was really the announcement that it was

00:36:18,810 --> 00:36:21,960
coming out that Christmas yeah my team

00:36:20,880 --> 00:36:24,360
lead comedian so we need to start

00:36:21,960 --> 00:36:26,190
developing a pearl six driver I think

00:36:24,360 --> 00:36:28,290
it's okay what's about yet there is

00:36:26,190 --> 00:36:29,880
there is a there is April six MongoDB

00:36:28,290 --> 00:36:33,300
driver that was a part of an older

00:36:29,880 --> 00:36:34,320
version of the pro five MongoDB driver I

00:36:33,300 --> 00:36:36,120
haven't really should have looked at it

00:36:34,320 --> 00:36:38,550
but I'm in contact with the maintainer

00:36:36,120 --> 00:36:39,720
and we talked about issues and I kind of

00:36:38,550 --> 00:36:42,420
try to point them to things that might

00:36:39,720 --> 00:36:43,860
be helpful as versions change so I kind

00:36:42,420 --> 00:36:45,890
of keep tabs on it but I don't have the

00:36:43,860 --> 00:36:47,520
bandwidth to get more directly involved

00:36:45,890 --> 00:36:50,690
other questions

00:36:47,520 --> 00:36:52,830
MongoDB or distributed systems related

00:36:50,690 --> 00:36:55,490
all right thank you very much appreciate

00:36:52,830 --> 00:36:55,490

YouTube URL: https://www.youtube.com/watch?v=hTAedFCex2A


