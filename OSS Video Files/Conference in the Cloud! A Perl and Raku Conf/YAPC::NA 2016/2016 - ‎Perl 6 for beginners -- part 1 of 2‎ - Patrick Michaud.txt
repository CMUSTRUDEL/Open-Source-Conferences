Title: 2016 - ‎Perl 6 for beginners -- part 1 of 2‎ - Patrick Michaud
Publication date: 2016-06-27
Playlist: YAPC::NA 2016
Description: 
	
Captions: 
	00:00:01,700 --> 00:00:09,750
what yeah so my talk this morning is

00:00:07,049 --> 00:00:11,759
perfect hands-on tutorial actually this

00:00:09,750 --> 00:00:12,330
looks like the wrong nope it's the right

00:00:11,759 --> 00:00:16,859
one okay

00:00:12,330 --> 00:00:19,560
Pro six hands-on tutorial so this is

00:00:16,859 --> 00:00:22,320
actually a slide deck that Jonathan

00:00:19,560 --> 00:00:24,000
Worthington did a year ago and I thought

00:00:22,320 --> 00:00:26,580
it was good enough that rather than make

00:00:24,000 --> 00:00:30,000
my own tutorial I just stole his so I'm

00:00:26,580 --> 00:00:31,980
presenting that one today it's very

00:00:30,000 --> 00:00:33,840
beginning introduction to purl 6 so

00:00:31,980 --> 00:00:35,280
before I start with all the purl 6 stuff

00:00:33,840 --> 00:00:37,320
just let me ask how many people in here

00:00:35,280 --> 00:00:40,140
this is your first this conference is

00:00:37,320 --> 00:00:44,340
your first real exposure to purl 600

00:00:40,140 --> 00:00:53,039
awesome fantastic you in the back there

00:00:44,340 --> 00:00:54,870
mr. Conway Conway well so dr. Conway

00:00:53,039 --> 00:00:56,850
yesterday gave an excellent keynote

00:00:54,870 --> 00:00:58,260
showing all of the fancy features that

00:00:56,850 --> 00:00:59,670
you can do with purl 6 going all the way

00:00:58,260 --> 00:01:01,739
up to quantum supercomputing and that

00:00:59,670 --> 00:01:05,159
was for beginners so I'm going to extend

00:01:01,739 --> 00:01:07,380
from what he started with everything I

00:01:05,159 --> 00:01:11,340
do today will be a quantum superposition

00:01:07,380 --> 00:01:13,229
of one value all right we'll start from

00:01:11,340 --> 00:01:16,140
there and begin from there but the rest

00:01:13,229 --> 00:01:17,759
of it should be in there so the

00:01:16,140 --> 00:01:20,790
presentation that I'm giving is split

00:01:17,759 --> 00:01:22,170
across two sessions the we have the 50

00:01:20,790 --> 00:01:23,729
minutes here today and then when there's

00:01:22,170 --> 00:01:25,439
another session tomorrow at 11:00 where

00:01:23,729 --> 00:01:28,650
I will pick up from wherever I left off

00:01:25,439 --> 00:01:30,630
today I thought about trying to do all

00:01:28,650 --> 00:01:33,659
of Perl 6 on a hundred minutes but it's

00:01:30,630 --> 00:01:35,670
probably not going to happen and in

00:01:33,659 --> 00:01:37,530
these talks I'm not even going to try

00:01:35,670 --> 00:01:40,049
and detour to the cool features will

00:01:37,530 --> 00:01:42,540
stumble across a lot of cool features in

00:01:40,049 --> 00:01:45,720
the process but really what this is for

00:01:42,540 --> 00:01:47,070
is I'm assuming you know something about

00:01:45,720 --> 00:01:49,500
Perl because you're here at this

00:01:47,070 --> 00:01:51,299
conference but you don't know anything

00:01:49,500 --> 00:01:52,590
about Perl 6 and you would like to be

00:01:51,299 --> 00:01:55,770
able to get started and you just need

00:01:52,590 --> 00:01:58,979
some pointers to go along the way and in

00:01:55,770 --> 00:02:00,869
each of these talks I have easily more

00:01:58,979 --> 00:02:02,850
material than there is time to present

00:02:00,869 --> 00:02:06,030
it so I'm not going to try and rush to

00:02:02,850 --> 00:02:08,129
make any goals or whatever as I go

00:02:06,030 --> 00:02:09,380
through and do it if you have a laptop

00:02:08,129 --> 00:02:11,330
and you have

00:02:09,380 --> 00:02:13,130
riku del pearl installed then you can be

00:02:11,330 --> 00:02:14,930
going along with it I will give you some

00:02:13,130 --> 00:02:16,670
time to try things and however far we

00:02:14,930 --> 00:02:19,700
get is however far we get

00:02:16,670 --> 00:02:21,830
alright so questions you know problems

00:02:19,700 --> 00:02:23,270
those kind of things are encouraged if I

00:02:21,830 --> 00:02:24,500
think they're too advanced then I'll say

00:02:23,270 --> 00:02:27,710
let's do in the hallway or it'll come

00:02:24,500 --> 00:02:28,850
tomorrow or something like that okay all

00:02:27,710 --> 00:02:30,350
right

00:02:28,850 --> 00:02:32,180
throughout this we have try and see it

00:02:30,350 --> 00:02:33,740
in slides chances for you to try things

00:02:32,180 --> 00:02:35,840
out on your laptop so how many people

00:02:33,740 --> 00:02:36,460
came and have Rick Udo open in front of

00:02:35,840 --> 00:02:39,710
them right now

00:02:36,460 --> 00:02:42,590
awesome alright so you can try these

00:02:39,710 --> 00:02:43,550
things out if you don't have that you

00:02:42,590 --> 00:02:45,020
know and I don't mind if you switch

00:02:43,550 --> 00:02:46,520
around or if you find somebody and you

00:02:45,020 --> 00:02:47,750
want to leave lean over and look and see

00:02:46,520 --> 00:02:49,520
what they're doing it works out really

00:02:47,750 --> 00:02:52,640
good I'm a big fan of pair programming

00:02:49,520 --> 00:02:54,470
so feel free to pair up and try and do

00:02:52,640 --> 00:02:56,600
those if you get up move around in the

00:02:54,470 --> 00:02:58,280
middle of my talk I absolutely does not

00:02:56,600 --> 00:03:01,870
bother me right I'm actually gonna

00:02:58,280 --> 00:03:01,870
ignore you from this point on anyway so

00:03:04,960 --> 00:03:10,700
values alright so we need to dive right

00:03:08,660 --> 00:03:12,560
into pro 6 so the different types of

00:03:10,700 --> 00:03:14,300
values that you can have in Perl 6 so of

00:03:12,560 --> 00:03:17,120
course we have integers and we have

00:03:14,300 --> 00:03:19,010
rationals and so you can see there 0.25

00:03:17,120 --> 00:03:20,540
that's a rational we'll look at it here

00:03:19,010 --> 00:03:21,530
in a second a lot of people would say no

00:03:20,540 --> 00:03:24,710
that's a floating-point number

00:03:21,530 --> 00:03:26,690
not in Perl 6 in Perl 6 0.25 is a

00:03:24,710 --> 00:03:28,340
rational and then we have floating-point

00:03:26,690 --> 00:03:29,570
numbers and the common way to get a

00:03:28,340 --> 00:03:30,710
floating-point number is you use

00:03:29,570 --> 00:03:33,920
exponential notation

00:03:30,710 --> 00:03:35,930
alright so given that you have a value

00:03:33,920 --> 00:03:37,820
how can you figure out what type it is

00:03:35,930 --> 00:03:39,350
and this is one of the first things

00:03:37,820 --> 00:03:42,410
that's worth learning about Perl 6

00:03:39,350 --> 00:03:45,530
because Perl 6 has a very rich type

00:03:42,410 --> 00:03:47,120
system and I'm gonna detour out of the

00:03:45,530 --> 00:03:49,760
slides for just a second to give you an

00:03:47,120 --> 00:03:52,070
idea of how rich the type system is and

00:03:49,760 --> 00:03:53,750
also point a couple of places that you

00:03:52,070 --> 00:03:56,950
want to know about so one of them is dot

00:03:53,750 --> 00:03:56,950
dot Perl 6 org

00:04:02,370 --> 00:04:08,260
we'll let that do that in the background

00:04:05,400 --> 00:04:10,840
so you can discover what type is is

00:04:08,260 --> 00:04:12,460
using by using what so if you have an

00:04:10,840 --> 00:04:14,140
object if you have a variable if you

00:04:12,460 --> 00:04:16,150
have a value and you want to know what

00:04:14,140 --> 00:04:18,070
type it is you just do dot what after it

00:04:16,150 --> 00:04:20,860
and that will stringify to a tightening

00:04:18,070 --> 00:04:23,290
much like you see at the bottom so let's

00:04:20,860 --> 00:04:24,520
just go ahead and go into say okay I'm

00:04:23,290 --> 00:04:27,760
gonna get rid of Firefox because it's

00:04:24,520 --> 00:04:29,800
totally messing up my video this is what

00:04:27,760 --> 00:04:31,780
I get from running Linux on a surface

00:04:29,800 --> 00:04:35,050
pro 3 all righty

00:04:31,780 --> 00:04:39,130
oh wow it really killed everything all

00:04:35,050 --> 00:04:42,640
right so if I want to just find out like

00:04:39,130 --> 00:04:49,330
say 1 dot what it's an integer say 0.25

00:04:42,640 --> 00:04:52,350
dot what it's a wrap say 4.32 or e 10

00:04:49,330 --> 00:04:57,220
what that's a numb

00:04:52,350 --> 00:05:00,460
say hello what it's a string right so

00:04:57,220 --> 00:05:02,350
dot what all caps is the way or as a way

00:05:00,460 --> 00:05:06,850
that you can find out what type of value

00:05:02,350 --> 00:05:14,550
you're playing with okay let me go back

00:05:06,850 --> 00:05:17,080
and pull up my tutorial again alright

00:05:14,550 --> 00:05:19,330
for numbers you have the usual set of

00:05:17,080 --> 00:05:22,540
numeric operators available there are

00:05:19,330 --> 00:05:26,490
many that are new as we saw for example

00:05:22,540 --> 00:05:29,890
a supersuit superscripted 2 means square

00:05:26,490 --> 00:05:32,700
things like that so use plus to add two

00:05:29,890 --> 00:05:35,260
numbers minus to subtract two numbers

00:05:32,700 --> 00:05:36,730
multiply two numbers and so on you know

00:05:35,260 --> 00:05:38,910
pretty standard stuff if you're familiar

00:05:36,730 --> 00:05:42,700
with Perl

00:05:38,910 --> 00:05:45,220
alright so very quickly I'm gonna give

00:05:42,700 --> 00:05:47,650
you about a minute to play real quick

00:05:45,220 --> 00:05:51,690
what's the largest integer we can have

00:05:47,650 --> 00:05:54,280
in Perl 6 see if you can get an overflow

00:05:51,690 --> 00:05:56,170
secondly take two integers and divide

00:05:54,280 --> 00:06:01,420
them and see what type of value you get

00:05:56,170 --> 00:06:04,510
and then thirdly try taking 0.1 plus 0.2

00:06:01,420 --> 00:06:05,550
and see if that's equal to 0.3 and see

00:06:04,510 --> 00:06:07,480
if you a true or false

00:06:05,550 --> 00:06:11,169
alright so I'm just gonna give you a few

00:06:07,480 --> 00:06:13,919
few like few seconds to try that I'll

00:06:11,169 --> 00:06:13,919
have my window up here

00:06:18,760 --> 00:06:23,510
yeah I will but I don't wanna I don't

00:06:21,230 --> 00:06:25,490
wanna you know I don't I want to let

00:06:23,510 --> 00:06:26,180
people try it a little bit for just a

00:06:25,490 --> 00:06:33,320
second

00:06:26,180 --> 00:06:36,230
oh sorry the questions just met they're

00:06:33,320 --> 00:06:38,500
coming back they're coming back there

00:06:36,230 --> 00:06:38,500
you go

00:06:52,810 --> 00:07:04,470
okay so how big can integers get so

00:06:55,930 --> 00:07:11,710
let's try 2 to the 128 not very big

00:07:04,470 --> 00:07:20,230
let's try 2 to the 1024 a little bit

00:07:11,710 --> 00:07:24,790
bigger let's try 2 6 5 5 3 6 a little

00:07:20,230 --> 00:07:28,419
bit bigger integers can be very large in

00:07:24,790 --> 00:07:31,510
Perl 6 and it basically means big ants

00:07:28,419 --> 00:07:33,220
are built into Perl 6 alright so you

00:07:31,510 --> 00:07:34,870
have you know integers you don't have to

00:07:33,220 --> 00:07:37,150
worry about overflowing the integer type

00:07:34,870 --> 00:07:40,680
so what type do we get when we divide

00:07:37,150 --> 00:07:44,350
two integers so let's say 4 divided by 2

00:07:40,680 --> 00:07:50,140
and we put what's on it and tells me

00:07:44,350 --> 00:07:53,169
that's a wrap because division of two

00:07:50,140 --> 00:07:59,260
integers in Perl 6 produces rational

00:07:53,169 --> 00:08:06,100
numbers so if I say 3/5 dot what it says

00:07:59,260 --> 00:08:07,120
that's a rat if I just say 3/5 it tells

00:08:06,100 --> 00:08:09,220
me it's point 6

00:08:07,120 --> 00:08:14,350
but that zero point six is actually a

00:08:09,220 --> 00:08:16,720
rational number if you want to play with

00:08:14,350 --> 00:08:18,460
rats a little bit more you can ask for

00:08:16,720 --> 00:08:21,660
their numerator oops

00:08:18,460 --> 00:08:25,510
but is it new you can ask for it

00:08:21,660 --> 00:08:27,039
numerator there we go you can ask for

00:08:25,510 --> 00:08:29,590
their numerator and you'll see that if

00:08:27,039 --> 00:08:31,900
we do I say

00:08:29,590 --> 00:08:36,300
4/10 numerator then it tells me the

00:08:31,900 --> 00:08:41,680
numerator is 2 because the denominator

00:08:36,300 --> 00:08:42,909
is 5 it automatically reduces if you

00:08:41,680 --> 00:08:44,620
want to get both of them all but if you

00:08:42,909 --> 00:08:46,089
want to get both the numerator and the

00:08:44,620 --> 00:08:48,330
denominator that you asked for our new

00:08:46,089 --> 00:08:48,330
draft

00:08:51,130 --> 00:09:00,430
and then if we try and save 0.1 plus 0.2

00:08:56,740 --> 00:09:04,120
and ask if that's equal to 0.3 it comes

00:09:00,430 --> 00:09:10,389
back and says true so if we try that in

00:09:04,120 --> 00:09:15,610
some other language there probably need

00:09:10,389 --> 00:09:20,529
a biggie here right it is so hard for me

00:09:15,610 --> 00:09:26,380
to go back to pro 5 these taste then I

00:09:20,529 --> 00:09:27,850
get false right bro 5 doesn't think that

00:09:26,380 --> 00:09:30,190
point 1 and point 2 are equal to point 3

00:09:27,850 --> 00:09:32,290
neither does Python neither do quite a

00:09:30,190 --> 00:09:34,000
few other languages and again the reason

00:09:32,290 --> 00:09:36,130
is is because these are rational numbers

00:09:34,000 --> 00:09:40,600
so that there are exact representations

00:09:36,130 --> 00:09:42,160
0.1 is 1/10 0.2 is 2/10 so they eat add

00:09:40,600 --> 00:09:43,029
up to 3/10 and there's no loss of

00:09:42,160 --> 00:09:51,880
precision because we're out doing

00:09:43,029 --> 00:09:53,589
floating-point right Perl 6 has lots of

00:09:51,880 --> 00:09:55,180
quoting strapped constructs the simples

00:09:53,589 --> 00:09:57,250
simplest are single and double quotes

00:09:55,180 --> 00:10:00,399
they work much the same way that you

00:09:57,250 --> 00:10:02,610
might be familiar with in Perl 5 the one

00:10:00,399 --> 00:10:04,829
that often confuses people is

00:10:02,610 --> 00:10:09,759
concatenation is now the tilde operator

00:10:04,829 --> 00:10:11,920
instead of the dot so how do you

00:10:09,759 --> 00:10:13,240
remember that the tilde operator is the

00:10:11,920 --> 00:10:17,829
thing well we think of it as stitching

00:10:13,240 --> 00:10:19,329
things together right and as Jonathan

00:10:17,829 --> 00:10:20,709
notes it looks like a piece of string so

00:10:19,329 --> 00:10:21,819
if you're combining two strings you use

00:10:20,709 --> 00:10:24,550
an other piece of string to tie them

00:10:21,819 --> 00:10:26,949
together right so the tilde operator is

00:10:24,550 --> 00:10:28,959
the concatenation in Perl 6 and that's

00:10:26,949 --> 00:10:31,060
speaking the reason for that is that the

00:10:28,959 --> 00:10:33,100
dot has another purpose now which is

00:10:31,060 --> 00:10:38,470
more important namely for doing method

00:10:33,100 --> 00:10:41,079
calls there are a lot of operations on

00:10:38,470 --> 00:10:43,420
strings so if you want to know the

00:10:41,079 --> 00:10:46,240
length of a string and I'll just make a

00:10:43,420 --> 00:10:48,699
note there is no length keyword in Perl

00:10:46,240 --> 00:10:51,759
6 we never talk about length of things

00:10:48,699 --> 00:10:53,649
because it's too ambiguous so if you

00:10:51,759 --> 00:10:55,340
want to know how many characters is in a

00:10:53,649 --> 00:10:58,430
string then

00:10:55,340 --> 00:10:59,480
you can use the the cars function if you

00:10:58,430 --> 00:11:01,550
want to convert a string to all

00:10:59,480 --> 00:11:03,380
uppercase its you see all lowercase as

00:11:01,550 --> 00:11:08,600
LC if you want to do it to title case

00:11:03,380 --> 00:11:10,880
then it's TC LC and here on this side

00:11:08,600 --> 00:11:14,510
slide we can see that you can do the the

00:11:10,880 --> 00:11:17,000
functional forms or the subroutine call

00:11:14,510 --> 00:11:19,820
forms that pro/5 has always had but

00:11:17,000 --> 00:11:21,410
there are also method call forms so for

00:11:19,820 --> 00:11:23,630
the method call you have an object or a

00:11:21,410 --> 00:11:27,800
value and use a dot and you say which

00:11:23,630 --> 00:11:29,510
method you want to have it invoke and it

00:11:27,800 --> 00:11:30,830
will come back and give you the result

00:11:29,510 --> 00:11:33,920
of invoking that method on that object

00:11:30,830 --> 00:11:41,060
so another way to do it is to say cars

00:11:33,920 --> 00:11:43,970
you see LC and dot TCL see one thing to

00:11:41,060 --> 00:11:45,320
know about Perl 6 that it's some level

00:11:43,970 --> 00:11:47,660
II it seems like I don't need to know

00:11:45,320 --> 00:11:51,860
this as a beginner but you rapidly can

00:11:47,660 --> 00:11:54,590
run into it is that is what does cars

00:11:51,860 --> 00:11:56,630
really doing and that's because all

00:11:54,590 --> 00:11:59,720
strings in Perl 6 are unicode strings

00:11:56,630 --> 00:12:01,460
there's not a notion of the different

00:11:59,720 --> 00:12:03,800
and coatings that are available if it's

00:12:01,460 --> 00:12:06,890
a string type if it's a string then it's

00:12:03,800 --> 00:12:08,600
Unicode and Unicode works at several

00:12:06,890 --> 00:12:11,090
different levels so there's the graphene

00:12:08,600 --> 00:12:14,360
level which is the things that a human

00:12:11,090 --> 00:12:16,280
thinks of as being a character right and

00:12:14,360 --> 00:12:19,730
typically we think of that as being a

00:12:16,280 --> 00:12:21,500
graphic lift of some sort then there's

00:12:19,730 --> 00:12:24,920
the code point level which is what

00:12:21,500 --> 00:12:26,480
Unicode uses to give values to each

00:12:24,920 --> 00:12:28,880
thing that can be used to create

00:12:26,480 --> 00:12:30,530
characters right and sometimes those are

00:12:28,880 --> 00:12:32,450
actual characters by themselves but

00:12:30,530 --> 00:12:34,340
sometimes they're diacritical marks or

00:12:32,450 --> 00:12:37,520
their things that overlay on top of a

00:12:34,340 --> 00:12:40,220
another Unicode code point in order to

00:12:37,520 --> 00:12:41,900
create a different character and then in

00:12:40,220 --> 00:12:43,850
all of this we have to deal with bytes

00:12:41,900 --> 00:12:45,610
because internally that's how they

00:12:43,850 --> 00:12:49,190
actually get stored it's by bytes and so

00:12:45,610 --> 00:12:51,980
in other languages pro/5 PHP Python

00:12:49,190 --> 00:12:54,860
you're always having to worry about what

00:12:51,980 --> 00:12:58,250
a type of encoding the string you're

00:12:54,860 --> 00:13:00,050
working with is in it was a utf-8 or is

00:12:58,250 --> 00:13:02,060
it just a binary string or is it an

00:13:00,050 --> 00:13:04,280
ASCII string you know is it in some

00:13:02,060 --> 00:13:06,770
other encoding entirely like Latinate in

00:13:04,280 --> 00:13:08,270
perl 6 all the strings work at the

00:13:06,770 --> 00:13:11,480
graphene level and they're all

00:13:08,270 --> 00:13:12,920
no code right so if you ask for cars on

00:13:11,480 --> 00:13:14,270
a string you're not gonna get the number

00:13:12,920 --> 00:13:16,160
of bytes that it takes you're always

00:13:14,270 --> 00:13:19,640
going to get the number of characters

00:13:16,160 --> 00:13:20,990
that are in the string and that is the

00:13:19,640 --> 00:13:26,210
way we would think of it from a human

00:13:20,990 --> 00:13:28,220
perspective and if you want one of those

00:13:26,210 --> 00:13:30,920
other things we have other types to

00:13:28,220 --> 00:13:37,400
represent those other things so STR

00:13:30,920 --> 00:13:38,870
which is the one you use STR the STR

00:13:37,400 --> 00:13:40,160
type which is the one you use almost all

00:13:38,870 --> 00:13:41,330
the time it's the one that comes in the

00:13:40,160 --> 00:13:43,460
double quotes and the single quotes

00:13:41,330 --> 00:13:46,130
that's an immutable string and it's at

00:13:43,460 --> 00:13:47,900
the grapheme level if you want to deal

00:13:46,130 --> 00:13:51,560
with it as a sequence of code points

00:13:47,900 --> 00:13:55,130
instead of a sequence of graphemes then

00:13:51,560 --> 00:13:56,990
you would use the Uni type and if you

00:13:55,130 --> 00:13:59,840
want to deal with a sequence of bytes

00:13:56,990 --> 00:14:01,340
then that's called a buff and there are

00:13:59,840 --> 00:14:02,900
also things called blobs which are like

00:14:01,340 --> 00:14:05,270
Bluffs buffs but they can't have their

00:14:02,900 --> 00:14:07,730
values change they're immutable so you

00:14:05,270 --> 00:14:09,050
can always translate between string type

00:14:07,730 --> 00:14:10,520
and annuity type but if you have a

00:14:09,050 --> 00:14:13,370
sequence of bytes and you want it to be

00:14:10,520 --> 00:14:15,020
treated as Unicode you have to go

00:14:13,370 --> 00:14:17,270
through an end code or a decode step

00:14:15,020 --> 00:14:19,430
there's a method for doing that and in

00:14:17,270 --> 00:14:21,230
that encode step you would be able to

00:14:19,430 --> 00:14:24,020
say this is the actual encoding that I

00:14:21,230 --> 00:14:27,080
want you to convert it from in order to

00:14:24,020 --> 00:14:30,050
go into a string type so Jonathan has a

00:14:27,080 --> 00:14:32,720
quick slide here that we won't try real

00:14:30,050 --> 00:14:35,750
quick but here you can see that we have

00:14:32,720 --> 00:14:38,540
a letter a followed by a combining dot

00:14:35,750 --> 00:14:40,610
above and a combining dot below and if

00:14:38,540 --> 00:14:43,370
you do that what you get is you get a

00:14:40,610 --> 00:14:45,590
character that consists of an A with a

00:14:43,370 --> 00:14:47,510
dot above it the dot below it and that

00:14:45,590 --> 00:14:49,310
will work just fine in ruku Doe but if

00:14:47,510 --> 00:14:51,700
you ask how many characters are in that

00:14:49,310 --> 00:14:53,600
string it will tell you there's one and

00:14:51,700 --> 00:14:55,190
there's only one character in that

00:14:53,600 --> 00:14:58,400
string because it automatically does the

00:14:55,190 --> 00:14:59,810
combining so if we ask how many codes

00:14:58,400 --> 00:15:02,330
are in that string it would tell us

00:14:59,810 --> 00:15:05,570
three because that three there are three

00:15:02,330 --> 00:15:06,560
Unicode code points in there okay bad

00:15:05,570 --> 00:15:11,150
let's get beyond that

00:15:06,560 --> 00:15:13,460
all right boolean so there's a true

00:15:11,150 --> 00:15:17,030
boolean there is an actual boolean type

00:15:13,460 --> 00:15:19,400
in Perl six and there are built-in

00:15:17,030 --> 00:15:21,320
constants false and true and you can do

00:15:19,400 --> 00:15:24,110
what on false and true and

00:15:21,320 --> 00:15:26,900
determined that they are bulls all of

00:15:24,110 --> 00:15:29,120
the types that are in the core settings

00:15:26,900 --> 00:15:31,160
know how to boola fie themselves know

00:15:29,120 --> 00:15:33,320
how to say what their boolean value

00:15:31,160 --> 00:15:34,970
would be and the standard way to do that

00:15:33,320 --> 00:15:38,750
is with a question mark in front of it

00:15:34,970 --> 00:15:40,640
and so this is and the way to find out

00:15:38,750 --> 00:15:42,380
the opposite the negation of that is to

00:15:40,640 --> 00:15:44,180
use an exclamation point now everybody

00:15:42,380 --> 00:15:47,500
is probably familiar with using the

00:15:44,180 --> 00:15:49,940
exclamation point to me not right so

00:15:47,500 --> 00:15:53,180
this is actually one of those things

00:15:49,940 --> 00:15:55,250
that gets repeated a lot in Perl six the

00:15:53,180 --> 00:15:58,420
opposite of not is the question mark

00:15:55,250 --> 00:16:00,890
which is true right or as we call it so

00:15:58,420 --> 00:16:02,510
right people say why you'd have it so

00:16:00,890 --> 00:16:09,950
and the answer is it's the kids argument

00:16:02,510 --> 00:16:12,500
is not is so is is so right so if you

00:16:09,950 --> 00:16:14,030
wanted to test the the boolean this if

00:16:12,500 --> 00:16:15,500
you want to test if something is true or

00:16:14,030 --> 00:16:17,360
not then you put a question mark in

00:16:15,500 --> 00:16:19,640
front and you go I test if it's false

00:16:17,360 --> 00:16:21,050
then you put a if you know that's not

00:16:19,640 --> 00:16:24,320
true you put an exclamation point in

00:16:21,050 --> 00:16:26,720
front there's also the lower precedence

00:16:24,320 --> 00:16:29,600
forms of those which are so and not

00:16:26,720 --> 00:16:31,810
right so they have lower binding

00:16:29,600 --> 00:16:37,340
precedents to be able to do their things

00:16:31,810 --> 00:16:39,290
all right in fact the question mark and

00:16:37,340 --> 00:16:41,840
the bang of the exclamation point are

00:16:39,290 --> 00:16:44,450
just two coercion to coercion operators

00:16:41,840 --> 00:16:46,070
and there's more all right so the tilde

00:16:44,450 --> 00:16:48,410
which we used before to mean

00:16:46,070 --> 00:16:49,760
concatenation if you use it as a prefix

00:16:48,410 --> 00:16:52,460
operator it means stringify

00:16:49,760 --> 00:16:54,650
means take whatever it is that it's

00:16:52,460 --> 00:16:58,670
operating on and convert it into a

00:16:54,650 --> 00:17:00,200
string right and so in this example if I

00:16:58,670 --> 00:17:02,630
have four point two which would be a rat

00:17:00,200 --> 00:17:04,880
and I put the tilde in front then I

00:17:02,630 --> 00:17:06,589
would get back a string representation

00:17:04,880 --> 00:17:08,390
of that rational number which would

00:17:06,589 --> 00:17:12,079
probably be the characters four dot and

00:17:08,390 --> 00:17:14,570
two there are also plus and minus prefix

00:17:12,079 --> 00:17:16,400
operators that make things numeric so if

00:17:14,570 --> 00:17:18,230
you put plus in front of a string or

00:17:16,400 --> 00:17:19,970
some other objects then it will give you

00:17:18,230 --> 00:17:21,500
back a numeric value corresponding to

00:17:19,970 --> 00:17:23,630
what it thinks it's numeric value should

00:17:21,500 --> 00:17:25,100
be if you put a minus sign then it will

00:17:23,630 --> 00:17:26,600
give you back a numeric value but it

00:17:25,100 --> 00:17:31,540
will give you the opposite one the

00:17:26,600 --> 00:17:32,840
negation of that right and so these five

00:17:31,540 --> 00:17:35,420
characters

00:17:32,840 --> 00:17:37,760
question mark bang Tildy

00:17:35,420 --> 00:17:41,750
- are your standard ways for converting

00:17:37,760 --> 00:17:44,240
among these types and you see that

00:17:41,750 --> 00:17:45,860
repeated throughout the language so

00:17:44,240 --> 00:17:47,870
anytime you see a question mark or an

00:17:45,860 --> 00:17:50,480
exclamation point it usually means

00:17:47,870 --> 00:17:55,070
something that means like I'm testing

00:17:50,480 --> 00:17:57,560
for boolean nature somehow if you try

00:17:55,070 --> 00:17:59,480
and nullify a string that doesn't

00:17:57,560 --> 00:18:03,290
contain a valid number you will get an

00:17:59,480 --> 00:18:07,870
exception alright and so the typical

00:18:03,290 --> 00:18:10,460
example of that is if I say plus hello

00:18:07,870 --> 00:18:13,100
right then it'll say I can't convert

00:18:10,460 --> 00:18:16,700
that string to a number right because

00:18:13,100 --> 00:18:21,080
it's not a valid numeric string if I say

00:18:16,700 --> 00:18:24,110
1 2 3 then it says I can do that if once

00:18:21,080 --> 00:18:26,150
the entire string to be the number so

00:18:24,110 --> 00:18:28,280
again in pearls and pro/5 you could you

00:18:26,150 --> 00:18:30,950
could do this and you would get 123 in

00:18:28,280 --> 00:18:35,390
Perl 6 it says that whole string is not

00:18:30,950 --> 00:18:41,600
a number so it will white-spaces or a

00:18:35,390 --> 00:18:43,100
lot but other characters are not there's

00:18:41,600 --> 00:18:47,540
a note here that what you get back is

00:18:43,100 --> 00:18:50,360
called a failure and not necessarily an

00:18:47,540 --> 00:18:52,790
error so for example if I do I'm gonna

00:18:50,360 --> 00:18:58,490
do variables a bit later but if I say my

00:18:52,790 --> 00:18:59,630
my a equals plus hello and then say and

00:18:58,490 --> 00:19:04,880
I'll just say the value of one you'll

00:18:59,630 --> 00:19:06,800
see I didn't get the error right the

00:19:04,880 --> 00:19:08,450
error message didn't come up and so

00:19:06,800 --> 00:19:10,190
everybody says oh wait what happened to

00:19:08,450 --> 00:19:12,740
that exception it should have been an

00:19:10,190 --> 00:19:14,480
error and I can do other things here

00:19:12,740 --> 00:19:16,700
like if I say might be equals three

00:19:14,480 --> 00:19:19,600
divided by zero say one where's the

00:19:16,700 --> 00:19:22,190
error I just did a division by zero

00:19:19,600 --> 00:19:23,900
where is the error that happens to be

00:19:22,190 --> 00:19:26,480
there it turns out that at this point

00:19:23,900 --> 00:19:29,780
dollar a and dollar B hold an error

00:19:26,480 --> 00:19:32,390
object that says exactly what the type

00:19:29,780 --> 00:19:33,830
of error is and if you try and use those

00:19:32,390 --> 00:19:36,050
values so it didn't throw an exception

00:19:33,830 --> 00:19:37,840
it didn't make your program die but as

00:19:36,050 --> 00:19:41,150
soon as you try and use them in a way

00:19:37,840 --> 00:19:42,920
that is not error handling then they

00:19:41,150 --> 00:19:44,390
will warn you about it so if I say tell

00:19:42,920 --> 00:19:46,450
me the value of a it says no can't

00:19:44,390 --> 00:19:49,880
convert to string to a number

00:19:46,450 --> 00:19:52,340
right if I try and say the value of B

00:19:49,880 --> 00:19:57,380
nope I attempted to draw a vide three by

00:19:52,340 --> 00:19:59,870
zero and it doesn't know where I did it

00:19:57,380 --> 00:20:02,929
because I'm doing it from the repple

00:19:59,870 --> 00:20:04,730
okay so sometimes you can do things that

00:20:02,929 --> 00:20:06,710
are errors and they generate errors but

00:20:04,730 --> 00:20:08,210
they don't show up at the point of where

00:20:06,710 --> 00:20:10,429
the error occurred they show up later

00:20:08,210 --> 00:20:12,800
when you try and use them Perl 6 has a

00:20:10,429 --> 00:20:20,179
lot of laziness built in maybe that's

00:20:12,800 --> 00:20:23,200
why it took so long to create that's

00:20:20,179 --> 00:20:23,200
true a multiple levels

00:20:24,250 --> 00:20:30,620
all right so try a little bit with

00:20:27,380 --> 00:20:33,320
coercion so try and figure out what does

00:20:30,620 --> 00:20:33,800
the null string bulla Phi - is it true

00:20:33,320 --> 00:20:36,620
or false

00:20:33,800 --> 00:20:38,990
what does 0 bulla Phi - true or false

00:20:36,620 --> 00:20:40,490
what is false abilify - is it true or

00:20:38,990 --> 00:20:43,040
false

00:20:40,490 --> 00:20:46,460
what types do you get if you

00:20:43,040 --> 00:20:48,320
NUMA Phi those different strings now

00:20:46,460 --> 00:20:50,570
when you do these it does warn you be

00:20:48,320 --> 00:20:53,150
careful with precedents the method call

00:20:50,570 --> 00:20:56,240
binds tighter than operators do so you

00:20:53,150 --> 00:20:57,620
have to parenthesize to them and then

00:20:56,240 --> 00:20:59,330
what it's true and false name of Phi -

00:20:57,620 --> 00:21:04,550
and I'll just give a couple of seconds

00:20:59,330 --> 00:21:06,080
and then we'll just run through them and

00:21:04,550 --> 00:21:08,090
we can even do a guess here for people

00:21:06,080 --> 00:21:15,490
who don't so string values the null

00:21:08,090 --> 00:21:15,490
string bulla Phi's - what false right

00:21:16,960 --> 00:21:23,080
false what was all that the wind up

00:21:20,660 --> 00:21:23,080
above it

00:21:31,330 --> 00:21:36,470
there we go it's all those exceptions I

00:21:34,580 --> 00:21:40,910
left lying around it's warning me dead

00:21:36,470 --> 00:21:46,330
bad things you want on alrighty so so

00:21:40,910 --> 00:21:51,320
that one so how about the about zero

00:21:46,330 --> 00:21:53,809
true what is false in Perl 5 if I want

00:21:51,320 --> 00:21:57,250
to test if it's zero and it's a string

00:21:53,809 --> 00:21:57,250
then I should do this

00:21:59,320 --> 00:22:02,799
and I'm gonna put spaces in here just to

00:22:01,640 --> 00:22:05,090
make sure

00:22:02,799 --> 00:22:09,080
NUMA fie it then check it for its

00:22:05,090 --> 00:22:11,059
boolean value right so that's saying

00:22:09,080 --> 00:22:13,640
give me the boolean notification of the

00:22:11,059 --> 00:22:16,429
numa fication of that string right but

00:22:13,640 --> 00:22:24,590
if I just do a string only the empty

00:22:16,429 --> 00:22:26,059
string is now false okay so only the

00:22:24,590 --> 00:22:27,470
empty string is false even the string

00:22:26,059 --> 00:22:31,730
containing false it's not false that's

00:22:27,470 --> 00:22:34,100
true which sounds like a paradox alright

00:22:31,730 --> 00:22:37,940
what types do we get for these different

00:22:34,100 --> 00:22:43,840
things so 4 plus 42 right in what plus

00:22:37,940 --> 00:22:47,120
1.5 plus 4.2 e4

00:22:43,840 --> 00:22:50,390
we get away nope that one is gonna

00:22:47,120 --> 00:22:52,990
expend it in it so it'll be a new it'll

00:22:50,390 --> 00:22:52,990
be a floating-point number

00:22:55,059 --> 00:22:58,330
not what

00:23:01,980 --> 00:23:05,510
so that'll be a floating-point number

00:23:13,729 --> 00:23:16,959
everybody want to take you guess

00:23:18,620 --> 00:23:29,419
four plus 3i is a complex number the

00:23:27,260 --> 00:23:36,860
complex numbers also built into pearl

00:23:29,419 --> 00:23:38,679
six okay and then what to true and false

00:23:36,860 --> 00:23:43,400
Lima fights you what would you expect

00:23:38,679 --> 00:23:48,559
true would Numa Phi two one

00:23:43,400 --> 00:23:51,520
right and false would Numa Phi 2 0 42

00:23:48,559 --> 00:23:51,520
all right zero

00:23:54,220 --> 00:24:02,779
all right variables so we start with

00:24:00,320 --> 00:24:06,679
scalars a scalar variable holds a single

00:24:02,779 --> 00:24:10,370
item it has the dollar sign sigil which

00:24:06,679 --> 00:24:13,399
just looks like a very expensive s in

00:24:10,370 --> 00:24:16,460
Perl 6 we require all your variables to

00:24:13,399 --> 00:24:18,919
be explicitly declared so it's like use

00:24:16,460 --> 00:24:21,320
strict design so my dollar sign answer

00:24:18,919 --> 00:24:24,409
equals 42 creates a variable called

00:24:21,320 --> 00:24:26,990
answer it gives it the value 42 scalars

00:24:24,409 --> 00:24:28,880
are first-class objects in Perl 6 so we

00:24:26,990 --> 00:24:32,059
actually there's actually a scalar type

00:24:28,880 --> 00:24:33,700
but most of the time you don't encounter

00:24:32,059 --> 00:24:38,899
it unless you're doing weird things

00:24:33,700 --> 00:24:42,049
right so if I go through and say what

00:24:38,899 --> 00:24:43,340
kind of thing is answer it tells me in

00:24:42,049 --> 00:24:45,620
this case it's an int because it's

00:24:43,340 --> 00:24:48,110
holding the 42 even though answer is

00:24:45,620 --> 00:24:49,640
actually a scalar holding an int but

00:24:48,110 --> 00:24:51,590
usually the the fact that there's a

00:24:49,640 --> 00:24:54,679
scalar there kind of drops out of the

00:24:51,590 --> 00:24:56,690
picture right so the way that we think

00:24:54,679 --> 00:24:57,830
about it in terms of compiler terms and

00:24:56,690 --> 00:24:59,510
you don't have to think about it this

00:24:57,830 --> 00:25:01,399
way is the beginning programmer too much

00:24:59,510 --> 00:25:03,620
but you should be aware of it a little

00:25:01,399 --> 00:25:06,350
bit is that dollar sign answer is our

00:25:03,620 --> 00:25:08,149
variable name it's bound to a scalar

00:25:06,350 --> 00:25:12,919
which I always think of scalars as being

00:25:08,149 --> 00:25:17,200
boxes when I first learned to program 26

00:25:12,919 --> 00:25:19,640
36 years ago I had a book from that

00:25:17,200 --> 00:25:22,070
article I found in byte magazine and

00:25:19,640 --> 00:25:24,409
they described variables as boxes with

00:25:22,070 --> 00:25:26,480
Leonard with labels on them and that was

00:25:24,409 --> 00:25:29,120
the model I use and it works really well

00:25:26,480 --> 00:25:31,210
for that so dollar sign answer in this

00:25:29,120 --> 00:25:33,070
case is the label it's

00:25:31,210 --> 00:25:34,659
currently referencing a box and inside

00:25:33,070 --> 00:25:40,690
that box there's an integers that says

00:25:34,659 --> 00:25:42,669
42 there is another operation in Perl 6

00:25:40,690 --> 00:25:45,669
called binding and it's done with the

00:25:42,669 --> 00:25:48,220
colon equals operator and I remember dr.

00:25:45,669 --> 00:25:49,750
Conway in 2005 at OSCON saying that any

00:25:48,220 --> 00:25:58,450
language that has a colon equals

00:25:49,750 --> 00:26:00,279
operation and it is doomed so we'll

00:25:58,450 --> 00:26:02,529
start with just this plane assignment so

00:26:00,279 --> 00:26:04,029
if you used the assignment operator then

00:26:02,529 --> 00:26:07,750
that takes whatever was in that box

00:26:04,029 --> 00:26:09,549
whatever was in that variable and given

00:26:07,750 --> 00:26:11,470
a new value given a new item to keep

00:26:09,549 --> 00:26:13,330
track of so here we would give answer

00:26:11,470 --> 00:26:15,070
the value of 2 here we take what's in

00:26:13,330 --> 00:26:16,929
answer which is currently 2 when we add

00:26:15,070 --> 00:26:19,120
19 to it which makes 21 and we stick

00:26:16,929 --> 00:26:21,370
that in answer there's the shortcut

00:26:19,120 --> 00:26:23,500
notation this says take answer multiply

00:26:21,370 --> 00:26:27,700
it by 2 and store back in answer right

00:26:23,500 --> 00:26:29,740
pretty standard stuff but Perl 6 also

00:26:27,700 --> 00:26:31,809
provides binding which is the colon

00:26:29,740 --> 00:26:33,730
equal operator and what that does is

00:26:31,809 --> 00:26:35,710
that takes that name that variable name

00:26:33,730 --> 00:26:39,159
and attaches it directly to a value with

00:26:35,710 --> 00:26:41,080
no box all right there's no box that you

00:26:39,159 --> 00:26:42,640
put it in so it's as if I had this in

00:26:41,080 --> 00:26:45,039
this case I had this string called

00:26:42,640 --> 00:26:48,880
hammer and I stuck the label right onto

00:26:45,039 --> 00:26:51,700
it and so if I try and assign to that

00:26:48,880 --> 00:26:53,350
variable name then it will die it will

00:26:51,700 --> 00:26:55,510
say I can't do that because the string

00:26:53,350 --> 00:26:58,480
is not a box it's not something I can

00:26:55,510 --> 00:27:00,730
puts things into and so I can't replace

00:26:58,480 --> 00:27:04,090
that string with a new value and it will

00:27:00,730 --> 00:27:06,490
give us an error all so we'll just segue

00:27:04,090 --> 00:27:08,529
here a lot of people have noted variable

00:27:06,490 --> 00:27:12,490
names can have apostrophes and hyphens

00:27:08,529 --> 00:27:14,980
in them and I think the general rule is

00:27:12,490 --> 00:27:20,260
it can have a very apostrophe or - as

00:27:14,980 --> 00:27:22,390
long as it's followed by a letter if

00:27:20,260 --> 00:27:23,740
it's not followed by a letter than the -

00:27:22,390 --> 00:27:28,899
or the apostrophe is not part of the

00:27:23,740 --> 00:27:30,850
identifier all right and so if you try

00:27:28,899 --> 00:27:32,440
and do that sort of assignment in this

00:27:30,850 --> 00:27:34,270
case you will get an exception ASIST

00:27:32,440 --> 00:27:38,919
cannot write to a read-only string or

00:27:34,270 --> 00:27:40,840
something like that so you're not likely

00:27:38,919 --> 00:27:44,080
to see binding you're not likely to use

00:27:40,840 --> 00:27:46,030
that colon equal operator a lot yourself

00:27:44,080 --> 00:27:47,500
I mean it's very useful and we use it a

00:27:46,030 --> 00:27:49,780
lot within the court but you know

00:27:47,500 --> 00:27:52,420
standard programming it's not but it's

00:27:49,780 --> 00:27:53,830
really useful to know that it exists

00:27:52,420 --> 00:27:56,350
because there are a lot of other parts

00:27:53,830 --> 00:27:57,910
of the Perl 6 language where you're

00:27:56,350 --> 00:27:59,650
doing binding even though you're not

00:27:57,910 --> 00:28:01,090
using the colon equals and it's good to

00:27:59,650 --> 00:28:04,390
know that that's what's happening behind

00:28:01,090 --> 00:28:07,360
the scenes if you want to know if there

00:28:04,390 --> 00:28:12,070
is a scalar behind a name then use dot

00:28:07,360 --> 00:28:15,370
VAR and so if you've are on a variable

00:28:12,070 --> 00:28:17,800
it will tell you what it really is right

00:28:15,370 --> 00:28:19,390
and it actually gives you back the thing

00:28:17,800 --> 00:28:20,770
that it really is as opposed to if it's

00:28:19,390 --> 00:28:23,410
a scalar the thing that's inside the

00:28:20,770 --> 00:28:25,900
scalar and so in this particular example

00:28:23,410 --> 00:28:27,520
here I have answers 42 and if I say

00:28:25,900 --> 00:28:30,040
answered var that gives me back the

00:28:27,520 --> 00:28:32,530
scalar box and I say what then it tells

00:28:30,040 --> 00:28:34,900
me it's a scalar but if I did the

00:28:32,530 --> 00:28:36,820
binding and said can't assign is bound

00:28:34,900 --> 00:28:38,170
directly to a string and I do the dollar

00:28:36,820 --> 00:28:40,540
var then it just gives me back the

00:28:38,170 --> 00:28:42,510
string because there was no box and if I

00:28:40,540 --> 00:28:53,950
say 1 on that then it gives me a string

00:28:42,510 --> 00:29:02,590
yes it's a scalar variable it's a scalar

00:28:53,950 --> 00:29:04,900
variable I'm sorry what yeah yeah again

00:29:02,590 --> 00:29:07,330
this doesn't happen commonly so you know

00:29:04,900 --> 00:29:09,160
it's hard to do I tend when I need to

00:29:07,330 --> 00:29:12,760
make the distinction I usually say

00:29:09,160 --> 00:29:16,000
dollar answer is the variable and it is

00:29:12,760 --> 00:29:18,690
referencing a scalar except I try not to

00:29:16,000 --> 00:29:18,690
use the word reference

00:29:19,020 --> 00:29:29,800
so it but the I think the easier way to

00:29:26,260 --> 00:29:32,830
say it is a scalar variable that box can

00:29:29,800 --> 00:29:36,010
contain things that we in pro/5 didn't

00:29:32,830 --> 00:29:39,420
used to think of as scalar values like a

00:29:36,010 --> 00:29:39,420
scalar variable can hold an array

00:29:47,990 --> 00:29:52,190
all right and so a lot of people say oh

00:29:50,780 --> 00:29:53,990
that's an array Ref well we don't have a

00:29:52,190 --> 00:29:56,500
Rea refs in Perl 6 but if I ask what

00:29:53,990 --> 00:29:58,900
kind of thing is is a it's an array

00:29:56,500 --> 00:30:04,340
right so scalar variables

00:29:58,900 --> 00:30:06,559
scalar variables are what's the easy way

00:30:04,340 --> 00:30:09,610
to scalar variables just holding up they

00:30:06,559 --> 00:30:12,050
reference an object they hold an object

00:30:09,610 --> 00:30:16,370
and there's no coercion that takes place

00:30:12,050 --> 00:30:18,920
there a contact sensitivity goes away we

00:30:16,370 --> 00:30:21,350
have no more contact stuff let me get to

00:30:18,920 --> 00:30:22,250
that a little bit I got it

00:30:21,350 --> 00:30:24,200
was there another question in the back

00:30:22,250 --> 00:30:29,840
or was that a stretch it was a stretch

00:30:24,200 --> 00:30:32,179
all right okay oh just so this note if

00:30:29,840 --> 00:30:34,550
you're using bar and what in your code

00:30:32,179 --> 00:30:36,470
those are code smells those are things

00:30:34,550 --> 00:30:38,120
we are not you're probably not doing

00:30:36,470 --> 00:30:40,220
what Perl sticks really wants you to do

00:30:38,120 --> 00:30:42,980
so if you want to test the type of the

00:30:40,220 --> 00:30:44,660
variable you probably don't do it using

00:30:42,980 --> 00:30:46,520
what you would use the smart match if

00:30:44,660 --> 00:30:50,000
you want to find out if the variable or

00:30:46,520 --> 00:30:51,920
not you can you know in them in the most

00:30:50,000 --> 00:30:53,630
common cases you shouldn't need to be

00:30:51,920 --> 00:30:56,480
using those they're really there for

00:30:53,630 --> 00:31:02,630
debugging and for doing weird behind the

00:30:56,480 --> 00:31:04,280
scenes compiler stuff okay so let's work

00:31:02,630 --> 00:31:05,360
out the following if you have a scalar

00:31:04,280 --> 00:31:12,740
and you have an assigned to the value

00:31:05,360 --> 00:31:15,770
what is in it to begin with and then can

00:31:12,740 --> 00:31:17,900
a variable change its type over time if

00:31:15,770 --> 00:31:19,190
we stick it into into a variable can we

00:31:17,900 --> 00:31:21,309
put something of a different type into

00:31:19,190 --> 00:31:21,309
it

00:31:24,660 --> 00:31:31,890
all right so let's uh let's just try

00:31:27,360 --> 00:31:37,140
that so here's my scalar variable and if

00:31:31,890 --> 00:31:39,810
I say what is it should have done that

00:31:37,140 --> 00:31:45,960
all on one line but either way then it

00:31:39,810 --> 00:31:48,660
tells me that it's an any okay so what

00:31:45,960 --> 00:31:49,770
is that any look like first of all for

00:31:48,660 --> 00:31:51,330
based on the other things that we've

00:31:49,770 --> 00:31:52,560
seen what kind of what kind of thing

00:31:51,330 --> 00:31:57,860
does any look like to you

00:31:52,560 --> 00:32:00,540
like if I did this right int was a type

00:31:57,860 --> 00:32:04,790
right we kind of know that because it

00:32:00,540 --> 00:32:08,970
shows the parens there right so any is a

00:32:04,790 --> 00:32:12,420
it's a type okay fact it's like it's

00:32:08,970 --> 00:32:14,100
it's one of the more generic types it's

00:32:12,420 --> 00:32:16,140
not the most generic type but in other

00:32:14,100 --> 00:32:18,570
languages it might be the class that we

00:32:16,140 --> 00:32:20,370
would consider to be object right kind

00:32:18,570 --> 00:32:22,440
of the root of our object system and

00:32:20,370 --> 00:32:24,210
again it's not the root of the Perl 6

00:32:22,440 --> 00:32:27,810
object system but it's pretty close to

00:32:24,210 --> 00:32:30,930
the root so any is the type from which

00:32:27,810 --> 00:32:34,140
most of the other types derive and what

00:32:30,930 --> 00:32:36,240
is being held in a scalar variable when

00:32:34,140 --> 00:32:39,060
you create it but before you initialize

00:32:36,240 --> 00:32:43,290
it to anything is the type object itself

00:32:39,060 --> 00:32:48,750
the any type itself and the nice thing

00:32:43,290 --> 00:32:53,550
about the type objects is that they're

00:32:48,750 --> 00:32:55,920
undefined right and so this notion of

00:32:53,550 --> 00:32:57,450
undef that we have in Perl 5 in Perl 6

00:32:55,920 --> 00:32:59,940
we have undef but they're all typed on

00:32:57,450 --> 00:33:01,980
gifts right and so you won't actually

00:32:59,940 --> 00:33:04,230
see undef what you usually have is some

00:33:01,980 --> 00:33:06,660
sort of a type object that represents

00:33:04,230 --> 00:33:08,940
undefined in this for a type so if I say

00:33:06,660 --> 00:33:13,590
is the int type defined then it will say

00:33:08,940 --> 00:33:16,410
false all right so we go a little bit

00:33:13,590 --> 00:33:18,630
beyond just you know the the standard

00:33:16,410 --> 00:33:19,530
notion of this is undefined to actually

00:33:18,630 --> 00:33:22,680
saying well there are many different

00:33:19,530 --> 00:33:25,560
types of undefined in this and the the

00:33:22,680 --> 00:33:29,070
base type reach for each of our built-in

00:33:25,560 --> 00:33:30,360
types that's certainly the case all

00:33:29,070 --> 00:33:34,490
right can a variable change its type

00:33:30,360 --> 00:33:34,490
over time yes or no

00:33:35,340 --> 00:33:41,980
yes all right

00:33:37,300 --> 00:33:44,140
yes so when I was a professor I would

00:33:41,980 --> 00:33:47,190
ask my students a question and if they

00:33:44,140 --> 00:33:47,190
didn't answer we sat there

00:33:49,440 --> 00:33:53,590
so yes the variable can change its type

00:33:52,060 --> 00:33:57,970
over time and if it couldn't it wouldn't

00:33:53,590 --> 00:33:59,560
be purl right and then if we tried this

00:33:57,970 --> 00:34:02,470
code at the bottom anybody know what a

00:33:59,560 --> 00:34:04,540
is going to say what value it's going to

00:34:02,470 --> 00:34:06,490
have there's not only gonna be two

00:34:04,540 --> 00:34:09,910
answers right it's either gonna be 42 or

00:34:06,490 --> 00:34:12,000
100 how many people I say 42 I got a

00:34:09,910 --> 00:34:17,740
couple of 42 is how many want to say 100

00:34:12,000 --> 00:34:22,210
how many want say undef Hey all right so

00:34:17,740 --> 00:34:24,220
it's going to say 100 okay it's going to

00:34:22,210 --> 00:34:25,750
say 100 and you could try it on your

00:34:24,220 --> 00:34:27,700
laptop's but essentially here's the way

00:34:25,750 --> 00:34:30,460
to think of it right so my dollar i

00:34:27,700 --> 00:34:32,470
equals 42 so I create a box that is a

00:34:30,460 --> 00:34:35,890
scalar stick 42 in it and a is the name

00:34:32,470 --> 00:34:38,050
of the box and then I do the binding so

00:34:35,890 --> 00:34:41,790
B becomes the name for whatever a is a

00:34:38,050 --> 00:34:45,130
is a box so B is the name for the box

00:34:41,790 --> 00:34:48,190
same box so now I'm gonna stick 100 into

00:34:45,130 --> 00:34:51,430
B so that box now has 100 in it that box

00:34:48,190 --> 00:34:53,590
has got two names a and B so when I say

00:34:51,430 --> 00:34:56,110
a we go to a and we look in the box it's

00:34:53,590 --> 00:34:59,740
got 100 and it says 100 right so binding

00:34:56,110 --> 00:35:04,600
is a way of attaching multiple names to

00:34:59,740 --> 00:35:07,480
an object right so that's what binding

00:35:04,600 --> 00:35:09,250
does now the place where that actually

00:35:07,480 --> 00:35:11,200
happens and again it's typically behind

00:35:09,250 --> 00:35:15,070
the scenes is when you do a subroutine

00:35:11,200 --> 00:35:17,380
call if I do a subroutine call and I

00:35:15,070 --> 00:35:18,670
pass a value to the subroutine on the

00:35:17,380 --> 00:35:21,640
other side because we have formal

00:35:18,670 --> 00:35:23,950
parameters those formal parameters often

00:35:21,640 --> 00:35:27,220
become aliases to the value that came in

00:35:23,950 --> 00:35:30,670
and what the way we do that is it's a

00:35:27,220 --> 00:35:33,010
binding we bind a name to whatever came

00:35:30,670 --> 00:35:35,140
in and if what came in was a constant

00:35:33,010 --> 00:35:39,000
value I can't assign to it if what came

00:35:35,140 --> 00:35:41,440
in was a box I can write to it all right

00:35:39,000 --> 00:35:44,660
so that's what binding is happening

00:35:41,440 --> 00:35:48,180
behind the scenes anyway a is 100

00:35:44,660 --> 00:35:50,150
any questions on scalars beyond the ones

00:35:48,180 --> 00:35:52,650
I couldn't answer

00:35:50,150 --> 00:35:55,589
all right so an array is an ordered

00:35:52,650 --> 00:35:57,359
collection of scalars it can grow on

00:35:55,589 --> 00:35:59,460
demand it can be used like a queue or a

00:35:57,359 --> 00:36:01,369
stack the easiest way to get an array is

00:35:59,460 --> 00:36:04,200
to declare a variable with an axonal

00:36:01,369 --> 00:36:07,680
when you assign to anything with an @

00:36:04,200 --> 00:36:09,119
sigil then the compiler knows you're

00:36:07,680 --> 00:36:11,009
doing something that looks like a list

00:36:09,119 --> 00:36:12,569
assignment so it will parse whatever's

00:36:11,009 --> 00:36:15,599
on the right-hand side of the equal sign

00:36:12,569 --> 00:36:18,960
as a list what we call list precedence

00:36:15,599 --> 00:36:22,440
so this code here my country's equals

00:36:18,960 --> 00:36:24,839
this list of countries that works right

00:36:22,440 --> 00:36:27,539
that in this particular case because of

00:36:24,839 --> 00:36:29,519
the @ sign here on the left hand side it

00:36:27,539 --> 00:36:32,489
knows that the comma has higher

00:36:29,519 --> 00:36:34,259
precedence than the equal sign and so it

00:36:32,489 --> 00:36:37,769
should take this comma separated list of

00:36:34,259 --> 00:36:40,499
things and put it into countries if you

00:36:37,769 --> 00:36:41,910
asked an array you know if you declare

00:36:40,499 --> 00:36:43,229
an array this way and you say what type

00:36:41,910 --> 00:36:45,420
is it then you get back that it's an

00:36:43,229 --> 00:36:46,859
array and they know the number of

00:36:45,420 --> 00:36:49,920
elements again we don't have length in

00:36:46,859 --> 00:36:51,089
Perl 6 so if I just say array element

00:36:49,920 --> 00:36:54,420
that will tell you how many things are

00:36:51,089 --> 00:36:55,950
in the array now an array is an ordered

00:36:54,420 --> 00:36:57,479
collection of scalars so I think of it

00:36:55,950 --> 00:37:00,420
as an array is an ordered collection of

00:36:57,479 --> 00:37:01,769
boxes so if I say how many elements are

00:37:00,420 --> 00:37:04,469
in the array tells me how many boxes

00:37:01,769 --> 00:37:05,849
there are in the array then tell me you

00:37:04,469 --> 00:37:08,099
know some of those boxes may not have

00:37:05,849 --> 00:37:10,289
had anything put into them yet but it'll

00:37:08,099 --> 00:37:11,849
tell me how many they are and again

00:37:10,289 --> 00:37:15,299
there's no length so we say Elam's when

00:37:11,849 --> 00:37:16,640
we want to get the number of items in

00:37:15,299 --> 00:37:19,650
the array

00:37:16,640 --> 00:37:23,009
the brackets array indexer can be used

00:37:19,650 --> 00:37:24,359
with a single element as an argument so

00:37:23,009 --> 00:37:26,039
and if you assign the one that doesn't

00:37:24,359 --> 00:37:29,190
exist the array automatically grows to

00:37:26,039 --> 00:37:32,039
accommodate it so here we can say what

00:37:29,190 --> 00:37:35,579
is countries at position 0 at index 0

00:37:32,039 --> 00:37:38,549
and it comes back UK if I stick a string

00:37:35,579 --> 00:37:40,049
into the array at position 4 there

00:37:38,549 --> 00:37:41,460
wasn't anything there before so the

00:37:40,049 --> 00:37:43,950
array grows by 1 to be able to

00:37:41,460 --> 00:37:45,329
accommodate it and now I can ask how

00:37:43,950 --> 00:37:50,599
many elements are in the array it's now

00:37:45,329 --> 00:37:53,880
grown to 5 elements right you can also

00:37:50,599 --> 00:37:55,279
do multiple arguments inside the

00:37:53,880 --> 00:37:58,140
brackets in which case you get a slice

00:37:55,279 --> 00:38:00,630
so if you come from Perl 6 land

00:37:58,140 --> 00:38:02,519
I'll and you know that you use the sigil

00:38:00,630 --> 00:38:04,049
to say whether you wanted a scalar value

00:38:02,519 --> 00:38:06,599
back or a list value back we don't do

00:38:04,049 --> 00:38:09,569
that in Perl 6 in Perl 6 the sigil is

00:38:06,599 --> 00:38:12,480
part of variable name right so it's

00:38:09,569 --> 00:38:14,369
always at sign countries and what

00:38:12,480 --> 00:38:16,529
determines if we get a single element

00:38:14,369 --> 00:38:19,049
back or a list back is whether we passed

00:38:16,529 --> 00:38:21,319
a single value into the brackets or if

00:38:19,049 --> 00:38:23,880
we passed a list thing into the brackets

00:38:21,319 --> 00:38:25,769
so whatever we passed into the brackets

00:38:23,880 --> 00:38:28,200
if it has multiple things here then

00:38:25,769 --> 00:38:30,240
we're going to get a slice and it just

00:38:28,200 --> 00:38:32,819
has a single item in it then we're going

00:38:30,240 --> 00:38:35,099
to likely get a scalar element so if I

00:38:32,819 --> 00:38:38,039
want to swap two values then this takes

00:38:35,099 --> 00:38:41,490
the elements that our index is 1 & 2 and

00:38:38,039 --> 00:38:42,960
swap some if I want to get 3 of the

00:38:41,490 --> 00:38:45,210
elements out then I can say give me the

00:38:42,960 --> 00:38:47,609
country's at position 0 1 & 2 and I'll

00:38:45,210 --> 00:38:49,740
get back to the UK Spain in Slovakia or

00:38:47,609 --> 00:38:51,630
if I wanted to send a range I can say

00:38:49,740 --> 00:38:53,849
give me everything from 0 to 2 and that

00:38:51,630 --> 00:38:55,380
will work exactly the same or I can say

00:38:53,849 --> 00:39:03,569
give me everything up to the third one

00:38:55,380 --> 00:39:04,980
and it'll do exactly the same thing when

00:39:03,569 --> 00:39:07,079
you assign to an array each of them it's

00:39:04,980 --> 00:39:08,970
a scalar container so you can do binding

00:39:07,079 --> 00:39:10,589
into the middle of array you won't do

00:39:08,970 --> 00:39:12,750
that much yourself but that's the way

00:39:10,589 --> 00:39:16,529
that increment works on a race I'm gonna

00:39:12,750 --> 00:39:19,740
skip that because it's not too

00:39:16,529 --> 00:39:22,980
interesting we have a quote words

00:39:19,740 --> 00:39:26,519
mechanism in Perl 6 we still have the

00:39:22,980 --> 00:39:29,099
Perl 5 1qw but instead of writing all of

00:39:26,519 --> 00:39:31,500
the quotation marks with the commas you

00:39:29,099 --> 00:39:35,940
can do the single angle brackets

00:39:31,500 --> 00:39:40,380
that's our quote words notation in Perl

00:39:35,940 --> 00:39:42,000
6 and it separates on whitespace if you

00:39:40,380 --> 00:39:43,650
have something in there that needs to

00:39:42,000 --> 00:39:46,589
have white space but be a single element

00:39:43,650 --> 00:39:50,009
then there's the double angle brackets

00:39:46,589 --> 00:39:51,509
and in the double angle brackets it

00:39:50,009 --> 00:39:53,519
interpolates things that are between

00:39:51,509 --> 00:39:56,190
them so in this case this would give us

00:39:53,519 --> 00:39:58,980
4 elements the first one would be United

00:39:56,190 --> 00:40:00,930
Kingdom and then the second third and

00:39:58,980 --> 00:40:06,089
fourth ones would be Slovakia Spain and

00:40:00,930 --> 00:40:07,890
Sweden the way to keep in keeping in

00:40:06,089 --> 00:40:09,660
mind or keep the correspondence it's

00:40:07,890 --> 00:40:11,170
roughly equivalent to the way single

00:40:09,660 --> 00:40:14,210
quotes and double quotes work

00:40:11,170 --> 00:40:15,619
single quotes give you exactly what's

00:40:14,210 --> 00:40:17,990
inside the quotes and they don't do any

00:40:15,619 --> 00:40:20,990
interpolation double quotes do

00:40:17,990 --> 00:40:22,670
interpolation single angle brackets give

00:40:20,990 --> 00:40:24,349
you exactly what's in there split on

00:40:22,670 --> 00:40:30,829
white space double brackets do some

00:40:24,349 --> 00:40:32,990
interpolation you can do push and pop on

00:40:30,829 --> 00:40:35,450
the end of an array there's push and pop

00:40:32,990 --> 00:40:36,770
functions as well if you want to work on

00:40:35,450 --> 00:40:39,619
the beginning of the array you can you

00:40:36,770 --> 00:40:45,470
shift and unshift using push and shift

00:40:39,619 --> 00:40:48,049
in combination you get cue semantics I'm

00:40:45,470 --> 00:40:49,910
gonna skip these because I only have

00:40:48,049 --> 00:40:54,230
seven minutes left I want to get through

00:40:49,910 --> 00:40:55,640
the next part hashes are good for

00:40:54,230 --> 00:40:58,730
storing mappings one thing to another

00:40:55,640 --> 00:41:02,690
hashes are probably the one thing that

00:40:58,730 --> 00:41:04,400
got me into Perl in the first place the

00:41:02,690 --> 00:41:06,950
easiest way to get a hash is declare it

00:41:04,400 --> 00:41:12,710
with the % sigil and we typically do

00:41:06,950 --> 00:41:14,380
pairs so this arrow notation in pro/5

00:41:12,710 --> 00:41:17,059
that was it's called the fat comma in

00:41:14,380 --> 00:41:20,270
Perl 6 it's the Parrot constructor so

00:41:17,059 --> 00:41:23,990
this is actually giving us - giving us a

00:41:20,270 --> 00:41:25,970
single object here that has a key of UK

00:41:23,990 --> 00:41:28,549
and a value of London and another one

00:41:25,970 --> 00:41:31,640
that has a key of Slovakia and a value

00:41:28,549 --> 00:41:33,529
of Bratislava but that's the way to

00:41:31,640 --> 00:41:35,660
initialize an array now you can do it

00:41:33,529 --> 00:41:38,150
the old way as well you could do it just

00:41:35,660 --> 00:41:40,700
copy you K comma London comma Slovakia

00:41:38,150 --> 00:41:43,270
comma Bratislava in which case it knows

00:41:40,700 --> 00:41:45,349
key value key value so that still works

00:41:43,270 --> 00:41:48,230
but typically we use the arrow notation

00:41:45,349 --> 00:41:50,450
nowadays so if you say what kind of

00:41:48,230 --> 00:41:51,799
variable is it says it's a hash if you

00:41:50,450 --> 00:41:53,809
say how many elements does it has have

00:41:51,799 --> 00:41:55,940
two there's two entries in the hash

00:41:53,809 --> 00:42:01,730
table there's two keys than the hash

00:41:55,940 --> 00:42:06,799
table hashes are indexed with the curly

00:42:01,730 --> 00:42:08,359
braces and just as before if I put one

00:42:06,799 --> 00:42:10,789
item in there I'm likely to get back a

00:42:08,359 --> 00:42:12,799
scalar and if I put multiple items in

00:42:10,789 --> 00:42:14,720
there I'm gonna get a list of some sort

00:42:12,799 --> 00:42:20,660
I'll get a slice of the hash

00:42:14,720 --> 00:42:23,730
and because we do litoral keys so often

00:42:20,660 --> 00:42:27,210
like this and there are no bare words in

00:42:23,730 --> 00:42:28,590
Perl six there's another notation to be

00:42:27,210 --> 00:42:31,140
able to look up things in a hash using

00:42:28,590 --> 00:42:32,820
the angle brackets and so if you use the

00:42:31,140 --> 00:42:37,290
angle brackets here then that quotes

00:42:32,820 --> 00:42:40,680
what's inside of it and again if you did

00:42:37,290 --> 00:42:43,320
this this would be a slice right those

00:42:40,680 --> 00:42:44,730
are in fact meant to be the same angle

00:42:43,320 --> 00:42:47,970
brackets that we saw in the quote words

00:42:44,730 --> 00:42:49,910
mechanism syntactically they occupy

00:42:47,970 --> 00:42:52,140
different space but they work the same

00:42:49,910 --> 00:42:54,480
that what we're doing is we're taking

00:42:52,140 --> 00:42:55,890
whatever's inside of these these angle

00:42:54,480 --> 00:43:03,240
brackets and separating them on white

00:42:55,890 --> 00:43:06,180
space double angle brackets worked there

00:43:03,240 --> 00:43:09,000
as well so you can interpolate in there

00:43:06,180 --> 00:43:12,500
and get string keys out that you would

00:43:09,000 --> 00:43:12,500
then be able to index into the hash with

00:43:14,330 --> 00:43:21,480
there's not an exist function or method

00:43:17,070 --> 00:43:23,310
in Perl six if you want to check for an

00:43:21,480 --> 00:43:26,730
entity in a hash you have to use the

00:43:23,310 --> 00:43:29,940
exists adverb pearl 6 has adverbs in it

00:43:26,730 --> 00:43:32,130
and they're signified by a colon and

00:43:29,940 --> 00:43:35,370
some sort of a word or identifier after

00:43:32,130 --> 00:43:37,230
that there are a lot of deep reasons why

00:43:35,370 --> 00:43:40,500
we can't do it as a function or method

00:43:37,230 --> 00:43:43,980
and so the exists adverb is the way that

00:43:40,500 --> 00:43:45,660
it gets done so if we say it's capitals

00:43:43,980 --> 00:43:47,310
is there something that exists at the

00:43:45,660 --> 00:43:48,960
key of UK that would come back is true

00:43:47,310 --> 00:43:50,550
and is there something in the hash that

00:43:48,960 --> 00:43:53,490
exists at a key of elbonia that would be

00:43:50,550 --> 00:43:55,920
false similar same thing for deletion if

00:43:53,490 --> 00:43:58,580
we want to remove something from a hash

00:43:55,920 --> 00:44:01,230
then we have to say delete as an adverb

00:43:58,580 --> 00:44:02,580
to go after that when you delete

00:44:01,230 --> 00:44:04,140
something you get back the thing that

00:44:02,580 --> 00:44:05,430
was deleted which is handli when you get

00:44:04,140 --> 00:44:07,320
back to thing that was deleted you

00:44:05,430 --> 00:44:10,520
actually get back the pair the key and

00:44:07,320 --> 00:44:10,520
the value not just the value

00:44:11,780 --> 00:44:17,430
if you want to get the keys of a hash

00:44:14,190 --> 00:44:18,900
then you just say dot keys if you want

00:44:17,430 --> 00:44:21,300
to get the values of the hash you can

00:44:18,900 --> 00:44:23,099
just say dot values so if I say keys

00:44:21,300 --> 00:44:26,099
then in this case it's gonna give me

00:44:23,099 --> 00:44:27,450
back my two keys of the hash if I ask

00:44:26,099 --> 00:44:29,430
for the values I get back the values

00:44:27,450 --> 00:44:30,720
that are in the hash and if you want to

00:44:29,430 --> 00:44:33,210
get an alternation of key and value

00:44:30,720 --> 00:44:34,710
pairs then you do Cavey in which case

00:44:33,210 --> 00:44:41,970
you get key and its value key and its

00:44:34,710 --> 00:44:44,010
value Keinath value all in a list it's

00:44:41,970 --> 00:44:46,680
individuals if I wanted a list of pairs

00:44:44,010 --> 00:44:54,450
then I would say dot pairs or just use

00:44:46,680 --> 00:44:57,599
the bit hash by itself okay so our

00:44:54,450 --> 00:45:00,869
pair's first class object in Perl 6 and

00:44:57,599 --> 00:45:04,440
when I say yes right probably dave says

00:45:00,869 --> 00:45:08,810
yes so he's it's gotta be right right so

00:45:04,440 --> 00:45:08,810
let's just do that one real quick oops

00:45:13,970 --> 00:45:18,950
so there it is and if I say what is it

00:45:16,069 --> 00:45:29,240
tells me it's a pair right it's built in

00:45:18,950 --> 00:45:30,920
tight suppose you declare the cat the

00:45:29,240 --> 00:45:34,460
hash in our examples and we set dollar

00:45:30,920 --> 00:45:38,650
sign a to be UK capitals curly brace

00:45:34,460 --> 00:45:41,150
dollar sign a will look up the value UK

00:45:38,650 --> 00:45:43,490
if we look up this what key is it going

00:45:41,150 --> 00:45:49,040
to look up in that particular case with

00:45:43,490 --> 00:45:51,819
the angle brackets it's going to look

00:45:49,040 --> 00:45:55,190
for a key of dollar a literally dollar a

00:45:51,819 --> 00:45:58,849
because these are the quote mechanism so

00:45:55,190 --> 00:46:00,980
it's quoting single quoting dollar a and

00:45:58,849 --> 00:46:02,720
so it's going to look for a key of

00:46:00,980 --> 00:46:07,220
dollar a it won't interpolate in that

00:46:02,720 --> 00:46:09,920
particular case if you assign one hash

00:46:07,220 --> 00:46:11,900
to another just works it copies the

00:46:09,920 --> 00:46:14,630
pair's from one hash into the other if

00:46:11,900 --> 00:46:15,890
you sign a hash to an array what do you

00:46:14,630 --> 00:46:21,680
think you get if you assign a hash to

00:46:15,890 --> 00:46:25,599
array array of pairs what happens if you

00:46:21,680 --> 00:46:25,599
use keys values in KB on an array

00:46:28,580 --> 00:46:35,540
runtime failure oh no we we don't like

00:46:31,160 --> 00:46:43,220
runtime failures right let's uh let's do

00:46:35,540 --> 00:46:45,200
oh it's Apple berry cherry date okay so

00:46:43,220 --> 00:46:48,770
if I say give me the values of that

00:46:45,200 --> 00:46:51,080
array right we'd expect to get the

00:46:48,770 --> 00:46:52,060
values of the array so they give me the

00:46:51,080 --> 00:46:55,820
keys

00:46:52,060 --> 00:47:00,260
what are the keys to that array zero one

00:46:55,820 --> 00:47:04,310
two and three if I say give me the KB's

00:47:00,260 --> 00:47:10,640
on that array zero Apple one berry to

00:47:04,310 --> 00:47:13,670
cherry three date they are not a list of

00:47:10,640 --> 00:47:16,460
pairs what's happening is that the dot

00:47:13,670 --> 00:47:19,100
KB and Keys method are basically

00:47:16,460 --> 00:47:21,650
treating them and building pairs as you

00:47:19,100 --> 00:47:23,630
go internally they're just the things

00:47:21,650 --> 00:47:26,540
and it's this there's an implied key and

00:47:23,630 --> 00:47:30,560
whenever you ask for keys or Cavey then

00:47:26,540 --> 00:47:32,810
we make that implied key explicit and in

00:47:30,560 --> 00:47:36,550
fact I can say give me a as a list of

00:47:32,810 --> 00:47:36,550
pairs and there they are

00:47:39,250 --> 00:47:43,960
alrighty and

00:47:52,210 --> 00:47:58,300
it's assignment shallow if you're using

00:47:56,559 --> 00:48:01,990
if you're assigning something that has

00:47:58,300 --> 00:48:05,530
the at or the percent signal then

00:48:01,990 --> 00:48:07,480
flattens if you are assigning something

00:48:05,530 --> 00:48:19,990
that has a dollar sign sigil the dollar

00:48:07,480 --> 00:48:28,359
sign said field never flattens that one

00:48:19,990 --> 00:48:30,339
two three my B equals four at a five say

00:48:28,359 --> 00:48:33,490
B by the way there's a built-in data

00:48:30,339 --> 00:48:35,140
dumper not pearl so that gives me the

00:48:33,490 --> 00:48:37,480
pro representation of that so here we

00:48:35,140 --> 00:48:40,540
could say oh it didn't work did that

00:48:37,480 --> 00:48:48,900
change in the glr okay so it never

00:48:40,540 --> 00:48:56,109
flattens okay okay

00:48:48,900 --> 00:48:59,319
got it and one minute yes okay you can

00:48:56,109 --> 00:49:00,609
interpolate arrays and hashes but you

00:48:59,319 --> 00:49:02,109
have to do it a little bit more than

00:49:00,609 --> 00:49:04,059
with scalars so if I stick it a dollar

00:49:02,109 --> 00:49:05,470
sign scaler inside of a double coated

00:49:04,059 --> 00:49:08,079
string it's gonna interpolate directly

00:49:05,470 --> 00:49:10,420
if you use the @ sign or the hash sign

00:49:08,079 --> 00:49:13,180
and you want to interpolate just putting

00:49:10,420 --> 00:49:15,400
that there won't interpolate an array

00:49:13,180 --> 00:49:17,020
called app PO box if you want the

00:49:15,400 --> 00:49:19,059
interpolation to take place you have to

00:49:17,020 --> 00:49:22,630
put the brackets in to get it to

00:49:19,059 --> 00:49:24,549
interpolate alright so the example

00:49:22,630 --> 00:49:26,530
that's here at the bottom the winner is

00:49:24,549 --> 00:49:28,480
winter sub-zero that's going to take

00:49:26,530 --> 00:49:30,040
element zero out of this array and stick

00:49:28,480 --> 00:49:31,569
it here in the string and if you want

00:49:30,040 --> 00:49:33,819
all of them you just use what we call

00:49:31,569 --> 00:49:35,020
the Zen slice a pair of empty brackets

00:49:33,819 --> 00:49:37,000
and that puts all of them spaced

00:49:35,020 --> 00:49:38,079
separated into the string so now you

00:49:37,000 --> 00:49:40,660
don't have to worry about email

00:49:38,079 --> 00:49:42,579
addresses suddenly losing the part after

00:49:40,660 --> 00:49:44,559
the @ sign but based on a false

00:49:42,579 --> 00:49:47,400
interpolation the same thing is true for

00:49:44,559 --> 00:49:47,400
hashes as well

00:49:47,770 --> 00:49:52,839
you can go beyond that and interpolate

00:49:49,420 --> 00:49:54,849
method calls so if you have something

00:49:52,839 --> 00:49:57,700
that you've interpolate 'add in either a

00:49:54,849 --> 00:49:58,900
scalar or an array and you put a method

00:49:57,700 --> 00:50:00,599
call in there that's part of the

00:49:58,900 --> 00:50:03,609
interpolation

00:50:00,599 --> 00:50:04,300
right and just like with the raisin

00:50:03,609 --> 00:50:06,040
hashes you have

00:50:04,300 --> 00:50:07,720
the brackets and for a method call you

00:50:06,040 --> 00:50:10,540
have to have the parens in for that to

00:50:07,720 --> 00:50:12,670
take place so this does not try and call

00:50:10,540 --> 00:50:15,040
the dot txt method on dollar-sign file

00:50:12,670 --> 00:50:17,230
because there's no parents there so you

00:50:15,040 --> 00:50:23,200
have to have that that ending part in

00:50:17,230 --> 00:50:25,480
order to do it alright this is my last

00:50:23,200 --> 00:50:26,950
slide and then we will stop you can

00:50:25,480 --> 00:50:28,720
embed code inside of an interpolated

00:50:26,950 --> 00:50:30,190
string using Curly's if you put curly

00:50:28,720 --> 00:50:31,960
brackets inside of an interpolated

00:50:30,190 --> 00:50:34,060
string it executes whatever is in the

00:50:31,960 --> 00:50:36,940
Curly's stringify the results and sticks

00:50:34,060 --> 00:50:43,380
it in the middle of your string right so

00:50:36,940 --> 00:50:43,380
you can do things like say total equals

00:50:43,890 --> 00:50:51,520
2 plus 4 in the middle of the string and

00:50:48,340 --> 00:50:53,470
it comes back and says total equals 6 so

00:50:51,520 --> 00:50:57,850
curlies are blocks and you can just do

00:50:53,470 --> 00:51:00,880
those there's a common gotcha here in

00:50:57,850 --> 00:51:02,530
the Pearl of six interpolation rules so

00:51:00,880 --> 00:51:04,240
what's going to happen when we

00:51:02,530 --> 00:51:05,920
interpolate that particular string is

00:51:04,240 --> 00:51:10,170
it's going to try and treat dollar sign

00:51:05,920 --> 00:51:16,810
name as a hash and look up the /b key

00:51:10,170 --> 00:51:18,250
right so how do we avoid that right you

00:51:16,810 --> 00:51:23,800
put dollar sign name inside of curly

00:51:18,250 --> 00:51:26,010
braces or you backslash the the quote or

00:51:23,800 --> 00:51:27,370
there's more than one way to do it right

00:51:26,010 --> 00:51:31,170
all right

00:51:27,370 --> 00:51:31,170

YouTube URL: https://www.youtube.com/watch?v=ySch4xpoPA0


