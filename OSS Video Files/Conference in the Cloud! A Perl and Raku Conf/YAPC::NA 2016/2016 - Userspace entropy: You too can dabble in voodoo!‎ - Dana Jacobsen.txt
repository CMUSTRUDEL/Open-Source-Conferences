Title: 2016 - Userspace entropy: You too can dabble in voodoo!‎ - Dana Jacobsen
Publication date: 2016-06-27
Playlist: YAPC::NA 2016
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:04,200
okay my name is Dana Jacobson I'm going

00:00:02,399 --> 00:00:08,010
to be talking about user space entropy

00:00:04,200 --> 00:00:10,019
or how you too can dabble in voodoo I'll

00:00:08,010 --> 00:00:11,849
if you'd like to ask short questions

00:00:10,019 --> 00:00:15,059
I'll take them I'll do longer questions

00:00:11,849 --> 00:00:17,430
after and I'm here all conference and I

00:00:15,059 --> 00:00:19,020
love talking about this I will talk

00:00:17,430 --> 00:00:22,680
about until you get very tired but I

00:00:19,020 --> 00:00:23,820
also love learning about it so first

00:00:22,680 --> 00:00:25,970
I'll make this distinction between

00:00:23,820 --> 00:00:28,710
randomness and entropy randomness is a

00:00:25,970 --> 00:00:30,390
statistical property so for instance if

00:00:28,710 --> 00:00:32,070
you assume the digits of pi r normal

00:00:30,390 --> 00:00:33,420
which we don't have have actually proven

00:00:32,070 --> 00:00:35,250
but if you assume that they sure act

00:00:33,420 --> 00:00:37,950
like it you could say oh the digits of

00:00:35,250 --> 00:00:40,350
pi are very random but there's no

00:00:37,950 --> 00:00:43,110
entropy their entropy is this physical

00:00:40,350 --> 00:00:44,660
process of unpredictability and so

00:00:43,110 --> 00:00:47,160
usually from a physical process

00:00:44,660 --> 00:00:49,190
computers generally cannot do this

00:00:47,160 --> 00:00:51,809
because they're all very deterministic

00:00:49,190 --> 00:00:54,870
but you can use physical processes to do

00:00:51,809 --> 00:00:57,239
it so the right way to get entropy is

00:00:54,870 --> 00:00:59,010
using a hardware device there are some

00:00:57,239 --> 00:01:00,300
available under fifty dollars there are

00:00:59,010 --> 00:01:04,439
certainly many of them available for

00:01:00,300 --> 00:01:07,380
more they use for instance atomic decay

00:01:04,439 --> 00:01:10,229
or that's actually rather expensive but

00:01:07,380 --> 00:01:12,360
you could do it with a DC's video all

00:01:10,229 --> 00:01:14,760
sorts of things you can get hardware

00:01:12,360 --> 00:01:16,170
entropy or you could do it in the

00:01:14,760 --> 00:01:18,030
operating system sometime in the late

00:01:16,170 --> 00:01:19,530
90's everyone realized the operating

00:01:18,030 --> 00:01:22,290
system was the right place to put this

00:01:19,530 --> 00:01:24,420
and they made dev random and Linux there

00:01:22,290 --> 00:01:27,750
are various other sources and now newer

00:01:24,420 --> 00:01:29,930
linux kernel's will actually find your

00:01:27,750 --> 00:01:34,380
hardware and start reading from that to

00:01:29,930 --> 00:01:36,500
supply more randomness to its process so

00:01:34,380 --> 00:01:38,729
some of the problems we get with this

00:01:36,500 --> 00:01:40,470
maybe you have an old operating system

00:01:38,729 --> 00:01:42,060
or you're doing an experimental

00:01:40,470 --> 00:01:43,909
operating system so you don't have to

00:01:42,060 --> 00:01:47,310
have random you don't have these devices

00:01:43,909 --> 00:01:49,380
or you don't trust it good new PG on

00:01:47,310 --> 00:01:51,210
Windows says this is nice that Microsoft

00:01:49,380 --> 00:01:52,649
is supplying this wonderful method but I

00:01:51,210 --> 00:01:54,240
don't trust Microsoft or at least

00:01:52,649 --> 00:01:56,759
they're closed source I don't know what

00:01:54,240 --> 00:01:57,960
to do I'll do it all myself so you're

00:01:56,759 --> 00:02:01,770
trading off one set of problems for

00:01:57,960 --> 00:02:03,360
another or maybe it's slow it's

00:02:01,770 --> 00:02:05,880
especially if you are in a virtual

00:02:03,360 --> 00:02:08,280
machine or an isolated server it can be

00:02:05,880 --> 00:02:10,619
extremely slow so I'll tell you a little

00:02:08,280 --> 00:02:12,870
story in about two thousand five I

00:02:10,619 --> 00:02:14,549
bought this linksys and

00:02:12,870 --> 00:02:19,739
sell you to network attached storage

00:02:14,549 --> 00:02:23,340
device also called the slug it had 32

00:02:19,739 --> 00:02:27,239
meg of ram ranting very under Klopp to

00:02:23,340 --> 00:02:28,890
arm processor and anyway worked for a

00:02:27,239 --> 00:02:29,909
while and at some point i found Sipan

00:02:28,890 --> 00:02:32,489
Chester's and thought this is really

00:02:29,909 --> 00:02:35,220
cool I'll of Sipan testers but it runs

00:02:32,489 --> 00:02:38,970
almost everybody is running Linux

00:02:35,220 --> 00:02:41,370
sometimes a BSD on x86 so we're all

00:02:38,970 --> 00:02:43,079
testing the same thing so I thought well

00:02:41,370 --> 00:02:47,250
this is certainly different it's running

00:02:43,079 --> 00:02:49,140
some odd our clinics on a machine that

00:02:47,250 --> 00:02:52,019
almost nobody else is running this will

00:02:49,140 --> 00:02:54,000
provide a nice source of testing so I

00:02:52,019 --> 00:02:56,450
started it up and put it in a corner

00:02:54,000 --> 00:02:58,680
it's using 10 watts or less and it's

00:02:56,450 --> 00:03:01,650
very slowly going through SI phan

00:02:58,680 --> 00:03:03,629
testing and at some point I looked and

00:03:01,650 --> 00:03:06,599
said wait a second it hasn't submitted a

00:03:03,629 --> 00:03:09,780
result in over a week what's going on so

00:03:06,599 --> 00:03:12,900
I log on it's doing just fine but it's

00:03:09,780 --> 00:03:16,260
running an openssh test and that test

00:03:12,900 --> 00:03:19,530
wanted to read 4096 bits from dev random

00:03:16,260 --> 00:03:22,470
and then repeat that process of numerous

00:03:19,530 --> 00:03:25,410
times so here's a device with no hard

00:03:22,470 --> 00:03:28,859
disk it's a USB stick it's got no

00:03:25,410 --> 00:03:31,590
keyboard it's got no mouse it's on a

00:03:28,859 --> 00:03:34,859
switch nobody's logged in so there's no

00:03:31,590 --> 00:03:36,569
network traffic it's running 32 meg I

00:03:34,859 --> 00:03:37,919
stripped everything I possibly could out

00:03:36,569 --> 00:03:41,010
of that so there's no extraneous

00:03:37,919 --> 00:03:42,750
processes and the poor thing just you

00:03:41,010 --> 00:03:45,120
know the colonel is saying I have no

00:03:42,750 --> 00:03:49,109
entropy source ones just sit here and

00:03:45,120 --> 00:03:50,760
hope one will come along so this is what

00:03:49,109 --> 00:03:53,099
I could have discovered this idea of

00:03:50,760 --> 00:03:55,290
running other things that can generate

00:03:53,099 --> 00:03:57,000
entropy for it now of course cheap

00:03:55,290 --> 00:03:58,650
solution to this is you just linked a

00:03:57,000 --> 00:04:00,720
few random to dev random and then it

00:03:58,650 --> 00:04:05,040
stops blocking but that's a different

00:04:00,720 --> 00:04:07,639
problem so if anybody knows me you know

00:04:05,040 --> 00:04:11,430
i had to say crimes in my talk somewhere

00:04:07,639 --> 00:04:12,660
so in my m3 module I wanted to generate

00:04:11,430 --> 00:04:14,720
random primes and of course there are

00:04:12,660 --> 00:04:17,940
lots of functions to do that to do that

00:04:14,720 --> 00:04:19,979
well I need random numbers David Oswald

00:04:17,940 --> 00:04:22,740
was working on this module called bytes

00:04:19,979 --> 00:04:23,880
random secure which had a perfect API

00:04:22,740 --> 00:04:27,180
for what I wanted

00:04:23,880 --> 00:04:29,250
I certainly recommend it but as usual

00:04:27,180 --> 00:04:31,770
that just leads to another thing well at

00:04:29,250 --> 00:04:33,570
some point by tran of secure uses a

00:04:31,770 --> 00:04:35,490
cryptographically secure pseudo-random

00:04:33,570 --> 00:04:37,100
number generator and it wants to get a

00:04:35,490 --> 00:04:39,540
good seat how does it get a good seed

00:04:37,100 --> 00:04:41,640
well that's different on every operating

00:04:39,540 --> 00:04:45,480
system so i wrote a module called crypt

00:04:41,640 --> 00:04:48,480
random seed trying to give that idea of

00:04:45,480 --> 00:04:50,640
look I just want good randomness go get

00:04:48,480 --> 00:04:53,910
at the appropriate way so on windows

00:04:50,640 --> 00:04:55,590
will get use the crypto API it'll try to

00:04:53,910 --> 00:04:56,850
have random to have you random there are

00:04:55,590 --> 00:04:59,730
lots of different options for how it

00:04:56,850 --> 00:05:01,320
works entropy gathering demon look at a

00:04:59,730 --> 00:05:02,970
bunch of different places but at some

00:05:01,320 --> 00:05:05,340
point if it can't find any of these

00:05:02,970 --> 00:05:07,920
things what does it do it goes to

00:05:05,340 --> 00:05:10,890
software user space entropy has to make

00:05:07,920 --> 00:05:14,090
it up so rather than put that in that

00:05:10,890 --> 00:05:17,310
module it goes to another one so

00:05:14,090 --> 00:05:18,600
historically how do you get randomness

00:05:17,310 --> 00:05:20,610
if you can't get it from your operating

00:05:18,600 --> 00:05:22,770
system we've used time we've used

00:05:20,610 --> 00:05:24,000
process data network all of these

00:05:22,770 --> 00:05:25,980
different things if you look at papers

00:05:24,000 --> 00:05:28,530
from the 90s it's all there lots of

00:05:25,980 --> 00:05:31,590
papers that describe how you could tease

00:05:28,530 --> 00:05:34,080
out some entropy from these things time

00:05:31,590 --> 00:05:35,850
is generally a terrible idea there are

00:05:34,080 --> 00:05:37,020
lots of attacks that have been done

00:05:35,850 --> 00:05:40,290
because you've taken your nice

00:05:37,020 --> 00:05:42,390
intractable problem and turned it into a

00:05:40,290 --> 00:05:44,610
very tractable one of discover which

00:05:42,390 --> 00:05:48,180
time they used in this very small one

00:05:44,610 --> 00:05:50,850
hour period so so unless you do a whole

00:05:48,180 --> 00:05:52,890
lot of modifications time is a bad idea

00:05:50,850 --> 00:05:54,950
if you're just doing simulations you're

00:05:52,890 --> 00:05:56,970
not doing cryptography then who cares

00:05:54,950 --> 00:05:59,310
but that's not really what this is about

00:05:56,970 --> 00:06:00,810
the whole thing is to get entropy so

00:05:59,310 --> 00:06:03,000
these other things are very easy for the

00:06:00,810 --> 00:06:04,740
operating system but kind of hard for

00:06:03,000 --> 00:06:06,360
the user space for instance if I'm just

00:06:04,740 --> 00:06:08,250
a generic user and I've logged into this

00:06:06,360 --> 00:06:10,710
machine hopefully I could not read

00:06:08,250 --> 00:06:14,940
keyboard strokes and all the mouse

00:06:10,710 --> 00:06:16,320
presses so that's really hard for me to

00:06:14,940 --> 00:06:18,630
do which is one reason why this all got

00:06:16,320 --> 00:06:21,300
moved into the operating system so far

00:06:18,630 --> 00:06:24,390
but one thing I can look at is operating

00:06:21,300 --> 00:06:28,710
system timers I can use sig alarm I can

00:06:24,390 --> 00:06:30,210
use my croissant I'm if I'm on a

00:06:28,710 --> 00:06:32,700
real-time operating system a very good

00:06:30,210 --> 00:06:34,860
real-time operating system if I asked to

00:06:32,700 --> 00:06:36,200
sleep 13 microseconds I'll probably get

00:06:34,860 --> 00:06:38,390
something very close I won't

00:06:36,200 --> 00:06:40,490
necessarily get 13 microseconds but if

00:06:38,390 --> 00:06:42,920
I'm on a standard operating system like

00:06:40,490 --> 00:06:46,100
most of us use I won't get anything

00:06:42,920 --> 00:06:47,900
close to 13 microseconds maybe i'll get

00:06:46,100 --> 00:06:48,740
something kind close but every time I

00:06:47,900 --> 00:06:51,410
run it I'm going to get something

00:06:48,740 --> 00:06:53,390
somewhat different we have other

00:06:51,410 --> 00:06:55,460
processes going on we have timer's the

00:06:53,390 --> 00:06:58,400
timers are not necessarily synchronized

00:06:55,460 --> 00:07:02,050
with the CPU scheduler jitter a number

00:06:58,400 --> 00:07:05,030
of other things so when I mentioned

00:07:02,050 --> 00:07:06,830
cover couple things in here when I

00:07:05,030 --> 00:07:09,050
mentioned this idea for instance atomic

00:07:06,830 --> 00:07:10,760
decay well this is great this wonderful

00:07:09,050 --> 00:07:12,740
source of randomest every time my little

00:07:10,760 --> 00:07:14,650
Geiger counter reads something it puts a

00:07:12,740 --> 00:07:17,210
one in there otherwise is putting zeros

00:07:14,650 --> 00:07:19,730
but I have this huge string then of

00:07:17,210 --> 00:07:21,620
zeros with an occasional one well that

00:07:19,730 --> 00:07:24,610
doesn't look random 0 occurs far more

00:07:21,620 --> 00:07:27,620
often so von Neumann looked at this

00:07:24,610 --> 00:07:30,020
quite a long time ago and he said well

00:07:27,620 --> 00:07:33,470
we could solve this by looking at pairs

00:07:30,020 --> 00:07:37,580
and if you see 00 or 11 we just toss it

00:07:33,470 --> 00:07:39,950
if you see 01 or 10 then wha but the

00:07:37,580 --> 00:07:41,570
first bit and if you turn this long

00:07:39,950 --> 00:07:43,820
string of zeros with an occasional one

00:07:41,570 --> 00:07:47,660
into what actually comes out as half

00:07:43,820 --> 00:07:49,910
zeros half ones this doesn't necessarily

00:07:47,660 --> 00:07:51,800
pass all of your statistical tests yet

00:07:49,910 --> 00:07:55,640
but it's certainly a first step in

00:07:51,800 --> 00:07:57,950
getting that compacted so we also want

00:07:55,640 --> 00:08:02,150
to do some sort of stirring or mixing

00:07:57,950 --> 00:08:04,220
process in all of this and it turns out

00:08:02,150 --> 00:08:05,960
cryptographic hashes are very very good

00:08:04,220 --> 00:08:08,120
at this in fact they have competitions

00:08:05,960 --> 00:08:10,370
to decide cryptographic hashes they

00:08:08,120 --> 00:08:13,430
measure what's called diffusion very

00:08:10,370 --> 00:08:17,030
carefully to see that things that occur

00:08:13,430 --> 00:08:19,400
later in your original input do not just

00:08:17,030 --> 00:08:20,780
show up in the last bit sore the first

00:08:19,400 --> 00:08:25,100
bits or whatever they actually get

00:08:20,780 --> 00:08:27,320
diffused to the whole process and there

00:08:25,100 --> 00:08:29,390
are different ways to do this but they

00:08:27,320 --> 00:08:32,240
get tested very well and that's one of

00:08:29,390 --> 00:08:34,520
the properties they have so it turns out

00:08:32,240 --> 00:08:38,900
I didn't know this but math truly random

00:08:34,520 --> 00:08:42,410
is a module on Sipan since 1996 one of

00:08:38,900 --> 00:08:43,669
the very early modules and it does it's

00:08:42,410 --> 00:08:45,710
actually mentioned in the pearl core

00:08:43,669 --> 00:08:46,430
documentation you should use math truly

00:08:45,710 --> 00:08:49,880
random if you want

00:08:46,430 --> 00:08:52,610
good entropy it uses the true r and 1.1

00:08:49,880 --> 00:08:56,779
algorithm from blaze and Mitchell who

00:08:52,610 --> 00:08:59,000
did it in at AT&T in 95 and it uses this

00:08:56,779 --> 00:09:01,820
idea of operating system timers so we

00:08:59,000 --> 00:09:04,640
set a short alarm we run a busy loop and

00:09:01,820 --> 00:09:06,170
then when the alarm goes off we mix you

00:09:04,640 --> 00:09:09,260
in whatever count we got in our busy

00:09:06,170 --> 00:09:11,540
loop we do that 11 times so this takes a

00:09:09,260 --> 00:09:14,630
while and keeps the CPU nicely humming

00:09:11,540 --> 00:09:16,760
along for a while there's problems with

00:09:14,630 --> 00:09:18,680
this turns out there's not enough

00:09:16,760 --> 00:09:21,680
entropy in your output you will get at

00:09:18,680 --> 00:09:25,610
most eight bits of entropy out of every

00:09:21,680 --> 00:09:27,770
32 you ask for so that's not good the

00:09:25,610 --> 00:09:29,180
mixing function is a very standard what

00:09:27,770 --> 00:09:31,279
all of us would do if we're sitting down

00:09:29,180 --> 00:09:32,420
and writing C and we think well I've got

00:09:31,279 --> 00:09:36,440
it right of mixing function right away

00:09:32,420 --> 00:09:38,720
XOR and shift that's that's good and but

00:09:36,440 --> 00:09:42,200
it turns out it's not good and it's very

00:09:38,720 --> 00:09:43,580
slow so a year later the authors

00:09:42,200 --> 00:09:45,380
actually published an update to this

00:09:43,580 --> 00:09:47,810
algorithm where they did eight times

00:09:45,380 --> 00:09:49,760
more rounds and they found this thing

00:09:47,810 --> 00:09:52,070
that NIST was working on called a

00:09:49,760 --> 00:09:54,260
cryptographic hash and so they used a

00:09:52,070 --> 00:09:56,810
beta version of sha-1 which turns out

00:09:54,260 --> 00:09:58,550
it's exactly equal to sha-1 so that

00:09:56,810 --> 00:09:59,930
fixes those problems but since that does

00:09:58,550 --> 00:10:03,529
eight times more rounds it's actually

00:09:59,930 --> 00:10:04,910
slower there's problem with the

00:10:03,529 --> 00:10:07,459
implementation of math truly random

00:10:04,910 --> 00:10:10,550
however you run it on windows and you

00:10:07,459 --> 00:10:14,089
get all these compiler errors oh you

00:10:10,550 --> 00:10:19,339
can't use sig alarm on Windows you run

00:10:14,089 --> 00:10:21,950
it on Linux and test hang forever so

00:10:19,339 --> 00:10:24,770
that's not good the last time it had an

00:10:21,950 --> 00:10:27,560
actual pass was in 2008 on a solaris box

00:10:24,770 --> 00:10:31,430
I believe it's at 27 passes total since

00:10:27,560 --> 00:10:34,900
1996 so I supply to patch wrote

00:10:31,430 --> 00:10:37,310
something in pure pearl in January 2013

00:10:34,900 --> 00:10:40,940
but the maintainer died over 10 years

00:10:37,310 --> 00:10:44,029
ago so unfortunately we can't you no one

00:10:40,940 --> 00:10:46,130
can apply that patch so I did request

00:10:44,029 --> 00:10:47,540
that we either deprecated or I can adopt

00:10:46,130 --> 00:10:50,899
that module because i have a patch that

00:10:47,540 --> 00:10:53,749
makes it work on these systems

00:10:50,899 --> 00:10:55,009
so the author where true Rand was

00:10:53,749 --> 00:10:57,379
written by blaze and Mitchell and that's

00:10:55,009 --> 00:10:58,790
what math truly random uses wrote the

00:10:57,379 --> 00:11:00,619
fault he heard someone was looking at

00:10:58,790 --> 00:11:03,410
this and wrote the following tweet in

00:11:00,619 --> 00:11:05,689
2012 he said voodoo entropy had its

00:11:03,410 --> 00:11:09,379
place but this belongs in the operating

00:11:05,689 --> 00:11:11,389
system now one of the I don't know if

00:11:09,379 --> 00:11:14,059
it's a motto of pearl but maybe it is

00:11:11,389 --> 00:11:15,800
certainly motto most of us here fun is

00:11:14,059 --> 00:11:19,879
more important than you shouldn't do

00:11:15,800 --> 00:11:22,759
this so I thought this was a lot of fun

00:11:19,879 --> 00:11:24,800
and it had a purpose so I wrote this

00:11:22,759 --> 00:11:27,050
thing called timer entropy using shot to

00:11:24,800 --> 00:11:30,319
trying to come up with a catchy name so

00:11:27,050 --> 00:11:32,240
it was Tesla to I wrote it in 2013 had

00:11:30,319 --> 00:11:34,309
never heard of bath truly random but I

00:11:32,240 --> 00:11:37,459
had heard of this timer entropy demon

00:11:34,309 --> 00:11:40,249
and so I got the idea from that so it's

00:11:37,459 --> 00:11:43,670
in pure pearl uses two modules that are

00:11:40,249 --> 00:11:45,350
in korat 510 and later runs on linux

00:11:43,670 --> 00:11:48,740
runs on Windows was actually very easy

00:11:45,350 --> 00:11:52,699
to write because of modules that are

00:11:48,740 --> 00:11:54,709
already on Sipan and are in core so

00:11:52,699 --> 00:11:57,110
internally it uses a very similar

00:11:54,709 --> 00:12:00,529
process but without the busy loop we get

00:11:57,110 --> 00:12:03,589
time of day we sleep a little bit get

00:12:00,529 --> 00:12:05,899
time of day again and then X or the

00:12:03,589 --> 00:12:09,139
actual delay with what we expected you

00:12:05,899 --> 00:12:11,420
could also subtract and now repeat that

00:12:09,139 --> 00:12:15,019
eight times and then shop 256 the whole

00:12:11,420 --> 00:12:17,540
thing so that's the internal but it uses

00:12:15,019 --> 00:12:19,189
a concept of entropy pools so when you

00:12:17,540 --> 00:12:20,720
actually call the routine going through

00:12:19,189 --> 00:12:24,139
and ripping tool which is a very

00:12:20,720 --> 00:12:26,600
standard concept dev random uses it yaro

00:12:24,139 --> 00:12:27,980
and Fortuna use entropy pools if you

00:12:26,600 --> 00:12:29,509
look up cryptography books you can

00:12:27,980 --> 00:12:33,529
usually find discussions of entropy

00:12:29,509 --> 00:12:36,199
pools so the idea is adding to it in my

00:12:33,529 --> 00:12:38,899
case I'm using sha-512 to mix you take

00:12:36,199 --> 00:12:40,009
the pool you concatenate the entropy you

00:12:38,899 --> 00:12:45,259
got through these in that internal

00:12:40,009 --> 00:12:48,769
routine and you stir it using cha 512 so

00:12:45,259 --> 00:12:51,619
to extract we add entropy as needed this

00:12:48,769 --> 00:12:53,779
is where dev random would block waiting

00:12:51,619 --> 00:12:55,399
waiting waiting for entropy in my case I

00:12:53,779 --> 00:12:59,299
can just keep calling that routine it

00:12:55,399 --> 00:13:01,189
generates entropy and then sha-512 the

00:12:59,299 --> 00:13:03,079
counter plus the pool is what I'm going

00:13:01,189 --> 00:13:03,800
to return which is kind of important

00:13:03,079 --> 00:13:05,899
that you don't want to

00:13:03,800 --> 00:13:08,029
give people the pool that you're using

00:13:05,899 --> 00:13:09,470
because then they could see your

00:13:08,029 --> 00:13:12,110
internal state so one of the things you

00:13:09,470 --> 00:13:14,000
do is basically pour some out put

00:13:12,110 --> 00:13:17,570
something in it stir it up and give that

00:13:14,000 --> 00:13:20,029
to them and you may have to repeat them

00:13:17,570 --> 00:13:21,740
so another way of looking at it if you

00:13:20,029 --> 00:13:25,149
need to pour in some entropy and stir

00:13:21,740 --> 00:13:29,660
pour some out at a counter stir it out

00:13:25,149 --> 00:13:31,579
output it repeat as needed because i

00:13:29,660 --> 00:13:34,970
have a 512-bit entropy people you could

00:13:31,579 --> 00:13:38,529
ask a 4096 bits so i have to keep moving

00:13:34,970 --> 00:13:41,540
along through that so this passes very

00:13:38,529 --> 00:13:44,180
statistical tests like ENT test you 0 1

00:13:41,540 --> 00:13:45,890
and die hard math truly random does not

00:13:44,180 --> 00:13:49,100
pass those tests which we expect because

00:13:45,890 --> 00:13:52,430
to read 1.1 we knew didn't do that timer

00:13:49,100 --> 00:13:54,290
entropy d is not passed those however if

00:13:52,430 --> 00:13:56,750
you using timer entropy d to put into a

00:13:54,290 --> 00:14:00,529
modern linux kernel to supply it

00:13:56,750 --> 00:14:03,110
randomness it will churn through a lot

00:14:00,529 --> 00:14:04,760
of this stuff the colonel is very good

00:14:03,110 --> 00:14:07,250
about taking all sorts of different

00:14:04,760 --> 00:14:09,649
sources and making the best user can out

00:14:07,250 --> 00:14:12,589
of them so how much entropy does this

00:14:09,649 --> 00:14:14,779
process generate an interesting thing

00:14:12,589 --> 00:14:17,060
was to test and configure this at

00:14:14,779 --> 00:14:20,149
compile time so actually measure how

00:14:17,060 --> 00:14:21,709
good are the timers compile time how

00:14:20,149 --> 00:14:24,140
much entropy do we think we're getting

00:14:21,709 --> 00:14:25,610
and then configure that so how many

00:14:24,140 --> 00:14:28,160
times do I have to call that random bite

00:14:25,610 --> 00:14:30,740
your team to actually get enough entropy

00:14:28,160 --> 00:14:32,060
and I try to be conservative all of

00:14:30,740 --> 00:14:35,360
these algorithms always try to be

00:14:32,060 --> 00:14:38,990
conservative so anything over eight bits

00:14:35,360 --> 00:14:42,680
per byte certainly good enough this i'm

00:14:38,990 --> 00:14:44,930
estimating at 21 estimated 32 plus four

00:14:42,680 --> 00:14:47,149
windows there's this problem of course

00:14:44,930 --> 00:14:48,829
is that you measure once and you run it

00:14:47,149 --> 00:14:51,980
later how do you know you're getting the

00:14:48,829 --> 00:14:53,570
same thing one possibility is measure it

00:14:51,980 --> 00:14:57,620
dynamically so every time you go get

00:14:53,570 --> 00:14:59,630
some entropy go measure some more that

00:14:57,620 --> 00:15:01,899
can cause it to be extremely extremely

00:14:59,630 --> 00:15:01,899
slow

00:15:09,059 --> 00:15:15,359
so i've estimated that every time i call

00:15:12,299 --> 00:15:28,469
this random bite routine it's returning

00:15:15,359 --> 00:15:30,659
21 bits of entropy it's I'm being very

00:15:28,469 --> 00:15:35,279
concerned so we've estimated that there

00:15:30,659 --> 00:15:42,149
are 21 bits in this whole process how is

00:15:35,279 --> 00:15:44,849
it not after eight how did not the

00:15:42,149 --> 00:15:46,229
ceiling absolutely would be eight so

00:15:44,849 --> 00:15:48,749
another way of measuring it is if you

00:15:46,229 --> 00:15:50,759
took a bite well a string of bites and

00:15:48,749 --> 00:15:54,079
you tried to compress it using an ideal

00:15:50,759 --> 00:15:56,969
compressor you'd get no compression as

00:15:54,079 --> 00:16:03,299
your entropy falls below eight bits per

00:15:56,969 --> 00:16:05,519
byte you would get compression for eight

00:16:03,299 --> 00:16:08,129
bits of output we've estimated that

00:16:05,519 --> 00:16:13,009
there were 21 entropy bits that went

00:16:08,129 --> 00:16:15,539
into making it which is more than enough

00:16:13,009 --> 00:16:17,759
we're not actually getting 21 out of

00:16:15,539 --> 00:16:19,709
that of course so this is kind of

00:16:17,759 --> 00:16:21,329
confusing in the sense because actually

00:16:19,709 --> 00:16:26,309
it's returning that internal call is

00:16:21,329 --> 00:16:30,589
actually returning 256 cause this is how

00:16:26,309 --> 00:16:34,589
conservative Ondine with this it's it's

00:16:30,589 --> 00:16:38,050
confusing overkill there's another way

00:16:34,589 --> 00:16:40,190
of looking at it yes

00:16:38,050 --> 00:16:47,180
what you're saying but is there a sense

00:16:40,190 --> 00:16:50,180
that by taking those bits out of there

00:16:47,180 --> 00:16:53,030
is it so this is every time I want to

00:16:50,180 --> 00:16:56,030
put eight bits in i estimate that I'm

00:16:53,030 --> 00:16:58,790
actually putting 21 yet so we're

00:16:56,030 --> 00:17:02,180
supplying it far more entropy we think

00:16:58,790 --> 00:17:04,220
then we really need to and then we take

00:17:02,180 --> 00:17:05,750
out if you wanted eight however many

00:17:04,220 --> 00:17:08,120
bits we take out to hundreds of these

00:17:05,750 --> 00:17:10,160
expense but that means we took we

00:17:08,120 --> 00:17:14,210
thought we took 206 out so we'll have to

00:17:10,160 --> 00:17:15,620
add 256 more we're estimating we're

00:17:14,210 --> 00:17:17,450
actually adding a lot more so it's

00:17:15,620 --> 00:17:21,530
slower than it has to be because I'm

00:17:17,450 --> 00:17:23,300
trying to be conservative yeah so how

00:17:21,530 --> 00:17:25,850
fast does it run it varies greatly

00:17:23,300 --> 00:17:29,090
depending on your operating system your

00:17:25,850 --> 00:17:30,920
timers and what's doesn't vary so much

00:17:29,090 --> 00:17:33,230
based on what's going on the machine in

00:17:30,920 --> 00:17:34,790
most cases okay if you had an isolated

00:17:33,230 --> 00:17:37,010
server may be a little different but

00:17:34,790 --> 00:17:40,520
I've run it on isolated server so it

00:17:37,010 --> 00:17:42,470
runs fine various 230 kilobits per

00:17:40,520 --> 00:17:44,510
second is approaching the speed of a lot

00:17:42,470 --> 00:17:48,770
of those hardware devices most machines

00:17:44,510 --> 00:17:51,340
are not running that fast cygwin on this

00:17:48,770 --> 00:17:53,870
little Adam runs at 60 bits per second

00:17:51,340 --> 00:17:57,590
on windows on the same machine he was

00:17:53,870 --> 00:18:00,020
getting about 17,000 an old hp-ux boxes

00:17:57,590 --> 00:18:07,370
during 20 bits per second it's very very

00:18:00,020 --> 00:18:10,370
slow I believe it's the timer the amount

00:18:07,370 --> 00:18:14,240
the closer you can get to the actual if

00:18:10,370 --> 00:18:16,340
you say I want to sleep 27 microseconds

00:18:14,240 --> 00:18:19,760
and you come back with 27 plus a little

00:18:16,340 --> 00:18:23,480
tiny bit that little tiny bit is what

00:18:19,760 --> 00:18:27,460
we're getting is our jitter linux is

00:18:23,480 --> 00:18:33,929
getting you your sleep more accurately

00:18:27,460 --> 00:18:33,929
therefore was it yeah yes

00:18:34,400 --> 00:18:47,510
read your clock rates differ yeah yes

00:18:45,580 --> 00:18:49,460
yeah there are a lot of things that

00:18:47,510 --> 00:18:51,770
would go into it if your scheduler comes

00:18:49,460 --> 00:18:54,380
back to you right away then oh you'll

00:18:51,770 --> 00:18:56,390
you won't spend extra time in that

00:18:54,380 --> 00:18:58,520
process so arguably could say Linux it's

00:18:56,390 --> 00:19:08,450
worse because it's waiting longer

00:18:58,520 --> 00:19:18,770
sometimes yes yeah I remember that

00:19:08,450 --> 00:19:21,500
though okay so if you wanted to use it

00:19:18,770 --> 00:19:23,960
for that you would run this and you

00:19:21,500 --> 00:19:27,640
would send it to the kernel as here is a

00:19:23,960 --> 00:19:30,530
source of entropy and I can use that and

00:19:27,640 --> 00:19:32,540
there it is something you can do though

00:19:30,530 --> 00:19:34,070
I would say there are there are people

00:19:32,540 --> 00:19:38,330
who have spent a lot of time on this

00:19:34,070 --> 00:19:40,190
have g.e.d for demon is something people

00:19:38,330 --> 00:19:42,010
have worked a lot on and they do this

00:19:40,190 --> 00:19:44,270
plus a whole bunch of other things and

00:19:42,010 --> 00:19:48,010
that will just sit there and run and

00:19:44,270 --> 00:19:48,010
poke data into the car

00:19:53,799 --> 00:19:59,679
oh I did yeah as soon as I start typing

00:19:56,919 --> 00:20:01,210
it starts immediately different you can

00:19:59,679 --> 00:20:02,980
actually look at how much entropy is in

00:20:01,210 --> 00:20:05,529
the kernel pool and as you start typing

00:20:02,980 --> 00:20:08,350
furiously it will generate more yeah

00:20:05,529 --> 00:20:14,159
yeah fortunately it hadn't done that

00:20:08,350 --> 00:20:16,480
much so very quickly you know we can ask

00:20:14,159 --> 00:20:19,239
how do you test this testing these

00:20:16,480 --> 00:20:21,039
things is always very hard one of the

00:20:19,239 --> 00:20:22,720
things is if you don't have good enough

00:20:21,039 --> 00:20:24,940
timers you really can't use this

00:20:22,720 --> 00:20:26,440
properly so there are some devices that

00:20:24,940 --> 00:20:28,330
just quanta or operating systems to

00:20:26,440 --> 00:20:29,739
quantize all of their return so you

00:20:28,330 --> 00:20:33,220
don't have micro second timers and

00:20:29,739 --> 00:20:35,619
therefore at install time this would

00:20:33,220 --> 00:20:38,559
decide you can't use it I also wrote

00:20:35,619 --> 00:20:40,779
phipps 140 we do some in the test

00:20:38,559 --> 00:20:41,980
process it generate it does the

00:20:40,779 --> 00:20:46,720
measurements again of what it thinks

00:20:41,980 --> 00:20:49,299
it's getting so in conclusion this was a

00:20:46,720 --> 00:20:51,249
lot of fun it can be useful I think it

00:20:49,299 --> 00:20:54,070
was under 90 lines if you strip out all

00:20:51,249 --> 00:20:56,769
the comments the comments are probably

00:20:54,070 --> 00:20:59,619
five six times more than the actual code

00:20:56,769 --> 00:21:02,139
it's under 90 lines because of the

00:20:59,619 --> 00:21:03,609
wonderful modules from seed man but

00:21:02,139 --> 00:21:08,549
maybe you should just use your operating

00:21:03,609 --> 00:21:08,549
system that's it

00:21:13,240 --> 00:21:16,240

YouTube URL: https://www.youtube.com/watch?v=Mv_BmVFuDQM


