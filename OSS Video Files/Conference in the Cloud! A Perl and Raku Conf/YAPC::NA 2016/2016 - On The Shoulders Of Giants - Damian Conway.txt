Title: 2016 - On The Shoulders Of Giants - Damian Conway
Publication date: 2016-06-27
Playlist: YAPC::NA 2016
Description: 
	
Captions: 
	00:00:00,060 --> 00:00:05,009
before we get started I wouldn't take a

00:00:02,669 --> 00:00:08,610
minute to thank one of our sponsors in

00:00:05,009 --> 00:00:11,550
particular Grant Street Group has been

00:00:08,610 --> 00:00:15,540
one of our most faithful sponsors for

00:00:11,550 --> 00:00:17,640
Perl events in fact it's hard for me to

00:00:15,540 --> 00:00:21,800
remember a Perl event that Grant Street

00:00:17,640 --> 00:00:21,800
group has not been a part of sponsoring

00:00:21,830 --> 00:00:29,550
any time that we need something for an

00:00:25,680 --> 00:00:31,230
activity it's great to have someone like

00:00:29,550 --> 00:00:34,260
at Grant Street group that we can always

00:00:31,230 --> 00:00:36,390
call on and say hey we're in a pinch we

00:00:34,260 --> 00:00:38,670
need this ok can you help us out because

00:00:36,390 --> 00:00:41,640
they are always very eager and willing

00:00:38,670 --> 00:00:43,440
to provide whatever we need there they

00:00:41,640 --> 00:00:46,230
have been so supportive of the Perl

00:00:43,440 --> 00:00:49,020
foundation in the Pro community and we

00:00:46,230 --> 00:00:51,809
appreciate it so much a really good

00:00:49,020 --> 00:00:55,289
example of that is for this conference

00:00:51,809 --> 00:00:58,379
we were presented with an opportunity to

00:00:55,289 --> 00:01:01,170
get free advertising in the linux

00:00:58,379 --> 00:01:02,760
journal to advertise this event but we

00:01:01,170 --> 00:01:05,369
needed somebody with graphic design

00:01:02,760 --> 00:01:08,220
skills to put together an ad for us and

00:01:05,369 --> 00:01:10,710
we only had a very short period of time

00:01:08,220 --> 00:01:12,810
to get that done and so we called up

00:01:10,710 --> 00:01:14,700
grants tree group and said do you have

00:01:12,810 --> 00:01:17,700
any designers that can help us we need

00:01:14,700 --> 00:01:20,939
this done in a few days and there was no

00:01:17,700 --> 00:01:22,740
problem they they assign the staff it

00:01:20,939 --> 00:01:25,350
got done it was beautiful and we

00:01:22,740 --> 00:01:27,270
appreciated so much so I want to thank

00:01:25,350 --> 00:01:29,100
Grant Street group very much for

00:01:27,270 --> 00:01:31,979
everything that they've done to make

00:01:29,100 --> 00:01:34,579
this event a success so thank you very

00:01:31,979 --> 00:01:34,579
much for that

00:01:40,659 --> 00:01:46,490
it's now my honor to introduce Pierre

00:01:44,030 --> 00:01:48,200
Dennis chief technology officer of Grant

00:01:46,490 --> 00:01:58,579
Street group who will be introducing our

00:01:48,200 --> 00:02:00,770
keynote Thank You then so I'm here dan

00:01:58,579 --> 00:02:04,090
is chief technology officer at Grant

00:02:00,770 --> 00:02:07,759
Street group and so grants we would we

00:02:04,090 --> 00:02:10,670
make we write software to make to help

00:02:07,759 --> 00:02:13,610
government work better so here in

00:02:10,670 --> 00:02:16,220
Florida we all software processes more

00:02:13,610 --> 00:02:18,620
than 50% of the property tax being

00:02:16,220 --> 00:02:25,040
collected in the state and and we help

00:02:18,620 --> 00:02:27,920
you know get this money to firefighters

00:02:25,040 --> 00:02:29,569
and we're very committed to making this

00:02:27,920 --> 00:02:32,810
whole process and helping government

00:02:29,569 --> 00:02:34,790
being more efficient Perl is a core

00:02:32,810 --> 00:02:37,010
technology for us and we've been

00:02:34,790 --> 00:02:40,250
supporting her for a long time we have

00:02:37,010 --> 00:02:42,769
more than 50 per developers and we've

00:02:40,250 --> 00:02:44,870
been proud sponsor as the Dan said of

00:02:42,769 --> 00:02:46,190
various Perl foundation events and I had

00:02:44,870 --> 00:02:48,079
to actually look back because I didn't

00:02:46,190 --> 00:02:52,190
remember since when we started and I

00:02:48,079 --> 00:02:55,459
know we started at least in 2003 and and

00:02:52,190 --> 00:02:58,220
so we really enjoy you know pro

00:02:55,459 --> 00:03:01,519
community and we hire developers on a

00:02:58,220 --> 00:03:04,040
regular basis because we grow in so we

00:03:01,519 --> 00:03:07,280
have a rap role here and make sure to go

00:03:04,040 --> 00:03:09,170
to your table to win potentially Apple

00:03:07,280 --> 00:03:10,549
watch and there is also if you feel like

00:03:09,170 --> 00:03:13,519
it there is a coding challenge

00:03:10,549 --> 00:03:19,130
it's kind of hard and there is an iPad

00:03:13,519 --> 00:03:22,370
pro that winner will get anyway now it

00:03:19,130 --> 00:03:26,200
is my honor to introduce our conferences

00:03:22,370 --> 00:03:29,870
keynote speaker and I remember actually

00:03:26,200 --> 00:03:32,930
devouring is

00:03:29,870 --> 00:03:34,489
object-oriented parole back in 2000 I'm

00:03:32,930 --> 00:03:36,260
sure many of you have fond memories of

00:03:34,489 --> 00:03:39,440
that and I have thoroughly enjoyed this

00:03:36,260 --> 00:03:41,330
mastery of Perl I'm sure like you and

00:03:39,440 --> 00:03:44,390
computer science ever since is the

00:03:41,330 --> 00:03:46,610
author of multiple books advanced and

00:03:44,390 --> 00:03:49,610
powerful sipping modules multiple winner

00:03:46,610 --> 00:03:51,200
of Larry world awards and URI just gave

00:03:49,610 --> 00:03:55,489
me told me an anecdote earlier today

00:03:51,200 --> 00:03:58,040
about early days early O'Reilly Perl

00:03:55,489 --> 00:04:00,349
conference and they were judging

00:03:58,040 --> 00:04:03,140
submitted technical papers for the

00:04:00,349 --> 00:04:06,290
library world award and they were stuck

00:04:03,140 --> 00:04:08,450
on two papers and to you know to find

00:04:06,290 --> 00:04:10,160
the best one and it's only after a while

00:04:08,450 --> 00:04:15,470
that they realized that both papers were

00:04:10,160 --> 00:04:17,479
from Damien so there's not enough time

00:04:15,470 --> 00:04:19,370
to enumerate all of his accomplishments

00:04:17,479 --> 00:04:21,169
of course surprises to say that these

00:04:19,370 --> 00:04:23,000
lectures are now the stuff of legend and

00:04:21,169 --> 00:04:26,210
we are very lucky to have such a great

00:04:23,000 --> 00:04:28,400
man in our community asked me to tell

00:04:26,210 --> 00:04:30,680
you that it will be very happy to take

00:04:28,400 --> 00:04:33,979
questions of discussion points but only

00:04:30,680 --> 00:04:37,810
at the end of the keynotes ok so ladies

00:04:33,979 --> 00:04:37,810
and gentlemen dr. demian Conway

00:04:42,279 --> 00:04:48,579
thank you thank you very much can I just

00:04:46,779 --> 00:04:51,489
start by saying how great it is to be

00:04:48,579 --> 00:04:54,179
back with my tribe I've missed you guys

00:04:51,489 --> 00:04:54,179
so much

00:05:00,700 --> 00:05:05,390
so I really think we're gonna have to

00:05:03,140 --> 00:05:11,180
blame Dan right for what follows I mean

00:05:05,390 --> 00:05:12,920
you all know Dan there's Dan because

00:05:11,180 --> 00:05:15,710
when we were talking about me coming

00:05:12,920 --> 00:05:17,240
back to Yap see he said well could you

00:05:15,710 --> 00:05:19,640
give a keynote on the features of pearl

00:05:17,240 --> 00:05:23,240
six that make life better even for

00:05:19,640 --> 00:05:25,850
beginners so given that brief that was

00:05:23,240 --> 00:05:27,560
completely natural that I would decide

00:05:25,850 --> 00:05:34,420
that this keynote I'm going to talk

00:05:27,560 --> 00:05:37,760
about basically all of these topics and

00:05:34,420 --> 00:05:40,340
the way I got here was I started out by

00:05:37,760 --> 00:05:42,800
asking myself well what is it the

00:05:40,340 --> 00:05:44,840
beginners would do with pearl six and I

00:05:42,800 --> 00:05:46,610
guess that always depends on the kind of

00:05:44,840 --> 00:05:48,170
being as we're talking about if they're

00:05:46,610 --> 00:05:50,270
just beginners in Pearl six if they're

00:05:48,170 --> 00:05:51,620
used to pearl five for example then I

00:05:50,270 --> 00:05:53,390
pretty much expect that you're going to

00:05:51,620 --> 00:05:56,480
be doing the same sorts of things that

00:05:53,390 --> 00:06:00,260
you do in Pearl 5 in Pearl six just

00:05:56,480 --> 00:06:03,290
enjoying it more if you're new to pearl

00:06:00,260 --> 00:06:04,730
entirely then it's very likely that what

00:06:03,290 --> 00:06:06,020
you're going to be doing with pearl 6 is

00:06:04,730 --> 00:06:10,970
what you were doing with whatever

00:06:06,020 --> 00:06:15,650
languages you have escaped from and just

00:06:10,970 --> 00:06:17,120
enjoying it more but I wanted to go a

00:06:15,650 --> 00:06:20,050
little bit further than that I think

00:06:17,120 --> 00:06:22,550
what about people who are beginners in

00:06:20,050 --> 00:06:24,380
programming I thought well where can I

00:06:22,550 --> 00:06:25,370
find a list of beginners in programming

00:06:24,380 --> 00:06:27,320
and of course you can find it on

00:06:25,370 --> 00:06:29,180
Wikipedia when you look for a list of

00:06:27,320 --> 00:06:34,700
beginners in programming you find these

00:06:29,180 --> 00:06:37,400
names so I decided I would talk about

00:06:34,700 --> 00:06:42,740
what they did and what they might have

00:06:37,400 --> 00:06:44,480
been able to do if they had Perl 6 so

00:06:42,740 --> 00:06:46,820
let's get started let's start with this

00:06:44,480 --> 00:06:49,760
lady this is ADA King the Countess of

00:06:46,820 --> 00:06:51,620
Lovelace and she of course is famous for

00:06:49,760 --> 00:06:53,120
publishing the first ever computer

00:06:51,620 --> 00:06:54,770
algorithm and the great thing about the

00:06:53,120 --> 00:06:57,320
Internet is if you want to see it you

00:06:54,770 --> 00:06:59,150
can actually see it online if you want

00:06:57,320 --> 00:07:01,040
to go out there and find that and it was

00:06:59,150 --> 00:07:03,950
fantastic because she even had coding

00:07:01,040 --> 00:07:07,700
tables for how to run the analytical

00:07:03,950 --> 00:07:10,580
engine so this very first algorithm was

00:07:07,700 --> 00:07:12,680
about computing Bernoulli numbers and of

00:07:10,580 --> 00:07:13,850
course since that particular publication

00:07:12,680 --> 00:07:17,300
there have been better Algar

00:07:13,850 --> 00:07:20,380
for it and he is probably about the best

00:07:17,300 --> 00:07:24,920
of them the Akiyama tanigawa algorithm

00:07:20,380 --> 00:07:26,270
written in Perl 6 now very familiar with

00:07:24,920 --> 00:07:29,450
Perl 6 the first thing you'll notice

00:07:26,270 --> 00:07:35,960
here is how much this looks like a

00:07:29,450 --> 00:07:37,520
modern Perl 5 implementation and in fact

00:07:35,960 --> 00:07:39,560
there are only a few syntactic

00:07:37,520 --> 00:07:41,630
differences but I would argue those

00:07:39,560 --> 00:07:45,110
syntactic differences of valuable and

00:07:41,630 --> 00:07:48,830
make life better so the most obvious one

00:07:45,110 --> 00:07:53,060
is we rejigged how the for-loop syntax

00:07:48,830 --> 00:07:56,330
works so in Perl 6 you say for this list

00:07:53,060 --> 00:07:59,540
of things and then you say and they feed

00:07:56,330 --> 00:08:03,650
into some iterator variable which I'm

00:07:59,540 --> 00:08:06,140
going to use in the loop so that's very

00:08:03,650 --> 00:08:09,560
very cool and of course when you have

00:08:06,140 --> 00:08:11,240
your list in Perl 6 you can do all kinds

00:08:09,560 --> 00:08:13,790
of things you can't easily do in Perl 5

00:08:11,240 --> 00:08:17,270
you can count up from 0 which you can do

00:08:13,790 --> 00:08:20,450
in Perl 5 you can count down from M just

00:08:17,270 --> 00:08:21,920
as easily and indeed what we found that

00:08:20,450 --> 00:08:25,430
many people want to do is they want to

00:08:21,920 --> 00:08:27,920
count from 0 to n minus 1 so we made an

00:08:25,430 --> 00:08:29,960
operator for that you want to count 20

00:08:27,920 --> 00:08:31,430
times that's what you're doing there we

00:08:29,960 --> 00:08:37,070
think that this will decrease the use of

00:08:31,430 --> 00:08:38,479
minus 1 by about 80% in Perl code so the

00:08:37,070 --> 00:08:41,780
other interesting thing about this is

00:08:38,479 --> 00:08:44,270
the way this works when we are setting

00:08:41,780 --> 00:08:46,880
up the iterator variable is that that

00:08:44,270 --> 00:08:49,460
iterator variable is actually just a

00:08:46,880 --> 00:08:53,390
parameter of the block in Perl 6 all

00:08:49,460 --> 00:08:56,000
blocks can have parameters and so the

00:08:53,390 --> 00:08:57,890
for loop just takes two arguments a list

00:08:56,000 --> 00:09:00,890
in a block with a parameter and the

00:08:57,890 --> 00:09:02,810
parameter tells you what the name of the

00:09:00,890 --> 00:09:04,910
iterator variable is if you don't give

00:09:02,810 --> 00:09:07,340
it a name it gets an automatic parameter

00:09:04,910 --> 00:09:11,150
and that automatic parameter is dollar

00:09:07,340 --> 00:09:14,840
underscore the next thing I really like

00:09:11,150 --> 00:09:17,090
about Perl 6 is that none of the control

00:09:14,840 --> 00:09:19,850
structures in the language require you

00:09:17,090 --> 00:09:20,950
to put parentheses in you still can if

00:09:19,850 --> 00:09:23,390
it makes you feel better

00:09:20,950 --> 00:09:25,580
but it's not necessary anymore and

00:09:23,390 --> 00:09:28,400
anything that moves us away from Lisp is

00:09:25,580 --> 00:09:31,860
a good thing

00:09:28,400 --> 00:09:34,500
the other thing that I like about Perl 6

00:09:31,860 --> 00:09:36,960
is we made a fundamental change in the

00:09:34,500 --> 00:09:39,930
way that you access an array or indeed a

00:09:36,960 --> 00:09:42,000
hash so in Perl 5 if you think back to

00:09:39,930 --> 00:09:44,100
when you were learning Perl 5 maybe that

00:09:42,000 --> 00:09:47,790
was last week maybe that was a decade

00:09:44,100 --> 00:09:50,550
ago one of the biggest jobs of the

00:09:47,790 --> 00:09:53,820
beginner in Perl 5 is to try and work

00:09:50,550 --> 00:09:56,070
out which sigil to use and basically the

00:09:53,820 --> 00:09:59,600
method we mostly use is I'll try all of

00:09:56,070 --> 00:10:02,760
them until one of them stops complaining

00:09:59,600 --> 00:10:06,510
well in Perl 6 we completely changed the

00:10:02,760 --> 00:10:11,550
way that works in Perl 6 if it's an

00:10:06,510 --> 00:10:13,350
array you use an @ sign always saying

00:10:11,550 --> 00:10:15,560
with hashes always a percentage sign

00:10:13,350 --> 00:10:18,060
same with scalars always a dollar sign

00:10:15,560 --> 00:10:21,450
lesson over that's it so in other words

00:10:18,060 --> 00:10:24,840
we took this Perl 5 table of what do you

00:10:21,450 --> 00:10:30,630
use when and we made it this table

00:10:24,840 --> 00:10:31,740
instead so I really like that because it

00:10:30,630 --> 00:10:33,930
really does make everyone's life easier

00:10:31,740 --> 00:10:37,290
except people who are coding in both

00:10:33,930 --> 00:10:41,070
Perl 5 and Perl 6 at the same time your

00:10:37,290 --> 00:10:43,230
lives will be misery the last thing I

00:10:41,070 --> 00:10:46,560
like is in Perl 6 if you see curly

00:10:43,230 --> 00:10:48,480
brackets that's a block of code even if

00:10:46,560 --> 00:10:51,510
the curly brackets happen to be inside a

00:10:48,480 --> 00:10:53,220
double quoted string so inside a double

00:10:51,510 --> 00:10:54,830
quoted string you come across a block of

00:10:53,220 --> 00:10:57,840
code it executes the block of code

00:10:54,830 --> 00:11:00,450
interpolates whatever the result was now

00:10:57,840 --> 00:11:02,670
putting subroutine calls inside a double

00:11:00,450 --> 00:11:04,830
quoted string is that easy you will

00:11:02,670 --> 00:11:07,100
never use the concatenation operator

00:11:04,830 --> 00:11:07,100
again

00:11:09,280 --> 00:11:17,620
so let's run this little bit of code and

00:11:15,000 --> 00:11:19,630
see what it does well what it does is

00:11:17,620 --> 00:11:21,760
compute the Bernoulli numbers it's very

00:11:19,630 --> 00:11:23,260
exciting I know and if you're familiar

00:11:21,760 --> 00:11:25,540
with the Bernoulli number it's a weird

00:11:23,260 --> 00:11:27,040
sequence it kind of starts out saying

00:11:25,540 --> 00:11:28,180
and then every second one decides it's

00:11:27,040 --> 00:11:30,430
going to be zero forever

00:11:28,180 --> 00:11:34,780
and all the other ones just can't kind

00:11:30,430 --> 00:11:37,770
of have random values I want you to

00:11:34,780 --> 00:11:39,850
remember eyes that particular list

00:11:37,770 --> 00:11:41,590
because I want to show you the same

00:11:39,850 --> 00:11:46,110
thing in Perl 5 watch carefully

00:11:41,590 --> 00:11:46,110
that's Perl 5 version note how similar

00:11:53,280 --> 00:12:02,440
it's great language so if we pull those

00:11:58,270 --> 00:12:04,780
two lists up you'll see that some of the

00:12:02,440 --> 00:12:08,020
Perl 5 values are right some of them are

00:12:04,780 --> 00:12:10,090
kind of right and then things go

00:12:08,020 --> 00:12:12,730
horribly horribly wrong because of the

00:12:10,090 --> 00:12:15,100
accumulated rounding errors because in

00:12:12,730 --> 00:12:17,440
Perl 5 what do we use we use your native

00:12:15,100 --> 00:12:19,960
floating-point notation to do these

00:12:17,440 --> 00:12:22,360
calculations and as we go on in the

00:12:19,960 --> 00:12:24,610
iteration things go horribly wrong

00:12:22,360 --> 00:12:27,400
so why didn't it go horribly wrong in

00:12:24,610 --> 00:12:30,070
Perl 6 and understand that we need to

00:12:27,400 --> 00:12:32,920
look down here where I'm going to add

00:12:30,070 --> 00:12:34,839
something to the call to Bernoulli I'm

00:12:32,920 --> 00:12:36,900
saying when you get the value back show

00:12:34,839 --> 00:12:39,970
it to me as if it was perl source code

00:12:36,900 --> 00:12:42,700
basically Perl 6 has data dumper built

00:12:39,970 --> 00:12:46,540
right into their language which is kind

00:12:42,700 --> 00:12:48,400
of useful too yeah I like that too when

00:12:46,540 --> 00:12:51,250
I run that you'll see that what it's

00:12:48,400 --> 00:12:54,010
actually doing is it's representing each

00:12:51,250 --> 00:12:56,770
of these values as a rational number

00:12:54,010 --> 00:12:59,260
the reason it's doing that is because we

00:12:56,770 --> 00:13:01,480
built the numbers out of a division of

00:12:59,260 --> 00:13:03,490
integers so it uses rational numbers and

00:13:01,480 --> 00:13:05,850
in Perl 6 the rational numbers are

00:13:03,490 --> 00:13:08,860
arbitrary precision rational numbers

00:13:05,850 --> 00:13:10,839
therefore the calculation never goes

00:13:08,860 --> 00:13:12,660
wrong the only time you get rounding is

00:13:10,839 --> 00:13:15,880
when it's printing it out as a decimal

00:13:12,660 --> 00:13:19,930
now not that you couldn't do the same

00:13:15,880 --> 00:13:22,610
thing in Perl 5 but what you wouldn't

00:13:19,930 --> 00:13:24,769
want to do is say just use big num

00:13:22,610 --> 00:13:27,939
because if you use big nom indeed it

00:13:24,769 --> 00:13:30,439
does get closer to the correct answer

00:13:27,939 --> 00:13:33,230
but it's still going wrong what you have

00:13:30,439 --> 00:13:38,569
to use in purl 5 is a building called

00:13:33,230 --> 00:13:43,369
big rat and some you know purl community

00:13:38,569 --> 00:13:45,379
we suck at marketing this does not help

00:13:43,369 --> 00:13:47,749
oh yeah you can fix the Bernoulli

00:13:45,379 --> 00:13:55,369
numbers but you have to use a big rack

00:13:47,749 --> 00:13:59,179
to do it so what is it the purl 6 offers

00:13:55,369 --> 00:14:01,939
to beginners well for a start it offers

00:13:59,179 --> 00:14:03,559
them a cleaner syntax just a simple

00:14:01,939 --> 00:14:06,049
syntactic cleanup that's simpler to

00:14:03,559 --> 00:14:10,009
understand but maybe more importantly it

00:14:06,049 --> 00:14:12,799
offers cleaner semantics more do what

00:14:10,009 --> 00:14:14,989
you mean this and so I was thinking

00:14:12,799 --> 00:14:18,199
about semantics and beginners and that

00:14:14,989 --> 00:14:21,350
naturally leads me to this guy Alan

00:14:18,199 --> 00:14:27,319
Turing famous of course for inventing

00:14:21,350 --> 00:14:29,419
the Alan machine which would have gone

00:14:27,319 --> 00:14:32,439
much much better if he'd called the I

00:14:29,419 --> 00:14:32,439
tape infinity

00:14:33,190 --> 00:14:37,640
so you know know the cheering machine

00:14:35,960 --> 00:14:38,990
you know you've got a tape you can write

00:14:37,640 --> 00:14:39,770
on it you can read from it you've got

00:14:38,990 --> 00:14:41,870
States to move

00:14:39,770 --> 00:14:43,340
I love the Turing machine you can build

00:14:41,870 --> 00:14:45,380
a Turing machine out of just about

00:14:43,340 --> 00:14:48,170
anything you can build it out of Meccano

00:14:45,380 --> 00:14:52,820
you can build it out of Lego you can

00:14:48,170 --> 00:14:55,640
build it out of Excel but my favorite

00:14:52,820 --> 00:14:59,240
implementation of the Turing machine was

00:14:55,640 --> 00:15:06,770
the person who implemented it in the

00:14:59,240 --> 00:15:08,900
template system of C++ not in C++ in the

00:15:06,770 --> 00:15:11,540
template system so there are no

00:15:08,900 --> 00:15:15,170
executable statements in this Turing

00:15:11,540 --> 00:15:18,380
machine you compile it and the cheering

00:15:15,170 --> 00:15:21,710
machine runs in other words the template

00:15:18,380 --> 00:15:24,020
mechanism of C++ is cheering complete

00:15:21,710 --> 00:15:29,240
which tells you everything you need to

00:15:24,020 --> 00:15:32,330
know about C++ so I thought what would a

00:15:29,240 --> 00:15:35,480
Turing machine look like in Perl 6 this

00:15:32,330 --> 00:15:37,550
is the complete implementation for it so

00:15:35,480 --> 00:15:39,500
a Turing machine needs 5 bits of

00:15:37,550 --> 00:15:41,270
information you need to tell me what

00:15:39,500 --> 00:15:43,610
state to start in you need to tell me

00:15:41,270 --> 00:15:46,430
what the rules of transition are you

00:15:43,610 --> 00:15:48,530
need to tell me where the heads going to

00:15:46,430 --> 00:15:52,280
be what the tape looks like initially

00:15:48,530 --> 00:15:55,610
and when I should stop and then you go

00:15:52,280 --> 00:15:58,570
into a big infinite loop and you print

00:15:55,610 --> 00:16:00,590
out the current state of the tape and

00:15:58,570 --> 00:16:03,350
then if you're in the hot state you

00:16:00,590 --> 00:16:05,900
finish and otherwise you update what's

00:16:03,350 --> 00:16:09,170
under the read under the head position

00:16:05,900 --> 00:16:12,340
and in the tape what the state is now

00:16:09,170 --> 00:16:16,160
and do you move the head left or right

00:16:12,340 --> 00:16:18,620
and the only bit of this that's not

00:16:16,160 --> 00:16:21,290
actually about the algorithm itself is

00:16:18,620 --> 00:16:24,500
these last two lines and the problem

00:16:21,290 --> 00:16:27,620
here is in Perl 5 and Perl 6 we've got

00:16:24,500 --> 00:16:29,330
these unbounded arrays which we all love

00:16:27,620 --> 00:16:32,180
because they're incredibly useful but

00:16:29,330 --> 00:16:34,130
they're only semi unbounded they're only

00:16:32,180 --> 00:16:36,170
semi infinite so if you happen to move

00:16:34,130 --> 00:16:37,580
the head off the start of the tape if

00:16:36,170 --> 00:16:39,200
you want to simulate an infinite tape

00:16:37,580 --> 00:16:40,820
then you've got to move everything down

00:16:39,200 --> 00:16:42,950
and move the head back on and that's

00:16:40,820 --> 00:16:44,540
what those two lines are doing they're

00:16:42,950 --> 00:16:45,680
exactly the same is if you did them in

00:16:44,540 --> 00:16:47,750
Perl 5

00:16:45,680 --> 00:16:50,300
now some things that I like about this

00:16:47,750 --> 00:16:53,839
from the language point of view is that

00:16:50,300 --> 00:16:56,570
in Perl 6 we have an incredibly advanced

00:16:53,839 --> 00:16:58,520
mechanism for specifying the signature

00:16:56,570 --> 00:17:01,040
of a subroutine you can do all kinds of

00:16:58,520 --> 00:17:03,680
amazing things probably the most useful

00:17:01,040 --> 00:17:06,410
is you can create a subroutine whose

00:17:03,680 --> 00:17:07,730
parameters are named parameters that's

00:17:06,410 --> 00:17:10,160
what the colons in front of those

00:17:07,730 --> 00:17:11,750
parameters are for it says these are

00:17:10,160 --> 00:17:14,030
named parameters which means when you

00:17:11,750 --> 00:17:17,390
call them you have to call them with a

00:17:14,030 --> 00:17:19,640
name in front of them and anyone who's

00:17:17,390 --> 00:17:21,439
written large-scale code knows this is

00:17:19,640 --> 00:17:23,510
the way to write parameter calls if you

00:17:21,439 --> 00:17:25,309
possibly can because in six months time

00:17:23,510 --> 00:17:26,839
you come back and you remember these and

00:17:25,309 --> 00:17:28,880
more importantly when someone comes back

00:17:26,839 --> 00:17:30,650
and say oh we should alphabetize them or

00:17:28,880 --> 00:17:33,710
something like that and changes the

00:17:30,650 --> 00:17:36,140
order name parameters don't care the

00:17:33,710 --> 00:17:37,970
name tells it which variable to go into

00:17:36,140 --> 00:17:39,800
so it always worked you know to remember

00:17:37,970 --> 00:17:41,570
the order of things and as I get older

00:17:39,800 --> 00:17:43,640
not having to remember the order of

00:17:41,570 --> 00:17:46,970
things becomes increasingly valuable to

00:17:43,640 --> 00:17:48,950
me but there's more to this as well in

00:17:46,970 --> 00:17:50,630
most languages that have named

00:17:48,950 --> 00:17:53,600
parameters the main parameters are

00:17:50,630 --> 00:17:55,820
optional and they are in Perl 6 as well

00:17:53,600 --> 00:18:00,290
but you can also make them required and

00:17:55,820 --> 00:18:03,920
you do this just by screaming them stay

00:18:00,290 --> 00:18:07,309
roles if you don't like to scream then

00:18:03,920 --> 00:18:12,080
you can just say they are required but

00:18:07,309 --> 00:18:15,740
that's more fun normally as in Perl 5

00:18:12,080 --> 00:18:18,320
Perl 6 parameters are passed as aliases

00:18:15,740 --> 00:18:19,790
but sometimes what you want is a copy of

00:18:18,320 --> 00:18:22,520
the thing that you can mess around with

00:18:19,790 --> 00:18:24,679
and not destroy the original argument so

00:18:22,520 --> 00:18:26,720
you can say in Perl 6 very easily I want

00:18:24,679 --> 00:18:28,280
a copy in Perl 5 you have to actually

00:18:26,720 --> 00:18:30,830
manually copy it into a variable

00:18:28,280 --> 00:18:32,450
yourself this makes that easy and of

00:18:30,830 --> 00:18:34,790
course for the optional arguments it's

00:18:32,450 --> 00:18:36,650
also nice if they can have defaults and

00:18:34,790 --> 00:18:38,780
they can have defaulting by the way you

00:18:36,650 --> 00:18:42,860
get that in Perl 5 now as long as you're

00:18:38,780 --> 00:18:45,530
using Perl 5 20 and later so very cool

00:18:42,860 --> 00:18:48,620
mechanism for creating really nice api's

00:18:45,530 --> 00:18:51,440
to your subroutines and there are other

00:18:48,620 --> 00:18:57,250
cool stuff I never want to have to write

00:18:51,440 --> 00:19:00,440
wild one or for Dracula again

00:18:57,250 --> 00:19:02,450
and I don't have to I love the fact that

00:19:00,440 --> 00:19:04,520
in Perl 6 almost anything that you'd

00:19:02,450 --> 00:19:08,299
want to interpolate into a double quoted

00:19:04,520 --> 00:19:10,700
string including a method call on an

00:19:08,299 --> 00:19:13,760
array which calls another method to map

00:19:10,700 --> 00:19:16,100
the values just works and that's all

00:19:13,760 --> 00:19:17,900
just to interpolate it into the string

00:19:16,100 --> 00:19:20,210
what this is doing is it saying give me

00:19:17,900 --> 00:19:22,910
the tape give me the key in values of

00:19:20,210 --> 00:19:24,710
the tape that is position and value and

00:19:22,910 --> 00:19:27,320
if the position is at the head position

00:19:24,710 --> 00:19:29,150
draw the cell with a square brackets

00:19:27,320 --> 00:19:30,650
around it and otherwise don't throw it

00:19:29,150 --> 00:19:32,120
with a square brackets around it and

00:19:30,650 --> 00:19:34,940
when I show you this running you'll see

00:19:32,120 --> 00:19:39,260
that makes the head position visible on

00:19:34,940 --> 00:19:40,669
the tape you're going to love it I love

00:19:39,260 --> 00:19:42,590
the fact that when I want to sleep for

00:19:40,669 --> 00:19:45,169
one tenth of a second I can just say

00:19:42,590 --> 00:19:47,630
sleep for one tenth of a second without

00:19:45,169 --> 00:19:49,250
having to load it into module I'll

00:19:47,630 --> 00:19:54,260
forget to load in the module and then

00:19:49,250 --> 00:19:57,860
have it round down to zero I love the

00:19:54,260 --> 00:19:59,780
fact that hashes you can look up with a

00:19:57,860 --> 00:20:02,210
percentage left on the front so here I'm

00:19:59,780 --> 00:20:04,190
looking up in the rule hash for a

00:20:02,210 --> 00:20:05,990
particular state and a particular thing

00:20:04,190 --> 00:20:07,790
under the head or if I can't find

00:20:05,990 --> 00:20:11,330
anything under the head then just for

00:20:07,790 --> 00:20:12,980
the empty space give me the rule for

00:20:11,330 --> 00:20:16,210
that which will be a nested hash

00:20:12,980 --> 00:20:18,440
eventually and if that doesn't work fail

00:20:16,210 --> 00:20:24,679
now I could have written died there but

00:20:18,440 --> 00:20:28,880
die is very intense fail says yep die

00:20:24,679 --> 00:20:31,760
but make it savable which is very very

00:20:28,880 --> 00:20:33,530
cool as well so if I look up my rule

00:20:31,760 --> 00:20:35,990
then I want to look in this little hash

00:20:33,530 --> 00:20:38,929
that I found and find out what to do on

00:20:35,990 --> 00:20:41,210
the tape what to do with the state and

00:20:38,929 --> 00:20:42,470
what to do with the head so what I'm

00:20:41,210 --> 00:20:48,980
going to do is I'm going to look up

00:20:42,470 --> 00:20:51,500
three entries in that hash but they have

00:20:48,980 --> 00:20:54,890
the hash available to me I want to given

00:20:51,500 --> 00:20:57,830
it and it's just like Perl 5 given says

00:20:54,890 --> 00:21:01,040
make that hash that I've looked up

00:20:57,830 --> 00:21:03,110
dollar underscore so now I look up the

00:21:01,040 --> 00:21:06,230
hash and I do it in a way that you've

00:21:03,110 --> 00:21:09,380
probably not even imagined before

00:21:06,230 --> 00:21:11,780
in Perl 6 if you want to default to

00:21:09,380 --> 00:21:15,260
dollar underscore you can still do so

00:21:11,780 --> 00:21:17,750
but you just can't do so magically so in

00:21:15,260 --> 00:21:20,180
Perl 6 none of the built-ins default to

00:21:17,750 --> 00:21:22,310
dollar underscore because in Perl 5 only

00:21:20,180 --> 00:21:24,530
40% of the built-ins default to dollar

00:21:22,310 --> 00:21:27,500
underscore and how many know exactly the

00:21:24,530 --> 00:21:32,030
40% I'm watching Larry's not put his

00:21:27,500 --> 00:21:33,650
hand up either so in Perl 6 if you want

00:21:32,030 --> 00:21:35,330
to default the dollar underscore you say

00:21:33,650 --> 00:21:38,330
dot in front of the thing because that's

00:21:35,330 --> 00:21:40,730
the same as saying look up the method on

00:21:38,330 --> 00:21:43,550
the object that's in dollar underscore

00:21:40,730 --> 00:21:46,100
and that object is a hash so I do a hash

00:21:43,550 --> 00:21:48,410
lookup now you'll note that I'm using

00:21:46,100 --> 00:21:49,910
angle brackets rather than Curly's I

00:21:48,410 --> 00:21:53,030
could still use curlies

00:21:49,910 --> 00:21:55,990
but in Perl 6 Curly's don't auto quote

00:21:53,030 --> 00:21:58,460
and that's actually a feature not a bug

00:21:55,990 --> 00:22:01,940
because have you ever done Auto quoting

00:21:58,460 --> 00:22:03,680
in Perl 5 when you didn't mean to you'll

00:22:01,940 --> 00:22:05,810
realize that it's kind of nice that we

00:22:03,680 --> 00:22:09,200
have a separate notation that just looks

00:22:05,810 --> 00:22:12,290
it up now the thing is in these rules

00:22:09,200 --> 00:22:14,270
there might not be any instruction to

00:22:12,290 --> 00:22:16,730
write something on the tape there might

00:22:14,270 --> 00:22:18,740
not be a state change so we also have to

00:22:16,730 --> 00:22:20,930
say only do that if we've defined

00:22:18,740 --> 00:22:22,820
something in this particular hash that

00:22:20,930 --> 00:22:26,210
tells me what to write or what state to

00:22:22,820 --> 00:22:28,550
go into so in other words I'm going to

00:22:26,210 --> 00:22:30,860
look up something to write onto the tape

00:22:28,550 --> 00:22:33,290
if it's there look up something to

00:22:30,860 --> 00:22:34,490
change the state if it's there and I'm

00:22:33,290 --> 00:22:36,230
going to look up something to see if

00:22:34,490 --> 00:22:37,970
there's a move to make and I'm just

00:22:36,230 --> 00:22:39,950
going to add it to the head position so

00:22:37,970 --> 00:22:42,320
all the moves are relative in a Turing

00:22:39,950 --> 00:22:43,670
machine move left move right of course

00:22:42,320 --> 00:22:46,370
if they haven't got anything there it'll

00:22:43,670 --> 00:22:50,030
be move undef which will go to 0 and I

00:22:46,370 --> 00:22:52,670
won't care but the problem is this

00:22:50,030 --> 00:22:55,250
pattern is very very common I want to

00:22:52,670 --> 00:22:58,010
assign something but only if the

00:22:55,250 --> 00:22:59,600
something is defined now there is not an

00:22:58,010 --> 00:23:01,220
operator to do that there's not in purl

00:22:59,600 --> 00:23:03,470
5 either you're thinking of the slash

00:23:01,220 --> 00:23:06,770
slash equals that's not what slash slash

00:23:03,470 --> 00:23:08,960
equals does but I like this pattern only

00:23:06,770 --> 00:23:11,860
do the assignment if the thing you're

00:23:08,960 --> 00:23:14,300
assigning is there kind of makes sense

00:23:11,860 --> 00:23:17,960
so I thought I would like to have that

00:23:14,300 --> 00:23:20,890
available all the time well Perl 6 makes

00:23:17,960 --> 00:23:20,890
that incredibly easy

00:23:31,200 --> 00:23:34,200
okay

00:23:36,690 --> 00:23:41,830
so how do I make that a permanent part

00:23:40,180 --> 00:23:44,440
of my language well the answer is I

00:23:41,830 --> 00:23:48,160
factor it out up here assign the R value

00:23:44,440 --> 00:23:51,160
if the R value is defined and I write

00:23:48,160 --> 00:23:54,700
myself a new operator one that's never

00:23:51,160 --> 00:24:00,760
been seen before so the name of that

00:23:54,700 --> 00:24:02,710
operator is a sign it takes an L value

00:24:00,760 --> 00:24:05,200
which is read writable it takes an hour

00:24:02,710 --> 00:24:07,240
value which is only readable and it

00:24:05,200 --> 00:24:10,570
assigns the R value to the L value if

00:24:07,240 --> 00:24:14,020
the R value is defined and now down here

00:24:10,570 --> 00:24:21,520
I can just say a sign to write a sign to

00:24:14,020 --> 00:24:24,240
state and it's just available to me so

00:24:21,520 --> 00:24:24,240
when I run that

00:24:28,510 --> 00:24:32,020
there's the cheering machine the

00:24:30,790 --> 00:24:34,210
cheering machine one of the very first

00:24:32,020 --> 00:24:35,950
ones that Alan Turing did himself which

00:24:34,210 --> 00:24:39,490
was the one that duplicates its own

00:24:35,950 --> 00:24:41,980
input my favorite one is not that one

00:24:39,490 --> 00:24:46,380
it's this next one which has got a quite

00:24:41,980 --> 00:24:46,380
a few rules to it but when you run it

00:24:52,210 --> 00:24:59,680
that sort in cheering machine is that

00:24:57,250 --> 00:25:04,780
not awesome unfortunately it's not

00:24:59,680 --> 00:25:07,750
awesome because it's bubble sort we want

00:25:04,780 --> 00:25:08,980
awesome sorts like quicksort now I'm

00:25:07,750 --> 00:25:10,780
going to talk to you about the history

00:25:08,980 --> 00:25:12,970
of quicksort you probably expected me to

00:25:10,780 --> 00:25:17,350
put up a picture like this and saying

00:25:12,970 --> 00:25:18,390
this guy invented it in 1640 but that's

00:25:17,350 --> 00:25:23,430
not what happened

00:25:18,390 --> 00:25:29,410
quicksort was invented by this guy in

00:25:23,430 --> 00:25:32,350
1959 it's really new technology now 1959

00:25:29,410 --> 00:25:35,050
was about the era when john mcafee was

00:25:32,350 --> 00:25:37,290
inventing lisp so naturally what i want

00:25:35,050 --> 00:25:43,240
to do to you is show you

00:25:37,290 --> 00:25:47,710
quicksort unless but you know what

00:25:43,240 --> 00:25:53,220
that's not quicksort in lisp that ladies

00:25:47,710 --> 00:25:53,220
and gentlemen is quicksort in perl 6

00:25:59,200 --> 00:26:03,730
and you say hang on a minute I'm pretty

00:26:01,450 --> 00:26:09,220
sure that we don't have car and coulda

00:26:03,730 --> 00:26:13,140
and yeah right I had to ride it but I

00:26:09,220 --> 00:26:16,600
wrote it basically in Lisp ish Perl 6

00:26:13,140 --> 00:26:18,850
and what I love about this language more

00:26:16,600 --> 00:26:20,620
than perhaps anything else is if you are

00:26:18,850 --> 00:26:23,200
coming from a list for a scheme

00:26:20,620 --> 00:26:24,970
background and you want to write code

00:26:23,200 --> 00:26:26,710
that feels comfortable and familiar in

00:26:24,970 --> 00:26:29,110
the way that you want to ride it it's

00:26:26,710 --> 00:26:31,180
perfectly possible to do if you're

00:26:29,110 --> 00:26:32,920
coming from an imperative background and

00:26:31,180 --> 00:26:35,530
you want to write quicksort in the

00:26:32,920 --> 00:26:37,420
standard kind of shift off the pivot and

00:26:35,530 --> 00:26:40,060
grep out the before and after and

00:26:37,420 --> 00:26:42,250
recursively sort them then you can do

00:26:40,060 --> 00:26:44,500
that as well and if you're coming from a

00:26:42,250 --> 00:26:48,040
haskell background we're not allowed to

00:26:44,500 --> 00:26:51,340
have any variables and you want a pure

00:26:48,040 --> 00:26:54,520
functional implementation using multiple

00:26:51,340 --> 00:26:57,130
dispatch and D structuring arguments if

00:26:54,520 --> 00:26:59,170
there's no nothing in the list to return

00:26:57,130 --> 00:27:01,570
nothing there's one thing in the list

00:26:59,170 --> 00:27:03,610
return one thing if there's more than

00:27:01,570 --> 00:27:12,190
one thing in the list do the recursive

00:27:03,610 --> 00:27:14,590
algorithm well that works too this is an

00:27:12,190 --> 00:27:17,230
awesome language you can code the way

00:27:14,590 --> 00:27:19,590
that you want to now I have to say if

00:27:17,230 --> 00:27:22,930
I'm talking about beginners beginners

00:27:19,590 --> 00:27:24,820
generally don't favor quicksort if you

00:27:22,930 --> 00:27:27,010
ask a beginner to implement a sort

00:27:24,820 --> 00:27:31,870
algorithm they will tend to go for a

00:27:27,010 --> 00:27:35,080
non-deterministic algorithm typically

00:27:31,870 --> 00:27:37,450
they'll go for bogo's sort if I mean

00:27:35,080 --> 00:27:39,490
with BOGO sought principle of BOGO sort

00:27:37,450 --> 00:27:41,740
is very simple I give you a set of car a

00:27:39,490 --> 00:27:43,690
deck of cards and I say sort is for me

00:27:41,740 --> 00:27:45,640
you do it like this you shuffle the deck

00:27:43,690 --> 00:27:47,830
of cards and check whether it's sorted

00:27:45,640 --> 00:27:49,690
if it's not you shuffle the deck of

00:27:47,830 --> 00:27:51,850
cards and then check whether it's sorted

00:27:49,690 --> 00:27:53,470
it's not you shuffle the deck of cards

00:27:51,850 --> 00:27:56,530
and then check with it and eventually it

00:27:53,470 --> 00:27:59,410
will be sorted and that's this algorithm

00:27:56,530 --> 00:28:05,170
in other words until the list is in

00:27:59,410 --> 00:28:07,090
order pick from the list all of the

00:28:05,170 --> 00:28:09,880
elements at random the star just means

00:28:07,090 --> 00:28:11,920
all of them that's kind of shuffle built

00:28:09,880 --> 00:28:12,900
into the language and put it back in the

00:28:11,920 --> 00:28:15,790
list

00:28:12,900 --> 00:28:18,910
and then check whether it's an order

00:28:15,790 --> 00:28:21,130
again this is a fantastically simple

00:28:18,910 --> 00:28:25,630
algorithm you can implement this very

00:28:21,130 --> 00:28:27,190
very quickly in C and eventually it will

00:28:25,630 --> 00:28:29,830
be sorted and then you just return the

00:28:27,190 --> 00:28:32,740
list okay it's about the simplest sort

00:28:29,830 --> 00:28:35,740
algorithm that's available we can

00:28:32,740 --> 00:28:38,980
optimize it a little bit in Perl 6 when

00:28:35,740 --> 00:28:40,840
you have variable equals variable

00:28:38,980 --> 00:28:43,480
operator whatever you don't write that

00:28:40,840 --> 00:28:47,740
you'd never write x equals x plus 7

00:28:43,480 --> 00:28:49,480
you'd write X plus equal 7 well you can

00:28:47,740 --> 00:28:53,560
do that with method calls as well in

00:28:49,480 --> 00:28:54,750
Perl 6 you can just say list call equals

00:28:53,560 --> 00:28:58,030
pick

00:28:54,750 --> 00:28:59,470
in other words pick every element out of

00:28:58,030 --> 00:29:01,840
this list and put it back in the list

00:28:59,470 --> 00:29:04,150
it's kind of cool the other thing is

00:29:01,840 --> 00:29:06,810
where do I get this in order from up by

00:29:04,150 --> 00:29:12,280
the way in Perl 6 you can use hyphens in

00:29:06,810 --> 00:29:14,850
identifiers and that nice bringing the

00:29:12,280 --> 00:29:18,340
60s technology to you

00:29:14,850 --> 00:29:19,270
how would I implement in order well the

00:29:18,340 --> 00:29:21,310
thing that I love most about

00:29:19,270 --> 00:29:23,290
implementing in order is in Perl 6 you

00:29:21,310 --> 00:29:25,210
could implement in order in fewer

00:29:23,290 --> 00:29:32,650
characters than it takes to write in

00:29:25,210 --> 00:29:36,010
order that's in order in Perl 6 Perl 6

00:29:32,650 --> 00:29:37,600
has an after operator which you can put

00:29:36,010 --> 00:29:40,120
between two values and I'll tell you

00:29:37,600 --> 00:29:42,970
which whether the first one is after the

00:29:40,120 --> 00:29:44,980
second it has a not matter operator

00:29:42,970 --> 00:29:47,110
which you can apply to after to say okay

00:29:44,980 --> 00:29:49,540
I want it to not be after the second and

00:29:47,110 --> 00:29:51,760
it has square brackets which you can put

00:29:49,540 --> 00:29:55,240
around the operator to turn it into a

00:29:51,760 --> 00:29:57,220
list operator so it effectively says put

00:29:55,240 --> 00:30:00,430
that operator between every single

00:29:57,220 --> 00:30:01,780
element and if the first element is not

00:30:00,430 --> 00:30:04,090
after the second element the second is

00:30:01,780 --> 00:30:07,090
not after the third and etc etc that's a

00:30:04,090 --> 00:30:08,980
sorted list now you might say okay but

00:30:07,090 --> 00:30:13,140
that's kind of scary I much preferred to

00:30:08,980 --> 00:30:16,360
see in order fine write a subroutine and

00:30:13,140 --> 00:30:19,980
yeah you can still use an underscore if

00:30:16,360 --> 00:30:19,980
you want to sorry Steve

00:30:20,500 --> 00:30:27,980
so when you run that sure enough it'll

00:30:24,769 --> 00:30:37,610
sort a list and sometimes it sorts it

00:30:27,980 --> 00:30:42,950
quickly and sometimes it sorts it less

00:30:37,610 --> 00:30:44,659
quickly so that's not an ideal algorithm

00:30:42,950 --> 00:30:47,330
and or an ideal use for non determinism

00:30:44,659 --> 00:30:49,549
is there any actual useful use for non

00:30:47,330 --> 00:30:52,909
determinism and it turns out that there

00:30:49,549 --> 00:30:56,539
is you can use non determinism to detect

00:30:52,909 --> 00:30:59,690
prime numbers so how does a beginner

00:30:56,539 --> 00:31:01,789
write a prime number checker they write

00:30:59,690 --> 00:31:03,679
it something like this go through all

00:31:01,789 --> 00:31:09,070
the numbers 4 2 2 the square root of n

00:31:03,679 --> 00:31:13,730
and if the number is evenly divisible by

00:31:09,070 --> 00:31:15,049
the divisor then it ate a prime if you

00:31:13,730 --> 00:31:16,850
go through all the numbers and none of

00:31:15,049 --> 00:31:18,919
them were than it is a prime a couple of

00:31:16,850 --> 00:31:22,490
things to note there Perl 6 has an is

00:31:18,919 --> 00:31:31,010
evenly divisible by so you don't have to

00:31:22,490 --> 00:31:32,600
write n mod divisor equals 0 it also has

00:31:31,010 --> 00:31:36,940
a true and false value which is

00:31:32,600 --> 00:31:40,519
canonical so we run that particular

00:31:36,940 --> 00:31:43,580
algorithm and sure enough it finds prime

00:31:40,519 --> 00:31:49,610
numbers but as the prime numbers get

00:31:43,580 --> 00:31:51,710
longer it does less and less well so

00:31:49,610 --> 00:31:57,440
another beginner had a go at prime

00:31:51,710 --> 00:32:02,169
number detection this guy this is Pierre

00:31:57,440 --> 00:32:02,169
de Fermat known to you as ferment

00:32:02,220 --> 00:32:09,880
and in 1640 he released his little

00:32:07,059 --> 00:32:14,670
theorem and his little theorem gives us

00:32:09,880 --> 00:32:17,290
a way of very probably detecting primes

00:32:14,670 --> 00:32:19,929
so the algorithm basically looks like

00:32:17,290 --> 00:32:22,000
this you pick a number between 2 and N

00:32:19,929 --> 00:32:23,440
you do a calculation on it and if it

00:32:22,000 --> 00:32:26,070
gives you a certain answer then it's

00:32:23,440 --> 00:32:28,390
composite otherwise it's probably prime

00:32:26,070 --> 00:32:30,610
so in other words you take a random

00:32:28,390 --> 00:32:32,890
number that you want to say is that

00:32:30,610 --> 00:32:35,740
prime or not you choose another random

00:32:32,890 --> 00:32:38,050
number less than it and you raise that

00:32:35,740 --> 00:32:42,179
number to the original number minus 1

00:32:38,050 --> 00:32:44,830
which gives you a very large number

00:32:42,179 --> 00:32:48,270
which you then mod by the original

00:32:44,830 --> 00:32:54,010
number and if that turns out to be 1

00:32:48,270 --> 00:32:55,750
then it's prime probably so if you take

00:32:54,010 --> 00:32:58,140
a composite number and you do the same

00:32:55,750 --> 00:33:00,910
pick a random number less than it

00:32:58,140 --> 00:33:03,790
subtract 1 there you get an even bigger

00:33:00,910 --> 00:33:06,429
number in this case mod it by the

00:33:03,790 --> 00:33:08,110
original you get 36 and so we have

00:33:06,429 --> 00:33:13,920
detected with only a huge amount of

00:33:08,110 --> 00:33:16,210
calculation that 86 why 68 is not prime

00:33:13,920 --> 00:33:19,570
so the problem here of course is that

00:33:16,210 --> 00:33:23,110
probably there are certain numbers for

00:33:19,570 --> 00:33:24,850
which that relationship doesn't work so

00:33:23,110 --> 00:33:26,350
people came to Fermat and said there are

00:33:24,850 --> 00:33:29,470
certain related numbers for which that

00:33:26,350 --> 00:33:34,570
relationship doesn't work pierre and he

00:33:29,470 --> 00:33:38,260
said i don't care i look at this and he

00:33:34,570 --> 00:33:40,720
said if you do it a hundred times with

00:33:38,260 --> 00:33:43,270
different random numbers the probability

00:33:40,720 --> 00:33:46,750
of it not being prime goes way way way

00:33:43,270 --> 00:33:49,420
way way down so that algorithm basically

00:33:46,750 --> 00:33:53,679
looks like this do it for a hundred

00:33:49,420 --> 00:33:56,440
times pick an rj and do the same sort of

00:33:53,679 --> 00:33:58,210
thing there now you may have noticed a

00:33:56,440 --> 00:34:00,580
couple of things here for a start in

00:33:58,210 --> 00:34:03,580
perl 6 is incredibly easy to pick a

00:34:00,580 --> 00:34:07,120
random number in a range you write the

00:34:03,580 --> 00:34:10,240
range and then you say pick no more

00:34:07,120 --> 00:34:13,880
doing that mental reverse calculation on

00:34:10,240 --> 00:34:18,080
r and to get the right range

00:34:13,880 --> 00:34:22,580
but more importantly purl sixes source

00:34:18,080 --> 00:34:25,850
code is unicode so if you're having a

00:34:22,580 --> 00:34:28,580
Perl 6 identifier it can be any valid

00:34:25,850 --> 00:34:31,880
unicode character including subscripts

00:34:28,580 --> 00:34:40,760
there is no rational reason to use this

00:34:31,880 --> 00:34:45,740
feature except how wonderful it is

00:34:40,760 --> 00:34:48,650
is that not glorious also note the Perl

00:34:45,740 --> 00:34:51,140
6 has a lot of built-ins it has a

00:34:48,650 --> 00:34:52,970
built-in that takes a number raises it

00:34:51,140 --> 00:34:55,670
to a power and then mods it by a number

00:34:52,970 --> 00:34:57,470
and it turns out that's actually a very

00:34:55,670 --> 00:34:59,360
useful thing to be able to do because if

00:34:57,470 --> 00:35:01,490
you take a big number and raise it to

00:34:59,360 --> 00:35:03,680
the power of a big number you get a huge

00:35:01,490 --> 00:35:07,760
great big number and then modding it is

00:35:03,680 --> 00:35:09,500
really really slow this uses an

00:35:07,760 --> 00:35:11,570
algorithm that doesn't build huge

00:35:09,500 --> 00:35:14,450
numbers it does interim calculations and

00:35:11,570 --> 00:35:16,100
it's very very fast you could do it that

00:35:14,450 --> 00:35:19,130
way of course it would look very pretty

00:35:16,100 --> 00:35:23,000
but this is actually faster so when we

00:35:19,130 --> 00:35:25,070
run this now it turns out that we can

00:35:23,000 --> 00:35:30,230
factor that find out these numbers are

00:35:25,070 --> 00:35:32,540
prime very very quickly so that's great

00:35:30,230 --> 00:35:36,470
that would be a terrific algorithm for

00:35:32,540 --> 00:35:38,390
us to use if it weren't for this guy the

00:35:36,470 --> 00:35:41,360
villain of the piece here this is Robert

00:35:38,390 --> 00:35:43,280
Carmichael British mathematician after

00:35:41,360 --> 00:35:47,330
whom a certain set of numbers are named

00:35:43,280 --> 00:35:50,540
the Robert no the Carmichael numbers the

00:35:47,330 --> 00:35:57,800
Carmichael numbers break Fermat's prime

00:35:50,540 --> 00:36:01,100
number tester so in 1976 Gary Miller and

00:35:57,800 --> 00:36:04,490
in 1980 Michael rabbin improved upon a

00:36:01,100 --> 00:36:07,370
new algorithm that is impervious to this

00:36:04,490 --> 00:36:10,550
and it's basically the old algorithm

00:36:07,370 --> 00:36:13,880
with some trickery involved and most of

00:36:10,550 --> 00:36:17,990
the trickery involved says once I found

00:36:13,880 --> 00:36:23,180
a trial that was ok I'm now going to go

00:36:17,990 --> 00:36:25,610
from 1 up to but excluding our

00:36:23,180 --> 00:36:30,020
and here the rest of the minus ones

00:36:25,610 --> 00:36:40,250
disappear from the language and now I'm

00:36:30,020 --> 00:36:42,110
going to square a number yep now in the

00:36:40,250 --> 00:36:45,680
continental United States it's probably

00:36:42,110 --> 00:36:46,970
illegal to use that but in the rest of

00:36:45,680 --> 00:36:49,490
the world where we can actually access

00:36:46,970 --> 00:36:54,560
Unicode on our keyboards that is so

00:36:49,490 --> 00:36:59,150
amazingly cool so if we run this

00:36:54,560 --> 00:37:01,610
algorithm it's really good at doing it

00:36:59,150 --> 00:37:03,670
it's really really quick and in fact the

00:37:01,610 --> 00:37:06,500
most amazing thing about this algorithm

00:37:03,670 --> 00:37:10,840
implementation in Perl 6 is that it

00:37:06,500 --> 00:37:10,840
still works if you do this

00:37:17,540 --> 00:37:21,380
no that's not some stupid modular that

00:37:19,670 --> 00:37:26,330
over release that just bleaches your

00:37:21,380 --> 00:37:29,720
source code Perl 6 has an is prime built

00:37:26,330 --> 00:37:30,230
into the language and it uses the rabbin

00:37:29,720 --> 00:37:36,650
Miller

00:37:30,230 --> 00:37:38,120
prime tester so at this point you're

00:37:36,650 --> 00:37:42,320
probably thinking to do it yourself

00:37:38,120 --> 00:37:44,180
nobody cares about primes and that's

00:37:42,320 --> 00:37:46,280
true it's absolutely true nobody does

00:37:44,180 --> 00:37:49,490
but guess what everybody cares about

00:37:46,280 --> 00:37:52,130
prime factors and by everybody I mean

00:37:49,490 --> 00:37:58,970
the NSA and the CIA and now apparently

00:37:52,130 --> 00:38:03,290
the FBI - and in 1973 this guy Clifford

00:37:58,970 --> 00:38:05,420
Cox invented public key cryptography no

00:38:03,290 --> 00:38:06,980
one knew at the time because the Brits

00:38:05,420 --> 00:38:09,380
keep things pretty close to their chest

00:38:06,980 --> 00:38:11,810
but you all know public key cryptography

00:38:09,380 --> 00:38:14,060
based on a fairly simple principle and

00:38:11,810 --> 00:38:17,270
that simple principle is you've got two

00:38:14,060 --> 00:38:19,160
big numbers it's relatively quick to add

00:38:17,270 --> 00:38:21,050
them to multiply them together to get an

00:38:19,160 --> 00:38:22,550
even bigger number they've got an even

00:38:21,050 --> 00:38:25,660
bigger number and you want to find the

00:38:22,550 --> 00:38:29,060
numbers that it was built from that's

00:38:25,660 --> 00:38:30,860
comparatively slow to do and if your

00:38:29,060 --> 00:38:32,090
number is big enough it's so slow that

00:38:30,860 --> 00:38:35,270
you're not going to do it in the rest of

00:38:32,090 --> 00:38:37,670
the time of the universe's so the

00:38:35,270 --> 00:38:41,120
question is well given a number how does

00:38:37,670 --> 00:38:43,220
a beginner factor it and the beginners

00:38:41,120 --> 00:38:45,770
algorithm for factoring a number looks

00:38:43,220 --> 00:38:47,660
pretty much like this you take all of

00:38:45,770 --> 00:38:49,490
the numbers between two and the square

00:38:47,660 --> 00:38:52,850
root of n which are all the possible

00:38:49,490 --> 00:38:55,040
factors you make a list of them and then

00:38:52,850 --> 00:38:57,770
you go into a loop and for each of those

00:38:55,040 --> 00:39:01,130
factors you try dividing the number

00:38:57,770 --> 00:39:03,350
evenly by that divisor and if it does

00:39:01,130 --> 00:39:06,710
divide then you take that number and

00:39:03,350 --> 00:39:10,100
keep it because it's a good number and

00:39:06,710 --> 00:39:13,760
what that take does is feeds the

00:39:10,100 --> 00:39:16,430
surrounding gather block so in Perl 6 we

00:39:13,760 --> 00:39:18,560
have this tool built-in whereby as you

00:39:16,430 --> 00:39:20,450
take these values the gather block

00:39:18,560 --> 00:39:22,010
collects them at the end the gather

00:39:20,450 --> 00:39:24,800
block returns them so this is like a

00:39:22,010 --> 00:39:27,410
generalized do block you know in a do

00:39:24,800 --> 00:39:29,930
block you guess get the last statement

00:39:27,410 --> 00:39:31,050
back in a gather take you get as many

00:39:29,930 --> 00:39:33,900
takes as you want

00:39:31,050 --> 00:39:35,970
so you take that number you divide the

00:39:33,900 --> 00:39:37,770
number by it giving you a smaller number

00:39:35,970 --> 00:39:40,230
to deal with and then you keep trying

00:39:37,770 --> 00:39:42,540
the divisors and if the divisor doesn't

00:39:40,230 --> 00:39:43,590
work you get rid of it until you get to

00:39:42,540 --> 00:39:46,170
the point where you've gone through all

00:39:43,590 --> 00:39:47,520
the divisors and then whatever you've

00:39:46,170 --> 00:39:52,290
got left in n is going to be a prime

00:39:47,520 --> 00:39:56,220
number or one so then you take all of

00:39:52,290 --> 00:39:59,850
the numbers and N and you flatten that

00:39:56,220 --> 00:40:02,670
all down in Perl six arrays as parts of

00:39:59,850 --> 00:40:05,250
lists don't naturally flatten you have

00:40:02,670 --> 00:40:07,170
to do it manually and that way is kind

00:40:05,250 --> 00:40:10,650
of annoying but it also means you can

00:40:07,170 --> 00:40:12,990
have lists of lists of lists so we take

00:40:10,650 --> 00:40:14,430
those we feed them through grit because

00:40:12,990 --> 00:40:17,160
we only want the ones that are two or

00:40:14,430 --> 00:40:19,380
bigger and then just for convenience we

00:40:17,160 --> 00:40:20,610
sort them the sorts not required but

00:40:19,380 --> 00:40:23,330
it's kind of nice to get them back in a

00:40:20,610 --> 00:40:28,320
sorted order what I like about this is

00:40:23,330 --> 00:40:31,650
that's concurrent programming the things

00:40:28,320 --> 00:40:34,050
on the left-hand side get fed into the

00:40:31,650 --> 00:40:35,550
calculation on the right-hand side and

00:40:34,050 --> 00:40:37,950
if that calculation on the right-hand

00:40:35,550 --> 00:40:39,870
side is capable of it it will start

00:40:37,950 --> 00:40:42,600
processing them even before the

00:40:39,870 --> 00:40:44,970
left-hand side is finished pipelining

00:40:42,600 --> 00:40:47,040
right in the language if you don't care

00:40:44,970 --> 00:40:48,780
about the concurrency just like the fact

00:40:47,040 --> 00:40:54,900
that you can say do this then do that

00:40:48,780 --> 00:40:59,250
then do that in the correct order so if

00:40:54,900 --> 00:41:04,170
I run that then sure enough it starts

00:40:59,250 --> 00:41:06,540
factoring my numbers but not really very

00:41:04,170 --> 00:41:07,830
quickly and in fact I'm not even gonna

00:41:06,540 --> 00:41:10,520
bother to keep on with this one because

00:41:07,830 --> 00:41:10,520
that's never going to finish

00:41:13,680 --> 00:41:18,400
so this is another place where

00:41:15,600 --> 00:41:20,350
non-determinism can help us so here's

00:41:18,400 --> 00:41:21,910
the non-deterministic version of that

00:41:20,350 --> 00:41:25,690
the non-deterministic version says

00:41:21,910 --> 00:41:28,390
choose a random factor of n I don't care

00:41:25,690 --> 00:41:30,460
which one it is just find me one and

00:41:28,390 --> 00:41:32,440
what I'll do then is I'll find the prime

00:41:30,460 --> 00:41:34,930
factors of that so I'm breaking the

00:41:32,440 --> 00:41:37,750
problem down and I'll also find the

00:41:34,930 --> 00:41:40,210
prime factors of n divided by that which

00:41:37,750 --> 00:41:43,020
is the other main factor of it and so

00:41:40,210 --> 00:41:45,640
I'm doing this recursive implementation

00:41:43,020 --> 00:41:49,090
and then you do a stupid thing where you

00:41:45,640 --> 00:41:51,820
just say look checking random numbers to

00:41:49,090 --> 00:41:54,910
see if they're factors and if they are

00:41:51,820 --> 00:42:04,840
return them this is about as dumb as it

00:41:54,910 --> 00:42:06,970
gets but surprisingly well no it's not

00:42:04,840 --> 00:42:09,460
faster it would be very surprising if in

00:42:06,970 --> 00:42:13,960
fact it was faster it's not faster at

00:42:09,460 --> 00:42:17,620
all cuz it's stupid except when it is

00:42:13,960 --> 00:42:20,740
faster and then it's very impressive you

00:42:17,620 --> 00:42:26,560
know if you luck out like 10 times in a

00:42:20,740 --> 00:42:28,690
row then it's really fast but once

00:42:26,560 --> 00:42:31,390
people got hooked on this idea there was

00:42:28,690 --> 00:42:33,160
no letting go of it the whole idea was

00:42:31,390 --> 00:42:35,080
very simple algorithm I'm just gonna

00:42:33,160 --> 00:42:38,170
find better ways of finding random

00:42:35,080 --> 00:42:40,960
factors so what people did is they

00:42:38,170 --> 00:42:44,650
started using horrible horrible number

00:42:40,960 --> 00:42:50,230
theory to refine their guess of the

00:42:44,650 --> 00:42:54,730
random number and the current sort of

00:42:50,230 --> 00:42:59,590
leader for this is a guy called John

00:42:54,730 --> 00:43:01,540
Pollard now there is no picture on the

00:42:59,590 --> 00:43:05,040
entire Internet of John Pollard so I

00:43:01,540 --> 00:43:05,040
just put up Leonardo DiCaprio

00:43:07,050 --> 00:43:12,430
first deities very good-looking but more

00:43:09,940 --> 00:43:14,110
importantly I kind of think that after

00:43:12,430 --> 00:43:16,420
working out the algorithm that I'm about

00:43:14,110 --> 00:43:20,350
to show you this is probably how John

00:43:16,420 --> 00:43:22,960
Pollard felt so polite invented

00:43:20,350 --> 00:43:25,000
something called the Rho factorization

00:43:22,960 --> 00:43:26,170
and it's called Rho factorization

00:43:25,000 --> 00:43:28,600
because he couldn't get away with

00:43:26,170 --> 00:43:34,300
calling it convergent iterated smart

00:43:28,600 --> 00:43:36,280
guessing so the basic principle is you

00:43:34,300 --> 00:43:37,330
have to find a random factor of n so

00:43:36,280 --> 00:43:39,880
you're going to use some kind of

00:43:37,330 --> 00:43:42,490
horrible number theory here is the

00:43:39,880 --> 00:43:44,680
horrible number theory that he uses and

00:43:42,490 --> 00:43:46,570
again I'm not going to go through the

00:43:44,680 --> 00:43:48,100
algorithm with you you can look it up on

00:43:46,570 --> 00:43:50,860
Wikipedia if you want to know the gory

00:43:48,100 --> 00:43:54,430
details of it all I want to show you is

00:43:50,860 --> 00:43:57,250
it's called Rho factorization because it

00:43:54,430 --> 00:44:01,000
uses a coefficient Rho in it which of

00:43:57,250 --> 00:44:03,370
course is a valid alphabetic character

00:44:01,000 --> 00:44:05,200
in the unicode set so I can have dollar

00:44:03,370 --> 00:44:11,470
Rho and that's the only reason I want to

00:44:05,200 --> 00:44:14,290
show you this whole damn thing except of

00:44:11,470 --> 00:44:16,780
course to also make the point that this

00:44:14,290 --> 00:44:19,180
algorithm requires you at one point to

00:44:16,780 --> 00:44:22,870
find the greatest common divisor of two

00:44:19,180 --> 00:44:25,300
numbers and guess what that's built into

00:44:22,870 --> 00:44:27,460
the language as well and not even as a

00:44:25,300 --> 00:44:31,930
function it's built in as an infix

00:44:27,460 --> 00:44:33,220
operator is that not awesome because

00:44:31,930 --> 00:44:35,320
then you can put square brackets around

00:44:33,220 --> 00:44:39,640
it and find the greatest common divisor

00:44:35,320 --> 00:44:42,250
of all the numbers but the thing I love

00:44:39,640 --> 00:44:46,840
most about this is that I can write X I

00:44:42,250 --> 00:44:48,880
equals x I squared plus 1 mod n and you

00:44:46,840 --> 00:44:51,700
might think well why is that helpful

00:44:48,880 --> 00:44:55,060
it's helpful because if you have an

00:44:51,700 --> 00:44:59,250
algorithm now you can just transcribe it

00:44:55,060 --> 00:45:01,990
into your Perl source and it executes I

00:44:59,250 --> 00:45:04,360
love that I think that's fantastic

00:45:01,990 --> 00:45:07,030
so if we have a look at this algorithm

00:45:04,360 --> 00:45:08,650
running it's really really impressive so

00:45:07,030 --> 00:45:12,000
I actually decided I was gonna factor a

00:45:08,650 --> 00:45:12,000
whole lot of numbers for you

00:45:13,390 --> 00:45:21,940
is that awesome all right now don't get

00:45:17,020 --> 00:45:23,620
too excited I've only got an hour so

00:45:21,940 --> 00:45:26,080
that one's not going to finish either

00:45:23,620 --> 00:45:27,850
and this brings up the fundamental

00:45:26,080 --> 00:45:31,240
problem this is kind of a kick-ass

00:45:27,850 --> 00:45:33,550
algorithm for factoring in a traditional

00:45:31,240 --> 00:45:36,040
sort of way but it doesn't matter that

00:45:33,550 --> 00:45:39,280
it is because it doesn't matter how set

00:45:36,040 --> 00:45:42,190
theoretic you get you still don't get to

00:45:39,280 --> 00:45:44,740
polynomial time all of these algorithms

00:45:42,190 --> 00:45:46,750
are non polynomial time which means that

00:45:44,740 --> 00:45:49,570
when you try and extend them out to

00:45:46,750 --> 00:45:52,210
reasonable sizes that you might use in

00:45:49,570 --> 00:45:53,410
an actual encryption algorithm you might

00:45:52,210 --> 00:45:57,430
as well you're going to need another

00:45:53,410 --> 00:46:03,040
universe to do it in and that was true

00:45:57,430 --> 00:46:08,050
right up to 1994 when this guy Peter

00:46:03,040 --> 00:46:11,110
shor published the first polynomial time

00:46:08,050 --> 00:46:15,430
algorithm for factoring a number using

00:46:11,110 --> 00:46:16,060
quantum computation now I will say at

00:46:15,430 --> 00:46:18,790
this point

00:46:16,060 --> 00:46:23,740
jaws algorithm for quantum factoring is

00:46:18,790 --> 00:46:26,980
not for beginners so I do not propose to

00:46:23,740 --> 00:46:32,280
show it to you this morning I'll show it

00:46:26,980 --> 00:46:35,590
to you but that's all I'm going to do

00:46:32,280 --> 00:46:37,480
but the thing I'd say is yeah sure it's

00:46:35,590 --> 00:46:39,700
not for beginners but you know what

00:46:37,480 --> 00:46:41,920
quantum computing really is for

00:46:39,700 --> 00:46:43,450
beginners I want to prove that to you in

00:46:41,920 --> 00:46:47,430
the last fifteen minutes or so that I

00:46:43,450 --> 00:46:49,930
have it really is good for beginners so

00:46:47,430 --> 00:46:53,860
here's a crash course on quantum

00:46:49,930 --> 00:46:56,170
computing suppose I have a result an

00:46:53,860 --> 00:46:58,570
outcome that could be in one of two

00:46:56,170 --> 00:47:01,930
possible values I might get a 1 I might

00:46:58,570 --> 00:47:07,150
get a 2 and maybe there like 50% likely

00:47:01,930 --> 00:47:10,570
each using quantum technology I can

00:47:07,150 --> 00:47:13,960
actually create a single value that is

00:47:10,570 --> 00:47:16,480
50% likely to be observed as one and 50%

00:47:13,960 --> 00:47:17,530
likely to be observed as two now of

00:47:16,480 --> 00:47:19,240
course it's not going to be observed as

00:47:17,530 --> 00:47:21,160
one and two it's going to be a little

00:47:19,240 --> 00:47:23,760
tiny quantum particle which is going to

00:47:21,160 --> 00:47:25,810
be observed as spin-up or spin-down

00:47:23,760 --> 00:47:27,190
but it doesn't matter because I can call

00:47:25,810 --> 00:47:30,010
spin up one and spin down

00:47:27,190 --> 00:47:32,319
- and then I've got a binary

00:47:30,010 --> 00:47:34,750
representation and then I can make it

00:47:32,319 --> 00:47:37,839
anything I like now suppose I had a

00:47:34,750 --> 00:47:40,030
second possible outcome for a second

00:47:37,839 --> 00:47:42,040
observation and that was that it was

00:47:40,030 --> 00:47:45,069
very likely to be three and just a

00:47:42,040 --> 00:47:47,290
little bit likely to be - well now I can

00:47:45,069 --> 00:47:50,770
create a system a quantum system that

00:47:47,290 --> 00:47:52,770
represents that as well and of course

00:47:50,770 --> 00:47:55,450
the interesting thing is there are also

00:47:52,770 --> 00:47:58,390
operations that I can do in a quantum

00:47:55,450 --> 00:48:02,140
system that simulate the behavior of the

00:47:58,390 --> 00:48:05,980
plus so when I add maybe one or maybe

00:48:02,140 --> 00:48:08,380
two - maybe two or maybe three then I

00:48:05,980 --> 00:48:12,099
get all possible combinations of the

00:48:08,380 --> 00:48:16,420
outcome I get very low probability of

00:48:12,099 --> 00:48:18,099
three reasonable probability of five and

00:48:16,420 --> 00:48:19,540
it's much more likely to be four and the

00:48:18,099 --> 00:48:20,980
reason is much more likely before is

00:48:19,540 --> 00:48:24,520
because it could be one and three or two

00:48:20,980 --> 00:48:25,750
and two and you put those together and

00:48:24,520 --> 00:48:29,440
now you've got something that will

00:48:25,750 --> 00:48:30,990
almost certainly collapse to four but

00:48:29,440 --> 00:48:34,089
sometimes it won't

00:48:30,990 --> 00:48:37,270
and what do you do then you get yourself

00:48:34,089 --> 00:48:43,359
an observer to have a look and so the

00:48:37,270 --> 00:48:46,450
observer comes and has a look and at

00:48:43,359 --> 00:48:47,560
that point it collapses down into a

00:48:46,450 --> 00:48:49,300
particular value and a collapse down

00:48:47,560 --> 00:48:51,910
into five it was a bit unlikely but it

00:48:49,300 --> 00:48:57,430
happened now the interesting thing about

00:48:51,910 --> 00:49:00,339
that is as soon as it collapses then all

00:48:57,430 --> 00:49:04,540
of the values that were involved in

00:49:00,339 --> 00:49:07,869
creating that value must collapse -

00:49:04,540 --> 00:49:09,550
consistent values and that means that

00:49:07,869 --> 00:49:11,829
without anyone looking at anything else

00:49:09,550 --> 00:49:13,420
those things from now on are going to

00:49:11,829 --> 00:49:16,109
have to be two and three because that's

00:49:13,420 --> 00:49:18,700
the only way I could have observed five

00:49:16,109 --> 00:49:22,410
and otherwise it would be a paradox and

00:49:18,700 --> 00:49:22,410
the entire universe would unzip

00:49:24,089 --> 00:49:31,499
that's cool but what would have happened

00:49:26,939 --> 00:49:33,809
if Leo had happened to observe four well

00:49:31,499 --> 00:49:36,209
if he'd happened to observe four then

00:49:33,809 --> 00:49:38,549
these two things could not collapse

00:49:36,209 --> 00:49:40,469
because there were two different ways

00:49:38,549 --> 00:49:42,660
that he could have observed four and

00:49:40,469 --> 00:49:45,180
therefore the probabilities are not

00:49:42,660 --> 00:49:47,249
certain yet so the only way we can work

00:49:45,180 --> 00:49:49,920
out what those values are is for him to

00:49:47,249 --> 00:49:51,420
go and observe one of them and he might

00:49:49,920 --> 00:49:52,829
observe it as three and then the other

00:49:51,420 --> 00:49:57,239
one will have to be two it will

00:49:52,829 --> 00:49:59,789
automatically collapse and the basis of

00:49:57,239 --> 00:50:01,680
quantum computation is the fact that I

00:49:59,789 --> 00:50:06,239
can observe one thing and it will make

00:50:01,680 --> 00:50:10,799
other things happen consistently without

00:50:06,239 --> 00:50:14,039
any extra work involved and the other

00:50:10,799 --> 00:50:17,309
thing is it's reversible it's working

00:50:14,039 --> 00:50:20,430
backwards we looked at the result but we

00:50:17,309 --> 00:50:23,430
were able to find the components that

00:50:20,430 --> 00:50:25,140
produce that result automatically and of

00:50:23,430 --> 00:50:27,299
course that's exactly what we want to do

00:50:25,140 --> 00:50:29,939
and we have a big number that's a result

00:50:27,299 --> 00:50:34,619
and we want to find the two factors that

00:50:29,939 --> 00:50:38,509
made that result so obviously what I was

00:50:34,619 --> 00:50:38,509
going to do it's not built into Perl 6

00:50:39,079 --> 00:50:45,390
some quantum technology is built in in

00:50:42,209 --> 00:50:46,709
the form of junctions but not this so I

00:50:45,390 --> 00:50:48,479
wrote a module called quantum

00:50:46,709 --> 00:50:50,880
computation if I had an extra half hour

00:50:48,479 --> 00:50:53,369
I would show you that module because I'm

00:50:50,880 --> 00:50:56,130
so proud of it it's all based on the

00:50:53,369 --> 00:50:57,929
multiple worlds theory and it reads like

00:50:56,130 --> 00:50:59,699
a treatise on multiple worlds it's just

00:50:57,929 --> 00:51:01,679
lovely but you can't see it so I'm just

00:50:59,699 --> 00:51:04,170
going to show you the results so the

00:51:01,679 --> 00:51:06,449
results are you get these state things

00:51:04,170 --> 00:51:09,119
where you say ok I'm in state 1 with a

00:51:06,449 --> 00:51:11,009
probability of 0.5 I'm in state 2 with a

00:51:09,119 --> 00:51:14,039
probability 0.5 if I add them together

00:51:11,009 --> 00:51:17,759
then I get one of these super positions

00:51:14,039 --> 00:51:18,779
which is half one and half two and I do

00:51:17,759 --> 00:51:20,640
the same thing with different

00:51:18,779 --> 00:51:27,059
probabilities for two and three and

00:51:20,640 --> 00:51:31,880
having got those things then I can add

00:51:27,059 --> 00:51:33,890
them together and now I get a result Zed

00:51:31,880 --> 00:51:35,540
that's going to be one of those values

00:51:33,890 --> 00:51:38,960
so this is exactly replicating the

00:51:35,540 --> 00:51:41,410
diagram that I showed you before and

00:51:38,960 --> 00:51:45,920
when I observe Zed it will collapse and

00:51:41,410 --> 00:51:48,410
more importantly so too will x and y if

00:51:45,920 --> 00:51:50,510
they can collapse if they can't they

00:51:48,410 --> 00:51:54,410
will stay uncollapse t' until we observe

00:51:50,510 --> 00:51:57,350
them so this really does replicate the

00:51:54,410 --> 00:51:59,510
actual behavior of quantum mechanics and

00:51:57,350 --> 00:52:03,590
could in fact be ported to a real

00:51:59,510 --> 00:52:05,450
quantum computer now the only thing

00:52:03,590 --> 00:52:07,040
about that is if you're ported to a

00:52:05,450 --> 00:52:08,600
quantum computer then the physicists who

00:52:07,040 --> 00:52:10,610
have to use the quantum computer will

00:52:08,600 --> 00:52:12,650
not understand this notation because

00:52:10,610 --> 00:52:17,210
they have their own weird notation

00:52:12,650 --> 00:52:22,510
called the ket notation and a quantum

00:52:17,210 --> 00:52:25,630
physicist would write it like that and

00:52:22,510 --> 00:52:34,510
of course how hard is that in Perl six

00:52:25,630 --> 00:52:34,510
it's a one-liner so

00:52:35,140 --> 00:52:41,290
here we go our two states adding up to

00:52:38,980 --> 00:52:43,450
Zed I also added a thing that you can't

00:52:41,290 --> 00:52:44,860
have in quantum computing which is look

00:52:43,450 --> 00:52:51,490
at the states without actually looking

00:52:44,860 --> 00:52:59,800
at them this is the eye of God but it's

00:52:51,490 --> 00:53:01,810
very handy for debugging so I'm going to

00:52:59,800 --> 00:53:03,460
show you what the unobserved Zed looks

00:53:01,810 --> 00:53:06,240
like in superposition then I'm going to

00:53:03,460 --> 00:53:09,160
observe the Zed just by printing it and

00:53:06,240 --> 00:53:11,020
then I'm gonna show you what X&Y look

00:53:09,160 --> 00:53:12,730
like after I did that and then I'm going

00:53:11,020 --> 00:53:14,710
to observe why and so forth so what

00:53:12,730 --> 00:53:17,200
happens when I do that well the

00:53:14,710 --> 00:53:21,040
unobserved is in the states of different

00:53:17,200 --> 00:53:24,370
superposition when I observe for x and y

00:53:21,040 --> 00:53:25,690
are still in superposition because for

00:53:24,370 --> 00:53:29,470
could have been made in one of two ways

00:53:25,690 --> 00:53:31,540
but when I observe at Y now X can only

00:53:29,470 --> 00:53:35,050
be one and it's already collapsed before

00:53:31,540 --> 00:53:38,350
I observed it we run exactly the same

00:53:35,050 --> 00:53:41,710
code again damn we get exactly the same

00:53:38,350 --> 00:53:42,250
outcome hang on try again yeah we had a

00:53:41,710 --> 00:53:46,270
different outcome

00:53:42,250 --> 00:53:49,030
now Zed was observed to be three not a

00:53:46,270 --> 00:53:51,070
very high probability event but now X

00:53:49,030 --> 00:53:52,600
and y have already collapsed before

00:53:51,070 --> 00:53:54,790
either of them have been observed

00:53:52,600 --> 00:54:02,470
because that's the way the universe has

00:53:54,790 --> 00:54:05,800
to work so that's cool but it gets an

00:54:02,470 --> 00:54:08,980
awful lot cooler as soon as you add in

00:54:05,800 --> 00:54:12,040
one extra quantum operation known as a

00:54:08,980 --> 00:54:16,230
quantum switch and the quantum switch

00:54:12,040 --> 00:54:19,270
comes from an idea by Erwin Schrodinger

00:54:16,230 --> 00:54:23,410
who I think qualifies as the scariest

00:54:19,270 --> 00:54:26,560
looking physicist of all time so you all

00:54:23,410 --> 00:54:29,770
know about Schrodinger's cat this was a

00:54:26,560 --> 00:54:32,560
thought experiment which is if you take

00:54:29,770 --> 00:54:37,000
a radioactive particle and a Geiger

00:54:32,560 --> 00:54:40,020
counter and a container of cyanide and a

00:54:37,000 --> 00:54:43,560
cat and you put them all in a box

00:54:40,020 --> 00:54:47,050
scariest physicist of all time

00:54:43,560 --> 00:54:50,620
and you hook it up so that if the

00:54:47,050 --> 00:54:53,500
particle randomly decomposes the Geiger

00:54:50,620 --> 00:54:55,960
counter detects it and trips the cyanide

00:54:53,500 --> 00:55:00,880
canister to release the cyanide thereby

00:54:55,960 --> 00:55:03,490
making the cat very unhappy and if it

00:55:00,880 --> 00:55:06,460
doesn't trip because it didn't decompose

00:55:03,490 --> 00:55:08,950
then the cats still very unhappy no

00:55:06,460 --> 00:55:12,700
actually the the cats pretty happy

00:55:08,950 --> 00:55:15,580
because it's in a box right so roading

00:55:12,700 --> 00:55:18,160
his point was if this random event is

00:55:15,580 --> 00:55:21,400
determining the outcome for the gas and

00:55:18,160 --> 00:55:25,180
for the cat then until someone observes

00:55:21,400 --> 00:55:27,280
that system internally then the cat is

00:55:25,180 --> 00:55:30,610
actually in a superposition of alive and

00:55:27,280 --> 00:55:32,080
dead and the thing is when Schrodinger

00:55:30,610 --> 00:55:34,120
was making this experiment he was using

00:55:32,080 --> 00:55:37,000
it to say how ridiculous he thought

00:55:34,120 --> 00:55:40,380
quantum mechanics was but unfortunately

00:55:37,000 --> 00:55:43,930
this is correct this is the way it works

00:55:40,380 --> 00:55:49,270
and we can prove that in perl 6 with

00:55:43,930 --> 00:55:53,500
code so you use the module quantum

00:55:49,270 --> 00:55:54,880
computation you set up a system where

00:55:53,500 --> 00:56:00,150
the probability that the particle

00:55:54,880 --> 00:56:03,130
decayed is true is 1/2 and false is 1/2

00:56:00,150 --> 00:56:04,990
then you say well what is the gas state

00:56:03,130 --> 00:56:07,390
well the gas state depends on what the

00:56:04,990 --> 00:56:10,660
particle did so you say well suppose

00:56:07,390 --> 00:56:14,080
that the particle decay was true or

00:56:10,660 --> 00:56:15,820
false then the gas must be either

00:56:14,080 --> 00:56:17,410
released or contained if it's true it'll

00:56:15,820 --> 00:56:20,110
be released if it's false it'll be

00:56:17,410 --> 00:56:22,150
contained so if you're trying to

00:56:20,110 --> 00:56:25,570
understand what this supposed thing is

00:56:22,150 --> 00:56:27,580
it's basically like given this particle

00:56:25,570 --> 00:56:29,380
when it's true released when it's false

00:56:27,580 --> 00:56:32,010
decayed or if you want to think even

00:56:29,380 --> 00:56:35,980
more simply it's like a ternary operator

00:56:32,010 --> 00:56:38,350
this is the quantum ternary operator now

00:56:35,980 --> 00:56:40,630
in perl 6 we change the syntax of the

00:56:38,350 --> 00:56:42,240
ternary operator because single question

00:56:40,630 --> 00:56:46,200
mark and single colon were just too

00:56:42,240 --> 00:56:49,660
valuable to waste on ternary operators

00:56:46,200 --> 00:56:52,030
so if the particles decayed become

00:56:49,660 --> 00:56:54,820
released if it's contained except it

00:56:52,030 --> 00:56:56,470
doesn't do it by observing the particle

00:56:54,820 --> 00:56:59,440
it does it by not of

00:56:56,470 --> 00:57:02,590
serving the particle so the result is

00:56:59,440 --> 00:57:06,550
you get a state where it's 0.5 released

00:57:02,590 --> 00:57:09,400
in 0.5 contained we don't know yet so

00:57:06,550 --> 00:57:13,210
this is kind of the blind ternary

00:57:09,400 --> 00:57:15,580
operator and then of course the cat's

00:57:13,210 --> 00:57:17,890
state depends on the gaseous state in

00:57:15,580 --> 00:57:20,560
exactly the same way so if the gas was

00:57:17,890 --> 00:57:22,780
released the cat is dead if the gas was

00:57:20,560 --> 00:57:25,330
contained the cat is alive once again it

00:57:22,780 --> 00:57:29,230
does that in such a way that you end up

00:57:25,330 --> 00:57:34,180
with these chains of associations of the

00:57:29,230 --> 00:57:37,180
possible outcomes so what do we do then

00:57:34,180 --> 00:57:41,099
we observe the cat we open the box see

00:57:37,180 --> 00:57:47,140
what the cat is and when we do that the

00:57:41,099 --> 00:57:49,930
observation causes the cat's state to

00:57:47,140 --> 00:57:57,690
collapse to one absolutely certain value

00:57:49,930 --> 00:58:01,450
unless we are also in a closed box and

00:57:57,690 --> 00:58:05,859
when it collapses like that then the

00:58:01,450 --> 00:58:07,900
values on which it depended and the

00:58:05,859 --> 00:58:11,380
technical term is the values on with

00:58:07,900 --> 00:58:16,480
which its entangled must also collapse

00:58:11,380 --> 00:58:18,070
to a consistent set of values so when I

00:58:16,480 --> 00:58:22,089
observe these other two things I will

00:58:18,070 --> 00:58:23,830
only get that so if I show you this here

00:58:22,089 --> 00:58:24,940
I have it I'm gonna run it seven times

00:58:23,830 --> 00:58:27,910
in the hope of getting different

00:58:24,940 --> 00:58:29,859
outcomes very first time I run it I'm

00:58:27,910 --> 00:58:32,710
going to show you what the uncollapse

00:58:29,859 --> 00:58:36,520
states are just so you can see when we

00:58:32,710 --> 00:58:39,910
run that you get this initially they are

00:58:36,520 --> 00:58:42,520
in these uncollapse states if the cat's

00:58:39,910 --> 00:58:46,450
dead then you always get released and

00:58:42,520 --> 00:58:49,570
decay if it's alive then you always get

00:58:46,450 --> 00:58:51,160
contained and did not decay and there's

00:58:49,570 --> 00:58:51,880
no possibility of getting any other

00:58:51,160 --> 00:58:53,950
combination

00:58:51,880 --> 00:58:55,720
once you've observed one part of the

00:58:53,950 --> 00:59:00,089
system the rest of the system is

00:58:55,720 --> 00:59:05,910
determined okay so that's great for

00:59:00,089 --> 00:59:05,910
party tricks by psychopathic Germans

00:59:06,739 --> 00:59:15,660
but you know what it's actually great

00:59:09,719 --> 00:59:18,359
for real work too so remember this thing

00:59:15,660 --> 00:59:19,529
we had the random prime factor we had to

00:59:18,359 --> 00:59:21,660
find and we're going to do it by

00:59:19,529 --> 00:59:24,479
eliminating invalid candidates using

00:59:21,660 --> 00:59:26,999
horrible number theory guess what you

00:59:24,479 --> 00:59:30,029
can do it instead by eliminating entire

00:59:26,999 --> 00:59:36,960
universes using horrible quantum

00:59:30,029 --> 00:59:41,789
mathematics so the whole algorithm looks

00:59:36,960 --> 00:59:44,099
like this that's it you say the

00:59:41,789 --> 00:59:45,809
following you say entangle all the

00:59:44,099 --> 00:59:48,630
numbers between 2 and the square root of

00:59:45,809 --> 00:59:51,180
N and that's just an easy way of saying

00:59:48,630 --> 00:59:53,190
give me all the possible numbers between

00:59:51,180 --> 00:59:57,059
2 and the square root of n each with an

00:59:53,190 --> 00:59:58,440
equal probability of 1 over N but I got

00:59:57,059 --> 01:00:00,950
sick of writing that so I just made an

00:59:58,440 --> 01:00:04,109
entangle function that does that for you

01:00:00,950 --> 01:00:06,599
and that will be your factor so in other

01:00:04,109 --> 01:00:09,839
words take all possible factors and just

01:00:06,599 --> 01:00:14,099
mix them all together eek we probably

01:00:09,839 --> 01:00:15,839
and then of course your modulus that

01:00:14,099 --> 01:00:19,200
you're looking for which we'd like to be

01:00:15,839 --> 01:00:21,119
0 is just going to be n divided by that

01:00:19,200 --> 01:00:23,910
and when I'm doing an operation on a

01:00:21,119 --> 01:00:26,690
quantum value I end up with another

01:00:23,910 --> 01:00:30,680
quantum value and I get the

01:00:26,690 --> 01:00:35,160
superposition of all the possible moduli

01:00:30,680 --> 01:00:38,670
in that variable and then I do the

01:00:35,160 --> 01:00:43,349
quantum switch I say suppose the modulus

01:00:38,670 --> 01:00:48,150
is 0 then there truly can be a prior

01:00:43,349 --> 01:00:51,690
effector and if it's not zero

01:00:48,150 --> 01:00:55,190
I don't care about it new in Perl 6 is

01:00:51,690 --> 01:00:58,109
an undefined value in fact it is the

01:00:55,190 --> 01:01:03,089
parent of all undefined values it's the

01:00:58,109 --> 01:01:05,069
most undefined value in Xen terms it is

01:01:03,089 --> 01:01:09,809
the nothing from which everything

01:01:05,069 --> 01:01:12,450
proceeds and what this means in quantum

01:01:09,809 --> 01:01:14,729
mechanics is we're saying anything other

01:01:12,450 --> 01:01:17,100
than zero is an impossible state

01:01:14,729 --> 01:01:22,800
therefore eliminate that universe

01:01:17,100 --> 01:01:27,030
I also need the factor to be prime

01:01:22,800 --> 01:01:29,880
because I need a random prime factor so

01:01:27,030 --> 01:01:33,240
I say call the built-in is prime

01:01:29,880 --> 01:01:39,270
function and if it turns out to be true

01:01:33,240 --> 01:01:42,150
then that's okay and otherwise I'm doing

01:01:39,270 --> 01:01:43,830
new for you now

01:01:42,150 --> 01:01:45,890
it turned out that when I was writing

01:01:43,830 --> 01:01:48,660
different algorithms using this module

01:01:45,890 --> 01:01:51,090
wanting to eliminate 99% of the

01:01:48,660 --> 01:01:52,400
universes and who hasn't wanted to do

01:01:51,090 --> 01:01:55,080
that

01:01:52,400 --> 01:01:58,680
we're so common that I just made it the

01:01:55,080 --> 01:02:02,520
default so be very careful with the

01:01:58,680 --> 01:02:05,820
quantum switch operator and having set

01:02:02,520 --> 01:02:10,010
up all of those constraints then all you

01:02:05,820 --> 01:02:12,450
have to do is observe the factor

01:02:10,010 --> 01:02:13,590
literally by treating is a number in

01:02:12,450 --> 01:02:15,000
Perl 6 if you want something to

01:02:13,590 --> 01:02:16,980
definitely be a number you put a plus in

01:02:15,000 --> 01:02:20,160
front of it and then it is observed to

01:02:16,980 --> 01:02:23,250
be a number and that will cause all of

01:02:20,160 --> 01:02:25,890
those entangled superpositions to

01:02:23,250 --> 01:02:28,800
collapse down to a consistent

01:02:25,890 --> 01:02:37,560
arrangement that meets all the criteria

01:02:28,800 --> 01:02:41,070
and sure enough here it is just by the

01:02:37,560 --> 01:02:43,880
by it the module also provides a

01:02:41,070 --> 01:02:46,140
universe block which can you can

01:02:43,880 --> 01:02:53,780
separate it off from other universes

01:02:46,140 --> 01:02:53,780
just in case and when you run it

01:02:55,560 --> 01:03:02,800
in fact as numbers it's just like that

01:03:00,210 --> 01:03:05,530
now I haven't even started optimizing

01:03:02,800 --> 01:03:07,180
this the module itself is set up so if I

01:03:05,530 --> 01:03:09,340
was doing it concurrently it would run

01:03:07,180 --> 01:03:14,050
very much faster I just didn't do it yet

01:03:09,340 --> 01:03:17,110
but I'm gonna get there the thing I like

01:03:14,050 --> 01:03:21,370
most about this is if you look at this

01:03:17,110 --> 01:03:25,660
algorithm it's really just a description

01:03:21,370 --> 01:03:30,160
of what we want the fact that has to be

01:03:25,660 --> 01:03:34,900
between 2 and the square root of n the

01:03:30,160 --> 01:03:37,840
modulus has to be n mod the factor the

01:03:34,900 --> 01:03:41,620
modulus has to be 0 and the fact that

01:03:37,840 --> 01:03:44,590
has to be prime and now solve for the

01:03:41,620 --> 01:03:46,420
factor let's that's kind of just the

01:03:44,590 --> 01:03:49,330
ultimate description of what we want

01:03:46,420 --> 01:03:51,610
without any coding at all you know what

01:03:49,330 --> 01:03:55,230
like it actually with very little effort

01:03:51,610 --> 01:03:58,510
make pearl six work exactly like that

01:03:55,230 --> 01:04:00,580
literally all I did was say any of just

01:03:58,510 --> 01:04:02,140
entangled states required is just a

01:04:00,580 --> 01:04:07,240
quantum switch and solve for just

01:04:02,140 --> 01:04:10,990
collapses the superposition and so that

01:04:07,240 --> 01:04:16,590
ladies and gentlemen is pure declarative

01:04:10,990 --> 01:04:16,590
quantum factorization for beginners

01:04:31,740 --> 01:04:38,410
and here's one of the Giants on whose

01:04:34,480 --> 01:04:41,320
shoulders we all stand and it's been my

01:04:38,410 --> 01:04:44,560
privilege over the last two decades to

01:04:41,320 --> 01:04:48,460
work with Larry to help him create this

01:04:44,560 --> 01:04:50,740
amazing new language Perl 6 and all of

01:04:48,460 --> 01:04:53,349
that time he has had a very very clear

01:04:50,740 --> 01:04:57,070
focus about what he wanted for that

01:04:53,349 --> 01:05:00,520
language and what it is that beginners

01:04:57,070 --> 01:05:02,440
in programming really need I need

01:05:00,520 --> 01:05:05,349
languages that have the right tools

01:05:02,440 --> 01:05:07,030
already built in and Perl 6 has more of

01:05:05,349 --> 01:05:09,609
that than just about any language but

01:05:07,030 --> 01:05:12,220
they also at the same time need

01:05:09,609 --> 01:05:15,070
languages that get out of your way but

01:05:12,220 --> 01:05:18,910
don't overload you with syntax and with

01:05:15,070 --> 01:05:21,520
syntactic inconsistencies and Perl 6 has

01:05:18,910 --> 01:05:26,230
that in a way that Perl 5 frankly

01:05:21,520 --> 01:05:29,020
doesn't we've known for a long time that

01:05:26,230 --> 01:05:31,359
Larry has liked languages that let you

01:05:29,020 --> 01:05:33,700
do what you mean well you write

01:05:31,359 --> 01:05:35,920
something and it does the right thing

01:05:33,700 --> 01:05:38,710
and I think I've demonstrated today Perl

01:05:35,920 --> 01:05:42,790
6 allows you to do that very very

01:05:38,710 --> 01:05:45,819
powerfully even if you're a beginner but

01:05:42,790 --> 01:05:47,710
equally important has always been his

01:05:45,819 --> 01:05:50,589
belief that beginners need languages

01:05:47,710 --> 01:05:54,240
that do the right thing as well and Perl

01:05:50,589 --> 01:05:56,890
6 is really a high watermark for that

01:05:54,240 --> 01:05:59,500
because not just about doing the right

01:05:56,890 --> 01:06:01,450
thing it's about making it easy to do

01:05:59,500 --> 01:06:03,220
the right thing to make the thing that

01:06:01,450 --> 01:06:08,829
you would naturally do do the right

01:06:03,220 --> 01:06:11,020
thing so my claim for you today is that

01:06:08,829 --> 01:06:14,140
if you are a beginner then what

01:06:11,020 --> 01:06:18,700
beginners need is to be learning Perl 6

01:06:14,140 --> 01:06:21,369
it's an amazing language and the great

01:06:18,700 --> 01:06:24,250
thing about that is it's only been out

01:06:21,369 --> 01:06:27,910
for like about 6 months so for most of

01:06:24,250 --> 01:06:30,190
us we're all Perl 6 beginners so can I

01:06:27,910 --> 01:06:33,730
leave you with a thought that now is the

01:06:30,190 --> 01:06:38,050
time to begin go to pill 6 dot or go to

01:06:33,730 --> 01:06:40,060
Riku todo or download play learn it's a

01:06:38,050 --> 01:06:40,530
great language I promise you you'll be

01:06:40,060 --> 01:06:44,510
glad

01:06:40,530 --> 01:06:44,510
did so thank you very very much

01:07:12,400 --> 01:07:19,029
okay so we're we're gonna take a break

01:07:15,839 --> 01:07:21,130
if anybody is interested Damien's always

01:07:19,029 --> 01:07:24,640
looking for some good gigs he does a lot

01:07:21,130 --> 01:07:27,999
of consulting work and he's a great

01:07:24,640 --> 01:07:29,170
asset for any company we're gonna take

01:07:27,999 --> 01:07:30,940
that we're gonna take a break right now

01:07:29,170 --> 01:07:35,009
and we'll come back to the breakout

01:07:30,940 --> 01:07:35,009

YouTube URL: https://www.youtube.com/watch?v=Nq2HkAYbG5o


