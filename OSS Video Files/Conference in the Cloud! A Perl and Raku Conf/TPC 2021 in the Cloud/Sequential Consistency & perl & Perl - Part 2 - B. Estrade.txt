Title: Sequential Consistency & perl & Perl - Part 2 - B. Estrade
Publication date: 2021-06-16
Playlist: TPC 2021 in the Cloud
Description: 
	Addendum video to original conference presentation that that ended prematurely; demo.
Captions: 
	00:00:01,120 --> 00:00:06,480
hello this is brett estridge

00:00:03,280 --> 00:00:09,599
um picking up uh with my talk

00:00:06,480 --> 00:00:12,639
from the other day at the pearl and raku

00:00:09,599 --> 00:00:16,080
or raiku conference in the cloud

00:00:12,639 --> 00:00:19,199
i went over so i wasn't able to

00:00:16,080 --> 00:00:21,680
go into any uh demonstration of

00:00:19,199 --> 00:00:23,840
the module that i was using for some of

00:00:21,680 --> 00:00:26,880
these examples and as a result of

00:00:23,840 --> 00:00:27,599
the investigation i'm doing however i

00:00:26,880 --> 00:00:31,920
wanted to

00:00:27,599 --> 00:00:34,960
start here and i have no time limit set

00:00:31,920 --> 00:00:36,000
and uh this so this may go on for a

00:00:34,960 --> 00:00:38,559
while or may

00:00:36,000 --> 00:00:41,760
wrap up quickly but in any case my my

00:00:38,559 --> 00:00:44,640
aim is to inform and not waste your time

00:00:41,760 --> 00:00:45,760
but we do need to talk about the example

00:00:44,640 --> 00:00:49,120
from the talk

00:00:45,760 --> 00:00:51,280
the original talk i had introduced this

00:00:49,120 --> 00:00:52,399
concept of this execution this parallel

00:00:51,280 --> 00:00:55,760
execution

00:00:52,399 --> 00:00:59,520
that could operate over two cpus

00:00:55,760 --> 00:01:02,559
one line of execution on cpu 1 here

00:00:59,520 --> 00:01:05,760
is consists of task

00:01:02,559 --> 00:01:07,360
a b and c and then the second

00:01:05,760 --> 00:01:10,320
parallel and independent line of

00:01:07,360 --> 00:01:13,520
execution consisted of task

00:01:10,320 --> 00:01:14,000
x y and z within each thread or or

00:01:13,520 --> 00:01:17,920
within

00:01:14,000 --> 00:01:20,960
each line of execution that is on the um

00:01:17,920 --> 00:01:23,680
each cpu there is a total ordering so a

00:01:20,960 --> 00:01:24,159
has to happen before b b has to happen

00:01:23,680 --> 00:01:27,439
before

00:01:24,159 --> 00:01:31,280
c and then similarly on cpu2

00:01:27,439 --> 00:01:34,159
task x has to happen before task y

00:01:31,280 --> 00:01:34,799
and task y needs to happen before task z

00:01:34,159 --> 00:01:37,759
so

00:01:34,799 --> 00:01:38,079
within each line of execution the tasks

00:01:37,759 --> 00:01:40,799
are

00:01:38,079 --> 00:01:42,799
totally ordered and then between the two

00:01:40,799 --> 00:01:43,439
lines of execution they are partially

00:01:42,799 --> 00:01:47,040
ordered

00:01:43,439 --> 00:01:50,399
which allows us to interleave

00:01:47,040 --> 00:01:52,880
tasks that are not directly dependent on

00:01:50,399 --> 00:01:56,799
one another

00:01:52,880 --> 00:01:59,840
and what you have at the bottom so

00:01:56,799 --> 00:02:02,240
this top dependency graph

00:01:59,840 --> 00:02:04,000
is the parallel execution the question

00:02:02,240 --> 00:02:04,320
we're addressing is what does this look

00:02:04,000 --> 00:02:07,280
like

00:02:04,320 --> 00:02:09,200
if we wanted to run these tasks in a

00:02:07,280 --> 00:02:12,000
properly ordered way

00:02:09,200 --> 00:02:13,120
on a single cpu so we're reducing the

00:02:12,000 --> 00:02:16,800
parallelism

00:02:13,120 --> 00:02:19,840
from two cpus to one cpu

00:02:16,800 --> 00:02:22,000
and this the bottom dependency graph is

00:02:19,840 --> 00:02:23,920
an example of what you may get and it is

00:02:22,000 --> 00:02:25,040
consistent with the total ordering that

00:02:23,920 --> 00:02:28,400
is implied

00:02:25,040 --> 00:02:31,040
on each cpu the parallel execution

00:02:28,400 --> 00:02:31,599
and it's also valid when you consider

00:02:31,040 --> 00:02:34,000
the

00:02:31,599 --> 00:02:35,519
potential for partial ordering between

00:02:34,000 --> 00:02:38,720
the two lines of execution

00:02:35,519 --> 00:02:42,000
in this case it's just as simple a b

00:02:38,720 --> 00:02:44,160
and c happen before x y and z

00:02:42,000 --> 00:02:45,840
and the execution order i have described

00:02:44,160 --> 00:02:46,959
as a string here at the bottom in the

00:02:45,840 --> 00:02:51,440
white box

00:02:46,959 --> 00:02:53,440
a b c x y z

00:02:51,440 --> 00:02:55,280
and then i also covered this slide in

00:02:53,440 --> 00:02:58,480
the original talk

00:02:55,280 --> 00:02:59,840
this shows all of the valid orderings of

00:02:58,480 --> 00:03:02,800
the execution

00:02:59,840 --> 00:03:03,040
that maintain the total ordering among a

00:03:02,800 --> 00:03:06,720
b

00:03:03,040 --> 00:03:08,959
and c and x y and z but then allow for

00:03:06,720 --> 00:03:12,720
the portion of partial ordering

00:03:08,959 --> 00:03:16,080
to be um to be to be

00:03:12,720 --> 00:03:18,080
um affected as an interleaving of the

00:03:16,080 --> 00:03:20,800
tasks

00:03:18,080 --> 00:03:22,159
between each of the executions that

00:03:20,800 --> 00:03:24,720
parallel executions

00:03:22,159 --> 00:03:25,360
and in fact there's 20 of them there is

00:03:24,720 --> 00:03:27,599
a way

00:03:25,360 --> 00:03:29,360
by the way there is a way to compute

00:03:27,599 --> 00:03:31,680
combinatorially count

00:03:29,360 --> 00:03:32,640
how many uh different orderings one may

00:03:31,680 --> 00:03:35,599
get but

00:03:32,640 --> 00:03:36,799
that's not the scope of this call but

00:03:35,599 --> 00:03:37,920
i'm sure somebody may have been

00:03:36,799 --> 00:03:39,840
wondering

00:03:37,920 --> 00:03:42,080
how do i know there's 20. well in this

00:03:39,840 --> 00:03:43,920
case i just literally just listed out

00:03:42,080 --> 00:03:46,400
all of the possible paths

00:03:43,920 --> 00:03:46,959
using uh one of the tools that i'll talk

00:03:46,400 --> 00:03:49,440
about

00:03:46,959 --> 00:03:49,440
in a bit

00:03:50,159 --> 00:03:53,040
all right so

00:03:53,360 --> 00:03:58,000
this is another slide that just shows

00:03:55,760 --> 00:04:00,720
the valid orderings and that they

00:03:58,000 --> 00:04:02,879
are all valid within the context of what

00:04:00,720 --> 00:04:05,920
the parallelism that is being

00:04:02,879 --> 00:04:07,760
described in this this flow or this

00:04:05,920 --> 00:04:10,319
dependency diagram of the parallel

00:04:07,760 --> 00:04:10,319
exhibition

00:04:11,920 --> 00:04:15,760
so how do we want to sear how can we

00:04:13,760 --> 00:04:16,639
serialize arbitrary dependencies the

00:04:15,760 --> 00:04:19,759
question is

00:04:16,639 --> 00:04:21,680
how do we turn parallel execution or

00:04:19,759 --> 00:04:22,639
dependency graphs that admit parallel

00:04:21,680 --> 00:04:25,759
execution

00:04:22,639 --> 00:04:26,960
into a singular line of execution the

00:04:25,759 --> 00:04:31,280
the trick is

00:04:26,960 --> 00:04:33,919
to respect the total ordering that is

00:04:31,280 --> 00:04:35,199
inherent in each line of execution but

00:04:33,919 --> 00:04:37,840
also

00:04:35,199 --> 00:04:38,880
allow for us to express the different

00:04:37,840 --> 00:04:41,199
combinations

00:04:38,880 --> 00:04:42,720
that the partial the freedom that the

00:04:41,199 --> 00:04:45,280
partial ordering among

00:04:42,720 --> 00:04:46,160
the lines of execution give us and what

00:04:45,280 --> 00:04:48,800
we talked about

00:04:46,160 --> 00:04:50,800
in the original talk is that this looks

00:04:48,800 --> 00:04:54,080
like a uh finite automaton

00:04:50,800 --> 00:04:56,639
and finite automata in fact has some

00:04:54,080 --> 00:04:58,639
ability through its yeah all the some of

00:04:56,639 --> 00:05:01,680
the algorithms that are used to convert

00:04:58,639 --> 00:05:04,960
from regular expressions to automata

00:05:01,680 --> 00:05:08,080
to handle this uh the constraint

00:05:04,960 --> 00:05:10,639
of total ordering and also admit

00:05:08,080 --> 00:05:11,759
the possibility of interleaving the

00:05:10,639 --> 00:05:14,880
partially ordered

00:05:11,759 --> 00:05:17,600
tasks or statements i

00:05:14,880 --> 00:05:19,600
talked about finite automata i'm going

00:05:17,600 --> 00:05:22,960
to skip over these

00:05:19,600 --> 00:05:25,759
finite regular so finite automata

00:05:22,960 --> 00:05:27,199
are the graphical representation of

00:05:25,759 --> 00:05:30,240
regular languages

00:05:27,199 --> 00:05:32,960
regular expressions necessarily

00:05:30,240 --> 00:05:34,080
define an equivalently defined finite

00:05:32,960 --> 00:05:35,759
automaton

00:05:34,080 --> 00:05:39,360
and in this talk we talked about

00:05:35,759 --> 00:05:41,759
deterministic finite automata and it's

00:05:39,360 --> 00:05:42,960
regular operators concatenation union

00:05:41,759 --> 00:05:45,120
and the clean star

00:05:42,960 --> 00:05:46,800
or it's also known as closure then

00:05:45,120 --> 00:05:47,759
there's non-deterministic finite

00:05:46,800 --> 00:05:50,960
automata

00:05:47,759 --> 00:05:52,479
has the same three common operators

00:05:50,960 --> 00:05:54,479
uh when we're talking about the regular

00:05:52,479 --> 00:05:56,639
expressions describing the

00:05:54,479 --> 00:05:58,319
autonomy and then the power there's

00:05:56,639 --> 00:06:00,720
parallel finite atoms

00:05:58,319 --> 00:06:01,840
now this includes the three operators

00:06:00,720 --> 00:06:04,160
that we're all used to

00:06:01,840 --> 00:06:05,199
plus the shuffle operator the shuffle

00:06:04,160 --> 00:06:09,360
operator

00:06:05,199 --> 00:06:10,479
is sometimes called an interleaving

00:06:09,360 --> 00:06:14,160
operator

00:06:10,479 --> 00:06:18,080
but one interesting note is that a

00:06:14,160 --> 00:06:21,039
parallel finite automata that expresses

00:06:18,080 --> 00:06:22,080
some combination of languages using the

00:06:21,039 --> 00:06:24,400
shuffle operator

00:06:22,080 --> 00:06:26,880
is equivalent to a binary petri net and

00:06:24,400 --> 00:06:29,039
this is shown in that 1994 stocks

00:06:26,880 --> 00:06:30,080
and few paper which if you're interested

00:06:29,039 --> 00:06:31,840
in this topic

00:06:30,080 --> 00:06:33,600
even even if you're just interested in

00:06:31,840 --> 00:06:35,680
formal languages and finite

00:06:33,600 --> 00:06:36,960
comments i strongly recommend you read

00:06:35,680 --> 00:06:39,680
that paper it is

00:06:36,960 --> 00:06:42,000
really neat all right so shuffle

00:06:39,680 --> 00:06:45,840
operator i think we've talked about this

00:06:42,000 --> 00:06:47,600
but it it's the and to unions or

00:06:45,840 --> 00:06:49,120
and that it makes sense that there would

00:06:47,600 --> 00:06:50,160
there would be maybe this missing

00:06:49,120 --> 00:06:52,160
operator

00:06:50,160 --> 00:06:53,680
that uh most people don't use or

00:06:52,160 --> 00:06:56,800
implement i believe that

00:06:53,680 --> 00:06:59,039
that's because um

00:06:56,800 --> 00:07:00,880
maybe maybe it's not obvious why this is

00:06:59,039 --> 00:07:02,720
useful well this is a case

00:07:00,880 --> 00:07:04,479
we're talking about here is a case of

00:07:02,720 --> 00:07:08,080
how to

00:07:04,479 --> 00:07:11,919
how to describe parallel semantics among

00:07:08,080 --> 00:07:14,000
say valid strings or characters and then

00:07:11,919 --> 00:07:15,840
have some sort of some sort of

00:07:14,000 --> 00:07:17,360
algorithmic way to reduce the

00:07:15,840 --> 00:07:19,599
parallelism

00:07:17,360 --> 00:07:21,039
is a good use case and maybe it's not

00:07:19,599 --> 00:07:22,479
intuitive because

00:07:21,039 --> 00:07:24,319
why would you want to go from more

00:07:22,479 --> 00:07:26,479
parallel to less parallel well

00:07:24,319 --> 00:07:27,759
there's there's some interesting reasons

00:07:26,479 --> 00:07:29,360
i think that this is one of them that

00:07:27,759 --> 00:07:31,440
we're talking about here

00:07:29,360 --> 00:07:32,960
now the shuffle operator this is just an

00:07:31,440 --> 00:07:35,680
example of

00:07:32,960 --> 00:07:37,680
how it works over two regular languages

00:07:35,680 --> 00:07:39,680
in this example you've got language 1

00:07:37,680 --> 00:07:41,599
which is just the string av

00:07:39,680 --> 00:07:43,039
and you've got language 2 which is just

00:07:41,599 --> 00:07:46,479
the string cd

00:07:43,039 --> 00:07:49,520
now if i want to shuffle l1 and l2

00:07:46,479 --> 00:07:51,280
i'm saying that i want to

00:07:49,520 --> 00:07:54,080
want to bring them together in such a

00:07:51,280 --> 00:07:57,599
way that valid strings resulting in the

00:07:54,080 --> 00:08:00,960
language from the shuffle

00:07:57,599 --> 00:08:04,400
it's a combination of all valid strings

00:08:00,960 --> 00:08:07,840
from l1 and all valid strings in l2

00:08:04,400 --> 00:08:10,879
but all combinations of them

00:08:07,840 --> 00:08:12,639
as it may appear as if the valid

00:08:10,879 --> 00:08:13,919
strings from each language are

00:08:12,639 --> 00:08:15,440
interleaved

00:08:13,919 --> 00:08:18,080
and this is a good example that's a

00:08:15,440 --> 00:08:20,400
mouthful what i just said but

00:08:18,080 --> 00:08:22,319
what this says well the valid strings i

00:08:20,400 --> 00:08:23,120
have enumerated here there's five of

00:08:22,319 --> 00:08:27,280
them

00:08:23,120 --> 00:08:30,319
and then it's simply a v and then cd

00:08:27,280 --> 00:08:33,360
a c beating a c

00:08:30,319 --> 00:08:36,320
d v c a d v

00:08:33,360 --> 00:08:36,640
c d a b and you'll know it it maintains

00:08:36,320 --> 00:08:39,440
the

00:08:36,640 --> 00:08:39,760
total ordering within language one and

00:08:39,440 --> 00:08:41,680
then

00:08:39,760 --> 00:08:44,320
total ordering within language two of

00:08:41,680 --> 00:08:45,360
the single strings that are consist of

00:08:44,320 --> 00:08:48,800
the language

00:08:45,360 --> 00:08:50,160
which is a b and c d but it also

00:08:48,800 --> 00:08:52,399
presents the final

00:08:50,160 --> 00:08:54,800
final valid strings of this resulting

00:08:52,399 --> 00:08:57,519
language as the combination

00:08:54,800 --> 00:08:59,200
of all valid strings from both of the

00:08:57,519 --> 00:09:02,959
languages

00:08:59,200 --> 00:09:06,000
in some in all interleaving orders so

00:09:02,959 --> 00:09:07,360
it expresses the partial ordering that

00:09:06,000 --> 00:09:10,399
is inherent among

00:09:07,360 --> 00:09:13,440
the valid strings within each

00:09:10,399 --> 00:09:15,200
constituent language but also enforces

00:09:13,440 --> 00:09:17,120
the total ordering

00:09:15,200 --> 00:09:23,839
of the valid strings that are in each

00:09:17,120 --> 00:09:23,839
individual language

00:09:23,920 --> 00:09:29,120
okay so in the that flat module

00:09:29,519 --> 00:09:32,640
i've implemented or implemented 15 years

00:09:32,240 --> 00:09:34,880
ago

00:09:32,640 --> 00:09:36,320
the ability to convert regular

00:09:34,880 --> 00:09:39,200
expressions um

00:09:36,320 --> 00:09:41,760
into into dfas and the way that we that

00:09:39,200 --> 00:09:43,760
i did that was simply by

00:09:41,760 --> 00:09:46,720
implementing the published algorithms

00:09:43,760 --> 00:09:49,680
that have been well known for some time

00:09:46,720 --> 00:09:50,160
um going from re to nf regular

00:09:49,680 --> 00:09:53,360
expression

00:09:50,160 --> 00:09:54,240
nfa you would parse the regular

00:09:53,360 --> 00:09:56,880
expression

00:09:54,240 --> 00:09:57,760
and create an abstract syntax tree and

00:09:56,880 --> 00:09:59,040
then you would

00:09:57,760 --> 00:10:00,800
you would perform what's called

00:09:59,040 --> 00:10:02,320
thompson's construction which is a

00:10:00,800 --> 00:10:05,680
traversal over this

00:10:02,320 --> 00:10:09,600
abstract syntax tree and when

00:10:05,680 --> 00:10:12,399
different operators are encountered the

00:10:09,600 --> 00:10:13,760
finite automata or the directed graph is

00:10:12,399 --> 00:10:16,560
built up

00:10:13,760 --> 00:10:18,880
um using certain elements based on on

00:10:16,560 --> 00:10:19,519
the tree itself so it's it's literally

00:10:18,880 --> 00:10:21,680
just

00:10:19,519 --> 00:10:23,600
traversing the tree and building up this

00:10:21,680 --> 00:10:27,440
directed graph based on

00:10:23,600 --> 00:10:30,839
the traversal and the uh the

00:10:27,440 --> 00:10:32,079
sub trees that are present when an

00:10:30,839 --> 00:10:34,079
operator

00:10:32,079 --> 00:10:36,480
now nfa going from a non-deterministic

00:10:34,079 --> 00:10:38,079
finite automata to deterministic finite

00:10:36,480 --> 00:10:38,640
automaton you would use something called

00:10:38,079 --> 00:10:42,160
subset

00:10:38,640 --> 00:10:45,440
construction and that basically

00:10:42,160 --> 00:10:48,560
it discovers all of the same um

00:10:45,440 --> 00:10:50,800
same states that that through some

00:10:48,560 --> 00:10:52,160
like creation of i describe it as a

00:10:50,800 --> 00:10:53,839
creation of buckets

00:10:52,160 --> 00:10:55,600
uh and then it determines which of these

00:10:53,839 --> 00:10:56,640
buckets are equivalent collapses those

00:10:55,600 --> 00:10:59,920
buckets down

00:10:56,640 --> 00:11:00,320
into single states and that's how you

00:10:59,920 --> 00:11:02,320
you

00:11:00,320 --> 00:11:04,480
get out of this non-deterministic

00:11:02,320 --> 00:11:06,560
non-deterministic finite automata

00:11:04,480 --> 00:11:07,760
all of the actual deterministic states

00:11:06,560 --> 00:11:10,560
that are present

00:11:07,760 --> 00:11:12,959
and then once you have a dfa

00:11:10,560 --> 00:11:16,880
deterministic finite automata

00:11:12,959 --> 00:11:19,680
you may we necessarily have to enumerate

00:11:16,880 --> 00:11:22,079
all of the valid strings well we started

00:11:19,680 --> 00:11:26,079
with a regular expression

00:11:22,079 --> 00:11:29,040
and the best way to do this is simply to

00:11:26,079 --> 00:11:29,920
implement a depth first traversal of the

00:11:29,040 --> 00:11:32,959
dfa

00:11:29,920 --> 00:11:35,519
taking it as a directed graph from

00:11:32,959 --> 00:11:37,040
the start state to an accepting state

00:11:35,519 --> 00:11:39,279
and if you

00:11:37,040 --> 00:11:41,040
accumulate the labels along the way

00:11:39,279 --> 00:11:42,240
which are the valid symbols then you

00:11:41,040 --> 00:11:46,000
won't necessarily

00:11:42,240 --> 00:11:47,760
be constructing all the valid um

00:11:46,000 --> 00:11:50,000
all the valid strings that are described

00:11:47,760 --> 00:11:52,480
by the language

00:11:50,000 --> 00:11:54,000
of the dfa and this is also a good

00:11:52,480 --> 00:11:56,480
example a good reason

00:11:54,000 --> 00:11:57,760
good place to point out why i don't

00:11:56,480 --> 00:11:59,920
currently

00:11:57,760 --> 00:12:01,120
um i haven't currently done anything

00:11:59,920 --> 00:12:05,440
with creating

00:12:01,120 --> 00:12:07,600
um these pre-plans or these parallel

00:12:05,440 --> 00:12:09,279
regular expressions with the clean stars

00:12:07,600 --> 00:12:12,480
because it admits

00:12:09,279 --> 00:12:15,839
cycles and there's no there's no uh

00:12:12,480 --> 00:12:17,519
neat way to just go from a start state

00:12:15,839 --> 00:12:20,079
to an accept state

00:12:17,519 --> 00:12:20,880
you have to make decisions for example

00:12:20,079 --> 00:12:23,360
how

00:12:20,880 --> 00:12:25,600
which cycles do i want to iterate out

00:12:23,360 --> 00:12:29,040
which cycles do i want to

00:12:25,600 --> 00:12:30,480
traverse how many times do i want to

00:12:29,040 --> 00:12:32,160
traverse them

00:12:30,480 --> 00:12:33,839
so there's there's some questions open

00:12:32,160 --> 00:12:34,639
questions related to that as far as the

00:12:33,839 --> 00:12:36,880
usefulness

00:12:34,639 --> 00:12:39,440
i believe it is very useful in this case

00:12:36,880 --> 00:12:40,240
uh for what we're doing here so genius

00:12:39,440 --> 00:12:42,800
but

00:12:40,240 --> 00:12:43,760
uh that remains to be seen and i'll make

00:12:42,800 --> 00:12:45,839
no claims

00:12:43,760 --> 00:12:47,839
at this time on what can be done so

00:12:45,839 --> 00:12:50,160
we're dealing with finite languages

00:12:47,839 --> 00:12:51,200
and we so that means that the number of

00:12:50,160 --> 00:12:53,760
strings that

00:12:51,200 --> 00:12:55,279
are accepted by these regular

00:12:53,760 --> 00:12:56,240
expressions these parallel regular

00:12:55,279 --> 00:12:59,360
expressions and then

00:12:56,240 --> 00:13:00,560
automatically that they apply is finite

00:12:59,360 --> 00:13:04,639
and you can list them out

00:13:00,560 --> 00:13:04,639
and there is a beginning of this list

00:13:04,720 --> 00:13:08,399
this is uh talking about converting

00:13:06,639 --> 00:13:09,600
these parallel regular expressions to

00:13:08,399 --> 00:13:12,160
dfas

00:13:09,600 --> 00:13:13,839
so the the pre is a parallel regular

00:13:12,160 --> 00:13:16,160
expression

00:13:13,839 --> 00:13:17,760
it is a regular expression that has the

00:13:16,160 --> 00:13:20,000
um

00:13:17,760 --> 00:13:21,760
that has a shuffle operator in it and

00:13:20,000 --> 00:13:22,800
the result is a parallel finite

00:13:21,760 --> 00:13:25,839
automaton

00:13:22,800 --> 00:13:28,320
the parallel finite automata is created

00:13:25,839 --> 00:13:30,560
in a much similar way as going from a

00:13:28,320 --> 00:13:33,760
regular expression to an nfa

00:13:30,560 --> 00:13:36,959
a recursive descent parser it creates an

00:13:33,760 --> 00:13:39,279
abstract syntax tree and then

00:13:36,959 --> 00:13:41,839
the there was an algorithm it was it was

00:13:39,279 --> 00:13:43,680
a modified thompson's construction

00:13:41,839 --> 00:13:45,760
uh that was introduced in the stocks and

00:13:43,680 --> 00:13:48,320
pew paper that

00:13:45,760 --> 00:13:50,399
introduced a lambda transition in

00:13:48,320 --> 00:13:53,360
addition to the epsilon transition

00:13:50,399 --> 00:13:54,399
so we're basically building in a

00:13:53,360 --> 00:13:56,959
modified or

00:13:54,399 --> 00:13:58,079
an augmented non-deterministic finite

00:13:56,959 --> 00:14:01,199
automaton

00:13:58,079 --> 00:14:04,079
that tracks the shuffling

00:14:01,199 --> 00:14:06,000
of languages that is indicated with the

00:14:04,079 --> 00:14:08,320
shuffle operator

00:14:06,000 --> 00:14:08,320
um

00:14:09,040 --> 00:14:13,440
by adding another element and that

00:14:11,519 --> 00:14:16,079
element necessarily includes this

00:14:13,440 --> 00:14:19,279
lambda transition and then from there we

00:14:16,079 --> 00:14:22,079
go from the pfa to the nfa

00:14:19,279 --> 00:14:23,279
this algorithm is published and based

00:14:22,079 --> 00:14:27,360
essentially

00:14:23,279 --> 00:14:30,160
it essentially consists of enumerating

00:14:27,360 --> 00:14:30,639
all of the different interleavings

00:14:30,160 --> 00:14:33,920
between

00:14:30,639 --> 00:14:36,240
all of the valid languages or

00:14:33,920 --> 00:14:37,279
valid strings or valid state state

00:14:36,240 --> 00:14:40,160
transitions

00:14:37,279 --> 00:14:41,519
for the two languages that are being

00:14:40,160 --> 00:14:43,519
shuffled

00:14:41,519 --> 00:14:44,720
it's not an efficient algorithm and

00:14:43,519 --> 00:14:47,199
there have been attempts to

00:14:44,720 --> 00:14:49,519
make it more efficient but it's it's a

00:14:47,199 --> 00:14:53,040
very complex thing to do there's lots of

00:14:49,519 --> 00:14:54,320
the shuffle it necessarily um implies

00:14:53,040 --> 00:14:58,000
lots of

00:14:54,320 --> 00:14:59,360
additional elements to the language for

00:14:58,000 --> 00:15:01,440
addition to language

00:14:59,360 --> 00:15:03,279
and then there's the nfa to dfa using

00:15:01,440 --> 00:15:06,880
the usual subset construction

00:15:03,279 --> 00:15:09,760
and then finally dfa to um to generate

00:15:06,880 --> 00:15:11,839
these valid strings

00:15:09,760 --> 00:15:12,880
strings from a finite language i've

00:15:11,839 --> 00:15:14,639
talked about this

00:15:12,880 --> 00:15:17,040
as long as we don't use a closure or the

00:15:14,639 --> 00:15:19,360
clean star there will be no cycles

00:15:17,040 --> 00:15:21,279
admitted into the dfa or any of the

00:15:19,360 --> 00:15:23,680
finite automata along the way

00:15:21,279 --> 00:15:24,320
so generating these strings is simple

00:15:23,680 --> 00:15:26,720
and when

00:15:24,320 --> 00:15:28,399
when the reason it's important to

00:15:26,720 --> 00:15:29,199
generate strings with what we're doing

00:15:28,399 --> 00:15:32,320
is because

00:15:29,199 --> 00:15:35,440
the strings represent valid

00:15:32,320 --> 00:15:39,040
sequential orderings of the executions

00:15:35,440 --> 00:15:41,040
that are described when we describe

00:15:39,040 --> 00:15:42,399
the relationship the execution

00:15:41,040 --> 00:15:44,720
relationship and

00:15:42,399 --> 00:15:45,920
uh that we want to using the parallel

00:15:44,720 --> 00:15:47,360
regular expression

00:15:45,920 --> 00:15:49,120
so in our examples we're going to be

00:15:47,360 --> 00:15:51,120
using we're just going to be using

00:15:49,120 --> 00:15:52,800
finite languages and that's pretty much

00:15:51,120 --> 00:15:55,279
what it says here

00:15:52,800 --> 00:15:57,519
infinite languages this is uh this is a

00:15:55,279 --> 00:15:59,440
similar slide to the previous one

00:15:57,519 --> 00:16:00,880
but what it says here is if you start

00:15:59,440 --> 00:16:03,199
using the clean star

00:16:00,880 --> 00:16:05,199
you're going to get cycles and the flat

00:16:03,199 --> 00:16:08,079
module has a way to basically

00:16:05,199 --> 00:16:08,800
pump or describe how deeply you would

00:16:08,079 --> 00:16:11,839
like to

00:16:08,800 --> 00:16:13,600
iterate into these cycles in these

00:16:11,839 --> 00:16:15,440
infinite languages but

00:16:13,600 --> 00:16:17,120
right now i haven't i haven't looked

00:16:15,440 --> 00:16:20,160
into how to make this

00:16:17,120 --> 00:16:22,160
useful or accessible when wanting to

00:16:20,160 --> 00:16:24,959
schedule the execution or describe

00:16:22,160 --> 00:16:25,759
some inherent parallelism uh among some

00:16:24,959 --> 00:16:28,560
severe teams

00:16:25,759 --> 00:16:29,040
and executions that had that could have

00:16:28,560 --> 00:16:32,320
zero

00:16:29,040 --> 00:16:33,600
or more uh repetitions i'm not i'm sure

00:16:32,320 --> 00:16:36,720
there's something there

00:16:33,600 --> 00:16:38,639
and uh i'm more than happy to hear from

00:16:36,720 --> 00:16:41,120
anybody if you have any cool ideas

00:16:38,639 --> 00:16:43,120
i just haven't looked at it yet all

00:16:41,120 --> 00:16:45,440
right going back to the shuffle example

00:16:43,120 --> 00:16:47,199
so this this is looking more this is the

00:16:45,440 --> 00:16:49,120
execution dependency graph that we've

00:16:47,199 --> 00:16:52,959
been working with most of the talk

00:16:49,120 --> 00:16:55,040
and it's now i've converted it or i've

00:16:52,959 --> 00:16:56,720
drawn it so that it looks more like a

00:16:55,040 --> 00:16:58,880
finite automaton

00:16:56,720 --> 00:17:00,639
and in this case it's a parallel finite

00:16:58,880 --> 00:17:04,000
automata you see

00:17:00,639 --> 00:17:05,520
the initial state is state zero and you

00:17:04,000 --> 00:17:08,400
go from

00:17:05,520 --> 00:17:10,000
from there to a lambda transition which

00:17:08,400 --> 00:17:11,839
happens pretty much automatically in

00:17:10,000 --> 00:17:13,760
this case like an epsilon

00:17:11,839 --> 00:17:15,919
and then it splits off into the two

00:17:13,760 --> 00:17:19,360
different languages or abc

00:17:15,919 --> 00:17:21,439
and then xyz that we are joining

00:17:19,360 --> 00:17:25,439
through the shuffle and then there's at

00:17:21,439 --> 00:17:25,439
the end another lambda

00:17:25,520 --> 00:17:31,520
note or point and basically what

00:17:28,720 --> 00:17:33,520
this says is i wish i didn't have i

00:17:31,520 --> 00:17:36,080
didn't think to include a picture here

00:17:33,520 --> 00:17:36,559
but if you can think of if you can think

00:17:36,080 --> 00:17:39,039
of

00:17:36,559 --> 00:17:39,840
a if you're familiar with thinking of

00:17:39,039 --> 00:17:43,760
how a

00:17:39,840 --> 00:17:46,400
finite automata operates over a string

00:17:43,760 --> 00:17:49,360
as acceptance is happening you can look

00:17:46,400 --> 00:17:52,960
at a lambda transition to

00:17:49,360 --> 00:17:56,480
to mean that the

00:17:52,960 --> 00:17:58,000
there is a um

00:17:56,480 --> 00:18:00,240
there are two different languages that

00:17:58,000 --> 00:18:02,799
are being shuffled and there are

00:18:00,240 --> 00:18:04,640
literally two two different languages as

00:18:02,799 --> 00:18:08,160
in their original form

00:18:04,640 --> 00:18:11,360
are being um executed over

00:18:08,160 --> 00:18:13,760
a given string and that

00:18:11,360 --> 00:18:15,200
in order for this combined string or

00:18:13,760 --> 00:18:18,080
this inner leaf string

00:18:15,200 --> 00:18:19,520
to be accepted it needs to be accepted

00:18:18,080 --> 00:18:22,799
by both languages

00:18:19,520 --> 00:18:24,240
so that is another i guess indication

00:18:22,799 --> 00:18:27,520
that the shuffle operator

00:18:24,240 --> 00:18:30,799
implies parallelism is that inherently

00:18:27,520 --> 00:18:31,360
you're describing that any any valid

00:18:30,799 --> 00:18:33,919
string

00:18:31,360 --> 00:18:35,039
must simultaneous that is valid with the

00:18:33,919 --> 00:18:38,000
shuffled language

00:18:35,039 --> 00:18:39,200
but simultaneously be accepted by both

00:18:38,000 --> 00:18:42,400
languages

00:18:39,200 --> 00:18:44,640
and that's what what this uh

00:18:42,400 --> 00:18:45,760
this branching off at the lambda and

00:18:44,640 --> 00:18:48,240
then it's

00:18:45,760 --> 00:18:49,840
coming back together or merging um at

00:18:48,240 --> 00:18:50,559
the land on the right hand side

00:18:49,840 --> 00:18:52,640
indicates

00:18:50,559 --> 00:18:54,240
and then and then of course the uh

00:18:52,640 --> 00:18:57,200
there's the final state seven

00:18:54,240 --> 00:18:58,799
so so in terms of execution over

00:18:57,200 --> 00:19:00,720
parallel finite automata

00:18:58,799 --> 00:19:02,400
that's exactly what our parallel

00:19:00,720 --> 00:19:06,400
execution was describing

00:19:02,400 --> 00:19:06,640
so it matches what i guess the semantics

00:19:06,400 --> 00:19:10,160
of

00:19:06,640 --> 00:19:12,000
what we want to express here so the

00:19:10,160 --> 00:19:14,559
resulting pfa if i

00:19:12,000 --> 00:19:16,080
so the one on the top is the original

00:19:14,559 --> 00:19:17,600
the graph on the top is the original

00:19:16,080 --> 00:19:21,200
execution graph

00:19:17,600 --> 00:19:24,000
the picture on the bottom is the result

00:19:21,200 --> 00:19:24,799
of passing in a parallel regular

00:19:24,000 --> 00:19:29,200
expression

00:19:24,799 --> 00:19:31,120
into um into flat or

00:19:29,200 --> 00:19:32,320
through through into flat through

00:19:31,120 --> 00:19:34,880
sub-genes

00:19:32,320 --> 00:19:35,840
and it dumped and it's a visualization

00:19:34,880 --> 00:19:39,360
of

00:19:35,840 --> 00:19:42,400
the pfa that is created and then i

00:19:39,360 --> 00:19:45,280
i did this i'm able to

00:19:42,400 --> 00:19:45,280
export the

00:19:45,520 --> 00:19:49,840
graph you know various various stages of

00:19:48,320 --> 00:19:52,880
the graph the

00:19:49,840 --> 00:19:54,880
finite automata as graphic graphics

00:19:52,880 --> 00:19:57,520
format or the dot format and then i just

00:19:54,880 --> 00:19:58,799
i just render it using dot or something

00:19:57,520 --> 00:20:00,480
in any case that's how i got this

00:19:58,799 --> 00:20:05,280
picture

00:20:00,480 --> 00:20:08,159
but what we're showing here is this abc

00:20:05,280 --> 00:20:09,280
and x y z that's a parallel regular

00:20:08,159 --> 00:20:13,440
expression

00:20:09,280 --> 00:20:16,159
and that's indicating that that abc is

00:20:13,440 --> 00:20:17,200
is a language or an execution path and

00:20:16,159 --> 00:20:19,440
then xyz

00:20:17,200 --> 00:20:20,640
is an execution path and then the and

00:20:19,440 --> 00:20:22,320
symbol

00:20:20,640 --> 00:20:24,559
indicates that there's there's

00:20:22,320 --> 00:20:26,320
independence between those two so

00:20:24,559 --> 00:20:27,679
there's total ordering among each

00:20:26,320 --> 00:20:29,600
language within each

00:20:27,679 --> 00:20:31,520
set of parentheses there but then the

00:20:29,600 --> 00:20:34,559
ampersand indicates that they are

00:20:31,520 --> 00:20:36,000
independent but we want we want to we

00:20:34,559 --> 00:20:39,360
want to indicate that they're

00:20:36,000 --> 00:20:39,679
they're shuffled so um on a high level

00:20:39,360 --> 00:20:43,200
this

00:20:39,679 --> 00:20:44,480
this is a way to express parallelism

00:20:43,200 --> 00:20:49,520
semantically

00:20:44,480 --> 00:20:51,520
using these um the shuffle operator

00:20:49,520 --> 00:20:53,039
this is the resulting non-deterministic

00:20:51,520 --> 00:20:54,480
finite automata

00:20:53,039 --> 00:20:56,720
uh it's kind of neat looking very

00:20:54,480 --> 00:20:59,200
symmetric and nice

00:20:56,720 --> 00:21:00,960
and i dumped it the same way uh in dot

00:20:59,200 --> 00:21:03,440
format

00:21:00,960 --> 00:21:05,679
uh this is the dfa that results from

00:21:03,440 --> 00:21:07,600
subset construction which

00:21:05,679 --> 00:21:09,440
uh i'm sure that there's some symmetry

00:21:07,600 --> 00:21:10,080
there or it can be made to that look

00:21:09,440 --> 00:21:13,360
nice

00:21:10,080 --> 00:21:16,559
and neat but that's what

00:21:13,360 --> 00:21:19,520
got the dot utility not super pretty

00:21:16,559 --> 00:21:21,600
but equivalent and we can see that

00:21:19,520 --> 00:21:24,480
because this is a minimized dfa

00:21:21,600 --> 00:21:25,760
from the same thing and that they were

00:21:24,480 --> 00:21:28,720
back to

00:21:25,760 --> 00:21:29,120
much a much better uh symmetric looking

00:21:28,720 --> 00:21:32,720
uh

00:21:29,120 --> 00:21:33,039
graph direct graph here and ultimately

00:21:32,720 --> 00:21:36,480
this

00:21:33,039 --> 00:21:38,480
this minimal dfa is what we use

00:21:36,480 --> 00:21:41,440
to generate all of the list of the valid

00:21:38,480 --> 00:21:44,960
strings that we showed all 20 of them so

00:21:41,440 --> 00:21:48,000
there's 20 paths from start state 0 to

00:21:44,960 --> 00:21:50,799
except state 15 and they all

00:21:48,000 --> 00:21:51,440
include the proper ordering among a b

00:21:50,799 --> 00:21:53,919
and c

00:21:51,440 --> 00:21:55,919
the proper ordering among x y and z

00:21:53,919 --> 00:21:58,320
however

00:21:55,919 --> 00:21:59,520
a b and c that string is shuffled or

00:21:58,320 --> 00:22:02,559
interleaved within

00:21:59,520 --> 00:22:02,559
the string xyz

00:22:04,240 --> 00:22:08,159
and here we go this is just to

00:22:06,559 --> 00:22:10,720
illustrate my point

00:22:08,159 --> 00:22:11,840
if you take all paths from start from

00:22:10,720 --> 00:22:14,640
start state 0

00:22:11,840 --> 00:22:15,440
to end state 15 you'll you will

00:22:14,640 --> 00:22:18,240
necessarily

00:22:15,440 --> 00:22:19,840
uh generate all 20 strings and all 20 of

00:22:18,240 --> 00:22:22,480
these strings

00:22:19,840 --> 00:22:23,280
are what we're talking about which is

00:22:22,480 --> 00:22:26,159
sequentially

00:22:23,280 --> 00:22:27,280
consistent with the parallelism and

00:22:26,159 --> 00:22:30,080
execution

00:22:27,280 --> 00:22:31,280
uh of execution graph that we showed and

00:22:30,080 --> 00:22:33,360
have been working right through this

00:22:31,280 --> 00:22:35,919
talk

00:22:33,360 --> 00:22:36,960
uh this is another one to show this is a

00:22:35,919 --> 00:22:40,000
finite

00:22:36,960 --> 00:22:42,720
this is the the i guess the

00:22:40,000 --> 00:22:43,840
um evolution is a bad word but the

00:22:42,720 --> 00:22:46,880
stepwise

00:22:43,840 --> 00:22:47,679
uh conversion of a parallel regular

00:22:46,880 --> 00:22:51,919
expression

00:22:47,679 --> 00:22:55,520
that includes the or operator from a pfa

00:22:51,919 --> 00:22:57,600
to the nfa to the minimal dfa i skipped

00:22:55,520 --> 00:22:59,679
the dfa because it doesn't really show

00:22:57,600 --> 00:23:01,039
much that's interesting but the symmetry

00:22:59,679 --> 00:23:05,120
of these pictures

00:23:01,039 --> 00:23:07,919
is is interesting and um

00:23:05,120 --> 00:23:08,720
but i wanted to show an example so so we

00:23:07,919 --> 00:23:12,320
can define

00:23:08,720 --> 00:23:14,480
finite dependency graphs

00:23:12,320 --> 00:23:15,840
as long as we using the using

00:23:14,480 --> 00:23:19,120
concatenation

00:23:15,840 --> 00:23:22,159
using the or for the union and using

00:23:19,120 --> 00:23:24,400
the shuffle for the hand

00:23:22,159 --> 00:23:26,240
but in this case we're not using the

00:23:24,400 --> 00:23:27,840
clean star or the closure because

00:23:26,240 --> 00:23:29,120
because otherwise we would have some

00:23:27,840 --> 00:23:32,480
cycles in there and then we would

00:23:29,120 --> 00:23:32,480
necessarily have to deal with those

00:23:33,840 --> 00:23:40,480
okay so recall the motivation here

00:23:37,520 --> 00:23:41,679
uh i wanted to be able to express some

00:23:40,480 --> 00:23:44,720
concurrency

00:23:41,679 --> 00:23:47,440
on a high level and naturally in pearl

00:23:44,720 --> 00:23:49,200
and then which pearl the language which

00:23:47,440 --> 00:23:52,799
i'm contending

00:23:49,200 --> 00:23:54,960
literally is begging for us to

00:23:52,799 --> 00:23:56,480
express our programs concurrently and

00:23:54,960 --> 00:24:00,000
that's fundamentally

00:23:56,480 --> 00:24:02,880
the the um that comes from its

00:24:00,000 --> 00:24:06,320
functional nature and its ability to be

00:24:02,880 --> 00:24:07,360
highly implicit that's that makes us

00:24:06,320 --> 00:24:10,320
want to describe

00:24:07,360 --> 00:24:10,720
things in parallel or independently so

00:24:10,320 --> 00:24:14,080
that's

00:24:10,720 --> 00:24:15,840
that's a natural claim uh it's a i feel

00:24:14,080 --> 00:24:17,840
like it's a natural claim

00:24:15,840 --> 00:24:19,919
and natural feeling to want to express

00:24:17,840 --> 00:24:22,799
pearl semantically

00:24:19,919 --> 00:24:23,760
in parallel or to describe parallel

00:24:22,799 --> 00:24:28,080
things

00:24:23,760 --> 00:24:31,360
now since pearl the the run time

00:24:28,080 --> 00:24:32,880
is a uni process that gives us a bit of

00:24:31,360 --> 00:24:35,120
a problem there's

00:24:32,880 --> 00:24:36,720
there's that you know you can call it

00:24:35,120 --> 00:24:40,400
cognitive dissonance but

00:24:36,720 --> 00:24:41,919
there's there's it doesn't match

00:24:40,400 --> 00:24:43,840
the way that we want to think about the

00:24:41,919 --> 00:24:47,200
language and use the language

00:24:43,840 --> 00:24:49,360
hits a really thick brick wall when then

00:24:47,200 --> 00:24:50,559
when we have to consider the environment

00:24:49,360 --> 00:24:52,960
in which it's running

00:24:50,559 --> 00:24:54,000
all right the whole point of this is

00:24:52,960 --> 00:24:56,080
that

00:24:54,000 --> 00:24:57,200
there's a there's a way to be able to

00:24:56,080 --> 00:25:00,480
think in parallel

00:24:57,200 --> 00:25:03,600
and also still run as intended

00:25:00,480 --> 00:25:04,559
in this uni process environment and in

00:25:03,600 --> 00:25:07,600
fact

00:25:04,559 --> 00:25:08,480
we can we can even use the benefits of

00:25:07,600 --> 00:25:11,120
both

00:25:08,480 --> 00:25:11,760
there's the freedom of expression in the

00:25:11,120 --> 00:25:14,640
um

00:25:11,760 --> 00:25:15,679
you know by using the parallel pearl the

00:25:14,640 --> 00:25:18,559
language

00:25:15,679 --> 00:25:19,279
to imply parallelism and then there's

00:25:18,559 --> 00:25:21,840
the

00:25:19,279 --> 00:25:23,200
the consistency and the predictability

00:25:21,840 --> 00:25:24,799
of the memory model

00:25:23,200 --> 00:25:26,400
and the introspection of the memory

00:25:24,799 --> 00:25:29,279
model that pearl

00:25:26,400 --> 00:25:31,279
the uni process the run time gives us

00:25:29,279 --> 00:25:33,679
and i think it results in some

00:25:31,279 --> 00:25:36,720
some interesting approaches to pearl to

00:25:33,679 --> 00:25:36,720
writing pro programs

00:25:37,360 --> 00:25:42,559
okay so i created this this module and

00:25:40,640 --> 00:25:46,480
it's called subgenius

00:25:42,559 --> 00:25:49,840
and um basically what it does it takes

00:25:46,480 --> 00:25:53,440
a um it takes the

00:25:49,840 --> 00:25:56,000
a an execution plan which is the string

00:25:53,440 --> 00:25:58,320
represented as a parallel finite a

00:25:56,000 --> 00:26:01,360
parallel regular expression

00:25:58,320 --> 00:26:04,640
and converts it into

00:26:01,360 --> 00:26:08,080
one of any number of valid

00:26:04,640 --> 00:26:11,360
sequential strings so it takes a pre

00:26:08,080 --> 00:26:13,400
and converts it to a

00:26:11,360 --> 00:26:14,960
it serializes it and then the

00:26:13,400 --> 00:26:18,880
serialization of

00:26:14,960 --> 00:26:23,120
that the turn is then used

00:26:18,880 --> 00:26:24,400
to uh run the subroutines that may be

00:26:23,120 --> 00:26:28,000
named the same thing as

00:26:24,400 --> 00:26:29,120
the words in that pre in the order

00:26:28,000 --> 00:26:31,600
described in its

00:26:29,120 --> 00:26:33,600
serialization the important part is that

00:26:31,600 --> 00:26:37,120
the serialization

00:26:33,600 --> 00:26:40,640
is sequentially consistent so if we can

00:26:37,120 --> 00:26:41,760
if we can think about how we want to run

00:26:40,640 --> 00:26:44,159
a program

00:26:41,760 --> 00:26:45,279
we can describe it in a parallel or

00:26:44,159 --> 00:26:49,440
implicit way

00:26:45,279 --> 00:26:52,480
we can then use this module to generate

00:26:49,440 --> 00:26:55,360
a serialized execution

00:26:52,480 --> 00:26:57,279
execution calls or these subroutines so

00:26:55,360 --> 00:27:00,640
that it is being done

00:26:57,279 --> 00:27:03,600
we can trust that it's being done in

00:27:00,640 --> 00:27:05,360
a way that is consistent sequentially

00:27:03,600 --> 00:27:07,840
with how it was described

00:27:05,360 --> 00:27:07,840
in parallel

00:27:11,360 --> 00:27:19,919
let's see oh another thing to point out

00:27:16,159 --> 00:27:20,960
is the serialization can take many forms

00:27:19,919 --> 00:27:23,679
as we've seen

00:27:20,960 --> 00:27:24,320
with that simple graph call graph that

00:27:23,679 --> 00:27:26,960
we've

00:27:24,320 --> 00:27:28,080
been looking at for a dependency graph

00:27:26,960 --> 00:27:32,080
you can see there's 20

00:27:28,080 --> 00:27:34,159
20 valid orders so even a simple

00:27:32,080 --> 00:27:36,880
parallel regular expression can be you

00:27:34,159 --> 00:27:40,960
know executed many different ways

00:27:36,880 --> 00:27:43,360
and then there's um the benefit of

00:27:40,960 --> 00:27:45,840
the for the fact that these subroutines

00:27:43,360 --> 00:27:48,799
are being called within a

00:27:45,840 --> 00:27:50,720
unified uh pearl process so that means

00:27:48,799 --> 00:27:52,480
that we have global memory

00:27:50,720 --> 00:27:53,840
we're able to utilize and we're able to

00:27:52,480 --> 00:27:56,080
utilize all the cool things that

00:27:53,840 --> 00:27:59,039
subroutines give us including

00:27:56,080 --> 00:28:00,320
being able to pass in parameters and

00:27:59,039 --> 00:28:04,080
return parameters

00:28:00,320 --> 00:28:05,919
and also the give assign or give or

00:28:04,080 --> 00:28:08,000
assign the subroutines um

00:28:05,919 --> 00:28:09,200
memory from call to call through the

00:28:08,000 --> 00:28:10,880
state variable or

00:28:09,200 --> 00:28:12,720
through the state keyword and i would

00:28:10,880 --> 00:28:16,080
like to also give credit

00:28:12,720 --> 00:28:18,399
uh to my buddy today who

00:28:16,080 --> 00:28:19,919
came up with the name for this module i

00:28:18,399 --> 00:28:23,039
had actually originally called it

00:28:19,919 --> 00:28:24,159
uh subsequentializer something but it

00:28:23,039 --> 00:28:26,720
was a mouthful but

00:28:24,159 --> 00:28:27,520
he suggested i i was asking for better

00:28:26,720 --> 00:28:29,919
names

00:28:27,520 --> 00:28:31,120
uh this was one of them and it just it

00:28:29,919 --> 00:28:32,320
really stuck because i think it's

00:28:31,120 --> 00:28:36,640
hilarious

00:28:32,320 --> 00:28:38,720
um and and very appropriate so

00:28:36,640 --> 00:28:40,799
but check out his modules he's got one

00:28:38,720 --> 00:28:44,000
on uh playwright

00:28:40,799 --> 00:28:47,360
which is uh for web know web browser

00:28:44,000 --> 00:28:49,279
uh automation uh he does the uh

00:28:47,360 --> 00:28:50,399
he's got the pro module for for

00:28:49,279 --> 00:28:52,159
playwright so i would and

00:28:50,399 --> 00:28:53,919
he's done some selenium stuff he's got

00:28:52,159 --> 00:28:58,640
he's got neat stuff in any case

00:28:53,919 --> 00:29:02,240
uh okay

00:28:58,640 --> 00:29:04,080
so this is the um

00:29:02,240 --> 00:29:06,159
this is the execution environment in

00:29:04,080 --> 00:29:08,000
which we're we're provided with

00:29:06,159 --> 00:29:09,679
when we're running something that a

00:29:08,000 --> 00:29:12,480
serialized

00:29:09,679 --> 00:29:12,960
schedule that we've been presented with

00:29:12,480 --> 00:29:15,120
after

00:29:12,960 --> 00:29:16,799
serializing a parallel regular

00:29:15,120 --> 00:29:17,360
expression that describes how we want

00:29:16,799 --> 00:29:19,760
our

00:29:17,360 --> 00:29:21,360
subroutines to interact we've got our

00:29:19,760 --> 00:29:24,080
global shared memory

00:29:21,360 --> 00:29:26,000
and everything's running on one cpu

00:29:24,080 --> 00:29:28,640
within one pearl process

00:29:26,000 --> 00:29:30,399
so we've got the global memory that

00:29:28,640 --> 00:29:30,799
we're told we can't use or shouldn't use

00:29:30,399 --> 00:29:32,480
or

00:29:30,799 --> 00:29:34,000
it's not a best practice but in this

00:29:32,480 --> 00:29:37,440
case it's it's a

00:29:34,000 --> 00:29:42,000
benefit and then we have a uh

00:29:37,440 --> 00:29:44,960
we have a scope and this is provided by

00:29:42,000 --> 00:29:45,279
provided for by the subgenius driver the

00:29:44,960 --> 00:29:47,760
run

00:29:45,279 --> 00:29:49,039
method we'll show some demonstrations

00:29:47,760 --> 00:29:53,919
here shortly

00:29:49,039 --> 00:29:55,440
but there's a scope that gets passed

00:29:53,919 --> 00:29:58,000
from call to call among

00:29:55,440 --> 00:29:59,120
the subroutines so it's more or less

00:29:58,000 --> 00:30:01,679
like a

00:29:59,120 --> 00:30:02,399
an accumulator or you can treat you can

00:30:01,679 --> 00:30:06,159
treat

00:30:02,399 --> 00:30:08,720
this as um it's not something

00:30:06,159 --> 00:30:10,320
over which the subroutine executions can

00:30:08,720 --> 00:30:11,520
contact his filters

00:30:10,320 --> 00:30:13,039
you don't have to use it that way you

00:30:11,520 --> 00:30:15,039
can totally ignore the fact that this is

00:30:13,039 --> 00:30:17,760
happening but it provides some

00:30:15,039 --> 00:30:19,520
uh more or less an execution scope for

00:30:17,760 --> 00:30:21,120
this i think angular or one of the

00:30:19,520 --> 00:30:22,960
versions of angular has something

00:30:21,120 --> 00:30:25,360
similar but

00:30:22,960 --> 00:30:26,399
but in any case there is an ability to

00:30:25,360 --> 00:30:29,760
pass

00:30:26,399 --> 00:30:32,159
something among these subroutines as

00:30:29,760 --> 00:30:34,240
they are getting called in order

00:30:32,159 --> 00:30:36,320
and then finally we've got with we've

00:30:34,240 --> 00:30:39,279
got the subroutines themselves

00:30:36,320 --> 00:30:41,919
and the subroutines you can either you

00:30:39,279 --> 00:30:46,159
can either just treat them

00:30:41,919 --> 00:30:48,000
by default and not not

00:30:46,159 --> 00:30:49,360
not take advantage of the fact that you

00:30:48,000 --> 00:30:51,279
can give it memory

00:30:49,360 --> 00:30:52,799
so it can remember things within its own

00:30:51,279 --> 00:30:55,120
context from call to call

00:30:52,799 --> 00:30:56,960
or you can create some state variables

00:30:55,120 --> 00:30:59,440
within the subroutines you define

00:30:56,960 --> 00:31:00,080
and suddenly you've got subroutines that

00:30:59,440 --> 00:31:02,880
can remember

00:31:00,080 --> 00:31:04,080
things and they can evolve and they can

00:31:02,880 --> 00:31:05,760
they can do

00:31:04,080 --> 00:31:07,200
uh they can do things even more

00:31:05,760 --> 00:31:08,159
implicitly so we're dealing with

00:31:07,200 --> 00:31:11,440
multiple level

00:31:08,159 --> 00:31:13,200
levels of you know being implicit

00:31:11,440 --> 00:31:14,640
and that's really where the power of

00:31:13,200 --> 00:31:17,760
this is is

00:31:14,640 --> 00:31:20,080
we're trying to get to

00:31:17,760 --> 00:31:21,600
as much we're trying to give ourselves

00:31:20,080 --> 00:31:24,720
as much

00:31:21,600 --> 00:31:27,039
power to implicitly describe think

00:31:24,720 --> 00:31:29,360
the thing we want to do as possible and

00:31:27,039 --> 00:31:32,399
that starts with describing things

00:31:29,360 --> 00:31:35,679
maybe currently using the pre and then

00:31:32,399 --> 00:31:39,760
also utilizing global memory

00:31:35,679 --> 00:31:41,440
and then giving our the scope the scope

00:31:39,760 --> 00:31:42,640
value that gets passed from call to call

00:31:41,440 --> 00:31:46,159
and then finally giving

00:31:42,640 --> 00:31:48,880
the subroutines memory which i clearly

00:31:46,159 --> 00:31:53,279
think is pretty cool

00:31:48,880 --> 00:31:56,480
okay this is the um

00:31:53,279 --> 00:31:57,840
this is anatomy of a very basic program

00:31:56,480 --> 00:32:01,600
that's using

00:31:57,840 --> 00:32:04,240
um subgenius and it's really

00:32:01,600 --> 00:32:06,000
all it is it's really two it's really

00:32:04,240 --> 00:32:09,600
it's really three things

00:32:06,000 --> 00:32:12,000
um at the top you you describe the plan

00:32:09,600 --> 00:32:15,279
i call it pre-plan

00:32:12,000 --> 00:32:16,960
and um that's parallel regular

00:32:15,279 --> 00:32:20,159
expression

00:32:16,960 --> 00:32:23,600
that describes the ordering or the

00:32:20,159 --> 00:32:25,679
the constraints on on how the subroutine

00:32:23,600 --> 00:32:29,200
should be called

00:32:25,679 --> 00:32:30,240
now necessarily any if it's not obvious

00:32:29,200 --> 00:32:32,000
by now any

00:32:30,240 --> 00:32:35,200
word that's in this parallel regular

00:32:32,000 --> 00:32:38,399
expression really needs to be

00:32:35,200 --> 00:32:42,320
implemented as a subroutine or

00:32:38,399 --> 00:32:45,360
handled in some way by auto load

00:32:42,320 --> 00:32:47,200
but in any case any word that is in this

00:32:45,360 --> 00:32:50,399
parallel regular expression

00:32:47,200 --> 00:32:51,279
is a subroutine that is going to get

00:32:50,399 --> 00:32:57,120
called

00:32:51,279 --> 00:32:59,440
so the second part or i should say

00:32:57,120 --> 00:33:00,399
well there's a pre and then there's the

00:32:59,440 --> 00:33:05,720
call to sub

00:33:00,399 --> 00:33:08,960
genius to basically linearize or

00:33:05,720 --> 00:33:10,159
sequentialize the plan into some valid

00:33:08,960 --> 00:33:13,039
ordering as we've been talking

00:33:10,159 --> 00:33:13,840
about this whole time and then there's

00:33:13,039 --> 00:33:17,360
the call

00:33:13,840 --> 00:33:19,200
to run any now i've

00:33:17,360 --> 00:33:20,640
it's probably better for me to just

00:33:19,200 --> 00:33:23,760
direct you to the main page

00:33:20,640 --> 00:33:25,440
or the pod on on sub subgenius to look

00:33:23,760 --> 00:33:28,399
at the different ways to run things

00:33:25,440 --> 00:33:29,279
but the most concise way that you can

00:33:28,399 --> 00:33:32,720
run

00:33:29,279 --> 00:33:37,279
a plan is by using run in

00:33:32,720 --> 00:33:40,320
so you when you initially initialize

00:33:37,279 --> 00:33:43,519
the subgenius reference

00:33:40,320 --> 00:33:45,039
and you pass it to free plan it's not

00:33:43,519 --> 00:33:47,760
yet serialized

00:33:45,039 --> 00:33:48,720
you've just created this this object or

00:33:47,760 --> 00:33:52,880
this

00:33:48,720 --> 00:33:55,200
instance of some genius and then

00:33:52,880 --> 00:33:57,039
you can use run any run any pretty much

00:33:55,200 --> 00:33:58,640
encapsulates the things you need to do

00:33:57,039 --> 00:34:02,480
like the call to syria

00:33:58,640 --> 00:34:06,159
to serialize the pre into into a dfa

00:34:02,480 --> 00:34:09,599
and then um and also

00:34:06,159 --> 00:34:10,879
pick a an execution plan or generate a

00:34:09,599 --> 00:34:13,599
string basically

00:34:10,879 --> 00:34:14,000
that describes the execution plan and

00:34:13,599 --> 00:34:17,200
then

00:34:14,000 --> 00:34:19,359
iterate over this string just calling

00:34:17,200 --> 00:34:20,800
each subroutine one one at a time in

00:34:19,359 --> 00:34:23,919
order and

00:34:20,800 --> 00:34:27,760
while passing in the scope variable

00:34:23,919 --> 00:34:29,520
so um what this run any call is doing

00:34:27,760 --> 00:34:30,079
it's encompassing all of that so that is

00:34:29,520 --> 00:34:33,200
the most

00:34:30,079 --> 00:34:36,079
concise way and it's also saying that

00:34:33,200 --> 00:34:37,280
uh you're comfortable running in any of

00:34:36,079 --> 00:34:39,200
the valid

00:34:37,280 --> 00:34:41,040
sequentially consistent plans that are

00:34:39,200 --> 00:34:43,200
produced by this pra

00:34:41,040 --> 00:34:46,000
theory and what i would what i would

00:34:43,200 --> 00:34:49,200
suggest is you not have a pre

00:34:46,000 --> 00:34:53,359
that has valid orderings that you're not

00:34:49,200 --> 00:34:57,119
wanting to use in other words the pre

00:34:53,359 --> 00:35:01,040
should give you a finite set

00:34:57,119 --> 00:35:04,720
the finite set of strings that you

00:35:01,040 --> 00:35:06,880
want to be able to execute over

00:35:04,720 --> 00:35:08,720
or the orderings that you which you want

00:35:06,880 --> 00:35:13,040
to be executing

00:35:08,720 --> 00:35:16,000
the the your tolerance for the number of

00:35:13,040 --> 00:35:17,760
different valid orderings described in

00:35:16,000 --> 00:35:21,440
the pre

00:35:17,760 --> 00:35:23,680
has a lot to do with the parallelism

00:35:21,440 --> 00:35:24,640
that is present in what it is that you

00:35:23,680 --> 00:35:26,720
want to do

00:35:24,640 --> 00:35:28,400
if something is fully independent

00:35:26,720 --> 00:35:30,720
embarrassingly

00:35:28,400 --> 00:35:32,000
independent are embarrassingly parallel

00:35:30,720 --> 00:35:34,880
as they say

00:35:32,000 --> 00:35:35,359
then you don't really care the order in

00:35:34,880 --> 00:35:38,160
which

00:35:35,359 --> 00:35:39,200
these these subroutines are executed

00:35:38,160 --> 00:35:41,040
they all

00:35:39,200 --> 00:35:42,960
you just want them all run it doesn't

00:35:41,040 --> 00:35:45,620
matter the order okay

00:35:42,960 --> 00:35:47,280
now you can use you can use the

00:35:45,620 --> 00:35:50,079
[Music]

00:35:47,280 --> 00:35:51,040
um you can construct a parallel regular

00:35:50,079 --> 00:35:54,720
expression

00:35:51,040 --> 00:35:57,599
that does imply you know some routines

00:35:54,720 --> 00:35:59,440
that need to happen in a certain order

00:35:57,599 --> 00:36:01,280
where they need to have it in order

00:35:59,440 --> 00:36:02,160
parts of your execution where maybe

00:36:01,280 --> 00:36:04,240
there is some

00:36:02,160 --> 00:36:05,200
parallelism and some independence so

00:36:04,240 --> 00:36:07,280
that's that's

00:36:05,200 --> 00:36:09,200
when you start thinking about how you

00:36:07,280 --> 00:36:09,680
really want the execution to go and the

00:36:09,200 --> 00:36:12,320
parts

00:36:09,680 --> 00:36:13,040
that have to be executed in order and

00:36:12,320 --> 00:36:14,960
the others that

00:36:13,040 --> 00:36:16,079
don't have to be executed in any

00:36:14,960 --> 00:36:18,320
particular order

00:36:16,079 --> 00:36:19,599
that's that it gets expressed and you

00:36:18,320 --> 00:36:22,720
can express it

00:36:19,599 --> 00:36:24,720
very very precisely using

00:36:22,720 --> 00:36:26,640
using regular parallel regular

00:36:24,720 --> 00:36:29,440
expressions so that's the power

00:36:26,640 --> 00:36:31,200
you should not you should only be so you

00:36:29,440 --> 00:36:33,760
should only be crafting these parallel

00:36:31,200 --> 00:36:36,160
regular expressions to describe

00:36:33,760 --> 00:36:37,760
the full set or in other words you

00:36:36,160 --> 00:36:39,440
shouldn't

00:36:37,760 --> 00:36:41,280
you're the pre that you're describing

00:36:39,440 --> 00:36:42,320
should not be producing orderings that

00:36:41,280 --> 00:36:44,960
you're not

00:36:42,320 --> 00:36:46,240
you're not admitting is is correct that

00:36:44,960 --> 00:36:48,400
that tells me that

00:36:46,240 --> 00:36:49,359
you need to you need to reformulate your

00:36:48,400 --> 00:36:51,680
pre

00:36:49,359 --> 00:36:53,440
oh hope i didn't get too deep into that

00:36:51,680 --> 00:36:54,960
but that's an important point i needed

00:36:53,440 --> 00:36:56,880
to make

00:36:54,960 --> 00:36:58,880
so i guess the the third and final part

00:36:56,880 --> 00:37:01,119
part of the anatomy of this script

00:36:58,880 --> 00:37:02,320
is that the subroutines are returned and

00:37:01,119 --> 00:37:04,560
if you look at

00:37:02,320 --> 00:37:05,359
so there's a begin sub routine there's a

00:37:04,560 --> 00:37:07,200
step one

00:37:05,359 --> 00:37:09,599
subroutine there's a step two sub

00:37:07,200 --> 00:37:12,320
routine and there's a fin

00:37:09,599 --> 00:37:13,760
sub routine on the left hand side is the

00:37:12,320 --> 00:37:16,480
minimal dfa

00:37:13,760 --> 00:37:17,520
and then under that i list all there's

00:37:16,480 --> 00:37:21,119
only two

00:37:17,520 --> 00:37:24,720
valid valid orderings in which

00:37:21,119 --> 00:37:27,599
this pre is describing the the

00:37:24,720 --> 00:37:28,960
uh execution can go so begin is always

00:37:27,599 --> 00:37:32,000
first

00:37:28,960 --> 00:37:33,680
fin is always last and then the only i

00:37:32,000 --> 00:37:35,200
guess freedom you have or independence

00:37:33,680 --> 00:37:36,960
within the execution of

00:37:35,200 --> 00:37:38,960
where you're where you're able to be

00:37:36,960 --> 00:37:42,000
implicit in your description

00:37:38,960 --> 00:37:43,920
is where step one

00:37:42,000 --> 00:37:45,680
step one and step two don't necessarily

00:37:43,920 --> 00:37:47,440
have have to happen

00:37:45,680 --> 00:37:50,000
uh one after the other they can happen

00:37:47,440 --> 00:37:52,480
in any war and when you serialize it

00:37:50,000 --> 00:37:53,599
down to a single line of execution

00:37:52,480 --> 00:37:55,280
that's what you're going to get so

00:37:53,599 --> 00:37:56,160
you're admitting you're admitting here

00:37:55,280 --> 00:37:59,520
that there's

00:37:56,160 --> 00:38:02,640
only two orderings in which this pre

00:37:59,520 --> 00:38:04,400
is valid based on your description i

00:38:02,640 --> 00:38:05,040
also wanted to point out so let's just

00:38:04,400 --> 00:38:08,880
pick the

00:38:05,040 --> 00:38:11,520
begin subroutine um

00:38:08,880 --> 00:38:14,400
like i said before there is a scope it's

00:38:11,520 --> 00:38:16,560
a hash reference that gets passed in

00:38:14,400 --> 00:38:18,079
to each subroutine call so you can

00:38:16,560 --> 00:38:21,200
capture that in

00:38:18,079 --> 00:38:23,599
as and that's pretty much how you handle

00:38:21,200 --> 00:38:24,240
parameters uh that you wish to pass in

00:38:23,599 --> 00:38:26,079
and out

00:38:24,240 --> 00:38:28,000
of the subroutines as the execution is

00:38:26,079 --> 00:38:29,359
going as i said before i call it the

00:38:28,000 --> 00:38:30,640
execution scope

00:38:29,359 --> 00:38:32,880
not sure if that's the right term but

00:38:30,640 --> 00:38:36,079
that's what i call it and

00:38:32,880 --> 00:38:39,599
then i also show you don't have to use

00:38:36,079 --> 00:38:41,760
a state variable that gives each

00:38:39,599 --> 00:38:42,720
subroutine a memory from call to call

00:38:41,760 --> 00:38:44,320
but you can

00:38:42,720 --> 00:38:46,000
and it's private memory within each

00:38:44,320 --> 00:38:48,560
subroutine so

00:38:46,000 --> 00:38:49,280
in this case i show it we don't use it

00:38:48,560 --> 00:38:52,640
but

00:38:49,280 --> 00:38:54,240
it's there if you want it some things

00:38:52,640 --> 00:38:58,480
can be done

00:38:54,240 --> 00:39:01,440
done pretty cleverly by using this

00:38:58,480 --> 00:39:02,800
this is so this is just this is just a

00:39:01,440 --> 00:39:04,960
anatomy of a program

00:39:02,800 --> 00:39:06,560
and this is this is actually the the

00:39:04,960 --> 00:39:07,520
template not template but this is the

00:39:06,560 --> 00:39:09,359
form that

00:39:07,520 --> 00:39:10,560
all all the examples that i'm going to

00:39:09,359 --> 00:39:15,119
be showing

00:39:10,560 --> 00:39:17,280
shortly follow

00:39:15,119 --> 00:39:19,440
all right i've got a couple of tools

00:39:17,280 --> 00:39:19,760
that come with sub genius one is stubby

00:39:19,440 --> 00:39:22,000
this

00:39:19,760 --> 00:39:23,599
is kind of like the general utility i

00:39:22,000 --> 00:39:26,240
found when i was creating these

00:39:23,599 --> 00:39:27,760
examples that there's a lot there's some

00:39:26,240 --> 00:39:30,960
boilerplate involved

00:39:27,760 --> 00:39:33,040
and i knew i was gonna given a pre

00:39:30,960 --> 00:39:34,240
i knew that i was going to need to

00:39:33,040 --> 00:39:36,400
define

00:39:34,240 --> 00:39:38,160
several teams that were named the same

00:39:36,400 --> 00:39:40,960
thing as all the words in

00:39:38,160 --> 00:39:42,640
the pre so it makes a lot of sense just

00:39:40,960 --> 00:39:44,960
to automatically generate

00:39:42,640 --> 00:39:46,000
these subroutines so a stubby can be

00:39:44,960 --> 00:39:48,640
used for that

00:39:46,000 --> 00:39:50,480
stubby can also be used for pre-caching

00:39:48,640 --> 00:39:52,560
these pres

00:39:50,480 --> 00:39:54,320
because of the complexity of the

00:39:52,560 --> 00:39:57,440
algorithms involved

00:39:54,320 --> 00:39:59,920
these pres can take a long time

00:39:57,440 --> 00:40:02,640
to be compiled and i'm i'll use the word

00:39:59,920 --> 00:40:06,720
compile down into a dfa

00:40:02,640 --> 00:40:10,000
so i built into subgenius the ability to

00:40:06,720 --> 00:40:13,280
cache pres and it happens automatically

00:40:10,000 --> 00:40:16,319
much in the same way as inline c will

00:40:13,280 --> 00:40:19,359
will not recompile

00:40:16,319 --> 00:40:21,359
programs if it detects

00:40:19,359 --> 00:40:22,800
that the shared libraries created for

00:40:21,359 --> 00:40:25,200
use have already been

00:40:22,800 --> 00:40:26,800
have already been generated so very much

00:40:25,200 --> 00:40:30,640
similar approach

00:40:26,800 --> 00:40:32,800
i call it free caching in the tool

00:40:30,640 --> 00:40:34,560
in conversation i call it compiling

00:40:32,800 --> 00:40:39,119
because i mean that's what it is

00:40:34,560 --> 00:40:41,680
so bash is a uh it's an old

00:40:39,119 --> 00:40:43,520
old shell script that basically provides

00:40:41,680 --> 00:40:46,319
access to a bunch of one-liners

00:40:43,520 --> 00:40:47,920
that are available through plaque i plan

00:40:46,319 --> 00:40:50,720
on sprucing that up a bit

00:40:47,920 --> 00:40:51,200
but it's what it's what i can use to say

00:40:50,720 --> 00:40:54,640
dump

00:40:51,200 --> 00:40:57,680
the the dot you know

00:40:54,640 --> 00:41:01,200
the different finite automata and

00:40:57,680 --> 00:41:04,960
um graphiz format for visualization

00:41:01,200 --> 00:41:06,800
but my my goal is to move away from that

00:41:04,960 --> 00:41:09,920
and just use stubby as the

00:41:06,800 --> 00:41:12,240
as the primary tool not only for

00:41:09,920 --> 00:41:13,520
you know initializing project

00:41:12,240 --> 00:41:17,040
initializing

00:41:13,520 --> 00:41:19,040
code but also

00:41:17,040 --> 00:41:20,560
doing allowing for free compilation to

00:41:19,040 --> 00:41:24,000
happen

00:41:20,560 --> 00:41:25,440
and also for doing you know like

00:41:24,000 --> 00:41:28,480
debugging or in

00:41:25,440 --> 00:41:31,200
introspection um with any programs that

00:41:28,480 --> 00:41:34,400
people may end up writing with this

00:41:31,200 --> 00:41:36,880
and i'll show some examples here okay so

00:41:34,400 --> 00:41:38,800
i've already touched on this but

00:41:36,880 --> 00:41:41,920
it takes a long time for pres to be

00:41:38,800 --> 00:41:45,040
compiled or converted into dfas

00:41:41,920 --> 00:41:46,800
this is largely uh algorithmically or

00:41:45,040 --> 00:41:48,319
computationally complex with the

00:41:46,800 --> 00:41:51,520
computation of complexity

00:41:48,319 --> 00:41:53,280
is is high so

00:41:51,520 --> 00:41:55,280
you know there's only so efficient that

00:41:53,280 --> 00:41:58,480
the algorithm itself can be made

00:41:55,280 --> 00:42:00,160
but other things can be done to make it

00:41:58,480 --> 00:42:03,280
faster

00:42:00,160 --> 00:42:05,119
the conversion process itself faster

00:42:03,280 --> 00:42:06,960
writing it as it you know as an excess

00:42:05,119 --> 00:42:09,440
module comes to mind

00:42:06,960 --> 00:42:11,520
but since that's not my forte although

00:42:09,440 --> 00:42:13,760
i'm interested in doing that

00:42:11,520 --> 00:42:15,760
my solution was just to provide some

00:42:13,760 --> 00:42:16,720
cash and again this caching is very

00:42:15,760 --> 00:42:19,839
similar to how

00:42:16,720 --> 00:42:23,119
inline c operates

00:42:19,839 --> 00:42:25,839
um and it actually once once you have

00:42:23,119 --> 00:42:27,119
uh once you have a pre that's been

00:42:25,839 --> 00:42:29,200
cached

00:42:27,119 --> 00:42:30,240
it almost takes no time at all because

00:42:29,200 --> 00:42:32,560
it just pulls

00:42:30,240 --> 00:42:34,800
it just pulls the dfa right out of the

00:42:32,560 --> 00:42:34,800
uh

00:42:36,079 --> 00:42:42,480
okay now we get a demo

00:42:39,920 --> 00:42:43,520
all right this is this is what i let in

00:42:42,480 --> 00:42:46,960
with

00:42:43,520 --> 00:42:49,680
it's a jf demo and uh

00:42:46,960 --> 00:42:50,480
oh that is an errand z so please ignore

00:42:49,680 --> 00:42:52,560
that

00:42:50,480 --> 00:42:53,760
as a pdf so i can't delete it right away

00:42:52,560 --> 00:42:55,520
but in any case

00:42:53,760 --> 00:42:56,800
ignore that z at the end that doesn't

00:42:55,520 --> 00:42:59,839
mean anything

00:42:56,800 --> 00:43:02,079
so so this is the uh the pre

00:42:59,839 --> 00:43:03,119
for jeff i thought this was an

00:43:02,079 --> 00:43:08,079
appropriate uh

00:43:03,119 --> 00:43:10,319
demo now let's talk about the jeff fiore

00:43:08,079 --> 00:43:12,480
all right there's a beginning there's an

00:43:10,319 --> 00:43:16,079
end and then within

00:43:12,480 --> 00:43:18,400
the parentheses there's j-a-p-h

00:43:16,079 --> 00:43:19,760
and they are all shuffled shuffled with

00:43:18,400 --> 00:43:22,480
one another

00:43:19,760 --> 00:43:23,520
so this this shows the parallel finite

00:43:22,480 --> 00:43:25,119
automata

00:43:23,520 --> 00:43:27,520
the non-deterministic finite of

00:43:25,119 --> 00:43:31,280
tolerance and the minimum dfa

00:43:27,520 --> 00:43:34,480
that is produced from the

00:43:31,280 --> 00:43:35,599
jaf example now you're saying to

00:43:34,480 --> 00:43:38,640
yourself

00:43:35,599 --> 00:43:39,760
you're probably assuming that the j sub

00:43:38,640 --> 00:43:42,400
routine is going to

00:43:39,760 --> 00:43:43,040
going to print just the a sub routines

00:43:42,400 --> 00:43:46,000
and

00:43:43,040 --> 00:43:46,680
print another and so on but since i

00:43:46,000 --> 00:43:50,160
wanted to

00:43:46,680 --> 00:43:53,119
simultaneously demonstrate

00:43:50,160 --> 00:43:54,800
you know i wanted to simultaneously use

00:43:53,119 --> 00:43:58,079
a classic

00:43:54,800 --> 00:44:00,319
pearl you know pearl tradition

00:43:58,079 --> 00:44:01,760
and also demonstrate what we're doing

00:44:00,319 --> 00:44:04,960
here

00:44:01,760 --> 00:44:04,960
that's not going to be the case

00:44:05,119 --> 00:44:09,040
all right so i think that what i'll do

00:44:07,680 --> 00:44:12,960
now

00:44:09,040 --> 00:44:16,880
is switch over to this view

00:44:12,960 --> 00:44:20,880
where i can run the demo

00:44:16,880 --> 00:44:22,640
and i believe i have the code up

00:44:20,880 --> 00:44:25,680
so let's go i've got three different

00:44:22,640 --> 00:44:25,680
versions of jack

00:44:26,880 --> 00:44:31,040
and it's pretty straightforward so i

00:44:29,839 --> 00:44:33,760
actually can delete

00:44:31,040 --> 00:44:34,720
that find stuff out of there because i'm

00:44:33,760 --> 00:44:36,640
using

00:44:34,720 --> 00:44:37,920
sub genius says it's been installed on

00:44:36,640 --> 00:44:40,480
this system

00:44:37,920 --> 00:44:41,599
um this is just a big old comment so

00:44:40,480 --> 00:44:43,920
this is the pre

00:44:41,599 --> 00:44:45,520
parallel regular expression right here i

00:44:43,920 --> 00:44:48,800
said begin

00:44:45,520 --> 00:44:50,480
and then j-a-p-h

00:44:48,800 --> 00:44:52,880
and then here's where i initially

00:44:50,480 --> 00:44:56,079
initialize

00:44:52,880 --> 00:44:59,119
some more numbers so line number

00:44:56,079 --> 00:45:02,880
29 is where i initialize the

00:44:59,119 --> 00:45:05,280
subgenius instance and then here

00:45:02,880 --> 00:45:06,560
on line 31 i'm creating some global

00:45:05,280 --> 00:45:08,000
memory

00:45:06,560 --> 00:45:09,440
so yes i'm going to be i'm going to be

00:45:08,000 --> 00:45:10,400
utilizing global memory from the

00:45:09,440 --> 00:45:13,680
subroutine

00:45:10,400 --> 00:45:16,480
so most cases i wouldn't recommend that

00:45:13,680 --> 00:45:18,400
but in this case we actually want to

00:45:16,480 --> 00:45:22,160
take advantage of the fact that this is

00:45:18,400 --> 00:45:25,280
provided for us by pro's memory model

00:45:22,160 --> 00:45:28,160
so um this call here

00:45:25,280 --> 00:45:30,160
in it plan that is the step that

00:45:28,160 --> 00:45:33,680
converts the pre

00:45:30,160 --> 00:45:35,119
so the jeff in this case into a minimal

00:45:33,680 --> 00:45:39,040
dfa

00:45:35,119 --> 00:45:42,000
and that basically primes

00:45:39,040 --> 00:45:44,319
and initializes uh our object for for

00:45:42,000 --> 00:45:48,079
getting ready to exit

00:45:44,319 --> 00:45:51,599
so then i have run once now when

00:45:48,079 --> 00:45:54,400
you run on line 35 you run a knit plan

00:45:51,599 --> 00:45:54,800
it's going to it's going to pick any

00:45:54,400 --> 00:45:57,760
some

00:45:54,800 --> 00:45:58,640
some uh one of the orderings you're not

00:45:57,760 --> 00:46:01,359
guaranteeing

00:45:58,640 --> 00:46:02,319
which ordering you're going to be using

00:46:01,359 --> 00:46:04,480
and again

00:46:02,319 --> 00:46:06,400
what i said before you should be

00:46:04,480 --> 00:46:07,119
describing your pre in a way that you

00:46:06,400 --> 00:46:09,359
don't care

00:46:07,119 --> 00:46:10,960
which order you're using now it might be

00:46:09,359 --> 00:46:14,000
beneficial

00:46:10,960 --> 00:46:15,760
to and i have ways to iterate over the

00:46:14,000 --> 00:46:17,839
different ordering it might be

00:46:15,760 --> 00:46:18,880
beneficial to do that in some way or for

00:46:17,839 --> 00:46:21,280
some reason

00:46:18,880 --> 00:46:22,640
but basically you don't have to worry

00:46:21,280 --> 00:46:25,599
about which ordering

00:46:22,640 --> 00:46:26,560
is first so in other words you don't

00:46:25,599 --> 00:46:30,079
you're not going to

00:46:26,560 --> 00:46:33,520
serialize the pre and then

00:46:30,079 --> 00:46:37,440
inspect the orderings that it produces

00:46:33,520 --> 00:46:42,880
you rely on the fact that you described

00:46:37,440 --> 00:46:46,880
you describe your tolerance for

00:46:42,880 --> 00:46:49,520
implied unorderedness in the pre

00:46:46,880 --> 00:46:52,480
and you have some confidence that you're

00:46:49,520 --> 00:46:55,680
going to get a sequentially consistent

00:46:52,480 --> 00:46:57,119
serial ordering from that and then so

00:46:55,680 --> 00:47:00,319
that should just be good enough

00:46:57,119 --> 00:47:01,920
for you although i do i do encourage you

00:47:00,319 --> 00:47:03,599
to look into it uh you mean

00:47:01,920 --> 00:47:05,599
confidence but that's the approach that

00:47:03,599 --> 00:47:08,480
this is implying is

00:47:05,599 --> 00:47:09,839
you generate the pre and then you run it

00:47:08,480 --> 00:47:11,599
if you want to look and see which

00:47:09,839 --> 00:47:14,160
ordering it was running that's cool

00:47:11,599 --> 00:47:15,440
uh but it shouldn't matter your your

00:47:14,160 --> 00:47:18,880
basis and control is

00:47:15,440 --> 00:47:21,440
how you describe the pre um all right so

00:47:18,880 --> 00:47:23,280
this one this run once this is actually

00:47:21,440 --> 00:47:24,559
okay so this is this is the main command

00:47:23,280 --> 00:47:28,240
that you use to execute

00:47:24,559 --> 00:47:30,800
ordering and um

00:47:28,240 --> 00:47:32,559
the verbose that's just an argument

00:47:30,800 --> 00:47:34,480
that's something you can pass in to run

00:47:32,559 --> 00:47:36,240
some diagnostic information

00:47:34,480 --> 00:47:38,079
typically that's off but i'll show you

00:47:36,240 --> 00:47:40,400
what it looks like it could be further

00:47:38,079 --> 00:47:42,079
developed and be more helpful now this

00:47:40,400 --> 00:47:44,720
scope here

00:47:42,079 --> 00:47:46,559
this is just a demonstration of i'm

00:47:44,720 --> 00:47:49,119
initializing the scope

00:47:46,559 --> 00:47:50,480
that is getting passed in to the first

00:47:49,119 --> 00:47:52,319
call so

00:47:50,480 --> 00:47:54,240
this is the data structure and if if

00:47:52,319 --> 00:47:56,559
this isn't defined then you're

00:47:54,240 --> 00:47:58,640
an empty hash is going to be passed into

00:47:56,559 --> 00:48:00,880
the first subroutine it's called

00:47:58,640 --> 00:48:02,880
the pre was described in such a way that

00:48:00,880 --> 00:48:06,160
begin is always called first

00:48:02,880 --> 00:48:08,240
so this anonymous hash

00:48:06,160 --> 00:48:09,680
that we've defined here with with the

00:48:08,240 --> 00:48:12,480
scope keyword

00:48:09,680 --> 00:48:14,640
um where the scope key is going to be

00:48:12,480 --> 00:48:18,480
getting passed into the begin

00:48:14,640 --> 00:48:22,240
subroutine first and then passed on

00:48:18,480 --> 00:48:23,040
to subsequent calls and that's pretty

00:48:22,240 --> 00:48:26,720
much it

00:48:23,040 --> 00:48:34,160
so um now you may be wondering how this

00:48:26,720 --> 00:48:37,520
actually works i'm gonna run it

00:48:34,160 --> 00:48:40,880
and you will see that it prints

00:48:37,520 --> 00:48:44,319
my difference consistently now let's

00:48:40,880 --> 00:48:46,800
let's turn that verbose flag on

00:48:44,319 --> 00:48:48,559
just by passing something in so what

00:48:46,800 --> 00:48:51,839
this is showing us

00:48:48,559 --> 00:48:54,960
it's outlining the the actual serialized

00:48:51,839 --> 00:48:58,480
plan that is being executed

00:48:54,960 --> 00:49:01,599
with this first line and then under

00:48:58,480 --> 00:49:02,240
the execution of the execution colon it

00:49:01,599 --> 00:49:04,480
shows you

00:49:02,240 --> 00:49:05,839
the i guess the output which in our case

00:49:04,480 --> 00:49:09,520
is printing just another

00:49:05,839 --> 00:49:12,240
pearl hacker and then underneath that

00:49:09,520 --> 00:49:14,559
it's showing and i i have this in as

00:49:12,240 --> 00:49:14,559
part of

00:49:14,720 --> 00:49:20,000
that's not part of the diagnostic uh

00:49:17,760 --> 00:49:21,200
the provided diagnostic part what i'm

00:49:20,000 --> 00:49:24,800
doing here is i'm

00:49:21,200 --> 00:49:27,839
literally just dumping the contributions

00:49:24,800 --> 00:49:31,599
uh for each subroutine that's called so

00:49:27,839 --> 00:49:35,200
going back to this in our case

00:49:31,599 --> 00:49:38,880
so begin is getting run first then j

00:49:35,200 --> 00:49:41,680
p h a and then

00:49:38,880 --> 00:49:42,319
so just another pearl hacker the j sub

00:49:41,680 --> 00:49:45,760
routine

00:49:42,319 --> 00:49:50,319
printed just makes sense

00:49:45,760 --> 00:49:53,760
right okay now the a subroutine

00:49:50,319 --> 00:49:56,880
printed you would expect it to print

00:49:53,760 --> 00:50:00,960
another but it prints hacker

00:49:56,880 --> 00:50:02,720
and then h prints pearl p prints another

00:50:00,960 --> 00:50:04,000
well if you look at the execution order

00:50:02,720 --> 00:50:06,640
we want to maintain

00:50:04,000 --> 00:50:07,119
this kind of a trick tricky demo or a

00:50:06,640 --> 00:50:10,400
tricky

00:50:07,119 --> 00:50:10,400
tricky first example but

00:50:10,559 --> 00:50:13,920
what we want because we're dealing with

00:50:12,240 --> 00:50:16,800
this this uh

00:50:13,920 --> 00:50:18,000
specific ordering we want our execution

00:50:16,800 --> 00:50:21,680
order to be

00:50:18,000 --> 00:50:24,800
oblivious to the ordering in which

00:50:21,680 --> 00:50:26,400
the uh the subroutines were called so in

00:50:24,800 --> 00:50:29,680
other words

00:50:26,400 --> 00:50:30,240
we want the first j this could have been

00:50:29,680 --> 00:50:32,640
a p

00:50:30,240 --> 00:50:34,240
or h or a we want the first thing the

00:50:32,640 --> 00:50:35,920
first subroutine that's being shuffled

00:50:34,240 --> 00:50:37,920
to always print just

00:50:35,920 --> 00:50:41,119
we want the second one to always print

00:50:37,920 --> 00:50:43,280
another we went to the thirds of print

00:50:41,119 --> 00:50:45,040
pearl and we went to fourth different

00:50:43,280 --> 00:50:48,079
hacker comma

00:50:45,040 --> 00:50:51,440
and then there's the end so

00:50:48,079 --> 00:50:54,160
the way that this is done is basically

00:50:51,440 --> 00:50:55,200
any of the subroutines defined below

00:50:54,160 --> 00:50:59,040
whether it's j

00:50:55,200 --> 00:51:01,280
a p or h will

00:50:59,040 --> 00:51:03,280
print what's next in the order of the

00:51:01,280 --> 00:51:06,880
string that we're expecting

00:51:03,280 --> 00:51:10,240
to print so

00:51:06,880 --> 00:51:13,920
when say j is called first

00:51:10,240 --> 00:51:17,040
it's going to record

00:51:13,920 --> 00:51:18,800
within let's see here

00:51:17,040 --> 00:51:23,839
it's going to record within this global

00:51:18,800 --> 00:51:23,839
hash that it's printing

00:51:25,119 --> 00:51:29,599
let's see here i'm even confusing myself

00:51:33,440 --> 00:51:37,839
oh let's go back up to the machine

00:51:39,359 --> 00:51:42,800
okay okay so within the scope we're

00:51:41,920 --> 00:51:45,920
defining

00:51:42,800 --> 00:51:46,640
the ordering of jab so here we've got a

00:51:45,920 --> 00:51:50,319
list

00:51:46,640 --> 00:51:53,119
we're creating an anonymous array

00:51:50,319 --> 00:51:54,160
and it's composed of the elements just

00:51:53,119 --> 00:51:57,520
and then another

00:51:54,160 --> 00:51:57,520
and then pearl and then

00:52:00,720 --> 00:52:07,359
and then when a subroutine gets called

00:52:04,079 --> 00:52:07,359
it's going to be picking

00:52:07,920 --> 00:52:14,000
let's see ah okay so it tracks the order

00:52:12,079 --> 00:52:15,359
in which it's called using the scope

00:52:14,000 --> 00:52:17,520
variable

00:52:15,359 --> 00:52:19,440
cur or current what's the what's the

00:52:17,520 --> 00:52:21,920
current what's the current position that

00:52:19,440 --> 00:52:23,200
that order in which the subroutine is

00:52:21,920 --> 00:52:26,160
being called

00:52:23,200 --> 00:52:26,160
so in that case

00:52:26,240 --> 00:52:30,400
it has more to do with the call ordering

00:52:28,480 --> 00:52:33,839
or everything to do with the call order

00:52:30,400 --> 00:52:35,280
so what j is called first we're

00:52:33,839 --> 00:52:38,720
recording the actual

00:52:35,280 --> 00:52:42,880
word contributed by j as the

00:52:38,720 --> 00:52:45,599
element with the index of whatever scope

00:52:42,880 --> 00:52:46,880
per is and then that gets incremented

00:52:45,599 --> 00:52:49,920
and then passed on

00:52:46,880 --> 00:52:54,480
so jay when j is first called

00:52:49,920 --> 00:52:57,839
it's going to record actual as

00:52:54,480 --> 00:53:01,280
uh as just and then

00:52:57,839 --> 00:53:03,440
scope that we record this here

00:53:01,280 --> 00:53:04,640
within the scope barrel that gets passed

00:53:03,440 --> 00:53:07,680
in and out

00:53:04,640 --> 00:53:10,880
within the this contrib

00:53:07,680 --> 00:53:12,079
key that's passed among the different

00:53:10,880 --> 00:53:14,160
subroutines

00:53:12,079 --> 00:53:15,200
the fact that i'm using this state

00:53:14,160 --> 00:53:17,680
variable

00:53:15,200 --> 00:53:18,319
it doesn't really uh give us any benefit

00:53:17,680 --> 00:53:20,559
in this case

00:53:18,319 --> 00:53:22,319
except to just confuse the example which

00:53:20,559 --> 00:53:25,599
clearly

00:53:22,319 --> 00:53:27,760
confused me a bit a little bit but in

00:53:25,599 --> 00:53:28,559
any case it shows you that that you can

00:53:27,760 --> 00:53:31,359
save

00:53:28,559 --> 00:53:32,400
with any subroutine you know things that

00:53:31,359 --> 00:53:34,800
it has done

00:53:32,400 --> 00:53:36,400
or has seen in the past so if we were to

00:53:34,800 --> 00:53:37,119
if we were to create something that

00:53:36,400 --> 00:53:40,319
maybe

00:53:37,119 --> 00:53:41,280
um you know called j again then we could

00:53:40,319 --> 00:53:43,599
recall

00:53:41,280 --> 00:53:44,559
the fact that in a previous call it

00:53:43,599 --> 00:53:47,680
contributed

00:53:44,559 --> 00:53:50,319
the word just um to the to the

00:53:47,680 --> 00:53:51,839
ultimate strength so in any case the

00:53:50,319 --> 00:53:55,359
ordering in

00:53:51,839 --> 00:53:58,319
the ordering in which the server teams

00:53:55,359 --> 00:53:59,520
are called matters and it simply just

00:53:58,319 --> 00:54:02,720
picks out

00:53:59,520 --> 00:54:06,480
the element that is in this

00:54:02,720 --> 00:54:09,200
shaft this jav key

00:54:06,480 --> 00:54:10,000
of within the scope and then the string

00:54:09,200 --> 00:54:13,200
itself is built

00:54:10,000 --> 00:54:15,520
up in this this contrib here

00:54:13,200 --> 00:54:17,520
as each subroutine is called and then

00:54:15,520 --> 00:54:20,800
car is initialized here so

00:54:17,520 --> 00:54:24,960
this car is just what what index

00:54:20,800 --> 00:54:27,599
of the jaff anonymous array above it

00:54:24,960 --> 00:54:29,359
is the subroutine building temperature

00:54:27,599 --> 00:54:32,160
so

00:54:29,359 --> 00:54:32,160
so then once

00:54:34,160 --> 00:54:37,440
once it gets to the end we know that

00:54:36,079 --> 00:54:40,960
thin is going to be called

00:54:37,440 --> 00:54:45,680
last so we have finn actually doing

00:54:40,960 --> 00:54:45,680
the printing of this

00:54:50,319 --> 00:54:54,160
okay that's a little more clear so we

00:54:52,400 --> 00:54:55,200
know that again is going to get called

00:54:54,160 --> 00:54:57,119
first

00:54:55,200 --> 00:54:59,200
then is going to get called last and

00:54:57,119 --> 00:55:00,960
then in the meantime

00:54:59,200 --> 00:55:02,640
j a p and h are going to get called in

00:55:00,960 --> 00:55:05,359
anywhere well

00:55:02,640 --> 00:55:08,400
by the time that end is called we know

00:55:05,359 --> 00:55:13,040
it really is the end

00:55:08,400 --> 00:55:15,920
and uh i guess i was calling it our fin

00:55:13,040 --> 00:55:15,920
but in this example

00:55:17,839 --> 00:55:21,119
but since we're we know it's going to be

00:55:19,520 --> 00:55:23,520
called getting called at the very end

00:55:21,119 --> 00:55:25,839
every single time and we know that this

00:55:23,520 --> 00:55:28,960
contrib

00:55:25,839 --> 00:55:32,880
this contrib key within the scope

00:55:28,960 --> 00:55:35,520
context is uh going to possess

00:55:32,880 --> 00:55:37,440
and ordered the properly ordered words

00:55:35,520 --> 00:55:38,480
that come together to say just another

00:55:37,440 --> 00:55:39,599
pearl hacker

00:55:38,480 --> 00:55:41,280
we're going to put we're going to join

00:55:39,599 --> 00:55:42,640
that in plan and that's where that's

00:55:41,280 --> 00:55:47,520
where you get the brick

00:55:42,640 --> 00:55:52,160
so so that's that

00:55:47,520 --> 00:55:55,839
i've got a couple of other jeff examples

00:55:52,160 --> 00:55:55,839
let's see what the difference is here

00:56:01,440 --> 00:56:06,480
this uses run any so you can see that's

00:56:04,799 --> 00:56:07,040
the main difference here is it just uses

00:56:06,480 --> 00:56:08,960
it front

00:56:07,040 --> 00:56:11,359
running i also don't use any globe the

00:56:08,960 --> 00:56:14,000
global variable but that is that is

00:56:11,359 --> 00:56:16,160
it is uh okay to access that if you want

00:56:14,000 --> 00:56:18,079
the subroutine to be accessing it

00:56:16,160 --> 00:56:19,359
you can use the global variable in the

00:56:18,079 --> 00:56:21,040
global space and

00:56:19,359 --> 00:56:22,400
i guess in the same way as maybe just go

00:56:21,040 --> 00:56:23,920
to scope context

00:56:22,400 --> 00:56:26,160
but it can also be used in different

00:56:23,920 --> 00:56:30,079
ways and i would actually encourage you

00:56:26,160 --> 00:56:30,960
to consider using them discovering you

00:56:30,079 --> 00:56:34,640
know what are the best

00:56:30,960 --> 00:56:34,640
reasons and places to use

00:56:34,880 --> 00:56:38,720
those memories because again we're you

00:56:37,040 --> 00:56:39,839
know we want to take full advantage of

00:56:38,720 --> 00:56:43,280
the memory that

00:56:39,839 --> 00:56:44,160
pearl's giving us we have we have global

00:56:43,280 --> 00:56:47,200
memory

00:56:44,160 --> 00:56:48,240
we have uh memory that can can get

00:56:47,200 --> 00:56:51,760
passed in

00:56:48,240 --> 00:56:54,400
from or an execution context we're

00:56:51,760 --> 00:56:55,760
i guess adding this execution scope that

00:56:54,400 --> 00:56:56,559
can get passed in and out of each

00:56:55,760 --> 00:56:58,400
subroutine

00:56:56,559 --> 00:57:01,119
and then and then you've got the uh the

00:56:58,400 --> 00:57:03,359
state variables

00:57:01,119 --> 00:57:04,160
so this is this is just showing run any

00:57:03,359 --> 00:57:08,400
so there's no

00:57:04,160 --> 00:57:12,000
unlike um unlike in this first example

00:57:08,400 --> 00:57:15,440
here where

00:57:12,000 --> 00:57:17,760
do the net plan and then run

00:57:15,440 --> 00:57:17,760
once

00:57:18,559 --> 00:57:26,240
we're uh we're just creating a pre

00:57:23,119 --> 00:57:29,119
and then we're doing in one fell swoop

00:57:26,240 --> 00:57:30,799
the initialization or instantiation of

00:57:29,119 --> 00:57:34,000
the subgenius

00:57:30,799 --> 00:57:36,880
reference we're passing in the

00:57:34,000 --> 00:57:38,000
um pre-plan and then we're just saying

00:57:36,880 --> 00:57:41,599
run any and then

00:57:38,000 --> 00:57:43,920
of course the um we're passing in

00:57:41,599 --> 00:57:44,880
different keys that maybe the run once

00:57:43,920 --> 00:57:46,720
or when any

00:57:44,880 --> 00:57:48,400
uh would take and this then we're

00:57:46,720 --> 00:57:50,799
initializing the scope

00:57:48,400 --> 00:57:51,520
here works in the same way as the first

00:57:50,799 --> 00:57:55,839
jab

00:57:51,520 --> 00:57:55,839
and then

00:57:57,359 --> 00:58:01,839
so i guess that's what i mean by it's

00:57:59,280 --> 00:58:04,960
it's sequentially consistent

00:58:01,839 --> 00:58:06,559
consistency oblivious it doesn't these

00:58:04,960 --> 00:58:08,720
these subroutines are created in such a

00:58:06,559 --> 00:58:11,839
way where it doesn't matter what we're

00:58:08,720 --> 00:58:15,599
running oh

00:58:11,839 --> 00:58:19,280
this is to demonstrate full comments so

00:58:15,599 --> 00:58:22,880
you can actually have comments

00:58:19,280 --> 00:58:26,319
within your pre-plan to make it easy

00:58:22,880 --> 00:58:31,040
to remember or to to describe it

00:58:26,319 --> 00:58:33,599
um those all get filtered out and um

00:58:31,040 --> 00:58:34,160
so it makes it makes it pretty easy um

00:58:33,599 --> 00:58:36,400
okay

00:58:34,160 --> 00:58:37,920
so let's let's look at a use another

00:58:36,400 --> 00:58:39,599
useful example

00:58:37,920 --> 00:58:41,200
that i don't have uh listed on the

00:58:39,599 --> 00:58:44,000
slides but

00:58:41,200 --> 00:58:44,559
this okay i've talked about openmp

00:58:44,000 --> 00:58:46,559
before

00:58:44,559 --> 00:58:48,240
this is not this is not like using

00:58:46,559 --> 00:58:51,839
openmp with this but i needed to show

00:58:48,240 --> 00:58:51,839
this example

00:58:51,920 --> 00:58:58,400
all right so this this is a

00:58:55,839 --> 00:58:59,359
parallelized parallelization of the

00:58:58,400 --> 00:59:01,839
computation

00:58:59,359 --> 00:59:02,960
pi and it's basically using the

00:59:01,839 --> 00:59:06,559
integration

00:59:02,960 --> 00:59:10,240
method of computing pi so you have

00:59:06,559 --> 00:59:13,359
you have um the function

00:59:10,240 --> 00:59:14,799
a function that i'm not an expert in

00:59:13,359 --> 00:59:17,839
this but

00:59:14,799 --> 00:59:18,400
pi can be can be shown as a function and

00:59:17,839 --> 00:59:21,839
then

00:59:18,400 --> 00:59:25,200
you can basically compute the area

00:59:21,839 --> 00:59:28,960
under this this function and

00:59:25,200 --> 00:59:30,839
using some math you can come up with the

00:59:28,960 --> 00:59:33,040
value of pi

00:59:30,839 --> 00:59:35,520
um i'm probably describing it very

00:59:33,040 --> 00:59:38,079
incorrectly but but in any case

00:59:35,520 --> 00:59:39,599
the the point is that this can be done

00:59:38,079 --> 00:59:41,920
in parallel because you

00:59:39,599 --> 00:59:43,839
basically just you've got this function

00:59:41,920 --> 00:59:44,880
and basically you're just slicing up the

00:59:43,839 --> 00:59:48,160
function

00:59:44,880 --> 00:59:51,359
into rectangles and then computing

00:59:48,160 --> 00:59:54,079
the the area of the rectangle and then

00:59:51,359 --> 00:59:55,680
and then adding them up in a certain way

00:59:54,079 --> 00:59:58,640
and that's that's generally how

00:59:55,680 --> 00:59:59,599
i guess integration is implemented in

00:59:58,640 --> 01:00:01,520
computers but

00:59:59,599 --> 01:00:03,680
but that's what we're doing here so this

01:00:01,520 --> 01:00:04,720
this is an openmp program which of

01:00:03,680 --> 01:00:08,400
course is threaded

01:00:04,720 --> 01:00:08,400
that is computing pi

01:00:08,799 --> 01:00:12,400
and so i wanted to create a useful

01:00:11,599 --> 01:00:15,599
example

01:00:12,400 --> 01:00:18,000
that took thing that computed pi using

01:00:15,599 --> 01:00:20,480
subgenius

01:00:18,000 --> 01:00:22,160
you know again when it gets executed

01:00:20,480 --> 01:00:24,400
it's all run sequentially

01:00:22,160 --> 01:00:25,200
but i wanted to i wanted to show that

01:00:24,400 --> 01:00:28,960
this could be

01:00:25,200 --> 01:00:30,400
described using the pre

01:00:28,960 --> 01:00:32,240
and then come up with something that

01:00:30,400 --> 01:00:35,520
kind of looks like

01:00:32,240 --> 01:00:38,480
so here we have this is

01:00:35,520 --> 01:00:40,240
this is effectively a you know you start

01:00:38,480 --> 01:00:42,559
and then you fork off into

01:00:40,240 --> 01:00:44,240
multiple independent threads each thread

01:00:42,559 --> 01:00:46,319
contributes its own piece

01:00:44,240 --> 01:00:48,000
and then there's a reduction at the end

01:00:46,319 --> 01:00:49,839
where they the values or the

01:00:48,000 --> 01:00:51,440
computations that each thread is done

01:00:49,839 --> 01:00:53,040
independently

01:00:51,440 --> 01:00:56,480
will come back together to give you a

01:00:53,040 --> 01:00:59,920
single result and that result for us is

01:00:56,480 --> 01:01:02,079
so this is the free plan um

01:00:59,920 --> 01:01:03,520
number of threads here this is used

01:01:02,079 --> 01:01:06,160
later on

01:01:03,520 --> 01:01:08,000
um but each one of these step zero step

01:01:06,160 --> 01:01:11,680
one step two step three step four

01:01:08,000 --> 01:01:16,319
step five actually there should be

01:01:11,680 --> 01:01:16,319
there's six threads

01:01:16,640 --> 01:01:22,559
um is uh they're all participating

01:01:19,839 --> 01:01:23,359
in this computation of five now i'm

01:01:22,559 --> 01:01:27,760
using the

01:01:23,359 --> 01:01:27,760
run any and um

01:01:36,720 --> 01:01:39,839
all right well

01:01:42,400 --> 01:01:53,839
show you what scope is

01:01:59,520 --> 01:02:03,359
okay in any case uh the scope that we're

01:02:02,160 --> 01:02:05,280
initializing here

01:02:03,359 --> 01:02:07,119
and we're not using global memory using

01:02:05,280 --> 01:02:09,039
the execution context

01:02:07,119 --> 01:02:10,400
but we've got sum that we're

01:02:09,039 --> 01:02:12,160
initializing at zero

01:02:10,400 --> 01:02:13,760
number of steps is going to be one

01:02:12,160 --> 01:02:15,680
million so per thread

01:02:13,760 --> 01:02:20,240
it's going to iterate one million times

01:02:15,680 --> 01:02:23,520
and then pi is undefined

01:02:20,240 --> 01:02:26,000
uh this is just printing out um oh so

01:02:23,520 --> 01:02:26,559
so when this is called this way using

01:02:26,000 --> 01:02:29,680
the run

01:02:26,559 --> 01:02:31,599
anyway the final result

01:02:29,680 --> 01:02:33,599
or the final scope that's passed is

01:02:31,599 --> 01:02:36,240
returned so i'm capturing it so this

01:02:33,599 --> 01:02:36,799
this single line here is executing

01:02:36,240 --> 01:02:38,319
everything

01:02:36,799 --> 01:02:40,720
and capturing at the end the final

01:02:38,319 --> 01:02:42,319
result and then

01:02:40,720 --> 01:02:49,839
this is just printing out the final

01:02:42,319 --> 01:02:49,839
value of pi them um

01:02:52,400 --> 01:02:55,599
so anything anything below this

01:02:54,400 --> 01:02:58,319
subroutine yeah this

01:02:55,599 --> 01:03:00,160
this comment block here subroutine

01:02:58,319 --> 01:03:01,520
that's your program as long as you have

01:03:00,160 --> 01:03:03,520
the

01:03:01,520 --> 01:03:04,720
initialization or the the execution of

01:03:03,520 --> 01:03:05,839
your program as long as you have the

01:03:04,720 --> 01:03:09,520
subroutines

01:03:05,839 --> 01:03:12,160
defined um as you

01:03:09,520 --> 01:03:12,960
consider them then they will do the

01:03:12,160 --> 01:03:15,680
right thing

01:03:12,960 --> 01:03:18,079
so in this example i've got each

01:03:15,680 --> 01:03:21,839
subroutine defined explicitly

01:03:18,079 --> 01:03:24,799
they all call me this do calc

01:03:21,839 --> 01:03:25,920
and then i finally have this reduce

01:03:24,799 --> 01:03:29,440
subroutine

01:03:25,920 --> 01:03:31,200
so the duke calc basically each thread

01:03:29,440 --> 01:03:34,480
is computing and so

01:03:31,200 --> 01:03:37,599
it's um it's piece of the

01:03:34,480 --> 01:03:40,000
pi the value of pi then it's computed

01:03:37,599 --> 01:03:41,520
and really the only reason why there is

01:03:40,000 --> 01:03:43,359
a sub routine here

01:03:41,520 --> 01:03:44,880
per step you know step one step two step

01:03:43,359 --> 01:03:48,640
three is to

01:03:44,880 --> 01:03:51,760
um is to uh define that

01:03:48,640 --> 01:03:55,440
this is step id one

01:03:51,760 --> 01:03:57,359
or step id zero okay so

01:03:55,440 --> 01:03:59,119
otherwise it's all boilerplate but i'm

01:03:57,359 --> 01:04:01,359
going to run this to show you that

01:03:59,119 --> 01:04:02,319
it produces anything and i will warn you

01:04:01,359 --> 01:04:05,200
ahead of time

01:04:02,319 --> 01:04:07,680
this is not exactly pi and it's not the

01:04:05,200 --> 01:04:07,680
whole point

01:04:10,839 --> 01:04:13,920
so

01:04:12,240 --> 01:04:16,799
so it's doing its thing it's computing

01:04:13,920 --> 01:04:19,520
pi it's iterating over

01:04:16,799 --> 01:04:21,280
millions of times and then it gives us

01:04:19,520 --> 01:04:23,680
something that kind of looks like pi

01:04:21,280 --> 01:04:26,559
i guess that's acceptable for now so but

01:04:23,680 --> 01:04:29,200
what's happened here is

01:04:26,559 --> 01:04:31,119
each of those each of those subroutines

01:04:29,200 --> 01:04:33,680
have been executed in

01:04:31,119 --> 01:04:33,680
some order

01:04:37,760 --> 01:04:41,920
so this this is an example i wanted to

01:04:40,400 --> 01:04:43,599
reduce the number of explicit

01:04:41,920 --> 01:04:45,760
subroutines

01:04:43,599 --> 01:04:47,920
because we're trying to write less code

01:04:45,760 --> 01:04:51,119
and here i've got the same pre

01:04:47,920 --> 01:04:53,839
step 0 through 5

01:04:51,119 --> 01:04:55,119
but here what i've got instead of

01:04:53,839 --> 01:04:58,319
defining

01:04:55,119 --> 01:05:00,640
defining each subroutine explicitly

01:04:58,319 --> 01:05:01,680
i'm using auto load because i don't have

01:05:00,640 --> 01:05:03,680
the steps

01:05:01,680 --> 01:05:05,520
defined i'm using auto load to get out

01:05:03,680 --> 01:05:08,720
the necessary information

01:05:05,520 --> 01:05:11,359
so i'm getting the name

01:05:08,720 --> 01:05:12,640
uh really i'm not even caring about the

01:05:11,359 --> 01:05:15,119
name i want to make sure that

01:05:12,640 --> 01:05:17,039
the subroutine that's in the pre is at

01:05:15,119 --> 01:05:19,119
least starts with the word step

01:05:17,039 --> 01:05:20,559
and it has a number on it but what i

01:05:19,119 --> 01:05:22,880
really want to get out of it

01:05:20,559 --> 01:05:23,760
is the number that's at the end because

01:05:22,880 --> 01:05:26,799
that's

01:05:23,760 --> 01:05:27,839
that's used as the step by d now and

01:05:26,799 --> 01:05:30,559
then so

01:05:27,839 --> 01:05:32,000
this whole part of the auto load you may

01:05:30,559 --> 01:05:34,240
recognize is just

01:05:32,000 --> 01:05:36,000
looking at okay what it was called and

01:05:34,240 --> 01:05:39,119
then the bottom part is dealing

01:05:36,000 --> 01:05:40,559
with calling now i'm getting

01:05:39,119 --> 01:05:43,039
since we're dealing with scope that's

01:05:40,559 --> 01:05:45,920
getting passed into each subroutine call

01:05:43,039 --> 01:05:46,480
um i'm capturing it here under old scope

01:05:45,920 --> 01:05:49,359
and then

01:05:46,480 --> 01:05:50,480
when i run it i'm capturing the new

01:05:49,359 --> 01:05:52,559
scope

01:05:50,480 --> 01:05:53,760
now i'm running it using snap which is

01:05:52,559 --> 01:05:56,960
just it's

01:05:53,760 --> 01:06:00,000
it's like you know prototypical

01:05:56,960 --> 01:06:01,039
or archetypal uh step and it uses the

01:06:00,000 --> 01:06:03,680
step id

01:06:01,039 --> 01:06:05,520
and then the old scope and then here

01:06:03,680 --> 01:06:08,079
really it's just a wrapper around

01:06:05,520 --> 01:06:09,359
view count which necessarily means a

01:06:08,079 --> 01:06:11,839
step id

01:06:09,359 --> 01:06:13,119
uh and then and then the scope okay

01:06:11,839 --> 01:06:15,200
because it updates

01:06:13,119 --> 01:06:19,839
does it update this code now it gets

01:06:15,200 --> 01:06:19,839
information from the scope like the sum

01:06:22,000 --> 01:06:27,039
like the sum and oh okay

01:06:25,119 --> 01:06:28,400
so i'm not assigning to scope within

01:06:27,039 --> 01:06:31,440
this two count

01:06:28,400 --> 01:06:35,520
but i am assigning to scope within

01:06:31,440 --> 01:06:38,400
snap snap return scope and then

01:06:35,520 --> 01:06:40,400
auto load returns the new scope and that

01:06:38,400 --> 01:06:42,000
gets fed into the next 17 that gets

01:06:40,400 --> 01:06:45,039
called

01:06:42,000 --> 01:06:46,880
i will show you that it runs it may even

01:06:45,039 --> 01:06:49,119
give us the same answer as

01:06:46,880 --> 01:06:49,119
first

01:06:51,039 --> 01:06:57,039
there we go same same answer now

01:06:54,799 --> 01:06:59,119
it ran a little bit faster but that's

01:06:57,039 --> 01:07:02,160
because we were caching

01:06:59,119 --> 01:07:04,400
i will show you the cash directory

01:07:02,160 --> 01:07:05,520
those are storable objects that were

01:07:04,400 --> 01:07:08,240
generated from

01:07:05,520 --> 01:07:08,240
the pres

01:07:08,799 --> 01:07:11,599
and i'll talk i can talk a little bit

01:07:10,240 --> 01:07:14,240
about how those are generated in a

01:07:11,599 --> 01:07:14,240
consistent way

01:07:14,720 --> 01:07:21,200
all right final example is

01:07:18,160 --> 01:07:22,319
making it more implicit i have the same

01:07:21,200 --> 01:07:25,520
step listed

01:07:22,319 --> 01:07:28,880
six times okay

01:07:25,520 --> 01:07:30,079
and i'm calling it the same way but this

01:07:28,880 --> 01:07:33,680
time

01:07:30,079 --> 01:07:36,720
i've just got i've got no auto load i've

01:07:33,680 --> 01:07:39,839
got a single server team called step

01:07:36,720 --> 01:07:41,680
i've got the reduce which it's the same

01:07:39,839 --> 01:07:45,200
in all cases and i've got to do calc

01:07:41,680 --> 01:07:45,200
which has been the same in all cases

01:07:45,520 --> 01:07:52,559
so what's happening here we're using

01:07:49,119 --> 01:07:55,839
the state keyword

01:07:52,559 --> 01:07:58,480
to track and increment the step id so

01:07:55,839 --> 01:08:02,720
each time

01:07:58,480 --> 01:08:07,680
each time this is called step is called

01:08:02,720 --> 01:08:10,079
step id is zero

01:08:07,680 --> 01:08:10,079
step

01:08:13,200 --> 01:08:17,359
and then go all the way down here keep

01:08:16,159 --> 01:08:19,600
in mind that

01:08:17,359 --> 01:08:24,960
this is going to still result in a valid

01:08:19,600 --> 01:08:28,640
pre because it supports comments id

01:08:24,960 --> 01:08:33,120
is equal to five

01:08:28,640 --> 01:08:33,600
so we're taking advantage of the fact

01:08:33,120 --> 01:08:36,159
that

01:08:33,600 --> 01:08:37,920
the step function step subroutine can

01:08:36,159 --> 01:08:39,440
remember through the state variable step

01:08:37,920 --> 01:08:42,560
id

01:08:39,440 --> 01:08:45,600
what what it should be using for step id

01:08:42,560 --> 01:08:48,960
and here's where it's incremented

01:08:45,600 --> 01:08:52,000
and sorry about that

01:08:48,960 --> 01:08:53,920
536 is where it's incremented

01:08:52,000 --> 01:08:55,279
there we go those all three of those

01:08:53,920 --> 01:08:58,000
programs are equivalent

01:08:55,279 --> 01:08:59,040
some are more implicit than others but

01:08:58,000 --> 01:09:01,040
it's giving you

01:08:59,040 --> 01:09:02,239
hopefully it's giving you an example of

01:09:01,040 --> 01:09:07,040
what can be done

01:09:02,239 --> 01:09:10,400
now i can show you stubby

01:09:07,040 --> 01:09:12,239
very quickly so one one thing i mean

01:09:10,400 --> 01:09:14,560
i added a couple of features for stubby

01:09:12,239 --> 01:09:17,279
during this talk because

01:09:14,560 --> 01:09:17,279
i wanted to

01:09:19,279 --> 01:09:27,359
i wanted to be able to generate and list

01:09:23,520 --> 01:09:34,400
all the valid orderings in that way so

01:09:27,359 --> 01:09:38,000
we can um so like

01:09:34,400 --> 01:09:40,480
step zero

01:09:38,000 --> 01:09:43,199
step one we're looking at this is the

01:09:40,480 --> 01:09:46,839
pre that was in the pi example just now

01:09:43,199 --> 01:09:50,080
step two step

01:09:46,839 --> 01:09:53,520
three step four

01:09:50,080 --> 01:09:57,440
step five close

01:09:53,520 --> 01:09:57,440
reduce now

01:09:58,159 --> 01:10:01,440
list something

01:10:02,800 --> 01:10:06,400
sorry dash key

01:10:07,199 --> 01:10:10,880
and since we already ran it it's it's uh

01:10:10,000 --> 01:10:14,159
it's pretty cute

01:10:10,880 --> 01:10:14,159
now i'll show you something here

01:10:14,960 --> 01:10:20,560
gonna i'm gonna um away all of the

01:10:18,239 --> 01:10:20,560
um

01:10:23,280 --> 01:10:27,360
blow away the cache directory and we're

01:10:25,520 --> 01:10:31,840
gonna time this

01:10:27,360 --> 01:10:31,840
just to show the cache effect here

01:10:35,040 --> 01:10:38,159
so here here say take about it took

01:10:37,360 --> 01:10:40,960
about five

01:10:38,159 --> 01:10:41,920
five seconds of real time okay kind of

01:10:40,960 --> 01:10:44,400
solution

01:10:41,920 --> 01:10:46,239
if i were to run that again most of that

01:10:44,400 --> 01:10:49,280
time was actually spent

01:10:46,239 --> 01:10:50,480
um converting the parallel regular

01:10:49,280 --> 01:10:53,120
expression

01:10:50,480 --> 01:10:53,600
um all the way to minimize the fps so

01:10:53,120 --> 01:10:55,120
here

01:10:53,600 --> 01:10:58,320
it runs almost immediately because of

01:10:55,120 --> 01:11:01,600
the caching so a huge savings

01:10:58,320 --> 01:11:05,600
um let's see

01:11:01,600 --> 01:11:05,600
now if i wanted to

01:11:09,760 --> 01:11:16,640
if i wanted to just pre-cache uh

01:11:12,800 --> 01:11:16,640
and not not do anything really with it

01:11:20,159 --> 01:11:27,840
that's where the precache

01:11:29,280 --> 01:11:32,400
and then when it finishes it's going to

01:11:30,880 --> 01:11:35,679
give you the path

01:11:32,400 --> 01:11:35,679
to the um

01:11:35,920 --> 01:11:41,040
the storable object now what we can do

01:11:38,880 --> 01:11:44,719
is

01:11:41,040 --> 01:11:44,719
i can show you that

01:11:48,000 --> 01:11:52,960
let's time this so since that was the

01:11:50,239 --> 01:11:52,960
same pre

01:11:53,040 --> 01:11:57,600
it rained almost immediately now

01:11:57,920 --> 01:12:01,840
i'm gonna i'm gonna blow away the cache

01:12:00,000 --> 01:12:05,040
directory again

01:12:01,840 --> 01:12:06,800
and run that probably take about five

01:12:05,040 --> 01:12:10,960
seconds

01:12:06,800 --> 01:12:10,960
or more slightly one to five okay

01:12:16,080 --> 01:12:19,840
i deleted the cache file again so all

01:12:18,880 --> 01:12:22,960
right so

01:12:19,840 --> 01:12:24,880
system dependent but let's say between

01:12:22,960 --> 01:12:26,000
three and a half to five seconds if i

01:12:24,880 --> 01:12:27,440
were to run this again

01:12:26,000 --> 01:12:29,360
i'm not deleting the cache file and

01:12:27,440 --> 01:12:32,960
running pi boom

01:12:29,360 --> 01:12:36,239
it happens super fast so so

01:12:32,960 --> 01:12:39,760
now what is a what is a pre

01:12:36,239 --> 01:12:45,040
that that like goes off the rails not

01:12:39,760 --> 01:12:45,040
computation or complexity-wise when uh

01:12:45,920 --> 01:12:51,840
when you want to um

01:12:52,560 --> 01:12:58,640
what you want to um

01:12:55,600 --> 01:13:05,840
like make it super slow well

01:12:58,640 --> 01:13:05,840
the more shuffles you have

01:13:10,640 --> 01:13:19,840
see how long this takes

01:13:24,239 --> 01:13:36,000
oh that's not taking any time at all so

01:13:33,600 --> 01:13:36,000
that's it

01:13:38,000 --> 01:13:43,440
all right so that's four seconds a b c

01:13:40,960 --> 01:13:43,440
or g h

01:13:44,840 --> 01:13:47,840
here

01:13:58,239 --> 01:14:01,840
take a little longer

01:14:06,880 --> 01:14:11,600
so this this will actually lead me i so

01:14:09,600 --> 01:14:13,360
check out stubby stubby can also help

01:14:11,600 --> 01:14:15,679
initialize programs

01:14:13,360 --> 01:14:18,239
well i'll give an example of that here

01:14:15,679 --> 01:14:18,239
so you know

01:14:25,920 --> 01:14:29,840
it's working too

01:14:49,199 --> 01:14:57,840
uh i'm gonna kill it

01:14:52,320 --> 01:14:57,840
well maybe h would be faster

01:15:00,880 --> 01:15:03,920
well any case this this points out a

01:15:02,719 --> 01:15:07,199
good uh

01:15:03,920 --> 01:15:12,320
so a good a cool cool thing that uh

01:15:07,199 --> 01:15:16,400
i was playing with in let's see

01:15:12,320 --> 01:15:20,320
in examples let's see i got i've got

01:15:16,400 --> 01:15:22,000
the pre plans now

01:15:20,320 --> 01:15:24,960
one way to get around this in addition

01:15:22,000 --> 01:15:24,960
to caching i think

01:15:32,480 --> 01:15:40,560
all these stubby commands will take um

01:15:36,719 --> 01:15:44,400
files too in addition to to fury now

01:15:40,560 --> 01:15:48,960
what i have here is this do lazy

01:15:44,400 --> 01:15:52,199
here so say we have this monster pre

01:15:48,960 --> 01:15:55,360
you can actually save time by lazily

01:15:52,199 --> 01:15:59,040
sequentializing pres okay

01:15:55,360 --> 01:16:01,199
so this do lazy scq

01:15:59,040 --> 01:16:02,880
actually contains within it i need to

01:16:01,199 --> 01:16:03,199
find the example but it contains within

01:16:02,880 --> 01:16:04,880
it

01:16:03,199 --> 01:16:06,480
that's a routine call so each of these

01:16:04,880 --> 01:16:09,920
are subroutine called it

01:16:06,480 --> 01:16:13,920
sub a sub b lazy sec sub c

01:16:09,920 --> 01:16:17,840
sub d do lazy sec

01:16:13,920 --> 01:16:20,719
is um within it contains

01:16:17,840 --> 01:16:22,000
a new instantiation of subgenius and

01:16:20,719 --> 01:16:24,480
another peri

01:16:22,000 --> 01:16:25,440
so if you have this monster pre that you

01:16:24,480 --> 01:16:27,679
created

01:16:25,440 --> 01:16:28,880
and you don't want you want to save some

01:16:27,679 --> 01:16:32,840
time lazily

01:16:28,880 --> 01:16:35,840
sequentializing you can do it in this

01:16:32,840 --> 01:16:35,840
way

01:16:45,760 --> 01:16:51,360
well here's the example to do lazy which

01:16:48,880 --> 01:16:51,360
is probably

01:16:52,719 --> 01:16:58,800
interesting uh so this

01:16:55,840 --> 01:16:58,800
this do lazy

01:16:59,440 --> 01:17:05,120
down here you can see it's got itself an

01:17:03,040 --> 01:17:07,679
inner

01:17:05,120 --> 01:17:09,040
plan now i'm not going to sit here i'm

01:17:07,679 --> 01:17:12,960
not going to sit here and try and

01:17:09,040 --> 01:17:16,000
uh show you how long it takes to

01:17:12,960 --> 01:17:19,120
to compile the non-lazy

01:17:16,000 --> 01:17:31,840
form of this but i can run this

01:17:19,120 --> 01:17:31,840
script here

01:17:32,960 --> 01:17:39,360
i just show you that boom that works so

01:17:37,440 --> 01:17:42,239
what happens is the order operations

01:17:39,360 --> 01:17:45,440
basically is it sequentializes the

01:17:42,239 --> 01:17:46,480
the top level pre and then when it hits

01:17:45,440 --> 01:17:50,000
the do lazy

01:17:46,480 --> 01:17:53,440
uh subroutine within that subroutine

01:17:50,000 --> 01:17:57,040
it hits another pre and then it

01:17:53,440 --> 01:18:00,000
then will compile that

01:17:57,040 --> 01:18:01,840
and then it will execute that now you

01:18:00,000 --> 01:18:06,400
just need to make sure you define the

01:18:01,840 --> 01:18:10,880
subject now finally i'm going to show

01:18:06,400 --> 01:18:13,920
uh let's see

01:18:10,880 --> 01:18:13,920
stubby knit

01:18:15,040 --> 01:18:20,960
oh let's do stubby and then

01:18:18,640 --> 01:18:20,960
half

01:18:22,320 --> 01:18:26,320
plan so i'm going to initialize i'm

01:18:25,440 --> 01:18:30,480
initialize

01:18:26,320 --> 01:18:35,360
um the perl script

01:18:30,480 --> 01:18:38,239
using that free plan okay

01:18:35,360 --> 01:18:41,840
so we'll just need our next step yeah it

01:18:38,239 --> 01:18:41,840
does have the standard out so

01:18:52,840 --> 01:18:55,840
whatever

01:18:57,199 --> 01:19:02,960
so this literally that call just created

01:19:01,199 --> 01:19:04,960
all of this

01:19:02,960 --> 01:19:06,840
so if you know the pre that you want to

01:19:04,960 --> 01:19:09,760
run

01:19:06,840 --> 01:19:11,440
then okay yeah

01:19:09,760 --> 01:19:13,120
so if you know the pre that you want to

01:19:11,440 --> 01:19:23,120
run so when i created

01:19:13,120 --> 01:19:26,400
that examples

01:19:23,120 --> 01:19:28,080
when i created this program i literally

01:19:26,400 --> 01:19:31,440
just did what i showed you there

01:19:28,080 --> 01:19:34,640
except for the

01:19:31,440 --> 01:19:37,840
new lazy here

01:19:34,640 --> 01:19:37,840
what i did was

01:19:38,480 --> 01:19:45,840
just did i added a pre

01:19:41,679 --> 01:19:49,120
added another call to sub genius um

01:19:45,840 --> 01:19:51,600
you see you see what i did here is i'm

01:19:49,120 --> 01:19:54,000
not even creating instant instance

01:19:51,600 --> 01:19:55,040
i am passing in the scope that was

01:19:54,000 --> 01:19:58,480
passed in

01:19:55,040 --> 01:20:00,960
uh and then i'm just running run eddy

01:19:58,480 --> 01:20:02,159
boom so that's gonna what that is it's

01:20:00,960 --> 01:20:05,840
gonna allow

01:20:02,159 --> 01:20:07,280
allow you to express pres even in

01:20:05,840 --> 01:20:08,880
subroutines as you're calling through

01:20:07,280 --> 01:20:10,560
the original pr

01:20:08,880 --> 01:20:18,320
so you could have it hierarchy nested

01:20:10,560 --> 01:20:23,440
pres that don't take forever to compile

01:20:18,320 --> 01:20:23,440
um all right uh let's

01:20:27,040 --> 01:20:34,000
so genius has a very long

01:20:30,159 --> 01:20:34,960
and interesting or excruciatingly

01:20:34,000 --> 01:20:38,080
painfully long

01:20:34,960 --> 01:20:40,800
however you take it uh pearl dock

01:20:38,080 --> 01:20:41,760
and i'm trying to make sure it's

01:20:40,800 --> 01:20:44,840
complete and

01:20:41,760 --> 01:20:46,080
legible or you know readable that makes

01:20:44,840 --> 01:20:48,719
sense

01:20:46,080 --> 01:20:51,679
so lots lots of stuff to explore there

01:20:48,719 --> 01:20:55,360
all right let me go jump back to the pdf

01:20:51,679 --> 01:20:55,360
and finish this thing

01:20:56,800 --> 01:21:00,159
all right way forward so this gives us i

01:20:59,520 --> 01:21:02,960
mean to me

01:21:00,159 --> 01:21:04,800
i think this gives us some at least a

01:21:02,960 --> 01:21:08,159
some way to express parallel

01:21:04,800 --> 01:21:10,080
parallel semantics um and then it

01:21:08,159 --> 01:21:11,679
allows us to do so in a way that

01:21:10,080 --> 01:21:14,080
exploits pearl's unique process

01:21:11,679 --> 01:21:15,360
model so we can get the implicit

01:21:14,080 --> 01:21:19,840
implicit uh

01:21:15,360 --> 01:21:23,920
you know a way to supposedly define

01:21:19,840 --> 01:21:26,239
programs within this uni process context

01:21:23,920 --> 01:21:29,199
now the examples i showed before were

01:21:26,239 --> 01:21:30,800
kind of i say fork join with in openmp

01:21:29,199 --> 01:21:32,800
and openmp that's kind of like a

01:21:30,800 --> 01:21:35,760
high-level threaded

01:21:32,800 --> 01:21:38,159
interface to programming for cc plus

01:21:35,760 --> 01:21:39,679
plus and fortran

01:21:38,159 --> 01:21:42,080
there are sections within the code you

01:21:39,679 --> 01:21:44,080
can say

01:21:42,080 --> 01:21:46,159
generate or you define these parallel

01:21:44,080 --> 01:21:49,040
sections that's referred to as a fork

01:21:46,159 --> 01:21:50,639
and pearl i mean uh openmp within their

01:21:49,040 --> 01:21:53,199
own literature and

01:21:50,639 --> 01:21:53,679
you know papers and whatnot they refer

01:21:53,199 --> 01:21:57,679
it

01:21:53,679 --> 01:22:00,400
refer to it as primarily a fork joined

01:21:57,679 --> 01:22:01,199
paradigm meaning you have a sequential

01:22:00,400 --> 01:22:03,440
program

01:22:01,199 --> 01:22:04,560
you break out into threads you start

01:22:03,440 --> 01:22:06,639
does its own thing

01:22:04,560 --> 01:22:08,159
you've got shared memory and then

01:22:06,639 --> 01:22:08,960
there's the point where the parallel

01:22:08,159 --> 01:22:10,639
section ends

01:22:08,960 --> 01:22:12,880
and that's the join and then it can

01:22:10,639 --> 01:22:15,840
proceed openmd also has

01:22:12,880 --> 01:22:16,960
tasks and things like that but that's

01:22:15,840 --> 01:22:20,159
that's not really what i'm

01:22:16,960 --> 01:22:22,400
talking about so this

01:22:20,159 --> 01:22:23,280
gives us right out of the box and very

01:22:22,400 --> 01:22:25,360
clearly

01:22:23,280 --> 01:22:26,960
fork joint semantics i'm not talking

01:22:25,360 --> 01:22:28,320
about system fork and i'm not talking

01:22:26,960 --> 01:22:31,360
about array join

01:22:28,320 --> 01:22:35,440
talking about the creation of parallel

01:22:31,360 --> 01:22:38,239
sections uh at least you know for us

01:22:35,440 --> 01:22:39,040
as far as it helps us you know being

01:22:38,239 --> 01:22:41,840
able to

01:22:39,040 --> 01:22:43,280
describe them semantically other things

01:22:41,840 --> 01:22:45,280
that i'm going to be looking at i'm sure

01:22:43,280 --> 01:22:47,040
that there's a way to do a sink

01:22:45,280 --> 01:22:48,560
a weight and a weight that's not

01:22:47,040 --> 01:22:49,120
supposed to be away it's supposed to be

01:22:48,560 --> 01:22:51,280
weight

01:22:49,120 --> 01:22:52,400
but i'm still trying to wrap my head

01:22:51,280 --> 01:22:56,400
around like what

01:22:52,400 --> 01:22:59,679
futures are in this uni process

01:22:56,400 --> 01:23:01,199
context and this this actually is one of

01:22:59,679 --> 01:23:02,719
the things that made me start thinking

01:23:01,199 --> 01:23:06,080
about this

01:23:02,719 --> 01:23:08,960
is i can i kind of get what futures are

01:23:06,080 --> 01:23:09,360
i know what async is i know what a

01:23:08,960 --> 01:23:12,639
weight

01:23:09,360 --> 01:23:15,679
is i think so i do anyway i know

01:23:12,639 --> 01:23:17,280
what uh futures or promises and that

01:23:15,679 --> 01:23:19,199
kind of stuff are

01:23:17,280 --> 01:23:20,800
but it doesn't make any sense to me

01:23:19,199 --> 01:23:23,360
about what that means

01:23:20,800 --> 01:23:25,280
process context like even like how would

01:23:23,360 --> 01:23:28,400
i even describe that

01:23:25,280 --> 01:23:30,239
currently so i think that there's a way

01:23:28,400 --> 01:23:32,639
to do it

01:23:30,239 --> 01:23:34,320
but when i start thinking about it that

01:23:32,639 --> 01:23:34,639
way it just kind of just just kind of

01:23:34,320 --> 01:23:38,000
like

01:23:34,639 --> 01:23:39,760
falls apart on my hand when when i'm

01:23:38,000 --> 01:23:41,199
stuck when i try to think about it so

01:23:39,760 --> 01:23:43,199
i just need to think about it some more

01:23:41,199 --> 01:23:44,480
and talk to some some other

01:23:43,199 --> 01:23:46,400
other people that i never know what

01:23:44,480 --> 01:23:47,520
they're talking about that's what i

01:23:46,400 --> 01:23:49,120
intend to do

01:23:47,520 --> 01:23:50,639
and maybe there's some other paradigms

01:23:49,120 --> 01:23:54,960
that might be interesting

01:23:50,639 --> 01:23:54,960
for us um to look into

01:23:55,040 --> 01:23:59,120
okay um so during all of this i i

01:23:57,840 --> 01:24:01,520
started thinking well

01:23:59,120 --> 01:24:03,440
especially when i implemented the scope

01:24:01,520 --> 01:24:04,400
the execution scope that gets passed in

01:24:03,440 --> 01:24:06,719
and out

01:24:04,400 --> 01:24:08,560
i was thinking this is very pipelining

01:24:06,719 --> 01:24:09,199
uh so let me let me search for something

01:24:08,560 --> 01:24:10,719
like this

01:24:09,199 --> 01:24:12,960
uh at least something related to

01:24:10,719 --> 01:24:15,199
subroutine scheduling on cpan

01:24:12,960 --> 01:24:16,239
and the first well the first three

01:24:15,199 --> 01:24:18,320
there's are

01:24:16,239 --> 01:24:20,080
probably the biggest hits uh there's

01:24:18,320 --> 01:24:23,440
pipeworks sub pipeline

01:24:20,080 --> 01:24:25,280
and prices process pipeline um those are

01:24:23,440 --> 01:24:29,120
interesting take a look at them

01:24:25,280 --> 01:24:31,280
um i think that this this approach is

01:24:29,120 --> 01:24:32,560
it's just different from those so take

01:24:31,280 --> 01:24:35,679
that for for what

01:24:32,560 --> 01:24:39,120
uh there's a flat module which is

01:24:35,679 --> 01:24:42,159
which is what is utilized to convert

01:24:39,120 --> 01:24:44,000
the pre to the pfa and pfa all the way

01:24:42,159 --> 01:24:44,719
down to the minimized dfa and that's how

01:24:44,000 --> 01:24:47,040
we get our

01:24:44,719 --> 01:24:49,120
our strings or our you know aka our

01:24:47,040 --> 01:24:51,440
valid execution paths

01:24:49,120 --> 01:24:53,199
from the the parallel semantics provided

01:24:51,440 --> 01:24:55,360
for the parallel regular expression

01:24:53,199 --> 01:24:56,239
so that's that's really all subgenius

01:24:55,360 --> 01:24:58,960
does is

01:24:56,239 --> 01:25:00,080
it gives us a convenient interface to go

01:24:58,960 --> 01:25:03,199
from a pre

01:25:00,080 --> 01:25:03,600
where the words or subroutine names down

01:25:03,199 --> 01:25:07,440
to

01:25:03,600 --> 01:25:09,440
a linearized schedule equivalent

01:25:07,440 --> 01:25:12,320
or valid sequentially consistent

01:25:09,440 --> 01:25:15,440
schedule of what the subroutine calls

01:25:12,320 --> 01:25:17,360
would look like and then graft petri net

01:25:15,440 --> 01:25:18,719
um i haven't really had a lot of time to

01:25:17,360 --> 01:25:21,920
play with this

01:25:18,719 --> 01:25:23,760
my i said before a

01:25:21,920 --> 01:25:26,400
parallel finite automata is equivalent

01:25:23,760 --> 01:25:28,000
to a binary petri net

01:25:26,400 --> 01:25:29,920
i would like to see if there's an

01:25:28,000 --> 01:25:32,880
opportunity for me to

01:25:29,920 --> 01:25:34,159
integrate or to use graph featuring that

01:25:32,880 --> 01:25:37,520
somehow in flat

01:25:34,159 --> 01:25:39,120
but we shall see flat was

01:25:37,520 --> 01:25:41,040
provided all the capabilities that i

01:25:39,120 --> 01:25:42,080
needed to provide the rapper that some

01:25:41,040 --> 01:25:45,199
geniuses

01:25:42,080 --> 01:25:45,600
but um i'm still interested in the topic

01:25:45,199 --> 01:25:48,239
and

01:25:45,600 --> 01:25:50,159
who knows maybe i'll i'll discover uh

01:25:48,239 --> 01:25:51,760
i'll find out about a

01:25:50,159 --> 01:25:53,120
new regular operator out there that

01:25:51,760 --> 01:25:54,800
might help help in some other

01:25:53,120 --> 01:25:58,480
interesting way

01:25:54,800 --> 01:26:01,360
but i am on the hunt i i tried to find a

01:25:58,480 --> 01:26:04,639
list of all regular operators

01:26:01,360 --> 01:26:06,080
over regular languages and

01:26:04,639 --> 01:26:07,679
for some reason i can't find them i have

01:26:06,080 --> 01:26:09,199
a couple of people i can ask that would

01:26:07,679 --> 01:26:11,360
probably know but if you know let me

01:26:09,199 --> 01:26:11,360
know

01:26:11,760 --> 01:26:16,480
uh goodreads so this

01:26:14,800 --> 01:26:18,800
this point one it talks about the

01:26:16,480 --> 01:26:19,920
shuffle of languages it's on planet math

01:26:18,800 --> 01:26:22,000
it was pretty good

01:26:19,920 --> 01:26:24,639
uh leslie lamport's paper where he

01:26:22,000 --> 01:26:27,360
introduced uh sequential consistency

01:26:24,639 --> 01:26:27,679
now we talked about number three is uh

01:26:27,360 --> 01:26:30,400
it's

01:26:27,679 --> 01:26:32,000
interesting it's not it's not the pdf i

01:26:30,400 --> 01:26:34,639
was looking for but it's still good

01:26:32,000 --> 01:26:37,199
on memory models and what they mean

01:26:34,639 --> 01:26:38,880
typically in the context of multiple

01:26:37,199 --> 01:26:42,639
threads or smp

01:26:38,880 --> 01:26:45,760
um number four is a video from

01:26:42,639 --> 01:26:47,920
design who um

01:26:45,760 --> 01:26:50,320
and i've talked quite a bit about

01:26:47,920 --> 01:26:52,880
sequential consistency and

01:26:50,320 --> 01:26:54,400
async stuff so i would definitely

01:26:52,880 --> 01:26:57,120
recommend checking out some of

01:26:54,400 --> 01:26:59,440
these videos and then there's number

01:26:57,120 --> 01:27:02,560
five introduction to automata theory

01:26:59,440 --> 01:27:03,679
languages which i pointed out and i had

01:27:02,560 --> 01:27:06,159
a copy somewhere

01:27:03,679 --> 01:27:06,159
here it is

01:27:07,920 --> 01:27:14,080
i meant to show it i meant to show it

01:27:11,199 --> 01:27:17,120
before but um

01:27:14,080 --> 01:27:20,880
i also have a book

01:27:17,120 --> 01:27:24,320
on openmp which is interesting

01:27:20,880 --> 01:27:26,719
okay enough of that oh i didn't list the

01:27:24,320 --> 01:27:27,600
paper by stats and few but look up stats

01:27:26,719 --> 01:27:30,840
and few power

01:27:27,600 --> 01:27:33,840
parallel regular expressions it's from

01:27:30,840 --> 01:27:36,080
1994. uh conclusion pres can be used to

01:27:33,840 --> 01:27:38,639
describe some athlete parallelism

01:27:36,080 --> 01:27:40,080
and we can use it as long as we can we

01:27:38,639 --> 01:27:42,880
can get it down to a

01:27:40,080 --> 01:27:44,320
sequentially consistent form um when

01:27:42,880 --> 01:27:46,560
describing execution order of

01:27:44,320 --> 01:27:48,880
subroutines we can we can use

01:27:46,560 --> 01:27:50,400
use it to describe things concurrently

01:27:48,880 --> 01:27:54,159
and execute them

01:27:50,400 --> 01:27:56,400
consistently in the unity process

01:27:54,159 --> 01:27:57,920
but notice there's lots of work to be

01:27:56,400 --> 01:27:59,679
explored here

01:27:57,920 --> 01:28:02,000
hopefully there's some interest in it

01:27:59,679 --> 01:28:05,600
i'm happy to answer questions

01:28:02,000 --> 01:28:07,280
and um you know i'd be thrilled that

01:28:05,600 --> 01:28:11,120
people found bugs and

01:28:07,280 --> 01:28:13,120
future requests so

01:28:11,120 --> 01:28:14,320
open questions i kind of went over this

01:28:13,120 --> 01:28:16,560
before at the end in

01:28:14,320 --> 01:28:17,760
a rush but um you know there's some

01:28:16,560 --> 01:28:20,400
opportunity here

01:28:17,760 --> 01:28:20,880
at some point if if people start using

01:28:20,400 --> 01:28:23,920
this

01:28:20,880 --> 01:28:26,239
there's some opportunity uh to either

01:28:23,920 --> 01:28:28,560
figure out how to how to

01:28:26,239 --> 01:28:30,000
get some you know actual parallelism out

01:28:28,560 --> 01:28:32,159
of this like if we get used to

01:28:30,000 --> 01:28:33,760
expressing things concurrently

01:28:32,159 --> 01:28:35,920
you know it might be a step in the right

01:28:33,760 --> 01:28:38,639
direction to get us

01:28:35,920 --> 01:28:39,040
talking about and thinking about actual

01:28:38,639 --> 01:28:42,159
uh

01:28:39,040 --> 01:28:44,400
shared memory parallelism within pearl

01:28:42,159 --> 01:28:46,320
and seeing if there are parts of pearl

01:28:44,400 --> 01:28:48,239
that can be parallelized i know

01:28:46,320 --> 01:28:49,760
not all of it can be parallelized i know

01:28:48,239 --> 01:28:53,040
that the data structures

01:28:49,760 --> 01:28:56,320
uh are necessarily an unforgivingly

01:28:53,040 --> 01:28:59,199
easy process and require um

01:28:56,320 --> 01:28:59,600
you know the safety that that that gives

01:28:59,199 --> 01:29:01,840
but

01:28:59,600 --> 01:29:03,120
there's probably lots of other places in

01:29:01,840 --> 01:29:05,120
um

01:29:03,120 --> 01:29:07,920
in pearl that that could be made

01:29:05,120 --> 01:29:10,080
parallel or introduce some shared memory

01:29:07,920 --> 01:29:12,800
parallelism i think if i think of you

01:29:10,080 --> 01:29:15,760
know people who are interested in this

01:29:12,800 --> 01:29:17,920
look closely enough we will find that

01:29:15,760 --> 01:29:20,560
there is a tremendous amount of

01:29:17,920 --> 01:29:21,440
um there are tremendous amount of things

01:29:20,560 --> 01:29:24,719
within pearl

01:29:21,440 --> 01:29:26,480
now that can be used for this that maybe

01:29:24,719 --> 01:29:28,000
wasn't thought of to use it in that way

01:29:26,480 --> 01:29:28,960
or maybe not enough people showed

01:29:28,000 --> 01:29:32,080
interest but

01:29:28,960 --> 01:29:35,520
i i'm confident that we have now

01:29:32,080 --> 01:29:37,120
or we we're very close now to to being

01:29:35,520 --> 01:29:40,639
able to provide some really

01:29:37,120 --> 01:29:43,280
nice intuitive interfaces to

01:29:40,639 --> 01:29:45,040
to real shared memory parallelism but in

01:29:43,280 --> 01:29:46,800
the meantime

01:29:45,040 --> 01:29:48,880
it's still enjoyable for me to start

01:29:46,800 --> 01:29:51,520
thinking about these problems and

01:29:48,880 --> 01:29:52,800
get feedback from people regarding the

01:29:51,520 --> 01:29:56,080
approach that

01:29:52,800 --> 01:29:58,639
i'm suggesting here and that's

01:29:56,080 --> 01:30:00,000
it i will stop the recording hopefully

01:29:58,639 --> 01:30:02,880
everything reported

01:30:00,000 --> 01:30:04,400
properly and uh this isn't too terribly

01:30:02,880 --> 01:30:06,080
long but again i'm happy to answer

01:30:04,400 --> 01:30:09,120
questions

01:30:06,080 --> 01:30:10,480
you can find me online not hard to find

01:30:09,120 --> 01:30:12,400
and just let me know if you have

01:30:10,480 --> 01:30:14,800
questions

01:30:12,400 --> 01:30:20,560
good luck have a good good day good

01:30:14,800 --> 01:30:20,560

YouTube URL: https://www.youtube.com/watch?v=XOnPF5GnhHE


