Title: Perl's Amazing Time Machine - Paul Evans
Publication date: 2021-06-10
Playlist: TPC 2021 in the Cloud
Description: 
	Using Perl's custom keyword mechanism we can add new syntax and features, even to versions of Perl released years ago. As it stands, the core mechanism is very low-level and hard to use correctly, but there is a better way.

We'll first take a look at some existing modules that provide syntax extensions, and demonstrate that most of them work as far back as Perl 5.16, even though the modules themselves are much newer than this. We'll then take a brief look at how early versions of those modules were implemented, to demonstrate what is involved in that. Finally we shall take a look at a newer, much simpler method of providing the same - along with a list of benefits and other attractions of this new technique.
Captions: 
	00:00:01,360 --> 00:00:05,200
so i'm going to start

00:00:03,040 --> 00:00:06,799
with a demo if it works come on come on

00:00:05,200 --> 00:00:09,840
press the button yes here we go

00:00:06,799 --> 00:00:12,559
so here is a perl 516

00:00:09,840 --> 00:00:13,599
from when's that well it says copyright

00:00:12,559 --> 00:00:16,240
2012.

00:00:13,599 --> 00:00:17,279
um it was actually released 2013 but

00:00:16,240 --> 00:00:20,480
anyway that's like seven

00:00:17,279 --> 00:00:20,480
eight years ago that's pretty old

00:00:20,640 --> 00:00:26,640
here is a module that i came up with um

00:00:24,320 --> 00:00:28,640
well quite recently uh in fact even the

00:00:26,640 --> 00:00:32,320
very first version here

00:00:28,640 --> 00:00:34,160
21st uh sorry 15th of april 2021 so

00:00:32,320 --> 00:00:37,520
that's a that's a pretty new

00:00:34,160 --> 00:00:38,719
idea of a module and i'm going to

00:00:37,520 --> 00:00:40,079
combine the two

00:00:38,719 --> 00:00:44,000
what do we think is it going to work is

00:00:40,079 --> 00:00:47,680
it going to work uh yes it does

00:00:44,000 --> 00:00:51,120
that's amazing um it's it's an old perl

00:00:47,680 --> 00:00:53,360
but we're using new syntax in it um

00:00:51,120 --> 00:00:54,960
how strange and it is true syntax right

00:00:53,360 --> 00:00:57,280
this isn't this isn't just

00:00:54,960 --> 00:00:58,320
exporting some functions this is this is

00:00:57,280 --> 00:01:00,960
real

00:00:58,320 --> 00:01:01,920
actual control flow syntax so how did i

00:01:00,960 --> 00:01:05,280
do that

00:01:01,920 --> 00:01:08,479
well because i have a time machine

00:01:05,280 --> 00:01:11,119
so over the years in perl we've had

00:01:08,479 --> 00:01:13,439
various changes of syntax so if anyone

00:01:11,119 --> 00:01:14,400
can remember back to 510 we added given

00:01:13,439 --> 00:01:17,119
when

00:01:14,400 --> 00:01:18,960
um we added the defined or operator

00:01:17,119 --> 00:01:20,560
which is absolutely amazing i use it all

00:01:18,960 --> 00:01:22,000
the time i just

00:01:20,560 --> 00:01:26,880
now i just i just don't care about

00:01:22,000 --> 00:01:30,159
anything 5 8 or below

00:01:26,880 --> 00:01:33,119
514 uh we added the substitute

00:01:30,159 --> 00:01:34,960
and replace um in return the value

00:01:33,119 --> 00:01:39,119
operator that's quite useful

00:01:34,960 --> 00:01:41,119
we added package name block 520

00:01:39,119 --> 00:01:42,960
there's a bit of a gap there 520 we

00:01:41,119 --> 00:01:44,720
added the postfix draft those are very

00:01:42,960 --> 00:01:47,920
nice i use those a lot

00:01:44,720 --> 00:01:51,119
uh 532 we added the is a

00:01:47,920 --> 00:01:54,960
and um oh that should say 534 there typo

00:01:51,119 --> 00:01:57,439
in my slides we added try catch

00:01:54,960 --> 00:01:59,280
um what if what if we want to do

00:01:57,439 --> 00:02:02,640
something more than that

00:01:59,280 --> 00:02:04,640
um well uh very early pearls

00:02:02,640 --> 00:02:06,960
we we had to wait for the porters to

00:02:04,640 --> 00:02:11,200
actually add something

00:02:06,960 --> 00:02:13,360
but uh or or worth use uh use devel

00:02:11,200 --> 00:02:16,239
declare which uh

00:02:13,360 --> 00:02:17,120
which is pretty terrible actually um but

00:02:16,239 --> 00:02:18,720
if i'll declare

00:02:17,120 --> 00:02:20,879
it's very fragile it's very fragile

00:02:18,720 --> 00:02:23,760
because um

00:02:20,879 --> 00:02:25,200
you're working at a string level so

00:02:23,760 --> 00:02:29,599
deval declare basically

00:02:25,200 --> 00:02:33,120
you just insert into the

00:02:29,599 --> 00:02:36,000
the reader of the code and

00:02:33,120 --> 00:02:37,519
your your module just decides to rewrite

00:02:36,000 --> 00:02:39,519
the the the text

00:02:37,519 --> 00:02:40,720
that it uh that the pearl thinks it read

00:02:39,519 --> 00:02:43,840
from the file

00:02:40,720 --> 00:02:45,599
um it's very fragile because you have to

00:02:43,840 --> 00:02:47,519
deal with all things like quoted strings

00:02:45,599 --> 00:02:49,200
and comments and hear docs

00:02:47,519 --> 00:02:50,879
and if anyone ever thinks they have

00:02:49,200 --> 00:02:53,599
correctly implemented a regex

00:02:50,879 --> 00:02:55,360
to um to to pull out heredocs for

00:02:53,599 --> 00:02:55,840
example they've almost certainly done it

00:02:55,360 --> 00:02:57,760
wrong

00:02:55,840 --> 00:02:59,840
um because over the years you know many

00:02:57,760 --> 00:03:01,360
people have tried very few people unless

00:02:59,840 --> 00:03:04,080
their name is damian conway have

00:03:01,360 --> 00:03:06,879
actually succeeded

00:03:04,080 --> 00:03:10,080
it's also not re-entrant so you can't do

00:03:06,879 --> 00:03:13,200
kind of nested structures you can't do

00:03:10,080 --> 00:03:15,440
blocks within blocks and so on

00:03:13,200 --> 00:03:16,959
um so it's got a very limited ability to

00:03:15,440 --> 00:03:19,440
kind of really do anything because

00:03:16,959 --> 00:03:20,319
as well as its input all its output is

00:03:19,440 --> 00:03:22,480
perl code

00:03:20,319 --> 00:03:23,599
so all it can do is rewrite your source

00:03:22,480 --> 00:03:25,120
code as if

00:03:23,599 --> 00:03:28,000
you had written something else in your

00:03:25,120 --> 00:03:29,599
editor that's all it can do

00:03:28,000 --> 00:03:31,599
and so really it's it's not much more

00:03:29,599 --> 00:03:33,040
than a step step away from source

00:03:31,599 --> 00:03:34,959
filters right i mean those those are

00:03:33,040 --> 00:03:38,480
pretty terrible

00:03:34,959 --> 00:03:40,159
well 514 basically goaded on by the fact

00:03:38,480 --> 00:03:43,120
that people were using devil declare

00:03:40,159 --> 00:03:45,120
uh the the core maintainers added a nice

00:03:43,120 --> 00:03:46,400
much nicer mechanism called pl keyword

00:03:45,120 --> 00:03:47,920
plugin

00:03:46,400 --> 00:03:50,319
which basically allows you to insert a

00:03:47,920 --> 00:03:52,319
real piece of code

00:03:50,319 --> 00:03:54,560
that has access to the actual lexa and

00:03:52,319 --> 00:03:55,920
the parsing functions

00:03:54,560 --> 00:03:58,799
rather than just working on the source

00:03:55,920 --> 00:04:00,720
code and also in 514

00:03:58,799 --> 00:04:02,959
they added the the ability to create

00:04:00,720 --> 00:04:03,360
custom ops i'll explain those in a

00:04:02,959 --> 00:04:06,159
minute

00:04:03,360 --> 00:04:08,000
basically combined between them they

00:04:06,159 --> 00:04:09,120
make a much more flexible much more

00:04:08,000 --> 00:04:12,400
robust

00:04:09,120 --> 00:04:17,680
syntax extension mechanism

00:04:12,400 --> 00:04:19,120
so let's see what kinds of things we had

00:04:17,680 --> 00:04:20,799
so for example there's a module called

00:04:19,120 --> 00:04:22,880
function parameters

00:04:20,799 --> 00:04:25,280
um which adds as you can see this is

00:04:22,880 --> 00:04:27,520
this is quite fancy syntax

00:04:25,280 --> 00:04:30,080
so rather than the sub keyword you have

00:04:27,520 --> 00:04:32,960
fun and you can put the um

00:04:30,080 --> 00:04:33,919
parameters to your function in there um

00:04:32,960 --> 00:04:35,840
this feature

00:04:33,919 --> 00:04:37,040
this module i'm pretty sure helped

00:04:35,840 --> 00:04:39,759
inspire the

00:04:37,040 --> 00:04:40,479
the mod the the core feature called

00:04:39,759 --> 00:04:43,360
signatures

00:04:40,479 --> 00:04:45,120
which were added in in 520 and still

00:04:43,360 --> 00:04:47,040
currently remain experimental but

00:04:45,120 --> 00:04:48,240
hoping they will they'll make it out of

00:04:47,040 --> 00:04:51,040
experimental soon because

00:04:48,240 --> 00:04:51,840
they're very nice they're very powerful

00:04:51,040 --> 00:04:53,280
um

00:04:51,840 --> 00:04:55,360
there's another module called syntax

00:04:53,280 --> 00:04:57,360
keyword try uh that implements well this

00:04:55,360 --> 00:05:00,240
this try catch syntax

00:04:57,360 --> 00:05:01,440
um as rick said yesterday that's now

00:05:00,240 --> 00:05:05,759
been added to

00:05:01,440 --> 00:05:08,000
to pearl core in 5.34 as use feature try

00:05:05,759 --> 00:05:08,880
and um that that was that was that was

00:05:08,000 --> 00:05:10,639
one that i added

00:05:08,880 --> 00:05:14,000
that that's been in my big feature for

00:05:10,639 --> 00:05:15,840
5.34 i'm very happy we've got that in

00:05:14,000 --> 00:05:17,280
uh we've also got future raising kuwait

00:05:15,840 --> 00:05:18,240
i've talked about this module a number

00:05:17,280 --> 00:05:19,759
of times so i'm not going to go into

00:05:18,240 --> 00:05:22,080
detail today about what it does

00:05:19,759 --> 00:05:23,520
but again it's just another example of

00:05:22,080 --> 00:05:26,080
here's some keywords

00:05:23,520 --> 00:05:28,560
that sit in the middle of your code and

00:05:26,080 --> 00:05:31,759
actually start to do some quite powerful

00:05:28,560 --> 00:05:33,039
things um just in brief it basically

00:05:31,759 --> 00:05:39,840
allows you to suspend

00:05:33,039 --> 00:05:39,840
this function so

00:05:39,919 --> 00:05:43,840
when i do that because it breaks

00:05:41,759 --> 00:05:49,039
everything excuse me a minute

00:05:43,840 --> 00:05:49,039
i have lost all my

00:05:50,840 --> 00:05:53,840
slides

00:05:58,479 --> 00:06:01,039
i'm not going to touch the screen

00:05:59,600 --> 00:06:01,919
anymore that seems a very dangerous

00:06:01,039 --> 00:06:05,840
thing to do

00:06:01,919 --> 00:06:08,960
right so let's move on

00:06:05,840 --> 00:06:10,080
uh object pad is another module um ovid

00:06:08,960 --> 00:06:11,120
was talking about that earlier this

00:06:10,080 --> 00:06:12,080
morning

00:06:11,120 --> 00:06:13,840
again i'm not going to get to detail

00:06:12,080 --> 00:06:15,759
about what it does but again just look

00:06:13,840 --> 00:06:18,479
here we have some quite

00:06:15,759 --> 00:06:19,440
expressive some quite powerful syntax

00:06:18,479 --> 00:06:22,960
that has been added

00:06:19,440 --> 00:06:26,400
as real keywords real syntax real stuff

00:06:22,960 --> 00:06:28,000
in the language it's really doing things

00:06:26,400 --> 00:06:31,039
and with any luck that may one day

00:06:28,000 --> 00:06:33,120
become you know another core feature

00:06:31,039 --> 00:06:35,840
perhaps we'll call it use feature class

00:06:33,120 --> 00:06:35,840
hopefully

00:06:35,919 --> 00:06:41,280
so overall on cpan there's

00:06:38,960 --> 00:06:43,199
basically this collection of modules and

00:06:41,280 --> 00:06:45,840
there may be one or two more

00:06:43,199 --> 00:06:47,360
kind of little ones lurking around but i

00:06:45,840 --> 00:06:49,919
i'm not really aware

00:06:47,360 --> 00:06:52,960
of any other syntax modules other other

00:06:49,919 --> 00:06:52,960
than these lot here

00:06:53,039 --> 00:06:57,280
now if i put the authors and the release

00:06:55,199 --> 00:06:58,240
dates on there you might spot a bit of a

00:06:57,280 --> 00:07:00,800
pattern

00:06:58,240 --> 00:07:01,680
um because if for example we were to

00:07:00,800 --> 00:07:03,919
remove

00:07:01,680 --> 00:07:04,800
well function parameters kind of that

00:07:03,919 --> 00:07:08,639
that's now all

00:07:04,800 --> 00:07:12,240
in choruses in 520 that's now signatures

00:07:08,639 --> 00:07:14,960
um use feature try well that's

00:07:12,240 --> 00:07:15,680
um that's kind of superseded in a way by

00:07:14,960 --> 00:07:18,319
my uh

00:07:15,680 --> 00:07:19,520
my syntax keyword try uh it's just kind

00:07:18,319 --> 00:07:19,919
of a bit more powerful there's a bit

00:07:19,520 --> 00:07:22,880
more

00:07:19,919 --> 00:07:23,919
more stuff and switch playing again um

00:07:22,880 --> 00:07:24,720
is another module i've not really

00:07:23,919 --> 00:07:27,360
mentioned yet

00:07:24,720 --> 00:07:28,400
um that's kind of superseded by syntax

00:07:27,360 --> 00:07:30,080
keyword match

00:07:28,400 --> 00:07:31,840
so if we if we kind of remove all those

00:07:30,080 --> 00:07:34,880
because in any case they're all old

00:07:31,840 --> 00:07:36,639
um pretty much all of the syntax modules

00:07:34,880 --> 00:07:37,680
that exist on cpan that anyone might

00:07:36,639 --> 00:07:41,039
ever have used

00:07:37,680 --> 00:07:41,680
were written by me um apart from g

00:07:41,039 --> 00:07:43,599
fuji's

00:07:41,680 --> 00:07:45,840
keyword boolean in there that adds two

00:07:43,599 --> 00:07:47,520
key words true and false

00:07:45,840 --> 00:07:49,520
which i'm sure everyone finds very

00:07:47,520 --> 00:07:51,520
useful um

00:07:49,520 --> 00:07:54,319
but really nobody other than me seems to

00:07:51,520 --> 00:07:58,479
be writing these things at the moment

00:07:54,319 --> 00:08:00,240
which is a bit of a shame um

00:07:58,479 --> 00:08:02,720
because they provide this kind of

00:08:00,240 --> 00:08:05,520
experimental playground

00:08:02,720 --> 00:08:07,199
right where we can we can iterate and we

00:08:05,520 --> 00:08:10,240
can test out ideas

00:08:07,199 --> 00:08:12,639
much faster than um

00:08:10,240 --> 00:08:13,280
than they can be done in in core pearl i

00:08:12,639 --> 00:08:14,560
mean i've

00:08:13,280 --> 00:08:16,240
i've made the i've made this point a

00:08:14,560 --> 00:08:18,400
number of times that you know we we get

00:08:16,240 --> 00:08:21,199
one core poll release a year

00:08:18,400 --> 00:08:22,879
well i have been known sometimes to do

00:08:21,199 --> 00:08:23,440
two or three versions of a keyword

00:08:22,879 --> 00:08:26,240
module

00:08:23,440 --> 00:08:28,319
in a single week so if i can do you know

00:08:26,240 --> 00:08:30,639
if i could if i could average like

00:08:28,319 --> 00:08:31,520
two releases a week over a year that's a

00:08:30,639 --> 00:08:32,959
hundred

00:08:31,520 --> 00:08:34,560
you know i could potentially do a

00:08:32,959 --> 00:08:35,680
hundred releases a year that's a hundred

00:08:34,560 --> 00:08:39,039
times faster

00:08:35,680 --> 00:08:42,159
than than we can iterate on ideas in

00:08:39,039 --> 00:08:44,240
in core pearl so having this mechanism

00:08:42,159 --> 00:08:45,440
where we can experiment with ideas in

00:08:44,240 --> 00:08:46,720
c-pen nodules

00:08:45,440 --> 00:08:48,640
means that we can get through these

00:08:46,720 --> 00:08:51,279
experiments much faster

00:08:48,640 --> 00:08:52,000
and reach a much wider audience and and

00:08:51,279 --> 00:08:55,519
really

00:08:52,000 --> 00:08:57,920
feel like we have a good solid grip on

00:08:55,519 --> 00:08:58,880
on how these things work you know i i

00:08:57,920 --> 00:09:01,920
added um

00:08:58,880 --> 00:09:03,600
try into into corpul so quickly because

00:09:01,920 --> 00:09:04,959
it was originally one of the syntax

00:09:03,600 --> 00:09:07,040
modules that just

00:09:04,959 --> 00:09:08,800
skipped the whole experimenting with

00:09:07,040 --> 00:09:09,920
what kind of syntax might work what what

00:09:08,800 --> 00:09:12,959
should we want

00:09:09,920 --> 00:09:14,480
um it doesn't matter let's just take

00:09:12,959 --> 00:09:15,360
that that cpan module that has already

00:09:14,480 --> 00:09:17,920
been used for years

00:09:15,360 --> 00:09:19,760
just throw it straight into core made it

00:09:17,920 --> 00:09:22,560
much faster

00:09:19,760 --> 00:09:24,000
um yeah as i said see that's give a try

00:09:22,560 --> 00:09:25,440
well that's that's been in core

00:09:24,000 --> 00:09:28,480
um i'm kind of hoping to get some test

00:09:25,440 --> 00:09:29,519
keyword defer in maybe in in 536 once i

00:09:28,480 --> 00:09:31,760
fixed a few

00:09:29,519 --> 00:09:33,200
small bugs in it where small bugs are if

00:09:31,760 --> 00:09:35,040
you write the code wrong you say full

00:09:33,200 --> 00:09:38,959
pearl

00:09:35,040 --> 00:09:41,519
well i'll hopefully fix that um

00:09:38,959 --> 00:09:42,320
so one of the things that maybe the

00:09:41,519 --> 00:09:45,440
reason why

00:09:42,320 --> 00:09:48,720
why nobody writes these these things is

00:09:45,440 --> 00:09:50,000
um the actual c level api so i'm going

00:09:48,720 --> 00:09:52,000
to have a bit of c code up here

00:09:50,000 --> 00:09:53,120
um there's not gonna be too much c code

00:09:52,000 --> 00:09:55,680
in my in my um

00:09:53,120 --> 00:09:57,279
talk i'm gonna try and keep it brief and

00:09:55,680 --> 00:09:57,680
largely when i'm writing large amounts

00:09:57,279 --> 00:10:00,080
of

00:09:57,680 --> 00:10:02,160
code i'm just writing the code here to

00:10:00,080 --> 00:10:03,120
show you how complicated it is so don't

00:10:02,160 --> 00:10:06,640
worry too much

00:10:03,120 --> 00:10:08,560
if you're not following but briefly how

00:10:06,640 --> 00:10:10,880
the c api works is we have the

00:10:08,560 --> 00:10:12,560
the keyword plug-in hook itself which is

00:10:10,880 --> 00:10:15,360
a variable it's a value

00:10:12,560 --> 00:10:17,279
that gets stored inside the interpreter

00:10:15,360 --> 00:10:18,560
it forms a bit of a chain

00:10:17,279 --> 00:10:20,880
we have a whole bunch of functions

00:10:18,560 --> 00:10:24,000
called lex and pars

00:10:20,880 --> 00:10:26,880
on their name they are kind of the

00:10:24,000 --> 00:10:27,600
the interface that modules can call to

00:10:26,880 --> 00:10:30,800
get at

00:10:27,600 --> 00:10:34,000
the parser and we have the as i said

00:10:30,800 --> 00:10:37,440
earlier the mechanism called custom ops

00:10:34,000 --> 00:10:38,720
the the keyword plugin and the lecture

00:10:37,440 --> 00:10:41,360
and parser will obviously those those

00:10:38,720 --> 00:10:43,440
are happening all at compile time

00:10:41,360 --> 00:10:44,880
so they they are looking at your source

00:10:43,440 --> 00:10:48,000
code understanding what

00:10:44,880 --> 00:10:50,560
what does your program mean

00:10:48,000 --> 00:10:51,519
and the custom ops they are there to

00:10:50,560 --> 00:10:54,640
implement the actual

00:10:51,519 --> 00:10:55,920
runtime of the code so once we've worked

00:10:54,640 --> 00:10:58,480
out what you intend to do

00:10:55,920 --> 00:11:00,880
the custom ops are how do we go about

00:10:58,480 --> 00:11:02,320
actually doing that

00:11:00,880 --> 00:11:04,079
so today i'm i'm mainly going to be

00:11:02,320 --> 00:11:06,160
talking about the parter

00:11:04,079 --> 00:11:09,040
side of things because the the parser

00:11:06,160 --> 00:11:13,200
side of things is

00:11:09,040 --> 00:11:16,640
i think a much much more awkward

00:11:13,200 --> 00:11:19,120
thing that could be made better

00:11:16,640 --> 00:11:21,279
so how that works is that we have as i

00:11:19,120 --> 00:11:23,839
said this uh pl keyword plugin

00:11:21,279 --> 00:11:25,279
hook which is kind of the start point

00:11:23,839 --> 00:11:26,880
the the parser

00:11:25,279 --> 00:11:28,560
when it's looking at your source code it

00:11:26,880 --> 00:11:30,079
gets to a word that it doesn't

00:11:28,560 --> 00:11:31,600
understand

00:11:30,079 --> 00:11:33,120
and it goes oh i don't know what that

00:11:31,600 --> 00:11:36,320
word means you know like

00:11:33,120 --> 00:11:36,560
try or match or flibble wibble or you

00:11:36,320 --> 00:11:38,079
know

00:11:36,560 --> 00:11:40,399
whatever word that you've come up with

00:11:38,079 --> 00:11:41,839
in your syntax to mean something

00:11:40,399 --> 00:11:44,560
perlis that goes well i don't know what

00:11:41,839 --> 00:11:46,880
that means but here plugins maybe do you

00:11:44,560 --> 00:11:48,959
know something about that

00:11:46,880 --> 00:11:50,399
and that gets passed to the first

00:11:48,959 --> 00:11:52,160
function and the first function can look

00:11:50,399 --> 00:11:53,839
at that and decide oh yes i know that

00:11:52,160 --> 00:11:55,680
or no i don't i'll pass it to the next

00:11:53,839 --> 00:11:57,600
one so sort of gets passed down

00:11:55,680 --> 00:11:59,040
as a as a list so i'm watching the chat

00:11:57,600 --> 00:12:00,079
here what what would flip a wobble do

00:11:59,040 --> 00:12:02,079
you know good question

00:12:00,079 --> 00:12:03,360
someone someone design me an rfc and

00:12:02,079 --> 00:12:04,000
i'll have a look at it by the end of the

00:12:03,360 --> 00:12:07,279
talk

00:12:04,000 --> 00:12:08,720
there's a challenge for you um yeah so

00:12:07,279 --> 00:12:11,920
you have these chained hooks

00:12:08,720 --> 00:12:12,959
um but because they are built in at the

00:12:11,920 --> 00:12:16,079
base mechanism

00:12:12,959 --> 00:12:17,120
of the the pearl parser they can be

00:12:16,079 --> 00:12:19,360
reentrant

00:12:17,120 --> 00:12:20,959
uh so already we're as i said we're now

00:12:19,360 --> 00:12:22,399
a step up from the kinds of things you

00:12:20,959 --> 00:12:24,880
could do with source filters

00:12:22,399 --> 00:12:26,399
because all of a sudden if you if you

00:12:24,880 --> 00:12:28,800
for example write a try block

00:12:26,399 --> 00:12:29,440
and inside the try block you put another

00:12:28,800 --> 00:12:30,959
try

00:12:29,440 --> 00:12:33,200
well that's just fine because that

00:12:30,959 --> 00:12:33,920
that's just more code calling the parser

00:12:33,200 --> 00:12:35,600
again and

00:12:33,920 --> 00:12:38,000
and all is fine so everything everything

00:12:35,600 --> 00:12:39,120
works just nicely

00:12:38,000 --> 00:12:40,959
in order to actually implement one of

00:12:39,120 --> 00:12:42,079
these things you basically write this

00:12:40,959 --> 00:12:45,440
huge

00:12:42,079 --> 00:12:47,600
huge blob of of c code uh where you

00:12:45,440 --> 00:12:49,760
store the current value of the plugin so

00:12:47,600 --> 00:12:52,959
that you can then write a new value in

00:12:49,760 --> 00:12:54,639
and then later on when you when you're

00:12:52,959 --> 00:12:55,920
when your code actually runs you look at

00:12:54,639 --> 00:12:56,399
it and you decide no i don't like that

00:12:55,920 --> 00:13:00,000
thing

00:12:56,399 --> 00:13:02,240
i'll call the old value um well you

00:13:00,000 --> 00:13:03,440
in order to actually implement something

00:13:02,240 --> 00:13:05,519
you have to actually

00:13:03,440 --> 00:13:06,959
look at the keyword that's passed to you

00:13:05,519 --> 00:13:10,720
is its length five

00:13:06,959 --> 00:13:12,800
is it equal to the word h-e-l-l-o

00:13:10,720 --> 00:13:14,000
and if so well i'll run my plug-in

00:13:12,800 --> 00:13:16,480
otherwise i'll just

00:13:14,000 --> 00:13:17,200
call down the chain um there's a lot of

00:13:16,480 --> 00:13:19,279
work there

00:13:17,200 --> 00:13:20,560
and actually this plug-in is a terrible

00:13:19,279 --> 00:13:22,639
plugin because it reacts

00:13:20,560 --> 00:13:25,440
all the time now what you actually want

00:13:22,639 --> 00:13:27,920
to do is look in the hints hash and see

00:13:25,440 --> 00:13:29,360
is the does the hint hash actually have

00:13:27,920 --> 00:13:32,639
a key set for

00:13:29,360 --> 00:13:35,440
my current keyword um

00:13:32,639 --> 00:13:37,200
that then get set in the in you know by

00:13:35,440 --> 00:13:38,880
the import routine or whatever it is

00:13:37,200 --> 00:13:40,160
that enables your syntax

00:13:38,880 --> 00:13:42,560
so there's all of a sudden a lot of

00:13:40,160 --> 00:13:44,240
boilerplate there uh we haven't

00:13:42,560 --> 00:13:45,839
done anything yet we haven't implemented

00:13:44,240 --> 00:13:47,360
our keyword but we've just got all of

00:13:45,839 --> 00:13:47,839
this code that's just kind of sitting

00:13:47,360 --> 00:13:49,760
there and

00:13:47,839 --> 00:13:51,760
that's exactly the same for every single

00:13:49,760 --> 00:13:53,199
module so having written the first one

00:13:51,760 --> 00:13:54,959
of mine all i did for all of the other

00:13:53,199 --> 00:13:56,800
ones is i just copy pasted it

00:13:54,959 --> 00:13:58,480
and renamed bits of it like like there's

00:13:56,800 --> 00:13:59,920
no magic in there at all

00:13:58,480 --> 00:14:03,120
it's all very standard boring

00:13:59,920 --> 00:14:05,199
boilerplate stuff

00:14:03,120 --> 00:14:07,839
we've also got these the lex and the

00:14:05,199 --> 00:14:10,240
parse functions as i mentioned

00:14:07,839 --> 00:14:11,360
so when when the code actually gets

00:14:10,240 --> 00:14:14,079
invoked

00:14:11,360 --> 00:14:15,440
it can it can start pulling more things

00:14:14,079 --> 00:14:17,440
out of the source code

00:14:15,440 --> 00:14:19,120
to actually pass the things that it's

00:14:17,440 --> 00:14:21,199
doing um

00:14:19,120 --> 00:14:22,720
the lexa is this this kind of very low

00:14:21,199 --> 00:14:24,240
level thing it's concerned with the

00:14:22,720 --> 00:14:25,920
individual characters

00:14:24,240 --> 00:14:27,440
making up these little things called

00:14:25,920 --> 00:14:29,440
tokens

00:14:27,440 --> 00:14:31,440
um or sometimes people call them let

00:14:29,440 --> 00:14:33,360
seems hence the word alexa

00:14:31,440 --> 00:14:34,720
and then the parser is the bit that

00:14:33,360 --> 00:14:36,160
actually starts building these

00:14:34,720 --> 00:14:37,519
taking these little building blocks and

00:14:36,160 --> 00:14:38,880
starts building them up into bigger

00:14:37,519 --> 00:14:40,560
things that eventually becomes your

00:14:38,880 --> 00:14:42,240
program

00:14:40,560 --> 00:14:45,360
the actual functions that are available

00:14:42,240 --> 00:14:48,079
in the poll core a very small set

00:14:45,360 --> 00:14:48,480
um as i said you you you're really just

00:14:48,079 --> 00:14:50,240
implem

00:14:48,480 --> 00:14:51,680
you're just interacting with the with

00:14:50,240 --> 00:14:55,760
the current input

00:14:51,680 --> 00:14:58,480
source code as a string basically um

00:14:55,760 --> 00:14:59,760
and all you really get is peek at the

00:14:58,480 --> 00:15:02,880
next character

00:14:59,760 --> 00:15:04,639
or read the next character and there's a

00:15:02,880 --> 00:15:06,079
there's a white space skipping function

00:15:04,639 --> 00:15:09,279
there to to help you

00:15:06,079 --> 00:15:12,240
but really that's kind of it

00:15:09,279 --> 00:15:13,279
um there's very little help from from

00:15:12,240 --> 00:15:16,880
the core

00:15:13,279 --> 00:15:17,600
lecture but the parser is not much

00:15:16,880 --> 00:15:20,959
better

00:15:17,600 --> 00:15:23,279
really um the core parser

00:15:20,959 --> 00:15:24,320
you can in theory get that to do most of

00:15:23,279 --> 00:15:26,320
the work

00:15:24,320 --> 00:15:29,279
it can recognize things like expressions

00:15:26,320 --> 00:15:31,920
and statements and blocks

00:15:29,279 --> 00:15:33,440
by consuming input out of the buffer and

00:15:31,920 --> 00:15:36,160
it returns

00:15:33,440 --> 00:15:38,079
this thing called an op tree um so i

00:15:36,160 --> 00:15:40,160
should probably have a little aside

00:15:38,079 --> 00:15:41,920
to explain what you know what do i mean

00:15:40,160 --> 00:15:46,000
by an op tree

00:15:41,920 --> 00:15:48,720
so inco in in perl code gets compiled

00:15:46,000 --> 00:15:49,040
into tree shaped structures it's called

00:15:48,720 --> 00:15:53,040
op

00:15:49,040 --> 00:15:53,759
trees each each node of that tree is a

00:15:53,040 --> 00:15:55,519
thing called an

00:15:53,759 --> 00:15:56,800
op and we sort of build them up together

00:15:55,519 --> 00:16:00,000
from the little tiny base

00:15:56,800 --> 00:16:02,399
ops into sort of larger ones that form

00:16:00,000 --> 00:16:03,120
individual statements expressions within

00:16:02,399 --> 00:16:04,639
them

00:16:03,120 --> 00:16:06,839
a sequence of expressions becomes a

00:16:04,639 --> 00:16:09,680
whole function

00:16:06,839 --> 00:16:11,440
um it approximately corresponds to the

00:16:09,680 --> 00:16:13,440
written syntax they they don't

00:16:11,440 --> 00:16:14,639
quite in in all cases things like for

00:16:13,440 --> 00:16:17,440
each loops

00:16:14,639 --> 00:16:18,959
um look a bit weird in the optic shape

00:16:17,440 --> 00:16:19,759
as compared to what's written but

00:16:18,959 --> 00:16:21,839
generally

00:16:19,759 --> 00:16:24,240
it's an approximation of the writ syntax

00:16:21,839 --> 00:16:26,320
so you can sort of think of it of a

00:16:24,240 --> 00:16:27,759
like an abstract syntax tree like an ast

00:16:26,320 --> 00:16:29,279
it's not quite an ast

00:16:27,759 --> 00:16:31,519
it's not usable in the same way as an

00:16:29,279 --> 00:16:32,800
ast is but it's kind of the same thing

00:16:31,519 --> 00:16:34,959
if you're familiar with that from other

00:16:32,800 --> 00:16:37,360
languages

00:16:34,959 --> 00:16:39,040
so a little example here so if we were

00:16:37,360 --> 00:16:41,120
to have this statement here my seven

00:16:39,040 --> 00:16:43,279
equals four plus three

00:16:41,120 --> 00:16:45,839
the the compiler looks at that parses

00:16:43,279 --> 00:16:47,759
that builds it up into our tree

00:16:45,839 --> 00:16:49,680
the at the top level that's that's a

00:16:47,759 --> 00:16:51,680
scalar assignment so we have this off

00:16:49,680 --> 00:16:55,279
called s assign

00:16:51,680 --> 00:16:57,680
and within that that's form of an add op

00:16:55,279 --> 00:16:59,680
that itself is formed from this thing

00:16:57,680 --> 00:17:02,880
called pad sv that

00:16:59,680 --> 00:17:03,440
looks for a a variable uh let's put

00:17:02,880 --> 00:17:05,039
variable

00:17:03,440 --> 00:17:08,000
and this const well funnily enough

00:17:05,039 --> 00:17:09,520
that's a constant um

00:17:08,000 --> 00:17:11,199
and then we assign those into another

00:17:09,520 --> 00:17:12,959
paradise feed um

00:17:11,199 --> 00:17:14,160
and so that's that's the kind of data

00:17:12,959 --> 00:17:15,039
structure that you're working with

00:17:14,160 --> 00:17:18,400
inside these

00:17:15,039 --> 00:17:20,640
um inside these custom keyword plugins

00:17:18,400 --> 00:17:21,439
um and they're a very powerful way to

00:17:20,640 --> 00:17:24,160
represent

00:17:21,439 --> 00:17:25,120
the perl source code but trying to build

00:17:24,160 --> 00:17:26,799
one of those

00:17:25,120 --> 00:17:28,720
trying to get one of those out of the

00:17:26,799 --> 00:17:31,360
source code is a bit

00:17:28,720 --> 00:17:33,919
is a bit awkward and also it's again

00:17:31,360 --> 00:17:37,280
quite limited in its ability

00:17:33,919 --> 00:17:37,919
so we have a bunch of functions from the

00:17:37,280 --> 00:17:39,840
parser

00:17:37,919 --> 00:17:41,760
that can sort of help us do this so

00:17:39,840 --> 00:17:44,320
we've got different kinds of expressions

00:17:41,760 --> 00:17:46,480
that basically just relate to where they

00:17:44,320 --> 00:17:48,720
are in precedence order so arith

00:17:46,480 --> 00:17:50,559
an arithmetic expression is a little

00:17:48,720 --> 00:17:50,799
tiny thing separated by pluses and then

00:17:50,559 --> 00:17:52,880
a

00:17:50,799 --> 00:17:53,840
term explorer is a slightly bigger thing

00:17:52,880 --> 00:17:56,160
the distinction is

00:17:53,840 --> 00:17:57,679
is kind of a bit vague and artificial it

00:17:56,160 --> 00:18:00,720
doesn't come up in core pearl

00:17:57,679 --> 00:18:02,080
in pearl syntax it's just there in the

00:18:00,720 --> 00:18:03,840
parser it's a bit weird

00:18:02,080 --> 00:18:05,200
uh list expressions full expressions

00:18:03,840 --> 00:18:05,919
kind of a bit weird they've got

00:18:05,200 --> 00:18:07,679
statements

00:18:05,919 --> 00:18:09,039
got a sequence of statements and we've

00:18:07,679 --> 00:18:11,840
got a block

00:18:09,039 --> 00:18:12,480
and that's kind of it out of the parser

00:18:11,840 --> 00:18:15,039
there's no

00:18:12,480 --> 00:18:16,160
other there's no other things that are

00:18:15,039 --> 00:18:17,760
smaller

00:18:16,160 --> 00:18:20,000
so there's no things like give me

00:18:17,760 --> 00:18:23,200
something that's just a lexical variable

00:18:20,000 --> 00:18:26,640
or give me something that's just a label

00:18:23,200 --> 00:18:28,240
or just a word or anything like that

00:18:26,640 --> 00:18:30,400
so you you've got this kind of problem

00:18:28,240 --> 00:18:32,240
where the lexa functions

00:18:30,400 --> 00:18:34,559
all you can do is take out single

00:18:32,240 --> 00:18:35,919
individual unicode characters

00:18:34,559 --> 00:18:37,440
and they've got these parser functions

00:18:35,919 --> 00:18:38,080
where you can say give me an entire

00:18:37,440 --> 00:18:40,240
block

00:18:38,080 --> 00:18:43,280
or an entire full statement or whatever

00:18:40,240 --> 00:18:44,960
but you haven't got something in between

00:18:43,280 --> 00:18:46,640
and it turns out when you're writing

00:18:44,960 --> 00:18:47,039
syntax plugins a lot of the things you

00:18:46,640 --> 00:18:49,840
want

00:18:47,039 --> 00:18:50,480
are in that kind of medium size that's

00:18:49,840 --> 00:18:53,919
just not

00:18:50,480 --> 00:18:53,919
catered for by the api

00:18:54,440 --> 00:18:58,160
um i mean in brief i'm not really going

00:18:56,640 --> 00:18:59,600
to talk very much about these but just

00:18:58,160 --> 00:19:01,840
to kind of complete the picture

00:18:59,600 --> 00:19:03,200
you have these custom ops which are

00:19:01,840 --> 00:19:04,160
definitely the most powerful and the

00:19:03,200 --> 00:19:07,360
most flexible

00:19:04,160 --> 00:19:09,679
part of this whole trio of pieces um

00:19:07,360 --> 00:19:11,440
they're the only way to get new runtime

00:19:09,679 --> 00:19:14,000
behavior out of your code

00:19:11,440 --> 00:19:14,960
so something like the the boolean module

00:19:14,000 --> 00:19:16,480
keyword boolean

00:19:14,960 --> 00:19:18,240
all that's doing is adding these new

00:19:16,480 --> 00:19:20,320
true and false constants

00:19:18,240 --> 00:19:21,840
um that's no there's no new behavior in

00:19:20,320 --> 00:19:25,200
there there's nothing exciting

00:19:21,840 --> 00:19:26,880
but things like um syntax keyword try

00:19:25,200 --> 00:19:28,559
well that's adding this this try catch

00:19:26,880 --> 00:19:29,360
behavior and catch in particular is kind

00:19:28,559 --> 00:19:32,080
of a new

00:19:29,360 --> 00:19:33,760
thing that pearl doesn't do async awaits

00:19:32,080 --> 00:19:35,919
that's absolutely enormous the weight

00:19:33,760 --> 00:19:37,520
of the actual code for that if you

00:19:35,919 --> 00:19:39,200
consider all of the functions it calls

00:19:37,520 --> 00:19:39,760
and so on there's about 700 lines of

00:19:39,200 --> 00:19:42,160
proper c

00:19:39,760 --> 00:19:43,440
code that runs during runtime so these

00:19:42,160 --> 00:19:44,960
custom ops are

00:19:43,440 --> 00:19:47,919
very much the core of adding the

00:19:44,960 --> 00:19:50,240
behavior to the code

00:19:47,919 --> 00:19:51,440
um they're also the hardest in a way the

00:19:50,240 --> 00:19:52,000
hardest bits to get right there are a

00:19:51,440 --> 00:19:53,440
lot of steps

00:19:52,000 --> 00:19:54,720
to it because you've got to register

00:19:53,440 --> 00:19:56,240
them with the thing and then you've got

00:19:54,720 --> 00:19:57,200
to create the opportunity for it and

00:19:56,240 --> 00:19:58,400
you've got to add all the runtime

00:19:57,200 --> 00:20:02,240
semantics and so on

00:19:58,400 --> 00:20:04,720
um but that's

00:20:02,240 --> 00:20:06,240
that's just part of adding new behavior

00:20:04,720 --> 00:20:07,840
to pearl and that's that's always going

00:20:06,240 --> 00:20:08,720
to be the case that's just that's just

00:20:07,840 --> 00:20:10,240
difficult

00:20:08,720 --> 00:20:11,840
um and i'll pause here for a second

00:20:10,240 --> 00:20:13,760
because i've just seen an interesting

00:20:11,840 --> 00:20:15,200
question on the chat so the question is

00:20:13,760 --> 00:20:16,880
can you register a hook for a keyword

00:20:15,200 --> 00:20:19,760
that already exists in pearl core

00:20:16,880 --> 00:20:20,880
and if you give back control to the core

00:20:19,760 --> 00:20:24,320
if you decide

00:20:20,880 --> 00:20:28,080
that it's not suitable um

00:20:24,320 --> 00:20:30,480
not really um so

00:20:28,080 --> 00:20:31,600
as far as i can remember the the keyword

00:20:30,480 --> 00:20:34,960
hook mechanism

00:20:31,600 --> 00:20:37,360
is only invoked if perl itself doesn't

00:20:34,960 --> 00:20:40,720
recognize the word that you've put there

00:20:37,360 --> 00:20:44,080
so it will never see if or sub

00:20:40,720 --> 00:20:45,840
or use for example because the

00:20:44,080 --> 00:20:48,159
the core parser already knows those

00:20:45,840 --> 00:20:49,600
things but it will see

00:20:48,159 --> 00:20:52,080
you know if you happen to name a

00:20:49,600 --> 00:20:54,400
function i don't know apple

00:20:52,080 --> 00:20:55,200
and then later on you try to call apple

00:20:54,400 --> 00:20:58,799
it will see

00:20:55,200 --> 00:21:02,000
apple for a moment because that's not a

00:20:58,799 --> 00:21:04,159
core token known by pearl

00:21:02,000 --> 00:21:05,840
um but then then your plugin presumably

00:21:04,159 --> 00:21:07,280
doesn't recognize apple either so it

00:21:05,840 --> 00:21:08,559
just gets thrown away and then it goes

00:21:07,280 --> 00:21:08,960
back to the parser and the parser says

00:21:08,559 --> 00:21:10,240
well

00:21:08,960 --> 00:21:11,679
nobody implemented this a special

00:21:10,240 --> 00:21:14,000
keyword oh but it turns out that's a

00:21:11,679 --> 00:21:15,919
function so i'll call that

00:21:14,000 --> 00:21:17,760
so yeah to answer your question you

00:21:15,919 --> 00:21:20,480
can't use a custom keyword plugin

00:21:17,760 --> 00:21:22,000
to make a better for each loop that will

00:21:20,480 --> 00:21:23,600
pull out multiple variables

00:21:22,000 --> 00:21:25,039
because pearl doesn't let you see that

00:21:23,600 --> 00:21:26,799
perl has already taken

00:21:25,039 --> 00:21:28,720
the four each or the four keywords

00:21:26,799 --> 00:21:30,880
that's in it um so you'll never get to

00:21:28,720 --> 00:21:33,919
see that so yes unfortunately you can't

00:21:30,880 --> 00:21:37,679
use custom keywords to implement those

00:21:33,919 --> 00:21:40,640
um so anyway so where's where was i um

00:21:37,679 --> 00:21:41,440
the the limitations of the api so as

00:21:40,640 --> 00:21:43,280
i've said

00:21:41,440 --> 00:21:44,400
there are missing functions there are

00:21:43,280 --> 00:21:45,039
things that you'd like to be able to

00:21:44,400 --> 00:21:49,039
parse

00:21:45,039 --> 00:21:50,799
that you just can't so i kind of came up

00:21:49,039 --> 00:21:51,760
with a solution to this in in a lot of

00:21:50,799 --> 00:21:53,919
my modules

00:21:51,760 --> 00:21:55,200
where i i sort of added a few functions

00:21:53,919 --> 00:21:56,559
in a module and then

00:21:55,200 --> 00:21:58,159
in another module i kind of wanted to

00:21:56,559 --> 00:21:59,919
say one so i started off by just copy

00:21:58,159 --> 00:22:03,360
pasting them around and then eventually

00:21:59,919 --> 00:22:04,799
i came up with a very large file that i

00:22:03,360 --> 00:22:06,880
just copied the entire file

00:22:04,799 --> 00:22:08,880
between all of my modules it's called

00:22:06,880 --> 00:22:10,720
lexa editions

00:22:08,880 --> 00:22:12,320
and i literally just copied that around

00:22:10,720 --> 00:22:13,919
all my modules and whenever i wanted to

00:22:12,320 --> 00:22:15,440
add a new function i just add it and

00:22:13,919 --> 00:22:16,640
kind of copy it around and if i fixed a

00:22:15,440 --> 00:22:17,600
bug i'd have to be able to copy it

00:22:16,640 --> 00:22:19,600
around all of them

00:22:17,600 --> 00:22:21,280
and you know i'm copy pasting code it's

00:22:19,600 --> 00:22:23,360
pretty terrible right i mean

00:22:21,280 --> 00:22:25,760
perhaps perhaps there's a better way we

00:22:23,360 --> 00:22:28,000
can do this

00:22:25,760 --> 00:22:29,440
but some some examples of the kinds of

00:22:28,000 --> 00:22:32,080
things i was adding

00:22:29,440 --> 00:22:33,840
are things like uh well i was told the

00:22:32,080 --> 00:22:36,880
lexa i needed a function to say

00:22:33,840 --> 00:22:38,240
here's a whole string of letters that

00:22:36,880 --> 00:22:41,520
make up a keyword

00:22:38,240 --> 00:22:42,000
and atomically please either consume

00:22:41,520 --> 00:22:44,159
that

00:22:42,000 --> 00:22:46,320
as in that definitely exists in the

00:22:44,159 --> 00:22:48,480
source code so take it and return true

00:22:46,320 --> 00:22:49,600
or if it doesn't exist just return false

00:22:48,480 --> 00:22:51,440
so already

00:22:49,600 --> 00:22:53,200
that kind of very simple behavior of

00:22:51,440 --> 00:22:55,200
does the word match

00:22:53,200 --> 00:22:58,159
appear next in the source code that

00:22:55,200 --> 00:23:01,520
didn't exist in perl i had to add that

00:22:58,159 --> 00:23:03,840
uh scan ident yeah that that looks for

00:23:01,520 --> 00:23:05,440
and eats a sequence of characters that

00:23:03,840 --> 00:23:07,120
implement that stands for like an

00:23:05,440 --> 00:23:08,480
identifier like a package name or a

00:23:07,120 --> 00:23:10,799
function name or something

00:23:08,480 --> 00:23:12,000
so i had to make one of those and i had

00:23:10,799 --> 00:23:15,440
to try very hard

00:23:12,000 --> 00:23:18,240
to implement lexvar to parse the same

00:23:15,440 --> 00:23:19,360
kinds of lexical variables that core

00:23:18,240 --> 00:23:20,559
pearl does

00:23:19,360 --> 00:23:21,679
and already i've got it slightly wrong

00:23:20,559 --> 00:23:23,120
because it turns out the call pile will

00:23:21,679 --> 00:23:24,320
allow you to put a space between the

00:23:23,120 --> 00:23:26,000
dollar and the name

00:23:24,320 --> 00:23:27,520
please don't try it it makes me feel

00:23:26,000 --> 00:23:28,799
very sick but um

00:23:27,520 --> 00:23:31,120
yeah you could put a space between

00:23:28,799 --> 00:23:33,360
dollar space name or variable here

00:23:31,120 --> 00:23:36,480
um i don't my one doesn't pass that and

00:23:33,360 --> 00:23:40,159
i consider that a teacher

00:23:36,480 --> 00:23:41,600
anyhow um i then i then got yes you put

00:23:40,159 --> 00:23:42,720
new lines yes yeah you put all kinds of

00:23:41,600 --> 00:23:44,320
white space in there you could probably

00:23:42,720 --> 00:23:45,520
put a horizontal tab actually as well

00:23:44,320 --> 00:23:47,919
that would that would keep

00:23:45,520 --> 00:23:48,640
that would keep everyone happy um so

00:23:47,919 --> 00:23:50,159
yeah

00:23:48,640 --> 00:23:52,720
and then there's some other functions

00:23:50,159 --> 00:23:55,200
like things to scan for attributes

00:23:52,720 --> 00:23:56,559
of functions um and i've got a whole

00:23:55,200 --> 00:23:57,760
load of functions i'm not going to list

00:23:56,559 --> 00:23:59,440
them all here because there's about 20

00:23:57,760 --> 00:24:00,960
of them but that's a that kind of gives

00:23:59,440 --> 00:24:04,320
you a flavor of the kinds of things that

00:24:00,960 --> 00:24:08,159
i found it necessary to add

00:24:04,320 --> 00:24:11,600
um so just as a brief example of how

00:24:08,159 --> 00:24:13,120
one of these things might run so

00:24:11,600 --> 00:24:15,440
if for example we were to take this

00:24:13,120 --> 00:24:18,559
module it would list keywords

00:24:15,440 --> 00:24:19,679
so the perl parser will handle you know

00:24:18,559 --> 00:24:21,679
the use statement

00:24:19,679 --> 00:24:23,120
it'll get as far as my dollar variable

00:24:21,679 --> 00:24:24,320
equals

00:24:23,120 --> 00:24:26,000
and then it gets to a point where it

00:24:24,320 --> 00:24:26,880
looks at that next word any and it says

00:24:26,000 --> 00:24:29,840
well

00:24:26,880 --> 00:24:30,799
i don't understand what that word means

00:24:29,840 --> 00:24:33,440
hey

00:24:30,799 --> 00:24:34,240
keyword plugins do you do you understand

00:24:33,440 --> 00:24:37,520
that

00:24:34,240 --> 00:24:39,520
and the plugins between them

00:24:37,520 --> 00:24:41,840
all take a look at that and they decide

00:24:39,520 --> 00:24:44,000
yeah i can handle that

00:24:41,840 --> 00:24:45,360
and then i will and then whichever

00:24:44,000 --> 00:24:48,080
module

00:24:45,360 --> 00:24:48,880
was decided it was going to handle that

00:24:48,080 --> 00:24:51,120
we'll eat

00:24:48,880 --> 00:24:52,960
all of the syntax that it wants to have

00:24:51,120 --> 00:24:54,080
in in whatever way it does by calling

00:24:52,960 --> 00:24:56,240
code

00:24:54,080 --> 00:24:57,840
and consume all of that and then hands

00:24:56,240 --> 00:24:59,760
control back to pearl and pearl will

00:24:57,840 --> 00:25:02,400
kind of consume that semicolon it'll

00:24:59,760 --> 00:25:04,480
it'll carry on doing its thing so your

00:25:02,400 --> 00:25:07,760
function gets invoked and has to do

00:25:04,480 --> 00:25:09,440
everything all of the work because at

00:25:07,760 --> 00:25:12,960
the end of the day this thing is an api

00:25:09,440 --> 00:25:16,240
it's a set of functions to call

00:25:12,960 --> 00:25:19,600
the whatever kind of grammar is is

00:25:16,240 --> 00:25:22,720
in cut is um accepted by your code

00:25:19,600 --> 00:25:24,159
is kind of very subtly hidden in the

00:25:22,720 --> 00:25:27,679
runtime behavior

00:25:24,159 --> 00:25:29,600
of that code it's not explicitly

00:25:27,679 --> 00:25:31,360
it's not explicitly written anywhere

00:25:29,600 --> 00:25:33,520
it's just kind of

00:25:31,360 --> 00:25:34,559
emergent as a side effect of the kinds

00:25:33,520 --> 00:25:37,279
of things that

00:25:34,559 --> 00:25:38,960
your code is calling on the lexa that

00:25:37,279 --> 00:25:40,640
means we don't get static information

00:25:38,960 --> 00:25:41,279
access for example so it makes static

00:25:40,640 --> 00:25:43,600
parsing

00:25:41,279 --> 00:25:45,120
in in things like you know code editors

00:25:43,600 --> 00:25:47,360
syntax highlighters whatever just

00:25:45,120 --> 00:25:50,640
basically impossible it's not gonna work

00:25:47,360 --> 00:25:53,440
um and it's also very easy to make

00:25:50,640 --> 00:25:54,000
totally nonsensical grammars for example

00:25:53,440 --> 00:25:56,080
nothing

00:25:54,000 --> 00:25:58,320
in the api stops you passing a thing

00:25:56,080 --> 00:25:59,679
that looks like this

00:25:58,320 --> 00:26:01,440
where we have a keyword and then a

00:25:59,679 --> 00:26:03,520
package name and then an open brace

00:26:01,440 --> 00:26:06,000
and then an expression and then an open

00:26:03,520 --> 00:26:07,360
square bracket

00:26:06,000 --> 00:26:09,679
you could write code for that that would

00:26:07,360 --> 00:26:11,360
be absolutely fine by pearl

00:26:09,679 --> 00:26:12,960
i would shoot you for it your co-workers

00:26:11,360 --> 00:26:14,159
would shoot you for it but carl doesn't

00:26:12,960 --> 00:26:16,559
care

00:26:14,159 --> 00:26:18,080
um and that kind of thing is not very

00:26:16,559 --> 00:26:20,480
nice because it it

00:26:18,080 --> 00:26:21,600
it's kind of too powerful in a way it's

00:26:20,480 --> 00:26:24,240
so flexible

00:26:21,600 --> 00:26:27,200
that it's easy to make something wrong

00:26:24,240 --> 00:26:27,200
and we don't like that

00:26:27,760 --> 00:26:31,760
so as i've said these things have seen

00:26:30,080 --> 00:26:35,039
very limited use so far

00:26:31,760 --> 00:26:36,799
um pretty much i i seem to be pretty

00:26:35,039 --> 00:26:38,400
much the only person who's actually

00:26:36,799 --> 00:26:41,120
writing things with this with this

00:26:38,400 --> 00:26:42,799
keyword plug-in mechanism

00:26:41,120 --> 00:26:45,200
uh which is a shame and i think we need

00:26:42,799 --> 00:26:46,880
to do something better

00:26:45,200 --> 00:26:48,240
but we have the perfect opportunity to

00:26:46,880 --> 00:26:51,039
do something better

00:26:48,240 --> 00:26:52,400
because nobody else is writing any of

00:26:51,039 --> 00:26:55,120
these things so i

00:26:52,400 --> 00:26:55,440
kind of felt that i had can't blanch as

00:26:55,120 --> 00:26:58,480
a

00:26:55,440 --> 00:27:01,360
as a word to just kind of do what i like

00:26:58,480 --> 00:27:02,080
and come up with something nicer so i

00:27:01,360 --> 00:27:04,159
did

00:27:02,080 --> 00:27:05,520
and i created this thing called xs pass

00:27:04,159 --> 00:27:08,559
keyword

00:27:05,520 --> 00:27:10,480
hs pass keyword is a cpan module it's a

00:27:08,559 --> 00:27:12,720
it's an access level helper module

00:27:10,480 --> 00:27:13,760
so it's a module and you load it you

00:27:12,720 --> 00:27:14,640
don't actually get any new pearl

00:27:13,760 --> 00:27:16,559
functions

00:27:14,640 --> 00:27:18,159
you get a lot of new crazy things at the

00:27:16,559 --> 00:27:21,360
xs level that helps

00:27:18,159 --> 00:27:23,120
exit other authors write code

00:27:21,360 --> 00:27:24,880
so it's a module that you'd only be

00:27:23,120 --> 00:27:27,520
using if you were writing

00:27:24,880 --> 00:27:28,880
an xs module so don't expect to find

00:27:27,520 --> 00:27:31,440
code in there because you won't

00:27:28,880 --> 00:27:32,320
pull code in there but what access pass

00:27:31,440 --> 00:27:35,120
keyword does

00:27:32,320 --> 00:27:36,480
is it takes over all of the uh the

00:27:35,120 --> 00:27:38,240
parsing side

00:27:36,480 --> 00:27:40,080
out of your keyword plugin so you don't

00:27:38,240 --> 00:27:43,679
need to worry about any of the parsing

00:27:40,080 --> 00:27:46,000
from your keyword plugin you still

00:27:43,679 --> 00:27:47,600
have to build your op tree and you still

00:27:46,000 --> 00:27:49,200
have to actually implement the runtime

00:27:47,600 --> 00:27:50,880
semantics

00:27:49,200 --> 00:27:52,240
so this is not a this is not a truly

00:27:50,880 --> 00:27:55,360
magical mechanism for

00:27:52,240 --> 00:27:55,679
creating new keywords it's just to help

00:27:55,360 --> 00:27:57,919
you

00:27:55,679 --> 00:27:59,120
parse them so you still have to

00:27:57,919 --> 00:27:59,760
understand what not true is you still

00:27:59,120 --> 00:28:01,360
have to

00:27:59,760 --> 00:28:04,640
work out how to implement your semantics

00:28:01,360 --> 00:28:04,640
you don't have to worry about part of it

00:28:05,039 --> 00:28:09,120
so this module works as kind of a

00:28:07,360 --> 00:28:11,279
registry of keywords

00:28:09,120 --> 00:28:12,880
if you want to implement a new keyword

00:28:11,279 --> 00:28:15,120
you you register it

00:28:12,880 --> 00:28:16,320
with xs pass keyword and you provide a

00:28:15,120 --> 00:28:19,600
name

00:28:16,320 --> 00:28:20,880
and the the i call it the permit key the

00:28:19,600 --> 00:28:22,880
the name that we're going to look up in

00:28:20,880 --> 00:28:25,039
the hint hash to see whether or not this

00:28:22,880 --> 00:28:27,200
syntax is enabled

00:28:25,039 --> 00:28:29,200
you have to supply a list of pieces and

00:28:27,200 --> 00:28:32,240
i will explain what those pieces are

00:28:29,200 --> 00:28:34,080
in a moment and you also have to supply

00:28:32,240 --> 00:28:35,440
your obtree building function because as

00:28:34,080 --> 00:28:37,360
i said i'm not handling

00:28:35,440 --> 00:28:39,200
the op tree building that that's your

00:28:37,360 --> 00:28:41,520
that's your job all we're doing is the

00:28:39,200 --> 00:28:44,960
parsing

00:28:41,520 --> 00:28:46,480
um sorry there's another exciting

00:28:44,960 --> 00:28:47,679
question nicholas has so many exciting

00:28:46,480 --> 00:28:48,240
questions you're starting to think that

00:28:47,679 --> 00:28:50,799
xs

00:28:48,240 --> 00:28:53,200
the syntax keyword match is containing

00:28:50,799 --> 00:28:55,039
commonplace to core

00:28:53,200 --> 00:28:56,799
no i haven't i haven't copy pasted any

00:28:55,039 --> 00:28:58,159
any core code around no i've just

00:28:56,799 --> 00:28:59,520
written new code just using the

00:28:58,159 --> 00:29:01,440
mechanisms that are already there

00:28:59,520 --> 00:29:03,279
yeah yeah there's no there's no there is

00:29:01,440 --> 00:29:04,640
some crazy copying of core stuff but

00:29:03,279 --> 00:29:07,440
i'll get on to that later

00:29:04,640 --> 00:29:09,440
um but that's that's only because core

00:29:07,440 --> 00:29:12,799
forgot to provide something good anyway

00:29:09,440 --> 00:29:16,480
um so how access past keyboard works

00:29:12,799 --> 00:29:19,039
we using the same example as from before

00:29:16,480 --> 00:29:21,679
so again perl is going to get up up

00:29:19,039 --> 00:29:24,159
until that word any

00:29:21,679 --> 00:29:24,960
and it's going to then hand that down to

00:29:24,159 --> 00:29:28,399
the

00:29:24,960 --> 00:29:30,559
the keyword plug-in chain but the only

00:29:28,399 --> 00:29:32,559
plug-in that actually exists in that

00:29:30,559 --> 00:29:33,919
chain now is xs pass keyword because ss

00:29:32,559 --> 00:29:34,720
pass keyword has now taken over the

00:29:33,919 --> 00:29:36,640
whole process

00:29:34,720 --> 00:29:38,880
so it says no don't worry i'll deal with

00:29:36,640 --> 00:29:40,880
this access pass keyword looks at its

00:29:38,880 --> 00:29:43,279
set of registrations and it says now

00:29:40,880 --> 00:29:44,720
who is handling this piece of code this

00:29:43,279 --> 00:29:47,919
this keyword

00:29:44,720 --> 00:29:48,960
um let's look up what they've said as

00:29:47,919 --> 00:29:52,480
the grammar

00:29:48,960 --> 00:29:53,440
and their build function and then i will

00:29:52,480 --> 00:29:56,480
pass

00:29:53,440 --> 00:29:57,520
all of the incoming text into little

00:29:56,480 --> 00:29:58,720
pieces

00:29:57,520 --> 00:30:01,760
according to the grammar that you've

00:29:58,720 --> 00:30:02,399
specified and only then will i call your

00:30:01,760 --> 00:30:04,399
bill your

00:30:02,399 --> 00:30:06,399
your building function with those

00:30:04,399 --> 00:30:08,320
pre-parsed pieces

00:30:06,399 --> 00:30:09,600
and and hand you those so you can do

00:30:08,320 --> 00:30:11,120
whatever you like so you're still going

00:30:09,600 --> 00:30:13,840
to build your object but you don't have

00:30:11,120 --> 00:30:13,840
to worry about parsing it

00:30:14,000 --> 00:30:17,679
so here's an example from actually

00:30:15,600 --> 00:30:20,720
implementing it so

00:30:17,679 --> 00:30:22,480
for example we see down at the bottom

00:30:20,720 --> 00:30:24,240
here in the in the boot section

00:30:22,480 --> 00:30:25,600
we obviously have to register the

00:30:24,240 --> 00:30:28,640
keyword so we say yep

00:30:25,600 --> 00:30:31,840
we're doing the keyword any and

00:30:28,640 --> 00:30:33,360
we've given it a a a key in the hint

00:30:31,840 --> 00:30:34,880
hash

00:30:33,360 --> 00:30:37,279
which then means that in in the poll

00:30:34,880 --> 00:30:39,039
code in the import sub we just

00:30:37,279 --> 00:30:41,600
turn that to turn that thing on what do

00:30:39,039 --> 00:30:44,000
you mean typo i've got no typo

00:30:41,600 --> 00:30:45,919
um yeah we just turn that that key on in

00:30:44,000 --> 00:30:49,919
the hint hash and it enables

00:30:45,919 --> 00:30:51,039
that that keyword in this lexical scope

00:30:49,919 --> 00:30:53,279
um

00:30:51,039 --> 00:30:54,720
so how this runs for example in more

00:30:53,279 --> 00:30:56,559
detail so here is the

00:30:54,720 --> 00:30:58,720
here is the registration for the any

00:30:56,559 --> 00:31:01,919
keyword

00:30:58,720 --> 00:31:04,320
and so as i mentioned earlier we

00:31:01,919 --> 00:31:06,399
we give it a set of pieces so this

00:31:04,320 --> 00:31:09,360
keyword is saying it wants two pieces

00:31:06,399 --> 00:31:09,840
the first keyword is a block that it

00:31:09,360 --> 00:31:11,279
wants

00:31:09,840 --> 00:31:14,240
and and by the way that block better

00:31:11,279 --> 00:31:17,360
return a scalar context

00:31:14,240 --> 00:31:18,559
so it'll pass out to block and also i

00:31:17,360 --> 00:31:21,600
want a list expression

00:31:18,559 --> 00:31:23,200
oh and i want that in list context and

00:31:21,600 --> 00:31:23,600
so now all of a sudden by just putting

00:31:23,200 --> 00:31:26,240
those

00:31:23,600 --> 00:31:27,760
those two words down here we've now told

00:31:26,240 --> 00:31:29,440
excess pass keywords

00:31:27,760 --> 00:31:31,600
everything that it needs to know to

00:31:29,440 --> 00:31:33,120
parse our keyword

00:31:31,600 --> 00:31:34,640
we haven't had to talk to the parser

00:31:33,120 --> 00:31:35,360
ourselves or the lecture or anything

00:31:34,640 --> 00:31:37,360
we've just said

00:31:35,360 --> 00:31:39,919
i want a block and a list expression

00:31:37,360 --> 00:31:41,919
give me those

00:31:39,919 --> 00:31:43,840
and then those eventually turn up in the

00:31:41,919 --> 00:31:45,360
in the in the arbitrary building

00:31:43,840 --> 00:31:47,039
function here

00:31:45,360 --> 00:31:48,559
has those arguments so the first

00:31:47,039 --> 00:31:50,080
argument is the block the second

00:31:48,559 --> 00:31:51,440
argument is the list expression

00:31:50,080 --> 00:31:53,120
and this function will have to go off

00:31:51,440 --> 00:31:53,919
and build its op tree in much the same

00:31:53,120 --> 00:31:56,000
as

00:31:53,919 --> 00:31:57,760
the older style of keyword plugins would

00:31:56,000 --> 00:31:59,519
have to do but we haven't had to worry

00:31:57,760 --> 00:32:00,000
about the parsing at all that's all been

00:31:59,519 --> 00:32:02,399
handled

00:32:00,000 --> 00:32:02,399
for us

00:32:11,039 --> 00:32:18,000
so as i said one syntax item

00:32:14,640 --> 00:32:19,600
is called a piece so what kind of pieces

00:32:18,000 --> 00:32:22,080
have we got well we've already seen

00:32:19,600 --> 00:32:24,080
for example we've got these little whips

00:32:22,080 --> 00:32:27,200
so we've already seen we have

00:32:24,080 --> 00:32:28,320
blocks and we have list expressions

00:32:27,200 --> 00:32:30,080
there's a whole bunch of other things

00:32:28,320 --> 00:32:31,519
that we can pass as well so there are

00:32:30,080 --> 00:32:35,279
there are things like

00:32:31,519 --> 00:32:36,799
uh term expressions so um

00:32:35,279 --> 00:32:38,480
syntax keyword match for example uses

00:32:36,799 --> 00:32:40,640
those in some various places

00:32:38,480 --> 00:32:43,039
uh we've also got these literal things

00:32:40,640 --> 00:32:46,559
so you can you can expect a literal

00:32:43,039 --> 00:32:49,039
uh word case or a literal colon

00:32:46,559 --> 00:32:49,840
now very specifically not given the

00:32:49,039 --> 00:32:52,480
ability

00:32:49,840 --> 00:32:53,760
to to just wait for any kind of literal

00:32:52,480 --> 00:32:57,200
character

00:32:53,760 --> 00:32:59,919
so you cannot just say i want a literal

00:32:57,200 --> 00:33:01,120
open parenthesis please because if i

00:32:59,919 --> 00:33:03,200
gave you that power

00:33:01,120 --> 00:33:05,279
you would probably get it wrong and you

00:33:03,200 --> 00:33:06,880
would end up making some kind of grammar

00:33:05,279 --> 00:33:11,840
that didn't make sense because its

00:33:06,880 --> 00:33:11,840
parentheses weren't balanced

00:33:12,320 --> 00:33:16,960
we have things like a choice um that's

00:33:14,960 --> 00:33:19,440
kind of a little bit like a regex

00:33:16,960 --> 00:33:20,399
alternation thing where you say well i

00:33:19,440 --> 00:33:21,919
want that thing

00:33:20,399 --> 00:33:24,480
all this other thing all this other

00:33:21,919 --> 00:33:25,360
thing so syntax keyword match basically

00:33:24,480 --> 00:33:28,000
just says it wants

00:33:25,360 --> 00:33:28,960
uh to find these various operators here

00:33:28,000 --> 00:33:30,720
um

00:33:28,960 --> 00:33:32,320
i said i'm not giving you the power to

00:33:30,720 --> 00:33:33,519
have parentheses but what i am

00:33:32,320 --> 00:33:35,519
giving you is this thing called a

00:33:33,519 --> 00:33:38,000
parenthesis scope

00:33:35,519 --> 00:33:39,360
so you can say i want a scope with

00:33:38,000 --> 00:33:41,279
parentheses around it

00:33:39,360 --> 00:33:42,720
and inside it i want the term expression

00:33:41,279 --> 00:33:43,360
then a colon then a choice of these

00:33:42,720 --> 00:33:44,960
things

00:33:43,360 --> 00:33:46,720
um and all of that is going to be

00:33:44,960 --> 00:33:49,120
surrounded by parentheses

00:33:46,720 --> 00:33:50,799
so it means that you cannot forget to

00:33:49,120 --> 00:33:51,360
wait for the closed parenthesis at the

00:33:50,799 --> 00:33:52,720
end

00:33:51,360 --> 00:33:54,399
it just it just kind of happens

00:33:52,720 --> 00:33:56,000
automatically for you there's some nice

00:33:54,399 --> 00:33:57,760
little magic there to just say

00:33:56,000 --> 00:34:00,240
these things with parentheses around

00:33:57,760 --> 00:34:00,240
them please

00:34:01,120 --> 00:34:08,240
um now i i wouldn't bother to put the

00:34:06,080 --> 00:34:10,159
entire source code of the previous

00:34:08,240 --> 00:34:11,760
version of syntax keyword match on the

00:34:10,159 --> 00:34:13,760
screen because it's absolutely enormous

00:34:11,760 --> 00:34:15,599
it's about 200 lines to pass

00:34:13,760 --> 00:34:18,720
all of that whereas this thing here

00:34:15,599 --> 00:34:20,639
that's i think that's about 20 lines

00:34:18,720 --> 00:34:22,079
that is that is literally copy pasted

00:34:20,639 --> 00:34:25,359
straight out of the xs file

00:34:22,079 --> 00:34:26,320
that is the entire grammar of syntax

00:34:25,359 --> 00:34:29,280
keyword match

00:34:26,320 --> 00:34:31,280
that there perfectly describes exactly

00:34:29,280 --> 00:34:33,200
what it passes

00:34:31,280 --> 00:34:34,879
that happens to be a piece of c code

00:34:33,200 --> 00:34:37,280
that gets run by the perl interpreter

00:34:34,879 --> 00:34:38,159
but you could just take that as

00:34:37,280 --> 00:34:39,280
information

00:34:38,159 --> 00:34:41,280
because it's just declarative

00:34:39,280 --> 00:34:41,919
information and you could throw that

00:34:41,280 --> 00:34:44,159
into

00:34:41,919 --> 00:34:45,679
your code editor or syntax highlighting

00:34:44,159 --> 00:34:46,720
mechanisms or kind of whatever you can

00:34:45,679 --> 00:34:48,560
do whatever you like with that

00:34:46,720 --> 00:34:50,800
because that's just information that

00:34:48,560 --> 00:34:53,119
could be reused in other places

00:34:50,800 --> 00:34:54,320
to to give other tools the ability to

00:34:53,119 --> 00:34:58,160
perfectly parse

00:34:54,320 --> 00:34:59,119
this code again it's not going to

00:34:58,160 --> 00:35:01,040
implement the code

00:34:59,119 --> 00:35:02,240
but most most other things that pass the

00:35:01,040 --> 00:35:03,680
code don't need to worry about the

00:35:02,240 --> 00:35:04,240
runtime semantics they just want to

00:35:03,680 --> 00:35:07,280
worry about

00:35:04,240 --> 00:35:10,160
parsing it um

00:35:07,280 --> 00:35:11,839
yes yes all right so you can put abigail

00:35:10,160 --> 00:35:14,480
is trolling me here abigail says oh

00:35:11,839 --> 00:35:16,079
what about spk literal with a quote uh

00:35:14,480 --> 00:35:17,760
with a with a parenthesis in quotes i

00:35:16,079 --> 00:35:21,040
mean yes you could do that and

00:35:17,760 --> 00:35:23,280
and okay so i haven't made it impossible

00:35:21,040 --> 00:35:24,560
to make silly grammars but you have to

00:35:23,280 --> 00:35:26,800
go out of your way

00:35:24,560 --> 00:35:27,760
to do something silly like that so yeah

00:35:26,800 --> 00:35:29,040
don't

00:35:27,760 --> 00:35:30,720
don't do that i mean i could have it

00:35:29,040 --> 00:35:31,760
check for those but uh but i currently

00:35:30,720 --> 00:35:33,520
don't

00:35:31,760 --> 00:35:35,520
um yeah it's always advocate of trying

00:35:33,520 --> 00:35:39,359
to break things i know right

00:35:35,520 --> 00:35:42,079
right um so that's all well and good

00:35:39,359 --> 00:35:44,720
but a major problem that still exists

00:35:42,079 --> 00:35:47,760
here is that plugins can't cooperate

00:35:44,720 --> 00:35:48,000
now what do i mean by that so um i have

00:35:47,760 --> 00:35:49,599
the

00:35:48,000 --> 00:35:51,359
as i said i have this this module called

00:35:49,599 --> 00:35:51,760
future i think await and that allows you

00:35:51,359 --> 00:35:54,320
to create

00:35:51,760 --> 00:35:55,839
async subs so you put the word async in

00:35:54,320 --> 00:35:58,000
front of yourself and now you've got

00:35:55,839 --> 00:36:00,160
this this wonderful async code that you

00:35:58,000 --> 00:36:02,480
can you can put a weight expressions in

00:36:00,160 --> 00:36:04,000
and we have object pad and object pad is

00:36:02,480 --> 00:36:06,720
very nice it allows you to to write

00:36:04,000 --> 00:36:08,880
methods using the method keyword

00:36:06,720 --> 00:36:09,760
and so inside method you have lexical

00:36:08,880 --> 00:36:11,359
variables

00:36:09,760 --> 00:36:13,040
that correspond to all of the object

00:36:11,359 --> 00:36:14,400
slots and you've also got the dollar

00:36:13,040 --> 00:36:15,760
self and the dollar class

00:36:14,400 --> 00:36:17,680
and you've got a bunch of nice stuff in

00:36:15,760 --> 00:36:18,640
there um so you're thinking it'd be

00:36:17,680 --> 00:36:21,280
really nice

00:36:18,640 --> 00:36:23,599
to be able to do async method the

00:36:21,280 --> 00:36:24,839
problem is you can't

00:36:23,599 --> 00:36:26,880
or at least not with this current

00:36:24,839 --> 00:36:29,119
mechanism

00:36:26,880 --> 00:36:31,040
so i came up with another mechanism

00:36:29,119 --> 00:36:33,119
called xspars sub like

00:36:31,040 --> 00:36:34,240
um and actually i wrote that before i

00:36:33,119 --> 00:36:36,720
wrote the keyword because i

00:36:34,240 --> 00:36:38,480
needed this whereas keyword keyword just

00:36:36,720 --> 00:36:40,480
basically makes things a lot nicer but

00:36:38,480 --> 00:36:42,640
excess powers sub like i literally had

00:36:40,480 --> 00:36:44,960
to make to make something possible

00:36:42,640 --> 00:36:46,800
it's again it's a registry of keywords

00:36:44,960 --> 00:36:48,320
each one is provided in it as a set of

00:36:46,800 --> 00:36:50,480
hooks

00:36:48,320 --> 00:36:51,359
and those hooks are all called various

00:36:50,480 --> 00:36:55,359
parts

00:36:51,359 --> 00:36:57,200
of calling sub of parsing a sub

00:36:55,359 --> 00:36:59,200
because it as i said earlier it turns

00:36:57,200 --> 00:37:01,119
out that the core pearl

00:36:59,200 --> 00:37:02,720
it gives you the lexa functions so you

00:37:01,119 --> 00:37:05,760
can peck away at

00:37:02,720 --> 00:37:08,320
single individual characters or

00:37:05,760 --> 00:37:08,960
you can call the parser and pass huge

00:37:08,320 --> 00:37:11,359
things

00:37:08,960 --> 00:37:12,800
but there's no middle granularity there

00:37:11,359 --> 00:37:15,520
you can't say

00:37:12,800 --> 00:37:16,880
i kind of want to pass a sub but but

00:37:15,520 --> 00:37:18,400
interrupt me

00:37:16,880 --> 00:37:20,960
just at this point because i've got

00:37:18,400 --> 00:37:22,960
something special to do

00:37:20,960 --> 00:37:24,560
so i have a holiday hook functions that

00:37:22,960 --> 00:37:27,200
are specifically designed

00:37:24,560 --> 00:37:28,240
to be able to compose behaviors together

00:37:27,200 --> 00:37:32,000
and allow multiple

00:37:28,240 --> 00:37:33,119
modules to cooperate to pass a sub um

00:37:32,000 --> 00:37:34,240
so i'm going to try and go through this

00:37:33,119 --> 00:37:35,680
a little bit quickly because there's a

00:37:34,240 --> 00:37:37,119
lot of steps you don't have to worry

00:37:35,680 --> 00:37:38,560
about all of these steps this is just a

00:37:37,119 --> 00:37:42,480
brief example

00:37:38,560 --> 00:37:43,200
so object pad has a whole bunch of these

00:37:42,480 --> 00:37:45,440
steps

00:37:43,200 --> 00:37:48,880
it's actually implementing all of them

00:37:45,440 --> 00:37:48,880
um here they all are

00:37:49,040 --> 00:37:52,960
so how that works well pearl gets as far

00:37:51,599 --> 00:37:55,200
as the method keyword

00:37:52,960 --> 00:37:56,960
and then invokes all of the magic and

00:37:55,200 --> 00:37:59,680
the whole magic starts

00:37:56,960 --> 00:38:01,359
and then excess piles sub like is now

00:37:59,680 --> 00:38:02,720
taking over and it says right

00:38:01,359 --> 00:38:04,400
here's a thing that's that's a bit like

00:38:02,720 --> 00:38:06,160
a sub um

00:38:04,400 --> 00:38:07,760
before we start do you want to do

00:38:06,160 --> 00:38:09,280
anything um

00:38:07,760 --> 00:38:10,880
because it turns out clickpad does need

00:38:09,280 --> 00:38:13,200
to do something uh

00:38:10,880 --> 00:38:14,720
i'm then going to pass the name i'm

00:38:13,200 --> 00:38:16,640
going to see do we have any attributes

00:38:14,720 --> 00:38:19,920
on the sub

00:38:16,640 --> 00:38:21,520
within about to start the block do you

00:38:19,920 --> 00:38:22,160
want to do anything like add lexical

00:38:21,520 --> 00:38:23,920
variables

00:38:22,160 --> 00:38:25,359
dot dot maybe because you want dollar

00:38:23,920 --> 00:38:28,480
self okay you go do that

00:38:25,359 --> 00:38:30,400
right i'll go and pass the code right

00:38:28,480 --> 00:38:32,560
i'm about to finish the block do you

00:38:30,400 --> 00:38:33,599
want to do anything such as adjust the

00:38:32,560 --> 00:38:36,400
obtree

00:38:33,599 --> 00:38:38,079
do go do that now okay i've done that

00:38:36,400 --> 00:38:40,320
i've now finished pausing

00:38:38,079 --> 00:38:42,160
here's your new cv do you want to do

00:38:40,320 --> 00:38:45,520
anything with it

00:38:42,160 --> 00:38:48,400
so all the time the parser is

00:38:45,520 --> 00:38:50,160
piles sub-like is doing all of this this

00:38:48,400 --> 00:38:52,400
parsing but telling you by the way did

00:38:50,160 --> 00:38:55,599
you want to do something else

00:38:52,400 --> 00:38:56,640
similarly um futuristic await when it

00:38:55,599 --> 00:39:00,320
runs this

00:38:56,640 --> 00:39:03,440
it uh has a whole bunch of these hooks

00:39:00,320 --> 00:39:04,480
that will run at various times which

00:39:03,440 --> 00:39:08,160
means that when

00:39:04,480 --> 00:39:09,119
we uh put both together to do async

00:39:08,160 --> 00:39:11,920
method

00:39:09,119 --> 00:39:12,320
so the async works futurising kuwait

00:39:11,920 --> 00:39:14,640
says

00:39:12,320 --> 00:39:15,760
yep i recognize that as a sub-like thing

00:39:14,640 --> 00:39:18,720
here are some hooks

00:39:15,760 --> 00:39:20,560
carry on and then we go method oh that's

00:39:18,720 --> 00:39:21,119
a sub-like keyword i know how to deal

00:39:20,560 --> 00:39:23,119
with that

00:39:21,119 --> 00:39:25,680
i've got some hooks over here i've now

00:39:23,119 --> 00:39:27,440
got two sets of hooks

00:39:25,680 --> 00:39:30,720
which means that when i start passing

00:39:27,440 --> 00:39:34,240
through this i can suddenly run

00:39:30,720 --> 00:39:35,920
both hooks so feature i think a weight

00:39:34,240 --> 00:39:40,079
gets a look at the block

00:39:35,920 --> 00:39:42,480
and object pad gets to look at the block

00:39:40,079 --> 00:39:44,560
and then it gets to run at the end and

00:39:42,480 --> 00:39:48,160
then it gets to have a look at the cv

00:39:44,560 --> 00:39:48,160
both modules get to cooperate

00:39:48,400 --> 00:39:53,359
so that's a really cool mechanism so

00:39:50,800 --> 00:39:56,800
where do i want to go next with this

00:39:53,359 --> 00:39:58,240
i want to add some infix plugins

00:39:56,800 --> 00:40:00,000
i'm going to wait there for a second for

00:39:58,240 --> 00:40:01,839
people to gasp

00:40:00,000 --> 00:40:03,040
uh i want tighter integration between

00:40:01,839 --> 00:40:05,280
these modules because

00:40:03,040 --> 00:40:07,440
as we've seen there are some mechanisms

00:40:05,280 --> 00:40:09,520
here but we could do a lot better

00:40:07,440 --> 00:40:11,440
i would like oh there we are people are

00:40:09,520 --> 00:40:14,400
now gasping on the chat good thank you

00:40:11,440 --> 00:40:15,760
um i would like automatic d-pass support

00:40:14,400 --> 00:40:19,280
gonna be hard in general but

00:40:15,760 --> 00:40:22,800
i've got a few places um so

00:40:19,280 --> 00:40:24,560
in fix now on my

00:40:22,800 --> 00:40:25,839
branch i've got a i've got a branch of

00:40:24,560 --> 00:40:28,880
fleet pearl called

00:40:25,839 --> 00:40:30,560
infix plugin hints in the name um

00:40:28,880 --> 00:40:33,440
in which i've written this module xs

00:40:30,560 --> 00:40:33,440
powers infix

00:40:33,839 --> 00:40:38,160
which allows you which which allows

00:40:36,960 --> 00:40:41,040
infix parsing

00:40:38,160 --> 00:40:42,400
of infix modules uh infix operators and

00:40:41,040 --> 00:40:45,040
i very much want this module

00:40:42,400 --> 00:40:46,079
to be the user facing api so i've kind

00:40:45,040 --> 00:40:47,839
of not documented

00:40:46,079 --> 00:40:50,319
plmfix plugin it's just it's part of the

00:40:47,839 --> 00:40:52,640
mechanism my intention is to ship

00:40:50,319 --> 00:40:53,760
access powers pars infix as a core

00:40:52,640 --> 00:40:55,839
module and say

00:40:53,760 --> 00:40:57,440
you should be using this module to

00:40:55,839 --> 00:40:58,800
interact with the core perl

00:40:57,440 --> 00:41:00,480
because that gives us a lot of ability

00:40:58,800 --> 00:41:01,839
to fiddle with core pearl

00:41:00,480 --> 00:41:03,839
on the inside doesn't matter as long as

00:41:01,839 --> 00:41:05,839
we keep that module working if you just

00:41:03,839 --> 00:41:06,880
talk to this module that's how you do it

00:41:05,839 --> 00:41:08,560
how to do it

00:41:06,880 --> 00:41:10,960
because it very easily allows things

00:41:08,560 --> 00:41:11,680
like the equ operator which i talked

00:41:10,960 --> 00:41:14,720
about in my

00:41:11,680 --> 00:41:17,920
fosdem talk so just briefly here

00:41:14,720 --> 00:41:20,560
it's it's like string equality

00:41:17,920 --> 00:41:21,520
that understands undef and understands

00:41:20,560 --> 00:41:24,560
that undef

00:41:21,520 --> 00:41:26,560
is not the empty string because this is

00:41:24,560 --> 00:41:29,280
an operator i would like to have

00:41:26,560 --> 00:41:30,319
uh and it turns out that if you just add

00:41:29,280 --> 00:41:32,400
p olympics

00:41:30,319 --> 00:41:35,119
plugin to core perl you can now

00:41:32,400 --> 00:41:36,720
implement this operator as a cpan module

00:41:35,119 --> 00:41:38,800
so i've done that as an excess module

00:41:36,720 --> 00:41:42,240
i've just done that similarly it does

00:41:38,800 --> 00:41:44,560
numerical comparisons as well

00:41:42,240 --> 00:41:45,839
um i actually i haven't got a slide

00:41:44,560 --> 00:41:47,680
about this but what during

00:41:45,839 --> 00:41:48,880
leon's talk yesterday where he said he

00:41:47,680 --> 00:41:51,839
wanted the percent percent

00:41:48,880 --> 00:41:53,359
operator to to be does this number

00:41:51,839 --> 00:41:56,319
divide this other number

00:41:53,359 --> 00:41:57,359
i actually wrote a rota module during

00:41:56,319 --> 00:41:59,440
his talk

00:41:57,359 --> 00:42:00,800
um to implement that as a thing because

00:41:59,440 --> 00:42:04,000
it turned out that was quite easy with

00:42:00,800 --> 00:42:06,319
the with the infix plugin module

00:42:04,000 --> 00:42:07,440
but obviously that's not on cpen um

00:42:06,319 --> 00:42:08,640
there's a lot tighter integration

00:42:07,440 --> 00:42:11,119
between these modules

00:42:08,640 --> 00:42:14,000
uh because for example i've as we've

00:42:11,119 --> 00:42:18,000
just seen syntax operator equ

00:42:14,000 --> 00:42:21,119
can provide an equality test operator

00:42:18,000 --> 00:42:23,920
syntax keyword match wants

00:42:21,119 --> 00:42:25,040
an equality test operator you can see

00:42:23,920 --> 00:42:28,480
where i'm going

00:42:25,040 --> 00:42:31,280
here it would be lovely

00:42:28,480 --> 00:42:32,400
if you could just write use one module

00:42:31,280 --> 00:42:36,240
use the other module

00:42:32,400 --> 00:42:38,960
match string colon equ

00:42:36,240 --> 00:42:40,480
on all these things but if you remember

00:42:38,960 --> 00:42:41,599
the grammar that i wrote before that's

00:42:40,480 --> 00:42:42,160
not going to help that's not going to

00:42:41,599 --> 00:42:45,119
work

00:42:42,160 --> 00:42:47,040
because currently syntax keyword match

00:42:45,119 --> 00:42:49,280
says it wants a choice of exactly those

00:42:47,040 --> 00:42:52,319
four things the equals

00:42:49,280 --> 00:42:55,680
uh that the eq double equals is a

00:42:52,319 --> 00:42:56,079
or the uh regex byte so instead i think

00:42:55,680 --> 00:42:58,720
well

00:42:56,079 --> 00:42:59,520
what i'd have to add is some kind of

00:42:58,720 --> 00:43:01,440
registry

00:42:59,520 --> 00:43:02,880
again there's a lot of common themes

00:43:01,440 --> 00:43:04,240
here registries registries are good

00:43:02,880 --> 00:43:07,839
everyone should have a registry

00:43:04,240 --> 00:43:11,440
a registry of equality operators

00:43:07,839 --> 00:43:13,520
and so uh syntax offer a keyword match

00:43:11,440 --> 00:43:14,560
could say i want a term expression a

00:43:13,520 --> 00:43:16,400
colon and then

00:43:14,560 --> 00:43:18,319
any kind of operator that implements

00:43:16,400 --> 00:43:20,400
equality i don't really care what

00:43:18,319 --> 00:43:22,079
and so by default perl core knows all

00:43:20,400 --> 00:43:24,000
those standard ones

00:43:22,079 --> 00:43:25,680
but some other module could come along

00:43:24,000 --> 00:43:26,000
and say i'm registering an infix

00:43:25,680 --> 00:43:28,880
operator

00:43:26,000 --> 00:43:30,240
called equ oh and by the way it's an

00:43:28,880 --> 00:43:32,079
equality type operator

00:43:30,240 --> 00:43:33,599
just in case anyone cares and all of a

00:43:32,079 --> 00:43:34,319
sudden these two modules can talk to

00:43:33,599 --> 00:43:36,160
each other

00:43:34,319 --> 00:43:38,319
even though neither module knew about

00:43:36,160 --> 00:43:39,520
the other one they can just cooperate

00:43:38,319 --> 00:43:40,960
and someone could come along and write

00:43:39,520 --> 00:43:42,560
you know whatever other kinds of quality

00:43:40,960 --> 00:43:45,040
operators they like

00:43:42,560 --> 00:43:47,200
and they would all just work so that

00:43:45,040 --> 00:43:50,480
would be great

00:43:47,200 --> 00:43:54,400
and then finally automatic deposit

00:43:50,480 --> 00:43:55,680
so the the core bd pass module does have

00:43:54,400 --> 00:43:58,480
some logic to handle these

00:43:55,680 --> 00:44:00,240
these custom ops it's not very good it's

00:43:58,480 --> 00:44:02,319
not very flexible it relies on the

00:44:00,240 --> 00:44:03,839
string name of the operator

00:44:02,319 --> 00:44:05,359
for one thing so if two different people

00:44:03,839 --> 00:44:06,720
happen to operate or not implement an

00:44:05,359 --> 00:44:08,240
operator of the same name it gets very

00:44:06,720 --> 00:44:10,160
confused

00:44:08,240 --> 00:44:12,800
it's also it's not very good at pulling

00:44:10,160 --> 00:44:15,760
out the context around them

00:44:12,800 --> 00:44:17,520
for example syntax keyword try does

00:44:15,760 --> 00:44:19,359
actually wrap an extra block

00:44:17,520 --> 00:44:20,880
around when you write try catch whatever

00:44:19,359 --> 00:44:22,240
there's actually an extra block wrapped

00:44:20,880 --> 00:44:24,640
around that before

00:44:22,240 --> 00:44:25,839
the custom operator which means that

00:44:24,640 --> 00:44:29,040
when you try and run

00:44:25,839 --> 00:44:32,240
syntax keyword try code through bd parse

00:44:29,040 --> 00:44:34,240
you end up seeing that extra block

00:44:32,240 --> 00:44:35,839
so an extra set of braces appears in the

00:44:34,240 --> 00:44:36,480
code and there's nothing i can do about

00:44:35,839 --> 00:44:37,760
that

00:44:36,480 --> 00:44:39,520
so it means if you kind of keep round

00:44:37,760 --> 00:44:41,119
tripping with pot with with

00:44:39,520 --> 00:44:44,480
parsing the code they're depositing it

00:44:41,119 --> 00:44:46,160
you just get more and more nested braces

00:44:44,480 --> 00:44:48,400
so it's it's not very good i don't like

00:44:46,160 --> 00:44:49,920
that um and it requires yeah

00:44:48,400 --> 00:44:52,000
bd pass currently requires a lot of

00:44:49,920 --> 00:44:54,000
awkward monkey patching

00:44:52,000 --> 00:44:55,920
whereas at the moment i because the

00:44:54,000 --> 00:44:57,440
infix operators tend to be so simple

00:44:55,920 --> 00:45:00,960
because they are literally just

00:44:57,440 --> 00:45:04,079
expression operator other expression

00:45:00,960 --> 00:45:05,119
xs pars infix already monkey patches uh

00:45:04,079 --> 00:45:07,520
bd pars

00:45:05,119 --> 00:45:08,720
to be able to automatically parse all of

00:45:07,520 --> 00:45:11,200
the stuff that you write

00:45:08,720 --> 00:45:12,000
so every syntax module that i've written

00:45:11,200 --> 00:45:14,480
this um

00:45:12,000 --> 00:45:15,200
using syntax that's a syntax operator

00:45:14,480 --> 00:45:17,599
module

00:45:15,200 --> 00:45:19,280
already bd parse just works and i never

00:45:17,599 --> 00:45:20,240
had to do anything special in each

00:45:19,280 --> 00:45:22,560
module

00:45:20,240 --> 00:45:24,240
so that's very nice so it's a quick

00:45:22,560 --> 00:45:27,280
recap

00:45:24,240 --> 00:45:30,400
plugable keywords are a very nice way to

00:45:27,280 --> 00:45:31,680
experiment on cpan with new features so

00:45:30,400 --> 00:45:33,440
that we can come back

00:45:31,680 --> 00:45:34,880
to core pearl and say yes we've

00:45:33,440 --> 00:45:36,960
experimented with this

00:45:34,880 --> 00:45:39,680
this is what we've this is what we like

00:45:36,960 --> 00:45:41,280
we'll just copy it into court pearl

00:45:39,680 --> 00:45:43,200
the low level mechanisms are very hard

00:45:41,280 --> 00:45:45,119
to use

00:45:43,200 --> 00:45:47,599
i've written some cpan modules that make

00:45:45,119 --> 00:45:49,200
it nicer so there's xs pass keyword and

00:45:47,599 --> 00:45:51,520
already all of my keyword modules

00:45:49,200 --> 00:45:52,400
as of i think two days before the

00:45:51,520 --> 00:45:54,880
conference

00:45:52,400 --> 00:45:56,400
are now using that yay conference driven

00:45:54,880 --> 00:45:58,800
software

00:45:56,400 --> 00:46:00,079
uh there's excess power sublight

00:45:58,800 --> 00:46:00,800
currently there are only two modules

00:46:00,079 --> 00:46:02,240
that use that

00:46:00,800 --> 00:46:03,839
because i literally wrote it as a

00:46:02,240 --> 00:46:07,520
mechanism for

00:46:03,839 --> 00:46:09,599
um for a to handle async

00:46:07,520 --> 00:46:10,960
method uh somebody has pointed out that

00:46:09,599 --> 00:46:13,119
maybe we would like

00:46:10,960 --> 00:46:15,200
multiple dispatch so we might have to do

00:46:13,119 --> 00:46:16,079
multi async sub and so often you're

00:46:15,200 --> 00:46:18,880
going to have to combine

00:46:16,079 --> 00:46:20,000
three sets of hooks there so i'm going

00:46:18,880 --> 00:46:20,480
to have to extend that a bit more to

00:46:20,000 --> 00:46:24,640
allow

00:46:20,480 --> 00:46:26,400
more code so that could be fun

00:46:24,640 --> 00:46:28,240
and one day i hope you're able to ship

00:46:26,400 --> 00:46:30,000
an excess parsing fix but as i think at

00:46:28,240 --> 00:46:30,720
the moment that relies on a core pearl

00:46:30,000 --> 00:46:34,079
feature

00:46:30,720 --> 00:46:36,880
that i haven't got merged

00:46:34,079 --> 00:46:37,760
but i'm hoping to um because all of

00:46:36,880 --> 00:46:40,000
these modules

00:46:37,760 --> 00:46:41,040
shield the plug-in authors from the core

00:46:40,000 --> 00:46:43,440
code from

00:46:41,040 --> 00:46:44,880
from the pearl core so you don't have to

00:46:43,440 --> 00:46:45,200
understand anywhere near as much about

00:46:44,880 --> 00:46:47,680
how

00:46:45,200 --> 00:46:48,880
core pearl does its parsing now you only

00:46:47,680 --> 00:46:52,079
have to understand

00:46:48,880 --> 00:46:53,520
the published interface to these modules

00:46:52,079 --> 00:46:55,520
it says yeah there's less coupling with

00:46:53,520 --> 00:46:57,040
pearl core and that's a good thing

00:46:55,520 --> 00:46:58,400
and i think this should be the preferred

00:46:57,040 --> 00:47:00,240
way that everyone should be writing

00:46:58,400 --> 00:47:01,520
keyword plugin modules

00:47:00,240 --> 00:47:04,160
and since i seem to be the only person

00:47:01,520 --> 00:47:06,480
writing keyword modules at the moment

00:47:04,160 --> 00:47:07,200
this now is the preferred way because

00:47:06,480 --> 00:47:11,760
all of them

00:47:07,200 --> 00:47:15,280
are using it

00:47:11,760 --> 00:47:15,280
does anyone have any questions

00:47:19,760 --> 00:47:24,319
someone's written the question i've got

00:47:21,760 --> 00:47:25,839
a couple comments comments

00:47:24,319 --> 00:47:27,599
okay i'll listen to your one first and

00:47:25,839 --> 00:47:32,480
then i'll come back and

00:47:27,599 --> 00:47:32,480
do one from the chat yep let's go on uh

00:47:35,680 --> 00:47:39,040
your sound's dropped out i can't hear

00:47:47,440 --> 00:47:50,319
i'll come back to that i'll take this

00:47:48,480 --> 00:47:51,680
one from the chat first how does

00:47:50,319 --> 00:47:53,440
pluggable keywords work with

00:47:51,680 --> 00:47:54,559
dependencies among modules being used in

00:47:53,440 --> 00:47:56,400
an application

00:47:54,559 --> 00:47:57,920
if you add a keyword in a module what's

00:47:56,400 --> 00:48:00,000
the scope of that oh

00:47:57,920 --> 00:48:01,440
these things are entirely lexical so the

00:48:00,000 --> 00:48:03,440
point that i was making uh

00:48:01,440 --> 00:48:05,599
right at the beginning about the the

00:48:03,440 --> 00:48:08,800
hint hash let me see if i can just

00:48:05,599 --> 00:48:11,359
briefly nip back and

00:48:08,800 --> 00:48:12,960
find it the point that i was making

00:48:11,359 --> 00:48:16,160
about the hint hash

00:48:12,960 --> 00:48:19,040
here is that um you have to

00:48:16,160 --> 00:48:20,800
you have to put in some work to say um

00:48:19,040 --> 00:48:23,359
here's the keyword that i recognize

00:48:20,800 --> 00:48:25,119
in this scope with the with the lexical

00:48:23,359 --> 00:48:28,880
hint enabled

00:48:25,119 --> 00:48:30,160
um and so the uh oh i don't know whether

00:48:28,880 --> 00:48:35,839
i'm going to find the slide at the

00:48:30,160 --> 00:48:35,839
moment but um

00:48:39,280 --> 00:48:44,079
the point i was making about um they are

00:48:42,240 --> 00:48:45,599
they're all lexically scoped because

00:48:44,079 --> 00:48:48,000
they're all enabled

00:48:45,599 --> 00:48:49,520
by things in the lexical hint hash that

00:48:48,000 --> 00:48:51,280
gets put there by the import

00:48:49,520 --> 00:48:52,319
some so they're totally electrically

00:48:51,280 --> 00:48:52,960
scoped you can have two different

00:48:52,319 --> 00:48:54,559
modules

00:48:52,960 --> 00:48:56,319
that implement two different keywords

00:48:54,559 --> 00:48:57,760
it's all fine or two module

00:48:56,319 --> 00:48:59,599
two different two different modules of

00:48:57,760 --> 00:49:02,640
your code might be using

00:48:59,599 --> 00:49:04,000
this a keyword that's the same word from

00:49:02,640 --> 00:49:06,800
two different plugins and that's all

00:49:04,000 --> 00:49:06,800
that's all absolutely fine

00:49:08,400 --> 00:49:12,160
right do we have this question again

00:49:13,920 --> 00:49:17,839
i think we've got maybe five minutes or

00:49:15,760 --> 00:49:17,839
so

00:49:18,240 --> 00:49:22,800
may i oh yeah go ahead okay first of all

00:49:21,280 --> 00:49:25,200
i think we should nominate you for the

00:49:22,800 --> 00:49:27,920
first annual damian conway

00:49:25,200 --> 00:49:28,839
most mind-blowing presentation of the

00:49:27,920 --> 00:49:32,160
conference

00:49:28,839 --> 00:49:35,359
award because that was really yeah

00:49:32,160 --> 00:49:38,880
really amazing second if

00:49:35,359 --> 00:49:42,000
you get enough of these of these excess

00:49:38,880 --> 00:49:45,599
parse modules actually

00:49:42,000 --> 00:49:48,640
shipped with the core

00:49:45,599 --> 00:49:51,599
then how much

00:49:48,640 --> 00:49:53,520
twiddling of the actual core do we

00:49:51,599 --> 00:49:55,760
really need to use

00:49:53,520 --> 00:49:56,640
if you ship these with the core and then

00:49:55,760 --> 00:49:59,359
you vote on

00:49:56,640 --> 00:50:01,040
okay we like this one this

00:49:59,359 --> 00:50:03,599
implementation of eq

00:50:01,040 --> 00:50:05,200
and shipped that with the core how much

00:50:03,599 --> 00:50:08,800
twiddling with the cord do we

00:50:05,200 --> 00:50:09,359
actually have to do so i kind of glossed

00:50:08,800 --> 00:50:11,119
over

00:50:09,359 --> 00:50:13,680
quite a few of the inner details i mean

00:50:11,119 --> 00:50:16,640
if you if you implement custom code

00:50:13,680 --> 00:50:17,520
then as far as the perl core is

00:50:16,640 --> 00:50:20,000
concerned

00:50:17,520 --> 00:50:21,599
its op type is op custom and it happens

00:50:20,000 --> 00:50:22,720
to have a special function attached to

00:50:21,599 --> 00:50:24,480
it which is the function

00:50:22,720 --> 00:50:25,760
that you've supplied to implement your

00:50:24,480 --> 00:50:27,359
semantics

00:50:25,760 --> 00:50:30,480
and so there are lots of things that the

00:50:27,359 --> 00:50:32,720
call of perl doesn't really do properly

00:50:30,480 --> 00:50:34,800
um so there's things like the there's

00:50:32,720 --> 00:50:36,800
like the the internal optimizer

00:50:34,800 --> 00:50:39,359
so the internal optimizer inside core

00:50:36,800 --> 00:50:41,200
pearl understands all of core pearl's

00:50:39,359 --> 00:50:42,480
ops the real ops that are provided by

00:50:41,200 --> 00:50:44,559
core pearl

00:50:42,480 --> 00:50:46,480
and can shuffle them around provide

00:50:44,559 --> 00:50:47,920
better versions things like multi-concat

00:50:46,480 --> 00:50:49,599
is a bit crazy

00:50:47,920 --> 00:50:51,119
and it can do that with its internal ops

00:50:49,599 --> 00:50:53,359
because it understands them but it won't

00:50:51,119 --> 00:50:56,000
do anything with your custom ops

00:50:53,359 --> 00:50:56,720
secondly there's things like try catch

00:50:56,000 --> 00:50:59,359
so

00:50:56,720 --> 00:51:00,079
cause version of try catch even though

00:50:59,359 --> 00:51:04,000
try

00:51:00,079 --> 00:51:06,800
is really an eval block cause try catch

00:51:04,000 --> 00:51:08,960
is invisible to caller so it doesn't

00:51:06,800 --> 00:51:10,720
appear in the caller stack

00:51:08,960 --> 00:51:12,319
that's because the function that

00:51:10,720 --> 00:51:15,760
implements caller

00:51:12,319 --> 00:51:17,760
can recognize the true try operation

00:51:15,760 --> 00:51:20,240
that is provided by the cause version of

00:51:17,760 --> 00:51:22,319
try catch where a syntax keyword try

00:51:20,240 --> 00:51:24,640
because it's just a cpan module it can't

00:51:22,319 --> 00:51:26,640
create new kinds of context

00:51:24,640 --> 00:51:28,160
so it's stuck with having to be an eval

00:51:26,640 --> 00:51:30,880
and therefore appears in the caller

00:51:28,160 --> 00:51:32,880
list um so there are a lot more powerful

00:51:30,880 --> 00:51:33,440
internal things that real core things

00:51:32,880 --> 00:51:35,119
can do

00:51:33,440 --> 00:51:37,119
so there will always be a case where you

00:51:35,119 --> 00:51:39,280
will want real core things

00:51:37,119 --> 00:51:41,760
the the syntax modules on cpanel are

00:51:39,280 --> 00:51:43,920
really kind of a way to experiment with

00:51:41,760 --> 00:51:45,760
how do we like this syntax do we like

00:51:43,920 --> 00:51:46,880
that that bracket there do we want to do

00:51:45,760 --> 00:51:50,319
this without brackets

00:51:46,880 --> 00:51:53,359
so for example uh for a while um catch

00:51:50,319 --> 00:51:56,319
with a variable was spelt catch my

00:51:53,359 --> 00:51:57,760
dollar e with no parentheses and for a

00:51:56,319 --> 00:51:59,040
while we used that in syntax keyword

00:51:57,760 --> 00:52:01,040
right then eventually when i started

00:51:59,040 --> 00:52:01,839
doing the type to catch we realized

00:52:01,040 --> 00:52:03,440
actually you kind of want the

00:52:01,839 --> 00:52:05,520
parentheses here so that's typing

00:52:03,440 --> 00:52:07,599
information inside the parentheses

00:52:05,520 --> 00:52:09,520
um so the cpanel is a good way to

00:52:07,599 --> 00:52:10,960
experiment with changing around the

00:52:09,520 --> 00:52:12,880
syntax once you've worked out what the

00:52:10,960 --> 00:52:15,040
syntax should look like can be spelled

00:52:12,880 --> 00:52:16,160
you can then copy that idea into

00:52:15,040 --> 00:52:19,119
corporel and

00:52:16,160 --> 00:52:20,319
implement it in a better way so you end

00:52:19,119 --> 00:52:23,760
up with

00:52:20,319 --> 00:52:26,880
an rfc i want to do this

00:52:23,760 --> 00:52:31,520
and a set of

00:52:26,880 --> 00:52:34,640
xs modules you write to play with it

00:52:31,520 --> 00:52:37,599
and then include the excess modules

00:52:34,640 --> 00:52:38,720
in the core in a release and then the

00:52:37,599 --> 00:52:40,400
next release

00:52:38,720 --> 00:52:42,319
you have to take them out of excess and

00:52:40,400 --> 00:52:45,200
show them in the uh i wouldn't do that

00:52:42,319 --> 00:52:46,640
i wouldn't do that so syntax keyword try

00:52:45,200 --> 00:52:49,920
i spent maybe

00:52:46,640 --> 00:52:53,119
two or three years elapsed time

00:52:49,920 --> 00:52:54,720
uh experimenting with that on cpan um

00:52:53,119 --> 00:52:55,920
once we'd finalized that and we said

00:52:54,720 --> 00:52:56,400
right we're going to pull this into part

00:52:55,920 --> 00:52:58,960
core

00:52:56,400 --> 00:52:59,680
took me two days to be two days to

00:52:58,960 --> 00:53:02,800
totally

00:52:59,680 --> 00:53:06,240
write the code from scratch in bleep in

00:53:02,800 --> 00:53:06,960
in core pearl it did not take me long to

00:53:06,240 --> 00:53:08,880
implement

00:53:06,960 --> 00:53:10,559
the idea because the idea already

00:53:08,880 --> 00:53:12,079
existed and the documentation already

00:53:10,559 --> 00:53:12,800
existed and the unit tests and

00:53:12,079 --> 00:53:14,160
everything

00:53:12,800 --> 00:53:15,520
other than the implementation already

00:53:14,160 --> 00:53:17,599
existed so i just spent two days

00:53:15,520 --> 00:53:19,599
implementing it and that was all fine

00:53:17,599 --> 00:53:22,160
pulling these excess modules into core

00:53:19,599 --> 00:53:24,800
is not going to buy you anything

00:53:22,160 --> 00:53:25,920
god okay i was just wondering if if you

00:53:24,800 --> 00:53:28,319
know

00:53:25,920 --> 00:53:29,920
if you know if people want to add if i

00:53:28,319 --> 00:53:32,960
was just wondering if that was a way to

00:53:29,920 --> 00:53:34,160
smooth it in put it in like this let's

00:53:32,960 --> 00:53:37,200
see it happen and then

00:53:34,160 --> 00:53:37,760
court and then put it code wise i think

00:53:37,200 --> 00:53:39,760
having it

00:53:37,760 --> 00:53:41,200
i think having it is available as a cpan

00:53:39,760 --> 00:53:44,400
module that people can use

00:53:41,200 --> 00:53:44,880
and then in the rfc you can point out we

00:53:44,400 --> 00:53:46,720
will

00:53:44,880 --> 00:53:49,200
we would like to implement this core

00:53:46,720 --> 00:53:49,760
syntax as an exact copy of that module

00:53:49,200 --> 00:53:51,200
over there

00:53:49,760 --> 00:53:52,559
look how many people are already using

00:53:51,200 --> 00:53:53,520
that i think that's a very strong

00:53:52,559 --> 00:53:56,240
motivation

00:53:53,520 --> 00:53:56,880
to tell core yes we want this that's

00:53:56,240 --> 00:53:58,240
backwards

00:53:56,880 --> 00:54:00,079
that's backwards from what i was

00:53:58,240 --> 00:54:01,280
thinking you're thinking yeah implement

00:54:00,079 --> 00:54:03,839
it as a

00:54:01,280 --> 00:54:04,640
implement it as a module work out the

00:54:03,839 --> 00:54:07,599
bugs

00:54:04,640 --> 00:54:08,160
and then point to it in the rfc okay

00:54:07,599 --> 00:54:09,920
yeah

00:54:08,160 --> 00:54:11,520
yeah that that's the kind of process i

00:54:09,920 --> 00:54:12,079
could imagine working yeah that's me

00:54:11,520 --> 00:54:15,040
exactly

00:54:12,079 --> 00:54:16,559
thank you so i think we're pretty much

00:54:15,040 --> 00:54:17,359
at time unless there's anything else

00:54:16,559 --> 00:54:20,160
really quick

00:54:17,359 --> 00:54:22,400
yes we are reaching the uh time box unit

00:54:20,160 --> 00:54:24,960
yeah

00:54:22,400 --> 00:54:28,480
okay nobody nobody else is shouting so

00:54:24,960 --> 00:54:28,480

YouTube URL: https://www.youtube.com/watch?v=Kc_bP73xNyM


