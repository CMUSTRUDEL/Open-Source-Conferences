Title: Elasticsearch Data Exploration in Your Terminal - Brad Lhotsky
Publication date: 2021-06-09
Playlist: TPC 2021 in the Cloud
Description: 
	You've seen the pretty graphs. Visuals are great for signaling there is a problem somewhere. How do you go from pretty graphs to root cause analysis? Let's talk more about integrating Elasticsearch-based dashboards back to the command line workflows I love.

This talk is an overview of a tool I developed while working at Booking.com to drastically reduce the time and complexity of performing incident response against rich, structured data in Elasticsearch. It was developed with the help of the security and fraud teams to perform ad-hoc queries critical for incident response. The tool served the team well and it's been under active development ever since. It continues to grow in capabilities aimed to make ad-hoc analysis simple, easy, and accessible to hardened command line jockeys and command line newbies.

Join me to learn how to bring the logging data you love back to your terminal!
Captions: 
	00:00:00,399 --> 00:00:05,759
all right it is eight o'clock um

00:00:04,000 --> 00:00:07,759
so this is the first time i've ever done

00:00:05,759 --> 00:00:11,200
a virtual conference

00:00:07,759 --> 00:00:14,000
so i hope it's um i hope

00:00:11,200 --> 00:00:15,040
everyone's expectations are met here um

00:00:14,000 --> 00:00:16,720
it's kind of weird

00:00:15,040 --> 00:00:18,720
giving a talk without an audience

00:00:16,720 --> 00:00:23,039
present um so

00:00:18,720 --> 00:00:24,880
bear with my terrible jokes um

00:00:23,039 --> 00:00:26,400
welcome to elasticsearch data

00:00:24,880 --> 00:00:29,199
exploration in your terminal

00:00:26,400 --> 00:00:30,000
i i'm your host brad lotzky um these

00:00:29,199 --> 00:00:33,520
slides are already

00:00:30,000 --> 00:00:36,079
up on speaker deck i have a tiny url

00:00:33,520 --> 00:00:36,559
uh here if you want to follow along

00:00:36,079 --> 00:00:37,920
there

00:00:36,559 --> 00:00:39,840
there's a possibility they're not done

00:00:37,920 --> 00:00:40,960
processing yet but i will make sure that

00:00:39,840 --> 00:00:43,440
after this talk

00:00:40,960 --> 00:00:44,000
everything is working at that link i

00:00:43,440 --> 00:00:47,039
also added

00:00:44,000 --> 00:00:49,920
it to the wiki so you can find the

00:00:47,039 --> 00:00:49,920
the slides there

00:00:50,160 --> 00:00:54,480
so the first thing that you're going to

00:00:53,440 --> 00:00:56,840
be asking yourself

00:00:54,480 --> 00:00:58,000
is uh why do we want to bring

00:00:56,840 --> 00:01:00,719
elasticsearch

00:00:58,000 --> 00:01:02,879
into the terminal we already have a lot

00:01:00,719 --> 00:01:05,119
of different interfaces to elasticsearch

00:01:02,879 --> 00:01:06,400
so why go ahead and add terminal in we

00:01:05,119 --> 00:01:09,360
have cabana

00:01:06,400 --> 00:01:12,960
and cabana's developed at lockstep with

00:01:09,360 --> 00:01:16,720
elasticsearch it's developed by elastic

00:01:12,960 --> 00:01:20,560
surely it's representative of all your

00:01:16,720 --> 00:01:24,479
graphing and data exploration needs

00:01:20,560 --> 00:01:26,000
for me i found cabana a little bit

00:01:24,479 --> 00:01:28,080
difficult to work with and also

00:01:26,000 --> 00:01:30,479
difficult to teach people who

00:01:28,080 --> 00:01:31,840
aren't super technical how to use how to

00:01:30,479 --> 00:01:33,520
build graphs how to

00:01:31,840 --> 00:01:35,520
combine visualizations and create

00:01:33,520 --> 00:01:37,439
dashboards and it's just

00:01:35,520 --> 00:01:40,640
the working with the tool feels slower

00:01:37,439 --> 00:01:43,200
and less intuitive than some other tools

00:01:40,640 --> 00:01:44,399
there's grafana grafana is pretty

00:01:43,200 --> 00:01:46,880
awesome

00:01:44,399 --> 00:01:48,399
i love this tool it's my go-to for doing

00:01:46,880 --> 00:01:52,479
dashboards and graphs

00:01:48,399 --> 00:01:54,320
you can combine data sources on

00:01:52,479 --> 00:01:56,320
graphs or dashboards so you can have

00:01:54,320 --> 00:01:59,439
data coming in from graphite from

00:01:56,320 --> 00:02:03,119
sql databases from influx prometheus and

00:01:59,439 --> 00:02:06,880
elasticsearch um it's really really cool

00:02:03,119 --> 00:02:10,319
um but still it's not that great for

00:02:06,880 --> 00:02:12,640
logging data um they're

00:02:10,319 --> 00:02:14,319
adding text into a browser with all

00:02:12,640 --> 00:02:16,080
these fancy widgets and

00:02:14,319 --> 00:02:18,000
all the visualizations uh it feels a

00:02:16,080 --> 00:02:20,239
little bit clunky we add in

00:02:18,000 --> 00:02:21,599
a bunch of scroll bars so we have a

00:02:20,239 --> 00:02:22,720
scroll bar for the browser we have a

00:02:21,599 --> 00:02:25,520
scroll bar for

00:02:22,720 --> 00:02:26,800
the individual widgets sometimes we get

00:02:25,520 --> 00:02:28,160
truncated text

00:02:26,800 --> 00:02:30,800
we can't really see everything we don't

00:02:28,160 --> 00:02:34,160
have good control over how wrapping is

00:02:30,800 --> 00:02:35,920
handled in a lot of these

00:02:34,160 --> 00:02:38,160
tools so it just it just doesn't feel

00:02:35,920 --> 00:02:40,239
right um

00:02:38,160 --> 00:02:42,560
and you know grafana recently added a

00:02:40,239 --> 00:02:45,599
product called loki into their profile

00:02:42,560 --> 00:02:48,879
and loki is specifically designed

00:02:45,599 --> 00:02:53,440
for handling log data inside of grafana

00:02:48,879 --> 00:02:55,760
and that again meets with those same

00:02:53,440 --> 00:02:56,879
issues that i have with you know just

00:02:55,760 --> 00:02:58,800
logging data in

00:02:56,879 --> 00:03:00,480
the browser in general which is it's

00:02:58,800 --> 00:03:03,920
very difficult to navigate

00:03:00,480 --> 00:03:04,959
text and to navigate with your keyboard

00:03:03,920 --> 00:03:07,519
in

00:03:04,959 --> 00:03:08,400
a uh in a browser window and the other

00:03:07,519 --> 00:03:12,080
thing is

00:03:08,400 --> 00:03:14,400
the log exploration pieces um in grafana

00:03:12,080 --> 00:03:16,800
are really tailored towards loki

00:03:14,400 --> 00:03:19,200
and so there there's not as much

00:03:16,800 --> 00:03:22,000
incentive for the grafana folks to keep

00:03:19,200 --> 00:03:25,040
the elastic search components as

00:03:22,000 --> 00:03:28,080
up-to-date and fluent as

00:03:25,040 --> 00:03:30,480
the loki data is that's that may not

00:03:28,080 --> 00:03:32,400
always be the case but

00:03:30,480 --> 00:03:33,760
at least in early versions the elastic

00:03:32,400 --> 00:03:35,360
search support was was

00:03:33,760 --> 00:03:37,360
really really terrible i think it's been

00:03:35,360 --> 00:03:38,159
getting a lot better but still we're

00:03:37,360 --> 00:03:41,440
dealing with

00:03:38,159 --> 00:03:42,400
the dom and js and we have touchpad

00:03:41,440 --> 00:03:45,920
gestures and

00:03:42,400 --> 00:03:48,640
um there's just too much noise happening

00:03:45,920 --> 00:03:48,640
in the browser

00:03:49,200 --> 00:03:52,400
and if we wanted to drag the terminal

00:03:50,720 --> 00:03:55,760
into this couldn't we just curl

00:03:52,400 --> 00:03:58,879
and jq stuff and

00:03:55,760 --> 00:04:01,599
yeah you could and if that's your jam

00:03:58,879 --> 00:04:02,239
go for it but i found that to be really

00:04:01,599 --> 00:04:05,120
annoying

00:04:02,239 --> 00:04:06,000
and certainly not easy to teach other

00:04:05,120 --> 00:04:09,599
people who

00:04:06,000 --> 00:04:12,799
who may be in junior positions

00:04:09,599 --> 00:04:16,160
and i'm really terrible with gooeys

00:04:12,799 --> 00:04:19,040
anytime a mouse is involved um it

00:04:16,160 --> 00:04:20,560
you might as well have uh uh an 85 year

00:04:19,040 --> 00:04:21,680
old man with no computer experience

00:04:20,560 --> 00:04:22,400
sitting in front of the computer it's

00:04:21,680 --> 00:04:24,400
just

00:04:22,400 --> 00:04:26,000
it's just horrible i'm i'm amazed that

00:04:24,400 --> 00:04:30,240
this is working today

00:04:26,000 --> 00:04:31,600
um so i i don't like to use mice

00:04:30,240 --> 00:04:33,759
and i've never really been effective

00:04:31,600 --> 00:04:34,880
with apps or browsers and i see things

00:04:33,759 --> 00:04:36,960
like slack as a

00:04:34,880 --> 00:04:38,800
you know massive loss of portability and

00:04:36,960 --> 00:04:41,280
compatibility and openness

00:04:38,800 --> 00:04:42,800
um i run my browser with so many privacy

00:04:41,280 --> 00:04:44,240
and security extensions

00:04:42,800 --> 00:04:45,840
that even when i put them all to

00:04:44,240 --> 00:04:47,440
permissive mode i

00:04:45,840 --> 00:04:49,120
there are some websites that just render

00:04:47,440 --> 00:04:50,880
as a blank white page to me

00:04:49,120 --> 00:04:52,880
and i'm not willing to compromise on

00:04:50,880 --> 00:04:54,639
those security and privacy pieces

00:04:52,880 --> 00:04:56,800
so i just can't work with some of those

00:04:54,639 --> 00:04:59,120
things um the browser is

00:04:56,800 --> 00:05:00,639
not a good work environment for me it's

00:04:59,120 --> 00:05:03,280
slow bloated

00:05:00,639 --> 00:05:04,880
it's prone to distraction i don't even

00:05:03,280 --> 00:05:06,400
know how many tabs i have open in my

00:05:04,880 --> 00:05:09,280
browser right now but i know the last

00:05:06,400 --> 00:05:12,320
time i counted it was around 85

00:05:09,280 --> 00:05:13,840
and that's not helping me most of those

00:05:12,320 --> 00:05:15,680
tabs are work related

00:05:13,840 --> 00:05:17,360
but you know i do have a gmail or a

00:05:15,680 --> 00:05:19,840
twitter um

00:05:17,360 --> 00:05:21,120
tab open on occasion and with browser

00:05:19,840 --> 00:05:23,520
notifications

00:05:21,120 --> 00:05:24,960
it just gets to be very distracting if

00:05:23,520 --> 00:05:26,960
you've ever studied

00:05:24,960 --> 00:05:29,199
user experience and user interface

00:05:26,960 --> 00:05:30,080
design you'll know that the top right

00:05:29,199 --> 00:05:32,720
and left

00:05:30,080 --> 00:05:33,360
corners of your browser are the most

00:05:32,720 --> 00:05:35,919
visually

00:05:33,360 --> 00:05:38,000
important and that's exactly where all

00:05:35,919 --> 00:05:38,880
of these notifications pop up so you

00:05:38,000 --> 00:05:42,080
wind up getting

00:05:38,880 --> 00:05:43,759
um getting distracted too easily so

00:05:42,080 --> 00:05:47,039
the bottom line is i don't see my

00:05:43,759 --> 00:05:49,840
browser as a workplace

00:05:47,039 --> 00:05:51,360
if we look at the terminal and my use of

00:05:49,840 --> 00:05:52,960
the terminal and probably some of your

00:05:51,360 --> 00:05:54,479
uses of the terminal

00:05:52,960 --> 00:05:57,199
you have a lot more flexibility in

00:05:54,479 --> 00:05:59,120
choice you have a choice of shells

00:05:57,199 --> 00:06:01,759
you can heavily customize the shell for

00:05:59,120 --> 00:06:04,800
your needs you can create

00:06:01,759 --> 00:06:06,080
shortcuts for pretty much anything you

00:06:04,800 --> 00:06:08,479
have tab autocomplete

00:06:06,080 --> 00:06:10,080
breedline and a rich ecosystem of

00:06:08,479 --> 00:06:11,280
command line tools that are there at

00:06:10,080 --> 00:06:13,600
your disposal

00:06:11,280 --> 00:06:15,600
um so it makes performing any operation

00:06:13,600 --> 00:06:17,360
you could think of very easy

00:06:15,600 --> 00:06:19,520
um and then of course you have access to

00:06:17,360 --> 00:06:20,319
your favorite programming interpreter

00:06:19,520 --> 00:06:22,160
like pearl

00:06:20,319 --> 00:06:24,319
um so you can just ditch stuff into

00:06:22,160 --> 00:06:26,960
pearl and and do stuff there

00:06:24,319 --> 00:06:28,639
um so aside from things like muds net

00:06:26,960 --> 00:06:30,240
hack and drug wars there's not really a

00:06:28,639 --> 00:06:32,720
lot of things to distract you in your

00:06:30,240 --> 00:06:32,720
terminal

00:06:32,800 --> 00:06:37,199
this means that the terminal is where i

00:06:34,639 --> 00:06:41,360
make money this is what pays my bills

00:06:37,199 --> 00:06:43,199
um i also have a few

00:06:41,360 --> 00:06:44,960
principles that i consider guiding

00:06:43,199 --> 00:06:45,520
lights that have kind of shaped my

00:06:44,960 --> 00:06:49,199
career

00:06:45,520 --> 00:06:52,240
and and made me who i am today um

00:06:49,199 --> 00:06:52,800
very early in my career a uh i was an

00:06:52,240 --> 00:06:55,280
intern

00:06:52,800 --> 00:06:56,800
at um applied research laboratories in

00:06:55,280 --> 00:06:57,840
aberdeen which is the contractor for the

00:06:56,800 --> 00:07:00,880
army

00:06:57,840 --> 00:07:02,240
and i met a programmer who uh told me

00:07:00,880 --> 00:07:04,479
that there are a finite number of

00:07:02,240 --> 00:07:05,440
keystrokes before you die so use them

00:07:04,479 --> 00:07:07,120
wisely

00:07:05,440 --> 00:07:08,639
um that's always stuck with me i've

00:07:07,120 --> 00:07:10,160
always i've always thought about that

00:07:08,639 --> 00:07:12,000
anytime i've typed the same command

00:07:10,160 --> 00:07:13,919
twice like should i be doing this should

00:07:12,000 --> 00:07:16,160
i be writing a script to do this

00:07:13,919 --> 00:07:18,080
um so that's constantly in my mind and i

00:07:16,160 --> 00:07:19,759
also add my corollary to that which is

00:07:18,080 --> 00:07:21,599
there's a finite distance you can mouse

00:07:19,759 --> 00:07:24,240
or gesture before you die so use it

00:07:21,599 --> 00:07:24,240
wisely

00:07:24,479 --> 00:07:28,800
the unix philosophy is is really has

00:07:27,360 --> 00:07:30,880
been really attractive to me

00:07:28,800 --> 00:07:32,000
and it's been really important in in my

00:07:30,880 --> 00:07:35,360
career um

00:07:32,000 --> 00:07:38,639
it's kind of why i am where i am today

00:07:35,360 --> 00:07:40,720
and it's forced me to think of

00:07:38,639 --> 00:07:42,639
automating myself out of a job and i've

00:07:40,720 --> 00:07:44,639
been doing that since 1999 and my

00:07:42,639 --> 00:07:46,560
backlog is still

00:07:44,639 --> 00:07:48,000
pretty long but i am working on more

00:07:46,560 --> 00:07:49,599
interesting things um

00:07:48,000 --> 00:07:51,599
and at the heart of the unix philosophy

00:07:49,599 --> 00:07:53,680
is this idea of interoperability and

00:07:51,599 --> 00:07:56,000
openness so you have to think about

00:07:53,680 --> 00:07:57,840
your command is going to receive input

00:07:56,000 --> 00:07:59,280
from a user but that user could also be

00:07:57,840 --> 00:08:02,240
a command and then your

00:07:59,280 --> 00:08:03,919
output could be used to be sent to

00:08:02,240 --> 00:08:05,759
another command so when you start

00:08:03,919 --> 00:08:07,759
thinking about that command line api

00:08:05,759 --> 00:08:08,800
and creating these pipelines for

00:08:07,759 --> 00:08:12,560
workflows

00:08:08,800 --> 00:08:14,000
you can get a lot more done and

00:08:12,560 --> 00:08:15,759
it allows you to stand on the shoulders

00:08:14,000 --> 00:08:17,280
of giants i don't know if anyone's

00:08:15,759 --> 00:08:18,080
looked at the source code of the sort

00:08:17,280 --> 00:08:20,720
program

00:08:18,080 --> 00:08:21,599
but it's really efficient it's one of

00:08:20,720 --> 00:08:23,680
the most

00:08:21,599 --> 00:08:25,120
efficient implementations of sorting

00:08:23,680 --> 00:08:26,319
algorithms that you can come across and

00:08:25,120 --> 00:08:28,080
there are so many

00:08:26,319 --> 00:08:30,240
different features in just that one

00:08:28,080 --> 00:08:32,159
program if you haven't

00:08:30,240 --> 00:08:33,680
if you don't know what the sort dash h

00:08:32,159 --> 00:08:35,279
flag is for instance

00:08:33,680 --> 00:08:36,719
check that out i've learned that

00:08:35,279 --> 00:08:39,360
recently and it

00:08:36,719 --> 00:08:40,640
it changed my life so there's a lot of

00:08:39,360 --> 00:08:44,080
really cool utilities

00:08:40,640 --> 00:08:45,279
uh in inside of the unix posix

00:08:44,080 --> 00:08:48,880
environment that

00:08:45,279 --> 00:08:48,880
allow you to be more effective

00:08:49,040 --> 00:08:52,080
and then there's pearl i'm not ashamed

00:08:50,800 --> 00:08:52,959
to say i love it i've been using it

00:08:52,080 --> 00:08:55,839
professionally for

00:08:52,959 --> 00:08:58,160
uh 20 years it dominated the 90s due to

00:08:55,839 --> 00:09:00,320
its ubiquity and ease of use

00:08:58,160 --> 00:09:02,080
it's a well thought out language that

00:09:00,320 --> 00:09:05,040
mimics the sloppiness and

00:09:02,080 --> 00:09:06,000
unpredictability of natural language and

00:09:05,040 --> 00:09:08,080
what this

00:09:06,000 --> 00:09:09,440
means is the language grows with you you

00:09:08,080 --> 00:09:12,560
can start out writing

00:09:09,440 --> 00:09:14,160
bad code that works and as you learn

00:09:12,560 --> 00:09:16,080
more and more about the language your

00:09:14,160 --> 00:09:18,959
code can become more efficient

00:09:16,080 --> 00:09:19,440
and you're never wanting for features

00:09:18,959 --> 00:09:24,399
plus

00:09:19,440 --> 00:09:24,399
we have the cpan and that's just amazing

00:09:25,360 --> 00:09:29,519
while i was working at booking i learned

00:09:27,440 --> 00:09:31,760
the importance of

00:09:29,519 --> 00:09:33,360
being able to ask a data store arbitrary

00:09:31,760 --> 00:09:35,120
questions there's something to be said

00:09:33,360 --> 00:09:38,800
about a well

00:09:35,120 --> 00:09:39,200
defined purpose-built data store that

00:09:38,800 --> 00:09:41,600
does

00:09:39,200 --> 00:09:43,760
one thing well and is super performant

00:09:41,600 --> 00:09:46,480
that can be in a critical path

00:09:43,760 --> 00:09:47,360
but if you need to be able to explore

00:09:46,480 --> 00:09:50,640
the data in

00:09:47,360 --> 00:09:52,560
a data store it needs to be sloppy and

00:09:50,640 --> 00:09:54,640
unpredictable

00:09:52,560 --> 00:09:55,839
so that you can ask these arbitrary

00:09:54,640 --> 00:09:57,200
questions

00:09:55,839 --> 00:09:58,720
because there's a lot of power in there

00:09:57,200 --> 00:10:00,560
and you can use that as a jumping off

00:09:58,720 --> 00:10:02,480
point you can use these

00:10:00,560 --> 00:10:03,600
you can use a data store that's flexible

00:10:02,480 --> 00:10:06,959
like this

00:10:03,600 --> 00:10:08,480
to house just a little bit of your data

00:10:06,959 --> 00:10:10,240
so that you can figure out what are the

00:10:08,480 --> 00:10:11,760
important questions we want to ask this

00:10:10,240 --> 00:10:13,200
and then you can build a purpose-built

00:10:11,760 --> 00:10:14,959
data store that will be highly

00:10:13,200 --> 00:10:17,600
performant for those questions

00:10:14,959 --> 00:10:18,079
but not having that ability to just turn

00:10:17,600 --> 00:10:20,399
the data

00:10:18,079 --> 00:10:21,920
upside down and sideways and join it

00:10:20,399 --> 00:10:22,959
with other data and merge it and

00:10:21,920 --> 00:10:26,399
aggregate

00:10:22,959 --> 00:10:27,920
um you you're going to be not able to

00:10:26,399 --> 00:10:30,240
answer those questions and you're going

00:10:27,920 --> 00:10:32,160
to be less effective at your job

00:10:30,240 --> 00:10:33,440
this is one of the most important things

00:10:32,160 --> 00:10:35,680
that i learned while i was working at

00:10:33,440 --> 00:10:37,600
booking

00:10:35,680 --> 00:10:39,600
all this led me to see the power of

00:10:37,600 --> 00:10:42,959
elasticsearch really early

00:10:39,600 --> 00:10:46,000
um booking adopted elasticsearch

00:10:42,959 --> 00:10:48,160
probably in the o15016 days

00:10:46,000 --> 00:10:49,920
and um we were using it for front-end

00:10:48,160 --> 00:10:52,240
search and disambiguation

00:10:49,920 --> 00:10:53,040
and i was at the time working in

00:10:52,240 --> 00:10:55,040
security

00:10:53,040 --> 00:10:56,720
trying to find with what's called a

00:10:55,040 --> 00:10:59,120
security information and event

00:10:56,720 --> 00:11:01,760
management system which is a sim

00:10:59,120 --> 00:11:02,399
um and i came across early versions of

00:11:01,760 --> 00:11:04,399
greylog

00:11:02,399 --> 00:11:06,240
and logstash which used elasticsearch as

00:11:04,399 --> 00:11:07,360
a datastore and since we already had

00:11:06,240 --> 00:11:09,200
elasticsearch

00:11:07,360 --> 00:11:11,040
in the infrastructure and i was

00:11:09,200 --> 00:11:13,120
supporting it

00:11:11,040 --> 00:11:15,200
there was no business friction for me

00:11:13,120 --> 00:11:18,640
testing these these things out

00:11:15,200 --> 00:11:19,120
and um it i adopted it and quickly was

00:11:18,640 --> 00:11:22,880
just

00:11:19,120 --> 00:11:24,720
blown away by how uh how much

00:11:22,880 --> 00:11:26,320
data was now available what the

00:11:24,720 --> 00:11:28,959
questions i could answer it was

00:11:26,320 --> 00:11:29,600
nothing else had ever come close um in

00:11:28,959 --> 00:11:32,560
the most

00:11:29,600 --> 00:11:33,519
uh the the corollary i could think of is

00:11:32,560 --> 00:11:35,920
people who've

00:11:33,519 --> 00:11:37,680
had uh experience working with splunk

00:11:35,920 --> 00:11:40,880
the first time you worked with splunk it

00:11:37,680 --> 00:11:40,880
was very similar to that

00:11:41,120 --> 00:11:47,440
the issue was plastic search wasn't very

00:11:44,720 --> 00:11:48,880
cli or ops friendly at this time um i

00:11:47,440 --> 00:11:51,680
was responsible for a

00:11:48,880 --> 00:11:52,560
very fragile but very profitable elastic

00:11:51,680 --> 00:11:55,760
search cluster

00:11:52,560 --> 00:11:58,959
at booking and the lack of monitoring

00:11:55,760 --> 00:12:01,279
and operations integrations really

00:11:58,959 --> 00:12:02,320
hurt us when the elasticsearch cluster

00:12:01,279 --> 00:12:05,440
went down it meant

00:12:02,320 --> 00:12:06,959
we were losing money so we needed um we

00:12:05,440 --> 00:12:08,560
needed a solution we needed something

00:12:06,959 --> 00:12:11,279
that could integrate with our existing

00:12:08,560 --> 00:12:15,279
operations tools and

00:12:11,279 --> 00:12:18,000
provide more uh introspection

00:12:15,279 --> 00:12:20,240
so after suffering a few outages i work

00:12:18,000 --> 00:12:22,000
closely with my colleagues at booking

00:12:20,240 --> 00:12:23,680
and shai bannon the creator of

00:12:22,000 --> 00:12:24,560
elasticsearch he was working with us at

00:12:23,680 --> 00:12:25,839
the time

00:12:24,560 --> 00:12:28,240
to figure out what was important to

00:12:25,839 --> 00:12:30,880
monitor and what were the things we

00:12:28,240 --> 00:12:33,760
needed to do to keep the cluster healthy

00:12:30,880 --> 00:12:34,800
and so i started app elasticsearch

00:12:33,760 --> 00:12:38,639
utilities

00:12:34,800 --> 00:12:41,680
as a functional library

00:12:38,639 --> 00:12:43,760
of monitoring and operations tools

00:12:41,680 --> 00:12:45,839
so the main tools were monitoring

00:12:43,760 --> 00:12:47,680
maintenance status information so

00:12:45,839 --> 00:12:49,120
admins could run commands and see what's

00:12:47,680 --> 00:12:52,399
going on with the cluster

00:12:49,120 --> 00:12:55,519
um but i built it all with a reusable

00:12:52,399 --> 00:12:56,160
um functional library so everything was

00:12:55,519 --> 00:12:59,120
functional

00:12:56,160 --> 00:13:00,720
and that you know because it was aimed

00:12:59,120 --> 00:13:02,240
at operations people the idea was to be

00:13:00,720 --> 00:13:03,519
able to write quick one-off scripts

00:13:02,240 --> 00:13:06,000
without having to get too deep into

00:13:03,519 --> 00:13:08,560
documentation so everything was very um

00:13:06,000 --> 00:13:09,839
straightforward the tools were built um

00:13:08,560 --> 00:13:13,120
version agnostic

00:13:09,839 --> 00:13:15,360
um with translations in place as

00:13:13,120 --> 00:13:17,120
we upgraded versions of elasticsearch so

00:13:15,360 --> 00:13:20,000
that we didn't have to rewrite code

00:13:17,120 --> 00:13:20,639
the code could stay the same forever and

00:13:20,000 --> 00:13:22,639
we could

00:13:20,639 --> 00:13:24,240
migrate to newer versions of

00:13:22,639 --> 00:13:27,200
elasticsearch

00:13:24,240 --> 00:13:27,600
we we used in our logging infrastructure

00:13:27,200 --> 00:13:30,639
um

00:13:27,600 --> 00:13:33,040
the default logstash index naming

00:13:30,639 --> 00:13:34,560
at the time so a lot of the tools inside

00:13:33,040 --> 00:13:37,680
of the

00:13:34,560 --> 00:13:38,240
distribution assume that if you have log

00:13:37,680 --> 00:13:41,600
data

00:13:38,240 --> 00:13:46,800
that it it follows this index dash

00:13:41,600 --> 00:13:48,639
y dot m.d format

00:13:46,800 --> 00:13:50,880
and while i was working on these tools

00:13:48,639 --> 00:13:53,440
it became evident to me that i could

00:13:50,880 --> 00:13:55,040
use the same libraries to get data out

00:13:53,440 --> 00:13:56,800
of the cluster

00:13:55,040 --> 00:13:58,480
the actual data rather than the metadata

00:13:56,800 --> 00:14:00,880
about how the cluster was working

00:13:58,480 --> 00:14:02,639
and that is es search.pl and that's what

00:14:00,880 --> 00:14:04,480
i'm going to talk about today

00:14:02,639 --> 00:14:06,160
um if you'd like to if you have an

00:14:04,480 --> 00:14:08,160
elasticsearch cluster at home

00:14:06,160 --> 00:14:10,560
and you'd like to follow along um go

00:14:08,160 --> 00:14:13,120
ahead i recommend using pro brew

00:14:10,560 --> 00:14:14,480
to install um the latest pearl which is

00:14:13,120 --> 00:14:18,320
uh pearl

00:14:14,480 --> 00:14:20,720
534 right now and then you see pan m

00:14:18,320 --> 00:14:21,920
elastic search utilities and you can you

00:14:20,720 --> 00:14:22,800
can follow along with some of the

00:14:21,920 --> 00:14:26,240
examples in

00:14:22,800 --> 00:14:29,040
in the presentation um

00:14:26,240 --> 00:14:30,320
so this happened in in 2012 all of this

00:14:29,040 --> 00:14:32,000
code

00:14:30,320 --> 00:14:34,480
predated a lot of the stuff that's

00:14:32,000 --> 00:14:36,120
currently available in the elastic

00:14:34,480 --> 00:14:38,320
ecosystem but i still feel like

00:14:36,120 --> 00:14:40,720
esearch.pl is is one of the

00:14:38,320 --> 00:14:42,399
tools that i haven't seen a parallel to

00:14:40,720 --> 00:14:44,880
and and has really

00:14:42,399 --> 00:14:46,079
been uh useful to me and to the people

00:14:44,880 --> 00:14:49,199
that i've shown it to

00:14:46,079 --> 00:14:51,760
um the code is

00:14:49,199 --> 00:14:52,800
compatible with version o16 all the way

00:14:51,760 --> 00:14:55,360
through the latest

00:14:52,800 --> 00:14:56,560
uh seven um there's some constraints

00:14:55,360 --> 00:15:00,000
built into the tooling

00:14:56,560 --> 00:15:00,800
to make searching safe even for older

00:15:00,000 --> 00:15:03,120
versions

00:15:00,800 --> 00:15:04,480
of elasticsearch that tend to explode

00:15:03,120 --> 00:15:06,079
under load

00:15:04,480 --> 00:15:07,920
hopefully most people are on to at least

00:15:06,079 --> 00:15:10,959
six right now if not

00:15:07,920 --> 00:15:10,959
on to the latest seven

00:15:11,199 --> 00:15:14,480
i've been slowly rolling back some of

00:15:12,560 --> 00:15:17,519
the the safety features but

00:15:14,480 --> 00:15:18,800
um whenever i get a cluster out of

00:15:17,519 --> 00:15:20,800
memory error it makes me

00:15:18,800 --> 00:15:22,320
give a good pause to pulling back some

00:15:20,800 --> 00:15:24,560
of the stuff

00:15:22,320 --> 00:15:25,920
so um if you're developing a tool that

00:15:24,560 --> 00:15:27,360
you expect other people to use which was

00:15:25,920 --> 00:15:29,120
the case for this tool

00:15:27,360 --> 00:15:30,560
um it's important to have good

00:15:29,120 --> 00:15:34,480
documentation so

00:15:30,560 --> 00:15:35,600
es search has two documentation modes

00:15:34,480 --> 00:15:37,040
help we'll just give you a quick

00:15:35,600 --> 00:15:38,399
overview of all the

00:15:37,040 --> 00:15:40,800
command line switches and there are a

00:15:38,399 --> 00:15:43,600
lot of them and then

00:15:40,800 --> 00:15:44,320
manual will actually give you a full

00:15:43,600 --> 00:15:46,160
manual

00:15:44,320 --> 00:15:48,160
which includes all of the command line

00:15:46,160 --> 00:15:50,880
options all the switches

00:15:48,160 --> 00:15:52,959
and examples of how to use each one of

00:15:50,880 --> 00:15:54,079
them as well as full examples of these

00:15:52,959 --> 00:15:56,240
are some searches that we were

00:15:54,079 --> 00:15:57,360
using in our security and operations

00:15:56,240 --> 00:16:00,800
teams

00:15:57,360 --> 00:16:00,800
and you might find them useful too

00:16:01,279 --> 00:16:04,720
es search defaults to look to connecting

00:16:03,519 --> 00:16:08,240
to localhost

00:16:04,720 --> 00:16:09,199
port 9200 if you need to connect to

00:16:08,240 --> 00:16:12,000
another

00:16:09,199 --> 00:16:12,560
host other than that you just do host

00:16:12,000 --> 00:16:15,040
yes

00:16:12,560 --> 00:16:15,759
then the name but of course um like i

00:16:15,040 --> 00:16:18,720
said

00:16:15,759 --> 00:16:19,680
finite number of keystrokes um it has a

00:16:18,720 --> 00:16:21,199
dot file

00:16:19,680 --> 00:16:22,959
where you can specify all the connection

00:16:21,199 --> 00:16:24,079
details um these are all the main

00:16:22,959 --> 00:16:25,920
connection details

00:16:24,079 --> 00:16:28,320
so you can specify the host the port the

00:16:25,920 --> 00:16:30,240
protocol the default is http

00:16:28,320 --> 00:16:32,880
the default port is 9 200 default host

00:16:30,240 --> 00:16:33,839
is localhost and then if you use a basic

00:16:32,880 --> 00:16:35,759
authentication

00:16:33,839 --> 00:16:37,199
with your cluster you can specify the

00:16:35,759 --> 00:16:40,399
http username and then

00:16:37,199 --> 00:16:42,160
a a path to a script to exact to get the

00:16:40,399 --> 00:16:43,920
password out of one of your keychains

00:16:42,160 --> 00:16:45,519
so that you don't have to provide that

00:16:43,920 --> 00:16:49,360
all on the

00:16:45,519 --> 00:16:50,720
command line um

00:16:49,360 --> 00:16:52,160
as we go through this these are some

00:16:50,720 --> 00:16:53,440
things some assumptions have been made

00:16:52,160 --> 00:16:55,519
in the tooling that uh

00:16:53,440 --> 00:16:57,199
are just useful to know um searches are

00:16:55,519 --> 00:16:59,120
constrained by the

00:16:57,199 --> 00:17:01,120
calendar index date by default if you're

00:16:59,120 --> 00:17:02,160
using the default parameter of dash

00:17:01,120 --> 00:17:05,360
dashbase

00:17:02,160 --> 00:17:05,919
and dash dashbase is uh a index base

00:17:05,360 --> 00:17:08,319
name

00:17:05,919 --> 00:17:10,160
i just reassume that you put like data

00:17:08,319 --> 00:17:12,640
in like named indexes

00:17:10,160 --> 00:17:14,480
um so here you see dash dash based logs

00:17:12,640 --> 00:17:16,480
that's going to find anything that looks

00:17:14,480 --> 00:17:19,600
like a log sash index

00:17:16,480 --> 00:17:21,199
and add that into your your query um

00:17:19,600 --> 00:17:23,199
it defaults to looking at one day's

00:17:21,199 --> 00:17:25,600
worth of data but you can say

00:17:23,199 --> 00:17:27,199
um dash days seven for opening your

00:17:25,600 --> 00:17:29,840
scope up to seven days

00:17:27,199 --> 00:17:30,799
the searches will stop after they reach

00:17:29,840 --> 00:17:34,480
the default

00:17:30,799 --> 00:17:36,799
dash size which is 20 results so if they

00:17:34,480 --> 00:17:38,880
meet that result that um that total

00:17:36,799 --> 00:17:40,160
number of results in the first index it

00:17:38,880 --> 00:17:42,640
won't go back any further

00:17:40,160 --> 00:17:43,440
um you can use dash all to get all the

00:17:42,640 --> 00:17:44,960
results

00:17:43,440 --> 00:17:47,679
across the full time span that you

00:17:44,960 --> 00:17:49,520
specified sort orders descending based

00:17:47,679 --> 00:17:54,400
on the timestamp field

00:17:49,520 --> 00:17:56,559
you can override that with ascending

00:17:54,400 --> 00:17:58,320
and if you need to use this tool i do

00:17:56,559 --> 00:17:59,760
occasionally use this tool to look at

00:17:58,320 --> 00:18:00,720
other indexes that don't follow the

00:17:59,760 --> 00:18:03,600
state

00:18:00,720 --> 00:18:04,320
format you can specify that with dash

00:18:03,600 --> 00:18:06,320
index

00:18:04,320 --> 00:18:07,679
and you can use an alias or index you

00:18:06,320 --> 00:18:10,480
can also provide

00:18:07,679 --> 00:18:12,480
multiple indexes with commas and you can

00:18:10,480 --> 00:18:13,440
use wildcards in the dash dash index

00:18:12,480 --> 00:18:17,360
it's just passed

00:18:13,440 --> 00:18:19,679
to the url to the index

00:18:17,360 --> 00:18:21,039
position and url so anything you could

00:18:19,679 --> 00:18:24,080
do in kibana

00:18:21,039 --> 00:18:26,880
or in any other elastic tool

00:18:24,080 --> 00:18:26,880
you can use there

00:18:27,360 --> 00:18:30,640
so if we're getting started with like

00:18:29,120 --> 00:18:32,080
let's figure out what's going on i've

00:18:30,640 --> 00:18:33,600
got data and elasticsearch i know

00:18:32,080 --> 00:18:34,240
nothing about it the first thing that i

00:18:33,600 --> 00:18:36,320
want to do

00:18:34,240 --> 00:18:37,760
is figure out what are the bases that

00:18:36,320 --> 00:18:40,240
are available so

00:18:37,760 --> 00:18:41,360
when you run es search dash basis what

00:18:40,240 --> 00:18:44,480
happens is i

00:18:41,360 --> 00:18:45,440
the tool pulls all of the indexes that

00:18:44,480 --> 00:18:48,320
are available

00:18:45,440 --> 00:18:49,039
um and then it figures out what they

00:18:48,320 --> 00:18:51,360
look like

00:18:49,039 --> 00:18:52,640
um based on their index name and it'll

00:18:51,360 --> 00:18:54,880
provide you a list of

00:18:52,640 --> 00:18:56,480
base names that you can then target with

00:18:54,880 --> 00:18:58,480
the the command in this case there's

00:18:56,480 --> 00:19:01,840
three simple ones but if you use

00:18:58,480 --> 00:19:03,919
like data center ids in your with your

00:19:01,840 --> 00:19:06,880
index names you might see some of that

00:19:03,919 --> 00:19:09,039
um you might see like data center dash

00:19:06,880 --> 00:19:10,160
you know log stash and then also log

00:19:09,039 --> 00:19:14,080
stash because

00:19:10,160 --> 00:19:16,320
it'll figure all these things out um

00:19:14,080 --> 00:19:17,280
once you have the bases um you might

00:19:16,320 --> 00:19:20,559
want to say okay

00:19:17,280 --> 00:19:23,039
what is actually in this index so here

00:19:20,559 --> 00:19:25,840
i'm saying look in the syslog index

00:19:23,039 --> 00:19:27,360
and show me all the fields and what that

00:19:25,840 --> 00:19:28,320
might look like and this may be hard for

00:19:27,360 --> 00:19:29,919
you to read it's not

00:19:28,320 --> 00:19:31,840
super important that you can read every

00:19:29,919 --> 00:19:32,799
line on here but we're dumping all the

00:19:31,840 --> 00:19:34,080
field names

00:19:32,799 --> 00:19:36,720
and along with those field names we're

00:19:34,080 --> 00:19:38,960
also dumping out the

00:19:36,720 --> 00:19:40,080
data type so that we have some bearing

00:19:38,960 --> 00:19:43,120
as to

00:19:40,080 --> 00:19:44,080
what uh is in this index um and then at

00:19:43,120 --> 00:19:46,240
the very last

00:19:44,080 --> 00:19:47,120
um the very last two lines give you a

00:19:46,240 --> 00:19:49,760
breakdown

00:19:47,120 --> 00:19:51,120
of what actually um happened so we found

00:19:49,760 --> 00:19:54,799
43 fields

00:19:51,120 --> 00:19:57,120
in one index and we can see that

00:19:54,799 --> 00:20:00,960
there are 29 keyword fields etc so we

00:19:57,120 --> 00:20:04,240
get a summary of what's in this index

00:20:00,960 --> 00:20:06,080
so once you know what's in the index um

00:20:04,240 --> 00:20:08,080
just show me a document right just i

00:20:06,080 --> 00:20:09,679
want to see let me let me see what

00:20:08,080 --> 00:20:11,919
sample of what's in there

00:20:09,679 --> 00:20:13,679
um and for space i'm just using size one

00:20:11,919 --> 00:20:16,480
so that you can see the full output

00:20:13,679 --> 00:20:17,120
but here you can see um a few things

00:20:16,480 --> 00:20:19,039
first off

00:20:17,120 --> 00:20:21,120
um in the heading we see a warning

00:20:19,039 --> 00:20:22,960
timestamp field at time stamp not found

00:20:21,120 --> 00:20:24,559
using timestamp instead

00:20:22,960 --> 00:20:26,799
all these searches are based on the

00:20:24,559 --> 00:20:27,360
timestamp so it needs to know which

00:20:26,799 --> 00:20:29,919
field

00:20:27,360 --> 00:20:31,200
you're sorting on so if there's only one

00:20:29,919 --> 00:20:33,360
timestamp

00:20:31,200 --> 00:20:34,320
it can guess that and it does and it

00:20:33,360 --> 00:20:36,000
defaults to

00:20:34,320 --> 00:20:38,080
guessing the default log stash and

00:20:36,000 --> 00:20:38,880
elasticseo system timestamp which is at

00:20:38,080 --> 00:20:40,960
timestamp

00:20:38,880 --> 00:20:42,640
if it doesn't find that timestamp it

00:20:40,960 --> 00:20:44,720
will use the single

00:20:42,640 --> 00:20:46,960
timestamp field if there are more than

00:20:44,720 --> 00:20:48,559
one timestamps in an index

00:20:46,960 --> 00:20:50,400
then you will get a war you'll get an

00:20:48,559 --> 00:20:52,240
error and it will list all the timestamp

00:20:50,400 --> 00:20:55,360
fields and tell you to pick one

00:20:52,240 --> 00:20:57,679
um so yes we have data out

00:20:55,360 --> 00:20:59,919
um it's yaml uh we'll get to that in a

00:20:57,679 --> 00:21:02,000
second at the bottom you can see that

00:20:59,919 --> 00:21:03,600
we get a summary we're displaying one of

00:21:02,000 --> 00:21:06,480
36 25

00:21:03,600 --> 00:21:08,880
results and it took point 19 seconds to

00:21:06,480 --> 00:21:08,880
do that

00:21:09,360 --> 00:21:14,799
again um you know i don't like to type

00:21:12,640 --> 00:21:16,559
so we can specify the default number of

00:21:14,799 --> 00:21:18,480
days and the default base

00:21:16,559 --> 00:21:19,679
so we don't have to specify those on the

00:21:18,480 --> 00:21:22,720
command line

00:21:19,679 --> 00:21:25,760
and timestamp

00:21:22,720 --> 00:21:26,880
we can set the the timestamp via the

00:21:25,760 --> 00:21:28,960
command line

00:21:26,880 --> 00:21:31,039
or we can add that timestamp again into

00:21:28,960 --> 00:21:33,200
esutils

00:21:31,039 --> 00:21:34,960
so that this you won't have to provide

00:21:33,200 --> 00:21:37,039
that hint any longer

00:21:34,960 --> 00:21:38,720
um what if there's more than one base

00:21:37,039 --> 00:21:39,520
well that's fine we don't want you to

00:21:38,720 --> 00:21:42,000
type too much

00:21:39,520 --> 00:21:43,679
either if you add a meta section into

00:21:42,000 --> 00:21:45,760
the esutils you can say

00:21:43,679 --> 00:21:47,520
for the logs base name we're going to

00:21:45,760 --> 00:21:51,200
use timestamp at timestamp

00:21:47,520 --> 00:21:53,039
but for the rest of our indexes

00:21:51,200 --> 00:21:54,799
the default timestamp is timestamp

00:21:53,039 --> 00:21:56,960
without that at sign

00:21:54,799 --> 00:21:58,000
and you can list as many index base

00:21:56,960 --> 00:22:00,880
names there and

00:21:58,000 --> 00:22:01,679
timestamps as you need so back to the

00:22:00,880 --> 00:22:04,799
output

00:22:01,679 --> 00:22:06,640
um this is yaml

00:22:04,799 --> 00:22:07,919
and what you're saying right now is brad

00:22:06,640 --> 00:22:11,200
i hate yaml

00:22:07,919 --> 00:22:13,600
and yes i know you want logs

00:22:11,200 --> 00:22:15,520
so what we can do is we can tell es

00:22:13,600 --> 00:22:17,360
search which fields we want to see

00:22:15,520 --> 00:22:19,280
in the index so we do that with show and

00:22:17,360 --> 00:22:22,400
we give it a comma separated list

00:22:19,280 --> 00:22:24,640
of field names and when we do that

00:22:22,400 --> 00:22:27,280
we have logs this looks very familiar to

00:22:24,640 --> 00:22:29,840
anyone who's ever retailed a log file

00:22:27,280 --> 00:22:31,760
so that's kind of that's very refreshing

00:22:29,840 --> 00:22:35,360
everyone can breathe a sigh of relief we

00:22:31,760 --> 00:22:35,360
have logs from elasticsearch

00:22:35,600 --> 00:22:38,960
really the power of elasticsearch is

00:22:37,120 --> 00:22:42,080
being able to search things

00:22:38,960 --> 00:22:43,679
and we support the lucine query syntax

00:22:42,080 --> 00:22:45,919
by default so

00:22:43,679 --> 00:22:49,039
in this case we say the program field

00:22:45,919 --> 00:22:51,600
matches sshd

00:22:49,039 --> 00:22:52,240
we can then do this search and you can

00:22:51,600 --> 00:22:54,799
see

00:22:52,240 --> 00:22:55,760
the the parameter that i set to the

00:22:54,799 --> 00:22:57,120
command line

00:22:55,760 --> 00:22:59,440
and then down here in the search

00:22:57,120 --> 00:23:03,280
parameters i actually get an overview

00:22:59,440 --> 00:23:05,360
of the exact way that that search was

00:23:03,280 --> 00:23:06,559
provided to the backend so we see the

00:23:05,360 --> 00:23:08,799
query string

00:23:06,559 --> 00:23:10,640
parameter um which matches up with the

00:23:08,799 --> 00:23:12,880
elasticsearch documentation for this

00:23:10,640 --> 00:23:12,880
stuff

00:23:16,480 --> 00:23:22,240
but we what we do this tool was built

00:23:19,679 --> 00:23:24,240
out of security and operations um

00:23:22,240 --> 00:23:26,559
and we tend to build up queries as we're

00:23:24,240 --> 00:23:29,360
going along we narrow in we hone

00:23:26,559 --> 00:23:30,880
in on attributes in the logs that we're

00:23:29,360 --> 00:23:32,640
really interested in

00:23:30,880 --> 00:23:34,400
so we start out with a high level

00:23:32,640 --> 00:23:36,320
overview we find this

00:23:34,400 --> 00:23:37,919
needle in a haystack and then we add

00:23:36,320 --> 00:23:39,679
that in and then we see what else is

00:23:37,919 --> 00:23:42,400
there

00:23:39,679 --> 00:23:43,440
so being able to add multiple parameters

00:23:42,400 --> 00:23:45,440
is important

00:23:43,440 --> 00:23:46,480
and the mistake that we made a lot in

00:23:45,440 --> 00:23:48,080
our early days

00:23:46,480 --> 00:23:49,760
of working with this tool was forgetting

00:23:48,080 --> 00:23:53,120
to specify a conjunction so

00:23:49,760 --> 00:23:54,799
and or to join terms

00:23:53,120 --> 00:23:57,679
and we found out that we almost never

00:23:54,799 --> 00:24:00,720
used or when we were always using and

00:23:57,679 --> 00:24:03,760
so eserch.pl makes a way with the

00:24:00,720 --> 00:24:04,559
you having to specify and or and just

00:24:03,760 --> 00:24:06,960
assumes

00:24:04,559 --> 00:24:08,480
that any dangling search term will be

00:24:06,960 --> 00:24:10,480
joined with an and

00:24:08,480 --> 00:24:12,080
so here we have two search parameters

00:24:10,480 --> 00:24:15,200
instead of one

00:24:12,080 --> 00:24:16,320
and you can see in the the um command

00:24:15,200 --> 00:24:19,360
line we are missing that

00:24:16,320 --> 00:24:22,640
and that is proper but down here in the

00:24:19,360 --> 00:24:25,279
search parameters um it joined that with

00:24:22,640 --> 00:24:28,640
an and for us so that we don't have to

00:24:25,279 --> 00:24:32,080
pull our hair out this just makes

00:24:28,640 --> 00:24:35,120
again fewer keystrokes um if

00:24:32,080 --> 00:24:36,159
you're if you are one of the people who

00:24:35,120 --> 00:24:38,320
somehow

00:24:36,159 --> 00:24:39,840
enjoys wearing everything um you can use

00:24:38,320 --> 00:24:41,120
dash dash or to change the default

00:24:39,840 --> 00:24:43,440
operator to or

00:24:41,120 --> 00:24:44,960
um i would probably advise you to be

00:24:43,440 --> 00:24:48,000
explicit and use or

00:24:44,960 --> 00:24:50,320
as inside of your query um

00:24:48,000 --> 00:24:51,520
because doing the multiple joins gets

00:24:50,320 --> 00:24:53,440
really weird and

00:24:51,520 --> 00:24:54,720
you want to use parentheses and all that

00:24:53,440 --> 00:24:56,480
stuff to to make sure you're doing the

00:24:54,720 --> 00:24:59,360
right thing

00:24:56,480 --> 00:25:01,200
but here when i use or again with the

00:24:59,360 --> 00:25:03,279
same parameters i had before i get a

00:25:01,200 --> 00:25:04,960
much wider search scope but you can see

00:25:03,279 --> 00:25:08,000
that we joined with or instead of

00:25:04,960 --> 00:25:08,000
joining with and

00:25:08,240 --> 00:25:13,440
and if you're of the opinion that

00:25:11,279 --> 00:25:14,400
um you want to do all the stuff in the

00:25:13,440 --> 00:25:17,279
command line

00:25:14,400 --> 00:25:18,000
um anyways um and you want to use jq to

00:25:17,279 --> 00:25:20,000
do that

00:25:18,000 --> 00:25:21,520
that's cool i've got your back there if

00:25:20,000 --> 00:25:23,760
you specified

00:25:21,520 --> 00:25:25,520
jq all the decorations that we've seen

00:25:23,760 --> 00:25:27,120
in the previous slides will be removed

00:25:25,520 --> 00:25:30,640
and all you'll get back

00:25:27,120 --> 00:25:32,480
are the actual raw document results in

00:25:30,640 --> 00:25:35,679
new line delimited json form and then

00:25:32,480 --> 00:25:37,760
you can use your jq tools to do

00:25:35,679 --> 00:25:40,080
all kinds of stuff so here you can see

00:25:37,760 --> 00:25:43,440
that we just

00:25:40,080 --> 00:25:47,039
said use jq format and boom now we can

00:25:43,440 --> 00:25:50,000
just extract out the ip addresses

00:25:47,039 --> 00:25:51,200
um as we were working with this tool it

00:25:50,000 --> 00:25:52,240
started to become more difficult to

00:25:51,200 --> 00:25:53,840
represent

00:25:52,240 --> 00:25:55,679
some of the queries we wanted to make

00:25:53,840 --> 00:25:57,360
because our knowledge of elasticsearch

00:25:55,679 --> 00:25:59,039
was growing and our

00:25:57,360 --> 00:26:00,799
use cases were growing so we needed to

00:25:59,039 --> 00:26:03,039
do more complex things

00:26:00,799 --> 00:26:04,159
so as that happened i started adding a

00:26:03,039 --> 00:26:07,039
plug-in system

00:26:04,159 --> 00:26:08,480
to this tool so that we could take

00:26:07,039 --> 00:26:10,320
tokens that were coming in on the

00:26:08,480 --> 00:26:11,440
command line and expand them out into

00:26:10,320 --> 00:26:14,159
elasticsearch

00:26:11,440 --> 00:26:15,679
conventions in the back end and the

00:26:14,159 --> 00:26:17,679
query

00:26:15,679 --> 00:26:19,440
the first one is very simple it was a

00:26:17,679 --> 00:26:20,480
mistake we made a lot which was not

00:26:19,440 --> 00:26:23,200
capitalizing and

00:26:20,480 --> 00:26:24,159
or not so if you don't capitalize and or

00:26:23,200 --> 00:26:26,159
not

00:26:24,159 --> 00:26:27,840
it will be capitalized for you so that

00:26:26,159 --> 00:26:29,440
it passes the leucine syntax

00:26:27,840 --> 00:26:32,159
and does the thing that you expect it to

00:26:29,440 --> 00:26:33,440
do um this is a do what i mean kind of

00:26:32,159 --> 00:26:35,279
principle that i

00:26:33,440 --> 00:26:37,200
borrow heavily from pearl so here you

00:26:35,279 --> 00:26:41,039
can see i have a lowercase

00:26:37,200 --> 00:26:43,279
not in my um parameter and then

00:26:41,039 --> 00:26:44,400
when i actually go down to the search

00:26:43,279 --> 00:26:46,000
parameter the

00:26:44,400 --> 00:26:48,400
the search parameter has been uppercase

00:26:46,000 --> 00:26:50,400
so that it does the right thing

00:26:48,400 --> 00:26:52,320
security and operations people work a

00:26:50,400 --> 00:26:54,080
lot with ip addresses and we like to

00:26:52,320 --> 00:26:55,039
group those ip addresses using slider

00:26:54,080 --> 00:26:56,799
notation

00:26:55,039 --> 00:26:58,799
um so that's not something that's

00:26:56,799 --> 00:27:00,320
natively supported by elasticsearch you

00:26:58,799 --> 00:27:02,880
need to use a range query

00:27:00,320 --> 00:27:04,400
so if elasticsearch if esearch.pl

00:27:02,880 --> 00:27:05,039
determines that there is a token that

00:27:04,400 --> 00:27:07,279
looks like

00:27:05,039 --> 00:27:09,039
cider notation in your query it will go

00:27:07,279 --> 00:27:10,080
ahead and it'll expand that to a range

00:27:09,039 --> 00:27:11,919
query

00:27:10,080 --> 00:27:13,440
so here you can see that i specified

00:27:11,919 --> 00:27:15,520
insider notation

00:27:13,440 --> 00:27:17,679
um another thing that i wanted to show

00:27:15,520 --> 00:27:20,240
is if you specify an

00:27:17,679 --> 00:27:21,840
show a field that is uh actually

00:27:20,240 --> 00:27:24,960
contains structured data

00:27:21,840 --> 00:27:26,320
when you do the show um you'll get that

00:27:24,960 --> 00:27:30,080
structured data back

00:27:26,320 --> 00:27:32,000
so it'll jsonify that structured data

00:27:30,080 --> 00:27:35,039
and here you can see on search

00:27:32,000 --> 00:27:38,159
parameters that our

00:27:35,039 --> 00:27:40,720
cybernotation was transformed into a

00:27:38,159 --> 00:27:43,200
native elastic search range query and

00:27:40,720 --> 00:27:46,559
the villagers rejoiced

00:27:43,200 --> 00:27:49,440
range queries are supported

00:27:46,559 --> 00:27:50,480
for numeric data as well and for dates

00:27:49,440 --> 00:27:52,640
so you can

00:27:50,480 --> 00:27:54,240
um specify greater than less than

00:27:52,640 --> 00:27:57,279
greater than equal to

00:27:54,240 --> 00:28:00,080
less than equal to um the catch here

00:27:57,279 --> 00:28:00,960
is these characters have special meaning

00:28:00,080 --> 00:28:04,880
in the shell

00:28:00,960 --> 00:28:07,440
so you need to shell escape them um so

00:28:04,880 --> 00:28:08,320
here we do a range query of greater than

00:28:07,440 --> 00:28:10,960
five

00:28:08,320 --> 00:28:11,679
and it's transformed into a native range

00:28:10,960 --> 00:28:14,399
query

00:28:11,679 --> 00:28:14,399
in es search

00:28:14,880 --> 00:28:18,480
some things are hard to escape i don't

00:28:16,640 --> 00:28:20,240
know if anyone has ever attempted to

00:28:18,480 --> 00:28:23,440
search elastic search for

00:28:20,240 --> 00:28:24,000
a user agent um without using term

00:28:23,440 --> 00:28:26,880
filter

00:28:24,000 --> 00:28:28,480
and using machine query syntax but it is

00:28:26,880 --> 00:28:31,600
maddening

00:28:28,480 --> 00:28:33,760
so one of the optimizations that i added

00:28:31,600 --> 00:28:34,320
was if you prefix a field with an equal

00:28:33,760 --> 00:28:36,799
sign

00:28:34,320 --> 00:28:38,960
which you'll need to escape in zsh with

00:28:36,799 --> 00:28:43,600
a backslash because equal sign has

00:28:38,960 --> 00:28:45,760
a special meaning in in zsh um

00:28:43,600 --> 00:28:47,279
then everything that comes after the

00:28:45,760 --> 00:28:50,960
field name will be

00:28:47,279 --> 00:28:54,399
promoted to a terms query so here we see

00:28:50,960 --> 00:28:56,159
that i specified the equal um

00:28:54,399 --> 00:28:58,399
and then down in the search parameters

00:28:56,159 --> 00:29:00,080
instead of being a query string query we

00:28:58,399 --> 00:29:02,720
now have a term query

00:29:00,080 --> 00:29:06,080
and we match the document that actually

00:29:02,720 --> 00:29:06,080
has that exact match

00:29:06,399 --> 00:29:09,520
there's a few underscore search

00:29:08,320 --> 00:29:11,360
parameters that

00:29:09,520 --> 00:29:13,279
leucine syntax supports underscore

00:29:11,360 --> 00:29:15,120
exists underscore missing

00:29:13,279 --> 00:29:17,120
um so one of the things that we were

00:29:15,120 --> 00:29:17,840
doing is underscore prefix and it didn't

00:29:17,120 --> 00:29:20,399
exist

00:29:17,840 --> 00:29:22,000
um so i created it if you do underscore

00:29:20,399 --> 00:29:25,200
prefix

00:29:22,000 --> 00:29:29,679
you will get the translation

00:29:25,200 --> 00:29:29,679
to a prefix query automatically

00:29:30,159 --> 00:29:34,799
um again security and operations people

00:29:32,399 --> 00:29:37,120
we carry around text files full of data

00:29:34,799 --> 00:29:38,960
and sometimes we need to take a column

00:29:37,120 --> 00:29:43,200
of that data and then use that as

00:29:38,960 --> 00:29:45,279
a feed for our query so

00:29:43,200 --> 00:29:46,559
i added the support for being able to

00:29:45,279 --> 00:29:49,360
pull data out of

00:29:46,559 --> 00:29:50,880
structured text files so this will work

00:29:49,360 --> 00:29:52,240
with tab delimited files white space

00:29:50,880 --> 00:29:55,520
delimited files

00:29:52,240 --> 00:29:57,440
comma separated files and json a new

00:29:55,520 --> 00:29:59,520
line delimited json files

00:29:57,440 --> 00:30:00,600
um so in this in these few examples we

00:29:59,520 --> 00:30:03,520
have a file called

00:30:00,600 --> 00:30:04,480
badguys.dat which has some ip addresses

00:30:03,520 --> 00:30:07,039
in it

00:30:04,480 --> 00:30:07,600
what it will do is it'll columnize the

00:30:07,039 --> 00:30:09,200
data

00:30:07,600 --> 00:30:11,279
and then it will default to pulling the

00:30:09,200 --> 00:30:15,279
last column of the data

00:30:11,279 --> 00:30:17,679
um pulling all those rows uniqueing them

00:30:15,279 --> 00:30:18,480
and then translating that into a terms

00:30:17,679 --> 00:30:19,919
query

00:30:18,480 --> 00:30:21,279
if you don't want the last column but

00:30:19,919 --> 00:30:22,399
you want a different column you can

00:30:21,279 --> 00:30:24,559
specify that using the

00:30:22,399 --> 00:30:26,159
rate zero based array syntax um because

00:30:24,559 --> 00:30:27,039
it's just an array and you can access

00:30:26,159 --> 00:30:29,120
any of the

00:30:27,039 --> 00:30:30,480
the array syntax there so let's take a

00:30:29,120 --> 00:30:31,200
look at what that looks like so here i

00:30:30,480 --> 00:30:34,640
have

00:30:31,200 --> 00:30:36,240
badguys.dat and um i have some ip

00:30:34,640 --> 00:30:39,039
addresses in the last column

00:30:36,240 --> 00:30:40,840
so what i do is i run the search program

00:30:39,039 --> 00:30:43,679
iptables

00:30:40,840 --> 00:30:46,000
sourceipad guys.dat

00:30:43,679 --> 00:30:47,120
and then show these fields and then you

00:30:46,000 --> 00:30:50,320
can see here

00:30:47,120 --> 00:30:50,960
in the search parameters that i have a

00:30:50,320 --> 00:30:54,159
terms

00:30:50,960 --> 00:30:55,039
uh query and it contains all the ip

00:30:54,159 --> 00:30:58,960
addresses

00:30:55,039 --> 00:30:58,960
that were in my um

00:30:59,440 --> 00:31:05,919
badges.data file

00:31:04,320 --> 00:31:08,480
this also works with newline delimited

00:31:05,919 --> 00:31:11,840
json of course you probably have

00:31:08,480 --> 00:31:14,159
like hash data or object data

00:31:11,840 --> 00:31:14,880
in those files so you would use the key

00:31:14,159 --> 00:31:16,640
name

00:31:14,880 --> 00:31:19,440
in between the brackets if you have

00:31:16,640 --> 00:31:23,760
nested keys you can use

00:31:19,440 --> 00:31:23,760
the the dot to represent the nesting

00:31:24,320 --> 00:31:26,720
all right

00:31:28,720 --> 00:31:32,799
but the real power of elasticsearch

00:31:30,880 --> 00:31:36,799
isn't in these like arbitrary queries

00:31:32,799 --> 00:31:39,200
um it's fun but looking at larger

00:31:36,799 --> 00:31:40,320
uh groups of data and aggregating that

00:31:39,200 --> 00:31:42,480
data into

00:31:40,320 --> 00:31:43,519
ways that we can understand is really

00:31:42,480 --> 00:31:46,960
what we want

00:31:43,519 --> 00:31:48,720
um so elasticsearch the esr ipl

00:31:46,960 --> 00:31:51,039
comes with the ability to do

00:31:48,720 --> 00:31:52,559
aggregations there's a couple of caveats

00:31:51,039 --> 00:31:53,279
with aggregations because like i said

00:31:52,559 --> 00:31:56,080
this was built

00:31:53,279 --> 00:31:57,440
in a very exploding version of

00:31:56,080 --> 00:31:59,120
elasticsearch

00:31:57,440 --> 00:32:01,200
back when they were called facets and

00:31:59,120 --> 00:32:04,080
they would kill your cluster

00:32:01,200 --> 00:32:05,039
if you did them so there are a few uh

00:32:04,080 --> 00:32:07,600
restrictions

00:32:05,039 --> 00:32:08,640
um i've backed off a lot of them um and

00:32:07,600 --> 00:32:11,120
i'm still working

00:32:08,640 --> 00:32:13,200
on what makes sense to remove so that

00:32:11,120 --> 00:32:14,320
this default experience is positive for

00:32:13,200 --> 00:32:16,399
users

00:32:14,320 --> 00:32:18,720
as well as figuring out how to make some

00:32:16,399 --> 00:32:18,720
you know

00:32:18,799 --> 00:32:22,240
super user switches that say you know

00:32:21,440 --> 00:32:26,640
i'm okay with

00:32:22,240 --> 00:32:29,279
if you kill my cluster um so

00:32:26,640 --> 00:32:31,360
the default to running the aggregations

00:32:29,279 --> 00:32:35,519
on those calendar day indexes

00:32:31,360 --> 00:32:38,240
um instead of doing them against um

00:32:35,519 --> 00:32:40,880
the full range you'll you'll do them as

00:32:38,240 --> 00:32:42,559
the result would would be par so you

00:32:40,880 --> 00:32:44,000
we do the first aggregation set on the

00:32:42,559 --> 00:32:45,360
first day's worth of data and then

00:32:44,000 --> 00:32:47,360
second aggregation set on the second

00:32:45,360 --> 00:32:49,679
day's worth of data and combine those

00:32:47,360 --> 00:32:51,840
results it's not perfect but it did

00:32:49,679 --> 00:32:54,240
protect the cluster from exploding by

00:32:51,840 --> 00:32:55,440
by not engaging as many shards at one

00:32:54,240 --> 00:32:57,200
time

00:32:55,440 --> 00:32:58,640
the top aggregation has to be a bucket

00:32:57,200 --> 00:33:00,399
aggregation right now

00:32:58,640 --> 00:33:02,720
terms and significant terms are really

00:33:00,399 --> 00:33:04,399
the ones that work best

00:33:02,720 --> 00:33:06,799
the rest of the bucket aggregations

00:33:04,399 --> 00:33:08,480
haven't been quite as well tested

00:33:06,799 --> 00:33:10,080
and it is currently limited to two

00:33:08,480 --> 00:33:12,880
levels of aggregate of

00:33:10,080 --> 00:33:14,159
aggregations with a special case for a

00:33:12,880 --> 00:33:16,720
third

00:33:14,159 --> 00:33:18,960
level but i'm looking at rolling that

00:33:16,720 --> 00:33:22,480
back as well

00:33:18,960 --> 00:33:24,799
so to do that we just do eserch.pl

00:33:22,480 --> 00:33:26,480
top program to get the top program name

00:33:24,799 --> 00:33:27,919
um that will give us top 20 because

00:33:26,480 --> 00:33:29,600
that's the default size

00:33:27,919 --> 00:33:31,279
if we want to change the amount number

00:33:29,600 --> 00:33:34,480
of results we're seeing we can use dash

00:33:31,279 --> 00:33:35,200
size any number limit and all these

00:33:34,480 --> 00:33:37,760
things are

00:33:35,200 --> 00:33:39,600
the same parameter so we can get the top

00:33:37,760 --> 00:33:42,159
50 if we wanted to

00:33:39,600 --> 00:33:43,360
so if we do this search to see the top

00:33:42,159 --> 00:33:45,360
program

00:33:43,360 --> 00:33:47,679
we get the list of top programs down

00:33:45,360 --> 00:33:51,120
here we see that we're displaying 20 of

00:33:47,679 --> 00:33:52,799
41s there are 41 distinct programs

00:33:51,120 --> 00:33:54,440
and we're displaying the top 20 of them

00:33:52,799 --> 00:33:58,399
and our query matched

00:33:54,440 --> 00:33:58,399
158 000 documents

00:33:58,720 --> 00:34:02,240
um special case aggregation that's

00:34:00,720 --> 00:34:04,640
supported beyond two

00:34:02,240 --> 00:34:06,640
levels of aggregation is interval um if

00:34:04,640 --> 00:34:08,879
we wanted to

00:34:06,640 --> 00:34:10,320
if we see a spike in something sometimes

00:34:08,879 --> 00:34:12,720
we want to be able to say what caused

00:34:10,320 --> 00:34:14,720
that spike or what changed in that spike

00:34:12,720 --> 00:34:16,560
so we might do an interval one hour

00:34:14,720 --> 00:34:19,679
interval of 10 minutes an interval

00:34:16,560 --> 00:34:22,960
five minutes to see you know what

00:34:19,679 --> 00:34:23,599
what changed in the top results as we

00:34:22,960 --> 00:34:26,320
hit this

00:34:23,599 --> 00:34:27,440
spike uh to help narrow in on it and

00:34:26,320 --> 00:34:30,879
what that looks like in

00:34:27,440 --> 00:34:33,119
the terminal is um each each line has

00:34:30,879 --> 00:34:34,639
a bucket uh that tells you the start

00:34:33,119 --> 00:34:37,760
point of the

00:34:34,639 --> 00:34:39,359
bucket and then the count of the objects

00:34:37,760 --> 00:34:41,919
inside of that bucket

00:34:39,359 --> 00:34:43,119
so here you can see we have all the the

00:34:41,919 --> 00:34:46,879
um

00:34:43,119 --> 00:34:52,079
the buckets for this um one range

00:34:46,879 --> 00:34:52,079
for this one index um

00:34:53,440 --> 00:34:56,639
we can support other aggregation levels

00:34:55,839 --> 00:34:59,680
so

00:34:56,639 --> 00:35:03,040
if we wanted to get the top action with

00:34:59,680 --> 00:35:03,680
the top three source uh countries um we

00:35:03,040 --> 00:35:05,599
can do that

00:35:03,680 --> 00:35:06,720
um this sub aggregation is limited to

00:35:05,599 --> 00:35:09,359
three results per

00:35:06,720 --> 00:35:10,640
um set by default but you can change

00:35:09,359 --> 00:35:12,880
that by using a colon

00:35:10,640 --> 00:35:14,160
after the field name to give you a count

00:35:12,880 --> 00:35:17,520
of the

00:35:14,160 --> 00:35:20,640
um sub aggregations you'd like to see so

00:35:17,520 --> 00:35:22,560
the first example is um the top actions

00:35:20,640 --> 00:35:26,320
of the top 20 actions

00:35:22,560 --> 00:35:27,760
with the top three um source ips

00:35:26,320 --> 00:35:29,920
or source countries so that would give

00:35:27,760 --> 00:35:31,599
you 60 results

00:35:29,920 --> 00:35:33,760
and then the bottom one would give you

00:35:31,599 --> 00:35:36,720
200 results

00:35:33,760 --> 00:35:38,240
um so also three was chosen just because

00:35:36,720 --> 00:35:39,440
it would help minimize the amount of

00:35:38,240 --> 00:35:40,800
data on your screen so you could

00:35:39,440 --> 00:35:42,880
actually make some sort of distinction

00:35:40,800 --> 00:35:45,839
about what you want to do with that data

00:35:42,880 --> 00:35:46,480
and what that looks like is um here i've

00:35:45,839 --> 00:35:49,440
done a

00:35:46,480 --> 00:35:50,720
n3 just for conciseness to to fit in

00:35:49,440 --> 00:35:54,000
this slide without

00:35:50,720 --> 00:35:57,040
tons of data um here we can see

00:35:54,000 --> 00:36:00,240
blocks of three um the action here

00:35:57,040 --> 00:36:03,839
is block there are 97

00:36:00,240 --> 00:36:05,440
58 block actions and then we can get a

00:36:03,839 --> 00:36:07,920
breakdown by source ip

00:36:05,440 --> 00:36:08,680
and so we can see that this source ip

00:36:07,920 --> 00:36:11,520
had

00:36:08,680 --> 00:36:14,079
1700 of those blocks

00:36:11,520 --> 00:36:14,560
and then the next block is pass we can

00:36:14,079 --> 00:36:17,920
see

00:36:14,560 --> 00:36:21,119
um all the the top three source ips for

00:36:17,920 --> 00:36:21,119
the pass action as well

00:36:21,359 --> 00:36:24,640
um if we wanted to change that like i

00:36:23,359 --> 00:36:27,040
said to

00:36:24,640 --> 00:36:28,560
get 10 results i dropped the dash n to 1

00:36:27,040 --> 00:36:29,520
so we're only seeing the top which is

00:36:28,560 --> 00:36:32,800
block

00:36:29,520 --> 00:36:38,480
um but now we get 10 source ips

00:36:32,800 --> 00:36:38,480
of the the top for that action

00:36:39,520 --> 00:36:44,000
of course you're not always looking for

00:36:42,160 --> 00:36:44,960
the top by document count sometimes you

00:36:44,000 --> 00:36:48,560
want to use

00:36:44,960 --> 00:36:51,280
um you want to look at the top by some

00:36:48,560 --> 00:36:52,880
other parameter so in this case um if we

00:36:51,280 --> 00:36:54,000
wanted to see the top source ip by

00:36:52,880 --> 00:36:56,240
distinct destination

00:36:54,000 --> 00:36:57,200
countries we can say give me the top

00:36:56,240 --> 00:37:00,400
source ip by

00:36:57,200 --> 00:37:02,960
cardinality dust goip country

00:37:00,400 --> 00:37:03,920
we can also use any single stack

00:37:02,960 --> 00:37:07,359
aggregation

00:37:03,920 --> 00:37:11,200
so we can also use sum min max

00:37:07,359 --> 00:37:11,599
median and another example here of using

00:37:11,200 --> 00:37:15,040
some

00:37:11,599 --> 00:37:18,079
without with the amount of data so

00:37:15,040 --> 00:37:21,760
here we have the cardinality of the

00:37:18,079 --> 00:37:22,160
destination gop country and we can see

00:37:21,760 --> 00:37:25,359
that

00:37:22,160 --> 00:37:30,400
um the top result has hit 45 uh

00:37:25,359 --> 00:37:32,960
countries um in 1800 documents

00:37:30,400 --> 00:37:33,760
and then the next one down has hit 14

00:37:32,960 --> 00:37:36,640
countries

00:37:33,760 --> 00:37:37,440
and 89 documents and then you can see

00:37:36,640 --> 00:37:39,359
there's

00:37:37,440 --> 00:37:41,200
this first column is the cardinality the

00:37:39,359 --> 00:37:43,280
second column is the number of documents

00:37:41,200 --> 00:37:44,560
so we're sorting first by the

00:37:43,280 --> 00:37:47,599
cardinality and then

00:37:44,560 --> 00:37:48,720
second the second one is by number of

00:37:47,599 --> 00:37:50,240
documents

00:37:48,720 --> 00:37:53,040
so you can still see the most popular

00:37:50,240 --> 00:37:53,040
documents there

00:37:53,200 --> 00:37:56,560
and then again here's an example using

00:37:55,119 --> 00:38:00,079
that sum where we

00:37:56,560 --> 00:38:01,200
we count the data and we can see the the

00:38:00,079 --> 00:38:05,839
top desk ip

00:38:01,200 --> 00:38:08,240
with um by the sum

00:38:05,839 --> 00:38:09,599
and if we wanted to we can kind of put

00:38:08,240 --> 00:38:11,359
these two things together

00:38:09,599 --> 00:38:12,720
so that we can you know maybe have a

00:38:11,359 --> 00:38:13,599
little bit of an understanding of what's

00:38:12,720 --> 00:38:16,880
going on

00:38:13,599 --> 00:38:19,520
so we can look at the top source ip by

00:38:16,880 --> 00:38:20,960
the most amount of data sent out and

00:38:19,520 --> 00:38:24,320
then look at the top

00:38:20,960 --> 00:38:25,680
hit for that destination ip so we get a

00:38:24,320 --> 00:38:26,720
little bit more context from what's

00:38:25,680 --> 00:38:29,440
going on

00:38:26,720 --> 00:38:31,200
and what that looks like is this we have

00:38:29,440 --> 00:38:33,599
the sum of the data

00:38:31,200 --> 00:38:35,280
and then we have the number of hits

00:38:33,599 --> 00:38:36,800
followed by a percentage of the total

00:38:35,280 --> 00:38:40,240
number of documents

00:38:36,800 --> 00:38:42,880
the source ip and then we get this deskt

00:38:40,240 --> 00:38:44,480
and then the number of documents and the

00:38:42,880 --> 00:38:47,920
percentage of that bucket

00:38:44,480 --> 00:38:50,400
that um that makes that

00:38:47,920 --> 00:38:52,160
the percentage of the encompassing

00:38:50,400 --> 00:38:55,680
bucket so in this case it's

00:38:52,160 --> 00:38:59,359
28 of the total data for this source ip

00:38:55,680 --> 00:39:02,400
of 148 251 1468.

00:38:59,359 --> 00:39:05,200
so that helps us kind of um get it get

00:39:02,400 --> 00:39:05,200
some data but

00:39:05,680 --> 00:39:09,680
we might be interested in statistical

00:39:07,760 --> 00:39:12,320
analysis of some of the data um

00:39:09,680 --> 00:39:14,079
so like and this index that i'm working

00:39:12,320 --> 00:39:17,119
with i i created i know

00:39:14,079 --> 00:39:18,000
that the total time field is actually

00:39:17,119 --> 00:39:21,359
the total time

00:39:18,000 --> 00:39:24,640
for parsing the raw syslog element

00:39:21,359 --> 00:39:27,359
into a structured

00:39:24,640 --> 00:39:29,680
structured document so if i were looking

00:39:27,359 --> 00:39:32,320
at the performance of these parsers

00:39:29,680 --> 00:39:34,000
the parsers are keyed off program so i

00:39:32,320 --> 00:39:35,680
would want to see all the programs and i

00:39:34,000 --> 00:39:38,720
want to see the slowest

00:39:35,680 --> 00:39:39,680
program parser so i would use by average

00:39:38,720 --> 00:39:41,680
total time

00:39:39,680 --> 00:39:42,720
and then i can get stats total time so i

00:39:41,680 --> 00:39:45,040
can say give me

00:39:42,720 --> 00:39:48,160
the top program by average total time

00:39:45,040 --> 00:39:49,760
with the stats from the total time

00:39:48,160 --> 00:39:52,400
and this is a little bit more robust

00:39:49,760 --> 00:39:55,040
output because there's a lot of data to

00:39:52,400 --> 00:39:56,800
display so here we can see that the

00:39:55,040 --> 00:39:59,839
iptables

00:39:56,800 --> 00:40:00,720
program parser is the slowest and its

00:39:59,839 --> 00:40:04,400
average

00:40:00,720 --> 00:40:08,400
time is about .013

00:40:04,400 --> 00:40:11,040
seconds and it's 241 documents and the

00:40:08,400 --> 00:40:15,200
minimum amount of time is 0.006

00:40:11,040 --> 00:40:17,359
um and then the max time is 0.0.02

00:40:15,200 --> 00:40:18,880
and the total time spent to that parser

00:40:17,359 --> 00:40:21,040
is three seconds

00:40:18,880 --> 00:40:22,079
so um this gives us kind of an overview

00:40:21,040 --> 00:40:25,359
of what the

00:40:22,079 --> 00:40:27,760
parsing looks like for these parsers

00:40:25,359 --> 00:40:29,119
but of course if you are a fan of

00:40:27,760 --> 00:40:32,319
statistics you know

00:40:29,119 --> 00:40:33,839
that's not this descriptive statistics

00:40:32,319 --> 00:40:37,040
do not stop at average

00:40:33,839 --> 00:40:38,160
min and max um and percentiles are much

00:40:37,040 --> 00:40:40,480
better way of

00:40:38,160 --> 00:40:42,319
viewing data so here we can specify

00:40:40,480 --> 00:40:43,839
percentiles of the total time

00:40:42,319 --> 00:40:45,440
and then add a third parameter which are

00:40:43,839 --> 00:40:49,280
the percentiles we want to see

00:40:45,440 --> 00:40:52,240
in this case the median or 50 90 and 99

00:40:49,280 --> 00:40:54,319
and then we get that data as well so we

00:40:52,240 --> 00:40:55,760
can get a better sense of the shape of

00:40:54,319 --> 00:40:58,640
the data

00:40:55,760 --> 00:41:00,480
but if we wanted to really know the data

00:40:58,640 --> 00:41:01,280
we would want to look at a histogram of

00:41:00,480 --> 00:41:05,480
the data

00:41:01,280 --> 00:41:08,480
and so yeah search.pl provides

00:41:05,480 --> 00:41:10,000
a way to display histograms of data in

00:41:08,480 --> 00:41:12,319
the terminal

00:41:10,000 --> 00:41:13,920
it's not yet bar graphs but it's

00:41:12,319 --> 00:41:16,400
something

00:41:13,920 --> 00:41:17,359
and one day it may be bar graphs it's on

00:41:16,400 --> 00:41:19,200
the list

00:41:17,359 --> 00:41:21,359
so here i'm saying i want a histogram of

00:41:19,200 --> 00:41:23,079
the total time and i want each bucket of

00:41:21,359 --> 00:41:26,560
the histogram to represent

00:41:23,079 --> 00:41:29,119
0.01 seconds

00:41:26,560 --> 00:41:30,640
and that's this is what you end up with

00:41:29,119 --> 00:41:32,240
you will get a result

00:41:30,640 --> 00:41:34,240
so here you can see the top result is

00:41:32,240 --> 00:41:36,079
the ip tables we have three buckets in

00:41:34,240 --> 00:41:36,800
the histogram from zero to point zero

00:41:36,079 --> 00:41:39,839
one

00:41:36,800 --> 00:41:40,160
zero point point zero one to point zero

00:41:39,839 --> 00:41:43,280
two

00:41:40,160 --> 00:41:45,839
and point zero two to point zero three

00:41:43,280 --> 00:41:47,280
so we get an overview of how many

00:41:45,839 --> 00:41:48,720
documents were in each one of these

00:41:47,280 --> 00:41:51,359
buckets and we can see that

00:41:48,720 --> 00:41:52,000
the most documents were in point zero

00:41:51,359 --> 00:41:54,240
one

00:41:52,000 --> 00:41:55,680
so we know between point zero one and

00:41:54,240 --> 00:41:57,440
point zero two is that is

00:41:55,680 --> 00:41:58,720
where it takes the most that's where

00:41:57,440 --> 00:42:01,200
most of the documents fall

00:41:58,720 --> 00:42:02,000
so that can be helpful in understanding

00:42:01,200 --> 00:42:03,520
the performance

00:42:02,000 --> 00:42:06,319
of some things that you have in

00:42:03,520 --> 00:42:08,560
elasticsearch um

00:42:06,319 --> 00:42:09,599
you can also do significant terms in the

00:42:08,560 --> 00:42:11,440
in the top

00:42:09,599 --> 00:42:13,359
aggregation i didn't really have a good

00:42:11,440 --> 00:42:14,319
example to show this in the indexes that

00:42:13,359 --> 00:42:16,720
i was using for

00:42:14,319 --> 00:42:17,839
a demo but you can also specify the

00:42:16,720 --> 00:42:20,880
background filter

00:42:17,839 --> 00:42:22,480
so in the top one the background is the

00:42:20,880 --> 00:42:24,960
rest of the data set

00:42:22,480 --> 00:42:26,400
and then in the second field here when

00:42:24,960 --> 00:42:27,760
we use a bg filter

00:42:26,400 --> 00:42:29,520
the background that's being used for

00:42:27,760 --> 00:42:32,480
computation of significance

00:42:29,520 --> 00:42:33,520
is limited to documents that match the

00:42:32,480 --> 00:42:36,079
source ip

00:42:33,520 --> 00:42:37,839
or source country of us um so that's

00:42:36,079 --> 00:42:42,400
that's also handy when you're doing

00:42:37,839 --> 00:42:42,400
um security and operation stuff

00:42:42,720 --> 00:42:48,480
one more thing um or more i'm not sure

00:42:46,240 --> 00:42:50,000
um this is built with cli helpers um

00:42:48,480 --> 00:42:51,119
it's a library for developing command

00:42:50,000 --> 00:42:52,800
line utilities

00:42:51,119 --> 00:42:54,560
um it will auto detect whether or not

00:42:52,800 --> 00:42:56,800
you have git colors enabled and enable

00:42:54,560 --> 00:42:59,920
color output which you've seen in my

00:42:56,800 --> 00:43:01,839
screens it provides the data file

00:42:59,920 --> 00:43:03,520
which when data is tagged in an output

00:43:01,839 --> 00:43:05,760
with data it will output it

00:43:03,520 --> 00:43:06,640
to that data file and it supports app no

00:43:05,760 --> 00:43:10,000
paste

00:43:06,640 --> 00:43:11,440
app paste will only the cli helpers will

00:43:10,000 --> 00:43:15,119
only paste to

00:43:11,440 --> 00:43:17,359
private app no paste services

00:43:15,119 --> 00:43:18,720
unless you specify dash note paste

00:43:17,359 --> 00:43:20,079
public and then it will allow you to

00:43:18,720 --> 00:43:22,560
paste to a public server

00:43:20,079 --> 00:43:24,640
um so what i've done is just subclassed

00:43:22,560 --> 00:43:26,400
a app no case service object for

00:43:24,640 --> 00:43:28,160
my internal paste service flagged is

00:43:26,400 --> 00:43:29,440
private and i use that to share data

00:43:28,160 --> 00:43:32,319
with my colleagues

00:43:29,440 --> 00:43:32,960
so here's an example where i do a top

00:43:32,319 --> 00:43:35,200
aggregation

00:43:32,960 --> 00:43:37,280
i do a top search and then down here i

00:43:35,200 --> 00:43:38,880
specified data file inside the house dot

00:43:37,280 --> 00:43:41,280
d a t

00:43:38,880 --> 00:43:43,040
um and you may be familiar with that

00:43:41,280 --> 00:43:45,040
because you saw bad guys.dat that's

00:43:43,040 --> 00:43:47,520
exactly the kind of query that would

00:43:45,040 --> 00:43:50,800
create that type of file

00:43:47,520 --> 00:43:52,160
um so now i can then use that output as

00:43:50,800 --> 00:43:54,880
the input to the next

00:43:52,160 --> 00:43:56,640
query so now i can get all the actions

00:43:54,880 --> 00:43:57,280
that this actor has taken not just the

00:43:56,640 --> 00:43:59,920
ones

00:43:57,280 --> 00:44:01,359
that i i got from the threat feed um and

00:43:59,920 --> 00:44:02,960
then if i want to share that information

00:44:01,359 --> 00:44:04,880
with my colleagues i can just do

00:44:02,960 --> 00:44:06,160
no paste and it will paste it to my

00:44:04,880 --> 00:44:08,800
internal paste bin

00:44:06,160 --> 00:44:10,160
and we have the document there for um

00:44:08,800 --> 00:44:12,319
sharing

00:44:10,160 --> 00:44:13,440
um this is also a pro library that i've

00:44:12,319 --> 00:44:16,880
been working on

00:44:13,440 --> 00:44:19,920
um and um used

00:44:16,880 --> 00:44:22,160
it's been becoming more and more old

00:44:19,920 --> 00:44:24,000
so that it's reusable to make it a

00:44:22,160 --> 00:44:25,680
little bit easier to work with

00:44:24,000 --> 00:44:27,359
apple elasticsearch utilities query

00:44:25,680 --> 00:44:29,440
string provides all the cool query

00:44:27,359 --> 00:44:32,160
string expansion that i showed you

00:44:29,440 --> 00:44:33,200
um aplastic search query provides an

00:44:32,160 --> 00:44:35,440
interface around

00:44:33,200 --> 00:44:37,440
just doing a very simple around doing

00:44:35,440 --> 00:44:38,960
queries um

00:44:37,440 --> 00:44:41,200
and all these are all from the config

00:44:38,960 --> 00:44:42,720
and command line options of app elastic

00:44:41,200 --> 00:44:44,240
search utility so when you build a

00:44:42,720 --> 00:44:44,720
utility with these modules you have

00:44:44,240 --> 00:44:46,560
depth

00:44:44,720 --> 00:44:48,560
host you have the basic user

00:44:46,560 --> 00:44:49,520
authentication you have bases you have

00:44:48,560 --> 00:44:52,960
all those things

00:44:49,520 --> 00:44:55,040
available to you um so let's see if this

00:44:52,960 --> 00:44:59,760
works i've got a few minutes

00:44:55,040 --> 00:44:59,760
maybe a minute see if i can uh

00:44:59,920 --> 00:45:05,839
you're good on time okay um let's do

00:45:08,160 --> 00:45:11,400
[Music]

00:45:14,560 --> 00:45:20,880
well let's just do this i wanted to show

00:45:18,800 --> 00:45:23,440
the library stuff just really quick

00:45:20,880 --> 00:45:25,760
um and everyone can see this it's

00:45:23,440 --> 00:45:25,760
working

00:45:26,720 --> 00:45:30,480
okay so here's the apple asset search

00:45:29,119 --> 00:45:33,119
utilities query string

00:45:30,480 --> 00:45:34,240
um i just initialize the object and then

00:45:33,119 --> 00:45:35,440
i pass the

00:45:34,240 --> 00:45:37,119
anything that comes in on the command

00:45:35,440 --> 00:45:39,119
line to expand query string which does

00:45:37,119 --> 00:45:40,720
the automatic query string expansion

00:45:39,119 --> 00:45:42,480
i create an aggregation and terms

00:45:40,720 --> 00:45:45,440
aggregation on the field program

00:45:42,480 --> 00:45:46,240
size one execute the results print the

00:45:45,440 --> 00:45:49,119
results

00:45:46,240 --> 00:45:51,920
and then show you what the query was so

00:45:49,119 --> 00:45:51,920
if i do that

00:45:54,079 --> 00:46:00,800
one um if i just run that

00:45:57,599 --> 00:46:02,880
you can see i got uh this is the raw

00:46:00,800 --> 00:46:04,720
result that came back from elasticsearch

00:46:02,880 --> 00:46:06,960
um and then here's the query

00:46:04,720 --> 00:46:08,800
so the thing is like we can still do the

00:46:06,960 --> 00:46:09,599
things that i mentioned before since we

00:46:08,800 --> 00:46:12,880
used

00:46:09,599 --> 00:46:15,440
um since we used query string

00:46:12,880 --> 00:46:16,800
um instead of query so here i have query

00:46:15,440 --> 00:46:20,160
bool must range crit

00:46:16,800 --> 00:46:21,920
g greater than five so we have access to

00:46:20,160 --> 00:46:24,960
all this stuff we can say things like

00:46:21,920 --> 00:46:24,960
you know source ip

00:46:26,839 --> 00:46:29,839
10.0.0.0

00:46:30,960 --> 00:46:34,800
and i get my range query so you get all

00:46:33,280 --> 00:46:37,920
that stuff for free

00:46:34,800 --> 00:46:39,440
by using um the these libraries

00:46:37,920 --> 00:46:41,520
the next thing i want to show is like

00:46:39,440 --> 00:46:42,319
multiple levels of aggregation become

00:46:41,520 --> 00:46:44,800
easier

00:46:42,319 --> 00:46:45,680
so in this case what i'm doing here is

00:46:44,800 --> 00:46:48,480
i'm creating

00:46:45,680 --> 00:46:50,160
the innermost aggregation first and then

00:46:48,480 --> 00:46:51,440
i'm wrapping that aggregation in second

00:46:50,160 --> 00:46:53,680
aggregation so it's

00:46:51,440 --> 00:46:54,720
it's building it from the inside of the

00:46:53,680 --> 00:46:57,599
onion out

00:46:54,720 --> 00:46:58,079
um what will look what it will look like

00:46:57,599 --> 00:47:01,200
so

00:46:58,079 --> 00:47:01,200
let's do that one

00:47:02,720 --> 00:47:06,640
so here i have my outer aggregation was

00:47:04,880 --> 00:47:09,760
hostname and i get

00:47:06,640 --> 00:47:11,040
the hostname of pfsense and the inner

00:47:09,760 --> 00:47:12,960
bucket is programmed i just did

00:47:11,040 --> 00:47:14,880
one so that the results would fit into

00:47:12,960 --> 00:47:16,319
these

00:47:14,880 --> 00:47:18,400
terminals but you could imagine that

00:47:16,319 --> 00:47:21,119
expanding out to multiple ones and again

00:47:18,400 --> 00:47:21,119
since this is

00:47:23,200 --> 00:47:28,240
using query string um i can

00:47:26,640 --> 00:47:29,680
apply those changes you don't i didn't

00:47:28,240 --> 00:47:30,880
output the query here but you can see

00:47:29,680 --> 00:47:33,920
that the name changed from

00:47:30,880 --> 00:47:37,520
pf sends to janus and the uh

00:47:33,920 --> 00:47:38,160
program to hussack another thing that i

00:47:37,520 --> 00:47:40,480
do a lot

00:47:38,160 --> 00:47:42,319
um when i'm writing writing scripts to

00:47:40,480 --> 00:47:43,280
do generate reports from data out of

00:47:42,319 --> 00:47:45,520
elasticsearch which

00:47:43,280 --> 00:47:47,440
this library works really well with is

00:47:45,520 --> 00:47:50,240
um

00:47:47,440 --> 00:47:50,960
i'd like to create a really complex

00:47:50,240 --> 00:47:53,440
query

00:47:50,960 --> 00:47:54,240
and and this is a stand-in for a complex

00:47:53,440 --> 00:47:56,880
query

00:47:54,240 --> 00:47:57,680
and then in a loop i want to like look

00:47:56,880 --> 00:48:01,040
at that query

00:47:57,680 --> 00:48:03,119
against different parameters um so

00:48:01,040 --> 00:48:04,720
in this case all i'm going to do is

00:48:03,119 --> 00:48:06,640
change the hostname

00:48:04,720 --> 00:48:08,480
but i'm going to introduce a stash so i

00:48:06,640 --> 00:48:12,079
stash this boolean

00:48:08,480 --> 00:48:14,240
um uh thing i execute it

00:48:12,079 --> 00:48:15,200
and the next time i call stash that that

00:48:14,240 --> 00:48:16,960
part of the query is

00:48:15,200 --> 00:48:19,440
just replaced so the rest of my query

00:48:16,960 --> 00:48:22,720
stays intact but the stash is replaced

00:48:19,440 --> 00:48:22,720
and then what that looks like

00:48:23,280 --> 00:48:27,520
is this so now i have the um same

00:48:26,480 --> 00:48:28,880
aggregation

00:48:27,520 --> 00:48:31,520
stuff i didn't have to change anything

00:48:28,880 --> 00:48:33,359
and i get that so those are kind of nice

00:48:31,520 --> 00:48:34,960
and i guess the other thing that i i

00:48:33,359 --> 00:48:39,920
wanted to you know show

00:48:34,960 --> 00:48:39,920
is this this stuff does actually work um

00:48:40,160 --> 00:48:43,599
this log fields we get all the field

00:48:42,720 --> 00:48:45,760
data

00:48:43,599 --> 00:48:47,440
um and i guess one thing that i didn't

00:48:45,760 --> 00:48:49,040
show in here that

00:48:47,440 --> 00:48:50,960
everyone really needs if they're going

00:48:49,040 --> 00:48:54,720
to be doing any type of data with

00:48:50,960 --> 00:48:54,720
any type of logging is

00:48:54,960 --> 00:49:00,480
a feature and this is a very low volume

00:48:58,640 --> 00:49:02,240
that should be low volume

00:49:00,480 --> 00:49:04,400
so this might not be as glorious as it

00:49:02,240 --> 00:49:05,200
could be everyone loves the tail logs in

00:49:04,400 --> 00:49:07,920
their command

00:49:05,200 --> 00:49:09,280
because that's as we know the most

00:49:07,920 --> 00:49:09,599
effective way to find out what's going

00:49:09,280 --> 00:49:11,040
on

00:49:09,599 --> 00:49:13,599
in your infrastructure is to tell log

00:49:11,040 --> 00:49:15,440
files so you can if you use show you can

00:49:13,599 --> 00:49:18,559
do dash dash tail and

00:49:15,440 --> 00:49:20,880
you can tell logs so um

00:49:18,559 --> 00:49:23,280
you know all those people that are

00:49:20,880 --> 00:49:25,119
currently not wanting to get into the

00:49:23,280 --> 00:49:28,880
elasticsearch ecosystem

00:49:25,119 --> 00:49:30,079
that re must tell a log file in a

00:49:28,880 --> 00:49:32,240
command line just

00:49:30,079 --> 00:49:34,000
in a shell to see what's going on they

00:49:32,240 --> 00:49:37,359
can be satisfied as well

00:49:34,000 --> 00:49:40,079
so um that's kind of um

00:49:37,359 --> 00:49:41,040
all i had right now um i wanted to know

00:49:40,079 --> 00:49:42,880
if

00:49:41,040 --> 00:49:45,680
i wouldn't leave time for questions if

00:49:42,880 --> 00:49:48,079
there were any questions

00:49:45,680 --> 00:49:49,520
but yeah that is uh aplastic search

00:49:48,079 --> 00:49:52,720
utilities um

00:49:49,520 --> 00:49:56,960
the only other things i have here are

00:49:52,720 --> 00:49:59,040
your back just a real quick note about

00:49:56,960 --> 00:50:01,440
future plans for arbitrary levels of

00:49:59,040 --> 00:50:03,599
nesting json output for aggregations

00:50:01,440 --> 00:50:05,520
better support for nested documents um

00:50:03,599 --> 00:50:07,599
and arbitrary data joins

00:50:05,520 --> 00:50:09,280
anything you you can think of and here's

00:50:07,599 --> 00:50:13,839
my contact information

00:50:09,280 --> 00:50:13,839
um so yeah are we doing questions

00:50:16,480 --> 00:50:26,380
absolutely okay yeah the floor is yours

00:50:19,839 --> 00:50:29,530
we got five minutes okay

00:50:26,380 --> 00:50:29,530
[Music]

00:50:32,000 --> 00:50:41,520
sarah oh there's a chat

00:50:36,240 --> 00:50:44,720
i didn't have chat open

00:50:41,520 --> 00:50:46,000
um so someone did say uh

00:50:44,720 --> 00:50:48,240
many programs behave differently

00:50:46,000 --> 00:50:50,240
depending on the existence uh or not of

00:50:48,240 --> 00:50:54,440
a config file is this any different

00:50:50,240 --> 00:50:56,880
so the um esearch.pl will use

00:50:54,440 --> 00:50:58,960
esutils.yaml if it exists if not it will

00:50:56,880 --> 00:51:02,559
default to searching localhost

00:50:58,960 --> 00:51:04,079
um really the only main parameters that

00:51:02,559 --> 00:51:05,200
are will change the host that you're

00:51:04,079 --> 00:51:06,319
connecting to the port that you're

00:51:05,200 --> 00:51:08,720
connecting to

00:51:06,319 --> 00:51:10,079
and then the default base and timestamps

00:51:08,720 --> 00:51:11,839
those are really the only information

00:51:10,079 --> 00:51:13,599
that es search needs to use

00:51:11,839 --> 00:51:16,160
needs to understand to be able to do its

00:51:13,599 --> 00:51:18,400
job so um those are the only

00:51:16,160 --> 00:51:22,480
behavioral changes that change based on

00:51:18,400 --> 00:51:24,640
the existence of that file or not

00:51:22,480 --> 00:51:25,599
that comment brad was in reference to

00:51:24,640 --> 00:51:27,839
the feature

00:51:25,599 --> 00:51:30,240
of being able to read the last column

00:51:27,839 --> 00:51:33,520
out of a csv for example and how

00:51:30,240 --> 00:51:35,040
the command line operates differently if

00:51:33,520 --> 00:51:36,319
there's a file in your local directory

00:51:35,040 --> 00:51:39,599
of that name versus

00:51:36,319 --> 00:51:43,119
using it as a search term oh right

00:51:39,599 --> 00:51:46,319
so you can specify a fully qualified

00:51:43,119 --> 00:51:49,359
path so you can an absolute path um

00:51:46,319 --> 00:51:51,680
or you in my examples i just use

00:51:49,359 --> 00:51:53,440
files that are relative to the local

00:51:51,680 --> 00:51:58,480
directory

00:51:53,440 --> 00:52:01,440
you do have to specify.dat.txt.csv or

00:51:58,480 --> 00:52:02,880
json as your suffixes because it will

00:52:01,440 --> 00:52:05,599
only look for those

00:52:02,880 --> 00:52:06,559
in the in the search terms and then if

00:52:05,599 --> 00:52:08,720
it finds

00:52:06,559 --> 00:52:10,079
the document that the file on your file

00:52:08,720 --> 00:52:11,520
system where you specified with the

00:52:10,079 --> 00:52:13,119
default search path being current

00:52:11,520 --> 00:52:16,160
working in your directory

00:52:13,119 --> 00:52:17,839
it will do the the thing

00:52:16,160 --> 00:52:19,839
if it does not find it it will pass it

00:52:17,839 --> 00:52:22,240
along as a search term so

00:52:19,839 --> 00:52:23,280
um that's part of the reason why the

00:52:22,240 --> 00:52:25,119
tool gives you

00:52:23,280 --> 00:52:27,520
the one of the last lines of the output

00:52:25,119 --> 00:52:29,680
is the search parameters that it used

00:52:27,520 --> 00:52:31,440
so you can see oh that didn't expand

00:52:29,680 --> 00:52:32,000
that actually searched directly for that

00:52:31,440 --> 00:52:36,480
that

00:52:32,000 --> 00:52:36,480
name yeah

00:52:38,000 --> 00:52:41,280
yeah so um there's a lot of

00:52:39,760 --> 00:52:42,559
documentation so

00:52:41,280 --> 00:52:43,599
i'm gonna assume that everyone's read

00:52:42,559 --> 00:52:44,480
the documentation doesn't have any

00:52:43,599 --> 00:52:46,400
questions but

00:52:44,480 --> 00:52:48,079
um if you do have any questions feel

00:52:46,400 --> 00:52:50,559
free to reach out to me um

00:52:48,079 --> 00:52:51,760
on twitter sometimes i've really taken a

00:52:50,559 --> 00:52:54,319
step back from

00:52:51,760 --> 00:52:55,760
online stuff to kind of lower the

00:52:54,319 --> 00:52:57,839
anxiety levels

00:52:55,760 --> 00:52:58,960
um but you can you can hit me up on

00:52:57,839 --> 00:53:02,160
twitter

00:52:58,960 --> 00:53:04,640
and if you want to have a more um direct

00:53:02,160 --> 00:53:06,240
conversation um hit me up on twitter

00:53:04,640 --> 00:53:07,119
i'll give you my signal information so

00:53:06,240 --> 00:53:09,280
you can reach me

00:53:07,119 --> 00:53:10,640
um almost any hour of the day if you're

00:53:09,280 --> 00:53:12,640
if you're using this tool

00:53:10,640 --> 00:53:15,040
it's something that that has been a lot

00:53:12,640 --> 00:53:16,000
of fun to work with and a lot of fun to

00:53:15,040 --> 00:53:17,200
talk about so

00:53:16,000 --> 00:53:20,160
thank you for the opportunity to talk

00:53:17,200 --> 00:53:20,160

YouTube URL: https://www.youtube.com/watch?v=cexwpN3N2j0


