Title: Introduction to Perl Data Types - William N. Braswell, Jr.
Publication date: 2021-06-08
Playlist: TPC 2021 in the Cloud
Description: 
	Data types are hints to a computer language, telling the language's interpreter or compiler how best to allocate resources and optimize performance.

We will introduce the type system provided by the Perl compiler, and the many benefits of utilizing Perl data types.

The Perl interpreter itself is written in C, and implements data types for its own internal use, including:

- IV, integer value
- NV, number value
- PV, pointer value AKA string
- AV, array value
- HV, hash value
- SV, scalar value
- RV, reference value

The Perl interpreter does not provide programmers with access to these pre-defined types, and instead it encourages us not to use data types at all.

Perl does allow programmers to create user-defined data types, but none of the (numerous & incompatible) data type systems actually utilizes the underlying C data types implemented in the Perl interpreter.

The Perl compiler finally provides developers with direct access to real C data types and their C++ equivalents.

Upgrade your Perl, start utilizing data types today!
Captions: 
	00:00:00,880 --> 00:00:06,000
yes yes okay wonderful

00:00:03,520 --> 00:00:09,200
so let's go ahead and get started it is

00:00:06,000 --> 00:00:12,480
time greetings pearl citizens

00:00:09,200 --> 00:00:14,320
it is i your fearless leader of austin

00:00:12,480 --> 00:00:17,600
texas pro mongers

00:00:14,320 --> 00:00:20,320
will the chill broadcasting live

00:00:17,600 --> 00:00:22,080
from austin texas some of you may know

00:00:20,320 --> 00:00:25,279
me by my legal name

00:00:22,080 --> 00:00:26,960
will braswell and i would like to thank

00:00:25,279 --> 00:00:30,880
everyone for joining us today

00:00:26,960 --> 00:00:33,200
here at the pearl conference 2021

00:00:30,880 --> 00:00:35,040
today we're going to be talking about

00:00:33,200 --> 00:00:37,520
pearl data types

00:00:35,040 --> 00:00:39,600
this will be a an introductory course

00:00:37,520 --> 00:00:40,160
it's not going to be super advanced with

00:00:39,600 --> 00:00:42,879
uh

00:00:40,160 --> 00:00:44,399
too many gory details but we'll

00:00:42,879 --> 00:00:47,039
hopefully allow

00:00:44,399 --> 00:00:47,920
you to to uh get moving in the right

00:00:47,039 --> 00:00:49,440
direction

00:00:47,920 --> 00:00:52,000
especially if you're not already

00:00:49,440 --> 00:00:55,199
familiar with pearl data types

00:00:52,000 --> 00:00:56,239
i will um also go ahead and apologize in

00:00:55,199 --> 00:00:59,520
advance

00:00:56,239 --> 00:01:03,120
that um this is going to be

00:00:59,520 --> 00:01:06,560
a uh meme tastic

00:01:03,120 --> 00:01:09,119
presentation um i guess that's the

00:01:06,560 --> 00:01:10,240
popular thing to do nowadays so uh who

00:01:09,119 --> 00:01:13,040
am i to

00:01:10,240 --> 00:01:13,840
to buck popularity um i just have to get

00:01:13,040 --> 00:01:17,040
my

00:01:13,840 --> 00:01:20,640
bernie mittens on okay

00:01:17,040 --> 00:01:23,119
next why why why

00:01:20,640 --> 00:01:24,960
why in the world would we want to use

00:01:23,119 --> 00:01:28,159
data types

00:01:24,960 --> 00:01:31,119
um you you will often hear people say

00:01:28,159 --> 00:01:32,960
perl doesn't need data types um why why

00:01:31,119 --> 00:01:34,880
do i need to care about data types i'm a

00:01:32,960 --> 00:01:36,240
pearl programmer perl doesn't even have

00:01:34,880 --> 00:01:39,520
data types

00:01:36,240 --> 00:01:40,000
and so forth it's it's uh remarkably

00:01:39,520 --> 00:01:42,479
similar

00:01:40,000 --> 00:01:44,960
or reminiscent at least of the of the

00:01:42,479 --> 00:01:47,360
often repeated and equally

00:01:44,960 --> 00:01:48,560
inaccurate pearl is dead or pearl

00:01:47,360 --> 00:01:51,040
doesn't have any more

00:01:48,560 --> 00:01:52,560
new jobs or pearl doesn't have anything

00:01:51,040 --> 00:01:55,520
cool going on

00:01:52,560 --> 00:01:57,360
um all of those things that we also know

00:01:55,520 --> 00:02:00,320
are untrue so these are

00:01:57,360 --> 00:02:00,719
um it's misinformation it's fake news

00:02:00,320 --> 00:02:04,719
it's

00:02:00,719 --> 00:02:08,560
uh it's not accurate it's untrue

00:02:04,719 --> 00:02:10,239
so um pearl does have

00:02:08,560 --> 00:02:11,599
data types we're going to go through

00:02:10,239 --> 00:02:15,120
that here today

00:02:11,599 --> 00:02:18,000
um in in my um

00:02:15,120 --> 00:02:20,080
understanding of computer science and

00:02:18,000 --> 00:02:20,800
and uh the pearl programming language

00:02:20,080 --> 00:02:23,360
pearl

00:02:20,800 --> 00:02:24,720
needs these data types not only for its

00:02:23,360 --> 00:02:26,959
own internal use

00:02:24,720 --> 00:02:29,360
again we'll go more into that later but

00:02:26,959 --> 00:02:30,720
for our use as as pearl programmers i

00:02:29,360 --> 00:02:32,560
mean we

00:02:30,720 --> 00:02:34,000
we we need to have access to that

00:02:32,560 --> 00:02:37,040
considering the

00:02:34,000 --> 00:02:38,959
the uh sometimes unreasonably

00:02:37,040 --> 00:02:40,480
high amount of access that pearl gives

00:02:38,959 --> 00:02:43,680
us to its own internal

00:02:40,480 --> 00:02:44,480
data uh one one would have thought that

00:02:43,680 --> 00:02:48,400
we would have

00:02:44,480 --> 00:02:52,879
had real data types in the

00:02:48,400 --> 00:02:55,680
in the pearl core language years ago um

00:02:52,879 --> 00:02:56,400
i almost put one of the a meme of this

00:02:55,680 --> 00:02:58,400
skeleton

00:02:56,400 --> 00:03:00,560
sitting there saying uh this is me

00:02:58,400 --> 00:03:02,239
waiting for pearl types to go into the

00:03:00,560 --> 00:03:05,040
pearl core but

00:03:02,239 --> 00:03:05,920
um i guess as they say if you build it

00:03:05,040 --> 00:03:08,319
they will come

00:03:05,920 --> 00:03:09,599
or if you want a job done right do it

00:03:08,319 --> 00:03:11,920
yourself or

00:03:09,599 --> 00:03:13,440
you know all these kinds of things i'm

00:03:11,920 --> 00:03:15,920
we'll we'll get it in there

00:03:13,440 --> 00:03:18,000
at some point uh hopefully in the not

00:03:15,920 --> 00:03:20,879
too distant future now that the

00:03:18,000 --> 00:03:23,040
the uh pearl leadership is getting

00:03:20,879 --> 00:03:25,680
shaken up at least a little bit

00:03:23,040 --> 00:03:26,319
um we might actually see pearl seven

00:03:25,680 --> 00:03:28,720
someday

00:03:26,319 --> 00:03:31,599
maybe even a pearl eight pro line and

00:03:28,720 --> 00:03:35,120
who knows a version of pearl that has

00:03:31,599 --> 00:03:35,760
real data type so anyway back to the

00:03:35,120 --> 00:03:39,280
question

00:03:35,760 --> 00:03:41,120
why data types

00:03:39,280 --> 00:03:43,040
well there's a number of reasons and you

00:03:41,120 --> 00:03:44,959
can probably come up with more but i

00:03:43,040 --> 00:03:46,400
just put down a few off the top of my

00:03:44,959 --> 00:03:48,959
head

00:03:46,400 --> 00:03:49,599
uh readability well this is for your

00:03:48,959 --> 00:03:53,040
this is

00:03:49,599 --> 00:03:55,280
for your own benefit this is for you to

00:03:53,040 --> 00:03:57,439
read your own code

00:03:55,280 --> 00:03:58,959
i mean you do want to be able to read

00:03:57,439 --> 00:04:00,640
your own code right i mean even if

00:03:58,959 --> 00:04:04,000
you're

00:04:00,640 --> 00:04:06,720
one of those very masochistic people who

00:04:04,000 --> 00:04:08,560
goes into the uh obfuscated pearl

00:04:06,720 --> 00:04:11,680
contests and so forth

00:04:08,560 --> 00:04:13,599
um you you're probably not submitting

00:04:11,680 --> 00:04:14,480
that work for your day job one would

00:04:13,599 --> 00:04:17,519
hope

00:04:14,480 --> 00:04:17,919
and uh and and in your day job or in

00:04:17,519 --> 00:04:22,400
your

00:04:17,919 --> 00:04:25,600
sort of uh professional or or

00:04:22,400 --> 00:04:27,680
more normal programming career

00:04:25,600 --> 00:04:29,440
you should not be writing off your

00:04:27,680 --> 00:04:32,000
skated code you should want your own

00:04:29,440 --> 00:04:35,759
code to be readable by your own self

00:04:32,000 --> 00:04:38,160
easily um now and in the future so

00:04:35,759 --> 00:04:40,160
data types will help with that uh

00:04:38,160 --> 00:04:42,560
maintainability this is

00:04:40,160 --> 00:04:44,080
kind of like when it's a lot of time has

00:04:42,560 --> 00:04:45,199
passed and now it's somebody else's

00:04:44,080 --> 00:04:47,120
problem

00:04:45,199 --> 00:04:49,040
um or maybe a lot of time has passed and

00:04:47,120 --> 00:04:50,560
you quit that job and then they rehired

00:04:49,040 --> 00:04:51,520
you to work on your old code from 10

00:04:50,560 --> 00:04:54,400
years ago and you just

00:04:51,520 --> 00:04:55,199
don't even remember writing it or maybe

00:04:54,400 --> 00:04:56,800
just a few

00:04:55,199 --> 00:04:58,240
weeks or months have passed and you have

00:04:56,800 --> 00:05:01,680
a very bad

00:04:58,240 --> 00:05:04,320
long-term memory and you uh

00:05:01,680 --> 00:05:07,199
you need you know a higher level of

00:05:04,320 --> 00:05:10,400
maintainability just for your own

00:05:07,199 --> 00:05:14,000
sanity so in those cases

00:05:10,400 --> 00:05:17,840
uh again data types will help you you'll

00:05:14,000 --> 00:05:21,039
go back uh to this old code whether it's

00:05:17,840 --> 00:05:23,520
yours or someone else's um and

00:05:21,039 --> 00:05:25,600
uh you'll you'll have an a less

00:05:23,520 --> 00:05:26,080
difficult time understanding what it did

00:05:25,600 --> 00:05:30,080
if you

00:05:26,080 --> 00:05:31,840
know what all the data types are um

00:05:30,080 --> 00:05:33,440
by the way if you don't even know what

00:05:31,840 --> 00:05:34,320
data types are just wait a minute we'll

00:05:33,440 --> 00:05:37,520
get there

00:05:34,320 --> 00:05:39,440
don't worry um i'm

00:05:37,520 --> 00:05:40,720
i apologize i'm assuming people at least

00:05:39,440 --> 00:05:43,120
know what data types are

00:05:40,720 --> 00:05:43,759
but we will cover that again here in a

00:05:43,120 --> 00:05:46,960
minute

00:05:43,759 --> 00:05:48,960
correctness of your programs

00:05:46,960 --> 00:05:50,960
this is a big one because people

00:05:48,960 --> 00:05:53,120
actually write bad code all the time and

00:05:50,960 --> 00:05:55,520
i don't mean bad code in that it just

00:05:53,120 --> 00:05:57,280
looks bad but runs right i mean bad code

00:05:55,520 --> 00:05:59,600
that actually runs wrong

00:05:57,280 --> 00:06:01,759
or it can run wrong in certain cases

00:05:59,600 --> 00:06:03,039
maybe you haven't discovered those cases

00:06:01,759 --> 00:06:05,600
yet

00:06:03,039 --> 00:06:06,639
or it could be hours weeks months or

00:06:05,600 --> 00:06:08,400
years before

00:06:06,639 --> 00:06:10,080
those cases are discovered and something

00:06:08,400 --> 00:06:13,600
crashes and burns

00:06:10,080 --> 00:06:16,960
and boy that's not fun for anyone um

00:06:13,600 --> 00:06:20,080
so you want to minimize that

00:06:16,960 --> 00:06:23,440
incorrect code and if you have

00:06:20,080 --> 00:06:26,960
uh strong data types then

00:06:23,440 --> 00:06:30,080
you can avoid those problems by

00:06:26,960 --> 00:06:32,639
having type checking occur both at run

00:06:30,080 --> 00:06:33,600
time and also in many cases at compile

00:06:32,639 --> 00:06:37,199
time

00:06:33,600 --> 00:06:39,199
so you can more you can be more

00:06:37,199 --> 00:06:40,560
confident in the correctness of your

00:06:39,199 --> 00:06:42,400
code now if you

00:06:40,560 --> 00:06:43,840
implement the algorithm incorrectly or

00:06:42,400 --> 00:06:47,199
the incorrect algorithm or

00:06:43,840 --> 00:06:49,199
you just have some other

00:06:47,199 --> 00:06:50,880
bugs for some reason or even bugs in

00:06:49,199 --> 00:06:55,440
someone else's code that you

00:06:50,880 --> 00:06:57,759
used without checking it first um

00:06:55,440 --> 00:06:58,800
that you know we can't really help you

00:06:57,759 --> 00:07:00,240
to protect against

00:06:58,800 --> 00:07:03,840
those kinds of problems because they're

00:07:00,240 --> 00:07:06,720
not related to data types and data

00:07:03,840 --> 00:07:07,759
but for all of those kinds of bugs that

00:07:06,720 --> 00:07:12,479
are related to

00:07:07,759 --> 00:07:15,039
bad data data types can

00:07:12,479 --> 00:07:16,160
certainly will not hurt you and in many

00:07:15,039 --> 00:07:20,160
many cases will

00:07:16,160 --> 00:07:21,520
help quite a bit uh performance ah one

00:07:20,160 --> 00:07:26,080
of my personal

00:07:21,520 --> 00:07:30,560
favorites so with performance

00:07:26,080 --> 00:07:33,840
we have a lot of considerations they

00:07:30,560 --> 00:07:36,240
they're the i'll just mention

00:07:33,840 --> 00:07:37,280
i mean if you're coming into this with

00:07:36,240 --> 00:07:40,800
not knowing who i

00:07:37,280 --> 00:07:43,840
am or familiar with any of of uh my

00:07:40,800 --> 00:07:45,759
my work in the pearl community then uh

00:07:43,840 --> 00:07:47,199
there's there's sort of two different

00:07:45,759 --> 00:07:50,080
ways that you can run

00:07:47,199 --> 00:07:51,840
pearl code you can use the regular pearl

00:07:50,080 --> 00:07:53,520
interpreter that's what everybody

00:07:51,840 --> 00:07:54,960
here at the conference is kind of

00:07:53,520 --> 00:07:56,720
talking about

00:07:54,960 --> 00:07:59,360
and then you can also use the pro

00:07:56,720 --> 00:08:03,840
compiler which i wrote it's called rpr

00:07:59,360 --> 00:08:05,840
and and our pearl does

00:08:03,840 --> 00:08:06,879
provide you with data types and that

00:08:05,840 --> 00:08:10,000
we'll again be

00:08:06,879 --> 00:08:10,400
looking at here in a moment and the one

00:08:10,000 --> 00:08:13,520
of

00:08:10,400 --> 00:08:15,440
the main purposes of of the

00:08:13,520 --> 00:08:16,879
compiler is to provide you with

00:08:15,440 --> 00:08:19,599
increased performance

00:08:16,879 --> 00:08:20,720
and you can have dramatically increased

00:08:19,599 --> 00:08:23,759
performance

00:08:20,720 --> 00:08:27,199
in in many cases i mean i've seen it go

00:08:23,759 --> 00:08:29,599
over 400 times faster

00:08:27,199 --> 00:08:31,280
than the normal pearl interpreter and

00:08:29,599 --> 00:08:34,399
that's that's not 400

00:08:31,280 --> 00:08:37,919
it's 40 000 so you can

00:08:34,399 --> 00:08:38,959
get insanely faster speeds by compiling

00:08:37,919 --> 00:08:40,719
your code

00:08:38,959 --> 00:08:42,080
and if that's something that sounds

00:08:40,719 --> 00:08:45,200
appealing to you then

00:08:42,080 --> 00:08:47,040
again data types will help get you there

00:08:45,200 --> 00:08:48,800
uh last but not least and again there

00:08:47,040 --> 00:08:49,680
are probably many other reasons to use

00:08:48,800 --> 00:08:52,480
data types

00:08:49,680 --> 00:08:53,680
please you know let us know what you

00:08:52,480 --> 00:08:56,959
think about that

00:08:53,680 --> 00:08:58,000
but uh best practices so let's imagine

00:08:56,959 --> 00:09:00,000
you work in a

00:08:58,000 --> 00:09:02,000
company with some teams of programmers

00:09:00,000 --> 00:09:04,399
and you're on one of those teams and

00:09:02,000 --> 00:09:05,760
and it's important to uh to have

00:09:04,399 --> 00:09:08,959
everyone working together

00:09:05,760 --> 00:09:10,800
cohesively peacefully and

00:09:08,959 --> 00:09:12,560
and to be able to hand off projects to

00:09:10,800 --> 00:09:15,600
other programmers and teams in the

00:09:12,560 --> 00:09:19,120
future as other people inherit the code

00:09:15,600 --> 00:09:19,600
so we we have this somewhat nebulous

00:09:19,120 --> 00:09:22,640
term

00:09:19,600 --> 00:09:23,040
best practices and it means like what

00:09:22,640 --> 00:09:25,360
are

00:09:23,040 --> 00:09:27,760
what are a bunch of good ideas that you

00:09:25,360 --> 00:09:32,320
can do to make your code

00:09:27,760 --> 00:09:35,519
overall better in some way and there's

00:09:32,320 --> 00:09:36,959
books and lectures and

00:09:35,519 --> 00:09:39,279
tons and tons of arguments and even

00:09:36,959 --> 00:09:40,640
flame wars about best practices and even

00:09:39,279 --> 00:09:43,680
specifically the best about

00:09:40,640 --> 00:09:44,080
parole best practices but uh i will

00:09:43,680 --> 00:09:46,800
again

00:09:44,080 --> 00:09:47,920
as you know as your your humble uh pearl

00:09:46,800 --> 00:09:50,160
compiler

00:09:47,920 --> 00:09:51,839
uh author i will put forth that uh

00:09:50,160 --> 00:09:53,680
utilizing data types is

00:09:51,839 --> 00:09:54,959
is a best practice for all the reasons

00:09:53,680 --> 00:09:57,279
that i just mentioned

00:09:54,959 --> 00:09:58,640
um and and plus for all of these sort of

00:09:57,279 --> 00:10:01,120
a business reasons

00:09:58,640 --> 00:10:02,000
you know like uh spending less money

00:10:01,120 --> 00:10:06,000
less less

00:10:02,000 --> 00:10:06,800
uh human resources uh fewer uh trouble

00:10:06,000 --> 00:10:09,760
tickets and

00:10:06,800 --> 00:10:11,040
displeased customers all of the business

00:10:09,760 --> 00:10:14,079
reasons that you could

00:10:11,040 --> 00:10:15,040
think of may fall under best practices

00:10:14,079 --> 00:10:17,519
so

00:10:15,040 --> 00:10:20,399
why should you use pearl data types

00:10:17,519 --> 00:10:23,760
goodness gracious good night good lord

00:10:20,399 --> 00:10:24,800
good grief and good gravy why wouldn't

00:10:23,760 --> 00:10:28,720
you

00:10:24,800 --> 00:10:31,760
use data types it's boggles the mind

00:10:28,720 --> 00:10:32,000
again imagine me as a skeleton sitting

00:10:31,760 --> 00:10:34,720
here

00:10:32,000 --> 00:10:36,160
waiting for pearl data types to be in

00:10:34,720 --> 00:10:38,320
the pearl core

00:10:36,160 --> 00:10:39,360
um but thankfully i'm not just sitting

00:10:38,320 --> 00:10:41,519
here i'm

00:10:39,360 --> 00:10:44,000
you know madly coding through the years

00:10:41,519 --> 00:10:47,600
to make it all happen

00:10:44,000 --> 00:10:53,040
make it happen as they say okay

00:10:47,600 --> 00:10:53,040
next fake types versus real types

00:10:53,360 --> 00:10:58,720
so here's a humanoid android

00:10:56,399 --> 00:11:00,720
robot in some anime i've never seen from

00:10:58,720 --> 00:11:03,440
the 90s

00:11:00,720 --> 00:11:04,720
he thinks that this butterfly is a

00:11:03,440 --> 00:11:06,800
pigeon

00:11:04,720 --> 00:11:08,000
and he's asking the question is this a

00:11:06,800 --> 00:11:12,000
pigeon well it's

00:11:08,000 --> 00:11:15,200
you know just innocent robotic naivete

00:11:12,000 --> 00:11:18,240
i suppose um but it's been meme many

00:11:15,200 --> 00:11:20,640
times to have this sort of

00:11:18,240 --> 00:11:23,360
easy to make or common misconception

00:11:20,640 --> 00:11:23,360
about a thing

00:11:23,440 --> 00:11:30,240
now if you're like me you love

00:11:27,200 --> 00:11:31,839
reading pearl blog posts and if uh you

00:11:30,240 --> 00:11:35,760
hang out in our

00:11:31,839 --> 00:11:38,240
online uh facebook group then you will

00:11:35,760 --> 00:11:39,760
hopefully be friends with my friend mark

00:11:38,240 --> 00:11:42,560
gardner who writes a lot of

00:11:39,760 --> 00:11:44,000
great blog post about pearl and he was

00:11:42,560 --> 00:11:46,320
even leading the

00:11:44,000 --> 00:11:47,760
um birds of a feather we were having

00:11:46,320 --> 00:11:50,399
earlier today about

00:11:47,760 --> 00:11:51,120
that very thing blogging about pearl you

00:11:50,399 --> 00:11:53,680
can read

00:11:51,120 --> 00:11:56,320
some of his recent blog posts about

00:11:53,680 --> 00:11:59,200
pearl type systems in fact mark if

00:11:56,320 --> 00:12:02,800
you're watching right now hi mark

00:11:59,200 --> 00:12:06,000
um good job on all of those blog posts

00:12:02,800 --> 00:12:09,440
so um you can go read mark's

00:12:06,000 --> 00:12:12,560
recent stuff including um one or two

00:12:09,440 --> 00:12:16,959
blog posts about pearl data types

00:12:12,560 --> 00:12:18,240
um or really these sort of type systems

00:12:16,959 --> 00:12:19,360
and the reason i'm pointing you towards

00:12:18,240 --> 00:12:20,720
that is because i'm not going to give

00:12:19,360 --> 00:12:23,519
you any of the

00:12:20,720 --> 00:12:24,639
review that mark gave you i'm not here

00:12:23,519 --> 00:12:28,000
to teach you about

00:12:24,639 --> 00:12:30,480
fake type systems sorry mark i know that

00:12:28,000 --> 00:12:32,160
nobody was really aware of the

00:12:30,480 --> 00:12:33,839
differentiation between fake types and

00:12:32,160 --> 00:12:34,480
real types so we have a whole slide that

00:12:33,839 --> 00:12:36,959
you are

00:12:34,480 --> 00:12:39,200
currently looking at about this very

00:12:36,959 --> 00:12:42,399
topic so when you are

00:12:39,200 --> 00:12:44,160
um doing your googling and you're

00:12:42,399 --> 00:12:46,079
looking up things on medicine and you

00:12:44,160 --> 00:12:49,440
come across a

00:12:46,079 --> 00:12:51,920
pearl type system type

00:12:49,440 --> 00:12:53,760
tiny or moose types or whatever they are

00:12:51,920 --> 00:12:56,399
i don't even remember because i've

00:12:53,760 --> 00:12:57,839
i don't need them i don't use them these

00:12:56,399 --> 00:13:00,000
are all

00:12:57,839 --> 00:13:01,040
what you could consider to be soft type

00:13:00,000 --> 00:13:03,440
systems or fake

00:13:01,040 --> 00:13:05,200
type systems what does that mean what is

00:13:03,440 --> 00:13:07,279
the difference between a fake type and a

00:13:05,200 --> 00:13:09,360
real type what is the difference between

00:13:07,279 --> 00:13:11,040
a soft type system and a hard type

00:13:09,360 --> 00:13:14,720
system well that's

00:13:11,040 --> 00:13:14,720
a critically important question

00:13:15,519 --> 00:13:20,000
i believe i mean just to even understand

00:13:18,480 --> 00:13:23,920
what we're talking about when we say

00:13:20,000 --> 00:13:27,040
type system type system is a a set of

00:13:23,920 --> 00:13:29,519
of software um libraries or or

00:13:27,040 --> 00:13:31,040
data routines whatever that provides you

00:13:29,519 --> 00:13:32,720
with data types

00:13:31,040 --> 00:13:35,519
so type system is just a bunch of data

00:13:32,720 --> 00:13:38,480
types packaged together somehow

00:13:35,519 --> 00:13:40,800
and generally connected to a computer

00:13:38,480 --> 00:13:45,040
programming language in this case perl

00:13:40,800 --> 00:13:48,560
so because the

00:13:45,040 --> 00:13:49,839
um current procore does not have a user

00:13:48,560 --> 00:13:52,800
accessible type system

00:13:49,839 --> 00:13:54,399
a number of people have created ad hoc

00:13:52,800 --> 00:13:56,720
type systems

00:13:54,399 --> 00:13:58,079
um and i'm sure they all did it with

00:13:56,720 --> 00:14:02,399
good intentions i

00:13:58,079 --> 00:14:05,440
hope i assume they did um

00:14:02,399 --> 00:14:08,240
how could i know though um

00:14:05,440 --> 00:14:09,519
oh good people are texting me on irc

00:14:08,240 --> 00:14:13,120
right now

00:14:09,519 --> 00:14:17,519
um giving pearl conference talk

00:14:13,120 --> 00:14:20,720
right now exclamation

00:14:17,519 --> 00:14:24,720
winky face okay anyway

00:14:20,720 --> 00:14:24,720
um so

00:14:25,120 --> 00:14:28,959
the real type systems versus fake type

00:14:27,920 --> 00:14:32,480
systems

00:14:28,959 --> 00:14:35,600
um a real type system

00:14:32,480 --> 00:14:37,440
is linked to uh hardware that's kind of

00:14:35,600 --> 00:14:38,980
where the term hard comes from

00:14:37,440 --> 00:14:40,160
we're trying to fit things within

00:14:38,980 --> 00:14:42,399
[Music]

00:14:40,160 --> 00:14:44,000
registers on the cpu or within certain

00:14:42,399 --> 00:14:48,560
slots in memory and so

00:14:44,000 --> 00:14:52,480
forth um and and all of those things are

00:14:48,560 --> 00:14:54,959
uh you know hardware

00:14:52,480 --> 00:14:56,560
limited or or hardware related or

00:14:54,959 --> 00:14:59,040
restricted in some way you have a

00:14:56,560 --> 00:15:00,959
certain amount of ram and in that ram

00:14:59,040 --> 00:15:02,399
you have to fit things in a certain way

00:15:00,959 --> 00:15:05,199
and you have a certain

00:15:02,399 --> 00:15:06,639
um you know 64-bit processor 32-bit

00:15:05,199 --> 00:15:09,279
whatever it is and

00:15:06,639 --> 00:15:10,880
uh and the registers in the processor

00:15:09,279 --> 00:15:14,000
have certain rules that

00:15:10,880 --> 00:15:17,440
govern them and so forth so you uh

00:15:14,000 --> 00:15:19,839
your compiler in the background has to

00:15:17,440 --> 00:15:21,680
get all of your data somehow to fit

00:15:19,839 --> 00:15:27,120
inside of the hardware that's

00:15:21,680 --> 00:15:30,639
actually running things um

00:15:27,120 --> 00:15:34,480
uh a soft type system on the other hand

00:15:30,639 --> 00:15:36,399
or a fake type system is just uh

00:15:34,480 --> 00:15:38,480
it's not related to hardware in any way

00:15:36,399 --> 00:15:42,240
it's it's emulated or

00:15:38,480 --> 00:15:44,079
simulated or it's just um it seems

00:15:42,240 --> 00:15:45,680
to kind of sort of be a type system but

00:15:44,079 --> 00:15:47,440
not really because

00:15:45,680 --> 00:15:50,399
you don't it's not correlated to

00:15:47,440 --> 00:15:50,399
hardware in any way

00:15:50,480 --> 00:15:54,079
you could make up any number of types

00:15:53,120 --> 00:15:55,759
that have nothing to do with the

00:15:54,079 --> 00:15:59,519
hardware that you're running on and

00:15:55,759 --> 00:16:01,199
call it a type system i mean it's

00:15:59,519 --> 00:16:02,720
they don't even have to correspond to

00:16:01,199 --> 00:16:05,759
reality i guess

00:16:02,720 --> 00:16:07,440
uh the types that you create in a soft

00:16:05,759 --> 00:16:08,079
type system generally you would want

00:16:07,440 --> 00:16:10,399
them to have

00:16:08,079 --> 00:16:12,320
some familiarity to computer programmers

00:16:10,399 --> 00:16:15,120
presumably but

00:16:12,320 --> 00:16:16,480
whatever i mean pearl programmers are

00:16:15,120 --> 00:16:18,880
ingeniously

00:16:16,480 --> 00:16:20,880
stupid about many things and we can

00:16:18,880 --> 00:16:22,480
create all kinds of wacky type systems

00:16:20,880 --> 00:16:25,600
that have no

00:16:22,480 --> 00:16:29,279
bearing on reality

00:16:25,600 --> 00:16:31,440
so a lot of them appear to be

00:16:29,279 --> 00:16:33,040
ad hoc like somebody created something

00:16:31,440 --> 00:16:34,880
and then they needed a type system so

00:16:33,040 --> 00:16:36,079
they kind of tacked on a type system and

00:16:34,880 --> 00:16:39,199
then that type system

00:16:36,079 --> 00:16:42,560
got released somehow

00:16:39,199 --> 00:16:45,360
or um

00:16:42,560 --> 00:16:46,240
they they wanted to create a type system

00:16:45,360 --> 00:16:49,199
but didn't

00:16:46,240 --> 00:16:51,600
bother to figure out how it pertained to

00:16:49,199 --> 00:16:55,279
hardware or the underlying

00:16:51,600 --> 00:16:58,560
compilation or interpreting system

00:16:55,279 --> 00:16:59,600
so um i apologize if i'm painting anyone

00:16:58,560 --> 00:17:02,800
in a

00:16:59,600 --> 00:17:04,000
negative or incorrect light i'm simply

00:17:02,800 --> 00:17:07,120
trying to point out that

00:17:04,000 --> 00:17:10,240
uh using a type system that is not

00:17:07,120 --> 00:17:14,000
compiling directly into the hardware

00:17:10,240 --> 00:17:15,120
supported types um is not a hard type

00:17:14,000 --> 00:17:17,199
system

00:17:15,120 --> 00:17:19,600
you can use subtypes all you like use

00:17:17,199 --> 00:17:23,600
them all day just don't say they're real

00:17:19,600 --> 00:17:26,079
they're fake um usually when you look

00:17:23,600 --> 00:17:26,959
behind the curtains on the soft type

00:17:26,079 --> 00:17:29,520
systems

00:17:26,959 --> 00:17:32,000
you're going to find that it's using

00:17:29,520 --> 00:17:35,120
something like a regular expression

00:17:32,000 --> 00:17:37,200
to test the data

00:17:35,120 --> 00:17:38,559
and i have to roll my eyes at that

00:17:37,200 --> 00:17:40,480
because

00:17:38,559 --> 00:17:42,080
i guarantee you there's not a tiny

00:17:40,480 --> 00:17:45,600
regular expression engine running in

00:17:42,080 --> 00:17:45,600
your cpu checking types

00:17:45,679 --> 00:17:52,960
it's uh it's it's nowhere near that

00:17:49,120 --> 00:17:54,960
convoluted i guess now

00:17:52,960 --> 00:17:56,400
it may be convenient to do that in pearl

00:17:54,960 --> 00:17:59,120
because pearl has a

00:17:56,400 --> 00:18:00,160
very nice built-in regular expression

00:17:59,120 --> 00:18:02,640
engine

00:18:00,160 --> 00:18:04,320
but that's not how real type systems

00:18:02,640 --> 00:18:07,039
work real type systems

00:18:04,320 --> 00:18:08,240
are going to compile down to c or c plus

00:18:07,039 --> 00:18:09,600
plus types or if you're

00:18:08,240 --> 00:18:11,760
if it's not using either of those

00:18:09,600 --> 00:18:15,039
languages it's going to somehow combine

00:18:11,760 --> 00:18:17,520
straight down to assembly uh registers

00:18:15,039 --> 00:18:20,480
and and so forth like i mentioned before

00:18:17,520 --> 00:18:22,000
um but usually you're gonna have to at

00:18:20,480 --> 00:18:24,080
least be

00:18:22,000 --> 00:18:25,679
fitting things into c types or c plus

00:18:24,080 --> 00:18:29,280
plus types for them to

00:18:25,679 --> 00:18:31,520
correlate to hardware if you're using

00:18:29,280 --> 00:18:33,679
regular expressions to check your

00:18:31,520 --> 00:18:35,120
data types you're using a soft type

00:18:33,679 --> 00:18:38,220
system

00:18:35,120 --> 00:18:39,919
you could probably make the general

00:18:38,220 --> 00:18:42,160
[Music]

00:18:39,919 --> 00:18:43,919
stereotype that soft type systems are

00:18:42,160 --> 00:18:45,760
slow and hard type systems are fast but

00:18:43,919 --> 00:18:46,640
it really has more to do with the data

00:18:45,760 --> 00:18:49,679
types and how to

00:18:46,640 --> 00:18:52,160
the data ty the data

00:18:49,679 --> 00:18:53,760
values and structures and how quickly

00:18:52,160 --> 00:18:56,880
you can access them

00:18:53,760 --> 00:18:58,320
when your program is running if you want

00:18:56,880 --> 00:19:00,080
that to be fast you're going to need to

00:18:58,320 --> 00:19:00,880
use a hard type system because it needs

00:19:00,080 --> 00:19:03,039
to be able to

00:19:00,880 --> 00:19:05,679
compile down to these hardware types

00:19:03,039 --> 00:19:08,960
that are thus going to be fast

00:19:05,679 --> 00:19:10,720
again if you don't care about speed use

00:19:08,960 --> 00:19:11,760
a slow fake type system it doesn't

00:19:10,720 --> 00:19:14,400
matter to me

00:19:11,760 --> 00:19:15,120
um and last but not least as mentioned

00:19:14,400 --> 00:19:18,080
uh

00:19:15,120 --> 00:19:19,679
sort of just now um the the fake type

00:19:18,080 --> 00:19:20,880
systems are generally just going to be

00:19:19,679 --> 00:19:23,120
interpreted they're not

00:19:20,880 --> 00:19:24,960
trying to compile anything they're not

00:19:23,120 --> 00:19:26,960
even related to compiling anything

00:19:24,960 --> 00:19:28,160
they're just so you can kind of feel

00:19:26,960 --> 00:19:30,640
good about your

00:19:28,160 --> 00:19:31,440
data being labeled better i guess and in

00:19:30,640 --> 00:19:34,960
some cases

00:19:31,440 --> 00:19:38,480
you can check to make sure certain

00:19:34,960 --> 00:19:41,679
data is within ranges or within vague

00:19:38,480 --> 00:19:43,120
types uh globs or you know

00:19:41,679 --> 00:19:46,240
conglomerations of types

00:19:43,120 --> 00:19:48,640
as as implemented by regular expressions

00:19:46,240 --> 00:19:49,760
um or something similar maybe just you

00:19:48,640 --> 00:19:52,240
know

00:19:49,760 --> 00:19:54,320
custom subroutines in perl that can

00:19:52,240 --> 00:19:54,640
check if something looks like a string

00:19:54,320 --> 00:19:57,600
or

00:19:54,640 --> 00:19:57,600
looks like a number

00:19:58,160 --> 00:20:02,880
but yeah um generally fake types are

00:20:01,120 --> 00:20:04,480
soft they're ad hoc they're using

00:20:02,880 --> 00:20:04,960
something like regular expressions

00:20:04,480 --> 00:20:09,120
they're

00:20:04,960 --> 00:20:11,679
slowly interpreted and real types are

00:20:09,120 --> 00:20:12,320
related hardware they're engineered like

00:20:11,679 --> 00:20:13,679
you have to

00:20:12,320 --> 00:20:15,440
think about how it relates to the

00:20:13,679 --> 00:20:18,480
hardware they're using

00:20:15,440 --> 00:20:20,159
actual c or lower level types it's going

00:20:18,480 --> 00:20:21,679
to be compiled and it's going to be fast

00:20:20,159 --> 00:20:24,000
and we are really just going to be

00:20:21,679 --> 00:20:25,679
talking about real types i haven't just

00:20:24,000 --> 00:20:28,000
wasted my breath to tell you all that so

00:20:25,679 --> 00:20:30,960
that i can go on to teach you about

00:20:28,000 --> 00:20:32,480
fake types sorry if you were here to

00:20:30,960 --> 00:20:35,760
learn about fake types again

00:20:32,480 --> 00:20:37,280
go read mark's blog posts

00:20:35,760 --> 00:20:38,720
by the way if anybody's like trying to

00:20:37,280 --> 00:20:39,760
write things in the chat system or

00:20:38,720 --> 00:20:42,159
something i'm

00:20:39,760 --> 00:20:42,960
not gonna be able to see it because i'm

00:20:42,159 --> 00:20:47,360
focused on

00:20:42,960 --> 00:20:51,039
talking okay

00:20:47,360 --> 00:20:52,720
next uh so what are

00:20:51,039 --> 00:20:54,320
the c data types that the perl

00:20:52,720 --> 00:20:55,679
interpreter uses because it has to use

00:20:54,320 --> 00:20:56,559
something right well yes of course it

00:20:55,679 --> 00:21:00,720
does

00:20:56,559 --> 00:21:04,240
um there's really only three um

00:21:00,720 --> 00:21:06,559
basic or primitive data types uh

00:21:04,240 --> 00:21:07,280
when you talk about primitive data types

00:21:06,559 --> 00:21:09,200
in c

00:21:07,280 --> 00:21:12,320
you're talking about things like

00:21:09,200 --> 00:21:14,400
integers floating point numbers

00:21:12,320 --> 00:21:16,320
character strings and that's what we

00:21:14,400 --> 00:21:20,000
have in fact these are

00:21:16,320 --> 00:21:22,640
implemented relatively simply but not

00:21:20,000 --> 00:21:24,480
nearly simply enough to be hard types

00:21:22,640 --> 00:21:25,840
these are soft types implemented in

00:21:24,480 --> 00:21:28,799
pearl using

00:21:25,840 --> 00:21:30,320
c89 which is what pearl itself is

00:21:28,799 --> 00:21:33,600
written in uh if you

00:21:30,320 --> 00:21:36,799
weren't aware really c

00:21:33,600 --> 00:21:38,640
is the new assembly and assembly is

00:21:36,799 --> 00:21:41,200
not really utilized directly much

00:21:38,640 --> 00:21:44,799
anymore except for specialty people or

00:21:41,200 --> 00:21:46,880
hobbyist purposes i suppose but you know

00:21:44,799 --> 00:21:48,720
c is written in c c plus plus is written

00:21:46,880 --> 00:21:51,200
in c perl is written in c

00:21:48,720 --> 00:21:52,640
linux is written in c i i guess other

00:21:51,200 --> 00:21:53,440
operating systems are written in c as

00:21:52,640 --> 00:21:56,960
well

00:21:53,440 --> 00:21:59,280
um so c is like what everything

00:21:56,960 --> 00:22:01,600
needs to compile to and then you run the

00:21:59,280 --> 00:22:04,000
c compiler as the last step

00:22:01,600 --> 00:22:05,520
and and that's the reason is because

00:22:04,000 --> 00:22:07,520
more effort has been put into c

00:22:05,520 --> 00:22:09,440
compilers than any other compilers

00:22:07,520 --> 00:22:10,640
and thus they are the fastest and the

00:22:09,440 --> 00:22:13,600
closest to

00:22:10,640 --> 00:22:14,240
assembly without being assembly and uh

00:22:13,600 --> 00:22:17,280
and make

00:22:14,240 --> 00:22:18,880
the most logical target for other

00:22:17,280 --> 00:22:21,600
languages

00:22:18,880 --> 00:22:23,600
so um again perl itself the pearl

00:22:21,600 --> 00:22:26,159
interpreter is written in c

00:22:23,600 --> 00:22:27,679
um and it implements these three

00:22:26,159 --> 00:22:30,240
primitive types iv

00:22:27,679 --> 00:22:31,919
which stands for integer value nv for

00:22:30,240 --> 00:22:33,760
number or numeric value

00:22:31,919 --> 00:22:35,440
and pv which stands for pointer value

00:22:33,760 --> 00:22:38,880
but it it means a string

00:22:35,440 --> 00:22:39,200
it's a like a character pointer remember

00:22:38,880 --> 00:22:41,520
in

00:22:39,200 --> 00:22:42,880
c a character pointer is used with how

00:22:41,520 --> 00:22:46,799
you make a string

00:22:42,880 --> 00:22:50,000
in c so um you'll see why we didn't have

00:22:46,799 --> 00:22:52,240
sv in a moment for string value because

00:22:50,000 --> 00:22:55,039
it's already in use for another purpose

00:22:52,240 --> 00:22:56,320
but uh those are the three primitive

00:22:55,039 --> 00:23:00,159
data types

00:22:56,320 --> 00:23:02,559
so you're going to be using one of those

00:23:00,159 --> 00:23:04,159
three or or all of them behind the

00:23:02,559 --> 00:23:07,840
scenes whenever you create

00:23:04,159 --> 00:23:10,159
a a scalar or primitive

00:23:07,840 --> 00:23:11,919
value in pearl itself when you're

00:23:10,159 --> 00:23:13,840
writing you know normal pearl code with

00:23:11,919 --> 00:23:17,200
dollar signs and so forth

00:23:13,840 --> 00:23:19,760
uh the way that that pearl handles this

00:23:17,200 --> 00:23:23,520
in the background is it creates

00:23:19,760 --> 00:23:27,440
enums or structs that actually will have

00:23:23,520 --> 00:23:30,480
an iv and envy and a pv that's the way

00:23:27,440 --> 00:23:33,840
that pearl allows you to store

00:23:30,480 --> 00:23:38,480
any kind of scalar value

00:23:33,840 --> 00:23:40,960
inside of a scalar variable so um

00:23:38,480 --> 00:23:42,960
perl will actually have a little magic

00:23:40,960 --> 00:23:46,080
thing that tells it which

00:23:42,960 --> 00:23:50,400
of these three is currently in use

00:23:46,080 --> 00:23:52,720
but you can overload a variable and

00:23:50,400 --> 00:23:54,640
have it have all three of these things

00:23:52,720 --> 00:23:55,919
set and then use magic stuff to access

00:23:54,640 --> 00:23:59,600
them so

00:23:55,919 --> 00:24:03,760
perl is giving you three at least

00:23:59,600 --> 00:24:06,720
three types of data

00:24:03,760 --> 00:24:08,880
for every one variable you create that's

00:24:06,720 --> 00:24:11,039
way top heavy and it's bloatware

00:24:08,880 --> 00:24:14,240
there's no reason to do that other than

00:24:11,039 --> 00:24:18,000
the fact that pearl does not currently

00:24:14,240 --> 00:24:20,080
know how not to do that i mean i would

00:24:18,000 --> 00:24:21,520
say thanks a lot saint larry but i'm

00:24:20,080 --> 00:24:23,520
saying thank you so much st

00:24:21,520 --> 00:24:24,960
larry for at least getting us here

00:24:23,520 --> 00:24:26,080
letting us have this language that we

00:24:24,960 --> 00:24:29,360
can

00:24:26,080 --> 00:24:29,679
improve upon so um these are these are

00:24:29,360 --> 00:24:32,799
the

00:24:29,679 --> 00:24:36,000
um underlying c

00:24:32,799 --> 00:24:38,640
data types and i i mark this as uh c

00:24:36,000 --> 00:24:39,120
is not fun change my mind because i've

00:24:38,640 --> 00:24:42,320
written

00:24:39,120 --> 00:24:44,159
more than enough c in my life hundreds

00:24:42,320 --> 00:24:46,000
or thousands of lines

00:24:44,159 --> 00:24:47,840
to never really want to write anymore

00:24:46,000 --> 00:24:48,880
ever again and the same thing pretty

00:24:47,840 --> 00:24:53,120
much goes for c

00:24:48,880 --> 00:24:56,080
plus which is one of the

00:24:53,120 --> 00:24:57,039
ostensible reasons why i created the

00:24:56,080 --> 00:24:59,760
pearl compiler

00:24:57,039 --> 00:25:00,240
in the first place so that someday some

00:24:59,760 --> 00:25:03,200
way

00:25:00,240 --> 00:25:05,440
when the compiler is done or at least i

00:25:03,200 --> 00:25:08,320
don't have to do it all myself anymore

00:25:05,440 --> 00:25:10,480
then i will hopefully not ever have to

00:25:08,320 --> 00:25:11,760
write any more crc plus plus code i can

00:25:10,480 --> 00:25:13,200
just

00:25:11,760 --> 00:25:15,520
write it all in pearl code and it will

00:25:13,200 --> 00:25:20,000
get compiled into cnc

00:25:15,520 --> 00:25:23,600
plus for me so that would be pretty cool

00:25:20,000 --> 00:25:24,000
meanwhile yeah we're stuck with what we

00:25:23,600 --> 00:25:27,279
have

00:25:24,000 --> 00:25:29,919
so next okay

00:25:27,279 --> 00:25:31,200
no meme on this one not enough room um

00:25:29,919 --> 00:25:35,440
these are the

00:25:31,200 --> 00:25:36,559
uh this is the three column table that

00:25:35,440 --> 00:25:39,039
shows

00:25:36,559 --> 00:25:39,600
um on the on the left side the original

00:25:39,039 --> 00:25:41,840
uh

00:25:39,600 --> 00:25:43,520
three primitive types that we just

00:25:41,840 --> 00:25:46,159
mentioned integer numeric

00:25:43,520 --> 00:25:47,039
and string value then in the middle

00:25:46,159 --> 00:25:50,480
column

00:25:47,039 --> 00:25:52,960
um we have uh the

00:25:50,480 --> 00:25:53,840
types that you can use now in perl this

00:25:52,960 --> 00:25:55,679
is through

00:25:53,840 --> 00:25:57,520
uh the arpro compiler these are the

00:25:55,679 --> 00:25:59,679
types that arpro implements for you

00:25:57,520 --> 00:26:00,799
primitive types primitive scalers and

00:25:59,679 --> 00:26:04,159
then here on the

00:26:00,799 --> 00:26:08,320
on the right side um is the

00:26:04,159 --> 00:26:11,279
uh what the perl compiler will output

00:26:08,320 --> 00:26:12,170
for you um and uh and the ones that

00:26:11,279 --> 00:26:13,600
appear on the same

00:26:12,170 --> 00:26:16,080
[Music]

00:26:13,600 --> 00:26:17,120
horizontal row are uh functionally

00:26:16,080 --> 00:26:20,240
equivalent

00:26:17,120 --> 00:26:23,679
so um a high magic

00:26:20,240 --> 00:26:24,960
uh soft type iv integer value written in

00:26:23,679 --> 00:26:27,360
c

00:26:24,960 --> 00:26:28,000
is functionally equivalent to uh to the

00:26:27,360 --> 00:26:31,440
type

00:26:28,000 --> 00:26:32,720
uh integer that is accessible now

00:26:31,440 --> 00:26:36,240
through the pearl compiler

00:26:32,720 --> 00:26:38,880
in your perl code which is also

00:26:36,240 --> 00:26:41,360
functionally equivalent to the just

00:26:38,880 --> 00:26:43,440
plain old-fashioned int

00:26:41,360 --> 00:26:45,679
raise your hand if you remember int yes

00:26:43,440 --> 00:26:47,760
i can see you all raising hands

00:26:45,679 --> 00:26:49,200
by the way i'm imagining laughter in my

00:26:47,760 --> 00:26:49,919
head every time i bring up one of these

00:26:49,200 --> 00:26:52,480
memes

00:26:49,919 --> 00:26:53,679
so please be sure that you do laugh that

00:26:52,480 --> 00:26:55,840
way i'm not just

00:26:53,679 --> 00:26:57,200
imagining things that aren't there

00:26:55,840 --> 00:26:58,720
because i'm pretty sure that would make

00:26:57,200 --> 00:27:03,039
me crazy and i'm not

00:26:58,720 --> 00:27:06,240
crazy i'm not crazy i'm crazy for pearl

00:27:03,039 --> 00:27:09,600
or at least for making it run fast so

00:27:06,240 --> 00:27:11,919
um you can also see that the nv

00:27:09,600 --> 00:27:12,960
is accessible now through using the type

00:27:11,919 --> 00:27:14,720
called number

00:27:12,960 --> 00:27:16,559
and that is functionally equivalent to

00:27:14,720 --> 00:27:18,720
the good old-fashioned

00:27:16,559 --> 00:27:20,159
double you probably remember float

00:27:18,720 --> 00:27:22,960
single double

00:27:20,159 --> 00:27:23,919
um long there's double long or there's

00:27:22,960 --> 00:27:27,039
several other

00:27:23,919 --> 00:27:28,640
ones that are all kind of different but

00:27:27,039 --> 00:27:30,000
similar and it just means a floating

00:27:28,640 --> 00:27:30,880
point number a number with decimal

00:27:30,000 --> 00:27:34,480
places

00:27:30,880 --> 00:27:37,760
and then pv um is accessible now through

00:27:34,480 --> 00:27:40,880
perl as a string data type and uh and

00:27:37,760 --> 00:27:41,520
that is being compiled into a a standard

00:27:40,880 --> 00:27:43,120
string

00:27:41,520 --> 00:27:45,679
in c plus plus and those are all

00:27:43,120 --> 00:27:47,760
functional equivalent now

00:27:45,679 --> 00:27:48,799
you'll notice we have seven data types

00:27:47,760 --> 00:27:51,279
here but only

00:27:48,799 --> 00:27:52,399
three of the original primitives that's

00:27:51,279 --> 00:27:55,840
because

00:27:52,399 --> 00:27:58,240
we needed to improve um it wasn't enough

00:27:55,840 --> 00:27:59,440
to just have iv and v and pv we needed

00:27:58,240 --> 00:28:02,799
other things

00:27:59,440 --> 00:28:06,240
so we do now have boolean which is a

00:28:02,799 --> 00:28:08,880
simply a bool a zero or one truth type

00:28:06,240 --> 00:28:10,559
value we have unsigned integer which is

00:28:08,880 --> 00:28:14,640
an unsigned int

00:28:10,559 --> 00:28:17,600
um and we have a gmp integer

00:28:14,640 --> 00:28:19,360
which is the new multi-precision library

00:28:17,600 --> 00:28:22,159
that's an integer that has as many

00:28:19,360 --> 00:28:24,399
digits as you want um and that is uh

00:28:22,159 --> 00:28:27,520
compiled into an mpz

00:28:24,399 --> 00:28:28,480
type the multi-precision type in the

00:28:27,520 --> 00:28:30,799
background and

00:28:28,480 --> 00:28:32,559
we also added a single character for

00:28:30,799 --> 00:28:35,760
when you just need one

00:28:32,559 --> 00:28:38,159
character and that of course compiles

00:28:35,760 --> 00:28:41,760
down to just a char

00:28:38,159 --> 00:28:42,480
so uh yeah we have all seven of these

00:28:41,760 --> 00:28:45,520
primitive

00:28:42,480 --> 00:28:46,960
uh data types available now

00:28:45,520 --> 00:28:48,559
right now today you could be using them

00:28:46,960 --> 00:28:49,360
in perl and all of your perl code you

00:28:48,559 --> 00:28:51,200
should

00:28:49,360 --> 00:28:53,039
you should now remember you're not going

00:28:51,200 --> 00:28:55,200
to be typing

00:28:53,039 --> 00:28:56,720
iv anywhere in your curl code you're not

00:28:55,200 --> 00:28:58,000
going to be typing into anywhere in your

00:28:56,720 --> 00:28:59,760
perl code you're only going to be using

00:28:58,000 --> 00:29:03,440
the things in the middle column

00:28:59,760 --> 00:29:06,960
okay integer number character string

00:29:03,440 --> 00:29:07,919
these are the names of the data types in

00:29:06,960 --> 00:29:09,279
perl

00:29:07,919 --> 00:29:11,120
that you need to be typing into your

00:29:09,279 --> 00:29:15,679
perl code they're descriptive

00:29:11,120 --> 00:29:18,799
they're much more descriptive than mpzt

00:29:15,679 --> 00:29:19,919
for example um or even double what does

00:29:18,799 --> 00:29:22,159
double really mean

00:29:19,919 --> 00:29:23,039
i mean if you're not an old school c

00:29:22,159 --> 00:29:26,240
programmer you

00:29:23,039 --> 00:29:28,080
might not know so um

00:29:26,240 --> 00:29:29,279
and we wanted them to correspond as much

00:29:28,080 --> 00:29:32,480
as we could to the

00:29:29,279 --> 00:29:35,520
underlying types as well so there you go

00:29:32,480 --> 00:29:37,919
um those are your names of pearl data

00:29:35,520 --> 00:29:37,919
types

00:29:38,000 --> 00:29:43,840
hope you like it next okay we have some

00:29:41,039 --> 00:29:46,960
examples of scalar

00:29:43,840 --> 00:29:47,520
data types here um sorry the code's a

00:29:46,960 --> 00:29:51,279
little

00:29:47,520 --> 00:29:51,279
small hopefully you can see it

00:29:51,520 --> 00:29:58,799
um so yes we have uh a number of

00:29:55,360 --> 00:30:01,919
options and uh ways to use

00:29:58,799 --> 00:30:03,120
data types here um i didn't put any

00:30:01,919 --> 00:30:05,440
integers in this

00:30:03,120 --> 00:30:07,279
example i don't think but just imagine

00:30:05,440 --> 00:30:09,679
one of the numbers as an integer

00:30:07,279 --> 00:30:10,320
uh you can imagine any of them this is

00:30:09,679 --> 00:30:12,399
just

00:30:10,320 --> 00:30:14,399
some random code i picked up that was

00:30:12,399 --> 00:30:17,279
easy to use so

00:30:14,399 --> 00:30:18,799
we can use data types uh scalar data

00:30:17,279 --> 00:30:20,840
types in constants

00:30:18,799 --> 00:30:24,240
but you didn't know that pearl had

00:30:20,840 --> 00:30:26,880
constants huh huh

00:30:24,240 --> 00:30:27,279
uh well it does um it's a little bit you

00:30:26,880 --> 00:30:29,919
know

00:30:27,279 --> 00:30:32,399
interesting syntax right now to to get

00:30:29,919 --> 00:30:35,120
typed constants but you can

00:30:32,399 --> 00:30:36,000
and so here's uh the first one here is a

00:30:35,120 --> 00:30:38,880
number

00:30:36,000 --> 00:30:39,520
you can see number there it's my number

00:30:38,880 --> 00:30:41,200
um

00:30:39,520 --> 00:30:43,440
and this will be compiled into a

00:30:41,200 --> 00:30:44,080
constant it will be compiled into an

00:30:43,440 --> 00:30:46,399
actual

00:30:44,080 --> 00:30:47,600
ultra fast constant can't get any faster

00:30:46,399 --> 00:30:49,440
than a constant because it can't be

00:30:47,600 --> 00:30:50,640
changed it has all the special rules and

00:30:49,440 --> 00:30:53,760
it's a hard-coded

00:30:50,640 --> 00:30:55,360
memory location or whatever it is so um

00:30:53,760 --> 00:30:57,760
yeah that's compiled into a

00:30:55,360 --> 00:30:59,600
c plus plus constant uh constant number

00:30:57,760 --> 00:31:01,679
and then likewise you could do strings

00:30:59,600 --> 00:31:03,360
characters all the other types that we

00:31:01,679 --> 00:31:07,440
mentioned

00:31:03,360 --> 00:31:09,440
subroutines um well there is a void type

00:31:07,440 --> 00:31:10,799
especially really it's only used for

00:31:09,440 --> 00:31:13,519
subroutines for when you're

00:31:10,799 --> 00:31:14,000
not returning any values but you may

00:31:13,519 --> 00:31:16,960
need it

00:31:14,000 --> 00:31:17,519
in some cases um more than likely you're

00:31:16,960 --> 00:31:20,799
going to have

00:31:17,519 --> 00:31:22,000
at least one real return type um here

00:31:20,799 --> 00:31:25,440
with the

00:31:22,000 --> 00:31:26,960
pi r squared sub routine it's returning

00:31:25,440 --> 00:31:28,000
just a single number but you could put a

00:31:26,960 --> 00:31:32,399
comma here and put

00:31:28,000 --> 00:31:33,840
my string this or my this or that um oh

00:31:32,399 --> 00:31:35,600
wait no this that would be for input

00:31:33,840 --> 00:31:36,000
sorry the return types are only one time

00:31:35,600 --> 00:31:38,640
but the

00:31:36,000 --> 00:31:39,440
input the next line here is where you

00:31:38,640 --> 00:31:41,039
could have multiple

00:31:39,440 --> 00:31:42,480
you could have this one is just taking a

00:31:41,039 --> 00:31:43,200
single number in returning a single

00:31:42,480 --> 00:31:46,080
number out

00:31:43,200 --> 00:31:48,559
you could have one or more different

00:31:46,080 --> 00:31:52,559
data types input just put a comma there

00:31:48,559 --> 00:31:53,440
and then um my integer this my string

00:31:52,559 --> 00:31:56,880
that and so forth

00:31:53,440 --> 00:31:59,039
uh have as many inputs as you like

00:31:56,880 --> 00:32:00,720
utilize those inputs inside of the

00:31:59,039 --> 00:32:04,480
subroutine body

00:32:00,720 --> 00:32:06,399
and uh and then returned

00:32:04,480 --> 00:32:10,480
the return value hopefully that matches

00:32:06,399 --> 00:32:13,679
the return type that you declared above

00:32:10,480 --> 00:32:16,960
you can directly

00:32:13,679 --> 00:32:18,559
declare variables um just

00:32:16,960 --> 00:32:21,760
outside of subroutines in your normal

00:32:18,559 --> 00:32:23,120
code here we have my number area

00:32:21,760 --> 00:32:25,039
you don't have to set it to a value

00:32:23,120 --> 00:32:26,320
immediately you can if you want to

00:32:25,039 --> 00:32:28,480
you could just say my number area

00:32:26,320 --> 00:32:30,559
semicolon just to declare it and then

00:32:28,480 --> 00:32:32,640
you can

00:32:30,559 --> 00:32:34,960
modify the value later set and modify it

00:32:32,640 --> 00:32:34,960
later

00:32:35,120 --> 00:32:39,919
you can also see that that

00:32:38,320 --> 00:32:43,279
although we won't be getting into it

00:32:39,919 --> 00:32:46,960
today class names are also data types

00:32:43,279 --> 00:32:49,200
uh and so you can declare an object

00:32:46,960 --> 00:32:50,799
by having a class name here in this case

00:32:49,200 --> 00:32:54,799
mybar class

00:32:50,799 --> 00:32:58,000
um and bar object is getting

00:32:54,799 --> 00:33:00,080
initialized with these uh initialization

00:32:58,000 --> 00:33:03,600
values here a number and a string

00:33:00,080 --> 00:33:08,240
um which are themselves uh declared as

00:33:03,600 --> 00:33:08,240
a number and string in the um

00:33:08,559 --> 00:33:11,919
class definition which we're not again

00:33:10,880 --> 00:33:15,360
going to get into

00:33:11,919 --> 00:33:17,519
classes today but needless to say um

00:33:15,360 --> 00:33:19,440
the compiler does support uh

00:33:17,519 --> 00:33:21,279
user-defined classes of course these are

00:33:19,440 --> 00:33:24,559
compiled directly into ultra fast c

00:33:21,279 --> 00:33:28,320
plus plus classes there's no way

00:33:24,559 --> 00:33:31,440
to be faster so um

00:33:28,320 --> 00:33:34,799
there's just a handful of examples

00:33:31,440 --> 00:33:38,000
for scalars scalar values

00:33:34,799 --> 00:33:41,919
scalar variables in pearl

00:33:38,000 --> 00:33:45,679
next okay they wanted me to use c

00:33:41,919 --> 00:33:48,320
data types so apparently

00:33:45,679 --> 00:33:49,600
this little girl turned to a life of

00:33:48,320 --> 00:33:52,559
crime

00:33:49,600 --> 00:33:54,799
or so it would appear i know that's what

00:33:52,559 --> 00:33:56,480
i would consider doing if someone was

00:33:54,799 --> 00:34:00,880
forcing me to use c

00:33:56,480 --> 00:34:02,960
data types all the time um

00:34:00,880 --> 00:34:04,080
i wouldn't actually burn anything down

00:34:02,960 --> 00:34:07,120
but i would

00:34:04,080 --> 00:34:11,119
be very unhappy in my mind

00:34:07,120 --> 00:34:13,839
um so anyway there there are

00:34:11,119 --> 00:34:15,679
uh c data types and t data structures

00:34:13,839 --> 00:34:17,280
that we again need to to at least be

00:34:15,679 --> 00:34:21,599
familiar with

00:34:17,280 --> 00:34:24,560
so in this case um these are the

00:34:21,599 --> 00:34:25,839
the the left two are the sort of common

00:34:24,560 --> 00:34:28,720
data structures

00:34:25,839 --> 00:34:31,119
arrays and hashes it's a v for array

00:34:28,720 --> 00:34:34,560
value and h v for hash value

00:34:31,119 --> 00:34:35,440
um there are also two other sort of

00:34:34,560 --> 00:34:39,280
specialty

00:34:35,440 --> 00:34:41,280
data type structure thingies

00:34:39,280 --> 00:34:43,040
um i don't know which i would classify

00:34:41,280 --> 00:34:46,399
them as so i put them on this page

00:34:43,040 --> 00:34:49,440
um a scalar value sv and reference value

00:34:46,399 --> 00:34:50,320
rv and the way that these all work

00:34:49,440 --> 00:34:53,119
together is

00:34:50,320 --> 00:34:53,760
relatively convoluted we're not going to

00:34:53,119 --> 00:34:56,960
try and

00:34:53,760 --> 00:34:58,640
explain to you how to to do this all in

00:34:56,960 --> 00:35:03,040
the high magic

00:34:58,640 --> 00:35:05,520
c89 code that's that's a whole other

00:35:03,040 --> 00:35:06,720
ball game um but you do need to at least

00:35:05,520 --> 00:35:09,680
know that these

00:35:06,720 --> 00:35:11,599
types exist and again these are

00:35:09,680 --> 00:35:13,040
implemented in the peril interpreter and

00:35:11,599 --> 00:35:15,599
c89 just like the

00:35:13,040 --> 00:35:16,880
iv envy and pv by the way this is why

00:35:15,599 --> 00:35:20,480
you can't have sv for

00:35:16,880 --> 00:35:23,680
string value because sv is scalar value

00:35:20,480 --> 00:35:27,599
um but you can take references

00:35:23,680 --> 00:35:29,680
of arrays and hashes and scalars

00:35:27,599 --> 00:35:31,839
so you can kind of chain these types

00:35:29,680 --> 00:35:35,359
together in a way

00:35:31,839 --> 00:35:36,079
and sv scalar values can hold reference

00:35:35,359 --> 00:35:40,160
values

00:35:36,079 --> 00:35:43,040
as well as holding ivs nvs and pvs

00:35:40,160 --> 00:35:43,760
if you're still not confused yet go read

00:35:43,040 --> 00:35:47,520
pearl

00:35:43,760 --> 00:35:50,079
guts so um

00:35:47,520 --> 00:35:51,280
you and after doing which you too may

00:35:50,079 --> 00:35:53,040
feel like this

00:35:51,280 --> 00:35:55,680
little girl who wants to burn people's

00:35:53,040 --> 00:35:56,960
houses down uh it's it's just not simple

00:35:55,680 --> 00:36:00,560
or straightforward it's

00:35:56,960 --> 00:36:02,560
really it's really complicated but

00:36:00,560 --> 00:36:03,920
it's there it's what we've got it's how

00:36:02,560 --> 00:36:04,880
pearl interpreter works it's not going

00:36:03,920 --> 00:36:08,480
to change

00:36:04,880 --> 00:36:11,200
probably ever but what we can do is

00:36:08,480 --> 00:36:13,359
continue to improve improve improve

00:36:11,200 --> 00:36:16,640
improve next

00:36:13,359 --> 00:36:19,599
so here's the examples of improvement

00:36:16,640 --> 00:36:20,960
these are one-dimensional um data

00:36:19,599 --> 00:36:22,960
structures

00:36:20,960 --> 00:36:24,000
in pearl on the left and in c plus plus

00:36:22,960 --> 00:36:25,359
on the right now we're not going to do a

00:36:24,000 --> 00:36:27,760
three column with the c

00:36:25,359 --> 00:36:29,520
on the far left like we did with the

00:36:27,760 --> 00:36:31,440
primitives

00:36:29,520 --> 00:36:32,640
because as mentioned it would be far too

00:36:31,440 --> 00:36:34,560
convoluted and it's a whole bunch of

00:36:32,640 --> 00:36:35,280
wacky chaining of different things and

00:36:34,560 --> 00:36:38,720
it's

00:36:35,280 --> 00:36:40,560
just not within the it's not it's

00:36:38,720 --> 00:36:42,560
somewhat pertinent but it's not within

00:36:40,560 --> 00:36:46,160
the um

00:36:42,560 --> 00:36:48,960
uh the scope of of the time

00:36:46,160 --> 00:36:50,640
we have available for this talk so if

00:36:48,960 --> 00:36:52,640
you really want to know about that again

00:36:50,640 --> 00:36:54,560
check out pearl guts or just chat with

00:36:52,640 --> 00:36:58,160
me offline

00:36:54,560 --> 00:37:01,520
so again on this um

00:36:58,160 --> 00:37:02,000
two column table everything that's on a

00:37:01,520 --> 00:37:05,040
row

00:37:02,000 --> 00:37:08,240
is functionally equivalent so we have

00:37:05,040 --> 00:37:10,320
um actually i left out the

00:37:08,240 --> 00:37:11,760
multi-precision integers so we have six

00:37:10,320 --> 00:37:15,359
of the seven

00:37:11,760 --> 00:37:17,119
um primitive types here the the

00:37:15,359 --> 00:37:18,800
integer is really kind of a special type

00:37:17,119 --> 00:37:20,880
because i had to shoehorn it in there

00:37:18,800 --> 00:37:22,400
through the the gnu multi-precision

00:37:20,880 --> 00:37:24,640
library it's

00:37:22,400 --> 00:37:26,079
it's not part of the standard c plus

00:37:24,640 --> 00:37:28,640
plus library or the c

00:37:26,079 --> 00:37:30,160
itself but nevertheless it's i think

00:37:28,640 --> 00:37:32,880
important enough to have

00:37:30,160 --> 00:37:33,760
so um but for now just for the sake of

00:37:32,880 --> 00:37:35,920
this slide

00:37:33,760 --> 00:37:37,440
sorry i forgot it i left it out so

00:37:35,920 --> 00:37:39,440
here's the six

00:37:37,440 --> 00:37:41,760
um boolean unsigned integer integer

00:37:39,440 --> 00:37:44,480
number character string and again

00:37:41,760 --> 00:37:46,480
at the bottom here these top ones are

00:37:44,480 --> 00:37:47,280
array refs and the bottom ones are

00:37:46,480 --> 00:37:50,000
hashrefs

00:37:47,280 --> 00:37:51,040
so in your perl code you could write

00:37:50,000 --> 00:37:54,800
boolean

00:37:51,040 --> 00:37:59,599
array ref and that will be compiled into

00:37:54,800 --> 00:38:03,520
a standard vector of bool data types

00:37:59,599 --> 00:38:04,000
likewise a number array ref would get

00:38:03,520 --> 00:38:07,200
compiled

00:38:04,000 --> 00:38:09,200
into a vector of doubles and a string

00:38:07,200 --> 00:38:09,760
array ref into a vector of standard

00:38:09,200 --> 00:38:12,480
strings

00:38:09,760 --> 00:38:13,280
a standard vector of standard strings

00:38:12,480 --> 00:38:17,200
vector vector

00:38:13,280 --> 00:38:20,480
vector standard standard standard so

00:38:17,200 --> 00:38:23,280
similarly for all the hash reps

00:38:20,480 --> 00:38:25,040
array reps are currently compiled into

00:38:23,280 --> 00:38:27,040
standard vectors and hashgraphs are

00:38:25,040 --> 00:38:30,560
currently compiled into standard

00:38:27,040 --> 00:38:32,320
unordered maps and

00:38:30,560 --> 00:38:33,839
arrays versus values not withstanding

00:38:32,320 --> 00:38:37,119
we'll talk about it in a moment

00:38:33,839 --> 00:38:40,400
uh these are functionally equivalent so

00:38:37,119 --> 00:38:42,320
a vector in c plus plus and an array in

00:38:40,400 --> 00:38:45,599
perl are functionally equivalent

00:38:42,320 --> 00:38:49,119
and an unordered map in c plus

00:38:45,599 --> 00:38:50,079
and a hash in perl are functionally

00:38:49,119 --> 00:38:52,720
equivalent

00:38:50,079 --> 00:38:53,760
so um oh and you'll notice that the

00:38:52,720 --> 00:38:57,280
unordered maps

00:38:53,760 --> 00:38:59,920
um they're all keyed off of strings

00:38:57,280 --> 00:39:00,800
so you're taking a standard string as

00:38:59,920 --> 00:39:03,760
the

00:39:00,800 --> 00:39:05,599
input key and it's looking up a boolean

00:39:03,760 --> 00:39:08,960
value or a double or a char

00:39:05,599 --> 00:39:12,320
or another string in that case

00:39:08,960 --> 00:39:15,599
so we could

00:39:12,320 --> 00:39:19,680
key off of integers

00:39:15,599 --> 00:39:22,640
or i think other data types as well but

00:39:19,680 --> 00:39:25,280
that's not for the standard usage

00:39:22,640 --> 00:39:26,320
purposes of parole hashes is to key off

00:39:25,280 --> 00:39:28,240
of strings

00:39:26,320 --> 00:39:30,480
so we'll treat them as strings and plus

00:39:28,240 --> 00:39:34,880
we can upgrade any

00:39:30,480 --> 00:39:38,400
non-strings to strings um

00:39:34,880 --> 00:39:40,320
if if need be but going backwards not so

00:39:38,400 --> 00:39:43,440
much

00:39:40,320 --> 00:39:46,560
so yes that uh that should explain

00:39:43,440 --> 00:39:47,599
in general um how the one-dimensional

00:39:46,560 --> 00:39:50,560
data structures

00:39:47,599 --> 00:39:51,520
uh end up getting compiled um again

00:39:50,560 --> 00:39:54,560
there's a

00:39:51,520 --> 00:39:57,280
ton of compiling stuff that has to

00:39:54,560 --> 00:39:59,200
happen for this to occur and i'm not

00:39:57,280 --> 00:40:00,800
giving an introduction to the compiler

00:39:59,200 --> 00:40:02,480
right now this is an introduction only

00:40:00,800 --> 00:40:05,520
to the data types

00:40:02,480 --> 00:40:06,640
so sorry for skipping over some compiler

00:40:05,520 --> 00:40:10,240
related details

00:40:06,640 --> 00:40:11,280
next array examples okay

00:40:10,240 --> 00:40:12,560
we're gonna have to get through these

00:40:11,280 --> 00:40:13,680
kind of quick because we're already

00:40:12,560 --> 00:40:16,960
getting

00:40:13,680 --> 00:40:20,960
on to the uh on the time here

00:40:16,960 --> 00:40:23,599
but uh you can see that these top two

00:40:20,960 --> 00:40:25,200
lines are both valid um oh you'll notice

00:40:23,599 --> 00:40:27,839
there's an underscore here into the

00:40:25,200 --> 00:40:31,520
instead of the double colon scope

00:40:27,839 --> 00:40:35,040
operator this is because i am upgrading

00:40:31,520 --> 00:40:38,319
the pearl type system currently to

00:40:35,040 --> 00:40:39,839
be composable um if you want to write

00:40:38,319 --> 00:40:41,440
the code right now just put underscore

00:40:39,839 --> 00:40:44,800
and then you can change it

00:40:41,440 --> 00:40:48,000
um with a regex if you want

00:40:44,800 --> 00:40:51,599
to the scope uh double colon

00:40:48,000 --> 00:40:52,960
when we have uh next version or two of

00:40:51,599 --> 00:40:54,160
our pro come out

00:40:52,960 --> 00:40:56,720
um until then you can just put

00:40:54,160 --> 00:40:59,359
underscores it's fine um

00:40:56,720 --> 00:40:59,920
so you can make an empty array ref you

00:40:59,359 --> 00:41:03,200
can make

00:40:59,920 --> 00:41:05,839
a singleton array ref um you can

00:41:03,200 --> 00:41:08,640
declare an array ref without a value and

00:41:05,839 --> 00:41:12,160
then assign a value

00:41:08,640 --> 00:41:16,800
you can call these built-in subroutines

00:41:12,160 --> 00:41:20,000
that are the data type and then tostring

00:41:16,800 --> 00:41:22,000
that will stringify your type

00:41:20,000 --> 00:41:23,599
um there's also other conversion

00:41:22,000 --> 00:41:25,119
subroutines that can convert to other

00:41:23,599 --> 00:41:27,359
types and so forth

00:41:25,119 --> 00:41:28,800
not so easy for data structures more for

00:41:27,359 --> 00:41:31,040
the primitives but you've got you know

00:41:28,800 --> 00:41:33,359
integer to string screen integer

00:41:31,040 --> 00:41:34,160
integer number number to integer

00:41:33,359 --> 00:41:36,480
numbered string

00:41:34,160 --> 00:41:37,520
string the number all of those built-in

00:41:36,480 --> 00:41:40,319
conversions

00:41:37,520 --> 00:41:40,790
you can access to convert the primitives

00:41:40,319 --> 00:41:42,160
um

00:41:40,790 --> 00:41:46,000
[Music]

00:41:42,160 --> 00:41:47,119
and then uh oh yes hard versus soft

00:41:46,000 --> 00:41:50,960
types

00:41:47,119 --> 00:41:53,599
so for these first three lines

00:41:50,960 --> 00:41:57,119
they would pass just fine in a hard syst

00:41:53,599 --> 00:41:59,520
type system or in a soft type system

00:41:57,119 --> 00:42:00,319
because all of the items in the integer

00:41:59,520 --> 00:42:03,839
array ref

00:42:00,319 --> 00:42:06,400
all of the elements are integers all the

00:42:03,839 --> 00:42:07,200
elements in the number are numbers or

00:42:06,400 --> 00:42:09,839
integers which

00:42:07,200 --> 00:42:11,520
fall under numbers um and all the

00:42:09,839 --> 00:42:12,880
elements in the string ray ref are

00:42:11,520 --> 00:42:16,319
strings

00:42:12,880 --> 00:42:20,560
however for the last three lines here

00:42:16,319 --> 00:42:24,319
um there are elements that do not match

00:42:20,560 --> 00:42:27,520
um and this would uh may emit a

00:42:24,319 --> 00:42:28,640
warning but still run in a soft type

00:42:27,520 --> 00:42:32,079
system

00:42:28,640 --> 00:42:35,440
uh this will emit a hard error

00:42:32,079 --> 00:42:40,160
and not run at all in a hard

00:42:35,440 --> 00:42:42,400
type system so um 15.5 is not an integer

00:42:40,160 --> 00:42:46,720
it cannot be stored inside of an integer

00:42:42,400 --> 00:42:49,040
data type um and so that that will

00:42:46,720 --> 00:42:50,160
fail to compile it will be a compiler

00:42:49,040 --> 00:42:52,560
error

00:42:50,160 --> 00:42:54,319
uh or if you're trying to set that value

00:42:52,560 --> 00:42:55,680
during runtime it will be a runtime

00:42:54,319 --> 00:42:57,359
error

00:42:55,680 --> 00:42:59,200
memory access error or something like

00:42:57,359 --> 00:43:01,200
that uh

00:42:59,200 --> 00:43:02,400
and likewise for these others that have

00:43:01,200 --> 00:43:05,599
mismatching types

00:43:02,400 --> 00:43:08,640
15 is a string inside of a number

00:43:05,599 --> 00:43:09,760
all right ref and so forth so uh just a

00:43:08,640 --> 00:43:12,240
little example of

00:43:09,760 --> 00:43:12,960
the hard versus type soft type systems

00:43:12,240 --> 00:43:15,200
next

00:43:12,960 --> 00:43:18,079
coming upgrades y'all got any more than

00:43:15,200 --> 00:43:21,280
pearl beta tap upgrades

00:43:18,079 --> 00:43:22,240
oh dave chappelle glad you didn't die in

00:43:21,280 --> 00:43:25,520
africa

00:43:22,240 --> 00:43:27,359
so um uh

00:43:25,520 --> 00:43:29,599
he did disappear he came back he's

00:43:27,359 --> 00:43:32,640
hilarious but with a foul mouth

00:43:29,599 --> 00:43:35,760
please consume with caution

00:43:32,640 --> 00:43:38,400
um but still quite a funny comedian and

00:43:35,760 --> 00:43:38,839
uh and he is addicted to something in

00:43:38,400 --> 00:43:41,760
this

00:43:38,839 --> 00:43:42,640
um in this skit i'm addicted to pearl

00:43:41,760 --> 00:43:44,960
data types

00:43:42,640 --> 00:43:46,240
so we're going to always keep upgrading

00:43:44,960 --> 00:43:48,800
our pro data types

00:43:46,240 --> 00:43:51,200
um at least until we have the full range

00:43:48,800 --> 00:43:54,160
of of modern data types

00:43:51,200 --> 00:43:54,880
some coming upgrades include arrays and

00:43:54,160 --> 00:43:56,720
hashes by

00:43:54,880 --> 00:43:57,839
value instead of by reference only as

00:43:56,720 --> 00:43:59,599
they are currently implemented

00:43:57,839 --> 00:44:00,400
composable data structures that would be

00:43:59,599 --> 00:44:03,119
the

00:44:00,400 --> 00:44:04,400
double colon scope operator instead of

00:44:03,119 --> 00:44:06,560
the underscores

00:44:04,400 --> 00:44:07,680
so you can mix and match and not have

00:44:06,560 --> 00:44:09,760
them hard coded

00:44:07,680 --> 00:44:11,040
like that multi-dimensional data

00:44:09,760 --> 00:44:14,160
structures

00:44:11,040 --> 00:44:14,880
um c plus plus templates i'm working on

00:44:14,160 --> 00:44:18,480
now that

00:44:14,880 --> 00:44:21,200
just allows us to have much more robust

00:44:18,480 --> 00:44:22,960
type system in perl generic reference

00:44:21,200 --> 00:44:26,480
and dereferencing

00:44:22,960 --> 00:44:29,920
right now do the arrays

00:44:26,480 --> 00:44:33,440
by value versus arrays by reference

00:44:29,920 --> 00:44:35,760
issue um some of the reference and

00:44:33,440 --> 00:44:38,880
dereference stuff is contrived or

00:44:35,760 --> 00:44:41,440
limited um we also

00:44:38,880 --> 00:44:42,800
will eventually enable a scalar data

00:44:41,440 --> 00:44:46,800
type it's already has a

00:44:42,800 --> 00:44:48,480
placeholder but that would be the

00:44:46,800 --> 00:44:50,000
the data type that can hold the other

00:44:48,480 --> 00:44:52,720
three data types that i mentioned so

00:44:50,000 --> 00:44:53,280
that would actually be implementing the

00:44:52,720 --> 00:44:56,720
sv

00:44:53,280 --> 00:44:59,040
that can hold an iv envy or pv

00:44:56,720 --> 00:45:01,200
so it could hold an integer number or

00:44:59,040 --> 00:45:03,599
string

00:45:01,200 --> 00:45:05,280
we may implement an unknown data type

00:45:03,599 --> 00:45:06,800
this this is when you just

00:45:05,280 --> 00:45:08,480
don't know what it's going to hold and

00:45:06,800 --> 00:45:10,800
it could hold anything

00:45:08,480 --> 00:45:13,280
we may also implement auto at some point

00:45:10,800 --> 00:45:16,480
although i don't want people to get lazy

00:45:13,280 --> 00:45:17,599
i know that when c plus created auto it

00:45:16,480 --> 00:45:19,200
made a lot of people

00:45:17,599 --> 00:45:21,200
stop paying attention to what their data

00:45:19,200 --> 00:45:23,680
types were and just try and make the

00:45:21,200 --> 00:45:26,960
compiler figured out for them and that

00:45:23,680 --> 00:45:28,160
completely destroys all the readability

00:45:26,960 --> 00:45:31,200
maintainability

00:45:28,160 --> 00:45:32,640
and all of those other reasons why

00:45:31,200 --> 00:45:34,720
we want to use types in the first place

00:45:32,640 --> 00:45:36,319
it would still make it fast and

00:45:34,720 --> 00:45:38,560
hopefully still help with correctness

00:45:36,319 --> 00:45:41,599
but not as much

00:45:38,560 --> 00:45:44,800
as explicit user user

00:45:41,599 --> 00:45:47,440
provided data types so

00:45:44,800 --> 00:45:49,440
in the last few minutes i'll just say um

00:45:47,440 --> 00:45:51,920
data types data types data types

00:45:49,440 --> 00:45:52,480
ancient aliens maybe the ancient aliens

00:45:51,920 --> 00:45:55,920
brought us

00:45:52,480 --> 00:45:58,640
data types i don't know but um

00:45:55,920 --> 00:46:00,640
okay so uh the first two lines are valid

00:45:58,640 --> 00:46:01,200
in normal perl only the third line is

00:46:00,640 --> 00:46:03,760
valid

00:46:01,200 --> 00:46:05,119
in compiled pearl because we're only

00:46:03,760 --> 00:46:06,720
currently have

00:46:05,119 --> 00:46:08,400
raised by reference and you have to have

00:46:06,720 --> 00:46:10,640
data types for those rays

00:46:08,400 --> 00:46:12,800
in the future we would be able to say my

00:46:10,640 --> 00:46:14,480
integer array

00:46:12,800 --> 00:46:15,839
on the first line and then it would be

00:46:14,480 --> 00:46:18,000
valid um that's

00:46:15,839 --> 00:46:19,520
one of the things we're working on uh

00:46:18,000 --> 00:46:22,640
you can also see some

00:46:19,520 --> 00:46:24,560
some of the uh contrived pushing and

00:46:22,640 --> 00:46:25,520
popping and de-referencing the third one

00:46:24,560 --> 00:46:27,599
would be

00:46:25,520 --> 00:46:29,200
um invalid because it's an unnecessary

00:46:27,599 --> 00:46:31,440
dereference the

00:46:29,200 --> 00:46:33,200
first two would be valid because it's

00:46:31,440 --> 00:46:35,839
necessary use by reference

00:46:33,200 --> 00:46:37,599
um just some examples of things again

00:46:35,839 --> 00:46:39,040
that were coming with upgrades other

00:46:37,599 --> 00:46:40,800
things that are coming with upgrades we

00:46:39,040 --> 00:46:42,800
do have some multi-dimensional stuff

00:46:40,800 --> 00:46:44,160
implemented already

00:46:42,800 --> 00:46:46,319
some of the two-dimensional stuff you

00:46:44,160 --> 00:46:48,160
can see an integer array ref array ref

00:46:46,319 --> 00:46:50,160
this would be a two-dimensional like a

00:46:48,160 --> 00:46:52,400
matrix a matrix of

00:46:50,160 --> 00:46:53,839
integers that compiles to a vector

00:46:52,400 --> 00:46:55,760
vector of ins

00:46:53,839 --> 00:46:56,880
you can see the other four you can

00:46:55,760 --> 00:46:59,359
combine together

00:46:56,880 --> 00:47:01,119
uh the hashes and array refs and a

00:46:59,359 --> 00:47:02,560
hashgraph of array refs

00:47:01,119 --> 00:47:03,920
and so forth we could do

00:47:02,560 --> 00:47:04,960
three-dimensional four-dimensional and

00:47:03,920 --> 00:47:06,079
dimensional things that would be

00:47:04,960 --> 00:47:07,520
compiled in that way

00:47:06,079 --> 00:47:09,680
this is one of the things i'm working on

00:47:07,520 --> 00:47:10,960
right now with c plus templates and so

00:47:09,680 --> 00:47:14,160
forth

00:47:10,960 --> 00:47:16,560
uh useful bits go to some links because

00:47:14,160 --> 00:47:18,640
smart procoders use links to figure out

00:47:16,560 --> 00:47:22,000
how to use data types

00:47:18,640 --> 00:47:26,040
smart thinking um

00:47:22,000 --> 00:47:27,760
so uh rpel.org of course

00:47:26,040 --> 00:47:28,960
procommunity.org if you want to learn

00:47:27,760 --> 00:47:30,680
how to get more involved in the pro

00:47:28,960 --> 00:47:33,200
community

00:47:30,680 --> 00:47:34,319
patreon.compro please please please if

00:47:33,200 --> 00:47:37,200
you are not already

00:47:34,319 --> 00:47:40,640
please and thank you for uh supporting

00:47:37,200 --> 00:47:43,280
us on patreon.com forward slash rpro

00:47:40,640 --> 00:47:44,960
and this of course is uh primarily for

00:47:43,280 --> 00:47:48,160
the compiler and data types and

00:47:44,960 --> 00:47:49,839
other things but we do have um uh

00:47:48,160 --> 00:47:51,280
many other pro projects that are

00:47:49,839 --> 00:47:54,480
supported um

00:47:51,280 --> 00:47:57,440
by that self-same patreon please

00:47:54,480 --> 00:47:58,960
do support us if you can we accept all

00:47:57,440 --> 00:48:02,079
the way down to one dollar

00:47:58,960 --> 00:48:03,680
hey why not uh medicipane.org

00:48:02,079 --> 00:48:05,839
slash pod slash our pearl for some of

00:48:03,680 --> 00:48:07,520
the examples i went over today

00:48:05,839 --> 00:48:09,200
i promise that will all be upgraded at

00:48:07,520 --> 00:48:10,640
some point once i'm finished overhauling

00:48:09,200 --> 00:48:13,520
the type system

00:48:10,640 --> 00:48:14,240
um that will be much more extensive and

00:48:13,520 --> 00:48:18,880
up-to-date

00:48:14,240 --> 00:48:22,960
uh documentation and if you want to run

00:48:18,880 --> 00:48:25,760
your own copy of these data types

00:48:22,960 --> 00:48:26,400
please use docker um you can try and

00:48:25,760 --> 00:48:28,160
install it

00:48:26,400 --> 00:48:29,680
yourself if you want but you'll probably

00:48:28,160 --> 00:48:31,839
fail because

00:48:29,680 --> 00:48:33,839
it's not easy to install complicated

00:48:31,839 --> 00:48:34,720
stuff off of cpane and it's really not

00:48:33,839 --> 00:48:37,040
easy to install

00:48:34,720 --> 00:48:39,440
super complicated stuff off of cpane and

00:48:37,040 --> 00:48:42,480
the pro compiler is currently

00:48:39,440 --> 00:48:42,960
super duper complicated so um you could

00:48:42,480 --> 00:48:46,079
try

00:48:42,960 --> 00:48:48,000
you can just try cpan r-pro and if your

00:48:46,079 --> 00:48:50,160
system is set up perfectly it

00:48:48,000 --> 00:48:51,920
very well may work but since it's

00:48:50,160 --> 00:48:55,280
probably not i recommend using

00:48:51,920 --> 00:48:57,359
docker immediately following this

00:48:55,280 --> 00:48:58,559
talk in fact i guess immediately

00:48:57,359 --> 00:49:01,599
following today's

00:48:58,559 --> 00:49:02,000
final talks which is now today um we're

00:49:01,599 --> 00:49:04,720
going

00:49:02,000 --> 00:49:06,319
to have a live get-together a community

00:49:04,720 --> 00:49:08,559
panel to discuss

00:49:06,319 --> 00:49:09,599
all the cool stuff that happened today

00:49:08,559 --> 00:49:12,160
in day one

00:49:09,599 --> 00:49:13,599
of the pearl conference uh please join

00:49:12,160 --> 00:49:16,160
us for that live

00:49:13,599 --> 00:49:17,119
gathering it will be on dot com slash

00:49:16,160 --> 00:49:19,760
groups

00:49:17,119 --> 00:49:21,119
slash pearl programmers this is the uh

00:49:19,760 --> 00:49:24,480
primary pearl

00:49:21,119 --> 00:49:25,040
group online with uh nearly 5 000

00:49:24,480 --> 00:49:27,359
members

00:49:25,040 --> 00:49:28,880
going strong more every day we hope to

00:49:27,359 --> 00:49:31,680
see you there

00:49:28,880 --> 00:49:32,559
you can log in with your video camera

00:49:31,680 --> 00:49:35,839
technology

00:49:32,559 --> 00:49:39,119
allowing and uh we should all be able to

00:49:35,839 --> 00:49:42,079
chit chat and share ideas and so forth

00:49:39,119 --> 00:49:43,440
so uh with that i say thank you thank

00:49:42,079 --> 00:49:45,280
you

00:49:43,440 --> 00:49:46,880
this is wilder chill signing off saying

00:49:45,280 --> 00:49:50,160
please enjoy

00:49:46,880 --> 00:49:56,000
your pearl data types good night

00:49:50,160 --> 00:49:56,000

YouTube URL: https://www.youtube.com/watch?v=go7Ru3QQYYs


