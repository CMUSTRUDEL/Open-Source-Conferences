Title: Machine Learning In Pure Perl - William N. Braswell, Jr.
Publication date: 2021-06-10
Playlist: TPC 2021 in the Cloud
Description: 
	Everything You Always Wanted to Know About Machine Learning In Perl
(But Were Afraid To Ask)

What is Machine Learning?
Why is ML important?
How does ML work?
How is ML different from Artificial Intelligence?
How can ML benefit your Perl projects?

Learn the answers to these questions, and more!

In this talk, we will learn the basics of Machine Learning in pure Perl, including concepts such as the following...

The 4 types of ML algorithms:
- supervised
- semi-supervised
- unsupervised
- reinforcement

Common ML algorithms:
- K-Nearest Neighbor
- Learning Vector Quantization
- Self-Organizing Map
- Locally Weighted Learning
- Linear Regression
- Logistic Regression
- Decision Tree
- Naive Bayes
- K-Means Clustering
- Support Vector Machine
- Random Forest
- Dimensionality Reduction Algorithms
- Gradient Boosting algorithms

We will review Perl source code samples from select algorithms, run live demos, and analyze the results.

If you have always been curious about Machine Learning in Perl, or if you are already an ML programmer looking to expand your knowledge, then this talk is for you!
Captions: 
	00:00:00,439 --> 00:00:06,480
greetings pearl citizens it is i

00:00:03,439 --> 00:00:08,800
your fearless leader of austin texas

00:00:06,480 --> 00:00:09,679
pearl mongers will the chill coming to

00:00:08,800 --> 00:00:12,719
you live

00:00:09,679 --> 00:00:13,599
on june 10 2021 with the pearl

00:00:12,719 --> 00:00:16,320
conference

00:00:13,599 --> 00:00:17,440
in the cloud thank you everyone for

00:00:16,320 --> 00:00:20,080
joining me

00:00:17,440 --> 00:00:20,640
we are broadcasting to you today live

00:00:20,080 --> 00:00:22,320
from the

00:00:20,640 --> 00:00:24,800
pearl capital of the world according to

00:00:22,320 --> 00:00:26,560
yours truly austin texas

00:00:24,800 --> 00:00:27,920
and today we will be talking about

00:00:26,560 --> 00:00:32,480
machine learning

00:00:27,920 --> 00:00:35,680
in pure pearl so um i will have to uh

00:00:32,480 --> 00:00:37,760
i am once again coming to you to ask

00:00:35,680 --> 00:00:38,399
your forgiveness in advance because this

00:00:37,760 --> 00:00:42,399
will

00:00:38,399 --> 00:00:45,360
once again be a memetastic presentation

00:00:42,399 --> 00:00:46,879
so i hope you like memes related to

00:00:45,360 --> 00:00:51,039
machine learning

00:00:46,879 --> 00:00:54,879
i know i do next slide please

00:00:51,039 --> 00:00:56,320
so why machine learning why or what is

00:00:54,879 --> 00:00:57,840
machine learning why do we care about

00:00:56,320 --> 00:00:59,840
machine learning

00:00:57,840 --> 00:01:01,280
why have i spent my time to make a

00:00:59,840 --> 00:01:02,399
presentation in a bunch of pearl

00:01:01,280 --> 00:01:05,519
software

00:01:02,399 --> 00:01:05,920
about machine learning good question

00:01:05,519 --> 00:01:08,400
will

00:01:05,920 --> 00:01:10,640
thanks well i'll answer the question now

00:01:08,400 --> 00:01:12,320
well as you can see in this hilarious

00:01:10,640 --> 00:01:13,920
meme which i did not make

00:01:12,320 --> 00:01:15,759
um actually i didn't have to make any of

00:01:13,920 --> 00:01:17,360
the memes this time pretty much because

00:01:15,759 --> 00:01:18,320
there was already a ton of memes about

00:01:17,360 --> 00:01:20,720
machine learning

00:01:18,320 --> 00:01:22,400
unlike that other presentation which is

00:01:20,720 --> 00:01:24,960
only number one so far

00:01:22,400 --> 00:01:26,080
last time i checked in which case i had

00:01:24,960 --> 00:01:28,479
to make all of the

00:01:26,080 --> 00:01:30,400
pearl memes myself but anyway you can

00:01:28,479 --> 00:01:32,400
see this guy here

00:01:30,400 --> 00:01:34,079
he's got something in this case it's

00:01:32,400 --> 00:01:35,840
actually a defect in his

00:01:34,079 --> 00:01:38,240
structural integrity of the wall here

00:01:35,840 --> 00:01:40,000
but this crack in the wall is labeled

00:01:38,240 --> 00:01:42,479
statistics he puts a frame around

00:01:40,000 --> 00:01:43,759
it and and declares that it is machine

00:01:42,479 --> 00:01:45,759
learning and then

00:01:43,759 --> 00:01:47,280
goes on further to declare that is

00:01:45,759 --> 00:01:49,200
artificial intelligence so

00:01:47,280 --> 00:01:52,000
what is the difference between these

00:01:49,200 --> 00:01:54,399
three things well it depends on who you

00:01:52,000 --> 00:01:58,240
ask and where you draw the

00:01:54,399 --> 00:02:01,119
somewhat arbitrary lines in the sand

00:01:58,240 --> 00:02:01,920
so i guess if we were going to build on

00:02:01,119 --> 00:02:05,439
some

00:02:01,920 --> 00:02:07,520
neat old saying uh sufficiently advanced

00:02:05,439 --> 00:02:09,679
statistics are indistinguishable

00:02:07,520 --> 00:02:10,800
from machine learning and sufficiently

00:02:09,679 --> 00:02:12,080
advanced machine learning is

00:02:10,800 --> 00:02:15,280
indistinguishable from

00:02:12,080 --> 00:02:19,120
artificial intelligence um although

00:02:15,280 --> 00:02:22,480
i guess in order of

00:02:19,120 --> 00:02:25,440
popular uh

00:02:22,480 --> 00:02:26,959
surgeons in the in the academic and and

00:02:25,440 --> 00:02:29,360
business communities it was

00:02:26,959 --> 00:02:30,879
pretty much statistics first that's like

00:02:29,360 --> 00:02:34,160
old-fashioned

00:02:30,879 --> 00:02:35,760
math then ai was real big until we

00:02:34,160 --> 00:02:37,360
realized that it was way harder than we

00:02:35,760 --> 00:02:38,879
thought and then we just kind of started

00:02:37,360 --> 00:02:40,800
focusing on this thing more recently

00:02:38,879 --> 00:02:43,680
called machine learning

00:02:40,800 --> 00:02:45,599
machine learning is according again to

00:02:43,680 --> 00:02:46,239
yours truly the presenter in this case

00:02:45,599 --> 00:02:47,840
uh

00:02:46,239 --> 00:02:51,120
we can consider machine learning to be

00:02:47,840 --> 00:02:53,440
like a subset of the

00:02:51,120 --> 00:02:54,400
of the overall technologies that would

00:02:53,440 --> 00:02:57,519
be required

00:02:54,400 --> 00:03:00,480
to build an artificial intelligence

00:02:57,519 --> 00:03:01,920
um and we could then again consider

00:03:00,480 --> 00:03:05,360
statistics to be

00:03:01,920 --> 00:03:07,680
a significant uh component that goes

00:03:05,360 --> 00:03:10,159
into building machine learning so

00:03:07,680 --> 00:03:10,879
each one is building on top of the next

00:03:10,159 --> 00:03:14,000
to hear

00:03:10,879 --> 00:03:15,760
me describe it at least again if you ask

00:03:14,000 --> 00:03:17,200
a hundred different computer scientists

00:03:15,760 --> 00:03:18,720
what the difference between those three

00:03:17,200 --> 00:03:20,800
things are you will get

00:03:18,720 --> 00:03:22,239
110 different answers because some of

00:03:20,800 --> 00:03:22,720
them are going to hedge their bets and

00:03:22,239 --> 00:03:26,000
give

00:03:22,720 --> 00:03:27,680
multiple conflicting answers

00:03:26,000 --> 00:03:29,360
but more importantly why do we care

00:03:27,680 --> 00:03:30,080
about machine learning nowadays right

00:03:29,360 --> 00:03:32,239
now for

00:03:30,080 --> 00:03:33,599
business reasons well gosh dang there's

00:03:32,239 --> 00:03:36,640
a lot of money

00:03:33,599 --> 00:03:39,760
money money money money filthy looker

00:03:36,640 --> 00:03:41,040
greenback simoleons texas tea oh wait no

00:03:39,760 --> 00:03:42,000
that's something else that converts to

00:03:41,040 --> 00:03:44,239
money but you know

00:03:42,000 --> 00:03:47,040
the point is that uh there's a lot of

00:03:44,239 --> 00:03:50,080
money that's just being dumped

00:03:47,040 --> 00:03:53,120
i mean like by the truckload

00:03:50,080 --> 00:03:55,519
by the tanker load of

00:03:53,120 --> 00:03:57,280
money just being dumped by corporations

00:03:55,519 --> 00:03:58,400
into machine learning so if you want a

00:03:57,280 --> 00:04:01,680
job

00:03:58,400 --> 00:04:03,200
you uh in in computer programming

00:04:01,680 --> 00:04:04,799
nowadays if you put machine learning on

00:04:03,200 --> 00:04:05,519
your resume it's probably going to help

00:04:04,799 --> 00:04:08,080
you

00:04:05,519 --> 00:04:08,640
uh the i guess you could also say

00:04:08,080 --> 00:04:11,360
there's

00:04:08,640 --> 00:04:12,879
big results i put scare quotes around

00:04:11,360 --> 00:04:15,200
big in this case

00:04:12,879 --> 00:04:16,880
because it again depends on who you ask

00:04:15,200 --> 00:04:19,600
but i do believe

00:04:16,880 --> 00:04:21,519
that the results that you can get from

00:04:19,600 --> 00:04:23,520
properly utilized machine learning

00:04:21,519 --> 00:04:24,880
can be big results that it can achieve

00:04:23,520 --> 00:04:27,360
things that would be prohibitively

00:04:24,880 --> 00:04:29,919
difficult to do otherwise

00:04:27,360 --> 00:04:31,040
and there are again depending on the u.s

00:04:29,919 --> 00:04:33,199
there's usually

00:04:31,040 --> 00:04:34,560
quoted as three different main

00:04:33,199 --> 00:04:38,320
categories or types of

00:04:34,560 --> 00:04:39,120
of um machine learning algorithms or

00:04:38,320 --> 00:04:40,479
approaches

00:04:39,120 --> 00:04:42,080
supervised unsupervised and

00:04:40,479 --> 00:04:42,560
reinforcement supervised learning is

00:04:42,080 --> 00:04:46,720
where

00:04:42,560 --> 00:04:47,759
you already have uh sample data or like

00:04:46,720 --> 00:04:50,880
input data

00:04:47,759 --> 00:04:54,000
that's somehow categorized or that you

00:04:50,880 --> 00:04:54,639
know is correct in some way and then the

00:04:54,000 --> 00:04:56,560
machine

00:04:54,639 --> 00:04:58,479
learns off of that the algorithm learns

00:04:56,560 --> 00:05:00,800
off of that correct data

00:04:58,479 --> 00:05:02,960
and goes on to try and do other stuff

00:05:00,800 --> 00:05:05,680
whatever that may be

00:05:02,960 --> 00:05:07,600
classifying things or making decisions

00:05:05,680 --> 00:05:11,199
about things or whatever

00:05:07,600 --> 00:05:13,919
in unsupervised learning you do not

00:05:11,199 --> 00:05:14,960
already have a set of data that you know

00:05:13,919 --> 00:05:17,120
is correct or

00:05:14,960 --> 00:05:18,080
classified or somehow sorted or

00:05:17,120 --> 00:05:20,479
organized

00:05:18,080 --> 00:05:21,280
you're just saying go figure it out on

00:05:20,479 --> 00:05:24,720
your own

00:05:21,280 --> 00:05:26,320
and the algorithm will have to

00:05:24,720 --> 00:05:28,240
figure out what the classifications may

00:05:26,320 --> 00:05:29,680
be and so forth and that's

00:05:28,240 --> 00:05:32,240
perhaps even more difficult and

00:05:29,680 --> 00:05:35,039
reinforcement learning is is uh

00:05:32,240 --> 00:05:36,080
more of a feedback loop i guess or a

00:05:35,039 --> 00:05:39,520
dynamic

00:05:36,080 --> 00:05:41,039
interaction between the um

00:05:39,520 --> 00:05:43,039
the learning algorithm and its

00:05:41,039 --> 00:05:44,880
environment somebody is unmuted

00:05:43,039 --> 00:05:47,199
so whoever the host is can you mute

00:05:44,880 --> 00:05:49,919
everyone except for me please

00:05:47,199 --> 00:05:51,039
uh and please check if you're muted

00:05:49,919 --> 00:05:53,759
because i'm hearing some background

00:05:51,039 --> 00:05:57,280
noise from someone else thank you

00:05:53,759 --> 00:06:00,000
the reinforcement uh type of learning

00:05:57,280 --> 00:06:02,080
is basically like you're giving rewards

00:06:00,000 --> 00:06:05,440
when the algorithm does the correct

00:06:02,080 --> 00:06:06,000
thing um and the algorithm is trying to

00:06:05,440 --> 00:06:07,680
maximize

00:06:06,000 --> 00:06:08,800
its rewards so that's reinforcement

00:06:07,680 --> 00:06:09,759
learning i remember reinforcement

00:06:08,800 --> 00:06:11,280
learning came out

00:06:09,759 --> 00:06:13,840
real big when i was in college and here

00:06:11,280 --> 00:06:17,120
we are still trying to figure it all out

00:06:13,840 --> 00:06:18,479
but why pure pearl well this is a

00:06:17,120 --> 00:06:19,600
machine learning and pure pearl

00:06:18,479 --> 00:06:21,520
presentation

00:06:19,600 --> 00:06:23,280
because it defines who i am oh wait that

00:06:21,520 --> 00:06:24,240
was someone who never talks about never

00:06:23,280 --> 00:06:25,039
stops talking about machine learning

00:06:24,240 --> 00:06:27,280
well i guess

00:06:25,039 --> 00:06:29,440
if i know some people that never stopped

00:06:27,280 --> 00:06:31,680
talking about machine learning and pearl

00:06:29,440 --> 00:06:33,280
and that's great um we need more of that

00:06:31,680 --> 00:06:35,600
actually

00:06:33,280 --> 00:06:37,039
probably because of this whole big money

00:06:35,600 --> 00:06:40,000
thing that i was mentioning

00:06:37,039 --> 00:06:40,800
and also i guess i should foreshadow a

00:06:40,000 --> 00:06:43,600
conclusion

00:06:40,800 --> 00:06:44,479
about um why machine learning is

00:06:43,600 --> 00:06:47,280
important

00:06:44,479 --> 00:06:48,400
it's because it's kind of like the

00:06:47,280 --> 00:06:51,280
future of

00:06:48,400 --> 00:06:52,880
of programming in many ways machine

00:06:51,280 --> 00:06:54,479
learning will never

00:06:52,880 --> 00:06:56,400
like probably decrease it's going to

00:06:54,479 --> 00:06:58,560
keep increasing in importance

00:06:56,400 --> 00:07:00,639
um and prevalence and and significance

00:06:58,560 --> 00:07:00,960
and the as a required skill for people

00:07:00,639 --> 00:07:04,720
to

00:07:00,960 --> 00:07:06,960
get programming jobs and do projects

00:07:04,720 --> 00:07:09,280
competitively with other groups and

00:07:06,960 --> 00:07:11,360
companies and so forth so

00:07:09,280 --> 00:07:12,720
machine learning is kind of the future

00:07:11,360 --> 00:07:14,400
it's a big part of the future of

00:07:12,720 --> 00:07:17,039
software development so why do we care

00:07:14,400 --> 00:07:20,240
about doing this in pure pearl

00:07:17,039 --> 00:07:23,680
well i do not like writing code in

00:07:20,240 --> 00:07:26,720
xs uh maybe you do if you're like

00:07:23,680 --> 00:07:30,160
crazy or again masochistic person

00:07:26,720 --> 00:07:32,400
um uh same thing for c i'm not a huge

00:07:30,160 --> 00:07:34,639
fan i'd rather use c than xs

00:07:32,400 --> 00:07:35,599
but i still would rather not use it if i

00:07:34,639 --> 00:07:39,039
don't have to

00:07:35,599 --> 00:07:40,560
and and obviously pearl we like to think

00:07:39,039 --> 00:07:42,560
is better than python i think that

00:07:40,560 --> 00:07:44,000
everyone watching this would hopefully

00:07:42,560 --> 00:07:46,319
agree that we would prefer to

00:07:44,000 --> 00:07:47,199
use pearl rather than python if we had

00:07:46,319 --> 00:07:50,639
the option

00:07:47,199 --> 00:07:52,160
right so where's the option other

00:07:50,639 --> 00:07:53,919
we're getting to that obviously are

00:07:52,160 --> 00:07:56,639
there other reasons why we care about

00:07:53,919 --> 00:08:00,560
doing things in pure pearl

00:07:56,639 --> 00:08:02,720
um readability i mean i

00:08:00,560 --> 00:08:04,400
especially compared to like xs or c the

00:08:02,720 --> 00:08:05,599
readability of pure pearl is going to be

00:08:04,400 --> 00:08:07,280
far far higher

00:08:05,599 --> 00:08:09,360
compared to other dynamic or high level

00:08:07,280 --> 00:08:12,160
languages like python it could be

00:08:09,360 --> 00:08:13,759
relatively similar with just ugly white

00:08:12,160 --> 00:08:14,639
space or syntax sugar or whatever

00:08:13,759 --> 00:08:16,800
depending on your

00:08:14,639 --> 00:08:18,560
preference right it's more about

00:08:16,800 --> 00:08:20,080
preference at that point

00:08:18,560 --> 00:08:21,520
but certainly pearl is going to have

00:08:20,080 --> 00:08:23,120
much better readability than a lower

00:08:21,520 --> 00:08:24,800
level language

00:08:23,120 --> 00:08:26,479
and if you write really great pro code

00:08:24,800 --> 00:08:29,599
it could have really great readability

00:08:26,479 --> 00:08:33,519
maintainability similarly i uh

00:08:29,599 --> 00:08:35,760
do not want to try and um

00:08:33,519 --> 00:08:37,519
maintain anyone else's excess code ever

00:08:35,760 --> 00:08:38,080
i've had to tweak a few things here and

00:08:37,519 --> 00:08:40,719
there

00:08:38,080 --> 00:08:42,479
and holy cow it was like you know

00:08:40,719 --> 00:08:44,480
crawling under an old house and trying

00:08:42,479 --> 00:08:48,000
to fix the plumbing and you could just

00:08:44,480 --> 00:08:51,440
die at any moment sort of thing

00:08:48,000 --> 00:08:54,080
uh but

00:08:51,440 --> 00:08:55,040
yeah maintainability and i would much

00:08:54,080 --> 00:08:56,959
rather maintain

00:08:55,040 --> 00:08:58,240
someone's pearl code rather than

00:08:56,959 --> 00:09:00,720
non-perl code

00:08:58,240 --> 00:09:02,160
um why do you keep mentioning that snake

00:09:00,720 --> 00:09:03,680
language i don't know we'll get there in

00:09:02,160 --> 00:09:07,120
a minute i guess

00:09:03,680 --> 00:09:08,800
performance wow most people wouldn't say

00:09:07,120 --> 00:09:09,920
that they're using pearl for performance

00:09:08,800 --> 00:09:12,000
unless they're in the

00:09:09,920 --> 00:09:14,240
ignorant group of people who think that

00:09:12,000 --> 00:09:16,720
pearl runs really fast compared to other

00:09:14,240 --> 00:09:17,360
modern languages when i'm here to dispel

00:09:16,720 --> 00:09:19,920
that

00:09:17,360 --> 00:09:20,959
wildly incorrect rumor that with the

00:09:19,920 --> 00:09:24,560
sole exception of

00:09:20,959 --> 00:09:25,440
isolating special cases like regex only

00:09:24,560 --> 00:09:29,120
timings

00:09:25,440 --> 00:09:29,839
um the the general uh speed of the pro

00:09:29,120 --> 00:09:32,560
interpreter

00:09:29,839 --> 00:09:34,560
is uh slower than java slower than

00:09:32,560 --> 00:09:37,920
javascript slower than python slower

00:09:34,560 --> 00:09:42,240
than ruby pearl is not a particularly

00:09:37,920 --> 00:09:44,399
fast interpreter um but

00:09:42,240 --> 00:09:46,080
we can we can get around that as we'll

00:09:44,399 --> 00:09:49,200
see here in a moment by using

00:09:46,080 --> 00:09:52,240
pure pearl next slide please

00:09:49,200 --> 00:09:54,480
uh pearl versus python the snake

00:09:52,240 --> 00:09:55,120
language as i call it the snake coming

00:09:54,480 --> 00:09:59,760
on up

00:09:55,120 --> 00:10:03,120
through the bushes to get you well um

00:09:59,760 --> 00:10:04,399
there's a lot going on in python from

00:10:03,120 --> 00:10:05,839
machine learning so much that i had to

00:10:04,399 --> 00:10:08,720
make an entire

00:10:05,839 --> 00:10:11,279
slide about it here and that there is in

00:10:08,720 --> 00:10:15,360
fact uh

00:10:11,279 --> 00:10:18,480
a meme about that so um

00:10:15,360 --> 00:10:21,920
here you see some dude reading

00:10:18,480 --> 00:10:24,959
some giant manual on some

00:10:21,920 --> 00:10:28,320
arcane computer system presumably

00:10:24,959 --> 00:10:30,320
um and then you see some nicely

00:10:28,320 --> 00:10:31,279
manicured ladies fingers with a tiny

00:10:30,320 --> 00:10:34,640
book

00:10:31,279 --> 00:10:37,760
um and in this particular uh

00:10:34,640 --> 00:10:38,880
titling or or context the uh the guy

00:10:37,760 --> 00:10:41,920
with huge manual

00:10:38,880 --> 00:10:45,360
is the person that wrote all the math or

00:10:41,920 --> 00:10:48,079
uh is uh studying the math right for

00:10:45,360 --> 00:10:49,519
the statistics that's the stats right we

00:10:48,079 --> 00:10:50,079
saw the picture frame and the crack in

00:10:49,519 --> 00:10:53,040
the wall

00:10:50,079 --> 00:10:53,839
that's the math the statistics um but

00:10:53,040 --> 00:10:56,399
once that's

00:10:53,839 --> 00:10:59,200
written right once the code is written

00:10:56,399 --> 00:11:02,560
and working all you have to do is just

00:10:59,200 --> 00:11:03,600
put one line of code you know to import

00:11:02,560 --> 00:11:05,760
that library

00:11:03,600 --> 00:11:08,000
and and that would be like an include

00:11:05,760 --> 00:11:11,519
statement in c or an import statement or

00:11:08,000 --> 00:11:14,160
in the snakey snake language or the

00:11:11,519 --> 00:11:16,320
use statement in pearl it's just

00:11:14,160 --> 00:11:18,399
importing some library and then you just

00:11:16,320 --> 00:11:20,800
you're up and running you're off to the

00:11:18,399 --> 00:11:21,839
races with one line you now have this

00:11:20,800 --> 00:11:25,200
giant

00:11:21,839 --> 00:11:28,320
book of of of math um

00:11:25,200 --> 00:11:31,760
and algorithms at your fingertip well

00:11:28,320 --> 00:11:35,279
in python that is very much the case

00:11:31,760 --> 00:11:38,880
um you can see here uh just the top

00:11:35,279 --> 00:11:41,760
six um python packages

00:11:38,880 --> 00:11:42,160
relating to machine learning each of

00:11:41,760 --> 00:11:46,640
which

00:11:42,160 --> 00:11:49,279
has dozens or hundreds

00:11:46,640 --> 00:11:49,760
of of algorithms implemented in them so

00:11:49,279 --> 00:11:53,120
there's

00:11:49,760 --> 00:11:53,920
thousands of of you know bits of usable

00:11:53,120 --> 00:11:56,959
code

00:11:53,920 --> 00:12:00,560
among these these top six

00:11:56,959 --> 00:12:01,839
here um so i'm not going to try and get

00:12:00,560 --> 00:12:02,800
in any of them you've probably heard

00:12:01,839 --> 00:12:04,800
about them all

00:12:02,800 --> 00:12:06,160
i am not a python user i don't use

00:12:04,800 --> 00:12:09,519
python or write

00:12:06,160 --> 00:12:13,040
python code obviously but i have had to

00:12:09,519 --> 00:12:16,079
look at some python code

00:12:13,040 --> 00:12:17,680
for two reasons i guess number one to

00:12:16,079 --> 00:12:19,839
see what these things

00:12:17,680 --> 00:12:20,880
looked like what the code looked like

00:12:19,839 --> 00:12:22,800
was it well written

00:12:20,880 --> 00:12:24,240
is it a mess is it hard to understand is

00:12:22,800 --> 00:12:27,279
it um

00:12:24,240 --> 00:12:30,320
well documented and so forth and

00:12:27,279 --> 00:12:31,440
also in a much more specific and smaller

00:12:30,320 --> 00:12:33,600
capacity to

00:12:31,440 --> 00:12:34,480
try and see if it was possible to

00:12:33,600 --> 00:12:36,560
understand

00:12:34,480 --> 00:12:38,480
or copy any of their algorithms because

00:12:36,560 --> 00:12:39,760
the algorithms are generic

00:12:38,480 --> 00:12:42,079
you know machine learning algorithms

00:12:39,760 --> 00:12:43,760
that are in my old computer science

00:12:42,079 --> 00:12:45,200
textbooks but i was like well

00:12:43,760 --> 00:12:46,800
if somebody's gone to the trouble of

00:12:45,200 --> 00:12:47,279
actually trying to code it up maybe i

00:12:46,800 --> 00:12:48,800
can

00:12:47,279 --> 00:12:51,600
look at their code i've done it a few

00:12:48,800 --> 00:12:54,639
times with simple algorithms in the past

00:12:51,600 --> 00:12:55,519
usually with more complex situations you

00:12:54,639 --> 00:12:57,360
need to just

00:12:55,519 --> 00:12:59,120
read the textbook and understand how it

00:12:57,360 --> 00:13:00,079
works and then code the whole thing from

00:12:59,120 --> 00:13:01,920
scratch

00:13:00,079 --> 00:13:03,200
but i wanted to see i wanted to see if i

00:13:01,920 --> 00:13:06,320
could you know

00:13:03,200 --> 00:13:09,519
snag any algorithms for free or for

00:13:06,320 --> 00:13:11,279
a discount price uh you know a less

00:13:09,519 --> 00:13:14,800
steep learning curve

00:13:11,279 --> 00:13:16,079
and i did open up scikit-learn

00:13:14,800 --> 00:13:18,000
the first one on the list here called

00:13:16,079 --> 00:13:22,079
sclern

00:13:18,000 --> 00:13:24,160
for short and i was eventually

00:13:22,079 --> 00:13:25,600
able to dig down deep enough in their

00:13:24,160 --> 00:13:27,760
code to actually find like

00:13:25,600 --> 00:13:29,920
a piece of an algorithm but gosh dang it

00:13:27,760 --> 00:13:32,639
was buried so deep and

00:13:29,920 --> 00:13:33,600
with such obscure inputs and outputs

00:13:32,639 --> 00:13:37,040
that it was

00:13:33,600 --> 00:13:38,720
not usable in the sense really of like

00:13:37,040 --> 00:13:39,360
well i can just see how this algorithm

00:13:38,720 --> 00:13:41,600
works and

00:13:39,360 --> 00:13:42,959
code it right up in pure pearl not

00:13:41,600 --> 00:13:46,800
really

00:13:42,959 --> 00:13:48,720
i mostly had to study the algorithm with

00:13:46,800 --> 00:13:50,000
some friends who all thank at the end

00:13:48,720 --> 00:13:53,120
the presentation

00:13:50,000 --> 00:13:53,760
and um and understand how it worked and

00:13:53,120 --> 00:13:55,279
try and

00:13:53,760 --> 00:13:57,760
just kind of sort of code it from

00:13:55,279 --> 00:14:00,399
scratch um

00:13:57,760 --> 00:14:02,079
i guess if you want to extend this

00:14:00,399 --> 00:14:04,000
visual analogy of the guy with a huge

00:14:02,079 --> 00:14:07,040
book and the lady with the tiny book

00:14:04,000 --> 00:14:08,880
um well

00:14:07,040 --> 00:14:10,800
you may be asking yourself what the name

00:14:08,880 --> 00:14:11,120
of this slide it says right across the

00:14:10,800 --> 00:14:13,279
top

00:14:11,120 --> 00:14:14,320
machine learning pro versus python but

00:14:13,279 --> 00:14:17,120
all six of these

00:14:14,320 --> 00:14:19,519
are appear to be python where's the

00:14:17,120 --> 00:14:19,519
pearl

00:14:21,600 --> 00:14:27,279
i'll ask again where's the pearl on this

00:14:24,959 --> 00:14:27,279
list

00:14:29,519 --> 00:14:36,000
crickets you're gonna get crickets

00:14:33,519 --> 00:14:38,160
get it it's not a good joke it's not a

00:14:36,000 --> 00:14:40,000
funny joke but it's true

00:14:38,160 --> 00:14:42,000
there's just not much by the way of

00:14:40,000 --> 00:14:44,480
pearl in machine learning

00:14:42,000 --> 00:14:46,000
so again to visually to extend this

00:14:44,480 --> 00:14:49,040
visual

00:14:46,000 --> 00:14:50,639
analogy python is at least this giant

00:14:49,040 --> 00:14:53,440
fat book and pearl is

00:14:50,639 --> 00:14:54,399
at most this tiny thin little thing um

00:14:53,440 --> 00:14:56,399
pearl has an

00:14:54,399 --> 00:14:58,639
interface to the fast artificial neural

00:14:56,399 --> 00:15:01,760
networks pearl has some interfaces other

00:14:58,639 --> 00:15:02,720
some clever pro programmer who thinks he

00:15:01,760 --> 00:15:05,440
or she is

00:15:02,720 --> 00:15:07,279
doing a good thing may even be

00:15:05,440 --> 00:15:08,160
implementing or have already implemented

00:15:07,279 --> 00:15:11,360
some

00:15:08,160 --> 00:15:13,360
perl interfaces to these python

00:15:11,360 --> 00:15:16,639
libraries thinking that's a good thing

00:15:13,360 --> 00:15:20,240
but gosh dang do we want

00:15:16,639 --> 00:15:21,760
our perl machine learning to just be a

00:15:20,240 --> 00:15:25,120
wrapper around python

00:15:21,760 --> 00:15:29,440
no in fact i will say

00:15:25,120 --> 00:15:31,839
heck gosh baby dang no

00:15:29,440 --> 00:15:33,920
we do not that's that would be that

00:15:31,839 --> 00:15:36,880
would be very depressing very bad

00:15:33,920 --> 00:15:38,320
we'd never be able to advertise that pro

00:15:36,880 --> 00:15:39,600
has its own machine learning code

00:15:38,320 --> 00:15:42,560
because it would all be

00:15:39,600 --> 00:15:44,160
just wrappers around python and this is

00:15:42,560 --> 00:15:46,959
the same problem that much of

00:15:44,160 --> 00:15:50,079
bio perl suffers from because much of

00:15:46,959 --> 00:15:51,600
bio perl is a wrapper around bio c but

00:15:50,079 --> 00:15:53,759
and there's no such thing as bio c but

00:15:51,600 --> 00:15:56,800
it's the c code libraries

00:15:53,759 --> 00:15:59,279
thank goodness though that's not a bunch

00:15:56,800 --> 00:16:01,040
of python libraries so it's a little bit

00:15:59,279 --> 00:16:03,040
less disingenuous to use the term

00:16:01,040 --> 00:16:04,720
bioperl but

00:16:03,040 --> 00:16:06,720
we could not apply the term machine

00:16:04,720 --> 00:16:07,680
learning perl or ml perl as we're

00:16:06,720 --> 00:16:09,759
calling it

00:16:07,680 --> 00:16:13,199
to uh to something that's just a bunch

00:16:09,759 --> 00:16:15,920
of python wrappers that would be no good

00:16:13,199 --> 00:16:16,399
so we need to do it ourself next slide

00:16:15,920 --> 00:16:19,040
please

00:16:16,399 --> 00:16:20,639
okay here is what we have been working

00:16:19,040 --> 00:16:23,759
on there's an algorithm called k

00:16:20,639 --> 00:16:27,680
nearest neighbors

00:16:23,759 --> 00:16:29,920
oh my goodness why can't we mute people

00:16:27,680 --> 00:16:30,959
and force them to stay muted well thank

00:16:29,920 --> 00:16:33,279
you zoom

00:16:30,959 --> 00:16:34,720
and again whoever is the administrator

00:16:33,279 --> 00:16:37,360
of this zoom call

00:16:34,720 --> 00:16:37,839
let's go ahead and try and control that

00:16:37,360 --> 00:16:40,399
issue

00:16:37,839 --> 00:16:42,240
please do not unmute yourselves during a

00:16:40,399 --> 00:16:46,240
public presentation

00:16:42,240 --> 00:16:48,160
uh in the k-nearest neighbors algorithm

00:16:46,240 --> 00:16:49,839
um i'm just going to visually explain it

00:16:48,160 --> 00:16:52,639
instead of trying to show you pseudocode

00:16:49,839 --> 00:16:53,279
and walk you through my learning process

00:16:52,639 --> 00:16:55,040
there

00:16:53,279 --> 00:16:57,199
this is our sample data so this is the

00:16:55,040 --> 00:16:58,959
data that we know is correct

00:16:57,199 --> 00:17:00,800
in this very simple case it's

00:16:58,959 --> 00:17:02,320
two-dimensional k-nearest neighbor so

00:17:00,800 --> 00:17:03,360
the points are two-dimensional data it

00:17:02,320 --> 00:17:05,280
makes it easy to show on a

00:17:03,360 --> 00:17:08,959
two-dimensional screen

00:17:05,280 --> 00:17:11,439
uh there are two groups of data a red

00:17:08,959 --> 00:17:12,880
square and a blue circle the blue circle

00:17:11,439 --> 00:17:14,959
is just called group a

00:17:12,880 --> 00:17:16,799
and the red square is called group b

00:17:14,959 --> 00:17:18,799
they could be any classification it

00:17:16,799 --> 00:17:19,839
could be men or women it could be up and

00:17:18,799 --> 00:17:22,640
down it could be

00:17:19,839 --> 00:17:24,480
right or left good or bad it could be

00:17:22,640 --> 00:17:26,160
you know cheap expensive whatever these

00:17:24,480 --> 00:17:27,679
two different groups may be it could be

00:17:26,160 --> 00:17:29,280
two different types of

00:17:27,679 --> 00:17:31,200
things or any plants or animals or

00:17:29,280 --> 00:17:32,160
whatever it's just two different groups

00:17:31,200 --> 00:17:33,600
that are not

00:17:32,160 --> 00:17:35,440
one group they are definitely two

00:17:33,600 --> 00:17:37,200
different groups you could have as many

00:17:35,440 --> 00:17:38,720
groups as you want but we're doing like

00:17:37,200 --> 00:17:40,960
the simplest possible examples

00:17:38,720 --> 00:17:42,160
you can understand here you can see that

00:17:40,960 --> 00:17:45,520
these groups

00:17:42,160 --> 00:17:48,000
are mostly centered around

00:17:45,520 --> 00:17:50,240
the origins like the vertical axis

00:17:48,000 --> 00:17:51,440
around the zero origin is where the blue

00:17:50,240 --> 00:17:54,559
group is

00:17:51,440 --> 00:17:56,400
and the uh the horizontal

00:17:54,559 --> 00:17:58,320
axis around the zero origin again is

00:17:56,400 --> 00:18:00,080
where most of the red group is

00:17:58,320 --> 00:18:02,720
clustered and they're kind of spread out

00:18:00,080 --> 00:18:05,760
and distributed among those

00:18:02,720 --> 00:18:08,960
different axes

00:18:05,760 --> 00:18:12,960
on this graph so we feed this

00:18:08,960 --> 00:18:15,360
data into the k nearest neighbors

00:18:12,960 --> 00:18:17,120
algorithm and it will learn this is its

00:18:15,360 --> 00:18:20,080
supervised learning period

00:18:17,120 --> 00:18:21,039
is it learns what this data

00:18:20,080 --> 00:18:24,640
classification

00:18:21,039 --> 00:18:27,360
is next step is

00:18:24,640 --> 00:18:28,080
we give it some test data here you can

00:18:27,360 --> 00:18:30,960
see the test

00:18:28,080 --> 00:18:31,520
data this test data is literally just

00:18:30,960 --> 00:18:33,600
random

00:18:31,520 --> 00:18:35,280
randomly generated it's it's a random

00:18:33,600 --> 00:18:38,720
number generator that generated

00:18:35,280 --> 00:18:40,080
random data within this window of of

00:18:38,720 --> 00:18:43,280
range of values

00:18:40,080 --> 00:18:46,640
um and it's uh really

00:18:43,280 --> 00:18:48,640
not clustered in any way it's it's

00:18:46,640 --> 00:18:50,799
actually totally random or at least as

00:18:48,640 --> 00:18:52,799
pseudo-random as we can get

00:18:50,799 --> 00:18:54,400
on uh a random number generator on a

00:18:52,799 --> 00:18:56,080
computer um

00:18:54,400 --> 00:18:57,600
it's still obviously two-dimensional

00:18:56,080 --> 00:19:00,640
points within the same

00:18:57,600 --> 00:19:03,440
you know dimensionality and and uh

00:19:00,640 --> 00:19:04,080
the space uh test space here there's no

00:19:03,440 --> 00:19:06,799
grouping

00:19:04,080 --> 00:19:07,840
assigned at this point these these data

00:19:06,799 --> 00:19:10,000
points have no

00:19:07,840 --> 00:19:11,760
no classification no categorization no

00:19:10,000 --> 00:19:13,200
grouping applied to them

00:19:11,760 --> 00:19:14,799
and again it's totally random

00:19:13,200 --> 00:19:17,039
distribution at this time

00:19:14,799 --> 00:19:18,880
so what's going to happen is that the

00:19:17,039 --> 00:19:21,919
algorithm k nearest neighbors

00:19:18,880 --> 00:19:25,600
is going to for each one of

00:19:21,919 --> 00:19:29,039
these points it's going to go back

00:19:25,600 --> 00:19:31,520
to the original sample data and find

00:19:29,039 --> 00:19:32,559
the nearest neighbors k is an arbitrary

00:19:31,520 --> 00:19:34,720
integer

00:19:32,559 --> 00:19:35,679
you could set k to two or three or four

00:19:34,720 --> 00:19:37,520
or five

00:19:35,679 --> 00:19:39,360
and it would pick the top you know if

00:19:37,520 --> 00:19:42,000
you set k equal to three then it would

00:19:39,360 --> 00:19:43,200
pick the three closest neighbors so if

00:19:42,000 --> 00:19:45,760
we're looking at

00:19:43,200 --> 00:19:48,240
um this data point right here i don't

00:19:45,760 --> 00:19:49,760
even know if you guys can see my um

00:19:48,240 --> 00:19:51,840
cursor but if you can't it's not the

00:19:49,760 --> 00:19:53,120
very tip top one but it's the one

00:19:51,840 --> 00:19:56,400
under that sort of in the middle of the

00:19:53,120 --> 00:19:59,520
top uh the the nearest neighbors to that

00:19:56,400 --> 00:20:02,000
would be all blue because it would be

00:19:59,520 --> 00:20:03,840
this cluster of three blue dots

00:20:02,000 --> 00:20:05,679
that's uh all kind of close to each

00:20:03,840 --> 00:20:06,000
other it just randomly happens to be

00:20:05,679 --> 00:20:09,039
quite

00:20:06,000 --> 00:20:10,640
close but uh nevertheless those would be

00:20:09,039 --> 00:20:12,320
the three nearest neighbors of this

00:20:10,640 --> 00:20:16,480
particular data point

00:20:12,320 --> 00:20:18,000
so um depending on the distance function

00:20:16,480 --> 00:20:18,880
you use which we'll talk about in a

00:20:18,000 --> 00:20:20,880
minute

00:20:18,880 --> 00:20:21,919
it would almost certainly determine that

00:20:20,880 --> 00:20:24,880
those three

00:20:21,919 --> 00:20:25,840
uh blue points are the three nearest

00:20:24,880 --> 00:20:28,520
neighbors if you set

00:20:25,840 --> 00:20:30,080
k to three to this currently

00:20:28,520 --> 00:20:33,120
uncategorized

00:20:30,080 --> 00:20:34,320
test data point and thus the algorithm

00:20:33,120 --> 00:20:37,919
would determine

00:20:34,320 --> 00:20:38,640
that that point is blue and you can see

00:20:37,919 --> 00:20:41,840
here

00:20:38,640 --> 00:20:43,360
in the now categorized data that point

00:20:41,840 --> 00:20:44,960
has turned blue

00:20:43,360 --> 00:20:47,200
and the rest of the points have

00:20:44,960 --> 00:20:49,360
similarly been iterated through

00:20:47,200 --> 00:20:51,039
and categorized according to their

00:20:49,360 --> 00:20:54,240
k-nearest neighbors

00:20:51,039 --> 00:20:54,559
and interestingly you can see now that

00:20:54,240 --> 00:20:57,200
there

00:20:54,559 --> 00:20:58,320
is a similar distribution to the sample

00:20:57,200 --> 00:21:02,480
data points

00:20:58,320 --> 00:21:05,360
um the the data points that are

00:21:02,480 --> 00:21:05,840
more clustered along the vertical are

00:21:05,360 --> 00:21:07,440
blue

00:21:05,840 --> 00:21:08,960
and the data points that are more

00:21:07,440 --> 00:21:10,080
clustered around the horizontal are the

00:21:08,960 --> 00:21:11,840
red squares

00:21:10,080 --> 00:21:14,840
so the blue circles and the red squares

00:21:11,840 --> 00:21:18,000
are you know

00:21:14,840 --> 00:21:19,840
uh similarly distributed

00:21:18,000 --> 00:21:21,360
now there's no way to be perfect and

00:21:19,840 --> 00:21:22,400
there's many different options and

00:21:21,360 --> 00:21:23,919
waiting functions

00:21:22,400 --> 00:21:26,880
distance functions we'll talk about in a

00:21:23,919 --> 00:21:28,400
minute but using a simple example this

00:21:26,880 --> 00:21:29,919
is what you end up with and

00:21:28,400 --> 00:21:31,440
this needs to be a simple example so we

00:21:29,919 --> 00:21:33,120
can just visually understand how this

00:21:31,440 --> 00:21:35,440
works because it's a bunch of tedious

00:21:33,120 --> 00:21:38,320
code to write it all out

00:21:35,440 --> 00:21:38,720
speaking of tedious code let's check it

00:21:38,320 --> 00:21:41,039
out

00:21:38,720 --> 00:21:42,000
uh sorry for so many slides without

00:21:41,039 --> 00:21:44,400
memes gosh

00:21:42,000 --> 00:21:46,159
dang somebody needs to make a meme about

00:21:44,400 --> 00:21:49,280
not enough memes i guess

00:21:46,159 --> 00:21:51,200
but um here we have uh

00:21:49,280 --> 00:21:52,880
a snippet of code this is actually just

00:21:51,200 --> 00:21:55,919
a a nearly

00:21:52,880 --> 00:21:59,280
empty um pearl class

00:21:55,919 --> 00:22:03,200
that we created called neighbor 2d and

00:21:59,280 --> 00:22:06,640
um for each two-dimensional neighbor

00:22:03,200 --> 00:22:09,600
uh we don't really have any

00:22:06,640 --> 00:22:10,840
uh methods no operations applied here

00:22:09,600 --> 00:22:13,760
it's just data

00:22:10,840 --> 00:22:15,200
properties um there's a property that's

00:22:13,760 --> 00:22:18,960
actually called data

00:22:15,200 --> 00:22:20,720
um and this is the actual

00:22:18,960 --> 00:22:22,320
two dimensional data point you know the

00:22:20,720 --> 00:22:23,440
x and y coordinates if you're looking at

00:22:22,320 --> 00:22:26,799
the graph

00:22:23,440 --> 00:22:30,080
the distance is how far it is

00:22:26,799 --> 00:22:33,520
from its neighbor

00:22:30,080 --> 00:22:35,600
and uh the classification is

00:22:33,520 --> 00:22:36,559
which group was it put in was it put in

00:22:35,600 --> 00:22:39,919
group a

00:22:36,559 --> 00:22:41,760
or b uh and and so was it was it again

00:22:39,919 --> 00:22:42,159
going to be like the the blue or the red

00:22:41,760 --> 00:22:44,720
group

00:22:42,159 --> 00:22:45,840
so those are the two classifications um

00:22:44,720 --> 00:22:49,039
this all starts out as

00:22:45,840 --> 00:22:49,919
empty or undefined sort of data but you

00:22:49,039 --> 00:22:52,480
can see we

00:22:49,919 --> 00:22:54,640
are using data types and this is

00:22:52,480 --> 00:22:56,000
critical because uh we want our code to

00:22:54,640 --> 00:22:58,960
run fast in the end

00:22:56,000 --> 00:23:00,720
so um the two-dimensional data is a a

00:22:58,960 --> 00:23:03,440
number array ref

00:23:00,720 --> 00:23:04,320
um and in the new composing version it

00:23:03,440 --> 00:23:06,880
would be number

00:23:04,320 --> 00:23:08,320
uh colon colon array ref so it'd be

00:23:06,880 --> 00:23:09,360
number scope array ref instead of

00:23:08,320 --> 00:23:11,520
underscore

00:23:09,360 --> 00:23:12,960
um you can see this number two is

00:23:11,520 --> 00:23:14,320
actually a hint

00:23:12,960 --> 00:23:16,240
uh that says it's going to be a two

00:23:14,320 --> 00:23:17,600
dimensional data but you don't have to

00:23:16,240 --> 00:23:20,159
put that if you don't know

00:23:17,600 --> 00:23:21,440
the size of the data the distance is an

00:23:20,159 --> 00:23:23,520
individual number

00:23:21,440 --> 00:23:25,039
so it's a floating point number and the

00:23:23,520 --> 00:23:26,880
classification is a string

00:23:25,039 --> 00:23:28,400
um because it could be anything you

00:23:26,880 --> 00:23:28,880
could it could be named you know llamas

00:23:28,400 --> 00:23:32,320
versus

00:23:28,880 --> 00:23:34,320
emus or camels versus dramaticaries or

00:23:32,320 --> 00:23:36,799
you know pearl versus non-pearl whatever

00:23:34,320 --> 00:23:38,799
it it's just a string it's an arbitrary

00:23:36,799 --> 00:23:41,279
string classification

00:23:38,799 --> 00:23:43,919
that's it that's the whole class that's

00:23:41,279 --> 00:23:46,159
all you really need

00:23:43,919 --> 00:23:48,080
as far as we're implementing this in a

00:23:46,159 --> 00:23:50,559
similar object-oriented fashion

00:23:48,080 --> 00:23:51,360
because it it makes sense to have these

00:23:50,559 --> 00:23:54,559
neighbors

00:23:51,360 --> 00:23:57,600
as their sort of standalone objects um

00:23:54,559 --> 00:24:00,640
we could crunch this all into some giant

00:23:57,600 --> 00:24:03,919
data structure or something but why

00:24:00,640 --> 00:24:04,799
make bad code when you can make nicer

00:24:03,919 --> 00:24:07,440
code and

00:24:04,799 --> 00:24:08,799
this this is a programming exercise that

00:24:07,440 --> 00:24:12,320
does lend itself

00:24:08,799 --> 00:24:17,360
to object oriented stylings

00:24:12,320 --> 00:24:21,600
so uh what do we do with this next slide

00:24:17,360 --> 00:24:24,400
we use it in um the classifier

00:24:21,600 --> 00:24:26,240
function so um this is again the

00:24:24,400 --> 00:24:27,840
interesting part of the code there's a

00:24:26,240 --> 00:24:29,440
whole bunch of boilerplate that has to

00:24:27,840 --> 00:24:31,919
do with

00:24:29,440 --> 00:24:33,440
data inputs and outputs and and so forth

00:24:31,919 --> 00:24:34,880
but this is the cool part of the code

00:24:33,440 --> 00:24:36,480
the code

00:24:34,880 --> 00:24:38,320
there's some before and after it that

00:24:36,480 --> 00:24:39,600
has to do with finding out which of the

00:24:38,320 --> 00:24:42,880
distances are the

00:24:39,600 --> 00:24:44,159
shortest and iterating through data and

00:24:42,880 --> 00:24:46,480
so forth but

00:24:44,159 --> 00:24:47,440
this is the math this is the math that

00:24:46,480 --> 00:24:50,559
we care about

00:24:47,440 --> 00:24:52,400
um the math behind the uh

00:24:50,559 --> 00:24:54,240
k nearest neighbor so that's why i chose

00:24:52,400 --> 00:24:57,760
these bits to look at specifically

00:24:54,240 --> 00:25:00,960
this is three different distance

00:24:57,760 --> 00:25:02,480
functions by the way k nearest neighbor

00:25:00,960 --> 00:25:06,000
is a supervised

00:25:02,480 --> 00:25:07,850
uh type of machine learning algorithm

00:25:06,000 --> 00:25:09,039
um you

00:25:07,850 --> 00:25:10,799
[Music]

00:25:09,039 --> 00:25:12,400
i guess there might be some way to do it

00:25:10,799 --> 00:25:12,960
as reinforcement or unsupervised i

00:25:12,400 --> 00:25:16,400
haven't

00:25:12,960 --> 00:25:17,760
gone that deep um but this style of

00:25:16,400 --> 00:25:21,919
using the default

00:25:17,760 --> 00:25:21,919
of using k-nearest neighbor is

00:25:23,200 --> 00:25:27,799
supervised learning and within

00:25:26,240 --> 00:25:30,240
the sort of i guess the

00:25:27,799 --> 00:25:34,000
subclassification of of uh

00:25:30,240 --> 00:25:36,400
supervised learning is um

00:25:34,000 --> 00:25:38,080
classifiers there's also regression

00:25:36,400 --> 00:25:40,000
there's also

00:25:38,080 --> 00:25:42,000
other things like i mentioned uh making

00:25:40,000 --> 00:25:45,919
decisions about things and

00:25:42,000 --> 00:25:48,799
and so forth um uh usually

00:25:45,919 --> 00:25:51,360
uh active learning classification and

00:25:48,799 --> 00:25:53,039
regression are

00:25:51,360 --> 00:25:56,159
quoted as some of the primary

00:25:53,039 --> 00:25:58,880
subcategories of of supervised learning

00:25:56,159 --> 00:26:00,080
um so we're we're classifying in this

00:25:58,880 --> 00:26:03,520
case that means that we

00:26:00,080 --> 00:26:04,000
want to choose a classification for each

00:26:03,520 --> 00:26:05,279
of those

00:26:04,000 --> 00:26:07,120
points that did not have a

00:26:05,279 --> 00:26:10,640
classification

00:26:07,120 --> 00:26:13,679
so um how how do we

00:26:10,640 --> 00:26:15,840
know which of the neighbors is nearest

00:26:13,679 --> 00:26:18,880
well we have to calculate the distance

00:26:15,840 --> 00:26:21,039
and then just choose the the top k

00:26:18,880 --> 00:26:22,320
uh closest neighbors or k nearest

00:26:21,039 --> 00:26:25,840
neighbors that's the name

00:26:22,320 --> 00:26:28,960
of the algorithm um but uh

00:26:25,840 --> 00:26:31,200
in this case we we don't know how to

00:26:28,960 --> 00:26:34,159
compute the distance because there's

00:26:31,200 --> 00:26:36,559
several different ways i mean you could

00:26:34,159 --> 00:26:39,120
you could make up any distance function

00:26:36,559 --> 00:26:40,320
in fact uh there there are not only

00:26:39,120 --> 00:26:41,919
these three

00:26:40,320 --> 00:26:43,440
sort of obvious and easy distance

00:26:41,919 --> 00:26:45,039
functions that we're about to cover real

00:26:43,440 --> 00:26:46,650
quick but

00:26:45,039 --> 00:26:48,400
there are um

00:26:46,650 --> 00:26:49,840
[Music]

00:26:48,400 --> 00:26:52,080
you could make up your own distance

00:26:49,840 --> 00:26:55,679
functions functions there's a ton of

00:26:52,080 --> 00:26:58,799
different um options

00:26:55,679 --> 00:27:00,400
and and uh you know things you can tweak

00:26:58,799 --> 00:27:02,960
and make it run a little different or a

00:27:00,400 --> 00:27:05,600
little faster or more optimized or

00:27:02,960 --> 00:27:07,039
there's k nearest neighbor is a simple

00:27:05,600 --> 00:27:09,279
algorithm but it can go

00:27:07,039 --> 00:27:10,880
it can become deep and and that's kind

00:27:09,279 --> 00:27:11,600
of what they've done with sklearn is

00:27:10,880 --> 00:27:14,720
they've you know

00:27:11,600 --> 00:27:16,799
implemented every possible option

00:27:14,720 --> 00:27:18,240
um that you can get including all the

00:27:16,799 --> 00:27:18,960
different distance functions all the

00:27:18,240 --> 00:27:22,240
different

00:27:18,960 --> 00:27:23,760
uh types of input and output data and

00:27:22,240 --> 00:27:25,840
and so forth so

00:27:23,760 --> 00:27:27,600
um but let's look at these three and

00:27:25,840 --> 00:27:29,919
just see kind of how they work

00:27:27,600 --> 00:27:31,600
the first one is called the manhattan

00:27:29,919 --> 00:27:32,559
distance it's called manhattan because

00:27:31,600 --> 00:27:35,360
if you imagine

00:27:32,559 --> 00:27:36,320
that you are walking around on foot in

00:27:35,360 --> 00:27:38,880
manhattan

00:27:36,320 --> 00:27:40,480
um it's a bunch of city grids right it's

00:27:38,880 --> 00:27:42,880
a it's a square city

00:27:40,480 --> 00:27:44,559
with all of these uh you know city

00:27:42,880 --> 00:27:48,640
blocks in a grid

00:27:44,559 --> 00:27:50,640
and um you cannot cut diagonal through a

00:27:48,640 --> 00:27:51,840
building obviously because that's a

00:27:50,640 --> 00:27:55,600
solid

00:27:51,840 --> 00:27:58,640
brick building that you as a

00:27:55,600 --> 00:27:59,840
you know matter based entity cannot

00:27:58,640 --> 00:28:02,080
pass through maybe if you're a

00:27:59,840 --> 00:28:04,880
non-corporeal form you could float right

00:28:02,080 --> 00:28:06,240
through the the big giant buildings but

00:28:04,880 --> 00:28:09,120
as a normal human

00:28:06,240 --> 00:28:10,480
you have to walk you know three blocks

00:28:09,120 --> 00:28:13,679
north and then

00:28:10,480 --> 00:28:16,000
two blocks east to get to

00:28:13,679 --> 00:28:18,000
a place that as the crow flies diagonal

00:28:16,000 --> 00:28:20,399
would be a much shorter distance

00:28:18,000 --> 00:28:22,480
um so it actually does take quite a long

00:28:20,399 --> 00:28:25,840
time to walk anywhere in manhattan

00:28:22,480 --> 00:28:26,960
um i i've been on several field trips as

00:28:25,840 --> 00:28:30,640
a youth uh

00:28:26,960 --> 00:28:32,559
living in the in the northeast and

00:28:30,640 --> 00:28:34,799
you just kind of walk forever those city

00:28:32,559 --> 00:28:37,200
blocks are are super long

00:28:34,799 --> 00:28:37,919
so the manhattan distance as you can see

00:28:37,200 --> 00:28:41,039
here

00:28:37,919 --> 00:28:44,480
is just the uh the x

00:28:41,039 --> 00:28:47,440
distance um so you know the

00:28:44,480 --> 00:28:48,559
the training data minus the test data x

00:28:47,440 --> 00:28:51,919
coordinates

00:28:48,559 --> 00:28:54,399
uh plus the training data um

00:28:51,919 --> 00:28:55,279
minus test data y coordinates so it's

00:28:54,399 --> 00:28:58,080
the same thing i'm just

00:28:55,279 --> 00:29:00,000
walking up and then walking over it's

00:28:58,080 --> 00:29:03,200
not a diagonal shortcut

00:29:00,000 --> 00:29:05,919
it's it's a longer distance because it's

00:29:03,200 --> 00:29:07,600
like city blocks walking there uh that's

00:29:05,919 --> 00:29:11,600
called the manhattan distance

00:29:07,600 --> 00:29:15,600
um there may be reasons to use this

00:29:11,600 --> 00:29:18,799
it's i guess whatever makes sense to you

00:29:15,600 --> 00:29:20,880
uh to do that there's there's no right

00:29:18,799 --> 00:29:24,720
or wrong answer really the second

00:29:20,880 --> 00:29:28,399
um metric or distance function

00:29:24,720 --> 00:29:30,960
is euclidean and this is uh this is

00:29:28,399 --> 00:29:33,279
where you can go diagonal you can go as

00:29:30,960 --> 00:29:35,840
the crow flies or imagine you're

00:29:33,279 --> 00:29:36,640
you know in no clipping mode in doom and

00:29:35,840 --> 00:29:40,799
um

00:29:36,640 --> 00:29:42,720
you can you know uh idsp is popd

00:29:40,799 --> 00:29:43,840
right through the diagonal through the

00:29:42,720 --> 00:29:47,279
walls and

00:29:43,840 --> 00:29:50,399
and get to where you need to go in a

00:29:47,279 --> 00:29:52,840
shorter distance obviously and this is

00:29:50,399 --> 00:29:54,240
um perhaps more meaningful for

00:29:52,840 --> 00:29:57,520
two-dimensional type

00:29:54,240 --> 00:30:00,880
data that has two-dimensional distances

00:29:57,520 --> 00:30:03,360
because it's the obvious natural

00:30:00,880 --> 00:30:04,000
distance between two points would be to

00:30:03,360 --> 00:30:06,240
just

00:30:04,000 --> 00:30:08,320
go directly between them instead of

00:30:06,240 --> 00:30:10,960
walking down and then over

00:30:08,320 --> 00:30:11,840
um in order to do that you have to you

00:30:10,960 --> 00:30:14,240
have to uh

00:30:11,840 --> 00:30:15,600
subtract the x coordinates but then

00:30:14,240 --> 00:30:17,760
square that

00:30:15,600 --> 00:30:19,039
subtract the y coordinates square that

00:30:17,760 --> 00:30:20,960
add them together and then take the

00:30:19,039 --> 00:30:24,399
square root of the whole thing

00:30:20,960 --> 00:30:28,880
um you probably remember this from

00:30:24,399 --> 00:30:32,159
your geometry um in high school or

00:30:28,880 --> 00:30:36,240
college so that is the normal

00:30:32,159 --> 00:30:37,760
2d method if we had to keep

00:30:36,240 --> 00:30:39,679
one of these three we would keep

00:30:37,760 --> 00:30:40,640
euclidean for two-dimensional because

00:30:39,679 --> 00:30:42,559
it's um

00:30:40,640 --> 00:30:44,080
it's the fastest implementation of the

00:30:42,559 --> 00:30:46,480
default most

00:30:44,080 --> 00:30:47,679
natural distance for two-dimensional

00:30:46,480 --> 00:30:49,520
data points

00:30:47,679 --> 00:30:50,960
um and then the third metric that we can

00:30:49,520 --> 00:30:52,799
see here

00:30:50,960 --> 00:30:54,080
this is all pure parole obviously this

00:30:52,799 --> 00:30:55,120
is the real code i just copied and

00:30:54,080 --> 00:30:58,559
pasted it

00:30:55,120 --> 00:31:02,840
um this is minkowski space

00:30:58,559 --> 00:31:05,679
so euclidean space is sort of the normal

00:31:02,840 --> 00:31:09,519
two-dimensional distance minkowski

00:31:05,679 --> 00:31:11,440
is uh generalized um in fact

00:31:09,519 --> 00:31:13,200
minkowski is the generalized version of

00:31:11,440 --> 00:31:13,840
both manhattan and euclidean once you

00:31:13,200 --> 00:31:17,600
understand

00:31:13,840 --> 00:31:18,080
that conversely euclidean and manhattan

00:31:17,600 --> 00:31:21,039
are

00:31:18,080 --> 00:31:22,720
degenerate cases of minkowski so

00:31:21,039 --> 00:31:25,519
minkowski space

00:31:22,720 --> 00:31:27,360
um is the same thing as euclidean but

00:31:25,519 --> 00:31:28,640
instead of squaring it squaring it and

00:31:27,360 --> 00:31:31,039
square rooting it

00:31:28,640 --> 00:31:32,000
you're doing an arbitrary power

00:31:31,039 --> 00:31:35,600
arbitrary power

00:31:32,000 --> 00:31:38,880
and then that same thing as the um

00:31:35,600 --> 00:31:40,640
power route so one over that

00:31:38,880 --> 00:31:42,080
uh which is the same thing as taking the

00:31:40,640 --> 00:31:44,960
square root if the

00:31:42,080 --> 00:31:46,240
p power was two um then you would be

00:31:44,960 --> 00:31:47,440
squaring it squaring it and taking the

00:31:46,240 --> 00:31:49,519
square root so

00:31:47,440 --> 00:31:52,320
um you can see that with p equal to

00:31:49,519 --> 00:31:54,320
minkowski space is equal to euclidean

00:31:52,320 --> 00:31:56,080
um minkowski distance sorry is equal to

00:31:54,320 --> 00:31:58,559
euclidean and then with p

00:31:56,080 --> 00:32:00,080
equal one minkowski distance is

00:31:58,559 --> 00:32:01,600
equivalent to manhattan because you're

00:32:00,080 --> 00:32:02,799
just raising things to the first power

00:32:01,600 --> 00:32:04,480
raises the first power

00:32:02,799 --> 00:32:05,919
and then take the first root of it the

00:32:04,480 --> 00:32:08,480
one root which is nothing that

00:32:05,919 --> 00:32:10,320
all is just a no op and thus it can drop

00:32:08,480 --> 00:32:12,000
out and become this more simple code

00:32:10,320 --> 00:32:15,200
that you see right here

00:32:12,000 --> 00:32:16,559
um minkowski distance is more

00:32:15,200 --> 00:32:18,080
complicated more computationally

00:32:16,559 --> 00:32:21,519
intensive

00:32:18,080 --> 00:32:25,039
so um you probably don't

00:32:21,519 --> 00:32:27,279
want to use that unless you have to use

00:32:25,039 --> 00:32:29,120
it for some weird scientific reason but

00:32:27,279 --> 00:32:30,399
if you have multi-dimensional data then

00:32:29,120 --> 00:32:33,840
it's going to become

00:32:30,399 --> 00:32:36,640
i believe much more significant so

00:32:33,840 --> 00:32:39,600
this is real code uh above and around

00:32:36,640 --> 00:32:41,919
this code there's like

00:32:39,600 --> 00:32:43,440
a for loop to go through each point so

00:32:41,919 --> 00:32:46,399
this is just for one data point

00:32:43,440 --> 00:32:48,080
and then after this piece of this code

00:32:46,399 --> 00:32:49,840
it does have to have another for loop to

00:32:48,080 --> 00:32:52,480
search for those k

00:32:49,840 --> 00:32:54,480
nearest neighbors because it's this is

00:32:52,480 --> 00:32:55,120
calculating one distance for one

00:32:54,480 --> 00:32:57,120
neighbor

00:32:55,120 --> 00:32:58,559
but then you have to do that for the k

00:32:57,120 --> 00:33:00,320
nearest neighbors and then throw out the

00:32:58,559 --> 00:33:01,679
ones that are not the nearest neighbors

00:33:00,320 --> 00:33:03,360
and so forth so there's a lot of

00:33:01,679 --> 00:33:03,919
optimization that can go on in this

00:33:03,360 --> 00:33:05,679
algorithm

00:33:03,919 --> 00:33:07,440
that's why i'm not going to try and go

00:33:05,679 --> 00:33:10,080
through

00:33:07,440 --> 00:33:11,360
every bit of the code during this

00:33:10,080 --> 00:33:14,960
presentation you can

00:33:11,360 --> 00:33:14,960
look it up yourself if you like

00:33:15,360 --> 00:33:18,880
next slide please oh my goodness we're

00:33:17,600 --> 00:33:21,360
still in the middle of this long run

00:33:18,880 --> 00:33:23,120
with no memes that's a very bad mistake

00:33:21,360 --> 00:33:24,720
on my part i should have interjected

00:33:23,120 --> 00:33:27,039
some pearl memes

00:33:24,720 --> 00:33:29,279
in the middle of this code um let's go

00:33:27,039 --> 00:33:31,200
back to one that had some memes oh yes

00:33:29,279 --> 00:33:34,720
the guy with the giant book

00:33:31,200 --> 00:33:38,240
that was cool okay back to this stuff

00:33:34,720 --> 00:33:41,600
um run times in python oh

00:33:38,240 --> 00:33:45,519
get that language out of here well

00:33:41,600 --> 00:33:49,279
um yeah the snake language

00:33:45,519 --> 00:33:52,240
the snake language matters a lot

00:33:49,279 --> 00:33:52,880
because we need to know how we're doing

00:33:52,240 --> 00:33:57,039
i guess

00:33:52,880 --> 00:34:00,080
are we doing good or not um so

00:33:57,039 --> 00:34:04,000
i just used sklearn i um

00:34:00,080 --> 00:34:07,120
my my friends helped me

00:34:04,000 --> 00:34:08,399
uh well my friends actually used sklearn

00:34:07,120 --> 00:34:11,440
and i just kind of

00:34:08,399 --> 00:34:15,359
copied their code but um

00:34:11,440 --> 00:34:18,839
but yeah this is actual scleron runtimes

00:34:15,359 --> 00:34:20,639
on my system um obviously it's an

00:34:18,839 --> 00:34:22,320
arbitrary speed because

00:34:20,639 --> 00:34:23,760
my computer speed would be different

00:34:22,320 --> 00:34:24,639
than yours but all of these runtimes

00:34:23,760 --> 00:34:26,240
were done

00:34:24,639 --> 00:34:28,399
on the same system so that's what

00:34:26,240 --> 00:34:31,679
matters uh

00:34:28,399 --> 00:34:32,560
sorry i didn't sort this by data size

00:34:31,679 --> 00:34:35,679
but it's

00:34:32,560 --> 00:34:38,480
kind of in these groups of uh three

00:34:35,679 --> 00:34:40,560
rows at a time um for the number of

00:34:38,480 --> 00:34:43,119
timing repetitions i kept increasing the

00:34:40,560 --> 00:34:45,440
timing repetitions because

00:34:43,119 --> 00:34:46,960
with a low number of repetitions you

00:34:45,440 --> 00:34:48,800
were having too much startup and

00:34:46,960 --> 00:34:50,159
shutdown time and things weren't getting

00:34:48,800 --> 00:34:53,280
cached right and

00:34:50,159 --> 00:34:56,079
it's not as accurate of a timing i guess

00:34:53,280 --> 00:34:56,720
um so with more repetitions it helps and

00:34:56,079 --> 00:35:00,800
then of course

00:34:56,720 --> 00:35:03,440
increasing the data size

00:35:00,800 --> 00:35:05,280
of the training data and increasing the

00:35:03,440 --> 00:35:07,680
data size of the testing data

00:35:05,280 --> 00:35:10,720
so all of these things kind of multiply

00:35:07,680 --> 00:35:13,280
out to make larger and larger data

00:35:10,720 --> 00:35:13,920
and um in general longer and longer run

00:35:13,280 --> 00:35:16,000
times

00:35:13,920 --> 00:35:17,520
although i didn't sort this by again

00:35:16,000 --> 00:35:19,280
data size or runtime

00:35:17,520 --> 00:35:20,720
um i apologize in that but we'll see the

00:35:19,280 --> 00:35:23,839
data sorted here in a minute

00:35:20,720 --> 00:35:24,480
uh i i did this the way that it was in

00:35:23,839 --> 00:35:27,200
my

00:35:24,480 --> 00:35:27,760
my timing spreadsheet uh and then you

00:35:27,200 --> 00:35:30,800
can see

00:35:27,760 --> 00:35:34,720
the this is a speed column this uh

00:35:30,800 --> 00:35:37,760
this column here um is is essentially a

00:35:34,720 --> 00:35:38,240
a measure of speed uh and you can see

00:35:37,760 --> 00:35:41,760
that

00:35:38,240 --> 00:35:43,839
that is um slowly increasing in speed

00:35:41,760 --> 00:35:45,119
so the the bigger the test data and the

00:35:43,839 --> 00:35:48,320
longer you let the

00:35:45,119 --> 00:35:51,599
python code run the faster it

00:35:48,320 --> 00:35:55,040
runs interestingly um and

00:35:51,599 --> 00:35:56,400
uh and it in fact uh continues to run

00:35:55,040 --> 00:35:57,920
faster and faster that

00:35:56,400 --> 00:36:01,119
that was an annoying thing i will tell

00:35:57,920 --> 00:36:03,680
you that the python interpreter

00:36:01,119 --> 00:36:05,040
has so much tricky stuff built into it i

00:36:03,680 --> 00:36:09,440
had to

00:36:05,040 --> 00:36:13,200
do operating operating system level

00:36:09,440 --> 00:36:17,839
uh sandboxing and process control

00:36:13,200 --> 00:36:21,119
in order to stop the python interpreter

00:36:17,839 --> 00:36:23,760
from spawning new threads

00:36:21,119 --> 00:36:25,520
from caching things that it shouldn't

00:36:23,760 --> 00:36:29,839
and so forth in order to make it

00:36:25,520 --> 00:36:31,599
show me a real timing um the

00:36:29,839 --> 00:36:33,119
python did not want to show me a real

00:36:31,599 --> 00:36:34,960
timing let's just say that

00:36:33,119 --> 00:36:36,560
now i'm sure for the python programmers

00:36:34,960 --> 00:36:37,760
that just want something to run and run

00:36:36,560 --> 00:36:39,520
fast that's great but

00:36:37,760 --> 00:36:41,760
when you're doing comparative timings it

00:36:39,520 --> 00:36:42,880
was not so easy or great

00:36:41,760 --> 00:36:45,040
we're going to come back to the slide in

00:36:42,880 --> 00:36:49,040
a minute but let's look at pearl

00:36:45,040 --> 00:36:51,680
it's the same exact sizes and

00:36:49,040 --> 00:36:52,640
timing repetitions and so forth and you

00:36:51,680 --> 00:36:55,760
can see that

00:36:52,640 --> 00:36:59,119
it is again increasing in

00:36:55,760 --> 00:37:02,400
speed the second to last column here um

00:36:59,119 --> 00:37:04,400
it is slowly increasing in speed um

00:37:02,400 --> 00:37:06,400
although perhaps not as much as we would

00:37:04,400 --> 00:37:09,200
like so if we go back to the previous

00:37:06,400 --> 00:37:11,520
slide you will see that the last column

00:37:09,200 --> 00:37:13,200
in both of them is comparative so for

00:37:11,520 --> 00:37:15,599
the python

00:37:13,200 --> 00:37:17,760
speeds where the last column is the

00:37:15,599 --> 00:37:20,320
plural comparative speed up

00:37:17,760 --> 00:37:21,680
how many times faster is python than

00:37:20,320 --> 00:37:24,079
perl

00:37:21,680 --> 00:37:25,440
so uh and then for the for the pearl

00:37:24,079 --> 00:37:29,839
slide it's the opposite

00:37:25,440 --> 00:37:32,880
so uh at the very small

00:37:29,839 --> 00:37:36,800
smallest scale python

00:37:32,880 --> 00:37:38,320
was like one and two-thirds the speed

00:37:36,800 --> 00:37:39,839
if this was one it would mean they're

00:37:38,320 --> 00:37:42,960
equal speed

00:37:39,839 --> 00:37:46,000
but once you get up into

00:37:42,960 --> 00:37:49,200
you know larger run times um and

00:37:46,000 --> 00:37:51,839
sizes data size and so forth uh

00:37:49,200 --> 00:37:52,400
python starts getting a lot faster and

00:37:51,839 --> 00:37:55,280
this was

00:37:52,400 --> 00:37:57,760
even with all of my controls turned on

00:37:55,280 --> 00:38:00,640
with the controls not turned on python

00:37:57,760 --> 00:38:02,240
became way too fast way too quick but it

00:38:00,640 --> 00:38:05,520
was doing all sorts of cheats

00:38:02,240 --> 00:38:06,160
and and stuff that was not real timings

00:38:05,520 --> 00:38:08,480
again

00:38:06,160 --> 00:38:10,480
so it was not compared if it was apples

00:38:08,480 --> 00:38:11,839
to oranges not apples to apples

00:38:10,480 --> 00:38:14,320
so when you do the apples to apples

00:38:11,839 --> 00:38:15,200
comparison as close as i could possibly

00:38:14,320 --> 00:38:19,200
get it

00:38:15,200 --> 00:38:21,119
this is what you get um eventually

00:38:19,200 --> 00:38:23,040
uh python keeps getting faster and

00:38:21,119 --> 00:38:25,030
faster and pearl

00:38:23,040 --> 00:38:27,520
can't keep up with that um

00:38:25,030 --> 00:38:29,520
[Music]

00:38:27,520 --> 00:38:31,440
this the data that you're looking at

00:38:29,520 --> 00:38:35,520
here shows it going

00:38:31,440 --> 00:38:39,040
um all the way up to 19 times faster

00:38:35,520 --> 00:38:41,920
python 19 times faster than pearl

00:38:39,040 --> 00:38:43,839
but i can tell you it keeps going it

00:38:41,920 --> 00:38:47,040
does not end there

00:38:43,839 --> 00:38:49,920
in fact i'm looking at at my much

00:38:47,040 --> 00:38:50,960
larger spreadsheet that has sparse data

00:38:49,920 --> 00:38:52,480
when i stopped

00:38:50,960 --> 00:38:54,240
running the pearl code because it was

00:38:52,480 --> 00:38:54,720
taking like it was going to take over a

00:38:54,240 --> 00:38:56,570
day

00:38:54,720 --> 00:38:58,000
to run

00:38:56,570 --> 00:39:01,040
[Music]

00:38:58,000 --> 00:39:03,680
python was 30 times faster

00:39:01,040 --> 00:39:05,200
and and still increasing so for

00:39:03,680 --> 00:39:07,920
long-running data like

00:39:05,200 --> 00:39:08,720
you know real uh machine learning stuff

00:39:07,920 --> 00:39:12,480
that's going to run

00:39:08,720 --> 00:39:15,200
for days and days and weeks and weeks

00:39:12,480 --> 00:39:16,320
python could be 50 times 100 times fast

00:39:15,200 --> 00:39:18,480
it's

00:39:16,320 --> 00:39:20,560
so much more faster even with full

00:39:18,480 --> 00:39:22,560
controls locking it down

00:39:20,560 --> 00:39:24,079
that pearl can't really compete when you

00:39:22,560 --> 00:39:26,880
turn those controls off

00:39:24,079 --> 00:39:28,000
python's going to be 500 times faster or

00:39:26,880 --> 00:39:30,960
a thousand times faster

00:39:28,000 --> 00:39:33,200
or something that's so much faster that

00:39:30,960 --> 00:39:36,960
right about now y'all should start

00:39:33,200 --> 00:39:38,880
getting worried if you're a pearl

00:39:36,960 --> 00:39:40,320
programmer if you're a python programmer

00:39:38,880 --> 00:39:41,599
here watching this for some reason you

00:39:40,320 --> 00:39:45,520
should be laughing

00:39:41,599 --> 00:39:49,440
right about now well don't you worry the

00:39:45,520 --> 00:39:52,240
tides are soon about to turn here so

00:39:49,440 --> 00:39:54,320
um again you can see the same thing here

00:39:52,240 --> 00:39:55,520
uh but it's just the the inverted number

00:39:54,320 --> 00:39:58,000
so it's down to about 1

00:39:55,520 --> 00:40:00,720
20th here at the end but it keeps

00:39:58,000 --> 00:40:04,400
decreasing

00:40:00,720 --> 00:40:06,960
but wait sir wasn't there some sort of

00:40:04,400 --> 00:40:08,160
thing that allows us to make our pearl

00:40:06,960 --> 00:40:11,920
code

00:40:08,160 --> 00:40:14,640
run at a competitive speed

00:40:11,920 --> 00:40:16,800
well i think there is and i seem to

00:40:14,640 --> 00:40:20,000
remember spending the last several years

00:40:16,800 --> 00:40:22,560
programming up the perl compiler

00:40:20,000 --> 00:40:23,280
so let's see what happens when we

00:40:22,560 --> 00:40:26,640
compile

00:40:23,280 --> 00:40:30,480
that code we looked at a few minutes ago

00:40:26,640 --> 00:40:33,680
well holy cow it starts running

00:40:30,480 --> 00:40:34,640
gosh dang fast and not just a little

00:40:33,680 --> 00:40:38,400
fast but really

00:40:34,640 --> 00:40:42,560
super duper duper duper fast um

00:40:38,400 --> 00:40:45,760
so here we have two final columns

00:40:42,560 --> 00:40:48,560
how many times faster is compiled pearl

00:40:45,760 --> 00:40:49,040
than not compiled pearl and how many

00:40:48,560 --> 00:40:53,119
times

00:40:49,040 --> 00:40:57,119
faster is compiled pearl than python

00:40:53,119 --> 00:41:01,200
and um so

00:40:57,119 --> 00:41:05,040
now we're becoming competitive uh

00:41:01,200 --> 00:41:08,720
the rate at which the compiled pearl

00:41:05,040 --> 00:41:11,280
increases in speed as data size and

00:41:08,720 --> 00:41:14,640
runtime increase

00:41:11,280 --> 00:41:15,839
is um greater than that which

00:41:14,640 --> 00:41:20,480
interpreted pearl does

00:41:15,839 --> 00:41:23,119
in other words this ratio

00:41:20,480 --> 00:41:24,480
increasing compiled pearl just keeps

00:41:23,119 --> 00:41:28,480
getting faster

00:41:24,480 --> 00:41:31,599
regular pearl is not getting fast

00:41:28,480 --> 00:41:34,640
like that so

00:41:31,599 --> 00:41:36,240
the this is not the the case where

00:41:34,640 --> 00:41:38,160
oh i just need to run my data long

00:41:36,240 --> 00:41:40,800
enough and the pearl interpreter will

00:41:38,160 --> 00:41:42,079
eventually save me no no no the longer

00:41:40,800 --> 00:41:45,359
you run the worse

00:41:42,079 --> 00:41:48,079
the interpreter gets so i'm i'm not here

00:41:45,359 --> 00:41:49,839
to poo poo on p5p

00:41:48,079 --> 00:41:51,599
i'm not here to say that pearl sucks in

00:41:49,839 --> 00:41:53,280
fact i'm here to to make people

00:41:51,599 --> 00:41:55,680
understand that

00:41:53,280 --> 00:41:57,440
there's better pearl to be had out there

00:41:55,680 --> 00:41:59,040
you do not need to use the interpreter

00:41:57,440 --> 00:42:02,640
if it's going to run slow

00:41:59,040 --> 00:42:04,000
which it will you need to compile your

00:42:02,640 --> 00:42:07,520
pearl

00:42:04,000 --> 00:42:10,319
likewise um compiled pearl

00:42:07,520 --> 00:42:11,760
has a comparison with python but it's

00:42:10,319 --> 00:42:15,119
not increasing

00:42:11,760 --> 00:42:17,760
in fact it is converging

00:42:15,119 --> 00:42:20,000
if you let the compiled pearl run for a

00:42:17,760 --> 00:42:23,760
long long time

00:42:20,000 --> 00:42:27,359
python will apparently either

00:42:23,760 --> 00:42:30,160
completely cache all operations

00:42:27,359 --> 00:42:31,119
or internally compile everything using

00:42:30,160 --> 00:42:33,280
either

00:42:31,119 --> 00:42:35,040
our python or some other internal

00:42:33,280 --> 00:42:36,400
jitting mechanism that i'm not familiar

00:42:35,040 --> 00:42:38,800
with

00:42:36,400 --> 00:42:40,480
i don't know which because i'm not a

00:42:38,800 --> 00:42:42,560
python programmer and i don't know

00:42:40,480 --> 00:42:43,359
anything about python guts but i can

00:42:42,560 --> 00:42:45,920
tell you

00:42:43,359 --> 00:42:47,920
that when i let the code run for a long

00:42:45,920 --> 00:42:50,800
long time

00:42:47,920 --> 00:42:52,000
this column that's comparing the

00:42:50,800 --> 00:42:54,240
compiled perl

00:42:52,000 --> 00:42:56,839
with python that will eventually

00:42:54,240 --> 00:42:58,480
converge to

00:42:56,839 --> 00:43:01,599
one

00:42:58,480 --> 00:43:01,599
that's interesting that's

00:43:02,240 --> 00:43:06,000
more than interesting it may even be a

00:43:03,760 --> 00:43:08,319
little bit mind-blowing because it means

00:43:06,000 --> 00:43:10,400
that the fastest we can possibly get

00:43:08,319 --> 00:43:11,839
which is compiling our pearl code into

00:43:10,400 --> 00:43:15,200
c and c plus plus and is about the

00:43:11,839 --> 00:43:19,599
fastest as you can get is also attained

00:43:15,200 --> 00:43:22,240
now apparently automatically

00:43:19,599 --> 00:43:24,319
by python over time it has to run for

00:43:22,240 --> 00:43:26,000
quite some time to achieve that but it's

00:43:24,319 --> 00:43:28,160
doing it's compiling stuff in the

00:43:26,000 --> 00:43:31,200
background or something

00:43:28,160 --> 00:43:33,680
i don't know how it's doing that so this

00:43:31,200 --> 00:43:36,480
is just a warning

00:43:33,680 --> 00:43:37,520
to the pearl steering council that as

00:43:36,480 --> 00:43:39,440
soon as you guys

00:43:37,520 --> 00:43:41,599
have an official request for comments

00:43:39,440 --> 00:43:44,240
we're going to have to do something

00:43:41,599 --> 00:43:45,760
about getting data types into the pro

00:43:44,240 --> 00:43:46,800
core and eventually about getting

00:43:45,760 --> 00:43:49,520
compiler

00:43:46,800 --> 00:43:51,680
the perl compiler r perl merged into the

00:43:49,520 --> 00:43:52,240
pro core because apparently it's already

00:43:51,680 --> 00:43:54,720
been done

00:43:52,240 --> 00:43:55,440
in python whatever mechanism they're

00:43:54,720 --> 00:43:58,880
using

00:43:55,440 --> 00:44:01,280
it's it's eventually after a long long

00:43:58,880 --> 00:44:05,200
time after several hours of running

00:44:01,280 --> 00:44:08,560
it is able to match our top speed

00:44:05,200 --> 00:44:11,839
now our top speed is from the get go

00:44:08,560 --> 00:44:13,280
that's why we start out at 17 18 19

00:44:11,839 --> 00:44:15,599
times faster

00:44:13,280 --> 00:44:17,280
because our code runs super fast from

00:44:15,599 --> 00:44:20,000
the very beginning once you

00:44:17,280 --> 00:44:22,640
just compile it but the python code

00:44:20,000 --> 00:44:24,000
keeps getting faster and faster

00:44:22,640 --> 00:44:26,640
we're getting near the end but there's

00:44:24,000 --> 00:44:29,680
some nifty graphs

00:44:26,640 --> 00:44:32,800
um this is

00:44:29,680 --> 00:44:35,520
uh run time you don't want to be going

00:44:32,800 --> 00:44:36,000
up in this graph and look at pearl going

00:44:35,520 --> 00:44:39,200
up

00:44:36,000 --> 00:44:40,560
like a bottle rocket dang that's

00:44:39,200 --> 00:44:42,400
interpreted pearl

00:44:40,560 --> 00:44:44,800
python is down there at the bottom kind

00:44:42,400 --> 00:44:45,359
of munging around and slowly going up a

00:44:44,800 --> 00:44:47,920
bit

00:44:45,359 --> 00:44:48,480
and our pearl uh compiled pearl is like

00:44:47,920 --> 00:44:52,319
almost

00:44:48,480 --> 00:44:54,480
flat on the bottom there um

00:44:52,319 --> 00:44:58,160
getting rid of the lat first and last

00:44:54,480 --> 00:45:00,800
three entries just zooming in a bit here

00:44:58,160 --> 00:45:01,520
you can see that again regular pearl is

00:45:00,800 --> 00:45:05,119
is

00:45:01,520 --> 00:45:07,280
going upwards at a seemingly

00:45:05,119 --> 00:45:08,960
exponentially increasing curve i had to

00:45:07,280 --> 00:45:11,119
stop after a while because it

00:45:08,960 --> 00:45:13,680
very quickly just starts taking days to

00:45:11,119 --> 00:45:15,839
run things i think it is increasing

00:45:13,680 --> 00:45:17,440
maybe not exponentially but with it

00:45:15,839 --> 00:45:18,160
could i think it is exponentially it's

00:45:17,440 --> 00:45:22,240
with some

00:45:18,160 --> 00:45:24,079
kind of curve upwards um python

00:45:22,240 --> 00:45:26,000
is kind of jumping around a bit and

00:45:24,079 --> 00:45:29,119
increasing a little bit

00:45:26,000 --> 00:45:31,520
but not really again it's

00:45:29,119 --> 00:45:33,760
holding pretty steady down there low

00:45:31,520 --> 00:45:35,040
because of some internal optimizations

00:45:33,760 --> 00:45:38,160
that it's doing

00:45:35,040 --> 00:45:40,800
um and our fully optimized and compiled

00:45:38,160 --> 00:45:41,680
our perl code is hugging the bottom

00:45:40,800 --> 00:45:44,240
where it should be

00:45:41,680 --> 00:45:46,000
you can't get any lower than that we are

00:45:44,240 --> 00:45:48,960
as fast as you can get

00:45:46,000 --> 00:45:51,200
it's just that we were you have to do

00:45:48,960 --> 00:45:52,720
that extra step of manually compiling

00:45:51,200 --> 00:45:55,520
the code instead of

00:45:52,720 --> 00:45:57,040
python which again apparently does it

00:45:55,520 --> 00:45:59,440
automatically

00:45:57,040 --> 00:46:00,640
good for them this is another situation

00:45:59,440 --> 00:46:03,280
where we're gonna have to copy

00:46:00,640 --> 00:46:04,880
their homework because they're beating

00:46:03,280 --> 00:46:08,000
the pants off of us

00:46:04,880 --> 00:46:11,440
another graph just one more um

00:46:08,000 --> 00:46:14,560
this is the speeds remember the it's not

00:46:11,440 --> 00:46:17,839
it's kind of the opposite of the

00:46:14,560 --> 00:46:19,200
um run time

00:46:17,839 --> 00:46:21,280
the lower the run time the higher the

00:46:19,200 --> 00:46:25,040
speed right so

00:46:21,280 --> 00:46:28,720
you can see that uh our parol and

00:46:25,040 --> 00:46:30,880
um python uh

00:46:28,720 --> 00:46:33,119
are jumping around a little bit on their

00:46:30,880 --> 00:46:35,820
speeds this is

00:46:33,119 --> 00:46:37,280
i guess because um

00:46:35,820 --> 00:46:41,760
[Music]

00:46:37,280 --> 00:46:44,319
the their the operating system is is

00:46:41,760 --> 00:46:44,800
fluctuating just enough to to show up

00:46:44,319 --> 00:46:48,000
here

00:46:44,800 --> 00:46:51,280
but if we average these out it's

00:46:48,000 --> 00:46:51,920
it's a pretty straight line the average

00:46:51,280 --> 00:46:53,280
is

00:46:51,920 --> 00:46:56,319
right even though they seem to jump

00:46:53,280 --> 00:46:59,359
around a bit and uh pearl

00:46:56,319 --> 00:47:00,640
is an incredibly smooth line with an

00:46:59,359 --> 00:47:03,680
incredibly

00:47:00,640 --> 00:47:05,520
low speed in fact it's

00:47:03,680 --> 00:47:07,280
it's almost at the bottom it's so low

00:47:05,520 --> 00:47:09,440
because of these uh

00:47:07,280 --> 00:47:11,280
scientific notations of the speed here i

00:47:09,440 --> 00:47:14,800
should have normalized it somehow but

00:47:11,280 --> 00:47:18,160
the point is pearl is like so slow it's

00:47:14,800 --> 00:47:22,000
not even not even competing

00:47:18,160 --> 00:47:24,960
not even competitive thank goodness

00:47:22,000 --> 00:47:27,200
for the pearl compiler next slide coming

00:47:24,960 --> 00:47:30,240
up grades i've got three minutes

00:47:27,200 --> 00:47:31,599
two and a half minutes um we need to

00:47:30,240 --> 00:47:33,280
implement maybe some more distance

00:47:31,599 --> 00:47:35,680
functions i guess

00:47:33,280 --> 00:47:38,240
for more generic cases um other

00:47:35,680 --> 00:47:40,400
classification algorithms start getting

00:47:38,240 --> 00:47:43,280
some regression algorithms in there

00:47:40,400 --> 00:47:45,200
part of the data type overhaul that

00:47:43,280 --> 00:47:49,599
we're currently in the process of

00:47:45,200 --> 00:47:52,640
for the perl compiler is um to add

00:47:49,599 --> 00:47:54,000
c plus template support that allows us

00:47:52,640 --> 00:47:56,559
some really powerful

00:47:54,000 --> 00:47:58,240
multi-dimensional data structure stuff

00:47:56,559 --> 00:48:02,000
which is kind of key to

00:47:58,240 --> 00:48:03,599
um a lot of machine learning because

00:48:02,000 --> 00:48:05,200
data points rarely are only

00:48:03,599 --> 00:48:06,079
two-dimensional even three-dimensional

00:48:05,200 --> 00:48:07,839
you have

00:48:06,079 --> 00:48:09,440
n dimensional data points and you have

00:48:07,839 --> 00:48:11,839
to be able to do

00:48:09,440 --> 00:48:12,480
nearest neighbors and lots of other

00:48:11,839 --> 00:48:14,480
learning

00:48:12,480 --> 00:48:17,200
algorithms using n-dimensional data

00:48:14,480 --> 00:48:19,280
arbitrary dimensional data

00:48:17,200 --> 00:48:20,720
also we need to do super unsupervised

00:48:19,280 --> 00:48:23,200
reinforcement all that stuff

00:48:20,720 --> 00:48:23,920
i have done one tiny little piece of

00:48:23,200 --> 00:48:28,000
work to

00:48:23,920 --> 00:48:31,920
show that k-nearest neighbors can

00:48:28,000 --> 00:48:33,440
win against python um

00:48:31,920 --> 00:48:35,599
but i i need your help if you're

00:48:33,440 --> 00:48:38,800
watching this i really hope

00:48:35,599 --> 00:48:42,480
that you will consider um

00:48:38,800 --> 00:48:43,119
actually trying to to to contribute in

00:48:42,480 --> 00:48:45,920
some way

00:48:43,119 --> 00:48:47,200
please i need your help and don't be

00:48:45,920 --> 00:48:49,520
surprised if the machine

00:48:47,200 --> 00:48:51,440
actually starts learning at some point

00:48:49,520 --> 00:48:54,640
like the surprise pikachu here

00:48:51,440 --> 00:48:58,079
um the lady yelling at the cat

00:48:54,640 --> 00:49:01,200
or dog thank you so much

00:48:58,079 --> 00:49:04,240
um to my friends al ivan and tommy

00:49:01,200 --> 00:49:06,319
um who helped me get oriented and work

00:49:04,240 --> 00:49:08,400
on some of the original

00:49:06,319 --> 00:49:09,359
knn algorithms you should probably check

00:49:08,400 --> 00:49:12,960
out these um

00:49:09,359 --> 00:49:14,800
websites procommunity.org rpel.org

00:49:12,960 --> 00:49:16,079
thank you thank you so much if you're

00:49:14,800 --> 00:49:19,440
watching this

00:49:16,079 --> 00:49:21,280
for supporting our work on patreon.com

00:49:19,440 --> 00:49:23,040
r pro that goes towards mo pearl the

00:49:21,280 --> 00:49:24,960
compiler all the other

00:49:23,040 --> 00:49:26,559
pro projects that we're working on also

00:49:24,960 --> 00:49:27,599
if you want to run this please use this

00:49:26,559 --> 00:49:29,920
docker command

00:49:27,599 --> 00:49:30,720
at the bottom and then just inside of

00:49:29,920 --> 00:49:32,720
the docker run

00:49:30,720 --> 00:49:33,920
cpan ml perl and it will install the

00:49:32,720 --> 00:49:37,440
code for you

00:49:33,920 --> 00:49:40,319
um and uh oh yeah

00:49:37,440 --> 00:49:42,240
uh tomorrow friday is our town pearl

00:49:40,319 --> 00:49:43,440
town hall day please check us out on the

00:49:42,240 --> 00:49:45,760
facebook.com

00:49:43,440 --> 00:49:46,960
groups pro programmers we will be going

00:49:45,760 --> 00:49:50,559
live about

00:49:46,960 --> 00:49:53,520
three o'clock ish tomorrow uh texas time

00:49:50,559 --> 00:49:54,319
for our recap of day three an overall

00:49:53,520 --> 00:49:57,440
overview

00:49:54,319 --> 00:49:59,599
of the pearl conference 2021

00:49:57,440 --> 00:50:00,480
so i've run out of time thank you so

00:49:59,599 --> 00:50:03,520
much uh

00:50:00,480 --> 00:50:06,240
let's not allow python

00:50:03,520 --> 00:50:07,920
to remain the sword with us as the fork

00:50:06,240 --> 00:50:09,040
let's try and swap this around we're

00:50:07,920 --> 00:50:11,040
gonna have to

00:50:09,040 --> 00:50:12,720
implement a whole bunch of stuff from

00:50:11,040 --> 00:50:15,680
scratch but

00:50:12,720 --> 00:50:16,480
since when have we let that stop us

00:50:15,680 --> 00:50:19,839
until then

00:50:16,480 --> 00:50:22,079
i am again your fearless leader

00:50:19,839 --> 00:50:23,599
of austin texas pro mongers will the

00:50:22,079 --> 00:50:26,640
chill signing off thank you all for

00:50:23,599 --> 00:50:26,640

YouTube URL: https://www.youtube.com/watch?v=i3aY9-ns0PM


