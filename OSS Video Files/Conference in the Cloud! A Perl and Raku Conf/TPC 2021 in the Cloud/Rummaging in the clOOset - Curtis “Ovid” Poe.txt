Title: Rummaging in the clOOset - Curtis “Ovid” Poe
Publication date: 2021-06-10
Playlist: TPC 2021 in the Cloud
Description: 
	With all of the talk about bringing modern-OO to the Perl core, you might wonder what "modern" is.

This is not an easy thing to answer, but we'll talk about the history of OO, ways to think about OO today, why Dr. Alan Kay is brilliant, and explore OO in other languages.

Object-oriented programming is, sadly, something that is widely misunderstood. When done well, it's brilliant. When done poorly, it leads to rants by developers about why OO is useless and we should all use [insert favorite paradigm here] programming.

Sadly, this talk won't be covering much about doing OO well for the simple reason that there's too much to cover and I have to cut _something_. But we'll hit some of the high points. What we _plan_ to cover is:

* A Brief History of OO
* Why Dr. Alan Kay hates us all
* How OO is used today
* How other languages approach OO

Examples for Perl will often use [Corinna](https://github.com/Ovid/Cor/wiki) syntax, while examples from other languages are often NSFW and may cause gastrointestinal distress. At a minimum, for comparisons, we'll touch on Ruby, BETA, Python, and maybe Java. All of these languages have interesting features that are worth considering.

(And you in the back, shut up about Eiffel already; I only have 50 minutes)
Captions: 
	00:00:00,000 --> 00:00:06,399
tobacco took out

00:00:03,040 --> 00:00:08,480
both the fiber and the copper going into

00:00:06,399 --> 00:00:10,559
my employer's building

00:00:08,480 --> 00:00:12,080
and they decided i guess to save time

00:00:10,559 --> 00:00:15,200
just to run both

00:00:12,080 --> 00:00:16,720
cables through the same conduit

00:00:15,200 --> 00:00:18,240
but the cables were different companies

00:00:16,720 --> 00:00:21,439
right

00:00:18,240 --> 00:00:23,119
uh yeah who knows but they were the same

00:00:21,439 --> 00:00:24,800
they were in physical location and

00:00:23,119 --> 00:00:28,840
that's kind of not

00:00:24,800 --> 00:00:31,840
the point the whole point is you have of

00:00:28,840 --> 00:00:31,840
course

00:00:35,280 --> 00:00:43,120
okay folks it's five o'clock

00:00:39,360 --> 00:00:46,879
it's actually a couple months after um

00:00:43,120 --> 00:00:46,879
is everything good to go right now

00:00:47,600 --> 00:00:53,840
okay so i'll go ahead and get started um

00:00:51,680 --> 00:00:55,520
i just had to go off script a little bit

00:00:53,840 --> 00:00:56,640
in this talk because there was so much

00:00:55,520 --> 00:00:58,719
interesting trivia

00:00:56,640 --> 00:01:00,320
that i was pulling out that i'm not

00:00:58,719 --> 00:01:01,199
going to stick entirely to exactly what

00:01:00,320 --> 00:01:03,840
i had

00:01:01,199 --> 00:01:04,239
in the description but uh rummaging

00:01:03,840 --> 00:01:08,479
around

00:01:04,239 --> 00:01:10,159
in a losing closet if you will

00:01:08,479 --> 00:01:11,760
um i decided i was just going to pick

00:01:10,159 --> 00:01:13,600
out a number of interesting things

00:01:11,760 --> 00:01:15,119
i found various different

00:01:13,600 --> 00:01:17,520
object-oriented systems

00:01:15,119 --> 00:01:20,400
uh some things which someone is typing

00:01:17,520 --> 00:01:20,400
can you mute yourself

00:01:21,680 --> 00:01:25,439
thank you and just pulling out various

00:01:24,400 --> 00:01:26,080
interesting things from different

00:01:25,439 --> 00:01:28,640
object-oriented

00:01:26,080 --> 00:01:28,640
systems and

00:01:29,200 --> 00:01:32,720
we talked about korean much though i'll

00:01:31,119 --> 00:01:33,200
mention that a little bit towards the

00:01:32,720 --> 00:01:35,360
end

00:01:33,200 --> 00:01:37,920
this is more a talk on interesting

00:01:35,360 --> 00:01:37,920
approaches

00:01:38,840 --> 00:01:43,200
um

00:01:40,560 --> 00:01:45,680
so most of you you already know uh

00:01:43,200 --> 00:01:45,680
kirkpope

00:01:47,360 --> 00:01:54,079
um and there's my twitter uh my email

00:01:51,200 --> 00:01:54,079
this is slide

00:01:54,320 --> 00:01:57,680
so you can go ahead and check that out

00:01:55,840 --> 00:01:59,119
later if you need to

00:01:57,680 --> 00:02:01,360
and this is just going to be it's going

00:01:59,119 --> 00:02:04,640
to be nice it's going to be

00:02:01,360 --> 00:02:06,240
there's talk actually it's just

00:02:04,640 --> 00:02:08,000
some fun stuff that i picked out of

00:02:06,240 --> 00:02:11,200
different oo systems that i thought some

00:02:08,000 --> 00:02:14,239
of you might find very interesting

00:02:11,200 --> 00:02:17,440
and i'll start with simula 67.

00:02:14,239 --> 00:02:20,560
this was in 1967

00:02:17,440 --> 00:02:22,800
over 50 years first

00:02:20,560 --> 00:02:23,760
modern oho programming language and they

00:02:22,800 --> 00:02:25,599
produce

00:02:23,760 --> 00:02:27,920
the most modern concepts that we agree

00:02:25,599 --> 00:02:30,800
with rectangle class

00:02:27,920 --> 00:02:33,519
we can kind of make out what it does uh

00:02:30,800 --> 00:02:33,519
mostly um

00:02:34,840 --> 00:02:41,680
straightforward hey um

00:02:39,599 --> 00:02:43,280
the sound is very choppy for multiple

00:02:41,680 --> 00:02:44,319
people i think if you talk a little more

00:02:43,280 --> 00:02:47,200
slowly

00:02:44,319 --> 00:02:47,920
we'll be able to follow the chops better

00:02:47,200 --> 00:02:51,040
actually

00:02:47,920 --> 00:02:54,239
maybe also turn off your camera

00:02:51,040 --> 00:02:56,080
mine yeah that might be using more of

00:02:54,239 --> 00:02:59,840
your bandwidth

00:02:56,080 --> 00:03:03,599
okay do i sound clearer right now

00:02:59,840 --> 00:03:05,680
so far okay

00:03:03,599 --> 00:03:06,800
okay i hope that works because talking

00:03:05,680 --> 00:03:08,000
slowly might be

00:03:06,800 --> 00:03:10,400
a little problem i've got a lot of

00:03:08,000 --> 00:03:11,280
slides so i'll just try and go through

00:03:10,400 --> 00:03:14,000
here

00:03:11,280 --> 00:03:14,000
are you still there

00:03:15,280 --> 00:03:21,519
yeah yep okay good okay so simple

00:03:18,879 --> 00:03:22,400
67 introduced classes polymorphism

00:03:21,519 --> 00:03:25,840
encapsulation

00:03:22,400 --> 00:03:28,239
inheritance uh modern class-based

00:03:25,840 --> 00:03:29,200
uh inheritance is tricky but we'll get

00:03:28,239 --> 00:03:30,480
to that later

00:03:29,200 --> 00:03:31,680
uh the rest of that's pretty pretty

00:03:30,480 --> 00:03:33,040
standard but i want to talk about small

00:03:31,680 --> 00:03:35,519
talk because small talk

00:03:33,040 --> 00:03:36,640
is kind of a fun language i'm not going

00:03:35,519 --> 00:03:39,200
to go deep into it

00:03:36,640 --> 00:03:40,879
at all because it's just trivia but i

00:03:39,200 --> 00:03:42,640
love this quote from allen k

00:03:40,879 --> 00:03:44,720
making simple things very simple and

00:03:42,640 --> 00:03:47,120
complex things very possible that

00:03:44,720 --> 00:03:48,640
probably sounds similar to a quote some

00:03:47,120 --> 00:03:50,159
of you may have heard

00:03:48,640 --> 00:03:52,400
i particularly liked the quote because

00:03:50,159 --> 00:03:52,799
down at the bottom this was reported by

00:03:52,400 --> 00:03:56,080
dr

00:03:52,799 --> 00:03:57,920
stefan ducasse and if you if that name

00:03:56,080 --> 00:03:59,680
sounds familiar to any of you

00:03:57,920 --> 00:04:00,959
he's one of the researchers who came up

00:03:59,680 --> 00:04:03,200
with uh the

00:04:00,959 --> 00:04:04,159
traits paper that we've built our roles

00:04:03,200 --> 00:04:06,560
on top of

00:04:04,159 --> 00:04:08,640
uh i've emailed with him before he's

00:04:06,560 --> 00:04:12,319
they they're doing great work

00:04:08,640 --> 00:04:15,200
it's fun digging into this so this

00:04:12,319 --> 00:04:15,680
with the exception of primitives this

00:04:15,200 --> 00:04:19,440
small

00:04:15,680 --> 00:04:22,240
method in small talk has every

00:04:19,440 --> 00:04:23,919
syntax that small talk presents that is

00:04:22,240 --> 00:04:26,840
how simple the stacks for small

00:04:23,919 --> 00:04:28,560
talk is which i i think is absolutely

00:04:26,840 --> 00:04:30,080
marvelous

00:04:28,560 --> 00:04:32,400
uh that function doesn't actually do

00:04:30,080 --> 00:04:34,479
anything uh for small talk 80 it had six

00:04:32,400 --> 00:04:35,680
keywords true false no self super this

00:04:34,479 --> 00:04:39,040
that's

00:04:35,680 --> 00:04:42,479
that is all that is how simple and pure

00:04:39,040 --> 00:04:44,960
a language can be just very fascinating

00:04:42,479 --> 00:04:45,759
and you might wonder like where's the if

00:04:44,960 --> 00:04:47,199
else

00:04:45,759 --> 00:04:49,280
you've heard small talk everything's an

00:04:47,199 --> 00:04:51,040
object oh by the way

00:04:49,280 --> 00:04:52,320
here's defined in terms of lists they've

00:04:51,040 --> 00:04:53,840
also done a great job

00:04:52,320 --> 00:04:57,360
of simplicity and being able to

00:04:53,840 --> 00:05:00,479
bootstrap yourself is really nice but

00:04:57,360 --> 00:05:02,560
so small talk this is one of my

00:05:00,479 --> 00:05:04,320
one of my first big epiphanies about oh

00:05:02,560 --> 00:05:07,600
programming

00:05:04,320 --> 00:05:10,320
white x are rather problematic

00:05:07,600 --> 00:05:10,800
we have a result and if a is greater

00:05:10,320 --> 00:05:13,120
than b

00:05:10,800 --> 00:05:14,479
we have well there's if true and false

00:05:13,120 --> 00:05:17,520
so we do something like

00:05:14,479 --> 00:05:18,880
else no a is an object and it's getting

00:05:17,520 --> 00:05:22,840
past the greater than

00:05:18,880 --> 00:05:26,080
and b and if true and false are

00:05:22,840 --> 00:05:26,880
methods and if a resolves is greater

00:05:26,080 --> 00:05:28,880
than b

00:05:26,880 --> 00:05:30,400
it's going to help the if true they

00:05:28,880 --> 00:05:33,600
provoke the

00:05:30,400 --> 00:05:35,360
default actually a greater than b that's

00:05:33,600 --> 00:05:37,120
going to return a boolean object

00:05:35,360 --> 00:05:38,560
and it might have true belief or false

00:05:37,120 --> 00:05:40,400
belief and both those

00:05:38,560 --> 00:05:42,000
call and one of them might just do

00:05:40,400 --> 00:05:46,560
nothing the other one might

00:05:42,000 --> 00:05:49,680
invoke that code that results

00:05:46,560 --> 00:05:51,360
if this was pearl using karina syntax it

00:05:49,680 --> 00:05:53,759
would look like this we'd have

00:05:51,360 --> 00:05:53,759
belief

00:05:56,240 --> 00:06:04,560
they do nothing whereas our true class

00:06:01,039 --> 00:06:06,880
true code will invoke class

00:06:04,560 --> 00:06:08,400
if false code then will affect code

00:06:06,880 --> 00:06:12,000
block

00:06:08,400 --> 00:06:13,600
and the other on fire

00:06:12,000 --> 00:06:15,199
which is kind of an interesting way of

00:06:13,600 --> 00:06:16,720
looking at how this works

00:06:15,199 --> 00:06:20,240
so can you folks still hear me because i

00:06:16,720 --> 00:06:22,479
can see you right now this is

00:06:20,240 --> 00:06:24,240
you are still cutting in and out a fair

00:06:22,479 --> 00:06:27,360
bit

00:06:24,240 --> 00:06:27,360
are you able to follow

00:06:28,160 --> 00:06:36,080
yes it's it's

00:06:32,840 --> 00:06:38,160
difficult mostly

00:06:36,080 --> 00:06:40,319
i have fiber on my side so i thought i

00:06:38,160 --> 00:06:43,520
should be doing fine

00:06:40,319 --> 00:06:45,440
but i'll i'll keep going actually

00:06:43,520 --> 00:06:49,840
we're suspecting that the problem is

00:06:45,440 --> 00:06:49,840
under the atlantic

00:06:53,440 --> 00:06:58,000
when i got bored of writing slides i i

00:06:55,120 --> 00:06:58,000
had fun with this uh

00:06:58,400 --> 00:07:01,680
it's both true and false until you look

00:07:00,479 --> 00:07:02,000
at it in which case it resolves to

00:07:01,680 --> 00:07:04,800
either

00:07:02,000 --> 00:07:05,280
true or false it stays on it thumbs up

00:07:04,800 --> 00:07:08,160
just

00:07:05,280 --> 00:07:09,120
be playing with interesting ways of

00:07:08,160 --> 00:07:13,199
playing with code

00:07:09,120 --> 00:07:13,199
but inheritance that that stuff

00:07:15,280 --> 00:07:18,479
so inheritance we understand how this

00:07:16,960 --> 00:07:21,360
works class customer

00:07:18,479 --> 00:07:23,120
is a person and what this means is a

00:07:21,360 --> 00:07:24,960
subclass should be a more specialized

00:07:23,120 --> 00:07:31,440
version of the parent class

00:07:24,960 --> 00:07:34,880
uh mammal is an animal cat is a mammal

00:07:31,440 --> 00:07:35,919
which is interesting um so liskov we've

00:07:34,880 --> 00:07:38,240
we've heard about the let's go

00:07:35,919 --> 00:07:39,759
substitution principle let phi of x be a

00:07:38,240 --> 00:07:41,199
property blah blah blah no one

00:07:39,759 --> 00:07:44,080
understands what that means

00:07:41,199 --> 00:07:45,520
even though she wanted a word for this

00:07:44,080 --> 00:07:46,080
what it means is any place you have a

00:07:45,520 --> 00:07:47,840
class

00:07:46,080 --> 00:07:49,360
if you have a subclass in that class you

00:07:47,840 --> 00:07:50,800
should be able to use subclass

00:07:49,360 --> 00:07:52,720
in place of the parent and your code

00:07:50,800 --> 00:07:55,039
should work just fine

00:07:52,720 --> 00:07:56,800
that's all it's an important thing the

00:07:55,039 --> 00:07:57,120
real world doesn't actually work that

00:07:56,800 --> 00:07:59,759
way

00:07:57,120 --> 00:08:00,960
so for example our mammal plant you

00:07:59,759 --> 00:08:02,960
might say well mammal

00:08:00,960 --> 00:08:04,400
spare live young that's one of the

00:08:02,960 --> 00:08:05,520
things you have in your mammal class but

00:08:04,400 --> 00:08:07,440
platypuses are

00:08:05,520 --> 00:08:08,639
mammals aren't they yes but they don't

00:08:07,440 --> 00:08:10,800
bear like young

00:08:08,639 --> 00:08:12,240
so it doesn't always work this way in

00:08:10,800 --> 00:08:14,960
the real world

00:08:12,240 --> 00:08:16,240
trying to model classes against real

00:08:14,960 --> 00:08:20,080
world stuff

00:08:16,240 --> 00:08:22,400
okay it's mostly a good idea

00:08:20,080 --> 00:08:24,240
and what this means is if a customer is

00:08:22,400 --> 00:08:26,800
a person if this works

00:08:24,240 --> 00:08:28,479
person age years greater than voting age

00:08:26,800 --> 00:08:30,080
the following must work customer age

00:08:28,479 --> 00:08:31,680
years greater than voting age

00:08:30,080 --> 00:08:33,839
you should always be able to drop a

00:08:31,680 --> 00:08:36,399
subclass in where your parent class

00:08:33,839 --> 00:08:36,880
is and have things magically work it

00:08:36,399 --> 00:08:40,080
really

00:08:36,880 --> 00:08:42,399
simplifies a lot of capability

00:08:40,080 --> 00:08:43,760
but the real comparatives this is

00:08:42,399 --> 00:08:46,720
something um

00:08:43,760 --> 00:08:47,839
so allen k he initially thought that uh

00:08:46,720 --> 00:08:50,320
inheritance was great

00:08:47,839 --> 00:08:52,080
by the way he's he's not some grumpy old

00:08:50,320 --> 00:08:54,160
guy who just graduated from the rails

00:08:52,080 --> 00:08:56,640
boot camp he invented the term

00:08:54,160 --> 00:08:57,839
object-oriented program he's brilliant

00:08:56,640 --> 00:08:59,440
but he was thinking about biological

00:08:57,839 --> 00:09:00,560
systems of cells in our bodies for

00:08:59,440 --> 00:09:03,200
example

00:09:00,560 --> 00:09:04,880
and when he thought inheritance first he

00:09:03,200 --> 00:09:08,880
saw the actual problem

00:09:04,880 --> 00:09:11,920
class invoice is a person

00:09:08,880 --> 00:09:14,080
um what does that mean this doesn't make

00:09:11,920 --> 00:09:16,080
any sense this is not a specialized

00:09:14,080 --> 00:09:17,360
thing a more specialized thing but we

00:09:16,080 --> 00:09:19,279
can't prevent that

00:09:17,360 --> 00:09:20,880
not without say artificial general

00:09:19,279 --> 00:09:22,240
intelligence and even that might not be

00:09:20,880 --> 00:09:22,959
able to do it because humans have

00:09:22,240 --> 00:09:24,560
trouble

00:09:22,959 --> 00:09:27,839
sometimes figuring out what's an

00:09:24,560 --> 00:09:30,320
appropriate subclass so inheritance is

00:09:27,839 --> 00:09:32,399
it's it's not a great modeling tool for

00:09:30,320 --> 00:09:34,560
many reasons

00:09:32,399 --> 00:09:36,000
software doesn't understand the intent

00:09:34,560 --> 00:09:37,360
of what you're doing so you can't really

00:09:36,000 --> 00:09:41,120
enforce it

00:09:37,360 --> 00:09:43,760
um design by contract sort of helps

00:09:41,120 --> 00:09:45,200
so i won't go into this basically you

00:09:43,760 --> 00:09:46,560
assign a contract for your class and

00:09:45,200 --> 00:09:48,560
your subclasses aren't allowed to

00:09:46,560 --> 00:09:50,959
violate the contract

00:09:48,560 --> 00:09:52,399
this is built directly into eiffel so

00:09:50,959 --> 00:09:53,120
this is an example from the eiffel

00:09:52,399 --> 00:09:55,920
language

00:09:53,120 --> 00:09:56,399
where we need to be able to put an item

00:09:55,920 --> 00:10:00,000
into

00:09:56,399 --> 00:10:01,200
a into a like a dictionary and we

00:10:00,000 --> 00:10:03,040
require that

00:10:01,200 --> 00:10:04,480
that has capacity and then we actually

00:10:03,040 --> 00:10:05,279
have a key that we're going to store it

00:10:04,480 --> 00:10:06,959
with

00:10:05,279 --> 00:10:08,720
uh that we have our insertion algorithm

00:10:06,959 --> 00:10:10,480
and then we ensure afterwards

00:10:08,720 --> 00:10:12,240
we actually have the item that we

00:10:10,480 --> 00:10:14,720
inserted that the

00:10:12,240 --> 00:10:16,399
key actually the item for the key match

00:10:14,720 --> 00:10:18,480
basically this is designed by contract

00:10:16,399 --> 00:10:20,480
you create a subclass with this thing

00:10:18,480 --> 00:10:23,040
it has to respect this it's not allowed

00:10:20,480 --> 00:10:23,040
to violate it

00:10:23,519 --> 00:10:26,720
you can actually do design by contract

00:10:25,360 --> 00:10:28,720
in perl here's uh

00:10:26,720 --> 00:10:30,560
one example using class contract there's

00:10:28,720 --> 00:10:32,160
actually quite a number of cpan modules

00:10:30,560 --> 00:10:33,440
out there which do this but uh most

00:10:32,160 --> 00:10:35,360
people just they don't bother

00:10:33,440 --> 00:10:36,560
they find it painful designed by

00:10:35,360 --> 00:10:38,320
contract is not something we're

00:10:36,560 --> 00:10:40,399
proposing for creative by the way

00:10:38,320 --> 00:10:41,920
it's just one of the many ways of trying

00:10:40,399 --> 00:10:45,200
to solve some of these problems

00:10:41,920 --> 00:10:46,800
we have that people are looking at

00:10:45,200 --> 00:10:49,680
but this this is one of my favorite

00:10:46,800 --> 00:10:51,600
examples because this really

00:10:49,680 --> 00:10:54,320
hurts people's minds sometimes this is

00:10:51,600 --> 00:10:57,440
the beta programming language

00:10:54,320 --> 00:11:00,480
in beta you don't have classes and

00:10:57,440 --> 00:11:03,920
methods you have patterns

00:11:00,480 --> 00:11:06,240
and so you have that employee colon

00:11:03,920 --> 00:11:08,079
open paren hash that's starting a

00:11:06,240 --> 00:11:10,640
pattern

00:11:08,079 --> 00:11:11,279
but register work that's that looks like

00:11:10,640 --> 00:11:13,040
a method

00:11:11,279 --> 00:11:14,480
but that's also a pattern and in b the

00:11:13,040 --> 00:11:16,640
classes and patterns there's not really

00:11:14,480 --> 00:11:19,760
a distinction between the two

00:11:16,640 --> 00:11:21,519
they've managed to unify them if you

00:11:19,760 --> 00:11:23,360
look at compute salary

00:11:21,519 --> 00:11:25,120
you've got that less than symbol after

00:11:23,360 --> 00:11:25,440
the colon that looks a little odd and

00:11:25,120 --> 00:11:28,399
then

00:11:25,440 --> 00:11:30,560
do enter what's going on with that well

00:11:28,399 --> 00:11:33,519
here we have sub patterns

00:11:30,560 --> 00:11:34,399
of our employee we could say subclasses

00:11:33,519 --> 00:11:36,399
worker is an

00:11:34,399 --> 00:11:37,760
employee sales person is an employee and

00:11:36,399 --> 00:11:39,200
both of those have compute salary

00:11:37,760 --> 00:11:42,720
methods

00:11:39,200 --> 00:11:43,279
what happens in beta is you have your

00:11:42,720 --> 00:11:46,320
employee

00:11:43,279 --> 00:11:47,600
test compute salary it defines salary as

00:11:46,320 --> 00:11:50,480
being an integer

00:11:47,600 --> 00:11:52,079
you call do enter if you call the

00:11:50,480 --> 00:11:54,720
compute salary method

00:11:52,079 --> 00:11:56,240
on your on your salesperson class you

00:11:54,720 --> 00:11:57,360
don't get the sales person compute

00:11:56,240 --> 00:11:59,279
salary method

00:11:57,360 --> 00:12:01,519
you get the employee compute salary

00:11:59,279 --> 00:12:02,160
method and that is responsible for

00:12:01,519 --> 00:12:05,600
calling

00:12:02,160 --> 00:12:07,920
the inner method the sub patterns

00:12:05,600 --> 00:12:10,000
virtual method if you will of compute

00:12:07,920 --> 00:12:11,440
salary and then when it returns it it

00:12:10,000 --> 00:12:13,440
can do a lot of checks to make sure this

00:12:11,440 --> 00:12:16,079
is valid so this is another

00:12:13,440 --> 00:12:17,040
way of programmatic enforcement of

00:12:16,079 --> 00:12:19,360
liscom

00:12:17,040 --> 00:12:20,639
your subclasses cannot violate what

00:12:19,360 --> 00:12:22,800
their parent classes do

00:12:20,639 --> 00:12:26,639
because the parent classes are the ones

00:12:22,800 --> 00:12:26,639
calling the shots not the sunglasses

00:12:26,720 --> 00:12:30,160
this kind of hurts people's head

00:12:29,200 --> 00:12:32,720
sometimes

00:12:30,160 --> 00:12:34,079
but you you may find this vaguely

00:12:32,720 --> 00:12:35,040
familiar because this is actually a

00:12:34,079 --> 00:12:37,920
pearl

00:12:35,040 --> 00:12:40,000
specifically moose you can have your

00:12:37,920 --> 00:12:42,320
package employee compute salary

00:12:40,000 --> 00:12:44,880
you can call inner and your salesman

00:12:42,320 --> 00:12:47,120
class you have augment compute salary

00:12:44,880 --> 00:12:48,800
and you can do the same thing in boost

00:12:47,120 --> 00:12:49,920
if you want to and i i thought about

00:12:48,800 --> 00:12:52,079
this but this is also

00:12:49,920 --> 00:12:53,839
not being proposed for karina but it's

00:12:52,079 --> 00:12:57,519
another interesting way of approaching

00:12:53,839 --> 00:12:57,519
this problem which i really appreciate

00:12:58,880 --> 00:13:04,320
so getting back to inheritance uh

00:13:01,839 --> 00:13:05,760
multiple inheritance single

00:13:04,320 --> 00:13:07,519
single single inheritance i don't know

00:13:05,760 --> 00:13:09,040
why i typed that we got composition and

00:13:07,519 --> 00:13:10,959
delegation to work around it

00:13:09,040 --> 00:13:12,480
interfaces mix-ins whatever the vita

00:13:10,959 --> 00:13:13,360
designers were thinking when they wrote

00:13:12,480 --> 00:13:15,360
their stuff

00:13:13,360 --> 00:13:16,720
it gets complicated trying to figure out

00:13:15,360 --> 00:13:19,440
how to share

00:13:16,720 --> 00:13:20,959
this behavior and i want to talk about

00:13:19,440 --> 00:13:23,200
mixes

00:13:20,959 --> 00:13:24,720
so here this is the ruby version of

00:13:23,200 --> 00:13:27,760
mixes they originally came from

00:13:24,720 --> 00:13:29,360
a variant list called flavors but for

00:13:27,760 --> 00:13:32,160
ruby we're more familiar with that

00:13:29,360 --> 00:13:32,880
we have these are two mixes module bomb

00:13:32,160 --> 00:13:35,920
and module

00:13:32,880 --> 00:13:36,399
toddler imagine you want a practical

00:13:35,920 --> 00:13:38,320
joke

00:13:36,399 --> 00:13:40,880
class you're writing a game a practical

00:13:38,320 --> 00:13:42,720
joke you want to have the bomb fuse

00:13:40,880 --> 00:13:44,800
because you can control the timing but

00:13:42,720 --> 00:13:46,240
you want to have the toddler explode

00:13:44,800 --> 00:13:48,480
behavior because it doesn't actually

00:13:46,240 --> 00:13:51,440
kill the person so

00:13:48,480 --> 00:13:53,040
you include or mix in your toddler and

00:13:51,440 --> 00:13:56,160
your bomb

00:13:53,040 --> 00:13:57,120
but you only get the when you call fuse

00:13:56,160 --> 00:13:58,800
and explode

00:13:57,120 --> 00:14:00,839
you get the bomb fuse and the bomb

00:13:58,800 --> 00:14:04,160
explode what's happening

00:14:00,839 --> 00:14:05,839
is if this is multiple inheritance

00:14:04,160 --> 00:14:07,199
generally speaking the first class you

00:14:05,839 --> 00:14:09,839
would hear it from would win

00:14:07,199 --> 00:14:10,800
with mix-ins the last class you inherit

00:14:09,839 --> 00:14:12,560
from links

00:14:10,800 --> 00:14:15,279
you still have ordering problems you can

00:14:12,560 --> 00:14:17,120
now sort this list of mixins

00:14:15,279 --> 00:14:19,199
uh in alphabetical order and have bomb

00:14:17,120 --> 00:14:20,399
before toddler and your code will break

00:14:19,199 --> 00:14:22,800
because it will exhibit different

00:14:20,399 --> 00:14:22,800
behavior

00:14:23,839 --> 00:14:29,279
and if you're wondering why it does that

00:14:27,040 --> 00:14:30,800
if you go into the ruby rebel and you

00:14:29,279 --> 00:14:34,480
type ancestors

00:14:30,800 --> 00:14:36,480
joke you see bomb and toddler those are

00:14:34,480 --> 00:14:38,000
inserted into the single inheritance

00:14:36,480 --> 00:14:42,959
tree between practical joke

00:14:38,000 --> 00:14:46,639
and object it's just abusing inheritance

00:14:42,959 --> 00:14:48,880
it's abusing inheritance enough that

00:14:46,639 --> 00:14:51,040
you see things like this uh class car

00:14:48,880 --> 00:14:52,800
inherits the vehicle include robot

00:14:51,040 --> 00:14:54,240
you know what if vehicle and robot both

00:14:52,800 --> 00:14:58,320
have a driver method well

00:14:54,240 --> 00:15:00,320
robot driver wins not the car driver um

00:14:58,320 --> 00:15:01,760
and you know his roles have the same

00:15:00,320 --> 00:15:04,000
issue but is robot really a more

00:15:01,760 --> 00:15:05,920
specialized version of vehicle that

00:15:04,000 --> 00:15:09,600
it doesn't seem like a music inheritance

00:15:05,920 --> 00:15:09,600
this way really makes sense

00:15:10,839 --> 00:15:15,040
and you'll see on stack overflow in

00:15:14,320 --> 00:15:17,279
other places

00:15:15,040 --> 00:15:19,360
uh developers are asking i'm trying to

00:15:17,279 --> 00:15:21,440
call super inside of my mixin

00:15:19,360 --> 00:15:23,279
and it's not behaving correctly it's

00:15:21,440 --> 00:15:25,839
because mixins should not assume

00:15:23,279 --> 00:15:27,760
that they're being mixed into a

00:15:25,839 --> 00:15:29,600
particular thing

00:15:27,760 --> 00:15:31,680
and you can't guarantee that you have a

00:15:29,600 --> 00:15:32,399
parent class which raises an interesting

00:15:31,680 --> 00:15:35,360
question

00:15:32,399 --> 00:15:36,320
should we allow next method in roles

00:15:35,360 --> 00:15:38,639
because

00:15:36,320 --> 00:15:40,240
roles can't assume that the class that

00:15:38,639 --> 00:15:43,120
is being consumed in

00:15:40,240 --> 00:15:43,920
as a parent class we're not proposing

00:15:43,120 --> 00:15:47,040
outlines

00:15:43,920 --> 00:15:47,839
rules but it's an interesting thing to

00:15:47,040 --> 00:15:50,240
consider

00:15:47,839 --> 00:15:54,000
it is a problem and it does cause buggy

00:15:50,240 --> 00:15:55,279
codes sometimes

00:15:54,000 --> 00:15:56,880
which all gets down to computer

00:15:55,279 --> 00:15:57,680
scientists argue and computer

00:15:56,880 --> 00:16:00,240
programmers

00:15:57,680 --> 00:16:01,440
rant uh we we get upset about a lot of

00:16:00,240 --> 00:16:03,360
these things and what i hear

00:16:01,440 --> 00:16:05,279
when i talk about some of the frailties

00:16:03,360 --> 00:16:06,399
we have in the code that we write what i

00:16:05,279 --> 00:16:09,759
hear from people is

00:16:06,399 --> 00:16:12,160
yeah it mostly works it's easy to fix

00:16:09,759 --> 00:16:13,519
and the devs should know their code base

00:16:12,160 --> 00:16:16,240
it's that last one which

00:16:13,519 --> 00:16:17,600
i find very frustrating if you have a

00:16:16,240 --> 00:16:19,680
million line code base

00:16:17,600 --> 00:16:21,040
with 100 developers who are working on

00:16:19,680 --> 00:16:23,440
this constantly

00:16:21,040 --> 00:16:26,160
you don't know your code base you want

00:16:23,440 --> 00:16:27,759
your code base to protect you from you

00:16:26,160 --> 00:16:29,759
not you protecting the code base from

00:16:27,759 --> 00:16:33,120
itself because the language

00:16:29,759 --> 00:16:33,120
should know how to protect itself

00:16:33,759 --> 00:16:37,839
so getting back to allan k the human

00:16:35,839 --> 00:16:39,120
body is 40 trillion cells

00:16:37,839 --> 00:16:40,720
each of them you can think of those as

00:16:39,120 --> 00:16:42,800
an object they're sending messages to

00:16:40,720 --> 00:16:44,240
each other all the time

00:16:42,800 --> 00:16:45,920
and even when some of them failed still

00:16:44,240 --> 00:16:49,120
works marvelously it works

00:16:45,920 --> 00:16:50,880
brilliantly and

00:16:49,120 --> 00:16:53,360
the best example of an object-oriented

00:16:50,880 --> 00:16:56,720
system today

00:16:53,360 --> 00:16:59,360
is the web so perfect objects not my

00:16:56,720 --> 00:17:01,120
home page it's the browser when the

00:16:59,360 --> 00:17:02,480
browser is calling a web server it sends

00:17:01,120 --> 00:17:03,199
a message to it if the web server is not

00:17:02,480 --> 00:17:05,199
available

00:17:03,199 --> 00:17:07,679
or if your web server throws a 500 error

00:17:05,199 --> 00:17:09,600
your browser doesn't crash

00:17:07,679 --> 00:17:10,959
at least i hope it doesn't you have

00:17:09,600 --> 00:17:12,640
isolation

00:17:10,959 --> 00:17:15,039
everything is isolated we've got

00:17:12,640 --> 00:17:17,199
well-defined protocols which handle

00:17:15,039 --> 00:17:19,039
errors fairly well

00:17:17,199 --> 00:17:21,199
part of what makes it work is you as a

00:17:19,039 --> 00:17:22,959
human are driving this

00:17:21,199 --> 00:17:25,439
but this is one of the best examples of

00:17:22,959 --> 00:17:27,199
objects today but i can't go there

00:17:25,439 --> 00:17:29,360
either because i have to make sure that

00:17:27,199 --> 00:17:32,720
karina looks like pearl

00:17:29,360 --> 00:17:34,559
so if you want something like this

00:17:32,720 --> 00:17:35,919
you might want to check out early

00:17:34,559 --> 00:17:37,200
because earlying is

00:17:35,919 --> 00:17:38,960
fascinating and it might be one of the

00:17:37,200 --> 00:17:40,320
best examples with a whole programming

00:17:38,960 --> 00:17:41,760
language today

00:17:40,320 --> 00:17:44,960
even though most people don't consider

00:17:41,760 --> 00:17:44,960
it to be object-oriented

00:17:45,200 --> 00:17:50,160
so i want to dig into python for a

00:17:47,919 --> 00:17:50,160
moment

00:17:51,360 --> 00:17:55,200
so this is an inventory item python it's

00:17:54,400 --> 00:17:57,120
mutable

00:17:55,200 --> 00:18:00,160
we've got a name price and quantity and

00:17:57,120 --> 00:18:02,000
we can figure out the total cost

00:18:00,160 --> 00:18:03,760
of all of our inventory items if we

00:18:02,000 --> 00:18:07,360
multiply the quantity on hand

00:18:03,760 --> 00:18:09,120
by the unit price this is very simple

00:18:07,360 --> 00:18:11,039
there's nothing fancy it's very easy to

00:18:09,120 --> 00:18:12,320
do in fact this is pretty much easier

00:18:11,039 --> 00:18:16,640
than what you could do a

00:18:12,320 --> 00:18:18,400
core pearl because this is core pearl

00:18:16,640 --> 00:18:20,080
in this case this is immutable because

00:18:18,400 --> 00:18:24,240
it's actually harder to make it mutable

00:18:20,080 --> 00:18:27,360
so core pearl this is python

00:18:24,240 --> 00:18:29,440
this is pearl python wins

00:18:27,360 --> 00:18:30,480
there hands down i'm sorry it is easier

00:18:29,440 --> 00:18:32,000
to write that

00:18:30,480 --> 00:18:33,520
because with pearl when you only have

00:18:32,000 --> 00:18:36,640
less you have to wire everything

00:18:33,520 --> 00:18:39,039
together by hand that's very frustrating

00:18:36,640 --> 00:18:40,080
uh by the way this is karina uh pretty

00:18:39,039 --> 00:18:41,760
much the same thing

00:18:40,080 --> 00:18:44,080
except this is an immutable version

00:18:41,760 --> 00:18:47,120
which i prefer as most of you i think

00:18:44,080 --> 00:18:51,280
know it's very simple clean uh

00:18:47,120 --> 00:18:51,280
and even nicer than the python version

00:18:51,840 --> 00:18:56,640
but let's get back to the python version

00:18:54,880 --> 00:18:59,039
i can down at the bottom you can see i

00:18:56,640 --> 00:19:01,760
can set item price to bob

00:18:59,039 --> 00:19:02,240
and if i were to print that my total

00:19:01,760 --> 00:19:04,000
cost

00:19:02,240 --> 00:19:06,400
is unit priced on quantity on hand that

00:19:04,000 --> 00:19:08,799
would print out

00:19:06,400 --> 00:19:10,640
that doesn't make any sense we have no

00:19:08,799 --> 00:19:12,720
validation and when i talk to python

00:19:10,640 --> 00:19:14,559
programmers they say

00:19:12,720 --> 00:19:16,000
this is pythonic you do not want to

00:19:14,559 --> 00:19:19,840
validate your data

00:19:16,000 --> 00:19:19,840
because you should know your code base

00:19:20,080 --> 00:19:24,000
and it turns out there's a lot of

00:19:21,760 --> 00:19:27,679
problems with this on larger code bases

00:19:24,000 --> 00:19:29,039
not a surprise so one developer was

00:19:27,679 --> 00:19:30,720
working on something called data classes

00:19:29,039 --> 00:19:31,360
and he worked with guido to get a good

00:19:30,720 --> 00:19:34,160
syntax

00:19:31,360 --> 00:19:37,039
language where you can mention you can

00:19:34,160 --> 00:19:38,320
basically list the types

00:19:37,039 --> 00:19:39,679
i'm going to kind of slag up data

00:19:38,320 --> 00:19:41,360
classes a little bit here but they're

00:19:39,679 --> 00:19:42,559
actually wonderful there's a huge amount

00:19:41,360 --> 00:19:46,080
of stuff they provide

00:19:42,559 --> 00:19:48,240
for you but not types

00:19:46,080 --> 00:19:49,360
they they see profile types but they

00:19:48,240 --> 00:19:50,720
they really don't

00:19:49,360 --> 00:19:54,640
if you look them right now you see the

00:19:50,720 --> 00:19:54,640
stream you see the float you see the int

00:19:54,720 --> 00:19:59,440
and you can still assign bob to your

00:19:57,760 --> 00:20:01,280
unit price even though it's a float and

00:19:59,440 --> 00:20:02,720
when you print item total cost that will

00:20:01,280 --> 00:20:06,080
print bob

00:20:02,720 --> 00:20:07,840
what's going on i have my type

00:20:06,080 --> 00:20:09,919
information there well it turns out

00:20:07,840 --> 00:20:12,159
python ignores this

00:20:09,919 --> 00:20:14,080
um you have to use external tools for

00:20:12,159 --> 00:20:17,200
this or

00:20:14,080 --> 00:20:18,880
you can write your own data validation

00:20:17,200 --> 00:20:20,400
here's the cert ballot method again

00:20:18,880 --> 00:20:21,840
these are all online going through it

00:20:20,400 --> 00:20:23,679
too fast i know

00:20:21,840 --> 00:20:25,520
but these are all online and when i call

00:20:23,679 --> 00:20:27,360
total costs i can assert that all my

00:20:25,520 --> 00:20:28,000
data is valid and throw an exception if

00:20:27,360 --> 00:20:30,880
it is not

00:20:28,000 --> 00:20:31,280
if it doesn't match the types this is

00:20:30,880 --> 00:20:33,360
kind of

00:20:31,280 --> 00:20:35,840
ugly so if i were to make this object

00:20:33,360 --> 00:20:38,720
immutable i can call post init

00:20:35,840 --> 00:20:39,360
which is kind of like uh the build

00:20:38,720 --> 00:20:42,559
method

00:20:39,360 --> 00:20:43,679
in boost and that would call a certain

00:20:42,559 --> 00:20:45,840
ballot on the object

00:20:43,679 --> 00:20:48,880
because i've set frozen equals true i

00:20:45,840 --> 00:20:50,960
now have a nice immutable object

00:20:48,880 --> 00:20:52,960
i still don't want to write this code to

00:20:50,960 --> 00:20:53,919
manually verify that my types are

00:20:52,960 --> 00:20:55,360
correct

00:20:53,919 --> 00:20:59,600
because every time you have to write

00:20:55,360 --> 00:20:59,600
that that's more chances for bugs

00:20:59,679 --> 00:21:03,200
but you have pedantic which is a

00:21:01,360 --> 00:21:05,600
one-time type validation my pi

00:21:03,200 --> 00:21:06,400
pyrite static type chapters all of these

00:21:05,600 --> 00:21:09,280
have been built

00:21:06,400 --> 00:21:10,799
in response to a single problem python

00:21:09,280 --> 00:21:13,360
as systems get bigger they're harder to

00:21:10,799 --> 00:21:16,480
maintain without types

00:21:13,360 --> 00:21:17,840
it's that simple right there's

00:21:16,480 --> 00:21:20,159
we see this in perl we see this in

00:21:17,840 --> 00:21:22,159
python these tons of languages

00:21:20,159 --> 00:21:23,840
larger systems if you don't have this

00:21:22,159 --> 00:21:24,400
way of asserting the correctness of the

00:21:23,840 --> 00:21:27,280
program

00:21:24,400 --> 00:21:27,280
you have more bugs

00:21:27,840 --> 00:21:31,520
so why do you get types there's there's

00:21:29,679 --> 00:21:32,720
more reasons in this probably the big

00:21:31,520 --> 00:21:34,880
three correctness performance

00:21:32,720 --> 00:21:37,679
documentation documentation telling you

00:21:34,880 --> 00:21:38,159
what kind of data you have performance

00:21:37,679 --> 00:21:39,840
you can

00:21:38,159 --> 00:21:41,200
build in great performance advantages

00:21:39,840 --> 00:21:44,159
but really

00:21:41,200 --> 00:21:45,760
it's correctness that is the first thing

00:21:44,159 --> 00:21:47,440
we need to strive for because we want to

00:21:45,760 --> 00:21:48,880
make sure the software we build does

00:21:47,440 --> 00:21:51,679
what it's supposed to do

00:21:48,880 --> 00:21:54,960
that's a big thing up front the others

00:21:51,679 --> 00:21:54,960
we can worry about think

00:21:55,280 --> 00:21:59,280
but we're not going to get that in korea

00:21:57,520 --> 00:22:02,000
as much as i want it and the reason

00:21:59,280 --> 00:22:04,240
we're not going to get that

00:22:02,000 --> 00:22:05,520
because it spans the entire language

00:22:04,240 --> 00:22:09,440
variable declarations

00:22:05,520 --> 00:22:09,440
slot declarations signatures

00:22:09,520 --> 00:22:12,799
there's many different arguments about

00:22:11,120 --> 00:22:15,039
how types should be

00:22:12,799 --> 00:22:16,400
declared the first one my aunt fu

00:22:15,039 --> 00:22:18,799
probably won't happen

00:22:16,400 --> 00:22:20,159
because that's leveraging existing

00:22:18,799 --> 00:22:22,320
syntax and pearl

00:22:20,159 --> 00:22:24,080
which is mostly unused except it is used

00:22:22,320 --> 00:22:24,480
with fields fragment and we can't take a

00:22:24,080 --> 00:22:28,480
chance

00:22:24,480 --> 00:22:30,400
breaking backwards compatibility

00:22:28,480 --> 00:22:31,760
there's other things i won't go into it

00:22:30,400 --> 00:22:32,960
right now but

00:22:31,760 --> 00:22:35,679
effectively we're not getting types

00:22:32,960 --> 00:22:36,880
anytime soon we get a lot of other nice

00:22:35,679 --> 00:22:42,080
things out of creative

00:22:36,880 --> 00:22:42,080
types of not going to be one so

00:22:42,559 --> 00:22:46,159
what we've learned inheritance is it's

00:22:45,039 --> 00:22:47,840
kind of a mess

00:22:46,159 --> 00:22:49,760
we're not going to get the types but

00:22:47,840 --> 00:22:52,480
simplicity that's that's lovely how

00:22:49,760 --> 00:22:56,080
simple can we get and still have a great

00:22:52,480 --> 00:22:56,640
oo system um less is not the simplicity

00:22:56,080 --> 00:22:59,280
you want

00:22:56,640 --> 00:23:00,799
because that's the assembly language we

00:22:59,280 --> 00:23:02,960
need something which allows you to do

00:23:00,799 --> 00:23:05,360
as much as you want but takes away a lot

00:23:02,960 --> 00:23:08,000
of the grunt work so you can focus on

00:23:05,360 --> 00:23:09,679
building the code that you need and not

00:23:08,000 --> 00:23:12,480
the code that you need to build

00:23:09,679 --> 00:23:14,080
to write the code that allows you to do

00:23:12,480 --> 00:23:16,159
what you need

00:23:14,080 --> 00:23:17,760
so good enough is not good enough if

00:23:16,159 --> 00:23:20,840
we're going to push pearl forward

00:23:17,760 --> 00:23:23,520
we can't be decent we have to excel

00:23:20,840 --> 00:23:26,320
beyond what we thought we could do

00:23:23,520 --> 00:23:26,320
and that's what we're trying

00:23:27,440 --> 00:23:33,200
there are some i'm gonna see what what

00:23:31,440 --> 00:23:35,120
i need to find out what slide i'm on

00:23:33,200 --> 00:23:36,799
okay i am

00:23:35,120 --> 00:23:38,880
actually making great time this makes me

00:23:36,799 --> 00:23:40,159
very happy so changes to koreano that

00:23:38,880 --> 00:23:42,000
you may not have heard about

00:23:40,159 --> 00:23:43,679
curtis uh you stopped sharing your

00:23:42,000 --> 00:23:50,240
screen

00:23:43,679 --> 00:23:54,320
thank you very much that was frustrating

00:23:50,240 --> 00:23:55,279
okay so changes to karena that you may

00:23:54,320 --> 00:23:58,880
not have heard of

00:23:55,279 --> 00:24:01,919
um first of all the builder for

00:23:58,880 --> 00:24:03,440
has dollar foo poland builder that has

00:24:01,919 --> 00:24:06,080
gone away

00:24:03,440 --> 00:24:06,960
i'll explain this in a moment uh we're

00:24:06,080 --> 00:24:09,039
not going to have

00:24:06,960 --> 00:24:11,440
uh the construct phaser that's like

00:24:09,039 --> 00:24:12,240
builders and loose and move that's going

00:24:11,440 --> 00:24:15,200
away

00:24:12,240 --> 00:24:15,840
uh adjust and destruct are going to be

00:24:15,200 --> 00:24:18,320
phasers

00:24:15,840 --> 00:24:19,039
and not methods phasers you've heard

00:24:18,320 --> 00:24:21,919
about them in

00:24:19,039 --> 00:24:22,320
raku we have similar things in pearl uh

00:24:21,919 --> 00:24:25,840
check

00:24:22,320 --> 00:24:28,000
unit check init uh begin

00:24:25,840 --> 00:24:30,080
and so on so justin's structuring to be

00:24:28,000 --> 00:24:31,679
phasers

00:24:30,080 --> 00:24:33,200
the reason we're not going to have

00:24:31,679 --> 00:24:34,240
builder though this this one was kind of

00:24:33,200 --> 00:24:36,240
contentious

00:24:34,240 --> 00:24:37,360
so if i have some class and i have

00:24:36,240 --> 00:24:39,679
another class

00:24:37,360 --> 00:24:41,200
if another class were to inherit from

00:24:39,679 --> 00:24:42,640
some class which i forgot to put on the

00:24:41,200 --> 00:24:46,240
slide

00:24:42,640 --> 00:24:47,440
my build x is returning a string but i'm

00:24:46,240 --> 00:24:49,600
expecting a float

00:24:47,440 --> 00:24:51,520
in the parent class especially since i

00:24:49,600 --> 00:24:54,080
can't have types it's bad

00:24:51,520 --> 00:24:55,600
we're violating encapsulation if a child

00:24:54,080 --> 00:24:58,400
class could just

00:24:55,600 --> 00:24:59,120
stomp on the parent classes data for no

00:24:58,400 --> 00:25:02,080
reason

00:24:59,120 --> 00:25:02,559
furthermore this is the default in how

00:25:02,080 --> 00:25:05,840
pearl

00:25:02,559 --> 00:25:07,279
actually works you have no way of oh

00:25:05,840 --> 00:25:09,039
this is the default of how much new

00:25:07,279 --> 00:25:10,960
works you really don't have an

00:25:09,039 --> 00:25:12,400
easy way of preventing this unless you

00:25:10,960 --> 00:25:13,520
inline the sub in the attribute

00:25:12,400 --> 00:25:14,880
declaration

00:25:13,520 --> 00:25:16,400
but people tend to have separate

00:25:14,880 --> 00:25:19,039
builders especially if they're

00:25:16,400 --> 00:25:19,039
complicated

00:25:19,440 --> 00:25:24,559
so if your builder's complex

00:25:22,799 --> 00:25:26,480
you know this would be frustrating this

00:25:24,559 --> 00:25:27,279
is one possible syntax we could have for

00:25:26,480 --> 00:25:28,960
this

00:25:27,279 --> 00:25:30,320
if we had private methods this would be

00:25:28,960 --> 00:25:32,400
simple because you couldn't

00:25:30,320 --> 00:25:33,679
override them in a subclass we're not

00:25:32,400 --> 00:25:34,480
going to have private methods in the

00:25:33,679 --> 00:25:38,240
first pass

00:25:34,480 --> 00:25:40,960
probably so that's unfortunate

00:25:38,240 --> 00:25:42,240
but for now we still have the default

00:25:40,960 --> 00:25:44,400
assignment equals rand

00:25:42,240 --> 00:25:46,400
again if your code's complex that's not

00:25:44,400 --> 00:25:48,480
going to work terribly well

00:25:46,400 --> 00:25:50,480
but we have the adjust phase which is

00:25:48,480 --> 00:25:53,600
like build and move

00:25:50,480 --> 00:25:55,440
we can assign rand to x there

00:25:53,600 --> 00:25:57,600
if we want to so it's fairly simple that

00:25:55,440 --> 00:26:00,080
happens right after object construction

00:25:57,600 --> 00:26:02,159
or if you really really want a subclass

00:26:00,080 --> 00:26:04,799
to overwrite it

00:26:02,159 --> 00:26:06,000
then you just have your method built x

00:26:04,799 --> 00:26:09,039
return

00:26:06,000 --> 00:26:10,159
and then in your adjust method you call

00:26:09,039 --> 00:26:13,279
that

00:26:10,159 --> 00:26:14,240
and it works fine so we didn't lose

00:26:13,279 --> 00:26:16,559
anything

00:26:14,240 --> 00:26:17,840
we've gotten more safety by taking away

00:26:16,559 --> 00:26:19,679
the builders so parent

00:26:17,840 --> 00:26:21,200
so child children cannot accidentally

00:26:19,679 --> 00:26:24,559
stop on their parents

00:26:21,200 --> 00:26:26,559
but we've still given you the ability to

00:26:24,559 --> 00:26:28,640
take care of this this is nice because

00:26:26,559 --> 00:26:30,880
again this is pairing away part of

00:26:28,640 --> 00:26:34,320
the language but still offering this

00:26:30,880 --> 00:26:36,320
flexibility which i appreciate

00:26:34,320 --> 00:26:37,679
so adjust and destruct like i said these

00:26:36,320 --> 00:26:39,919
are just phasers so

00:26:37,679 --> 00:26:41,279
here we've got a class class data mynum

00:26:39,919 --> 00:26:44,320
instances equals zero

00:26:41,279 --> 00:26:44,880
and and adjust and destruct those will

00:26:44,320 --> 00:26:46,799
simply

00:26:44,880 --> 00:26:48,480
allow num instances to report at any

00:26:46,799 --> 00:26:49,840
time how many instances of some class

00:26:48,480 --> 00:26:52,240
you've created

00:26:49,840 --> 00:26:52,960
it's just like begin unit check things

00:26:52,240 --> 00:26:56,880
like that so

00:26:52,960 --> 00:26:59,760
fairly straightforward and it's

00:26:56,880 --> 00:27:00,880
leveraging the existing ideas that we

00:26:59,760 --> 00:27:04,080
already have

00:27:00,880 --> 00:27:04,080
and i really appreciate that

00:27:04,480 --> 00:27:07,840
so the construct phaser

00:27:09,120 --> 00:27:11,760
here's what it was looking like

00:27:10,159 --> 00:27:14,000
constructor would accept the class and

00:27:11,760 --> 00:27:15,120
the hards and of one equals args with

00:27:14,000 --> 00:27:18,240
unshipped arts

00:27:15,120 --> 00:27:20,480
names we often do this with um

00:27:18,240 --> 00:27:22,399
build arts in loose and new if we want

00:27:20,480 --> 00:27:24,240
to have like an alternate constructor

00:27:22,399 --> 00:27:25,840
instead of passing in key value pairs i

00:27:24,240 --> 00:27:27,919
just want to pass into one value

00:27:25,840 --> 00:27:29,840
or something we have to punch that the

00:27:27,919 --> 00:27:31,760
thing is phasers don't accept

00:27:29,840 --> 00:27:33,279
data and they don't return data this

00:27:31,760 --> 00:27:36,960
wasn't working

00:27:33,279 --> 00:27:38,799
and well just create an alternate

00:27:36,960 --> 00:27:40,640
constructor if you want to do that

00:27:38,799 --> 00:27:43,039
some classroom name over that's not from

00:27:40,640 --> 00:27:46,799
the constructor there's no need

00:27:43,039 --> 00:27:48,399
for the build arms slash construct

00:27:46,799 --> 00:27:51,279
we just have a different constructor and

00:27:48,399 --> 00:27:54,480
everything is simple

00:27:51,279 --> 00:27:58,159
so again we managed to take more things

00:27:54,480 --> 00:27:59,520
away from karina uh make it safer make

00:27:58,159 --> 00:28:02,240
it easier

00:27:59,520 --> 00:28:03,679
and get some more power out there and i

00:28:02,240 --> 00:28:04,640
think this is going well here's another

00:28:03,679 --> 00:28:07,919
example of this i

00:28:04,640 --> 00:28:08,720
hated this syntax which i designed but i

00:28:07,919 --> 00:28:11,440
hated it

00:28:08,720 --> 00:28:13,520
we have names new title is new but it's

00:28:11,440 --> 00:28:14,000
optional you don't necessarily need that

00:28:13,520 --> 00:28:16,480
in the

00:28:14,000 --> 00:28:17,919
constructor and it's like this is the

00:28:16,480 --> 00:28:21,120
only place we use that

00:28:17,919 --> 00:28:23,120
optional in parentheses and it's

00:28:21,120 --> 00:28:26,159
really really been bugging me it's just

00:28:23,120 --> 00:28:29,200
ugly and then i realized

00:28:26,159 --> 00:28:32,480
i don't need to do that so now

00:28:29,200 --> 00:28:33,279
new but i provide a default value even

00:28:32,480 --> 00:28:35,600
if it's on def

00:28:33,279 --> 00:28:37,360
it means i don't need to provide that in

00:28:35,600 --> 00:28:39,120
my constructor

00:28:37,360 --> 00:28:40,799
i'm leveraging the existing constructs

00:28:39,120 --> 00:28:41,279
from the language i'm simplifying the

00:28:40,799 --> 00:28:44,320
grammar

00:28:41,279 --> 00:28:47,679
again uh and still providing the power

00:28:44,320 --> 00:28:47,679
that we were hoping to have

00:28:48,880 --> 00:28:52,399
so abstract methods this is another one

00:28:50,880 --> 00:28:53,440
thinking about for a while an abstract

00:28:52,399 --> 00:28:56,399
method

00:28:53,440 --> 00:28:58,159
um basically doesn't have a body it says

00:28:56,399 --> 00:29:01,200
you need to override this in

00:28:58,159 --> 00:29:03,039
a subclass there are a lot of useful

00:29:01,200 --> 00:29:04,480
types there's things about compile time

00:29:03,039 --> 00:29:05,840
and runtime checking which i'm not going

00:29:04,480 --> 00:29:08,399
to get into right now

00:29:05,840 --> 00:29:08,880
but i'm looking at this abstract method

00:29:08,399 --> 00:29:12,240
foo

00:29:08,880 --> 00:29:14,480
and we just don't provide a method body

00:29:12,240 --> 00:29:15,520
and here's an abstract class abstract

00:29:14,480 --> 00:29:17,520
class shape

00:29:15,520 --> 00:29:19,120
i have an area and i have a parameter

00:29:17,520 --> 00:29:23,039
those are abstract methods

00:29:19,120 --> 00:29:25,520
but if i have abstract methods the class

00:29:23,039 --> 00:29:28,000
is automatically abstract

00:29:25,520 --> 00:29:28,960
and these are basically forward

00:29:28,000 --> 00:29:31,039
declarations

00:29:28,960 --> 00:29:32,559
right here i don't need to declare those

00:29:31,039 --> 00:29:34,880
as abstract so again

00:29:32,559 --> 00:29:35,600
maybe i could pare down even more of the

00:29:34,880 --> 00:29:37,840
language

00:29:35,600 --> 00:29:38,720
and get a lot more and get the power

00:29:37,840 --> 00:29:40,480
that we wanted

00:29:38,720 --> 00:29:42,399
but it's still clear what's going on

00:29:40,480 --> 00:29:46,000
this is obviously an abstract class

00:29:42,399 --> 00:29:46,000
it cannot be instantiated

00:29:46,159 --> 00:29:50,000
so here's how this would look if you

00:29:48,720 --> 00:29:54,000
were to do this with role

00:29:50,000 --> 00:29:55,600
fire's area the perimeter

00:29:54,000 --> 00:29:57,039
if you try to instantiate if you try and

00:29:55,600 --> 00:29:58,080
call a method on the class it's just

00:29:57,039 --> 00:29:59,840
going to blow up because it's an

00:29:58,080 --> 00:30:02,080
abstract class you can't use them that

00:29:59,840 --> 00:30:02,080
way

00:30:03,120 --> 00:30:06,720
but do you remember that abs that

00:30:04,880 --> 00:30:07,440
abstract boolean class that i showed you

00:30:06,720 --> 00:30:09,279
earlier

00:30:07,440 --> 00:30:10,880
in this case i've got these two methods

00:30:09,279 --> 00:30:12,480
true and false neither of which are

00:30:10,880 --> 00:30:14,159
abstract

00:30:12,480 --> 00:30:16,399
they can't be because they were supposed

00:30:14,159 --> 00:30:18,960
to provide an implementation which does

00:30:16,399 --> 00:30:19,919
nothing to mirror what small talk was

00:30:18,960 --> 00:30:23,679
doing which means

00:30:19,919 --> 00:30:25,440
i can't infer that the class is abstract

00:30:23,679 --> 00:30:27,520
so i have to put the abstract keyword

00:30:25,440 --> 00:30:29,120
though and then i started thinking about

00:30:27,520 --> 00:30:31,360
this more and i realized

00:30:29,120 --> 00:30:33,520
actually if a class is abstract you'll

00:30:31,360 --> 00:30:35,600
have to declare it as abstract

00:30:33,520 --> 00:30:37,440
we don't want to infer this and miss

00:30:35,600 --> 00:30:40,320
that on the class declaration

00:30:37,440 --> 00:30:41,279
because that's more checks we have to

00:30:40,320 --> 00:30:43,200
put in the code

00:30:41,279 --> 00:30:45,039
and it's also not a self-documenting you

00:30:43,200 --> 00:30:46,960
might not notice that that huge class

00:30:45,039 --> 00:30:48,480
that you're looking at is abstract

00:30:46,960 --> 00:30:50,000
if you're not declaring it as abstract

00:30:48,480 --> 00:30:51,520
so this was a case where i was trying to

00:30:50,000 --> 00:30:55,200
bear it down too much

00:30:51,520 --> 00:30:57,520
but it didn't work so i had to put that

00:30:55,200 --> 00:30:57,520
back in

00:30:59,279 --> 00:31:02,880
common this is for classmates and these

00:31:01,919 --> 00:31:06,480
can be called

00:31:02,880 --> 00:31:09,919
on classes

00:31:06,480 --> 00:31:11,600
but and instances below that method food

00:31:09,919 --> 00:31:12,320
that could be called an instance but it

00:31:11,600 --> 00:31:14,399
can't be called

00:31:12,320 --> 00:31:15,840
the class method so for a common method

00:31:14,399 --> 00:31:18,399
we inject the class

00:31:15,840 --> 00:31:18,880
variable for method foo we inject both

00:31:18,399 --> 00:31:21,120
the self

00:31:18,880 --> 00:31:22,880
and a class variable which means if you

00:31:21,120 --> 00:31:24,080
want to get the class name you no longer

00:31:22,880 --> 00:31:27,120
need to

00:31:24,080 --> 00:31:28,720
type ref class or class or ref cell for

00:31:27,120 --> 00:31:30,720
self in order to get the plastic

00:31:28,720 --> 00:31:32,960
it will be there for you and this

00:31:30,720 --> 00:31:35,279
started to get interesting

00:31:32,960 --> 00:31:36,799
here's a common method as this is a

00:31:35,279 --> 00:31:40,000
compile time field

00:31:36,799 --> 00:31:41,840
because we will not have self injected

00:31:40,000 --> 00:31:44,240
in the class method because it doesn't

00:31:41,840 --> 00:31:45,360
make sense so if you try and call a

00:31:44,240 --> 00:31:47,279
class method as an

00:31:45,360 --> 00:31:49,279
instance method it will now fail at

00:31:47,279 --> 00:31:51,279
compile time

00:31:49,279 --> 00:31:53,679
we will have other possibilities of

00:31:51,279 --> 00:31:56,399
doing this in the future

00:31:53,679 --> 00:31:56,399
for example

00:31:56,799 --> 00:32:00,080
no i i won't get there here's an

00:31:58,640 --> 00:32:01,840
interesting redefine point

00:32:00,080 --> 00:32:03,519
if you call my classic with refself

00:32:01,840 --> 00:32:04,320
itself we're going to get a redefine

00:32:03,519 --> 00:32:06,480
warning because

00:32:04,320 --> 00:32:09,919
class is already provided for you you

00:32:06,480 --> 00:32:09,919
don't have to write that code anymore

00:32:11,600 --> 00:32:15,120
in the future this would be interesting

00:32:13,120 --> 00:32:16,880
i've got a common method as that's a

00:32:15,120 --> 00:32:18,240
class method not an instance method that

00:32:16,880 --> 00:32:20,960
calls foo

00:32:18,240 --> 00:32:21,440
but foo is an instance method and has

00:32:20,960 --> 00:32:25,039
cell

00:32:21,440 --> 00:32:27,039
in there so that should blow up because

00:32:25,039 --> 00:32:28,399
class methods cannot call instance

00:32:27,039 --> 00:32:29,919
methods because they don't have access

00:32:28,399 --> 00:32:32,640
to the instance data

00:32:29,919 --> 00:32:33,440
and they're not guaranteed to work so

00:32:32,640 --> 00:32:34,720
this is something

00:32:33,440 --> 00:32:37,360
we could possibly even catch that at

00:32:34,720 --> 00:32:39,200
compile time

00:32:37,360 --> 00:32:40,399
but we're not going to try that with v1

00:32:39,200 --> 00:32:43,760
we're trying to get v1

00:32:40,399 --> 00:32:44,640
as short as possible so v1 uh

00:32:43,760 --> 00:32:46,640
it's probably not going to have

00:32:44,640 --> 00:32:47,600
exclusion or aliasing in the role

00:32:46,640 --> 00:32:49,919
methods

00:32:47,600 --> 00:32:51,440
uh it might not have method modifiers i

00:32:49,919 --> 00:32:53,519
don't like method modifiers at all but

00:32:51,440 --> 00:32:57,200
we found some cases where

00:32:53,519 --> 00:32:58,720
we probably need them but how small of a

00:32:57,200 --> 00:33:00,960
thing can we provide you

00:32:58,720 --> 00:33:02,240
and still provide you with the value

00:33:00,960 --> 00:33:04,559
that we think

00:33:02,240 --> 00:33:05,279
this potentially has so here's an

00:33:04,559 --> 00:33:08,640
example of

00:33:05,279 --> 00:33:10,480
roles so roles are

00:33:08,640 --> 00:33:11,679
a little different from subclasses

00:33:10,480 --> 00:33:13,840
because here

00:33:11,679 --> 00:33:15,440
this role requires a private method

00:33:13,840 --> 00:33:16,000
marshall that's when we get private

00:33:15,440 --> 00:33:18,640
methods

00:33:16,000 --> 00:33:20,559
a subclass cannot access private methods

00:33:18,640 --> 00:33:22,240
but roles sometimes will need to be able

00:33:20,559 --> 00:33:23,840
to access those private methods because

00:33:22,240 --> 00:33:24,559
you don't want to expose them outside of

00:33:23,840 --> 00:33:26,720
the class

00:33:24,559 --> 00:33:27,679
but you can trust a role because you're

00:33:26,720 --> 00:33:29,120
consuming the role

00:33:27,679 --> 00:33:30,880
into your class you're consuming the

00:33:29,120 --> 00:33:32,399
methods into your class

00:33:30,880 --> 00:33:34,159
and now we will be able to provide

00:33:32,399 --> 00:33:37,600
private methods so

00:33:34,159 --> 00:33:39,519
we have another ability to

00:33:37,600 --> 00:33:41,600
have a smaller interface to your class

00:33:39,519 --> 00:33:42,159
to not expose the data that you

00:33:41,600 --> 00:33:45,919
shouldn't be

00:33:42,159 --> 00:33:46,559
exposing and keep things clean and tidy

00:33:45,919 --> 00:33:48,480
in a way

00:33:46,559 --> 00:33:52,000
we haven't been able to properly do or

00:33:48,480 --> 00:33:55,279
easily do before

00:33:52,000 --> 00:33:56,799
everyone wants to know when and i don't

00:33:55,279 --> 00:33:58,880
have an answer for that

00:33:56,799 --> 00:34:01,760
so i've been doing most of the creative

00:33:58,880 --> 00:34:04,159
design and i started on an rfc

00:34:01,760 --> 00:34:06,080
as you may know uh pearl now has an rfc

00:34:04,159 --> 00:34:09,599
process that they're experimenting with

00:34:06,080 --> 00:34:13,919
the rfc for this is not easy

00:34:09,599 --> 00:34:17,040
because this is not a tiny project but

00:34:13,919 --> 00:34:17,679
paul he has been doing most of the work

00:34:17,040 --> 00:34:19,919
actually

00:34:17,679 --> 00:34:21,760
on the implementation side he's been

00:34:19,919 --> 00:34:23,359
doing this in object path

00:34:21,760 --> 00:34:24,879
if you haven't played with object pad i

00:34:23,359 --> 00:34:26,159
recommend you do so i believe one

00:34:24,879 --> 00:34:28,000
company is actually using this in

00:34:26,159 --> 00:34:31,359
production right now which is

00:34:28,000 --> 00:34:33,520
surprising but object pad is a test bed

00:34:31,359 --> 00:34:35,919
for the karina ideas plus a few other

00:34:33,520 --> 00:34:37,760
ideas that paul has

00:34:35,919 --> 00:34:39,760
and he's also written future ac to

00:34:37,760 --> 00:34:43,760
weight syntax keyword try

00:34:39,760 --> 00:34:46,079
a lot more things but syntax keyword try

00:34:43,760 --> 00:34:47,359
is actually what should be exciting

00:34:46,079 --> 00:34:48,560
because he's also looking at doing

00:34:47,359 --> 00:34:52,480
syntax keyword

00:34:48,560 --> 00:34:54,399
class so that when we have a version of

00:34:52,480 --> 00:34:56,560
karina that we can propose

00:34:54,399 --> 00:34:57,520
for the pro core you're like oh yeah

00:34:56,560 --> 00:35:00,400
that's going to be what

00:34:57,520 --> 00:35:01,280
parole 5 you know 40 or something way

00:35:00,400 --> 00:35:03,359
off in the future

00:35:01,280 --> 00:35:04,960
i won't be able to use it yes you will

00:35:03,359 --> 00:35:07,520
with older versions of pearl

00:35:04,960 --> 00:35:08,960
with syntax keyword class you'll be able

00:35:07,520 --> 00:35:09,760
to enable that and then you'll get the

00:35:08,960 --> 00:35:13,040
full syntax

00:35:09,760 --> 00:35:15,200
korean syntax available for you and not

00:35:13,040 --> 00:35:17,440
just limited to newer pros

00:35:15,200 --> 00:35:18,400
so this will be nice it'll be backwards

00:35:17,440 --> 00:35:21,760
compatible

00:35:18,400 --> 00:35:24,160
basically um because the syntax doesn't

00:35:21,760 --> 00:35:25,680
work with all the versions of pearl

00:35:24,160 --> 00:35:27,520
you'll be able to still be able to use

00:35:25,680 --> 00:35:28,880
it for older versions of pearl in case

00:35:27,520 --> 00:35:30,720
you want to take advantage of it

00:35:28,880 --> 00:35:33,920
right now the performance is on par with

00:35:30,720 --> 00:35:36,480
new uh which is a fairly fast so system

00:35:33,920 --> 00:35:39,119
and that's with no optimizations

00:35:36,480 --> 00:35:42,160
whatsoever

00:35:39,119 --> 00:35:43,680
and to wrap all of this up and then i

00:35:42,160 --> 00:35:45,520
can take some questions uh

00:35:43,680 --> 00:35:46,720
this this wasn't designed to be

00:35:45,520 --> 00:35:49,200
informative

00:35:46,720 --> 00:35:51,119
i had fun with a lot of those other oboe

00:35:49,200 --> 00:35:52,320
systems digging in to see what they do

00:35:51,119 --> 00:35:53,760
and i thought it would be fun to share

00:35:52,320 --> 00:35:55,040
that with you and some of the things

00:35:53,760 --> 00:35:57,280
that it helped

00:35:55,040 --> 00:35:58,160
form thoughts about how to make karina

00:35:57,280 --> 00:35:59,599
better

00:35:58,160 --> 00:36:01,200
i've been looking at how much we can

00:35:59,599 --> 00:36:01,920
remove and still have something which is

00:36:01,200 --> 00:36:04,000
great

00:36:01,920 --> 00:36:06,400
uh what do we have to add back in that

00:36:04,000 --> 00:36:10,000
you know if i took away too much

00:36:06,400 --> 00:36:13,200
lack of types is a problem but

00:36:10,000 --> 00:36:15,119
karina it offers incredible

00:36:13,200 --> 00:36:16,480
encapsulation in a way we've never been

00:36:15,119 --> 00:36:19,359
able to do before

00:36:16,480 --> 00:36:20,880
probably very easily i should say uh all

00:36:19,359 --> 00:36:23,119
the various attempts i've seen have been

00:36:20,880 --> 00:36:24,480
very clumsy it's very frustrating uh

00:36:23,119 --> 00:36:26,560
native roles will be built

00:36:24,480 --> 00:36:28,240
into the language not some third-party

00:36:26,560 --> 00:36:29,920
module

00:36:28,240 --> 00:36:31,599
most of the syntax for karima is

00:36:29,920 --> 00:36:33,839
declarative in nature

00:36:31,599 --> 00:36:35,200
which means it's easier to get right and

00:36:33,839 --> 00:36:37,760
you don't have to wire all the bits

00:36:35,200 --> 00:36:38,400
together and we can build on that in the

00:36:37,760 --> 00:36:40,400
future

00:36:38,400 --> 00:36:41,920
because the minimum viable project

00:36:40,400 --> 00:36:45,599
product is designed to be

00:36:41,920 --> 00:36:48,240
minimal so that we can test out the core

00:36:45,599 --> 00:36:48,640
of this and see how well it works uh and

00:36:48,240 --> 00:36:50,400
what

00:36:48,640 --> 00:36:52,079
and we don't have to add things in if it

00:36:50,400 --> 00:36:55,119
turns out we don't actually need them so

00:36:52,079 --> 00:36:58,560
we'll be building too much

00:36:55,119 --> 00:37:00,720
so that wraps up that i'm now going to

00:36:58,560 --> 00:37:06,000
turn back on my video

00:37:00,720 --> 00:37:06,000
and once i ah there we go

00:37:07,200 --> 00:37:10,960
and does anyone have any questions

00:37:12,960 --> 00:37:19,280
i've got one question curtis

00:37:16,480 --> 00:37:21,680
on the slide with the rolls on the slide

00:37:19,280 --> 00:37:25,280
where you define the role

00:37:21,680 --> 00:37:28,240
yes um there was no

00:37:25,280 --> 00:37:30,320
declaration on that page of what class

00:37:28,240 --> 00:37:32,880
it belonged to

00:37:30,320 --> 00:37:35,280
and there probably won't be because you

00:37:32,880 --> 00:37:38,079
can compose a role into any class

00:37:35,280 --> 00:37:38,400
correct well let me let me go back to

00:37:38,079 --> 00:37:42,480
that

00:37:38,400 --> 00:37:44,880
i'm looking at the slide right now um

00:37:42,480 --> 00:37:47,040
okay let me share this so folks can see

00:37:44,880 --> 00:37:47,040
that

00:37:48,240 --> 00:37:52,640
right we don't so roles don't belong to

00:37:51,680 --> 00:37:53,920
a class

00:37:52,640 --> 00:37:55,839
right they're they're not they're

00:37:53,920 --> 00:37:56,480
specifically not supposed to belong to a

00:37:55,839 --> 00:37:59,440
class

00:37:56,480 --> 00:38:01,440
so as so as as a standalone piece of

00:37:59,440 --> 00:38:04,560
code

00:38:01,440 --> 00:38:08,160
how does this thing pass a

00:38:04,560 --> 00:38:12,000
pearl dash c on it for example

00:38:08,160 --> 00:38:14,320
uh something that's just assumed or

00:38:12,000 --> 00:38:16,400
product c works fine uh with roles

00:38:14,320 --> 00:38:18,720
there's no problem with that because c

00:38:16,400 --> 00:38:19,440
is a compile check it's not actually

00:38:18,720 --> 00:38:21,760
checking that

00:38:19,440 --> 00:38:23,200
you're running the code necessarily

00:38:21,760 --> 00:38:24,640
there's obviously this

00:38:23,200 --> 00:38:26,880
trick for that i wouldn't complain about

00:38:24,640 --> 00:38:29,440
not finding self or is this going to be

00:38:26,880 --> 00:38:32,400
embedded enough that self is gonna

00:38:29,440 --> 00:38:33,280
it's gonna know that self is a object of

00:38:32,400 --> 00:38:36,480
some sort

00:38:33,280 --> 00:38:39,200
wink wink not not when you compose it

00:38:36,480 --> 00:38:39,920
um for the newer versions of pearl uh if

00:38:39,200 --> 00:38:43,599
you use a

00:38:39,920 --> 00:38:45,920
dash capital e switch um well that turns

00:38:43,599 --> 00:38:48,240
it up that's not c um

00:38:45,920 --> 00:38:48,960
you you're at first it's going to be

00:38:48,240 --> 00:38:52,079
explicitly

00:38:48,960 --> 00:38:53,680
use feature class and that turns up that

00:38:52,079 --> 00:38:55,040
will turn on the karina syntax and that

00:38:53,680 --> 00:38:57,200
will understand all this

00:38:55,040 --> 00:38:59,200
got it thank you yes yes we have the

00:38:57,200 --> 00:39:00,800
future guard in there right

00:38:59,200 --> 00:39:02,640
that's right it's all going to be buried

00:39:00,800 --> 00:39:05,119
under that thank you

00:39:02,640 --> 00:39:05,119
you're welcome

00:39:06,640 --> 00:39:12,400
anything else yeah i have a question

00:39:09,680 --> 00:39:14,079
yes sir how does karina relate to the

00:39:12,400 --> 00:39:18,079
mob that stephen little has been

00:39:14,079 --> 00:39:22,160
working on um the intention is to

00:39:18,079 --> 00:39:25,200
get the mock for karina to be as

00:39:22,160 --> 00:39:26,960
similar to the mop that steven was

00:39:25,200 --> 00:39:30,000
working on

00:39:26,960 --> 00:39:33,920
as possible using that as a guide uh

00:39:30,000 --> 00:39:37,040
i need to paul are you here

00:39:33,920 --> 00:39:38,560
yeah i'm here there you are um

00:39:37,040 --> 00:39:39,760
can you answer that question for him

00:39:38,560 --> 00:39:42,560
because you're doing the implementation

00:39:39,760 --> 00:39:45,680
side on that have you gotten them

00:39:42,560 --> 00:39:46,160
so the object pad does have parts of the

00:39:45,680 --> 00:39:48,880
mop

00:39:46,160 --> 00:39:50,400
um it doesn't i haven't just implemented

00:39:48,880 --> 00:39:52,480
all of the methods

00:39:50,400 --> 00:39:53,599
i've only been implementing things that

00:39:52,480 --> 00:39:55,040
i actually needed

00:39:53,599 --> 00:39:57,440
but whenever i needed something i

00:39:55,040 --> 00:40:00,320
implemented it in the same way

00:39:57,440 --> 00:40:01,200
um so it's sort of a lazy partial copy

00:40:00,320 --> 00:40:06,079
of

00:40:01,200 --> 00:40:06,079
the um the other mop api yes

00:40:07,760 --> 00:40:11,200
i don't know if that answers okay thank

00:40:10,240 --> 00:40:14,480
you

00:40:11,200 --> 00:40:14,480
so you'll get your meta programming

00:40:14,880 --> 00:40:18,400
much the horror of many people yeah i

00:40:17,119 --> 00:40:19,680
mean i because i i already

00:40:18,400 --> 00:40:21,760
i've already been using that in a few

00:40:19,680 --> 00:40:25,680
places and the um

00:40:21,760 --> 00:40:28,960
there's a cpan module myriad my

00:40:25,680 --> 00:40:31,760
riad um the the company i

00:40:28,960 --> 00:40:33,040
i work for have been sort of working on

00:40:31,760 --> 00:40:35,040
and that that's kind of

00:40:33,040 --> 00:40:36,079
their big kind of scary test bed with

00:40:35,040 --> 00:40:39,599
all of the

00:40:36,079 --> 00:40:42,400
um object class and and um

00:40:39,599 --> 00:40:43,839
did a async await and all of those fancy

00:40:42,400 --> 00:40:46,640
things in there

00:40:43,839 --> 00:40:48,560
oh i'm looking forward to seeing that

00:40:46,640 --> 00:40:53,839
yeah

00:40:48,560 --> 00:40:53,839
okay any more questions

00:40:58,079 --> 00:41:02,160
i have a question if you can hear me yes

00:41:00,800 --> 00:41:04,960
i can

00:41:02,160 --> 00:41:07,040
uh i don't want to i mean i love the

00:41:04,960 --> 00:41:10,640
core project and the work you have done

00:41:07,040 --> 00:41:13,040
but i was just wondering since what uh

00:41:10,640 --> 00:41:15,359
paul just said about object pad kind of

00:41:13,040 --> 00:41:17,920
implementing parts of the mob

00:41:15,359 --> 00:41:18,800
uh i'm guessing or hoping that's like

00:41:17,920 --> 00:41:22,480
native or

00:41:18,800 --> 00:41:25,599
c based or is like something speed based

00:41:22,480 --> 00:41:26,000
but in that case will it be possible if

00:41:25,599 --> 00:41:29,440
you

00:41:26,000 --> 00:41:31,359
like are have too much code or are too

00:41:29,440 --> 00:41:34,480
used to the old style of mu

00:41:31,359 --> 00:41:36,640
and moose to implement those

00:41:34,480 --> 00:41:38,240
with object pad or something like that

00:41:36,640 --> 00:41:42,240
or is that just stupid

00:41:38,240 --> 00:41:42,240
question um

00:41:43,440 --> 00:41:48,800
most of the point here is to provide

00:41:46,400 --> 00:41:53,040
nicer looking syntax

00:41:48,800 --> 00:41:53,599
um so in a way i'm not sure why you

00:41:53,040 --> 00:41:56,800
would

00:41:53,599 --> 00:41:58,319
kind of need to do that like there's

00:41:56,800 --> 00:42:00,560
there's no point

00:41:58,319 --> 00:42:02,319
there's no point having a core object

00:42:00,560 --> 00:42:04,880
system or object pad or whatever

00:42:02,319 --> 00:42:06,480
provide the same syntax that mo or moose

00:42:04,880 --> 00:42:08,880
can provide because you've already got

00:42:06,480 --> 00:42:11,920
that you just use mirror mousse

00:42:08,880 --> 00:42:14,720
so like there'd be no point yeah

00:42:11,920 --> 00:42:15,359
yeah uh new code you you can write new

00:42:14,720 --> 00:42:17,359
code

00:42:15,359 --> 00:42:19,200
and for example object pad i i have a

00:42:17,359 --> 00:42:22,560
bunch of tests in there that check that

00:42:19,200 --> 00:42:24,319
you can subclass um plain object classes

00:42:22,560 --> 00:42:25,839
and move classes and move classes and so

00:42:24,319 --> 00:42:26,400
on and also you can do it in the other

00:42:25,839 --> 00:42:27,920
direction

00:42:26,400 --> 00:42:30,000
so so they are they are fully cross

00:42:27,920 --> 00:42:31,839
compatible wow

00:42:30,000 --> 00:42:33,839
it's purely about just providing a nicer

00:42:31,839 --> 00:42:35,599
syntax

00:42:33,839 --> 00:42:37,680
yeah okay if it's compatible then it's

00:42:35,599 --> 00:42:38,800
easier but i was just thinking about

00:42:37,680 --> 00:42:41,720
people with big code

00:42:38,800 --> 00:42:43,359
bases that want to have faster

00:42:41,720 --> 00:42:45,920
object-oriented

00:42:43,359 --> 00:42:47,119
code without rewriting all the object

00:42:45,920 --> 00:42:48,880
oriented code

00:42:47,119 --> 00:42:51,280
well yeah just just just find your your

00:42:48,880 --> 00:42:52,960
kind of inner five percent hotspots and

00:42:51,280 --> 00:42:55,359
rewrite those

00:42:52,960 --> 00:42:55,359
okay

00:42:56,160 --> 00:43:00,480
i see william in the chat was asking

00:42:58,319 --> 00:43:01,440
about uh some comparing contrast with

00:43:00,480 --> 00:43:04,720
raku

00:43:01,440 --> 00:43:05,599
um i did find rocky very interesting and

00:43:04,720 --> 00:43:07,359
i was

00:43:05,599 --> 00:43:08,800
thinking about a lot of the ideas that

00:43:07,359 --> 00:43:11,280
baku offers yeah

00:43:08,800 --> 00:43:13,040
how would that work for us um i think

00:43:11,280 --> 00:43:14,880
rocco is a little bit too promiscuous

00:43:13,040 --> 00:43:18,640
with its slot data

00:43:14,880 --> 00:43:19,200
um so that's one thing which i think

00:43:18,640 --> 00:43:20,720
core

00:43:19,200 --> 00:43:24,000
actually doesn't karina does a better

00:43:20,720 --> 00:43:27,119
job on uh however

00:43:24,000 --> 00:43:29,839
oh i i want this they're hashes and

00:43:27,119 --> 00:43:31,119
lists they're arrayed they don't flat

00:43:29,839 --> 00:43:34,400
when you pass them

00:43:31,119 --> 00:43:37,599
so raku can actually declare

00:43:34,400 --> 00:43:39,520
an array or a hash as a slot which

00:43:37,599 --> 00:43:42,079
i believe object pad can but we can't

00:43:39,520 --> 00:43:45,119
attach attributes to it really because

00:43:42,079 --> 00:43:46,480
how do you pass in an array into the

00:43:45,119 --> 00:43:47,839
constructor well you pass it

00:43:46,480 --> 00:43:49,599
as an array wrap well why didn't you

00:43:47,839 --> 00:43:51,440
declare it as an array ref

00:43:49,599 --> 00:43:53,200
what does it mean if you're trying to

00:43:51,440 --> 00:43:55,040
return that array it's

00:43:53,200 --> 00:43:57,440
there's all sorts of funky little

00:43:55,040 --> 00:43:59,440
confusions the languages don't quite

00:43:57,440 --> 00:44:00,880
fit together because raku has fixed a

00:43:59,440 --> 00:44:04,560
lot of the problems that

00:44:00,880 --> 00:44:07,520
pearl has and

00:44:04,560 --> 00:44:08,000
because of that you they look very

00:44:07,520 --> 00:44:10,240
similar

00:44:08,000 --> 00:44:11,040
actually i have uh one example i often

00:44:10,240 --> 00:44:14,560
use is

00:44:11,040 --> 00:44:17,119
uh an lru cache that i wrote in karina

00:44:14,560 --> 00:44:17,680
i also wrote that in raku and they look

00:44:17,119 --> 00:44:19,760
almost

00:44:17,680 --> 00:44:21,520
identical uh just very little

00:44:19,760 --> 00:44:23,440
differences one thing about raku which

00:44:21,520 --> 00:44:26,560
is uh definitely different is raku

00:44:23,440 --> 00:44:27,200
well aside from using uh dots for method

00:44:26,560 --> 00:44:29,280
indication

00:44:27,200 --> 00:44:30,800
we're using we're sticking with arrows

00:44:29,280 --> 00:44:31,760
um because we're trying to keep this

00:44:30,800 --> 00:44:33,599
pearl

00:44:31,760 --> 00:44:35,520
and also dots it turns out there's all

00:44:33,599 --> 00:44:36,240
sorts of problems if you try and switch

00:44:35,520 --> 00:44:39,440
that

00:44:36,240 --> 00:44:43,119
um but the other thing is um

00:44:39,440 --> 00:44:43,839
i like twiddles that secondary bit of

00:44:43,119 --> 00:44:46,400
punctuation

00:44:43,839 --> 00:44:47,359
but i've argued vehemently against them

00:44:46,400 --> 00:44:48,560
for a long time

00:44:47,359 --> 00:44:50,319
even though many people have tried to

00:44:48,560 --> 00:44:52,079
put that in there simply because uh

00:44:50,319 --> 00:44:54,319
there's this perception of pearl has

00:44:52,079 --> 00:44:55,839
too much syntax and i didn't want to or

00:44:54,319 --> 00:44:57,280
so too much punctuation but i didn't

00:44:55,839 --> 00:44:57,680
want to add more punctuation on top of

00:44:57,280 --> 00:44:59,200
that

00:44:57,680 --> 00:45:01,119
so that's also another difference

00:44:59,200 --> 00:45:05,839
between what karina offers and what

00:45:01,119 --> 00:45:05,839
rocky was

00:45:08,319 --> 00:45:12,560
you're welcome uh thank you thank you

00:45:10,319 --> 00:45:15,359
for that that was great

00:45:12,560 --> 00:45:16,560
okay trying to see if there's anything

00:45:15,359 --> 00:45:18,720
else

00:45:16,560 --> 00:45:21,119
or someone wants to pop up with a

00:45:18,720 --> 00:45:21,119
question

00:45:21,440 --> 00:45:26,160
i have a question yes

00:45:24,560 --> 00:45:26,960
uh this is just an idea off the top of

00:45:26,160 --> 00:45:28,079
my head and haven't really thought

00:45:26,960 --> 00:45:29,280
through the implications so it might be

00:45:28,079 --> 00:45:31,599
a bad idea but

00:45:29,280 --> 00:45:33,280
you said that the class method dollar

00:45:31,599 --> 00:45:34,880
sign itself would be forbidden cause

00:45:33,280 --> 00:45:36,800
compile time error

00:45:34,880 --> 00:45:38,000
is there any reason not to just allow

00:45:36,800 --> 00:45:40,480
dolly science health to

00:45:38,000 --> 00:45:41,599
be valid inside class methods also if

00:45:40,480 --> 00:45:42,079
you call it from outside the class

00:45:41,599 --> 00:45:43,359
methods

00:45:42,079 --> 00:45:45,119
from like main code or something it

00:45:43,359 --> 00:45:46,079
would just be on deaf and if you call a

00:45:45,119 --> 00:45:48,480
thunderclass method

00:45:46,079 --> 00:45:50,079
it could be defined and call back and

00:45:48,480 --> 00:45:51,200
forth between class and instance methods

00:45:50,079 --> 00:45:54,720
without

00:45:51,200 --> 00:45:58,079
having it be two separate worlds ah

00:45:54,720 --> 00:45:58,079
i i see what you're saying that's

00:45:59,520 --> 00:46:02,720
and they could choose to check if it's

00:46:00,800 --> 00:46:04,000
undeath and throw an error if you try to

00:46:02,720 --> 00:46:07,680
call an instance method when

00:46:04,000 --> 00:46:07,680
you don't have one defined

00:46:08,319 --> 00:46:13,280
you know i find that a very annoying

00:46:10,319 --> 00:46:15,280
question because i don't have an answer

00:46:13,280 --> 00:46:16,720
uh don't think about it for later maybe

00:46:15,280 --> 00:46:20,960
no i i appreciate that

00:46:16,720 --> 00:46:21,680
um there's there's pros and cons if we

00:46:20,960 --> 00:46:23,599
don't allow

00:46:21,680 --> 00:46:25,200
dollar self inside of a class method

00:46:23,599 --> 00:46:27,200
then we get the possibility of having

00:46:25,200 --> 00:46:30,560
those compile time failures

00:46:27,200 --> 00:46:32,480
um but is that enough of a whim

00:46:30,560 --> 00:46:33,599
but what does it mean if i call a class

00:46:32,480 --> 00:46:36,800
method from

00:46:33,599 --> 00:46:40,560
an instance method and therefore

00:46:36,800 --> 00:46:42,400
i haven't because it would be nice if

00:46:40,560 --> 00:46:43,920
you could

00:46:42,400 --> 00:46:45,440
you can't of course you can call the

00:46:43,920 --> 00:46:46,480
class method for business method but you

00:46:45,440 --> 00:46:47,280
just i'm talking about the other way

00:46:46,480 --> 00:46:48,560
around

00:46:47,280 --> 00:46:50,240
once you call it from the instance

00:46:48,560 --> 00:46:51,680
method can you then call another

00:46:50,240 --> 00:46:53,680
instance method from the class method

00:46:51,680 --> 00:46:54,800
you called from an instance that's the

00:46:53,680 --> 00:46:57,440
thing that seems like you would be

00:46:54,800 --> 00:47:00,400
blocking now but maybe you could allow

00:46:57,440 --> 00:47:01,359
that that doesn't work in any language

00:47:00,400 --> 00:47:04,240
that i'm aware of

00:47:01,359 --> 00:47:06,400
because i know but why not do something

00:47:04,240 --> 00:47:06,400
new

00:47:07,520 --> 00:47:11,119
well at that point you've not got a

00:47:09,760 --> 00:47:12,880
class method what you've got is

00:47:11,119 --> 00:47:14,640
a method an instance called a hybrid

00:47:12,880 --> 00:47:17,040
method well

00:47:14,640 --> 00:47:18,480
what what point why would it's an

00:47:17,040 --> 00:47:21,359
instance method you can call without an

00:47:18,480 --> 00:47:23,680
instance of the object that's what it is

00:47:21,359 --> 00:47:25,359
what you sort of have in pearl oo anyway

00:47:23,680 --> 00:47:28,960
because you can call it on the class

00:47:25,359 --> 00:47:31,200
itself or on an object right but

00:47:28,960 --> 00:47:32,079
that's simply because pearl does a very

00:47:31,200 --> 00:47:33,760
good i don't know but

00:47:32,079 --> 00:47:35,280
eventually it does a bad job of type

00:47:33,760 --> 00:47:36,160
checking it just doesn't do anything

00:47:35,280 --> 00:47:38,160
with that

00:47:36,160 --> 00:47:40,079
it does give you you know an ability to

00:47:38,160 --> 00:47:41,760
make a dual method that's both

00:47:40,079 --> 00:47:43,280
callable from outside the class and from

00:47:41,760 --> 00:47:44,720
an instance

00:47:43,280 --> 00:47:46,800
i think you would have to make a strong

00:47:44,720 --> 00:47:50,240
cases where we would need that

00:47:46,800 --> 00:47:50,559
to why that would be more valuable than

00:47:50,240 --> 00:47:53,280
the

00:47:50,559 --> 00:47:54,880
safety we would get well how about only

00:47:53,280 --> 00:47:58,079
enable it with a keyword perhaps

00:47:54,880 --> 00:47:58,079
if you have some reason to want to do

00:47:58,800 --> 00:48:04,079
ah wait i know there's a new rfc process

00:48:02,880 --> 00:48:06,800
for pearl

00:48:04,079 --> 00:48:08,720
and once karina goes in met by one and

00:48:06,800 --> 00:48:12,160
then all right

00:48:08,720 --> 00:48:14,480
that that i think it's actually

00:48:12,160 --> 00:48:15,599
it was a dodge but i think the rfc

00:48:14,480 --> 00:48:18,240
process works well

00:48:15,599 --> 00:48:19,520
i think that um is probably the right

00:48:18,240 --> 00:48:21,760
way going forward

00:48:19,520 --> 00:48:22,640
that's a good way to allow people to see

00:48:21,760 --> 00:48:25,920
those

00:48:22,640 --> 00:48:27,040
and to discuss them because it if karina

00:48:25,920 --> 00:48:29,359
gets into core

00:48:27,040 --> 00:48:30,960
i'm going to be you know pitching rfcs

00:48:29,359 --> 00:48:32,480
for these are new things that i want

00:48:30,960 --> 00:48:34,640
because i won't be able to mandate this

00:48:32,480 --> 00:48:36,160
i don't get to have control over this

00:48:34,640 --> 00:48:37,359
paul's not going to get to have control

00:48:36,160 --> 00:48:39,280
you get one chance at it and then it

00:48:37,359 --> 00:48:44,079
goes in the core

00:48:39,280 --> 00:48:48,240
yeah any other questions

00:48:44,079 --> 00:48:50,400
i have a small question um yes uh

00:48:48,240 --> 00:48:51,839
are we maybe you have mentioned this

00:48:50,400 --> 00:48:54,960
before but um

00:48:51,839 --> 00:48:57,839
are we expecting uh classes defined

00:48:54,960 --> 00:48:59,440
with this new method uh to be in any way

00:48:57,839 --> 00:49:01,599
compatible with the ones that use

00:48:59,440 --> 00:49:03,280
bliss or are they supposed to just live

00:49:01,599 --> 00:49:05,040
in separate worlds

00:49:03,280 --> 00:49:06,640
currently with object pad you can

00:49:05,040 --> 00:49:09,040
inherit um

00:49:06,640 --> 00:49:09,680
i think for purina we want to forbid

00:49:09,040 --> 00:49:11,680
that and

00:49:09,680 --> 00:49:13,599
here's what's going on with that there's

00:49:11,680 --> 00:49:15,760
there's nice work around them

00:49:13,599 --> 00:49:17,599
we want to forbid that because karina

00:49:15,760 --> 00:49:20,480
potentially has a different

00:49:17,599 --> 00:49:21,040
uh universal base class which could

00:49:20,480 --> 00:49:24,079
provide

00:49:21,040 --> 00:49:25,440
uh improved capabilities in a way that

00:49:24,079 --> 00:49:27,359
we've not been able to do

00:49:25,440 --> 00:49:28,720
with the core object system but then if

00:49:27,359 --> 00:49:30,880
i'm going to inherit from

00:49:28,720 --> 00:49:32,559
a blessed object instead of a karina

00:49:30,880 --> 00:49:35,359
object

00:49:32,559 --> 00:49:36,880
what base class wins so all of a sudden

00:49:35,359 --> 00:49:39,119
that starts

00:49:36,880 --> 00:49:40,960
karina is going to expect that you know

00:49:39,119 --> 00:49:41,680
if i have these extended capabilities my

00:49:40,960 --> 00:49:43,760
base class

00:49:41,680 --> 00:49:45,119
but she inherits from another class you

00:49:43,760 --> 00:49:46,559
know all of a sudden she doesn't get

00:49:45,119 --> 00:49:49,839
those anymore

00:49:46,559 --> 00:49:51,359
the simple work around and i'm trying to

00:49:49,839 --> 00:49:53,680
figure out the best way of doing this

00:49:51,359 --> 00:49:54,800
is basically you instantiate what would

00:49:53,680 --> 00:49:57,440
be your parent class

00:49:54,800 --> 00:49:58,880
you put it in a slot and the methods

00:49:57,440 --> 00:50:00,400
that you need from that class you

00:49:58,880 --> 00:50:02,079
delegate to

00:50:00,400 --> 00:50:04,079
and we might allow a one-time exception

00:50:02,079 --> 00:50:06,640
for the colon handles attribute

00:50:04,079 --> 00:50:08,000
instead of listing uh the methods that

00:50:06,640 --> 00:50:10,079
that get delegated off

00:50:08,000 --> 00:50:11,760
is i put an asterisk in there which

00:50:10,079 --> 00:50:13,520
would be karina's version

00:50:11,760 --> 00:50:15,200
something similar to an auto load but

00:50:13,520 --> 00:50:15,920
what it's saying is anything i don't

00:50:15,200 --> 00:50:18,880
know

00:50:15,920 --> 00:50:20,720
let this class try and handle and if

00:50:18,880 --> 00:50:21,520
that class can't handle it then it blows

00:50:20,720 --> 00:50:23,440
up

00:50:21,520 --> 00:50:24,960
so that effectively gets you inheritance

00:50:23,440 --> 00:50:26,400
but with composition

00:50:24,960 --> 00:50:28,000
instead of inheritance which a lot of

00:50:26,400 --> 00:50:31,040
people agree is nicer

00:50:28,000 --> 00:50:34,800
and it also ensures that karina has

00:50:31,040 --> 00:50:36,480
uh her base class safely available

00:50:34,800 --> 00:50:38,720
but we don't know if we're gonna do that

00:50:36,480 --> 00:50:38,720
yet

00:50:38,880 --> 00:50:42,319
but the nice thing is if we say karina

00:50:41,119 --> 00:50:45,440
cannot inherit from

00:50:42,319 --> 00:50:45,839
non-pro classes we can change our minds

00:50:45,440 --> 00:50:48,960
later

00:50:45,839 --> 00:50:49,440
if we say it can inherit from num if we

00:50:48,960 --> 00:50:51,920
say

00:50:49,440 --> 00:50:54,240
it can inherit sorry for blessed vest if

00:50:51,920 --> 00:50:55,920
it can inherit from blessed classes

00:50:54,240 --> 00:50:58,880
we can't take that away later if it

00:50:55,920 --> 00:51:00,640
turns out to be a mistake

00:50:58,880 --> 00:51:01,920
uh question does green aim to render old

00:51:00,640 --> 00:51:03,280
object systems redundant

00:51:01,920 --> 00:51:04,480
green is not trying to change anything

00:51:03,280 --> 00:51:06,160
i'm not trying to take away bless i'm

00:51:04,480 --> 00:51:07,520
not trying to remove loose smooth or

00:51:06,160 --> 00:51:08,640
anything like that i don't want to make

00:51:07,520 --> 00:51:10,400
anything redundant

00:51:08,640 --> 00:51:11,839
i want to offer a way forward so that we

00:51:10,400 --> 00:51:13,040
have something which is safer to use

00:51:11,839 --> 00:51:14,240
it's easier to use it's going to be

00:51:13,040 --> 00:51:15,359
faster it's going to provide better

00:51:14,240 --> 00:51:18,079
encapsulation

00:51:15,359 --> 00:51:18,800
and it's the defaults in korean are

00:51:18,079 --> 00:51:20,720
designed

00:51:18,800 --> 00:51:22,319
to follow what we know about many boho

00:51:20,720 --> 00:51:25,680
best practices

00:51:22,319 --> 00:51:27,520
so it's a better way of writing this but

00:51:25,680 --> 00:51:29,040
if you want to use moose or you want to

00:51:27,520 --> 00:51:31,839
use bless well

00:51:29,040 --> 00:51:31,839
do it that's fine

00:51:34,640 --> 00:51:37,839
any other questions

00:51:38,480 --> 00:51:42,720
if it's not going to be a definite that

00:51:40,240 --> 00:51:46,319
it cannot that it can um

00:51:42,720 --> 00:51:48,079
cross uh inherit with the

00:51:46,319 --> 00:51:50,400
standard pearl objects what if you just

00:51:48,079 --> 00:51:52,319
had it so that the current object could

00:51:50,400 --> 00:51:54,240
occur an object i guess could um

00:51:52,319 --> 00:51:56,800
explicitly inherit universal to enable

00:51:54,240 --> 00:51:56,800
that or something

00:52:00,800 --> 00:52:04,000
i don't think we want to go there yet

00:52:02,319 --> 00:52:07,200
because that's one of the things that

00:52:04,000 --> 00:52:08,319
if we when we first launch korea

00:52:07,200 --> 00:52:09,520
of course it's going to be alpha we're

00:52:08,319 --> 00:52:10,640
going to say okay we're going to change

00:52:09,520 --> 00:52:12,240
the things we need to

00:52:10,640 --> 00:52:14,079
but it's very dangerous to publish

00:52:12,240 --> 00:52:15,520
something publish an interface

00:52:14,079 --> 00:52:17,040
and then people start relying on the

00:52:15,520 --> 00:52:18,079
interface when you realize you've made a

00:52:17,040 --> 00:52:20,800
mistake

00:52:18,079 --> 00:52:22,640
you it's hard to back out and you lose

00:52:20,800 --> 00:52:23,920
the trust of your users it's one of the

00:52:22,640 --> 00:52:24,640
things we talk about all the time with

00:52:23,920 --> 00:52:25,920
objects

00:52:24,640 --> 00:52:27,920
they're open for extension not

00:52:25,920 --> 00:52:31,280
modification um

00:52:27,920 --> 00:52:33,520
so i'm very very concerned

00:52:31,280 --> 00:52:35,680
about that so i appreciate what you're

00:52:33,520 --> 00:52:37,359
saying and i'm not saying no

00:52:35,680 --> 00:52:39,680
but i'm trying to see how much can i

00:52:37,359 --> 00:52:41,119
take away like karina first pass

00:52:39,680 --> 00:52:43,119
probably i think it's a lot safer to

00:52:41,119 --> 00:52:45,599
have a single inheritance

00:52:43,119 --> 00:52:46,640
you get rid of the mro problems that we

00:52:45,599 --> 00:52:48,800
have

00:52:46,640 --> 00:52:50,960
um we don't have to worry about c3 we've

00:52:48,800 --> 00:52:54,400
got roles to

00:52:50,960 --> 00:52:57,760
deal with to solve the problems that

00:52:54,400 --> 00:53:00,319
multiple inheritance used to solve

00:52:57,760 --> 00:53:01,760
so and that means we could add multiple

00:53:00,319 --> 00:53:02,880
inheritance later if we want to

00:53:01,760 --> 00:53:04,880
but if we start with multiple

00:53:02,880 --> 00:53:07,359
inheritance we can't take it away

00:53:04,880 --> 00:53:09,040
so it's the same thing yeah i i've i've

00:53:07,359 --> 00:53:09,839
already got single inheritance in object

00:53:09,040 --> 00:53:11,599
pad as well

00:53:09,839 --> 00:53:13,520
and that that makes the implementation

00:53:11,599 --> 00:53:15,280
so much simpler and again as you say

00:53:13,520 --> 00:53:16,400
with once you've got roles you kind of

00:53:15,280 --> 00:53:19,599
don't need mi

00:53:16,400 --> 00:53:22,319
like any of the places where in

00:53:19,599 --> 00:53:23,839
in existing perl i have used mi it's

00:53:22,319 --> 00:53:24,400
only because i didn't actually have

00:53:23,839 --> 00:53:26,319
roles

00:53:24,400 --> 00:53:28,400
and i found as i've been rewriting more

00:53:26,319 --> 00:53:30,559
of my code to using object pad

00:53:28,400 --> 00:53:32,000
i just go well actually this is a role

00:53:30,559 --> 00:53:32,559
and it just makes the code neater like

00:53:32,000 --> 00:53:35,760
i've never

00:53:32,559 --> 00:53:35,760
actually needed mi

00:53:40,559 --> 00:53:45,440
i think that covers that um uh looks

00:53:43,440 --> 00:53:48,319
like we're running out of time

00:53:45,440 --> 00:53:50,160
um i don't know who the moderator is do

00:53:48,319 --> 00:53:51,599
i have time for more questions or do we

00:53:50,160 --> 00:53:52,400
need to shut this down or how does this

00:53:51,599 --> 00:53:54,960
work

00:53:52,400 --> 00:53:57,839
uh we should probably set it down in a

00:53:54,960 --> 00:53:57,839
couple minutes

00:53:58,640 --> 00:54:02,400
i think it shuts down automatically i

00:54:01,520 --> 00:54:05,760
don't okay

00:54:02,400 --> 00:54:06,400
i don't know that that's true todd asked

00:54:05,760 --> 00:54:08,160
me to

00:54:06,400 --> 00:54:10,880
explicitly shut it down and let him know

00:54:08,160 --> 00:54:11,760
when i did that okay so let's see if we

00:54:10,880 --> 00:54:14,559
can get another question

00:54:11,760 --> 00:54:14,559
if anyone has it

00:54:22,480 --> 00:54:26,160
okay it sounds like we're in a good

00:54:24,079 --> 00:54:27,440
place uh the link to the wiki

00:54:26,160 --> 00:54:29,200
the link to the wiki had been set out

00:54:27,440 --> 00:54:30,400
where we had the slides so mine's on

00:54:29,200 --> 00:54:32,480
slideshare

00:54:30,400 --> 00:54:34,160
so go check the wiki for the links to

00:54:32,480 --> 00:54:35,760
all the presentations uh on

00:54:34,160 --> 00:54:37,680
day three i believe so you'll see that

00:54:35,760 --> 00:54:39,920
down there and you can go and check

00:54:37,680 --> 00:54:41,680
the version which is on slideshare is a

00:54:39,920 --> 00:54:43,280
touch older than this one but not much

00:54:41,680 --> 00:54:44,160
older it's more or less the same thing

00:54:43,280 --> 00:54:47,119
so

00:54:44,160 --> 00:54:48,319
there's information uh that you missed

00:54:47,119 --> 00:54:51,359
you can see it there

00:54:48,319 --> 00:54:52,319
if you have questions later go ahead and

00:54:51,359 --> 00:54:55,520
contact me

00:54:52,319 --> 00:54:58,960
uh there's also the if you're on

00:54:55,520 --> 00:55:01,359
uh which irc server is it uh

00:54:58,960 --> 00:55:03,200
paul for the karina channel is it irc

00:55:01,359 --> 00:55:06,160
pearl.org

00:55:03,200 --> 00:55:08,240
uh probably yeah let me just check uh uh

00:55:06,160 --> 00:55:10,960
yeah it's on irc.com

00:55:08,240 --> 00:55:12,160
so yeah if you go to irc.org you can

00:55:10,960 --> 00:55:14,000
join the core channel

00:55:12,160 --> 00:55:15,680
it found cor because karina used to be

00:55:14,000 --> 00:55:18,160
called court

00:55:15,680 --> 00:55:19,359
you can ask questions there of people if

00:55:18,160 --> 00:55:22,720
you know when i'm on

00:55:19,359 --> 00:55:23,119
uh you can email me or you can visit the

00:55:22,720 --> 00:55:25,920
uh

00:55:23,119 --> 00:55:26,240
wiki which i have out there for checking

00:55:25,920 --> 00:55:28,319
out

00:55:26,240 --> 00:55:29,599
what's available on the latest stuff on

00:55:28,319 --> 00:55:30,880
core i haven't updated that for a while

00:55:29,599 --> 00:55:33,359
though i have started

00:55:30,880 --> 00:55:34,400
to work on the rfc so even the rfc is

00:55:33,359 --> 00:55:36,400
going to be public

00:55:34,400 --> 00:55:37,520
so you can go out there and start

00:55:36,400 --> 00:55:40,319
looking at

00:55:37,520 --> 00:55:40,880
the very very beginnings of that rfc

00:55:40,319 --> 00:55:42,240
it's

00:55:40,880 --> 00:55:44,559
it's going to take a while to put

00:55:42,240 --> 00:55:44,559
together

00:55:47,280 --> 00:55:51,359
anything else before i say goodbye

00:55:55,520 --> 00:56:03,839
okay oh thank you jj i appreciate that

00:55:58,960 --> 00:56:03,839

YouTube URL: https://www.youtube.com/watch?v=FO5ift28RyE


