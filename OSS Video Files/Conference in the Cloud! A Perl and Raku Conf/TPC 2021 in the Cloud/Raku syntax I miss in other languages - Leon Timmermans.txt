Title: Raku syntax I miss in other languages - Leon Timmermans
Publication date: 2021-06-08
Playlist: TPC 2021 in the Cloud
Description: 
	I will walk you through some of my favorite unique or unusual features raku features that help in making your code easier to read and write

This includes (but isn't limited to): junctions, named arguments, pointy blocks, smartmatch (really, hear me out) and a few moreâ€¦
Captions: 
	00:00:00,799 --> 00:00:04,319
okay welcome everyone i'm gonna talk

00:00:03,679 --> 00:00:07,839
about

00:00:04,319 --> 00:00:11,679
raccoon syntax i miss in other languages

00:00:07,839 --> 00:00:12,960
and um in particular i'm gonna focus on

00:00:11,679 --> 00:00:16,400
features that help

00:00:12,960 --> 00:00:21,199
with making code more self-describing

00:00:16,400 --> 00:00:25,359
and in my experience doing so

00:00:21,199 --> 00:00:28,480
is often a matter of how versus what

00:00:25,359 --> 00:00:29,199
o code is a description of how it works

00:00:28,480 --> 00:00:30,960
because

00:00:29,199 --> 00:00:33,120
a computer can interpret it and

00:00:30,960 --> 00:00:36,239
computers operate on

00:00:33,120 --> 00:00:37,440
that level but good code is also a good

00:00:36,239 --> 00:00:40,239
description of

00:00:37,440 --> 00:00:40,239
what it does

00:00:41,680 --> 00:00:45,039
and a good example of this would be

00:00:43,840 --> 00:00:47,840
junctions

00:00:45,039 --> 00:00:48,879
what are junctions junctions are

00:00:47,840 --> 00:00:52,480
operations

00:00:48,879 --> 00:00:55,920
that are both are distributive

00:00:52,480 --> 00:00:59,359
until they do a boolean operation

00:00:55,920 --> 00:01:00,000
but what does that mean distributive

00:00:59,359 --> 00:01:03,199
means that

00:01:00,000 --> 00:01:06,240
any a b is bigger than two

00:01:03,199 --> 00:01:06,960
is equivalent to any a is bigger than

00:01:06,240 --> 00:01:10,080
two

00:01:06,960 --> 00:01:10,080
b is bigger than c

00:01:10,479 --> 00:01:15,680
and it is distributive over almost any

00:01:13,600 --> 00:01:19,600
operation in the language

00:01:15,680 --> 00:01:21,840
so for example hash any keys

00:01:19,600 --> 00:01:22,640
is identical to any hash keys

00:01:21,840 --> 00:01:24,880
distributive

00:01:22,640 --> 00:01:26,320
means that the order of operations

00:01:24,880 --> 00:01:29,920
doesn't actually matter

00:01:26,320 --> 00:01:30,320
for the end results it's just a matter

00:01:29,920 --> 00:01:33,439
of

00:01:30,320 --> 00:01:33,920
which one is more expressive or useful

00:01:33,439 --> 00:01:37,600
in this

00:01:33,920 --> 00:01:39,280
situation um

00:01:37,600 --> 00:01:41,439
the other half of it is the boolean

00:01:39,280 --> 00:01:44,479
operation because the one thing

00:01:41,439 --> 00:01:45,360
that a junction is not this well there

00:01:44,479 --> 00:01:47,759
are a few more

00:01:45,360 --> 00:01:49,200
but the one major thing that is not

00:01:47,759 --> 00:01:52,880
distributive over

00:01:49,200 --> 00:01:54,799
is bullification on bullification

00:01:52,880 --> 00:01:56,000
the the boolean operation of the

00:01:54,799 --> 00:01:59,920
junction which is

00:01:56,000 --> 00:02:03,439
any o one or none uh will be performed

00:01:59,920 --> 00:02:07,119
on the bag of values that it contains

00:02:03,439 --> 00:02:10,560
and that boolean is returned

00:02:07,119 --> 00:02:11,840
and in my experience there are two ways

00:02:10,560 --> 00:02:14,640
of using junctions

00:02:11,840 --> 00:02:17,120
that i call right side and left side i

00:02:14,640 --> 00:02:19,360
made these terms up myself no one else

00:02:17,120 --> 00:02:20,800
uses them but i think they're really

00:02:19,360 --> 00:02:24,480
good at describing

00:02:20,800 --> 00:02:26,239
how to use them i think

00:02:24,480 --> 00:02:29,760
all of you have written code like this

00:02:26,239 --> 00:02:33,040
right if value is 1 or a value is 2

00:02:29,760 --> 00:02:35,840
or value is 5.

00:02:33,040 --> 00:02:36,879
this is clear enough code but it's very

00:02:35,840 --> 00:02:40,160
repetitive

00:02:36,879 --> 00:02:42,000
and um well we all we all

00:02:40,160 --> 00:02:43,920
we none of uh none of us programmers

00:02:42,000 --> 00:02:47,280
like repetition

00:02:43,920 --> 00:02:51,680
so junctions allow you to write if value

00:02:47,280 --> 00:02:53,920
is any of one two or five

00:02:51,680 --> 00:02:55,120
and this i call this a right-hand

00:02:53,920 --> 00:02:58,239
junction

00:02:55,120 --> 00:03:01,519
because it tends to it tends to occur

00:02:58,239 --> 00:03:04,000
on the right side of a comparison

00:03:01,519 --> 00:03:05,120
you can also write this using the infix

00:03:04,000 --> 00:03:08,239
operator for f

00:03:05,120 --> 00:03:10,239
for any value is one or two or five

00:03:08,239 --> 00:03:12,959
which for right hand side i tend to

00:03:10,239 --> 00:03:15,519
prefer whereas for a left-hand side

00:03:12,959 --> 00:03:16,840
you you what you tend to use the

00:03:15,519 --> 00:03:20,879
functional

00:03:16,840 --> 00:03:24,239
form a left and left side junction

00:03:20,879 --> 00:03:27,840
is more loop like and tends to combine

00:03:24,239 --> 00:03:29,760
with a lot more operations for example

00:03:27,840 --> 00:03:32,239
imagine you have a list and you want to

00:03:29,760 --> 00:03:35,280
know is any of these values

00:03:32,239 --> 00:03:36,959
larger than 4 than 42.

00:03:35,280 --> 00:03:38,480
in a lesser programming language you

00:03:36,959 --> 00:03:40,159
would write a loop like this

00:03:38,480 --> 00:03:42,239
and i'm sure you've all read that and

00:03:40,159 --> 00:03:43,280
this is working perfectly fine but it's

00:03:42,239 --> 00:03:45,519
a lot of code

00:03:43,280 --> 00:03:47,280
for something that is very simple

00:03:45,519 --> 00:03:50,319
there's a lot of how in here

00:03:47,280 --> 00:03:52,640
that's obfuscating the watts

00:03:50,319 --> 00:03:53,680
in perl you would you probably use list

00:03:52,640 --> 00:03:56,000
any and

00:03:53,680 --> 00:03:58,319
you would write it like this if any

00:03:56,000 --> 00:04:01,280
dollar underscore bigger than two values

00:03:58,319 --> 00:04:01,840
which is a lot better because at least

00:04:01,280 --> 00:04:05,280
it is

00:04:01,840 --> 00:04:07,599
a single statement a single expression

00:04:05,280 --> 00:04:10,000
however it still has a bit of an awkward

00:04:07,599 --> 00:04:11,760
order because the values is at the end

00:04:10,000 --> 00:04:13,439
when it's actually a very important

00:04:11,760 --> 00:04:14,959
thing that you kind of want in the

00:04:13,439 --> 00:04:16,880
beginning

00:04:14,959 --> 00:04:19,680
using junctions you can write it like

00:04:16,880 --> 00:04:22,800
this if any of these values is bigger

00:04:19,680 --> 00:04:26,960
than 42. this

00:04:22,800 --> 00:04:29,440
very much self describes what it's doing

00:04:26,960 --> 00:04:31,919
um and i think junctions are a very

00:04:29,440 --> 00:04:34,320
powerful concept of writing code that

00:04:31,919 --> 00:04:35,919
this that in this way is very

00:04:34,320 --> 00:04:37,520
self-describing

00:04:35,919 --> 00:04:40,400
but you can't only use it with

00:04:37,520 --> 00:04:44,320
comparisons you can for example also say

00:04:40,400 --> 00:04:46,080
if one of these values is prime

00:04:44,320 --> 00:04:48,000
it's immediately clear what you're

00:04:46,080 --> 00:04:50,320
trying to achieve and how it work

00:04:48,000 --> 00:04:51,440
and the how of how the how behind is

00:04:50,320 --> 00:04:54,240
behind the curtains

00:04:51,440 --> 00:04:56,080
doesn't really matter likewise you can

00:04:54,240 --> 00:04:59,520
say if all of these values

00:04:56,080 --> 00:05:01,680
are dividable by three the visibility

00:04:59,520 --> 00:05:02,160
operator is another small nice raku

00:05:01,680 --> 00:05:04,160
feature

00:05:02,160 --> 00:05:06,400
that i do kind of miss in other

00:05:04,160 --> 00:05:10,320
languages

00:05:06,400 --> 00:05:13,440
um so yes junctions are great

00:05:10,320 --> 00:05:16,080
another great feature that i find

00:05:13,440 --> 00:05:18,000
makes my rocker code a lot more readable

00:05:16,080 --> 00:05:21,039
is named arguments

00:05:18,000 --> 00:05:23,440
and unlike most of my most of the

00:05:21,039 --> 00:05:26,000
features that i'm highlighting here

00:05:23,440 --> 00:05:27,199
named arguments are not necessarily

00:05:26,000 --> 00:05:29,280
uncommon there are

00:05:27,199 --> 00:05:31,600
a bunch of other languages that also

00:05:29,280 --> 00:05:32,479
have them but raku tends to do them

00:05:31,600 --> 00:05:36,840
differently

00:05:32,479 --> 00:05:41,039
in ways that i find are very helpful

00:05:36,840 --> 00:05:41,600
um and the basic syntax for it is

00:05:41,039 --> 00:05:44,400
usually

00:05:41,600 --> 00:05:45,440
colon name and then between parenthesis

00:05:44,400 --> 00:05:48,160
the value

00:05:45,440 --> 00:05:50,639
or the fat arrow syntax which is similar

00:05:48,160 --> 00:05:52,800
to what some of you may know from pearl

00:05:50,639 --> 00:05:54,720
and this is similar enough to other

00:05:52,800 --> 00:05:57,440
languages

00:05:54,720 --> 00:05:59,039
and in usage and in declaration you use

00:05:57,440 --> 00:06:02,080
the same colon which is

00:05:59,039 --> 00:06:05,759
has a very nice symmetry to it um

00:06:02,080 --> 00:06:08,560
so here you have a named argument foo

00:06:05,759 --> 00:06:09,360
then you pass it on and this way you can

00:06:08,560 --> 00:06:11,600
make your

00:06:09,360 --> 00:06:14,319
you can pass a bit of extra information

00:06:11,600 --> 00:06:18,080
in this function call

00:06:14,319 --> 00:06:21,840
um but that's not the only reason why

00:06:18,080 --> 00:06:24,479
this works so well on raku because

00:06:21,840 --> 00:06:26,800
uh in a lot of languages it named

00:06:24,479 --> 00:06:30,319
arguments have a lot of

00:06:26,800 --> 00:06:33,039
uh a lot of noise there's

00:06:30,319 --> 00:06:34,720
um there's a there's more there's like

00:06:33,039 --> 00:06:36,639
too much there's a lot of

00:06:34,720 --> 00:06:38,319
words for the information that are are

00:06:36,639 --> 00:06:41,520
placed past therefore there

00:06:38,319 --> 00:06:45,360
are a few uh shortcuts

00:06:41,520 --> 00:06:48,000
in particular colon foo

00:06:45,360 --> 00:06:49,360
has an implicit argument of true it's a

00:06:48,000 --> 00:06:53,520
short way of writing

00:06:49,360 --> 00:06:54,960
colon full true and this is very useful

00:06:53,520 --> 00:06:57,759
because in my experience

00:06:54,960 --> 00:06:59,840
boolean is the most common type of named

00:06:57,759 --> 00:07:03,199
arguments because named arguments are

00:06:59,840 --> 00:07:06,800
often used for optional parameters

00:07:03,199 --> 00:07:10,160
and likewise colon exclamation mark foo

00:07:06,800 --> 00:07:12,639
means passing false

00:07:10,160 --> 00:07:14,000
this is another fairly common value to

00:07:12,639 --> 00:07:17,199
pass as name arguments

00:07:14,000 --> 00:07:18,960
therefore it has a shorter form there's

00:07:17,199 --> 00:07:22,319
also a slightly shorter form

00:07:18,960 --> 00:07:23,440
for strings and what does this look like

00:07:22,319 --> 00:07:25,919
in practice

00:07:23,440 --> 00:07:28,479
well this is an example using my module

00:07:25,919 --> 00:07:31,440
called pathfinder for finding files

00:07:28,479 --> 00:07:32,000
for find files in theirs it must be a

00:07:31,440 --> 00:07:34,800
file

00:07:32,000 --> 00:07:37,440
it must have this extension and it must

00:07:34,800 --> 00:07:41,199
not be empty

00:07:37,440 --> 00:07:43,520
named arguments allow you to write down

00:07:41,199 --> 00:07:46,160
to write code in such a way that if you

00:07:43,520 --> 00:07:48,800
like literally say out loud what it says

00:07:46,160 --> 00:07:52,319
you know what it does without having to

00:07:48,800 --> 00:07:54,400
look up what any of these arguments do

00:07:52,319 --> 00:07:56,960
and that's why i'm a big fan of named

00:07:54,400 --> 00:07:56,960
arguments

00:07:57,199 --> 00:08:00,400
but there's another kind of repetition

00:07:59,919 --> 00:08:02,400
which

00:08:00,400 --> 00:08:03,759
tends to happen a lot when like you're

00:08:02,400 --> 00:08:06,080
passing on arguments

00:08:03,759 --> 00:08:07,120
and those arguments tend to have the

00:08:06,080 --> 00:08:09,520
same name

00:08:07,120 --> 00:08:12,000
and then you're writing like bar twice

00:08:09,520 --> 00:08:15,440
and past twice because twice

00:08:12,000 --> 00:08:16,800
and well like i said before repetition

00:08:15,440 --> 00:08:19,039
is annoying

00:08:16,800 --> 00:08:20,400
therefore there's this another great

00:08:19,039 --> 00:08:23,680
short form

00:08:20,400 --> 00:08:24,160
where you write colon dollar for four

00:08:23,680 --> 00:08:28,160
bar

00:08:24,160 --> 00:08:30,319
bass and this way you don't have to

00:08:28,160 --> 00:08:34,159
repeat yourself

00:08:30,319 --> 00:08:36,240
but this actually has another advantage

00:08:34,159 --> 00:08:38,399
because if you write your code this way

00:08:36,240 --> 00:08:40,320
then that's essentially forcing the code

00:08:38,399 --> 00:08:44,240
base to be very consistent

00:08:40,320 --> 00:08:44,240
in how it names its arguments

00:08:44,399 --> 00:08:47,920
because there is one way of naming your

00:08:46,720 --> 00:08:50,880
arguments

00:08:47,920 --> 00:08:54,399
that is actually working smoother than

00:08:50,880 --> 00:08:56,480
the others

00:08:54,399 --> 00:08:58,320
this is of course assuming that people

00:08:56,480 --> 00:09:02,080
who write whose libraries you use

00:08:58,320 --> 00:09:02,080
give their argument sensible names

00:09:02,640 --> 00:09:05,760
another favorite feature of mine is

00:09:04,399 --> 00:09:09,040
pointy blocks

00:09:05,760 --> 00:09:12,800
this may be a bit of surprising choice

00:09:09,040 --> 00:09:15,839
but i'll explain why in raku

00:09:12,800 --> 00:09:17,760
all blocks are callable all of them

00:09:15,839 --> 00:09:20,399
it's just that most of the time you

00:09:17,760 --> 00:09:22,880
don't need to think about them as such

00:09:20,399 --> 00:09:23,600
but they are and that also means that

00:09:22,880 --> 00:09:27,279
like that

00:09:23,600 --> 00:09:30,800
in theory all blocks can take arguments

00:09:27,279 --> 00:09:33,200
a good example of this is a for loop

00:09:30,800 --> 00:09:34,240
uh this should be clear enough for array

00:09:33,200 --> 00:09:37,600
loop

00:09:34,240 --> 00:09:39,600
for array go to ellen um

00:09:37,600 --> 00:09:41,279
the for loop actually doesn't have any

00:09:39,600 --> 00:09:43,760
special syntax it's just

00:09:41,279 --> 00:09:44,880
a four key word an expression and a

00:09:43,760 --> 00:09:48,080
pointy block

00:09:44,880 --> 00:09:51,839
this is very generic syntax that is

00:09:48,080 --> 00:09:54,000
still very powerful

00:09:51,839 --> 00:09:56,480
and i like pointy blocks for three

00:09:54,000 --> 00:09:59,279
different reasons

00:09:56,480 --> 00:10:00,560
one of them is ordering in a traditional

00:09:59,279 --> 00:10:02,560
ordering

00:10:00,560 --> 00:10:04,640
if you wanna if you wanna have an

00:10:02,560 --> 00:10:06,160
expression but want to store the value

00:10:04,640 --> 00:10:09,200
of the expression as well

00:10:06,160 --> 00:10:13,040
you have to write my if dollar value is

00:10:09,200 --> 00:10:15,839
fu that means that the expression foo

00:10:13,040 --> 00:10:16,880
that belongs with the if is is detached

00:10:15,839 --> 00:10:20,000
from the if

00:10:16,880 --> 00:10:22,240
and likewise this new variable

00:10:20,000 --> 00:10:25,839
that is conceptually attached to the

00:10:22,240 --> 00:10:30,000
block is far away from the block

00:10:25,839 --> 00:10:32,240
this ordering is wrong

00:10:30,000 --> 00:10:33,040
but with pointy blocks you can swap them

00:10:32,240 --> 00:10:35,200
around

00:10:33,040 --> 00:10:37,600
and the foo that refers to the

00:10:35,200 --> 00:10:40,480
conditionals actually adjacent

00:10:37,600 --> 00:10:42,720
to the if and the value that's as

00:10:40,480 --> 00:10:45,839
conceptually attached to the block

00:10:42,720 --> 00:10:47,680
is attached to the block

00:10:45,839 --> 00:10:49,120
second reason why i love this is

00:10:47,680 --> 00:10:51,200
signatures

00:10:49,120 --> 00:10:53,040
signatures are a very powerful feature

00:10:51,200 --> 00:10:55,360
in raku

00:10:53,040 --> 00:10:57,120
that i'm not going to talk much about if

00:10:55,360 --> 00:10:59,600
because i could

00:10:57,120 --> 00:11:00,399
spend an entire chapter on that too so

00:10:59,600 --> 00:11:02,560
for example

00:11:00,399 --> 00:11:04,640
in raku if you want to loop over two

00:11:02,560 --> 00:11:05,519
variables at a time you just give the

00:11:04,640 --> 00:11:08,880
pointy block

00:11:05,519 --> 00:11:10,720
to variables because four is smart

00:11:08,880 --> 00:11:14,959
enough to notice that and just do

00:11:10,720 --> 00:11:16,560
what you expect it to do and

00:11:14,959 --> 00:11:18,240
this this is this sort of thing is used

00:11:16,560 --> 00:11:20,480
in a lot of places

00:11:18,240 --> 00:11:22,560
another very powerful use that i'm

00:11:20,480 --> 00:11:26,000
personally very fond of

00:11:22,560 --> 00:11:29,120
is is using destructuring

00:11:26,000 --> 00:11:30,880
because naive like in in burlish raku

00:11:29,120 --> 00:11:32,720
you could write something like this you

00:11:30,880 --> 00:11:36,000
check if something matches and then you

00:11:32,720 --> 00:11:39,040
unpack dollar bondo or two whatever

00:11:36,000 --> 00:11:41,600
however you can directly

00:11:39,040 --> 00:11:42,720
pass that on to the to the block and

00:11:41,600 --> 00:11:45,519
then

00:11:42,720 --> 00:11:47,040
if this matches extract these values

00:11:45,519 --> 00:11:49,680
from the match

00:11:47,040 --> 00:11:52,240
you can express that in one go and i

00:11:49,680 --> 00:11:55,040
think that's a very powerful concept

00:11:52,240 --> 00:11:56,959
that translates to a lot of different

00:11:55,040 --> 00:11:57,839
problems because it's not only matches

00:11:56,959 --> 00:12:00,000
that do as well

00:11:57,839 --> 00:12:01,120
it's a lot of built-in types that do

00:12:00,000 --> 00:12:04,560
this well

00:12:01,120 --> 00:12:06,639
i mean an array would map to a

00:12:04,560 --> 00:12:08,480
an array would map positional arguments

00:12:06,639 --> 00:12:10,639
but you could have like a hash

00:12:08,480 --> 00:12:12,320
and those elements of the hash would map

00:12:10,639 --> 00:12:14,639
to like named arguments

00:12:12,320 --> 00:12:15,839
of the block those blocks can also have

00:12:14,639 --> 00:12:19,440
named arguments

00:12:15,839 --> 00:12:23,839
and a lot of types

00:12:19,440 --> 00:12:25,519
decompose the very sensible values

00:12:23,839 --> 00:12:27,920
the third advantage of this is the

00:12:25,519 --> 00:12:30,480
regularity

00:12:27,920 --> 00:12:32,240
raku is actually one of the few algol

00:12:30,480 --> 00:12:34,959
derived languages

00:12:32,240 --> 00:12:37,360
where the syntax of a for loop is

00:12:34,959 --> 00:12:39,200
actually the same as the syntax of init

00:12:37,360 --> 00:12:42,079
of an if statement except for the

00:12:39,200 --> 00:12:42,079
keyword itself

00:12:42,160 --> 00:12:46,880
i mean raku is a language with a lot of

00:12:44,320 --> 00:12:48,480
keywords but this complexity is actually

00:12:46,880 --> 00:12:51,360
managed because

00:12:48,480 --> 00:12:52,800
the syntax is very predictable because

00:12:51,360 --> 00:12:55,040
it keeps being the same

00:12:52,800 --> 00:12:57,200
all these keywords are either if like or

00:12:55,040 --> 00:13:01,200
else like

00:12:57,200 --> 00:13:03,440
and most most of them are if like

00:13:01,200 --> 00:13:04,839
um and this really helps in you know

00:13:03,440 --> 00:13:07,519
keeping raku

00:13:04,839 --> 00:13:10,639
readable another

00:13:07,519 --> 00:13:12,720
favorite feature of mine i know i hope

00:13:10,639 --> 00:13:15,600
i'm not going too fast

00:13:12,720 --> 00:13:17,519
is whatever code now here you see an

00:13:15,600 --> 00:13:20,240
example with you want to grab to a list

00:13:17,519 --> 00:13:22,000
of numbers

00:13:20,240 --> 00:13:23,839
and and here you see the pointy block

00:13:22,000 --> 00:13:26,160
that i explained before

00:13:23,839 --> 00:13:27,600
and this works fine this is perfectly

00:13:26,160 --> 00:13:30,000
valid for cool

00:13:27,600 --> 00:13:32,320
but it's kind of repetitive in using

00:13:30,000 --> 00:13:34,000
dollar and twice

00:13:32,320 --> 00:13:35,440
can we do can we make this more

00:13:34,000 --> 00:13:38,560
expressive well

00:13:35,440 --> 00:13:40,079
yes of course we can

00:13:38,560 --> 00:13:42,000
you can you we can use a default

00:13:40,079 --> 00:13:44,480
argument dollar underscore here which

00:13:42,000 --> 00:13:47,760
already makes it a lot shorter

00:13:44,480 --> 00:13:52,079
but can we make it even more expressive

00:13:47,760 --> 00:13:54,720
yes we can using using the whatever star

00:13:52,079 --> 00:13:56,959
we can just say grab for whatever bigger

00:13:54,720 --> 00:13:58,880
than two

00:13:56,959 --> 00:14:00,720
this is pretty much as close as you can

00:13:58,880 --> 00:14:02,160
guess to like the minimal possible

00:14:00,720 --> 00:14:06,399
syntax for like

00:14:02,160 --> 00:14:09,600
grabbing for like some comparison

00:14:06,399 --> 00:14:10,880
um of course it's it's also always a

00:14:09,600 --> 00:14:13,920
matter of

00:14:10,880 --> 00:14:17,040
uh there's more than one way to do it

00:14:13,920 --> 00:14:19,600
and this is not always the right way

00:14:17,040 --> 00:14:20,959
larry wall's famous for saying easy

00:14:19,600 --> 00:14:24,399
things should be easy

00:14:20,959 --> 00:14:27,040
and difficult things should be possible

00:14:24,399 --> 00:14:28,320
whatever code is a brilliant feature for

00:14:27,040 --> 00:14:31,519
making easy things

00:14:28,320 --> 00:14:33,440
easy you shouldn't go but you shouldn't

00:14:31,519 --> 00:14:34,079
use it for difficult things should be

00:14:33,440 --> 00:14:36,320
possible

00:14:34,079 --> 00:14:38,160
that's where pointy blocks are great

00:14:36,320 --> 00:14:41,839
because they have like

00:14:38,160 --> 00:14:41,839
they have they they

00:14:42,639 --> 00:14:48,639
um they tend to be less confusing if you

00:14:44,880 --> 00:14:48,639
have like more than one operator

00:14:51,440 --> 00:14:57,920
and then there are meta operators

00:14:55,040 --> 00:14:58,720
the meta operators sounds like a very

00:14:57,920 --> 00:15:02,160
esoteric

00:14:58,720 --> 00:15:05,760
subject to most people because it's well

00:15:02,160 --> 00:15:08,880
meta but actually

00:15:05,760 --> 00:15:12,079
it's not that unusual at all

00:15:08,880 --> 00:15:16,079
in fact all of you all

00:15:12,079 --> 00:15:18,800
of you have used meta operators before

00:15:16,079 --> 00:15:20,959
you see there is this one very famous

00:15:18,800 --> 00:15:25,440
class of meta operators known as

00:15:20,959 --> 00:15:29,360
augmented assignments in other words

00:15:25,440 --> 00:15:32,560
uh assignment meta operators a plus is

00:15:29,360 --> 00:15:34,800
b is a mata's assignment math operator

00:15:32,560 --> 00:15:37,279
on plus

00:15:34,800 --> 00:15:39,600
raku is not the first language deaf meta

00:15:37,279 --> 00:15:42,480
operators it just has a few more than

00:15:39,600 --> 00:15:42,480
other languages

00:15:42,560 --> 00:15:47,040
in particular the ones that i'm going to

00:15:44,399 --> 00:15:49,600
focus on and these are not the only ones

00:15:47,040 --> 00:15:50,639
are the list are list based meta

00:15:49,600 --> 00:15:52,880
operators

00:15:50,639 --> 00:15:55,120
because in my experience these add a lot

00:15:52,880 --> 00:15:55,600
of power to the language and provide a

00:15:55,120 --> 00:15:59,920
lot of

00:15:55,600 --> 00:16:03,519
very practical tools

00:15:59,920 --> 00:16:06,399
first of all there is reduction

00:16:03,519 --> 00:16:07,120
reduction meta operators aren't that new

00:16:06,399 --> 00:16:10,720
at all

00:16:07,120 --> 00:16:13,440
they're just fairly un uncommon apl had

00:16:10,720 --> 00:16:14,160
them and apl is like 40 or 50 years olds

00:16:13,440 --> 00:16:16,800
and then

00:16:14,160 --> 00:16:17,199
most people forgot about it settle had

00:16:16,800 --> 00:16:19,519
them

00:16:17,199 --> 00:16:21,600
and saddle is not very well known but it

00:16:19,519 --> 00:16:23,920
is a very influential language that

00:16:21,600 --> 00:16:27,199
influenced both haskell and python

00:16:23,920 --> 00:16:29,440
but not but somehow reduction operators

00:16:27,199 --> 00:16:31,839
not sure about haskell didn't become

00:16:29,440 --> 00:16:34,160
popular

00:16:31,839 --> 00:16:35,040
a reduction operator is essentially does

00:16:34,160 --> 00:16:38,160
a reduce

00:16:35,040 --> 00:16:38,720
or also known as a fold on it with an

00:16:38,160 --> 00:16:42,320
infix

00:16:38,720 --> 00:16:43,360
operator it takes a list of values and

00:16:42,320 --> 00:16:46,880
reduces that

00:16:43,360 --> 00:16:48,560
to one value in particular

00:16:46,880 --> 00:16:50,800
it's smart enough to respect the

00:16:48,560 --> 00:16:53,440
associativity of an operator

00:16:50,800 --> 00:16:55,040
if it's left associative which is almost

00:16:53,440 --> 00:16:57,120
all of them to be honest

00:16:55,040 --> 00:16:59,440
it will do a left fold from left to

00:16:57,120 --> 00:17:01,519
right if it's right associative

00:16:59,440 --> 00:17:03,199
if go go from right to left there's

00:17:01,519 --> 00:17:04,000
chain associative and will also

00:17:03,199 --> 00:17:07,120
correctly handle

00:17:04,000 --> 00:17:08,720
that so

00:17:07,120 --> 00:17:10,319
without matter reduction method

00:17:08,720 --> 00:17:11,199
operators you would do something like

00:17:10,319 --> 00:17:15,199
this my sum

00:17:11,199 --> 00:17:17,439
is reduce a plus b over a list

00:17:15,199 --> 00:17:19,199
but with the reduction method operator

00:17:17,439 --> 00:17:19,600
you can just use that you can just use

00:17:19,199 --> 00:17:21,839
this

00:17:19,600 --> 00:17:23,280
you can you can put the operator between

00:17:21,839 --> 00:17:25,600
square brackets

00:17:23,280 --> 00:17:26,319
and it will apply this operator to the

00:17:25,600 --> 00:17:29,760
entire

00:17:26,319 --> 00:17:33,280
list and return the resulting value

00:17:29,760 --> 00:17:35,360
and this is incredibly expressive

00:17:33,280 --> 00:17:38,640
and it's also actually very useful for a

00:17:35,360 --> 00:17:40,960
lot of very common operations

00:17:38,640 --> 00:17:43,039
for example i just showed you some can

00:17:40,960 --> 00:17:45,200
be expressed as a meta operator

00:17:43,039 --> 00:17:46,799
the product of a list can be expressed

00:17:45,200 --> 00:17:48,640
as a meta operator

00:17:46,799 --> 00:17:51,200
joining a bunch of strings can be

00:17:48,640 --> 00:17:53,760
expressed as a meta operator

00:17:51,200 --> 00:17:54,640
these are all very common common

00:17:53,760 --> 00:17:57,360
operations

00:17:54,640 --> 00:17:58,640
and their use is kind of only limited by

00:17:57,360 --> 00:18:01,200
the fact

00:17:58,640 --> 00:18:03,520
that some of these are already buildings

00:18:01,200 --> 00:18:05,360
anyway because they're so common

00:18:03,520 --> 00:18:06,799
but there are a lot of a lot of more a

00:18:05,360 --> 00:18:09,039
lot more interesting

00:18:06,799 --> 00:18:11,760
uses for meta up for deferred reduction

00:18:09,039 --> 00:18:13,840
meta operator for example

00:18:11,760 --> 00:18:16,160
if you want to know are all these values

00:18:13,840 --> 00:18:16,160
equal

00:18:16,240 --> 00:18:19,679
are these values sorted

00:18:19,760 --> 00:18:23,280
in most languages that requires multiple

00:18:22,000 --> 00:18:25,919
statements to

00:18:23,280 --> 00:18:28,559
actually figure that out if you don't

00:18:25,919 --> 00:18:30,160
have a function for it already in raku

00:18:28,559 --> 00:18:32,720
you can just express that in three

00:18:30,160 --> 00:18:32,720
characters

00:18:33,360 --> 00:18:37,440
likewise you can say is or you already

00:18:36,240 --> 00:18:39,440
likewise you can say

00:18:37,440 --> 00:18:41,200
you come and apply the or operator on

00:18:39,440 --> 00:18:42,080
the entire list to get the first true

00:18:41,200 --> 00:18:45,440
value

00:18:42,080 --> 00:18:45,440
it'll just do that for you

00:18:46,400 --> 00:18:50,799
reduction operators are very very

00:18:48,480 --> 00:18:52,799
pragmatic and very useful operators that

00:18:50,799 --> 00:18:56,880
have a lot of surprising uses

00:18:52,799 --> 00:18:59,200
once once you once you actually see them

00:18:56,880 --> 00:19:00,960
another favorite is the zip meta

00:18:59,200 --> 00:19:04,320
operator

00:19:00,960 --> 00:19:07,360
now whereas the reduction

00:19:04,320 --> 00:19:10,559
takes a takes a list and reduces that to

00:19:07,360 --> 00:19:13,600
one scalar value zip a zip operator

00:19:10,559 --> 00:19:18,080
takes two or more lists and

00:19:13,600 --> 00:19:19,679
transforms that into a new list

00:19:18,080 --> 00:19:22,080
that's what essentially all zip

00:19:19,679 --> 00:19:25,120
operators do they just differ in

00:19:22,080 --> 00:19:26,480
how they make the new list uh for

00:19:25,120 --> 00:19:29,600
example you can say

00:19:26,480 --> 00:19:30,320
one two three zip plus thirty twenty ten

00:19:29,600 --> 00:19:33,840
and then you get

00:19:30,320 --> 00:19:36,320
thirty one twenty to thirteen

00:19:33,840 --> 00:19:37,520
it applies this operation on like the

00:19:36,320 --> 00:19:39,520
first element of

00:19:37,520 --> 00:19:43,039
of both lists the second element of both

00:19:39,520 --> 00:19:45,120
lists the third element above please

00:19:43,039 --> 00:19:46,880
the most common use of this probably at

00:19:45,120 --> 00:19:50,080
least in my experience

00:19:46,880 --> 00:19:53,120
is that comma and in fact that coma is

00:19:50,080 --> 00:19:57,039
so common that the set operator without

00:19:53,120 --> 00:19:59,600
any specified operator will do that

00:19:57,039 --> 00:20:00,720
and why is it so useful because this

00:19:59,600 --> 00:20:03,919
allows you

00:20:00,720 --> 00:20:07,840
to loop over over two lists

00:20:03,919 --> 00:20:07,840
at the same time

00:20:08,320 --> 00:20:11,520
for situations where that are too

00:20:10,480 --> 00:20:14,640
complicated for

00:20:11,520 --> 00:20:18,080
just using a single operator

00:20:14,640 --> 00:20:20,640
here again you see a pointy block used

00:20:18,080 --> 00:20:22,799
to decompose these elements this creates

00:20:20,640 --> 00:20:24,080
a list of two element lists and you use

00:20:22,799 --> 00:20:26,000
a pointy block to

00:20:24,080 --> 00:20:29,919
decompose the elements of those new

00:20:26,000 --> 00:20:29,919
lists into two new scalar values

00:20:30,640 --> 00:20:34,240
this is incredibly useful and in a lot

00:20:33,360 --> 00:20:37,360
of languages

00:20:34,240 --> 00:20:40,080
it is really kind of ugly

00:20:37,360 --> 00:20:41,760
um you have to loop over the index of

00:20:40,080 --> 00:20:43,039
both of them and here you can just say i

00:20:41,760 --> 00:20:46,840
want a loop over a

00:20:43,039 --> 00:20:49,039
and b at the same time thank you very

00:20:46,840 --> 00:20:51,120
much

00:20:49,039 --> 00:20:52,080
another good use of this is you take a

00:20:51,120 --> 00:20:54,400
list of keys

00:20:52,080 --> 00:20:57,039
you take a list of values combine them

00:20:54,400 --> 00:20:57,039
into a hash

00:20:59,360 --> 00:21:04,000
also of course zip operators chain i

00:21:01,760 --> 00:21:05,679
mean i i used examples of like

00:21:04,000 --> 00:21:08,159
two lists here but you can also use

00:21:05,679 --> 00:21:10,559
three or four or five or six or however

00:21:08,159 --> 00:21:13,600
many you want

00:21:10,559 --> 00:21:17,360
that of course also means that you can

00:21:13,600 --> 00:21:20,640
reduce a zip operator

00:21:17,360 --> 00:21:23,760
and in fact reducing a zip operator

00:21:20,640 --> 00:21:26,799
is a useful thing to do because

00:21:23,760 --> 00:21:27,679
what this does is transpose a list of

00:21:26,799 --> 00:21:31,840
lists

00:21:27,679 --> 00:21:31,840
in three characters

00:21:33,760 --> 00:21:37,039
the third meta operator i'm going to

00:21:35,760 --> 00:21:40,480
talk about is a cross

00:21:37,039 --> 00:21:41,120
product now cross product permutes two

00:21:40,480 --> 00:21:43,280
lists

00:21:41,120 --> 00:21:44,559
that means it takes an upper it loops

00:21:43,280 --> 00:21:46,640
over

00:21:44,559 --> 00:21:48,000
over one list and then over the other

00:21:46,640 --> 00:21:49,679
and then the first list again

00:21:48,000 --> 00:21:53,679
and it produces all possible

00:21:49,679 --> 00:21:56,400
combinations of those two or more lists

00:21:53,679 --> 00:21:58,080
uh let's take for example uh this

00:21:56,400 --> 00:22:01,200
example you have a list three nine

00:21:58,080 --> 00:22:02,480
and a lift list uh two and ten and you

00:22:01,200 --> 00:22:05,760
want to

00:22:02,480 --> 00:22:07,280
take this all of the possible sums

00:22:05,760 --> 00:22:09,600
in most languages you would have to

00:22:07,280 --> 00:22:12,159
write this this is a lot of code for a

00:22:09,600 --> 00:22:15,440
fairly simple thing

00:22:12,159 --> 00:22:18,559
in raku you can just say 3 9

00:22:15,440 --> 00:22:19,440
cross plus 210 and this will this will

00:22:18,559 --> 00:22:23,120
return

00:22:19,440 --> 00:22:25,840
the list for you the all four values

00:22:23,120 --> 00:22:27,679
this is a very expressive way of saying

00:22:25,840 --> 00:22:29,360
this is this is what i want

00:22:27,679 --> 00:22:32,640
and you don't have to write all this

00:22:29,360 --> 00:22:36,559
code of how you get there

00:22:32,640 --> 00:22:36,559
i think that's very expressive

00:22:36,720 --> 00:22:42,480
surprisingly perhaps in my experience

00:22:40,640 --> 00:22:43,919
the most useful thing you can do with

00:22:42,480 --> 00:22:46,080
the cross operator

00:22:43,919 --> 00:22:48,640
actually only involves a list on one of

00:22:46,080 --> 00:22:52,000
the two sides

00:22:48,640 --> 00:22:52,799
because for example here if you have a

00:22:52,000 --> 00:22:54,799
list

00:22:52,799 --> 00:22:56,080
and you want to prefix a value to all

00:22:54,799 --> 00:22:58,240
elements of the list

00:22:56,080 --> 00:23:00,159
you can use a cross operator and a cross

00:22:58,240 --> 00:23:03,679
operator will just see that as a list of

00:23:00,159 --> 00:23:03,679
one element and do its thing

00:23:04,480 --> 00:23:09,120
again this this is somewhat this this is

00:23:07,840 --> 00:23:10,960
way easier than

00:23:09,120 --> 00:23:13,039
in any other language that i've ever

00:23:10,960 --> 00:23:14,960
seen

00:23:13,039 --> 00:23:17,679
the last meta operator that i want to

00:23:14,960 --> 00:23:21,200
talk about is hypers

00:23:17,679 --> 00:23:25,280
um the previous three examples were all

00:23:21,200 --> 00:23:28,080
meta operators on infix operators

00:23:25,280 --> 00:23:30,159
hypers also works on prefix and postfix

00:23:28,080 --> 00:23:31,919
operators

00:23:30,159 --> 00:23:33,760
which is actually their most interesting

00:23:31,919 --> 00:23:34,320
use you can kind of use hyper to

00:23:33,760 --> 00:23:36,880
implement

00:23:34,320 --> 00:23:38,000
like the others but that gets really

00:23:36,880 --> 00:23:41,200
confusing

00:23:38,000 --> 00:23:43,919
for example you can say lists hyper

00:23:41,200 --> 00:23:45,919
dot apps and it's the equivalent of say

00:23:43,919 --> 00:23:48,240
of mapping all values and getting their

00:23:45,919 --> 00:23:51,600
absolute value

00:23:48,240 --> 00:23:54,799
it's the same thing except less typing

00:23:51,600 --> 00:23:57,200
more extra more more expressive

00:23:54,799 --> 00:23:57,840
it works on prefix operators it works

00:23:57,200 --> 00:24:00,960
with

00:23:57,840 --> 00:24:02,720
with post post circumfix operators

00:24:00,960 --> 00:24:04,720
this is one of the more useful ones

00:24:02,720 --> 00:24:06,240
because actually i

00:24:04,720 --> 00:24:08,159
i tend to do this sort of thing a lot

00:24:06,240 --> 00:24:10,000
where i'm like i have some list or an

00:24:08,159 --> 00:24:12,080
object or whatever and i want one thing

00:24:10,000 --> 00:24:14,000
out of all of them

00:24:12,080 --> 00:24:18,559
one extra character and you can do that

00:24:14,000 --> 00:24:20,400
for all of them

00:24:18,559 --> 00:24:21,840
but let me give you an example of how to

00:24:20,400 --> 00:24:25,039
combine these

00:24:21,840 --> 00:24:28,400
um by by computing a

00:24:25,039 --> 00:24:28,400
an euclidean distance

00:24:28,880 --> 00:24:32,080
when you're computing euclidean distance

00:24:31,679 --> 00:24:34,640
you're

00:24:32,080 --> 00:24:36,799
you're taking the distance for f your

00:24:34,640 --> 00:24:38,320
euclidean distance is the distance over

00:24:36,799 --> 00:24:46,559
multiple dimensions the

00:24:38,320 --> 00:24:48,080
the complete distance for example when

00:24:46,559 --> 00:24:50,720
you're computing this you want to

00:24:48,080 --> 00:24:51,279
come first compute the distance for

00:24:50,720 --> 00:24:53,279
every

00:24:51,279 --> 00:24:54,559
every different dimension which you can

00:24:53,279 --> 00:24:57,600
you do using

00:24:54,559 --> 00:24:58,159
a zip operator then you want to square

00:24:57,600 --> 00:25:00,799
them

00:24:58,159 --> 00:25:02,240
you can do this using a hyper operator

00:25:00,799 --> 00:25:04,320
then you want to sum them

00:25:02,240 --> 00:25:06,240
we should do using a reduce operator and

00:25:04,320 --> 00:25:08,080
then just you square them

00:25:06,240 --> 00:25:10,080
this is a very practical algorithm

00:25:08,080 --> 00:25:13,440
that's for example used in like

00:25:10,080 --> 00:25:14,400
voting advice software and you can

00:25:13,440 --> 00:25:18,559
implement this

00:25:14,400 --> 00:25:20,799
in raku using a single expression

00:25:18,559 --> 00:25:22,480
i think that's really powerful and i it

00:25:20,799 --> 00:25:24,320
can be i mean i imagine

00:25:22,480 --> 00:25:25,760
if you have never seen if you've never

00:25:24,320 --> 00:25:28,320
programmed raku before

00:25:25,760 --> 00:25:30,640
you're like what's happening here but if

00:25:28,320 --> 00:25:33,679
you actually know these concepts

00:25:30,640 --> 00:25:34,000
then you can you can express things way

00:25:33,679 --> 00:25:37,120
more

00:25:34,000 --> 00:25:39,679
cleanly and like literally this is the

00:25:37,120 --> 00:25:43,840
entire algorithm described in

00:25:39,679 --> 00:25:43,840
one operator per step

00:25:46,080 --> 00:25:50,559
and lastly i want to talk about smart

00:25:48,000 --> 00:25:56,240
match now some of you may be thinking

00:25:50,559 --> 00:25:58,400
really smart match what are you smoking

00:25:56,240 --> 00:26:00,000
now that and if you're thinking that

00:25:58,400 --> 00:26:02,080
then you're probably a pro

00:26:00,000 --> 00:26:03,760
more of a pro programmer than a rock

00:26:02,080 --> 00:26:05,760
programmer because

00:26:03,760 --> 00:26:07,840
uh in perl it tends to have a bunch of

00:26:05,760 --> 00:26:11,279
issues but in raku it tends to work

00:26:07,840 --> 00:26:12,480
really really nicely because what smart

00:26:11,279 --> 00:26:15,840
match really does

00:26:12,480 --> 00:26:19,840
in practice is answer the question

00:26:15,840 --> 00:26:23,440
is a value part of this set of values

00:26:19,840 --> 00:26:26,400
is it this kind of value

00:26:23,440 --> 00:26:28,960
and in raku almost all building values

00:26:26,400 --> 00:26:30,960
are actually smart matchable

00:26:28,960 --> 00:26:32,400
so you can use them to answer the

00:26:30,960 --> 00:26:35,600
question is this value

00:26:32,400 --> 00:26:38,720
like this other value and

00:26:35,600 --> 00:26:39,120
in improv is mainly known for its use in

00:26:38,720 --> 00:26:41,440
when

00:26:39,120 --> 00:26:43,679
but in raku i would i would claim that

00:26:41,440 --> 00:26:46,480
the canonical use of smart match is

00:26:43,679 --> 00:26:46,480
actually crap

00:26:46,799 --> 00:26:52,480
grab will smart match with smart match

00:26:49,679 --> 00:26:54,799
its values against its arguments

00:26:52,480 --> 00:26:56,720
for example we have the whatever code

00:26:54,799 --> 00:27:01,840
before

00:26:56,720 --> 00:27:04,000
becomes uh becomes this becomes a small

00:27:01,840 --> 00:27:06,000
code object which compares is this

00:27:04,000 --> 00:27:07,840
bigger than two

00:27:06,000 --> 00:27:10,720
but you can like by say smart match

00:27:07,840 --> 00:27:13,760
against a string and then it will check

00:27:10,720 --> 00:27:15,039
does do which of these values are stream

00:27:13,760 --> 00:27:18,240
wise equivalent

00:27:15,039 --> 00:27:18,880
to the string foo you can compare the

00:27:18,240 --> 00:27:21,200
numbers

00:27:18,880 --> 00:27:23,120
and it will do exactly what you expect

00:27:21,200 --> 00:27:25,919
it to do

00:27:23,120 --> 00:27:26,559
you can match against a type object and

00:27:25,919 --> 00:27:30,399
it will do

00:27:26,559 --> 00:27:32,240
exactly what you expect it to do

00:27:30,399 --> 00:27:34,000
you can match it against the straight

00:27:32,240 --> 00:27:37,600
against the regex and it'll do

00:27:34,000 --> 00:27:39,760
exactly what you expect it to do

00:27:37,600 --> 00:27:41,840
you can match it against a range and

00:27:39,760 --> 00:27:43,919
it'll do exactly what you expect it to

00:27:41,840 --> 00:27:45,600
do

00:27:43,919 --> 00:27:47,440
you can match it against the pair and it

00:27:45,600 --> 00:27:48,480
will not do what you expect it to do but

00:27:47,440 --> 00:27:50,720
it will do something

00:27:48,480 --> 00:27:52,159
very very useful nonetheless it will

00:27:50,720 --> 00:27:55,760
call that method on

00:27:52,159 --> 00:27:58,559
on the object and match and

00:27:55,760 --> 00:27:59,679
gather any value but where that method

00:27:58,559 --> 00:28:02,320
returns true

00:27:59,679 --> 00:28:04,000
for example grab colon prime will give

00:28:02,320 --> 00:28:08,080
you all the prime numbers off

00:28:04,000 --> 00:28:09,279
in a list and of course we go back to

00:28:08,080 --> 00:28:13,760
one of my favorite

00:28:09,279 --> 00:28:15,600
favorite features in raku ever junctions

00:28:13,760 --> 00:28:17,200
junctions are just made for smart

00:28:15,600 --> 00:28:19,279
matching

00:28:17,200 --> 00:28:20,320
for example if you want a prime number

00:28:19,279 --> 00:28:23,679
that contains

00:28:20,320 --> 00:28:27,440
two consecutive at twos you can just say

00:28:23,679 --> 00:28:30,960
is prime and matches two two

00:28:27,440 --> 00:28:33,760
this will just work you can combine

00:28:30,960 --> 00:28:35,600
any smart matching objects using any

00:28:33,760 --> 00:28:39,600
other smart magical object

00:28:35,600 --> 00:28:40,880
using junctions one of the more useful

00:28:39,600 --> 00:28:44,480
ones actually here

00:28:40,880 --> 00:28:48,320
is none you can negate

00:28:44,480 --> 00:28:51,039
any smart match by putting it in a num

00:28:48,320 --> 00:28:51,760
this will return all values that do not

00:28:51,039 --> 00:28:54,080
match to

00:28:51,760 --> 00:28:54,080
true

00:28:56,559 --> 00:29:01,440
but how do you use this well again again

00:28:59,600 --> 00:29:02,880
i'm using example from my pathfinder

00:29:01,440 --> 00:29:06,240
module find

00:29:02,880 --> 00:29:10,640
dears with find indeers

00:29:06,240 --> 00:29:14,000
with the extension raku mod or pm0

00:29:10,640 --> 00:29:16,880
with a size bigger than a kilobyte

00:29:14,000 --> 00:29:18,159
with the depth three to five that

00:29:16,880 --> 00:29:21,039
contains

00:29:18,159 --> 00:29:21,039
this regex

00:29:22,880 --> 00:29:26,000
i this is code that i don't have to

00:29:25,039 --> 00:29:27,679
comment what is

00:29:26,000 --> 00:29:29,279
what it's doing here because it's

00:29:27,679 --> 00:29:33,919
literally describing

00:29:29,279 --> 00:29:36,240
out loud what it is doing

00:29:33,919 --> 00:29:37,120
and i think that i and i think that's

00:29:36,240 --> 00:29:38,880
amazing

00:29:37,120 --> 00:29:40,720
because i've no i haven't seen anything

00:29:38,880 --> 00:29:41,279
in any other language that allows me to

00:29:40,720 --> 00:29:44,000
be this

00:29:41,279 --> 00:29:46,320
literal about what what and what i'm

00:29:44,000 --> 00:29:48,399
trying to search for

00:29:46,320 --> 00:29:51,600
you usually have to write like the code

00:29:48,399 --> 00:29:51,600
code out explicitly

00:29:52,240 --> 00:29:57,200
thank you any questions i think i went a

00:29:54,720 --> 00:29:57,200
bit fast

00:30:03,600 --> 00:30:10,080
no questions i'm

00:30:06,640 --> 00:30:13,760
not lacking any other questions then um

00:30:10,080 --> 00:30:15,279
this this one could go on for hours so

00:30:13,760 --> 00:30:17,440
i'll suggest you should probably keep

00:30:15,279 --> 00:30:20,720
your answer to about two minutes but uh

00:30:17,440 --> 00:30:22,000
to what extent do you think that some of

00:30:20,720 --> 00:30:25,440
these ideas could

00:30:22,000 --> 00:30:26,159
be borrowed back into pearl uh provided

00:30:25,440 --> 00:30:29,200
we don't do

00:30:26,159 --> 00:30:32,880
another 510 with the whole smart match

00:30:29,200 --> 00:30:35,200
in pearl problem yeah it depends

00:30:32,880 --> 00:30:36,880
some of these features are more easily

00:30:35,200 --> 00:30:39,679
done than others

00:30:36,880 --> 00:30:40,799
like junctions are like a very deep

00:30:39,679 --> 00:30:42,559
feature

00:30:40,799 --> 00:30:44,240
that like full junctions is actually

00:30:42,559 --> 00:30:47,039
very difficult

00:30:44,240 --> 00:30:47,360
but some of their functions like having

00:30:47,039 --> 00:30:49,039
like

00:30:47,360 --> 00:30:51,039
some of their functionalities actually

00:30:49,039 --> 00:30:53,360
quite doable

00:30:51,039 --> 00:30:55,279
like right hand junction right hand

00:30:53,360 --> 00:30:57,679
junctions are actually fairly easy to

00:30:55,279 --> 00:30:59,519
implement

00:30:57,679 --> 00:31:01,279
it's the left side ones that get really

00:30:59,519 --> 00:31:02,880
complicated because right side is

00:31:01,279 --> 00:31:05,840
basically you can you can do that using

00:31:02,880 --> 00:31:08,320
the operator overloading and whatever

00:31:05,840 --> 00:31:09,120
so there's there's sort of two layers to

00:31:08,320 --> 00:31:13,200
my question

00:31:09,120 --> 00:31:13,840
because most of the most of the features

00:31:13,200 --> 00:31:15,519
that you're

00:31:13,840 --> 00:31:18,159
you're suggesting things like the

00:31:15,519 --> 00:31:21,919
junctions and the smart match and so on

00:31:18,159 --> 00:31:22,559
our syntax that is look like we couldn't

00:31:21,919 --> 00:31:24,640
phrase

00:31:22,559 --> 00:31:25,840
instance trivially just have the pipe

00:31:24,640 --> 00:31:27,760
operator in

00:31:25,840 --> 00:31:29,200
perl to do this to do these junctions

00:31:27,760 --> 00:31:31,200
because the pipe program already means

00:31:29,200 --> 00:31:32,960
numerical bitwise or

00:31:31,200 --> 00:31:35,840
um so we'd have to find a new way to

00:31:32,960 --> 00:31:37,919
spell it but the actual functionality

00:31:35,840 --> 00:31:39,200
is fairly easy to implement with just

00:31:37,919 --> 00:31:42,320
another spelling but

00:31:39,200 --> 00:31:45,519
things like the pointy blocks

00:31:42,320 --> 00:31:48,960
are a kind of a much harder thing to do

00:31:45,519 --> 00:31:50,000
yes conceptually like it's not just a

00:31:48,960 --> 00:31:53,200
matter of spelling it

00:31:50,000 --> 00:31:55,120
it's a it's a i feel it's it's different

00:31:53,200 --> 00:31:59,440
on a different level

00:31:55,120 --> 00:32:02,559
yes um i would agree

00:31:59,440 --> 00:32:06,000
um it's all a matter of

00:32:02,559 --> 00:32:10,159
of um it's very

00:32:06,000 --> 00:32:10,159
very sloppy feature really

00:32:12,000 --> 00:32:16,399
i mean i would really like to see some

00:32:14,000 --> 00:32:17,279
of those meta operators also on pro

00:32:16,399 --> 00:32:19,840
because i think

00:32:17,279 --> 00:32:20,799
a bunch of them are doable not with the

00:32:19,840 --> 00:32:24,000
same syntax

00:32:20,799 --> 00:32:26,720
but um i mean

00:32:24,000 --> 00:32:27,120
not to spoil the the surprise too much

00:32:26,720 --> 00:32:28,640
but

00:32:27,120 --> 00:32:31,760
i've just implemented the divides

00:32:28,640 --> 00:32:34,080
operator while i was watching that uh

00:32:31,760 --> 00:32:35,519
i've not done that now but some of the

00:32:34,080 --> 00:32:37,120
meta ones are a little bit tricky for

00:32:35,519 --> 00:32:40,840
the spelling of them

00:32:37,120 --> 00:32:42,080
um well i mean i i wonder whether it's

00:32:40,840 --> 00:32:44,559
worth

00:32:42,080 --> 00:32:46,240
the pearl stop kind of things just

00:32:44,559 --> 00:32:46,799
sitting down and going through that list

00:32:46,240 --> 00:32:48,720
and thinking

00:32:46,799 --> 00:32:49,840
you know in practice could we import

00:32:48,720 --> 00:32:51,760
some of these but

00:32:49,840 --> 00:32:53,679
try and do it in a safer way than we did

00:32:51,760 --> 00:32:56,159
last time with uh with smart

00:32:53,679 --> 00:32:58,640
i mean the the problem in five standard

00:32:56,159 --> 00:33:02,000
is that they really try to

00:32:58,640 --> 00:33:05,279
uh transplant features one-on-one

00:33:02,000 --> 00:33:07,600
without doing like a translation to get

00:33:05,279 --> 00:33:09,279
from raccoon to pro and then that got

00:33:07,600 --> 00:33:12,880
very confusing

00:33:09,279 --> 00:33:14,320
um but yes some of these features could

00:33:12,880 --> 00:33:17,760
definitely be ported

00:33:14,320 --> 00:33:19,519
yes yeah i think the meta operators or

00:33:17,760 --> 00:33:21,440
at least the first three would be fairly

00:33:19,519 --> 00:33:25,360
high on that list

00:33:21,440 --> 00:33:26,640
yeah like them i do

00:33:25,360 --> 00:33:28,159
i don't know i don't know about timing

00:33:26,640 --> 00:33:30,080
here right i don't want to spill over

00:33:28,159 --> 00:33:32,640
timing into a huge conversation but uh

00:33:30,080 --> 00:33:34,159
i mean i've i've been trying really hard

00:33:32,640 --> 00:33:35,600
the square brackets i think are not

00:33:34,159 --> 00:33:37,519
going to fly in pearl

00:33:35,600 --> 00:33:39,600
but i've been trying really hard if we

00:33:37,519 --> 00:33:42,799
get rid of the redline operator

00:33:39,600 --> 00:33:44,559
and we get rid of uh glob

00:33:42,799 --> 00:33:46,799
then suddenly we can get angle brackets

00:33:44,559 --> 00:33:47,600
back and and i think that actually we

00:33:46,799 --> 00:33:50,000
can do a lot

00:33:47,600 --> 00:33:51,760
by just using the angle brackets rather

00:33:50,000 --> 00:33:54,640
than square brackets and there may be

00:33:51,760 --> 00:33:54,640
some potential there

00:33:54,880 --> 00:34:00,399
maybe but it's not trivial but it might

00:33:57,919 --> 00:34:00,399
be doable

00:34:00,880 --> 00:34:05,200
i i suspect that we're gonna have to

00:34:03,279 --> 00:34:09,440
find like i

00:34:05,200 --> 00:34:09,440
find our very own syntax for these

00:34:18,839 --> 00:34:21,839
concepts

00:34:23,040 --> 00:34:26,480
there's been a lot of chatter so i don't

00:34:24,720 --> 00:34:29,520
know how we would summarize that

00:34:26,480 --> 00:34:30,079
um yeah see i'm just seeing that now and

00:34:29,520 --> 00:34:35,839
it's like

00:34:30,079 --> 00:34:35,839
a lot of chatter

00:34:36,480 --> 00:34:40,159
i guess i'll look at that later very

00:34:38,639 --> 00:34:43,200
briefly

00:34:40,159 --> 00:34:46,839
is there syntax that you miss

00:34:43,200 --> 00:34:48,480
when you're working in raiku from other

00:34:46,839 --> 00:34:51,520
languages

00:34:48,480 --> 00:34:55,520
um because we'll add it

00:34:51,520 --> 00:34:57,680
you know we will um

00:34:55,520 --> 00:35:00,320
yes probably i can't think of anything

00:34:57,680 --> 00:35:00,320
right now

00:35:01,040 --> 00:35:05,839
because i think pretty much anything has

00:35:02,720 --> 00:35:05,839
been added already

00:35:06,400 --> 00:35:17,839
thank you

00:35:22,320 --> 00:35:26,240
oh to summarize the chat there's a whole

00:35:24,240 --> 00:35:27,920
lot of complimentary and interesting

00:35:26,240 --> 00:35:29,440
discussion but there was a question of

00:35:27,920 --> 00:35:32,160
why you didn't

00:35:29,440 --> 00:35:34,480
cover laziness maybe because you don't

00:35:32,160 --> 00:35:38,240
consider it syntax or

00:35:34,480 --> 00:35:40,320
um yes well i went a bit

00:35:38,240 --> 00:35:41,440
i wasn't expecting to have like this

00:35:40,320 --> 00:35:44,240
much time left

00:35:41,440 --> 00:35:46,160
but nerves made me go a bit faster than

00:35:44,240 --> 00:35:49,520
i would ordinarily go

00:35:46,160 --> 00:35:51,680
um lazy lists yes

00:35:49,520 --> 00:35:52,720
are a very useful feature too but

00:35:51,680 --> 00:35:55,520
they're less

00:35:52,720 --> 00:35:57,440
i'm kind of focusing on syntax here and

00:35:55,520 --> 00:36:00,560
lazy lists are more on the semantic

00:35:57,440 --> 00:36:00,560
side i would say

00:36:02,160 --> 00:36:07,280
leon you should use the three dots in

00:36:05,119 --> 00:36:08,560
the chat to save your chat so you can

00:36:07,280 --> 00:36:13,839
browse it later

00:36:08,560 --> 00:36:13,839
yes i already did so okay

00:36:18,320 --> 00:36:21,200
any more questions

00:36:24,400 --> 00:36:29,680
great talk yes sir indeed

00:36:30,320 --> 00:36:34,000
well if i have spare time then i'm gonna

00:36:32,720 --> 00:36:35,680
i

00:36:34,000 --> 00:36:37,359
there was one fee i don't have slides

00:36:35,680 --> 00:36:38,160
for it but there's one feature that i

00:36:37,359 --> 00:36:39,920
really like

00:36:38,160 --> 00:36:41,760
that i thought i wouldn't have time for

00:36:39,920 --> 00:36:45,920
but i'm just gonna describe it

00:36:41,760 --> 00:36:49,599
okay in raku it is legal to use

00:36:45,920 --> 00:36:51,760
a dash as part of a name

00:36:49,599 --> 00:36:54,800
which is very common in lisp derived

00:36:51,760 --> 00:36:57,200
languages but in algol derived languages

00:36:54,800 --> 00:36:58,800
is not and i think this is great because

00:36:57,200 --> 00:37:01,520
frankly

00:36:58,800 --> 00:37:03,599
no one ever used an underscore unless

00:37:01,520 --> 00:37:06,240
computer systems forced them to use

00:37:03,599 --> 00:37:06,240
underscores

00:37:07,760 --> 00:37:12,240
whereas that whereas dashes are actually

00:37:09,839 --> 00:37:15,200
part of natural languages

00:37:12,240 --> 00:37:16,560
and raku and raku just decided we're

00:37:15,200 --> 00:37:19,920
gonna allow this

00:37:16,560 --> 00:37:21,280
because given sigils there are very few

00:37:19,920 --> 00:37:24,160
ambiguous cases

00:37:21,280 --> 00:37:27,920
and in the odd ambiguous case we'll just

00:37:24,160 --> 00:37:30,640
use white space to disambiguate them

00:37:27,920 --> 00:37:32,560
which sounds kind of complicated but in

00:37:30,640 --> 00:37:36,000
practice it turns out to always work

00:37:32,560 --> 00:37:39,680
exactly as you expect it to do

00:37:36,000 --> 00:37:40,000
um which is a tiny tiny tiny feature but

00:37:39,680 --> 00:37:42,160
i

00:37:40,000 --> 00:37:44,079
really appreciate it because dashers

00:37:42,160 --> 00:37:46,720
just look so much prettier than

00:37:44,079 --> 00:37:46,720
underscores

00:37:47,760 --> 00:37:52,720
also apostrophes which are not quite as

00:37:51,040 --> 00:37:55,359
handy

00:37:52,720 --> 00:37:56,960
but very useful on verification use them

00:37:55,359 --> 00:38:00,400
like in real code whereas

00:37:56,960 --> 00:38:02,480
i use dashes literally all the time leon

00:38:00,400 --> 00:38:06,560
are you talking about a leading unders

00:38:02,480 --> 00:38:08,480
an underscore or a dash or a hyphen

00:38:06,560 --> 00:38:09,760
are you talking about an underscore or a

00:38:08,480 --> 00:38:13,359
hyphen

00:38:09,760 --> 00:38:15,280
hyphen thank you

00:38:13,359 --> 00:38:17,040
yeah the only time i've been tempted

00:38:15,280 --> 00:38:17,760
with apostrophes is to demonstrate

00:38:17,040 --> 00:38:21,040
possession

00:38:17,760 --> 00:38:23,200
which does occasionally come up yeah

00:38:21,040 --> 00:38:25,760
it's it's a cute trick but i'm not very

00:38:23,200 --> 00:38:27,760
tempted to use it whereas like hyphens

00:38:25,760 --> 00:38:29,680
all the time wherever i would use an

00:38:27,760 --> 00:38:32,160
underscore in any other language i use a

00:38:29,680 --> 00:38:34,800
hyphen imraku

00:38:32,160 --> 00:38:36,880
and what about unicore characters as

00:38:34,800 --> 00:38:41,119
operators

00:38:36,880 --> 00:38:43,599
um i use them but only some of them

00:38:41,119 --> 00:38:45,200
because some of them are like relatively

00:38:43,599 --> 00:38:46,560
easy to type and others are fairly

00:38:45,200 --> 00:38:49,040
difficult and

00:38:46,560 --> 00:38:51,119
well like some operators are like like

00:38:49,040 --> 00:38:53,040
for hyper i will definitely use the

00:38:51,119 --> 00:38:56,640
french quotes

00:38:53,040 --> 00:38:58,960
um but for

00:38:56,640 --> 00:39:00,800
do i use other unicode operators not

00:38:58,960 --> 00:39:03,599
that many i think

00:39:00,800 --> 00:39:05,440
regardless i'm still for the idea of

00:39:03,599 --> 00:39:09,200
deprecating or killing the use of

00:39:05,440 --> 00:39:09,200
apostrophe as a package separator

00:39:09,760 --> 00:39:14,720
yes that will break the acme don't

00:39:13,680 --> 00:39:17,920
module though

00:39:14,720 --> 00:39:20,240
don't care it will break is good it has

00:39:17,920 --> 00:39:20,240
more

00:39:21,760 --> 00:39:25,760
not that that is a good idea but it

00:39:23,520 --> 00:39:27,359
exists

00:39:25,760 --> 00:39:29,280
yeah some of the pearl ideas i have

00:39:27,359 --> 00:39:32,000
might break the is function though

00:39:29,280 --> 00:39:32,000
that's the problem

00:39:32,160 --> 00:39:35,680

YouTube URL: https://www.youtube.com/watch?v=elalwvfmYgk


