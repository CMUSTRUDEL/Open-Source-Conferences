Title: Sequential Consistency & Perl & perl - B. Estrade
Publication date: 2021-06-09
Playlist: TPC 2021 in the Cloud
Description: 
	This talk will discuss the idea of sequential consistency and why it's important for concurrent Perl semantics in the uniprocess runtime environment of perl. The talk will necessarily include the topics of Regular Languages, Finite Automata, and concurrent programming, and memory consistency models.

Much wasted effort has been expended for the cause of providing parallel and concurrent semantics in Perl,  the language. Because the perl runtime is unforgivably uniprocess, any effort must begin by ensuring a property of sequential consistency, which may described such that,

"... the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program." [1,2]

An inherently sequential memory model as the one provided for in a uniprocess runtime environment provides a lot of benefits. One of these benefits is that it provides strong memory consistency guarantees. In addition to that, the perl runtime environment provides a treasure trove of features that make it ideal for the support of implicit shared memory semantics with strong consistent memory guarantees. What's the missing link? A way to convert arbitrarily complex, concurrent semantics (or intentions by the programmer) into a valid sequential execution plan suitable for a uniprocess perl runtime environment.

This talk introduces that idea of sequential consistency, the uniprocess perl runtime model, and a CPAN module that demonstrates the feasibility of this approach, Sub::Genius.

References:

1. Leslie Lamport, "How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs", IEEE Trans. Comput. C-28,9 (Sept. 1979), 690-691.

2. https://en.wikipedia.org/wiki/Sequential_consistency
Captions: 
	00:00:25,199 --> 00:00:29,679
okay

00:00:27,039 --> 00:00:32,320
i think i made the right i jumped in the

00:00:29,679 --> 00:00:34,559
wrong zoom

00:00:32,320 --> 00:00:37,360
but i think i'm here now this is brett

00:00:34,559 --> 00:00:45,840
you are here now

00:00:37,360 --> 00:00:45,840
are you on multiple channels

00:00:47,170 --> 00:00:50,259
[Music]

00:00:56,719 --> 00:01:01,039
all right so i just do the share thing

00:01:07,680 --> 00:01:13,200
okay we are already live on youtube and

00:01:11,119 --> 00:01:14,880
uh so we just need your screen share and

00:01:13,200 --> 00:01:20,320
then you can go ahead and start

00:01:14,880 --> 00:01:20,320
at 11 o'clock all right sounds good

00:01:20,960 --> 00:01:24,320
somebody who is unmuted has some

00:01:22,479 --> 00:01:27,840
background noise so if you're not

00:01:24,320 --> 00:01:27,840
presenting please mute

00:01:34,960 --> 00:01:41,840
okay can y'all see my uh

00:01:42,720 --> 00:01:58,479
i see it all right

00:01:55,759 --> 00:02:00,640
all right do y'all see just the the

00:01:58,479 --> 00:02:02,960
front slide or the

00:02:00,640 --> 00:02:04,880
i see like a presentation view also

00:02:02,960 --> 00:02:05,520
sequential consistency and pearl looks

00:02:04,880 --> 00:02:09,840
good

00:02:05,520 --> 00:02:09,840
all right

00:02:10,319 --> 00:02:13,360
all right should we kick it off

00:02:18,560 --> 00:02:23,040
yeah i think it's after 11 go for all

00:02:21,680 --> 00:02:24,959
right

00:02:23,040 --> 00:02:27,920
well uh thank you for attending this

00:02:24,959 --> 00:02:30,319
talk uh this is a topic that

00:02:27,920 --> 00:02:31,599
i have uh been thinking about for many

00:02:30,319 --> 00:02:34,560
years

00:02:31,599 --> 00:02:36,400
and uh hopefully you'll find it as

00:02:34,560 --> 00:02:39,680
interesting as i do the uh

00:02:36,400 --> 00:02:43,120
the slides it's a simple concept and uh

00:02:39,680 --> 00:02:45,519
but it's it's got a lot of backgrounds

00:02:43,120 --> 00:02:46,720
and it was hard to kind of put this in a

00:02:45,519 --> 00:02:48,800
unified way

00:02:46,720 --> 00:02:51,040
uh but before we start i wanted to

00:02:48,800 --> 00:02:51,599
mention i work for cpanel been there for

00:02:51,040 --> 00:02:54,879
uh

00:02:51,599 --> 00:02:56,319
about a decade now and uh i'm also a

00:02:54,879 --> 00:02:59,519
member of the houston

00:02:56,319 --> 00:03:01,760
pro mongers and we do zoom

00:02:59,519 --> 00:03:03,200
things by zoom most of the time now and

00:03:01,760 --> 00:03:06,080
we often get

00:03:03,200 --> 00:03:07,040
uh visitors from other pms all over the

00:03:06,080 --> 00:03:09,040
world

00:03:07,040 --> 00:03:10,640
and uh y'all are more most certainly

00:03:09,040 --> 00:03:13,040
welcome to join us that's our

00:03:10,640 --> 00:03:15,360
our website and uh anyway looking

00:03:13,040 --> 00:03:16,480
forward to seeing some of you all there

00:03:15,360 --> 00:03:19,840
we've been talking about some pretty

00:03:16,480 --> 00:03:19,840
interesting things lately so

00:03:20,720 --> 00:03:25,120
okay a little bit of history um so in

00:03:23,560 --> 00:03:28,959
00:03:25,120 --> 00:03:31,840
i uh pushed a it's a module to cpan

00:03:28,959 --> 00:03:33,840
is pretty much my first major module or

00:03:31,840 --> 00:03:36,879
maybe my only major module

00:03:33,840 --> 00:03:38,959
and it was a result of basically a

00:03:36,879 --> 00:03:40,959
homework assignment that i was uh

00:03:38,959 --> 00:03:42,080
working on at the time and i was

00:03:40,959 --> 00:03:45,280
exploring

00:03:42,080 --> 00:03:47,840
regular languages finite automata

00:03:45,280 --> 00:03:49,599
and the homework assignment was to write

00:03:47,840 --> 00:03:51,920
a program that would convert

00:03:49,599 --> 00:03:54,560
a regular expression and now i'm talking

00:03:51,920 --> 00:03:57,599
about regular expressions in the formal

00:03:54,560 --> 00:04:00,959
computer science term into a

00:03:57,599 --> 00:04:04,000
a deterministic finite automata and that

00:04:00,959 --> 00:04:05,920
spurred this uh tool kit

00:04:04,000 --> 00:04:07,040
that because i wanted to look at

00:04:05,920 --> 00:04:09,680
different uh

00:04:07,040 --> 00:04:10,400
you know what different regular what

00:04:09,680 --> 00:04:12,720
kind of

00:04:10,400 --> 00:04:14,159
dfas were created by different kinds of

00:04:12,720 --> 00:04:16,239
regular expressions

00:04:14,159 --> 00:04:18,000
and i've been into pearl for a few years

00:04:16,239 --> 00:04:19,919
at this point and it was a it was a

00:04:18,000 --> 00:04:23,120
natural fit

00:04:19,919 --> 00:04:24,800
um it is a really interesting module and

00:04:23,120 --> 00:04:26,720
some of the stuff that i was digging

00:04:24,800 --> 00:04:29,199
into was very interesting to me

00:04:26,720 --> 00:04:30,160
but i didn't use it for anything other

00:04:29,199 --> 00:04:33,120
than

00:04:30,160 --> 00:04:36,000
messing around um until recently so it's

00:04:33,120 --> 00:04:39,440
been sitting on cpan for about 15 years

00:04:36,000 --> 00:04:40,720
and uh there's i have interest in

00:04:39,440 --> 00:04:42,800
concurrency

00:04:40,720 --> 00:04:44,720
there's there's always been interest in

00:04:42,800 --> 00:04:47,360
concurrency in the parole world

00:04:44,720 --> 00:04:49,360
but there's always been a sticking point

00:04:47,360 --> 00:04:51,840
related to the fact that the parole

00:04:49,360 --> 00:04:52,960
run time process is is a single process

00:04:51,840 --> 00:04:56,000
so

00:04:52,960 --> 00:04:58,080
recently um i

00:04:56,000 --> 00:04:59,600
thought maybe i could i could utilize

00:04:58,080 --> 00:05:03,039
some of the capabilities of this

00:04:59,600 --> 00:05:07,520
this flat module uh to explore that that

00:05:03,039 --> 00:05:09,199
topic a little more so

00:05:07,520 --> 00:05:11,039
i'm talking about pearl in two different

00:05:09,199 --> 00:05:13,360
ways there's pearl the language

00:05:11,039 --> 00:05:14,960
and i'll use that capital p and then

00:05:13,360 --> 00:05:15,759
there's the pearl runtime or the

00:05:14,960 --> 00:05:18,479
interpreter

00:05:15,759 --> 00:05:19,039
okay the pearl language and i'm not

00:05:18,479 --> 00:05:21,680
going to show

00:05:19,039 --> 00:05:23,440
examples but i think we can all agree

00:05:21,680 --> 00:05:25,840
there's a strong temptation

00:05:23,440 --> 00:05:26,800
when somebody is learning pearl and and

00:05:25,840 --> 00:05:28,720
doing

00:05:26,800 --> 00:05:30,800
all of the cool things we can do with

00:05:28,720 --> 00:05:32,639
the language and the semantics

00:05:30,800 --> 00:05:35,280
to want to do things concurrently or in

00:05:32,639 --> 00:05:36,880
parallel there's nothing inherently

00:05:35,280 --> 00:05:38,880
nothing inherent about pearl the

00:05:36,880 --> 00:05:42,400
language itself that

00:05:38,880 --> 00:05:45,440
um makes it makes it have to be run

00:05:42,400 --> 00:05:47,759
in the single process or sequentially

00:05:45,440 --> 00:05:49,199
and that's for a variety of reasons but

00:05:47,759 --> 00:05:49,919
i don't think anybody would argue with

00:05:49,199 --> 00:05:54,400
that

00:05:49,919 --> 00:05:57,199
pearl the run time is unforgivingly

00:05:54,400 --> 00:05:58,000
um single process and i know this

00:05:57,199 --> 00:06:01,120
because for

00:05:58,000 --> 00:06:01,600
for 20 years now i've been one of the

00:06:01,120 --> 00:06:03,919
people

00:06:01,600 --> 00:06:05,280
who you know will chime up every once in

00:06:03,919 --> 00:06:07,600
a while and say

00:06:05,280 --> 00:06:08,479
you know why can't we have you know real

00:06:07,600 --> 00:06:10,639
lightweight

00:06:08,479 --> 00:06:12,960
shared memory threads in pearl why can't

00:06:10,639 --> 00:06:16,160
we do things in a parallel way

00:06:12,960 --> 00:06:18,479
and my my background is in um

00:06:16,160 --> 00:06:19,840
high performance computing and i got

00:06:18,479 --> 00:06:22,720
into you know message

00:06:19,840 --> 00:06:23,440
mpi message passing interface one of my

00:06:22,720 --> 00:06:25,600
favorite

00:06:23,440 --> 00:06:28,639
things to to play with though is openmp

00:06:25,600 --> 00:06:31,120
which is a which is a high level

00:06:28,639 --> 00:06:31,919
high level uh declarative way to to

00:06:31,120 --> 00:06:34,319
interface with

00:06:31,919 --> 00:06:36,240
with threads and a lot of times that

00:06:34,319 --> 00:06:38,880
those threads are implemented with

00:06:36,240 --> 00:06:40,880
with key threads in any case my my

00:06:38,880 --> 00:06:44,720
strong interest was in

00:06:40,880 --> 00:06:46,880
shared memory parallelism so

00:06:44,720 --> 00:06:49,280
now i also care a lot about the pearl

00:06:46,880 --> 00:06:51,840
community just like everybody else here

00:06:49,280 --> 00:06:52,639
and there's always something nagging at

00:06:51,840 --> 00:06:54,880
me

00:06:52,639 --> 00:06:56,720
about why why were there always you know

00:06:54,880 --> 00:06:59,120
people asking for this

00:06:56,720 --> 00:06:59,919
for parallelism or threading or you know

00:06:59,120 --> 00:07:01,599
i i say

00:06:59,919 --> 00:07:03,280
i'll call it real threading and then

00:07:01,599 --> 00:07:05,440
somebody will get offended

00:07:03,280 --> 00:07:07,360
um but when i when i say real threading

00:07:05,440 --> 00:07:09,199
i mean real

00:07:07,360 --> 00:07:10,960
you know lightweight threads where

00:07:09,199 --> 00:07:14,639
processes can can

00:07:10,960 --> 00:07:18,080
use shared memory not not the not what's

00:07:14,639 --> 00:07:21,440
provided 4x4 so but

00:07:18,080 --> 00:07:23,440
i accepted i accept that that's the case

00:07:21,440 --> 00:07:25,840
and once i fully embrace the fact that

00:07:23,440 --> 00:07:29,199
the pearl runtime

00:07:25,840 --> 00:07:32,400
is a single process it is

00:07:29,199 --> 00:07:35,520
sequential uh then things

00:07:32,400 --> 00:07:37,520
things started opening up for me now one

00:07:35,520 --> 00:07:41,039
of the problems i had was

00:07:37,520 --> 00:07:43,199
at least for me it was forcing me into a

00:07:41,039 --> 00:07:45,440
state of cognitive dissonance

00:07:43,199 --> 00:07:47,360
you want to write concurrent or parallel

00:07:45,440 --> 00:07:49,919
things using parallel language

00:07:47,360 --> 00:07:51,039
but you can't so then there are these

00:07:49,919 --> 00:07:53,440
have been these

00:07:51,039 --> 00:07:54,960
herculean and heroic attempts over the

00:07:53,440 --> 00:07:58,000
years to

00:07:54,960 --> 00:07:59,840
provide some sort of parallelism

00:07:58,000 --> 00:08:02,080
or what feels like parallelism and this

00:07:59,840 --> 00:08:05,360
is even this has been exacerbated

00:08:02,080 --> 00:08:07,039
by the fact that multi-processors are on

00:08:05,360 --> 00:08:09,280
everything now

00:08:07,039 --> 00:08:10,160
um so the ultimately the purpose of this

00:08:09,280 --> 00:08:13,360
talk is

00:08:10,160 --> 00:08:15,280
my attempt to reconcile uh

00:08:13,360 --> 00:08:16,800
the you know what i want to do with

00:08:15,280 --> 00:08:20,080
pearl the language and

00:08:16,800 --> 00:08:24,080
what i am given as far as the

00:08:20,080 --> 00:08:24,080
single process that is the pro run time

00:08:24,800 --> 00:08:28,240
um so a little bit about shared memory

00:08:26,960 --> 00:08:31,199
memory concurrency

00:08:28,240 --> 00:08:32,399
communication is implicit it's done over

00:08:31,199 --> 00:08:35,839
shared variables

00:08:32,399 --> 00:08:38,560
um and it as opposed to say

00:08:35,839 --> 00:08:38,880
a message passing type of approach where

00:08:38,560 --> 00:08:40,320
you're

00:08:38,880 --> 00:08:42,240
you know you have a bunch of say

00:08:40,320 --> 00:08:42,880
sequential communicating processes that

00:08:42,240 --> 00:08:45,839
are

00:08:42,880 --> 00:08:46,959
communicating actual messages in an

00:08:45,839 --> 00:08:50,320
explicit way

00:08:46,959 --> 00:08:52,480
a message i mentioned mpi earlier

00:08:50,320 --> 00:08:54,000
this is this is what's what's typically

00:08:52,480 --> 00:08:56,640
used on these large linux

00:08:54,000 --> 00:08:58,160
baywolf clusters when you have a bunch

00:08:56,640 --> 00:09:01,279
of processors running across

00:08:58,160 --> 00:09:03,040
a cluster so you've got you've got these

00:09:01,279 --> 00:09:05,600
compute nodes that

00:09:03,040 --> 00:09:07,040
have have more you know have many cpus

00:09:05,600 --> 00:09:09,440
within a shared memory con

00:09:07,040 --> 00:09:11,200
without that share the same memory and

00:09:09,440 --> 00:09:14,160
then they're all connected over some

00:09:11,200 --> 00:09:15,760
some kind of network um that that

00:09:14,160 --> 00:09:16,800
facilitates communication so like

00:09:15,760 --> 00:09:19,839
ethernet

00:09:16,800 --> 00:09:22,880
or infiniband is another one

00:09:19,839 --> 00:09:25,440
so in any case but in in order to

00:09:22,880 --> 00:09:26,880
quote unquote share share memory or to

00:09:25,440 --> 00:09:30,480
to

00:09:26,880 --> 00:09:33,600
uh allow participation in in some

00:09:30,480 --> 00:09:36,560
collective computation let's say

00:09:33,600 --> 00:09:38,399
mpi programs have to send over messages

00:09:36,560 --> 00:09:39,440
and the messages are usually data

00:09:38,399 --> 00:09:42,240
structures and

00:09:39,440 --> 00:09:43,519
mpi is great i really think it's cool

00:09:42,240 --> 00:09:46,320
and it and it does it in

00:09:43,519 --> 00:09:48,240
in a very efficient way but that's not

00:09:46,320 --> 00:09:49,920
what i want for pearl

00:09:48,240 --> 00:09:51,760
or what i want to that's not how i want

00:09:49,920 --> 00:09:52,800
to be able to program in pearl when i

00:09:51,760 --> 00:09:56,640
talk about

00:09:52,800 --> 00:09:58,160
concurrency and i also prefer the s

00:09:56,640 --> 00:09:59,839
p approaches so that symmetric

00:09:58,160 --> 00:10:00,800
multi-processing or shared memory

00:09:59,839 --> 00:10:04,079
programming

00:10:00,800 --> 00:10:06,160
uh i i use those terms interchangeably

00:10:04,079 --> 00:10:07,519
so one of the benefits of of shared

00:10:06,160 --> 00:10:10,160
memory concurrency

00:10:07,519 --> 00:10:11,600
and since the communication is implicit

00:10:10,160 --> 00:10:15,040
using the state of

00:10:11,600 --> 00:10:17,680
memory or a variable is that

00:10:15,040 --> 00:10:18,720
you don't have to explicitly communicate

00:10:17,680 --> 00:10:20,880
you can do things

00:10:18,720 --> 00:10:22,640
you can implement algorithms and

00:10:20,880 --> 00:10:25,600
computations in a very

00:10:22,640 --> 00:10:26,160
implicit way and and i think we we all

00:10:25,600 --> 00:10:29,120
know

00:10:26,160 --> 00:10:30,720
with pearl pearl admits a lot of uh

00:10:29,120 --> 00:10:33,440
implicit approaches

00:10:30,720 --> 00:10:35,600
meaning that it's it's much more of a

00:10:33,440 --> 00:10:38,800
functional or declarative approach to

00:10:35,600 --> 00:10:40,560
what you want to do as opposed to how

00:10:38,800 --> 00:10:43,200
you want to do it how you want to

00:10:40,560 --> 00:10:45,040
implement the low level you know

00:10:43,200 --> 00:10:47,839
protocols in place

00:10:45,040 --> 00:10:48,959
so that's another reason why i like the

00:10:47,839 --> 00:10:50,959
shared memory approach

00:10:48,959 --> 00:10:52,000
because i'm lazy and i think a lot of

00:10:50,959 --> 00:10:55,760
this harms

00:10:52,000 --> 00:10:58,160
so um there's value

00:10:55,760 --> 00:11:00,880
the the ultimate point of i think all of

00:10:58,160 --> 00:11:05,200
this is there's value at least for me

00:11:00,880 --> 00:11:09,120
in presenting a shared memory type of

00:11:05,200 --> 00:11:10,959
approach even if where the program is

00:11:09,120 --> 00:11:14,240
getting executed

00:11:10,959 --> 00:11:16,560
happens to be a single process

00:11:14,240 --> 00:11:19,279
and that's that's where that's where i'm

00:11:16,560 --> 00:11:19,279
going with this

00:11:19,760 --> 00:11:25,200
um so i i'll put it this way

00:11:23,920 --> 00:11:26,800
i want to have all the fun of

00:11:25,200 --> 00:11:29,519
traditional shared memory programming

00:11:26,800 --> 00:11:31,519
but inside of a single process

00:11:29,519 --> 00:11:33,279
and that includes and that includes

00:11:31,519 --> 00:11:34,160
potential for race conditions that

00:11:33,279 --> 00:11:35,360
includes

00:11:34,160 --> 00:11:37,279
you know opening up all of those

00:11:35,360 --> 00:11:38,240
pitfalls that that shared memory program

00:11:37,279 --> 00:11:39,920
gives us

00:11:38,240 --> 00:11:44,399
and i want to be able to do it naturally

00:11:39,920 --> 00:11:44,399
within pearl as naturally as possible

00:11:44,640 --> 00:11:50,800
so the nice thing is that

00:11:47,680 --> 00:11:53,200
pearl the run time since it's a single

00:11:50,800 --> 00:11:56,959
process is a very well defined

00:11:53,200 --> 00:11:58,959
and safe and consistent memory space

00:11:56,959 --> 00:12:00,639
um the other the other thing that i

00:11:58,959 --> 00:12:01,680
think is pretty exciting about being

00:12:00,639 --> 00:12:05,120
able to do this

00:12:01,680 --> 00:12:08,160
within a parole process is the

00:12:05,120 --> 00:12:11,279
the uh the ability of

00:12:08,160 --> 00:12:14,639
of us to make subroutines stateful

00:12:11,279 --> 00:12:16,480
using the state keyword and i think that

00:12:14,639 --> 00:12:17,839
although there you know you can use

00:12:16,480 --> 00:12:21,279
closures to

00:12:17,839 --> 00:12:24,320
affect that in other ways having this

00:12:21,279 --> 00:12:27,200
this easy ability to give state memory

00:12:24,320 --> 00:12:28,160
or the subroutines memory from call to

00:12:27,200 --> 00:12:30,320
call

00:12:28,160 --> 00:12:32,160
um you know basically creating making

00:12:30,320 --> 00:12:34,399
them co routines

00:12:32,160 --> 00:12:35,600
is super powerful and that that frees up

00:12:34,399 --> 00:12:38,959
your minds

00:12:35,600 --> 00:12:40,639
even more to uh to do some interesting

00:12:38,959 --> 00:12:41,920
things and think more about the problem

00:12:40,639 --> 00:12:45,600
and the solution that you're

00:12:41,920 --> 00:12:45,600
you're uh you're trying to solve

00:12:46,480 --> 00:12:51,839
okay so this is a motivating example

00:12:50,240 --> 00:12:53,360
i'm not showing the rest of the pearl

00:12:51,839 --> 00:12:56,399
here but

00:12:53,360 --> 00:12:58,959
the the approach that i'll i get into

00:12:56,399 --> 00:12:59,600
towards the end of the talk is basically

00:12:58,959 --> 00:13:03,760
defining

00:12:59,600 --> 00:13:06,560
an execution um an execution plan

00:13:03,760 --> 00:13:07,279
and i've been calling it a plan that

00:13:06,560 --> 00:13:10,000
take

00:13:07,279 --> 00:13:12,639
where the words say the words in this

00:13:10,000 --> 00:13:16,000
example this is just a string

00:13:12,639 --> 00:13:18,959
but it it describes that

00:13:16,000 --> 00:13:20,160
how the subroutines that i have i will

00:13:18,959 --> 00:13:23,200
define

00:13:20,160 --> 00:13:24,720
uh relate to one another so and i'll get

00:13:23,200 --> 00:13:28,639
more into this but you can

00:13:24,720 --> 00:13:29,360
you can look at so begin the the capital

00:13:28,639 --> 00:13:31,920
j

00:13:29,360 --> 00:13:32,560
capital a capital p capital h and then

00:13:31,920 --> 00:13:35,680
the end

00:13:32,560 --> 00:13:37,600
those all represent the fine subroutines

00:13:35,680 --> 00:13:40,720
within the rest in the pearl script that

00:13:37,600 --> 00:13:42,959
i have not yet shown

00:13:40,720 --> 00:13:43,839
so i will be explaining this later and

00:13:42,959 --> 00:13:47,600
hopefully this will

00:13:43,839 --> 00:13:50,320
keep you keep you paying attention

00:13:47,600 --> 00:13:51,600
so a few uh more than a few terms that

00:13:50,320 --> 00:13:54,720
we're i'm going to be talking about

00:13:51,600 --> 00:13:55,839
is uniprocess what is that what is a

00:13:54,720 --> 00:13:58,399
memory model

00:13:55,839 --> 00:14:00,880
what is sequential consistency i'm going

00:13:58,399 --> 00:14:04,959
to talk about finite automata although

00:14:00,880 --> 00:14:06,959
i don't go into a lot of depth

00:14:04,959 --> 00:14:08,639
it's a super interesting topic and i

00:14:06,959 --> 00:14:11,199
could probably talk

00:14:08,639 --> 00:14:13,040
to you for hours about it but this is

00:14:11,199 --> 00:14:14,560
definitely not the place for that

00:14:13,040 --> 00:14:16,800
and then regular expressions now when i

00:14:14,560 --> 00:14:18,639
talk about regular expressions

00:14:16,800 --> 00:14:20,800
i want to be very clear i'm not talking

00:14:18,639 --> 00:14:23,760
about pearl regex's

00:14:20,800 --> 00:14:24,800
although i believe the pearl regex

00:14:23,760 --> 00:14:28,880
engine

00:14:24,800 --> 00:14:29,760
utilizes um the concept of finite

00:14:28,880 --> 00:14:32,720
automata

00:14:29,760 --> 00:14:34,399
but it's a whole lot more powerful so

00:14:32,720 --> 00:14:35,600
i'm definitely not talking about plural

00:14:34,399 --> 00:14:38,160
regexes here

00:14:35,600 --> 00:14:39,680
i'm talking about the formal concept of

00:14:38,160 --> 00:14:43,040
regular expressions

00:14:39,680 --> 00:14:45,199
uh within the the confines of the formal

00:14:43,040 --> 00:14:47,120
languages or finite automata within

00:14:45,199 --> 00:14:49,360
computer science

00:14:47,120 --> 00:14:50,959
and then i'm finally going to talk about

00:14:49,360 --> 00:14:52,560
i'm going to define what the shuffle

00:14:50,959 --> 00:14:54,480
operator is

00:14:52,560 --> 00:14:56,320
and i'll tell you right now it is an

00:14:54,480 --> 00:15:00,160
operator that sits

00:14:56,320 --> 00:15:02,399
right next to concatenation the union

00:15:00,160 --> 00:15:04,240
and the clean star and it's it's an

00:15:02,399 --> 00:15:05,760
additional operator that

00:15:04,240 --> 00:15:07,760
i don't think most people really have

00:15:05,760 --> 00:15:09,120
heard of because it really hasn't been

00:15:07,760 --> 00:15:11,519
that useful but

00:15:09,120 --> 00:15:14,160
i think i think that it's useful for

00:15:11,519 --> 00:15:14,160
what i'm doing

00:15:15,440 --> 00:15:21,839
so pearl is a uni process

00:15:18,480 --> 00:15:26,079
pearl 5.0 came out in 1994 at that time

00:15:21,839 --> 00:15:27,760
not even linux was supporting smp all

00:15:26,079 --> 00:15:29,519
the machines that we had were single

00:15:27,760 --> 00:15:30,320
process or at least the ones that we had

00:15:29,519 --> 00:15:33,680
at home

00:15:30,320 --> 00:15:36,320
were single process uh nobody was

00:15:33,680 --> 00:15:36,720
nobody was really thinking about you

00:15:36,320 --> 00:15:39,279
know

00:15:36,720 --> 00:15:41,120
utilizing all of the computational power

00:15:39,279 --> 00:15:43,279
that might be on your desktop

00:15:41,120 --> 00:15:44,959
and certainly people were not thinking

00:15:43,279 --> 00:15:48,320
you know how can i

00:15:44,959 --> 00:15:49,519
express something that has parallelism

00:15:48,320 --> 00:15:52,560
or concurrency

00:15:49,519 --> 00:15:55,600
but then run it run it correctly

00:15:52,560 --> 00:15:58,639
in a single process so

00:15:55,600 --> 00:15:59,360
there was no reason for pearl uh to even

00:15:58,639 --> 00:16:02,240
consider

00:15:59,360 --> 00:16:03,920
being anything but a single process when

00:16:02,240 --> 00:16:06,320
5.0 came out

00:16:03,920 --> 00:16:07,440
and that i believe that's a good thing

00:16:06,320 --> 00:16:09,839
because

00:16:07,440 --> 00:16:10,560
a uni process or single process

00:16:09,839 --> 00:16:12,959
environment

00:16:10,560 --> 00:16:14,800
processor environment or single process

00:16:12,959 --> 00:16:15,680
that gives you a lot of power because it

00:16:14,800 --> 00:16:17,519
inherently is

00:16:15,680 --> 00:16:20,959
shared memory you're sharing memory

00:16:17,519 --> 00:16:23,839
among one process one line of execution

00:16:20,959 --> 00:16:24,320
but it provides a consistent memory you

00:16:23,839 --> 00:16:28,079
know when

00:16:24,320 --> 00:16:31,120
when you're programming smp

00:16:28,079 --> 00:16:33,120
you have to consider the the

00:16:31,120 --> 00:16:34,800
state of the memory memory can get

00:16:33,120 --> 00:16:36,880
corrupted if two threads are

00:16:34,800 --> 00:16:38,560
updating at the same time if you're not

00:16:36,880 --> 00:16:41,839
careful

00:16:38,560 --> 00:16:44,959
and it actually you know it

00:16:41,839 --> 00:16:48,000
it actually is

00:16:44,959 --> 00:16:50,000
uh easier to just

00:16:48,000 --> 00:16:51,120
assume that you don't have all of those

00:16:50,000 --> 00:16:54,000
those pitfalls

00:16:51,120 --> 00:16:55,600
but at the same time it allows you to

00:16:54,000 --> 00:16:57,759
maybe think in an s p

00:16:55,600 --> 00:16:58,880
type way for the day let's say that you

00:16:57,759 --> 00:17:01,920
do have

00:16:58,880 --> 00:17:03,600
a true true multi-process environment or

00:17:01,920 --> 00:17:05,360
run time

00:17:03,600 --> 00:17:07,760
so within within pearl there's been a

00:17:05,360 --> 00:17:10,880
ton of a ton of workarounds

00:17:07,760 --> 00:17:12,720
um you know i and i don't like any

00:17:10,880 --> 00:17:14,400
um you know i'm talking about eye

00:17:12,720 --> 00:17:17,600
threads i'm talking about

00:17:14,400 --> 00:17:19,919
any anything that calls

00:17:17,600 --> 00:17:21,919
says it's it's threaded pearl or it

00:17:19,919 --> 00:17:24,959
provides threads

00:17:21,919 --> 00:17:27,199
ultimately if if it's not

00:17:24,959 --> 00:17:29,200
limited to the confines of a single

00:17:27,199 --> 00:17:29,760
pearl process then it's necessarily

00:17:29,200 --> 00:17:32,799
using

00:17:29,760 --> 00:17:34,080
the port system call and i like fork i'm

00:17:32,799 --> 00:17:37,760
a big fan of fork i

00:17:34,080 --> 00:17:40,240
i distribute large workloads using fork

00:17:37,760 --> 00:17:40,799
but what fork doesn't give us is a way

00:17:40,240 --> 00:17:44,240
to

00:17:40,799 --> 00:17:46,799
to generally share

00:17:44,240 --> 00:17:47,520
memory among the processes or the

00:17:46,799 --> 00:17:49,600
children

00:17:47,520 --> 00:17:52,400
and again there's been a ton of ton of

00:17:49,600 --> 00:17:53,440
um solutions to this but they're file

00:17:52,400 --> 00:17:55,360
based

00:17:53,440 --> 00:17:57,840
they're they're messy they don't they

00:17:55,360 --> 00:17:58,640
don't they don't give us what we really

00:17:57,840 --> 00:18:02,080
deserve

00:17:58,640 --> 00:18:04,799
in terms of threading or s p support

00:18:02,080 --> 00:18:06,160
with respect to pearl it really it

00:18:04,799 --> 00:18:08,000
really hampers

00:18:06,160 --> 00:18:09,280
you know our ability to think and be

00:18:08,000 --> 00:18:11,919
creative

00:18:09,280 --> 00:18:13,679
but again i i totally accept the fact

00:18:11,919 --> 00:18:16,000
that this is a uni process and i've

00:18:13,679 --> 00:18:18,640
really come to embrace it

00:18:16,000 --> 00:18:19,919
um and and again i'm gonna focus on i'm

00:18:18,640 --> 00:18:21,919
gonna mention there's been a lot of

00:18:19,919 --> 00:18:23,919
negativity this is one of the areas

00:18:21,919 --> 00:18:25,919
where i guess pearl fights tend to

00:18:23,919 --> 00:18:29,120
happen and it's

00:18:25,919 --> 00:18:31,120
it's in my opinion and i don't think

00:18:29,120 --> 00:18:32,720
anyone would disagree the more that we

00:18:31,120 --> 00:18:35,760
can just embrace

00:18:32,720 --> 00:18:37,919
the the true state of things and uh see

00:18:35,760 --> 00:18:38,720
what we can do within the limitations of

00:18:37,919 --> 00:18:41,039
them

00:18:38,720 --> 00:18:43,039
the better the more that we can all work

00:18:41,039 --> 00:18:44,799
together and focus on providing

00:18:43,039 --> 00:18:46,960
interesting solutions which is what

00:18:44,799 --> 00:18:47,840
pearl the pearl community is absolutely

00:18:46,960 --> 00:18:51,440
known for

00:18:47,840 --> 00:18:52,240
and why i love it but one of those one

00:18:51,440 --> 00:18:56,320
of those things

00:18:52,240 --> 00:18:58,000
is threading or is you know

00:18:56,320 --> 00:19:01,039
providing some sort of concurrent

00:18:58,000 --> 00:19:03,120
semantics and and i think that

00:19:01,039 --> 00:19:05,520
to a large degree when people want

00:19:03,120 --> 00:19:07,919
concurrency or they want threading

00:19:05,520 --> 00:19:09,200
they care more about being able to

00:19:07,919 --> 00:19:11,919
express

00:19:09,200 --> 00:19:13,600
their program or their algorithm in this

00:19:11,919 --> 00:19:15,919
in this way semantically

00:19:13,600 --> 00:19:16,960
rather than the actual speed up of the

00:19:15,919 --> 00:19:19,200
program

00:19:16,960 --> 00:19:20,240
uh speed up of the program is important

00:19:19,200 --> 00:19:22,720
i would love to use

00:19:20,240 --> 00:19:24,720
you know bare metal machines that have

00:19:22,720 --> 00:19:26,960
you know 16 or more processes

00:19:24,720 --> 00:19:28,080
processors that's the kind of thing that

00:19:26,960 --> 00:19:31,200
i like to do but

00:19:28,080 --> 00:19:33,280
but in any case what i

00:19:31,200 --> 00:19:34,400
what i walk away with when i've written

00:19:33,280 --> 00:19:37,120
something

00:19:34,400 --> 00:19:38,160
that uses in an s p style is i just

00:19:37,120 --> 00:19:40,799
think it was a

00:19:38,160 --> 00:19:42,480
pleasant experience and you know i don't

00:19:40,799 --> 00:19:45,520
have to think too much about

00:19:42,480 --> 00:19:48,960
making sure making sure that was correct

00:19:45,520 --> 00:19:51,039
um beyond what was necessary so

00:19:48,960 --> 00:19:52,559
i say there's a similar lining to this

00:19:51,039 --> 00:19:54,720
that we can just start with

00:19:52,559 --> 00:19:56,480
all right we've got a single process but

00:19:54,720 --> 00:20:00,320
we want to write things

00:19:56,480 --> 00:20:00,320
in an implicit shared memory way

00:20:01,760 --> 00:20:04,799
this is kind of how i think about it

00:20:04,320 --> 00:20:07,360
i've got

00:20:04,799 --> 00:20:08,960
on the left i've got a big old bulldozer

00:20:07,360 --> 00:20:11,600
which is the pearl run time

00:20:08,960 --> 00:20:12,799
and then on the right hand side got a

00:20:11,600 --> 00:20:14,480
bunch of all these you know

00:20:12,799 --> 00:20:16,159
bunch of efforts trying to trying to do

00:20:14,480 --> 00:20:18,640
things in parallel um

00:20:16,159 --> 00:20:20,000
it really it really can be seen as a

00:20:18,640 --> 00:20:22,960
boat anchor but i've

00:20:20,000 --> 00:20:25,760
i've more or less moved on from this

00:20:22,960 --> 00:20:25,760
this point of view

00:20:25,840 --> 00:20:29,440
with with the work here so i'm going to

00:20:28,559 --> 00:20:32,799
talk about

00:20:29,440 --> 00:20:36,000
sequential consistency now

00:20:32,799 --> 00:20:37,360
sequential consistency is and i'm not

00:20:36,000 --> 00:20:40,080
going to read landford's

00:20:37,360 --> 00:20:41,679
quote here but i absolutely recommend

00:20:40,080 --> 00:20:44,640
you read the work of this man

00:20:41,679 --> 00:20:46,400
um he works at microsoft research he's

00:20:44,640 --> 00:20:47,360
the creator of the byzantine general

00:20:46,400 --> 00:20:50,320
problem

00:20:47,360 --> 00:20:50,880
he is i think he just won a uh touring

00:20:50,320 --> 00:20:52,880
award

00:20:50,880 --> 00:20:54,720
or one of the one of the top computer

00:20:52,880 --> 00:20:57,120
science awards

00:20:54,720 --> 00:20:59,200
uh within the last few years but but he

00:20:57,120 --> 00:21:02,960
has some very interesting

00:20:59,200 --> 00:21:06,400
work and uh

00:21:02,960 --> 00:21:08,640
he came up with this term so uh

00:21:06,400 --> 00:21:10,640
in my in the way i would describe

00:21:08,640 --> 00:21:14,320
sequential consistency is

00:21:10,640 --> 00:21:16,960
say you had um you know you had

00:21:14,320 --> 00:21:17,919
an algorithm or a program that that did

00:21:16,960 --> 00:21:20,960
things

00:21:17,919 --> 00:21:21,520
in a in a parallel or concurrent way and

00:21:20,960 --> 00:21:24,159
you had

00:21:21,520 --> 00:21:25,440
you had multiple process processors on

00:21:24,159 --> 00:21:27,520
which to do it

00:21:25,440 --> 00:21:30,000
well say you went from multiple

00:21:27,520 --> 00:21:32,640
processors to one processor

00:21:30,000 --> 00:21:34,320
well necessarily you would still have to

00:21:32,640 --> 00:21:36,159
do the same amount of work

00:21:34,320 --> 00:21:37,360
a lot a lot of that work has been

00:21:36,159 --> 00:21:40,960
defined in

00:21:37,360 --> 00:21:41,280
somewhat independent ways but you need

00:21:40,960 --> 00:21:44,480
to

00:21:41,280 --> 00:21:45,760
you need to be able to collapse that

00:21:44,480 --> 00:21:49,520
parallel work

00:21:45,760 --> 00:21:51,440
into a single line of execution

00:21:49,520 --> 00:21:52,559
and the the question about sequential

00:21:51,440 --> 00:21:55,760
consistency is

00:21:52,559 --> 00:22:00,000
how do you do that in a correct way

00:21:55,760 --> 00:22:00,000
and i will talk more about that

00:22:00,480 --> 00:22:04,400
so some more benefit i guess i think i

00:22:03,120 --> 00:22:06,960
already talked about this

00:22:04,400 --> 00:22:08,559
uh inherent so benefits of uni process

00:22:06,960 --> 00:22:11,039
is inherent memory

00:22:08,559 --> 00:22:12,640
consistency there's no actual race

00:22:11,039 --> 00:22:12,960
conditions although you can program them

00:22:12,640 --> 00:22:16,559
in

00:22:12,960 --> 00:22:17,840
certainly express them semantically but

00:22:16,559 --> 00:22:20,080
there's going to be no corruption

00:22:17,840 --> 00:22:22,320
resulting from them

00:22:20,080 --> 00:22:23,120
we have and this is certainly true and

00:22:22,320 --> 00:22:24,480
pro pro

00:22:23,120 --> 00:22:27,200
has powerful runtime memory

00:22:24,480 --> 00:22:30,640
introspection pearl in particular

00:22:27,200 --> 00:22:33,280
has extremely well developed capability

00:22:30,640 --> 00:22:36,240
for different types of scoping

00:22:33,280 --> 00:22:36,799
package scoping file scoping block block

00:22:36,240 --> 00:22:38,320
local

00:22:36,799 --> 00:22:39,840
and then staple subroutines as i've

00:22:38,320 --> 00:22:41,840
already mentioned there's probably more

00:22:39,840 --> 00:22:44,400
that that i don't even know about

00:22:41,840 --> 00:22:45,200
um but those those those are extremely

00:22:44,400 --> 00:22:48,159
powerful

00:22:45,200 --> 00:22:50,880
to the point where i will get on i will

00:22:48,159 --> 00:22:52,799
try to use some other language and

00:22:50,880 --> 00:22:54,400
it will just it will feel incomplete

00:22:52,799 --> 00:22:55,919
because i want to do

00:22:54,400 --> 00:22:57,919
i want to be able to use the scoping

00:22:55,919 --> 00:23:00,960
rules that i'm familiar with and

00:22:57,919 --> 00:23:04,960
sometimes i can't um which is why i

00:23:00,960 --> 00:23:04,960
usually don't ever use other languages

00:23:05,200 --> 00:23:09,039
and i've even extended my thought

00:23:07,840 --> 00:23:11,679
process

00:23:09,039 --> 00:23:13,679
to claim that the the uni process pearl

00:23:11,679 --> 00:23:17,200
has more in common with the uni process

00:23:13,679 --> 00:23:18,960
operating system uh and what i mean

00:23:17,200 --> 00:23:20,400
what i mean i should probably put

00:23:18,960 --> 00:23:22,400
together a talk at some point what i

00:23:20,400 --> 00:23:22,960
mean maybe further develop that concept

00:23:22,400 --> 00:23:24,799
but

00:23:22,960 --> 00:23:26,320
but there's the pearl run time which is

00:23:24,799 --> 00:23:27,919
like the user land and then we've got

00:23:26,320 --> 00:23:30,720
the core which is the kernel

00:23:27,919 --> 00:23:32,320
so you know i i look at i look at pearl

00:23:30,720 --> 00:23:35,919
as an ecosystem

00:23:32,320 --> 00:23:37,919
more as an operating system than uh

00:23:35,919 --> 00:23:39,280
strictly as just a language or just a

00:23:37,919 --> 00:23:40,720
runtime and

00:23:39,280 --> 00:23:42,559
i don't know some of y'all may get that

00:23:40,720 --> 00:23:44,559
joke that i mean

00:23:42,559 --> 00:23:46,720
it lacks pearl's an operating system

00:23:44,559 --> 00:23:48,880
that lacks a decent programming language

00:23:46,720 --> 00:23:50,720
that's an emac strip i guess anyway

00:23:48,880 --> 00:23:53,760
moving on

00:23:50,720 --> 00:23:54,880
okay so pearl's memory model first what

00:23:53,760 --> 00:23:57,760
is a memory model

00:23:54,880 --> 00:23:59,200
uh and this is a wikipedia quote it's

00:23:57,760 --> 00:24:01,039
the interaction

00:23:59,200 --> 00:24:03,600
it's the interaction of threads through

00:24:01,039 --> 00:24:06,400
memory and their shared use of data so

00:24:03,600 --> 00:24:07,440
it's it's given given your computing

00:24:06,400 --> 00:24:10,720
environment

00:24:07,440 --> 00:24:14,880
how how does your program manage

00:24:10,720 --> 00:24:18,080
memory among multiple you know processes

00:24:14,880 --> 00:24:19,120
or lines of execution that are using the

00:24:18,080 --> 00:24:23,039
same memory

00:24:19,120 --> 00:24:25,279
and that that has a lot to do with um

00:24:23,039 --> 00:24:26,880
with the assumptions that you can make

00:24:25,279 --> 00:24:29,679
when you're when you're

00:24:26,880 --> 00:24:30,880
programming in a shared memory way a lot

00:24:29,679 --> 00:24:32,720
of it has to do with

00:24:30,880 --> 00:24:34,000
how does the operating system have

00:24:32,720 --> 00:24:36,000
handle caching

00:24:34,000 --> 00:24:38,400
how does how do the under how does the

00:24:36,000 --> 00:24:40,960
underlying hardware handle caching

00:24:38,400 --> 00:24:42,159
is it um you know is it is it

00:24:40,960 --> 00:24:44,799
architecture pneuma

00:24:42,159 --> 00:24:45,840
so non-uniform memory access is it cc

00:24:44,799 --> 00:24:48,799
ccnuma

00:24:45,840 --> 00:24:49,919
which is cash coherent non-uniform

00:24:48,799 --> 00:24:52,240
memory access

00:24:49,919 --> 00:24:53,520
so you know terms like when you talk

00:24:52,240 --> 00:24:56,000
about memory models

00:24:53,520 --> 00:24:58,159
and shared memory program programming

00:24:56,000 --> 00:24:58,960
your things like pneuma come up things

00:24:58,159 --> 00:25:02,400
like

00:24:58,960 --> 00:25:04,720
cash coherency come up the different

00:25:02,400 --> 00:25:07,120
thing there are classes of algorithms

00:25:04,720 --> 00:25:08,400
that are oblivious to layers to levels

00:25:07,120 --> 00:25:10,720
of cash

00:25:08,400 --> 00:25:11,919
which is another interesting topic you

00:25:10,720 --> 00:25:13,760
may want to look into

00:25:11,919 --> 00:25:15,679
i'm not this has nothing to do with it

00:25:13,760 --> 00:25:16,720
but it's called cache oblivious

00:25:15,679 --> 00:25:18,720
algorithms

00:25:16,720 --> 00:25:20,640
i always thought that was pretty neat um

00:25:18,720 --> 00:25:23,120
but that that at least shows you that

00:25:20,640 --> 00:25:25,120
the memory model the caching model that

00:25:23,120 --> 00:25:27,520
you were forced to use

00:25:25,120 --> 00:25:29,440
either through your hardware or through

00:25:27,520 --> 00:25:30,960
the programming environment has a lot to

00:25:29,440 --> 00:25:31,600
do with the assumptions that you can

00:25:30,960 --> 00:25:33,679
make

00:25:31,600 --> 00:25:34,960
well with since perl is a uni process we

00:25:33,679 --> 00:25:36,400
don't have to worry about any of that

00:25:34,960 --> 00:25:39,760
stuff

00:25:36,400 --> 00:25:42,080
okay so when we talk about

00:25:39,760 --> 00:25:44,480
memory model within perl like i said we

00:25:42,080 --> 00:25:47,679
have a single line of execution

00:25:44,480 --> 00:25:50,559
that is managing memory

00:25:47,679 --> 00:25:51,919
it's a view of memory through the the

00:25:50,559 --> 00:25:55,520
variable scoping

00:25:51,919 --> 00:25:57,679
facilities that pearl has and this also

00:25:55,520 --> 00:25:59,039
has to do with data isolation so it's

00:25:57,679 --> 00:26:00,559
block scoping

00:25:59,039 --> 00:26:02,559
um you know if you want to use if you

00:26:00,559 --> 00:26:04,960
want to localize uh

00:26:02,559 --> 00:26:06,159
something so that you can say you want

00:26:04,960 --> 00:26:10,400
to localize

00:26:06,159 --> 00:26:12,080
the environment the environment hash

00:26:10,400 --> 00:26:13,760
the global environment hashing to run

00:26:12,080 --> 00:26:15,520
time but you don't want it you only want

00:26:13,760 --> 00:26:18,640
to muck with it within a certain

00:26:15,520 --> 00:26:19,520
certain block you would use local that

00:26:18,640 --> 00:26:22,159
sort of stuff

00:26:19,520 --> 00:26:23,600
um and then ref counting certainly has a

00:26:22,159 --> 00:26:26,080
lot to do with that because of the

00:26:23,600 --> 00:26:29,679
garbage collection

00:26:26,080 --> 00:26:32,000
um aspect of pearl and the nice

00:26:29,679 --> 00:26:33,679
the nice things it does for us so that

00:26:32,000 --> 00:26:35,760
we don't have to worry about allocating

00:26:33,679 --> 00:26:37,919
de-allocating freeing memory

00:26:35,760 --> 00:26:40,159
those sorts of things and that all has

00:26:37,919 --> 00:26:43,600
to do with pearl's memory mod

00:26:40,159 --> 00:26:46,240
but it all happens within a

00:26:43,600 --> 00:26:47,039
um you know single line of execution

00:26:46,240 --> 00:26:49,679
there are

00:26:47,039 --> 00:26:50,960
i believe there is one gotcha and i

00:26:49,679 --> 00:26:54,720
think it has to do with

00:26:50,960 --> 00:26:57,120
the the destructors

00:26:54,720 --> 00:26:58,880
there's no for example you can't if you

00:26:57,120 --> 00:27:01,600
have an object

00:26:58,880 --> 00:27:02,799
and you've defined the destructor method

00:27:01,600 --> 00:27:06,080
or

00:27:02,799 --> 00:27:07,039
is it destroy method in any case that

00:27:06,080 --> 00:27:09,440
gets called when

00:27:07,039 --> 00:27:11,039
when the the reference goes out of scope

00:27:09,440 --> 00:27:13,279
but you don't you can't you can't

00:27:11,039 --> 00:27:14,880
actually schedule when that happens so

00:27:13,279 --> 00:27:16,400
as far as i know that's that's one of

00:27:14,880 --> 00:27:19,279
the few

00:27:16,400 --> 00:27:21,279
one of the few danger zones in pearl

00:27:19,279 --> 00:27:22,640
with regard to its uni process memory

00:27:21,279 --> 00:27:25,679
model

00:27:22,640 --> 00:27:28,480
but that can be managed

00:27:25,679 --> 00:27:30,080
um and then the other interesting thing

00:27:28,480 --> 00:27:31,200
i've mentioned and i think that this is

00:27:30,080 --> 00:27:34,240
probably one of the cool

00:27:31,200 --> 00:27:34,960
coolest features of pearl is that it has

00:27:34,240 --> 00:27:38,240
the state

00:27:34,960 --> 00:27:40,559
the easy way to give

00:27:38,240 --> 00:27:42,159
subroutines stateful memory turn them

00:27:40,559 --> 00:27:43,760
into co-routine so

00:27:42,159 --> 00:27:45,279
you know in addition to all of the

00:27:43,760 --> 00:27:47,120
wonderful ways that we can

00:27:45,279 --> 00:27:49,520
dynamically create and define

00:27:47,120 --> 00:27:51,840
subroutines we also have

00:27:49,520 --> 00:27:52,559
have this mechanism so that we can we

00:27:51,840 --> 00:27:55,279
can

00:27:52,559 --> 00:27:55,840
give subroutine memory so that it can

00:27:55,279 --> 00:27:58,320
remember

00:27:55,840 --> 00:27:59,039
things from from the last time it was

00:27:58,320 --> 00:28:01,360
called

00:27:59,039 --> 00:28:02,240
and i think that that's very powerful

00:28:01,360 --> 00:28:05,760
being able

00:28:02,240 --> 00:28:09,600
being able to to track or to remember

00:28:05,760 --> 00:28:12,480
things is uh it's one of the

00:28:09,600 --> 00:28:13,760
it's one of the characteristics of you

00:28:12,480 --> 00:28:16,480
know increasing power

00:28:13,760 --> 00:28:19,200
computational power for example from a

00:28:16,480 --> 00:28:21,679
finite automata which has zero memory

00:28:19,200 --> 00:28:23,520
uh all the way to say a turing machine

00:28:21,679 --> 00:28:26,000
which has random access

00:28:23,520 --> 00:28:27,120
memory and then there's the you know

00:28:26,000 --> 00:28:29,200
push down auto

00:28:27,120 --> 00:28:30,559
automata that's in between and uh

00:28:29,200 --> 00:28:32,399
another one but

00:28:30,559 --> 00:28:34,080
uh i'm not i'm not gonna get into that

00:28:32,399 --> 00:28:37,279
in any case memory

00:28:34,080 --> 00:28:39,200
inc in computing memory equals power

00:28:37,279 --> 00:28:41,200
and whether even though it doesn't give

00:28:39,200 --> 00:28:43,120
us additional computational power

00:28:41,200 --> 00:28:44,240
because we're running you know we're in

00:28:43,120 --> 00:28:47,039
a programming environment

00:28:44,240 --> 00:28:47,440
we have we have turing completeness it

00:28:47,039 --> 00:28:50,559
gives

00:28:47,440 --> 00:28:54,080
us it gives us the ability to

00:28:50,559 --> 00:28:57,279
uh be more implicit so we have to be

00:28:54,080 --> 00:29:00,000
we have to define things less

00:28:57,279 --> 00:29:00,720
or we have to write less code if we can

00:29:00,000 --> 00:29:03,360
if we've got

00:29:00,720 --> 00:29:06,559
things like subroutines i can remember

00:29:03,360 --> 00:29:09,520
from call to call

00:29:06,559 --> 00:29:11,039
okay uh performance i mentioned

00:29:09,520 --> 00:29:13,600
performance earlier

00:29:11,039 --> 00:29:15,440
we're running in a single process

00:29:13,600 --> 00:29:18,720
there's no speed up

00:29:15,440 --> 00:29:21,600
um most most people i think

00:29:18,720 --> 00:29:23,520
i'm contending this this may or may not

00:29:21,600 --> 00:29:25,120
be true it's true for me

00:29:23,520 --> 00:29:27,279
i would prefer to be able to write

00:29:25,120 --> 00:29:30,080
something concurrently or implicitly

00:29:27,279 --> 00:29:32,240
then get some actual speed up although

00:29:30,080 --> 00:29:33,919
speed ups really nice and i love the

00:29:32,240 --> 00:29:36,640
the idea that i'm actually using all the

00:29:33,919 --> 00:29:40,480
cpus on my on my computer

00:29:36,640 --> 00:29:41,679
um but we're not talking and

00:29:40,480 --> 00:29:43,600
what i'm talking about here it isn't

00:29:41,679 --> 00:29:45,360
giving us any of that it's not creating

00:29:43,600 --> 00:29:49,039
actual threaded pearl

00:29:45,360 --> 00:29:52,240
it's not leveraging fork um to utilize

00:29:49,039 --> 00:29:53,600
additional cpus uh to distribute work or

00:29:52,240 --> 00:29:55,200
any of that stuff it's

00:29:53,600 --> 00:29:58,159
what i'm talking about is simply giving

00:29:55,200 --> 00:30:00,720
us a way to describe

00:29:58,159 --> 00:30:02,960
concurrency while we're while we are

00:30:00,720 --> 00:30:07,039
programming

00:30:02,960 --> 00:30:08,799
um but what what this may offer some

00:30:07,039 --> 00:30:10,960
opportunities to provide some actual

00:30:08,799 --> 00:30:12,720
speed up or to provide some some avenues

00:30:10,960 --> 00:30:16,799
that maybe have not been

00:30:12,720 --> 00:30:21,200
um uh possible or easily accessible

00:30:16,799 --> 00:30:24,399
up until now um

00:30:21,200 --> 00:30:27,679
let's see i said most of this uh

00:30:24,399 --> 00:30:29,840
so some issues with with snp programming

00:30:27,679 --> 00:30:31,440
um that are actually done using

00:30:29,840 --> 00:30:33,600
competing processes

00:30:31,440 --> 00:30:35,760
um you know there's comp there's real

00:30:33,600 --> 00:30:39,200
system resources you have to worry about

00:30:35,760 --> 00:30:40,720
there's your disk i o there's network

00:30:39,200 --> 00:30:43,360
there's a potential for corrupting

00:30:40,720 --> 00:30:44,159
memory there's potential for overwrite

00:30:43,360 --> 00:30:46,080
so though

00:30:44,159 --> 00:30:48,159
what we're doing here doesn't save save

00:30:46,080 --> 00:30:50,799
you from that one

00:30:48,159 --> 00:30:53,600
but aside from the fact that we're

00:30:50,799 --> 00:30:56,399
running in a single process

00:30:53,600 --> 00:30:56,960
uh we get a lot of safety in the fact

00:30:56,399 --> 00:30:58,799
that

00:30:56,960 --> 00:31:00,640
there's there's not going to be there's

00:30:58,799 --> 00:31:04,000
no real potential for

00:31:00,640 --> 00:31:06,799
for unsafe things to occur um

00:31:04,000 --> 00:31:08,480
but that that but we have not taken away

00:31:06,799 --> 00:31:09,679
a lot of the benefits of being able to

00:31:08,480 --> 00:31:12,000
think of

00:31:09,679 --> 00:31:12,880
how we're programming or scheduling um

00:31:12,000 --> 00:31:16,960
the extra

00:31:12,880 --> 00:31:19,840
defining our execution um plan

00:31:16,960 --> 00:31:20,960
in a concurrent way all right finally a

00:31:19,840 --> 00:31:23,360
picture

00:31:20,960 --> 00:31:24,559
and most of his pictures from now on i'm

00:31:23,360 --> 00:31:26,480
watching the time

00:31:24,559 --> 00:31:27,919
and uh we'll try and get through all of

00:31:26,480 --> 00:31:30,000
this so

00:31:27,919 --> 00:31:32,080
this is a program it's not implemented

00:31:30,000 --> 00:31:34,559
in any way but this is this is a this is

00:31:32,080 --> 00:31:36,240
my attempt to show a true multi-threaded

00:31:34,559 --> 00:31:39,279
program

00:31:36,240 --> 00:31:40,880
you've got cpu one and cpu two there and

00:31:39,279 --> 00:31:43,279
then you've got

00:31:40,880 --> 00:31:44,000
the two threads each thread consists of

00:31:43,279 --> 00:31:47,519
say three

00:31:44,000 --> 00:31:49,840
three uh three operations that are

00:31:47,519 --> 00:31:52,720
dependent on on the one that precedes it

00:31:49,840 --> 00:31:53,200
so in cpu one you've got thread the

00:31:52,720 --> 00:31:55,760
thread

00:31:53,200 --> 00:31:56,320
where task a has to happen before test b

00:31:55,760 --> 00:31:58,799
test b

00:31:56,320 --> 00:32:00,399
has to happen before task c and the same

00:31:58,799 --> 00:32:03,679
thing with cpu

00:32:00,399 --> 00:32:05,840
two and you've got tech task x y and z

00:32:03,679 --> 00:32:07,200
there's a there's a total ordering

00:32:05,840 --> 00:32:11,440
within each thread

00:32:07,200 --> 00:32:14,880
of those tasks but there's no dependency

00:32:11,440 --> 00:32:18,000
between any of the tasks on cpu one

00:32:14,880 --> 00:32:20,880
and any of the tests in cpu2 and this is

00:32:18,000 --> 00:32:22,640
this is the this is called a partial

00:32:20,880 --> 00:32:23,279
ordering and there's no dependency

00:32:22,640 --> 00:32:26,399
between

00:32:23,279 --> 00:32:27,519
a abc and an xyz but there's a total

00:32:26,399 --> 00:32:30,000
ordering

00:32:27,519 --> 00:32:31,360
among a b c and then there's a total

00:32:30,000 --> 00:32:34,480
ordering among x y

00:32:31,360 --> 00:32:35,519
z so those are two that's the kind of

00:32:34,480 --> 00:32:37,760
ordering

00:32:35,519 --> 00:32:39,120
tells us the kind of constraints we have

00:32:37,760 --> 00:32:42,399
if we wanted to

00:32:39,120 --> 00:32:45,760
re you know serialize this go from

00:32:42,399 --> 00:32:48,640
two cpus to one cpu

00:32:45,760 --> 00:32:49,919
um this is just pretty much what i said

00:32:48,640 --> 00:32:52,799
before

00:32:49,919 --> 00:32:55,279
oh so i do talk a little more about

00:32:52,799 --> 00:32:58,480
total ordering so a a must proceed b

00:32:55,279 --> 00:33:00,720
b must proceed c same with x y and z

00:32:58,480 --> 00:33:01,840
partial ordering is exactly what i said

00:33:00,720 --> 00:33:05,039
before

00:33:01,840 --> 00:33:06,000
uh the tasks in the set abc have nothing

00:33:05,039 --> 00:33:08,720
to do with

00:33:06,000 --> 00:33:10,000
the tasks in xyz and they can happen in

00:33:08,720 --> 00:33:11,760
any order with respect

00:33:10,000 --> 00:33:13,360
to one another as long as the total

00:33:11,760 --> 00:33:16,399
ordering within the freddy's is

00:33:13,360 --> 00:33:18,559
respect um

00:33:16,399 --> 00:33:21,600
so what if we wanted to go down to from

00:33:18,559 --> 00:33:24,799
from say two cpus to one cpu

00:33:21,600 --> 00:33:26,799
well we would

00:33:24,799 --> 00:33:28,559
you can call it sequentialization you

00:33:26,799 --> 00:33:29,600
can call it serialization you can call

00:33:28,559 --> 00:33:32,320
it linear

00:33:29,600 --> 00:33:34,480
linearization uh but the point is we

00:33:32,320 --> 00:33:37,519
want to be able to

00:33:34,480 --> 00:33:40,640
say uh take the

00:33:37,519 --> 00:33:43,039
implicit ordering that may happen among

00:33:40,640 --> 00:33:44,880
these the partial order tasks that are

00:33:43,039 --> 00:33:47,840
operating over two cpus

00:33:44,880 --> 00:33:49,600
and put them in a valid form if they

00:33:47,840 --> 00:33:53,120
were to occur in a single

00:33:49,600 --> 00:33:54,960
cpu so the the top

00:33:53,120 --> 00:33:56,799
graph is the one i was showing before in

00:33:54,960 --> 00:34:00,640
the last two slides the bottom

00:33:56,799 --> 00:34:03,760
is what what a valid one of many

00:34:00,640 --> 00:34:06,399
valid execution orders would look like

00:34:03,760 --> 00:34:07,760
if you went down to one cpu and this is

00:34:06,399 --> 00:34:11,040
the obvious one it's

00:34:07,760 --> 00:34:12,800
every abc happened and then xyz

00:34:11,040 --> 00:34:15,520
happened but the important thing to note

00:34:12,800 --> 00:34:17,839
is we're maintaining that total ordering

00:34:15,520 --> 00:34:22,079
that was defined before

00:34:17,839 --> 00:34:24,399
among a b and c and then x y and z

00:34:22,079 --> 00:34:26,159
and at the bottom i've got you'll see

00:34:24,399 --> 00:34:29,359
it's like a string right it's a b

00:34:26,159 --> 00:34:30,720
c x y z that that is defining the the

00:34:29,359 --> 00:34:34,000
execution order

00:34:30,720 --> 00:34:37,119
a valid execution order in fact

00:34:34,000 --> 00:34:40,960
this is all of them if you were to

00:34:37,119 --> 00:34:43,280
enumerate all of the valid ways that

00:34:40,960 --> 00:34:44,720
you could combine this string down to

00:34:43,280 --> 00:34:47,839
one where

00:34:44,720 --> 00:34:49,760
x abc abc

00:34:47,839 --> 00:34:51,919
respected its total ordering and then

00:34:49,760 --> 00:34:54,639
xyz respected its total ordering

00:34:51,919 --> 00:34:56,800
but then you can mix up anything from

00:34:54,639 --> 00:34:57,599
the first set with the second set in any

00:34:56,800 --> 00:35:00,000
order

00:34:57,599 --> 00:35:01,440
okay this is what you would get and this

00:35:00,000 --> 00:35:05,599
this is what you would describe

00:35:01,440 --> 00:35:07,920
as as a interleaving of things

00:35:05,599 --> 00:35:07,920
okay

00:35:08,720 --> 00:35:11,040
um

00:35:12,720 --> 00:35:15,760
yeah saying the same thing but it's

00:35:14,320 --> 00:35:17,520
another example

00:35:15,760 --> 00:35:20,320
the the all of the strings on the left

00:35:17,520 --> 00:35:21,520
hand side are all of the valid orderings

00:35:20,320 --> 00:35:23,440
and it's important i'm saying i'm

00:35:21,520 --> 00:35:25,359
calling them strings on purpose we're

00:35:23,440 --> 00:35:29,200
about to start talking about

00:35:25,359 --> 00:35:29,200
regular expressions and finite atomic

00:35:29,440 --> 00:35:32,480
now the question is how do we take

00:35:31,119 --> 00:35:35,680
something like this

00:35:32,480 --> 00:35:38,960
and then turn it into

00:35:35,680 --> 00:35:40,960
one of these strings well first thing to

00:35:38,960 --> 00:35:43,040
recognize is this is that this is a

00:35:40,960 --> 00:35:44,079
dependency graph it's a it's a directed

00:35:43,040 --> 00:35:46,240
graph

00:35:44,079 --> 00:35:48,800
and it kind of looks suspiciously like a

00:35:46,240 --> 00:35:51,760
finite automata that would result from

00:35:48,800 --> 00:35:52,400
um from converting a regular expression

00:35:51,760 --> 00:35:55,520
into

00:35:52,400 --> 00:35:58,320
a deterministic finite atomic

00:35:55,520 --> 00:35:59,440
and then you look at a little more step

00:35:58,320 --> 00:36:01,359
back and

00:35:59,440 --> 00:36:03,680
you know within the circles i have task

00:36:01,359 --> 00:36:06,000
a test b task c

00:36:03,680 --> 00:36:07,599
a finite automata typically has the

00:36:06,000 --> 00:36:10,240
characters on the labels on the

00:36:07,599 --> 00:36:12,000
transitions themselves or the arrows

00:36:10,240 --> 00:36:14,160
and then within the circles those are

00:36:12,000 --> 00:36:18,560
actually given numbers

00:36:14,160 --> 00:36:20,960
um and called states and then

00:36:18,560 --> 00:36:21,839
you remember the day that you've skipped

00:36:20,960 --> 00:36:24,240
when they cover

00:36:21,839 --> 00:36:26,320
covered the shuffle operators and i'm

00:36:24,240 --> 00:36:29,520
going to talk more about that

00:36:26,320 --> 00:36:32,400
the day in computer science classes

00:36:29,520 --> 00:36:34,160
all right so this is a breakdown of the

00:36:32,400 --> 00:36:37,119
different kinds of finite automata

00:36:34,160 --> 00:36:37,760
i'm talking about finite automata within

00:36:37,119 --> 00:36:39,839
the

00:36:37,760 --> 00:36:41,680
within the subject of formal languages

00:36:39,839 --> 00:36:44,400
and computer science

00:36:41,680 --> 00:36:45,680
it's literally just a directed graph the

00:36:44,400 --> 00:36:48,880
edges are labeled

00:36:45,680 --> 00:36:52,160
with with symbols the

00:36:48,880 --> 00:36:53,760
states are numbered so i don't have the

00:36:52,160 --> 00:36:57,040
formal definition here

00:36:53,760 --> 00:36:59,200
but the things that are on the on the

00:36:57,040 --> 00:37:00,480
that decorate the edges the late the

00:36:59,200 --> 00:37:03,520
labels

00:37:00,480 --> 00:37:05,520
that is that consists of the alphabet so

00:37:03,520 --> 00:37:08,079
typically a through z

00:37:05,520 --> 00:37:09,680
you can add some other symbols and then

00:37:08,079 --> 00:37:11,599
the states themselves are not

00:37:09,680 --> 00:37:13,520
explicitly defined so when you define a

00:37:11,599 --> 00:37:15,280
regular expression what you're doing is

00:37:13,520 --> 00:37:17,599
you're defining the transition among

00:37:15,280 --> 00:37:20,240
states you're not defining

00:37:17,599 --> 00:37:21,280
the nodes themselves those are implied

00:37:20,240 --> 00:37:23,359
as opposed to

00:37:21,280 --> 00:37:24,320
other ways that you can define directed

00:37:23,359 --> 00:37:27,520
graphs

00:37:24,320 --> 00:37:29,520
you would define the node

00:37:27,520 --> 00:37:31,200
and then you would define the edge and

00:37:29,520 --> 00:37:32,320
then you may have a label on the edge

00:37:31,200 --> 00:37:34,880
you may not

00:37:32,320 --> 00:37:36,480
but we're taking sort of a sort of a

00:37:34,880 --> 00:37:39,599
different approach

00:37:36,480 --> 00:37:42,560
so deterministic finite automata those

00:37:39,599 --> 00:37:43,280
are um those are typically what people

00:37:42,560 --> 00:37:46,480
think of when

00:37:43,280 --> 00:37:48,720
when you consider finite automata it

00:37:46,480 --> 00:37:50,960
is deterministic meaning it is

00:37:48,720 --> 00:37:52,320
explicitly defined every transition is

00:37:50,960 --> 00:37:55,359
defined even down

00:37:52,320 --> 00:37:56,720
to like if you if if it were if it were

00:37:55,359 --> 00:37:59,119
you were trying to figure out if the

00:37:56,720 --> 00:38:02,400
string was was acceptable

00:37:59,119 --> 00:38:05,839
in this dfa um then

00:38:02,400 --> 00:38:08,079
it would not only would it not

00:38:05,839 --> 00:38:08,960
not so you don't define it not being

00:38:08,079 --> 00:38:10,800
accepted by

00:38:08,960 --> 00:38:12,000
it's just not going anywhere you

00:38:10,800 --> 00:38:13,680
literally have to define

00:38:12,000 --> 00:38:15,760
what they call sync state so it has to

00:38:13,680 --> 00:38:18,240
go somewhere but

00:38:15,760 --> 00:38:18,800
whether it's accepted by the transition

00:38:18,240 --> 00:38:20,960
or not

00:38:18,800 --> 00:38:21,839
determines whether you proceed

00:38:20,960 --> 00:38:25,440
throughout through the

00:38:21,839 --> 00:38:28,000
through a path from a start state to a

00:38:25,440 --> 00:38:29,359
accepting state in the dfa or if you go

00:38:28,000 --> 00:38:31,040
into a sync state and then that

00:38:29,359 --> 00:38:32,400
of course indicates that you're dead in

00:38:31,040 --> 00:38:34,800
the water

00:38:32,400 --> 00:38:36,880
non-determining non-deterministic finite

00:38:34,800 --> 00:38:38,960
automata is a class of finite automata

00:38:36,880 --> 00:38:39,680
it's equivalent to dfas it has something

00:38:38,960 --> 00:38:41,839
called

00:38:39,680 --> 00:38:43,200
an epsilon transition and these are

00:38:41,839 --> 00:38:44,480
transitions that just happen

00:38:43,200 --> 00:38:48,800
automatically

00:38:44,480 --> 00:38:53,040
and it is this is where

00:38:48,800 --> 00:38:56,079
you get the a way to implicitly define

00:38:53,040 --> 00:38:59,680
a finite automaton and it

00:38:56,079 --> 00:39:02,000
necessarily compacts the state space

00:38:59,680 --> 00:39:03,680
and there is a way there's an algorithm

00:39:02,000 --> 00:39:05,440
called subset construction that would

00:39:03,680 --> 00:39:07,359
allow you to go from non-deterministic

00:39:05,440 --> 00:39:10,800
finite automata to it to a

00:39:07,359 --> 00:39:13,440
dfa now if you think about

00:39:10,800 --> 00:39:14,640
if you think about a string if checking

00:39:13,440 --> 00:39:15,760
a string

00:39:14,640 --> 00:39:17,040
i should probably should have had an

00:39:15,760 --> 00:39:18,400
animation for this but if you have a

00:39:17,040 --> 00:39:19,839
string and you wanted to know if it was

00:39:18,400 --> 00:39:22,960
accepted by this dfa

00:39:19,839 --> 00:39:25,839
if it matched a regular expression okay

00:39:22,960 --> 00:39:27,119
then with dfa i said you had you have

00:39:25,839 --> 00:39:29,839
actual sync states

00:39:27,119 --> 00:39:31,359
where the execution path would go in if

00:39:29,839 --> 00:39:32,400
it was not accepted if there were no

00:39:31,359 --> 00:39:33,920
transitions on

00:39:32,400 --> 00:39:36,079
the symbol that's currently being

00:39:33,920 --> 00:39:38,400
considered in non-determinic

00:39:36,079 --> 00:39:40,880
non-deterministic finite automata it's

00:39:38,400 --> 00:39:43,599
sort of like the multiverse

00:39:40,880 --> 00:39:44,079
multiverse thing where you've got all

00:39:43,599 --> 00:39:47,599
these

00:39:44,079 --> 00:39:50,800
like parallel worlds where the

00:39:47,599 --> 00:39:52,480
due to the epsilon transitions which

00:39:50,800 --> 00:39:55,280
just happen automatically

00:39:52,480 --> 00:39:56,079
you're considering a single string but

00:39:55,280 --> 00:39:59,599
you're considering

00:39:56,079 --> 00:40:03,119
it over multiple uh

00:39:59,599 --> 00:40:05,440
potential acceptances so you're testing

00:40:03,119 --> 00:40:08,560
it in multiple different universes

00:40:05,440 --> 00:40:11,680
the in the universes in which

00:40:08,560 --> 00:40:12,640
it is not a valid string they just kind

00:40:11,680 --> 00:40:14,400
of disappear

00:40:12,640 --> 00:40:15,839
so they kind of die on the vine there's

00:40:14,400 --> 00:40:17,680
no sync state

00:40:15,839 --> 00:40:18,880
you don't know what happened you just

00:40:17,680 --> 00:40:21,119
can imagine that

00:40:18,880 --> 00:40:22,240
there was that universe just collapsed

00:40:21,119 --> 00:40:25,359
and went away

00:40:22,240 --> 00:40:26,880
where the universe is that um for the

00:40:25,359 --> 00:40:28,720
universe is where

00:40:26,880 --> 00:40:30,000
you know so far so good the string is

00:40:28,720 --> 00:40:33,760
being accepted and there's

00:40:30,000 --> 00:40:36,160
an actual path then

00:40:33,760 --> 00:40:39,040
an accepted and accepted string will

00:40:36,160 --> 00:40:41,839
eventually land on an accept state

00:40:39,040 --> 00:40:43,680
and you it's sort of like the you know

00:40:41,839 --> 00:40:46,640
the schrodinger's thing where things

00:40:43,680 --> 00:40:47,760
you know where things collapse if a

00:40:46,640 --> 00:40:50,400
string is accepted within a

00:40:47,760 --> 00:40:52,480
non-deterministic finite automata then

00:40:50,400 --> 00:40:54,400
the the whole thing collapses down and

00:40:52,480 --> 00:40:57,520
it's you end up in an

00:40:54,400 --> 00:40:58,720
accept state um there's no i don't know

00:40:57,520 --> 00:41:00,800
if you can

00:40:58,720 --> 00:41:02,640
implement this on quantum computers i

00:41:00,800 --> 00:41:04,800
really don't understand that stuff but

00:41:02,640 --> 00:41:07,040
but if you the only way you can't really

00:41:04,800 --> 00:41:07,839
emulate actual non-deterministic finite

00:41:07,040 --> 00:41:10,480
automata

00:41:07,839 --> 00:41:11,760
on hardware it's more of a thought

00:41:10,480 --> 00:41:13,440
exercise

00:41:11,760 --> 00:41:15,040
but you can kind of do it because you

00:41:13,440 --> 00:41:16,240
can just have this massively parallel

00:41:15,040 --> 00:41:19,359
machine

00:41:16,240 --> 00:41:21,760
checking a string on this massively

00:41:19,359 --> 00:41:23,280
non-deterministic finite automata but

00:41:21,760 --> 00:41:24,800
you're actually you know you're actually

00:41:23,280 --> 00:41:25,599
in one universe and you're actually

00:41:24,800 --> 00:41:27,040
checking

00:41:25,599 --> 00:41:28,960
each of these things in parallel so

00:41:27,040 --> 00:41:31,119
that's but the non-terminic

00:41:28,960 --> 00:41:32,480
non-deterministic finite atomic gives

00:41:31,119 --> 00:41:36,000
you that

00:41:32,480 --> 00:41:39,200
notion of the parallel universes or or

00:41:36,000 --> 00:41:40,000
in independence among you know different

00:41:39,200 --> 00:41:43,599
things that you're

00:41:40,000 --> 00:41:46,800
you're checking parallel finite automata

00:41:43,599 --> 00:41:48,160
as an additional transition it's called

00:41:46,800 --> 00:41:51,359
a lambda transition

00:41:48,160 --> 00:41:52,960
and this is this cut is where

00:41:51,359 --> 00:41:54,960
the shuffle operator comes in because

00:41:52,960 --> 00:41:58,160
the shuffle operator

00:41:54,960 --> 00:41:59,119
adds that lambda transition now one

00:41:58,160 --> 00:42:01,280
thing to note

00:41:59,119 --> 00:42:03,520
if anybody's interested after this

00:42:01,280 --> 00:42:05,520
parallel finite automata are equivalent

00:42:03,520 --> 00:42:07,440
to binary petri nets

00:42:05,520 --> 00:42:09,760
and there's a paper by stats and pew in

00:42:07,440 --> 00:42:11,359
1994 it talks it's called parallel

00:42:09,760 --> 00:42:12,800
regular expressions and this is kind of

00:42:11,359 --> 00:42:16,160
what kicked me off

00:42:12,800 --> 00:42:18,560
kicking onto this this whole thing but

00:42:16,160 --> 00:42:20,319
there they talk about their focus is on

00:42:18,560 --> 00:42:21,200
on petri nuts and they go through and

00:42:20,319 --> 00:42:22,880
they explain

00:42:21,200 --> 00:42:24,480
you know what a petri net is what

00:42:22,880 --> 00:42:28,640
atlanta transition is

00:42:24,480 --> 00:42:30,560
and how uh how you can define a petri

00:42:28,640 --> 00:42:32,000
net using what they call a parallel

00:42:30,560 --> 00:42:34,560
regular expression

00:42:32,000 --> 00:42:35,280
and then you can trans you can transform

00:42:34,560 --> 00:42:38,319
that parallel

00:42:35,280 --> 00:42:40,079
or convert the parallel

00:42:38,319 --> 00:42:41,680
regular expression which is just a

00:42:40,079 --> 00:42:42,880
regular expression with the shuffle

00:42:41,680 --> 00:42:45,440
operator

00:42:42,880 --> 00:42:46,079
into a parallel finite automata which is

00:42:45,440 --> 00:42:48,720
just

00:42:46,079 --> 00:42:50,079
an nfa with the additional lambda

00:42:48,720 --> 00:42:52,400
transition

00:42:50,079 --> 00:42:54,480
okay and what the shuffle operator

00:42:52,400 --> 00:42:57,440
implements is more of an interleaving

00:42:54,480 --> 00:42:59,680
of languages uh and i'll show you some

00:42:57,440 --> 00:43:02,880
more i need to start moving faster

00:42:59,680 --> 00:43:04,960
so in the deterministic finite automata

00:43:02,880 --> 00:43:07,040
you've got the operators i think many

00:43:04,960 --> 00:43:09,599
people are mostly used to

00:43:07,040 --> 00:43:11,200
with the pro regexes and these these are

00:43:09,599 --> 00:43:14,319
these mean the same thing

00:43:11,200 --> 00:43:16,560
there's concatenation which is

00:43:14,319 --> 00:43:18,319
usually it's usually implied by just

00:43:16,560 --> 00:43:18,960
symbols being next to one another so

00:43:18,319 --> 00:43:20,640
like you just

00:43:18,960 --> 00:43:22,400
you know you write a string and those

00:43:20,640 --> 00:43:24,640
are concatenated uh we

00:43:22,400 --> 00:43:26,160
also have the concatenation operator

00:43:24,640 --> 00:43:28,480
which is the dot

00:43:26,160 --> 00:43:29,520
so it's it's the same thing it's just

00:43:28,480 --> 00:43:32,480
concatenating

00:43:29,520 --> 00:43:33,839
symbols into a string there's union

00:43:32,480 --> 00:43:35,839
which is the or

00:43:33,839 --> 00:43:38,480
and then there's a clean star which is

00:43:35,839 --> 00:43:40,319
you get zero or more

00:43:38,480 --> 00:43:42,319
the regular expressions in the computer

00:43:40,319 --> 00:43:43,200
science world don't have anything else

00:43:42,319 --> 00:43:46,240
there's no

00:43:43,200 --> 00:43:50,000
there's no you know saying i want

00:43:46,240 --> 00:43:52,560
you know zero or one i want you know

00:43:50,000 --> 00:43:53,040
um you know there's nothing like we have

00:43:52,560 --> 00:43:54,800
in the

00:43:53,040 --> 00:43:56,560
regular expressions that define some

00:43:54,800 --> 00:43:58,800
limitations on i want five of these

00:43:56,560 --> 00:44:00,800
things or i want zero or more

00:43:58,800 --> 00:44:01,920
you know there's nothing like the plus

00:44:00,800 --> 00:44:04,240
uh that sort of thing

00:44:01,920 --> 00:44:05,280
so so this is what we have when we're

00:44:04,240 --> 00:44:08,079
talking about

00:44:05,280 --> 00:44:09,599
uh dfas and formal languages in the

00:44:08,079 --> 00:44:11,440
computer science world

00:44:09,599 --> 00:44:13,040
non-deterministic finite atomic doesn't

00:44:11,440 --> 00:44:15,119
give you anything else it just gives you

00:44:13,040 --> 00:44:16,800
that additional epsilon transition so

00:44:15,119 --> 00:44:18,079
you have concatenation union and clean

00:44:16,800 --> 00:44:20,560
star

00:44:18,079 --> 00:44:22,800
with parallel finite automata you get

00:44:20,560 --> 00:44:24,880
concatenation union and the clean star

00:44:22,800 --> 00:44:26,960
but you also get the shuffle operator

00:44:24,880 --> 00:44:29,680
and i mentioned again here it's

00:44:26,960 --> 00:44:31,520
equivalent to a binary petri net

00:44:29,680 --> 00:44:33,520
there's probably a lot more information

00:44:31,520 --> 00:44:36,960
online about petri nets than

00:44:33,520 --> 00:44:39,680
uh pfas um let's see

00:44:36,960 --> 00:44:41,839
so one thing to note is operate valid

00:44:39,680 --> 00:44:44,480
operators in regular languages

00:44:41,839 --> 00:44:45,200
are necessarily closed they call it

00:44:44,480 --> 00:44:47,920
closed

00:44:45,200 --> 00:44:50,000
in in uh under regular languages what

00:44:47,920 --> 00:44:53,680
that means is

00:44:50,000 --> 00:44:55,760
if if you want if you want an operator

00:44:53,680 --> 00:44:57,680
like say the concatenation to be

00:44:55,760 --> 00:45:00,079
considered a regular operator

00:44:57,680 --> 00:45:02,319
within a regular language the

00:45:00,079 --> 00:45:04,079
concatenation of two strings or we can

00:45:02,319 --> 00:45:07,680
say even two languages regular

00:45:04,079 --> 00:45:10,480
languages has to result in

00:45:07,680 --> 00:45:12,240
itself a regular language there's a lot

00:45:10,480 --> 00:45:14,160
of things you can do with right between

00:45:12,240 --> 00:45:16,240
with regular languages and combine them

00:45:14,160 --> 00:45:19,359
in all kinds of ways

00:45:16,240 --> 00:45:20,880
that require say a push down automata to

00:45:19,359 --> 00:45:23,599
accept them or to

00:45:20,880 --> 00:45:24,319
to detect them so you could very easily

00:45:23,599 --> 00:45:26,560
combine

00:45:24,319 --> 00:45:28,319
two regular languages in a way that

00:45:26,560 --> 00:45:30,720
would either make them a context

00:45:28,319 --> 00:45:32,640
context sensitive language or context

00:45:30,720 --> 00:45:34,079
free language or even some sort of

00:45:32,640 --> 00:45:36,800
universal language

00:45:34,079 --> 00:45:38,880
so so when we talk about operator

00:45:36,800 --> 00:45:39,680
regular operators we need to make sure

00:45:38,880 --> 00:45:41,520
that it has

00:45:39,680 --> 00:45:43,200
certain properties one of those

00:45:41,520 --> 00:45:44,400
properties is that it results in a

00:45:43,200 --> 00:45:47,520
regular language

00:45:44,400 --> 00:45:50,000
and the shuffle operator does this and i

00:45:47,520 --> 00:45:50,800
i am kind of on a hunt for other

00:45:50,000 --> 00:45:54,319
operators

00:45:50,800 --> 00:45:56,720
um but it's not super easy to find so

00:45:54,319 --> 00:45:57,920
i may need to uh dig a little deeper

00:45:56,720 --> 00:46:00,960
into that

00:45:57,920 --> 00:46:02,160
but the shuffle operator i meant to put

00:46:00,960 --> 00:46:04,720
a picture of this book

00:46:02,160 --> 00:46:06,560
um the book that i and i still have this

00:46:04,720 --> 00:46:07,280
copy for many years ago and it's pretty

00:46:06,560 --> 00:46:09,599
worn because i

00:46:07,280 --> 00:46:10,480
i really dove into it it was an

00:46:09,599 --> 00:46:12,319
introduction to

00:46:10,480 --> 00:46:13,599
automated theory languages and

00:46:12,319 --> 00:46:17,200
computation

00:46:13,599 --> 00:46:19,200
by hopkoff matuani and omen

00:46:17,200 --> 00:46:21,200
and uh hopcroft and almond recently just

00:46:19,200 --> 00:46:22,880
won a uh touring award for off by the

00:46:21,200 --> 00:46:26,720
way i don't know if you knew that

00:46:22,880 --> 00:46:28,319
but but in any case in this book

00:46:26,720 --> 00:46:30,160
they don't even formally cover the

00:46:28,319 --> 00:46:33,440
shuffle operator in fact

00:46:30,160 --> 00:46:35,280
they bring it up in a assignment in the

00:46:33,440 --> 00:46:37,119
back of the book

00:46:35,280 --> 00:46:39,200
and i didn't even know that uh until i

00:46:37,119 --> 00:46:40,800
read that stocks and q paper many years

00:46:39,200 --> 00:46:41,760
ago but i thought that was interesting

00:46:40,800 --> 00:46:43,680
that

00:46:41,760 --> 00:46:45,040
i would i would love to see some kind of

00:46:43,680 --> 00:46:47,359
paper information on

00:46:45,040 --> 00:46:49,119
what what is what are all of the regular

00:46:47,359 --> 00:46:51,760
operators because

00:46:49,119 --> 00:46:52,480
as we can see with the shuffle operator

00:46:51,760 --> 00:46:54,720
it

00:46:52,480 --> 00:46:56,560
it's useful for something it's not you

00:46:54,720 --> 00:46:57,040
know it may not be immediately obvious

00:46:56,560 --> 00:47:00,000
but

00:46:57,040 --> 00:47:00,400
if you you can apply it to other things

00:47:00,000 --> 00:47:02,880
um

00:47:00,400 --> 00:47:03,599
and and leverage it for some interesting

00:47:02,880 --> 00:47:05,200
things

00:47:03,599 --> 00:47:06,640
all right so this is an example of a

00:47:05,200 --> 00:47:09,920
shuffle so

00:47:06,640 --> 00:47:10,560
we we have two languages we have string

00:47:09,920 --> 00:47:12,319
av

00:47:10,560 --> 00:47:14,160
and you can consider that a language a

00:47:12,319 --> 00:47:14,880
regular language it's just the string a

00:47:14,160 --> 00:47:18,720
b

00:47:14,880 --> 00:47:22,960
and then language two which is cd

00:47:18,720 --> 00:47:25,520
now if i were to shuffle these two then

00:47:22,960 --> 00:47:26,000
that means that the resulting string

00:47:25,520 --> 00:47:28,319
these

00:47:26,000 --> 00:47:30,480
the resulting valid strings of the

00:47:28,319 --> 00:47:33,440
combined or the shuffled language

00:47:30,480 --> 00:47:35,760
would necessarily have to include a

00:47:33,440 --> 00:47:38,880
vowel a string that is valid

00:47:35,760 --> 00:47:41,200
in language one and language 2.

00:47:38,880 --> 00:47:42,960
so that means that any valid string has

00:47:41,200 --> 00:47:46,160
to have av

00:47:42,960 --> 00:47:49,280
and cd but it says nothing about

00:47:46,160 --> 00:47:51,359
how those strings need to

00:47:49,280 --> 00:47:52,800
be ordered with respect to the two

00:47:51,359 --> 00:47:54,640
different languages

00:47:52,800 --> 00:47:57,119
the valid language with within each

00:47:54,640 --> 00:48:00,960
language obviously has to remain totally

00:47:57,119 --> 00:48:04,160
ordered but the ordering among the valid

00:48:00,960 --> 00:48:05,680
between the valid strings

00:48:04,160 --> 00:48:07,280
of the two different languages can can

00:48:05,680 --> 00:48:09,200
be interleaved in any order

00:48:07,280 --> 00:48:10,720
and i think hopefully this this looks

00:48:09,200 --> 00:48:11,280
exactly like what we were talking about

00:48:10,720 --> 00:48:13,200
before

00:48:11,280 --> 00:48:14,480
how do you how do you take something

00:48:13,200 --> 00:48:18,480
that is parallel and

00:48:14,480 --> 00:48:20,880
and correctly uh enumerated as

00:48:18,480 --> 00:48:21,839
uh sequential well this is how you do it

00:48:20,880 --> 00:48:24,319
because it's really just

00:48:21,839 --> 00:48:26,160
interleaving a and b have to happen in

00:48:24,319 --> 00:48:26,960
that order c and d have to happen in

00:48:26,160 --> 00:48:29,040
that order

00:48:26,960 --> 00:48:31,119
but you can and you put you and you also

00:48:29,040 --> 00:48:33,280
have to create a single string

00:48:31,119 --> 00:48:34,640
which is just a single line of execution

00:48:33,280 --> 00:48:39,119
let's say

00:48:34,640 --> 00:48:39,760
and um and then present it in this way

00:48:39,119 --> 00:48:42,079
so

00:48:39,760 --> 00:48:44,960
you can you can interleave the valid

00:48:42,079 --> 00:48:44,960
strings okay

00:48:45,040 --> 00:48:50,640
so regular expressions

00:48:48,559 --> 00:48:52,240
deterministic finite automata and

00:48:50,640 --> 00:48:53,359
non-deterministic finite autonomous are

00:48:52,240 --> 00:48:56,559
equivalent

00:48:53,359 --> 00:48:57,520
and that flat the flat uh module that

00:48:56,559 --> 00:49:01,440
that i created

00:48:57,520 --> 00:49:04,400
it all this is all well-known stuff um

00:49:01,440 --> 00:49:06,079
but the in order to it implements um

00:49:04,400 --> 00:49:07,359
converting from regular expression to

00:49:06,079 --> 00:49:09,359
nfa

00:49:07,359 --> 00:49:11,200
the way that i do that is i basically

00:49:09,359 --> 00:49:12,640
just use recursive descent parser i

00:49:11,200 --> 00:49:16,000
create an abstract syntax

00:49:12,640 --> 00:49:17,599
tree and then over that ast i run some i

00:49:16,000 --> 00:49:19,839
do something called thompson's

00:49:17,599 --> 00:49:21,040
construction which is you literally just

00:49:19,839 --> 00:49:24,000
traverse to ast

00:49:21,040 --> 00:49:25,520
and you're building out um building out

00:49:24,000 --> 00:49:28,839
the finite automata

00:49:25,520 --> 00:49:31,599
using using uh certain elements

00:49:28,839 --> 00:49:33,599
of you know graph connections it's

00:49:31,599 --> 00:49:35,280
interesting i suggest you look it up

00:49:33,599 --> 00:49:37,680
i love talking about it but this is not

00:49:35,280 --> 00:49:41,119
the time or place it

00:49:37,680 --> 00:49:41,920
to make it easier it introduces epsilon

00:49:41,119 --> 00:49:43,839
transitions

00:49:41,920 --> 00:49:45,520
and it just that just gives it some some

00:49:43,839 --> 00:49:47,359
wiggle room as far as

00:49:45,520 --> 00:49:49,359
um you know the types of elements that

00:49:47,359 --> 00:49:51,040
it is using to construct this directive

00:49:49,359 --> 00:49:52,880
graph

00:49:51,040 --> 00:49:55,280
you can also then you can convert from

00:49:52,880 --> 00:49:57,440
an nfa to a dfa using something called

00:49:55,280 --> 00:49:58,400
subset construction that's another

00:49:57,440 --> 00:50:01,119
interesting

00:49:58,400 --> 00:50:01,440
algorithm it basically just finds all of

00:50:01,119 --> 00:50:05,599
the

00:50:01,440 --> 00:50:08,160
all identical states by building buckets

00:50:05,599 --> 00:50:09,119
and then once once it has all these

00:50:08,160 --> 00:50:10,960
buckets built

00:50:09,119 --> 00:50:12,720
all the non-determinism is gone it

00:50:10,960 --> 00:50:16,400
collapses the non-determinism

00:50:12,720 --> 00:50:19,760
into a deterministic finite automata

00:50:16,400 --> 00:50:21,520
where you can execute it sequentially

00:50:19,760 --> 00:50:23,839
or you can validate a string

00:50:21,520 --> 00:50:26,160
sequentially over it

00:50:23,839 --> 00:50:27,920
now one thing that i necessarily have to

00:50:26,160 --> 00:50:29,599
do is once i have a dfa

00:50:27,920 --> 00:50:31,280
i need to be able to generate valid

00:50:29,599 --> 00:50:33,760
string so i don't

00:50:31,280 --> 00:50:36,079
i don't know ahead of time what a valid

00:50:33,760 --> 00:50:39,119
string for

00:50:36,079 --> 00:50:41,520
this dfa is but what you can do there is

00:50:39,119 --> 00:50:44,079
just do a depth first reversal from

00:50:41,520 --> 00:50:46,240
the start state to an accept state and

00:50:44,079 --> 00:50:49,119
then collect the labels along the way

00:50:46,240 --> 00:50:51,119
and that that is your strength and um it

00:50:49,119 --> 00:50:55,040
works out pretty well

00:50:51,119 --> 00:50:58,000
converting from a a well i say shuffled

00:50:55,040 --> 00:51:00,559
pre and it's either shuffled or it's pre

00:50:58,000 --> 00:51:02,720
so by converting to a parallel uh

00:51:00,559 --> 00:51:06,000
regular expression to a dfa

00:51:02,720 --> 00:51:07,839
involves an additional step so

00:51:06,000 --> 00:51:09,040
that first point actually should be p r

00:51:07,839 --> 00:51:11,119
e to p f a

00:51:09,040 --> 00:51:12,079
i'll correct that uh before i pass these

00:51:11,119 --> 00:51:14,880
slides on

00:51:12,079 --> 00:51:16,480
but it does the same exact thing and

00:51:14,880 --> 00:51:19,839
stocks and pew

00:51:16,480 --> 00:51:23,200
um define a modified thompson

00:51:19,839 --> 00:51:27,920
construction element uh

00:51:23,200 --> 00:51:30,079
so for for a regular expression ast

00:51:27,920 --> 00:51:31,040
that has a shuffle operator in it and

00:51:30,079 --> 00:51:34,400
that's where

00:51:31,040 --> 00:51:37,520
the lambda transition gets introduced

00:51:34,400 --> 00:51:38,640
okay so we've got this pre to pfa

00:51:37,520 --> 00:51:41,839
conversion

00:51:38,640 --> 00:51:43,920
now we need to do a pfa to an nfa well

00:51:41,839 --> 00:51:45,280
back when i was looking into this they

00:51:43,920 --> 00:51:48,880
didn't define

00:51:45,280 --> 00:51:49,520
how to do this and they didn't answer my

00:51:48,880 --> 00:51:51,920
emails

00:51:49,520 --> 00:51:53,760
so i had to figure out how to do this

00:51:51,920 --> 00:51:56,960
well how do you do this

00:51:53,760 --> 00:51:59,920
all what you do is since all all the

00:51:56,960 --> 00:52:01,440
strings from all the languages necessary

00:51:59,920 --> 00:52:03,440
you've got five minutes for either

00:52:01,440 --> 00:52:08,240
questions or to finish up

00:52:03,440 --> 00:52:11,599
oh dang it let me move on

00:52:08,240 --> 00:52:14,319
um so

00:52:11,599 --> 00:52:16,480
okay this is this is an example take

00:52:14,319 --> 00:52:18,319
going from the uh

00:52:16,480 --> 00:52:20,079
going from that dependency graph that i

00:52:18,319 --> 00:52:22,720
showed in the beginning to a parallel

00:52:20,079 --> 00:52:24,960
finite automata

00:52:22,720 --> 00:52:26,720
um this is what the nfa looks like so

00:52:24,960 --> 00:52:27,200
you can see it's it's starting to look

00:52:26,720 --> 00:52:30,319
like

00:52:27,200 --> 00:52:31,680
if you take a start a path from start to

00:52:30,319 --> 00:52:35,040
finish which is

00:52:31,680 --> 00:52:38,800
the the circle 17 with the double rings

00:52:35,040 --> 00:52:42,319
then you can um you can enumerate

00:52:38,800 --> 00:52:44,400
valid valid strings from this

00:52:42,319 --> 00:52:46,800
this is what the dfa looks like after

00:52:44,400 --> 00:52:48,559
subset construction so a lot of times

00:52:46,800 --> 00:52:51,920
we minimize it so we get something a lot

00:52:48,559 --> 00:52:54,880
neater so given that original

00:52:51,920 --> 00:52:56,800
given that original um graph and then

00:52:54,880 --> 00:52:57,839
that list of all the valid orderings of

00:52:56,800 --> 00:53:00,240
the execution

00:52:57,839 --> 00:53:01,119
we can generate that from this as long

00:53:00,240 --> 00:53:03,440
as we go

00:53:01,119 --> 00:53:05,359
and if we take all paths from start

00:53:03,440 --> 00:53:08,559
which is state 0

00:53:05,359 --> 00:53:11,680
to state 15 you will get all of those

00:53:08,559 --> 00:53:13,119
strings all of those strings are valid

00:53:11,680 --> 00:53:16,800
in this regular expression

00:53:13,119 --> 00:53:17,359
and this dfa all of these strings in

00:53:16,800 --> 00:53:20,160
past

00:53:17,359 --> 00:53:21,520
are also sequentially consistent

00:53:20,160 --> 00:53:25,440
therefore

00:53:21,520 --> 00:53:28,480
you can define your program concurrently

00:53:25,440 --> 00:53:30,000
using this parallel regular expression

00:53:28,480 --> 00:53:32,720
so the original

00:53:30,000 --> 00:53:34,480
the original execution path that i

00:53:32,720 --> 00:53:37,520
showed in the beginning can be defined

00:53:34,480 --> 00:53:40,720
using this regular expression

00:53:37,520 --> 00:53:44,480
where it's abc shuffle

00:53:40,720 --> 00:53:45,599
i say and abc and xyz i say i need abc

00:53:44,480 --> 00:53:48,160
to happen and i need

00:53:45,599 --> 00:53:49,599
xyz to happen that shuffle or the

00:53:48,160 --> 00:53:52,880
ampersand implies that

00:53:49,599 --> 00:53:54,640
that there's an independence between

00:53:52,880 --> 00:53:58,800
those two languages

00:53:54,640 --> 00:54:01,839
but i can get if i needed to go from

00:53:58,800 --> 00:54:04,079
this parallel with the parallelism

00:54:01,839 --> 00:54:06,079
that's implied in this

00:54:04,079 --> 00:54:07,280
parallel regular expression to a

00:54:06,079 --> 00:54:10,400
sequential string

00:54:07,280 --> 00:54:13,760
that is valid for that for both of those

00:54:10,400 --> 00:54:16,160
all for for both of those um

00:54:13,760 --> 00:54:18,079
threads happening then i can use the

00:54:16,160 --> 00:54:20,960
process described

00:54:18,079 --> 00:54:23,520
to enumerate all the different order of

00:54:20,960 --> 00:54:26,720
execution

00:54:23,520 --> 00:54:29,839
this is one these are this is a pfa

00:54:26,720 --> 00:54:31,280
an nfa and a minimum dfa just showing

00:54:29,839 --> 00:54:34,319
that you can do the same thing

00:54:31,280 --> 00:54:37,440
um whether if you have the at the or the

00:54:34,319 --> 00:54:38,319
the uh the union operator in there and

00:54:37,440 --> 00:54:39,680
that's

00:54:38,319 --> 00:54:41,839
that's the fight that's considered a

00:54:39,680 --> 00:54:45,359
finite language

00:54:41,839 --> 00:54:48,000
um let me see something here

00:54:45,359 --> 00:54:50,079
i thought i had so one thing i wanted to

00:54:48,000 --> 00:54:51,440
note is that i haven't shown any

00:54:50,079 --> 00:54:54,319
examples with the clean star

00:54:51,440 --> 00:54:55,599
the reason for that is the clean star

00:54:54,319 --> 00:54:58,799
emits

00:54:55,599 --> 00:55:01,200
cycles into the dfa and that

00:54:58,799 --> 00:55:02,319
makes basically creates infinite

00:55:01,200 --> 00:55:04,079
languages

00:55:02,319 --> 00:55:05,440
i haven't really looked much into that

00:55:04,079 --> 00:55:06,000
about how to handle that or how that

00:55:05,440 --> 00:55:08,880
would benefit

00:55:06,000 --> 00:55:10,720
what we're talking about here so getting

00:55:08,880 --> 00:55:13,440
all the way to

00:55:10,720 --> 00:55:14,319
how do you take this and then use it to

00:55:13,440 --> 00:55:17,920
write something

00:55:14,319 --> 00:55:20,960
in a um

00:55:17,920 --> 00:55:22,160
in a short shared memory sort implicit

00:55:20,960 --> 00:55:25,520
way

00:55:22,160 --> 00:55:27,760
well what you do is you can create this

00:55:25,520 --> 00:55:30,240
plan

00:55:27,760 --> 00:55:31,920
well i'll get back to that what i'm

00:55:30,240 --> 00:55:35,440
showing here is

00:55:31,920 --> 00:55:37,680
this is what pearl gives us in terms of

00:55:35,440 --> 00:55:39,839
you know our snp i probably should have

00:55:37,680 --> 00:55:41,599
always the very front

00:55:39,839 --> 00:55:43,119
but going back to the original example

00:55:41,599 --> 00:55:46,799
abc xyz

00:55:43,119 --> 00:55:47,200
you can see that within a within one cpu

00:55:46,799 --> 00:55:50,240
you've got

00:55:47,200 --> 00:55:51,119
global shared memory each node or is a

00:55:50,240 --> 00:55:53,760
subroutine

00:55:51,119 --> 00:55:54,240
that has can ha can have its own state

00:55:53,760 --> 00:55:57,839
and then

00:55:54,240 --> 00:56:00,160
using this module sub genius that i have

00:55:57,839 --> 00:56:01,440
which is that's a joke name but one

00:56:00,160 --> 00:56:07,760
minute

00:56:01,440 --> 00:56:07,760
oh so so i need to stop for questions

00:56:08,640 --> 00:56:11,839
is that is that what the one minute is

00:56:10,079 --> 00:56:13,359
no i need to stop one minute for

00:56:11,839 --> 00:56:16,480
questions

00:56:13,359 --> 00:56:21,599
oh there's only one minute for questions

00:56:16,480 --> 00:56:23,119
okay well let's see let's jump ahead

00:56:21,599 --> 00:56:25,680
i might have to take questions some

00:56:23,119 --> 00:56:28,720
other time um

00:56:25,680 --> 00:56:30,559
this is an example of using a parallel

00:56:28,720 --> 00:56:33,040
regular expression to

00:56:30,559 --> 00:56:34,160
define how you in what order and how you

00:56:33,040 --> 00:56:38,000
want your

00:56:34,160 --> 00:56:40,240
subroutines to get executed um

00:56:38,000 --> 00:56:42,559
i've got tools that will help you use

00:56:40,240 --> 00:56:42,559
this

00:56:42,839 --> 00:56:46,880
um well

00:56:44,720 --> 00:56:50,240
i was trying to get to all right can i

00:56:46,880 --> 00:56:50,240
do i have time to run the jab

00:56:52,240 --> 00:56:58,319
you do it in 30 seconds yeah

00:56:55,920 --> 00:57:00,079
i i think uh this this should be an open

00:56:58,319 --> 00:57:03,920
invite to houston pearl mongers

00:57:00,079 --> 00:57:09,359
in july sounds good to me all right

00:57:03,920 --> 00:57:09,359
uh actually no idea let me open this up

00:57:10,559 --> 00:57:15,599
all right so this is a program that's

00:57:13,920 --> 00:57:18,960
using subgenius i have the

00:57:15,599 --> 00:57:22,160
pre here that defines

00:57:18,960 --> 00:57:24,079
jf and then basically i'm compiling

00:57:22,160 --> 00:57:26,480
this parallel regular expression that

00:57:24,079 --> 00:57:29,599
defines the order of operations

00:57:26,480 --> 00:57:31,520
into a sequential plan and then i've got

00:57:29,599 --> 00:57:37,280
the subroutines defined

00:57:31,520 --> 00:57:37,280
below here and it's taking advantage of

00:57:37,359 --> 00:57:40,400
the global memory and demonstrating use

00:57:39,680 --> 00:57:44,640
of

00:57:40,400 --> 00:57:44,640
the scope the ability to pipeline scope

00:57:45,920 --> 00:57:49,040
anyway all right where did i want to go

00:57:48,640 --> 00:57:52,000
all right

00:57:49,040 --> 00:57:53,119
open questions i want to look like i

00:57:52,000 --> 00:57:54,480
want to see what it look i'm going to be

00:57:53,119 --> 00:57:55,680
looking at what it looks like when fork

00:57:54,480 --> 00:57:59,760
is introduced

00:57:55,680 --> 00:58:02,799
um uh you know what gives us when we

00:57:59,760 --> 00:58:03,520
treat subroutines statefully how can we

00:58:02,799 --> 00:58:07,119
use this

00:58:03,520 --> 00:58:09,839
to to um do something like related to

00:58:07,119 --> 00:58:12,559
async await or futures

00:58:09,839 --> 00:58:14,480
how can we use infinite languages to to

00:58:12,559 --> 00:58:16,400
as a plan

00:58:14,480 --> 00:58:17,680
i've got a run loop or a driver within

00:58:16,400 --> 00:58:19,040
this module

00:58:17,680 --> 00:58:21,280
and then i've got some utilities in

00:58:19,040 --> 00:58:23,040
there that help you write it and

00:58:21,280 --> 00:58:25,200
basically dump you know with the with

00:58:23,040 --> 00:58:27,359
the flat underlying financial timeout

00:58:25,200 --> 00:58:28,240
but in any case check out the module

00:58:27,359 --> 00:58:30,160
i've got

00:58:28,240 --> 00:58:31,760
i've got lots of stuff written on cpan

00:58:30,160 --> 00:58:33,920
about it within the pod

00:58:31,760 --> 00:58:34,839
and i plan on continuing to work through

00:58:33,920 --> 00:58:38,960
this so

00:58:34,839 --> 00:58:40,799
anyway sorry i went over i've

00:58:38,960 --> 00:58:42,319
spent too much time on the uh the

00:58:40,799 --> 00:58:43,920
background information

00:58:42,319 --> 00:58:45,680
do we have time for any questions even

00:58:43,920 --> 00:58:48,079
one we do not

00:58:45,680 --> 00:58:49,359
take them in slack but there's about

00:58:48,079 --> 00:58:52,319
thank you bro

00:58:49,359 --> 00:58:52,880
open tomorrow thank you for coming yeah

00:58:52,319 --> 00:58:53,920
all right

00:58:52,880 --> 00:58:59,760
well i'll see you about doing that

00:58:53,920 --> 00:58:59,760

YouTube URL: https://www.youtube.com/watch?v=ypkPDUI-E-0


