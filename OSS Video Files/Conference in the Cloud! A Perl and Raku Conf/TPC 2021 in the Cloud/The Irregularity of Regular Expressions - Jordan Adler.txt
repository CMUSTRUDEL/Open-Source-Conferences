Title: The Irregularity of Regular Expressions - Jordan Adler
Publication date: 2021-06-09
Playlist: TPC 2021 in the Cloud
Description: 
	Walk-in with zero regex knowledge, walk out with solid Regexp knowledge and a global lay of the land.

Regular Expressions are not nearly as standard as they may seem.  In this talk, we’ll provide an overview of regular expressions, their history, use cases, and alternative techniques.  Then, we’ll walk through the tools in the regexp toolbox (chars, wildcards, character classes, assertions, etc) with examples in PCRE, Perl, and Raku syntax.  Finally we’ll summarize and analyze the variations in regular expression syntax and provide some closing thoughts on regex and regex portability.
Captions: 
	00:00:01,520 --> 00:00:06,160
okay we're uh ready to go

00:00:03,120 --> 00:00:06,799
uh everybody uh please welcome jordan

00:00:06,160 --> 00:00:08,559
adler

00:00:06,799 --> 00:00:12,000
he's gonna be talking about irregularity

00:00:08,559 --> 00:00:12,000
of regular expressions all right

00:00:13,360 --> 00:00:17,039
hello good morning how's everyone doing

00:00:15,200 --> 00:00:18,720
today

00:00:17,039 --> 00:00:21,199
the first session of the day so i'm sure

00:00:18,720 --> 00:00:25,039
everyone's wide awake

00:00:21,199 --> 00:00:27,359
uh it's 8 a.m over here on the uh

00:00:25,039 --> 00:00:28,240
the west coast here in san francisco so

00:00:27,359 --> 00:00:29,760
i uh

00:00:28,240 --> 00:00:31,279
i can totally understand if you're a bit

00:00:29,760 --> 00:00:33,360
groggy

00:00:31,279 --> 00:00:34,800
but i'd love to to get started to chat a

00:00:33,360 --> 00:00:37,440
bit about regular expressions with you

00:00:34,800 --> 00:00:37,440
all if you're ready

00:00:40,800 --> 00:00:45,360
um first a bit about what we'll be doing

00:00:43,840 --> 00:00:45,920
in this presentation i'll go over some

00:00:45,360 --> 00:00:49,039
kind of

00:00:45,920 --> 00:00:50,399
quick uh overview of regular expressions

00:00:49,039 --> 00:00:52,800
talking about a little bit about the

00:00:50,399 --> 00:00:54,000
history a little digression on language

00:00:52,800 --> 00:00:55,920
theory

00:00:54,000 --> 00:00:57,440
some tools and use cases and engines for

00:00:55,920 --> 00:01:00,480
regular expressions

00:00:57,440 --> 00:01:03,600
typical call patterns and then get

00:01:00,480 --> 00:01:05,439
straight into the kind of flavors and

00:01:03,600 --> 00:01:07,840
syntax of regular expressions and how

00:01:05,439 --> 00:01:12,560
they vary and i'll provide examples in

00:01:07,840 --> 00:01:13,760
posix bre posix ere perl as well as raku

00:01:12,560 --> 00:01:16,400
we'll have some time for questions at

00:01:13,760 --> 00:01:20,000
the end first a bit about me

00:01:16,400 --> 00:01:22,799
i'm jordan adler i'm a frequent

00:01:20,000 --> 00:01:23,920
uh presenter here at here at the pearl

00:01:22,799 --> 00:01:26,400
conference

00:01:23,920 --> 00:01:28,400
i've been doing pearl since 2003 uh

00:01:26,400 --> 00:01:29,920
which is the year nina simone pass greta

00:01:28,400 --> 00:01:32,000
thunberg was born

00:01:29,920 --> 00:01:33,840
um what else happened that year oh sars

00:01:32,000 --> 00:01:35,520
and mers were introduced into our

00:01:33,840 --> 00:01:37,280
vocabulary in fact we're in the cloud

00:01:35,520 --> 00:01:41,680
today because of a

00:01:37,280 --> 00:01:43,119
cousin of of those two lovely viruses

00:01:41,680 --> 00:01:46,079
um i work for a company called one

00:01:43,119 --> 00:01:48,320
signal one signal is a communication

00:01:46,079 --> 00:01:50,399
platform as a service and so we offer a

00:01:48,320 --> 00:01:52,840
number of really interesting tools for

00:01:50,399 --> 00:01:54,399
communicating and doing communication

00:01:52,840 --> 00:01:57,439
marketing

00:01:54,399 --> 00:01:58,479
um oops first a bit about regular

00:01:57,439 --> 00:02:02,159
expressions

00:01:58,479 --> 00:02:04,479
um they're a tool for managing

00:02:02,159 --> 00:02:05,360
text essentially right so you have these

00:02:04,479 --> 00:02:07,119
patterns

00:02:05,360 --> 00:02:08,959
or programs sometimes just called

00:02:07,119 --> 00:02:12,000
rejects

00:02:08,959 --> 00:02:15,760
and these essentially dictate

00:02:12,000 --> 00:02:18,560
or or describe ways to

00:02:15,760 --> 00:02:19,200
manipulate or scan text for certain

00:02:18,560 --> 00:02:22,480
kinds of

00:02:19,200 --> 00:02:25,220
of characteristics

00:02:22,480 --> 00:02:27,520
they were developed as part of the

00:02:25,220 --> 00:02:30,160
[Music]

00:02:27,520 --> 00:02:31,760
advancement of language theory by mr

00:02:30,160 --> 00:02:35,440
clean here on the left

00:02:31,760 --> 00:02:36,080
back in the 50s and and 60s ken thompson

00:02:35,440 --> 00:02:38,959
developed an

00:02:36,080 --> 00:02:39,920
algorithm that implemented them uh in in

00:02:38,959 --> 00:02:43,040
the 60s

00:02:39,920 --> 00:02:44,239
alfred ajo extended that adding uh

00:02:43,040 --> 00:02:46,400
you know some of the features that we

00:02:44,239 --> 00:02:48,239
call extended regular expressions today

00:02:46,400 --> 00:02:53,280
and eventually became formalized as

00:02:48,239 --> 00:02:55,040
posix eres in in the 60s

00:02:53,280 --> 00:02:57,280
henry spencer developed a regular

00:02:55,040 --> 00:02:59,120
expression library in the 80s that was

00:02:57,280 --> 00:03:01,680
passed around usenet

00:02:59,120 --> 00:03:04,239
added quite a few new features that

00:03:01,680 --> 00:03:06,480
really formed kind of the basis of of

00:03:04,239 --> 00:03:08,560
what we think of as modern backtracking

00:03:06,480 --> 00:03:10,400
regular expression engines

00:03:08,560 --> 00:03:12,080
larry wall of course as everyone here

00:03:10,400 --> 00:03:14,720
knows took that embedded

00:03:12,080 --> 00:03:16,480
into pearl extended it and developed a

00:03:14,720 --> 00:03:19,200
number of new features

00:03:16,480 --> 00:03:19,920
and then looking at raku kind of took

00:03:19,200 --> 00:03:22,239
some you know

00:03:19,920 --> 00:03:23,920
fresh perspective rethought some of the

00:03:22,239 --> 00:03:25,200
design decisions and

00:03:23,920 --> 00:03:27,120
really came up with some interesting

00:03:25,200 --> 00:03:29,120
features in in raku regular expressions

00:03:27,120 --> 00:03:32,959
and raku rules

00:03:29,120 --> 00:03:35,920
russ cox developed a library called re2

00:03:32,959 --> 00:03:36,560
also re1 but re2 is the significant one

00:03:35,920 --> 00:03:40,239
in

00:03:36,560 --> 00:03:42,000
in kind of the early 2000s

00:03:40,239 --> 00:03:43,920
and this is the one used in in the go

00:03:42,000 --> 00:03:45,840
language and in google tools it's

00:03:43,920 --> 00:03:46,560
notable because it doesn't support back

00:03:45,840 --> 00:03:47,599
reference

00:03:46,560 --> 00:03:50,239
excuse me doesn't support back

00:03:47,599 --> 00:03:51,440
referencing doesn't support backtracking

00:03:50,239 --> 00:03:54,720
and as a consequence it's more

00:03:51,440 --> 00:03:56,400
performant but less feature rich

00:03:54,720 --> 00:03:58,080
bit of digression so we call them

00:03:56,400 --> 00:04:01,360
regular expressions but they are

00:03:58,080 --> 00:04:04,319
because they are a part inspired by uh

00:04:01,360 --> 00:04:05,599
you know or based on the idea of regular

00:04:04,319 --> 00:04:08,640
languages

00:04:05,599 --> 00:04:11,680
uh and developed by clean out of this

00:04:08,640 --> 00:04:14,080
idea of uh

00:04:11,680 --> 00:04:16,239
you know formal language theory in

00:04:14,080 --> 00:04:18,239
practice today however

00:04:16,239 --> 00:04:19,359
most regular expression programs and

00:04:18,239 --> 00:04:22,560
patterns are not

00:04:19,359 --> 00:04:24,400
regular they are either turing complete

00:04:22,560 --> 00:04:26,400
in the case of pearl or raku if you're

00:04:24,400 --> 00:04:29,280
using embedded code

00:04:26,400 --> 00:04:29,919
or or context sensitive depending on the

00:04:29,280 --> 00:04:33,440
um

00:04:29,919 --> 00:04:33,440
if you're using a back tracking system

00:04:33,759 --> 00:04:37,600
common use cases for regular expressions

00:04:36,080 --> 00:04:40,000
include text editors scrap

00:04:37,600 --> 00:04:41,040
command line utils like grep set and awk

00:04:40,000 --> 00:04:43,520
that enable you

00:04:41,040 --> 00:04:44,880
to use regular expressions to find text

00:04:43,520 --> 00:04:46,880
on a file system

00:04:44,880 --> 00:04:49,040
uh search engines often use regular

00:04:46,880 --> 00:04:51,280
expressions under the hood quite a bit

00:04:49,040 --> 00:04:53,120
for tokenizing and parsing and so on

00:04:51,280 --> 00:04:55,280
almost every programming language is

00:04:53,120 --> 00:04:57,040
standard libraries yes of course ack

00:04:55,280 --> 00:04:58,560
is one of the best ack is better than

00:04:57,040 --> 00:05:01,360
grep

00:04:58,560 --> 00:05:02,720
standard libraries include uh almost all

00:05:01,360 --> 00:05:04,320
of them include some sort of regular

00:05:02,720 --> 00:05:06,160
expression engine

00:05:04,320 --> 00:05:07,840
and of course the compilers almost every

00:05:06,160 --> 00:05:09,520
compiler includes

00:05:07,840 --> 00:05:11,039
parsing you know every compiler includes

00:05:09,520 --> 00:05:12,880
parsing is this first step and

00:05:11,039 --> 00:05:14,160
often those are backed by regex in fact

00:05:12,880 --> 00:05:14,800
you'll notice the dragon book here on

00:05:14,160 --> 00:05:16,320
the right

00:05:14,800 --> 00:05:20,080
has a familiar name as one of its

00:05:16,320 --> 00:05:22,000
authors and that's no coincidence

00:05:20,080 --> 00:05:23,759
in terms of the engines that implement

00:05:22,000 --> 00:05:26,400
regular expressions there's our

00:05:23,759 --> 00:05:28,000
there are many um you know we talked

00:05:26,400 --> 00:05:30,720
about a bit about the uh

00:05:28,000 --> 00:05:32,560
uh spencer henry spencer regex library

00:05:30,720 --> 00:05:35,600
but there's also tre

00:05:32,560 --> 00:05:39,280
re2 uh pearl has it's it's

00:05:35,600 --> 00:05:41,199
it's built in gnu corey libraries has a

00:05:39,280 --> 00:05:42,560
regex engine that's built into canoe

00:05:41,199 --> 00:05:46,080
crap and canoe

00:05:42,560 --> 00:05:47,440
awk and so on you said uh att unix has

00:05:46,080 --> 00:05:50,120
the ats

00:05:47,440 --> 00:05:52,160
raku has its own java has one

00:05:50,120 --> 00:05:55,120
w.util.regex which has its own

00:05:52,160 --> 00:05:57,840
quarks and of course there are even now

00:05:55,120 --> 00:05:58,880
fpga gpu and other kinds of hardware

00:05:57,840 --> 00:06:01,440
accelerated

00:05:58,880 --> 00:06:02,000
regular expression engines for those who

00:06:01,440 --> 00:06:05,199
are doing

00:06:02,000 --> 00:06:06,880
massive regex at scale

00:06:05,199 --> 00:06:09,360
uh one quick note when it comes to

00:06:06,880 --> 00:06:12,639
regular expressions you're applying a

00:06:09,360 --> 00:06:15,360
program to a representation of uh

00:06:12,639 --> 00:06:17,360
text in data and so you have to be

00:06:15,360 --> 00:06:20,800
cognizant of what exactly that means

00:06:17,360 --> 00:06:23,600
most modern regex engines use

00:06:20,800 --> 00:06:24,639
or support unicode well but you have to

00:06:23,600 --> 00:06:25,919
be careful when you're writing your

00:06:24,639 --> 00:06:28,160
regex program

00:06:25,919 --> 00:06:29,280
to be cognizant of what that means right

00:06:28,160 --> 00:06:32,000
so um

00:06:29,280 --> 00:06:32,800
if you take a look at some characters

00:06:32,000 --> 00:06:35,039
like

00:06:32,800 --> 00:06:37,039
this you know combined ae character

00:06:35,039 --> 00:06:40,319
which is common in some languages

00:06:37,039 --> 00:06:42,319
um have uh will will support you know

00:06:40,319 --> 00:06:45,919
the dot wild card in some cases

00:06:42,319 --> 00:06:50,160
wide characters like like chinese uh

00:06:45,919 --> 00:06:52,240
uh pictograms uh will um

00:06:50,160 --> 00:06:53,599
will will match as a single character

00:06:52,240 --> 00:06:56,000
although internally they might

00:06:53,599 --> 00:06:57,599
be represented as two characters and

00:06:56,000 --> 00:06:58,080
some magic tangents will interpret that

00:06:57,599 --> 00:07:00,479
as

00:06:58,080 --> 00:07:03,759
two characters in a row that's called

00:07:00,479 --> 00:07:05,440
the wide character

00:07:03,759 --> 00:07:07,120
in terms of actual call patterns once

00:07:05,440 --> 00:07:08,560
you've built a regular expression

00:07:07,120 --> 00:07:10,639
pattern or program

00:07:08,560 --> 00:07:12,160
uh typically you're you pass that along

00:07:10,639 --> 00:07:14,639
to your engine along with a string

00:07:12,160 --> 00:07:17,199
and you request one of four different

00:07:14,639 --> 00:07:19,199
kinds of executions for that

00:07:17,199 --> 00:07:20,960
the first would be counting right show

00:07:19,199 --> 00:07:22,720
me all the matches just the number i

00:07:20,960 --> 00:07:24,560
just need the number

00:07:22,720 --> 00:07:26,240
matching is another one you know give me

00:07:24,560 --> 00:07:27,039
all the matches potentially capturing

00:07:26,240 --> 00:07:30,479
them

00:07:27,039 --> 00:07:33,520
substitution apply the program that

00:07:30,479 --> 00:07:34,800
makes changes in the string and

00:07:33,520 --> 00:07:36,639
splitting so take a

00:07:34,800 --> 00:07:38,639
long string chunk it up into smaller

00:07:36,639 --> 00:07:40,880
strings based on a regular expression

00:07:38,639 --> 00:07:42,800
program

00:07:40,880 --> 00:07:44,400
and of course no talk about regular

00:07:42,800 --> 00:07:47,840
expressions is complete without a

00:07:44,400 --> 00:07:50,160
warning to not use regular expressions

00:07:47,840 --> 00:07:51,680
and that's no different today jamie

00:07:50,160 --> 00:07:53,360
zwinski is noted for this

00:07:51,680 --> 00:07:55,599
you know pithy quote about the

00:07:53,360 --> 00:07:57,120
problematic use of regular expressions

00:07:55,599 --> 00:07:58,800
but there are challenges

00:07:57,120 --> 00:08:01,599
regular expressions can be difficult to

00:07:58,800 --> 00:08:04,160
debug they can become problematically

00:08:01,599 --> 00:08:05,759
complex at scale

00:08:04,160 --> 00:08:08,319
and they can represent security

00:08:05,759 --> 00:08:10,840
challenges if not well managed and

00:08:08,319 --> 00:08:12,160
if using user input as part of the

00:08:10,840 --> 00:08:15,199
program

00:08:12,160 --> 00:08:18,800
so let's dive into some of the um

00:08:15,199 --> 00:08:20,560
specifics of regex flavors so here we'll

00:08:18,800 --> 00:08:22,560
kind of this is the the format we'll go

00:08:20,560 --> 00:08:24,400
for the rest of the talk we'll have bre

00:08:22,560 --> 00:08:26,319
ere which are the posix basics and

00:08:24,400 --> 00:08:28,240
extended regular expression standards

00:08:26,319 --> 00:08:29,360
as well as pearl and raku syntax down

00:08:28,240 --> 00:08:31,199
here at the bottom

00:08:29,360 --> 00:08:32,560
and you can see here wild cards are

00:08:31,199 --> 00:08:34,479
fairly standard you use the dot

00:08:32,560 --> 00:08:36,080
character as a wild card that's pretty

00:08:34,479 --> 00:08:38,479
consistent throughout

00:08:36,080 --> 00:08:40,000
throughout the ecosystem when you get

00:08:38,479 --> 00:08:43,919
into anchors this is where

00:08:40,000 --> 00:08:46,959
i think things start to deviate um

00:08:43,919 --> 00:08:49,760
bre and ere have support

00:08:46,959 --> 00:08:52,000
for these carrot and dollar signs start

00:08:49,760 --> 00:08:54,240
off and end of line anchors

00:08:52,000 --> 00:08:56,480
pearl extends is further creating word

00:08:54,240 --> 00:08:59,600
boundaries string start string and

00:08:56,480 --> 00:09:02,640
uh and many other kinds of anchors

00:08:59,600 --> 00:09:04,399
raku uh also supports these anchors

00:09:02,640 --> 00:09:07,040
but the interesting and notable bit is

00:09:04,399 --> 00:09:08,080
the the syntactical change in some of

00:09:07,040 --> 00:09:11,440
these the the way

00:09:08,080 --> 00:09:13,680
that raku refers to these anchors um

00:09:11,440 --> 00:09:17,440
and i think that the the motivation

00:09:13,680 --> 00:09:17,440
behind these is readability

00:09:17,600 --> 00:09:22,080
alternations is a significant feature

00:09:20,560 --> 00:09:25,200
and a distinguishing characteristic

00:09:22,080 --> 00:09:27,839
between posix bre and ere and

00:09:25,200 --> 00:09:29,120
essentially alternations just say match

00:09:27,839 --> 00:09:32,240
one thing or the other

00:09:29,120 --> 00:09:34,240
right foo or bar and

00:09:32,240 --> 00:09:35,680
there are there's a sense of greediness

00:09:34,240 --> 00:09:36,880
to alternations right you can do the

00:09:35,680 --> 00:09:38,560
longest alternation

00:09:36,880 --> 00:09:41,120
is the standard approaching ere and

00:09:38,560 --> 00:09:41,600
pearl supports that raku also supports

00:09:41,120 --> 00:09:43,519
just

00:09:41,600 --> 00:09:44,880
the non-longest alternation which uses

00:09:43,519 --> 00:09:48,160
the double fur bar here

00:09:44,880 --> 00:09:51,839
which enables kind of more uh

00:09:48,160 --> 00:09:54,320
less greedy matching

00:09:51,839 --> 00:09:55,839
bracket expressions as they are called

00:09:54,320 --> 00:09:59,040
in the posix

00:09:55,839 --> 00:10:00,080
land are a list of characters that could

00:09:59,040 --> 00:10:01,600
be supported

00:10:00,080 --> 00:10:04,160
or a range of characters that could be

00:10:01,600 --> 00:10:07,600
supported pearl extends this further

00:10:04,160 --> 00:10:10,399
by uh creating negated lists and ranges

00:10:07,600 --> 00:10:11,279
and raku sorry raku extends this even

00:10:10,399 --> 00:10:14,320
further

00:10:11,279 --> 00:10:17,360
by allowing uh unions

00:10:14,320 --> 00:10:19,279
united classes unions of the two sets or

00:10:17,360 --> 00:10:22,079
the diffs of the two sets

00:10:19,279 --> 00:10:22,880
so that you can kind of combine and

00:10:22,079 --> 00:10:25,040
compose

00:10:22,880 --> 00:10:26,399
character classes which is especially

00:10:25,040 --> 00:10:29,040
effective when

00:10:26,399 --> 00:10:30,399
using you know more primitive tokens

00:10:29,040 --> 00:10:32,000
that you have named as regular

00:10:30,399 --> 00:10:36,560
expressions so raku supports quite

00:10:32,000 --> 00:10:39,040
well character classes are a major point

00:10:36,560 --> 00:10:40,000
of distinction bre defines exactly 12 of

00:10:39,040 --> 00:10:41,680
these

00:10:40,000 --> 00:10:43,040
and i have some of the kind of key ones

00:10:41,680 --> 00:10:46,480
up top here

00:10:43,040 --> 00:10:49,519
ere supports more or less the same pearl

00:10:46,480 --> 00:10:51,519
has a slightly different a much more

00:10:49,519 --> 00:10:51,760
comprehensive list of these as well as

00:10:51,519 --> 00:10:53,920
they

00:10:51,760 --> 00:10:55,040
introducing something called word which

00:10:53,920 --> 00:10:58,480
is basically

00:10:55,040 --> 00:11:00,880
c very like a c style variable names

00:10:58,480 --> 00:11:02,480
that are supported so a to z zero to

00:11:00,880 --> 00:11:06,079
nine underscore

00:11:02,480 --> 00:11:08,720
um raku tweaks this slightly uh

00:11:06,079 --> 00:11:10,480
using al num as as word essentially

00:11:08,720 --> 00:11:12,880
allowing underscore to be part of

00:11:10,480 --> 00:11:15,839
aluminum and so there's a distinction

00:11:12,880 --> 00:11:15,839
there

00:11:15,880 --> 00:11:19,519
quantification is of course and

00:11:17,839 --> 00:11:21,040
greediness one of the first challenges

00:11:19,519 --> 00:11:22,640
that i think everyone who's trying to

00:11:21,040 --> 00:11:24,000
write regular expressions complicated

00:11:22,640 --> 00:11:25,600
regular expressions for the first time

00:11:24,000 --> 00:11:29,360
will encounter

00:11:25,600 --> 00:11:31,600
bre supports um quantification

00:11:29,360 --> 00:11:32,000
specifiers zero more and or more and or

00:11:31,600 --> 00:11:35,040
less

00:11:32,000 --> 00:11:36,160
and end to m and so on you'll notice the

00:11:35,040 --> 00:11:39,760
backslashing

00:11:36,160 --> 00:11:43,200
uh requirements here in bre which is

00:11:39,760 --> 00:11:46,240
not present in ere and it's part of why

00:11:43,200 --> 00:11:48,240
people often say posixbre has backslash

00:11:46,240 --> 00:11:49,600
itis right you'll have to

00:11:48,240 --> 00:11:52,880
write a bunch of these backslashes to

00:11:49,600 --> 00:11:52,880
deal with these meta characters

00:11:52,959 --> 00:11:59,200
ere also introduces this kind of zero or

00:11:56,160 --> 00:12:02,959
one question mark and one or more

00:11:59,200 --> 00:12:06,000
plus sign uh syntax sugar

00:12:02,959 --> 00:12:08,160
if you will that essentially uh

00:12:06,000 --> 00:12:10,000
provides something like the you know n

00:12:08,160 --> 00:12:13,519
or more or n or less but for zero

00:12:10,000 --> 00:12:16,320
and one perl

00:12:13,519 --> 00:12:17,839
supports the same as eri and raku does

00:12:16,320 --> 00:12:19,120
as well although it has a separate

00:12:17,839 --> 00:12:22,480
syntax for

00:12:19,120 --> 00:12:26,320
specifying um specific

00:12:22,480 --> 00:12:26,320
uh a specific range

00:12:27,680 --> 00:12:31,279
pearl and raku also support something

00:12:29,360 --> 00:12:32,800
called frugal quantification of course

00:12:31,279 --> 00:12:35,200
the posix ones cannot

00:12:32,800 --> 00:12:37,600
uh they are by their nature greedy much

00:12:35,200 --> 00:12:39,839
like wario here our friend

00:12:37,600 --> 00:12:41,760
so if you add the question mark to the

00:12:39,839 --> 00:12:43,920
end of the syntax

00:12:41,760 --> 00:12:44,800
or sort of the end of the operator to to

00:12:43,920 --> 00:12:46,720
specify

00:12:44,800 --> 00:12:48,399
the quantifier and notice that it's

00:12:46,720 --> 00:12:49,360
frugal quantification essentially what

00:12:48,399 --> 00:12:51,120
that means is

00:12:49,360 --> 00:12:53,200
instead of capturing as much as is

00:12:51,120 --> 00:12:56,560
possible it tries to capture as least as

00:12:53,200 --> 00:12:58,480
possible there's also a concept of

00:12:56,560 --> 00:13:00,800
possessive quantification which is

00:12:58,480 --> 00:13:02,880
important for backtracking

00:13:00,800 --> 00:13:05,519
essentially you you dictate that the

00:13:02,880 --> 00:13:08,800
quantification ought to be

00:13:05,519 --> 00:13:09,040
greedy but not to backtrack and this is

00:13:08,800 --> 00:13:11,279
a

00:13:09,040 --> 00:13:14,000
an important technique for writing

00:13:11,279 --> 00:13:16,480
performant regular expressions

00:13:14,000 --> 00:13:19,040
and pearl supports this with the plus

00:13:16,480 --> 00:13:21,200
operator relatively new

00:13:19,040 --> 00:13:24,480
and raku uses the colon to denote

00:13:21,200 --> 00:13:26,240
possessive quantification

00:13:24,480 --> 00:13:27,920
grouping capturing and back references

00:13:26,240 --> 00:13:29,279
are a common feature of regular

00:13:27,920 --> 00:13:32,639
expressions

00:13:29,279 --> 00:13:34,480
bre and ere support capturing

00:13:32,639 --> 00:13:36,399
pearl and and the the henry spencer

00:13:34,480 --> 00:13:38,320
regex library introduced back references

00:13:36,399 --> 00:13:40,560
and this back referencing

00:13:38,320 --> 00:13:41,360
uh you know the original syntax was like

00:13:40,560 --> 00:13:43,839
slash one

00:13:41,360 --> 00:13:44,560
uh pearl uses dollar sign one raku does

00:13:43,839 --> 00:13:47,760
as well

00:13:44,560 --> 00:13:48,560
uh raku also has named capturing one

00:13:47,760 --> 00:13:50,880
challenge with

00:13:48,560 --> 00:13:51,920
with back references in particular is

00:13:50,880 --> 00:13:54,880
that

00:13:51,920 --> 00:13:57,120
uh the the adding this requirement to

00:13:54,880 --> 00:13:59,760
your regular expression engine

00:13:57,120 --> 00:14:01,120
eliminates or require necessitates that

00:13:59,760 --> 00:14:03,199
you use an algorithm that is not

00:14:01,120 --> 00:14:06,639
necessarily optimally important

00:14:03,199 --> 00:14:06,639
or sorry optimally performant

00:14:07,680 --> 00:14:11,120
bre and era do not have what we call

00:14:09,680 --> 00:14:14,000
zero width assertions but

00:14:11,120 --> 00:14:14,800
pearl and raku do and these are quite

00:14:14,000 --> 00:14:16,399
important

00:14:14,800 --> 00:14:18,560
i think these are you know relatively

00:14:16,399 --> 00:14:20,399
myopic examples but there are a lot of

00:14:18,560 --> 00:14:23,760
powerful programs that you can write

00:14:20,399 --> 00:14:26,240
let's say hey look for a a bar that's

00:14:23,760 --> 00:14:28,399
not before a foo or not after a foo or

00:14:26,240 --> 00:14:30,720
something along those lines

00:14:28,399 --> 00:14:32,079
and that's uh that's something that i

00:14:30,720 --> 00:14:33,199
think is is a

00:14:32,079 --> 00:14:36,000
significant distinguishing

00:14:33,199 --> 00:14:36,000
characteristics

00:14:36,880 --> 00:14:41,839
white space and comments are a another

00:14:39,360 --> 00:14:43,920
uh feature that that pearl brings in

00:14:41,839 --> 00:14:45,600
that enables you to make regular

00:14:43,920 --> 00:14:46,720
expressions more readable and document

00:14:45,600 --> 00:14:49,120
them in line

00:14:46,720 --> 00:14:50,079
you have to use the slash x modifier in

00:14:49,120 --> 00:14:53,279
perl

00:14:50,079 --> 00:14:54,079
and raku all uh the slash x modifier is

00:14:53,279 --> 00:14:57,199
essentially

00:14:54,079 --> 00:15:02,000
by default and there's a colon

00:14:57,199 --> 00:15:02,000
sig space in in raku

00:15:03,600 --> 00:15:08,320
in a pearl so i note the modifiers here

00:15:06,160 --> 00:15:10,000
so you can do kind of multi-line single

00:15:08,320 --> 00:15:12,000
line and global matches using

00:15:10,000 --> 00:15:13,920
modifiers the syntax is relatively

00:15:12,000 --> 00:15:16,480
similar there are other ways to specify

00:15:13,920 --> 00:15:19,680
modifiers but it's noteworthy that br

00:15:16,480 --> 00:15:19,680
and erie don't support this

00:15:20,000 --> 00:15:24,079
it's also possible to embed code and

00:15:21,920 --> 00:15:25,600
this is one of the things that makes uh

00:15:24,079 --> 00:15:26,959
you know the the pearl and raccoon

00:15:25,600 --> 00:15:28,079
regular expressions meaningfully

00:15:26,959 --> 00:15:31,440
significant

00:15:28,079 --> 00:15:34,320
uh you and in fact turing complete uh

00:15:31,440 --> 00:15:35,680
you can embed code using the syntax node

00:15:34,320 --> 00:15:37,199
below

00:15:35,680 --> 00:15:39,120
there are other ways to embed code too

00:15:37,199 --> 00:15:40,000
by the way you can embed code in a bi uh

00:15:39,120 --> 00:15:43,440
sorry a boolean

00:15:40,000 --> 00:15:46,000
context uh and you can embed code uh

00:15:43,440 --> 00:15:46,480
as part of the substitution as well as

00:15:46,000 --> 00:15:48,800
the like

00:15:46,480 --> 00:15:50,240
e modifier which allows the evaluation

00:15:48,800 --> 00:15:52,639
of the substitution string and the

00:15:50,240 --> 00:15:53,920
the ee double modifier which i'm not

00:15:52,639 --> 00:15:55,759
going to get into but our additional

00:15:53,920 --> 00:15:59,199
advanced features that are unique to

00:15:55,759 --> 00:16:01,360
pearl and roku uh proraku also support

00:15:59,199 --> 00:16:02,320
recursive regexes so this is essentially

00:16:01,360 --> 00:16:04,240
saying hey

00:16:02,320 --> 00:16:07,040
you know apply this same regex program

00:16:04,240 --> 00:16:10,079
that's described here as part of

00:16:07,040 --> 00:16:12,320
a a part of the the regular expression

00:16:10,079 --> 00:16:13,839
this is neat uh particularly if you're

00:16:12,320 --> 00:16:15,759
working with an embedded program if

00:16:13,839 --> 00:16:17,440
you're trying to reject out lisp

00:16:15,759 --> 00:16:19,600
uh you know that's not something that's

00:16:17,440 --> 00:16:21,120
uh easily done with without

00:16:19,600 --> 00:16:25,360
recursive projects you can write a

00:16:21,120 --> 00:16:27,279
program that tokenizes quite clearly

00:16:25,360 --> 00:16:28,560
and my favorite feature is a kind of a

00:16:27,279 --> 00:16:30,399
raku only feature

00:16:28,560 --> 00:16:32,320
with the first class support for regular

00:16:30,399 --> 00:16:33,920
expression that pearl introduced for ku

00:16:32,320 --> 00:16:36,399
takes us a step further and provides

00:16:33,920 --> 00:16:39,759
first class support for grammars

00:16:36,399 --> 00:16:42,399
using tokens uh in kind of an eb and f

00:16:39,759 --> 00:16:44,959
style syntax here you can create tokens

00:16:42,399 --> 00:16:48,160
that are based on regular expressions

00:16:44,959 --> 00:16:49,680
and these regular expressions uh can be

00:16:48,160 --> 00:16:50,959
you know these sprite expressions can be

00:16:49,680 --> 00:16:52,560
used to build these grammars these

00:16:50,959 --> 00:16:55,680
grammars can be used to build

00:16:52,560 --> 00:16:58,079
kind of more more complex and and more

00:16:55,680 --> 00:17:01,199
complex programs that you pass in

00:16:58,079 --> 00:17:02,399
uh to to specific uh classes so there's

00:17:01,199 --> 00:17:04,799
a lot of com

00:17:02,399 --> 00:17:06,959
composition that's supported here in

00:17:04,799 --> 00:17:09,760
raku rules and raku grammars that is not

00:17:06,959 --> 00:17:09,760
supported elsewhere

00:17:09,919 --> 00:17:13,839
raiku also supports conjunctions uh

00:17:12,559 --> 00:17:15,039
which is a sort of

00:17:13,839 --> 00:17:17,839
you know can kind of think of it as the

00:17:15,039 --> 00:17:20,079
boolean and to the alternations boolean

00:17:17,839 --> 00:17:20,079
or

00:17:20,160 --> 00:17:23,839
and this is particularly helpful for

00:17:22,400 --> 00:17:26,000
more advanced i mean again this is a

00:17:23,839 --> 00:17:29,919
myopic example but for more advanced

00:17:26,000 --> 00:17:31,520
programs this is a helpful effort

00:17:29,919 --> 00:17:33,120
and that's all i have for you today i'd

00:17:31,520 --> 00:17:33,760
love to open the floor and have some

00:17:33,120 --> 00:17:35,679
questions i know

00:17:33,760 --> 00:17:37,440
quite a few people have messaged me on

00:17:35,679 --> 00:17:39,600
uh on

00:17:37,440 --> 00:17:42,799
on the chat here with with some

00:17:39,600 --> 00:17:44,080
specifics i'd love to hear more about uh

00:17:42,799 --> 00:17:47,840
other other things that people have

00:17:44,080 --> 00:17:47,840
noted questions and comments and so on

00:18:04,559 --> 00:18:07,679
yeah feel free to i'm you i have a

00:18:06,799 --> 00:18:11,200
question here

00:18:07,679 --> 00:18:11,760
sure um are you aware of any libraries

00:18:11,200 --> 00:18:14,320
which will

00:18:11,760 --> 00:18:15,200
translate from the across the various

00:18:14,320 --> 00:18:16,960
regular expression

00:18:15,200 --> 00:18:19,120
engines so if i have a regular

00:18:16,960 --> 00:18:22,080
expression in perl and i want to

00:18:19,120 --> 00:18:22,799
figure use it in vim you know what's how

00:18:22,080 --> 00:18:25,919
do you do that

00:18:22,799 --> 00:18:28,400
or things like that uh

00:18:25,919 --> 00:18:30,640
no i'm not aware of that i am aware of

00:18:28,400 --> 00:18:32,799
what are called regex induction engines

00:18:30,640 --> 00:18:35,039
where an essentially you pass

00:18:32,799 --> 00:18:36,880
a series of like inputs and outputs and

00:18:35,039 --> 00:18:38,880
it'll deduce or rather induce

00:18:36,880 --> 00:18:39,919
the the regular expression program based

00:18:38,880 --> 00:18:42,080
on that

00:18:39,919 --> 00:18:43,840
but specifically between like converting

00:18:42,080 --> 00:18:44,960
between syntaxes i'm not aware of any

00:18:43,840 --> 00:18:47,520
program like that

00:18:44,960 --> 00:18:47,520
right thank you

00:18:50,960 --> 00:18:54,960
you mentioned in your talk that there is

00:18:54,160 --> 00:18:57,360
no

00:18:54,960 --> 00:19:00,559
support for name captures in pearl but

00:18:57,360 --> 00:19:02,080
it actually there is one

00:19:00,559 --> 00:19:05,200
yep that's a great point that was an

00:19:02,080 --> 00:19:05,200
omission on my behalf

00:19:07,440 --> 00:19:14,320
uh one thing that uh that i like to use

00:19:11,280 --> 00:19:16,559
the uh the look aheads for is

00:19:14,320 --> 00:19:18,799
to uh because you can use the pause

00:19:16,559 --> 00:19:20,559
function to figure out where you are

00:19:18,799 --> 00:19:21,919
in in the last string that you matched

00:19:20,559 --> 00:19:24,880
on and

00:19:21,919 --> 00:19:26,320
sometimes you want that pause to return

00:19:24,880 --> 00:19:27,520
the beginning of an expression where

00:19:26,320 --> 00:19:30,640
normally if you just

00:19:27,520 --> 00:19:33,039
have a match it'll it'll be positioned

00:19:30,640 --> 00:19:33,679
after the match and if you wanted to

00:19:33,039 --> 00:19:35,919
position

00:19:33,679 --> 00:19:37,120
before the match you could do it as a

00:19:35,919 --> 00:19:39,120
zero width assertion

00:19:37,120 --> 00:19:41,600
instead and then then you'll be

00:19:39,120 --> 00:19:43,840
positioned right before that match

00:19:41,600 --> 00:19:44,640
um which which can be handy in a lot of

00:19:43,840 --> 00:19:47,280
cases

00:19:44,640 --> 00:19:53,520
so so i end up using the the look asides

00:19:47,280 --> 00:19:56,640
for stuff like that often

00:19:53,520 --> 00:19:59,440
in in regular expressions there is a

00:19:56,640 --> 00:20:00,320
uh i think it's the end the ampersand

00:19:59,440 --> 00:20:03,840
operator which

00:20:00,320 --> 00:20:06,080
does something like that it's a sort of

00:20:03,840 --> 00:20:06,880
look ahead that it's not really a look

00:20:06,080 --> 00:20:09,520
ahead

00:20:06,880 --> 00:20:11,120
it's more like you know you got an atom

00:20:09,520 --> 00:20:13,760
and if it matches then

00:20:11,120 --> 00:20:16,080
try to match something else after that

00:20:13,760 --> 00:20:21,840
so it's pretty similar to the double

00:20:16,080 --> 00:20:21,840
double end in the in the last slide

00:20:23,360 --> 00:20:28,240
gotcha so it's like somewhere between a

00:20:24,720 --> 00:20:28,240
conjunction and an assertion

00:20:29,039 --> 00:20:33,360
okay the vim regex flavor has uh quite a

00:20:31,600 --> 00:20:34,080
few interesting characteristics actually

00:20:33,360 --> 00:20:37,360
there's this concept

00:20:34,080 --> 00:20:40,640
of magic when you can like you know make

00:20:37,360 --> 00:20:40,640
it more and more capable

00:20:44,559 --> 00:20:48,080
look behind i believe there is there has

00:20:47,760 --> 00:20:50,400
been

00:20:48,080 --> 00:20:52,559
some development in recent pearl version

00:20:50,400 --> 00:20:54,720
to support a variable with

00:20:52,559 --> 00:20:55,679
variable length look behind correct

00:20:54,720 --> 00:20:57,840
instead of just

00:20:55,679 --> 00:20:59,120
doing some clever hack to sort of

00:20:57,840 --> 00:21:03,840
simulate it

00:20:59,120 --> 00:21:03,840
is that correct

00:21:04,159 --> 00:21:08,320
i'm i'm not familiar with the latest

00:21:06,880 --> 00:21:09,760
developments of the regex engine in

00:21:08,320 --> 00:21:17,840
pearl maybe someone else could comment

00:21:09,760 --> 00:21:17,840
on that

00:21:22,159 --> 00:21:25,200
mark notes in the chat i think the

00:21:23,520 --> 00:21:26,960
biggest controversy is do you spell it

00:21:25,200 --> 00:21:30,000
regex or regex

00:21:26,960 --> 00:21:31,919
that's that's a big one um or red

00:21:30,000 --> 00:21:35,280
jackson as daniel notes

00:21:31,919 --> 00:21:38,480
um i think you know i i try to use regex

00:21:35,280 --> 00:21:40,320
uh i i don't really know that

00:21:38,480 --> 00:21:41,760
there's any standard here arguably it

00:21:40,320 --> 00:21:43,280
should not be either

00:21:41,760 --> 00:21:44,880
arguably it should be called something

00:21:43,280 --> 00:21:46,080
else i think we've deviated

00:21:44,880 --> 00:21:50,080
significantly from

00:21:46,080 --> 00:21:50,080
the kind of original regular expression

00:21:50,960 --> 00:21:54,159
well the p is silent

00:21:55,280 --> 00:22:02,080
it's still pronounced regex

00:21:59,360 --> 00:22:02,080
that works too

00:22:07,120 --> 00:22:13,919
we mentioned unicor support and local

00:22:11,360 --> 00:22:14,720
you support during the talk and there is

00:22:13,919 --> 00:22:17,760
also

00:22:14,720 --> 00:22:20,159
the the layer of what you know

00:22:17,760 --> 00:22:20,799
what a string means when you actually

00:22:20,159 --> 00:22:23,280
apply your

00:22:20,799 --> 00:22:25,120
i guess to it it could be a byte string

00:22:23,280 --> 00:22:28,240
in a in a few cases

00:22:25,120 --> 00:22:30,400
it could be a character string

00:22:28,240 --> 00:22:31,520
in that's causing a whole different

00:22:30,400 --> 00:22:35,200
ballpark

00:22:31,520 --> 00:22:35,520
and it could be also i think in raqqa

00:22:35,200 --> 00:22:37,760
there

00:22:35,520 --> 00:22:38,799
is also a concept of graphene cluster

00:22:37,760 --> 00:22:42,080
etc

00:22:38,799 --> 00:22:44,400
to express you know what is

00:22:42,080 --> 00:22:46,559
visually a single character that is a

00:22:44,400 --> 00:22:48,799
sequence of chord points is something

00:22:46,559 --> 00:22:50,159
rather different although it's not

00:22:48,799 --> 00:22:54,000
visible to the user

00:22:50,159 --> 00:22:57,919
so that's something as well and

00:22:54,000 --> 00:23:00,720
another point i think i've often seen

00:22:57,919 --> 00:23:03,440
personally a lot of praise i guess well

00:23:00,720 --> 00:23:06,400
deserve for grandmas in rakupu

00:23:03,440 --> 00:23:08,000
but uh there is at least from something

00:23:06,400 --> 00:23:09,840
that i've of often been curious

00:23:08,000 --> 00:23:11,520
about i believe there was a talk a

00:23:09,840 --> 00:23:13,760
couple of uh

00:23:11,520 --> 00:23:15,280
in the yup cu in the pell conference in

00:23:13,760 --> 00:23:18,480
riga a couple of years ago about

00:23:15,280 --> 00:23:21,679
the grammar implementations because

00:23:18,480 --> 00:23:22,559
grammars are peg grammars but they don't

00:23:21,679 --> 00:23:25,840
often

00:23:22,559 --> 00:23:28,720
uh adapt to every possible situation

00:23:25,840 --> 00:23:29,520
so sometimes it's it does feel as though

00:23:28,720 --> 00:23:31,440
they

00:23:29,520 --> 00:23:33,760
are sort of all purpose grammars but

00:23:31,440 --> 00:23:35,440
perhaps that may not be the case in

00:23:33,760 --> 00:23:38,240
each and every situation there are

00:23:35,440 --> 00:23:40,880
situations where they are not

00:23:38,240 --> 00:23:43,200
as you know all purpose as they might

00:23:40,880 --> 00:23:43,200
seem

00:23:45,200 --> 00:23:48,400
yeah that's a great point um adding on

00:23:46,960 --> 00:23:49,760
to the first bit about kind of

00:23:48,400 --> 00:23:52,000
the character express or sorry the

00:23:49,760 --> 00:23:53,600
character set i think the uh

00:23:52,000 --> 00:23:55,039
you know one notable thing is the ruby

00:23:53,600 --> 00:23:57,279
regex engine was

00:23:55,039 --> 00:23:58,480
built in part to better support the

00:23:57,279 --> 00:23:59,760
japanese language

00:23:58,480 --> 00:24:01,200
and the character sets and character

00:23:59,760 --> 00:24:02,159
encodings that the japanese language

00:24:01,200 --> 00:24:04,320
uses

00:24:02,159 --> 00:24:07,039
um i think i'm want to say it's cp 512

00:24:04,320 --> 00:24:09,360
but i'm not 100 sure

00:24:07,039 --> 00:24:11,279
and that kind of construct is is

00:24:09,360 --> 00:24:13,840
significant especially when you're using

00:24:11,279 --> 00:24:14,880
higher level uh primitives like

00:24:13,840 --> 00:24:16,640
character classes right

00:24:14,880 --> 00:24:18,080
how do you define uppercase how do you

00:24:16,640 --> 00:24:21,919
define alpha

00:24:18,080 --> 00:24:22,480
in a language like chinese or japanese

00:24:21,919 --> 00:24:24,559
or

00:24:22,480 --> 00:24:26,320
or even like you know czech right where

00:24:24,559 --> 00:24:27,760
what is you know the upper case of a

00:24:26,320 --> 00:24:30,640
particular grapheme

00:24:27,760 --> 00:24:32,000
can have multiple characteristics and i

00:24:30,640 --> 00:24:34,240
think there's also an interesting

00:24:32,000 --> 00:24:35,520
point where i don't remember the exact

00:24:34,240 --> 00:24:38,159
language but

00:24:35,520 --> 00:24:39,600
one of the the nordic european languages

00:24:38,159 --> 00:24:41,279
where like certain characters are

00:24:39,600 --> 00:24:42,960
considered the uppercase version right

00:24:41,279 --> 00:24:44,320
like i think the bracket

00:24:42,960 --> 00:24:48,080
curly brackets are considered the

00:24:44,320 --> 00:24:50,400
uppercase version of square brackets

00:24:48,080 --> 00:24:52,480
both in a semantic as well as in like a

00:24:50,400 --> 00:24:55,039
input case

00:24:52,480 --> 00:24:56,799
i've heard this talk about for years but

00:24:55,039 --> 00:24:58,400
what i wonder is

00:24:56,799 --> 00:25:00,320
you know what's the evidence out on the

00:24:58,400 --> 00:25:02,799
internet how how

00:25:00,320 --> 00:25:04,000
how what do the regex is the practical

00:25:02,799 --> 00:25:07,120
uses of

00:25:04,000 --> 00:25:11,120
to solve those problems look like

00:25:07,120 --> 00:25:11,120
you know like a check uppercase

00:25:11,679 --> 00:25:15,679
i mean i think it's program program

00:25:13,200 --> 00:25:19,279
specific and and frankly these days

00:25:15,679 --> 00:25:19,760
normalize things into utf-8 uh and so

00:25:19,279 --> 00:25:22,640
you can

00:25:19,760 --> 00:25:24,640
rely on you know well-supported utf-8

00:25:22,640 --> 00:25:28,000
engines and write programs that

00:25:24,640 --> 00:25:31,200
that manage those well

00:25:28,000 --> 00:25:31,200
kind of test it against them

00:25:32,400 --> 00:25:35,440
one thing i've wondered about is how do

00:25:34,320 --> 00:25:38,559
different x

00:25:35,440 --> 00:25:40,559
engines treat uh left right text versus

00:25:38,559 --> 00:25:44,159
right to left text is the meaning of

00:25:40,559 --> 00:25:48,240
of next character switch or do you

00:25:44,159 --> 00:25:50,960
keep the consistent text direction even

00:25:48,240 --> 00:25:51,840
with that i think it depends on the

00:25:50,960 --> 00:25:54,080
character set

00:25:51,840 --> 00:25:56,000
um but the the significance there is

00:25:54,080 --> 00:25:58,240
like the definition of start of

00:25:56,000 --> 00:25:59,440
line and end of line is different but

00:25:58,240 --> 00:26:01,440
like the the

00:25:59,440 --> 00:26:03,120
the idea of like next and previous and

00:26:01,440 --> 00:26:05,760
look behind and look ahead

00:26:03,120 --> 00:26:10,080
are then derived from that start and end

00:26:05,760 --> 00:26:12,480
of of line or start and end of string

00:26:10,080 --> 00:26:14,159
back and forth in the direction during a

00:26:12,480 --> 00:26:16,159
in inside the string so

00:26:14,159 --> 00:26:17,200
that would actually complicate things a

00:26:16,159 --> 00:26:20,240
bit more

00:26:17,200 --> 00:26:22,320
if you go to more scripts etc just

00:26:20,240 --> 00:26:25,760
looking at our own translations usually

00:26:22,320 --> 00:26:29,120
uh with rtl the byte zero

00:26:25,760 --> 00:26:32,880
is the furthest right character right so

00:26:29,120 --> 00:26:34,799
your your position uh is indexed from

00:26:32,880 --> 00:26:37,200
rightmost as opposed to left most but

00:26:34,799 --> 00:26:39,039
it's still position zero

00:26:37,200 --> 00:26:41,760
you just move in the opposite direction

00:26:39,039 --> 00:26:41,760
with your pointer

00:26:51,679 --> 00:26:56,080
it one of the uh things that uh

00:26:53,919 --> 00:26:58,720
surprises me about regex is uh

00:26:56,080 --> 00:27:00,799
um or that i learned very late is the

00:26:58,720 --> 00:27:02,400
difference between dollar sign and uh

00:27:00,799 --> 00:27:05,919
backslash z

00:27:02,400 --> 00:27:06,320
um and uh it's in my opinion it's kind

00:27:05,919 --> 00:27:10,240
of an

00:27:06,320 --> 00:27:13,120
unfortunate side effect that dollar sign

00:27:10,240 --> 00:27:13,760
is pretty much what everyone uses but

00:27:13,120 --> 00:27:15,440
really

00:27:13,760 --> 00:27:18,080
almost everybody should be doing

00:27:15,440 --> 00:27:19,679
backslash z uh in the fact that they

00:27:18,080 --> 00:27:21,840
mostly work the same

00:27:19,679 --> 00:27:23,919
means i don't know did we get it wrong

00:27:21,840 --> 00:27:27,120
when we designed the uh

00:27:23,919 --> 00:27:29,279
the pcre language or the regex language

00:27:27,120 --> 00:27:29,279
or

00:27:29,679 --> 00:27:33,039
yeah i mean that's a great point i think

00:27:31,279 --> 00:27:35,440
the uh

00:27:33,039 --> 00:27:37,520
you know a lot of that semantic derives

00:27:35,440 --> 00:27:39,760
from posix bre

00:27:37,520 --> 00:27:41,120
which was really derived from from you

00:27:39,760 --> 00:27:44,799
know parsing

00:27:41,120 --> 00:27:45,200
fairly simple like lines of of uh source

00:27:44,799 --> 00:27:49,200
code

00:27:45,200 --> 00:27:52,480
mostly and so the the like idea of

00:27:49,200 --> 00:27:54,960
you know boundaries uh and and

00:27:52,480 --> 00:27:56,000
and other you know anchors is less

00:27:54,960 --> 00:27:59,360
significant

00:27:56,000 --> 00:28:03,840
when you have uh you know semicolon and

00:27:59,360 --> 00:28:03,840
other kinds of anchors to focus on

00:28:10,720 --> 00:28:17,200
question about regex engines

00:28:14,399 --> 00:28:18,399
i think i remember reading quite some

00:28:17,200 --> 00:28:22,320
time ago that

00:28:18,399 --> 00:28:25,520
uh the tickle engine was a sort of uh

00:28:22,320 --> 00:28:27,919
of a hybrid engine that used both

00:28:25,520 --> 00:28:29,039
non-infinite automata and phineas

00:28:27,919 --> 00:28:32,000
thermometer

00:28:29,039 --> 00:28:33,279
in its uh in its implementation and then

00:28:32,000 --> 00:28:37,039
sort of chose the

00:28:33,279 --> 00:28:39,520
one versus the other depending on the

00:28:37,039 --> 00:28:40,320
on the pattern or on the what was more

00:28:39,520 --> 00:28:43,520
convenient

00:28:40,320 --> 00:28:45,039
for for matching and

00:28:43,520 --> 00:28:46,559
do you have anything do you know

00:28:45,039 --> 00:28:48,320
something about that

00:28:46,559 --> 00:28:50,720
yeah i know a bit about that so the

00:28:48,320 --> 00:28:52,080
posix bri and posix ere there's an

00:28:50,720 --> 00:28:53,840
implementation

00:28:52,080 --> 00:28:55,200
uh the henry spencer library

00:28:53,840 --> 00:28:59,279
implementation is

00:28:55,200 --> 00:29:01,200
used or was initially used in in teagle

00:28:59,279 --> 00:29:02,960
and then henry spencer developed

00:29:01,200 --> 00:29:04,720
something called tegel ari

00:29:02,960 --> 00:29:06,480
the advanced regular expression flavor

00:29:04,720 --> 00:29:07,919
which i think uses the algorithm that

00:29:06,480 --> 00:29:09,279
you're describing and has some other

00:29:07,919 --> 00:29:12,000
kinds of constraints

00:29:09,279 --> 00:29:13,279
i'm not super familiar with with what

00:29:12,000 --> 00:29:14,720
that looks like under the hood and how

00:29:13,279 --> 00:29:16,159
it decides which of these

00:29:14,720 --> 00:29:17,840
flavors and which algorithms to use

00:29:16,159 --> 00:29:18,399
depend on which flavor in in tequila

00:29:17,840 --> 00:29:20,320
itself

00:29:18,399 --> 00:29:22,159
but it's worth noting by the way that uh

00:29:20,320 --> 00:29:25,440
like postgres by the uh

00:29:22,159 --> 00:29:26,640
as an example uses a re and are is is

00:29:25,440 --> 00:29:30,880
often considered like a

00:29:26,640 --> 00:29:32,640
you know uh uh good balance between

00:29:30,880 --> 00:29:35,120
feature richness and and performance

00:29:32,640 --> 00:29:38,720
characteristics in part because of the

00:29:35,120 --> 00:29:40,960
um uh the point that you noted around

00:29:38,720 --> 00:29:44,159
like using an nfa based algorithm

00:29:40,960 --> 00:29:47,440
or a dfa based algorithm can

00:29:44,159 --> 00:29:51,600
can determine the worst case

00:29:47,440 --> 00:29:51,600
runtime complexity characteristics

00:29:53,200 --> 00:29:56,399
and in fact by the way russ cox's re2

00:29:55,760 --> 00:29:58,320
engine

00:29:56,399 --> 00:29:59,520
was developed in part based on this

00:29:58,320 --> 00:30:01,520
motivation

00:29:59,520 --> 00:30:02,880
uh and that's the one used in the go

00:30:01,520 --> 00:30:04,559
language and it doesn't support back

00:30:02,880 --> 00:30:05,840
references specifically to avoid

00:30:04,559 --> 00:30:07,679
backtracking

00:30:05,840 --> 00:30:09,039
there's a bit of a trade-off here too in

00:30:07,679 --> 00:30:12,559
terms of time and space

00:30:09,039 --> 00:30:14,640
so uh those engines tend to have more

00:30:12,559 --> 00:30:15,840
memory requirements because they develop

00:30:14,640 --> 00:30:18,720
objects that have

00:30:15,840 --> 00:30:19,279
in in representation for the program

00:30:18,720 --> 00:30:22,240
that

00:30:19,279 --> 00:30:23,039
requires tracking more kinds of things

00:30:22,240 --> 00:30:24,880
but

00:30:23,039 --> 00:30:26,159
doesn't create things and then delete

00:30:24,880 --> 00:30:28,720
them kind of

00:30:26,159 --> 00:30:29,919
in a repeated fashion in the way that

00:30:28,720 --> 00:30:37,840
most backtracking

00:30:29,919 --> 00:30:37,840
regex algorithms use

00:30:48,840 --> 00:30:53,919
is since there's a product comes to mind

00:30:53,120 --> 00:30:57,519
it is a

00:30:53,919 --> 00:30:59,760
spamdisa and spam engine that uses a

00:30:57,519 --> 00:31:03,519
combination of

00:30:59,760 --> 00:31:06,640
i think re2 or something similar

00:31:03,519 --> 00:31:08,480
for certain kind of you know

00:31:06,640 --> 00:31:10,799
text patterns then sort of falling back

00:31:08,480 --> 00:31:13,039
to pcre for more complex

00:31:10,799 --> 00:31:14,480
matches etc in order to maxim to

00:31:13,039 --> 00:31:17,200
maximize the

00:31:14,480 --> 00:31:19,120
the efficiency when it comes to the the

00:31:17,200 --> 00:31:23,279
time constraints etc

00:31:19,120 --> 00:31:25,679
or also to try and prevent

00:31:23,279 --> 00:31:26,960
as far as much as possible catastrophic

00:31:25,679 --> 00:31:30,080
backtracking or

00:31:26,960 --> 00:31:33,679
similar problems within nfa engines

00:31:30,080 --> 00:31:36,000
for instance and that is actually quite

00:31:33,679 --> 00:31:37,279
i've often encountered in real life

00:31:36,000 --> 00:31:39,679
products

00:31:37,279 --> 00:31:40,799
problems with you know naive regular

00:31:39,679 --> 00:31:43,039
expressions

00:31:40,799 --> 00:31:44,080
in in java or in other languages where

00:31:43,039 --> 00:31:46,960
they actually

00:31:44,080 --> 00:31:48,799
did not account for the the catastrophe

00:31:46,960 --> 00:31:52,000
back tracking problems and

00:31:48,799 --> 00:31:54,799
led to threats stuck for days on end

00:31:52,000 --> 00:31:57,279
just trying to to to determine whether

00:31:54,799 --> 00:31:59,279
an html failed a

00:31:57,279 --> 00:32:00,480
certain regular expression or not for

00:31:59,279 --> 00:32:02,880
instance and that's

00:32:00,480 --> 00:32:03,760
actually quite a real light and there's

00:32:02,880 --> 00:32:05,600
actually a thing

00:32:03,760 --> 00:32:08,320
uh i don't remember it was cloudflare

00:32:05,600 --> 00:32:10,960
recently they had a similar problem

00:32:08,320 --> 00:32:12,080
in in recent recent months where they

00:32:10,960 --> 00:32:14,320
had

00:32:12,080 --> 00:32:15,760
a problem related to this sort of you

00:32:14,320 --> 00:32:19,200
know events

00:32:15,760 --> 00:32:20,320
that sort of become you know uh a denial

00:32:19,200 --> 00:32:23,200
of service problem

00:32:20,320 --> 00:32:25,039
even if it's not intended that way oh

00:32:23,200 --> 00:32:27,679
and in many ways it is intended that way

00:32:25,039 --> 00:32:30,000
right what they call redos right the

00:32:27,679 --> 00:32:32,159
regular expression denial of service

00:32:30,000 --> 00:32:33,360
if you have an understanding of the

00:32:32,159 --> 00:32:34,799
patterns that are used

00:32:33,360 --> 00:32:37,120
the specific programs you know

00:32:34,799 --> 00:32:37,919
oftentimes pulled like an r spam d or

00:32:37,120 --> 00:32:39,919
apache

00:32:37,919 --> 00:32:41,679
pulled from users right the the

00:32:39,919 --> 00:32:43,840
operators of the system

00:32:41,679 --> 00:32:45,600
and then the string which is pulled from

00:32:43,840 --> 00:32:47,919
from kind of a indeed the internet right

00:32:45,600 --> 00:32:50,960
so i can send an arbitrary string

00:32:47,919 --> 00:32:54,240
you you can cause buffer overflows and

00:32:50,960 --> 00:32:57,360
and other other kinds of um

00:32:54,240 --> 00:33:00,880
indirect uh negative consequences

00:32:57,360 --> 00:33:04,559
for by by essentially leveraging attacks

00:33:00,880 --> 00:33:04,559
on the backtracking algorithm

00:33:05,039 --> 00:33:08,559
yeah uh male spam assassin which is a

00:33:07,760 --> 00:33:11,600
pearl product

00:33:08,559 --> 00:33:14,720
they um they use a

00:33:11,600 --> 00:33:17,679
something called re2c which basically

00:33:14,720 --> 00:33:19,919
turns the regex into c code

00:33:17,679 --> 00:33:23,120
and then that's actually what runs over

00:33:19,919 --> 00:33:24,320
the mail as it comes across

00:33:23,120 --> 00:33:27,200
that's interesting i've never seen that

00:33:24,320 --> 00:33:27,200
i'll have to take a look at that

00:33:28,640 --> 00:33:31,840
and now i'm sitting here wondering what

00:33:30,480 --> 00:33:34,240
engine re2c

00:33:31,840 --> 00:33:38,000
uses to convert it to c so i'm going to

00:33:34,240 --> 00:33:41,279
go look myself

00:33:38,000 --> 00:33:44,640
a sort of a time limit on the uh

00:33:41,279 --> 00:33:46,640
on the regex you know computation etc

00:33:44,640 --> 00:33:47,919
in order to avoid the sort of problem

00:33:46,640 --> 00:33:50,000
where there is

00:33:47,919 --> 00:33:52,159
are often encounters as well with farm

00:33:50,000 --> 00:33:54,960
assassin or similar products that

00:33:52,159 --> 00:33:55,840
sometimes if you craft your your your

00:33:54,960 --> 00:33:58,159
axis

00:33:55,840 --> 00:33:59,440
a bit in a bit of an unfortunate manner

00:33:58,159 --> 00:34:00,480
you can find threads that have been

00:33:59,440 --> 00:34:03,919
running for

00:34:00,480 --> 00:34:04,960
i don't know one year on processes like

00:34:03,919 --> 00:34:06,480
that because it

00:34:04,960 --> 00:34:09,359
probably encounters something that was

00:34:06,480 --> 00:34:10,800
not you know they could not fail in any

00:34:09,359 --> 00:34:13,679
reasonable

00:34:10,800 --> 00:34:14,560
you know reasonable lifespans and i sort

00:34:13,679 --> 00:34:17,839
of got stuck

00:34:14,560 --> 00:34:18,240
in a service for for for months or years

00:34:17,839 --> 00:34:20,800
and

00:34:18,240 --> 00:34:22,159
so that's that's a quite a real problem

00:34:20,800 --> 00:34:23,839
even if it's something

00:34:22,159 --> 00:34:25,280
most people don't actually come into

00:34:23,839 --> 00:34:27,839
contact with but

00:34:25,280 --> 00:34:28,399
it is a problem that's why there are

00:34:27,839 --> 00:34:30,639
many

00:34:28,399 --> 00:34:32,000
that's actually there are a couple of

00:34:30,639 --> 00:34:34,240
projects apart from the

00:34:32,000 --> 00:34:36,240
grammars the programmers the iraqi

00:34:34,240 --> 00:34:37,359
grammars sorry that are based on

00:34:36,240 --> 00:34:39,679
grammars there are actually other

00:34:37,359 --> 00:34:43,119
projects that sort of say okay

00:34:39,679 --> 00:34:45,280
let's avoid regexis when one can use a

00:34:43,119 --> 00:34:46,320
grammar or something like that there is

00:34:45,280 --> 00:34:49,599
the i think the

00:34:46,320 --> 00:34:50,720
rosy pattern language is a a language

00:34:49,599 --> 00:34:53,919
that tries to

00:34:50,720 --> 00:34:56,960
sort of present itself as a form of less

00:34:53,919 --> 00:34:59,760
noisy less

00:34:56,960 --> 00:35:00,800
risky substitute for regular expressions

00:34:59,760 --> 00:35:03,119
although that's

00:35:00,800 --> 00:35:05,839
not entirely the case i guess in many

00:35:03,119 --> 00:35:05,839
situations

00:35:09,760 --> 00:35:14,839
william has shared a link to rosie in

00:35:11,839 --> 00:35:17,839
the rosie pattern language in the

00:35:14,839 --> 00:35:17,839
chat

00:35:23,200 --> 00:35:26,800
all right well that's it for me um if

00:35:26,320 --> 00:35:29,359
anyone

00:35:26,800 --> 00:35:31,839
asks us anything to share otherwise

00:35:29,359 --> 00:35:31,839

YouTube URL: https://www.youtube.com/watch?v=yfYqE3-Wy-g


