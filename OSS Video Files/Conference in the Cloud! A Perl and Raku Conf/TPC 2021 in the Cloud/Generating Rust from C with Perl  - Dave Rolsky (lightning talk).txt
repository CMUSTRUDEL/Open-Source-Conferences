Title: Generating Rust from C with Perl  - Dave Rolsky (lightning talk)
Publication date: 2021-06-08
Playlist: TPC 2021 in the Cloud
Description: 
	
Captions: 
	00:00:02,500 --> 00:00:05,819
[Applause]

00:00:06,560 --> 00:00:10,160
so

00:00:08,400 --> 00:00:11,519
welcome to the first session of

00:00:10,160 --> 00:00:13,840
lightning talks

00:00:11,519 --> 00:00:15,679
today we have eight talks scheduled for

00:00:13,840 --> 00:00:17,520
the full hour

00:00:15,679 --> 00:00:19,600
if you want to give an advertisement

00:00:17,520 --> 00:00:23,279
remember to raise your hand

00:00:19,600 --> 00:00:23,920
inside the zoom or try to hit me some

00:00:23,279 --> 00:00:27,119
other way

00:00:23,920 --> 00:00:27,119
and i will try to notice

00:00:27,599 --> 00:00:31,599
when a speaker finishes i will hit the

00:00:30,400 --> 00:00:33,360
gong

00:00:31,599 --> 00:00:36,000
or i will hit the gong to cause the

00:00:33,360 --> 00:00:39,360
speaker to finish could go either way

00:00:36,000 --> 00:00:39,840
and say that these like the advertiser

00:00:39,360 --> 00:00:42,320
can go

00:00:39,840 --> 00:00:44,079
and who should be setting up when the

00:00:42,320 --> 00:00:44,960
advertiser finishes we use the gong

00:00:44,079 --> 00:00:46,640
again

00:00:44,960 --> 00:00:48,160
we'll mention who's gonna be next and

00:00:46,640 --> 00:00:48,719
that the next person should start to

00:00:48,160 --> 00:00:50,160
talk

00:00:48,719 --> 00:00:52,960
i'll wait a few seconds so that we can

00:00:50,160 --> 00:00:56,000
get the video right and then we will

00:00:52,960 --> 00:00:59,359
then slather and repeat so

00:00:56,000 --> 00:01:01,280
let's go whenever you're ready

00:00:59,359 --> 00:01:03,520
all right so i'm going to talk about a

00:01:01,280 --> 00:01:05,920
thing which i think we've all done

00:01:03,520 --> 00:01:06,640
which is generating rust code from c

00:01:05,920 --> 00:01:08,560
with pearl

00:01:06,640 --> 00:01:10,080
so i apologize if this is just

00:01:08,560 --> 00:01:11,520
repetition for everybody who's been

00:01:10,080 --> 00:01:13,280
doing this already

00:01:11,520 --> 00:01:14,720
um so the background is i have this

00:01:13,280 --> 00:01:15,360
project called pg pretty i've been

00:01:14,720 --> 00:01:18,400
working on

00:01:15,360 --> 00:01:21,680
for a while and it's a postgres

00:01:18,400 --> 00:01:23,280
sql pretty printer written in rust

00:01:21,680 --> 00:01:25,119
and that's that's where i'm doing it so

00:01:23,280 --> 00:01:26,799
when i first started on this project

00:01:25,119 --> 00:01:29,280
i looked at what tools were available so

00:01:26,799 --> 00:01:31,040
there's this thing called lid pg query

00:01:29,280 --> 00:01:32,720
which is a c library where basically

00:01:31,040 --> 00:01:34,880
somebody ripped

00:01:32,720 --> 00:01:36,400
the pg part for code out of the postgres

00:01:34,880 --> 00:01:39,119
source and turned it into a

00:01:36,400 --> 00:01:39,759
library which is really really helpful

00:01:39,119 --> 00:01:42,079
because that's

00:01:39,759 --> 00:01:43,200
that's the hard work is is quite a bit

00:01:42,079 --> 00:01:44,880
of the hard work is that

00:01:43,200 --> 00:01:46,560
building that person so they didn't have

00:01:44,880 --> 00:01:48,079
to do that that's great and then there's

00:01:46,560 --> 00:01:50,079
this rust wrapper around the c library

00:01:48,079 --> 00:01:53,119
somebody else wrote called with pgquery

00:01:50,079 --> 00:01:55,200
this cool great i should be able to

00:01:53,119 --> 00:01:57,520
get right on this and write my pretty

00:01:55,200 --> 00:02:00,399
printer except

00:01:57,520 --> 00:02:01,439
the parser from c just gives me this

00:02:00,399 --> 00:02:04,000
json

00:02:01,439 --> 00:02:05,680
uh and the json is a lot of json this is

00:02:04,000 --> 00:02:07,600
an incredibly simple query

00:02:05,680 --> 00:02:08,879
and this is what you get you know for a

00:02:07,600 --> 00:02:10,800
more complex query

00:02:08,879 --> 00:02:12,400
as you imagine it's much bigger and this

00:02:10,800 --> 00:02:15,120
is basically

00:02:12,400 --> 00:02:16,319
uh the the query structure is an ast so

00:02:15,120 --> 00:02:18,160
what's the goal

00:02:16,319 --> 00:02:20,160
the goal is i want to turn that json

00:02:18,160 --> 00:02:22,160
into rust data structure so i can work

00:02:20,160 --> 00:02:22,560
with them i need an ast and specifically

00:02:22,160 --> 00:02:26,080
i need

00:02:22,560 --> 00:02:29,120
an ast and rust um and for

00:02:26,080 --> 00:02:30,879
nst you need node nodes and each node

00:02:29,120 --> 00:02:33,280
represents 1.3

00:02:30,879 --> 00:02:37,599
how many node types do we need well for

00:02:33,280 --> 00:02:37,599
postgres 10 we need 218

00:02:37,760 --> 00:02:42,720
this is the c code for the select

00:02:41,040 --> 00:02:44,319
statement node which

00:02:42,720 --> 00:02:45,680
is both for top level select statements

00:02:44,319 --> 00:02:47,280
but you'll also see anything like

00:02:45,680 --> 00:02:48,879
sub-select

00:02:47,280 --> 00:02:50,560
and these are all the fields then

00:02:48,879 --> 00:02:52,319
there's there's a bunch of fields

00:02:50,560 --> 00:02:54,400
and as you'll see a lot of these fields

00:02:52,319 --> 00:02:55,440
are themselves references to other

00:02:54,400 --> 00:02:57,680
things like

00:02:55,440 --> 00:02:58,480
the target list is a list of targets and

00:02:57,680 --> 00:03:00,400
the list

00:02:58,480 --> 00:03:01,519
anyway i'll get into that more it's a

00:03:00,400 --> 00:03:04,560
lot of stuff

00:03:01,519 --> 00:03:07,360
so how do i get there

00:03:04,560 --> 00:03:08,080
uh i could do it by hand uh but that

00:03:07,360 --> 00:03:10,879
would be really

00:03:08,080 --> 00:03:12,319
slow and tedious error-prone just just a

00:03:10,879 --> 00:03:14,560
horrible idea right

00:03:12,319 --> 00:03:15,440
so i'm not gonna do it by hand

00:03:14,560 --> 00:03:17,760
fortunately

00:03:15,440 --> 00:03:19,840
that dj query has these json files with

00:03:17,760 --> 00:03:20,239
all of the parsers e types defined in

00:03:19,840 --> 00:03:21,840
them

00:03:20,239 --> 00:03:24,959
so this is what select statement looks

00:03:21,840 --> 00:03:26,720
like it tells me there's it's fields

00:03:24,959 --> 00:03:28,640
what the c type is what the name is

00:03:26,720 --> 00:03:31,840
there's these comments

00:03:28,640 --> 00:03:33,760
um and some some of the the nodes in

00:03:31,840 --> 00:03:36,000
this json have just a comment and

00:03:33,760 --> 00:03:37,840
it's not super important anyway all the

00:03:36,000 --> 00:03:39,040
matter is if there's json that describes

00:03:37,840 --> 00:03:42,319
this stuff

00:03:39,040 --> 00:03:45,680
so how do we turn that json on to rust

00:03:42,319 --> 00:03:47,360
right we have here is pro of course um

00:03:45,680 --> 00:03:49,440
and the pro kind of knows what you'd

00:03:47,360 --> 00:03:51,280
expect it reads these json files and it

00:03:49,440 --> 00:03:54,080
writes out a bunch of rust structs

00:03:51,280 --> 00:03:55,760
and eons and it really lets me focus on

00:03:54,080 --> 00:04:00,400
the interesting parts of the project

00:03:55,760 --> 00:04:04,400
rather than handwriting 218 ast nodes

00:04:00,400 --> 00:04:06,640
uh to to implement this

00:04:04,400 --> 00:04:07,840
uh but mapping seed rust it has some

00:04:06,640 --> 00:04:08,799
interesting challenges one of the

00:04:07,840 --> 00:04:12,080
biggest challenges is

00:04:08,799 --> 00:04:14,640
optional fields so in c if you have like

00:04:12,080 --> 00:04:17,680
a pointer to a char opponent to a node

00:04:14,640 --> 00:04:21,120
is that field optional

00:04:17,680 --> 00:04:22,960
maybe uh but rust

00:04:21,120 --> 00:04:24,720
is much more specific though for example

00:04:22,960 --> 00:04:26,479
rust has a string type and then an

00:04:24,720 --> 00:04:28,000
option string type and an auction string

00:04:26,479 --> 00:04:29,840
type is optional

00:04:28,000 --> 00:04:32,160
and string is never optional it always

00:04:29,840 --> 00:04:34,800
has a value it could be an empty string

00:04:32,160 --> 00:04:36,720
but there's no notion of nil or null

00:04:34,800 --> 00:04:38,240
values in rust there's just

00:04:36,720 --> 00:04:40,720
optional values and there's some other

00:04:38,240 --> 00:04:42,320
things now i could make all of the rust

00:04:40,720 --> 00:04:46,080
struct fields

00:04:42,320 --> 00:04:48,320
be option foo you know option string

00:04:46,080 --> 00:04:50,000
option node whatever but that's really

00:04:48,320 --> 00:04:51,199
really annoying because in rust you

00:04:50,000 --> 00:04:53,759
can't treat

00:04:51,199 --> 00:04:54,320
an option string like a string you have

00:04:53,759 --> 00:04:56,479
to

00:04:54,320 --> 00:04:58,240
de-option it essentially check that it

00:04:56,479 --> 00:04:59,199
has a value before you work with that

00:04:58,240 --> 00:05:02,080
value

00:04:59,199 --> 00:05:03,840
so avoiding this when possible is ideal

00:05:02,080 --> 00:05:06,080
so how do i figure this out

00:05:03,840 --> 00:05:07,759
well there's yet another sort of

00:05:06,080 --> 00:05:09,199
programming language involved here which

00:05:07,759 --> 00:05:11,680
is a yak grammar

00:05:09,199 --> 00:05:13,360
so i go into the postgres source code

00:05:11,680 --> 00:05:14,960
for the yak grammar and i start looking

00:05:13,360 --> 00:05:16,160
at all the places where we make the

00:05:14,960 --> 00:05:18,080
thing in question

00:05:16,160 --> 00:05:20,080
to see whether the field is always

00:05:18,080 --> 00:05:22,880
populated and if it is i can make it

00:05:20,080 --> 00:05:25,440
non-optional

00:05:22,880 --> 00:05:26,960
so yeah that's fun lots of fun and then

00:05:25,440 --> 00:05:29,360
i was thinking maybe what i need is a

00:05:26,960 --> 00:05:31,680
parser for the yakramer to instruct this

00:05:29,360 --> 00:05:32,960
information and then i think that i

00:05:31,680 --> 00:05:35,840
might be going crazy

00:05:32,960 --> 00:05:37,199
so um this is what the generated struct

00:05:35,840 --> 00:05:38,880
looks like it has 18

00:05:37,199 --> 00:05:41,840
fields many of which are node which

00:05:38,880 --> 00:05:43,280
means any ast node

00:05:41,840 --> 00:05:45,039
there's also list which is a list of

00:05:43,280 --> 00:05:46,000
nodes in a lot of cases they can't be

00:05:45,039 --> 00:05:48,080
any node

00:05:46,000 --> 00:05:49,520
so select won't create contain a create

00:05:48,080 --> 00:05:51,280
table where clause

00:05:49,520 --> 00:05:53,360
so then i go back to the pg grammar and

00:05:51,280 --> 00:05:55,360
i look at the where clause definition

00:05:53,360 --> 00:05:56,400
and i look at what that means it says oh

00:05:55,360 --> 00:05:58,800
where a expression

00:05:56,400 --> 00:06:00,800
and a expression is this huge long thing

00:05:58,800 --> 00:06:01,919
that goes on for 400 lines i give up and

00:06:00,800 --> 00:06:04,080
i make it a node

00:06:01,919 --> 00:06:05,680
but sometimes i can narrow it down and i

00:06:04,080 --> 00:06:07,039
can make it a more specific type which

00:06:05,680 --> 00:06:09,039
is really nice

00:06:07,039 --> 00:06:10,240
uh there's lots still to do uh

00:06:09,039 --> 00:06:11,840
formatting code is

00:06:10,240 --> 00:06:13,600
gross there's more statement types i

00:06:11,840 --> 00:06:15,759
want to do plpg scroll and then i need

00:06:13,600 --> 00:06:17,280
to make everything work with playspg

00:06:15,759 --> 00:06:19,280
running over time so last thing if

00:06:17,280 --> 00:06:21,360
there's interest in response i'd be up

00:06:19,280 --> 00:06:21,840
for it let's discuss on slack i would

00:06:21,360 --> 00:06:24,240
prefer

00:06:21,840 --> 00:06:34,240
tomorrow's boss slot over thursdays

00:06:24,240 --> 00:06:34,240

YouTube URL: https://www.youtube.com/watch?v=HBoHv8-TZfk


