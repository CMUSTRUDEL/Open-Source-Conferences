Title: Curtis Poe (Ovid) - Perl 6 for Mere Mortals
Publication date: 2015-06-16
Playlist: YAPC::NA 2015
Description: 
	Ballroom A - Little America Hotel
Captions: 
	00:00:14,370 --> 00:00:19,810
okay it looks like that's tapering off

00:00:17,230 --> 00:00:30,279
just a little bit there or someone gonna

00:00:19,810 --> 00:00:45,000
make me a liar yes yes and yes and yes

00:00:30,279 --> 00:00:49,600
and yes okay and yes and and yes okay

00:00:45,000 --> 00:00:52,240
hello folks this has been an awesome

00:00:49,600 --> 00:00:55,480
conference so far I've been having a

00:00:52,240 --> 00:00:57,970
blast so my name is Curtis po better

00:00:55,480 --> 00:00:59,980
known to many of you is of it and I

00:00:57,970 --> 00:01:02,440
always like to put up the slide first of

00:00:59,980 --> 00:01:06,430
thanks to video quality my daughter is

00:01:02,440 --> 00:01:08,590
apparently dying but this is why I do

00:01:06,430 --> 00:01:15,399
what I do specifically that glass of

00:01:08,590 --> 00:01:17,110
wine right there and today's talk is

00:01:15,399 --> 00:01:19,990
going to be about / 06 for mere mortals

00:01:17,110 --> 00:01:22,749
the previous one there was some hinting

00:01:19,990 --> 00:01:24,520
at some of the problem that has been

00:01:22,749 --> 00:01:26,229
there with acceptance of the idea of

00:01:24,520 --> 00:01:29,740
pearl sex and I want to go into this a

00:01:26,229 --> 00:01:31,539
little bit deeper trying to get away

00:01:29,740 --> 00:01:33,549
from these scary aspects of pearl sakes

00:01:31,539 --> 00:01:36,700
let people know it's not just cool

00:01:33,549 --> 00:01:38,109
things it's better things it's going to

00:01:36,700 --> 00:01:41,799
make your life easier it's going to make

00:01:38,109 --> 00:01:44,950
your life so much nicer and my company

00:01:41,799 --> 00:01:46,630
by the way all around the world fr this

00:01:44,950 --> 00:01:47,770
is my pitch we do pearl consulting

00:01:46,630 --> 00:01:50,590
training for quite a number of different

00:01:47,770 --> 00:01:52,689
companies we do this for agile databases

00:01:50,590 --> 00:01:54,700
get but mostly we're in and of pearl

00:01:52,689 --> 00:01:57,959
including the company whose PHP

00:01:54,700 --> 00:01:57,959
installation we are gutting

00:01:58,469 --> 00:02:03,250
can't say more about that if you want to

00:02:00,850 --> 00:02:04,299
follow me online generally Twitter's one

00:02:03,250 --> 00:02:08,830
of the better places to do that

00:02:04,299 --> 00:02:12,310
twitter.com / Ovid pearl so that's

00:02:08,830 --> 00:02:14,260
enough of the pitch I have a couple of

00:02:12,310 --> 00:02:17,620
friends of mine James and yon who are

00:02:14,260 --> 00:02:20,170
racecar drivers if you wanted to learn

00:02:17,620 --> 00:02:21,640
how to drive a car you could go to James

00:02:20,170 --> 00:02:23,530
and yaarian and they could tell you

00:02:21,640 --> 00:02:25,090
everything you wanted to know they could

00:02:23,530 --> 00:02:26,709
talk about this engine here and they can

00:02:25,090 --> 00:02:29,799
tell you what that gear does what those

00:02:26,709 --> 00:02:31,840
gears do what that yellow thing does

00:02:29,799 --> 00:02:33,519
what that pink thing does I don't know

00:02:31,840 --> 00:02:35,560
what this stuff is it's an engine and

00:02:33,519 --> 00:02:38,829
it's scary and it's intimidating they

00:02:35,560 --> 00:02:40,180
talk about fuel air ratios and all sorts

00:02:38,829 --> 00:02:42,010
of things that after a while you're like

00:02:40,180 --> 00:02:45,250
oh my god this is really intimidating

00:02:42,010 --> 00:02:46,390
this is hard but most of us know if you

00:02:45,250 --> 00:02:49,590
want to drive a car you just get in the

00:02:46,390 --> 00:02:51,430
car and drive it's not a difficult thing

00:02:49,590 --> 00:02:52,870
but if you wanna start looking under the

00:02:51,430 --> 00:02:55,450
hood it could be intimidating and a lot

00:02:52,870 --> 00:02:57,010
of people who are excited about Pearl 6

00:02:55,450 --> 00:02:59,260
and all the possibilities start talking

00:02:57,010 --> 00:03:00,700
about what's under the hood start

00:02:59,260 --> 00:03:02,530
talking about the cool things you do I

00:03:00,700 --> 00:03:04,540
remember one of my favorite blog entries

00:03:02,530 --> 00:03:06,160
I wrote this thing I was explaining I

00:03:04,540 --> 00:03:08,500
think Larry wrote it originally solving

00:03:06,160 --> 00:03:11,139
red black trees using multisubs in Perl

00:03:08,500 --> 00:03:12,760
6 and I wrote up a long I was very proud

00:03:11,139 --> 00:03:16,120
of this explanation on blogs pearl that

00:03:12,760 --> 00:03:18,730
org not a single comment I don't think

00:03:16,120 --> 00:03:20,260
people even read it because these are

00:03:18,730 --> 00:03:23,500
the sorts of things we don't do all the

00:03:20,260 --> 00:03:25,269
time and they scare people so I wanted

00:03:23,500 --> 00:03:27,160
to bring it back down to earth a little

00:03:25,269 --> 00:03:30,970
bit and let you know that it's not scary

00:03:27,160 --> 00:03:32,919
but first I'm going to have like a

00:03:30,970 --> 00:03:35,139
little rant beforehand this is almost

00:03:32,919 --> 00:03:36,010
like a lightning talk before the talk so

00:03:35,139 --> 00:03:38,440
you can see one of the fundamental

00:03:36,010 --> 00:03:41,169
problems we have with how computer

00:03:38,440 --> 00:03:42,730
languages are handled today the last

00:03:41,169 --> 00:03:45,220
time I gave this talk was in Brussels

00:03:42,730 --> 00:03:47,290
and I made a horrible tactical error by

00:03:45,220 --> 00:03:49,090
asking the audience to participate and

00:03:47,290 --> 00:03:51,099
everyone was trying to get in the best

00:03:49,090 --> 00:03:53,049
line and they had some good ones so

00:03:51,099 --> 00:03:55,540
right now is there some in this audience

00:03:53,049 --> 00:03:57,310
who's really comfortable with math who

00:03:55,540 --> 00:04:02,680
can solve a couple of simple math

00:03:57,310 --> 00:04:05,379
problems for me what is your name David

00:04:02,680 --> 00:04:07,090
ok this is this is just to illustrate

00:04:05,379 --> 00:04:08,290
some of the differences in how computers

00:04:07,090 --> 00:04:10,180
tend to approach math and how we

00:04:08,290 --> 00:04:11,390
approach math so there's just a simple

00:04:10,180 --> 00:04:12,860
math problem I'd like

00:04:11,390 --> 00:04:14,720
don't think about computers just think

00:04:12,860 --> 00:04:20,450
about what your teacher in junior high

00:04:14,720 --> 00:04:26,600
would have told you i I'm sorry David

00:04:20,450 --> 00:04:29,350
that's the wrong slide forget about

00:04:26,600 --> 00:04:34,880
computers David can you solve for x

00:04:29,350 --> 00:04:37,310
what's the answer ok yes the answer is 3

00:04:34,880 --> 00:04:39,440
in it you know you're being filmed right

00:04:37,310 --> 00:04:40,940
now and I don't want you to think I've

00:04:39,440 --> 00:04:42,800
led you into a trap or something and

00:04:40,940 --> 00:04:51,280
embarrassing you do you want to revise

00:04:42,800 --> 00:04:51,280
your answer that's an embarrassing pause

00:05:01,240 --> 00:05:06,500
it's yeah I'll save you is 3.5 you're

00:05:05,360 --> 00:05:11,810
right the first time you trust your

00:05:06,500 --> 00:05:17,229
instincts ok I wasn't expecting that my

00:05:11,810 --> 00:05:19,490
apologies but so when we talk about your

00:05:17,229 --> 00:05:24,440
instincts you're saying 3.5 actually

00:05:19,490 --> 00:05:30,970
Ruby says you're wrong Python 2 says you

00:05:24,440 --> 00:05:33,979
are wrong tickle says you are wrong and

00:05:30,970 --> 00:05:36,200
in fact DC a nice little tools an

00:05:33,979 --> 00:05:38,660
arbitrary precision calculator trip with

00:05:36,200 --> 00:05:44,510
many operating systems obviously this

00:05:38,660 --> 00:05:46,250
can handle it so I wrote a number of

00:05:44,510 --> 00:05:49,570
these one-liners to help illustrate the

00:05:46,250 --> 00:05:49,570
problem i wrote a one liner and see

00:05:58,770 --> 00:06:04,660
so in fact I think the best way sees

00:06:03,100 --> 00:06:08,050
type system could be described as a

00:06:04,660 --> 00:06:09,370
steaming pile of zeros and ones and you

00:06:08,050 --> 00:06:11,230
get a warning but you don't get it from

00:06:09,370 --> 00:06:12,670
see you get it from the compiler GCC

00:06:11,230 --> 00:06:17,430
because it's smart enough to know that C

00:06:12,670 --> 00:06:20,260
is stupid and the % f here is a float

00:06:17,430 --> 00:06:22,540
double whatever we know that you know

00:06:20,260 --> 00:06:25,360
7/2 you have integer operand integer

00:06:22,540 --> 00:06:27,130
returns an integer so you know in this

00:06:25,360 --> 00:06:29,020
version of Jesus this compiler that I

00:06:27,130 --> 00:06:31,860
have I'm going to get the zeros down

00:06:29,020 --> 00:06:38,950
there if I correct the printf format I

00:06:31,860 --> 00:06:40,510
three so the thing to remember the thing

00:06:38,950 --> 00:06:42,820
I want to point out about all of this is

00:06:40,510 --> 00:06:44,680
the purpose of computers is not to solve

00:06:42,820 --> 00:06:46,570
computer issues it's not to optimize for

00:06:44,680 --> 00:06:48,669
computers it's to optimize for humans

00:06:46,570 --> 00:06:50,890
just to solve our problems if you don't

00:06:48,669 --> 00:06:52,660
believe me hit stack overflow or you

00:06:50,890 --> 00:06:54,669
know if your old school hit newsgroups

00:06:52,660 --> 00:06:56,890
and see all sorts of issues with this

00:06:54,669 --> 00:06:58,750
all the time and oh that's integer math

00:06:56,890 --> 00:07:02,290
you silly fool and I've had people argue

00:06:58,750 --> 00:07:08,470
with me that 7/2 has to be three because

00:07:02,290 --> 00:07:11,979
they're integers ha ok so pro 5 we know

00:07:08,470 --> 00:07:13,810
gets us right by there a Python 3 gets

00:07:11,979 --> 00:07:16,060
us right because we'd 0 itted that it

00:07:13,810 --> 00:07:19,930
was a mistake in a Python 2 shouldn't

00:07:16,060 --> 00:07:24,390
have been there so that's been fixed now

00:07:19,930 --> 00:07:26,830
at David I apologize for what I did to

00:07:24,390 --> 00:07:29,010
can I do it again can you tell me let's

00:07:26,830 --> 00:07:29,010
see

00:07:35,180 --> 00:07:44,970
yes Everett just just leave it alone

00:07:39,690 --> 00:07:48,090
that's nice haha so C says you're wrong

00:07:44,970 --> 00:07:51,570
but we know you're right so C says

00:07:48,090 --> 00:07:53,280
negative three integer divided by an

00:07:51,570 --> 00:07:56,310
integer operand integer you know

00:07:53,280 --> 00:07:58,980
negative 3 in this case what do these

00:07:56,310 --> 00:08:00,240
other languages say so a show of hands

00:07:58,980 --> 00:08:05,520
how many people think the answer is

00:08:00,240 --> 00:08:08,610
negative 3 this is not a trick question

00:08:05,520 --> 00:08:10,050
by the way honestly so I've see a few

00:08:08,610 --> 00:08:13,560
hands negative 3 how many people say it

00:08:10,050 --> 00:08:16,340
might be negative for how many people

00:08:13,560 --> 00:08:16,340
think it might be something different

00:08:17,870 --> 00:08:23,880
David's learning haha you know I

00:08:21,960 --> 00:08:28,320
honestly wouldn't be surprised at this

00:08:23,880 --> 00:08:32,969
point so so we saw the sea gave us minus

00:08:28,320 --> 00:08:37,200
3 so Ruby minus whoops ruby is minus 4

00:08:32,969 --> 00:08:41,120
minus 4 minus 4 BC gives us minus 3 and

00:08:37,200 --> 00:08:41,120
of course pearl you know it gives us oh

00:08:42,200 --> 00:08:55,830
I I have no idea I but very that's less

00:08:53,250 --> 00:08:58,410
than useful I think but but the thing is

00:08:55,830 --> 00:09:00,270
I have a room full of very very bright

00:08:58,410 --> 00:09:02,130
people in here with very simple

00:09:00,270 --> 00:09:03,390
mathematical problems who can't figure

00:09:02,130 --> 00:09:06,089
out what the computer is going to say

00:09:03,390 --> 00:09:07,680
and in fact I said C says negative 3 i

00:09:06,089 --> 00:09:10,950
canna lied because if you're dealing

00:09:07,680 --> 00:09:12,390
with c89 when integers are divided and

00:09:10,950 --> 00:09:13,950
the end of it and the division is

00:09:12,390 --> 00:09:18,870
inexact if either operon is negative the

00:09:13,950 --> 00:09:21,589
results as implementation defined you

00:09:18,870 --> 00:09:24,210
can have a perfectly correct program

00:09:21,589 --> 00:09:25,170
compiled you know against c89 ship it

00:09:24,210 --> 00:09:26,310
off to someone else and because they

00:09:25,170 --> 00:09:29,960
have a different compiler they get a

00:09:26,310 --> 00:09:29,960
different answer than you

00:09:36,319 --> 00:09:41,459
I'm not a sea programmer anymore either

00:09:38,910 --> 00:09:44,759
it was I I stopped actually in the 90s

00:09:41,459 --> 00:09:46,319
touching seat so oh thank you for

00:09:44,759 --> 00:09:48,269
reminding me question policy I should

00:09:46,319 --> 00:09:50,939
have said this at the beginning so that

00:09:48,269 --> 00:09:52,410
was a valid question but this is that's

00:09:50,939 --> 00:09:53,670
a sort of question if you want to expand

00:09:52,410 --> 00:09:55,860
beyond what I'm talking about please

00:09:53,670 --> 00:09:57,660
save those questions till the end so we

00:09:55,860 --> 00:09:59,339
have the time for that if there's

00:09:57,660 --> 00:10:01,470
something you don't understand about

00:09:59,339 --> 00:10:03,119
what I said go ahead and hold up your

00:10:01,470 --> 00:10:04,559
hand don't be embarrassed I mean someone

00:10:03,119 --> 00:10:06,959
else didn't understand it either and I

00:10:04,559 --> 00:10:08,369
did a bad job of explaining so that just

00:10:06,959 --> 00:10:09,300
helps us to manage our time better I

00:10:08,369 --> 00:10:15,540
should have said that at the beginning

00:10:09,300 --> 00:10:16,740
so thanks for the reminder haven't I

00:10:15,540 --> 00:10:25,519
told you before that you're not allowed

00:10:16,740 --> 00:10:28,649
to ask questions that's typical Larry

00:10:25,519 --> 00:10:33,689
okay now I made pro/5 look kind of good

00:10:28,649 --> 00:10:34,740
but that's not fair so um David I'm

00:10:33,689 --> 00:10:38,459
gonna let you off the hook because this

00:10:34,740 --> 00:10:40,740
one's pretty complicated here so so

00:10:38,459 --> 00:10:42,809
we're going to solve for x 0 point 1

00:10:40,740 --> 00:10:45,480
plus point 2 minus point three point one

00:10:42,809 --> 00:10:52,019
plus point2 reduces 2.3 minus point 3 is

00:10:45,480 --> 00:10:53,610
0 forget about computers people because

00:10:52,019 --> 00:10:56,220
we're trying to figure out what humans

00:10:53,610 --> 00:11:00,240
need not computers 0 equals point 1 plus

00:10:56,220 --> 00:11:07,709
point 2 minus point 3 okay david says

00:11:00,240 --> 00:11:09,569
yes so this is correct we know this is

00:11:07,709 --> 00:11:11,220
correct your maths teachers are going to

00:11:09,569 --> 00:11:15,139
grade you on this and say yes this is

00:11:11,220 --> 00:11:15,139
correct so what is pearl safe 405

00:11:17,040 --> 00:11:22,660
that is a very small number that is not

00:11:20,650 --> 00:11:25,210
zero and this is extremely important

00:11:22,660 --> 00:11:26,440
because zero mathematically has some

00:11:25,210 --> 00:11:28,690
significant properties which are

00:11:26,440 --> 00:11:30,250
different from other numbers and we have

00:11:28,690 --> 00:11:31,870
to keep this in mind in fact we could

00:11:30,250 --> 00:11:34,360
look at one sense and say this number is

00:11:31,870 --> 00:11:37,120
as far away from zero as 18 quadrillion

00:11:34,360 --> 00:11:39,010
I mean it is not zero and that is

00:11:37,120 --> 00:11:43,330
extremely important to keep in mind for

00:11:39,010 --> 00:11:45,640
example 1/0 produces a an exceptionally

00:11:43,330 --> 00:11:48,970
large number but not an exception so

00:11:45,640 --> 00:11:51,070
that's a little bit disappointing we can

00:11:48,970 --> 00:11:53,770
multiply the mass of the Sun in

00:11:51,070 --> 00:11:58,090
kilograms by zero and the resulting

00:11:53,770 --> 00:12:00,250
answer is 110 trillion kilograms that's

00:11:58,090 --> 00:12:01,660
the mass of Mount Everest yes as you

00:12:00,250 --> 00:12:05,070
always suspected Mount Everest is

00:12:01,660 --> 00:12:05,070
nothing more than a floating-point error

00:12:07,050 --> 00:12:11,890
other languages they all get it wrong

00:12:09,580 --> 00:12:13,900
ironically bc gets this right but since

00:12:11,890 --> 00:12:18,280
it can't figure out 7/3 I'm not

00:12:13,900 --> 00:12:19,480
reassured so this is a common problem

00:12:18,280 --> 00:12:20,980
with floating-point mathematics which

00:12:19,480 --> 00:12:22,450
I'm not going to go into right now if

00:12:20,980 --> 00:12:30,340
you're curious about it you can ask me

00:12:22,450 --> 00:12:32,590
afterwards actually I was going to touch

00:12:30,340 --> 00:12:37,750
about that was COBOL but thank you so

00:12:32,590 --> 00:12:39,370
what's pearl sixes idea of zero it gets

00:12:37,750 --> 00:12:41,320
the right answer what's going on with

00:12:39,370 --> 00:12:45,070
that I just pulled a rabbit out of the

00:12:41,320 --> 00:12:47,320
hat or something like that typically for

00:12:45,070 --> 00:12:49,660
the stock so in fact you have 1 divided

00:12:47,320 --> 00:12:50,980
by 0 for this example and you actually

00:12:49,660 --> 00:12:54,190
get the proper exception that you're

00:12:50,980 --> 00:12:55,300
expecting don't want to look under the

00:12:54,190 --> 00:12:56,710
hood too much in this talk because I

00:12:55,300 --> 00:12:58,870
wanted to be simple I want you to see

00:12:56,710 --> 00:13:00,190
how pearl actually Perl 6 actually does

00:12:58,870 --> 00:13:01,420
the right thing makes your life easier

00:13:00,190 --> 00:13:03,730
so you don't have to worry about these

00:13:01,420 --> 00:13:05,620
problems but just for this little bit

00:13:03,730 --> 00:13:07,900
let's lift the bonnet look under the

00:13:05,620 --> 00:13:10,360
hood see lips abundant look under the

00:13:07,900 --> 00:13:12,280
hood I'm mixing up my country's here and

00:13:10,360 --> 00:13:15,760
see what's actually going on so we can

00:13:12,280 --> 00:13:17,980
understand what happened so in Perl 6

00:13:15,760 --> 00:13:19,060
everything is an object after this I

00:13:17,980 --> 00:13:21,910
might just start referring to it as

00:13:19,060 --> 00:13:23,770
pearl just to keep things simpler and if

00:13:21,910 --> 00:13:26,770
you just type perl 6 at a command prompt

00:13:23,770 --> 00:13:28,810
hit return you enter a simple repple so

00:13:26,770 --> 00:13:29,630
say point 3 dot what you're calling the

00:13:28,810 --> 00:13:32,650
what

00:13:29,630 --> 00:13:35,300
method on that and it says it's a rat

00:13:32,650 --> 00:13:37,490
what's a rat a rat is a rational number

00:13:35,300 --> 00:13:38,750
you can't say rational because rationale

00:13:37,490 --> 00:13:40,250
is actually a role you can apply to

00:13:38,750 --> 00:13:43,660
other things so r at this rational

00:13:40,250 --> 00:13:47,870
number which has a numerator of three a

00:13:43,660 --> 00:13:49,640
denominator of 10 rats have a nude

00:13:47,870 --> 00:13:51,170
method which returns a list of the

00:13:49,640 --> 00:13:53,450
numerator and the denominator and then

00:13:51,170 --> 00:13:55,940
you call pearl kind of like data dump er

00:13:53,450 --> 00:13:57,880
which then returns 3 comma 10 so you can

00:13:55,940 --> 00:14:01,970
see the numerator over the denominator

00:13:57,880 --> 00:14:03,830
that is how it can keep exact values for

00:14:01,970 --> 00:14:07,430
you and if I hear this last one is very

00:14:03,830 --> 00:14:09,260
interesting so 3.14159 27 we know that's

00:14:07,430 --> 00:14:11,900
an approximation of pie and a rational

00:14:09,260 --> 00:14:14,780
number but now instead about instead of

00:14:11,900 --> 00:14:17,360
letting your computer's limitations to

00:14:14,780 --> 00:14:20,360
find what precision you have for this

00:14:17,360 --> 00:14:22,280
rational number you get to choose you

00:14:20,360 --> 00:14:26,180
get to decide what in precision you want

00:14:22,280 --> 00:14:28,040
to have with these numbers but you can

00:14:26,180 --> 00:14:29,210
forget about that most of the time you

00:14:28,040 --> 00:14:30,650
don't want to worry about what's under

00:14:29,210 --> 00:14:34,760
the hood just drive the darn car and

00:14:30,650 --> 00:14:36,920
it's going to work for you so that was

00:14:34,760 --> 00:14:38,750
my mini rant about a common problem that

00:14:36,920 --> 00:14:40,330
I think pearl doesn't pearls pro-sex

00:14:38,750 --> 00:14:42,380
pearl does a really good job of solving

00:14:40,330 --> 00:14:45,920
but now I want to talk about another

00:14:42,380 --> 00:14:47,960
problem a very common problem data being

00:14:45,920 --> 00:14:50,210
passed around a lot of people like talk

00:14:47,960 --> 00:14:51,590
about unit testing and I'm actually a

00:14:50,210 --> 00:14:54,230
little frustrated with unit testing cuz

00:14:51,590 --> 00:14:55,970
unit testing tests a unit and does it do

00:14:54,230 --> 00:14:58,040
what I wanted to do but it often doesn't

00:14:55,970 --> 00:15:00,290
test whether or not units talk to one

00:14:58,040 --> 00:15:01,640
another effectively and if they can't

00:15:00,290 --> 00:15:04,310
speak the same language you've got a

00:15:01,640 --> 00:15:05,960
serious problem and in dynamic languages

00:15:04,310 --> 00:15:07,010
you know you don't want that call three

00:15:05,960 --> 00:15:08,420
o'clock in the morning cuz something

00:15:07,010 --> 00:15:10,100
went wrong and you found out you had

00:15:08,420 --> 00:15:12,260
this bad data being passed around all

00:15:10,100 --> 00:15:14,030
over the place because well you're lazy

00:15:12,260 --> 00:15:17,360
you didn't check the types you can check

00:15:14,030 --> 00:15:20,660
the values whatever and static languages

00:15:17,360 --> 00:15:23,390
often avoid this dynamic languages often

00:15:20,660 --> 00:15:26,840
ignore this so what do we actually have

00:15:23,390 --> 00:15:29,180
with pearl so here's a simple function

00:15:26,840 --> 00:15:30,830
in pro 5 reciprocal one over I mean

00:15:29,180 --> 00:15:32,540
obviously this is a stupid example of

00:15:30,830 --> 00:15:34,910
don't repeat yourself because you just

00:15:32,540 --> 00:15:36,590
have that in line but what does that

00:15:34,910 --> 00:15:40,100
shift mean if you're not familiar with

00:15:36,590 --> 00:15:42,620
pro 5 in fact what do all these darn

00:15:40,100 --> 00:15:42,870
things mean I mean this this is starting

00:15:42,620 --> 00:15:45,270
to get

00:15:42,870 --> 00:15:46,830
but confusing after a while and this is

00:15:45,270 --> 00:15:52,200
there's more the one way to embarrass

00:15:46,830 --> 00:15:54,480
just screw this I mean it's nice but

00:15:52,200 --> 00:15:56,850
since there's not a an affordance for

00:15:54,480 --> 00:15:58,740
doing the right thing in Perl 5 we all

00:15:56,850 --> 00:16:02,070
do our own thing and sometimes that's

00:15:58,740 --> 00:16:03,150
confusing so I'm going to stop for a

00:16:02,070 --> 00:16:04,740
moment and talk about the Fibonacci

00:16:03,150 --> 00:16:07,050
series and we'll get back to functions

00:16:04,740 --> 00:16:08,490
in a moment and a lot of people hate the

00:16:07,050 --> 00:16:09,930
Fibonacci series because they say it has

00:16:08,490 --> 00:16:12,690
no application in the real world in

00:16:09,930 --> 00:16:15,720
which which is not true but it generally

00:16:12,690 --> 00:16:16,920
doesn't touch our code the reason i like

00:16:15,720 --> 00:16:18,089
the fibonacci series so much

00:16:16,920 --> 00:16:20,339
particularly when i'm trying to explain

00:16:18,089 --> 00:16:22,680
recursion to someone is it's incredibly

00:16:20,339 --> 00:16:24,660
simple to understand it's incredibly

00:16:22,680 --> 00:16:25,950
simple to explain but when you're

00:16:24,660 --> 00:16:28,200
talking about recursive functions you

00:16:25,950 --> 00:16:29,760
have three strong cases of failure one

00:16:28,200 --> 00:16:31,830
you forget the base cases to break out

00:16:29,760 --> 00:16:33,839
of the recursion because you don't want

00:16:31,830 --> 00:16:36,180
an infinite loop and that's a human

00:16:33,839 --> 00:16:38,430
problem to you forget to check your

00:16:36,180 --> 00:16:39,930
arguments to make sure they're valid for

00:16:38,430 --> 00:16:41,190
your recursive function that's that's

00:16:39,930 --> 00:16:43,350
also kind of a human problem not just

00:16:41,190 --> 00:16:45,390
limited to recursion obviously and three

00:16:43,350 --> 00:16:48,750
deep recursion can blow the stack that's

00:16:45,390 --> 00:16:51,420
a computer problem that gets to be kind

00:16:48,750 --> 00:16:54,270
of annoying so a very simple recursive

00:16:51,420 --> 00:16:56,400
function can demonstrate all sorts of

00:16:54,270 --> 00:16:58,680
fascinating errors so I like to keep it

00:16:56,400 --> 00:17:01,350
nice and simple with Fibonacci so you

00:16:58,680 --> 00:17:03,620
can focus on the errors and if it Maxie

00:17:01,350 --> 00:17:06,689
series if you've never seen it before

00:17:03,620 --> 00:17:08,610
without going into too much detail 0+1

00:17:06,689 --> 00:17:11,069
you add the last two numbers list to get

00:17:08,610 --> 00:17:14,339
the next element to the list 0 plus 1 is

00:17:11,069 --> 00:17:16,650
1 1 plus 1 is to 1 plus 2 is 32 plus 35

00:17:14,339 --> 00:17:20,189
etc etc etc that's how you generate the

00:17:16,650 --> 00:17:22,530
Fibonacci series it's simple it is not

00:17:20,189 --> 00:17:23,550
hard no it generally doesn't apply to

00:17:22,530 --> 00:17:24,780
what you're actually doing but it's a

00:17:23,550 --> 00:17:28,830
nice way to illustrate some of the

00:17:24,780 --> 00:17:30,240
problems we have so here is one array

00:17:28,830 --> 00:17:32,309
one way to write the Fibonacci a

00:17:30,240 --> 00:17:37,170
recursive Fibonacci function in Perl 6

00:17:32,309 --> 00:17:39,150
and bless you it's not rocket science

00:17:37,170 --> 00:17:40,860
and we actually have a basic function

00:17:39,150 --> 00:17:42,030
signature right there function

00:17:40,860 --> 00:17:45,480
signatures have been around since before

00:17:42,030 --> 00:17:51,230
most of us were born so it's about darn

00:17:45,480 --> 00:17:51,230
time that we have the things hmm

00:17:52,509 --> 00:17:58,039
and down here we can say say fib that

00:17:56,360 --> 00:17:59,899
gives us the eighth Fibonacci number

00:17:58,039 --> 00:18:03,500
indexing from zero we know it's 21 and

00:17:59,899 --> 00:18:05,960
this works this works give an N twin 00

00:18:03,500 --> 00:18:07,639
when 11 so basically last name and

00:18:05,960 --> 00:18:09,649
evaluated you know that's a return value

00:18:07,639 --> 00:18:11,090
just like Perl 5 default this is like

00:18:09,649 --> 00:18:12,350
the given winds statement you get in

00:18:11,090 --> 00:18:15,860
Perl 5 to a lot of people don't actually

00:18:12,350 --> 00:18:17,570
use it very much it works very nicely it

00:18:15,860 --> 00:18:19,480
actually maps very cleanly to the

00:18:17,570 --> 00:18:21,940
mathematical definition of Fibonacci

00:18:19,480 --> 00:18:26,360
let's just look complicated to anyone

00:18:21,940 --> 00:18:28,610
now but that's an infinite loop and

00:18:26,360 --> 00:18:32,210
that's a little bit frustrating because

00:18:28,610 --> 00:18:33,980
we have the 3.7 down here your n minus 1

00:18:32,210 --> 00:18:36,200
your enth minus 2 will never match your

00:18:33,980 --> 00:18:37,970
base cases now we have an infinite loop

00:18:36,200 --> 00:18:39,919
it's very easy to do that and recursive

00:18:37,970 --> 00:18:41,990
functions oops we screwed up so now you

00:18:39,919 --> 00:18:44,029
got to check the value that you've

00:18:41,990 --> 00:18:49,179
passed in how would you do that we'll

00:18:44,029 --> 00:18:52,370
look at pro 5 again hello there we go so

00:18:49,179 --> 00:18:53,929
there are many many many many ways you

00:18:52,370 --> 00:18:55,279
can check to see that you've actually

00:18:53,929 --> 00:19:00,100
got an integer instead of a floating

00:18:55,279 --> 00:19:02,629
point number and all of these are wrong

00:19:00,100 --> 00:19:05,360
they will generally work but every

00:19:02,629 --> 00:19:07,639
single one of those is buggy in subtly

00:19:05,360 --> 00:19:10,519
different ways not least of which you

00:19:07,639 --> 00:19:12,700
pass multiple arguments this one let's

00:19:10,519 --> 00:19:14,809
talk about you know the Unicode

00:19:12,700 --> 00:19:16,190
characters it actually matches numbers

00:19:14,809 --> 00:19:18,379
which don't look anything like numbers

00:19:16,190 --> 00:19:20,059
some of which are made up numbers from

00:19:18,379 --> 00:19:21,799
Tibet which were found under stamp art

00:19:20,059 --> 00:19:24,350
actually numbers I mean there's all

00:19:21,799 --> 00:19:28,370
sorts of bugs in this and it's a pain to

00:19:24,350 --> 00:19:29,960
read that so perl 6 just slap an int on

00:19:28,370 --> 00:19:32,570
their say it's got to be an int this is

00:19:29,960 --> 00:19:34,639
what we call gradual typing in perl 6

00:19:32,570 --> 00:19:35,690
you can actually read about this as one

00:19:34,639 --> 00:19:37,700
of the languages where they're looking

00:19:35,690 --> 00:19:39,259
more dynamic languages are realizing

00:19:37,700 --> 00:19:41,419
okay we need this type information

00:19:39,259 --> 00:19:44,480
they're trying to bolt gradual typing on

00:19:41,419 --> 00:19:46,610
behind and it's not actually working as

00:19:44,480 --> 00:19:49,490
nicely as a can of perl 6 because it's

00:19:46,610 --> 00:19:51,200
not part of the language you can't

00:19:49,490 --> 00:19:52,820
really take advantage and a lot of the

00:19:51,200 --> 00:19:54,679
optimizations there because it's an

00:19:52,820 --> 00:19:57,529
afterthought in perl 6 is built in you

00:19:54,679 --> 00:19:59,240
don't have to have it but if you do fade

00:19:57,529 --> 00:20:03,080
3.7 type check failed and binding

00:19:59,240 --> 00:20:03,620
expected int but so it works it does

00:20:03,080 --> 00:20:07,720
what you

00:20:03,620 --> 00:20:10,309
want it to do and again it's simple and

00:20:07,720 --> 00:20:12,890
we have another infinite loop because

00:20:10,309 --> 00:20:15,470
it's still not enough so fib negative 3

00:20:12,890 --> 00:20:17,480
the ends minus 1 and the n minus 2 are

00:20:15,470 --> 00:20:21,850
never going to hit our base cases of 0

00:20:17,480 --> 00:20:24,640
and 1 so we're still not quite there

00:20:21,850 --> 00:20:28,790
that is where we have a constraint

00:20:24,640 --> 00:20:30,860
intent where star greater than equal to

00:20:28,790 --> 00:20:32,240
0 star is an example of the whatever

00:20:30,860 --> 00:20:36,140
class and I like to read this as

00:20:32,240 --> 00:20:39,440
whatever I got intent wear whatever I

00:20:36,140 --> 00:20:41,720
got greater than equal to 0 give

00:20:39,440 --> 00:20:45,920
negative 3 constraint that's the where

00:20:41,720 --> 00:20:49,190
type check failed for parameter n so

00:20:45,920 --> 00:20:50,900
that allows us to have a very nice tight

00:20:49,190 --> 00:20:52,910
constraint saying it's got to be an

00:20:50,900 --> 00:20:55,490
integer wear whatever I have is greater

00:20:52,910 --> 00:20:57,500
than equal to 0 and it's simple and easy

00:20:55,490 --> 00:20:58,820
to write and you don't have to litter

00:20:57,500 --> 00:21:01,040
your code with a lot of procedural

00:20:58,820 --> 00:21:05,450
checks to figure out whether or not your

00:21:01,040 --> 00:21:07,190
data is correct it's simple but this is

00:21:05,450 --> 00:21:08,510
actually kind of ugly because what if

00:21:07,190 --> 00:21:11,809
you have multiple parameters being

00:21:08,510 --> 00:21:13,070
passed in there or you know instead of

00:21:11,809 --> 00:21:14,540
multiple parameters what if you're going

00:21:13,070 --> 00:21:17,320
to be using this particular constraint

00:21:14,540 --> 00:21:19,700
all over the place fine let's name it

00:21:17,320 --> 00:21:22,690
subset not negative int int wear

00:21:19,700 --> 00:21:25,730
whatever I got greater than equals 0 and

00:21:22,690 --> 00:21:27,890
non negative intent and boom it just

00:21:25,730 --> 00:21:32,330
magically works you have created your

00:21:27,890 --> 00:21:35,030
own type on the fly and it's easy it's

00:21:32,330 --> 00:21:36,500
simple does that look like rocket

00:21:35,030 --> 00:21:38,090
science anyone is this Oh mind binding

00:21:36,500 --> 00:21:41,390
mind-bendingly complex you can't

00:21:38,090 --> 00:21:44,929
understand it now can you imagine trying

00:21:41,390 --> 00:21:46,400
to write all that in Perl 5 the 273 ways

00:21:44,929 --> 00:21:51,800
you can come up just off the top of your

00:21:46,400 --> 00:21:52,970
head to do that it's simple it's easy so

00:21:51,800 --> 00:21:55,580
function signatures are one of the

00:21:52,970 --> 00:21:57,890
things which are nice about the Perl 6

00:21:55,580 --> 00:21:59,600
dynamic language the first four that we

00:21:57,890 --> 00:22:01,010
see here are what you're going to get in

00:21:59,600 --> 00:22:03,020
the most popular dynamic languages

00:22:01,010 --> 00:22:04,820
sometimes are optional you have basic

00:22:03,020 --> 00:22:06,590
ones where they're just named you have

00:22:04,820 --> 00:22:08,420
default values if we don't pass in

00:22:06,590 --> 00:22:11,240
dollar foo then it gets the default

00:22:08,420 --> 00:22:12,890
value of three we have names function

00:22:11,240 --> 00:22:15,380
named arguments which I'll talk about a

00:22:12,890 --> 00:22:16,830
little bit later the last two the number

00:22:15,380 --> 00:22:19,620
five and six where we can

00:22:16,830 --> 00:22:22,320
gradual typing or we can add these nice

00:22:19,620 --> 00:22:25,140
constraints afterwards those aren't as

00:22:22,320 --> 00:22:27,779
common but it's built in and it's

00:22:25,140 --> 00:22:30,690
natural to Perl 6 it's easy and it's

00:22:27,779 --> 00:22:33,870
incredibly powerful in fact looking at

00:22:30,690 --> 00:22:36,269
this constraint here what is that so

00:22:33,870 --> 00:22:38,250
subset non empty string of string where

00:22:36,269 --> 00:22:40,230
whatever we got cars greater than equals

00:22:38,250 --> 00:22:41,760
zero how many times has anyone here ever

00:22:40,230 --> 00:22:44,220
had a bug where you had to pass in a

00:22:41,760 --> 00:22:48,299
string and you forgot to check whether

00:22:44,220 --> 00:22:50,429
or not it was empty yeah and you know it

00:22:48,299 --> 00:22:53,820
shows up in like MySQL all the time very

00:22:50,429 --> 00:22:55,440
frustrating and so this way you just say

00:22:53,820 --> 00:22:57,240
you just assert that this string can't

00:22:55,440 --> 00:22:59,580
be empty this is going to be one of

00:22:57,240 --> 00:23:02,159
those popular subsets in Perl 6 right

00:22:59,580 --> 00:23:03,870
here just give me a string but it better

00:23:02,159 --> 00:23:08,130
not be emptied art it it's going to be

00:23:03,870 --> 00:23:09,990
nice or another one this is the one that

00:23:08,130 --> 00:23:11,789
I think might be very popular for when

00:23:09,990 --> 00:23:15,450
your system administrator did not

00:23:11,789 --> 00:23:17,639
configure MySQL properly when would it's

00:23:15,450 --> 00:23:19,019
a not in strict or traditional mode so

00:23:17,639 --> 00:23:21,779
what happens in MySQL let's say you got

00:23:19,019 --> 00:23:23,940
a varchar 255 and you insert a string

00:23:21,779 --> 00:23:25,529
which is 500 characters mysql is very

00:23:23,940 --> 00:23:28,799
helpful and make sure that you only have

00:23:25,529 --> 00:23:32,220
255 characters in there it truncates

00:23:28,799 --> 00:23:33,659
your data it throws it away there's all

00:23:32,220 --> 00:23:35,250
sorts of failure modes what many of us

00:23:33,659 --> 00:23:36,870
are familiar with that in this case I

00:23:35,250 --> 00:23:40,200
can see something like this being used

00:23:36,870 --> 00:23:42,149
in orl sub first name of string where 0

00:23:40,200 --> 00:23:45,330
is less than whatever I got care cars

00:23:42,149 --> 00:23:49,230
less than 256 in other words it's a non

00:23:45,330 --> 00:23:50,820
empty string up to 255 characters so

00:23:49,230 --> 00:23:54,659
even if your database isn't configured

00:23:50,820 --> 00:23:56,429
well your perl 6 subset right here will

00:23:54,659 --> 00:24:03,679
guarantee that you can't pass bad data

00:23:56,429 --> 00:24:03,679
into it yes this

00:24:05,470 --> 00:24:10,000
ah no this is a grammar we're going to

00:24:08,620 --> 00:24:14,770
make everything case-insensitive like

00:24:10,000 --> 00:24:17,049
you know vb or something sorry yes thank

00:24:14,770 --> 00:24:25,090
you I gotta fix that there was a was

00:24:17,049 --> 00:24:26,169
okay thank you so I didn't talk about I

00:24:25,090 --> 00:24:28,210
didn't I'm not going to say the call

00:24:26,169 --> 00:24:30,400
graph but mostly who I hope are familiar

00:24:28,210 --> 00:24:31,510
with how call graphs of recursive

00:24:30,400 --> 00:24:33,280
functions work and how you can

00:24:31,510 --> 00:24:35,919
accidentally wind up calculating the

00:24:33,280 --> 00:24:37,120
same data over and over again and in

00:24:35,919 --> 00:24:38,799
recursive function like you know

00:24:37,120 --> 00:24:40,480
Fibonacci you start searching for like

00:24:38,799 --> 00:24:41,710
the 25th Fibonacci number and above

00:24:40,480 --> 00:24:44,320
you're going to be recalculating the

00:24:41,710 --> 00:24:46,419
same information over and over again and

00:24:44,320 --> 00:24:48,010
it slows down to the point where

00:24:46,419 --> 00:24:50,110
sometimes you'll just be waiting forever

00:24:48,010 --> 00:24:53,110
and you'll give up heat death of the

00:24:50,110 --> 00:24:54,700
universe etc so how do you deal with

00:24:53,110 --> 00:24:57,610
situations like that there's many ways

00:24:54,700 --> 00:24:58,900
you can do that one is caching so here

00:24:57,610 --> 00:25:00,610
you might have instrumenting your code

00:24:58,900 --> 00:25:02,500
you insert a cash this is a state

00:25:00,610 --> 00:25:04,240
variable it will return its data between

00:25:02,500 --> 00:25:05,890
you know function column becomes just

00:25:04,240 --> 00:25:09,309
like we have had in perl for quite some

00:25:05,890 --> 00:25:11,710
time this is the exists adverb on cash

00:25:09,309 --> 00:25:13,390
to find out if that value exists yes

00:25:11,710 --> 00:25:15,220
it's a new language so it's going to be

00:25:13,390 --> 00:25:17,830
a little different and then you cash

00:25:15,220 --> 00:25:20,610
your results for whatever the value is

00:25:17,830 --> 00:25:22,480
and then you return the cash value

00:25:20,610 --> 00:25:25,240
speeds it up dramatically there's a

00:25:22,480 --> 00:25:27,309
couple of problems with the solution the

00:25:25,240 --> 00:25:29,890
first problem is when I first show this

00:25:27,309 --> 00:25:32,740
slide in Russells I forgot about those

00:25:29,890 --> 00:25:34,000
two so my cash wouldn't return there I

00:25:32,740 --> 00:25:35,320
value when you have to manually

00:25:34,000 --> 00:25:37,419
instrument a cash you're going to make

00:25:35,320 --> 00:25:40,059
mistakes I made a mistake I do this so

00:25:37,419 --> 00:25:42,010
many times throughout code and here I

00:25:40,059 --> 00:25:45,220
blew it in a very very simple function

00:25:42,010 --> 00:25:47,289
if you've got a function which is a much

00:25:45,220 --> 00:25:49,570
larger and you want to instrument the

00:25:47,289 --> 00:25:52,000
caching then this sort of thing is going

00:25:49,570 --> 00:25:54,730
to be harder to do it starts obfuscate

00:25:52,000 --> 00:25:56,169
the code a little bit or you can say you

00:25:54,730 --> 00:25:59,559
know I don't want to cash i'm going to

00:25:56,169 --> 00:26:03,820
rewrite this iteratively so then we

00:25:59,559 --> 00:26:05,950
track our previous trade oh n solution

00:26:03,820 --> 00:26:07,870
it's very fast the problem with that is

00:26:05,950 --> 00:26:11,049
now you've lost the mathematical beauty

00:26:07,870 --> 00:26:13,480
of what you had this is how we define

00:26:11,049 --> 00:26:17,470
the Fibonacci sequence mathematically

00:26:13,480 --> 00:26:19,030
and here's the Perl 6 code very clean

00:26:17,470 --> 00:26:22,690
very easy to read if

00:26:19,030 --> 00:26:25,240
you rewrite it like this can you

00:26:22,690 --> 00:26:26,770
guarantee instantly this is correct you

00:26:25,240 --> 00:26:28,300
got to do a desk tack you might want to

00:26:26,770 --> 00:26:31,960
write some tests whatever you're just

00:26:28,300 --> 00:26:33,400
not sure so this yeah that that's pretty

00:26:31,960 --> 00:26:35,200
clear you can see it matches correctly

00:26:33,400 --> 00:26:39,490
so let's just throw an is cast straight

00:26:35,200 --> 00:26:41,890
on there boom done common thing with

00:26:39,490 --> 00:26:43,120
perl 6 we know the sorts of problems you

00:26:41,890 --> 00:26:44,680
have all the time we're going to solve

00:26:43,120 --> 00:26:47,110
them for you you don't want to throw is

00:26:44,680 --> 00:26:49,720
cached on say a get customer method

00:26:47,110 --> 00:26:51,040
because you know there's all sorts of

00:26:49,720 --> 00:26:52,330
problems when you're returning volatile

00:26:51,040 --> 00:26:55,060
data it's certainly good when you have

00:26:52,330 --> 00:26:56,740
pure functions you give it a piece of

00:26:55,060 --> 00:26:58,270
data you return you expect the same

00:26:56,740 --> 00:27:00,460
piece of data every time you don't have

00:26:58,270 --> 00:27:01,570
side effects there's still some more

00:27:00,460 --> 00:27:03,250
work being done on this but this is part

00:27:01,570 --> 00:27:04,960
of the stuff being done with perl 6 just

00:27:03,250 --> 00:27:10,240
to make your life easier for the common

00:27:04,960 --> 00:27:11,590
problems that you face 25 minutes anyone

00:27:10,240 --> 00:27:19,750
have some questions before I move on to

00:27:11,590 --> 00:27:21,940
the next slide here there's not work

00:27:19,750 --> 00:27:24,070
being done on the is cash straight right

00:27:21,940 --> 00:27:26,170
now to add refinements for it or

00:27:24,070 --> 00:27:28,660
anything like that so that's just it

00:27:26,170 --> 00:27:29,620
that's there and once it's a better

00:27:28,660 --> 00:27:31,390
understanding of how it's going to be

00:27:29,620 --> 00:27:35,610
used there'll be refinements but it's

00:27:31,390 --> 00:27:41,070
just there any other questions ok so

00:27:35,610 --> 00:27:43,510
what the hell is that in the far future

00:27:41,070 --> 00:27:44,800
hundreds of years from now space

00:27:43,510 --> 00:27:46,630
stations aren't going to be those you

00:27:44,800 --> 00:27:48,820
know silly donuts that you're going to

00:27:46,630 --> 00:27:50,320
see in like you know 2001 space odyssey

00:27:48,820 --> 00:27:51,760
now you take an asteroid several

00:27:50,320 --> 00:27:53,140
kilometers long you put some robots on

00:27:51,760 --> 00:27:55,030
it the hollow at the asteroid sold the

00:27:53,140 --> 00:27:57,180
minerals then you seal it you spin it

00:27:55,030 --> 00:27:59,050
you fill it boom you got a space station

00:27:57,180 --> 00:28:00,610
that's what they'll look like in the

00:27:59,050 --> 00:28:01,900
future a little mock-up I did and the

00:28:00,610 --> 00:28:05,460
reason i point that out is i've been

00:28:01,900 --> 00:28:07,720
writing a text based MMORPG in Perl

00:28:05,460 --> 00:28:09,040
after this we'll have an unofficial Boff

00:28:07,720 --> 00:28:10,540
if anyone wants to come and talk to me

00:28:09,040 --> 00:28:16,180
about that boy was that a shameless plug

00:28:10,540 --> 00:28:19,530
or what and how do you get to a space

00:28:16,180 --> 00:28:22,990
station will you travel to it um this is

00:28:19,530 --> 00:28:24,730
almost the exact code I have in the game

00:28:22,990 --> 00:28:28,660
for this the character can travel to a

00:28:24,730 --> 00:28:30,160
location so if location area a room in

00:28:28,660 --> 00:28:32,950
the station and travels that location

00:28:30,160 --> 00:28:34,510
travel the area else if location is

00:28:32,950 --> 00:28:36,429
asian travel station location else

00:28:34,510 --> 00:28:38,380
implication is a stub you got this long

00:28:36,429 --> 00:28:42,010
if else if chain is not exactly the same

00:28:38,380 --> 00:28:44,889
in the code but this comment is verbatim

00:28:42,010 --> 00:28:46,539
from my code and then you have to

00:28:44,889 --> 00:28:47,590
remember to catch the condition where we

00:28:46,539 --> 00:28:49,240
don't know how to travel to a particular

00:28:47,590 --> 00:28:50,350
location there are other location types

00:28:49,240 --> 00:28:53,710
that are going to be added in the future

00:28:50,350 --> 00:28:55,269
I have to add this long if else if chain

00:28:53,710 --> 00:28:58,929
and read through it very carefully to

00:28:55,269 --> 00:29:00,159
make sure it's a pig it's ugly and I was

00:28:58,929 --> 00:29:01,240
thinking about how can i fix this thing

00:29:00,159 --> 00:29:03,880
one of the things i thought about doing

00:29:01,240 --> 00:29:06,789
is what if I slap a location trait on

00:29:03,880 --> 00:29:09,460
the locations I can travel to and then I

00:29:06,789 --> 00:29:11,590
can just say if location does location

00:29:09,460 --> 00:29:14,440
then location travel to character ooh

00:29:11,590 --> 00:29:16,029
that's ugly because now its object verb

00:29:14,440 --> 00:29:19,240
syntax instead of subject verb object

00:29:16,029 --> 00:29:20,320
and it's not as clear so you're reading

00:29:19,240 --> 00:29:22,000
that and there's like a mental speed

00:29:20,320 --> 00:29:26,230
bump so I could change the method name

00:29:22,000 --> 00:29:27,880
to look to buy character right now I got

00:29:26,230 --> 00:29:29,980
a verb with two prepositions on the end

00:29:27,880 --> 00:29:31,539
it's ugly it's a code smell and the

00:29:29,980 --> 00:29:33,880
reason the code smells there is because

00:29:31,539 --> 00:29:42,519
it really does hide an actual problem

00:29:33,880 --> 00:29:46,419
that re oh that should be self sorry

00:29:42,519 --> 00:29:50,590
thank you so another thing to fix on the

00:29:46,419 --> 00:29:51,519
slide so in this case I location

00:29:50,590 --> 00:29:53,769
shouldn't know about the characters

00:29:51,519 --> 00:29:55,299
traveling to them or through them i'm

00:29:53,769 --> 00:29:56,860
distributing the character knowledge too

00:29:55,299 --> 00:29:59,019
wide but characters do have to know

00:29:56,860 --> 00:30:00,669
about traveling so i don't want to have

00:29:59,019 --> 00:30:05,529
this reversal if I was just writing this

00:30:00,669 --> 00:30:08,049
in Perl 6 multi methods like so many

00:30:05,529 --> 00:30:09,760
other languages have multi-method travel

00:30:08,049 --> 00:30:11,799
to station area station area travel to

00:30:09,760 --> 00:30:13,269
station station I'd only have to write

00:30:11,799 --> 00:30:15,340
any code for the base case of not

00:30:13,269 --> 00:30:19,590
matching the location type which isn't

00:30:15,340 --> 00:30:23,230
there because it just handles it for me

00:30:19,590 --> 00:30:24,639
so once again using subs or methods

00:30:23,230 --> 00:30:26,860
passing data back and forth making sure

00:30:24,639 --> 00:30:28,870
that we're correctly an obvious use case

00:30:26,860 --> 00:30:32,590
that we use all the time is baked in the

00:30:28,870 --> 00:30:34,389
language and made simpler for you by the

00:30:32,590 --> 00:30:36,789
way this these are multi methods you can

00:30:34,389 --> 00:30:38,139
do this multisubs and because as a pearl

00:30:36,789 --> 00:30:39,100
and there is more than one way to do it

00:30:38,139 --> 00:30:42,639
here's another way to write the

00:30:39,100 --> 00:30:44,649
Fibonacci function multifit 0 multi-fit

00:30:42,639 --> 00:30:45,850
one multifit blah blah blah in case

00:30:44,649 --> 00:30:46,130
you're wondering what's going on here by

00:30:45,850 --> 00:30:48,470
the way

00:30:46,130 --> 00:30:51,440
so that's 0 and the one that's that's

00:30:48,470 --> 00:30:54,260
kind of neat stuff because there's type

00:30:51,440 --> 00:30:56,210
inference involved here when you call

00:30:54,260 --> 00:30:58,190
fib with some value it's going to check

00:30:56,210 --> 00:31:00,500
to see what the value type is and it's

00:30:58,190 --> 00:31:03,170
going to see that 0 is of type int and

00:31:00,500 --> 00:31:05,030
its value is 0 so I get int and I

00:31:03,170 --> 00:31:06,680
imagine or a subclass of int that you're

00:31:05,030 --> 00:31:08,120
passing into this it could infer the

00:31:06,680 --> 00:31:13,840
type that you're dealing with and allow

00:31:08,120 --> 00:31:13,840
you to call the correct multisub yes

00:31:16,240 --> 00:31:20,570
it's going to throw an exception saying

00:31:18,110 --> 00:31:23,960
there's not a target to call like if you

00:31:20,570 --> 00:31:26,030
had negative 3 I don't know the exact

00:31:23,960 --> 00:31:28,670
syntax of what the exception is off hand

00:31:26,030 --> 00:31:30,020
for that oh it's so here's that the

00:31:28,670 --> 00:31:31,820
question was what if you call it without

00:31:30,020 --> 00:31:34,150
the you know while without something

00:31:31,820 --> 00:31:41,780
which matches one of the arguments yes

00:31:34,150 --> 00:31:45,740
was there something else well yeah you

00:31:41,780 --> 00:31:46,730
can define multi fib any or there's a

00:31:45,740 --> 00:31:53,180
number of ways you can handle that I

00:31:46,730 --> 00:31:54,620
would imagine hmm asterisk yeah so

00:31:53,180 --> 00:32:00,610
there's a number of ways you can handle

00:31:54,620 --> 00:32:00,610
that case I'm sorry

00:32:03,270 --> 00:32:09,730
uh oh yes you're right oops another bug

00:32:08,050 --> 00:32:18,790
I have to fix up my slides that's very

00:32:09,730 --> 00:32:20,200
embarrassing yes oops okay actually

00:32:18,790 --> 00:32:21,970
where we have the where star greater

00:32:20,200 --> 00:32:34,870
than one isn't that going to say one is

00:32:21,970 --> 00:32:39,970
an int yep not in this case okay yes but

00:32:34,870 --> 00:32:41,620
it's so the end is okay fair enough so

00:32:39,970 --> 00:32:44,880
possibly i've got this mistake

00:32:41,620 --> 00:32:46,960
replicated on another slide later so

00:32:44,880 --> 00:32:48,430
that's talking about passing data into

00:32:46,960 --> 00:32:50,500
functions thank you for those questions

00:32:48,430 --> 00:32:52,990
by the way so passing data back from

00:32:50,500 --> 00:32:56,050
functions so here we can assert a return

00:32:52,990 --> 00:32:58,540
type of bull and we retire try to return

00:32:56,050 --> 00:33:00,370
a string say yes if you and we're going

00:32:58,540 --> 00:33:03,100
to type check failed for return value

00:33:00,370 --> 00:33:04,660
expected bull but got string so now it's

00:33:03,100 --> 00:33:06,190
an easy way to make sure not only are we

00:33:04,660 --> 00:33:09,720
accepting the correct data we are

00:33:06,190 --> 00:33:13,270
emitting the correct data and in this

00:33:09,720 --> 00:33:16,960
example it looks kind of trivial what is

00:33:13,270 --> 00:33:18,310
some other funk for turn you might go

00:33:16,960 --> 00:33:20,080
out there to check some other funk and

00:33:18,310 --> 00:33:22,120
verify that it does in fact only return

00:33:20,080 --> 00:33:24,730
boolean values but then some programmer

00:33:22,120 --> 00:33:27,610
decides to update it so sometimes it

00:33:24,730 --> 00:33:29,740
returns a string error message this will

00:33:27,610 --> 00:33:31,330
properly die rather than have bad data

00:33:29,740 --> 00:33:33,250
propagating all throughout your code and

00:33:31,330 --> 00:33:37,750
you'll catch it close to the source of

00:33:33,250 --> 00:33:39,430
error very simple very quick and of

00:33:37,750 --> 00:33:40,660
course you can use subsets there so you

00:33:39,430 --> 00:33:42,220
wanted to find your own types on the fly

00:33:40,660 --> 00:33:44,050
just say we're going to assert that it

00:33:42,220 --> 00:33:45,730
returns a non-negative integer and you

00:33:44,050 --> 00:33:48,870
know that it will return however you

00:33:45,730 --> 00:33:48,870
have to find non-negative integer

00:33:54,090 --> 00:33:59,010
I didn't choose the terminology on that

00:33:56,620 --> 00:33:59,010
it's just

00:34:19,789 --> 00:34:36,809
okay so that talks I'm sorry yes go

00:34:27,179 --> 00:34:38,399
ahead I would imagine not because like

00:34:36,809 --> 00:34:42,809
your Java and other languages generally

00:34:38,399 --> 00:34:44,879
don't allow that so it's I don't think

00:34:42,809 --> 00:34:49,049
it's possible to really enforce that is

00:34:44,879 --> 00:34:50,970
it okay yeah so all the question was you

00:34:49,049 --> 00:34:54,419
know are there like multisubs on return

00:34:50,970 --> 00:35:05,970
types and it that's almost impossible to

00:34:54,419 --> 00:35:07,259
verify yes watch no okay so that

00:35:05,970 --> 00:35:09,720
explains some of the basic stuffs about

00:35:07,259 --> 00:35:12,180
subs about passing data into them

00:35:09,720 --> 00:35:13,410
passing data back out of them making you

00:35:12,180 --> 00:35:14,940
know showing you some of the things

00:35:13,410 --> 00:35:16,019
about you know how subsets work you can

00:35:14,940 --> 00:35:20,099
define your own types on the fly very

00:35:16,019 --> 00:35:22,769
easily this is this isn't really how

00:35:20,099 --> 00:35:27,089
classes work exactly in Perl 6 is just a

00:35:22,769 --> 00:35:29,549
small subset of class behavior just to

00:35:27,089 --> 00:35:32,460
show you about some of the power of what

00:35:29,549 --> 00:35:36,509
we've seen so far so here's a very small

00:35:32,460 --> 00:35:38,119
point class in Perl 6 so point X point

00:35:36,509 --> 00:35:40,769
why whatever you've seen these before

00:35:38,119 --> 00:35:42,720
they're sometimes controversial examples

00:35:40,769 --> 00:35:44,670
but this isn't a class on you know

00:35:42,720 --> 00:35:46,140
proper oo programming it's just to show

00:35:44,670 --> 00:35:50,519
you some of the power of what's involved

00:35:46,140 --> 00:35:53,250
here class point has dollar dot x equals

00:35:50,519 --> 00:35:55,799
zero dollar dot y equals zero so the

00:35:53,250 --> 00:35:58,500
secondary punctuation mark the dot is

00:35:55,799 --> 00:36:01,289
called at wiggle and in this case this

00:35:58,500 --> 00:36:03,660
particular twiddled the dot is for just

00:36:01,289 --> 00:36:05,460
think of it you know for objects this

00:36:03,660 --> 00:36:09,990
tells you this is an attribute of the

00:36:05,460 --> 00:36:11,400
point class now this is just kinda like

00:36:09,990 --> 00:36:13,109
moose if your artery familiar with moose

00:36:11,400 --> 00:36:15,420
you know how attributes work except now

00:36:13,109 --> 00:36:19,250
you know they're built in first class

00:36:15,420 --> 00:36:24,000
the equals 0 does not get evaluated

00:36:19,250 --> 00:36:26,700
unless you don't pass in that value to

00:36:24,000 --> 00:36:28,559
the constructor so the equals 0 that's

00:36:26,700 --> 00:36:30,630
saying that's the default value if

00:36:28,559 --> 00:36:32,189
didn't pass anything in so I believe

00:36:30,630 --> 00:36:34,469
that also generates basically a closure

00:36:32,189 --> 00:36:35,849
on the fly which won't be it generates a

00:36:34,469 --> 00:36:37,650
closure which won't be executed unless

00:36:35,849 --> 00:36:41,009
there is no value provided for that

00:36:37,650 --> 00:36:42,269
attribute so just think of it that way

00:36:41,009 --> 00:36:44,219
whatever is on the other side won't be

00:36:42,269 --> 00:36:45,660
evaluated unless there's no value so

00:36:44,219 --> 00:36:49,859
that's how you provide default values

00:36:45,660 --> 00:36:52,469
for attributes string overloading you

00:36:49,859 --> 00:36:54,269
just uppercase s and then TR that's how

00:36:52,469 --> 00:36:59,249
you do string overloading in Perl 6

00:36:54,269 --> 00:37:02,880
that's really easy and then we can have

00:36:59,249 --> 00:37:06,749
my point equals point new X is 5 y is 3

00:37:02,880 --> 00:37:08,069
say point x5 say point y 3 and then we

00:37:06,749 --> 00:37:10,140
take advantage of our string overloading

00:37:08,069 --> 00:37:11,640
you can put a tilde in front if you want

00:37:10,140 --> 00:37:13,410
I thought quoting in strings was cleaner

00:37:11,640 --> 00:37:16,140
and then we can see the point is 53

00:37:13,410 --> 00:37:17,939
exactly what we expect not the most

00:37:16,140 --> 00:37:19,589
useful class but it shows you some of

00:37:17,939 --> 00:37:23,789
what you can do some of the basic syntax

00:37:19,589 --> 00:37:29,160
of pearl sex but this is an immutable

00:37:23,789 --> 00:37:30,359
object pro sex works very hard to make a

00:37:29,160 --> 00:37:34,949
lot of things immutable because there's

00:37:30,359 --> 00:37:36,390
a lot of benefits of immutability but we

00:37:34,949 --> 00:37:38,130
want to change our x and y in this

00:37:36,390 --> 00:37:39,599
example this is where it gets a little

00:37:38,130 --> 00:37:43,199
bit more complicated because this is a

00:37:39,599 --> 00:37:45,839
new language so the colon at the front

00:37:43,199 --> 00:37:49,259
of the variable basically that's a named

00:37:45,839 --> 00:37:50,549
attribute and then the equals is the

00:37:49,259 --> 00:37:53,910
same thing as this is the default value

00:37:50,549 --> 00:37:55,319
so we can set dollar X and if we don't

00:37:53,910 --> 00:37:58,650
set it the default is going to be the

00:37:55,319 --> 00:38:00,209
current value of dollar X and the same

00:37:58,650 --> 00:38:02,849
thing for y so both of these are

00:38:00,209 --> 00:38:05,459
optional this is how you can set the x

00:38:02,849 --> 00:38:08,099
and the y property for the point and the

00:38:05,459 --> 00:38:11,429
baying what's a bang twiddle this is the

00:38:08,099 --> 00:38:15,839
internal version of the attribute saying

00:38:11,429 --> 00:38:17,999
okay this by default is read-only this

00:38:15,839 --> 00:38:21,059
is read right so now i can assign dollar

00:38:17,999 --> 00:38:22,979
extra dollar baying x and that will

00:38:21,059 --> 00:38:24,839
change the dollar dot variable so the

00:38:22,979 --> 00:38:27,929
baying think of that as danger will

00:38:24,839 --> 00:38:29,670
robinson danger changing the state of an

00:38:27,929 --> 00:38:31,529
object can be somewhat problematic at

00:38:29,670 --> 00:38:33,599
times very dangerous thing all sorts of

00:38:31,529 --> 00:38:35,699
bugs involved there but this is you know

00:38:33,599 --> 00:38:37,170
it's the code looks a little funky if

00:38:35,699 --> 00:38:39,089
you're not used to Perl 6 at first but

00:38:37,170 --> 00:38:40,799
it's pretty easy to pick up and then you

00:38:39,089 --> 00:38:42,380
know here you know my point eels point

00:38:40,799 --> 00:38:45,380
new blah you know we've seen that

00:38:42,380 --> 00:38:48,710
point set Y 17 and then we can see that

00:38:45,380 --> 00:39:00,070
our point is 517 so the public interface

00:38:48,710 --> 00:39:00,070
is very simple yes I've never seen that

00:39:01,720 --> 00:39:13,370
okay Thank You Patrick so oh yes yeah

00:39:11,240 --> 00:39:16,190
the question and that was you know if we

00:39:13,370 --> 00:39:17,630
had the dollar bang X up there you know

00:39:16,190 --> 00:39:18,830
would that make it rideable that's not

00:39:17,630 --> 00:39:21,320
how you make it rideable you'll see that

00:39:18,830 --> 00:39:23,090
in a moment the dollar the dot is what

00:39:21,320 --> 00:39:25,850
makes it public the Bang is what is

00:39:23,090 --> 00:39:29,030
private so this is the private version

00:39:25,850 --> 00:39:30,920
of the public attribute but the private

00:39:29,030 --> 00:39:32,900
version is mutable you can do anything

00:39:30,920 --> 00:39:34,670
inside your class with the data that you

00:39:32,900 --> 00:39:39,380
want to that answer your question I

00:39:34,670 --> 00:39:42,370
assume okay but we have a serious

00:39:39,380 --> 00:39:44,690
problem with this I can set y tu fou and

00:39:42,370 --> 00:39:46,790
there's nothing to stop that in fact you

00:39:44,690 --> 00:39:48,110
know a lot of old-style Perl code you

00:39:46,790 --> 00:39:49,390
know that would be a common type of bug

00:39:48,110 --> 00:39:51,290
because we're only doing type

00:39:49,390 --> 00:39:53,180
constraints or you know type checking

00:39:51,290 --> 00:39:56,000
very much so here we're just going to

00:39:53,180 --> 00:39:58,640
say foods got to be a rat a rational

00:39:56,000 --> 00:40:00,410
number and if we try and set Y 2 or x

00:39:58,640 --> 00:40:02,420
and y half your rational number so if we

00:40:00,410 --> 00:40:07,790
try and set y tu fou it's going to blow

00:40:02,420 --> 00:40:08,960
up so once again gradual typing makes

00:40:07,790 --> 00:40:10,640
our code a little bit easier to work

00:40:08,960 --> 00:40:12,910
with a little bit safer to work with and

00:40:10,640 --> 00:40:15,140
it's it's actually pretty easy to read

00:40:12,910 --> 00:40:18,320
but now there's something different here

00:40:15,140 --> 00:40:21,020
so in Java they learned a long time ago

00:40:18,320 --> 00:40:22,850
don't make your attributes public

00:40:21,020 --> 00:40:25,250
because people are going to find a way

00:40:22,850 --> 00:40:27,650
to screw it up no matter what you do so

00:40:25,250 --> 00:40:30,770
you have your IDEs with try all sorts of

00:40:27,650 --> 00:40:32,030
getters and setters for you but you can

00:40:30,770 --> 00:40:33,710
make your attributes Republican in this

00:40:32,030 --> 00:40:36,140
case if we think of x and y is being

00:40:33,710 --> 00:40:38,000
anything allowed so long as it's a

00:40:36,140 --> 00:40:41,540
rational number we don't need our set

00:40:38,000 --> 00:40:44,900
method anymore so we're going to declare

00:40:41,540 --> 00:40:51,200
them as read write and now you can say

00:40:44,900 --> 00:40:54,020
point x equals 17.3 and it works so now

00:40:51,200 --> 00:40:56,290
we've exposed our attribute in this

00:40:54,020 --> 00:40:58,850
simple case that's not really dangerous

00:40:56,290 --> 00:41:00,320
and you can't set it to dolt you can't

00:40:58,850 --> 00:41:02,810
send to the string foo or something else

00:41:00,320 --> 00:41:03,830
so we've exposed our attribute but you

00:41:02,810 --> 00:41:06,980
know possibly is a little bit dangerous

00:41:03,830 --> 00:41:09,440
if for example x and y we r restricted

00:41:06,980 --> 00:41:11,750
to negative 10 to 10 on the cartesian

00:41:09,440 --> 00:41:13,280
plane then we're saying oh well we can't

00:41:11,750 --> 00:41:19,090
do this because now we have no way to

00:41:13,280 --> 00:41:19,090
validate it well we have empty slides

00:41:22,090 --> 00:41:36,830
well so what that is fascinating what

00:41:34,940 --> 00:41:38,420
happened there okay we're going to get

00:41:36,830 --> 00:41:40,010
back somehow this inserter to hold them

00:41:38,420 --> 00:41:45,170
to empty slides in my talk just to make

00:41:40,010 --> 00:41:48,290
me look really really stupid okay there

00:41:45,170 --> 00:41:49,460
we go we're back so I lost my timing

00:41:48,290 --> 00:41:52,370
because of that how much time to ten

00:41:49,460 --> 00:41:54,800
minutes thank you so now we just declare

00:41:52,370 --> 00:41:56,390
a subset point limit of rat where you

00:41:54,800 --> 00:41:57,860
know negative 10 is less than equal to

00:41:56,390 --> 00:41:59,690
whatever you got less than equal to 10

00:41:57,860 --> 00:42:02,900
and then declare those as point limits

00:41:59,690 --> 00:42:06,110
and now if we try and set this to 17.3

00:42:02,900 --> 00:42:08,060
boom we have publicly exposed our

00:42:06,110 --> 00:42:12,200
attributes but we have tight constraints

00:42:08,060 --> 00:42:17,630
on them very easy to define and it's not

00:42:12,200 --> 00:42:20,000
difficult it's simple but you know we

00:42:17,630 --> 00:42:22,850
why are they you know defaulting to zero

00:42:20,000 --> 00:42:23,990
having a 0 comma 0 is kind of silly so

00:42:22,850 --> 00:42:26,570
maybe we want to make them required

00:42:23,990 --> 00:42:28,820
attributes so you just say equals die

00:42:26,570 --> 00:42:30,560
dollar X is required dollar dot y is

00:42:28,820 --> 00:42:33,290
required and we fail to pass in into

00:42:30,560 --> 00:42:36,340
constructor it blows up for us so it's

00:42:33,290 --> 00:42:39,310
easy to make them required if we want to

00:42:36,340 --> 00:42:42,620
but you know I want to go even further

00:42:39,310 --> 00:42:45,140
you know I can well for one thing i can

00:42:42,620 --> 00:42:47,900
simplify this subset declaration up

00:42:45,140 --> 00:42:49,580
there I can use the range operator where

00:42:47,900 --> 00:42:51,380
negative 10 to 10 and this being pearl

00:42:49,580 --> 00:42:54,980
it pretty much figures out what you mean

00:42:51,380 --> 00:42:56,690
and we're running low on time so I'm

00:42:54,980 --> 00:42:58,790
going to skip some of those examples but

00:42:56,690 --> 00:43:01,370
here I'm going to get rid of the string

00:42:58,790 --> 00:43:03,410
overloading and we'll just call the pro

00:43:01,370 --> 00:43:05,450
method which is built in so now point

00:43:03,410 --> 00:43:06,590
new so in this case the serialization is

00:43:05,450 --> 00:43:09,830
going to show you how to recreate the

00:43:06,590 --> 00:43:10,140
object not always guaranteed depending

00:43:09,830 --> 00:43:11,640
upon

00:43:10,140 --> 00:43:14,519
the objects defined but it's pretty

00:43:11,640 --> 00:43:17,420
simple now let's stop and think about

00:43:14,519 --> 00:43:20,579
what we have here for just a moment

00:43:17,420 --> 00:43:25,079
subset point limit where where whatever

00:43:20,579 --> 00:43:26,910
it is is negative 10 to 10 we have the

00:43:25,079 --> 00:43:30,029
point limit of X this so both of these

00:43:26,910 --> 00:43:32,970
are mutable their required values now we

00:43:30,029 --> 00:43:37,589
can't instantiate an incorrect object we

00:43:32,970 --> 00:43:40,519
cannot set it to an invalid state does

00:43:37,589 --> 00:43:43,940
this look like rocket science to anyone

00:43:40,519 --> 00:43:51,660
it's easy to read it's very expressive

00:43:43,940 --> 00:43:53,730
Norman that was a case where earlier I'd

00:43:51,660 --> 00:43:56,609
verified this on the mailing list where

00:43:53,730 --> 00:43:58,500
because I have the negative 10 0 to 10 0

00:43:56,609 --> 00:44:06,930
it's going to figure out that it's a rat

00:43:58,500 --> 00:44:15,089
and I tested that so I can pass a float

00:44:06,930 --> 00:44:16,650
in there also ok ok because i thought i

00:44:15,089 --> 00:44:17,880
had tested that earlier but that was

00:44:16,650 --> 00:44:21,059
several months ago maybe there's

00:44:17,880 --> 00:44:26,670
something maybe something has changed in

00:44:21,059 --> 00:44:28,230
my memory so let's go ahead though and

00:44:26,670 --> 00:44:30,359
we see what this is we see how

00:44:28,230 --> 00:44:32,039
expressive it is we see how i don't

00:44:30,359 --> 00:44:36,180
quite have the time please ask me

00:44:32,039 --> 00:44:38,880
afterwards sorry about that this is how

00:44:36,180 --> 00:44:40,500
that would look in corporal 5 that was

00:44:38,880 --> 00:44:43,440
my attempt to replicate the behavior

00:44:40,500 --> 00:44:45,359
exactly in corporal five and not take

00:44:43,440 --> 00:44:47,430
the sort of shortcuts that we tend to do

00:44:45,359 --> 00:44:49,319
there is no need to take the shortcut

00:44:47,430 --> 00:44:51,539
over here a lot i need to take shortcuts

00:44:49,319 --> 00:44:53,220
over there so we tend to take them we

00:44:51,539 --> 00:44:54,960
don't write our pearl 5 out this way but

00:44:53,220 --> 00:44:58,980
we're modern pearl programmer so we use

00:44:54,960 --> 00:45:06,059
mousse which is still a fair chunk

00:44:58,980 --> 00:45:07,950
longer or their c++ there's java there's

00:45:06,059 --> 00:45:10,430
python 3 where we have to define a class

00:45:07,950 --> 00:45:13,079
to declare our point limit on that

00:45:10,430 --> 00:45:15,569
there's javascript again more or less

00:45:13,079 --> 00:45:17,640
the same thing Ruby my favorite example

00:45:15,569 --> 00:45:20,069
go I had to shrink the font down in

00:45:17,640 --> 00:45:22,589
order to get to fit on the slide because

00:45:20,069 --> 00:45:23,750
goes pretty darned verbose maybe a great

00:45:22,589 --> 00:45:27,300
language

00:45:23,750 --> 00:45:29,970
that is the power and expressivity you

00:45:27,300 --> 00:45:43,530
get out of pearl sex and it was easy it

00:45:29,970 --> 00:45:46,700
was not difficult stuff so yes I will

00:45:43,530 --> 00:45:50,880
touch on just a second so that's a

00:45:46,700 --> 00:45:52,140
equals is the default value dollar X if

00:45:50,880 --> 00:45:55,110
we don't have a value assigned to it

00:45:52,140 --> 00:45:57,150
then it will be equal to this value on

00:45:55,110 --> 00:45:58,650
the other side but i'll actually touch

00:45:57,150 --> 00:46:01,460
on that in a second so for day-to-day

00:45:58,650 --> 00:46:04,200
code perl 6 is more correct than / 05 it

00:46:01,460 --> 00:46:07,380
is safer than pearl fact it's easier

00:46:04,200 --> 00:46:08,790
than / 05 and by the way up my which

00:46:07,380 --> 00:46:10,440
list I want to get rid of that equals

00:46:08,790 --> 00:46:12,150
died and i would love to have an is

00:46:10,440 --> 00:46:14,280
required that's actually very simple to

00:46:12,150 --> 00:46:15,900
implement inside of pearl six I believe

00:46:14,280 --> 00:46:17,250
there's been some discussion possibly

00:46:15,900 --> 00:46:19,320
well if the error message should be I

00:46:17,250 --> 00:46:20,820
don't know why it's not there I would

00:46:19,320 --> 00:46:23,430
like to see that that would be very very

00:46:20,820 --> 00:46:28,290
Andy make this code even more expressive

00:46:23,430 --> 00:46:30,720
I think so what we have with pearl sex

00:46:28,290 --> 00:46:32,580
we have math you saw its beginning math

00:46:30,720 --> 00:46:34,470
that pretty much works does what you

00:46:32,580 --> 00:46:37,020
expected to do as a human not as a

00:46:34,470 --> 00:46:40,050
computer you have function signatures

00:46:37,020 --> 00:46:42,750
they're rich they're powerful and it's

00:46:40,050 --> 00:46:44,310
about time you saw the subsets where

00:46:42,750 --> 00:46:46,020
it's very easy to declare your own types

00:46:44,310 --> 00:46:48,270
on the fly and the syntax is not

00:46:46,020 --> 00:46:50,660
complicated and we have proper classes

00:46:48,270 --> 00:46:53,310
but I only touch them that for a bit so

00:46:50,660 --> 00:46:57,510
we know that pearl sex is a large

00:46:53,310 --> 00:46:59,160
language so is pearl five so is c plus

00:46:57,510 --> 00:47:01,440
plus one of the most popular languages

00:46:59,160 --> 00:47:02,730
in the world but the common features

00:47:01,440 --> 00:47:06,050
that we need the sort of problems that

00:47:02,730 --> 00:47:08,010
we have these are baked in to Perl 6

00:47:06,050 --> 00:47:08,760
they paid a lot of tension to saying

00:47:08,010 --> 00:47:11,369
this is what you're doing on a

00:47:08,760 --> 00:47:14,490
day-to-day basis and making sure that

00:47:11,369 --> 00:47:16,290
it's actually solved for us you have the

00:47:14,490 --> 00:47:17,970
proper oil it's easy to read and like

00:47:16,290 --> 00:47:19,260
that it's a lot safer it's a very

00:47:17,970 --> 00:47:22,160
powerful language if you want to learn

00:47:19,260 --> 00:47:26,190
more about it you can check out pearl

00:47:22,160 --> 00:47:28,380
6069 org design / 06 org learn learn x

00:47:26,190 --> 00:47:31,410
and y minus com docs perl 6 that's tons

00:47:28,380 --> 00:47:33,410
of Perl 6 written out from very simple

00:47:31,410 --> 00:47:37,230
stuff down to more and more complicated

00:47:33,410 --> 00:47:40,080
and got a free node and just hit the

00:47:37,230 --> 00:47:42,000
pound Perl 6 channel I thought they were

00:47:40,080 --> 00:47:44,130
going to be annoyed with me with how

00:47:42,000 --> 00:47:45,990
many questions I was hitting them with

00:47:44,130 --> 00:47:47,220
and no they were great there were more

00:47:45,990 --> 00:47:49,280
than happy to answer all of my questions

00:47:47,220 --> 00:47:52,220
in depth I was very pleased with that

00:47:49,280 --> 00:47:55,710
buy my books

00:47:52,220 --> 00:47:58,380
and so I want to say thank you I have

00:47:55,710 --> 00:48:00,270
bonus slides unfortunately I don't have

00:47:58,380 --> 00:48:01,950
time for the bonus slides I usually

00:48:00,270 --> 00:48:03,300
offer people a choice I apologize about

00:48:01,950 --> 00:48:06,500
that but we might have time for a couple

00:48:03,300 --> 00:48:06,500
questions or two yes

00:48:15,240 --> 00:48:20,390
yes yes that should be trivial just like

00:48:18,270 --> 00:48:22,800
what you do it like plenty blacklist and

00:48:20,390 --> 00:48:26,369
what would it evaluate that on the fly

00:48:22,800 --> 00:48:28,440
afterwards so basically he's asking can

00:48:26,369 --> 00:48:30,150
you pass a subroutine in for the default

00:48:28,440 --> 00:48:33,030
value so you can calculate something a

00:48:30,150 --> 00:48:48,960
little bit more this answer yes yes he

00:48:33,030 --> 00:48:51,150
said so anything else yes so I don't

00:48:48,960 --> 00:48:52,710
believe the the subsets are as int

00:48:51,150 --> 00:48:54,030
respectable as I would like them to be I

00:48:52,710 --> 00:48:57,510
think you can get the body back of the

00:48:54,030 --> 00:48:59,369
code block but because this is you know

00:48:57,510 --> 00:49:01,470
you can bed a whole bunch of stuff in

00:48:59,369 --> 00:49:02,880
there it would be you'd be getting perl

00:49:01,470 --> 00:49:05,580
6 code back and you would have to read

00:49:02,880 --> 00:49:08,460
the Perl 6 code anything more than that

00:49:05,580 --> 00:49:09,600
I couldn't say sorry I don't have a

00:49:08,460 --> 00:49:11,700
better answer for you so I don't know

00:49:09,600 --> 00:49:20,210
how int respectable that is to

00:49:11,700 --> 00:49:20,210
constraint yes yes

00:49:32,059 --> 00:49:35,930
can you repeat that question because I

00:49:34,459 --> 00:49:43,509
don't know exactly what you asked my

00:49:35,930 --> 00:49:43,509
apologies yes

00:49:49,170 --> 00:49:54,610
what do you mean up it will so I amount

00:49:52,090 --> 00:49:56,650
of time it will blow up if that violates

00:49:54,610 --> 00:49:58,420
the constraint the whatever the

00:49:56,650 --> 00:50:06,300
constraint is for the non-negative int

00:49:58,420 --> 00:50:06,300

YouTube URL: https://www.youtube.com/watch?v=S0OGsFmPW2M


