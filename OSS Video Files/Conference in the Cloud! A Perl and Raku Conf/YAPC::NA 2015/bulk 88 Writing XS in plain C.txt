Title: bulk 88 Writing XS in plain C
Publication date: 2015-06-16
Playlist: YAPC::NA 2015
Description: 
	
Captions: 
	00:00:00,530 --> 00:00:05,700
welcome to writing excess in plane see I

00:00:04,049 --> 00:00:07,890
have to give credits for this talked to

00:00:05,700 --> 00:00:10,290
Stefan moolah who came up with the

00:00:07,890 --> 00:00:13,080
concept of this style of teaching of

00:00:10,290 --> 00:00:15,900
excess code the code samples that are in

00:00:13,080 --> 00:00:18,600
this talk are on github in a special

00:00:15,900 --> 00:00:20,640
branch I push today again i have to give

00:00:18,600 --> 00:00:22,680
thanks to Stefan Mueller because he

00:00:20,640 --> 00:00:25,560
invented this style of lecturing of

00:00:22,680 --> 00:00:29,100
explaining how excess works my name is

00:00:25,560 --> 00:00:31,160
bulk 88 I have a pause ID and I'm mostly

00:00:29,100 --> 00:00:35,160
seen in the pro community on the p5p

00:00:31,160 --> 00:00:37,590
mailing list and I mostly use pearl on

00:00:35,160 --> 00:00:41,370
Windows and I do a lot of pearl windows

00:00:37,590 --> 00:00:45,000
and see coding and general pearl and see

00:00:41,370 --> 00:00:48,570
coating the Perl interpreter is read it

00:00:45,000 --> 00:00:51,239
written in C 89 it is a large pile of

00:00:48,570 --> 00:00:52,950
machine code and it is memory unsafe but

00:00:51,239 --> 00:00:57,329
the Perl interpreter is not written in

00:00:52,950 --> 00:00:59,610
Java there are basically two ways to

00:00:57,329 --> 00:01:02,879
escape the pearl language sandbox you

00:00:59,610 --> 00:01:05,519
can use X subs or you can manipulate the

00:01:02,879 --> 00:01:07,799
OP tree and use keywords X subs can be

00:01:05,519 --> 00:01:09,450
monkey patched keywords are permanent

00:01:07,799 --> 00:01:12,780
there's no monkey patching of keywords

00:01:09,450 --> 00:01:14,760
in the pearl language also perlas kind

00:01:12,780 --> 00:01:18,450
of fat so sometimes you have to use c4

00:01:14,760 --> 00:01:22,140
speed and performance reasons um the

00:01:18,450 --> 00:01:24,750
mode access code is generally converted

00:01:22,140 --> 00:01:28,530
to c code by a program called X sub P P

00:01:24,750 --> 00:01:32,850
and it was introduced in Perl 5 alpha 4

00:01:28,530 --> 00:01:35,250
back in nineteen ninety three X sub P P

00:01:32,850 --> 00:01:40,159
is a descendant of a tool called mas

00:01:35,250 --> 00:01:42,810
which was introduced in Perl 3 in 1990

00:01:40,159 --> 00:01:47,159
must was originally created to allow

00:01:42,810 --> 00:01:52,140
curses to work in Perl three I guess I

00:01:47,159 --> 00:01:54,840
was barely alive then so to understand

00:01:52,140 --> 00:01:57,329
why excess is so hard to program or use

00:01:54,840 --> 00:02:01,110
you have to understand that excess was

00:01:57,329 --> 00:02:05,040
written in kif in the era of k and r c

00:02:01,110 --> 00:02:07,590
not c89 but k and r because c89 was one

00:02:05,040 --> 00:02:12,809
year old when excess was the predecessor

00:02:07,590 --> 00:02:14,040
to excess was invented also excess is

00:02:12,809 --> 00:02:20,099
generally considered to be

00:02:14,040 --> 00:02:21,450
macro soup the pros of using excess is

00:02:20,099 --> 00:02:23,790
you have actual source code

00:02:21,450 --> 00:02:26,250
compatibility and you're not using

00:02:23,790 --> 00:02:28,650
undocumented calls for everything also

00:02:26,250 --> 00:02:30,959
the macros can be upgraded internally

00:02:28,650 --> 00:02:32,489
without breaking your code and pretty

00:02:30,959 --> 00:02:35,519
much everything I tell you today is

00:02:32,489 --> 00:02:37,590
undocumented api's so don't cry 2 p-5 p

00:02:35,519 --> 00:02:40,769
if i if your code breaks because you use

00:02:37,590 --> 00:02:42,810
the pile of undocumented api's and also

00:02:40,769 --> 00:02:45,269
all the code samples only run on 522

00:02:42,810 --> 00:02:49,769
because again there is no compatibility

00:02:45,269 --> 00:02:51,870
if you skip the official public API how

00:02:49,769 --> 00:02:54,930
to make X subs appear in the pearl

00:02:51,870 --> 00:02:58,919
language the main tool used this excess

00:02:54,930 --> 00:03:01,470
loader or dyna loader and your p.m. file

00:02:58,919 --> 00:03:04,200
calls excess loader excess loader calls

00:03:01,470 --> 00:03:06,750
do load file the yellow stuff is C code

00:03:04,200 --> 00:03:10,769
and the blue lot of the blue boxes are

00:03:06,750 --> 00:03:12,689
pure Pearl sub calls you have to first

00:03:10,769 --> 00:03:16,019
load a shared library into the Pearl

00:03:12,689 --> 00:03:18,120
process excess loader then we'll take

00:03:16,019 --> 00:03:21,030
your package name prefix boot and

00:03:18,120 --> 00:03:23,940
replace the colons with underscores that

00:03:21,030 --> 00:03:26,040
then calls DL find symbol and dl find

00:03:23,940 --> 00:03:27,959
symbol goes and asks the OS shared

00:03:26,040 --> 00:03:30,090
library loader please give me the c

00:03:27,959 --> 00:03:33,349
function pointer for this particular

00:03:30,090 --> 00:03:35,400
symbol name and this is the only a

00:03:33,349 --> 00:03:37,949
function that needs to actually be

00:03:35,400 --> 00:03:43,019
extern or publicly available in your

00:03:37,949 --> 00:03:44,760
shared library up then XS loader takes

00:03:43,019 --> 00:03:48,269
the c function pointer that the OS

00:03:44,760 --> 00:03:50,220
returned and it calls dl install X sub

00:03:48,269 --> 00:03:52,260
this actually connects the c function

00:03:50,220 --> 00:03:54,030
pointer into the pearl language and

00:03:52,260 --> 00:03:56,250
makes it connectable and creates a type

00:03:54,030 --> 00:03:59,609
glob with a subroutine inside that you

00:03:56,250 --> 00:04:02,699
can now call from the pearl engine once

00:03:59,609 --> 00:04:04,799
this bootstrap sub is created in the

00:04:02,699 --> 00:04:07,260
pearl language it gets dispatched is the

00:04:04,799 --> 00:04:09,780
first time you get control in Perl in

00:04:07,260 --> 00:04:13,379
the C language normally the boot funked

00:04:09,780 --> 00:04:16,470
of the boot x subs generally call new xs

00:04:13,379 --> 00:04:17,970
and register all additional X subs in

00:04:16,470 --> 00:04:19,919
the process that your module will be

00:04:17,970 --> 00:04:21,900
using because there's only there's one

00:04:19,919 --> 00:04:25,169
central X sub that registers everything

00:04:21,900 --> 00:04:27,900
else traditionally after you've

00:04:25,169 --> 00:04:29,639
registered all your additional X subs X

00:04:27,900 --> 00:04:32,970
lauder pretty much exits and immediately

00:04:29,639 --> 00:04:35,580
returns control to your p.m. file every

00:04:32,970 --> 00:04:38,160
single pearl X sub follows the following

00:04:35,580 --> 00:04:41,520
sea prototype all X sub function

00:04:38,160 --> 00:04:43,889
pointers must have this prototype i will

00:04:41,520 --> 00:04:46,289
be using a one or two macros in this

00:04:43,889 --> 00:04:49,530
talk I said I'm not mad I'm not going to

00:04:46,289 --> 00:04:51,690
show you macro soup but the first

00:04:49,530 --> 00:04:54,479
argument is a pearl engine pointer and

00:04:51,690 --> 00:04:56,130
on no thread builds the argument has to

00:04:54,479 --> 00:04:58,949
be removed and on threaded bills you

00:04:56,130 --> 00:05:02,760
have to have a pearl engine pointer the

00:04:58,949 --> 00:05:04,710
p THX macros allow the engine pointers

00:05:02,760 --> 00:05:06,030
to be dropped out of your code based on

00:05:04,710 --> 00:05:10,320
whether you're using threaded or

00:05:06,030 --> 00:05:12,510
unthreaded pearl builds um but the other

00:05:10,320 --> 00:05:14,820
parameter is a CV pointer which is

00:05:12,510 --> 00:05:19,139
basically a pointer to a subroutine in

00:05:14,820 --> 00:05:21,660
the pearl sea side of things this the CV

00:05:19,139 --> 00:05:24,210
has this is pretty much the layout of

00:05:21,660 --> 00:05:25,710
the CV the green things are the most

00:05:24,210 --> 00:05:27,660
interesting things to an excess

00:05:25,710 --> 00:05:30,570
programmer the red stuff is only used

00:05:27,660 --> 00:05:32,880
for pure Perl code and sometimes as an

00:05:30,570 --> 00:05:37,260
excess programmer the yellow stuff will

00:05:32,880 --> 00:05:38,910
be useful up here we have the c function

00:05:37,260 --> 00:05:42,960
pointer that you're going to be calling

00:05:38,910 --> 00:05:45,449
you write the c function that goes up in

00:05:42,960 --> 00:05:47,159
here and there's also a 1 void pointer

00:05:45,449 --> 00:05:50,250
that the pearl engine doesn't use for

00:05:47,159 --> 00:05:51,930
anything called any and you can cash you

00:05:50,250 --> 00:05:55,169
can do things like building closures

00:05:51,930 --> 00:05:57,360
close your subs and stick like a C++

00:05:55,169 --> 00:06:00,389
object pointer in here for a quick look

00:05:57,360 --> 00:06:02,639
up but this has no backing or ownership

00:06:00,389 --> 00:06:04,979
so generally anything you stick in any

00:06:02,639 --> 00:06:06,690
the pointer has to be owned by a magic

00:06:04,979 --> 00:06:08,940
struck that lives in the linked list of

00:06:06,690 --> 00:06:10,650
magic it's faster to look up the excess

00:06:08,940 --> 00:06:12,180
any member than to go searching the

00:06:10,650 --> 00:06:13,590
linked list for magic every time you

00:06:12,180 --> 00:06:16,729
want to get your private closure

00:06:13,590 --> 00:06:19,680
information for the sub for the X sub

00:06:16,729 --> 00:06:21,330
the Pearl stack has a couple design

00:06:19,680 --> 00:06:23,550
requirements for it to work in the pearl

00:06:21,330 --> 00:06:26,330
language per liz has no strict

00:06:23,550 --> 00:06:29,460
prototyping so pray every subroutine and

00:06:26,330 --> 00:06:31,590
a few people ever use want array to

00:06:29,460 --> 00:06:34,349
strictly enforce context there is list

00:06:31,590 --> 00:06:36,240
and void and scalar but they're optional

00:06:34,349 --> 00:06:38,219
if you want to care about them and the

00:06:36,240 --> 00:06:41,250
pearl language doesn't make doesn't

00:06:38,219 --> 00:06:41,760
force context on you also pearl the

00:06:41,250 --> 00:06:43,470
pearls

00:06:41,760 --> 00:06:45,720
jack has to implement call frames

00:06:43,470 --> 00:06:47,790
because this is pearl and not basic and

00:06:45,720 --> 00:06:51,450
we have and we're not using go to lines

00:06:47,790 --> 00:06:53,700
to switch function calls at underscore

00:06:51,450 --> 00:06:56,730
is actually a window into a chunk of the

00:06:53,700 --> 00:06:59,880
pearl stack and each sub each call frame

00:06:56,730 --> 00:07:02,550
gets its own @ underscore with a window

00:06:59,880 --> 00:07:04,230
into pieces of the pearl stack there is

00:07:02,550 --> 00:07:06,630
a local that's going on behind the

00:07:04,230 --> 00:07:08,880
scenes that swaps out what ad underscore

00:07:06,630 --> 00:07:11,400
is pointing to and the pearl stack can

00:07:08,880 --> 00:07:14,430
be reallocated any time so you can grow

00:07:11,400 --> 00:07:16,860
it to 128 petabytes on Linda 120

00:07:14,430 --> 00:07:18,360
terabytes if you want on Linux I don't

00:07:16,860 --> 00:07:22,800
know if anyone wants a pearl stack that

00:07:18,360 --> 00:07:24,720
big um generally on the pearl stack your

00:07:22,800 --> 00:07:26,790
incoming arguments also become your

00:07:24,720 --> 00:07:29,220
outgoing arguments to your caller and

00:07:26,790 --> 00:07:31,650
you can only store the null pointer and

00:07:29,220 --> 00:07:34,500
reference counting things like scalars

00:07:31,650 --> 00:07:37,260
and her hashes array pointers on pearl

00:07:34,500 --> 00:07:39,600
stack you cannot store random pieces of

00:07:37,260 --> 00:07:41,340
data on the pearl stack it has to be a

00:07:39,600 --> 00:07:45,540
valid reference counted pointer at all

00:07:41,340 --> 00:07:47,730
times um context is really an artificial

00:07:45,540 --> 00:07:49,710
concept in the pearl stack it's really

00:07:47,730 --> 00:07:51,180
just how many arguments you passed in

00:07:49,710 --> 00:07:54,330
and how many arguments something

00:07:51,180 --> 00:07:55,620
returned if you do want the won't array

00:07:54,330 --> 00:07:57,930
information that you would have in the

00:07:55,620 --> 00:08:02,580
pearl language it is available in C so

00:07:57,930 --> 00:08:04,170
don't worry on the pearl stack a on the

00:08:02,580 --> 00:08:07,140
pearl stack is generally starts as

00:08:04,170 --> 00:08:09,060
something called PL stack base and you

00:08:07,140 --> 00:08:10,950
when writing an X sub you heavily

00:08:09,060 --> 00:08:13,770
interact with the mark stack and the

00:08:10,950 --> 00:08:16,290
Pearl stack in order to know where your

00:08:13,770 --> 00:08:18,240
section of pearl stack begins you have

00:08:16,290 --> 00:08:21,540
to look on the mark stack the marks that

00:08:18,240 --> 00:08:24,320
consists of indexes into the Pearl stack

00:08:21,540 --> 00:08:28,590
these are indexes these are not pointers

00:08:24,320 --> 00:08:32,820
so you have to read what is underneath

00:08:28,590 --> 00:08:35,729
PL mark stack pointer get that I 32 and

00:08:32,820 --> 00:08:37,530
then take PL stack base and using

00:08:35,729 --> 00:08:39,960
pointer arithmetic you just add the tube

00:08:37,530 --> 00:08:43,680
and you know where the start of your

00:08:39,960 --> 00:08:45,780
section is of pearl stack but this the

00:08:43,680 --> 00:08:47,520
start of your section is generally

00:08:45,780 --> 00:08:49,830
something called the mark pointer and

00:08:47,520 --> 00:08:52,010
what is underneath the mark pointer is

00:08:49,830 --> 00:08:54,930
not your memory address which is read

00:08:52,010 --> 00:08:55,410
your elements if you get any incoming

00:08:54,930 --> 00:08:57,389
element

00:08:55,410 --> 00:08:59,370
they're going to be after the mark

00:08:57,389 --> 00:09:01,440
pointer which would be the yellow zone

00:08:59,370 --> 00:09:05,250
the first two yellow zone the yellow

00:09:01,440 --> 00:09:07,829
zone PL stack SP is the end of your sex

00:09:05,250 --> 00:09:10,290
your section of temporarily the end of

00:09:07,829 --> 00:09:13,230
your section of the Pearl stack it is

00:09:10,290 --> 00:09:16,050
always underneath the last valid element

00:09:13,230 --> 00:09:19,230
that you are receiving in in your X sub

00:09:16,050 --> 00:09:21,689
if PL stack SP is equal to the mark

00:09:19,230 --> 00:09:24,600
pointer you got zero incoming arguments

00:09:21,689 --> 00:09:26,129
and do not try to dereference what is

00:09:24,600 --> 00:09:30,509
the SV pointer that is underneath

00:09:26,129 --> 00:09:33,449
underneath PL stack SP if PL stack SP is

00:09:30,509 --> 00:09:35,459
equal to your mark pointer in theory on

00:09:33,449 --> 00:09:37,470
the Pearl stack you could have a private

00:09:35,459 --> 00:09:39,959
zone in the middle where you could store

00:09:37,470 --> 00:09:42,060
additional SVS almost no X subs do this

00:09:39,959 --> 00:09:44,009
because they traditionally store sv

00:09:42,060 --> 00:09:46,920
pointers on the sea stack not on the

00:09:44,009 --> 00:09:49,379
Pearl stack and if you want you can have

00:09:46,920 --> 00:09:51,629
you can call additional subroutines by

00:09:49,379 --> 00:09:55,019
allocating yet another chunk of pearl

00:09:51,629 --> 00:09:57,240
stack further down the line and that's

00:09:55,019 --> 00:10:00,449
go becomes the outgoing arguments to

00:09:57,240 --> 00:10:02,130
your call it to your colleagues you have

00:10:00,449 --> 00:10:04,410
to also remember to bounce check

00:10:02,130 --> 00:10:06,899
whenever you are extending or putting

00:10:04,410 --> 00:10:09,120
things on mark stack and on the Pearl

00:10:06,899 --> 00:10:11,209
stack because this is sea and everything

00:10:09,120 --> 00:10:14,639
has to be balanced checked at all times

00:10:11,209 --> 00:10:17,100
the minimum X sub that this is the role

00:10:14,639 --> 00:10:19,500
of every X sub has to do this it has to

00:10:17,100 --> 00:10:22,350
decrease the mark stack pointer by one

00:10:19,500 --> 00:10:24,649
element there is this is the minimum X

00:10:22,350 --> 00:10:27,420
sub that you can write in plain see and

00:10:24,649 --> 00:10:29,339
generally it returns at underscore in

00:10:27,420 --> 00:10:32,970
pure pearl the equivalent of what this

00:10:29,339 --> 00:10:35,600
code does let's count the number of add

00:10:32,970 --> 00:10:38,459
underscore arguments your X sub gets

00:10:35,600 --> 00:10:40,589
every X sub generally has a prologue

00:10:38,459 --> 00:10:43,529
which consists of reading the Pearl

00:10:40,589 --> 00:10:45,600
stack pointer getting the index off of

00:10:43,529 --> 00:10:47,910
the mark stack and then computing the

00:10:45,600 --> 00:10:49,559
mark pointer based on a combination of

00:10:47,910 --> 00:10:53,339
the start of the Pearl stack and our

00:10:49,559 --> 00:10:55,769
index items is generally the stack

00:10:53,339 --> 00:10:57,990
pointer minus mark so if SP is equal to

00:10:55,769 --> 00:11:00,600
mark you got zero elements and you have

00:10:57,990 --> 00:11:02,610
no incoming arguments at all and here is

00:11:00,600 --> 00:11:06,180
our obligation to decrease the mark

00:11:02,610 --> 00:11:09,150
stack pointer by one we create a new

00:11:06,180 --> 00:11:11,580
Pearl scalar generally the Pearl stack

00:11:09,150 --> 00:11:13,770
does not own any sv pointers that are on

00:11:11,580 --> 00:11:15,780
it all sv pointers on pearl stack have

00:11:13,770 --> 00:11:17,580
to be owned by something else if you

00:11:15,780 --> 00:11:20,430
don't know what's supposed to own an SV

00:11:17,580 --> 00:11:22,380
put it on mortal eyes it which is an

00:11:20,430 --> 00:11:25,530
alternate stack of just temporary

00:11:22,380 --> 00:11:27,960
ownership of things we create we set the

00:11:25,530 --> 00:11:30,630
SV to our items count now we have

00:11:27,960 --> 00:11:32,460
because this is a VAR argh subroutine we

00:11:30,630 --> 00:11:34,200
have to wipe all of our incoming

00:11:32,460 --> 00:11:37,320
arguments and we do that by assigning

00:11:34,200 --> 00:11:39,450
mark to SP which backs SP up all the way

00:11:37,320 --> 00:11:42,060
to the start and effectively we have now

00:11:39,450 --> 00:11:43,920
zero arguments on the on our section of

00:11:42,060 --> 00:11:45,870
the Pearl stack because we could have

00:11:43,920 --> 00:11:48,120
been called with the zero with an empty

00:11:45,870 --> 00:11:50,430
list we have to still bounced check our

00:11:48,120 --> 00:11:52,200
stack pointer and grow and reallocated

00:11:50,430 --> 00:11:54,180
if necessary to put one element on

00:11:52,200 --> 00:11:57,780
because we could have gotten 0 elements

00:11:54,180 --> 00:12:00,180
0 incoming elements in our list because

00:11:57,780 --> 00:12:02,010
SP at this point is on the mark is

00:12:00,180 --> 00:12:04,260
underneath mark and Mark is an invalid

00:12:02,010 --> 00:12:08,400
memory address for us we've advanced SP

00:12:04,260 --> 00:12:11,340
by one and we put our SP by one we put

00:12:08,400 --> 00:12:13,650
our sv pointer on the Pearl stack and

00:12:11,340 --> 00:12:16,980
then we save the location of pearl stack

00:12:13,650 --> 00:12:20,280
to the global copy of SP for our caller

00:12:16,980 --> 00:12:22,860
to figure out what we're returning how

00:12:20,280 --> 00:12:25,710
to print a scalar we have the same

00:12:22,860 --> 00:12:27,330
prologue that you saw earlier and

00:12:25,710 --> 00:12:29,670
generally this is a lot of repetitive

00:12:27,330 --> 00:12:32,910
code to write X subs manually that's why

00:12:29,670 --> 00:12:34,590
nobody does that we have to check the

00:12:32,910 --> 00:12:36,720
number of items because we could have

00:12:34,590 --> 00:12:38,730
gotten 0 to infinity items in any

00:12:36,720 --> 00:12:41,040
subroutine so we always have to bounce

00:12:38,730 --> 00:12:42,450
check how many items we got if we're

00:12:41,040 --> 00:12:46,940
going to read anything off purl stack

00:12:42,450 --> 00:12:50,040
now to extract a string out of a scalar

00:12:46,940 --> 00:12:52,080
we can check the flags and if we the

00:12:50,040 --> 00:12:55,080
flags are ok we can directly read the

00:12:52,080 --> 00:12:57,510
char pointer that is inside the scalar

00:12:55,080 --> 00:12:59,850
else we have to call a casting function

00:12:57,510 --> 00:13:02,340
which will convert our scalar into a

00:12:59,850 --> 00:13:05,400
char pointer that we can use we then

00:13:02,340 --> 00:13:07,260
print the scalar and here because we

00:13:05,400 --> 00:13:09,060
know we only have one item we can just

00:13:07,260 --> 00:13:10,650
decrease stack pointer unconditionally

00:13:09,060 --> 00:13:12,840
by one and assign it and we know that

00:13:10,650 --> 00:13:15,450
will be returning an empty list because

00:13:12,840 --> 00:13:19,860
we have the earlier check that we only

00:13:15,450 --> 00:13:23,040
have one element how to sum this

00:13:19,860 --> 00:13:27,000
algorithm sums of by the entire list and

00:13:23,040 --> 00:13:29,970
adds the numbers here we back up SP by

00:13:27,000 --> 00:13:31,740
the number of incoming items but SP is

00:13:29,970 --> 00:13:34,709
now the same thing as mark in the

00:13:31,740 --> 00:13:36,690
subroutine so when we dereference SP we

00:13:34,709 --> 00:13:40,440
have to do plus one because the element

00:13:36,690 --> 00:13:43,230
under mark is not valid for us again as

00:13:40,440 --> 00:13:45,720
with the string pointer we have to check

00:13:43,230 --> 00:13:47,970
the flags if the flags are okay we can

00:13:45,720 --> 00:13:50,040
directly dereference we can directly

00:13:47,970 --> 00:13:51,750
read the double value that is in the

00:13:50,040 --> 00:13:53,759
scalar else we have to do the casting

00:13:51,750 --> 00:13:56,279
stuff again because we could have got an

00:13:53,759 --> 00:13:58,290
empty list we have to bounce check the

00:13:56,279 --> 00:14:01,709
Pearl stack before we can create a new

00:13:58,290 --> 00:14:05,250
scalar and put it on the Pearl stack now

00:14:01,709 --> 00:14:07,230
for some really crazy stuff this is a

00:14:05,250 --> 00:14:09,209
pure pearl version of the following code

00:14:07,230 --> 00:14:11,610
I will explain on how for an X sub 2

00:14:09,209 --> 00:14:14,819
directly call an X sub without the help

00:14:11,610 --> 00:14:17,130
of the Pearl engine we here we have a

00:14:14,819 --> 00:14:21,720
typical prologue that every single X sub

00:14:17,130 --> 00:14:24,750
contains and in order to call a child X

00:14:21,720 --> 00:14:26,430
up we have to put our own mark stack we

00:14:24,750 --> 00:14:29,010
have to create our own mark entry for

00:14:26,430 --> 00:14:31,290
the child to pop off we have to bounce

00:14:29,010 --> 00:14:34,370
check the mark stack just the same way

00:14:31,290 --> 00:14:37,620
we that we bounced check the Pearl stack

00:14:34,370 --> 00:14:38,880
we also have to what in this sub what

00:14:37,620 --> 00:14:41,880
we're going to do is we're going to copy

00:14:38,880 --> 00:14:44,459
our incoming pearl stack arguments to a

00:14:41,880 --> 00:14:46,800
section of out of outgoing pearl

00:14:44,459 --> 00:14:48,480
arguments so we're going to basically

00:14:46,800 --> 00:14:50,970
have two blocks on pearl stack with the

00:14:48,480 --> 00:14:53,160
same contents because after calling each

00:14:50,970 --> 00:14:55,649
subroutine the arguments you sent out

00:14:53,160 --> 00:14:57,630
are wiped because the outgoing section

00:14:55,649 --> 00:15:01,800
is also used for your the arguments you

00:14:57,630 --> 00:15:05,250
get back from each subroutine to call an

00:15:01,800 --> 00:15:07,740
X sub directly in see each X sub

00:15:05,250 --> 00:15:09,389
requires its CV pointer so we here we

00:15:07,740 --> 00:15:12,420
fetch the CV pointer from the Pearl

00:15:09,389 --> 00:15:15,329
engine and we can directly call the X

00:15:12,420 --> 00:15:17,579
sub oh yeah we have to put the stack

00:15:15,329 --> 00:15:20,279
pointer back after we create our new

00:15:17,579 --> 00:15:22,100
outgoing zone so that the sub can the

00:15:20,279 --> 00:15:25,800
child sub can find all of our arguments

00:15:22,100 --> 00:15:28,079
we directly call the c function which is

00:15:25,800 --> 00:15:30,569
an X sub without going through the Pearl

00:15:28,079 --> 00:15:33,029
engine and then weary fetch the stack

00:15:30,569 --> 00:15:34,910
pointer to see how far it was adjusted

00:15:33,029 --> 00:15:36,840
and whatever returning arguments we have

00:15:34,910 --> 00:15:39,450
down here we have the couch

00:15:36,840 --> 00:15:41,400
how many items our child gave us we're

00:15:39,450 --> 00:15:44,010
basically recomputing the mark pointer

00:15:41,400 --> 00:15:46,320
based on stack pointer and if it's wrong

00:15:44,010 --> 00:15:48,120
we fatally error else we can read back

00:15:46,320 --> 00:15:52,260
the one element that our child was

00:15:48,120 --> 00:15:54,120
supposed to return we can call a sub

00:15:52,260 --> 00:15:56,190
again in this case because we earlier

00:15:54,120 --> 00:15:57,990
downs checked our mark stack we don't

00:15:56,190 --> 00:16:00,900
need to repeat extending the mark stack

00:15:57,990 --> 00:16:05,940
we can just directly advance it by one

00:16:00,900 --> 00:16:08,310
and assign our outgoing mark again

00:16:05,940 --> 00:16:10,440
because every subroutine can reallocate

00:16:08,310 --> 00:16:12,660
the pearls pearls stack and the mark

00:16:10,440 --> 00:16:14,790
stack we have to recompute hour mark

00:16:12,660 --> 00:16:17,370
pointer from the basic information of

00:16:14,790 --> 00:16:20,160
the index we then can perform the memory

00:16:17,370 --> 00:16:22,890
copy and recopy our incoming zone to the

00:16:20,160 --> 00:16:25,620
outcoming zone we can then call another

00:16:22,890 --> 00:16:28,410
X sub directly from an X sub again this

00:16:25,620 --> 00:16:29,880
is all undocumented but you have to

00:16:28,410 --> 00:16:33,360
understand how the Turing machine works

00:16:29,880 --> 00:16:34,950
in Perl we call a subroutine again we

00:16:33,360 --> 00:16:39,510
have to fetch the stack pointer and

00:16:34,950 --> 00:16:41,790
check it again for the art count now

00:16:39,510 --> 00:16:44,250
that we have our count and our some we

00:16:41,790 --> 00:16:47,310
can compute a string and again call

00:16:44,250 --> 00:16:49,350
another subroutine directly and print

00:16:47,310 --> 00:16:53,640
the values that we got from our earlier

00:16:49,350 --> 00:16:55,500
child calls and at the final thing we

00:16:53,640 --> 00:16:57,360
need to return an empty list so again we

00:16:55,500 --> 00:16:59,280
have to recompute the mark pointer and

00:16:57,360 --> 00:17:01,140
by assigning mark directly to the global

00:16:59,280 --> 00:17:06,650
stack pointer was saying we're returning

00:17:01,140 --> 00:17:06,650
zero arguments to our caller questions

00:17:24,169 --> 00:17:30,369
you have to bounce check everything but

00:17:26,869 --> 00:17:30,369
you only need to bound check things once

00:17:36,730 --> 00:17:40,909
again most of the stuff I told you today

00:17:39,109 --> 00:17:44,029
is undocumented and you'll probably be

00:17:40,909 --> 00:17:46,730
broken in 5 24 and this code won't even

00:17:44,029 --> 00:17:48,529
compile on 520 but compared to three

00:17:46,730 --> 00:17:49,999
letter macros and you don't really know

00:17:48,529 --> 00:17:51,649
what they do and you just copy paste

00:17:49,999 --> 00:17:54,139
them I think this is a lot more

00:17:51,649 --> 00:17:55,730
intelligible on what the excess code you

00:17:54,139 --> 00:17:57,350
write actually does on a Turing machine

00:17:55,730 --> 00:17:59,419
level and how it interacts with the

00:17:57,350 --> 00:18:00,950
pearl engine rather than a bunch of copy

00:17:59,419 --> 00:18:08,720
pasted macros that you don't know what

00:18:00,950 --> 00:18:13,039
they do I'm not here to teach you that

00:18:08,720 --> 00:18:14,749
you can just read pro i'm not i'm not

00:18:13,039 --> 00:18:16,580
going to read pearl api to you because

00:18:14,749 --> 00:18:19,279
that's just pawed you can read that

00:18:16,580 --> 00:18:21,320
yourself i mean this is this is a very

00:18:19,279 --> 00:18:26,179
innovative way to try to explain what

00:18:21,320 --> 00:18:31,509
these macros do without using them any

00:18:26,179 --> 00:18:31,509
other questions go ahead

00:18:36,470 --> 00:18:40,880
yeah but I'm copying them repeatedly I'm

00:18:38,960 --> 00:18:49,909
passing the same adding to three

00:18:40,880 --> 00:18:57,230
different subroutines X subs don't have

00:18:49,909 --> 00:19:01,130
pads only pure Pro code has pads on the

00:18:57,230 --> 00:19:04,820
CV point of the cv struct on the pad

00:19:01,130 --> 00:19:07,130
list is not used for X subs I actually

00:19:04,820 --> 00:19:10,250
recycled it in 522 for this member which

00:19:07,130 --> 00:19:16,280
I added so their ex subs do not have pad

00:19:10,250 --> 00:19:18,710
lists we're keeping it rather than

00:19:16,280 --> 00:19:20,539
copying it to a pile of C autos or Mao

00:19:18,710 --> 00:19:22,850
looking a new block or using a lock a

00:19:20,539 --> 00:19:24,470
work this is to explain how the pearl

00:19:22,850 --> 00:19:33,799
stack works and you can keep private

00:19:24,470 --> 00:19:35,870
arguments on the Pearl stack the pad

00:19:33,799 --> 00:19:42,590
equivalent would be using the excess any

00:19:35,870 --> 00:19:44,179
member down here along with magic yeah

00:19:42,590 --> 00:19:46,100
you can't the mark pointer is given to

00:19:44,179 --> 00:19:53,450
you it's a read-only value can never go

00:19:46,100 --> 00:19:55,309
behind it all X subs are there knock the

00:19:53,450 --> 00:19:59,289
nod up codes they're not keywords they

00:19:55,309 --> 00:19:59,289
are subroutines they have to use mark

00:20:01,270 --> 00:20:05,539
this is about X subs this is not about

00:20:03,890 --> 00:20:09,110
keywords that's the other alternative I

00:20:05,539 --> 00:20:11,480
mentioned my direct opcodes don't

00:20:09,110 --> 00:20:12,980
necessarily use marks they don't have to

00:20:11,480 --> 00:20:15,710
use the Pearl stack they can do crazy

00:20:12,980 --> 00:20:18,830
stuff x subs have to follow a certain

00:20:15,710 --> 00:20:20,570
ABI and they have to look like pure

00:20:18,830 --> 00:20:22,280
pearl subroutines and they have to sort

00:20:20,570 --> 00:20:27,860
of follow the same API and ABI

00:20:22,280 --> 00:20:31,710
requirements question ok I guess we're

00:20:27,860 --> 00:20:37,770
out of time huh

00:20:31,710 --> 00:20:41,520
I didn't have time to show a boot

00:20:37,770 --> 00:20:42,840
function the boot X sub that there was

00:20:41,520 --> 00:20:49,370
the yellow diagram at the beginning I

00:20:42,840 --> 00:20:49,370

YouTube URL: https://www.youtube.com/watch?v=Iu6RV2wKQwo


