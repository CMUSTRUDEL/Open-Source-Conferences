Title: Dana Jacobsen  â€ŽBigNums When 64 bits just is not enough
Publication date: 2015-06-16
Playlist: YAPC::NA 2015
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:04,710
so Who am I I'm a software engineer

00:00:02,419 --> 00:00:06,899
AppNexus i'm a member of portland perl

00:00:04,710 --> 00:00:10,710
mongers group and a pearl user since the

00:00:06,899 --> 00:00:12,719
dark ages relevant to this talk i'm the

00:00:10,710 --> 00:00:14,460
author of the N theory number theory

00:00:12,719 --> 00:00:17,250
module which uses big numbers quite a

00:00:14,460 --> 00:00:19,619
bit and non-party replacements for

00:00:17,250 --> 00:00:23,100
various script modules including crypt

00:00:19,619 --> 00:00:26,099
RSA crypt yes I crypt Brian's party has

00:00:23,100 --> 00:00:29,429
some issues especially with windows so

00:00:26,099 --> 00:00:31,949
we want those and I do contributions to

00:00:29,429 --> 00:00:35,250
rosetta code and OE is a lot of those

00:00:31,949 --> 00:00:37,590
use big numbers so here's a simple

00:00:35,250 --> 00:00:41,000
Pascal's triangle straight from rosetta

00:00:37,590 --> 00:00:42,809
code and everything's fine till line 69

00:00:41,000 --> 00:00:46,530
we're suddenly start getting

00:00:42,809 --> 00:00:49,070
floating-point results line 55 on 32-bit

00:00:46,530 --> 00:00:51,629
pearl so let's digress for a moment

00:00:49,070 --> 00:00:53,969
looking at 32-bit pearl if you

00:00:51,629 --> 00:00:56,489
complement 0 you get UV max that's the

00:00:53,969 --> 00:00:59,879
maximum integer value we can get we get

00:00:56,489 --> 00:01:03,750
to to the 32nd minus 1 on 64-bit pearl

00:00:59,879 --> 00:01:06,060
we get to to the 64th minus 1 so let's

00:01:03,750 --> 00:01:07,740
go ahead and just do multiplying two

00:01:06,060 --> 00:01:10,950
numbers together that should easily fit

00:01:07,740 --> 00:01:12,810
and we get a floating-point result so

00:01:10,950 --> 00:01:15,119
this is somewhat of legacy of pearls

00:01:12,810 --> 00:01:17,220
dynamic typing it will happily convert

00:01:15,119 --> 00:01:19,560
things to envies which are doubles in

00:01:17,220 --> 00:01:21,720
most versions of pearl this was great in

00:01:19,560 --> 00:01:25,170
the 55 in earlier days when everything

00:01:21,720 --> 00:01:27,360
was 32 bit so doubles have a 53 bit

00:01:25,170 --> 00:01:29,310
mantissa so you can have about fifty

00:01:27,360 --> 00:01:31,920
three bits worth of data that's bigger

00:01:29,310 --> 00:01:33,689
than 32 bit hence you can back and forth

00:01:31,920 --> 00:01:36,240
back and forth between your integers and

00:01:33,689 --> 00:01:41,369
doubles and everything's fine but with

00:01:36,240 --> 00:01:43,439
64-bit world that's not true anymore so

00:01:41,369 --> 00:01:45,149
I'm 32-bit the interesting thing with

00:01:43,439 --> 00:01:47,700
that however is we multiply two numbers

00:01:45,149 --> 00:01:49,560
it turns into a double but that has

00:01:47,700 --> 00:01:52,950
actually more precision than the 32-bit

00:01:49,560 --> 00:01:55,680
integer so everything's great we can use

00:01:52,950 --> 00:01:59,250
the use integer pragma that starts to

00:01:55,680 --> 00:02:01,020
look good use integer on 32-bit pearl

00:01:59,250 --> 00:02:04,350
and we just silently get the wrong

00:02:01,020 --> 00:02:05,909
answer the other thing with you is

00:02:04,350 --> 00:02:08,789
integer is it turns everything into

00:02:05,909 --> 00:02:10,570
signed numbers so if you like positive

00:02:08,789 --> 00:02:15,050
numbers you just lost a bit

00:02:10,570 --> 00:02:17,410
I like unsigned numbers so personally so

00:02:15,050 --> 00:02:20,900
I don't like being forced to lose a bit

00:02:17,410 --> 00:02:22,400
so in core we have math bigint that's

00:02:20,900 --> 00:02:24,860
the kind of standard solution been

00:02:22,400 --> 00:02:26,990
around for a very long time in core so

00:02:24,860 --> 00:02:30,200
we can make a variable for instance 10

00:02:26,990 --> 00:02:33,710
as a big int object raise it to the 450s

00:02:30,200 --> 00:02:36,170
a 50 7th power at 499 because that's the

00:02:33,710 --> 00:02:38,570
first prime after that and we have a

00:02:36,170 --> 00:02:40,490
large number there's no floating point

00:02:38,570 --> 00:02:42,650
conversions that are going to go on we

00:02:40,490 --> 00:02:45,620
get integer semantics so if you divide

00:02:42,650 --> 00:02:48,080
you get an integer you can get the

00:02:45,620 --> 00:02:49,970
remainder as well arbitrary length tens

00:02:48,080 --> 00:02:51,200
of millions of digits if you want they

00:02:49,970 --> 00:02:54,050
get pretty large and some of the

00:02:51,200 --> 00:02:56,000
operations can be very slow so here's

00:02:54,050 --> 00:02:59,120
our Pascal's trying to look example

00:02:56,000 --> 00:03:01,370
again we're going to use the use big int

00:02:59,120 --> 00:03:03,740
pragma which says basically silently

00:03:01,370 --> 00:03:05,840
just turn every number you see into a

00:03:03,740 --> 00:03:07,700
big ant object and we get the right

00:03:05,840 --> 00:03:10,580
answer so that's the quick and easy way

00:03:07,700 --> 00:03:13,670
to solve these problems we also note use

00:03:10,580 --> 00:03:16,370
big ant is lexical so you can also use

00:03:13,670 --> 00:03:18,590
no big int which has turn it off but

00:03:16,370 --> 00:03:19,970
because this is inside the sub we don't

00:03:18,590 --> 00:03:22,880
have to worry about it doing it for

00:03:19,970 --> 00:03:25,880
things outside of our sod here's a

00:03:22,880 --> 00:03:27,890
binomial example binomials used in a lot

00:03:25,880 --> 00:03:30,440
of places in math one of the things

00:03:27,890 --> 00:03:32,750
that's used for is a number of

00:03:30,440 --> 00:03:35,030
combinations of K items out of a back at

00:03:32,750 --> 00:03:37,430
the end of them so we start getting

00:03:35,030 --> 00:03:40,970
floating-point numbers again if you get

00:03:37,430 --> 00:03:44,570
it large enough use big int no problem

00:03:40,970 --> 00:03:47,780
goes away so we also get some extra

00:03:44,570 --> 00:03:50,410
features modular exponentiation X to the

00:03:47,780 --> 00:03:52,730
Y modulo n the thing is that can be done

00:03:50,410 --> 00:03:55,490
vastly more efficiently than actually

00:03:52,730 --> 00:03:58,100
raising X to the y power and then modulo

00:03:55,490 --> 00:04:00,890
n Perl 6 has this is a built-in because

00:03:58,100 --> 00:04:04,100
that's so useful cryptography especially

00:04:00,890 --> 00:04:08,090
uses this all the time almost everywhere

00:04:04,100 --> 00:04:10,430
we also get factorial we get binomial we

00:04:08,090 --> 00:04:15,110
get logged the base we can import export

00:04:10,430 --> 00:04:17,390
things says binary octal hex that can be

00:04:15,110 --> 00:04:19,820
quite useful for a number of things some

00:04:17,390 --> 00:04:22,070
of the gotchas you'll run into this

00:04:19,820 --> 00:04:24,020
looks good we're using big ant we have

00:04:22,070 --> 00:04:26,440
these fairly small numbers you multiply

00:04:24,020 --> 00:04:31,730
them together but we get floating point

00:04:26,440 --> 00:04:33,410
but I said use bigint ranges are exempt

00:04:31,730 --> 00:04:37,250
from all of this ranges are always

00:04:33,410 --> 00:04:40,910
signed integers so a solution just

00:04:37,250 --> 00:04:43,010
coerce it so in this case we have a1 the

00:04:40,910 --> 00:04:44,660
again takes that and as soon as it

00:04:43,010 --> 00:04:46,430
starts multiplying everything starts

00:04:44,660 --> 00:04:49,580
getting turned into begins along the way

00:04:46,430 --> 00:04:52,280
we can also use 0 plus those are very

00:04:49,580 --> 00:04:56,510
common or you could just explicitly turn

00:04:52,280 --> 00:04:59,150
X into a big event object another one

00:04:56,510 --> 00:05:00,710
this is kind of a quirky example I've

00:04:59,150 --> 00:05:03,380
run into this all the time with user

00:05:00,710 --> 00:05:05,360
input hash keys and so on we're going to

00:05:03,380 --> 00:05:07,910
make our array we're going to use this

00:05:05,360 --> 00:05:09,260
nice little QW feature to instead of

00:05:07,910 --> 00:05:12,740
commas we're going to have it space

00:05:09,260 --> 00:05:14,510
separated except that is a string they

00:05:12,740 --> 00:05:16,070
look like numbers to me but to purl

00:05:14,510 --> 00:05:18,320
those are strings and so when we

00:05:16,070 --> 00:05:20,090
multiply them together big aunt doesn't

00:05:18,320 --> 00:05:22,220
know what to do with them so it just

00:05:20,090 --> 00:05:23,300
uses the standard pearl conversion they

00:05:22,220 --> 00:05:25,970
become integers and we get

00:05:23,300 --> 00:05:28,010
floating-point so just like before we

00:05:25,970 --> 00:05:32,030
could do 0 plus we could do one time

00:05:28,010 --> 00:05:34,060
sort just explicitly created most people

00:05:32,030 --> 00:05:37,700
will never see this I do occasionally

00:05:34,060 --> 00:05:40,700
the complement of 0 isn't UV max anymore

00:05:37,700 --> 00:05:42,380
because what is an arbitrarily sized

00:05:40,700 --> 00:05:48,350
integer with all one so it's really

00:05:42,380 --> 00:05:51,320
infinity so it gives minus 1 so this is

00:05:48,350 --> 00:05:54,640
a arithmetic geometric mean example

00:05:51,320 --> 00:05:57,440
10,000 digits of pi from rosetta code

00:05:54,640 --> 00:06:01,490
two minutes and 43 seconds with big int

00:05:57,440 --> 00:06:04,130
turns out that really slow so there are

00:06:01,490 --> 00:06:07,040
backends available turns out big into

00:06:04,130 --> 00:06:08,660
math beginnt has the ability to plug in

00:06:07,040 --> 00:06:11,390
basic operation so every time you want

00:06:08,660 --> 00:06:13,040
to do an add it can say oh well you can

00:06:11,390 --> 00:06:15,740
dynamically plug a function in that will

00:06:13,040 --> 00:06:18,140
do an add or multiply or divide and so

00:06:15,740 --> 00:06:20,510
on so they're backends available Perry

00:06:18,140 --> 00:06:23,750
and GMP are the two readily available

00:06:20,510 --> 00:06:27,290
ones and they of course go much faster

00:06:23,750 --> 00:06:29,210
and that's how you would normally

00:06:27,290 --> 00:06:32,090
install them or you see Panem or

00:06:29,210 --> 00:06:35,030
whatever your favorite installer is you

00:06:32,090 --> 00:06:37,730
could also use try which basically says

00:06:35,030 --> 00:06:39,620
try to find GMP great if you find it if

00:06:37,730 --> 00:06:43,250
you don't try pyry if you don't find

00:06:39,620 --> 00:06:44,540
that don't worry about lib will warn you

00:06:43,250 --> 00:06:46,850
if it doesn't find it and then keep

00:06:44,540 --> 00:06:51,380
going only says if you can't find the

00:06:46,850 --> 00:06:53,150
GMP back end fatal error so now i'm

00:06:51,380 --> 00:06:55,820
going to start bitching the perils of

00:06:53,150 --> 00:06:57,770
Sipan we all know about this neither

00:06:55,820 --> 00:07:00,170
back end that is we know about the

00:06:57,770 --> 00:07:03,830
dependency issues neither back-end will

00:07:00,170 --> 00:07:05,510
install since 5 20 10 including 522 so

00:07:03,830 --> 00:07:07,790
this is a known problem it's just an

00:07:05,510 --> 00:07:09,560
issue in the tests but it's frustrating

00:07:07,790 --> 00:07:14,240
that 522 you can't install these back

00:07:09,560 --> 00:07:16,370
ends without forcing it GMP back n turns

00:07:14,240 --> 00:07:18,320
large integers into negative inputs

00:07:16,370 --> 00:07:20,540
because of a one-character bug that

00:07:18,320 --> 00:07:23,890
patches was submitted two years ago all

00:07:20,540 --> 00:07:26,930
four maintained errs have sat on that

00:07:23,890 --> 00:07:29,690
the party back end doesn't work on

00:07:26,930 --> 00:07:31,520
windows 64 and if you try to use threads

00:07:29,690 --> 00:07:32,780
and you load the perry library don't

00:07:31,520 --> 00:07:34,580
even have to make a perry object just

00:07:32,780 --> 00:07:37,940
load the perry object and you will get a

00:07:34,580 --> 00:07:39,740
segfault some people would say what

00:07:37,940 --> 00:07:41,840
these threads but if I'm making a

00:07:39,740 --> 00:07:43,790
library and he uses party how do I know

00:07:41,840 --> 00:07:45,890
some other person doesn't want to use

00:07:43,790 --> 00:07:50,920
threats so I've just crashed this

00:07:45,890 --> 00:07:53,450
program so here's our binomial example

00:07:50,920 --> 00:07:57,860
we're going to take numbers from one to

00:07:53,450 --> 00:08:00,560
three hundred k 1 to n over 2 and we see

00:07:57,860 --> 00:08:03,650
the libraries don't help very much the

00:08:00,560 --> 00:08:05,420
bet the back ends so even with those

00:08:03,650 --> 00:08:08,360
back ends there's still a lot of pure

00:08:05,420 --> 00:08:10,220
pearlcoat being run and that ends up

00:08:08,360 --> 00:08:12,260
being a lot of overhead per operation if

00:08:10,220 --> 00:08:15,200
you're doing cryptography and you do a

00:08:12,260 --> 00:08:17,180
large modular exponentiation maybe you

00:08:15,200 --> 00:08:19,130
won't see this because that large that

00:08:17,180 --> 00:08:21,650
all your time is in that exponentiation

00:08:19,130 --> 00:08:23,800
and that goes on in GMP but if you're

00:08:21,650 --> 00:08:26,330
just doing lots of adds and subtracts on

00:08:23,800 --> 00:08:29,720
relatively small numbers that overhead

00:08:26,330 --> 00:08:32,140
is going to kill you so you can skip

00:08:29,720 --> 00:08:34,880
math beginnt entirely and go straight to

00:08:32,140 --> 00:08:37,190
these modules that have the backends

00:08:34,880 --> 00:08:40,480
implement a direct or the bigoted

00:08:37,190 --> 00:08:40,480
libraries implemented directly

00:08:41,180 --> 00:08:48,020
so also mention math int64 if you have

00:08:45,800 --> 00:08:52,250
AC compiler it gives you 64-bit numbers

00:08:48,020 --> 00:08:54,110
and most of them do you can access

00:08:52,250 --> 00:08:56,330
64-bit numbers as objects and they're

00:08:54,110 --> 00:08:58,610
very fast on the other hand you could

00:08:56,330 --> 00:09:00,350
just install 64 bit pearl there's a

00:08:58,610 --> 00:09:02,770
thing called pearl brew that would let

00:09:00,350 --> 00:09:04,940
you do that there are also other methods

00:09:02,770 --> 00:09:07,220
on the other hand it does have some nice

00:09:04,940 --> 00:09:09,380
features if you want to be stopped if it

00:09:07,220 --> 00:09:13,040
overflows and there are some other

00:09:09,380 --> 00:09:14,990
interesting things that has end 128 uses

00:09:13,040 --> 00:09:18,020
almost exactly the same semantics if

00:09:14,990 --> 00:09:21,310
your c compiler and your architecture

00:09:18,020 --> 00:09:24,410
basically GCC on x86 64 or power 8

00:09:21,310 --> 00:09:26,630
supports it then you can have 128-bit

00:09:24,410 --> 00:09:29,720
types which gives you a little bit

00:09:26,630 --> 00:09:33,350
larger room so it's very fast on the

00:09:29,720 --> 00:09:36,770
other hand mouth gmt z is almost as fast

00:09:33,350 --> 00:09:38,390
and gives you arbitrary precision so

00:09:36,770 --> 00:09:39,649
some big integer math libraries there

00:09:38,390 --> 00:09:42,350
are lots of them out there most of them

00:09:39,649 --> 00:09:44,120
deprecated you could roll your own it's

00:09:42,350 --> 00:09:47,839
a fun programming exercise I do not

00:09:44,120 --> 00:09:50,120
recommend actually using that there's

00:09:47,839 --> 00:09:52,640
lots of interesting things in there lib

00:09:50,120 --> 00:09:54,440
tom math is fairly old it's not

00:09:52,640 --> 00:09:56,959
particularly fast on the other hand it's

00:09:54,440 --> 00:09:59,779
small self-contained has great licensing

00:09:56,959 --> 00:10:01,990
Perl 6 uses that internally just

00:09:59,779 --> 00:10:04,459
basically shipped it with Perl 6 and

00:10:01,990 --> 00:10:07,250
under the scene under the hood so they

00:10:04,459 --> 00:10:11,300
could change it out anytime there is no

00:10:07,250 --> 00:10:13,490
pro/5 module for that perry is a classic

00:10:11,300 --> 00:10:16,400
number theory library from started in

00:10:13,490 --> 00:10:18,589
1985 still being actively maintained

00:10:16,400 --> 00:10:20,330
still being going most people don't use

00:10:18,589 --> 00:10:22,190
that actually is a big number library

00:10:20,330 --> 00:10:24,380
they use it because it has the GP

00:10:22,190 --> 00:10:25,850
programming language on top of it which

00:10:24,380 --> 00:10:27,589
is wonderful for number theory and all

00:10:25,850 --> 00:10:30,740
sorts of things of course it has big

00:10:27,589 --> 00:10:34,850
numbers VMP is kind of the gold standard

00:10:30,740 --> 00:10:36,860
here for almost everything it is the new

00:10:34,850 --> 00:10:38,779
multi precision library for big integers

00:10:36,860 --> 00:10:41,170
most see software you find the dust big

00:10:38,779 --> 00:10:43,730
integers will use it it's a very fast

00:10:41,170 --> 00:10:46,970
there is there are two modules for in

00:10:43,730 --> 00:10:50,000
Perl 5 i'll mention gwm that's George

00:10:46,970 --> 00:10:51,709
Waltons number library it's

00:10:50,000 --> 00:10:52,520
extraordinarily fast if you're dealing

00:10:51,709 --> 00:10:56,690
with thousands of

00:10:52,520 --> 00:10:59,120
it's it's obnoxious to program for the

00:10:56,690 --> 00:11:00,590
great internet Mersenne prime search for

00:10:59,120 --> 00:11:02,780
example uses it where it actually makes

00:11:00,590 --> 00:11:05,900
a difference when using multi million

00:11:02,780 --> 00:11:08,630
digit numbers there is no perl module

00:11:05,900 --> 00:11:11,750
for that so let's go over a math party

00:11:08,630 --> 00:11:13,190
there's a colon int option you could

00:11:11,750 --> 00:11:15,080
give it if you want to which is

00:11:13,190 --> 00:11:17,990
basically that transparently convert

00:11:15,080 --> 00:11:19,940
numbers into bigots for me the number

00:11:17,990 --> 00:11:23,510
one issue with that there's no active

00:11:19,940 --> 00:11:26,390
maintainer it is based on code a code

00:11:23,510 --> 00:11:31,190
line that started in 2000 the current

00:11:26,390 --> 00:11:34,010
version is much newer here's one I sent

00:11:31,190 --> 00:11:35,660
on IRC it will happily tell you in a

00:11:34,010 --> 00:11:40,190
quarter of seconds at nine is a prime

00:11:35,660 --> 00:11:43,670
number this was fixed in party 2.3 from

00:11:40,190 --> 00:11:47,900
I believe 2006 but math party has not

00:11:43,670 --> 00:11:50,270
caught up there is a easy way just call

00:11:47,900 --> 00:11:52,600
his prime twice on your number and the

00:11:50,270 --> 00:11:55,280
chances will be very very small then

00:11:52,600 --> 00:11:58,160
another issue this was a fun one for a

00:11:55,280 --> 00:12:00,320
lot of us last year there was about a

00:11:58,160 --> 00:12:01,610
week where a bunch of Sipan modules

00:12:00,320 --> 00:12:03,920
wouldn't install why wouldn't they

00:12:01,610 --> 00:12:06,530
install it can't find party from the ftp

00:12:03,920 --> 00:12:08,000
server well the party people looked at

00:12:06,530 --> 00:12:09,460
and said this is 15 years old we're

00:12:08,000 --> 00:12:11,750
going to put it in an archive directory

00:12:09,460 --> 00:12:14,030
so all of a sudden math party couldn't

00:12:11,750 --> 00:12:16,430
find it but there's a patch for that so

00:12:14,030 --> 00:12:18,710
it works now as I mentioned threads and

00:12:16,430 --> 00:12:22,250
party don't mix doesn't work at all in

00:12:18,710 --> 00:12:23,660
windows 64 so the strawberry perl people

00:12:22,250 --> 00:12:25,490
for instance were very concerned because

00:12:23,660 --> 00:12:28,130
they couldn't ship crypt RSA they

00:12:25,490 --> 00:12:29,810
couldn't ship DSA and so on they now use

00:12:28,130 --> 00:12:32,690
replacements for those that don't depend

00:12:29,810 --> 00:12:34,790
on party on Nick patch had some

00:12:32,690 --> 00:12:37,130
interesting things to say about the

00:12:34,790 --> 00:12:39,170
excess internals there was some overly

00:12:37,130 --> 00:12:41,030
clever code that got written to try to

00:12:39,170 --> 00:12:44,090
speed things up that is very non

00:12:41,030 --> 00:12:48,320
portable and it is used by classic pearl

00:12:44,090 --> 00:12:50,480
crypto modules math GMP I think this is

00:12:48,320 --> 00:12:53,330
a overall good choice it has a nice

00:12:50,480 --> 00:12:55,520
little constant option if you want to do

00:12:53,330 --> 00:12:58,880
transparent big numbers you have to have

00:12:55,520 --> 00:13:00,380
the GMP library in your system many

00:12:58,880 --> 00:13:03,620
Linux systems will come with that

00:13:00,380 --> 00:13:05,250
strawberry perl comes with that it's

00:13:03,620 --> 00:13:09,360
very easy to install

00:13:05,250 --> 00:13:11,040
if you don't have it already a few very

00:13:09,360 --> 00:13:12,510
small issues there's more overhead than

00:13:11,040 --> 00:13:15,600
needed per call that could be easily

00:13:12,510 --> 00:13:17,700
fixed nothing like math bigint it just

00:13:15,600 --> 00:13:21,060
becomes obvious when compared to GMP Z

00:13:17,700 --> 00:13:23,040
and the in 25 process can I doubt most

00:13:21,060 --> 00:13:26,640
people will see this if you have an

00:13:23,040 --> 00:13:29,100
excess function it will ask is this a

00:13:26,640 --> 00:13:31,140
native number there's little bug in the

00:13:29,100 --> 00:13:33,060
intef I process for math GMP where it

00:13:31,140 --> 00:13:36,200
says yeah sure this is a 64-bit native

00:13:33,060 --> 00:13:39,570
number and then you get wrong answers

00:13:36,200 --> 00:13:42,060
there are workarounds for that so math

00:13:39,570 --> 00:13:44,520
GMP Z is a really low level API that

00:13:42,060 --> 00:13:47,390
just exposes all of the integer

00:13:44,520 --> 00:13:50,520
functions the MP z functions into pearl

00:13:47,390 --> 00:13:52,710
if you use it by just making an object

00:13:50,520 --> 00:13:54,780
and then let overloading take over it's

00:13:52,710 --> 00:13:56,340
great if you use the functions you do

00:13:54,780 --> 00:13:58,140
have to be a little careful there's no

00:13:56,340 --> 00:14:00,090
hand-holding there's no auto bigint

00:13:58,140 --> 00:14:03,450
option if you call one of the functions

00:14:00,090 --> 00:14:07,110
with the wrong arguments you very well

00:14:03,450 --> 00:14:08,970
may suck fault so again if you just make

00:14:07,110 --> 00:14:11,060
objects and start adding and subtracting

00:14:08,970 --> 00:14:13,890
dividing and so on you won't see that

00:14:11,060 --> 00:14:16,550
has very low overhead it's definitely

00:14:13,890 --> 00:14:19,110
the fastest of everything I've seen

00:14:16,550 --> 00:14:22,170
there are a couple small bugs I found

00:14:19,110 --> 00:14:24,780
they were really there's a new version

00:14:22,170 --> 00:14:27,120
released within a day or two of my

00:14:24,780 --> 00:14:30,000
reporting the bug so that makes me feel

00:14:27,120 --> 00:14:31,920
really good when i get a maintainer

00:14:30,000 --> 00:14:34,860
who's very active and interested in

00:14:31,920 --> 00:14:36,810
making sure software works and if you're

00:14:34,860 --> 00:14:38,520
curious there are lots and lots of

00:14:36,810 --> 00:14:40,200
undocumented and unsupported functions

00:14:38,520 --> 00:14:44,339
in there that aren't really needed but

00:14:40,200 --> 00:14:46,140
they're fun to look at some performance

00:14:44,339 --> 00:14:48,560
hacks for math big ant these are not

00:14:46,140 --> 00:14:51,330
really needed it for the math party math

00:14:48,560 --> 00:14:53,880
GMP what if you're using math bigot I

00:14:51,330 --> 00:14:56,190
the core option and you care about

00:14:53,880 --> 00:15:00,140
performance a great deal then these are

00:14:56,190 --> 00:15:02,520
some of the things I've learned um make

00:15:00,140 --> 00:15:04,470
only what needs to be a math bigoted

00:15:02,520 --> 00:15:05,700
object one of those so if I just have a

00:15:04,470 --> 00:15:07,830
little counter that's going to be a

00:15:05,700 --> 00:15:09,780
native number and account for 50 20

00:15:07,830 --> 00:15:12,030
don't make that a math bigot object

00:15:09,780 --> 00:15:12,660
every operation on it you just want done

00:15:12,030 --> 00:15:17,290
as a native

00:15:12,660 --> 00:15:19,899
only make the things you need to use to

00:15:17,290 --> 00:15:21,580
code paths one for native one for big

00:15:19,899 --> 00:15:23,470
games that's kind of obnoxious for most

00:15:21,580 --> 00:15:25,600
people sometimes you can get away with

00:15:23,470 --> 00:15:28,390
things like this where if I know my

00:15:25,600 --> 00:15:31,300
function overflows after 20 I'll just

00:15:28,390 --> 00:15:34,269
make my multiply or native number or a

00:15:31,300 --> 00:15:37,810
big hint object depending and then I

00:15:34,269 --> 00:15:39,670
could have one code path so some other

00:15:37,810 --> 00:15:42,820
ones I'm call functions directly this is

00:15:39,670 --> 00:15:44,440
very obnoxious again you don't really

00:15:42,820 --> 00:15:49,390
need to do this with most of the things

00:15:44,440 --> 00:15:51,760
i wanted to do g- are all over / w so

00:15:49,390 --> 00:15:53,709
this is actually faster the problem with

00:15:51,760 --> 00:15:55,630
overloading is it doesn't sometimes know

00:15:53,709 --> 00:15:58,000
whether it should create a extra

00:15:55,630 --> 00:16:01,480
constant or not to make an extra copy of

00:15:58,000 --> 00:16:03,880
things and so using the functions makes

00:16:01,480 --> 00:16:06,910
it very explicit it actually can make

00:16:03,880 --> 00:16:10,589
quite a difference in speed always use

00:16:06,910 --> 00:16:14,050
be ink be deck or plus plus minus minus

00:16:10,589 --> 00:16:16,750
it's 4x faster than saying n plus equals

00:16:14,050 --> 00:16:19,149
1 which is kind of surprising and yet

00:16:16,750 --> 00:16:21,130
what we find out is it says 0 plus

00:16:19,149 --> 00:16:23,470
equals 1 well I better turn one into a

00:16:21,130 --> 00:16:26,230
bigot object so create a new object and

00:16:23,470 --> 00:16:29,709
populate it with one and then add and

00:16:26,230 --> 00:16:31,149
then destroy the object and if you're

00:16:29,709 --> 00:16:33,130
doing for instance loops by two you

00:16:31,149 --> 00:16:36,070
could go ahead and just pre define a big

00:16:33,130 --> 00:16:38,920
into object of two and do your stuff

00:16:36,070 --> 00:16:41,079
there so I'm going to have a little

00:16:38,920 --> 00:16:42,910
brief talk about floating point floating

00:16:41,079 --> 00:16:45,520
point is not easy to get right there's

00:16:42,910 --> 00:16:46,990
an old 1991 whatever computer scientists

00:16:45,520 --> 00:16:50,800
should know about floating point it's 48

00:16:46,990 --> 00:16:54,250
pages I doubt most of us have read it

00:16:50,800 --> 00:16:57,579
extensively and remember it all so

00:16:54,250 --> 00:16:59,800
floating-point modules math long double

00:16:57,579 --> 00:17:01,089
it's worth mentioning the problem is

00:16:59,800 --> 00:17:03,070
you're really at the mercy of what your

00:17:01,089 --> 00:17:05,410
C compiler has decided what long double

00:17:03,070 --> 00:17:07,480
means and in the standard says well it

00:17:05,410 --> 00:17:08,709
could be double so basically you could

00:17:07,480 --> 00:17:10,540
use long double and get absolutely

00:17:08,709 --> 00:17:13,329
nothing you could get 80 bit you could

00:17:10,540 --> 00:17:14,919
get hundred twenty-eight bit math big

00:17:13,329 --> 00:17:17,970
float is kind of the common solution

00:17:14,919 --> 00:17:21,790
it's in core it is particularly slow

00:17:17,970 --> 00:17:24,800
math GMP f gives you low level access to

00:17:21,790 --> 00:17:28,190
the GMP floating point so if you have GM

00:17:24,800 --> 00:17:30,290
you have those the downside there is GMP

00:17:28,190 --> 00:17:32,180
gives for floating-point gives you the

00:17:30,290 --> 00:17:34,070
rudimentary because you add subtract

00:17:32,180 --> 00:17:35,420
multiply divide if you want to do a

00:17:34,070 --> 00:17:37,490
square root you get to write your own

00:17:35,420 --> 00:17:38,810
square root routine which makes it

00:17:37,490 --> 00:17:42,920
really hard to use for a lot of

00:17:38,810 --> 00:17:44,390
algorithms so canoe basically went and

00:17:42,920 --> 00:17:47,990
did floating point is a separate project

00:17:44,390 --> 00:17:50,690
so they have math mpfr it's great it has

00:17:47,990 --> 00:17:52,130
kind of obnoxious use and that is multi

00:17:50,690 --> 00:17:56,660
precision floating point with correct

00:17:52,130 --> 00:17:59,060
rounding the problem there is you have

00:17:56,660 --> 00:18:01,190
to have the mpf our library installed on

00:17:59,060 --> 00:18:03,770
your system it does not come on any

00:18:01,190 --> 00:18:06,500
system i know of by default it's readily

00:18:03,770 --> 00:18:09,430
available you can get it but depends

00:18:06,500 --> 00:18:12,260
whether you can install a system library

00:18:09,430 --> 00:18:13,640
so here's an example using generating

00:18:12,260 --> 00:18:15,560
digits of pi again this time we're going

00:18:13,640 --> 00:18:19,160
to use the version built into math big

00:18:15,560 --> 00:18:22,460
float take 16 minutes with the party

00:18:19,160 --> 00:18:24,080
back in 26 seconds GMP back end point 4

00:18:22,460 --> 00:18:27,290
seconds well this sounds fat fabulous

00:18:24,080 --> 00:18:28,610
let's make some more okay almost 2

00:18:27,290 --> 00:18:30,830
minutes for a hundred thousand digits

00:18:28,610 --> 00:18:36,230
and at a million digits yeah I waited

00:18:30,830 --> 00:18:39,530
four and a half hours for it so in n

00:18:36,230 --> 00:18:41,780
theory i wrote a routine using a GM GMP

00:18:39,530 --> 00:18:45,170
directly that same 1 million digits

00:18:41,780 --> 00:18:47,510
comes out in 1.8 seconds mpfr you can

00:18:45,170 --> 00:18:50,750
see the wonderful syntax of mpfr this is

00:18:47,510 --> 00:18:53,000
actually easier than most uses of it 1.3

00:18:50,750 --> 00:18:57,380
seconds there are ways to go

00:18:53,000 --> 00:19:01,130
significantly faster than even these so

00:18:57,380 --> 00:19:02,780
in summary for integers math big ant and

00:19:01,130 --> 00:19:04,400
big ant pragma that's kind of the easy

00:19:02,780 --> 00:19:07,580
thing if you're just doing a little bit

00:19:04,400 --> 00:19:09,620
of work that's great it's in core it's

00:19:07,580 --> 00:19:12,800
simple it's easy if you really care

00:19:09,620 --> 00:19:15,890
about performance mass GMP umass gmt ze

00:19:12,800 --> 00:19:20,060
math GMP with the constant i recommend

00:19:15,890 --> 00:19:21,980
it if you can use it for floats we

00:19:20,060 --> 00:19:25,070
really only have two good options math

00:19:21,980 --> 00:19:29,810
big float it's in core it's particularly

00:19:25,070 --> 00:19:31,880
slow mass empty fre if you can and one

00:19:29,810 --> 00:19:33,500
of the things i want well one of them i

00:19:31,880 --> 00:19:35,830
didn't put up here is I'd like bugs

00:19:33,500 --> 00:19:38,049
fixed in modules

00:19:35,830 --> 00:19:40,090
it really is frustrating to constantly

00:19:38,049 --> 00:19:43,210
have it to work around them even when I

00:19:40,090 --> 00:19:46,179
patch suspense about and what I'd like

00:19:43,210 --> 00:19:48,580
is basically to use Matthew G mtz and

00:19:46,179 --> 00:19:49,899
math mpfr with transparent options I

00:19:48,580 --> 00:19:52,269
don't think that's a really hard thing

00:19:49,899 --> 00:19:55,419
to do it just need somebody to actually

00:19:52,269 --> 00:20:37,659
do it maybe i'll get around two or one

00:19:55,419 --> 00:20:39,010
of you and that's it yes no if I can't

00:20:37,659 --> 00:20:40,539
answer all of that because I'm not

00:20:39,010 --> 00:20:42,580
intimately familiar with how they're

00:20:40,539 --> 00:20:45,610
doing it but they do have many different

00:20:42,580 --> 00:20:48,250
rounding modes they have explicitly you

00:20:45,610 --> 00:20:51,039
have this many bits for your number and

00:20:48,250 --> 00:20:52,990
so all those operations are on that bits

00:20:51,039 --> 00:20:55,120
and they have very strict requirements

00:20:52,990 --> 00:20:57,639
of how many you LPS are done so it's

00:20:55,120 --> 00:21:01,120
kind of like i triple e 75 for but done

00:20:57,639 --> 00:21:02,769
with arbitrary numbers of bits and i do

00:21:01,120 --> 00:21:05,649
not know if it implements all of i

00:21:02,769 --> 00:21:08,289
triple e 75 for but most people don't

00:21:05,649 --> 00:21:12,600
care about quiet signaling and things

00:21:08,289 --> 00:21:12,600
like that yes

00:21:19,880 --> 00:21:27,750
there are a few patches for small things

00:21:23,809 --> 00:21:31,110
I think a lot of it is just there's a

00:21:27,750 --> 00:21:33,210
lot of pure pearlcoat being run there

00:21:31,110 --> 00:21:35,549
also needs to be somebody to take over

00:21:33,210 --> 00:21:37,860
responsibility for that and make sure

00:21:35,549 --> 00:21:39,870
that it actually works correctly every

00:21:37,860 --> 00:21:43,049
time and maybe that is just writing a

00:21:39,870 --> 00:21:45,299
really really good test suite there

00:21:43,049 --> 00:21:48,870
might be a way to reduce some of the

00:21:45,299 --> 00:21:50,790
overhead in terms of backends so in

00:21:48,870 --> 00:22:02,390
other words do less work if you have a

00:21:50,790 --> 00:22:05,940
back-end less work in pure pearl yes

00:22:02,390 --> 00:22:07,500
maybe what I'm thinking I'm one of the

00:22:05,940 --> 00:22:09,809
things I do in n theory is I actually

00:22:07,500 --> 00:22:12,450
look to see if GMP is available and if

00:22:09,809 --> 00:22:15,150
it is i'll go ahead and add that to my

00:22:12,450 --> 00:22:17,880
requirements list one of the GMP modules

00:22:15,150 --> 00:22:20,460
so in theory pearl could ask for that

00:22:17,880 --> 00:22:22,380
the problem there you'd get is what if

00:22:20,460 --> 00:22:25,530
someone removed that library on some

00:22:22,380 --> 00:22:30,630
pearl doesn't work well or at least that

00:22:25,530 --> 00:22:33,770
part of it doesn't right um basically

00:22:30,630 --> 00:22:35,669
just doing it require for the back end

00:22:33,770 --> 00:22:40,530
the problem is somebody would have to

00:22:35,669 --> 00:22:42,510
install it right but somebody would

00:22:40,530 --> 00:22:47,120
still have to install that back in which

00:22:42,510 --> 00:22:47,120
you could do at Pearl you compile time

00:22:55,000 --> 00:22:58,000
ok

00:23:02,230 --> 00:23:09,789
it might be me I've been certainly

00:23:05,360 --> 00:23:09,789

YouTube URL: https://www.youtube.com/watch?v=Dhl4_Chvm_g


