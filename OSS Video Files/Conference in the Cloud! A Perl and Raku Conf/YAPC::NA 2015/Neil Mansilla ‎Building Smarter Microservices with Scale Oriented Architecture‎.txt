Title: Neil Mansilla ‎Building Smarter Microservices with Scale Oriented Architecture‎
Publication date: 2015-06-16
Playlist: YAPC::NA 2015
Description: 
	
Captions: 
	00:00:00,330 --> 00:00:03,840
today I'm going to be talking about

00:00:01,680 --> 00:00:07,290
smart services in smart clients and

00:00:03,840 --> 00:00:08,670
basically how we use micro services at

00:00:07,290 --> 00:00:12,059
run scoped and how its kind of helped us

00:00:08,670 --> 00:00:15,870
around how we kind of how we build and

00:00:12,059 --> 00:00:17,820
deploy code so some context at run scope

00:00:15,870 --> 00:00:20,279
we build tools that help developers

00:00:17,820 --> 00:00:22,949
solve API problems one of those tools we

00:00:20,279 --> 00:00:25,109
built is runs go up radar so it's a way

00:00:22,949 --> 00:00:27,480
to build tests imagine chaining a bunch

00:00:25,109 --> 00:00:29,250
of HTTP requests together and being able

00:00:27,480 --> 00:00:31,679
to let's say extracts and variables

00:00:29,250 --> 00:00:34,520
stuff min starts and values supplement

00:00:31,679 --> 00:00:37,470
variables using subsequent requests

00:00:34,520 --> 00:00:38,790
right assertions against those to see

00:00:37,470 --> 00:00:40,440
what's kind of what's coming back and

00:00:38,790 --> 00:00:42,330
basically letting you know that your API

00:00:40,440 --> 00:00:45,090
is up and running it's healthy and it's

00:00:42,330 --> 00:00:47,070
performing properly another Chewie built

00:00:45,090 --> 00:00:49,980
is called traffic inspector and it

00:00:47,070 --> 00:00:51,540
allows you to debug in flight HTTP

00:00:49,980 --> 00:00:53,910
requests so it gives you a real-time

00:00:51,540 --> 00:00:55,740
stream of the data that's flowing

00:00:53,910 --> 00:00:58,130
between the client and any API is that

00:00:55,740 --> 00:01:02,220
you use includes timing information

00:00:58,130 --> 00:01:04,769
status codes full header I'm sorry for a

00:01:02,220 --> 00:01:06,870
request and response header in payloads

00:01:04,769 --> 00:01:09,000
and so on and so forth and so those are

00:01:06,870 --> 00:01:10,950
the tools that we built and we built

00:01:09,000 --> 00:01:13,230
them on top of microservices

00:01:10,950 --> 00:01:15,180
architecture which is over 60 services

00:01:13,230 --> 00:01:17,730
that are all independently independently

00:01:15,180 --> 00:01:19,740
deployable but with only a team of nine

00:01:17,730 --> 00:01:22,530
people nine people that's just like last

00:01:19,740 --> 00:01:24,860
week so in the past year microservices

00:01:22,530 --> 00:01:27,630
has become quite a crazy buzz word and

00:01:24,860 --> 00:01:29,220
let me show you we did not just jump on

00:01:27,630 --> 00:01:30,990
the bandwagon this is something that

00:01:29,220 --> 00:01:32,310
over two and a half years ago when we

00:01:30,990 --> 00:01:34,530
started we made a very conscious

00:01:32,310 --> 00:01:37,740
decision that we wanted to build

00:01:34,530 --> 00:01:40,710
software a certain way and that was part

00:01:37,740 --> 00:01:43,409
of that decision was to build it you

00:01:40,710 --> 00:01:45,690
know to build small services so why do

00:01:43,409 --> 00:01:47,159
we make that choice you know there's a

00:01:45,690 --> 00:01:49,140
lot of moving parts why introduce that

00:01:47,159 --> 00:01:50,940
topic complexity especially when you're

00:01:49,140 --> 00:01:53,550
just a very small team like we were or

00:01:50,940 --> 00:01:55,470
that we even we are right now and for us

00:01:53,550 --> 00:01:58,049
our answer that question was the ability

00:01:55,470 --> 00:01:59,190
to scale the infrastructure so to be

00:01:58,049 --> 00:02:01,560
able to handle the growth of the company

00:01:59,190 --> 00:02:03,420
to scale with the demand of our service

00:02:01,560 --> 00:02:06,299
which is very much up and to the right

00:02:03,420 --> 00:02:08,220
and also to scale our team make sure

00:02:06,299 --> 00:02:09,810
that you know our processes and the way

00:02:08,220 --> 00:02:12,130
we develop software kind of maps to the

00:02:09,810 --> 00:02:13,660
way we coordinate our teams and you know

00:02:12,130 --> 00:02:15,910
we handle the overhead that comes that

00:02:13,660 --> 00:02:17,500
growth so a lots been said about

00:02:15,910 --> 00:02:19,570
microservices there's a lot of swell

00:02:17,500 --> 00:02:22,630
talks and articles out there about what

00:02:19,570 --> 00:02:24,010
they are how they work why you should

00:02:22,630 --> 00:02:25,870
use them and most recently like maybe

00:02:24,010 --> 00:02:26,980
why you should not use them in this talk

00:02:25,870 --> 00:02:28,690
I'm going to touch on some of those

00:02:26,980 --> 00:02:30,910
things but I really want to focus and

00:02:28,690 --> 00:02:32,920
how we do things in practice at run

00:02:30,910 --> 00:02:34,570
scope the technology we use how we

00:02:32,920 --> 00:02:36,220
organize our code in our systems and

00:02:34,570 --> 00:02:40,030
basically how we make this whole thing

00:02:36,220 --> 00:02:41,500
work for us so from a high level I

00:02:40,030 --> 00:02:42,730
talked very fast by the way in plus I

00:02:41,500 --> 00:02:44,140
have a lot of content to cover so I'm

00:02:42,730 --> 00:02:46,090
going to go really really quick if you

00:02:44,140 --> 00:02:47,590
have any questions please ask me after

00:02:46,090 --> 00:02:48,640
from a high level one of the core

00:02:47,590 --> 00:02:50,620
reasons we chose these architectures

00:02:48,640 --> 00:02:52,660
because by definition microservices are

00:02:50,620 --> 00:02:54,610
all highly independent small components

00:02:52,660 --> 00:02:56,470
and for us that means independent code

00:02:54,610 --> 00:02:58,570
bases independent deployability and

00:02:56,470 --> 00:02:59,680
independent teams that they can own

00:02:58,570 --> 00:03:01,240
different parts of the stack without

00:02:59,680 --> 00:03:03,090
having to you know that obligation of

00:03:01,240 --> 00:03:05,710
having to coordinate between each other

00:03:03,090 --> 00:03:07,930
so needs to say there's a lot of moving

00:03:05,710 --> 00:03:08,770
parts and lots of things changing and a

00:03:07,930 --> 00:03:11,110
lot of things being shipped to

00:03:08,770 --> 00:03:12,820
production all the time and it takes a

00:03:11,110 --> 00:03:14,710
lot of work to make sure that things run

00:03:12,820 --> 00:03:17,320
smoothly and just don't crash and burn

00:03:14,710 --> 00:03:18,490
and don't fall apart so the biggest

00:03:17,320 --> 00:03:20,590
lesson that we've learned or the past

00:03:18,490 --> 00:03:22,540
two and a half years is running

00:03:20,590 --> 00:03:24,190
microservices is that if you don't

00:03:22,540 --> 00:03:27,040
invest in infrastructure you should not

00:03:24,190 --> 00:03:28,930
invest in micro services so another way

00:03:27,040 --> 00:03:32,070
of saying that is that microservices

00:03:28,930 --> 00:03:34,510
architecture is taking a decade-long

00:03:32,070 --> 00:03:36,640
picture of what traditional service

00:03:34,510 --> 00:03:39,640
oriented architecture is and applying a

00:03:36,640 --> 00:03:42,070
DevOps bend to that so applying a lot of

00:03:39,640 --> 00:03:44,080
automation infrastructure tooling around

00:03:42,070 --> 00:03:46,360
it is what makes it all possible for us

00:03:44,080 --> 00:03:49,000
and foremost and to give you a more

00:03:46,360 --> 00:03:50,590
concrete example we in the beginning we

00:03:49,000 --> 00:03:52,990
had our dashboard which is like our

00:03:50,590 --> 00:03:54,670
website and it's a service and we wanted

00:03:52,990 --> 00:03:56,890
to build another service that would help

00:03:54,670 --> 00:03:58,450
us encapsulate all of our customer data

00:03:56,890 --> 00:04:01,480
to gotta give it a data access layer and

00:03:58,450 --> 00:04:03,340
we call that service identity so it lets

00:04:01,480 --> 00:04:04,930
us get information about customers

00:04:03,340 --> 00:04:07,270
information about their teams and

00:04:04,930 --> 00:04:10,450
generally it's a service with a bunch of

00:04:07,270 --> 00:04:14,080
get input operations on configuration

00:04:10,450 --> 00:04:16,180
data what's blowing up over here okay so

00:04:14,080 --> 00:04:19,090
we have these two services deployed on

00:04:16,180 --> 00:04:20,200
one on host 0011 a host 002 so you think

00:04:19,090 --> 00:04:22,210
how do I actually implement this

00:04:20,200 --> 00:04:24,130
function get teams and so it's pretty

00:04:22,210 --> 00:04:25,350
straightforward we're doing this using

00:04:24,130 --> 00:04:26,730
the requests so

00:04:25,350 --> 00:04:29,370
the request is a Python library that's

00:04:26,730 --> 00:04:31,470
similar to lwp and pearl and in this

00:04:29,370 --> 00:04:33,990
code we're just setting URL to that host

00:04:31,470 --> 00:04:35,790
02 we're making a get request and we get

00:04:33,990 --> 00:04:39,420
the response back in Jason so this is

00:04:35,790 --> 00:04:40,560
code and it works kind of and I say kind

00:04:39,420 --> 00:04:42,450
of because the tricky thing here is that

00:04:40,560 --> 00:04:47,670
when you're kind of doing things hard

00:04:42,450 --> 00:04:49,620
coded or in a monolithic pattern in

00:04:47,670 --> 00:04:51,180
compared to a microservices architecture

00:04:49,620 --> 00:04:54,030
things always changing so for instance

00:04:51,180 --> 00:04:56,700
we spin up posts and they might crash

00:04:54,030 --> 00:04:58,650
they might spin down we're dynamic we're

00:04:56,700 --> 00:05:00,270
scaling and you have to change a replace

00:04:58,650 --> 00:05:02,700
host so for instance what would happen

00:05:00,270 --> 00:05:05,940
if I needed to change host 002 to host

00:05:02,700 --> 00:05:08,070
003 basically I'd have to change code

00:05:05,940 --> 00:05:10,770
deploy that and just to address this new

00:05:08,070 --> 00:05:12,330
location and a bigger question here is

00:05:10,770 --> 00:05:14,940
that what happens in multiple

00:05:12,330 --> 00:05:16,620
environments so I have my local dev or

00:05:14,940 --> 00:05:18,180
my testing of our production environment

00:05:16,620 --> 00:05:20,310
and although things need to talk to

00:05:18,180 --> 00:05:21,720
different hosts so on to my local

00:05:20,310 --> 00:05:23,460
machine to my testing cluster my

00:05:21,720 --> 00:05:24,990
production cluster and so hard coding

00:05:23,460 --> 00:05:27,600
these host names can turn into a huge

00:05:24,990 --> 00:05:29,700
mess and we wanted to avoid all that so

00:05:27,600 --> 00:05:30,900
the first thing you have to answer when

00:05:29,700 --> 00:05:32,910
you have all these services like we do

00:05:30,900 --> 00:05:34,770
is how the hell do you find that service

00:05:32,910 --> 00:05:36,570
and so our answer to that it's something

00:05:34,770 --> 00:05:39,000
that we built called smart client and it

00:05:36,570 --> 00:05:41,280
does several things first it's a wrapper

00:05:39,000 --> 00:05:42,900
around the Python request library so you

00:05:41,280 --> 00:05:46,020
just kind of drop it in wherever you use

00:05:42,900 --> 00:05:48,090
requests it has the same API responds

00:05:46,020 --> 00:05:50,100
with the same objects and the next thing

00:05:48,090 --> 00:05:51,870
we wanted to do is get rid of those host

00:05:50,100 --> 00:05:54,450
names so we invented something called

00:05:51,870 --> 00:05:56,820
service URLs which looks like URL except

00:05:54,450 --> 00:05:59,220
its service colon slash slash service

00:05:56,820 --> 00:06:00,870
name and the really nice thing about it

00:05:59,220 --> 00:06:05,340
is that whether you're working in your

00:06:00,870 --> 00:06:06,690
local your test staging or prod it's

00:06:05,340 --> 00:06:08,880
same code you don't have to change code

00:06:06,690 --> 00:06:12,120
or update it at all just to address

00:06:08,880 --> 00:06:13,620
different environments so a smart client

00:06:12,120 --> 00:06:15,000
does three main things for us again it's

00:06:13,620 --> 00:06:19,260
a service discovery layer it can

00:06:15,000 --> 00:06:21,960
translate that that service URL into a

00:06:19,260 --> 00:06:25,200
hostname at runtime next will

00:06:21,960 --> 00:06:27,960
automatically get a retry get put and

00:06:25,200 --> 00:06:29,550
delete those item potent requests so for

00:06:27,960 --> 00:06:31,740
instance if a network service was down

00:06:29,550 --> 00:06:33,540
it just couldn't get to it if it's safe

00:06:31,740 --> 00:06:35,850
it will retry it and it may succeed on

00:06:33,540 --> 00:06:36,930
on the next try and lastly another nice

00:06:35,850 --> 00:06:37,930
feature is that it gives you the option

00:06:36,930 --> 00:06:40,449
to run

00:06:37,930 --> 00:06:42,610
requests in an async manner so if you

00:06:40,449 --> 00:06:44,199
had a bunch of requests and you wanted

00:06:42,610 --> 00:06:45,639
to fire them all at once and then kind

00:06:44,199 --> 00:06:48,039
of handle them as it as they come back

00:06:45,639 --> 00:06:49,840
you're not blocking or waiting as if you

00:06:48,039 --> 00:06:51,669
would have to do if you did those in a

00:06:49,840 --> 00:06:53,110
serial manner so the next question is

00:06:51,669 --> 00:06:55,120
how does it actually work you know

00:06:53,110 --> 00:06:57,190
what's the mechanism behind it that's

00:06:55,120 --> 00:06:59,380
powering all of this particularly this

00:06:57,190 --> 00:07:00,970
cluster configuration and for us the

00:06:59,380 --> 00:07:03,550
answer is also a service and it's called

00:07:00,970 --> 00:07:05,949
Atlas and Atlas contains information

00:07:03,550 --> 00:07:09,009
about a hard clusters mapped so Atlas

00:07:05,949 --> 00:07:11,229
stores info in dynamo DB and zookeeper

00:07:09,009 --> 00:07:13,240
so whenever new services created or its

00:07:11,229 --> 00:07:14,889
attaches to a new host we record all

00:07:13,240 --> 00:07:16,000
those bits of metadata and so for

00:07:14,889 --> 00:07:18,669
instance in zookeeper we kind of have

00:07:16,000 --> 00:07:20,530
this directory structure it's a drive

00:07:18,669 --> 00:07:22,449
where it starts off with hosts service

00:07:20,530 --> 00:07:24,610
name the actual host word as well where

00:07:22,449 --> 00:07:25,810
it's where it's located port number and

00:07:24,610 --> 00:07:27,759
some other flags like whether it's

00:07:25,810 --> 00:07:29,139
enabled or disabled and so Atlas is a

00:07:27,759 --> 00:07:32,620
service that encapsulates all of our

00:07:29,139 --> 00:07:34,930
cluster configuration information the

00:07:32,620 --> 00:07:37,180
next part of this is a Python Damon that

00:07:34,930 --> 00:07:39,789
we call sidecar and sidecar runs on

00:07:37,180 --> 00:07:42,280
every single host in our cluster so it

00:07:39,789 --> 00:07:45,010
does a few things first it runs a copy

00:07:42,280 --> 00:07:46,930
of H a proxy locally so every one of the

00:07:45,010 --> 00:07:49,539
hosts has its own copy of H a proxy it

00:07:46,930 --> 00:07:51,880
gets it gets its config by reading the

00:07:49,539 --> 00:07:53,800
info from Atlas and once it does that it

00:07:51,880 --> 00:07:55,690
sets up zookeeper watches on the you

00:07:53,800 --> 00:07:57,430
know on those keys whether it's stable

00:07:55,690 --> 00:08:00,280
or enabled or if you've added a new

00:07:57,430 --> 00:08:03,659
service or a new host any changes to

00:08:00,280 --> 00:08:05,800
that will kick off a reload of H a proxy

00:08:03,659 --> 00:08:07,780
so what are in fact happens you've got

00:08:05,800 --> 00:08:09,729
this cluster machines with sidecar NH a

00:08:07,780 --> 00:08:11,320
proxy running on all of them and

00:08:09,729 --> 00:08:12,610
whenever you make a service call you're

00:08:11,320 --> 00:08:14,860
actually taking that service call and

00:08:12,610 --> 00:08:17,740
you're making it to localhost so a

00:08:14,860 --> 00:08:20,020
request to service a will get fanned out

00:08:17,740 --> 00:08:21,669
to find the service we know where it's

00:08:20,020 --> 00:08:23,289
located where it's living at that time

00:08:21,669 --> 00:08:26,020
same thing with be and make a request to

00:08:23,289 --> 00:08:27,340
local hosted it pans out so it makes the

00:08:26,020 --> 00:08:29,740
implementation of a smart client does

00:08:27,340 --> 00:08:31,330
pretty darn simple because it just takes

00:08:29,740 --> 00:08:33,339
a service URL parses out the service

00:08:31,330 --> 00:08:36,159
name we use a custom header that runs

00:08:33,339 --> 00:08:38,169
club service and it passes that to the

00:08:36,159 --> 00:08:39,579
service name passes that a service name

00:08:38,169 --> 00:08:41,349
in there and the actual request is made

00:08:39,579 --> 00:08:44,740
to localhost and that front end port at

00:08:41,349 --> 00:08:46,029
4,000 so an interesting thing we're

00:08:44,740 --> 00:08:48,220
doing they chant proxy and you guys use

00:08:46,029 --> 00:08:50,110
it is that we're using the ACLS feature

00:08:48,220 --> 00:08:51,100
where you can dine throughout a request

00:08:50,110 --> 00:08:52,720
based on

00:08:51,100 --> 00:08:54,940
information is coming in the request and

00:08:52,720 --> 00:08:58,240
in this case you see we're buying you to

00:08:54,940 --> 00:09:01,779
port 4000 HDTV mode and we're doing an

00:08:58,240 --> 00:09:04,389
ACL match basically on on run scope

00:09:01,779 --> 00:09:06,279
service header and if it has API then it

00:09:04,389 --> 00:09:09,940
essentially signs at ACL and then down

00:09:06,279 --> 00:09:13,269
below it will instruct HR proxy to use

00:09:09,940 --> 00:09:15,269
that back-end API back end so we have

00:09:13,269 --> 00:09:17,829
this one stanza for all those services

00:09:15,269 --> 00:09:20,160
and and depending on what headers

00:09:17,829 --> 00:09:23,230
present it'll choose the appropriate API

00:09:20,160 --> 00:09:25,209
I'm sorry they're appropriate back in so

00:09:23,230 --> 00:09:27,880
that makes the implementation really

00:09:25,209 --> 00:09:29,259
easy so when we when we originally built

00:09:27,880 --> 00:09:31,089
smart client we had a lot of these

00:09:29,259 --> 00:09:33,279
things hard-coded like the service names

00:09:31,089 --> 00:09:35,110
and the port numbers and they were kind

00:09:33,279 --> 00:09:37,360
of baked into the library and so

00:09:35,110 --> 00:09:39,550
whenever we wanted to make it a new

00:09:37,360 --> 00:09:41,190
change or our launch engine service we'd

00:09:39,550 --> 00:09:43,329
have to update that library do a build

00:09:41,190 --> 00:09:45,459
and then redeploy all the services that

00:09:43,329 --> 00:09:47,709
affected so moving to H a proxy with a

00:09:45,459 --> 00:09:49,180
dynamic header routing instead of you

00:09:47,709 --> 00:09:50,589
know doing a code deploy to pick up a

00:09:49,180 --> 00:09:52,870
new service it's all data driven now

00:09:50,589 --> 00:09:54,940
instead of making changes to code we can

00:09:52,870 --> 00:09:57,370
just essentially add a add or change or

00:09:54,940 --> 00:09:58,810
recommended in the database so for the

00:09:57,370 --> 00:10:00,850
code now force mark line it's very

00:09:58,810 --> 00:10:02,319
static it doesn't change we're not a new

00:10:00,850 --> 00:10:05,829
build or employees every time that we

00:10:02,319 --> 00:10:07,089
deploy a new service or make changes so

00:10:05,829 --> 00:10:08,769
smart client was our answer that first

00:10:07,089 --> 00:10:10,660
question how do we find that service and

00:10:08,769 --> 00:10:12,970
the next question is how do we make

00:10:10,660 --> 00:10:15,279
service building easy supposed to be

00:10:12,970 --> 00:10:16,899
fast right so our answer to that as you

00:10:15,279 --> 00:10:19,839
may have guessed is another service

00:10:16,899 --> 00:10:21,550
called smart service and smart service

00:10:19,839 --> 00:10:23,949
is a library that's built on top of

00:10:21,550 --> 00:10:25,750
flask which is a framework and flash

00:10:23,949 --> 00:10:27,160
grateful restful which is an extension

00:10:25,750 --> 00:10:29,860
of that framework that helps to build

00:10:27,160 --> 00:10:31,060
REST API is easily we started with the

00:10:29,860 --> 00:10:32,860
space and it started adding more

00:10:31,060 --> 00:10:34,689
packages on top of it kind of bundling

00:10:32,860 --> 00:10:36,009
together a lot of things that a lot of

00:10:34,689 --> 00:10:38,680
common features and functionality that

00:10:36,009 --> 00:10:41,800
we need across our application and one

00:10:38,680 --> 00:10:43,480
of those packages is a an open source

00:10:41,800 --> 00:10:44,920
project that we put out there called

00:10:43,480 --> 00:10:47,860
health check which basically gives like

00:10:44,920 --> 00:10:51,250
a health check and point to two flasks

00:10:47,860 --> 00:10:52,750
apps next set of packages were kind of

00:10:51,250 --> 00:10:53,980
some third-party a combination of

00:10:52,750 --> 00:10:56,350
third-party and some internal things we

00:10:53,980 --> 00:10:58,990
built a bug snag is a third-party tool

00:10:56,350 --> 00:11:00,730
that we use for exception logging run

00:10:58,990 --> 00:11:02,579
scope Damon helps with demonizing

00:11:00,730 --> 00:11:04,829
processes in a sink and

00:11:02,579 --> 00:11:05,999
screaming using tasks Alchemist is for

00:11:04,829 --> 00:11:07,619
database connection handling and

00:11:05,999 --> 00:11:11,009
management and then there's this thing

00:11:07,619 --> 00:11:12,689
called smart config smart config is kind

00:11:11,009 --> 00:11:14,579
of something it helps us where we used

00:11:12,689 --> 00:11:17,009
to kind of have all of our hard coded

00:11:14,579 --> 00:11:19,649
constants and API keys stored into some

00:11:17,009 --> 00:11:20,879
file and which is great because the way

00:11:19,649 --> 00:11:22,439
that you refer to them is really simple

00:11:20,879 --> 00:11:24,209
that interface is great we wanted to

00:11:22,439 --> 00:11:25,739
keep that interface but we didn't want

00:11:24,209 --> 00:11:28,619
to have it so that we would we would

00:11:25,739 --> 00:11:31,019
actually be baking these secret keys and

00:11:28,619 --> 00:11:33,029
secrets into a file that you know that

00:11:31,019 --> 00:11:36,089
we'd be checking into github so instead

00:11:33,029 --> 00:11:37,889
it can get those values from from Atlas

00:11:36,089 --> 00:11:40,769
so you can provide empty place holders

00:11:37,889 --> 00:11:42,779
and it'll query Atlas pull down those

00:11:40,769 --> 00:11:44,429
variables and replace them so that we

00:11:42,779 --> 00:11:46,589
don't have to be checking in code with

00:11:44,429 --> 00:11:48,449
secrets so here we r neutralizing a

00:11:46,589 --> 00:11:50,459
smart service with a config and

00:11:48,449 --> 00:11:52,999
basically what you get is an app object

00:11:50,459 --> 00:11:55,110
and it's basically a wrapped flask app

00:11:52,999 --> 00:11:58,499
so it has all the normal things that a

00:11:55,110 --> 00:12:00,839
flask a pass so based on the values of

00:11:58,499 --> 00:12:03,029
the config we can get you know we can

00:12:00,839 --> 00:12:04,529
inherit a lot of things so just from

00:12:03,029 --> 00:12:06,509
like import current app I could hey

00:12:04,529 --> 00:12:09,809
saker napped realm to find out if I'm in

00:12:06,509 --> 00:12:13,079
test test or a prod or my localhost or

00:12:09,809 --> 00:12:15,779
if my config had like Redis reddits

00:12:13,079 --> 00:12:17,669
configured I automatically get a Redis

00:12:15,779 --> 00:12:18,809
client connection I think about like hey

00:12:17,669 --> 00:12:21,480
where is that read a service which one

00:12:18,809 --> 00:12:22,230
do I use you know connection pooling you

00:12:21,480 --> 00:12:24,149
know to think about any of that stuff

00:12:22,230 --> 00:12:26,519
you just kind of think ok i'm going to

00:12:24,149 --> 00:12:28,379
import this app i'm gonna get this right

00:12:26,519 --> 00:12:30,179
his client start using it right and then

00:12:28,379 --> 00:12:32,970
same thing if it was postgrads or

00:12:30,179 --> 00:12:34,860
whatever so what I think smart service

00:12:32,970 --> 00:12:36,480
does it kind of builds a common logging

00:12:34,860 --> 00:12:38,129
configuration so everything's

00:12:36,480 --> 00:12:40,499
standardized we have we format Oliver

00:12:38,129 --> 00:12:42,389
logs you know all of our we configure

00:12:40,499 --> 00:12:43,829
our log format Solomon place so as a

00:12:42,389 --> 00:12:45,209
developer even to think about you know

00:12:43,829 --> 00:12:47,759
how do i access a logger how do i choose

00:12:45,209 --> 00:12:49,679
the right one for access or error log so

00:12:47,759 --> 00:12:52,110
for instance if i wanted to use bug snag

00:12:49,679 --> 00:12:54,119
i just import that and i use it this is

00:12:52,110 --> 00:12:56,040
one good example of how we build

00:12:54,119 --> 00:12:59,699
consistency across all of our different

00:12:56,040 --> 00:13:02,129
services so another feature of smart

00:12:59,699 --> 00:13:03,360
services on the whole easy part that I

00:13:02,129 --> 00:13:05,040
was talking about these things should be

00:13:03,360 --> 00:13:06,929
easy is that we auto generate the

00:13:05,040 --> 00:13:08,999
service skeletons so since all of our

00:13:06,929 --> 00:13:11,999
projects kind of look behave and act the

00:13:08,999 --> 00:13:14,499
same way we have one command you know

00:13:11,999 --> 00:13:15,999
generate service and it does a lot

00:13:14,499 --> 00:13:17,769
early heavy lifting for you so it

00:13:15,999 --> 00:13:20,199
constructs a new service object sets

00:13:17,769 --> 00:13:21,669
defaults gives you a repository install

00:13:20,199 --> 00:13:24,099
as a virtual environment so you run

00:13:21,669 --> 00:13:26,169
command one command you get a fully

00:13:24,099 --> 00:13:28,719
operational service if you can deploy it

00:13:26,169 --> 00:13:30,729
right away and it gets that overhead out

00:13:28,719 --> 00:13:31,989
of the way that you know perhaps you can

00:13:30,729 --> 00:13:34,239
help you move on to actually writing

00:13:31,989 --> 00:13:37,659
useful code and not worrying about the

00:13:34,239 --> 00:13:38,769
stuff going on behind the scenes so the

00:13:37,659 --> 00:13:41,139
smart service and all the things that we

00:13:38,769 --> 00:13:42,819
put into it as well as smart client they

00:13:41,139 --> 00:13:44,079
go into this idea of reducing cognitive

00:13:42,819 --> 00:13:46,479
overhead the amount of things you have

00:13:44,079 --> 00:13:48,069
to think about the amount of times that

00:13:46,479 --> 00:13:50,319
you have to contact switch it's

00:13:48,069 --> 00:13:52,389
significantly reduced so thinking about

00:13:50,319 --> 00:13:54,429
the database and where is it located and

00:13:52,389 --> 00:13:56,679
how do i construct a new sequel absolute

00:13:54,429 --> 00:13:57,699
alchemy model how do I find a database

00:13:56,679 --> 00:13:59,799
session do I need to tear that thing

00:13:57,699 --> 00:14:01,179
down you just have to think like those

00:13:59,799 --> 00:14:02,439
things are handled for you you just have

00:14:01,179 --> 00:14:03,999
to say hey database you know do this

00:14:02,439 --> 00:14:05,769
thing that I want and then you just move

00:14:03,999 --> 00:14:07,029
on to the next thing so this is really

00:14:05,769 --> 00:14:08,529
helpful for managing lots of services

00:14:07,029 --> 00:14:10,329
because all these services again they

00:14:08,529 --> 00:14:11,709
look they behave in the act the same way

00:14:10,329 --> 00:14:13,959
you don't have to focus on the minutia

00:14:11,709 --> 00:14:20,529
you just focus on writing code that

00:14:13,959 --> 00:14:22,239
moves things forward so that's what we

00:14:20,529 --> 00:14:24,609
did a bit make a building services very

00:14:22,239 --> 00:14:26,349
easy easy and we have a lot of services

00:14:24,609 --> 00:14:28,269
so the next question is so what happens

00:14:26,349 --> 00:14:29,349
when you have so many services and the

00:14:28,269 --> 00:14:31,059
answer is there's a lot of things

00:14:29,349 --> 00:14:31,839
happening so I'm going to talk about

00:14:31,059 --> 00:14:33,759
some of the lessons that we've learned

00:14:31,839 --> 00:14:36,220
and the things that we decided to kind

00:14:33,759 --> 00:14:38,079
of baked into our processes that makes

00:14:36,220 --> 00:14:41,769
living with a ton of services are really

00:14:38,079 --> 00:14:42,669
easy from day to day so the first lesson

00:14:41,769 --> 00:14:44,589
we learned is they have to automate

00:14:42,669 --> 00:14:46,299
everything so for us that means setting

00:14:44,589 --> 00:14:48,399
up new servers and bringing them online

00:14:46,299 --> 00:14:49,689
we use puppet to generate templates for

00:14:48,399 --> 00:14:51,599
init scripts and are monitoring

00:14:49,689 --> 00:14:53,949
everything that we do has to be

00:14:51,599 --> 00:14:56,859
repeatable and deployable without having

00:14:53,949 --> 00:14:58,389
to really think about it so we invest

00:14:56,859 --> 00:15:00,399
you have to invest a lot in DevOps

00:14:58,389 --> 00:15:02,319
invest in automation tools and building

00:15:00,399 --> 00:15:05,679
scripts that makes it reasonable to

00:15:02,319 --> 00:15:07,089
manage so many services the next thing

00:15:05,679 --> 00:15:08,439
we learned is that they're building a

00:15:07,089 --> 00:15:10,599
nice schools like this is that you kind

00:15:08,439 --> 00:15:12,309
of become a language agnostic so most of

00:15:10,599 --> 00:15:13,959
our stuffs in Python but as I said

00:15:12,309 --> 00:15:15,159
earlier that you you know about a year

00:15:13,959 --> 00:15:17,109
ago we started writing a lot of go code

00:15:15,159 --> 00:15:18,999
so once you have the go service up and

00:15:17,109 --> 00:15:20,409
running once we had it running it became

00:15:18,999 --> 00:15:22,239
really easy to integrate with the rest

00:15:20,409 --> 00:15:24,039
of our cluster so you get a lot of nice

00:15:22,239 --> 00:15:25,720
services that you I mean all the

00:15:24,039 --> 00:15:27,729
services that are already there you know

00:15:25,720 --> 00:15:28,279
you get to inherit those go doesn't need

00:15:27,729 --> 00:15:30,290
to know

00:15:28,279 --> 00:15:32,389
about you know with format the data is

00:15:30,290 --> 00:15:33,980
in or the database ORM it just needs to

00:15:32,389 --> 00:15:35,689
know that it has an API this is how you

00:15:33,980 --> 00:15:39,829
access it and I get all this data back

00:15:35,689 --> 00:15:40,970
in Jason so we were able to quickly spin

00:15:39,829 --> 00:15:43,990
up projects and third-party tools

00:15:40,970 --> 00:15:46,670
basically anything that talks in HTTP

00:15:43,990 --> 00:15:49,040
HTTP is was immediately useful to us and

00:15:46,670 --> 00:15:51,949
so we kind of say that HTTP is our

00:15:49,040 --> 00:15:53,959
common language the next bit though is

00:15:51,949 --> 00:15:55,519
well was more of a philosophical

00:15:53,959 --> 00:15:57,980
decision for us early on but it's really

00:15:55,519 --> 00:16:00,829
paid off and that is there are no shear

00:15:57,980 --> 00:16:02,209
databases between our services so

00:16:00,829 --> 00:16:04,069
imagine a world where you have a

00:16:02,209 --> 00:16:06,769
dashboard or traffic gateway and our API

00:16:04,069 --> 00:16:08,449
and they're all and they're all talking

00:16:06,769 --> 00:16:09,889
to the same Postgres database for

00:16:08,449 --> 00:16:11,959
customer data like for the identities

00:16:09,889 --> 00:16:13,430
the problem you encounter with this type

00:16:11,959 --> 00:16:16,069
of architecture is that you have the

00:16:13,430 --> 00:16:17,629
shared dependency and not only the type

00:16:16,069 --> 00:16:19,819
of database put the schema itself so if

00:16:17,629 --> 00:16:21,709
you to modify the schema at all add a

00:16:19,819 --> 00:16:24,649
column or make any changes you're going

00:16:21,709 --> 00:16:26,689
to have to update update and or deploy

00:16:24,649 --> 00:16:28,129
code to all these services that depend

00:16:26,689 --> 00:16:29,749
on it and the real problems that you're

00:16:28,129 --> 00:16:32,089
no longer have this independent system

00:16:29,749 --> 00:16:33,709
in fact you're taking away what used to

00:16:32,089 --> 00:16:35,389
be three independent services and you're

00:16:33,709 --> 00:16:37,250
really tying them really close together

00:16:35,389 --> 00:16:39,500
like this right so whenever you have a

00:16:37,250 --> 00:16:41,120
pattern were you making when you make

00:16:39,500 --> 00:16:43,819
one change but it affects the entire

00:16:41,120 --> 00:16:45,620
system you have to redeploy all in all

00:16:43,819 --> 00:16:47,660
these other areas you know you're doing

00:16:45,620 --> 00:16:49,009
something wrong so for us we said no

00:16:47,660 --> 00:16:50,240
we're not going to do that we're not

00:16:49,009 --> 00:16:52,370
going to have this one central data

00:16:50,240 --> 00:16:54,680
store so every service owns its own data

00:16:52,370 --> 00:16:56,600
store for so for identity it has flask

00:16:54,680 --> 00:17:00,680
postgrads and its own Redis incidence

00:16:56,600 --> 00:17:02,540
and the thing is is that you know from

00:17:00,680 --> 00:17:04,280
everyone else's perspective it's just an

00:17:02,540 --> 00:17:05,899
API you don't need to know what

00:17:04,280 --> 00:17:06,709
technologies are beneath the hood unless

00:17:05,899 --> 00:17:08,870
you're actually the one that's

00:17:06,709 --> 00:17:10,370
developing that service so if you're

00:17:08,870 --> 00:17:13,010
developing something for the website or

00:17:10,370 --> 00:17:14,600
your you know adding a new feature those

00:17:13,010 --> 00:17:17,539
tech details are completely irrelevant

00:17:14,600 --> 00:17:19,390
to you right in your day-to-day work it

00:17:17,539 --> 00:17:21,559
helps keep that mental overhead small

00:17:19,390 --> 00:17:22,970
and it makes easy to change things

00:17:21,559 --> 00:17:24,140
independent from everyone else around

00:17:22,970 --> 00:17:26,689
you the things that they're working on

00:17:24,140 --> 00:17:28,549
so the biggest effect of adapting this

00:17:26,689 --> 00:17:30,320
architecture is that it makes deploying

00:17:28,549 --> 00:17:31,610
really really easy so it's something we

00:17:30,320 --> 00:17:33,980
wanted for the beginning was this idea

00:17:31,610 --> 00:17:35,360
of a one click deploy and so not

00:17:33,980 --> 00:17:37,850
surprisingly we've got another service

00:17:35,360 --> 00:17:40,460
called prometheus and this helps us with

00:17:37,850 --> 00:17:41,570
our deploys so it's like an operational

00:17:40,460 --> 00:17:42,080
service dashboard you can see in the

00:17:41,570 --> 00:17:43,940
middle here

00:17:42,080 --> 00:17:46,549
you see all the branches for this

00:17:43,940 --> 00:17:48,529
particular service and you can deploy it

00:17:46,549 --> 00:17:49,519
to test or prod any realm that you want

00:17:48,529 --> 00:17:50,990
you change the realm of the top

00:17:49,519 --> 00:17:53,090
right-hand there and then there's a

00:17:50,990 --> 00:17:54,470
snapshot we use Jenkins for our builds

00:17:53,090 --> 00:17:56,570
you can see where the build last bill

00:17:54,470 --> 00:17:58,159
passed or failed for our now sorry for

00:17:56,570 --> 00:17:59,419
our unit tests and the idea here is

00:17:58,159 --> 00:18:01,669
we're going to make it simple to get a

00:17:59,419 --> 00:18:03,350
service deployed to our testing apart

00:18:01,669 --> 00:18:05,600
environments that on your very first day

00:18:03,350 --> 00:18:07,519
or working run scope you can check in

00:18:05,600 --> 00:18:09,529
code and just deploy it and you know

00:18:07,519 --> 00:18:11,750
deploy to production is an engineer and

00:18:09,529 --> 00:18:13,760
since all of our services are running

00:18:11,750 --> 00:18:16,010
independent from another you we have a

00:18:13,760 --> 00:18:18,289
rule that once your codes reviewed and

00:18:16,010 --> 00:18:19,399
it's merging a master that you are make

00:18:18,289 --> 00:18:20,450
sure you're responsible you're the one

00:18:19,399 --> 00:18:22,610
that can immediately go and deploy it

00:18:20,450 --> 00:18:24,529
yourself so we found that people really

00:18:22,610 --> 00:18:26,120
like doing that so right now we're close

00:18:24,529 --> 00:18:28,279
to left back in March but now we're

00:18:26,120 --> 00:18:30,340
close to closer to 100 deploys a day

00:18:28,279 --> 00:18:32,120
even though we have a very tiny team and

00:18:30,340 --> 00:18:33,710
so the next question is when you're

00:18:32,120 --> 00:18:35,570
deploying code so quickly how do not

00:18:33,710 --> 00:18:36,860
break things all the time right so for

00:18:35,570 --> 00:18:39,200
us it goes back to our product we

00:18:36,860 --> 00:18:41,059
actually use our own testing tool to

00:18:39,200 --> 00:18:43,360
monitor our own our own internal

00:18:41,059 --> 00:18:45,919
services this is a huge lifesaver for us

00:18:43,360 --> 00:18:48,350
we create service test through bond

00:18:45,919 --> 00:18:49,850
scope radar after you deploy it

00:18:48,350 --> 00:18:51,019
automatically triggers a test and it

00:18:49,850 --> 00:18:52,639
verifies all the services are running

00:18:51,019 --> 00:18:54,559
right and it's returning the right data

00:18:52,639 --> 00:18:56,269
and if things go south we get notified

00:18:54,559 --> 00:18:58,130
by email or slack or any other

00:18:56,269 --> 00:19:00,649
integration if we wanted to use like

00:18:58,130 --> 00:19:01,820
pagerduty for instance so the nice thing

00:19:00,649 --> 00:19:03,679
about the tools that we can write one

00:19:01,820 --> 00:19:05,330
test and use variables in those name and

00:19:03,679 --> 00:19:08,059
we can reuse it over and over again so

00:19:05,330 --> 00:19:10,490
if i'm testing on my local dev or if i'm

00:19:08,059 --> 00:19:12,409
testing on the testing environment I

00:19:10,490 --> 00:19:13,970
tried deploying to test we can

00:19:12,409 --> 00:19:15,620
automatically trigger test to run or

00:19:13,970 --> 00:19:17,840
even in product and reviews that same

00:19:15,620 --> 00:19:18,740
test and do it on automated schedule so

00:19:17,840 --> 00:19:22,340
that we know that it's up and running

00:19:18,740 --> 00:19:23,389
and performing very well over time so

00:19:22,340 --> 00:19:25,549
the idea here is that all these things

00:19:23,389 --> 00:19:27,649
together smart service smart service

00:19:25,549 --> 00:19:29,269
smart client and our own testing tools

00:19:27,649 --> 00:19:33,080
they make that they make this graph

00:19:29,269 --> 00:19:34,639
possible so an engineer can spend less

00:19:33,080 --> 00:19:36,110
time responding to a ticket in fact can

00:19:34,639 --> 00:19:38,419
probably solve the bug faster and deploy

00:19:36,110 --> 00:19:39,409
to prod the then it you'll do that in

00:19:38,419 --> 00:19:40,809
the shorter amount of time that does

00:19:39,409 --> 00:19:43,010
they actually responded I've email and

00:19:40,809 --> 00:19:44,269
they could just deploy code into

00:19:43,010 --> 00:19:46,940
production like day after day and that's

00:19:44,269 --> 00:19:48,200
a very empowering thing so we knew was

00:19:46,940 --> 00:19:50,029
possible that when we started the

00:19:48,200 --> 00:19:51,770
company that we could achieve this but

00:19:50,029 --> 00:19:53,539
doing it in practice for the past two

00:19:51,770 --> 00:19:55,090
and a half years has been very very like

00:19:53,539 --> 00:19:56,920
something we're very proud of

00:19:55,090 --> 00:19:59,830
and something we process we keep on

00:19:56,920 --> 00:20:01,120
trying to improve so it really has

00:19:59,830 --> 00:20:03,670
change it can change the way that you

00:20:01,120 --> 00:20:05,440
think about your code the scope of the

00:20:03,670 --> 00:20:07,570
thing that you're building or how often

00:20:05,440 --> 00:20:10,090
you how often you make changes or ship

00:20:07,570 --> 00:20:12,190
those changes to your apps and that you

00:20:10,090 --> 00:20:13,500
can do with confidence if you invest in

00:20:12,190 --> 00:20:16,420
the right pieces of infrastructure

00:20:13,500 --> 00:20:25,960
that's 20 minutes on the dot and so

00:20:16,420 --> 00:20:26,980
that's what i prepared thank you and

00:20:25,960 --> 00:20:28,180
there's a break right now so you guys

00:20:26,980 --> 00:20:33,480
have any questions I'd be happy to

00:20:28,180 --> 00:20:33,480
answer them yeah back there

00:20:40,470 --> 00:20:43,220
yes

00:20:47,370 --> 00:20:53,760
so the question is how what's a process

00:20:51,210 --> 00:20:54,870
like onboarding a new engineer and and

00:20:53,760 --> 00:20:57,390
I'm having to get familiar with all

00:20:54,870 --> 00:20:59,640
these services short answer is is that

00:20:57,390 --> 00:21:01,500
they don't need to master all of those

00:20:59,640 --> 00:21:03,180
services they need to understand what

00:21:01,500 --> 00:21:04,290
they do particularly if the service that

00:21:03,180 --> 00:21:06,750
they're building of the thing that

00:21:04,290 --> 00:21:09,570
they're working on depends on that but

00:21:06,750 --> 00:21:13,320
truly it is in truly independent so as a

00:21:09,570 --> 00:21:15,480
real world example Kelly is an engineer

00:21:13,320 --> 00:21:18,059
of ours I remember on day three she had

00:21:15,480 --> 00:21:20,700
spun up a spun up a service of her own

00:21:18,059 --> 00:21:23,070
right I mean there's no way in Hades

00:21:20,700 --> 00:21:26,670
that she had mastered the entire scope

00:21:23,070 --> 00:21:29,309
of our infrastructure from A to Z but

00:21:26,670 --> 00:21:31,770
she was able to create a service and

00:21:29,309 --> 00:21:33,840
that is used in production today so it

00:21:31,770 --> 00:21:36,240
doesn't it actually helps quite a bit

00:21:33,840 --> 00:21:38,790
you don't have to you don't have to

00:21:36,240 --> 00:21:40,679
master all those you know all existing

00:21:38,790 --> 00:21:46,460
59 services which is the number when she

00:21:40,679 --> 00:21:46,460
joined right good question a yes

00:21:56,289 --> 00:21:59,870
so the questions were kind of like the

00:21:58,549 --> 00:22:01,520
hierarchy of services and do other

00:21:59,870 --> 00:22:04,450
services depend on other services yes

00:22:01,520 --> 00:22:07,280
that does happen so you know dashboard

00:22:04,450 --> 00:22:09,380
which is our website you know uses the

00:22:07,280 --> 00:22:13,100
identity service for instance we have

00:22:09,380 --> 00:22:16,400
yeah everything is a service in our in

00:22:13,100 --> 00:22:18,200
our universe so I think that it's about

00:22:16,400 --> 00:22:19,730
trying to find out whether or not a

00:22:18,200 --> 00:22:21,140
service should stand on its own so we

00:22:19,730 --> 00:22:23,030
actually have had services that have

00:22:21,140 --> 00:22:25,490
grown to the point where we said you

00:22:23,030 --> 00:22:27,080
know what now there is a there is a

00:22:25,490 --> 00:22:29,299
segment there is another service that

00:22:27,080 --> 00:22:31,250
could use a subset of this functionality

00:22:29,299 --> 00:22:32,510
here and then we splintered that off

00:22:31,250 --> 00:22:35,299
right but that kind of has to meet a

00:22:32,510 --> 00:22:37,100
minimum criteria before you know you

00:22:35,299 --> 00:22:39,260
know we're not we're not microservices

00:22:37,100 --> 00:22:41,059
crazy where we just try to take like if

00:22:39,260 --> 00:22:43,039
it's a unique operation for a particular

00:22:41,059 --> 00:22:44,809
service you just keep their within that

00:22:43,039 --> 00:22:46,130
service right within an existing code

00:22:44,809 --> 00:22:47,990
base you're not necessarily going to

00:22:46,130 --> 00:22:50,390
splinter off everything so you had you

00:22:47,990 --> 00:22:52,309
know proceed with with good planning

00:22:50,390 --> 00:22:59,120
right and reason as to why you want to

00:22:52,309 --> 00:23:00,620
have a separate service yes what kind of

00:22:59,120 --> 00:23:03,650
data sizes are we transferring between

00:23:00,620 --> 00:23:05,630
the services um they're fairly small I

00:23:03,650 --> 00:23:10,909
mean we're talking the game yo these are

00:23:05,630 --> 00:23:12,679
all you know very very you know fairly I

00:23:10,909 --> 00:23:15,710
can't give you an exact number but in

00:23:12,679 --> 00:23:17,419
the kilobytes you know of HTTP requests

00:23:15,710 --> 00:23:20,320
with traditionally JSON data going back

00:23:17,419 --> 00:23:20,320
and forth yep

00:23:30,150 --> 00:23:35,610
yeah the question is about authorization

00:23:32,520 --> 00:23:38,640
on the services and that's something

00:23:35,610 --> 00:23:47,970
that I can't answer out loud but yeah

00:23:38,640 --> 00:23:51,210
I'd be happy to talk to you offline yeah

00:23:47,970 --> 00:23:54,320
so the question was HTTP or HTTPS that's

00:23:51,210 --> 00:23:56,160
another thing that's a great question

00:23:54,320 --> 00:23:57,930
internally weather and sound I mean

00:23:56,160 --> 00:23:59,190
again I get to walk off stage we can go

00:23:57,930 --> 00:24:03,600
look at the code ourselves and take a

00:23:59,190 --> 00:24:05,640
peek so yeah it's now this is all

00:24:03,600 --> 00:24:08,550
internal traffic right so the

00:24:05,640 --> 00:24:10,110
requirements for HTTPS going in between

00:24:08,550 --> 00:24:13,380
our infrastructure probably wouldn't be

00:24:10,110 --> 00:24:16,680
required but that being said I you know

00:24:13,380 --> 00:24:20,670
it really could be either hmm any other

00:24:16,680 --> 00:24:22,850
questions great well thanks for coming

00:24:20,670 --> 00:24:22,850

YouTube URL: https://www.youtube.com/watch?v=USXSnfilG4g


