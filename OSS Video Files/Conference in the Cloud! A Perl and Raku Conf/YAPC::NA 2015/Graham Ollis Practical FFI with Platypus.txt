Title: Graham Ollis Practical FFI with Platypus
Publication date: 2015-06-16
Playlist: YAPC::NA 2015
Description: 
	
Captions: 
	00:00:00,000 --> 00:00:02,340
going to talk to you today about a

00:00:01,110 --> 00:00:07,140
little project I've been working on

00:00:02,340 --> 00:00:12,330
called platypus it sort of makes fi a

00:00:07,140 --> 00:00:15,599
bit more practical in my opinion so just

00:00:12,330 --> 00:00:17,820
as an overview fi or foreign funding

00:00:15,599 --> 00:00:19,949
interface is a mechanism by which a

00:00:17,820 --> 00:00:21,390
program written in one programming

00:00:19,949 --> 00:00:24,570
language can call routines or make use

00:00:21,390 --> 00:00:26,519
of services written in another and so if

00:00:24,570 --> 00:00:28,080
you've been doing pearl for any length

00:00:26,519 --> 00:00:31,439
of time you probably know that we have

00:00:28,080 --> 00:00:35,730
one of those called excess and it's it's

00:00:31,439 --> 00:00:37,920
okay if you if you want to do that and

00:00:35,730 --> 00:00:41,129
you you're going to call C or C++ you

00:00:37,920 --> 00:00:43,920
can do that in practice though ffi

00:00:41,129 --> 00:00:46,230
refers to calling a dynamic library a

00:00:43,920 --> 00:00:50,610
shared object written in a compiled

00:00:46,230 --> 00:00:54,620
language like C rust Fortran Pascal

00:00:50,610 --> 00:00:56,940
whatever compiled language from a

00:00:54,620 --> 00:00:59,940
scripting or virtual machine language so

00:00:56,940 --> 00:01:04,890
like Perl Python Ruby Java that kind of

00:00:59,940 --> 00:01:07,020
thing I using lib ffi which is they've

00:01:04,890 --> 00:01:08,520
done it's a separate project they don't

00:01:07,020 --> 00:01:10,229
a lot of work to make sure that works on

00:01:08,520 --> 00:01:13,950
just about any platform that you can

00:01:10,229 --> 00:01:17,759
think of and we've actually had ffi

00:01:13,950 --> 00:01:19,740
available in some forms in Sipan for a

00:01:17,759 --> 00:01:22,920
long time but the ones that i'm going to

00:01:19,740 --> 00:01:25,350
focus on our ffi raw which i used to

00:01:22,920 --> 00:01:27,840
implement some lib archive bindings and

00:01:25,350 --> 00:01:29,790
platypus which addresses some of the

00:01:27,840 --> 00:01:35,939
issues that that I had when I was

00:01:29,790 --> 00:01:39,390
writing those bindings so ffi raw is is

00:01:35,939 --> 00:01:43,079
is a Sipan library that allows you to

00:01:39,390 --> 00:01:47,579
create a a pearl object that represents

00:01:43,079 --> 00:01:50,250
a function inside a dynamic library

00:01:47,579 --> 00:01:51,930
shared object so you give it the the

00:01:50,250 --> 00:01:54,740
library name the name of the function

00:01:51,930 --> 00:01:58,170
and the function significant signature

00:01:54,740 --> 00:02:00,329
excuse me and then you can call it using

00:01:58,170 --> 00:02:03,840
the call method so this is a bit awkward

00:02:00,329 --> 00:02:05,610
you have to if you want somebody use

00:02:03,840 --> 00:02:09,599
your bindings you have to wrap that

00:02:05,610 --> 00:02:11,250
around some other interface the way the

00:02:09,599 --> 00:02:13,260
big difference in the way platypus works

00:02:11,250 --> 00:02:13,980
is it's it's an object-oriented

00:02:13,260 --> 00:02:17,069
interface

00:02:13,980 --> 00:02:19,319
but now instead of the object

00:02:17,069 --> 00:02:22,110
representing the function it represents

00:02:19,319 --> 00:02:25,769
the library and you use the attached

00:02:22,110 --> 00:02:28,319
method to attach your functions into

00:02:25,769 --> 00:02:31,379
pearl space so now this is the same code

00:02:28,319 --> 00:02:34,230
basically except for I'm attaching the

00:02:31,379 --> 00:02:36,450
fdm function and calling it just like a

00:02:34,230 --> 00:02:38,489
regular pearl subroutine and you can

00:02:36,450 --> 00:02:40,680
export this into your collars namespace

00:02:38,489 --> 00:02:42,120
and they can use it without even really

00:02:40,680 --> 00:02:46,230
knowing that the using f of I or

00:02:42,120 --> 00:02:47,519
whatever and this actually has some

00:02:46,230 --> 00:02:50,849
performance benefits which we'll get

00:02:47,519 --> 00:02:52,200
into invited so why would you want to

00:02:50,849 --> 00:02:53,400
use this instead of like I said we have

00:02:52,200 --> 00:02:56,099
excess why you would you want to use

00:02:53,400 --> 00:02:59,099
this well it's a bit more portable it

00:02:56,099 --> 00:03:02,459
and this isn't this is a slide that I

00:02:59,099 --> 00:03:04,410
borrowed from a ruby talk that somebody

00:03:02,459 --> 00:03:06,959
gave some years back and basically in

00:03:04,410 --> 00:03:09,569
the Ruby world they have multiple

00:03:06,959 --> 00:03:11,579
implementations of Ruby and I showed

00:03:09,569 --> 00:03:13,769
this actually it in d.c Baltimore

00:03:11,579 --> 00:03:15,180
workshop and the somebody in the

00:03:13,769 --> 00:03:17,609
audience explained to me that this is

00:03:15,180 --> 00:03:21,810
actually small potatoes they've got like

00:03:17,609 --> 00:03:23,010
way more versions of Ruby depending on

00:03:21,810 --> 00:03:26,130
you know the appropriateness of the

00:03:23,010 --> 00:03:29,220
environment but the idea is that you can

00:03:26,130 --> 00:03:30,810
implement your application on one of

00:03:29,220 --> 00:03:33,389
these platforms and it should work on

00:03:30,810 --> 00:03:38,690
any of them because they all provide the

00:03:33,389 --> 00:03:40,919
same fi Ruby level interface and the

00:03:38,690 --> 00:03:44,400
other way it's a bit more portable is

00:03:40,919 --> 00:03:46,590
I've actually taken Ruby ffi libraries

00:03:44,400 --> 00:03:47,910
that have been interesting and ivory

00:03:46,590 --> 00:03:50,430
implemented them in Perl and that's

00:03:47,910 --> 00:03:52,769
pretty easy to do I've even taken some

00:03:50,430 --> 00:03:55,799
of my lib archive stuff and ported to

00:03:52,769 --> 00:03:59,180
Scylla so I think the what I'm trying to

00:03:55,799 --> 00:04:01,829
say is the the the technique is

00:03:59,180 --> 00:04:07,440
applicable to more than just pearl

00:04:01,829 --> 00:04:11,069
whereas I think pearl if you're using

00:04:07,440 --> 00:04:13,500
excess this is the pearl excess man page

00:04:11,069 --> 00:04:14,609
and if you want to do serious stuff

00:04:13,500 --> 00:04:16,410
you're going to become familiar with

00:04:14,609 --> 00:04:18,329
this and it's a lot of reading to do and

00:04:16,410 --> 00:04:22,469
it's not really applicable to anything

00:04:18,329 --> 00:04:24,080
but pearl in fact there's some other man

00:04:22,469 --> 00:04:26,379
pages you're going to have to look at so

00:04:24,080 --> 00:04:31,460
it's up to you but you

00:04:26,379 --> 00:04:33,229
we want to do so the question that often

00:04:31,460 --> 00:04:36,289
people ask me is what is it fast enough

00:04:33,229 --> 00:04:38,629
how does it perform and it's a good

00:04:36,289 --> 00:04:42,080
question because the obviously the

00:04:38,629 --> 00:04:45,199
current implementation of platypus and F

00:04:42,080 --> 00:04:48,080
of I raw are implemented using excess so

00:04:45,199 --> 00:04:49,879
it's you know it is sort of an extra

00:04:48,080 --> 00:04:53,599
layer there is going to be a little bit

00:04:49,879 --> 00:04:54,889
of overhead because of that so I had

00:04:53,599 --> 00:04:57,349
three principles when I was building

00:04:54,889 --> 00:04:58,759
platypus just to keep in mind because

00:04:57,349 --> 00:05:02,240
that the main thing is to make the thing

00:04:58,759 --> 00:05:04,780
easy to use and but to keep in mind at

00:05:02,240 --> 00:05:07,729
the same time to keep it relatively fast

00:05:04,780 --> 00:05:09,409
one thing that I did was I'm attaching

00:05:07,729 --> 00:05:11,419
functions as perl subroutines which is

00:05:09,409 --> 00:05:12,800
what i showed you it's a interface

00:05:11,419 --> 00:05:16,849
benefit it actually turns out to be a

00:05:12,800 --> 00:05:19,190
big performance benefit as well because

00:05:16,849 --> 00:05:20,629
there's no object oriented I'm

00:05:19,190 --> 00:05:23,690
allocating memory on the stack we're

00:05:20,629 --> 00:05:27,349
possible because Malik is can be

00:05:23,690 --> 00:05:30,050
expensive and I wrote some benchmarks to

00:05:27,349 --> 00:05:31,990
test out as I make it erupt changes to

00:05:30,050 --> 00:05:37,789
see if make sure that I'm not losing any

00:05:31,990 --> 00:05:41,690
I'm not losing any speed and the results

00:05:37,789 --> 00:05:43,729
were pretty good this is one benchmark

00:05:41,690 --> 00:05:46,940
that I ran I ran a bunch but this is

00:05:43,729 --> 00:05:52,129
they pretty much were very similar just

00:05:46,940 --> 00:05:54,500
in terms of the the the actual times but

00:05:52,129 --> 00:05:56,690
the Platypus version is as you can see

00:05:54,500 --> 00:05:59,930
it's about 12% within twelve percent of

00:05:56,690 --> 00:06:02,690
the excess version and just as a thought

00:05:59,930 --> 00:06:04,789
experiment I also wrote an

00:06:02,690 --> 00:06:07,669
implementation using excess that was

00:06:04,789 --> 00:06:11,150
object oriented so it's essentially like

00:06:07,669 --> 00:06:14,199
the FFI raw version in that it sort of

00:06:11,150 --> 00:06:16,879
injects an extra object oriented call

00:06:14,199 --> 00:06:21,289
and it's much it's much much slower than

00:06:16,879 --> 00:06:22,550
the Platypus version so it's kind of

00:06:21,289 --> 00:06:24,199
silly though right it's like comparing

00:06:22,550 --> 00:06:28,009
apples and oranges object-oriented

00:06:24,199 --> 00:06:30,879
programming is not you know ffi but I

00:06:28,009 --> 00:06:35,360
just wanted to put it in there too as a

00:06:30,879 --> 00:06:38,270
something to keep in mind if you're

00:06:35,360 --> 00:06:39,710
saying that f of i is too slow and then

00:06:38,270 --> 00:06:41,660
you're never going to use it

00:06:39,710 --> 00:06:42,920
you should also say that object-oriented

00:06:41,660 --> 00:06:47,180
programming is too slow and you

00:06:42,920 --> 00:06:49,010
shouldn't ever use it you know things

00:06:47,180 --> 00:06:52,550
are appropriate in appropriate places

00:06:49,010 --> 00:06:54,050
and if the thing can solve you some

00:06:52,550 --> 00:06:58,670
programmer time it may be worth a few

00:06:54,050 --> 00:07:00,980
cycles benchmarks so benchmarks I think

00:06:58,670 --> 00:07:04,340
Mark Twain said that the three types of

00:07:00,980 --> 00:07:06,980
benchmarks sorry three types of lies I

00:07:04,340 --> 00:07:16,280
just gave away the joke lies damned lies

00:07:06,980 --> 00:07:18,980
and benchmarks haha sorry so but what

00:07:16,280 --> 00:07:21,910
about real application so Dylan ported

00:07:18,980 --> 00:07:25,880
his EMQ ffi from FY raw to platypus

00:07:21,910 --> 00:07:27,830
which was great because it was a it gave

00:07:25,880 --> 00:07:30,770
us a real application to see how it

00:07:27,830 --> 00:07:32,930
performed and he said that it was a huge

00:07:30,770 --> 00:07:36,320
improvement over the FFI raw version and

00:07:32,930 --> 00:07:40,130
he cited the ability to attach functions

00:07:36,320 --> 00:07:41,780
as her the killer feature a platypus he

00:07:40,130 --> 00:07:43,820
said that it was his version was about

00:07:41,780 --> 00:07:46,520
ten times faster than the platypus sorry

00:07:43,820 --> 00:07:48,410
the Python implementation and his

00:07:46,520 --> 00:07:52,070
estimate was it was within about thirty

00:07:48,410 --> 00:07:55,850
percent of the excess implementation so

00:07:52,070 --> 00:07:58,070
which may seem like a lot maybe but on

00:07:55,850 --> 00:07:59,990
the other hand the sea implementation

00:07:58,070 --> 00:08:02,180
was much faster than the excess

00:07:59,990 --> 00:08:03,740
implementation so really if raw

00:08:02,180 --> 00:08:05,690
performance is the only thing that

00:08:03,740 --> 00:08:10,730
you're going to consider write it and

00:08:05,690 --> 00:08:12,260
see so now we've talked about

00:08:10,730 --> 00:08:13,850
performance the next thing I'm just

00:08:12,260 --> 00:08:17,000
going to do sort of vignettes here

00:08:13,850 --> 00:08:18,250
little short subjects really to ffi the

00:08:17,000 --> 00:08:23,360
next thing i want to talk about is

00:08:18,250 --> 00:08:28,340
records so structured data it's a common

00:08:23,360 --> 00:08:31,850
way of passing information in NC it sort

00:08:28,340 --> 00:08:33,790
of exposes your your innards it's kind

00:08:31,850 --> 00:08:35,810
of not a very nice way to pass around

00:08:33,790 --> 00:08:37,520
information but it is sort of necessary

00:08:35,810 --> 00:08:41,810
you're going to interface with C

00:08:37,520 --> 00:08:45,140
libraries so in order to do that I

00:08:41,810 --> 00:08:48,380
created an FFI platypus record interface

00:08:45,140 --> 00:08:51,980
and what it does is you specify a layout

00:08:48,380 --> 00:08:52,840
of the types that are names and types

00:08:51,980 --> 00:08:55,450
that are in

00:08:52,840 --> 00:09:01,150
the record and then you can declare it

00:08:55,450 --> 00:09:02,860
as a type and then when you're attaching

00:09:01,150 --> 00:09:05,800
the function you can set you can use

00:09:02,860 --> 00:09:07,540
that type as an argument type and now my

00:09:05,800 --> 00:09:12,900
local time function will return one of

00:09:07,540 --> 00:09:17,380
these TM objects and I can access the

00:09:12,900 --> 00:09:20,380
the HD the fields using access or

00:09:17,380 --> 00:09:24,070
attributes there's some other ways you

00:09:20,380 --> 00:09:25,780
can do this but this is sort of the nice

00:09:24,070 --> 00:09:27,550
thing about this is it takes care of all

00:09:25,780 --> 00:09:31,570
the alignment issues and stuff for you

00:09:27,550 --> 00:09:33,700
so it makes things simple so records is

00:09:31,570 --> 00:09:35,080
just one area i use it as an example of

00:09:33,700 --> 00:09:37,360
kind of one of the neat things that

00:09:35,080 --> 00:09:40,300
we've done there's other things you have

00:09:37,360 --> 00:09:41,740
to deal with when you're you know

00:09:40,300 --> 00:09:44,740
talking to see you have to deal with

00:09:41,740 --> 00:09:47,950
strings pointers to integers like basic

00:09:44,740 --> 00:09:51,970
types floats that kind of thing a raise

00:09:47,950 --> 00:09:53,500
of those types callbacks and we also

00:09:51,970 --> 00:09:56,650
have custom types so there's a lot of

00:09:53,500 --> 00:09:58,570
ways to deal with with types that I

00:09:56,650 --> 00:10:02,560
don't actually see in a lot of other ffi

00:09:58,570 --> 00:10:05,130
implementations so it's kind of neat the

00:10:02,560 --> 00:10:08,080
other thing that I wanted to touch on is

00:10:05,130 --> 00:10:09,190
the foreign language support is it

00:10:08,080 --> 00:10:10,210
something I'm kind of excited about

00:10:09,190 --> 00:10:13,990
because I'm interested in other

00:10:10,210 --> 00:10:15,760
languages but say you have a compiled

00:10:13,990 --> 00:10:18,460
new hot new compiled language called

00:10:15,760 --> 00:10:20,970
kangaroo and there's a library

00:10:18,460 --> 00:10:24,400
implemented in it you called lib Skippy

00:10:20,970 --> 00:10:26,830
so what what you can do is you can

00:10:24,400 --> 00:10:29,410
create a foreign language by a plug-in

00:10:26,830 --> 00:10:31,630
called foi platypus line kangaroo and

00:10:29,410 --> 00:10:34,450
this will define the types in the

00:10:31,630 --> 00:10:37,960
language and nem name mangling that is

00:10:34,450 --> 00:10:40,300
going on and then you can write your

00:10:37,960 --> 00:10:42,190
Skippy ffi without really having to

00:10:40,300 --> 00:10:44,350
worry about see because you're not

00:10:42,190 --> 00:10:48,730
working and see anymore you're working

00:10:44,350 --> 00:10:50,950
in kangaroo and I've so why not use

00:10:48,730 --> 00:10:53,410
inline kangaroo well obviously it

00:10:50,950 --> 00:10:55,750
doesn't exist it's it's a little bit

00:10:53,410 --> 00:10:57,820
harder to implement you have to you have

00:10:55,750 --> 00:10:59,440
to write a parser right every inline

00:10:57,820 --> 00:11:01,900
language that you want to support you

00:10:59,440 --> 00:11:05,110
basically have to almost reimplement the

00:11:01,900 --> 00:11:05,810
language itself it's also excess under

00:11:05,110 --> 00:11:07,970
the hood

00:11:05,810 --> 00:11:10,760
there's extra layers the debug when

00:11:07,970 --> 00:11:12,529
something goes awry it's also tied to

00:11:10,760 --> 00:11:16,540
the current implementation of pro 5

00:11:12,529 --> 00:11:16,540
which may or may not be a good thing

00:11:16,930 --> 00:11:26,779
I've written a couple of these already

00:11:20,950 --> 00:11:28,820
excuse me one is the the Fortran and as

00:11:26,779 --> 00:11:32,000
you can see here when I attach the add

00:11:28,820 --> 00:11:37,250
function i'm using the fortran integer

00:11:32,000 --> 00:11:41,270
type instead of the sea int type and

00:11:37,250 --> 00:11:42,920
it's a small thing but it's it reduces

00:11:41,270 --> 00:11:43,760
the cognitive load on your developer you

00:11:42,920 --> 00:11:45,050
know they don't have to worry about

00:11:43,760 --> 00:11:46,520
three language they just have to worry

00:11:45,050 --> 00:11:49,970
about pearl and Fortran those are the

00:11:46,520 --> 00:11:51,770
ones that they care about the other

00:11:49,970 --> 00:11:53,540
thing that this does that you can't see

00:11:51,770 --> 00:11:55,730
is that on some platforms Fortran

00:11:53,540 --> 00:12:00,350
actually inserts an underscore in the

00:11:55,730 --> 00:12:01,730
function name so and this the the

00:12:00,350 --> 00:12:05,180
foreign language program takes care of

00:12:01,730 --> 00:12:06,529
that and the other thing kind of

00:12:05,180 --> 00:12:11,600
interesting not related to this

00:12:06,529 --> 00:12:15,700
specifically but in Fortran the the call

00:12:11,600 --> 00:12:18,080
the the arguments are called by

00:12:15,700 --> 00:12:21,380
reference not call it call by value like

00:12:18,080 --> 00:12:23,089
they are NC so when I declare the

00:12:21,380 --> 00:12:25,760
function I use a pointer to integer

00:12:23,089 --> 00:12:31,190
instead of a regular integer I pass in

00:12:25,760 --> 00:12:34,310
references to integers rather than just

00:12:31,190 --> 00:12:38,570
the integers themselves another one that

00:12:34,310 --> 00:12:41,030
I wrote was a rust language plugin rust

00:12:38,570 --> 00:12:43,000
is kind of a you know and it's a an

00:12:41,030 --> 00:12:50,320
interesting language it's very it's a

00:12:43,000 --> 00:12:51,920
focuses on safety and giving you grief

00:12:50,320 --> 00:12:53,959
making sure that your code is

00:12:51,920 --> 00:13:01,490
appropriate and safe and stuff like that

00:12:53,959 --> 00:13:03,830
and so this is this is just a program

00:13:01,490 --> 00:13:06,260
that are a module basically that it

00:13:03,830 --> 00:13:09,920
implements at points and lines and some

00:13:06,260 --> 00:13:13,459
code to compute the length of that that

00:13:09,920 --> 00:13:15,290
line and using the foreign language

00:13:13,459 --> 00:13:17,870
plugin for rust it's pretty easy to use

00:13:15,290 --> 00:13:19,459
so again here i'm using the rust types

00:13:17,870 --> 00:13:25,790
by 32

00:13:19,459 --> 00:13:27,829
f 64 instead of the sea types this one

00:13:25,790 --> 00:13:31,220
doesn't handle name mangling at least

00:13:27,829 --> 00:13:34,399
not yet but there's no reason why I

00:13:31,220 --> 00:13:37,699
couldn't if that were something we

00:13:34,399 --> 00:13:39,949
decided that we wanted to do there's

00:13:37,699 --> 00:13:41,990
also a C++ one which is actually pretty

00:13:39,949 --> 00:13:44,779
fancy it does the main aim mangling you

00:13:41,990 --> 00:13:47,119
can actually create C++ object and call

00:13:44,779 --> 00:13:50,059
methods on it without having to worry

00:13:47,119 --> 00:13:52,939
about you know what the actual function

00:13:50,059 --> 00:13:55,970
name is it doesn't really make for a

00:13:52,939 --> 00:13:58,309
very interesting slide so there's an

00:13:55,970 --> 00:14:01,249
example library that I wrote called

00:13:58,309 --> 00:14:05,509
color ffi that lives on Sipan if you're

00:14:01,249 --> 00:14:06,949
interested so those are kind of the

00:14:05,509 --> 00:14:09,619
vignettes that I wanted to show but I

00:14:06,949 --> 00:14:12,889
also wanted to make a plug for my vision

00:14:09,619 --> 00:14:14,959
of the future which involves obviously

00:14:12,889 --> 00:14:16,429
not flying cars but flying Platypus

00:14:14,959 --> 00:14:21,920
vehicles because that would be pretty

00:14:16,429 --> 00:14:24,110
cool but actually I kind of like that

00:14:21,920 --> 00:14:25,970
that chart that I saw before I showed

00:14:24,110 --> 00:14:27,679
you before with Ruby I think that it

00:14:25,970 --> 00:14:30,980
would be pretty cool if we had that kind

00:14:27,679 --> 00:14:33,259
of technology in Perl as well so imagine

00:14:30,980 --> 00:14:35,179
if I don't know somebody forked parole

00:14:33,259 --> 00:14:38,319
or or if there was an alternate

00:14:35,179 --> 00:14:41,119
implementation written in Java or even

00:14:38,319 --> 00:14:44,119
it is actually possible to there's a

00:14:41,119 --> 00:14:49,309
there's an inline pro 5 now for perl 6

00:14:44,119 --> 00:14:51,410
and i expect experimented with actually

00:14:49,309 --> 00:14:54,829
calling platypus from perl 6 using that

00:14:51,410 --> 00:14:56,600
and it worked just fine so you can in

00:14:54,829 --> 00:14:59,199
theory you know write your bindings in

00:14:56,600 --> 00:15:01,519
one of these versions of pearl and

00:14:59,199 --> 00:15:11,990
expect it to work in multiple different

00:15:01,519 --> 00:15:18,860
places so that is mostly it I'm Graham

00:15:11,990 --> 00:15:23,209
I'm on you know Sipan and and github in

00:15:18,860 --> 00:15:25,249
all those fun things if you are if

00:15:23,209 --> 00:15:26,509
you're using platypus and and you're

00:15:25,249 --> 00:15:28,279
having any trouble with it let me know

00:15:26,509 --> 00:15:30,410
open an issue on the github I'm pretty

00:15:28,279 --> 00:15:31,440
responsive I'm interested in getting

00:15:30,410 --> 00:15:34,260
this

00:15:31,440 --> 00:15:37,560
better and better and faster and all

00:15:34,260 --> 00:15:39,950
those good things does anybody have any

00:15:37,560 --> 00:15:39,950
questions

00:15:56,490 --> 00:16:02,019
right so if you so the question is how

00:15:59,709 --> 00:16:03,699
does that are the types converted

00:16:02,019 --> 00:16:06,040
correctly or course correctly when you

00:16:03,699 --> 00:16:08,410
when you pass like a string form of a

00:16:06,040 --> 00:16:13,209
number into a double or an integer value

00:16:08,410 --> 00:16:14,680
is that yeah it uses the under the hood

00:16:13,209 --> 00:16:17,559
it uses the excess convert the same

00:16:14,680 --> 00:16:19,959
access conversion macro I can't run what

00:16:17,559 --> 00:16:22,899
it is so if you provide double quote you

00:16:19,959 --> 00:16:27,249
know 1.0 double quote to a function that

00:16:22,899 --> 00:16:30,899
takes a doubled and that will work so if

00:16:27,249 --> 00:16:33,899
you if you pressed a reference to a

00:16:30,899 --> 00:16:39,879
string that contains a number like that

00:16:33,899 --> 00:16:44,559
into a function that modifies the value

00:16:39,879 --> 00:16:46,389
it actually modifies the thing that's

00:16:44,559 --> 00:16:49,720
being referred to so it would come back

00:16:46,389 --> 00:16:52,629
as a as a float or an integer instead of

00:16:49,720 --> 00:16:55,300
a string so there's but mostly it's

00:16:52,629 --> 00:16:56,649
pretty smart I think about it does more

00:16:55,300 --> 00:16:58,660
or less the right thing within the

00:16:56,649 --> 00:17:01,870
confines of you know keeping it

00:16:58,660 --> 00:17:04,050
relatively fast that make sense anybody

00:17:01,870 --> 00:17:04,050
else

00:17:09,440 --> 00:17:16,829
um I mean I haven't noticed any

00:17:13,860 --> 00:17:18,660
particular I mean hasn't been so the

00:17:16,829 --> 00:17:22,050
biggest library that I have implemented

00:17:18,660 --> 00:17:23,790
was with was the lib archive and that

00:17:22,050 --> 00:17:25,350
has like three hundred some functions

00:17:23,790 --> 00:17:28,130
and I implement almost all of them and

00:17:25,350 --> 00:17:33,120
I'm using that case I'm using FF I raw

00:17:28,130 --> 00:17:35,010
but it's it's not it's it's it's

00:17:33,120 --> 00:17:37,080
completely usable for command line I

00:17:35,010 --> 00:17:39,290
haven't noticed any particular latency

00:17:37,080 --> 00:17:42,180
in terms of that kind of thing but I

00:17:39,290 --> 00:17:44,550
mean it is you are doing work when your

00:17:42,180 --> 00:17:49,130
startup so it may be a concern

00:17:44,550 --> 00:17:53,660
potentially did I repeat the question

00:17:49,130 --> 00:17:53,660
anyway okay yeah

00:18:02,650 --> 00:18:07,930
so the question is how do you how does

00:18:04,970 --> 00:18:10,610
how do you find the libraries and

00:18:07,930 --> 00:18:13,880
especially on Windows where that can be

00:18:10,610 --> 00:18:18,880
problematic there is a separate module

00:18:13,880 --> 00:18:22,520
called FF I check lib it's based on the

00:18:18,880 --> 00:18:24,470
sort of the develop that's been in Sipan

00:18:22,520 --> 00:18:29,630
for a while and it it's supposed to do

00:18:24,470 --> 00:18:31,550
the same kind of thing it it just it

00:18:29,630 --> 00:18:33,830
does just find like the first one in

00:18:31,550 --> 00:18:37,280
your path which is more or less what the

00:18:33,830 --> 00:18:39,410
what would happen in excess you could if

00:18:37,280 --> 00:18:42,080
you had specific requirements you could

00:18:39,410 --> 00:18:47,720
also implement your own and specified

00:18:42,080 --> 00:18:57,980
the the full path to the library anybody

00:18:47,720 --> 00:19:01,130
else get you yes so the question is

00:18:57,980 --> 00:19:02,960
there's a interface for callbacks and

00:19:01,130 --> 00:19:06,320
what is the what is the interface for

00:19:02,960 --> 00:19:07,910
that like look look like so when you

00:19:06,320 --> 00:19:09,800
define the function it's a little bit

00:19:07,910 --> 00:19:12,620
different than FF I raw actually so f fi

00:19:09,800 --> 00:19:17,450
raw you actually create an object

00:19:12,620 --> 00:19:19,490
wrapper around a pearl function which

00:19:17,450 --> 00:19:22,220
then you pass into any function that

00:19:19,490 --> 00:19:25,730
takes a pointer in platypus the way it

00:19:22,220 --> 00:19:29,150
works is you actually define the

00:19:25,730 --> 00:19:32,060
function type as an argument type so if

00:19:29,150 --> 00:19:33,710
the if the if the if the callback takes

00:19:32,060 --> 00:19:35,450
and it two integers for example you

00:19:33,710 --> 00:19:36,830
would actually create a type that

00:19:35,450 --> 00:19:38,300
represents a callback that takes two

00:19:36,830 --> 00:19:40,670
integers and use that type when you're

00:19:38,300 --> 00:19:45,830
defining when you're attaching the

00:19:40,670 --> 00:19:49,640
function and then you can actually you

00:19:45,830 --> 00:19:51,140
can't you you can't quite just pass in a

00:19:49,640 --> 00:19:52,340
pearl subroutine but you can almost do

00:19:51,140 --> 00:19:54,500
it there's a there's a little wrapper

00:19:52,340 --> 00:19:55,850
that basically attaches the kind of

00:19:54,500 --> 00:19:59,390
thing that you need but it's much

00:19:55,850 --> 00:20:01,900
simpler there's examples in the

00:19:59,390 --> 00:20:05,240
documentation if you want to take a look

00:20:01,900 --> 00:20:07,840
anybody else oh I'm out of time ok so

00:20:05,240 --> 00:20:10,790
thank you again just let me know if you

00:20:07,840 --> 00:20:14,560
if you have any questions or you can

00:20:10,790 --> 00:20:14,560

YouTube URL: https://www.youtube.com/watch?v=XjvpxfVJLNg


