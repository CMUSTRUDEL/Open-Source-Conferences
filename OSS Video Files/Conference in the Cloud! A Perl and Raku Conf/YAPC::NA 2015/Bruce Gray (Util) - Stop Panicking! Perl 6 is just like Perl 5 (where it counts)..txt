Title: Bruce Gray (Util) - Stop Panicking! Perl 6 is just like Perl 5 (where it counts).
Publication date: 2015-06-16
Playlist: YAPC::NA 2015
Description: 
	Ballroom A - Little America Hotel
Captions: 
	00:00:29,460 --> 00:00:34,750
before I get started if you're going to

00:00:32,439 --> 00:00:36,700
the Perl 6 beginner tutorial tonight and

00:00:34,750 --> 00:00:40,540
you need any help installing roo kudos

00:00:36,700 --> 00:00:42,580
star this is my only talk so after this

00:00:40,540 --> 00:00:46,030
talk I'm available to help anybody that

00:00:42,580 --> 00:00:48,850
needs help with the install yeah got it

00:00:46,030 --> 00:00:54,699
just see me in the hallway or catch me

00:00:48,850 --> 00:01:02,789
anytime but your first I'll try any

00:00:54,699 --> 00:01:05,110
platform please do download the slides

00:01:02,789 --> 00:01:08,020
there are a lot of bonus slides at the

00:01:05,110 --> 00:01:09,220
end and I'm going to go way too fast in

00:01:08,020 --> 00:01:13,140
some sections I've got way too many

00:01:09,220 --> 00:01:17,140
slides and you don't have good timing so

00:01:13,140 --> 00:01:19,390
you'll need the slides this talk has

00:01:17,140 --> 00:01:24,390
been previewed by Atlanta perl mongers

00:01:19,390 --> 00:01:24,390
and I've included some of their comments

00:01:26,789 --> 00:01:34,450
so this talk is stop panicking perl 6 is

00:01:30,790 --> 00:01:39,670
just like / 05 where it counts I am

00:01:34,450 --> 00:01:43,180
Bruce gray util the pearl monks I am NOT

00:01:39,670 --> 00:01:44,170
a member of the Perl 6 design team but I

00:01:43,180 --> 00:01:48,250
have been deep in the implementation

00:01:44,170 --> 00:01:55,049
guts for a long time more importantly on

00:01:48,250 --> 00:01:55,049
the bonus

00:01:56,540 --> 00:02:12,660
but does that make the wolf Larry patra

00:02:01,250 --> 00:02:15,959
or Damian well these talks tend to lead

00:02:12,660 --> 00:02:17,989
to excitement but I'd see people looking

00:02:15,959 --> 00:02:20,850
a little dazed a little glazed little

00:02:17,989 --> 00:02:23,819
shell-shocked after some of the talks

00:02:20,850 --> 00:02:31,380
and I dismissed any worry about that

00:02:23,819 --> 00:02:37,640
until two years ago around three years

00:02:31,380 --> 00:02:41,400
ago time flies it was just one hour I

00:02:37,640 --> 00:02:43,830
had lunch with two very skilled pro/5

00:02:41,400 --> 00:02:46,739
programmers who picked my brain for the

00:02:43,830 --> 00:02:49,470
whole hour on Perl 6 I am an excellent

00:02:46,739 --> 00:02:52,890
communicator at least one on one I don't

00:02:49,470 --> 00:02:55,519
know about right now and at the end of

00:02:52,890 --> 00:03:02,310
the hour their eyes were glazed over and

00:02:55,519 --> 00:03:04,470
I knew something was wrong first thing

00:03:02,310 --> 00:03:12,120
is wrong is you don't need to try to

00:03:04,470 --> 00:03:15,150
learn perl 6 in an hour Rick's going to

00:03:12,120 --> 00:03:22,620
go over just the 522 changes in our

00:03:15,150 --> 00:03:26,850
tomorrow he's no slouch but the other

00:03:22,620 --> 00:03:30,120
problem is we have a a proud and intense

00:03:26,850 --> 00:03:33,980
focus on the new early in the Perl 6

00:03:30,120 --> 00:03:37,200
design process Simon Cozens wrote an RFC

00:03:33,980 --> 00:03:39,920
you one of the first ones pearl should

00:03:37,200 --> 00:03:39,920
stay pearl

00:03:41,300 --> 00:03:47,730
golden opportunity let's not take it

00:03:45,410 --> 00:03:49,980
when your spring cleaning your house you

00:03:47,730 --> 00:03:55,470
don't burn the house down and build them

00:03:49,980 --> 00:03:57,270
all nothing's been burned down perl 6 is

00:03:55,470 --> 00:04:00,780
still pearl in some ways it's more /

00:03:57,270 --> 00:04:04,220
less than / 05 it's so i thought about

00:04:00,780 --> 00:04:09,240
it and it comes to this breakdown

00:04:04,220 --> 00:04:11,850
there's the new which is large but

00:04:09,240 --> 00:04:15,720
completely optional I mean none of us

00:04:11,850 --> 00:04:18,120
use every feature that was added to 512

00:04:15,720 --> 00:04:21,270
or 5 14 or 5 20 or whatever your current

00:04:18,120 --> 00:04:24,870
version that's right i know i don't and

00:04:21,270 --> 00:04:27,690
i read the pearl delta in detail looking

00:04:24,870 --> 00:04:29,310
for the new you don't have to use

00:04:27,690 --> 00:04:34,740
everything that's added to this new

00:04:29,310 --> 00:04:37,290
version of pearl pearl 6 either the

00:04:34,740 --> 00:04:39,870
mandatory changes are minimal I mean

00:04:37,290 --> 00:04:41,880
it's stuff like till day instead of dot

00:04:39,870 --> 00:04:43,770
for concatenation you have to put a calm

00:04:41,880 --> 00:04:46,950
after a sort block it takes about a week

00:04:43,770 --> 00:04:51,000
to get used to I work in Perl 5 and pro

00:04:46,950 --> 00:04:55,550
6 every week it's not a problem it's not

00:04:51,000 --> 00:05:00,060
big what's removed is forgettable

00:04:55,550 --> 00:05:03,540
formats yanked out will be a module get

00:05:00,060 --> 00:05:06,360
pwent get host ENT that whole family

00:05:03,540 --> 00:05:09,210
yanked out no longer in core going to be

00:05:06,360 --> 00:05:15,200
a module that was cluttering up the

00:05:09,210 --> 00:05:20,100
Pearl funk man page anyway and the old

00:05:15,200 --> 00:05:23,130
the old is pearl five Sid jewel scalars

00:05:20,100 --> 00:05:26,340
arrays hashes modules context if while

00:05:23,130 --> 00:05:28,080
have curly braces subs it's all pearl

00:05:26,340 --> 00:05:29,970
five these are all elements that you

00:05:28,080 --> 00:05:31,680
find familiar in Perl 5 they're all

00:05:29,970 --> 00:05:35,630
elements you will find familiar in Perl

00:05:31,680 --> 00:05:40,770
6 at this point Atlanta pro monger said

00:05:35,630 --> 00:05:43,080
you need pie well I like pie and no now

00:05:40,770 --> 00:05:47,940
a pie chart showing the old new to

00:05:43,080 --> 00:05:49,800
remove the changed I can make up a pie

00:05:47,940 --> 00:05:52,680
chart for the changed and old and

00:05:49,800 --> 00:05:53,639
removed but new would require a pie on

00:05:52,680 --> 00:06:05,159
top of that

00:05:53,639 --> 00:06:07,259
hi the put the pie in the face yeah so I

00:06:05,159 --> 00:06:10,199
decided to give this talk on the things

00:06:07,259 --> 00:06:13,229
in Perl 5 that we love neither got

00:06:10,199 --> 00:06:19,349
tweaked to remove a thorn or we turned

00:06:13,229 --> 00:06:23,400
all the way up to 11 for each is great I

00:06:19,349 --> 00:06:26,189
only had the old for loop and see we've

00:06:23,400 --> 00:06:29,789
got them both in Perl 5 the for each is

00:06:26,189 --> 00:06:35,729
an iterative walk over list for is the

00:06:29,789 --> 00:06:39,810
old three expressions e style one now

00:06:35,729 --> 00:06:42,180
you're probably taught that four is the

00:06:39,810 --> 00:06:47,250
three expression form from C and for

00:06:42,180 --> 00:06:49,409
each is iterative form right and that's

00:06:47,250 --> 00:06:52,650
how the compiler knows whether you use

00:06:49,409 --> 00:06:56,270
for or for each which loop guy hits not

00:06:52,650 --> 00:06:56,270
of head shake head something

00:06:58,550 --> 00:07:04,730
there's a spoiler in the audience yes

00:07:02,440 --> 00:07:05,750
that's why we're all taught and that's

00:07:04,730 --> 00:07:07,610
how the examples in the books are

00:07:05,750 --> 00:07:10,790
there's even an example I mean there's

00:07:07,610 --> 00:07:13,490
language in the pearl sin man page to

00:07:10,790 --> 00:07:16,640
that effect it calls one of them the for

00:07:13,490 --> 00:07:18,110
style and one of them the for each but

00:07:16,640 --> 00:07:21,140
the compiler really looks for the

00:07:18,110 --> 00:07:23,750
semicolons pearl best practices says

00:07:21,140 --> 00:07:25,610
just used for for everything use for

00:07:23,750 --> 00:07:31,400
because if the compiler doesn't care why

00:07:25,610 --> 00:07:33,440
should you type more but Larry says the

00:07:31,400 --> 00:07:35,360
similar thing should look similar and

00:07:33,440 --> 00:07:37,340
different things should look distinct

00:07:35,360 --> 00:07:43,060
that's a violation of that's principal

00:07:37,340 --> 00:07:48,040
so pearl six there's no longer the four

00:07:43,060 --> 00:07:51,320
for the c-style one is called loop and

00:07:48,040 --> 00:07:55,280
the iterative one is called for there is

00:07:51,320 --> 00:07:58,220
no for each anymore that's something to

00:07:55,280 --> 00:08:03,110
get used to but it's clearer and less

00:07:58,220 --> 00:08:07,040
confusing by the way the the new for

00:08:03,110 --> 00:08:11,660
doesn't require / ends but the old loop

00:08:07,040 --> 00:08:13,790
does still ranges ranges are great I

00:08:11,660 --> 00:08:18,100
miss someone on in languages that don't

00:08:13,790 --> 00:08:22,220
have them when you want the whole range

00:08:18,100 --> 00:08:25,430
they're less great in very common

00:08:22,220 --> 00:08:29,240
situations I want to go from one up to

00:08:25,430 --> 00:08:31,400
but not including a limit and I have to

00:08:29,240 --> 00:08:33,740
put limit minus do I need friends around

00:08:31,400 --> 00:08:35,660
the limit minus one does everybody

00:08:33,740 --> 00:08:37,160
remember whether you do or you don't

00:08:35,660 --> 00:08:41,900
automatically you don't have to try it

00:08:37,160 --> 00:08:48,440
because I don't sometimes I know yeah I

00:08:41,900 --> 00:08:49,670
dit for the slide yeah it's not hard to

00:08:48,440 --> 00:08:54,350
write but it ought to be clearer because

00:08:49,670 --> 00:08:56,540
that does not show my intent I don't

00:08:54,350 --> 00:08:59,110
want to go to limit minus one I want to

00:08:56,540 --> 00:09:02,240
go up to but not including the limit

00:08:59,110 --> 00:09:04,400
it's worse if the endpoints are constant

00:09:02,240 --> 00:09:06,020
I don't actually want to go from B to

00:09:04,400 --> 00:09:07,760
why there's nothing magic about be

00:09:06,020 --> 00:09:09,200
there's nothing magic about why I want

00:09:07,760 --> 00:09:11,260
to go through the range of the alphabet

00:09:09,200 --> 00:09:14,630
without the endpoint

00:09:11,260 --> 00:09:17,870
so in Perl 6 we have an additional

00:09:14,630 --> 00:09:19,370
syntax on top of the range operator you

00:09:17,870 --> 00:09:21,560
can put a carrot on one side on the

00:09:19,370 --> 00:09:24,140
other side neither or both and it means

00:09:21,560 --> 00:09:27,410
omit one of the end points or both of

00:09:24,140 --> 00:09:29,890
them now what this says is exactly what

00:09:27,410 --> 00:09:29,890
I mean

00:09:35,000 --> 00:09:42,080
data dumper is great and pearl monks so

00:09:40,220 --> 00:09:44,900
many times the fundamental answer the

00:09:42,080 --> 00:09:46,940
question is just look at your data used

00:09:44,900 --> 00:09:48,800
at a dumper and look at it never being

00:09:46,940 --> 00:09:55,370
able to call it be called as a function

00:09:48,800 --> 00:09:59,270
that's 78 method saving the eight

00:09:55,370 --> 00:10:00,860
methods grandfather in as functions and

00:09:59,270 --> 00:10:05,270
you can do it for your methods too if

00:10:00,860 --> 00:10:07,340
that's your API for is great unless

00:10:05,270 --> 00:10:09,380
you're working in at a time like

00:10:07,340 --> 00:10:11,090
sometimes your data is in a flat list

00:10:09,380 --> 00:10:13,670
when somebody should have made an array

00:10:11,090 --> 00:10:17,000
of arrays so it's city state zip city

00:10:13,670 --> 00:10:21,140
state zip city state zip and you can do

00:10:17,000 --> 00:10:23,990
this monstrosity right here where you do

00:10:21,140 --> 00:10:25,430
a flat loop through but you keep track

00:10:23,990 --> 00:10:27,710
of where you are in the loop and

00:10:25,430 --> 00:10:30,680
assigned to the right variable depending

00:10:27,710 --> 00:10:33,200
oh my god don't ever do that the bottom

00:10:30,680 --> 00:10:36,020
one is actually the idiom but its

00:10:33,200 --> 00:10:40,190
destructive it eats up the array as it

00:10:36,020 --> 00:10:46,510
goes but it's much less it's much more

00:10:40,190 --> 00:10:50,660
foolproof there is a module to do this

00:10:46,510 --> 00:10:52,790
in at a time function from list more

00:10:50,660 --> 00:10:54,710
utils but I really don't like the

00:10:52,790 --> 00:11:00,680
interface it feels artificial to me I

00:10:54,710 --> 00:11:03,680
still use it I just don't like it perl 6

00:11:00,680 --> 00:11:06,320
is easy because the iteration variables

00:11:03,680 --> 00:11:10,370
that that would be them like for my eye

00:11:06,320 --> 00:11:14,900
and pearl 5 aren't limited to single one

00:11:10,370 --> 00:11:16,580
so if you say for array and three

00:11:14,900 --> 00:11:18,560
variables then the first time through

00:11:16,580 --> 00:11:19,970
you get the first three the next time

00:11:18,560 --> 00:11:21,339
through you get the next three the next

00:11:19,970 --> 00:11:23,630
time through you get the next three

00:11:21,339 --> 00:11:25,870
which is exactly what's needed in this

00:11:23,630 --> 00:11:25,870
case

00:11:26,780 --> 00:11:36,040
reverse is great both in lists and

00:11:33,320 --> 00:11:36,040
string form

00:11:42,010 --> 00:11:51,430
so what do these do the first ones a

00:11:47,530 --> 00:11:53,650
list of two so given your mind what

00:11:51,430 --> 00:11:57,880
that's going to do and the next one is

00:11:53,650 --> 00:12:00,280
list with one thing in it that's often a

00:11:57,880 --> 00:12:03,280
bug right the third one is a simple

00:12:00,280 --> 00:12:05,940
string right so what's the output y'all

00:12:03,280 --> 00:12:08,440
got it in your head what those should do

00:12:05,940 --> 00:12:13,770
no you don't you can't know what they'll

00:12:08,440 --> 00:12:13,770
do because it's about the context

00:12:18,440 --> 00:12:23,120
you put scalar on the left side of the

00:12:20,690 --> 00:12:25,940
word reverse not on the right side it's

00:12:23,120 --> 00:12:31,880
what's what context the operator I mean

00:12:25,940 --> 00:12:33,800
the function is in it's very tricky so

00:12:31,880 --> 00:12:35,810
this is a source of bugs when people try

00:12:33,800 --> 00:12:37,730
and use reverse it often does not do

00:12:35,810 --> 00:12:41,320
what they wanted to do that reversing a

00:12:37,730 --> 00:12:44,030
list of one is a common one in Perl 6

00:12:41,320 --> 00:12:45,260
for simplicity it's been broken out

00:12:44,030 --> 00:12:47,810
there's no reason for overlap here

00:12:45,260 --> 00:12:53,570
there's three different functions or

00:12:47,810 --> 00:12:56,150
methods reverse 44 list flip for a

00:12:53,570 --> 00:12:59,120
string and if you've ever done reverse

00:12:56,150 --> 00:13:04,160
on a hash and it did what you wanted you

00:12:59,120 --> 00:13:06,080
were lucky invert in Perl 6 does what

00:13:04,160 --> 00:13:07,460
you want it to do even if you don't

00:13:06,080 --> 00:13:09,830
realize right now what you actually want

00:13:07,460 --> 00:13:12,560
to do it does some of what someone else

00:13:09,830 --> 00:13:17,120
I have to talk about that okay for is

00:13:12,560 --> 00:13:19,880
great except when you need the index

00:13:17,120 --> 00:13:25,160
this is a common request for enhancement

00:13:19,880 --> 00:13:26,900
in Perl 5 if I actually need I as I go

00:13:25,160 --> 00:13:30,350
through the list then I can't just

00:13:26,900 --> 00:13:33,590
iterate over the array I have to iterate

00:13:30,350 --> 00:13:35,630
over the indexes of the array which

00:13:33,590 --> 00:13:37,190
means i have to look up the index every

00:13:35,630 --> 00:13:45,560
time through and that feels inefficient

00:13:37,190 --> 00:13:47,660
to me so in Perl 6 there is a dot kv

00:13:45,560 --> 00:13:50,060
method that says give me the key the

00:13:47,660 --> 00:13:54,070
value the key the value in a flat list

00:13:50,060 --> 00:13:54,070
remember I said flat list earlier

00:13:56,980 --> 00:14:04,550
matches up great with this multiple

00:13:59,870 --> 00:14:07,759
alias iteration variable feature so now

00:14:04,550 --> 00:14:11,300
I can walk over it and get the index and

00:14:07,759 --> 00:14:13,250
get that element without look up exactly

00:14:11,300 --> 00:14:19,160
as has been requested for years in Perl

00:14:13,250 --> 00:14:23,420
5 well that actually does exist in Perl

00:14:19,160 --> 00:14:30,410
5 in a way but it's compromised so it's

00:14:23,420 --> 00:14:32,740
not recommended for is great unless

00:14:30,410 --> 00:14:36,110
you're doing aggregates I wrote this

00:14:32,740 --> 00:14:40,670
five minutes before the talk so wish me

00:14:36,110 --> 00:14:43,970
luck in Perl 5 shouldn't be able to see

00:14:40,670 --> 00:14:46,430
the pearl set stuff in pro 5 if you have

00:14:43,970 --> 00:14:48,769
that array of arrays that I was wishing

00:14:46,430 --> 00:14:50,779
for with the city state zip earlier so

00:14:48,769 --> 00:14:52,490
they're actually city state zip in an

00:14:50,779 --> 00:14:55,370
anonymous array city state zip in an

00:14:52,490 --> 00:14:58,310
honest ray then that top one is how you

00:14:55,370 --> 00:15:02,509
might work with it in Perl 5 you have

00:14:58,310 --> 00:15:04,699
the best you can do is a reference and

00:15:02,509 --> 00:15:09,139
then you can dereference the reference

00:15:04,699 --> 00:15:13,519
to break out the array in Perl 6 you can

00:15:09,139 --> 00:15:17,779
have hashes or arrays as the iteration

00:15:13,519 --> 00:15:21,470
alias so in that Perl 6 example that @

00:15:17,779 --> 00:15:23,300
sign a it's taking the array Rev it's

00:15:21,470 --> 00:15:26,089
not actually unpacking it it doesn't do

00:15:23,300 --> 00:15:28,670
the extra work it just knows to treat

00:15:26,089 --> 00:15:31,279
that as an array so I can just use it

00:15:28,670 --> 00:15:34,600
like an array in the next line isn't

00:15:31,279 --> 00:15:34,600
that great yes sir

00:15:37,589 --> 00:15:45,570
I'm going to pretend you didn't say that

00:15:39,640 --> 00:15:48,130
so so I really wish that we had this I

00:15:45,570 --> 00:15:50,080
would find this very useful the more you

00:15:48,130 --> 00:15:51,700
work in multi-dimensional data

00:15:50,080 --> 00:15:57,760
structures the more valuable this kind

00:15:51,700 --> 00:16:01,450
of thing is and you can have it as of a

00:15:57,760 --> 00:16:05,070
few days ago it is in 522 it's not quite

00:16:01,450 --> 00:16:09,310
as nice but it is there you can put a

00:16:05,070 --> 00:16:13,209
backslash dollar a in your my statement

00:16:09,310 --> 00:16:15,750
on a for loop it actually perl 6 you can

00:16:13,209 --> 00:16:18,459
do one better i'll stop pretending now

00:16:15,750 --> 00:16:22,089
you could actually unpack it directly in

00:16:18,459 --> 00:16:24,940
the for statement don't let that stop

00:16:22,089 --> 00:16:28,390
you for future comments though I don't

00:16:24,940 --> 00:16:34,899
want to suppress anything repetition is

00:16:28,390 --> 00:16:37,660
great we have a repeat operator and in

00:16:34,899 --> 00:16:42,930
scalar context if you just want a line

00:16:37,660 --> 00:16:47,709
of 80 dashes it's very straightforward

00:16:42,930 --> 00:16:50,079
if you if you want to repeat a list

00:16:47,709 --> 00:16:52,089
instead of a string then it depends on

00:16:50,079 --> 00:16:55,000
context now I know we had trouble on a

00:16:52,089 --> 00:16:57,070
previous slide but we shouldn't have

00:16:55,000 --> 00:16:59,829
trouble here I mean you can see that the

00:16:57,070 --> 00:17:01,570
first list context when it's going into

00:16:59,829 --> 00:17:03,310
an array therefore it's less context and

00:17:01,570 --> 00:17:05,350
if that's not hard enough if that's not

00:17:03,310 --> 00:17:07,839
enough list context i'm going to put

00:17:05,350 --> 00:17:11,470
parentheses around that so it's

00:17:07,839 --> 00:17:17,650
definitely list context so do I get the

00:17:11,470 --> 00:17:21,189
Z and the Z and the Z is output you

00:17:17,650 --> 00:17:23,350
would think but no you get Z Z Z for

00:17:21,189 --> 00:17:26,919
both of them if you want if you want

00:17:23,350 --> 00:17:28,900
that to be treated as a list because of

00:17:26,919 --> 00:17:32,740
the peculiar rules that are well

00:17:28,900 --> 00:17:35,110
documented but hard to remember you have

00:17:32,740 --> 00:17:40,390
to put parentheses around the z itself

00:17:35,110 --> 00:17:43,419
in Perl 6 is very straightforward we

00:17:40,390 --> 00:17:46,809
have at the X up you don't say 0-3 you

00:17:43,419 --> 00:17:48,880
just say negative 3 well Perl 6 is added

00:17:46,809 --> 00:17:52,150
these prefix up

00:17:48,880 --> 00:17:54,520
Raiders so the plus is numeric

00:17:52,150 --> 00:17:56,110
conversion the till day is string

00:17:54,520 --> 00:18:01,150
conversion and the question mark is

00:17:56,110 --> 00:18:03,100
boolean by the way the tilde is the the

00:18:01,150 --> 00:18:05,050
new concatenation sign you should be

00:18:03,100 --> 00:18:06,910
thinking strings Larry says you should

00:18:05,050 --> 00:18:11,860
think of stitching strings together

00:18:06,910 --> 00:18:14,410
that's why it's a tilde and these are

00:18:11,860 --> 00:18:16,300
important because because of other

00:18:14,410 --> 00:18:18,400
language elements you need to do these

00:18:16,300 --> 00:18:20,050
coercion more often than you did in Perl

00:18:18,400 --> 00:18:22,630
5 so it's great that we have a

00:18:20,050 --> 00:18:34,800
convenient way to do it Huffman ization

00:18:22,630 --> 00:18:34,800
is great don't do that what i'm drinking

00:18:39,600 --> 00:18:45,370
we talk ok Huffman coding essentially

00:18:43,690 --> 00:18:49,120
the more some things you use the shorter

00:18:45,370 --> 00:18:51,700
it should be we talked about Rehan izing

00:18:49,120 --> 00:18:56,140
the design of the language when we go

00:18:51,700 --> 00:18:59,200
into perl 6 that's why I've got these

00:18:56,140 --> 00:19:02,290
out of order QW you should be QW and

00:18:59,200 --> 00:19:04,870
then / ends that's four we use that a

00:19:02,290 --> 00:19:07,920
lot more in Perl 6 so it's reduced to

00:19:04,870 --> 00:19:07,920
two you'll see that later

00:19:11,040 --> 00:19:16,200
okay so short things this is a short

00:19:13,680 --> 00:19:25,440
thing that's an operator what's that

00:19:16,200 --> 00:19:28,470
operator all right let's try this

00:19:25,440 --> 00:19:33,420
different this word is spelled wi ND

00:19:28,470 --> 00:19:36,660
what word is that am i talking about air

00:19:33,420 --> 00:19:38,250
movement or coiling around a core it's

00:19:36,660 --> 00:19:39,750
two different words with different

00:19:38,250 --> 00:19:41,970
meanings they just have the same

00:19:39,750 --> 00:19:43,830
spelling you can't tell which is which

00:19:41,970 --> 00:19:48,450
you can't tell what's meant by that

00:19:43,830 --> 00:19:52,400
without context this operator is spelled

00:19:48,450 --> 00:19:52,400
dot dot which operator is it

00:19:58,570 --> 00:20:02,299
well the flip-flop operator is what I

00:20:00,950 --> 00:20:07,010
had in mind but you can't tell without

00:20:02,299 --> 00:20:09,440
context dot dot it that it's in this

00:20:07,010 --> 00:20:13,850
context is a range and in scale of

00:20:09,440 --> 00:20:16,070
context it's flip flop and there's a

00:20:13,850 --> 00:20:19,700
three dot version and much like all of

00:20:16,070 --> 00:20:25,659
you at this point Atlanta started

00:20:19,700 --> 00:20:29,360
heckling me Atlanta says is five dots no

00:20:25,659 --> 00:20:36,250
no that's not what I meant Captain

00:20:29,360 --> 00:20:39,169
Picard says there are four dots okay

00:20:36,250 --> 00:20:40,820
flip flop operator very briefly this is

00:20:39,169 --> 00:20:45,110
not enough time to grok it but you can

00:20:40,820 --> 00:20:48,049
look at look at it later if the

00:20:45,110 --> 00:20:50,929
flip-flop operator is false until its

00:20:48,049 --> 00:20:53,059
left side evaluates true then it's true

00:20:50,929 --> 00:20:54,679
until the right side evaluates true then

00:20:53,059 --> 00:21:00,830
its faults which is a horrible thing to

00:20:54,679 --> 00:21:03,289
say out loud but it comes up all the

00:21:00,830 --> 00:21:05,990
time you've got header body foot or

00:21:03,289 --> 00:21:10,520
heavy petter body footer and got markers

00:21:05,990 --> 00:21:12,200
of where the boundaries are and this if

00:21:10,520 --> 00:21:13,880
you have an expression that determines

00:21:12,200 --> 00:21:16,909
the boundaries the flip-flop operator

00:21:13,880 --> 00:21:19,010
does exactly what you want in this

00:21:16,909 --> 00:21:22,309
example the dot dot works just like the

00:21:19,010 --> 00:21:24,260
dot dot you need a more advanced example

00:21:22,309 --> 00:21:25,940
to show the difference between them it's

00:21:24,260 --> 00:21:29,419
incredibly subtle hopefully you'll never

00:21:25,940 --> 00:21:33,940
care but there's the dot form the dot

00:21:29,419 --> 00:21:37,460
dot form so what we have here is dot dot

00:21:33,940 --> 00:21:39,890
works in lists or scalar mode 2 does to

00:21:37,460 --> 00:21:42,590
two completely different things dot dot

00:21:39,890 --> 00:21:44,870
dot is only defined in scalar mode I

00:21:42,590 --> 00:21:47,690
tried it actually works in list mode too

00:21:44,870 --> 00:21:50,000
it works just like dot dot it's a range

00:21:47,690 --> 00:21:56,179
operator I consider that a bug but

00:21:50,000 --> 00:22:01,580
whatever but similar different distinct

00:21:56,179 --> 00:22:03,860
no fail so in Perl 6 dot dot is always a

00:22:01,580 --> 00:22:08,090
range operator no matter what context

00:22:03,860 --> 00:22:09,850
it's in FF for flip-flop is the new

00:22:08,090 --> 00:22:12,360
version of the dot dot

00:22:09,850 --> 00:22:16,120
for flip-flop and if you want the

00:22:12,360 --> 00:22:19,990
three-dot version is FFF that frees up

00:22:16,120 --> 00:22:25,960
the dot-dot-dot for a new language

00:22:19,990 --> 00:22:28,630
feature called sequences sequences are

00:22:25,960 --> 00:22:34,480
ranges on steroids but ova it's going to

00:22:28,630 --> 00:22:37,440
be your dealer today so the flip flops

00:22:34,480 --> 00:22:39,990
great have you heard of the flip flop

00:22:37,440 --> 00:22:43,000
except with the boundary conditions

00:22:39,990 --> 00:22:46,000
whenever there's that those dividing

00:22:43,000 --> 00:22:49,480
markers I don't want them so I end up

00:22:46,000 --> 00:22:56,440
writing this in Perl 5 and that's wet

00:22:49,480 --> 00:22:59,679
code then it's not dry and Perl 6 is no

00:22:56,440 --> 00:23:03,400
help because you know it's FF instead of

00:22:59,679 --> 00:23:05,799
dot dot but wait a minute I said

00:23:03,400 --> 00:23:09,580
boundary conditions but those are end

00:23:05,799 --> 00:23:11,080
points we've already covered that we can

00:23:09,580 --> 00:23:13,090
do things with in points we can put

00:23:11,080 --> 00:23:16,090
carrots around them to say ignore the

00:23:13,090 --> 00:23:19,750
endpoints and this works with FF right

00:23:16,090 --> 00:23:22,020
for cat ears Mouse ears or bunny ears or

00:23:19,750 --> 00:23:22,020
whatever

00:23:29,730 --> 00:23:36,940
operators are great operators are great

00:23:34,300 --> 00:23:42,610
profile operators need no changes at all

00:23:36,940 --> 00:23:44,650
they're wonderful but they were the

00:23:42,610 --> 00:23:47,050
thing that probably changed the most

00:23:44,650 --> 00:23:49,330
lots of changes there either directly

00:23:47,050 --> 00:23:51,040
for the better or to move things around

00:23:49,330 --> 00:23:54,940
to allow something to be added that

00:23:51,040 --> 00:23:58,720
needed together this is from my blue

00:23:54,940 --> 00:24:00,940
tiger translator it's very mechanical in

00:23:58,720 --> 00:24:02,740
some cases we have to defer to the user

00:24:00,940 --> 00:24:04,930
when it can't be determined what it

00:24:02,740 --> 00:24:07,930
means but it's like the dot became the

00:24:04,930 --> 00:24:11,920
till day the dash arrow for method call

00:24:07,930 --> 00:24:12,850
becomes a dot turn area spelled question

00:24:11,920 --> 00:24:18,280
mark question mark exclamation

00:24:12,850 --> 00:24:21,700
exclamation instead of ? colon the

00:24:18,280 --> 00:24:23,770
bitwise operators out remember what we

00:24:21,700 --> 00:24:25,840
said about the prefix the plus for

00:24:23,770 --> 00:24:27,790
numeric and the till day for string and

00:24:25,840 --> 00:24:31,600
all that they get broken out versions

00:24:27,790 --> 00:24:33,580
because they did rely on what state

00:24:31,600 --> 00:24:36,150
their arguments were in which was an

00:24:33,580 --> 00:24:40,210
enormous source for bugs and now this

00:24:36,150 --> 00:24:44,440
squashes all those bugs flat for is

00:24:40,210 --> 00:24:50,110
great if I mention that he's just a

00:24:44,440 --> 00:24:53,140
great guy it's a good talk sigils are

00:24:50,110 --> 00:24:54,760
great maybe they're a little hard to

00:24:53,140 --> 00:24:59,260
teach that was something that came out

00:24:54,760 --> 00:25:02,170
in the Perl 6 RFC process because they

00:24:59,260 --> 00:25:04,060
shift sigils that's the the thing in

00:25:02,170 --> 00:25:06,370
front of the thing you know the dollar

00:25:04,060 --> 00:25:09,490
sign for the scalar and the @ sign for

00:25:06,370 --> 00:25:13,660
the array and people wonder why we have

00:25:09,490 --> 00:25:16,570
this Python people wonder why we have

00:25:13,660 --> 00:25:22,180
this well Larry's linguist and the

00:25:16,570 --> 00:25:25,540
sigils or noun markers where subroutines

00:25:22,180 --> 00:25:28,900
and methods or verbs makes perfect sense

00:25:25,540 --> 00:25:31,240
when it's looked at like that but sigils

00:25:28,900 --> 00:25:33,520
are variant in Perl 5 makes them hard to

00:25:31,240 --> 00:25:36,190
teach depending on how you use something

00:25:33,520 --> 00:25:40,930
it changes what you put in front of it

00:25:36,190 --> 00:25:41,950
sigils are invariant in Perl 6 the most

00:25:40,930 --> 00:26:05,130
evil thing

00:25:41,950 --> 00:26:10,539
I ever encountered a today thank you so

00:26:05,130 --> 00:26:12,250
in Perl 6 it's just curly braces curly

00:26:10,539 --> 00:26:13,600
braces is a code block we're used to

00:26:12,250 --> 00:26:15,610
code blocks what happens in the code

00:26:13,600 --> 00:26:18,399
block it gets evaluated now that happens

00:26:15,610 --> 00:26:21,549
inside interpolation to there there is a

00:26:18,399 --> 00:26:24,070
way to tell it no don't allow code block

00:26:21,549 --> 00:26:25,870
interpolation inside your otherwise

00:26:24,070 --> 00:26:29,950
normal interpolation won't go into that

00:26:25,870 --> 00:26:36,519
it's just possible quote words is great

00:26:29,950 --> 00:26:38,740
and there's so many ways to do it I'm in

00:26:36,519 --> 00:26:42,639
a lot of people's code all the time and

00:26:38,740 --> 00:26:46,169
I don't like this inconsistency it's

00:26:42,639 --> 00:26:48,519
just it's a slight annoyance there's

00:26:46,169 --> 00:26:51,549
there ought to be one right way to do it

00:26:48,519 --> 00:26:56,380
now there's one right way to do it you

00:26:51,549 --> 00:27:04,899
others all still work it almost all the

00:26:56,380 --> 00:27:06,929
other ones still work thank you oh I

00:27:04,899 --> 00:27:11,559
realized why yeah it'd be function call

00:27:06,929 --> 00:27:13,840
okay but quote words is used more often

00:27:11,559 --> 00:27:19,480
in Perl 6 than Perl 5 i'm not going to

00:27:13,840 --> 00:27:20,889
get into where so angle brackets what

00:27:19,480 --> 00:27:23,049
would call them instead of less less

00:27:20,889 --> 00:27:31,179
than greater than angle brackets is the

00:27:23,049 --> 00:27:33,070
quote words but you might want not to do

00:27:31,179 --> 00:27:37,630
that because now summon prod or built-in

00:27:33,070 --> 00:27:41,980
in other ways okay but QW use it all the

00:27:37,630 --> 00:27:44,529
time falls down if anything in the list

00:27:41,980 --> 00:27:47,799
is not quoted and then you have to you

00:27:44,529 --> 00:27:49,570
know break your QW and inserted wrap the

00:27:47,799 --> 00:27:53,500
whole thing in another set of prints

00:27:49,570 --> 00:27:53,840
it's just ugly you can't mix QW with 9 q

00:27:53,500 --> 00:28:00,830
w

00:27:53,840 --> 00:28:04,580
easily in Perl 6 if you use double angle

00:28:00,830 --> 00:28:08,080
brackets it turns up the level of

00:28:04,580 --> 00:28:12,140
interpolation you can do things like

00:28:08,080 --> 00:28:15,770
quote you can do things like insert a

00:28:12,140 --> 00:28:20,240
variable a scalar an array it works the

00:28:15,770 --> 00:28:22,400
way you expect it to anybody's eyes

00:28:20,240 --> 00:28:31,820
glazed over at this point everybody

00:28:22,400 --> 00:28:33,860
happy in in getting this stuff reviewed

00:28:31,820 --> 00:28:35,750
if a couples hours ago that was a bug

00:28:33,860 --> 00:28:41,529
that i had so i don't want to speak to

00:28:35,750 --> 00:28:41,529
it one way or the other okay

00:28:48,020 --> 00:28:56,870
I'll just speak it if you don't remember

00:28:49,670 --> 00:28:59,500
that the tune net now I know don't be

00:28:56,870 --> 00:29:03,200
scared granny is right just be prepared

00:28:59,500 --> 00:29:07,520
isn't it nice to know a lot and a little

00:29:03,200 --> 00:29:16,870
bit not I've got a lot of bonus slides

00:29:07,520 --> 00:29:16,870
but questions yes sir

00:29:32,389 --> 00:29:39,590
the question so far is this is evil and

00:29:35,039 --> 00:30:01,110
I apologize but can I use can I pair

00:29:39,590 --> 00:30:10,679
Unicode and Larry says yes Larry

00:30:01,110 --> 00:30:13,499
confirms cool Larry's confirmed and

00:30:10,679 --> 00:30:15,889
Patrick that as long as we use the q w

00:30:13,499 --> 00:30:19,529
you can use any of the unit code

00:30:15,889 --> 00:30:27,749
bracketing characters which has been

00:30:19,529 --> 00:30:34,970
called awesome what else yes sir QW with

00:30:27,749 --> 00:30:34,970
/ q w with perine's is a function call

00:30:38,539 --> 00:30:42,990
that's correct because perine's are

00:30:41,490 --> 00:30:47,490
special they're not just bracketing

00:30:42,990 --> 00:30:51,740
characters there there are more for

00:30:47,490 --> 00:30:54,860
function calls than just for bracketing

00:30:51,740 --> 00:30:54,860
yes sir

00:31:24,390 --> 00:31:30,210
if you had to the question was and in

00:31:27,930 --> 00:31:34,020
Python this is done with a combination

00:31:30,210 --> 00:31:35,610
of split and hear Doc's and and a lot of

00:31:34,020 --> 00:31:38,310
other stuff that would make me cringe to

00:31:35,610 --> 00:31:42,030
listen to much less actually code no

00:31:38,310 --> 00:31:44,340
offense but you know that it's a I like

00:31:42,030 --> 00:31:46,620
it to be simpler than that and for any

00:31:44,340 --> 00:31:48,030
for whatever it is that you're

00:31:46,620 --> 00:31:53,150
constructing out of that I would hope

00:31:48,030 --> 00:31:53,150
that there is a better way in Perl 6

00:31:56,780 --> 00:32:02,430
Larry says even if you did it in the

00:32:00,630 --> 00:32:05,430
Python way it would be simpler in Perl 6

00:32:02,430 --> 00:32:09,090
and I I can imagine that although I

00:32:05,430 --> 00:32:10,920
can't see oh that's right the lines

00:32:09,090 --> 00:32:13,490
function is splitting to split

00:32:10,920 --> 00:32:13,490
everything of lives

00:32:21,330 --> 00:32:24,330
Annette

00:32:28,780 --> 00:32:59,450
that's a there dot this has gotten into

00:32:53,540 --> 00:33:01,910
a discussion on Q yeah Q W paired with

00:32:59,450 --> 00:33:04,850
you can search the dachshund QW Cullen

00:33:01,910 --> 00:33:16,640
tio to see about their docks which are

00:33:04,850 --> 00:33:19,510
improved here docks yes sir it depends

00:33:16,640 --> 00:33:19,510
what do you want it to do

00:33:33,900 --> 00:33:40,750
classify that you give it a code block

00:33:39,310 --> 00:33:42,730
sort of like in map you give a

00:33:40,750 --> 00:33:44,980
transformational code block this code

00:33:42,730 --> 00:33:47,200
block it transforms and it uses that as

00:33:44,980 --> 00:33:49,690
a key in a hash that is building and

00:33:47,200 --> 00:33:51,610
then everything that matched that key it

00:33:49,690 --> 00:33:54,700
builds in a race so you get a hash of

00:33:51,610 --> 00:33:58,960
arrays which is exactly what's printed

00:33:54,700 --> 00:34:03,430
out there so because my task matched

00:33:58,960 --> 00:34:05,650
that function I wrote it in Perl 6 I

00:34:03,430 --> 00:34:11,070
just grabbed for it and that took you

00:34:05,650 --> 00:34:11,070
know no less than two minutes to write

00:34:15,820 --> 00:34:23,650
ah the only reason the only reason the

00:34:20,830 --> 00:34:25,060
capture variables were ever dollar one

00:34:23,650 --> 00:34:28,600
dollar to dollar threes because dollar

00:34:25,060 --> 00:34:30,700
zero was taken by the program name and

00:34:28,600 --> 00:34:33,190
now program name is something else and

00:34:30,700 --> 00:34:35,650
we don't have that misalignment of if

00:34:33,190 --> 00:34:37,600
you read it into an array it's 0 1 & 2

00:34:35,650 --> 00:34:40,750
but if you use the doll the dollar signs

00:34:37,600 --> 00:34:43,480
its dollar one dollar 2003 so dollar 0

00:34:40,750 --> 00:34:45,700
is the first capture they only capture

00:34:43,480 --> 00:34:47,560
in this case the till day forces it to

00:34:45,700 --> 00:34:49,810
be a string because it's an object all

00:34:47,560 --> 00:34:52,960
the captures our objects now so you can

00:34:49,810 --> 00:34:55,360
do more complex nested things this is

00:34:52,960 --> 00:34:57,190
going to open a whole world of libraries

00:34:55,360 --> 00:34:59,350
regular expressions if you're a fan of

00:34:57,190 --> 00:35:01,990
reg ex called in common that's just

00:34:59,350 --> 00:35:04,540
going to explode and functionality under

00:35:01,990 --> 00:35:07,840
Perl 6 that the opportunities were very

00:35:04,540 --> 00:35:09,640
limited in Perl 5 just because the thing

00:35:07,840 --> 00:35:20,530
about you have to count left parenthesis

00:35:09,640 --> 00:35:24,190
you know yes sir yes they are the regex

00:35:20,530 --> 00:35:27,310
is the thing that is the most change the

00:35:24,190 --> 00:35:30,550
most alien and it's so much so that

00:35:27,310 --> 00:35:34,150
there is a new flag that you can put on

00:35:30,550 --> 00:35:37,300
regex the p5 flag that says do it just

00:35:34,150 --> 00:35:39,430
like Perl 5 it's this is very superior

00:35:37,300 --> 00:35:42,790
but I admit to most people if you're

00:35:39,430 --> 00:35:47,440
doing anything beyond the very basic you

00:35:42,790 --> 00:35:51,190
know dot star splat it's going plus

00:35:47,440 --> 00:35:54,970
things like that it's it's quite

00:35:51,190 --> 00:35:57,420
different so p5 is there for you yeah

00:35:54,970 --> 00:35:57,420
yes sir

00:36:03,970 --> 00:36:17,380
you mean /x yeah is it if you're saying

00:36:14,280 --> 00:36:20,050
if white space is important to you

00:36:17,380 --> 00:36:26,700
should you be moving your pearl 5 reg

00:36:20,050 --> 00:36:30,780
X's to use / x well I think every step

00:36:26,700 --> 00:36:34,630
forward is great and just using X is is

00:36:30,780 --> 00:36:37,750
an improvement in Perl 5 but the the

00:36:34,630 --> 00:36:42,010
stuff that we have in Perl 6 to handle

00:36:37,750 --> 00:36:45,700
the white space is a lot better than in

00:36:42,010 --> 00:36:48,099
Perl 5 so you will have if you do those

00:36:45,700 --> 00:36:50,500
transforms ahead of time then you will

00:36:48,099 --> 00:36:52,450
end up doing a lot more back slashing

00:36:50,500 --> 00:36:54,880
than you will need to if you just waited

00:36:52,450 --> 00:36:56,650
till you were in Perl 6 to do it and you

00:36:54,880 --> 00:36:59,320
can ask me in the hallway I'll give you

00:36:56,650 --> 00:37:03,030
more detail is that one minute signal

00:36:59,320 --> 00:37:03,030
yes go ahead

00:37:09,190 --> 00:37:14,530

YouTube URL: https://www.youtube.com/watch?v=KSWp9B-s-Sg


