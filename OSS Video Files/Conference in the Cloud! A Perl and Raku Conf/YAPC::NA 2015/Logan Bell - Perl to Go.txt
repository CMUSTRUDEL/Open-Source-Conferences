Title: Logan Bell - Perl to Go
Publication date: 2015-06-16
Playlist: YAPC::NA 2015
Description: 
	Ballroom B - Little America Hotel

Due to restrictions we are broadcasting at a lower bitrate.
Captions: 
	00:05:42,930 --> 00:05:46,710
I'm assuming swear the next presenter

00:05:44,850 --> 00:05:48,750
because I don't actually need one well

00:05:46,710 --> 00:05:51,740
we're adding yet another cable down here

00:05:48,750 --> 00:06:03,330
okay with a bucket of water right there

00:05:51,740 --> 00:06:06,090
yeah yeah like what we're doing here yes

00:06:03,330 --> 00:06:08,990
she might people actually said bucket of

00:06:06,090 --> 00:06:08,990
water Oh interesting

00:06:29,060 --> 00:06:43,980
time start okay good morning everyone

00:06:38,210 --> 00:06:48,960
morning so my name is Logan Bell and i'm

00:06:43,980 --> 00:06:50,580
a senior developer at mediamath today's

00:06:48,960 --> 00:06:53,250
talk we're going to go over what we're

00:06:50,580 --> 00:06:58,440
going to be going over go and really

00:06:53,250 --> 00:07:03,090
know pearl I go by epic Bell on Twitter

00:06:58,440 --> 00:07:06,510
and my Sipan ID is logi you can read

00:07:03,090 --> 00:07:12,210
that and I also go by the moniker logi

00:07:06,510 --> 00:07:14,760
or epic Bell on IRC so why go and why go

00:07:12,210 --> 00:07:21,000
at a pro conference well they accepted

00:07:14,760 --> 00:07:24,690
my talk but we use we use go fairly

00:07:21,000 --> 00:07:27,300
extensively at mediamath and we also use

00:07:24,690 --> 00:07:29,670
a lot of pearl as well and when I

00:07:27,300 --> 00:07:31,950
recently joined mediamath approximately

00:07:29,670 --> 00:07:33,890
seven months ago and one of the first

00:07:31,950 --> 00:07:36,540
projects i started with was with go and

00:07:33,890 --> 00:07:38,310
learning's fun and i honestly believe

00:07:36,540 --> 00:07:42,810
that it just makes you a better

00:07:38,310 --> 00:07:47,280
programmer to learn new languages so

00:07:42,810 --> 00:07:49,620
just a very brief history of go um it

00:07:47,280 --> 00:07:52,190
was created in Rob Pike had a very big

00:07:49,620 --> 00:07:57,060
hand in ken Thompson is created in

00:07:52,190 --> 00:08:00,510
around 2007-2008 at google it became

00:07:57,060 --> 00:08:05,730
public or open-source in 2009 and it's

00:08:00,510 --> 00:08:07,260
at version 1.4 soon to be 1.5 and its

00:08:05,730 --> 00:08:13,290
production ready we use it in production

00:08:07,260 --> 00:08:16,610
here at mediamath so with this talk I'm

00:08:13,290 --> 00:08:19,620
taking a slightly unorthodox approach to

00:08:16,610 --> 00:08:22,920
going over a language on what I'd like

00:08:19,620 --> 00:08:25,140
to do is build a game and walk through

00:08:22,920 --> 00:08:28,920
as a code review session how this game

00:08:25,140 --> 00:08:30,570
is built I built this game for this talk

00:08:28,920 --> 00:08:34,349
and it was one of the best ways for me

00:08:30,570 --> 00:08:36,690
to become better and go I also just want

00:08:34,349 --> 00:08:40,450
to point out that i am probably more of

00:08:36,690 --> 00:08:44,590
a beginner expert and go so

00:08:40,450 --> 00:08:46,300
just be nice okay so here here's a

00:08:44,590 --> 00:08:49,420
screenshot of what the game we're going

00:08:46,300 --> 00:08:52,360
to build this game is a Nancy based game

00:08:49,420 --> 00:08:54,010
and it's called arena and if you can't

00:08:52,360 --> 00:08:55,990
it's not really coming up very clearly

00:08:54,010 --> 00:08:57,280
on the screen there but you see there's

00:08:55,990 --> 00:08:58,900
two little characters the point of the

00:08:57,280 --> 00:09:00,820
game is to move around and attack each

00:08:58,900 --> 00:09:02,740
other and the first person the five or

00:09:00,820 --> 00:09:06,640
kills lowers the other person's hit

00:09:02,740 --> 00:09:08,650
points to five wins so let me tell you a

00:09:06,640 --> 00:09:11,320
lot more about it it's a server client

00:09:08,650 --> 00:09:13,480
model the cert I'll go over the server

00:09:11,320 --> 00:09:15,970
code which is written and go and the

00:09:13,480 --> 00:09:17,920
client code as well it's very simple and

00:09:15,970 --> 00:09:22,450
it demonstrates most of the constructs

00:09:17,920 --> 00:09:25,240
so go the typical gameplay is going to

00:09:22,450 --> 00:09:27,340
be left right down arrows first one of

00:09:25,240 --> 00:09:29,230
five wins space bars for attacking and

00:09:27,340 --> 00:09:33,070
there's only two clients that can

00:09:29,230 --> 00:09:35,950
connect okay so if we were to go out and

00:09:33,070 --> 00:09:39,100
check this code out on github and take a

00:09:35,950 --> 00:09:45,340
look at the directory structure we would

00:09:39,100 --> 00:09:46,840
see the following files now the you'll

00:09:45,340 --> 00:09:49,120
see a directory they're called client

00:09:46,840 --> 00:09:50,530
and that's all the client code then

00:09:49,120 --> 00:09:52,420
there's some packages with in there

00:09:50,530 --> 00:09:53,980
which is board which is there you'll see

00:09:52,420 --> 00:09:56,620
a main dot go in there and that that

00:09:53,980 --> 00:09:58,810
that's going to drive the what you

00:09:56,620 --> 00:10:00,970
actually see on the screen and then the

00:09:58,810 --> 00:10:03,040
fighter it which I will be going over is

00:10:00,970 --> 00:10:04,480
the code for keeping track of the

00:10:03,040 --> 00:10:06,010
position on the board for the fighter

00:10:04,480 --> 00:10:09,880
and there's a unit test in there which

00:10:06,010 --> 00:10:11,800
will demonstrate there's a main deck go

00:10:09,880 --> 00:10:14,320
which is the server go which is the

00:10:11,800 --> 00:10:16,750
server code and then there's also a safe

00:10:14,320 --> 00:10:17,770
hash which is to demonstrate an

00:10:16,750 --> 00:10:22,080
alternative approach to doing

00:10:17,770 --> 00:10:22,080
concurrency and go with the sink library

00:10:22,140 --> 00:10:26,650
before we dive in the code I also take a

00:10:24,730 --> 00:10:27,790
few side tracks just to kind of get

00:10:26,650 --> 00:10:30,580
people up to speed so we're going to

00:10:27,790 --> 00:10:34,900
start off with a hello world so this is

00:10:30,580 --> 00:10:37,810
go um it's fairly it's it's a very

00:10:34,900 --> 00:10:39,850
simple language and actually it takes

00:10:37,810 --> 00:10:41,530
learning the learning to actually be

00:10:39,850 --> 00:10:43,930
productive and go doesn't take much time

00:10:41,530 --> 00:10:48,190
at all as you can see it has some very

00:10:43,930 --> 00:10:51,190
resemblance to see it has a package here

00:10:48,190 --> 00:10:53,200
in Maine and a function main so if you

00:10:51,190 --> 00:10:54,190
were to create a program you need to

00:10:53,200 --> 00:10:55,570
have a function main and

00:10:54,190 --> 00:10:58,510
that's the first function that is

00:10:55,570 --> 00:11:01,060
executed and also you can see that i'm

00:10:58,510 --> 00:11:02,710
importing a library called FMT or format

00:11:01,060 --> 00:11:05,160
and it comes with a print line function

00:11:02,710 --> 00:11:09,010
and I'm just printing out hello world in

00:11:05,160 --> 00:11:11,950
order to compile hello world go comes

00:11:09,010 --> 00:11:14,410
with a in executable called go and

00:11:11,950 --> 00:11:15,880
there's many tools built into this and

00:11:14,410 --> 00:11:18,010
one of them is build and this will

00:11:15,880 --> 00:11:20,850
actually compile it for you and it just

00:11:18,010 --> 00:11:24,670
creates an executable called hello world

00:11:20,850 --> 00:11:26,530
so now let's look at some of the

00:11:24,670 --> 00:11:28,510
server-side code so the things that I'm

00:11:26,530 --> 00:11:31,360
going to be going over and this is how

00:11:28,510 --> 00:11:33,430
to design a basic package we're going to

00:11:31,360 --> 00:11:35,140
go over some of the types and go go

00:11:33,430 --> 00:11:37,000
routines and channels and what they are

00:11:35,140 --> 00:11:40,750
we're going to talk a little bit about

00:11:37,000 --> 00:11:43,960
methods on packages in interfaces and

00:11:40,750 --> 00:11:46,870
how they work and go interfaces and go

00:11:43,960 --> 00:11:50,020
we're very similar in my opinion to Java

00:11:46,870 --> 00:11:51,580
style interfaces which will which I'll

00:11:50,020 --> 00:11:52,990
show you and of course we ought to have

00:11:51,580 --> 00:11:54,700
some unit tests in there so i'll

00:11:52,990 --> 00:11:58,660
demonstrate how to write a basic unit

00:11:54,700 --> 00:12:01,240
test okay so that fire package what is

00:11:58,660 --> 00:12:04,270
it so here we go we have a package in it

00:12:01,240 --> 00:12:06,430
and it's a fighter we're importing a few

00:12:04,270 --> 00:12:07,780
things the thing that's interesting to

00:12:06,430 --> 00:12:12,190
note here is that you'll see these like

00:12:07,780 --> 00:12:15,340
github URLs so like github.com / loci 17

00:12:12,190 --> 00:12:16,960
arena client board well that's actually

00:12:15,340 --> 00:12:19,480
the fully qualified name of where you

00:12:16,960 --> 00:12:23,650
would find my local packages on the

00:12:19,480 --> 00:12:27,850
internet and go when you actually type

00:12:23,650 --> 00:12:30,460
go build or go get it will go and find

00:12:27,850 --> 00:12:40,270
those and pull them down through get for

00:12:30,460 --> 00:12:41,380
you so here is a a structure and go now

00:12:40,270 --> 00:12:44,500
for those who are not familiar with

00:12:41,380 --> 00:12:47,589
structured structure there structions c

00:12:44,500 --> 00:12:50,980
and c++ there like a compilation of

00:12:47,589 --> 00:12:52,780
different types um so in here we're

00:12:50,980 --> 00:12:54,390
actually setting a custom type with a

00:12:52,780 --> 00:12:56,980
type keyword which I'll go over later

00:12:54,390 --> 00:13:00,070
called fighter and within it is going to

00:12:56,980 --> 00:13:02,140
contain many different types the first

00:13:00,070 --> 00:13:03,940
you are all integers as you can see

00:13:02,140 --> 00:13:07,180
there's like x and a y-value and some

00:13:03,940 --> 00:13:08,019
other things we have a kind which is a

00:13:07,180 --> 00:13:09,730
string

00:13:08,019 --> 00:13:11,559
and then we have something here which

00:13:09,730 --> 00:13:15,670
some may not be familiar with which is

00:13:11,559 --> 00:13:18,369
called a rune and Arun is actually a it

00:13:15,670 --> 00:13:20,139
represents a UTF code point and go so

00:13:18,369 --> 00:13:23,499
that character will actually contain a

00:13:20,139 --> 00:13:25,929
UTF code point go actually supports

00:13:23,499 --> 00:13:29,970
utf-8 and you can actually just drop

00:13:25,929 --> 00:13:31,959
utf-8 code points right into the code

00:13:29,970 --> 00:13:34,179
another interesting one there is the

00:13:31,959 --> 00:13:37,989
message which is of a custom type called

00:13:34,179 --> 00:13:39,879
line and it's also called a channel now

00:13:37,989 --> 00:13:41,439
i'm going to go be going over channels

00:13:39,879 --> 00:13:45,369
but channels are a special type and this

00:13:41,439 --> 00:13:48,129
is how go reasons in this is how go

00:13:45,369 --> 00:13:49,420
reasons and constructs concurrency so

00:13:48,129 --> 00:13:50,799
this will be something that will be

00:13:49,420 --> 00:13:55,119
passing around to some concurrent

00:13:50,799 --> 00:13:58,569
processes so other types that go

00:13:55,119 --> 00:14:02,549
supports it is of course the boolean you

00:13:58,569 --> 00:14:07,269
know you true and false many various

00:14:02,549 --> 00:14:09,999
numerics t4s in 32s floats it has an

00:14:07,269 --> 00:14:12,600
array type has something called slices

00:14:09,999 --> 00:14:16,329
which is sort of a higher order array

00:14:12,600 --> 00:14:20,170
which you can actually append to and

00:14:16,329 --> 00:14:21,549
grow in size it has your standard sort

00:14:20,170 --> 00:14:24,009
of pointers are similar to like a c

00:14:21,549 --> 00:14:26,549
pointer it has functions which are also

00:14:24,009 --> 00:14:31,089
first class so you can pass them into

00:14:26,549 --> 00:14:32,319
functions you can um you can pass them

00:14:31,089 --> 00:14:33,929
into functions they also support

00:14:32,319 --> 00:14:36,399
closures and those sorts of things

00:14:33,929 --> 00:14:39,249
interfaces which I briefly spoke about

00:14:36,399 --> 00:14:42,610
which are really just a way to define an

00:14:39,249 --> 00:14:45,100
API and it also supports maps which in

00:14:42,610 --> 00:14:49,059
Perl terms is like a hash a key value

00:14:45,100 --> 00:14:52,929
pair okay so let's talk a little bit

00:14:49,059 --> 00:14:54,730
about go routines so here you can see

00:14:52,929 --> 00:14:57,189
some code here where we're we're inside

00:14:54,730 --> 00:14:59,169
main and we're calling go routine go

00:14:57,189 --> 00:15:01,139
routine go routine and we have a

00:14:59,169 --> 00:15:03,610
function actually just called routine so

00:15:01,139 --> 00:15:06,189
what this is doing so when when go

00:15:03,610 --> 00:15:08,879
compiles and spins up and it's executing

00:15:06,189 --> 00:15:12,879
main actually main itself is inside a

00:15:08,879 --> 00:15:14,679
process called a main go routine and for

00:15:12,879 --> 00:15:18,069
each one of these routines it spends up

00:15:14,679 --> 00:15:19,899
a parallel process if i were to compile

00:15:18,069 --> 00:15:21,720
this and run this we would actually see

00:15:19,899 --> 00:15:23,250
nothing because they all run

00:15:21,720 --> 00:15:25,500
parallel and there's nothing blocking or

00:15:23,250 --> 00:15:27,209
coordinating these calls so if I were to

00:15:25,500 --> 00:15:30,779
run this thing we would see nothing most

00:15:27,209 --> 00:15:32,730
likely so this is what it sort of looks

00:15:30,779 --> 00:15:34,699
looks like we have a main a primary

00:15:32,730 --> 00:15:37,350
routine and then we have three other

00:15:34,699 --> 00:15:41,670
parallel runs the parallel routines

00:15:37,350 --> 00:15:43,860
running concurrently so how can we how

00:15:41,670 --> 00:15:46,620
can we how can we coordinate these so

00:15:43,860 --> 00:15:48,360
that we can block and exit correctly and

00:15:46,620 --> 00:15:52,379
see the hello world from all three of

00:15:48,360 --> 00:15:56,490
our routines so this is where channels

00:15:52,379 --> 00:15:58,470
come in there is a key word there called

00:15:56,490 --> 00:16:01,920
make and that's just a special keyword

00:15:58,470 --> 00:16:04,379
to initialize a channel of a string type

00:16:01,920 --> 00:16:05,670
and we're naming it done and what we do

00:16:04,379 --> 00:16:08,160
that's actually like a shared memory

00:16:05,670 --> 00:16:11,189
that we're going to pass into the

00:16:08,160 --> 00:16:13,860
routine um and the way I think about

00:16:11,189 --> 00:16:16,800
channels in my mind is I think I'm about

00:16:13,860 --> 00:16:19,110
them as more of like pipes so if you

00:16:16,800 --> 00:16:21,509
have a pipe you need to have you have to

00:16:19,110 --> 00:16:24,180
have an end to put something into it and

00:16:21,509 --> 00:16:27,149
you have to have a receiving end um so

00:16:24,180 --> 00:16:29,430
when the routine is executing we send a

00:16:27,149 --> 00:16:32,459
string called done into the done channel

00:16:29,430 --> 00:16:35,519
and back down here back in the main

00:16:32,459 --> 00:16:36,899
routine you'll see this arrow left arrow

00:16:35,519 --> 00:16:38,519
done and what we're doing is we're

00:16:36,899 --> 00:16:41,670
draining the pipe or draining the

00:16:38,519 --> 00:16:43,829
channel so it will block that first done

00:16:41,670 --> 00:16:45,480
until something is received and I'll

00:16:43,829 --> 00:16:46,620
continue the block until he gets to the

00:16:45,480 --> 00:16:49,680
very end and then we close out the

00:16:46,620 --> 00:16:52,290
channel so if we were to compile that

00:16:49,680 --> 00:16:55,439
and run it they would they would run in

00:16:52,290 --> 00:16:57,839
parallel um but they wouldn't the main

00:16:55,439 --> 00:17:01,649
go-to routine would not close out until

00:16:57,839 --> 00:17:04,169
all the channels have been drained okay

00:17:01,649 --> 00:17:11,600
so now let's talk a little bit about how

00:17:04,169 --> 00:17:11,600
do we do object oriented yes sure

00:17:21,209 --> 00:17:28,559
the first done so these that there there

00:17:24,909 --> 00:17:31,270
there are ways that you can make a

00:17:28,559 --> 00:17:32,799
buffered channels which would not block

00:17:31,270 --> 00:17:35,080
but the first one down here will block

00:17:32,799 --> 00:17:37,630
because this is in technically it's

00:17:35,080 --> 00:17:39,159
called an unbuffered channel until it

00:17:37,630 --> 00:17:40,510
received something and then this one

00:17:39,159 --> 00:17:43,450
will block until something comes across

00:17:40,510 --> 00:17:46,090
the channel not certain if that answers

00:17:43,450 --> 00:17:54,450
your question yes because i have three

00:17:46,090 --> 00:18:05,020
concurrent processes running okay so

00:17:54,450 --> 00:18:06,520
what would it okay well let me try let

00:18:05,020 --> 00:18:07,929
me try to clarify it a bit and then I

00:18:06,520 --> 00:18:11,500
need to move ahead and then I can answer

00:18:07,929 --> 00:18:13,450
questions later so as we can see we're

00:18:11,500 --> 00:18:17,549
spinning up three processes with three

00:18:13,450 --> 00:18:19,960
go routines so there are three

00:18:17,549 --> 00:18:23,500
simultaneous processes running at the

00:18:19,960 --> 00:18:25,470
same time and when we pass a channel

00:18:23,500 --> 00:18:28,929
when we pass something into that channel

00:18:25,470 --> 00:18:31,029
we are saying so the code gets down to

00:18:28,929 --> 00:18:33,870
this line here it will block until

00:18:31,029 --> 00:18:35,980
something is received from that channel

00:18:33,870 --> 00:18:37,720
then we send something into the channel

00:18:35,980 --> 00:18:40,450
down here and then it moves to the next

00:18:37,720 --> 00:18:42,039
line sorry i do not have line numbers

00:18:40,450 --> 00:18:43,779
which would been helpful here but and

00:18:42,039 --> 00:18:45,010
then we do it three times because we

00:18:43,779 --> 00:18:50,830
have three we know we have three

00:18:45,010 --> 00:18:52,299
processes okay

00:18:50,830 --> 00:18:53,919
briefly go over there's a lot of code

00:18:52,299 --> 00:18:56,019
here but let's just briefly go over how

00:18:53,919 --> 00:18:58,480
we can initialize something or attempt

00:18:56,019 --> 00:19:00,100
to do object oriented I'll programming

00:18:58,480 --> 00:19:02,679
and go which is a little different than

00:19:00,100 --> 00:19:05,860
your traditional object-oriented

00:19:02,679 --> 00:19:07,539
programming here we've created a

00:19:05,860 --> 00:19:09,399
function called new fighter it's

00:19:07,539 --> 00:19:11,110
receiving some parameters you can see

00:19:09,399 --> 00:19:13,350
that in a function signature you

00:19:11,110 --> 00:19:16,149
actually it is a strongly typed language

00:19:13,350 --> 00:19:19,090
find what sort of types are coming in so

00:19:16,149 --> 00:19:21,760
we have X Y ID and an int that are all

00:19:19,090 --> 00:19:23,139
defined we also are passing in a string

00:19:21,760 --> 00:19:25,510
and then we're returning something with

00:19:23,139 --> 00:19:27,460
a capital F fighter which is an

00:19:25,510 --> 00:19:30,639
interface type and we'll go over what

00:19:27,460 --> 00:19:33,940
that means um here we're doing something

00:19:30,639 --> 00:19:38,679
with my safe map which is just really a

00:19:33,940 --> 00:19:39,760
a thread-safe hash map which we'll go

00:19:38,679 --> 00:19:44,409
over at the end of the talk here so

00:19:39,760 --> 00:19:46,510
don't worry um and the key thing here is

00:19:44,409 --> 00:19:48,010
we see this ampersand fighter and some

00:19:46,510 --> 00:19:49,419
parameters and what we're doing is we're

00:19:48,010 --> 00:19:52,330
actually initializing that struck that

00:19:49,419 --> 00:19:55,539
we saw earlier and the ampersand is

00:19:52,330 --> 00:19:57,549
setting it up as a pointer so we assign

00:19:55,539 --> 00:19:59,110
it to fighter we call some other methods

00:19:57,549 --> 00:20:01,539
down here listen and draw and then would

00:19:59,110 --> 00:20:05,230
return fighter now fighter is it a

00:20:01,539 --> 00:20:07,899
structure type but it matches the

00:20:05,230 --> 00:20:11,919
interface of what that capital F fighter

00:20:07,899 --> 00:20:14,169
is which i'll be showing here shortly so

00:20:11,919 --> 00:20:18,220
how do you how do you create methods on

00:20:14,169 --> 00:20:21,630
a struct so for example if we want to

00:20:18,220 --> 00:20:26,350
have like a down method we would have a

00:20:21,630 --> 00:20:30,460
you can define a method to be associated

00:20:26,350 --> 00:20:31,750
with a pointer based on the type so the

00:20:30,460 --> 00:20:33,760
signature is a little different than we

00:20:31,750 --> 00:20:36,190
saw earlier with the other function that

00:20:33,760 --> 00:20:38,019
in that you see a receiver so you see

00:20:36,190 --> 00:20:40,870
funk and then a receiver and then the

00:20:38,019 --> 00:20:43,450
method name and then parameters now what

00:20:40,870 --> 00:20:47,049
that is saying is this particular type

00:20:43,450 --> 00:20:48,880
fighter and will will happy associate

00:20:47,049 --> 00:20:54,909
with anything that let me rephrase that

00:20:48,880 --> 00:20:57,850
anything that matches that type will

00:20:54,909 --> 00:21:01,240
will have this method available to it so

00:20:57,850 --> 00:21:04,330
go is a strongly typed language and so

00:21:01,240 --> 00:21:06,070
this happens at compile time and

00:21:04,330 --> 00:21:07,539
it's able to basically hang this method

00:21:06,070 --> 00:21:09,450
off of there so you can see down below

00:21:07,539 --> 00:21:12,220
that we have another method called draw

00:21:09,450 --> 00:21:18,970
there which is would have a similar

00:21:12,220 --> 00:21:20,470
signature as above okay so interfaces we

00:21:18,970 --> 00:21:23,200
saw the capital of Fighters so what is

00:21:20,470 --> 00:21:26,289
that so this is this is an interface and

00:21:23,200 --> 00:21:28,510
it's another special type and go and

00:21:26,289 --> 00:21:30,610
it's just really all it's doing is

00:21:28,510 --> 00:21:33,070
defining method signatures for what a

00:21:30,610 --> 00:21:34,210
particular type should have so we're

00:21:33,070 --> 00:21:37,210
saying that a fire should have a

00:21:34,210 --> 00:21:40,000
left-right up-down method associated

00:21:37,210 --> 00:21:45,010
with it this comes in handy later when

00:21:40,000 --> 00:21:47,380
we want to set up we can actually set up

00:21:45,010 --> 00:21:49,659
custom functions that will force us to

00:21:47,380 --> 00:21:51,309
comply with this particular interface or

00:21:49,659 --> 00:21:54,610
API and if you want to think of it that

00:21:51,309 --> 00:21:57,970
way so it's just all it is is just

00:21:54,610 --> 00:22:03,700
function two signatures and how what

00:21:57,970 --> 00:22:07,120
they expect okay so now let's let's talk

00:22:03,700 --> 00:22:10,269
a little bit about unit testing so what

00:22:07,120 --> 00:22:13,240
we have here is a sort of a basic unit

00:22:10,269 --> 00:22:16,330
tests go comes with a library called

00:22:13,240 --> 00:22:18,309
testing which actually works in

00:22:16,330 --> 00:22:21,010
conjunction with the go command line

00:22:18,309 --> 00:22:23,470
tool so when you say go test it will

00:22:21,010 --> 00:22:25,690
actually find any files in your

00:22:23,470 --> 00:22:28,409
directory that are called whatever

00:22:25,690 --> 00:22:32,110
underscore test go and then it will run

00:22:28,409 --> 00:22:35,799
the test suite the testing library comes

00:22:32,110 --> 00:22:38,580
with a few a few few functions to help

00:22:35,799 --> 00:22:43,389
with your function if you're testing

00:22:38,580 --> 00:22:44,590
it's in in in some ways it's not it

00:22:43,389 --> 00:22:46,090
doesn't actually come with an assert

00:22:44,590 --> 00:22:48,659
function or anything like that it does

00:22:46,090 --> 00:22:51,250
come with some useful benchmark

00:22:48,659 --> 00:22:53,740
functions and some error logging and

00:22:51,250 --> 00:22:57,610
whatnot so what we can see here is that

00:22:53,740 --> 00:23:00,549
we're just testing to see that V should

00:22:57,610 --> 00:23:05,039
equal 8 if it doesn't then we haven't

00:23:00,549 --> 00:23:05,039
problem so we just outboard output that

00:23:05,610 --> 00:23:10,480
so when it comes to unit testing our

00:23:08,889 --> 00:23:13,659
fighter we just have another unit test

00:23:10,480 --> 00:23:14,559
here we're going to move left we're

00:23:13,659 --> 00:23:16,630
going to test our move left

00:23:14,559 --> 00:23:17,929
functionality and basically what we're

00:23:16,630 --> 00:23:20,269
doing is we're setting

00:23:17,929 --> 00:23:22,009
an enemy fighter and we're testing to

00:23:20,269 --> 00:23:24,019
verify that can we actually just move

00:23:22,009 --> 00:23:28,460
into the same space that is occupying if

00:23:24,019 --> 00:23:30,740
it can't then it fails so why don't we

00:23:28,460 --> 00:23:40,159
go ahead and demo how you run a unit

00:23:30,740 --> 00:23:46,879
test here and I'm tempting to this

00:23:40,159 --> 00:23:48,379
one-handed okay and I think let's just

00:23:46,879 --> 00:23:56,299
make this a little bigger so everyone

00:23:48,379 --> 00:23:58,100
can see okay so in this directory here

00:23:56,299 --> 00:24:00,679
we see a fighter go and a fighter

00:23:58,100 --> 00:24:03,289
underscore test and let's zoom in even

00:24:00,679 --> 00:24:14,960
more and we can actually just run go

00:24:03,289 --> 00:24:22,070
test and it will test there we go so

00:24:14,960 --> 00:24:25,909
there we go there's a unit test thank

00:24:22,070 --> 00:24:29,840
you okay so forth for side truck so that

00:24:25,909 --> 00:24:31,509
tight keyword what was that all about so

00:24:29,840 --> 00:24:35,240
one of the interesting thing is he so

00:24:31,509 --> 00:24:36,830
you can you can create custom types and

00:24:35,240 --> 00:24:39,440
go and you can actually create custom

00:24:36,830 --> 00:24:41,990
types off of primitives which allow you

00:24:39,440 --> 00:24:43,759
to do some interesting things so here we

00:24:41,990 --> 00:24:46,789
were saying that we're creating a

00:24:43,759 --> 00:24:51,080
account type and it's going to be an

00:24:46,789 --> 00:24:52,700
integer now what you can do with that

00:24:51,080 --> 00:24:55,940
now that we have this custom type we can

00:24:52,700 --> 00:24:59,029
actually hang methods off of it on so we

00:24:55,940 --> 00:25:02,090
can create this increment method here

00:24:59,029 --> 00:25:06,889
that accepts account type oh and this is

00:25:02,090 --> 00:25:09,110
doing a more so post post fixed

00:25:06,889 --> 00:25:11,600
increments and go actually return undef

00:25:09,110 --> 00:25:14,299
unlike in Perl will actually return the

00:25:11,600 --> 00:25:18,470
previous value of what it was so this

00:25:14,299 --> 00:25:21,289
this is basically allowing us to do an

00:25:18,470 --> 00:25:28,200
increment post fix that would return

00:25:21,289 --> 00:25:45,029
what the previous value was and

00:25:28,200 --> 00:25:47,340
I have a demo there so so this is the

00:25:45,029 --> 00:25:50,639
code here and so we can compile this

00:25:47,340 --> 00:25:58,200
let's just this is the code i just

00:25:50,639 --> 00:26:00,090
showed and if we run the type example it

00:25:58,200 --> 00:26:01,470
returns 1 because we're returning the

00:26:00,090 --> 00:26:12,779
previous value and if we look at the

00:26:01,470 --> 00:26:16,889
code it's the exact same kodos just

00:26:12,779 --> 00:26:21,720
demoing here so there you go there

00:26:16,889 --> 00:26:27,330
there's a demo okay so let's go back to

00:26:21,720 --> 00:26:30,090
the talk here ok so the server code so

00:26:27,330 --> 00:26:31,049
let's take a look at that the the

00:26:30,090 --> 00:26:33,500
primary things I want to demonstrate

00:26:31,049 --> 00:26:36,210
here is how do we listen for connections

00:26:33,500 --> 00:26:39,179
how do we broadcast messages to our

00:26:36,210 --> 00:26:40,230
other clients through channels and this

00:26:39,179 --> 00:26:41,850
will sort of demonstrate some of the

00:26:40,230 --> 00:26:46,470
concurrent concurrency patterns you can

00:26:41,850 --> 00:26:48,019
do with go so with concurrency as I

00:26:46,470 --> 00:26:50,309
mentioned you do it all with go routines

00:26:48,019 --> 00:26:53,130
channels help with the coordination of

00:26:50,309 --> 00:26:54,570
these routines many of the stuff is

00:26:53,130 --> 00:26:58,110
actually deeply rooted in a computer

00:26:54,570 --> 00:27:01,590
science topic called CSP there's many

00:26:58,110 --> 00:27:03,960
other languages where the concurrency is

00:27:01,590 --> 00:27:07,260
like a first-class sort of pattern like

00:27:03,960 --> 00:27:11,190
erling is an example of this that have

00:27:07,260 --> 00:27:12,720
similar source of constant constructs so

00:27:11,190 --> 00:27:16,019
let's let's take a look at that main

00:27:12,720 --> 00:27:18,330
deck go so what we're doing here as you

00:27:16,019 --> 00:27:23,070
can see so a main gets started up and we

00:27:18,330 --> 00:27:24,510
create a server object um and then we

00:27:23,070 --> 00:27:26,580
call a method called serve which will

00:27:24,510 --> 00:27:29,820
start serving if there's an error then

00:27:26,580 --> 00:27:33,840
we just print out the air nothing too

00:27:29,820 --> 00:27:37,980
magical going on there yet okay so now

00:27:33,840 --> 00:27:39,210
the serve method what we do is we we set

00:27:37,980 --> 00:27:43,600
up eight

00:27:39,210 --> 00:27:46,810
we set up al we listen on port 120 on

00:27:43,600 --> 00:27:49,060
localhost and you can't see where it's

00:27:46,810 --> 00:27:53,800
actually listening to hear and I don't

00:27:49,060 --> 00:27:54,940
know where my mouse went here we go that

00:27:53,800 --> 00:27:58,930
work you can actually see you

00:27:54,940 --> 00:28:00,580
highlighting oh cool ok so we're

00:27:58,930 --> 00:28:03,040
listening on 127 and it's getting cut

00:28:00,580 --> 00:28:06,220
off their it's actually like port 9000

00:28:03,040 --> 00:28:08,920
or something like that and so this is

00:28:06,220 --> 00:28:11,470
sort of a standard way of there's a net

00:28:08,920 --> 00:28:15,190
library and it binds to this this

00:28:11,470 --> 00:28:17,620
address we go down here and we call

00:28:15,190 --> 00:28:21,220
something called the fur the fur is a

00:28:17,620 --> 00:28:24,730
special function and go that allows you

00:28:21,220 --> 00:28:27,280
to defer defer expressions or function

00:28:24,730 --> 00:28:29,770
or defer things until after the function

00:28:27,280 --> 00:28:31,330
closes so what we're saying here is when

00:28:29,770 --> 00:28:33,370
this function exits we're going to

00:28:31,330 --> 00:28:35,860
actually call the clothes function on

00:28:33,370 --> 00:28:42,130
there there's some other things going on

00:28:35,860 --> 00:28:43,750
in here that are not very very specific

00:28:42,130 --> 00:28:45,940
but the one thing is that down there

00:28:43,750 --> 00:28:47,800
where you see s server listener except

00:28:45,940 --> 00:28:50,710
that will actually block until a

00:28:47,800 --> 00:28:54,220
connection is received if we have a

00:28:50,710 --> 00:28:56,710
error we then print it we create

00:28:54,220 --> 00:29:01,660
something called a new client and it

00:28:56,710 --> 00:29:04,300
starts listening to he starts listening

00:29:01,660 --> 00:29:07,590
to things coming over the wire and we'll

00:29:04,300 --> 00:29:09,790
come back to what this means later and

00:29:07,590 --> 00:29:14,820
let's see here let me just scroll down a

00:29:09,790 --> 00:29:16,830
little bit and then

00:29:14,820 --> 00:29:19,679
though routine so so when we get a

00:29:16,830 --> 00:29:21,029
connection we actually called go s

00:29:19,679 --> 00:29:23,820
handle connection and that's actually

00:29:21,029 --> 00:29:25,590
speaking of a parallel routine and then

00:29:23,820 --> 00:29:27,360
it goes back up to the top of the loop

00:29:25,590 --> 00:29:29,399
and it starts listening for connections

00:29:27,360 --> 00:29:34,110
again with this parallel routine running

00:29:29,399 --> 00:29:36,659
uh handling that connection and then we

00:29:34,110 --> 00:29:47,250
just returned out if there's if there if

00:29:36,659 --> 00:29:48,720
we're done okay so how do we handle the

00:29:47,250 --> 00:29:54,090
connection so one of the things that we

00:29:48,720 --> 00:29:57,090
do is we set up a we start up a special

00:29:54,090 --> 00:29:58,590
sort of buffer or news reader here and

00:29:57,090 --> 00:30:01,169
you see that we have a method they're

00:29:58,590 --> 00:30:04,379
called broadcast so what that's doing is

00:30:01,169 --> 00:30:08,309
it's actually passing data into this

00:30:04,379 --> 00:30:09,750
method and it will it will broadcast

00:30:08,309 --> 00:30:14,909
that over a channel to all the

00:30:09,750 --> 00:30:16,350
connections that we have the we sit here

00:30:14,909 --> 00:30:23,850
and we actually just spin in a loop

00:30:16,350 --> 00:30:26,429
until we receive something here a red

00:30:23,850 --> 00:30:29,460
line and then when we receive something

00:30:26,429 --> 00:30:34,590
we just broadcast it back out and we'll

00:30:29,460 --> 00:30:36,269
demonstrate this here in a minute so

00:30:34,590 --> 00:30:38,580
that broadcast is really all it's doing

00:30:36,269 --> 00:30:40,279
is it's just looping over all of our

00:30:38,580 --> 00:30:44,070
registered clients that are connected

00:30:40,279 --> 00:30:46,889
and it using the arrow syntax there it's

00:30:44,070 --> 00:30:49,919
passing a message into its particular

00:30:46,889 --> 00:30:56,789
message channel and then that will be

00:30:49,919 --> 00:30:59,340
received so when we're listening uh we

00:30:56,789 --> 00:31:00,509
we loop over each of the messages and

00:30:59,340 --> 00:31:03,779
there's different things that we're

00:31:00,509 --> 00:31:05,610
doing here so we have something so if

00:31:03,779 --> 00:31:07,799
the line for whatever reason with this

00:31:05,610 --> 00:31:09,720
is our this this this is the format that

00:31:07,799 --> 00:31:11,519
we receive so we get a line and then

00:31:09,720 --> 00:31:13,649
it's going to be we're going to parse it

00:31:11,519 --> 00:31:16,409
is gonna have an action an ID which is

00:31:13,649 --> 00:31:18,809
the the client and the x and y and if

00:31:16,409 --> 00:31:20,190
action is a particular like for some

00:31:18,809 --> 00:31:21,870
reason we're looking for stab it will

00:31:20,190 --> 00:31:24,120
send an attack message or we'll just

00:31:21,870 --> 00:31:25,529
send a position message and that's for

00:31:24,120 --> 00:31:29,210
the clients so that it knows where to

00:31:25,529 --> 00:31:34,890
put the the character symbol

00:31:29,210 --> 00:31:36,810
and finally when we so this is the sin

00:31:34,890 --> 00:31:39,420
position message when we receive

00:31:36,810 --> 00:31:42,270
something we send it back on calling the

00:31:39,420 --> 00:31:55,920
send message function there so let's

00:31:42,270 --> 00:31:58,050
let's just demo that real quick okay so

00:31:55,920 --> 00:32:00,690
we started we started a server here in

00:31:58,050 --> 00:32:05,430
just one moment I'm going to try to hold

00:32:00,690 --> 00:32:08,630
my mic with my elbow Oh put in the hole

00:32:05,430 --> 00:32:08,630
there is a great idea thank you I

00:32:10,370 --> 00:32:19,970
thought that'd be more difficult okay so

00:32:13,080 --> 00:32:25,190
oh okay so let's uh let's go ahead and

00:32:19,970 --> 00:32:29,520
we can connect here so what we see is

00:32:25,190 --> 00:32:32,370
I'm just connecting to 127 001 local

00:32:29,520 --> 00:32:33,960
host port 9000 and the server sent us a

00:32:32,370 --> 00:32:37,350
message it sends a message telling us

00:32:33,960 --> 00:32:39,660
what ur and where we live on the screen

00:32:37,350 --> 00:32:42,570
so we can actually send something back

00:32:39,660 --> 00:32:49,830
to the server and we can say hey my

00:32:42,570 --> 00:32:53,370
position for one is actually 24 to 25

00:32:49,830 --> 00:32:55,710
and then it broadcasts back what it's

00:32:53,370 --> 00:32:57,270
just echoing back what it received so

00:32:55,710 --> 00:32:59,100
every client would receive that and it's

00:32:57,270 --> 00:33:05,060
just sort of a simple broadcast message

00:32:59,100 --> 00:33:07,620
here and we go put this back here and

00:33:05,060 --> 00:33:13,830
you can see here that the server itself

00:33:07,620 --> 00:33:15,090
is outputting some messaging ok so let's

00:33:13,830 --> 00:33:17,820
take a look at the client-side code and

00:33:15,090 --> 00:33:20,970
how it works a little bit here ok so

00:33:17,820 --> 00:33:22,440
there's a main arm and we are

00:33:20,970 --> 00:33:24,180
essentially doing a very similar thing

00:33:22,440 --> 00:33:30,330
here except this time we're establishing

00:33:24,180 --> 00:33:31,710
a connection to the server uh there's

00:33:30,330 --> 00:33:33,570
some things going on we have that board

00:33:31,710 --> 00:33:35,790
that board was something I mentioned in

00:33:33,570 --> 00:33:37,050
the in a previous slide that's just

00:33:35,790 --> 00:33:42,179
another package that does something

00:33:37,050 --> 00:33:43,679
antsy term stuff and we close out a

00:33:42,179 --> 00:33:46,950
we establish a connection that will

00:33:43,679 --> 00:33:50,820
actually set up a and establish an

00:33:46,950 --> 00:33:53,279
object that talks to the server we defer

00:33:50,820 --> 00:33:57,360
close so when main exits we will close

00:33:53,279 --> 00:34:02,899
this and we're setting up our some

00:33:57,360 --> 00:34:05,190
initial like fighters and and down here

00:34:02,899 --> 00:34:09,990
this down here is how you set up an

00:34:05,190 --> 00:34:12,149
array so fighters colon arrow we're

00:34:09,990 --> 00:34:16,200
saying we're going to have a list of

00:34:12,149 --> 00:34:18,899
fighters and where it's going to be that

00:34:16,200 --> 00:34:21,119
player so that is just one that's just

00:34:18,899 --> 00:34:23,879
an array of a single thing of a player

00:34:21,119 --> 00:34:26,190
their way of the type fighter which is

00:34:23,879 --> 00:34:30,329
that interface and then we call read

00:34:26,190 --> 00:34:32,639
from server and we handle key events so

00:34:30,329 --> 00:34:34,950
to establish a connection this is

00:34:32,639 --> 00:34:38,490
actually returning if you can see is

00:34:34,950 --> 00:34:41,220
returning a type called net con up above

00:34:38,490 --> 00:34:44,010
their established connection netcong so

00:34:41,220 --> 00:34:47,429
this is sort of going to demonstrate how

00:34:44,010 --> 00:34:51,450
an interface works because that type

00:34:47,429 --> 00:35:05,460
there um we'll see here momentarily it's

00:34:51,450 --> 00:35:08,030
passed into just one moment okay where

00:35:05,460 --> 00:35:08,030
my slides go

00:35:15,550 --> 00:35:21,830
okay so it returns a net con up here

00:35:19,730 --> 00:35:23,540
this established connection and then we

00:35:21,830 --> 00:35:26,720
take turn around and we pass it into a

00:35:23,540 --> 00:35:30,080
new reader and new reader actually

00:35:26,720 --> 00:35:31,340
accepts a three you can pass that in but

00:35:30,080 --> 00:35:32,599
it's actually defiant if you were to

00:35:31,340 --> 00:35:34,609
look at the source code for new reader

00:35:32,599 --> 00:35:39,410
it would be a different it would

00:35:34,609 --> 00:35:40,609
actually be a different sort of type but

00:35:39,410 --> 00:35:42,830
the reason you can pass it in is because

00:35:40,609 --> 00:35:53,330
it matches the interface that is it that

00:35:42,830 --> 00:35:55,970
is defining so we can listen to um so we

00:35:53,330 --> 00:35:59,000
have a read from server here and this is

00:35:55,970 --> 00:36:02,300
a going to spin up another go routine

00:35:59,000 --> 00:36:04,130
and it's just reading everything that is

00:36:02,300 --> 00:36:06,470
coming from the server and it's very

00:36:04,130 --> 00:36:09,530
similar to the server code and we block

00:36:06,470 --> 00:36:11,840
here and we parse we block until we

00:36:09,530 --> 00:36:14,450
receive something from the buffer and

00:36:11,840 --> 00:36:17,780
then we get a we've received data from

00:36:14,450 --> 00:36:21,710
the line and we just do some various

00:36:17,780 --> 00:36:27,650
things depending on what what what is

00:36:21,710 --> 00:36:29,660
received here and then down here we have

00:36:27,650 --> 00:36:32,390
a list of connected fighters that we're

00:36:29,660 --> 00:36:33,920
aware of and when we send messages so a

00:36:32,390 --> 00:36:35,869
client has to keep track of the

00:36:33,920 --> 00:36:38,300
connections so it has to keep track of

00:36:35,869 --> 00:36:40,640
what enemies we have on the board and

00:36:38,300 --> 00:36:44,290
where they're at so we send messages

00:36:40,640 --> 00:36:47,210
back to that we handle key events uh

00:36:44,290 --> 00:36:50,960
based off we use a library called turn

00:36:47,210 --> 00:36:52,190
box uh which actually draws all of the

00:36:50,960 --> 00:36:56,230
the things that you see on the screen

00:36:52,190 --> 00:36:59,030
and it handles key events based off of

00:36:56,230 --> 00:37:01,580
it has some functionality here so able

00:36:59,030 --> 00:37:04,280
we just listened until we receive

00:37:01,580 --> 00:37:07,099
something and if we receive a particular

00:37:04,280 --> 00:37:10,580
one we exit now this also demonstrates a

00:37:07,099 --> 00:37:12,980
case statement and go uh so we just

00:37:10,580 --> 00:37:16,070
switch until a particular type is

00:37:12,980 --> 00:37:21,430
received and the default is we just want

00:37:16,070 --> 00:37:21,430
to call this connection right

00:37:24,400 --> 00:37:33,840
okay so let's just actually just see the

00:37:27,250 --> 00:37:33,840
game actually do something all right

00:37:34,620 --> 00:37:44,200
okay so let's start the server backup

00:37:36,970 --> 00:37:47,260
and now let's turn on the client okay

00:37:44,200 --> 00:37:50,860
okay now we have one guy connected all

00:37:47,260 --> 00:37:56,050
right let's turn on another client okay

00:37:50,860 --> 00:37:59,890
oh so there we go so you can see I have

00:37:56,050 --> 00:38:04,120
two clients here I can't bump into the

00:37:59,890 --> 00:38:10,570
other one um and then we can oh ouch

00:38:04,120 --> 00:38:20,230
okay oh okay I game over I want okay all

00:38:10,570 --> 00:38:24,910
right and my connection to the I don't

00:38:20,230 --> 00:38:30,880
know what's going on here oh there we go

00:38:24,910 --> 00:38:34,210
okay okay so I know I kind of went over

00:38:30,880 --> 00:38:35,860
a lot of coat there and it may not have

00:38:34,210 --> 00:38:37,840
been clearer some I'm open for quad if

00:38:35,860 --> 00:38:39,730
you have questions feel free to ask uh

00:38:37,840 --> 00:38:41,230
so let's let's talk about more

00:38:39,730 --> 00:38:44,800
traditional like low-level concurrency

00:38:41,230 --> 00:38:47,980
what's going on has a very nice sink

00:38:44,800 --> 00:38:49,390
library so I just there was something i

00:38:47,980 --> 00:38:50,890
went over that was called safe hash and

00:38:49,390 --> 00:38:56,800
i just want to talk a bit how that works

00:38:50,890 --> 00:39:00,190
and how it can be used on to do to do to

00:38:56,800 --> 00:39:04,860
to block without using channels and to

00:39:00,190 --> 00:39:07,180
make something concurrency safe so i

00:39:04,860 --> 00:39:09,520
basically there's a sink library and

00:39:07,180 --> 00:39:13,210
just comes with it becomes with it comes

00:39:09,520 --> 00:39:15,400
with a something called a mutex and what

00:39:13,210 --> 00:39:18,780
we do is we set up a structure here

00:39:15,400 --> 00:39:21,220
which is going to contain our hash and

00:39:18,780 --> 00:39:23,560
we're also going to have a special type

00:39:21,220 --> 00:39:26,440
in there called a mutex and immune texas

00:39:23,560 --> 00:39:29,230
just basically when when I have when I

00:39:26,440 --> 00:39:31,270
have something locked that means please

00:39:29,230 --> 00:39:33,730
don't write to me Igor you can't write

00:39:31,270 --> 00:39:36,079
to me and or you can't read for me

00:39:33,730 --> 00:39:39,650
depending on how its flipped

00:39:36,079 --> 00:39:43,309
so we take a look here we have an insert

00:39:39,650 --> 00:39:45,920
function of and so we do all that mutex

00:39:43,309 --> 00:39:49,999
and we say when I'm inserting a key I

00:39:45,920 --> 00:39:52,999
want to lock and I want to store a value

00:39:49,999 --> 00:39:54,499
in there after i'm locked and that means

00:39:52,999 --> 00:39:56,749
if something a concurrent process comes

00:39:54,499 --> 00:39:59,180
it will wait until it's unlocked to send

00:39:56,749 --> 00:40:03,259
its value in and then we have a defer

00:39:59,180 --> 00:40:05,150
there that will unlock the mutex and you

00:40:03,259 --> 00:40:07,759
can also see it also comes with read

00:40:05,150 --> 00:40:11,359
locks down below where you see a find

00:40:07,759 --> 00:40:13,849
there so that's that's sort of the sink

00:40:11,359 --> 00:40:20,680
library and that's more of a standard

00:40:13,849 --> 00:40:24,009
traditional sort of concurrency and

00:40:20,680 --> 00:40:24,009
demoting that time

00:40:35,240 --> 00:40:40,369
so the interesting about go here as you

00:40:38,119 --> 00:40:45,170
see me typing um there's a thing called

00:40:40,369 --> 00:40:47,210
a go path which we're all your code gets

00:40:45,170 --> 00:40:51,190
basically installed so is an environment

00:40:47,210 --> 00:40:51,190
variable that's why I'm going to home go

00:40:53,710 --> 00:41:09,470
okay so if we do the safe house here and

00:40:59,240 --> 00:41:14,300
let me zoom in and actually what I

00:41:09,470 --> 00:41:21,800
wanted to demo here what did I want to

00:41:14,300 --> 00:41:24,340
demo here we can actually see it working

00:41:21,800 --> 00:41:24,340
here

00:41:38,700 --> 00:41:43,950
so here's the safe map here where you

00:41:41,640 --> 00:41:48,270
basically we're using it as sort of like

00:41:43,950 --> 00:41:49,680
a shared memory between all the other so

00:41:48,270 --> 00:41:51,839
I just wanted to throw that in there as

00:41:49,680 --> 00:41:56,010
an example of how you can have sort of

00:41:51,839 --> 00:41:59,550
this kind of global shared memory that

00:41:56,010 --> 00:42:06,180
you can write to and read from within

00:41:59,550 --> 00:42:09,990
concurrent processes okay so to wrap up

00:42:06,180 --> 00:42:14,250
over here let's this is just an example

00:42:09,990 --> 00:42:16,050
and it's out on github and people are

00:42:14,250 --> 00:42:20,430
pull requests are totally welcome and

00:42:16,050 --> 00:42:25,230
also done do not program like me um go

00:42:20,430 --> 00:42:27,230
is a very simple language and but it's

00:42:25,230 --> 00:42:30,690
also very powerful of one of the things

00:42:27,230 --> 00:42:32,700
you'll discover is that well I feel very

00:42:30,690 --> 00:42:34,770
productive and go and it's easy to

00:42:32,700 --> 00:42:38,490
understand and get running with right

00:42:34,770 --> 00:42:40,290
away but there's definitely mastering

00:42:38,490 --> 00:42:43,109
some of the concurrency patterns that it

00:42:40,290 --> 00:42:47,760
offers are some things that will take

00:42:43,109 --> 00:42:49,950
time and you know as I was sort of

00:42:47,760 --> 00:42:54,000
saying earlier why should you care about

00:42:49,950 --> 00:42:56,609
learning go well but for me just

00:42:54,000 --> 00:42:58,890
learning new languages they're always it

00:42:56,609 --> 00:43:04,050
will generally it will make you a better

00:42:58,890 --> 00:43:05,520
programmer so thank you and thank you

00:43:04,050 --> 00:43:09,720
mediamath pro to allow me to have this

00:43:05,520 --> 00:43:15,109
talk and i will i am i'm open to

00:43:09,720 --> 00:43:15,109
entertaining questions yes

00:43:21,049 --> 00:43:32,339
yes oh actually check if it's locked oh

00:43:28,020 --> 00:43:37,380
ok yeah it's actually uh yeah it's not

00:43:32,339 --> 00:43:39,180
doing that yeah yes sorry he was asking

00:43:37,380 --> 00:43:46,970
me if I was checking if the mutex is

00:43:39,180 --> 00:43:46,970
locked and it is not doing that yes I

00:43:51,500 --> 00:43:56,160
just did the question was a safe hash

00:43:54,150 --> 00:44:02,930
something that you have to build and no

00:43:56,160 --> 00:44:02,930
you do not I just did that as a demo yes

00:44:15,410 --> 00:44:20,539
yes so the question is why else should i

00:44:17,690 --> 00:44:23,930
use go besides for a for some of the

00:44:20,539 --> 00:44:26,510
powerful concurrency constructs and I go

00:44:23,930 --> 00:44:29,180
is also known to be very fast it's a

00:44:26,510 --> 00:44:31,549
compiled language so you actually can

00:44:29,180 --> 00:44:32,960
compiled straight to machine code that

00:44:31,549 --> 00:44:39,710
can be distributed it's easy to deploy

00:44:32,960 --> 00:44:47,150
things to production so there have

00:44:39,710 --> 00:44:48,410
another reason yes the question was am I

00:44:47,150 --> 00:44:52,510
familiar with how the compilation

00:44:48,410 --> 00:44:52,510
happens I'm not certain what you mean by

00:44:53,380 --> 00:44:59,180
yes so is it C so I that's a good

00:44:57,710 --> 00:45:03,319
question i don't know i don't i don't

00:44:59,180 --> 00:45:05,000
know if I'm if I am the the person that

00:45:03,319 --> 00:45:08,000
should be answering that um but for my

00:45:05,000 --> 00:45:10,160
understanding is that it is see there is

00:45:08,000 --> 00:45:11,890
parts of it that with like the latest

00:45:10,160 --> 00:45:14,299
version of go that it's going to be more

00:45:11,890 --> 00:45:17,150
part of it isn't go itself the

00:45:14,299 --> 00:45:25,549
compilation um but i am not an expert in

00:45:17,150 --> 00:45:29,529
that yeah no you do not have that yeah

00:45:25,549 --> 00:45:29,529
yeah yes

00:45:33,640 --> 00:45:42,460
I see so the question was if it makes me

00:45:40,809 --> 00:45:43,690
currency easier can you distribute your

00:45:42,460 --> 00:45:46,839
code across the machines is that we

00:45:43,690 --> 00:45:48,760
you're asking um so you can do that

00:45:46,839 --> 00:45:51,250
through channels and it really shines

00:45:48,760 --> 00:45:54,400
when you're doing server to server or

00:45:51,250 --> 00:45:55,990
client to server type things so you get

00:45:54,400 --> 00:45:59,859
you just do it over a socket or whatever

00:45:55,990 --> 00:46:02,349
um so yes I think that sort of answers

00:45:59,859 --> 00:46:04,299
your maybe answers your question um but

00:46:02,349 --> 00:46:07,089
with it it actually takes the current

00:46:04,299 --> 00:46:10,119
currency is hidden away from the user so

00:46:07,089 --> 00:46:12,480
April when you actually use a go routine

00:46:10,119 --> 00:46:14,650
it's actually very lightweight um

00:46:12,480 --> 00:46:19,180
similar to light they're similar to

00:46:14,650 --> 00:46:21,940
threads from my understanding um however

00:46:19,180 --> 00:46:23,200
it will it will use you can spend you

00:46:21,940 --> 00:46:28,529
can spin up a thousand of them very

00:46:23,200 --> 00:46:30,880
cheaply um but it will only use how many

00:46:28,529 --> 00:46:32,619
aesthetic that you have available for

00:46:30,880 --> 00:46:38,609
that so I don't know if that answers

00:46:32,619 --> 00:46:38,609
your question may be okay yes

00:46:51,930 --> 00:46:55,869
exactly so the question I don't know if

00:46:55,000 --> 00:46:59,619
there's a question but more of a

00:46:55,869 --> 00:47:02,320
statement about channels and the channel

00:46:59,619 --> 00:47:06,910
it like yeah I don't know how to repeat

00:47:02,320 --> 00:47:21,270
that but yes I might go back here real

00:47:06,910 --> 00:47:25,810
quick yeah yes in a particular order

00:47:21,270 --> 00:47:27,510
yeah so uh if you wanted you so if you

00:47:25,810 --> 00:47:30,280
want a particular order you can actually

00:47:27,510 --> 00:47:33,040
so the question was how can you control

00:47:30,280 --> 00:47:35,800
order and there's different patterns

00:47:33,040 --> 00:47:37,359
with the using channels to do that and

00:47:35,800 --> 00:47:39,430
off the top of my head you could have

00:47:37,359 --> 00:47:41,859
multiple channels and so each one could

00:47:39,430 --> 00:47:44,440
basically be passing in a channel and

00:47:41,859 --> 00:47:46,540
you can actually use a there's another I

00:47:44,440 --> 00:47:48,790
didn't touch on this but there's a

00:47:46,540 --> 00:47:51,220
there's a there's a keyword called

00:47:48,790 --> 00:47:54,040
select and you can select based on what

00:47:51,220 --> 00:47:56,320
values are received from the channel and

00:47:54,040 --> 00:47:57,940
then do something so that's one way or

00:47:56,320 --> 00:48:09,119
the other way is you could use the sink

00:47:57,940 --> 00:48:09,119
library yes yes yes

00:48:14,730 --> 00:48:22,240
yeah so um so the question was what does

00:48:18,700 --> 00:48:25,740
the go testing library provide and how

00:48:22,240 --> 00:48:28,839
does it compare to pearl essentially so

00:48:25,740 --> 00:48:32,170
it it as I mentioned it actually offers

00:48:28,839 --> 00:48:34,540
some benchmarking on functions which are

00:48:32,170 --> 00:48:37,990
nice goes really big on trying for

00:48:34,540 --> 00:48:39,730
performance performance it's very

00:48:37,990 --> 00:48:42,730
rudimentary in my opinion is coming from

00:48:39,730 --> 00:48:45,730
pearl I I feel if their pearl has a much

00:48:42,730 --> 00:48:49,030
richer testing may as many more Richard

00:48:45,730 --> 00:48:50,109
testing libraries for example the

00:48:49,030 --> 00:48:55,480
testing library doesn't even have a

00:48:50,109 --> 00:48:58,599
basic assert function so what it exists

00:48:55,480 --> 00:49:00,520
to make the go test so when you type go

00:48:58,599 --> 00:49:03,250
test it will actually go and find those

00:49:00,520 --> 00:49:11,410
and that and it also does the

00:49:03,250 --> 00:49:13,119
specialized logging and yes i believe

00:49:11,410 --> 00:49:16,900
it's both but i don't know the exact

00:49:13,119 --> 00:49:18,220
details yeah any other questions I

00:49:16,900 --> 00:49:32,349
thought I saw someone back there but a

00:49:18,220 --> 00:49:34,780
missed them yes yes yes that broadcast

00:49:32,349 --> 00:49:36,160
was something I wrote yeah so the

00:49:34,780 --> 00:49:38,290
question was what was that broadcast

00:49:36,160 --> 00:49:41,109
doing broadcast was basically looping

00:49:38,290 --> 00:49:43,480
over an array of connections and it was

00:49:41,109 --> 00:49:44,650
sending a message over a channel and

00:49:43,480 --> 00:49:46,200
then the channel would receive that

00:49:44,650 --> 00:49:53,980
message and it would send it over a

00:49:46,200 --> 00:49:57,400
connection to yes well it depends on its

00:49:53,980 --> 00:50:00,730
type so channels wreck it so you most i

00:49:57,400 --> 00:50:04,990
was using string channels but you rivers

00:50:00,730 --> 00:50:08,940
or whatever sort of types yes channels

00:50:04,990 --> 00:50:08,940
are typed okay

00:50:10,150 --> 00:50:20,920
I depends on how you write it you can do

00:50:16,990 --> 00:50:22,930
it um I was doing it I see a message

00:50:20,920 --> 00:50:33,690
okay I'm sorry can you repeat the

00:50:22,930 --> 00:50:33,690
question yes

00:50:41,920 --> 00:50:46,070
okay so the question was when I was

00:50:44,930 --> 00:50:49,010
sending messages was I doing

00:50:46,070 --> 00:50:50,990
concurrently or not and it depends on

00:50:49,010 --> 00:50:53,060
how you write it the way I was doing and

00:50:50,990 --> 00:50:55,520
I was just looping over it which was not

00:50:53,060 --> 00:50:57,710
concurrent you could spin up a go

00:50:55,520 --> 00:51:02,120
routine which would then do it

00:50:57,710 --> 00:51:05,650
concurrently okay so i only have a

00:51:02,120 --> 00:51:05,650
couple more minutes any other questions

00:51:06,700 --> 00:51:11,560
okay well thank you everyone

00:51:22,850 --> 00:51:24,910

YouTube URL: https://www.youtube.com/watch?v=y573MDoLraY


