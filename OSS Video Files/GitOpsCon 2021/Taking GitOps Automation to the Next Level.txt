Title: Taking GitOps Automation to the Next Level
Publication date: 2021-04-29
Playlist: GitOpsCon 2021
Description: 
	We all know that GitOps can easily scale across hundreds of endpoints, but what about the ability for humans to scale to support many deployment files across multiple environments.  In this discussion, we will look to the future automation needs for scaling the human side of GitOps. Generation of .yaml files, separating the data from definition and the automation of pull request will be discussed as ways to take GitOps automation to the next level. Research from the Ortelius open-source community, a CDF incubating project, will be explored including what data is needed for auto-generating .yaml files, how to manage the metadata, and what is required to automate the pull request process as part of the CI/CD pipeline.
Captions: 
	00:00:01,360 --> 00:00:05,279
hello and thank you for attending my

00:00:03,280 --> 00:00:07,120
presentation i know there are a lot of

00:00:05,279 --> 00:00:09,120
good presentations so i so much

00:00:07,120 --> 00:00:10,960
appreciate you attending mine

00:00:09,120 --> 00:00:13,120
i'm going to talk to you today about

00:00:10,960 --> 00:00:14,799
taking get-ops automation to the next

00:00:13,120 --> 00:00:17,119
level

00:00:14,799 --> 00:00:18,960
but first just let me introduce myself

00:00:17,119 --> 00:00:21,119
my name is tracy reagan

00:00:18,960 --> 00:00:23,359
i am somewhat of a microservice

00:00:21,119 --> 00:00:25,359
evangelist i'm super passionate about

00:00:23,359 --> 00:00:26,480
configuration management and continuous

00:00:25,359 --> 00:00:28,320
deployment

00:00:26,480 --> 00:00:30,400
uh which is why i have interest in get

00:00:28,320 --> 00:00:33,600
ops i am the

00:00:30,400 --> 00:00:36,880
ceo and co-founder of deploy hub

00:00:33,600 --> 00:00:39,840
i was listed as a tech beacon last year

00:00:36,880 --> 00:00:41,520
in devops visionaries i'm a founding

00:00:39,840 --> 00:00:43,920
board member of the eclipse

00:00:41,520 --> 00:00:46,640
organization back in the day and i'm

00:00:43,920 --> 00:00:48,719
also a board member of the cd foundation

00:00:46,640 --> 00:00:50,160
i'm also a devops institute ambassador

00:00:48,719 --> 00:00:52,879
and i have been doing

00:00:50,160 --> 00:00:55,840
what we call devops now for my entire

00:00:52,879 --> 00:00:55,840
professional career

00:00:56,079 --> 00:01:00,559
so to really understand um what i'm

00:00:59,120 --> 00:01:01,760
talking about when i'm talking about

00:01:00,559 --> 00:01:04,080
bringing

00:01:01,760 --> 00:01:06,000
get ups uh upping the automation level

00:01:04,080 --> 00:01:08,320
and get ops is i think it's important to

00:01:06,000 --> 00:01:10,799
start at the beginning

00:01:08,320 --> 00:01:11,439
so in the beginning we started hearing

00:01:10,799 --> 00:01:12,880
about

00:01:11,439 --> 00:01:14,560
get ops it kind of followed

00:01:12,880 --> 00:01:16,960
infrastructure as code

00:01:14,560 --> 00:01:18,400
and this concept of operation by pull

00:01:16,960 --> 00:01:20,560
request

00:01:18,400 --> 00:01:21,600
with uh using leveraging git with an

00:01:20,560 --> 00:01:23,600
operator

00:01:21,600 --> 00:01:25,920
and in the beginning it was used by

00:01:23,600 --> 00:01:27,600
teams because they needed an immutable

00:01:25,920 --> 00:01:29,119
deployment process

00:01:27,600 --> 00:01:31,600
and they were containerizing their

00:01:29,119 --> 00:01:33,280
applications and moving into the cloud

00:01:31,600 --> 00:01:34,880
and they wanted to make sure nothing was

00:01:33,280 --> 00:01:38,159
tweaked

00:01:34,880 --> 00:01:40,640
in the process manually in particular

00:01:38,159 --> 00:01:42,479
so this idea of creating this hermetic

00:01:40,640 --> 00:01:44,720
or immutable deployment was

00:01:42,479 --> 00:01:46,479
very very interesting and infrastructure

00:01:44,720 --> 00:01:49,119
as code was sort of doing that

00:01:46,479 --> 00:01:52,560
and that's how we that's really where i

00:01:49,119 --> 00:01:52,560
first started seeing git ops

00:01:52,640 --> 00:01:56,320
and it was perfect for containerized

00:01:54,399 --> 00:01:58,320
apps it really solves some problems

00:01:56,320 --> 00:02:00,240
and when i say containerized apps i'm

00:01:58,320 --> 00:02:03,439
talking about taking a monolithic

00:02:00,240 --> 00:02:05,920
uh software solution an application

00:02:03,439 --> 00:02:06,719
um that is that is compiled and linked

00:02:05,920 --> 00:02:09,520
with all of its

00:02:06,719 --> 00:02:11,599
uh dependencies and then putting in a

00:02:09,520 --> 00:02:13,200
can it in a container with all of the

00:02:11,599 --> 00:02:15,440
dependencies that need that it needs to

00:02:13,200 --> 00:02:15,440
run

00:02:15,520 --> 00:02:21,440
the this is different from microservices

00:02:18,400 --> 00:02:23,680
and we're going to kind of dig into that

00:02:21,440 --> 00:02:25,360
but the the idea of containerizing your

00:02:23,680 --> 00:02:27,760
apps kind of insulated it from

00:02:25,360 --> 00:02:29,520
external changes and that's how many

00:02:27,760 --> 00:02:30,080
companies and how many companies still

00:02:29,520 --> 00:02:32,080
today

00:02:30,080 --> 00:02:34,640
are starting to migrate into a cloud

00:02:32,080 --> 00:02:34,640
environment

00:02:35,760 --> 00:02:39,440
so let's just talk about why it's

00:02:37,519 --> 00:02:42,080
brilliant why git ops was such a simple

00:02:39,440 --> 00:02:43,519
brilliant solution so i'm sure because

00:02:42,080 --> 00:02:45,360
you're at this conference you probably

00:02:43,519 --> 00:02:46,400
know this but some of you may not so i'm

00:02:45,360 --> 00:02:49,120
just going to go over this

00:02:46,400 --> 00:02:51,280
the architecture of it in a git ops

00:02:49,120 --> 00:02:53,599
environment you have your cluster

00:02:51,280 --> 00:02:55,360
and you have your application running in

00:02:53,599 --> 00:02:57,519
your cluster and in the cluster you have

00:02:55,360 --> 00:03:00,480
a git ops operator

00:02:57,519 --> 00:03:01,840
um a get ops operator monitors a docker

00:03:00,480 --> 00:03:05,040
registry or a query

00:03:01,840 --> 00:03:08,319
or a registry of some sort to to

00:03:05,040 --> 00:03:11,120
retrieve uh containers from

00:03:08,319 --> 00:03:12,000
but it gets its its information from

00:03:11,120 --> 00:03:14,720
your

00:03:12,000 --> 00:03:15,920
your git repository so in a git ops

00:03:14,720 --> 00:03:18,239
model you have two

00:03:15,920 --> 00:03:19,680
repositories you have your your code

00:03:18,239 --> 00:03:21,599
repository and in this

00:03:19,680 --> 00:03:22,720
example i have the hipster store code

00:03:21,599 --> 00:03:24,000
repository

00:03:22,720 --> 00:03:25,840
and then you have an environment

00:03:24,000 --> 00:03:27,760
repository where you store your

00:03:25,840 --> 00:03:29,680
your your deployment file and this could

00:03:27,760 --> 00:03:30,720
be a kubernetes deployment file or it

00:03:29,680 --> 00:03:33,360
could be a

00:03:30,720 --> 00:03:35,519
helm deployment file but the important

00:03:33,360 --> 00:03:37,200
thing to understand is it's declaring a

00:03:35,519 --> 00:03:39,920
desired state

00:03:37,200 --> 00:03:40,720
and instead of you having an imperative

00:03:39,920 --> 00:03:42,640
script

00:03:40,720 --> 00:03:44,319
you have a declarative one that says i

00:03:42,640 --> 00:03:46,159
this is the state i want

00:03:44,319 --> 00:03:48,000
and the get ops operator delivers

00:03:46,159 --> 00:03:49,360
delivers it for you and understands how

00:03:48,000 --> 00:03:52,239
to do that

00:03:49,360 --> 00:03:52,879
um it it looks at things like the the

00:03:52,239 --> 00:03:55,200
shaw

00:03:52,879 --> 00:03:57,280
and it determines what uh docker

00:03:55,200 --> 00:03:58,879
registry what container you need to pull

00:03:57,280 --> 00:04:02,080
from that registry

00:03:58,879 --> 00:04:04,879
so it's it's the

00:04:02,080 --> 00:04:05,280
end user has to update the scripts and

00:04:04,879 --> 00:04:09,120
and

00:04:05,280 --> 00:04:11,680
push it up to the um repository

00:04:09,120 --> 00:04:12,319
and then your regular pull request and

00:04:11,680 --> 00:04:16,000
your

00:04:12,319 --> 00:04:18,320
approvals merge occur once it's in the

00:04:16,000 --> 00:04:19,040
environment repository the get ops

00:04:18,320 --> 00:04:21,120
operator

00:04:19,040 --> 00:04:23,120
monitors that and make sure that the

00:04:21,120 --> 00:04:25,840
desired state is achieved at your

00:04:23,120 --> 00:04:25,840
cluster level

00:04:27,440 --> 00:04:32,560
so a developer makes an update to the

00:04:29,360 --> 00:04:34,400
code commits the changes to get

00:04:32,560 --> 00:04:35,840
a new container image is created and

00:04:34,400 --> 00:04:38,160
registered now this can

00:04:35,840 --> 00:04:39,440
be done manually or via a pipeline

00:04:38,160 --> 00:04:41,600
process

00:04:39,440 --> 00:04:43,600
which creates a new container tag then

00:04:41,600 --> 00:04:45,600
this tag is unique to that specific

00:04:43,600 --> 00:04:47,600
container

00:04:45,600 --> 00:04:49,600
the developer updates the deployment

00:04:47,600 --> 00:04:50,960
yaml file with that new tag

00:04:49,600 --> 00:04:53,120
and commits it back to the get

00:04:50,960 --> 00:04:55,199
environment repository

00:04:53,120 --> 00:04:56,960
the githubs operator sees the new new

00:04:55,199 --> 00:04:57,600
commit updates to cluster with the new

00:04:56,960 --> 00:05:00,639
container

00:04:57,600 --> 00:05:01,680
and as i say it's that was brilliant and

00:05:00,639 --> 00:05:05,199
the solution is

00:05:01,680 --> 00:05:07,280
immutable it is airtight it is hermetic

00:05:05,199 --> 00:05:08,320
a manual tweak to the cluster is

00:05:07,280 --> 00:05:11,280
overlaid uh

00:05:08,320 --> 00:05:12,880
if if a manual tweak to the cluster um

00:05:11,280 --> 00:05:14,320
occurs somebody goes out there and does

00:05:12,880 --> 00:05:17,199
something manually

00:05:14,320 --> 00:05:18,880
or through some kind of cli or interface

00:05:17,199 --> 00:05:19,440
the cluster overlays that the cluster

00:05:18,880 --> 00:05:21,199
says oh

00:05:19,440 --> 00:05:22,880
i'm out of sync i'm gonna bring you back

00:05:21,199 --> 00:05:24,400
into the desired state

00:05:22,880 --> 00:05:26,639
so everything you do everything you

00:05:24,400 --> 00:05:29,600
track is done by this

00:05:26,639 --> 00:05:32,320
check-in process which is operations by

00:05:29,600 --> 00:05:32,320
pull request

00:05:34,160 --> 00:05:38,160
so it had big benefits and it has big

00:05:37,440 --> 00:05:40,800
benefits

00:05:38,160 --> 00:05:41,360
because without a change in the way we

00:05:40,800 --> 00:05:44,639
work

00:05:41,360 --> 00:05:47,360
um everybody pretty much knows how to

00:05:44,639 --> 00:05:50,400
submit a change request or i'm sorry

00:05:47,360 --> 00:05:53,600
submit a pull request

00:05:50,400 --> 00:05:55,680
we were able to create a hermetic

00:05:53,600 --> 00:05:57,440
deployment process

00:05:55,680 --> 00:06:00,400
um that didn't require a whole lot of

00:05:57,440 --> 00:06:02,479
learning um and was super easy

00:06:00,400 --> 00:06:04,880
uh just checking in the code or

00:06:02,479 --> 00:06:06,080
triggering uh an action and gitops has

00:06:04,880 --> 00:06:10,400
created this

00:06:06,080 --> 00:06:10,400
airtight deployment process for for us

00:06:10,479 --> 00:06:14,560
with this process one of the benefits is

00:06:13,039 --> 00:06:16,560
the governance around it

00:06:14,560 --> 00:06:18,000
the auditability and we have a high

00:06:16,560 --> 00:06:20,800
level of confidence

00:06:18,000 --> 00:06:21,759
like pretty much 100 percent that what

00:06:20,800 --> 00:06:23,120
is stored in git

00:06:21,759 --> 00:06:25,199
is represented and running out in the

00:06:23,120 --> 00:06:26,560
cluster so if you needed to compare what

00:06:25,199 --> 00:06:29,520
was happening between

00:06:26,560 --> 00:06:30,800
um two clusters you can look at the uh

00:06:29,520 --> 00:06:32,479
the the yaml files

00:06:30,800 --> 00:06:34,800
and see what changed between any two

00:06:32,479 --> 00:06:37,520
gamma files

00:06:34,800 --> 00:06:40,560
so it's a super simple solution with

00:06:37,520 --> 00:06:43,280
super big benefits

00:06:40,560 --> 00:06:45,199
manual tweaks and imperative scripts

00:06:43,280 --> 00:06:48,000
were completely eliminated

00:06:45,199 --> 00:06:49,840
and that in essence was the goal of get

00:06:48,000 --> 00:06:52,960
ops and it's the goal of infrastructure

00:06:49,840 --> 00:06:52,960
as code in general

00:06:54,479 --> 00:06:59,039
so the question we have to ask ourselves

00:06:56,720 --> 00:07:01,680
can get up scale

00:06:59,039 --> 00:07:02,720
and i think we all know that from an

00:07:01,680 --> 00:07:06,160
architecture

00:07:02,720 --> 00:07:07,280
perspective it can it can scale to as

00:07:06,160 --> 00:07:10,720
many

00:07:07,280 --> 00:07:13,039
clusters as needed

00:07:10,720 --> 00:07:14,960
a git ops operator is going to run in

00:07:13,039 --> 00:07:16,000
each cluster and it manages that cluster

00:07:14,960 --> 00:07:17,440
in particular

00:07:16,000 --> 00:07:18,800
if you have hundreds of clusters you're

00:07:17,440 --> 00:07:20,080
going to have hundreds of operators and

00:07:18,800 --> 00:07:22,000
they're doing their job for that

00:07:20,080 --> 00:07:25,039
particular cluster

00:07:22,000 --> 00:07:27,919
so scaling across the the organization

00:07:25,039 --> 00:07:31,840
is again one of the benefits of the get

00:07:27,919 --> 00:07:31,840
ops architecture

00:07:31,919 --> 00:07:37,280
but we have to start thinking about it's

00:07:34,880 --> 00:07:40,560
how it scales on the human side what

00:07:37,280 --> 00:07:42,400
interaction a human needs to

00:07:40,560 --> 00:07:45,039
to take what steps they need to take to

00:07:42,400 --> 00:07:47,360
make git ups work and this is really

00:07:45,039 --> 00:07:49,599
the premise of this discussion is what's

00:07:47,360 --> 00:07:52,080
the next level of automation

00:07:49,599 --> 00:07:53,360
and understand why we need it we need to

00:07:52,080 --> 00:07:56,720
see how

00:07:53,360 --> 00:07:59,039
the how scaling is impacted

00:07:56,720 --> 00:08:00,080
when we start using get ops across a

00:07:59,039 --> 00:08:02,720
pipeline

00:08:00,080 --> 00:08:04,160
and again when we increase the number of

00:08:02,720 --> 00:08:05,919
yml files when we start using

00:08:04,160 --> 00:08:08,639
microservices

00:08:05,919 --> 00:08:09,440
so let's just take a our first scenario

00:08:08,639 --> 00:08:13,199
where we have

00:08:09,440 --> 00:08:16,960
a containerized application

00:08:13,199 --> 00:08:20,080
in a typical get ups implementation

00:08:16,960 --> 00:08:22,879
you are going to have a

00:08:20,080 --> 00:08:25,120
branch of your yaml files to support

00:08:22,879 --> 00:08:28,879
devtest and prod

00:08:25,120 --> 00:08:31,280
uh each environment may contain

00:08:28,879 --> 00:08:32,560
separate variables or separate separate

00:08:31,280 --> 00:08:34,959
definitions that are

00:08:32,560 --> 00:08:35,919
unique to that environment development

00:08:34,959 --> 00:08:38,719
production

00:08:35,919 --> 00:08:40,080
may not be the same in some cases you

00:08:38,719 --> 00:08:43,039
may just have one trunk

00:08:40,080 --> 00:08:43,599
and you may have multiple yaml files

00:08:43,039 --> 00:08:45,760
that the

00:08:43,599 --> 00:08:47,600
the operator interrogates to try to sort

00:08:45,760 --> 00:08:48,160
out what what variables need to be

00:08:47,600 --> 00:08:51,440
applied

00:08:48,160 --> 00:08:55,120
to that cluster based on what state

00:08:51,440 --> 00:08:57,040
it's it's managing so in this case

00:08:55,120 --> 00:08:59,120
we've already in the simple case we've

00:08:57,040 --> 00:09:01,920
already broken up

00:08:59,120 --> 00:09:03,120
our simple single yaml file into three

00:09:01,920 --> 00:09:06,640
yaml files

00:09:03,120 --> 00:09:09,279
one to support dev test and prod and

00:09:06,640 --> 00:09:10,640
this is a very simple pipeline many of

00:09:09,279 --> 00:09:11,760
you probably have many other steps in

00:09:10,640 --> 00:09:14,640
your pipeline

00:09:11,760 --> 00:09:16,160
we have companies that support many many

00:09:14,640 --> 00:09:18,480
different

00:09:16,160 --> 00:09:20,080
testing clusters and they have phases of

00:09:18,480 --> 00:09:22,800
testing that they go through

00:09:20,080 --> 00:09:23,680
so in this simple pipeline we have three

00:09:22,800 --> 00:09:25,519
you could have

00:09:23,680 --> 00:09:27,600
multiple months just for your single

00:09:25,519 --> 00:09:30,640
container running across your different

00:09:27,600 --> 00:09:30,640
pipeline stages

00:09:31,600 --> 00:09:35,600
so let's take this journey one step

00:09:34,080 --> 00:09:37,519
further and let's go into the

00:09:35,600 --> 00:09:39,839
microservices world

00:09:37,519 --> 00:09:42,000
we began our journey with a container

00:09:39,839 --> 00:09:45,120
containerized application

00:09:42,000 --> 00:09:48,240
but now we want to deploy microservices

00:09:45,120 --> 00:09:50,320
and as you know microservices are the

00:09:48,240 --> 00:09:52,160
process of taking your container your

00:09:50,320 --> 00:09:53,839
your monolithic application that we

00:09:52,160 --> 00:09:56,000
stuck in that container

00:09:53,839 --> 00:09:58,880
and decomposing it and everybody knows

00:09:56,000 --> 00:10:02,959
that breaking up is really hard to do

00:09:58,880 --> 00:10:07,040
and it creates more complication

00:10:02,959 --> 00:10:08,800
in the pipeline and in our get ops model

00:10:07,040 --> 00:10:10,800
and the reason why is the number of yml

00:10:08,800 --> 00:10:12,959
files and i'm always going back to this

00:10:10,800 --> 00:10:14,000
is a discussion around scaling the human

00:10:12,959 --> 00:10:15,600
part of git ops

00:10:14,000 --> 00:10:17,680
and when we have more yaml files that

00:10:15,600 --> 00:10:20,079
we're managing across the pipeline

00:10:17,680 --> 00:10:21,120
it potentially makes it more difficult

00:10:20,079 --> 00:10:25,200
for we

00:10:21,120 --> 00:10:25,200
devops humans to manage it

00:10:26,240 --> 00:10:30,079
so let's take a look at a simple very

00:10:28,079 --> 00:10:32,480
simple example

00:10:30,079 --> 00:10:33,600
we have a online store company here they

00:10:32,480 --> 00:10:36,399
have two

00:10:33,600 --> 00:10:38,720
two front ends they have a candy store

00:10:36,399 --> 00:10:40,560
and they have a hipster store

00:10:38,720 --> 00:10:42,320
the candy store and the hipster store

00:10:40,560 --> 00:10:45,120
they share services

00:10:42,320 --> 00:10:47,519
they use the same shipping the same cart

00:10:45,120 --> 00:10:48,880
and the same payment service

00:10:47,519 --> 00:10:50,640
but the way that they've implemented

00:10:48,880 --> 00:10:52,079
this is they have used they've added the

00:10:50,640 --> 00:10:53,760
candy store has a cluster and the

00:10:52,079 --> 00:10:55,600
hipster store has a cluster

00:10:53,760 --> 00:10:57,120
and they each have their own get ops

00:10:55,600 --> 00:11:00,160
operator

00:10:57,120 --> 00:11:02,079
so when we when we use a get ops

00:11:00,160 --> 00:11:04,800
model we are going to have a candy store

00:11:02,079 --> 00:11:07,600
repo for this this is just for one state

00:11:04,800 --> 00:11:09,040
for production and we're going to manage

00:11:07,600 --> 00:11:11,040
the ammo files for the

00:11:09,040 --> 00:11:12,320
the cart the shipping and the payment

00:11:11,040 --> 00:11:13,600
and in the same way we're going to do

00:11:12,320 --> 00:11:15,120
that with

00:11:13,600 --> 00:11:18,079
the shipping payment and the cart

00:11:15,120 --> 00:11:21,279
service in the in the hipster store repo

00:11:18,079 --> 00:11:24,399
so there's four yama piles uh four yaml

00:11:21,279 --> 00:11:27,519
files per state

00:11:24,399 --> 00:11:28,959
so as you can see we begin to start

00:11:27,519 --> 00:11:30,880
having the need to manage

00:11:28,959 --> 00:11:32,000
many yama files for many different

00:11:30,880 --> 00:11:34,880
environments

00:11:32,000 --> 00:11:35,440
so in this case we're managing 15 yama

00:11:34,880 --> 00:11:37,680
files

00:11:35,440 --> 00:11:39,839
uh for this now in the when we were

00:11:37,680 --> 00:11:41,440
doing it in a single container

00:11:39,839 --> 00:11:43,519
we had one ammo file for the entire

00:11:41,440 --> 00:11:45,200
container when we start breaking it up

00:11:43,519 --> 00:11:46,480
we start breaking up the number of yama

00:11:45,200 --> 00:11:47,680
files we need for these different

00:11:46,480 --> 00:11:49,839
services

00:11:47,680 --> 00:11:50,720
and then we add the pipeline we we end

00:11:49,839 --> 00:11:53,920
up with

00:11:50,720 --> 00:11:55,360
you know a good number of cert of yaml

00:11:53,920 --> 00:11:58,720
files that we're having to manage in

00:11:55,360 --> 00:12:02,320
this get githubs process

00:11:58,720 --> 00:12:05,519
so i know the point lots of yaml files

00:12:02,320 --> 00:12:06,720
so as we expand into microservice

00:12:05,519 --> 00:12:10,000
architecture

00:12:06,720 --> 00:12:12,560
we're adding exponentially the number of

00:12:10,000 --> 00:12:15,360
files we're managing and get and that

00:12:12,560 --> 00:12:18,000
can be a human problem

00:12:15,360 --> 00:12:18,399
and even though we consider this as a

00:12:18,000 --> 00:12:21,360
pull

00:12:18,399 --> 00:12:21,920
process a human is pushing it they're

00:12:21,360 --> 00:12:24,560
pushing

00:12:21,920 --> 00:12:25,440
updates into this environment repo or or

00:12:24,560 --> 00:12:27,680
in a segmented

00:12:25,440 --> 00:12:28,959
environment repo and they're managing

00:12:27,680 --> 00:12:31,120
merges

00:12:28,959 --> 00:12:32,720
so there's work to be done there and

00:12:31,120 --> 00:12:36,240
it's in this part is

00:12:32,720 --> 00:12:37,680
is manual and in our world of automation

00:12:36,240 --> 00:12:39,839
in the ci cd pipeline

00:12:37,680 --> 00:12:42,399
discussion we don't want to do things

00:12:39,839 --> 00:12:45,600
manually we want to automate everything

00:12:42,399 --> 00:12:46,480
and while the the actual deployment once

00:12:45,600 --> 00:12:49,040
we get the

00:12:46,480 --> 00:12:50,240
yama file updated into the correct git

00:12:49,040 --> 00:12:53,440
repository

00:12:50,240 --> 00:12:55,200
well that then is automated the process

00:12:53,440 --> 00:12:58,560
of getting it to that point

00:12:55,200 --> 00:13:00,480
is manual so yes it took me a bit to get

00:12:58,560 --> 00:13:04,079
there but now we've arrived in my

00:13:00,480 --> 00:13:07,040
um in my discussion about how we need to

00:13:04,079 --> 00:13:07,920
and why we need to automate more of the

00:13:07,040 --> 00:13:10,000
gitops

00:13:07,920 --> 00:13:12,320
process and now i'm going to talk about

00:13:10,000 --> 00:13:12,320
how

00:13:12,639 --> 00:13:16,560
so i'm going to introduce to you an open

00:13:14,320 --> 00:13:19,600
source project called ortelius

00:13:16,560 --> 00:13:22,399
ortilius is an open source project

00:13:19,600 --> 00:13:24,560
incubating at the cd foundation it's a

00:13:22,399 --> 00:13:25,200
microservice management platform that

00:13:24,560 --> 00:13:27,680
versions

00:13:25,200 --> 00:13:28,240
and tracks microservices their blast

00:13:27,680 --> 00:13:30,800
radius

00:13:28,240 --> 00:13:32,480
and inventory across clusters this

00:13:30,800 --> 00:13:34,800
provides you a proactive view

00:13:32,480 --> 00:13:37,600
of your microservice architecture as it

00:13:34,800 --> 00:13:40,480
changes over time

00:13:37,600 --> 00:13:40,800
our mission at the open source project

00:13:40,480 --> 00:13:43,279
is

00:13:40,800 --> 00:13:45,600
to really simplify the adoption of micro

00:13:43,279 --> 00:13:48,000
services through this world-class

00:13:45,600 --> 00:13:49,680
microservice management platform and i'm

00:13:48,000 --> 00:13:50,560
very proud to say we have an amazing

00:13:49,680 --> 00:13:52,079
diverse

00:13:50,560 --> 00:13:54,240
group of committers that come from

00:13:52,079 --> 00:13:58,639
everywhere from

00:13:54,240 --> 00:14:00,720
from nairobi to south africa to pakistan

00:13:58,639 --> 00:14:02,000
of course india and the united states

00:14:00,720 --> 00:14:04,639
germany we're all

00:14:02,000 --> 00:14:04,639
over the place

00:14:05,519 --> 00:14:08,800
so let me talk to you about what

00:14:06,720 --> 00:14:10,079
artilleus does today because i want to

00:14:08,800 --> 00:14:10,959
explain to you what we're looking at

00:14:10,079 --> 00:14:13,199
doing

00:14:10,959 --> 00:14:15,199
for addressing this problem of

00:14:13,199 --> 00:14:18,000
automating that getups

00:14:15,199 --> 00:14:19,680
the human side of get ups so right now

00:14:18,000 --> 00:14:23,199
the way ortilius works

00:14:19,680 --> 00:14:26,399
with the pipeline is it it gets

00:14:23,199 --> 00:14:30,000
woken up at the time that a container is

00:14:26,399 --> 00:14:31,760
a new container is registered

00:14:30,000 --> 00:14:34,800
so let me tell you how ortillius

00:14:31,760 --> 00:14:38,720
interfaces with the pipeline today

00:14:34,800 --> 00:14:40,720
ortillius can support your pipeline and

00:14:38,720 --> 00:14:42,880
it gets triggered at the point in time

00:14:40,720 --> 00:14:44,639
that a new container is registered

00:14:42,880 --> 00:14:47,040
that's when we get triggered

00:14:44,639 --> 00:14:48,560
and when ortillius gets triggered it

00:14:47,040 --> 00:14:50,720
captures the shaw

00:14:48,560 --> 00:14:52,800
and it uses the shaw as a unique

00:14:50,720 --> 00:14:54,720
identifier for that particular container

00:14:52,800 --> 00:14:55,680
and it creates a version of that

00:14:54,720 --> 00:14:59,360
container

00:14:55,680 --> 00:15:01,199
or what we call a component it could be

00:14:59,360 --> 00:15:02,399
it could be anything quite honest it

00:15:01,199 --> 00:15:05,199
doesn't have to be a

00:15:02,399 --> 00:15:06,959
container so we call it a component but

00:15:05,199 --> 00:15:08,800
if it's a container we capture the shaw

00:15:06,959 --> 00:15:11,760
and we map all the relationships it has

00:15:08,800 --> 00:15:12,959
to any of the consuming applications

00:15:11,760 --> 00:15:15,040
i'm not going to get in to tell you how

00:15:12,959 --> 00:15:17,760
we do that it's pretty simple

00:15:15,040 --> 00:15:20,240
but the point is that we conversion that

00:15:17,760 --> 00:15:24,000
kind of information

00:15:20,240 --> 00:15:27,440
once the deployment occurs

00:15:24,000 --> 00:15:28,320
we are notified again we so we track the

00:15:27,440 --> 00:15:31,440
deployment

00:15:28,320 --> 00:15:34,079
we are notified where it went to

00:15:31,440 --> 00:15:34,959
we would call helm in this case helmer

00:15:34,079 --> 00:15:37,519
spinnaker

00:15:34,959 --> 00:15:38,320
and we would get a feed get feedback

00:15:37,519 --> 00:15:40,880
that says this

00:15:38,320 --> 00:15:42,880
microservice now has been installed into

00:15:40,880 --> 00:15:44,800
this cluster

00:15:42,880 --> 00:15:47,279
so ortelius listens and tracks the

00:15:44,800 --> 00:15:49,759
inventory across all clusters

00:15:47,279 --> 00:15:50,480
it has a full set of apis that we can

00:15:49,759 --> 00:15:52,320
work with

00:15:50,480 --> 00:15:54,079
and it has something that i consider

00:15:52,320 --> 00:15:57,199
very important to this particular

00:15:54,079 --> 00:15:59,839
uh problem set which is this data store

00:15:57,199 --> 00:16:01,600
because what we are creating is a a

00:15:59,839 --> 00:16:02,720
central database of configuration

00:16:01,600 --> 00:16:05,199
management data

00:16:02,720 --> 00:16:09,839
that contains the what's needed to

00:16:05,199 --> 00:16:09,839
automate the update of the yaml files

00:16:10,079 --> 00:16:14,480
so in other words ortilius hoards

00:16:13,279 --> 00:16:16,399
metadata

00:16:14,480 --> 00:16:19,199
and it creates the central catalog of

00:16:16,399 --> 00:16:21,040
microservice configuration management

00:16:19,199 --> 00:16:23,440
it also separates the data from the

00:16:21,040 --> 00:16:24,160
definition and store keys value pairs

00:16:23,440 --> 00:16:27,199
based on

00:16:24,160 --> 00:16:29,440
environments and right now what we do is

00:16:27,199 --> 00:16:31,199
we generate a helm overrides file based

00:16:29,440 --> 00:16:32,480
on the environment and then

00:16:31,199 --> 00:16:35,040
and then it calls home to do the

00:16:32,480 --> 00:16:36,399
deployment using that override file

00:16:35,040 --> 00:16:39,440
based on the environment it's being

00:16:36,399 --> 00:16:41,040
deployed to ortillius stores the things

00:16:39,440 --> 00:16:44,000
like the shaw on the image tag

00:16:41,040 --> 00:16:46,079
and uses that to create a new version

00:16:44,000 --> 00:16:48,639
for that specific container

00:16:46,079 --> 00:16:50,079
now not necessary for this discussion

00:16:48,639 --> 00:16:52,720
but i think it's important to know

00:16:50,079 --> 00:16:54,880
that in a microservices world you have

00:16:52,720 --> 00:16:56,959
to think about

00:16:54,880 --> 00:16:58,160
we are doing linking very different than

00:16:56,959 --> 00:17:00,079
in monolithic

00:16:58,160 --> 00:17:02,079
in the monolithic approach what we did

00:17:00,079 --> 00:17:03,040
was we would compile a link or

00:17:02,079 --> 00:17:05,439
application

00:17:03,040 --> 00:17:06,240
and any external library we would use we

00:17:05,439 --> 00:17:08,160
would link it

00:17:06,240 --> 00:17:09,600
statically link it into our binary or

00:17:08,160 --> 00:17:12,079
jar file a war file

00:17:09,600 --> 00:17:13,919
and push that out in a microservices

00:17:12,079 --> 00:17:16,799
world we don't do that the linking is

00:17:13,919 --> 00:17:19,360
done via apis at runtime

00:17:16,799 --> 00:17:20,640
so when ortelius starts managing this

00:17:19,360 --> 00:17:23,039
kind of data

00:17:20,640 --> 00:17:24,240
as pushed across the pipeline what it

00:17:23,039 --> 00:17:26,480
does is it says hey

00:17:24,240 --> 00:17:28,160
i have a new version of a microservice

00:17:26,480 --> 00:17:30,720
which means that any

00:17:28,160 --> 00:17:32,320
consuming application has a new version

00:17:30,720 --> 00:17:33,919
so it doesn't just

00:17:32,320 --> 00:17:35,679
version the microservices or the

00:17:33,919 --> 00:17:37,280
container it also versions the

00:17:35,679 --> 00:17:39,760
application that's consuming that

00:17:37,280 --> 00:17:41,520
particular service

00:17:39,760 --> 00:17:43,600
so this is the kind of the data that we

00:17:41,520 --> 00:17:45,919
would will use to automate what we like

00:17:43,600 --> 00:17:48,400
to call the human side of devops or

00:17:45,919 --> 00:17:48,400
gitops

00:17:48,880 --> 00:17:53,280
so there's two ways that we're looking

00:17:51,200 --> 00:17:54,559
at this is a project we will be working

00:17:53,280 --> 00:17:57,360
on

00:17:54,559 --> 00:17:58,880
in the early fall we're right now

00:17:57,360 --> 00:18:00,640
gathering our requirements and really

00:17:58,880 --> 00:18:02,480
understanding um

00:18:00,640 --> 00:18:04,240
a needs analysis and where this should

00:18:02,480 --> 00:18:06,559
be how this should be implemented

00:18:04,240 --> 00:18:08,880
but these are our thoughts for now so

00:18:06,559 --> 00:18:11,440
there's two generic ways that we can

00:18:08,880 --> 00:18:13,280
automate all the steps that a human does

00:18:11,440 --> 00:18:16,160
to make git ops work

00:18:13,280 --> 00:18:17,840
and put that into the pipeline so that

00:18:16,160 --> 00:18:20,080
you could have a get ups model that's

00:18:17,840 --> 00:18:22,320
driven by your pipeline

00:18:20,080 --> 00:18:24,240
the first way is helm and get up so if

00:18:22,320 --> 00:18:26,080
you have a helm get ups operator

00:18:24,240 --> 00:18:27,760
what artillious will do is very very

00:18:26,080 --> 00:18:29,840
similar to what it does today it will

00:18:27,760 --> 00:18:31,840
generate the values

00:18:29,840 --> 00:18:33,840
for the yama file for the correct

00:18:31,840 --> 00:18:36,000
environment

00:18:33,840 --> 00:18:36,960
for checking that into the environment

00:18:36,000 --> 00:18:38,799
repository

00:18:36,960 --> 00:18:42,160
once it's generated it would automate

00:18:38,799 --> 00:18:44,240
the check-in of the new yama file after

00:18:42,160 --> 00:18:45,360
the check in then ortilius will issue a

00:18:44,240 --> 00:18:48,080
pull request just

00:18:45,360 --> 00:18:50,480
to stage the change and if allowed it

00:18:48,080 --> 00:18:53,600
can automatically do the approval

00:18:50,480 --> 00:18:56,000
now what that does is it replaces

00:18:53,600 --> 00:18:57,200
a human having to do all of those extra

00:18:56,000 --> 00:18:58,960
steps

00:18:57,200 --> 00:19:00,960
we don't necessarily need a human to do

00:18:58,960 --> 00:19:02,960
it we just need to get that information

00:19:00,960 --> 00:19:04,559
into get so we want to automate those

00:19:02,960 --> 00:19:06,480
steps

00:19:04,559 --> 00:19:08,480
now the second way is a kubernetes

00:19:06,480 --> 00:19:11,840
deployment ammo file

00:19:08,480 --> 00:19:13,840
very similar ortillius would read the

00:19:11,840 --> 00:19:15,200
existing deployment file and update the

00:19:13,840 --> 00:19:17,039
new values

00:19:15,200 --> 00:19:20,080
based on the environment it's going to

00:19:17,039 --> 00:19:22,480
and where it needs to be checked into

00:19:20,080 --> 00:19:24,880
after the check-in ortilius would issue

00:19:22,480 --> 00:19:26,559
the pull request to stage the change

00:19:24,880 --> 00:19:28,880
and then it would automate the approval

00:19:26,559 --> 00:19:30,559
if it's allowed

00:19:28,880 --> 00:19:32,240
automating the approvals are some things

00:19:30,559 --> 00:19:34,640
you'd have to make a decision to do

00:19:32,240 --> 00:19:36,320
you could certainly make a human do that

00:19:34,640 --> 00:19:38,320
but when we do that we start

00:19:36,320 --> 00:19:41,200
interrupting the cd pipeline and i know

00:19:38,320 --> 00:19:43,760
that production releases and

00:19:41,200 --> 00:19:46,559
continuous deployments not consumed by

00:19:43,760 --> 00:19:49,200
every single user of a ci cd pipeline

00:19:46,559 --> 00:19:50,559
it needs to be it should be a consistent

00:19:49,200 --> 00:19:53,280
repeatable process

00:19:50,559 --> 00:19:54,400
across the pipeline the way you deploy

00:19:53,280 --> 00:19:56,480
to development

00:19:54,400 --> 00:19:57,600
should be exactly the same as you deploy

00:19:56,480 --> 00:20:00,240
to test and

00:19:57,600 --> 00:20:00,720
production and with the get ops model we

00:20:00,240 --> 00:20:03,039
have an

00:20:00,720 --> 00:20:04,080
opportunity to actually do that the

00:20:03,039 --> 00:20:06,159
challenge will be

00:20:04,080 --> 00:20:07,840
getting that automation so that we can

00:20:06,159 --> 00:20:09,840
drive it into the pipeline

00:20:07,840 --> 00:20:12,159
allow the cd pipeline to execute the

00:20:09,840 --> 00:20:15,280
process and this may

00:20:12,159 --> 00:20:17,360
these may be events at some point so we

00:20:15,280 --> 00:20:20,880
would have an event called

00:20:17,360 --> 00:20:22,880
ortilius to create the yaml file another

00:20:20,880 --> 00:20:23,919
event would create the uh the pull

00:20:22,880 --> 00:20:25,840
request and

00:20:23,919 --> 00:20:28,480
do the another event might do the

00:20:25,840 --> 00:20:29,200
approval so we're moving into a very new

00:20:28,480 --> 00:20:32,320
world

00:20:29,200 --> 00:20:34,320
of devops and a cd pipeline

00:20:32,320 --> 00:20:35,440
and how we can actually change the way

00:20:34,320 --> 00:20:37,919
we do work

00:20:35,440 --> 00:20:38,960
and when we do that we need to make sure

00:20:37,919 --> 00:20:42,000
that the production

00:20:38,960 --> 00:20:44,640
updates are handled through the pipeline

00:20:42,000 --> 00:20:46,480
in the same way as dev and test is

00:20:44,640 --> 00:20:48,000
i know some companies are doing it quite

00:20:46,480 --> 00:20:50,960
well and tools

00:20:48,000 --> 00:20:52,000
like you know spinnaker and harness

00:20:50,960 --> 00:20:54,400
there are tools out there

00:20:52,000 --> 00:20:55,919
that are are supporting this process but

00:20:54,400 --> 00:20:58,880
they're few and far between that

00:20:55,919 --> 00:20:59,440
actually do a production rollout within

00:20:58,880 --> 00:21:02,960
the

00:20:59,440 --> 00:21:04,400
the ci cd model there's often a wall and

00:21:02,960 --> 00:21:05,760
what we want to do is break down that

00:21:04,400 --> 00:21:08,799
wall and get ops

00:21:05,760 --> 00:21:11,039
definitely has the potential of doing

00:21:08,799 --> 00:21:11,039
that

00:21:11,679 --> 00:21:15,840
so how would it look after the fact how

00:21:14,240 --> 00:21:18,640
would we have a getups

00:21:15,840 --> 00:21:20,000
in ortilius in the pipeline with gitops

00:21:18,640 --> 00:21:22,400
we'd look very similar

00:21:20,000 --> 00:21:23,760
we would still do a container we'd still

00:21:22,400 --> 00:21:26,080
be triggered based on the

00:21:23,760 --> 00:21:27,760
a new container being registered we'd

00:21:26,080 --> 00:21:29,520
still grab that same information we're

00:21:27,760 --> 00:21:30,799
already hoarding that now we track that

00:21:29,520 --> 00:21:33,280
because it's critical for us for

00:21:30,799 --> 00:21:34,799
versioning that container

00:21:33,280 --> 00:21:36,799
then at some point there would be a

00:21:34,799 --> 00:21:38,320
scheduled or on-demand trigger of the

00:21:36,799 --> 00:21:40,320
deployment process

00:21:38,320 --> 00:21:42,480
at that point ortilius would generate

00:21:40,320 --> 00:21:45,120
the ammo file either a kubernetes yaml

00:21:42,480 --> 00:21:48,159
file or a helm

00:21:45,120 --> 00:21:50,960
helmyamma file and we would do the

00:21:48,159 --> 00:21:52,559
uh we would trigger the the pull request

00:21:50,960 --> 00:21:55,039
and potentially

00:21:52,559 --> 00:21:56,559
the merge and the approvals and then of

00:21:55,039 --> 00:21:58,159
course we would continue listening

00:21:56,559 --> 00:21:58,960
getting that feedback from the get ops

00:21:58,159 --> 00:22:01,440
operator

00:21:58,960 --> 00:22:03,120
of what actually got deployed and

00:22:01,440 --> 00:22:04,880
ensuring that we know what the correct

00:22:03,120 --> 00:22:06,320
inventory is for that particular

00:22:04,880 --> 00:22:08,320
microservice

00:22:06,320 --> 00:22:09,760
and then we can continue giving you the

00:22:08,320 --> 00:22:11,840
great maps that we have

00:22:09,760 --> 00:22:14,799
that shows an application how an

00:22:11,840 --> 00:22:17,200
application version changed and why

00:22:14,799 --> 00:22:18,559
and show you what the blast radius is of

00:22:17,200 --> 00:22:20,159
anything that gets pushed through an

00:22:18,559 --> 00:22:24,400
operator

00:22:20,159 --> 00:22:27,360
okay so i'm going to quickly

00:22:24,400 --> 00:22:28,240
jump out of my powerpoint and i am going

00:22:27,360 --> 00:22:30,640
to show you

00:22:28,240 --> 00:22:32,159
a little bit about what ortillius looks

00:22:30,640 --> 00:22:35,440
like and how we're going to

00:22:32,159 --> 00:22:38,640
do that update okay

00:22:35,440 --> 00:22:41,360
so artillios is broke it says deploy hub

00:22:38,640 --> 00:22:44,480
but i'm only showing you the ortilius

00:22:41,360 --> 00:22:46,880
open source parts of deploy hub

00:22:44,480 --> 00:22:48,320
deploy hub is based on the ortelius open

00:22:46,880 --> 00:22:50,159
source project

00:22:48,320 --> 00:22:51,440
we talked about components and i talked

00:22:50,159 --> 00:22:53,600
about applications

00:22:51,440 --> 00:22:55,200
components for this discussion is the

00:22:53,600 --> 00:22:57,200
most important

00:22:55,200 --> 00:22:58,640
but i'm going to show you how we roll up

00:22:57,200 --> 00:23:01,280
information

00:22:58,640 --> 00:23:01,919
so we'll start by looking at what we

00:23:01,280 --> 00:23:06,799
call

00:23:01,919 --> 00:23:10,159
what i like to call a hipster store when

00:23:06,799 --> 00:23:12,480
when you implement ortilius you uh

00:23:10,159 --> 00:23:14,880
as an application team define your

00:23:12,480 --> 00:23:17,600
package in the same way as you would

00:23:14,880 --> 00:23:20,400
in many different kinds of deployment

00:23:17,600 --> 00:23:22,559
tools you define what you want to deploy

00:23:20,400 --> 00:23:23,679
what we do with that is we track the

00:23:22,559 --> 00:23:25,440
dependencies

00:23:23,679 --> 00:23:27,919
so you can take a look at the this is

00:23:25,440 --> 00:23:28,720
our the application based version of our

00:23:27,919 --> 00:23:31,679
hipster store

00:23:28,720 --> 00:23:32,960
fourth of july sale and you can see that

00:23:31,679 --> 00:23:36,159
it is consuming

00:23:32,960 --> 00:23:37,919
the cart service and the card service

00:23:36,159 --> 00:23:42,480
it's using is gc6

00:23:37,919 --> 00:23:44,159
here's gc6 this is the base version

00:23:42,480 --> 00:23:45,840
when it rolls out it rolls out the base

00:23:44,159 --> 00:23:49,279
version this is what the

00:23:45,840 --> 00:23:52,799
um we would helm would would deploy this

00:23:49,279 --> 00:23:52,799
now let's go and look at the components

00:23:52,960 --> 00:23:57,279
components change and if you're working

00:23:56,320 --> 00:24:00,720
in a

00:23:57,279 --> 00:24:02,960
in a service oriented architecture or

00:24:00,720 --> 00:24:04,640
if you're not and you are using clusters

00:24:02,960 --> 00:24:07,039
and you're still sharing

00:24:04,640 --> 00:24:08,080
components across teams which means you

00:24:07,039 --> 00:24:10,400
have somewhat of a

00:24:08,080 --> 00:24:11,520
cluster sprawl and you have the same

00:24:10,400 --> 00:24:13,760
cluster running

00:24:11,520 --> 00:24:15,279
the same component or microservice

00:24:13,760 --> 00:24:17,200
running in different clusters

00:24:15,279 --> 00:24:18,880
you need to understand the sprawl and

00:24:17,200 --> 00:24:20,159
the and what i like to call the blast

00:24:18,880 --> 00:24:22,960
radius

00:24:20,159 --> 00:24:24,480
so that's primarily the solution that

00:24:22,960 --> 00:24:25,919
ortillius is providing

00:24:24,480 --> 00:24:27,600
is so that you can see if you need to

00:24:25,919 --> 00:24:29,520
update the cart service where you need

00:24:27,600 --> 00:24:31,279
to update it to

00:24:29,520 --> 00:24:33,039
so you see here we have the the base

00:24:31,279 --> 00:24:35,200
version of the cart service we had the

00:24:33,039 --> 00:24:37,120
gc6 version of the cart service that our

00:24:35,200 --> 00:24:38,320
application our base version application

00:24:37,120 --> 00:24:39,840
was consuming

00:24:38,320 --> 00:24:41,360
and now we have a new version of the car

00:24:39,840 --> 00:24:42,960
service

00:24:41,360 --> 00:24:44,480
this is the kind of information that

00:24:42,960 --> 00:24:47,520
we're tracking and

00:24:44,480 --> 00:24:50,480
how we would um generate those uh

00:24:47,520 --> 00:24:51,840
the the gamma files for our get up get

00:24:50,480 --> 00:24:56,320
ops approach

00:24:51,840 --> 00:24:59,919
in this case you can see that um

00:24:56,320 --> 00:25:02,640
this cart service is stored in quay

00:24:59,919 --> 00:25:03,919
for this version we grabbed the the

00:25:02,640 --> 00:25:06,400
digest and the tag

00:25:03,919 --> 00:25:07,600
and in fact we used the tag as part of

00:25:06,400 --> 00:25:10,400
our versioning schema

00:25:07,600 --> 00:25:12,840
you can see that we used the name of it

00:25:10,400 --> 00:25:16,159
this was pushed via circle ci

00:25:12,840 --> 00:25:20,000
workflow and it uses helm

00:25:16,159 --> 00:25:22,240
and it uses the cart service helm chart

00:25:20,000 --> 00:25:23,520
this is the data that we use to oh and

00:25:22,240 --> 00:25:25,279
then over here is

00:25:23,520 --> 00:25:28,000
where we store those key value pairs

00:25:25,279 --> 00:25:30,320
that map to an environment

00:25:28,000 --> 00:25:32,159
this is and we also track where that

00:25:30,320 --> 00:25:34,159
cart service has been deployed in this

00:25:32,159 --> 00:25:36,400
case it's been deployed to

00:25:34,159 --> 00:25:40,080
the hipster store cluster a ci cd

00:25:36,400 --> 00:25:42,880
cluster and an initial repo cluster

00:25:40,080 --> 00:25:43,919
in our get get ops model we would take

00:25:42,880 --> 00:25:45,520
this information

00:25:43,919 --> 00:25:47,919
we would do very much what we're doing

00:25:45,520 --> 00:25:52,200
today except instead of pushing it to

00:25:47,919 --> 00:25:53,600
uh to using helm we would have a get up

00:25:52,200 --> 00:25:56,720
[Music]

00:25:53,600 --> 00:25:59,840
action here and that's what would do the

00:25:56,720 --> 00:26:01,120
the lifting between um creating doing

00:25:59,840 --> 00:26:03,840
the check in and the merge

00:26:01,120 --> 00:26:06,320
to get it up to the correct get ups

00:26:03,840 --> 00:26:08,320
environment repo

00:26:06,320 --> 00:26:09,600
over here is what you see is the blast

00:26:08,320 --> 00:26:12,000
radius

00:26:09,600 --> 00:26:12,960
remember i told you that if you in the

00:26:12,000 --> 00:26:15,600
new world if you

00:26:12,960 --> 00:26:17,200
update a if you update a component you

00:26:15,600 --> 00:26:17,679
need to also update the version of the

00:26:17,200 --> 00:26:19,679
contain

00:26:17,679 --> 00:26:20,880
of the application well in essence

00:26:19,679 --> 00:26:22,480
that's what we're doing

00:26:20,880 --> 00:26:25,760
so in our getups world we would

00:26:22,480 --> 00:26:30,640
initially grab the information

00:26:25,760 --> 00:26:33,600
by grabbing the the this shaw basically

00:26:30,640 --> 00:26:34,320
we would sit on that until it was

00:26:33,600 --> 00:26:37,120
deployed

00:26:34,320 --> 00:26:38,320
but we do create the relationships at

00:26:37,120 --> 00:26:40,400
that point in time

00:26:38,320 --> 00:26:42,799
so in this case we know that three

00:26:40,400 --> 00:26:44,880
applications are going to be impacted

00:26:42,799 --> 00:26:47,120
if this cart service is updated to the

00:26:44,880 --> 00:26:48,880
get offs repository this is your blast

00:26:47,120 --> 00:26:51,840
radius

00:26:48,880 --> 00:26:52,799
now at the higher level what we do is

00:26:51,840 --> 00:26:54,640
remember we

00:26:52,799 --> 00:26:56,880
started looking first at the hipster

00:26:54,640 --> 00:26:58,880
store fourth of july sale

00:26:56,880 --> 00:27:01,200
well now we have a new version because

00:26:58,880 --> 00:27:02,799
the cart service got updated

00:27:01,200 --> 00:27:04,880
and if we take a look at that new

00:27:02,799 --> 00:27:05,679
version and we take a look at it in the

00:27:04,880 --> 00:27:08,240
um

00:27:05,679 --> 00:27:09,840
from a general perspective we can scroll

00:27:08,240 --> 00:27:12,480
down and from the application

00:27:09,840 --> 00:27:15,760
perspective the application team can say

00:27:12,480 --> 00:27:18,159
oh okay we had a problem with our

00:27:15,760 --> 00:27:20,320
our hipster store application because

00:27:18,159 --> 00:27:22,080
the cart service was updated

00:27:20,320 --> 00:27:23,600
now regardless of how it's updated

00:27:22,080 --> 00:27:25,760
whether it's being pushed in a more

00:27:23,600 --> 00:27:27,600
traditional way or in a git ops way

00:27:25,760 --> 00:27:30,240
we can start tracking that kind of

00:27:27,600 --> 00:27:33,120
information and in essence that's what

00:27:30,240 --> 00:27:34,960
ortillius is is doing it is creating the

00:27:33,120 --> 00:27:37,120
bill of material reports

00:27:34,960 --> 00:27:41,039
it's creating difference reports and

00:27:37,120 --> 00:27:41,039
it's creating your blast radius

00:27:43,840 --> 00:27:47,600
so again thank you and i want to thank

00:27:46,799 --> 00:27:50,799
weaveworks

00:27:47,600 --> 00:27:53,919
and red hat for hosting this get ops con

00:27:50,799 --> 00:27:54,960
and inviting me to speak i very much

00:27:53,919 --> 00:27:56,640
appreciate

00:27:54,960 --> 00:27:58,799
the opportunity to talk about the

00:27:56,640 --> 00:28:02,320
ortilius open source project

00:27:58,799 --> 00:28:05,440
and how we're thinking to

00:28:02,320 --> 00:28:06,159
enhance ortilius to support that get ops

00:28:05,440 --> 00:28:09,440
model

00:28:06,159 --> 00:28:10,880
and do and automate the work that humans

00:28:09,440 --> 00:28:12,640
are having to do now

00:28:10,880 --> 00:28:14,840
in particular in a microservice

00:28:12,640 --> 00:28:16,240
environment where you have lots of yaml

00:28:14,840 --> 00:28:17,600
files

00:28:16,240 --> 00:28:19,360
if you want to learn more if you want to

00:28:17,600 --> 00:28:20,720
contribute to the artelias project we'd

00:28:19,360 --> 00:28:23,840
love to have you

00:28:20,720 --> 00:28:24,960
you can go to artillious.io and you can

00:28:23,840 --> 00:28:27,360
also

00:28:24,960 --> 00:28:28,840
check out our github repository at

00:28:27,360 --> 00:28:30,880
github.com

00:28:28,840 --> 00:28:31,760
ortelius and if you're wondering where

00:28:30,880 --> 00:28:35,279
we got the name

00:28:31,760 --> 00:28:37,120
abraham ortilius he it was the first

00:28:35,279 --> 00:28:39,760
person to create a world atlas

00:28:37,120 --> 00:28:40,399
and he did so in a very open source way

00:28:39,760 --> 00:28:42,320
he

00:28:40,399 --> 00:28:44,159
gathered information from other

00:28:42,320 --> 00:28:47,120
photographers and he put together

00:28:44,159 --> 00:28:49,039
a massive map and gave all those other

00:28:47,120 --> 00:28:51,840
map makers credit for it so that's

00:28:49,039 --> 00:28:53,760
pretty much an open source community

00:28:51,840 --> 00:28:56,080
and we are making maps we're making maps

00:28:53,760 --> 00:28:57,279
of cluster of microservices running in

00:28:56,080 --> 00:28:59,360
clusters and tracking their

00:28:57,279 --> 00:29:01,279
relationships and we do that outside the

00:28:59,360 --> 00:29:01,679
cluster keep that in mind we are sitting

00:29:01,279 --> 00:29:03,600
above

00:29:01,679 --> 00:29:06,559
all the clusters and creating a

00:29:03,600 --> 00:29:08,960
centralized hub of data

00:29:06,559 --> 00:29:11,039
of metadata about deployments and the

00:29:08,960 --> 00:29:14,240
get ops information will be one of that

00:29:11,039 --> 00:29:15,840
one of those data points you can follow

00:29:14,240 --> 00:29:18,559
ortilius at linkedin

00:29:15,840 --> 00:29:20,720
ortilius opensource or follow us on

00:29:18,559 --> 00:29:23,760
twitter at ortilius os

00:29:20,720 --> 00:29:26,360
and you can follow me at tracyregan and

00:29:23,760 --> 00:29:28,480
there is my linkedin

00:29:26,360 --> 00:29:30,080
tracydashreagan.oms

00:29:28,480 --> 00:29:31,679
if you ever want to chat about this

00:29:30,080 --> 00:29:35,200
please reach out to me

00:29:31,679 --> 00:29:36,720
and i would be happy to send you a chat

00:29:35,200 --> 00:29:39,039
a calendar invite so we can do a

00:29:36,720 --> 00:29:40,000
15-minute chat i would very much love to

00:29:39,039 --> 00:29:44,960
get your feedback

00:29:40,000 --> 00:29:53,200
on the needs for the automation part of

00:29:44,960 --> 00:29:53,200

YouTube URL: https://www.youtube.com/watch?v=aP9XSHW_yJQ


