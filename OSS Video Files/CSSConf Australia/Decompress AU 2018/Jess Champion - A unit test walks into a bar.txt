Title: Jess Champion - A unit test walks into a bar
Publication date: 2018-04-11
Playlist: Decompress AU 2018
Description: 
	A unit test walks into a bar. Orders a beer. Orders ten beers. Orders 2.5 billion beers. Orders -1 beers. Orders a nothing. Orders a cat. We spend a lot of time thinking and talking about how to write better code, but much less time on how to write better tests. Over the course of my career as a JavaScript developer Iâ€™ve worked across product teams, project team and operations. This talk will leverage my experience in each of these roles to examine how unit tests are a critical component of robust, stable and maintainable software across the full lifecycle. We'll do a deeper dive into some of the theory around unit testing while relating it back to business value and agile practices. I will also give opinionated practical advice for writing a robust test suite.
Captions: 
	00:00:09,660 --> 00:00:16,400
[Applause]

00:00:14,139 --> 00:00:18,619
so I heard it's good to start this sort

00:00:16,400 --> 00:00:20,330
of thing with a joke this joke might

00:00:18,619 --> 00:00:22,160
sound familiar because it was printed in

00:00:20,330 --> 00:00:28,579
the program but for anyone that missed

00:00:22,160 --> 00:00:31,700
it a unit kissed walks into a bar orders

00:00:28,579 --> 00:00:33,860
a beer orders Tim beers orders 2.5

00:00:31,700 --> 00:00:36,050
million beers billion beer sorry

00:00:33,860 --> 00:00:39,470
orders negative one beers orders a

00:00:36,050 --> 00:00:40,730
nothing orders a cat there was some

00:00:39,470 --> 00:00:43,519
thinking's there are not that many jokes

00:00:40,730 --> 00:00:45,289
about unit testing and if you don't get

00:00:43,519 --> 00:00:47,179
it don't worry I'm gonna come back and

00:00:45,289 --> 00:00:51,050
really over explain it for you in a few

00:00:47,179 --> 00:00:53,719
minutes anyway hello it's me I'm Jess

00:00:51,050 --> 00:00:55,339
teller of terrible jokes and developer

00:00:53,719 --> 00:00:58,219
at silver stripe in Wellington New

00:00:55,339 --> 00:00:59,809
Zealand and my Twitter handle is at just

00:00:58,219 --> 00:01:02,239
champion NZ in case you have follow-up

00:00:59,809 --> 00:01:04,010
questions and as was just mentioned

00:01:02,239 --> 00:01:08,300
today I'm gonna be talking about unit

00:01:04,010 --> 00:01:11,000
testing so unit testing is a form of

00:01:08,300 --> 00:01:12,860
automated testing so to start with I

00:01:11,000 --> 00:01:15,560
thought we would go over the benefits of

00:01:12,860 --> 00:01:19,370
automated testing in general why do we

00:01:15,560 --> 00:01:20,810
even do this the first reason is to

00:01:19,370 --> 00:01:22,940
reduce the amount of manual testing

00:01:20,810 --> 00:01:25,340
required manual testing is great

00:01:22,940 --> 00:01:26,930
provides a lot of value but it's

00:01:25,340 --> 00:01:29,150
expensive because you have to pay

00:01:26,930 --> 00:01:32,740
someone to sit there and do it and that

00:01:29,150 --> 00:01:34,850
makes it relatively slow automated test

00:01:32,740 --> 00:01:37,220
coverage reduces the amount of manual

00:01:34,850 --> 00:01:39,830
testing that we need to do and it's

00:01:37,220 --> 00:01:41,750
quick and relatively cheap although this

00:01:39,830 --> 00:01:43,970
up front costs are writing the tests

00:01:41,750 --> 00:01:48,140
they can be run again and again for

00:01:43,970 --> 00:01:49,670
practically nothing it also helps us

00:01:48,140 --> 00:01:52,130
with maintainability and ease of

00:01:49,670 --> 00:01:54,400
enhancement by reducing the cost of

00:01:52,130 --> 00:01:57,560
testing we reduced the cost of change

00:01:54,400 --> 00:02:00,680
making it easier and less risky to make

00:01:57,560 --> 00:02:02,750
changes refactor build enhancements it

00:02:00,680 --> 00:02:04,250
also helps with maintenance works such

00:02:02,750 --> 00:02:06,800
as framework upgrades or security

00:02:04,250 --> 00:02:10,280
patching you can do the upgrade and run

00:02:06,800 --> 00:02:12,560
the tests see what breaks and fix it all

00:02:10,280 --> 00:02:15,019
of the above helps you to increase the

00:02:12,560 --> 00:02:16,400
lifespan of you your solution you can

00:02:15,019 --> 00:02:20,990
keep working with what you've got for

00:02:16,400 --> 00:02:22,920
longer writing tests especially unit

00:02:20,990 --> 00:02:25,620
tests helps increase the quality and

00:02:22,920 --> 00:02:27,060
of your code it helps you find banks

00:02:25,620 --> 00:02:29,849
before they get to production and

00:02:27,060 --> 00:02:31,860
writing easily testable code encourages

00:02:29,849 --> 00:02:35,310
looser coupling and more separation of

00:02:31,860 --> 00:02:37,500
concerns tests are also a form of

00:02:35,310 --> 00:02:39,209
documentation they tell you how the

00:02:37,500 --> 00:02:43,230
system was intended to function in

00:02:39,209 --> 00:02:44,760
various circumstances and having a

00:02:43,230 --> 00:02:47,220
robust test suite helps you to ship

00:02:44,760 --> 00:02:50,430
faster and more often making it a key

00:02:47,220 --> 00:02:52,349
component of continuous integration this

00:02:50,430 --> 00:02:54,390
allows us to deploy with greater

00:02:52,349 --> 00:02:59,640
confidence that there are no unintended

00:02:54,390 --> 00:03:01,410
breakages or side-effects so I said that

00:02:59,640 --> 00:03:03,870
unit testing was one type of automated

00:03:01,410 --> 00:03:05,670
testing you might be wondering what the

00:03:03,870 --> 00:03:09,209
others are and how unit testing fits

00:03:05,670 --> 00:03:11,370
into the bigger picture so with unit

00:03:09,209 --> 00:03:14,880
test we test an isolated unit of code

00:03:11,370 --> 00:03:16,920
like a function or a class and we don't

00:03:14,880 --> 00:03:20,819
rely on external resources such as an

00:03:16,920 --> 00:03:23,580
API or a database we also have

00:03:20,819 --> 00:03:24,750
integration tests this is where we look

00:03:23,580 --> 00:03:27,299
at how different parts of the system

00:03:24,750 --> 00:03:29,880
work together and these tests may use a

00:03:27,299 --> 00:03:34,560
database have real Network requests or

00:03:29,880 --> 00:03:36,660
talk to an API we also have UI tests or

00:03:34,560 --> 00:03:38,070
functional tests or interim tests or use

00:03:36,660 --> 00:03:39,859
case tests whatever you want to call

00:03:38,070 --> 00:03:42,989
them basically the same thing

00:03:39,859 --> 00:03:45,660
essentially you test through through

00:03:42,989 --> 00:03:47,040
automated UI interactions generally

00:03:45,660 --> 00:03:48,570
these sorts of tests have fewer

00:03:47,040 --> 00:03:50,940
scenarios but cover a lot more

00:03:48,570 --> 00:03:53,450
functionality per test and they often

00:03:50,940 --> 00:03:56,489
automate a realistic use case such as

00:03:53,450 --> 00:03:58,470
login and then check your balance again

00:03:56,489 --> 00:04:02,730
these tests may rely on external

00:03:58,470 --> 00:04:07,109
resources generally the cost to create

00:04:02,730 --> 00:04:10,319
maintain and run the test turns up while

00:04:07,109 --> 00:04:14,280
the time taken to run the tests tests

00:04:10,319 --> 00:04:16,979
trends down and if we were to represent

00:04:14,280 --> 00:04:20,639
manual testing in this picture it might

00:04:16,979 --> 00:04:22,770
look something like this this diagram is

00:04:20,639 --> 00:04:24,330
adapted from Matt and Fowler's test

00:04:22,770 --> 00:04:25,830
pyramid so if you're interested in more

00:04:24,330 --> 00:04:27,560
detail and the other types of testing

00:04:25,830 --> 00:04:30,060
and look better

00:04:27,560 --> 00:04:31,890
looking this hopefully you can start to

00:04:30,060 --> 00:04:34,710
see the value of having a solid base of

00:04:31,890 --> 00:04:35,689
unit tests the next next thing to

00:04:34,710 --> 00:04:38,330
consider is when

00:04:35,689 --> 00:04:41,839
we're gonna write these tests you've

00:04:38,330 --> 00:04:43,789
probably heard something about TDD TDD

00:04:41,839 --> 00:04:45,619
or test-driven development was

00:04:43,789 --> 00:04:48,860
popularized by the XP edge our

00:04:45,619 --> 00:04:51,169
methodology in TDD you test first

00:04:48,860 --> 00:04:53,860
meaning you write a failing test and

00:04:51,169 --> 00:04:56,179
then you write the code to make it past

00:04:53,860 --> 00:04:58,879
for many years this has been touted as

00:04:56,179 --> 00:05:01,279
the ideal way to do unit testing but in

00:04:58,879 --> 00:05:04,009
reality being a hundred precent TDD is

00:05:01,279 --> 00:05:05,899
hard to achieve especially if you're

00:05:04,009 --> 00:05:09,169
just starting to introduce unit testing

00:05:05,899 --> 00:05:11,419
into your workflow and it's still a

00:05:09,169 --> 00:05:13,339
technique that I pull out in certain

00:05:11,419 --> 00:05:15,409
situations especially where when I'm

00:05:13,339 --> 00:05:17,389
dealing with more complex logic but day

00:05:15,409 --> 00:05:20,479
to day I don't think it's essential to

00:05:17,389 --> 00:05:24,019
TDD all the time so what's the

00:05:20,479 --> 00:05:27,229
alternative thing I normally do

00:05:24,019 --> 00:05:30,649
something more like this code the MVP

00:05:27,229 --> 00:05:35,019
for a feature speak up or write a list

00:05:30,649 --> 00:05:37,429
of things to test implement those tests

00:05:35,019 --> 00:05:40,729
fix any bugs I found during writing

00:05:37,429 --> 00:05:44,929
those tests add more functionality to

00:05:40,729 --> 00:05:46,789
the feature rinse in repeat or it's even

00:05:44,929 --> 00:05:50,179
fine to coat the entire feature first

00:05:46,789 --> 00:05:51,800
and then add the tests you're still

00:05:50,179 --> 00:05:55,069
going to get most of those benefits of

00:05:51,800 --> 00:05:56,300
unit testing you probably have to do

00:05:55,069 --> 00:05:57,889
some refactoring to make it more

00:05:56,300 --> 00:06:01,579
testable but that's ok

00:05:57,889 --> 00:06:03,559
and if you have a manual tester you can

00:06:01,579 --> 00:06:04,699
they can be testing the feature in

00:06:03,559 --> 00:06:07,069
parallel while you're writing the

00:06:04,699 --> 00:06:08,959
automated tests and then when they come

00:06:07,069 --> 00:06:13,939
back with bugs you don't have to context

00:06:08,959 --> 00:06:15,800
which so much to go and fix them the

00:06:13,939 --> 00:06:18,649
next question people often ask is what

00:06:15,800 --> 00:06:20,809
framework should I use in these slides

00:06:18,649 --> 00:06:22,879
I'm going to be using just in Jasmine

00:06:20,809 --> 00:06:25,669
but doesn't actually matter that much

00:06:22,879 --> 00:06:27,649
what tool in your use I would recommend

00:06:25,669 --> 00:06:29,089
to pick something that is popular and

00:06:27,649 --> 00:06:30,339
recommended for the framework or

00:06:29,089 --> 00:06:32,239
language that you're working with

00:06:30,339 --> 00:06:35,689
something that has decent community

00:06:32,239 --> 00:06:40,759
support and preferably something that

00:06:35,689 --> 00:06:42,769
supports behavior driven development so

00:06:40,759 --> 00:06:44,919
you might be wondering what is this

00:06:42,769 --> 00:06:47,269
behavior during development

00:06:44,919 --> 00:06:48,770
so if TDD is a testing business

00:06:47,269 --> 00:06:51,319
methodology

00:06:48,770 --> 00:06:55,340
then BDD is more like a testing

00:06:51,319 --> 00:06:58,280
philosophy the key principles and that

00:06:55,340 --> 00:06:59,840
you write tests also known as specs for

00:06:58,280 --> 00:07:03,039
each behavior that the code performs

00:06:59,840 --> 00:07:06,080
rather than for each method and code

00:07:03,039 --> 00:07:08,949
each spec describes in natural language

00:07:06,080 --> 00:07:11,690
the behavior of the code being tested

00:07:08,949 --> 00:07:13,430
BDD frameworks like Jasmine make this

00:07:11,690 --> 00:07:16,729
really easy it speaks a part of the

00:07:13,430 --> 00:07:20,569
natural syntax so this is an exact

00:07:16,729 --> 00:07:22,490
example of Jasmine syntax speaks become

00:07:20,569 --> 00:07:25,729
part of an documentation for the code

00:07:22,490 --> 00:07:29,110
base and when you just fail they help

00:07:25,729 --> 00:07:29,110
you identify exactly what's broken

00:07:29,349 --> 00:07:34,759
attached on speaking up earlier

00:07:31,659 --> 00:07:37,330
basically this means analyzing the code

00:07:34,759 --> 00:07:39,979
under test to determine what it does and

00:07:37,330 --> 00:07:44,360
then writing out a list of empty tests

00:07:39,979 --> 00:07:46,490
for each behavior when you're speaking

00:07:44,360 --> 00:07:47,990
up you want to try and cover all the

00:07:46,490 --> 00:07:50,530
possible paths through your code

00:07:47,990 --> 00:07:53,300
this means accounting for error handling

00:07:50,530 --> 00:07:57,469
invalid parameters and expected data in

00:07:53,300 --> 00:07:59,509
each cases testing this sad path helps

00:07:57,469 --> 00:08:00,800
us iron out bugs in oversight in our

00:07:59,509 --> 00:08:05,000
code before they get to production

00:08:00,800 --> 00:08:06,740
making your solution more robust which

00:08:05,000 --> 00:08:08,659
brings us back to my excellent joke from

00:08:06,740 --> 00:08:13,060
earlier that I promised to over explain

00:08:08,659 --> 00:08:16,370
a beer or 10 beers is your heavy path

00:08:13,060 --> 00:08:20,810
2.5 billion beers is in each case and

00:08:16,370 --> 00:08:23,240
the rest a sad path once we have a

00:08:20,810 --> 00:08:25,370
complete list of specs we then figure

00:08:23,240 --> 00:08:29,030
out how to test those behaviors through

00:08:25,370 --> 00:08:30,740
our public interface the public

00:08:29,030 --> 00:08:33,649
interface is the part of your code

00:08:30,740 --> 00:08:36,860
there's publicly accessible so in this

00:08:33,649 --> 00:08:40,010
example it's the cart class and it's add

00:08:36,860 --> 00:08:43,669
item method well get total and add two

00:08:40,010 --> 00:08:45,560
items a private if you're testing

00:08:43,669 --> 00:08:47,779
components the public interface may

00:08:45,560 --> 00:08:50,720
include UI events like click and input

00:08:47,779 --> 00:08:52,550
you can test these by programmatically

00:08:50,720 --> 00:08:54,589
triggering the events and there are a

00:08:52,550 --> 00:08:56,720
lot of libraries out there like enzyme

00:08:54,589 --> 00:09:00,140
for react or view test you tools that

00:08:56,720 --> 00:09:02,360
will help you with us here's a similar

00:09:00,140 --> 00:09:04,550
example in a functional style

00:09:02,360 --> 00:09:07,880
here the public interface is the

00:09:04,550 --> 00:09:10,820
exported add item to cart and get cart

00:09:07,880 --> 00:09:13,250
with items methods well get total in EDI

00:09:10,820 --> 00:09:15,230
'tom are private we're still going to

00:09:13,250 --> 00:09:16,910
test the behavior of these private

00:09:15,230 --> 00:09:20,360
methods but we're just going to access

00:09:16,910 --> 00:09:22,790
it through the public interface which

00:09:20,360 --> 00:09:24,560
might look something like this we pipe

00:09:22,790 --> 00:09:28,870
specific values into the public

00:09:24,560 --> 00:09:31,700
interface that we know will cause our

00:09:28,870 --> 00:09:33,110
private functions to be caught and then

00:09:31,700 --> 00:09:35,450
we assert that the publicly visible

00:09:33,110 --> 00:09:40,279
properties were affected the way we

00:09:35,450 --> 00:09:42,339
intended most testing frameworks have

00:09:40,279 --> 00:09:44,540
tools to analyze your code coverage

00:09:42,339 --> 00:09:46,970
coverage isn't the be-all and end-all

00:09:44,540 --> 00:09:49,670
but it's a pretty good indication of how

00:09:46,970 --> 00:09:51,230
thoroughly tested something is and it

00:09:49,670 --> 00:09:54,320
can help you identify areas that you've

00:09:51,230 --> 00:09:56,720
missed I often play a bit of a game with

00:09:54,320 --> 00:09:58,490
test coverage where I speak up and then

00:09:56,720 --> 00:10:01,279
implement the tests without checking the

00:09:58,490 --> 00:10:03,500
coverage and when I'm done I run it and

00:10:01,279 --> 00:10:07,100
see how high I can get it on the first

00:10:03,500 --> 00:10:08,540
go and I found that this helps me has

00:10:07,100 --> 00:10:12,079
helped me to develop a bit of an

00:10:08,540 --> 00:10:16,699
intuition about what I needs test and it

00:10:12,079 --> 00:10:18,529
also makes a day a bit more fun it's

00:10:16,699 --> 00:10:22,910
also helpful to consider what we don't

00:10:18,529 --> 00:10:25,610
need to test the first one is external

00:10:22,910 --> 00:10:27,440
libraries and frameworks the developers

00:10:25,610 --> 00:10:29,839
of these dependencies should be testing

00:10:27,440 --> 00:10:32,180
that they work correctly we can test the

00:10:29,839 --> 00:10:33,740
way our code interacts with them but we

00:10:32,180 --> 00:10:38,300
should avoid avoid testing their

00:10:33,740 --> 00:10:40,459
internal workings also styling and

00:10:38,300 --> 00:10:41,990
content these are not behaviors of the

00:10:40,459 --> 00:10:44,540
system they are much more likely to

00:10:41,990 --> 00:10:48,800
change and really they should be able to

00:10:44,540 --> 00:10:51,320
be changed freely as we touched on

00:10:48,800 --> 00:10:53,269
earlier and we want to avoid testing

00:10:51,320 --> 00:10:55,699
external dependencies such as databases

00:10:53,269 --> 00:10:57,440
and Network requests as these are more

00:10:55,699 --> 00:11:03,560
appropriate to be covered in integration

00:10:57,440 --> 00:11:06,529
tests not unit tests and then we have

00:11:03,560 --> 00:11:09,620
internal dependencies with unit testing

00:11:06,529 --> 00:11:11,329
we are testing one unit at a time for

00:11:09,620 --> 00:11:14,420
example if you have a Pyrrhic component

00:11:11,329 --> 00:11:15,740
that renders a child component you don't

00:11:14,420 --> 00:11:17,750
need to test the behavior

00:11:15,740 --> 00:11:20,210
of the child component in the parents

00:11:17,750 --> 00:11:23,980
test the children should have their own

00:11:20,210 --> 00:11:23,980
tests and there's no need to double up

00:11:24,250 --> 00:11:30,050
so I've talked a lot about not testing

00:11:27,230 --> 00:11:33,280
dependencies you might be wondering what

00:11:30,050 --> 00:11:33,280
am I actually supposed to do with them

00:11:33,340 --> 00:11:38,410
the answer is we either ignore them

00:11:35,840 --> 00:11:40,700
or we replace them with a test double

00:11:38,410 --> 00:11:42,530
meaning we replace the original

00:11:40,700 --> 00:11:45,350
dependency with a different dependency

00:11:42,530 --> 00:11:47,920
that has the same public interface but

00:11:45,350 --> 00:11:50,810
different code under the behind scenes

00:11:47,920 --> 00:11:52,270
the code and the test interacts with the

00:11:50,810 --> 00:11:56,440
double like it's the real thing

00:11:52,270 --> 00:11:58,520
think stunt double or crash-test-dummy

00:11:56,440 --> 00:12:01,130
there are a number of different flavors

00:11:58,520 --> 00:12:05,390
of test doubles including dummies fakes

00:12:01,130 --> 00:12:07,970
stubs spies and mocks each is useful in

00:12:05,390 --> 00:12:09,530
different situations and because we're

00:12:07,970 --> 00:12:11,870
covering a lot really fast today I'm

00:12:09,530 --> 00:12:17,540
just going to touch on stubs mocks and

00:12:11,870 --> 00:12:20,660
spice so here we've put some code that

00:12:17,540 --> 00:12:22,910
calls Fitch to request data we want to

00:12:20,660 --> 00:12:25,490
test all the logic around that without

00:12:22,910 --> 00:12:27,130
actually calling Fitch to do this we're

00:12:25,490 --> 00:12:29,750
going to replace the Fitch with a double

00:12:27,130 --> 00:12:31,340
one way we can do this is to pass in

00:12:29,750 --> 00:12:34,700
dependencies like we have with Fitch

00:12:31,340 --> 00:12:36,620
here and it will use the real Fitch by

00:12:34,700 --> 00:12:40,160
default but we can also pass it an our

00:12:36,620 --> 00:12:44,510
fake for testing and then we can set up

00:12:40,160 --> 00:12:46,760
a fake like this example we essentially

00:12:44,510 --> 00:12:49,400
pass in the data we want it to return

00:12:46,760 --> 00:12:51,230
and then we return and already resolved

00:12:49,400 --> 00:12:53,060
promise with that data so it looks like

00:12:51,230 --> 00:12:58,610
it's run the request and giving you back

00:12:53,060 --> 00:13:01,630
your data and then we can in our chests

00:12:58,610 --> 00:13:03,830
pass in our stub person effect Fitch and

00:13:01,630 --> 00:13:09,230
check that our expected data was

00:13:03,830 --> 00:13:10,850
returned mocks are a type of testable

00:13:09,230 --> 00:13:13,370
that has the same public interface as a

00:13:10,850 --> 00:13:15,850
dependency and they accept calls and

00:13:13,370 --> 00:13:18,860
Raqqah can return cans data like a stub

00:13:15,850 --> 00:13:21,860
but unlike a stub they keep a record of

00:13:18,860 --> 00:13:23,510
the calls that were made and we can make

00:13:21,860 --> 00:13:25,190
assertions on that record like

00:13:23,510 --> 00:13:28,610
inspecting the damage to a crash-test

00:13:25,190 --> 00:13:29,300
dummy in this example we're using a mock

00:13:28,610 --> 00:13:32,060
function

00:13:29,300 --> 00:13:34,100
for a callback parameter and then we're

00:13:32,060 --> 00:13:39,200
checking that it was called with the

00:13:34,100 --> 00:13:41,330
expected values a spy as a wrapper

00:13:39,200 --> 00:13:43,400
around a real object that allows us to

00:13:41,330 --> 00:13:46,130
record interactions with it and change

00:13:43,400 --> 00:13:48,590
the implementations of particular

00:13:46,130 --> 00:13:51,770
methods making it act a bit like a mock

00:13:48,590 --> 00:13:54,650
in this example were spying on the login

00:13:51,770 --> 00:13:55,850
method of our or service dependency to

00:13:54,650 --> 00:14:02,360
check that it was called with their

00:13:55,850 --> 00:14:04,520
expected values with the introduction of

00:14:02,360 --> 00:14:06,770
mocking techniques it became popular to

00:14:04,520 --> 00:14:09,170
code to test all code in isolation

00:14:06,770 --> 00:14:12,500
meaning all of the dependencies our test

00:14:09,170 --> 00:14:14,960
doubles full isolation is a lot more

00:14:12,500 --> 00:14:18,260
labor-intensive and doesn't necessarily

00:14:14,960 --> 00:14:20,450
mean better quality tests in fact just

00:14:18,260 --> 00:14:22,130
recently removed Auto mocking leaving it

00:14:20,450 --> 00:14:25,760
up to the program and to the side winter

00:14:22,130 --> 00:14:31,640
mark I find most of the time I only use

00:14:25,760 --> 00:14:34,370
test doubles as required to force the

00:14:31,640 --> 00:14:36,560
code down different paths and when I

00:14:34,370 --> 00:14:39,500
want to find out what was happening to a

00:14:36,560 --> 00:14:42,650
dependency or when the dependency could

00:14:39,500 --> 00:14:46,070
interfere was a test like with Fitch if

00:14:42,650 --> 00:14:47,210
we wouldn't want to returning false when

00:14:46,070 --> 00:14:52,100
you're expecting true because it

00:14:47,210 --> 00:14:53,960
couldn't access the network now that

00:14:52,100 --> 00:14:56,540
you've spent all this time and energy on

00:14:53,960 --> 00:14:59,210
your chest harness you'll want to keep

00:14:56,540 --> 00:15:00,980
it in good condition so to close I've

00:14:59,210 --> 00:15:03,620
got some quick tips for chest harness

00:15:00,980 --> 00:15:05,420
maintenance have a rule that you don't

00:15:03,620 --> 00:15:08,180
merge or deploy unless the tests are

00:15:05,420 --> 00:15:11,510
green or passing nobody likes fixing

00:15:08,180 --> 00:15:13,970
tests that someone else broke into Mensa

00:15:11,510 --> 00:15:15,830
of intermittently failing tests or false

00:15:13,970 --> 00:15:18,980
negatives erode trust and the harness

00:15:15,830 --> 00:15:20,480
fix them or just remove them the same

00:15:18,980 --> 00:15:23,890
goes for leaving a bunch of disabled

00:15:20,480 --> 00:15:27,290
tests in your suite fix it or remove it

00:15:23,890 --> 00:15:29,480
also use continuous integration or get

00:15:27,290 --> 00:15:31,370
hooks to run the tests for you rely on

00:15:29,480 --> 00:15:35,000
human diligence as little as possible

00:15:31,370 --> 00:15:36,710
and make sure to add instructions for

00:15:35,000 --> 00:15:40,490
running and debugging the tests to the

00:15:36,710 --> 00:15:41,360
project red bean that brings us to the

00:15:40,490 --> 00:15:42,860
end

00:15:41,360 --> 00:15:44,570
hope you got something out of this and

00:15:42,860 --> 00:15:46,519
if you've got any fellow quick follow-up

00:15:44,570 --> 00:15:47,990
questions feel free to hit me up on

00:15:46,519 --> 00:15:49,700
Twitter or I'll be around for the rest

00:15:47,990 --> 00:15:53,399
of the day thank you

00:15:49,700 --> 00:15:53,399
[Applause]

00:15:58,030 --> 00:16:00,090

YouTube URL: https://www.youtube.com/watch?v=d2c277s12NI


