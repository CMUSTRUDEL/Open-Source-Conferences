Title: Michael Robinson: The Promised Path to Async, Awaits
Publication date: 2017-05-19
Playlist: Decompress AU 2016
Description: 
	Thank you to Mozilla for making video recording possible.
Captions: 
	00:00:05,060 --> 00:00:12,420
I look at the code and I just don't get

00:00:08,960 --> 00:00:16,310
it I know this logically

00:00:12,420 --> 00:00:18,840
and it makes me feel stupid i hate ban i

00:00:16,310 --> 00:00:21,360
hear this sort of thing a lot and it

00:00:18,840 --> 00:00:22,980
makes me feel this way because working

00:00:21,360 --> 00:00:26,939
with javascript doesn't need to be this

00:00:22,980 --> 00:00:29,130
painful I love JavaScript and it's part

00:00:26,939 --> 00:00:32,730
of my job to have other people love it

00:00:29,130 --> 00:00:34,890
as well or at least not hate it I try to

00:00:32,730 --> 00:00:37,410
walk them down a path starting from

00:00:34,890 --> 00:00:39,750
colgate codes as they know and often

00:00:37,410 --> 00:00:42,090
hate through two promises which they

00:00:39,750 --> 00:00:45,269
sometimes know and also often hate and

00:00:42,090 --> 00:00:48,390
end up with async await functions which

00:00:45,269 --> 00:00:49,530
most people often haven't heard of but

00:00:48,390 --> 00:00:51,449
are a new feature that we can use in

00:00:49,530 --> 00:00:54,629
javascript in the browser and endowed

00:00:51,449 --> 00:00:56,370
today this is the promise pass to async

00:00:54,629 --> 00:00:59,729
await and we're going to travel down

00:00:56,370 --> 00:01:02,070
that path right now looking at examples

00:00:59,729 --> 00:01:03,869
like this it's really easy to see where

00:01:02,070 --> 00:01:07,049
some of that discomfort and confusion

00:01:03,869 --> 00:01:08,760
might come from see callback code

00:01:07,049 --> 00:01:11,280
imposes an additional burden on our

00:01:08,760 --> 00:01:13,290
minds by the addition of the time

00:01:11,280 --> 00:01:16,590
dimension so otherwise clears

00:01:13,290 --> 00:01:19,020
synchronous code when I fell into

00:01:16,590 --> 00:01:21,119
JavaScript in a big way coming from PHP

00:01:19,020 --> 00:01:24,000
and Ruby I found this style of code

00:01:21,119 --> 00:01:25,380
really difficult to learn and when I

00:01:24,000 --> 00:01:27,509
look at examples like this even today

00:01:25,380 --> 00:01:29,549
years later I can feel waves of

00:01:27,509 --> 00:01:31,770
frustration and confusion just making me

00:01:29,549 --> 00:01:34,859
wonder girl and twitch and like I used

00:01:31,770 --> 00:01:36,359
to back in those days but if its survey

00:01:34,859 --> 00:01:42,060
now it hands up if you have ever written

00:01:36,359 --> 00:01:46,109
callback code keep your hand up yeah if

00:01:42,060 --> 00:01:48,299
you've used promises okay and if you've

00:01:46,109 --> 00:01:52,530
never used async await put your hand

00:01:48,299 --> 00:01:55,740
down excellent everyone with a hand down

00:01:52,530 --> 00:01:57,899
look around keep your hands up until you

00:01:55,740 --> 00:01:59,189
can see someone with a hand up and keep

00:01:57,899 --> 00:02:03,299
them in mind because after this talk

00:01:59,189 --> 00:02:04,890
they'll be answering a question so that

00:02:03,299 --> 00:02:06,840
callback example that we looked at just

00:02:04,890 --> 00:02:09,479
now it's from production code that went

00:02:06,840 --> 00:02:12,600
in about three years ago it's not like

00:02:09,479 --> 00:02:14,190
my favorite code it's not the worst

00:02:12,600 --> 00:02:15,930
crowd I've ever written it falls into

00:02:14,190 --> 00:02:18,569
that and not banned category which is

00:02:15,930 --> 00:02:20,879
kind of like a prosecutor it gets you

00:02:18,569 --> 00:02:22,409
where you want to go but it takes a lot

00:02:20,879 --> 00:02:23,980
longer and a lot more effort so you

00:02:22,409 --> 00:02:26,470
might want to put in

00:02:23,980 --> 00:02:28,150
and to illustrate quickly why this

00:02:26,470 --> 00:02:29,349
callback code imposes this additional

00:02:28,150 --> 00:02:32,680
burden on our minds we'll just step

00:02:29,349 --> 00:02:34,810
through this function very fat the first

00:02:32,680 --> 00:02:37,090
thing that happens like with all code is

00:02:34,810 --> 00:02:39,819
the function call we say given these

00:02:37,090 --> 00:02:43,510
arguments call me back when you've got a

00:02:39,819 --> 00:02:44,739
valid token and sniffing into it we can

00:02:43,510 --> 00:02:47,890
see the first thing that happens is a

00:02:44,739 --> 00:02:49,840
call to a database so the really awesome

00:02:47,890 --> 00:02:51,760
thing about JavaScript and colbert code

00:02:49,840 --> 00:02:53,650
is that we can do these sort of things

00:02:51,760 --> 00:02:55,659
that require waiting for something like

00:02:53,650 --> 00:02:58,120
calling a database doing a network call

00:02:55,659 --> 00:02:59,650
reading a file without blocking the rest

00:02:58,120 --> 00:03:01,930
of the application or the GUI or

00:02:59,650 --> 00:03:05,530
whatever it is that your users are

00:03:01,930 --> 00:03:07,329
interacting with in your ab the downside

00:03:05,530 --> 00:03:09,310
is that we have to consider that extra

00:03:07,329 --> 00:03:11,650
dimension of time in addition to the

00:03:09,310 --> 00:03:14,650
sequence of events and logic that we

00:03:11,650 --> 00:03:15,670
think about in synchronous code as a

00:03:14,650 --> 00:03:18,430
programmer I don't want to think about

00:03:15,670 --> 00:03:20,470
this my logic is actually blocked until

00:03:18,430 --> 00:03:21,640
I give the token whether or not my

00:03:20,470 --> 00:03:22,840
application it's like there's really

00:03:21,640 --> 00:03:26,079
irrelevant when I'm trying to debug

00:03:22,840 --> 00:03:27,970
something and here we see the database

00:03:26,079 --> 00:03:30,280
is called back we've got a token there

00:03:27,970 --> 00:03:32,019
was no error we proceeded down make

00:03:30,280 --> 00:03:33,730
another database call which is more

00:03:32,019 --> 00:03:35,200
waiting another consideration of that

00:03:33,730 --> 00:03:37,599
time dimension that we would rather not

00:03:35,200 --> 00:03:38,680
think about and again it's great that we

00:03:37,599 --> 00:03:41,829
can do the sort of thing without

00:03:38,680 --> 00:03:44,349
blocking but a logic is still blocked so

00:03:41,829 --> 00:03:46,419
our minds the block great to the f isn't

00:03:44,349 --> 00:03:49,690
we are we have to think about this extra

00:03:46,419 --> 00:03:51,669
thing and here we've gone back to the

00:03:49,690 --> 00:03:53,769
database with another update and we're

00:03:51,669 --> 00:03:55,000
free to return our value which is what

00:03:53,769 --> 00:03:57,250
we would do if we were writing

00:03:55,000 --> 00:03:58,810
synchronous code but at this stage now

00:03:57,250 --> 00:04:00,790
function that ship has sailed we can't

00:03:58,810 --> 00:04:02,440
return anything instead we have the call

00:04:00,790 --> 00:04:05,440
our callback which was an argument to a

00:04:02,440 --> 00:04:06,639
function with the value and if that

00:04:05,440 --> 00:04:08,019
doesn't make any sense to anyone or you

00:04:06,639 --> 00:04:09,790
confuse that's because it is confusing

00:04:08,019 --> 00:04:12,459
even to me today after doing this for

00:04:09,790 --> 00:04:14,650
many years and here look at all those

00:04:12,459 --> 00:04:17,320
arrows five of them there should only be

00:04:14,650 --> 00:04:21,729
two once an initial function call and

00:04:17,320 --> 00:04:23,169
one for the execution of the function so

00:04:21,729 --> 00:04:25,690
because we're using asynchronous code

00:04:23,169 --> 00:04:28,270
with callbacks we've got a lot of that

00:04:25,690 --> 00:04:29,800
pyramid of doom going on so instead of

00:04:28,270 --> 00:04:31,150
just reading the code down we've got it

00:04:29,800 --> 00:04:32,860
also read it to this side then back then

00:04:31,150 --> 00:04:34,000
back to the side then back as we're

00:04:32,860 --> 00:04:36,300
figuring out what's happening in our

00:04:34,000 --> 00:04:36,300
function

00:04:36,580 --> 00:04:40,340
hopefully this fairly trivial example

00:04:38,450 --> 00:04:42,380
has highlighted some of the issues that

00:04:40,340 --> 00:04:43,580
exist with all that code but also showed

00:04:42,380 --> 00:04:47,090
how good it is like we can write a

00:04:43,580 --> 00:04:50,360
non-blocking stuff but it'd be better if

00:04:47,090 --> 00:04:52,490
it wasn't this way continue along the

00:04:50,360 --> 00:04:53,990
path to a think we'll take a quick start

00:04:52,490 --> 00:04:55,730
mend dreamland and look at what

00:04:53,990 --> 00:04:58,910
JavaScript might be like if it was

00:04:55,730 --> 00:05:02,870
synchronous his our gear token function

00:04:58,910 --> 00:05:04,250
written in a synchronous manner we would

00:05:02,870 --> 00:05:06,650
just assign the result of our function

00:05:04,250 --> 00:05:08,720
to a variable and the code would execute

00:05:06,650 --> 00:05:11,060
synchronously blocking that synchronous

00:05:08,720 --> 00:05:12,440
easy to read and if there was a problem

00:05:11,060 --> 00:05:15,140
we could catch it using the old

00:05:12,440 --> 00:05:17,360
try-catch paradigm the third dimension

00:05:15,140 --> 00:05:18,740
doesn't exist in this code we've gone

00:05:17,360 --> 00:05:20,600
back to just the sequence of events and

00:05:18,740 --> 00:05:22,220
the lodging which makes it much easier

00:05:20,600 --> 00:05:24,050
to tell what's going on much easier to

00:05:22,220 --> 00:05:27,350
read other people's code much easy to

00:05:24,050 --> 00:05:29,630
read our code from many months ago as

00:05:27,350 --> 00:05:30,770
here as I've goal state there's what

00:05:29,630 --> 00:05:33,220
we're going towards and that's what we

00:05:30,770 --> 00:05:36,010
will reach once we get to async await

00:05:33,220 --> 00:05:40,040
the first we have to go through promises

00:05:36,010 --> 00:05:41,510
promises has actually highlighted being

00:05:40,040 --> 00:05:43,490
highlighted a lot in many of the talks

00:05:41,510 --> 00:05:45,620
but here today and today and they're

00:05:43,490 --> 00:05:47,150
really fundamental aspect of JavaScript

00:05:45,620 --> 00:05:48,710
that we have to understand in order to

00:05:47,150 --> 00:05:50,450
be able to effectively used a lot of the

00:05:48,710 --> 00:05:52,520
libraries and the language itself going

00:05:50,450 --> 00:05:55,100
on even all of the media stuff that we

00:05:52,520 --> 00:05:57,050
saw yesterday and today seems to all be

00:05:55,100 --> 00:05:59,600
built with a promise API as opposed to a

00:05:57,050 --> 00:06:02,570
callback 1 & fitch which will be those

00:05:59,600 --> 00:06:04,820
two successive successor to Ajax is

00:06:02,570 --> 00:06:08,210
written with a promise API as well

00:06:04,820 --> 00:06:09,170
instead of Ajax's callback API so it's

00:06:08,210 --> 00:06:12,110
something that we really need to have a

00:06:09,170 --> 00:06:13,430
focus on and start learning more so when

00:06:12,110 --> 00:06:14,870
we want to go and start using the more

00:06:13,430 --> 00:06:17,000
advanced features of modern JavaScript

00:06:14,870 --> 00:06:22,220
like async await because they've built

00:06:17,000 --> 00:06:24,500
on promises refactoring our callback

00:06:22,220 --> 00:06:26,690
example to use promises we get something

00:06:24,500 --> 00:06:29,240
a bit like this some of the immediate

00:06:26,690 --> 00:06:30,650
advantages are that we no longer have to

00:06:29,240 --> 00:06:32,720
consider the time dimension as deeply

00:06:30,650 --> 00:06:34,400
it's much easier to see the sequence of

00:06:32,720 --> 00:06:36,950
in just going vertically down the

00:06:34,400 --> 00:06:40,100
function and we can throw things and we

00:06:36,950 --> 00:06:41,660
can catch them just like the callback

00:06:40,100 --> 00:06:43,970
version the first interesting thing that

00:06:41,660 --> 00:06:46,569
happens is the function call in this

00:06:43,970 --> 00:06:48,159
case we say given these arguments

00:06:46,569 --> 00:06:51,429
promise me a valid token when you're

00:06:48,159 --> 00:06:53,860
done a major difference though between

00:06:51,429 --> 00:06:55,629
the callback and the promise example is

00:06:53,860 --> 00:06:58,240
that in the promised example we

00:06:55,629 --> 00:07:00,879
immediately return something we return a

00:06:58,240 --> 00:07:02,229
promise object in this case a list of

00:07:00,879 --> 00:07:06,429
Frommer's objects known as a promise

00:07:02,229 --> 00:07:08,860
change now this promise object can have

00:07:06,429 --> 00:07:11,589
any one of two states it can be settled

00:07:08,860 --> 00:07:13,360
or it can be pending in this case is

00:07:11,589 --> 00:07:19,449
pending which means it hasn't yet done

00:07:13,360 --> 00:07:20,830
its work at the stage in our function we

00:07:19,449 --> 00:07:23,589
can see the first promise was fulfilled

00:07:20,830 --> 00:07:26,949
which means it was settled in a positive

00:07:23,589 --> 00:07:28,209
way otherwise known as resolved often

00:07:26,949 --> 00:07:33,789
this is the place where you're going to

00:07:28,209 --> 00:07:35,469
get your result and although similar to

00:07:33,789 --> 00:07:37,209
the callback example activity has

00:07:35,469 --> 00:07:39,069
occurred in the time dimension that we

00:07:37,209 --> 00:07:42,449
weren't considered we weren't forced to

00:07:39,069 --> 00:07:44,769
consider it as deeply using promises and

00:07:42,449 --> 00:07:47,289
here we can see the second promises to

00:07:44,769 --> 00:07:49,509
sue again successful and we can just

00:07:47,289 --> 00:07:51,969
return our value from the trailing

00:07:49,509 --> 00:07:55,119
promise and our fulfillment or then

00:07:51,969 --> 00:07:57,939
handler we get given that token and we

00:07:55,119 --> 00:07:59,800
can just do with it whatever we would an

00:07:57,939 --> 00:08:01,959
interesting thing to note about promises

00:07:59,800 --> 00:08:03,849
is that if anywhere within a promise

00:08:01,959 --> 00:08:05,709
throws an error we can catch that using

00:08:03,849 --> 00:08:10,269
the rejection or catch handler at the

00:08:05,709 --> 00:08:11,559
bottom of our promise consumer so this

00:08:10,269 --> 00:08:13,959
refactoring and quick walk through of

00:08:11,559 --> 00:08:16,839
promises shows some significant wins

00:08:13,959 --> 00:08:18,550
over callback code we no longer have to

00:08:16,839 --> 00:08:20,889
consider the time dimension is deeply

00:08:18,550 --> 00:08:24,009
it's more like 2.5 d as opposed to full

00:08:20,889 --> 00:08:25,839
3d we can separate area and success

00:08:24,009 --> 00:08:28,300
handling clearly in the code and we can

00:08:25,839 --> 00:08:30,309
throw and catch things again this often

00:08:28,300 --> 00:08:33,370
results in clearer easy-to-follow code

00:08:30,309 --> 00:08:36,310
if done properly we're getting there

00:08:33,370 --> 00:08:37,899
that's gonna be a laptop and so we've

00:08:36,310 --> 00:08:39,759
gone through callbacks we saw that

00:08:37,899 --> 00:08:42,159
although they impose that additional

00:08:39,759 --> 00:08:44,680
Burnett burden by forcing us to consider

00:08:42,159 --> 00:08:48,449
time they let us write code that doesn't

00:08:44,680 --> 00:08:51,430
block which is really cool promises

00:08:48,449 --> 00:08:54,279
patch over some of those complexities

00:08:51,430 --> 00:08:55,689
and imposed by fullback they have their

00:08:54,279 --> 00:08:58,750
own dumb down sides as well there's a

00:08:55,689 --> 00:09:00,250
lot more fluff vertical distance can

00:08:58,750 --> 00:09:02,010
increase when you're running promises

00:09:00,250 --> 00:09:04,450
and some actions can be a bit harder

00:09:02,010 --> 00:09:06,550
let's have a quick look at a thing and

00:09:04,450 --> 00:09:10,990
see how it improves on top of promises

00:09:06,550 --> 00:09:12,400
again another refactoring last one this

00:09:10,990 --> 00:09:15,250
time we've gone from promises to an

00:09:12,400 --> 00:09:18,880
async function if we put it next to the

00:09:15,250 --> 00:09:20,320
imaginary synchronous code if I hadn't

00:09:18,880 --> 00:09:23,980
spent the last ten minutes priming you

00:09:20,320 --> 00:09:26,110
Fred I'd be surprised as a large portion

00:09:23,980 --> 00:09:29,140
of us would even get to tell that it's

00:09:26,110 --> 00:09:31,690
asynchronous if we took out the async

00:09:29,140 --> 00:09:33,310
and the weight word it looks almost

00:09:31,690 --> 00:09:35,290
identical to the synchronous code and I

00:09:33,310 --> 00:09:36,880
think this is really awesome it means

00:09:35,290 --> 00:09:39,220
that we can just read this code as this

00:09:36,880 --> 00:09:41,530
will synchronous leading the engine do

00:09:39,220 --> 00:09:45,430
all of the asynchronous work behind the

00:09:41,530 --> 00:09:47,110
scenes the main difference between the

00:09:45,430 --> 00:09:49,360
two is that with our callback code oh

00:09:47,110 --> 00:09:50,980
sorry without synchronous code we can

00:09:49,360 --> 00:09:53,860
assign the result of our call to a

00:09:50,980 --> 00:09:55,450
variable with async await we're

00:09:53,860 --> 00:09:57,250
guaranteed get guaranteed to get a

00:09:55,450 --> 00:09:58,690
promise bank which means we can leverage

00:09:57,250 --> 00:10:01,270
all the things we learned with promises

00:09:58,690 --> 00:10:02,620
when we're using async functions we can

00:10:01,270 --> 00:10:04,690
use them inside promised change as well

00:10:02,620 --> 00:10:08,860
which is quite flexible and an easy way

00:10:04,690 --> 00:10:10,480
to start using them in existing code an

00:10:08,860 --> 00:10:12,370
async function you call it just like any

00:10:10,480 --> 00:10:14,650
other function regardless of what the

00:10:12,370 --> 00:10:18,220
function itself return the consumer will

00:10:14,650 --> 00:10:19,990
receive a promise back inside an async

00:10:18,220 --> 00:10:23,470
function though we can use a new keyword

00:10:19,990 --> 00:10:25,930
await a weight means that anything for

00:10:23,470 --> 00:10:27,580
the right of it is a promise and the

00:10:25,930 --> 00:10:29,440
functions execution should be paused

00:10:27,580 --> 00:10:33,100
until that promise has settled weather

00:10:29,440 --> 00:10:37,120
settles in a successful resolution or

00:10:33,100 --> 00:10:38,680
it's rejected and we can use it to wait

00:10:37,120 --> 00:10:40,630
for promises anyway we'd put a

00:10:38,680 --> 00:10:43,870
synchronous function call so as a

00:10:40,630 --> 00:10:45,730
variable declaration as a argument to

00:10:43,870 --> 00:10:47,589
another function or in a for loop or

00:10:45,730 --> 00:10:49,570
returning it from another function

00:10:47,589 --> 00:10:51,160
anything anywhere you would normally use

00:10:49,570 --> 00:10:54,520
a synchronous function you can put in a

00:10:51,160 --> 00:10:56,560
weighted promise this means that we

00:10:54,520 --> 00:10:58,750
don't put we programmers don't have to

00:10:56,560 --> 00:11:01,360
think about when things are happening as

00:10:58,750 --> 00:11:04,300
much in our code anymore we can just use

00:11:01,360 --> 00:11:06,820
promises and async functions and let the

00:11:04,300 --> 00:11:08,980
engine handle that sort of thing also

00:11:06,820 --> 00:11:11,350
you can throw again from inside async

00:11:08,980 --> 00:11:12,910
functions but if you forget to add a

00:11:11,350 --> 00:11:13,550
catch handler to your consumer that

00:11:12,910 --> 00:11:14,930
error

00:11:13,550 --> 00:11:16,339
will just disappear which is very

00:11:14,930 --> 00:11:20,600
confusing and it's a gotcha so keep that

00:11:16,339 --> 00:11:22,459
in mind it's got me many times unlike a

00:11:20,600 --> 00:11:24,260
normal function that returns a promise

00:11:22,459 --> 00:11:27,529
you're free to return whatever you like

00:11:24,260 --> 00:11:29,930
so as the head of static variable at a

00:11:27,529 --> 00:11:32,180
list another function call or a promise

00:11:29,930 --> 00:11:33,829
if you don't return a promise the engine

00:11:32,180 --> 00:11:37,790
will wrap it with one if you don't have

00:11:33,829 --> 00:11:39,680
to worry about that consistency this is

00:11:37,790 --> 00:11:41,420
how i feel after i've written code using

00:11:39,680 --> 00:11:43,959
async await and after I've reflected

00:11:41,420 --> 00:11:46,399
call back or promise code to use it and

00:11:43,959 --> 00:11:47,810
it's also highly favored months later or

00:11:46,399 --> 00:11:49,339
when I'm reviewing other people's code

00:11:47,810 --> 00:11:51,320
because I don't have to try to wrap my

00:11:49,339 --> 00:11:53,420
brain around when they think stuff is

00:11:51,320 --> 00:11:55,160
happening in the state correct as long

00:11:53,420 --> 00:11:56,420
as they've used async await correctly I

00:11:55,160 --> 00:11:58,640
can just read the code as if it was

00:11:56,420 --> 00:12:02,750
synchronous and let the engine handle

00:11:58,640 --> 00:12:04,550
all of the asynchronous actions looking

00:12:02,750 --> 00:12:05,990
at the callback and the async code slide

00:12:04,550 --> 00:12:08,060
by slide we can really see that although

00:12:05,990 --> 00:12:09,800
we haven't lost much vertically we've

00:12:08,060 --> 00:12:12,140
definitely gained a lot of simplicity in

00:12:09,800 --> 00:12:15,110
the horizontal or time dimension much

00:12:12,140 --> 00:12:16,430
easier to read and instead of having to

00:12:15,110 --> 00:12:18,709
use the error as the first argument

00:12:16,430 --> 00:12:20,600
convention if the code you're using even

00:12:18,709 --> 00:12:22,250
follows that convention in order to pass

00:12:20,600 --> 00:12:24,529
errors back we can just throw an error

00:12:22,250 --> 00:12:26,720
as long as we remembered to put a catch

00:12:24,529 --> 00:12:28,880
handler on our consumer will get that

00:12:26,720 --> 00:12:30,800
error there it also works and slide

00:12:28,880 --> 00:12:32,740
promised change so you can mix promises

00:12:30,800 --> 00:12:36,230
and async functions together in chain

00:12:32,740 --> 00:12:39,200
very useful and we've arrived all of the

00:12:36,230 --> 00:12:41,839
benefits of asynchronous code and none

00:12:39,200 --> 00:12:44,120
of the none of the negatives this is how

00:12:41,839 --> 00:12:45,649
I hope you feel now after you've seen

00:12:44,120 --> 00:12:48,920
how easy it is to use this in your daily

00:12:45,649 --> 00:12:50,540
work and play and home projects for my

00:12:48,920 --> 00:12:52,670
final couple of minutes I'm just going

00:12:50,540 --> 00:12:54,290
to show you my dr zeus generator which i

00:12:52,670 --> 00:12:56,149
put together as a way to cigarette out

00:12:54,290 --> 00:12:58,420
where i could and where i might not be

00:12:56,149 --> 00:13:00,790
able to put away and slow function i

00:12:58,420 --> 00:13:03,290
found that you can use it as an argument

00:13:00,790 --> 00:13:05,420
assists in this case this console log

00:13:03,290 --> 00:13:08,510
won't be called until the awaited

00:13:05,420 --> 00:13:09,769
promise has settled the value of that

00:13:08,510 --> 00:13:12,019
awaited promise we'll replace the

00:13:09,769 --> 00:13:13,160
console log so we don't have to think

00:13:12,019 --> 00:13:14,660
about this sort of thing normally this

00:13:13,160 --> 00:13:17,720
would be two or three lines and an

00:13:14,660 --> 00:13:20,480
indentation and you can use in a loop

00:13:17,720 --> 00:13:22,880
and we are in mind that this expects a

00:13:20,480 --> 00:13:25,400
array identity know will happen if it

00:13:22,880 --> 00:13:27,740
returns something else from the afire

00:13:25,400 --> 00:13:29,840
you can access the result as long as you

00:13:27,740 --> 00:13:33,020
wrap the await and the function call or

00:13:29,840 --> 00:13:34,610
the promise inside brackets and you can

00:13:33,020 --> 00:13:36,590
wrap it with a try-catch block and this

00:13:34,610 --> 00:13:38,060
works exactly the same way you would

00:13:36,590 --> 00:13:41,690
expect it to work if you were running

00:13:38,060 --> 00:13:43,400
synchronous code remember that if you

00:13:41,690 --> 00:13:45,430
don't wrap anything inside your a sinc

00:13:43,400 --> 00:13:47,570
function with a try-catch block and

00:13:45,430 --> 00:13:49,190
something throws an error that error

00:13:47,570 --> 00:13:51,260
will disappear unless you are handling

00:13:49,190 --> 00:13:53,870
it with a rejection or catch handler on

00:13:51,260 --> 00:13:55,610
the consumer side and you can return

00:13:53,870 --> 00:14:00,790
anything you want from an async function

00:13:55,610 --> 00:14:03,350
and you can use it today if you should I

00:14:00,790 --> 00:14:05,780
think you'd like it you really would at

00:14:03,350 --> 00:14:08,600
node version 7 or was able straight to

00:14:05,780 --> 00:14:10,490
production and spread stable thank you

00:14:08,600 --> 00:14:15,349
very much

00:14:10,490 --> 00:14:15,349

YouTube URL: https://www.youtube.com/watch?v=-EVGL0V-EC0


