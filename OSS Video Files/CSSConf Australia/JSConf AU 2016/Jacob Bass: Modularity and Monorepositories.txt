Title: Jacob Bass: Modularity and Monorepositories
Publication date: 2017-05-19
Playlist: JSConf AU 2016
Description: 
	Thank you to Mozilla for making video recording possible.

The delivery of Babel re-opened the debate in the JavaScript community around the structure or large projects. Out of the babel project came Lerna.js, a tool intended to simplify the development and management of complex projects with many related modules that should be developed simultaneously but delivered separately.

This talk will introduce the concept of a monorepository and explain the benefits and drawbacks of such a system. It will demonstrate how to use a monorepository to build and maintain a component library allowing a team to generate a living style guide but still publish each component as a separate npm module.
Captions: 
	00:00:05,660 --> 00:00:10,349
hi hi Jaclyn and there are a lot of us

00:00:09,719 --> 00:00:13,619
here today

00:00:10,349 --> 00:00:15,930
and a little bit nervous today not to

00:00:13,619 --> 00:00:18,990
speak in front of you but for two other

00:00:15,930 --> 00:00:20,130
reasons one is that it was a release

00:00:18,990 --> 00:00:22,619
this morning of the project that I'm

00:00:20,130 --> 00:00:26,610
working on at 1:00 a.m. and I just

00:00:22,619 --> 00:00:28,710
turned off slack so and the other is

00:00:26,610 --> 00:00:32,160
that my boss is in the audience Jed

00:00:28,710 --> 00:00:34,260
raise your hand Jed doesn't know this

00:00:32,160 --> 00:00:35,910
yet but this is actually going to be a

00:00:34,260 --> 00:00:39,659
pitch to how we should develop our next

00:00:35,910 --> 00:00:42,109
project I'd like a little bit of hope

00:00:39,659 --> 00:00:44,069
from everyone towards the end if I've

00:00:42,109 --> 00:00:45,659
convinced enough of you that this does

00:00:44,069 --> 00:00:47,399
seem like a viable way to develop the

00:00:45,659 --> 00:00:51,389
project after the talk could you just

00:00:47,399 --> 00:00:52,889
watch the chair to let him know so I'm

00:00:51,389 --> 00:00:56,459
going to talk today about modularity in

00:00:52,889 --> 00:00:59,850
one repository and essentially what I'm

00:00:56,459 --> 00:01:02,909
going to cover is not whether you should

00:00:59,850 --> 00:01:04,979
use a model repository or not but the

00:01:02,909 --> 00:01:08,540
ways in which these techniques might be

00:01:04,979 --> 00:01:11,510
able to help you write better software I

00:01:08,540 --> 00:01:13,590
did I did one that I had a loud voice

00:01:11,510 --> 00:01:16,500
write better software or write more

00:01:13,590 --> 00:01:17,910
maintainable software over time and I'm

00:01:16,500 --> 00:01:19,230
going to cover it in three phases the

00:01:17,910 --> 00:01:22,080
first is I'm going to describe what a

00:01:19,230 --> 00:01:24,090
monolith looks like then I'm going to

00:01:22,080 --> 00:01:25,470
describe what a mono purpose paradigm

00:01:24,090 --> 00:01:27,270
looks like and then I'm going to

00:01:25,470 --> 00:01:29,970
describe what a model repository can do

00:01:27,270 --> 00:01:32,670
for you and if this is starting to sound

00:01:29,970 --> 00:01:34,710
like I'm covering off some like

00:01:32,670 --> 00:01:38,010
unbelievable drain we might get to that

00:01:34,710 --> 00:01:39,420
point at the end of it so to begin with

00:01:38,010 --> 00:01:41,610
I want to start from the perspective

00:01:39,420 --> 00:01:43,410
that good architecture is going to cost

00:01:41,610 --> 00:01:46,020
your company and it's going to cost you

00:01:43,410 --> 00:01:49,260
less over time than bad architecture

00:01:46,020 --> 00:01:51,750
will my fiancee who promises me that

00:01:49,260 --> 00:01:53,640
she's tuning in to this talk now is a

00:01:51,750 --> 00:01:55,230
Britain motor architect and I mean she

00:01:53,640 --> 00:01:56,640
doesn't have the benefit towards the end

00:01:55,230 --> 00:01:57,810
of a project of being able to go back

00:01:56,640 --> 00:01:59,580
over the things that they've been

00:01:57,810 --> 00:02:02,040
working on and fix off anything that

00:01:59,580 --> 00:02:04,620
doesn't work like what's on the screen

00:02:02,040 --> 00:02:06,960
as software developers we have that

00:02:04,620 --> 00:02:09,569
power at any point of the project time

00:02:06,960 --> 00:02:10,979
and money constraints providing to go

00:02:09,569 --> 00:02:13,739
back over and change anything with very

00:02:10,979 --> 00:02:14,849
little cost we should be making sure at

00:02:13,739 --> 00:02:16,530
the beginning of the project where the

00:02:14,849 --> 00:02:18,490
decisions we make protect us to make

00:02:16,530 --> 00:02:19,930
good decisions later on

00:02:18,490 --> 00:02:21,820
not necessarily to get everything right

00:02:19,930 --> 00:02:23,410
at the beginning but just to be able to

00:02:21,820 --> 00:02:27,820
make the right decisions as we move

00:02:23,410 --> 00:02:30,370
through the project there's a very

00:02:27,820 --> 00:02:33,190
famous quote by a chap called Melvin

00:02:30,370 --> 00:02:34,810
Conway that covers us the way in which

00:02:33,190 --> 00:02:36,580
you produce solutions compared to the

00:02:34,810 --> 00:02:39,360
way your organization communicates if

00:02:36,580 --> 00:02:42,220
you have one person driving the entire

00:02:39,360 --> 00:02:43,630
company you probably has one person or

00:02:42,220 --> 00:02:45,280
very few people driving a software

00:02:43,630 --> 00:02:46,750
solution as well and it tends to show up

00:02:45,280 --> 00:02:48,520
in the way that you produce software I

00:02:46,750 --> 00:02:50,950
think this is a very interesting idea

00:02:48,520 --> 00:02:52,120
though for the opposite reason which is

00:02:50,950 --> 00:02:53,980
that the way that you produce software

00:02:52,120 --> 00:02:56,530
can actually change the way your company

00:02:53,980 --> 00:02:58,180
communicates if you tend to produce

00:02:56,530 --> 00:03:00,310
monolithic software or if you tend to

00:02:58,180 --> 00:03:02,140
produce very isolated software you'll

00:03:00,310 --> 00:03:03,640
also probably have isolated team and

00:03:02,140 --> 00:03:05,620
that means the information inside your

00:03:03,640 --> 00:03:07,990
company's systems are going to be very

00:03:05,620 --> 00:03:09,970
isolated this will lead to things like

00:03:07,990 --> 00:03:11,500
very small buffs active and dangerous

00:03:09,970 --> 00:03:13,840
when people leave your organization as

00:03:11,500 --> 00:03:15,370
well as needing to rely on very small

00:03:13,840 --> 00:03:19,210
numbers of people to be able to fix any

00:03:15,370 --> 00:03:23,170
problems that come up so what does your

00:03:19,210 --> 00:03:24,310
organization look like I'm gonna cover a

00:03:23,170 --> 00:03:26,200
little bit about what mine looks like

00:03:24,310 --> 00:03:28,690
like I mentioned at the moment I work at

00:03:26,200 --> 00:03:30,850
Sigma and we're a developer consultancy

00:03:28,690 --> 00:03:32,350
and what that tends to mean is that we

00:03:30,850 --> 00:03:34,810
work on a number of different projects

00:03:32,350 --> 00:03:36,700
at a time and they're all relatively

00:03:34,810 --> 00:03:38,620
isolated because different clients means

00:03:36,700 --> 00:03:41,140
different code bases and we have

00:03:38,620 --> 00:03:42,700
individual teams running them and so a

00:03:41,140 --> 00:03:44,380
lot of the information is kind of

00:03:42,700 --> 00:03:48,070
constrained into the system that we're

00:03:44,380 --> 00:03:50,560
looking at at the time we do the obvious

00:03:48,070 --> 00:03:52,060
things that NPM gives you to break out

00:03:50,560 --> 00:03:54,460
that information as I'm sure everyone

00:03:52,060 --> 00:03:55,930
does but it does mean that we using

00:03:54,460 --> 00:03:58,630
software in between projects can be a

00:03:55,930 --> 00:03:59,680
little bit challenging so let's start

00:03:58,630 --> 00:04:01,780
with the project that I'm on at the

00:03:59,680 --> 00:04:04,980
moment the project that I'm on at the

00:04:01,780 --> 00:04:06,880
moment is basically just a monolith and

00:04:04,980 --> 00:04:08,500
this is not a bad thing

00:04:06,880 --> 00:04:10,060
I definitely don't characterize it as a

00:04:08,500 --> 00:04:12,070
problem it's often the fastest way to

00:04:10,060 --> 00:04:15,220
get a solution to market but it does

00:04:12,070 --> 00:04:17,770
come with its own set of challenges the

00:04:15,220 --> 00:04:19,239
first is that keeping an entire monolith

00:04:17,770 --> 00:04:21,580
in your head can be pretty challenging

00:04:19,239 --> 00:04:23,470
this is a relatively small model it only

00:04:21,580 --> 00:04:25,720
has about 30,000 lines of code pure

00:04:23,470 --> 00:04:28,090
JavaScript code but 30,000 lines of

00:04:25,720 --> 00:04:29,050
JavaScript code so this can be very

00:04:28,090 --> 00:04:30,520
challenging when you need to make a

00:04:29,050 --> 00:04:31,300
change especially if your architecture

00:04:30,520 --> 00:04:34,030
patterns have a ball

00:04:31,300 --> 00:04:35,830
quickly over time knowing where files

00:04:34,030 --> 00:04:38,040
are knowing less functionality is can be

00:04:35,830 --> 00:04:40,540
very difficult

00:04:38,040 --> 00:04:43,450
similarly we work on a lot of open

00:04:40,540 --> 00:04:48,190
source projects and this can mean that

00:04:43,450 --> 00:04:50,500
we end up with a smaller subset of small

00:04:48,190 --> 00:04:52,510
projects and functionality and we'll see

00:04:50,500 --> 00:04:56,230
that we break that up into smaller

00:04:52,510 --> 00:04:57,820
pieces so we have the individual

00:04:56,230 --> 00:04:59,590
projects that make up the Keystone

00:04:57,820 --> 00:05:02,200
project a large open source project that

00:04:59,590 --> 00:05:04,600
we maintain and those break up into

00:05:02,200 --> 00:05:07,540
smaller pieces are easily shareable and

00:05:04,600 --> 00:05:09,550
easily reusable but shipping these kind

00:05:07,540 --> 00:05:12,400
of features throughout a system can take

00:05:09,550 --> 00:05:14,440
a lot of effort and a lot of time so

00:05:12,400 --> 00:05:16,090
finally the thing that I'm here to try

00:05:14,440 --> 00:05:18,040
and sell Jed specifically on and

00:05:16,090 --> 00:05:22,270
everyone in general on is a modern

00:05:18,040 --> 00:05:24,940
repository that idea that it will bring

00:05:22,270 --> 00:05:26,170
some kind of value to the business in

00:05:24,940 --> 00:05:29,800
general is what I'm going to try to

00:05:26,170 --> 00:05:32,620
focus on so let's take this mano a mano

00:05:29,800 --> 00:05:34,660
a mano and we're going to cover off

00:05:32,620 --> 00:05:37,240
three different ways that a modern

00:05:34,660 --> 00:05:39,880
repository might be able to help your

00:05:37,240 --> 00:05:43,060
organization deploy release and develop

00:05:39,880 --> 00:05:44,350
software all the time the first one

00:05:43,060 --> 00:05:46,960
we're going to focus on is deploying a

00:05:44,350 --> 00:05:48,550
release so if we look at the way that a

00:05:46,960 --> 00:05:50,920
monolithic software structure which

00:05:48,550 --> 00:05:52,300
deploys a release you just deploy the

00:05:50,920 --> 00:05:54,040
release you have a single deploy

00:05:52,300 --> 00:05:55,630
candidate there's one piece of software

00:05:54,040 --> 00:05:57,820
inside your application that goes live

00:05:55,630 --> 00:05:59,790
so you to play it I'm actually just

00:05:57,820 --> 00:06:02,020
going to interrupt myself quickly here

00:05:59,790 --> 00:06:03,880
terrible-looking slide and if I'd only

00:06:02,020 --> 00:06:05,590
asked Sharkey for help earlier with the

00:06:03,880 --> 00:06:10,210
CSS for this demonstration this would

00:06:05,590 --> 00:06:11,500
have gone a lot better so I apologize so

00:06:10,210 --> 00:06:13,060
a monolithic structure has a single

00:06:11,500 --> 00:06:16,810
deploy candidate and that's what we

00:06:13,060 --> 00:06:19,270
deploy with in contrast without a mono

00:06:16,810 --> 00:06:21,280
purpose repository a monetarist paradigm

00:06:19,270 --> 00:06:23,500
rather is a number of repositories who

00:06:21,280 --> 00:06:25,300
how the single deploy candidate in the

00:06:23,500 --> 00:06:26,890
JavaScript ecosystem the people who do

00:06:25,300 --> 00:06:29,650
this the most are people like James

00:06:26,890 --> 00:06:31,630
Halliday or syndra Soros who tend to

00:06:29,650 --> 00:06:33,130
produce one small package for exactly

00:06:31,630 --> 00:06:34,420
the feature that they're working on no

00:06:33,130 --> 00:06:35,890
matter how related that might be to

00:06:34,420 --> 00:06:39,400
another package they already have and

00:06:35,890 --> 00:06:41,380
this is a example of things like the

00:06:39,400 --> 00:06:42,840
UNIX ecosystem where you have tools that

00:06:41,380 --> 00:06:45,570
are meant to do one thing

00:06:42,840 --> 00:06:49,350
just do that one thing well but what you

00:06:45,570 --> 00:06:51,389
end up with are patterns and projects

00:06:49,350 --> 00:06:53,880
that are all kind of related but all

00:06:51,389 --> 00:06:55,139
very distributed whether you remember

00:06:53,880 --> 00:06:55,979
that you have this project in a

00:06:55,139 --> 00:06:58,380
different place whether your

00:06:55,979 --> 00:07:00,060
documentation and your discovery

00:06:58,380 --> 00:07:01,590
mechanisms are good enough for your team

00:07:00,060 --> 00:07:03,750
to remember that these projects exist

00:07:01,590 --> 00:07:06,990
these are the challenges that come with

00:07:03,750 --> 00:07:10,080
a model purpose organization and so what

00:07:06,990 --> 00:07:13,080
we end up with are innovative tools like

00:07:10,080 --> 00:07:15,450
style guides or individual internal

00:07:13,080 --> 00:07:17,310
component repositories or using github

00:07:15,450 --> 00:07:19,950
descriptions to make discovering these

00:07:17,310 --> 00:07:21,540
new mechanisms more obvious whether we

00:07:19,950 --> 00:07:23,400
succeed in doing that or not is often

00:07:21,540 --> 00:07:25,800
down to whether our organization has

00:07:23,400 --> 00:07:28,889
discovering as a priority inside the

00:07:25,800 --> 00:07:30,900
organization finally we have a model of

00:07:28,889 --> 00:07:32,729
oz' tree and again although a mono

00:07:30,900 --> 00:07:34,740
repository is the encapsulation of a

00:07:32,729 --> 00:07:37,560
number of projects inside one repository

00:07:34,740 --> 00:07:40,289
to deploy something like that really

00:07:37,560 --> 00:07:42,630
should only ever be a line of code what

00:07:40,289 --> 00:07:44,580
we end up having is scripting the

00:07:42,630 --> 00:07:46,620
individual deployed inside the

00:07:44,580 --> 00:07:49,260
repository but then kicking them all off

00:07:46,620 --> 00:07:51,570
in one command the advantages here are

00:07:49,260 --> 00:07:54,510
that while you do have this desired

00:07:51,570 --> 00:07:56,280
separate set of steps that occur you the

00:07:54,510 --> 00:08:00,150
developer only have to do one thing and

00:07:56,280 --> 00:08:02,520
that is much less risky than if you have

00:08:00,150 --> 00:08:05,310
to manually type in 20 or 30 commands I

00:08:02,520 --> 00:08:06,690
know that personally I have forgotten to

00:08:05,310 --> 00:08:08,310
deploy a key piece of infrastructure

00:08:06,690 --> 00:08:10,919
because I was deploying 15 other pieces

00:08:08,310 --> 00:08:13,289
of infrastructure and found that out

00:08:10,919 --> 00:08:15,750
late at night when a deploy didn't work

00:08:13,289 --> 00:08:17,970
the way that it was massive and from

00:08:15,750 --> 00:08:19,800
that point forward I've made sure that I

00:08:17,970 --> 00:08:21,349
try and keep as few moving pieces as

00:08:19,800 --> 00:08:23,490
part of a deploy process as possible

00:08:21,349 --> 00:08:27,090
which is where my interest in this area

00:08:23,490 --> 00:08:28,770
kind of stems from let's take a look at

00:08:27,090 --> 00:08:30,840
the idea of sharing common functionality

00:08:28,770 --> 00:08:33,479
if I ask how many people in the crowd

00:08:30,840 --> 00:08:37,469
have heard of the DRI principle don't

00:08:33,479 --> 00:08:39,570
repeat yourself basically everyone this

00:08:37,469 --> 00:08:41,700
is good with JavaScript developers on

00:08:39,570 --> 00:08:43,860
the most part and JavaScript is not such

00:08:41,700 --> 00:08:46,920
a simple mechanism to extract and share

00:08:43,860 --> 00:08:48,900
code we'd be very we'd be wasting

00:08:46,920 --> 00:08:52,020
potential if we didn't take advantage of

00:08:48,900 --> 00:08:53,110
that but not every project does that out

00:08:52,020 --> 00:08:55,450
of the box

00:08:53,110 --> 00:08:57,910
so if you look at a monolithic structure

00:08:55,450 --> 00:09:00,540
by definition a monolithic structure

00:08:57,910 --> 00:09:02,530
will not share code out of the box

00:09:00,540 --> 00:09:04,030
because that's what a monolith is it's

00:09:02,530 --> 00:09:07,060
all of your code encapsulated in a

00:09:04,030 --> 00:09:09,720
single repository as soon as you start

00:09:07,060 --> 00:09:12,550
to move to more of a modular strategy

00:09:09,720 --> 00:09:14,530
you have the ability to break out as

00:09:12,550 --> 00:09:15,790
small a function as you like and even

00:09:14,530 --> 00:09:18,280
make the entire JavaScript ecosystem

00:09:15,790 --> 00:09:20,970
dependent on that one small function as

00:09:18,280 --> 00:09:23,710
we all found out a couple of months ago

00:09:20,970 --> 00:09:25,900
similarly with a mono repository you

00:09:23,710 --> 00:09:27,970
have the ability to have that same small

00:09:25,900 --> 00:09:29,350
function take the forefront of your

00:09:27,970 --> 00:09:30,970
application take all of the

00:09:29,350 --> 00:09:32,890
functionality just related to that one

00:09:30,970 --> 00:09:35,140
module expressive and deploy it as an

00:09:32,890 --> 00:09:36,940
individual NPM module but still retain

00:09:35,140 --> 00:09:39,220
the ability to edit it inside the larger

00:09:36,940 --> 00:09:40,630
context of your project and what that

00:09:39,220 --> 00:09:43,150
gives you is the ability to see the

00:09:40,630 --> 00:09:45,160
context of your entire application how

00:09:43,150 --> 00:09:49,030
it relates to that single module it's a

00:09:45,160 --> 00:09:50,320
very powerful paradigm the final thing

00:09:49,030 --> 00:09:54,310
that I'm going to discuss in the context

00:09:50,320 --> 00:09:56,290
of these three repository patents is the

00:09:54,310 --> 00:09:58,570
idea of making atomic changes to shared

00:09:56,290 --> 00:10:00,700
dependencies so what we're going to look

00:09:58,570 --> 00:10:02,260
at with this one is when I have to make

00:10:00,700 --> 00:10:04,480
a change to something in my ecosystem

00:10:02,260 --> 00:10:07,090
how do I roll that change out through

00:10:04,480 --> 00:10:09,010
all of my projects in the case of a

00:10:07,090 --> 00:10:10,780
monolith again you have a single deploy

00:10:09,010 --> 00:10:12,400
you have no way to roll out changes to a

00:10:10,780 --> 00:10:14,380
distributed ecosystem because your code

00:10:12,400 --> 00:10:16,810
is just related to your single deploy

00:10:14,380 --> 00:10:18,250
candidate you might have a couple of

00:10:16,810 --> 00:10:19,750
steps to deploy multiple model lists at

00:10:18,250 --> 00:10:22,870
a time but you have no way to

00:10:19,750 --> 00:10:27,520
encapsulate that inside one monolithic

00:10:22,870 --> 00:10:29,350
structure for a mono purpose paradigm

00:10:27,520 --> 00:10:31,270
where you have lots of NPM modules

00:10:29,350 --> 00:10:33,250
individually again there's no real way

00:10:31,270 --> 00:10:34,660
to encapsulate that information inside

00:10:33,250 --> 00:10:36,310
one repository

00:10:34,660 --> 00:10:39,280
unless that one repositories only

00:10:36,310 --> 00:10:40,930
responsibility is deploying all of your

00:10:39,280 --> 00:10:42,310
other repositories and at that point

00:10:40,930 --> 00:10:43,840
you're back to having again how do I

00:10:42,310 --> 00:10:45,430
keep that one up-to-date how do I know

00:10:43,840 --> 00:10:49,210
that that refers to everything that is

00:10:45,430 --> 00:10:51,040
there finally we have a mono repository

00:10:49,210 --> 00:10:52,690
and because you have the majority of

00:10:51,040 --> 00:10:55,330
your code inside this one structure

00:10:52,690 --> 00:10:58,810
making a deploy or making a release is

00:10:55,330 --> 00:11:00,810
as is as much as adding the files

00:10:58,810 --> 00:11:03,160
committing the metonymy atomically

00:11:00,810 --> 00:11:05,610
creating a pull request having a pull

00:11:03,160 --> 00:11:07,560
request reviewed merging it and your

00:11:05,610 --> 00:11:09,660
at that point if you have automatic CI

00:11:07,560 --> 00:11:11,670
integration and CD integration you can

00:11:09,660 --> 00:11:13,379
deploy your code automatically if you

00:11:11,670 --> 00:11:14,939
don't then you have your script Iran

00:11:13,379 --> 00:11:17,189
manually at the tail end of a release

00:11:14,939 --> 00:11:19,319
and you run those but you can see a

00:11:17,189 --> 00:11:20,879
snapshot in time at every step that you

00:11:19,319 --> 00:11:22,620
change something in your application and

00:11:20,879 --> 00:11:24,149
you can follow those snapshots back

00:11:22,620 --> 00:11:25,379
through history and see this is the

00:11:24,149 --> 00:11:26,790
point that we made the header green

00:11:25,379 --> 00:11:30,269
because we thought it would give us 25%

00:11:26,790 --> 00:11:33,990
more revenue these these snapshots of

00:11:30,269 --> 00:11:35,819
history will give you the ability to see

00:11:33,990 --> 00:11:37,529
throughout time the changes not just to

00:11:35,819 --> 00:11:39,240
the individual modules and try and make

00:11:37,529 --> 00:11:41,790
them match up but to your entire

00:11:39,240 --> 00:11:43,769
ecosystem your entire company or

00:11:41,790 --> 00:11:45,449
organizations projects all of their

00:11:43,769 --> 00:11:49,470
history is encapsulated and shared in

00:11:45,449 --> 00:11:51,809
the same place so in comparison we can

00:11:49,470 --> 00:11:53,790
see that a monolithic structure is very

00:11:51,809 --> 00:11:55,769
strong at the toy in its individual

00:11:53,790 --> 00:11:58,800
release candidate but it's a little bit

00:11:55,769 --> 00:12:01,170
less able to share that functionality

00:11:58,800 --> 00:12:03,059
across an ecosystem and I don't have the

00:12:01,170 --> 00:12:06,480
ability to know about the larger context

00:12:03,059 --> 00:12:09,089
that it runs in similarly a model

00:12:06,480 --> 00:12:10,290
purpose or a modular structure does not

00:12:09,089 --> 00:12:12,660
have the ability to know about its

00:12:10,290 --> 00:12:14,699
larger ecosystem and while it shares

00:12:12,660 --> 00:12:16,230
functionality very well deploying those

00:12:14,699 --> 00:12:18,809
individual bits of functionality can be

00:12:16,230 --> 00:12:21,870
a little bit challenging finally if we

00:12:18,809 --> 00:12:23,670
look at a mono mono repository what we

00:12:21,870 --> 00:12:25,740
end up with is the ability to deploy

00:12:23,670 --> 00:12:27,360
these changes atomically to share

00:12:25,740 --> 00:12:29,670
functionality across our entire system

00:12:27,360 --> 00:12:32,100
and to make atomic changes throughout

00:12:29,670 --> 00:12:34,699
that system as we go so this is the

00:12:32,100 --> 00:12:38,100
paradigm that I'm going to describe

00:12:34,699 --> 00:12:39,990
finally we have this this concept of a

00:12:38,100 --> 00:12:41,639
mono repository and what does that mean

00:12:39,990 --> 00:12:43,620
what does that look like so that's what

00:12:41,639 --> 00:12:45,389
I'm going to demonstrate now and

00:12:43,620 --> 00:12:46,829
depending on how I run some time I might

00:12:45,389 --> 00:12:50,059
also live demonstrate it we'll see what

00:12:46,829 --> 00:12:52,050
happens so a brief note before I begin

00:12:50,059 --> 00:12:55,050
getting into what the code actually

00:12:52,050 --> 00:12:57,300
looks like this is not a token learner

00:12:55,050 --> 00:12:59,730
anyone who has heard of learner or use

00:12:57,300 --> 00:13:02,879
learner in the audience this is not that

00:12:59,730 --> 00:13:04,290
fork learner is a tool for managing mono

00:13:02,879 --> 00:13:06,360
repositories but I'm not going to delve

00:13:04,290 --> 00:13:08,100
too deeply into how it does it there are

00:13:06,360 --> 00:13:09,929
a number of options in this space

00:13:08,100 --> 00:13:11,339
learner just being one of them and if

00:13:09,929 --> 00:13:12,959
anyone is interested in that idea after

00:13:11,339 --> 00:13:14,459
this talk I definitely encourage you to

00:13:12,959 --> 00:13:16,100
have a look at these three options and

00:13:14,459 --> 00:13:19,430
to see which one makes sense

00:13:16,100 --> 00:13:21,590
learner formidable lapses buildup is

00:13:19,430 --> 00:13:23,120
another one formidable lab the or

00:13:21,590 --> 00:13:23,450
controls division run by action Ken

00:13:23,120 --> 00:13:26,630
wheeler

00:13:23,450 --> 00:13:29,330
and finally there's a pattern called be

00:13:26,630 --> 00:13:31,940
I think Allah patent and the idea here

00:13:29,330 --> 00:13:33,290
is that the way that nodes module

00:13:31,940 --> 00:13:34,520
resolution algorithm works you can

00:13:33,290 --> 00:13:36,170
actually just store all of your source

00:13:34,520 --> 00:13:38,660
code inside a folder called node module

00:13:36,170 --> 00:13:39,920
and it will resolve up and down the node

00:13:38,660 --> 00:13:42,470
modules tree and find everything that

00:13:39,920 --> 00:13:45,830
you need it's quite a cool trick and if

00:13:42,470 --> 00:13:47,690
you look at CouchDB repository that has

00:13:45,830 --> 00:13:50,930
this implementation running at the

00:13:47,690 --> 00:13:52,190
moment so you're definitely free to do

00:13:50,930 --> 00:13:54,110
it yourself but your mileage might vary

00:13:52,190 --> 00:13:55,940
and the amount of code that you end up

00:13:54,110 --> 00:13:57,260
writing that rebuild existing

00:13:55,940 --> 00:13:59,300
functionality somewhere else is

00:13:57,260 --> 00:14:01,100
definitely a risk and at the same time

00:13:59,300 --> 00:14:03,500
breaking out of something like learner

00:14:01,100 --> 00:14:04,970
to a different pattern is not a big deal

00:14:03,500 --> 00:14:08,300
it's very easy to move from one of these

00:14:04,970 --> 00:14:10,430
to the other so let's look at like let's

00:14:08,300 --> 00:14:12,080
look at what the setup for a mono

00:14:10,430 --> 00:14:14,120
repository looks like we're going to

00:14:12,080 --> 00:14:15,860
cover off starting a brand new project

00:14:14,120 --> 00:14:17,570
we've got our first day working at the

00:14:15,860 --> 00:14:19,280
new startup and we have to create an

00:14:17,570 --> 00:14:21,440
entirely new repository an entirely new

00:14:19,280 --> 00:14:23,360
structure so we start we run learner in

00:14:21,440 --> 00:14:25,130
it and what learner in it does is

00:14:23,360 --> 00:14:27,440
initialized a repository initialize a

00:14:25,130 --> 00:14:31,100
git repository create some files and

00:14:27,440 --> 00:14:33,620
create a packages folder this is the end

00:14:31,100 --> 00:14:35,660
result of creating your first modern

00:14:33,620 --> 00:14:38,180
repository I've created two folders

00:14:35,660 --> 00:14:40,520
inside this repository a demo button and

00:14:38,180 --> 00:14:42,860
a demo header the naming of these

00:14:40,520 --> 00:14:44,960
folders just corresponds to the name of

00:14:42,860 --> 00:14:47,660
the package jason inside the model

00:14:44,960 --> 00:14:49,340
repository and that's what this looks

00:14:47,660 --> 00:14:51,380
like you can see here that I've scoped

00:14:49,340 --> 00:14:54,560
the package Jason to an organization

00:14:51,380 --> 00:14:56,630
name that's freely available and I've

00:14:54,560 --> 00:14:59,240
also declared inside my header that I

00:14:56,630 --> 00:15:00,590
rely on my button component when I start

00:14:59,240 --> 00:15:01,880
working on this immediately I'll be able

00:15:00,590 --> 00:15:03,380
to make changes to either of them you

00:15:01,880 --> 00:15:07,550
see those changes reflected where they

00:15:03,380 --> 00:15:08,720
use so once I've done once I've declared

00:15:07,550 --> 00:15:11,090
my first few projects

00:15:08,720 --> 00:15:12,980
I run learn a bootstrap and it symlinks

00:15:11,090 --> 00:15:14,390
together all of the dependencies what it

00:15:12,980 --> 00:15:16,250
actually does under the code is build a

00:15:14,390 --> 00:15:17,510
great dependency map of all the

00:15:16,250 --> 00:15:19,760
different things that rely on all the

00:15:17,510 --> 00:15:21,710
other different things it will install

00:15:19,760 --> 00:15:24,380
anything that you don't have inside your

00:15:21,710 --> 00:15:25,970
model repository and it will symlink

00:15:24,380 --> 00:15:27,170
everything that you do so what that

00:15:25,970 --> 00:15:28,040
means is that rather than installing

00:15:27,170 --> 00:15:29,570
from NPM

00:15:28,040 --> 00:15:31,310
some candidate or instead of running NPM

00:15:29,570 --> 00:15:33,259
link manually yourself to set up these

00:15:31,310 --> 00:15:36,230
links instead learn it just takes care

00:15:33,259 --> 00:15:37,820
of all of that for you finally that's

00:15:36,230 --> 00:15:39,920
what we have here so we see we have the

00:15:37,820 --> 00:15:42,649
same shoe folders but we see that inside

00:15:39,920 --> 00:15:44,959
the header component we have a direct

00:15:42,649 --> 00:15:46,190
sim link to the button component at this

00:15:44,959 --> 00:15:47,630
point any changes that I make to the

00:15:46,190 --> 00:15:49,519
button component folder will be

00:15:47,630 --> 00:15:52,970
reflected in what the header component

00:15:49,519 --> 00:15:55,519
sees when it requires the button so this

00:15:52,970 --> 00:15:57,079
is all kind of architecture and DevOps

00:15:55,519 --> 00:15:59,329
II let's look at some actual JavaScript

00:15:57,079 --> 00:16:01,100
code well not yet because it's

00:15:59,329 --> 00:16:04,339
JavaScript we now installed babble and

00:16:01,100 --> 00:16:05,899
babble to NT 15 and that will react and

00:16:04,339 --> 00:16:08,180
we run it yes Liz we still more

00:16:05,899 --> 00:16:09,050
currently and still react the same kind

00:16:08,180 --> 00:16:11,930
of stuff that we would do for the

00:16:09,050 --> 00:16:12,980
beginning of every project but because

00:16:11,930 --> 00:16:14,509
we're doing this inside a mono

00:16:12,980 --> 00:16:16,009
repository contact our dev dependencies

00:16:14,509 --> 00:16:18,740
can be shared across our entire

00:16:16,009 --> 00:16:20,600
application so what that means is you

00:16:18,740 --> 00:16:22,130
only install these things once at the

00:16:20,600 --> 00:16:24,170
top level of the mono repository and you

00:16:22,130 --> 00:16:26,029
can reuse them everywhere inside the

00:16:24,170 --> 00:16:28,220
application so this is quite good

00:16:26,029 --> 00:16:29,449
because has anyone gone and gotten a

00:16:28,220 --> 00:16:36,740
coffee while waiting for an NPM install

00:16:29,449 --> 00:16:38,449
the results yeah yes right so with this

00:16:36,740 --> 00:16:39,470
with this practice you run npm install

00:16:38,449 --> 00:16:40,910
once you have all of your dev

00:16:39,470 --> 00:16:42,589
dependencies waiting there for you and

00:16:40,910 --> 00:16:44,000
to start a new project you could put the

00:16:42,589 --> 00:16:45,740
actual source code down you don't have

00:16:44,000 --> 00:16:49,279
to set up anything other than what you

00:16:45,740 --> 00:16:51,260
already have so what we end up with now

00:16:49,279 --> 00:16:52,670
inside each of our components is a babel

00:16:51,260 --> 00:16:54,980
RC in case they have anything

00:16:52,670 --> 00:16:57,319
particularly peculiar about how they

00:16:54,980 --> 00:16:59,630
need to rent a JavaScript code and we

00:16:57,319 --> 00:17:01,010
have the exact same learner structure

00:16:59,630 --> 00:17:04,669
the exact same model repository

00:17:01,010 --> 00:17:07,189
structure so if we look inside a

00:17:04,669 --> 00:17:08,630
component in this circumstance that just

00:17:07,189 --> 00:17:10,909
ordinary react components but this is

00:17:08,630 --> 00:17:13,189
not a react paradigm this works for all

00:17:10,909 --> 00:17:15,500
ordinary JavaScript code but what we

00:17:13,189 --> 00:17:18,380
have at the top there is a es6 modular

00:17:15,500 --> 00:17:21,919
import import button from organization

00:17:18,380 --> 00:17:24,589
scope slash package name we're not

00:17:21,919 --> 00:17:26,360
working relative paths we're not like

00:17:24,589 --> 00:17:27,860
going cool on the file system if I'm in

00:17:26,360 --> 00:17:29,990
development mode find the file here

00:17:27,860 --> 00:17:31,760
otherwise use the actual file from NPM

00:17:29,990 --> 00:17:32,960
we're not doing anything different than

00:17:31,760 --> 00:17:35,540
what we actually do in production

00:17:32,960 --> 00:17:37,640
instead what we have is just a call to a

00:17:35,540 --> 00:17:39,350
button component and because we're

00:17:37,640 --> 00:17:39,870
siblings inside node modules it knows

00:17:39,350 --> 00:17:41,460
exactly

00:17:39,870 --> 00:17:43,140
where and how to find that component and

00:17:41,460 --> 00:17:44,430
as we make changes to the button

00:17:43,140 --> 00:17:48,240
component they'll automatically show up

00:17:44,430 --> 00:17:50,400
here I just I'm not going to go through

00:17:48,240 --> 00:17:51,780
deep into the content on this slide the

00:17:50,400 --> 00:17:53,250
reason why I have that in the

00:17:51,780 --> 00:17:54,990
presentation is just to highlight that

00:17:53,250 --> 00:17:57,750
everything that you can do normally

00:17:54,990 --> 00:17:59,700
inside an NPM component you can do as

00:17:57,750 --> 00:18:02,580
part of a mono repository linting

00:17:59,700 --> 00:18:05,790
testing compilation watching hot

00:18:02,580 --> 00:18:07,890
reloading all of that works very simply

00:18:05,790 --> 00:18:09,630
you just essentially bring it up one

00:18:07,890 --> 00:18:12,630
context to run from the root of your

00:18:09,630 --> 00:18:15,809
project and with learner's specifically

00:18:12,630 --> 00:18:18,530
or with bash generically scoping those

00:18:15,809 --> 00:18:20,850
commands to a particular project is

00:18:18,530 --> 00:18:22,470
achievable so it gives you the

00:18:20,850 --> 00:18:24,540
opportunity depending on how comfortable

00:18:22,470 --> 00:18:26,490
you are with shell scripting so either

00:18:24,540 --> 00:18:28,020
take this into your own hands or to use

00:18:26,490 --> 00:18:31,860
an existing project that's already solve

00:18:28,020 --> 00:18:33,900
these problems so a big part of what I

00:18:31,860 --> 00:18:37,980
care about in developers developers

00:18:33,900 --> 00:18:39,360
developers developers developers and the

00:18:37,980 --> 00:18:41,550
developer experience is something that

00:18:39,360 --> 00:18:43,740
I've spent a lot of time working on and

00:18:41,550 --> 00:18:45,450
working with and trying to figure out

00:18:43,740 --> 00:18:48,960
the right nice patterns to make

00:18:45,450 --> 00:18:50,100
developing software enjoyable and what

00:18:48,960 --> 00:18:53,120
I'm going to show on the screen here is

00:18:50,100 --> 00:18:55,490
a project called storybook by Khedira

00:18:53,120 --> 00:18:57,540
essentially what storybook is is a

00:18:55,490 --> 00:18:59,520
encapsulation of a living style guide

00:18:57,540 --> 00:19:01,620
for your application all of those

00:18:59,520 --> 00:19:03,990
components that are sitting inside my

00:19:01,620 --> 00:19:06,690
packages folder as separate NPM modules

00:19:03,990 --> 00:19:08,760
are required by the storybook

00:19:06,690 --> 00:19:10,320
application and I can use that to render

00:19:08,760 --> 00:19:13,230
them with props in the specific ways

00:19:10,320 --> 00:19:14,640
that they used now ordinarily this works

00:19:13,230 --> 00:19:15,960
really well inside a monolithic

00:19:14,640 --> 00:19:17,790
structure where all of your components

00:19:15,960 --> 00:19:20,040
are just files inside the same tree but

00:19:17,790 --> 00:19:21,450
if you envisage having a modular

00:19:20,040 --> 00:19:23,420
structure where all of your files are in

00:19:21,450 --> 00:19:25,980
separate parts of your own file system

00:19:23,420 --> 00:19:27,720
having a project that integrates all of

00:19:25,980 --> 00:19:29,130
these things together is now another

00:19:27,720 --> 00:19:31,320
module that you have to maintain you

00:19:29,130 --> 00:19:32,820
have another area of source code with

00:19:31,320 --> 00:19:34,320
another project that requires these

00:19:32,820 --> 00:19:35,520
files and another project that has to

00:19:34,320 --> 00:19:38,160
make sure that they're all at the same

00:19:35,520 --> 00:19:39,390
version or the right version instead

00:19:38,160 --> 00:19:41,070
with this system inside a mono

00:19:39,390 --> 00:19:42,660
repository at the root of the

00:19:41,070 --> 00:19:44,570
application it just walks the tree and

00:19:42,660 --> 00:19:47,940
finds all of the places that a story is

00:19:44,570 --> 00:19:49,500
declared and imports it so when you add

00:19:47,940 --> 00:19:51,360
a new project into the mono repository

00:19:49,500 --> 00:19:53,550
you add a new story it's automatically

00:19:51,360 --> 00:19:55,710
picked up by storybook and it shows up

00:19:53,550 --> 00:19:57,840
in the in the browser when you load the

00:19:55,710 --> 00:19:58,980
story application what you can see on

00:19:57,840 --> 00:20:01,440
the screen was probably played a couple

00:19:58,980 --> 00:20:03,620
of times now is hot reloading of the

00:20:01,440 --> 00:20:06,210
changes that you make across the module

00:20:03,620 --> 00:20:07,290
those occur not only across the module

00:20:06,210 --> 00:20:08,730
that you're looking at if I make a

00:20:07,290 --> 00:20:11,280
change to the bottom component but as

00:20:08,730 --> 00:20:12,630
we'll see in a in a slide or two that

00:20:11,280 --> 00:20:14,490
they also occur for anything that

00:20:12,630 --> 00:20:16,650
depends on that button which means you

00:20:14,490 --> 00:20:19,710
see in real time changes not just to the

00:20:16,650 --> 00:20:21,720
ecosystem that you're mutating but to

00:20:19,710 --> 00:20:23,940
anything that uses that module inside

00:20:21,720 --> 00:20:26,310
your entire application rather than

00:20:23,940 --> 00:20:29,040
having the concept of work on a module

00:20:26,310 --> 00:20:29,910
publish it integrated into something see

00:20:29,040 --> 00:20:32,220
if you broke anything

00:20:29,910 --> 00:20:33,540
come back try it again publish it or

00:20:32,220 --> 00:20:36,120
deprecated or whatever you're going to

00:20:33,540 --> 00:20:39,810
do and instead of having to manually go

00:20:36,120 --> 00:20:42,240
around with a an NPM module fix or an

00:20:39,810 --> 00:20:43,410
NPM link strategies try and get things

00:20:42,240 --> 00:20:47,000
to integrate nicely together

00:20:43,410 --> 00:20:48,840
instead what we end up with is a way to

00:20:47,000 --> 00:20:50,820
automatically see these changes

00:20:48,840 --> 00:20:51,990
propagate throughout our system so this

00:20:50,820 --> 00:20:53,490
is quite a nice paradigm it's quite a

00:20:51,990 --> 00:20:56,460
nice way to make these changes to our

00:20:53,490 --> 00:20:58,260
software so let's think about making a

00:20:56,460 --> 00:21:00,630
change them so we come in in the morning

00:20:58,260 --> 00:21:02,820
and the product owner has said we love

00:21:00,630 --> 00:21:05,700
the button we love it a lot big fan to

00:21:02,820 --> 00:21:07,380
the button but it's just a default

00:21:05,700 --> 00:21:09,390
button we'd like to give it some styling

00:21:07,380 --> 00:21:15,000
we'd like it to look individual can we

00:21:09,390 --> 00:21:16,440
change the button okay so we come into

00:21:15,000 --> 00:21:20,250
our components we come into our text

00:21:16,440 --> 00:21:21,750
editor and we add the styles and we see

00:21:20,250 --> 00:21:24,090
the change automatically reflected in

00:21:21,750 --> 00:21:26,070
the button but we also see the change

00:21:24,090 --> 00:21:28,350
automatically reflected wherever the

00:21:26,070 --> 00:21:29,940
button is used so we have here a header

00:21:28,350 --> 00:21:32,040
component that also uses the button

00:21:29,940 --> 00:21:34,200
component these are separate NPM modules

00:21:32,040 --> 00:21:35,370
and when you make the change to the

00:21:34,200 --> 00:21:36,809
source code for the button it

00:21:35,370 --> 00:21:38,250
automatically is picked up and reflected

00:21:36,809 --> 00:21:40,169
in the source code for the NPM module

00:21:38,250 --> 00:21:43,290
and vice versa as you take the change

00:21:40,169 --> 00:21:47,010
away the new NPM module the header NPM

00:21:43,290 --> 00:21:48,660
module is reflective of that change so

00:21:47,010 --> 00:21:51,090
so far just showing front-end

00:21:48,660 --> 00:21:52,530
integration of this is this only for

00:21:51,090 --> 00:21:54,480
front-end JavaScript or it is only

00:21:52,530 --> 00:21:56,690
useful for integrating front-end

00:21:54,480 --> 00:21:59,100
components of course the answer is no

00:21:56,690 --> 00:22:00,240
because it's just ordinary JavaScript

00:21:59,100 --> 00:22:02,610
and it's just taking advantage of the

00:22:00,240 --> 00:22:04,910
ordinary way that JavaScript requires

00:22:02,610 --> 00:22:06,519
work using this with a back-end

00:22:04,910 --> 00:22:08,769
functionality

00:22:06,519 --> 00:22:11,139
the same process so here we have a

00:22:08,769 --> 00:22:12,610
simple Express server well simple it's

00:22:11,139 --> 00:22:14,049
using webpack and web pack middleware

00:22:12,610 --> 00:22:16,990
and a bunch of other plugins to make it

00:22:14,049 --> 00:22:21,100
work so simple but what we end up with

00:22:16,990 --> 00:22:23,350
is the ability to create a front-end

00:22:21,100 --> 00:22:25,809
component that is just specific to this

00:22:23,350 --> 00:22:27,999
server in this case a landing page for

00:22:25,809 --> 00:22:29,919
our startup application but that landing

00:22:27,999 --> 00:22:33,399
page consumes the modules that we have

00:22:29,919 --> 00:22:35,619
elsewhere in the ecosystem so when we

00:22:33,399 --> 00:22:36,970
make a change and we can see here again

00:22:35,619 --> 00:22:38,619
the storybook showing us all the

00:22:36,970 --> 00:22:40,600
different states that we might be in

00:22:38,619 --> 00:22:42,789
with our components when we make a

00:22:40,600 --> 00:22:45,399
change to that component we can see it

00:22:42,789 --> 00:22:47,710
reflected in the actual liar the actual

00:22:45,399 --> 00:22:49,960
server code and it picks it up in real

00:22:47,710 --> 00:22:51,070
time as well so whenever you make a

00:22:49,960 --> 00:22:52,480
change to any of your individual

00:22:51,070 --> 00:22:55,080
components not only can you see them

00:22:52,480 --> 00:22:58,330
live reflected in the actual component

00:22:55,080 --> 00:23:00,190
component render you can see them in the

00:22:58,330 --> 00:23:02,139
integration renders and you can also see

00:23:00,190 --> 00:23:03,220
them in the full page renders of your

00:23:02,139 --> 00:23:04,840
servers that are part of the mana

00:23:03,220 --> 00:23:06,669
repository you have full end-to-end

00:23:04,840 --> 00:23:09,549
integration of all of your components

00:23:06,669 --> 00:23:11,860
throughout your system and that's

00:23:09,549 --> 00:23:13,539
reflected so reflected here is the

00:23:11,860 --> 00:23:14,409
deploy strategy I'm not going to go too

00:23:13,539 --> 00:23:16,330
deeply into this because it's very

00:23:14,409 --> 00:23:17,799
individual to learn but the idea is that

00:23:16,330 --> 00:23:19,690
you can deploy these things at

00:23:17,799 --> 00:23:21,159
independent versions because your npm

00:23:19,690 --> 00:23:23,470
version is held separate from your

00:23:21,159 --> 00:23:25,779
repository state so if you have a minor

00:23:23,470 --> 00:23:27,700
patch for one component and a major bump

00:23:25,779 --> 00:23:29,230
for another component you can do that

00:23:27,700 --> 00:23:31,779
separately inside the same git

00:23:29,230 --> 00:23:33,759
repository and push them out as part of

00:23:31,779 --> 00:23:35,019
the same commit it's still atomic but

00:23:33,759 --> 00:23:37,029
you just have that separation or

00:23:35,019 --> 00:23:38,710
versioning separate from the fact that

00:23:37,029 --> 00:23:43,240
they happen to be used together at that

00:23:38,710 --> 00:23:44,619
step so this probably doesn't look very

00:23:43,240 --> 00:23:49,570
different from how people are working

00:23:44,619 --> 00:23:51,789
now and that's a good thing basically

00:23:49,570 --> 00:23:53,919
the the benefit here is not that this

00:23:51,789 --> 00:23:55,450
will revolutionize or make a radical

00:23:53,919 --> 00:23:57,669
change to the way that you develop

00:23:55,450 --> 00:24:00,279
software now instead the idea here is

00:23:57,669 --> 00:24:02,230
that with these practices you're able to

00:24:00,279 --> 00:24:03,970
introduce small developer experience

00:24:02,230 --> 00:24:06,279
tweaks that will make your life a little

00:24:03,970 --> 00:24:07,929
bit easier whether you take away from

00:24:06,279 --> 00:24:09,490
this that having things integrated

00:24:07,929 --> 00:24:11,440
together end-to-end at the time that

00:24:09,490 --> 00:24:13,210
you're developing is the benefit or

00:24:11,440 --> 00:24:15,490
whether it's being able to deploy

00:24:13,210 --> 00:24:17,499
releases atomically as a benefit all of

00:24:15,490 --> 00:24:18,919
these things are small wins that we can

00:24:17,499 --> 00:24:23,539
make to make our lives

00:24:18,919 --> 00:24:24,980
the easier the other the other part this

00:24:23,539 --> 00:24:26,480
equation this is that it doesn't require

00:24:24,980 --> 00:24:27,919
a massive change it's something that you

00:24:26,480 --> 00:24:29,720
can integrate into your organization

00:24:27,919 --> 00:24:32,149
gradually and you don't have to buy

00:24:29,720 --> 00:24:33,820
entirely in in one go so there are two

00:24:32,149 --> 00:24:36,769
paths that you can approach this from

00:24:33,820 --> 00:24:38,419
there's the path where you come at it

00:24:36,769 --> 00:24:40,999
from an existing model if extractor

00:24:38,419 --> 00:24:42,559
where you can say call all of my code is

00:24:40,999 --> 00:24:44,989
in one repository but it's all in one

00:24:42,559 --> 00:24:47,629
NPM module or one server how do I break

00:24:44,989 --> 00:24:49,429
it out and from that point of view all

00:24:47,629 --> 00:24:50,359
you have to do with that is take the

00:24:49,429 --> 00:24:52,909
code that you have inside your

00:24:50,359 --> 00:24:54,230
monolithic structure extract out just a

00:24:52,909 --> 00:24:55,940
part of it that is going to make sense

00:24:54,230 --> 00:24:57,889
as an NPM module and put both your

00:24:55,940 --> 00:25:00,980
monolithic structure and that NPM module

00:24:57,889 --> 00:25:02,330
inside one mono repository and then keep

00:25:00,980 --> 00:25:02,960
developing your monolithic structure as

00:25:02,330 --> 00:25:04,909
you normally would

00:25:02,960 --> 00:25:06,289
and then the next time you come across a

00:25:04,909 --> 00:25:07,879
small change that would make sense as an

00:25:06,289 --> 00:25:09,590
NPM module extract it out of the

00:25:07,879 --> 00:25:12,049
monolith into the small NPM component

00:25:09,590 --> 00:25:13,850
bring that out into your monolithic as

00:25:12,049 --> 00:25:15,409
your mono repository structure and you

00:25:13,850 --> 00:25:18,649
kind of continue down that same slowly

00:25:15,409 --> 00:25:19,999
making small changes the opposite

00:25:18,649 --> 00:25:22,700
approach works as well if you're coming

00:25:19,999 --> 00:25:24,409
at this from a large distributed system

00:25:22,700 --> 00:25:26,779
like a large distributed set of content

00:25:24,409 --> 00:25:28,999
components all you really have to do is

00:25:26,779 --> 00:25:30,950
pick one as the starting point for your

00:25:28,999 --> 00:25:32,419
mono repository put it as the only

00:25:30,950 --> 00:25:34,340
package in your mono repository and

00:25:32,419 --> 00:25:35,509
start developing against it when you

00:25:34,340 --> 00:25:37,399
next come to making a change to

00:25:35,509 --> 00:25:39,259
something brings that into the mono

00:25:37,399 --> 00:25:40,940
repository as well so you can gradually

00:25:39,259 --> 00:25:43,450
apply these patterns as you go and

00:25:40,940 --> 00:25:45,950
breaking out of these patterns is also

00:25:43,450 --> 00:25:47,450
relatively straightforward what you have

00:25:45,950 --> 00:25:49,369
to do is to break out of the pattern is

00:25:47,450 --> 00:25:50,989
to take the modules that are inside the

00:25:49,369 --> 00:25:52,700
mono repository into their own folder

00:25:50,989 --> 00:25:54,499
initialize them as git repository and

00:25:52,700 --> 00:25:57,850
you can continue deploying them to the

00:25:54,499 --> 00:26:01,820
same NPM target that you were before so

00:25:57,850 --> 00:26:02,899
everything is great now well not

00:26:01,820 --> 00:26:05,690
necessarily there are a couple of

00:26:02,899 --> 00:26:07,159
caveats that I want to cover the first

00:26:05,690 --> 00:26:09,440
is that your git checkout saw was

00:26:07,159 --> 00:26:12,889
definitely slowed down if you visualize

00:26:09,440 --> 00:26:15,200
having one one project worth of get

00:26:12,889 --> 00:26:16,940
having n projects worth of get is going

00:26:15,200 --> 00:26:19,489
to be n times as much kid simple

00:26:16,940 --> 00:26:21,409
mathematics and what that will mean is

00:26:19,489 --> 00:26:23,029
that you'll float your git check out

00:26:21,409 --> 00:26:25,249
your git clones and you'll get pushes

00:26:23,029 --> 00:26:26,450
will slow down especially as all of the

00:26:25,249 --> 00:26:28,269
developers in your company will be

00:26:26,450 --> 00:26:30,919
integrating into the same environment

00:26:28,269 --> 00:26:32,320
this is not all that dissimilar from

00:26:30,919 --> 00:26:33,490
having all of your code instead

00:26:32,320 --> 00:26:35,350
environments and then having to pull

00:26:33,490 --> 00:26:37,450
down each of them and I haven't seen it

00:26:35,350 --> 00:26:39,820
as a major cost over time but if you

00:26:37,450 --> 00:26:41,590
approach Google or Facebook scale and

00:26:39,820 --> 00:26:42,940
success and wouldn't we all like to

00:26:41,590 --> 00:26:45,009
approach people in facebook scale to

00:26:42,940 --> 00:26:47,860
success then that might be a concern

00:26:45,009 --> 00:26:49,809
that you have the field you need to get

00:26:47,860 --> 00:26:50,830
a little bit creative with tagging what

00:26:49,809 --> 00:26:53,380
that means is that you're releasing

00:26:50,830 --> 00:26:55,090
process using get tags can't just be the

00:26:53,380 --> 00:26:57,909
exact version number you're going to

00:26:55,090 --> 00:26:59,110
have to either version it at the module

00:26:57,909 --> 00:27:00,700
versions and have a couple of tags

00:26:59,110 --> 00:27:02,380
pointing to that there are other ways

00:27:00,700 --> 00:27:03,639
that you can get around this and there

00:27:02,380 --> 00:27:04,779
are other processes you can use but

00:27:03,639 --> 00:27:06,669
you're probably not gonna be able to use

00:27:04,779 --> 00:27:09,460
the exact same get tagging process you

00:27:06,669 --> 00:27:11,379
had before and finally build tooling I

00:27:09,460 --> 00:27:12,940
covered a couple of ways to approach

00:27:11,379 --> 00:27:13,769
build filling but you are going to have

00:27:12,940 --> 00:27:16,539
to think about it

00:27:13,769 --> 00:27:18,279
JavaScript over the last two years has

00:27:16,539 --> 00:27:20,230
made us all have to think about Bill

00:27:18,279 --> 00:27:22,120
tooling in some capacity even if it's

00:27:20,230 --> 00:27:24,129
just applying Babel or browserify or

00:27:22,120 --> 00:27:26,019
webpack or something like that this

00:27:24,129 --> 00:27:27,700
process will also need you to come up

00:27:26,019 --> 00:27:30,220
with a way to run your build tooling in

00:27:27,700 --> 00:27:32,049
a certain way but the advantage here is

00:27:30,220 --> 00:27:33,639
that once you've solved that one you can

00:27:32,049 --> 00:27:35,110
just use it again not copying and

00:27:33,639 --> 00:27:37,210
pasting it not turning it into an NPM

00:27:35,110 --> 00:27:38,980
module just use it as you wrote it in

00:27:37,210 --> 00:27:41,320
the same place without needing to

00:27:38,980 --> 00:27:42,490
replicate it into other folders it also

00:27:41,320 --> 00:27:44,860
means that when it comes time to update

00:27:42,490 --> 00:27:46,149
that billing you just can because

00:27:44,860 --> 00:27:47,409
everything that's using it is in one

00:27:46,149 --> 00:27:51,370
place you don't have to make that change

00:27:47,409 --> 00:27:53,440
throughout your ecosystem so I'm going

00:27:51,370 --> 00:27:55,440
to touch off on one way to approach a

00:27:53,440 --> 00:27:59,169
middle ground for this and that's the

00:27:55,440 --> 00:28:02,230
Zelda project by sheriff's this project

00:27:59,169 --> 00:28:04,149
is a way to take all of your npm modules

00:28:02,230 --> 00:28:05,950
that are separate clone them together

00:28:04,149 --> 00:28:08,139
and link them together in the same way

00:28:05,950 --> 00:28:10,149
that learner or other model repository

00:28:08,139 --> 00:28:11,409
builders do but it won't sell them

00:28:10,149 --> 00:28:13,149
inside the same git repository you

00:28:11,409 --> 00:28:14,769
attend your individual git repositories

00:28:13,149 --> 00:28:16,720
but you can make all the changes in the

00:28:14,769 --> 00:28:18,100
same way that I was showing before you

00:28:16,720 --> 00:28:19,299
don't have the benefit of storing this

00:28:18,100 --> 00:28:21,940
in source control and you don't have the

00:28:19,299 --> 00:28:23,889
benefit of sharing it across your team

00:28:21,940 --> 00:28:25,450
but it is a way for you to get used to

00:28:23,889 --> 00:28:27,549
the how the development process works

00:28:25,450 --> 00:28:29,860
with these tools and see if you are

00:28:27,549 --> 00:28:32,049
willing to make the buy-in towards

00:28:29,860 --> 00:28:35,559
changing your process over to this kind

00:28:32,049 --> 00:28:37,570
of way of doing things so to recap mono

00:28:35,559 --> 00:28:39,309
repositories are a way to kind of take

00:28:37,570 --> 00:28:41,379
the best of both worlds between modular

00:28:39,309 --> 00:28:43,600
systems and monolithic systems they do

00:28:41,379 --> 00:28:46,190
come with their caveats but I believe

00:28:43,600 --> 00:28:49,250
that they will lead to better develop

00:28:46,190 --> 00:28:51,049
experiences and to a stronger culture of

00:28:49,250 --> 00:28:54,860
reuse of the time in a project rather

00:28:51,049 --> 00:28:55,860
than rewriting it and that's that thank

00:28:54,860 --> 00:28:59,880
you very much

00:28:55,860 --> 00:28:59,880

YouTube URL: https://www.youtube.com/watch?v=7Lr8xYPKG5w


