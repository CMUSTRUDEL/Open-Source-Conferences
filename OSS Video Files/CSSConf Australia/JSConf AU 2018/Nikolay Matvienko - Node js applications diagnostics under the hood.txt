Title: Nikolay Matvienko - Node js applications diagnostics under the hood
Publication date: 2018-04-11
Playlist: JSConf AU 2018
Description: 
	Based on my experience in diagnosing and troubleshooting highload e-commerce Node.js app in production, I’ve identified three stages in the Node.js diagnostic history. I’d like to briefly tell this path and show where we are now and tell in details "How to debug and tracing Node.js apps on different levels, and how to track performance problems and memory leaks inside Node.js apps in 2018":

Production troubleshooting: I show and explain the strategy of creation and debugging core dump using llnode, node-report and X-Transaction-ID in our company with real-life examples.
Memory leaks: I show how to identify memory leaks, memory holders using V8 GC tracing, llnode debugging + gencore tool with real-life examples.
Performance: I show how to use 0x flame graph to find performance bottlenecks, how identify Event Loop lags, GC slow work and what can give Async Hooks for that with real-life examples.
Captions: 
	hi everybody my name is Nikolai I amfrom Russia st. Petersburg and I willtell aboutapplication Diagnostics under the hoodfirst of all sorry from English insteadof improving heat I spent a lot of timeunder the hood with debuggers I work atgrid dynamics and full stack developerand in the retail domain we do digitaltransformation for logic a u.s.ecommerce companies using non GS and inorder to create our session successfulwe devote a lot of time to diagnosticsand today not just no.group that deals with performanceprofiling tracing memory analysis andpost-mortem debuggers and to understandwhere we are now in Diagnostics Isuggest you look at as a timeline as ahistory way I put the appearance ofsignificant tools and highlightedseveral stage the first stage of coursestarts from presented at GS con cool but the part ofpeople instruments appeared beforesynergist so as a sister profiler systemprofiler dtrace pair of instruments andthey still in useafter the nigiri appearance began toappear tools from the first stage keepdown memory Road not inspector andbasically those tools will developeffective in development and not inproduction and also do you rememberthere was a fork IGS which world moreappeal is that not just itself socommunity was divided but since IGS and not just you need uniting thefourth version community has a clearretro of development and by this pointnot already used in production by largecompanies such as eBay Alibaba Amazonand by our customers as well and here isa need for debugging and profiling toolsin production will create flame graphsfor profiling and C++ debuggers wereadapted forNagi as debugging so only in the secondstage we've got the ability to debug andprofile in production but we were therein the first stage already and it wasfunny and painful so from the have highlightedthe first stage on the timeline which ismostly focused on improving Nadia'sperformance tracing in internalcomponents and improving the quality ofinstruments here is a significanttradition to turbofan appearance of asink hooks so looks like the death todaywe have a lot of useful heat tools butmost of them still are external andrequire a better functionality with theless performance overhead and summarizethe pass in Diagnostics not GS wasmostly focused on performance and therewere reasons for that we often didn'thave enough functionality and each timewe transition to new version of Nijs wefaced it with the fact that we losesupport of many useful tools so we hadto choose either we go with a newversion which is faster but we losesupport of useful tools all we stay withold slow but with the tools and otherapplications not just applications webUI began for front-end and microservicesallocated in the center of largeenterprise architecture where integratewe use a multiple systems such as CDMdifferent databases services and problemcan come here from anywhere and in thedays of high load such as Black Fridaywhen company make a huge profit eachcode each meet each mistake coststhousand dollars per minute and if thereis an error in Nadia's application isnecessary to choose a strategy and toolsas soon as possible and prepare the hardfix and today I will show you how to dothat in certain examples in case oferrors performance loss and memory leaksin production so let's go to thedebugging there are several reasons fordebugging in production uncut exceptionkill your process physical reproducibleerrors and you don't have enoughinformation from your logs and andactually you cannot lock everythingproduction environment features and theerror does not reproduce locally and youdon't have a time let'smoving to the simple example we have acontroller which call service at work weuse the REST API and the error if thrownin the controller and applicationcrushed and here is a simpleimplementation of product reservation wehave a product controller with thereserved method where user profile andreverse account data I extracted fromthe cookies and since some user doesn'thave reverse account application Thronesand error your application crush andsauce it's bad but if it sells a flagabout an architect section in case ofuncut exception Nijs who create quorumwhich he is a whole which is dump ofwhole memory of the process thatcontains heap dump and stack tracebefore the crash after that yourapplication restarts you get access toproduction to the dump and read it withthe debugger the most relevant today isLLL not plug in for l-ltp debugger soand to find the error we need to do justthree simple steps so we need to get thestack trace and finds the lastJavaScript operation on function andread the source code of this functionand get the input parameters request andthe response so let's repeat it with thecore dumps we have a core dump and toread it we need to run ll node andspecify the path to the dump after thatin debugger session we get access toreach the trace with the common two which is a back trace and that here weneed to find the last J's function whichis store it in we see this is a reserved method of ourproduct controller and we have addressesto this objectincoming message which is a which is arequest response and even to thefunction source code in the memory so weneed to read the source code of ourfunctions or less just gets address andusing command vwith a dress on function we get thesource code of this function out of thememory after the reading source codeletterJim back to the start race and get theaddress of our request and extract fromthe memory and here it is so this is ourrequest we did it with the common toeight inspect and use it address ofrequest and after that we can repeatthis common together cookies to figureout which profile doesn't have rewardsand wipe our application across sothat's pretty simple but it was a goodstack trace informative decrees andbecause we had all necessary informationwe had order of last functions withaddresses to the request response or allobject but sometimes a framework errorhandler or incorrect customer errorhandling makes a trace uninformativeconsider this at the next example sohere instead of pass exactly and rewardsID we accidentally positive wholerewards object and now the error iswrong in the surveys in a synchronousmode and we don't have a cache blockhere to catch the error and to catch itwe use a subscription to an hello torejection event where we will do processabort to crash we use to get the dumpand when we try to gather stack trace ofthis dumpwe will not find any find anniversaryinformation so we don't have requestsrespawns and needed functions so wedon't have a stack trace and in thiscase we need to you work just with theheap dump with the memory and I'll showyou how to do this first of all we needto get the requests from the memory andwe can find objects by the type usingcommon fine J's instances and specify incomic message so those are requests inthe dump in the memory but while thereare so many and which request crushesthe process with all other requests thatwill there inside the event loop and howto find itand in this case we use a unique requestID which we store in the header evenextraction ID to find the right one andwe can get this value from our logs andfind which object has has a reference tothe string to this value with thecomment find revs - - drink and we havea headers object so let's find theparent object of this header and usingcommand vheaders we found the incoming message asa request that we need hi Dave so thatwas easy let's go deeper and imaginethat this data is not enough on us forus and we need to knowlocal variables from other otherfunctions for example from the reserveservice where was request REST API andrequest database and results we'llassign it to the same local variabledata and we don't have any objectsreferencing to this data how to find itbut we can find this object by values ofits properties for example by reverse IDuser ID or by even by the name of someproperty for example reverse and storeso the main idea is here that we canfind the objects not only from the lastfunction before the crash we can getthem out of memory from all otherfunctions with high probability thatwere executed before the crash fromsample from middleware from policiesfrom controller or other storage serviceand storage and it helps a lot and toget more information we can use an oddreport and in fact the search for anerror it's like a data to investigationwhere after generated before the crashreport will say you what happened withyour process by JavaScript and C++ stacktrace where it was and under whatconditions by worker of garbagecollector memory and CPU and logs willgive you valuable hintsbut core dump is not a silver bullet andto create core Dom on each error is nota good ideaotherwise the picture will be like thiswe have a lot of errors in productionand you know the spell not a bottle andcut exception so let the debugging beginfor each error is created core dumpone core dump took her down freak ordamn a lot a lot a lot of core dumps andbam and your boss is waiting for you andhe asked she asked hey buddy will losemoney how much time you need to solvethis issue and you think him where is mydump so I call the situation core dumpflood where is the problem we need tohave we need to follow to error handlebest practices to have a central asseterror handler with error selection logicfor example I have a hearty producibleerror but I don't want to generatehundreds of identical core dumps andlook for them among other all I don'twant to create core dump and kill theprocess every time on error when I canhandle itand in this case I use the gen core anderror registry which is a custom errorselection logic which makes decisionshould it create core dump a was forthis error dump craters already or isthis a heart irreducible error and if itshould we use a gem core that makes forkof you of your main process andterminate it with the dump and our mainprocess continue serving traffic withoutaccident so that's pretty cool enoughand let's reduce the whole algorithmwhat last time so if the error is notcut not just application generates coredump not report generates report andapplication restarts the continueserving traffic but if the error was cuterror handler pulled the availableinformation to a logand error selection logic make decisionshould it crush the process should havegenerate a core dump and if not itcontinue serving traffic and handles theerror and if it should it use GM core tomake a process fork to terminate it withthe dump and our main process continueserving traffic so after that we justconnect to production get local look andour core down to the bucket we ll not isit so my suggestions follow to errorhandler best practices call abort onlyin one place in central hazard errorhandler usage angkor do not kill yourmain process and use a non report tohave more information in case ofunexpected crush track your ID usingrequest IDs for example X request IDfrom engineering or Zipkin headers andavoid core dump flood that was aboutdebugging in production so let's go tothe performance profiling and search formemory leaks and let's investigate theperformance loss and memory leaks at anexample of well real situation whenafter the one of the religious we had ahuge performance decline just before theBlack Friday Eve and to do to figure outwas where as a problem we can start withperformance profiling using internalprofiler of Nijs and tick processor tofind the longest separation but there isa there is a good graphicalrepresentation of profile at trace itsattacks its call it flame growth and themain idea of the feed to find thewireless block because the wider blockis them often it was during is asampling CPU so the long gate whatperformative and on high-level overviewwe can find that application spends percent on the retrieval data from I longest block is a server-side pagerendering it's about it's a lot because it can't East consistfrom custom helpers partials and teaplates templates with logic and if wescroll up we will see which operationsare on CPU here is handlebars and is low- Mary utils and let's go deeper to low- merge stacks and if we zoom in we willsee so there are two white blocks offlow - base merge operation base mergedeep clone the for each cycle and fordata processing of product matter so wefound that our helpers logic in teamplayed a lot of cycles low - utilsour performance is the cause of lowestperformanceit's our bottlenecks and to improve thatwe can we did performance profiler witha pair of we reduce the punitive operations sinceit blocks our they block our mainprocess long cycles decent Parslow -object merge and remove it logic frombuting place and helpers especiallycustom halters and gradually implementedserver-side rendering and after thoseall improvements all the server-siderendering expands only about time and we reduce it wild blood andincrease it our synchrony of applicationexecution so my suggestions performanceshould be part of requirements everytime if you would like to add somelibrary third party library or yourlibrary you need to measure performancebefore and after every time collect themeasurement result or heapand profile on different environments onstage environments and maneet ordiagnostic tools performance impact butmisfortune never comes alone and withperformance loss we have a problem withhis memory consumption and there aremany ways how to define memory leaks wecan do it with application monitoringtools like an solid New Relic DTraceperf compare heap dump but I suggest youto focus on excessive garbage collectionsince it makes negative impact onperformancelook at this nearly graph the GC rategrows in a new space young generationand to get more information aboutgarbage collection work we can trace itusing tracers GC flag of Nadia's andhere we see that not said memoryconsumption grows after each collectionand interval between collection is tooshort that means that it's difficult tofind to find them in the memory so andgarbage collection performs veryfrequently and by the duration ofgarbage collection we see there are default millisecond so it that meansthat garbage collection spend more timetogether objects in the memory becauseof complex topology complex graph ofobjects in the memory and it spend moretime to kalam the memory and how totrack which operations require memoryallocation and as we know Naja'sprofiling result receipts tax it's a mixof JavaScript function and native vfunctions so why not just keep track wayback from garbage collection functionscalls to JavaScript so let's look at asimple implementation of flame graphand on the left side where CMS helperdid insert it use string replies whichrequired memory allocation from you oneuse drink and after that since memoryallocation was failed garbage collectioncalled collec garbage and what we can dowe can find scavenge objects law look attext representation command and figureout by way back which JavaScriptfunction required memory allocation andclean at lamps memory so and same ashelper is a problem the same examplewith the product matter which did themap of big array and since it requiredmemory for new items and garbagecollection calledscavenge object and allocation step soas I said we would use itour mappers clones be good JavaScriptcycles and custom helpers and in theresult after that our memory can doesn'tdoesn't grow and garbage collection islittle more than one default millisecondbut we think it's ok and the sameproblem was in in all generation wherehe is a long garbage collection and tofind miss it closures or timers usuallywe use the heap dump we compare them butI'll show you how to do the same withthe core dump in case of fatal errorwhen you get the core dump so what weneed to do we need to get a report ofall JavaScript object inside the memorywe can do it with comment we ate findobjects GS objects and incoming masslarge of incoming messages looksuspicious so let's figure out wherethose requests allocated so we need toget all of them from the memory choosethe first one for example and let take alook where are these request is locatedsothis is a reference from server respondsto requests and from one big array solet's figure out where is this arraylocated and this comment we ate findrevs value and address of this array wecan find the parent object and this isprofile middleware with the requestproperty so we found which object holdsmemory my suggestions controls thelifecycle of objects so you need to knowwhere your object was created and whereto it will be removed trace work ofgarbage collector and if you have ifyou're not sure about the behavior ofJavaScript behavior maybe in case ofclosures you can download and use dwhich is the debug the JavaScript behavior calledJavaScript manually or read a memoryusage test using leakage and create heapdump and core down to investigate andfind the problemso finally we lose performance withgrowth of functionality until it becamecritical for us and after all in allthose improvements we achieved inincreasing our performance by half fromthe original baseline and to prevent asituation like this one you can choosemy tips my suggestions because not GSwas created as a fast performanceplatform and we as end users shoulddevelop fast performance applicationsthat's all thank youyouyou
YouTube URL: https://www.youtube.com/watch?v=y2PRfNsY28w


