Title: Mathias Bynens - V8 internals for JavaScript developers
Publication date: 2018-04-11
Playlist: JSConf AU 2018
Description: 
	This presentation demonstrates how learning just a little bit about JavaScript engine internals can help you improve the run-time performance of your JavaScript code — not just in V8 specifically, but across all JavaScript engines!

I’ll start by explaining how V8 handles arrays behind the scenes, and especially how it can optimize operations on them. I can do all of this with my “JS developer” hat on, i.e. without showing a single line of C++. This knowledge leads to useful insights for JavaScript developers wishing to improve their code’s run-time performance. In the end, the audience will walk away with several practical performance tips, and a deeper understanding of what’s going on under the hood.

Slides: https://slidr.io/mathiasbynens/v8-internals-for-javascript-developers#1
Writeup: https://v8project.blogspot.com.au/2017/09/elements-kinds-in-v8.html
Captions: 
	hi everyone how's it going today we'regonna take a look behind the scenes ofJavaScript engines and specificallywe're gonna take a look at what thatmeans for JavaScript developers like youand I now I work on the vGoogle and vthat's used within Google Chrome butalso note yes and some other projects solet's just initialize this environmentvariable right there and update theslides and there we go yeah sodisclaimer I am going to talk about somevthat all the performance advice thatwill draw from this knowledge appliesnot just to vbrowsers and all JavaScript enginesacross the board and I think that'sreally important so let's get right intoit javascript objects can have arbitraryproperties associated with them thenames of these properties can consist ofalphanumeric characters or even weirdUnicode characters as well but onespecific case that JavaScript enginescan choose to optimize for ourproperties whose names are entirelynumeric more specifically array indexesin vseparately they're treated speciallyalthough in many circumstances theseproperties behave just like otherproperties vseparately from non numeric propertiesfor optimization purposes internally viavthey're called elements so think of itthis way objects have properties andvalues and arrays have indexes that mapto elements it's just the names that weuse in vJavaScript code vkind of elements each array containsthis information allows VA to optimizeany operations on the array specificallyfor this type of elements so for examplewhen you call reduce or map or for eachon an array if yet can use thatinformation to optimize those callsnow take this array for example whatkind of elements does it contain well ifyou were to ask the typeof operator inJavaScript it will tell you that allthese three elements are numbers at theJavaScript languagethat's all you'll get JavaScript doesn'tdistinguish between integers floats anddoubles but behind the scenes in theJavaScript engine itself we can makethis more precise distinction so theelements count for this array is packedmy elements and we'll get to the packedpart in a minute so ignore that for nowfor now focus on the my part in vis a smile refers to the particularformat that we use to store smallintegers that's what it stands for smallinteger later adding a floating-pointnumber to the same array transitions theelements kinds to a more generic versionpacked double elements now adding astring literal to the array changes theelements kind once again velements kind to each array and as we'veseen the elements kind of an array isnot stat in stone it can change atruntime in this case we transitions allthe way from packets my elements topacked elements so far we've seen threedistinct elements kinds there's one forsmize doubles and regular elements youcan think of this as a pyramid becausethe set of numbers that can berepresented as a smile is a subset ofthe numbers that can be represented as adouble and the same thing goes fordoubles versus regular elements butwhat's important here is that theseelement kind transitions can only occurin one direction you go from a veryspecific one like the ones at the top toone that is more general like the onesat the bottom it only goes downwards andonce we transition to packed elementswhich is for regular elements we cannever transition upwards again we cannever go back up to packed doubleelements for example now going back tothat array that we had before the arraycontains five elements what happens ifwe assign a value to do the index thatis far outside of the arrays boundariesfor example if we assign a value atposition nine in the array while doingthis creates holes in the array theholes are at positions five until eightthe array is now sparse or holy as wecall it in vso creating holes in the arraydowngrades the elements guides to it's aholy variant in this case we went frompacked elements to holy elements nowthere are other ways of creating holesfor example if you use the deleteoperator on an indexed element that alsocreates a hole or if you have an arrayliteral and you just forget to assign avalue like for example if you have twocommas and there is no value in betweenthem that would also create a hole sowhy does Fiat care so much about whetherthere's a hole in an array or not whydoes it care so much that it has aseparate elements kind for holes let'sfind out by taking a look at an examplejust pretend that you're a JavaScriptengine for the next couple of minutesokayand you're getting the element at indexeight what's the value for the elementat index eight that's the question thatwe need to answer you can't just givethe answer right away you have to dosome work you have to follow the spec toget the answer so va bounced check on the array index isthis index between zero inclusive andthe length of the array exclusive and inthis case the bounds check succeeds butwe still cannot really answer thequestion of what the result is more workis needed so now we look up the propertynamed eight on the array itself but inthis case that property doesn't existbecause all that's there is a hole so westill cannot answer the question we haveto take a little deeper now because theproperty is not present on the arrayitself we have to grow up the prototypechain until either a value is found orthe prototype chain ends and the firstthing we check in a prototype chain isarray the prototype because that's theprototype for any array and this doesnot have a product this does not have aproperty named this point we still do not know what theanswer is we have to continue to followthe prototype chain now the next item ina prototype chain is object or prototypebecause that's the prototype of a radarprototype and we check if the propertyeight exists there but it doesn't and inthis case the prototype chain ends afterreaching object dot prototypeit could be even longer in case someoneextended it that is a totally validthing to do in JavaScript you can muckwith built-in prototypes and we'd sayit's probably a bad practice but as aJavaScript engine you have to supportthese cases because it can happen in thereal world now in this case because thechain ends we cannot continue searchingfor the property which means we can nowfinally answer our question the hole atposition finally well from a JavaScript enginesperspective that's a lot of work that wejust did just to get an undefined valueright now if you compare that to apacked array which is an array that isguaranteed to have no holes in it itturns out that we don't actually have todo up a lot of this work if the arrayindex is within bounds then theJavaScript engine can already return thevalue no other checks or expensivelookups on the prototype chain areneeded at all now if we go back to aholy array even if we get a propertythat does exist within a holy arraythere's still a bit more work that wehave to do we have to check if theproperty exists first because we knowthere are holes in this array so vhx ifthe index is within the bounds of thearray and it is but it still doesn'thave enough information to return theresults so we must check if the propertyactually exists in the array just incase there is a hole at this position inthis case a property exists so we canfinally return its value now if theproperty didn't exist we would be backin the situation from before where Iwould have to look up prototype chainwhich is very expensive and bad forperformance now this is the very bestcase scenario for a holy array and it'sstill one more operation compared to apacked array and this is why in generalpacked arrays are preferred over holyarrays operations on packed arrays canjust be optimized in a much moreaggressive way than operations on holyarrays for optimal performance youshould try and avoid creating holeswhenever you can so we looked at thispyramid before with this list ofelements kinds there's smize doubles andregular elements and we knew that we cantransitiondownwards throughout this pyramid butnow we learned that it turns out there'sactually two flavors for each of theseelements kinds there's the packedversion and there's a Holi version andnot only can we transition downwards wecan also transition from left to rightwe can go from packed to holy so insteadof two separate pyramids it's probably alittle bit easier to think of elementskinds as a lattice and that is in facthow velements kinds and the transitionsbetween them more concretely it lookssomething like thisso we have our smile double and regularelements and each of those comes in twoflavorsthere's the pact and the holy versionnow these are the most common arrayelements kinds but vabout twenty different elements kindsfor other things like typed arrays aswell and you can only transitiondownwards throughout this lattice it'skind of like that pokemon blue towerpuzzle where all the tiles have like anarrow drawn on the floor and when youstep on a tile you can only move in thatdirection the same goes here you canonly follow the arrows throughout thelattice which means you can never goback up once a single floating-pointnumber is added to an array it is markedas double even if it later consists ofSmiles only and similarly once youcreate a hole in an array it has markedas holy now in general more specificelements kinds enable more fine-grainedoptimizations the further down theelements kindness in this lattice theslower manipulations and operations onthat object might be so for optimalperformance it makes sense to needlesslyto avoid needlessly transitioningbetween these elements kinds and stickto the most specific elements kinds thatapplies to your use case let's look atan example for that for each uniqueelements kind vimage optimizations when performingoperations on the array whenever you'reusing for each for example voptimize this call based on thisknowledge about the elements kind we canhave one set of for each optimizationsspecifically for packets my elementsanother set of optimizations for packeddouble elements and so on and over timewe can add more and more of theseoptimizations so if you look at chromewhen we just shipped a new pipeline invand turbofan our new optimizing compilerand at the time we didn't really doanything special with this informationfor for each so while we renew theelements kinds of these arrays we didn'tspecifically optimize any of theseelements kinds but by the time chrome was released we had optimized for eachin turbofan for all packed elementskinds and more recently in chrome added support for the holy elementskinds as well four for each specificallyso this is a pattern that you'll seerepeated over time over time we will addmore and more fine-grain and specificoptimizations for different elementskinds for specific array functionalityso you could say the same thing aboutrate of prototype dot map for example wesupport all these different elementskinds for map in chrome goes for filter some every reduce reduceright and then there's some other arraymethods like find and find index andthese two are a little bit special ifyou look them up in the spec you'll findthat these Street holes in erase alittle bit differently than all of theother array methods because they turnholes into explicit undefined valueswhich makes things a little bitcomplicated for us and for that reasonwe haven't yet been able to optimize aholy double elements so far but like Isaid before this is something that we'reworking on and over time you can expectto see more green in these lattices forany given array method so very soon itwill look like this now let's look atanother example this piece of codecreates an array of length but what values does the array containit just has three holes in it so thearray is sparse at this point so it getsthe element kind holy smileholy is my elements because that's themost specific possibility given thecurrently available information nowlet's assign a value to position zero inthe array well wait a minute that's astring instead of a small integer so inthis case the elements kinds transitionsto holy elements now we add a valueto position one in the array and theelements kinds remains unchanged in thiscase and finally we sign another valueto the last position in the array now atthis point all three positions in thearray are filled so the array is packedand no longer sparse however we cannottransition to a more specific kind aspacked elements as we saw after we seenearlier so unfortunately the elementskind remains holy elements at this pointonce an array is marked as holy it isholy forever I believe that's howsainthood works as well now in thisscenario a better solution is of courseto use an array literal instead if youknow all the values ahead of time thenwhy not just add them in an arrayliteral but if you don't know all thevalues ahead of time you can still use atechnique that is similar you can startoff with an empty array or with an arraythat contains some of the values thatyou already know and then you can pushmore values to it as you dynamicallycompute them or get them from someexternal source that way you avoidcreating holes in the array at any giventime and the array will never get markedas holy this approach ensures that voptimizes any future operations on thearray to the best of its abilities lifeis easier without poles JavaScriptengines can deal with packed arrays muchmore efficiently in general if you needto perform lots of operations on anarray try and avoid creating holes in itand similarly you should avoid readingbeyond the length of the array becausethere's nothing there anyway so forexample don't write your loops like thisthis loop reads all the elements in thearray and then one more it only stopswhen it finds an undefined or nullelement so this also means that it wouldonly work for arrays that don't containundefined or no now this kind of patternis just as bad as hitting a hole it's adifferent scenario but it's very similarbecause in this case the bounds checkthat we did before fails the check tosee if the property is present fails andthen we need to look up the prototypechain just like before and as we'velearned that is very expensive so don'tdo this and instead keep your loopsimple if you have to write out your ownloop you can dodo it the simple way you can keep trackof the index and keep iterating untilyou hit the last element when thecollection you're looping over isiterable which is the case for arraysand node lists for example then that'seven better you can just use for off andthis is my favorite way of looping overany kind of collection in JavaScriptbecause it's so simple now for arraysspecifically of course you can also usearray dot prototype out for each thatalso works and the good news today isthat whether you want to use for each orwrite your own for loop or use for offperformance-wise it doesn't matteranymore which means you can just makethat decision and pick your favoritewithout performance being a factor inthat decision I think that's prettygreat now avoid creating avoid readingbeyond the end of the array in summaryso doing so is just as bad as hitting ahole now before we move on to some moreperformance advice here's a fun factsjavascript has two zeros there's theregular zero which is positive butthere's also a negative zero andalthough these values are strictly equalto each otherbecause of course why wouldn't they beit turns out that they're actuallyobservably different in some cases andobject op is is an example of thatbecause they behave differentlyit means javascript engines has have tostore these values separately as well indifferent ways and the reason I'mtelling you this is because this has animpact on elements kinds I mentionedearlier that a piece of advice when itcomes to elements kind is to avoidtransitioning to a less specificelements kind whenever you can and thisis actually harder than it seems forexample just adding minus of small integers is enough totransition it to packed double elementsany future operations on this array willnow be optimized in a completelydifferent way and they would be forsmiles specifically so that's just onemore reason to avoid negative general unless of course you need toexplicitly differentiate betweennegative and positive you probably don't now the same thinggoes for nan and infinity these valuesare stored as a doublewhich means that adding a single lamp toan array of smile elements transitionsit to double elements so if you'replanning on performing lots ofoperations on an array of integers youshould consider normalizing the valuesbefore you're adding them to the arrayso normalize minus zero to positive zeroand block-man and infinity when you'reinitializing the values this way thearray sticks to the packets my elementskind and of course there's a one timenormalization cost involved there forall the extra text that you do whenyou're initializing the array but it canbe worth the later optimizations in factif you're doing lots of mathematicaloperations on an array of numbers shouldprobably look into using type arraysbecause vfor those as well and they're kind ofoptimized for this kind of thing ingeneral if you need to perform lots ofoperations on an array try sticking toan elements kind that's as specific aspossible so that vmuch as possible some objects inJavaScript especially in the Dom looklike arrays although there aren't properarrays it's possible to create arraylike objects yourself which is what I'mdoing here this object has a lengthproperty and it supports indexed elementaccess just like a real array but itlacks array methods like for each on itsprototype it's still possible to callthese array methods on this objectthough here we're calling the array foreach built-in on the array like objectand that works as expected however thisis going to be slower than calling arraythan calling for each on a proper arraywhich is highly optimized in vyou plan on using array built-ins onthis object more than onceconsider turning it into an actual arraybeforehand so that voperations to the best of its abilitiesand here we're using slice to do that soof course there is a one-time cost ofdoing the actual slice call but thiscost can be worth the lateroptimizations especially if you plan onperforming lots of operations on thearray and a specific example of this isthe arguments object this is an arraylike object so when you call arraybuilt-in such as for each on it it worksbut it won't be fully up tothat's the way it could be for a properairing so nowadays I think there is abetter solution to this in the form ofesproper arrays that can be used insteadof the array like arguments objects in avery elegant way so nowadays I thinkthere is no good reason to use thearguments object anymoreuse rest parameters it will make yourcode more elegant and more optimizablein various JavaScript engines as wellthis is not a real crocodile and it'snot gonna have the same performance as areal crocodile the same thing goes forarrays in general you should avoid arraylike objects whenever possible and usereal arrays instead now after all thistalk about elements kinds you may bewondering how you can identify theelements kinds of a given array in yourcode base maybe you're debugging aperformance issue or maybe you just wantto have a deeper understanding of whatI'm talking about well you can run youcan compile vbuild and run the dfor developer shell or debug build noone on the vstands for actually it's a mystery D butwhat I do know is that you have to passin the allow native syntax flag doing soenables access to some internal vfunctionality from within JavaScriptit's very powerful especially if youcombine this with a debug build of ventering that command opens up a wrapperwhich is very similar to what you get ifyou just type node on your command lineexcept this way we can run some codedirectly in vsome code first we create the array thatwe want to test and then we call one ofthose special vit in this case debug print and you seehow the name there starts with apercentage sign yeah that's not actuallyvalid JavaScript and the reason why wedo this is because we don't want peopleto use this in production it doesn'tmake sense to use it in production andby making it invalid javascript we kindof force it on people that they cannotuse this in production this would onlywork in this particular built of vanyway so doesn't make sense to try touse it elsewhere now running this codeprints a lot of outputeven more than what is shown here in theslide but in this case what we'relooking for is the elements kind of thearray which is listed on this line theelements kind is holy smile elements cownow that cow does not refer to theanimal it stands for copy-on-write whichis yet another internal optimization butdon't worry about that for now we cantalk about it in another presentation orjust come talk to me laterlet's recap what we've seen so far we'veexplored what elements kinds are and howthey work and as a result we were ableto identify some practical tips that canhelp us boost performance avoid creatingholes in arrays don't access arrayindexes beyond the arrays length try tokeep the elements kind of your array asspecific as possible by sticking to asingle value type for each array avoidusing array like objects and when youhave to use them consider convertingthem into proper arrays beforeperforming any expensive operations onthem now although this presentationcovered some vtips don't just apply to vJavaScript engines can benefit from themas well and by following this advice Iguarantee you that your code is notgoing to get slower in any of the otherengines in fact it will probably getfaster across the board now there is onemore thing that I quickly wanted tomention we went to an example like thisbefore where we have an array and it hassome values in it and if you know thevalues beforehand it makes sense tohard-code them into an array literallike this but things get moreinteresting for larger arrays especiallyif you don't know all the valuesbeforehand maybe you're computing thevalues dynamically or you're fetchingthem from some third party source orwhatever and if you know the length ofthis array ahead of time especially ifthe array is very large it makes senseto pass it through the array constructorlike this and doing so ensures thatJavaScript engines can pre allocatespace for all the array will hold the downside is as we'veseen before that the array will bemarked as holy from the moment it'screated so there's some ups and somedowns here when using the arrayconstructor like thisjavascript engines can pre allocate thespace that they need for the correctnumber of needed elements behind thescenes especially for large arrays thismight speed up the actual creation ofthe array however the array is marked asholy from the beginning so there'spotentially slower array operations onthe array compared to packed arrays itdepends on which you know what you wantto optimize the creation or theoperations of the array to avoid goingholy we discussed this pattern where youstart with an empty array and then asyou get more values you just push themto the array now when you create anarray the JavaScript engine creates abuffer in the backing store to hold allthis array elements and for an emptyarray that we already initialize abuffer of some room to grow now when a new elementis added that doesn't fit in the bufferanymore we have to create a new bufferin the backing store and then copy overall the elements from the old arraybehind the scenes and this is anexpensive operation and this is calledreallocation now if you start off withan empty array for example and then youpush will reallocate the buffer in thebacking store for a total of which is not too bad but this numbergrows as the array gets larger soespecially for large arrays you mightwant to consider this starting from anempty array and continuously pushing toit ensures we never create any holeswhich is good the array remains packedand any future operations on the arraycan be fully optimized but the downsideof continuously pushing to an array thatis continuously pushing to an array isthat behind the scenes engines need toreallocate the space as the array growsall the time and for a large race maybenot elements this might slow down the actualcreation of the array so either youchoose to optimize the array creationitself by using new array passing in thelength if you know it so that it can bepre-allocated behind the scenes or youchoose to optimize the later operationson the array in this case it makes senseto avoid holy elements kinds and it's atrade-off for sure and which of thesetwo you pick dependson the use case that you have in yourspecific code finally the last piece ofadvice I'd like to give is to writemodern idiomatic JavaScript withoutworrying about performance too muchbecause that way JavaScript engines canmake it fast for youthank you[Applause]you
YouTube URL: https://www.youtube.com/watch?v=m9cTaYI95Zc


