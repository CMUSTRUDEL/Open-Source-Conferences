Title: Malte Ubl - Designing very large JavaScript applications
Publication date: 2018-04-11
Playlist: JSConf AU 2018
Description: 
	Over the last years a modular approach to programming in JS gained a huge following and with the advent of virtual DOM building isomorphic JavaScript application for the web became dramatically more approachable; yet, we are still largely deploying monolithic application blobs that know how to render the settings page of our single page apps before accepting user input on the homepage.

My talk will explore 2 primary themes:

How to build highly sophisticated web apps that load a constant amount of JS to make the first page the user sees interactive; where constant means, even if you have 100s of engineers write code for your app for a year, the size will still be the same.
How to throughout the lifecycle of your application never load a single line of JS that is not currently needed.
As part of this exploration I will introduce 3 novel concepts: lazy decoration, asynchronous dependency injection and reverse dependencies in module systems.

Come see my talk if you enjoy nerding out on over-engineering problems, or want to build the next YouTube or Twitter.
Captions: 
	hmm hey other onemy name is Malta this was this were thenested loops who performed last year atJes come for you you should check outthe video it's amazing so manyJavaScript funds in yeah by the way I'm crying forcing theinternet I don't really want to go intowhy that's the case and there's anotherimportant fact about me I used to buildvery large JavaScript applications Idon't actually do that anymore so Ithought it was like a good kind of timeto give a bit of a retrospective andshare what I learned yesterday I washaving a beer and I was asked like heyMalta so what actually gives you theright authority to talk about this topicand I was actually gonna talk about thatanyway because I think it's a bit ontopic usually I think talking aboutyourself is a bit weird so I built thisJavaScript for America at Google andit's used by photos sites plus Driveplay and the search engine and like allthese projects right so I guess but someof them are pretty large you might haveused a few of them and this javascriptfirm work is not open source which issad I guess but I think there's somerelevant things to be learned and thereason why it's not open source isbecause the kind that came out at thesame time is reacting I was like do wereally need another JavaScript frameworklike Java like Google has a few of thoseright there's like angular and polymerand I just thought it would confusepeople and I was like well just keep itto ourselves but I don't think that'sactually all that that's not what thistalk is about anyway so I just have somestuff and I think it's generallyapplicable so let's talk about verylarge application what do they have incommon so certainly that you might havea lot of developers right so it might belike a few dozen or so and so becausethere's no humans humans have feelingsand if problems and you have to factorthat in and even if your team is not asbig maybe you're working on that thingfor a while and maybe you're notactually the first person working onthis you might not have all the contextthat might be stuff that you don'treally understand there might be peoplenow on your team that don't understandeverything that's in the applicationso that's kind of what we have to thinkabout when we want to build these verylarge applications that have maybedifferent properties from us from asmaller oneand another thing I wanted to do here isto give that a bit of a context in termsof everyone's careers so I think many ofus here in the room would maybe considerthemselves a senior engineer or we'renot quite there yet but we want tobecome one and I think that's what thatmeans is you know as a C engineer I kindof think that I would be able to almostsolve every problem that someone softthrows at me right I kind of know mytools and I know my domain and you knowI can I can do things and the otherimportant part of that job is that Imake the junior engineers on my team besenior engineers but what what happensis that at some point we wonder likewhat might be the next step we'vereached that seniority stage what is thenext thing we're going to do and so forsome of us the answer might bemanagement but I don't think that shouldbe the answer for everyone because noteveryone should be a manager right likesome of us really great engineers andwhy don't we do that for the rest of ourlives so I want to propose a way to kindof level up a bit of Buffett's in seniorlevel so the way I would talk aboutmyself as a senior engineers that I saylike I know how I would solve a problemright and because I know how I wouldsolve it I could also teach someone elsehow to solve the problem and so my mytheory is that the next level is that Ican say about myself I know how otherswould solve the problem let's make thisa bit more concrete so you make thatsentence I can anticipate how the APIchoices that I'm making or theabstractions that I'm introducing in aproject how they impact the way otherpeople would solve a problem I thinkthis is a fundamentally like powerfulconcept that allows me to to reasonabout how the choices are making insoftware design how they impact theimplication and I would also call thisan application of empathy right soyou're thinking with other stuffengineers and you're thinking about howwhat you do and the api's that you'regiving them how they impact how theywrite software right luckily this isempathy on easy mode because you knowempathy generally it's hard and this isstill very hard but at least the peoplethat you're having empathy with thereare also other software developers orother software engineers and so whilethey might be very different from youthey at least have in common that theyyou know building software and and Ithink that this is something you can getquite good at all right so thinkingabout these topics there's one veryimportant term we're going to talk aboutwhich is the programming model so whichis the word that I'm going to use a lotwhich means like given a set of API s orset of libraries or set of framework setof toolshow do people write software in thatcontext and so my talk is really abouthow subtle changes in API is and soforth how they impact the programmingmodel I want to give a few examplesabout things that impact the programmodel right so let's say if your angularproject and you're saying like no I'mgonna pop this to react that is awfullygoing to change where people writesoftware right but then you're like ahyou know sex the kilobyte for like thisDom de thing that seems reasonable let'sswitch to pre act and that's an APIcompatible thing it's not going tochange the way people write softwarejust because you make that choice maybethen you're saying like oh this isreally complex I should have likedsomething orchestrating how muchvacation works I'm gonna introduce Reduxthat is going to change how people writesoftware you're then getting thisrequirement we are needing a date pickerand you're going to NPM you search fordate picker there's one doesn't really matter which one youpick will not change how you writesoftware but having npm at yourfingertipsthis vast like you know collection ofmodules having that and being able touse it in your application it doeschange how you write software cool yeahso these are just a few examples aboutlike things how you can impact the waypeople write software now I want to talkabout one aspect that all largeJavaScript applications have in commonwhen you deliver them to users which isthat a venturethey will get so big that you don't wantto like deliver them all at once and forthis which kind of all introduced thistechnique called code splitting whatcode splitting means is that you definea set of bundles for your application sohe's saying like you know me you someusers to use this some users use thatlet's put like a bundle together and I'monly going to load that bundle if thefunction of the application that theuser is actually using is being executedand that's something that every one ofus can can do like many things it wasinvented by closure compiler at least inthe JavaScript world but I think themost popular way of doing code splittingis with a pack and if using for exampleobjects which is super awesome they justrecently a few weeks ago added supportfor this so definitely something y'allshould do but there are some things tothink about when you introduce this toan application because it does haveimpact on the programming model you havethings that used to be sync they nowbecome async so without code splittingthe application is nice and simple it'sone big thing it starts up and then it'sstable and you can assume stuff aboutyou can reason about it you don't haveto wait for stuff with code splittingyou might sometimes say oh I need thatbundle so you know needs to go to thenetwork and you have to affect your inthat this can happen and so yourapplication becomes more complex also wehave humans entering the field becauseCo splitting requires you to like definebundles and it requires you to thinkabout when to load them so these humansengineers on your team they have to nowmake the decisions what is going intowhich bundle and one to load that bundleright and every time you have a humaninvolved that definitely impacts theprogram model because now they have tothink about it now there is one veryestablished way that solves the problemthat gets the human kind of out of thismess when doing code spinning which iscalled route based code splitting andthat is my like if you don't do it yetthat's probably the way how you shoulddo it as a first cut so routes are likethe the baseline URL structures of youokayso my for example in you might have allyour product pages on slash productslash and some IG and you could categorypages somewhere else right and so yourrouter in your application nowunderstands there's code splitting andwhenever you go to a road the routerloads the code and then within thatroute you can forget about Co splittingexisting right now you're back to theprogramming model that was almost thesame as if you had just one big bundlefor everything all right so it's areally nice way to do this anddefinitely a good first step however thetalk title is designing very largeJavaScript applications and they're solarge that sometimes a single routebundle might not you know be feasibleanymore because those those routesitself get to fit very big I actuallyhave a good example for for anapplication that's big enough so I waslike figuring out how to be a publicspeaker coming up to this talk and I getthis like nice list of blue things rightand you could totally envision this pageto be like super wealth you know fittedfor for route based code splittings likesearch slash and there's this list ofstuff and it's not very complicated butthen I wasn't I kind of wondering whatthe weather was because California kindof had a bit of a cold one and so I wassearching over there was Simpsonssuddenly there was completely differentdifferent module right and so thisseemingly simple route of slash searchis more complicated and we thought andthen I was getting invited to thisconference super exciting and I waschecking out how much you know USdollars are in one Australian dollar andthere's this you know complex currencyconverter and so again I think it'sobviously there's like a thousandspecial ones of these right and so it'sinfeasible to say we're going to put allof them in one bundle because then thatbundle is gonna be like a megabyte andpeople are going to be unhappy so wecan't do it that way we have to come upwith a different way of doing it now noroute based coding was nice because it'sa very coarse grain level of yourapplication at the very highest levelyou make that split everything under Icould ignorebecause I like simple stuff if you don'tdo the super course one how about thesuper fine-grained version right let'sthink about what would happen if welaser loaded every single component ofyour website that seems really nice froma like efficiency point of view when youonly think about bandwidth right itmight be like Superbad from other pointof views like latency but it is a niceway of doing it and and and want toconsider but let's imagine for exampleyour application users react in reactcomponents statically depend on theirchildren right and that means that ifyou stop doing that because you startlazy loading your children then itchanges your program model and thingsstop being so nice so let's say you havea Currency Converter component that youwant to put on your such pageyou import it right that's like thenormal way of doing it in your six andthat's pretty nice but if you want tolazy load it you get code like thiswhere you like use dynamic import withjust a new fancy thing to like lazy loadyour six modules and you wrap it intosome load all the component and you knowthere's probably like different ways to do this and I'mcertainly not a reactive program or evenanywhere to expert but like it'sdefinitely going to change how you writethe application and and that's no longerit's nice because stuff you know it'smore complicated something that wasstatic no its dynamics that's anotherred flag for the program we're allchangingyou have to suddenly wonder who decideswhat to lazy load when because that'sgoing to impact the latency of yourapplication the human is there andthey're like they're static import thisdynamic import when do they use whichit's also really bad if you do it wrongbecause one static import is going tolike make everything be together againand you don't really get any benefitsfrom dynamic loading so that's reallycomplicated and it's going to go wrongwhen you have a lot of Engineers overlong periods of time I'm going to talkabout like how Google actually does itand what one way is to achieve like agood programming model with goodperformance and hopefully good resultsso what we're doing iswe take our component we split it byrendering logic the sort of way werender it and the logic of like forexample on the currency converter whathappens when you press the button andyou get you know use the two Australiandollars so we we have these two thingsinstead of one thing and then we onlyload the logic of a page when weactually rendered the component and andthat again is a very simple modelbecause now we can just service atrender a page and then whatever we kindof actually rendered because yousearched for whether and there was abetter module then that rendering of theweather module triggers the client toload the code and again that kind ofputs the human out of the conversationwe get that you know Australian dollaranswer and we have a very simple pagenow this might that might seems nicebut it does have some trade-offs rightso if you know how server-side renderingtypically works with frameworks likereact of UJS or so forth what they do isa process called hydration the wayhydration works is you server-siderendering something and then on theclient you render it again which meansyou have to have load the code to rendersomething that's already on the pagewhich is incredibly wasteful both interms of loading that code and in termsof executing it right so it's a bunch ofwasted bandwidth as a bunch of basic CPUbut it's really nice because because youcan ignore on the clients that thatthese servers I wondered something rightand that is very nice and so if youdesign this very large application youhave to think about do I want to takethat super fast route but it's morecomplex or am i okay with the hydrationapproach which is less efficient butit's so nice for programmers right andso you will have to make this decisionnobody can help you with thatcool my next topic is my favoriteproblem in computer science which is notnaming things although I probably gavethis a bad name and it's not off-by-oneerrorsit's the who here has ever like written some codeand now it's no longer needed but it'sstill on your code base right so maybethere was a or something like that right um so thishappens I think see this particularfamous for it if you have this one bigCSIS file and there's a selector inthere but who really knows that thatstill matches anything in yourapplication you know so you cannot justkeep it there and so I think that'scommunity it's at the forefront of arevolution because they realize this isa problem and they created solutionslike CSS nsj right we have a single filecomponent the component and you like say okay it's notcomponent and then everything is goneand it's very simple so very easy todelete code so I think this is a verybig idea and it should be applied tomore than just CSS so when I give a fewexamples of this like general idea thatyou want to avoid central configurationof your application at all costs becausecentral configuration like havingcentral CSS file makes it very hard toleak code so I was talking before aboutroutes in your application so manyapplication will have a file like routesGS which is all your routes and thenthose routes met themselves to like somebroad component right and that's anexample of central configuration it'ssomething that you do not want in alarge application because now like someengineer says do I still need tech whatcomponent they're like I need to updatethat file but that's like kind of ownedby some other team or something likethat I'm like too scared to do it andI'm maybe I'm going to do that tomorrowor like maybe I don't do it at all rightand so this file it's more like you knowit's edition only people don't tend toget rid of stuff another example of thisanti-pattern is the web pack configdutchy is where you have this one thinglet's assume to build your entireapplication and that you know might gofine for a while but eventually you knowneeding to know about every aspect ofwhat some other team did system whereall right that just doesn't scale soagain I think we need a pattern that hasto emerge how to decentralize configurestuff that we want to build it's notonly bad examples there's good examplesso for example package of JSONvamped npm right each package says Ihave these dependencies this is how yourun me this is how you built me andobviously not like there's not this onegiant configuration file of all of NPMbecause that would not work right youwould you imagine having a hundredthousand modules and you all would haveto edit as one file would definitelygive you a glut of merge conflicts andget right and and so sure NPM is verybig but I would argue that many of ourapplications you know while they're notas big as NPM they get big enough thatwe have to worry about the same stuffand we have to kind of adopt the samepatterns so I don't really have like allthe solutions but I think this you knowthis idea that Jesus and Jes brought tothe table it's going to come to otheraspects of how we build applicationsmore abstractly I would describe thisidea that we take responsibility for howour application is designed in theabstract how it's organized as takingresponsibility of shaping the dependencytree for replication and with dependencyon that now I mean that's like veryabstract like it could be like you knowyes six module dependencies could bedata dependency service dependenciesthere's many ways to have dependenciesso obviously you know we all have likesuper complicated applications but I'mgoing to have a very simple one it hasonly four components there's a routerthat kind of knows how to go from oneaspect of your application to the nextand it has a few word components a B andC now as I mentioned before this is thecentral import problem right because therouter now has to import all the workcomponents and you know if you want todelete one of them you have to go to therouter you have to delete the import ifto delete the road and so forth and thateventually and you with the holidayspecial at Google come up with a solution forthis that I want to introduce to youwhich I don't think we've ever talkedabout it's kind of cool we invented anew concept it's called enhance and it'ssomething you use instead of import andin fact it's the opposite of import itis a reverse dependency so if youenhance a module you make that modulehave a dependency on you which you knowit seems kind of cool so looking at thePennsy graph what happens is thatthere's still the same components butthey the error is no point in theopposite direction right so instead ofthe router importing the the routecomponents the work components announcethemselves using enhance to the rotorthe rock component a says hi router heream please have a dependency on meinstead of the opposite to rate rightand that now means that I can just getrid of the Road component a by deletingthe file and because you know it nolonger enhances the router that's theonly operation have to do to delete thiscomponent and that's really nice itwasn't for the humans to now have tolike think about hmm I have like importof it enhance which one do I use underwhich circumstances right and so theythey suffer from this and I think thisis a particularly bad case of thisbecause imagine just how dangerous it isthat you as a programmer I get the powerto make everyone else every file in thesystem have a dependency on you it'seasy to imagine that this leads toreally bad situations so Google wedecided it's a nice idea but we make itillegal no one gets to use it oneexception which is generated code it's areally good fit for generate codeactually and it solves some of theproblems that generated code has whichis also really niceso with generated code sometimes youhave to import if generate file theycan't even see you have to guess it'sname is really unpleasant if thatgenerated file is just there and the theshadows and enhance that's some centralentity then you don't have theseproblems right you don't you never haveto know but this file it just magicallyenhances the central registry and sothat works really well let's take a lookat a concrete example so we have oursingle file component here and we run acode generator from it and we kind ofextract this little route definitionfile for example maybe use like somestatic declaration and you're saving afile component we parse it out using oursome Harry Potter ast and then we havethat route file rightand that route file just says hey routerum please enhance me and and that's howit works and obviously you can use thispattern for like all kinds of otherthings when you're using like graph QLor like some other thing like that andyou're saying hey my data dependency therouter should know about it and you'redoing the same pattern maybe of someservices whatever right like whateverfancy words you have in computer scienceum so you can you can use this pattern Ithink it works really well it's reallypowerful and I think it has a goodfeature all rightum fortunately this is not everything weneed to know about it there's a secondfavorite problem in computer sciencewhich all I call the base bundle pile oftrash so the base bundle in your likegraph of bundles of the application it'sthe one bundle that whatever you dowhatever the user is doing you willalways load this one bundle and so it'sparticularly important because if it'sbig then everything you'll do is bigright if it's really small then you canhave really small dependent bundlesright still anecdote I at some pointjoined the Google+ Callisterinfrastructure team and I found out thatthe base one had eight hundred kilobytesof JavaScript and so my warning to youis if you want to be more successful inGoogle+ don't have a charge kilobytes ofJavaScript in your base bundle andunfortunately this is very easy right toget to a bad state I'm going to show youa few examples so again your base bundleit needs to like to depend on the routesbecause you always want to know when yougo from A to B what is the route for Bright so it has to be there but what youreally don't want is any form of UIbecause depending where the user comesin there might be different UI so youreally don't want that UI to be thereright and so know the date picker itdefinitely should not be in your datebase bundle right the checkout flowshould not be in your base bundle and sohow do we prevent that rightunfortunately imports are very fragileyou might like innocently import thatcool util packageright because it has a function to makerandom numbers and now someone says Iwon't need a utility for self-drivingcars and suddenly you are like importthe I don't know machine learningalgorithm for self-driving cars and yourbased money like these can happen reallyeasily and because imports aretransitive things can like things canpile up into that pile of trash thesolution we found for this that I thinkis a also very powerful pattern areforbidden dependency tests so forbiddendependency tests are way to sort thatfor example your base bundle does notdepend on any UI let's take a concreteexample so for example in an react everyevery component needs to inherit fromreact component so if you want that youknow UI at all can even your base bundleyou simply add that one test sayingreact component is not the transitivedependency of a base bundle and it willjust fail right so looking at the graphagain you know you just get a testfailure when someone tries to add thedate picker and it's typically like inthat case it's usually really easy tofix it right away because probably thatperson didn't actually want to put itthere which is some weird transitivedependency but if you're like two yearsin and it's been there for a while it'stypically super hard to get the stuffdisentangle so the test really helps youalrightideally though you find like that mostnatural pass right you want to get to astate where whatever the engineers andyour teams do the most straightforwardway to do something is the right wayright so that they don't get off thepass they naturally do the right thingsand then as I just showed with theForbidden depends it has you know justadd a test and I think this is alsosomething that not many people feelempowered to do so please feel empoweredto add tests to your application thatensure the major and variant of yourinfrastructure right the tests are notonly for you know testing that your massfunction does the right things rightthey're also for infrastructure and forthe major like design features ofapplication so please do that and I tryto avoid human judgment outside of theapplication domain Iso if you work on an application we haveto understand the the business part butnot every engineer in your organizationcan and will understand how costbuilding work and they don't need to dothat right so try to introduce thesethings in your application in a way thatit's completely fine you can still workwell without having that knowledge andand all that complexity in your head andthen also really just make it easy tolead code so my talk was calleddesigning very large JavaScriptapplication maybe the web best advice Ican give is that you should ideally notget to this very large stage the bestway to not get there is that you deletestuff before it's too latecool I want to address just one morepoint which is people sometimes say thathaving no abstractions at all it'sbetter than having the wrong wrongabstraction right what this really meansis that the costs of the wrongabstractions is very high so be carefulI think this is sometimes misinterpretedit does not mean that you should have noabstractions again it just means thatyou have to be very careful and so Ithink my main advice is to get good atmaking the right choices right and as Iwas saying at the start of thepresentation the way to get there is tothink with your engineers on your teamhow they will use your API and how theywill use your abstractions you can getthere with experience it will take you awhile I have done this wrong most of thetime and I still do but I think I'mstill getting better and so empathy andexperience the way how you can lead havethe right abstractions in yourapplication thank you very much[Applause]you
YouTube URL: https://www.youtube.com/watch?v=ZZmUwXEiPm4


